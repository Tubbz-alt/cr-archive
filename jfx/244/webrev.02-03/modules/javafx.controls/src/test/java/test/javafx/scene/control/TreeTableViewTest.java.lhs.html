<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/test/java/test/javafx/scene/control/TreeTableViewTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package test.javafx.scene.control;
  27 
  28 import com.sun.javafx.scene.control.TableColumnBaseHelper;
  29 import static test.com.sun.javafx.scene.control.infrastructure.ControlTestUtils.assertStyleClassContains;
  30 import static javafx.scene.control.TreeTableColumn.SortType.ASCENDING;
  31 import static javafx.scene.control.TreeTableColumn.SortType.DESCENDING;
  32 import static org.junit.Assert.*;
  33 import static org.junit.Assert.assertEquals;
  34 
  35 import java.util.ArrayList;
  36 import java.util.Comparator;
  37 import java.util.List;
  38 import java.util.Objects;
  39 import java.util.concurrent.atomic.AtomicInteger;
  40 import java.util.function.Consumer;
  41 import java.util.function.Supplier;
  42 import java.util.stream.Collectors;
  43 
  44 import com.sun.javafx.scene.control.behavior.TreeTableCellBehavior;
  45 import javafx.beans.property.ReadOnlyIntegerWrapper;
  46 import javafx.collections.transformation.FilteredList;
  47 import javafx.scene.control.TableColumn;
  48 import javafx.scene.control.TableView;
  49 import test.com.sun.javafx.scene.control.infrastructure.KeyEventFirer;
  50 import test.com.sun.javafx.scene.control.infrastructure.KeyModifier;
  51 import test.com.sun.javafx.scene.control.infrastructure.MouseEventFirer;
  52 import javafx.scene.control.skin.TreeTableCellSkin;
  53 import test.com.sun.javafx.scene.control.test.Data;
  54 
  55 import javafx.application.Platform;
  56 import javafx.beans.InvalidationListener;
  57 import javafx.beans.Observable;
  58 import javafx.beans.binding.Bindings;
  59 import javafx.beans.binding.ObjectBinding;
  60 import javafx.beans.property.ObjectProperty;
  61 import javafx.beans.property.ReadOnlyBooleanWrapper;
  62 import javafx.beans.property.ReadOnlyObjectWrapper;
  63 import javafx.beans.property.ReadOnlyStringWrapper;
  64 import javafx.beans.property.SimpleObjectProperty;
  65 import javafx.beans.property.SimpleStringProperty;
  66 import javafx.collections.FXCollections;
  67 import javafx.collections.ListChangeListener;
  68 import javafx.collections.ObservableList;
  69 import javafx.event.EventHandler;
  70 import javafx.scene.Group;
  71 import javafx.scene.Node;
  72 import javafx.scene.Scene;
  73 import javafx.scene.control.TreeTableView.TreeTableViewFocusModel;
  74 import javafx.scene.control.cell.*;
  75 import javafx.scene.image.ImageView;
  76 import javafx.scene.input.KeyCode;
  77 import javafx.scene.layout.StackPane;
  78 import javafx.scene.layout.VBox;
  79 import javafx.scene.paint.Color;
  80 import javafx.scene.shape.Circle;
  81 import javafx.scene.shape.Rectangle;
  82 import javafx.stage.Stage;
  83 import javafx.util.Callback;
  84 
  85 import org.junit.Before;
  86 import org.junit.Ignore;
  87 import org.junit.Test;
  88 
  89 import com.sun.javafx.scene.control.TableColumnComparatorBase.TreeTableColumnComparator;
  90 import test.com.sun.javafx.scene.control.infrastructure.ControlTestUtils;
  91 import test.com.sun.javafx.scene.control.infrastructure.StageLoader;
  92 import test.com.sun.javafx.scene.control.infrastructure.VirtualFlowTestUtils;
  93 import com.sun.javafx.scene.control.VirtualScrollBar;
  94 import test.com.sun.javafx.scene.control.test.Person;
  95 import test.com.sun.javafx.scene.control.test.RT_22463_Person;
  96 import com.sun.javafx.tk.Toolkit;
  97 import javafx.scene.control.Button;
  98 import javafx.scene.control.Cell;
  99 import javafx.scene.control.FocusModel;
 100 import javafx.scene.control.IndexedCell;
 101 import javafx.scene.control.MultipleSelectionModel;
 102 import javafx.scene.control.MultipleSelectionModelBaseShim;
 103 import javafx.scene.control.SelectionMode;
 104 import javafx.scene.control.TableColumnBaseShim;
 105 import javafx.scene.control.TableSelectionModel;
 106 import javafx.scene.control.TextField;
 107 import javafx.scene.control.TreeItem;
 108 import javafx.scene.control.TreeTableCell;
 109 import javafx.scene.control.TreeTableCellShim;
 110 import javafx.scene.control.TreeTableColumn;
 111 import javafx.scene.control.TreeTablePosition;
 112 import javafx.scene.control.TreeTableRow;
 113 import javafx.scene.control.TreeTableRowShim;
 114 import javafx.scene.control.TreeTableView;
 115 import javafx.scene.control.TreeTableViewShim;
 116 import javafx.scene.control.TreeView;
 117 
 118 public class TreeTableViewTest {
 119     private TreeTableView&lt;String&gt; treeTableView;
 120     private TreeTableView.TreeTableViewSelectionModel sm;
 121     private TreeTableViewFocusModel&lt;String&gt; fm;
 122 
 123 
 124     // sample data #1
 125     private TreeItem&lt;String&gt; root;
 126     private TreeItem&lt;String&gt; child1;
 127     private TreeItem&lt;String&gt; child2;
 128     private TreeItem&lt;String&gt; child3;
 129 
 130     // sample data #1
 131     private TreeItem&lt;String&gt; myCompanyRootNode;
 132         private TreeItem&lt;String&gt; salesDepartment;
 133             private TreeItem&lt;String&gt; ethanWilliams;
 134             private TreeItem&lt;String&gt; emmaJones;
 135             private TreeItem&lt;String&gt; michaelBrown;
 136             private TreeItem&lt;String&gt; annaBlack;
 137             private TreeItem&lt;String&gt; rodgerYork;
 138             private TreeItem&lt;String&gt; susanCollins;
 139 
 140         private TreeItem&lt;String&gt; itSupport;
 141             private TreeItem&lt;String&gt; mikeGraham;
 142             private TreeItem&lt;String&gt; judyMayer;
 143             private TreeItem&lt;String&gt; gregorySmith;
 144 
 145     @Before public void setup() {
 146         treeTableView = new TreeTableView&lt;String&gt;();
 147         sm = treeTableView.getSelectionModel();
 148         fm = treeTableView.getFocusModel();
 149 
 150         // build sample data #2, even though it may not be used...
 151         myCompanyRootNode = new TreeItem&lt;String&gt;(&quot;MyCompany Human Resources&quot;);
 152         salesDepartment = new TreeItem&lt;String&gt;(&quot;Sales Department&quot;);
 153             ethanWilliams = new TreeItem&lt;String&gt;(&quot;Ethan Williams&quot;);
 154             emmaJones = new TreeItem&lt;String&gt;(&quot;Emma Jones&quot;);
 155             michaelBrown = new TreeItem&lt;String&gt;(&quot;Michael Brown&quot;);
 156             annaBlack = new TreeItem&lt;String&gt;(&quot;Anna Black&quot;);
 157             rodgerYork = new TreeItem&lt;String&gt;(&quot;Rodger York&quot;);
 158             susanCollins = new TreeItem&lt;String&gt;(&quot;Susan Collins&quot;);
 159 
 160         itSupport = new TreeItem&lt;String&gt;(&quot;IT Support&quot;);
 161             mikeGraham = new TreeItem&lt;String&gt;(&quot;Mike Graham&quot;);
 162             judyMayer = new TreeItem&lt;String&gt;(&quot;Judy Mayer&quot;);
 163             gregorySmith = new TreeItem&lt;String&gt;(&quot;Gregory Smith&quot;);
 164 
 165         myCompanyRootNode.getChildren().setAll(
 166             salesDepartment,
 167             itSupport
 168         );
 169         salesDepartment.getChildren().setAll(
 170             ethanWilliams,
 171             emmaJones,
 172             michaelBrown,
 173             annaBlack,
 174             rodgerYork,
 175             susanCollins
 176         );
 177         itSupport.getChildren().setAll(
 178             mikeGraham,
 179             judyMayer,
 180             gregorySmith
 181         );
 182     }
 183 
 184     private void installChildren() {
 185         root = new TreeItem&lt;String&gt;(&quot;Root&quot;);
 186         child1 = new TreeItem&lt;String&gt;(&quot;Child 1&quot;);
 187         child2 = new TreeItem&lt;String&gt;(&quot;Child 2&quot;);
 188         child3 = new TreeItem&lt;String&gt;(&quot;Child 3&quot;);
 189         root.setExpanded(true);
 190         root.getChildren().setAll(child1, child2, child3);
 191         treeTableView.setRoot(root);
 192     }
 193 
 194     private String debug() {
 195         StringBuilder sb = new StringBuilder(&quot;Selected Cells: [&quot;);
 196 
 197         List&lt;TreeTablePosition&lt;?,?&gt;&gt; cells = sm.getSelectedCells();
 198         for (TreeTablePosition cell : cells) {
 199             sb.append(&quot;(&quot;);
 200             sb.append(cell.getRow());
 201             sb.append(&quot;,&quot;);
 202             sb.append(cell.getColumn());
 203             sb.append(&quot;), &quot;);
 204         }
 205 
 206         sb.append(&quot;] \nFocus: &quot; + fm.getFocusedIndex());
 207 //        sb.append(&quot; \nAnchor: &quot; + getAnchor());
 208         return sb.toString();
 209     }
 210 
 211     @Test public void ensureCorrectInitialState() {
 212         installChildren();
 213         assertEquals(0, treeTableView.getRow(root));
 214         assertEquals(1, treeTableView.getRow(child1));
 215         assertEquals(2, treeTableView.getRow(child2));
 216         assertEquals(3, treeTableView.getRow(child3));
 217     }
 218 
 219 
 220 
 221 
 222 
 223 
 224 
 225 
 226     /***************************************************************************
 227      *
 228      *
 229      * Tests taken from TableViewTest
 230      * (scroll down further for the TreeViewTests)
 231      *
 232      *
 233      **************************************************************************/
 234 
 235     /*********************************************************************
 236      * Tests for the constructors                                        *
 237      ********************************************************************/
 238 
 239     @Test public void noArgConstructorSetsNonNullSelectionModel() {
 240         assertNotNull(sm);
 241     }
 242 
 243     @Test public void noArgConstructor_selectedItemIsNull() {
 244         assertNull(sm.getSelectedItem());
 245     }
 246 
 247     @Test public void noArgConstructor_selectedIndexIsNegativeOne() {
 248         assertEquals(-1, sm.getSelectedIndex());
 249     }
 250 
 251     @Test public void noArgConstructorSetsNonNullSortPolicy() {
 252         assertNotNull(treeTableView.getSortPolicy());
 253     }
 254 
 255     @Test public void noArgConstructorSetsNullComparator() {
 256         assertNull(treeTableView.getComparator());
 257     }
 258 
 259     @Test public void noArgConstructorSetsNullOnSort() {
 260         assertNull(treeTableView.getOnSort());
 261     }
 262 
 263 //    @Test public void singleArgConstructorSetsNonNullSelectionModel() {
 264 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 265 //        assertNotNull(b2.getSelectionModel());
 266 //    }
 267 //
 268 //    @Test public void singleArgConstructorAllowsNullItems() {
 269 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(null);
 270 //        assertNull(b2.getItems());
 271 //    }
 272 //
 273 //    @Test public void singleArgConstructorTakesItems() {
 274 //        ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;Hi&quot;);
 275 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(items);
 276 //        assertSame(items, b2.getItems());
 277 //    }
 278 //
 279 //    @Test public void singleArgConstructor_selectedItemIsNull() {
 280 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 281 //        assertNull(b2.getSelectionModel().getSelectedItem());
 282 //    }
 283 //
 284 //    @Test public void singleArgConstructor_selectedIndexIsNegativeOne() {
 285 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 286 //        assertEquals(-1, b2.getSelectionModel().getSelectedIndex());
 287 //    }
 288 
 289     /*********************************************************************
 290      * Tests for columns                                                 *
 291      ********************************************************************/
 292 
 293     @Test public void testColumns() {
 294         TreeTableColumn col1 = new TreeTableColumn();
 295 
 296         assertNotNull(treeTableView.getColumns());
 297         assertEquals(0, treeTableView.getColumns().size());
 298 
 299         treeTableView.getColumns().add(col1);
 300         assertEquals(1, treeTableView.getColumns().size());
 301 
 302         treeTableView.getColumns().remove(col1);
 303         assertEquals(0, treeTableView.getColumns().size());
 304     }
 305 
 306     @Test public void testVisibleLeafColumns() {
 307         TreeTableColumn col1 = new TreeTableColumn();
 308 
 309         assertNotNull(treeTableView.getColumns());
 310         assertEquals(0, treeTableView.getColumns().size());
 311 
 312         treeTableView.getColumns().add(col1);
 313         assertEquals(1, treeTableView.getVisibleLeafColumns().size());
 314 
 315         treeTableView.getColumns().remove(col1);
 316         assertEquals(0, treeTableView.getVisibleLeafColumns().size());
 317     }
 318 
 319     @Test public void testSortOrderCleanup() {
 320         TreeTableView treeTableView = new TreeTableView();
 321         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
 322         first.setCellValueFactory(new PropertyValueFactory(&quot;firstName&quot;));
 323         TreeTableColumn&lt;String,String&gt; second = new TreeTableColumn&lt;String,String&gt;(&quot;second&quot;);
 324         second.setCellValueFactory(new PropertyValueFactory(&quot;lastName&quot;));
 325         treeTableView.getColumns().addAll(first, second);
 326         treeTableView.getSortOrder().setAll(first, second);
 327         treeTableView.getColumns().remove(first);
 328         assertFalse(treeTableView.getSortOrder().contains(first));
 329     }
 330 
 331 
 332     /*********************************************************************
 333      * Tests for new sorting API in JavaFX 8.0                           *
 334      ********************************************************************/
 335 
 336     private TreeItem&lt;String&gt; apple, orange, banana;
 337 
 338     // TODO test for sort policies returning null
 339     // TODO test for changing column sortType out of order
 340 
 341     private static final Callback&lt;TreeTableView&lt;String&gt;, Boolean&gt; NO_SORT_FAILED_SORT_POLICY =
 342             treeTableView1 -&gt; false;
 343 
 344     private static final Callback&lt;TreeTableView&lt;String&gt;, Boolean&gt; SORT_SUCCESS_ASCENDING_SORT_POLICY =
 345             treeTableView1 -&gt; {
 346                 if (treeTableView1.getSortOrder().isEmpty()) return true;
 347                 FXCollections.sort(treeTableView1.getRoot().getChildren(), new Comparator&lt;TreeItem&lt;String&gt;&gt;() {
 348                     @Override public int compare(TreeItem&lt;String&gt; o1, TreeItem&lt;String&gt; o2) {
 349                         return o1.getValue().compareTo(o2.getValue());
 350                     }
 351                 });
 352                 return true;
 353             };
 354 
 355     private TreeTableColumn&lt;String, String&gt; initSortTestStructure() {
 356         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
 357         col.setSortType(ASCENDING);
 358         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
 359         treeTableView.getColumns().add(col);
 360 
 361         TreeItem&lt;String&gt; newRoot = new TreeItem&lt;String&gt;(&quot;root&quot;);
 362         newRoot.setExpanded(true);
 363         newRoot.getChildren().addAll(
 364                 apple  = new TreeItem(&quot;Apple&quot;),
 365                 orange = new TreeItem(&quot;Orange&quot;),
 366                 banana = new TreeItem(&quot;Banana&quot;));
 367 
 368         treeTableView.setRoot(newRoot);
 369 
 370         return col;
 371     }
 372 
 373     private int countSelectedIndexChangeEvent;
 374     private int countSelectedItemChangeEvent;
 375     private int countSelectedIndicesChangeEvent;
 376     private int countSelectedItemsChangeEvent;
<a name="1" id="anc1"></a><span class="line-modified"> 377     private TreeItem&lt;String&gt; selectedItem;</span>
<span class="line-modified"> 378     private List&lt;TreeTablePosition&lt;String,?&gt;&gt; selectedCellsBeforePermutation;</span>


 379 
 380     @Test public void testSelectionUpdatesCorrectlyAfterSort() {
<a name="2" id="anc2"></a><span class="line-modified"> 381         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();</span>
<span class="line-removed"> 382         setupForPermutationTest();</span>
<span class="line-removed"> 383         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);</span>
 384         treeTableView.getSortOrder().add(col);
<a name="3" id="anc3"></a><span class="line-removed"> 385         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);</span>
 386         verifySelectionAfterPermutation();
 387     }
 388 
 389     @Test public void testSelectionUpdatesCorrectlyAfterRootSetAll() {
<a name="4" id="anc4"></a><span class="line-removed"> 390         initSortTestStructure();</span>
 391         setupForPermutationTest();
<a name="5" id="anc5"></a><span class="line-modified"> 392         treeTableView.getRoot().getChildren().setAll(banana, apple, orange);</span>
 393         verifySelectionAfterPermutation();
 394     }
 395 
 396     @Test public void testSelectionUpdatesCorrectlyAfterChildSetAll() {
<a name="6" id="anc6"></a><span class="line-removed"> 397         initSortTestStructure();</span>
 398         setupForPermutationTest();
<a name="7" id="anc7"></a><span class="line-modified"> 399         banana.getChildren().setAll(banana.getChildren().get(2), banana.getChildren().get(0), banana.getChildren().get(1));</span>
 400         verifySelectionAfterPermutation();
 401     }
 402 
<a name="8" id="anc8"></a><span class="line-modified"> 403     private void setupForPermutationTest() {</span>









 404         countSelectedIndexChangeEvent = 0;
 405         countSelectedItemChangeEvent = 0;
 406         countSelectedIndicesChangeEvent = 0;
 407         countSelectedItemsChangeEvent = 0;
 408 
<a name="9" id="anc9"></a><span class="line-modified"> 409         apple.getChildren().addAll(new TreeItem(&quot;Apple3&quot;), new TreeItem(&quot;Apple2&quot;), new TreeItem(&quot;Apple1&quot;));</span>
<span class="line-modified"> 410         apple.setExpanded(true);</span>
<span class="line-modified"> 411         orange.getChildren().addAll(new TreeItem(&quot;Orange3&quot;), new TreeItem(&quot;Orange2&quot;), new TreeItem(&quot;Orange1&quot;));</span>
<span class="line-modified"> 412         orange.setExpanded(true);</span>
<span class="line-modified"> 413         banana.getChildren().addAll(new TreeItem(&quot;Banana3&quot;), new TreeItem(&quot;Banana2&quot;), new TreeItem(&quot;Banana1&quot;));</span>
<span class="line-modified"> 414         banana.setExpanded(true);</span>
































 415 
 416         sm.setSelectionMode(SelectionMode.MULTIPLE);
<a name="10" id="anc10"></a><span class="line-modified"> 417         sm.selectIndices(2, 5, 8, 10);</span>

 418 
 419         // Sanity checks
<a name="11" id="anc11"></a><span class="line-modified"> 420         assertEquals(4, sm.getSelectedIndices().size());</span>
<span class="line-modified"> 421         assertEquals(10, sm.getSelectedIndex());</span>
<span class="line-modified"> 422         assertEquals(treeTableView.getTreeItem(10), sm.getSelectedItem());</span>


 423 
<a name="12" id="anc12"></a><span class="line-modified"> 424         selectedItem = (TreeItem&lt;String&gt;) sm.getSelectedItem();</span>
<span class="line-modified"> 425         selectedCellsBeforePermutation = new ArrayList&lt;&gt;(sm.getSelectedCells());</span>


 426 
 427         sm.selectedIndexProperty().addListener(ov -&gt; {
 428             countSelectedIndexChangeEvent++;
<a name="13" id="anc13"></a>
 429         });
 430         sm.selectedItemProperty().addListener(l -&gt; {
 431             countSelectedItemChangeEvent++;
 432         });
 433         sm.getSelectedIndices().addListener((ListChangeListener) c -&gt; {
 434             countSelectedIndicesChangeEvent++;
<a name="14" id="anc14"></a>





 435         });
 436         sm.getSelectedItems().addListener((ListChangeListener) c -&gt; {
 437             countSelectedItemsChangeEvent++;
<a name="15" id="anc15"></a>





 438         });
<a name="16" id="anc16"></a>

 439     }
 440 
<a name="17" id="anc17"></a><span class="line-modified"> 441     private void verifySelectionAfterPermutation() {</span>
<span class="line-modified"> 442         assertEquals(&quot;Selected index should be updated&quot;, treeTableView.getRow(selectedItem), sm.getSelectedIndex());</span>
<span class="line-modified"> 443         assertEquals(&quot;Selected Item should remain same&quot;, selectedItem, sm.getSelectedItem());</span>
<span class="line-removed"> 444 </span>
<span class="line-removed"> 445         final List&lt;TreeTablePosition&lt;String,?&gt;&gt; selectedCellsAfterPermutation =</span>
<span class="line-removed"> 446                 new ArrayList&lt;&gt;(sm.getSelectedCells());</span>
<span class="line-removed"> 447         assertEquals(&quot;The number of selected items before and after permutation, should remain same&quot;,</span>
<span class="line-removed"> 448                 selectedCellsBeforePermutation.size(), selectedCellsAfterPermutation.size());</span>
<span class="line-removed"> 449         // Verify that the cells that were selected before permutation,</span>
<span class="line-removed"> 450         // remain selected after permutation.</span>
<span class="line-removed"> 451         for (TreeTablePosition beforePos : selectedCellsBeforePermutation) {</span>
 452             boolean isCellStillSelected = false;
<a name="18" id="anc18"></a><span class="line-modified"> 453             for (TreeTablePosition afterPos : selectedCellsAfterPermutation) {</span>
 454                 if ((beforePos.getTreeItem() == afterPos.getTreeItem()) &amp;&amp;
 455                         (beforePos.getTableColumn() == afterPos.getTableColumn()) &amp;&amp;
 456                         (beforePos.getColumn() == afterPos.getColumn())) {
 457                     isCellStillSelected = true;
 458                 }
 459             }
 460             assertTrue(&quot;The item (&quot; + beforePos.getRow() + &quot;, &quot; + beforePos.getColumn() +
 461                     &quot;) lost selection during permutation&quot;, isCellStillSelected);
 462         }
<a name="19" id="anc19"></a>

















 463         assertEquals(1, countSelectedIndexChangeEvent);
 464         assertEquals(0, countSelectedItemChangeEvent);
 465         assertEquals(1, countSelectedIndicesChangeEvent);
 466         assertEquals(1, countSelectedItemsChangeEvent);
<a name="20" id="anc20"></a>






 467     }
 468 
 469     @Ignore(&quot;This test is only valid if sort event consumption should revert changes&quot;)
 470     @Test public void testSortEventCanBeConsumedToStopSortOccurring_changeSortOrderList() {
 471         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 472         treeTableView.setOnSort(event -&gt; {
 473             event.consume();
 474         });
 475 
 476         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 477         treeTableView.getSortOrder().add(col);
 478         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 479 
 480         // the sort order list should be returned back to its original state
 481         assertTrue(treeTableView.getSortOrder().isEmpty());
 482     }
 483 
 484     @Test public void testSortEventCanBeNotConsumedToAllowSortToOccur_changeSortOrderList() {
 485         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 486         treeTableView.setOnSort(event -&gt; {
 487             // do not consume here - this allows the sort to happen
 488         });
 489 
 490         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 491         treeTableView.getSortOrder().add(col);
 492         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 493 
 494         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 495     }
 496 
 497     @Ignore(&quot;This test is only valid if sort event consumption should revert changes&quot;)
 498     @Test public void testSortEventCanBeConsumedToStopSortOccurring_changeColumnSortType_AscendingToDescending() {
 499         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 500         assertEquals(ASCENDING, col.getSortType());
 501         treeTableView.getSortOrder().add(col);
 502         treeTableView.setOnSort(event -&gt; {
 503             event.consume();
 504         });
 505 
 506         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 507 
 508         // when we change from ASCENDING to DESCENDING we don&#39;t expect the sort
 509         // to actually change (and in fact we expect the sort type to resort
 510         // back to being ASCENDING)
 511         col.setSortType(DESCENDING);
 512         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 513         assertEquals(ASCENDING, col.getSortType());
 514 
 515         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 516     }
 517 
 518     @Test public void testSortEventCanBeNotConsumedToAllowSortToOccur_changeColumnSortType_AscendingToDescending() {
 519         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 520         assertEquals(ASCENDING, col.getSortType());
 521         treeTableView.getSortOrder().add(col);
 522         treeTableView.setOnSort(event -&gt; {
 523             // do not consume here - this allows the sort to happen
 524         });
 525 
 526         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 527 
 528         col.setSortType(DESCENDING);
 529         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 530         assertEquals(DESCENDING, col.getSortType());
 531 
 532         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 533     }
 534 
 535     @Ignore(&quot;This test is only valid if sort event consumption should revert changes&quot;)
 536     @Test public void testSortEventCanBeConsumedToStopSortOccurring_changeColumnSortType_DescendingToNull() {
 537         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 538         col.setSortType(DESCENDING);
 539         assertEquals(DESCENDING, col.getSortType());
 540         treeTableView.getSortOrder().add(col);
 541         treeTableView.setOnSort(event -&gt; {
 542             event.consume();
 543         });
 544 
 545         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 546 
 547         col.setSortType(null);
 548         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 549         assertEquals(DESCENDING, col.getSortType());
 550 
 551         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 552     }
 553 
 554     @Test public void testSortEventCanBeNotConsumedToAllowSortToOccur_changeColumnSortType_DescendingToNull() {
 555         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 556         col.setSortType(DESCENDING);
 557         assertEquals(DESCENDING, col.getSortType());
 558         treeTableView.getSortOrder().add(col);
 559         treeTableView.setOnSort(event -&gt; {
 560             // do not consume here - this allows the sort to happen
 561         });
 562 
 563         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 564 
 565         col.setSortType(null);
 566         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 567         assertNull(col.getSortType());
 568 
 569         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 570     }
 571 
 572     @Ignore(&quot;This test is only valid if sort event consumption should revert changes&quot;)
 573     @Test public void testSortEventCanBeConsumedToStopSortOccurring_changeColumnSortType_NullToAscending() {
 574         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 575         col.setSortType(null);
 576         assertNull(col.getSortType());
 577         treeTableView.getSortOrder().add(col);
 578         treeTableView.setOnSort(event -&gt; {
 579             event.consume();
 580         });
 581 
 582         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 583 
 584         col.setSortType(ASCENDING);
 585         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 586         assertNull(col.getSortType());
 587 
 588         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 589     }
 590 
 591     @Test public void testSortEventCanBeNotConsumedToAllowSortToOccur_changeColumnSortType_NullToAscending() {
 592         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 593         col.setSortType(null);
 594         assertNull(col.getSortType());
 595         treeTableView.getSortOrder().add(col);
 596         treeTableView.setOnSort(event -&gt; {
 597             // do not consume here - this allows the sort to happen
 598         });
 599 
 600         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 601 
 602         col.setSortType(ASCENDING);
 603         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 604         assertEquals(ASCENDING, col.getSortType());
 605 
 606         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 607     }
 608 
 609     @Test public void testSortMethodWithNullSortPolicy() {
 610         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 611         treeTableView.setSortPolicy(null);
 612         assertNull(treeTableView.getSortPolicy());
 613         treeTableView.sort();
 614     }
 615 
 616     @Test public void testChangingSortPolicyUpdatesItemsList() {
 617         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 618         col.setSortType(DESCENDING);
 619         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 620         treeTableView.getSortOrder().add(col);
 621         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 622         treeTableView.setSortPolicy(SORT_SUCCESS_ASCENDING_SORT_POLICY);
 623         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 624     }
 625 
 626     @Test public void testChangingSortPolicyDoesNotUpdateItemsListWhenTheSortOrderListIsEmpty() {
 627         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 628         col.setSortType(DESCENDING);
 629         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 630 
 631         treeTableView.setSortPolicy(SORT_SUCCESS_ASCENDING_SORT_POLICY);
 632         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 633     }
 634 
 635     @Test public void testFailedSortPolicyBacksOutLastChange_sortOrderAddition() {
 636         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 637         col.setSortType(DESCENDING);
 638         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 639         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 640 
 641         treeTableView.getSortOrder().add(col);
 642 
 643         // no sort should be run (as we have a custom sort policy), and the
 644         // sortOrder list should be empty as the sortPolicy failed
 645         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 646         assertTrue(treeTableView.getSortOrder().isEmpty());
 647     }
 648 
 649     @Test public void testFailedSortPolicyBacksOutLastChange_sortOrderRemoval() {
 650         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 651         col.setSortType(DESCENDING);
 652         treeTableView.getSortOrder().add(col);
 653         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 654 
 655         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 656 
 657         // even though we remove the column from the sort order here, because the
 658         // sort policy fails the items list should remain unchanged and the sort
 659         // order list should continue to have the column in it.
 660         treeTableView.getSortOrder().remove(col);
 661         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 662         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 663     }
 664 
 665     @Test public void testFailedSortPolicyBacksOutLastChange_sortTypeChange_ascendingToDescending() {
 666         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 667         col.setSortType(ASCENDING);
 668         treeTableView.getSortOrder().add(col);
 669         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 670 
 671         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 672 
 673         col.setSortType(DESCENDING);
 674         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 675         assertEquals(ASCENDING, col.getSortType());
 676     }
 677 
 678     @Test public void testFailedSortPolicyBacksOutLastChange_sortTypeChange_descendingToNull() {
 679         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 680         col.setSortType(DESCENDING);
 681         treeTableView.getSortOrder().add(col);
 682         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 683 
 684         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 685 
 686         col.setSortType(null);
 687         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 688         assertEquals(DESCENDING, col.getSortType());
 689     }
 690 
 691     @Test public void testFailedSortPolicyBacksOutLastChange_sortTypeChange_nullToAscending() {
 692         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 693         col.setSortType(null);
 694         treeTableView.getSortOrder().add(col);
 695         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 696 
 697         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 698 
 699         col.setSortType(ASCENDING);
 700         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 701         assertNull(col.getSortType());
 702     }
 703 
 704     @Test public void testComparatorChangesInSyncWithSortOrder_1() {
 705         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 706         assertNull(treeTableView.getComparator());
 707         assertTrue(treeTableView.getSortOrder().isEmpty());
 708 
 709         treeTableView.getSortOrder().add(col);
 710         TreeTableColumnComparator c = (TreeTableColumnComparator)treeTableView.getComparator();
 711         assertNotNull(c);
 712         VirtualFlowTestUtils.assertListContainsItemsInOrder(c.getColumns(), col);
 713     }
 714 
 715     @Test public void testComparatorChangesInSyncWithSortOrder_2() {
 716         // same as test above
 717         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 718         assertNull(treeTableView.getComparator());
 719         assertTrue(treeTableView.getSortOrder().isEmpty());
 720 
 721         treeTableView.getSortOrder().add(col);
 722         TreeTableColumnComparator c = (TreeTableColumnComparator)treeTableView.getComparator();
 723         assertNotNull(c);
 724         VirtualFlowTestUtils.assertListContainsItemsInOrder(c.getColumns(), col);
 725 
 726         // now remove column from sort order, and the comparator should go to
 727         // being null
 728         treeTableView.getSortOrder().remove(col);
 729         assertNull(treeTableView.getComparator());
 730     }
 731 
 732     @Test public void testFailedSortPolicyBacksOutComparatorChange_sortOrderAddition() {
 733         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 734         final TreeTableColumnComparator oldComparator = (TreeTableColumnComparator)treeTableView.getComparator();
 735 
 736         col.setSortType(DESCENDING);
 737         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 738         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 739 
 740         treeTableView.getSortOrder().add(col);
 741 
 742         assertEquals(oldComparator, treeTableView.getComparator());
 743     }
 744 
 745     @Test public void testFailedSortPolicyBacksOutComparatorChange_sortOrderRemoval() {
 746         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 747         TreeTableColumnComparator oldComparator = (TreeTableColumnComparator)treeTableView.getComparator();
 748         assertNull(oldComparator);
 749 
 750         col.setSortType(DESCENDING);
 751         treeTableView.getSortOrder().add(col);
 752         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 753         oldComparator = (TreeTableColumnComparator)treeTableView.getComparator();
 754         VirtualFlowTestUtils.assertListContainsItemsInOrder(oldComparator.getColumns(), col);
 755 
 756         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 757         treeTableView.getSortOrder().remove(col);
 758 
 759         assertTrue(treeTableView.getSortOrder().contains(col));
 760         VirtualFlowTestUtils.assertListContainsItemsInOrder(oldComparator.getColumns(), col);
 761     }
 762 
 763     @Test public void testFailedSortPolicyBacksOutComparatorChange_sortTypeChange() {
 764         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 765         final TreeTableColumnComparator oldComparator = (TreeTableColumnComparator)treeTableView.getComparator();
 766         assertNull(oldComparator);
 767 
 768         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 769         treeTableView.getSortOrder().add(col);
 770         col.setSortType(ASCENDING);
 771 
 772         assertTrue(treeTableView.getSortOrder().isEmpty());
 773         assertNull(oldComparator);
 774     }
 775 
 776 
 777 
 778     /*********************************************************************
 779      * Tests for specific bugs                                           *
 780      ********************************************************************/
 781 //    @Test public void test_rt16019() {
 782 //        // RT-16019: NodeMemory TableView tests fail with
 783 //        // IndexOutOfBoundsException (ObservableListWrapper.java:336)
 784 //        TreeTableView treeTableView = new TreeTableView();
 785 //        for (int i = 0; i &lt; 1000; i++) {
 786 //            treeTableView.getItems().add(&quot;data &quot; + i);
 787 //        }
 788 //    }
 789 //
 790 //    @Test public void test_rt15793() {
 791 //        // ListView/TableView selectedIndex is 0 although the items list is empty
 792 //        final TreeTableView tv = new TreeTableView();
 793 //        final ObservableList list = FXCollections.observableArrayList();
 794 //        tv.setItems(list);
 795 //        list.add(&quot;toto&quot;);
 796 //        tv.getSelectionModel().select(0);
 797 //        assertEquals(0, tv.getSelectionModel().getSelectedIndex());
 798 //        list.remove(0);
 799 //        assertEquals(-1, tv.getSelectionModel().getSelectedIndex());
 800 //    }
 801 //
 802 //    @Test public void test_rt17522_focusShouldMoveWhenItemAddedAtFocusIndex() {
 803 //        final TreeTableView lv = new TreeTableView();
 804 //        FocusModel fm = lv.getFocusModel();
 805 //        lv.getItems().add(&quot;row1&quot;);
 806 //        fm.focus(0);
 807 //        assertTrue(fm.isFocused(0));
 808 //
 809 //        lv.getItems().add(0, &quot;row0&quot;);
 810 //        assertTrue(fm.isFocused(1));
 811 //    }
 812 //
 813 //    @Test public void test_rt17522_focusShouldMoveWhenItemAddedBeforeFocusIndex() {
 814 //        final TreeTableView lv = new TreeTableView();
 815 //        FocusModel fm = lv.getFocusModel();
 816 //        lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
 817 //        fm.focus(1);
 818 //        assertTrue(fm.isFocused(1));
 819 //        assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 820 //
 821 //        lv.getItems().add(1, &quot;row0&quot;);
 822 //        assertTrue(fm.isFocused(2));
 823 //        assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 824 //        assertFalse(fm.isFocused(1));
 825 //    }
 826 //
 827 //    @Test public void test_rt17522_focusShouldNotMoveWhenItemAddedAfterFocusIndex() {
 828 //        final TreeTableView lv = new TreeTableView();
 829 //        FocusModel fm = lv.getFocusModel();
 830 //        lv.getItems().addAll(&quot;row1&quot;);
 831 //        fm.focus(0);
 832 //        assertTrue(fm.isFocused(0));
 833 //        assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 834 //
 835 //        lv.getItems().add(1, &quot;row2&quot;);
 836 //        assertTrue(fm.isFocused(0));
 837 //        assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 838 //        assertFalse(fm.isFocused(1));
 839 //    }
 840 //
 841 //    @Test public void test_rt17522_focusShouldBeResetWhenFocusedItemIsRemoved() {
 842 //        final TreeTableView lv = new TreeTableView();
 843 //        FocusModel fm = lv.getFocusModel();
 844 //        lv.getItems().add(&quot;row1&quot;);
 845 //        fm.focus(0);
 846 //        assertTrue(fm.isFocused(0));
 847 //
 848 //        lv.getItems().remove(&quot;row1&quot;);
 849 //        assertTrue(fm.getFocusedIndex() == -1);
 850 //        assertNull(fm.getFocusedItem());
 851 //    }
 852 //
 853 //    @Test public void test_rt17522_focusShouldMoveWhenItemRemovedBeforeFocusIndex() {
 854 //        final TreeTableView lv = new TreeTableView();
 855 //        FocusModel fm = lv.getFocusModel();
 856 //        lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
 857 //        fm.focus(1);
 858 //        assertTrue(fm.isFocused(1));
 859 //        assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 860 //
 861 //        lv.getItems().remove(&quot;row1&quot;);
 862 //        assertTrue(fm.isFocused(0));
 863 //        assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 864 //    }
 865 //
 866 //    @Test public void test_rt17522_focusShouldNotMoveWhenItemRemovedAfterFocusIndex() {
 867 //        final TreeTableView lv = new TreeTableView();
 868 //        FocusModel fm = lv.getFocusModel();
 869 //        lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
 870 //        fm.focus(0);
 871 //        assertTrue(fm.isFocused(0));
 872 //        assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 873 //
 874 //        lv.getItems().remove(&quot;row2&quot;);
 875 //        assertTrue(fm.isFocused(0));
 876 //        assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 877 //    }
 878 //
 879 //    @Test public void test_rt18385() {
 880 //        treeTableView.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;);
 881 //        sm.select(1);
 882 //        treeTableView.getItems().add(&quot;Another Row&quot;);
 883 //        assertEquals(1, sm.getSelectedIndices().size());
 884 //        assertEquals(1, sm.getSelectedItems().size());
 885 //        assertEquals(1, sm.getSelectedCells().size());
 886 //    }
 887 
 888     @Test public void test_rt18339_onlyEditWhenTableViewIsEditable_tableEditableIsFalse_columnEditableIsFalse() {
 889         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
 890         first.setEditable(false);
 891         treeTableView.getColumns().add(first);
 892         treeTableView.setEditable(false);
 893         treeTableView.edit(1, first);
 894         assertEquals(null, treeTableView.getEditingCell());
 895     }
 896 
 897     @Test public void test_rt18339_onlyEditWhenTableViewIsEditable_tableEditableIsFalse_columnEditableIsTrue() {
 898         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
 899         first.setEditable(true);
 900         treeTableView.getColumns().add(first);
 901         treeTableView.setEditable(false);
 902         treeTableView.edit(1, first);
 903         assertEquals(null, treeTableView.getEditingCell());
 904     }
 905 
 906     @Test public void test_rt18339_onlyEditWhenTableViewIsEditable_tableEditableIsTrue_columnEditableIsFalse() {
 907         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
 908         first.setEditable(false);
 909         treeTableView.getColumns().add(first);
 910         treeTableView.setEditable(true);
 911         treeTableView.edit(1, first);
 912         assertEquals(null, treeTableView.getEditingCell());
 913     }
 914 
 915     @Test public void test_rt18339_onlyEditWhenTableViewIsEditable_tableEditableIsTrue_columnEditableIsTrue() {
 916         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
 917         first.setEditable(true);
 918         treeTableView.getColumns().add(first);
 919         treeTableView.setEditable(true);
 920         treeTableView.edit(1, first);
 921         assertEquals(new TreeTablePosition(treeTableView, 1, first), treeTableView.getEditingCell());
 922     }
 923 
 924 //    @Test public void test_rt14451() {
 925 //        treeTableView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 926 //        sm.setSelectionMode(SelectionMode.MULTIPLE);
 927 //        sm.selectRange(0, 2); // select from 0 (inclusive) to 2 (exclusive)
 928 //        assertEquals(2, sm.getSelectedIndices().size());
 929 //    }
 930 //
 931 //    @Test public void test_rt21586() {
 932 //        treeTableView.getItems().setAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 933 //        treeTableView.getSelectionModel().select(1);
 934 //        assertEquals(1, treeTableView.getSelectionModel().getSelectedIndex());
 935 //        assertEquals(&quot;Orange&quot;, treeTableView.getSelectionModel().getSelectedItem());
 936 //
 937 //        treeTableView.getItems().setAll(&quot;Kiwifruit&quot;, &quot;Pineapple&quot;, &quot;Grape&quot;);
 938 //        assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
 939 //        assertNull(treeTableView.getSelectionModel().getSelectedItem());
 940 //    }
 941 
 942 
 943 
 944 
 945 
 946 
 947 
 948 
 949 
 950 
 951 
 952 
 953 
 954 
 955 
 956     /***************************************************************************
 957      *
 958      *
 959      * Tests taken from TreeViewTest
 960      *
 961      *
 962      **************************************************************************/
 963 
 964 
 965 
 966 
 967     /*********************************************************************
 968      * Tests for the constructors                                        *
 969      ********************************************************************/
 970 
 971     @Test public void noArgConstructorSetsTheStyleClass() {
 972         assertStyleClassContains(treeTableView, &quot;tree-table-view&quot;);
 973     }
 974 
 975     @Test public void noArgConstructorSetsNullItems() {
 976         assertNull(treeTableView.getRoot());
 977     }
 978 
 979     @Test public void singleArgConstructorSetsTheStyleClass() {
 980         final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(new TreeItem&lt;String&gt;(&quot;Hi&quot;));
 981         assertStyleClassContains(b2, &quot;tree-table-view&quot;);
 982     }
 983 
 984     /*********************************************************************
 985      * Tests for selection model                                         *
 986      ********************************************************************/
 987 
 988     @Test public void selectionModelCanBeNull() {
 989         treeTableView.setSelectionModel(null);
 990         assertNull(treeTableView.getSelectionModel());
 991     }
 992 
 993     @Test public void selectionModelCanBeBound() {
 994         TableSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm =
 995                 TreeTableViewShim.&lt;String&gt;get_TreeTableViewArrayListSelectionModel(treeTableView);
 996         ObjectProperty&lt;TreeTableView.TreeTableViewSelectionModel&lt;String&gt;&gt; other =
 997                 new SimpleObjectProperty(sm);
 998         treeTableView.selectionModelProperty().bind(other);
 999         assertSame(sm, treeTableView.getSelectionModel());
1000     }
1001 
1002     @Test public void selectionModelCanBeChanged() {
1003         TableSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm =
1004                 TreeTableViewShim.&lt;String&gt;get_TreeTableViewArrayListSelectionModel(treeTableView);
1005         TreeTableViewShim.&lt;String&gt;setSelectionModel(treeTableView, sm);
1006         assertSame(sm, treeTableView.getSelectionModel());
1007     }
1008 
1009     @Test public void canSetSelectedItemToAnItemEvenWhenThereAreNoItems() {
1010         TreeItem&lt;String&gt; element = new TreeItem&lt;String&gt;(&quot;I AM A CRAZY RANDOM STRING&quot;);
1011         treeTableView.getSelectionModel().select(element);
1012         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1013         assertSame(element, treeTableView.getSelectionModel().getSelectedItem());
1014     }
1015 
1016     @Test public void canSetSelectedItemToAnItemNotInTheDataModel() {
1017         installChildren();
1018         TreeItem&lt;String&gt; element = new TreeItem&lt;String&gt;(&quot;I AM A CRAZY RANDOM STRING&quot;);
1019         treeTableView.getSelectionModel().select(element);
1020         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1021         assertSame(element, treeTableView.getSelectionModel().getSelectedItem());
1022     }
1023 
1024     @Test public void settingTheSelectedItemToAnItemInItemsResultsInTheCorrectSelectedIndex() {
1025         installChildren();
1026         treeTableView.getSelectionModel().select(child1);
1027         assertEquals(1, treeTableView.getSelectionModel().getSelectedIndex());
1028         assertSame(child1, treeTableView.getSelectionModel().getSelectedItem());
1029     }
1030 
1031     @Ignore(&quot;Not yet supported&quot;)
1032     @Test public void settingTheSelectedItemToANonexistantItemAndThenSettingItemsWhichContainsItResultsInCorrectSelectedIndex() {
1033         treeTableView.getSelectionModel().select(child1);
1034         installChildren();
1035         assertEquals(1, treeTableView.getSelectionModel().getSelectedIndex());
1036         assertSame(child1, treeTableView.getSelectionModel().getSelectedItem());
1037     }
1038 
1039     @Ignore(&quot;Not yet supported&quot;)
1040     @Test public void ensureSelectionClearsWhenAllItemsAreRemoved_selectIndex0() {
1041         installChildren();
1042         treeTableView.getSelectionModel().select(0);
1043         treeTableView.setRoot(null);
1044         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1045         assertEquals(null, treeTableView.getSelectionModel().getSelectedItem());
1046     }
1047 
1048     @Ignore(&quot;Not yet supported&quot;)
1049     @Test public void ensureSelectionClearsWhenAllItemsAreRemoved_selectIndex2() {
1050         installChildren();
1051         treeTableView.getSelectionModel().select(2);
1052         treeTableView.setRoot(null);
1053         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1054         assertEquals(null, treeTableView.getSelectionModel().getSelectedItem());
1055     }
1056 
1057     @Ignore(&quot;Not yet supported&quot;)
1058     @Test public void ensureSelectedItemRemainsAccurateWhenItemsAreCleared() {
1059         installChildren();
1060         treeTableView.getSelectionModel().select(2);
1061         treeTableView.setRoot(null);
1062         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1063         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1064 
1065         TreeItem&lt;String&gt; newRoot = new TreeItem&lt;String&gt;(&quot;New Root&quot;);
1066         TreeItem&lt;String&gt; newChild1 = new TreeItem&lt;String&gt;(&quot;New Child 1&quot;);
1067         TreeItem&lt;String&gt; newChild2 = new TreeItem&lt;String&gt;(&quot;New Child 2&quot;);
1068         TreeItem&lt;String&gt; newChild3 = new TreeItem&lt;String&gt;(&quot;New Child 3&quot;);
1069         newRoot.setExpanded(true);
1070         newRoot.getChildren().setAll(newChild1, newChild2, newChild3);
1071         treeTableView.setRoot(root);
1072 
1073         treeTableView.getSelectionModel().select(2);
1074         assertEquals(newChild2, treeTableView.getSelectionModel().getSelectedItem());
1075     }
1076 
1077     @Test public void ensureSelectionIsCorrectWhenItemsChange() {
1078         installChildren();
1079         treeTableView.getSelectionModel().select(0);
1080         assertEquals(root, treeTableView.getSelectionModel().getSelectedItem());
1081 
1082         TreeItem newRoot = new TreeItem&lt;String&gt;(&quot;New Root&quot;);
1083         treeTableView.setRoot(newRoot);
1084         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1085         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1086         assertEquals(0, treeTableView.getFocusModel().getFocusedIndex());
1087         assertEquals(newRoot, treeTableView.getFocusModel().getFocusedItem());
1088     }
1089 
1090     @Test public void ensureSelectionRemainsOnBranchWhenExpanded() {
1091         installChildren();
1092         root.setExpanded(false);
1093         treeTableView.getSelectionModel().select(0);
1094         assertTrue(treeTableView.getSelectionModel().isSelected(0));
1095         root.setExpanded(true);
1096         assertTrue(treeTableView.getSelectionModel().isSelected(0));
1097         assertTrue(treeTableView.getSelectionModel().getSelectedItems().contains(root));
1098     }
1099 
1100     /*********************************************************************
1101      * Tests for misc                                                    *
1102      ********************************************************************/
1103     @Test public void ensureRootIndexIsZeroWhenRootIsShowing() {
1104         installChildren();
1105         assertEquals(0, treeTableView.getRow(root));
1106     }
1107 
1108     @Test public void ensureRootIndexIsNegativeOneWhenRootIsNotShowing() {
1109         installChildren();
1110         treeTableView.setShowRoot(false);
1111         assertEquals(-1, treeTableView.getRow(root));
1112     }
1113 
1114     @Test public void ensureCorrectIndexWhenRootTreeItemHasParent() {
1115         installChildren();
1116         treeTableView.setRoot(child1);
1117         assertEquals(-1, treeTableView.getRow(root));
1118         assertEquals(0, treeTableView.getRow(child1));
1119         assertEquals(1, treeTableView.getRow(child2));
1120         assertEquals(2, treeTableView.getRow(child3));
1121     }
1122 
1123     @Test public void ensureCorrectIndexWhenRootTreeItemHasParentAndRootIsNotShowing() {
1124         installChildren();
1125         treeTableView.setRoot(child1);
1126         treeTableView.setShowRoot(false);
1127 
1128         // despite the fact there are children in this tree, in reality none are
1129         // visible as the root node has no children (only siblings), and the
1130         // root node is not visible.
1131         assertEquals(0, treeTableView.getExpandedItemCount());
1132 
1133         assertEquals(-1, treeTableView.getRow(root));
1134         assertEquals(-1, treeTableView.getRow(child1));
1135         assertEquals(-1, treeTableView.getRow(child2));
1136         assertEquals(-1, treeTableView.getRow(child3));
1137     }
1138 
1139     @Test public void ensureCorrectIndexWhenRootTreeItemIsCollapsed() {
1140         installChildren();
1141         root.setExpanded(false);
1142         assertEquals(0, treeTableView.getRow(root));
1143 
1144         // note that the indices are negative, as these children rows are not
1145         // visible in the tree
1146         assertEquals(-1, treeTableView.getRow(child1));
1147         assertEquals(-1, treeTableView.getRow(child2));
1148         assertEquals(-1, treeTableView.getRow(child3));
1149     }
1150 
1151 //    @Test public void removingLastTest() {
1152 //        TreeTableView tree_view = new TreeTableView();
1153 //        MultipleSelectionModel sm = tree_view.getSelectionModel();
1154 //        TreeItem&lt;String&gt; tree_model = new TreeItem&lt;String&gt;(&quot;Root&quot;);
1155 //        TreeItem node = new TreeItem(&quot;Data item&quot;);
1156 //        tree_model.getChildren().add(node);
1157 //        tree_view.setRoot(tree_model);
1158 //        tree_model.setExpanded(true);
1159 //        // select the &#39;Data item&#39; in the selection model
1160 //        sm.select(tree_model.getChildren().get(0));
1161 //        // remove the &#39;Data item&#39; from the root node
1162 //        tree_model.getChildren().remove(sm.getSelectedItem());
1163 //        // assert the there are no selected items any longer
1164 //        assertTrue(&quot;items: &quot; + sm.getSelectedItem(), sm.getSelectedItems().isEmpty());
1165 //    }
1166 
1167     /*********************************************************************
1168      * Tests from bug reports                                            *
1169      ********************************************************************/
1170     @Ignore @Test public void test_rt17112() {
1171         TreeItem&lt;String&gt; root1 = new TreeItem&lt;String&gt;(&quot;Root&quot;);
1172         root1.setExpanded(true);
1173         addChildren(root1, &quot;child&quot;);
1174         for (TreeItem child : root1.getChildren()) {
1175             addChildren(child, (String)child.getValue());
1176             child.setExpanded(true);
1177         }
1178 
1179         final TreeTableView treeTableView1 = new TreeTableView();
1180         final MultipleSelectionModel sm = treeTableView1.getSelectionModel();
1181         sm.setSelectionMode(SelectionMode.MULTIPLE);
1182         treeTableView1.setRoot(root1);
1183 
1184         final TreeItem&lt;String&gt; rt17112_child1 = root1.getChildren().get(1);
1185         final TreeItem&lt;String&gt; rt17112_child1_0 = rt17112_child1.getChildren().get(0);
1186         final TreeItem&lt;String&gt; rt17112_child2 = root1.getChildren().get(2);
1187 
1188         sm.getSelectedItems().addListener(new InvalidationListener() {
1189             int count = 0;
1190             @Override public void invalidated(Observable observable) {
1191                 if (count == 0) {
1192                     assertEquals(rt17112_child1_0, sm.getSelectedItem());
1193                     assertEquals(1, sm.getSelectedIndices().size());
1194                     assertEquals(6, sm.getSelectedIndex());
1195                     assertTrue(treeTableView1.getFocusModel().isFocused(6));
1196                 } else if (count == 1) {
1197                     assertEquals(rt17112_child1, sm.getSelectedItem());
1198                     assertFalse(sm.getSelectedItems().contains(rt17112_child2));
1199                     assertEquals(1, sm.getSelectedIndices().size());
1200                     assertTrue(treeTableView1.getFocusModel().isFocused(5));
1201                 }
1202                 count++;
1203             }
1204         });
1205 
1206         // this triggers the first callback above, so that count == 0
1207         sm.select(rt17112_child1_0);
1208 
1209         // this triggers the second callback above, so that count == 1
1210         rt17112_child1.setExpanded(false);
1211     }
1212     private void addChildren(TreeItem parent, String name) {
1213         for (int i=0; i&lt;3; i++) {
1214             TreeItem&lt;String&gt; ti = new TreeItem&lt;String&gt;(name+&quot;-&quot;+i);
1215             parent.getChildren().add(ti);
1216         }
1217     }
1218 
1219     @Test public void test_rt17522_focusShouldMoveWhenItemAddedAtFocusIndex_1() {
1220         installChildren();
1221         FocusModel fm = treeTableView.getFocusModel();
1222         fm.focus(1);    // focus on child1
1223         assertTrue(fm.isFocused(1));
1224         assertEquals(child1, fm.getFocusedItem());
1225 
1226         TreeItem child0 = new TreeItem(&quot;child0&quot;);
1227         root.getChildren().add(0, child0);  // 0th index == position of child1 in root
1228 
1229         assertEquals(child1, fm.getFocusedItem());
1230         assertTrue(fm.isFocused(2));
1231     }
1232 
1233     @Test public void test_rt17522_focusShouldMoveWhenItemAddedBeforeFocusIndex_1() {
1234         installChildren();
1235         FocusModel fm = treeTableView.getFocusModel();
1236         fm.focus(1);    // focus on child1
1237         assertTrue(fm.isFocused(1));
1238 
1239         TreeItem child0 = new TreeItem(&quot;child0&quot;);
1240         root.getChildren().add(0, child0);
1241         assertTrue(&quot;Focused index: &quot; + fm.getFocusedIndex(), fm.isFocused(2));
1242     }
1243 
1244     @Test public void test_rt17522_focusShouldNotMoveWhenItemAddedAfterFocusIndex_1() {
1245         installChildren();
1246         FocusModel fm = treeTableView.getFocusModel();
1247         fm.focus(1);    // focus on child1
1248         assertTrue(fm.isFocused(1));
1249 
1250         TreeItem child4 = new TreeItem(&quot;child4&quot;);
1251         root.getChildren().add(3, child4);
1252         assertTrue(&quot;Focused index: &quot; + fm.getFocusedIndex(), fm.isFocused(1));
1253     }
1254 
1255     @Test public void test_rt17522_focusShouldBeMovedWhenFocusedItemIsRemoved_1() {
1256         installChildren();
1257         FocusModel fm = treeTableView.getFocusModel();
1258         fm.focus(1);
1259         assertTrue(fm.isFocused(1));
1260 
1261         root.getChildren().remove(child1);
1262         assertEquals(0, fm.getFocusedIndex());
1263         assertEquals(treeTableView.getTreeItem(0), fm.getFocusedItem());
1264     }
1265 
1266     @Test public void test_rt17522_focusShouldMoveWhenItemRemovedBeforeFocusIndex_1() {
1267         installChildren();
1268         FocusModel fm = treeTableView.getFocusModel();
1269         fm.focus(2);
1270         assertTrue(fm.isFocused(2));
1271 
1272         root.getChildren().remove(child1);
1273         assertTrue(fm.isFocused(1));
1274         assertEquals(child2, fm.getFocusedItem());
1275     }
1276 
1277 //    This test fails as, in TreeTableView FocusModel, we do not know the index of the
1278 //    removed tree items, which means we don&#39;t know whether they existed before
1279 //    or after the focused item.
1280 //    @Test public void test_rt17522_focusShouldNotMoveWhenItemRemovedAfterFocusIndex() {
1281 //        installChildren();
1282 //        FocusModel fm = treeTableView.getFocusModel();
1283 //        fm.focus(1);
1284 //        assertTrue(fm.isFocused(1));
1285 //
1286 //        root.getChildren().remove(child3);
1287 //        assertTrue(&quot;Focused index: &quot; + fm.getFocusedIndex(), fm.isFocused(1));
1288 //        assertEquals(child1, fm.getFocusedItem());
1289 //    }
1290 
1291     @Test public void test_rt18385() {
1292         installChildren();
1293 //        table.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;);
1294         treeTableView.getSelectionModel().select(1);
1295         treeTableView.getRoot().getChildren().add(new TreeItem(&quot;Another Row&quot;));
1296         assertEquals(1, treeTableView.getSelectionModel().getSelectedIndices().size());
1297         assertEquals(1, treeTableView.getSelectionModel().getSelectedItems().size());
1298     }
1299 
1300     @Test public void test_rt18339_onlyEditWhenTreeTableViewIsEditable_editableIsFalse() {
1301         TreeItem root = new TreeItem(&quot;root&quot;);
1302         root.getChildren().setAll(
1303                 new TreeItem(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1304                 new TreeItem(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1305                 new TreeItem(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1306                 new TreeItem(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1307                 new TreeItem(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1308         root.setExpanded(true);
1309 
1310         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;Person&gt;(root);
1311 
1312         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1313         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1314 
1315         table.setEditable(false);
1316         table.edit(0,firstNameCol);
1317         assertNull(table.getEditingCell());
1318     }
1319 
1320     @Test public void test_rt18339_onlyEditWhenTreeTableViewIsEditable_editableIsTrue() {
1321         TreeItem root = new TreeItem(&quot;root&quot;);
1322         root.getChildren().setAll(
1323                 new TreeItem(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1324                 new TreeItem(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1325                 new TreeItem(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1326                 new TreeItem(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1327                 new TreeItem(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1328         root.setExpanded(true);
1329 
1330         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;Person&gt;(root);
1331 
1332         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1333         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1334 
1335         table.setEditable(true);
1336         table.edit(0,firstNameCol);
1337         assertEquals(root, table.getEditingCell().getTreeItem());
1338     }
1339 
1340     @Test public void test_rt14451() {
1341         installChildren();
1342         treeTableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
1343         treeTableView.getSelectionModel().selectRange(0, 2); // select from 0 (inclusive) to 2 (exclusive)
1344         assertEquals(2, treeTableView.getSelectionModel().getSelectedIndices().size());
1345     }
1346 
1347     @Test public void test_rt21586() {
1348         installChildren();
1349         treeTableView.getSelectionModel().select(1);
1350         assertEquals(1, treeTableView.getSelectionModel().getSelectedIndex());
1351         assertEquals(child1, treeTableView.getSelectionModel().getSelectedItem());
1352 
1353         TreeItem root = new TreeItem&lt;String&gt;(&quot;New Root&quot;);
1354         TreeItem child1 = new TreeItem&lt;String&gt;(&quot;New Child 1&quot;);
1355         TreeItem child2 = new TreeItem&lt;String&gt;(&quot;New Child 2&quot;);
1356         TreeItem child3 = new TreeItem&lt;String&gt;(&quot;New Child 3&quot;);
1357         root.setExpanded(true);
1358         root.getChildren().setAll(child1, child2, child3);
1359         treeTableView.setRoot(root);
1360         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1361         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1362         assertEquals(0, treeTableView.getFocusModel().getFocusedIndex());
1363         assertEquals(root, treeTableView.getFocusModel().getFocusedItem());
1364     }
1365 
1366     @Test public void test_rt27181() {
1367         myCompanyRootNode.setExpanded(true);
1368         treeTableView.setRoot(myCompanyRootNode);
1369 
1370         // start test
1371         salesDepartment.setExpanded(true);
1372         treeTableView.getSelectionModel().select(salesDepartment);
1373 
1374         assertEquals(1, treeTableView.getFocusModel().getFocusedIndex());
1375         itSupport.setExpanded(true);
1376         assertEquals(1, treeTableView.getFocusModel().getFocusedIndex());
1377     }
1378 
1379     @Test public void test_rt27185() {
1380         myCompanyRootNode.setExpanded(true);
1381         treeTableView.setRoot(myCompanyRootNode);
1382 
1383         // start test
1384         itSupport.setExpanded(true);
1385         treeTableView.getSelectionModel().select(mikeGraham);
1386 
1387         assertEquals(mikeGraham, treeTableView.getFocusModel().getFocusedItem());
1388         salesDepartment.setExpanded(true);
1389         assertEquals(mikeGraham, treeTableView.getFocusModel().getFocusedItem());
1390     }
1391 
1392     @Ignore(&quot;Bug hasn&#39;t been fixed yet&quot;)
1393     @Test public void test_rt28114() {
1394         myCompanyRootNode.setExpanded(true);
1395         treeTableView.setRoot(myCompanyRootNode);
1396 
1397         // start test
1398         itSupport.setExpanded(true);
1399         treeTableView.getSelectionModel().select(itSupport);
1400         assertEquals(itSupport, treeTableView.getFocusModel().getFocusedItem());
1401         assertEquals(itSupport, treeTableView.getSelectionModel().getSelectedItem());
1402         assertTrue(! itSupport.isLeaf());
1403         assertTrue(itSupport.isExpanded());
1404 
1405         itSupport.getChildren().remove(mikeGraham);
1406         assertEquals(itSupport, treeTableView.getFocusModel().getFocusedItem());
1407         assertEquals(itSupport, treeTableView.getSelectionModel().getSelectedItem());
1408         assertTrue(itSupport.isLeaf());
1409         assertTrue(!itSupport.isExpanded());
1410     }
1411 
1412     @Test public void test_rt27820_1() {
1413         TreeItem root = new TreeItem(&quot;root&quot;);
1414         root.setExpanded(true);
1415         TreeItem child = new TreeItem(&quot;child&quot;);
1416         root.getChildren().add(child);
1417         treeTableView.setRoot(root);
1418 
1419         treeTableView.getSelectionModel().select(0);
1420         assertEquals(1, treeTableView.getSelectionModel().getSelectedItems().size());
1421         assertEquals(root, treeTableView.getSelectionModel().getSelectedItem());
1422 
1423         treeTableView.setRoot(null);
1424         assertEquals(0, treeTableView.getSelectionModel().getSelectedItems().size());
1425         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1426     }
1427 
1428     @Test public void test_rt27820_2() {
1429         TreeItem root = new TreeItem(&quot;root&quot;);
1430         root.setExpanded(true);
1431         TreeItem child = new TreeItem(&quot;child&quot;);
1432         root.getChildren().add(child);
1433         treeTableView.setRoot(root);
1434 
1435         treeTableView.getSelectionModel().select(1);
1436         assertEquals(1, treeTableView.getSelectionModel().getSelectedItems().size());
1437         assertEquals(child, treeTableView.getSelectionModel().getSelectedItem());
1438 
1439         treeTableView.setRoot(null);
1440         assertEquals(0, treeTableView.getSelectionModel().getSelectedItems().size());
1441         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1442     }
1443 
1444     @Test public void test_rt28390() {
1445         // There should be no NPE when a TreeTableView is shown and the disclosure
1446         // node is null in a TreeCell
1447         TreeItem root = new TreeItem(&quot;root&quot;);
1448         treeTableView.setRoot(root);
1449 
1450         // install a custom cell factory that forces the disclosure node to be
1451         // null (because by default a null disclosure node will be replaced by
1452         // a non-null one).
1453         treeTableView.setRowFactory(new Callback() {
1454             @Override public Object call(Object p) {
1455                 TreeTableRow treeCell = new TreeTableRowShim() {
1456                     {
1457                         disclosureNodeProperty().addListener((ov, t, t1) -&gt; {
1458                             setDisclosureNode(null);
1459                         });
1460                     }
1461 
1462                     @Override public void updateItem(Object item, boolean empty) {
1463                         super.updateItem(item, empty);
1464                         setText(item == null ? &quot;&quot; : item.toString());
1465                     }
1466                 };
1467                 treeCell.setDisclosureNode(null);
1468                 return treeCell;
1469             }
1470         });
1471 
1472         try {
1473             Group group = new Group();
1474             group.getChildren().setAll(treeTableView);
1475             Scene scene = new Scene(group);
1476             Stage stage = new Stage();
1477             stage.setScene(scene);
1478             stage.show();
1479         } catch (NullPointerException e) {
1480             System.out.println(&quot;A null disclosure node is valid, so we shouldn&#39;t have an NPE here.&quot;);
1481             e.printStackTrace();
1482             assertTrue(false);
1483         }
1484     }
1485 
1486     @Ignore(&quot;This test begun failing when createDefaultCellImpl was removed from TreeTableViewSkin on 28/3/2013&quot;)
1487     @Test public void test_rt28534() {
1488         TreeItem root = new TreeItem(&quot;root&quot;);
1489         root.getChildren().setAll(
1490                 new TreeItem(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1491                 new TreeItem(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1492                 new TreeItem(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1493                 new TreeItem(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1494                 new TreeItem(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1495         root.setExpanded(true);
1496 
1497         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;Person&gt;(root);
1498 
1499         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1500         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1501 
1502         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1503         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1504 
1505         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1506         emailCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1507 
1508         table.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1509 
1510         VirtualFlowTestUtils.assertRowsNotEmpty(table, 0, 6); // rows 0 - 6 should be filled
1511         VirtualFlowTestUtils.assertRowsEmpty(table, 6, -1); // rows 6+ should be empty
1512 
1513         // now we replace the data and expect the cells that have no data
1514         // to be empty
1515         root.getChildren().setAll(
1516                 new TreeItem(new Person(&quot;*_*Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1517                 new TreeItem(new Person(&quot;_Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1518 
1519         VirtualFlowTestUtils.assertRowsNotEmpty(table, 0, 3); // rows 0 - 3 should be filled
1520         VirtualFlowTestUtils.assertRowsEmpty(table, 3, -1); // rows 3+ should be empty
1521     }
1522 
1523     @Test public void test_rt22463() {
1524         final TreeTableView&lt;RT_22463_Person&gt; table = new TreeTableView&lt;RT_22463_Person&gt;();
1525         table.setTableMenuButtonVisible(true);
1526         TreeTableColumn c1 = new TreeTableColumn(&quot;Id&quot;);
1527         TreeTableColumn c2 = new TreeTableColumn(&quot;Name&quot;);
1528         c1.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, Long&gt;(&quot;id&quot;));
1529         c2.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;name&quot;));
1530         table.getColumns().addAll(c1, c2);
1531 
1532         RT_22463_Person rootPerson = new RT_22463_Person();
1533         rootPerson.setName(&quot;Root&quot;);
1534         TreeItem&lt;RT_22463_Person&gt; root = new TreeItem&lt;RT_22463_Person&gt;(rootPerson);
1535         root.setExpanded(true);
1536 
1537         table.setRoot(root);
1538 
1539         // before the change things display fine
1540         RT_22463_Person p1 = new RT_22463_Person();
1541         p1.setId(1l);
1542         p1.setName(&quot;name1&quot;);
1543         RT_22463_Person p2 = new RT_22463_Person();
1544         p2.setId(2l);
1545         p2.setName(&quot;name2&quot;);
1546         root.getChildren().addAll(
1547                 new TreeItem&lt;RT_22463_Person&gt;(p1),
1548                 new TreeItem&lt;RT_22463_Person&gt;(p2));
1549         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;1&quot;, &quot;name1&quot;);
1550         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;2&quot;, &quot;name2&quot;);
1551 
1552         // now we change the persons but they are still equal as the ID&#39;s don&#39;t
1553         // change - but the items list is cleared so the cells should update
1554         RT_22463_Person new_p1 = new RT_22463_Person();
1555         new_p1.setId(1l);
1556         new_p1.setName(&quot;updated name1&quot;);
1557         RT_22463_Person new_p2 = new RT_22463_Person();
1558         new_p2.setId(2l);
1559         new_p2.setName(&quot;updated name2&quot;);
1560         root.getChildren().clear();
1561         root.getChildren().setAll(
1562                 new TreeItem&lt;RT_22463_Person&gt;(new_p1),
1563                 new TreeItem&lt;RT_22463_Person&gt;(new_p2));
1564         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;1&quot;, &quot;updated name1&quot;);
1565         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;2&quot;, &quot;updated name2&quot;);
1566     }
1567 
1568     @Test public void test_rt28637() {
1569         TreeItem&lt;String&gt; s1, s2, s3, s4;
1570         ObservableList&lt;TreeItem&lt;String&gt;&gt; items = FXCollections.observableArrayList(
1571                 s1 = new TreeItem&lt;String&gt;(&quot;String1&quot;),
1572                 s2 = new TreeItem&lt;String&gt;(&quot;String2&quot;),
1573                 s3 = new TreeItem&lt;String&gt;(&quot;String3&quot;),
1574                 s4 = new TreeItem&lt;String&gt;(&quot;String4&quot;));
1575 
1576         final TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;String&gt;();
1577 
1578         TreeItem&lt;String&gt; root = new TreeItem&lt;String&gt;(&quot;Root&quot;);
1579         root.setExpanded(true);
1580         treeTableView.setRoot(root);
1581         treeTableView.setShowRoot(false);
1582         root.getChildren().addAll(items);
1583 
1584         treeTableView.getSelectionModel().select(0);
1585         assertEquals((Object)s1, treeTableView.getSelectionModel().getSelectedItem());
1586         assertEquals((Object)s1, treeTableView.getSelectionModel().getSelectedItems().get(0));
1587         assertEquals(0, treeTableView.getSelectionModel().getSelectedIndex());
1588 
1589         root.getChildren().remove(treeTableView.getSelectionModel().getSelectedItem());
1590         assertEquals((Object)s2, treeTableView.getSelectionModel().getSelectedItem());
1591         assertEquals((Object)s2, treeTableView.getSelectionModel().getSelectedItems().get(0));
1592         assertEquals(0, treeTableView.getSelectionModel().getSelectedIndex());
1593     }
1594 
1595     @Test public void test_rt24844() {
1596         // p1 == lowest first name
1597         TreeItem&lt;Person&gt; p0, p1, p2, p3, p4;
1598 
1599         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1600             p3 = new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1601             p2 = new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1602             p1 = new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1603             p0 = new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1604             p4 = new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1605 
1606         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1607 
1608         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1609         root.setExpanded(true);
1610         table.setRoot(root);
1611         table.setShowRoot(false);
1612         root.getChildren().setAll(persons);
1613 
1614         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1615         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1616 
1617         // set dummy comparator to lock items in place until new comparator is set
1618         firstNameCol.setComparator((t, t1) -&gt; 0);
1619 
1620         table.getColumns().addAll(firstNameCol);
1621         table.getSortOrder().add(firstNameCol);
1622 
1623         // ensure the existing order is as expected
1624         assertEquals(p3, root.getChildren().get(0));
1625         assertEquals(p2, root.getChildren().get(1));
1626         assertEquals(p1, root.getChildren().get(2));
1627         assertEquals(p0, root.getChildren().get(3));
1628         assertEquals(p4, root.getChildren().get(4));
1629 
1630         // set a new comparator
1631         firstNameCol.setComparator((t, t1) -&gt; t.toString().compareTo(t1.toString()));
1632 
1633         // ensure the new order is as expected
1634         assertEquals(p0, root.getChildren().get(0));
1635         assertEquals(p1, root.getChildren().get(1));
1636         assertEquals(p2, root.getChildren().get(2));
1637         assertEquals(p3, root.getChildren().get(3));
1638         assertEquals(p4, root.getChildren().get(4));
1639     }
1640 
1641     @Test public void test_rt29331() {
1642         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;Person&gt;();
1643 
1644         // p1 == lowest first name
1645         TreeItem&lt;Person&gt; p0, p1, p2, p3, p4;
1646 
1647         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1648         firstNameCol.setCellValueFactory(new PropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1649 
1650         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1651         lastNameCol.setCellValueFactory(new PropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1652 
1653         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1654         emailCol.setCellValueFactory(new PropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1655 
1656         TreeTableColumn parentColumn = new TreeTableColumn&lt;&gt;(&quot;Parent&quot;);
1657         parentColumn.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1658 
1659         table.getColumns().addAll(parentColumn);
1660 
1661         // table is setup, now hide the &#39;last name&#39; column
1662         emailCol.setVisible(false);
1663         assertFalse(emailCol.isVisible());
1664 
1665         // reorder columns inside the parent column
1666         parentColumn.getColumns().setAll(emailCol, firstNameCol, lastNameCol);
1667 
1668         // the email column should not become visible after this, but it does
1669         assertFalse(emailCol.isVisible());
1670     }
1671 
1672     private int rt29330_count = 0;
1673     @Test public void test_rt29330_1() {
1674         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1675                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1676                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1677                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1678                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1679                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1680 
1681         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1682 
1683         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1684         root.setExpanded(true);
1685         table.setRoot(root);
1686         table.setShowRoot(false);
1687         root.getChildren().setAll(persons);
1688 
1689         TreeTableColumn parentColumn = new TreeTableColumn&lt;&gt;(&quot;Parent&quot;);
1690         table.getColumns().addAll(parentColumn);
1691 
1692         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1693         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1694 
1695         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1696         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1697 
1698         parentColumn.getColumns().addAll(firstNameCol, lastNameCol);
1699 
1700         table.setOnSort(event -&gt; {
1701             rt29330_count++;
1702         });
1703 
1704         // test preconditions
1705         assertEquals(ASCENDING, lastNameCol.getSortType());
1706         assertEquals(0, rt29330_count);
1707 
1708         table.getSortOrder().add(lastNameCol);
1709         assertEquals(1, rt29330_count);
1710 
1711         lastNameCol.setSortType(DESCENDING);
1712         assertEquals(2, rt29330_count);
1713 
1714         lastNameCol.setSortType(null);
1715         assertEquals(3, rt29330_count);
1716 
1717         lastNameCol.setSortType(ASCENDING);
1718         assertEquals(4, rt29330_count);
1719     }
1720 
1721     @Test public void test_rt29330_2() {
1722         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1723                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1724                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1725                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1726                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1727                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1728 
1729         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1730 
1731         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1732         root.setExpanded(true);
1733         table.setRoot(root);
1734         table.setShowRoot(false);
1735         root.getChildren().setAll(persons);
1736 
1737         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1738         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1739 
1740         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1741         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1742 
1743         // this test differs from the previous one by installing the parent column
1744         // into the tableview after it has the children added into it
1745         TreeTableColumn parentColumn = new TreeTableColumn&lt;&gt;(&quot;Parent&quot;);
1746         parentColumn.getColumns().addAll(firstNameCol, lastNameCol);
1747         table.getColumns().addAll(parentColumn);
1748 
1749         table.setOnSort(event -&gt; {
1750             rt29330_count++;
1751         });
1752 
1753         // test preconditions
1754         assertEquals(ASCENDING, lastNameCol.getSortType());
1755         assertEquals(0, rt29330_count);
1756 
1757         table.getSortOrder().add(lastNameCol);
1758         assertEquals(1, rt29330_count);
1759 
1760         lastNameCol.setSortType(DESCENDING);
1761         assertEquals(2, rt29330_count);
1762 
1763         lastNameCol.setSortType(null);
1764         assertEquals(3, rt29330_count);
1765 
1766         lastNameCol.setSortType(ASCENDING);
1767         assertEquals(4, rt29330_count);
1768     }
1769 
1770     @Test public void test_rt29313_selectedIndices() {
1771         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1772                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1773                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1774                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1775                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1776                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1777 
1778         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1779 
1780         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1781         root.setExpanded(true);
1782         table.setRoot(root);
1783         table.setShowRoot(false);
1784         root.getChildren().setAll(persons);
1785 
1786         TableSelectionModel sm = table.getSelectionModel();
1787 
1788         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1789         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1790 
1791         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1792         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1793 
1794         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1795         emailCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1796 
1797         table.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1798         sm.setCellSelectionEnabled(true);
1799         sm.setSelectionMode(SelectionMode.MULTIPLE);
1800 
1801         assertTrue(sm.getSelectedIndices().isEmpty());
1802 
1803         // only (0,0) should be selected, so selected indices should be [0]
1804         sm.select(0, firstNameCol);
1805         assertEquals(1, sm.getSelectedIndices().size());
1806 
1807         // now (0,0) and (1,0) should be selected, so selected indices should be [0, 1]
1808         sm.select(1, firstNameCol);
1809         assertEquals(2, sm.getSelectedIndices().size());
1810 
1811         // now (0,0), (1,0) and (1,1) should be selected, but selected indices
1812         // should remain as [0, 1], as we don&#39;t want selected indices to become
1813         // [0,1,1] (which is what RT-29313 is about)
1814         sm.select(1, lastNameCol);
1815         assertEquals(2, sm.getSelectedIndices().size());
1816         assertEquals(0, sm.getSelectedIndices().get(0));
1817         assertEquals(1, sm.getSelectedIndices().get(1));
1818     }
1819 
1820     @Test public void test_rt29313_selectedItems() {
1821         TreeItem&lt;Person&gt; p0, p1;
1822         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1823                 p0 = new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1824                 p1 = new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1825                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1826                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1827                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1828 
1829         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1830 
1831         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1832         root.setExpanded(true);
1833         table.setRoot(root);
1834         table.setShowRoot(false);
1835         root.getChildren().setAll(persons);
1836 
1837         TableSelectionModel sm = table.getSelectionModel();
1838 
1839         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1840         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1841 
1842         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1843         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1844 
1845         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1846         emailCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1847 
1848         table.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1849         sm.setCellSelectionEnabled(true);
1850         sm.setSelectionMode(SelectionMode.MULTIPLE);
1851 
1852         assertTrue(sm.getSelectedItems().isEmpty());
1853 
1854         // only (0,0) should be selected, so selected items should be [p0]
1855         sm.select(0, firstNameCol);
1856         assertEquals(1, sm.getSelectedItems().size());
1857 
1858         // now (0,0) and (1,0) should be selected, so selected items should be [p0, p1]
1859         sm.select(1, firstNameCol);
1860         assertEquals(2, sm.getSelectedItems().size());
1861 
1862         // now (0,0), (1,0) and (1,1) should be selected, but selected items
1863         // should remain as [p0, p1], as we don&#39;t want selected items to become
1864         // [p0,p1,p1] (which is what RT-29313 is about)
1865         sm.select(1, lastNameCol);
1866         assertEquals(2, sm.getSelectedItems().size());
1867         assertEquals(p0, sm.getSelectedItems().get(0));
1868         assertEquals(p1, sm.getSelectedItems().get(1));
1869     }
1870 
1871     @Test public void test_rt29566() {
1872         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1873                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1874                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1875                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1876                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1877                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1878 
1879         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1880 
1881         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1882         root.setExpanded(true);
1883         table.setRoot(root);
1884         table.setShowRoot(false);
1885         root.getChildren().setAll(persons);
1886 
1887         TableSelectionModel sm = table.getSelectionModel();
1888 
1889         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1890         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1891 
1892         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1893         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1894 
1895         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1896         emailCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1897 
1898         table.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1899 
1900         // test the state before we hide and re-add a column
1901         VirtualFlowTestUtils.assertCellTextEquals(table, 0, &quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;);
1902         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;);
1903         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;);
1904         VirtualFlowTestUtils.assertCellTextEquals(table, 3, &quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;);
1905         VirtualFlowTestUtils.assertCellTextEquals(table, 4, &quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;);
1906 
1907         // hide the last name column, and test cells again
1908         table.getColumns().remove(lastNameCol);
1909         VirtualFlowTestUtils.assertCellTextEquals(table, 0, &quot;Jacob&quot;, &quot;jacob.smith@example.com&quot;);
1910         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;Isabella&quot;, &quot;isabella.johnson@example.com&quot;);
1911         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;Ethan&quot;, &quot;ethan.williams@example.com&quot;);
1912         VirtualFlowTestUtils.assertCellTextEquals(table, 3, &quot;Emma&quot;, &quot;emma.jones@example.com&quot;);
1913         VirtualFlowTestUtils.assertCellTextEquals(table, 4, &quot;Michael&quot;, &quot;michael.brown@example.com&quot;);
1914 
1915         // re-add the last name column - we should go back to the original state.
1916         // However, what appears to be happening is that, for some reason, some
1917         // of the cells from the removed column do not reappear - meaning in this case
1918         // some of the last name values will not be where we expect them to be.
1919         // This is clearly not ideal!
1920         table.getColumns().add(1, lastNameCol);
1921         VirtualFlowTestUtils.assertCellTextEquals(table, 0, &quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;);
1922         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;);
1923         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;);
1924         VirtualFlowTestUtils.assertCellTextEquals(table, 3, &quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;);
1925         VirtualFlowTestUtils.assertCellTextEquals(table, 4, &quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;);
1926     }
1927 
1928     @Test public void test_rt29390() {
1929         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1930                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1931                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1932                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1933                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1934                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1935                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1936                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1937                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1938                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1939                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1940                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1941                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1942                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1943                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1944                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1945                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)
1946         ));
1947 
1948         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1949         table.setMaxHeight(50);
1950         table.setPrefHeight(50);
1951 
1952         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1953         root.setExpanded(true);
1954         table.setRoot(root);
1955         table.setShowRoot(false);
1956         root.getChildren().setAll(persons);
1957 
1958         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1959         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1960 
1961         table.getColumns().add(firstNameCol);
1962 
1963         Toolkit.getToolkit().firePulse();
1964 
1965         // we want the vertical scrollbar
1966         VirtualScrollBar scrollBar = VirtualFlowTestUtils.getVirtualFlowVerticalScrollbar(table);
1967 
1968         assertNotNull(scrollBar);
1969         assertTrue(scrollBar.isVisible());
1970         assertTrue(scrollBar.getVisibleAmount() &gt; 0.0);
1971         assertTrue(scrollBar.getVisibleAmount() &lt; 1.0);
1972 
1973         // this next test is likely to be brittle, but we&#39;ll see...If it is the
1974         // cause of failure then it can be commented out
1975         assertEquals(0.0625, scrollBar.getVisibleAmount(), 0.0);
1976     }
1977 
1978     @Test public void test_rt29676_withText() {
1979         // set up test
1980         TreeTableView&lt;Data&gt; treeTableView = new TreeTableView&lt;Data&gt;();
1981         treeTableView.setMaxWidth(100);
1982 
1983         TreeItem&lt;Data&gt; root = new TreeItem&lt;Data&gt;(new Data(&quot;Root&quot;));
1984         treeTableView.setRoot(root);
1985         addLevel(root, 0, 30);
1986 
1987         treeTableView.getRoot().setExpanded(true);
1988         TreeTableColumn&lt;Data, String&gt; column = new TreeTableColumn&lt;Data, String&gt;(&quot;Items&#39; name&quot;);
1989         column.setCellValueFactory(p -&gt; new ReadOnlyStringWrapper(p.getValue().getValue().getData()));
1990         treeTableView.getColumns().add(column);
1991 
1992         // show treeTableView
1993         StageLoader sl = new StageLoader(treeTableView);
1994 
1995         // expand all collapsed branches
1996         root.setExpanded(true);
1997         for (int i = 0; i &lt; root.getChildren().size(); i++) {
1998             TreeItem&lt;Data&gt; child = root.getChildren().get(i);
1999             child.setExpanded(true);
2000         }
2001 
2002         // get all cells and ensure their content is as expected
2003         int cellCount = VirtualFlowTestUtils.getCellCount(treeTableView);
2004         for (int i = 0; i &lt; cellCount; i++) {
2005             // get the TreeTableRow
2006             final TreeTableRow rowCell = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, i);
2007             final TreeItem treeItem = rowCell.getTreeItem();
2008             if (treeItem == null) continue;
2009 
2010             final boolean isBranch = ! treeItem.isLeaf();
2011 
2012             // then check its children
2013             List&lt;Node&gt; children = rowCell.getChildrenUnmodifiable();
2014             for (int j = 0; j &lt; children.size(); j++) {
2015                 final Node child = children.get(j);
2016 
2017                 assertTrue(child.isVisible());
2018                 assertNotNull(child.getParent());
2019                 assertNotNull(child.getScene());
2020 
2021                 if (child.getStyleClass().contains(&quot;tree-disclosure-node&quot;)) {
2022                     // no-op
2023                 }
2024 
2025                 if (child.getStyleClass().contains(&quot;tree-table-cell&quot;)) {
2026                     TreeTableCell cell = (TreeTableCell) child;
2027                     assertNotNull(cell.getText());
2028                     assertFalse(cell.getText().isEmpty());
2029                 }
2030             }
2031         }
2032 
2033         sl.dispose();
2034     }
2035     private void addLevel(TreeItem&lt;Data&gt; item, int level, int length) {
2036         for (int i = 0; i &lt; 3; i++) {
2037             StringBuilder builder = new StringBuilder();
2038             builder.append(&quot;Level &quot; + level + &quot; Item &quot; + item);
2039             if (length &gt; 0) {
2040                 builder.append(&quot; l&quot;);
2041                 for (int j = 0; j &lt; length; j++) {
2042                     builder.append(&quot;o&quot;);
2043                 }
2044                 builder.append(&quot;ng&quot;);
2045             }
2046             String itemString = builder.toString();
2047             TreeItem&lt;Data&gt; child = new TreeItem&lt;Data&gt;(new Data(itemString));
2048             if (level &lt; 3 - 1) {
2049                 addLevel(child, level + 1, length);
2050             }
2051             item.getChildren().add(child);
2052         }
2053     }
2054 
2055     @Test public void test_rt27180_collapseBranch_childSelected_singleSelection() {
2056         sm.setCellSelectionEnabled(false);
2057         sm.setSelectionMode(SelectionMode.SINGLE);
2058 
2059         treeTableView.setRoot(myCompanyRootNode);
2060         myCompanyRootNode.setExpanded(true);
2061         salesDepartment.setExpanded(true);
2062         itSupport.setExpanded(true);
2063         sm.select(2);                   // ethanWilliams
2064         assertFalse(sm.isSelected(1));  // salesDepartment
2065         assertTrue(sm.isSelected(2));   // ethanWilliams
2066         assertTrue(treeTableView.getFocusModel().isFocused(2));
2067         assertEquals(1, sm.getSelectedCells().size());
2068 
2069         // now collapse the salesDepartment, selection should
2070         // not jump down to the itSupport people
2071         salesDepartment.setExpanded(false);
2072         assertTrue(sm.getSelectedIndices().toString(), sm.isSelected(1));   // salesDepartment
2073         assertTrue(treeTableView.getFocusModel().isFocused(1));
2074         assertEquals(1, sm.getSelectedCells().size());
2075     }
2076 
2077     @Test public void test_rt27180_collapseBranch_laterSiblingSelected_singleSelection() {
2078         sm.setCellSelectionEnabled(false);
2079         sm.setSelectionMode(SelectionMode.SINGLE);
2080 
2081         treeTableView.setRoot(myCompanyRootNode);
2082         myCompanyRootNode.setExpanded(true);
2083         salesDepartment.setExpanded(true);
2084         itSupport.setExpanded(true);
2085         sm.select(8);                   // itSupport
2086         assertFalse(sm.isSelected(1));  // salesDepartment
2087         assertTrue(sm.isSelected(8));   // itSupport
2088         assertTrue(treeTableView.getFocusModel().isFocused(8));
2089         assertEquals(1, sm.getSelectedIndices().size());
2090 
2091         salesDepartment.setExpanded(false);
2092         assertTrue(debug(), sm.isSelected(2));   // itSupport
2093         assertTrue(treeTableView.getFocusModel().isFocused(2));
2094         assertEquals(1, sm.getSelectedIndices().size());
2095     }
2096 
2097     @Test public void test_rt27180_collapseBranch_laterSiblingAndChildrenSelected() {
2098         sm.setSelectionMode(SelectionMode.MULTIPLE);
2099         sm.setCellSelectionEnabled(false);
2100 
2101         treeTableView.setRoot(myCompanyRootNode);
2102         myCompanyRootNode.setExpanded(true);
2103         salesDepartment.setExpanded(true);
2104         itSupport.setExpanded(true);
2105         sm.clearSelection();
2106         sm.selectIndices(8, 9, 10);     // itSupport, and two people
2107         assertFalse(sm.isSelected(1));  // salesDepartment
2108         assertTrue(sm.isSelected(8));   // itSupport
2109         assertTrue(sm.isSelected(9));   // mikeGraham
2110         assertTrue(sm.isSelected(10));  // judyMayer
2111         assertTrue(treeTableView.getFocusModel().isFocused(10));
2112         assertEquals(debug(), 3, sm.getSelectedIndices().size());
2113 
2114         salesDepartment.setExpanded(false);
2115         assertTrue(debug(), sm.isSelected(2));   // itSupport
2116         assertTrue(sm.isSelected(3));   // mikeGraham
2117         assertTrue(sm.isSelected(4));   // judyMayer
2118         assertTrue(treeTableView.getFocusModel().isFocused(4));
2119         assertEquals(3, sm.getSelectedIndices().size());
2120     }
2121 
2122     @Test public void test_rt27180_expandBranch_laterSiblingSelected_singleSelection() {
2123         sm.setCellSelectionEnabled(false);
2124         sm.setSelectionMode(SelectionMode.SINGLE);
2125 
2126         treeTableView.setRoot(myCompanyRootNode);
2127         myCompanyRootNode.setExpanded(true);
2128         salesDepartment.setExpanded(false);
2129         itSupport.setExpanded(true);
2130         sm.select(2);                   // itSupport
2131         assertFalse(sm.isSelected(1));  // salesDepartment
2132         assertTrue(sm.isSelected(2));   // itSupport
2133         assertTrue(treeTableView.getFocusModel().isFocused(2));
2134         assertEquals(1, sm.getSelectedIndices().size());
2135 
2136         salesDepartment.setExpanded(true);
2137         assertTrue(debug(), sm.isSelected(8));   // itSupport
2138         assertTrue(treeTableView.getFocusModel().isFocused(8));
2139         assertEquals(1, sm.getSelectedIndices().size());
2140     }
2141 
2142     @Test public void test_rt27180_expandBranch_laterSiblingAndChildrenSelected() {
2143         sm.setSelectionMode(SelectionMode.MULTIPLE);
2144         sm.setCellSelectionEnabled(false);
2145 
2146         treeTableView.setRoot(myCompanyRootNode);
2147         myCompanyRootNode.setExpanded(true);
2148         salesDepartment.setExpanded(false);
2149         itSupport.setExpanded(true);
2150         sm.clearSelection();
2151         sm.selectIndices(2,3,4);     // itSupport, and two people
2152         assertFalse(sm.isSelected(1));  // salesDepartment
2153         assertTrue(sm.isSelected(2));   // itSupport
2154         assertTrue(sm.isSelected(3));   // mikeGraham
2155         assertTrue(sm.isSelected(4));  // judyMayer
2156         assertTrue(treeTableView.getFocusModel().isFocused(4));
2157         assertEquals(3, sm.getSelectedIndices().size());
2158 
2159         salesDepartment.setExpanded(true);
2160         assertTrue(debug(), sm.isSelected(8));   // itSupport
2161         assertTrue(sm.isSelected(9));   // mikeGraham
2162         assertTrue(sm.isSelected(10));   // judyMayer
2163         assertTrue(treeTableView.getFocusModel().isFocused(10));
2164         assertEquals(3, sm.getSelectedIndices().size());
2165     }
2166 
2167     @Test public void test_rt30400() {
2168         // create a treetableview that&#39;ll render cells using the check box cell factory
2169         TreeItem&lt;String&gt; rootItem = new TreeItem&lt;&gt;(&quot;root&quot;);
2170         final TreeTableView&lt;String&gt; tableView = new TreeTableView&lt;String&gt;(rootItem);
2171         tableView.setMinHeight(100);
2172         tableView.setPrefHeight(100);
2173 
2174         TreeTableColumn&lt;String, String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2175         firstNameCol.setCellValueFactory(param -&gt; new SimpleStringProperty(param.getValue().getValue()));
2176         firstNameCol.setCellFactory(CheckBoxTreeTableCell.forTreeTableColumn(param -&gt; new ReadOnlyBooleanWrapper(true)));
2177         tableView.getColumns().add(firstNameCol);
2178 
2179         // because only the first row has data, all other rows should be
2180         // empty (and not contain check boxes - we just check the first four here)
2181         VirtualFlowTestUtils.assertRowsNotEmpty(tableView, 0, 1);
2182         VirtualFlowTestUtils.assertCellNotEmpty(VirtualFlowTestUtils.getCell(tableView, 0));
2183         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(tableView, 1));
2184         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(tableView, 2));
2185         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(tableView, 3));
2186     }
2187 
2188     @Ignore(&quot;This bug is not yet fixed&quot;)
2189     @Test public void test_rt31165() {
2190         installChildren();
2191         treeTableView.setEditable(true);
2192 
2193         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
2194         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(&quot;TEST&quot;));
2195         firstNameCol.setCellFactory(TextFieldTreeTableCell.forTreeTableColumn());
2196         firstNameCol.setEditable(true);
2197 
2198         treeTableView.getColumns().add(firstNameCol);
2199 
2200         IndexedCell cell = VirtualFlowTestUtils.getCell(treeTableView, 1, 0);
2201         assertEquals(&quot;TEST&quot;, cell.getText());
2202         assertFalse(cell.isEditing());
2203 
2204         treeTableView.edit(1, firstNameCol);
2205 
2206         assertEquals(child1, treeTableView.getEditingCell().getTreeItem());
2207         assertTrue(cell.isEditing());
2208 
2209         VirtualFlowTestUtils.getVirtualFlow(treeTableView).requestLayout();
2210         Toolkit.getToolkit().firePulse();
2211 
2212         assertEquals(child1, treeTableView.getEditingCell().getTreeItem());
2213         assertTrue(cell.isEditing());
2214     }
2215 
2216     @Test public void test_rt31404() {
2217         installChildren();
2218 
2219         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2220         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2221 
2222         treeTableView.getColumns().add(firstNameCol);
2223 
2224         IndexedCell cell = VirtualFlowTestUtils.getCell(treeTableView, 0, 0);
2225         assertEquals(&quot;Root&quot;, cell.getText());
2226 
2227         treeTableView.setShowRoot(false);
2228         assertEquals(&quot;Child 1&quot;, cell.getText());
2229     }
2230 
2231     @Test public void test_rt31471() {
2232         installChildren();
2233 
2234         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2235         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2236 
2237         treeTableView.getColumns().add(firstNameCol);
2238 
2239         IndexedCell cell = VirtualFlowTestUtils.getCell(treeTableView, 0);
2240         assertEquals(&quot;Root&quot;, cell.getItem());
2241 
2242         treeTableView.setFixedCellSize(50);
2243 
2244         VirtualFlowTestUtils.getVirtualFlow(treeTableView).requestLayout();
2245         Toolkit.getToolkit().firePulse();
2246 
2247         assertEquals(&quot;Root&quot;, cell.getItem());
2248         assertEquals(50, cell.getHeight(), 0.00);
2249     }
2250 
2251     @Test public void test_rt30466() {
2252         final Node graphic1 = new Circle(6.75, Color.RED);
2253         final Node graphic2 = new Circle(6.75, Color.GREEN);
2254 
2255         installChildren();
2256 
2257         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2258         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2259 
2260         treeTableView.getColumns().add(firstNameCol);
2261 
2262         TreeTableRow cell = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2263         assertEquals(&quot;Root&quot;, cell.getItem());
2264 
2265         // set the first graphic - which we expect to see as a child of the cell
2266         root.setGraphic(graphic1);
2267         cell = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2268         boolean matchGraphic1 = false;
2269         boolean matchGraphic2 = false;
2270         for (Node n : cell.getChildrenUnmodifiable()) {
2271             if (n == graphic1) {
2272                 matchGraphic1 = true;
2273             }
2274             if (n == graphic2) {
2275                 matchGraphic2 = true;
2276             }
2277         }
2278         assertTrue(matchGraphic1);
2279         assertFalse(matchGraphic2);
2280 
2281         // set the second graphic - which we also expect to see - but of course graphic1 should not be a child any longer
2282         root.setGraphic(graphic2);
2283         cell = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2284         matchGraphic1 = false;
2285         matchGraphic2 = false;
2286         for (Node n : cell.getChildrenUnmodifiable()) {
2287             if (n == graphic1) {
2288                 matchGraphic1 = true;
2289             }
2290             if (n == graphic2) {
2291                 matchGraphic2 = true;
2292             }
2293         }
2294         assertFalse(matchGraphic1);
2295         assertTrue(matchGraphic2);
2296     }
2297 
2298     private int rt_31200_count = 0;
2299     @Test public void test_rt_31200_tableCell() {
2300         rt_31200_count = 0;
2301 
2302         installChildren();
2303         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2304         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2305         treeTableView.getColumns().add(firstNameCol);
2306 
2307         firstNameCol.setCellFactory(new Callback&lt;TreeTableColumn&lt;String, String&gt;, TreeTableCell&lt;String, String&gt;&gt;() {
2308             @Override
2309             public TreeTableCell&lt;String, String&gt; call(TreeTableColumn&lt;String, String&gt; param) {
2310                 return new TreeTableCellShim&lt;String, String&gt;() {
2311                     ImageView view = new ImageView();
2312 
2313                     {
2314                         setGraphic(view);
2315                     }
2316 
2317                     ;
2318 
2319                     @Override
2320                     public void updateItem(String item, boolean empty) {
2321                         if (getItem() == null ? item == null : getItem().equals(item)) {
2322                             rt_31200_count++;
2323                         }
2324                         super.updateItem(item, empty);
2325                         if (item == null || empty) {
2326                             view.setImage(null);
2327                             setText(null);
2328                         } else {
2329                             setText(item);
2330                         }
2331                     }
2332                 };
2333             }
2334         });
2335 
2336         StageLoader sl = new StageLoader(treeTableView);
2337 
2338         assertEquals(12, rt_31200_count);
2339 
2340         // resize the stage
2341         sl.getStage().setHeight(250);
2342         Toolkit.getToolkit().firePulse();
2343         sl.getStage().setHeight(50);
2344         Toolkit.getToolkit().firePulse();
2345         assertEquals(12, rt_31200_count);
2346 
2347         sl.dispose();
2348     }
2349 
2350     @Test public void test_rt_31200_tableRow() {
2351         rt_31200_count = 0;
2352 
2353         installChildren();
2354         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2355         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2356         treeTableView.getColumns().add(firstNameCol);
2357 
2358         treeTableView.setRowFactory(new Callback&lt;TreeTableView&lt;String&gt;, TreeTableRow&lt;String&gt;&gt;() {
2359             @Override
2360             public TreeTableRow&lt;String&gt; call(TreeTableView&lt;String&gt; param) {
2361                 return new TreeTableRowShim&lt;String&gt;() {
2362                     ImageView view = new ImageView();
2363 
2364                     {
2365                         setGraphic(view);
2366                     }
2367 
2368                     ;
2369 
2370                     @Override
2371                     public void updateItem(String item, boolean empty) {
2372                         if (getItem() == null ? item == null : getItem().equals(item)) {
2373                             rt_31200_count++;
2374                         }
2375                         super.updateItem(item, empty);
2376                         if (item == null || empty) {
2377                             view.setImage(null);
2378                             setText(null);
2379                         } else {
2380                             setText(item.toString());
2381                         }
2382                     }
2383                 };
2384             }
2385         });
2386 
2387         StageLoader sl = new StageLoader(treeTableView);
2388 
2389         assertEquals(21, rt_31200_count);
2390 
2391         // resize the stage
2392         sl.getStage().setHeight(250);
2393         Toolkit.getToolkit().firePulse();
2394         sl.getStage().setHeight(50);
2395         Toolkit.getToolkit().firePulse();
2396         assertEquals(21, rt_31200_count);
2397 
2398         sl.dispose();
2399     }
2400 
2401     @Test public void test_rt_31727() {
2402         installChildren();
2403         treeTableView.setEditable(true);
2404 
2405         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
2406         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(&quot;TEST&quot;));
2407         firstNameCol.setCellFactory(TextFieldTreeTableCell.forTreeTableColumn());
2408         firstNameCol.setEditable(true);
2409 
2410         treeTableView.getColumns().add(firstNameCol);
2411 
2412         treeTableView.setEditable(true);
2413         firstNameCol.setEditable(true);
2414 
2415         // do a normal edit
2416         treeTableView.edit(0, firstNameCol);
2417         TreeTablePosition editingCell = treeTableView.getEditingCell();
2418         assertNotNull(editingCell);
2419         assertEquals(0, editingCell.getRow());
2420         assertEquals(0, editingCell.getColumn());
2421         assertEquals(firstNameCol, editingCell.getTableColumn());
2422         assertEquals(treeTableView, editingCell.getTreeTableView());
2423 
2424         // cancel editing
2425         treeTableView.edit(-1, null);
2426         editingCell = treeTableView.getEditingCell();
2427         assertNull(editingCell);
2428     }
2429 
2430     @Test public void test_rt_21517() {
2431         installChildren();
2432 
2433 //        final TableSelectionModel sm = t.getSelectionModel();
2434         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
2435         col.setSortType(ASCENDING);
2436         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
2437         treeTableView.getColumns().add(col);
2438 
2439         // test pre-conditions
2440         assertEquals(0, sm.getSelectedCells().size());
2441         assertEquals(0, sm.getSelectedItems().size());
2442         assertEquals(0, sm.getSelectedIndices().size());
2443 
2444         // select the 4th row (that is, the third child of the root)
2445         sm.select(3);
2446         assertTrue(sm.isSelected(3));
2447         assertEquals(3, sm.getSelectedIndex());
2448         assertEquals(1, sm.getSelectedIndices().size());
2449         assertTrue(sm.getSelectedIndices().contains(3));
2450         assertEquals(child3, sm.getSelectedItem());
2451         assertEquals(1, sm.getSelectedItems().size());
2452         assertTrue(sm.getSelectedItems().contains(child3));
2453 
2454         // we also want to test visually
2455         TreeTableRow rootRow = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2456         assertFalse(rootRow.isSelected());
2457         TreeTableRow child3Row = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 3);
2458         assertTrue(child3Row.isSelected());
2459 
2460         // sort tableview by firstname column in ascending (default) order
2461         // (so aaa continues to come first)
2462         treeTableView.getSortOrder().add(col);
2463 
2464         // nothing should have changed
2465         assertTrue(sm.isSelected(3));
2466         assertEquals(3, sm.getSelectedIndex());
2467         assertEquals(1, sm.getSelectedIndices().size());
2468         assertTrue(sm.getSelectedIndices().contains(3));
2469         assertEquals(child3, sm.getSelectedItem());
2470         assertEquals(1, sm.getSelectedItems().size());
2471         assertTrue(sm.getSelectedItems().contains(child3));
2472         rootRow = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2473         assertFalse(rootRow.isSelected());
2474         child3Row = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 3);
2475         assertTrue(child3Row.isSelected());
2476 
2477         // continue to sort tableview by firstname column, but now in descending
2478         // order, (so ccc to come first)
2479         col.setSortType(TreeTableColumn.SortType.DESCENDING);
2480 
2481         // now test to ensure that CCC is still the only selected item, but now
2482         // located in index 1 (as the first child of the root)
2483         assertTrue(debug(), sm.isSelected(1));
2484         assertEquals(1, sm.getSelectedIndex());
2485         assertEquals(1, sm.getSelectedIndices().size());
2486         assertTrue(sm.getSelectedIndices().contains(1));
2487         assertEquals(child3, sm.getSelectedItem());
2488         assertEquals(1, sm.getSelectedItems().size());
2489         assertTrue(sm.getSelectedItems().contains(child3));
2490 
2491         // we also want to test visually
2492         rootRow = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2493         assertFalse(rootRow.isSelected());
2494         child3Row = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 1);
2495         assertTrue(child3Row.isSelected());
2496     }
2497 
2498     @Test public void test_rt_30484_treeTableCell() {
2499         installChildren();
2500 
2501         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
2502         col.setSortType(ASCENDING);
2503         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
2504         treeTableView.getColumns().add(col);
2505 
2506         col.setCellFactory(new Callback&lt;TreeTableColumn&lt;String, String&gt;, TreeTableCell&lt;String, String&gt;&gt;() {
2507             @Override
2508             public TreeTableCell&lt;String, String&gt; call(TreeTableColumn&lt;String, String&gt; param) {
2509                 return new TreeTableCellShim&lt;String, String&gt;() {
2510                     Rectangle graphic = new Rectangle(10, 10, Color.RED);
2511                     { setGraphic(graphic); };
2512 
2513                     @Override public void updateItem(String item, boolean empty) {
2514                         super.updateItem(item, empty);
2515                         if (item == null || empty) {
2516                             graphic.setVisible(false);
2517                             setText(null);
2518                         } else {
2519                             graphic.setVisible(true);
2520                             setText(item);
2521                         }
2522                     }
2523                 };
2524             }
2525         });
2526 
2527         // First four rows have content, so the graphic should show.
2528         // All other rows have no content, so graphic should not show.
2529 
2530         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    0, 0);
2531         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    1, 0);
2532         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    2, 0);
2533         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    3, 0);
2534         VirtualFlowTestUtils.assertGraphicIsNotVisible(treeTableView, 4, 0);
2535         VirtualFlowTestUtils.assertGraphicIsNotVisible(treeTableView, 5, 0);
2536     }
2537 
2538     @Test public void test_rt_30484_treeTableRow() {
2539         installChildren();
2540 
2541         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
2542         col.setSortType(ASCENDING);
2543         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
2544         treeTableView.getColumns().add(col);
2545 
2546         treeTableView.setRowFactory(new Callback&lt;TreeTableView&lt;String&gt;, TreeTableRow&lt;String&gt;&gt;() {
2547             @Override public TreeTableRow&lt;String&gt; call(TreeTableView&lt;String&gt; param) {
2548                 return new TreeTableRowShim&lt;String&gt;() {
2549                     Rectangle graphic = new Rectangle(10, 10, Color.RED);
2550                     { setGraphic(graphic); };
2551 
2552                     @Override public void updateItem(String item, boolean empty) {
2553                         super.updateItem(item, empty);
2554                         if (item == null || empty) {
2555                             graphic.setVisible(false);
2556                             setText(null);
2557                         } else {
2558                             graphic.setVisible(true);
2559                             setText(item.toString());
2560                         }
2561                     }
2562                 };
2563             }
2564         });
2565 
2566         // First two rows have content, so the graphic should show.
2567         // All other rows have no content, so graphic should not show.
2568 
2569         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    0);
2570         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    1);
2571         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    2);
2572         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    3);
2573         VirtualFlowTestUtils.assertGraphicIsNotVisible(treeTableView, 4);
2574         VirtualFlowTestUtils.assertGraphicIsNotVisible(treeTableView, 5);
2575     }
2576 
2577     private int rt_31015_count = 0;
2578     @Test public void test_rt_31015() {
2579         installChildren();
2580         root.getChildren().clear();
2581         treeTableView.setEditable(true);
2582 
2583         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
2584         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
2585         treeTableView.getColumns().add(col);
2586 
2587         //Set cell factory for cells that allow editing
2588         Callback&lt;TreeTableColumn&lt;String,String&gt;, TreeTableCell&lt;String, String&gt;&gt; cellFactory = new Callback&lt;TreeTableColumn&lt;String,String&gt;, TreeTableCell&lt;String, String&gt;&gt;() {
2589             public TreeTableCell&lt;String, String&gt; call(TreeTableColumn&lt;String, String&gt; p) {
2590                 return new TreeTableCell&lt;String, String&gt;() {
2591                     @Override public void cancelEdit() {
2592                         super.cancelEdit();
2593                         rt_31015_count++;
2594                     }
2595                 };
2596             }
2597         };
2598         col.setCellFactory(cellFactory);
2599 
2600         StageLoader sl = new StageLoader(treeTableView);
2601 
2602         assertEquals(0, rt_31015_count);
2603 
2604         treeTableView.edit(0, col);
2605         assertEquals(0, rt_31015_count);
2606 
2607         treeTableView.edit(-1, null);
2608         assertEquals(1, rt_31015_count);
2609 
2610         sl.dispose();
2611     }
2612 
2613     @Test public void test_rt_30688() {
2614         installChildren();
2615         root.getChildren().clear();
2616         treeTableView.setColumnResizePolicy(TreeTableView.CONSTRAINED_RESIZE_POLICY);
2617 
2618         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;column&quot;);
2619         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;&gt;(param.getValue().getValue()));
2620         treeTableView.getColumns().add(col);
2621 
2622         StageLoader sl = new StageLoader(treeTableView);
2623 
2624         assertEquals(TreeTableViewShim.get_contentWidth(treeTableView),
2625                 TableColumnBaseShim.getWidth(col), 0.0);
2626 
2627         sl.dispose();
2628     }
2629 
2630     private int rt_29650_start_count = 0;
2631     private int rt_29650_commit_count = 0;
2632     private int rt_29650_cancel_count = 0;
2633     @Test public void test_rt_29650() {
2634         installChildren();
2635         treeTableView.setEditable(true);
2636 
2637         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;column&quot;);
2638         Callback&lt;TreeTableColumn&lt;String, String&gt;, TreeTableCell&lt;String, String&gt;&gt; factory = TextFieldTreeTableCell.forTreeTableColumn();
2639         col.setCellFactory(factory);
2640         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;&gt;(param.getValue().getValue()));
2641         treeTableView.getColumns().add(col);
2642 
2643         col.setOnEditStart(t -&gt; {
2644             rt_29650_start_count++;
2645         });
2646         col.setOnEditCommit(t -&gt; {
2647             rt_29650_commit_count++;
2648         });
2649         col.setOnEditCancel(t -&gt; {
2650             rt_29650_cancel_count++;
2651         });
2652 
2653         StageLoader sl = new StageLoader(treeTableView);
2654 
2655         treeTableView.edit(0, col);
2656 
2657         Toolkit.getToolkit().firePulse();
2658 
2659         TreeTableCell rootCell = (TreeTableCell) VirtualFlowTestUtils.getCell(treeTableView, 0, 0);
2660         TextField textField = (TextField) rootCell.getGraphic();
2661         textField.setText(&quot;Testing!&quot;);
2662         KeyEventFirer keyboard = new KeyEventFirer(textField);
2663         keyboard.doKeyPress(KeyCode.ENTER);
2664 
2665         // TODO should the following assert be enabled?
2666 //        assertEquals(&quot;Testing!&quot;, listView.getItems().get(0));
2667         assertEquals(1, rt_29650_start_count);
2668         assertEquals(1, rt_29650_commit_count);
2669         assertEquals(0, rt_29650_cancel_count);
2670 
2671         sl.dispose();
2672     }
2673 
2674     private int rt_29849_start_count = 0;
2675     @Test public void test_rt_29849() {
2676         installChildren();
2677         treeTableView.setEditable(true);
2678 
2679         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;column&quot;);
2680         col.setEditable(true);
2681         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;&gt;(param.getValue().getValue()));
2682         treeTableView.getColumns().add(col);
2683 
2684         col.setOnEditStart(t -&gt; {
2685             rt_29849_start_count++;
2686         });
2687 
2688         // load the table so the default cells are created
2689         StageLoader sl = new StageLoader(treeTableView);
2690 
2691         // now replace the cell factory
2692         Callback&lt;TreeTableColumn&lt;String, String&gt;, TreeTableCell&lt;String, String&gt;&gt; factory = TextFieldTreeTableCell.forTreeTableColumn();
2693         col.setCellFactory(factory);
2694 
2695         Toolkit.getToolkit().firePulse();
2696 
2697         // now start an edit and count the start edit events - it should be just 1
2698         treeTableView.edit(0, col);
2699         assertEquals(1, rt_29849_start_count);
2700 
2701         sl.dispose();
2702     }
2703 
2704     @Test public void test_rt_34327() {
2705         // by default the comparator is null.
2706         // NOTE: this method (prior to the fix as part of RT-34327) would have
2707         // returned Comparator&lt;String&gt;, but after the fix it correctly returns
2708         // a Comparator&lt;TreeItem&lt;String&gt;&gt;
2709         Comparator nonGenericComparator = treeTableView.getComparator();
2710         Comparator&lt;TreeItem&lt;String&gt;&gt; genericComparator = treeTableView.getComparator();
2711         assertNull(nonGenericComparator);
2712         assertNull(genericComparator);
2713 
2714         // add in a column and some data
2715         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;column&quot;);
2716         col.setEditable(true);
2717         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;&gt;(param.getValue().getValue()));
2718         treeTableView.getColumns().add(col);
2719 
2720         installChildren();
2721 
2722         // sort by that column
2723         treeTableView.getSortOrder().add(col);
2724 
2725         // get the new comparator, which should no longer be null
2726         nonGenericComparator = treeTableView.getComparator();
2727         genericComparator = treeTableView.getComparator();
2728         assertNotNull(nonGenericComparator);
2729         assertNotNull(genericComparator);
2730 
2731         // now, as noted above, previously we would use the Comparator to compare
2732         // two String instances, which would fail at runtime as the Comparator
2733         // was actually expecting to compare two TreeItem&lt;String&gt;, but the API
2734         // was failing us.
2735         try {
2736             nonGenericComparator.compare(&quot;abc&quot;, &quot;def&quot;);
2737             fail(&quot;This should not work!&quot;);
2738         } catch (ClassCastException e) {
2739             // if we get the exception, we&#39;re happy
2740         }
2741 
2742         try {
2743             Object string1 = &quot;abc&quot;;
2744             Object string2 = &quot;def&quot;;
2745             genericComparator.compare((TreeItem&lt;String&gt;)string1, (TreeItem&lt;String&gt;)string2);
2746             fail(&quot;This should not work!&quot;);
2747         } catch (ClassCastException e) {
2748             // if we get the exception, we&#39;re happy
2749         }
2750     }
2751 
2752     @Test public void test_rt26718() {
2753         treeTableView.setRoot(new TreeItem(&quot;Root&quot;));
2754         treeTableView.getRoot().setExpanded(true);
2755 
2756         for (int i = 0; i &lt; 4; i++) {
2757             TreeItem parent = new TreeItem(&quot;item - &quot; + i);
2758             treeTableView.getRoot().getChildren().add(parent);
2759 
2760             for (int j = 0; j &lt; 4; j++) {
2761                 TreeItem child = new TreeItem(&quot;item - &quot; + i + &quot; &quot; + j);
2762                 parent.getChildren().add(child);
2763             }
2764         }
2765 
2766         treeTableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
2767 
2768         final TreeItem item0 = treeTableView.getTreeItem(1);
2769         final TreeItem item1 = treeTableView.getTreeItem(2);
2770 
2771         assertEquals(&quot;item - 0&quot;, item0.getValue());
2772         assertEquals(&quot;item - 1&quot;, item1.getValue());
2773 
2774         item0.setExpanded(true);
2775         item1.setExpanded(true);
2776         Toolkit.getToolkit().firePulse();
2777 
2778         treeTableView.getSelectionModel().selectRange(0, 8);
2779         assertEquals(8, treeTableView.getSelectionModel().getSelectedIndices().size());
2780         assertEquals(7, treeTableView.getSelectionModel().getSelectedIndex());
2781         assertEquals(7, treeTableView.getFocusModel().getFocusedIndex());
2782 
2783         // collapse item0 - but because the selected and focused indices are
2784         // not children of item 0, they should remain where they are (but of
2785         // course be shifted up). The bug was that focus was moving up to item0,
2786         // which makes no sense
2787         item0.setExpanded(false);
2788         Toolkit.getToolkit().firePulse();
2789         assertEquals(3, treeTableView.getSelectionModel().getSelectedIndex());
2790         assertEquals(3, treeTableView.getFocusModel().getFocusedIndex());
2791     }
2792 
2793 //    @Ignore(&quot;Test started intermittently failing, most probably due to RT-36855 changeset&quot;)
2794     @Test public void test_rt_34493() {
2795         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
2796             new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;))
2797         );
2798 
2799         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
2800 
2801         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
2802         root.setExpanded(true);
2803         table.setRoot(root);
2804         table.setShowRoot(false);
2805         root.getChildren().setAll(persons);
2806 
2807         TreeTableColumn first = new TreeTableColumn(&quot;First Name&quot;);
2808         first.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
2809 
2810         TreeTableColumn last = new TreeTableColumn(&quot;Last Name&quot;);
2811         last.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
2812 
2813         TreeTableColumn email = new TreeTableColumn(&quot;Email&quot;);
2814         email.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
2815 
2816         table.getColumns().addAll(first, last, email);
2817 
2818         // load the table
2819         StageLoader sl = new StageLoader(table);
2820 
2821         // resize the last column
2822         TableColumnBaseHelper.setWidth(last, 400);
2823         assertEquals(400, last.getWidth(), 0.0);
2824 
2825         // hide the first column
2826         table.getColumns().remove(first);
2827         Toolkit.getToolkit().firePulse();
2828 
2829         // the last column should still be 400px, not the default width or any
2830         // other value (based on the width of the content in that column)
2831         assertEquals(400, last.getWidth(), 0.0);
2832 
2833         sl.dispose();
2834     }
2835 
2836     @Test public void test_rt26721_collapseParent_firstRootChild() {
2837         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
2838         table.setRoot(new TreeItem(&quot;Root&quot;));
2839         table.getRoot().setExpanded(true);
2840 
2841         for (int i = 0; i &lt; 4; i++) {
2842             TreeItem parent = new TreeItem(&quot;item - &quot; + i);
2843             table.getRoot().getChildren().add(parent);
2844 
2845             for (int j = 0; j &lt; 4; j++) {
2846                 TreeItem child = new TreeItem(&quot;item - &quot; + i + &quot; &quot; + j);
2847                 parent.getChildren().add(child);
2848             }
2849         }
2850 
2851         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
2852 
2853         final TreeItem&lt;String&gt; item0 = table.getTreeItem(1);
2854         final TreeItem&lt;String&gt; item0child0 = item0.getChildren().get(0);
2855         final TreeItem&lt;String&gt; item1 = table.getTreeItem(2);
2856 
2857         assertEquals(&quot;item - 0&quot;, item0.getValue());
2858         assertEquals(&quot;item - 1&quot;, item1.getValue());
2859 
2860         item0.setExpanded(true);
2861         item1.setExpanded(true);
2862         Toolkit.getToolkit().firePulse();
2863 
2864         // select the first child of item0
2865         table.getSelectionModel().select(item0child0);
2866 
2867         assertEquals(item0child0, table.getSelectionModel().getSelectedItem());
2868         assertEquals(item0child0, table.getFocusModel().getFocusedItem());
2869 
2870         // collapse item0 - we expect the selection / focus to move up to item0
2871         item0.setExpanded(false);
2872         Toolkit.getToolkit().firePulse();
2873         assertEquals(item0, table.getSelectionModel().getSelectedItem());
2874         assertEquals(item0, table.getFocusModel().getFocusedItem());
2875     }
2876 
2877     @Test public void test_rt26721_collapseParent_lastRootChild() {
2878         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
2879         table.setRoot(new TreeItem(&quot;Root&quot;));
2880         table.getRoot().setExpanded(true);
2881 
2882         for (int i = 0; i &lt; 4; i++) {
2883             TreeItem parent = new TreeItem(&quot;item - &quot; + i);
2884             table.getRoot().getChildren().add(parent);
2885 
2886             for (int j = 0; j &lt; 4; j++) {
2887                 TreeItem child = new TreeItem(&quot;item - &quot; + i + &quot; &quot; + j);
2888                 parent.getChildren().add(child);
2889             }
2890         }
2891 
2892         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
2893 
2894         final TreeItem&lt;String&gt; item3 = table.getTreeItem(4);
2895         final TreeItem&lt;String&gt; item3child0 = item3.getChildren().get(0);
2896 
2897         assertEquals(&quot;item - 3&quot;, item3.getValue());
2898         assertEquals(&quot;item - 3 0&quot;, item3child0.getValue());
2899 
2900         item3.setExpanded(true);
2901         Toolkit.getToolkit().firePulse();
2902 
2903         // select the first child of item0
2904         table.getSelectionModel().select(item3child0);
2905 
2906         assertEquals(item3child0, table.getSelectionModel().getSelectedItem());
2907         assertEquals(item3child0, table.getFocusModel().getFocusedItem());
2908 
2909         // collapse item3 - we expect the selection / focus to move up to item3
2910         item3.setExpanded(false);
2911         Toolkit.getToolkit().firePulse();
2912         assertEquals(item3, table.getSelectionModel().getSelectedItem());
2913         assertEquals(item3, table.getFocusModel().getFocusedItem());
2914     }
2915 
2916     @Test public void test_rt26721_collapseGrandParent() {
2917         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
2918         table.setRoot(new TreeItem(&quot;Root&quot;));
2919         table.getRoot().setExpanded(true);
2920 
2921         for (int i = 0; i &lt; 4; i++) {
2922             TreeItem parent = new TreeItem(&quot;item - &quot; + i);
2923             table.getRoot().getChildren().add(parent);
2924 
2925             for (int j = 0; j &lt; 4; j++) {
2926                 TreeItem child = new TreeItem(&quot;item - &quot; + i + &quot; &quot; + j);
2927                 parent.getChildren().add(child);
2928             }
2929         }
2930 
2931         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
2932 
2933         final TreeItem&lt;String&gt; item0 = table.getTreeItem(1);
2934         final TreeItem&lt;String&gt; item0child0 = item0.getChildren().get(0);
2935         final TreeItem&lt;String&gt; item1 = table.getTreeItem(2);
2936 
2937         assertEquals(&quot;item - 0&quot;, item0.getValue());
2938         assertEquals(&quot;item - 1&quot;, item1.getValue());
2939 
2940         item0.setExpanded(true);
2941         item1.setExpanded(true);
2942         Toolkit.getToolkit().firePulse();
2943 
2944         // select the first child of item0
2945         table.getSelectionModel().select(item0child0);
2946 
2947         assertEquals(item0child0, table.getSelectionModel().getSelectedItem());
2948         assertEquals(item0child0, table.getFocusModel().getFocusedItem());
2949 
2950         // collapse root - we expect the selection / focus to move up to root
2951         table.getRoot().setExpanded(false);
2952         Toolkit.getToolkit().firePulse();
2953         assertEquals(table.getRoot(), table.getSelectionModel().getSelectedItem());
2954         assertEquals(table.getRoot(), table.getFocusModel().getFocusedItem());
2955     }
2956 
2957     @Test public void test_rt_34685_directEditCall_cellSelectionMode() {
2958         test_rt_34685_commitCount = 0;
2959         test_rt_34685(false, true);
2960     }
2961 
2962     @Test public void test_rt_34685_directEditCall_rowSelectionMode() {
2963         test_rt_34685_commitCount = 0;
2964         test_rt_34685(false, false);
2965     }
2966 
2967     @Test public void test_rt_34685_mouseDoubleClick_cellSelectionMode() {
2968         test_rt_34685_commitCount = 0;
2969         test_rt_34685(true, true);
2970     }
2971 
2972     @Test public void test_rt_34685_mouseDoubleClick_rowSelectionMode() {
2973         test_rt_34685_commitCount = 0;
2974         test_rt_34685(true, false);
2975     }
2976 
2977     private int test_rt_34685_commitCount = 0;
2978     private void test_rt_34685(boolean useMouseToInitiateEdit, boolean cellSelectionModeEnabled) {
2979         assertEquals(0, test_rt_34685_commitCount);
2980 
2981         Person person1;
2982         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
2983             new TreeItem&lt;&gt;(person1 = new Person(&quot;John&quot;, &quot;Smith&quot;, &quot;john.smith@example.com&quot;))
2984         );
2985 
2986         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
2987         table.getSelectionModel().setCellSelectionEnabled(cellSelectionModeEnabled);
2988         table.getSelectionModel().setSelectionMode(SelectionMode.SINGLE);
2989         table.setEditable(true);
2990 
2991         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
2992         root.setExpanded(true);
2993         table.setRoot(root);
2994         table.setShowRoot(false);
2995         root.getChildren().setAll(persons);
2996 
2997         TreeTableColumn first = new TreeTableColumn(&quot;First Name&quot;);
2998         first.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
2999         first.setCellFactory(TextFieldTreeTableCell.forTreeTableColumn());
3000 
3001         EventHandler&lt;TreeTableColumn.CellEditEvent&lt;Person, String&gt;&gt; onEditCommit = first.getOnEditCommit();
3002         first.setOnEditCommit(new EventHandler&lt;TreeTableColumn.CellEditEvent&lt;Person, String&gt;&gt;() {
3003             @Override public void handle(TreeTableColumn.CellEditEvent&lt;Person, String&gt; event) {
3004                 test_rt_34685_commitCount++;
3005                 onEditCommit.handle(event);
3006             }
3007         });
3008 
3009         table.getColumns().addAll(first);
3010 
3011         // get the cell at (0,0) - we&#39;re hiding the root row
3012         VirtualFlowTestUtils.BLOCK_STAGE_LOADER_DISPOSE = true;
3013         TreeTableCell cell = (TreeTableCell) VirtualFlowTestUtils.getCell(table, 0, 0);
3014         VirtualFlowTestUtils.BLOCK_STAGE_LOADER_DISPOSE = false;
3015         assertTrue(cell.getSkin() instanceof TreeTableCellSkin);
3016         assertNull(cell.getGraphic());
3017         assertEquals(&quot;John&quot;, cell.getText());
3018         assertEquals(&quot;John&quot;, person1.getFirstName());
3019 
3020         // set the table to be editing the first cell at 0,0
3021         if (useMouseToInitiateEdit) {
3022             MouseEventFirer mouse = new MouseEventFirer(cell);
3023             mouse.fireMousePressAndRelease(2, 10, 10);  // click 10 pixels in and 10 pixels down
3024             mouse.dispose();
3025         } else {
3026             table.edit(0,first);
3027         }
3028 
3029         Toolkit.getToolkit().firePulse();
3030         assertNotNull(cell.getGraphic());
3031         assertTrue(cell.getGraphic() instanceof TextField);
3032 
3033         TextField textField = (TextField) cell.getGraphic();
3034         assertEquals(&quot;John&quot;, textField.getText());
3035 
3036         textField.setText(&quot;Andrew&quot;);
3037         textField.requestFocus();
3038         Toolkit.getToolkit().firePulse();
3039 
3040         KeyEventFirer keyboard = new KeyEventFirer(textField);
3041         keyboard.doKeyPress(KeyCode.ENTER);
3042 
3043         VirtualFlowTestUtils.getVirtualFlow(table).requestLayout();
3044         Toolkit.getToolkit().firePulse();
3045 
3046         VirtualFlowTestUtils.assertTableCellTextEquals(table, 0, 0, &quot;Andrew&quot;);
3047         assertEquals(&quot;Andrew&quot;, cell.getText());
3048         assertEquals(&quot;Andrew&quot;, person1.getFirstName());
3049         assertEquals(1, test_rt_34685_commitCount);
3050     }
3051 
3052     @Test public void test_rt34694() {
3053         TreeItem treeNode = new TreeItem(&quot;Controls&quot;);
3054         treeNode.getChildren().addAll(
3055                 new TreeItem(&quot;Button&quot;),
3056                 new TreeItem(&quot;ButtonBar&quot;),
3057                 new TreeItem(&quot;LinkBar&quot;),
3058                 new TreeItem(&quot;LinkButton&quot;),
3059                 new TreeItem(&quot;PopUpButton&quot;),
3060                 new TreeItem(&quot;ToggleButtonBar&quot;)
3061         );
3062 
3063         final TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3064         table.setRoot(treeNode);
3065         treeNode.setExpanded(true);
3066 
3067         table.getSelectionModel().select(0);
3068         assertTrue(table.getSelectionModel().isSelected(0));
3069         assertTrue(table.getFocusModel().isFocused(0));
3070 
3071         treeNode.getChildren().clear();
3072         treeNode.getChildren().addAll(
3073                 new TreeItem(&quot;Button1&quot;),
3074                 new TreeItem(&quot;ButtonBar1&quot;),
3075                 new TreeItem(&quot;LinkBar1&quot;),
3076                 new TreeItem(&quot;LinkButton1&quot;),
3077                 new TreeItem(&quot;PopUpButton1&quot;),
3078                 new TreeItem(&quot;ToggleButtonBar1&quot;)
3079         );
3080         Toolkit.getToolkit().firePulse();
3081 
3082         assertTrue(table.getSelectionModel().isSelected(0));
3083         assertTrue(table.getFocusModel().isFocused(0));
3084     }
3085 
3086     private int test_rt_35213_eventCount = 0;
3087     @Test public void test_rt35213() {
3088         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;();
3089 
3090         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Boss&quot;);
3091         view.setRoot(root);
3092 
3093         TreeItem&lt;String&gt; group1 = new TreeItem&lt;&gt;(&quot;Group 1&quot;);
3094         TreeItem&lt;String&gt; group2 = new TreeItem&lt;&gt;(&quot;Group 2&quot;);
3095         TreeItem&lt;String&gt; group3 = new TreeItem&lt;&gt;(&quot;Group 3&quot;);
3096 
3097         root.getChildren().addAll(group1, group2, group3);
3098 
3099         TreeItem&lt;String&gt; employee1 = new TreeItem&lt;&gt;(&quot;Employee 1&quot;);
3100         TreeItem&lt;String&gt; employee2 = new TreeItem&lt;&gt;(&quot;Employee 2&quot;);
3101 
3102         group2.getChildren().addAll(employee1, employee2);
3103 
3104         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;Name&quot;);
3105         nameColumn.setCellValueFactory(param -&gt; new SimpleStringProperty(param.getValue().getValue()));
3106         view.getColumns().add(nameColumn);
3107 
3108         view.expandedItemCountProperty().addListener((observableValue, oldCount, newCount) -&gt; {
3109 
3110             // DEBUG OUTPUT
3111 //                System.out.println(&quot;new expanded item count: &quot; + newCount.intValue());
3112 //                for (int i = 0; i &lt; newCount.intValue(); i++) {
3113 //                    TreeItem&lt;String&gt; item = view.getTreeItem(i);
3114 //                    String text = item.getValue();
3115 //                    System.out.println(&quot;person found at index &quot; + i + &quot; is &quot; + text);
3116 //                }
3117 //                System.out.println(&quot;------------------------------------------&quot;);
3118 
3119             if (test_rt_35213_eventCount == 0) {
3120                 assertEquals(4, newCount);
3121                 assertEquals(&quot;Boss&quot;, view.getTreeItem(0).getValue());
3122                 assertEquals(&quot;Group 1&quot;, view.getTreeItem(1).getValue());
3123                 assertEquals(&quot;Group 2&quot;, view.getTreeItem(2).getValue());
3124                 assertEquals(&quot;Group 3&quot;, view.getTreeItem(3).getValue());
3125             } else if (test_rt_35213_eventCount == 1) {
3126                 assertEquals(6, newCount);
3127                 assertEquals(&quot;Boss&quot;, view.getTreeItem(0).getValue());
3128                 assertEquals(&quot;Group 1&quot;, view.getTreeItem(1).getValue());
3129                 assertEquals(&quot;Group 2&quot;, view.getTreeItem(2).getValue());
3130                 assertEquals(&quot;Employee 1&quot;, view.getTreeItem(3).getValue());
3131                 assertEquals(&quot;Employee 2&quot;, view.getTreeItem(4).getValue());
3132                 assertEquals(&quot;Group 3&quot;, view.getTreeItem(5).getValue());
3133             } else if (test_rt_35213_eventCount == 2) {
3134                 assertEquals(4, newCount);
3135                 assertEquals(&quot;Boss&quot;, view.getTreeItem(0).getValue());
3136                 assertEquals(&quot;Group 1&quot;, view.getTreeItem(1).getValue());
3137                 assertEquals(&quot;Group 2&quot;, view.getTreeItem(2).getValue());
3138                 assertEquals(&quot;Group 3&quot;, view.getTreeItem(3).getValue());
3139             }
3140 
3141             test_rt_35213_eventCount++;
3142         });
3143 
3144         StageLoader sl = new StageLoader(view);
3145 
3146         root.setExpanded(true);
3147         Toolkit.getToolkit().firePulse();
3148 
3149         group2.setExpanded(true);
3150         Toolkit.getToolkit().firePulse();
3151 
3152         group2.setExpanded(false);
3153         Toolkit.getToolkit().firePulse();
3154 
3155         sl.dispose();
3156     }
3157 
3158     @Test public void test_rt23245_itemIsInTree() {
3159         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;String&gt;();
3160         final List&lt;TreeItem&lt;String&gt;&gt; items = new ArrayList&lt;&gt;();
3161         for (int i = 0; i &lt; 10; i++) {
3162             final TreeItem&lt;String&gt; item = new TreeItem&lt;String&gt;(&quot;Item&quot; + i);
3163             item.setExpanded(true);
3164             items.add(item);
3165         }
3166 
3167         // link the items up so that the next item is the child of the current item
3168         for (int i = 0; i &lt; 9; i++) {
3169             items.get(i).getChildren().add(items.get(i + 1));
3170         }
3171 
3172         view.setRoot(items.get(0));
3173 
3174         for (int i = 0; i &lt; 10; i++) {
3175             // we expect the level of the tree item at the ith position to be
3176             // 0, as every iteration we are setting the ith item as the root.
3177             assertEquals(0, view.getTreeItemLevel(items.get(i)));
3178 
3179             // whilst we are testing, we should also ensure that the ith item
3180             // is indeed the root item, and that the ith item is indeed the item
3181             // at the 0th position
3182             assertEquals(items.get(i), view.getRoot());
3183             assertEquals(items.get(i), view.getTreeItem(0));
3184 
3185             // shuffle the next item into the root position (keeping its parent
3186             // chain intact - which is what exposes this issue in the first place).
3187             if (i &lt; 9) {
3188                 view.setRoot(items.get(i + 1));
3189             }
3190         }
3191     }
3192 
3193     @Test public void test_rt23245_itemIsNotInTree_noRootNode() {
3194         final TreeView&lt;String&gt; view = new TreeView&lt;String&gt;();
3195         final List&lt;TreeItem&lt;String&gt;&gt; items = new ArrayList&lt;&gt;();
3196         for (int i = 0; i &lt; 10; i++) {
3197             final TreeItem&lt;String&gt; item = new TreeItem&lt;String&gt;(&quot;Item&quot; + i);
3198             item.setExpanded(true);
3199             items.add(item);
3200         }
3201 
3202         // link the items up so that the next item is the child of the current item
3203         for (int i = 0; i &lt; 9; i++) {
3204             items.get(i).getChildren().add(items.get(i + 1));
3205         }
3206 
3207         for (int i = 0; i &lt; 10; i++) {
3208             // because we have no root (and we are not changing the root like
3209             // the previous test), we expect the tree item level of the item
3210             // in the ith position to be i.
3211             assertEquals(i, view.getTreeItemLevel(items.get(i)));
3212 
3213             // all items requested from the TreeView should be null, as the
3214             // TreeView does not have a root item
3215             assertNull(view.getTreeItem(i));
3216         }
3217     }
3218 
3219     @Test public void test_rt23245_itemIsNotInTree_withUnrelatedRootNode() {
3220         final TreeView&lt;String&gt; view = new TreeView&lt;String&gt;();
3221         final List&lt;TreeItem&lt;String&gt;&gt; items = new ArrayList&lt;&gt;();
3222         for (int i = 0; i &lt; 10; i++) {
3223             final TreeItem&lt;String&gt; item = new TreeItem&lt;String&gt;(&quot;Item&quot; + i);
3224             item.setExpanded(true);
3225             items.add(item);
3226         }
3227 
3228         // link the items up so that the next item is the child of the current item
3229         for (int i = 0; i &lt; 9; i++) {
3230             items.get(i).getChildren().add(items.get(i + 1));
3231         }
3232 
3233         view.setRoot(new TreeItem(&quot;Unrelated root node&quot;));
3234 
3235         for (int i = 0; i &lt; 10; i++) {
3236             // because we have no root (and we are not changing the root like
3237             // the previous test), we expect the tree item level of the item
3238             // in the ith position to be i.
3239             assertEquals(i, view.getTreeItemLevel(items.get(i)));
3240 
3241             // all items requested from the TreeView should be null except for
3242             // the root node
3243             assertNull(view.getTreeItem(i + 1));
3244         }
3245     }
3246 
3247     @Test public void test_rt35039_setRoot() {
3248         TreeItem aabbaa = new TreeItem(&quot;aabbaa&quot;);
3249         TreeItem bbc = new TreeItem(&quot;bbc&quot;);
3250 
3251         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3252         root.setExpanded(true);
3253         root.getChildren().setAll(aabbaa, bbc);
3254 
3255         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;();
3256         treeView.setRoot(root);
3257 
3258         StageLoader sl = new StageLoader(treeView);
3259 
3260         // Selection starts in row -1
3261         assertNull(treeView.getSelectionModel().getSelectedItem());
3262 
3263         // select &quot;bbc&quot; and ensure everything is set to that
3264         treeView.getSelectionModel().select(2);
3265         assertEquals(&quot;bbc&quot;, treeView.getSelectionModel().getSelectedItem().getValue());
3266 
3267         // change the items list - but retain the same content. We expect
3268         // that &quot;bbc&quot; remains selected as it is still in the list
3269         treeView.setRoot(root);
3270         assertEquals(&quot;bbc&quot;, treeView.getSelectionModel().getSelectedItem().getValue());
3271 
3272         sl.dispose();
3273     }
3274 
3275     @Test public void test_rt35039_resetRootChildren() {
3276         TreeItem aabbaa = new TreeItem(&quot;aabbaa&quot;);
3277         TreeItem bbc = new TreeItem(&quot;bbc&quot;);
3278 
3279         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3280         root.setExpanded(true);
3281         root.getChildren().setAll(aabbaa, bbc);
3282 
3283         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;();
3284         treeView.setRoot(root);
3285 
3286         StageLoader sl = new StageLoader(treeView);
3287 
3288         // Selection starts in row -1
3289         assertNull(treeView.getSelectionModel().getSelectedItem());
3290 
3291         // select &quot;bbc&quot; and ensure everything is set to that
3292         treeView.getSelectionModel().select(2);
3293         assertEquals(&quot;bbc&quot;, treeView.getSelectionModel().getSelectedItem().getValue());
3294 
3295         // change the items list - but retain the same content. We expect
3296         // that &quot;bbc&quot; remains selected as it is still in the list
3297         root.getChildren().setAll(aabbaa, bbc);
3298         assertEquals(&quot;bbc&quot;, treeView.getSelectionModel().getSelectedItem().getValue());
3299 
3300         sl.dispose();
3301     }
3302 
3303     @Test public void test_rt35763() {
3304         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3305         root.setExpanded(true);
3306         TreeItem aaa = new TreeItem(&quot;aaa&quot;);
3307         TreeItem bbb = new TreeItem(&quot;bbb&quot;);
3308         root.getChildren().setAll(bbb, aaa);
3309 
3310         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;();
3311 
3312         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
3313         col.setCellValueFactory(param -&gt; param.getValue().valueProperty());
3314 
3315         treeView.getColumns().add(col);
3316         treeView.setRoot(root);
3317 
3318         assertEquals(root, treeView.getTreeItem(0));
3319         assertEquals(bbb, treeView.getTreeItem(1));
3320         assertEquals(aaa,treeView.getTreeItem(2));
3321 
3322         // change sort order - expect items to be sorted
3323         treeView.getSortOrder().setAll(col);
3324 
3325         assertEquals(1, treeView.getSortOrder().size());
3326         assertEquals(col, treeView.getSortOrder().get(0));
3327 
3328         Toolkit.getToolkit().firePulse();
3329 
3330         assertEquals(root, treeView.getTreeItem(0));
3331         assertEquals(bbb, treeView.getTreeItem(2));
3332         assertEquals(aaa,treeView.getTreeItem(1));
3333 
3334         // set new items into items list - expect sortOrder list to be reset
3335         // and the items list to remain unsorted
3336         TreeItem&lt;String&gt; root2 = new TreeItem&lt;&gt;(&quot;Root&quot;);
3337         root2.setExpanded(true);
3338         TreeItem ccc = new TreeItem(&quot;ccc&quot;);
3339         TreeItem ddd = new TreeItem(&quot;ddd&quot;);
3340         root2.getChildren().setAll(ddd, ccc);
3341         treeView.setRoot(root2);
3342 
3343         assertEquals(root2, treeView.getTreeItem(0));
3344         assertEquals(ddd, treeView.getTreeItem(1));
3345         assertEquals(ccc,treeView.getTreeItem(2));
3346 
3347         assertTrue(treeView.getSortOrder().isEmpty());
3348     }
3349 
3350     @Test public void test_rt35857() {
3351         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3352         root.setExpanded(true);
3353         TreeItem a = new TreeItem(&quot;A&quot;);
3354         TreeItem b = new TreeItem(&quot;B&quot;);
3355         TreeItem c = new TreeItem(&quot;C&quot;);
3356         root.getChildren().setAll(a, b, c);
3357 
3358         final TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;String&gt;(root);
3359 
3360         treeTableView.getSelectionModel().select(1);
3361 
3362         ObservableList&lt;TreeItem&lt;String&gt;&gt; selectedItems = treeTableView.getSelectionModel().getSelectedItems();
3363         assertEquals(1, selectedItems.size());
3364         assertEquals(&quot;A&quot;, selectedItems.get(0).getValue());
3365 
3366         root.getChildren().removeAll(selectedItems);
3367         assertEquals(2, root.getChildren().size());
3368         assertEquals(&quot;B&quot;, root.getChildren().get(0).getValue());
3369         assertEquals(&quot;C&quot;, root.getChildren().get(1).getValue());
3370     }
3371 
3372     private int rt36452_instanceCount = 0;
3373     @Test public void test_rt36452() {
3374         TreeTableColumn&lt;String, String&gt; myColumn = new TreeTableColumn&lt;String,String&gt;();
3375         myColumn.setCellValueFactory((item)-&gt;(new ReadOnlyObjectWrapper&lt;&gt;(item.getValue().getValue())));
3376         myColumn.setCellFactory(column -&gt; new TreeTableCell&lt;String, String&gt;() {
3377             {
3378                 rt36452_instanceCount++;
3379             }
3380         });
3381 
3382         TreeTableView&lt;String&gt; ttv = new TreeTableView&lt;&gt;();
3383         ttv.setShowRoot(false);
3384         ttv.getColumns().add(myColumn);
3385 
3386         TreeItem&lt;String&gt; treeRootItem = new TreeItem&lt;&gt;(&quot;root&quot;);
3387         treeRootItem.setExpanded(true);
3388 
3389         for (int i = 0; i &lt; 100; i++) {
3390             treeRootItem.getChildren().add(new TreeItem&lt;&gt;(&quot;Child: &quot; + i));
3391         }
3392 
3393         ttv.setRoot(treeRootItem);
3394         ttv.setFixedCellSize(25);
3395 
3396         StackPane root = new StackPane();
3397         root.getChildren().add(ttv);
3398 
3399         StageLoader sl = new StageLoader(root);
3400 
3401         final int cellCountAtStart = rt36452_instanceCount;
3402 
3403         // start scrolling
3404         for (int i = 0; i &lt; 100; i++) {
3405             ttv.scrollTo(i);
3406             Toolkit.getToolkit().firePulse();
3407         }
3408 
3409         // we don&#39;t mind if an extra few cells are created. What we are really
3410         // testing for here is that we don&#39;t end up with an order of magnitude
3411         // extra cells.
3412         // On my machine the cellCountAtStart is 16. Before this issue was fixed
3413         // I would end up with 102 instances after running this test. Once the
3414         // bug was fixed, I would consistently see that 17 cells had been
3415         // created in total.
3416         // However, for now, we&#39;ll test on the assumption that across all
3417         // platforms we only get one extra cell created, and we can loosen this
3418         // up if necessary.
3419         assertEquals(cellCountAtStart + 1, rt36452_instanceCount);
3420 
3421         sl.dispose();
3422     }
3423 
3424     @Test public void test_rt25679_rowSelection() {
3425         test_rt25679(true);
3426     }
3427 
3428     @Test public void test_rt25679_cellSelection() {
3429         test_rt25679(false);
3430     }
3431 
3432     private void test_rt25679(boolean rowSelection) {
3433         Button focusBtn = new Button(&quot;Focus here&quot;);
3434 
3435         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3436         root.getChildren().setAll(new TreeItem(&quot;a&quot;), new TreeItem(&quot;b&quot;));
3437         root.setExpanded(true);
3438 
3439         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;(root);
3440         TreeTableColumn&lt;String, String&gt; tableColumn = new TreeTableColumn&lt;&gt;();
3441         tableColumn.setCellValueFactory(rowValue -&gt; new SimpleStringProperty(rowValue.getValue().getValue()));
3442         treeView.getColumns().add(tableColumn);
3443 
3444         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = treeView.getSelectionModel();
3445         sm.setCellSelectionEnabled(! rowSelection);
3446 
3447         VBox vbox = new VBox(focusBtn, treeView);
3448 
3449         StageLoader sl = new StageLoader(vbox);
3450         sl.getStage().requestFocus();
3451         focusBtn.requestFocus();
3452         Toolkit.getToolkit().firePulse();
3453 
3454         // test initial state
3455         assertEquals(sl.getStage().getScene().getFocusOwner(), focusBtn);
3456         assertTrue(focusBtn.isFocused());
3457         assertEquals(-1, sm.getSelectedIndex());
3458         assertNull(sm.getSelectedItem());
3459 
3460         // move focus to the TreeTableView
3461         treeView.requestFocus();
3462 
3463         // ensure that there is a selection (where previously there was not one)
3464         assertEquals(sl.getStage().getScene().getFocusOwner(), treeView);
3465         assertTrue(treeView.isFocused());
3466 
3467         if (rowSelection) {
3468             assertEquals(0, sm.getSelectedIndices().size());
3469             assertNull(sm.getSelectedItem());
3470             assertFalse(sm.isSelected(0));
3471             assertEquals(0, sm.getSelectedCells().size());
3472         } else {
3473             assertFalse(sm.isSelected(0, tableColumn));
3474             assertEquals(0, sm.getSelectedCells().size());
3475         }
3476 
3477         sl.dispose();
3478     }
3479 
3480     @Test public void test_rt36885() {
3481         test_rt36885(false);
3482     }
3483 
3484     @Test public void test_rt36885_addChildAfterSelection() {
3485         test_rt36885(true);
3486     }
3487 
3488     private void test_rt36885(boolean addChildToAAfterSelection) {
3489         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);         // 0
3490                 TreeItem&lt;String&gt; a = new TreeItem&lt;&gt;(&quot;a&quot;);       // 1
3491                     TreeItem&lt;String&gt; a1 = new TreeItem&lt;&gt;(&quot;a1&quot;); // a expanded = 2, a collapsed = -1
3492             TreeItem&lt;String&gt; b = new TreeItem&lt;&gt;(&quot;b&quot;);           // a expanded = 3, a collapsed = 2
3493                 TreeItem&lt;String&gt; b1 = new TreeItem&lt;&gt;(&quot;b1&quot;);     // a expanded = 4, a collapsed = 3
3494                 TreeItem&lt;String&gt; b2 = new TreeItem&lt;&gt;(&quot;b2&quot;);     // a expanded = 5, a collapsed = 4
3495 
3496         root.setExpanded(true);
3497         root.getChildren().setAll(a, b);
3498 
3499         a.setExpanded(false);
3500         if (!addChildToAAfterSelection) {
3501             a.getChildren().add(a1);
3502         }
3503 
3504         b.setExpanded(true);
3505         b.getChildren().addAll(b1, b2);
3506 
3507         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;(root);
3508         TreeTableColumn&lt;String, String&gt; tableColumn = new TreeTableColumn&lt;&gt;();
3509         tableColumn.setCellValueFactory(rowValue -&gt; new SimpleStringProperty(rowValue.getValue().getValue()));
3510         treeView.getColumns().add(tableColumn);
3511 
3512         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = treeView.getSelectionModel();
3513         FocusModel&lt;TreeItem&lt;String&gt;&gt; fm = treeView.getFocusModel();
3514 
3515         sm.select(b1);
3516         assertEquals(3, sm.getSelectedIndex());
3517         assertEquals(b1, sm.getSelectedItem());
3518         assertEquals(3, fm.getFocusedIndex());
3519         assertEquals(b1, fm.getFocusedItem());
3520 
3521         if (addChildToAAfterSelection) {
3522             a.getChildren().add(a1);
3523         }
3524 
3525         a.setExpanded(true);
3526         assertEquals(4, sm.getSelectedIndex());
3527         assertEquals(b1, sm.getSelectedItem());
3528         assertEquals(4, fm.getFocusedIndex());
3529         assertEquals(b1, fm.getFocusedItem());
3530     }
3531 
3532     private int rt_37061_index_counter = 0;
3533     private int rt_37061_item_counter = 0;
3534     @Test public void test_rt_37061() {
3535         TreeItem&lt;Integer&gt; root = new TreeItem&lt;&gt;(0);
3536         root.setExpanded(true);
3537         TreeTableView&lt;Integer&gt; tv = new TreeTableView&lt;&gt;();
3538         tv.setRoot(root);
3539         tv.getSelectionModel().select(0);
3540 
3541         // note we add the listeners after the selection is made, so the counters
3542         // at this point are still both at zero.
3543         tv.getSelectionModel().selectedIndexProperty().addListener((observable, oldValue, newValue) -&gt; {
3544             rt_37061_index_counter++;
3545         });
3546 
3547         tv.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -&gt; {
3548             rt_37061_item_counter++;
3549         });
3550 
3551         // add a new item. This does not impact the selected index or selected item
3552         // so the counters should remain at zero.
3553         tv.getRoot().getChildren().add(new TreeItem(&quot;1&quot;));
3554         assertEquals(0, rt_37061_index_counter);
3555         assertEquals(0, rt_37061_item_counter);
3556     }
3557 
3558     @Test public void test_rt_37054_noScroll() {
3559         test_rt_37054(false);
3560     }
3561 
3562     @Test public void test_rt_37054_scroll() {
3563         test_rt_37054(true);
3564     }
3565 
3566     private void test_rt_37054(boolean scroll) {
3567         ObjectProperty&lt;Integer&gt; offset = new SimpleObjectProperty&lt;Integer&gt;(0);
3568 
3569         // create table with a bunch of rows and 1 column...
3570         TreeItem&lt;Integer&gt; root = new TreeItem&lt;&gt;(0);
3571         root.setExpanded(true);
3572         for (int i = 1; i &lt;= 50; i++) {
3573             root.getChildren().add(new TreeItem&lt;&gt;(i));
3574         }
3575 
3576         final TreeTableColumn&lt;Integer, Integer&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
3577 
3578         final TreeTableView&lt;Integer&gt; table = new TreeTableView&lt;&gt;(root);
3579         table.getColumns().add( column );
3580         column.setPrefWidth( 150 );
3581 
3582         // each cell displays x, where x = &quot;cell row number + offset&quot;
3583         column.setCellValueFactory( cdf -&gt; new ObjectBinding&lt;Integer&gt;() {
3584             { super.bind( offset ); }
3585 
3586             @Override protected Integer computeValue() {
3587                 return cdf.getValue().getValue() + offset.get();
3588             }
3589         });
3590 
3591         StackPane stack = new StackPane();
3592         stack.getChildren().add(table);
3593         StageLoader sl = new StageLoader(stack);
3594 
3595         int index = scroll ? 0 : 25;
3596 
3597         if (scroll) {
3598             // we scroll to force the table cells to update the objects they observe
3599             table.scrollTo(index);
3600             Toolkit.getToolkit().firePulse();
3601         }
3602 
3603         TreeTableCell cell = (TreeTableCell) VirtualFlowTestUtils.getCell(table, index + 3, 0);
3604         final int initialValue = (Integer) cell.getItem();
3605 
3606         // increment the offset value
3607         offset.setValue(offset.get() + 1);
3608         Toolkit.getToolkit().firePulse();
3609 
3610         final int incrementedValue = (Integer) cell.getItem();
3611         assertEquals(initialValue + 1, incrementedValue);
3612 
3613         sl.dispose();
3614     }
3615 
3616     private int rt_37395_index_addCount = 0;
3617     private int rt_37395_index_removeCount = 0;
3618     private int rt_37395_index_permutationCount = 0;
3619     private int rt_37395_item_addCount = 0;
3620     private int rt_37395_item_removeCount = 0;
3621     private int rt_37395_item_permutationCount = 0;
3622 
3623     @Test public void test_rt_37395() {
3624         // table items - 3 items, 2nd item has 2 children
3625         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;();
3626 
3627         TreeItem&lt;String&gt; two = new TreeItem&lt;&gt;(&quot;two&quot;);
3628         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childOne&quot;));
3629         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childTwo&quot;));
3630 
3631         root.getChildren().add(new TreeItem&lt;&gt;(&quot;one&quot;));
3632         root.getChildren().add(two);
3633         root.getChildren().add(new TreeItem&lt;&gt;(&quot;three&quot;));
3634 
3635         // table columns - 1 column; name
3636         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;name&quot;);
3637         nameColumn.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper(param.getValue().getValue()));
3638         nameColumn.setPrefWidth(200);
3639 
3640         // table
3641         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3642         table.setShowRoot(false);
3643         table.setRoot(root);
3644         table.getColumns().addAll(nameColumn);
3645 
3646         TreeTableView.TreeTableViewSelectionModel sm = table.getSelectionModel();
3647         sm.getSelectedIndices().addListener(new ListChangeListener&lt;Integer&gt;() {
3648             @Override public void onChanged(Change&lt;? extends Integer&gt; c) {
3649                 while (c.next()) {
3650                     if (c.wasRemoved()) {
3651                         c.getRemoved().forEach(item -&gt; {
3652                             if (item == null) {
3653                                 fail(&quot;Removed index should never be null&quot;);
3654                             } else {
3655                                 rt_37395_index_removeCount++;
3656                             }
3657                         });
3658                     }
3659                     if (c.wasAdded()) {
3660                         c.getAddedSubList().forEach(item -&gt; {
3661                             rt_37395_index_addCount++;
3662                         });
3663                     }
3664                     if (c.wasPermutated()) {
3665                         rt_37395_index_permutationCount++;
3666                     }
3667                 }
3668             }
3669         });
3670         sm.getSelectedItems().addListener(new ListChangeListener&lt;TreeItem&lt;String&gt;&gt;() {
3671             @Override public void onChanged(Change&lt;? extends TreeItem&lt;String&gt;&gt; c) {
3672                 while (c.next()) {
3673                     if (c.wasRemoved()) {
3674                         c.getRemoved().forEach(item -&gt; {
3675                             if (item == null) {
3676                                 fail(&quot;Removed item should never be null&quot;);
3677                             } else {
3678                                 rt_37395_item_removeCount++;
3679                             }
3680                         });
3681                     }
3682                     if (c.wasAdded()) {
3683                         c.getAddedSubList().forEach(item -&gt; {
3684                             rt_37395_item_addCount++;
3685                         });
3686                     }
3687                     if (c.wasPermutated()) {
3688                         rt_37395_item_permutationCount++;
3689                     }
3690                 }
3691             }
3692         });
3693 
3694         assertEquals(0, rt_37395_index_removeCount);
3695         assertEquals(0, rt_37395_index_addCount);
3696         assertEquals(0, rt_37395_index_permutationCount);
3697         assertEquals(0, rt_37395_item_removeCount);
3698         assertEquals(0, rt_37395_item_addCount);
3699         assertEquals(0, rt_37395_item_permutationCount);
3700 
3701         StageLoader sl = new StageLoader(table);
3702 
3703         // step one: select item &#39;three&#39; in index 2
3704         sm.select(2);
3705         assertEquals(0, rt_37395_index_removeCount);
3706         assertEquals(1, rt_37395_index_addCount);
3707         assertEquals(0, rt_37395_index_permutationCount);
3708         assertEquals(0, rt_37395_item_removeCount);
3709         assertEquals(1, rt_37395_item_addCount);
3710         assertEquals(0, rt_37395_item_permutationCount);
3711 
3712         // step two: expand item &#39;two&#39;
3713         // The first part of the bug report was that we received add/remove
3714         // change events here, when in reality we shouldn&#39;t have, so lets enforce
3715         // that. We do expect a permutation event on the index, as it has been
3716         // pushed down, but this should not result in an item permutation event,
3717         // as it remains unchanged
3718         two.setExpanded(true);
3719         assertEquals(1, rt_37395_index_removeCount);
3720         assertEquals(2, rt_37395_index_addCount);
3721         assertEquals(0, rt_37395_index_permutationCount);
3722         assertEquals(0, rt_37395_item_removeCount);
3723         assertEquals(1, rt_37395_item_addCount);
3724         assertEquals(0, rt_37395_item_permutationCount);
3725 
3726         // step three: collapse item &#39;two&#39;
3727         // Same argument as in step two above: no addition or removal, just a
3728         // permutation on the index
3729         two.setExpanded(false);
3730         assertEquals(2, rt_37395_index_removeCount);
3731         assertEquals(3, rt_37395_index_addCount);
3732         assertEquals(0, rt_37395_index_permutationCount);
3733         assertEquals(0, rt_37395_item_removeCount);
3734         assertEquals(1, rt_37395_item_addCount);
3735         assertEquals(0, rt_37395_item_permutationCount);
3736 
3737         sl.dispose();
3738     }
3739 
3740     @Test public void test_rt_37429() {
3741         // table items - 3 items, 2nd item has 2 children
3742         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;();
3743 
3744         TreeItem&lt;String&gt; two = new TreeItem&lt;&gt;(&quot;two&quot;);
3745         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childOne&quot;));
3746         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childTwo&quot;));
3747         two.setExpanded(true);
3748 
3749         root.getChildren().add(new TreeItem&lt;&gt;(&quot;one&quot;));
3750         root.getChildren().add(two);
3751         root.getChildren().add(new TreeItem&lt;&gt;(&quot;three&quot;));
3752 
3753         // table columns - 1 column; name
3754         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;name&quot;);
3755         nameColumn.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper(param.getValue().getValue()));
3756         nameColumn.setPrefWidth(200);
3757 
3758         // table
3759         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3760         table.setShowRoot(false);
3761         table.setRoot(root);
3762         table.getColumns().addAll(nameColumn);
3763 
3764         table.getSelectionModel().getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) c -&gt; {
3765             while (c.next()) {
3766                 if(c.wasRemoved()) {
3767                     // The removed list of items must be iterated or the AIOOBE will
3768                     // not be thrown when getAddedSubList is called.
3769                     c.getRemoved().forEach(item -&gt; {});
3770                 }
3771 
3772                 if (c.wasAdded()) {
3773                     c.getAddedSubList();
3774                 }
3775             }
3776         });
3777 
3778         StageLoader sl = new StageLoader(table);
3779 
3780         ControlTestUtils.runWithExceptionHandler(() -&gt; {
3781             table.getSelectionModel().select(0);
3782             table.getSortOrder().add(nameColumn);
3783         });
3784 
3785         sl.dispose();
3786     }
3787 
3788     private int rt_37429_items_change_count = 0;
3789     private int rt_37429_cells_change_count = 0;
3790     @Test public void test_rt_37429_sortEventsShouldNotFireExtraChangeEvents() {
3791         // table items - 3 items, 2nd item has 2 children
3792         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;();
3793 
3794         root.getChildren().add(new TreeItem&lt;&gt;(&quot;a&quot;));
3795         root.getChildren().add(new TreeItem&lt;&gt;(&quot;c&quot;));
3796         root.getChildren().add(new TreeItem&lt;&gt;(&quot;b&quot;));
3797 
3798         // table columns - 1 column; name
3799         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;name&quot;);
3800         nameColumn.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper(param.getValue().getValue()));
3801         nameColumn.setPrefWidth(200);
3802 
3803         // table
3804         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3805         table.setShowRoot(false);
3806         table.setRoot(root);
3807         table.getColumns().addAll(nameColumn);
3808 
3809         table.getSelectionModel().getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) c -&gt; {
3810             while (c.next()) {
3811                 rt_37429_items_change_count++;
3812             }
3813         });
3814         table.getSelectionModel().getSelectedCells().addListener((ListChangeListener&lt;TreeTablePosition&lt;String, ?&gt;&gt;) c -&gt; {
3815             while (c.next()) {
3816                 rt_37429_cells_change_count++;
3817             }
3818         });
3819 
3820         StageLoader sl = new StageLoader(table);
3821 
3822         assertEquals(0, rt_37429_items_change_count);
3823         assertEquals(0, rt_37429_cells_change_count);
3824 
3825         table.getSelectionModel().select(0);
3826         assertEquals(1, rt_37429_items_change_count);
3827         assertEquals(1, rt_37429_cells_change_count);
3828 
3829         table.getSortOrder().add(nameColumn);
3830         assertEquals(1, rt_37429_items_change_count);
3831         assertEquals(1, rt_37429_cells_change_count);
3832 
3833         nameColumn.setSortType(TreeTableColumn.SortType.DESCENDING);
3834         assertEquals(1, rt_37429_items_change_count);
3835         assertEquals(2, rt_37429_cells_change_count);
3836 
3837         nameColumn.setSortType(TreeTableColumn.SortType.ASCENDING);
3838         assertEquals(1, rt_37429_items_change_count);
3839         assertEquals(3, rt_37429_cells_change_count);
3840 
3841         sl.dispose();
3842     }
3843 
3844     private int rt_37538_count = 0;
3845     @Test public void test_rt_37538_noCNextCall() {
3846         test_rt_37538(false, false);
3847     }
3848 
3849     @Test public void test_rt_37538_callCNextOnce() {
3850         test_rt_37538(true, false);
3851     }
3852 
3853     @Test public void test_rt_37538_callCNextInLoop() {
3854         test_rt_37538(false, true);
3855     }
3856 
3857     private void test_rt_37538(boolean callCNextOnce, boolean callCNextInLoop) {
3858         // create table with a bunch of rows and 1 column...
3859         TreeItem&lt;Integer&gt; root = new TreeItem&lt;&gt;(0);
3860         root.setExpanded(true);
3861         for (int i = 1; i &lt;= 50; i++) {
3862             root.getChildren().add(new TreeItem&lt;&gt;(i));
3863         }
3864 
3865         final TreeTableColumn&lt;Integer, Integer&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
3866         column.setCellValueFactory( cdf -&gt; new ReadOnlyObjectWrapper&lt;Integer&gt;(cdf.getValue().getValue()));
3867 
3868         final TreeTableView&lt;Integer&gt; table = new TreeTableView&lt;&gt;(root);
3869         table.getColumns().add( column );
3870 
3871         table.getSelectionModel().getSelectedItems().addListener((ListChangeListener.Change&lt;? extends TreeItem&lt;Integer&gt;&gt; c) -&gt; {
3872             if (callCNextOnce) {
3873                 c.next();
3874             } else if (callCNextInLoop) {
3875                 while (c.next()) {
3876                     // no-op
3877                 }
3878             }
3879 
3880             if (rt_37538_count &gt;= 1) {
3881                 Thread.dumpStack();
3882                 fail(&quot;This method should only be called once&quot;);
3883             }
3884 
3885             rt_37538_count++;
3886         });
3887 
3888         StageLoader sl = new StageLoader(table);
3889         assertEquals(0, rt_37538_count);
3890         table.getSelectionModel().select(0);
3891         assertEquals(1, rt_37538_count);
3892         sl.dispose();
3893     }
3894 
3895     @Test public void test_rt_37593() {
3896         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;();
3897 
3898         TreeItem&lt;String&gt; one = new TreeItem&lt;&gt;(&quot;one&quot;);
3899         root.getChildren().add(one);
3900 
3901         TreeItem&lt;String&gt; two = new TreeItem&lt;&gt;(&quot;two&quot;);
3902         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childOne&quot;));
3903         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childTwo&quot;));
3904         root.getChildren().add(two);
3905 
3906         root.getChildren().add(new TreeItem&lt;&gt;(&quot;three&quot;));
3907 
3908         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;name&quot;);
3909         nameColumn.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper(param.getValue().getValue()));
3910 
3911         treeTableView.setShowRoot(false);
3912         treeTableView.setRoot(root);
3913         treeTableView.getColumns().addAll(nameColumn);
3914 
3915         treeTableView.getSortOrder().add(nameColumn);
3916         nameColumn.setSortType(TreeTableColumn.SortType.DESCENDING);
3917         sm.select(one);
3918 
3919         // at this point, the &#39;one&#39; item should be in row 2
3920         assertTrue(sm.isSelected(2));
3921         assertEquals(one, sm.getSelectedItem());
3922 
3923         two.setExpanded(true);
3924 
3925         // we should end up with the selection being on index 4, which is the
3926         // final location of the &#39;one&#39; tree item, after sorting and expanding &#39;two&#39;
3927         assertEquals(one, sm.getSelectedItem());
3928         assertTrue(debug(), sm.isSelected(4));
3929 
3930         // this line would create a NPE
3931         VirtualFlowTestUtils.clickOnRow(treeTableView, 4, true);
3932 
3933         // The mouse click should not change selection at all
3934         assertEquals(one, sm.getSelectedItem());
3935         assertTrue(debug(), sm.isSelected(4));
3936     }
3937 
3938     @Test public void test_rt_35395_testCell_fixedCellSize() {
3939         test_rt_35395(true, true);
3940     }
3941 
3942     @Test public void test_rt_35395_testCell_notFixedCellSize() {
3943         test_rt_35395(true, false);
3944     }
3945 
3946     @Ignore(&quot;Fix not yet developed for TreeTableView&quot;)
3947     @Test public void test_rt_35395_testRow_fixedCellSize() {
3948         test_rt_35395(false, true);
3949     }
3950 
3951     @Ignore(&quot;Fix not yet developed for TreeTableView&quot;)
3952     @Test public void test_rt_35395_testRow_notFixedCellSize() {
3953         test_rt_35395(false, false);
3954     }
3955 
3956     private int rt_35395_counter;
3957     private void test_rt_35395(boolean testCell, boolean useFixedCellSize) {
3958         rt_35395_counter = 0;
3959 
3960         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;green&quot;);
3961         root.setExpanded(true);
3962         for (int i = 0; i &lt; 20; i++) {
3963             root.getChildren().addAll(new TreeItem&lt;&gt;(&quot;red&quot;), new TreeItem&lt;&gt;(&quot;green&quot;), new TreeItem&lt;&gt;(&quot;blue&quot;), new TreeItem&lt;&gt;(&quot;purple&quot;));
3964         }
3965 
3966         TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;&gt;(root);
3967         if (useFixedCellSize) {
3968             treeTableView.setFixedCellSize(24);
3969         }
3970         treeTableView.setRowFactory(tv -&gt; new TreeTableRowShim&lt;String&gt;() {
3971             @Override public void updateItem(String color, boolean empty) {
3972                 rt_35395_counter += testCell ? 0 : 1;
3973                 super.updateItem(color, empty);
3974             }
3975         });
3976 
3977         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
3978         column.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
3979         column.setCellFactory(tv -&gt; new TreeTableCellShim&lt;String,String&gt;() {
3980             @Override public void updateItem(String color, boolean empty) {
3981                 rt_35395_counter += testCell ? 1 : 0;
3982                 super.updateItem(color, empty);
3983                 setText(null);
3984                 if (empty) {
3985                     setGraphic(null);
3986                 } else {
3987                     Rectangle rect = new Rectangle(16, 16);
3988                     rect.setStyle(&quot;-fx-fill: &quot; + color);
3989                     setGraphic(rect);
3990                 }
3991             }
3992         });
3993         treeTableView.getColumns().addAll(column);
3994 
3995         StageLoader sl = new StageLoader(treeTableView);
3996 
3997         Platform.runLater(() -&gt; {
3998             rt_35395_counter = 0;
3999             root.getChildren().set(10, new TreeItem&lt;&gt;(&quot;yellow&quot;));
4000             Platform.runLater(() -&gt; {
4001                 Toolkit.getToolkit().firePulse();
4002                 assertEquals(1, rt_35395_counter);
4003                 rt_35395_counter = 0;
4004                 root.getChildren().set(30, new TreeItem&lt;&gt;(&quot;yellow&quot;));
4005                 Platform.runLater(() -&gt; {
4006                     Toolkit.getToolkit().firePulse();
4007                     assertEquals(0, rt_35395_counter);
4008                     rt_35395_counter = 0;
4009                     treeTableView.scrollTo(5);
4010                     Platform.runLater(() -&gt; {
4011                         Toolkit.getToolkit().firePulse();
4012                         assertEquals(useFixedCellSize ? 5 : 5, rt_35395_counter);
4013                         rt_35395_counter = 0;
4014                         treeTableView.scrollTo(55);
4015                         Platform.runLater(() -&gt; {
4016                             Toolkit.getToolkit().firePulse();
4017 
4018                             assertEquals(useFixedCellSize ? 7 : 59, rt_35395_counter);
4019                             sl.dispose();
4020                         });
4021                     });
4022                 });
4023             });
4024         });
4025     }
4026 
4027     @Test public void test_rt_37632() {
4028         final TreeItem&lt;String&gt; rootOne = new TreeItem&lt;&gt;(&quot;Root 1&quot;);
4029         final TreeItem&lt;String&gt; rootTwo = new TreeItem&lt;&gt;(&quot;Root 2&quot;);
4030 
4031         TreeTableColumn&lt;String,String&gt; tableColumn = new TreeTableColumn(&quot;column&quot;);
4032         tableColumn.setCellValueFactory(c -&gt; new ReadOnlyStringWrapper(c.getValue().getValue()));
4033 
4034         final TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;&gt;();
4035         treeTableView.getColumns().addAll(tableColumn);
4036         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = treeTableView.getSelectionModel();
4037         treeTableView.setRoot(rootOne);
4038         treeTableView.getSelectionModel().selectFirst();
4039 
4040         assertEquals(0, sm.getSelectedIndex());
4041         assertEquals(rootOne, sm.getSelectedItem());
4042         assertEquals(1, sm.getSelectedIndices().size());
4043         assertEquals(0, (int) sm.getSelectedIndices().get(0));
4044         assertEquals(1, sm.getSelectedItems().size());
4045         assertEquals(rootOne, sm.getSelectedItems().get(0));
4046 
4047         treeTableView.setRoot(rootTwo);
4048 
4049         assertEquals(-1, sm.getSelectedIndex());
4050         assertNull(sm.getSelectedItem());
4051         assertEquals(0, sm.getSelectedIndices().size());
4052         assertEquals(0, sm.getSelectedItems().size());
4053     }
4054 
4055     private TreeTableView&lt;Person&gt; test_rt_38464_createControl() {
4056         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
4057                 new TreeItem&lt;&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
4058                 new TreeItem&lt;&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
4059                 new TreeItem&lt;&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
4060                 new TreeItem&lt;&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
4061                 new TreeItem&lt;&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
4062 
4063         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
4064         table.setShowRoot(false);
4065 
4066         TreeItem&lt;Person&gt; root = new TreeItem&lt;&gt;(new Person(&quot;Root&quot;, null, null));
4067         root.setExpanded(true);
4068         root.getChildren().setAll(persons);
4069         table.setRoot(root);
4070 
4071 
4072 
4073         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
4074         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
4075 
4076         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
4077         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
4078 
4079         table.getColumns().addAll(firstNameCol, lastNameCol);
4080 
4081         return table;
4082     }
4083 
4084     @Test public void test_rt_38464_rowSelection_selectFirstRowOnly() {
4085         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4086         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4087         sm.setCellSelectionEnabled(false);
4088         sm.setSelectionMode(SelectionMode.MULTIPLE);
4089 
4090         sm.select(0);
4091 
4092         assertTrue(sm.isSelected(0));
4093         assertTrue(sm.isSelected(0, table.getColumns().get(0)));
4094         assertTrue(sm.isSelected(0, table.getColumns().get(1)));
4095 
4096         assertEquals(1, sm.getSelectedIndices().size());
4097         assertEquals(1, sm.getSelectedItems().size());
4098         assertEquals(1, sm.getSelectedCells().size());
4099     }
4100 
4101     @Test public void test_rt_38464_rowSelection_selectFirstRowAndThenCallNoOpMethods() {
4102         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4103         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4104         sm.setCellSelectionEnabled(false);
4105         sm.setSelectionMode(SelectionMode.MULTIPLE);
4106 
4107         sm.select(0);               // select first row
4108         sm.select(0);               // this should be a no-op
4109         sm.select(0, table.getColumns().get(0)); // so should this, as we are in row selection mode
4110         sm.select(0, table.getColumns().get(1));  // and same here
4111 
4112         assertTrue(sm.isSelected(0));
4113         assertTrue(sm.isSelected(0, table.getColumns().get(0)));
4114         assertTrue(sm.isSelected(0, table.getColumns().get(1)));
4115 
4116         assertEquals(1, sm.getSelectedIndices().size());
4117         assertEquals(1, sm.getSelectedItems().size());
4118         assertEquals(1, sm.getSelectedCells().size());
4119     }
4120 
4121 
4122     @Test public void test_rt_38464_cellSelection_selectFirstRowOnly() {
4123         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4124         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4125         sm.setCellSelectionEnabled(true);
4126         sm.setSelectionMode(SelectionMode.MULTIPLE);
4127 
4128         // select first row. This should be translated into selection of all
4129         // cells in this row, and (as of JDK 9) _does_ result in the row itself being
4130         // considered selected.
4131         sm.select(0);
4132 
4133         assertTrue(sm.isSelected(0));
4134         assertTrue(sm.isSelected(0, table.getColumns().get(0)));
4135         assertTrue(sm.isSelected(0, table.getColumns().get(1)));
4136 
4137         assertEquals(1, sm.getSelectedIndices().size());
4138         assertEquals(1, sm.getSelectedItems().size());
4139         assertEquals(2, sm.getSelectedCells().size());
4140     }
4141 
4142     @Test public void test_rt_38464_cellSelection_selectFirstRowAndThenCallNoOpMethods() {
4143         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4144         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4145         sm.setCellSelectionEnabled(true);
4146         sm.setSelectionMode(SelectionMode.MULTIPLE);
4147 
4148         // select first row. This should be translated into selection of all
4149         // cells in this row, and (as of JDK 9) _does_ result in the row itself being
4150         // considered selected.
4151         sm.select(0);                            // select first row
4152         sm.select(0, table.getColumns().get(0)); // This line and the next should be no-ops
4153         sm.select(0, table.getColumns().get(1));
4154 
4155         assertTrue(sm.isSelected(0));
4156         assertTrue(sm.isSelected(0, table.getColumns().get(0)));
4157         assertTrue(sm.isSelected(0, table.getColumns().get(1)));
4158 
4159         assertEquals(1, sm.getSelectedIndices().size());
4160         assertEquals(1, sm.getSelectedItems().size());
4161         assertEquals(2, sm.getSelectedCells().size());
4162     }
4163 
4164     @Test public void test_rt38464_selectCellMultipleTimes() {
4165         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4166         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4167         sm.setCellSelectionEnabled(true);
4168         sm.setSelectionMode(SelectionMode.MULTIPLE);
4169 
4170         // default selection when in cell selection mode
4171         assertEquals(0, sm.getSelectedCells().size());
4172         assertEquals(0, sm.getSelectedItems().size());
4173         assertEquals(0, sm.getSelectedIndices().size());
4174 
4175         // select the first cell
4176         sm.select(0, table.getColumns().get(0));
4177         assertEquals(1, sm.getSelectedCells().size());
4178         assertEquals(1, sm.getSelectedItems().size());
4179         assertEquals(1, sm.getSelectedIndices().size());
4180 
4181         // select the first cell....again
4182         sm.select(0, table.getColumns().get(0));
4183         assertEquals(1, sm.getSelectedCells().size());
4184         assertEquals(1, sm.getSelectedItems().size());
4185         assertEquals(1, sm.getSelectedIndices().size());
4186     }
4187 
4188     @Test public void test_rt38464_selectCellThenRow() {
4189         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4190         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4191         sm.setCellSelectionEnabled(true);
4192         sm.setSelectionMode(SelectionMode.MULTIPLE);
4193 
4194         // default selection when in cell selection mode
4195         assertEquals(0, sm.getSelectedCells().size());
4196         assertEquals(0, sm.getSelectedItems().size());
4197         assertEquals(0, sm.getSelectedIndices().size());
4198 
4199         // select the first cell
4200         sm.select(0, table.getColumns().get(0));
4201         assertEquals(1, sm.getSelectedCells().size());
4202         assertEquals(1, sm.getSelectedItems().size());
4203         assertEquals(1, sm.getSelectedIndices().size());
4204 
4205         // select the first row
4206         sm.select(0);
4207 
4208         // we go to 2 here as all cells in the row become selected. What we do
4209         // not expect is to go to 3, as that would mean duplication
4210         assertEquals(2, sm.getSelectedCells().size());
4211         assertEquals(1, sm.getSelectedItems().size());
4212         assertEquals(1, sm.getSelectedIndices().size());
4213     }
4214 
4215     @Test public void test_rt38464_selectRowThenCell() {
4216         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4217         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4218         sm.setCellSelectionEnabled(true);
4219         sm.setSelectionMode(SelectionMode.MULTIPLE);
4220 
4221         // default selection when in cell selection mode
4222         assertEquals(0, sm.getSelectedCells().size());
4223         assertEquals(0, sm.getSelectedItems().size());
4224         assertEquals(0, sm.getSelectedIndices().size());
4225 
4226         // select the first row
4227         sm.select(0);
4228 
4229         // we go to 2 here as all cells in the row become selected.
4230         assertEquals(2, sm.getSelectedCells().size());
4231         assertEquals(1, sm.getSelectedItems().size());
4232         assertEquals(1, sm.getSelectedIndices().size());
4233 
4234         // select the first cell - no change is expected
4235         sm.select(0, table.getColumns().get(0));
4236         assertEquals(2, sm.getSelectedCells().size());
4237         assertEquals(1, sm.getSelectedItems().size());
4238         assertEquals(1, sm.getSelectedIndices().size());
4239     }
4240 
4241     @Test public void test_rt38464_selectTests_cellSelection_singleSelection_selectsOneRow() {
4242         test_rt38464_selectTests(true, true, true);
4243     }
4244 
4245     @Test public void test_rt38464_selectTests_cellSelection_singleSelection_selectsTwoRows() {
4246         test_rt38464_selectTests(true, true, false);
4247     }
4248 
4249     @Test public void test_rt38464_selectTests_cellSelection_multipleSelection_selectsOneRow() {
4250         test_rt38464_selectTests(true, false, true);
4251     }
4252 
4253     @Test public void test_rt38464_selectTests_cellSelection_multipleSelection_selectsTwoRows() {
4254         test_rt38464_selectTests(true, false, false);
4255     }
4256 
4257     @Test public void test_rt38464_selectTests_rowSelection_singleSelection_selectsOneRow() {
4258         test_rt38464_selectTests(false, true, true);
4259     }
4260 
4261     @Test public void test_rt38464_selectTests_rowSelection_singleSelection_selectsTwoRows() {
4262         test_rt38464_selectTests(false, true, false);
4263     }
4264 
4265     @Test public void test_rt38464_selectTests_rowSelection_multipleSelection_selectsOneRow() {
4266         test_rt38464_selectTests(false, false, true);
4267     }
4268 
4269     @Test public void test_rt38464_selectTests_rowSelection_multipleSelection_selectsTwoRows() {
4270         test_rt38464_selectTests(false, false, false);
4271     }
4272 
4273     private void test_rt38464_selectTests(boolean cellSelection, boolean singleSelection, boolean selectsOneRow) {
4274         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4275         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4276         sm.setCellSelectionEnabled(cellSelection);
4277         sm.setSelectionMode(singleSelection ? SelectionMode.SINGLE : SelectionMode.MULTIPLE);
4278 
4279         // default selection when in cell selection mode
4280         assertEquals(0, sm.getSelectedCells().size());
4281         assertEquals(0, sm.getSelectedItems().size());
4282         assertEquals(0, sm.getSelectedIndices().size());
4283 
4284         if (selectsOneRow) {
4285             sm.select(0);
4286         } else {
4287             // select the first two rows
4288             sm.selectIndices(0, 1);
4289         }
4290 
4291         final int expectedCells = singleSelection                    ? 1 :
4292                                   selectsOneRow   &amp;&amp; cellSelection   ? 2 :
4293                                   selectsOneRow   &amp;&amp; !cellSelection  ? 1 :
4294                                   !selectsOneRow  &amp;&amp; cellSelection   ? 4 :
4295                                /* !selectsOneRow  &amp;&amp; !cellSelection */ 2;
4296 
4297         final int expectedItems = singleSelection ? 1 :
4298                 selectsOneRow   ? 1 : 2;
4299 
4300         assertEquals(expectedCells, sm.getSelectedCells().size());
4301         assertEquals(expectedItems, sm.getSelectedItems().size());
4302         assertEquals(expectedItems, sm.getSelectedIndices().size());
4303 
4304         // we expect the table column of all selected cells, in this instance,
4305         // to be null as we have not explicitly stated a column, nor have we clicked
4306         // on a column. The only alternative is to use the first column.
4307         for (TreeTablePosition&lt;?,?&gt; tp : sm.getSelectedCells()) {
4308             if (cellSelection) {
4309                 assertNotNull(tp.getTableColumn());
4310             } else {
4311                 assertNull(tp.getTableColumn());
4312             }
4313         }
4314     }
4315 
4316     @Test public void test_rt_37853_replaceRoot() {
4317         test_rt_37853(true);
4318     }
4319 
4320     @Test public void test_rt_37853_replaceRootChildren() {
4321         test_rt_37853(false);
4322     }
4323 
4324     private int rt_37853_cancelCount;
4325     private int rt_37853_commitCount;
4326     public void test_rt_37853(boolean replaceRoot) {
4327         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;&gt;(&quot;first&quot;);
4328         first.setEditable(true);
4329         first.setCellFactory(TextFieldTreeTableCell.forTreeTableColumn());
4330         treeTableView.getColumns().add(first);
4331         treeTableView.setEditable(true);
4332         treeTableView.setRoot(new TreeItem&lt;&gt;(&quot;Root&quot;));
4333         treeTableView.getRoot().setExpanded(true);
4334 
4335         for (int i = 0; i &lt; 10; i++) {
4336             treeTableView.getRoot().getChildren().add(new TreeItem&lt;&gt;(&quot;&quot; + i));
4337         }
4338 
4339         StageLoader sl = new StageLoader(treeTableView);
4340 
4341         first.setOnEditCancel(editEvent -&gt; rt_37853_cancelCount++);
4342         first.setOnEditCommit(editEvent -&gt; rt_37853_commitCount++);
4343 
4344         assertEquals(0, rt_37853_cancelCount);
4345         assertEquals(0, rt_37853_commitCount);
4346 
4347         treeTableView.edit(1, first);
4348         assertNotNull(treeTableView.getEditingCell());
4349 
4350         if (replaceRoot) {
4351             treeTableView.setRoot(new TreeItem&lt;&gt;(&quot;New Root&quot;));
4352         } else {
4353             treeTableView.getRoot().getChildren().clear();
4354             for (int i = 0; i &lt; 10; i++) {
4355                 treeTableView.getRoot().getChildren().add(new TreeItem&lt;&gt;(&quot;new item &quot; + i));
4356             }
4357         }
4358         assertEquals(1, rt_37853_cancelCount);
4359         assertEquals(0, rt_37853_commitCount);
4360 
4361         sl.dispose();
4362     }
4363 
4364 
4365     /**************************************************************************
4366      *
4367      * Tests (and related code) for RT-38892
4368      *
4369      *************************************************************************/
4370 
4371     private final Supplier&lt;TreeTableColumn&lt;Person,String&gt;&gt; columnCallable = () -&gt; {
4372         TreeTableColumn&lt;Person,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Last Name&quot;);
4373         column.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person,String&gt;(&quot;lastName&quot;));
4374         return column;
4375     };
4376 
4377     private TreeTableColumn&lt;Person, String&gt; test_rt_38892_firstNameCol;
4378     private TreeTableColumn&lt;Person, String&gt; test_rt_38892_lastNameCol;
4379 
4380     private TreeTableView&lt;Person&gt; init_test_rt_38892() {
4381         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
4382                 new TreeItem&lt;&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
4383                 new TreeItem&lt;&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
4384                 new TreeItem&lt;&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
4385                 new TreeItem&lt;&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
4386                 new TreeItem&lt;&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
4387 
4388         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
4389         table.setShowRoot(false);
4390         table.getSelectionModel().setCellSelectionEnabled(true);
4391         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
4392 
4393         TreeItem&lt;Person&gt; root = new TreeItem&lt;&gt;(new Person(&quot;Root&quot;, null, null));
4394         root.setExpanded(true);
4395         root.getChildren().setAll(persons);
4396         table.setRoot(root);
4397 
4398         test_rt_38892_firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
4399         test_rt_38892_firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;&gt;(&quot;firstName&quot;));
4400         test_rt_38892_lastNameCol = columnCallable.get();
4401         table.getColumns().addAll(test_rt_38892_firstNameCol, test_rt_38892_lastNameCol);
4402 
4403         return table;
4404     }
4405 
4406     @Test public void test_rt_38892_focusMovesToLeftWhenPossible() {
4407         TreeTableView&lt;Person&gt; table = init_test_rt_38892();
4408 
4409         TreeTableView.TreeTableViewFocusModel&lt;Person&gt; fm = table.getFocusModel();
4410         fm.focus(0, test_rt_38892_lastNameCol);
4411 
4412         // assert pre-conditions
4413         assertEquals(0, fm.getFocusedIndex());
4414         assertEquals(0, fm.getFocusedCell().getRow());
4415         assertEquals(test_rt_38892_lastNameCol, fm.getFocusedCell().getTableColumn());
4416         assertEquals(1, fm.getFocusedCell().getColumn());
4417 
4418         // now remove column where focus is and replace it with a new column.
4419         // We expect focus to move to the left one cell.
4420         table.getColumns().remove(1);
4421         table.getColumns().add(columnCallable.get());
4422 
4423         assertEquals(0, fm.getFocusedIndex());
4424         assertEquals(0, fm.getFocusedCell().getRow());
4425         assertEquals(test_rt_38892_firstNameCol, fm.getFocusedCell().getTableColumn());
4426         assertEquals(0, fm.getFocusedCell().getColumn());
4427     }
4428 
4429     @Test public void test_rt_38892_removeLeftMostColumn() {
4430         TreeTableView&lt;Person&gt; table = init_test_rt_38892();
4431 
4432         TreeTableView.TreeTableViewFocusModel&lt;Person&gt; fm = table.getFocusModel();
4433         fm.focus(0, test_rt_38892_firstNameCol);
4434 
4435         // assert pre-conditions
4436         assertEquals(0, fm.getFocusedIndex());
4437         assertEquals(0, fm.getFocusedCell().getRow());
4438         assertEquals(test_rt_38892_firstNameCol, fm.getFocusedCell().getTableColumn());
4439         assertEquals(0, fm.getFocusedCell().getColumn());
4440 
4441         // now remove column where focus is and replace it with a new column.
4442         // In the current (non-specified) behavior, this results in focus being
4443         // shifted to a cell in the remaining column, even when we add a new column
4444         // as we index based on the column, not on its index.
4445         table.getColumns().remove(0);
4446         TreeTableColumn&lt;Person,String&gt; newColumn = columnCallable.get();
4447         table.getColumns().add(0, newColumn);
4448 
4449         assertEquals(0, fm.getFocusedIndex());
4450         assertEquals(0, fm.getFocusedCell().getRow());
4451         assertEquals(test_rt_38892_lastNameCol, fm.getFocusedCell().getTableColumn());
4452         assertEquals(0, fm.getFocusedCell().getColumn());
4453     }
4454 
4455     @Test public void test_rt_38892_removeSelectionFromCellsInRemovedColumn() {
4456         TreeTableView&lt;Person&gt; table = init_test_rt_38892();
4457 
4458         TreeTableView.TreeTableViewSelectionModel sm = table.getSelectionModel();
4459         sm.select(0, test_rt_38892_firstNameCol);
4460         sm.select(1, test_rt_38892_lastNameCol);    // this should go
4461         sm.select(2, test_rt_38892_firstNameCol);
4462         sm.select(3, test_rt_38892_lastNameCol);    // so should this
4463         sm.select(4, test_rt_38892_firstNameCol);
4464 
4465         assertEquals(5, sm.getSelectedCells().size());
4466 
4467         table.getColumns().remove(1);
4468 
4469         assertEquals(3, sm.getSelectedCells().size());
4470         assertTrue(sm.isSelected(0, test_rt_38892_firstNameCol));
4471         assertFalse(sm.isSelected(1, test_rt_38892_lastNameCol));
4472         assertTrue(sm.isSelected(2, test_rt_38892_firstNameCol));
4473         assertFalse(sm.isSelected(3, test_rt_38892_lastNameCol));
4474         assertTrue(sm.isSelected(4, test_rt_38892_firstNameCol));
4475     }
4476 
4477     @Test public void test_rt_38787_remove_b() {
4478         // Remove &#39;b&#39;, selection moves to &#39;a&#39;
4479         test_rt_38787(&quot;a&quot;, 0, 1);
4480     }
4481 
4482     @Test public void test_rt_38787_remove_b_c() {
4483         // Remove &#39;b&#39; and &#39;c&#39;, selection moves to &#39;a&#39;
4484         test_rt_38787(&quot;a&quot;, 0, 1, 2);
4485     }
4486 
4487     @Test public void test_rt_38787_remove_c_d() {
4488         // Remove &#39;c&#39; and &#39;d&#39;, selection moves to &#39;b&#39;
4489         test_rt_38787(&quot;b&quot;, 1, 2, 3);
4490     }
4491 
4492     @Test public void test_rt_38787_remove_a() {
4493         // Remove &#39;a&#39;, selection moves to &#39;b&#39;, now in index 0
4494         test_rt_38787(&quot;b&quot;, 0, 0);
4495     }
4496 
4497     private void test_rt_38787(String expectedItem, int expectedIndex, int... indicesToRemove) {
4498         TreeItem&lt;String&gt; a, b, c, d;
4499         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4500         root.setExpanded(true);
4501         root.getChildren().addAll(
4502                 a = new TreeItem&lt;String&gt;(&quot;a&quot;),
4503                 b = new TreeItem&lt;String&gt;(&quot;b&quot;),
4504                 c = new TreeItem&lt;String&gt;(&quot;c&quot;),
4505                 d = new TreeItem&lt;String&gt;(&quot;d&quot;)
4506         );
4507 
4508         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
4509         stringTreeTableView.setShowRoot(false);
4510 
4511         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4512         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4513         stringTreeTableView.getColumns().add(column);
4514 
4515         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = stringTreeTableView.getSelectionModel();
4516         sm.select(b);
4517 
4518         // test pre-conditions
4519         assertEquals(1, sm.getSelectedIndex());
4520         assertEquals(1, (int)sm.getSelectedIndices().get(0));
4521         assertEquals(b, sm.getSelectedItem());
4522         assertEquals(b, sm.getSelectedItems().get(0));
4523         assertFalse(sm.isSelected(0));
4524         assertTrue(sm.isSelected(1));
4525         assertFalse(sm.isSelected(2));
4526 
4527         // removing items
4528         List&lt;TreeItem&lt;String&gt;&gt; itemsToRemove = new ArrayList&lt;&gt;(indicesToRemove.length);
4529         for (int index : indicesToRemove) {
4530             itemsToRemove.add(root.getChildren().get(index));
4531         }
4532         root.getChildren().removeAll(itemsToRemove);
4533 
4534         // testing against expectations
4535         assertEquals(expectedIndex, sm.getSelectedIndex());
4536         assertEquals(expectedIndex, (int)sm.getSelectedIndices().get(0));
4537         assertEquals(expectedItem, sm.getSelectedItem().getValue());
4538         assertEquals(expectedItem, sm.getSelectedItems().get(0).getValue());
4539     }
4540 
4541     private int rt_38341_indices_count = 0;
4542     private int rt_38341_items_count = 0;
4543     @Test public void test_rt_38341() {
4544         Callback&lt;Integer, TreeItem&lt;String&gt;&gt; callback = number -&gt; {
4545             final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root &quot; + number);
4546             final TreeItem&lt;String&gt; child = new TreeItem&lt;&gt;(&quot;Child &quot; + number);
4547 
4548             root.getChildren().add(child);
4549             return root;
4550         };
4551 
4552         final TreeItem&lt;String&gt; root = new TreeItem&lt;String&gt;();
4553         root.setExpanded(true);
4554         root.getChildren().addAll(callback.call(1), callback.call(2));
4555 
4556         final TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;&gt;(root);
4557         treeTableView.setShowRoot(false);
4558 
4559         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4560         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4561         treeTableView.getColumns().add(column);
4562 
4563         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = treeTableView.getSelectionModel();
4564         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;) c -&gt; rt_38341_indices_count++);
4565         sm.getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) c -&gt; rt_38341_items_count++);
4566 
4567         assertEquals(0, rt_38341_indices_count);
4568         assertEquals(0, rt_38341_items_count);
4569 
4570         // expand the first child of root, and select it (note: root isn&#39;t visible)
4571         root.getChildren().get(0).setExpanded(true);
4572         sm.select(1);
4573         assertEquals(1, sm.getSelectedIndex());
4574         assertEquals(1, sm.getSelectedIndices().size());
4575         assertEquals(1, (int)sm.getSelectedIndices().get(0));
4576         assertEquals(1, sm.getSelectedItems().size());
4577         assertEquals(&quot;Child 1&quot;, sm.getSelectedItem().getValue());
4578         assertEquals(&quot;Child 1&quot;, sm.getSelectedItems().get(0).getValue());
4579 
4580         assertEquals(1, rt_38341_indices_count);
4581         assertEquals(1, rt_38341_items_count);
4582 
4583         // now delete it
4584         root.getChildren().get(0).getChildren().remove(0);
4585 
4586         // selection should move to the childs parent in index 0
4587         assertEquals(0, sm.getSelectedIndex());
4588         assertEquals(1, sm.getSelectedIndices().size());
4589         assertEquals(0, (int)sm.getSelectedIndices().get(0));
4590         assertEquals(1, sm.getSelectedItems().size());
4591         assertEquals(&quot;Root 1&quot;, sm.getSelectedItem().getValue());
4592         assertEquals(&quot;Root 1&quot;, sm.getSelectedItems().get(0).getValue());
4593 
4594         // we also expect there to be an event in the selection model for
4595         // selected indices and selected items
4596         assertEquals(2, rt_38341_indices_count);
4597         assertEquals(2, rt_38341_items_count);
4598     }
4599 
4600     private int rt_38943_index_count = 0;
4601     private int rt_38943_item_count = 0;
4602     @Test public void test_rt_38943() {
4603         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4604         root.setExpanded(true);
4605         root.getChildren().addAll(
4606             new TreeItem&lt;&gt;(&quot;a&quot;),
4607             new TreeItem&lt;&gt;(&quot;b&quot;),
4608             new TreeItem&lt;&gt;(&quot;c&quot;),
4609             new TreeItem&lt;&gt;(&quot;d&quot;)
4610         );
4611 
4612         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
4613         stringTreeTableView.setShowRoot(false);
4614 
4615         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4616         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4617         stringTreeTableView.getColumns().add(column);
4618 
4619         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = stringTreeTableView.getSelectionModel();
4620 
4621         sm.selectedIndexProperty().addListener((observable, oldValue, newValue) -&gt; rt_38943_index_count++);
4622         sm.selectedItemProperty().addListener((observable, oldValue, newValue) -&gt; rt_38943_item_count++);
4623 
4624         assertEquals(-1, sm.getSelectedIndex());
4625         assertNull(sm.getSelectedItem());
4626         assertEquals(0, rt_38943_index_count);
4627         assertEquals(0, rt_38943_item_count);
4628 
4629         sm.select(0);
4630         assertEquals(0, sm.getSelectedIndex());
4631         assertEquals(&quot;a&quot;, sm.getSelectedItem().getValue());
4632         assertEquals(1, rt_38943_index_count);
4633         assertEquals(1, rt_38943_item_count);
4634 
4635         sm.clearSelection(0);
4636         assertEquals(-1, sm.getSelectedIndex());
4637         assertNull(sm.getSelectedItem());
4638         assertEquals(2, rt_38943_index_count);
4639         assertEquals(2, rt_38943_item_count);
4640     }
4641 
4642     @Test public void test_rt_38884() {
4643         final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4644         final TreeItem&lt;String&gt; foo = new TreeItem&lt;&gt;(&quot;foo&quot;);
4645 
4646         TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;(root);
4647         treeView.setShowRoot(false);
4648         root.setExpanded(true);
4649 
4650         treeView.getSelectionModel().getSelectedItems().addListener((ListChangeListener.Change&lt;? extends TreeItem&lt;String&gt;&gt; c) -&gt; {
4651             while (c.next()) {
4652                 if (c.wasRemoved()) {
4653                     assertTrue(c.getRemovedSize() &gt; 0);
4654 
4655                     List&lt;? extends TreeItem&lt;String&gt;&gt; removed = c.getRemoved();
4656                     TreeItem&lt;String&gt; removedItem = null;
4657                     try {
4658                         removedItem = removed.get(0);
4659                     } catch (Exception e) {
4660                         fail();
4661                     }
4662 
4663                     assertEquals(foo, removedItem);
4664                 }
4665             }
4666         });
4667 
4668         root.getChildren().add(foo);
4669         treeView.getSelectionModel().select(0);
4670         root.getChildren().clear();
4671     }
4672 
4673     private int rt_37360_add_count = 0;
4674     private int rt_37360_remove_count = 0;
4675     @Test public void test_rt_37360() {
4676         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4677         root.setExpanded(true);
4678         root.getChildren().addAll(
4679                 new TreeItem&lt;&gt;(&quot;a&quot;),
4680                 new TreeItem&lt;&gt;(&quot;b&quot;)
4681         );
4682 
4683         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
4684         stringTreeTableView.setShowRoot(false);
4685 
4686         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4687         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4688         stringTreeTableView.getColumns().add(column);
4689 
4690         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = stringTreeTableView.getSelectionModel();
4691         sm.setSelectionMode(SelectionMode.MULTIPLE);
4692         sm.getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) c -&gt; {
4693             while (c.next()) {
4694                 if (c.wasAdded()) {
4695                     rt_37360_add_count += c.getAddedSize();
4696                 }
4697                 if (c.wasRemoved()) {
4698                     rt_37360_remove_count += c.getRemovedSize();
4699                 }
4700             }
4701         });
4702 
4703         assertEquals(0, sm.getSelectedItems().size());
4704         assertEquals(0, rt_37360_add_count);
4705         assertEquals(0, rt_37360_remove_count);
4706 
4707         sm.select(0);
4708         assertEquals(1, sm.getSelectedItems().size());
4709         assertEquals(1, rt_37360_add_count);
4710         assertEquals(0, rt_37360_remove_count);
4711 
4712         sm.select(1);
4713         assertEquals(2, sm.getSelectedItems().size());
4714         assertEquals(2, rt_37360_add_count);
4715         assertEquals(0, rt_37360_remove_count);
4716 
4717         sm.clearAndSelect(1);
4718         assertEquals(1, sm.getSelectedItems().size());
4719         assertEquals(2, rt_37360_add_count);
4720         assertEquals(1, rt_37360_remove_count);
4721     }
4722 
4723     private int rt_37366_count = 0;
4724     @Test public void test_rt_37366() {
4725         final TreeItem&lt;String&gt; treeItem2 = new TreeItem&lt;&gt;(&quot;Item 2&quot;);
4726         treeItem2.getChildren().addAll(new TreeItem&lt;&gt;(&quot;Item 21&quot;), new TreeItem&lt;&gt;(&quot;Item 22&quot;));
4727 
4728         final TreeItem&lt;String&gt; root1 = new TreeItem&lt;&gt;(&quot;Root Node 1&quot;);
4729         TreeItem&lt;String&gt; treeItem1 = new TreeItem&lt;&gt;(&quot;Item 1&quot;);
4730         root1.getChildren().addAll(treeItem1, treeItem2, new TreeItem&lt;&gt;(&quot;Item 3&quot;));
4731         root1.setExpanded(true);
4732 
4733         final TreeItem&lt;String&gt; root2 = new TreeItem&lt;&gt;(&quot;Root Node 2&quot;);
4734 
4735         final TreeItem&lt;String&gt; hiddenRoot = new TreeItem&lt;&gt;(&quot;Hidden Root Node&quot;);
4736         hiddenRoot.getChildren().add(root1);
4737         hiddenRoot.getChildren().add(root2);
4738 
4739         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;(hiddenRoot);
4740         treeView.setShowRoot(false);
4741 
4742         AtomicInteger step = new AtomicInteger();
4743         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = treeView.getSelectionModel();
4744         sm.setSelectionMode(SelectionMode.MULTIPLE);
4745         sm.getSelectedItems().addListener((ListChangeListener.Change&lt;? extends TreeItem&lt;String&gt;&gt; c) -&gt; {
4746             switch (step.get()) {
4747                 case 0: {
4748                     // we expect treeItem1 to be the only item added
4749                     while (c.next()) {
4750                         assertFalse(c.wasRemoved());
4751                         assertTrue(c.wasAdded());
4752                         assertEquals(1, c.getAddedSize());
4753                         assertTrue(c.getAddedSubList().contains(treeItem1));
4754                     }
4755                     break;
4756                 }
4757                 case 1: {
4758                     // we expect treeItem2 to be the only item added
4759                     while (c.next()) {
4760                         assertFalse(c.wasRemoved());
4761                         assertTrue(c.wasAdded());
4762                         assertEquals(1, c.getAddedSize());
4763                         assertTrue(c.getAddedSubList().contains(treeItem2));
4764                     }
4765                     break;
4766                 }
4767                 case 2: {
4768                     // we expect treeItem1 and treeItem2 to be removed in one separate event,
4769                     // and then we expect a separate event for root1 to be added. Therefore,
4770                     // once the remove event is received, we will increment the step to test for
4771                     // the addition
4772                     boolean wasRemoved = false;
4773                     while (c.next()) {
4774                         if (c.wasAdded()) {
4775                             fail(&quot;no addition expected yet&quot;);
4776                         }
4777                         if (c.wasRemoved()) {
4778                             assertTrue(c.getRemoved().containsAll(FXCollections.observableArrayList(treeItem1, treeItem2)));
4779                             wasRemoved = true;
4780                         }
4781                     }
4782                     if (!wasRemoved) {
4783                         fail(&quot;Expected a remove operation&quot;);
4784                     }
4785                     step.incrementAndGet();
4786                     break;
4787                 }
4788                 case 3: {
4789                     boolean wasAdded = false;
4790                     while (c.next()) {
4791                         if (c.wasAdded()) {
4792                             assertEquals(1, c.getAddedSize());
4793                             assertTrue(c.getAddedSubList().contains(root1));
4794                             wasAdded = true;
4795                         }
4796                         if (c.wasRemoved()) {
4797                             fail(&quot;no removal expected now&quot;);
4798                         }
4799                     }
4800                     if (!wasAdded) {
4801                         fail(&quot;Expected an add operation&quot;);
4802                     }
4803                     break;
4804                 }
4805             }
4806             rt_37366_count++;
4807         });
4808 
4809         assertEquals(0, rt_37366_count);
4810 
4811         step.set(0);
4812         sm.select(1); // select &quot;Item 1&quot;
4813         assertEquals(1, rt_37366_count);
4814         assertFalse(sm.isSelected(0));
4815         assertTrue(sm.isSelected(1));
4816         assertFalse(sm.isSelected(2));
4817 
4818         step.set(1);
4819         sm.select(2); // select &quot;Item 2&quot;
4820         assertEquals(2, rt_37366_count);
4821         assertFalse(sm.isSelected(0));
4822         assertTrue(sm.isSelected(1));
4823         assertTrue(sm.isSelected(2));
4824 
4825         step.set(2);
4826         root1.setExpanded(false); // collapse &quot;Root Node 1&quot; and deselect the two children, moving selection up to &quot;Root Node 1&quot;
4827         assertEquals(4, rt_37366_count);
4828         assertTrue(sm.isSelected(0));
4829         assertFalse(sm.isSelected(1));
4830         assertFalse(sm.isSelected(2));
4831     }
4832 
4833     @Test public void test_rt_38491() {
4834         TreeItem&lt;String&gt; a;
4835         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4836         root.setExpanded(true);
4837         root.getChildren().addAll(
4838                 a = new TreeItem&lt;&gt;(&quot;a&quot;),
4839                 new TreeItem&lt;&gt;(&quot;b&quot;)
4840         );
4841 
4842         TreeTableView&lt;String&gt; stringTreeView = new TreeTableView&lt;&gt;(root);
4843         stringTreeView.setShowRoot(false);
4844 
4845         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4846         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4847         stringTreeView.getColumns().add(column);
4848 
4849         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeView.getSelectionModel();
4850         sm.setSelectionMode(SelectionMode.MULTIPLE);
4851 
4852         TreeTableViewFocusModel&lt;String&gt; fm = stringTreeView.getFocusModel();
4853 
4854         StageLoader sl = new StageLoader(stringTreeView);
4855 
4856         // test pre-conditions
4857         assertTrue(sm.isEmpty());
4858         assertEquals(a, fm.getFocusedItem());
4859         assertEquals(0, fm.getFocusedIndex());
4860 
4861         // click on row 0
4862 //        VirtualFlowTestUtils.clickOnRow(stringTreeView, 0);
4863         sm.select(0, column);
4864         assertTrue(sm.isSelected(0));
4865         assertEquals(a, sm.getSelectedItem());
4866         assertTrue(fm.isFocused(0));
4867         assertEquals(a, fm.getFocusedItem());
4868         assertEquals(0, fm.getFocusedIndex());
4869         assertEquals(0, fm.getFocusedCell().getRow());
4870         assertEquals(column, fm.getFocusedCell().getTableColumn());
4871 
4872         TreeTablePosition&lt;String, ?&gt; anchor = TreeTableCellBehavior.getAnchor(stringTreeView, null);
4873         assertNotNull(anchor);
4874         assertTrue(TreeTableCellBehavior.hasNonDefaultAnchor(stringTreeView));
4875         assertEquals(0, anchor.getRow());
4876 
4877         // now add a new item at row 0. This has the effect of pushing down
4878         // the selected item into row 1.
4879         root.getChildren().add(0, new TreeItem(&quot;z&quot;));
4880 
4881         // The first bug was that selection and focus were not moving down to
4882         // be on row 1, so we test that now
4883         assertFalse(sm.isSelected(0));
4884         assertFalse(fm.isFocused(0));
4885         assertTrue(sm.isSelected(1));
4886         assertEquals(a, sm.getSelectedItem());
4887         assertTrue(fm.isFocused(1));
4888         assertEquals(a, fm.getFocusedItem());
4889         assertEquals(1, fm.getFocusedIndex());
4890         assertEquals(1, fm.getFocusedCell().getRow());
4891         assertEquals(column, fm.getFocusedCell().getTableColumn());
4892 
4893         // The second bug was that the anchor was not being pushed down as well
4894         // (when it should).
4895         anchor = TreeTableCellBehavior.getAnchor(stringTreeView, null);
4896         assertNotNull(anchor);
4897         assertTrue(TreeTableCellBehavior.hasNonDefaultAnchor(stringTreeView));
4898         assertEquals(1, anchor.getRow());
4899         assertEquals(column, anchor.getTableColumn());
4900 
4901         sl.dispose();
4902     }
4903 
4904     private final ObservableList&lt;TreeItem&lt;String&gt;&gt; rt_39256_list = FXCollections.observableArrayList();
4905     @Test public void test_rt_39256() {
4906         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4907         root.setExpanded(true);
4908         root.getChildren().addAll(
4909                 new TreeItem&lt;&gt;(&quot;a&quot;),
4910                 new TreeItem&lt;&gt;(&quot;b&quot;),
4911                 new TreeItem&lt;&gt;(&quot;c&quot;),
4912                 new TreeItem&lt;&gt;(&quot;d&quot;)
4913         );
4914 
4915         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
4916         stringTreeTableView.setShowRoot(false);
4917 
4918         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4919         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4920         stringTreeTableView.getColumns().add(column);
4921 
4922         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = stringTreeTableView.getSelectionModel();
4923         sm.setSelectionMode(SelectionMode.MULTIPLE);
4924 
4925 //        rt_39256_list.addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) change -&gt; {
4926 //            while (change.next()) {
4927 //                System.err.println(&quot;number of selected persons (in bound list): &quot; + change.getList().size());
4928 //            }
4929 //        });
4930 
4931         Bindings.bindContent(rt_39256_list, sm.getSelectedItems());
4932 
4933         assertEquals(0, sm.getSelectedItems().size());
4934         assertEquals(0, rt_39256_list.size());
4935 
4936         sm.selectAll();
4937         assertEquals(4, sm.getSelectedItems().size());
4938         assertEquals(4, rt_39256_list.size());
4939 
4940         sm.selectAll();
4941         assertEquals(4, sm.getSelectedItems().size());
4942         assertEquals(4, rt_39256_list.size());
4943 
4944         sm.selectAll();
4945         assertEquals(4, sm.getSelectedItems().size());
4946         assertEquals(4, rt_39256_list.size());
4947     }
4948 
4949     private final ObservableList&lt;TreeItem&lt;String&gt;&gt; rt_39482_list = FXCollections.observableArrayList();
4950     @Test public void test_rt_39482() {
4951         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4952         root.setExpanded(true);
4953         root.getChildren().addAll(
4954                 new TreeItem&lt;&gt;(&quot;a&quot;),
4955                 new TreeItem&lt;&gt;(&quot;b&quot;),
4956                 new TreeItem&lt;&gt;(&quot;c&quot;),
4957                 new TreeItem&lt;&gt;(&quot;d&quot;)
4958         );
4959 
4960         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
4961         stringTreeTableView.setShowRoot(false);
4962 
4963         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4964         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4965         stringTreeTableView.getColumns().add(column);
4966 
4967         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
4968         sm.setSelectionMode(SelectionMode.MULTIPLE);
4969 
4970 //        rt_39256_list.addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) change -&gt; {
4971 //            while (change.next()) {
4972 //                System.err.println(&quot;number of selected persons (in bound list): &quot; + change.getList().size());
4973 //            }
4974 //        });
4975 
4976         Bindings.bindContent(rt_39482_list, sm.getSelectedItems());
4977 
4978         assertEquals(0, sm.getSelectedItems().size());
4979         assertEquals(0, rt_39482_list.size());
4980 
4981         test_rt_39482_selectRow(&quot;a&quot;, sm, 0, column);
4982         test_rt_39482_selectRow(&quot;b&quot;, sm, 1, column);
4983         test_rt_39482_selectRow(&quot;c&quot;, sm, 2, column);
4984         test_rt_39482_selectRow(&quot;d&quot;, sm, 3, column);
4985     }
4986 
4987     private void test_rt_39482_selectRow(String expectedString,
4988                                          TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm,
4989                                          int rowToSelect,
4990                                          TreeTableColumn&lt;String,String&gt; columnToSelect) {
4991         System.out.println(&quot;\nSelect row &quot; + rowToSelect);
4992         sm.selectAll();
4993         assertEquals(4, sm.getSelectedCells().size());
4994         assertEquals(4, sm.getSelectedIndices().size());
4995         assertEquals(4, sm.getSelectedItems().size());
4996         assertEquals(4, rt_39482_list.size());
4997 
4998         sm.clearAndSelect(rowToSelect, columnToSelect);
4999         assertEquals(1, sm.getSelectedCells().size());
5000         assertEquals(1, sm.getSelectedIndices().size());
5001         assertEquals(1, sm.getSelectedItems().size());
5002         assertEquals(expectedString, sm.getSelectedItem().getValue());
5003         assertEquals(expectedString, rt_39482_list.get(0).getValue());
5004         assertEquals(1, rt_39482_list.size());
5005     }
5006 
5007     @Test public void test_rt_39559_useSM_selectAll() {
5008         test_rt_39559(true);
5009     }
5010 
5011     @Test public void test_rt_39559_useKeyboard_selectAll() {
5012         test_rt_39559(false);
5013     }
5014 
5015     private void test_rt_39559(boolean useSMSelectAll) {
5016         TreeItem&lt;String&gt; a, b;
5017         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5018         root.setExpanded(true);
5019         root.getChildren().addAll(
5020                 a = new TreeItem&lt;&gt;(&quot;a&quot;),
5021                 b = new TreeItem&lt;&gt;(&quot;b&quot;),
5022                 new TreeItem&lt;&gt;(&quot;c&quot;),
5023                 new TreeItem&lt;&gt;(&quot;d&quot;)
5024         );
5025 
5026         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5027         stringTreeTableView.setShowRoot(false);
5028 
5029         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5030         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5031         stringTreeTableView.getColumns().add(column);
5032 
5033         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5034         sm.setSelectionMode(SelectionMode.MULTIPLE);
5035 
5036         StageLoader sl = new StageLoader(stringTreeTableView);
5037         KeyEventFirer keyboard = new KeyEventFirer(stringTreeTableView);
5038 
5039         assertEquals(0, sm.getSelectedItems().size());
5040 
5041         sm.clearAndSelect(0);
5042 
5043         if (useSMSelectAll) {
5044             sm.selectAll();
5045         } else {
5046             keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
5047         }
5048 
5049         assertEquals(4, sm.getSelectedItems().size());
5050         assertEquals(0, ((TreeTablePosition) TreeTableCellBehavior.getAnchor(stringTreeTableView, null)).getRow());
5051 
5052         keyboard.doKeyPress(KeyCode.DOWN, KeyModifier.SHIFT);
5053 
5054         assertEquals(0, ((TreeTablePosition) TreeTableCellBehavior.getAnchor(stringTreeTableView, null)).getRow());
5055         assertEquals(2, sm.getSelectedItems().size());
5056         assertEquals(a, sm.getSelectedItems().get(0));
5057         assertEquals(b, sm.getSelectedItems().get(1));
5058 
5059         sl.dispose();
5060     }
5061 
5062     @Test public void test_rt_16068_firstElement_selectAndRemoveSameRow() {
5063         // select and then remove the &#39;a&#39; item, selection and focus should both
5064         // stay at the first row, now &#39;b&#39;
5065         test_rt_16068(0, 0, 0);
5066     }
5067 
5068     @Test public void test_rt_16068_firstElement_selectRowAndRemoveLaterSibling() {
5069         // select row &#39;a&#39;, and remove row &#39;c&#39;, selection and focus should not change
5070         test_rt_16068(0, 2, 0);
5071     }
5072 
5073     @Test public void test_rt_16068_middleElement_selectAndRemoveSameRow() {
5074         // select and then remove the &#39;b&#39; item, selection and focus should both
5075         // move up one row to the &#39;a&#39; item
5076         test_rt_16068(1, 1, 0);
5077     }
5078 
5079     @Test public void test_rt_16068_middleElement_selectRowAndRemoveLaterSibling() {
5080         // select row &#39;b&#39;, and remove row &#39;c&#39;, selection and focus should not change
5081         test_rt_16068(1, 2, 1);
5082     }
5083 
5084     @Test public void test_rt_16068_middleElement_selectRowAndRemoveEarlierSibling() {
5085         // select row &#39;b&#39;, and remove row &#39;a&#39;, selection and focus should move up
5086         // one row, remaining on &#39;b&#39;
5087         test_rt_16068(1, 0, 0);
5088     }
5089 
5090     @Test public void test_rt_16068_lastElement_selectAndRemoveSameRow() {
5091         // select and then remove the &#39;d&#39; item, selection and focus should both
5092         // move up one row to the &#39;c&#39; item
5093         test_rt_16068(3, 3, 2);
5094     }
5095 
5096     @Test public void test_rt_16068_lastElement_selectRowAndRemoveEarlierSibling() {
5097         // select row &#39;d&#39;, and remove row &#39;a&#39;, selection and focus should move up
5098         // one row, remaining on &#39;d&#39;
5099         test_rt_16068(3, 0, 2);
5100     }
5101 
5102     private void test_rt_16068(int indexToSelect, int indexToRemove, int expectedIndex) {
5103         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5104         root.setExpanded(true);
5105         root.getChildren().addAll(
5106                 new TreeItem&lt;&gt;(&quot;a&quot;), // 0
5107                 new TreeItem&lt;&gt;(&quot;b&quot;), // 1
5108                 new TreeItem&lt;&gt;(&quot;c&quot;), // 2
5109                 new TreeItem&lt;&gt;(&quot;d&quot;)  // 3
5110         );
5111 
5112         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5113         stringTreeTableView.setShowRoot(false);
5114 
5115         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5116         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5117         stringTreeTableView.getColumns().add(column);
5118 
5119         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5120         FocusModel&lt;TreeItem&lt;String&gt;&gt; fm = stringTreeTableView.getFocusModel();
5121 
5122         sm.select(indexToSelect);
5123         assertEquals(indexToSelect, sm.getSelectedIndex());
5124         assertEquals(root.getChildren().get(indexToSelect).getValue(), sm.getSelectedItem().getValue());
5125         assertEquals(indexToSelect, fm.getFocusedIndex());
5126         assertEquals(root.getChildren().get(indexToSelect).getValue(), fm.getFocusedItem().getValue());
5127 
5128         root.getChildren().remove(indexToRemove);
5129         assertEquals(expectedIndex, sm.getSelectedIndex());
5130         assertEquals(root.getChildren().get(expectedIndex).getValue(), sm.getSelectedItem().getValue());
5131         assertEquals(debug(), expectedIndex, fm.getFocusedIndex());
5132         assertEquals(root.getChildren().get(expectedIndex).getValue(), fm.getFocusedItem().getValue());
5133     }
5134 
5135     @Test public void test_rt_39675() {
5136         TreeItem&lt;String&gt; b;
5137         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5138         root.setExpanded(true);
5139         root.getChildren().addAll(
5140                 new TreeItem&lt;&gt;(&quot;a&quot;),
5141                 b = new TreeItem&lt;&gt;(&quot;b&quot;),
5142                 new TreeItem&lt;&gt;(&quot;c&quot;),
5143                 new TreeItem&lt;&gt;(&quot;d&quot;)
5144         );
5145 
5146         b.setExpanded(true);
5147         b.getChildren().addAll(
5148                 new TreeItem&lt;&gt;(&quot;b1&quot;),
5149                 new TreeItem&lt;&gt;(&quot;b2&quot;),
5150                 new TreeItem&lt;&gt;(&quot;b3&quot;),
5151                 new TreeItem&lt;&gt;(&quot;b4&quot;)
5152         );
5153 
5154         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5155 
5156         TreeTableColumn&lt;String,String&gt; column0 = new TreeTableColumn&lt;&gt;(&quot;Column1&quot;);
5157         column0.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5158 
5159         TreeTableColumn&lt;String,String&gt; column1 = new TreeTableColumn&lt;&gt;(&quot;Column2&quot;);
5160         column1.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5161 
5162         TreeTableColumn&lt;String,String&gt; column2 = new TreeTableColumn&lt;&gt;(&quot;Column3&quot;);
5163         column2.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5164 
5165         stringTreeTableView.getColumns().addAll(column0, column1, column2);
5166 
5167         sm = stringTreeTableView.getSelectionModel();
5168         sm.setSelectionMode(SelectionMode.SINGLE);
5169         sm.setCellSelectionEnabled(true);
5170 
5171         StageLoader sl = new StageLoader(stringTreeTableView);
5172 
5173         assertEquals(0, sm.getSelectedItems().size());
5174 
5175         sm.clearAndSelect(4, column0);  // select &#39;b2&#39; in row 4, column 0
5176         assertTrue(sm.isSelected(4, column0));
5177         assertEquals(1, sm.getSelectedCells().size());
5178         assertEquals(&quot;b2&quot;, ((TreeItem)sm.getSelectedItem()).getValue());
5179 
5180         // collapse the &#39;b&#39; tree item, selection and focus should go to
5181         // the &#39;b&#39; tree item in row 2, column 0
5182         b.setExpanded(false);
5183         assertTrue(sm.isSelected(2, column0));
5184         assertEquals(1, sm.getSelectedCells().size());
5185         assertEquals(&quot;b&quot;, ((TreeItem)sm.getSelectedItem()).getValue());
5186 
5187         sl.dispose();
5188     }
5189 
5190 
5191     private ObservableList&lt;String&gt; test_rt_39661_setup() {
5192         ObservableList&lt;String&gt;  rawItems = FXCollections.observableArrayList(
5193                 &quot;9-item&quot;, &quot;8-item&quot;, &quot;7-item&quot;, &quot;6-item&quot;,
5194                 &quot;5-item&quot;, &quot;4-item&quot;, &quot;3-item&quot;, &quot;2-item&quot;, &quot;1-item&quot;);
5195         root = createSubTree(&quot;root&quot;, rawItems);
5196         root.setExpanded(true);
5197         treeTableView = new TreeTableView(root);
5198         return rawItems;
5199     }
5200 
5201     private TreeItem createSubTree(Object item, ObservableList&lt;String&gt; rawItems) {
5202         TreeItem child = new TreeItem(item);
5203         child.getChildren().setAll(rawItems.stream()
5204                 .map(rawItem -&gt; new TreeItem(rawItem))
5205                 .collect(Collectors.toList()));
5206         return child;
5207     }
5208 
5209     @Test public void test_rt_39661_rowLessThanExpandedItemCount() {
5210         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5211         TreeItem child = createSubTree(&quot;child&quot;, rawItems);
5212         TreeItem grandChild = (TreeItem) child.getChildren().get(rawItems.size() - 1);
5213         root.getChildren().add(child);
5214         assertTrue(&quot;row of item must be less than expandedItemCount, but was: &quot; + treeTableView.getRow(grandChild),
5215                 treeTableView.getRow(grandChild) &lt; treeTableView.getExpandedItemCount());
5216     }
5217 
5218     @Test public void test_rt_39661_rowOfGrandChildParentCollapsedUpdatedOnInsertAbove() {
5219         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5220         int grandIndex = 2;
5221         int childIndex = 3;
5222 
5223         TreeItem child = createSubTree(&quot;addedChild2&quot;, rawItems);
5224         TreeItem grandChild = (TreeItem) child.getChildren().get(grandIndex);
5225         root.getChildren().add(childIndex, child);
5226 
5227         int rowOfGrand = treeTableView.getRow(grandChild);
5228         root.getChildren().add(childIndex - 1, createSubTree(&quot;other&quot;, rawItems));
5229 
5230         assertEquals(-1, treeTableView.getRow(grandChild));
5231     }
5232 
5233     @Test public void test_rt_39661_rowOfGrandChildParentCollapsedUpdatedOnInsertAboveWithoutAccess() {
5234         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5235         int grandIndex = 2;
5236         int childIndex = 3;
5237 
5238         TreeItem child = createSubTree(&quot;addedChild2&quot;, rawItems);
5239         TreeItem grandChild = (TreeItem) child.getChildren().get(grandIndex);
5240         root.getChildren().add(childIndex, child);
5241 
5242         int rowOfGrand = 7; //treeTableView.getRow(grandChild);
5243         root.getChildren().add(childIndex, createSubTree(&quot;other&quot;, rawItems));
5244 
5245         assertEquals(-1, treeTableView.getRow(grandChild));
5246     }
5247 
5248     @Test public void test_rt_39661_rowOfGrandChildParentExpandedUpdatedOnInsertAbove() {
5249         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5250         int grandIndex = 2;
5251         int childIndex = 3;
5252         TreeItem child = createSubTree(&quot;addedChild2&quot;, rawItems);
5253         TreeItem grandChild = (TreeItem) child.getChildren().get(grandIndex);
5254         child.setExpanded(true);
5255         root.getChildren().add(childIndex, child);
5256         int rowOfGrand = treeTableView.getRow(grandChild);
5257         root.getChildren().add(childIndex -1, createSubTree(&quot;other&quot;, rawItems));
5258         assertEquals(rowOfGrand + 1, treeTableView.getRow(grandChild));
5259     }
5260 
5261     /**
5262      * Testing getRow on grandChild: compare collapsed/expanded parent.
5263      */
5264     @Test public void test_rt_39661_rowOfGrandChildDependsOnParentExpansion() {
5265         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5266         int grandIndex = 2;
5267         int childIndex = 3;
5268 
5269         TreeItem collapsedChild = createSubTree(&quot;addedChild&quot;, rawItems);
5270         TreeItem collapsedGrandChild = (TreeItem) collapsedChild.getChildren().get(grandIndex);
5271         root.getChildren().add(childIndex, collapsedChild);
5272 
5273         int collapedGrandIndex = treeTableView.getRow(collapsedGrandChild);
5274         int collapsedRowCount = treeTableView.getExpandedItemCount();
5275 
5276         // start again
5277         test_rt_39661_setup();
5278         assertEquals(collapsedRowCount - 1, treeTableView.getExpandedItemCount());
5279         TreeItem expandedChild = createSubTree(&quot;addedChild2&quot;, rawItems);
5280         TreeItem expandedGrandChild = (TreeItem) expandedChild.getChildren().get(grandIndex);
5281         expandedChild.setExpanded(true);
5282 
5283         root.getChildren().add(childIndex, expandedChild);
5284         assertNotSame(&quot;getRow must depend on expansionState &quot; + collapedGrandIndex,
5285                 collapedGrandIndex, treeTableView.getRow(expandedGrandChild));
5286     }
5287 
5288     @Test public void test_rt_39661_rowOfGrandChildInCollapsedChild() {
5289         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5290 
5291         // create a collapsed new child to insert into the root
5292         TreeItem newChild = createSubTree(&quot;added-child&quot;, rawItems);
5293         TreeItem grandChild = (TreeItem) newChild.getChildren().get(2);
5294         root.getChildren().add(6, newChild);
5295 
5296         // query the row of a grand-child
5297         int row = treeTableView.getRow(grandChild);
5298 
5299         // grandChild not visible, row coordinate in tree is not available
5300         assertEquals(&quot;grandChild not visible&quot;, -1, row);
5301 
5302         // the other way round: if we get a row, expect the item at the row be the grandChild
5303         if (row &gt; -1) {
5304             assertEquals(grandChild, treeTableView.getTreeItem(row));
5305         }
5306     }
5307 
5308     @Test public void test_rt_39661_rowOfRootChild() {
5309         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5310         int index = 2;
5311 
5312         TreeItem child = (TreeItem) root.getChildren().get(index);
5313         assertEquals(index + 1, treeTableView.getRow(child));
5314     }
5315 
5316     @Test public void test_rt_39661_expandedItemCount() {
5317         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5318         int initialRowCount = treeTableView.getExpandedItemCount();
5319         assertEquals(root.getChildren().size() + 1, initialRowCount);
5320 
5321         TreeItem collapsedChild = createSubTree(&quot;collapsed-child&quot;, rawItems);
5322         root.getChildren().add(collapsedChild);
5323         assertEquals(initialRowCount + 1, treeTableView.getExpandedItemCount());
5324 
5325         TreeItem expandedChild = createSubTree(&quot;expanded-child&quot;, rawItems);
5326         expandedChild.setExpanded(true);
5327         root.getChildren().add(0, expandedChild);
5328         assertEquals(2 * initialRowCount + 1, treeTableView.getExpandedItemCount());
5329     }
5330 
5331     private int test_rt_39822_count = 0;
5332     @Test public void test_rt_39822() {
5333         // get the current exception handler before replacing with our own,
5334         // as ListListenerHelp intercepts the exception otherwise
5335         final Thread.UncaughtExceptionHandler exceptionHandler = Thread.currentThread().getUncaughtExceptionHandler();
5336         Thread.currentThread().setUncaughtExceptionHandler((t, e) -&gt; {
5337 
5338             if (test_rt_39822_count == 0) {
5339                 test_rt_39822_count++;
5340                 if (! (e instanceof IllegalStateException)) {
5341                     e.printStackTrace();
5342                     fail(&quot;Expected IllegalStateException, instead got &quot; + e);
5343                 }
5344             } else {
5345                 // don&#39;t care
5346                 test_rt_39822_count++;
5347             }
5348         });
5349 
5350         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
5351         TreeTableColumn&lt;String, String&gt; col1 = new TreeTableColumn&lt;&gt;(&quot;Foo&quot;);
5352         table.getColumns().addAll(col1, col1);  // add column twice
5353 
5354         StageLoader sl = null;
5355         try {
5356             sl = new StageLoader(table);
5357         } finally {
5358             if (sl != null) {
5359                 sl.dispose();
5360             }
5361 
5362             // reset the exception handler
5363             Thread.currentThread().setUncaughtExceptionHandler(exceptionHandler);
5364         }
5365     }
5366 
5367     private int test_rt_39842_count = 0;
5368     @Test public void test_rt_39842_selectLeftDown() {
5369         test_rt_39842(true, false);
5370     }
5371 
5372     @Test public void test_rt_39842_selectLeftUp() {
5373         test_rt_39842(true, true);
5374     }
5375 
5376     @Test public void test_rt_39842_selectRightDown() {
5377         test_rt_39842(false, false);
5378     }
5379 
5380     @Test public void test_rt_39842_selectRightUp() {
5381         test_rt_39842(false, true);
5382     }
5383 
5384     private void test_rt_39842(boolean selectToLeft, boolean selectUpwards) {
5385         test_rt_39842_count = 0;
5386 
5387         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
5388         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
5389 
5390         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
5391         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
5392 
5393         TreeItem root = new TreeItem(&quot;root&quot;);
5394         root.getChildren().setAll(
5395                 new TreeItem(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
5396                 new TreeItem(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
5397                 new TreeItem(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
5398                 new TreeItem(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
5399                 new TreeItem(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
5400         root.setExpanded(true);
5401 
5402         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;(root);
5403         table.setShowRoot(false);
5404         table.getColumns().addAll(firstNameCol, lastNameCol);
5405 
5406         sm = table.getSelectionModel();
5407         sm.setCellSelectionEnabled(true);
5408         sm.setSelectionMode(SelectionMode.MULTIPLE);
5409         sm.getSelectedCells().addListener((ListChangeListener) c -&gt; test_rt_39842_count++);
5410 
5411         StageLoader sl = new StageLoader(table);
5412 
5413         assertEquals(0, test_rt_39842_count);
5414 
5415         if (selectToLeft) {
5416             if (selectUpwards) {
5417                 sm.selectRange(3, lastNameCol, 0, firstNameCol);
5418             } else {
5419                 sm.selectRange(0, lastNameCol, 3, firstNameCol);
5420             }
5421         } else {
5422             if (selectUpwards) {
5423                 sm.selectRange(3, firstNameCol, 0, lastNameCol);
5424             } else {
5425                 sm.selectRange(0, firstNameCol, 3, lastNameCol);
5426             }
5427         }
5428 
5429         // test model state
5430         assertEquals(8, sm.getSelectedCells().size());
5431         assertEquals(1, test_rt_39842_count);
5432 
5433         // test visual state
5434         for (int row = 0; row &lt;= 3; row++) {
5435             for (int column = 0; column &lt;= 1; column++) {
5436                 IndexedCell cell = VirtualFlowTestUtils.getCell(table, row, column);
5437                 assertTrue(cell.isSelected());
5438             }
5439         }
5440 
5441         sl.dispose();
5442     }
5443 
5444     @Test public void test_rt_22599() {
5445         TreeItem&lt;RT22599_DataType&gt; root = new TreeItem&lt;&gt;();
5446         root.getChildren().setAll(
5447                 new TreeItem&lt;&gt;(new RT22599_DataType(1, &quot;row1&quot;)),
5448                 new TreeItem&lt;&gt;(new RT22599_DataType(2, &quot;row2&quot;)),
5449                 new TreeItem&lt;&gt;(new RT22599_DataType(3, &quot;row3&quot;)));
5450         root.setExpanded(true);
5451 
5452         TreeTableColumn&lt;RT22599_DataType, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;Header&quot;);
5453         col.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue().text));
5454 
5455         TreeTableView&lt;RT22599_DataType&gt; table = new TreeTableView&lt;&gt;(root);
5456         table.setShowRoot(false);
5457         table.getColumns().addAll(col);
5458 
5459         StageLoader sl = new StageLoader(table);
5460 
5461         // testing initial state
5462         assertNotNull(table.getSkin());
5463         assertEquals(&quot;row1&quot;, VirtualFlowTestUtils.getCell(table, 0, 0).getText());
5464         assertEquals(&quot;row2&quot;, VirtualFlowTestUtils.getCell(table, 1, 0).getText());
5465         assertEquals(&quot;row3&quot;, VirtualFlowTestUtils.getCell(table, 2, 0).getText());
5466 
5467         // change row 0 (where &quot;row1&quot; currently resides), keeping same id.
5468         // Because &#39;set&#39; is called, the control should update to the new content
5469         // without any user interaction
5470         TreeItem&lt;RT22599_DataType&gt; data;
5471         root.getChildren().set(0, data = new TreeItem&lt;&gt;(new RT22599_DataType(0, &quot;row1a&quot;)));
5472         Toolkit.getToolkit().firePulse();
5473         assertEquals(&quot;row1a&quot;, VirtualFlowTestUtils.getCell(table, 0, 0).getText());
5474 
5475         // change the row 0 (where we currently have &quot;row1a&quot;) value directly.
5476         // Because there is no associated property, this won&#39;t be observed, so
5477         // the control should still show &quot;row1a&quot; rather than &quot;row1b&quot;
5478         data.getValue().text = &quot;row1b&quot;;
5479         Toolkit.getToolkit().firePulse();
5480         assertEquals(&quot;row1a&quot;, VirtualFlowTestUtils.getCell(table, 0, 0).getText());
5481 
5482         // call refresh() to force a refresh of all visible cells
5483         table.refresh();
5484         Toolkit.getToolkit().firePulse();
5485         assertEquals(&quot;row1b&quot;, VirtualFlowTestUtils.getCell(table, 0, 0).getText());
5486 
5487         sl.dispose();
5488     }
5489 
5490     private static class RT22599_DataType {
5491         public int id = 0;
5492         public String text = &quot;&quot;;
5493 
5494         public RT22599_DataType(int id, String text) {
5495             this.id = id;
5496             this.text = text;
5497         }
5498 
5499         @Override public boolean equals(Object obj) {
5500             if (obj == null) return false;
5501             return id == ((RT22599_DataType)obj).id;
5502         }
5503     }
5504 
5505     private int rt_39966_count = 0;
5506     @Test public void test_rt_39966() {
5507         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5508         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;(root);
5509         table.setShowRoot(true);
5510 
5511         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5512         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5513         table.getColumns().add(column);
5514 
5515         StageLoader sl = new StageLoader(table);
5516 
5517         // initially there is no selection
5518         assertTrue(table.getSelectionModel().isEmpty());
5519 
5520         table.getSelectionModel().selectedItemProperty().addListener((value, s1, s2) -&gt; {
5521             if (rt_39966_count == 0) {
5522                 rt_39966_count++;
5523                 assertFalse(table.getSelectionModel().isEmpty());
5524             } else {
5525                 assertTrue(table.getSelectionModel().isEmpty());
5526             }
5527         });
5528 
5529         // our assertion two lines down always succeeds. What fails is our
5530         // assertion above within the listener.
5531         table.getSelectionModel().select(0);
5532         assertFalse(table.getSelectionModel().isEmpty());
5533 
5534         table.setRoot(null);
5535         assertTrue(table.getSelectionModel().isEmpty());
5536 
5537         sl.dispose();
5538     }
5539 
5540     /**
5541      * Bullet 1: selected index must be updated
5542      * Corner case: last selected. Fails for core
5543      */
5544     @Test public void test_rt_40012_selectedAtLastOnDisjointRemoveItemsAbove() {
5545         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5546         root.setExpanded(true);
5547         root.getChildren().addAll(
5548             new TreeItem&lt;&gt;(&quot;0&quot;),
5549             new TreeItem&lt;&gt;(&quot;1&quot;),
5550             new TreeItem&lt;&gt;(&quot;2&quot;),
5551             new TreeItem&lt;&gt;(&quot;3&quot;),
5552             new TreeItem&lt;&gt;(&quot;4&quot;),
5553             new TreeItem&lt;&gt;(&quot;5&quot;)
5554         );
5555 
5556         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5557         stringTreeTableView.setShowRoot(false);
5558         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5559 
5560         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5561         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5562         stringTreeTableView.getColumns().add(column);
5563 
5564         int last = root.getChildren().size() - 1;
5565 
5566         // selecting item &quot;5&quot;
5567         sm.select(last);
5568 
5569         // disjoint remove of 2 elements above the last selected
5570         // Removing &quot;1&quot; and &quot;3&quot;
5571         root.getChildren().removeAll(root.getChildren().get(1), root.getChildren().get(3));
5572 
5573         // selection should move up two places such that it remains on item &quot;5&quot;,
5574         // but in index (last - 2).
5575         int expected = last - 2;
5576         assertEquals(&quot;5&quot;, sm.getSelectedItem().getValue());
5577         assertEquals(&quot;selected index after disjoint removes above&quot;, expected, sm.getSelectedIndex());
5578     }
5579 
5580     /**
5581      * Variant of 1: if selectedIndex is not updated,
5582      * the old index is no longer valid
5583      * for accessing the items.
5584      */
5585     @Test public void test_rt_40012_accessSelectedAtLastOnDisjointRemoveItemsAbove() {
5586         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5587         root.setExpanded(true);
5588         root.getChildren().addAll(
5589                 new TreeItem&lt;&gt;(&quot;0&quot;),
5590                 new TreeItem&lt;&gt;(&quot;1&quot;),
5591                 new TreeItem&lt;&gt;(&quot;2&quot;),
5592                 new TreeItem&lt;&gt;(&quot;3&quot;),
5593                 new TreeItem&lt;&gt;(&quot;4&quot;),
5594                 new TreeItem&lt;&gt;(&quot;5&quot;)
5595         );
5596 
5597         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5598         stringTreeTableView.setShowRoot(false);
5599         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5600 
5601         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5602         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5603         stringTreeTableView.getColumns().add(column);
5604 
5605         int last = root.getChildren().size() - 1;
5606 
5607         // selecting item &quot;5&quot;
5608         sm.select(last);
5609 
5610         // disjoint remove of 2 elements above the last selected
5611         root.getChildren().removeAll(root.getChildren().get(1), root.getChildren().get(3));
5612         int selected = sm.getSelectedIndex();
5613         if (selected &gt; -1) {
5614             root.getChildren().get(selected);
5615         }
5616     }
5617 
5618     /**
5619      * Bullet 2: selectedIndex notification count
5620      *
5621      * Note that we don&#39;t use the corner case of having the last index selected
5622      * (which fails already on updating the index)
5623      */
5624     private int rt_40012_count = 0;
5625     @Test public void test_rt_40012_selectedIndexNotificationOnDisjointRemovesAbove() {
5626         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5627         root.setExpanded(true);
5628         root.getChildren().addAll(
5629                 new TreeItem&lt;&gt;(&quot;0&quot;),
5630                 new TreeItem&lt;&gt;(&quot;1&quot;),
5631                 new TreeItem&lt;&gt;(&quot;2&quot;),
5632                 new TreeItem&lt;&gt;(&quot;3&quot;),
5633                 new TreeItem&lt;&gt;(&quot;4&quot;),
5634                 new TreeItem&lt;&gt;(&quot;5&quot;)
5635         );
5636 
5637         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5638         stringTreeTableView.setShowRoot(false);
5639         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5640 
5641         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5642         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5643         stringTreeTableView.getColumns().add(column);
5644 
5645         int last = root.getChildren().size() - 2;
5646         sm.select(last);
5647         assertEquals(last, sm.getSelectedIndex());
5648 
5649         rt_40012_count = 0;
5650         sm.selectedIndexProperty().addListener(o -&gt; rt_40012_count++);
5651 
5652         // disjoint remove of 2 elements above the last selected
5653         root.getChildren().removeAll(root.getChildren().get(1), root.getChildren().get(3));
5654         assertEquals(&quot;sanity: selectedIndex must be shifted by -2&quot;, last - 2, sm.getSelectedIndex());
5655         assertEquals(&quot;must fire single event on removes above&quot;, 1, rt_40012_count);
5656     }
5657 
5658     /**
5659      * Bullet 3: unchanged selectedItem must not fire change
5660      */
5661     @Test
5662     public void test_rt_40012_selectedItemNotificationOnDisjointRemovesAbove() {
5663         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5664         root.setExpanded(true);
5665         root.getChildren().addAll(
5666                 new TreeItem&lt;&gt;(&quot;0&quot;),
5667                 new TreeItem&lt;&gt;(&quot;1&quot;),
5668                 new TreeItem&lt;&gt;(&quot;2&quot;),
5669                 new TreeItem&lt;&gt;(&quot;3&quot;),
5670                 new TreeItem&lt;&gt;(&quot;4&quot;),
5671                 new TreeItem&lt;&gt;(&quot;5&quot;)
5672         );
5673 
5674         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5675         stringTreeTableView.setShowRoot(false);
5676         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5677 
5678         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5679         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5680         stringTreeTableView.getColumns().add(column);
5681 
5682         int last = root.getChildren().size() - 2;
5683         Object lastItem = root.getChildren().get(last);
5684         sm.select(last);
5685         assertEquals(lastItem, sm.getSelectedItem());
5686 
5687         rt_40012_count = 0;
5688         sm.selectedItemProperty().addListener(o -&gt; rt_40012_count++);
5689 
5690         // disjoint remove of 2 elements above the last selected
5691         root.getChildren().removeAll(root.getChildren().get(1), root.getChildren().get(3));
5692         assertEquals(&quot;sanity: selectedItem unchanged&quot;, lastItem, sm.getSelectedItem());
5693         assertEquals(&quot;must not fire on unchanged selected item&quot;, 0, rt_40012_count);
5694     }
5695 
5696     private int rt_40010_count = 0;
5697     @Test public void test_rt_40010() {
5698         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5699         TreeItem&lt;String&gt; child = new TreeItem&lt;&gt;(&quot;child&quot;);
5700         root.setExpanded(true);
5701         root.getChildren().addAll(child);
5702 
5703         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5704         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5705 
5706         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5707         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5708         stringTreeTableView.getColumns().add(column);
5709 
5710         sm.getSelectedIndices().addListener((ListChangeListener&lt;? super Integer&gt;) l -&gt; rt_40010_count++);
5711         sm.getSelectedItems().addListener((ListChangeListener&lt;? super TreeItem&lt;String&gt;&gt;) l -&gt; rt_40010_count++);
5712 
5713         assertEquals(0, rt_40010_count);
5714 
5715         sm.select(1);
5716         assertEquals(1, sm.getSelectedIndex());
5717         assertEquals(child, sm.getSelectedItem());
5718         assertEquals(2, rt_40010_count);
5719 
5720         root.getChildren().remove(child);
5721         assertEquals(0, sm.getSelectedIndex());
5722         assertEquals(root, sm.getSelectedItem());
5723         assertEquals(4, rt_40010_count);
5724     }
5725 
5726     /**
5727      * ClearAndSelect fires invalid change event if selectedIndex is unchanged.
5728      */
5729     private int rt_40212_count = 0;
5730     @Test public void test_rt_40212() {
5731         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5732         root.setExpanded(true);
5733         root.getChildren().addAll(
5734                 new TreeItem&lt;&gt;(&quot;0&quot;),
5735                 new TreeItem&lt;&gt;(&quot;1&quot;),
5736                 new TreeItem&lt;&gt;(&quot;2&quot;),
5737                 new TreeItem&lt;&gt;(&quot;3&quot;),
5738                 new TreeItem&lt;&gt;(&quot;4&quot;),
5739                 new TreeItem&lt;&gt;(&quot;5&quot;)
5740         );
5741 
5742         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5743         stringTreeTableView.setShowRoot(false);
5744 
5745         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5746         sm.setSelectionMode(SelectionMode.MULTIPLE);
5747 
5748         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5749         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5750         stringTreeTableView.getColumns().add(column);
5751 
5752         sm.selectRange(3, 5);
5753         int selected = sm.getSelectedIndex();
5754 
5755         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;) change -&gt; {
5756             assertEquals(&quot;sanity: selectedIndex unchanged&quot;, selected, sm.getSelectedIndex());
5757             while(change.next()) {
5758                 assertEquals(&quot;single event on clearAndSelect already selected&quot;, 1, ++rt_40212_count);
5759 
5760                 boolean type = change.wasAdded() || change.wasRemoved() || change.wasPermutated() || change.wasUpdated();
5761                 assertTrue(&quot;at least one of the change types must be true&quot;, type);
5762             }
5763         });
5764 
5765         sm.clearAndSelect(selected);
5766     }
5767 
5768     @Test public void test_rt_40280() {
5769         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;();
5770         StageLoader sl = new StageLoader(view);
5771         MultipleSelectionModelBaseShim.getFocusedIndex(view.getSelectionModel());
5772         view.getFocusModel().getFocusedIndex();
5773         sl.dispose();
5774     }
5775 
5776     @Test public void test_rt_40278_showRoot() {
5777         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5778         root.setExpanded(true);
5779         root.getChildren().addAll(new TreeItem&lt;&gt;(&quot;0&quot;),new TreeItem&lt;&gt;(&quot;1&quot;));
5780 
5781         TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
5782         view.setShowRoot(false);
5783         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
5784 
5785         assertFalse(&quot;sanity: test setup such that root is not showing&quot;, view.isShowRoot());
5786         sm.select(0);
5787         assertEquals(0, sm.getSelectedIndex());
5788         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5789         view.setShowRoot(true);
5790         assertEquals(1, sm.getSelectedIndex());
5791         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5792     }
5793 
5794     @Test public void test_rt_40278_hideRoot_selectionOnChild() {
5795         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5796         root.setExpanded(true);
5797         root.getChildren().addAll(new TreeItem&lt;&gt;(&quot;0&quot;),new TreeItem&lt;&gt;(&quot;1&quot;));
5798 
5799         TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
5800         view.setShowRoot(true);
5801         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
5802 
5803         assertTrue(&quot;sanity: test setup such that root is showing&quot;, view.isShowRoot());
5804         sm.select(1);
5805         assertEquals(1, sm.getSelectedIndex());
5806         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5807         view.setShowRoot(false);
5808         assertEquals(0, sm.getSelectedIndex());
5809         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5810     }
5811 
5812     @Test public void test_rt_40278_hideRoot_selectionOnRoot() {
5813         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5814         root.setExpanded(true);
5815         root.getChildren().addAll(new TreeItem&lt;&gt;(&quot;0&quot;),new TreeItem&lt;&gt;(&quot;1&quot;));
5816 
5817         TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
5818         view.setShowRoot(true);
5819         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
5820 
5821         assertTrue(&quot;sanity: test setup such that root is showing&quot;, view.isShowRoot());
5822         sm.select(0);
5823         assertEquals(0, sm.getSelectedIndex());
5824         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5825         view.setShowRoot(false);
5826         assertEquals(0, sm.getSelectedIndex());
5827         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5828     }
5829 
5830     /**
5831      * Test list change of selectedIndices on setIndices. Fails for core ..
5832      */
5833     @Test public void test_rt_40263() {
5834         TreeItem&lt;Integer&gt; root = new TreeItem&lt;&gt;(-1);
5835         root.setExpanded(true);
5836 
5837         for (int i = 0; i &lt; 10; i++) {
5838             root.getChildren().add(new TreeItem&lt;Integer&gt;(i));
5839         }
5840 
5841         final TreeTableView&lt;Integer&gt; view = new TreeTableView&lt;&gt;(root);
5842         TreeTableView.TreeTableViewSelectionModel&lt;Integer&gt; sm = view.getSelectionModel();
5843         sm.setSelectionMode(SelectionMode.MULTIPLE);
5844 
5845         int[] indices = new int[]{2, 5, 7};
5846         ListChangeListener&lt;Integer&gt; l = c -&gt; {
5847             // firstly, we expect only one change
5848             int subChanges = 0;
5849             while(c.next()) {
5850                 subChanges++;
5851             }
5852             assertEquals(1, subChanges);
5853 
5854             // secondly, we expect the added size to be three, as that is the
5855             // number of items selected
5856             c.reset();
5857             c.next();
5858             System.out.println(&quot;Added items: &quot; + c.getAddedSubList());
5859             assertEquals(indices.length, c.getAddedSize());
5860             assertArrayEquals(indices, c.getAddedSubList().stream().mapToInt(i -&gt; i).toArray());
5861         };
5862         sm.getSelectedIndices().addListener(l);
5863         sm.selectIndices(indices[0], indices);
5864     }
5865 
5866     @Test public void test_rt_40319_toRight_toBottom()          { test_rt_40319(true, true, false);   }
5867     @Test public void test_rt_40319_toRight_toTop()             { test_rt_40319(true, false, false);  }
5868     @Test public void test_rt_40319_toLeft_toBottom()           { test_rt_40319(false, true, false);  }
5869     @Test public void test_rt_40319_toLeft_toTop()              { test_rt_40319(false, false, false); }
5870     @Test public void test_rt_40319_toRight_toBottom_useMouse() { test_rt_40319(true, true, true);    }
5871     @Test public void test_rt_40319_toRight_toTop_useMouse()    { test_rt_40319(true, false, true);   }
5872     @Test public void test_rt_40319_toLeft_toBottom_useMouse()  { test_rt_40319(false, true, true);   }
5873     @Test public void test_rt_40319_toLeft_toTop_useMouse()     { test_rt_40319(false, false, true);  }
5874 
5875     private void test_rt_40319(boolean toRight, boolean toBottom, boolean useMouse) {
5876         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5877         root.setExpanded(true);
5878         root.getChildren().addAll(
5879                 new TreeItem&lt;&gt;(&quot;0&quot;),
5880                 new TreeItem&lt;&gt;(&quot;1&quot;),
5881                 new TreeItem&lt;&gt;(&quot;2&quot;),
5882                 new TreeItem&lt;&gt;(&quot;3&quot;),
5883                 new TreeItem&lt;&gt;(&quot;4&quot;),
5884                 new TreeItem&lt;&gt;(&quot;5&quot;)
5885         );
5886 
5887         TreeTableView&lt;String&gt; t = new TreeTableView&lt;&gt;(root);
5888         t.setShowRoot(false);
5889 
5890         sm = t.getSelectionModel();
5891         sm.setSelectionMode(SelectionMode.MULTIPLE);
5892 
5893         TreeTableColumn&lt;String,String&gt; c1 = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5894         c1.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5895         TreeTableColumn&lt;String,String&gt; c2 = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5896         c2.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5897         t.getColumns().addAll(c1, c2);
5898 
5899         final int startIndex = toRight ? 0 : 2;
5900         final int endIndex = toRight ? 2 : 0;
5901         final TreeTableColumn&lt;String,String&gt; startColumn = toBottom ? c1 : c2;
5902         final TreeTableColumn&lt;String,String&gt; endColumn = toBottom ? c2 : c1;
5903 
5904         sm.select(startIndex, startColumn);
5905 
5906         if (useMouse) {
5907             Cell endCell = VirtualFlowTestUtils.getCell(t, endIndex, toRight ? 1 : 0);
5908             MouseEventFirer mouse = new MouseEventFirer(endCell);
5909             mouse.fireMousePressAndRelease(KeyModifier.SHIFT);
5910         } else {
5911             t.getSelectionModel().selectRange(startIndex, startColumn, endIndex, endColumn);
5912         }
5913 
5914         assertEquals(3, sm.getSelectedItems().size());
5915         assertEquals(3, sm.getSelectedIndices().size());
5916         assertEquals(3, sm.getSelectedCells().size());
5917     }
5918 
5919     @Test public void test_jdk_8147483() {
5920         TreeItem&lt;Number&gt; root = new TreeItem&lt;&gt;(0);
5921         root.setExpanded(true);
5922 
5923         final TreeTableView&lt;Number&gt; view = new TreeTableView&lt;&gt;(root);
5924         view.setShowRoot(false);
5925 
5926         AtomicInteger cellUpdateCount = new AtomicInteger();
5927         AtomicInteger rowCreateCount = new AtomicInteger();
5928 
5929         TreeTableColumn&lt;Number, Number&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5930         column.setCellValueFactory(cdf -&gt; new ReadOnlyIntegerWrapper(0));
5931         column.setCellFactory( ttc -&gt; new TreeTableCell&lt;Number,Number&gt;() {
5932             @Override protected void updateItem(Number item, boolean empty) {
5933                 cellUpdateCount.incrementAndGet();
5934                 super.updateItem(item, empty);
5935             }
5936         });
5937         view.getColumns().add(column);
5938 
5939         view.setRowFactory(t -&gt; {
5940             rowCreateCount.incrementAndGet();
5941             return new TreeTableRow&lt;&gt;();
5942         });
5943 
5944         assertEquals(0, cellUpdateCount.get());
5945         assertEquals(0, rowCreateCount.get());
5946 
5947         StageLoader sl = new StageLoader(view);
5948 
5949         // Before the fix, we got cellUpdateCount = 18 and rowCreateCount = 17 for the first add below.
5950         // After the second add, these numbers went to 53 and 17 respectively.
5951         // Because these numbers might differ on other systems, we simply record the values after
5952         // the first add, and then we expect the cellUpdateCount to increase by one, and rowCreateCount to
5953         // not increase at all.
5954         root.getChildren().add(new TreeItem(1));
5955         Toolkit.getToolkit().firePulse();
5956         final int firstCellUpdateCount = cellUpdateCount.get();
5957         final int firstRowCreateCount = rowCreateCount.get();
5958 
5959         root.getChildren().add(new TreeItem(2));
5960         Toolkit.getToolkit().firePulse();
5961         assertEquals(firstCellUpdateCount+1, cellUpdateCount.get());
5962         assertEquals(firstRowCreateCount, rowCreateCount.get());
5963 
5964         root.getChildren().add(new TreeItem(3));
5965         Toolkit.getToolkit().firePulse();
5966         assertEquals(firstCellUpdateCount+2, cellUpdateCount.get());
5967         assertEquals(firstRowCreateCount, rowCreateCount.get());
5968 
5969         sl.dispose();
5970     }
5971 
5972     @Test public void test_jdk_8144681_removeColumn() {
5973         TreeTableView&lt;Book&gt; table = new TreeTableView&lt;&gt;();
5974 
5975         TreeItem&lt;Book&gt; root = new TreeItem&lt;&gt;();
5976         root.getChildren().addAll(
5977                 new TreeItem&lt;&gt;(new Book(&quot;Book 1&quot;, &quot;Author 1&quot;, &quot;Remark 1&quot;))
5978                 , new TreeItem&lt;&gt;(new Book(&quot;Book 2&quot;, &quot;Author 2&quot;, &quot;Remark 2&quot;))
5979                 , new TreeItem&lt;&gt;(new Book(&quot;Book 3&quot;, &quot;Author 3&quot;, &quot;Remark 3&quot;))
5980                 , new TreeItem&lt;&gt;(new Book(&quot;Book 4&quot;, &quot;Author 4&quot;, &quot;Remark 4&quot;)));
5981         table.setRoot(root);
5982 
5983         String[] columns = { &quot;title&quot;, &quot;author&quot;, &quot;remark&quot; };
5984         for (String prop : columns) {
5985             TreeTableColumn&lt;Book, String&gt; col = new TreeTableColumn&lt;&gt;(prop);
5986             col.setCellValueFactory(new TreeItemPropertyValueFactory&lt;&gt;(prop));
5987             table.getColumns().add(col);
5988         }
5989         table.setColumnResizePolicy(TreeTableView.UNCONSTRAINED_RESIZE_POLICY);
5990         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
5991         table.getSelectionModel().setCellSelectionEnabled(true);
5992 
5993         table.getSelectionModel().selectAll();
5994 
5995         ControlTestUtils.runWithExceptionHandler(() -&gt; table.getColumns().remove(2));
5996     }
5997 
5998     @Test public void test_jdk_8144681_moveColumn() {
5999         TreeTableView&lt;Book&gt; table = new TreeTableView&lt;&gt;();
6000 
6001         TreeItem&lt;Book&gt; root = new TreeItem&lt;&gt;();
6002         root.getChildren().addAll(
6003                 new TreeItem&lt;&gt;(new Book(&quot;Book 1&quot;, &quot;Author 1&quot;, &quot;Remark 1&quot;))
6004                 , new TreeItem&lt;&gt;(new Book(&quot;Book 2&quot;, &quot;Author 2&quot;, &quot;Remark 2&quot;))
6005                 , new TreeItem&lt;&gt;(new Book(&quot;Book 3&quot;, &quot;Author 3&quot;, &quot;Remark 3&quot;))
6006                 , new TreeItem&lt;&gt;(new Book(&quot;Book 4&quot;, &quot;Author 4&quot;, &quot;Remark 4&quot;)));
6007         table.setRoot(root);
6008 
6009         String[] columns = { &quot;title&quot;, &quot;author&quot;, &quot;remark&quot; };
6010         for (String prop : columns) {
6011             TreeTableColumn&lt;Book, String&gt; col = new TreeTableColumn&lt;&gt;(prop);
6012             col.setCellValueFactory(new TreeItemPropertyValueFactory&lt;&gt;(prop));
6013             table.getColumns().add(col);
6014         }
6015         table.setColumnResizePolicy(TreeTableView.UNCONSTRAINED_RESIZE_POLICY);
6016         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
6017         table.getSelectionModel().setCellSelectionEnabled(true);
6018 
6019         table.getSelectionModel().selectAll();
6020 
6021         ControlTestUtils.runWithExceptionHandler(() -&gt; {
6022             table.getColumns().setAll(table.getColumns().get(0), table.getColumns().get(2), table.getColumns().get(1));
6023         });
6024     }
6025 
6026     private static class Book {
6027         private SimpleStringProperty title = new SimpleStringProperty();
6028         private SimpleStringProperty author = new SimpleStringProperty();
6029         private SimpleStringProperty remark = new SimpleStringProperty();
6030 
6031         public Book(String title, String author, String remark) {
6032             super();
6033             setTitle(title);
6034             setAuthor(author);
6035             setRemark(remark);
6036         }
6037 
6038         public SimpleStringProperty titleProperty() {
6039             return this.title;
6040         }
6041 
6042         public java.lang.String getTitle() {
6043             return this.titleProperty().get();
6044         }
6045 
6046         public void setTitle(final java.lang.String title) {
6047             this.titleProperty().set(title);
6048         }
6049 
6050         public SimpleStringProperty authorProperty() {
6051             return this.author;
6052         }
6053 
6054         public java.lang.String getAuthor() {
6055             return this.authorProperty().get();
6056         }
6057 
6058         public void setAuthor(final java.lang.String author) {
6059             this.authorProperty().set(author);
6060         }
6061 
6062         public SimpleStringProperty remarkProperty() {
6063             return this.remark;
6064         }
6065 
6066         public java.lang.String getRemark() {
6067             return this.remarkProperty().get();
6068         }
6069 
6070         public void setRemark(final java.lang.String remark) {
6071             this.remarkProperty().set(remark);
6072         }
6073 
6074         @Override
6075         public String toString() {
6076             return String.format(&quot;%s(%s) - %s&quot;, getTitle(), getAuthor(), getRemark());
6077         }
6078     }
6079 
6080     @Test public void test_jdk_8157205() {
6081         final TreeItem&lt;String&gt; childNode1 = new TreeItem&lt;&gt;(&quot;Child Node 1&quot;);
6082         childNode1.setExpanded(true);
6083         TreeItem&lt;String&gt; item1 = new TreeItem&lt;&gt;(&quot;Node 1-1&quot;);
6084         TreeItem&lt;String&gt; item2 = new TreeItem&lt;&gt;(&quot;Node 1-2&quot;);
6085         childNode1.getChildren().addAll(item1, item2);
6086 
6087         final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root node&quot;);
6088         root.setExpanded(true);
6089         root.getChildren().add(childNode1);
6090 
6091         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
6092         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
6093         sm.setSelectionMode(SelectionMode.MULTIPLE);
6094 
6095         AtomicInteger step = new AtomicInteger();
6096 
6097         AtomicInteger indicesEventCount = new AtomicInteger();
6098         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;)c -&gt; {
6099             switch (step.get()) {
6100                 case 0: {
6101                     // expect to see [1,2,3] added at index 0
6102                     c.next();
6103                     assertEquals(3, c.getAddedSize());
6104                     assertTrue(&quot;added: &quot; + c.getAddedSubList(),
6105                             c.getAddedSubList().containsAll(FXCollections.observableArrayList(1,2,3)));
6106                     assertEquals(0, c.getFrom());
6107                     break;
6108                 }
6109                 case 1: {
6110                     // expect to see [2,3] removed
6111                     List&lt;Integer&gt; removed = new ArrayList&lt;&gt;();
6112                     while (c.next()) {
6113                         if (c.wasRemoved()) {
6114                             removed.addAll(c.getRemoved());
6115                         } else {
6116                             fail(&quot;Unexpected state&quot;);
6117                         }
6118                     }
6119                     if (!removed.isEmpty()) {
6120                         assertTrue(removed.containsAll(FXCollections.observableArrayList(2,3)));
6121                     }
6122                     break;
6123                 }
6124             }
6125 
6126             indicesEventCount.incrementAndGet();
6127         });
6128 
6129         AtomicInteger itemsEventCount = new AtomicInteger();
6130         sm.getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;)c -&gt; {
6131             switch (step.get()) {
6132                 case 0: {
6133                     // expect to see [1,2,3] added at index 0
6134                     c.next();
6135                     assertEquals(3, c.getAddedSize());
6136                     assertTrue(&quot;added: &quot; + c.getAddedSubList(),
6137                             c.getAddedSubList().containsAll(FXCollections.observableArrayList(childNode1, item1, item2)));
6138                     assertEquals(0, c.getFrom());
6139                     break;
6140                 }
6141                 case 1: {
6142                     // expect to see [2,3] removed
6143                     List&lt;TreeItem&lt;String&gt;&gt; removed = new ArrayList&lt;&gt;();
6144                     while (c.next()) {
6145                         if (c.wasRemoved()) {
6146                             removed.addAll(c.getRemoved());
6147                         } else {
6148                             fail(&quot;Unexpected state&quot;);
6149                         }
6150                     }
6151                     if (!removed.isEmpty()) {
6152                         assertTrue(removed.containsAll(FXCollections.observableArrayList(item1, item2)));
6153                     }
6154                     break;
6155                 }
6156             }
6157 
6158             itemsEventCount.incrementAndGet();
6159         });
6160 
6161         assertEquals(0, indicesEventCount.get());
6162         assertEquals(0, itemsEventCount.get());
6163 
6164         step.set(0);
6165         sm.selectIndices(1,2,3); // select Child Node 1 and both children
6166         assertTrue(sm.isSelected(1));
6167         assertTrue(sm.isSelected(2));
6168         assertTrue(sm.isSelected(3));
6169         assertEquals(3, sm.getSelectedIndices().size());
6170         assertEquals(3, sm.getSelectedItems().size());
6171         assertEquals(1, indicesEventCount.get());
6172         assertEquals(1, itemsEventCount.get());
6173 
6174         step.set(1);
6175         System.out.println(&quot;about to collapse now&quot;);
6176         childNode1.setExpanded(false); // collapse Child Node 1 and expect both children to be deselected
6177         assertTrue(sm.isSelected(1));
6178         assertFalse(sm.isSelected(2));
6179         assertFalse(sm.isSelected(3));
6180         assertEquals(1, sm.getSelectedIndices().size());
6181         assertEquals(1, sm.getSelectedItems().size());
6182         assertEquals(2, indicesEventCount.get());
6183         assertEquals(2, itemsEventCount.get());
6184 
6185         step.set(2);
6186         childNode1.setExpanded(true); // expand Child Node 1 and expect both children to still be deselected
6187         assertTrue(sm.isSelected(1));
6188         assertFalse(sm.isSelected(2));
6189         assertFalse(sm.isSelected(3));
6190         assertEquals(1, sm.getSelectedIndices().size());
6191         assertEquals(1, sm.getSelectedItems().size());
6192         assertEquals(2, indicesEventCount.get());
6193         assertEquals(2, itemsEventCount.get());
6194     }
6195 
6196     @Test public void test_jdk_8157285() {
6197         final TreeItem&lt;String&gt; childNode1 = new TreeItem&lt;&gt;(&quot;Child Node 1&quot;);
6198         childNode1.setExpanded(true);
6199         TreeItem&lt;String&gt; item1 = new TreeItem&lt;&gt;(&quot;Node 1-1&quot;);
6200         TreeItem&lt;String&gt; item2 = new TreeItem&lt;&gt;(&quot;Node 1-2&quot;);
6201         childNode1.getChildren().addAll(item1, item2);
6202 
6203         final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root node&quot;);
6204         root.setExpanded(true);
6205         root.getChildren().add(childNode1);
6206 
6207         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
6208         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
6209         sm.setSelectionMode(SelectionMode.MULTIPLE);
6210 
6211         view.expandedItemCountProperty().addListener((observable, oldCount, newCount) -&gt; {
6212             if (childNode1.isExpanded()) return;
6213             System.out.println(sm.getSelectedIndices());
6214             System.out.println(sm.getSelectedItems());
6215             assertTrue(sm.isSelected(1));
6216             assertFalse(sm.isSelected(2));
6217             assertFalse(sm.isSelected(3));
6218             assertEquals(1, sm.getSelectedIndices().size());
6219             assertEquals(1, sm.getSelectedItems().size());
6220         });
6221 
6222         sm.selectIndices(1,2,3); // select Child Node 1 and both children
6223         assertTrue(sm.isSelected(1));
6224         assertTrue(sm.isSelected(2));
6225         assertTrue(sm.isSelected(3));
6226         assertEquals(3, sm.getSelectedIndices().size());
6227         assertEquals(3, sm.getSelectedItems().size());
6228 
6229         // collapse Child Node 1 and expect both children to be deselected,
6230         // and that in the expandedItemCount listener that we get the right values
6231         // in the selectedIndices and selectedItems list
6232         childNode1.setExpanded(false);
6233     }
6234 
6235     @Test public void test_jdk_8152396() {
6236         final TreeItem&lt;String&gt; childNode1 = new TreeItem&lt;&gt;(&quot;Child Node 1&quot;);
6237         TreeItem&lt;String&gt; item1 = new TreeItem&lt;&gt;(&quot;Node 1-1&quot;);
6238         TreeItem&lt;String&gt; item2 = new TreeItem&lt;&gt;(&quot;Node 1-2&quot;);
6239         childNode1.getChildren().addAll(item1, item2);
6240 
6241         final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root node&quot;);
6242         root.setExpanded(true);
6243         root.getChildren().add(childNode1);
6244 
6245         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
6246         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
6247         sm.setSelectionMode(SelectionMode.MULTIPLE);
6248 
6249         view.expandedItemCountProperty().addListener((observable, oldCount, newCount) -&gt; {
6250             if (newCount.intValue() &gt; oldCount.intValue()) {
6251                 for (int index: sm.getSelectedIndices()) {
6252                     TreeItem&lt;String&gt; item = view.getTreeItem(index);
6253 
6254                     if (item != null &amp;&amp; item.isExpanded() &amp;&amp; !item.getChildren().isEmpty()) {
6255                         int startIndex = index + 1;
6256                         int maxCount = startIndex + item.getChildren().size();
6257 
6258                         sm.selectRange(startIndex, maxCount);
6259                     }
6260                 }
6261             }
6262         });
6263 
6264         FilteredList filteredList = sm.getSelectedItems().filtered(Objects::nonNull);
6265 
6266         StageLoader sl = new StageLoader(view);
6267 
6268         sm.select(1);
6269         childNode1.setExpanded(true);
6270         Toolkit.getToolkit().firePulse();
6271 
6272         // collapse Child Node 1 and expect both children to be deselected,
6273         // and that the filtered list does not throw an exception
6274         assertEquals(3, filteredList.size());
6275         ControlTestUtils.runWithExceptionHandler(() -&gt; childNode1.setExpanded(false));
6276 
6277         Toolkit.getToolkit().firePulse();
6278         assertEquals(1, filteredList.size());
6279 
6280         sl.dispose();
6281     }
6282 
6283     @Test public void test_jdk_8160771() {
6284         TreeTableView table = new TreeTableView();
6285         TreeTableColumn first = new TreeTableColumn(&quot;First Name&quot;);
6286         table.getColumns().add(first);
6287         table.getVisibleLeafColumns().addListener((ListChangeListener) c -&gt; {
6288             c.next();
6289             assertTrue(c.wasAdded());
6290             assertSame(table, ((TreeTableColumn) c.getAddedSubList().get(0)).getTreeTableView());
6291         });
6292         TreeTableColumn last = new TreeTableColumn(&quot;Last Name&quot;);
6293         table.getColumns().add(0, last);
6294     }
6295 
6296     private void test_jdk_8169642(Consumer&lt;TreeTableView.TreeTableViewSelectionModel&gt; before,
6297                                   Consumer&lt;TreeTableView.TreeTableViewSelectionModel&gt; afterDescending,
6298                                   Consumer&lt;TreeTableView.TreeTableViewSelectionModel&gt; afterAscending) {
6299         final TreeItem&lt;String&gt; rootItem = new TreeItem&lt;&gt;(&quot;root&quot;);
6300         rootItem.setExpanded(true);
6301         rootItem.getChildren().addAll(new TreeItem&lt;&gt;(&quot;first child&quot;), new TreeItem&lt;&gt;(&quot;second child&quot;), new TreeItem&lt;&gt;(&quot;third child&quot;));
6302 
6303         final TreeTableView&lt;String&gt; tree = new TreeTableView&lt;&gt;(rootItem);
6304         final TreeTableColumn&lt;String, String&gt; column = new TreeTableColumn&lt;&gt;(&quot;first column&quot;);
6305         column.setCellValueFactory(param -&gt; new SimpleStringProperty(param.getValue().getValue()));
6306         tree.getColumns().add(column);
6307 
6308         TreeTableView.TreeTableViewSelectionModel sm = tree.getSelectionModel();
6309         sm.setSelectionMode(SelectionMode.MULTIPLE);
6310 
6311         assertTrue(sm.isEmpty());
6312         before.accept(sm);
6313 
6314         tree.getSortOrder().add(column);
6315         column.setSortType(TreeTableColumn.SortType.DESCENDING);
6316         afterDescending.accept(sm);
6317 
6318         column.setSortType(TreeTableColumn.SortType.ASCENDING);
6319         afterAscending.accept(sm);
6320     }
6321 
6322     @Test public void test_jdk_8169642_1_only() {
6323         test_jdk_8169642(
6324             sm -&gt; {
6325                 // select &#39;first&#39;
6326                 sm.select(1);
6327                 assertTrue(sm.isSelected(1));
6328                 assertEquals(1, sm.getSelectedCells().size());
6329             },
6330             sm -&gt; {
6331                 assertTrue(sm.isSelected(3));
6332                 assertEquals(1, sm.getSelectedCells().size());
6333             },
6334             sm -&gt; {
6335                 assertTrue(sm.isSelected(1));
6336                 assertEquals(1, sm.getSelectedCells().size());
6337             }
6338         );
6339     }
6340 
6341     @Test public void test_jdk_8169642_2_only() {
6342         test_jdk_8169642(
6343             sm -&gt; {
6344                 // select &#39;second&#39;
6345                 sm.select(2);
6346                 assertTrue(sm.isSelected(2));
6347                 assertEquals(1, sm.getSelectedCells().size());
6348             },
6349             sm -&gt; {
6350                 assertTrue(sm.isSelected(2));
6351                 assertEquals(1, sm.getSelectedCells().size());
6352             },
6353             sm -&gt; {
6354                 assertTrue(sm.isSelected(2));
6355                 assertEquals(1, sm.getSelectedCells().size());
6356             }
6357         );
6358     }
6359 
6360     @Test public void test_jdk_8169642_1_and_3() {
6361         test_jdk_8169642(
6362             sm -&gt; {
6363                 // select &#39;first&#39; and &#39;third&#39;, they should flip positions
6364                 sm.select(1);
6365                 sm.select(3);
6366                 assertTrue(sm.isSelected(1));
6367                 assertTrue(sm.isSelected(3));
6368                 assertEquals(2, sm.getSelectedCells().size());
6369             },
6370             sm -&gt; {
6371                 assertTrue(sm.isSelected(1));
6372                 assertTrue(sm.isSelected(3));
6373                 assertEquals(2, sm.getSelectedCells().size());
6374             },
6375             sm -&gt; {
6376                 assertTrue(sm.isSelected(1));
6377                 assertTrue(sm.isSelected(3));
6378                 assertEquals(2, sm.getSelectedCells().size());
6379             }
6380         );
6381     }
6382 
6383     @Test public void test_jdk_8169642_0_and_3() {
6384         test_jdk_8169642(
6385                 sm -&gt; {
6386                     // select &#39;root&#39; and &#39;third&#39;
6387                     sm.select(0);
6388                     sm.select(3);
6389                     assertTrue(sm.isSelected(0));
6390                     assertTrue(sm.isSelected(3));
6391                     assertEquals(2, sm.getSelectedCells().size());
6392                 },
6393                 sm -&gt; {
6394                     assertTrue(sm.isSelected(0));
6395                     assertTrue(sm.isSelected(1));
6396                     assertEquals(2, sm.getSelectedCells().size());
6397                 },
6398                 sm -&gt; {
6399                     assertTrue(sm.isSelected(0));
6400                     assertTrue(sm.isSelected(3));
6401                     assertEquals(2, sm.getSelectedCells().size());
6402                 }
6403         );
6404     }
6405 }
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.fxml/src/main/java/javafx/fxml/FXMLLoader.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.fxml;
  27 
  28 import com.sun.javafx.util.Logging;
  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.io.InputStreamReader;
  32 import java.lang.reflect.Array;
  33 import java.lang.reflect.Constructor;
  34 import java.lang.reflect.Field;
  35 import java.lang.reflect.InvocationTargetException;
  36 import java.lang.reflect.Method;
  37 import java.lang.reflect.Modifier;
  38 import java.lang.reflect.ParameterizedType;
  39 import java.lang.reflect.Type;
  40 import java.net.URL;
  41 import java.nio.charset.Charset;
  42 import java.util.AbstractMap;
  43 import java.util.ArrayList;
  44 import java.util.Collections;
  45 import java.util.HashMap;
  46 import java.util.LinkedList;
  47 import java.util.List;
  48 import java.util.Map;
  49 import java.util.ResourceBundle;
  50 import java.util.Set;
  51 import java.util.regex.Pattern;
  52 
  53 import javafx.beans.DefaultProperty;
  54 import javafx.beans.InvalidationListener;
  55 import javafx.beans.property.Property;
  56 import javafx.beans.value.ChangeListener;
  57 import javafx.beans.value.ObservableValue;
  58 import javafx.collections.*;
  59 import javafx.event.Event;
  60 import javafx.event.EventHandler;
  61 import javafx.util.Builder;
  62 import javafx.util.BuilderFactory;
  63 import javafx.util.Callback;
  64 
  65 import javax.script.Bindings;
  66 import javax.script.Compilable;
  67 import javax.script.CompiledScript;
  68 import javax.script.ScriptContext;
  69 import javax.script.ScriptEngine;
  70 import javax.script.ScriptEngineManager;
  71 import javax.script.ScriptException;
  72 import javax.script.SimpleBindings;
  73 import javax.xml.stream.XMLInputFactory;
  74 import javax.xml.stream.XMLStreamConstants;
  75 import javax.xml.stream.XMLStreamException;
  76 import javax.xml.stream.XMLStreamReader;
  77 import javax.xml.stream.util.StreamReaderDelegate;
  78 
  79 import com.sun.javafx.beans.IDProperty;
  80 import com.sun.javafx.fxml.BeanAdapter;
  81 import com.sun.javafx.fxml.ParseTraceElement;
  82 import com.sun.javafx.fxml.PropertyNotFoundException;
  83 import com.sun.javafx.fxml.expression.Expression;
  84 import com.sun.javafx.fxml.expression.ExpressionValue;
  85 import com.sun.javafx.fxml.expression.KeyPath;
  86 import static com.sun.javafx.FXPermissions.MODIFY_FXML_CLASS_LOADER_PERMISSION;
  87 import com.sun.javafx.fxml.FXMLLoaderHelper;
  88 import com.sun.javafx.fxml.MethodHelper;
  89 import java.net.MalformedURLException;
  90 import java.security.AccessController;
  91 import java.security.PrivilegedAction;
  92 import java.util.EnumMap;
  93 import java.util.Locale;
  94 import java.util.StringTokenizer;
  95 import com.sun.javafx.reflect.ConstructorUtil;
  96 import com.sun.javafx.reflect.MethodUtil;
  97 import com.sun.javafx.reflect.ReflectUtil;
  98 
  99 /**
 100  * Loads an object hierarchy from an XML document.
 101  * For more information, see the
 102  * &lt;a href=&quot;doc-files/introduction_to_fxml.html&quot;&gt;Introduction to FXML&lt;/a&gt;
 103  * document.
 104  *
 105  * @since JavaFX 2.0
 106  */
 107 public class FXMLLoader {
 108 
 109     // Indicates permission to get the ClassLoader
 110     private static final RuntimePermission GET_CLASSLOADER_PERMISSION =
 111         new RuntimePermission(&quot;getClassLoader&quot;);
 112 
 113     // Instance of StackWalker used to get caller class (must be private)
 114     private static final StackWalker walker =
 115         AccessController.doPrivileged((PrivilegedAction&lt;StackWalker&gt;) () -&gt;
 116             StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE));
 117 
 118     // Abstract base class for elements
 119     private abstract class Element {
 120         public final Element parent;
 121 
 122         public Object value = null;
 123         private BeanAdapter valueAdapter = null;
 124 
 125         public final LinkedList&lt;Attribute&gt; eventHandlerAttributes = new LinkedList&lt;Attribute&gt;();
 126         public final LinkedList&lt;Attribute&gt; instancePropertyAttributes = new LinkedList&lt;Attribute&gt;();
 127         public final LinkedList&lt;Attribute&gt; staticPropertyAttributes = new LinkedList&lt;Attribute&gt;();
 128         public final LinkedList&lt;PropertyElement&gt; staticPropertyElements = new LinkedList&lt;PropertyElement&gt;();
 129 
 130         public Element() {
 131             parent = current;
 132         }
 133 
 134         public boolean isCollection() {
 135             // Return true if value is a list, or if the value&#39;s type defines
 136             // a default property that is a list
 137             boolean collection;
 138             if (value instanceof List&lt;?&gt;) {
 139                 collection = true;
 140             } else {
 141                 Class&lt;?&gt; type = value.getClass();
 142                 DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);
 143 
 144                 if (defaultProperty != null) {
 145                     collection = getProperties().get(defaultProperty.value()) instanceof List&lt;?&gt;;
 146                 } else {
 147                     collection = false;
 148                 }
 149             }
 150 
 151             return collection;
 152         }
 153 
 154         @SuppressWarnings(&quot;unchecked&quot;)
 155         public void add(Object element) throws LoadException {
 156             // If value is a list, add element to it; otherwise, get the value
 157             // of the default property, which is assumed to be a list and add
 158             // to that (coerce to the appropriate type)
 159             List&lt;Object&gt; list;
 160             if (value instanceof List&lt;?&gt;) {
 161                 list = (List&lt;Object&gt;)value;
 162             } else {
 163                 Class&lt;?&gt; type = value.getClass();
 164                 DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);
 165                 String defaultPropertyName = defaultProperty.value();
 166 
 167                 // Get the list value
 168                 list = (List&lt;Object&gt;)getProperties().get(defaultPropertyName);
 169 
 170                 // Coerce the element to the list item type
 171                 if (!Map.class.isAssignableFrom(type)) {
 172                     Type listType = getValueAdapter().getGenericType(defaultPropertyName);
 173                     element = BeanAdapter.coerce(element, BeanAdapter.getListItemType(listType));
 174                 }
 175             }
 176 
 177             list.add(element);
 178         }
 179 
 180         public void set(Object value) throws LoadException {
 181             if (this.value == null) {
 182                 throw constructLoadException(&quot;Cannot set value on this element.&quot;);
 183             }
 184 
 185             // Apply value to this element&#39;s properties
 186             Class&lt;?&gt; type = this.value.getClass();
 187             DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);
 188             if (defaultProperty == null) {
 189                 throw constructLoadException(&quot;Element does not define a default property.&quot;);
 190             }
 191 
 192             getProperties().put(defaultProperty.value(), value);
 193         }
 194 
 195         public void updateValue(Object value) {
 196             this.value = value;
 197             valueAdapter = null;
 198         }
 199 
 200         public boolean isTyped() {
 201             return !(value instanceof Map&lt;?, ?&gt;);
 202         }
 203 
 204         public BeanAdapter getValueAdapter() {
 205             if (valueAdapter == null) {
 206                 valueAdapter = new BeanAdapter(value);
 207             }
 208 
 209             return valueAdapter;
 210         }
 211 
 212         @SuppressWarnings(&quot;unchecked&quot;)
 213         public Map&lt;String, Object&gt; getProperties() {
 214             return (isTyped()) ? getValueAdapter() : (Map&lt;String, Object&gt;)value;
 215         }
 216 
 217         public void processStartElement() throws IOException {
 218             for (int i = 0, n = xmlStreamReader.getAttributeCount(); i &lt; n; i++) {
 219                 String prefix = xmlStreamReader.getAttributePrefix(i);
 220                 String localName = xmlStreamReader.getAttributeLocalName(i);
 221                 String value = xmlStreamReader.getAttributeValue(i);
 222 
 223                 if (loadListener != null
 224                     &amp;&amp; prefix != null
 225                     &amp;&amp; prefix.equals(FX_NAMESPACE_PREFIX)) {
 226                     loadListener.readInternalAttribute(prefix + &quot;:&quot; + localName, value);
 227                 }
 228 
 229                 processAttribute(prefix, localName, value);
 230             }
 231         }
 232 
 233         public void processEndElement() throws IOException {
 234             // No-op
 235         }
 236 
 237         public void processCharacters() throws IOException {
 238             throw constructLoadException(&quot;Unexpected characters in input stream.&quot;);
 239         }
 240 
 241         public void processInstancePropertyAttributes() throws IOException {
 242             if (instancePropertyAttributes.size() &gt; 0) {
 243                 for (Attribute attribute : instancePropertyAttributes) {
 244                     processPropertyAttribute(attribute);
 245                 }
 246             }
 247         }
 248 
 249         public void processAttribute(String prefix, String localName, String value)
 250             throws IOException{
 251             if (prefix == null) {
 252                 // Add the attribute to the appropriate list
 253                 if (localName.startsWith(EVENT_HANDLER_PREFIX)) {
 254                     if (loadListener != null) {
 255                         loadListener.readEventHandlerAttribute(localName, value);
 256                     }
 257 
 258                     eventHandlerAttributes.add(new Attribute(localName, null, value));
 259                 } else {
 260                     int i = localName.lastIndexOf(&#39;.&#39;);
 261 
 262                     if (i == -1) {
 263                         // The attribute represents an instance property
 264                         if (loadListener != null) {
 265                             loadListener.readPropertyAttribute(localName, null, value);
 266                         }
 267 
 268                         instancePropertyAttributes.add(new Attribute(localName, null, value));
 269                     } else {
 270                         // The attribute represents a static property
 271                         String name = localName.substring(i + 1);
 272                         Class&lt;?&gt; sourceType = getType(localName.substring(0, i));
 273 
 274                         if (sourceType != null) {
 275                             if (loadListener != null) {
 276                                 loadListener.readPropertyAttribute(name, sourceType, value);
 277                             }
 278 
 279                             staticPropertyAttributes.add(new Attribute(name, sourceType, value));
 280                         } else if (staticLoad) {
 281                             if (loadListener != null) {
 282                                 loadListener.readUnknownStaticPropertyAttribute(localName, value);
 283                             }
 284                         } else {
 285                             throw constructLoadException(localName + &quot; is not a valid attribute.&quot;);
 286                         }
 287                     }
 288 
 289                 }
 290             } else {
 291                 throw constructLoadException(prefix + &quot;:&quot; + localName
 292                     + &quot; is not a valid attribute.&quot;);
 293             }
 294         }
 295 
 296         @SuppressWarnings(&quot;unchecked&quot;)
 297         public void processPropertyAttribute(Attribute attribute) throws IOException {
 298             String value = attribute.value;
 299             if (isBindingExpression(value)) {
 300                 // Resolve the expression
 301                 Expression expression;
 302 
 303                 if (attribute.sourceType != null) {
 304                     throw constructLoadException(&quot;Cannot bind to static property.&quot;);
 305                 }
 306 
 307                 if (!isTyped()) {
 308                     throw constructLoadException(&quot;Cannot bind to untyped object.&quot;);
 309                 }
 310 
 311                 // TODO We may want to identify binding properties in processAttribute()
 312                 // and apply them after build() has been called
 313                 if (this.value instanceof Builder) {
 314                     throw constructLoadException(&quot;Cannot bind to builder property.&quot;);
 315                 }
 316 
 317                 if (!isStaticLoad()) {
 318                     value = value.substring(BINDING_EXPRESSION_PREFIX.length(),
 319                             value.length() - 1);
 320                     expression = Expression.valueOf(value);
 321 
 322                     // Create the binding
 323                     BeanAdapter targetAdapter = new BeanAdapter(this.value);
 324                     ObservableValue&lt;Object&gt; propertyModel = targetAdapter.getPropertyModel(attribute.name);
 325                     Class&lt;?&gt; type = targetAdapter.getType(attribute.name);
 326 
 327                     if (propertyModel instanceof Property&lt;?&gt;) {
 328                         ((Property&lt;Object&gt;) propertyModel).bind(new ExpressionValue(namespace, expression, type));
 329                     }
 330                 }
 331             } else if (isBidirectionalBindingExpression(value)) {
 332                 throw constructLoadException(new UnsupportedOperationException(&quot;This feature is not currently enabled.&quot;));
 333             } else {
 334                 processValue(attribute.sourceType, attribute.name, value);
 335             }
 336         }
 337 
 338         private boolean isBindingExpression(String aValue) {
 339             return aValue.startsWith(BINDING_EXPRESSION_PREFIX)
 340                    &amp;&amp; aValue.endsWith(BINDING_EXPRESSION_SUFFIX);
 341         }
 342 
 343         private boolean isBidirectionalBindingExpression(String aValue) {
 344             return aValue.startsWith(BI_DIRECTIONAL_BINDING_PREFIX);
 345         }
 346 
 347         private boolean processValue(Class sourceType, String propertyName, String aValue)
 348             throws LoadException {
 349 
 350             boolean processed = false;
 351                 //process list or array first
 352                 if (sourceType == null &amp;&amp; isTyped()) {
 353                     BeanAdapter valueAdapter = getValueAdapter();
 354                     Class&lt;?&gt; type = valueAdapter.getType(propertyName);
 355 
 356                     if (type == null) {
 357                         throw new PropertyNotFoundException(&quot;Property \&quot;&quot; + propertyName
 358                             + &quot;\&quot; does not exist&quot; + &quot; or is read-only.&quot;);
 359                     }
 360 
 361                     if (List.class.isAssignableFrom(type)
 362                         &amp;&amp; valueAdapter.isReadOnly(propertyName)) {
 363                         populateListFromString(valueAdapter, propertyName, aValue);
 364                         processed = true;
 365                     } else if (type.isArray()) {
 366                         applyProperty(propertyName, sourceType,
 367                                 populateArrayFromString(type, aValue));
 368                         processed = true;
 369                     }
 370                 }
 371                 if (!processed) {
 372                     applyProperty(propertyName, sourceType, resolvePrefixedValue(aValue));
 373                     processed = true;
 374                 }
 375                 return processed;
 376         }
 377 
 378         /**
 379          * Resolves value prefixed with RELATIVE_PATH_PREFIX and RESOURCE_KEY_PREFIX.
 380          */
 381         private Object resolvePrefixedValue(String aValue) throws LoadException {
 382             if (aValue.startsWith(ESCAPE_PREFIX)) {
 383                 aValue = aValue.substring(ESCAPE_PREFIX.length());
 384 
 385                 if (aValue.length() == 0
 386                     || !(aValue.startsWith(ESCAPE_PREFIX)
 387                         || aValue.startsWith(RELATIVE_PATH_PREFIX)
 388                         || aValue.startsWith(RESOURCE_KEY_PREFIX)
 389                         || aValue.startsWith(EXPRESSION_PREFIX)
 390                         || aValue.startsWith(BI_DIRECTIONAL_BINDING_PREFIX))) {
 391                     throw constructLoadException(&quot;Invalid escape sequence.&quot;);
 392                 }
 393                 return aValue;
 394             } else if (aValue.startsWith(RELATIVE_PATH_PREFIX)) {
 395                 aValue = aValue.substring(RELATIVE_PATH_PREFIX.length());
 396                 if (aValue.length() == 0) {
 397                     throw constructLoadException(&quot;Missing relative path.&quot;);
 398                 }
 399                 if (aValue.startsWith(RELATIVE_PATH_PREFIX)) {
 400                     // The prefix was escaped
 401                     warnDeprecatedEscapeSequence(RELATIVE_PATH_PREFIX);
 402                     return aValue;
 403                 } else {
 404                         if (aValue.charAt(0) == &#39;/&#39;) {
 405                             // FIXME: JIGSAW -- use Class.getResourceAsStream if resource is in a module
 406                             final URL res = getClassLoader().getResource(aValue.substring(1));
 407                             if (res == null) {
 408                                 throw constructLoadException(&quot;Invalid resource: &quot; + aValue + &quot; not found on the classpath&quot;);
 409                             }
 410                             return res.toString();
 411                         } else {
 412                             try {
 413                                 return new URL(FXMLLoader.this.location, aValue).toString();
 414                             } catch (MalformedURLException e) {
 415                                 System.err.println(FXMLLoader.this.location + &quot;/&quot; + aValue);
 416                             }
 417                         }
 418                 }
 419             } else if (aValue.startsWith(RESOURCE_KEY_PREFIX)) {
 420                 aValue = aValue.substring(RESOURCE_KEY_PREFIX.length());
 421                 if (aValue.length() == 0) {
 422                     throw constructLoadException(&quot;Missing resource key.&quot;);
 423                 }
 424                 if (aValue.startsWith(RESOURCE_KEY_PREFIX)) {
 425                     // The prefix was escaped
 426                     warnDeprecatedEscapeSequence(RESOURCE_KEY_PREFIX);
 427                     return aValue;
 428                 } else {
 429                     // Resolve the resource value
 430                     if (resources == null) {
 431                         throw constructLoadException(&quot;No resources specified.&quot;);
 432                     }
 433                     if (!resources.containsKey(aValue)) {
 434                         throw constructLoadException(&quot;Resource \&quot;&quot; + aValue + &quot;\&quot; not found.&quot;);
 435                     }
 436 
 437                     return resources.getString(aValue);
 438                 }
 439             } else if (aValue.startsWith(EXPRESSION_PREFIX)) {
 440                 aValue = aValue.substring(EXPRESSION_PREFIX.length());
 441                 if (aValue.length() == 0) {
 442                     throw constructLoadException(&quot;Missing expression.&quot;);
 443                 }
 444                 if (aValue.startsWith(EXPRESSION_PREFIX)) {
 445                     // The prefix was escaped
 446                     warnDeprecatedEscapeSequence(EXPRESSION_PREFIX);
 447                     return aValue;
 448                 } else if (aValue.equals(NULL_KEYWORD)) {
 449                     // The attribute value is null
 450                     return null;
 451                 }
 452                 return Expression.get(namespace, KeyPath.parse(aValue));
 453             }
 454             return aValue;
 455         }
 456 
 457         /**
 458          * Creates an array of given type and populates it with values from
 459          * a string where tokens are separated by ARRAY_COMPONENT_DELIMITER.
 460          * If token is prefixed with RELATIVE_PATH_PREFIX a value added to
 461          * the array becomes relative to document location.
 462          */
 463         private Object populateArrayFromString(
 464                 Class&lt;?&gt;type,
 465                 String stringValue) throws LoadException {
 466 
 467             Object propertyValue = null;
 468             // Split the string and set the values as an array
 469             Class&lt;?&gt; componentType = type.getComponentType();
 470 
 471             if (stringValue.length() &gt; 0) {
 472                 String[] values = stringValue.split(ARRAY_COMPONENT_DELIMITER);
 473                 propertyValue = Array.newInstance(componentType, values.length);
 474                 for (int i = 0; i &lt; values.length; i++) {
 475                     Array.set(propertyValue, i,
 476                             BeanAdapter.coerce(resolvePrefixedValue(values[i].trim()),
 477                             type.getComponentType()));
 478                 }
 479             } else {
 480                 propertyValue = Array.newInstance(componentType, 0);
 481             }
 482             return propertyValue;
 483         }
 484 
 485         /**
 486          * Populates list with values from a string where tokens are separated
 487          * by ARRAY_COMPONENT_DELIMITER. If token is prefixed with RELATIVE_PATH_PREFIX
 488          * a value added to the list becomes relative to document location.
 489          */
 490         private void populateListFromString(
 491                 BeanAdapter valueAdapter,
 492                 String listPropertyName,
 493                 String stringValue) throws LoadException {
 494             // Split the string and add the values to the list
 495             List&lt;Object&gt; list = (List&lt;Object&gt;)valueAdapter.get(listPropertyName);
 496             Type listType = valueAdapter.getGenericType(listPropertyName);
 497             Type itemType = (Class&lt;?&gt;)BeanAdapter.getGenericListItemType(listType);
 498 
 499             if (itemType instanceof ParameterizedType) {
 500                 itemType = ((ParameterizedType)itemType).getRawType();
 501             }
 502 
 503             if (stringValue.length() &gt; 0) {
 504                 String[] values = stringValue.split(ARRAY_COMPONENT_DELIMITER);
 505 
 506                 for (String aValue: values) {
 507                     aValue = aValue.trim();
 508                     list.add(
 509                             BeanAdapter.coerce(resolvePrefixedValue(aValue),
 510                                                (Class&lt;?&gt;)itemType));
 511                 }
 512             }
 513         }
 514 
 515         public void warnDeprecatedEscapeSequence(String prefix) {
 516             System.err.println(prefix + prefix + &quot; is a deprecated escape sequence. &quot;
 517                 + &quot;Please use \\&quot; + prefix + &quot; instead.&quot;);
 518         }
 519 
 520         public void applyProperty(String name, Class&lt;?&gt; sourceType, Object value) {
 521             if (sourceType == null) {
 522                 getProperties().put(name, value);
 523             } else {
 524                 BeanAdapter.put(this.value, sourceType, name, value);
 525             }
 526         }
 527 
 528         private Object getExpressionObject(String handlerValue) throws LoadException{
 529             if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
 530                 handlerValue = handlerValue.substring(EXPRESSION_PREFIX.length());
 531 
 532                 if (handlerValue.length() == 0) {
 533                     throw constructLoadException(&quot;Missing expression reference.&quot;);
 534                 }
 535 
 536                 Object expression = Expression.get(namespace, KeyPath.parse(handlerValue));
 537                 if (expression == null) {
 538                     throw constructLoadException(&quot;Unable to resolve expression : $&quot; + handlerValue);
 539                 }
 540                 return expression;
 541             }
 542             return null;
 543         }
 544 
 545         private &lt;T&gt; T getExpressionObjectOfType(String handlerValue, Class&lt;T&gt; type) throws LoadException{
 546             Object expression = getExpressionObject(handlerValue);
 547             if (expression != null) {
 548                 if (type.isInstance(expression)) {
 549                     return (T) expression;
 550                 }
 551                 throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue +&quot;\&quot; expression.&quot;
 552                         + &quot;Does not point to a &quot; + type.getName());
 553             }
 554             return null;
 555         }
 556 
 557         private MethodHandler getControllerMethodHandle(String handlerName, SupportedType... types) throws LoadException {
 558             if (handlerName.startsWith(CONTROLLER_METHOD_PREFIX)) {
 559                 handlerName = handlerName.substring(CONTROLLER_METHOD_PREFIX.length());
 560 
 561                 if (!handlerName.startsWith(CONTROLLER_METHOD_PREFIX)) {
 562                     if (handlerName.length() == 0) {
 563                         throw constructLoadException(&quot;Missing controller method.&quot;);
 564                     }
 565 
 566                     if (controller == null) {
 567                         throw constructLoadException(&quot;No controller specified.&quot;);
 568                     }
 569 
 570                     for (SupportedType t : types) {
 571                         Method method = controllerAccessor
 572                                             .getControllerMethods()
 573                                             .get(t)
 574                                             .get(handlerName);
 575                         if (method != null) {
 576                             return new MethodHandler(controller, method, t);
 577                         }
 578                     }
 579                     Method method = controllerAccessor
 580                                         .getControllerMethods()
 581                                         .get(SupportedType.PARAMETERLESS)
 582                                         .get(handlerName);
 583                     if (method != null) {
 584                         return new MethodHandler(controller, method, SupportedType.PARAMETERLESS);
 585                     }
 586 
 587                     return null;
 588 
 589                 }
 590 
 591             }
 592             return null;
 593         }
 594 
 595         public void processEventHandlerAttributes() throws LoadException {
 596             if (eventHandlerAttributes.size() &gt; 0 &amp;&amp; !staticLoad) {
 597                 for (Attribute attribute : eventHandlerAttributes) {
 598                     String handlerName = attribute.value;
 599                     if (value instanceof ObservableList &amp;&amp; attribute.name.equals(COLLECTION_HANDLER_NAME)) {
 600                         processObservableListHandler(handlerName);
 601                     } else if (value instanceof ObservableMap &amp;&amp; attribute.name.equals(COLLECTION_HANDLER_NAME)) {
 602                         processObservableMapHandler(handlerName);
 603                     } else if (value instanceof ObservableSet &amp;&amp; attribute.name.equals(COLLECTION_HANDLER_NAME)) {
 604                         processObservableSetHandler(handlerName);
 605                     } else if (attribute.name.endsWith(CHANGE_EVENT_HANDLER_SUFFIX)) {
 606                         processPropertyHandler(attribute.name, handlerName);
 607                     } else {
 608                         EventHandler&lt;? extends Event&gt; eventHandler = null;
 609                         MethodHandler handler = getControllerMethodHandle(handlerName, SupportedType.EVENT);
 610                         if (handler != null) {
 611                             eventHandler = new ControllerMethodEventHandler&lt;&gt;(handler);
 612                         }
 613 
 614                         if (eventHandler == null) {
 615                             eventHandler = getExpressionObjectOfType(handlerName, EventHandler.class);
 616                         }
 617 
 618                         if (eventHandler == null) {
 619                             if (handlerName.length() == 0 || scriptEngine == null) {
 620                                 throw constructLoadException(&quot;Error resolving &quot; + attribute.name + &quot;=&#39;&quot; + attribute.value
 621                                         + &quot;&#39;, either the event handler is not in the Namespace or there is an error in the script.&quot;);
 622                             }
 623                             eventHandler = new ScriptEventHandler(handlerName, scriptEngine, location.getPath()
 624                                         + &quot;-&quot; + attribute.name  + &quot;_attribute_in_element_ending_at_line_&quot;  + getLineNumber());
 625                         }
 626 
 627                         // Add the handler
 628                         getValueAdapter().put(attribute.name, eventHandler);
 629                     }
 630                 }
 631             }
 632         }
 633 
 634         private void processObservableListHandler(String handlerValue) throws LoadException {
 635             ObservableList list = (ObservableList)value;
 636             if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
 637                 MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.LIST_CHANGE_LISTENER);
 638                 if (handler != null) {
 639                     list.addListener(new ObservableListChangeAdapter(handler));
 640                 } else {
 641                     throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
 642                 }
 643             } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
 644                 Object listener = getExpressionObject(handlerValue);
 645                    if (listener instanceof ListChangeListener) {
 646                     list.addListener((ListChangeListener) listener);
 647                 } else if (listener instanceof InvalidationListener) {
 648                     list.addListener((InvalidationListener) listener);
 649                 } else {
 650                     throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
 651                             + &quot;Must be either ListChangeListener or InvalidationListener&quot;);
 652                 }
 653             }
 654         }
 655 
 656         private void processObservableMapHandler(String handlerValue) throws LoadException {
 657             ObservableMap map = (ObservableMap)value;
 658             if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
 659                 MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.MAP_CHANGE_LISTENER);
 660                 if (handler != null) {
 661                     map.addListener(new ObservableMapChangeAdapter(handler));
 662                 } else {
 663                     throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
 664                 }
 665             } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
 666                 Object listener = getExpressionObject(handlerValue);
 667                 if (listener instanceof MapChangeListener) {
 668                     map.addListener((MapChangeListener) listener);
 669                 } else if (listener instanceof InvalidationListener) {
 670                     map.addListener((InvalidationListener) listener);
 671                 } else {
 672                     throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
 673                             + &quot;Must be either MapChangeListener or InvalidationListener&quot;);
 674                 }
 675             }
 676         }
 677 
 678         private void processObservableSetHandler(String handlerValue) throws LoadException {
 679             ObservableSet set = (ObservableSet)value;
 680             if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
 681                 MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.SET_CHANGE_LISTENER);
 682                 if (handler != null) {
 683                     set.addListener(new ObservableSetChangeAdapter(handler));
 684                 } else {
 685                     throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
 686                 }
 687             } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
 688                 Object listener = getExpressionObject(handlerValue);
 689                 if (listener instanceof SetChangeListener) {
 690                     set.addListener((SetChangeListener) listener);
 691                 } else if (listener instanceof InvalidationListener) {
 692                     set.addListener((InvalidationListener) listener);
 693                 } else {
 694                     throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
 695                             + &quot;Must be either SetChangeListener or InvalidationListener&quot;);
 696                 }
 697             }
 698         }
 699 
 700         private void processPropertyHandler(String attributeName, String handlerValue) throws LoadException {
 701             int i = EVENT_HANDLER_PREFIX.length();
 702             int j = attributeName.length() - CHANGE_EVENT_HANDLER_SUFFIX.length();
 703 
 704             if (i != j) {
 705                 String key = Character.toLowerCase(attributeName.charAt(i))
 706                         + attributeName.substring(i + 1, j);
 707 
 708                 ObservableValue&lt;Object&gt; propertyModel = getValueAdapter().getPropertyModel(key);
 709                 if (propertyModel == null) {
 710                     throw constructLoadException(value.getClass().getName() + &quot; does not define&quot;
 711                             + &quot; a property model for \&quot;&quot; + key + &quot;\&quot;.&quot;);
 712                 }
 713 
 714                 if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
 715                     final MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.PROPERTY_CHANGE_LISTENER, SupportedType.EVENT);
 716                     if (handler != null) {
 717                         if (handler.type == SupportedType.EVENT) {
 718                             // Note: this part is solely for purpose of 2.2 backward compatibility where an Event object
 719                             // has been used instead of usual property change parameters
 720                             propertyModel.addListener(new ChangeListener&lt;Object&gt;() {
 721                                 @Override
 722                                 public void changed(ObservableValue&lt;?&gt; observable, Object oldValue, Object newValue) {
 723                                     handler.invoke(new Event(value, null, Event.ANY));
 724                                 }
 725                             });
 726                         } else {
 727                             propertyModel.addListener(new PropertyChangeAdapter(handler));
 728                         }
 729                     } else {
 730                     throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
 731                     }
 732                 } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
 733                     Object listener = getExpressionObject(handlerValue);
 734                     if (listener instanceof ChangeListener) {
 735                         propertyModel.addListener((ChangeListener) listener);
 736                     } else if (listener instanceof InvalidationListener) {
 737                         propertyModel.addListener((InvalidationListener) listener);
 738                     } else {
 739                         throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
 740                                 + &quot;Must be either ChangeListener or InvalidationListener&quot;);
 741                     }
 742                 }
 743 
 744             }
 745         }
 746     }
 747 
 748     // Element representing a value
 749     private abstract class ValueElement extends Element {
 750         public String fx_id = null;
 751 
 752         @Override
 753         public void processStartElement() throws IOException {
 754             super.processStartElement();
 755 
 756             updateValue(constructValue());
 757 
 758             if (value instanceof Builder&lt;?&gt;) {
 759                 processInstancePropertyAttributes();
 760             } else {
 761                 processValue();
 762             }
 763         }
 764 
 765         @Override
 766         @SuppressWarnings(&quot;unchecked&quot;)
 767         public void processEndElement() throws IOException {
 768             super.processEndElement();
 769 
 770             // Build the value, if necessary
 771             if (value instanceof Builder&lt;?&gt;) {
 772                 Builder&lt;Object&gt; builder = (Builder&lt;Object&gt;)value;
 773                 updateValue(builder.build());
 774 
 775                 processValue();
 776             } else {
 777                 processInstancePropertyAttributes();
 778             }
 779 
 780             processEventHandlerAttributes();
 781 
 782             // Process static property attributes
 783             if (staticPropertyAttributes.size() &gt; 0) {
 784                 for (Attribute attribute : staticPropertyAttributes) {
 785                     processPropertyAttribute(attribute);
 786                 }
 787             }
 788 
 789             // Process static property elements
 790             if (staticPropertyElements.size() &gt; 0) {
 791                 for (PropertyElement element : staticPropertyElements) {
 792                     BeanAdapter.put(value, element.sourceType, element.name, element.value);
 793                 }
 794             }
 795 
 796             if (parent != null) {
 797                 if (parent.isCollection()) {
 798                     parent.add(value);
 799                 } else {
 800                     parent.set(value);
 801                 }
 802             }
 803         }
 804 
 805         private Object getListValue(Element parent, String listPropertyName, Object value) {
 806             // If possible, coerce the value to the list item type
 807             if (parent.isTyped()) {
 808                 Type listType = parent.getValueAdapter().getGenericType(listPropertyName);
 809 
 810                 if (listType != null) {
 811                     Type itemType = BeanAdapter.getGenericListItemType(listType);
 812 
 813                     if (itemType instanceof ParameterizedType) {
 814                         itemType = ((ParameterizedType)itemType).getRawType();
 815                     }
 816 
 817                     value = BeanAdapter.coerce(value, (Class&lt;?&gt;)itemType);
 818                 }
 819             }
 820 
 821             return value;
 822         }
 823 
 824         private void processValue() throws LoadException {
 825             // If this is the root element, update the value
 826             if (parent == null) {
 827                 root = value;
 828 
 829                 // checking version of fx namespace - throw exception if not supported
 830                 String fxNSURI = xmlStreamReader.getNamespaceContext().getNamespaceURI(&quot;fx&quot;);
 831                 if (fxNSURI != null) {
 832                     String fxVersion = fxNSURI.substring(fxNSURI.lastIndexOf(&quot;/&quot;) + 1);
 833                     if (compareJFXVersions(FX_NAMESPACE_VERSION, fxVersion) &lt; 0) {
 834                         throw constructLoadException(&quot;Loading FXML document of version &quot; +
 835                                 fxVersion + &quot; by JavaFX runtime supporting version &quot; + FX_NAMESPACE_VERSION);
 836                     }
 837                 }
 838 
 839                 // checking the version JavaFX API - print warning if not supported
 840                 String defaultNSURI = xmlStreamReader.getNamespaceContext().getNamespaceURI(&quot;&quot;);
 841                 if (defaultNSURI != null) {
 842                     String nsVersion = defaultNSURI.substring(defaultNSURI.lastIndexOf(&quot;/&quot;) + 1);
 843                     if (compareJFXVersions(JAVAFX_VERSION, nsVersion) &lt; 0) {
 844                         Logging.getJavaFXLogger().warning(&quot;Loading FXML document with JavaFX API of version &quot; +
 845                                 nsVersion + &quot; by JavaFX runtime of version &quot; + JAVAFX_VERSION);
 846                     }
 847                 }
 848             }
 849 
 850             // Add the value to the namespace
 851             if (fx_id != null) {
 852                 namespace.put(fx_id, value);
 853 
 854                 // If the value defines an ID property, set it
 855                 IDProperty idProperty = value.getClass().getAnnotation(IDProperty.class);
 856 
 857                 if (idProperty != null) {
 858                     Map&lt;String, Object&gt; properties = getProperties();
 859                     // set fx:id property value to Node.id only if Node.id was not
 860                     // already set when processing start element attributes
 861                     if (properties.get(idProperty.value()) == null) {
 862                         properties.put(idProperty.value(), fx_id);
 863                     }
 864                 }
 865 
 866                 // Set the controller field value
 867                 injectFields(fx_id, value);
 868             }
 869         }
 870 
 871         @Override
 872         @SuppressWarnings(&quot;unchecked&quot;)
 873         public void processCharacters() throws LoadException {
 874             Class&lt;?&gt; type = value.getClass();
 875             DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);
 876 
 877             // If the default property is a read-only list, add the value to it;
 878             // otherwise, set the value as the default property
 879             if (defaultProperty != null) {
 880                 String text = xmlStreamReader.getText();
 881                 text = extraneousWhitespacePattern.matcher(text).replaceAll(&quot; &quot;);
 882 
 883                 String defaultPropertyName = defaultProperty.value();
 884                 BeanAdapter valueAdapter = getValueAdapter();
 885 
 886                 if (valueAdapter.isReadOnly(defaultPropertyName)
 887                     &amp;&amp; List.class.isAssignableFrom(valueAdapter.getType(defaultPropertyName))) {
 888                     List&lt;Object&gt; list = (List&lt;Object&gt;)valueAdapter.get(defaultPropertyName);
 889                     list.add(getListValue(this, defaultPropertyName, text));
 890                 } else {
 891                     valueAdapter.put(defaultPropertyName, text.trim());
 892                 }
 893             } else {
 894                 throw constructLoadException(type.getName() + &quot; does not have a default property.&quot;);
 895             }
 896         }
 897 
 898         @Override
 899         public void processAttribute(String prefix, String localName, String value)
 900             throws IOException{
 901             if (prefix != null
 902                 &amp;&amp; prefix.equals(FX_NAMESPACE_PREFIX)) {
 903                 if (localName.equals(FX_ID_ATTRIBUTE)) {
 904                     // Verify that ID is a valid identifier
 905                     if (value.equals(NULL_KEYWORD)) {
 906                         throw constructLoadException(&quot;Invalid identifier.&quot;);
 907                     }
 908 
 909                     for (int i = 0, n = value.length(); i &lt; n; i++) {
 910                         if (!Character.isJavaIdentifierPart(value.charAt(i))) {
 911                             throw constructLoadException(&quot;Invalid identifier.&quot;);
 912                         }
 913                     }
 914 
 915                     fx_id = value;
 916 
 917                 } else if (localName.equals(FX_CONTROLLER_ATTRIBUTE)) {
 918                     if (current.parent != null) {
 919                         throw constructLoadException(FX_NAMESPACE_PREFIX + &quot;:&quot; + FX_CONTROLLER_ATTRIBUTE
 920                             + &quot; can only be applied to root element.&quot;);
 921                     }
 922 
 923                     if (controller != null) {
 924                         throw constructLoadException(&quot;Controller value already specified.&quot;);
 925                     }
 926 
 927                     if (!staticLoad) {
 928                         Class&lt;?&gt; type;
 929                         try {
 930                             type = getClassLoader().loadClass(value);
 931                         } catch (ClassNotFoundException exception) {
 932                             throw constructLoadException(exception);
 933                         }
 934 
 935                         try {
 936                             if (controllerFactory == null) {
 937                                 ReflectUtil.checkPackageAccess(type);
 938                                 setController(type.newInstance());
 939                             } else {
 940                                 setController(controllerFactory.call(type));
 941                             }
 942                         } catch (InstantiationException exception) {
 943                             throw constructLoadException(exception);
 944                         } catch (IllegalAccessException exception) {
 945                             throw constructLoadException(exception);
 946                         }
 947                     }
 948                 } else {
 949                     throw constructLoadException(&quot;Invalid attribute.&quot;);
 950                 }
 951             } else {
 952                 super.processAttribute(prefix, localName, value);
 953             }
 954         }
 955 
 956         public abstract Object constructValue() throws IOException;
 957     }
 958 
 959     // Element representing a class instance
 960     private class InstanceDeclarationElement extends ValueElement {
 961         public Class&lt;?&gt; type;
 962 
 963         public String constant = null;
 964         public String factory = null;
 965 
 966         public InstanceDeclarationElement(Class&lt;?&gt; type) throws LoadException {
 967             this.type = type;
 968         }
 969 
 970         @Override
 971         public void processAttribute(String prefix, String localName, String value)
 972             throws IOException {
 973             if (prefix != null
 974                 &amp;&amp; prefix.equals(FX_NAMESPACE_PREFIX)) {
 975                 if (localName.equals(FX_VALUE_ATTRIBUTE)) {
 976                     this.value = value;
 977                 } else if (localName.equals(FX_CONSTANT_ATTRIBUTE)) {
 978                     constant = value;
 979                 } else if (localName.equals(FX_FACTORY_ATTRIBUTE)) {
 980                     factory = value;
 981                 } else {
 982                     super.processAttribute(prefix, localName, value);
 983                 }
 984             } else {
 985                 super.processAttribute(prefix, localName, value);
 986             }
 987         }
 988 
 989         @Override
 990         public Object constructValue() throws IOException {
 991             Object value;
 992             if (this.value != null) {
 993                 value = BeanAdapter.coerce(this.value, type);
 994             } else if (constant != null) {
 995                 value = BeanAdapter.getConstantValue(type, constant);
 996             } else if (factory != null) {
 997                 Method factoryMethod;
 998                 try {
 999                     factoryMethod = MethodUtil.getMethod(type, factory, new Class[] {});
1000                 } catch (NoSuchMethodException exception) {
1001                     throw constructLoadException(exception);
1002                 }
1003 
1004                 try {
1005                     value = MethodHelper.invoke(factoryMethod, null, new Object [] {});
1006                 } catch (IllegalAccessException exception) {
1007                     throw constructLoadException(exception);
1008                 } catch (InvocationTargetException exception) {
1009                     throw constructLoadException(exception);
1010                 }
1011             } else {
1012                 value = (builderFactory == null) ? null : builderFactory.getBuilder(type);
1013 
1014                 if (value == null) {
1015                     value = DEFAULT_BUILDER_FACTORY.getBuilder(type);
1016                 }
1017 
1018                 if (value == null) {
1019                     try {
1020                         ReflectUtil.checkPackageAccess(type);
1021                         value = type.newInstance();
1022                     } catch (InstantiationException exception) {
1023                         throw constructLoadException(exception);
1024                     } catch (IllegalAccessException exception) {
1025                         throw constructLoadException(exception);
1026                     }
1027                 }
1028             }
1029 
1030             return value;
1031         }
1032     }
1033 
1034     // Element representing an unknown type
1035     private class UnknownTypeElement extends ValueElement {
1036         // Map type representing an unknown value
1037         @DefaultProperty(&quot;items&quot;)
1038         public class UnknownValueMap extends AbstractMap&lt;String, Object&gt; {
1039             private ArrayList&lt;?&gt; items = new ArrayList&lt;Object&gt;();
1040             private HashMap&lt;String, Object&gt; values = new HashMap&lt;String, Object&gt;();
1041 
1042             @Override
1043             public Object get(Object key) {
1044                 if (key == null) {
1045                     throw new NullPointerException();
1046                 }
1047 
1048                 return (key.equals(getClass().getAnnotation(DefaultProperty.class).value())) ?
1049                     items : values.get(key);
1050             }
1051 
1052             @Override
1053             public Object put(String key, Object value) {
1054                 if (key == null) {
1055                     throw new NullPointerException();
1056                 }
1057 
1058                 if (key.equals(getClass().getAnnotation(DefaultProperty.class).value())) {
1059                     throw new IllegalArgumentException();
1060                 }
1061 
1062                 return values.put(key, value);
1063             }
1064 
1065             @Override
1066             public Set&lt;Entry&lt;String, Object&gt;&gt; entrySet() {
1067                 return Collections.emptySet();
1068             }
1069         }
1070 
1071         @Override
1072         public void processEndElement() throws IOException {
1073             // No-op
1074         }
1075 
1076         @Override
1077         public Object constructValue() throws LoadException {
1078             return new UnknownValueMap();
1079         }
1080     }
1081 
1082     // Element representing an include
1083     private class IncludeElement extends ValueElement {
1084         public String source = null;
1085         public ResourceBundle resources = FXMLLoader.this.resources;
1086         public Charset charset = FXMLLoader.this.charset;
1087 
1088         @Override
1089         public void processAttribute(String prefix, String localName, String value)
1090             throws IOException {
1091             if (prefix == null) {
1092                 if (localName.equals(INCLUDE_SOURCE_ATTRIBUTE)) {
1093                     if (loadListener != null) {
1094                         loadListener.readInternalAttribute(localName, value);
1095                     }
1096 
1097                     source = value;
1098                 } else if (localName.equals(INCLUDE_RESOURCES_ATTRIBUTE)) {
1099                     if (loadListener != null) {
1100                         loadListener.readInternalAttribute(localName, value);
1101                     }
1102 
1103                     resources = ResourceBundle.getBundle(value, Locale.getDefault(),
1104                             FXMLLoader.this.resources.getClass().getClassLoader());
1105                 } else if (localName.equals(INCLUDE_CHARSET_ATTRIBUTE)) {
1106                     if (loadListener != null) {
1107                         loadListener.readInternalAttribute(localName, value);
1108                     }
1109 
1110                     charset = Charset.forName(value);
1111                 } else {
1112                     super.processAttribute(prefix, localName, value);
1113                 }
1114             } else {
1115                 super.processAttribute(prefix, localName, value);
1116             }
1117         }
1118 
1119         @Override
1120         public Object constructValue() throws IOException {
1121             if (source == null) {
1122                 throw constructLoadException(INCLUDE_SOURCE_ATTRIBUTE + &quot; is required.&quot;);
1123             }
1124 
1125             URL location;
1126             final ClassLoader cl = getClassLoader();
1127             if (source.charAt(0) == &#39;/&#39;) {
1128             // FIXME: JIGSAW -- use Class.getResourceAsStream if resource is in a module
1129                 location = cl.getResource(source.substring(1));
1130                 if (location == null) {
1131                     throw constructLoadException(&quot;Cannot resolve path: &quot; + source);
1132                 }
1133             } else {
1134                 if (FXMLLoader.this.location == null) {
1135                     throw constructLoadException(&quot;Base location is undefined.&quot;);
1136                 }
1137 
1138                 location = new URL(FXMLLoader.this.location, source);
1139             }
1140 
1141             FXMLLoader fxmlLoader = new FXMLLoader(location, resources,
1142                 builderFactory, controllerFactory, charset,
1143                 loaders);
1144             fxmlLoader.parentLoader = FXMLLoader.this;
1145 
1146             if (isCyclic(FXMLLoader.this, fxmlLoader)) {
1147                 throw new IOException(
1148                         String.format(
1149                         &quot;Including \&quot;%s\&quot; in \&quot;%s\&quot; created cyclic reference.&quot;,
1150                         fxmlLoader.location.toExternalForm(),
1151                         FXMLLoader.this.location.toExternalForm()));
1152             }
1153             fxmlLoader.setClassLoader(cl);
1154             fxmlLoader.setStaticLoad(staticLoad);
1155 
1156             Object value = fxmlLoader.loadImpl(callerClass);
1157 
1158             if (fx_id != null) {
1159                 String id = this.fx_id + CONTROLLER_SUFFIX;
1160                 Object controller = fxmlLoader.getController();
1161 
1162                 namespace.put(id, controller);
1163                 injectFields(id, controller);
1164             }
1165 
1166             return value;
1167         }
1168     }
1169 
1170     private void injectFields(String fieldName, Object value) throws LoadException {
1171         if (controller != null &amp;&amp; fieldName != null) {
1172             List&lt;Field&gt; fields = controllerAccessor.getControllerFields().get(fieldName);
1173             if (fields != null) {
1174                 try {
1175                     for (Field f : fields) {
1176                         f.set(controller, value);
1177                     }
1178                 } catch (IllegalAccessException exception) {
1179                     throw constructLoadException(exception);
1180                 }
1181             }
1182         }
1183     }
1184 
1185     // Element representing a reference
1186     private class ReferenceElement extends ValueElement {
1187         public String source = null;
1188 
1189         @Override
1190         public void processAttribute(String prefix, String localName, String value)
1191             throws IOException {
1192             if (prefix == null) {
1193                 if (localName.equals(REFERENCE_SOURCE_ATTRIBUTE)) {
1194                     if (loadListener != null) {
1195                         loadListener.readInternalAttribute(localName, value);
1196                     }
1197 
1198                     source = value;
1199                 } else {
1200                     super.processAttribute(prefix, localName, value);
1201                 }
1202             } else {
1203                 super.processAttribute(prefix, localName, value);
1204             }
1205         }
1206 
1207         @Override
1208         public Object constructValue() throws LoadException {
1209             if (source == null) {
1210                 throw constructLoadException(REFERENCE_SOURCE_ATTRIBUTE + &quot; is required.&quot;);
1211             }
1212 
1213             KeyPath path = KeyPath.parse(source);
1214             if (!Expression.isDefined(namespace, path)) {
1215                 throw constructLoadException(&quot;Value \&quot;&quot; + source + &quot;\&quot; does not exist.&quot;);
1216             }
1217 
1218             return Expression.get(namespace, path);
1219         }
1220     }
1221 
1222     // Element representing a copy
1223     private class CopyElement extends ValueElement {
1224         public String source = null;
1225 
1226         @Override
1227         public void processAttribute(String prefix, String localName, String value)
1228             throws IOException {
1229             if (prefix == null) {
1230                 if (localName.equals(COPY_SOURCE_ATTRIBUTE)) {
1231                     if (loadListener != null) {
1232                         loadListener.readInternalAttribute(localName, value);
1233                     }
1234 
1235                     source = value;
1236                 } else {
1237                     super.processAttribute(prefix, localName, value);
1238                 }
1239             } else {
1240                 super.processAttribute(prefix, localName, value);
1241             }
1242         }
1243 
1244         @Override
1245         public Object constructValue() throws LoadException {
1246             if (source == null) {
1247                 throw constructLoadException(COPY_SOURCE_ATTRIBUTE + &quot; is required.&quot;);
1248             }
1249 
1250             KeyPath path = KeyPath.parse(source);
1251             if (!Expression.isDefined(namespace, path)) {
1252                 throw constructLoadException(&quot;Value \&quot;&quot; + source + &quot;\&quot; does not exist.&quot;);
1253             }
1254 
1255             Object sourceValue = Expression.get(namespace, path);
1256             Class&lt;?&gt; sourceValueType = sourceValue.getClass();
1257 
1258             Constructor&lt;?&gt; constructor = null;
1259             try {
1260                 constructor = ConstructorUtil.getConstructor(sourceValueType, new Class[] { sourceValueType });
1261             } catch (NoSuchMethodException exception) {
1262                 // No-op
1263             }
1264 
1265             Object value;
1266             if (constructor != null) {
1267                 try {
1268                     ReflectUtil.checkPackageAccess(sourceValueType);
1269                     value = constructor.newInstance(sourceValue);
1270                 } catch (InstantiationException exception) {
1271                     throw constructLoadException(exception);
1272                 } catch (IllegalAccessException exception) {
1273                     throw constructLoadException(exception);
1274                 } catch (InvocationTargetException exception) {
1275                     throw constructLoadException(exception);
1276                 }
1277             } else {
1278                 throw constructLoadException(&quot;Can&#39;t copy value &quot; + sourceValue + &quot;.&quot;);
1279             }
1280 
1281             return value;
1282         }
1283     }
1284 
1285     // Element representing a predefined root value
1286     private class RootElement extends ValueElement {
1287         public String type = null;
1288 
1289         @Override
1290         public void processAttribute(String prefix, String localName, String value)
1291             throws IOException {
1292             if (prefix == null) {
1293                 if (localName.equals(ROOT_TYPE_ATTRIBUTE)) {
1294                     if (loadListener != null) {
1295                         loadListener.readInternalAttribute(localName, value);
1296                     }
1297 
1298                     type = value;
1299                 } else {
1300                     super.processAttribute(prefix, localName, value);
1301                 }
1302             } else {
1303                 super.processAttribute(prefix, localName, value);
1304             }
1305         }
1306 
1307         @Override
1308         public Object constructValue() throws LoadException {
1309             if (type == null) {
1310                 throw constructLoadException(ROOT_TYPE_ATTRIBUTE + &quot; is required.&quot;);
1311             }
1312 
1313             Class&lt;?&gt; type = getType(this.type);
1314 
1315             if (type == null) {
1316                 throw constructLoadException(this.type + &quot; is not a valid type.&quot;);
1317             }
1318 
1319             Object value;
1320             if (root == null) {
1321                 if (staticLoad) {
1322                     value = (builderFactory == null) ? null : builderFactory.getBuilder(type);
1323 
1324                     if (value == null) {
1325                         value = DEFAULT_BUILDER_FACTORY.getBuilder(type);
1326                     }
1327 
1328                     if (value == null) {
1329                         try {
1330                             ReflectUtil.checkPackageAccess(type);
1331                             value = type.newInstance();
1332                         } catch (InstantiationException exception) {
1333                             throw constructLoadException(exception);
1334                         } catch (IllegalAccessException exception) {
1335                             throw constructLoadException(exception);
1336                         }
1337                     }
1338                     root = value;
1339                 } else {
1340                     throw constructLoadException(&quot;Root hasn&#39;t been set. Use method setRoot() before load.&quot;);
1341                 }
1342             } else {
1343                 if (!type.isAssignableFrom(root.getClass())) {
1344                     throw constructLoadException(&quot;Root is not an instance of &quot;
1345                         + type.getName() + &quot;.&quot;);
1346                 }
1347 
1348                 value = root;
1349             }
1350 
1351             return value;
1352         }
1353     }
1354 
1355     // Element representing a property
1356     private class PropertyElement extends Element {
1357         public final String name;
1358         public final Class&lt;?&gt; sourceType;
1359         public final boolean readOnly;
1360 
1361         public PropertyElement(String name, Class&lt;?&gt; sourceType) throws LoadException {
1362             if (parent == null) {
1363                 throw constructLoadException(&quot;Invalid root element.&quot;);
1364             }
1365 
1366             if (parent.value == null) {
1367                 throw constructLoadException(&quot;Parent element does not support property elements.&quot;);
1368             }
1369 
1370             this.name = name;
1371             this.sourceType = sourceType;
1372 
1373             if (sourceType == null) {
1374                 // The element represents an instance property
1375                 if (name.startsWith(EVENT_HANDLER_PREFIX)) {
1376                     throw constructLoadException(&quot;\&quot;&quot; + name + &quot;\&quot; is not a valid element name.&quot;);
1377                 }
1378 
1379                 Map&lt;String, Object&gt; parentProperties = parent.getProperties();
1380 
1381                 if (parent.isTyped()) {
1382                     readOnly = parent.getValueAdapter().isReadOnly(name);
1383                 } else {
1384                 // If the map already defines a value for the property, assume
1385                     // that it is read-only
1386                     readOnly = parentProperties.containsKey(name);
1387                 }
1388 
1389                 if (readOnly) {
1390                     Object value = parentProperties.get(name);
1391                     if (value == null) {
1392                         throw constructLoadException(&quot;Invalid property.&quot;);
1393                     }
1394 
1395                     updateValue(value);
1396                 }
1397             } else {
1398                 // The element represents a static property
1399                 readOnly = false;
1400             }
1401         }
1402 
1403         @Override
1404         public boolean isCollection() {
1405             return (readOnly) ? super.isCollection() : false;
1406         }
1407 
1408         @Override
1409         public void add(Object element) throws LoadException {
1410             // Coerce the element to the list item type
1411             if (parent.isTyped()) {
1412                 Type listType = parent.getValueAdapter().getGenericType(name);
1413                 element = BeanAdapter.coerce(element, BeanAdapter.getListItemType(listType));
1414             }
1415 
1416             // Add the item to the list
1417             super.add(element);
1418         }
1419 
1420         @Override
1421         public void set(Object value) throws LoadException {
1422             // Update the value
1423             updateValue(value);
1424 
1425             if (sourceType == null) {
1426                 // Apply value to parent element&#39;s properties
1427                 parent.getProperties().put(name, value);
1428             } else {
1429                 if (parent.value instanceof Builder) {
1430                     // Defer evaluation of the property
1431                     parent.staticPropertyElements.add(this);
1432                 } else {
1433                     // Apply the static property value
1434                     BeanAdapter.put(parent.value, sourceType, name, value);
1435                 }
1436             }
1437         }
1438 
1439         @Override
1440         public void processAttribute(String prefix, String localName, String value)
1441             throws IOException {
1442             if (!readOnly) {
1443                 throw constructLoadException(&quot;Attributes are not supported for writable property elements.&quot;);
1444             }
1445 
1446             super.processAttribute(prefix, localName, value);
1447         }
1448 
1449         @Override
1450         public void processEndElement() throws IOException {
1451             super.processEndElement();
1452 
1453             if (readOnly) {
1454                 processInstancePropertyAttributes();
1455                 processEventHandlerAttributes();
1456             }
1457         }
1458 
1459         @Override
1460         public void processCharacters() throws IOException {
1461             String text = xmlStreamReader.getText();
1462             text = extraneousWhitespacePattern.matcher(text).replaceAll(&quot; &quot;).trim();
1463 
1464             if (readOnly) {
1465                 if (isCollection()) {
1466                     add(text);
1467                 } else {
1468                     super.processCharacters();
1469                 }
1470             } else {
1471                 set(text);
1472             }
1473         }
1474     }
1475 
1476     // Element representing an unknown static property
1477     private class UnknownStaticPropertyElement extends Element {
1478         public UnknownStaticPropertyElement() throws LoadException {
1479             if (parent == null) {
1480                 throw constructLoadException(&quot;Invalid root element.&quot;);
1481             }
1482 
1483             if (parent.value == null) {
1484                 throw constructLoadException(&quot;Parent element does not support property elements.&quot;);
1485             }
1486         }
1487 
1488         @Override
1489         public boolean isCollection() {
1490             return false;
1491         }
1492 
1493         @Override
1494         public void set(Object value) {
1495             updateValue(value);
1496         }
1497 
1498         @Override
1499         public void processCharacters() throws IOException {
1500             String text = xmlStreamReader.getText();
1501             text = extraneousWhitespacePattern.matcher(text).replaceAll(&quot; &quot;);
1502 
1503             updateValue(text.trim());
1504         }
1505     }
1506 
1507     // Element representing a script block
1508     private class ScriptElement extends Element {
1509         public String source = null;
1510         public Charset charset = FXMLLoader.this.charset;
1511 
1512         @Override
1513         public boolean isCollection() {
1514             return false;
1515         }
1516 
1517         @Override
1518         public void processStartElement() throws IOException {
1519             super.processStartElement();
1520 
1521             if (source != null &amp;&amp; !staticLoad) {
1522                 int i = source.lastIndexOf(&quot;.&quot;);
1523                 if (i == -1) {
1524                     throw constructLoadException(&quot;Cannot determine type of script \&quot;&quot;
1525                         + source + &quot;\&quot;.&quot;);
1526                 }
1527 
1528                 String extension = source.substring(i + 1);
1529                 ScriptEngine engine;
1530                 final ClassLoader cl = getClassLoader();
1531                 if (scriptEngine != null &amp;&amp; scriptEngine.getFactory().getExtensions().contains(extension)) {
1532                     // If we have a page language and it&#39;s engine supports the extension, use the same engine
1533                     engine = scriptEngine;
1534                 } else {
1535                     ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();
1536                     try {
1537                         Thread.currentThread().setContextClassLoader(cl);
1538                         ScriptEngineManager scriptEngineManager = getScriptEngineManager();
1539                         engine = scriptEngineManager.getEngineByExtension(extension);
1540                     } finally {
1541                         Thread.currentThread().setContextClassLoader(oldLoader);
1542                     }
1543                 }
1544 
1545                 if (engine == null) {
1546                     throw constructLoadException(&quot;Unable to locate scripting engine for&quot;
1547                         + &quot; extension &quot; + extension + &quot;.&quot;);
1548                 }
1549 
1550                 try {
1551                     URL location;
1552                     if (source.charAt(0) == &#39;/&#39;) {
1553                         // FIXME: JIGSAW -- use Class.getResourceAsStream if resource is in a module
1554                         location = cl.getResource(source.substring(1));
1555                     } else {
1556                         if (FXMLLoader.this.location == null) {
1557                             throw constructLoadException(&quot;Base location is undefined.&quot;);
1558                         }
1559 
1560                         location = new URL(FXMLLoader.this.location, source);
1561                     }
1562                     Bindings engineBindings = engine.getBindings(ScriptContext.ENGINE_SCOPE);
1563                     String filename = location.getPath();
1564                     engineBindings.put(engine.FILENAME, filename);
1565 
1566                     InputStreamReader scriptReader = null;
1567                     String script=null;
1568                     try {
1569                         scriptReader = new InputStreamReader(location.openStream(), charset);
1570                         StringBuilder sb = new StringBuilder();
1571                         char[] charBuffer = new char[4096];
1572                         int n;
1573                         do {
1574                           n = scriptReader.read(charBuffer,0,4096);
1575                           if (n &gt; 0) {
1576                               sb.append(new String(charBuffer,0,n));
1577                           }
1578                         } while (n == 4096);
1579                         script = sb.toString();
1580                     } catch (IOException exception) {
1581                         throw constructLoadException(exception);
1582                     } finally {
1583                         if (scriptReader != null) {
1584                             scriptReader.close();
1585                         }
1586                     }
1587                     try {
1588                         if (engine instanceof Compilable &amp;&amp; compileScript) {
1589                             CompiledScript compiledScript = null;
1590                             try {
1591                                 compiledScript=((Compilable) engine).compile(script);
1592                             } catch (ScriptException compileExc) {
1593                                Logging.getJavaFXLogger().warning(filename+&quot;: compiling caused \&quot;&quot;+compileExc+&quot;\&quot;, falling back to evaluating script in uncompiled mode&quot;);
1594                             }
1595                             if (compiledScript != null) {
1596                                compiledScript.eval();
1597                             }
1598                             else {        // fallback to uncompiled mode
1599                                engine.eval(script);
1600                             }
1601                         }
1602                         else {
1603                            engine.eval(script);
1604                         }
1605                     } catch (ScriptException exception) {
1606                         System.err.println(filename+&quot;: caused ScriptException&quot;);
1607                         exception.printStackTrace();
1608                     }
1609                 }
1610                 catch (IOException exception) {
1611                   throw constructLoadException(exception);
1612                 }
1613             }
1614         }
1615 
1616         @Override
1617         public void processEndElement() throws IOException {
1618             super.processEndElement();
1619 
1620             if (value != null &amp;&amp; !staticLoad) {
1621                 // Evaluate the script
1622                 String filename = null;
1623                 try {
1624                     Bindings engineBindings = scriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);
1625                     String script = (String) value;
1626                     filename = location.getPath() + &quot;-script_starting_at_line_&quot;
1627                                        + (getLineNumber() - (int) script.codePoints().filter(c -&gt; c == &#39;\n&#39;).count());
1628                     engineBindings.put(scriptEngine.FILENAME, filename);
1629                     if (scriptEngine instanceof Compilable &amp;&amp; compileScript) {
1630                         CompiledScript compiledScript = null;
1631                         try {
1632                             compiledScript=((Compilable) scriptEngine).compile(script);
1633                         } catch (ScriptException compileExc) {
1634                             Logging.getJavaFXLogger().warning(filename+&quot;: compiling caused \&quot;&quot;+compileExc+&quot;\&quot;, falling back to evaluating script in uncompiled mode&quot;);
1635                         }
1636                         if (compiledScript != null) {
1637                            compiledScript.eval();
1638                         }
1639                         else {        // fallback to uncompiled mode
1640                            scriptEngine.eval(script);
1641                             }
1642                     }
1643                     else {
1644                        scriptEngine.eval(script);
1645                     }
1646                 } catch (ScriptException exception) {
1647                     System.err.println(filename+&quot;: caused ScriptException\n&quot;+exception.getMessage());
1648                 }
1649             }
1650         }
1651 
1652         @Override
1653         public void processCharacters() throws LoadException {
1654             if (source != null) {
1655                 throw constructLoadException(&quot;Script source already specified.&quot;);
1656             }
1657 
1658             if (scriptEngine == null &amp;&amp; !staticLoad) {
1659                 throw constructLoadException(&quot;Page language not specified.&quot;);
1660             }
1661 
1662             updateValue(xmlStreamReader.getText());
1663         }
1664 
1665         @Override
1666         public void processAttribute(String prefix, String localName, String value)
1667             throws IOException {
1668             if (prefix == null
1669                 &amp;&amp; localName.equals(SCRIPT_SOURCE_ATTRIBUTE)) {
1670                 if (loadListener != null) {
1671                     loadListener.readInternalAttribute(localName, value);
1672                 }
1673 
1674                 source = value;
1675             } else if (localName.equals(SCRIPT_CHARSET_ATTRIBUTE)) {
1676                 if (loadListener != null) {
1677                     loadListener.readInternalAttribute(localName, value);
1678                 }
1679 
1680                 charset = Charset.forName(value);
1681             } else {
1682                 throw constructLoadException(prefix == null ? localName : prefix + &quot;:&quot; + localName
1683                     + &quot; is not a valid attribute.&quot;);
1684             }
1685         }
1686     }
1687 
1688     // Element representing a define block
1689     private class DefineElement extends Element {
1690         @Override
1691         public boolean isCollection() {
1692             return true;
1693         }
1694 
1695         @Override
1696         public void add(Object element) {
1697             // No-op
1698         }
1699 
1700         @Override
1701         public void processAttribute(String prefix, String localName, String value)
1702             throws LoadException{
1703             throw constructLoadException(&quot;Element does not support attributes.&quot;);
1704         }
1705     }
1706 
1707     // Class representing an attribute of an element
1708     private static class Attribute {
1709         public final String name;
1710         public final Class&lt;?&gt; sourceType;
1711         public final String value;
1712 
1713         public Attribute(String name, Class&lt;?&gt; sourceType, String value) {
1714             this.name = name;
1715             this.sourceType = sourceType;
1716             this.value = value;
1717         }
1718     }
1719 
1720     // Event handler that delegates to a method defined by the controller object
1721     private static class ControllerMethodEventHandler&lt;T extends Event&gt; implements EventHandler&lt;T&gt; {
1722         private final MethodHandler handler;
1723 
1724         public ControllerMethodEventHandler(MethodHandler handler) {
1725             this.handler = handler;
1726         }
1727 
1728         @Override
1729         public void handle(T event) {
1730             handler.invoke(event);
1731         }
1732     }
1733 
1734     // Event handler implemented in script code
1735     private static class ScriptEventHandler implements EventHandler&lt;Event&gt; {
1736         public final String script;
1737         public final ScriptEngine scriptEngine;
1738         public final String filename;
1739         public CompiledScript compiledScript;
1740         public boolean isCompiled=false;
1741 
1742         public ScriptEventHandler(String script, ScriptEngine scriptEngine, String filename) {
1743             this.script = script;
1744             this.scriptEngine = scriptEngine;
1745             this.filename = filename;
1746             if (scriptEngine instanceof Compilable  &amp;&amp; compileScript) {
1747                try {
1748                   // supply the filename to the scriptEngine engine scope Bindings in case it is needed for compilation
1749                   scriptEngine.getBindings(ScriptContext.ENGINE_SCOPE).put(scriptEngine.FILENAME, filename);
1750                   this.compiledScript = ((Compilable) scriptEngine).compile(script);
1751                   this.isCompiled = true;
1752                } catch (ScriptException compileExc){
1753                     Logging.getJavaFXLogger().warning(filename+&quot;: compiling caused \&quot;&quot;+compileExc+&quot;\&quot;, falling back to evaluating script in uncompiled mode&quot;);
1754                }
1755             }
1756         }
1757 
1758         @Override
1759         public void handle(Event event) {
1760             // Don&#39;t pollute the page namespace with values defined in the script
1761             Bindings engineBindings = scriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);
1762             Bindings localBindings = scriptEngine.createBindings();
1763             localBindings.putAll(engineBindings);
1764             localBindings.put(EVENT_KEY, event);
1765             localBindings.put(scriptEngine.ARGV, new Object[]{event});
1766             localBindings.put(scriptEngine.FILENAME, filename);
1767             // Execute the script
1768             try {
1769                 if (isCompiled) {
1770                    compiledScript.eval(localBindings);
1771                 }
1772                 else {
1773                    scriptEngine.eval(script, localBindings);
1774                 }
1775             } catch (ScriptException exception){
1776                 throw new RuntimeException(filename+&quot;: caused ScriptException&quot;, exception);
1777             }
1778         }
1779     }
1780 
1781     // Observable list change listener
1782     private static class ObservableListChangeAdapter implements ListChangeListener {
1783         private final MethodHandler handler;
1784 
1785         public ObservableListChangeAdapter(MethodHandler handler) {
1786             this.handler = handler;
1787         }
1788 
1789         @Override
1790         @SuppressWarnings(&quot;unchecked&quot;)
1791         public void onChanged(Change change) {
1792             if (handler != null) {
1793                 handler.invoke(change);
1794             }
1795         }
1796     }
1797 
1798     // Observable map change listener
1799     private static class ObservableMapChangeAdapter implements MapChangeListener {
1800         public final MethodHandler handler;
1801 
1802         public ObservableMapChangeAdapter(MethodHandler handler) {
1803             this.handler = handler;
1804         }
1805 
1806         @Override
1807         public void onChanged(Change change) {
1808             if (handler != null) {
1809                 handler.invoke(change);
1810             }
1811         }
1812     }
1813 
1814     // Observable set change listener
1815     private static class ObservableSetChangeAdapter implements SetChangeListener {
1816         public final MethodHandler handler;
1817 
1818         public ObservableSetChangeAdapter(MethodHandler handler) {
1819             this.handler = handler;
1820         }
1821 
1822         @Override
1823         public void onChanged(Change change) {
1824             if (handler != null) {
1825                 handler.invoke(change);
1826             }
1827         }
1828     }
1829 
1830     // Property model change listener
1831     private static class PropertyChangeAdapter implements ChangeListener&lt;Object&gt; {
1832         public final MethodHandler handler;
1833 
1834         public PropertyChangeAdapter(MethodHandler handler) {
1835             this.handler = handler;
1836         }
1837 
1838         @Override
1839         public void changed(ObservableValue&lt;? extends Object&gt; observable, Object oldValue, Object newValue) {
1840             handler.invoke(observable, oldValue, newValue);
1841         }
1842     }
1843 
1844     private static class MethodHandler {
1845         private final Object controller;
1846         private final Method method;
1847         private final SupportedType type;
1848 
1849         private MethodHandler(Object controller, Method method, SupportedType type) {
1850             this.method = method;
1851             this.controller = controller;
1852             this.type = type;
1853         }
1854 
1855         public void invoke(Object... params) {
1856             try {
1857                 if (type != SupportedType.PARAMETERLESS) {
1858                     MethodHelper.invoke(method, controller, params);
1859                 } else {
1860                     MethodHelper.invoke(method, controller, new Object[] {});
1861                 }
1862             } catch (InvocationTargetException exception) {
1863                 throw new RuntimeException(exception);
1864             } catch (IllegalAccessException exception) {
1865                 throw new RuntimeException(exception);
1866             }
1867         }
1868     }
1869 
1870     private URL location;
1871     private ResourceBundle resources;
1872 
1873     private ObservableMap&lt;String, Object&gt; namespace = FXCollections.observableHashMap();
1874 
1875     private Object root = null;
1876     private Object controller = null;
1877 
1878     private BuilderFactory builderFactory;
1879     private Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory;
1880     private Charset charset;
1881 
1882     private final LinkedList&lt;FXMLLoader&gt; loaders;
1883 
1884     private ClassLoader classLoader = null;
1885     private boolean staticLoad = false;
1886     private LoadListener loadListener = null;
1887 
1888     private FXMLLoader parentLoader;
1889 
1890     private XMLStreamReader xmlStreamReader = null;
1891     private Element current = null;
1892 
1893     private ScriptEngine scriptEngine = null;
1894     private static boolean compileScript = true;
1895 
1896     private List&lt;String&gt; packages = new LinkedList&lt;String&gt;();
1897     private Map&lt;String, Class&lt;?&gt;&gt; classes = new HashMap&lt;String, Class&lt;?&gt;&gt;();
1898 
1899     private ScriptEngineManager scriptEngineManager = null;
1900 
1901     private static ClassLoader defaultClassLoader = null;
1902 
1903     private static final Pattern extraneousWhitespacePattern = Pattern.compile(&quot;\\s+&quot;);
1904 
1905     private static BuilderFactory DEFAULT_BUILDER_FACTORY = new JavaFXBuilderFactory();
1906 
1907     /**
1908      * The character set used when character set is not explicitly specified.
1909      */
1910     public static final String DEFAULT_CHARSET_NAME = &quot;UTF-8&quot;;
1911 
1912     /**
1913      * The tag name of language processing instruction.
1914      */
1915     public static final String LANGUAGE_PROCESSING_INSTRUCTION = &quot;language&quot;;
1916     /**
1917      * The tag name of import processing instruction.
1918      */
1919     public static final String IMPORT_PROCESSING_INSTRUCTION = &quot;import&quot;;
1920 
1921     /**
1922      * The tag name of the compile processing instruction.
1923      * @since 15
1924      */
1925     public static final String COMPILE_PROCESSING_INSTRUCTION = &quot;compile&quot;;
1926 
1927     /**
1928      * Prefix of &#39;fx&#39; namespace.
1929      */
1930     public static final String FX_NAMESPACE_PREFIX = &quot;fx&quot;;
1931     /**
1932      * The name of fx:controller attribute of a root.
1933      */
1934     public static final String FX_CONTROLLER_ATTRIBUTE = &quot;controller&quot;;
1935     /**
1936      * The name of fx:id attribute.
1937      */
1938     public static final String FX_ID_ATTRIBUTE = &quot;id&quot;;
1939     /**
1940      * The name of fx:value attribute.
1941      */
1942     public static final String FX_VALUE_ATTRIBUTE = &quot;value&quot;;
1943     /**
1944      * The tag name of &#39;fx:constant&#39;.
1945      * @since JavaFX 2.2
1946      */
1947     public static final String FX_CONSTANT_ATTRIBUTE = &quot;constant&quot;;
1948     /**
1949      * The name of &#39;fx:factory&#39; attribute.
1950      */
1951     public static final String FX_FACTORY_ATTRIBUTE = &quot;factory&quot;;
1952 
1953     /**
1954      * The tag name of {@literal &lt;fx:include&gt;}.
1955      */
1956     public static final String INCLUDE_TAG = &quot;include&quot;;
1957     /**
1958      * The {@literal &lt;fx:include&gt;} &#39;source&#39; attribute.
1959      */
1960     public static final String INCLUDE_SOURCE_ATTRIBUTE = &quot;source&quot;;
1961     /**
1962      * The {@literal &lt;fx:include&gt;} &#39;resources&#39; attribute.
1963      */
1964     public static final String INCLUDE_RESOURCES_ATTRIBUTE = &quot;resources&quot;;
1965     /**
1966      * The {@literal &lt;fx:include&gt;} &#39;charset&#39; attribute.
1967      */
1968     public static final String INCLUDE_CHARSET_ATTRIBUTE = &quot;charset&quot;;
1969 
1970     /**
1971      * The tag name of {@literal &lt;fx:script&gt;}.
1972      */
1973     public static final String SCRIPT_TAG = &quot;script&quot;;
1974     /**
1975      * The {@literal &lt;fx:script&gt;} &#39;source&#39; attribute.
1976      */
1977     public static final String SCRIPT_SOURCE_ATTRIBUTE = &quot;source&quot;;
1978     /**
1979      * The {@literal &lt;fx:script&gt;} &#39;charset&#39; attribute.
1980      */
1981     public static final String SCRIPT_CHARSET_ATTRIBUTE = &quot;charset&quot;;
1982 
1983     /**
1984      * The tag name of {@literal &lt;fx:define&gt;}.
1985      */
1986     public static final String DEFINE_TAG = &quot;define&quot;;
1987 
1988     /**
1989      * The tag name of {@literal &lt;fx:reference&gt;}.
1990      */
1991     public static final String REFERENCE_TAG = &quot;reference&quot;;
1992     /**
1993      * The {@literal &lt;fx:reference&gt;} &#39;source&#39; attribute.
1994      */
1995     public static final String REFERENCE_SOURCE_ATTRIBUTE = &quot;source&quot;;
1996 
1997     /**
1998      * The tag name of {@literal &lt;fx:root&gt;}.
1999      * @since JavaFX 2.2
2000      */
2001     public static final String ROOT_TAG = &quot;root&quot;;
2002     /**
2003      * The {@literal &lt;fx:root&gt;} &#39;type&#39; attribute.
2004      * @since JavaFX 2.2
2005      */
2006     public static final String ROOT_TYPE_ATTRIBUTE = &quot;type&quot;;
2007 
2008     /**
2009      * The tag name of {@literal &lt;fx:copy&gt;}.
2010      */
2011     public static final String COPY_TAG = &quot;copy&quot;;
2012     /**
2013      * The {@literal &lt;fx:copy&gt;} &#39;source&#39; attribute.
2014      */
2015     public static final String COPY_SOURCE_ATTRIBUTE = &quot;source&quot;;
2016 
2017     /**
2018      * The prefix of event handler attributes.
2019      */
2020     public static final String EVENT_HANDLER_PREFIX = &quot;on&quot;;
2021     /**
2022      * The name of the Event object in event handler scripts.
2023      */
2024     public static final String EVENT_KEY = &quot;event&quot;;
2025     /**
2026      * Suffix for property change/invalidation handlers.
2027      */
2028     public static final String CHANGE_EVENT_HANDLER_SUFFIX = &quot;Change&quot;;
2029     private static final String COLLECTION_HANDLER_NAME = EVENT_HANDLER_PREFIX + CHANGE_EVENT_HANDLER_SUFFIX;
2030 
2031     /**
2032      * Value that represents &#39;null&#39;.
2033      */
2034     public static final String NULL_KEYWORD = &quot;null&quot;;
2035 
2036     /**
2037      * Escape prefix for escaping special characters inside attribute values.
2038      * Serves as an escape for {@link #ESCAPE_PREFIX}, {@link #RELATIVE_PATH_PREFIX},
2039      * {@link #RESOURCE_KEY_PREFIX}, {@link #EXPRESSION_PREFIX},
2040      * {@link #BI_DIRECTIONAL_BINDING_PREFIX}
2041      * @since JavaFX 2.1
2042      */
2043     public static final String ESCAPE_PREFIX = &quot;\\&quot;;
2044     /**
2045      * Prefix for relative location resolution.
2046      */
2047     public static final String RELATIVE_PATH_PREFIX = &quot;@&quot;;
2048     /**
2049      * Prefix for resource resolution.
2050      */
2051     public static final String RESOURCE_KEY_PREFIX = &quot;%&quot;;
2052     /**
2053      * Prefix for (variable) expression resolution.
2054      */
2055     public static final String EXPRESSION_PREFIX = &quot;$&quot;;
2056     /**
2057      * Prefix for binding expression resolution.
2058      */
2059     public static final String BINDING_EXPRESSION_PREFIX = &quot;${&quot;;
2060     /**
2061      * Suffix for binding expression resolution.
2062      */
2063     public static final String BINDING_EXPRESSION_SUFFIX = &quot;}&quot;;
2064 
2065     /**
2066      * Prefix for bidirectional-binding expression resolution.
2067      * @since JavaFX 2.1
2068      */
2069     public static final String BI_DIRECTIONAL_BINDING_PREFIX = &quot;#{&quot;;
2070     /**
2071      * Suffix for bidirectional-binding expression resolution.
2072      * @since JavaFX 2.1
2073      */
2074     public static final String BI_DIRECTIONAL_BINDING_SUFFIX = &quot;}&quot;;
2075 
2076     /**
2077      * Delimiter for arrays as values.
2078      * @since JavaFX 2.1
2079      */
2080     public static final String ARRAY_COMPONENT_DELIMITER = &quot;,&quot;;
2081 
2082     /**
2083      * A key for location URL in namespace map.
2084      * @see #getNamespace()
2085      * @since JavaFX 2.2
2086      */
2087     public static final String LOCATION_KEY = &quot;location&quot;;
2088     /**
2089      * A key for ResourceBundle in namespace map.
2090      * @see #getNamespace()
2091      * @since JavaFX 2.2
2092      */
2093     public static final String RESOURCES_KEY = &quot;resources&quot;;
2094 
2095     /**
2096      * Prefix for controller method resolution.
2097      */
2098     public static final String CONTROLLER_METHOD_PREFIX = &quot;#&quot;;
2099     /**
2100      * A key for controller in namespace map.
2101      * @see #getNamespace()
2102      * @since JavaFX 2.1
2103      */
2104     public static final String CONTROLLER_KEYWORD = &quot;controller&quot;;
2105     /**
2106      * A suffix for controllers of included fxml files.
2107      * The full key is stored in namespace map.
2108      * @see #getNamespace()
2109      * @since JavaFX 2.2
2110      */
2111     public static final String CONTROLLER_SUFFIX = &quot;Controller&quot;;
2112 
2113     /**
2114      * The name of initialize method.
2115      * @since JavaFX 2.2
2116      */
2117     public static final String INITIALIZE_METHOD_NAME = &quot;initialize&quot;;
2118 
2119     /**
2120      * Contains the current javafx version.
2121      * @since JavaFX 8.0
2122      */
2123     public static final String JAVAFX_VERSION;
2124 
2125     /**
2126      * Contains the current fx namepsace version.
2127      * @since JavaFX 8.0
2128      */
2129     public static final String FX_NAMESPACE_VERSION = &quot;1&quot;;
2130 
2131     static {
2132         JAVAFX_VERSION = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {
2133             @Override
2134             public String run() {
2135                 return System.getProperty(&quot;javafx.version&quot;);
2136             }
2137         });
2138 
2139         FXMLLoaderHelper.setFXMLLoaderAccessor(new FXMLLoaderHelper.FXMLLoaderAccessor() {
2140             @Override
2141             public void setStaticLoad(FXMLLoader fxmlLoader, boolean staticLoad) {
2142                 fxmlLoader.setStaticLoad(staticLoad);
2143             }
2144         });
2145     }
2146 
2147     /**
2148      * Creates a new FXMLLoader instance.
2149      */
2150     public FXMLLoader() {
2151         this((URL)null);
2152     }
2153 
2154     /**
2155      * Creates a new FXMLLoader instance.
2156      *
2157      * @param location the location used to resolve relative path attribute values
2158      * @since JavaFX 2.1
2159      */
2160     public FXMLLoader(URL location) {
2161         this(location, null);
2162     }
2163 
2164     /**
2165      * Creates a new FXMLLoader instance.
2166      *
2167      * @param location the location used to resolve relative path attribute values
2168      * @param resources the resources used to resolve resource key attribute values
2169      * @since JavaFX 2.1
2170      */
2171     public FXMLLoader(URL location, ResourceBundle resources) {
2172         this(location, resources, null);
2173     }
2174 
2175     /**
2176      * Creates a new FXMLLoader instance.
2177      *
2178      * @param location the location used to resolve relative path attribute values
2179      * @param resources resources used to resolve resource key attribute values
2180      * @param builderFactory the builder factory used by this loader
2181      * @since JavaFX 2.1
2182      */
2183     public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory) {
2184         this(location, resources, builderFactory, null);
2185     }
2186 
2187     /**
2188      * Creates a new FXMLLoader instance.
2189      *
2190      * @param location the location used to resolve relative path attribute values
2191      * @param resources resources used to resolve resource key attribute values
2192      * @param builderFactory the builder factory used by this loader
2193      * @param controllerFactory the controller factory used by this loader
2194      * @since JavaFX 2.1
2195      */
2196     public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
2197         Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory) {
2198         this(location, resources, builderFactory, controllerFactory, Charset.forName(DEFAULT_CHARSET_NAME));
2199     }
2200 
2201     /**
2202      * Creates a new FXMLLoader instance.
2203      *
2204      * @param charset the character set used by this loader
2205      */
2206     public FXMLLoader(Charset charset) {
2207         this(null, null, null, null, charset);
2208     }
2209 
2210     /**
2211      * Creates a new FXMLLoader instance.
2212      *
2213      * @param location the location used to resolve relative path attribute values
2214      * @param resources resources used to resolve resource key attribute values
2215      * @param builderFactory the builder factory used by this loader
2216      * @param controllerFactory the controller factory used by this loader
2217      * @param charset the character set used by this loader
2218      * @since JavaFX 2.1
2219      */
2220     public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
2221         Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory, Charset charset) {
2222         this(location, resources, builderFactory, controllerFactory, charset,
2223             new LinkedList&lt;FXMLLoader&gt;());
2224     }
2225 
2226     /**
2227      * Creates a new FXMLLoader instance.
2228      *
2229      * @param location the location used to resolve relative path attribute values
2230      * @param resources resources used to resolve resource key attribute values
2231      * @param builderFactory the builder factory used by this loader
2232      * @param controllerFactory the controller factory used by this loader
2233      * @param charset the character set used by this loader
2234      * @param loaders list of loaders
2235      * @since JavaFX 2.1
2236      */
2237     public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
2238         Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory, Charset charset,
2239         LinkedList&lt;FXMLLoader&gt; loaders) {
2240         setLocation(location);
2241         setResources(resources);
2242         setBuilderFactory(builderFactory);
2243         setControllerFactory(controllerFactory);
2244         setCharset(charset);
2245 
2246         this.loaders = new LinkedList(loaders);
2247     }
2248 
2249     /**
2250      * Returns the location used to resolve relative path attribute values.
2251      * @return the location used to resolve relative path attribute values
2252      */
2253     public URL getLocation() {
2254         return location;
2255     }
2256 
2257     /**
2258      * Sets the location used to resolve relative path attribute values.
2259      *
2260      * @param location the location
2261      */
2262     public void setLocation(URL location) {
2263         this.location = location;
2264     }
2265 
2266     /**
2267      * Returns the resources used to resolve resource key attribute values.
2268      * @return the resources used to resolve resource key attribute values
2269      */
2270     public ResourceBundle getResources() {
2271         return resources;
2272     }
2273 
2274     /**
2275      * Sets the resources used to resolve resource key attribute values.
2276      *
2277      * @param resources the resources
2278      */
2279     public void setResources(ResourceBundle resources) {
2280         this.resources = resources;
2281     }
2282 
2283     /**
2284      * Returns the namespace used by this loader.
2285      * @return the namespace
2286      */
2287     public ObservableMap&lt;String, Object&gt; getNamespace() {
2288         return namespace;
2289     }
2290 
2291     /**
2292      * Returns the root of the object hierarchy.
2293      * @param &lt;T&gt; the type of the root object
2294      * @return the root of the object hierarchy
2295      */
2296     @SuppressWarnings(&quot;unchecked&quot;)
2297     public &lt;T&gt; T getRoot() {
2298         return (T)root;
2299     }
2300 
2301     /**
2302      * Sets the root of the object hierarchy. The value passed to this method
2303      * is used as the value of the {@code &lt;fx:root&gt;} tag. This method
2304      * must be called prior to loading the document when using
2305      * {@code &lt;fx:root&gt;}.
2306      *
2307      * @param root the root of the object hierarchy
2308      *
2309      * @since JavaFX 2.2
2310      */
2311     public void setRoot(Object root) {
2312         this.root = root;
2313     }
2314 
2315     @Override
2316     public boolean equals(Object obj) {
2317         if (obj instanceof FXMLLoader) {
2318             FXMLLoader loader = (FXMLLoader)obj;
2319             if (location == null || loader.location == null) {
2320                 return loader.location == location;
2321             }
2322             return location.toExternalForm().equals(
2323                     loader.location.toExternalForm());
2324         }
2325         return false;
2326     }
2327 
2328     private boolean isCyclic(
2329                             FXMLLoader currentLoader,
2330                             FXMLLoader node) {
2331         if (currentLoader == null) {
2332             return false;
2333         }
2334         if (currentLoader.equals(node)) {
2335             return true;
2336         }
2337         return isCyclic(currentLoader.parentLoader, node);
2338     }
2339 
2340     /**
2341      * Returns the controller associated with the root object.
2342      * @param &lt;T&gt; the type of the controller
2343      * @return the controller associated with the root object
2344      */
2345     @SuppressWarnings(&quot;unchecked&quot;)
2346     public &lt;T&gt; T getController() {
2347         return (T)controller;
2348     }
2349 
2350     /**
2351      * Sets the controller associated with the root object. The value passed to
2352      * this method is used as the value of the {@code fx:controller} attribute.
2353      * This method must be called prior to loading the document when using
2354      * controller event handlers when an {@code fx:controller} attribute is not
2355      * specified in the document.
2356      *
2357      * @param controller the controller to associate with the root object
2358      *
2359      * @since JavaFX 2.2
2360      */
2361     public void setController(Object controller) {
2362         this.controller = controller;
2363 
2364         if (controller == null) {
2365             namespace.remove(CONTROLLER_KEYWORD);
2366         } else {
2367             namespace.put(CONTROLLER_KEYWORD, controller);
2368         }
2369 
2370         controllerAccessor.setController(controller);
2371     }
2372 
2373     /**
2374      * Returns the builder factory used by this loader.
2375      * @return the builder factory
2376      */
2377     public BuilderFactory getBuilderFactory() {
2378         return builderFactory;
2379     }
2380 
2381     /**
2382      * Sets the builder factory used by this loader.
2383      *
2384      * @param builderFactory the builder factory
2385      */
2386     public void setBuilderFactory(BuilderFactory builderFactory) {
2387         this.builderFactory = builderFactory;
2388     }
2389 
2390     /**
2391      * Returns the controller factory used by this loader.
2392      * @return the controller factory
2393      * @since JavaFX 2.1
2394      */
2395     public Callback&lt;Class&lt;?&gt;, Object&gt; getControllerFactory() {
2396         return controllerFactory;
2397     }
2398 
2399     /**
2400      * Sets the controller factory used by this loader.
2401      *
2402      * @param controllerFactory the controller factory
2403      * @since JavaFX 2.1
2404      */
2405     public void setControllerFactory(Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory) {
2406         this.controllerFactory = controllerFactory;
2407     }
2408 
2409     /**
2410      * Returns the character set used by this loader.
2411      * @return the character set
2412      */
2413     public Charset getCharset() {
2414         return charset;
2415     }
2416 
2417     /**
2418      * Sets the character set used by this loader.
2419      *
2420      * @param charset the character set
2421      * @since JavaFX 2.1
2422      */
2423     public void setCharset(Charset charset) {
2424         if (charset == null) {
2425             throw new NullPointerException(&quot;charset is null.&quot;);
2426         }
2427 
2428         this.charset = charset;
2429     }
2430 
2431     /**
2432      * Returns the classloader used by this loader.
2433      * @return the classloader
2434      * @since JavaFX 2.1
2435      */
2436     public ClassLoader getClassLoader() {
2437         if (classLoader == null) {
2438             final SecurityManager sm = System.getSecurityManager();
2439             final Class caller = (sm != null) ?
2440                     walker.getCallerClass() :
2441                     null;
2442             return getDefaultClassLoader(caller);
2443         }
2444         return classLoader;
2445     }
2446 
2447     /**
2448      * Sets the classloader used by this loader and clears any existing
2449      * imports.
2450      *
2451      * @param classLoader the classloader
2452      * @since JavaFX 2.1
2453      */
2454     public void setClassLoader(ClassLoader classLoader) {
2455         if (classLoader == null) {
2456             throw new IllegalArgumentException();
2457         }
2458 
2459         this.classLoader = classLoader;
2460 
2461         clearImports();
2462     }
2463 
2464     /*
2465      * Returns the static load flag.
2466      */
2467     boolean isStaticLoad() {
2468         // SB-dependency: RT-21226 has been filed to track this
2469         return staticLoad;
2470     }
2471 
2472     /*
2473      * Sets the static load flag.
2474      *
2475      * @param staticLoad
2476      */
2477     void setStaticLoad(boolean staticLoad) {
2478         // SB-dependency: RT-21226 has been filed to track this
2479         this.staticLoad = staticLoad;
2480     }
2481 
2482     /**
2483      * Returns this loader&#39;s load listener.
2484      *
2485      * @return the load listener
2486      *
2487      * @since 9
2488      */
2489     public LoadListener getLoadListener() {
2490         // SB-dependency: RT-21228 has been filed to track this
2491         return loadListener;
2492     }
2493 
2494     /**
2495      * Sets this loader&#39;s load listener.
2496      *
2497      * @param loadListener the load listener
2498      *
2499      * @since 9
2500      */
2501     public final void setLoadListener(LoadListener loadListener) {
2502         // SB-dependency: RT-21228 has been filed to track this
2503         this.loadListener = loadListener;
2504     }
2505 
2506     /**
2507      * Loads an object hierarchy from a FXML document. The location from which
2508      * the document will be loaded must have been set by a prior call to
2509      * {@link #setLocation(URL)}.
2510      *
2511      * @param &lt;T&gt; the type of the root object
2512      * @throws IOException if an error occurs during loading
2513      * @return the loaded object hierarchy
2514      *
2515      * @since JavaFX 2.1
2516      */
2517     public &lt;T&gt; T load() throws IOException {
2518         return loadImpl((System.getSecurityManager() != null)
2519                             ? walker.getCallerClass()
2520                             : null);
2521     }
2522 
2523     /**
2524      * Loads an object hierarchy from a FXML document.
2525      *
2526      * @param &lt;T&gt; the type of the root object
2527      * @param inputStream an input stream containing the FXML data to load
2528      *
2529      * @throws IOException if an error occurs during loading
2530      * @return the loaded object hierarchy
2531      */
2532     public &lt;T&gt; T load(InputStream inputStream) throws IOException {
2533         return loadImpl(inputStream, (System.getSecurityManager() != null)
2534                                          ? walker.getCallerClass()
2535                                          : null);
2536     }
2537 
2538     private Class&lt;?&gt; callerClass;
2539 
2540     private &lt;T&gt; T loadImpl(final Class&lt;?&gt; callerClass) throws IOException {
2541         if (location == null) {
2542             throw new IllegalStateException(&quot;Location is not set.&quot;);
2543         }
2544 
2545         InputStream inputStream = null;
2546         T value;
2547         try {
2548             inputStream = location.openStream();
2549             value = loadImpl(inputStream, callerClass);
2550         } finally {
2551             if (inputStream != null) {
2552                 inputStream.close();
2553             }
2554         }
2555 
2556         return value;
2557     }
2558 
2559     @SuppressWarnings({ &quot;dep-ann&quot;, &quot;unchecked&quot; })
2560     private &lt;T&gt; T loadImpl(InputStream inputStream,
2561                            Class&lt;?&gt; callerClass) throws IOException {
2562         if (inputStream == null) {
2563             throw new NullPointerException(&quot;inputStream is null.&quot;);
2564         }
2565 
2566         this.callerClass = callerClass;
2567         controllerAccessor.setCallerClass(callerClass);
2568         try {
2569             clearImports();
2570 
2571             // Initialize the namespace
2572             namespace.put(LOCATION_KEY, location);
2573             namespace.put(RESOURCES_KEY, resources);
2574 
2575             // Clear the script engine
2576             scriptEngine = null;
2577 
2578             // Create the parser
2579             try {
2580                 XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
2581                 xmlInputFactory.setProperty(&quot;javax.xml.stream.isCoalescing&quot;, true);
2582 
2583                 // Some stream readers incorrectly report an empty string as the prefix
2584                 // for the default namespace; correct this as needed
2585                 InputStreamReader inputStreamReader = new InputStreamReader(inputStream, charset);
2586                 xmlStreamReader = new StreamReaderDelegate(xmlInputFactory.createXMLStreamReader(inputStreamReader)) {
2587                     @Override
2588                     public String getPrefix() {
2589                         String prefix = super.getPrefix();
2590 
2591                         if (prefix != null
2592                             &amp;&amp; prefix.length() == 0) {
2593                             prefix = null;
2594                         }
2595 
2596                         return prefix;
2597                     }
2598 
2599                     @Override
2600                     public String getAttributePrefix(int index) {
2601                         String attributePrefix = super.getAttributePrefix(index);
2602 
2603                         if (attributePrefix != null
2604                             &amp;&amp; attributePrefix.length() == 0) {
2605                             attributePrefix = null;
2606                         }
2607 
2608                         return attributePrefix;
2609                     }
2610                 };
2611             } catch (XMLStreamException exception) {
2612                 throw constructLoadException(exception);
2613             }
2614 
2615             // Push this loader onto the stack
2616             loaders.push(this);
2617 
2618             // Parse the XML stream
2619             try {
2620                 while (xmlStreamReader.hasNext()) {
2621                     int event = xmlStreamReader.next();
2622 
2623                     switch (event) {
2624                         case XMLStreamConstants.PROCESSING_INSTRUCTION: {
2625                             processProcessingInstruction();
2626                             break;
2627                         }
2628 
2629                         case XMLStreamConstants.COMMENT: {
2630                             processComment();
2631                             break;
2632                         }
2633 
2634                         case XMLStreamConstants.START_ELEMENT: {
2635                             processStartElement();
2636                             break;
2637                         }
2638 
2639                         case XMLStreamConstants.END_ELEMENT: {
2640                             processEndElement();
2641                             break;
2642                         }
2643 
2644                         case XMLStreamConstants.CHARACTERS: {
2645                             processCharacters();
2646                             break;
2647                         }
2648                     }
2649                 }
2650             } catch (XMLStreamException exception) {
2651                 throw constructLoadException(exception);
2652             }
2653 
2654             if (controller != null) {
2655                 if (controller instanceof Initializable) {
2656                     ((Initializable)controller).initialize(location, resources);
2657                 } else {
2658                     // Inject controller fields
2659                     Map&lt;String, List&lt;Field&gt;&gt; controllerFields =
2660                             controllerAccessor.getControllerFields();
2661 
2662                     injectFields(LOCATION_KEY, location);
2663 
2664                     injectFields(RESOURCES_KEY, resources);
2665 
2666                     // Initialize the controller
2667                     Method initializeMethod = controllerAccessor
2668                                                   .getControllerMethods()
2669                                                   .get(SupportedType.PARAMETERLESS)
2670                                                   .get(INITIALIZE_METHOD_NAME);
2671 
2672                     if (initializeMethod != null) {
2673                         try {
2674                             MethodHelper.invoke(initializeMethod, controller, new Object [] {});
2675                         } catch (IllegalAccessException exception) {
2676                             throw constructLoadException(exception);
2677                         } catch (InvocationTargetException exception) {
2678                             throw constructLoadException(exception);
2679                         }
2680                     }
2681                 }
2682             }
2683         } catch (final LoadException exception) {
2684             throw exception;
2685         } catch (final Exception exception) {
2686             throw constructLoadException(exception);
2687         } finally {
2688             controllerAccessor.setCallerClass(null);
2689             // Clear controller accessor caches
2690             controllerAccessor.reset();
2691             // Clear the parser
2692             xmlStreamReader = null;
2693         }
2694 
2695         return (T)root;
2696     }
2697 
2698     private void clearImports() {
2699         packages.clear();
2700         classes.clear();
2701     }
2702 
2703     private LoadException constructLoadException(String message){
2704         return new LoadException(message + constructFXMLTrace());
2705     }
2706 
2707     private LoadException constructLoadException(Throwable cause) {
2708         return new LoadException(constructFXMLTrace(), cause);
2709     }
2710 
2711     private LoadException constructLoadException(String message, Throwable cause){
2712         return new LoadException(message + constructFXMLTrace(), cause);
2713     }
2714 
2715     private String constructFXMLTrace() {
2716         StringBuilder messageBuilder = new StringBuilder(&quot;\n&quot;);
2717 
2718         for (FXMLLoader loader : loaders) {
2719             messageBuilder.append(loader.location != null ? loader.location.getPath() : &quot;unknown path&quot;);
2720 
2721             if (loader.current != null) {
2722                 messageBuilder.append(&quot;:&quot;);
2723                 messageBuilder.append(loader.getLineNumber());
2724             }
2725 
2726             messageBuilder.append(&quot;\n&quot;);
2727         }
2728         return messageBuilder.toString();
2729     }
2730 
2731     /**
2732      * Returns the current line number.
2733      */
2734     int getLineNumber() {
2735         return xmlStreamReader.getLocation().getLineNumber();
2736     }
2737 
2738     /**
2739      * Returns the current parse trace.
2740      */
2741     ParseTraceElement[] getParseTrace() {
2742         ParseTraceElement[] parseTrace = new ParseTraceElement[loaders.size()];
2743 
2744         int i = 0;
2745         for (FXMLLoader loader : loaders) {
2746             parseTrace[i++] = new ParseTraceElement(loader.location, (loader.current != null) ?
2747                 loader.getLineNumber() : -1);
2748         }
2749 
2750         return parseTrace;
2751     }
2752 
2753     private void processProcessingInstruction() throws LoadException {
2754         String piTarget = xmlStreamReader.getPITarget().trim();
2755 
2756         if (piTarget.equals(LANGUAGE_PROCESSING_INSTRUCTION)) {
2757             processLanguage();
2758         } else if (piTarget.equals(IMPORT_PROCESSING_INSTRUCTION)) {
2759             processImport();
2760         } else if (piTarget.equals(COMPILE_PROCESSING_INSTRUCTION)) {
2761             String strCompile=xmlStreamReader.getPIData().trim();
2762             // if PIData() is empty string then default to true, otherwise use Boolean.parseBoolean(string) to determine the boolean value
2763             compileScript = (strCompile.length()==0 ? true : Boolean.parseBoolean(strCompile));
2764         }
2765     }
2766 
2767     private void processLanguage() throws LoadException {
2768         if (scriptEngine != null) {
2769             throw constructLoadException(&quot;Page language already set.&quot;);
2770         }
2771 
2772         String language = xmlStreamReader.getPIData();
2773 
2774         if (loadListener != null) {
2775             loadListener.readLanguageProcessingInstruction(language);
2776         }
2777 
2778         if (!staticLoad) {
2779             ScriptEngineManager scriptEngineManager = getScriptEngineManager();
2780             scriptEngine = scriptEngineManager.getEngineByName(language);
2781         }
2782     }
2783 
2784     private void processImport() throws LoadException {
2785         String target = xmlStreamReader.getPIData().trim();
2786 
2787         if (loadListener != null) {
2788             loadListener.readImportProcessingInstruction(target);
2789         }
2790 
2791         if (target.endsWith(&quot;.*&quot;)) {
2792             importPackage(target.substring(0, target.length() - 2));
2793         } else {
2794             importClass(target);
2795         }
2796     }
2797 
2798     private void processComment() throws LoadException {
2799         if (loadListener != null) {
2800             loadListener.readComment(xmlStreamReader.getText());
2801         }
2802     }
2803 
2804     private void processStartElement() throws IOException {
2805         // Create the element
2806         createElement();
2807 
2808         // Process the start tag
2809         current.processStartElement();
2810 
2811         // Set the root value
2812         if (root == null) {
2813             root = current.value;
2814         }
2815     }
2816 
2817     private void createElement() throws IOException {
2818         String prefix = xmlStreamReader.getPrefix();
2819         String localName = xmlStreamReader.getLocalName();
2820 
2821         if (prefix == null) {
2822             int i = localName.lastIndexOf(&#39;.&#39;);
2823 
2824             if (Character.isLowerCase(localName.charAt(i + 1))) {
2825                 String name = localName.substring(i + 1);
2826 
2827                 if (i == -1) {
2828                     // This is an instance property
2829                     if (loadListener != null) {
2830                         loadListener.beginPropertyElement(name, null);
2831                     }
2832 
2833                     current = new PropertyElement(name, null);
2834                 } else {
2835                     // This is a static property
2836                     Class&lt;?&gt; sourceType = getType(localName.substring(0, i));
2837 
2838                     if (sourceType != null) {
2839                         if (loadListener != null) {
2840                             loadListener.beginPropertyElement(name, sourceType);
2841                         }
2842 
2843                         current = new PropertyElement(name, sourceType);
2844                     } else if (staticLoad) {
2845                         // The source type was not recognized
2846                         if (loadListener != null) {
2847                             loadListener.beginUnknownStaticPropertyElement(localName);
2848                         }
2849 
2850                         current = new UnknownStaticPropertyElement();
2851                     } else {
2852                         throw constructLoadException(localName + &quot; is not a valid property.&quot;);
2853                     }
2854                 }
2855             } else {
2856                 if (current == null &amp;&amp; root != null) {
2857                     throw constructLoadException(&quot;Root value already specified.&quot;);
2858                 }
2859 
2860                 Class&lt;?&gt; type = getType(localName);
2861 
2862                 if (type != null) {
2863                     if (loadListener != null) {
2864                         loadListener.beginInstanceDeclarationElement(type);
2865                     }
2866 
2867                     current = new InstanceDeclarationElement(type);
2868                 } else if (staticLoad) {
2869                     // The type was not recognized
2870                     if (loadListener != null) {
2871                         loadListener.beginUnknownTypeElement(localName);
2872                     }
2873 
2874                     current = new UnknownTypeElement();
2875                 } else {
2876                     throw constructLoadException(localName + &quot; is not a valid type.&quot;);
2877                 }
2878             }
2879         } else if (prefix.equals(FX_NAMESPACE_PREFIX)) {
2880             if (localName.equals(INCLUDE_TAG)) {
2881                 if (loadListener != null) {
2882                     loadListener.beginIncludeElement();
2883                 }
2884 
2885                 current = new IncludeElement();
2886             } else if (localName.equals(REFERENCE_TAG)) {
2887                 if (loadListener != null) {
2888                     loadListener.beginReferenceElement();
2889                 }
2890 
2891                 current = new ReferenceElement();
2892             } else if (localName.equals(COPY_TAG)) {
2893                 if (loadListener != null) {
2894                     loadListener.beginCopyElement();
2895                 }
2896 
2897                 current = new CopyElement();
2898             } else if (localName.equals(ROOT_TAG)) {
2899                 if (loadListener != null) {
2900                     loadListener.beginRootElement();
2901                 }
2902 
2903                 current = new RootElement();
2904             } else if (localName.equals(SCRIPT_TAG)) {
2905                 if (loadListener != null) {
2906                     loadListener.beginScriptElement();
2907                 }
2908 
2909                 current = new ScriptElement();
2910             } else if (localName.equals(DEFINE_TAG)) {
2911                 if (loadListener != null) {
2912                     loadListener.beginDefineElement();
2913                 }
2914 
2915                 current = new DefineElement();
2916             } else {
2917                 throw constructLoadException(prefix + &quot;:&quot; + localName + &quot; is not a valid element.&quot;);
2918             }
2919         } else {
2920             throw constructLoadException(&quot;Unexpected namespace prefix: &quot; + prefix + &quot;.&quot;);
2921         }
2922     }
2923 
2924     private void processEndElement() throws IOException {
2925         current.processEndElement();
2926 
2927         if (loadListener != null) {
2928             loadListener.endElement(current.value);
2929         }
2930 
2931         // Move up the stack
2932         current = current.parent;
2933     }
2934 
2935     private void processCharacters() throws IOException {
2936         // Process the characters
2937         if (!xmlStreamReader.isWhiteSpace()) {
2938             current.processCharacters();
2939         }
2940     }
2941 
2942     private void importPackage(String name) throws LoadException {
2943         packages.add(name);
2944     }
2945 
2946     private void importClass(String name) throws LoadException {
2947         try {
2948             loadType(name, true);
2949         } catch (ClassNotFoundException exception) {
2950             throw constructLoadException(exception);
2951         }
2952     }
2953 
2954     private Class&lt;?&gt; getType(String name) throws LoadException {
2955         Class&lt;?&gt; type = null;
2956 
2957         if (Character.isLowerCase(name.charAt(0))) {
2958             // This is a fully-qualified class name
2959             try {
2960                 type = loadType(name, false);
2961             } catch (ClassNotFoundException exception) {
2962                 // No-op
2963             }
2964         } else {
2965             // This is an unqualified class name
2966             type = classes.get(name);
2967 
2968             if (type == null) {
2969                 // The class has not been loaded yet; look it up
2970                 for (String packageName : packages) {
2971                     try {
2972                         type = loadTypeForPackage(packageName, name);
2973                     } catch (ClassNotFoundException exception) {
2974                         // No-op
2975                     }
2976 
2977                     if (type != null) {
2978                         break;
2979                     }
2980                 }
2981 
2982                 if (type != null) {
2983                     classes.put(name, type);
2984                 }
2985             }
2986         }
2987 
2988         return type;
2989     }
2990 
2991     private Class&lt;?&gt; loadType(String name, boolean cache) throws ClassNotFoundException {
2992         int i = name.indexOf(&#39;.&#39;);
2993         int n = name.length();
2994         while (i != -1
2995             &amp;&amp; i &lt; n
2996             &amp;&amp; Character.isLowerCase(name.charAt(i + 1))) {
2997             i = name.indexOf(&#39;.&#39;, i + 1);
2998         }
2999 
3000         if (i == -1 || i == n) {
3001             throw new ClassNotFoundException();
3002         }
3003 
3004         String packageName = name.substring(0, i);
3005         String className = name.substring(i + 1);
3006 
3007         Class&lt;?&gt; type = loadTypeForPackage(packageName, className);
3008 
3009         if (cache) {
3010             classes.put(className, type);
3011         }
3012 
3013         return type;
3014     }
3015 
3016     // TODO Rename to loadType() when deprecated static version is removed
3017     private Class&lt;?&gt; loadTypeForPackage(String packageName, String className) throws ClassNotFoundException {
3018         return getClassLoader().loadClass(packageName + &quot;.&quot; + className.replace(&#39;.&#39;, &#39;$&#39;));
3019     }
3020 
3021     private static enum SupportedType {
3022         PARAMETERLESS {
3023 
3024             @Override
3025             protected boolean methodIsOfType(Method m) {
3026                 return m.getParameterTypes().length == 0;
3027             }
3028 
3029         },
3030         EVENT {
3031 
3032             @Override
3033             protected boolean methodIsOfType(Method m) {
3034                 return m.getParameterTypes().length == 1 &amp;&amp;
3035                         Event.class.isAssignableFrom(m.getParameterTypes()[0]);
3036             }
3037 
3038         },
3039         LIST_CHANGE_LISTENER {
3040 
3041             @Override
3042             protected boolean methodIsOfType(Method m) {
3043                 return m.getParameterTypes().length == 1 &amp;&amp;
3044                         m.getParameterTypes()[0].equals(ListChangeListener.Change.class);
3045             }
3046 
3047         },
3048         MAP_CHANGE_LISTENER {
3049 
3050             @Override
3051             protected boolean methodIsOfType(Method m) {
3052                 return m.getParameterTypes().length == 1 &amp;&amp;
3053                         m.getParameterTypes()[0].equals(MapChangeListener.Change.class);
3054             }
3055 
3056         },
3057         SET_CHANGE_LISTENER {
3058 
3059             @Override
3060             protected boolean methodIsOfType(Method m) {
3061                 return m.getParameterTypes().length == 1 &amp;&amp;
3062                         m.getParameterTypes()[0].equals(SetChangeListener.Change.class);
3063             }
3064 
3065         },
3066         PROPERTY_CHANGE_LISTENER {
3067 
3068             @Override
3069             protected boolean methodIsOfType(Method m) {
3070                 return m.getParameterTypes().length == 3 &amp;&amp;
3071                         ObservableValue.class.isAssignableFrom(m.getParameterTypes()[0])
3072                         &amp;&amp; m.getParameterTypes()[1].equals(m.getParameterTypes()[2]);
3073             }
3074 
3075         };
3076 
3077         protected abstract boolean methodIsOfType(Method m);
3078     }
3079 
3080     private static SupportedType toSupportedType(Method m) {
3081         for (SupportedType t : SupportedType.values()) {
3082             if (t.methodIsOfType(m)) {
3083                 return t;
3084             }
3085         }
3086         return null;
3087     }
3088 
3089     private ScriptEngineManager getScriptEngineManager() {
3090         if (scriptEngineManager == null) {
3091             scriptEngineManager = new javax.script.ScriptEngineManager();
3092             scriptEngineManager.setBindings(new SimpleBindings(namespace));
3093         }
3094 
3095         return scriptEngineManager;
3096     }
3097 
3098     /**
3099      * Loads a type using the default class loader.
3100      *
3101      * @param packageName the package name of the class to load
3102      * @param className the name of the class to load
3103      *
3104      * @throws ClassNotFoundException if the specified class cannot be found
3105      * @return the class
3106      *
3107      * @deprecated
3108      * This method now delegates to {@link #getDefaultClassLoader()}.
3109      */
3110     @Deprecated
3111     public static Class&lt;?&gt; loadType(String packageName, String className) throws ClassNotFoundException {
3112         return loadType(packageName + &quot;.&quot; + className.replace(&#39;.&#39;, &#39;$&#39;));
3113     }
3114 
3115     /**
3116      * Loads a type using the default class loader.
3117      *
3118      * @param className the name of the class to load
3119      * @throws ClassNotFoundException if the specified class cannot be found
3120      * @return the class
3121      *
3122      * @deprecated
3123      * This method now delegates to {@link #getDefaultClassLoader()}.
3124      */
3125     @Deprecated
3126     public static Class&lt;?&gt; loadType(String className) throws ClassNotFoundException {
3127         ReflectUtil.checkPackageAccess(className);
3128         return Class.forName(className, true, getDefaultClassLoader());
3129     }
3130 
3131     private static boolean needsClassLoaderPermissionCheck(Class caller) {
3132         if (caller == null) {
3133             return false;
3134         }
3135         return !FXMLLoader.class.getModule().equals(caller.getModule());
3136     }
3137 
3138     private static ClassLoader getDefaultClassLoader(Class caller) {
3139         if (defaultClassLoader == null) {
3140             final SecurityManager sm = System.getSecurityManager();
3141             if (sm != null) {
3142                 if (needsClassLoaderPermissionCheck(caller)) {
3143                     sm.checkPermission(GET_CLASSLOADER_PERMISSION);
3144                 }
3145             }
3146             return Thread.currentThread().getContextClassLoader();
3147         }
3148         return defaultClassLoader;
3149     }
3150 
3151     /**
3152      * Returns the default class loader.
3153      * @return the default class loader
3154      * @since JavaFX 2.1
3155      */
3156     public static ClassLoader getDefaultClassLoader() {
3157         final SecurityManager sm = System.getSecurityManager();
3158         final Class caller = (sm != null) ?
3159                 walker.getCallerClass() :
3160                 null;
3161         return getDefaultClassLoader(caller);
3162     }
3163 
3164     /**
3165      * Sets the default class loader.
3166      *
3167      * @param defaultClassLoader
3168      * The default class loader to use when loading classes.
3169      * @since JavaFX 2.1
3170      */
3171     public static void setDefaultClassLoader(ClassLoader defaultClassLoader) {
3172         if (defaultClassLoader == null) {
3173             throw new NullPointerException();
3174         }
3175         final SecurityManager sm = System.getSecurityManager();
3176         if (sm != null) {
3177             sm.checkPermission(MODIFY_FXML_CLASS_LOADER_PERMISSION);
3178         }
3179 
3180         FXMLLoader.defaultClassLoader = defaultClassLoader;
3181     }
3182 
3183     /**
3184      * Loads an object hierarchy from a FXML document.
3185      *
3186      * @param &lt;T&gt; the type of the root object
3187      * @param location the location used to resolve relative path attribute values
3188      *
3189      * @throws IOException if an error occurs during loading
3190      * @return the loaded object hierarchy
3191      */
3192     public static &lt;T&gt; T load(URL location) throws IOException {
3193         return loadImpl(location, (System.getSecurityManager() != null)
3194                                       ? walker.getCallerClass()
3195                                       : null);
3196     }
3197 
3198     private static &lt;T&gt; T loadImpl(URL location, Class&lt;?&gt; callerClass)
3199             throws IOException {
3200         return loadImpl(location, null, callerClass);
3201     }
3202 
3203     /**
3204      * Loads an object hierarchy from a FXML document.
3205      *
3206      * @param &lt;T&gt; the type of the root object
3207      * @param location the location used to resolve relative path attribute values
3208      * @param resources the resources used to resolve resource key attribute values
3209      *
3210      * @throws IOException if an error occurs during loading
3211      * @return the loaded object hierarchy
3212      */
3213     public static &lt;T&gt; T load(URL location, ResourceBundle resources)
3214                                      throws IOException {
3215         return loadImpl(location, resources,
3216                         (System.getSecurityManager() != null)
3217                             ? walker.getCallerClass()
3218                             : null);
3219     }
3220 
3221     private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
3222                                   Class&lt;?&gt; callerClass) throws IOException {
3223         return loadImpl(location, resources,  null,
3224                         callerClass);
3225     }
3226 
3227     /**
3228      * Loads an object hierarchy from a FXML document.
3229      *
3230      * @param &lt;T&gt; the type of the root object
3231      * @param location the location used to resolve relative path attribute values
3232      * @param resources the resources used to resolve resource key attribute values
3233      * @param builderFactory the builder factory used to load the document
3234      *
3235      * @throws IOException if an error occurs during loading
3236      * @return the loaded object hierarchy
3237      */
3238     public static &lt;T&gt; T load(URL location, ResourceBundle resources,
3239                              BuilderFactory builderFactory)
3240                                      throws IOException {
3241         return loadImpl(location, resources, builderFactory,
3242                         (System.getSecurityManager() != null)
3243                             ? walker.getCallerClass()
3244                             : null);
3245     }
3246 
3247     private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
3248                                   BuilderFactory builderFactory,
3249                                   Class&lt;?&gt; callerClass) throws IOException {
3250         return loadImpl(location, resources, builderFactory, null, callerClass);
3251     }
3252 
3253     /**
3254      * Loads an object hierarchy from a FXML document.
3255      *
3256      * @param &lt;T&gt; the type of the root object
3257      * @param location the location used to resolve relative path attribute values
3258      * @param resources the resources used to resolve resource key attribute values
3259      * @param builderFactory the builder factory used when loading the document
3260      * @param controllerFactory the controller factory used when loading the document
3261      *
3262      * @throws IOException if an error occurs during loading
3263      * @return the loaded object hierarchy
3264      *
3265      * @since JavaFX 2.1
3266      */
3267     public static &lt;T&gt; T load(URL location, ResourceBundle resources,
3268                              BuilderFactory builderFactory,
3269                              Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory)
3270                                      throws IOException {
3271         return loadImpl(location, resources, builderFactory, controllerFactory,
3272                         (System.getSecurityManager() != null)
3273                             ? walker.getCallerClass()
3274                             : null);
3275     }
3276 
3277     private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
3278                                   BuilderFactory builderFactory,
3279                                   Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory,
3280                                   Class&lt;?&gt; callerClass) throws IOException {
3281         return loadImpl(location, resources, builderFactory, controllerFactory,
3282                         Charset.forName(DEFAULT_CHARSET_NAME), callerClass);
3283     }
3284 
3285     /**
3286      * Loads an object hierarchy from a FXML document.
3287      *
3288      * @param &lt;T&gt; the type of the root object
3289      * @param location the location used to resolve relative path attribute values
3290      * @param resources the resources used to resolve resource key attribute values
3291      * @param builderFactory the builder factory used when loading the document
3292      * @param controllerFactory the controller factory used when loading the document
3293      * @param charset the character set used when loading the document
3294      *
3295      * @throws IOException if an error occurs during loading
3296      * @return the loaded object hierarchy
3297      *
3298      * @since JavaFX 2.1
3299      */
3300     public static &lt;T&gt; T load(URL location, ResourceBundle resources,
3301                              BuilderFactory builderFactory,
3302                              Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory,
3303                              Charset charset) throws IOException {
3304         return loadImpl(location, resources, builderFactory, controllerFactory,
3305                         charset,
3306                         (System.getSecurityManager() != null)
3307                             ? walker.getCallerClass()
3308                             : null);
3309     }
3310 
3311     private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
3312                                   BuilderFactory builderFactory,
3313                                   Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory,
3314                                   Charset charset, Class&lt;?&gt; callerClass)
3315                                           throws IOException {
3316         if (location == null) {
3317             throw new NullPointerException(&quot;Location is required.&quot;);
3318         }
3319 
3320         FXMLLoader fxmlLoader =
3321                 new FXMLLoader(location, resources, builderFactory,
3322                                controllerFactory, charset);
3323 
3324         return fxmlLoader.&lt;T&gt;loadImpl(callerClass);
3325     }
3326 
3327     /**
3328      * Utility method for comparing two JavaFX version strings (such as 2.2.5, 8.0.0-ea)
3329      * @param rtVer String representation of JavaFX runtime version, including - or _ appendix
3330      * @param nsVer String representation of JavaFX version to compare against runtime version
3331      * @return number &amp;lt; 0 if runtime version is lower, 0 when both versions are the same,
3332      *          number &amp;gt; 0 if runtime is higher version
3333      */
3334     static int compareJFXVersions(String rtVer, String nsVer) {
3335 
3336         int retVal = 0;
3337 
3338         if (rtVer == null || &quot;&quot;.equals(rtVer) ||
3339             nsVer == null || &quot;&quot;.equals(nsVer)) {
3340             return retVal;
3341         }
3342 
3343         if (rtVer.equals(nsVer)) {
3344             return retVal;
3345         }
3346 
3347         // version string can contain &#39;-&#39;
3348         int dashIndex = rtVer.indexOf(&quot;-&quot;);
3349         if (dashIndex &gt; 0) {
3350             rtVer = rtVer.substring(0, dashIndex);
3351         }
3352 
3353         // or &quot;_&quot;
3354         int underIndex = rtVer.indexOf(&quot;_&quot;);
3355         if (underIndex &gt; 0) {
3356             rtVer = rtVer.substring(0, underIndex);
3357         }
3358 
3359         // do not try to compare if the string is not valid version format
3360         if (!Pattern.matches(&quot;^(\\d+)(\\.\\d+)*$&quot;, rtVer) ||
3361             !Pattern.matches(&quot;^(\\d+)(\\.\\d+)*$&quot;, nsVer)) {
3362             return retVal;
3363         }
3364 
3365         StringTokenizer nsVerTokenizer = new StringTokenizer(nsVer, &quot;.&quot;);
3366         StringTokenizer rtVerTokenizer = new StringTokenizer(rtVer, &quot;.&quot;);
3367         int nsDigit = 0, rtDigit = 0;
3368         boolean rtVerEnd = false;
3369 
3370         while (nsVerTokenizer.hasMoreTokens() &amp;&amp; retVal == 0) {
3371             nsDigit = Integer.parseInt(nsVerTokenizer.nextToken());
3372             if (rtVerTokenizer.hasMoreTokens()) {
3373                 rtDigit = Integer.parseInt(rtVerTokenizer.nextToken());
3374                 retVal = rtDigit - nsDigit;
3375             } else {
3376                 rtVerEnd = true;
3377                 break;
3378             }
3379         }
3380 
3381         if (rtVerTokenizer.hasMoreTokens() &amp;&amp; retVal == 0) {
3382             rtDigit = Integer.parseInt(rtVerTokenizer.nextToken());
3383             if (rtDigit &gt; 0) {
3384                 retVal = 1;
3385             }
3386         }
3387 
3388         if (rtVerEnd) {
3389             if (nsDigit &gt; 0) {
3390                 retVal = -1;
3391             } else {
3392                 while (nsVerTokenizer.hasMoreTokens()) {
3393                     nsDigit = Integer.parseInt(nsVerTokenizer.nextToken());
3394                     if (nsDigit &gt; 0) {
3395                         retVal = -1;
3396                         break;
3397                     }
3398                 }
3399             }
3400         }
3401 
3402         return retVal;
3403     }
3404 
3405     private static void checkClassLoaderPermission() {
3406         final SecurityManager securityManager = System.getSecurityManager();
3407         if (securityManager != null) {
3408             securityManager.checkPermission(MODIFY_FXML_CLASS_LOADER_PERMISSION);
3409         }
3410     }
3411 
3412     private final ControllerAccessor controllerAccessor =
3413             new ControllerAccessor();
3414 
3415     private static final class ControllerAccessor {
3416         private static final int PUBLIC = 1;
3417         private static final int PROTECTED = 2;
3418         private static final int PACKAGE = 4;
3419         private static final int PRIVATE = 8;
3420         private static final int INITIAL_CLASS_ACCESS =
3421                 PUBLIC | PROTECTED | PACKAGE | PRIVATE;
3422         private static final int INITIAL_MEMBER_ACCESS =
3423                 PUBLIC | PROTECTED | PACKAGE | PRIVATE;
3424 
3425         private static final int METHODS = 0;
3426         private static final int FIELDS = 1;
3427 
3428         private Object controller;
3429         private ClassLoader callerClassLoader;
3430 
3431         private Map&lt;String, List&lt;Field&gt;&gt; controllerFields;
3432         private Map&lt;SupportedType, Map&lt;String, Method&gt;&gt; controllerMethods;
3433 
3434         void setController(final Object controller) {
3435             if (this.controller != controller) {
3436                 this.controller = controller;
3437                 reset();
3438             }
3439         }
3440 
3441         void setCallerClass(final Class&lt;?&gt; callerClass) {
3442             final ClassLoader newCallerClassLoader =
3443                     (callerClass != null) ? callerClass.getClassLoader()
3444                                           : null;
3445             if (callerClassLoader != newCallerClassLoader) {
3446                 callerClassLoader = newCallerClassLoader;
3447                 reset();
3448             }
3449         }
3450 
3451         void reset() {
3452             controllerFields = null;
3453             controllerMethods = null;
3454         }
3455 
3456         Map&lt;String, List&lt;Field&gt;&gt; getControllerFields() {
3457             if (controllerFields == null) {
3458                 controllerFields = new HashMap&lt;&gt;();
3459 
3460                 if (callerClassLoader == null) {
3461                     // allow null class loader only with permission check
3462                     checkClassLoaderPermission();
3463                 }
3464 
3465                 addAccessibleMembers(controller.getClass(),
3466                                      INITIAL_CLASS_ACCESS,
3467                                      INITIAL_MEMBER_ACCESS,
3468                                      FIELDS);
3469             }
3470 
3471             return controllerFields;
3472         }
3473 
3474         Map&lt;SupportedType, Map&lt;String, Method&gt;&gt; getControllerMethods() {
3475             if (controllerMethods == null) {
3476                 controllerMethods = new EnumMap&lt;&gt;(SupportedType.class);
3477                 for (SupportedType t: SupportedType.values()) {
3478                     controllerMethods.put(t, new HashMap&lt;String, Method&gt;());
3479                 }
3480 
3481                 if (callerClassLoader == null) {
3482                     // allow null class loader only with permission check
3483                     checkClassLoaderPermission();
3484                 }
3485 
3486                 addAccessibleMembers(controller.getClass(),
3487                                      INITIAL_CLASS_ACCESS,
3488                                      INITIAL_MEMBER_ACCESS,
3489                                      METHODS);
3490             }
3491 
3492             return controllerMethods;
3493         }
3494 
3495         private void addAccessibleMembers(final Class&lt;?&gt; type,
3496                                           final int prevAllowedClassAccess,
3497                                           final int prevAllowedMemberAccess,
3498                                           final int membersType) {
3499             if (type == Object.class) {
3500                 return;
3501             }
3502 
3503             int allowedClassAccess = prevAllowedClassAccess;
3504             int allowedMemberAccess = prevAllowedMemberAccess;
3505             if ((callerClassLoader != null)
3506                     &amp;&amp; (type.getClassLoader() != callerClassLoader)) {
3507                 // restrict further access
3508                 allowedClassAccess &amp;= PUBLIC;
3509                 allowedMemberAccess &amp;= PUBLIC;
3510             }
3511 
3512             final int classAccess = getAccess(type.getModifiers());
3513             if ((classAccess &amp; allowedClassAccess) == 0) {
3514                 // we are done
3515                 return;
3516             }
3517 
3518             ReflectUtil.checkPackageAccess(type);
3519 
3520             addAccessibleMembers(type.getSuperclass(),
3521                                  allowedClassAccess,
3522                                  allowedMemberAccess,
3523                                  membersType);
3524 
3525             final int finalAllowedMemberAccess = allowedMemberAccess;
3526             AccessController.doPrivileged(
3527                     new PrivilegedAction&lt;Void&gt;() {
3528                         @Override
3529                         public Void run() {
3530                             if (membersType == FIELDS) {
3531                                 addAccessibleFields(type,
3532                                                     finalAllowedMemberAccess);
3533                             } else {
3534                                 addAccessibleMethods(type,
3535                                                      finalAllowedMemberAccess);
3536                             }
3537 
3538                             return null;
3539                         }
3540                     });
3541         }
3542 
3543         private void addAccessibleFields(final Class&lt;?&gt; type,
3544                                          final int allowedMemberAccess) {
3545             final boolean isPublicType = Modifier.isPublic(type.getModifiers());
3546 
3547             final Field[] fields = type.getDeclaredFields();
3548             for (int i = 0; i &lt; fields.length; ++i) {
3549                 final Field field = fields[i];
3550                 final int memberModifiers = field.getModifiers();
3551 
3552                 if (((memberModifiers &amp; (Modifier.STATIC
3553                                              | Modifier.FINAL)) != 0)
3554                         || ((getAccess(memberModifiers) &amp; allowedMemberAccess)
3555                                 == 0)) {
3556                     continue;
3557                 }
3558 
3559                 if (!isPublicType || !Modifier.isPublic(memberModifiers)) {
3560                     if (field.getAnnotation(FXML.class) == null) {
3561                         // no fxml annotation on a non-public field
3562                         continue;
3563                     }
3564 
3565                     // Ensure that the field is accessible
3566                     field.setAccessible(true);
3567                 }
3568 
3569                 List&lt;Field&gt; list = controllerFields.get(field.getName());
3570                 if (list == null) {
3571                     list = new ArrayList&lt;&gt;(1);
3572                     controllerFields.put(field.getName(), list);
3573                 }
3574                 list.add(field);
3575 
3576             }
3577         }
3578 
3579         private void addAccessibleMethods(final Class&lt;?&gt; type,
3580                                           final int allowedMemberAccess) {
3581             final boolean isPublicType = Modifier.isPublic(type.getModifiers());
3582 
3583             final Method[] methods = type.getDeclaredMethods();
3584             for (int i = 0; i &lt; methods.length; ++i) {
3585                 final Method method = methods[i];
3586                 final int memberModifiers = method.getModifiers();
3587 
3588                 if (((memberModifiers &amp; (Modifier.STATIC
3589                                              | Modifier.NATIVE)) != 0)
3590                         || ((getAccess(memberModifiers) &amp; allowedMemberAccess)
3591                                 == 0)) {
3592                     continue;
3593                 }
3594 
3595                 if (!isPublicType || !Modifier.isPublic(memberModifiers)) {
3596                     if (method.getAnnotation(FXML.class) == null) {
3597                         // no fxml annotation on a non-public method
3598                         continue;
3599                     }
3600 
3601                     // Ensure that the method is accessible
3602                     method.setAccessible(true);
3603                 }
3604 
3605                 // Add this method to the map if:
3606                 // a) it is the initialize() method, or
3607                 // b) it takes a single event argument, or
3608                 // c) it takes no arguments and a handler with this
3609                 //    name has not already been defined
3610                 final String methodName = method.getName();
3611                 final SupportedType convertedType;
3612 
3613                 if ((convertedType = toSupportedType(method)) != null) {
3614                     controllerMethods.get(convertedType)
3615                                      .put(methodName, method);
3616                 }
3617             }
3618         }
3619 
3620         private static int getAccess(final int fullModifiers) {
3621             final int untransformedAccess =
3622                     fullModifiers &amp; (Modifier.PRIVATE | Modifier.PROTECTED
3623                                                       | Modifier.PUBLIC);
3624 
3625             switch (untransformedAccess) {
3626                 case Modifier.PUBLIC:
3627                     return PUBLIC;
3628 
3629                 case Modifier.PROTECTED:
3630                     return PROTECTED;
3631 
3632                 case Modifier.PRIVATE:
3633                     return PRIVATE;
3634 
3635                 default:
3636                     return PACKAGE;
3637             }
3638         }
3639     }
3640 }
3641 
3642 
    </pre>
  </body>
</html>
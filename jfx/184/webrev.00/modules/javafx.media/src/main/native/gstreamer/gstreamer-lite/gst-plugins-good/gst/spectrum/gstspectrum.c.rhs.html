<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/spectrum/gstspectrum.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) &lt;1999&gt; Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *               &lt;2006,2011&gt; Stefan Kost &lt;ensonic@users.sf.net&gt;
   4  *               &lt;2007-2009&gt; Sebastian Dr√∂ge &lt;sebastian.droege@collabora.co.uk&gt;
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public
  17  * License along with this library; if not, write to the
  18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 /**
  22  * SECTION:element-spectrum
  23  *
  24  * The Spectrum element analyzes the frequency spectrum of an audio signal.
  25  * If the #GstSpectrum:post-messages property is %TRUE, it sends analysis results
  26  * as element messages named
  27  * &lt;classname&gt;&amp;quot;spectrum&amp;quot;&lt;/classname&gt; after each interval of time given
  28  * by the #GstSpectrum:interval property.
  29  *
  30  * The message&#39;s structure contains some combination of these fields:
  31  * &lt;itemizedlist&gt;
  32  * &lt;listitem&gt;
  33  *   &lt;para&gt;
  34  *   #GstClockTime
  35  *   &lt;classname&gt;&amp;quot;timestamp&amp;quot;&lt;/classname&gt;:
  36  *   the timestamp of the buffer that triggered the message.
  37  *   &lt;/para&gt;
  38  * &lt;/listitem&gt;
  39  * &lt;listitem&gt;
  40  *   &lt;para&gt;
  41  *   #GstClockTime
  42  *   &lt;classname&gt;&amp;quot;stream-time&amp;quot;&lt;/classname&gt;:
  43  *   the stream time of the buffer.
  44  *   &lt;/para&gt;
  45  * &lt;/listitem&gt;
  46  * &lt;listitem&gt;
  47  *   &lt;para&gt;
  48  *   #GstClockTime
  49  *   &lt;classname&gt;&amp;quot;running-time&amp;quot;&lt;/classname&gt;:
  50  *   the running_time of the buffer.
  51  *   &lt;/para&gt;
  52  * &lt;/listitem&gt;
  53  * &lt;listitem&gt;
  54  *   &lt;para&gt;
  55  *   #GstClockTime
  56  *   &lt;classname&gt;&amp;quot;duration&amp;quot;&lt;/classname&gt;:
  57  *   the duration of the buffer.
  58  *   &lt;/para&gt;
  59  * &lt;/listitem&gt;
  60  * &lt;listitem&gt;
  61  *   &lt;para&gt;
  62  *   #GstClockTime
  63  *   &lt;classname&gt;&amp;quot;endtime&amp;quot;&lt;/classname&gt;:
  64  *   the end time of the buffer that triggered the message as stream time (this
  65  *   is deprecated, as it can be calculated from stream-time + duration)
  66  *   &lt;/para&gt;
  67  * &lt;/listitem&gt;
  68  * &lt;listitem&gt;
  69  *   &lt;para&gt;
  70  *   #GstValueList of #gfloat
  71  *   &lt;classname&gt;&amp;quot;magnitude&amp;quot;&lt;/classname&gt;:
  72  *   the level for each frequency band in dB. All values below the value of the
  73  *   #GstSpectrum:threshold property will be set to the threshold. Only present
  74  *   if the #GstSpectrum:message-magnitude property is %TRUE.
  75  *   &lt;/para&gt;
  76  * &lt;/listitem&gt;
  77  * &lt;listitem&gt;
  78  *   &lt;para&gt;
  79  *   #GstValueList of #gfloat
  80  *   &lt;classname&gt;&amp;quot;phase&amp;quot;&lt;/classname&gt;:
  81  *   The phase for each frequency band. The value is between -pi and pi. Only
  82  *   present if the #GstSpectrum:message-phase property is %TRUE.
  83  *   &lt;/para&gt;
  84  * &lt;/listitem&gt;
  85  * &lt;/itemizedlist&gt;
  86  *
  87  * If #GstSpectrum:multi-channel property is set to true. magnitude and phase
  88  * fields will be each a nested #GstValueArray. The first dimension are the
  89  * channels and the second dimension are the values.
  90  *
  91  * &lt;refsect2&gt;
  92  * &lt;title&gt;Example application&lt;/title&gt;
  93  * &lt;informalexample&gt;&lt;programlisting language=&quot;C&quot;&gt;
  94  * &lt;xi:include xmlns:xi=&quot;http://www.w3.org/2003/XInclude&quot; parse=&quot;text&quot; href=&quot;../../../../tests/examples/spectrum/spectrum-example.c&quot; /&gt;
  95  * &lt;/programlisting&gt;&lt;/informalexample&gt;
  96  * &lt;/refsect2&gt;
  97  */
  98 
  99 #ifdef HAVE_CONFIG_H
 100 #include &quot;config.h&quot;
 101 #endif
 102 
 103 #include &lt;string.h&gt;
 104 #include &lt;math.h&gt;
 105 #include &quot;gstspectrum.h&quot;
 106 
 107 GST_DEBUG_CATEGORY_STATIC (gst_spectrum_debug);
 108 #define GST_CAT_DEFAULT gst_spectrum_debug
 109 
 110 /* elementfactory information */
 111 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
 112 # define FORMATS &quot;{ S16LE, S24LE, S32LE, F32LE, F64LE }&quot;
 113 #else
 114 # define FORMATS &quot;{ S16BE, S24BE, S32BE, F32BE, F64BE }&quot;
 115 #endif
 116 
 117 #ifdef GSTREAMER_LITE
 118 #define MAX_BANDS    1024
 119 #endif // GSTREAMER_LITE
 120 
 121 #define ALLOWED_CAPS \
 122   GST_AUDIO_CAPS_MAKE (FORMATS) &quot;, &quot; \
 123   &quot;layout = (string) interleaved&quot;
 124 
 125 /* Spectrum properties */
 126 #define DEFAULT_POST_MESSAGES         TRUE
 127 #define DEFAULT_MESSAGE_MAGNITUDE TRUE
 128 #define DEFAULT_MESSAGE_PHASE   FALSE
 129 #define DEFAULT_INTERVAL    (GST_SECOND / 10)
 130 #define DEFAULT_BANDS     128
 131 #define DEFAULT_THRESHOLD   -60
 132 #define DEFAULT_MULTI_CHANNEL   FALSE
 133 
 134 enum
 135 {
 136   PROP_0,
 137   PROP_POST_MESSAGES,
 138   PROP_MESSAGE_MAGNITUDE,
 139   PROP_MESSAGE_PHASE,
 140   PROP_INTERVAL,
 141   PROP_BANDS,
 142   PROP_THRESHOLD,
 143   PROP_MULTI_CHANNEL
 144 };
 145 
 146 #define gst_spectrum_parent_class parent_class
 147 G_DEFINE_TYPE (GstSpectrum, gst_spectrum, GST_TYPE_AUDIO_FILTER);
 148 
 149 static void gst_spectrum_finalize (GObject * object);
 150 static void gst_spectrum_set_property (GObject * object, guint prop_id,
 151     const GValue * value, GParamSpec * pspec);
 152 static void gst_spectrum_get_property (GObject * object, guint prop_id,
 153     GValue * value, GParamSpec * pspec);
 154 static gboolean gst_spectrum_start (GstBaseTransform * trans);
 155 static gboolean gst_spectrum_stop (GstBaseTransform * trans);
 156 static GstFlowReturn gst_spectrum_transform_ip (GstBaseTransform * trans,
 157     GstBuffer * in);
 158 static gboolean gst_spectrum_setup (GstAudioFilter * base,
 159     const GstAudioInfo * info);
 160 
 161 #if defined (GSTREAMER_LITE) &amp;&amp; defined (OSX)
 162 gboolean gst_spectrum_setup_api (GstAudioFilter * base, const GstAudioInfo * info,
 163                                  guint bps_user, guint bpf_user) {
 164     GstSpectrum *spectrum = GST_SPECTRUM (base);
 165     spectrum-&gt;bps_user = bps_user;
 166     spectrum-&gt;bpf_user = bpf_user;
 167     return gst_spectrum_setup(base, info);
 168 }
 169 
 170 GstFlowReturn
 171 gst_spectrum_transform_ip_api (GstBaseTransform * trans, GstBuffer * buffer) {
 172     return gst_spectrum_transform_ip(trans, buffer);
 173 }
 174 #endif // GSTREAMER_LITE and OSX
 175 
 176 static void
 177 gst_spectrum_class_init (GstSpectrumClass * klass)
 178 {
 179   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
 180   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
 181   GstBaseTransformClass *trans_class = GST_BASE_TRANSFORM_CLASS (klass);
 182   GstAudioFilterClass *filter_class = GST_AUDIO_FILTER_CLASS (klass);
 183   GstCaps *caps;
 184 
 185   gobject_class-&gt;set_property = gst_spectrum_set_property;
 186   gobject_class-&gt;get_property = gst_spectrum_get_property;
 187   gobject_class-&gt;finalize = gst_spectrum_finalize;
 188 
 189   trans_class-&gt;start = GST_DEBUG_FUNCPTR (gst_spectrum_start);
 190   trans_class-&gt;stop = GST_DEBUG_FUNCPTR (gst_spectrum_stop);
 191   trans_class-&gt;transform_ip = GST_DEBUG_FUNCPTR (gst_spectrum_transform_ip);
 192   trans_class-&gt;passthrough_on_same_caps = TRUE;
 193 
 194   filter_class-&gt;setup = GST_DEBUG_FUNCPTR (gst_spectrum_setup);
 195 
 196   g_object_class_install_property (gobject_class, PROP_POST_MESSAGES,
 197       g_param_spec_boolean (&quot;post-messages&quot;, &quot;Post Messages&quot;,
 198           &quot;Whether to post a &#39;spectrum&#39; element message on the bus for each &quot;
 199           &quot;passed interval&quot;, DEFAULT_POST_MESSAGES,
 200           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 201 
 202   g_object_class_install_property (gobject_class, PROP_MESSAGE_MAGNITUDE,
 203       g_param_spec_boolean (&quot;message-magnitude&quot;, &quot;Magnitude&quot;,
 204           &quot;Whether to add a &#39;magnitude&#39; field to the structure of any &quot;
 205           &quot;&#39;spectrum&#39; element messages posted on the bus&quot;,
 206           DEFAULT_MESSAGE_MAGNITUDE,
 207           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 208 
 209   g_object_class_install_property (gobject_class, PROP_MESSAGE_PHASE,
 210       g_param_spec_boolean (&quot;message-phase&quot;, &quot;Phase&quot;,
 211           &quot;Whether to add a &#39;phase&#39; field to the structure of any &quot;
 212           &quot;&#39;spectrum&#39; element messages posted on the bus&quot;,
 213           DEFAULT_MESSAGE_PHASE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 214 
 215   g_object_class_install_property (gobject_class, PROP_INTERVAL,
 216       g_param_spec_uint64 (&quot;interval&quot;, &quot;Interval&quot;,
 217           &quot;Interval of time between message posts (in nanoseconds)&quot;,
 218           1, G_MAXUINT64, DEFAULT_INTERVAL,
 219           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 220 
 221 #ifdef GSTREAMER_LITE
 222   g_object_class_install_property (gobject_class, PROP_BANDS,
 223       g_param_spec_uint (&quot;bands&quot;, &quot;Bands&quot;, &quot;Number of frequency bands&quot;,
 224           0, MAX_BANDS, DEFAULT_BANDS,
 225           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 226 #else
 227   g_object_class_install_property (gobject_class, PROP_BANDS,
 228       g_param_spec_uint (&quot;bands&quot;, &quot;Bands&quot;, &quot;Number of frequency bands&quot;,
 229           2, ((guint) G_MAXINT + 2) / 2, DEFAULT_BANDS,
 230           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 231 #endif // GSTREAMER_LITE
 232 
 233   g_object_class_install_property (gobject_class, PROP_THRESHOLD,
 234       g_param_spec_int (&quot;threshold&quot;, &quot;Threshold&quot;,
 235           &quot;dB threshold for result. All lower values will be set to this&quot;,
 236           G_MININT, 0, DEFAULT_THRESHOLD,
 237           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 238 
 239   g_object_class_install_property (gobject_class, PROP_MULTI_CHANNEL,
 240       g_param_spec_boolean (&quot;multi-channel&quot;, &quot;Multichannel results&quot;,
 241           &quot;Send separate results for each channel&quot;,
 242           DEFAULT_MULTI_CHANNEL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 243 
 244   GST_DEBUG_CATEGORY_INIT (gst_spectrum_debug, &quot;spectrum&quot;, 0,
 245       &quot;audio spectrum analyser element&quot;);
 246 
 247   gst_element_class_set_static_metadata (element_class, &quot;Spectrum analyzer&quot;,
 248       &quot;Filter/Analyzer/Audio&quot;,
 249       &quot;Run an FFT on the audio signal, output spectrum data&quot;,
 250       &quot;Erik Walthinsen &lt;omega@cse.ogi.edu&gt;, &quot;
 251       &quot;Stefan Kost &lt;ensonic@users.sf.net&gt;, &quot;
 252       &quot;Sebastian Dr√∂ge &lt;sebastian.droege@collabora.co.uk&gt;&quot;);
 253 
 254   caps = gst_caps_from_string (ALLOWED_CAPS);
 255   gst_audio_filter_class_add_pad_templates (filter_class, caps);
 256   gst_caps_unref (caps);
 257 }
 258 
 259 static void
 260 gst_spectrum_init (GstSpectrum * spectrum)
 261 {
 262   spectrum-&gt;post_messages = DEFAULT_POST_MESSAGES;
 263   spectrum-&gt;message_magnitude = DEFAULT_MESSAGE_MAGNITUDE;
 264   spectrum-&gt;message_phase = DEFAULT_MESSAGE_PHASE;
 265   spectrum-&gt;interval = DEFAULT_INTERVAL;
 266   spectrum-&gt;bands = DEFAULT_BANDS;
 267   spectrum-&gt;threshold = DEFAULT_THRESHOLD;
 268 
 269 #if defined (GSTREAMER_LITE) &amp;&amp; defined (OSX)
 270   spectrum-&gt;bps_user = 0;
 271   spectrum-&gt;bpf_user = 0;
 272   spectrum-&gt;user_data = NULL;
<a name="1" id="anc1"></a><span class="line-added"> 273   spectrum-&gt;post_message_callback = NULL;</span>
 274 #endif // GSTREAMER_LITE and OSX
 275 
 276   g_mutex_init (&amp;spectrum-&gt;lock);
 277 }
 278 
 279 static void
 280 gst_spectrum_alloc_channel_data (GstSpectrum * spectrum)
 281 {
 282   gint i;
 283   GstSpectrumChannel *cd;
 284   guint bands = spectrum-&gt;bands;
 285   guint nfft = 2 * bands - 2;
 286 
 287   g_assert (spectrum-&gt;channel_data == NULL);
 288 
 289   spectrum-&gt;num_channels = (spectrum-&gt;multi_channel) ?
 290       GST_AUDIO_FILTER_CHANNELS (spectrum) : 1;
 291 
 292   GST_DEBUG_OBJECT (spectrum, &quot;allocating data for %d channels&quot;,
 293       spectrum-&gt;num_channels);
 294 
 295   spectrum-&gt;channel_data = g_new (GstSpectrumChannel, spectrum-&gt;num_channels);
 296   for (i = 0; i &lt; spectrum-&gt;num_channels; i++) {
 297     cd = &amp;spectrum-&gt;channel_data[i];
 298     cd-&gt;fft_ctx = gst_fft_f32_new (nfft, FALSE);
 299     cd-&gt;input = g_new0 (gfloat, nfft);
 300     cd-&gt;input_tmp = g_new0 (gfloat, nfft);
 301     cd-&gt;freqdata = g_new0 (GstFFTF32Complex, bands);
 302     cd-&gt;spect_magnitude = g_new0 (gfloat, bands);
 303     cd-&gt;spect_phase = g_new0 (gfloat, bands);
 304   }
 305 }
 306 
 307 static void
 308 gst_spectrum_free_channel_data (GstSpectrum * spectrum)
 309 {
 310   if (spectrum-&gt;channel_data) {
 311     gint i;
 312     GstSpectrumChannel *cd;
 313 
 314     GST_DEBUG_OBJECT (spectrum, &quot;freeing data for %d channels&quot;,
 315         spectrum-&gt;num_channels);
 316 
 317     for (i = 0; i &lt; spectrum-&gt;num_channels; i++) {
 318       cd = &amp;spectrum-&gt;channel_data[i];
 319       if (cd-&gt;fft_ctx)
 320         gst_fft_f32_free (cd-&gt;fft_ctx);
 321       g_free (cd-&gt;input);
 322       g_free (cd-&gt;input_tmp);
 323       g_free (cd-&gt;freqdata);
 324       g_free (cd-&gt;spect_magnitude);
 325       g_free (cd-&gt;spect_phase);
 326     }
 327     g_free (spectrum-&gt;channel_data);
 328     spectrum-&gt;channel_data = NULL;
 329   }
 330 }
 331 
 332 static void
 333 gst_spectrum_flush (GstSpectrum * spectrum)
 334 {
 335   spectrum-&gt;num_frames = 0;
 336   spectrum-&gt;num_fft = 0;
 337 
 338   spectrum-&gt;accumulated_error = 0;
 339 #ifdef GSTREAMER_LITE
 340   spectrum-&gt;input_pos = 0;
 341 #endif // GSTREAMER_LITE
 342 }
 343 
 344 static void
 345 gst_spectrum_reset_state (GstSpectrum * spectrum)
 346 {
 347   GST_DEBUG_OBJECT (spectrum, &quot;resetting state&quot;);
 348 
 349   gst_spectrum_free_channel_data (spectrum);
 350   gst_spectrum_flush (spectrum);
 351 }
 352 
 353 static void
 354 gst_spectrum_finalize (GObject * object)
 355 {
 356   GstSpectrum *spectrum = GST_SPECTRUM (object);
 357 
 358   gst_spectrum_reset_state (spectrum);
 359   g_mutex_clear (&amp;spectrum-&gt;lock);
 360 
 361   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 362 }
 363 
 364 static void
 365 gst_spectrum_set_property (GObject * object, guint prop_id,
 366     const GValue * value, GParamSpec * pspec)
 367 {
 368   GstSpectrum *filter = GST_SPECTRUM (object);
 369 
 370   switch (prop_id) {
 371     case PROP_POST_MESSAGES:
 372       filter-&gt;post_messages = g_value_get_boolean (value);
 373       break;
 374     case PROP_MESSAGE_MAGNITUDE:
 375       filter-&gt;message_magnitude = g_value_get_boolean (value);
 376       break;
 377     case PROP_MESSAGE_PHASE:
 378       filter-&gt;message_phase = g_value_get_boolean (value);
 379       break;
 380     case PROP_INTERVAL:{
 381       guint64 interval = g_value_get_uint64 (value);
 382       g_mutex_lock (&amp;filter-&gt;lock);
 383       if (filter-&gt;interval != interval) {
 384         filter-&gt;interval = interval;
 385         gst_spectrum_reset_state (filter);
 386       }
 387       g_mutex_unlock (&amp;filter-&gt;lock);
 388       break;
 389     }
 390     case PROP_BANDS:{
 391       guint bands = g_value_get_uint (value);
 392       g_mutex_lock (&amp;filter-&gt;lock);
 393       if (filter-&gt;bands != bands) {
 394         filter-&gt;bands = bands;
 395         gst_spectrum_reset_state (filter);
 396       }
 397       g_mutex_unlock (&amp;filter-&gt;lock);
 398       break;
 399     }
 400     case PROP_THRESHOLD:
 401       filter-&gt;threshold = g_value_get_int (value);
 402       break;
 403     case PROP_MULTI_CHANNEL:{
 404       gboolean multi_channel = g_value_get_boolean (value);
 405       g_mutex_lock (&amp;filter-&gt;lock);
 406       if (filter-&gt;multi_channel != multi_channel) {
 407         filter-&gt;multi_channel = multi_channel;
 408         gst_spectrum_reset_state (filter);
 409       }
 410       g_mutex_unlock (&amp;filter-&gt;lock);
 411       break;
 412     }
 413     default:
 414       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 415       break;
 416   }
 417 }
 418 
 419 static void
 420 gst_spectrum_get_property (GObject * object, guint prop_id,
 421     GValue * value, GParamSpec * pspec)
 422 {
 423   GstSpectrum *filter = GST_SPECTRUM (object);
 424 
 425   switch (prop_id) {
 426     case PROP_POST_MESSAGES:
 427       g_value_set_boolean (value, filter-&gt;post_messages);
 428       break;
 429     case PROP_MESSAGE_MAGNITUDE:
 430       g_value_set_boolean (value, filter-&gt;message_magnitude);
 431       break;
 432     case PROP_MESSAGE_PHASE:
 433       g_value_set_boolean (value, filter-&gt;message_phase);
 434       break;
 435     case PROP_INTERVAL:
 436       g_value_set_uint64 (value, filter-&gt;interval);
 437       break;
 438     case PROP_BANDS:
 439       g_value_set_uint (value, filter-&gt;bands);
 440       break;
 441     case PROP_THRESHOLD:
 442       g_value_set_int (value, filter-&gt;threshold);
 443       break;
 444     case PROP_MULTI_CHANNEL:
 445       g_value_set_boolean (value, filter-&gt;multi_channel);
 446       break;
 447     default:
 448       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 449       break;
 450   }
 451 }
 452 
 453 static gboolean
 454 gst_spectrum_start (GstBaseTransform * trans)
 455 {
 456   GstSpectrum *spectrum = GST_SPECTRUM (trans);
 457 
 458   gst_spectrum_reset_state (spectrum);
 459 
 460   return TRUE;
 461 }
 462 
 463 static gboolean
 464 gst_spectrum_stop (GstBaseTransform * trans)
 465 {
 466   GstSpectrum *spectrum = GST_SPECTRUM (trans);
 467 
 468   gst_spectrum_reset_state (spectrum);
 469 
 470   return TRUE;
 471 }
 472 
 473 /* mixing data readers */
 474 
 475 static void
 476 input_data_mixed_float (const guint8 * _in, gfloat * out, guint len,
 477     guint channels, gfloat max_value, guint op, guint nfft)
 478 {
 479   guint i, j, ip = 0;
 480   gfloat v;
 481   gfloat *in = (gfloat *) _in;
 482 
 483   for (j = 0; j &lt; len; j++) {
 484     v = in[ip++];
 485     for (i = 1; i &lt; channels; i++)
 486       v += in[ip++];
 487     out[op] = v / channels;
 488     op = (op + 1) % nfft;
 489   }
 490 }
 491 
 492 static void
 493 input_data_mixed_double (const guint8 * _in, gfloat * out, guint len,
 494     guint channels, gfloat max_value, guint op, guint nfft)
 495 {
 496   guint i, j, ip = 0;
 497   gfloat v;
 498   gdouble *in = (gdouble *) _in;
 499 
 500   for (j = 0; j &lt; len; j++) {
 501     v = in[ip++];
 502     for (i = 1; i &lt; channels; i++)
 503       v += in[ip++];
 504     out[op] = v / channels;
 505     op = (op + 1) % nfft;
 506   }
 507 }
 508 
 509 static void
 510 input_data_mixed_int32_max (const guint8 * _in, gfloat * out, guint len,
 511     guint channels, gfloat max_value, guint op, guint nfft)
 512 {
 513   guint i, j, ip = 0;
 514   gint32 *in = (gint32 *) _in;
 515   gfloat v;
 516 
 517   for (j = 0; j &lt; len; j++) {
 518     v = in[ip++] / max_value;
 519     for (i = 1; i &lt; channels; i++)
 520       v += in[ip++] / max_value;
 521     out[op] = v / channels;
 522     op = (op + 1) % nfft;
 523   }
 524 }
 525 
 526 static void
 527 input_data_mixed_int24_max (const guint8 * _in, gfloat * out, guint len,
 528     guint channels, gfloat max_value, guint op, guint nfft)
 529 {
 530   guint i, j;
 531   gfloat v = 0.0;
 532 
 533   for (j = 0; j &lt; len; j++) {
 534     for (i = 0; i &lt; channels; i++) {
 535 #if G_BYTE_ORDER == G_BIG_ENDIAN
 536       gint32 value = GST_READ_UINT24_BE (_in);
 537 #else
 538       gint32 value = GST_READ_UINT24_LE (_in);
 539 #endif
 540       if (value &amp; 0x00800000)
 541         value |= 0xff000000;
 542       v += value / max_value;
 543       _in += 3;
 544     }
 545     out[op] = v / channels;
 546     op = (op + 1) % nfft;
 547   }
 548 }
 549 
 550 static void
 551 input_data_mixed_int16_max (const guint8 * _in, gfloat * out, guint len,
 552     guint channels, gfloat max_value, guint op, guint nfft)
 553 {
 554   guint i, j, ip = 0;
 555   gint16 *in = (gint16 *) _in;
 556   gfloat v;
 557 
 558   for (j = 0; j &lt; len; j++) {
 559     v = in[ip++] / max_value;
 560     for (i = 1; i &lt; channels; i++)
 561       v += in[ip++] / max_value;
 562     out[op] = v / channels;
 563     op = (op + 1) % nfft;
 564   }
 565 }
 566 
 567 /* non mixing data readers */
 568 
 569 static void
 570 input_data_float (const guint8 * _in, gfloat * out, guint len, guint channels,
 571     gfloat max_value, guint op, guint nfft)
 572 {
 573   guint j, ip;
 574   gfloat *in = (gfloat *) _in;
 575 
 576   for (j = 0, ip = 0; j &lt; len; j++, ip += channels) {
 577     out[op] = in[ip];
 578     op = (op + 1) % nfft;
 579   }
 580 }
 581 
 582 static void
 583 input_data_double (const guint8 * _in, gfloat * out, guint len, guint channels,
 584     gfloat max_value, guint op, guint nfft)
 585 {
 586   guint j, ip;
 587   gdouble *in = (gdouble *) _in;
 588 
 589   for (j = 0, ip = 0; j &lt; len; j++, ip += channels) {
 590     out[op] = in[ip];
 591     op = (op + 1) % nfft;
 592   }
 593 }
 594 
 595 static void
 596 input_data_int32_max (const guint8 * _in, gfloat * out, guint len,
 597     guint channels, gfloat max_value, guint op, guint nfft)
 598 {
 599   guint j, ip;
 600   gint32 *in = (gint32 *) _in;
 601 
 602   for (j = 0, ip = 0; j &lt; len; j++, ip += channels) {
 603     out[op] = in[ip] / max_value;
 604     op = (op + 1) % nfft;
 605   }
 606 }
 607 
 608 static void
 609 input_data_int24_max (const guint8 * _in, gfloat * out, guint len,
 610     guint channels, gfloat max_value, guint op, guint nfft)
 611 {
 612   guint j;
 613 
 614   for (j = 0; j &lt; len; j++) {
 615 #if G_BYTE_ORDER == G_BIG_ENDIAN
 616     gint32 v = GST_READ_UINT24_BE (_in);
 617 #else
 618     gint32 v = GST_READ_UINT24_LE (_in);
 619 #endif
 620     if (v &amp; 0x00800000)
 621       v |= 0xff000000;
 622     _in += 3 * channels;
 623     out[op] = v / max_value;
 624     op = (op + 1) % nfft;
 625   }
 626 }
 627 
 628 static void
 629 input_data_int16_max (const guint8 * _in, gfloat * out, guint len,
 630     guint channels, gfloat max_value, guint op, guint nfft)
 631 {
 632   guint j, ip;
 633   gint16 *in = (gint16 *) _in;
 634 
 635   for (j = 0, ip = 0; j &lt; len; j++, ip += channels) {
 636     out[op] = in[ip] / max_value;
 637     op = (op + 1) % nfft;
 638   }
 639 }
 640 
 641 static gboolean
 642 gst_spectrum_setup (GstAudioFilter * base, const GstAudioInfo * info)
 643 {
 644   GstSpectrum *spectrum = GST_SPECTRUM (base);
 645   gboolean multi_channel = spectrum-&gt;multi_channel;
 646   GstSpectrumInputData input_data = NULL;
 647 
 648   g_mutex_lock (&amp;spectrum-&gt;lock);
 649   switch (GST_AUDIO_INFO_FORMAT (info)) {
 650     case GST_AUDIO_FORMAT_S16:
 651       input_data =
 652           multi_channel ? input_data_int16_max : input_data_mixed_int16_max;
 653       break;
 654     case GST_AUDIO_FORMAT_S24:
 655       input_data =
 656           multi_channel ? input_data_int24_max : input_data_mixed_int24_max;
 657       break;
 658     case GST_AUDIO_FORMAT_S32:
 659       input_data =
 660           multi_channel ? input_data_int32_max : input_data_mixed_int32_max;
 661       break;
 662     case GST_AUDIO_FORMAT_F32:
 663       input_data = multi_channel ? input_data_float : input_data_mixed_float;
 664       break;
 665     case GST_AUDIO_FORMAT_F64:
 666       input_data = multi_channel ? input_data_double : input_data_mixed_double;
 667       break;
 668     default:
 669       g_assert_not_reached ();
 670       break;
 671   }
 672   spectrum-&gt;input_data = input_data;
 673 
 674   gst_spectrum_reset_state (spectrum);
 675   g_mutex_unlock (&amp;spectrum-&gt;lock);
 676 
 677   return TRUE;
 678 }
 679 
 680 static GValue *
 681 gst_spectrum_message_add_container (GstStructure * s, GType type,
 682     const gchar * name)
 683 {
 684   GValue v = { 0, };
 685 
 686   g_value_init (&amp;v, type);
 687   /* will copy-by-value */
 688   gst_structure_set_value (s, name, &amp;v);
 689   g_value_unset (&amp;v);
 690   return (GValue *) gst_structure_get_value (s, name);
 691 }
 692 
 693 static void
 694 gst_spectrum_message_add_list (GValue * cv, gfloat * data, guint num_values)
 695 {
 696   GValue v = { 0, };
 697   guint i;
 698 
 699   g_value_init (&amp;v, G_TYPE_FLOAT);
 700   for (i = 0; i &lt; num_values; i++) {
 701     g_value_set_float (&amp;v, data[i]);
 702     gst_value_list_append_value (cv, &amp;v);       /* copies by value */
 703   }
 704   g_value_unset (&amp;v);
 705 }
 706 
 707 static void
 708 gst_spectrum_message_add_array (GValue * cv, gfloat * data, guint num_values)
 709 {
 710   GValue v = { 0, };
 711   GValue a = { 0, };
 712   guint i;
 713 
 714   g_value_init (&amp;a, GST_TYPE_ARRAY);
 715 
 716   g_value_init (&amp;v, G_TYPE_FLOAT);
 717   for (i = 0; i &lt; num_values; i++) {
 718     g_value_set_float (&amp;v, data[i]);
 719     gst_value_array_append_value (&amp;a, &amp;v);      /* copies by value */
 720   }
 721   g_value_unset (&amp;v);
 722 
 723   gst_value_array_append_value (cv, &amp;a);        /* copies by value */
 724   g_value_unset (&amp;a);
 725 }
 726 
 727 static GstMessage *
 728 gst_spectrum_message_new (GstSpectrum * spectrum, GstClockTime timestamp,
 729     GstClockTime duration)
 730 {
 731   GstBaseTransform *trans = GST_BASE_TRANSFORM_CAST (spectrum);
 732   GstSpectrumChannel *cd;
 733   GstStructure *s;
 734   GValue *mcv = NULL, *pcv = NULL;
 735   GstClockTime endtime, running_time, stream_time;
 736 
 737   GST_DEBUG_OBJECT (spectrum, &quot;preparing message, bands =%d &quot;, spectrum-&gt;bands);
 738 
 739 #if defined (GSTREAMER_LITE) &amp;&amp; defined (OSX)
 740   // When running spectrum directly we cannot figure out time stamps, since we do not
 741   // have full pipeline. Caller will be responsible to handle time stamps.
 742   if (spectrum-&gt;user_data != NULL) {
 743     running_time = 0;
 744     stream_time = 0;
 745   } else {
 746     running_time = gst_segment_to_running_time (&amp;trans-&gt;segment, GST_FORMAT_TIME,
 747       timestamp);
 748     stream_time = gst_segment_to_stream_time (&amp;trans-&gt;segment, GST_FORMAT_TIME,
 749       timestamp);
 750   }
 751 #else // GSTREAMER_LITE and OSX
 752   running_time = gst_segment_to_running_time (&amp;trans-&gt;segment, GST_FORMAT_TIME,
 753       timestamp);
 754   stream_time = gst_segment_to_stream_time (&amp;trans-&gt;segment, GST_FORMAT_TIME,
 755       timestamp);
 756 #endif // GSTREAMER_LITE and OSX
 757   /* endtime is for backwards compatibility */
 758   endtime = stream_time + duration;
 759 
 760   s = gst_structure_new (&quot;spectrum&quot;,
 761       &quot;endtime&quot;, GST_TYPE_CLOCK_TIME, endtime,
 762       &quot;timestamp&quot;, G_TYPE_UINT64, timestamp,
 763       &quot;stream-time&quot;, G_TYPE_UINT64, stream_time,
 764       &quot;running-time&quot;, G_TYPE_UINT64, running_time,
 765       &quot;duration&quot;, G_TYPE_UINT64, duration, NULL);
 766 
 767   if (!spectrum-&gt;multi_channel) {
 768     cd = &amp;spectrum-&gt;channel_data[0];
 769 
 770     if (spectrum-&gt;message_magnitude) {
 771       /* FIXME 0.11: this should be an array, not a list */
 772       mcv = gst_spectrum_message_add_container (s, GST_TYPE_LIST, &quot;magnitude&quot;);
 773       gst_spectrum_message_add_list (mcv, cd-&gt;spect_magnitude, spectrum-&gt;bands);
 774     }
 775     if (spectrum-&gt;message_phase) {
 776       /* FIXME 0.11: this should be an array, not a list */
 777       pcv = gst_spectrum_message_add_container (s, GST_TYPE_LIST, &quot;phase&quot;);
 778       gst_spectrum_message_add_list (pcv, cd-&gt;spect_phase, spectrum-&gt;bands);
 779     }
 780   } else {
 781     guint c;
 782     guint channels = GST_AUDIO_FILTER_CHANNELS (spectrum);
 783 
 784     if (spectrum-&gt;message_magnitude) {
 785       mcv = gst_spectrum_message_add_container (s, GST_TYPE_ARRAY, &quot;magnitude&quot;);
 786     }
 787     if (spectrum-&gt;message_phase) {
 788       pcv = gst_spectrum_message_add_container (s, GST_TYPE_ARRAY, &quot;phase&quot;);
 789     }
 790 
 791     for (c = 0; c &lt; channels; c++) {
 792       cd = &amp;spectrum-&gt;channel_data[c];
 793 
 794       if (spectrum-&gt;message_magnitude) {
 795         gst_spectrum_message_add_array (mcv, cd-&gt;spect_magnitude,
 796             spectrum-&gt;bands);
 797       }
 798       if (spectrum-&gt;message_phase) {
 799         gst_spectrum_message_add_array (pcv, cd-&gt;spect_phase, spectrum-&gt;bands);
 800       }
 801     }
 802   }
 803   return gst_message_new_element (GST_OBJECT (spectrum), s);
 804 }
 805 
 806 static void
 807 gst_spectrum_run_fft (GstSpectrum * spectrum, GstSpectrumChannel * cd,
 808     guint input_pos)
 809 {
 810   guint i;
 811   guint bands = spectrum-&gt;bands;
 812   guint nfft = 2 * bands - 2;
 813   gint threshold = spectrum-&gt;threshold;
 814   gfloat *input = cd-&gt;input;
 815   gfloat *input_tmp = cd-&gt;input_tmp;
 816   gfloat *spect_magnitude = cd-&gt;spect_magnitude;
 817   gfloat *spect_phase = cd-&gt;spect_phase;
 818   GstFFTF32Complex *freqdata = cd-&gt;freqdata;
 819   GstFFTF32 *fft_ctx = cd-&gt;fft_ctx;
 820 
 821   for (i = 0; i &lt; nfft; i++)
 822     input_tmp[i] = input[(input_pos + i) % nfft];
 823 
 824   gst_fft_f32_window (fft_ctx, input_tmp, GST_FFT_WINDOW_HAMMING);
 825 
 826   gst_fft_f32_fft (fft_ctx, input_tmp, freqdata);
 827 
 828   if (spectrum-&gt;message_magnitude) {
 829     gdouble val;
 830     /* Calculate magnitude in db */
 831     for (i = 0; i &lt; bands; i++) {
 832       val = freqdata[i].r * freqdata[i].r;
 833       val += freqdata[i].i * freqdata[i].i;
 834       val /= nfft * nfft;
 835       val = 10.0 * log10 (val);
 836       if (val &lt; threshold)
 837         val = threshold;
 838       spect_magnitude[i] += val;
 839     }
 840   }
 841 
 842   if (spectrum-&gt;message_phase) {
 843     /* Calculate phase */
 844     for (i = 0; i &lt; bands; i++)
 845       spect_phase[i] += atan2 (freqdata[i].i, freqdata[i].r);
 846   }
 847 }
 848 
 849 static void
 850 gst_spectrum_prepare_message_data (GstSpectrum * spectrum,
 851     GstSpectrumChannel * cd)
 852 {
 853   guint i;
 854   guint bands = spectrum-&gt;bands;
 855   guint num_fft = spectrum-&gt;num_fft;
 856 
 857   /* Calculate average */
 858   if (spectrum-&gt;message_magnitude) {
 859     gfloat *spect_magnitude = cd-&gt;spect_magnitude;
 860     for (i = 0; i &lt; bands; i++)
 861       spect_magnitude[i] /= num_fft;
 862   }
 863   if (spectrum-&gt;message_phase) {
 864     gfloat *spect_phase = cd-&gt;spect_phase;
 865     for (i = 0; i &lt; bands; i++)
 866       spect_phase[i] /= num_fft;
 867   }
 868 }
 869 
 870 static void
 871 gst_spectrum_reset_message_data (GstSpectrum * spectrum,
 872     GstSpectrumChannel * cd)
 873 {
 874   guint bands = spectrum-&gt;bands;
 875   gfloat *spect_magnitude = cd-&gt;spect_magnitude;
 876   gfloat *spect_phase = cd-&gt;spect_phase;
 877 
 878   /* reset spectrum accumulators */
 879   memset (spect_magnitude, 0, bands * sizeof (gfloat));
 880   memset (spect_phase, 0, bands * sizeof (gfloat));
 881 }
 882 
 883 static GstFlowReturn
 884 gst_spectrum_transform_ip (GstBaseTransform * trans, GstBuffer * buffer)
 885 {
 886 #ifdef GSTREAMER_LITE
 887   GstMessage *m;
 888 
 889   GstSpectrum *spectrum = GST_SPECTRUM (trans);
 890   guint rate;
 891   guint channels;
 892   guint bps;
 893   guint bpf;
 894   guint output_channels;
 895   guint c;
 896   gfloat max_value;
 897   guint bands;
 898   guint nfft;
 899   guint input_pos;
 900   gfloat *input;
 901   GstMapInfo map;
 902   const guint8 *data;
 903   gsize size;
 904   guint fft_todo, msg_todo, block_size;
 905   gboolean have_full_interval;
 906   GstSpectrumChannel *cd;
 907   GstSpectrumInputData input_data;
 908 
 909   if (!spectrum-&gt;post_messages)
 910       return GST_FLOW_OK;
 911 
 912   rate = GST_AUDIO_FILTER_RATE (spectrum);
 913   channels = GST_AUDIO_FILTER_CHANNELS (spectrum);
 914   bps = GST_AUDIO_FILTER_BPS (spectrum);
 915   bpf = GST_AUDIO_FILTER_BPF (spectrum);
 916 #ifdef OSX
 917   if (spectrum-&gt;bps_user != 0 &amp;&amp; spectrum-&gt;bpf_user != 0) {
 918     bps = spectrum-&gt;bps_user;
 919     bpf = spectrum-&gt;bpf_user;
 920   }
 921 #endif // OSX
 922   output_channels = spectrum-&gt;multi_channel ? channels : 1;
 923   max_value = (1UL &lt;&lt; ((bps &lt;&lt; 3) - 1)) - 1;
 924   bands = spectrum-&gt;bands;
 925   nfft = 2 * bands - 2;
 926 #else // GSTREAMER_LITE
 927 
 928   guint rate = GST_AUDIO_FILTER_RATE (spectrum);
 929   guint channels = GST_AUDIO_FILTER_CHANNELS (spectrum);
 930   guint bps = GST_AUDIO_FILTER_BPS (spectrum);
 931   guint bpf = GST_AUDIO_FILTER_BPF (spectrum);
 932   guint output_channels = spectrum-&gt;multi_channel ? channels : 1;
 933   guint c;
 934   gfloat max_value = (1UL &lt;&lt; ((bps &lt;&lt; 3) - 1)) - 1;
 935   guint bands = spectrum-&gt;bands;
 936   guint nfft = 2 * bands - 2;
 937   guint input_pos;
 938   gfloat *input;
 939   GstMapInfo map;
 940   const guint8 *data;
 941   gsize size;
 942   guint fft_todo, msg_todo, block_size;
 943   gboolean have_full_interval;
 944   GstSpectrumChannel *cd;
 945   GstSpectrumInputData input_data;
 946 #endif // GSTREAMER_LITE
 947 
 948   g_mutex_lock (&amp;spectrum-&gt;lock);
 949   gst_buffer_map (buffer, &amp;map, GST_MAP_READ);
 950   data = map.data;
 951   size = map.size;
 952 
 953   GST_LOG_OBJECT (spectrum, &quot;input size: %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, size);
 954 
 955   if (GST_BUFFER_IS_DISCONT (buffer)) {
 956     GST_DEBUG_OBJECT (spectrum, &quot;Discontinuity detected -- flushing&quot;);
 957     gst_spectrum_flush (spectrum);
 958   }
 959 
 960   /* If we don&#39;t have a FFT context yet (or it was reset due to parameter
 961    * changes) get one and allocate memory for everything
 962    */
 963   if (spectrum-&gt;channel_data == NULL) {
 964     GST_DEBUG_OBJECT (spectrum, &quot;allocating for bands %u&quot;, bands);
 965 
 966     gst_spectrum_alloc_channel_data (spectrum);
 967 
 968     /* number of sample frames we process before posting a message
 969      * interval is in ns */
 970     spectrum-&gt;frames_per_interval =
 971         gst_util_uint64_scale (spectrum-&gt;interval, rate, GST_SECOND);
 972     spectrum-&gt;frames_todo = spectrum-&gt;frames_per_interval;
 973     /* rounding error for frames_per_interval in ns,
 974      * aggregated it in accumulated_error */
 975     spectrum-&gt;error_per_interval = (spectrum-&gt;interval * rate) % GST_SECOND;
 976     if (spectrum-&gt;frames_per_interval == 0)
 977       spectrum-&gt;frames_per_interval = 1;
 978 
 979     GST_INFO_OBJECT (spectrum, &quot;interval %&quot; GST_TIME_FORMAT &quot;, fpi %&quot;
 980         G_GUINT64_FORMAT &quot;, error %&quot; GST_TIME_FORMAT,
 981         GST_TIME_ARGS (spectrum-&gt;interval), spectrum-&gt;frames_per_interval,
 982         GST_TIME_ARGS (spectrum-&gt;error_per_interval));
 983 
 984     spectrum-&gt;input_pos = 0;
 985 
 986     gst_spectrum_flush (spectrum);
 987   }
 988 
 989   if (spectrum-&gt;num_frames == 0)
 990     spectrum-&gt;message_ts = GST_BUFFER_TIMESTAMP (buffer);
 991 
 992   input_pos = spectrum-&gt;input_pos;
 993   input_data = spectrum-&gt;input_data;
 994 
 995   while (size &gt;= bpf) {
 996     /* run input_data for a chunk of data */
 997     fft_todo = nfft - (spectrum-&gt;num_frames % nfft);
 998     msg_todo = spectrum-&gt;frames_todo - spectrum-&gt;num_frames;
 999     GST_LOG_OBJECT (spectrum,
1000         &quot;message frames todo: %u, fft frames todo: %u, input frames %&quot;
1001         G_GSIZE_FORMAT, msg_todo, fft_todo, (size / bpf));
1002     block_size = msg_todo;
1003     if (block_size &gt; (size / bpf))
1004       block_size = (size / bpf);
1005     if (block_size &gt; fft_todo)
1006       block_size = fft_todo;
1007 
1008     for (c = 0; c &lt; output_channels; c++) {
1009       cd = &amp;spectrum-&gt;channel_data[c];
1010       input = cd-&gt;input;
1011       /* Move the current frames into our ringbuffers */
1012       input_data (data + c * bps, input, block_size, channels, max_value,
1013           input_pos, nfft);
1014     }
1015     data += block_size * bpf;
1016     size -= block_size * bpf;
1017     input_pos = (input_pos + block_size) % nfft;
1018     spectrum-&gt;num_frames += block_size;
1019 
1020     have_full_interval = (spectrum-&gt;num_frames == spectrum-&gt;frames_todo);
1021 
1022     GST_LOG_OBJECT (spectrum,
1023         &quot;size: %&quot; G_GSIZE_FORMAT &quot;, do-fft = %d, do-message = %d&quot;, size,
1024         (spectrum-&gt;num_frames % nfft == 0), have_full_interval);
1025 
1026     /* If we have enough frames for an FFT or we have all frames required for
1027      * the interval and we haven&#39;t run a FFT, then run an FFT */
1028     if ((spectrum-&gt;num_frames % nfft == 0) ||
1029         (have_full_interval &amp;&amp; !spectrum-&gt;num_fft)) {
1030       for (c = 0; c &lt; output_channels; c++) {
1031         cd = &amp;spectrum-&gt;channel_data[c];
1032         gst_spectrum_run_fft (spectrum, cd, input_pos);
1033       }
1034       spectrum-&gt;num_fft++;
1035     }
1036 
1037     /* Do we have the FFTs for one interval? */
1038     if (have_full_interval) {
1039       GST_DEBUG_OBJECT (spectrum, &quot;nfft: %u frames: %&quot; G_GUINT64_FORMAT
1040           &quot; fpi: %&quot; G_GUINT64_FORMAT &quot; error: %&quot; GST_TIME_FORMAT, nfft,
1041           spectrum-&gt;num_frames, spectrum-&gt;frames_per_interval,
1042           GST_TIME_ARGS (spectrum-&gt;accumulated_error));
1043 
1044       spectrum-&gt;frames_todo = spectrum-&gt;frames_per_interval;
1045       if (spectrum-&gt;accumulated_error &gt;= GST_SECOND) {
1046         spectrum-&gt;accumulated_error -= GST_SECOND;
1047         spectrum-&gt;frames_todo++;
1048       }
1049       spectrum-&gt;accumulated_error += spectrum-&gt;error_per_interval;
1050 
1051 #ifndef GSTREAMER_LITE
1052       if (spectrum-&gt;post_messages) {
1053         GstMessage *m;
1054 #endif // GSTREAMER_LITE
1055 
1056         for (c = 0; c &lt; output_channels; c++) {
1057           cd = &amp;spectrum-&gt;channel_data[c];
1058           gst_spectrum_prepare_message_data (spectrum, cd);
1059         }
1060 
1061         m = gst_spectrum_message_new (spectrum, spectrum-&gt;message_ts,
1062             spectrum-&gt;interval);
1063 
<a name="2" id="anc2"></a><span class="line-added">1064 #if defined (GSTREAMER_LITE) &amp;&amp; defined (OSX)</span>
<span class="line-added">1065         if (spectrum-&gt;post_message_callback != NULL) {</span>
<span class="line-added">1066           spectrum-&gt;post_message_callback(GST_ELEMENT (spectrum), m);</span>
<span class="line-added">1067         } else {</span>
<span class="line-added">1068           gst_element_post_message (GST_ELEMENT (spectrum), m);</span>
<span class="line-added">1069         }</span>
<span class="line-added">1070 #else // GSTREAMER_LITE &amp;&amp; OSX</span>
1071         gst_element_post_message (GST_ELEMENT (spectrum), m);
<a name="3" id="anc3"></a><span class="line-added">1072 #endif // GSTREAMER_LITE &amp;&amp; OSX</span>
1073 #ifndef GSTREAMER_LITE
1074       }
1075 #endif // GSTREAMER_LITE
1076 
1077       if (GST_CLOCK_TIME_IS_VALID (spectrum-&gt;message_ts))
1078         spectrum-&gt;message_ts +=
1079             gst_util_uint64_scale (spectrum-&gt;num_frames, GST_SECOND, rate);
1080 
1081 #ifdef GSTREAMER_LITE
1082       for (c = 0; c &lt; spectrum-&gt;num_channels; c++) {
1083 #else // GSTREAMER_LITE
1084       for (c = 0; c &lt; output_channels; c++) {
1085 #endif // GSTREAMER_LITE
1086         cd = &amp;spectrum-&gt;channel_data[c];
1087         gst_spectrum_reset_message_data (spectrum, cd);
1088       }
1089       spectrum-&gt;num_frames = 0;
1090       spectrum-&gt;num_fft = 0;
1091     }
1092   }
1093 
1094   spectrum-&gt;input_pos = input_pos;
1095 
1096   gst_buffer_unmap (buffer, &amp;map);
1097   g_mutex_unlock (&amp;spectrum-&gt;lock);
1098 
1099   g_assert (size == 0);
1100 
1101   return GST_FLOW_OK;
1102 }
1103 
1104 #ifdef GSTREAMER_LITE
1105 gboolean
1106 plugin_init_spectrum (GstPlugin * plugin)
1107 #else // GSTREAMER_LITE
1108 static gboolean
1109 plugin_init (GstPlugin * plugin)
1110 #endif // GSTREAMER_LITE
1111 {
1112   return gst_element_register (plugin, &quot;spectrum&quot;, GST_RANK_NONE,
1113       GST_TYPE_SPECTRUM);
1114 }
1115 
1116 #ifndef GSTREAMER_LITE
1117 GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
1118     GST_VERSION_MINOR,
1119     spectrum,
1120     &quot;Run an FFT on the audio signal, output spectrum data&quot;,
1121     plugin_init, VERSION, GST_LICENSE, GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
1122 #endif // GSTREAMER_LITE
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
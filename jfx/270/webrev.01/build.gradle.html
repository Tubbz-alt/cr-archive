<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New build.gradle</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /**
  27  * The main build script for JavaFX.
  28  *
  29  * MUST FIX tasks to complete:
  30  *  - build check -- making sure the final artifact has the right bits
  31  *      - some things worth automatically sanity checking:
  32  *          - are there images in the javadocs?
  33  *          - are all of the expected dylibs etc there?
  34  *  - Perform sanity checking to make sure a JDK exists with javac, etc
  35  *  - Support building with no known JDK location, as long as javac, etc are on the path
  36  *  - Check all of the native flags. We&#39;re adding weight to some libs that don&#39;t need it, and so forth.
  37  *
  38  * Additional projects to work on as we go:
  39  *  - Add &quot;developer debug&quot;. This is where the natives do not have debug symbols, but the Java code does
  40  *  - The genVSproperties.bat doesn&#39;t find the directory where RC.exe lives. So it is hard coded. Might be a problem.
  41  *  - special tasks for common needs, such as:
  42  *      - updating copyright headers
  43  *      - stripping trailing whitespace (?)
  44  *  - checkstyle
  45  *  - findbugs
  46  *  - re needs?
  47  *  - sqe testing
  48  *  - API change check
  49  *  - Pushing results to a repo?
  50  *  - ServiceWithSecurityManagerTest fails to complete when run from gradle.
  51  *  - Integrate Parfait reports for C code
  52  *  - FXML Project tests are not running
  53  */
  54 defaultTasks = [&quot;sdk&quot;]
  55 
  56 import java.util.concurrent.CountDownLatch
  57 import java.util.concurrent.ExecutorService
  58 import java.util.concurrent.Executors
  59 import java.util.concurrent.Future
  60 
  61 /******************************************************************************
  62  *                              Utility methods                               *
  63  *****************************************************************************/
  64 
  65 /**
  66  * If the given named property is not defined, then this method will define
  67  * it with the given defaultValue. Any properties defined by this method can
  68  * be substituted on the command line by using -P, or by specifying a
  69  * gradle.properties file in the user home dir
  70  *
  71  * @param name The name of the property to define
  72  * @param defaultValue The default value to assign the property
  73  */
  74 void defineProperty(String name, String defaultValue) {
  75     if (!project.hasProperty(name)) {
  76         project.ext.set(name, defaultValue);
  77     }
  78 }
  79 
  80 /**
  81  * If the given named property is not defined, then this method will attempt to
  82  * look up the property in the props map, and use the defaultValue if it cannot be found.
  83  *
  84  * @param name The name of the property to look up and/or define
  85  * @param props The properties to look for the named property in, if it has not already been defined
  86  * @param defaultValue The default value if the property has not been defined and the
  87  *                     props map does not contain the named property
  88  */
  89 void defineProperty(String name, Properties props, String defaultValue) {
  90     if (!project.hasProperty(name)) {
  91         project.ext.set(name, props.getProperty(name, defaultValue));
  92     }
  93 }
  94 
  95 /**
  96  * Converts cygwin style paths to windows style paths, but with a forward slash.
  97  * This method is safe to call from any platform, and will only do work if
  98  * called on Windows (in all other cases it simply returns the supplied path.
  99  *
 100  * @param path the path to convert
 101  * @return the path converted to windows style, if on windows, otherwise it
 102  *         is the supplied path.
 103  */
 104 String cygpath(String path) {
 105     if (!IS_WINDOWS) return path;
 106     if (path == null || &quot;&quot;.equals(path)) return path;
 107     String ret = path.replaceAll(&#39;\\\\&#39;, &#39;/&#39;)
 108     logger.info(&quot;Converting path &#39;$path&#39; via cygpath to &quot;+ret)
 109     return ret
 110 }
 111 
 112 /**
 113  * Converts cygwin file paths for java executables to windows style
 114  * executable paths by changing forward slashes to back slashes and
 115  * adding the &#39;.exe&#39; extension.
 116  * This method is safe to call from any platform, and will only do work if
 117  * called on Windows (in all other cases it simply returns the supplied path).
 118  *
 119  * @param path the path to convert
 120  * @return the path converted to windows style, if on windows, otherwise it
 121  *         is the supplied path.
 122  */
 123 String cygpathExe(String path) {
 124     if (!IS_WINDOWS) return path;
 125     if (path == null || &quot;&quot;.equals(path)) return path;
 126     String ret = path.replaceAll(&#39;/&#39;, &#39;\\\\&#39;)
 127     logger.info(&quot;Converting path &#39;$path&#39; via cygpath to &quot;+ret)
 128     return ret + &quot;.exe&quot;
 129 }
 130 
 131 void loadProperties(String sourceFileName) {
 132     def config = new Properties()
 133     def propFile = new File(sourceFileName)
 134     if (propFile.canRead()) {
 135         config.load(new FileInputStream(propFile))
 136         for (java.util.Map.Entry property in config) {
 137             def keySplit = property.key.split(&quot;\\.&quot;);
 138             def key = keySplit[0];
 139             for (int i = 1; i &lt; keySplit.length; i++) {
 140                 key = key + keySplit[i].capitalize();
 141             }
 142             ext[key] = property.value;
 143         }
 144     }
 145 }
 146 
 147 /**
 148  * Struct used to contain some information passed to the closure
 149  * passed to compileTargets.
 150  */
 151 class CompileTarget {
 152     String name;
 153     String upper;
 154     String capital;
 155 }
 156 
 157 /**
 158  * Iterates over each of the compile targets, passing the given closure
 159  * a CompileTarget instance.
 160  *
 161  * @param c The closure to call
 162  */
 163 void compileTargets(Closure c) {
 164     if (COMPILE_TARGETS == &quot;&quot;) {
 165         return
 166     }
 167     COMPILE_TARGETS.split(&quot;,&quot;).each { target -&gt;
 168         CompileTarget ct = new CompileTarget();
 169         ct.name = target;
 170         ct.upper = target.trim().toUpperCase(Locale.ROOT)
 171         ct.capital = target.trim().capitalize()
 172         c(ct)
 173     }
 174 }
 175 
 176 /**
 177  * Manages the execution of some closure which is responsible for producing
 178  * content for a properties file built at build time and stored in the
 179  * root project&#39;s $buildDir, and then loading that properties file and
 180  * passing it to the processor closure.
 181  *
 182  * This is used on windows to produce a properties file containing all the
 183  * windows visual studio paths and environment variables, and on Linux
 184  * for storing the results of pkg-config calls.
 185  *
 186  * @param name the name of the file to produce
 187  * @param loader a closure which is invoked, given the properties file. This
 188  *        closure is invoked only if the properties file needs to be created
 189  *        and is responsible for populating the properties file.
 190  * @param processor a closure which is invoked every time this method is
 191  *        called and which will be given a Properties object, fully populated.
 192  *        The processor is then responsible for doing whatever it is that it
 193  *        must do with those properties (such as setting up environment
 194  *        variables used in subsequent native builds, or whatnot).
 195  */
 196 void setupTools(String name, Closure loader, Closure processor) {
 197     // Check to see whether $buildDir/$name.properties file exists. If not,
 198     // then generate it. Once generated, we need to read the properties file to
 199     // help us define the defaults for this block of properties
 200     File propFile = file(&quot;$buildDir/${name}.properties&quot;);
 201     if (!propFile.exists()) {
 202         // Create the properties file
 203         propFile.getParentFile().mkdirs();
 204         propFile.createNewFile();
 205         loader(propFile);
 206     }
 207 
 208     // Try reading the properties in order to define the properties. If the property file cannot
 209     // be located, then we will throw an exception because we cannot guess these values
 210     InputStream propStream = null;
 211     try {
 212         Properties properties = new Properties();
 213         propStream = new FileInputStream(propFile);
 214         properties.load(propStream);
 215         processor(properties);
 216     } finally {
 217         try { propStream.close() } catch (Exception e) { }
 218     }
 219 }
 220 
 221 String[] parseJavaVersion(String jRuntimeVersion) {
 222     def jVersion = jRuntimeVersion.split(&quot;[-\\+]&quot;)[0]
 223     def tmpBuildNumber = &quot;0&quot;
 224     if (jVersion.startsWith(&quot;1.&quot;)) {
 225         // This is a pre-JEP-223 version string
 226         def dashbIdx = jRuntimeVersion.lastIndexOf(&quot;-b&quot;)
 227         if (dashbIdx != -1) {
 228             tmpBuildNumber = jRuntimeVersion.substring(dashbIdx + 2)
 229         }
 230     } else {
 231         // This is a post-JEP-223 version string
 232         def plusIdx = jRuntimeVersion.indexOf(&quot;+&quot;)
 233         if (plusIdx != -1) {
 234             tmpBuildNumber = jRuntimeVersion.substring(plusIdx + 1)
 235         }
 236     }
 237     def jBuildNumber = tmpBuildNumber.split(&quot;[-\\+]&quot;)[0]
 238     def versionInfo = new String[2];
 239     versionInfo[0] = jVersion
 240     versionInfo[1] = jBuildNumber
 241     return versionInfo
 242 }
 243 
 244 /**
 245  * Fails the build with the specified error message
 246  *
 247  * @param msg the reason for the failure
 248  */
 249 void fail(String msg) {
 250     throw new GradleException(&quot;FAIL: &quot; + msg);
 251 }
 252 
 253 /******************************************************************************
 254  *                                                                            *
 255  *                   Definition of project properties                         *
 256  *                                                                            *
 257  *  All properties defined using ext. are immediately available throughout    *
 258  *  the script as variables that can be used. These variables are attached    *
 259  *  to the root project (whereas if they were defined as def variables then   *
 260  *  they would only be available within the root project scope).              *
 261  *                                                                            *
 262  *  All properties defined using the &quot;defineProperty&quot; method can be replaced  *
 263  *  on the command line by using the -P flag. For example, to override the    *
 264  *  location of the binary plug, you would specify -PBINARY_PLUG=some/where   *
 265  *                                                                            *
 266  *****************************************************************************/
 267 
 268 // If the ../rt-closed directory exists, then we are doing a closed build.
 269 // In this case, build and property files will be read from
 270 // ../rt-closed/closed-build.gradle and ../rt-closed/closed-properties.gradle
 271 // respectively
 272 
 273 def closedDir = file(&quot;../rt-closed&quot;)
 274 def buildClosed = closedDir.isDirectory()
 275 ext.BUILD_CLOSED = buildClosed
 276 
 277 ext.RUNARGSFILE = &quot;run.args&quot;
 278 ext.COMPILEARGSFILE = &quot;compile.args&quot;
 279 ext.RUNJAVAPOLICYFILE = &#39;run.java.policy&#39;
 280 
 281 ext.TESTCOMPILEARGSFILE = &quot;testcompile.args&quot;
 282 ext.TESTRUNARGSFILE = &quot;testrun.args&quot;
 283 ext.TESTJAVAPOLICYFILE = &#39;test.java.policy&#39;
 284 
 285 // the file containing &quot;extra&quot; --add-exports
 286 ext.EXTRAADDEXPORTS = &#39;buildSrc/addExports&#39;
 287 
 288 ext.MODULESOURCEPATH = &quot;modulesourcepath.args&quot;
 289 
 290 // These variables indicate what platform is running the build. Is
 291 // this build running on a Mac, Windows, or Linux machine? 32 or 64 bit?
 292 ext.OS_NAME = System.getProperty(&quot;os.name&quot;).toLowerCase()
 293 ext.OS_ARCH = System.getProperty(&quot;os.arch&quot;)
 294 ext.IS_64 = OS_ARCH.toLowerCase().contains(&quot;64&quot;)
 295 ext.IS_MAC = OS_NAME.contains(&quot;mac&quot;) || OS_NAME.contains(&quot;darwin&quot;)
 296 ext.IS_WINDOWS = OS_NAME.contains(&quot;windows&quot;)
 297 ext.IS_LINUX = OS_NAME.contains(&quot;linux&quot;)
 298 
 299 ext.MAVEN_GROUP_ID = &quot;org.openjfx&quot;
 300 
 301 // Verify that the architecture &amp; OS are supported configurations. Note that
 302 // at present building on PI is not supported, but we would only need to make
 303 // some changes on assumptions on what should be built (like SWT / Swing) and
 304 // such and we could probably make it work.
 305 if (!IS_MAC &amp;&amp; !IS_WINDOWS &amp;&amp; !IS_LINUX) fail(&quot;Unsupported build OS ${OS_NAME}&quot;)
 306 if (IS_WINDOWS &amp;&amp; OS_ARCH != &quot;x86&quot; &amp;&amp; OS_ARCH != &quot;amd64&quot;) {
 307     fail(&quot;Unknown and unsupported build architecture: $OS_ARCH&quot;)
 308 } else if (IS_MAC &amp;&amp; OS_ARCH != &quot;x86_64&quot;) {
 309     fail(&quot;Unknown and unsupported build architecture: $OS_ARCH&quot;)
 310 } else if (IS_LINUX &amp;&amp; OS_ARCH != &quot;i386&quot; &amp;&amp; OS_ARCH != &quot;amd64&quot;) {
 311     fail(&quot;Unknown and unsupported build architecture: $OS_ARCH&quot;)
 312 }
 313 
 314 
 315 // Get the JDK_HOME automatically based on the version of Java used to execute gradle. Or, if specified,
 316 // use a user supplied JDK_HOME, STUB_RUNTIME, JAVAC, all of which may be specified
 317 // independently (or we&#39;ll try to get the right one based on other supplied info). Sometimes the
 318 // JRE might be the thing that is being used instead of the JRE embedded in the JDK, such as:
 319 //    c:\Program Files (x86)\Java\jdk1.8.0\jre
 320 //    c:\Program Files (x86)\Java\jre8\
 321 // Because of this, you may sometimes get the jdk&#39;s JRE (in which case the logic we used to have here
 322 // was correct and consistent with all other platforms), or it might be the standalone JRE (for the love!).
 323 def envJavaHome = cygpath(System.getenv(&quot;JDK_HOME&quot;))
 324 if (envJavaHome == null || envJavaHome.equals(&quot;&quot;)) envJavaHome = cygpath(System.getenv(&quot;JAVA_HOME&quot;))
 325 def javaHome = envJavaHome == null || envJavaHome.equals(&quot;&quot;) ? System.getProperty(&quot;java.home&quot;) : envJavaHome
 326 def javaHomeFile = file(javaHome)
 327 defineProperty(&quot;JDK_HOME&quot;,
 328         javaHomeFile.name == &quot;jre&quot; ?
 329         javaHomeFile.getParent().toString() :
 330         javaHomeFile.name.startsWith(&quot;jre&quot;) ?
 331         new File(javaHomeFile.getParent(), &quot;jdk1.${javaHomeFile.name.substring(3)}.0&quot;).toString() :
 332         javaHome) // we have to bail and set it to something and this is as good as any!
 333 ext.JAVA_HOME = JDK_HOME
 334 
 335 defineProperty(&quot;JAVA&quot;, cygpathExe(&quot;$JDK_HOME/bin/java&quot;))
 336 defineProperty(&quot;JAVAC&quot;, cygpathExe(&quot;$JDK_HOME/bin/javac&quot;))
 337 defineProperty(&quot;JAVADOC&quot;, cygpathExe(&quot;$JDK_HOME/bin/javadoc&quot;))
 338 defineProperty(&quot;JMOD&quot;, cygpathExe(&quot;$JDK_HOME/bin/jmod&quot;))
 339 defineProperty(&quot;JDK_DOCS&quot;, &quot;https://docs.oracle.com/en/java/javase/12/docs/api/&quot;)
 340 defineProperty(&quot;JDK_JMODS&quot;, cygpath(System.getenv(&quot;JDK_JMODS&quot;)) ?: cygpath(System.getenv(&quot;JDK_HOME&quot;) + &quot;/jmods&quot;))
 341 
 342 defineProperty(&quot;javaRuntimeVersion&quot;, System.getProperty(&quot;java.runtime.version&quot;))
 343 def javaVersionInfo = parseJavaVersion(javaRuntimeVersion)
 344 defineProperty(&quot;javaVersion&quot;, javaVersionInfo[0])
 345 defineProperty(&quot;javaBuildNumber&quot;, javaVersionInfo[1])
 346 
 347 defineProperty(&quot;libAVRepositoryURL&quot;, &quot;https://libav.org/releases/&quot;)
 348 defineProperty(&quot;FFmpegRepositoryURL&quot;, &quot;https://www.ffmpeg.org/releases/&quot;)
 349 
 350 loadProperties(&quot;$projectDir/build.properties&quot;)
 351 
 352 def supplementalPreBuildFile = file(&quot;$closedDir/closed-pre-build.gradle&quot;);
 353 def supplementalBuildFile = file(&quot;$closedDir/closed-build.gradle&quot;);
 354 
 355 if (BUILD_CLOSED) {
 356     apply from: supplementalPreBuildFile
 357 }
 358 
 359 // GRADLE_VERSION_CHECK specifies whether to fail the build if the
 360 // gradle version check fails
 361 defineProperty(&quot;GRADLE_VERSION_CHECK&quot;, &quot;true&quot;)
 362 ext.IS_GRADLE_VERSION_CHECK = Boolean.parseBoolean(GRADLE_VERSION_CHECK)
 363 
 364 // JFX_DEPS_URL specifies the optional location of an alternate local repository
 365 defineProperty(&quot;JFX_DEPS_URL&quot;, &quot;&quot;)
 366 
 367 // JDK_DOCS_LINK specifies the optional URL for offline javadoc linking
 368 defineProperty(&quot;JDK_DOCS_LINK&quot;, &quot;&quot;)
 369 
 370 // COMPILE_WEBKIT specifies whether to build all of webkit.
 371 defineProperty(&quot;COMPILE_WEBKIT&quot;, &quot;false&quot;)
 372 ext.IS_COMPILE_WEBKIT = Boolean.parseBoolean(COMPILE_WEBKIT)
 373 
 374 // COMPILE_MEDIA specifies whether to build all of media.
 375 defineProperty(&quot;COMPILE_MEDIA&quot;, &quot;false&quot;)
 376 ext.IS_COMPILE_MEDIA = Boolean.parseBoolean(COMPILE_MEDIA)
 377 
 378 // BUILD_LIBAV_STUBS specifies whether to download and build libav/ffmpeg libraries
 379 defineProperty(&quot;BUILD_LIBAV_STUBS&quot;, &quot;false&quot;)
 380 ext.IS_BUILD_LIBAV_STUBS = IS_LINUX ? Boolean.parseBoolean(BUILD_LIBAV_STUBS) : false
 381 
 382 // BUILD_WORKING_LIBAV specifies whether to build libav/ffmpeg libraries with
 383 // decoder, demuxer, etc. required to run media. Valid only if BUILD_LIBAV_STUBS is true.
 384 defineProperty(&quot;BUILD_WORKING_LIBAV&quot;, &quot;false&quot;)
 385 ext.IS_BUILD_WORKING_LIBAV = IS_LINUX ? Boolean.parseBoolean(BUILD_WORKING_LIBAV) : false
 386 
 387 // COMPILE_PANGO specifies whether to build javafx_font_pango.
 388 defineProperty(&quot;COMPILE_PANGO&quot;, &quot;${IS_LINUX}&quot;)
 389 ext.IS_COMPILE_PANGO = Boolean.parseBoolean(COMPILE_PANGO)
 390 
 391 // COMPILE_HARFBUZZ specifies whether to use Harfbuzz.
 392 defineProperty(&quot;COMPILE_HARFBUZZ&quot;, &quot;false&quot;)
 393 ext.IS_COMPILE_HARFBUZZ = Boolean.parseBoolean(COMPILE_HARFBUZZ)
 394 
 395 // COMPILE_PARFAIT specifies whether to build parfait
 396 defineProperty(&quot;COMPILE_PARFAIT&quot;, &quot;false&quot;)
 397 ext.IS_COMPILE_PARFAIT = Boolean.parseBoolean(COMPILE_PARFAIT)
 398 
 399 defineProperty(&quot;STATIC_BUILD&quot;, &quot;false&quot;)
 400 ext.IS_STATIC_BUILD = Boolean.parseBoolean(STATIC_BUILD)
 401 
 402 if (IS_STATIC_BUILD &amp;&amp; IS_COMPILE_MEDIA) {
 403     throw new GradleException(&quot;Can not have COMPILE_MEDIA when STATIC_BUILD is enabled&quot;);
 404 }
 405 
 406 // BUILD_TOOLS_DOWNLOAD_SCRIPT specifies a path of a gradle script which downloads
 407 // required build tools.
 408 defineProperty(&quot;BUILD_TOOLS_DOWNLOAD_SCRIPT&quot;, &quot;&quot;)
 409 
 410 // Define the SWT.jar that we are going to have to download during the build process based
 411 // on what platform we are compiling from (not based on our target).
 412 ext.SWT_FILE_NAME = IS_MAC ? &quot;org.eclipse.swt.cocoa.macosx.x86_64_3.105.3.v20170228-0512&quot; :
 413     IS_WINDOWS &amp;&amp; IS_64 ? &quot;org.eclipse.swt.win32.win32.x86_64_3.105.3.v20170228-0512&quot; :
 414     IS_WINDOWS &amp;&amp; !IS_64 ? &quot;org.eclipse.swt.win32.win32.x86_3.105.3.v20170228-0512&quot; :
 415     IS_LINUX &amp;&amp; IS_64 ? &quot;org.eclipse.swt.gtk.linux.x86_64_3.105.3.v20170228-0512&quot; :
 416     IS_LINUX &amp;&amp; !IS_64 ? &quot;org.eclipse.swt.gtk.linux.x86_3.105.3.v20170228-0512&quot; : &quot;&quot;
 417 
 418 // Specifies whether to run full tests (true) or smoke tests (false)
 419 defineProperty(&quot;FULL_TEST&quot;, &quot;false&quot;)
 420 ext.IS_FULL_TEST = Boolean.parseBoolean(FULL_TEST);
 421 
 422 defineProperty(&quot;FORCE_TESTS&quot;, &quot;false&quot;)
 423 ext.IS_FORCE_TESTS = Boolean.parseBoolean(FORCE_TESTS);
 424 
 425 // Specifies whether to run robot-based visual tests (only used when FULL_TEST is also enabled)
 426 defineProperty(&quot;USE_ROBOT&quot;, &quot;false&quot;)
 427 ext.IS_USE_ROBOT = Boolean.parseBoolean(USE_ROBOT);
 428 
 429 // Specified whether to run tests in headless mode
 430 defineProperty(&quot;HEADLESS_TEST&quot;, &quot;false&quot;)
 431 ext.IS_HEADLESS_TEST = Boolean.parseBoolean(HEADLESS_TEST);
 432 
 433 // Specifies whether to run system tests that depend on AWT (only used when FULL_TEST is also enabled)
 434 defineProperty(&quot;AWT_TEST&quot;, &quot;true&quot;)
 435 ext.IS_AWT_TEST = Boolean.parseBoolean(AWT_TEST);
 436 
 437 // Specifies whether to run system tests that depend on SWT (only used when FULL_TEST is also enabled)
 438 defineProperty(&quot;SWT_TEST&quot;, &quot;true&quot;)
 439 ext.IS_SWT_TEST = Boolean.parseBoolean(SWT_TEST);
 440 
 441 // Specifies whether to run unstable tests (true) - tests that don&#39;t run well with Hudson builds
 442 // These tests should be protected with :
 443 //    assumeTrue(Boolean.getBoolean(&quot;unstable.test&quot;));
 444 defineProperty(&quot;UNSTABLE_TEST&quot;, &quot;false&quot;)
 445 ext.IS_UNSTABLE_TEST = Boolean.parseBoolean(UNSTABLE_TEST);
 446 
 447 // Toggle diagnostic output from the Gradle workaround and the Sandbox test apps.
 448 defineProperty(&quot;WORKER_DEBUG&quot;, &quot;false&quot;)
 449 ext.IS_WORKER_DEBUG = Boolean.parseBoolean(WORKER_DEBUG);
 450 
 451 // Specify the build configuration (Release, Debug, or DebugNative)
 452 defineProperty(&quot;CONF&quot;, &quot;Debug&quot;)
 453 ext.IS_DEBUG_JAVA = CONF == &quot;Debug&quot; || CONF == &quot;DebugNative&quot;
 454 ext.IS_DEBUG_NATIVE = CONF == &quot;DebugNative&quot;
 455 
 456 // Specifies whether to enable the Maven publishing tasks
 457 defineProperty(&quot;MAVEN_PUBLISH&quot;, &quot;false&quot;)
 458 ext.IS_MAVEN_PUBLISH = Boolean.parseBoolean(MAVEN_PUBLISH)
 459 
 460 // Defines the compiler warning levels to use. If empty, then no warnings are generated. If
 461 // not empty, then the expected syntax is as a space or comma separated list of names, such
 462 // as defined in the javac documentation.
 463 defineProperty(&quot;LINT&quot;, &quot;none&quot;)
 464 ext.IS_LINT = LINT != &quot;none&quot;
 465 
 466 defineProperty(&quot;DOC_LINT&quot;, &quot;all&quot;)
 467 ext.IS_DOC_LINT = DOC_LINT != &quot;&quot;
 468 
 469 // Specifies whether to use the &quot;useDepend&quot; option when compiling Java sources
 470 defineProperty(&quot;USE_DEPEND&quot;, &quot;true&quot;)
 471 ext.IS_USE_DEPEND = Boolean.parseBoolean(USE_DEPEND)
 472 
 473 // Specifies whether to use the &quot;incremental&quot; option when compiling Java sources
 474 defineProperty(&quot;INCREMENTAL&quot;, &quot;false&quot;)
 475 ext.IS_INCREMENTAL = Boolean.parseBoolean(INCREMENTAL)
 476 
 477 // Specifies whether to include the Null3D pipeline (for perf debugging)
 478 defineProperty(&quot;INCLUDE_NULL3D&quot;, &quot;false&quot;)
 479 ext.IS_INCLUDE_NULL3D = Boolean.parseBoolean(INCLUDE_NULL3D)
 480 
 481 // Specifies whether to include the ES2 pipeline if available
 482 defineProperty(&quot;INCLUDE_ES2&quot;, IS_WINDOWS ? &quot;false&quot; : &quot;true&quot;)
 483 ext.IS_INCLUDE_ES2 = Boolean.parseBoolean(INCLUDE_ES2)
 484 
 485 // Specifies whether to generate code coverage statistics when running tests
 486 defineProperty(&quot;JCOV&quot;, &quot;false&quot;)
 487 ext.DO_JCOV = Boolean.parseBoolean(JCOV)
 488 
 489 // Specifies whether to use Cygwin when building OpenJFX. This should only ever
 490 // be set to false for development builds (that skip building media and webkit).
 491 defineProperty(&quot;USE_CYGWIN&quot;, &quot;true&quot;)
 492 ext.IS_USE_CYGWIN = Boolean.parseBoolean(USE_CYGWIN)
 493 
 494 // Define the number of threads to use when compiling (specifically for native compilation)
 495 // On Mac we limit it to 1 by default due to problems running gcc in parallel
 496 if (IS_MAC) {
 497     defineProperty(&quot;NUM_COMPILE_THREADS&quot;, &quot;1&quot;)
 498 } else {
 499     defineProperty(&quot;NUM_COMPILE_THREADS&quot;, &quot;${Runtime.runtime.availableProcessors()}&quot;)
 500 }
 501 
 502 //
 503 // The next three sections of properties are used to generate the
 504 // VersionInfo class, and the Windows DLL manifest.
 505 //
 506 
 507 // The following properties should be left alone by developers and set only from Hudson.
 508 defineProperty(&quot;HUDSON_JOB_NAME&quot;, &quot;not_hudson&quot;)
 509 defineProperty(&quot;HUDSON_BUILD_NUMBER&quot;,&quot;0000&quot;)
 510 defineProperty(&quot;PROMOTED_BUILD_NUMBER&quot;, &quot;0&quot;)
 511 defineProperty(&quot;MILESTONE_FCS&quot;, &quot;false&quot;)
 512 ext.IS_MILESTONE_FCS = Boolean.parseBoolean(MILESTONE_FCS)
 513 
 514 // The following properties define the product name for Oracle JDK and OpenJDK
 515 // for VersionInfo and the DLL manifest.
 516 if (BUILD_CLOSED) {
 517     defineProperty(&quot;PRODUCT_NAME&quot;, &quot;Java(TM)&quot;)
 518     defineProperty(&quot;COMPANY_NAME&quot;, &quot;Oracle Corporation&quot;)
 519     defineProperty(&quot;PLATFORM_NAME&quot;, &quot;Platform SE&quot;)
 520 } else {
 521     defineProperty(&quot;PRODUCT_NAME&quot;, &quot;OpenJFX&quot;)
 522     defineProperty(&quot;COMPANY_NAME&quot;, &quot;N/A&quot;)
 523     defineProperty(&quot;PLATFORM_NAME&quot;, &quot;Platform&quot;)
 524 }
 525 
 526 // The following properties are set based on properties defined in
 527 // build.properties. The release version and suffix should be updated
 528 // in that file.
 529 def relVer = 0
 530 if (jfxReleasePatchVersion == &quot;0&quot;) {
 531     if (jfxReleaseSecurityVersion == &quot;0&quot;) {
 532         if (jfxReleaseMinorVersion == &quot;0&quot;) {
 533             relVer = &quot;${jfxReleaseMajorVersion}&quot;
 534         } else {
 535             relVer = &quot;${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}&quot;
 536         }
 537     } else {
 538         relVer = &quot;${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}.${jfxReleaseSecurityVersion}&quot;
 539     }
 540 } else {
 541     relVer = &quot;${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}.${jfxReleaseSecurityVersion}.${jfxReleasePatchVersion}&quot;
 542 }
 543 defineProperty(&quot;RELEASE_VERSION&quot;, relVer)
 544 defineProperty(&quot;RELEASE_VERSION_PADDED&quot;, &quot;${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}.${jfxReleaseSecurityVersion}.${jfxReleasePatchVersion}&quot;)
 545 
 546 def buildDate = new java.util.Date()
 547 def buildTimestamp = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd-HHmmss&quot;).format(buildDate)
 548 defineProperty(&quot;BUILD_TIMESTAMP&quot;, buildTimestamp)
 549 def relSuffix = &quot;&quot;
 550 def relOpt = &quot;&quot;
 551 if (HUDSON_JOB_NAME == &quot;not_hudson&quot;) {
 552     relSuffix = &quot;-internal&quot;
 553     relOpt = &quot;-${buildTimestamp}&quot;
 554 } else {
 555     relSuffix = IS_MILESTONE_FCS ? &quot;&quot; : jfxReleaseSuffix
 556 }
 557 defineProperty(&quot;RELEASE_SUFFIX&quot;, relSuffix)
 558 defineProperty(&quot;RELEASE_VERSION_SHORT&quot;, &quot;${RELEASE_VERSION}${RELEASE_SUFFIX}&quot;)
 559 defineProperty(&quot;RELEASE_VERSION_LONG&quot;, &quot;${RELEASE_VERSION_SHORT}+${PROMOTED_BUILD_NUMBER}${relOpt}&quot;)
 560 defineProperty(&quot;MAVEN_VERSION&quot;, IS_MAVEN_PUBLISH ? (IS_MILESTONE_FCS ? &quot;${RELEASE_VERSION_SHORT}&quot; : &quot;${RELEASE_VERSION_LONG}&quot;) : &quot;&quot;)
 561 
 562 // Check whether the COMPILE_TARGETS property has been specified (if so, it was done by
 563 // the user and not by this script). If it has not been defined then default
 564 // to building the normal desktop build for this machine
 565 project.ext.set(&quot;defaultHostTarget&quot;, IS_MAC ? &quot;mac&quot; : IS_WINDOWS ? &quot;win&quot; : IS_LINUX ? &quot;linux&quot; : &quot;&quot;);
 566 defineProperty(&quot;COMPILE_TARGETS&quot;, &quot;$defaultHostTarget&quot;)
 567 
 568 // Flag indicating whether to import cross compile tools
 569 def importCrossTools = false
 570 if (hasProperty(&quot;IMPORT_CROSS_TOOLS&quot;)) {
 571     importCrossTools = Boolean.parseBoolean(IMPORT_CROSS_TOOLS);
 572 }
 573 ext.IS_IMPORT_CROSS_TOOLS = importCrossTools
 574 
 575 // Location of the cross compile tools
 576 def crossToolsDir = &quot;../crosslibs&quot;
 577 if (hasProperty(&quot;CROSS_TOOLS_DIR&quot;)) {
 578     crossToolsDir = CROSS_TOOLS_DIR
 579 }
 580 ext.CROSS_TOOLS_DIR = file(crossToolsDir)
 581 
 582 // Specifies whether to run tests with the existing javafx.* modules instead of compiling a new one
 583 defineProperty(&quot;BUILD_SDK_FOR_TEST&quot;, &quot;true&quot;)
 584 ext.DO_BUILD_SDK_FOR_TEST = Boolean.parseBoolean(BUILD_SDK_FOR_TEST)
 585 
 586 // All &quot;classes&quot; and &quot;jar&quot; tasks and their dependencies would be disabled
 587 // when running with DO_BUILD_SDK_FOR_TEST=false as they&#39;re unneeded for running tests
 588 if (!DO_BUILD_SDK_FOR_TEST) {
 589     gradle.taskGraph.useFilter({ task -&gt; !task.name.equals(&quot;classes&quot;) &amp;&amp; !task.name.equals(&quot;jar&quot;) })
 590 }
 591 
 592 // Make sure JDK_HOME/bin/java exists
 593 if (!file(JAVA).exists()) throw new Exception(&quot;Missing or incorrect path to &#39;java&#39;: &#39;$JAVA&#39;. Perhaps bad JDK_HOME? $JDK_HOME&quot;)
 594 if (!file(JAVAC).exists()) throw new Exception(&quot;Missing or incorrect path to &#39;javac&#39;: &#39;$JAVAC&#39;. Perhaps bad JDK_HOME? $JDK_HOME&quot;)
 595 if (!file(JAVADOC).exists()) throw new Exception(&quot;Missing or incorrect path to &#39;javadoc&#39;: &#39;$JAVADOC&#39;. Perhaps bad JDK_HOME? $JDK_HOME&quot;)
 596 
 597 // Determine the verion of Java in JDK_HOME. It looks like this:
 598 //
 599 // $ java -version
 600 // java version &quot;1.7.0_45&quot;
 601 // Java(TM) SE Runtime Environment (build 1.7.0_45-b18)
 602 // Java HotSpot(TM) 64-Bit Server VM (build 24.45-b08, mixed mode)
 603 //
 604 // We need to parse the second line
 605 def inStream = new java.io.BufferedReader(new java.io.InputStreamReader(new java.lang.ProcessBuilder(JAVA, &quot;-fullversion&quot;).start().getErrorStream()));
 606 try {
 607     String v = inStream.readLine().trim();
 608     if (v != null) {
 609         int ib = v.indexOf(&quot;full version \&quot;&quot;);
 610         if (ib != -1) {
 611             String str = v.substring(ib);
 612             String ver = str.substring(str.indexOf(&quot;\&quot;&quot;) + 1, str.size() - 1);
 613 
 614             defineProperty(&quot;jdkRuntimeVersion&quot;, ver)
 615             def jdkVersionInfo = parseJavaVersion(ver)
 616             defineProperty(&quot;jdkVersion&quot;, jdkVersionInfo[0])
 617             defineProperty(&quot;jdkBuildNumber&quot;, jdkVersionInfo[1])
 618         }
 619     }
 620 } finally {
 621     inStream.close();
 622 }
 623 if (!project.hasProperty(&quot;jdkRuntimeVersion&quot;)) throw new Exception(&quot;Unable to determine the version of Java in JDK_HOME at $JDK_HOME&quot;);
 624 
 625 
 626 // Determine whether the javafx.* modules are present in the JDK. To do this,
 627 // we will execute &quot;java --list-modules&quot; and search for javafx.base.
 628 ext.HAS_JAVAFX_MODULES = false;
 629 def inStream2 = new java.io.BufferedReader(new java.io.InputStreamReader(new java.lang.ProcessBuilder(JAVA, &quot;--list-modules&quot;).start().getInputStream()));
 630 try {
 631     String v;
 632     while ((v = inStream2.readLine()) != null) {
 633         v = v.trim();
 634         if (v.startsWith(&quot;javafx.base&quot;)) ext.HAS_JAVAFX_MODULES = true;
 635     }
 636 } finally {
 637     inStream2.close();
 638 }
 639 
 640 // The HAS_JAVAFX_MODULES flag will be used to determine the mode for building
 641 // and running the applications and tests.
 642 // If HAS_JAVAFX_MODULES is true, then we will build / test javafx modules
 643 // for exporting to a JDK build. If HAS_JAVAFX_MODULES is false, then we will
 644 // build / test a standalone sdk for running with a JDK that does not include
 645 // the javafx modules.
 646 
 647 
 648 /**
 649  * Fetch/Check that external tools are present for the build. This method
 650  * will conditionally download the packages from project defined ivy repositories
 651  * and unpack them into the specified destdir
 652  *
 653  * @param configName A unique name to distinguish the configuration (ie &quot;ARMSFV6&quot;)
 654  * @param packages A list of required packages (with extensions .tgz, .zip)
 655  * @param destdir where the packages should be unpacked
 656  * @param doFetch if true, the named packages will be download
 657  */
 658 void fetchExternalTools(String configName, List packages, File destdir, boolean doFetch) {
 659     if (doFetch) {
 660         // create a unique configuration for this fetch
 661         def String fetchToolsConfig = &quot;fetchTools$configName&quot;
 662         rootProject.configurations.create(fetchToolsConfig)
 663 
 664         def List&lt;String&gt; fetchedPackages = []
 665         def int fetchCount = 0
 666 
 667         packages.each { pkgname-&gt;
 668             def int dotdex = pkgname.lastIndexOf(&#39;.&#39;)
 669             def int dashdex = pkgname.lastIndexOf(&#39;-&#39;)
 670             def String basename = pkgname.substring(0,dashdex)
 671             def String ver = pkgname.substring(dashdex+1,dotdex)
 672             def String ext = pkgname.substring(dotdex+1)
 673             def File pkgdir = file(&quot;$destdir/$basename-$ver&quot;)
 674 
 675             if (!pkgdir.isDirectory()) {
 676                 rootProject.dependencies.add(fetchToolsConfig, &quot;javafx:$basename:$ver&quot;, {
 677                     artifact {
 678                         name = basename
 679                         type = ext
 680                     }
 681                 })
 682                 println &quot;adding $pkgname as a downloadable item did not find $pkgdir&quot;
 683                 fetchedPackages.add(pkgname)
 684                 fetchCount++
 685             }
 686         }
 687 
 688         //fetch all the missing packages
 689         if (fetchedPackages.size &gt; 0) {
 690             destdir.mkdirs()
 691 
 692             logger.quiet &quot;fetching missing packages $fetchedPackages&quot;
 693             copy {
 694                 from rootProject.configurations[fetchToolsConfig]
 695                 into destdir
 696             }
 697 
 698             // unpack the fetched packages
 699             fetchedPackages.each { pkgname-&gt;
 700                 logger.quiet &quot;expanding the package $pkgname&quot;
 701                 def srcball = file(&quot;${destdir}/${pkgname}&quot;)
 702 
 703                 if (!srcball.exists()) {
 704                     throw new GradleException(&quot;Failed to fetch $pkgname&quot;);
 705                 }
 706 
 707                 def String basename = pkgname.substring(0,pkgname.lastIndexOf(&quot;.&quot;))
 708                 def File pkgdir = file(&quot;$destdir/$basename&quot;)
 709 
 710                 if (pkgname.endsWith(&quot;.tgz&quot;) || pkgname.endsWith(&quot;tar.gz&quot;)) {
 711                     if (IS_LINUX || IS_MAC) {
 712                         // use native tar to support symlinks
 713                         pkgdir.mkdirs()
 714                         exec {
 715                             workingDir pkgdir
 716                             commandLine &quot;tar&quot;, &quot;zxf&quot;, &quot;${srcball}&quot;
 717                          }
 718                     } else {
 719                         copy {
 720                             from tarTree(resources.gzip(&quot;${srcball}&quot;))
 721                             into pkgdir
 722                         }
 723                     }
 724                 } else if (pkgname.endsWith(&quot;.zip&quot;)) {
 725                      copy {
 726                          from zipTree(&quot;${srcball}&quot;)
 727                          into pkgdir
 728                      }
 729                 } else {
 730                     throw new GradleException(&quot;Unhandled package type for compile package ${pkgname}&quot;)
 731                 }
 732                 srcball.delete();
 733             }
 734         } else {
 735             logger.quiet &quot;all tool packages are present $packages&quot;
 736         }
 737     } else { // !doFetch - so just check they are present
 738         // check that all the dirs are really there
 739         def List&lt;String&gt; errors = []
 740         packages.each { pkgname-&gt;
 741             def String basename = pkgname.substring(0,pkgname.lastIndexOf(&quot;.&quot;))
 742             def File pkgdir = file(&quot;$destdir/$basename&quot;)
 743 
 744             if (!pkgdir.isDirectory()) {
 745                 errors.add(pkgname)
 746             }
 747         }
 748         if (errors.size &gt; 0) {
 749             throw new GradleException(&quot;Error: missing tool packages: $errors&quot;)
 750         } else {
 751             logger.quiet &quot;all tool packages are present $packages&quot;
 752         }
 753     }
 754 }
 755 
 756 // Make a forked ANT call.
 757 // This needs to be forked so that ant can be used with the right JDK and updated modules
 758 // for testing obscure things like packaging of apps
 759 void ant(String conf,   // platform configuration
 760          String dir,    // directory to run from
 761          String target, // ant target
 762          List&lt;String&gt;  params // parameters (usually -Dxxx=yyy)
 763          ) {
 764     // Try to use ANT_HOME
 765     String antHomeEnv = System.getenv(&quot;ANT_HOME&quot;)
 766     String antHome = antHomeEnv != null ? cygpath(antHomeEnv) : null;
 767     String ant = (antHome != null &amp;&amp; !antHome.equals(&quot;&quot;)) ? &quot;$antHome/bin/ant&quot; : &quot;ant&quot;;
 768 
 769     exec {
 770         workingDir = dir
 771         environment(&quot;JDK_HOME&quot;, JDK_HOME)
 772         environment(&quot;JAVA_HOME&quot;, JDK_HOME)
 773         if (IS_WINDOWS) {
 774             environment([
 775                     &quot;VCINSTALLDIR&quot;         : WINDOWS_VS_VCINSTALLDIR,
 776                     &quot;VSINSTALLDIR&quot;         : WINDOWS_VS_VSINSTALLDIR,
 777                     &quot;DEVENVDIR&quot;            : WINDOWS_VS_DEVENVDIR,
 778                     &quot;MSVCDIR&quot;              : WINDOWS_VS_MSVCDIR,
 779                     &quot;INCLUDE&quot;              : WINDOWS_VS_INCLUDE,
 780                     &quot;LIB&quot;                  : WINDOWS_VS_LIB,
 781                     &quot;LIBPATH&quot;              : WINDOWS_VS_LIBPATH,
 782                     &quot;DXSDK_DIR&quot;            : WINDOWS_DXSDK_DIR,
 783                     &quot;PATH&quot;                 : WINDOWS_VS_PATH
 784             ]);
 785             commandLine &quot;cmd&quot;, &quot;/c&quot;, ant, &quot;-Dbuild.compiler=javac1.7&quot;
 786         } else {
 787             commandLine ant, &quot;-Dbuild.compiler=javac1.7&quot;
 788         }
 789         if ((conf != null) &amp;&amp; !rootProject.defaultHostTarget.equals(conf)) {
 790             def targetProperties = rootProject.ext[conf.trim().toUpperCase()]
 791             args(&quot;-Dcross.platform=$conf&quot;)
 792             if (targetProperties.containsKey(&#39;arch&#39;)) {
 793                 args(&quot;-Dcross.platform.arch=${targetProperties.arch}&quot;)
 794             }
 795         }
 796         if (params != null) {
 797             params.each() { s-&gt;
 798                 args(s)
 799             }
 800         }
 801         if (IS_MILESTONE_FCS) {
 802             args(&#39;-Djfx.release.suffix=&quot;&quot;&#39;)
 803         }
 804         args(target);
 805     }
 806 }
 807 
 808 List&lt;String&gt; computeLibraryPath(boolean working) {
 809     List&lt;String&gt; lp = []
 810 
 811     if (HAS_JAVAFX_MODULES) {
 812         List&lt;String&gt; modsWithNative = [ &#39;graphics&#39;, &#39;media&#39;, &#39;web&#39; ]
 813 
 814         // the build/modular-sdk area
 815         def platformPrefix = &quot;&quot;
 816         def bundledSdkDirName = &quot;${platformPrefix}modular-sdk&quot;
 817         def bundledSdkDir = &quot;${rootProject.buildDir}/${bundledSdkDirName}&quot;
 818         def modulesLibsDir = &quot;${bundledSdkDir}/modules_libs&quot;
 819 
 820         modsWithNative.each() { m -&gt;
 821             lp &lt;&lt; cygpath(&quot;${modulesLibsDir}/javafx.${m}&quot;)
 822         }
 823     } else {
 824         def platformPrefix = &quot;&quot;
 825         def standaloneSdkDirName = &quot;${platformPrefix}sdk&quot;
 826         def standaloneSdkDir = &quot;${rootProject.buildDir}/${standaloneSdkDirName}&quot;
 827         def modulesLibName = IS_WINDOWS ? &quot;bin&quot; : &quot;lib&quot;
 828         def modulesLibsDir = &quot;${standaloneSdkDir}/${modulesLibName}&quot;
 829         lp &lt;&lt; cygpath(&quot;${modulesLibsDir}&quot;)
 830     }
 831 
 832     return lp
 833 }
 834 
 835 // Return list with the arguments needed for --patch-module or --module-path
 836 // for the provided projects. Used with Java executables ie. tests
 837 List&lt;String&gt; computePatchModuleArgs(List&lt;String&gt; deps, boolean test, boolean includeJLP) {
 838     List&lt;String&gt; pma = []
 839 
 840     if (HAS_JAVAFX_MODULES) {
 841         deps.each { String projname -&gt;
 842             def proj = project(projname)
 843             if (proj.hasProperty(&quot;moduleName&quot;)) {
 844                 File dir;
 845                 if (test &amp;&amp; proj.sourceSets.hasProperty(&#39;shims&#39;)) {
 846                     dir = file(&quot;${rootProject.buildDir}/shims&quot;)
 847                 } else {
 848                     dir = file(&quot;${rootProject.buildDir}/modular-sdk/modules&quot;)
 849                 }
 850                 String moduleName = proj.ext.moduleName
 851                 String dirpath = cygpath(&quot;${dir}/${moduleName}&quot;)
 852                 pma += &quot;--patch-module=${moduleName}=${dirpath}&quot;
 853             }
 854         }
 855     } else {
 856         String mp = null
 857         deps.each { String projname -&gt;
 858             def proj = project(projname)
 859             if (proj.hasProperty(&quot;moduleName&quot;)) {
 860                 String moduleName = proj.ext.moduleName
 861                 File dir;
 862                 if (test &amp;&amp; proj.sourceSets.hasProperty(&#39;shims&#39;)) {
 863                     dir = file(&quot;${rootProject.buildDir}/shims/${moduleName}&quot;)
 864                 } else {
 865                     dir = file(&quot;${rootProject.buildDir}/sdk/lib/${moduleName}.jar&quot;)
 866                 }
 867                 if (mp == null) {
 868                     mp = dir.path
 869                 } else {
 870                     mp = mp + File.pathSeparator + dir.path
 871                 }
 872             }
 873         }
 874 
 875         // in some cases like base we could end up with an empty
 876         // path... make sure we don&#39;t pass one back
 877         if (mp == null) {
 878             return null
 879         }
 880 
 881         pma += &#39;--module-path&#39;
 882         pma += mp
 883 
 884         String addm = null
 885         deps.each {String projname -&gt;
 886             def proj = project(projname)
 887             if (proj.hasProperty(&quot;moduleName&quot;) &amp;&amp; proj.buildModule) {
 888                 if (addm == null) {
 889                     addm = proj.moduleName
 890                 } else {
 891                     addm = addm + &quot;,&quot; + proj.moduleName
 892                 }
 893             }
 894         }
 895         if (addm != null) {
 896             pma += &quot;--add-modules=${addm}&quot;
 897         }
 898     }
 899 
 900     if (includeJLP) {
 901         pma += &quot;-Djava.library.path=&quot; + computeLibraryPath(true).join(File.pathSeparator)
 902     }
 903 
 904     return pma
 905 }
 906 
 907 // Return a list containing the --upgrade-module-path or --module-path
 908 // used with Javac
 909 List&lt;String&gt; computeModulePathArgs(String  pname, List&lt;String&gt; deps, boolean test) {
 910     List&lt;String&gt; mpa = HAS_JAVAFX_MODULES ? [ &#39;--upgrade-module-path&#39; ] : [ &#39;--module-path&#39; ]
 911     String mp = null
 912     deps.each { String projname -&gt;
 913         def proj = project(projname)
 914         // for a non test set of args, we don&#39;t want the current module in the list
 915         // for a test test, we do need it to update what we built
 916 
 917         if (proj.hasProperty(&quot;moduleName&quot;) &amp;&amp;
 918                 proj.buildModule &amp;&amp;
 919                 !(!test &amp;&amp; proj.name.equals(pname))) {
 920 
 921             File dir;
 922             if (test &amp;&amp; proj.sourceSets.hasProperty(&#39;shims&#39;)) {
 923                 dir = new File(proj.sourceSets.shims.java.outputDir, proj.ext.moduleName);
 924             } else {
 925                 dir = new File(proj.sourceSets.main.java.outputDir, proj.ext.moduleName);
 926             }
 927             if (mp == null) {
 928                 mp = dir.path
 929             } else {
 930                 mp = mp + File.pathSeparator + dir.path
 931             }
 932         }
 933     }
 934 
 935     // in some cases like base we could end up with an empty
 936     // path... make sure we don&#39;t pass one back
 937     if (mp == null) {
 938         return null
 939     }
 940 
 941     mpa += mp
 942 
 943     if (!HAS_JAVAFX_MODULES) {
 944         String addm = null
 945         deps.each {String projname -&gt;
 946             def proj = project(projname)
 947             // for a non test set of args, we don&#39;t want the current module in the list
 948             // for a test test, we do need it to update what we built
 949 
 950             if (proj.hasProperty(&quot;moduleName&quot;) &amp;&amp;
 951                     proj.buildModule &amp;&amp;
 952                     !(!test &amp;&amp; proj.name.equals(pname))) {
 953 
 954                 if (addm == null) {
 955                     addm = proj.moduleName
 956                 } else {
 957                     addm = addm + &quot;,&quot; + proj.moduleName
 958                 }
 959             }
 960         }
 961         if (addm != null) {
 962             mpa += &quot;--add-modules=${addm}&quot;
 963         }
 964     }
 965 
 966     return mpa
 967 }
 968 
 969 
 970 void writeRunArgsFile(File dest, List&lt;String&gt; libpath, List&lt;String&gt; modpath, List&lt;String&gt; modules) {
 971 
 972     dest.delete()
 973 
 974     logger.info(&quot;Creating file ${dest.path}&quot;)
 975 
 976     if (libpath != null) {
 977         dest &lt;&lt;  &quot;-Djava.library.path=\&quot;\\\n&quot;
 978         libpath.each() { e-&gt;
 979             dest &lt;&lt; &quot;  &quot;
 980             dest &lt;&lt; e
 981             dest &lt;&lt; File.pathSeparator
 982             dest &lt;&lt; &quot;\\\n&quot;
 983         }
 984         dest &lt;&lt;  &quot;  \&quot;\n&quot;
 985     }
 986 
 987     if (HAS_JAVAFX_MODULES) {
 988         modpath.each { e -&gt;
 989             dest &lt;&lt;  &quot;--patch-module=\&quot;&quot;
 990             dest &lt;&lt; e
 991             dest &lt;&lt; &quot;\&quot;\n&quot;
 992         }
 993     } else {
 994         if (modpath.size() == 1) {
 995             dest &lt;&lt;  &quot;--module-path=\&quot;&quot;
 996             dest &lt;&lt; modpath[0]
 997             dest &lt;&lt; &quot;\&quot;\n&quot;
 998         } else {
 999             dest &lt;&lt;  &quot;--module-path=\&quot;\\\n&quot;
1000             modpath.each() { e-&gt;
1001                 dest &lt;&lt; &quot;  &quot;
1002                 dest &lt;&lt; e
1003                 dest &lt;&lt; File.pathSeparator
1004                 dest &lt;&lt; &quot;\\\n&quot;
1005             }
1006             dest &lt;&lt;  &quot;  \&quot;\n&quot;
1007         }
1008     }
1009 
1010     if (modules != null) {
1011         dest &lt;&lt;  &quot;--add-modules=&quot;
1012         dest &lt;&lt; modules.join(&quot;,&quot;)
1013         dest &lt;&lt; &quot;\n&quot;
1014     }
1015 }
1016 
1017 // perform common project manipulation for modules
1018 void commonModuleSetup(Project p, List&lt;String&gt; moduleChain) {
1019 
1020     p.ext.moduleChain = moduleChain
1021 
1022     if (p.hasProperty(&quot;moduleName&quot;)) {
1023         p.ext.moduleDir = new File (p.sourceSets.main.java.outputDir, &quot;${p.moduleName}&quot;)
1024         if (p.sourceSets.hasProperty(&#39;shims&#39;)) {
1025             p.ext.moduleShimsDir = new File (p.sourceSets.shims.java.outputDir, &quot;${p.moduleName}&quot;)
1026         }
1027     }
1028 
1029     def mpa = computeModulePathArgs(p.name, moduleChain, false)
1030     if (mpa != null) {
1031         p.ext.modulePathArgs = mpa
1032     }
1033 
1034     p.ext.testModulePathArgs = computePatchModuleArgs(moduleChain, true, false)
1035     p.ext.patchModuleArgs = computePatchModuleArgs(moduleChain ,false, true)
1036     p.ext.testPatchModuleArgs = computePatchModuleArgs(moduleChain, true, true)
1037 
1038     moduleChain.each() {e -&gt;
1039         if (!e.equals(p.name)) {
1040             p.compileJava.dependsOn(project(e).classes)
1041             p.compileTestJava.dependsOn(project(e).testClasses)
1042         }
1043     }
1044 
1045     // read in any addExports file
1046     File addExportsFile = new File(p.projectDir,&quot;src/test/addExports&quot;)
1047     if (addExportsFile.exists()) {
1048         List&lt;String&gt; ae = []
1049         addExportsFile.eachLine { line -&gt;
1050             line = line.trim()
1051             if (!(line.startsWith(&quot;#&quot;) || line.equals(&quot;&quot;))) {
1052                 ae += line.split(&#39; &#39;)
1053             }
1054         }
1055         p.ext.testAddExports  = ae.flatten()
1056     }
1057 
1058     // read in the temporary addExports file EXTRAADDEXPORTS)
1059     //
1060     // These extra --add-exports will be used in two places and so we
1061     // create/modify two items:
1062     // p.testAddExports - add the extra items so they are included in test builds
1063     //
1064     // p.extraAddExports - for use in any other place where we don&#39;t automatically update
1065     //    for example any non modular, non &#39;test&#39; compile, any compile that does not
1066     //    use a module-source-path that includes the dependent modules
1067     //
1068     // Note that we don&#39;t modify the modular build (main, shims) because they use
1069     // module-info directly, and we don&#39;t want to cover up any missing items there.
1070     //
1071     if (!rootProject.hasProperty(&quot;EXTRA_ADDEXPORTS_ARGS&quot;)) {
1072         List&lt;String&gt; extraAddExportsList = []
1073         String fullae = &quot;&quot;
1074         File tmpaddExportsFile = new File(rootProject.projectDir, EXTRAADDEXPORTS)
1075         if (tmpaddExportsFile.exists()) {
1076             String nl = System.getProperty(&quot;line.separator&quot;)
1077             tmpaddExportsFile.eachLine { line -&gt;
1078                 line = line.trim()
1079                 fullae += line + nl
1080                 if (!(line.startsWith(&quot;#&quot;) || line.equals(&quot;&quot;))) {
1081                     extraAddExportsList += line.split(&#39; &#39;)
1082                 }
1083             }
1084         }
1085         // This string is used in the creation of the build/*.args files
1086         // so we preserve comments
1087         if (!extraAddExportsList.isEmpty()) {
1088             rootProject.ext.EXTRA_ADDEXPORTS_STRING = fullae
1089         }
1090         rootProject.ext.EXTRA_ADDEXPORTS_ARGS = extraAddExportsList
1091     }
1092 
1093     if (HAS_JAVAFX_MODULES) {
1094         // use this variable, because it shows we have a non empty addition
1095         if (rootProject.hasProperty(&quot;EXTRA_ADDEXPORTS_STRING&quot;)) {
1096             p.ext.extraAddExports = EXTRA_ADDEXPORTS_ARGS.flatten()
1097             if (p.hasProperty(&quot;testAddExports&quot;)) {
1098                 p.testAddExports += EXTRA_ADDEXPORTS_ARGS.flatten()
1099             }
1100         }
1101     }
1102 }
1103 
1104 if (BUILD_TOOLS_DOWNLOAD_SCRIPT != &quot;&quot;) {
1105     println &quot;Include build tools download script:${BUILD_TOOLS_DOWNLOAD_SCRIPT}&quot;
1106     apply from: BUILD_TOOLS_DOWNLOAD_SCRIPT
1107 }
1108 
1109 // Now we need to define the native compilation tasks. The set of parameters to
1110 // native compilation depends on the target platform (and also to some extent what platform
1111 // you are compiling on). These settings are contained in various gradle files
1112 // such as mac.gradle and linux.gradle and armhf.gradle. Additionally, the developer
1113 // can specify COMPILE_FLAGS_FILE to be a URL or path to a different gradle file
1114 // that will contain the appropriate flags.
1115 defineProperty(&quot;COMPILE_FLAGS_FILES&quot;, COMPILE_TARGETS.split(&quot;,&quot;).collect {&quot;buildSrc/${it.trim()}.gradle&quot;}.join(&quot;,&quot;))
1116 if (COMPILE_TARGETS == &quot;all&quot;) {
1117     def tmp = []
1118     File buildSrcDir = file(&quot;buildSrc&quot;)
1119     buildSrcDir.listFiles().each { File f -&gt;
1120         if (f.isFile() &amp;&amp; f.name.endsWith(&quot;.gradle&quot;) &amp;&amp; !f.name.equals(&quot;build.gradle&quot;)) {
1121             def target = f.name.substring(0, f.name.lastIndexOf(&#39;.gradle&#39;)).toUpperCase(Locale.ROOT)
1122             apply from: f
1123             if (project.ext[&quot;${target}&quot;].canBuild) {
1124                 tmp.add(target)
1125             }
1126         }
1127     }
1128     COMPILE_FLAGS_FILES = tmp.collect { &quot;buildSrc/${it}.gradle&quot;}.join(&quot;,&quot;)
1129     COMPILE_TARGETS = tmp.collect { &quot;${it.toLowerCase()}&quot;}.join(&quot;,&quot;)
1130 } else {
1131     COMPILE_FLAGS_FILES.split(&quot;,&quot;).each {
1132         logger.info(&quot;Applying COMPILE_FLAGS_FILE &#39;$it&#39;&quot;)
1133         apply from: it
1134     }
1135 }
1136 
1137 if (COMPILE_TARGETS != &quot;&quot;) {
1138     def tmp = []
1139     COMPILE_TARGETS.split(&quot;,&quot;).each {target -&gt;
1140         if (project.ext[&quot;${target.toUpperCase(Locale.ROOT)}&quot;].canBuild) {
1141             tmp.add(target)
1142         }
1143     }
1144     COMPILE_TARGETS = tmp.collect { &quot;${it.toLowerCase()}&quot;}.join(&quot;,&quot;)
1145 }
1146 
1147 // Sanity check the expected properties all exist
1148 compileTargets { t -&gt;
1149     // Every platform must define these variables
1150     if (!project.hasProperty(t.upper)) throw new Exception(&quot;ERROR: Incorrectly configured compile flags file, missing ${t.name} property&quot;)
1151     def props = project.ext[t.upper];
1152     // TODO: we could remove libDest in favor of modLibDest
1153     [&quot;compileSwing&quot;, &quot;compileSWT&quot;, &quot;libDest&quot;].each { prop -&gt;
1154         if (!props.containsKey(prop)) throw new Exception(&quot;ERROR: Incorrectly configured compile flags file, missing ${prop} property on ${t.name}&quot;)
1155     }
1156 }
1157 
1158 // Various build flags may be set by the different target files, such as
1159 // whether to build Swing, SWT, etc. We iterate over all
1160 // compile targets and look for these settings in our properties. Note that
1161 // these properties cannot be set from the command line, but are set by
1162 // the target build files such as armv6hf.gradle or mac.gradle.
1163 ext.COMPILE_SWING = false;
1164 ext.COMPILE_SWT = false;
1165 compileTargets { t -&gt;
1166     def targetProperties = project.rootProject.ext[t.upper]
1167 
1168     if (targetProperties.compileSwing) COMPILE_SWING = true
1169     if (targetProperties.compileSWT) COMPILE_SWT = true
1170 
1171     if (!targetProperties.containsKey(&#39;compileWebnodeNative&#39;)) {
1172         // unless specified otherwise, we will compile native Webnode if IS_COMPILE_WEBKIT
1173         targetProperties.compileWebnodeNative = true
1174     }
1175 
1176     if (!targetProperties.containsKey(&#39;compileMediaNative&#39;)) {
1177         // unless specified otherwise, we will compile native Media if IS_COMPILE_MEDIA
1178         targetProperties.compileMediaNative = true
1179     }
1180 
1181     if (!targetProperties.containsKey(&#39;includeSWT&#39;)) targetProperties.includeSWT = true
1182     if (!targetProperties.containsKey(&#39;includeSwing&#39;)) targetProperties.includeSwing = true
1183     if (!targetProperties.containsKey(&#39;includeNull3d&#39;)) targetProperties.includeNull3d = true
1184     if (!targetProperties.containsKey(&#39;includeMonocle&#39;)) targetProperties.includeMonocle = false
1185     if (!targetProperties.containsKey(&#39;includeEGL&#39;)) targetProperties.includeEGL = false
1186 
1187     if (!targetProperties.containsKey(&#39;includeGTK&#39;)) targetProperties.includeGTK = IS_LINUX
1188 
1189     if (!targetProperties.containsKey(&#39;modLibDest&#39;)) targetProperties.modLibDest = targetProperties.libDest
1190 
1191     // This value is used as a prefix for various directories under ./build,
1192     // such as sdk, to allow for a common name for the hosted build
1193     // (for use when building apps) and a unique name for cross builds.
1194     if (rootProject.defaultHostTarget.equals(t.name)) {
1195         // use a simple common default for the &quot;host&quot; build
1196         targetProperties.platformPrefix=&quot;&quot;
1197     } else {
1198         // and a more complex one for cross builds
1199         targetProperties.platformPrefix=&quot;${t.name}-&quot;
1200     }
1201 }
1202 
1203 /******************************************************************************
1204  *                                                                            *
1205  *                         Build Setup Sanity Checks                          *
1206  *                                                                            *
1207  *  Here we do a variety of checks so that if the version of Java you are     *
1208  *  building with is misconfigured, or you are using the wrong version of     *
1209  *  gradle, etc you will get some kind of helpful error / warning message     *
1210  *                                                                            *
1211  *****************************************************************************/
1212 
1213 // Sanity check that we actually have a list of compile targets to execute
1214 if (COMPILE_TARGETS == null || COMPILE_TARGETS == &quot;&quot;) {
1215     throw new Exception(&quot;Unable to determine compilation platform, must specify valid COMPILE_TARGETS!&quot;)
1216 }
1217 
1218 // Verify that CONF is something useful
1219 if (CONF != &quot;Release&quot; &amp;&amp; CONF != &quot;Debug&quot; &amp;&amp; CONF != &quot;DebugNative&quot;) {
1220     logger.warn(&quot;Unknown configuration CONF=&#39;$CONF&#39;. Treating as &#39;Release&#39;&quot;)
1221 }
1222 
1223 // If the number of compile threads is less than 1 then we have a problem!
1224 if (Integer.parseInt(NUM_COMPILE_THREADS.toString()) &lt; 1) {
1225     logger.warn(&quot;NUM_COMPILE_THREADS was specified as &#39;$NUM_COMPILE_THREADS&#39; which is less than the minimum value of 1. &quot; +
1226             &quot;Building with a value of 1 instead.&quot;)
1227     NUM_COMPILE_THREADS = 1
1228 }
1229 
1230 // Check gradle version
1231 if (gradle.gradleVersion != jfxGradleVersion) {
1232     def ver = gradle.gradleVersion.split(&quot;[\\.]&quot;);
1233     def verMin = jfxGradleVersionMin.split(&quot;[\\.]&quot;);
1234     def gradleMajor = Integer.parseInt(ver[0]);
1235     def gradleMinor = Integer.parseInt(ver[1].split(&quot;[^0-9]&quot;)[0]);
1236     def gradleMajorMin = Integer.parseInt(verMin[0]);
1237     def gradleMinorMin = Integer.parseInt(verMin[1].split(&quot;[^0-9]&quot;)[0]);
1238     def err = &quot;&quot;;
1239     if (gradleMajor &lt; gradleMajorMin || (gradleMajor == gradleMajorMin &amp;&amp; gradleMinor &lt; gradleMinorMin)) {
1240         err = &quot;Gradle version too old: ${gradle.gradleVersion}; must be at least ${jfxGradleVersionMin}&quot;
1241     }
1242 
1243     if (IS_GRADLE_VERSION_CHECK &amp;&amp; err != &quot;&quot;) {
1244         fail(err);
1245     }
1246 
1247     logger.warn(&quot;*****************************************************************&quot;);
1248     logger.warn(&quot;Unsupported gradle version $gradle.gradleVersion in use.&quot;);
1249     logger.warn(&quot;Only version $jfxGradleVersion is supported. Use this version at your own risk&quot;);
1250     if ( err != &quot;&quot;) logger.warn(err);
1251     logger.warn(&quot;*****************************************************************&quot;);
1252 }
1253 
1254 // Look for stub runtime in bundled sdk, standalone sdk, or boot JDK
1255 
1256 // Allows automatic provisioning of webkit+media shared libraries
1257 // from official OpenJFX releases, downloaded from MavenCentral
1258 defineProperty(&quot;STUB_RUNTIME_OPENJFX&quot;, &quot;&quot;)
1259 ext.IS_STUB_RUNTIME_OPENJFX = !STUB_RUNTIME_OPENJFX.isBlank()
1260 
1261 def String cachedBundledRuntime = cygpath(&quot;$projectDir&quot;) + &quot;/../caches/modular-sdk&quot;
1262 def String cachedStandaloneRuntime = cygpath(&quot;$projectDir&quot;) + &quot;/../caches/sdk&quot;
1263 def String jdkStubRuntime = cygpath(&quot;$JDK_HOME&quot;)
1264 def String openjfxStubRuntime = cygpath(&quot;$projectDir&quot;) + &quot;/buildSrc/build/openjfxStub&quot;
1265 
1266 def defaultStubRuntime = &quot;&quot;
1267 if (file(cachedBundledRuntime).exists()) {
1268     defaultStubRuntime = cachedBundledRuntime
1269 } else if (file(cachedStandaloneRuntime).exists()) {
1270     defaultStubRuntime = cachedStandaloneRuntime
1271 } else if (BUILD_CLOSED) {
1272     defaultStubRuntime = cachedBundledRuntime
1273 } else if (IS_STUB_RUNTIME_OPENJFX) {
1274     defaultStubRuntime = openjfxStubRuntime
1275 } else {
1276     defaultStubRuntime = jdkStubRuntime
1277 }
1278 
1279 defineProperty(&quot;STUB_RUNTIME&quot;, defaultStubRuntime)
1280 
1281 if (STUB_RUNTIME.endsWith(&quot;/modular-sdk&quot;)) {
1282     def stubModulesLib = &quot;$STUB_RUNTIME/modules_libs&quot;
1283     defineProperty(&quot;MEDIA_STUB&quot;, &quot;$stubModulesLib/javafx.media&quot;)
1284     defineProperty(&quot;WEB_STUB&quot;, &quot;$stubModulesLib/javafx.web&quot;)
1285 } else {
1286     def libraryStub = IS_WINDOWS ? &quot;$STUB_RUNTIME/bin&quot; : &quot;$STUB_RUNTIME/lib&quot;
1287 
1288     defineProperty(&quot;MEDIA_STUB&quot;, libraryStub)
1289     defineProperty(&quot;WEB_STUB&quot;, libraryStub)
1290 }
1291 
1292 ext.UPDATE_STUB_CACHE = (BUILD_CLOSED &amp;&amp; STUB_RUNTIME != &quot;&quot; &amp;&amp; !file(STUB_RUNTIME).isDirectory())
1293 
1294 
1295 /******************************************************************************
1296  *                                                                            *
1297  *                      Logging of Properties and Settings                    *
1298  *                                                                            *
1299  *  Log some of the settings we&#39;ve determined. We could log more here, it     *
1300  *  doesn&#39;t really hurt.                                                      *
1301  *                                                                            *
1302  *****************************************************************************/
1303 
1304 logger.quiet(&quot;gradle.gradleVersion: $gradle.gradleVersion&quot;)
1305 logger.quiet(&quot;OS_NAME: $OS_NAME&quot;)
1306 logger.quiet(&quot;OS_ARCH: $OS_ARCH&quot;)
1307 logger.quiet(&quot;JAVA_HOME: $JAVA_HOME&quot;)
1308 logger.quiet(&quot;JDK_HOME: $JDK_HOME&quot;)
1309 logger.quiet(&quot;java.runtime.version: ${javaRuntimeVersion}&quot;)
1310 logger.quiet(&quot;java version: ${javaVersion}&quot;)
1311 logger.quiet(&quot;java build number: ${javaBuildNumber}&quot;)
1312 logger.quiet(&quot;jdk.runtime.version: ${jdkRuntimeVersion}&quot;)
1313 logger.quiet(&quot;jdk version: ${jdkVersion}&quot;)
1314 logger.quiet(&quot;jdk build number: ${jdkBuildNumber}&quot;)
1315 logger.quiet(&quot;minimum jdk version: ${jfxBuildJdkVersionMin}&quot;)
1316 logger.quiet(&quot;minimum jdk build number: ${jfxBuildJdkBuildnumMin}&quot;)
1317 
1318 if (IS_LINUX) {
1319     logger.quiet(&quot;GCC version: ${jfxBuildLinuxGccVersion}&quot;)
1320 } else if (IS_WINDOWS) {
1321     logger.quiet(&quot;MSVC version: ${jfxBuildWindowsMsvcVersion}&quot;)
1322 } else if (IS_MAC) {
1323     logger.quiet(&quot;XCODE version: ${jfxBuildMacosxXcodeVersion}&quot;)
1324 }
1325 logger.quiet(&quot;cmake version: ${jfxBuildCmakeVersion}&quot;)
1326 logger.quiet(&quot;ninja version: ${jfxBuildNinjaVersion}&quot;)
1327 logger.quiet(&quot;ant version: ${jfxBuildAntVersion}&quot;)
1328 
1329 logger.quiet(&quot;HAS_JAVAFX_MODULES: $HAS_JAVAFX_MODULES&quot;)
1330 logger.quiet(&quot;STUB_RUNTIME: $STUB_RUNTIME&quot;)
1331 logger.quiet(&quot;CONF: $CONF&quot;)
1332 logger.quiet(&quot;NUM_COMPILE_THREADS: $NUM_COMPILE_THREADS&quot;)
1333 logger.quiet(&quot;COMPILE_TARGETS: $COMPILE_TARGETS&quot;)
1334 logger.quiet(&quot;COMPILE_FLAGS_FILES: $COMPILE_FLAGS_FILES&quot;)
1335 logger.quiet(&quot;HUDSON_JOB_NAME: $HUDSON_JOB_NAME&quot;)
1336 logger.quiet(&quot;HUDSON_BUILD_NUMBER: $HUDSON_BUILD_NUMBER&quot;)
1337 logger.quiet(&quot;PROMOTED_BUILD_NUMBER: $PROMOTED_BUILD_NUMBER&quot;)
1338 logger.quiet(&quot;PRODUCT_NAME: $PRODUCT_NAME&quot;)
1339 logger.quiet(&quot;RELEASE_VERSION: $RELEASE_VERSION&quot;)
1340 logger.quiet(&quot;RELEASE_SUFFIX: $RELEASE_SUFFIX&quot;)
1341 logger.quiet(&quot;RELEASE_VERSION_SHORT: $RELEASE_VERSION_SHORT&quot;)
1342 logger.quiet(&quot;RELEASE_VERSION_LONG: $RELEASE_VERSION_LONG&quot;)
1343 logger.quiet(&quot;RELEASE_VERSION_PADDED: $RELEASE_VERSION_PADDED&quot;)
1344 logger.quiet(&quot;MAVEN_PUBLISH: $MAVEN_PUBLISH&quot;)
1345 logger.quiet(&quot;MAVEN_VERSION: $MAVEN_VERSION&quot;)
1346 logger.quiet(&quot;UPDATE_STUB_CACHE: $UPDATE_STUB_CACHE&quot;)
1347 
1348 /******************************************************************************
1349  *                                                                            *
1350  *                Definition of Native Code Compilation Tasks                 *
1351  *                                                                            *
1352  *    - CCTask compiles native code. Specifically it will compile .m, .c,     *
1353  *      .cpp, or .cc files. It uses the headers provided by running           *
1354  *      &#39;javac -h&#39; plus additional platform specific headers. It will         *
1355  *      compile into .obj files.                                              *
1356  *    - LinkTask will perform native linking and create the .dll / .so /      *
1357  *      .dylib as necessary.                                                  *
1358  *                                                                            *
1359  *****************************************************************************/
1360 
1361 // Save a reference to the buildSrc.jar file because we need it for actually
1362 // compiling things, not just for the sake of this build script
1363 // (such as generating the JSL files, etc)
1364 ext.BUILD_SRC = rootProject.files(&quot;buildSrc/build/libs/buildSrc.jar&quot;)
1365 
1366 /**
1367  * Convenience method for creating cc, link, and &quot;native&quot; tasks in the given project. These
1368  * tasks are parameterized by name, so that we can produce, for example, ccGlass, etc
1369  * named tasks.
1370  *
1371  * @param project The project to add tasks to
1372  * @param name The name of the project, such as &quot;prism-common&quot;. This name is used
1373  *        in the name of the generated task, such as ccPrismCommon, and also
1374  *        in the name of the final library, such as libprism-common.dylib.
1375  */
1376 void addNative(Project project, String name) {
1377     // TODO if we want to handle 32/64 bit windows in the same build,
1378     // Then we will need to modify the win compile target to be win32 or win64
1379     def capitalName = name.split(&quot;-&quot;).collect{it.capitalize()}.join()
1380     def nativeTask = project.task(&quot;native$capitalName&quot;, group: &quot;Build&quot;) {
1381         description = &quot;Generates JNI headers, compiles, and builds native dynamic library for $name for all compile targets&quot;
1382     }
1383     def cleanTask = project.task(&quot;cleanNative$capitalName&quot;, type: Delete, group: &quot;Build&quot;) {
1384         description = &quot;Clean native objects for $name&quot;
1385     }
1386     if (project.hasProperty(&quot;nativeAllTask&quot;)) project.nativeAllTask.dependsOn nativeTask
1387     project.assemble.dependsOn(nativeTask)
1388     if (project.hasProperty(&quot;cleanNativeAllTask&quot;)) project.cleanNativeAllTask.dependsOn cleanTask
1389 
1390     // Each of the different compile targets will be placed in a sub directory
1391     // of these root dirs, with the name of the dir being the name of the target
1392     def nativeRootDir = project.file(&quot;$project.buildDir/native/$name&quot;)
1393     def libRootDir = project.file(&quot;$project.buildDir/libs/$name&quot;)
1394     // For each compile target, create a cc / link pair
1395     compileTargets { t -&gt;
1396         def targetProperties = project.rootProject.ext[t.upper]
1397         def library = targetProperties.library
1398         def properties = targetProperties.get(name)
1399         def nativeDir = file(&quot;$nativeRootDir/${t.name}&quot;)
1400         def headerDir = file(&quot;${project.buildDir}/gensrc/headers/${project.moduleName}&quot;)
1401 
1402         // If there is not a library clause in the properties, assume it is not wanted
1403         if (!targetProperties.containsKey(name)) {
1404             println(&quot;Ignoring native library ${name}. Not defined in ${t.name} project properties&quot;);
1405             return
1406         }
1407 
1408         // check for the property disable${name} = true
1409         def String disableKey = &quot;disable${name}&quot;
1410         def boolean disabled = targetProperties.containsKey(disableKey) ? targetProperties.get(disableKey) : false
1411         if (disabled) {
1412             println(&quot;Native library ${name} disabled in ${t.name} project properties&quot;);
1413             return
1414         }
1415 
1416         def variants = properties.containsKey(&quot;variants&quot;) ? properties.variants : [&quot;&quot;];
1417         variants.each { variant -&gt;
1418             def variantProperties = variant == &quot;&quot; ? properties : properties.get(variant)
1419             def capitalVariant = variant.capitalize()
1420             def ccOutput = variant == &quot;&quot; ? nativeDir : file(&quot;$nativeDir/$variant&quot;)
1421             def ccTask = project.task(&quot;cc${t.capital}$capitalName$capitalVariant&quot;, type: CCTask, group: &quot;Build&quot;) {
1422                 description = &quot;Compiles native sources for ${name} for ${t.name}${capitalVariant != &#39;&#39; ? &#39; for variant &#39; + capitalVariant : &#39;&#39;}&quot;
1423                 matches = &quot;.*\\.c|.*\\.cpp|.*\\.m|.*\\.cc&quot;
1424                 headers = headerDir
1425                 output(ccOutput)
1426                 params.addAll(variantProperties.ccFlags)
1427                 compiler = variantProperties.compiler
1428                 source(variantProperties.nativeSource)
1429                 cleanTask.delete ccOutput
1430             }
1431             def linkTask = project.task(&quot;link${t.capital}$capitalName$capitalVariant&quot;, type: LinkTask, dependsOn: ccTask, group: &quot;Build&quot;) {
1432                 description = &quot;Creates native dynamic library for $name for ${t.name}${capitalVariant != &#39;&#39; ? &#39; for variant &#39; + capitalVariant : &#39;&#39;}&quot;
1433                 objectDir = ccOutput
1434                 linkParams.addAll(variantProperties.linkFlags)
1435                 lib = file(&quot;$libRootDir/${t.name}/${variant == &#39;&#39; ? library(properties.lib) : library(variantProperties.lib)}&quot;)
1436                 linker = variantProperties.linker
1437                 cleanTask.delete &quot;$libRootDir/${t.name}&quot;
1438             }
1439             nativeTask.dependsOn(linkTask)
1440             if (IS_WINDOWS &amp;&amp; t.name == &quot;win&quot; &amp;&amp; (!IS_STATIC_BUILD || name == &quot;glass&quot;)) {
1441                 def rcTask = project.task(&quot;rc$capitalName$capitalVariant&quot;, type: CompileResourceTask, group: &quot;Build&quot;) {
1442                     description = &quot;Compiles native sources for $name&quot;
1443                     matches = &quot;.*\\.rc&quot;
1444                     compiler = variantProperties.rcCompiler
1445                     source(variantProperties.rcSource)
1446                     if (variantProperties.rcFlags) {
1447                         rcParams.addAll(variantProperties.rcFlags)
1448                     }
1449                     output(ccOutput)
1450                 }
1451                 linkTask.dependsOn rcTask;
1452             }
1453         }
1454 
1455         def useLipo = targetProperties.containsKey(&#39;useLipo&#39;) ? targetProperties.useLipo : false
1456         if (useLipo) {
1457             def lipoTask = project.task(&quot;lipo${t.capital}$capitalName&quot;, type: LipoTask, group: &quot;Build&quot;) {
1458                 description = &quot;Creates native fat library for $name for ${t.name}&quot;
1459                 libDir = file(&quot;$libRootDir/${t.name}&quot;)
1460                 lib = file(&quot;$libRootDir/${t.name}/${library(properties.lib)}&quot;)
1461             }
1462             nativeTask.dependsOn(lipoTask)
1463         }
1464     }
1465 }
1466 
1467 void addJSL(Project project, String name, String pkg, List&lt;String&gt; addExports, Closure compile) {
1468     def lowerName = name.toLowerCase()
1469 
1470     def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
1471     modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.base/build/classes/java/main&quot;
1472     def compileCompilers = project.task(&quot;compile${name}Compilers&quot;,
1473             type: JavaCompile,
1474             dependsOn: project.compileJava) {
1475         description = &quot;Compile the $name JSL Compilers&quot;
1476 
1477         classpath =
1478                project.files(project.sourceSets.jslc.java.outputDir) +
1479                project.configurations.antlr
1480         source = [project.file(&quot;src/main/jsl-$lowerName&quot;)]
1481         destinationDir = project.file(&quot;$project.buildDir/classes/jsl-compilers/$lowerName&quot;)
1482 
1483         options.compilerArgs.addAll([
1484             &quot;-implicit:none&quot;,
1485             &quot;--module-path&quot;, modulePath,
1486             &quot;--add-modules=javafx.graphics&quot;
1487             ])
1488         if (addExports != null) {
1489             options.compilerArgs.addAll(addExports)
1490         }
1491     }
1492 
1493     def generateShaders = project.task(&quot;generate${name}Shaders&quot;,
1494             dependsOn: compileCompilers) {
1495         description = &quot;Generate $name shaders from JSL&quot;
1496         def sourceDir = project.file(&quot;src/main/jsl-$lowerName&quot;)
1497         def destinationDir = project.file(&quot;$project.buildDir/gensrc/jsl-$lowerName&quot;)
1498         inputs.dir sourceDir
1499         outputs.dir destinationDir
1500         doLast {
1501             compile(sourceDir, destinationDir)
1502         }
1503     }
1504 
1505     def compileHLSLShaders = project.task(&quot;compile${name}HLSLShaders&quot;,
1506             dependsOn: generateShaders,
1507             type: CompileHLSLTask) {
1508         enabled = IS_WINDOWS
1509         description = &quot;Compile $name HLSL files into .obj files&quot;
1510         matches = &quot;.*\\.hlsl&quot;
1511         output project.file(&quot;$project.buildDir/hlsl/$name/$pkg&quot;)
1512         source project.file(&quot;$project.buildDir/gensrc/jsl-$lowerName/$pkg&quot;)
1513     }
1514 
1515     def processShaders = project.task(&quot;process${name}Shaders&quot;,
1516             dependsOn: [generateShaders, compileHLSLShaders],
1517             type: Copy,
1518             description: &quot;Copy hlsl / frag shaders to build/resources/jsl-$lowerName&quot;) {
1519         from(&quot;$project.buildDir/hlsl/$name&quot;) {
1520             include &quot;**/*.obj&quot;
1521         }
1522         from(&quot;$project.buildDir/gensrc/jsl-$lowerName&quot;) {
1523             include(&quot;**/*.frag&quot;)
1524         }
1525         into project.moduleDir
1526     }
1527 
1528     project.processShaders.dependsOn(processShaders)
1529     project.sourceSets.shaders.output.dir(&quot;$project.buildDir/gensrc/jsl-$lowerName&quot;, builtBy: processShaders )
1530 
1531     def processShimsShaders = project.task(&quot;process${name}ShimsShaders&quot;,
1532             dependsOn: [generateShaders, compileHLSLShaders],
1533             type: Copy,
1534             description: &quot;Copy hlsl / frag shaders to shims&quot;) {
1535         from(&quot;$project.buildDir/hlsl/$name&quot;) {
1536             include &quot;**/*.obj&quot;
1537         }
1538         from(&quot;$project.buildDir/gensrc/jsl-$lowerName&quot;) {
1539             include(&quot;**/*.frag&quot;)
1540         }
1541         into project.moduleShimsDir
1542     }
1543 
1544     project.processShimsShaders.dependsOn(processShimsShaders)
1545 
1546 }
1547 
1548 void addMavenPublication(Project project, List&lt;String&gt; projectDependencies) {
1549     if (!IS_MAVEN_PUBLISH) {
1550         return
1551     }
1552 
1553     project.apply plugin: &#39;maven-publish&#39;
1554 
1555     project.group = MAVEN_GROUP_ID
1556     project.version = MAVEN_VERSION
1557 
1558     if (project.name == &#39;base&#39;) {
1559         project.publishing {
1560             publications {
1561                 javafx(MavenPublication) {
1562                     artifactId = &#39;javafx&#39;
1563                     artifacts = []
1564                 }
1565             }
1566         }
1567     }
1568 
1569     gradle.taskGraph.whenReady { g -&gt;
1570         project.tasks.findAll { it.name == &#39;generatePomFileForJavafxPublication&#39;}.each { it -&gt;
1571             it.doLast {
1572                 copy {
1573                     into project.file(&quot;${project.buildDir}/publications/javafx&quot;)
1574                     from file(&quot;${rootProject.projectDir}/javafx.pom&quot;)
1575                     rename &quot;javafx.pom&quot;, &quot;pom-default.xml&quot;
1576                     filter { line -&gt;
1577                         line.replaceAll(&quot;@VERSION@&quot;, MAVEN_VERSION)
1578                     }
1579                 }
1580             }
1581         }
1582     }
1583 
1584     project.publishing {
1585         repositories {
1586             maven {
1587                 def repositoryUrl = project.hasProperty(&#39;repositoryUrl&#39;) ? project.getProperty(&#39;repositoryUrl&#39;) : &quot;&quot;
1588                 def repositoryUsername = project.hasProperty(&#39;repositoryUsername&#39;) ? project.getProperty(&#39;repositoryUsername&#39;) : &quot;&quot;
1589                 def repositoryPassword = project.hasProperty(&#39;repositoryPassword&#39;) ? project.getProperty(&#39;repositoryPassword&#39;) : &quot;&quot;
1590                 url repositoryUrl
1591                 credentials {
1592                    username repositoryUsername
1593                    password repositoryPassword
1594                 }
1595             }
1596         }
1597     }
1598 
1599     compileTargets { t -&gt;
1600         project.publishing {
1601             publications {
1602                 maven(MavenPublication) {
1603                     artifactId = &quot;javafx-${project.name}&quot;
1604 
1605                     afterEvaluate {
1606                         artifact project.tasks.&quot;moduleEmptyPublicationJar$t.capital&quot;
1607                         artifact project.tasks.&quot;modularPublicationJar$t.capital&quot; {
1608                             classifier &quot;$t.name&quot;
1609                         }
1610                     }
1611 
1612                     pom.withXml {
1613                         Node parent = asNode().appendNode(&quot;parent&quot;)
1614                         parent.appendNode(&quot;groupId&quot;, MAVEN_GROUP_ID)
1615                         parent.appendNode(&quot;artifactId&quot;, &quot;javafx&quot;)
1616                         parent.appendNode(&quot;version&quot;, MAVEN_VERSION)
1617 
1618                         Node dependencies = asNode().appendNode(&quot;dependencies&quot;)
1619 
1620                         Node projectDependencyPlatform = dependencies.appendNode(&quot;dependency&quot;)
1621                         projectDependencyPlatform.appendNode(&quot;groupId&quot;, MAVEN_GROUP_ID)
1622                         projectDependencyPlatform.appendNode(&quot;artifactId&quot;, &quot;javafx-${project.name}&quot;)
1623                         projectDependencyPlatform.appendNode(&quot;version&quot;, MAVEN_VERSION)
1624                         projectDependencyPlatform.appendNode(&quot;classifier&quot;, &quot;\${javafx.platform}&quot;)
1625 
1626                         if (!projectDependencies.empty) {
1627                             projectDependencies.each { dep -&gt;
1628                                 Node projectDependency = dependencies.appendNode(&quot;dependency&quot;)
1629                                 projectDependency.appendNode(&quot;groupId&quot;, MAVEN_GROUP_ID)
1630                                 projectDependency.appendNode(&quot;artifactId&quot;, &quot;javafx-$dep&quot;)
1631                                 projectDependency.appendNode(&quot;version&quot;, MAVEN_VERSION)
1632                            }
1633                         }
1634                     }
1635                 }
1636             }
1637 
1638         }
1639     }
1640 }
1641 
1642 /**
1643  * Verifies that all of the *.java files in a source tree have the
1644  * correct package name. If not, fail the build.
1645  *
1646  * @param sourceRoot the root of the source tree to check
1647  * @param hasModuleName true if the sources under sourceRoot are being
1648  * compiled as modules, with the immediate child directories being the
1649  * root(s) of the named modules being compiled. In this case the package
1650  * root is one directory below the sourceRoot.
1651  */
1652 void validatePackages(File sourceRoot, boolean hasModuleName) {
1653     if (!sourceRoot.isDirectory()) {
1654         return;
1655     }
1656     def err = false;
1657     String sourceString = sourceRoot.toString().replace(&quot;\\&quot;, &quot;/&quot;)
1658     def startPos = sourceString.length() + 1
1659     logger.info(&quot;validating packages for ${sourceRoot}&quot;)
1660     def inputFiles = fileTree(dir: sourceRoot, include: &quot;**/*.java&quot;)
1661     inputFiles.each { file -&gt;
1662         def packageRoot = file.toString().replace(&quot;\\&quot;, &quot;/&quot;).substring(startPos)
1663         if (hasModuleName) {
1664             packageRoot = packageRoot.substring(packageRoot.indexOf(&quot;/&quot;) + 1)
1665         }
1666         def endPos = packageRoot.lastIndexOf(&quot;/&quot;)
1667         def pkgEx = endPos &gt; -1 ?  packageRoot.substring(0, endPos).replace(&quot;/&quot;, &quot;.&quot;) : &quot;&quot;
1668         def pkg = &quot;&quot;
1669         file.withReader { reader -&gt;
1670             def line
1671             while ((line = reader.readLine()) != null) {
1672                 def words = line.trim().split(&quot;[ ;]+&quot;)
1673                 if (words.length &gt; 1 &amp;&amp; words[0] == &quot;package&quot;) {
1674                     pkg = words[1]
1675                     break;
1676                 }
1677             }
1678         }
1679         if (pkg != pkgEx) {
1680             err = true
1681             println &quot;*** ERROR: File location &lt;${file}&gt; does not match package name &lt;${pkg}&gt;&quot;
1682         }
1683     }
1684     if (err) {
1685         fail(&quot;Package validation failed&quot;)
1686     }
1687 }
1688 
1689 /**
1690  * Add a task to the given project to validate that the package names
1691  * of all java files in the given source sets have the correct package
1692  * name. If not, fail the build.
1693  */
1694 void addValidateSourceSets(Project project,
1695                            Collection&lt;SourceSet&gt; sourceSets,
1696                            Collection&lt;SourceSet&gt; modSourceSets) {
1697     def validateSourceSetsTask = project.task(&quot;validateSourceSets&quot;) {
1698         doLast {
1699             // Accumulate the root directories from all sourceSets.
1700             // We use a Set to elide duplicates (the shims sourceset
1701             // will include the dirs from the main sourceset)
1702             Set&lt;File&gt; sourceRoots = []
1703             sourceSets.each { srcSet -&gt;
1704                 srcSet.java.srcDirs.each { rootDir -&gt;
1705                     sourceRoots += rootDir
1706                 }
1707             }
1708             sourceRoots.each { rootDir -&gt;
1709                 validatePackages(rootDir, false)
1710             }
1711 
1712             Set&lt;File&gt; modSourceRoots = []
1713             modSourceSets.each { srcSet -&gt;
1714                 srcSet.java.srcDirs.each { rootDir -&gt;
1715                     modSourceRoots += rootDir
1716                 }
1717             }
1718             modSourceRoots.each { rootDir -&gt;
1719                 validatePackages(rootDir, true)
1720             }
1721         }
1722     }
1723 
1724     // Run this for all projects when compiling the test sources
1725     // (i.e., when running &quot;gradle test&quot;)
1726     project.compileTestJava.dependsOn(validateSourceSetsTask)
1727 }
1728 
1729 void addValidateSourceSets(Project project, Collection&lt;SourceSet&gt; sourceSets) {
1730     addValidateSourceSets(project, sourceSets, []);
1731 }
1732 
1733 
1734 /**
1735  * Parses a JDK version string. The string must be in one of the following
1736  * two formats:
1737  *
1738  *     major.minor.subminor
1739  * or
1740  *     major.minor.subminor_update
1741  *
1742  * In both cases a list of 4 integers is returned, with element 3 set to
1743  * 0 in the former case.
1744  */
1745 List parseJdkVersion(String version) {
1746     def arr = version.split(&quot;[_\\.]&quot;);
1747     def intArr = [];
1748     arr.each { s -&gt; intArr += Integer.parseInt(s); }
1749     while (intArr.size() &lt; 4) intArr += 0;
1750     return intArr;
1751 }
1752 
1753 /**
1754  * Returns -1, 0, or 1 depending on whether JDK version &quot;a&quot; is less than,
1755  * equal to, or grater than version &quot;b&quot;.
1756  */
1757 int compareJdkVersion(String a, String b) {
1758     def aIntArr = parseJdkVersion(a);
1759     def bIntArr = parseJdkVersion(b);
1760 
1761     for (int i = 0; i &lt; 4; i++) {
1762         if (aIntArr[i] &lt; bIntArr[i]) return -1;
1763         if (aIntArr[i] &gt; bIntArr[i]) return  1;
1764     }
1765     return 0;
1766 }
1767 
1768 // Task to verify the minimum level of Java needed to build JavaFX
1769 task verifyJava() {
1770     doLast {
1771         def status = compareJdkVersion(jdkVersion, jfxBuildJdkVersionMin);
1772         if (status &lt; 0) {
1773             fail(&quot;java version mismatch: JDK version (${jdkVersion}) &lt; minimum version (${jfxBuildJdkVersionMin})&quot;)
1774         } else if (status == 0) {
1775             def buildNum = Integer.parseInt(jdkBuildNumber)
1776             def minBuildNum = Integer.parseInt(jfxBuildJdkBuildnumMin)
1777             if (buildNum != 0 &amp;&amp; buildNum &lt; minBuildNum) {
1778                 fail(&quot;JDK build number ($buildNum) &lt; minimum build number ($minBuildNum)&quot;)
1779             }
1780         }
1781     }
1782 }
1783 
1784 task updateCacheIfNeeded() {
1785     // an empty task we can add to as needed for UPDATE_STUB_CACHE
1786 }
1787 
1788 task createTestArgfiles {
1789     // an empty task we can add to as needed
1790 }
1791 
1792 
1793 /*****************************************************************************
1794 *        Project definitions (dependencies, etc)                             *
1795 *****************************************************************************/
1796 
1797 void addJCov(p, test) {
1798     test.doFirst {
1799         def jcovJVMArgument =
1800                 &quot;include=javafx,&quot; +
1801                 &quot;include=com.sun.javafx,&quot; +
1802                 &quot;include=com.sun.glass,&quot; +
1803                 &quot;include=com.sun.openpisces,&quot; +
1804                 &quot;include=com.sun.pisces,&quot; +
1805                 &quot;include=com.sun.prism,&quot; +
1806                 &quot;include=com.sun.scenario,&quot; +
1807                 &quot;include=com.sun.webkit,&quot; +
1808                 &quot;exclude=com,&quot; +
1809                 &quot;exclude=java,&quot; +
1810                 &quot;exclude=javax,&quot; +
1811                 &quot;exclude=\&quot;**.test\&quot;,&quot; +
1812                 &quot;exclude=\&quot;**.*Test\&quot;,&quot; +
1813                 &quot;file=build/reports/jcov/report.xml,&quot; +
1814                 &quot;merge=merge&quot;;
1815         test.jvmArgs(&quot;-javaagent:${p.configurations.testCompile.files.find { it.name.startsWith(&#39;jcov&#39;) }}=$jcovJVMArgument&quot;);
1816         p.mkdir p.file(&quot;build/reports/jcov&quot;)
1817     }
1818     test.doLast {
1819         def reportFile = p.file(&quot;build/reports/jcov/report.xml&quot;)
1820         if (reportFile.exists()) {
1821             p.javaexec {
1822                 workingDir = p.file(&quot;build/reports/jcov&quot;)
1823                 classpath = p.files(p.configurations.testCompile.files.find { it.name.startsWith(&#39;jcov&#39;) })
1824                 main = &quot;com.sun.tdk.jcov.Helper&quot;
1825                 args = [
1826                         &quot;RepGen&quot;,
1827                         &quot;-exclude&quot;, &quot;\&quot;**.test\&quot;&quot;,
1828                         &quot;-exclude&quot;, &quot;\&quot;**.*Test\&quot;&quot;,
1829                         &quot;-output&quot;, &quot;.&quot;,
1830                         &quot;-source&quot;, p.sourceSets.main.java.srcDirs.collect{p.file(it)}.join(&quot;:&quot;),
1831                         &quot;report.xml&quot;
1832                 ]
1833             }
1834         }
1835     }
1836 }
1837 
1838 allprojects {
1839 
1840     // Setup the repositories that we&#39;ll download libraries from.
1841     // By default we use Maven Central for most things. The custom &quot;ivy&quot;
1842     // repo is for downloading SWT. The way it works is to setup the
1843     // download URL such that it will resolve to the actual jar file to
1844     // download. See SWT_FILE_NAME for the name of the jar that will be
1845     // used as the &quot;artifact&quot; in the pattern below.
1846     // If JFX_DEPS_URL is set, then that overrides the default
1847     // repositories. This allows the dependencies to be cached locally.
1848 
1849     if (JFX_DEPS_URL != &quot;&quot;) {
1850         repositories {
1851             ivy {
1852                 url JFX_DEPS_URL
1853                 metadataSources {
1854                     artifact()
1855                 }
1856                 patternLayout {
1857                     artifact &quot;[artifact]-[revision](-[classifier]).[ext]&quot;
1858                     artifact &quot;[artifact].[ext]&quot;
1859                 }
1860             }
1861         }
1862     }
1863 
1864     if (JFX_DEPS_URL == &quot;&quot;) {
1865         repositories {
1866             mavenCentral()
1867             ivy {
1868                 url &quot;https://download.eclipse.org/eclipse/updates/4.6/R-4.6.3-201703010400/plugins/&quot;
1869                 metadataSources {
1870                     artifact()
1871                 }
1872                 patternLayout {
1873                     artifact &quot;[artifact].[ext]&quot;
1874                 }
1875             }
1876         }
1877     }
1878 
1879     if (JFX_DEPS_URL == &quot;&quot; &amp;&amp; IS_BUILD_LIBAV_STUBS) {
1880         repositories {
1881             ivy {
1882                 url libAVRepositoryURL
1883                 metadataSources {
1884                     artifact()
1885                 }
1886                 patternLayout {
1887                     artifact &quot;[artifact].[ext]&quot;
1888                 }
1889             }
1890             ivy {
1891                 url FFmpegRepositoryURL
1892                 metadataSources {
1893                     artifact()
1894                 }
1895                 patternLayout {
1896                     artifact &quot;[artifact].[ext]&quot;
1897                 }
1898             }
1899         }
1900     }
1901 
1902     // We want to configure all projects as java projects and use the same compile settings
1903     // etc, except for the root project which we just want to ignore (and for now media)
1904     if (project == rootProject) {
1905        return
1906     }
1907     if (project.path.startsWith(&quot;:apps&quot;)) {
1908         // Lets handle the apps tree differently, as it is a collection of ant builds,
1909         // and the ant importer collides with the &#39;apply plugin:java&#39;
1910         return
1911     }
1912 
1913     // All of our projects are java projects
1914 
1915     apply plugin: &quot;java&quot;
1916     sourceCompatibility = 11
1917 
1918     // By default all of our projects require junit for testing so we can just
1919     // setup this dependency here.
1920     dependencies {
1921         testCompile group: &quot;junit&quot;, name: &quot;junit&quot;, version: &quot;4.8.2&quot;
1922         if (BUILD_CLOSED &amp;&amp; DO_JCOV)  {
1923             testCompile name: &quot;jcov&quot;
1924         }
1925     }
1926 
1927     compileJava.dependsOn verifyJava
1928 
1929     // At the moment the ASM library shipped with Gradle that is used to
1930     // discover the different test classes fails on Java 8, so in order
1931     // to have sourceCompatibility set to 1.8 I have to also turn scanForClasses off
1932     // and manually specify the includes / excludes. At the moment we use
1933     // Java 7 but when we switch to 8 this will be needed, and probably again when
1934     // we start building with Java 9.
1935     test {
1936         executable = JAVA;
1937         enableAssertions = true;
1938         testLogging.exceptionFormat = &quot;full&quot;;
1939         scanForTestClasses = false;
1940         include(&quot;**/*Test.*&quot;);
1941         if (BUILD_CLOSED &amp;&amp; DO_JCOV) {
1942             addJCov(project, test)
1943         }
1944 
1945         if (IS_HEADLESS_TEST) {
1946             systemProperty &#39;glass.platform&#39;, &#39;Monocle&#39;
1947             systemProperty &#39;monocle.platform&#39;, &#39;Headless&#39;
1948             systemProperty &#39;prism.order&#39;, &#39;sw&#39;
1949             systemProperty &#39;com.sun.javafx.gestures.zoom&#39;, &#39;true&#39;
1950             systemProperty &#39;com.sun.javafx.gestures.rotate&#39;, &#39;true&#39;
1951             systemProperty &#39;com.sun.javafx.gestures.scroll&#39;, &#39;true&#39;
1952         }
1953 
1954         systemProperty &#39;unstable.test&#39;, IS_UNSTABLE_TEST
1955     }
1956 
1957     compileTestJava {
1958     }
1959 }
1960 
1961 // These strings define the module-source-path to be used in compilation.
1962 // They need to contain the full paths to the sources and the * will be
1963 // used to infer the module name that is used.
1964 project.ext.defaultModuleSourcePath =
1965     cygpath(rootProject.projectDir.path + &#39;/modules/*/src/main/java&#39;) +
1966         File.pathSeparator  +
1967     cygpath(rootProject.projectDir.path + &#39;/modules/*/build/gensrc/{java,jsl-decora,jsl-prism}&#39;)
1968 
1969 // graphics pass one
1970 project.ext.defaultModuleSourcePath_GraphicsOne =
1971     cygpath(rootProject.projectDir.path + &#39;/modules/*/src/main/java&#39;) +
1972         File.pathSeparator  +
1973     cygpath(rootProject.projectDir.path + &#39;/modules/*/build/gensrc/{java,jsl-decora,jsl-prism}&#39;)
1974 
1975 // web pass one
1976 project.ext.defaultModuleSourcePath_WebOne =
1977     cygpath(rootProject.projectDir.path + &#39;/modules/*/src/main/java&#39;)
1978 
1979 // Compiling the test shim files too.
1980 project.ext.defaultModuleSourcePathShim =
1981     cygpath(rootProject.projectDir.path + &#39;/modules/*/src/{main,shims}/java&#39;) +
1982         File.pathSeparator  +
1983     cygpath(rootProject.projectDir.path + &#39;/modules/*/build/gensrc/{java,jsl-decora,jsl-prism}&#39;)
1984 
1985 // The &quot;base&quot; project is our first module and the most basic one required for
1986 // all other modules. It is useful even for non-GUI applications.
1987 project(&quot;:base&quot;) {
1988     project.ext.buildModule = true
1989     project.ext.includeSources = true
1990     project.ext.moduleRuntime = true
1991     project.ext.moduleName = &quot;javafx.base&quot;
1992 
1993     sourceSets {
1994         main
1995         shims {
1996             java {
1997                 compileClasspath += sourceSets.main.output
1998                 runtimeClasspath += sourceSets.main.output
1999             }
2000         }
2001         test {
2002             java {
2003                 compileClasspath += sourceSets.shims.output
2004                 runtimeClasspath += sourceSets.shims.output
2005             }
2006         }
2007     }
2008 
2009     dependencies {
2010         testCompile group: &quot;junit&quot;, name: &quot;junit&quot;, version: &quot;4.8.2&quot;
2011         testCompile sourceSets.main.output
2012         testCompile sourceSets.shims.output
2013     }
2014 
2015     commonModuleSetup(project, [ &#39;base&#39; ])
2016 
2017     project.ext.moduleSourcePath = defaultModuleSourcePath
2018     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2019 
2020     // We need to take the VersionInfo.java file and replace the various
2021     // properties within it
2022     def replacements = [
2023         &quot;BUILD_TIMESTAMP&quot;: BUILD_TIMESTAMP,
2024         &quot;HUDSON_JOB_NAME&quot;: HUDSON_JOB_NAME,
2025         &quot;HUDSON_BUILD_NUMBER&quot;: HUDSON_BUILD_NUMBER,
2026         &quot;PROMOTED_BUILD_NUMBER&quot;: PROMOTED_BUILD_NUMBER,
2027         &quot;PRODUCT_NAME&quot;: PRODUCT_NAME,
2028         &quot;RELEASE_VERSION&quot;: RELEASE_VERSION,
2029         &quot;RELEASE_SUFFIX&quot;: RELEASE_SUFFIX];
2030     task processVersionInfo(type: Copy, description: &quot;Replace params in VersionInfo and copy file to destination&quot;) {
2031         doFirst { mkdir &quot;$buildDir/gensrc/java&quot; }
2032         from &quot;src/main/version-info&quot;
2033         into &quot;$buildDir/gensrc/java/com/sun/javafx/runtime&quot;
2034         filter {line-&gt;
2035             replacements.each() {k, v -&gt;
2036                 line = line.replace(&quot;@$k@&quot;, v.toString());
2037             }
2038             line
2039         }
2040     }
2041 
2042     // Make sure to include $buildDir/gensrc/java that we previously created.
2043     // We DO NOT want to include src/main/version-info
2044 
2045     sourceSets.main.java.srcDirs += &quot;$buildDir/gensrc/java&quot;
2046 
2047     compileJava.dependsOn processVersionInfo
2048     addMavenPublication(project, [])
2049 
2050     addValidateSourceSets(project, sourceSets)
2051 }
2052 
2053 // The graphics module is needed for any graphical JavaFX application. It requires
2054 // the base module and includes the scene graph, layout, css, prism, windowing, etc.
2055 // This is a fairly complicated module. There are many different types of native components
2056 // that all need to be compiled.
2057 project(&quot;:graphics&quot;) {
2058 
2059     project.ext.buildModule = true
2060     project.ext.includeSources = true
2061     project.ext.moduleRuntime = true
2062     project.ext.moduleName = &quot;javafx.graphics&quot;
2063 
2064     getConfigurations().create(&quot;antlr&quot;);
2065 
2066     sourceSets {
2067         jslc   // JSLC gramar subset
2068         main
2069         shims {
2070             java {
2071                 compileClasspath += sourceSets.main.output
2072                 runtimeClasspath += sourceSets.main.output
2073             }
2074         }
2075         shaders // generated shaders (prism &amp; decora)
2076         test {
2077             java {
2078                 compileClasspath += sourceSets.shims.output
2079                 runtimeClasspath += sourceSets.shims.output
2080             }
2081         }
2082         stub
2083     }
2084 
2085     dependencies {
2086         stubCompile group: &quot;junit&quot;, name: &quot;junit&quot;, version: &quot;4.8.2&quot;
2087 
2088         antlr group: &quot;org.antlr&quot;, name: &quot;antlr4&quot;, version: &quot;4.7.2&quot;, classifier: &quot;complete&quot;
2089         compile project(&#39;:base&#39;)
2090     }
2091 
2092     project.ext.moduleSourcePath = defaultModuleSourcePath_GraphicsOne
2093     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2094 
2095     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39; ])
2096 
2097     List&lt;String&gt; decoraAddExports = [
2098             &#39;--add-exports=javafx.graphics/com.sun.scenario.effect=ALL-UNNAMED&#39;,
2099             &#39;--add-exports=javafx.graphics/com.sun.scenario.effect.light=ALL-UNNAMED&#39;,
2100             &#39;--add-exports=javafx.graphics/com.sun.scenario.effect.impl.state=ALL-UNNAMED&#39;
2101             ]
2102     /*
2103     Graphics compilation is &quot;complicated&quot; by the generated shaders.
2104 
2105     We have two shader groups - Decora and Prism.
2106 
2107     The shader groups each will generate a custom compiler that
2108     then genarates the shader code. These compilers rely on the JSLC
2109     gramar parser which is antlr generated and compile separately.
2110 
2111     The decora compiler relies on compileJava - which is sourceSet.main.java
2112     It also accesses module private packages, so will need add-exports
2113 
2114     Once the shader java code is generated, we can compileFullJava
2115 
2116     After that, we can generate the required native header and then build the native code
2117     */
2118 
2119     project.task(&quot;processShaders&quot;) {
2120         // an empty task to hang the prism and decora shaders on
2121     }
2122 
2123     project.task(&quot;processShimsShaders&quot;) {
2124         // an empty task to hang the prism and decora shaders on
2125     }
2126 
2127     compileShimsJava.dependsOn(&quot;processShimsShaders&quot;)
2128 
2129     // Generate the JSLC support grammar
2130     project.task(&quot;generateGrammarSource&quot;, type: JavaExec) {
2131         // use antlr to generate our grammar.
2132         // note: the antlr plugin creates some issues with the other compiles
2133         // so we will do this by hand
2134 
2135         File wd = file(project.projectDir.path + &quot;/src/jslc/antlr&quot;)
2136         File outDir = file(&quot;$buildDir/gensrc/antlr&quot;)
2137         def inJSL = &quot;com/sun/scenario/effect/compiler/JSL.g4&quot;
2138         if (IS_WINDOWS) {
2139             // antlr needs backslashes on Windows
2140             inJSL = inJSL.replace(&quot;/&quot;, &quot;\\&quot;)
2141         }
2142 
2143         executable = JAVA
2144         classpath = project.configurations.antlr
2145         workingDir = wd
2146         main = &quot;org.antlr.v4.Tool&quot;
2147 
2148         args = [
2149             &quot;-o&quot;,
2150             outDir.toString(),
2151             &quot;-package&quot;,
2152             &quot;com.sun.scenario.effect.compiler&quot;,
2153             &quot;-visitor&quot;,
2154             inJSL ]
2155 
2156         inputs.dir wd
2157         outputs.dir outDir
2158     }
2159     sourceSets.jslc.java.srcDirs += &quot;$buildDir/gensrc/antlr&quot;
2160 
2161     // and compile the JSLC support classes
2162     compileJslcJava.dependsOn(generateGrammarSource)
2163     compileJslcJava.classpath = project.configurations.antlr
2164 
2165     compileJava.dependsOn(compileJslcJava)
2166 
2167     // this task is the &quot;second pass&quot; compile of all of the module classes
2168     project.task(&quot;compileFullJava&quot;, type: JavaCompile, dependsOn: processShaders) {
2169         description = &quot;Compile all of the graphics java classes - main and shaders&quot;
2170 
2171         classpath = configurations.compile
2172 
2173         source = project.sourceSets.main.java.srcDirs
2174         source += &quot;$buildDir/gensrc/java&quot;
2175         source += project.sourceSets.shaders.output
2176 
2177         destinationDir = project.sourceSets.main.java.outputDir
2178         options.compilerArgs.addAll([
2179             &#39;-h&#39;, &quot;$buildDir/gensrc/headers/&quot;,  // Note: this creates the native headers
2180             &#39;-implicit:none&#39;,
2181             &#39;--module-source-path&#39;, defaultModuleSourcePath
2182             ] )
2183     }
2184     classes.dependsOn(compileFullJava)
2185 
2186     project.sourceSets.shims.java.srcDirs += project.sourceSets.shaders.output
2187     project.sourceSets.shims.java.srcDirs += &quot;$buildDir/gensrc/jsl-prism&quot;
2188     project.sourceSets.shims.java.srcDirs += &quot;$buildDir/gensrc/jsl-decora&quot;
2189 
2190     compileShimsJava.dependsOn(compileFullJava)
2191 
2192     // Create a single &quot;native&quot; task which will depend on all the individual native tasks for graphics
2193     project.ext.nativeAllTask = task(&quot;native&quot;, group: &quot;Build&quot;, description: &quot;Compiles and Builds all native libraries for Graphics&quot;);
2194     project.ext.cleanNativeAllTask = task(&quot;cleanNative&quot;, group: &quot;Build&quot;, description: &quot;Clean all native libraries and objects for Graphics&quot;);
2195 
2196     // Add tasks for native compilation
2197     addNative(project, &quot;glass&quot;);
2198     addNative(project, &quot;prism&quot;)
2199     addNative(project, &quot;prismSW&quot;)
2200     addNative(project, &quot;font&quot;)
2201     addNative(project, &quot;iio&quot;)
2202     addNative(project, &quot;prismES2&quot;)
2203 
2204     if (IS_COMPILE_PANGO) {
2205         addNative(project, &quot;fontFreetype&quot;)
2206         addNative(project, &quot;fontPango&quot;)
2207     }
2208 
2209     if (IS_WINDOWS) {
2210         addNative(project, &quot;prismD3D&quot;)
2211         // TODO need to hook this up to be executed only if PassThroughVS.h is missing or PassThroughVS.hlsl is changed
2212         task generateD3DHeaders(group: &quot;Build&quot;) {
2213             enabled = IS_WINDOWS
2214             inputs.file &quot;src/main/native-prism-d3d/hlsl/Mtl1PS.hlsl&quot;
2215             inputs.file &quot;src/main/native-prism-d3d/hlsl/Mtl1VS.hlsl&quot;
2216             inputs.file &quot;src/main/native-prism-d3d/PassThroughVS.hlsl&quot;
2217             outputs.dir &quot;$buildDir/headers/PrismD3D/&quot;
2218             outputs.dir &quot;$buildDir/headers/PrismD3D/hlsl/&quot;
2219             description = &quot;Generate headers by compiling hlsl files&quot;
2220             doLast {
2221                 mkdir file(&quot;$buildDir/headers/PrismD3D/hlsl&quot;)
2222                 def PS_3D_SRC = file(&quot;src/main/native-prism-d3d/hlsl/Mtl1PS.hlsl&quot;)
2223                 def VS_3D_SRC = file(&quot;src/main/native-prism-d3d/hlsl/Mtl1VS.hlsl&quot;)
2224                 def PASSTHROUGH_VS_SRC = file(&quot;src/main/native-prism-d3d/PassThroughVS.hlsl&quot;)
2225                 def jobs = [
2226                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;vs_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/PassThroughVS.h&quot;, &quot;/E&quot;, &quot;passThrough&quot;, &quot;$PASSTHROUGH_VS_SRC&quot;],
2227                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS.h&quot;, &quot;/DSpec=0&quot;, &quot;/DSType=0&quot;, &quot;$PS_3D_SRC&quot;],
2228                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_i.h&quot;, &quot;/DSpec=0&quot;, &quot;/DSType=0&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2229                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1n.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=0&quot;, &quot;$PS_3D_SRC&quot;],
2230                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2n.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=0&quot;, &quot;$PS_3D_SRC&quot;],
2231                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3n.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=0&quot;, &quot;$PS_3D_SRC&quot;],
2232                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1t.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=1&quot;, &quot;$PS_3D_SRC&quot;],
2233                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2t.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=1&quot;, &quot;$PS_3D_SRC&quot;],
2234                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3t.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=1&quot;, &quot;$PS_3D_SRC&quot;],
2235                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1c.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=2&quot;, &quot;$PS_3D_SRC&quot;],
2236                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2c.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=2&quot;, &quot;$PS_3D_SRC&quot;],
2237                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3c.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=2&quot;, &quot;$PS_3D_SRC&quot;],
2238                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1m.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=3&quot;, &quot;$PS_3D_SRC&quot;],
2239                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2m.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=3&quot;, &quot;$PS_3D_SRC&quot;],
2240                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3m.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=3&quot;, &quot;$PS_3D_SRC&quot;],
2241                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1n.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2242                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2n.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2243                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3n.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2244                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1t.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2245                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2t.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2246                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3t.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2247                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1c.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2248                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2c.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2249                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3c.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2250                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1m.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2251                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2m.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2252                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3m.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2253                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1ni.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=0&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2254                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2ni.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=0&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2255                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3ni.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=0&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2256                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1ti.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2257                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2ti.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2258                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3ti.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2259                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1ci.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=2&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2260                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2ci.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=2&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2261                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3ci.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=2&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2262                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1mi.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=3&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2263                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2mi.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=3&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2264                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3mi.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=3&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2265                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1ni.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2266                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2ni.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2267                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3ni.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2268                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1ti.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2269                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2ti.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2270                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3ti.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2271                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1ci.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2272                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2ci.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2273                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3ci.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2274                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1mi.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2275                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2mi.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2276                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3mi.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2277                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;vs_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1VS_Obj.h&quot;, &quot;/DVertexType=ObjVertex&quot;, &quot;$VS_3D_SRC&quot;]
2278                 ]
2279                 final ExecutorService executor = Executors.newFixedThreadPool(Integer.parseInt(project.NUM_COMPILE_THREADS.toString()));
2280                 final CountDownLatch latch = new CountDownLatch(jobs.size());
2281                 List futures = new ArrayList&lt;Future&gt;();
2282                 jobs.each { cmd -&gt;
2283                     futures.add(executor.submit(new Runnable() {
2284                         @Override public void run() {
2285                             try {
2286                                 exec {
2287                                     commandLine cmd
2288                                 }
2289                             } finally {
2290                                 latch.countDown();
2291                             }
2292                         }
2293                     }));
2294                 }
2295                 latch.await();
2296                 // Looking for whether an exception occurred while executing any of the futures.
2297                 // By calling &quot;get()&quot; on each future an exception will be thrown if one had occurred
2298                 // on the background thread.
2299                 futures.each {it.get();}
2300             }
2301         }
2302 
2303         ccWinPrismD3D.dependsOn generateD3DHeaders
2304     }
2305 
2306     // The Decora and Prism JSL files have to be generated in a very specific set of steps.
2307     //      1) Compile the *Compile.java classes. These live in src/main/jsl-* and will be
2308     //         output to $buildDir/classes/jsl-compilers/* (where * == decora or prism).
2309     //      2) Generate source files from the JSL files contained in src/main/jsl-*. These
2310     //         will be output to $buildDir/gensrc/jsl-*
2311     //      3) Compile the JSL Java sources in $buildDir/gensrc/jsl-* and put the output
2312     //         into classes/jsl-*
2313     //      4) Compile the native JSL sources in $buildDir/gensrc/jsl-* and put the obj
2314     //         files into native/jsl-* and the resulting library into libs/jsl-*.dll|so|dylib
2315     //      5) Modify the jar step to include classes/jsl-*
2316     // The native library must be copied over during SDK creation time in the &quot;sdk&quot; task. In
2317     // addition to these steps, the clean task is created. Note that I didn&#39;t bother to create
2318     // a new task for each of the decora files, preferring instead just to create a rule?? Also
2319     // need &quot;clean&quot; tasks for each compile task.
2320 
2321     def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
2322     modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.base/build/classes/java/main&quot;
2323     addJSL(project, &quot;Decora&quot;, &quot;com/sun/scenario/effect/impl/hw/d3d/hlsl&quot;, decoraAddExports) { sourceDir, destinationDir -&gt;
2324         [[fileName: &quot;ColorAdjust&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2325          [fileName: &quot;Brightpass&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2326          [fileName: &quot;SepiaTone&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2327          [fileName: &quot;PerspectiveTransform&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2328          [fileName: &quot;DisplacementMap&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2329          [fileName: &quot;InvertMask&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2330          [fileName: &quot;Blend&quot;, generator: &quot;CompileBlend&quot;, outputs: &quot;-all&quot;],
2331          [fileName: &quot;PhongLighting&quot;, generator: &quot;CompilePhong&quot;, outputs: &quot;-all&quot;],
2332          [fileName: &quot;LinearConvolve&quot;, generator: &quot;CompileLinearConvolve&quot;, outputs: &quot;-hw&quot;],
2333          [fileName: &quot;LinearConvolveShadow&quot;, generator: &quot;CompileLinearConvolve&quot;, outputs: &quot;-hw&quot;]].each { settings -&gt;
2334             javaexec {
2335                 executable = JAVA
2336                 workingDir = project.projectDir
2337                 main = settings.generator
2338                 classpath = configurations.compile + configurations.antlr
2339                 classpath += files(project.sourceSets.jslc.java.outputDir)
2340 
2341                 classpath += files(&quot;${project.projectDir}/src/jslc/resources&quot;)
2342 
2343                 classpath += files(&quot;$buildDir/classes/jsl-compilers/decora&quot;)
2344                 jvmArgs += &quot;--module-path=$modulePath&quot;
2345                 jvmArgs += &quot;--add-modules=javafx.graphics&quot;
2346                 jvmArgs += decoraAddExports
2347                 args += [&quot;-i&quot;, sourceDir, &quot;-o&quot;, destinationDir, &quot;-t&quot;, &quot;-pkg&quot;, &quot;com/sun/scenario/effect&quot;, &quot;$settings.outputs&quot;, &quot;$settings.fileName&quot;]
2348             }
2349         }
2350     }
2351 
2352 
2353     task nativeDecora(dependsOn: compileDecoraHLSLShaders, group: &quot;Build&quot;) {
2354         description = &quot;Generates JNI headers, compiles, and builds native dynamic library for Decora&quot;
2355     }
2356     task cleanNativeDecora(type: Delete, group: &quot;Build&quot;) {
2357         description = &quot;Clean native objects for Decora&quot;
2358     }
2359 
2360     def headerDir = file(&quot;$buildDir/gensrc/headers/javafx.graphics&quot;)
2361     def nativeRootDir = project.file(&quot;$project.buildDir/native/jsl-decora&quot;)
2362     def libRootDir = project.file(&quot;$project.buildDir/libs/jsl-decora&quot;)
2363     // For each compile target, create cc and link tasks
2364     compileTargets { t -&gt;
2365         def target = t.name
2366         def upperTarget = t.upper
2367         def capitalTarget = t.capital
2368         def targetProperties = rootProject.ext[upperTarget];
2369         def library = targetProperties.library
2370         def properties = targetProperties.get(&#39;decora&#39;)
2371         def nativeDir = file(&quot;$nativeRootDir/$target&quot;);
2372 
2373         def variants = properties.containsKey(&quot;variants&quot;) ? properties.variants : [&quot;&quot;];
2374         variants.each { variant -&gt;
2375             def variantProperties = variant == &quot;&quot; ? properties : properties.get(variant)
2376             def capitalVariant = variant.capitalize()
2377             def ccOutput = variant == &quot;&quot; ? nativeDir : file(&quot;$nativeDir/$variant&quot;)
2378 
2379             def ccTask = task(&quot;compileDecoraNativeShaders$capitalTarget$capitalVariant&quot;, type: CCTask ) {
2380                 description = &quot;Compiles Decora SSE natives for ${t.name}${capitalVariant != &#39;&#39; ? &#39; for variant &#39; + capitalVariant : &#39;&#39;}&quot;
2381                 matches = &quot;.*\\.cc&quot;
2382                 source file(&quot;$buildDir/gensrc/jsl-decora&quot;)
2383                 source file(project.projectDir.path + &quot;/src/main/native-decora&quot;)
2384                 headers = headerDir
2385                 params.addAll(variantProperties.ccFlags)
2386                 output(ccOutput)
2387                 compiler = variantProperties.compiler
2388                 cleanNativeDecora.delete ccOutput
2389             }
2390 
2391             def linkTask = task(&quot;linkDecoraNativeShaders$capitalTarget$capitalVariant&quot;, type: LinkTask, dependsOn: ccTask) {
2392                 description = &quot;Creates native dynamic library for Decora SSE ${t.name}${capitalVariant != &#39;&#39; ? &#39; for variant &#39; + capitalVariant : &#39;&#39;}&quot;
2393                 objectDir = ccOutput
2394                 linkParams.addAll(variantProperties.linkFlags)
2395                 lib = file(&quot;$libRootDir/$t.name/${library(variantProperties.lib)}&quot;)
2396                 linker = variantProperties.linker
2397                 cleanNativeDecora.delete &quot;$libRootDir/$t.name/&quot;
2398             }
2399 
2400             if (IS_WINDOWS &amp;&amp; target == &quot;win&quot;) {
2401                 def rcTask = project.task(&quot;rcDecoraNativeShaders$capitalTarget$capitalVariant&quot;, type: CompileResourceTask) {
2402                     description = &quot;Compiles native sources for Decora SSE&quot;
2403                     matches = &quot;.*\\.rc&quot;
2404                     compiler = variantProperties.rcCompiler
2405                     source(variantProperties.rcSource)
2406                     if (variantProperties.rcFlags) {
2407                         rcParams.addAll(variantProperties.rcFlags)
2408                     }
2409                     output(ccOutput)
2410                 }
2411                 linkTask.dependsOn rcTask;
2412             }
2413 
2414             nativeDecora.dependsOn(linkTask)
2415         }
2416     }
2417 
2418     // Prism JSL
2419     addJSL(project, &quot;Prism&quot;, &quot;com/sun/prism/d3d/hlsl&quot;, null) { sourceDir, destinationDir -&gt;
2420         def inputFiles = fileTree(dir: sourceDir)
2421         inputFiles.include &quot;**/*.jsl&quot;
2422         inputFiles.each { file -&gt;
2423             javaexec {
2424                 executable = JAVA
2425                 workingDir = project.projectDir
2426                 main = &quot;CompileJSL&quot;
2427                 classpath = configurations.compile + configurations.antlr
2428                 classpath += files(project.sourceSets.jslc.java.outputDir)
2429                 classpath += files(project.sourceSets.jslc.resources)
2430                 classpath += files(&quot;$buildDir/classes/jsl-compilers/prism&quot;,
2431                     project.projectDir.path + &quot;/src/main/jsl-prism&quot;) // for the .stg
2432                 args = [&quot;-i&quot;, sourceDir, &quot;-o&quot;, destinationDir, &quot;-t&quot;, &quot;-pkg&quot;, &quot;com/sun/prism&quot;, &quot;-d3d&quot;, &quot;-es2&quot;, &quot;-name&quot;, &quot;$file&quot;]
2433             }
2434         }
2435     }
2436 
2437     nativePrism.dependsOn compilePrismHLSLShaders;
2438 
2439     project.nativeAllTask.dependsOn nativeDecora
2440     project.cleanNativeAllTask.dependsOn cleanNativeDecora
2441     assemble.dependsOn nativeDecora
2442     processResources.dependsOn processDecoraShaders, processPrismShaders
2443 
2444     test {
2445         def cssDir = file(&quot;$buildDir/classes/java/main/${moduleName}/javafx&quot;)
2446         jvmArgs &quot;-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit&quot;,
2447             &quot;-DCSS_META_DATA_TEST_DIR=$cssDir&quot;
2448         enableAssertions = true
2449         testLogging.exceptionFormat = &quot;full&quot;
2450         scanForTestClasses = false
2451         include &quot;**/*Test.*&quot;
2452         if (BUILD_CLOSED &amp;&amp; DO_JCOV) {
2453             addJCov(project, test)
2454         }
2455     }
2456 
2457     // To enable the IDEs to all be happy (no red squiggles) we need to have the libraries
2458     // available in some known location. Maybe in the future the Gradle plugins to each
2459     // of the IDEs will be good enough that we won&#39;t need this hack anymore.
2460     classes {
2461         doLast {
2462             // Copy all of the download libraries to the libs directory for the sake of the IDEs
2463             File libsDir = rootProject.file(&quot;build/libs&quot;);
2464 
2465             // In some IDEs (Eclipse for example), touching these libraries
2466             // cauese a full build within the IDE. When gradle is used
2467             // outside of the IDE, for example to build the native code,
2468             // a full rebuild is caused within the IDE. The fix is to check
2469             // for the presence of the target files in the lib directory
2470             // and not copy the files if all are present.
2471 
2472             libsDir.mkdirs();
2473 
2474             def allLibsPresent = true
2475             def libNames = [ &quot;antlr4-4.7.2-complete.jar&quot; ]
2476             libNames.each { name -&gt;
2477                 File f = new File(libsDir, name)
2478                 if (!f.exists()) allLibsPresent = false
2479             }
2480             if (allLibsPresent) return;
2481 
2482             for (File f : [configurations.compile.files, configurations.antlr.files].flatten()) {
2483                 copy {
2484                     into libsDir
2485                     from f.getParentFile()
2486                     include &quot;**/antlr4-4.7.2-complete.jar&quot;
2487                     includeEmptyDirs = false
2488                 }
2489             }
2490         }
2491     }
2492 
2493     addMavenPublication(project, [ &#39;base&#39; ])
2494 
2495     addValidateSourceSets(project, sourceSets)
2496 }
2497 
2498 project(&quot;:controls&quot;) {
2499     project.ext.buildModule = true
2500     project.ext.includeSources = true
2501     project.ext.moduleRuntime = true
2502     project.ext.moduleName = &quot;javafx.controls&quot;
2503 
2504     sourceSets {
2505         main
2506         shims {
2507             java {
2508                 compileClasspath += sourceSets.main.output
2509                 runtimeClasspath += sourceSets.main.output
2510             }
2511         }
2512         test {
2513             java {
2514                 compileClasspath += sourceSets.shims.output
2515                 runtimeClasspath += sourceSets.shims.output
2516             }
2517         }
2518     }
2519 
2520     project.ext.moduleSourcePath = defaultModuleSourcePath
2521     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2522 
2523     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;controls&#39; ])
2524 
2525     dependencies {
2526         testCompile project(&quot;:graphics&quot;).sourceSets.test.output
2527         testCompile project(&quot;:base&quot;).sourceSets.test.output
2528         compile project(&#39;:base&#39;)
2529         compile project(&#39;:graphics&#39;)
2530     }
2531 
2532     test {
2533         def cssDir = file(&quot;$buildDir/classes/java/main/${moduleName}/javafx&quot;)
2534         jvmArgs &quot;-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit&quot;,
2535             &quot;-DCSS_META_DATA_TEST_DIR=$cssDir&quot;
2536     }
2537 
2538     def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
2539     modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.graphics/build/classes/java/main&quot;
2540     modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.base/build/classes/java/main&quot;
2541     processResources {
2542       doLast {
2543         def cssFiles = fileTree(dir: &quot;$moduleDir/com/sun/javafx/scene/control/skin&quot;)
2544         cssFiles.include &quot;**/*.css&quot;
2545         cssFiles.each { css -&gt;
2546             logger.info(&quot;converting CSS to BSS ${css}&quot;);
2547 
2548             javaexec {
2549                 executable = JAVA
2550                 workingDir = project.projectDir
2551                 jvmArgs += patchModuleArgs
2552                 jvmArgs += &quot;--module-path=$modulePath&quot;
2553                 jvmArgs += &quot;--add-modules=javafx.graphics&quot;
2554                 main = &quot;com.sun.javafx.css.parser.Css2Bin&quot;
2555                 args css
2556             }
2557         }
2558       }
2559     }
2560 
2561     processShimsResources.dependsOn(project.task(&quot;copyShimBss&quot;, type: Copy) {
2562         from project.moduleDir
2563         into project.moduleShimsDir
2564         include &quot;**/*.bss&quot;
2565     })
2566 
2567     addMavenPublication(project, [ &#39;graphics&#39; ])
2568 
2569     addValidateSourceSets(project, sourceSets)
2570 }
2571 
2572 project(&quot;:swing&quot;) {
2573 
2574     tasks.all {
2575         if (!COMPILE_SWING) it.enabled = false
2576     }
2577 
2578     project.ext.buildModule = COMPILE_SWING
2579     project.ext.includeSources = true
2580     project.ext.moduleRuntime = true
2581     project.ext.moduleName = &quot;javafx.swing&quot;
2582 
2583     sourceSets {
2584         main
2585         shims {
2586             java {
2587                 compileClasspath += sourceSets.main.output
2588                 runtimeClasspath += sourceSets.main.output
2589             }
2590         }
2591         test {
2592             java {
2593                 compileClasspath += sourceSets.shims.output
2594                 runtimeClasspath += sourceSets.shims.output
2595             }
2596         }
2597     }
2598 
2599     project.ext.moduleSourcePath = defaultModuleSourcePath
2600     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2601 
2602     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;swing&#39; ])
2603 
2604     dependencies {
2605         compile project(&quot;:base&quot;)
2606         compile project(&quot;:graphics&quot;)
2607     }
2608 
2609     test {
2610         enabled = IS_FULL_TEST &amp;&amp; IS_AWT_TEST
2611     }
2612 
2613     if (COMPILE_SWING) {
2614         addMavenPublication(project, [ &#39;graphics&#39; ])
2615     }
2616 
2617     addValidateSourceSets(project, sourceSets)
2618 }
2619 
2620 project(&quot;:swt&quot;) {
2621     tasks.all {
2622         if (!COMPILE_SWT) it.enabled = false
2623     }
2624 
2625     // javafx.swt is an automatic module
2626     project.ext.buildModule = false
2627 
2628     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39; ])
2629 
2630     dependencies {
2631         compile name: SWT_FILE_NAME
2632     }
2633 
2634     classes {
2635         doLast {
2636             // Copy all of the download libraries to libs directory for the sake of the IDEs
2637             File libsDir = rootProject.file(&quot;build/libs&quot;);
2638             File swtLib = new File(libsDir, &quot;swt-debug.jar&quot;)
2639             libsDir.mkdirs();
2640 
2641             // Skip copy if file is present.
2642             if (swtLib.exists()) return;
2643 
2644             for (File f : configurations.compile.files) {
2645                 // Have to rename the swt jar because it is some platform specific name but
2646                 // for the sake of the IDEs we need to have a single stable name that works
2647                 // on every platform
2648                 copy {
2649                     into libsDir
2650                     from f.getParentFile()
2651                     include &quot;**/*swt*.jar&quot;
2652                     includeEmptyDirs = false
2653                     rename &quot;.*swt.*jar&quot;, &quot;swt-debug\\.jar&quot;
2654                 }
2655             }
2656         }
2657     }
2658 
2659     compileJava.options.compilerArgs.addAll([
2660             &quot;--add-exports=javafx.graphics/com.sun.glass.ui=ALL-UNNAMED&quot;,
2661             &quot;--add-exports=javafx.graphics/com.sun.javafx.cursor=ALL-UNNAMED&quot;,
2662             &quot;--add-exports=javafx.graphics/com.sun.javafx.embed=ALL-UNNAMED&quot;,
2663             &quot;--add-exports=javafx.graphics/com.sun.javafx.stage=ALL-UNNAMED&quot;,
2664             &quot;--add-exports=javafx.graphics/com.sun.javafx.tk=ALL-UNNAMED&quot;,
2665             ])
2666 
2667     test {
2668         //enabled = IS_FULL_TEST &amp;&amp; IS_SWT_TEST
2669         enabled = false // FIXME: JIGSAW -- support this with modules
2670         logger.info(&quot;JIGSAW Testing disabled for swt&quot;)
2671 
2672         if (IS_MAC) {
2673             enabled = false
2674             logger.info(&quot;SWT tests are disabled on MAC, because Gradle test runner does not handle -XstartOnFirstThread properly (https://issues.gradle.org/browse/GRADLE-3290).&quot;)
2675         }
2676     }
2677 
2678     addValidateSourceSets(project, sourceSets)
2679 }
2680 
2681 project(&quot;:fxml&quot;) {
2682     project.ext.buildModule = true
2683     project.ext.includeSources = true
2684     project.ext.moduleRuntime = true
2685     project.ext.moduleName = &quot;javafx.fxml&quot;
2686 
2687     sourceSets {
2688         main
2689         shims {
2690             java {
2691                 compileClasspath += sourceSets.main.output
2692                 runtimeClasspath += sourceSets.main.output
2693             }
2694         }
2695         test {
2696             java {
2697                 compileClasspath += sourceSets.shims.output
2698                 runtimeClasspath += sourceSets.shims.output
2699             }
2700         }
2701     }
2702 
2703     project.ext.moduleSourcePath = defaultModuleSourcePath
2704     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2705 
2706     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;controls&#39;, &#39;fxml&#39; ])
2707 
2708 
2709     dependencies {
2710         testCompile project(&quot;:graphics&quot;).sourceSets.test.output
2711         testCompile project(&quot;:base&quot;).sourceSets.test.output
2712         compile project(&quot;:base&quot;)
2713         compile project(&quot;:graphics&quot;)
2714     }
2715 
2716     test {
2717         // StubToolkit is not *really* needed here, but because some code inadvertently invokes performance
2718         // tracker and this attempts to fire up the toolkit and this looks for native libraries and fails,
2719         // we have to use the stub toolkit for now.
2720         jvmArgs &quot;-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit&quot;
2721         // FIXME: change this to also allow JDK 9 boot jdk
2722         classpath += files(&quot;$JDK_HOME/jre/lib/ext/nashorn.jar&quot;)
2723     }
2724 
2725     addMavenPublication(project, [ &#39;controls&#39; ])
2726 
2727     addValidateSourceSets(project, sourceSets)
2728 }
2729 
2730 project(&quot;:media&quot;) {
2731     configurations {
2732         media
2733     }
2734 
2735     project.ext.buildModule = true
2736     project.ext.includeSources = true
2737     project.ext.moduleRuntime = true
2738     project.ext.moduleName = &quot;javafx.media&quot;
2739 
2740     sourceSets {
2741         main
2742         //shims // no test shims needed
2743         test
2744         tools {
2745             java.srcDir &quot;src/tools/java&quot;
2746         }
2747     }
2748 
2749     project.ext.moduleSourcePath = defaultModuleSourcePath
2750     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2751 
2752     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;media&#39; ])
2753 
2754     dependencies {
2755         if (IS_BUILD_LIBAV_STUBS) {
2756             media name: &quot;libav-9.14&quot;, ext: &quot;tar.gz&quot;
2757             media name: &quot;libav-11.4&quot;, ext: &quot;tar.gz&quot;
2758             media name: &quot;libav-12.1&quot;, ext: &quot;tar.gz&quot;
2759             media name: &quot;ffmpeg-3.3.3&quot;, ext: &quot;tar.gz&quot;
2760             media name: &quot;ffmpeg-4.0.2&quot;, ext: &quot;tar.gz&quot;
2761         }
2762         compile project(&quot;:base&quot;)
2763         compile project(&quot;:graphics&quot;)
2764     }
2765 
2766     compileJava.dependsOn updateCacheIfNeeded
2767 
2768     compileJava {
2769         // generate the native headers during compile
2770         options.compilerArgs.addAll([
2771             &#39;-h&#39;, &quot;${project.buildDir}/gensrc/headers&quot;
2772             ])
2773     }
2774 
2775     compileToolsJava {
2776         enabled = IS_COMPILE_MEDIA
2777         def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
2778         options.compilerArgs.addAll([
2779             &quot;--module-path=$modulePath&quot;,
2780             &quot;--add-modules=javafx.media&quot;,
2781             &#39;--add-exports&#39;, &#39;javafx.media/com.sun.media.jfxmedia=ALL-UNNAMED&#39;,
2782             ])
2783     }
2784 
2785     project.ext.makeJobsFlag = IS_WINDOWS &amp;&amp; IS_DEBUG_NATIVE ? &quot;-j1&quot; : &quot;-j5&quot;;
2786     project.ext.buildType = IS_DEBUG_NATIVE ? &quot;Debug&quot; : &quot;Release&quot;;
2787 
2788     def nativeSrcDir = file(&quot;${projectDir}/src/main/native&quot;)
2789     def generatedHeadersDir = file(&quot;${buildDir}/gensrc/headers/${project.moduleName}&quot;)
2790 
2791     task generateMediaErrorHeader(dependsOn: [compileJava, compileToolsJava]) {
2792         enabled = IS_COMPILE_MEDIA
2793         def headerpath = file(&quot;$generatedHeadersDir/jfxmedia_errors.h&quot;);
2794         doLast {
2795             def classpath = files(sourceSets.tools.output);
2796             def sourcepath = sourceSets.main.java.srcDirs;
2797             def srcRoot = (sourcepath.toArray())[0];
2798 
2799             mkdir generatedHeadersDir;
2800 
2801             def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
2802             modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.graphics/build/classes/java/main&quot;
2803             modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.base/build/classes/java/main&quot;
2804 
2805             exec {
2806                 commandLine(&quot;$JAVA&quot;);
2807                 args += patchModuleArgs
2808                 args += [ &quot;--module-path=$modulePath&quot; ]
2809                 args += [ &quot;--add-modules=javafx.media&quot; ]
2810                 args +=  [ &#39;--add-exports=javafx.media/com.sun.media.jfxmedia=ALL-UNNAMED&#39; ]
2811                 args +=  [ &#39;-classpath&#39;, &quot;${classpath.asPath}&quot; ]
2812                 args += [ &quot;headergen.HeaderGen&quot;, &quot;$headerpath&quot;, &quot;$srcRoot&quot; ]
2813             }
2814         }
2815         outputs.file(project.file(&quot;$headerpath&quot;))
2816     }
2817 
2818     task buildNativeTargets {
2819         enabled = IS_COMPILE_MEDIA
2820     }
2821 
2822     compileTargets { t-&gt;
2823         def targetProperties = project.rootProject.ext[t.upper]
2824         def nativeOutputDir = file(&quot;${buildDir}/native/${t.name}&quot;)
2825         def projectDir = t.name.startsWith(&quot;arm&quot;) ? &quot;linux&quot; : t.name
2826         def mediaProperties = targetProperties.media
2827         // Makefile for OSX needs to know if we&#39;re building for parfait
2828         def compileParfait = IS_COMPILE_PARFAIT ? &quot;true&quot; : &quot;false&quot;
2829 
2830         def buildNative = task(&quot;build${t.capital}Native&quot;, dependsOn: [generateMediaErrorHeader]) {
2831             enabled = targetProperties.compileMediaNative
2832             if (!targetProperties.compileMediaNative) {
2833                 println(&quot;Not compiling native Media for ${t.name} per configuration request&quot;);
2834             }
2835 
2836             doLast {
2837                 exec {
2838                     commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/jfxmedia/projects/${projectDir}&quot;)
2839                     args(&quot;JAVA_HOME=${JDK_HOME}&quot;, &quot;GENERATED_HEADERS_DIR=${generatedHeadersDir}&quot;,
2840                          &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=jfxmedia&quot;,
2841                          &quot;COMPILE_PARFAIT=${compileParfait}&quot;,
2842                          IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;,
2843                         &quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
2844 
2845                     if (t.name == &quot;win&quot;) {
2846                         environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
2847                         args( &quot;RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.jfxmediaRcFile}&quot;)
2848                     } else {
2849                         if (t.name.startsWith(&quot;arm&quot;)) {
2850                             args(&quot;EXTRA_CFLAGS=${mediaProperties.extra_cflags}&quot;, &quot;EXTRA_LDFLAGS=${mediaProperties.extra_ldflags}&quot;)
2851                         } else {
2852                             args(&quot;HOST_COMPILE=1&quot;)
2853                         }
2854                     }
2855                 }
2856             }
2857         }
2858 
2859         // check for the property disable${name} = true
2860         def boolean disabled = targetProperties.containsKey(&#39;disableMedia&#39;) ? targetProperties.get(&#39;disableMedia&#39;) : false
2861         if (!disabled) {
2862             // Building GStreamer
2863             def buildGStreamer = task(&quot;build${t.capital}GStreamer&quot;) {
2864                 enabled = IS_COMPILE_MEDIA
2865                 doLast {
2866                     exec {
2867                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/gstreamer-lite&quot;)
2868                         args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=gstreamer-lite&quot;,
2869                              IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;, &quot;CC=${mediaProperties.compiler}&quot;,
2870                              &quot;AR=${mediaProperties.ar}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
2871 
2872                         if (t.name == &quot;win&quot;) {
2873                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
2874                             args(&quot;RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.gstreamerRcFile}&quot;)
2875                         }
2876                     }
2877                 }
2878             }
2879 
2880             def buildPlugins = task(&quot;build${t.capital}Plugins&quot;, dependsOn: buildGStreamer) {
2881                 enabled = IS_COMPILE_MEDIA
2882 
2883                 doLast {
2884                     exec {
2885                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/fxplugins&quot;)
2886                         args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=fxplugins&quot;,
2887                              IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;,
2888                              &quot;CC=${mediaProperties.compiler}&quot;, &quot;AR=${mediaProperties.ar}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
2889 
2890                         if (t.name == &quot;win&quot;) {
2891                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
2892                             args(&quot;RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.fxpluginsRcFile}&quot;)
2893                         }
2894                     }
2895                 }
2896             }
2897 
2898             buildNative.dependsOn buildPlugins
2899 
2900             if (t.name == &quot;linux&quot;) {
2901                 // Pre-defined command line arguments
2902                 def cfgCMDArgs = [&quot;sh&quot;, &quot;configure&quot;]
2903                 def commonCfgArgs = [&quot;--enable-shared&quot;, &quot;--disable-debug&quot;, &quot;--disable-static&quot;, &quot;--disable-yasm&quot;, &quot;--disable-doc&quot;, &quot;--disable-programs&quot;, &quot;--disable-everything&quot;]
2904                 def codecsCfgArgs = [&quot;--enable-decoder=aac,mp3,mp3float,h264&quot;, &quot;--enable-parser=aac,h264&quot;, &quot;--enable-demuxer=aac,h264,mpegts,mpegtsraw&quot;]
2905 
2906                 def copyLibAVStubs = {String fromDir, String toDir -&gt;
2907                     FileCollection config = files(&quot;config.h&quot;)
2908                     FileCollection libavcodec = files(&quot;avcodec.h&quot;, &quot;avfft.h&quot;, &quot;dxva2.h&quot;, &quot;vaapi.h&quot;, &quot;vda.h&quot;,
2909                                                       &quot;vdpau.h&quot;, &quot;version.h&quot;, &quot;xvmc.h&quot;, &quot;old_codec_ids.h&quot;)
2910                     FileCollection libavdevice = files(&quot;avdevice.h&quot;, &quot;version.h&quot;)
2911                     FileCollection libavfilter = files(&quot;avfiltergraph.h&quot;, &quot;avfilter.h&quot;, &quot;buffersink.h&quot;, &quot;buffersrc.h&quot;, &quot;version.h&quot;);
2912                     FileCollection libavformat = files(&quot;avformat.h&quot;, &quot;avio.h&quot;, &quot;version.h&quot;)
2913                     FileCollection libavresample = files(&quot;avresample.h&quot;, &quot;version.h&quot;)
2914                     FileCollection libavutil = files(&quot;adler32.h&quot;, &quot;blowfish.h&quot;, &quot;error.h&quot;, &quot;log.h&quot;, &quot;pixfmt.h&quot;,
2915                                                      &quot;aes.h&quot;, &quot;bswap.h&quot;, &quot;eval.h&quot;, &quot;lzo.h&quot;, &quot;random_seed.h&quot;,
2916                                                      &quot;attributes.h&quot;, &quot;buffer.h&quot;, &quot;fifo.h&quot;, &quot;macros.h&quot;, &quot;rational.h&quot;,
2917                                                      &quot;audio_fifo.h&quot;, &quot;channel_layout.h&quot;, &quot;file.h&quot;, &quot;mathematics.h&quot;, &quot;samplefmt.h&quot;,
2918                                                      &quot;avassert.h&quot;, &quot;common.h&quot;, &quot;frame.h&quot;, &quot;md5.h&quot;, &quot;sha.h&quot;,
2919                                                      &quot;avconfig.h&quot;, &quot;imgutils.h&quot;, &quot;mem.h&quot;, &quot;time.h&quot;, &quot;avstring.h&quot;,
2920                                                      &quot;cpu_internal.h&quot;, &quot;intfloat.h&quot;, &quot;opt.h&quot;, &quot;version.h&quot;, &quot;avutil.h&quot;,
2921                                                      &quot;crc.h&quot;, &quot;intreadwrite.h&quot;, &quot;parseutils.h&quot;, &quot;xtea.h&quot;, &quot;base64.h&quot;,
2922                                                      &quot;dict.h&quot;, &quot;lfg.h&quot;, &quot;pixdesc.h&quot;, &quot;intfloat_readwrite.h&quot;, &quot;old_pix_fmts.h&quot;, &quot;audioconvert.h&quot;,
2923                                                      &quot;cpu.h&quot;, &quot;hwcontext.h&quot;)
2924                     FileCollection libavutil_x86 = files(&quot;cpu.h&quot;) // Use cpu.h from x86 instead of libavutil root if exist
2925                     FileCollection libswscale = files(&quot;swscale.h&quot;, &quot;version.h&quot;)
2926 
2927                     def copyLibAVFiles = {FileCollection files, String fDir, String tDir -&gt;
2928                         File dir = file(tDir)
2929                         dir.mkdirs()
2930 
2931                         files.each { File file -&gt;
2932                             copy {
2933                                 from fDir
2934                                 into tDir
2935                                 include file.name
2936                             }
2937                         }
2938                     }
2939 
2940                     copyLibAVFiles(config, fromDir, &quot;${toDir}/include&quot;)
2941                     copyLibAVFiles(libavcodec, &quot;${fromDir}/libavcodec&quot;, &quot;${toDir}/include/libavcodec&quot;)
2942                     copyLibAVFiles(libavdevice, &quot;${fromDir}/libavdevice&quot;, &quot;${toDir}/include/libavdevice&quot;)
2943                     copyLibAVFiles(libavfilter, &quot;${fromDir}/libavfilter&quot;, &quot;${toDir}/include/libavfilter&quot;)
2944                     copyLibAVFiles(libavformat, &quot;${fromDir}/libavformat&quot;, &quot;${toDir}/include/libavformat&quot;)
2945                     copyLibAVFiles(libavresample, &quot;${fromDir}/libavresample&quot;, &quot;${toDir}/include/libavresample&quot;)
2946                     copyLibAVFiles(libavutil, &quot;${fromDir}/libavutil&quot;, &quot;${toDir}/include/libavutil&quot;)
2947                     copyLibAVFiles(libavutil_x86, &quot;${fromDir}/libavutil/x86&quot;, &quot;${toDir}/include/libavutil&quot;)
2948                     copyLibAVFiles(libswscale, &quot;${fromDir}/libswscale&quot;, &quot;${toDir}/include/libswscale&quot;)
2949 
2950                     // Copy libs
2951                     FileTree libs = fileTree(dir: &quot;${fromDir}&quot;, include: &quot;**/*.so*&quot;)
2952                     libs.each {File file -&gt;
2953                         copy {
2954                             from file
2955                             into &quot;${toDir}/lib&quot;
2956                         }
2957                     }
2958                 }
2959 
2960                 def buildLibAVStubs = task(&quot;buildLibAVStubs&quot;, dependsOn: []) {
2961                     enabled = IS_BUILD_LIBAV_STUBS
2962 
2963                     doLast {
2964                         project.ext.libav = [:]
2965                         project.ext.libav.basedir = &quot;${buildDir}/native/linux/libav&quot;
2966                         project.ext.libav.versions = [ &quot;9.14&quot;, &quot;11.4&quot;, &quot;12.1&quot; ]
2967                         project.ext.libav.versionmap = [ &quot;9.14&quot; : &quot;54&quot;, &quot;11.4&quot; : &quot;56&quot;, &quot;12.1&quot; : &quot;57&quot; ]
2968 
2969                         libav.versions.each { version -&gt;
2970                             def libavDir = &quot;${libav.basedir}/libav-${version}&quot;
2971                             for (File f : configurations.media.files) {
2972                                 if (f.name.startsWith(&quot;libav-${version}&quot;)) {
2973                                     File dir = file(libavDir)
2974                                     dir.mkdirs()
2975                                     def libavTar = &quot;${libav.basedir}/libav-${version}.tar&quot;
2976                                     ant.gunzip(src: f, dest: libavTar)
2977                                     ant.untar(src: libavTar, dest: libav.basedir)
2978                                 }
2979                             }
2980                         }
2981 
2982                         libav.versions.each { version -&gt;
2983                             def libavDir = &quot;${libav.basedir}/libav-${version}&quot;
2984                             File dir = file(libavDir)
2985                             if (dir.exists()) {
2986                                 def configFile = &quot;${libav.basedir}/libav-${version}/config.h&quot;
2987                                 File cfgFile = file(configFile)
2988                                 if (!cfgFile.exists()) {
2989                                     // Add execute permissions to version.sh, otherwise build fails
2990                                     exec {
2991                                         workingDir(&quot;$libavDir&quot;)
2992                                         commandLine(&quot;chmod&quot;, &quot;+x&quot;, &quot;version.sh&quot;)
2993                                     }
2994                                     exec {
2995                                         workingDir(&quot;$libavDir&quot;)
2996                                         if (IS_BUILD_WORKING_LIBAV) {
2997                                             commandLine(cfgCMDArgs + commonCfgArgs + codecsCfgArgs)
2998                                         } else {
2999                                             commandLine(cfgCMDArgs + commonCfgArgs)
3000                                         }
3001                                     }
3002                                 }
3003                                 exec {
3004                                     workingDir(&quot;$libavDir&quot;)
3005                                     commandLine(&quot;make&quot;)
3006                                 }
3007                             }
3008                         }
3009 
3010                         libav.versions.each { version -&gt;
3011                             def fromDir = &quot;${libav.basedir}/libav-${version}&quot;
3012                             def majorVersion = libav.versionmap[version]
3013                             def toDir = &quot;${libav.basedir}/libav-${majorVersion}&quot;
3014                             copyLibAVStubs(fromDir, toDir)
3015                         }
3016                     }
3017                 }
3018 
3019                 def buildLibAVFFmpegStubs = task(&quot;buildLibAVFFmpegStubs&quot;, dependsOn: []) {
3020                     enabled = IS_BUILD_LIBAV_STUBS
3021 
3022                     def extraCfgArgs = [&quot;--build-suffix=-ffmpeg&quot;]
3023 
3024                     doLast {
3025                         project.ext.libav = [:]
3026                         project.ext.libav.basedir = &quot;${buildDir}/native/linux/libavffmpeg&quot;
3027                         project.ext.libav.versions = [ &quot;11.4&quot; ]
3028                         project.ext.libav.versionmap = [ &quot;11.4&quot; : &quot;56&quot; ]
3029 
3030                         libav.versions.each { version -&gt;
3031                             def libavDir = &quot;${libav.basedir}/libav-${version}&quot;
3032                             for (File f : configurations.media.files) {
3033                                 if (f.name.startsWith(&quot;libav-${version}&quot;)) {
3034                                     File dir = file(libavDir)
3035                                     dir.mkdirs()
3036                                     def libavTar = &quot;${libav.basedir}/libav-${version}.tar&quot;
3037                                     ant.gunzip(src: f, dest: libavTar)
3038                                     ant.untar(src: libavTar, dest: libav.basedir)
3039                                 }
3040                             }
3041                         }
3042 
3043                         libav.versions.each { version -&gt;
3044                             def libavDir = &quot;${libav.basedir}/libav-${version}&quot;
3045                             File dir = file(libavDir)
3046                             if (dir.exists()) {
3047                                 def configFile = &quot;${libav.basedir}/libav-${version}/config.h&quot;
3048                                 File cfgFile = file(configFile)
3049                                 if (!cfgFile.exists()) {
3050                                     // Patch *.v files, so we have *_FFMPEG_$MAJOR instead of *_$MAJOR, otherwise library will not be loaded
3051                                     FileTree vfiles = fileTree(dir: &quot;${libavDir}&quot;, include: &quot;**/*.v&quot;)
3052                                     vfiles.each {File file -&gt;
3053                                         String data = file.getText(&quot;UTF-8&quot;)
3054                                         data = data.replace(&quot;_\$MAJOR&quot;, &quot;_FFMPEG_\$MAJOR&quot;)
3055                                         file.write(data, &quot;UTF-8&quot;)
3056                                     }
3057                                     // Add execute permissions to version.sh, otherwise build fails
3058                                     exec {
3059                                         workingDir(&quot;$libavDir&quot;)
3060                                         commandLine(&quot;chmod&quot;, &quot;+x&quot;, &quot;version.sh&quot;)
3061                                     }
3062                                     exec {
3063                                         workingDir(&quot;$libavDir&quot;)
3064                                         if (IS_BUILD_WORKING_LIBAV) {
3065                                             commandLine(cfgCMDArgs + commonCfgArgs + codecsCfgArgs + extraCfgArgs)
3066                                         } else {
3067                                             commandLine(cfgCMDArgs + commonCfgArgs + extraCfgArgs)
3068                                         }
3069                                     }
3070                                 }
3071                                 exec {
3072                                     workingDir(&quot;$libavDir&quot;)
3073                                     commandLine(&quot;make&quot;)
3074                                 }
3075                             }
3076                         }
3077 
3078                         libav.versions.each { version -&gt;
3079                             def fromDir = &quot;${libav.basedir}/libav-${version}&quot;
3080                             def majorVersion = libav.versionmap[version]
3081                             def toDir = &quot;${libav.basedir}/libav-${majorVersion}&quot;
3082                             copyLibAVStubs(fromDir, toDir)
3083 
3084                             // Special case to copy *-ffmpeg.so to *.so
3085                             FileTree libs = fileTree(dir: &quot;${fromDir}&quot;, include: &quot;**/*-ffmpeg.so&quot;)
3086                             libs.each {File file -&gt;
3087                                 copy {
3088                                     from file
3089                                     into &quot;${toDir}/lib&quot;
3090                                     rename { String fileName -&gt;
3091                                         fileName.replace(&quot;-ffmpeg&quot;, &quot;&quot;)
3092                                     }
3093                                 }
3094                             }
3095                         }
3096                     }
3097                 }
3098 
3099                 def buildFFmpegStubs = task(&quot;buildFFmpegStubs&quot;, dependsOn: []) {
3100                     enabled = IS_BUILD_LIBAV_STUBS
3101 
3102                     doLast {
3103                         project.ext.libav = [:]
3104                         project.ext.libav.basedir = &quot;${buildDir}/native/linux/ffmpeg&quot;
3105                         project.ext.libav.versions = [ &quot;3.3.3&quot;, &quot;4.0.2&quot; ]
3106                         project.ext.libav.versionmap = [ &quot;3.3.3&quot; : &quot;57&quot;, &quot;4.0.2&quot; : &quot;58&quot; ]
3107 
3108                         libav.versions.each { version -&gt;
3109                             def libavDir = &quot;${libav.basedir}/ffmpeg-${version}&quot;
3110                             for (File f : configurations.media.files) {
3111                                 if (f.name.startsWith(&quot;ffmpeg-${version}&quot;)) {
3112                                     File dir = file(libavDir)
3113                                     dir.mkdirs()
3114                                     def libavTar = &quot;${libav.basedir}/ffmpeg-${version}.tar&quot;
3115                                     ant.gunzip(src: f, dest: libavTar)
3116                                     ant.untar(src: libavTar, dest: libav.basedir)
3117                                 }
3118                             }
3119                         }
3120 
3121                         libav.versions.each { version -&gt;
3122                             def libavDir = &quot;${libav.basedir}/ffmpeg-${version}&quot;
3123                             File dir = file(libavDir)
3124                             if (dir.exists()) {
3125                                 def configFile = &quot;${libavDir}/config.h&quot;
3126                                 File cfgFile = file(configFile)
3127                                 if (!cfgFile.exists()) {
3128                                     // Add execute permissions to version.sh, otherwise build fails
3129                                     def versionFile = &quot;${libavDir}/version.sh&quot;
3130                                     File verFile = file(versionFile)
3131                                     if (verFile.exists()) {
3132                                         exec {
3133                                             workingDir(&quot;$libavDir&quot;)
3134                                             commandLine(&quot;chmod&quot;, &quot;+x&quot;, &quot;version.sh&quot;)
3135                                         }
3136                                     } else {
3137                                         versionFile = &quot;${libavDir}/ffbuild/version.sh&quot;
3138                                         verFile = file(versionFile)
3139                                         if (verFile.exists()) {
3140                                             exec {
3141                                                 workingDir(&quot;${libavDir}/ffbuild&quot;)
3142                                                 commandLine(&quot;chmod&quot;)
3143                                                 args += &quot;+x&quot;
3144                                                 args += [&quot;version.sh&quot;, &quot;libversion.sh&quot;, &quot;pkgconfig_generate.sh&quot;]
3145                                             }
3146                                         }
3147                                     }
3148                                     exec {
3149                                         workingDir(&quot;$libavDir&quot;)
3150                                         if (IS_BUILD_WORKING_LIBAV) {
3151                                             commandLine(cfgCMDArgs + commonCfgArgs + codecsCfgArgs)
3152                                         } else {
3153                                             commandLine(cfgCMDArgs + commonCfgArgs)
3154                                         }
3155                                     }
3156                                 }
3157                                 exec {
3158                                     workingDir(&quot;$libavDir&quot;)
3159                                     commandLine(&quot;make&quot;)
3160                                 }
3161                             }
3162                         }
3163 
3164                         libav.versions.each { version -&gt;
3165                             def fromDir = &quot;${libav.basedir}/ffmpeg-${version}&quot;
3166                             def majorVersion = libav.versionmap[version]
3167                             def toDir = &quot;${libav.basedir}/ffmpeg-${majorVersion}&quot;
3168                             copyLibAVStubs(fromDir, toDir)
3169                         }
3170                     }
3171                 }
3172 
3173                 def buildAVPlugin = task( &quot;buildAVPlugin&quot;, dependsOn: [buildPlugins, buildLibAVStubs, buildLibAVFFmpegStubs, buildFFmpegStubs]) {
3174                     enabled = IS_COMPILE_MEDIA
3175 
3176                     doLast {
3177                         if (IS_BUILD_LIBAV_STUBS) {
3178                             project.ext.libav = [:]
3179                             project.ext.libav.basedir = &quot;${buildDir}/native/linux/libav/libav&quot;
3180                             project.ext.libav.versions = [ &quot;53&quot;, &quot;54&quot;, &quot;55&quot;, &quot;56&quot;, &quot;57&quot; ]
3181                             project.ext.libav.libavffmpeg = [:]
3182                             project.ext.libav.libavffmpeg.basedir = &quot;${buildDir}/native/linux/libavffmpeg/libav&quot;
3183                             project.ext.libav.libavffmpeg.versions = [ &quot;56&quot; ]
3184                             project.ext.libav.ffmpeg = [:]
3185                             project.ext.libav.ffmpeg.basedir = &quot;${buildDir}/native/linux/ffmpeg/ffmpeg&quot;
3186                             project.ext.libav.ffmpeg.versions = [ &quot;57&quot;, &quot;58&quot; ]
3187 
3188                             project.ext.libav.versions.each { version -&gt;
3189                                 def libavDir = &quot;${project.ext.libav.basedir}-${version}&quot;
3190                                 File dir = file(libavDir)
3191                                 if (dir.exists()) {
3192                                     exec {
3193                                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/linux/avplugin&quot;)
3194                                         args(&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;,
3195                                              &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;,
3196                                              &quot;BASE_NAME=avplugin&quot;, &quot;VERSION=${version}&quot;, &quot;LIBAV_DIR=${libavDir}&quot;,
3197                                              &quot;SUFFIX=&quot;, IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;)
3198                                     }
3199                                 }
3200                             }
3201 
3202                             project.ext.libav.libavffmpeg.versions.each { version -&gt;
3203                                 def libavDir = &quot;${project.ext.libav.libavffmpeg.basedir}-${version}&quot;
3204                                 File dir = file(libavDir)
3205                                 if (dir.exists()) {
3206                                     exec {
3207                                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/linux/avplugin&quot;)
3208                                         args(&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;,
3209                                              &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;,
3210                                              &quot;BASE_NAME=avplugin&quot;, &quot;VERSION=${version}&quot;, &quot;LIBAV_DIR=${libavDir}&quot;,
3211                                              &quot;SUFFIX=-ffmpeg&quot;, IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;)
3212                                     }
3213                                 }
3214                             }
3215 
3216                             project.ext.libav.ffmpeg.versions.each { version -&gt;
3217                                 def libavDir = &quot;${project.ext.libav.ffmpeg.basedir}-${version}&quot;
3218                                 File dir = file(libavDir)
3219                                 if (dir.exists()) {
3220                                     exec {
3221                                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/linux/avplugin&quot;)
3222                                         args(&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;,
3223                                              &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;,
3224                                              &quot;BASE_NAME=avplugin&quot;, &quot;VERSION=${version}&quot;, &quot;LIBAV_DIR=${libavDir}&quot;,
3225                                              &quot;SUFFIX=-ffmpeg&quot;, IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;)
3226                                     }
3227                                 }
3228                             }
3229                         } else {
3230                             // Building fxavcodec plugin (libav plugin)
3231                             exec {
3232                                 commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/linux/avplugin&quot;)
3233                                 args(&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;,
3234                                      &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;,
3235                                      &quot;BASE_NAME=avplugin&quot;, IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;)
3236                             }
3237                         }
3238                     }
3239                 }
3240                 buildNative.dependsOn buildAVPlugin
3241             }
3242 
3243             if (t.name == &quot;win&quot;) {
3244                 def buildResources = task(&quot;buildResources&quot;) {
3245                     doLast {
3246                         def rcOutputDir = &quot;${nativeOutputDir}/${buildType}&quot;
3247                         mkdir rcOutputDir
3248                         exec {
3249                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3250                             commandLine (WIN.media.rcCompiler)
3251                             args(WIN.media.glibRcFlags)
3252                             args(&quot;/Fo${rcOutputDir}/${WIN.media.glibRcFile}&quot;, WIN.media.rcSource)
3253                         }
3254 
3255                         exec {
3256                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3257                             commandLine (WIN.media.rcCompiler)
3258                             args(WIN.media.gstreamerRcFlags)
3259                             args(&quot;/Fo${rcOutputDir}/${WIN.media.gstreamerRcFile}&quot;, WIN.media.rcSource)
3260                         }
3261 
3262                         exec {
3263                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3264                             commandLine (WIN.media.rcCompiler)
3265                             args(WIN.media.fxpluginsRcFlags)
3266                             args(&quot;/Fo${rcOutputDir}/${WIN.media.fxpluginsRcFile}&quot;, WIN.media.rcSource)
3267                         }
3268 
3269                         exec {
3270                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3271                             commandLine (WIN.media.rcCompiler)
3272                             args(WIN.media.jfxmediaRcFlags)
3273                             args(&quot;/Fo${rcOutputDir}/${WIN.media.jfxmediaRcFile}&quot;, WIN.media.rcSource)
3274                         }
3275                     }
3276                 }
3277 
3278                 def buildGlib = task(&quot;build${t.capital}Glib&quot;, dependsOn: [buildResources]) {
3279                     enabled = IS_COMPILE_MEDIA
3280                     doLast {
3281                         exec {
3282                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3283                             commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/glib-lite&quot;)
3284                             args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=glib-lite&quot;,
3285                                  IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;, &quot;RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.glibRcFile}&quot;,
3286                                  &quot;CC=${mediaProperties.compiler}&quot;, &quot;AR=${mediaProperties.ar}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
3287                         }
3288                     }
3289                 }
3290                 buildGStreamer.dependsOn buildGlib
3291 
3292             } else if (t.name == &quot;mac&quot;) {
3293                 def buildGlib = task(&quot;build${t.capital}Glib&quot;) {
3294                     enabled = IS_COMPILE_MEDIA
3295                     doLast {
3296                         exec {
3297                             commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/libffi&quot;)
3298                             args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=ffi&quot;)
3299                             args (&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;, &quot;AR=${mediaProperties.ar}&quot;)
3300                         }
3301 
3302                         exec {
3303                             commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/glib-lite&quot;)
3304                             args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=glib-lite&quot;)
3305                             args (&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
3306                         }
3307                     }
3308                 }
3309                 buildGStreamer.dependsOn buildGlib
3310             }
3311         }
3312 
3313         buildNativeTargets.dependsOn buildNative
3314     }
3315 
3316     jar {
3317         exclude(&quot;headergen/**&quot;)
3318 
3319         dependsOn compileJava
3320         if (IS_COMPILE_MEDIA) {
3321             dependsOn buildNativeTargets
3322         }
3323     }
3324 
3325     addMavenPublication(project, [ &#39;graphics&#39; ])
3326 
3327     addValidateSourceSets(project, sourceSets)
3328 }
3329 
3330 project(&quot;:web&quot;) {
3331     configurations {
3332         webkit
3333     }
3334     project.ext.buildModule = true
3335     project.ext.includeSources = true
3336     project.ext.moduleRuntime = true
3337     project.ext.moduleName = &quot;javafx.web&quot;
3338 
3339     sourceSets {
3340         main
3341         shims {
3342             java {
3343                 compileClasspath += sourceSets.main.output
3344                 runtimeClasspath += sourceSets.main.output
3345             }
3346         }
3347         test {
3348             java {
3349                 compileClasspath += sourceSets.shims.output
3350                 runtimeClasspath += sourceSets.shims.output
3351             }
3352         }
3353     }
3354 
3355     project.ext.moduleSourcePath = defaultModuleSourcePath
3356     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
3357 
3358     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;controls&#39;, &#39;media&#39;, &#39;web&#39; ])
3359 
3360     dependencies {
3361         compile project(&quot;:base&quot;)
3362         compile project(&quot;:graphics&quot;)
3363         compile project(&quot;:controls&quot;)
3364         compile project(&quot;:media&quot;)
3365     }
3366 
3367     compileJava.dependsOn updateCacheIfNeeded
3368 
3369     task webArchiveJar(type: Jar) {
3370         from (project.file(&quot;$projectDir/src/test/resources/test/html&quot;)) {
3371             include &quot;**/archive-*.*&quot;
3372         }
3373         archiveName = &quot;webArchiveJar.jar&quot;
3374         destinationDir = file(&quot;$buildDir/testing/resources&quot;)
3375     }
3376 
3377     def gensrcDir = &quot;${buildDir}/gensrc/java&quot;
3378 
3379     // add in the wrappers to the compile
3380     sourceSets.main.java.srcDirs += &quot;${gensrcDir}&quot;
3381 
3382     if (IS_COMPILE_WEBKIT) {
3383         compileJava {
3384             // generate the native headers during compile
3385             // only needed if we are doing the native compile
3386             options.compilerArgs.addAll([
3387                 &#39;-h&#39;, &quot;${project.buildDir}/gensrc/headers&quot;
3388                 ])
3389         }
3390     }
3391 
3392     // Copy these to a common location in the moduleSourcePath
3393     def copyWrappers = project.task(&quot;copyPreGeneratedWrappers&quot;, type: Copy) {
3394         from &quot;src/main/native/Source/WebCore/bindings/java/dom3/java&quot;
3395         into &quot;${gensrcDir}&quot;
3396     }
3397 
3398     compileJava.dependsOn(copyWrappers);
3399 
3400     test {
3401         doFirst {
3402             if (IS_STUB_RUNTIME_OPENJFX) {
3403                 println &quot;********************************************************&quot;
3404                 println &quot;WARNING: running web tests with officially built webkit.&quot;
3405                 println &quot;The webkit native library may not be compatible with the&quot;
3406                 println &quot;source tree you are using.&quot;
3407                 println &quot;If tests fail, try compiling webkit instead.&quot;
3408                 println &quot;See WEBKIT-MEDIA-STUBS.md&quot;
3409                 println &quot;********************************************************&quot;
3410             } else if (!IS_COMPILE_WEBKIT) {
3411                 println &quot;******************************************************&quot;
3412                 println &quot;WARNING: running web tests without building webkit.&quot;
3413                 println &quot;The webkit native library will be copied from the JDK,&quot;
3414                 println &quot;which might lead to failures in some web tests.&quot;
3415                 println &quot;See WEBKIT-MEDIA-STUBS.md&quot;
3416                 println &quot;******************************************************&quot;
3417             }
3418         }
3419         // Run web tests in headless mode
3420         systemProperty &#39;glass.platform&#39;, &#39;Monocle&#39;
3421         systemProperty &#39;monocle.platform&#39;, &#39;Headless&#39;
3422         systemProperty &#39;prism.order&#39;, &#39;sw&#39;
3423         dependsOn webArchiveJar
3424         def testResourceDir = file(&quot;$buildDir/testing/resources&quot;)
3425         jvmArgs &quot;-DWEB_ARCHIVE_JAR_TEST_DIR=$testResourceDir&quot;
3426     }
3427 
3428     task compileJavaDOMBinding()
3429 
3430     compileTargets { t -&gt;
3431         def targetProperties = project.rootProject.ext[t.upper]
3432         def webkitProperties = targetProperties.webkit
3433         def classifier = (t.name != &quot;linux&quot; &amp;&amp; t.name != &quot;win&quot;) ? t.name :
3434                           IS_64 ? &quot;${t.name}-amd64&quot; : &quot;${t.name}-i586&quot;
3435 
3436         def webkitOutputDir = cygpath(&quot;$buildDir/${t.name}&quot;)
3437         def webkitConfig = IS_DEBUG_NATIVE ? &quot;Debug&quot; : &quot;Release&quot;
3438 
3439         File nativeBuildDir = new File(&quot;${webkitOutputDir}&quot;)
3440         nativeBuildDir.mkdirs()
3441 
3442         def compileNativeTask = task(&quot;compileNative${t.capital}&quot;, dependsOn: [compileJava]) {
3443             println &quot;Building Webkit configuration /$webkitConfig/ into $webkitOutputDir&quot;
3444             enabled =  (IS_COMPILE_WEBKIT)
3445 
3446             doLast {
3447                 exec {
3448                     workingDir(&quot;$webkitOutputDir&quot;)
3449                     commandLine(&quot;perl&quot;, &quot;$projectDir/src/main/native/Tools/Scripts/set-webkit-configuration&quot;, &quot;--$webkitConfig&quot;)
3450                     environment([&quot;WEBKIT_OUTPUTDIR&quot; : webkitOutputDir])
3451                 }
3452 
3453                 exec {
3454                     workingDir(&quot;$webkitOutputDir&quot;)
3455                     def cmakeArgs = &quot;-DENABLE_TOOLS=1&quot;
3456                     if (IS_STATIC_BUILD) {
3457                         cmakeArgs = &quot; $cmakeArgs -DSTATIC_BUILD=1 -DUSE_THIN_ARCHIVES=OFF&quot;;
3458                     }
3459                     cmakeArgs = &quot; $cmakeArgs -DCMAKE_C_COMPILER=&#39;${webkitProperties.compiler}&#39;&quot;
3460                     if (t.name == &quot;win&quot;) {
3461                         // To enable ninja build on Windows
3462                         environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3463                     } else if (t.name == &quot;mac&quot;) {
3464                         cmakeArgs = &quot; $cmakeArgs -DCMAKE_OSX_DEPLOYMENT_TARGET=$MACOSX_MIN_VERSION -DCMAKE_OSX_SYSROOT=$MACOSX_SDK_PATH&quot;
3465                     } else if (t.name == &quot;linux&quot;) {
3466                         cmakeArgs = &quot; $cmakeArgs -DCMAKE_SYSTEM_NAME=Linux&quot;
3467                         if (IS_64) {
3468                             cmakeArgs = &quot;$cmakeArgs -DCMAKE_SYSTEM_PROCESSOR=x86_64&quot;
3469                         } else {
3470                             cmakeArgs = &quot;$cmakeArgs -DCMAKE_SYSTEM_PROCESSOR=i586&quot;
3471                         }
3472                         // TODO: Use cflags and ldflags from all platforms
3473                         def cFlags = webkitProperties.ccFlags?.join(&#39; &#39;) ?: &#39;&#39;
3474                         def lFlags = webkitProperties.linkFlags?.join(&#39; &#39;) ?: &#39;&#39;
3475                         if (IS_STATIC_BUILD) {
3476                             cFlags = &quot; $cFlags -DSTATIC_BUILD=1&quot;;
3477                         }
3478                         // -shared flag should be omitted while creating executable.
3479                         def exeFlags = webkitProperties.linkFlags?.join(&#39; &#39;)?.replace(&#39;-shared&#39;, &#39;&#39;) ?: &#39;&#39;
3480                         cmakeArgs = &quot;$cmakeArgs -DCMAKE_C_FLAGS=&#39;${cFlags}&#39; -DCMAKE_CXX_FLAGS=&#39;${cFlags}&#39;&quot;
3481                         cmakeArgs = &quot;$cmakeArgs -DCMAKE_SHARED_LINKER_FLAGS=&#39;${lFlags}&#39; -DCMAKE_EXE_LINKER_FLAGS=&#39;${exeFlags}&#39;&quot;
3482                     } else if (t.name.startsWith(&quot;arm&quot;)) {
3483                         fail(&quot;ARM target is not supported as of now.&quot;)
3484                     }
3485 
3486                     if (IS_COMPILE_PARFAIT) {
3487                         environment([
3488                             &quot;COMPILE_PARFAIT&quot; : &quot;true&quot;
3489                         ])
3490                         environment &quot;PATH&quot;, System.env.PARFAIT_PATH + File.pathSeparator + environment.PATH
3491                         cmakeArgs = &quot;-DCMAKE_C_COMPILER=parfait-gcc -DCMAKE_CXX_COMPILER=parfait-g++&quot;
3492                     }
3493 
3494                     if (project.hasProperty(&#39;toolsPath&#39;)) {
3495                         environment &quot;PATH&quot;, toolsPath + File.pathSeparator + environment.PATH
3496                     }
3497 
3498                     environment([
3499                         &quot;JAVA_HOME&quot;       : JDK_HOME,
3500                         &quot;WEBKIT_OUTPUTDIR&quot; : webkitOutputDir,
3501                         &quot;PYTHONDONTWRITEBYTECODE&quot; : &quot;1&quot;,
3502                     ])
3503 
3504                     def targetCpuBitDepthSwitch = &quot;&quot;
3505                     if (IS_64) {
3506                         targetCpuBitDepthSwitch = &quot;--64-bit&quot;
3507                     } else {
3508                         targetCpuBitDepthSwitch = &quot;--32-bit&quot;
3509                     }
3510                     cmakeArgs += &quot; -DJAVAFX_RELEASE_VERSION=${jfxReleaseMajorVersion}&quot;
3511                     commandLine(&quot;perl&quot;, &quot;$projectDir/src/main/native/Tools/Scripts/build-webkit&quot;,
3512                         &quot;--java&quot;, &quot;--icu-unicode&quot;, targetCpuBitDepthSwitch,
3513                         &quot;--no-experimental-features&quot;, &quot;--cmakeargs=${cmakeArgs}&quot;)
3514                 }
3515             }
3516         }
3517 
3518         // Cmake places Windows DLL in bin directory
3519         def dllDir = IS_WINDOWS ? &quot;bin&quot; : &quot;lib&quot;
3520         def copyDumpTreeNativeTask = task(&quot;copyDumpTreeNative${t.capital}&quot;, type: Copy,
3521                 dependsOn: [ compileNativeTask]) {
3522             def library = rootProject.ext[t.upper].library
3523             from &quot;$webkitOutputDir/$webkitConfig/$dllDir/${library(&#39;DumpRenderTreeJava&#39;)}&quot;
3524             into &quot;$buildDir/test/${t.name}&quot;
3525         }
3526 
3527         def copyNativeTask = task(&quot;copyNative${t.capital}&quot;, type: Copy,
3528                 dependsOn: [compileNativeTask, copyDumpTreeNativeTask]) {
3529             enabled =  (IS_COMPILE_WEBKIT)
3530             def library = rootProject.ext[t.upper].library
3531             from &quot;$webkitOutputDir/$webkitConfig/$dllDir/${library(&#39;jfxwebkit&#39;)}&quot;
3532             into &quot;$buildDir/libs/${t.name}&quot;
3533         }
3534 
3535         if (IS_WINDOWS &amp;&amp; t.name == &quot;win&quot;) {
3536             def rcTask = project.task(&quot;rc${t.capital}&quot;, type: CompileResourceTask) {
3537                 compiler = webkitProperties.rcCompiler
3538                 source(webkitProperties.rcSource)
3539                 if (webkitProperties.rcFlags) {
3540                     rcParams.addAll(webkitProperties.rcFlags)
3541                 }
3542                 output(file(&quot;$webkitOutputDir/$webkitConfig/WebCore/obj&quot;))
3543             }
3544             compileNativeTask.dependsOn rcTask
3545         }
3546 
3547         def compileJavaDOMBindingTask = task(&quot;compileJavaDOMBinding${t.capital}&quot;, type: JavaCompile,
3548                 dependsOn: [compileJava, compileNativeTask, copyNativeTask]) {
3549             destinationDir = file(&quot;$buildDir/classes/java/main&quot;)
3550             classpath = configurations.compile
3551             source = project.sourceSets.main.java.srcDirs
3552             options.compilerArgs.addAll([
3553                 &#39;-implicit:none&#39;,
3554                 &#39;--module-source-path&#39;, defaultModuleSourcePath
3555                 ])
3556         }
3557 
3558         compileJavaDOMBinding.dependsOn compileJavaDOMBindingTask
3559 
3560         if (!targetProperties.compileWebnodeNative) {
3561             println(&quot;Not compiling native Webkit for ${t.name} per configuration request&quot;);
3562             compileNativeTask.enabled = false
3563         }
3564     }
3565 
3566     def drtClasses = &quot;**/com/sun/javafx/webkit/drt/**&quot;
3567     task drtJar(type: Jar, dependsOn: compileJava) {
3568         archiveName = &quot;drt.jar&quot;
3569         destinationDir = file(&quot;$buildDir/test&quot;)
3570         from &quot;$buildDir/classes/java/main/javafx.web/&quot;
3571         include drtClasses
3572         includeEmptyDirs = false
3573     }
3574 
3575     if (IS_COMPILE_WEBKIT) {
3576         assemble.dependsOn compileJavaDOMBinding, drtJar
3577     }
3578 
3579     addMavenPublication(project, [ &#39;controls&#39;, &#39;media&#39; ])
3580 
3581     addValidateSourceSets(project, sourceSets)
3582 }
3583 
3584 // This project is for system tests that need to run with a full SDK.
3585 // Most of them display a stage or do other things that preclude running
3586 // them in a shared JVM or as part of the &quot;smoke test&quot; run (which must
3587 // not pop up any windows or use audio). As such, they are only enabled
3588 // when FULL_TEST is specified, and each test runs in its own JVM
3589 project(&quot;:systemTests&quot;) {
3590 
3591     sourceSets {
3592         test
3593 
3594         // Source sets for standalone test apps (used for launcher tests)
3595         testapp1
3596 
3597         // Modular applications
3598         testapp2
3599         testapp3
3600         testapp4
3601         testapp5
3602         testapp6
3603         testscriptapp1
3604         testscriptapp2
3605     }
3606 
3607     def nonModSrcSets = [
3608         sourceSets.test,
3609         sourceSets.testapp1
3610     ]
3611 
3612     def modSrcSets = [
3613         sourceSets.testapp2,
3614         sourceSets.testapp3,
3615         sourceSets.testapp4,
3616         sourceSets.testapp5,
3617         sourceSets.testapp6,
3618         sourceSets.testscriptapp1,
3619         sourceSets.testscriptapp2
3620     ]
3621 
3622     project.ext.buildModule = false
3623     project.ext.moduleRuntime = false
3624     project.ext.moduleName = &quot;systemTests&quot;
3625 
3626     dependencies {
3627         testCompile project(&quot;:graphics&quot;).sourceSets.test.output
3628         testCompile project(&quot;:base&quot;).sourceSets.test.output
3629         testCompile project(&quot;:controls&quot;).sourceSets.test.output
3630         testCompile project(&quot;:swing&quot;).sourceSets.test.output
3631     }
3632 
3633     def dependentProjects = [ &#39;base&#39;, &#39;graphics&#39;, &#39;controls&#39;, &#39;media&#39;, &#39;web&#39;, &#39;swing&#39;, &#39;fxml&#39; ]
3634     commonModuleSetup(project, dependentProjects)
3635 
3636     File testJavaPolicyFile = new File(rootProject.buildDir, TESTJAVAPOLICYFILE);
3637     File testRunArgsFile = new File(rootProject.buildDir,TESTRUNARGSFILE);
3638 
3639     File stRunArgsFile = new File(project.buildDir,&quot;st.run.args&quot;);
3640 
3641     def sts = task(&quot;systemTestSetup&quot;) {
3642         outputs.file(stRunArgsFile)
3643 
3644         doLast() {
3645             stRunArgsFile.delete()
3646 
3647             logger.info(&quot;Creating patchmodule.args file ${stRunArgsFile}&quot;)
3648 
3649             // Create an argfile with the information needed to launch
3650             // the stand alone system unit tests.
3651 
3652             //First add in all of the patch-module args we use for the
3653             //normal unit tests, copied from test.run.args
3654             testRunArgsFile.eachLine { str -&gt;
3655                 stRunArgsFile &lt;&lt;  &quot;${str}\n&quot;
3656             }
3657 
3658             // Now add in the working classpath elements (junit, test classes...)
3659             stRunArgsFile &lt;&lt;  &quot;-cp \&quot;\\\n&quot;
3660             test.classpath.each() { elem -&gt;
3661                 def e = cygpath(&quot;${elem}&quot;)
3662                 stRunArgsFile &lt;&lt;  &quot;  ${e}${File.pathSeparator}\\\n&quot;
3663             }
3664             stRunArgsFile &lt;&lt;  &quot;\&quot;\n&quot;
3665         }
3666     }
3667 
3668     test.dependsOn(sts)
3669     test.dependsOn(createTestArgfiles);
3670 
3671     // Tasks to create standalone test applications for the launcher tests
3672 
3673     if (project.hasProperty(&#39;testModulePathArgs&#39;)) {
3674         compileTestapp1Java.options.compilerArgs.addAll(testModulePathArgs)
3675     }
3676     dependentProjects.each { e -&gt;
3677         compileTestapp1Java.dependsOn(rootProject.project(e).testClasses)
3678     }
3679 
3680     def testapp1JarName = &quot;testapp1.jar&quot;
3681     task createTestapp1Jar1(type: Jar) {
3682         dependsOn compileTestapp1Java
3683         enabled = IS_FULL_TEST
3684 
3685         destinationDir = file(&quot;$buildDir/testapp1&quot;)
3686         archiveName = testapp1JarName
3687         includeEmptyDirs = false
3688         from project.sourceSets.testapp1.java.outputDir
3689         include(&quot;testapp/**&quot;)
3690         include(&quot;com/javafx/main/**&quot;)
3691 
3692         manifest {
3693             attributes(
3694                 &quot;Main-Class&quot; : &quot;com.javafx.main.Main&quot;,
3695                 &quot;JavaFX-Version&quot; : &quot;2.2&quot;,
3696                 &quot;JavaFX-Application-Class&quot; : &quot;testapp.HelloWorld&quot;,
3697                 &quot;JavaFX-Class-Path&quot; : &quot;jar2.jar&quot;
3698             )
3699         }
3700     }
3701 
3702     task createTestapp1Jar2(type: Jar) {
3703         dependsOn compileTestapp1Java
3704         enabled = IS_FULL_TEST
3705 
3706         destinationDir = file(&quot;$buildDir/testapp1&quot;)
3707         archiveName = &quot;jar2.jar&quot;;
3708         includeEmptyDirs = false
3709         from project.sourceSets.testapp1.java.outputDir
3710         include(&quot;pkg2/**&quot;)
3711     }
3712 
3713     task createTestApps() {
3714         dependsOn(createTestapp1Jar1)
3715         dependsOn(createTestapp1Jar2)
3716     }
3717     test.dependsOn(createTestApps);
3718 
3719     def modtestapps = [ &quot;testapp2&quot;, &quot;testapp3&quot;, &quot;testapp4&quot;, &quot;testapp5&quot;, &quot;testapp6&quot;, &quot;testscriptapp1&quot;, &quot;testscriptapp2&quot; ]
3720     modtestapps.each { testapp -&gt;
3721         def testappCapital = testapp.capitalize()
3722         def copyTestAppTask = task(&quot;copy${testappCapital}&quot;, type: Copy) {
3723             from project.sourceSets.&quot;${testapp}&quot;.java.outputDir
3724             from project.sourceSets.&quot;${testapp}&quot;.output.resourcesDir
3725             into &quot;${project.buildDir}/modules/${testapp}&quot;
3726         }
3727 
3728         def List&lt;String&gt; testAppSourceDirs = []
3729         project.sourceSets.&quot;${testapp}&quot;.java.srcDirs.each { dir -&gt;
3730             testAppSourceDirs += dir
3731         }
3732         def testappCompileTasks = project.getTasksByName(&quot;compile${testappCapital}Java&quot;, true);
3733         def testappResourceTasks = project.getTasksByName(&quot;process${testappCapital}Resources&quot;, true);
3734         testappCompileTasks.each { appCompileTask -&gt;
3735             appCompileTask.options.compilerArgs.addAll([
3736                 &#39;-implicit:none&#39;,
3737                 &#39;--module-source-path&#39;, testAppSourceDirs.join(File.pathSeparator),
3738                 ] )
3739             if (project.hasProperty(&#39;testModulePathArgs&#39;)) {
3740                 appCompileTask.options.compilerArgs.addAll(testModulePathArgs)
3741             }
3742 
3743             dependentProjects.each { e -&gt;
3744                 appCompileTask.dependsOn(rootProject.project(e).testClasses)
3745             }
3746 
3747             copyTestAppTask.dependsOn(appCompileTask)
3748         }
3749         testappResourceTasks.each { appResourceTask -&gt;
3750             copyTestAppTask.dependsOn(appResourceTask)
3751         }
3752 
3753         createTestApps.dependsOn(copyTestAppTask)
3754     }
3755 
3756     test {
3757         enabled = IS_FULL_TEST
3758 
3759         // Parse testPatchModuleArgs looking for &quot;--module-path&quot;.
3760         // Save path if found so we can pass it to the module launcher tests
3761         def pendingModulePath = false
3762         testPatchModuleArgs.each { str -&gt;
3763             if (pendingModulePath) {
3764                 project.ext.launcherModulePath = str;
3765                 pendingModulePath = false
3766             } else if (str == &quot;--module-path&quot;) {
3767                 pendingModulePath = true
3768             }
3769         }
3770 
3771         // Properties passed to launcher tests
3772         systemProperty &quot;launchertest.testapp1.jar&quot;, &quot;build/testapp1/$testapp1JarName&quot;
3773         modtestapps.each { testapp -&gt;
3774             systemProperty &quot;launchertest.${testapp}.module.path&quot;,
3775                     &quot;${project.buildDir}/modules/${testapp}&quot;
3776         }
3777 
3778         // Properties passed to test.util.Util
3779         systemProperties &#39;worker.debug&#39;: IS_WORKER_DEBUG
3780         systemProperties &#39;worker.patchmodule.file&#39;: cygpath(stRunArgsFile.path)
3781         if (project.hasProperty(&quot;launcherModulePath&quot;)) {
3782             systemProperties &#39;worker.module.path&#39;: launcherModulePath
3783         }
3784         systemProperties &#39;worker.patch.policy&#39;: cygpath(testJavaPolicyFile.path)
3785         systemProperties &#39;worker.java.cmd&#39;: JAVA
3786 
3787         if (rootProject.hasProperty(&quot;ClipShapeTest.numTests&quot;)) {
3788             systemProperty &quot;ClipShapeTest.numTests&quot;, rootProject.getProperty(&quot;ClipShapeTest.numTests&quot;)
3789         }
3790 
3791         if (!IS_USE_ROBOT) {
3792             // Disable all robot-based visual tests
3793             exclude(&quot;test/robot/**&quot;);
3794         }
3795         if (!IS_UNSTABLE_TEST) {
3796             // JDK-8196607 Don&#39;t run monocle test cases 
3797             exclude(&quot;test/robot/com/sun/glass/ui/monocle/**&quot;);
3798         }
3799         if (!IS_AWT_TEST) {
3800             // Disable all AWT-based tests
3801             exclude(&quot;**/javafx/embed/swing/*.*&quot;);
3802             exclude(&quot;**/com/sun/javafx/application/Swing*.*&quot;);
3803         }
3804 
3805         forkEvery = 1
3806     }
3807 
3808     addValidateSourceSets(project, nonModSrcSets, modSrcSets)
3809 }
3810 
3811 allprojects {
3812     // The following block is a workaround for the fact that presently Gradle
3813     // can&#39;t set the -XDignore.symbol.file flag, because it appears that the
3814     // javac API is lacking support for it. So what we&#39;ll do is find any Compile
3815     // task and manually provide the options necessary to fire up the
3816     // compiler with the right settings.
3817     tasks.withType(JavaCompile) { compile -&gt;
3818         if (compile.options.hasProperty(&quot;useAnt&quot;)) {
3819             compile.options.useAnt = true
3820             compile.options.useDepend = IS_USE_DEPEND
3821         } else if (compile.options.hasProperty(&quot;incremental&quot;)) {
3822             compile.options.incremental = IS_INCREMENTAL
3823         }
3824         compile.options.debug = true // we always generate debugging info in the class files
3825         compile.options.debugOptions.debugLevel = IS_DEBUG_JAVA ? &quot;source,lines,vars&quot; : &quot;source,lines&quot;
3826         compile.options.fork = true
3827 
3828         compile.options.forkOptions.executable = JAVAC
3829 
3830         compile.options.warnings = IS_LINT
3831 
3832         compile.options.compilerArgs += [&quot;-XDignore.symbol.file&quot;, &quot;-encoding&quot;, &quot;UTF-8&quot;]
3833 
3834         // we use a custom javadoc command
3835         project.javadoc.enabled = false
3836 
3837         // Add in the -Xlint options
3838         if (IS_LINT) {
3839             LINT.split(&quot;[, ]&quot;).each { s -&gt;
3840                 compile.options.compilerArgs += &quot;-Xlint:$s&quot;
3841             }
3842         }
3843     } // tasks with javaCompile
3844 
3845     // If I am a module....
3846     if (project.hasProperty(&#39;moduleSourcePath&#39;) &amp;&amp;
3847             (project.hasProperty(&#39;buildModule&#39;) &amp;&amp; project.buildModule)) {
3848         project.compileJava {
3849             options.compilerArgs.addAll([
3850                 &#39;-implicit:none&#39;,
3851                 &#39;--module-source-path&#39;, project.moduleSourcePath
3852                 ])
3853         }
3854         // no jars needed for modules
3855         project.jar.enabled = false
3856 
3857         // and redirect the resources into the module
3858         project.sourceSets.main.output.resourcesDir = project.moduleDir
3859         project.processResources.destinationDir = project.moduleDir
3860     }
3861 
3862     if (project.hasProperty(&#39;moduleSourcePathShim&#39;) &amp;&amp;
3863             project.sourceSets.hasProperty(&#39;shims&#39;)) {
3864 
3865         // sync up the obvious source directories with the shims
3866         // others (like the shaders in graphics) should be added in there
3867         project.sourceSets.shims.java.srcDirs += project.sourceSets.main.java.srcDirs
3868         project.sourceSets.shims.java.srcDirs += &quot;$buildDir/gensrc/java&quot;
3869 
3870         project.compileShimsJava {
3871             options.compilerArgs.addAll([
3872                 &#39;-implicit:none&#39;,
3873                 &#39;--module-source-path&#39;, project.moduleSourcePathShim
3874                 ])
3875         }
3876         project.compileShimsJava.dependsOn(project.compileJava)
3877 
3878         def copyGeneratedShimsTask = task(&quot;copyGeneratedShims&quot;, type: Copy, dependsOn: [compileShimsJava, processShimsResources]) {
3879             from project.sourceSets.shims.java.outputDir
3880             into &quot;${rootProject.buildDir}/shims&quot;
3881             if (HAS_JAVAFX_MODULES) {
3882                 exclude(&quot;*/module-info.class&quot;)
3883             }
3884         }
3885 
3886         project.processShimsResources.dependsOn(project.processResources)
3887 
3888         // shims resources should have the main resouces as a base
3889         project.sourceSets.shims.resources.srcDirs += project.sourceSets.main.resources.srcDirs
3890 
3891         // and redirect the resources into the module
3892         project.sourceSets.shims.output.resourcesDir = project.moduleShimsDir
3893         project.processShimsResources.destinationDir = project.moduleShimsDir
3894 
3895        compileTestJava.dependsOn(copyGeneratedShimsTask)
3896     }
3897 
3898     if (project.hasProperty(&#39;modulePathArgs&#39;)) {
3899         project.compileJava.options.compilerArgs.addAll(modulePathArgs)
3900     }
3901 
3902     if (project.hasProperty(&#39;testModulePathArgs&#39;)) {
3903         project.compileTestJava.options.compilerArgs.addAll(testModulePathArgs)
3904     }
3905 
3906     if (project.hasProperty(&#39;testPatchModuleArgs&#39;)) {
3907         project.test.jvmArgs += testPatchModuleArgs
3908     }
3909 
3910     /* Note: we should not have to add extraAddExports to the normal
3911      * modular compile, as it contains all of the module-info files.
3912      * In fact doing so might cover up a module-info issue.
3913      * so we don&#39;t do it, and I will leave this commented out
3914      * block as a reminder of this fact.
3915     if (project.hasProperty(&#39;extraAddExports&#39;)) {
3916         project.compileJava.options.compilerArgs.addAll(extraAddExports);
3917     }
3918     */
3919 
3920     if (project.hasProperty(&#39;testAddExports&#39;)) {
3921         project.compileTestJava.options.compilerArgs.addAll(testAddExports);
3922         project.test.jvmArgs += testAddExports
3923     }
3924 
3925     if (rootProject.hasProperty(&quot;EXTRA_TEST_ARGS&quot;) &amp;&amp; project.hasProperty(&#39;test&#39;)) {
3926         EXTRA_TEST_ARGS.split(&#39; &#39;).each() { e -&gt;
3927             project.test.jvmArgs += e
3928         }
3929     }
3930 
3931     if (rootProject.hasProperty(&quot;EXTRA_COMPILE_ARGS&quot;) &amp;&amp; project.hasProperty(&#39;compileJava&#39;)) {
3932         project.compileJava.options.compilerArgs.addAll(EXTRA_COMPILE_ARGS.split(&#39; &#39;))
3933     }
3934 
3935     if (rootProject.hasProperty(&quot;EXTRA_COMPILE_ARGS&quot;) &amp;&amp; project.hasProperty(&#39;compileTestJava&#39;)) {
3936         project.compileTestJava.options.compilerArgs.addAll(EXTRA_COMPILE_ARGS.split(&#39; &#39;))
3937     }
3938 }
3939 
3940 /******************************************************************************
3941  *                                                                            *
3942  *                             Top Level Tasks                                *
3943  *                                                                            *
3944  *  These are the tasks which are defined only for the top level project and  *
3945  *  not for any sub projects. These are generally the entry point that is     *
3946  *  used by Hudson and by the continuous build system.                        *
3947  *                                                                            *
3948  *****************************************************************************/
3949 
3950 task clean() {
3951     group = &quot;Basic&quot;
3952     description = &quot;Deletes the build directory and the build directory of all sub projects&quot;
3953     getSubprojects().each { subProject -&gt;
3954         dependsOn(subProject.getTasksByName(&quot;clean&quot;, true));
3955     }
3956     doLast {
3957         delete(buildDir);
3958     }
3959 }
3960 
3961 task cleanAll() {
3962     group = &quot;Basic&quot;
3963     description = &quot;Scrubs the repo of build artifacts&quot;
3964     dependsOn(clean)
3965     doLast {
3966         //delete(&quot;.gradle&quot;); This causes problems on windows.
3967         delete(&quot;buildSrc/build&quot;);
3968     }
3969 }
3970 
3971 task createMSPfile() {
3972     group = &quot;Build&quot;
3973     File mspFile = new File(rootProject.buildDir,MODULESOURCEPATH)
3974     outputs.file(mspFile)
3975 
3976     doLast {
3977         mspFile.delete()
3978         mspFile &lt;&lt; &quot;--module-source-path\n&quot;
3979         mspFile &lt;&lt; defaultModuleSourcePath
3980         mspFile &lt;&lt; &quot;\n&quot;
3981     }
3982 }
3983 
3984 task javadoc(type: Javadoc, dependsOn: createMSPfile) {
3985     group = &quot;Basic&quot;
3986     description = &quot;Generates the JavaDoc for all the public API&quot;
3987     executable = JAVADOC
3988     def projectsToDocument = [
3989             project(&quot;:base&quot;), project(&quot;:graphics&quot;), project(&quot;:controls&quot;), project(&quot;:media&quot;),
3990             project(&quot;:swing&quot;), /*project(&quot;:swt&quot;),*/ project(&quot;:fxml&quot;), project(&quot;:web&quot;)]
3991     source(projectsToDocument.collect({
3992         [it.sourceSets.main.java]
3993     }));
3994     setDestinationDir(new File(buildDir, &#39;javadoc&#39;));
3995 
3996     exclude(&quot;com/**/*&quot;, &quot;Compile*&quot;, &quot;javafx/builder/**/*&quot;, &quot;javafx/scene/accessibility/**/*&quot;);
3997 
3998     options.tags(&quot;apiNote:a:API Note:&quot;)
3999     options.tags(&quot;implSpec:a:Implementation Requirements:&quot;)
4000     options.tags(&quot;implNote:a:Implementation Note:&quot;)
4001     options.tags(&quot;param&quot;)
4002     options.tags(&quot;return&quot;)
4003     options.tags(&quot;throws&quot;)
4004     options.tags(&quot;moduleGraph:X&quot;)
4005     options.tags(&quot;since&quot;)
4006     options.tags(&quot;version&quot;)
4007     options.tags(&quot;serialData&quot;)
4008     options.tags(&quot;factory&quot;)
4009     options.tags(&quot;see&quot;)
4010 
4011     options.windowTitle(&quot;${javadocTitle}&quot;)
4012     options.header(&quot;${javadocHeader}&quot;)
4013     options.bottom(&quot;${javadocBottom}&quot;)
4014     options.locale(&quot;en&quot;);
4015     if (JDK_DOCS_LINK != &quot;&quot;) {
4016         options.linksOffline(JDK_DOCS, JDK_DOCS_LINK);
4017     } else {
4018         options.links(JDK_DOCS);
4019     }
4020     options.addBooleanOption(&quot;XDignore.symbol.file&quot;).setValue(true);
4021     options.addBooleanOption(&quot;Xdoclint:${DOC_LINT}&quot;).setValue(IS_DOC_LINT);
4022     options.addBooleanOption(&quot;html5&quot;).setValue(true);
4023     options.addBooleanOption(&quot;javafx&quot;).setValue(true);
4024     options.addBooleanOption(&quot;use&quot;).setValue(true);
4025 
4026     options.setOptionFiles([
4027         new File(rootProject.buildDir,MODULESOURCEPATH)
4028         ]);
4029 
4030     doLast {
4031         projectsToDocument.each { p -&gt;
4032             def destDir = &quot;$buildDir/javadoc/${p.ext.moduleName}&quot;
4033             copy {
4034                 from(&quot;$p.projectDir/src/main/docs&quot;) {
4035                     include &quot;**/*.html&quot;
4036                     filter { line-&gt;
4037                         line = line.replace(&quot;@FXVERSION@&quot;, RELEASE_VERSION)
4038                     }
4039                 }
4040                 from(&quot;$p.projectDir/src/main/docs&quot;) {
4041                     exclude &quot;**/*.html&quot;
4042                 }
4043 
4044                 into destDir
4045             }
4046         }
4047     }
4048 
4049     dependsOn(projectsToDocument.collect { project -&gt; project.getTasksByName(&quot;classes&quot;, true)});
4050 }
4051 
4052 task sdk() {
4053     if (DO_BUILD_SDK_FOR_TEST) {
4054         rootProject.getTasksByName(&quot;test&quot;, true).each { t -&gt;
4055             if (t.enabled) t.dependsOn(sdk)
4056         }
4057     }
4058 }
4059 
4060 task jmods() {
4061     dependsOn(sdk)
4062     // real work items added later.
4063 }
4064 
4065 task appsjar() {
4066     dependsOn(sdk)
4067     // Note: the jar dependencies get added elsewhere see project(&quot;:apps&quot;)
4068 }
4069 
4070 // these are empty tasks, allowing us to depend on the task, which may have other
4071 // real work items added later.
4072 task copyAppsArtifacts() {
4073     dependsOn(appsjar)
4074 }
4075 
4076 task apps() {
4077     dependsOn(sdk)
4078     dependsOn(appsjar)
4079     dependsOn(copyAppsArtifacts)
4080 }
4081 
4082 task findbugs() {
4083     dependsOn(sdk)
4084 
4085     doLast {
4086         if (!BUILD_CLOSED) {
4087             println &quot;findbugs task is only run for a closed build&quot;
4088         }
4089     }
4090 }
4091 
4092 // create the zip file of modules for a JDK build
4093 task jdkZip {
4094     dependsOn(sdk)
4095 }
4096 
4097 // The following tasks are for the closed build only. They are a no-op for the open build
4098 
4099 task checkCache() {
4100     dependsOn(updateCacheIfNeeded)
4101 }
4102 
4103 task publicExports() {
4104     dependsOn(sdk, jmods, apps, javadoc, jdkZip)
4105     // note the real work is below in the compileTargets
4106 }
4107 
4108 task perf() {
4109     dependsOn(sdk, apps)
4110     doLast {
4111         if (!BUILD_CLOSED) {
4112             println &quot;perf task is only run for a closed build&quot;
4113         }
4114     }
4115 }
4116 
4117 task zips() {
4118     dependsOn(sdk, jmods, javadoc, apps, jdkZip, publicExports, perf)
4119     // note the real work is below in the compileTargets
4120 }
4121 
4122 task all() {
4123     dependsOn(sdk,publicExports,apps,perf,zips)
4124 }
4125 
4126 
4127 // Construct list of subprojects that are modules
4128 ext.moduleProjList = []
4129 subprojects {
4130     if (project.hasProperty(&quot;buildModule&quot;) &amp;&amp; project.ext.buildModule) {
4131         rootProject.ext.moduleProjList += project
4132         println &quot;module: $project (buildModule=YES)&quot;
4133     } else {
4134         println &quot;module: $project (buildModule=NO)&quot;
4135     }
4136 }
4137 
4138 
4139 // Define the sdk task, which also produces the javafx.swt modular jar
4140 
4141 compileTargets { t -&gt;
4142 
4143     def javafxSwtTask = task(&quot;javafxSwt$t.capital&quot;, type: Jar) {
4144         enabled = COMPILE_SWT
4145         group = &quot;Basic&quot;
4146         description = &quot;Creates the javafx-swt.jar for the $t.name target&quot;
4147         destinationDir = file(&quot;${project(&quot;:swt&quot;).buildDir}/libs&quot;)
4148         archiveName = &quot;javafx-swt.jar&quot;
4149         includeEmptyDirs = false
4150         from(&quot;${project(&quot;:swt&quot;).buildDir}/classes/java/main&quot;);
4151         include(&quot;**/javafx/embed/swt/**&quot;)
4152 
4153         dependsOn(
4154             project(&quot;:swt&quot;).compileJava,
4155             project(&quot;:swt&quot;).processResources,
4156             // note: assemble and classes are not enough for DidWork
4157             project(&quot;:swt&quot;).classes,
4158             // classes is needed for a jar copy
4159             )
4160     }
4161 
4162     // FIXME: do we really need the index task for this modular jar?
4163     def javafxSwtIndexTask = task(&quot;javafxSwtIndex$t.capital&quot;) {
4164         //the following is a workaround for the lack of indexing in gradle 1.4 through 1.7
4165         dependsOn(javafxSwtTask)
4166 
4167         doLast() {
4168             ant.jar (update: true, index: true, destfile: &quot;${javafxSwtTask.destinationDir}/${javafxSwtTask.archiveName}&quot;)
4169         }
4170     }
4171 
4172     def sdkTask = task(&quot;sdk$t.capital&quot;) {
4173         group = &quot;Basic&quot;
4174         dependsOn(javafxSwtIndexTask)
4175     }
4176 
4177     sdk.dependsOn(sdkTask)
4178 }
4179 
4180 project(&quot;:apps&quot;) {
4181     // The apps build is Ant based, we will exec ant from gradle.
4182 
4183     // Download the Lucene libraries needed for the Ensemble8 app
4184     def luceneVersion = &quot;7.7.2&quot;
4185     getConfigurations().create(&quot;lucene&quot;);
4186     dependencies {
4187         lucene group: &quot;org.apache.lucene&quot;, name: &quot;lucene-core&quot;, version: luceneVersion
4188         lucene group: &quot;org.apache.lucene&quot;, name: &quot;lucene-grouping&quot;, version: luceneVersion
4189         lucene group: &quot;org.apache.lucene&quot;, name: &quot;lucene-queryparser&quot;, version: luceneVersion
4190     }
4191 
4192     // Copy Lucene libraries into the Ensemble8/lib directory
4193     File ensembleLibDir = rootProject.file(&quot;apps/samples/Ensemble8/lib&quot;);
4194     def libNames = [ &quot;lucene-core-${luceneVersion}.jar&quot;,
4195                      &quot;lucene-grouping-${luceneVersion}.jar&quot;,
4196                      &quot;lucene-queryparser-${luceneVersion}.jar&quot; ]
4197 
4198 
4199     task getLucene(type: Copy) {
4200         doFirst {
4201             ensembleLibDir.mkdirs();
4202         }
4203         into ensembleLibDir
4204         includeEmptyDirs = false
4205         configurations.lucene.files.each { f -&gt;
4206             libNames.each { name -&gt;
4207                 if (name == f.getName()) {
4208                     from f.getPath()
4209                 }
4210             }
4211         }
4212     }
4213 
4214     compileTargets { t -&gt;
4215         List&lt;String&gt; params = []
4216 
4217         params &lt;&lt; &quot;-DtargetBld=$t.name&quot;
4218 
4219         if (!rootProject.ext[t.upper].compileSwing) {
4220             params &lt;&lt; &quot;-DJFX_CORE_ONLY=true&quot;
4221         }
4222         params &lt;&lt; &quot;-Dplatforms.JDK_1.9.home=${rootProject.ext.JDK_HOME}&quot;
4223         params &lt;&lt; &quot;-Dcompile.patch=@${rootProject.buildDir}/${COMPILEARGSFILE}&quot;
4224         params &lt;&lt; &quot;-Drun.patch=@${rootProject.buildDir}/${RUNARGSFILE}&quot;
4225 
4226         def appsJar = project.task(&quot;appsJar${t.capital}&quot;) {
4227             dependsOn(sdk, getLucene)
4228             doLast() {
4229                 ant(t.name,
4230                       projectDir.path,
4231                       &quot;appsJar&quot;,
4232                       params);
4233             }
4234         }
4235         rootProject.appsjar.dependsOn(appsJar)
4236 
4237         def appsClean = project.task(&quot;clean${t.capital}&quot;) {
4238             doLast() {
4239                 ant(t.name,
4240                       project.projectDir.path,
4241                       &quot;clean&quot;,
4242                       params);
4243                 delete(ensembleLibDir);
4244             }
4245         }
4246         rootProject.clean.dependsOn(appsClean)
4247     }
4248 }
4249 
4250 // Tasks to create the disk layout for the sdk, jmods, and docs
4251 // in the artifacts directory (publicExports), and zip them up in
4252 // artifacts/bundles (zips)
4253 // These tasks are only used for the standalone SDK.
4254 compileTargets { t -&gt;
4255     if (!HAS_JAVAFX_MODULES) {
4256         def targetProperties = rootProject.ext[t.upper]
4257         def platformPrefix = targetProperties.platformPrefix
4258 
4259         def artifactsDir = &quot;${rootProject.buildDir}/artifacts&quot;
4260         def bundlesDir = &quot;${artifactsDir}/bundles&quot;
4261 
4262         def sdkDirName = &quot;${platformPrefix}sdk&quot;
4263         def sdkDir = &quot;${rootProject.buildDir}/${sdkDirName}&quot;
4264         def sdkBundleName = &quot;javafx-sdk-${RELEASE_VERSION}&quot;
4265         def sdkArtifactsDir = &quot;${artifactsDir}/${sdkBundleName}&quot;
4266 
4267         def docsDirName = &quot;javadoc&quot;
4268         def docsDir = &quot;${rootProject.buildDir}/${docsDirName}&quot;
4269         def docsBundleName = &quot;javafx-docs-${RELEASE_VERSION}&quot;
4270         def docsArtifactsDir = &quot;${artifactsDir}/${docsBundleName}&quot;
4271 
4272         def jmodsDirName = &quot;jmods&quot;
4273         def jmodsDir = &quot;${rootProject.buildDir}/${jmodsDirName}&quot;
4274         def jmodsBundleName = &quot;javafx-jmods-${RELEASE_VERSION}&quot;
4275         def jmodsArtifactsDir = &quot;${artifactsDir}/${jmodsBundleName}&quot;
4276 
4277         def publicExportsTask = task (&quot;publicExportsStandalone${t.capital}&quot;) {
4278             group = &quot;Basic&quot;
4279             description = &quot;Creates the disk layout for sdk, jmods, and docs&quot;
4280         }
4281         publicExports.dependsOn(publicExportsTask)
4282 
4283         def copyArtifactsSdkTask = task(&quot;copyArtifactsSdk$t.capital&quot;, type: Copy, dependsOn: [sdk,jmods,apps,javadoc]) {
4284             from sdkDir
4285             into sdkArtifactsDir
4286         }
4287         publicExportsTask.dependsOn(copyArtifactsSdkTask)
4288 
4289         // Need to modify file permissions Windows to make sure that the
4290         // execute bit is set, and that the files are world readable
4291         def chmodArtifactsSdkTask = task(&quot;chmodArtifactsSdk$t.capital&quot;, dependsOn: copyArtifactsSdkTask) {
4292             if (IS_WINDOWS &amp;&amp; IS_USE_CYGWIN) {
4293                 doLast {
4294                     exec {
4295                         workingDir(sdkArtifactsDir)
4296                         commandLine(&quot;chmod&quot;, &quot;-R&quot;, &quot;755&quot;, &quot;.&quot;)
4297                     }
4298                 }
4299             }
4300         }
4301         publicExportsTask.dependsOn(chmodArtifactsSdkTask)
4302 
4303         def copyArtifactsDocsTask = task(&quot;copyArtifactsDocs$t.capital&quot;, type: Copy, dependsOn: chmodArtifactsSdkTask) {
4304             from docsDir
4305             into &quot;${docsArtifactsDir}/api&quot;
4306         }
4307         publicExportsTask.dependsOn(copyArtifactsDocsTask)
4308 
4309         def copyArtifactsJmodsTask = task(&quot;copyArtifactsJmods$t.capital&quot;, type: Copy, dependsOn: copyArtifactsDocsTask) {
4310             from jmodsDir
4311             into &quot;${jmodsArtifactsDir}&quot;
4312         }
4313         publicExportsTask.dependsOn(copyArtifactsJmodsTask)
4314 
4315         def zipsTask = task (&quot;zipsStandalone${t.capital}&quot;) {
4316             group = &quot;Basic&quot;
4317             description = &quot;Creates the public zip bundles&quot;
4318         }
4319         zips.dependsOn(zipsTask)
4320 
4321         // Use native zip tool so that file permissions are preserved on Windows
4322         def zipSdkTask = task(&quot;zipSdk$t.capital&quot;, dependsOn: publicExportsTask) {
4323             doLast {
4324                 def outZipFile = &quot;${bundlesDir}/${sdkBundleName}.zip&quot;
4325                 mkdir bundlesDir
4326                 exec {
4327                     workingDir(artifactsDir)
4328                     commandLine(&quot;zip&quot;, &quot;-q&quot;, &quot;-r&quot;, outZipFile, sdkBundleName)
4329                 }
4330             }
4331         }
4332         zipsTask.dependsOn(zipSdkTask)
4333 
4334         def zipDocsTask = task(&quot;zipDocs$t.capital&quot;, type: Zip, dependsOn: zipSdkTask) {
4335             destinationDir = file(&quot;${bundlesDir}&quot;)
4336             archiveName = &quot;${docsBundleName}.zip&quot;
4337             includeEmptyDirs = false
4338             from docsArtifactsDir
4339             into &quot;${docsBundleName}&quot;
4340         }
4341         zipsTask.dependsOn(zipDocsTask)
4342 
4343         def zipJmodsTask = task(&quot;zipJmods$t.capital&quot;, type: Zip, dependsOn: zipDocsTask) {
4344             destinationDir = file(&quot;${bundlesDir}&quot;)
4345             archiveName = &quot;${jmodsBundleName}.zip&quot;
4346             includeEmptyDirs = false
4347             from jmodsArtifactsDir
4348             into &quot;${jmodsBundleName}&quot;
4349         }
4350         zipsTask.dependsOn(zipJmodsTask)
4351     }
4352 }
4353 
4354 
4355 /******************************************************************************
4356  *                                                                            *
4357  *                             OpenJFX Stubs                                  *
4358  *                                                                            *
4359  *****************************************************************************/
4360 
4361 configurations {
4362     openjfxStubs
4363 }
4364 
4365 if (IS_STUB_RUNTIME_OPENJFX) {
4366     def String platform = IS_MAC ? &quot;mac&quot; : IS_WINDOWS ? &quot;win&quot; : IS_LINUX ? &quot;linux&quot; : &quot;&quot;
4367     dependencies {
4368         openjfxStubs &quot;org.openjfx:javafx-media:$STUB_RUNTIME_OPENJFX:$platform@jar&quot;
4369         openjfxStubs &quot;org.openjfx:javafx-web:$STUB_RUNTIME_OPENJFX:$platform@jar&quot;
4370     }
4371 }
4372 
4373 // Extract binary libraries from OpenJFX artifacts for use as stubs
4374 task prepOpenJfxStubs(type: Copy) {
4375     enabled = IS_STUB_RUNTIME_OPENJFX
4376 
4377     from configurations.openjfxStubs.files.collect { zipTree(it) }
4378     include(&quot;*.dll&quot;)
4379     include(&quot;*.dylib&quot;)
4380     include(&quot;*.so&quot;)
4381     into IS_WINDOWS ? file(&quot;$openjfxStubRuntime/bin&quot;) : file(&quot;$openjfxStubRuntime/lib&quot;)
4382 }
4383 
4384 
4385 /******************************************************************************
4386  *                                                                            *
4387  *                               Modules                                      *
4388  *                                                                            *
4389  *****************************************************************************/
4390 
4391 ext.moduleDependencies = [file(&quot;dependencies&quot;)]
4392 
4393 task buildModules {
4394 }
4395 
4396 // Combine the classes, lib, and bin for each module
4397 compileTargets { t -&gt;
4398     def targetProperties = project.ext[t.upper]
4399 
4400     def platformPrefix = targetProperties.platformPrefix
4401     def bundledSdkDirName = &quot;${platformPrefix}modular-sdk&quot;
4402     def bundledSdkDir = &quot;${rootProject.buildDir}/${bundledSdkDirName}&quot;
4403     def modulesDir = &quot;${bundledSdkDir}/modules&quot;
4404     def modulesCmdsDir = &quot;${bundledSdkDir}/modules_cmds&quot;
4405     def modulesLibsDir = &quot;${bundledSdkDir}/modules_libs&quot;
4406     def modulesSrcDir = &quot;${bundledSdkDir}/modules_src&quot;
4407     def modulesConfDir = &quot;${bundledSdkDir}/modules_conf&quot;
4408     def modulesLegalDir = &quot;${bundledSdkDir}/modules_legal&quot;
4409     def modulesMakeDir = &quot;${bundledSdkDir}/make&quot;
4410 
4411     final File runArgsFile = file(&quot;${rootProject.buildDir}/${RUNARGSFILE}&quot;)
4412     final File compileArgsFile = file(&quot;${rootProject.buildDir}/${COMPILEARGSFILE}&quot;)
4413 
4414     project.files(runArgsFile);
4415 
4416     def buildModulesTask = task(&quot;buildModules$t.capital&quot;, group: &quot;Build&quot;) {
4417         // BUNDLED SDK
4418 
4419         // Copy dependencies/*/module-info.java.extra
4420         // merging as needed, removing duplicates
4421         // only lines with &#39;exports&#39; will be copied
4422         def dependencyRoots = moduleDependencies
4423         if (rootProject.hasProperty(&quot;closedModuleDepedencies&quot;)) {
4424             dependencyRoots = [dependencyRoots, closedModuleDepedencies].flatten()
4425         }
4426 
4427         // Create the inputs/outputs list first to support UP-TO-DATE
4428         ArrayList outputNames = new ArrayList()
4429         dependencyRoots.each { root -&gt;
4430             FileTree ft = fileTree(root).include(&#39;**/*.extra&#39;)
4431             ft.each() { e-&gt;
4432                 inputs.file(e)
4433 
4434                 String usename = e.path
4435                 String filePath = e.getAbsolutePath()
4436                 String folderPath = root.getAbsolutePath()
4437                 if (filePath.startsWith(folderPath)) {
4438                     usename = filePath.substring(folderPath.length() + 1);
4439                 }
4440                 if (! outputNames.contains(usename) ) {
4441                     outputNames.add(usename)
4442                 }
4443             }
4444         }
4445 
4446         outputNames.each() { e-&gt;
4447                 File f = new File(modulesSrcDir, e)
4448                 outputs.file(f)
4449         }
4450 
4451         def outputPolicyDir = &quot;${modulesConfDir}/java.base/security&quot;
4452         def outputPolicyFile = file(&quot;${outputPolicyDir}/java.policy.extra&quot;)
4453 
4454         outputs.file(outputPolicyFile)
4455         moduleProjList.each { project -&gt;
4456             def policyDir = &quot;${project.projectDir}/src/main/conf/security&quot;
4457             def policyFile = file(&quot;${policyDir}/java.policy&quot;)
4458             if (policyFile.exists()) {
4459                 inputs.file(policyFile)
4460             }
4461         }
4462 
4463         doLast {
4464             Map extras = [:]
4465 
4466             dependencyRoots.each { root -&gt;
4467                 FileTree ft = fileTree(root).include(&#39;**/*.extra&#39;)
4468                 ft.each() { e-&gt;
4469                     String usename = e.path
4470                     String filePath = e.getAbsolutePath()
4471                     String folderPath = root.getAbsolutePath()
4472                     if (filePath.startsWith(folderPath)) {
4473                         usename = filePath.substring(folderPath.length() + 1);
4474                     }
4475                     if (extras.containsKey(usename)) {
4476                         List&lt;String&gt; lines = extras.get(usename)
4477                         e.eachLine { line -&gt;
4478                             line = line.trim()
4479                             if (line.length() &gt; 1 &amp;&amp; Character.isLetter(line.charAt(0))) {
4480                                 lines &lt;&lt; line
4481                             }
4482                         }
4483 
4484                     } else {
4485                         List&lt;String&gt; lines = []
4486                         e.eachLine { line -&gt;
4487                             line = line.trim()
4488                             if (line.length() &gt; 1 &amp;&amp; Character.isLetter(line.charAt(0))) {
4489                                 lines &lt;&lt; line
4490                             }
4491                         }
4492                         extras.put(usename,lines)
4493                     }
4494                 }
4495             }
4496             extras.keySet().each() { e-&gt;
4497                 File f = new File(modulesSrcDir, e)
4498                 f.getParentFile().mkdirs()
4499                 f.delete()
4500 
4501                 extras.get(e).unique().each() { l-&gt;
4502                     f &lt;&lt; l
4503                     f &lt;&lt; &quot;\n&quot;
4504                 }
4505             }
4506 
4507             // concatecate java.policy files into a single file
4508             //
4509             mkdir outputPolicyDir
4510             outputPolicyFile.delete()
4511             moduleProjList.each { project -&gt;
4512                 def policyDir = &quot;${project.projectDir}/src/main/conf/security&quot;
4513                 def policyFile = file(&quot;${policyDir}/java.policy&quot;)
4514                 if (policyFile.exists()) outputPolicyFile &lt;&lt; policyFile.text
4515             }
4516         }
4517     }
4518     buildModules.dependsOn(buildModulesTask)
4519 
4520     // BUNDLED SDK
4521     moduleProjList.each { project -&gt;
4522         // Copy classes, bin, and lib directories
4523 
4524         def moduleName = project.ext.moduleName
4525         def buildDir = project.buildDir
4526 
4527         def srcClassesDir = &quot;${buildDir}/${platformPrefix}module-classes&quot;
4528         def dstClassesDir = &quot;${modulesDir}/${moduleName}&quot;
4529         def copyClassFilesTask = project.task(&quot;copyClassFiles$t.capital&quot;, type: Copy, dependsOn: project.assemble) {
4530             from srcClassesDir
4531             into dstClassesDir
4532             exclude(&quot;module-info.class&quot;)
4533         }
4534 
4535         def srcCmdsDir = &quot;${buildDir}/${platformPrefix}module-bin&quot;
4536         def dstCmdsDir = &quot;${modulesCmdsDir}/${moduleName}&quot;
4537         def copyBinFilesTask = project.task(&quot;copyBinFiles$t.capital&quot;, type: Copy, dependsOn: copyClassFilesTask) {
4538             from srcCmdsDir
4539             into dstCmdsDir
4540         }
4541 
4542         def srcLibsDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
4543         def dstLibsDir = &quot;${modulesLibsDir}/${moduleName}&quot;
4544         def copyLibFilesTask = project.task(&quot;copyLibFiles$t.capital&quot;, type: Copy, dependsOn: copyBinFilesTask) {
4545             from srcLibsDir
4546             into dstLibsDir
4547         }
4548 
4549         // Copy module sources
4550         // FIXME: javafx.swt sources?
4551         def copySources = project.hasProperty(&quot;includeSources&quot;) &amp;&amp; project.includeSources
4552         def copySourceFilesTask = project.task(&quot;copySourceFiles$t.capital&quot;, type: Copy, dependsOn: copyLibFilesTask) {
4553             if (copySources) {
4554                 from &quot;${project.projectDir}/src/main/java&quot;
4555                 if (project.name.equals(&quot;base&quot;)) {
4556                     from &quot;${project.projectDir}/build/gensrc/java&quot;
4557                 }
4558                 if (project.name.equals(&quot;web&quot;)) {
4559                     from &quot;${project.projectDir}/src/main/native/Source/WebCore/bindings/java/dom3/java&quot;
4560                 }
4561             } else {
4562                 from &quot;${project.projectDir}/src/main/java/module-info.java&quot;
4563             }
4564             into &quot;${modulesSrcDir}/${moduleName}&quot;
4565             include &quot;**/*.java&quot;
4566 
4567             if (project.hasProperty(&quot;sourceFilter&quot;)) {
4568                 filter(project.sourceFilter)
4569             }
4570         }
4571 
4572         // Copy .html and other files needed for doc bundles
4573         def copyDocFiles = project.task(&quot;copyDocFiles$t.capital&quot;, type: Copy, dependsOn: copySourceFilesTask) {
4574             if (copySources) {
4575                 from(&quot;${project.projectDir}/src/main/docs&quot;) {
4576                     include &quot;**/*.html&quot;
4577                     filter { line-&gt;
4578                         line = line.replace(&quot;@FXVERSION@&quot;, RELEASE_VERSION)
4579                     }
4580                 }
4581                 from(&quot;${project.projectDir}/src/main/docs&quot;) {
4582                     exclude &quot;**/*.html&quot;
4583                 }
4584                 from(&quot;${project.projectDir}/src/main/java&quot;) {
4585                     exclude &quot;**/*.java&quot;
4586                 }
4587 
4588                 into &quot;${modulesSrcDir}/${moduleName}&quot;
4589             }
4590         }
4591 
4592         // Copy make/build.properties
4593         def srcMakeDir = &quot;${project.projectDir}/make&quot;
4594         def dstMakeDir = &quot;${modulesMakeDir}/${moduleName}&quot;
4595         def copyBuildPropertiesTask = project.task(&quot;copyBuildProperties$t.capital&quot;, type: Copy, dependsOn: copyDocFiles) {
4596             from srcMakeDir
4597             into dstMakeDir
4598         }
4599 
4600         // Copy legal files
4601         def srcLegalDir = &quot;${project.projectDir}/src/main/legal&quot;
4602         def dstLegalDir = &quot;${modulesLegalDir}/${moduleName}&quot;
4603         def copyLegalTask = project.task(&quot;copyLegal$t.capital&quot;, type: Copy, dependsOn: copyBuildPropertiesTask) {
4604             from srcLegalDir
4605             into dstLegalDir
4606 
4607             // Exclude ANGLE since we (currently) do not use it
4608             exclude(&quot;angle.md&quot;)
4609         }
4610 
4611         buildModulesTask.dependsOn(
4612             copyClassFilesTask,
4613             copyLibFilesTask,
4614             copySourceFilesTask,
4615             copyDocFiles,
4616             copyBuildPropertiesTask,
4617             copyLegalTask)
4618     }
4619 
4620     // ============================================================
4621 
4622     def standaloneSdkDirName = &quot;${platformPrefix}sdk&quot;
4623     def standaloneSdkDir = &quot;${rootProject.buildDir}/${standaloneSdkDirName}&quot;
4624     def standaloneLibDir = &quot;${standaloneSdkDir}/lib&quot;
4625     def libDest=targetProperties.libDest
4626     def standaloneNativeDir = &quot;${standaloneSdkDir}/${libDest}&quot;
4627     def standaloneLegalDir = &quot;${standaloneSdkDir}/legal&quot;
4628     def standaloneSrcZipName = &quot;src.zip&quot;
4629 
4630     // STANDALONE SDK
4631     moduleProjList.each { project -&gt;
4632         // Copy classes, bin, and lib directories
4633 
4634         def moduleName = project.ext.moduleName
4635         def buildDir = project.buildDir
4636 
4637         // Create modular jars
4638         def srcClassesDir = &quot;${buildDir}/${platformPrefix}module-classes&quot;
4639         def srcLibsDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
4640         def dstModularJarDir = &quot;${standaloneLibDir}&quot;
4641         def modularJarName = &quot;${moduleName}.jar&quot;
4642         def modularJarTask = project.task(&quot;modularJarStandalone$t.capital&quot;, type: Jar, dependsOn: project.assemble) {
4643             destinationDir = file(&quot;${dstModularJarDir}&quot;)
4644             archiveName = modularJarName
4645             includeEmptyDirs = false
4646             from srcClassesDir
4647         }
4648 
4649         // Copy native libraries
4650         def srcNativeDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
4651         def dstNativeDir = &quot;${standaloneNativeDir}&quot;
4652         def copyNativeFilesTask = project.task(&quot;copyNativeFilesStandalone$t.capital&quot;, type: Copy, dependsOn: modularJarTask) {
4653             from srcNativeDir
4654             into dstNativeDir
4655             include(&quot;*.dll&quot;)
4656         }
4657 
4658         // Copy other lib files
4659         def dstLibsDir = &quot;${standaloneLibDir}&quot;
4660         def copyLibFilesTask = project.task(&quot;copyLibFilesStandalone$t.capital&quot;, type: Copy, dependsOn: copyNativeFilesTask) {
4661             from srcLibsDir
4662             into dstLibsDir
4663             exclude(&quot;*.dll&quot;)
4664         }
4665 
4666         // Copy legal files
4667         def licenseFiles = [ &quot;ADDITIONAL_LICENSE_INFO&quot;, &quot;ASSEMBLY_EXCEPTION&quot;, &quot;LICENSE&quot; ]
4668         def srcLegalDir = &quot;${project.projectDir}/src/main/legal&quot;
4669         def dstLegalDir = &quot;${standaloneLegalDir}/${moduleName}&quot;
4670         def copyLegalTask = project.task(&quot;copyLegalStandalone$t.capital&quot;, type: Copy, dependsOn: copyLibFilesTask) {
4671 
4672             def rtDir = rootProject.file(&#39;.&#39;)
4673             licenseFiles.each { lFile -&gt;
4674                 from &quot;${rtDir}/${lFile}&quot;
4675             }
4676 
4677             from srcLegalDir
4678 
4679             into dstLegalDir
4680 
4681             // Exclude ANGLE since we (currently) do not use it
4682             exclude(&quot;angle.md&quot;)
4683         }
4684 
4685         buildModulesTask.dependsOn(
4686             modularJarTask,
4687             copyNativeFilesTask,
4688             copyLibFilesTask,
4689             copyLegalTask)
4690     }
4691 
4692     // Zip module sources for standalone SDK
4693     //
4694     // NOTE: the input is taken from the modular-sdk/modules_src dir
4695     // so that we don&#39;t have to duplicate the logic and create another
4696     // temporary directory. This is somewhat inelegant, since the bundled sdk
4697     // and the standalone sdk should be independent of one another, but seems
4698     // better than the alternatives.
4699     def zipSourceFilesTask = project.task(&quot;zipSourceFilesStandalone$t.capital&quot;, type: Zip, dependsOn: buildModulesTask) {
4700         destinationDir = file(&quot;${standaloneLibDir}&quot;)
4701         archiveName = standaloneSrcZipName
4702         includeEmptyDirs = false
4703         from modulesSrcDir
4704         include &quot;**/*.java&quot;
4705     }
4706     buildModules.dependsOn(zipSourceFilesTask)
4707 
4708     // ============================================================
4709 
4710     // Maven Publications
4711     def publicationDirName = &quot;${platformPrefix}publications&quot;
4712     def publicationDir = &quot;${rootProject.buildDir}/${publicationDirName}&quot;
4713 
4714     moduleProjList.each { project -&gt; 
4715         // Create publications to be uploaded 
4716 
4717         def moduleName = project.ext.moduleName
4718         def buildDir = project.buildDir
4719 
4720         def dstModularJarDir=&quot;${publicationDir}&quot;
4721         def srcClassesDir = &quot;${buildDir}/${platformPrefix}module-classes&quot;
4722         def srcLibsDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
4723 
4724         def modularEmptyPublicationJarName = &quot;${moduleName}.jar&quot;
4725         def modularEmptyPublicationJarTask = project.task(&quot;moduleEmptyPublicationJar${t.capital}&quot;, type: Jar) {
4726             destinationDir = file(&quot;${dstModularJarDir}&quot;)
4727             archiveName = modularEmptyPublicationJarName
4728             manifest {
4729                 attributes(
4730                     &#39;Automatic-Module-Name&#39;:&quot;${moduleName}Empty&quot;
4731                 )
4732             }
4733         }
4734 
4735         def modularPublicationJarName = &quot;${moduleName}-${t.name}.jar&quot;
4736         def modularPublicationJarTask = project.task(&quot;modularPublicationJar${t.capital}&quot;, type: Jar, dependsOn: modularEmptyPublicationJarTask) {
4737             destinationDir = file(&quot;${dstModularJarDir}&quot;)
4738             archiveName = modularPublicationJarName
4739             from srcLibsDir
4740             from srcClassesDir
4741         }
4742 
4743         buildModulesTask.dependsOn(modularPublicationJarTask)
4744 
4745     }
4746     // ============================================================
4747 
4748     def buildRunArgsTask = task(&quot;buildRunArgs$t.capital&quot;,
4749             group: &quot;Build&quot;, dependsOn: buildModulesTask) {
4750         outputs.file(runArgsFile);
4751         inputs.file(EXTRAADDEXPORTS);
4752         doLast() {
4753             List&lt;String&gt;modpath = []
4754             List&lt;String&gt;modnames = []
4755 
4756             moduleProjList.each { project -&gt;
4757                 def moduleName = project.ext.moduleName
4758                 def dstModuleDir = cygpath(&quot;${modulesDir}/${moduleName}&quot;)
4759                 if (HAS_JAVAFX_MODULES) {
4760                     modpath &lt;&lt;  &quot;${moduleName}=${dstModuleDir}&quot;
4761                 } else {
4762                     modnames &lt;&lt; moduleName
4763                 }
4764             }
4765 
4766             if (HAS_JAVAFX_MODULES) {
4767                 writeRunArgsFile(runArgsFile, computeLibraryPath(true), modpath, null)
4768                 writeRunArgsFile(compileArgsFile, null, modpath, null)
4769 
4770                 if (rootProject.hasProperty(&quot;EXTRA_ADDEXPORTS_STRING&quot;)) {
4771                     runArgsFile &lt;&lt; EXTRA_ADDEXPORTS_STRING
4772                     compileArgsFile &lt;&lt; EXTRA_ADDEXPORTS_STRING
4773                 }
4774             } else {
4775                 modpath = [ cygpath(&quot;${standaloneLibDir}&quot;) ]
4776                 writeRunArgsFile(runArgsFile, null, modpath, modnames)
4777                 writeRunArgsFile(compileArgsFile, null, modpath, modnames)
4778             }
4779         }
4780     }
4781     buildModules.dependsOn(buildRunArgsTask)
4782 
4783     def isWindows = IS_WINDOWS &amp;&amp; t.name == &quot;win&quot;;
4784     def isMac = IS_MAC &amp;&amp; t.name == &quot;mac&quot;;
4785 
4786     // Create layout for modular classes
4787     moduleProjList.each { project -&gt;
4788         def buildModuleClassesTask = project.task(&quot;buildModule$t.capital&quot;, group: &quot;Build&quot;, type: Copy) {
4789             dependsOn(project.assemble)
4790             def buildDir = project.buildDir
4791             def sourceBuildDirs = [
4792                 &quot;${buildDir}/classes/java/main/${project.moduleName}&quot;,
4793             ]
4794 
4795             def moduleClassesDir = &quot;$buildDir/${platformPrefix}module-classes&quot;
4796                 includeEmptyDirs = false
4797                 sourceBuildDirs.each { d -&gt;
4798                     from d
4799                 }
4800                 into moduleClassesDir
4801 
4802                 // Exclude obsolete, experimental, or non-shipping code
4803                 exclude(&quot;version.rc&quot;)
4804                 exclude(&quot;com/sun/glass/ui/swt&quot;)
4805                 exclude(&quot;com/sun/javafx/tools/ant&quot;)
4806                 exclude(&quot;com/javafx/main&quot;)
4807                 exclude(&quot;com/sun/javafx/webkit/drt&quot;)
4808                 if (!IS_INCLUDE_NULL3D) {
4809                     exclude (&quot;com/sun/prism/null3d&quot;)
4810                 }
4811                 if (!IS_INCLUDE_ES2) {
4812                        exclude(&quot;com/sun/prism/es2&quot;,
4813                                &quot;com/sun/scenario/effect/impl/es2&quot;)
4814                 }
4815 
4816                 // Exclude platform-specific classes for other platforms
4817 
4818                 if (!isMac) {
4819                     exclude (&quot;com/sun/media/jfxmediaimpl/platform/osx&quot;,
4820                              &quot;com/sun/prism/es2/MacGL*&quot;,
4821                              &quot;com/sun/glass/events/mac&quot;,
4822                              &quot;com/sun/glass/ui/mac&quot;,
4823                              )
4824                 }
4825 
4826                 if (!isWindows) {
4827                     exclude (&quot;**/*.hlsl&quot;,
4828                              &quot;com/sun/glass/ui/win&quot;,
4829                              &quot;com/sun/prism/d3d&quot;,
4830                              &quot;com/sun/prism/es2/WinGL*&quot;,
4831                              &quot;com/sun/scenario/effect/impl/hw/d3d&quot;
4832                              )
4833                 }
4834 
4835                 if (!targetProperties.includeGTK) { //usually IS_LINUX
4836                     exclude (
4837                              &quot;com/sun/glass/ui/gtk&quot;,
4838                              &quot;com/sun/prism/es2/EGL*&quot;,
4839                              &quot;com/sun/prism/es2/X11GL*&quot;
4840                              )
4841                 }
4842 
4843                 if (!targetProperties.includeEGL) {
4844                     exclude (&quot;com/sun/prism/es2/EGL*&quot;)
4845                 }
4846 
4847                 if (!targetProperties.includeMonocle) {
4848                     exclude (&quot;com/sun/glass/ui/monocle&quot;)
4849                     exclude(&quot;com/sun/prism/es2/Monocle*&quot;)
4850                 }
4851 
4852                 if (t.name != &#39;ios&#39;) {
4853                     exclude (&quot;com/sun/media/jfxmediaimpl/platform/ios&quot;,
4854                              &quot;com/sun/glass/ui/ios&quot;,
4855                              &quot;com/sun/prism/es2/IOS*&quot;
4856                              )
4857                 }
4858 
4859                 if (t.name != &#39;android&#39; &amp;&amp; t.name != &#39;dalvik&#39;) {
4860                     exclude (&quot;com/sun/glass/ui/android&quot;)
4861                 }
4862 
4863                 // Filter out other platform-specific classes
4864                 if (targetProperties.containsKey(&#39;jfxrtJarExcludes&#39;)) {
4865                     exclude(targetProperties.jfxrtJarExcludes)
4866                 }
4867 
4868                 /* FIXME: JIGSAW -- handle this in the module itself
4869                 String webbld = project(&quot;:web&quot;).buildDir.path
4870                 String ctrlbld = project(&quot;:controls&quot;).buildDir.path
4871                 if (t.name == &#39;android&#39;) {
4872                     from (&quot;${webbld}/classes/android&quot;,
4873                           &quot;${webbld}/resources/android&quot;,
4874                           &quot;${ctrlbld}/classes/android&quot;,
4875                           &quot;${ctrlbld}/resources/android&quot;)
4876                 } else if (t.name == &#39;ios&#39;) {
4877                     from (&quot;${webbld}/classes/ios&quot;,
4878                           &quot;${webbld}/resources/ios&quot;)
4879                 } else {
4880                     from (&quot;${webbld}/classes/java/main&quot;)
4881                 }
4882                 */
4883         }
4884         buildModulesTask.dependsOn(buildModuleClassesTask)
4885     }
4886 
4887     def buildModuleLibsTask = task(&quot;buildModuleLibs$t.capital&quot;) {
4888         group = &quot;Basic&quot;
4889 
4890         def baseProject = project(&quot;:base&quot;);
4891 
4892         def graphicsProject = project(&quot;:graphics&quot;);
4893 
4894         def mediaProject = project(&quot;:media&quot;);
4895 
4896         def webProject = project(&quot;:web&quot;);
4897         dependsOn(webProject.assemble)
4898 
4899         def swtProject = project(&quot;:swt&quot;);
4900 
4901         def library = targetProperties.library
4902 
4903         def useLipo = targetProperties.containsKey(&#39;useLipo&#39;) ? targetProperties.useLipo : false
4904         def modLibDest = targetProperties.modLibDest
4905         def moduleNativeDirName = &quot;${platformPrefix}module-$modLibDest&quot;
4906 
4907         def buildModuleBaseTask = task(&quot;buildModuleBase$t.capital&quot;, dependsOn: baseProject.assemble) {
4908             group = &quot;Basic&quot;
4909             description = &quot;creates javafx.base property files&quot;
4910 
4911             def moduleLibDir = &quot;${baseProject.buildDir}/${platformPrefix}module-lib&quot;
4912             final File javafxProperties = file(&quot;${moduleLibDir}/javafx.properties&quot;)
4913             outputs.file(javafxProperties)
4914 
4915             if (targetProperties.containsKey(&quot;javafxPlatformProperties&quot;)) {
4916                 final File javafxPlatformProperties = file(&quot;${moduleLibDir}/javafx.platform.properties&quot;)
4917                 outputs.file(javafxPlatformProperties)
4918             }
4919 
4920             doLast {
4921                 mkdir moduleLibDir
4922 
4923                 javafxProperties.delete()
4924                 javafxProperties &lt;&lt; &quot;javafx.version=$RELEASE_VERSION_SHORT&quot;;
4925                 javafxProperties &lt;&lt; &quot;\n&quot;
4926                 javafxProperties &lt;&lt; &quot;javafx.runtime.version=$RELEASE_VERSION_LONG&quot;;
4927                 javafxProperties &lt;&lt; &quot;\n&quot;
4928                 javafxProperties &lt;&lt; &quot;javafx.runtime.build=$PROMOTED_BUILD_NUMBER&quot;;
4929                 javafxProperties &lt;&lt; &quot;\n&quot;
4930                 // Include any properties that have been defined (most likely in
4931                 // one of the various platform gradle files)
4932                 if (targetProperties.containsKey(&quot;javafxProperties&quot;)) {
4933                     javafxProperties &lt;&lt; targetProperties.javafxProperties
4934                     javafxProperties &lt;&lt; &quot;\n&quot;
4935                 }
4936 
4937                 // Embedded builds define this file as well
4938                 if (targetProperties.containsKey(&quot;javafxPlatformProperties&quot;)) {
4939                     final File javafxPlatformProperties = file(&quot;${moduleLibDir}/javafx.platform.properties&quot;)
4940                     javafxPlatformProperties.delete()
4941                     javafxPlatformProperties &lt;&lt; targetProperties.javafxPlatformProperties
4942                     javafxPlatformProperties &lt;&lt; &quot;\n&quot;
4943                 }
4944             }
4945         }
4946 
4947         def buildModuleGraphicsTask = task(&quot;buildModuleGraphics$t.capital&quot;, type: Copy, dependsOn: graphicsProject.assemble) {
4948             group = &quot;Basic&quot;
4949             description = &quot;copies javafx.graphics native libraries&quot;
4950 
4951             into &quot;${graphicsProject.buildDir}/${moduleNativeDirName}&quot;
4952 
4953             from(&quot;${graphicsProject.buildDir}/libs/jsl-decora/${t.name}/${library(targetProperties.decora.lib)}&quot;)
4954             def libs = [&#39;font&#39;, &#39;prism&#39;, &#39;prismSW&#39;, &#39;glass&#39;, &#39;iio&#39;]
4955             if (IS_INCLUDE_ES2) {
4956                 libs += [&#39;prismES2&#39;];
4957             }
4958             if (IS_COMPILE_PANGO) {
4959                 libs += [&#39;fontFreetype&#39;, &#39;fontPango&#39;];
4960             }
4961             libs.each { lib -&gt;
4962                 def variants = targetProperties[lib].containsKey(&#39;variants&#39;) &amp;&amp; !useLipo ? targetProperties[lib].variants : [null]
4963                 variants.each { variant -&gt;
4964                     def variantProperties = variant ? targetProperties[lib][variant] : targetProperties[lib]
4965                     from (&quot;${graphicsProject.buildDir}/libs/$lib/$t.name/${library(variantProperties.lib)}&quot;)
4966                 }
4967             }
4968             if (IS_WINDOWS) {
4969                 from (&quot;${graphicsProject.buildDir}/libs/prismD3D/${t.name}/${library(targetProperties.prismD3D.lib)}&quot;);
4970                 targetProperties.VS2017DLLs.each { vslib -&gt;
4971                     from (&quot;$vslib&quot;);
4972                 }
4973                 targetProperties.WinSDKDLLs.each { winsdklib -&gt;
4974                     from (&quot;$winsdklib&quot;);
4975                 }
4976             }
4977         }
4978 
4979         def buildModuleMediaTask = task(&quot;buildModuleMedia$t.capital&quot;, type: Copy, dependsOn: [mediaProject.assemble, prepOpenJfxStubs]) {
4980             group = &quot;Basic&quot;
4981             description = &quot;copies javafx.media native libraries&quot;
4982 
4983             into &quot;${mediaProject.buildDir}/${moduleNativeDirName}&quot;
4984 
4985             def mediaBuildType = project(&quot;:media&quot;).ext.buildType
4986             if (IS_COMPILE_MEDIA) {
4987                 [ &quot;fxplugins&quot;, &quot;gstreamer-lite&quot;, &quot;jfxmedia&quot; ].each { name -&gt;
4988                     from (&quot;${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}/${library(name)}&quot;) }
4989 
4990                 if (t.name == &quot;mac&quot;) {
4991                     // OSX media natives
4992                     [ &quot;jfxmedia_qtkit&quot;, &quot;jfxmedia_avf&quot;, &quot;glib-lite&quot; ].each { name -&gt;
4993                         from (&quot;${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}/${library(name)}&quot;) }
4994                 } else if (t.name == &quot;linux&quot;) {
4995                     from(&quot;${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}&quot;) { include &quot;libavplugin*.so&quot; }
4996                 } else from (&quot;${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}/${library(&quot;glib-lite&quot;)}&quot;)
4997             } else {
4998                 if (t.name != &quot;android&quot;  &amp;&amp; t.name != &quot;dalvik&quot; ) {
4999                     [ &quot;fxplugins&quot;, &quot;gstreamer-lite&quot;, &quot;jfxmedia&quot; ].each { name -&gt;
5000                         from (&quot;$MEDIA_STUB/${library(name)}&quot;) }
5001                 }
5002 
5003                 if (t.name == &quot;mac&quot;) {
5004                     // copy libjfxmedia_{avf,qtkit}.dylib if they exist
5005                     [ &quot;jfxmedia_qtkit&quot;, &quot;jfxmedia_avf&quot;, &quot;glib-lite&quot; ].each { name -&gt;
5006                         from (&quot;$MEDIA_STUB/${library(name)}&quot;) }
5007                 } else if (t.name == &quot;linux&quot;) {
5008                     from(MEDIA_STUB) { include &quot;libavplugin*.so&quot; }
5009                 }
5010                 else if (t.name != &quot;android&quot;  &amp;&amp; t.name != &quot;dalvik&quot; ) {
5011                     from (&quot;$MEDIA_STUB/${library(&quot;glib-lite&quot;)}&quot;)
5012                 }
5013             }
5014         }
5015 
5016         def buildModuleWeb = task(&quot;buildModuleWeb$t.capital&quot;, type: Copy, dependsOn: [webProject.assemble, prepOpenJfxStubs]) {
5017             group = &quot;Basic&quot;
5018             description = &quot;copies javafx.web native libraries&quot;
5019 
5020             into &quot;${webProject.buildDir}/${moduleNativeDirName}&quot;
5021 
5022             if (IS_COMPILE_WEBKIT) {
5023                 from (&quot;${webProject.buildDir}/libs/${t.name}/${library(&#39;jfxwebkit&#39;)}&quot;)
5024             } else {
5025                 if (t.name != &quot;android&quot; &amp;&amp; t.name != &quot;ios&quot; &amp;&amp; t.name != &quot;dalvik&quot;) {
5026                     from (&quot;$WEB_STUB/${library(&#39;jfxwebkit&#39;)}&quot;)
5027                 }
5028             }
5029         }
5030 
5031         def buildModuleSWT = task(&quot;buildModuleSWT$t.capital&quot;, type: Copy) {
5032             group = &quot;Basic&quot;
5033             description = &quot;copies SWT JAR&quot;
5034 
5035             // FIXME: the following is a hack to workaround the fact that there
5036             // is no way to deliver javafx-swt.jar other than in one of the
5037             // existing runtime modules.
5038 
5039             dependsOn(buildModuleGraphicsTask) // we copy to the graphics module
5040 
5041             if (COMPILE_SWT) {
5042                 def javafxSwtIndexTask = tasks.getByName(&quot;javafxSwtIndex${t.capital}&quot;);
5043                 dependsOn(javafxSwtIndexTask)
5044                 //enabled = COMPILE_SWT
5045             }
5046 
5047             // Copy javafx-swt.jar to the javafx-graphics module lib dir
5048             from &quot;${swtProject.buildDir}/libs/javafx-swt.jar&quot;
5049             into &quot;${graphicsProject.buildDir}/${platformPrefix}module-lib&quot;
5050         }
5051 
5052         dependsOn(
5053             buildModuleBaseTask,
5054             buildModuleGraphicsTask,
5055             buildModuleMediaTask,
5056             buildModuleWeb,
5057             buildModuleSWT,
5058             )
5059     }
5060     buildModulesTask.dependsOn(buildModuleLibsTask)
5061 
5062     def zipTask = project.task(&quot;buildModuleZip$t.capital&quot;, type: Zip, group: &quot;Build&quot;,
5063             dependsOn: buildModulesTask ) {
5064 
5065         // FIXME: JIGSAW -- this should be moved to a sub-directory so we can keep the same name
5066         def jfxBundle = &quot;${platformPrefix}javafx-exports.zip&quot;
5067 
5068         doFirst() {
5069             file(&quot;${rootProject.buildDir}/${jfxBundle}&quot;).delete()
5070         }
5071 
5072         archiveName = jfxBundle
5073         destinationDir = file(&quot;${rootProject.buildDir}&quot;)
5074         includeEmptyDirs = false
5075         from &quot;${bundledSdkDir}&quot;
5076     }
5077     jdkZip.dependsOn(zipTask)
5078 
5079     Task testArgFiles = task(&quot;createTestArgfiles${t.capital}&quot;) {
5080 
5081         File testRunArgsFile = new File(rootProject.buildDir, TESTRUNARGSFILE)
5082         //test (shimed) version
5083         File testCompileArgsFile = new File(rootProject.buildDir, TESTCOMPILEARGSFILE)
5084         // And a test java.policy file
5085         File testJavaPolicyFile = new File(rootProject.buildDir, TESTJAVAPOLICYFILE)
5086         // and the non-test version to go with run.args
5087         File runJavaPolicyFile = new File(rootProject.buildDir, RUNJAVAPOLICYFILE);
5088 
5089         outputs.file(testRunArgsFile)
5090         outputs.file(testCompileArgsFile)
5091         outputs.file(testJavaPolicyFile)
5092         outputs.file(runJavaPolicyFile)
5093         inputs.file(EXTRAADDEXPORTS);
5094 
5095         doLast() {
5096             rootProject.buildDir.mkdir()
5097 
5098             List&lt;String&gt; projNames = []
5099             moduleProjList.each { project -&gt;
5100                 projNames &lt;&lt; project.name
5101             }
5102 
5103             // And the test (shimed) variation...
5104 
5105             testRunArgsFile.delete()
5106             testCompileArgsFile.delete()
5107 
5108             testJavaPolicyFile.delete()
5109             runJavaPolicyFile.delete()
5110 
5111             List&lt;String&gt; modpath = []
5112 
5113             if (HAS_JAVAFX_MODULES) {
5114                 moduleProjList.each { project -&gt;
5115                     if (project.hasProperty(&quot;moduleName&quot;) &amp;&amp; project.buildModule) {
5116                         File dir;
5117                         if (project.sourceSets.hasProperty(&#39;shims&#39;)) {
5118                            dir = new File(rootProject.buildDir, &quot;shims/${project.ext.moduleName}&quot;)
5119                         } else {
5120                            dir = new File(rootProject.buildDir, &quot;modular-sdk/modules/${project.ext.moduleName}&quot;)
5121                         }
5122 
5123                         def dstModuleDir = cygpath(dir.path)
5124                         modpath &lt;&lt; &quot;${project.ext.moduleName}=${dstModuleDir}&quot;
5125 
5126                         String themod = dir.toURI()
5127                         testJavaPolicyFile &lt;&lt;  &quot;grant codeBase \&quot;${themod}\&quot; {\n&quot; +
5128                         &quot;    permission java.security.AllPermission;\n&quot; +
5129                         &quot;};\n&quot;
5130 
5131                         dir = new File(rootProject.buildDir, &quot;modular-sdk/modules/${project.ext.moduleName}&quot;)
5132                         themod = dir.toURI()
5133                         runJavaPolicyFile &lt;&lt;  &quot;grant codeBase \&quot;${themod}\&quot; {\n&quot; +
5134                         &quot;    permission java.security.AllPermission;\n&quot; +
5135                         &quot;};\n&quot;
5136                     }
5137                 }
5138 
5139                 writeRunArgsFile(testCompileArgsFile, null, modpath, null)
5140                 writeRunArgsFile(testRunArgsFile, computeLibraryPath(true), modpath, null)
5141 
5142                 if (rootProject.hasProperty(&quot;EXTRA_ADDEXPORTS_STRING&quot;)) {
5143                     testCompileArgsFile &lt;&lt; EXTRA_ADDEXPORTS_STRING
5144                     testRunArgsFile &lt;&lt; EXTRA_ADDEXPORTS_STRING
5145                 }
5146             } else  {
5147                 def modnames = []
5148                 moduleProjList.each { project -&gt;
5149                     if (project.hasProperty(&quot;moduleName&quot;) &amp;&amp; project.buildModule) {
5150                         modnames &lt;&lt; project.ext.moduleName
5151                         File dir;
5152                         if (project.sourceSets.hasProperty(&#39;shims&#39;)) {
5153                            dir = new File(rootProject.buildDir, &quot;shims/${project.ext.moduleName}&quot;)
5154                         } else {
5155                            dir = new File(rootProject.buildDir, &quot;sdk/lib/${project.ext.moduleName}.jar&quot;)
5156                         }
5157 
5158                         def dstModuleDir = cygpath(dir.path)
5159                         modpath &lt;&lt; &quot;${dstModuleDir}&quot;
5160 
5161                         String themod = dir.toURI()
5162                         testJavaPolicyFile &lt;&lt;  &quot;grant codeBase \&quot;${themod}\&quot; {\n&quot; +
5163                         &quot;    permission java.security.AllPermission;\n&quot; +
5164                         &quot;};\n&quot;
5165 
5166                         dir = new File(rootProject.buildDir, &quot;sdk/lib/${project.ext.moduleName}.jar&quot;)
5167                         themod = dir.toURI()
5168                         runJavaPolicyFile &lt;&lt;  &quot;grant codeBase \&quot;${themod}\&quot; {\n&quot; +
5169                         &quot;    permission java.security.AllPermission;\n&quot; +
5170                         &quot;};\n&quot;
5171                     }
5172                 }
5173 
5174                 writeRunArgsFile(testCompileArgsFile, null, modpath, modnames)
5175                 writeRunArgsFile(testRunArgsFile, computeLibraryPath(true), modpath, modnames)
5176 
5177             }
5178         }
5179     }
5180     sdk.dependsOn(testArgFiles)
5181     createTestArgfiles.dependsOn(testArgFiles)
5182 
5183     def sdkTask = tasks.getByName(&quot;sdk${t.capital}&quot;);
5184     sdkTask.dependsOn(buildModulesTask)
5185 }
5186 sdk.dependsOn(buildModules)
5187 
5188 // Build the jmod for each module for the standalone SDK only.
5189 compileTargets { t -&gt;
5190     if (!HAS_JAVAFX_MODULES) {
5191         def targetProperties = project.ext[t.upper]
5192 
5193         def platformPrefix = targetProperties.platformPrefix
5194         def jmodsDirName = &quot;${platformPrefix}jmods&quot;
5195         def jmodsDir = &quot;${rootProject.buildDir}/${jmodsDirName}&quot;
5196         def standaloneSdkDirName = &quot;${platformPrefix}sdk&quot;
5197         def standaloneSdkDir = &quot;${rootProject.buildDir}/${standaloneSdkDirName}&quot;
5198         def standaloneLegalDir = &quot;${standaloneSdkDir}/legal&quot;
5199 
5200         def excludeNativeLibs = []
5201         if (IS_WINDOWS) {
5202             // List of duplicate Microsoft DLLs to exclude
5203             excludeNativeLibs += targetProperties.VS2017DLLNames
5204             excludeNativeLibs += targetProperties.WinSDKDLLNames
5205         }
5206 
5207         moduleProjList.each { project -&gt;
5208             def moduleName = project.ext.moduleName
5209             def buildDir = project.buildDir
5210 
5211             def srcClassesDir = &quot;${buildDir}/${platformPrefix}module-classes&quot;
5212             def srcLibDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
5213             def srcLegalDir = &quot;${standaloneLegalDir}/${moduleName}&quot;
5214 
5215             def jmodName = &quot;${moduleName}.jmod&quot;
5216             def jmodFile = &quot;${jmodsDir}/${jmodName}&quot;
5217             def jmodTask = project.task(&quot;jmod$t.capital&quot;, group: &quot;Build&quot;, dependsOn: sdk) {
5218                 doLast {
5219                     mkdir jmodsDir
5220                     delete(jmodFile);
5221                     exec {
5222                         commandLine(JMOD)
5223                         args(&quot;create&quot;)
5224                         args(&quot;--class-path&quot;)
5225                         args(srcClassesDir)
5226                         // Not all modules have a &quot;lib&quot; dir
5227                         if (file(srcLibDir).isDirectory()) {
5228                             args(&quot;--libs&quot;)
5229                             args(srcLibDir)
5230                         }
5231                         // Exclude duplicate native libs from javafx.graphics.jmod
5232                         if (moduleName == &quot;javafx.graphics&quot;) {
5233                             excludeNativeLibs.each { name -&gt;
5234                                 args(&quot;--exclude&quot;)
5235                                 args(name)
5236                             }
5237                         }
5238                         args(&quot;--legal-notices&quot;)
5239                         args(srcLegalDir)
5240                         args(jmodFile)
5241                     }
5242                 }
5243             }
5244 
5245             jmods.dependsOn(jmodTask)
5246         }
5247     }
5248 }
5249 
5250 /******************************************************************************
5251  *                                                                            *
5252  *                              BUILD_CLOSED                                  *
5253  *                                                                            *
5254  * This next section should remain at the end of the build script. It allows  *
5255  * for a &quot;supplemental&quot; gradle file to be used to extend the normal build     *
5256  * structure. For example, this is used for passing a supplemental gradle     *
5257  * file for producing official JavaFX builds.                                 *
5258  *                                                                            *
5259  *****************************************************************************/
5260 
5261 if (BUILD_CLOSED) {
5262     apply from: supplementalBuildFile
5263 }
5264 
5265 task showFlags {
5266 }
5267 
5268 compileTargets { t -&gt;
5269     // Every platform must define these variables
5270     def props = project.ext[t.upper];
5271     showFlags.dependsOn(
5272         project.task(&quot;showFlags$t.upper&quot;) {
5273             doLast() {
5274                 println &quot;Properties set for $t.upper&quot;
5275                 props.each { println it }
5276             }
5277         }
5278     )
5279 
5280 }
    </pre>
  </body>
</html>
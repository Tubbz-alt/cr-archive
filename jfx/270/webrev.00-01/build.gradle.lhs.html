<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames build.gradle</title>
    <link rel="stylesheet" href="style.css" />
    <script type="text/javascript" src="navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /**
  27  * The main build script for JavaFX.
  28  *
  29  * MUST FIX tasks to complete:
  30  *  - build check -- making sure the final artifact has the right bits
  31  *      - some things worth automatically sanity checking:
  32  *          - are there images in the javadocs?
  33  *          - are all of the expected dylibs etc there?
  34  *  - Perform sanity checking to make sure a JDK exists with javac, etc
  35  *  - Support building with no known JDK location, as long as javac, etc are on the path
  36  *  - Check all of the native flags. We&#39;re adding weight to some libs that don&#39;t need it, and so forth.
  37  *
  38  * Additional projects to work on as we go:
  39  *  - Add &quot;developer debug&quot;. This is where the natives do not have debug symbols, but the Java code does
  40  *  - The genVSproperties.bat doesn&#39;t find the directory where RC.exe lives. So it is hard coded. Might be a problem.
  41  *  - special tasks for common needs, such as:
  42  *      - updating copyright headers
  43  *      - stripping trailing whitespace (?)
  44  *  - checkstyle
  45  *  - findbugs
  46  *  - re needs?
  47  *  - sqe testing
  48  *  - API change check
  49  *  - Pushing results to a repo?
  50  *  - ServiceWithSecurityManagerTest fails to complete when run from gradle.
  51  *  - Integrate Parfait reports for C code
  52  *  - FXML Project tests are not running
  53  */
  54 defaultTasks = [&quot;sdk&quot;]
  55 
  56 import java.util.concurrent.CountDownLatch
  57 import java.util.concurrent.ExecutorService
  58 import java.util.concurrent.Executors
  59 import java.util.concurrent.Future
  60 
  61 /******************************************************************************
  62  *                              Utility methods                               *
  63  *****************************************************************************/
  64 
  65 /**
  66  * If the given named property is not defined, then this method will define
  67  * it with the given defaultValue. Any properties defined by this method can
  68  * be substituted on the command line by using -P, or by specifying a
  69  * gradle.properties file in the user home dir
  70  *
  71  * @param name The name of the property to define
  72  * @param defaultValue The default value to assign the property
  73  */
  74 void defineProperty(String name, String defaultValue) {
  75     if (!project.hasProperty(name)) {
  76         project.ext.set(name, defaultValue);
  77     }
  78 }
  79 
  80 /**
  81  * If the given named property is not defined, then this method will attempt to
  82  * look up the property in the props map, and use the defaultValue if it cannot be found.
  83  *
  84  * @param name The name of the property to look up and/or define
  85  * @param props The properties to look for the named property in, if it has not already been defined
  86  * @param defaultValue The default value if the property has not been defined and the
  87  *                     props map does not contain the named property
  88  */
  89 void defineProperty(String name, Properties props, String defaultValue) {
  90     if (!project.hasProperty(name)) {
  91         project.ext.set(name, props.getProperty(name, defaultValue));
  92     }
  93 }
  94 
  95 /**
  96  * Converts cygwin style paths to windows style paths, but with a forward slash.
  97  * This method is safe to call from any platform, and will only do work if
  98  * called on Windows (in all other cases it simply returns the supplied path.
  99  *
 100  * @param path the path to convert
 101  * @return the path converted to windows style, if on windows, otherwise it
 102  *         is the supplied path.
 103  */
 104 String cygpath(String path) {
 105     if (!IS_WINDOWS) return path;
 106     if (path == null || &quot;&quot;.equals(path)) return path;
 107     String ret = path.replaceAll(&#39;\\\\&#39;, &#39;/&#39;)
 108     logger.info(&quot;Converting path &#39;$path&#39; via cygpath to &quot;+ret)
 109     return ret
 110 }
 111 
 112 /**
 113  * Converts cygwin file paths for java executables to windows style
 114  * executable paths by changing forward slashes to back slashes and
 115  * adding the &#39;.exe&#39; extension.
 116  * This method is safe to call from any platform, and will only do work if
 117  * called on Windows (in all other cases it simply returns the supplied path).
 118  *
 119  * @param path the path to convert
 120  * @return the path converted to windows style, if on windows, otherwise it
 121  *         is the supplied path.
 122  */
 123 String cygpathExe(String path) {
 124     if (!IS_WINDOWS) return path;
 125     if (path == null || &quot;&quot;.equals(path)) return path;
 126     String ret = path.replaceAll(&#39;/&#39;, &#39;\\\\&#39;)
 127     logger.info(&quot;Converting path &#39;$path&#39; via cygpath to &quot;+ret)
 128     return ret + &quot;.exe&quot;
 129 }
 130 
 131 void loadProperties(String sourceFileName) {
 132     def config = new Properties()
 133     def propFile = new File(sourceFileName)
 134     if (propFile.canRead()) {
 135         config.load(new FileInputStream(propFile))
 136         for (java.util.Map.Entry property in config) {
 137             def keySplit = property.key.split(&quot;\\.&quot;);
 138             def key = keySplit[0];
 139             for (int i = 1; i &lt; keySplit.length; i++) {
 140                 key = key + keySplit[i].capitalize();
 141             }
 142             ext[key] = property.value;
 143         }
 144     }
 145 }
 146 
 147 /**
 148  * Struct used to contain some information passed to the closure
 149  * passed to compileTargets.
 150  */
 151 class CompileTarget {
 152     String name;
 153     String upper;
 154     String capital;
 155 }
 156 
 157 /**
 158  * Iterates over each of the compile targets, passing the given closure
 159  * a CompileTarget instance.
 160  *
 161  * @param c The closure to call
 162  */
 163 void compileTargets(Closure c) {
 164     if (COMPILE_TARGETS == &quot;&quot;) {
 165         return
 166     }
 167     COMPILE_TARGETS.split(&quot;,&quot;).each { target -&gt;
 168         CompileTarget ct = new CompileTarget();
 169         ct.name = target;
 170         ct.upper = target.trim().toUpperCase(Locale.ROOT)
 171         ct.capital = target.trim().capitalize()
 172         c(ct)
 173     }
 174 }
 175 
 176 /**
 177  * Manages the execution of some closure which is responsible for producing
 178  * content for a properties file built at build time and stored in the
 179  * root project&#39;s $buildDir, and then loading that properties file and
 180  * passing it to the processor closure.
 181  *
 182  * This is used on windows to produce a properties file containing all the
 183  * windows visual studio paths and environment variables, and on Linux
 184  * for storing the results of pkg-config calls.
 185  *
 186  * @param name the name of the file to produce
 187  * @param loader a closure which is invoked, given the properties file. This
 188  *        closure is invoked only if the properties file needs to be created
 189  *        and is responsible for populating the properties file.
 190  * @param processor a closure which is invoked every time this method is
 191  *        called and which will be given a Properties object, fully populated.
 192  *        The processor is then responsible for doing whatever it is that it
 193  *        must do with those properties (such as setting up environment
 194  *        variables used in subsequent native builds, or whatnot).
 195  */
 196 void setupTools(String name, Closure loader, Closure processor) {
 197     // Check to see whether $buildDir/$name.properties file exists. If not,
 198     // then generate it. Once generated, we need to read the properties file to
 199     // help us define the defaults for this block of properties
 200     File propFile = file(&quot;$buildDir/${name}.properties&quot;);
 201     if (!propFile.exists()) {
 202         // Create the properties file
 203         propFile.getParentFile().mkdirs();
 204         propFile.createNewFile();
 205         loader(propFile);
 206     }
 207 
 208     // Try reading the properties in order to define the properties. If the property file cannot
 209     // be located, then we will throw an exception because we cannot guess these values
 210     InputStream propStream = null;
 211     try {
 212         Properties properties = new Properties();
 213         propStream = new FileInputStream(propFile);
 214         properties.load(propStream);
 215         processor(properties);
 216     } finally {
 217         try { propStream.close() } catch (Exception e) { }
 218     }
 219 }
 220 
 221 String[] parseJavaVersion(String jRuntimeVersion) {
 222     def jVersion = jRuntimeVersion.split(&quot;[-\\+]&quot;)[0]
 223     def tmpBuildNumber = &quot;0&quot;
 224     if (jVersion.startsWith(&quot;1.&quot;)) {
 225         // This is a pre-JEP-223 version string
 226         def dashbIdx = jRuntimeVersion.lastIndexOf(&quot;-b&quot;)
 227         if (dashbIdx != -1) {
 228             tmpBuildNumber = jRuntimeVersion.substring(dashbIdx + 2)
 229         }
 230     } else {
 231         // This is a post-JEP-223 version string
 232         def plusIdx = jRuntimeVersion.indexOf(&quot;+&quot;)
 233         if (plusIdx != -1) {
 234             tmpBuildNumber = jRuntimeVersion.substring(plusIdx + 1)
 235         }
 236     }
 237     def jBuildNumber = tmpBuildNumber.split(&quot;[-\\+]&quot;)[0]
 238     def versionInfo = new String[2];
 239     versionInfo[0] = jVersion
 240     versionInfo[1] = jBuildNumber
 241     return versionInfo
 242 }
 243 
 244 /**
 245  * Fails the build with the specified error message
 246  *
 247  * @param msg the reason for the failure
 248  */
 249 void fail(String msg) {
 250     throw new GradleException(&quot;FAIL: &quot; + msg);
 251 }
 252 
 253 /******************************************************************************
 254  *                                                                            *
 255  *                   Definition of project properties                         *
 256  *                                                                            *
 257  *  All properties defined using ext. are immediately available throughout    *
 258  *  the script as variables that can be used. These variables are attached    *
 259  *  to the root project (whereas if they were defined as def variables then   *
 260  *  they would only be available within the root project scope).              *
 261  *                                                                            *
 262  *  All properties defined using the &quot;defineProperty&quot; method can be replaced  *
 263  *  on the command line by using the -P flag. For example, to override the    *
 264  *  location of the binary plug, you would specify -PBINARY_PLUG=some/where   *
 265  *                                                                            *
 266  *****************************************************************************/
 267 
 268 // If the ../rt-closed directory exists, then we are doing a closed build.
 269 // In this case, build and property files will be read from
 270 // ../rt-closed/closed-build.gradle and ../rt-closed/closed-properties.gradle
 271 // respectively
 272 
 273 def closedDir = file(&quot;../rt-closed&quot;)
 274 def buildClosed = closedDir.isDirectory()
 275 ext.BUILD_CLOSED = buildClosed
 276 
 277 ext.RUNARGSFILE = &quot;run.args&quot;
 278 ext.COMPILEARGSFILE = &quot;compile.args&quot;
 279 ext.RUNJAVAPOLICYFILE = &#39;run.java.policy&#39;
 280 
 281 ext.TESTCOMPILEARGSFILE = &quot;testcompile.args&quot;
 282 ext.TESTRUNARGSFILE = &quot;testrun.args&quot;
 283 ext.TESTJAVAPOLICYFILE = &#39;test.java.policy&#39;
 284 
 285 // the file containing &quot;extra&quot; --add-exports
 286 ext.EXTRAADDEXPORTS = &#39;buildSrc/addExports&#39;
 287 
 288 ext.MODULESOURCEPATH = &quot;modulesourcepath.args&quot;
 289 
 290 // These variables indicate what platform is running the build. Is
 291 // this build running on a Mac, Windows, or Linux machine? 32 or 64 bit?
 292 ext.OS_NAME = System.getProperty(&quot;os.name&quot;).toLowerCase()
 293 ext.OS_ARCH = System.getProperty(&quot;os.arch&quot;)
 294 ext.IS_64 = OS_ARCH.toLowerCase().contains(&quot;64&quot;)
 295 ext.IS_MAC = OS_NAME.contains(&quot;mac&quot;) || OS_NAME.contains(&quot;darwin&quot;)
 296 ext.IS_WINDOWS = OS_NAME.contains(&quot;windows&quot;)
 297 ext.IS_LINUX = OS_NAME.contains(&quot;linux&quot;)
 298 
 299 ext.MAVEN_GROUP_ID = &quot;org.openjfx&quot;
 300 
 301 // Verify that the architecture &amp; OS are supported configurations. Note that
 302 // at present building on PI is not supported, but we would only need to make
 303 // some changes on assumptions on what should be built (like SWT / Swing) and
 304 // such and we could probably make it work.
 305 if (!IS_MAC &amp;&amp; !IS_WINDOWS &amp;&amp; !IS_LINUX) fail(&quot;Unsupported build OS ${OS_NAME}&quot;)
 306 if (IS_WINDOWS &amp;&amp; OS_ARCH != &quot;x86&quot; &amp;&amp; OS_ARCH != &quot;amd64&quot;) {
 307     fail(&quot;Unknown and unsupported build architecture: $OS_ARCH&quot;)
 308 } else if (IS_MAC &amp;&amp; OS_ARCH != &quot;x86_64&quot;) {
 309     fail(&quot;Unknown and unsupported build architecture: $OS_ARCH&quot;)
 310 } else if (IS_LINUX &amp;&amp; OS_ARCH != &quot;i386&quot; &amp;&amp; OS_ARCH != &quot;amd64&quot;) {
 311     fail(&quot;Unknown and unsupported build architecture: $OS_ARCH&quot;)
 312 }
 313 
 314 
 315 // Get the JDK_HOME automatically based on the version of Java used to execute gradle. Or, if specified,
 316 // use a user supplied JDK_HOME, STUB_RUNTIME, JAVAC, all of which may be specified
 317 // independently (or we&#39;ll try to get the right one based on other supplied info). Sometimes the
 318 // JRE might be the thing that is being used instead of the JRE embedded in the JDK, such as:
 319 //    c:\Program Files (x86)\Java\jdk1.8.0\jre
 320 //    c:\Program Files (x86)\Java\jre8\
 321 // Because of this, you may sometimes get the jdk&#39;s JRE (in which case the logic we used to have here
 322 // was correct and consistent with all other platforms), or it might be the standalone JRE (for the love!).
 323 def envJavaHome = cygpath(System.getenv(&quot;JDK_HOME&quot;))
 324 if (envJavaHome == null || envJavaHome.equals(&quot;&quot;)) envJavaHome = cygpath(System.getenv(&quot;JAVA_HOME&quot;))
 325 def javaHome = envJavaHome == null || envJavaHome.equals(&quot;&quot;) ? System.getProperty(&quot;java.home&quot;) : envJavaHome
 326 def javaHomeFile = file(javaHome)
 327 defineProperty(&quot;JDK_HOME&quot;,
 328         javaHomeFile.name == &quot;jre&quot; ?
 329         javaHomeFile.getParent().toString() :
 330         javaHomeFile.name.startsWith(&quot;jre&quot;) ?
 331         new File(javaHomeFile.getParent(), &quot;jdk1.${javaHomeFile.name.substring(3)}.0&quot;).toString() :
 332         javaHome) // we have to bail and set it to something and this is as good as any!
 333 ext.JAVA_HOME = JDK_HOME
 334 
 335 defineProperty(&quot;JAVA&quot;, cygpathExe(&quot;$JDK_HOME/bin/java&quot;))
 336 defineProperty(&quot;JAVAC&quot;, cygpathExe(&quot;$JDK_HOME/bin/javac&quot;))
 337 defineProperty(&quot;JAVADOC&quot;, cygpathExe(&quot;$JDK_HOME/bin/javadoc&quot;))
 338 defineProperty(&quot;JMOD&quot;, cygpathExe(&quot;$JDK_HOME/bin/jmod&quot;))
 339 defineProperty(&quot;JDK_DOCS&quot;, &quot;https://docs.oracle.com/en/java/javase/12/docs/api/&quot;)
 340 defineProperty(&quot;JDK_JMODS&quot;, cygpath(System.getenv(&quot;JDK_JMODS&quot;)) ?: cygpath(System.getenv(&quot;JDK_HOME&quot;) + &quot;/jmods&quot;))
 341 
 342 defineProperty(&quot;javaRuntimeVersion&quot;, System.getProperty(&quot;java.runtime.version&quot;))
 343 def javaVersionInfo = parseJavaVersion(javaRuntimeVersion)
 344 defineProperty(&quot;javaVersion&quot;, javaVersionInfo[0])
 345 defineProperty(&quot;javaBuildNumber&quot;, javaVersionInfo[1])
 346 
 347 defineProperty(&quot;libAVRepositoryURL&quot;, &quot;https://libav.org/releases/&quot;)
 348 defineProperty(&quot;FFmpegRepositoryURL&quot;, &quot;https://www.ffmpeg.org/releases/&quot;)
 349 
 350 loadProperties(&quot;$projectDir/build.properties&quot;)
 351 
 352 def supplementalPreBuildFile = file(&quot;$closedDir/closed-pre-build.gradle&quot;);
 353 def supplementalBuildFile = file(&quot;$closedDir/closed-build.gradle&quot;);
 354 
 355 if (BUILD_CLOSED) {
 356     apply from: supplementalPreBuildFile
 357 }
 358 
 359 // GRADLE_VERSION_CHECK specifies whether to fail the build if the
 360 // gradle version check fails
 361 defineProperty(&quot;GRADLE_VERSION_CHECK&quot;, &quot;true&quot;)
 362 ext.IS_GRADLE_VERSION_CHECK = Boolean.parseBoolean(GRADLE_VERSION_CHECK)
 363 
 364 // JFX_DEPS_URL specifies the optional location of an alternate local repository
 365 defineProperty(&quot;JFX_DEPS_URL&quot;, &quot;&quot;)
 366 
 367 // JDK_DOCS_LINK specifies the optional URL for offline javadoc linking
 368 defineProperty(&quot;JDK_DOCS_LINK&quot;, &quot;&quot;)
 369 
 370 // COMPILE_WEBKIT specifies whether to build all of webkit.
 371 defineProperty(&quot;COMPILE_WEBKIT&quot;, &quot;false&quot;)
 372 ext.IS_COMPILE_WEBKIT = Boolean.parseBoolean(COMPILE_WEBKIT)
 373 
 374 // COMPILE_MEDIA specifies whether to build all of media.
 375 defineProperty(&quot;COMPILE_MEDIA&quot;, &quot;false&quot;)
 376 ext.IS_COMPILE_MEDIA = Boolean.parseBoolean(COMPILE_MEDIA)
 377 
 378 // BUILD_LIBAV_STUBS specifies whether to download and build libav/ffmpeg libraries
 379 defineProperty(&quot;BUILD_LIBAV_STUBS&quot;, &quot;false&quot;)
 380 ext.IS_BUILD_LIBAV_STUBS = IS_LINUX ? Boolean.parseBoolean(BUILD_LIBAV_STUBS) : false
 381 
 382 // BUILD_WORKING_LIBAV specifies whether to build libav/ffmpeg libraries with
 383 // decoder, demuxer, etc. required to run media. Valid only if BUILD_LIBAV_STUBS is true.
 384 defineProperty(&quot;BUILD_WORKING_LIBAV&quot;, &quot;false&quot;)
 385 ext.IS_BUILD_WORKING_LIBAV = IS_LINUX ? Boolean.parseBoolean(BUILD_WORKING_LIBAV) : false
 386 
 387 // COMPILE_PANGO specifies whether to build javafx_font_pango.
 388 defineProperty(&quot;COMPILE_PANGO&quot;, &quot;${IS_LINUX}&quot;)
 389 ext.IS_COMPILE_PANGO = Boolean.parseBoolean(COMPILE_PANGO)
 390 
 391 // COMPILE_HARFBUZZ specifies whether to use Harfbuzz.
 392 defineProperty(&quot;COMPILE_HARFBUZZ&quot;, &quot;false&quot;)
 393 ext.IS_COMPILE_HARFBUZZ = Boolean.parseBoolean(COMPILE_HARFBUZZ)
 394 
 395 // COMPILE_PARFAIT specifies whether to build parfait
 396 defineProperty(&quot;COMPILE_PARFAIT&quot;, &quot;false&quot;)
 397 ext.IS_COMPILE_PARFAIT = Boolean.parseBoolean(COMPILE_PARFAIT)
 398 
 399 defineProperty(&quot;STATIC_BUILD&quot;, &quot;false&quot;)
 400 ext.IS_STATIC_BUILD = Boolean.parseBoolean(STATIC_BUILD)
 401 
 402 if (IS_STATIC_BUILD &amp;&amp; IS_COMPILE_MEDIA) {
 403     throw new GradleException(&quot;Can not have COMPILE_MEDIA when STATIC_BUILD is enabled&quot;);
 404 }
 405 
 406 // BUILD_TOOLS_DOWNLOAD_SCRIPT specifies a path of a gradle script which downloads
 407 // required build tools.
 408 defineProperty(&quot;BUILD_TOOLS_DOWNLOAD_SCRIPT&quot;, &quot;&quot;)
 409 
 410 // Define the SWT.jar that we are going to have to download during the build process based
 411 // on what platform we are compiling from (not based on our target).
 412 ext.SWT_FILE_NAME = IS_MAC ? &quot;org.eclipse.swt.cocoa.macosx.x86_64_3.105.3.v20170228-0512&quot; :
 413     IS_WINDOWS &amp;&amp; IS_64 ? &quot;org.eclipse.swt.win32.win32.x86_64_3.105.3.v20170228-0512&quot; :
 414     IS_WINDOWS &amp;&amp; !IS_64 ? &quot;org.eclipse.swt.win32.win32.x86_3.105.3.v20170228-0512&quot; :
 415     IS_LINUX &amp;&amp; IS_64 ? &quot;org.eclipse.swt.gtk.linux.x86_64_3.105.3.v20170228-0512&quot; :
 416     IS_LINUX &amp;&amp; !IS_64 ? &quot;org.eclipse.swt.gtk.linux.x86_3.105.3.v20170228-0512&quot; : &quot;&quot;
 417 
 418 // Specifies whether to run full tests (true) or smoke tests (false)
 419 defineProperty(&quot;FULL_TEST&quot;, &quot;false&quot;)
 420 ext.IS_FULL_TEST = Boolean.parseBoolean(FULL_TEST);
 421 
 422 defineProperty(&quot;FORCE_TESTS&quot;, &quot;false&quot;)
 423 ext.IS_FORCE_TESTS = Boolean.parseBoolean(FORCE_TESTS);
 424 
 425 // Specifies whether to run robot-based visual tests (only used when FULL_TEST is also enabled)
 426 defineProperty(&quot;USE_ROBOT&quot;, &quot;false&quot;)
 427 ext.IS_USE_ROBOT = Boolean.parseBoolean(USE_ROBOT);
 428 
 429 // Specified whether to run tests in headless mode
 430 defineProperty(&quot;HEADLESS_TEST&quot;, &quot;false&quot;)
 431 ext.IS_HEADLESS_TEST = Boolean.parseBoolean(HEADLESS_TEST);
 432 
 433 // Specifies whether to run system tests that depend on AWT (only used when FULL_TEST is also enabled)
 434 defineProperty(&quot;AWT_TEST&quot;, &quot;true&quot;)
 435 ext.IS_AWT_TEST = Boolean.parseBoolean(AWT_TEST);
 436 
 437 // Specifies whether to run system tests that depend on SWT (only used when FULL_TEST is also enabled)
 438 defineProperty(&quot;SWT_TEST&quot;, &quot;true&quot;)
 439 ext.IS_SWT_TEST = Boolean.parseBoolean(SWT_TEST);
 440 
 441 // Specifies whether to run unstable tests (true) - tests that don&#39;t run well with Hudson builds
 442 // These tests should be protected with :
 443 //    assumeTrue(Boolean.getBoolean(&quot;unstable.test&quot;));
 444 defineProperty(&quot;UNSTABLE_TEST&quot;, &quot;false&quot;)
 445 ext.IS_UNSTABLE_TEST = Boolean.parseBoolean(UNSTABLE_TEST);
 446 
 447 // Toggle diagnostic output from the Gradle workaround and the Sandbox test apps.
 448 defineProperty(&quot;WORKER_DEBUG&quot;, &quot;false&quot;)
 449 ext.IS_WORKER_DEBUG = Boolean.parseBoolean(WORKER_DEBUG);
 450 
 451 // Specify the build configuration (Release, Debug, or DebugNative)
 452 defineProperty(&quot;CONF&quot;, &quot;Debug&quot;)
 453 ext.IS_DEBUG_JAVA = CONF == &quot;Debug&quot; || CONF == &quot;DebugNative&quot;
 454 ext.IS_DEBUG_NATIVE = CONF == &quot;DebugNative&quot;
 455 
 456 // Specifies whether to enable the Maven publishing tasks
 457 defineProperty(&quot;MAVEN_PUBLISH&quot;, &quot;false&quot;)
 458 ext.IS_MAVEN_PUBLISH = Boolean.parseBoolean(MAVEN_PUBLISH)
 459 
 460 // Defines the compiler warning levels to use. If empty, then no warnings are generated. If
 461 // not empty, then the expected syntax is as a space or comma separated list of names, such
 462 // as defined in the javac documentation.
 463 defineProperty(&quot;LINT&quot;, &quot;none&quot;)
 464 ext.IS_LINT = LINT != &quot;none&quot;
 465 
 466 defineProperty(&quot;DOC_LINT&quot;, &quot;all&quot;)
 467 ext.IS_DOC_LINT = DOC_LINT != &quot;&quot;
 468 
 469 // Specifies whether to use the &quot;useDepend&quot; option when compiling Java sources
 470 defineProperty(&quot;USE_DEPEND&quot;, &quot;true&quot;)
 471 ext.IS_USE_DEPEND = Boolean.parseBoolean(USE_DEPEND)
 472 
 473 // Specifies whether to use the &quot;incremental&quot; option when compiling Java sources
 474 defineProperty(&quot;INCREMENTAL&quot;, &quot;false&quot;)
 475 ext.IS_INCREMENTAL = Boolean.parseBoolean(INCREMENTAL)
 476 
 477 // Specifies whether to include the Null3D pipeline (for perf debugging)
 478 defineProperty(&quot;INCLUDE_NULL3D&quot;, &quot;false&quot;)
 479 ext.IS_INCLUDE_NULL3D = Boolean.parseBoolean(INCLUDE_NULL3D)
 480 
 481 // Specifies whether to include the ES2 pipeline if available
 482 defineProperty(&quot;INCLUDE_ES2&quot;, IS_WINDOWS ? &quot;false&quot; : &quot;true&quot;)
 483 ext.IS_INCLUDE_ES2 = Boolean.parseBoolean(INCLUDE_ES2)
 484 
 485 // Specifies whether to generate code coverage statistics when running tests
 486 defineProperty(&quot;JCOV&quot;, &quot;false&quot;)
 487 ext.DO_JCOV = Boolean.parseBoolean(JCOV)
 488 
 489 // Specifies whether to use Cygwin when building OpenJFX. This should only ever
 490 // be set to false for development builds (that skip building media and webkit).
 491 defineProperty(&quot;USE_CYGWIN&quot;, &quot;true&quot;)
 492 ext.IS_USE_CYGWIN = Boolean.parseBoolean(USE_CYGWIN)
 493 
 494 // Define the number of threads to use when compiling (specifically for native compilation)
 495 // On Mac we limit it to 1 by default due to problems running gcc in parallel
 496 if (IS_MAC) {
 497     defineProperty(&quot;NUM_COMPILE_THREADS&quot;, &quot;1&quot;)
 498 } else {
 499     defineProperty(&quot;NUM_COMPILE_THREADS&quot;, &quot;${Runtime.runtime.availableProcessors()}&quot;)
 500 }
 501 
 502 //
 503 // The next three sections of properties are used to generate the
 504 // VersionInfo class, and the Windows DLL manifest.
 505 //
 506 
 507 // The following properties should be left alone by developers and set only from Hudson.
 508 defineProperty(&quot;HUDSON_JOB_NAME&quot;, &quot;not_hudson&quot;)
 509 defineProperty(&quot;HUDSON_BUILD_NUMBER&quot;,&quot;0000&quot;)
 510 defineProperty(&quot;PROMOTED_BUILD_NUMBER&quot;, &quot;0&quot;)
 511 defineProperty(&quot;MILESTONE_FCS&quot;, &quot;false&quot;)
 512 ext.IS_MILESTONE_FCS = Boolean.parseBoolean(MILESTONE_FCS)
 513 
 514 // The following properties define the product name for Oracle JDK and OpenJDK
 515 // for VersionInfo and the DLL manifest.
 516 if (BUILD_CLOSED) {
 517     defineProperty(&quot;PRODUCT_NAME&quot;, &quot;Java(TM)&quot;)
 518     defineProperty(&quot;COMPANY_NAME&quot;, &quot;Oracle Corporation&quot;)
 519     defineProperty(&quot;PLATFORM_NAME&quot;, &quot;Platform SE&quot;)
 520 } else {
 521     defineProperty(&quot;PRODUCT_NAME&quot;, &quot;OpenJFX&quot;)
 522     defineProperty(&quot;COMPANY_NAME&quot;, &quot;N/A&quot;)
 523     defineProperty(&quot;PLATFORM_NAME&quot;, &quot;Platform&quot;)
 524 }
 525 
 526 // The following properties are set based on properties defined in
 527 // build.properties. The release version and suffix should be updated
 528 // in that file.
 529 def relVer = 0
 530 if (jfxReleasePatchVersion == &quot;0&quot;) {
 531     if (jfxReleaseSecurityVersion == &quot;0&quot;) {
 532         if (jfxReleaseMinorVersion == &quot;0&quot;) {
 533             relVer = &quot;${jfxReleaseMajorVersion}&quot;
 534         } else {
 535             relVer = &quot;${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}&quot;
 536         }
 537     } else {
 538         relVer = &quot;${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}.${jfxReleaseSecurityVersion}&quot;
 539     }
 540 } else {
 541     relVer = &quot;${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}.${jfxReleaseSecurityVersion}.${jfxReleasePatchVersion}&quot;
 542 }
 543 defineProperty(&quot;RELEASE_VERSION&quot;, relVer)
 544 defineProperty(&quot;RELEASE_VERSION_PADDED&quot;, &quot;${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}.${jfxReleaseSecurityVersion}.${jfxReleasePatchVersion}&quot;)
 545 
 546 def buildDate = new java.util.Date()
 547 def buildTimestamp = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd-HHmmss&quot;).format(buildDate)
 548 defineProperty(&quot;BUILD_TIMESTAMP&quot;, buildTimestamp)
 549 def relSuffix = &quot;&quot;
 550 def relOpt = &quot;&quot;
 551 if (HUDSON_JOB_NAME == &quot;not_hudson&quot;) {
 552     relSuffix = &quot;-internal&quot;
 553     relOpt = &quot;-${buildTimestamp}&quot;
 554 } else {
 555     relSuffix = IS_MILESTONE_FCS ? &quot;&quot; : jfxReleaseSuffix
 556 }
 557 defineProperty(&quot;RELEASE_SUFFIX&quot;, relSuffix)
 558 defineProperty(&quot;RELEASE_VERSION_SHORT&quot;, &quot;${RELEASE_VERSION}${RELEASE_SUFFIX}&quot;)
 559 defineProperty(&quot;RELEASE_VERSION_LONG&quot;, &quot;${RELEASE_VERSION_SHORT}+${PROMOTED_BUILD_NUMBER}${relOpt}&quot;)
 560 defineProperty(&quot;MAVEN_VERSION&quot;, IS_MAVEN_PUBLISH ? (IS_MILESTONE_FCS ? &quot;${RELEASE_VERSION_SHORT}&quot; : &quot;${RELEASE_VERSION_LONG}&quot;) : &quot;&quot;)
 561 
 562 // Check whether the COMPILE_TARGETS property has been specified (if so, it was done by
 563 // the user and not by this script). If it has not been defined then default
 564 // to building the normal desktop build for this machine
 565 project.ext.set(&quot;defaultHostTarget&quot;, IS_MAC ? &quot;mac&quot; : IS_WINDOWS ? &quot;win&quot; : IS_LINUX ? &quot;linux&quot; : &quot;&quot;);
 566 defineProperty(&quot;COMPILE_TARGETS&quot;, &quot;$defaultHostTarget&quot;)
 567 
 568 // Flag indicating whether to import cross compile tools
 569 def importCrossTools = false
 570 if (hasProperty(&quot;IMPORT_CROSS_TOOLS&quot;)) {
 571     importCrossTools = Boolean.parseBoolean(IMPORT_CROSS_TOOLS);
 572 }
 573 ext.IS_IMPORT_CROSS_TOOLS = importCrossTools
 574 
 575 // Location of the cross compile tools
 576 def crossToolsDir = &quot;../crosslibs&quot;
 577 if (hasProperty(&quot;CROSS_TOOLS_DIR&quot;)) {
 578     crossToolsDir = CROSS_TOOLS_DIR
 579 }
 580 ext.CROSS_TOOLS_DIR = file(crossToolsDir)
 581 
 582 // Specifies whether to run tests with the existing javafx.* modules instead of compiling a new one
 583 defineProperty(&quot;BUILD_SDK_FOR_TEST&quot;, &quot;true&quot;)
 584 ext.DO_BUILD_SDK_FOR_TEST = Boolean.parseBoolean(BUILD_SDK_FOR_TEST)
 585 
 586 // All &quot;classes&quot; and &quot;jar&quot; tasks and their dependencies would be disabled
 587 // when running with DO_BUILD_SDK_FOR_TEST=false as they&#39;re unneeded for running tests
 588 if (!DO_BUILD_SDK_FOR_TEST) {
 589     gradle.taskGraph.useFilter({ task -&gt; !task.name.equals(&quot;classes&quot;) &amp;&amp; !task.name.equals(&quot;jar&quot;) })
 590 }
 591 
 592 // Make sure JDK_HOME/bin/java exists
 593 if (!file(JAVA).exists()) throw new Exception(&quot;Missing or incorrect path to &#39;java&#39;: &#39;$JAVA&#39;. Perhaps bad JDK_HOME? $JDK_HOME&quot;)
 594 if (!file(JAVAC).exists()) throw new Exception(&quot;Missing or incorrect path to &#39;javac&#39;: &#39;$JAVAC&#39;. Perhaps bad JDK_HOME? $JDK_HOME&quot;)
 595 if (!file(JAVADOC).exists()) throw new Exception(&quot;Missing or incorrect path to &#39;javadoc&#39;: &#39;$JAVADOC&#39;. Perhaps bad JDK_HOME? $JDK_HOME&quot;)
 596 
 597 // Determine the verion of Java in JDK_HOME. It looks like this:
 598 //
 599 // $ java -version
 600 // java version &quot;1.7.0_45&quot;
 601 // Java(TM) SE Runtime Environment (build 1.7.0_45-b18)
 602 // Java HotSpot(TM) 64-Bit Server VM (build 24.45-b08, mixed mode)
 603 //
 604 // We need to parse the second line
 605 def inStream = new java.io.BufferedReader(new java.io.InputStreamReader(new java.lang.ProcessBuilder(JAVA, &quot;-fullversion&quot;).start().getErrorStream()));
 606 try {
 607     String v = inStream.readLine().trim();
 608     if (v != null) {
 609         int ib = v.indexOf(&quot;full version \&quot;&quot;);
 610         if (ib != -1) {
 611             String str = v.substring(ib);
 612             String ver = str.substring(str.indexOf(&quot;\&quot;&quot;) + 1, str.size() - 1);
 613 
 614             defineProperty(&quot;jdkRuntimeVersion&quot;, ver)
 615             def jdkVersionInfo = parseJavaVersion(ver)
 616             defineProperty(&quot;jdkVersion&quot;, jdkVersionInfo[0])
 617             defineProperty(&quot;jdkBuildNumber&quot;, jdkVersionInfo[1])
 618         }
 619     }
 620 } finally {
 621     inStream.close();
 622 }
 623 if (!project.hasProperty(&quot;jdkRuntimeVersion&quot;)) throw new Exception(&quot;Unable to determine the version of Java in JDK_HOME at $JDK_HOME&quot;);
 624 
 625 
 626 // Determine whether the javafx.* modules are present in the JDK. To do this,
 627 // we will execute &quot;java --list-modules&quot; and search for javafx.base.
 628 ext.HAS_JAVAFX_MODULES = false;
 629 def inStream2 = new java.io.BufferedReader(new java.io.InputStreamReader(new java.lang.ProcessBuilder(JAVA, &quot;--list-modules&quot;).start().getInputStream()));
 630 try {
 631     String v;
 632     while ((v = inStream2.readLine()) != null) {
 633         v = v.trim();
 634         if (v.startsWith(&quot;javafx.base&quot;)) ext.HAS_JAVAFX_MODULES = true;
 635     }
 636 } finally {
 637     inStream2.close();
 638 }
 639 
 640 // The HAS_JAVAFX_MODULES flag will be used to determine the mode for building
 641 // and running the applications and tests.
 642 // If HAS_JAVAFX_MODULES is true, then we will build / test javafx modules
 643 // for exporting to a JDK build. If HAS_JAVAFX_MODULES is false, then we will
 644 // build / test a standalone sdk for running with a JDK that does not include
 645 // the javafx modules.
 646 
 647 
 648 /**
 649  * Fetch/Check that external tools are present for the build. This method
 650  * will conditionally download the packages from project defined ivy repositories
 651  * and unpack them into the specified destdir
 652  *
 653  * @param configName A unique name to distinguish the configuration (ie &quot;ARMSFV6&quot;)
 654  * @param packages A list of required packages (with extensions .tgz, .zip)
 655  * @param destdir where the packages should be unpacked
 656  * @param doFetch if true, the named packages will be download
 657  */
 658 void fetchExternalTools(String configName, List packages, File destdir, boolean doFetch) {
 659     if (doFetch) {
 660         // create a unique configuration for this fetch
 661         def String fetchToolsConfig = &quot;fetchTools$configName&quot;
 662         rootProject.configurations.create(fetchToolsConfig)
 663 
 664         def List&lt;String&gt; fetchedPackages = []
 665         def int fetchCount = 0
 666 
 667         packages.each { pkgname-&gt;
 668             def int dotdex = pkgname.lastIndexOf(&#39;.&#39;)
 669             def int dashdex = pkgname.lastIndexOf(&#39;-&#39;)
 670             def String basename = pkgname.substring(0,dashdex)
 671             def String ver = pkgname.substring(dashdex+1,dotdex)
 672             def String ext = pkgname.substring(dotdex+1)
 673             def File pkgdir = file(&quot;$destdir/$basename-$ver&quot;)
 674 
 675             if (!pkgdir.isDirectory()) {
 676                 rootProject.dependencies.add(fetchToolsConfig, &quot;javafx:$basename:$ver&quot;, {
 677                     artifact {
 678                         name = basename
 679                         type = ext
 680                     }
 681                 })
 682                 println &quot;adding $pkgname as a downloadable item did not find $pkgdir&quot;
 683                 fetchedPackages.add(pkgname)
 684                 fetchCount++
 685             }
 686         }
 687 
 688         //fetch all the missing packages
 689         if (fetchedPackages.size &gt; 0) {
 690             destdir.mkdirs()
 691 
 692             logger.quiet &quot;fetching missing packages $fetchedPackages&quot;
 693             copy {
 694                 from rootProject.configurations[fetchToolsConfig]
 695                 into destdir
 696             }
 697 
 698             // unpack the fetched packages
 699             fetchedPackages.each { pkgname-&gt;
 700                 logger.quiet &quot;expanding the package $pkgname&quot;
 701                 def srcball = file(&quot;${destdir}/${pkgname}&quot;)
 702 
 703                 if (!srcball.exists()) {
 704                     throw new GradleException(&quot;Failed to fetch $pkgname&quot;);
 705                 }
 706 
 707                 def String basename = pkgname.substring(0,pkgname.lastIndexOf(&quot;.&quot;))
 708                 def File pkgdir = file(&quot;$destdir/$basename&quot;)
 709 
 710                 if (pkgname.endsWith(&quot;.tgz&quot;) || pkgname.endsWith(&quot;tar.gz&quot;)) {
 711                     if (IS_LINUX || IS_MAC) {
 712                         // use native tar to support symlinks
 713                         pkgdir.mkdirs()
 714                         exec {
 715                             workingDir pkgdir
 716                             commandLine &quot;tar&quot;, &quot;zxf&quot;, &quot;${srcball}&quot;
 717                          }
 718                     } else {
 719                         copy {
 720                             from tarTree(resources.gzip(&quot;${srcball}&quot;))
 721                             into pkgdir
 722                         }
 723                     }
 724                 } else if (pkgname.endsWith(&quot;.zip&quot;)) {
 725                      copy {
 726                          from zipTree(&quot;${srcball}&quot;)
 727                          into pkgdir
 728                      }
 729                 } else {
 730                     throw new GradleException(&quot;Unhandled package type for compile package ${pkgname}&quot;)
 731                 }
 732                 srcball.delete();
 733             }
 734         } else {
 735             logger.quiet &quot;all tool packages are present $packages&quot;
 736         }
 737     } else { // !doFetch - so just check they are present
 738         // check that all the dirs are really there
 739         def List&lt;String&gt; errors = []
 740         packages.each { pkgname-&gt;
 741             def String basename = pkgname.substring(0,pkgname.lastIndexOf(&quot;.&quot;))
 742             def File pkgdir = file(&quot;$destdir/$basename&quot;)
 743 
 744             if (!pkgdir.isDirectory()) {
 745                 errors.add(pkgname)
 746             }
 747         }
 748         if (errors.size &gt; 0) {
 749             throw new GradleException(&quot;Error: missing tool packages: $errors&quot;)
 750         } else {
 751             logger.quiet &quot;all tool packages are present $packages&quot;
 752         }
 753     }
 754 }
 755 
 756 // Make a forked ANT call.
 757 // This needs to be forked so that ant can be used with the right JDK and updated modules
 758 // for testing obscure things like packaging of apps
 759 void ant(String conf,   // platform configuration
 760          String dir,    // directory to run from
 761          String target, // ant target
 762          List&lt;String&gt;  params // parameters (usually -Dxxx=yyy)
 763          ) {
 764     // Try to use ANT_HOME
 765     String antHomeEnv = System.getenv(&quot;ANT_HOME&quot;)
 766     String antHome = antHomeEnv != null ? cygpath(antHomeEnv) : null;
 767     String ant = (antHome != null &amp;&amp; !antHome.equals(&quot;&quot;)) ? &quot;$antHome/bin/ant&quot; : &quot;ant&quot;;
 768 
 769     exec {
 770         workingDir = dir
 771         environment(&quot;JDK_HOME&quot;, JDK_HOME)
 772         environment(&quot;JAVA_HOME&quot;, JDK_HOME)
 773         if (IS_WINDOWS) {
 774             environment([
 775                     &quot;VCINSTALLDIR&quot;         : WINDOWS_VS_VCINSTALLDIR,
 776                     &quot;VSINSTALLDIR&quot;         : WINDOWS_VS_VSINSTALLDIR,
 777                     &quot;DEVENVDIR&quot;            : WINDOWS_VS_DEVENVDIR,
 778                     &quot;MSVCDIR&quot;              : WINDOWS_VS_MSVCDIR,
 779                     &quot;INCLUDE&quot;              : WINDOWS_VS_INCLUDE,
 780                     &quot;LIB&quot;                  : WINDOWS_VS_LIB,
 781                     &quot;LIBPATH&quot;              : WINDOWS_VS_LIBPATH,
 782                     &quot;DXSDK_DIR&quot;            : WINDOWS_DXSDK_DIR,
 783                     &quot;PATH&quot;                 : WINDOWS_VS_PATH
 784             ]);
 785             commandLine &quot;cmd&quot;, &quot;/c&quot;, ant, &quot;-Dbuild.compiler=javac1.7&quot;
 786         } else {
 787             commandLine ant, &quot;-Dbuild.compiler=javac1.7&quot;
 788         }
 789         if ((conf != null) &amp;&amp; !rootProject.defaultHostTarget.equals(conf)) {
 790             def targetProperties = rootProject.ext[conf.trim().toUpperCase()]
 791             args(&quot;-Dcross.platform=$conf&quot;)
 792             if (targetProperties.containsKey(&#39;arch&#39;)) {
 793                 args(&quot;-Dcross.platform.arch=${targetProperties.arch}&quot;)
 794             }
 795         }
 796         if (params != null) {
 797             params.each() { s-&gt;
 798                 args(s)
 799             }
 800         }
 801         if (IS_MILESTONE_FCS) {
 802             args(&#39;-Djfx.release.suffix=&quot;&quot;&#39;)
 803         }
 804         args(target);
 805     }
 806 }
 807 
 808 List&lt;String&gt; computeLibraryPath(boolean working) {
 809     List&lt;String&gt; lp = []
 810 
 811     if (HAS_JAVAFX_MODULES) {
 812         List&lt;String&gt; modsWithNative = [ &#39;graphics&#39;, &#39;media&#39;, &#39;web&#39; ]
 813 
 814         // the build/modular-sdk area
 815         def platformPrefix = &quot;&quot;
 816         def bundledSdkDirName = &quot;${platformPrefix}modular-sdk&quot;
 817         def bundledSdkDir = &quot;${rootProject.buildDir}/${bundledSdkDirName}&quot;
 818         def modulesLibsDir = &quot;${bundledSdkDir}/modules_libs&quot;
 819 
 820         modsWithNative.each() { m -&gt;
 821             lp &lt;&lt; cygpath(&quot;${modulesLibsDir}/javafx.${m}&quot;)
 822         }
 823     } else {
 824         def platformPrefix = &quot;&quot;
 825         def standaloneSdkDirName = &quot;${platformPrefix}sdk&quot;
 826         def standaloneSdkDir = &quot;${rootProject.buildDir}/${standaloneSdkDirName}&quot;
 827         def modulesLibName = IS_WINDOWS ? &quot;bin&quot; : &quot;lib&quot;
 828         def modulesLibsDir = &quot;${standaloneSdkDir}/${modulesLibName}&quot;
 829         lp &lt;&lt; cygpath(&quot;${modulesLibsDir}&quot;)
 830     }
 831 
 832     return lp
 833 }
 834 
 835 // Return list with the arguments needed for --patch-module or --module-path
 836 // for the provided projects. Used with Java executables ie. tests
 837 List&lt;String&gt; computePatchModuleArgs(List&lt;String&gt; deps, boolean test, boolean includeJLP) {
 838     List&lt;String&gt; pma = []
 839 
 840     if (HAS_JAVAFX_MODULES) {
 841         deps.each { String projname -&gt;
 842             def proj = project(projname)
 843             if (proj.hasProperty(&quot;moduleName&quot;)) {
 844                 File dir;
 845                 if (test &amp;&amp; proj.sourceSets.hasProperty(&#39;shims&#39;)) {
 846                     dir = file(&quot;${rootProject.buildDir}/shims&quot;)
 847                 } else {
 848                     dir = file(&quot;${rootProject.buildDir}/modular-sdk/modules&quot;)
 849                 }
 850                 String moduleName = proj.ext.moduleName
 851                 String dirpath = cygpath(&quot;${dir}/${moduleName}&quot;)
 852                 pma += &quot;--patch-module=${moduleName}=${dirpath}&quot;
 853             }
 854         }
 855     } else {
 856         String mp = null
 857         deps.each { String projname -&gt;
 858             def proj = project(projname)
 859             if (proj.hasProperty(&quot;moduleName&quot;)) {
 860                 String moduleName = proj.ext.moduleName
 861                 File dir;
 862                 if (test &amp;&amp; proj.sourceSets.hasProperty(&#39;shims&#39;)) {
 863                     dir = file(&quot;${rootProject.buildDir}/shims/${moduleName}&quot;)
 864                 } else {
 865                     dir = file(&quot;${rootProject.buildDir}/sdk/lib/${moduleName}.jar&quot;)
 866                 }
 867                 if (mp == null) {
 868                     mp = dir.path
 869                 } else {
 870                     mp = mp + File.pathSeparator + dir.path
 871                 }
 872             }
 873         }
 874 
 875         // in some cases like base we could end up with an empty
 876         // path... make sure we don&#39;t pass one back
 877         if (mp == null) {
 878             return null
 879         }
 880 
 881         pma += &#39;--module-path&#39;
 882         pma += mp
 883 
 884         String addm = null
 885         deps.each {String projname -&gt;
 886             def proj = project(projname)
 887             if (proj.hasProperty(&quot;moduleName&quot;) &amp;&amp; proj.buildModule) {
 888                 if (addm == null) {
 889                     addm = proj.moduleName
 890                 } else {
 891                     addm = addm + &quot;,&quot; + proj.moduleName
 892                 }
 893             }
 894         }
 895         if (addm != null) {
 896             pma += &quot;--add-modules=${addm}&quot;
 897         }
 898     }
 899 
 900     if (includeJLP) {
 901         pma += &quot;-Djava.library.path=&quot; + computeLibraryPath(true).join(File.pathSeparator)
 902     }
 903 
 904     return pma
 905 }
 906 
 907 // Return a list containing the --upgrade-module-path or --module-path
 908 // used with Javac
 909 List&lt;String&gt; computeModulePathArgs(String  pname, List&lt;String&gt; deps, boolean test) {
 910     List&lt;String&gt; mpa = HAS_JAVAFX_MODULES ? [ &#39;--upgrade-module-path&#39; ] : [ &#39;--module-path&#39; ]
 911     String mp = null
 912     deps.each { String projname -&gt;
 913         def proj = project(projname)
 914         // for a non test set of args, we don&#39;t want the current module in the list
 915         // for a test test, we do need it to update what we built
 916 
 917         if (proj.hasProperty(&quot;moduleName&quot;) &amp;&amp;
 918                 proj.buildModule &amp;&amp;
 919                 !(!test &amp;&amp; proj.name.equals(pname))) {
 920 
 921             File dir;
 922             if (test &amp;&amp; proj.sourceSets.hasProperty(&#39;shims&#39;)) {
 923                 dir = new File(proj.sourceSets.shims.java.outputDir, proj.ext.moduleName);
 924             } else {
 925                 dir = new File(proj.sourceSets.main.java.outputDir, proj.ext.moduleName);
 926             }
 927             if (mp == null) {
 928                 mp = dir.path
 929             } else {
 930                 mp = mp + File.pathSeparator + dir.path
 931             }
 932         }
 933     }
 934 
 935     // in some cases like base we could end up with an empty
 936     // path... make sure we don&#39;t pass one back
 937     if (mp == null) {
 938         return null
 939     }
 940 
 941     mpa += mp
 942 
 943     if (!HAS_JAVAFX_MODULES) {
 944         String addm = null
 945         deps.each {String projname -&gt;
 946             def proj = project(projname)
 947             // for a non test set of args, we don&#39;t want the current module in the list
 948             // for a test test, we do need it to update what we built
 949 
 950             if (proj.hasProperty(&quot;moduleName&quot;) &amp;&amp;
 951                     proj.buildModule &amp;&amp;
 952                     !(!test &amp;&amp; proj.name.equals(pname))) {
 953 
 954                 if (addm == null) {
 955                     addm = proj.moduleName
 956                 } else {
 957                     addm = addm + &quot;,&quot; + proj.moduleName
 958                 }
 959             }
 960         }
 961         if (addm != null) {
 962             mpa += &quot;--add-modules=${addm}&quot;
 963         }
 964     }
 965 
 966     return mpa
 967 }
 968 
 969 
 970 void writeRunArgsFile(File dest, List&lt;String&gt; libpath, List&lt;String&gt; modpath, List&lt;String&gt; modules) {
 971 
 972     dest.delete()
 973 
 974     logger.info(&quot;Creating file ${dest.path}&quot;)
 975 
 976     if (libpath != null) {
 977         dest &lt;&lt;  &quot;-Djava.library.path=\&quot;\\\n&quot;
 978         libpath.each() { e-&gt;
 979             dest &lt;&lt; &quot;  &quot;
 980             dest &lt;&lt; e
 981             dest &lt;&lt; File.pathSeparator
 982             dest &lt;&lt; &quot;\\\n&quot;
 983         }
 984         dest &lt;&lt;  &quot;  \&quot;\n&quot;
 985     }
 986 
 987     if (HAS_JAVAFX_MODULES) {
 988         modpath.each { e -&gt;
 989             dest &lt;&lt;  &quot;--patch-module=\&quot;&quot;
 990             dest &lt;&lt; e
 991             dest &lt;&lt; &quot;\&quot;\n&quot;
 992         }
 993     } else {
 994         if (modpath.size() == 1) {
 995             dest &lt;&lt;  &quot;--module-path=\&quot;&quot;
 996             dest &lt;&lt; modpath[0]
 997             dest &lt;&lt; &quot;\&quot;\n&quot;
 998         } else {
 999             dest &lt;&lt;  &quot;--module-path=\&quot;\\\n&quot;
1000             modpath.each() { e-&gt;
1001                 dest &lt;&lt; &quot;  &quot;
1002                 dest &lt;&lt; e
1003                 dest &lt;&lt; File.pathSeparator
1004                 dest &lt;&lt; &quot;\\\n&quot;
1005             }
1006             dest &lt;&lt;  &quot;  \&quot;\n&quot;
1007         }
1008     }
1009 
1010     if (modules != null) {
1011         dest &lt;&lt;  &quot;--add-modules=&quot;
1012         dest &lt;&lt; modules.join(&quot;,&quot;)
1013         dest &lt;&lt; &quot;\n&quot;
1014     }
1015 }
1016 
1017 // perform common project manipulation for modules
1018 void commonModuleSetup(Project p, List&lt;String&gt; moduleChain) {
1019 
1020     p.ext.moduleChain = moduleChain
1021 
1022     if (p.hasProperty(&quot;moduleName&quot;)) {
1023         p.ext.moduleDir = new File (p.sourceSets.main.java.outputDir, &quot;${p.moduleName}&quot;)
1024         if (p.sourceSets.hasProperty(&#39;shims&#39;)) {
1025             p.ext.moduleShimsDir = new File (p.sourceSets.shims.java.outputDir, &quot;${p.moduleName}&quot;)
1026         }
1027     }
1028 
1029     def mpa = computeModulePathArgs(p.name, moduleChain, false)
1030     if (mpa != null) {
1031         p.ext.modulePathArgs = mpa
1032     }
1033 
1034     p.ext.testModulePathArgs = computePatchModuleArgs(moduleChain, true, false)
1035     p.ext.patchModuleArgs = computePatchModuleArgs(moduleChain ,false, true)
1036     p.ext.testPatchModuleArgs = computePatchModuleArgs(moduleChain, true, true)
1037 
1038     moduleChain.each() {e -&gt;
1039         if (!e.equals(p.name)) {
1040             p.compileJava.dependsOn(project(e).classes)
1041             p.compileTestJava.dependsOn(project(e).testClasses)
1042         }
1043     }
1044 
1045     // read in any addExports file
1046     File addExportsFile = new File(p.projectDir,&quot;src/test/addExports&quot;)
1047     if (addExportsFile.exists()) {
1048         List&lt;String&gt; ae = []
1049         addExportsFile.eachLine { line -&gt;
1050             line = line.trim()
1051             if (!(line.startsWith(&quot;#&quot;) || line.equals(&quot;&quot;))) {
1052                 ae += line.split(&#39; &#39;)
1053             }
1054         }
1055         p.ext.testAddExports  = ae.flatten()
1056     }
1057 
1058     // read in the temporary addExports file EXTRAADDEXPORTS)
1059     //
1060     // These extra --add-exports will be used in two places and so we
1061     // create/modify two items:
1062     // p.testAddExports - add the extra items so they are included in test builds
1063     //
1064     // p.extraAddExports - for use in any other place where we don&#39;t automatically update
1065     //    for example any non modular, non &#39;test&#39; compile, any compile that does not
1066     //    use a module-source-path that includes the dependent modules
1067     //
1068     // Note that we don&#39;t modify the modular build (main, shims) because they use
1069     // module-info directly, and we don&#39;t want to cover up any missing items there.
1070     //
1071     if (!rootProject.hasProperty(&quot;EXTRA_ADDEXPORTS_ARGS&quot;)) {
1072         List&lt;String&gt; extraAddExportsList = []
1073         String fullae = &quot;&quot;
1074         File tmpaddExportsFile = new File(rootProject.projectDir, EXTRAADDEXPORTS)
1075         if (tmpaddExportsFile.exists()) {
1076             String nl = System.getProperty(&quot;line.separator&quot;)
1077             tmpaddExportsFile.eachLine { line -&gt;
1078                 line = line.trim()
1079                 fullae += line + nl
1080                 if (!(line.startsWith(&quot;#&quot;) || line.equals(&quot;&quot;))) {
1081                     extraAddExportsList += line.split(&#39; &#39;)
1082                 }
1083             }
1084         }
1085         // This string is used in the creation of the build/*.args files
1086         // so we preserve comments
1087         if (!extraAddExportsList.isEmpty()) {
1088             rootProject.ext.EXTRA_ADDEXPORTS_STRING = fullae
1089         }
1090         rootProject.ext.EXTRA_ADDEXPORTS_ARGS = extraAddExportsList
1091     }
1092 
1093     if (HAS_JAVAFX_MODULES) {
1094         // use this variable, because it shows we have a non empty addition
1095         if (rootProject.hasProperty(&quot;EXTRA_ADDEXPORTS_STRING&quot;)) {
1096             p.ext.extraAddExports = EXTRA_ADDEXPORTS_ARGS.flatten()
1097             if (p.hasProperty(&quot;testAddExports&quot;)) {
1098                 p.testAddExports += EXTRA_ADDEXPORTS_ARGS.flatten()
1099             }
1100         }
1101     }
1102 }
1103 
1104 if (BUILD_TOOLS_DOWNLOAD_SCRIPT != &quot;&quot;) {
1105     println &quot;Include build tools download script:${BUILD_TOOLS_DOWNLOAD_SCRIPT}&quot;
1106     apply from: BUILD_TOOLS_DOWNLOAD_SCRIPT
1107 }
1108 
1109 // Now we need to define the native compilation tasks. The set of parameters to
1110 // native compilation depends on the target platform (and also to some extent what platform
1111 // you are compiling on). These settings are contained in various gradle files
1112 // such as mac.gradle and linux.gradle and armhf.gradle. Additionally, the developer
1113 // can specify COMPILE_FLAGS_FILE to be a URL or path to a different gradle file
1114 // that will contain the appropriate flags.
1115 defineProperty(&quot;COMPILE_FLAGS_FILES&quot;, COMPILE_TARGETS.split(&quot;,&quot;).collect {&quot;buildSrc/${it.trim()}.gradle&quot;}.join(&quot;,&quot;))
1116 if (COMPILE_TARGETS == &quot;all&quot;) {
1117     def tmp = []
1118     File buildSrcDir = file(&quot;buildSrc&quot;)
1119     buildSrcDir.listFiles().each { File f -&gt;
1120         if (f.isFile() &amp;&amp; f.name.endsWith(&quot;.gradle&quot;) &amp;&amp; !f.name.equals(&quot;build.gradle&quot;)) {
1121             def target = f.name.substring(0, f.name.lastIndexOf(&#39;.gradle&#39;)).toUpperCase(Locale.ROOT)
1122             apply from: f
1123             if (project.ext[&quot;${target}&quot;].canBuild) {
1124                 tmp.add(target)
1125             }
1126         }
1127     }
1128     COMPILE_FLAGS_FILES = tmp.collect { &quot;buildSrc/${it}.gradle&quot;}.join(&quot;,&quot;)
1129     COMPILE_TARGETS = tmp.collect { &quot;${it.toLowerCase()}&quot;}.join(&quot;,&quot;)
1130 } else {
1131     COMPILE_FLAGS_FILES.split(&quot;,&quot;).each {
1132         logger.info(&quot;Applying COMPILE_FLAGS_FILE &#39;$it&#39;&quot;)
1133         apply from: it
1134     }
1135 }
1136 
1137 if (COMPILE_TARGETS != &quot;&quot;) {
1138     def tmp = []
1139     COMPILE_TARGETS.split(&quot;,&quot;).each {target -&gt;
1140         if (project.ext[&quot;${target.toUpperCase(Locale.ROOT)}&quot;].canBuild) {
1141             tmp.add(target)
1142         }
1143     }
1144     COMPILE_TARGETS = tmp.collect { &quot;${it.toLowerCase()}&quot;}.join(&quot;,&quot;)
1145 }
1146 
1147 // Sanity check the expected properties all exist
1148 compileTargets { t -&gt;
1149     // Every platform must define these variables
1150     if (!project.hasProperty(t.upper)) throw new Exception(&quot;ERROR: Incorrectly configured compile flags file, missing ${t.name} property&quot;)
1151     def props = project.ext[t.upper];
1152     // TODO: we could remove libDest in favor of modLibDest
1153     [&quot;compileSwing&quot;, &quot;compileSWT&quot;, &quot;libDest&quot;].each { prop -&gt;
1154         if (!props.containsKey(prop)) throw new Exception(&quot;ERROR: Incorrectly configured compile flags file, missing ${prop} property on ${t.name}&quot;)
1155     }
1156 }
1157 
1158 // Various build flags may be set by the different target files, such as
1159 // whether to build Swing, SWT, etc. We iterate over all
1160 // compile targets and look for these settings in our properties. Note that
1161 // these properties cannot be set from the command line, but are set by
1162 // the target build files such as armv6hf.gradle or mac.gradle.
1163 ext.COMPILE_SWING = false;
1164 ext.COMPILE_SWT = false;
1165 compileTargets { t -&gt;
1166     def targetProperties = project.rootProject.ext[t.upper]
1167 
1168     if (targetProperties.compileSwing) COMPILE_SWING = true
1169     if (targetProperties.compileSWT) COMPILE_SWT = true
1170 
1171     if (!targetProperties.containsKey(&#39;compileWebnodeNative&#39;)) {
1172         // unless specified otherwise, we will compile native Webnode if IS_COMPILE_WEBKIT
1173         targetProperties.compileWebnodeNative = true
1174     }
1175 
1176     if (!targetProperties.containsKey(&#39;compileMediaNative&#39;)) {
1177         // unless specified otherwise, we will compile native Media if IS_COMPILE_MEDIA
1178         targetProperties.compileMediaNative = true
1179     }
1180 
1181     if (!targetProperties.containsKey(&#39;includeSWT&#39;)) targetProperties.includeSWT = true
1182     if (!targetProperties.containsKey(&#39;includeSwing&#39;)) targetProperties.includeSwing = true
1183     if (!targetProperties.containsKey(&#39;includeNull3d&#39;)) targetProperties.includeNull3d = true
1184     if (!targetProperties.containsKey(&#39;includeMonocle&#39;)) targetProperties.includeMonocle = false
1185     if (!targetProperties.containsKey(&#39;includeEGL&#39;)) targetProperties.includeEGL = false
1186 
1187     if (!targetProperties.containsKey(&#39;includeGTK&#39;)) targetProperties.includeGTK = IS_LINUX
1188 
1189     if (!targetProperties.containsKey(&#39;modLibDest&#39;)) targetProperties.modLibDest = targetProperties.libDest
1190 
1191     // This value is used as a prefix for various directories under ./build,
1192     // such as sdk, to allow for a common name for the hosted build
1193     // (for use when building apps) and a unique name for cross builds.
1194     if (rootProject.defaultHostTarget.equals(t.name)) {
1195         // use a simple common default for the &quot;host&quot; build
1196         targetProperties.platformPrefix=&quot;&quot;
1197     } else {
1198         // and a more complex one for cross builds
1199         targetProperties.platformPrefix=&quot;${t.name}-&quot;
1200     }
1201 }
1202 
1203 /******************************************************************************
1204  *                                                                            *
1205  *                         Build Setup Sanity Checks                          *
1206  *                                                                            *
1207  *  Here we do a variety of checks so that if the version of Java you are     *
1208  *  building with is misconfigured, or you are using the wrong version of     *
1209  *  gradle, etc you will get some kind of helpful error / warning message     *
1210  *                                                                            *
1211  *****************************************************************************/
1212 
1213 // Sanity check that we actually have a list of compile targets to execute
1214 if (COMPILE_TARGETS == null || COMPILE_TARGETS == &quot;&quot;) {
1215     throw new Exception(&quot;Unable to determine compilation platform, must specify valid COMPILE_TARGETS!&quot;)
1216 }
1217 
1218 // Verify that CONF is something useful
1219 if (CONF != &quot;Release&quot; &amp;&amp; CONF != &quot;Debug&quot; &amp;&amp; CONF != &quot;DebugNative&quot;) {
1220     logger.warn(&quot;Unknown configuration CONF=&#39;$CONF&#39;. Treating as &#39;Release&#39;&quot;)
1221 }
1222 
1223 // If the number of compile threads is less than 1 then we have a problem!
1224 if (Integer.parseInt(NUM_COMPILE_THREADS.toString()) &lt; 1) {
1225     logger.warn(&quot;NUM_COMPILE_THREADS was specified as &#39;$NUM_COMPILE_THREADS&#39; which is less than the minimum value of 1. &quot; +
1226             &quot;Building with a value of 1 instead.&quot;)
1227     NUM_COMPILE_THREADS = 1
1228 }
1229 
1230 // Check gradle version
1231 if (gradle.gradleVersion != jfxGradleVersion) {
1232     def ver = gradle.gradleVersion.split(&quot;[\\.]&quot;);
1233     def verMin = jfxGradleVersionMin.split(&quot;[\\.]&quot;);
1234     def gradleMajor = Integer.parseInt(ver[0]);
1235     def gradleMinor = Integer.parseInt(ver[1].split(&quot;[^0-9]&quot;)[0]);
1236     def gradleMajorMin = Integer.parseInt(verMin[0]);
1237     def gradleMinorMin = Integer.parseInt(verMin[1].split(&quot;[^0-9]&quot;)[0]);
1238     def err = &quot;&quot;;
1239     if (gradleMajor &lt; gradleMajorMin || (gradleMajor == gradleMajorMin &amp;&amp; gradleMinor &lt; gradleMinorMin)) {
1240         err = &quot;Gradle version too old: ${gradle.gradleVersion}; must be at least ${jfxGradleVersionMin}&quot;
1241     }
1242 
1243     if (IS_GRADLE_VERSION_CHECK &amp;&amp; err != &quot;&quot;) {
1244         fail(err);
1245     }
1246 
1247     logger.warn(&quot;*****************************************************************&quot;);
1248     logger.warn(&quot;Unsupported gradle version $gradle.gradleVersion in use.&quot;);
1249     logger.warn(&quot;Only version $jfxGradleVersion is supported. Use this version at your own risk&quot;);
1250     if ( err != &quot;&quot;) logger.warn(err);
1251     logger.warn(&quot;*****************************************************************&quot;);
1252 }
1253 
1254 // Look for stub runtime in bundled sdk, standalone sdk, or boot JDK
1255 
1256 // Allows automatic provisioning of webkit+media shared libraries
1257 // from official OpenJFX releases, downloaded from MavenCentral
1258 defineProperty(&quot;STUB_RUNTIME_OPENJFX&quot;, &quot;&quot;)
1259 ext.IS_STUB_RUNTIME_OPENJFX = !STUB_RUNTIME_OPENJFX.isBlank()
1260 
1261 def String cachedBundledRuntime = cygpath(&quot;$projectDir&quot;) + &quot;/../caches/modular-sdk&quot;
1262 def String cachedStandaloneRuntime = cygpath(&quot;$projectDir&quot;) + &quot;/../caches/sdk&quot;
1263 def String jdkStubRuntime = cygpath(&quot;$JDK_HOME&quot;)
1264 def String openjfxStubRuntime = cygpath(&quot;$projectDir&quot;) + &quot;/buildSrc/build/openjfxStub&quot;
1265 
1266 def defaultStubRuntime = &quot;&quot;
1267 if (file(cachedBundledRuntime).exists()) {
1268     defaultStubRuntime = cachedBundledRuntime
1269 } else if (file(cachedStandaloneRuntime).exists()) {
1270     defaultStubRuntime = cachedStandaloneRuntime
1271 } else if (BUILD_CLOSED) {
1272     defaultStubRuntime = cachedBundledRuntime
1273 } else if (IS_STUB_RUNTIME_OPENJFX) {
1274     defaultStubRuntime = openjfxStubRuntime
1275 } else {
1276     defaultStubRuntime = jdkStubRuntime
1277 }
1278 
1279 defineProperty(&quot;STUB_RUNTIME&quot;, defaultStubRuntime)
1280 
1281 if (STUB_RUNTIME.endsWith(&quot;/modular-sdk&quot;)) {
1282     def stubModulesLib = &quot;$STUB_RUNTIME/modules_libs&quot;
1283     defineProperty(&quot;MEDIA_STUB&quot;, &quot;$stubModulesLib/javafx.media&quot;)
1284     defineProperty(&quot;WEB_STUB&quot;, &quot;$stubModulesLib/javafx.web&quot;)
1285 } else {
1286     def libraryStub = IS_WINDOWS ? &quot;$STUB_RUNTIME/bin&quot; : &quot;$STUB_RUNTIME/lib&quot;
1287 
1288     defineProperty(&quot;MEDIA_STUB&quot;, libraryStub)
1289     defineProperty(&quot;WEB_STUB&quot;, libraryStub)
1290 }
1291 
1292 ext.UPDATE_STUB_CACHE = (BUILD_CLOSED &amp;&amp; STUB_RUNTIME != &quot;&quot; &amp;&amp; !file(STUB_RUNTIME).isDirectory())
1293 
1294 
1295 /******************************************************************************
1296  *                                                                            *
1297  *                      Logging of Properties and Settings                    *
1298  *                                                                            *
1299  *  Log some of the settings we&#39;ve determined. We could log more here, it     *
1300  *  doesn&#39;t really hurt.                                                      *
1301  *                                                                            *
1302  *****************************************************************************/
1303 
1304 logger.quiet(&quot;gradle.gradleVersion: $gradle.gradleVersion&quot;)
1305 logger.quiet(&quot;OS_NAME: $OS_NAME&quot;)
1306 logger.quiet(&quot;OS_ARCH: $OS_ARCH&quot;)
1307 logger.quiet(&quot;JAVA_HOME: $JAVA_HOME&quot;)
1308 logger.quiet(&quot;JDK_HOME: $JDK_HOME&quot;)
1309 logger.quiet(&quot;java.runtime.version: ${javaRuntimeVersion}&quot;)
1310 logger.quiet(&quot;java version: ${javaVersion}&quot;)
1311 logger.quiet(&quot;java build number: ${javaBuildNumber}&quot;)
1312 logger.quiet(&quot;jdk.runtime.version: ${jdkRuntimeVersion}&quot;)
1313 logger.quiet(&quot;jdk version: ${jdkVersion}&quot;)
1314 logger.quiet(&quot;jdk build number: ${jdkBuildNumber}&quot;)
1315 logger.quiet(&quot;minimum jdk version: ${jfxBuildJdkVersionMin}&quot;)
1316 logger.quiet(&quot;minimum jdk build number: ${jfxBuildJdkBuildnumMin}&quot;)
1317 
1318 if (IS_LINUX) {
1319     logger.quiet(&quot;GCC version: ${jfxBuildLinuxGccVersion}&quot;)
1320 } else if (IS_WINDOWS) {
1321     logger.quiet(&quot;MSVC version: ${jfxBuildWindowsMsvcVersion}&quot;)
1322 } else if (IS_MAC) {
1323     logger.quiet(&quot;XCODE version: ${jfxBuildMacosxXcodeVersion}&quot;)
1324 }
1325 logger.quiet(&quot;cmake version: ${jfxBuildCmakeVersion}&quot;)
1326 logger.quiet(&quot;ninja version: ${jfxBuildNinjaVersion}&quot;)
1327 logger.quiet(&quot;ant version: ${jfxBuildAntVersion}&quot;)
1328 
1329 logger.quiet(&quot;HAS_JAVAFX_MODULES: $HAS_JAVAFX_MODULES&quot;)
1330 logger.quiet(&quot;STUB_RUNTIME: $STUB_RUNTIME&quot;)
1331 logger.quiet(&quot;CONF: $CONF&quot;)
1332 logger.quiet(&quot;NUM_COMPILE_THREADS: $NUM_COMPILE_THREADS&quot;)
1333 logger.quiet(&quot;COMPILE_TARGETS: $COMPILE_TARGETS&quot;)
1334 logger.quiet(&quot;COMPILE_FLAGS_FILES: $COMPILE_FLAGS_FILES&quot;)
1335 logger.quiet(&quot;HUDSON_JOB_NAME: $HUDSON_JOB_NAME&quot;)
1336 logger.quiet(&quot;HUDSON_BUILD_NUMBER: $HUDSON_BUILD_NUMBER&quot;)
1337 logger.quiet(&quot;PROMOTED_BUILD_NUMBER: $PROMOTED_BUILD_NUMBER&quot;)
1338 logger.quiet(&quot;PRODUCT_NAME: $PRODUCT_NAME&quot;)
1339 logger.quiet(&quot;RELEASE_VERSION: $RELEASE_VERSION&quot;)
1340 logger.quiet(&quot;RELEASE_SUFFIX: $RELEASE_SUFFIX&quot;)
1341 logger.quiet(&quot;RELEASE_VERSION_SHORT: $RELEASE_VERSION_SHORT&quot;)
1342 logger.quiet(&quot;RELEASE_VERSION_LONG: $RELEASE_VERSION_LONG&quot;)
1343 logger.quiet(&quot;RELEASE_VERSION_PADDED: $RELEASE_VERSION_PADDED&quot;)
1344 logger.quiet(&quot;MAVEN_PUBLISH: $MAVEN_PUBLISH&quot;)
1345 logger.quiet(&quot;MAVEN_VERSION: $MAVEN_VERSION&quot;)
1346 logger.quiet(&quot;UPDATE_STUB_CACHE: $UPDATE_STUB_CACHE&quot;)
1347 
1348 /******************************************************************************
1349  *                                                                            *
1350  *                Definition of Native Code Compilation Tasks                 *
1351  *                                                                            *
1352  *    - CCTask compiles native code. Specifically it will compile .m, .c,     *
1353  *      .cpp, or .cc files. It uses the headers provided by running           *
1354  *      &#39;javac -h&#39; plus additional platform specific headers. It will         *
1355  *      compile into .obj files.                                              *
1356  *    - LinkTask will perform native linking and create the .dll / .so /      *
1357  *      .dylib as necessary.                                                  *
1358  *                                                                            *
1359  *****************************************************************************/
1360 
1361 // Save a reference to the buildSrc.jar file because we need it for actually
1362 // compiling things, not just for the sake of this build script
1363 // (such as generating the JSL files, etc)
1364 ext.BUILD_SRC = rootProject.files(&quot;buildSrc/build/libs/buildSrc.jar&quot;)
1365 
1366 /**
1367  * Convenience method for creating cc, link, and &quot;native&quot; tasks in the given project. These
1368  * tasks are parameterized by name, so that we can produce, for example, ccGlass, etc
1369  * named tasks.
1370  *
1371  * @param project The project to add tasks to
1372  * @param name The name of the project, such as &quot;prism-common&quot;. This name is used
1373  *        in the name of the generated task, such as ccPrismCommon, and also
1374  *        in the name of the final library, such as libprism-common.dylib.
1375  */
1376 void addNative(Project project, String name) {
1377     // TODO if we want to handle 32/64 bit windows in the same build,
1378     // Then we will need to modify the win compile target to be win32 or win64
1379     def capitalName = name.split(&quot;-&quot;).collect{it.capitalize()}.join()
1380     def nativeTask = project.task(&quot;native$capitalName&quot;, group: &quot;Build&quot;) {
1381         description = &quot;Generates JNI headers, compiles, and builds native dynamic library for $name for all compile targets&quot;
1382     }
1383     def cleanTask = project.task(&quot;cleanNative$capitalName&quot;, type: Delete, group: &quot;Build&quot;) {
1384         description = &quot;Clean native objects for $name&quot;
1385     }
1386     if (project.hasProperty(&quot;nativeAllTask&quot;)) project.nativeAllTask.dependsOn nativeTask
1387     project.assemble.dependsOn(nativeTask)
1388     if (project.hasProperty(&quot;cleanNativeAllTask&quot;)) project.cleanNativeAllTask.dependsOn cleanTask
1389 
1390     // Each of the different compile targets will be placed in a sub directory
1391     // of these root dirs, with the name of the dir being the name of the target
1392     def nativeRootDir = project.file(&quot;$project.buildDir/native/$name&quot;)
1393     def libRootDir = project.file(&quot;$project.buildDir/libs/$name&quot;)
1394     // For each compile target, create a cc / link pair
1395     compileTargets { t -&gt;
1396         def targetProperties = project.rootProject.ext[t.upper]
1397         def library = targetProperties.library
1398         def properties = targetProperties.get(name)
1399         def nativeDir = file(&quot;$nativeRootDir/${t.name}&quot;)
1400         def headerDir = file(&quot;${project.buildDir}/gensrc/headers/${project.moduleName}&quot;)
1401 
1402         // If there is not a library clause in the properties, assume it is not wanted
1403         if (!targetProperties.containsKey(name)) {
1404             println(&quot;Ignoring native library ${name}. Not defined in ${t.name} project properties&quot;);
1405             return
1406         }
1407 
1408         // check for the property disable${name} = true
1409         def String disableKey = &quot;disable${name}&quot;
1410         def boolean disabled = targetProperties.containsKey(disableKey) ? targetProperties.get(disableKey) : false
1411         if (disabled) {
1412             println(&quot;Native library ${name} disabled in ${t.name} project properties&quot;);
1413             return
1414         }
1415 
1416         def variants = properties.containsKey(&quot;variants&quot;) ? properties.variants : [&quot;&quot;];
1417         variants.each { variant -&gt;
1418             def variantProperties = variant == &quot;&quot; ? properties : properties.get(variant)
1419             def capitalVariant = variant.capitalize()
1420             def ccOutput = variant == &quot;&quot; ? nativeDir : file(&quot;$nativeDir/$variant&quot;)
1421             def ccTask = project.task(&quot;cc${t.capital}$capitalName$capitalVariant&quot;, type: CCTask, group: &quot;Build&quot;) {
1422                 description = &quot;Compiles native sources for ${name} for ${t.name}${capitalVariant != &#39;&#39; ? &#39; for variant &#39; + capitalVariant : &#39;&#39;}&quot;
1423                 matches = &quot;.*\\.c|.*\\.cpp|.*\\.m|.*\\.cc&quot;
1424                 headers = headerDir
1425                 output(ccOutput)
1426                 params.addAll(variantProperties.ccFlags)
1427                 compiler = variantProperties.compiler
1428                 source(variantProperties.nativeSource)
1429                 cleanTask.delete ccOutput
1430             }
1431             def linkTask = project.task(&quot;link${t.capital}$capitalName$capitalVariant&quot;, type: LinkTask, dependsOn: ccTask, group: &quot;Build&quot;) {
1432                 description = &quot;Creates native dynamic library for $name for ${t.name}${capitalVariant != &#39;&#39; ? &#39; for variant &#39; + capitalVariant : &#39;&#39;}&quot;
1433                 objectDir = ccOutput
1434                 linkParams.addAll(variantProperties.linkFlags)
1435                 lib = file(&quot;$libRootDir/${t.name}/${variant == &#39;&#39; ? library(properties.lib) : library(variantProperties.lib)}&quot;)
1436                 linker = variantProperties.linker
1437                 cleanTask.delete &quot;$libRootDir/${t.name}&quot;
1438             }
1439             nativeTask.dependsOn(linkTask)
1440             if (IS_WINDOWS &amp;&amp; t.name == &quot;win&quot; &amp;&amp; (!IS_STATIC_BUILD || name == &quot;glass&quot;)) {
1441                 def rcTask = project.task(&quot;rc$capitalName$capitalVariant&quot;, type: CompileResourceTask, group: &quot;Build&quot;) {
1442                     description = &quot;Compiles native sources for $name&quot;
1443                     matches = &quot;.*\\.rc&quot;
1444                     compiler = variantProperties.rcCompiler
1445                     source(variantProperties.rcSource)
1446                     if (variantProperties.rcFlags) {
1447                         rcParams.addAll(variantProperties.rcFlags)
1448                     }
1449                     output(ccOutput)
1450                 }
1451                 linkTask.dependsOn rcTask;
1452             }
1453         }
1454 
1455         def useLipo = targetProperties.containsKey(&#39;useLipo&#39;) ? targetProperties.useLipo : false
1456         if (useLipo) {
1457             def lipoTask = project.task(&quot;lipo${t.capital}$capitalName&quot;, type: LipoTask, group: &quot;Build&quot;) {
1458                 description = &quot;Creates native fat library for $name for ${t.name}&quot;
1459                 libDir = file(&quot;$libRootDir/${t.name}&quot;)
1460                 lib = file(&quot;$libRootDir/${t.name}/${library(properties.lib)}&quot;)
1461             }
1462             nativeTask.dependsOn(lipoTask)
1463         }
1464     }
1465 }
1466 
1467 void addJSL(Project project, String name, String pkg, List&lt;String&gt; addExports, Closure compile) {
1468     def lowerName = name.toLowerCase()
1469 
1470     def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
1471     modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.base/build/classes/java/main&quot;
1472     def compileCompilers = project.task(&quot;compile${name}Compilers&quot;,
1473             type: JavaCompile,
1474             dependsOn: project.compileJava) {
1475         description = &quot;Compile the $name JSL Compilers&quot;
1476 
1477         classpath =
1478                project.files(project.sourceSets.jslc.java.outputDir) +
1479                project.configurations.antlr
1480         source = [project.file(&quot;src/main/jsl-$lowerName&quot;)]
1481         destinationDir = project.file(&quot;$project.buildDir/classes/jsl-compilers/$lowerName&quot;)
1482 
1483         options.compilerArgs.addAll([
1484             &quot;-implicit:none&quot;,
1485             &quot;--module-path&quot;, modulePath,
1486             &quot;--add-modules=javafx.graphics&quot;
1487             ])
1488         if (addExports != null) {
1489             options.compilerArgs.addAll(addExports)
1490         }
1491     }
1492 
1493     def generateShaders = project.task(&quot;generate${name}Shaders&quot;,
1494             dependsOn: compileCompilers) {
1495         description = &quot;Generate $name shaders from JSL&quot;
1496         def sourceDir = project.file(&quot;src/main/jsl-$lowerName&quot;)
1497         def destinationDir = project.file(&quot;$project.buildDir/gensrc/jsl-$lowerName&quot;)
1498         inputs.dir sourceDir
1499         outputs.dir destinationDir
1500         doLast {
1501             compile(sourceDir, destinationDir)
1502         }
1503     }
1504 
1505     def compileHLSLShaders = project.task(&quot;compile${name}HLSLShaders&quot;,
1506             dependsOn: generateShaders,
1507             type: CompileHLSLTask) {
1508         enabled = IS_WINDOWS
1509         description = &quot;Compile $name HLSL files into .obj files&quot;
1510         matches = &quot;.*\\.hlsl&quot;
1511         output project.file(&quot;$project.buildDir/hlsl/$name/$pkg&quot;)
1512         source project.file(&quot;$project.buildDir/gensrc/jsl-$lowerName/$pkg&quot;)
1513     }
1514 
1515     def processShaders = project.task(&quot;process${name}Shaders&quot;,
1516             dependsOn: [generateShaders, compileHLSLShaders],
1517             type: Copy,
1518             description: &quot;Copy hlsl / frag shaders to build/resources/jsl-$lowerName&quot;) {
1519         from(&quot;$project.buildDir/hlsl/$name&quot;) {
1520             include &quot;**/*.obj&quot;
1521         }
1522         from(&quot;$project.buildDir/gensrc/jsl-$lowerName&quot;) {
1523             include(&quot;**/*.frag&quot;)
1524         }
1525         into project.moduleDir
1526     }
1527 
1528     project.processShaders.dependsOn(processShaders)
1529     project.sourceSets.shaders.output.dir(&quot;$project.buildDir/gensrc/jsl-$lowerName&quot;, builtBy: processShaders )
1530 
1531     def processShimsShaders = project.task(&quot;process${name}ShimsShaders&quot;,
1532             dependsOn: [generateShaders, compileHLSLShaders],
1533             type: Copy,
1534             description: &quot;Copy hlsl / frag shaders to shims&quot;) {
1535         from(&quot;$project.buildDir/hlsl/$name&quot;) {
1536             include &quot;**/*.obj&quot;
1537         }
1538         from(&quot;$project.buildDir/gensrc/jsl-$lowerName&quot;) {
1539             include(&quot;**/*.frag&quot;)
1540         }
1541         into project.moduleShimsDir
1542     }
1543 
1544     project.processShimsShaders.dependsOn(processShimsShaders)
1545 
1546 }
1547 
1548 void addMavenPublication(Project project, List&lt;String&gt; projectDependencies) {
1549     if (!IS_MAVEN_PUBLISH) {
1550         return
1551     }
1552 
1553     project.apply plugin: &#39;maven-publish&#39;
1554 
1555     project.group = MAVEN_GROUP_ID
1556     project.version = MAVEN_VERSION
1557 
1558     if (project.name == &#39;base&#39;) {
1559         project.publishing {
1560             publications {
1561                 javafx(MavenPublication) {
1562                     artifactId = &#39;javafx&#39;
1563                     artifacts = []
1564                 }
1565             }
1566         }
1567     }
1568 
1569     gradle.taskGraph.whenReady { g -&gt;
1570         project.tasks.findAll { it.name == &#39;generatePomFileForJavafxPublication&#39;}.each { it -&gt;
1571             it.doLast {
1572                 copy {
1573                     into project.file(&quot;${project.buildDir}/publications/javafx&quot;)
1574                     from file(&quot;${rootProject.projectDir}/javafx.pom&quot;)
1575                     rename &quot;javafx.pom&quot;, &quot;pom-default.xml&quot;
1576                     filter { line -&gt;
1577                         line.replaceAll(&quot;@VERSION@&quot;, MAVEN_VERSION)
1578                     }
1579                 }
1580             }
1581         }
1582     }
1583 
1584     project.publishing {
1585         repositories {
1586             maven {
1587                 def repositoryUrl = project.hasProperty(&#39;repositoryUrl&#39;) ? project.getProperty(&#39;repositoryUrl&#39;) : &quot;&quot;
1588                 def repositoryUsername = project.hasProperty(&#39;repositoryUsername&#39;) ? project.getProperty(&#39;repositoryUsername&#39;) : &quot;&quot;
1589                 def repositoryPassword = project.hasProperty(&#39;repositoryPassword&#39;) ? project.getProperty(&#39;repositoryPassword&#39;) : &quot;&quot;
1590                 url repositoryUrl
1591                 credentials {
1592                    username repositoryUsername
1593                    password repositoryPassword
1594                 }
1595             }
1596         }
1597     }
1598 
1599     compileTargets { t -&gt;
1600         project.publishing {
1601             publications {
1602                 maven(MavenPublication) {
1603                     artifactId = &quot;javafx-${project.name}&quot;
1604 
1605                     afterEvaluate {
1606                         artifact project.tasks.&quot;moduleEmptyPublicationJar$t.capital&quot;
1607                         artifact project.tasks.&quot;modularPublicationJar$t.capital&quot; {
1608                             classifier &quot;$t.name&quot;
1609                         }
1610                     }
1611 
1612                     pom.withXml {
1613                         Node parent = asNode().appendNode(&quot;parent&quot;)
1614                         parent.appendNode(&quot;groupId&quot;, MAVEN_GROUP_ID)
1615                         parent.appendNode(&quot;artifactId&quot;, &quot;javafx&quot;)
1616                         parent.appendNode(&quot;version&quot;, MAVEN_VERSION)
1617 
1618                         Node dependencies = asNode().appendNode(&quot;dependencies&quot;)
1619 
1620                         Node projectDependencyPlatform = dependencies.appendNode(&quot;dependency&quot;)
1621                         projectDependencyPlatform.appendNode(&quot;groupId&quot;, MAVEN_GROUP_ID)
1622                         projectDependencyPlatform.appendNode(&quot;artifactId&quot;, &quot;javafx-${project.name}&quot;)
1623                         projectDependencyPlatform.appendNode(&quot;version&quot;, MAVEN_VERSION)
1624                         projectDependencyPlatform.appendNode(&quot;classifier&quot;, &quot;\${javafx.platform}&quot;)
1625 
1626                         if (!projectDependencies.empty) {
1627                             projectDependencies.each { dep -&gt;
1628                                 Node projectDependency = dependencies.appendNode(&quot;dependency&quot;)
1629                                 projectDependency.appendNode(&quot;groupId&quot;, MAVEN_GROUP_ID)
1630                                 projectDependency.appendNode(&quot;artifactId&quot;, &quot;javafx-$dep&quot;)
1631                                 projectDependency.appendNode(&quot;version&quot;, MAVEN_VERSION)
1632                            }
1633                         }
1634                     }
1635                 }
1636             }
1637 
1638         }
1639     }
1640 }
1641 
1642 /**
1643  * Verifies that all of the *.java files in a source tree have the
1644  * correct package name. If not, fail the build.
1645  *
1646  * @param sourceRoot the root of the source tree to check
1647  * @param hasModuleName true if the sources under sourceRoot are being
1648  * compiled as modules, with the immediate child directories being the
1649  * root(s) of the named modules being compiled. In this case the package
1650  * root is one directory below the sourceRoot.
1651  */
1652 void validatePackages(File sourceRoot, boolean hasModuleName) {
1653     if (!sourceRoot.isDirectory()) {
1654         return;
1655     }
1656     def err = false;
1657     String sourceString = sourceRoot.toString().replace(&quot;\\&quot;, &quot;/&quot;)
1658     def startPos = sourceString.length() + 1
1659     logger.info(&quot;validating packages for ${sourceRoot}&quot;)
1660     def inputFiles = fileTree(dir: sourceRoot, include: &quot;**/*.java&quot;)
1661     inputFiles.each { file -&gt;
1662         def packageRoot = file.toString().replace(&quot;\\&quot;, &quot;/&quot;).substring(startPos)
1663         if (hasModuleName) {
1664             packageRoot = packageRoot.substring(packageRoot.indexOf(&quot;/&quot;) + 1)
1665         }
1666         def endPos = packageRoot.lastIndexOf(&quot;/&quot;)
1667         def pkgEx = endPos &gt; -1 ?  packageRoot.substring(0, endPos).replace(&quot;/&quot;, &quot;.&quot;) : &quot;&quot;
1668         def pkg = &quot;&quot;
1669         file.withReader { reader -&gt;
1670             def line
1671             while ((line = reader.readLine()) != null) {
1672                 def words = line.trim().split(&quot;[ ;]+&quot;)
1673                 if (words.length &gt; 1 &amp;&amp; words[0] == &quot;package&quot;) {
1674                     pkg = words[1]
1675                     break;
1676                 }
1677             }
1678         }
1679         if (pkg != pkgEx) {
1680             err = true
1681             println &quot;*** ERROR: File location &lt;${file}&gt; does not match package name &lt;${pkg}&gt;&quot;
1682         }
1683     }
1684     if (err) {
1685         fail(&quot;Package validation failed&quot;)
1686     }
1687 }
1688 
1689 /**
1690  * Add a task to the given project to validate that the package names
1691  * of all java files in the given source sets have the correct package
1692  * name. If not, fail the build.
1693  */
1694 void addValidateSourceSets(Project project,
1695                            Collection&lt;SourceSet&gt; sourceSets,
1696                            Collection&lt;SourceSet&gt; modSourceSets) {
1697     def validateSourceSetsTask = project.task(&quot;validateSourceSets&quot;) {
1698         doLast {
1699             // Accumulate the root directories from all sourceSets.
1700             // We use a Set to elide duplicates (the shims sourceset
1701             // will include the dirs from the main sourceset)
1702             Set&lt;File&gt; sourceRoots = []
1703             sourceSets.each { srcSet -&gt;
1704                 srcSet.java.srcDirs.each { rootDir -&gt;
1705                     sourceRoots += rootDir
1706                 }
1707             }
1708             sourceRoots.each { rootDir -&gt;
1709                 validatePackages(rootDir, false)
1710             }
1711 
1712             Set&lt;File&gt; modSourceRoots = []
1713             modSourceSets.each { srcSet -&gt;
1714                 srcSet.java.srcDirs.each { rootDir -&gt;
1715                     modSourceRoots += rootDir
1716                 }
1717             }
1718             modSourceRoots.each { rootDir -&gt;
1719                 validatePackages(rootDir, true)
1720             }
1721         }
1722     }
1723 
1724     // Run this for all projects when compiling the test sources
1725     // (i.e., when running &quot;gradle test&quot;)
1726     project.compileTestJava.dependsOn(validateSourceSetsTask)
1727 }
1728 
1729 void addValidateSourceSets(Project project, Collection&lt;SourceSet&gt; sourceSets) {
1730     addValidateSourceSets(project, sourceSets, []);
1731 }
1732 
1733 
1734 /**
1735  * Parses a JDK version string. The string must be in one of the following
1736  * two formats:
1737  *
1738  *     major.minor.subminor
1739  * or
1740  *     major.minor.subminor_update
1741  *
1742  * In both cases a list of 4 integers is returned, with element 3 set to
1743  * 0 in the former case.
1744  */
1745 List parseJdkVersion(String version) {
1746     def arr = version.split(&quot;[_\\.]&quot;);
1747     def intArr = [];
1748     arr.each { s -&gt; intArr += Integer.parseInt(s); }
1749     while (intArr.size() &lt; 4) intArr += 0;
1750     return intArr;
1751 }
1752 
1753 /**
1754  * Returns -1, 0, or 1 depending on whether JDK version &quot;a&quot; is less than,
1755  * equal to, or grater than version &quot;b&quot;.
1756  */
1757 int compareJdkVersion(String a, String b) {
1758     def aIntArr = parseJdkVersion(a);
1759     def bIntArr = parseJdkVersion(b);
1760 
1761     for (int i = 0; i &lt; 4; i++) {
1762         if (aIntArr[i] &lt; bIntArr[i]) return -1;
1763         if (aIntArr[i] &gt; bIntArr[i]) return  1;
1764     }
1765     return 0;
1766 }
1767 
1768 // Task to verify the minimum level of Java needed to build JavaFX
1769 task verifyJava() {
1770     doLast {
1771         def status = compareJdkVersion(jdkVersion, jfxBuildJdkVersionMin);
1772         if (status &lt; 0) {
1773             fail(&quot;java version mismatch: JDK version (${jdkVersion}) &lt; minimum version (${jfxBuildJdkVersionMin})&quot;)
1774         } else if (status == 0) {
1775             def buildNum = Integer.parseInt(jdkBuildNumber)
1776             def minBuildNum = Integer.parseInt(jfxBuildJdkBuildnumMin)
1777             if (buildNum != 0 &amp;&amp; buildNum &lt; minBuildNum) {
1778                 fail(&quot;JDK build number ($buildNum) &lt; minimum build number ($minBuildNum)&quot;)
1779             }
1780         }
1781     }
1782 }
1783 
1784 task updateCacheIfNeeded() {
1785     // an empty task we can add to as needed for UPDATE_STUB_CACHE
1786 }
1787 
1788 task createTestArgfiles {
1789     // an empty task we can add to as needed
1790 }
1791 
1792 
1793 /*****************************************************************************
1794 *        Project definitions (dependencies, etc)                             *
1795 *****************************************************************************/
1796 
1797 void addJCov(p, test) {
1798     test.doFirst {
1799         def jcovJVMArgument =
1800                 &quot;include=javafx,&quot; +
1801                 &quot;include=com.sun.javafx,&quot; +
1802                 &quot;include=com.sun.glass,&quot; +
1803                 &quot;include=com.sun.openpisces,&quot; +
1804                 &quot;include=com.sun.pisces,&quot; +
1805                 &quot;include=com.sun.prism,&quot; +
1806                 &quot;include=com.sun.scenario,&quot; +
1807                 &quot;include=com.sun.webkit,&quot; +
1808                 &quot;exclude=com,&quot; +
1809                 &quot;exclude=java,&quot; +
1810                 &quot;exclude=javax,&quot; +
1811                 &quot;exclude=\&quot;**.test\&quot;,&quot; +
1812                 &quot;exclude=\&quot;**.*Test\&quot;,&quot; +
1813                 &quot;file=build/reports/jcov/report.xml,&quot; +
1814                 &quot;merge=merge&quot;;
1815         test.jvmArgs(&quot;-javaagent:${p.configurations.testCompile.files.find { it.name.startsWith(&#39;jcov&#39;) }}=$jcovJVMArgument&quot;);
1816         p.mkdir p.file(&quot;build/reports/jcov&quot;)
1817     }
1818     test.doLast {
1819         def reportFile = p.file(&quot;build/reports/jcov/report.xml&quot;)
1820         if (reportFile.exists()) {
1821             p.javaexec {
1822                 workingDir = p.file(&quot;build/reports/jcov&quot;)
1823                 classpath = p.files(p.configurations.testCompile.files.find { it.name.startsWith(&#39;jcov&#39;) })
1824                 main = &quot;com.sun.tdk.jcov.Helper&quot;
1825                 args = [
1826                         &quot;RepGen&quot;,
1827                         &quot;-exclude&quot;, &quot;\&quot;**.test\&quot;&quot;,
1828                         &quot;-exclude&quot;, &quot;\&quot;**.*Test\&quot;&quot;,
1829                         &quot;-output&quot;, &quot;.&quot;,
1830                         &quot;-source&quot;, p.sourceSets.main.java.srcDirs.collect{p.file(it)}.join(&quot;:&quot;),
1831                         &quot;report.xml&quot;
1832                 ]
1833             }
1834         }
1835     }
1836 }
1837 
1838 allprojects {
1839 
1840     // Setup the repositories that we&#39;ll download libraries from.
1841     // By default we use Maven Central for most things. The custom &quot;ivy&quot;
1842     // repo is for downloading SWT. The way it works is to setup the
1843     // download URL such that it will resolve to the actual jar file to
1844     // download. See SWT_FILE_NAME for the name of the jar that will be
1845     // used as the &quot;artifact&quot; in the pattern below.
1846     // If JFX_DEPS_URL is set, then that overrides the default
1847     // repositories. This allows the dependencies to be cached locally.
1848 
1849     if (JFX_DEPS_URL != &quot;&quot;) {
1850         repositories {
1851             ivy {
1852                 url JFX_DEPS_URL
1853                 metadataSources {
1854                     artifact()
1855                 }
1856                 patternLayout {
1857                     artifact &quot;[artifact]-[revision](-[classifier]).[ext]&quot;
1858                     artifact &quot;[artifact].[ext]&quot;
1859                 }
1860             }
1861         }
1862     }
1863 
1864     if (JFX_DEPS_URL == &quot;&quot;) {
1865         repositories {
1866             mavenCentral()
1867             ivy {
1868                 url &quot;https://download.eclipse.org/eclipse/updates/4.6/R-4.6.3-201703010400/plugins/&quot;
1869                 metadataSources {
1870                     artifact()
1871                 }
1872                 patternLayout {
1873                     artifact &quot;[artifact].[ext]&quot;
1874                 }
1875             }
1876         }
1877     }
1878 
1879     if (JFX_DEPS_URL == &quot;&quot; &amp;&amp; IS_BUILD_LIBAV_STUBS) {
1880         repositories {
1881             ivy {
1882                 url libAVRepositoryURL
1883                 metadataSources {
1884                     artifact()
1885                 }
1886                 patternLayout {
1887                     artifact &quot;[artifact].[ext]&quot;
1888                 }
1889             }
1890             ivy {
1891                 url FFmpegRepositoryURL
1892                 metadataSources {
1893                     artifact()
1894                 }
1895                 patternLayout {
1896                     artifact &quot;[artifact].[ext]&quot;
1897                 }
1898             }
1899         }
1900     }
1901 
1902     // We want to configure all projects as java projects and use the same compile settings
1903     // etc, except for the root project which we just want to ignore (and for now media)
1904     if (project == rootProject) {
1905        return
1906     }
1907     if (project.path.startsWith(&quot;:apps&quot;)) {
1908         // Lets handle the apps tree differently, as it is a collection of ant builds,
1909         // and the ant importer collides with the &#39;apply plugin:java&#39;
1910         return
1911     }
1912 
1913     // All of our projects are java projects
1914 
1915     apply plugin: &quot;java&quot;
1916     sourceCompatibility = 11
1917 
1918     // By default all of our projects require junit for testing so we can just
1919     // setup this dependency here.
1920     dependencies {
1921         testCompile group: &quot;junit&quot;, name: &quot;junit&quot;, version: &quot;4.8.2&quot;
1922         if (BUILD_CLOSED &amp;&amp; DO_JCOV)  {
1923             testCompile name: &quot;jcov&quot;
1924         }
1925     }
1926 
1927     compileJava.dependsOn verifyJava
1928 
1929     // At the moment the ASM library shipped with Gradle that is used to
1930     // discover the different test classes fails on Java 8, so in order
1931     // to have sourceCompatibility set to 1.8 I have to also turn scanForClasses off
1932     // and manually specify the includes / excludes. At the moment we use
1933     // Java 7 but when we switch to 8 this will be needed, and probably again when
1934     // we start building with Java 9.
1935     test {
1936         executable = JAVA;
1937         enableAssertions = true;
1938         testLogging.exceptionFormat = &quot;full&quot;;
1939         scanForTestClasses = false;
1940         include(&quot;**/*Test.*&quot;);
1941         if (BUILD_CLOSED &amp;&amp; DO_JCOV) {
1942             addJCov(project, test)
1943         }
1944 
1945         if (IS_HEADLESS_TEST) {
1946             systemProperty &#39;glass.platform&#39;, &#39;Monocle&#39;
1947             systemProperty &#39;monocle.platform&#39;, &#39;Headless&#39;
1948             systemProperty &#39;prism.order&#39;, &#39;sw&#39;
1949             systemProperty &#39;com.sun.javafx.gestures.zoom&#39;, &#39;true&#39;
1950             systemProperty &#39;com.sun.javafx.gestures.rotate&#39;, &#39;true&#39;
1951             systemProperty &#39;com.sun.javafx.gestures.scroll&#39;, &#39;true&#39;
1952         }
1953 
1954         systemProperty &#39;unstable.test&#39;, IS_UNSTABLE_TEST
1955     }
1956 
1957     compileTestJava {
1958     }
1959 }
1960 
1961 // These strings define the module-source-path to be used in compilation.
1962 // They need to contain the full paths to the sources and the * will be
1963 // used to infer the module name that is used.
1964 project.ext.defaultModuleSourcePath =
1965     cygpath(rootProject.projectDir.path + &#39;/modules/*/src/main/java&#39;) +
1966         File.pathSeparator  +
1967     cygpath(rootProject.projectDir.path + &#39;/modules/*/build/gensrc/{java,jsl-decora,jsl-prism}&#39;)
1968 
1969 // graphics pass one
1970 project.ext.defaultModuleSourcePath_GraphicsOne =
1971     cygpath(rootProject.projectDir.path + &#39;/modules/*/src/main/java&#39;) +
1972         File.pathSeparator  +
1973     cygpath(rootProject.projectDir.path + &#39;/modules/*/build/gensrc/{java,jsl-decora,jsl-prism}&#39;)
1974 
1975 // web pass one
1976 project.ext.defaultModuleSourcePath_WebOne =
1977     cygpath(rootProject.projectDir.path + &#39;/modules/*/src/main/java&#39;)
1978 
1979 // Compiling the test shim files too.
1980 project.ext.defaultModuleSourcePathShim =
1981     cygpath(rootProject.projectDir.path + &#39;/modules/*/src/{main,shims}/java&#39;) +
1982         File.pathSeparator  +
1983     cygpath(rootProject.projectDir.path + &#39;/modules/*/build/gensrc/{java,jsl-decora,jsl-prism}&#39;)
1984 
1985 // The &quot;base&quot; project is our first module and the most basic one required for
1986 // all other modules. It is useful even for non-GUI applications.
1987 project(&quot;:base&quot;) {
1988     project.ext.buildModule = true
1989     project.ext.includeSources = true
1990     project.ext.moduleRuntime = true
1991     project.ext.moduleName = &quot;javafx.base&quot;
1992 
1993     sourceSets {
1994         main
1995         shims {
1996             java {
1997                 compileClasspath += sourceSets.main.output
1998                 runtimeClasspath += sourceSets.main.output
1999             }
2000         }
2001         test {
2002             java {
2003                 compileClasspath += sourceSets.shims.output
2004                 runtimeClasspath += sourceSets.shims.output
2005             }
2006         }
2007     }
2008 
2009     dependencies {
2010         testCompile group: &quot;junit&quot;, name: &quot;junit&quot;, version: &quot;4.8.2&quot;
2011         testCompile sourceSets.main.output
2012         testCompile sourceSets.shims.output
2013     }
2014 
2015     commonModuleSetup(project, [ &#39;base&#39; ])
2016 
2017     project.ext.moduleSourcePath = defaultModuleSourcePath
2018     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2019 
2020     // We need to take the VersionInfo.java file and replace the various
2021     // properties within it
2022     def replacements = [
2023         &quot;BUILD_TIMESTAMP&quot;: BUILD_TIMESTAMP,
2024         &quot;HUDSON_JOB_NAME&quot;: HUDSON_JOB_NAME,
2025         &quot;HUDSON_BUILD_NUMBER&quot;: HUDSON_BUILD_NUMBER,
2026         &quot;PROMOTED_BUILD_NUMBER&quot;: PROMOTED_BUILD_NUMBER,
2027         &quot;PRODUCT_NAME&quot;: PRODUCT_NAME,
2028         &quot;RELEASE_VERSION&quot;: RELEASE_VERSION,
2029         &quot;RELEASE_SUFFIX&quot;: RELEASE_SUFFIX];
2030     task processVersionInfo(type: Copy, description: &quot;Replace params in VersionInfo and copy file to destination&quot;) {
2031         doFirst { mkdir &quot;$buildDir/gensrc/java&quot; }
2032         from &quot;src/main/version-info&quot;
2033         into &quot;$buildDir/gensrc/java/com/sun/javafx/runtime&quot;
2034         filter {line-&gt;
2035             replacements.each() {k, v -&gt;
2036                 line = line.replace(&quot;@$k@&quot;, v.toString());
2037             }
2038             line
2039         }
2040     }
2041 
2042     // Make sure to include $buildDir/gensrc/java that we previously created.
2043     // We DO NOT want to include src/main/version-info
2044 
2045     sourceSets.main.java.srcDirs += &quot;$buildDir/gensrc/java&quot;
2046 
2047     compileJava.dependsOn processVersionInfo
2048     addMavenPublication(project, [])
2049 
2050     addValidateSourceSets(project, sourceSets)
2051 }
2052 
2053 // The graphics module is needed for any graphical JavaFX application. It requires
2054 // the base module and includes the scene graph, layout, css, prism, windowing, etc.
2055 // This is a fairly complicated module. There are many different types of native components
2056 // that all need to be compiled.
2057 project(&quot;:graphics&quot;) {
2058 
2059     project.ext.buildModule = true
2060     project.ext.includeSources = true
2061     project.ext.moduleRuntime = true
2062     project.ext.moduleName = &quot;javafx.graphics&quot;
<a name="1" id="anc1"></a><span class="line-removed">2063     project.ext.mavenPublish = IS_MAVEN_PUBLISH</span>
2064 
2065     getConfigurations().create(&quot;antlr&quot;);
2066 
2067     sourceSets {
2068         jslc   // JSLC gramar subset
2069         main
2070         shims {
2071             java {
2072                 compileClasspath += sourceSets.main.output
2073                 runtimeClasspath += sourceSets.main.output
2074             }
2075         }
2076         shaders // generated shaders (prism &amp; decora)
2077         test {
2078             java {
2079                 compileClasspath += sourceSets.shims.output
2080                 runtimeClasspath += sourceSets.shims.output
2081             }
2082         }
2083         stub
2084     }
2085 
2086     dependencies {
2087         stubCompile group: &quot;junit&quot;, name: &quot;junit&quot;, version: &quot;4.8.2&quot;
2088 
2089         antlr group: &quot;org.antlr&quot;, name: &quot;antlr4&quot;, version: &quot;4.7.2&quot;, classifier: &quot;complete&quot;
2090         compile project(&#39;:base&#39;)
2091     }
2092 
2093     project.ext.moduleSourcePath = defaultModuleSourcePath_GraphicsOne
2094     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2095 
2096     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39; ])
2097 
2098     List&lt;String&gt; decoraAddExports = [
2099             &#39;--add-exports=javafx.graphics/com.sun.scenario.effect=ALL-UNNAMED&#39;,
2100             &#39;--add-exports=javafx.graphics/com.sun.scenario.effect.light=ALL-UNNAMED&#39;,
2101             &#39;--add-exports=javafx.graphics/com.sun.scenario.effect.impl.state=ALL-UNNAMED&#39;
2102             ]
2103     /*
2104     Graphics compilation is &quot;complicated&quot; by the generated shaders.
2105 
2106     We have two shader groups - Decora and Prism.
2107 
2108     The shader groups each will generate a custom compiler that
2109     then genarates the shader code. These compilers rely on the JSLC
2110     gramar parser which is antlr generated and compile separately.
2111 
2112     The decora compiler relies on compileJava - which is sourceSet.main.java
2113     It also accesses module private packages, so will need add-exports
2114 
2115     Once the shader java code is generated, we can compileFullJava
2116 
2117     After that, we can generate the required native header and then build the native code
2118     */
2119 
2120     project.task(&quot;processShaders&quot;) {
2121         // an empty task to hang the prism and decora shaders on
2122     }
2123 
2124     project.task(&quot;processShimsShaders&quot;) {
2125         // an empty task to hang the prism and decora shaders on
2126     }
2127 
2128     compileShimsJava.dependsOn(&quot;processShimsShaders&quot;)
2129 
2130     // Generate the JSLC support grammar
2131     project.task(&quot;generateGrammarSource&quot;, type: JavaExec) {
2132         // use antlr to generate our grammar.
2133         // note: the antlr plugin creates some issues with the other compiles
2134         // so we will do this by hand
2135 
2136         File wd = file(project.projectDir.path + &quot;/src/jslc/antlr&quot;)
2137         File outDir = file(&quot;$buildDir/gensrc/antlr&quot;)
2138         def inJSL = &quot;com/sun/scenario/effect/compiler/JSL.g4&quot;
2139         if (IS_WINDOWS) {
2140             // antlr needs backslashes on Windows
2141             inJSL = inJSL.replace(&quot;/&quot;, &quot;\\&quot;)
2142         }
2143 
2144         executable = JAVA
2145         classpath = project.configurations.antlr
2146         workingDir = wd
2147         main = &quot;org.antlr.v4.Tool&quot;
2148 
2149         args = [
2150             &quot;-o&quot;,
2151             outDir.toString(),
2152             &quot;-package&quot;,
2153             &quot;com.sun.scenario.effect.compiler&quot;,
2154             &quot;-visitor&quot;,
2155             inJSL ]
2156 
2157         inputs.dir wd
2158         outputs.dir outDir
2159     }
2160     sourceSets.jslc.java.srcDirs += &quot;$buildDir/gensrc/antlr&quot;
2161 
2162     // and compile the JSLC support classes
2163     compileJslcJava.dependsOn(generateGrammarSource)
2164     compileJslcJava.classpath = project.configurations.antlr
2165 
2166     compileJava.dependsOn(compileJslcJava)
2167 
2168     // this task is the &quot;second pass&quot; compile of all of the module classes
2169     project.task(&quot;compileFullJava&quot;, type: JavaCompile, dependsOn: processShaders) {
2170         description = &quot;Compile all of the graphics java classes - main and shaders&quot;
2171 
2172         classpath = configurations.compile
2173 
2174         source = project.sourceSets.main.java.srcDirs
2175         source += &quot;$buildDir/gensrc/java&quot;
2176         source += project.sourceSets.shaders.output
2177 
2178         destinationDir = project.sourceSets.main.java.outputDir
2179         options.compilerArgs.addAll([
2180             &#39;-h&#39;, &quot;$buildDir/gensrc/headers/&quot;,  // Note: this creates the native headers
2181             &#39;-implicit:none&#39;,
2182             &#39;--module-source-path&#39;, defaultModuleSourcePath
2183             ] )
2184     }
2185     classes.dependsOn(compileFullJava)
2186 
2187     project.sourceSets.shims.java.srcDirs += project.sourceSets.shaders.output
2188     project.sourceSets.shims.java.srcDirs += &quot;$buildDir/gensrc/jsl-prism&quot;
2189     project.sourceSets.shims.java.srcDirs += &quot;$buildDir/gensrc/jsl-decora&quot;
2190 
2191     compileShimsJava.dependsOn(compileFullJava)
2192 
2193     // Create a single &quot;native&quot; task which will depend on all the individual native tasks for graphics
2194     project.ext.nativeAllTask = task(&quot;native&quot;, group: &quot;Build&quot;, description: &quot;Compiles and Builds all native libraries for Graphics&quot;);
2195     project.ext.cleanNativeAllTask = task(&quot;cleanNative&quot;, group: &quot;Build&quot;, description: &quot;Clean all native libraries and objects for Graphics&quot;);
2196 
2197     // Add tasks for native compilation
2198     addNative(project, &quot;glass&quot;);
2199     addNative(project, &quot;prism&quot;)
2200     addNative(project, &quot;prismSW&quot;)
2201     addNative(project, &quot;font&quot;)
2202     addNative(project, &quot;iio&quot;)
2203     addNative(project, &quot;prismES2&quot;)
2204 
2205     if (IS_COMPILE_PANGO) {
2206         addNative(project, &quot;fontFreetype&quot;)
2207         addNative(project, &quot;fontPango&quot;)
2208     }
2209 
2210     if (IS_WINDOWS) {
2211         addNative(project, &quot;prismD3D&quot;)
2212         // TODO need to hook this up to be executed only if PassThroughVS.h is missing or PassThroughVS.hlsl is changed
2213         task generateD3DHeaders(group: &quot;Build&quot;) {
2214             enabled = IS_WINDOWS
2215             inputs.file &quot;src/main/native-prism-d3d/hlsl/Mtl1PS.hlsl&quot;
2216             inputs.file &quot;src/main/native-prism-d3d/hlsl/Mtl1VS.hlsl&quot;
2217             inputs.file &quot;src/main/native-prism-d3d/PassThroughVS.hlsl&quot;
2218             outputs.dir &quot;$buildDir/headers/PrismD3D/&quot;
2219             outputs.dir &quot;$buildDir/headers/PrismD3D/hlsl/&quot;
2220             description = &quot;Generate headers by compiling hlsl files&quot;
2221             doLast {
2222                 mkdir file(&quot;$buildDir/headers/PrismD3D/hlsl&quot;)
2223                 def PS_3D_SRC = file(&quot;src/main/native-prism-d3d/hlsl/Mtl1PS.hlsl&quot;)
2224                 def VS_3D_SRC = file(&quot;src/main/native-prism-d3d/hlsl/Mtl1VS.hlsl&quot;)
2225                 def PASSTHROUGH_VS_SRC = file(&quot;src/main/native-prism-d3d/PassThroughVS.hlsl&quot;)
2226                 def jobs = [
2227                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;vs_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/PassThroughVS.h&quot;, &quot;/E&quot;, &quot;passThrough&quot;, &quot;$PASSTHROUGH_VS_SRC&quot;],
2228                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS.h&quot;, &quot;/DSpec=0&quot;, &quot;/DSType=0&quot;, &quot;$PS_3D_SRC&quot;],
2229                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_i.h&quot;, &quot;/DSpec=0&quot;, &quot;/DSType=0&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2230                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1n.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=0&quot;, &quot;$PS_3D_SRC&quot;],
2231                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2n.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=0&quot;, &quot;$PS_3D_SRC&quot;],
2232                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3n.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=0&quot;, &quot;$PS_3D_SRC&quot;],
2233                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1t.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=1&quot;, &quot;$PS_3D_SRC&quot;],
2234                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2t.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=1&quot;, &quot;$PS_3D_SRC&quot;],
2235                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3t.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=1&quot;, &quot;$PS_3D_SRC&quot;],
2236                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1c.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=2&quot;, &quot;$PS_3D_SRC&quot;],
2237                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2c.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=2&quot;, &quot;$PS_3D_SRC&quot;],
2238                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3c.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=2&quot;, &quot;$PS_3D_SRC&quot;],
2239                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1m.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=3&quot;, &quot;$PS_3D_SRC&quot;],
2240                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2m.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=3&quot;, &quot;$PS_3D_SRC&quot;],
2241                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3m.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=3&quot;, &quot;$PS_3D_SRC&quot;],
2242                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1n.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2243                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2n.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2244                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3n.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2245                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1t.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2246                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2t.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2247                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3t.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2248                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1c.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2249                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2c.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2250                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3c.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2251                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1m.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2252                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2m.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2253                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3m.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2254                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1ni.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=0&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2255                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2ni.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=0&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2256                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3ni.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=0&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2257                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1ti.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2258                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2ti.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2259                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3ti.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2260                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1ci.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=2&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2261                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2ci.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=2&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2262                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3ci.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=2&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2263                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1mi.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=3&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2264                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2mi.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=3&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2265                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3mi.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=3&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2266                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1ni.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2267                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2ni.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2268                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3ni.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2269                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1ti.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2270                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2ti.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2271                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3ti.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2272                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1ci.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2273                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2ci.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2274                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3ci.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2275                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1mi.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2276                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2mi.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2277                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3mi.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2278                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;vs_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1VS_Obj.h&quot;, &quot;/DVertexType=ObjVertex&quot;, &quot;$VS_3D_SRC&quot;]
2279                 ]
2280                 final ExecutorService executor = Executors.newFixedThreadPool(Integer.parseInt(project.NUM_COMPILE_THREADS.toString()));
2281                 final CountDownLatch latch = new CountDownLatch(jobs.size());
2282                 List futures = new ArrayList&lt;Future&gt;();
2283                 jobs.each { cmd -&gt;
2284                     futures.add(executor.submit(new Runnable() {
2285                         @Override public void run() {
2286                             try {
2287                                 exec {
2288                                     commandLine cmd
2289                                 }
2290                             } finally {
2291                                 latch.countDown();
2292                             }
2293                         }
2294                     }));
2295                 }
2296                 latch.await();
2297                 // Looking for whether an exception occurred while executing any of the futures.
2298                 // By calling &quot;get()&quot; on each future an exception will be thrown if one had occurred
2299                 // on the background thread.
2300                 futures.each {it.get();}
2301             }
2302         }
2303 
2304         ccWinPrismD3D.dependsOn generateD3DHeaders
2305     }
2306 
2307     // The Decora and Prism JSL files have to be generated in a very specific set of steps.
2308     //      1) Compile the *Compile.java classes. These live in src/main/jsl-* and will be
2309     //         output to $buildDir/classes/jsl-compilers/* (where * == decora or prism).
2310     //      2) Generate source files from the JSL files contained in src/main/jsl-*. These
2311     //         will be output to $buildDir/gensrc/jsl-*
2312     //      3) Compile the JSL Java sources in $buildDir/gensrc/jsl-* and put the output
2313     //         into classes/jsl-*
2314     //      4) Compile the native JSL sources in $buildDir/gensrc/jsl-* and put the obj
2315     //         files into native/jsl-* and the resulting library into libs/jsl-*.dll|so|dylib
2316     //      5) Modify the jar step to include classes/jsl-*
2317     // The native library must be copied over during SDK creation time in the &quot;sdk&quot; task. In
2318     // addition to these steps, the clean task is created. Note that I didn&#39;t bother to create
2319     // a new task for each of the decora files, preferring instead just to create a rule?? Also
2320     // need &quot;clean&quot; tasks for each compile task.
2321 
2322     def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
2323     modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.base/build/classes/java/main&quot;
2324     addJSL(project, &quot;Decora&quot;, &quot;com/sun/scenario/effect/impl/hw/d3d/hlsl&quot;, decoraAddExports) { sourceDir, destinationDir -&gt;
2325         [[fileName: &quot;ColorAdjust&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2326          [fileName: &quot;Brightpass&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2327          [fileName: &quot;SepiaTone&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2328          [fileName: &quot;PerspectiveTransform&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2329          [fileName: &quot;DisplacementMap&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2330          [fileName: &quot;InvertMask&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2331          [fileName: &quot;Blend&quot;, generator: &quot;CompileBlend&quot;, outputs: &quot;-all&quot;],
2332          [fileName: &quot;PhongLighting&quot;, generator: &quot;CompilePhong&quot;, outputs: &quot;-all&quot;],
2333          [fileName: &quot;LinearConvolve&quot;, generator: &quot;CompileLinearConvolve&quot;, outputs: &quot;-hw&quot;],
2334          [fileName: &quot;LinearConvolveShadow&quot;, generator: &quot;CompileLinearConvolve&quot;, outputs: &quot;-hw&quot;]].each { settings -&gt;
2335             javaexec {
2336                 executable = JAVA
2337                 workingDir = project.projectDir
2338                 main = settings.generator
2339                 classpath = configurations.compile + configurations.antlr
2340                 classpath += files(project.sourceSets.jslc.java.outputDir)
2341 
2342                 classpath += files(&quot;${project.projectDir}/src/jslc/resources&quot;)
2343 
2344                 classpath += files(&quot;$buildDir/classes/jsl-compilers/decora&quot;)
2345                 jvmArgs += &quot;--module-path=$modulePath&quot;
2346                 jvmArgs += &quot;--add-modules=javafx.graphics&quot;
2347                 jvmArgs += decoraAddExports
2348                 args += [&quot;-i&quot;, sourceDir, &quot;-o&quot;, destinationDir, &quot;-t&quot;, &quot;-pkg&quot;, &quot;com/sun/scenario/effect&quot;, &quot;$settings.outputs&quot;, &quot;$settings.fileName&quot;]
2349             }
2350         }
2351     }
2352 
2353 
2354     task nativeDecora(dependsOn: compileDecoraHLSLShaders, group: &quot;Build&quot;) {
2355         description = &quot;Generates JNI headers, compiles, and builds native dynamic library for Decora&quot;
2356     }
2357     task cleanNativeDecora(type: Delete, group: &quot;Build&quot;) {
2358         description = &quot;Clean native objects for Decora&quot;
2359     }
2360 
2361     def headerDir = file(&quot;$buildDir/gensrc/headers/javafx.graphics&quot;)
2362     def nativeRootDir = project.file(&quot;$project.buildDir/native/jsl-decora&quot;)
2363     def libRootDir = project.file(&quot;$project.buildDir/libs/jsl-decora&quot;)
2364     // For each compile target, create cc and link tasks
2365     compileTargets { t -&gt;
2366         def target = t.name
2367         def upperTarget = t.upper
2368         def capitalTarget = t.capital
2369         def targetProperties = rootProject.ext[upperTarget];
2370         def library = targetProperties.library
2371         def properties = targetProperties.get(&#39;decora&#39;)
2372         def nativeDir = file(&quot;$nativeRootDir/$target&quot;);
2373 
2374         def variants = properties.containsKey(&quot;variants&quot;) ? properties.variants : [&quot;&quot;];
2375         variants.each { variant -&gt;
2376             def variantProperties = variant == &quot;&quot; ? properties : properties.get(variant)
2377             def capitalVariant = variant.capitalize()
2378             def ccOutput = variant == &quot;&quot; ? nativeDir : file(&quot;$nativeDir/$variant&quot;)
2379 
2380             def ccTask = task(&quot;compileDecoraNativeShaders$capitalTarget$capitalVariant&quot;, type: CCTask ) {
2381                 description = &quot;Compiles Decora SSE natives for ${t.name}${capitalVariant != &#39;&#39; ? &#39; for variant &#39; + capitalVariant : &#39;&#39;}&quot;
2382                 matches = &quot;.*\\.cc&quot;
2383                 source file(&quot;$buildDir/gensrc/jsl-decora&quot;)
2384                 source file(project.projectDir.path + &quot;/src/main/native-decora&quot;)
2385                 headers = headerDir
2386                 params.addAll(variantProperties.ccFlags)
2387                 output(ccOutput)
2388                 compiler = variantProperties.compiler
2389                 cleanNativeDecora.delete ccOutput
2390             }
2391 
2392             def linkTask = task(&quot;linkDecoraNativeShaders$capitalTarget$capitalVariant&quot;, type: LinkTask, dependsOn: ccTask) {
2393                 description = &quot;Creates native dynamic library for Decora SSE ${t.name}${capitalVariant != &#39;&#39; ? &#39; for variant &#39; + capitalVariant : &#39;&#39;}&quot;
2394                 objectDir = ccOutput
2395                 linkParams.addAll(variantProperties.linkFlags)
2396                 lib = file(&quot;$libRootDir/$t.name/${library(variantProperties.lib)}&quot;)
2397                 linker = variantProperties.linker
2398                 cleanNativeDecora.delete &quot;$libRootDir/$t.name/&quot;
2399             }
2400 
2401             if (IS_WINDOWS &amp;&amp; target == &quot;win&quot;) {
2402                 def rcTask = project.task(&quot;rcDecoraNativeShaders$capitalTarget$capitalVariant&quot;, type: CompileResourceTask) {
2403                     description = &quot;Compiles native sources for Decora SSE&quot;
2404                     matches = &quot;.*\\.rc&quot;
2405                     compiler = variantProperties.rcCompiler
2406                     source(variantProperties.rcSource)
2407                     if (variantProperties.rcFlags) {
2408                         rcParams.addAll(variantProperties.rcFlags)
2409                     }
2410                     output(ccOutput)
2411                 }
2412                 linkTask.dependsOn rcTask;
2413             }
2414 
2415             nativeDecora.dependsOn(linkTask)
2416         }
2417     }
2418 
2419     // Prism JSL
2420     addJSL(project, &quot;Prism&quot;, &quot;com/sun/prism/d3d/hlsl&quot;, null) { sourceDir, destinationDir -&gt;
2421         def inputFiles = fileTree(dir: sourceDir)
2422         inputFiles.include &quot;**/*.jsl&quot;
2423         inputFiles.each { file -&gt;
2424             javaexec {
2425                 executable = JAVA
2426                 workingDir = project.projectDir
2427                 main = &quot;CompileJSL&quot;
2428                 classpath = configurations.compile + configurations.antlr
2429                 classpath += files(project.sourceSets.jslc.java.outputDir)
2430                 classpath += files(project.sourceSets.jslc.resources)
2431                 classpath += files(&quot;$buildDir/classes/jsl-compilers/prism&quot;,
2432                     project.projectDir.path + &quot;/src/main/jsl-prism&quot;) // for the .stg
2433                 args = [&quot;-i&quot;, sourceDir, &quot;-o&quot;, destinationDir, &quot;-t&quot;, &quot;-pkg&quot;, &quot;com/sun/prism&quot;, &quot;-d3d&quot;, &quot;-es2&quot;, &quot;-name&quot;, &quot;$file&quot;]
2434             }
2435         }
2436     }
2437 
2438     nativePrism.dependsOn compilePrismHLSLShaders;
2439 
2440     project.nativeAllTask.dependsOn nativeDecora
2441     project.cleanNativeAllTask.dependsOn cleanNativeDecora
2442     assemble.dependsOn nativeDecora
2443     processResources.dependsOn processDecoraShaders, processPrismShaders
2444 
2445     test {
2446         def cssDir = file(&quot;$buildDir/classes/java/main/${moduleName}/javafx&quot;)
2447         jvmArgs &quot;-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit&quot;,
2448             &quot;-DCSS_META_DATA_TEST_DIR=$cssDir&quot;
2449         enableAssertions = true
2450         testLogging.exceptionFormat = &quot;full&quot;
2451         scanForTestClasses = false
2452         include &quot;**/*Test.*&quot;
2453         if (BUILD_CLOSED &amp;&amp; DO_JCOV) {
2454             addJCov(project, test)
2455         }
2456     }
2457 
2458     // To enable the IDEs to all be happy (no red squiggles) we need to have the libraries
2459     // available in some known location. Maybe in the future the Gradle plugins to each
2460     // of the IDEs will be good enough that we won&#39;t need this hack anymore.
2461     classes {
2462         doLast {
2463             // Copy all of the download libraries to the libs directory for the sake of the IDEs
2464             File libsDir = rootProject.file(&quot;build/libs&quot;);
2465 
2466             // In some IDEs (Eclipse for example), touching these libraries
2467             // cauese a full build within the IDE. When gradle is used
2468             // outside of the IDE, for example to build the native code,
2469             // a full rebuild is caused within the IDE. The fix is to check
2470             // for the presence of the target files in the lib directory
2471             // and not copy the files if all are present.
2472 
2473             libsDir.mkdirs();
2474 
2475             def allLibsPresent = true
2476             def libNames = [ &quot;antlr4-4.7.2-complete.jar&quot; ]
2477             libNames.each { name -&gt;
2478                 File f = new File(libsDir, name)
2479                 if (!f.exists()) allLibsPresent = false
2480             }
2481             if (allLibsPresent) return;
2482 
2483             for (File f : [configurations.compile.files, configurations.antlr.files].flatten()) {
2484                 copy {
2485                     into libsDir
2486                     from f.getParentFile()
2487                     include &quot;**/antlr4-4.7.2-complete.jar&quot;
2488                     includeEmptyDirs = false
2489                 }
2490             }
2491         }
2492     }
2493 
2494     addMavenPublication(project, [ &#39;base&#39; ])
2495 
2496     addValidateSourceSets(project, sourceSets)
2497 }
2498 
2499 project(&quot;:controls&quot;) {
2500     project.ext.buildModule = true
2501     project.ext.includeSources = true
2502     project.ext.moduleRuntime = true
2503     project.ext.moduleName = &quot;javafx.controls&quot;
2504 
2505     sourceSets {
2506         main
2507         shims {
2508             java {
2509                 compileClasspath += sourceSets.main.output
2510                 runtimeClasspath += sourceSets.main.output
2511             }
2512         }
2513         test {
2514             java {
2515                 compileClasspath += sourceSets.shims.output
2516                 runtimeClasspath += sourceSets.shims.output
2517             }
2518         }
2519     }
2520 
2521     project.ext.moduleSourcePath = defaultModuleSourcePath
2522     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2523 
2524     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;controls&#39; ])
2525 
2526     dependencies {
2527         testCompile project(&quot;:graphics&quot;).sourceSets.test.output
2528         testCompile project(&quot;:base&quot;).sourceSets.test.output
2529         compile project(&#39;:base&#39;)
2530         compile project(&#39;:graphics&#39;)
2531     }
2532 
2533     test {
2534         def cssDir = file(&quot;$buildDir/classes/java/main/${moduleName}/javafx&quot;)
2535         jvmArgs &quot;-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit&quot;,
2536             &quot;-DCSS_META_DATA_TEST_DIR=$cssDir&quot;
2537     }
2538 
2539     def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
2540     modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.graphics/build/classes/java/main&quot;
2541     modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.base/build/classes/java/main&quot;
2542     processResources {
2543       doLast {
2544         def cssFiles = fileTree(dir: &quot;$moduleDir/com/sun/javafx/scene/control/skin&quot;)
2545         cssFiles.include &quot;**/*.css&quot;
2546         cssFiles.each { css -&gt;
2547             logger.info(&quot;converting CSS to BSS ${css}&quot;);
2548 
2549             javaexec {
2550                 executable = JAVA
2551                 workingDir = project.projectDir
2552                 jvmArgs += patchModuleArgs
2553                 jvmArgs += &quot;--module-path=$modulePath&quot;
2554                 jvmArgs += &quot;--add-modules=javafx.graphics&quot;
2555                 main = &quot;com.sun.javafx.css.parser.Css2Bin&quot;
2556                 args css
2557             }
2558         }
2559       }
2560     }
2561 
2562     processShimsResources.dependsOn(project.task(&quot;copyShimBss&quot;, type: Copy) {
2563         from project.moduleDir
2564         into project.moduleShimsDir
2565         include &quot;**/*.bss&quot;
2566     })
2567 
2568     addMavenPublication(project, [ &#39;graphics&#39; ])
2569 
2570     addValidateSourceSets(project, sourceSets)
2571 }
2572 
2573 project(&quot;:swing&quot;) {
2574 
2575     tasks.all {
2576         if (!COMPILE_SWING) it.enabled = false
2577     }
2578 
2579     project.ext.buildModule = COMPILE_SWING
2580     project.ext.includeSources = true
2581     project.ext.moduleRuntime = true
2582     project.ext.moduleName = &quot;javafx.swing&quot;
2583 
2584     sourceSets {
2585         main
2586         shims {
2587             java {
2588                 compileClasspath += sourceSets.main.output
2589                 runtimeClasspath += sourceSets.main.output
2590             }
2591         }
2592         test {
2593             java {
2594                 compileClasspath += sourceSets.shims.output
2595                 runtimeClasspath += sourceSets.shims.output
2596             }
2597         }
2598     }
2599 
2600     project.ext.moduleSourcePath = defaultModuleSourcePath
2601     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2602 
2603     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;swing&#39; ])
2604 
2605     dependencies {
2606         compile project(&quot;:base&quot;)
2607         compile project(&quot;:graphics&quot;)
2608     }
2609 
2610     test {
2611         enabled = IS_FULL_TEST &amp;&amp; IS_AWT_TEST
2612     }
2613 
2614     if (COMPILE_SWING) {
2615         addMavenPublication(project, [ &#39;graphics&#39; ])
2616     }
2617 
2618     addValidateSourceSets(project, sourceSets)
2619 }
2620 
2621 project(&quot;:swt&quot;) {
2622     tasks.all {
2623         if (!COMPILE_SWT) it.enabled = false
2624     }
2625 
2626     // javafx.swt is an automatic module
2627     project.ext.buildModule = false
2628 
2629     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39; ])
2630 
2631     dependencies {
2632         compile name: SWT_FILE_NAME
2633     }
2634 
2635     classes {
2636         doLast {
2637             // Copy all of the download libraries to libs directory for the sake of the IDEs
2638             File libsDir = rootProject.file(&quot;build/libs&quot;);
2639             File swtLib = new File(libsDir, &quot;swt-debug.jar&quot;)
2640             libsDir.mkdirs();
2641 
2642             // Skip copy if file is present.
2643             if (swtLib.exists()) return;
2644 
2645             for (File f : configurations.compile.files) {
2646                 // Have to rename the swt jar because it is some platform specific name but
2647                 // for the sake of the IDEs we need to have a single stable name that works
2648                 // on every platform
2649                 copy {
2650                     into libsDir
2651                     from f.getParentFile()
2652                     include &quot;**/*swt*.jar&quot;
2653                     includeEmptyDirs = false
2654                     rename &quot;.*swt.*jar&quot;, &quot;swt-debug\\.jar&quot;
2655                 }
2656             }
2657         }
2658     }
2659 
2660     compileJava.options.compilerArgs.addAll([
2661             &quot;--add-exports=javafx.graphics/com.sun.glass.ui=ALL-UNNAMED&quot;,
2662             &quot;--add-exports=javafx.graphics/com.sun.javafx.cursor=ALL-UNNAMED&quot;,
2663             &quot;--add-exports=javafx.graphics/com.sun.javafx.embed=ALL-UNNAMED&quot;,
2664             &quot;--add-exports=javafx.graphics/com.sun.javafx.stage=ALL-UNNAMED&quot;,
2665             &quot;--add-exports=javafx.graphics/com.sun.javafx.tk=ALL-UNNAMED&quot;,
2666             ])
2667 
2668     test {
2669         //enabled = IS_FULL_TEST &amp;&amp; IS_SWT_TEST
2670         enabled = false // FIXME: JIGSAW -- support this with modules
2671         logger.info(&quot;JIGSAW Testing disabled for swt&quot;)
2672 
2673         if (IS_MAC) {
2674             enabled = false
2675             logger.info(&quot;SWT tests are disabled on MAC, because Gradle test runner does not handle -XstartOnFirstThread properly (https://issues.gradle.org/browse/GRADLE-3290).&quot;)
2676         }
2677     }
2678 
2679     addValidateSourceSets(project, sourceSets)
2680 }
2681 
2682 project(&quot;:fxml&quot;) {
2683     project.ext.buildModule = true
2684     project.ext.includeSources = true
2685     project.ext.moduleRuntime = true
2686     project.ext.moduleName = &quot;javafx.fxml&quot;
2687 
2688     sourceSets {
2689         main
2690         shims {
2691             java {
2692                 compileClasspath += sourceSets.main.output
2693                 runtimeClasspath += sourceSets.main.output
2694             }
2695         }
2696         test {
2697             java {
2698                 compileClasspath += sourceSets.shims.output
2699                 runtimeClasspath += sourceSets.shims.output
2700             }
2701         }
2702     }
2703 
2704     project.ext.moduleSourcePath = defaultModuleSourcePath
2705     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2706 
2707     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;controls&#39;, &#39;fxml&#39; ])
2708 
2709 
2710     dependencies {
2711         testCompile project(&quot;:graphics&quot;).sourceSets.test.output
2712         testCompile project(&quot;:base&quot;).sourceSets.test.output
2713         compile project(&quot;:base&quot;)
2714         compile project(&quot;:graphics&quot;)
2715     }
2716 
2717     test {
2718         // StubToolkit is not *really* needed here, but because some code inadvertently invokes performance
2719         // tracker and this attempts to fire up the toolkit and this looks for native libraries and fails,
2720         // we have to use the stub toolkit for now.
2721         jvmArgs &quot;-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit&quot;
2722         // FIXME: change this to also allow JDK 9 boot jdk
2723         classpath += files(&quot;$JDK_HOME/jre/lib/ext/nashorn.jar&quot;)
2724     }
2725 
2726     addMavenPublication(project, [ &#39;controls&#39; ])
2727 
2728     addValidateSourceSets(project, sourceSets)
2729 }
2730 
2731 project(&quot;:media&quot;) {
2732     configurations {
2733         media
2734     }
2735 
2736     project.ext.buildModule = true
2737     project.ext.includeSources = true
2738     project.ext.moduleRuntime = true
2739     project.ext.moduleName = &quot;javafx.media&quot;
2740 
2741     sourceSets {
2742         main
2743         //shims // no test shims needed
2744         test
2745         tools {
2746             java.srcDir &quot;src/tools/java&quot;
2747         }
2748     }
2749 
2750     project.ext.moduleSourcePath = defaultModuleSourcePath
2751     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2752 
2753     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;media&#39; ])
2754 
2755     dependencies {
2756         if (IS_BUILD_LIBAV_STUBS) {
2757             media name: &quot;libav-9.14&quot;, ext: &quot;tar.gz&quot;
2758             media name: &quot;libav-11.4&quot;, ext: &quot;tar.gz&quot;
2759             media name: &quot;libav-12.1&quot;, ext: &quot;tar.gz&quot;
2760             media name: &quot;ffmpeg-3.3.3&quot;, ext: &quot;tar.gz&quot;
2761             media name: &quot;ffmpeg-4.0.2&quot;, ext: &quot;tar.gz&quot;
2762         }
2763         compile project(&quot;:base&quot;)
2764         compile project(&quot;:graphics&quot;)
2765     }
2766 
2767     compileJava.dependsOn updateCacheIfNeeded
2768 
2769     compileJava {
2770         // generate the native headers during compile
2771         options.compilerArgs.addAll([
2772             &#39;-h&#39;, &quot;${project.buildDir}/gensrc/headers&quot;
2773             ])
2774     }
2775 
2776     compileToolsJava {
2777         enabled = IS_COMPILE_MEDIA
2778         def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
2779         options.compilerArgs.addAll([
2780             &quot;--module-path=$modulePath&quot;,
2781             &quot;--add-modules=javafx.media&quot;,
2782             &#39;--add-exports&#39;, &#39;javafx.media/com.sun.media.jfxmedia=ALL-UNNAMED&#39;,
2783             ])
2784     }
2785 
2786     project.ext.makeJobsFlag = IS_WINDOWS &amp;&amp; IS_DEBUG_NATIVE ? &quot;-j1&quot; : &quot;-j5&quot;;
2787     project.ext.buildType = IS_DEBUG_NATIVE ? &quot;Debug&quot; : &quot;Release&quot;;
2788 
2789     def nativeSrcDir = file(&quot;${projectDir}/src/main/native&quot;)
2790     def generatedHeadersDir = file(&quot;${buildDir}/gensrc/headers/${project.moduleName}&quot;)
2791 
2792     task generateMediaErrorHeader(dependsOn: [compileJava, compileToolsJava]) {
2793         enabled = IS_COMPILE_MEDIA
2794         def headerpath = file(&quot;$generatedHeadersDir/jfxmedia_errors.h&quot;);
2795         doLast {
2796             def classpath = files(sourceSets.tools.output);
2797             def sourcepath = sourceSets.main.java.srcDirs;
2798             def srcRoot = (sourcepath.toArray())[0];
2799 
2800             mkdir generatedHeadersDir;
2801 
2802             def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
2803             modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.graphics/build/classes/java/main&quot;
2804             modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.base/build/classes/java/main&quot;
2805 
2806             exec {
2807                 commandLine(&quot;$JAVA&quot;);
2808                 args += patchModuleArgs
2809                 args += [ &quot;--module-path=$modulePath&quot; ]
2810                 args += [ &quot;--add-modules=javafx.media&quot; ]
2811                 args +=  [ &#39;--add-exports=javafx.media/com.sun.media.jfxmedia=ALL-UNNAMED&#39; ]
2812                 args +=  [ &#39;-classpath&#39;, &quot;${classpath.asPath}&quot; ]
2813                 args += [ &quot;headergen.HeaderGen&quot;, &quot;$headerpath&quot;, &quot;$srcRoot&quot; ]
2814             }
2815         }
2816         outputs.file(project.file(&quot;$headerpath&quot;))
2817     }
2818 
2819     task buildNativeTargets {
2820         enabled = IS_COMPILE_MEDIA
2821     }
2822 
2823     compileTargets { t-&gt;
2824         def targetProperties = project.rootProject.ext[t.upper]
2825         def nativeOutputDir = file(&quot;${buildDir}/native/${t.name}&quot;)
2826         def projectDir = t.name.startsWith(&quot;arm&quot;) ? &quot;linux&quot; : t.name
2827         def mediaProperties = targetProperties.media
2828         // Makefile for OSX needs to know if we&#39;re building for parfait
2829         def compileParfait = IS_COMPILE_PARFAIT ? &quot;true&quot; : &quot;false&quot;
2830 
2831         def buildNative = task(&quot;build${t.capital}Native&quot;, dependsOn: [generateMediaErrorHeader]) {
2832             enabled = targetProperties.compileMediaNative
2833             if (!targetProperties.compileMediaNative) {
2834                 println(&quot;Not compiling native Media for ${t.name} per configuration request&quot;);
2835             }
2836 
2837             doLast {
2838                 exec {
2839                     commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/jfxmedia/projects/${projectDir}&quot;)
2840                     args(&quot;JAVA_HOME=${JDK_HOME}&quot;, &quot;GENERATED_HEADERS_DIR=${generatedHeadersDir}&quot;,
2841                          &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=jfxmedia&quot;,
2842                          &quot;COMPILE_PARFAIT=${compileParfait}&quot;,
2843                          IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;,
2844                         &quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
2845 
2846                     if (t.name == &quot;win&quot;) {
2847                         environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
2848                         args( &quot;RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.jfxmediaRcFile}&quot;)
2849                     } else {
2850                         if (t.name.startsWith(&quot;arm&quot;)) {
2851                             args(&quot;EXTRA_CFLAGS=${mediaProperties.extra_cflags}&quot;, &quot;EXTRA_LDFLAGS=${mediaProperties.extra_ldflags}&quot;)
2852                         } else {
2853                             args(&quot;HOST_COMPILE=1&quot;)
2854                         }
2855                     }
2856                 }
2857             }
2858         }
2859 
2860         // check for the property disable${name} = true
2861         def boolean disabled = targetProperties.containsKey(&#39;disableMedia&#39;) ? targetProperties.get(&#39;disableMedia&#39;) : false
2862         if (!disabled) {
2863             // Building GStreamer
2864             def buildGStreamer = task(&quot;build${t.capital}GStreamer&quot;) {
2865                 enabled = IS_COMPILE_MEDIA
2866                 doLast {
2867                     exec {
2868                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/gstreamer-lite&quot;)
2869                         args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=gstreamer-lite&quot;,
2870                              IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;, &quot;CC=${mediaProperties.compiler}&quot;,
2871                              &quot;AR=${mediaProperties.ar}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
2872 
2873                         if (t.name == &quot;win&quot;) {
2874                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
2875                             args(&quot;RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.gstreamerRcFile}&quot;)
2876                         }
2877                     }
2878                 }
2879             }
2880 
2881             def buildPlugins = task(&quot;build${t.capital}Plugins&quot;, dependsOn: buildGStreamer) {
2882                 enabled = IS_COMPILE_MEDIA
2883 
2884                 doLast {
2885                     exec {
2886                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/fxplugins&quot;)
2887                         args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=fxplugins&quot;,
2888                              IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;,
2889                              &quot;CC=${mediaProperties.compiler}&quot;, &quot;AR=${mediaProperties.ar}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
2890 
2891                         if (t.name == &quot;win&quot;) {
2892                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
2893                             args(&quot;RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.fxpluginsRcFile}&quot;)
2894                         }
2895                     }
2896                 }
2897             }
2898 
2899             buildNative.dependsOn buildPlugins
2900 
2901             if (t.name == &quot;linux&quot;) {
2902                 // Pre-defined command line arguments
2903                 def cfgCMDArgs = [&quot;sh&quot;, &quot;configure&quot;]
2904                 def commonCfgArgs = [&quot;--enable-shared&quot;, &quot;--disable-debug&quot;, &quot;--disable-static&quot;, &quot;--disable-yasm&quot;, &quot;--disable-doc&quot;, &quot;--disable-programs&quot;, &quot;--disable-everything&quot;]
2905                 def codecsCfgArgs = [&quot;--enable-decoder=aac,mp3,mp3float,h264&quot;, &quot;--enable-parser=aac,h264&quot;, &quot;--enable-demuxer=aac,h264,mpegts,mpegtsraw&quot;]
2906 
2907                 def copyLibAVStubs = {String fromDir, String toDir -&gt;
2908                     FileCollection config = files(&quot;config.h&quot;)
2909                     FileCollection libavcodec = files(&quot;avcodec.h&quot;, &quot;avfft.h&quot;, &quot;dxva2.h&quot;, &quot;vaapi.h&quot;, &quot;vda.h&quot;,
2910                                                       &quot;vdpau.h&quot;, &quot;version.h&quot;, &quot;xvmc.h&quot;, &quot;old_codec_ids.h&quot;)
2911                     FileCollection libavdevice = files(&quot;avdevice.h&quot;, &quot;version.h&quot;)
2912                     FileCollection libavfilter = files(&quot;avfiltergraph.h&quot;, &quot;avfilter.h&quot;, &quot;buffersink.h&quot;, &quot;buffersrc.h&quot;, &quot;version.h&quot;);
2913                     FileCollection libavformat = files(&quot;avformat.h&quot;, &quot;avio.h&quot;, &quot;version.h&quot;)
2914                     FileCollection libavresample = files(&quot;avresample.h&quot;, &quot;version.h&quot;)
2915                     FileCollection libavutil = files(&quot;adler32.h&quot;, &quot;blowfish.h&quot;, &quot;error.h&quot;, &quot;log.h&quot;, &quot;pixfmt.h&quot;,
2916                                                      &quot;aes.h&quot;, &quot;bswap.h&quot;, &quot;eval.h&quot;, &quot;lzo.h&quot;, &quot;random_seed.h&quot;,
2917                                                      &quot;attributes.h&quot;, &quot;buffer.h&quot;, &quot;fifo.h&quot;, &quot;macros.h&quot;, &quot;rational.h&quot;,
2918                                                      &quot;audio_fifo.h&quot;, &quot;channel_layout.h&quot;, &quot;file.h&quot;, &quot;mathematics.h&quot;, &quot;samplefmt.h&quot;,
2919                                                      &quot;avassert.h&quot;, &quot;common.h&quot;, &quot;frame.h&quot;, &quot;md5.h&quot;, &quot;sha.h&quot;,
2920                                                      &quot;avconfig.h&quot;, &quot;imgutils.h&quot;, &quot;mem.h&quot;, &quot;time.h&quot;, &quot;avstring.h&quot;,
2921                                                      &quot;cpu_internal.h&quot;, &quot;intfloat.h&quot;, &quot;opt.h&quot;, &quot;version.h&quot;, &quot;avutil.h&quot;,
2922                                                      &quot;crc.h&quot;, &quot;intreadwrite.h&quot;, &quot;parseutils.h&quot;, &quot;xtea.h&quot;, &quot;base64.h&quot;,
2923                                                      &quot;dict.h&quot;, &quot;lfg.h&quot;, &quot;pixdesc.h&quot;, &quot;intfloat_readwrite.h&quot;, &quot;old_pix_fmts.h&quot;, &quot;audioconvert.h&quot;,
2924                                                      &quot;cpu.h&quot;, &quot;hwcontext.h&quot;)
2925                     FileCollection libavutil_x86 = files(&quot;cpu.h&quot;) // Use cpu.h from x86 instead of libavutil root if exist
2926                     FileCollection libswscale = files(&quot;swscale.h&quot;, &quot;version.h&quot;)
2927 
2928                     def copyLibAVFiles = {FileCollection files, String fDir, String tDir -&gt;
2929                         File dir = file(tDir)
2930                         dir.mkdirs()
2931 
2932                         files.each { File file -&gt;
2933                             copy {
2934                                 from fDir
2935                                 into tDir
2936                                 include file.name
2937                             }
2938                         }
2939                     }
2940 
2941                     copyLibAVFiles(config, fromDir, &quot;${toDir}/include&quot;)
2942                     copyLibAVFiles(libavcodec, &quot;${fromDir}/libavcodec&quot;, &quot;${toDir}/include/libavcodec&quot;)
2943                     copyLibAVFiles(libavdevice, &quot;${fromDir}/libavdevice&quot;, &quot;${toDir}/include/libavdevice&quot;)
2944                     copyLibAVFiles(libavfilter, &quot;${fromDir}/libavfilter&quot;, &quot;${toDir}/include/libavfilter&quot;)
2945                     copyLibAVFiles(libavformat, &quot;${fromDir}/libavformat&quot;, &quot;${toDir}/include/libavformat&quot;)
2946                     copyLibAVFiles(libavresample, &quot;${fromDir}/libavresample&quot;, &quot;${toDir}/include/libavresample&quot;)
2947                     copyLibAVFiles(libavutil, &quot;${fromDir}/libavutil&quot;, &quot;${toDir}/include/libavutil&quot;)
2948                     copyLibAVFiles(libavutil_x86, &quot;${fromDir}/libavutil/x86&quot;, &quot;${toDir}/include/libavutil&quot;)
2949                     copyLibAVFiles(libswscale, &quot;${fromDir}/libswscale&quot;, &quot;${toDir}/include/libswscale&quot;)
2950 
2951                     // Copy libs
2952                     FileTree libs = fileTree(dir: &quot;${fromDir}&quot;, include: &quot;**/*.so*&quot;)
2953                     libs.each {File file -&gt;
2954                         copy {
2955                             from file
2956                             into &quot;${toDir}/lib&quot;
2957                         }
2958                     }
2959                 }
2960 
2961                 def buildLibAVStubs = task(&quot;buildLibAVStubs&quot;, dependsOn: []) {
2962                     enabled = IS_BUILD_LIBAV_STUBS
2963 
2964                     doLast {
2965                         project.ext.libav = [:]
2966                         project.ext.libav.basedir = &quot;${buildDir}/native/linux/libav&quot;
2967                         project.ext.libav.versions = [ &quot;9.14&quot;, &quot;11.4&quot;, &quot;12.1&quot; ]
2968                         project.ext.libav.versionmap = [ &quot;9.14&quot; : &quot;54&quot;, &quot;11.4&quot; : &quot;56&quot;, &quot;12.1&quot; : &quot;57&quot; ]
2969 
2970                         libav.versions.each { version -&gt;
2971                             def libavDir = &quot;${libav.basedir}/libav-${version}&quot;
2972                             for (File f : configurations.media.files) {
2973                                 if (f.name.startsWith(&quot;libav-${version}&quot;)) {
2974                                     File dir = file(libavDir)
2975                                     dir.mkdirs()
2976                                     def libavTar = &quot;${libav.basedir}/libav-${version}.tar&quot;
2977                                     ant.gunzip(src: f, dest: libavTar)
2978                                     ant.untar(src: libavTar, dest: libav.basedir)
2979                                 }
2980                             }
2981                         }
2982 
2983                         libav.versions.each { version -&gt;
2984                             def libavDir = &quot;${libav.basedir}/libav-${version}&quot;
2985                             File dir = file(libavDir)
2986                             if (dir.exists()) {
2987                                 def configFile = &quot;${libav.basedir}/libav-${version}/config.h&quot;
2988                                 File cfgFile = file(configFile)
2989                                 if (!cfgFile.exists()) {
2990                                     // Add execute permissions to version.sh, otherwise build fails
2991                                     exec {
2992                                         workingDir(&quot;$libavDir&quot;)
2993                                         commandLine(&quot;chmod&quot;, &quot;+x&quot;, &quot;version.sh&quot;)
2994                                     }
2995                                     exec {
2996                                         workingDir(&quot;$libavDir&quot;)
2997                                         if (IS_BUILD_WORKING_LIBAV) {
2998                                             commandLine(cfgCMDArgs + commonCfgArgs + codecsCfgArgs)
2999                                         } else {
3000                                             commandLine(cfgCMDArgs + commonCfgArgs)
3001                                         }
3002                                     }
3003                                 }
3004                                 exec {
3005                                     workingDir(&quot;$libavDir&quot;)
3006                                     commandLine(&quot;make&quot;)
3007                                 }
3008                             }
3009                         }
3010 
3011                         libav.versions.each { version -&gt;
3012                             def fromDir = &quot;${libav.basedir}/libav-${version}&quot;
3013                             def majorVersion = libav.versionmap[version]
3014                             def toDir = &quot;${libav.basedir}/libav-${majorVersion}&quot;
3015                             copyLibAVStubs(fromDir, toDir)
3016                         }
3017                     }
3018                 }
3019 
3020                 def buildLibAVFFmpegStubs = task(&quot;buildLibAVFFmpegStubs&quot;, dependsOn: []) {
3021                     enabled = IS_BUILD_LIBAV_STUBS
3022 
3023                     def extraCfgArgs = [&quot;--build-suffix=-ffmpeg&quot;]
3024 
3025                     doLast {
3026                         project.ext.libav = [:]
3027                         project.ext.libav.basedir = &quot;${buildDir}/native/linux/libavffmpeg&quot;
3028                         project.ext.libav.versions = [ &quot;11.4&quot; ]
3029                         project.ext.libav.versionmap = [ &quot;11.4&quot; : &quot;56&quot; ]
3030 
3031                         libav.versions.each { version -&gt;
3032                             def libavDir = &quot;${libav.basedir}/libav-${version}&quot;
3033                             for (File f : configurations.media.files) {
3034                                 if (f.name.startsWith(&quot;libav-${version}&quot;)) {
3035                                     File dir = file(libavDir)
3036                                     dir.mkdirs()
3037                                     def libavTar = &quot;${libav.basedir}/libav-${version}.tar&quot;
3038                                     ant.gunzip(src: f, dest: libavTar)
3039                                     ant.untar(src: libavTar, dest: libav.basedir)
3040                                 }
3041                             }
3042                         }
3043 
3044                         libav.versions.each { version -&gt;
3045                             def libavDir = &quot;${libav.basedir}/libav-${version}&quot;
3046                             File dir = file(libavDir)
3047                             if (dir.exists()) {
3048                                 def configFile = &quot;${libav.basedir}/libav-${version}/config.h&quot;
3049                                 File cfgFile = file(configFile)
3050                                 if (!cfgFile.exists()) {
3051                                     // Patch *.v files, so we have *_FFMPEG_$MAJOR instead of *_$MAJOR, otherwise library will not be loaded
3052                                     FileTree vfiles = fileTree(dir: &quot;${libavDir}&quot;, include: &quot;**/*.v&quot;)
3053                                     vfiles.each {File file -&gt;
3054                                         String data = file.getText(&quot;UTF-8&quot;)
3055                                         data = data.replace(&quot;_\$MAJOR&quot;, &quot;_FFMPEG_\$MAJOR&quot;)
3056                                         file.write(data, &quot;UTF-8&quot;)
3057                                     }
3058                                     // Add execute permissions to version.sh, otherwise build fails
3059                                     exec {
3060                                         workingDir(&quot;$libavDir&quot;)
3061                                         commandLine(&quot;chmod&quot;, &quot;+x&quot;, &quot;version.sh&quot;)
3062                                     }
3063                                     exec {
3064                                         workingDir(&quot;$libavDir&quot;)
3065                                         if (IS_BUILD_WORKING_LIBAV) {
3066                                             commandLine(cfgCMDArgs + commonCfgArgs + codecsCfgArgs + extraCfgArgs)
3067                                         } else {
3068                                             commandLine(cfgCMDArgs + commonCfgArgs + extraCfgArgs)
3069                                         }
3070                                     }
3071                                 }
3072                                 exec {
3073                                     workingDir(&quot;$libavDir&quot;)
3074                                     commandLine(&quot;make&quot;)
3075                                 }
3076                             }
3077                         }
3078 
3079                         libav.versions.each { version -&gt;
3080                             def fromDir = &quot;${libav.basedir}/libav-${version}&quot;
3081                             def majorVersion = libav.versionmap[version]
3082                             def toDir = &quot;${libav.basedir}/libav-${majorVersion}&quot;
3083                             copyLibAVStubs(fromDir, toDir)
3084 
3085                             // Special case to copy *-ffmpeg.so to *.so
3086                             FileTree libs = fileTree(dir: &quot;${fromDir}&quot;, include: &quot;**/*-ffmpeg.so&quot;)
3087                             libs.each {File file -&gt;
3088                                 copy {
3089                                     from file
3090                                     into &quot;${toDir}/lib&quot;
3091                                     rename { String fileName -&gt;
3092                                         fileName.replace(&quot;-ffmpeg&quot;, &quot;&quot;)
3093                                     }
3094                                 }
3095                             }
3096                         }
3097                     }
3098                 }
3099 
3100                 def buildFFmpegStubs = task(&quot;buildFFmpegStubs&quot;, dependsOn: []) {
3101                     enabled = IS_BUILD_LIBAV_STUBS
3102 
3103                     doLast {
3104                         project.ext.libav = [:]
3105                         project.ext.libav.basedir = &quot;${buildDir}/native/linux/ffmpeg&quot;
3106                         project.ext.libav.versions = [ &quot;3.3.3&quot;, &quot;4.0.2&quot; ]
3107                         project.ext.libav.versionmap = [ &quot;3.3.3&quot; : &quot;57&quot;, &quot;4.0.2&quot; : &quot;58&quot; ]
3108 
3109                         libav.versions.each { version -&gt;
3110                             def libavDir = &quot;${libav.basedir}/ffmpeg-${version}&quot;
3111                             for (File f : configurations.media.files) {
3112                                 if (f.name.startsWith(&quot;ffmpeg-${version}&quot;)) {
3113                                     File dir = file(libavDir)
3114                                     dir.mkdirs()
3115                                     def libavTar = &quot;${libav.basedir}/ffmpeg-${version}.tar&quot;
3116                                     ant.gunzip(src: f, dest: libavTar)
3117                                     ant.untar(src: libavTar, dest: libav.basedir)
3118                                 }
3119                             }
3120                         }
3121 
3122                         libav.versions.each { version -&gt;
3123                             def libavDir = &quot;${libav.basedir}/ffmpeg-${version}&quot;
3124                             File dir = file(libavDir)
3125                             if (dir.exists()) {
3126                                 def configFile = &quot;${libavDir}/config.h&quot;
3127                                 File cfgFile = file(configFile)
3128                                 if (!cfgFile.exists()) {
3129                                     // Add execute permissions to version.sh, otherwise build fails
3130                                     def versionFile = &quot;${libavDir}/version.sh&quot;
3131                                     File verFile = file(versionFile)
3132                                     if (verFile.exists()) {
3133                                         exec {
3134                                             workingDir(&quot;$libavDir&quot;)
3135                                             commandLine(&quot;chmod&quot;, &quot;+x&quot;, &quot;version.sh&quot;)
3136                                         }
3137                                     } else {
3138                                         versionFile = &quot;${libavDir}/ffbuild/version.sh&quot;
3139                                         verFile = file(versionFile)
3140                                         if (verFile.exists()) {
3141                                             exec {
3142                                                 workingDir(&quot;${libavDir}/ffbuild&quot;)
3143                                                 commandLine(&quot;chmod&quot;)
3144                                                 args += &quot;+x&quot;
3145                                                 args += [&quot;version.sh&quot;, &quot;libversion.sh&quot;, &quot;pkgconfig_generate.sh&quot;]
3146                                             }
3147                                         }
3148                                     }
3149                                     exec {
3150                                         workingDir(&quot;$libavDir&quot;)
3151                                         if (IS_BUILD_WORKING_LIBAV) {
3152                                             commandLine(cfgCMDArgs + commonCfgArgs + codecsCfgArgs)
3153                                         } else {
3154                                             commandLine(cfgCMDArgs + commonCfgArgs)
3155                                         }
3156                                     }
3157                                 }
3158                                 exec {
3159                                     workingDir(&quot;$libavDir&quot;)
3160                                     commandLine(&quot;make&quot;)
3161                                 }
3162                             }
3163                         }
3164 
3165                         libav.versions.each { version -&gt;
3166                             def fromDir = &quot;${libav.basedir}/ffmpeg-${version}&quot;
3167                             def majorVersion = libav.versionmap[version]
3168                             def toDir = &quot;${libav.basedir}/ffmpeg-${majorVersion}&quot;
3169                             copyLibAVStubs(fromDir, toDir)
3170                         }
3171                     }
3172                 }
3173 
3174                 def buildAVPlugin = task( &quot;buildAVPlugin&quot;, dependsOn: [buildPlugins, buildLibAVStubs, buildLibAVFFmpegStubs, buildFFmpegStubs]) {
3175                     enabled = IS_COMPILE_MEDIA
3176 
3177                     doLast {
3178                         if (IS_BUILD_LIBAV_STUBS) {
3179                             project.ext.libav = [:]
3180                             project.ext.libav.basedir = &quot;${buildDir}/native/linux/libav/libav&quot;
3181                             project.ext.libav.versions = [ &quot;53&quot;, &quot;54&quot;, &quot;55&quot;, &quot;56&quot;, &quot;57&quot; ]
3182                             project.ext.libav.libavffmpeg = [:]
3183                             project.ext.libav.libavffmpeg.basedir = &quot;${buildDir}/native/linux/libavffmpeg/libav&quot;
3184                             project.ext.libav.libavffmpeg.versions = [ &quot;56&quot; ]
3185                             project.ext.libav.ffmpeg = [:]
3186                             project.ext.libav.ffmpeg.basedir = &quot;${buildDir}/native/linux/ffmpeg/ffmpeg&quot;
3187                             project.ext.libav.ffmpeg.versions = [ &quot;57&quot;, &quot;58&quot; ]
3188 
3189                             project.ext.libav.versions.each { version -&gt;
3190                                 def libavDir = &quot;${project.ext.libav.basedir}-${version}&quot;
3191                                 File dir = file(libavDir)
3192                                 if (dir.exists()) {
3193                                     exec {
3194                                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/linux/avplugin&quot;)
3195                                         args(&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;,
3196                                              &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;,
3197                                              &quot;BASE_NAME=avplugin&quot;, &quot;VERSION=${version}&quot;, &quot;LIBAV_DIR=${libavDir}&quot;,
3198                                              &quot;SUFFIX=&quot;, IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;)
3199                                     }
3200                                 }
3201                             }
3202 
3203                             project.ext.libav.libavffmpeg.versions.each { version -&gt;
3204                                 def libavDir = &quot;${project.ext.libav.libavffmpeg.basedir}-${version}&quot;
3205                                 File dir = file(libavDir)
3206                                 if (dir.exists()) {
3207                                     exec {
3208                                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/linux/avplugin&quot;)
3209                                         args(&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;,
3210                                              &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;,
3211                                              &quot;BASE_NAME=avplugin&quot;, &quot;VERSION=${version}&quot;, &quot;LIBAV_DIR=${libavDir}&quot;,
3212                                              &quot;SUFFIX=-ffmpeg&quot;, IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;)
3213                                     }
3214                                 }
3215                             }
3216 
3217                             project.ext.libav.ffmpeg.versions.each { version -&gt;
3218                                 def libavDir = &quot;${project.ext.libav.ffmpeg.basedir}-${version}&quot;
3219                                 File dir = file(libavDir)
3220                                 if (dir.exists()) {
3221                                     exec {
3222                                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/linux/avplugin&quot;)
3223                                         args(&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;,
3224                                              &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;,
3225                                              &quot;BASE_NAME=avplugin&quot;, &quot;VERSION=${version}&quot;, &quot;LIBAV_DIR=${libavDir}&quot;,
3226                                              &quot;SUFFIX=-ffmpeg&quot;, IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;)
3227                                     }
3228                                 }
3229                             }
3230                         } else {
3231                             // Building fxavcodec plugin (libav plugin)
3232                             exec {
3233                                 commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/linux/avplugin&quot;)
3234                                 args(&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;,
3235                                      &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;,
3236                                      &quot;BASE_NAME=avplugin&quot;, IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;)
3237                             }
3238                         }
3239                     }
3240                 }
3241                 buildNative.dependsOn buildAVPlugin
3242             }
3243 
3244             if (t.name == &quot;win&quot;) {
3245                 def buildResources = task(&quot;buildResources&quot;) {
3246                     doLast {
3247                         def rcOutputDir = &quot;${nativeOutputDir}/${buildType}&quot;
3248                         mkdir rcOutputDir
3249                         exec {
3250                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3251                             commandLine (WIN.media.rcCompiler)
3252                             args(WIN.media.glibRcFlags)
3253                             args(&quot;/Fo${rcOutputDir}/${WIN.media.glibRcFile}&quot;, WIN.media.rcSource)
3254                         }
3255 
3256                         exec {
3257                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3258                             commandLine (WIN.media.rcCompiler)
3259                             args(WIN.media.gstreamerRcFlags)
3260                             args(&quot;/Fo${rcOutputDir}/${WIN.media.gstreamerRcFile}&quot;, WIN.media.rcSource)
3261                         }
3262 
3263                         exec {
3264                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3265                             commandLine (WIN.media.rcCompiler)
3266                             args(WIN.media.fxpluginsRcFlags)
3267                             args(&quot;/Fo${rcOutputDir}/${WIN.media.fxpluginsRcFile}&quot;, WIN.media.rcSource)
3268                         }
3269 
3270                         exec {
3271                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3272                             commandLine (WIN.media.rcCompiler)
3273                             args(WIN.media.jfxmediaRcFlags)
3274                             args(&quot;/Fo${rcOutputDir}/${WIN.media.jfxmediaRcFile}&quot;, WIN.media.rcSource)
3275                         }
3276                     }
3277                 }
3278 
3279                 def buildGlib = task(&quot;build${t.capital}Glib&quot;, dependsOn: [buildResources]) {
3280                     enabled = IS_COMPILE_MEDIA
3281                     doLast {
3282                         exec {
3283                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3284                             commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/glib-lite&quot;)
3285                             args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=glib-lite&quot;,
3286                                  IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;, &quot;RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.glibRcFile}&quot;,
3287                                  &quot;CC=${mediaProperties.compiler}&quot;, &quot;AR=${mediaProperties.ar}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
3288                         }
3289                     }
3290                 }
3291                 buildGStreamer.dependsOn buildGlib
3292 
3293             } else if (t.name == &quot;mac&quot;) {
3294                 def buildGlib = task(&quot;build${t.capital}Glib&quot;) {
3295                     enabled = IS_COMPILE_MEDIA
3296                     doLast {
3297                         exec {
3298                             commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/libffi&quot;)
3299                             args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=ffi&quot;)
3300                             args (&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;, &quot;AR=${mediaProperties.ar}&quot;)
3301                         }
3302 
3303                         exec {
3304                             commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/glib-lite&quot;)
3305                             args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=glib-lite&quot;)
3306                             args (&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
3307                         }
3308                     }
3309                 }
3310                 buildGStreamer.dependsOn buildGlib
3311             }
3312         }
3313 
3314         buildNativeTargets.dependsOn buildNative
3315     }
3316 
3317     jar {
3318         exclude(&quot;headergen/**&quot;)
3319 
3320         dependsOn compileJava
3321         if (IS_COMPILE_MEDIA) {
3322             dependsOn buildNativeTargets
3323         }
3324     }
3325 
3326     addMavenPublication(project, [ &#39;graphics&#39; ])
3327 
3328     addValidateSourceSets(project, sourceSets)
3329 }
3330 
3331 project(&quot;:web&quot;) {
3332     configurations {
3333         webkit
3334     }
3335     project.ext.buildModule = true
3336     project.ext.includeSources = true
3337     project.ext.moduleRuntime = true
3338     project.ext.moduleName = &quot;javafx.web&quot;
3339 
3340     sourceSets {
3341         main
3342         shims {
3343             java {
3344                 compileClasspath += sourceSets.main.output
3345                 runtimeClasspath += sourceSets.main.output
3346             }
3347         }
3348         test {
3349             java {
3350                 compileClasspath += sourceSets.shims.output
3351                 runtimeClasspath += sourceSets.shims.output
3352             }
3353         }
3354     }
3355 
3356     project.ext.moduleSourcePath = defaultModuleSourcePath
3357     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
3358 
3359     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;controls&#39;, &#39;media&#39;, &#39;web&#39; ])
3360 
3361     dependencies {
3362         compile project(&quot;:base&quot;)
3363         compile project(&quot;:graphics&quot;)
3364         compile project(&quot;:controls&quot;)
3365         compile project(&quot;:media&quot;)
3366     }
3367 
3368     compileJava.dependsOn updateCacheIfNeeded
3369 
3370     task webArchiveJar(type: Jar) {
3371         from (project.file(&quot;$projectDir/src/test/resources/test/html&quot;)) {
3372             include &quot;**/archive-*.*&quot;
3373         }
3374         archiveName = &quot;webArchiveJar.jar&quot;
3375         destinationDir = file(&quot;$buildDir/testing/resources&quot;)
3376     }
3377 
3378     def gensrcDir = &quot;${buildDir}/gensrc/java&quot;
3379 
3380     // add in the wrappers to the compile
3381     sourceSets.main.java.srcDirs += &quot;${gensrcDir}&quot;
3382 
3383     if (IS_COMPILE_WEBKIT) {
3384         compileJava {
3385             // generate the native headers during compile
3386             // only needed if we are doing the native compile
3387             options.compilerArgs.addAll([
3388                 &#39;-h&#39;, &quot;${project.buildDir}/gensrc/headers&quot;
3389                 ])
3390         }
3391     }
3392 
3393     // Copy these to a common location in the moduleSourcePath
3394     def copyWrappers = project.task(&quot;copyPreGeneratedWrappers&quot;, type: Copy) {
3395         from &quot;src/main/native/Source/WebCore/bindings/java/dom3/java&quot;
3396         into &quot;${gensrcDir}&quot;
3397     }
3398 
3399     compileJava.dependsOn(copyWrappers);
3400 
3401     test {
3402         doFirst {
3403             if (IS_STUB_RUNTIME_OPENJFX) {
3404                 println &quot;********************************************************&quot;
3405                 println &quot;WARNING: running web tests with officially built webkit.&quot;
3406                 println &quot;The webkit native library may not be compatible with the&quot;
3407                 println &quot;source tree you are using.&quot;
3408                 println &quot;If tests fail, try compiling webkit instead.&quot;
3409                 println &quot;See WEBKIT-MEDIA-STUBS.md&quot;
3410                 println &quot;********************************************************&quot;
3411             } else if (!IS_COMPILE_WEBKIT) {
3412                 println &quot;******************************************************&quot;
3413                 println &quot;WARNING: running web tests without building webkit.&quot;
3414                 println &quot;The webkit native library will be copied from the JDK,&quot;
3415                 println &quot;which might lead to failures in some web tests.&quot;
3416                 println &quot;See WEBKIT-MEDIA-STUBS.md&quot;
3417                 println &quot;******************************************************&quot;
3418             }
3419         }
3420         // Run web tests in headless mode
3421         systemProperty &#39;glass.platform&#39;, &#39;Monocle&#39;
3422         systemProperty &#39;monocle.platform&#39;, &#39;Headless&#39;
3423         systemProperty &#39;prism.order&#39;, &#39;sw&#39;
3424         dependsOn webArchiveJar
3425         def testResourceDir = file(&quot;$buildDir/testing/resources&quot;)
3426         jvmArgs &quot;-DWEB_ARCHIVE_JAR_TEST_DIR=$testResourceDir&quot;
3427     }
3428 
3429     task compileJavaDOMBinding()
3430 
3431     compileTargets { t -&gt;
3432         def targetProperties = project.rootProject.ext[t.upper]
3433         def webkitProperties = targetProperties.webkit
3434         def classifier = (t.name != &quot;linux&quot; &amp;&amp; t.name != &quot;win&quot;) ? t.name :
3435                           IS_64 ? &quot;${t.name}-amd64&quot; : &quot;${t.name}-i586&quot;
3436 
3437         def webkitOutputDir = cygpath(&quot;$buildDir/${t.name}&quot;)
3438         def webkitConfig = IS_DEBUG_NATIVE ? &quot;Debug&quot; : &quot;Release&quot;
3439 
3440         File nativeBuildDir = new File(&quot;${webkitOutputDir}&quot;)
3441         nativeBuildDir.mkdirs()
3442 
3443         def compileNativeTask = task(&quot;compileNative${t.capital}&quot;, dependsOn: [compileJava]) {
3444             println &quot;Building Webkit configuration /$webkitConfig/ into $webkitOutputDir&quot;
3445             enabled =  (IS_COMPILE_WEBKIT)
3446 
3447             doLast {
3448                 exec {
3449                     workingDir(&quot;$webkitOutputDir&quot;)
3450                     commandLine(&quot;perl&quot;, &quot;$projectDir/src/main/native/Tools/Scripts/set-webkit-configuration&quot;, &quot;--$webkitConfig&quot;)
3451                     environment([&quot;WEBKIT_OUTPUTDIR&quot; : webkitOutputDir])
3452                 }
3453 
3454                 exec {
3455                     workingDir(&quot;$webkitOutputDir&quot;)
3456                     def cmakeArgs = &quot;-DENABLE_TOOLS=1&quot;
3457                     if (IS_STATIC_BUILD) {
3458                         cmakeArgs = &quot; $cmakeArgs -DSTATIC_BUILD=1 -DUSE_THIN_ARCHIVES=OFF&quot;;
3459                     }
3460                     cmakeArgs = &quot; $cmakeArgs -DCMAKE_C_COMPILER=&#39;${webkitProperties.compiler}&#39;&quot;
3461                     if (t.name == &quot;win&quot;) {
3462                         // To enable ninja build on Windows
3463                         environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3464                     } else if (t.name == &quot;mac&quot;) {
3465                         cmakeArgs = &quot; $cmakeArgs -DCMAKE_OSX_DEPLOYMENT_TARGET=$MACOSX_MIN_VERSION -DCMAKE_OSX_SYSROOT=$MACOSX_SDK_PATH&quot;
3466                     } else if (t.name == &quot;linux&quot;) {
3467                         cmakeArgs = &quot; $cmakeArgs -DCMAKE_SYSTEM_NAME=Linux&quot;
3468                         if (IS_64) {
3469                             cmakeArgs = &quot;$cmakeArgs -DCMAKE_SYSTEM_PROCESSOR=x86_64&quot;
3470                         } else {
3471                             cmakeArgs = &quot;$cmakeArgs -DCMAKE_SYSTEM_PROCESSOR=i586&quot;
3472                         }
3473                         // TODO: Use cflags and ldflags from all platforms
3474                         def cFlags = webkitProperties.ccFlags?.join(&#39; &#39;) ?: &#39;&#39;
3475                         def lFlags = webkitProperties.linkFlags?.join(&#39; &#39;) ?: &#39;&#39;
3476                         if (IS_STATIC_BUILD) {
3477                             cFlags = &quot; $cFlags -DSTATIC_BUILD=1&quot;;
3478                         }
3479                         // -shared flag should be omitted while creating executable.
3480                         def exeFlags = webkitProperties.linkFlags?.join(&#39; &#39;)?.replace(&#39;-shared&#39;, &#39;&#39;) ?: &#39;&#39;
3481                         cmakeArgs = &quot;$cmakeArgs -DCMAKE_C_FLAGS=&#39;${cFlags}&#39; -DCMAKE_CXX_FLAGS=&#39;${cFlags}&#39;&quot;
3482                         cmakeArgs = &quot;$cmakeArgs -DCMAKE_SHARED_LINKER_FLAGS=&#39;${lFlags}&#39; -DCMAKE_EXE_LINKER_FLAGS=&#39;${exeFlags}&#39;&quot;
3483                     } else if (t.name.startsWith(&quot;arm&quot;)) {
3484                         fail(&quot;ARM target is not supported as of now.&quot;)
3485                     }
3486 
3487                     if (IS_COMPILE_PARFAIT) {
3488                         environment([
3489                             &quot;COMPILE_PARFAIT&quot; : &quot;true&quot;
3490                         ])
3491                         environment &quot;PATH&quot;, System.env.PARFAIT_PATH + File.pathSeparator + environment.PATH
3492                         cmakeArgs = &quot;-DCMAKE_C_COMPILER=parfait-gcc -DCMAKE_CXX_COMPILER=parfait-g++&quot;
3493                     }
3494 
3495                     if (project.hasProperty(&#39;toolsPath&#39;)) {
3496                         environment &quot;PATH&quot;, toolsPath + File.pathSeparator + environment.PATH
3497                     }
3498 
3499                     environment([
3500                         &quot;JAVA_HOME&quot;       : JDK_HOME,
3501                         &quot;WEBKIT_OUTPUTDIR&quot; : webkitOutputDir,
3502                         &quot;PYTHONDONTWRITEBYTECODE&quot; : &quot;1&quot;,
3503                     ])
3504 
3505                     def targetCpuBitDepthSwitch = &quot;&quot;
3506                     if (IS_64) {
3507                         targetCpuBitDepthSwitch = &quot;--64-bit&quot;
3508                     } else {
3509                         targetCpuBitDepthSwitch = &quot;--32-bit&quot;
3510                     }
3511                     cmakeArgs += &quot; -DJAVAFX_RELEASE_VERSION=${jfxReleaseMajorVersion}&quot;
3512                     commandLine(&quot;perl&quot;, &quot;$projectDir/src/main/native/Tools/Scripts/build-webkit&quot;,
3513                         &quot;--java&quot;, &quot;--icu-unicode&quot;, targetCpuBitDepthSwitch,
3514                         &quot;--no-experimental-features&quot;, &quot;--cmakeargs=${cmakeArgs}&quot;)
3515                 }
3516             }
3517         }
3518 
3519         // Cmake places Windows DLL in bin directory
3520         def dllDir = IS_WINDOWS ? &quot;bin&quot; : &quot;lib&quot;
3521         def copyDumpTreeNativeTask = task(&quot;copyDumpTreeNative${t.capital}&quot;, type: Copy,
3522                 dependsOn: [ compileNativeTask]) {
3523             def library = rootProject.ext[t.upper].library
3524             from &quot;$webkitOutputDir/$webkitConfig/$dllDir/${library(&#39;DumpRenderTreeJava&#39;)}&quot;
3525             into &quot;$buildDir/test/${t.name}&quot;
3526         }
3527 
3528         def copyNativeTask = task(&quot;copyNative${t.capital}&quot;, type: Copy,
3529                 dependsOn: [compileNativeTask, copyDumpTreeNativeTask]) {
3530             enabled =  (IS_COMPILE_WEBKIT)
3531             def library = rootProject.ext[t.upper].library
3532             from &quot;$webkitOutputDir/$webkitConfig/$dllDir/${library(&#39;jfxwebkit&#39;)}&quot;
3533             into &quot;$buildDir/libs/${t.name}&quot;
3534         }
3535 
3536         if (IS_WINDOWS &amp;&amp; t.name == &quot;win&quot;) {
3537             def rcTask = project.task(&quot;rc${t.capital}&quot;, type: CompileResourceTask) {
3538                 compiler = webkitProperties.rcCompiler
3539                 source(webkitProperties.rcSource)
3540                 if (webkitProperties.rcFlags) {
3541                     rcParams.addAll(webkitProperties.rcFlags)
3542                 }
3543                 output(file(&quot;$webkitOutputDir/$webkitConfig/WebCore/obj&quot;))
3544             }
3545             compileNativeTask.dependsOn rcTask
3546         }
3547 
3548         def compileJavaDOMBindingTask = task(&quot;compileJavaDOMBinding${t.capital}&quot;, type: JavaCompile,
3549                 dependsOn: [compileJava, compileNativeTask, copyNativeTask]) {
3550             destinationDir = file(&quot;$buildDir/classes/java/main&quot;)
3551             classpath = configurations.compile
3552             source = project.sourceSets.main.java.srcDirs
3553             options.compilerArgs.addAll([
3554                 &#39;-implicit:none&#39;,
3555                 &#39;--module-source-path&#39;, defaultModuleSourcePath
3556                 ])
3557         }
3558 
3559         compileJavaDOMBinding.dependsOn compileJavaDOMBindingTask
3560 
3561         if (!targetProperties.compileWebnodeNative) {
3562             println(&quot;Not compiling native Webkit for ${t.name} per configuration request&quot;);
3563             compileNativeTask.enabled = false
3564         }
3565     }
3566 
3567     def drtClasses = &quot;**/com/sun/javafx/webkit/drt/**&quot;
3568     task drtJar(type: Jar, dependsOn: compileJava) {
3569         archiveName = &quot;drt.jar&quot;
3570         destinationDir = file(&quot;$buildDir/test&quot;)
3571         from &quot;$buildDir/classes/java/main/javafx.web/&quot;
3572         include drtClasses
3573         includeEmptyDirs = false
3574     }
3575 
3576     if (IS_COMPILE_WEBKIT) {
3577         assemble.dependsOn compileJavaDOMBinding, drtJar
3578     }
3579 
3580     addMavenPublication(project, [ &#39;controls&#39;, &#39;media&#39; ])
3581 
3582     addValidateSourceSets(project, sourceSets)
3583 }
3584 
3585 // This project is for system tests that need to run with a full SDK.
3586 // Most of them display a stage or do other things that preclude running
3587 // them in a shared JVM or as part of the &quot;smoke test&quot; run (which must
3588 // not pop up any windows or use audio). As such, they are only enabled
3589 // when FULL_TEST is specified, and each test runs in its own JVM
3590 project(&quot;:systemTests&quot;) {
3591 
3592     sourceSets {
3593         test
3594 
3595         // Source sets for standalone test apps (used for launcher tests)
3596         testapp1
3597 
3598         // Modular applications
3599         testapp2
3600         testapp3
3601         testapp4
3602         testapp5
3603         testapp6
3604         testscriptapp1
3605         testscriptapp2
3606     }
3607 
3608     def nonModSrcSets = [
3609         sourceSets.test,
3610         sourceSets.testapp1
3611     ]
3612 
3613     def modSrcSets = [
3614         sourceSets.testapp2,
3615         sourceSets.testapp3,
3616         sourceSets.testapp4,
3617         sourceSets.testapp5,
3618         sourceSets.testapp6,
3619         sourceSets.testscriptapp1,
3620         sourceSets.testscriptapp2
3621     ]
3622 
3623     project.ext.buildModule = false
3624     project.ext.moduleRuntime = false
3625     project.ext.moduleName = &quot;systemTests&quot;
3626 
3627     dependencies {
3628         testCompile project(&quot;:graphics&quot;).sourceSets.test.output
3629         testCompile project(&quot;:base&quot;).sourceSets.test.output
3630         testCompile project(&quot;:controls&quot;).sourceSets.test.output
3631         testCompile project(&quot;:swing&quot;).sourceSets.test.output
3632     }
3633 
3634     def dependentProjects = [ &#39;base&#39;, &#39;graphics&#39;, &#39;controls&#39;, &#39;media&#39;, &#39;web&#39;, &#39;swing&#39;, &#39;fxml&#39; ]
3635     commonModuleSetup(project, dependentProjects)
3636 
3637     File testJavaPolicyFile = new File(rootProject.buildDir, TESTJAVAPOLICYFILE);
3638     File testRunArgsFile = new File(rootProject.buildDir,TESTRUNARGSFILE);
3639 
3640     File stRunArgsFile = new File(project.buildDir,&quot;st.run.args&quot;);
3641 
3642     def sts = task(&quot;systemTestSetup&quot;) {
3643         outputs.file(stRunArgsFile)
3644 
3645         doLast() {
3646             stRunArgsFile.delete()
3647 
3648             logger.info(&quot;Creating patchmodule.args file ${stRunArgsFile}&quot;)
3649 
3650             // Create an argfile with the information needed to launch
3651             // the stand alone system unit tests.
3652 
3653             //First add in all of the patch-module args we use for the
3654             //normal unit tests, copied from test.run.args
3655             testRunArgsFile.eachLine { str -&gt;
3656                 stRunArgsFile &lt;&lt;  &quot;${str}\n&quot;
3657             }
3658 
3659             // Now add in the working classpath elements (junit, test classes...)
3660             stRunArgsFile &lt;&lt;  &quot;-cp \&quot;\\\n&quot;
3661             test.classpath.each() { elem -&gt;
3662                 def e = cygpath(&quot;${elem}&quot;)
3663                 stRunArgsFile &lt;&lt;  &quot;  ${e}${File.pathSeparator}\\\n&quot;
3664             }
3665             stRunArgsFile &lt;&lt;  &quot;\&quot;\n&quot;
3666         }
3667     }
3668 
3669     test.dependsOn(sts)
3670     test.dependsOn(createTestArgfiles);
3671 
3672     // Tasks to create standalone test applications for the launcher tests
3673 
3674     if (project.hasProperty(&#39;testModulePathArgs&#39;)) {
3675         compileTestapp1Java.options.compilerArgs.addAll(testModulePathArgs)
3676     }
3677     dependentProjects.each { e -&gt;
3678         compileTestapp1Java.dependsOn(rootProject.project(e).testClasses)
3679     }
3680 
3681     def testapp1JarName = &quot;testapp1.jar&quot;
3682     task createTestapp1Jar1(type: Jar) {
3683         dependsOn compileTestapp1Java
3684         enabled = IS_FULL_TEST
3685 
3686         destinationDir = file(&quot;$buildDir/testapp1&quot;)
3687         archiveName = testapp1JarName
3688         includeEmptyDirs = false
3689         from project.sourceSets.testapp1.java.outputDir
3690         include(&quot;testapp/**&quot;)
3691         include(&quot;com/javafx/main/**&quot;)
3692 
3693         manifest {
3694             attributes(
3695                 &quot;Main-Class&quot; : &quot;com.javafx.main.Main&quot;,
3696                 &quot;JavaFX-Version&quot; : &quot;2.2&quot;,
3697                 &quot;JavaFX-Application-Class&quot; : &quot;testapp.HelloWorld&quot;,
3698                 &quot;JavaFX-Class-Path&quot; : &quot;jar2.jar&quot;
3699             )
3700         }
3701     }
3702 
3703     task createTestapp1Jar2(type: Jar) {
3704         dependsOn compileTestapp1Java
3705         enabled = IS_FULL_TEST
3706 
3707         destinationDir = file(&quot;$buildDir/testapp1&quot;)
3708         archiveName = &quot;jar2.jar&quot;;
3709         includeEmptyDirs = false
3710         from project.sourceSets.testapp1.java.outputDir
3711         include(&quot;pkg2/**&quot;)
3712     }
3713 
3714     task createTestApps() {
3715         dependsOn(createTestapp1Jar1)
3716         dependsOn(createTestapp1Jar2)
3717     }
3718     test.dependsOn(createTestApps);
3719 
3720     def modtestapps = [ &quot;testapp2&quot;, &quot;testapp3&quot;, &quot;testapp4&quot;, &quot;testapp5&quot;, &quot;testapp6&quot;, &quot;testscriptapp1&quot;, &quot;testscriptapp2&quot; ]
3721     modtestapps.each { testapp -&gt;
3722         def testappCapital = testapp.capitalize()
3723         def copyTestAppTask = task(&quot;copy${testappCapital}&quot;, type: Copy) {
3724             from project.sourceSets.&quot;${testapp}&quot;.java.outputDir
3725             from project.sourceSets.&quot;${testapp}&quot;.output.resourcesDir
3726             into &quot;${project.buildDir}/modules/${testapp}&quot;
3727         }
3728 
3729         def List&lt;String&gt; testAppSourceDirs = []
3730         project.sourceSets.&quot;${testapp}&quot;.java.srcDirs.each { dir -&gt;
3731             testAppSourceDirs += dir
3732         }
3733         def testappCompileTasks = project.getTasksByName(&quot;compile${testappCapital}Java&quot;, true);
3734         def testappResourceTasks = project.getTasksByName(&quot;process${testappCapital}Resources&quot;, true);
3735         testappCompileTasks.each { appCompileTask -&gt;
3736             appCompileTask.options.compilerArgs.addAll([
3737                 &#39;-implicit:none&#39;,
3738                 &#39;--module-source-path&#39;, testAppSourceDirs.join(File.pathSeparator),
3739                 ] )
3740             if (project.hasProperty(&#39;testModulePathArgs&#39;)) {
3741                 appCompileTask.options.compilerArgs.addAll(testModulePathArgs)
3742             }
3743 
3744             dependentProjects.each { e -&gt;
3745                 appCompileTask.dependsOn(rootProject.project(e).testClasses)
3746             }
3747 
3748             copyTestAppTask.dependsOn(appCompileTask)
3749         }
3750         testappResourceTasks.each { appResourceTask -&gt;
3751             copyTestAppTask.dependsOn(appResourceTask)
3752         }
3753 
3754         createTestApps.dependsOn(copyTestAppTask)
3755     }
3756 
3757     test {
3758         enabled = IS_FULL_TEST
3759 
3760         // Parse testPatchModuleArgs looking for &quot;--module-path&quot;.
3761         // Save path if found so we can pass it to the module launcher tests
3762         def pendingModulePath = false
3763         testPatchModuleArgs.each { str -&gt;
3764             if (pendingModulePath) {
3765                 project.ext.launcherModulePath = str;
3766                 pendingModulePath = false
3767             } else if (str == &quot;--module-path&quot;) {
3768                 pendingModulePath = true
3769             }
3770         }
3771 
3772         // Properties passed to launcher tests
3773         systemProperty &quot;launchertest.testapp1.jar&quot;, &quot;build/testapp1/$testapp1JarName&quot;
3774         modtestapps.each { testapp -&gt;
3775             systemProperty &quot;launchertest.${testapp}.module.path&quot;,
3776                     &quot;${project.buildDir}/modules/${testapp}&quot;
3777         }
3778 
3779         // Properties passed to test.util.Util
3780         systemProperties &#39;worker.debug&#39;: IS_WORKER_DEBUG
3781         systemProperties &#39;worker.patchmodule.file&#39;: cygpath(stRunArgsFile.path)
3782         if (project.hasProperty(&quot;launcherModulePath&quot;)) {
3783             systemProperties &#39;worker.module.path&#39;: launcherModulePath
3784         }
3785         systemProperties &#39;worker.patch.policy&#39;: cygpath(testJavaPolicyFile.path)
3786         systemProperties &#39;worker.java.cmd&#39;: JAVA
3787 
3788         if (rootProject.hasProperty(&quot;ClipShapeTest.numTests&quot;)) {
3789             systemProperty &quot;ClipShapeTest.numTests&quot;, rootProject.getProperty(&quot;ClipShapeTest.numTests&quot;)
3790         }
3791 
3792         if (!IS_USE_ROBOT) {
3793             // Disable all robot-based visual tests
3794             exclude(&quot;test/robot/**&quot;);
3795         }
3796         if (!IS_UNSTABLE_TEST) {
3797             // JDK-8196607 Don&#39;t run monocle test cases 
3798             exclude(&quot;test/robot/com/sun/glass/ui/monocle/**&quot;);
3799         }
3800         if (!IS_AWT_TEST) {
3801             // Disable all AWT-based tests
3802             exclude(&quot;**/javafx/embed/swing/*.*&quot;);
3803             exclude(&quot;**/com/sun/javafx/application/Swing*.*&quot;);
3804         }
3805 
3806         forkEvery = 1
3807     }
3808 
3809     addValidateSourceSets(project, nonModSrcSets, modSrcSets)
3810 }
3811 
3812 allprojects {
3813     // The following block is a workaround for the fact that presently Gradle
3814     // can&#39;t set the -XDignore.symbol.file flag, because it appears that the
3815     // javac API is lacking support for it. So what we&#39;ll do is find any Compile
3816     // task and manually provide the options necessary to fire up the
3817     // compiler with the right settings.
3818     tasks.withType(JavaCompile) { compile -&gt;
3819         if (compile.options.hasProperty(&quot;useAnt&quot;)) {
3820             compile.options.useAnt = true
3821             compile.options.useDepend = IS_USE_DEPEND
3822         } else if (compile.options.hasProperty(&quot;incremental&quot;)) {
3823             compile.options.incremental = IS_INCREMENTAL
3824         }
3825         compile.options.debug = true // we always generate debugging info in the class files
3826         compile.options.debugOptions.debugLevel = IS_DEBUG_JAVA ? &quot;source,lines,vars&quot; : &quot;source,lines&quot;
3827         compile.options.fork = true
3828 
3829         compile.options.forkOptions.executable = JAVAC
3830 
3831         compile.options.warnings = IS_LINT
3832 
3833         compile.options.compilerArgs += [&quot;-XDignore.symbol.file&quot;, &quot;-encoding&quot;, &quot;UTF-8&quot;]
3834 
3835         // we use a custom javadoc command
3836         project.javadoc.enabled = false
3837 
3838         // Add in the -Xlint options
3839         if (IS_LINT) {
3840             LINT.split(&quot;[, ]&quot;).each { s -&gt;
3841                 compile.options.compilerArgs += &quot;-Xlint:$s&quot;
3842             }
3843         }
3844     } // tasks with javaCompile
3845 
3846     // If I am a module....
3847     if (project.hasProperty(&#39;moduleSourcePath&#39;) &amp;&amp;
3848             (project.hasProperty(&#39;buildModule&#39;) &amp;&amp; project.buildModule)) {
3849         project.compileJava {
3850             options.compilerArgs.addAll([
3851                 &#39;-implicit:none&#39;,
3852                 &#39;--module-source-path&#39;, project.moduleSourcePath
3853                 ])
3854         }
3855         // no jars needed for modules
3856         project.jar.enabled = false
3857 
3858         // and redirect the resources into the module
3859         project.sourceSets.main.output.resourcesDir = project.moduleDir
3860         project.processResources.destinationDir = project.moduleDir
3861     }
3862 
3863     if (project.hasProperty(&#39;moduleSourcePathShim&#39;) &amp;&amp;
3864             project.sourceSets.hasProperty(&#39;shims&#39;)) {
3865 
3866         // sync up the obvious source directories with the shims
3867         // others (like the shaders in graphics) should be added in there
3868         project.sourceSets.shims.java.srcDirs += project.sourceSets.main.java.srcDirs
3869         project.sourceSets.shims.java.srcDirs += &quot;$buildDir/gensrc/java&quot;
3870 
3871         project.compileShimsJava {
3872             options.compilerArgs.addAll([
3873                 &#39;-implicit:none&#39;,
3874                 &#39;--module-source-path&#39;, project.moduleSourcePathShim
3875                 ])
3876         }
3877         project.compileShimsJava.dependsOn(project.compileJava)
3878 
3879         def copyGeneratedShimsTask = task(&quot;copyGeneratedShims&quot;, type: Copy, dependsOn: [compileShimsJava, processShimsResources]) {
3880             from project.sourceSets.shims.java.outputDir
3881             into &quot;${rootProject.buildDir}/shims&quot;
3882             if (HAS_JAVAFX_MODULES) {
3883                 exclude(&quot;*/module-info.class&quot;)
3884             }
3885         }
3886 
3887         project.processShimsResources.dependsOn(project.processResources)
3888 
3889         // shims resources should have the main resouces as a base
3890         project.sourceSets.shims.resources.srcDirs += project.sourceSets.main.resources.srcDirs
3891 
3892         // and redirect the resources into the module
3893         project.sourceSets.shims.output.resourcesDir = project.moduleShimsDir
3894         project.processShimsResources.destinationDir = project.moduleShimsDir
3895 
3896        compileTestJava.dependsOn(copyGeneratedShimsTask)
3897     }
3898 
3899     if (project.hasProperty(&#39;modulePathArgs&#39;)) {
3900         project.compileJava.options.compilerArgs.addAll(modulePathArgs)
3901     }
3902 
3903     if (project.hasProperty(&#39;testModulePathArgs&#39;)) {
3904         project.compileTestJava.options.compilerArgs.addAll(testModulePathArgs)
3905     }
3906 
3907     if (project.hasProperty(&#39;testPatchModuleArgs&#39;)) {
3908         project.test.jvmArgs += testPatchModuleArgs
3909     }
3910 
3911     /* Note: we should not have to add extraAddExports to the normal
3912      * modular compile, as it contains all of the module-info files.
3913      * In fact doing so might cover up a module-info issue.
3914      * so we don&#39;t do it, and I will leave this commented out
3915      * block as a reminder of this fact.
3916     if (project.hasProperty(&#39;extraAddExports&#39;)) {
3917         project.compileJava.options.compilerArgs.addAll(extraAddExports);
3918     }
3919     */
3920 
3921     if (project.hasProperty(&#39;testAddExports&#39;)) {
3922         project.compileTestJava.options.compilerArgs.addAll(testAddExports);
3923         project.test.jvmArgs += testAddExports
3924     }
3925 
3926     if (rootProject.hasProperty(&quot;EXTRA_TEST_ARGS&quot;) &amp;&amp; project.hasProperty(&#39;test&#39;)) {
3927         EXTRA_TEST_ARGS.split(&#39; &#39;).each() { e -&gt;
3928             project.test.jvmArgs += e
3929         }
3930     }
3931 
3932     if (rootProject.hasProperty(&quot;EXTRA_COMPILE_ARGS&quot;) &amp;&amp; project.hasProperty(&#39;compileJava&#39;)) {
3933         project.compileJava.options.compilerArgs.addAll(EXTRA_COMPILE_ARGS.split(&#39; &#39;))
3934     }
3935 
3936     if (rootProject.hasProperty(&quot;EXTRA_COMPILE_ARGS&quot;) &amp;&amp; project.hasProperty(&#39;compileTestJava&#39;)) {
3937         project.compileTestJava.options.compilerArgs.addAll(EXTRA_COMPILE_ARGS.split(&#39; &#39;))
3938     }
3939 }
3940 
3941 /******************************************************************************
3942  *                                                                            *
3943  *                             Top Level Tasks                                *
3944  *                                                                            *
3945  *  These are the tasks which are defined only for the top level project and  *
3946  *  not for any sub projects. These are generally the entry point that is     *
3947  *  used by Hudson and by the continuous build system.                        *
3948  *                                                                            *
3949  *****************************************************************************/
3950 
3951 task clean() {
3952     group = &quot;Basic&quot;
3953     description = &quot;Deletes the build directory and the build directory of all sub projects&quot;
3954     getSubprojects().each { subProject -&gt;
3955         dependsOn(subProject.getTasksByName(&quot;clean&quot;, true));
3956     }
3957     doLast {
3958         delete(buildDir);
3959     }
3960 }
3961 
3962 task cleanAll() {
3963     group = &quot;Basic&quot;
3964     description = &quot;Scrubs the repo of build artifacts&quot;
3965     dependsOn(clean)
3966     doLast {
3967         //delete(&quot;.gradle&quot;); This causes problems on windows.
3968         delete(&quot;buildSrc/build&quot;);
3969     }
3970 }
3971 
3972 task createMSPfile() {
3973     group = &quot;Build&quot;
3974     File mspFile = new File(rootProject.buildDir,MODULESOURCEPATH)
3975     outputs.file(mspFile)
3976 
3977     doLast {
3978         mspFile.delete()
3979         mspFile &lt;&lt; &quot;--module-source-path\n&quot;
3980         mspFile &lt;&lt; defaultModuleSourcePath
3981         mspFile &lt;&lt; &quot;\n&quot;
3982     }
3983 }
3984 
3985 task javadoc(type: Javadoc, dependsOn: createMSPfile) {
3986     group = &quot;Basic&quot;
3987     description = &quot;Generates the JavaDoc for all the public API&quot;
3988     executable = JAVADOC
3989     def projectsToDocument = [
3990             project(&quot;:base&quot;), project(&quot;:graphics&quot;), project(&quot;:controls&quot;), project(&quot;:media&quot;),
3991             project(&quot;:swing&quot;), /*project(&quot;:swt&quot;),*/ project(&quot;:fxml&quot;), project(&quot;:web&quot;)]
3992     source(projectsToDocument.collect({
3993         [it.sourceSets.main.java]
3994     }));
3995     setDestinationDir(new File(buildDir, &#39;javadoc&#39;));
3996 
3997     exclude(&quot;com/**/*&quot;, &quot;Compile*&quot;, &quot;javafx/builder/**/*&quot;, &quot;javafx/scene/accessibility/**/*&quot;);
3998 
3999     options.tags(&quot;apiNote:a:API Note:&quot;)
4000     options.tags(&quot;implSpec:a:Implementation Requirements:&quot;)
4001     options.tags(&quot;implNote:a:Implementation Note:&quot;)
4002     options.tags(&quot;param&quot;)
4003     options.tags(&quot;return&quot;)
4004     options.tags(&quot;throws&quot;)
4005     options.tags(&quot;moduleGraph:X&quot;)
4006     options.tags(&quot;since&quot;)
4007     options.tags(&quot;version&quot;)
4008     options.tags(&quot;serialData&quot;)
4009     options.tags(&quot;factory&quot;)
4010     options.tags(&quot;see&quot;)
4011 
4012     options.windowTitle(&quot;${javadocTitle}&quot;)
4013     options.header(&quot;${javadocHeader}&quot;)
4014     options.bottom(&quot;${javadocBottom}&quot;)
4015     options.locale(&quot;en&quot;);
4016     if (JDK_DOCS_LINK != &quot;&quot;) {
4017         options.linksOffline(JDK_DOCS, JDK_DOCS_LINK);
4018     } else {
4019         options.links(JDK_DOCS);
4020     }
4021     options.addBooleanOption(&quot;XDignore.symbol.file&quot;).setValue(true);
4022     options.addBooleanOption(&quot;Xdoclint:${DOC_LINT}&quot;).setValue(IS_DOC_LINT);
4023     options.addBooleanOption(&quot;html5&quot;).setValue(true);
4024     options.addBooleanOption(&quot;javafx&quot;).setValue(true);
4025     options.addBooleanOption(&quot;use&quot;).setValue(true);
4026 
4027     options.setOptionFiles([
4028         new File(rootProject.buildDir,MODULESOURCEPATH)
4029         ]);
4030 
4031     doLast {
4032         projectsToDocument.each { p -&gt;
4033             def destDir = &quot;$buildDir/javadoc/${p.ext.moduleName}&quot;
4034             copy {
4035                 from(&quot;$p.projectDir/src/main/docs&quot;) {
4036                     include &quot;**/*.html&quot;
4037                     filter { line-&gt;
4038                         line = line.replace(&quot;@FXVERSION@&quot;, RELEASE_VERSION)
4039                     }
4040                 }
4041                 from(&quot;$p.projectDir/src/main/docs&quot;) {
4042                     exclude &quot;**/*.html&quot;
4043                 }
4044 
4045                 into destDir
4046             }
4047         }
4048     }
4049 
4050     dependsOn(projectsToDocument.collect { project -&gt; project.getTasksByName(&quot;classes&quot;, true)});
4051 }
4052 
4053 task sdk() {
4054     if (DO_BUILD_SDK_FOR_TEST) {
4055         rootProject.getTasksByName(&quot;test&quot;, true).each { t -&gt;
4056             if (t.enabled) t.dependsOn(sdk)
4057         }
4058     }
4059 }
4060 
4061 task jmods() {
4062     dependsOn(sdk)
4063     // real work items added later.
4064 }
4065 
4066 task appsjar() {
4067     dependsOn(sdk)
4068     // Note: the jar dependencies get added elsewhere see project(&quot;:apps&quot;)
4069 }
4070 
4071 // these are empty tasks, allowing us to depend on the task, which may have other
4072 // real work items added later.
4073 task copyAppsArtifacts() {
4074     dependsOn(appsjar)
4075 }
4076 
4077 task apps() {
4078     dependsOn(sdk)
4079     dependsOn(appsjar)
4080     dependsOn(copyAppsArtifacts)
4081 }
4082 
4083 task findbugs() {
4084     dependsOn(sdk)
4085 
4086     doLast {
4087         if (!BUILD_CLOSED) {
4088             println &quot;findbugs task is only run for a closed build&quot;
4089         }
4090     }
4091 }
4092 
4093 // create the zip file of modules for a JDK build
4094 task jdkZip {
4095     dependsOn(sdk)
4096 }
4097 
4098 // The following tasks are for the closed build only. They are a no-op for the open build
4099 
4100 task checkCache() {
4101     dependsOn(updateCacheIfNeeded)
4102 }
4103 
4104 task publicExports() {
4105     dependsOn(sdk, jmods, apps, javadoc, jdkZip)
4106     // note the real work is below in the compileTargets
4107 }
4108 
4109 task perf() {
4110     dependsOn(sdk, apps)
4111     doLast {
4112         if (!BUILD_CLOSED) {
4113             println &quot;perf task is only run for a closed build&quot;
4114         }
4115     }
4116 }
4117 
4118 task zips() {
4119     dependsOn(sdk, jmods, javadoc, apps, jdkZip, publicExports, perf)
4120     // note the real work is below in the compileTargets
4121 }
4122 
4123 task all() {
4124     dependsOn(sdk,publicExports,apps,perf,zips)
4125 }
4126 
4127 
4128 // Construct list of subprojects that are modules
4129 ext.moduleProjList = []
4130 subprojects {
4131     if (project.hasProperty(&quot;buildModule&quot;) &amp;&amp; project.ext.buildModule) {
4132         rootProject.ext.moduleProjList += project
4133         println &quot;module: $project (buildModule=YES)&quot;
4134     } else {
4135         println &quot;module: $project (buildModule=NO)&quot;
4136     }
4137 }
4138 
4139 
4140 // Define the sdk task, which also produces the javafx.swt modular jar
4141 
4142 compileTargets { t -&gt;
4143 
4144     def javafxSwtTask = task(&quot;javafxSwt$t.capital&quot;, type: Jar) {
4145         enabled = COMPILE_SWT
4146         group = &quot;Basic&quot;
4147         description = &quot;Creates the javafx-swt.jar for the $t.name target&quot;
4148         destinationDir = file(&quot;${project(&quot;:swt&quot;).buildDir}/libs&quot;)
4149         archiveName = &quot;javafx-swt.jar&quot;
4150         includeEmptyDirs = false
4151         from(&quot;${project(&quot;:swt&quot;).buildDir}/classes/java/main&quot;);
4152         include(&quot;**/javafx/embed/swt/**&quot;)
4153 
4154         dependsOn(
4155             project(&quot;:swt&quot;).compileJava,
4156             project(&quot;:swt&quot;).processResources,
4157             // note: assemble and classes are not enough for DidWork
4158             project(&quot;:swt&quot;).classes,
4159             // classes is needed for a jar copy
4160             )
4161     }
4162 
4163     // FIXME: do we really need the index task for this modular jar?
4164     def javafxSwtIndexTask = task(&quot;javafxSwtIndex$t.capital&quot;) {
4165         //the following is a workaround for the lack of indexing in gradle 1.4 through 1.7
4166         dependsOn(javafxSwtTask)
4167 
4168         doLast() {
4169             ant.jar (update: true, index: true, destfile: &quot;${javafxSwtTask.destinationDir}/${javafxSwtTask.archiveName}&quot;)
4170         }
4171     }
4172 
4173     def sdkTask = task(&quot;sdk$t.capital&quot;) {
4174         group = &quot;Basic&quot;
4175         dependsOn(javafxSwtIndexTask)
4176     }
4177 
4178     sdk.dependsOn(sdkTask)
4179 }
4180 
4181 project(&quot;:apps&quot;) {
4182     // The apps build is Ant based, we will exec ant from gradle.
4183 
4184     // Download the Lucene libraries needed for the Ensemble8 app
4185     def luceneVersion = &quot;7.7.2&quot;
4186     getConfigurations().create(&quot;lucene&quot;);
4187     dependencies {
4188         lucene group: &quot;org.apache.lucene&quot;, name: &quot;lucene-core&quot;, version: luceneVersion
4189         lucene group: &quot;org.apache.lucene&quot;, name: &quot;lucene-grouping&quot;, version: luceneVersion
4190         lucene group: &quot;org.apache.lucene&quot;, name: &quot;lucene-queryparser&quot;, version: luceneVersion
4191     }
4192 
4193     // Copy Lucene libraries into the Ensemble8/lib directory
4194     File ensembleLibDir = rootProject.file(&quot;apps/samples/Ensemble8/lib&quot;);
4195     def libNames = [ &quot;lucene-core-${luceneVersion}.jar&quot;,
4196                      &quot;lucene-grouping-${luceneVersion}.jar&quot;,
4197                      &quot;lucene-queryparser-${luceneVersion}.jar&quot; ]
4198 
4199 
4200     task getLucene(type: Copy) {
4201         doFirst {
4202             ensembleLibDir.mkdirs();
4203         }
4204         into ensembleLibDir
4205         includeEmptyDirs = false
4206         configurations.lucene.files.each { f -&gt;
4207             libNames.each { name -&gt;
4208                 if (name == f.getName()) {
4209                     from f.getPath()
4210                 }
4211             }
4212         }
4213     }
4214 
4215     compileTargets { t -&gt;
4216         List&lt;String&gt; params = []
4217 
4218         params &lt;&lt; &quot;-DtargetBld=$t.name&quot;
4219 
4220         if (!rootProject.ext[t.upper].compileSwing) {
4221             params &lt;&lt; &quot;-DJFX_CORE_ONLY=true&quot;
4222         }
4223         params &lt;&lt; &quot;-Dplatforms.JDK_1.9.home=${rootProject.ext.JDK_HOME}&quot;
4224         params &lt;&lt; &quot;-Dcompile.patch=@${rootProject.buildDir}/${COMPILEARGSFILE}&quot;
4225         params &lt;&lt; &quot;-Drun.patch=@${rootProject.buildDir}/${RUNARGSFILE}&quot;
4226 
4227         def appsJar = project.task(&quot;appsJar${t.capital}&quot;) {
4228             dependsOn(sdk, getLucene)
4229             doLast() {
4230                 ant(t.name,
4231                       projectDir.path,
4232                       &quot;appsJar&quot;,
4233                       params);
4234             }
4235         }
4236         rootProject.appsjar.dependsOn(appsJar)
4237 
4238         def appsClean = project.task(&quot;clean${t.capital}&quot;) {
4239             doLast() {
4240                 ant(t.name,
4241                       project.projectDir.path,
4242                       &quot;clean&quot;,
4243                       params);
4244                 delete(ensembleLibDir);
4245             }
4246         }
4247         rootProject.clean.dependsOn(appsClean)
4248     }
4249 }
4250 
4251 // Tasks to create the disk layout for the sdk, jmods, and docs
4252 // in the artifacts directory (publicExports), and zip them up in
4253 // artifacts/bundles (zips)
4254 // These tasks are only used for the standalone SDK.
4255 compileTargets { t -&gt;
4256     if (!HAS_JAVAFX_MODULES) {
4257         def targetProperties = rootProject.ext[t.upper]
4258         def platformPrefix = targetProperties.platformPrefix
4259 
4260         def artifactsDir = &quot;${rootProject.buildDir}/artifacts&quot;
4261         def bundlesDir = &quot;${artifactsDir}/bundles&quot;
4262 
4263         def sdkDirName = &quot;${platformPrefix}sdk&quot;
4264         def sdkDir = &quot;${rootProject.buildDir}/${sdkDirName}&quot;
4265         def sdkBundleName = &quot;javafx-sdk-${RELEASE_VERSION}&quot;
4266         def sdkArtifactsDir = &quot;${artifactsDir}/${sdkBundleName}&quot;
4267 
4268         def docsDirName = &quot;javadoc&quot;
4269         def docsDir = &quot;${rootProject.buildDir}/${docsDirName}&quot;
4270         def docsBundleName = &quot;javafx-docs-${RELEASE_VERSION}&quot;
4271         def docsArtifactsDir = &quot;${artifactsDir}/${docsBundleName}&quot;
4272 
4273         def jmodsDirName = &quot;jmods&quot;
4274         def jmodsDir = &quot;${rootProject.buildDir}/${jmodsDirName}&quot;
4275         def jmodsBundleName = &quot;javafx-jmods-${RELEASE_VERSION}&quot;
4276         def jmodsArtifactsDir = &quot;${artifactsDir}/${jmodsBundleName}&quot;
4277 
4278         def publicExportsTask = task (&quot;publicExportsStandalone${t.capital}&quot;) {
4279             group = &quot;Basic&quot;
4280             description = &quot;Creates the disk layout for sdk, jmods, and docs&quot;
4281         }
4282         publicExports.dependsOn(publicExportsTask)
4283 
4284         def copyArtifactsSdkTask = task(&quot;copyArtifactsSdk$t.capital&quot;, type: Copy, dependsOn: [sdk,jmods,apps,javadoc]) {
4285             from sdkDir
4286             into sdkArtifactsDir
4287         }
4288         publicExportsTask.dependsOn(copyArtifactsSdkTask)
4289 
4290         // Need to modify file permissions Windows to make sure that the
4291         // execute bit is set, and that the files are world readable
4292         def chmodArtifactsSdkTask = task(&quot;chmodArtifactsSdk$t.capital&quot;, dependsOn: copyArtifactsSdkTask) {
4293             if (IS_WINDOWS &amp;&amp; IS_USE_CYGWIN) {
4294                 doLast {
4295                     exec {
4296                         workingDir(sdkArtifactsDir)
4297                         commandLine(&quot;chmod&quot;, &quot;-R&quot;, &quot;755&quot;, &quot;.&quot;)
4298                     }
4299                 }
4300             }
4301         }
4302         publicExportsTask.dependsOn(chmodArtifactsSdkTask)
4303 
4304         def copyArtifactsDocsTask = task(&quot;copyArtifactsDocs$t.capital&quot;, type: Copy, dependsOn: chmodArtifactsSdkTask) {
4305             from docsDir
4306             into &quot;${docsArtifactsDir}/api&quot;
4307         }
4308         publicExportsTask.dependsOn(copyArtifactsDocsTask)
4309 
4310         def copyArtifactsJmodsTask = task(&quot;copyArtifactsJmods$t.capital&quot;, type: Copy, dependsOn: copyArtifactsDocsTask) {
4311             from jmodsDir
4312             into &quot;${jmodsArtifactsDir}&quot;
4313         }
4314         publicExportsTask.dependsOn(copyArtifactsJmodsTask)
4315 
4316         def zipsTask = task (&quot;zipsStandalone${t.capital}&quot;) {
4317             group = &quot;Basic&quot;
4318             description = &quot;Creates the public zip bundles&quot;
4319         }
4320         zips.dependsOn(zipsTask)
4321 
4322         // Use native zip tool so that file permissions are preserved on Windows
4323         def zipSdkTask = task(&quot;zipSdk$t.capital&quot;, dependsOn: publicExportsTask) {
4324             doLast {
4325                 def outZipFile = &quot;${bundlesDir}/${sdkBundleName}.zip&quot;
4326                 mkdir bundlesDir
4327                 exec {
4328                     workingDir(artifactsDir)
4329                     commandLine(&quot;zip&quot;, &quot;-q&quot;, &quot;-r&quot;, outZipFile, sdkBundleName)
4330                 }
4331             }
4332         }
4333         zipsTask.dependsOn(zipSdkTask)
4334 
4335         def zipDocsTask = task(&quot;zipDocs$t.capital&quot;, type: Zip, dependsOn: zipSdkTask) {
4336             destinationDir = file(&quot;${bundlesDir}&quot;)
4337             archiveName = &quot;${docsBundleName}.zip&quot;
4338             includeEmptyDirs = false
4339             from docsArtifactsDir
4340             into &quot;${docsBundleName}&quot;
4341         }
4342         zipsTask.dependsOn(zipDocsTask)
4343 
4344         def zipJmodsTask = task(&quot;zipJmods$t.capital&quot;, type: Zip, dependsOn: zipDocsTask) {
4345             destinationDir = file(&quot;${bundlesDir}&quot;)
4346             archiveName = &quot;${jmodsBundleName}.zip&quot;
4347             includeEmptyDirs = false
4348             from jmodsArtifactsDir
4349             into &quot;${jmodsBundleName}&quot;
4350         }
4351         zipsTask.dependsOn(zipJmodsTask)
4352     }
4353 }
4354 
4355 
4356 /******************************************************************************
4357  *                                                                            *
4358  *                             OpenJFX Stubs                                  *
4359  *                                                                            *
4360  *****************************************************************************/
4361 
4362 configurations {
4363     openjfxStubs
4364 }
4365 
4366 if (IS_STUB_RUNTIME_OPENJFX) {
4367     def String platform = IS_MAC ? &quot;mac&quot; : IS_WINDOWS ? &quot;win&quot; : IS_LINUX ? &quot;linux&quot; : &quot;&quot;
4368     dependencies {
4369         openjfxStubs &quot;org.openjfx:javafx-media:$STUB_RUNTIME_OPENJFX:$platform@jar&quot;
4370         openjfxStubs &quot;org.openjfx:javafx-web:$STUB_RUNTIME_OPENJFX:$platform@jar&quot;
4371     }
4372 }
4373 
4374 // Extract binary libraries from OpenJFX artifacts for use as stubs
4375 task prepOpenJfxStubs(type: Copy) {
4376     enabled = IS_STUB_RUNTIME_OPENJFX
4377 
4378     from configurations.openjfxStubs.files.collect { zipTree(it) }
4379     include(&quot;*.dll&quot;)
4380     include(&quot;*.dylib&quot;)
4381     include(&quot;*.so&quot;)
4382     into IS_WINDOWS ? file(&quot;$openjfxStubRuntime/bin&quot;) : file(&quot;$openjfxStubRuntime/lib&quot;)
4383 }
4384 
4385 
4386 /******************************************************************************
4387  *                                                                            *
4388  *                               Modules                                      *
4389  *                                                                            *
4390  *****************************************************************************/
4391 
4392 ext.moduleDependencies = [file(&quot;dependencies&quot;)]
4393 
4394 task buildModules {
4395 }
4396 
4397 // Combine the classes, lib, and bin for each module
4398 compileTargets { t -&gt;
4399     def targetProperties = project.ext[t.upper]
4400 
4401     def platformPrefix = targetProperties.platformPrefix
4402     def bundledSdkDirName = &quot;${platformPrefix}modular-sdk&quot;
4403     def bundledSdkDir = &quot;${rootProject.buildDir}/${bundledSdkDirName}&quot;
4404     def modulesDir = &quot;${bundledSdkDir}/modules&quot;
4405     def modulesCmdsDir = &quot;${bundledSdkDir}/modules_cmds&quot;
4406     def modulesLibsDir = &quot;${bundledSdkDir}/modules_libs&quot;
4407     def modulesSrcDir = &quot;${bundledSdkDir}/modules_src&quot;
4408     def modulesConfDir = &quot;${bundledSdkDir}/modules_conf&quot;
4409     def modulesLegalDir = &quot;${bundledSdkDir}/modules_legal&quot;
4410     def modulesMakeDir = &quot;${bundledSdkDir}/make&quot;
4411 
4412     final File runArgsFile = file(&quot;${rootProject.buildDir}/${RUNARGSFILE}&quot;)
4413     final File compileArgsFile = file(&quot;${rootProject.buildDir}/${COMPILEARGSFILE}&quot;)
4414 
4415     project.files(runArgsFile);
4416 
4417     def buildModulesTask = task(&quot;buildModules$t.capital&quot;, group: &quot;Build&quot;) {
4418         // BUNDLED SDK
4419 
4420         // Copy dependencies/*/module-info.java.extra
4421         // merging as needed, removing duplicates
4422         // only lines with &#39;exports&#39; will be copied
4423         def dependencyRoots = moduleDependencies
4424         if (rootProject.hasProperty(&quot;closedModuleDepedencies&quot;)) {
4425             dependencyRoots = [dependencyRoots, closedModuleDepedencies].flatten()
4426         }
4427 
4428         // Create the inputs/outputs list first to support UP-TO-DATE
4429         ArrayList outputNames = new ArrayList()
4430         dependencyRoots.each { root -&gt;
4431             FileTree ft = fileTree(root).include(&#39;**/*.extra&#39;)
4432             ft.each() { e-&gt;
4433                 inputs.file(e)
4434 
4435                 String usename = e.path
4436                 String filePath = e.getAbsolutePath()
4437                 String folderPath = root.getAbsolutePath()
4438                 if (filePath.startsWith(folderPath)) {
4439                     usename = filePath.substring(folderPath.length() + 1);
4440                 }
4441                 if (! outputNames.contains(usename) ) {
4442                     outputNames.add(usename)
4443                 }
4444             }
4445         }
4446 
4447         outputNames.each() { e-&gt;
4448                 File f = new File(modulesSrcDir, e)
4449                 outputs.file(f)
4450         }
4451 
4452         def outputPolicyDir = &quot;${modulesConfDir}/java.base/security&quot;
4453         def outputPolicyFile = file(&quot;${outputPolicyDir}/java.policy.extra&quot;)
4454 
4455         outputs.file(outputPolicyFile)
4456         moduleProjList.each { project -&gt;
4457             def policyDir = &quot;${project.projectDir}/src/main/conf/security&quot;
4458             def policyFile = file(&quot;${policyDir}/java.policy&quot;)
4459             if (policyFile.exists()) {
4460                 inputs.file(policyFile)
4461             }
4462         }
4463 
4464         doLast {
4465             Map extras = [:]
4466 
4467             dependencyRoots.each { root -&gt;
4468                 FileTree ft = fileTree(root).include(&#39;**/*.extra&#39;)
4469                 ft.each() { e-&gt;
4470                     String usename = e.path
4471                     String filePath = e.getAbsolutePath()
4472                     String folderPath = root.getAbsolutePath()
4473                     if (filePath.startsWith(folderPath)) {
4474                         usename = filePath.substring(folderPath.length() + 1);
4475                     }
4476                     if (extras.containsKey(usename)) {
4477                         List&lt;String&gt; lines = extras.get(usename)
4478                         e.eachLine { line -&gt;
4479                             line = line.trim()
4480                             if (line.length() &gt; 1 &amp;&amp; Character.isLetter(line.charAt(0))) {
4481                                 lines &lt;&lt; line
4482                             }
4483                         }
4484 
4485                     } else {
4486                         List&lt;String&gt; lines = []
4487                         e.eachLine { line -&gt;
4488                             line = line.trim()
4489                             if (line.length() &gt; 1 &amp;&amp; Character.isLetter(line.charAt(0))) {
4490                                 lines &lt;&lt; line
4491                             }
4492                         }
4493                         extras.put(usename,lines)
4494                     }
4495                 }
4496             }
4497             extras.keySet().each() { e-&gt;
4498                 File f = new File(modulesSrcDir, e)
4499                 f.getParentFile().mkdirs()
4500                 f.delete()
4501 
4502                 extras.get(e).unique().each() { l-&gt;
4503                     f &lt;&lt; l
4504                     f &lt;&lt; &quot;\n&quot;
4505                 }
4506             }
4507 
4508             // concatecate java.policy files into a single file
4509             //
4510             mkdir outputPolicyDir
4511             outputPolicyFile.delete()
4512             moduleProjList.each { project -&gt;
4513                 def policyDir = &quot;${project.projectDir}/src/main/conf/security&quot;
4514                 def policyFile = file(&quot;${policyDir}/java.policy&quot;)
4515                 if (policyFile.exists()) outputPolicyFile &lt;&lt; policyFile.text
4516             }
4517         }
4518     }
4519     buildModules.dependsOn(buildModulesTask)
4520 
4521     // BUNDLED SDK
4522     moduleProjList.each { project -&gt;
4523         // Copy classes, bin, and lib directories
4524 
4525         def moduleName = project.ext.moduleName
4526         def buildDir = project.buildDir
4527 
4528         def srcClassesDir = &quot;${buildDir}/${platformPrefix}module-classes&quot;
4529         def dstClassesDir = &quot;${modulesDir}/${moduleName}&quot;
4530         def copyClassFilesTask = project.task(&quot;copyClassFiles$t.capital&quot;, type: Copy, dependsOn: project.assemble) {
4531             from srcClassesDir
4532             into dstClassesDir
4533             exclude(&quot;module-info.class&quot;)
4534         }
4535 
4536         def srcCmdsDir = &quot;${buildDir}/${platformPrefix}module-bin&quot;
4537         def dstCmdsDir = &quot;${modulesCmdsDir}/${moduleName}&quot;
4538         def copyBinFilesTask = project.task(&quot;copyBinFiles$t.capital&quot;, type: Copy, dependsOn: copyClassFilesTask) {
4539             from srcCmdsDir
4540             into dstCmdsDir
4541         }
4542 
4543         def srcLibsDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
4544         def dstLibsDir = &quot;${modulesLibsDir}/${moduleName}&quot;
4545         def copyLibFilesTask = project.task(&quot;copyLibFiles$t.capital&quot;, type: Copy, dependsOn: copyBinFilesTask) {
4546             from srcLibsDir
4547             into dstLibsDir
4548         }
4549 
4550         // Copy module sources
4551         // FIXME: javafx.swt sources?
4552         def copySources = project.hasProperty(&quot;includeSources&quot;) &amp;&amp; project.includeSources
4553         def copySourceFilesTask = project.task(&quot;copySourceFiles$t.capital&quot;, type: Copy, dependsOn: copyLibFilesTask) {
4554             if (copySources) {
4555                 from &quot;${project.projectDir}/src/main/java&quot;
4556                 if (project.name.equals(&quot;base&quot;)) {
4557                     from &quot;${project.projectDir}/build/gensrc/java&quot;
4558                 }
4559                 if (project.name.equals(&quot;web&quot;)) {
4560                     from &quot;${project.projectDir}/src/main/native/Source/WebCore/bindings/java/dom3/java&quot;
4561                 }
4562             } else {
4563                 from &quot;${project.projectDir}/src/main/java/module-info.java&quot;
4564             }
4565             into &quot;${modulesSrcDir}/${moduleName}&quot;
4566             include &quot;**/*.java&quot;
4567 
4568             if (project.hasProperty(&quot;sourceFilter&quot;)) {
4569                 filter(project.sourceFilter)
4570             }
4571         }
4572 
4573         // Copy .html and other files needed for doc bundles
4574         def copyDocFiles = project.task(&quot;copyDocFiles$t.capital&quot;, type: Copy, dependsOn: copySourceFilesTask) {
4575             if (copySources) {
4576                 from(&quot;${project.projectDir}/src/main/docs&quot;) {
4577                     include &quot;**/*.html&quot;
4578                     filter { line-&gt;
4579                         line = line.replace(&quot;@FXVERSION@&quot;, RELEASE_VERSION)
4580                     }
4581                 }
4582                 from(&quot;${project.projectDir}/src/main/docs&quot;) {
4583                     exclude &quot;**/*.html&quot;
4584                 }
4585                 from(&quot;${project.projectDir}/src/main/java&quot;) {
4586                     exclude &quot;**/*.java&quot;
4587                 }
4588 
4589                 into &quot;${modulesSrcDir}/${moduleName}&quot;
4590             }
4591         }
4592 
4593         // Copy make/build.properties
4594         def srcMakeDir = &quot;${project.projectDir}/make&quot;
4595         def dstMakeDir = &quot;${modulesMakeDir}/${moduleName}&quot;
4596         def copyBuildPropertiesTask = project.task(&quot;copyBuildProperties$t.capital&quot;, type: Copy, dependsOn: copyDocFiles) {
4597             from srcMakeDir
4598             into dstMakeDir
4599         }
4600 
4601         // Copy legal files
4602         def srcLegalDir = &quot;${project.projectDir}/src/main/legal&quot;
4603         def dstLegalDir = &quot;${modulesLegalDir}/${moduleName}&quot;
4604         def copyLegalTask = project.task(&quot;copyLegal$t.capital&quot;, type: Copy, dependsOn: copyBuildPropertiesTask) {
4605             from srcLegalDir
4606             into dstLegalDir
4607 
4608             // Exclude ANGLE since we (currently) do not use it
4609             exclude(&quot;angle.md&quot;)
4610         }
4611 
4612         buildModulesTask.dependsOn(
4613             copyClassFilesTask,
4614             copyLibFilesTask,
4615             copySourceFilesTask,
4616             copyDocFiles,
4617             copyBuildPropertiesTask,
4618             copyLegalTask)
4619     }
4620 
4621     // ============================================================
4622 
4623     def standaloneSdkDirName = &quot;${platformPrefix}sdk&quot;
4624     def standaloneSdkDir = &quot;${rootProject.buildDir}/${standaloneSdkDirName}&quot;
4625     def standaloneLibDir = &quot;${standaloneSdkDir}/lib&quot;
4626     def libDest=targetProperties.libDest
4627     def standaloneNativeDir = &quot;${standaloneSdkDir}/${libDest}&quot;
4628     def standaloneLegalDir = &quot;${standaloneSdkDir}/legal&quot;
4629     def standaloneSrcZipName = &quot;src.zip&quot;
4630 
4631     // STANDALONE SDK
4632     moduleProjList.each { project -&gt;
4633         // Copy classes, bin, and lib directories
4634 
4635         def moduleName = project.ext.moduleName
4636         def buildDir = project.buildDir
4637 
4638         // Create modular jars
4639         def srcClassesDir = &quot;${buildDir}/${platformPrefix}module-classes&quot;
4640         def srcLibsDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
4641         def dstModularJarDir = &quot;${standaloneLibDir}&quot;
4642         def modularJarName = &quot;${moduleName}.jar&quot;
4643         def modularJarTask = project.task(&quot;modularJarStandalone$t.capital&quot;, type: Jar, dependsOn: project.assemble) {
4644             destinationDir = file(&quot;${dstModularJarDir}&quot;)
4645             archiveName = modularJarName
4646             includeEmptyDirs = false
4647             from srcClassesDir
4648         }
4649 
4650         // Copy native libraries
4651         def srcNativeDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
4652         def dstNativeDir = &quot;${standaloneNativeDir}&quot;
4653         def copyNativeFilesTask = project.task(&quot;copyNativeFilesStandalone$t.capital&quot;, type: Copy, dependsOn: modularJarTask) {
4654             from srcNativeDir
4655             into dstNativeDir
4656             include(&quot;*.dll&quot;)
4657         }
4658 
4659         // Copy other lib files
4660         def dstLibsDir = &quot;${standaloneLibDir}&quot;
4661         def copyLibFilesTask = project.task(&quot;copyLibFilesStandalone$t.capital&quot;, type: Copy, dependsOn: copyNativeFilesTask) {
4662             from srcLibsDir
4663             into dstLibsDir
4664             exclude(&quot;*.dll&quot;)
4665         }
4666 
4667         // Copy legal files
4668         def licenseFiles = [ &quot;ADDITIONAL_LICENSE_INFO&quot;, &quot;ASSEMBLY_EXCEPTION&quot;, &quot;LICENSE&quot; ]
4669         def srcLegalDir = &quot;${project.projectDir}/src/main/legal&quot;
4670         def dstLegalDir = &quot;${standaloneLegalDir}/${moduleName}&quot;
4671         def copyLegalTask = project.task(&quot;copyLegalStandalone$t.capital&quot;, type: Copy, dependsOn: copyLibFilesTask) {
4672 
4673             def rtDir = rootProject.file(&#39;.&#39;)
4674             licenseFiles.each { lFile -&gt;
4675                 from &quot;${rtDir}/${lFile}&quot;
4676             }
4677 
4678             from srcLegalDir
4679 
4680             into dstLegalDir
4681 
4682             // Exclude ANGLE since we (currently) do not use it
4683             exclude(&quot;angle.md&quot;)
4684         }
4685 
4686         buildModulesTask.dependsOn(
4687             modularJarTask,
4688             copyNativeFilesTask,
4689             copyLibFilesTask,
4690             copyLegalTask)
4691     }
4692 
4693     // Zip module sources for standalone SDK
4694     //
4695     // NOTE: the input is taken from the modular-sdk/modules_src dir
4696     // so that we don&#39;t have to duplicate the logic and create another
4697     // temporary directory. This is somewhat inelegant, since the bundled sdk
4698     // and the standalone sdk should be independent of one another, but seems
4699     // better than the alternatives.
4700     def zipSourceFilesTask = project.task(&quot;zipSourceFilesStandalone$t.capital&quot;, type: Zip, dependsOn: buildModulesTask) {
4701         destinationDir = file(&quot;${standaloneLibDir}&quot;)
4702         archiveName = standaloneSrcZipName
4703         includeEmptyDirs = false
4704         from modulesSrcDir
4705         include &quot;**/*.java&quot;
4706     }
4707     buildModules.dependsOn(zipSourceFilesTask)
4708 
4709     // ============================================================
4710 
4711     // Maven Publications
4712     def publicationDirName = &quot;${platformPrefix}publications&quot;
4713     def publicationDir = &quot;${rootProject.buildDir}/${publicationDirName}&quot;
4714 
4715     moduleProjList.each { project -&gt; 
4716         // Create publications to be uploaded 
4717 
4718         def moduleName = project.ext.moduleName
4719         def buildDir = project.buildDir
4720 
4721         def dstModularJarDir=&quot;${publicationDir}&quot;
4722         def srcClassesDir = &quot;${buildDir}/${platformPrefix}module-classes&quot;
4723         def srcLibsDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
4724 
4725         def modularEmptyPublicationJarName = &quot;${moduleName}.jar&quot;
4726         def modularEmptyPublicationJarTask = project.task(&quot;moduleEmptyPublicationJar${t.capital}&quot;, type: Jar) {
4727             destinationDir = file(&quot;${dstModularJarDir}&quot;)
4728             archiveName = modularEmptyPublicationJarName
4729             manifest {
4730                 attributes(
4731                     &#39;Automatic-Module-Name&#39;:&quot;${moduleName}Empty&quot;
4732                 )
4733             }
4734         }
4735 
4736         def modularPublicationJarName = &quot;${moduleName}-${t.name}.jar&quot;
4737         def modularPublicationJarTask = project.task(&quot;modularPublicationJar${t.capital}&quot;, type: Jar, dependsOn: modularEmptyPublicationJarTask) {
4738             destinationDir = file(&quot;${dstModularJarDir}&quot;)
4739             archiveName = modularPublicationJarName
4740             from srcLibsDir
4741             from srcClassesDir
4742         }
4743 
4744         buildModulesTask.dependsOn(modularPublicationJarTask)
4745 
4746     }
4747     // ============================================================
4748 
4749     def buildRunArgsTask = task(&quot;buildRunArgs$t.capital&quot;,
4750             group: &quot;Build&quot;, dependsOn: buildModulesTask) {
4751         outputs.file(runArgsFile);
4752         inputs.file(EXTRAADDEXPORTS);
4753         doLast() {
4754             List&lt;String&gt;modpath = []
4755             List&lt;String&gt;modnames = []
4756 
4757             moduleProjList.each { project -&gt;
4758                 def moduleName = project.ext.moduleName
4759                 def dstModuleDir = cygpath(&quot;${modulesDir}/${moduleName}&quot;)
4760                 if (HAS_JAVAFX_MODULES) {
4761                     modpath &lt;&lt;  &quot;${moduleName}=${dstModuleDir}&quot;
4762                 } else {
4763                     modnames &lt;&lt; moduleName
4764                 }
4765             }
4766 
4767             if (HAS_JAVAFX_MODULES) {
4768                 writeRunArgsFile(runArgsFile, computeLibraryPath(true), modpath, null)
4769                 writeRunArgsFile(compileArgsFile, null, modpath, null)
4770 
4771                 if (rootProject.hasProperty(&quot;EXTRA_ADDEXPORTS_STRING&quot;)) {
4772                     runArgsFile &lt;&lt; EXTRA_ADDEXPORTS_STRING
4773                     compileArgsFile &lt;&lt; EXTRA_ADDEXPORTS_STRING
4774                 }
4775             } else {
4776                 modpath = [ cygpath(&quot;${standaloneLibDir}&quot;) ]
4777                 writeRunArgsFile(runArgsFile, null, modpath, modnames)
4778                 writeRunArgsFile(compileArgsFile, null, modpath, modnames)
4779             }
4780         }
4781     }
4782     buildModules.dependsOn(buildRunArgsTask)
4783 
4784     def isWindows = IS_WINDOWS &amp;&amp; t.name == &quot;win&quot;;
4785     def isMac = IS_MAC &amp;&amp; t.name == &quot;mac&quot;;
4786 
4787     // Create layout for modular classes
4788     moduleProjList.each { project -&gt;
4789         def buildModuleClassesTask = project.task(&quot;buildModule$t.capital&quot;, group: &quot;Build&quot;, type: Copy) {
4790             dependsOn(project.assemble)
4791             def buildDir = project.buildDir
4792             def sourceBuildDirs = [
4793                 &quot;${buildDir}/classes/java/main/${project.moduleName}&quot;,
4794             ]
4795 
4796             def moduleClassesDir = &quot;$buildDir/${platformPrefix}module-classes&quot;
4797                 includeEmptyDirs = false
4798                 sourceBuildDirs.each { d -&gt;
4799                     from d
4800                 }
4801                 into moduleClassesDir
4802 
4803                 // Exclude obsolete, experimental, or non-shipping code
4804                 exclude(&quot;version.rc&quot;)
4805                 exclude(&quot;com/sun/glass/ui/swt&quot;)
4806                 exclude(&quot;com/sun/javafx/tools/ant&quot;)
4807                 exclude(&quot;com/javafx/main&quot;)
4808                 exclude(&quot;com/sun/javafx/webkit/drt&quot;)
4809                 if (!IS_INCLUDE_NULL3D) {
4810                     exclude (&quot;com/sun/prism/null3d&quot;)
4811                 }
4812                 if (!IS_INCLUDE_ES2) {
4813                        exclude(&quot;com/sun/prism/es2&quot;,
4814                                &quot;com/sun/scenario/effect/impl/es2&quot;)
4815                 }
4816 
4817                 // Exclude platform-specific classes for other platforms
4818 
4819                 if (!isMac) {
4820                     exclude (&quot;com/sun/media/jfxmediaimpl/platform/osx&quot;,
4821                              &quot;com/sun/prism/es2/MacGL*&quot;,
4822                              &quot;com/sun/glass/events/mac&quot;,
4823                              &quot;com/sun/glass/ui/mac&quot;,
4824                              )
4825                 }
4826 
4827                 if (!isWindows) {
4828                     exclude (&quot;**/*.hlsl&quot;,
4829                              &quot;com/sun/glass/ui/win&quot;,
4830                              &quot;com/sun/prism/d3d&quot;,
4831                              &quot;com/sun/prism/es2/WinGL*&quot;,
4832                              &quot;com/sun/scenario/effect/impl/hw/d3d&quot;
4833                              )
4834                 }
4835 
4836                 if (!targetProperties.includeGTK) { //usually IS_LINUX
4837                     exclude (
4838                              &quot;com/sun/glass/ui/gtk&quot;,
4839                              &quot;com/sun/prism/es2/EGL*&quot;,
4840                              &quot;com/sun/prism/es2/X11GL*&quot;
4841                              )
4842                 }
4843 
4844                 if (!targetProperties.includeEGL) {
4845                     exclude (&quot;com/sun/prism/es2/EGL*&quot;)
4846                 }
4847 
4848                 if (!targetProperties.includeMonocle) {
4849                     exclude (&quot;com/sun/glass/ui/monocle&quot;)
4850                     exclude(&quot;com/sun/prism/es2/Monocle*&quot;)
4851                 }
4852 
4853                 if (t.name != &#39;ios&#39;) {
4854                     exclude (&quot;com/sun/media/jfxmediaimpl/platform/ios&quot;,
4855                              &quot;com/sun/glass/ui/ios&quot;,
4856                              &quot;com/sun/prism/es2/IOS*&quot;
4857                              )
4858                 }
4859 
4860                 if (t.name != &#39;android&#39; &amp;&amp; t.name != &#39;dalvik&#39;) {
4861                     exclude (&quot;com/sun/glass/ui/android&quot;)
4862                 }
4863 
4864                 // Filter out other platform-specific classes
4865                 if (targetProperties.containsKey(&#39;jfxrtJarExcludes&#39;)) {
4866                     exclude(targetProperties.jfxrtJarExcludes)
4867                 }
4868 
4869                 /* FIXME: JIGSAW -- handle this in the module itself
4870                 String webbld = project(&quot;:web&quot;).buildDir.path
4871                 String ctrlbld = project(&quot;:controls&quot;).buildDir.path
4872                 if (t.name == &#39;android&#39;) {
4873                     from (&quot;${webbld}/classes/android&quot;,
4874                           &quot;${webbld}/resources/android&quot;,
4875                           &quot;${ctrlbld}/classes/android&quot;,
4876                           &quot;${ctrlbld}/resources/android&quot;)
4877                 } else if (t.name == &#39;ios&#39;) {
4878                     from (&quot;${webbld}/classes/ios&quot;,
4879                           &quot;${webbld}/resources/ios&quot;)
4880                 } else {
4881                     from (&quot;${webbld}/classes/java/main&quot;)
4882                 }
4883                 */
4884         }
4885         buildModulesTask.dependsOn(buildModuleClassesTask)
4886     }
4887 
4888     def buildModuleLibsTask = task(&quot;buildModuleLibs$t.capital&quot;) {
4889         group = &quot;Basic&quot;
4890 
4891         def baseProject = project(&quot;:base&quot;);
4892 
4893         def graphicsProject = project(&quot;:graphics&quot;);
4894 
4895         def mediaProject = project(&quot;:media&quot;);
4896 
4897         def webProject = project(&quot;:web&quot;);
4898         dependsOn(webProject.assemble)
4899 
4900         def swtProject = project(&quot;:swt&quot;);
4901 
4902         def library = targetProperties.library
4903 
4904         def useLipo = targetProperties.containsKey(&#39;useLipo&#39;) ? targetProperties.useLipo : false
4905         def modLibDest = targetProperties.modLibDest
4906         def moduleNativeDirName = &quot;${platformPrefix}module-$modLibDest&quot;
4907 
4908         def buildModuleBaseTask = task(&quot;buildModuleBase$t.capital&quot;, dependsOn: baseProject.assemble) {
4909             group = &quot;Basic&quot;
4910             description = &quot;creates javafx.base property files&quot;
4911 
4912             def moduleLibDir = &quot;${baseProject.buildDir}/${platformPrefix}module-lib&quot;
4913             final File javafxProperties = file(&quot;${moduleLibDir}/javafx.properties&quot;)
4914             outputs.file(javafxProperties)
4915 
4916             if (targetProperties.containsKey(&quot;javafxPlatformProperties&quot;)) {
4917                 final File javafxPlatformProperties = file(&quot;${moduleLibDir}/javafx.platform.properties&quot;)
4918                 outputs.file(javafxPlatformProperties)
4919             }
4920 
4921             doLast {
4922                 mkdir moduleLibDir
4923 
4924                 javafxProperties.delete()
4925                 javafxProperties &lt;&lt; &quot;javafx.version=$RELEASE_VERSION_SHORT&quot;;
4926                 javafxProperties &lt;&lt; &quot;\n&quot;
4927                 javafxProperties &lt;&lt; &quot;javafx.runtime.version=$RELEASE_VERSION_LONG&quot;;
4928                 javafxProperties &lt;&lt; &quot;\n&quot;
4929                 javafxProperties &lt;&lt; &quot;javafx.runtime.build=$PROMOTED_BUILD_NUMBER&quot;;
4930                 javafxProperties &lt;&lt; &quot;\n&quot;
4931                 // Include any properties that have been defined (most likely in
4932                 // one of the various platform gradle files)
4933                 if (targetProperties.containsKey(&quot;javafxProperties&quot;)) {
4934                     javafxProperties &lt;&lt; targetProperties.javafxProperties
4935                     javafxProperties &lt;&lt; &quot;\n&quot;
4936                 }
4937 
4938                 // Embedded builds define this file as well
4939                 if (targetProperties.containsKey(&quot;javafxPlatformProperties&quot;)) {
4940                     final File javafxPlatformProperties = file(&quot;${moduleLibDir}/javafx.platform.properties&quot;)
4941                     javafxPlatformProperties.delete()
4942                     javafxPlatformProperties &lt;&lt; targetProperties.javafxPlatformProperties
4943                     javafxPlatformProperties &lt;&lt; &quot;\n&quot;
4944                 }
4945             }
4946         }
4947 
4948         def buildModuleGraphicsTask = task(&quot;buildModuleGraphics$t.capital&quot;, type: Copy, dependsOn: graphicsProject.assemble) {
4949             group = &quot;Basic&quot;
4950             description = &quot;copies javafx.graphics native libraries&quot;
4951 
4952             into &quot;${graphicsProject.buildDir}/${moduleNativeDirName}&quot;
4953 
4954             from(&quot;${graphicsProject.buildDir}/libs/jsl-decora/${t.name}/${library(targetProperties.decora.lib)}&quot;)
4955             def libs = [&#39;font&#39;, &#39;prism&#39;, &#39;prismSW&#39;, &#39;glass&#39;, &#39;iio&#39;]
4956             if (IS_INCLUDE_ES2) {
4957                 libs += [&#39;prismES2&#39;];
4958             }
4959             if (IS_COMPILE_PANGO) {
4960                 libs += [&#39;fontFreetype&#39;, &#39;fontPango&#39;];
4961             }
4962             libs.each { lib -&gt;
4963                 def variants = targetProperties[lib].containsKey(&#39;variants&#39;) &amp;&amp; !useLipo ? targetProperties[lib].variants : [null]
4964                 variants.each { variant -&gt;
4965                     def variantProperties = variant ? targetProperties[lib][variant] : targetProperties[lib]
4966                     from (&quot;${graphicsProject.buildDir}/libs/$lib/$t.name/${library(variantProperties.lib)}&quot;)
4967                 }
4968             }
4969             if (IS_WINDOWS) {
4970                 from (&quot;${graphicsProject.buildDir}/libs/prismD3D/${t.name}/${library(targetProperties.prismD3D.lib)}&quot;);
4971                 targetProperties.VS2017DLLs.each { vslib -&gt;
4972                     from (&quot;$vslib&quot;);
4973                 }
4974                 targetProperties.WinSDKDLLs.each { winsdklib -&gt;
4975                     from (&quot;$winsdklib&quot;);
4976                 }
4977             }
4978         }
4979 
4980         def buildModuleMediaTask = task(&quot;buildModuleMedia$t.capital&quot;, type: Copy, dependsOn: [mediaProject.assemble, prepOpenJfxStubs]) {
4981             group = &quot;Basic&quot;
4982             description = &quot;copies javafx.media native libraries&quot;
4983 
4984             into &quot;${mediaProject.buildDir}/${moduleNativeDirName}&quot;
4985 
4986             def mediaBuildType = project(&quot;:media&quot;).ext.buildType
4987             if (IS_COMPILE_MEDIA) {
4988                 [ &quot;fxplugins&quot;, &quot;gstreamer-lite&quot;, &quot;jfxmedia&quot; ].each { name -&gt;
4989                     from (&quot;${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}/${library(name)}&quot;) }
4990 
4991                 if (t.name == &quot;mac&quot;) {
4992                     // OSX media natives
4993                     [ &quot;jfxmedia_qtkit&quot;, &quot;jfxmedia_avf&quot;, &quot;glib-lite&quot; ].each { name -&gt;
4994                         from (&quot;${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}/${library(name)}&quot;) }
4995                 } else if (t.name == &quot;linux&quot;) {
4996                     from(&quot;${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}&quot;) { include &quot;libavplugin*.so&quot; }
4997                 } else from (&quot;${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}/${library(&quot;glib-lite&quot;)}&quot;)
4998             } else {
4999                 if (t.name != &quot;android&quot;  &amp;&amp; t.name != &quot;dalvik&quot; ) {
5000                     [ &quot;fxplugins&quot;, &quot;gstreamer-lite&quot;, &quot;jfxmedia&quot; ].each { name -&gt;
5001                         from (&quot;$MEDIA_STUB/${library(name)}&quot;) }
5002                 }
5003 
5004                 if (t.name == &quot;mac&quot;) {
5005                     // copy libjfxmedia_{avf,qtkit}.dylib if they exist
5006                     [ &quot;jfxmedia_qtkit&quot;, &quot;jfxmedia_avf&quot;, &quot;glib-lite&quot; ].each { name -&gt;
5007                         from (&quot;$MEDIA_STUB/${library(name)}&quot;) }
5008                 } else if (t.name == &quot;linux&quot;) {
5009                     from(MEDIA_STUB) { include &quot;libavplugin*.so&quot; }
5010                 }
5011                 else if (t.name != &quot;android&quot;  &amp;&amp; t.name != &quot;dalvik&quot; ) {
5012                     from (&quot;$MEDIA_STUB/${library(&quot;glib-lite&quot;)}&quot;)
5013                 }
5014             }
5015         }
5016 
5017         def buildModuleWeb = task(&quot;buildModuleWeb$t.capital&quot;, type: Copy, dependsOn: [webProject.assemble, prepOpenJfxStubs]) {
5018             group = &quot;Basic&quot;
5019             description = &quot;copies javafx.web native libraries&quot;
5020 
5021             into &quot;${webProject.buildDir}/${moduleNativeDirName}&quot;
5022 
5023             if (IS_COMPILE_WEBKIT) {
5024                 from (&quot;${webProject.buildDir}/libs/${t.name}/${library(&#39;jfxwebkit&#39;)}&quot;)
5025             } else {
5026                 if (t.name != &quot;android&quot; &amp;&amp; t.name != &quot;ios&quot; &amp;&amp; t.name != &quot;dalvik&quot;) {
5027                     from (&quot;$WEB_STUB/${library(&#39;jfxwebkit&#39;)}&quot;)
5028                 }
5029             }
5030         }
5031 
5032         def buildModuleSWT = task(&quot;buildModuleSWT$t.capital&quot;, type: Copy) {
5033             group = &quot;Basic&quot;
5034             description = &quot;copies SWT JAR&quot;
5035 
5036             // FIXME: the following is a hack to workaround the fact that there
5037             // is no way to deliver javafx-swt.jar other than in one of the
5038             // existing runtime modules.
5039 
5040             dependsOn(buildModuleGraphicsTask) // we copy to the graphics module
5041 
5042             if (COMPILE_SWT) {
5043                 def javafxSwtIndexTask = tasks.getByName(&quot;javafxSwtIndex${t.capital}&quot;);
5044                 dependsOn(javafxSwtIndexTask)
5045                 //enabled = COMPILE_SWT
5046             }
5047 
5048             // Copy javafx-swt.jar to the javafx-graphics module lib dir
5049             from &quot;${swtProject.buildDir}/libs/javafx-swt.jar&quot;
5050             into &quot;${graphicsProject.buildDir}/${platformPrefix}module-lib&quot;
5051         }
5052 
5053         dependsOn(
5054             buildModuleBaseTask,
5055             buildModuleGraphicsTask,
5056             buildModuleMediaTask,
5057             buildModuleWeb,
5058             buildModuleSWT,
5059             )
5060     }
5061     buildModulesTask.dependsOn(buildModuleLibsTask)
5062 
5063     def zipTask = project.task(&quot;buildModuleZip$t.capital&quot;, type: Zip, group: &quot;Build&quot;,
5064             dependsOn: buildModulesTask ) {
5065 
5066         // FIXME: JIGSAW -- this should be moved to a sub-directory so we can keep the same name
5067         def jfxBundle = &quot;${platformPrefix}javafx-exports.zip&quot;
5068 
5069         doFirst() {
5070             file(&quot;${rootProject.buildDir}/${jfxBundle}&quot;).delete()
5071         }
5072 
5073         archiveName = jfxBundle
5074         destinationDir = file(&quot;${rootProject.buildDir}&quot;)
5075         includeEmptyDirs = false
5076         from &quot;${bundledSdkDir}&quot;
5077     }
5078     jdkZip.dependsOn(zipTask)
5079 
5080     Task testArgFiles = task(&quot;createTestArgfiles${t.capital}&quot;) {
5081 
5082         File testRunArgsFile = new File(rootProject.buildDir, TESTRUNARGSFILE)
5083         //test (shimed) version
5084         File testCompileArgsFile = new File(rootProject.buildDir, TESTCOMPILEARGSFILE)
5085         // And a test java.policy file
5086         File testJavaPolicyFile = new File(rootProject.buildDir, TESTJAVAPOLICYFILE)
5087         // and the non-test version to go with run.args
5088         File runJavaPolicyFile = new File(rootProject.buildDir, RUNJAVAPOLICYFILE);
5089 
5090         outputs.file(testRunArgsFile)
5091         outputs.file(testCompileArgsFile)
5092         outputs.file(testJavaPolicyFile)
5093         outputs.file(runJavaPolicyFile)
5094         inputs.file(EXTRAADDEXPORTS);
5095 
5096         doLast() {
5097             rootProject.buildDir.mkdir()
5098 
5099             List&lt;String&gt; projNames = []
5100             moduleProjList.each { project -&gt;
5101                 projNames &lt;&lt; project.name
5102             }
5103 
5104             // And the test (shimed) variation...
5105 
5106             testRunArgsFile.delete()
5107             testCompileArgsFile.delete()
5108 
5109             testJavaPolicyFile.delete()
5110             runJavaPolicyFile.delete()
5111 
5112             List&lt;String&gt; modpath = []
5113 
5114             if (HAS_JAVAFX_MODULES) {
5115                 moduleProjList.each { project -&gt;
5116                     if (project.hasProperty(&quot;moduleName&quot;) &amp;&amp; project.buildModule) {
5117                         File dir;
5118                         if (project.sourceSets.hasProperty(&#39;shims&#39;)) {
5119                            dir = new File(rootProject.buildDir, &quot;shims/${project.ext.moduleName}&quot;)
5120                         } else {
5121                            dir = new File(rootProject.buildDir, &quot;modular-sdk/modules/${project.ext.moduleName}&quot;)
5122                         }
5123 
5124                         def dstModuleDir = cygpath(dir.path)
5125                         modpath &lt;&lt; &quot;${project.ext.moduleName}=${dstModuleDir}&quot;
5126 
5127                         String themod = dir.toURI()
5128                         testJavaPolicyFile &lt;&lt;  &quot;grant codeBase \&quot;${themod}\&quot; {\n&quot; +
5129                         &quot;    permission java.security.AllPermission;\n&quot; +
5130                         &quot;};\n&quot;
5131 
5132                         dir = new File(rootProject.buildDir, &quot;modular-sdk/modules/${project.ext.moduleName}&quot;)
5133                         themod = dir.toURI()
5134                         runJavaPolicyFile &lt;&lt;  &quot;grant codeBase \&quot;${themod}\&quot; {\n&quot; +
5135                         &quot;    permission java.security.AllPermission;\n&quot; +
5136                         &quot;};\n&quot;
5137                     }
5138                 }
5139 
5140                 writeRunArgsFile(testCompileArgsFile, null, modpath, null)
5141                 writeRunArgsFile(testRunArgsFile, computeLibraryPath(true), modpath, null)
5142 
5143                 if (rootProject.hasProperty(&quot;EXTRA_ADDEXPORTS_STRING&quot;)) {
5144                     testCompileArgsFile &lt;&lt; EXTRA_ADDEXPORTS_STRING
5145                     testRunArgsFile &lt;&lt; EXTRA_ADDEXPORTS_STRING
5146                 }
5147             } else  {
5148                 def modnames = []
5149                 moduleProjList.each { project -&gt;
5150                     if (project.hasProperty(&quot;moduleName&quot;) &amp;&amp; project.buildModule) {
5151                         modnames &lt;&lt; project.ext.moduleName
5152                         File dir;
5153                         if (project.sourceSets.hasProperty(&#39;shims&#39;)) {
5154                            dir = new File(rootProject.buildDir, &quot;shims/${project.ext.moduleName}&quot;)
5155                         } else {
5156                            dir = new File(rootProject.buildDir, &quot;sdk/lib/${project.ext.moduleName}.jar&quot;)
5157                         }
5158 
5159                         def dstModuleDir = cygpath(dir.path)
5160                         modpath &lt;&lt; &quot;${dstModuleDir}&quot;
5161 
5162                         String themod = dir.toURI()
5163                         testJavaPolicyFile &lt;&lt;  &quot;grant codeBase \&quot;${themod}\&quot; {\n&quot; +
5164                         &quot;    permission java.security.AllPermission;\n&quot; +
5165                         &quot;};\n&quot;
5166 
5167                         dir = new File(rootProject.buildDir, &quot;sdk/lib/${project.ext.moduleName}.jar&quot;)
5168                         themod = dir.toURI()
5169                         runJavaPolicyFile &lt;&lt;  &quot;grant codeBase \&quot;${themod}\&quot; {\n&quot; +
5170                         &quot;    permission java.security.AllPermission;\n&quot; +
5171                         &quot;};\n&quot;
5172                     }
5173                 }
5174 
5175                 writeRunArgsFile(testCompileArgsFile, null, modpath, modnames)
5176                 writeRunArgsFile(testRunArgsFile, computeLibraryPath(true), modpath, modnames)
5177 
5178             }
5179         }
5180     }
5181     sdk.dependsOn(testArgFiles)
5182     createTestArgfiles.dependsOn(testArgFiles)
5183 
5184     def sdkTask = tasks.getByName(&quot;sdk${t.capital}&quot;);
5185     sdkTask.dependsOn(buildModulesTask)
5186 }
5187 sdk.dependsOn(buildModules)
5188 
5189 // Build the jmod for each module for the standalone SDK only.
5190 compileTargets { t -&gt;
5191     if (!HAS_JAVAFX_MODULES) {
5192         def targetProperties = project.ext[t.upper]
5193 
5194         def platformPrefix = targetProperties.platformPrefix
5195         def jmodsDirName = &quot;${platformPrefix}jmods&quot;
5196         def jmodsDir = &quot;${rootProject.buildDir}/${jmodsDirName}&quot;
5197         def standaloneSdkDirName = &quot;${platformPrefix}sdk&quot;
5198         def standaloneSdkDir = &quot;${rootProject.buildDir}/${standaloneSdkDirName}&quot;
5199         def standaloneLegalDir = &quot;${standaloneSdkDir}/legal&quot;
5200 
5201         def excludeNativeLibs = []
5202         if (IS_WINDOWS) {
5203             // List of duplicate Microsoft DLLs to exclude
5204             excludeNativeLibs += targetProperties.VS2017DLLNames
5205             excludeNativeLibs += targetProperties.WinSDKDLLNames
5206         }
5207 
5208         moduleProjList.each { project -&gt;
5209             def moduleName = project.ext.moduleName
5210             def buildDir = project.buildDir
5211 
5212             def srcClassesDir = &quot;${buildDir}/${platformPrefix}module-classes&quot;
5213             def srcLibDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
5214             def srcLegalDir = &quot;${standaloneLegalDir}/${moduleName}&quot;
5215 
5216             def jmodName = &quot;${moduleName}.jmod&quot;
5217             def jmodFile = &quot;${jmodsDir}/${jmodName}&quot;
5218             def jmodTask = project.task(&quot;jmod$t.capital&quot;, group: &quot;Build&quot;, dependsOn: sdk) {
5219                 doLast {
5220                     mkdir jmodsDir
5221                     delete(jmodFile);
5222                     exec {
5223                         commandLine(JMOD)
5224                         args(&quot;create&quot;)
5225                         args(&quot;--class-path&quot;)
5226                         args(srcClassesDir)
5227                         // Not all modules have a &quot;lib&quot; dir
5228                         if (file(srcLibDir).isDirectory()) {
5229                             args(&quot;--libs&quot;)
5230                             args(srcLibDir)
5231                         }
5232                         // Exclude duplicate native libs from javafx.graphics.jmod
5233                         if (moduleName == &quot;javafx.graphics&quot;) {
5234                             excludeNativeLibs.each { name -&gt;
5235                                 args(&quot;--exclude&quot;)
5236                                 args(name)
5237                             }
5238                         }
5239                         args(&quot;--legal-notices&quot;)
5240                         args(srcLegalDir)
5241                         args(jmodFile)
5242                     }
5243                 }
5244             }
5245 
5246             jmods.dependsOn(jmodTask)
5247         }
5248     }
5249 }
5250 
5251 /******************************************************************************
5252  *                                                                            *
5253  *                              BUILD_CLOSED                                  *
5254  *                                                                            *
5255  * This next section should remain at the end of the build script. It allows  *
5256  * for a &quot;supplemental&quot; gradle file to be used to extend the normal build     *
5257  * structure. For example, this is used for passing a supplemental gradle     *
5258  * file for producing official JavaFX builds.                                 *
5259  *                                                                            *
5260  *****************************************************************************/
5261 
5262 if (BUILD_CLOSED) {
5263     apply from: supplementalBuildFile
5264 }
5265 
5266 task showFlags {
5267 }
5268 
5269 compileTargets { t -&gt;
5270     // Every platform must define these variables
5271     def props = project.ext[t.upper];
5272     showFlags.dependsOn(
5273         project.task(&quot;showFlags$t.upper&quot;) {
5274             doLast() {
5275                 println &quot;Properties set for $t.upper&quot;
5276                 props.each { println it }
5277             }
5278         }
5279     )
5280 
5281 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/Labeled.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control;
  27 
<a name="1" id="anc1"></a><span class="line-removed">  28 </span>
  29 import com.sun.javafx.css.StyleManager;
  30 import com.sun.javafx.scene.NodeHelper;
  31 import javafx.css.converter.BooleanConverter;
  32 import javafx.css.converter.EnumConverter;
  33 import javafx.css.converter.InsetsConverter;
  34 import javafx.css.converter.PaintConverter;
  35 import javafx.css.converter.SizeConverter;
  36 import javafx.css.converter.StringConverter;
  37 
  38 import java.util.ArrayList;
  39 import java.util.Collections;
  40 import java.util.List;
  41 
  42 import javafx.beans.property.BooleanProperty;
  43 import javafx.beans.property.DoubleProperty;
  44 import javafx.beans.property.ObjectProperty;
  45 import javafx.beans.property.ReadOnlyObjectProperty;
  46 import javafx.beans.property.SimpleBooleanProperty;
  47 import javafx.beans.property.SimpleStringProperty;
  48 import javafx.beans.property.StringProperty;
  49 import javafx.beans.value.WritableValue;
  50 import javafx.geometry.Insets;
  51 import javafx.geometry.Orientation;
  52 import javafx.geometry.Pos;
  53 import javafx.scene.Node;
  54 import javafx.scene.image.Image;
  55 import javafx.scene.image.ImageView;
  56 import javafx.scene.paint.Color;
  57 import javafx.scene.paint.Paint;
  58 import javafx.scene.text.Font;
  59 import javafx.scene.text.TextAlignment;
  60 import javafx.beans.DefaultProperty;
  61 import javafx.css.CssMetaData;
  62 import javafx.css.FontCssMetaData;
  63 import javafx.css.StyleOrigin;
  64 import javafx.css.Styleable;
  65 import javafx.css.StyleableBooleanProperty;
  66 import javafx.css.StyleableDoubleProperty;
  67 import javafx.css.StyleableObjectProperty;
  68 import javafx.css.StyleableProperty;
  69 import javafx.css.StyleableStringProperty;
  70 
<a name="2" id="anc2"></a><span class="line-removed">  71 </span>
  72 /**
  73  * A Labeled {@link Control} is one which has as part of its user interface
  74  * a textual content associated with it. For example, a {@link Button} displays
  75  * {@code text}, as does a {@link Label}, a {@link Tooltip}, and many
  76  * other controls.
  77  * &lt;p&gt;
  78  * Labeled is also a convenient base class from which to extend when building
  79  * new Controls which, as part of their UI, display read-only textual content.
  80  * &lt;/p&gt;
  81  *
  82  * &lt;p&gt;Example of how to place a graphic above the text:
  83  * &lt;pre&gt;&lt;code&gt;
  84  *  Image image = new Image(getClass().getResourceAsStream(&quot;image.png&quot;));
  85  *  ImageView imageView = new ImageView();
  86  *  imageView.setImage(image);
  87  *  Label label = new Label(&quot;text&quot;, imageView);
  88  *  label.setContentDisplay(ContentDisplay.TOP);
  89  * &lt;/code&gt;&lt;/pre&gt;
  90  *
  91  * @see Button
  92  * @see Label
  93  * @see ToggleButton
  94  * @since JavaFX 2.0
  95  */
  96 @DefaultProperty(&quot;text&quot;)
  97 public abstract class Labeled extends Control {
  98 
  99     private final static String DEFAULT_ELLIPSIS_STRING = &quot;...&quot;;
 100 
 101 
 102     /***************************************************************************
 103      *                                                                         *
 104      * Constructors                                                            *
 105      *                                                                         *
 106      **************************************************************************/
 107 
 108     /**
 109      * Creates a Label with no text and graphic
 110      */
 111     public Labeled() { }
 112 
 113     /**
 114      * Creates a Label with text
 115      * @param text The text for the label.
 116      */
 117     public Labeled(String text) {
 118         setText(text);
 119     }
 120 
 121     /**
 122      * Creates a Label with text and a graphic
 123      * @param text The text for the label.
 124      * @param graphic The graphic for the label.
 125      */
 126     public Labeled(String text, Node graphic) {
 127         setText(text);
 128         ((StyleableProperty&lt;Node&gt;)(WritableValue&lt;Node&gt;)graphicProperty()).applyStyle(null, graphic);
 129     }
 130 
 131     /***************************************************************************
 132      *                                                                         *
 133      * Properties                                                              *
 134      *                                                                         *
 135      **************************************************************************/
 136     /**
 137      * The text to display in the label. The text may be null.
 138      *
 139      * @return the text to display in the label
<a name="3" id="anc3"></a><span class="line-modified"> 140      * @default {@code &quot;&quot;} (empty string}</span>
 141      */
 142     public final StringProperty textProperty() {
 143         if (text == null) {
 144             text = new SimpleStringProperty(this, &quot;text&quot;, &quot;&quot;);
 145         }
 146         return text;
 147     }
 148     private StringProperty text;
 149     public final void setText(String value) { textProperty().setValue(value); }
 150     public final String getText() { return text == null ? &quot;&quot; : text.getValue(); }
 151 
 152     /**
 153      * Specifies how the text and graphic within the Labeled should be
 154      * aligned when there is empty space within the Labeled.
<a name="4" id="anc4"></a>
 155      * @return the alignment within this labeled
<a name="5" id="anc5"></a>
 156      */
 157     public final ObjectProperty&lt;Pos&gt; alignmentProperty() {
 158         if (alignment == null) {
 159             alignment = new StyleableObjectProperty&lt;Pos&gt;(Pos.CENTER_LEFT) {
 160 
 161                 @Override public CssMetaData&lt;Labeled,Pos&gt; getCssMetaData() {
 162                     return StyleableProperties.ALIGNMENT;
 163                 }
 164 
 165                 @Override
 166                 public Object getBean() {
 167                     return Labeled.this;
 168                 }
 169 
 170                 @Override
 171                 public String getName() {
 172                     return &quot;alignment&quot;;
 173                 }
 174             };
 175         }
 176         return alignment;
 177     }
 178     private ObjectProperty&lt;Pos&gt; alignment;
 179     public final void setAlignment(Pos value) { alignmentProperty().set(value); }
 180     public final Pos getAlignment() { return alignment == null ? Pos.CENTER_LEFT : alignment.get(); }
 181 
 182 
 183     /**
 184      * Specifies the behavior for lines of text &lt;em&gt;when text is multiline&lt;/em&gt;.
 185      * Unlike {@link #contentDisplayProperty} which affects the graphic and text, this setting
 186      * only affects multiple lines of text relative to the text bounds.
 187      *
 188      * @return the alignment of lines of text within this labeled
<a name="6" id="anc6"></a><span class="line-modified"> 189      * @default {@code TextAlignment.LEFT}</span>
 190      */
 191     public final ObjectProperty&lt;TextAlignment&gt; textAlignmentProperty() {
 192         if (textAlignment == null) {
 193             textAlignment = new StyleableObjectProperty&lt;TextAlignment&gt;(TextAlignment.LEFT) {
 194 
 195                 @Override
 196                 public CssMetaData&lt;Labeled,TextAlignment&gt; getCssMetaData() {
 197                     return StyleableProperties.TEXT_ALIGNMENT;
 198                 }
 199 
 200                 @Override
 201                 public Object getBean() {
 202                     return Labeled.this;
 203                 }
 204 
 205                 @Override
 206                 public String getName() {
 207                     return &quot;textAlignment&quot;;
 208                 }
 209             };
 210         }
 211         return textAlignment;
 212     }
 213     private ObjectProperty&lt;TextAlignment&gt; textAlignment;
 214     public final void setTextAlignment(TextAlignment value) { textAlignmentProperty().setValue(value); }
 215     public final TextAlignment getTextAlignment() { return textAlignment == null ? TextAlignment.LEFT : textAlignment.getValue(); }
 216 
 217     /**
 218      * Specifies the behavior to use if the text of the {@code Labeled}
 219      * exceeds the available space for rendering the text.
 220      *
 221      * @return the overrun behavior if the text exceeds the available space
<a name="7" id="anc7"></a><span class="line-modified"> 222      * @default {@code OverrunStyle.ELLIPSIS}</span>
 223      */
 224     public final ObjectProperty&lt;OverrunStyle&gt; textOverrunProperty() {
 225         if (textOverrun == null) {
 226             textOverrun = new StyleableObjectProperty&lt;OverrunStyle&gt;(OverrunStyle.ELLIPSIS) {
 227 
 228                 @Override
 229                 public CssMetaData&lt;Labeled,OverrunStyle&gt; getCssMetaData() {
 230                     return StyleableProperties.TEXT_OVERRUN;
 231                 }
 232 
 233                 @Override
 234                 public Object getBean() {
 235                     return Labeled.this;
 236                 }
 237 
 238                 @Override
 239                 public String getName() {
 240                     return &quot;textOverrun&quot;;
 241                 }
 242             };
 243         }
 244         return textOverrun;
 245     }
 246     private ObjectProperty&lt;OverrunStyle&gt; textOverrun;
 247     public final void setTextOverrun(OverrunStyle value) { textOverrunProperty().setValue(value); }
 248     public final OverrunStyle getTextOverrun() { return textOverrun == null ? OverrunStyle.ELLIPSIS : textOverrun.getValue(); }
 249 
 250     /**
 251      * Specifies the string to display for the ellipsis when text is truncated.
 252      *
 253      * &lt;table&gt;
 254      *   &lt;caption&gt;Ellipsis Table&lt;/caption&gt;
 255      *   &lt;tr&gt;&lt;th scope=&quot;col&quot; colspan=2&gt;Examples&lt;/th&gt;&lt;/tr&gt;
 256      *   &lt;tr class=&quot;altColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot;...&quot; &lt;/th&gt;        &lt;td&gt;Default value for most locales&lt;/td&gt;
 257      *   &lt;tr class=&quot;rowColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot; . . . &quot; &lt;/th&gt;    &lt;td&gt;&lt;/td&gt;
 258      *   &lt;tr class=&quot;altColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot; [...] &quot; &lt;/th&gt;    &lt;td&gt;&lt;/td&gt;
 259      *   &lt;tr class=&quot;rowColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot;&amp;#92;u2026&quot; &lt;/th&gt; &lt;td&gt;The Unicode ellipsis character &#39;&amp;hellip;&#39;&lt;/td&gt;
 260      *   &lt;tr class=&quot;altColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot;&quot; &lt;/th&gt;           &lt;td&gt;No ellipsis, just display the truncated string&lt;/td&gt;
 261      * &lt;/table&gt;
 262      *
 263      * &lt;p&gt;Note that not all fonts support all Unicode characters.
 264      *
 265      * @return the ellipsis property on the string to display for the ellipsis
 266      * when text is truncated
 267      * @see &lt;a href=&quot;http://en.wikipedia.org/wiki/Ellipsis#Computer_representations&quot;&gt;Wikipedia:ellipsis&lt;/a&gt;
 268      * @since JavaFX 2.2
<a name="8" id="anc8"></a><span class="line-modified"> 269      * @default {@code &quot;...&quot;}</span>
 270      */
 271     public final StringProperty ellipsisStringProperty() {
 272         if (ellipsisString == null) {
 273             ellipsisString = new StyleableStringProperty(DEFAULT_ELLIPSIS_STRING) {
 274                 @Override public Object getBean() {
 275                     return Labeled.this;
 276                 }
 277 
 278                 @Override public String getName() {
 279                     return &quot;ellipsisString&quot;;
 280                 }
 281 
 282                 @Override public CssMetaData&lt;Labeled,String&gt; getCssMetaData() {
 283                     return StyleableProperties.ELLIPSIS_STRING;
 284                 }
 285             };
 286         }
 287         return ellipsisString;
 288     }
 289     private StringProperty ellipsisString;
 290     public final void setEllipsisString(String value) { ellipsisStringProperty().set((value == null) ? &quot;&quot; : value); }
 291     public final String getEllipsisString() { return ellipsisString == null ? DEFAULT_ELLIPSIS_STRING : ellipsisString.get(); }
 292 
 293 
 294     /**
 295      * If a run of text exceeds the width of the Labeled, then this variable
 296      * indicates whether the text should wrap onto another line.
 297      *
 298      * @return the wrap property if a run of text exceeds the width of the Labeled
<a name="9" id="anc9"></a><span class="line-modified"> 299      * @default {@code false}</span>
 300      */
 301     public final BooleanProperty wrapTextProperty() {
 302         if (wrapText == null) {
 303             wrapText = new StyleableBooleanProperty() {
 304 
 305                 @Override
 306                 public CssMetaData&lt;Labeled,Boolean&gt; getCssMetaData() {
 307                     return StyleableProperties.WRAP_TEXT;
 308                 }
 309 
 310                 @Override
 311                 public Object getBean() {
 312                     return Labeled.this;
 313                 }
 314 
 315                 @Override
 316                 public String getName() {
 317                     return &quot;wrapText&quot;;
 318                 }
 319             };
 320         }
 321         return wrapText;
 322     }
 323     private BooleanProperty wrapText;
 324     public final void setWrapText(boolean value) { wrapTextProperty().setValue(value); }
 325     public final boolean isWrapText() { return wrapText == null ? false : wrapText.getValue(); }
 326 
 327     /**
 328      * If wrapText is true, then contentBias will be HORIZONTAL, otherwise it is null.
 329      * @return orientation of width/height dependency or null if there is none
 330      */
 331     @Override public Orientation getContentBias() {
 332         return isWrapText()? Orientation.HORIZONTAL : null;
 333     }
 334 
 335     /**
 336      * The default font to use for text in the Labeled. If the Label&#39;s text is
 337      * rich text then this font may or may not be used depending on the font
 338      * information embedded in the rich text, but in any case where a default
 339      * font is required, this font will be used.
 340      *
 341      * @return the default font to use for text in this labeled
<a name="10" id="anc10"></a><span class="line-modified"> 342      * @default {@link Font#getDefault()}</span>
 343      */
 344     public final ObjectProperty&lt;Font&gt; fontProperty() {
 345 
 346         if (font == null) {
 347             font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {
 348 
 349                 private boolean fontSetByCss = false;
 350 
 351                 @Override
 352                 public void applyStyle(StyleOrigin newOrigin, Font value) {
 353 
 354                     //
 355                     // RT-20727 - if CSS is setting the font, then make sure invalidate doesn&#39;t call NodeHelper.reapplyCSS
 356                     //
 357                     try {
 358                         // super.applyStyle calls set which might throw if value is bound.
 359                         // Have to make sure fontSetByCss is reset.
 360                         fontSetByCss = true;
 361                         super.applyStyle(newOrigin, value);
 362                     } catch(Exception e) {
 363                         throw e;
 364                     } finally {
 365                         fontSetByCss = false;
 366                     }
 367                 }
 368 
 369                 @Override
 370                 public void set(Font value) {
 371 
 372                     final Font oldValue = get();
 373                     if (value != null ? !value.equals(oldValue) : oldValue != null) {
 374                         super.set(value);
 375                     }
 376 
 377                 }
 378 
 379                 @Override
 380                 protected void invalidated() {
 381                     // RT-20727 - if font is changed by calling setFont, then
 382                     // css might need to be reapplied since font size affects
 383                     // calculated values for styles with relative values
 384                     if(fontSetByCss == false) {
 385                         NodeHelper.reapplyCSS(Labeled.this);
 386                     }
 387                 }
 388 
 389                 @Override
 390                 public CssMetaData&lt;Labeled,Font&gt; getCssMetaData() {
 391                     return StyleableProperties.FONT;
 392                 }
 393 
 394                 @Override
 395                 public Object getBean() {
 396                     return Labeled.this;
 397                 }
 398 
 399                 @Override
 400                 public String getName() {
 401                     return &quot;font&quot;;
 402                 }
 403             };
 404         }
 405         return font;
 406     }
 407     private ObjectProperty&lt;Font&gt; font;
 408     public final void setFont(Font value) { fontProperty().setValue(value); }
 409     public final Font getFont() { return font == null ? Font.getDefault() : font.getValue(); }
 410 
 411 
 412     /**
 413      * An optional icon for the Labeled. This can be positioned relative to the
 414      * text by using {@link #setContentDisplay}.  The node specified for this
 415      * variable cannot appear elsewhere in the scene graph, otherwise
 416      * the {@code IllegalArgumentException} is thrown.  See the class
 417      * description of {@link Node} for more detail.
 418      *
 419      * @return the optional icon for this labeled
<a name="11" id="anc11"></a><span class="line-modified"> 420      * @default {@code null}</span>
 421      */
 422     public final ObjectProperty&lt;Node&gt; graphicProperty() {
 423         if (graphic == null) {
 424             graphic = new StyleableObjectProperty&lt;Node&gt;() {
 425 
 426                 // The graphic is styleable by css, but it is the
 427                 // imageUrlProperty that handles the style value.
 428                 @Override
 429                 public CssMetaData getCssMetaData() {
 430                     return StyleableProperties.GRAPHIC;
 431                 }
 432 
 433                 @Override
 434                 public Object getBean() {
 435                     return Labeled.this;
 436                 }
 437 
 438                 @Override
 439                 public String getName() {
 440                     return &quot;graphic&quot;;
 441                 }
 442             };
 443         }
 444         return graphic;
 445     }
 446     private ObjectProperty&lt;Node&gt; graphic;
 447     public final void setGraphic(Node value) {
 448         graphicProperty().setValue(value);
 449     }
 450     public final Node getGraphic() { return graphic == null ? null : graphic.getValue(); }
 451 
 452     private StyleableStringProperty imageUrl = null;
 453     /**
 454      * The imageUrl property is set from CSS and then the graphic property is
 455      * set from the invalidated method. This ensures that the same image isn&#39;t
 456      * reloaded.
 457      */
 458     private StyleableStringProperty imageUrlProperty() {
 459         if (imageUrl == null) {
 460             imageUrl = new StyleableStringProperty() {
 461 
 462                 //
 463                 // If imageUrlProperty is invalidated, this is the origin of the style that
 464                 // triggered the invalidation. This is used in the invaildated() method where the
 465                 // value of super.getStyleOrigin() is not valid until after the call to set(v) returns,
 466                 // by which time invalidated will have been called.
 467                 // This value is initialized to USER in case someone calls set on the imageUrlProperty, which
 468                 // is possible:
 469                 //     CssMetaData metaData = ((StyleableProperty)labeled.graphicProperty()).getCssMetaData();
 470                 //     StyleableProperty prop = metaData.getStyleableProperty(labeled);
 471                 //     prop.set(someUrl);
 472                 //
 473                 // TODO: Note that prop != labeled, which violates the contract between StyleableProperty and CssMetaData.
 474                 //
 475                 StyleOrigin origin = StyleOrigin.USER;
 476 
 477                 @Override
 478                 public void applyStyle(StyleOrigin origin, String v) {
 479 
 480                     this.origin = origin;
 481 
 482                     // Don&#39;t want applyStyle to throw an exception which would leave this.origin set to the wrong value
 483                     if (graphic == null || graphic.isBound() == false) super.applyStyle(origin, v);
 484 
 485                     // Origin is only valid for this invocation of applyStyle, so reset it to USER in case someone calls set.
 486                     this.origin = StyleOrigin.USER;
 487                 }
 488 
 489                 @Override
 490                 protected void invalidated() {
 491 
 492                     // need to call super.get() here since get() is overridden to return the graphicProperty&#39;s value
 493                     final String url = super.get();
 494 
 495                     if (url == null) {
 496                         ((StyleableProperty&lt;Node&gt;)(WritableValue&lt;Node&gt;)graphicProperty()).applyStyle(origin, null);
 497                     } else {
 498                         // RT-34466 - if graphic&#39;s url is the same as this property&#39;s value, then don&#39;t overwrite.
 499                         final Node graphicNode = Labeled.this.getGraphic();
 500                         if (graphicNode instanceof ImageView) {
 501                             final ImageView imageView = (ImageView)graphicNode;
 502                             final Image image = imageView.getImage();
 503                             if (image != null) {
 504                                 final String imageViewUrl = image.getUrl();
 505                                 if (url.equals(imageViewUrl)) return;
 506                             }
 507 
 508                         }
 509 
 510                         final Image img = StyleManager.getInstance().getCachedImage(url);
 511 
 512                         if (img != null) {
 513                             //
 514                             // Note that it is tempting to try to re-use existing ImageView simply by setting
 515                             // the image on the current ImageView, if there is one. This would effectively change
 516                             // the image, but not the ImageView which means that no graphicProperty listeners would
 517                             // be notified. This is probably not what we want.
 518                             //
 519 
 520                             //
 521                             // Have to call applyStyle on graphicProperty so that the graphicProperty&#39;s
 522                             // origin matches the imageUrlProperty&#39;s origin.
 523                             //
 524                             ((StyleableProperty&lt;Node&gt;)(WritableValue&lt;Node&gt;)graphicProperty()).applyStyle(origin, new ImageView(img));
 525                         }
 526                     }
 527                 }
 528 
 529                 @Override
 530                 public String get() {
 531 
 532                     //
 533                     // The value of the imageUrlProperty is that of the graphicProperty.
 534                     // Return the value in a way that doesn&#39;t expand the graphicProperty.
 535                     //
 536                     final Node graphic = getGraphic();
 537                     if (graphic instanceof ImageView) {
 538                         final Image image = ((ImageView)graphic).getImage();
 539                         if (image != null) {
 540                             return image.getUrl();
 541                         }
 542                     }
 543                     return null;
 544                 }
 545 
 546                 @Override
 547                 public StyleOrigin getStyleOrigin() {
 548 
 549                     //
 550                     // The origin of the imageUrlProperty is that of the graphicProperty.
 551                     // Return the origin in a way that doesn&#39;t expand the graphicProperty.
 552                     //
 553                     return graphic != null ? ((StyleableProperty&lt;Node&gt;)(WritableValue&lt;Node&gt;)graphic).getStyleOrigin() : null;
 554                 }
 555 
 556                 @Override
 557                 public Object getBean() {
 558                     return Labeled.this;
 559                 }
 560 
 561                 @Override
 562                 public String getName() {
 563                     return &quot;imageUrl&quot;;
 564                 }
 565 
 566                 @Override
 567                 public CssMetaData&lt;Labeled,String&gt; getCssMetaData() {
 568                     return StyleableProperties.GRAPHIC;
 569                 }
 570 
 571             };
 572         }
 573         return imageUrl;
 574     }
 575 
 576     /**
 577      * Whether all text should be underlined.
 578      *
 579      * @return the underline property of all text in this labeled
<a name="12" id="anc12"></a><span class="line-modified"> 580      * @default {@code false}</span>
 581      */
 582     public final BooleanProperty underlineProperty() {
 583         if (underline == null) {
 584             underline = new StyleableBooleanProperty(false) {
 585 
 586                 @Override
 587                 public CssMetaData&lt;Labeled, Boolean&gt; getCssMetaData() {
 588                     return StyleableProperties.UNDERLINE;
 589                 }
 590 
 591                 @Override
 592                 public Object getBean() {
 593                     return Labeled.this;
 594                 }
 595 
 596                 @Override
 597                 public String getName() {
 598                     return &quot;underline&quot;;
 599                 }
 600             };
 601         }
 602         return underline;
 603     }
 604     private BooleanProperty underline;
 605     public final void setUnderline(boolean value) { underlineProperty().setValue(value); }
 606     public final boolean isUnderline() { return underline == null ? false : underline.getValue(); }
 607 
 608     /**
 609      * Specifies the space in pixel between lines.
 610      *
 611      * @return the line spacing property between lines in this labeled
 612      * @since JavaFX 8.0
<a name="13" id="anc13"></a><span class="line-modified"> 613      * @default 0</span>
 614      */
 615     public final DoubleProperty lineSpacingProperty() {
 616         if (lineSpacing == null) {
 617             lineSpacing = new StyleableDoubleProperty(0) {
 618 
 619                 @Override
 620                 public CssMetaData&lt;Labeled,Number&gt; getCssMetaData() {
 621                     return StyleableProperties.LINE_SPACING;
 622                 }
 623 
 624                 @Override
 625                 public Object getBean() {
 626                     return Labeled.this;
 627                 }
 628 
 629                 @Override
 630                 public String getName() {
 631                     return &quot;lineSpacing&quot;;
 632                 }
 633             };
 634         }
 635         return lineSpacing;
 636     }
 637     private DoubleProperty lineSpacing;
 638     public final void setLineSpacing(double value) { lineSpacingProperty().setValue(value); }
 639     public final double getLineSpacing() { return lineSpacing == null ? 0 : lineSpacing.getValue(); }
 640 
 641     /**
 642      * Specifies the positioning of the graphic relative to the text.
 643      *
 644      * @return content display property of this labeled
<a name="14" id="anc14"></a><span class="line-modified"> 645      * @default {@code ContentDisplay.LEFT}</span>
 646      */
 647     public final ObjectProperty&lt;ContentDisplay&gt; contentDisplayProperty() {
 648         if (contentDisplay == null) {
 649             contentDisplay = new StyleableObjectProperty&lt;ContentDisplay&gt;(ContentDisplay.LEFT) {
 650 
 651                 @Override
 652                 public CssMetaData&lt;Labeled,ContentDisplay&gt; getCssMetaData() {
 653                     return StyleableProperties.CONTENT_DISPLAY;
 654                 }
 655 
 656                 @Override
 657                 public Object getBean() {
 658                     return Labeled.this;
 659                 }
 660 
 661                 @Override
 662                 public String getName() {
 663                     return &quot;contentDisplay&quot;;
 664                 }
 665             };
 666         }
 667         return contentDisplay;
 668     }
 669     private ObjectProperty&lt;ContentDisplay&gt; contentDisplay;
 670     public final void setContentDisplay(ContentDisplay value) { contentDisplayProperty().setValue(value); }
 671     public final ContentDisplay getContentDisplay() { return contentDisplay == null ? ContentDisplay.LEFT : contentDisplay.getValue(); }
 672 
 673     /**
 674      * The padding around the Labeled&#39;s text and graphic content.
 675      * By default labelPadding is Insets.EMPTY and cannot be set to null.
 676      * Subclasses may add nodes outside this padding and inside the Labeled&#39;s padding.
 677      *
 678      * This property can only be set from CSS.
 679      *
 680      * @return the label padding property of this labeled
<a name="15" id="anc15"></a><span class="line-modified"> 681      * @default {@code Insets.EMPTY}</span>
 682      */
 683     public final ReadOnlyObjectProperty&lt;Insets&gt; labelPaddingProperty() {
 684         return labelPaddingPropertyImpl();
 685     }
 686     private ObjectProperty&lt;Insets&gt; labelPaddingPropertyImpl() {
 687         if (labelPadding == null) {
 688             labelPadding = new StyleableObjectProperty&lt;Insets&gt;(Insets.EMPTY) {
 689                 private Insets lastValidValue = Insets.EMPTY;
 690 
 691                 @Override
 692                 public void invalidated() {
 693                     final Insets newValue = get();
 694                     if (newValue == null) {
 695                         set(lastValidValue);
 696                         throw new NullPointerException(&quot;cannot set labelPadding to null&quot;);
 697                     }
 698                     lastValidValue = newValue;
 699                     requestLayout();
 700                 }
 701 
 702                 @Override
 703                 public CssMetaData&lt;Labeled,Insets&gt; getCssMetaData() {
 704                     return StyleableProperties.LABEL_PADDING;
 705                 }
 706 
 707                 @Override
 708                 public Object getBean() {
 709                     return Labeled.this;
 710                 }
 711 
 712                 @Override
 713                 public String getName() {
 714                     return &quot;labelPadding&quot;;
 715                 }
 716             };
 717         }
 718         return labelPadding;
 719     }
 720     private ObjectProperty&lt;Insets&gt; labelPadding;
 721     private void setLabelPadding(Insets value) { labelPaddingPropertyImpl().set(value); }
 722     public final Insets getLabelPadding() { return labelPadding == null ? Insets.EMPTY : labelPadding.get(); }
 723 
 724     /**
 725      * The amount of space between the graphic and text
 726      *
 727      * @return the graphics text gap property of this labeled
<a name="16" id="anc16"></a><span class="line-modified"> 728      * @default 4</span>
 729      */
 730     public final DoubleProperty graphicTextGapProperty() {
 731         if (graphicTextGap == null) {
 732             graphicTextGap = new StyleableDoubleProperty(4) {
 733 
 734                 @Override
 735                 public CssMetaData&lt;Labeled,Number&gt; getCssMetaData() {
 736                     return StyleableProperties.GRAPHIC_TEXT_GAP;
 737                 }
 738 
 739                 @Override
 740                 public Object getBean() {
 741                     return Labeled.this;
 742                 }
 743 
 744                 @Override
 745                 public String getName() {
 746                     return &quot;graphicTextGap&quot;;
 747                 }
 748             };
 749         }
 750         return graphicTextGap;
 751     }
 752     private DoubleProperty graphicTextGap;
 753     public final void setGraphicTextGap(double value) { graphicTextGapProperty().setValue(value); }
 754     public final double getGraphicTextGap() { return graphicTextGap == null ? 4 : graphicTextGap.getValue(); }
 755 
 756 
 757     /**
 758      * The {@link Paint} used to fill the text.
 759      *
<a name="17" id="anc17"></a><span class="line-modified"> 760      * @default {@code Color.BLACK}</span>
 761      */
 762     private ObjectProperty&lt;Paint&gt; textFill; // TODO for now change this
 763 
 764     public final void setTextFill(Paint value) {
 765         textFillProperty().set(value);
 766     }
 767 
 768     public final Paint getTextFill() {
 769         return textFill == null ? Color.BLACK : textFill.get();
 770     }
 771 
 772     public final ObjectProperty&lt;Paint&gt; textFillProperty() {
 773         if (textFill == null) {
 774             textFill = new StyleableObjectProperty&lt;Paint&gt;(Color.BLACK) {
 775 
 776                 @Override
 777                 public CssMetaData&lt;Labeled,Paint&gt; getCssMetaData() {
 778                     return StyleableProperties.TEXT_FILL;
 779                 }
 780 
 781                 @Override
 782                 public Object getBean() {
 783                     return Labeled.this;
 784                 }
 785 
 786                 @Override
 787                 public String getName() {
 788                     return &quot;textFill&quot;;
 789                 }
 790             };
 791         }
 792         return textFill;
 793     }
 794 
 795 
 796     /**
 797      * MnemonicParsing property to enable/disable text parsing.
 798      * If this is set to true, then the Label text will be
 799      * parsed to see if it contains the mnemonic parsing character &#39;_&#39;.
 800      * When a mnemonic is detected the key combination will
 801      * be determined based on the succeeding character, and the mnemonic
 802      * added.
 803      *
<a name="18" id="anc18"></a><span class="line-modified"> 804      * @default {@code false}; {@code true} for some Controls.</span>
<span class="line-removed"> 805      * &lt;/p&gt;</span>
 806      */
 807     private BooleanProperty mnemonicParsing;
 808     public final void setMnemonicParsing(boolean value) {
 809         mnemonicParsingProperty().set(value);
 810     }
 811     public final boolean isMnemonicParsing() {
 812         return mnemonicParsing == null ? false : mnemonicParsing.get();
 813     }
 814     public final BooleanProperty mnemonicParsingProperty() {
 815         if (mnemonicParsing == null) {
 816             mnemonicParsing = new SimpleBooleanProperty(this, &quot;mnemonicParsing&quot;);
 817         }
 818         return mnemonicParsing;
 819     }
 820 
 821     //    /**
 822     //     * This is the symbol that is searched for in the text and used as
 823     //     * a mnemonic. You can change what symbol is used. Using the symbol
 824     //     * more than once will cause the symbol to be escaped. Thus, if &quot;_&quot;
 825     //     * (the default) is used, then the string &quot;H_ello World&quot; will use
 826     //     * &quot;e&quot; as the mnemonic. If &quot;H__ello World&quot; is used, then no mnemonic
 827     //     * will be used and the text will be rendered as &quot;H_ello World&quot;.
 828     //     * TODO: Have i18n review this part of the API to confirm proper
 829     //     * externalization will work as expected
 830     //     */
 831 
 832     @Override public String toString() {
 833         StringBuilder builder =
 834             new StringBuilder(super.toString())
 835                 .append(&quot;&#39;&quot;).append(getText()).append(&quot;&#39;&quot;);
 836         return builder.toString();
 837     }
 838 
 839     /***************************************************************************
 840      *                                                                         *
 841      * Stylesheet Handling                                                     *
 842      *                                                                         *
 843      **************************************************************************/
 844 
 845     /**
 846      * Returns the initial alignment state of this control, for use
 847      * by the JavaFX CSS engine to correctly set its initial value. This method
 848      * is overridden to use Pos.CENTER_LEFT initially.
 849      *
 850      * @return the initial alignment state of this control
 851      * @since 9
 852      */
 853     protected Pos getInitialAlignment() {
 854         return Pos.CENTER_LEFT;
 855     }
 856 
 857     private static class StyleableProperties {
 858         private static final FontCssMetaData&lt;Labeled&gt; FONT =
 859             new FontCssMetaData&lt;Labeled&gt;(&quot;-fx-font&quot;, Font.getDefault()) {
 860 
 861             @Override
 862             public boolean isSettable(Labeled n) {
 863                 return n.font == null || !n.font.isBound();
 864             }
 865 
 866             @Override
 867             public StyleableProperty&lt;Font&gt; getStyleableProperty(Labeled n) {
 868                 return (StyleableProperty&lt;Font&gt;)(WritableValue&lt;Font&gt;)n.fontProperty();
 869             }
 870         };
 871 
 872         private static final CssMetaData&lt;Labeled,Pos&gt; ALIGNMENT =
 873                 new CssMetaData&lt;Labeled,Pos&gt;(&quot;-fx-alignment&quot;,
 874                 new EnumConverter&lt;Pos&gt;(Pos.class), Pos.CENTER_LEFT ) {
 875 
 876             @Override
 877             public boolean isSettable(Labeled n) {
 878                 return n.alignment == null || !n.alignment.isBound();
 879             }
 880 
 881             @Override
 882             public StyleableProperty&lt;Pos&gt; getStyleableProperty(Labeled n) {
 883                 return (StyleableProperty&lt;Pos&gt;)(WritableValue&lt;Pos&gt;)n.alignmentProperty();
 884             }
 885 
 886             @Override
 887             public Pos getInitialValue(Labeled n) {
 888                 return n.getInitialAlignment();
 889             }
 890         };
 891 
 892         private static final CssMetaData&lt;Labeled,TextAlignment&gt; TEXT_ALIGNMENT =
 893                 new CssMetaData&lt;Labeled,TextAlignment&gt;(&quot;-fx-text-alignment&quot;,
 894                 new EnumConverter&lt;TextAlignment&gt;(TextAlignment.class),
 895                 TextAlignment.LEFT) {
 896 
 897             @Override
 898             public boolean isSettable(Labeled n) {
 899                 return n.textAlignment == null || !n.textAlignment.isBound();
 900             }
 901 
 902             @Override
 903             public StyleableProperty&lt;TextAlignment&gt; getStyleableProperty(Labeled n) {
 904                 return (StyleableProperty&lt;TextAlignment&gt;)(WritableValue&lt;TextAlignment&gt;)n.textAlignmentProperty();
 905             }
 906         };
 907 
 908         private static final CssMetaData&lt;Labeled,Paint&gt; TEXT_FILL =
 909                 new CssMetaData&lt;Labeled,Paint&gt;(&quot;-fx-text-fill&quot;,
 910                 PaintConverter.getInstance(), Color.BLACK) {
 911 
 912             @Override
 913             public boolean isSettable(Labeled n) {
 914                 return n.textFill == null || !n.textFill.isBound();
 915             }
 916 
 917             @Override
 918             public StyleableProperty&lt;Paint&gt; getStyleableProperty(Labeled n) {
 919                 return (StyleableProperty&lt;Paint&gt;)(WritableValue&lt;Paint&gt;)n.textFillProperty();
 920             }
 921         };
 922 
 923         private static final CssMetaData&lt;Labeled,OverrunStyle&gt; TEXT_OVERRUN =
 924                 new CssMetaData&lt;Labeled,OverrunStyle&gt;(&quot;-fx-text-overrun&quot;,
 925                 new EnumConverter&lt;OverrunStyle&gt;(OverrunStyle.class),
 926                 OverrunStyle.ELLIPSIS) {
 927 
 928             @Override
 929             public boolean isSettable(Labeled n) {
 930                 return n.textOverrun == null || !n.textOverrun.isBound();
 931             }
 932 
 933             @Override
 934             public StyleableProperty&lt;OverrunStyle&gt; getStyleableProperty(Labeled n) {
 935                 return (StyleableProperty&lt;OverrunStyle&gt;)(WritableValue&lt;OverrunStyle&gt;)n.textOverrunProperty();
 936             }
 937         };
 938 
 939         private static final CssMetaData&lt;Labeled,String&gt; ELLIPSIS_STRING =
 940                 new CssMetaData&lt;Labeled,String&gt;(&quot;-fx-ellipsis-string&quot;,
 941                 StringConverter.getInstance(), DEFAULT_ELLIPSIS_STRING) {
 942 
 943             @Override public boolean isSettable(Labeled n) {
 944                 return n.ellipsisString == null || !n.ellipsisString.isBound();
 945             }
 946 
 947             @Override public StyleableProperty&lt;String&gt; getStyleableProperty(Labeled n) {
 948                 return (StyleableProperty&lt;String&gt;)(WritableValue&lt;String&gt;)n.ellipsisStringProperty();
 949             }
 950         };
 951 
 952         private static final CssMetaData&lt;Labeled,Boolean&gt; WRAP_TEXT =
 953                 new CssMetaData&lt;Labeled,Boolean&gt;(&quot;-fx-wrap-text&quot;,
 954                 BooleanConverter.getInstance(), false) {
 955 
 956             @Override
 957             public boolean isSettable(Labeled n) {
 958                 return n.wrapText == null || !n.wrapText.isBound();
 959             }
 960 
 961             @Override
 962             public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Labeled n) {
 963                 return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)n.wrapTextProperty();
 964             }
 965         };
 966 
 967         private static final CssMetaData&lt;Labeled,String&gt; GRAPHIC =
 968             new CssMetaData&lt;Labeled,String&gt;(&quot;-fx-graphic&quot;,
 969                 StringConverter.getInstance()) {
 970 
 971             @Override
 972             public boolean isSettable(Labeled n) {
 973                 // Note that we care about the graphic, not imageUrl
 974                 return n.graphic == null || !n.graphic.isBound();
 975             }
 976 
 977             @Override
 978             public StyleableProperty&lt;String&gt; getStyleableProperty(Labeled n) {
 979                 return n.imageUrlProperty();
 980             }
 981         };
 982 
 983         private static final CssMetaData&lt;Labeled,Boolean&gt; UNDERLINE =
 984             new CssMetaData&lt;Labeled,Boolean&gt;(&quot;-fx-underline&quot;,
 985                 BooleanConverter.getInstance(), Boolean.FALSE) {
 986 
 987             @Override
 988             public boolean isSettable(Labeled n) {
 989                 return n.underline == null || !n.underline.isBound();
 990             }
 991 
 992             @Override
 993             public StyleableProperty&lt;Boolean&gt; getStyleableProperty(Labeled n) {
 994                 return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)n.underlineProperty();
 995             }
 996         };
 997 
 998         private static final CssMetaData&lt;Labeled,Number&gt; LINE_SPACING =
 999             new CssMetaData&lt;Labeled,Number&gt;(&quot;-fx-line-spacing&quot;,
1000                 SizeConverter.getInstance(), 0) {
1001 
1002             @Override
1003             public boolean isSettable(Labeled n) {
1004                 return n.lineSpacing == null || !n.lineSpacing.isBound();
1005             }
1006 
1007             @Override
1008             public StyleableProperty&lt;Number&gt; getStyleableProperty(Labeled n) {
1009                 return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.lineSpacingProperty();
1010             }
1011         };
1012 
1013         private static final CssMetaData&lt;Labeled,ContentDisplay&gt; CONTENT_DISPLAY =
1014             new CssMetaData&lt;Labeled,ContentDisplay&gt;(&quot;-fx-content-display&quot;,
1015                 new EnumConverter&lt;ContentDisplay&gt;(ContentDisplay.class),
1016                 ContentDisplay.LEFT) {
1017 
1018             @Override
1019             public boolean isSettable(Labeled n) {
1020                 return n.contentDisplay == null || !n.contentDisplay.isBound();
1021             }
1022 
1023             @Override
1024             public StyleableProperty&lt;ContentDisplay&gt; getStyleableProperty(Labeled n) {
1025                 return (StyleableProperty&lt;ContentDisplay&gt;)(WritableValue&lt;ContentDisplay&gt;)n.contentDisplayProperty();
1026             }
1027         };
1028 
1029         private static final CssMetaData&lt;Labeled,Insets&gt; LABEL_PADDING =
1030             new CssMetaData&lt;Labeled,Insets&gt;(&quot;-fx-label-padding&quot;,
1031                 InsetsConverter.getInstance(), Insets.EMPTY) {
1032 
1033             @Override
1034             public boolean isSettable(Labeled n) {
1035                 return n.labelPadding == null || !n.labelPadding.isBound();
1036             }
1037 
1038             @Override
1039             public StyleableProperty&lt;Insets&gt; getStyleableProperty(Labeled n) {
1040                 return (StyleableProperty&lt;Insets&gt;)(WritableValue&lt;Insets&gt;)n.labelPaddingPropertyImpl();
1041             }
1042         };
1043 
1044         private static final CssMetaData&lt;Labeled,Number&gt; GRAPHIC_TEXT_GAP =
1045             new CssMetaData&lt;Labeled,Number&gt;(&quot;-fx-graphic-text-gap&quot;,
1046                 SizeConverter.getInstance(), 4.0) {
1047 
1048             @Override
1049             public boolean isSettable(Labeled n) {
1050                 return n.graphicTextGap == null || !n.graphicTextGap.isBound();
1051             }
1052 
1053             @Override
1054             public StyleableProperty&lt;Number&gt; getStyleableProperty(Labeled n) {
1055                 return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.graphicTextGapProperty();
1056             }
1057         };
1058 
1059         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
1060         static {
1061             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1062                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
1063             Collections.addAll(styleables,
1064                 FONT,
1065                 ALIGNMENT,
1066                 TEXT_ALIGNMENT,
1067                 TEXT_FILL,
1068                 TEXT_OVERRUN,
1069                 ELLIPSIS_STRING,
1070                 WRAP_TEXT,
1071                 GRAPHIC,
1072                 UNDERLINE,
1073                 LINE_SPACING,
1074                 CONTENT_DISPLAY,
1075                 LABEL_PADDING,
1076                 GRAPHIC_TEXT_GAP
1077             );
1078             STYLEABLES = Collections.unmodifiableList(styleables);
1079         }
1080     }
1081 
1082     /**
1083      * @return The CssMetaData associated with this class, which may include the
1084      * CssMetaData of its superclasses.
1085      * @since JavaFX 8.0
1086      */
1087     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1088         return StyleableProperties.STYLEABLES;
1089     }
1090 
1091     /**
1092      * {@inheritDoc}
1093      * @since JavaFX 8.0
1094      */
1095     @Override
1096     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
1097         return getClassCssMetaData();
1098     }
1099  }
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.controls/src/main/java/javafx/scene/control/Labeled.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Pagination.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.controls/src/main/java/javafx/scene/control/Labeled.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control;
  27 
<span class="line-removed">  28 </span>
  29 import com.sun.javafx.css.StyleManager;
  30 import com.sun.javafx.scene.NodeHelper;
  31 import javafx.css.converter.BooleanConverter;
  32 import javafx.css.converter.EnumConverter;
  33 import javafx.css.converter.InsetsConverter;
  34 import javafx.css.converter.PaintConverter;
  35 import javafx.css.converter.SizeConverter;
  36 import javafx.css.converter.StringConverter;
  37 
  38 import java.util.ArrayList;
  39 import java.util.Collections;
  40 import java.util.List;
  41 
  42 import javafx.beans.property.BooleanProperty;
  43 import javafx.beans.property.DoubleProperty;
  44 import javafx.beans.property.ObjectProperty;
  45 import javafx.beans.property.ReadOnlyObjectProperty;
  46 import javafx.beans.property.SimpleBooleanProperty;
  47 import javafx.beans.property.SimpleStringProperty;
  48 import javafx.beans.property.StringProperty;
</pre>
<hr />
<pre>
  51 import javafx.geometry.Orientation;
  52 import javafx.geometry.Pos;
  53 import javafx.scene.Node;
  54 import javafx.scene.image.Image;
  55 import javafx.scene.image.ImageView;
  56 import javafx.scene.paint.Color;
  57 import javafx.scene.paint.Paint;
  58 import javafx.scene.text.Font;
  59 import javafx.scene.text.TextAlignment;
  60 import javafx.beans.DefaultProperty;
  61 import javafx.css.CssMetaData;
  62 import javafx.css.FontCssMetaData;
  63 import javafx.css.StyleOrigin;
  64 import javafx.css.Styleable;
  65 import javafx.css.StyleableBooleanProperty;
  66 import javafx.css.StyleableDoubleProperty;
  67 import javafx.css.StyleableObjectProperty;
  68 import javafx.css.StyleableProperty;
  69 import javafx.css.StyleableStringProperty;
  70 
<span class="line-removed">  71 </span>
  72 /**
  73  * A Labeled {@link Control} is one which has as part of its user interface
  74  * a textual content associated with it. For example, a {@link Button} displays
  75  * {@code text}, as does a {@link Label}, a {@link Tooltip}, and many
  76  * other controls.
  77  * &lt;p&gt;
  78  * Labeled is also a convenient base class from which to extend when building
  79  * new Controls which, as part of their UI, display read-only textual content.
  80  * &lt;/p&gt;
  81  *
  82  * &lt;p&gt;Example of how to place a graphic above the text:
  83  * &lt;pre&gt;&lt;code&gt;
  84  *  Image image = new Image(getClass().getResourceAsStream(&quot;image.png&quot;));
  85  *  ImageView imageView = new ImageView();
  86  *  imageView.setImage(image);
  87  *  Label label = new Label(&quot;text&quot;, imageView);
  88  *  label.setContentDisplay(ContentDisplay.TOP);
  89  * &lt;/code&gt;&lt;/pre&gt;
  90  *
  91  * @see Button
</pre>
<hr />
<pre>
 120 
 121     /**
 122      * Creates a Label with text and a graphic
 123      * @param text The text for the label.
 124      * @param graphic The graphic for the label.
 125      */
 126     public Labeled(String text, Node graphic) {
 127         setText(text);
 128         ((StyleableProperty&lt;Node&gt;)(WritableValue&lt;Node&gt;)graphicProperty()).applyStyle(null, graphic);
 129     }
 130 
 131     /***************************************************************************
 132      *                                                                         *
 133      * Properties                                                              *
 134      *                                                                         *
 135      **************************************************************************/
 136     /**
 137      * The text to display in the label. The text may be null.
 138      *
 139      * @return the text to display in the label
<span class="line-modified"> 140      * @default {@code &quot;&quot;} (empty string}</span>
 141      */
 142     public final StringProperty textProperty() {
 143         if (text == null) {
 144             text = new SimpleStringProperty(this, &quot;text&quot;, &quot;&quot;);
 145         }
 146         return text;
 147     }
 148     private StringProperty text;
 149     public final void setText(String value) { textProperty().setValue(value); }
 150     public final String getText() { return text == null ? &quot;&quot; : text.getValue(); }
 151 
 152     /**
 153      * Specifies how the text and graphic within the Labeled should be
 154      * aligned when there is empty space within the Labeled.

 155      * @return the alignment within this labeled

 156      */
 157     public final ObjectProperty&lt;Pos&gt; alignmentProperty() {
 158         if (alignment == null) {
 159             alignment = new StyleableObjectProperty&lt;Pos&gt;(Pos.CENTER_LEFT) {
 160 
 161                 @Override public CssMetaData&lt;Labeled,Pos&gt; getCssMetaData() {
 162                     return StyleableProperties.ALIGNMENT;
 163                 }
 164 
 165                 @Override
 166                 public Object getBean() {
 167                     return Labeled.this;
 168                 }
 169 
 170                 @Override
 171                 public String getName() {
 172                     return &quot;alignment&quot;;
 173                 }
 174             };
 175         }
 176         return alignment;
 177     }
 178     private ObjectProperty&lt;Pos&gt; alignment;
 179     public final void setAlignment(Pos value) { alignmentProperty().set(value); }
 180     public final Pos getAlignment() { return alignment == null ? Pos.CENTER_LEFT : alignment.get(); }
 181 
 182 
 183     /**
 184      * Specifies the behavior for lines of text &lt;em&gt;when text is multiline&lt;/em&gt;.
 185      * Unlike {@link #contentDisplayProperty} which affects the graphic and text, this setting
 186      * only affects multiple lines of text relative to the text bounds.
 187      *
 188      * @return the alignment of lines of text within this labeled
<span class="line-modified"> 189      * @default {@code TextAlignment.LEFT}</span>
 190      */
 191     public final ObjectProperty&lt;TextAlignment&gt; textAlignmentProperty() {
 192         if (textAlignment == null) {
 193             textAlignment = new StyleableObjectProperty&lt;TextAlignment&gt;(TextAlignment.LEFT) {
 194 
 195                 @Override
 196                 public CssMetaData&lt;Labeled,TextAlignment&gt; getCssMetaData() {
 197                     return StyleableProperties.TEXT_ALIGNMENT;
 198                 }
 199 
 200                 @Override
 201                 public Object getBean() {
 202                     return Labeled.this;
 203                 }
 204 
 205                 @Override
 206                 public String getName() {
 207                     return &quot;textAlignment&quot;;
 208                 }
 209             };
 210         }
 211         return textAlignment;
 212     }
 213     private ObjectProperty&lt;TextAlignment&gt; textAlignment;
 214     public final void setTextAlignment(TextAlignment value) { textAlignmentProperty().setValue(value); }
 215     public final TextAlignment getTextAlignment() { return textAlignment == null ? TextAlignment.LEFT : textAlignment.getValue(); }
 216 
 217     /**
 218      * Specifies the behavior to use if the text of the {@code Labeled}
 219      * exceeds the available space for rendering the text.
 220      *
 221      * @return the overrun behavior if the text exceeds the available space
<span class="line-modified"> 222      * @default {@code OverrunStyle.ELLIPSIS}</span>
 223      */
 224     public final ObjectProperty&lt;OverrunStyle&gt; textOverrunProperty() {
 225         if (textOverrun == null) {
 226             textOverrun = new StyleableObjectProperty&lt;OverrunStyle&gt;(OverrunStyle.ELLIPSIS) {
 227 
 228                 @Override
 229                 public CssMetaData&lt;Labeled,OverrunStyle&gt; getCssMetaData() {
 230                     return StyleableProperties.TEXT_OVERRUN;
 231                 }
 232 
 233                 @Override
 234                 public Object getBean() {
 235                     return Labeled.this;
 236                 }
 237 
 238                 @Override
 239                 public String getName() {
 240                     return &quot;textOverrun&quot;;
 241                 }
 242             };
</pre>
<hr />
<pre>
 249 
 250     /**
 251      * Specifies the string to display for the ellipsis when text is truncated.
 252      *
 253      * &lt;table&gt;
 254      *   &lt;caption&gt;Ellipsis Table&lt;/caption&gt;
 255      *   &lt;tr&gt;&lt;th scope=&quot;col&quot; colspan=2&gt;Examples&lt;/th&gt;&lt;/tr&gt;
 256      *   &lt;tr class=&quot;altColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot;...&quot; &lt;/th&gt;        &lt;td&gt;Default value for most locales&lt;/td&gt;
 257      *   &lt;tr class=&quot;rowColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot; . . . &quot; &lt;/th&gt;    &lt;td&gt;&lt;/td&gt;
 258      *   &lt;tr class=&quot;altColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot; [...] &quot; &lt;/th&gt;    &lt;td&gt;&lt;/td&gt;
 259      *   &lt;tr class=&quot;rowColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot;&amp;#92;u2026&quot; &lt;/th&gt; &lt;td&gt;The Unicode ellipsis character &#39;&amp;hellip;&#39;&lt;/td&gt;
 260      *   &lt;tr class=&quot;altColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot;&quot; &lt;/th&gt;           &lt;td&gt;No ellipsis, just display the truncated string&lt;/td&gt;
 261      * &lt;/table&gt;
 262      *
 263      * &lt;p&gt;Note that not all fonts support all Unicode characters.
 264      *
 265      * @return the ellipsis property on the string to display for the ellipsis
 266      * when text is truncated
 267      * @see &lt;a href=&quot;http://en.wikipedia.org/wiki/Ellipsis#Computer_representations&quot;&gt;Wikipedia:ellipsis&lt;/a&gt;
 268      * @since JavaFX 2.2
<span class="line-modified"> 269      * @default {@code &quot;...&quot;}</span>
 270      */
 271     public final StringProperty ellipsisStringProperty() {
 272         if (ellipsisString == null) {
 273             ellipsisString = new StyleableStringProperty(DEFAULT_ELLIPSIS_STRING) {
 274                 @Override public Object getBean() {
 275                     return Labeled.this;
 276                 }
 277 
 278                 @Override public String getName() {
 279                     return &quot;ellipsisString&quot;;
 280                 }
 281 
 282                 @Override public CssMetaData&lt;Labeled,String&gt; getCssMetaData() {
 283                     return StyleableProperties.ELLIPSIS_STRING;
 284                 }
 285             };
 286         }
 287         return ellipsisString;
 288     }
 289     private StringProperty ellipsisString;
 290     public final void setEllipsisString(String value) { ellipsisStringProperty().set((value == null) ? &quot;&quot; : value); }
 291     public final String getEllipsisString() { return ellipsisString == null ? DEFAULT_ELLIPSIS_STRING : ellipsisString.get(); }
 292 
 293 
 294     /**
 295      * If a run of text exceeds the width of the Labeled, then this variable
 296      * indicates whether the text should wrap onto another line.
 297      *
 298      * @return the wrap property if a run of text exceeds the width of the Labeled
<span class="line-modified"> 299      * @default {@code false}</span>
 300      */
 301     public final BooleanProperty wrapTextProperty() {
 302         if (wrapText == null) {
 303             wrapText = new StyleableBooleanProperty() {
 304 
 305                 @Override
 306                 public CssMetaData&lt;Labeled,Boolean&gt; getCssMetaData() {
 307                     return StyleableProperties.WRAP_TEXT;
 308                 }
 309 
 310                 @Override
 311                 public Object getBean() {
 312                     return Labeled.this;
 313                 }
 314 
 315                 @Override
 316                 public String getName() {
 317                     return &quot;wrapText&quot;;
 318                 }
 319             };
</pre>
<hr />
<pre>
 322     }
 323     private BooleanProperty wrapText;
 324     public final void setWrapText(boolean value) { wrapTextProperty().setValue(value); }
 325     public final boolean isWrapText() { return wrapText == null ? false : wrapText.getValue(); }
 326 
 327     /**
 328      * If wrapText is true, then contentBias will be HORIZONTAL, otherwise it is null.
 329      * @return orientation of width/height dependency or null if there is none
 330      */
 331     @Override public Orientation getContentBias() {
 332         return isWrapText()? Orientation.HORIZONTAL : null;
 333     }
 334 
 335     /**
 336      * The default font to use for text in the Labeled. If the Label&#39;s text is
 337      * rich text then this font may or may not be used depending on the font
 338      * information embedded in the rich text, but in any case where a default
 339      * font is required, this font will be used.
 340      *
 341      * @return the default font to use for text in this labeled
<span class="line-modified"> 342      * @default {@link Font#getDefault()}</span>
 343      */
 344     public final ObjectProperty&lt;Font&gt; fontProperty() {
 345 
 346         if (font == null) {
 347             font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {
 348 
 349                 private boolean fontSetByCss = false;
 350 
 351                 @Override
 352                 public void applyStyle(StyleOrigin newOrigin, Font value) {
 353 
 354                     //
 355                     // RT-20727 - if CSS is setting the font, then make sure invalidate doesn&#39;t call NodeHelper.reapplyCSS
 356                     //
 357                     try {
 358                         // super.applyStyle calls set which might throw if value is bound.
 359                         // Have to make sure fontSetByCss is reset.
 360                         fontSetByCss = true;
 361                         super.applyStyle(newOrigin, value);
 362                     } catch(Exception e) {
</pre>
<hr />
<pre>
 400                 public String getName() {
 401                     return &quot;font&quot;;
 402                 }
 403             };
 404         }
 405         return font;
 406     }
 407     private ObjectProperty&lt;Font&gt; font;
 408     public final void setFont(Font value) { fontProperty().setValue(value); }
 409     public final Font getFont() { return font == null ? Font.getDefault() : font.getValue(); }
 410 
 411 
 412     /**
 413      * An optional icon for the Labeled. This can be positioned relative to the
 414      * text by using {@link #setContentDisplay}.  The node specified for this
 415      * variable cannot appear elsewhere in the scene graph, otherwise
 416      * the {@code IllegalArgumentException} is thrown.  See the class
 417      * description of {@link Node} for more detail.
 418      *
 419      * @return the optional icon for this labeled
<span class="line-modified"> 420      * @default {@code null}</span>
 421      */
 422     public final ObjectProperty&lt;Node&gt; graphicProperty() {
 423         if (graphic == null) {
 424             graphic = new StyleableObjectProperty&lt;Node&gt;() {
 425 
 426                 // The graphic is styleable by css, but it is the
 427                 // imageUrlProperty that handles the style value.
 428                 @Override
 429                 public CssMetaData getCssMetaData() {
 430                     return StyleableProperties.GRAPHIC;
 431                 }
 432 
 433                 @Override
 434                 public Object getBean() {
 435                     return Labeled.this;
 436                 }
 437 
 438                 @Override
 439                 public String getName() {
 440                     return &quot;graphic&quot;;
</pre>
<hr />
<pre>
 560 
 561                 @Override
 562                 public String getName() {
 563                     return &quot;imageUrl&quot;;
 564                 }
 565 
 566                 @Override
 567                 public CssMetaData&lt;Labeled,String&gt; getCssMetaData() {
 568                     return StyleableProperties.GRAPHIC;
 569                 }
 570 
 571             };
 572         }
 573         return imageUrl;
 574     }
 575 
 576     /**
 577      * Whether all text should be underlined.
 578      *
 579      * @return the underline property of all text in this labeled
<span class="line-modified"> 580      * @default {@code false}</span>
 581      */
 582     public final BooleanProperty underlineProperty() {
 583         if (underline == null) {
 584             underline = new StyleableBooleanProperty(false) {
 585 
 586                 @Override
 587                 public CssMetaData&lt;Labeled, Boolean&gt; getCssMetaData() {
 588                     return StyleableProperties.UNDERLINE;
 589                 }
 590 
 591                 @Override
 592                 public Object getBean() {
 593                     return Labeled.this;
 594                 }
 595 
 596                 @Override
 597                 public String getName() {
 598                     return &quot;underline&quot;;
 599                 }
 600             };
 601         }
 602         return underline;
 603     }
 604     private BooleanProperty underline;
 605     public final void setUnderline(boolean value) { underlineProperty().setValue(value); }
 606     public final boolean isUnderline() { return underline == null ? false : underline.getValue(); }
 607 
 608     /**
 609      * Specifies the space in pixel between lines.
 610      *
 611      * @return the line spacing property between lines in this labeled
 612      * @since JavaFX 8.0
<span class="line-modified"> 613      * @default 0</span>
 614      */
 615     public final DoubleProperty lineSpacingProperty() {
 616         if (lineSpacing == null) {
 617             lineSpacing = new StyleableDoubleProperty(0) {
 618 
 619                 @Override
 620                 public CssMetaData&lt;Labeled,Number&gt; getCssMetaData() {
 621                     return StyleableProperties.LINE_SPACING;
 622                 }
 623 
 624                 @Override
 625                 public Object getBean() {
 626                     return Labeled.this;
 627                 }
 628 
 629                 @Override
 630                 public String getName() {
 631                     return &quot;lineSpacing&quot;;
 632                 }
 633             };
 634         }
 635         return lineSpacing;
 636     }
 637     private DoubleProperty lineSpacing;
 638     public final void setLineSpacing(double value) { lineSpacingProperty().setValue(value); }
 639     public final double getLineSpacing() { return lineSpacing == null ? 0 : lineSpacing.getValue(); }
 640 
 641     /**
 642      * Specifies the positioning of the graphic relative to the text.
 643      *
 644      * @return content display property of this labeled
<span class="line-modified"> 645      * @default {@code ContentDisplay.LEFT}</span>
 646      */
 647     public final ObjectProperty&lt;ContentDisplay&gt; contentDisplayProperty() {
 648         if (contentDisplay == null) {
 649             contentDisplay = new StyleableObjectProperty&lt;ContentDisplay&gt;(ContentDisplay.LEFT) {
 650 
 651                 @Override
 652                 public CssMetaData&lt;Labeled,ContentDisplay&gt; getCssMetaData() {
 653                     return StyleableProperties.CONTENT_DISPLAY;
 654                 }
 655 
 656                 @Override
 657                 public Object getBean() {
 658                     return Labeled.this;
 659                 }
 660 
 661                 @Override
 662                 public String getName() {
 663                     return &quot;contentDisplay&quot;;
 664                 }
 665             };
 666         }
 667         return contentDisplay;
 668     }
 669     private ObjectProperty&lt;ContentDisplay&gt; contentDisplay;
 670     public final void setContentDisplay(ContentDisplay value) { contentDisplayProperty().setValue(value); }
 671     public final ContentDisplay getContentDisplay() { return contentDisplay == null ? ContentDisplay.LEFT : contentDisplay.getValue(); }
 672 
 673     /**
 674      * The padding around the Labeled&#39;s text and graphic content.
 675      * By default labelPadding is Insets.EMPTY and cannot be set to null.
 676      * Subclasses may add nodes outside this padding and inside the Labeled&#39;s padding.
 677      *
 678      * This property can only be set from CSS.
 679      *
 680      * @return the label padding property of this labeled
<span class="line-modified"> 681      * @default {@code Insets.EMPTY}</span>
 682      */
 683     public final ReadOnlyObjectProperty&lt;Insets&gt; labelPaddingProperty() {
 684         return labelPaddingPropertyImpl();
 685     }
 686     private ObjectProperty&lt;Insets&gt; labelPaddingPropertyImpl() {
 687         if (labelPadding == null) {
 688             labelPadding = new StyleableObjectProperty&lt;Insets&gt;(Insets.EMPTY) {
 689                 private Insets lastValidValue = Insets.EMPTY;
 690 
 691                 @Override
 692                 public void invalidated() {
 693                     final Insets newValue = get();
 694                     if (newValue == null) {
 695                         set(lastValidValue);
 696                         throw new NullPointerException(&quot;cannot set labelPadding to null&quot;);
 697                     }
 698                     lastValidValue = newValue;
 699                     requestLayout();
 700                 }
 701 
</pre>
<hr />
<pre>
 708                 public Object getBean() {
 709                     return Labeled.this;
 710                 }
 711 
 712                 @Override
 713                 public String getName() {
 714                     return &quot;labelPadding&quot;;
 715                 }
 716             };
 717         }
 718         return labelPadding;
 719     }
 720     private ObjectProperty&lt;Insets&gt; labelPadding;
 721     private void setLabelPadding(Insets value) { labelPaddingPropertyImpl().set(value); }
 722     public final Insets getLabelPadding() { return labelPadding == null ? Insets.EMPTY : labelPadding.get(); }
 723 
 724     /**
 725      * The amount of space between the graphic and text
 726      *
 727      * @return the graphics text gap property of this labeled
<span class="line-modified"> 728      * @default 4</span>
 729      */
 730     public final DoubleProperty graphicTextGapProperty() {
 731         if (graphicTextGap == null) {
 732             graphicTextGap = new StyleableDoubleProperty(4) {
 733 
 734                 @Override
 735                 public CssMetaData&lt;Labeled,Number&gt; getCssMetaData() {
 736                     return StyleableProperties.GRAPHIC_TEXT_GAP;
 737                 }
 738 
 739                 @Override
 740                 public Object getBean() {
 741                     return Labeled.this;
 742                 }
 743 
 744                 @Override
 745                 public String getName() {
 746                     return &quot;graphicTextGap&quot;;
 747                 }
 748             };
 749         }
 750         return graphicTextGap;
 751     }
 752     private DoubleProperty graphicTextGap;
 753     public final void setGraphicTextGap(double value) { graphicTextGapProperty().setValue(value); }
 754     public final double getGraphicTextGap() { return graphicTextGap == null ? 4 : graphicTextGap.getValue(); }
 755 
 756 
 757     /**
 758      * The {@link Paint} used to fill the text.
 759      *
<span class="line-modified"> 760      * @default {@code Color.BLACK}</span>
 761      */
 762     private ObjectProperty&lt;Paint&gt; textFill; // TODO for now change this
 763 
 764     public final void setTextFill(Paint value) {
 765         textFillProperty().set(value);
 766     }
 767 
 768     public final Paint getTextFill() {
 769         return textFill == null ? Color.BLACK : textFill.get();
 770     }
 771 
 772     public final ObjectProperty&lt;Paint&gt; textFillProperty() {
 773         if (textFill == null) {
 774             textFill = new StyleableObjectProperty&lt;Paint&gt;(Color.BLACK) {
 775 
 776                 @Override
 777                 public CssMetaData&lt;Labeled,Paint&gt; getCssMetaData() {
 778                     return StyleableProperties.TEXT_FILL;
 779                 }
 780 
</pre>
<hr />
<pre>
 784                 }
 785 
 786                 @Override
 787                 public String getName() {
 788                     return &quot;textFill&quot;;
 789                 }
 790             };
 791         }
 792         return textFill;
 793     }
 794 
 795 
 796     /**
 797      * MnemonicParsing property to enable/disable text parsing.
 798      * If this is set to true, then the Label text will be
 799      * parsed to see if it contains the mnemonic parsing character &#39;_&#39;.
 800      * When a mnemonic is detected the key combination will
 801      * be determined based on the succeeding character, and the mnemonic
 802      * added.
 803      *
<span class="line-modified"> 804      * @default {@code false}; {@code true} for some Controls.</span>
<span class="line-removed"> 805      * &lt;/p&gt;</span>
 806      */
 807     private BooleanProperty mnemonicParsing;
 808     public final void setMnemonicParsing(boolean value) {
 809         mnemonicParsingProperty().set(value);
 810     }
 811     public final boolean isMnemonicParsing() {
 812         return mnemonicParsing == null ? false : mnemonicParsing.get();
 813     }
 814     public final BooleanProperty mnemonicParsingProperty() {
 815         if (mnemonicParsing == null) {
 816             mnemonicParsing = new SimpleBooleanProperty(this, &quot;mnemonicParsing&quot;);
 817         }
 818         return mnemonicParsing;
 819     }
 820 
 821     //    /**
 822     //     * This is the symbol that is searched for in the text and used as
 823     //     * a mnemonic. You can change what symbol is used. Using the symbol
 824     //     * more than once will cause the symbol to be escaped. Thus, if &quot;_&quot;
 825     //     * (the default) is used, then the string &quot;H_ello World&quot; will use
</pre>
</td>
<td>
<hr />
<pre>
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control;
  27 

  28 import com.sun.javafx.css.StyleManager;
  29 import com.sun.javafx.scene.NodeHelper;
  30 import javafx.css.converter.BooleanConverter;
  31 import javafx.css.converter.EnumConverter;
  32 import javafx.css.converter.InsetsConverter;
  33 import javafx.css.converter.PaintConverter;
  34 import javafx.css.converter.SizeConverter;
  35 import javafx.css.converter.StringConverter;
  36 
  37 import java.util.ArrayList;
  38 import java.util.Collections;
  39 import java.util.List;
  40 
  41 import javafx.beans.property.BooleanProperty;
  42 import javafx.beans.property.DoubleProperty;
  43 import javafx.beans.property.ObjectProperty;
  44 import javafx.beans.property.ReadOnlyObjectProperty;
  45 import javafx.beans.property.SimpleBooleanProperty;
  46 import javafx.beans.property.SimpleStringProperty;
  47 import javafx.beans.property.StringProperty;
</pre>
<hr />
<pre>
  50 import javafx.geometry.Orientation;
  51 import javafx.geometry.Pos;
  52 import javafx.scene.Node;
  53 import javafx.scene.image.Image;
  54 import javafx.scene.image.ImageView;
  55 import javafx.scene.paint.Color;
  56 import javafx.scene.paint.Paint;
  57 import javafx.scene.text.Font;
  58 import javafx.scene.text.TextAlignment;
  59 import javafx.beans.DefaultProperty;
  60 import javafx.css.CssMetaData;
  61 import javafx.css.FontCssMetaData;
  62 import javafx.css.StyleOrigin;
  63 import javafx.css.Styleable;
  64 import javafx.css.StyleableBooleanProperty;
  65 import javafx.css.StyleableDoubleProperty;
  66 import javafx.css.StyleableObjectProperty;
  67 import javafx.css.StyleableProperty;
  68 import javafx.css.StyleableStringProperty;
  69 

  70 /**
  71  * A Labeled {@link Control} is one which has as part of its user interface
  72  * a textual content associated with it. For example, a {@link Button} displays
  73  * {@code text}, as does a {@link Label}, a {@link Tooltip}, and many
  74  * other controls.
  75  * &lt;p&gt;
  76  * Labeled is also a convenient base class from which to extend when building
  77  * new Controls which, as part of their UI, display read-only textual content.
  78  * &lt;/p&gt;
  79  *
  80  * &lt;p&gt;Example of how to place a graphic above the text:
  81  * &lt;pre&gt;&lt;code&gt;
  82  *  Image image = new Image(getClass().getResourceAsStream(&quot;image.png&quot;));
  83  *  ImageView imageView = new ImageView();
  84  *  imageView.setImage(image);
  85  *  Label label = new Label(&quot;text&quot;, imageView);
  86  *  label.setContentDisplay(ContentDisplay.TOP);
  87  * &lt;/code&gt;&lt;/pre&gt;
  88  *
  89  * @see Button
</pre>
<hr />
<pre>
 118 
 119     /**
 120      * Creates a Label with text and a graphic
 121      * @param text The text for the label.
 122      * @param graphic The graphic for the label.
 123      */
 124     public Labeled(String text, Node graphic) {
 125         setText(text);
 126         ((StyleableProperty&lt;Node&gt;)(WritableValue&lt;Node&gt;)graphicProperty()).applyStyle(null, graphic);
 127     }
 128 
 129     /***************************************************************************
 130      *                                                                         *
 131      * Properties                                                              *
 132      *                                                                         *
 133      **************************************************************************/
 134     /**
 135      * The text to display in the label. The text may be null.
 136      *
 137      * @return the text to display in the label
<span class="line-modified"> 138      * @defaultValue {@code &quot;&quot;} (empty string}</span>
 139      */
 140     public final StringProperty textProperty() {
 141         if (text == null) {
 142             text = new SimpleStringProperty(this, &quot;text&quot;, &quot;&quot;);
 143         }
 144         return text;
 145     }
 146     private StringProperty text;
 147     public final void setText(String value) { textProperty().setValue(value); }
 148     public final String getText() { return text == null ? &quot;&quot; : text.getValue(); }
 149 
 150     /**
 151      * Specifies how the text and graphic within the Labeled should be
 152      * aligned when there is empty space within the Labeled.
<span class="line-added"> 153      *</span>
 154      * @return the alignment within this labeled
<span class="line-added"> 155      * @defaultValue {@code Pos.CENTER_LEFT}</span>
 156      */
 157     public final ObjectProperty&lt;Pos&gt; alignmentProperty() {
 158         if (alignment == null) {
 159             alignment = new StyleableObjectProperty&lt;Pos&gt;(Pos.CENTER_LEFT) {
 160 
 161                 @Override public CssMetaData&lt;Labeled,Pos&gt; getCssMetaData() {
 162                     return StyleableProperties.ALIGNMENT;
 163                 }
 164 
 165                 @Override
 166                 public Object getBean() {
 167                     return Labeled.this;
 168                 }
 169 
 170                 @Override
 171                 public String getName() {
 172                     return &quot;alignment&quot;;
 173                 }
 174             };
 175         }
 176         return alignment;
 177     }
 178     private ObjectProperty&lt;Pos&gt; alignment;
 179     public final void setAlignment(Pos value) { alignmentProperty().set(value); }
 180     public final Pos getAlignment() { return alignment == null ? Pos.CENTER_LEFT : alignment.get(); }
 181 
 182 
 183     /**
 184      * Specifies the behavior for lines of text &lt;em&gt;when text is multiline&lt;/em&gt;.
 185      * Unlike {@link #contentDisplayProperty} which affects the graphic and text, this setting
 186      * only affects multiple lines of text relative to the text bounds.
 187      *
 188      * @return the alignment of lines of text within this labeled
<span class="line-modified"> 189      * @defaultValue {@code TextAlignment.LEFT}</span>
 190      */
 191     public final ObjectProperty&lt;TextAlignment&gt; textAlignmentProperty() {
 192         if (textAlignment == null) {
 193             textAlignment = new StyleableObjectProperty&lt;TextAlignment&gt;(TextAlignment.LEFT) {
 194 
 195                 @Override
 196                 public CssMetaData&lt;Labeled,TextAlignment&gt; getCssMetaData() {
 197                     return StyleableProperties.TEXT_ALIGNMENT;
 198                 }
 199 
 200                 @Override
 201                 public Object getBean() {
 202                     return Labeled.this;
 203                 }
 204 
 205                 @Override
 206                 public String getName() {
 207                     return &quot;textAlignment&quot;;
 208                 }
 209             };
 210         }
 211         return textAlignment;
 212     }
 213     private ObjectProperty&lt;TextAlignment&gt; textAlignment;
 214     public final void setTextAlignment(TextAlignment value) { textAlignmentProperty().setValue(value); }
 215     public final TextAlignment getTextAlignment() { return textAlignment == null ? TextAlignment.LEFT : textAlignment.getValue(); }
 216 
 217     /**
 218      * Specifies the behavior to use if the text of the {@code Labeled}
 219      * exceeds the available space for rendering the text.
 220      *
 221      * @return the overrun behavior if the text exceeds the available space
<span class="line-modified"> 222      * @defaultValue {@code OverrunStyle.ELLIPSIS}</span>
 223      */
 224     public final ObjectProperty&lt;OverrunStyle&gt; textOverrunProperty() {
 225         if (textOverrun == null) {
 226             textOverrun = new StyleableObjectProperty&lt;OverrunStyle&gt;(OverrunStyle.ELLIPSIS) {
 227 
 228                 @Override
 229                 public CssMetaData&lt;Labeled,OverrunStyle&gt; getCssMetaData() {
 230                     return StyleableProperties.TEXT_OVERRUN;
 231                 }
 232 
 233                 @Override
 234                 public Object getBean() {
 235                     return Labeled.this;
 236                 }
 237 
 238                 @Override
 239                 public String getName() {
 240                     return &quot;textOverrun&quot;;
 241                 }
 242             };
</pre>
<hr />
<pre>
 249 
 250     /**
 251      * Specifies the string to display for the ellipsis when text is truncated.
 252      *
 253      * &lt;table&gt;
 254      *   &lt;caption&gt;Ellipsis Table&lt;/caption&gt;
 255      *   &lt;tr&gt;&lt;th scope=&quot;col&quot; colspan=2&gt;Examples&lt;/th&gt;&lt;/tr&gt;
 256      *   &lt;tr class=&quot;altColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot;...&quot; &lt;/th&gt;        &lt;td&gt;Default value for most locales&lt;/td&gt;
 257      *   &lt;tr class=&quot;rowColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot; . . . &quot; &lt;/th&gt;    &lt;td&gt;&lt;/td&gt;
 258      *   &lt;tr class=&quot;altColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot; [...] &quot; &lt;/th&gt;    &lt;td&gt;&lt;/td&gt;
 259      *   &lt;tr class=&quot;rowColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot;&amp;#92;u2026&quot; &lt;/th&gt; &lt;td&gt;The Unicode ellipsis character &#39;&amp;hellip;&#39;&lt;/td&gt;
 260      *   &lt;tr class=&quot;altColor&quot;&gt;&lt;th scope=&quot;row&quot;&gt;&quot;&quot; &lt;/th&gt;           &lt;td&gt;No ellipsis, just display the truncated string&lt;/td&gt;
 261      * &lt;/table&gt;
 262      *
 263      * &lt;p&gt;Note that not all fonts support all Unicode characters.
 264      *
 265      * @return the ellipsis property on the string to display for the ellipsis
 266      * when text is truncated
 267      * @see &lt;a href=&quot;http://en.wikipedia.org/wiki/Ellipsis#Computer_representations&quot;&gt;Wikipedia:ellipsis&lt;/a&gt;
 268      * @since JavaFX 2.2
<span class="line-modified"> 269      * @defaultValue {@code &quot;...&quot;}</span>
 270      */
 271     public final StringProperty ellipsisStringProperty() {
 272         if (ellipsisString == null) {
 273             ellipsisString = new StyleableStringProperty(DEFAULT_ELLIPSIS_STRING) {
 274                 @Override public Object getBean() {
 275                     return Labeled.this;
 276                 }
 277 
 278                 @Override public String getName() {
 279                     return &quot;ellipsisString&quot;;
 280                 }
 281 
 282                 @Override public CssMetaData&lt;Labeled,String&gt; getCssMetaData() {
 283                     return StyleableProperties.ELLIPSIS_STRING;
 284                 }
 285             };
 286         }
 287         return ellipsisString;
 288     }
 289     private StringProperty ellipsisString;
 290     public final void setEllipsisString(String value) { ellipsisStringProperty().set((value == null) ? &quot;&quot; : value); }
 291     public final String getEllipsisString() { return ellipsisString == null ? DEFAULT_ELLIPSIS_STRING : ellipsisString.get(); }
 292 
 293 
 294     /**
 295      * If a run of text exceeds the width of the Labeled, then this variable
 296      * indicates whether the text should wrap onto another line.
 297      *
 298      * @return the wrap property if a run of text exceeds the width of the Labeled
<span class="line-modified"> 299      * @defaultValue {@code false}</span>
 300      */
 301     public final BooleanProperty wrapTextProperty() {
 302         if (wrapText == null) {
 303             wrapText = new StyleableBooleanProperty() {
 304 
 305                 @Override
 306                 public CssMetaData&lt;Labeled,Boolean&gt; getCssMetaData() {
 307                     return StyleableProperties.WRAP_TEXT;
 308                 }
 309 
 310                 @Override
 311                 public Object getBean() {
 312                     return Labeled.this;
 313                 }
 314 
 315                 @Override
 316                 public String getName() {
 317                     return &quot;wrapText&quot;;
 318                 }
 319             };
</pre>
<hr />
<pre>
 322     }
 323     private BooleanProperty wrapText;
 324     public final void setWrapText(boolean value) { wrapTextProperty().setValue(value); }
 325     public final boolean isWrapText() { return wrapText == null ? false : wrapText.getValue(); }
 326 
 327     /**
 328      * If wrapText is true, then contentBias will be HORIZONTAL, otherwise it is null.
 329      * @return orientation of width/height dependency or null if there is none
 330      */
 331     @Override public Orientation getContentBias() {
 332         return isWrapText()? Orientation.HORIZONTAL : null;
 333     }
 334 
 335     /**
 336      * The default font to use for text in the Labeled. If the Label&#39;s text is
 337      * rich text then this font may or may not be used depending on the font
 338      * information embedded in the rich text, but in any case where a default
 339      * font is required, this font will be used.
 340      *
 341      * @return the default font to use for text in this labeled
<span class="line-modified"> 342      * @defaultValue {@link Font#getDefault()}</span>
 343      */
 344     public final ObjectProperty&lt;Font&gt; fontProperty() {
 345 
 346         if (font == null) {
 347             font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {
 348 
 349                 private boolean fontSetByCss = false;
 350 
 351                 @Override
 352                 public void applyStyle(StyleOrigin newOrigin, Font value) {
 353 
 354                     //
 355                     // RT-20727 - if CSS is setting the font, then make sure invalidate doesn&#39;t call NodeHelper.reapplyCSS
 356                     //
 357                     try {
 358                         // super.applyStyle calls set which might throw if value is bound.
 359                         // Have to make sure fontSetByCss is reset.
 360                         fontSetByCss = true;
 361                         super.applyStyle(newOrigin, value);
 362                     } catch(Exception e) {
</pre>
<hr />
<pre>
 400                 public String getName() {
 401                     return &quot;font&quot;;
 402                 }
 403             };
 404         }
 405         return font;
 406     }
 407     private ObjectProperty&lt;Font&gt; font;
 408     public final void setFont(Font value) { fontProperty().setValue(value); }
 409     public final Font getFont() { return font == null ? Font.getDefault() : font.getValue(); }
 410 
 411 
 412     /**
 413      * An optional icon for the Labeled. This can be positioned relative to the
 414      * text by using {@link #setContentDisplay}.  The node specified for this
 415      * variable cannot appear elsewhere in the scene graph, otherwise
 416      * the {@code IllegalArgumentException} is thrown.  See the class
 417      * description of {@link Node} for more detail.
 418      *
 419      * @return the optional icon for this labeled
<span class="line-modified"> 420      * @defaultValue {@code null}</span>
 421      */
 422     public final ObjectProperty&lt;Node&gt; graphicProperty() {
 423         if (graphic == null) {
 424             graphic = new StyleableObjectProperty&lt;Node&gt;() {
 425 
 426                 // The graphic is styleable by css, but it is the
 427                 // imageUrlProperty that handles the style value.
 428                 @Override
 429                 public CssMetaData getCssMetaData() {
 430                     return StyleableProperties.GRAPHIC;
 431                 }
 432 
 433                 @Override
 434                 public Object getBean() {
 435                     return Labeled.this;
 436                 }
 437 
 438                 @Override
 439                 public String getName() {
 440                     return &quot;graphic&quot;;
</pre>
<hr />
<pre>
 560 
 561                 @Override
 562                 public String getName() {
 563                     return &quot;imageUrl&quot;;
 564                 }
 565 
 566                 @Override
 567                 public CssMetaData&lt;Labeled,String&gt; getCssMetaData() {
 568                     return StyleableProperties.GRAPHIC;
 569                 }
 570 
 571             };
 572         }
 573         return imageUrl;
 574     }
 575 
 576     /**
 577      * Whether all text should be underlined.
 578      *
 579      * @return the underline property of all text in this labeled
<span class="line-modified"> 580      * @defaultValue {@code false}</span>
 581      */
 582     public final BooleanProperty underlineProperty() {
 583         if (underline == null) {
 584             underline = new StyleableBooleanProperty(false) {
 585 
 586                 @Override
 587                 public CssMetaData&lt;Labeled, Boolean&gt; getCssMetaData() {
 588                     return StyleableProperties.UNDERLINE;
 589                 }
 590 
 591                 @Override
 592                 public Object getBean() {
 593                     return Labeled.this;
 594                 }
 595 
 596                 @Override
 597                 public String getName() {
 598                     return &quot;underline&quot;;
 599                 }
 600             };
 601         }
 602         return underline;
 603     }
 604     private BooleanProperty underline;
 605     public final void setUnderline(boolean value) { underlineProperty().setValue(value); }
 606     public final boolean isUnderline() { return underline == null ? false : underline.getValue(); }
 607 
 608     /**
 609      * Specifies the space in pixel between lines.
 610      *
 611      * @return the line spacing property between lines in this labeled
 612      * @since JavaFX 8.0
<span class="line-modified"> 613      * @defaultValue 0</span>
 614      */
 615     public final DoubleProperty lineSpacingProperty() {
 616         if (lineSpacing == null) {
 617             lineSpacing = new StyleableDoubleProperty(0) {
 618 
 619                 @Override
 620                 public CssMetaData&lt;Labeled,Number&gt; getCssMetaData() {
 621                     return StyleableProperties.LINE_SPACING;
 622                 }
 623 
 624                 @Override
 625                 public Object getBean() {
 626                     return Labeled.this;
 627                 }
 628 
 629                 @Override
 630                 public String getName() {
 631                     return &quot;lineSpacing&quot;;
 632                 }
 633             };
 634         }
 635         return lineSpacing;
 636     }
 637     private DoubleProperty lineSpacing;
 638     public final void setLineSpacing(double value) { lineSpacingProperty().setValue(value); }
 639     public final double getLineSpacing() { return lineSpacing == null ? 0 : lineSpacing.getValue(); }
 640 
 641     /**
 642      * Specifies the positioning of the graphic relative to the text.
 643      *
 644      * @return content display property of this labeled
<span class="line-modified"> 645      * @defaultValue {@code ContentDisplay.LEFT}</span>
 646      */
 647     public final ObjectProperty&lt;ContentDisplay&gt; contentDisplayProperty() {
 648         if (contentDisplay == null) {
 649             contentDisplay = new StyleableObjectProperty&lt;ContentDisplay&gt;(ContentDisplay.LEFT) {
 650 
 651                 @Override
 652                 public CssMetaData&lt;Labeled,ContentDisplay&gt; getCssMetaData() {
 653                     return StyleableProperties.CONTENT_DISPLAY;
 654                 }
 655 
 656                 @Override
 657                 public Object getBean() {
 658                     return Labeled.this;
 659                 }
 660 
 661                 @Override
 662                 public String getName() {
 663                     return &quot;contentDisplay&quot;;
 664                 }
 665             };
 666         }
 667         return contentDisplay;
 668     }
 669     private ObjectProperty&lt;ContentDisplay&gt; contentDisplay;
 670     public final void setContentDisplay(ContentDisplay value) { contentDisplayProperty().setValue(value); }
 671     public final ContentDisplay getContentDisplay() { return contentDisplay == null ? ContentDisplay.LEFT : contentDisplay.getValue(); }
 672 
 673     /**
 674      * The padding around the Labeled&#39;s text and graphic content.
 675      * By default labelPadding is Insets.EMPTY and cannot be set to null.
 676      * Subclasses may add nodes outside this padding and inside the Labeled&#39;s padding.
 677      *
 678      * This property can only be set from CSS.
 679      *
 680      * @return the label padding property of this labeled
<span class="line-modified"> 681      * @defaultValue {@code Insets.EMPTY}</span>
 682      */
 683     public final ReadOnlyObjectProperty&lt;Insets&gt; labelPaddingProperty() {
 684         return labelPaddingPropertyImpl();
 685     }
 686     private ObjectProperty&lt;Insets&gt; labelPaddingPropertyImpl() {
 687         if (labelPadding == null) {
 688             labelPadding = new StyleableObjectProperty&lt;Insets&gt;(Insets.EMPTY) {
 689                 private Insets lastValidValue = Insets.EMPTY;
 690 
 691                 @Override
 692                 public void invalidated() {
 693                     final Insets newValue = get();
 694                     if (newValue == null) {
 695                         set(lastValidValue);
 696                         throw new NullPointerException(&quot;cannot set labelPadding to null&quot;);
 697                     }
 698                     lastValidValue = newValue;
 699                     requestLayout();
 700                 }
 701 
</pre>
<hr />
<pre>
 708                 public Object getBean() {
 709                     return Labeled.this;
 710                 }
 711 
 712                 @Override
 713                 public String getName() {
 714                     return &quot;labelPadding&quot;;
 715                 }
 716             };
 717         }
 718         return labelPadding;
 719     }
 720     private ObjectProperty&lt;Insets&gt; labelPadding;
 721     private void setLabelPadding(Insets value) { labelPaddingPropertyImpl().set(value); }
 722     public final Insets getLabelPadding() { return labelPadding == null ? Insets.EMPTY : labelPadding.get(); }
 723 
 724     /**
 725      * The amount of space between the graphic and text
 726      *
 727      * @return the graphics text gap property of this labeled
<span class="line-modified"> 728      * @defaultValue 4</span>
 729      */
 730     public final DoubleProperty graphicTextGapProperty() {
 731         if (graphicTextGap == null) {
 732             graphicTextGap = new StyleableDoubleProperty(4) {
 733 
 734                 @Override
 735                 public CssMetaData&lt;Labeled,Number&gt; getCssMetaData() {
 736                     return StyleableProperties.GRAPHIC_TEXT_GAP;
 737                 }
 738 
 739                 @Override
 740                 public Object getBean() {
 741                     return Labeled.this;
 742                 }
 743 
 744                 @Override
 745                 public String getName() {
 746                     return &quot;graphicTextGap&quot;;
 747                 }
 748             };
 749         }
 750         return graphicTextGap;
 751     }
 752     private DoubleProperty graphicTextGap;
 753     public final void setGraphicTextGap(double value) { graphicTextGapProperty().setValue(value); }
 754     public final double getGraphicTextGap() { return graphicTextGap == null ? 4 : graphicTextGap.getValue(); }
 755 
 756 
 757     /**
 758      * The {@link Paint} used to fill the text.
 759      *
<span class="line-modified"> 760      * @defaultValue {@code Color.BLACK}</span>
 761      */
 762     private ObjectProperty&lt;Paint&gt; textFill; // TODO for now change this
 763 
 764     public final void setTextFill(Paint value) {
 765         textFillProperty().set(value);
 766     }
 767 
 768     public final Paint getTextFill() {
 769         return textFill == null ? Color.BLACK : textFill.get();
 770     }
 771 
 772     public final ObjectProperty&lt;Paint&gt; textFillProperty() {
 773         if (textFill == null) {
 774             textFill = new StyleableObjectProperty&lt;Paint&gt;(Color.BLACK) {
 775 
 776                 @Override
 777                 public CssMetaData&lt;Labeled,Paint&gt; getCssMetaData() {
 778                     return StyleableProperties.TEXT_FILL;
 779                 }
 780 
</pre>
<hr />
<pre>
 784                 }
 785 
 786                 @Override
 787                 public String getName() {
 788                     return &quot;textFill&quot;;
 789                 }
 790             };
 791         }
 792         return textFill;
 793     }
 794 
 795 
 796     /**
 797      * MnemonicParsing property to enable/disable text parsing.
 798      * If this is set to true, then the Label text will be
 799      * parsed to see if it contains the mnemonic parsing character &#39;_&#39;.
 800      * When a mnemonic is detected the key combination will
 801      * be determined based on the succeeding character, and the mnemonic
 802      * added.
 803      *
<span class="line-modified"> 804      * @defaultValue {@code false}; {@code true} for some Controls.</span>

 805      */
 806     private BooleanProperty mnemonicParsing;
 807     public final void setMnemonicParsing(boolean value) {
 808         mnemonicParsingProperty().set(value);
 809     }
 810     public final boolean isMnemonicParsing() {
 811         return mnemonicParsing == null ? false : mnemonicParsing.get();
 812     }
 813     public final BooleanProperty mnemonicParsingProperty() {
 814         if (mnemonicParsing == null) {
 815             mnemonicParsing = new SimpleBooleanProperty(this, &quot;mnemonicParsing&quot;);
 816         }
 817         return mnemonicParsing;
 818     }
 819 
 820     //    /**
 821     //     * This is the symbol that is searched for in the text and used as
 822     //     * a mnemonic. You can change what symbol is used. Using the symbol
 823     //     * more than once will cause the symbol to be escaped. Thus, if &quot;_&quot;
 824     //     * (the default) is used, then the string &quot;H_ello World&quot; will use
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Pagination.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
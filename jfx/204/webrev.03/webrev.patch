diff a/modules/javafx.base/src/test/java/test/util/memory/JMemoryBuddy.java b/modules/javafx.base/src/test/java/test/util/memory/JMemoryBuddy.java
--- /dev/null
+++ b/modules/javafx.base/src/test/java/test/util/memory/JMemoryBuddy.java
@@ -0,0 +1,299 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package test.util.memory;
+
+import com.sun.management.HotSpotDiagnosticMXBean;
+import javax.management.MBeanServer;
+import java.io.File;
+import java.io.IOException;
+import java.lang.management.ManagementFactory;
+import java.lang.ref.WeakReference;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.LinkedList;
+import java.util.function.Consumer;
+import java.util.function.Function;
+
+
+/**
+ * Checkout <a href="https://github.com/Sandec/JMemoryBuddy">https://github.com/Sandec/JMemoryBuddy</a> for more documentation.
+ */
+public class JMemoryBuddy {
+
+    private static int steps = 10;
+    private static int overallTime = 1000;
+    private static int sleepTime = overallTime / steps;
+    private static boolean createHeapdump = false;
+    private static int garbageAmount = 999999;
+    private static String MX_BEAN_PROXY_TYPE = "com.sun.management:type=HotSpotDiagnostic";
+    private static String outputFolderString = ".";
+
+    static {
+        outputFolderString = System.getProperty("jmemorybuddy.output",".");
+        overallTime = Integer.parseInt(System.getProperty("jmemorybuddy.checktime","1000"));
+        steps = Integer.parseInt(System.getProperty("jmemorybuddy.steps", "10"));
+        createHeapdump = Boolean.parseBoolean(System.getProperty("jmemorybuddy.createHeapdump", "false"));
+        garbageAmount = Integer.parseInt(System.getProperty("jmemorybuddy.garbageAmount", "10"));
+    }
+
+    static void createGarbage() {
+        LinkedList list = new LinkedList<Integer>();
+        int counter = 0;
+        while(counter < garbageAmount) {
+            counter += 1;
+            list.add(1);
+        }
+    }
+
+    /**
+     * Checks whether the content of the WeakReference can be collected.
+     * @param weakReference The WeakReference to check.
+     */
+    public static void assertCollectable(WeakReference weakReference) {
+        if(!checkCollectable(weakReference)) {
+            AssertCollectable assertCollectable = new AssertCollectable(weakReference);
+            createHeapDump();
+            throw new AssertionError("Content of WeakReference was not collected. content: " + weakReference.get());
+        }
+    }
+
+    /**
+     * Checks whether the content of the WeakReference can be collected.
+     * @param weakReference The WeakReference to check.
+     * @return Returns true, when the provided WeakReference can be collected.
+     */
+    public static boolean checkCollectable(WeakReference weakReference) {
+        return checkCollectable(steps, weakReference) > 0;
+    }
+
+    private static int checkCollectable(int stepsLeft, WeakReference weakReference) {
+        int counter = stepsLeft;
+
+        if(weakReference.get() != null) {
+            createGarbage();
+            System.gc();
+            System.runFinalization();
+        }
+
+        while(counter > 0 && weakReference.get() != null) {
+            try {
+                Thread.sleep(sleepTime);
+            } catch (InterruptedException e) {}
+            counter = counter - 1;
+            createGarbage();
+            System.gc();
+            System.runFinalization();
+        }
+
+        if(weakReference.get() == null && counter < steps / 3) {
+            int percentageUsed = (int) ((steps - counter) / steps * 100);
+            System.out.println("Warning test seems to be unstable. time used: " + percentageUsed + "%");
+        }
+
+        return counter;
+    }
+
+    /**
+     * Checks whether the content of the WeakReference can not be collected.
+     * @param weakReference The WeakReference to check.
+     */
+    public static void assertNotCollectable(WeakReference weakReference) {
+        if(!checkNotCollectable(weakReference)) {
+            throw new AssertionError("Content of WeakReference was collected!");
+        }
+    }
+
+    /**
+     * Checks whether the content of the WeakReference can not be collected.
+     * @param weakReference The WeakReference to check.
+     * @return Returns true, when the provided WeakReference can be collected.
+     */
+    public static boolean checkNotCollectable(WeakReference weakReference) {
+        createGarbage();
+        System.gc();
+        return weakReference.get() != null;
+    }
+
+    /**
+     * A standard method to define a test which checks code for specific memory semantic.
+     * The parameter of the lambda provides an API to define the required memory semantic.
+     * @param f A function which get's executed with the API to define the required memory semantic.
+     */
+    public static void memoryTest(Consumer<MemoryTestAPI> f) {
+        LinkedList<WeakReference> toBeCollected = new LinkedList<WeakReference>();
+        LinkedList<AssertNotCollectable> toBeNotCollected = new LinkedList<AssertNotCollectable>();
+        LinkedList<SetAsReferenced> toBeReferenced = new LinkedList<SetAsReferenced>();
+
+        f.accept(new MemoryTestAPI() {
+            public void assertCollectable(Object ref) {
+                if(ref == null) throw new NullPointerException();
+                toBeCollected.add(new WeakReference<Object>(ref));
+            }
+            public void assertNotCollectable(Object ref) {
+                if(ref == null) throw new NullPointerException();
+                toBeNotCollected.add(new AssertNotCollectable(ref));
+            }
+            public void setAsReferenced(Object ref) {
+                if(ref == null) throw new NullPointerException();
+                toBeReferenced.add(new SetAsReferenced(ref));
+            }
+        });
+
+        int stepsLeft = steps;
+        boolean failed = false;
+
+        for(WeakReference wRef: toBeCollected) {
+            stepsLeft = checkCollectable(stepsLeft, wRef);
+        }
+        if(stepsLeft == 0) {
+            failed = true;
+        }
+        for(AssertNotCollectable wRef: toBeNotCollected) {
+            if(!checkNotCollectable(wRef.getWeakReference())) {
+                failed = true;
+            };
+        }
+
+        if(failed) {
+            LinkedList<AssertCollectable> toBeCollectedMarked = new LinkedList<AssertCollectable>();
+            LinkedList<AssertNotCollectable> toBeNotCollectedMarked = new LinkedList<AssertNotCollectable>();
+
+            for(WeakReference wRef: toBeCollected) {
+                if(wRef.get() != null) {
+                    toBeCollectedMarked.add(new AssertCollectable(wRef));
+                }
+            }
+            for(AssertNotCollectable wRef: toBeNotCollected) {
+                if(wRef.getWeakReference().get() == null) {
+                    toBeNotCollectedMarked.add(wRef);
+                }
+            }
+            createHeapDump();
+            if(toBeNotCollectedMarked.isEmpty()) {
+                throw new AssertionError("The following references should be collected: " + toBeCollectedMarked);
+            } else {
+                throw new AssertionError("The following references should be collected: " + toBeCollectedMarked + " and " + toBeNotCollected.size() + " should not be collected: " + toBeNotCollectedMarked);
+            }
+        }
+
+
+    }
+
+
+    static void createHeapDump() {
+        if(createHeapdump) {
+            try {
+                String dateString = new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss").format(new Date());
+                String fileName = "heapdump_jmemb_" + dateString + ".hprof";
+                File outputFolder = new File(outputFolderString);
+                String heapdumpFile = new java.io.File(outputFolder, fileName).getAbsolutePath();
+                System.out.println("Creating Heapdump at: " + heapdumpFile);
+                getHotspotMBean().dumpHeap(heapdumpFile, true);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        } else {
+            System.out.println("No Heapdump was created. You might want to change the configuration to get a HeapDump.");
+        }
+    }
+
+    private static void setMxBeanProxyName(String mxBeanName) {
+        MX_BEAN_PROXY_TYPE = mxBeanName;
+    }
+
+    private static HotSpotDiagnosticMXBean getHotspotMBean() throws IOException {
+        MBeanServer server = ManagementFactory.getPlatformMBeanServer();
+        HotSpotDiagnosticMXBean bean =
+                ManagementFactory.newPlatformMXBeanProxy(server,
+                        MX_BEAN_PROXY_TYPE, HotSpotDiagnosticMXBean.class);
+        return bean;
+    }
+
+    public static interface MemoryTestAPI {
+        /**
+         * After executing the lambda, the provided ref must be collectable. Otherwise an Exception is thrown.
+         * @param ref The reference which should be collectable.
+         */
+        public void assertCollectable(Object ref);
+        /**
+         * After executing the lambda, the provided ref must be not collectable. Otherwise an Exception is thrown.
+         * @param ref The reference which should not be collectable.
+         */
+        public void assertNotCollectable(Object ref);
+
+        /**
+         * The provided reference will be reference hard, so it won't be collected, until memoryTest finishes.
+         * @param ref The reference which should get a hard reference for this test.
+         */
+        public void setAsReferenced(Object ref);
+    }
+
+    static class AssertCollectable {
+        WeakReference<Object> assertCollectable;
+
+        AssertCollectable(WeakReference<Object> ref) {
+            this.assertCollectable = ref;
+        }
+
+        WeakReference<Object> getWeakReference() {
+            return assertCollectable;
+        }
+
+        @Override
+        public String toString() {
+            Object el = assertCollectable.get();
+            return el != null ? el.toString() : "null";
+        }
+    }
+
+    private static class AssertNotCollectable {
+        WeakReference<Object> assertNotCollectable;
+        String originalResultOfToString;
+
+        AssertNotCollectable(Object ref) {
+            this.assertNotCollectable = new WeakReference<>(ref);
+            originalResultOfToString = ref.toString();
+        }
+
+        WeakReference<Object> getWeakReference() {
+            return assertNotCollectable;
+        }
+
+        @Override
+        public String toString() {
+            return originalResultOfToString;
+        }
+    }
+
+    private static class SetAsReferenced {
+        Object setAsReferenced;
+
+        SetAsReferenced(Object ref) {
+            this.setAsReferenced = ref;
+        }
+    }
+
+}
diff a/modules/javafx.controls/src/test/java/test/javafx/scene/control/ToggleButtonTest.java b/modules/javafx.controls/src/test/java/test/javafx/scene/control/ToggleButtonTest.java
--- a/modules/javafx.controls/src/test/java/test/javafx/scene/control/ToggleButtonTest.java
+++ b/modules/javafx.controls/src/test/java/test/javafx/scene/control/ToggleButtonTest.java
@@ -40,10 +40,11 @@
 import javafx.scene.shape.Rectangle;
 import static org.junit.Assert.*;
 
 import org.junit.Before;
 import org.junit.Test;
+import de.sandec.jmemorybuddy.JMemoryBuddy;
 
 /**
  *
  * @author srikalyc
  */
@@ -155,69 +156,59 @@
         toggle.setToggleGroup(toggleGroup);
         assertSame(toggle.getToggleGroup(), toggleGroup);
     }
 
     @Test public void toggleGroupViaGroupAddAndRemoveClearsReference() {
-        WeakReference<ToggleButton> ref = new WeakReference<>(toggle);
+        JMemoryBuddy.memoryTest(checker -> {
+            toggleGroup.getToggles().add(toggle);
+            toggleGroup.getToggles().clear();
 
-        toggleGroup.getToggles().add(toggle);
-        toggleGroup.getToggles().clear();
-
-        toggle = null;
-        attemptGC(ref, 5);
-
-        assertNull(ref.get());
+            checker.assertCollectable(toggle);
+            toggle = null;
+        });
     }
 
     @Test public void toggleGroupViaToggleSetClearsReference() {
-        WeakReference<ToggleButton> ref = new WeakReference<>(toggle);
+        JMemoryBuddy.memoryTest(checker -> {
+            toggle.setToggleGroup(toggleGroup);
+            toggle.setToggleGroup(null);
 
-        toggle.setToggleGroup(toggleGroup);
-        toggle.setToggleGroup(null);
-
-        toggle = null;
-        attemptGC(ref, 5);
-
-        assertNull(ref.get());
+            checker.assertCollectable(toggle);
+            toggle = null;
+        });
     }
 
     @Test public void toggleGroupViaToggleThenGroupClearsReference() {
-        WeakReference<ToggleButton> ref = new WeakReference<>(toggle);
+        JMemoryBuddy.memoryTest(checker -> {
+            toggle.setToggleGroup(toggleGroup);
+            toggleGroup.getToggles().clear();
 
-        toggle.setToggleGroup(toggleGroup);
-        toggleGroup.getToggles().clear();
-
-        toggle = null;
-        attemptGC(ref, 5);
-
-        assertNull(ref.get());
+            checker.assertCollectable(toggle);
+            toggle = null;
+        });
     }
 
     @Test public void toggleGroupViaGroupThenToggleClearsReference() {
-        WeakReference<ToggleButton> ref = new WeakReference<>(toggle);
-
-        toggleGroup.getToggles().add(toggle);
-        toggle.setToggleGroup(null);
-
-        toggle = null;
-        attemptGC(ref, 5);
+        JMemoryBuddy.memoryTest(checker -> {
+            toggleGroup.getToggles().add(toggle);
+            toggle.setToggleGroup(null);
 
-        assertNull(ref.get());
+            checker.assertCollectable(toggle);
+            toggle = null;
+        });
     }
 
     @Test public void toggleGroupSwitchingClearsReference() {
-        WeakReference<ToggleButton> ref = new WeakReference<>(toggle);
-
-        ToggleGroup anotherToggleGroup = new ToggleGroup();
-        toggle.setToggleGroup(toggleGroup);
-        toggle.setToggleGroup(anotherToggleGroup);
-        toggle.setToggleGroup(null);
-
-        toggle = null;
-        attemptGC(ref, 5);
-
-        assertNull(ref.get());
+        JMemoryBuddy.memoryTest(checker -> {
+            ToggleGroup anotherToggleGroup = new ToggleGroup();
+            toggle.setToggleGroup(toggleGroup);
+            toggle.setToggleGroup(anotherToggleGroup);
+            toggle.setToggleGroup(null);
+
+            checker.assertCollectable(toggle);
+            toggle = null;
+        });
     }
 
     /*********************************************************************
      * Miscellaneous Tests                                         *
      ********************************************************************/
@@ -252,23 +243,6 @@
         } catch (InterruptedException ex) {
             PlatformLogger.getLogger(ToggleButtonTest.class.getName()).severe(null, ex);
         }
         assertTrue("fire() doesnt emit ActionEvent!", flag[0]);
     }
-
-    private void attemptGC(WeakReference<? extends Object> weakRef, int n) {
-        // Attempt gc n times
-        for (int i = 0; i < n; i++) {
-            System.gc();
-            System.runFinalization();
-
-            if (weakRef.get() == null) {
-                break;
-            }
-            try {
-                Thread.sleep(500);
-            } catch (InterruptedException e) {
-                fail("InterruptedException occurred during Thread.sleep()");
-            }
-        }
-    }
 }
diff a/tests/system/src/test/java/test/javafx/accessibility/virtualflow/VirtualFlowMemoryLeakTest.java b/tests/system/src/test/java/test/javafx/accessibility/virtualflow/VirtualFlowMemoryLeakTest.java
--- a/tests/system/src/test/java/test/javafx/accessibility/virtualflow/VirtualFlowMemoryLeakTest.java
+++ b/tests/system/src/test/java/test/javafx/accessibility/virtualflow/VirtualFlowMemoryLeakTest.java
@@ -54,10 +54,11 @@
 import javafx.scene.control.TableRow;
 import javafx.scene.control.TableView;
 import javafx.scene.control.TableView.TableViewSelectionModel;
 import javafx.stage.Stage;
 import test.util.Util;
+import de.sandec.jmemorybuddy.JMemoryBuddy;
 
 public class VirtualFlowMemoryLeakTest {
 
     private static CountDownLatch startupLatch;
     private static CountDownLatch screenReaderLatch = new CountDownLatch(1);
@@ -173,19 +174,11 @@
         for (int i = 0; i < 20; i++) {
             runAndWait(() -> addItem());
         }
         runAndWait(() -> items.clear());
 
-        for (int j = 0; j < 5; ++j) {
-            System.gc();
-            System.runFinalization();
-            if (firstRowRef.get() == null) {
-                break;
-            }
-            MILLISECONDS.sleep(100);
-        }
-        assertEquals(null, firstRowRef.get());
+        JMemoryBuddy.assertCollectable(firstRowRef);
     }
 
     private void runAndWait(final Runnable runnable) {
         Util.runAndWait(runnable);
     }
diff a/tests/system/src/test/java/test/javafx/scene/InitialNodesMemoryLeakTest.java b/tests/system/src/test/java/test/javafx/scene/InitialNodesMemoryLeakTest.java
--- a/tests/system/src/test/java/test/javafx/scene/InitialNodesMemoryLeakTest.java
+++ b/tests/system/src/test/java/test/javafx/scene/InitialNodesMemoryLeakTest.java
@@ -83,21 +83,11 @@
         }
     }
 
     @Test
     public void testRootNodeMemoryLeak() throws Exception {
-        for (int j = 0; j < 10; j++) {
-            System.gc();
-            System.runFinalization();
-
-            if (groupWRef.get() == null) {
-                break;
-            }
-
-            Util.sleep(500);
-        }
-        Assert.assertNull("Couldn't collect Node", groupWRef.get());
+        JMemoryBuddy.assertCollectable("groupWRef");
     }
 
     @AfterClass
     public static void teardownOnce() {
         Platform.runLater(() -> {
diff a/tests/system/src/test/java/test/javafx/scene/control/ProgressIndicatorLeakTest.java b/tests/system/src/test/java/test/javafx/scene/control/ProgressIndicatorLeakTest.java
--- a/tests/system/src/test/java/test/javafx/scene/control/ProgressIndicatorLeakTest.java
+++ b/tests/system/src/test/java/test/javafx/scene/control/ProgressIndicatorLeakTest.java
@@ -41,10 +41,11 @@
 
 import junit.framework.Assert;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
+import de.sandec.jmemorybuddy.JMemoryBuddy;
 
 public class ProgressIndicatorLeakTest {
 
     static CountDownLatch startupLatch;
     static WeakReference<Node> detIndicator = null;
@@ -79,27 +80,11 @@
         Assert.assertTrue("Timeout waiting for FX runtime to start", startupLatch.await(15, TimeUnit.SECONDS));
     }
 
     @Test
     public void memoryTest() throws Exception {
-        assertCollectable(detIndicator);
-    }
-
-    public static void assertCollectable(WeakReference weakReference) throws Exception {
-        int counter = 0;
-
-        System.gc();
-        System.runFinalization();
-
-        while (counter < 10 && weakReference.get() != null) {
-            Thread.sleep(100);
-            counter = counter + 1;
-            System.gc();
-            System.runFinalization();
-        }
-
-        Assert.assertNull(weakReference.get());
+        JMemoryBuddy.assertCollectable(detIndicator);
     }
 
     @AfterClass
     public static void teardownOnce() {
         Platform.runLater(() -> {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.controls/src/main/java/javafx/scene/control/skin/TabPaneSkin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control.skin;
  27 
  28 import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;
  29 import com.sun.javafx.scene.control.Properties;
  30 import com.sun.javafx.scene.control.TabObservableList;
  31 import com.sun.javafx.util.Utils;
  32 import javafx.animation.Animation;
  33 import javafx.animation.Interpolator;
  34 import javafx.animation.KeyFrame;
  35 import javafx.animation.KeyValue;
  36 import javafx.animation.Timeline;
  37 import javafx.animation.Transition;
  38 import javafx.beans.InvalidationListener;
  39 import javafx.beans.Observable;
  40 import javafx.beans.WeakInvalidationListener;
  41 import javafx.beans.property.DoubleProperty;
  42 import javafx.beans.property.ObjectProperty;
  43 import javafx.beans.property.SimpleDoubleProperty;
  44 import javafx.beans.value.WritableValue;
  45 import javafx.collections.FXCollections;
  46 import javafx.collections.ListChangeListener;
  47 import javafx.collections.ObservableList;
  48 import javafx.collections.WeakListChangeListener;
  49 import javafx.css.CssMetaData;
  50 import javafx.css.PseudoClass;
  51 import javafx.css.Styleable;
  52 import javafx.css.StyleableObjectProperty;
  53 import javafx.css.StyleableProperty;
  54 import javafx.event.ActionEvent;
  55 import javafx.event.EventHandler;
  56 import javafx.geometry.Bounds;
  57 import javafx.geometry.HPos;
  58 import javafx.geometry.NodeOrientation;
  59 import javafx.geometry.Point2D;
  60 import javafx.geometry.Pos;
  61 import javafx.geometry.Side;
  62 import javafx.geometry.VPos;
  63 import javafx.scene.AccessibleAction;
  64 import javafx.scene.AccessibleAttribute;
  65 import javafx.scene.AccessibleRole;
  66 import javafx.scene.Node;
  67 import javafx.scene.control.ContextMenu;
  68 import javafx.scene.control.Control;
  69 import javafx.scene.control.Label;
  70 import javafx.scene.control.MenuItem;
  71 import javafx.scene.control.RadioMenuItem;
  72 import javafx.scene.control.SelectionModel;
  73 import javafx.scene.control.SkinBase;
  74 import javafx.scene.control.Tab;
  75 import javafx.scene.control.TabPane;
  76 import javafx.scene.control.TabPane.TabClosingPolicy;
  77 import javafx.scene.control.TabPane.TabDragPolicy;
  78 import javafx.scene.control.ToggleGroup;
  79 import javafx.scene.control.Tooltip;
  80 import javafx.scene.effect.DropShadow;
  81 import javafx.scene.image.ImageView;
  82 import javafx.scene.input.ContextMenuEvent;
  83 import javafx.scene.input.MouseButton;
  84 import javafx.scene.input.MouseEvent;
  85 import javafx.scene.input.ScrollEvent;
  86 import javafx.scene.input.SwipeEvent;
  87 import javafx.scene.layout.Pane;
  88 import javafx.scene.layout.Region;
  89 import javafx.scene.layout.StackPane;
  90 import javafx.scene.shape.Rectangle;
  91 import javafx.scene.transform.Rotate;
  92 import javafx.util.Duration;
  93 import javafx.util.Pair;
  94 
  95 import java.util.ArrayList;
  96 import java.util.Collections;
  97 import java.util.Iterator;
  98 import java.util.List;
  99 
 100 import javafx.css.converter.EnumConverter;
 101 import com.sun.javafx.scene.control.behavior.TabPaneBehavior;
 102 
 103 import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;
 104 
 105 /**
 106  * Default skin implementation for the {@link TabPane} control.
 107  *
 108  * @see TabPane
 109  * @since 9
 110  */
 111 public class TabPaneSkin extends SkinBase&lt;TabPane&gt; {
 112 
 113     /***************************************************************************
 114      *                                                                         *
 115      * Enums                                                                   *
 116      *                                                                         *
 117      **************************************************************************/
 118 
 119     private enum TabAnimation {
 120         NONE,
 121         GROW
 122         // In future we could add FADE, ...
 123     }
 124 
 125     private enum TabAnimationState {
 126         SHOWING, HIDING, NONE;
 127     }
 128 
 129 
 130 
 131     /***************************************************************************
 132      *                                                                         *
 133      * Static fields                                                           *
 134      *                                                                         *
 135      **************************************************************************/
 136 
 137     static int CLOSE_BTN_SIZE = 16;
 138 
 139 
 140 
 141     /***************************************************************************
 142      *                                                                         *
 143      * Private fields                                                          *
 144      *                                                                         *
 145      **************************************************************************/
 146 
 147     private static final double ANIMATION_SPEED = 150;
 148     private static final int SPACER = 10;
 149 
 150     private TabHeaderArea tabHeaderArea;
 151     private ObservableList&lt;TabContentRegion&gt; tabContentRegions;
 152     private Rectangle clipRect;
 153     private Rectangle tabHeaderAreaClipRect;
 154     private Tab selectedTab;
 155     private boolean isSelectingTab;
 156 
 157     private final TabPaneBehavior behavior;
 158 
 159 
 160 
 161     /***************************************************************************
 162      *                                                                         *
 163      * Constructors                                                            *
 164      *                                                                         *
 165      **************************************************************************/
 166 
 167     /**
 168      * Creates a new TabPaneSkin instance, installing the necessary child
 169      * nodes into the Control {@link Control#getChildren() children} list, as
 170      * well as the necessary input mappings for handling key, mouse, etc events.
 171      *
 172      * @param control The control that this skin should be installed onto.
 173      */
 174     public TabPaneSkin(TabPane control) {
 175         super(control);
 176 
 177         // install default input map for the TabPane control
 178         this.behavior = new TabPaneBehavior(control);
 179 //        control.setInputMap(behavior.getInputMap());
 180 
 181         clipRect = new Rectangle(control.getWidth(), control.getHeight());
 182         getSkinnable().setClip(clipRect);
 183 
 184         tabContentRegions = FXCollections.&lt;TabContentRegion&gt;observableArrayList();
 185 
 186         for (Tab tab : getSkinnable().getTabs()) {
 187             addTabContent(tab);
 188         }
 189 
 190         tabHeaderAreaClipRect = new Rectangle();
 191         tabHeaderArea = new TabHeaderArea();
 192         tabHeaderArea.setClip(tabHeaderAreaClipRect);
 193         getChildren().add(tabHeaderArea);
 194         if (getSkinnable().getTabs().size() == 0) {
 195             tabHeaderArea.setVisible(false);
 196         }
 197 
 198         initializeTabListener();
 199         updateSelectionModel();
 200 
 201         registerChangeListener(control.selectionModelProperty(), e -&gt; updateSelectionModel());
 202         registerChangeListener(control.sideProperty(), e -&gt; updateTabPosition());
 203         registerChangeListener(control.widthProperty(), e -&gt; clipRect.setWidth(getSkinnable().getWidth()));
 204         registerChangeListener(control.heightProperty(), e -&gt; clipRect.setHeight(getSkinnable().getHeight()));
 205 
 206         selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
 207         // Could not find the selected tab try and get the selected tab using the selected index
 208         if (selectedTab == null &amp;&amp; getSkinnable().getSelectionModel().getSelectedIndex() != -1) {
 209             getSkinnable().getSelectionModel().select(getSkinnable().getSelectionModel().getSelectedIndex());
 210             selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
 211         }
 212         if (selectedTab == null) {
 213             // getSelectedItem and getSelectedIndex failed select the first.
 214             getSkinnable().getSelectionModel().selectFirst();
 215         }
 216         selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
 217         isSelectingTab = false;
 218 
 219         initializeSwipeHandlers();
 220     }
 221 
 222 
 223 
 224     /***************************************************************************
 225      *                                                                         *
 226      * Properties                                                              *
 227      *                                                                         *
 228      **************************************************************************/
 229 
 230     private ObjectProperty&lt;TabAnimation&gt; openTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
 231         @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
 232             return StyleableProperties.OPEN_TAB_ANIMATION;
 233         }
 234 
 235         @Override public Object getBean() {
 236             return TabPaneSkin.this;
 237         }
 238 
 239         @Override public String getName() {
 240             return &quot;openTabAnimation&quot;;
 241         }
 242     };
 243 
 244     private ObjectProperty&lt;TabAnimation&gt; closeTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
 245         @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
 246             return StyleableProperties.CLOSE_TAB_ANIMATION;
 247         }
 248 
 249         @Override public Object getBean() {
 250             return TabPaneSkin.this;
 251         }
 252 
 253         @Override public String getName() {
 254             return &quot;closeTabAnimation&quot;;
 255         }
 256     };
 257 
 258     /***************************************************************************
 259      *                                                                         *
 260      * Public API                                                              *
 261      *                                                                         *
 262      **************************************************************************/
 263 
 264     /** {@inheritDoc} */
 265     @Override public void dispose() {
 266         if (selectionModel != null) {
 267             selectionModel.selectedItemProperty().removeListener(weakSelectionChangeListener);
 268             selectionModel = null;
 269         }
 270 
 271         super.dispose();
 272 
 273         if (behavior != null) {
 274             behavior.dispose();
 275         }
 276     }
 277 
 278     /** {@inheritDoc} */
 279     @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
 280         // The TabPane can only be as wide as it widest content width.
 281         double maxw = 0.0;
 282         for (TabContentRegion contentRegion: tabContentRegions) {
 283             maxw = Math.max(maxw, snapSizeX(contentRegion.prefWidth(-1)));
 284         }
 285 
 286         final boolean isHorizontal = isHorizontal();
 287         final double tabHeaderAreaSize = isHorizontal
 288                 ? snapSizeX(tabHeaderArea.prefWidth(-1))
 289                 : snapSizeY(tabHeaderArea.prefHeight(-1));
 290 
 291         double prefWidth = isHorizontal ?
 292                 Math.max(maxw, tabHeaderAreaSize) : maxw + tabHeaderAreaSize;
 293         return snapSizeX(prefWidth) + rightInset + leftInset;
 294     }
 295 
 296     /** {@inheritDoc} */
 297     @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
 298         // The TabPane can only be as high as it highest content height.
 299         double maxh = 0.0;
 300         for (TabContentRegion contentRegion: tabContentRegions) {
 301             maxh = Math.max(maxh, snapSizeY(contentRegion.prefHeight(-1)));
 302         }
 303 
 304         final boolean isHorizontal = isHorizontal();
 305         final double tabHeaderAreaSize = isHorizontal
 306                 ? snapSizeY(tabHeaderArea.prefHeight(-1))
 307                 : snapSizeX(tabHeaderArea.prefWidth(-1));
 308 
 309         double prefHeight = isHorizontal ?
 310                 maxh + snapSizeY(tabHeaderAreaSize) : Math.max(maxh, tabHeaderAreaSize);
 311         return snapSizeY(prefHeight) + topInset + bottomInset;
 312     }
 313 
 314     /** {@inheritDoc} */
 315     @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
 316         Side tabPosition = getSkinnable().getSide();
 317         if (tabPosition == Side.TOP) {
 318             return tabHeaderArea.getBaselineOffset() + topInset;
 319         }
 320         return 0;
 321     }
 322 
 323     /** {@inheritDoc} */
 324     @Override protected void layoutChildren(final double x, final double y,
 325                                             final double w, final double h) {
 326         TabPane tabPane = getSkinnable();
 327         Side tabPosition = tabPane.getSide();
 328 
 329         double headerHeight = tabPosition.isHorizontal()
 330                 ? snapSizeY(tabHeaderArea.prefHeight(-1))
 331                 : snapSizeX(tabHeaderArea.prefHeight(-1));
 332         double tabsStartX = tabPosition.equals(Side.RIGHT)? x + w - headerHeight : x;
 333         double tabsStartY = tabPosition.equals(Side.BOTTOM)? y + h - headerHeight : y;
 334 
 335         final double leftInset = snappedLeftInset();
 336         final double topInset = snappedTopInset();
 337 
 338         if (tabPosition == Side.TOP) {
 339             tabHeaderArea.resize(w, headerHeight);
 340             tabHeaderArea.relocate(tabsStartX, tabsStartY);
 341             tabHeaderArea.getTransforms().clear();
 342             tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.TOP)));
 343         } else if (tabPosition == Side.BOTTOM) {
 344             tabHeaderArea.resize(w, headerHeight);
 345             tabHeaderArea.relocate(w + leftInset, tabsStartY - headerHeight);
 346             tabHeaderArea.getTransforms().clear();
 347             tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.BOTTOM), 0, headerHeight));
 348         } else if (tabPosition == Side.LEFT) {
 349             tabHeaderArea.resize(h, headerHeight);
 350             tabHeaderArea.relocate(tabsStartX + headerHeight, h - headerHeight + topInset);
 351             tabHeaderArea.getTransforms().clear();
 352             tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.LEFT), 0, headerHeight));
 353         } else if (tabPosition == Side.RIGHT) {
 354             tabHeaderArea.resize(h, headerHeight);
 355             tabHeaderArea.relocate(tabsStartX, y - headerHeight);
 356             tabHeaderArea.getTransforms().clear();
 357             tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.RIGHT), 0, headerHeight));
 358         }
 359 
 360         tabHeaderAreaClipRect.setX(0);
 361         tabHeaderAreaClipRect.setY(0);
 362         if (isHorizontal()) {
 363             tabHeaderAreaClipRect.setWidth(w);
 364         } else {
 365             tabHeaderAreaClipRect.setWidth(h);
 366         }
 367         tabHeaderAreaClipRect.setHeight(headerHeight);
 368 
 369         // ==================================
 370         // position the tab content for the selected tab only
 371         // ==================================
 372         // if the tabs are on the left, the content needs to be indented
 373         double contentStartX = 0;
 374         double contentStartY = 0;
 375 
 376         if (tabPosition == Side.TOP) {
 377             contentStartX = x;
 378             contentStartY = y + headerHeight;
 379             if (isFloatingStyleClass()) {
 380                 // This is to hide the top border content
 381                 contentStartY -= 1;
 382             }
 383         } else if (tabPosition == Side.BOTTOM) {
 384             contentStartX = x;
 385             contentStartY = y + topInset;
 386             if (isFloatingStyleClass()) {
 387                 // This is to hide the bottom border content
 388                 contentStartY = 1 + topInset;
 389             }
 390         } else if (tabPosition == Side.LEFT) {
 391             contentStartX = x + headerHeight;
 392             contentStartY = y;
 393             if (isFloatingStyleClass()) {
 394                 // This is to hide the left border content
 395                 contentStartX -= 1;
 396             }
 397         } else if (tabPosition == Side.RIGHT) {
 398             contentStartX = x + leftInset;
 399             contentStartY = y;
 400             if (isFloatingStyleClass()) {
 401                 // This is to hide the right border content
 402                 contentStartX = 1 + leftInset;
 403             }
 404         }
 405 
 406         double contentWidth = w - (isHorizontal() ? 0 : headerHeight);
 407         double contentHeight = h - (isHorizontal() ? headerHeight: 0);
 408 
 409         for (int i = 0, max = tabContentRegions.size(); i &lt; max; i++) {
 410             TabContentRegion tabContent = tabContentRegions.get(i);
 411 
 412             tabContent.setAlignment(Pos.TOP_LEFT);
 413             if (tabContent.getClip() != null) {
 414                 ((Rectangle)tabContent.getClip()).setWidth(contentWidth);
 415                 ((Rectangle)tabContent.getClip()).setHeight(contentHeight);
 416             }
 417 
 418             // we need to size all tabs, even if they aren&#39;t visible. For example,
 419             // see RT-29167
 420             tabContent.resize(contentWidth, contentHeight);
 421             tabContent.relocate(contentStartX, contentStartY);
 422         }
 423     }
 424 
 425 
 426 
 427     /***************************************************************************
 428      *                                                                         *
 429      * Private implementation                                                  *
 430      *                                                                         *
 431      **************************************************************************/
 432 
 433     private SelectionModel&lt;Tab&gt; selectionModel;
 434     private InvalidationListener selectionChangeListener = observable -&gt; {
 435         isSelectingTab = true;
 436         selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
 437         getSkinnable().requestLayout();
 438     };
 439     private WeakInvalidationListener weakSelectionChangeListener =
 440             new WeakInvalidationListener(selectionChangeListener);
 441 
 442     private void updateSelectionModel() {
 443         if (selectionModel != null) {
 444             selectionModel.selectedItemProperty().removeListener(weakSelectionChangeListener);
 445         }
 446         selectionModel = getSkinnable().getSelectionModel();
 447         if (selectionModel != null) {
 448             selectionModel.selectedItemProperty().addListener(weakSelectionChangeListener);
 449         }
 450     }
 451 
 452     private static int getRotation(Side pos) {
 453         switch (pos) {
 454             case TOP:
 455                 return 0;
 456             case BOTTOM:
 457                 return 180;
 458             case LEFT:
 459                 return -90;
 460             case RIGHT:
 461                 return 90;
 462             default:
 463                 return 0;
 464         }
 465     }
 466 
 467     /**
 468      * VERY HACKY - this lets us &#39;duplicate&#39; Label and ImageView nodes to be used in a
 469      * Tab and the tabs menu at the same time.
 470      */
 471     private static Node clone(Node n) {
 472         if (n == null) {
 473             return null;
 474         }
 475         if (n instanceof ImageView) {
 476             ImageView iv = (ImageView) n;
 477             ImageView imageview = new ImageView();
 478             imageview.imageProperty().bind(iv.imageProperty());
 479             return imageview;
 480         }
 481         if (n instanceof Label) {
 482             Label l = (Label)n;
 483             Label label = new Label(l.getText(), clone(l.getGraphic()));
 484             label.textProperty().bind(l.textProperty());
 485             return label;
 486         }
 487         return null;
 488     }
 489 
 490     private void removeTabs(List&lt;? extends Tab&gt; removedList) {
 491         for (final Tab tab : removedList) {
 492             stopCurrentAnimation(tab);
 493             // Animate the tab removal
 494             final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
 495             if (tabRegion != null) {
 496                 tabRegion.isClosing = true;
 497 
 498                 tabRegion.removeListeners(tab);
 499                 removeTabContent(tab);
 500 
 501                 EventHandler&lt;ActionEvent&gt; cleanup = ae -&gt; {
 502                     tabRegion.animationState = TabAnimationState.NONE;
 503 
 504                     tabHeaderArea.removeTab(tab);
 505                     tabHeaderArea.requestLayout();
 506                     if (getSkinnable().getTabs().isEmpty()) {
 507                         tabHeaderArea.setVisible(false);
 508                     }
 509                 };
 510 
 511                 if (closeTabAnimation.get() == TabAnimation.GROW) {
 512                     tabRegion.animationState = TabAnimationState.HIDING;
 513                     Timeline closedTabTimeline = tabRegion.currentAnimation =
 514                             createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 0.0F, cleanup);
 515                     closedTabTimeline.play();
 516                 } else {
 517                     cleanup.handle(null);
 518                 }
 519             }
 520         }
 521     }
 522 
 523     private void stopCurrentAnimation(Tab tab) {
 524         final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
 525         if (tabRegion != null) {
 526             // Execute the code immediately, don&#39;t wait for the animation to finish.
 527             Timeline timeline = tabRegion.currentAnimation;
 528             if (timeline != null &amp;&amp; timeline.getStatus() == Animation.Status.RUNNING) {
 529                 timeline.getOnFinished().handle(null);
 530                 timeline.stop();
 531                 tabRegion.currentAnimation = null;
 532             }
 533         }
 534     }
 535 
 536     private void addTabs(List&lt;? extends Tab&gt; addedList, int from) {
 537         int i = 0;
 538 
 539         // RT-39984: check if any other tabs are animating - they must be completed first.
 540         List&lt;Node&gt; headers = new ArrayList&lt;&gt;(tabHeaderArea.headersRegion.getChildren());
 541         for (Node n : headers) {
 542             TabHeaderSkin header = (TabHeaderSkin) n;
 543             if (header.animationState == TabAnimationState.HIDING) {
 544                 stopCurrentAnimation(header.tab);
 545             }
 546         }
 547         // end of fix for RT-39984
 548 
 549         for (final Tab tab : addedList) {
 550             stopCurrentAnimation(tab); // Note that this must happen before addTab() call below
 551             // A new tab was added - animate it out
 552             if (!tabHeaderArea.isVisible()) {
 553                 tabHeaderArea.setVisible(true);
 554             }
 555             int index = from + i++;
 556             tabHeaderArea.addTab(tab, index);
 557             addTabContent(tab);
 558             final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
 559             if (tabRegion != null) {
 560                 if (openTabAnimation.get() == TabAnimation.GROW) {
 561                     tabRegion.animationState = TabAnimationState.SHOWING;
 562                     tabRegion.animationTransition.setValue(0.0);
 563                     tabRegion.setVisible(true);
 564                     tabRegion.currentAnimation = createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 1.0, event -&gt; {
 565                         tabRegion.animationState = TabAnimationState.NONE;
 566                         tabRegion.setVisible(true);
 567                         tabRegion.inner.requestLayout();
 568                     });
 569                     tabRegion.currentAnimation.play();
 570                 } else {
 571                     tabRegion.setVisible(true);
 572                     tabRegion.inner.requestLayout();
 573                 }
 574             }
 575         }
 576     }
 577 
 578     private void initializeTabListener() {
 579         getSkinnable().getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; {
 580             List&lt;Tab&gt; tabsToRemove = new ArrayList&lt;&gt;();
 581             List&lt;Tab&gt; tabsToAdd = new ArrayList&lt;&gt;();
 582 
 583             while (c.next()) {
 584                 if (c.wasPermutated()) {
 585                     if (dragState != DragState.REORDER) {
 586                         TabPane tabPane = getSkinnable();
 587                         List&lt;Tab&gt; tabs = tabPane.getTabs();
 588 
 589                         // tabs sorted : create list of permutated tabs.
 590                         // clear selection, set tab animation to NONE
 591                         // remove permutated tabs, add them back in correct order.
 592                         // restore old selection, and old tab animation states.
 593                         int size = c.getTo() - c.getFrom();
 594                         Tab selTab = tabPane.getSelectionModel().getSelectedItem();
 595                         List&lt;Tab&gt; permutatedTabs = new ArrayList&lt;Tab&gt;(size);
 596                         getSkinnable().getSelectionModel().clearSelection();
 597 
 598                         // save and set tab animation to none - as it is not a good idea
 599                         // to animate on the same data for open and close.
 600                         TabAnimation prevOpenAnimation = openTabAnimation.get();
 601                         TabAnimation prevCloseAnimation = closeTabAnimation.get();
 602                         openTabAnimation.set(TabAnimation.NONE);
 603                         closeTabAnimation.set(TabAnimation.NONE);
 604                         for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
 605                             permutatedTabs.add(tabs.get(i));
 606                         }
 607 
 608                         removeTabs(permutatedTabs);
 609                         addTabs(permutatedTabs, c.getFrom());
 610                         openTabAnimation.set(prevOpenAnimation);
 611                         closeTabAnimation.set(prevCloseAnimation);
 612                         getSkinnable().getSelectionModel().select(selTab);
 613                     }
 614                 }
 615 
 616                 if (c.wasRemoved()) {
 617                     tabsToRemove.addAll(c.getRemoved());
 618                 }
 619                 if (c.wasAdded()) {
 620                     tabsToAdd.addAll(c.getAddedSubList());
 621                 }
 622             }
 623 
 624             // now only remove the tabs that are not in the tabsToAdd list
 625             tabsToRemove.removeAll(tabsToAdd);
 626             removeTabs(tabsToRemove);
 627 
 628             // and add in any new tabs (that we don&#39;t already have showing)
 629             List&lt;Pair&lt;Integer, TabHeaderSkin&gt;&gt; headersToMove = new ArrayList();
 630             if (!tabsToAdd.isEmpty()) {
 631                 for (TabContentRegion tabContentRegion : tabContentRegions) {
 632                     Tab tab = tabContentRegion.getTab();
 633                     TabHeaderSkin tabHeader = tabHeaderArea.getTabHeaderSkin(tab);
 634                     if (!tabHeader.isClosing &amp;&amp; tabsToAdd.contains(tabContentRegion.getTab())) {
 635                         tabsToAdd.remove(tabContentRegion.getTab());
 636 
 637                         // If a tab is removed and added back at the same time,
 638                         // then we must ensure that the index of tabHeader in
 639                         // headersRegion is same as index of tab in getTabs().
 640                         int tabIndex = getSkinnable().getTabs().indexOf(tab);
 641                         int tabHeaderIndex = tabHeaderArea.headersRegion.getChildren().indexOf(tabHeader);
 642                         if (tabIndex != tabHeaderIndex) {
 643                             headersToMove.add(new Pair(tabIndex, tabHeader));
 644                         }
 645                     }
 646                 }
 647 
 648                 if (!tabsToAdd.isEmpty()) {
 649                     addTabs(tabsToAdd, getSkinnable().getTabs().indexOf(tabsToAdd.get(0)));
 650                 }
 651                 for (Pair&lt;Integer, TabHeaderSkin&gt; move : headersToMove) {
 652                     tabHeaderArea.moveTab(move.getKey(), move.getValue());
 653                 }
 654             }
 655 
 656             // Fix for RT-34692
 657             getSkinnable().requestLayout();
 658         });
 659     }
 660 
 661     private void addTabContent(Tab tab) {
 662         TabContentRegion tabContentRegion = new TabContentRegion(tab);
 663         tabContentRegion.setClip(new Rectangle());
 664         tabContentRegions.add(tabContentRegion);
 665         // We want the tab content to always sit below the tab headers
 666         getChildren().add(0, tabContentRegion);
 667     }
 668 
 669     private void removeTabContent(Tab tab) {
 670         for (TabContentRegion contentRegion : tabContentRegions) {
 671             if (contentRegion.getTab().equals(tab)) {
 672                 contentRegion.removeListeners(tab);
 673                 getChildren().remove(contentRegion);
 674                 tabContentRegions.remove(contentRegion);
 675                 break;
 676             }
 677         }
 678     }
 679 
 680     private void updateTabPosition() {
 681         tabHeaderArea.setScrollOffset(0.0F);
 682         getSkinnable().applyCss();
 683         getSkinnable().requestLayout();
 684     }
 685 
 686     private Timeline createTimeline(final TabHeaderSkin tabRegion, final Duration duration, final double endValue, final EventHandler&lt;ActionEvent&gt; func) {
 687         Timeline timeline = new Timeline();
 688         timeline.setCycleCount(1);
 689 
 690         KeyValue keyValue = new KeyValue(tabRegion.animationTransition, endValue, Interpolator.LINEAR);
 691         timeline.getKeyFrames().clear();
 692         timeline.getKeyFrames().add(new KeyFrame(duration, keyValue));
 693 
 694         timeline.setOnFinished(func);
 695         return timeline;
 696     }
 697 
 698     private boolean isHorizontal() {
 699         Side tabPosition = getSkinnable().getSide();
 700         return Side.TOP.equals(tabPosition) || Side.BOTTOM.equals(tabPosition);
 701     }
 702 
 703     private void initializeSwipeHandlers() {
 704         if (Properties.IS_TOUCH_SUPPORTED) {
 705             getSkinnable().addEventHandler(SwipeEvent.SWIPE_LEFT, t -&gt; {
 706                 behavior.selectNextTab();
 707             });
 708 
 709             getSkinnable().addEventHandler(SwipeEvent.SWIPE_RIGHT, t -&gt; {
 710                 behavior.selectPreviousTab();
 711             });
 712         }
 713     }
 714 
 715     //TODO need to cache this.
 716     private boolean isFloatingStyleClass() {
 717         return getSkinnable().getStyleClass().contains(TabPane.STYLE_CLASS_FLOATING);
 718     }
 719 
 720 
 721 
 722     /***************************************************************************
 723      *                                                                         *
 724      * CSS                                                                     *
 725      *                                                                         *
 726      **************************************************************************/
 727 
 728    /*
 729     * Super-lazy instantiation pattern from Bill Pugh.
 730     */
 731    private static class StyleableProperties {
 732         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
 733 
 734         private final static CssMetaData&lt;TabPane,TabAnimation&gt; OPEN_TAB_ANIMATION =
 735                 new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-open-tab-animation&quot;,
 736                     new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {
 737 
 738             @Override public boolean isSettable(TabPane node) {
 739                 return true;
 740             }
 741 
 742             @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
 743                 TabPaneSkin skin = (TabPaneSkin) node.getSkin();
 744                 return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.openTabAnimation;
 745             }
 746         };
 747 
 748         private final static CssMetaData&lt;TabPane,TabAnimation&gt; CLOSE_TAB_ANIMATION =
 749                 new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-close-tab-animation&quot;,
 750                     new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {
 751 
 752             @Override public boolean isSettable(TabPane node) {
 753                 return true;
 754             }
 755 
 756             @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
 757                 TabPaneSkin skin = (TabPaneSkin) node.getSkin();
 758                 return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.closeTabAnimation;
 759             }
 760         };
 761 
 762         static {
 763 
 764            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
 765                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
 766            styleables.add(OPEN_TAB_ANIMATION);
 767            styleables.add(CLOSE_TAB_ANIMATION);
 768            STYLEABLES = Collections.unmodifiableList(styleables);
 769 
 770         }
 771     }
 772 
 773     /**
 774      * Returns the CssMetaData associated with this class, which may include the
 775      * CssMetaData of its superclasses.
 776      * @return the CssMetaData associated with this class, which may include the
 777      * CssMetaData of its superclasses
 778      */
 779     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
 780         return StyleableProperties.STYLEABLES;
 781     }
 782 
 783     /**
 784      * {@inheritDoc}
 785      */
 786     @Override public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
 787         return getClassCssMetaData();
 788     }
 789 
 790 
 791 
 792     /***************************************************************************
 793      *                                                                         *
 794      * Support classes                                                         *
 795      *                                                                         *
 796      **************************************************************************/
 797 
 798     /**************************************************************************
 799      *
 800      * TabHeaderArea: Area responsible for painting all tabs
 801      *
 802      **************************************************************************/
 803     class TabHeaderArea extends StackPane {
 804         private Rectangle headerClip;
 805         private StackPane headersRegion;
 806         private StackPane headerBackground;
 807         private TabControlButtons controlButtons;
 808 
 809         private boolean measureClosingTabs = false;
 810 
 811         private double scrollOffset;
 812 
 813         public TabHeaderArea() {
 814             getStyleClass().setAll(&quot;tab-header-area&quot;);
 815             setManaged(false);
 816             final TabPane tabPane = getSkinnable();
 817 
 818             headerClip = new Rectangle();
 819 
 820             headersRegion = new StackPane() {
 821                 @Override protected double computePrefWidth(double height) {
 822                     double width = 0.0F;
 823                     for (Node child : getChildren()) {
 824                         TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
 825                         if (tabHeaderSkin.isVisible() &amp;&amp; (measureClosingTabs || ! tabHeaderSkin.isClosing)) {
 826                             width += tabHeaderSkin.prefWidth(height);
 827                         }
 828                     }
 829                     return snapSize(width) + snappedLeftInset() + snappedRightInset();
 830                 }
 831 
 832                 @Override protected double computePrefHeight(double width) {
 833                     double height = 0.0F;
 834                     for (Node child : getChildren()) {
 835                         TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
 836                         height = Math.max(height, tabHeaderSkin.prefHeight(width));
 837                     }
 838                     return snapSize(height) + snappedTopInset() + snappedBottomInset();
 839                 }
 840 
 841                 @Override protected void layoutChildren() {
 842                     if (tabsFit()) {
 843                         setScrollOffset(0.0);
 844                     } else {
 845                         if (isSelectingTab) {
 846                             ensureSelectedTabIsVisible();
 847                         } else {
 848                             validateScrollOffset();
 849                         }
 850                     }
 851                     isSelectingTab = false;
 852 
 853                     Side tabPosition = getSkinnable().getSide();
 854                     double tabBackgroundHeight = snapSize(prefHeight(-1));
 855                     double tabX = (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) ?
 856                         snapSize(getWidth()) - getScrollOffset() : getScrollOffset();
 857 
 858                     updateHeaderClip();
 859                     for (Node node : getChildren()) {
 860                         TabHeaderSkin tabHeader = (TabHeaderSkin)node;
 861 
 862                         // size and position the header relative to the other headers
 863                         double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1) * tabHeader.animationTransition.get());
 864                         double tabHeaderPrefHeight = snapSize(tabHeader.prefHeight(-1));
 865                         tabHeader.resize(tabHeaderPrefWidth, tabHeaderPrefHeight);
 866 
 867                         // This ensures that the tabs are located in the correct position
 868                         // when there are tabs of differing heights.
 869                         double startY = tabPosition.equals(Side.BOTTOM) ?
 870                             0 : tabBackgroundHeight - tabHeaderPrefHeight - snappedBottomInset();
 871                         if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
 872                             // build from the right
 873                             tabX -= tabHeaderPrefWidth;
 874                             if (dragState != DragState.REORDER ||
 875                                     (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
 876                                 tabHeader.relocate(tabX, startY);
 877                             }
 878                         } else {
 879                             // build from the left
 880                             if (dragState != DragState.REORDER ||
 881                                     (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
 882                                 tabHeader.relocate(tabX, startY);
 883                             }
 884                             tabX += tabHeaderPrefWidth;
 885                         }
 886                     }
 887                 }
 888 
 889             };
 890             headersRegion.getStyleClass().setAll(&quot;headers-region&quot;);
 891             headersRegion.setClip(headerClip);
 892             setupReordering(headersRegion);
 893 
 894             headerBackground = new StackPane();
 895             headerBackground.getStyleClass().setAll(&quot;tab-header-background&quot;);
 896 
 897             int i = 0;
 898             for (Tab tab: tabPane.getTabs()) {
 899                 addTab(tab, i++);
 900             }
 901 
 902             controlButtons = new TabControlButtons();
 903             controlButtons.setVisible(false);
 904             if (controlButtons.isVisible()) {
 905                 controlButtons.setVisible(true);
 906             }
 907             getChildren().addAll(headerBackground, headersRegion, controlButtons);
 908 
 909             // support for mouse scroll of header area (for when the tabs exceed
 910             // the available space).
 911             // Scrolling the mouse wheel downwards results in the tabs scrolling left (i.e. exposing the right-most tabs)
 912             // Scrolling the mouse wheel upwards results in the tabs scrolling right (i.e. exposing th left-most tabs)
 913             addEventHandler(ScrollEvent.SCROLL, (ScrollEvent e) -&gt; {
 914                 Side side = getSkinnable().getSide();
 915                 side = side == null ? Side.TOP : side;
 916                 switch (side) {
 917                     default:
 918                     case TOP:
 919                     case BOTTOM:
 920                         setScrollOffset(scrollOffset + e.getDeltaY());
 921                         break;
 922                     case LEFT:
 923                     case RIGHT:
 924                         setScrollOffset(scrollOffset - e.getDeltaY());
 925                         break;
 926                 }
 927 
 928             });
 929         }
 930 
 931         private void updateHeaderClip() {
 932             Side tabPosition = getSkinnable().getSide();
 933 
 934             double x = 0;
 935             double y = 0;
 936             double clipWidth = 0;
 937             double clipHeight = 0;
 938             double maxWidth = 0;
 939             double shadowRadius = 0;
 940             double clipOffset = firstTabIndent();
 941             double controlButtonPrefWidth = snapSize(controlButtons.prefWidth(-1));
 942 
 943             measureClosingTabs = true;
 944             double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
 945             measureClosingTabs = false;
 946 
 947             double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));
 948 
 949             // Add the spacer if isShowTabsMenu is true.
 950             if (controlButtonPrefWidth &gt; 0) {
 951                 controlButtonPrefWidth = controlButtonPrefWidth + SPACER;
 952             }
 953 
 954             if (headersRegion.getEffect() instanceof DropShadow) {
 955                 DropShadow shadow = (DropShadow)headersRegion.getEffect();
 956                 shadowRadius = shadow.getRadius();
 957             }
 958 
 959             maxWidth = snapSize(getWidth()) - controlButtonPrefWidth - clipOffset;
 960             if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
 961                 if (headersPrefWidth &lt; maxWidth) {
 962                     clipWidth = headersPrefWidth + shadowRadius;
 963                 } else {
 964                     x = headersPrefWidth - maxWidth;
 965                     clipWidth = maxWidth + shadowRadius;
 966                 }
 967                 clipHeight = headersPrefHeight;
 968             } else {
 969                 // If x = 0 the header region&#39;s drop shadow is clipped.
 970                 x = -shadowRadius;
 971                 clipWidth = (headersPrefWidth &lt; maxWidth ? headersPrefWidth : maxWidth) + shadowRadius;
 972                 clipHeight = headersPrefHeight;
 973             }
 974 
 975             headerClip.setX(x);
 976             headerClip.setY(y);
 977             headerClip.setWidth(clipWidth);
 978             headerClip.setHeight(clipHeight);
 979         }
 980 
 981         private void addTab(Tab tab, int addToIndex) {
 982             TabHeaderSkin tabHeaderSkin = new TabHeaderSkin(tab);
 983             headersRegion.getChildren().add(addToIndex, tabHeaderSkin);
 984         }
 985 
 986         private void removeTab(Tab tab) {
 987             TabHeaderSkin tabHeaderSkin = getTabHeaderSkin(tab);
 988             if (tabHeaderSkin != null) {
 989                 headersRegion.getChildren().remove(tabHeaderSkin);
 990             }
 991         }
 992 
 993         private void moveTab(int moveToIndex, TabHeaderSkin tabHeaderSkin) {
 994             if (moveToIndex != headersRegion.getChildren().indexOf(tabHeaderSkin)) {
 995                 headersRegion.getChildren().remove(tabHeaderSkin);
 996                 headersRegion.getChildren().add(moveToIndex, tabHeaderSkin);
 997             }
 998         }
 999 
1000         private TabHeaderSkin getTabHeaderSkin(Tab tab) {
1001             for (Node child: headersRegion.getChildren()) {
1002                 TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
1003                 if (tabHeaderSkin.getTab().equals(tab)) {
1004                     return tabHeaderSkin;
1005                 }
1006             }
1007             return null;
1008         }
1009 
1010         private boolean tabsFit() {
1011             double headerPrefWidth = snapSize(headersRegion.prefWidth(-1));
1012             double controlTabWidth = snapSize(controlButtons.prefWidth(-1));
1013             double visibleWidth = headerPrefWidth + controlTabWidth + firstTabIndent() + SPACER;
1014             return visibleWidth &lt; getWidth();
1015         }
1016 
1017         private void ensureSelectedTabIsVisible() {
1018             // work out the visible width of the tab header
1019             double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
1020             double controlTabWidth = snapSize(controlButtons.getWidth());
1021             double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;
1022 
1023             // and get where the selected tab is in the header area
1024             double offset = 0.0;
1025             double selectedTabOffset = 0.0;
1026             double selectedTabWidth = 0.0;
1027             for (Node node : headersRegion.getChildren()) {
1028                 TabHeaderSkin tabHeader = (TabHeaderSkin)node;
1029 
1030                 double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));
1031 
1032                 if (selectedTab != null &amp;&amp; selectedTab.equals(tabHeader.getTab())) {
1033                     selectedTabOffset = offset;
1034                     selectedTabWidth = tabHeaderPrefWidth;
1035                 }
1036                 offset += tabHeaderPrefWidth;
1037             }
1038 
1039             final double scrollOffset = getScrollOffset();
1040             final double selectedTabStartX = selectedTabOffset;
1041             final double selectedTabEndX = selectedTabOffset + selectedTabWidth;
1042 
1043             final double visibleAreaEndX = visibleWidth;
1044 
1045             if (selectedTabStartX &lt; -scrollOffset) {
1046                 setScrollOffset(-selectedTabStartX);
1047             } else if (selectedTabEndX &gt; (visibleAreaEndX - scrollOffset)) {
1048                 setScrollOffset(visibleAreaEndX - selectedTabEndX);
1049             }
1050         }
1051 
1052         public double getScrollOffset() {
1053             return scrollOffset;
1054         }
1055 
1056         private void validateScrollOffset() {
1057             setScrollOffset(getScrollOffset());
1058         }
1059 
1060         private void setScrollOffset(double newScrollOffset) {
1061             // work out the visible width of the tab header
1062             double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
1063             double controlTabWidth = snapSize(controlButtons.getWidth());
1064             double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;
1065 
1066             // measure the width of all tabs
1067             double offset = 0.0;
1068             for (Node node : headersRegion.getChildren()) {
1069                 TabHeaderSkin tabHeader = (TabHeaderSkin)node;
1070                 double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));
1071                 offset += tabHeaderPrefWidth;
1072             }
1073 
1074             double actualNewScrollOffset;
1075 
1076             if ((visibleWidth - newScrollOffset) &gt; offset &amp;&amp; newScrollOffset &lt; 0) {
1077                 // need to make sure the right-most tab is attached to the
1078                 // right-hand side of the tab header (e.g. if the tab header area width
1079                 // is expanded), and if it isn&#39;t modify the scroll offset to bring
1080                 // it into line. See RT-35194 for a test case.
1081                 actualNewScrollOffset = visibleWidth - offset;
1082             } else if (newScrollOffset &gt; 0) {
1083                 // need to prevent the left-most tab from becoming detached
1084                 // from the left-hand side of the tab header.
1085                 actualNewScrollOffset = 0;
1086             } else {
1087                 actualNewScrollOffset = newScrollOffset;
1088             }
1089 
1090             if (Math.abs(actualNewScrollOffset - scrollOffset) &gt; 0.001) {
1091                 scrollOffset = actualNewScrollOffset;
1092                 headersRegion.requestLayout();
1093             }
1094         }
1095 
1096         private double firstTabIndent() {
1097             switch (getSkinnable().getSide()) {
1098                 case TOP:
1099                 case BOTTOM:
1100                     return snappedLeftInset();
1101                 case RIGHT:
1102                 case LEFT:
1103                     return snappedTopInset();
1104                 default:
1105                     return 0;
1106             }
1107         }
1108 
1109         @Override protected double computePrefWidth(double height) {
1110             double padding = isHorizontal() ?
1111                 snappedLeftInset() + snappedRightInset() :
1112                 snappedTopInset() + snappedBottomInset();
1113             return snapSize(headersRegion.prefWidth(height)) + controlButtons.prefWidth(height) +
1114                     firstTabIndent() + SPACER + padding;
1115         }
1116 
1117         @Override protected double computePrefHeight(double width) {
1118             double padding = isHorizontal() ?
1119                 snappedTopInset() + snappedBottomInset() :
1120                 snappedLeftInset() + snappedRightInset();
1121             return snapSize(headersRegion.prefHeight(-1)) + padding;
1122         }
1123 
1124         @Override public double getBaselineOffset() {
1125             if (getSkinnable().getSide() == Side.TOP) {
1126                 return headersRegion.getBaselineOffset() + snappedTopInset();
1127             }
1128             return 0;
1129         }
1130 
1131         @Override protected void layoutChildren() {
1132             final double leftInset = snappedLeftInset();
1133             final double rightInset = snappedRightInset();
1134             final double topInset = snappedTopInset();
1135             final double bottomInset = snappedBottomInset();
1136             double w = snapSize(getWidth()) - (isHorizontal() ?
1137                     leftInset + rightInset : topInset + bottomInset);
1138             double h = snapSize(getHeight()) - (isHorizontal() ?
1139                     topInset + bottomInset : leftInset + rightInset);
1140             double tabBackgroundHeight = snapSize(prefHeight(-1));
1141             double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
1142             double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));
1143 
1144             controlButtons.showTabsMenu(! tabsFit());
1145 
1146             updateHeaderClip();
1147             headersRegion.requestLayout();
1148 
1149             // RESIZE CONTROL BUTTONS
1150             double btnWidth = snapSize(controlButtons.prefWidth(-1));
1151             final double btnHeight = controlButtons.prefHeight(btnWidth);
1152             controlButtons.resize(btnWidth, btnHeight);
1153 
1154             // POSITION TABS
1155             headersRegion.resize(headersPrefWidth, headersPrefHeight);
1156 
1157             if (isFloatingStyleClass()) {
1158                 headerBackground.setVisible(false);
1159             } else {
1160                 headerBackground.resize(snapSize(getWidth()), snapSize(getHeight()));
1161                 headerBackground.setVisible(true);
1162             }
1163 
1164             double startX = 0;
1165             double startY = 0;
1166             double controlStartX = 0;
1167             double controlStartY = 0;
1168             Side tabPosition = getSkinnable().getSide();
1169 
1170             if (tabPosition.equals(Side.TOP)) {
1171                 startX = leftInset;
1172                 startY = tabBackgroundHeight - headersPrefHeight - bottomInset;
1173                 controlStartX = w - btnWidth + leftInset;
1174                 controlStartY = snapSize(getHeight()) - btnHeight - bottomInset;
1175             } else if (tabPosition.equals(Side.RIGHT)) {
1176                 startX = topInset;
1177                 startY = tabBackgroundHeight - headersPrefHeight - leftInset;
1178                 controlStartX = w - btnWidth + topInset;
1179                 controlStartY = snapSize(getHeight()) - btnHeight - leftInset;
1180             } else if (tabPosition.equals(Side.BOTTOM)) {
1181                 startX = snapSize(getWidth()) - headersPrefWidth - leftInset;
1182                 startY = tabBackgroundHeight - headersPrefHeight - topInset;
1183                 controlStartX = rightInset;
1184                 controlStartY = snapSize(getHeight()) - btnHeight - topInset;
1185             } else if (tabPosition.equals(Side.LEFT)) {
1186                 startX = snapSize(getWidth()) - headersPrefWidth - topInset;
1187                 startY = tabBackgroundHeight - headersPrefHeight - rightInset;
1188                 controlStartX = leftInset;
1189                 controlStartY = snapSize(getHeight()) - btnHeight - rightInset;
1190             }
1191             if (headerBackground.isVisible()) {
1192                 positionInArea(headerBackground, 0, 0,
1193                         snapSize(getWidth()), snapSize(getHeight()), /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
1194             }
1195             positionInArea(headersRegion, startX, startY, w, h, /*baseline ignored*/0, HPos.LEFT, VPos.CENTER);
1196             positionInArea(controlButtons, controlStartX, controlStartY, btnWidth, btnHeight,
1197                         /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
1198         }
1199     } /* End TabHeaderArea */
1200 
1201 
1202 
1203 
1204     /**************************************************************************
1205      *
1206      * TabHeaderSkin: skin for each tab
1207      *
1208      **************************************************************************/
1209 
1210     class TabHeaderSkin extends StackPane {
1211         private final Tab tab;
1212         public Tab getTab() {
1213             return tab;
1214         }
1215         private Label label;
1216         private StackPane closeBtn;
1217         private StackPane inner;
1218         private Tooltip oldTooltip;
1219         private Tooltip tooltip;
1220         private Rectangle clip;
1221 
1222         private boolean isClosing = false;
1223 
1224         private LambdaMultiplePropertyChangeListenerHandler listener = new LambdaMultiplePropertyChangeListenerHandler();
1225 
1226         private final ListChangeListener&lt;String&gt; styleClassListener = new ListChangeListener&lt;String&gt;() {
1227             @Override
1228             public void onChanged(Change&lt;? extends String&gt; c) {
1229                 getStyleClass().setAll(tab.getStyleClass());
1230             }
1231         };
1232 
1233         private final WeakListChangeListener&lt;String&gt; weakStyleClassListener =
1234                 new WeakListChangeListener&lt;&gt;(styleClassListener);
1235 
1236         public TabHeaderSkin(final Tab tab) {
1237             getStyleClass().setAll(tab.getStyleClass());
1238             setId(tab.getId());
1239             setStyle(tab.getStyle());
1240             setAccessibleRole(AccessibleRole.TAB_ITEM);
1241             setViewOrder(1);
1242 
1243             this.tab = tab;
1244             clip = new Rectangle();
1245             setClip(clip);
1246 
1247             label = new Label(tab.getText(), tab.getGraphic());
1248             label.getStyleClass().setAll(&quot;tab-label&quot;);
1249 
1250             closeBtn = new StackPane() {
1251                 @Override protected double computePrefWidth(double h) {
1252                     return CLOSE_BTN_SIZE;
1253                 }
1254                 @Override protected double computePrefHeight(double w) {
1255                     return CLOSE_BTN_SIZE;
1256                 }
1257                 @Override
1258                 public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
1259                     switch (action) {
1260                         case FIRE: {
1261                             Tab tab = getTab();
1262                             if (behavior.canCloseTab(tab)) {
1263                                 behavior.closeTab(tab);
1264                                 setOnMousePressed(null);
1265                             }
1266                             break;
1267                         }
1268                         default: super.executeAccessibleAction(action, parameters);
1269                     }
1270                 }
1271             };
1272             closeBtn.setAccessibleRole(AccessibleRole.BUTTON);
1273             closeBtn.setAccessibleText(getString(&quot;Accessibility.title.TabPane.CloseButton&quot;));
1274             closeBtn.getStyleClass().setAll(&quot;tab-close-button&quot;);
1275             closeBtn.setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
1276                 @Override
1277                 public void handle(MouseEvent me) {
1278                     Tab tab = getTab();
1279                     if (me.getButton().equals(MouseButton.PRIMARY) &amp;&amp; behavior.canCloseTab(tab)) {
1280                         behavior.closeTab(tab);
1281                         setOnMousePressed(null);
1282                         me.consume();
1283                     }
1284                 }
1285             });
1286 
1287             updateGraphicRotation();
1288 
1289             final Region focusIndicator = new Region();
1290             focusIndicator.setMouseTransparent(true);
1291             focusIndicator.getStyleClass().add(&quot;focus-indicator&quot;);
1292 
1293             inner = new StackPane() {
1294                 @Override protected void layoutChildren() {
1295                     final TabPane skinnable = getSkinnable();
1296 
1297                     final double paddingTop = snappedTopInset();
1298                     final double paddingRight = snappedRightInset();
1299                     final double paddingBottom = snappedBottomInset();
1300                     final double paddingLeft = snappedLeftInset();
1301                     final double w = getWidth() - (paddingLeft + paddingRight);
1302                     final double h = getHeight() - (paddingTop + paddingBottom);
1303 
1304                     final double prefLabelWidth = snapSize(label.prefWidth(-1));
1305                     final double prefLabelHeight = snapSize(label.prefHeight(-1));
1306 
1307                     final double closeBtnWidth = showCloseButton() ? snapSize(closeBtn.prefWidth(-1)) : 0;
1308                     final double closeBtnHeight = showCloseButton() ? snapSize(closeBtn.prefHeight(-1)) : 0;
1309                     final double minWidth = snapSize(skinnable.getTabMinWidth());
1310                     final double maxWidth = snapSize(skinnable.getTabMaxWidth());
1311                     final double maxHeight = snapSize(skinnable.getTabMaxHeight());
1312 
1313                     double labelAreaWidth = prefLabelWidth;
1314                     double labelWidth = prefLabelWidth;
1315                     double labelHeight = prefLabelHeight;
1316 
1317                     final double childrenWidth = labelAreaWidth + closeBtnWidth;
1318                     final double childrenHeight = Math.max(labelHeight, closeBtnHeight);
1319 
1320                     if (childrenWidth &gt; maxWidth &amp;&amp; maxWidth != Double.MAX_VALUE) {
1321                         labelAreaWidth = maxWidth - closeBtnWidth;
1322                         labelWidth = maxWidth - closeBtnWidth;
1323                     } else if (childrenWidth &lt; minWidth) {
1324                         labelAreaWidth = minWidth - closeBtnWidth;
1325                     }
1326 
1327                     if (childrenHeight &gt; maxHeight &amp;&amp; maxHeight != Double.MAX_VALUE) {
1328                         labelHeight = maxHeight;
1329                     }
1330 
1331                     if (animationState != TabAnimationState.NONE) {
1332 //                        if (prefWidth.getValue() &lt; labelAreaWidth) {
1333 //                            labelAreaWidth = prefWidth.getValue();
1334 //                        }
1335                         labelAreaWidth *= animationTransition.get();
1336                         closeBtn.setVisible(false);
1337                     } else {
1338                         closeBtn.setVisible(showCloseButton());
1339                     }
1340 
1341 
1342                     label.resize(labelWidth, labelHeight);
1343 
1344 
1345                     double labelStartX = paddingLeft;
1346 
1347                     // If maxWidth is less than Double.MAX_VALUE, the user has
1348                     // clamped the max width, but we should
1349                     // position the close button at the end of the tab,
1350                     // which may not necessarily be the entire width of the
1351                     // provided max width.
1352                     double closeBtnStartX = (maxWidth &lt; Double.MAX_VALUE ? Math.min(w, maxWidth) : w) - paddingRight - closeBtnWidth;
1353 
1354                     positionInArea(label, labelStartX, paddingTop, labelAreaWidth, h,
1355                             /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
1356 
1357                     if (closeBtn.isVisible()) {
1358                         closeBtn.resize(closeBtnWidth, closeBtnHeight);
1359                         positionInArea(closeBtn, closeBtnStartX, paddingTop, closeBtnWidth, h,
1360                                 /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
1361                     }
1362 
1363                     // Magic numbers regretfully introduced for RT-28944 (so that
1364                     // the focus rect appears as expected on Windows and Mac).
1365                     // In short we use the vPadding to shift the focus rect down
1366                     // into the content area (whereas previously it was being clipped
1367                     // on Windows, whilst it still looked fine on Mac). In the
1368                     // future we may want to improve this code to remove the
1369                     // magic number. Similarly, the hPadding differs on Mac.
1370                     final int vPadding = Utils.isMac() ? 2 : 3;
1371                     final int hPadding = Utils.isMac() ? 2 : 1;
1372                     focusIndicator.resizeRelocate(
1373                             paddingLeft - hPadding,
1374                             paddingTop + vPadding,
1375                             w + 2 * hPadding,
1376                             h - 2 * vPadding);
1377                 }
1378             };
1379             inner.getStyleClass().add(&quot;tab-container&quot;);
1380             inner.setRotate(getSkinnable().getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
1381             inner.getChildren().addAll(label, closeBtn, focusIndicator);
1382 
1383             getChildren().addAll(inner);
1384 
1385             tooltip = tab.getTooltip();
1386             if (tooltip != null) {
1387                 Tooltip.install(this, tooltip);
1388                 oldTooltip = tooltip;
1389             }
1390 
1391             listener.registerChangeListener(tab.closableProperty(), e -&gt; {
1392                 inner.requestLayout();
1393                 requestLayout();
1394             });
1395             listener.registerChangeListener(tab.selectedProperty(), e -&gt; {
1396                 pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
1397                 // Need to request a layout pass for inner because if the width
1398                 // and height didn&#39;t not change the label or close button may have
1399                 // changed.
1400                 inner.requestLayout();
1401                 requestLayout();
1402             });
1403             listener.registerChangeListener(tab.textProperty(),e -&gt; label.setText(getTab().getText()));
1404             listener.registerChangeListener(tab.graphicProperty(), e -&gt; label.setGraphic(getTab().getGraphic()));
1405             listener.registerChangeListener(tab.tooltipProperty(), e -&gt; {
1406                 // uninstall the old tooltip
1407                 if (oldTooltip != null) {
1408                     Tooltip.uninstall(this, oldTooltip);
1409                 }
1410                 tooltip = tab.getTooltip();
1411                 if (tooltip != null) {
1412                     // install new tooltip and save as old tooltip.
1413                     Tooltip.install(this, tooltip);
1414                     oldTooltip = tooltip;
1415                 }
1416             });
1417             listener.registerChangeListener(tab.disabledProperty(), e -&gt; {
1418                 updateTabDisabledState();
1419             });
1420             listener.registerChangeListener(tab.getTabPane().disabledProperty(), e -&gt; {
1421                 updateTabDisabledState();
1422             });
1423             listener.registerChangeListener(tab.styleProperty(), e -&gt; setStyle(tab.getStyle()));
1424 
1425             tab.getStyleClass().addListener(weakStyleClassListener);
1426 
1427             listener.registerChangeListener(getSkinnable().tabClosingPolicyProperty(),e -&gt; {
1428                 inner.requestLayout();
1429                 requestLayout();
1430             });
1431             listener.registerChangeListener(getSkinnable().sideProperty(),e -&gt; {
1432                 final Side side = getSkinnable().getSide();
1433                 pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
1434                 pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
1435                 pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
1436                 pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
1437                 inner.setRotate(side == Side.BOTTOM ? 180.0F : 0.0F);
1438                 if (getSkinnable().isRotateGraphic()) {
1439                     updateGraphicRotation();
1440                 }
1441             });
1442             listener.registerChangeListener(getSkinnable().rotateGraphicProperty(), e -&gt; updateGraphicRotation());
1443             listener.registerChangeListener(getSkinnable().tabMinWidthProperty(), e -&gt; {
1444                 requestLayout();
1445                 getSkinnable().requestLayout();
1446             });
1447             listener.registerChangeListener(getSkinnable().tabMaxWidthProperty(), e -&gt; {
1448                 requestLayout();
1449                 getSkinnable().requestLayout();
1450             });
1451             listener.registerChangeListener(getSkinnable().tabMinHeightProperty(), e -&gt; {
1452                 requestLayout();
1453                 getSkinnable().requestLayout();
1454             });
1455             listener.registerChangeListener(getSkinnable().tabMaxHeightProperty(), e -&gt; {
1456                 requestLayout();
1457                 getSkinnable().requestLayout();
1458             });
1459 
1460             getProperties().put(Tab.class, tab);
1461             getProperties().put(ContextMenu.class, tab.getContextMenu());
1462 
1463             setOnContextMenuRequested((ContextMenuEvent me) -&gt; {
1464                if (getTab().getContextMenu() != null) {
1465                     getTab().getContextMenu().show(inner, me.getScreenX(), me.getScreenY());
1466                     me.consume();
1467                 }
1468             });
1469             setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
1470                 @Override public void handle(MouseEvent me) {
1471                     Tab tab = getTab();
1472                     if (tab.isDisable()) {
1473                         return;
1474                     }
1475                     if (me.getButton().equals(MouseButton.MIDDLE)
1476                         || me.getButton().equals(MouseButton.PRIMARY)) {
1477 
1478                         if (tab.getContextMenu() != null
1479                             &amp;&amp; tab.getContextMenu().isShowing()) {
1480                             tab.getContextMenu().hide();
1481                         }
1482                     }
1483                     if (me.getButton().equals(MouseButton.MIDDLE)) {
1484                         if (showCloseButton()) {
1485                             if (behavior.canCloseTab(tab)) {
1486                                 removeListeners(tab);
1487                                 behavior.closeTab(tab);
1488                             }
1489                         }
1490                     } else if (me.getButton().equals(MouseButton.PRIMARY)) {
1491                         behavior.selectTab(tab);
1492                     }
1493                 }
1494             });
1495 
1496             // initialize pseudo-class state
1497             pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
1498             pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
1499             final Side side = getSkinnable().getSide();
1500             pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
1501             pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
1502             pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
1503             pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
1504         }
1505 
1506         private void updateTabDisabledState() {
1507             pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
1508             inner.requestLayout();
1509             requestLayout();
1510         }
1511 
1512         private void updateGraphicRotation() {
1513             if (label.getGraphic() != null) {
1514                 label.getGraphic().setRotate(getSkinnable().isRotateGraphic() ? 0.0F :
1515                     (getSkinnable().getSide().equals(Side.RIGHT) ? -90.0F :
1516                         (getSkinnable().getSide().equals(Side.LEFT) ? 90.0F : 0.0F)));
1517             }
1518         }
1519 
1520         private boolean showCloseButton() {
1521             return tab.isClosable() &amp;&amp;
1522                     (getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.ALL_TABS) ||
1523                     getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.SELECTED_TAB) &amp;&amp; tab.isSelected());
1524         }
1525 
1526         private final DoubleProperty animationTransition = new SimpleDoubleProperty(this, &quot;animationTransition&quot;, 1.0) {
1527             @Override protected void invalidated() {
1528                 requestLayout();
1529             }
1530         };
1531 
1532         private void removeListeners(Tab tab) {
1533             listener.dispose();
1534             inner.getChildren().clear();
1535             getChildren().clear();
1536             setOnContextMenuRequested(null);
1537             setOnMousePressed(null);
1538         }
1539 
1540         private TabAnimationState animationState = TabAnimationState.NONE;
1541         private Timeline currentAnimation;
1542 
1543         @Override protected double computePrefWidth(double height) {
1544 //            if (animating) {
1545 //                return prefWidth.getValue();
1546 //            }
1547             double minWidth = snapSize(getSkinnable().getTabMinWidth());
1548             double maxWidth = snapSize(getSkinnable().getTabMaxWidth());
1549             double paddingRight = snappedRightInset();
1550             double paddingLeft = snappedLeftInset();
1551             double tmpPrefWidth = snapSize(label.prefWidth(-1));
1552 
1553             // only include the close button width if it is relevant
1554             if (showCloseButton()) {
1555                 tmpPrefWidth += snapSize(closeBtn.prefWidth(-1));
1556             }
1557 
1558             if (tmpPrefWidth &gt; maxWidth) {
1559                 tmpPrefWidth = maxWidth;
1560             } else if (tmpPrefWidth &lt; minWidth) {
1561                 tmpPrefWidth = minWidth;
1562             }
1563             tmpPrefWidth += paddingRight + paddingLeft;
1564 //            prefWidth.setValue(tmpPrefWidth);
1565             return tmpPrefWidth;
1566         }
1567 
1568         @Override protected double computePrefHeight(double width) {
1569             double minHeight = snapSize(getSkinnable().getTabMinHeight());
1570             double maxHeight = snapSize(getSkinnable().getTabMaxHeight());
1571             double paddingTop = snappedTopInset();
1572             double paddingBottom = snappedBottomInset();
1573             double tmpPrefHeight = snapSize(label.prefHeight(width));
1574 
1575             if (tmpPrefHeight &gt; maxHeight) {
1576                 tmpPrefHeight = maxHeight;
1577             } else if (tmpPrefHeight &lt; minHeight) {
1578                 tmpPrefHeight = minHeight;
1579             }
1580             tmpPrefHeight += paddingTop + paddingBottom;
1581             return tmpPrefHeight;
1582         }
1583 
1584         @Override protected void layoutChildren() {
1585             double w = (snapSize(getWidth()) - snappedRightInset() - snappedLeftInset()) * animationTransition.getValue();
1586             inner.resize(w, snapSize(getHeight()) - snappedTopInset() - snappedBottomInset());
1587             inner.relocate(snappedLeftInset(), snappedTopInset());
1588         }
1589 
1590         @Override protected void setWidth(double value) {
1591             super.setWidth(value);
1592             clip.setWidth(value);
1593         }
1594 
1595         @Override protected void setHeight(double value) {
1596             super.setHeight(value);
1597             clip.setHeight(value);
1598         }
1599 
1600         /** {@inheritDoc} */
1601         @Override
1602         public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1603             switch (attribute) {
1604                 case TEXT: return getTab().getText();
1605                 case SELECTED: return selectedTab == getTab();
1606                 default: return super.queryAccessibleAttribute(attribute, parameters);
1607             }
1608         }
1609 
1610         /** {@inheritDoc} */
1611         @Override
1612         public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
1613             switch (action) {
1614                 case REQUEST_FOCUS:
1615                     getSkinnable().getSelectionModel().select(getTab());
1616                     break;
1617                 default: super.executeAccessibleAction(action, parameters);
1618             }
1619         }
1620 
1621     } /* End TabHeaderSkin */
1622 
1623     private static final PseudoClass SELECTED_PSEUDOCLASS_STATE =
1624             PseudoClass.getPseudoClass(&quot;selected&quot;);
1625     private static final PseudoClass TOP_PSEUDOCLASS_STATE =
1626             PseudoClass.getPseudoClass(&quot;top&quot;);
1627     private static final PseudoClass BOTTOM_PSEUDOCLASS_STATE =
1628             PseudoClass.getPseudoClass(&quot;bottom&quot;);
1629     private static final PseudoClass LEFT_PSEUDOCLASS_STATE =
1630             PseudoClass.getPseudoClass(&quot;left&quot;);
1631     private static final PseudoClass RIGHT_PSEUDOCLASS_STATE =
1632             PseudoClass.getPseudoClass(&quot;right&quot;);
1633     private static final PseudoClass DISABLED_PSEUDOCLASS_STATE =
1634             PseudoClass.getPseudoClass(&quot;disabled&quot;);
1635 
1636 
1637     /**************************************************************************
1638      *
1639      * TabContentRegion: each tab has one to contain the tab&#39;s content node
1640      *
1641      **************************************************************************/
1642     static class TabContentRegion extends StackPane {
1643 
1644         private Tab tab;
1645 
1646         private InvalidationListener tabContentListener = valueModel -&gt; {
1647             updateContent();
1648         };
1649         private InvalidationListener tabSelectedListener = new InvalidationListener() {
1650             @Override public void invalidated(Observable valueModel) {
1651                 setVisible(tab.isSelected());
1652             }
1653         };
1654 
1655         private WeakInvalidationListener weakTabContentListener =
1656                 new WeakInvalidationListener(tabContentListener);
1657         private WeakInvalidationListener weakTabSelectedListener =
1658                 new WeakInvalidationListener(tabSelectedListener);
1659 
1660         public Tab getTab() {
1661             return tab;
1662         }
1663 
1664         public TabContentRegion(Tab tab) {
1665             getStyleClass().setAll(&quot;tab-content-area&quot;);
1666             setManaged(false);
1667             this.tab = tab;
1668             updateContent();
1669             setVisible(tab.isSelected());
1670 
1671             tab.selectedProperty().addListener(weakTabSelectedListener);
1672             tab.contentProperty().addListener(weakTabContentListener);
1673         }
1674 
1675         private void updateContent() {
1676             Node newContent = getTab().getContent();
1677             if (newContent == null) {
1678                 getChildren().clear();
1679             } else {
1680                 getChildren().setAll(newContent);
1681             }
1682         }
1683 
1684         private void removeListeners(Tab tab) {
1685             tab.selectedProperty().removeListener(weakTabSelectedListener);
1686             tab.contentProperty().removeListener(weakTabContentListener);
1687         }
1688 
1689     } /* End TabContentRegion */
1690 
1691     /**************************************************************************
1692      *
1693      * TabControlButtons: controls to manipulate tab interaction
1694      *
1695      **************************************************************************/
1696     class TabControlButtons extends StackPane {
1697         private StackPane inner;
1698         private StackPane downArrow;
1699         private Pane downArrowBtn;
1700         private boolean showControlButtons;
1701         private ContextMenu popup;
1702 
1703         public TabControlButtons() {
1704             getStyleClass().setAll(&quot;control-buttons-tab&quot;);
1705 
1706             TabPane tabPane = getSkinnable();
1707 
1708             downArrowBtn = new Pane();
1709             downArrowBtn.getStyleClass().setAll(&quot;tab-down-button&quot;);
1710             downArrowBtn.setVisible(isShowTabsMenu());
1711             downArrow = new StackPane();
1712             downArrow.setManaged(false);
1713             downArrow.getStyleClass().setAll(&quot;arrow&quot;);
1714             downArrow.setRotate(tabPane.getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
1715             downArrowBtn.getChildren().add(downArrow);
1716             downArrowBtn.setOnMouseClicked(me -&gt; {
1717                 showPopupMenu();
1718             });
1719 
1720             setupPopupMenu();
1721 
1722             inner = new StackPane() {
1723                 @Override protected double computePrefWidth(double height) {
1724                     double pw;
1725                     double maxArrowWidth = ! isShowTabsMenu() ? 0 : snapSize(downArrow.prefWidth(getHeight())) + snapSize(downArrowBtn.prefWidth(getHeight()));
1726                     pw = 0.0F;
1727                     if (isShowTabsMenu()) {
1728                         pw += maxArrowWidth;
1729                     }
1730                     if (pw &gt; 0) {
1731                         pw += snappedLeftInset() + snappedRightInset();
1732                     }
1733                     return pw;
1734                 }
1735 
1736                 @Override protected double computePrefHeight(double width) {
1737                     double height = 0.0F;
1738                     if (isShowTabsMenu()) {
1739                         height = Math.max(height, snapSize(downArrowBtn.prefHeight(width)));
1740                     }
1741                     if (height &gt; 0) {
1742                         height += snappedTopInset() + snappedBottomInset();
1743                     }
1744                     return height;
1745                 }
1746 
1747                 @Override protected void layoutChildren() {
1748                     if (isShowTabsMenu()) {
1749                         double x = 0;
1750                         double y = snappedTopInset();
1751                         double w = snapSize(getWidth()) - x + snappedLeftInset();
1752                         double h = snapSize(getHeight()) - y + snappedBottomInset();
1753                         positionArrow(downArrowBtn, downArrow, x, y, w, h);
1754                     }
1755                 }
1756 
1757                 private void positionArrow(Pane btn, StackPane arrow, double x, double y, double width, double height) {
1758                     btn.resize(width, height);
1759                     positionInArea(btn, x, y, width, height, /*baseline ignored*/0,
1760                             HPos.CENTER, VPos.CENTER);
1761                     // center arrow region within arrow button
1762                     double arrowWidth = snapSize(arrow.prefWidth(-1));
1763                     double arrowHeight = snapSize(arrow.prefHeight(-1));
1764                     arrow.resize(arrowWidth, arrowHeight);
1765                     positionInArea(arrow, btn.snappedLeftInset(), btn.snappedTopInset(),
1766                             width - btn.snappedLeftInset() - btn.snappedRightInset(),
1767                             height - btn.snappedTopInset() - btn.snappedBottomInset(),
1768                             /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
1769                 }
1770             };
1771             inner.getStyleClass().add(&quot;container&quot;);
1772             inner.getChildren().add(downArrowBtn);
1773 
1774             getChildren().add(inner);
1775 
1776             tabPane.sideProperty().addListener(valueModel -&gt; {
1777                 Side tabPosition = getSkinnable().getSide();
1778                 downArrow.setRotate(tabPosition.equals(Side.BOTTOM)? 180.0F : 0.0F);
1779             });
1780             tabPane.getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; setupPopupMenu());
1781             showControlButtons = false;
1782             if (isShowTabsMenu()) {
1783                 showControlButtons = true;
1784                 requestLayout();
1785             }
1786             getProperties().put(ContextMenu.class, popup);
1787         }
1788 
1789         private boolean showTabsMenu = false;
1790 
1791         private void showTabsMenu(boolean value) {
1792             final boolean wasTabsMenuShowing = isShowTabsMenu();
1793             this.showTabsMenu = value;
1794 
1795             if (showTabsMenu &amp;&amp; !wasTabsMenuShowing) {
1796                 downArrowBtn.setVisible(true);
1797                 showControlButtons = true;
1798                 inner.requestLayout();
1799                 tabHeaderArea.requestLayout();
1800             } else if (!showTabsMenu &amp;&amp; wasTabsMenuShowing) {
1801                 hideControlButtons();
1802             }
1803         }
1804 
1805         private boolean isShowTabsMenu() {
1806             return showTabsMenu;
1807         }
1808 
1809         @Override protected double computePrefWidth(double height) {
1810             double pw = snapSize(inner.prefWidth(height));
1811             if (pw &gt; 0) {
1812                 pw += snappedLeftInset() + snappedRightInset();
1813             }
1814             return pw;
1815         }
1816 
1817         @Override protected double computePrefHeight(double width) {
1818             return Math.max(getSkinnable().getTabMinHeight(), snapSize(inner.prefHeight(width))) +
1819                     snappedTopInset() + snappedBottomInset();
1820         }
1821 
1822         @Override protected void layoutChildren() {
1823             double x = snappedLeftInset();
1824             double y = snappedTopInset();
1825             double w = snapSize(getWidth()) - x + snappedRightInset();
1826             double h = snapSize(getHeight()) - y + snappedBottomInset();
1827 
1828             if (showControlButtons) {
1829                 showControlButtons();
1830                 showControlButtons = false;
1831             }
1832 
1833             inner.resize(w, h);
1834             positionInArea(inner, x, y, w, h, /*baseline ignored*/0, HPos.CENTER, VPos.BOTTOM);
1835         }
1836 
1837         private void showControlButtons() {
1838             setVisible(true);
1839             if (popup == null) {
1840                 setupPopupMenu();
1841             }
1842         }
1843 
1844         private void hideControlButtons() {
1845             // If the scroll arrows or tab menu is still visible we don&#39;t want
1846             // to hide it animate it back it.
1847             if (isShowTabsMenu()) {
1848                 showControlButtons = true;
1849             } else {
1850                 setVisible(false);
1851                 clearPopupMenu();
1852                 popup = null;
1853             }
1854 
1855             // This needs to be called when we are in the left tabPosition
1856             // to allow for the clip offset to move properly (otherwise
1857             // it jumps too early - before the animation is done).
1858             requestLayout();
1859         }
1860 
1861         private void setupPopupMenu() {
1862             if (popup == null) {
1863                 popup = new ContextMenu();
1864             }
1865             clearPopupMenu();
1866             ToggleGroup group = new ToggleGroup();
1867             ObservableList&lt;RadioMenuItem&gt; menuitems = FXCollections.&lt;RadioMenuItem&gt;observableArrayList();
1868             for (final Tab tab : getSkinnable().getTabs()) {
1869                 TabMenuItem item = new TabMenuItem(tab);
1870                 item.setToggleGroup(group);
1871                 item.setOnAction(t -&gt; getSkinnable().getSelectionModel().select(tab));
1872                 menuitems.add(item);
1873             }
1874             popup.getItems().addAll(menuitems);
1875         }
1876 
1877         private void clearPopupMenu() {
1878             for (MenuItem item : popup.getItems()) {
1879                 ((TabMenuItem) item).dispose();
1880             }
1881             popup.getItems().clear();
1882         }
1883 
1884         private void showPopupMenu() {
1885             for (MenuItem mi: popup.getItems()) {
1886                 TabMenuItem tmi = (TabMenuItem)mi;
1887                 if (selectedTab.equals(tmi.getTab())) {
1888                     tmi.setSelected(true);
1889                     break;
1890                 }
1891             }
1892             popup.show(downArrowBtn, Side.BOTTOM, 0, 0);
1893         }
1894     } /* End TabControlButtons*/
1895 
1896     static class TabMenuItem extends RadioMenuItem {
1897         Tab tab;
1898 
1899         private InvalidationListener disableListener = new InvalidationListener() {
1900             @Override public void invalidated(Observable o) {
1901                 setDisable(tab.isDisable());
1902             }
1903         };
1904 
1905         private WeakInvalidationListener weakDisableListener =
1906                 new WeakInvalidationListener(disableListener);
1907 
1908         public TabMenuItem(final Tab tab) {
1909             super(tab.getText(), TabPaneSkin.clone(tab.getGraphic()));
1910             this.tab = tab;
1911             setDisable(tab.isDisable());
1912             tab.disableProperty().addListener(weakDisableListener);
1913             textProperty().bind(tab.textProperty());
1914         }
1915 
1916         public Tab getTab() {
1917             return tab;
1918         }
1919 
1920         public void dispose() {
1921             textProperty().unbind();
1922             tab.disableProperty().removeListener(weakDisableListener);
1923             tab = null;
1924         }
1925     }
1926 
1927     @Override
1928     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1929         switch (attribute) {
1930             case FOCUS_ITEM: return tabHeaderArea.getTabHeaderSkin(selectedTab);
1931             case ITEM_COUNT: return tabHeaderArea.headersRegion.getChildren().size();
1932             case ITEM_AT_INDEX: {
1933                 Integer index = (Integer)parameters[0];
1934                 if (index == null) return null;
1935                 return tabHeaderArea.headersRegion.getChildren().get(index);
1936             }
1937             default: return super.queryAccessibleAttribute(attribute, parameters);
1938         }
1939     }
1940 
1941     // --------------------------
1942     // Tab Reordering
1943     // --------------------------
1944     private enum DragState {
1945         NONE,
1946         START,
1947         REORDER
1948     }
1949     private EventHandler&lt;MouseEvent&gt; headerDraggedHandler = this::handleHeaderDragged;
1950     private EventHandler&lt;MouseEvent&gt; headerMousePressedHandler = this::handleHeaderMousePressed;
1951     private EventHandler&lt;MouseEvent&gt; headerMouseReleasedHandler = this::handleHeaderMouseReleased;
1952 
1953     private int dragTabHeaderStartIndex;
1954     private int dragTabHeaderIndex;
1955     private TabHeaderSkin dragTabHeader;
1956     private TabHeaderSkin dropTabHeader;
1957     private StackPane headersRegion;
1958     private DragState dragState;
1959     private final int MIN_TO_MAX = 1;
1960     private final int MAX_TO_MIN = -1;
1961     private int xLayoutDirection;
1962     private double dragEventPrevLoc;
1963     private int prevDragDirection = MIN_TO_MAX;
1964     private final double DRAG_DIST_THRESHOLD = 0.75;
1965 
1966     // Reordering Animation
1967     private final double ANIM_DURATION = 120;
1968     private TabHeaderSkin dropAnimHeader;
1969     private double dropHeaderSourceX;
1970     private double dropHeaderTransitionX;
1971     private final Animation dropHeaderAnim = new Transition() {
1972         {
1973             setInterpolator(Interpolator.EASE_BOTH);
1974             setCycleDuration(Duration.millis(ANIM_DURATION));
1975             setOnFinished(event -&gt; {
1976                 completeHeaderReordering();
1977             });
1978         }
1979         protected void interpolate(double frac) {
1980             dropAnimHeader.setLayoutX(dropHeaderSourceX + dropHeaderTransitionX * frac);
1981         }
1982     };
1983     private double dragHeaderDestX;
1984     private double dragHeaderSourceX;
1985     private double dragHeaderTransitionX;
1986     private final Animation dragHeaderAnim = new Transition() {
1987         {
1988             setInterpolator(Interpolator.EASE_OUT);
1989             setCycleDuration(Duration.millis(ANIM_DURATION));
1990             setOnFinished(event -&gt; {
1991                 reorderTabs();
1992                 resetDrag();
1993             });
1994         }
1995         protected void interpolate(double frac) {
1996             dragTabHeader.setLayoutX(dragHeaderSourceX + dragHeaderTransitionX * frac);
1997         }
1998     };
1999 
2000     // Helper methods for managing the listeners based on TabDragPolicy.
2001     private void addReorderListeners(Node n) {
2002         n.addEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
2003         n.addEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
2004         n.addEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
2005     }
2006 
2007     private void removeReorderListeners(Node n) {
2008         n.removeEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
2009         n.removeEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
2010         n.removeEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
2011     }
2012 
2013     private ListChangeListener childListener = new ListChangeListener&lt;Node&gt;() {
2014         public void onChanged(Change&lt;? extends Node&gt; change) {
2015             while (change.next()) {
2016                 if (change.wasAdded()) {
2017                     for(Node n : change.getAddedSubList()) {
2018                         addReorderListeners(n);
2019                     }
2020                 }
2021                 if (change.wasRemoved()) {
2022                     for(Node n : change.getRemoved()) {
2023                         removeReorderListeners(n);
2024                     }
2025                 }
2026             }
2027         }
2028     };
2029 
2030     private void updateListeners() {
2031         if (getSkinnable().getTabDragPolicy() == TabDragPolicy.FIXED ||
2032                 getSkinnable().getTabDragPolicy() == null) {
2033             for (Node n : headersRegion.getChildren()) {
2034                 removeReorderListeners(n);
2035             }
2036             headersRegion.getChildren().removeListener(childListener);
2037         } else if (getSkinnable().getTabDragPolicy() == TabDragPolicy.REORDER) {
2038             for (Node n : headersRegion.getChildren()) {
2039                 addReorderListeners(n);
2040             }
2041             headersRegion.getChildren().addListener(childListener);
2042         }
2043     }
2044 
2045     private void setupReordering(StackPane headersRegion) {
2046         dragState = DragState.NONE;
2047         this.headersRegion = headersRegion;
2048         updateListeners();
2049         getSkinnable().tabDragPolicyProperty().addListener((observable, oldValue, newValue) -&gt; {
2050             if (oldValue != newValue) {
2051                 updateListeners();
2052             }
2053         });
2054     }
2055 
2056     private void handleHeaderMousePressed(MouseEvent event) {
2057         if (event.getButton().equals(MouseButton.PRIMARY)) {
2058             ((StackPane) event.getSource()).setMouseTransparent(true);
2059             startDrag(event);
2060         }
2061     }
2062 
2063     private void handleHeaderMouseReleased(MouseEvent event) {
2064         if (event.getButton().equals(MouseButton.PRIMARY)) {
2065             ((StackPane) event.getSource()).setMouseTransparent(false);
2066             stopDrag();
2067             event.consume();
2068         }
2069     }
2070 
2071     private void handleHeaderDragged(MouseEvent event) {
2072         if (event.getButton().equals(MouseButton.PRIMARY)) {
2073             performDrag(event);
2074         }
2075     }
2076 
2077     private double getDragDelta(double curr, double prev) {
2078         if (getSkinnable().getSide().equals(Side.TOP) ||
2079                 getSkinnable().getSide().equals(Side.RIGHT)) {
2080             return curr - prev;
2081         } else {
2082             return prev - curr;
2083         }
2084     }
2085 
2086     private int deriveTabHeaderLayoutXDirection() {
2087         if (getSkinnable().getSide().equals(Side.TOP) ||
2088                 getSkinnable().getSide().equals(Side.RIGHT)) {
2089             // TabHeaderSkin are laid out in left to right direction inside headersRegion
2090             return MIN_TO_MAX;
2091         }
2092         // TabHeaderSkin are laid out in right to left direction inside headersRegion
2093         return MAX_TO_MIN;
2094     }
2095 
2096     private void performDrag(MouseEvent event) {
2097         if (dragState == DragState.NONE) {
2098             return;
2099         }
2100         int dragDirection;
2101         double dragHeaderNewLayoutX;
2102         Bounds dragHeaderBounds;
2103         Bounds dropHeaderBounds;
2104         double draggedDist;
2105         double mouseCurrentLoc = getHeaderRegionLocalX(event);
2106         double dragDelta = getDragDelta(mouseCurrentLoc, dragEventPrevLoc);
2107 
2108         if (dragDelta &gt; 0) {
2109             // Dragging the tab header towards higher indexed tab headers inside headersRegion.
2110             dragDirection = MIN_TO_MAX;
2111         } else {
2112             // Dragging the tab header towards lower indexed tab headers inside headersRegion.
2113             dragDirection = MAX_TO_MIN;
2114         }
2115         // Stop dropHeaderAnim if direction of drag is changed
2116         if (prevDragDirection != dragDirection) {
2117             stopAnim(dropHeaderAnim);
2118             prevDragDirection = dragDirection;
2119         }
2120 
2121         dragHeaderNewLayoutX = dragTabHeader.getLayoutX() + xLayoutDirection * dragDelta;
2122 
2123         if (dragHeaderNewLayoutX &gt;= 0 &amp;&amp;
2124                 dragHeaderNewLayoutX + dragTabHeader.getWidth() &lt;= headersRegion.getWidth()) {
2125 
2126             dragState = DragState.REORDER;
2127             dragTabHeader.setLayoutX(dragHeaderNewLayoutX);
2128             dragHeaderBounds = dragTabHeader.getBoundsInParent();
2129 
2130             if (dragDirection == MIN_TO_MAX) {
2131                 // Dragging the tab header towards higher indexed tab headers
2132                 // Last tab header can not be dragged outside headersRegion.
2133 
2134                 // When the mouse is moved too fast, sufficient number of events
2135                 // are not generated. Hence it is required to check all possible
2136                 // headers to be reordered.
2137                 for (int i = dragTabHeaderIndex + 1; i &lt; headersRegion.getChildren().size(); i++) {
2138                     dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);
2139 
2140                     // dropTabHeader should not be already reordering.
2141                     if (dropAnimHeader != dropTabHeader) {
2142                         dropHeaderBounds = dropTabHeader.getBoundsInParent();
2143 
2144                         if (xLayoutDirection == MIN_TO_MAX) {
2145                             draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
2146                         } else {
2147                             draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
2148                         }
2149 
2150                         // A tab header is reordered when dragged tab header crosses DRAG_DIST_THRESHOLD% of next tab header&#39;s width.
2151                         if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
2152                             stopAnim(dropHeaderAnim);
2153                             // Distance by which tab header should be animated.
2154                             dropHeaderTransitionX = xLayoutDirection * -dragHeaderBounds.getWidth();
2155                             if (xLayoutDirection == MIN_TO_MAX) {
2156                                 dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
2157                             } else {
2158                                 dragHeaderDestX = dropHeaderBounds.getMinX();
2159                             }
2160                             startHeaderReorderingAnim();
2161                         } else {
2162                             break;
2163                         }
2164                     }
2165                 }
2166             } else {
2167                 // dragDirection is MAX_TO_MIN
2168                 // Dragging the tab header towards lower indexed tab headers.
2169                 // First tab header can not be dragged outside headersRegion.
2170 
2171                 // When the mouse is moved too fast, sufficient number of events
2172                 // are not generated. Hence it is required to check all possible
2173                 // tab headers to be reordered.
2174                 for (int i = dragTabHeaderIndex - 1; i &gt;= 0; i--) {
2175                     dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);
2176 
2177                     // dropTabHeader should not be already reordering.
2178                     if (dropAnimHeader != dropTabHeader) {
2179                         dropHeaderBounds = dropTabHeader.getBoundsInParent();
2180 
2181                         if (xLayoutDirection == MIN_TO_MAX) {
2182                             draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
2183                         } else {
2184                             draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
2185                         }
2186 
2187                         // A tab header is reordered when dragged tab crosses DRAG_DIST_THRESHOLD% of next tab header&#39;s width.
2188                         if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
2189                             stopAnim(dropHeaderAnim);
2190                             // Distance by which tab header should be animated.
2191                             dropHeaderTransitionX = xLayoutDirection * dragHeaderBounds.getWidth();
2192                             if (xLayoutDirection == MIN_TO_MAX) {
2193                                 dragHeaderDestX = dropHeaderBounds.getMinX();
2194                             } else {
2195                                 dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
2196                             }
2197                             startHeaderReorderingAnim();
2198                         } else {
2199                             break;
2200                         }
2201                     }
2202                 }
2203             }
2204         }
2205         dragEventPrevLoc = mouseCurrentLoc;
2206         event.consume();
2207     }
2208 
2209     private void startDrag(MouseEvent event) {
2210         // Stop the animations if any are running from previous reorder.
2211         stopAnim(dropHeaderAnim);
2212         stopAnim(dragHeaderAnim);
2213 
2214         dragTabHeader = (TabHeaderSkin) event.getSource();
2215         if (dragTabHeader != null) {
2216             dragState = DragState.START;
2217             xLayoutDirection = deriveTabHeaderLayoutXDirection();
2218             dragEventPrevLoc = getHeaderRegionLocalX(event);
2219             dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
2220             dragTabHeaderStartIndex = dragTabHeaderIndex;
2221             dragTabHeader.setViewOrder(0);
2222             dragHeaderDestX = dragTabHeader.getLayoutX();
2223         }
2224     }
2225 
2226     private double getHeaderRegionLocalX(MouseEvent ev) {
2227         // The event is converted to tab header&#39;s parent i.e. headersRegion&#39;s local space.
2228         // This will provide a value of X co-ordinate with all transformations of TabPane
2229         // and transformations of all nodes in the TabPane&#39;s parent hierarchy.
2230         Point2D sceneToLocalHR = headersRegion.sceneToLocal(ev.getSceneX(), ev.getSceneY());
2231         return sceneToLocalHR.getX();
2232     }
2233 
2234     private void stopDrag() {
2235         if (dragState == DragState.START) {
2236             // No drag action was performed.
2237             resetDrag();
2238         } else if (dragState == DragState.REORDER) {
2239             // Animate tab header being dragged to its final position.
2240             dragHeaderSourceX = dragTabHeader.getLayoutX();
2241             dragHeaderTransitionX = dragHeaderDestX - dragHeaderSourceX;
2242             dragHeaderAnim.playFromStart();
2243         }
2244     }
2245 
2246     private void reorderTabs() {
2247         if (dragTabHeaderIndex != dragTabHeaderStartIndex) {
2248             ((TabObservableList&lt;Tab&gt;) getSkinnable().getTabs()).reorder(
2249                     getSkinnable().getTabs().get(dragTabHeaderStartIndex),
2250                     getSkinnable().getTabs().get(dragTabHeaderIndex));
2251         }
2252     }
2253 
2254     private void resetDrag() {
2255         dragState = DragState.NONE;
2256         dragTabHeader.setViewOrder(1);
2257         dragTabHeader = null;
2258         dropTabHeader = null;
2259         headersRegion.requestLayout();
2260     }
2261 
2262     // Animate tab header being dropped-on to its new position.
2263     private void startHeaderReorderingAnim() {
2264         dropAnimHeader = dropTabHeader;
2265         dropHeaderSourceX = dropAnimHeader.getLayoutX();
2266         dropHeaderAnim.playFromStart();
2267     }
2268 
2269     // Remove dropAnimHeader and add at the index position of dragTabHeader.
2270     private void completeHeaderReordering() {
2271         if (dropAnimHeader != null) {
2272             headersRegion.getChildren().remove(dropAnimHeader);
2273             headersRegion.getChildren().add(dragTabHeaderIndex, dropAnimHeader);
2274             dropAnimHeader = null;
2275             headersRegion.requestLayout();
2276             dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
2277         }
2278     }
2279 
2280     // Helper method to stop an animation.
2281     private void stopAnim(Animation anim) {
2282         if (anim.getStatus() == Animation.Status.RUNNING) {
2283             anim.getOnFinished().handle(null);
2284             anim.stop();
2285         }
2286     }
2287 
2288     // For testing purpose.
2289     ContextMenu test_getTabsMenu() {
2290         return tabHeaderArea.controlButtons.popup;
2291     }
2292 
2293     void test_disableAnimations() {
2294         closeTabAnimation.set(TabAnimation.NONE);
2295         openTabAnimation.set(TabAnimation.NONE);
2296     }
2297 }
    </pre>
  </body>
</html>
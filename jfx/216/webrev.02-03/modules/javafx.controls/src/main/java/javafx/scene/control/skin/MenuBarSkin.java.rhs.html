<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/skin/MenuBarSkin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control.skin;
  27 
  28 import static com.sun.javafx.FXPermissions.ACCESS_WINDOW_LIST_PERMISSION;
  29 
  30 import com.sun.javafx.scene.traversal.Direction;
  31 import javafx.css.converter.EnumConverter;
  32 import javafx.css.converter.SizeConverter;
  33 import com.sun.javafx.scene.control.MenuBarButton;
  34 import com.sun.javafx.scene.control.skin.Utils;
  35 import com.sun.javafx.scene.traversal.ParentTraversalEngine;
  36 import javafx.beans.InvalidationListener;
  37 import javafx.beans.property.DoubleProperty;
  38 import javafx.beans.property.ObjectProperty;
  39 import javafx.beans.property.ReadOnlyProperty;
  40 import javafx.beans.value.ChangeListener;
  41 import javafx.beans.value.WeakChangeListener;
  42 import javafx.beans.value.WritableValue;
  43 import javafx.collections.ListChangeListener;
  44 import javafx.collections.MapChangeListener;
  45 import javafx.collections.ObservableList;
  46 import javafx.css.CssMetaData;
  47 import javafx.css.Styleable;
  48 import javafx.css.StyleableDoubleProperty;
  49 import javafx.css.StyleableObjectProperty;
  50 import javafx.css.StyleableProperty;
  51 import javafx.event.ActionEvent;
  52 import javafx.event.EventHandler;
  53 import javafx.event.WeakEventHandler;
  54 import javafx.geometry.Bounds;
  55 import javafx.geometry.NodeOrientation;
  56 import javafx.geometry.Pos;
  57 import javafx.scene.AccessibleAttribute;
  58 import javafx.scene.Node;
  59 import javafx.scene.Scene;
  60 import javafx.scene.control.Control;
  61 import javafx.scene.control.CustomMenuItem;
  62 import javafx.scene.control.Menu;
  63 import javafx.scene.control.MenuBar;
  64 import javafx.scene.control.MenuButton;
  65 import javafx.scene.control.MenuItem;
  66 import javafx.scene.control.SeparatorMenuItem;
  67 import javafx.scene.control.Skin;
  68 import javafx.scene.control.SkinBase;
  69 import javafx.scene.input.KeyCombination;
  70 import javafx.scene.input.KeyEvent;
  71 import javafx.scene.input.MouseEvent;
  72 import javafx.scene.layout.HBox;
  73 import javafx.stage.Stage;
  74 
  75 import static javafx.scene.input.KeyCode.*;
  76 
  77 import java.lang.ref.Reference;
  78 import java.lang.ref.WeakReference;
  79 import java.util.ArrayList;
  80 import java.util.Collections;
  81 import java.util.Iterator;
  82 import java.util.List;
  83 import java.util.Map;
  84 import java.util.Optional;
  85 import java.util.WeakHashMap;
  86 
  87 import com.sun.javafx.menu.MenuBase;
  88 import com.sun.javafx.scene.ParentHelper;
  89 import com.sun.javafx.scene.SceneHelper;
  90 import com.sun.javafx.scene.control.GlobalMenuAdapter;
  91 import com.sun.javafx.tk.Toolkit;
  92 import java.util.function.Predicate;
  93 import javafx.stage.Window;
  94 import javafx.util.Pair;
  95 
  96 import java.security.AccessController;
  97 import java.security.PrivilegedAction;
  98 
  99 /**
 100  * Default skin implementation for the {@link MenuBar} control. In essence it is
 101  * a simple toolbar. For the time being there is no overflow behavior and we just
 102  * hide nodes which fall outside the bounds.
 103  *
 104  * @see MenuBar
 105  * @since 9
 106  */
 107 public class MenuBarSkin extends SkinBase&lt;MenuBar&gt; {
 108 
 109     private static final ObservableList&lt;Window&gt; stages;
 110 
 111     static {
 112         final Predicate&lt;Window&gt; findStage = (w) -&gt; w instanceof Stage;
 113         ObservableList&lt;Window&gt; windows = AccessController.doPrivileged(
 114             (PrivilegedAction&lt;ObservableList&lt;Window&gt;&gt;) () -&gt; Window.getWindows(),
 115             null,
 116             ACCESS_WINDOW_LIST_PERMISSION);
 117         stages = windows.filtered(findStage);
 118     }
 119 
 120     /***************************************************************************
 121      *                                                                         *
 122      * Private fields                                                          *
 123      *                                                                         *
 124      **************************************************************************/
 125 
 126     private final HBox container;
 127 
 128     // represents the currently _open_ menu
 129     private Menu openMenu;
 130     private MenuBarButton openMenuButton;
 131 
 132     // represents the currently _focused_ menu. If openMenu is non-null, this should equal
 133     // openMenu. If openMenu is null, this can be any menu in the menu bar.
 134     private Menu focusedMenu;
 135     private int focusedMenuIndex = -1;
 136 
 137     private static WeakHashMap&lt;Stage, Reference&lt;MenuBarSkin&gt;&gt; systemMenuMap;
 138     private static List&lt;MenuBase&gt; wrappedDefaultMenus = new ArrayList&lt;&gt;();
 139     private static Stage currentMenuBarStage;
 140     private List&lt;MenuBase&gt; wrappedMenus;
 141 
 142     private WeakEventHandler&lt;KeyEvent&gt; weakSceneKeyEventHandler;
 143     private WeakEventHandler&lt;MouseEvent&gt; weakSceneMouseEventHandler;
 144     private WeakEventHandler&lt;KeyEvent&gt; weakSceneAltKeyEventHandler;
 145     private WeakChangeListener&lt;Boolean&gt; weakWindowFocusListener;
 146     private WeakChangeListener&lt;Window&gt; weakWindowSceneListener;
 147     private EventHandler&lt;KeyEvent&gt; keyEventHandler;
 148     private EventHandler&lt;KeyEvent&gt; altKeyEventHandler;
 149     private EventHandler&lt;MouseEvent&gt; mouseEventHandler;
 150     private ChangeListener&lt;Boolean&gt; menuBarFocusedPropertyListener;
 151     private ChangeListener&lt;Scene&gt; sceneChangeListener;
 152     private ChangeListener&lt;Boolean&gt; menuVisibilityChangeListener;
 153 
 154     private boolean pendingDismiss = false;
 155 
 156     private boolean altKeyPressed = false;
 157 
 158 
 159     /***************************************************************************
 160      *                                                                         *
 161      * Listeners / Callbacks                                                   *
 162      *                                                                         *
 163      **************************************************************************/
 164 
 165     // RT-20411 : reset menu selected/focused state
 166     private EventHandler&lt;ActionEvent&gt; menuActionEventHandler = t -&gt; {
 167         if (t.getSource() instanceof CustomMenuItem) {
 168             // RT-29614 If CustomMenuItem hideOnClick is false, dont hide
 169             CustomMenuItem cmi = (CustomMenuItem)t.getSource();
 170             if (!cmi.isHideOnClick()) return;
 171         }
 172         unSelectMenus();
 173     };
 174 
 175     private ListChangeListener&lt;MenuItem&gt; menuItemListener = (c) -&gt; {
 176         while (c.next()) {
 177             for (MenuItem mi : c.getAddedSubList()) {
 178                 updateActionListeners(mi, true);
 179             }
 180             for (MenuItem mi: c.getRemoved()) {
 181                 updateActionListeners(mi, false);
 182             }
 183         }
 184     };
 185 
 186     Runnable firstMenuRunnable = new Runnable() {
 187         public void run() {
 188             /*
 189             ** check that this menubar&#39;s container has contents,
 190             ** and that the first item is a MenuButton....
 191             ** otherwise the transfer is off!
 192             */
 193             if (container.getChildren().size() &gt; 0) {
 194                 if (container.getChildren().get(0) instanceof MenuButton) {
 195 //                        container.getChildren().get(0).requestFocus();
 196                     if (focusedMenuIndex != 0) {
 197                         unSelectMenus();
 198                         menuModeStart(0);
 199                         openMenuButton = ((MenuBarButton)container.getChildren().get(0));
 200 //                        openMenu = getSkinnable().getMenus().get(0);
 201                         openMenuButton.setHover();
 202                     }
 203                     else {
 204                         unSelectMenus();
 205                     }
 206                 }
 207             }
 208         }
 209     };
 210 
 211 
 212 
 213     /***************************************************************************
 214      *                                                                         *
 215      * Constructors                                                            *
 216      *                                                                         *
 217      **************************************************************************/
 218 
 219     /**
 220      * Creates a new MenuBarSkin instance, installing the necessary child
 221      * nodes into the Control {@link Control#getChildren() children} list, as
 222      * well as the necessary input mappings for handling key, mouse, etc events.
 223      *
 224      * @param control The control that this skin should be installed onto.
 225      */
 226     public MenuBarSkin(final MenuBar control) {
 227         super(control);
 228 
 229         container = new HBox();
 230         container.getStyleClass().add(&quot;container&quot;);
 231         getChildren().add(container);
 232 
 233         // Key navigation
 234         keyEventHandler = event -&gt; {
 235             // process right left and may be tab key events
 236             if (focusedMenu != null) {
 237                 switch (event.getCode()) {
 238                     case LEFT: {
 239                         boolean isRTL = control.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT;
 240                         if (control.getScene().getWindow().isFocused()) {
 241                             if (openMenu != null &amp;&amp; !openMenu.isShowing()) {
 242                                 if (isRTL) {
 243                                     moveToMenu(Direction.NEXT, false); // just move the selection bar
 244                                 } else {
 245                                     moveToMenu(Direction.PREVIOUS, false); // just move the selection bar
 246                                 }
 247                                 event.consume();
 248                                 return;
 249                             }
 250                             if (isRTL) {
 251                                 moveToMenu(Direction.NEXT, true);
 252                             } else {
 253                                 moveToMenu(Direction.PREVIOUS, true);
 254                             }
 255                         }
 256                         event.consume();
 257                         break;
 258                     }
 259                     case RIGHT:
 260                     {
 261                         boolean isRTL = control.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT;
 262                         if (control.getScene().getWindow().isFocused()) {
 263                             if (openMenu != null &amp;&amp; !openMenu.isShowing()) {
 264                                 if (isRTL) {
 265                                     moveToMenu(Direction.PREVIOUS, false); // just move the selection bar
 266                                 } else {
 267                                     moveToMenu(Direction.NEXT, false); // just move the selection bar
 268                                 }
 269                                 event.consume();
 270                                 return;
 271                             }
 272                             if (isRTL) {
 273                                 moveToMenu(Direction.PREVIOUS, true);
 274                             } else {
 275                                 moveToMenu(Direction.NEXT, true);
 276                             }
 277                         }
 278                         event.consume();
 279                         break;
 280                     }
 281                     case DOWN:
 282                     //case SPACE:
 283                     //case ENTER:
 284                         // RT-18859: Doing nothing for space and enter
 285                         if (control.getScene().getWindow().isFocused()) {
 286                             if (focusedMenuIndex != -1) {
 287                                 Menu menuToOpen = getSkinnable().getMenus().get(focusedMenuIndex);
 288                                 showMenu(menuToOpen, true);
 289                                 event.consume();
 290                             }
 291                         }
 292                         break;
 293                     case ESCAPE:
 294                         unSelectMenus();
 295                         event.consume();
 296                         break;
 297                 default:
 298                     break;
 299                 }
 300             }
 301         };
 302         menuBarFocusedPropertyListener = (ov, t, t1) -&gt; {
 303             unSelectMenus();
 304             if (t1 &amp;&amp; !container.getChildren().isEmpty()) {
 305                 // RT-23147 when MenuBar&#39;s focusTraversable is true the first
 306                 // menu will visually indicate focus
 307                 menuModeStart(0);
 308                 openMenuButton = ((MenuBarButton)container.getChildren().get(0));
 309                 setFocusedMenuIndex(0);
 310                 openMenuButton.setHover();
 311             }
 312          };
 313         weakSceneKeyEventHandler = new WeakEventHandler&lt;KeyEvent&gt;(keyEventHandler);
 314         Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -&gt; {
 315             scene.addEventFilter(KeyEvent.KEY_PRESSED, weakSceneKeyEventHandler);
 316         });
 317 
 318         // When we click else where in the scene - menu selection should be cleared.
 319         mouseEventHandler = t -&gt; {
 320             Bounds containerScreenBounds = container.localToScreen(container.getLayoutBounds());
 321             if (containerScreenBounds == null || !containerScreenBounds.contains(t.getScreenX(), t.getScreenY())) {
 322                 unSelectMenus();
 323             }
 324         };
 325         weakSceneMouseEventHandler = new WeakEventHandler&lt;MouseEvent&gt;(mouseEventHandler);
 326         Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -&gt; {
 327             scene.addEventFilter(MouseEvent.MOUSE_CLICKED, weakSceneMouseEventHandler);
 328         });
 329 
 330         weakWindowFocusListener = new WeakChangeListener&lt;Boolean&gt;((ov, t, t1) -&gt; {
 331             if (!t1) {
 332               unSelectMenus();
 333             }
 334         });
 335         // When the parent window looses focus - menu selection should be cleared
 336         Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -&gt; {
 337             if (scene.getWindow() != null) {
 338                 scene.getWindow().focusedProperty().addListener(weakWindowFocusListener);
 339             } else {
 340                 ChangeListener&lt;Window&gt; sceneWindowListener = (observable, oldValue, newValue) -&gt; {
 341                     if (oldValue != null)
 342                         oldValue.focusedProperty().removeListener(weakWindowFocusListener);
 343                     if (newValue != null)
 344                         newValue.focusedProperty().addListener(weakWindowFocusListener);
 345                 };
 346                 weakWindowSceneListener = new WeakChangeListener&lt;&gt;(sceneWindowListener);
 347                 scene.windowProperty().addListener(weakWindowSceneListener);
 348             }
 349         });
 350 
 351         menuVisibilityChangeListener = (ov, t, t1) -&gt; {
 352             rebuildUI();
 353         };
 354 
 355         rebuildUI();
 356         control.getMenus().addListener((ListChangeListener&lt;Menu&gt;) c -&gt; {
 357             rebuildUI();
 358         });
 359 
 360         if (Toolkit.getToolkit().getSystemMenu().isSupported()) {
 361             control.useSystemMenuBarProperty().addListener(valueModel -&gt; {
 362                 rebuildUI();
 363             });
 364         }
 365 
 366         // When the mouse leaves the menu, the last hovered item should lose
 367         // it&#39;s focus so that it is no longer selected. This code returns focus
 368         // to the MenuBar itself, such that keyboard navigation can continue.
 369           // fix RT-12254 : menu bar should not request focus on mouse exit.
 370 //        addEventFilter(MouseEvent.MOUSE_EXITED, new EventHandler&lt;MouseEvent&gt;() {
 371 //            @Override
 372 //            public void handle(MouseEvent event) {
 373 //                requestFocus();
 374 //            }
 375 //        });
 376 
 377         /*
 378         ** add an accelerator for F10 on windows and ctrl+F10 on mac/linux
 379         ** pressing f10 will select the first menu button on a menubar
 380         */
 381         final KeyCombination acceleratorKeyCombo;
 382         if (com.sun.javafx.util.Utils.isMac()) {
 383            acceleratorKeyCombo = KeyCombination.keyCombination(&quot;ctrl+F10&quot;);
 384         } else {
 385            acceleratorKeyCombo = KeyCombination.keyCombination(&quot;F10&quot;);
 386         }
 387 
 388         altKeyEventHandler = e -&gt; {
 389             if (e.getEventType() == KeyEvent.KEY_PRESSED) {
 390                 // Clear menu selection when ALT is pressed by itself
 391                 altKeyPressed = false;
 392                 if (e.getCode() == ALT &amp;&amp; !e.isConsumed()) {
 393                     if (focusedMenuIndex == -1) {
 394                         altKeyPressed = true;
 395                     }
 396                     unSelectMenus();
 397                 }
 398             } else if (e.getEventType() == KeyEvent.KEY_RELEASED) {
 399                 // Put focus on the first menu when ALT is released
 400                 // directly after being pressed by itself
 401                 if (altKeyPressed &amp;&amp; e.getCode() == ALT &amp;&amp; !e.isConsumed()) {
 402                     firstMenuRunnable.run();
 403                 }
 404                 altKeyPressed = false;
 405             }
 406         };
 407         weakSceneAltKeyEventHandler = new WeakEventHandler&lt;&gt;(altKeyEventHandler);
 408 
 409         Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -&gt; {
 410             scene.getAccelerators().put(acceleratorKeyCombo, firstMenuRunnable);
 411             scene.addEventHandler(KeyEvent.ANY, weakSceneAltKeyEventHandler);
 412         });
 413 
 414         ParentTraversalEngine engine = new ParentTraversalEngine(getSkinnable());
 415         engine.addTraverseListener((node, bounds) -&gt; {
 416             if (openMenu != null) openMenu.hide();
 417             setFocusedMenuIndex(0);
 418         });
 419         ParentHelper.setTraversalEngine(getSkinnable(), engine);
 420 
 421         control.sceneProperty().addListener((ov, t, t1) -&gt; {
 422             // remove event handlers / filters from the old scene (t)
 423             if (t != null) {
 424                 if (weakSceneKeyEventHandler != null) {
 425                     t.removeEventFilter(KeyEvent.KEY_PRESSED, weakSceneKeyEventHandler);
 426                 }
 427                 if (weakSceneMouseEventHandler != null) {
 428                     t.removeEventFilter(MouseEvent.MOUSE_CLICKED, weakSceneMouseEventHandler);
 429                 }
 430                 if (weakSceneAltKeyEventHandler != null) {
 431                     t.removeEventHandler(KeyEvent.ANY, weakSceneAltKeyEventHandler);
 432                 }
 433             }
 434 
 435             /**
 436              * remove the f10 accelerator from the old scene
 437              * add it to the new scene
 438              */
 439             if (t != null) {
 440                 t.getAccelerators().remove(acceleratorKeyCombo);
 441             }
 442             if (t1 != null ) {
 443                 t1.getAccelerators().put(acceleratorKeyCombo, firstMenuRunnable);
 444             }
 445         });
 446     }
 447 
 448     private void showMenu(Menu menu) {
 449         showMenu(menu, false);
 450     }
 451 
 452     private void showMenu(Menu menu, boolean selectFirstItem) {
 453         // hide the currently visible menu, and move to the next one
 454         if (openMenu == menu) return;
 455         if (openMenu != null) {
 456             openMenu.hide();
 457         }
 458 
 459         openMenu = menu;
 460         if (!menu.isShowing() &amp;&amp; !isMenuEmpty(menu)) {
 461             if (selectFirstItem) {
 462                 // put selection / focus on first item in menu
 463                 MenuButton menuButton = getNodeForMenu(focusedMenuIndex);
 464                 Skin&lt;?&gt; skin = menuButton.getSkin();
 465                 if (skin instanceof MenuButtonSkinBase) {
 466                     ((MenuButtonSkinBase)skin).requestFocusOnFirstMenuItem();
 467                 }
 468             }
 469 
 470             openMenu.show();
 471         }
 472     }
 473 
<a name="1" id="anc1"></a><span class="line-modified"> 474     /**</span>
<span class="line-modified"> 475      * This method is package scoped as it is used in this class as well as for testing</span>
<span class="line-modified"> 476      */</span>
<span class="line-added"> 477     void setFocusedMenuIndex(int index) {</span>
<span class="line-added"> 478         focusedMenuIndex = (index &gt;= -1 &amp;&amp; index &lt; getSkinnable().getMenus().size()) ? index : -1;</span>
<span class="line-added"> 479         focusedMenu = (focusedMenuIndex != -1) ? getSkinnable().getMenus().get(index) : null;</span>
 480 
 481         if (focusedMenuIndex != -1) {
 482             openMenuButton = (MenuBarButton)container.getChildren().get(focusedMenuIndex);
 483             openMenuButton.setHover();
 484         }
 485     }
 486 
 487 
 488 
 489     /***************************************************************************
 490      *                                                                         *
 491      * Static methods                                                          *
 492      *                                                                         *
 493      **************************************************************************/
 494 
 495     // RT-22480: This is intended as private API for SceneBuilder,
 496     // pending fix for RT-19857: Keeping menu in the Mac menu bar when
 497     // there is no more stage
 498     /**
 499      * Set the default system menu bar. This allows an application to keep menu
 500      * in the system menu bar after the last Window is closed.
 501      * @param menuBar the menu bar
 502      */
 503     public static void setDefaultSystemMenuBar(final MenuBar menuBar) {
 504         if (Toolkit.getToolkit().getSystemMenu().isSupported()) {
 505             wrappedDefaultMenus.clear();
 506             for (Menu menu : menuBar.getMenus()) {
 507                 wrappedDefaultMenus.add(GlobalMenuAdapter.adapt(menu));
 508             }
 509             menuBar.getMenus().addListener((ListChangeListener&lt;Menu&gt;) c -&gt; {
 510                 wrappedDefaultMenus.clear();
 511                 for (Menu menu : menuBar.getMenus()) {
 512                     wrappedDefaultMenus.add(GlobalMenuAdapter.adapt(menu));
 513                 }
 514             });
 515         }
 516     }
 517 
 518     private static MenuBarSkin getMenuBarSkin(Stage stage) {
 519         if (systemMenuMap == null) return null;
 520         Reference&lt;MenuBarSkin&gt; skinRef = systemMenuMap.get(stage);
 521         return skinRef == null ? null : skinRef.get();
 522     }
 523 
 524     private static void setSystemMenu(Stage stage) {
 525         if (stage != null &amp;&amp; stage.isFocused()) {
 526             while (stage != null &amp;&amp; stage.getOwner() instanceof Stage) {
 527                 MenuBarSkin skin = getMenuBarSkin(stage);
 528                 if (skin != null &amp;&amp; skin.wrappedMenus != null) {
 529                     break;
 530                 } else {
 531                     // This is a secondary stage (dialog) that doesn&#39;t
 532                     // have own menu bar.
 533                     //
 534                     // Continue looking for a menu bar in the parent stage.
 535                     stage = (Stage)stage.getOwner();
 536                 }
 537             }
 538         } else {
 539             stage = null;
 540         }
 541 
 542         if (stage != currentMenuBarStage) {
 543             List&lt;MenuBase&gt; menuList = null;
 544             if (stage != null) {
 545                 MenuBarSkin skin = getMenuBarSkin(stage);
 546                 if (skin != null) {
 547                     menuList = skin.wrappedMenus;
 548                 }
 549             }
 550             if (menuList == null) {
 551                 menuList = wrappedDefaultMenus;
 552             }
 553             Toolkit.getToolkit().getSystemMenu().setMenus(menuList);
 554             currentMenuBarStage = stage;
 555         }
 556     }
 557 
 558     private static void initSystemMenuBar() {
 559         systemMenuMap = new WeakHashMap&lt;&gt;();
 560 
 561         final InvalidationListener focusedStageListener = ov -&gt; {
 562             setSystemMenu((Stage)((ReadOnlyProperty&lt;?&gt;)ov).getBean());
 563         };
 564 
 565         for (Window stage : stages) {
 566             stage.focusedProperty().addListener(focusedStageListener);
 567         }
 568         stages.addListener((ListChangeListener&lt;Window&gt;) c -&gt; {
 569             while (c.next()) {
 570                 for (Window stage : c.getRemoved()) {
 571                     stage.focusedProperty().removeListener(focusedStageListener);
 572                 }
 573                 for (Window stage : c.getAddedSubList()) {
 574                     stage.focusedProperty().addListener(focusedStageListener);
 575                     setSystemMenu((Stage) stage);
 576                 }
 577             }
 578         });
 579     }
 580 
 581 
 582 
 583     /***************************************************************************
 584      *                                                                         *
 585      * Properties                                                              *
 586      *                                                                         *
 587      **************************************************************************/
 588 
 589     /**
 590      * Specifies the spacing between menu buttons on the MenuBar.
 591      */
 592     // --- spacing
 593     private DoubleProperty spacing;
 594     public final void setSpacing(double value) {
 595         spacingProperty().set(snapSpaceX(value));
 596     }
 597 
 598     public final double getSpacing() {
 599         return spacing == null ? 0.0 : snapSpaceX(spacing.get());
 600     }
 601 
 602     public final DoubleProperty spacingProperty() {
 603         if (spacing == null) {
 604             spacing = new StyleableDoubleProperty() {
 605 
 606                 @Override
 607                 protected void invalidated() {
 608                     final double value = get();
 609                     container.setSpacing(value);
 610                 }
 611 
 612                 @Override
 613                 public Object getBean() {
 614                     return MenuBarSkin.this;
 615                 }
 616 
 617                 @Override
 618                 public String getName() {
 619                     return &quot;spacing&quot;;
 620                 }
 621 
 622                 @Override
 623                 public CssMetaData&lt;MenuBar,Number&gt; getCssMetaData() {
 624                     return SPACING;
 625                 }
 626             };
 627         }
 628         return spacing;
 629     }
 630 
 631     /**
 632      * Specifies the alignment of the menu buttons inside the MenuBar (by default
 633      * it is Pos.TOP_LEFT).
 634      */
 635     // --- container alignment
 636     private ObjectProperty&lt;Pos&gt; containerAlignment;
 637     public final void setContainerAlignment(Pos value) {
 638         containerAlignmentProperty().set(value);
 639     }
 640 
 641     public final Pos getContainerAlignment() {
 642         return containerAlignment == null ? Pos.TOP_LEFT : containerAlignment.get();
 643     }
 644 
 645     public final ObjectProperty&lt;Pos&gt; containerAlignmentProperty() {
 646         if (containerAlignment == null) {
 647             containerAlignment = new StyleableObjectProperty&lt;Pos&gt;(Pos.TOP_LEFT) {
 648 
 649                 @Override
 650                 public void invalidated() {
 651                     final Pos value = get();
 652                     container.setAlignment(value);
 653                 }
 654 
 655                 @Override
 656                 public Object getBean() {
 657                     return MenuBarSkin.this;
 658                 }
 659 
 660                 @Override
 661                 public String getName() {
 662                     return &quot;containerAlignment&quot;;
 663                 }
 664 
 665                 @Override
 666                 public CssMetaData&lt;MenuBar,Pos&gt; getCssMetaData() {
 667                     return ALIGNMENT;
 668                 }
 669             };
 670         }
 671         return containerAlignment;
 672     }
 673 
 674 
 675 
 676     /***************************************************************************
 677      *                                                                         *
 678      * Public API                                                              *
 679      *                                                                         *
 680      **************************************************************************/
 681 
 682     /** {@inheritDoc} */
 683     @Override public void dispose() {
 684         cleanUpSystemMenu();
 685         // call super.dispose last since it sets control to null
 686         super.dispose();
 687     }
 688 
 689     // Return empty insets when &quot;container&quot; is empty, which happens
 690     // when using the system menu bar.
 691 
 692     /** {@inheritDoc} */
 693     @Override protected double snappedTopInset() {
 694         return container.getChildren().isEmpty() ? 0 : super.snappedTopInset();
 695     }
 696     /** {@inheritDoc} */
 697     @Override protected double snappedBottomInset() {
 698         return container.getChildren().isEmpty() ? 0 : super.snappedBottomInset();
 699     }
 700     /** {@inheritDoc} */
 701     @Override protected double snappedLeftInset() {
 702         return container.getChildren().isEmpty() ? 0 : super.snappedLeftInset();
 703     }
 704     /** {@inheritDoc} */
 705     @Override protected double snappedRightInset() {
 706         return container.getChildren().isEmpty() ? 0 : super.snappedRightInset();
 707     }
 708 
 709     /**
 710      * Layout the menu bar. This is a simple horizontal layout like an hbox.
 711      * Any menu items which don&#39;t fit into it will simply be made invisible.
 712      */
 713     /** {@inheritDoc} */
 714     @Override protected void layoutChildren(final double x, final double y,
 715                                             final double w, final double h) {
 716         // layout the menus one after another
 717         container.resizeRelocate(x, y, w, h);
 718     }
 719 
 720     /** {@inheritDoc} */
 721     @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
 722         return container.minWidth(height) + snappedLeftInset() + snappedRightInset();
 723     }
 724 
 725     /** {@inheritDoc} */
 726     @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
 727         return container.prefWidth(height) + snappedLeftInset() + snappedRightInset();
 728     }
 729 
 730     /** {@inheritDoc} */
 731     @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
 732         return container.minHeight(width) + snappedTopInset() + snappedBottomInset();
 733     }
 734 
 735     /** {@inheritDoc} */
 736     @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
 737         return container.prefHeight(width) + snappedTopInset() + snappedBottomInset();
 738     }
 739 
 740     // grow horizontally, but not vertically
 741     /** {@inheritDoc} */
 742     @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
 743         return getSkinnable().prefHeight(-1);
 744     }
 745 
 746 
 747 
 748     /***************************************************************************
 749      *                                                                         *
 750      * Private implementation                                                  *
 751      *                                                                         *
 752      **************************************************************************/
 753 
 754     // For testing purpose only.
 755     MenuButton getNodeForMenu(int i) {
 756         if (i &lt; container.getChildren().size()) {
 757             return (MenuBarButton)container.getChildren().get(i);
 758         }
 759         return null;
 760     }
 761 
 762     int getFocusedMenuIndex() {
 763         return focusedMenuIndex;
 764     }
 765 
<a name="2" id="anc2"></a>



 766     private boolean menusContainCustomMenuItem() {
 767         for (Menu menu : getSkinnable().getMenus()) {
 768             if (menuContainsCustomMenuItem(menu)) {
 769                 System.err.println(&quot;Warning: MenuBar ignored property useSystemMenuBar because menus contain CustomMenuItem&quot;);
 770                 return true;
 771             }
 772         }
 773         return false;
 774     }
 775 
 776     private boolean menuContainsCustomMenuItem(Menu menu) {
 777         for (MenuItem mi : menu.getItems()) {
 778             if (mi instanceof CustomMenuItem &amp;&amp; !(mi instanceof SeparatorMenuItem)) {
 779                 return true;
 780             } else if (mi instanceof Menu) {
 781                 if (menuContainsCustomMenuItem((Menu)mi)) {
 782                     return true;
 783                 }
 784             }
 785         }
 786         return false;
 787     }
 788 
 789     private int getMenuBarButtonIndex(MenuBarButton m) {
 790         for (int i= 0; i &lt; container.getChildren().size(); i++) {
 791             MenuBarButton menuButton = (MenuBarButton)container.getChildren().get(i);
 792             if (m == menuButton) {
 793                 return i;
 794             }
 795         }
 796         return -1;
 797     }
 798 
 799     private void updateActionListeners(MenuItem item, boolean add) {
 800         if (item instanceof Menu) {
 801             Menu menu = (Menu) item;
 802 
 803             if (add) {
 804                 menu.getItems().addListener(menuItemListener);
 805             } else {
 806                 menu.getItems().removeListener(menuItemListener);
 807             }
 808 
 809             for (MenuItem mi : menu.getItems()) {
 810                 updateActionListeners(mi, add);
 811             }
 812         } else {
 813             if (add) {
 814                 item.addEventHandler(ActionEvent.ACTION, menuActionEventHandler);
 815             } else {
 816                 item.removeEventHandler(ActionEvent.ACTION, menuActionEventHandler);
 817             }
 818         }
 819     }
 820 
 821     private void rebuildUI() {
 822         getSkinnable().focusedProperty().removeListener(menuBarFocusedPropertyListener);
 823         for (Menu m : getSkinnable().getMenus()) {
 824             // remove action listeners
 825             updateActionListeners(m, false);
 826 
 827             m.visibleProperty().removeListener(menuVisibilityChangeListener);
 828         }
 829         for (Node n : container.getChildren()) {
 830             // Stop observing menu&#39;s showing &amp; disable property for changes.
 831             // Need to unbind before clearing container&#39;s children.
 832             MenuBarButton menuButton = (MenuBarButton)n;
 833             menuButton.hide();
 834             menuButton.menu.showingProperty().removeListener(menuButton.menuListener);
 835             menuButton.disableProperty().unbind();
 836             menuButton.textProperty().unbind();
 837             menuButton.graphicProperty().unbind();
 838             menuButton.styleProperty().unbind();
 839 
 840             menuButton.dispose();
 841 
 842             // RT-29729 : old instance of context menu window/popup for this MenuButton needs
 843             // to be cleaned up. Setting the skin to null - results in a call to dispose()
 844             // on the skin which in this case MenuButtonSkinBase - does the subsequent
 845             // clean up to ContextMenu/popup window.
 846             menuButton.setSkin(null);
 847             menuButton = null;
 848         }
 849         container.getChildren().clear();
 850 
 851         if (Toolkit.getToolkit().getSystemMenu().isSupported()) {
 852             final Scene scene = getSkinnable().getScene();
 853             if (scene != null) {
 854                 // RT-36554 - make sure system menu is updated when this MenuBar&#39;s scene changes.
 855                 if (sceneChangeListener == null) {
 856                     sceneChangeListener = (observable, oldValue, newValue) -&gt; {
 857 
 858                         if (oldValue != null) {
 859                             if (oldValue.getWindow() instanceof Stage) {
 860                                 final Stage stage = (Stage) oldValue.getWindow();
 861                                 final MenuBarSkin curMBSkin = getMenuBarSkin(stage);
 862                                 if (curMBSkin == MenuBarSkin.this) {
 863                                     curMBSkin.wrappedMenus = null;
 864                                     systemMenuMap.remove(stage);
 865                                     if (currentMenuBarStage == stage) {
 866                                         currentMenuBarStage = null;
 867                                         setSystemMenu(stage);
 868                                     }
 869                                 } else {
 870                                     if (getSkinnable().isUseSystemMenuBar() &amp;&amp;
 871                                             curMBSkin != null &amp;&amp; curMBSkin.getSkinnable() != null &amp;&amp;
 872                                             curMBSkin.getSkinnable().isUseSystemMenuBar()) {
 873                                         curMBSkin.getSkinnable().setUseSystemMenuBar(false);
 874                                     }
 875                                 }
 876                             }
 877                         }
 878 
 879                         if (newValue != null) {
 880                             if (getSkinnable().isUseSystemMenuBar() &amp;&amp; !menusContainCustomMenuItem()) {
 881                                 if (newValue.getWindow() instanceof Stage) {
 882                                     final Stage stage = (Stage) newValue.getWindow();
 883                                     if (systemMenuMap == null) {
 884                                         initSystemMenuBar();
 885                                     }
 886                                     wrappedMenus = new ArrayList&lt;&gt;();
 887                                     systemMenuMap.put(stage, new WeakReference&lt;&gt;(this));
 888                                     for (Menu menu : getSkinnable().getMenus()) {
 889                                         wrappedMenus.add(GlobalMenuAdapter.adapt(menu));
 890                                     }
 891                                     currentMenuBarStage = null;
 892                                     setSystemMenu(stage);
 893 
 894                                     // TODO: Why two request layout calls here?
 895                                     getSkinnable().requestLayout();
 896                                     javafx.application.Platform.runLater(() -&gt; getSkinnable().requestLayout());
 897                                 }
 898                             }
 899                         }
 900                     };
 901                     getSkinnable().sceneProperty().addListener(sceneChangeListener);
 902                 }
 903 
 904                 // Fake a change event to trigger an update to the system menu.
 905                 sceneChangeListener.changed(getSkinnable().sceneProperty(), scene, scene);
 906 
 907                 // If the system menu references this MenuBarSkin, then we&#39;re done with rebuilding the UI.
 908                 // If the system menu does not reference this MenuBarSkin, then the MenuBar is a child of the scene
 909                 // and we continue with the update.
 910                 // If there is no system menu but this skinnable uses the system menu bar, then the
 911                 // stage just isn&#39;t focused yet (see setSystemMenu) and we&#39;re done rebuilding the UI.
 912                 if (currentMenuBarStage != null ? getMenuBarSkin(currentMenuBarStage) == MenuBarSkin.this : getSkinnable().isUseSystemMenuBar()) {
 913                     return;
 914                 }
 915 
 916             } else {
 917                 // if scene is null, make sure this MenuBarSkin isn&#39;t left behind as the system menu
 918                 if (currentMenuBarStage != null) {
 919                     final MenuBarSkin curMBSkin = getMenuBarSkin(currentMenuBarStage);
 920                     if (curMBSkin == MenuBarSkin.this) {
 921                         setSystemMenu(null);
 922                     }
 923                 }
 924             }
 925         }
 926 
 927         getSkinnable().focusedProperty().addListener(menuBarFocusedPropertyListener);
 928         for (final Menu menu : getSkinnable().getMenus()) {
 929 
 930             menu.visibleProperty().addListener(menuVisibilityChangeListener);
 931 
 932             if (!menu.isVisible()) continue;
 933             final MenuBarButton menuButton = new MenuBarButton(this, menu);
 934             menuButton.setFocusTraversable(false);
 935             menuButton.getStyleClass().add(&quot;menu&quot;);
 936             menuButton.setStyle(menu.getStyle()); // copy style
 937 
 938             menuButton.getItems().setAll(menu.getItems());
 939             container.getChildren().add(menuButton);
 940 
 941             menuButton.menuListener = (observable, oldValue, newValue) -&gt; {
 942                 if (menu.isShowing()) {
 943                     menuButton.show();
 944                     menuModeStart(container.getChildren().indexOf(menuButton));
 945                 } else {
 946                     menuButton.hide();
 947                 }
 948             };
 949             menuButton.menu = menu;
 950             menu.showingProperty().addListener(menuButton.menuListener);
 951             menuButton.disableProperty().bindBidirectional(menu.disableProperty());
 952             menuButton.textProperty().bind(menu.textProperty());
 953             menuButton.graphicProperty().bind(menu.graphicProperty());
 954             menuButton.styleProperty().bind(menu.styleProperty());
 955             menuButton.getProperties().addListener((MapChangeListener&lt;Object, Object&gt;) c -&gt; {
 956                  if (c.wasAdded() &amp;&amp; MenuButtonSkin.AUTOHIDE.equals(c.getKey())) {
 957                     menuButton.getProperties().remove(MenuButtonSkin.AUTOHIDE);
 958                     menu.hide();
 959                 }
 960             });
 961             menuButton.showingProperty().addListener((observable, oldValue, isShowing) -&gt; {
 962                 if (isShowing) {
 963                     if(openMenuButton == null &amp;&amp; focusedMenuIndex != -1)
 964                         openMenuButton = (MenuBarButton)container.getChildren().get(focusedMenuIndex);
 965 
 966                     if (openMenuButton != null &amp;&amp; openMenuButton != menuButton) {
 967                         openMenuButton.clearHover();
 968                     }
 969                     openMenuButton = menuButton;
 970                     showMenu(menu);
 971                 } else {
 972                     // Fix for JDK-8167138 - we need to clear out the openMenu / openMenuButton
 973                     // when the menu is hidden (e.g. via autoHide), so that we can open it again
 974                     // the next time (if it is the first menu requested to show)
 975                     openMenu = null;
 976                     openMenuButton = null;
 977                 }
 978             });
 979 
 980             menuButton.setOnMousePressed(event -&gt; {
 981                 pendingDismiss = menuButton.isShowing();
 982 
 983                 // check if the owner window has focus
 984                 if (menuButton.getScene().getWindow().isFocused()) {
 985                     showMenu(menu);
 986                     // update FocusedIndex
 987                     menuModeStart(getMenuBarButtonIndex(menuButton));
 988                 }
 989             });
 990 
 991             menuButton.setOnMouseReleased(event -&gt; {
 992                 // check if the owner window has focus
 993                 if (menuButton.getScene().getWindow().isFocused()) {
 994                     if (pendingDismiss) {
 995                         resetOpenMenu();
 996                     }
 997                 }
 998                 pendingDismiss = false;
 999             });
1000 
1001             menuButton.setOnMouseEntered(event -&gt; {
1002                 // check if the owner window has focus
1003                 if (menuButton.getScene() != null &amp;&amp; menuButton.getScene().getWindow() != null &amp;&amp;
1004                         menuButton.getScene().getWindow().isFocused()) {
1005                     if (openMenuButton != null &amp;&amp; openMenuButton != menuButton) {
1006                             openMenuButton.clearHover();
1007                             openMenuButton = null;
1008                             openMenuButton = menuButton;
1009                     }
1010                     updateFocusedIndex();
1011                     if (openMenu != null &amp;&amp; openMenu != menu) {
1012                         showMenu(menu);
1013                     }
1014                 }
1015             });
1016             updateActionListeners(menu, true);
1017         }
1018         getSkinnable().requestLayout();
1019     }
1020 
1021     private void cleanUpSystemMenu() {
1022         if (sceneChangeListener != null &amp;&amp; getSkinnable() != null) {
1023             getSkinnable().sceneProperty().removeListener(sceneChangeListener);
1024             // rebuildUI creates sceneChangeListener and adds sceneChangeListener to sceneProperty,
1025             // so sceneChangeListener needs to be reset to null in the off chance that this
1026             // skin instance is reused.
1027             sceneChangeListener = null;
1028         }
1029 
1030         if (currentMenuBarStage != null &amp;&amp; getMenuBarSkin(currentMenuBarStage) == MenuBarSkin.this) {
1031             setSystemMenu(null);
1032         }
1033 
1034         if (systemMenuMap != null) {
1035             Iterator&lt;Map.Entry&lt;Stage,Reference&lt;MenuBarSkin&gt;&gt;&gt; iterator = systemMenuMap.entrySet().iterator();
1036             while (iterator.hasNext()) {
1037                 Map.Entry&lt;Stage,Reference&lt;MenuBarSkin&gt;&gt; entry = iterator.next();
1038                 Reference&lt;MenuBarSkin&gt; ref = entry.getValue();
1039                 MenuBarSkin skin = ref != null ? ref.get() : null;
1040                 if (skin == null || skin == MenuBarSkin.this) {
1041                     iterator.remove();
1042                 }
1043             }
1044         }
1045     }
1046 
1047     private boolean isMenuEmpty(Menu menu) {
1048         boolean retVal = true;
1049         if (menu != null) {
1050             for (MenuItem m : menu.getItems()) {
1051                 if (m != null &amp;&amp; m.isVisible()) retVal = false;
1052             }
1053         }
1054         return retVal;
1055     }
1056 
1057     private void resetOpenMenu() {
1058         if (openMenu != null) {
1059             openMenu.hide();
1060             openMenu = null;
1061         }
1062     }
1063 
1064     private void unSelectMenus() {
1065         clearMenuButtonHover();
1066         if (focusedMenuIndex == -1) return;
1067         if (openMenu != null) {
1068             openMenu.hide();
1069             openMenu = null;
1070         }
1071         if (openMenuButton != null) {
1072             openMenuButton.clearHover();
1073             openMenuButton = null;
1074         }
1075         menuModeEnd();
1076     }
1077 
1078     private void menuModeStart(int newIndex) {
1079         if (focusedMenuIndex == -1) {
1080             SceneHelper.getSceneAccessor().setTransientFocusContainer(getSkinnable().getScene(), getSkinnable());
1081         }
1082         setFocusedMenuIndex(newIndex);
1083     }
1084 
1085     private void menuModeEnd() {
1086         if (focusedMenuIndex != -1) {
1087             SceneHelper.getSceneAccessor().setTransientFocusContainer(getSkinnable().getScene(), null);
1088 
1089             /* Return the a11y focus to a control in the scene. */
1090             getSkinnable().notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_NODE);
1091         }
1092         setFocusedMenuIndex(-1);
1093     }
1094 
1095     private void moveToMenu(Direction dir, boolean doShow) {
1096         boolean showNextMenu = doShow &amp;&amp; focusedMenu.isShowing();
1097         findSibling(dir, focusedMenuIndex).ifPresent(p -&gt; {
1098             setFocusedMenuIndex(p.getValue());
1099             if (showNextMenu) {
1100                 // we explicitly do *not* allow selection - we are moving
1101                 // to a sibling menu, and therefore selection should be reset
1102                 showMenu(p.getKey(), false);
1103             }
1104         });
1105     }
1106 
1107     private Optional&lt;Pair&lt;Menu,Integer&gt;&gt; findSibling(Direction dir, int startIndex) {
1108         if (startIndex == -1) {
1109             return Optional.empty();
1110         }
1111 
1112         final int totalMenus = getSkinnable().getMenus().size();
1113         int i = 0;
1114         int nextIndex = 0;
1115 
1116         // Traverse all menus in menubar to find nextIndex
1117         while (i &lt; totalMenus) {
1118             i++;
1119 
1120             nextIndex = (startIndex + (dir.isForward() ? 1 : -1)) % totalMenus;
1121 
1122             if (nextIndex == -1) {
1123                 // loop backwards to end
1124                 nextIndex = totalMenus - 1;
1125             }
1126 
1127             // if menu at nextIndex is disabled, skip it
1128             if (getSkinnable().getMenus().get(nextIndex).isDisable()) {
1129                 // Calculate new nextIndex by continuing loop
1130                 startIndex = nextIndex;
1131             } else {
1132                 // nextIndex is to be highlighted
1133                 break;
1134             }
1135         }
1136 
1137         clearMenuButtonHover();
1138         return Optional.of(new Pair&lt;&gt;(getSkinnable().getMenus().get(nextIndex), nextIndex));
1139     }
1140 
1141     private void updateFocusedIndex() {
1142         int index = 0;
1143         for(Node n : container.getChildren()) {
1144             if (n.isHover()) {
1145                 setFocusedMenuIndex(index);
1146                 return;
1147             }
1148             index++;
1149         }
1150         menuModeEnd();
1151     }
1152 
1153     private void clearMenuButtonHover() {
1154          for(Node n : container.getChildren()) {
1155             if (n.isHover()) {
1156                 ((MenuBarButton)n).clearHover();
1157                 ((MenuBarButton)n).disarm();
1158                 return;
1159             }
1160         }
1161     }
1162 
1163 
1164 
1165     /***************************************************************************
1166      *                                                                         *
1167      * CSS                                                                     *
1168      *                                                                         *
1169      **************************************************************************/
1170 
1171     private static final CssMetaData&lt;MenuBar,Number&gt; SPACING =
1172             new CssMetaData&lt;MenuBar,Number&gt;(&quot;-fx-spacing&quot;,
1173                     SizeConverter.getInstance(), 0.0) {
1174 
1175                 @Override
1176                 public boolean isSettable(MenuBar n) {
1177                     final MenuBarSkin skin = (MenuBarSkin) n.getSkin();
1178                     return skin.spacing == null || !skin.spacing.isBound();
1179                 }
1180 
1181                 @Override
1182                 public StyleableProperty&lt;Number&gt; getStyleableProperty(MenuBar n) {
1183                     final MenuBarSkin skin = (MenuBarSkin) n.getSkin();
1184                     return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)skin.spacingProperty();
1185                 }
1186             };
1187 
1188     private static final CssMetaData&lt;MenuBar,Pos&gt; ALIGNMENT =
1189             new CssMetaData&lt;MenuBar,Pos&gt;(&quot;-fx-alignment&quot;,
1190                     new EnumConverter&lt;Pos&gt;(Pos.class), Pos.TOP_LEFT ) {
1191 
1192                 @Override
1193                 public boolean isSettable(MenuBar n) {
1194                     final MenuBarSkin skin = (MenuBarSkin) n.getSkin();
1195                     return skin.containerAlignment == null || !skin.containerAlignment.isBound();
1196                 }
1197 
1198                 @Override
1199                 public StyleableProperty&lt;Pos&gt; getStyleableProperty(MenuBar n) {
1200                     final MenuBarSkin skin = (MenuBarSkin) n.getSkin();
1201                     return (StyleableProperty&lt;Pos&gt;)(WritableValue&lt;Pos&gt;)skin.containerAlignmentProperty();
1202                 }
1203             };
1204 
1205 
1206     private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
1207     static {
1208 
1209         final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1210                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
1211 
1212         // StackPane also has -fx-alignment. Replace it with
1213         // MenuBarSkin&#39;s.
1214         // TODO: Really should be able to reference StackPane.StyleableProperties.ALIGNMENT
1215         final String alignmentProperty = ALIGNMENT.getProperty();
1216         for (int n=0, nMax=styleables.size(); n&lt;nMax; n++) {
1217             final CssMetaData&lt;?,?&gt; prop = styleables.get(n);
1218             if (alignmentProperty.equals(prop.getProperty())) styleables.remove(prop);
1219         }
1220 
1221         styleables.add(SPACING);
1222         styleables.add(ALIGNMENT);
1223         STYLEABLES = Collections.unmodifiableList(styleables);
1224 
1225     }
1226 
1227     /**
1228      * Returns the CssMetaData associated with this class, which may include the
1229      * CssMetaData of its superclasses.
1230      * @return the CssMetaData associated with this class, which may include the
1231      * CssMetaData of its superclasses
1232      */
1233     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1234         return STYLEABLES;
1235     }
1236 
1237     /**
1238      * {@inheritDoc}
1239      */
1240     @Override
1241     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
1242         return getClassCssMetaData();
1243     }
1244 
1245     /***************************************************************************
1246      *                                                                         *
1247      * Accessibility handling                                                  *
1248      *                                                                         *
1249      **************************************************************************/
1250 
1251     /** {@inheritDoc} */
1252     @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1253         switch (attribute) {
1254             case FOCUS_NODE: return openMenuButton;
1255             default: return super.queryAccessibleAttribute(attribute, parameters);
1256         }
1257     }
1258 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/skin/MenuBarSkin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control.skin;
  27 
  28 import static com.sun.javafx.FXPermissions.ACCESS_WINDOW_LIST_PERMISSION;
  29 
  30 import com.sun.javafx.scene.traversal.Direction;
  31 import javafx.css.converter.EnumConverter;
  32 import javafx.css.converter.SizeConverter;
  33 import com.sun.javafx.scene.control.MenuBarButton;
  34 import com.sun.javafx.scene.control.skin.Utils;
  35 import com.sun.javafx.scene.traversal.ParentTraversalEngine;
  36 import javafx.beans.InvalidationListener;
  37 import javafx.beans.property.DoubleProperty;
  38 import javafx.beans.property.ObjectProperty;
  39 import javafx.beans.property.ReadOnlyProperty;
  40 import javafx.beans.value.ChangeListener;
  41 import javafx.beans.value.WeakChangeListener;
  42 import javafx.beans.value.WritableValue;
  43 import javafx.collections.ListChangeListener;
  44 import javafx.collections.MapChangeListener;
  45 import javafx.collections.ObservableList;
  46 import javafx.css.CssMetaData;
  47 import javafx.css.Styleable;
  48 import javafx.css.StyleableDoubleProperty;
  49 import javafx.css.StyleableObjectProperty;
  50 import javafx.css.StyleableProperty;
  51 import javafx.event.ActionEvent;
  52 import javafx.event.EventHandler;
  53 import javafx.event.WeakEventHandler;
  54 import javafx.geometry.Bounds;
  55 import javafx.geometry.NodeOrientation;
  56 import javafx.geometry.Pos;
  57 import javafx.scene.AccessibleAttribute;
  58 import javafx.scene.Node;
  59 import javafx.scene.Scene;
  60 import javafx.scene.control.Control;
  61 import javafx.scene.control.CustomMenuItem;
  62 import javafx.scene.control.Menu;
  63 import javafx.scene.control.MenuBar;
  64 import javafx.scene.control.MenuButton;
  65 import javafx.scene.control.MenuItem;
  66 import javafx.scene.control.SeparatorMenuItem;
  67 import javafx.scene.control.Skin;
  68 import javafx.scene.control.SkinBase;
  69 import javafx.scene.input.KeyCombination;
  70 import javafx.scene.input.KeyEvent;
  71 import javafx.scene.input.MouseEvent;
  72 import javafx.scene.layout.HBox;
  73 import javafx.stage.Stage;
  74 
  75 import static javafx.scene.input.KeyCode.*;
  76 
  77 import java.lang.ref.Reference;
  78 import java.lang.ref.WeakReference;
  79 import java.util.ArrayList;
  80 import java.util.Collections;
  81 import java.util.Iterator;
  82 import java.util.List;
  83 import java.util.Map;
  84 import java.util.Optional;
  85 import java.util.WeakHashMap;
  86 
  87 import com.sun.javafx.menu.MenuBase;
  88 import com.sun.javafx.scene.ParentHelper;
  89 import com.sun.javafx.scene.SceneHelper;
  90 import com.sun.javafx.scene.control.GlobalMenuAdapter;
  91 import com.sun.javafx.tk.Toolkit;
  92 import java.util.function.Predicate;
  93 import javafx.stage.Window;
  94 import javafx.util.Pair;
  95 
  96 import java.security.AccessController;
  97 import java.security.PrivilegedAction;
  98 
  99 /**
 100  * Default skin implementation for the {@link MenuBar} control. In essence it is
 101  * a simple toolbar. For the time being there is no overflow behavior and we just
 102  * hide nodes which fall outside the bounds.
 103  *
 104  * @see MenuBar
 105  * @since 9
 106  */
 107 public class MenuBarSkin extends SkinBase&lt;MenuBar&gt; {
 108 
 109     private static final ObservableList&lt;Window&gt; stages;
 110 
 111     static {
 112         final Predicate&lt;Window&gt; findStage = (w) -&gt; w instanceof Stage;
 113         ObservableList&lt;Window&gt; windows = AccessController.doPrivileged(
 114             (PrivilegedAction&lt;ObservableList&lt;Window&gt;&gt;) () -&gt; Window.getWindows(),
 115             null,
 116             ACCESS_WINDOW_LIST_PERMISSION);
 117         stages = windows.filtered(findStage);
 118     }
 119 
 120     /***************************************************************************
 121      *                                                                         *
 122      * Private fields                                                          *
 123      *                                                                         *
 124      **************************************************************************/
 125 
 126     private final HBox container;
 127 
 128     // represents the currently _open_ menu
 129     private Menu openMenu;
 130     private MenuBarButton openMenuButton;
 131 
 132     // represents the currently _focused_ menu. If openMenu is non-null, this should equal
 133     // openMenu. If openMenu is null, this can be any menu in the menu bar.
 134     private Menu focusedMenu;
 135     private int focusedMenuIndex = -1;
 136 
 137     private static WeakHashMap&lt;Stage, Reference&lt;MenuBarSkin&gt;&gt; systemMenuMap;
 138     private static List&lt;MenuBase&gt; wrappedDefaultMenus = new ArrayList&lt;&gt;();
 139     private static Stage currentMenuBarStage;
 140     private List&lt;MenuBase&gt; wrappedMenus;
 141 
 142     private WeakEventHandler&lt;KeyEvent&gt; weakSceneKeyEventHandler;
 143     private WeakEventHandler&lt;MouseEvent&gt; weakSceneMouseEventHandler;
 144     private WeakEventHandler&lt;KeyEvent&gt; weakSceneAltKeyEventHandler;
 145     private WeakChangeListener&lt;Boolean&gt; weakWindowFocusListener;
 146     private WeakChangeListener&lt;Window&gt; weakWindowSceneListener;
 147     private EventHandler&lt;KeyEvent&gt; keyEventHandler;
 148     private EventHandler&lt;KeyEvent&gt; altKeyEventHandler;
 149     private EventHandler&lt;MouseEvent&gt; mouseEventHandler;
 150     private ChangeListener&lt;Boolean&gt; menuBarFocusedPropertyListener;
 151     private ChangeListener&lt;Scene&gt; sceneChangeListener;
 152     private ChangeListener&lt;Boolean&gt; menuVisibilityChangeListener;
 153 
 154     private boolean pendingDismiss = false;
 155 
 156     private boolean altKeyPressed = false;
 157 
 158 
 159     /***************************************************************************
 160      *                                                                         *
 161      * Listeners / Callbacks                                                   *
 162      *                                                                         *
 163      **************************************************************************/
 164 
 165     // RT-20411 : reset menu selected/focused state
 166     private EventHandler&lt;ActionEvent&gt; menuActionEventHandler = t -&gt; {
 167         if (t.getSource() instanceof CustomMenuItem) {
 168             // RT-29614 If CustomMenuItem hideOnClick is false, dont hide
 169             CustomMenuItem cmi = (CustomMenuItem)t.getSource();
 170             if (!cmi.isHideOnClick()) return;
 171         }
 172         unSelectMenus();
 173     };
 174 
 175     private ListChangeListener&lt;MenuItem&gt; menuItemListener = (c) -&gt; {
 176         while (c.next()) {
 177             for (MenuItem mi : c.getAddedSubList()) {
 178                 updateActionListeners(mi, true);
 179             }
 180             for (MenuItem mi: c.getRemoved()) {
 181                 updateActionListeners(mi, false);
 182             }
 183         }
 184     };
 185 
 186     Runnable firstMenuRunnable = new Runnable() {
 187         public void run() {
 188             /*
 189             ** check that this menubar&#39;s container has contents,
 190             ** and that the first item is a MenuButton....
 191             ** otherwise the transfer is off!
 192             */
 193             if (container.getChildren().size() &gt; 0) {
 194                 if (container.getChildren().get(0) instanceof MenuButton) {
 195 //                        container.getChildren().get(0).requestFocus();
 196                     if (focusedMenuIndex != 0) {
 197                         unSelectMenus();
 198                         menuModeStart(0);
 199                         openMenuButton = ((MenuBarButton)container.getChildren().get(0));
 200 //                        openMenu = getSkinnable().getMenus().get(0);
 201                         openMenuButton.setHover();
 202                     }
 203                     else {
 204                         unSelectMenus();
 205                     }
 206                 }
 207             }
 208         }
 209     };
 210 
 211 
 212 
 213     /***************************************************************************
 214      *                                                                         *
 215      * Constructors                                                            *
 216      *                                                                         *
 217      **************************************************************************/
 218 
 219     /**
 220      * Creates a new MenuBarSkin instance, installing the necessary child
 221      * nodes into the Control {@link Control#getChildren() children} list, as
 222      * well as the necessary input mappings for handling key, mouse, etc events.
 223      *
 224      * @param control The control that this skin should be installed onto.
 225      */
 226     public MenuBarSkin(final MenuBar control) {
 227         super(control);
 228 
 229         container = new HBox();
 230         container.getStyleClass().add(&quot;container&quot;);
 231         getChildren().add(container);
 232 
 233         // Key navigation
 234         keyEventHandler = event -&gt; {
 235             // process right left and may be tab key events
 236             if (focusedMenu != null) {
 237                 switch (event.getCode()) {
 238                     case LEFT: {
 239                         boolean isRTL = control.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT;
 240                         if (control.getScene().getWindow().isFocused()) {
 241                             if (openMenu != null &amp;&amp; !openMenu.isShowing()) {
 242                                 if (isRTL) {
 243                                     moveToMenu(Direction.NEXT, false); // just move the selection bar
 244                                 } else {
 245                                     moveToMenu(Direction.PREVIOUS, false); // just move the selection bar
 246                                 }
 247                                 event.consume();
 248                                 return;
 249                             }
 250                             if (isRTL) {
 251                                 moveToMenu(Direction.NEXT, true);
 252                             } else {
 253                                 moveToMenu(Direction.PREVIOUS, true);
 254                             }
 255                         }
 256                         event.consume();
 257                         break;
 258                     }
 259                     case RIGHT:
 260                     {
 261                         boolean isRTL = control.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT;
 262                         if (control.getScene().getWindow().isFocused()) {
 263                             if (openMenu != null &amp;&amp; !openMenu.isShowing()) {
 264                                 if (isRTL) {
 265                                     moveToMenu(Direction.PREVIOUS, false); // just move the selection bar
 266                                 } else {
 267                                     moveToMenu(Direction.NEXT, false); // just move the selection bar
 268                                 }
 269                                 event.consume();
 270                                 return;
 271                             }
 272                             if (isRTL) {
 273                                 moveToMenu(Direction.PREVIOUS, true);
 274                             } else {
 275                                 moveToMenu(Direction.NEXT, true);
 276                             }
 277                         }
 278                         event.consume();
 279                         break;
 280                     }
 281                     case DOWN:
 282                     //case SPACE:
 283                     //case ENTER:
 284                         // RT-18859: Doing nothing for space and enter
 285                         if (control.getScene().getWindow().isFocused()) {
 286                             if (focusedMenuIndex != -1) {
 287                                 Menu menuToOpen = getSkinnable().getMenus().get(focusedMenuIndex);
 288                                 showMenu(menuToOpen, true);
 289                                 event.consume();
 290                             }
 291                         }
 292                         break;
 293                     case ESCAPE:
 294                         unSelectMenus();
 295                         event.consume();
 296                         break;
 297                 default:
 298                     break;
 299                 }
 300             }
 301         };
 302         menuBarFocusedPropertyListener = (ov, t, t1) -&gt; {
 303             if (t1) {
 304                 // RT-23147 when MenuBar&#39;s focusTraversable is true the first
 305                 // menu will visually indicate focus
 306                 unSelectMenus();
<a name="1" id="anc1"></a><span class="line-modified"> 307                 if (!container.getChildren().isEmpty()) {</span>
<span class="line-modified"> 308                     menuModeStart(0);</span>
<span class="line-modified"> 309                     openMenuButton = ((MenuBarButton)container.getChildren().get(0));</span>
<span class="line-modified"> 310                     setFocusedMenuIndex(0);</span>
<span class="line-added"> 311                     openMenuButton.setHover();</span>
<span class="line-added"> 312                 }</span>
 313             } else {
 314                 unSelectMenus();
 315              }
 316          };
 317         weakSceneKeyEventHandler = new WeakEventHandler&lt;KeyEvent&gt;(keyEventHandler);
 318         Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -&gt; {
 319             scene.addEventFilter(KeyEvent.KEY_PRESSED, weakSceneKeyEventHandler);
 320         });
 321 
 322         // When we click else where in the scene - menu selection should be cleared.
 323         mouseEventHandler = t -&gt; {
 324             Bounds containerScreenBounds = container.localToScreen(container.getLayoutBounds());
 325             if (containerScreenBounds == null || !containerScreenBounds.contains(t.getScreenX(), t.getScreenY())) {
 326                 unSelectMenus();
 327             }
 328         };
 329         weakSceneMouseEventHandler = new WeakEventHandler&lt;MouseEvent&gt;(mouseEventHandler);
 330         Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -&gt; {
 331             scene.addEventFilter(MouseEvent.MOUSE_CLICKED, weakSceneMouseEventHandler);
 332         });
 333 
 334         weakWindowFocusListener = new WeakChangeListener&lt;Boolean&gt;((ov, t, t1) -&gt; {
 335             if (!t1) {
 336               unSelectMenus();
 337             }
 338         });
 339         // When the parent window looses focus - menu selection should be cleared
 340         Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -&gt; {
 341             if (scene.getWindow() != null) {
 342                 scene.getWindow().focusedProperty().addListener(weakWindowFocusListener);
 343             } else {
 344                 ChangeListener&lt;Window&gt; sceneWindowListener = (observable, oldValue, newValue) -&gt; {
 345                     if (oldValue != null)
 346                         oldValue.focusedProperty().removeListener(weakWindowFocusListener);
 347                     if (newValue != null)
 348                         newValue.focusedProperty().addListener(weakWindowFocusListener);
 349                 };
 350                 weakWindowSceneListener = new WeakChangeListener&lt;&gt;(sceneWindowListener);
 351                 scene.windowProperty().addListener(weakWindowSceneListener);
 352             }
 353         });
 354 
 355         menuVisibilityChangeListener = (ov, t, t1) -&gt; {
 356             rebuildUI();
 357         };
 358 
 359         rebuildUI();
 360         control.getMenus().addListener((ListChangeListener&lt;Menu&gt;) c -&gt; {
 361             rebuildUI();
 362         });
 363 
 364         if (Toolkit.getToolkit().getSystemMenu().isSupported()) {
 365             control.useSystemMenuBarProperty().addListener(valueModel -&gt; {
 366                 rebuildUI();
 367             });
 368         }
 369 
 370         // When the mouse leaves the menu, the last hovered item should lose
 371         // it&#39;s focus so that it is no longer selected. This code returns focus
 372         // to the MenuBar itself, such that keyboard navigation can continue.
 373           // fix RT-12254 : menu bar should not request focus on mouse exit.
 374 //        addEventFilter(MouseEvent.MOUSE_EXITED, new EventHandler&lt;MouseEvent&gt;() {
 375 //            @Override
 376 //            public void handle(MouseEvent event) {
 377 //                requestFocus();
 378 //            }
 379 //        });
 380 
 381         /*
 382         ** add an accelerator for F10 on windows and ctrl+F10 on mac/linux
 383         ** pressing f10 will select the first menu button on a menubar
 384         */
 385         final KeyCombination acceleratorKeyCombo;
 386         if (com.sun.javafx.util.Utils.isMac()) {
 387            acceleratorKeyCombo = KeyCombination.keyCombination(&quot;ctrl+F10&quot;);
 388         } else {
 389            acceleratorKeyCombo = KeyCombination.keyCombination(&quot;F10&quot;);
 390         }
 391 
 392         altKeyEventHandler = e -&gt; {
 393             if (e.getEventType() == KeyEvent.KEY_PRESSED) {
 394                 // Clear menu selection when ALT is pressed by itself
 395                 altKeyPressed = false;
 396                 if (e.getCode() == ALT &amp;&amp; !e.isConsumed()) {
 397                     if (focusedMenuIndex == -1) {
 398                         altKeyPressed = true;
 399                     }
 400                     unSelectMenus();
 401                 }
 402             } else if (e.getEventType() == KeyEvent.KEY_RELEASED) {
 403                 // Put focus on the first menu when ALT is released
 404                 // directly after being pressed by itself
 405                 if (altKeyPressed &amp;&amp; e.getCode() == ALT &amp;&amp; !e.isConsumed()) {
 406                     firstMenuRunnable.run();
 407                 }
 408                 altKeyPressed = false;
 409             }
 410         };
 411         weakSceneAltKeyEventHandler = new WeakEventHandler&lt;&gt;(altKeyEventHandler);
 412 
 413         Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -&gt; {
 414             scene.getAccelerators().put(acceleratorKeyCombo, firstMenuRunnable);
 415             scene.addEventHandler(KeyEvent.ANY, weakSceneAltKeyEventHandler);
 416         });
 417 
 418         ParentTraversalEngine engine = new ParentTraversalEngine(getSkinnable());
 419         engine.addTraverseListener((node, bounds) -&gt; {
 420             if (openMenu != null) openMenu.hide();
 421             setFocusedMenuIndex(0);
 422         });
 423         ParentHelper.setTraversalEngine(getSkinnable(), engine);
 424 
 425         control.sceneProperty().addListener((ov, t, t1) -&gt; {
 426             // remove event handlers / filters from the old scene (t)
 427             if (t != null) {
 428                 if (weakSceneKeyEventHandler != null) {
 429                     t.removeEventFilter(KeyEvent.KEY_PRESSED, weakSceneKeyEventHandler);
 430                 }
 431                 if (weakSceneMouseEventHandler != null) {
 432                     t.removeEventFilter(MouseEvent.MOUSE_CLICKED, weakSceneMouseEventHandler);
 433                 }
 434                 if (weakSceneAltKeyEventHandler != null) {
 435                     t.removeEventHandler(KeyEvent.ANY, weakSceneAltKeyEventHandler);
 436                 }
 437             }
 438 
 439             /**
 440              * remove the f10 accelerator from the old scene
 441              * add it to the new scene
 442              */
 443             if (t != null) {
 444                 t.getAccelerators().remove(acceleratorKeyCombo);
 445             }
 446             if (t1 != null ) {
 447                 t1.getAccelerators().put(acceleratorKeyCombo, firstMenuRunnable);
 448             }
 449         });
 450     }
 451 
 452     private void showMenu(Menu menu) {
 453         showMenu(menu, false);
 454     }
 455 
 456     private void showMenu(Menu menu, boolean selectFirstItem) {
 457         // hide the currently visible menu, and move to the next one
 458         if (openMenu == menu) return;
 459         if (openMenu != null) {
 460             openMenu.hide();
 461         }
 462 
 463         openMenu = menu;
 464         if (!menu.isShowing() &amp;&amp; !isMenuEmpty(menu)) {
 465             if (selectFirstItem) {
 466                 // put selection / focus on first item in menu
 467                 MenuButton menuButton = getNodeForMenu(focusedMenuIndex);
 468                 Skin&lt;?&gt; skin = menuButton.getSkin();
 469                 if (skin instanceof MenuButtonSkinBase) {
 470                     ((MenuButtonSkinBase)skin).requestFocusOnFirstMenuItem();
 471                 }
 472             }
 473 
 474             openMenu.show();
 475         }
 476     }
 477 
 478     private void setFocusedMenuIndex(int index) {
 479         this.focusedMenuIndex = index;
<a name="2" id="anc2"></a><span class="line-modified"> 480         focusedMenu = null;</span>
<span class="line-added"> 481 </span>
<span class="line-added"> 482         if (index != -1 &amp;&amp; !(getSkinnable().getMenus().isEmpty())) {</span>
<span class="line-added"> 483             focusedMenu = getSkinnable().getMenus().get(index);</span>
<span class="line-added"> 484         }</span>
 485 
 486         if (focusedMenu != null &amp;&amp; focusedMenuIndex != -1) {
 487             openMenuButton = (MenuBarButton)container.getChildren().get(focusedMenuIndex);
 488             openMenuButton.setHover();
 489         }
 490     }
 491 
 492 
 493 
 494     /***************************************************************************
 495      *                                                                         *
 496      * Static methods                                                          *
 497      *                                                                         *
 498      **************************************************************************/
 499 
 500     // RT-22480: This is intended as private API for SceneBuilder,
 501     // pending fix for RT-19857: Keeping menu in the Mac menu bar when
 502     // there is no more stage
 503     /**
 504      * Set the default system menu bar. This allows an application to keep menu
 505      * in the system menu bar after the last Window is closed.
 506      * @param menuBar the menu bar
 507      */
 508     public static void setDefaultSystemMenuBar(final MenuBar menuBar) {
 509         if (Toolkit.getToolkit().getSystemMenu().isSupported()) {
 510             wrappedDefaultMenus.clear();
 511             for (Menu menu : menuBar.getMenus()) {
 512                 wrappedDefaultMenus.add(GlobalMenuAdapter.adapt(menu));
 513             }
 514             menuBar.getMenus().addListener((ListChangeListener&lt;Menu&gt;) c -&gt; {
 515                 wrappedDefaultMenus.clear();
 516                 for (Menu menu : menuBar.getMenus()) {
 517                     wrappedDefaultMenus.add(GlobalMenuAdapter.adapt(menu));
 518                 }
 519             });
 520         }
 521     }
 522 
 523     private static MenuBarSkin getMenuBarSkin(Stage stage) {
 524         if (systemMenuMap == null) return null;
 525         Reference&lt;MenuBarSkin&gt; skinRef = systemMenuMap.get(stage);
 526         return skinRef == null ? null : skinRef.get();
 527     }
 528 
 529     private static void setSystemMenu(Stage stage) {
 530         if (stage != null &amp;&amp; stage.isFocused()) {
 531             while (stage != null &amp;&amp; stage.getOwner() instanceof Stage) {
 532                 MenuBarSkin skin = getMenuBarSkin(stage);
 533                 if (skin != null &amp;&amp; skin.wrappedMenus != null) {
 534                     break;
 535                 } else {
 536                     // This is a secondary stage (dialog) that doesn&#39;t
 537                     // have own menu bar.
 538                     //
 539                     // Continue looking for a menu bar in the parent stage.
 540                     stage = (Stage)stage.getOwner();
 541                 }
 542             }
 543         } else {
 544             stage = null;
 545         }
 546 
 547         if (stage != currentMenuBarStage) {
 548             List&lt;MenuBase&gt; menuList = null;
 549             if (stage != null) {
 550                 MenuBarSkin skin = getMenuBarSkin(stage);
 551                 if (skin != null) {
 552                     menuList = skin.wrappedMenus;
 553                 }
 554             }
 555             if (menuList == null) {
 556                 menuList = wrappedDefaultMenus;
 557             }
 558             Toolkit.getToolkit().getSystemMenu().setMenus(menuList);
 559             currentMenuBarStage = stage;
 560         }
 561     }
 562 
 563     private static void initSystemMenuBar() {
 564         systemMenuMap = new WeakHashMap&lt;&gt;();
 565 
 566         final InvalidationListener focusedStageListener = ov -&gt; {
 567             setSystemMenu((Stage)((ReadOnlyProperty&lt;?&gt;)ov).getBean());
 568         };
 569 
 570         for (Window stage : stages) {
 571             stage.focusedProperty().addListener(focusedStageListener);
 572         }
 573         stages.addListener((ListChangeListener&lt;Window&gt;) c -&gt; {
 574             while (c.next()) {
 575                 for (Window stage : c.getRemoved()) {
 576                     stage.focusedProperty().removeListener(focusedStageListener);
 577                 }
 578                 for (Window stage : c.getAddedSubList()) {
 579                     stage.focusedProperty().addListener(focusedStageListener);
 580                     setSystemMenu((Stage) stage);
 581                 }
 582             }
 583         });
 584     }
 585 
 586 
 587 
 588     /***************************************************************************
 589      *                                                                         *
 590      * Properties                                                              *
 591      *                                                                         *
 592      **************************************************************************/
 593 
 594     /**
 595      * Specifies the spacing between menu buttons on the MenuBar.
 596      */
 597     // --- spacing
 598     private DoubleProperty spacing;
 599     public final void setSpacing(double value) {
 600         spacingProperty().set(snapSpaceX(value));
 601     }
 602 
 603     public final double getSpacing() {
 604         return spacing == null ? 0.0 : snapSpaceX(spacing.get());
 605     }
 606 
 607     public final DoubleProperty spacingProperty() {
 608         if (spacing == null) {
 609             spacing = new StyleableDoubleProperty() {
 610 
 611                 @Override
 612                 protected void invalidated() {
 613                     final double value = get();
 614                     container.setSpacing(value);
 615                 }
 616 
 617                 @Override
 618                 public Object getBean() {
 619                     return MenuBarSkin.this;
 620                 }
 621 
 622                 @Override
 623                 public String getName() {
 624                     return &quot;spacing&quot;;
 625                 }
 626 
 627                 @Override
 628                 public CssMetaData&lt;MenuBar,Number&gt; getCssMetaData() {
 629                     return SPACING;
 630                 }
 631             };
 632         }
 633         return spacing;
 634     }
 635 
 636     /**
 637      * Specifies the alignment of the menu buttons inside the MenuBar (by default
 638      * it is Pos.TOP_LEFT).
 639      */
 640     // --- container alignment
 641     private ObjectProperty&lt;Pos&gt; containerAlignment;
 642     public final void setContainerAlignment(Pos value) {
 643         containerAlignmentProperty().set(value);
 644     }
 645 
 646     public final Pos getContainerAlignment() {
 647         return containerAlignment == null ? Pos.TOP_LEFT : containerAlignment.get();
 648     }
 649 
 650     public final ObjectProperty&lt;Pos&gt; containerAlignmentProperty() {
 651         if (containerAlignment == null) {
 652             containerAlignment = new StyleableObjectProperty&lt;Pos&gt;(Pos.TOP_LEFT) {
 653 
 654                 @Override
 655                 public void invalidated() {
 656                     final Pos value = get();
 657                     container.setAlignment(value);
 658                 }
 659 
 660                 @Override
 661                 public Object getBean() {
 662                     return MenuBarSkin.this;
 663                 }
 664 
 665                 @Override
 666                 public String getName() {
 667                     return &quot;containerAlignment&quot;;
 668                 }
 669 
 670                 @Override
 671                 public CssMetaData&lt;MenuBar,Pos&gt; getCssMetaData() {
 672                     return ALIGNMENT;
 673                 }
 674             };
 675         }
 676         return containerAlignment;
 677     }
 678 
 679 
 680 
 681     /***************************************************************************
 682      *                                                                         *
 683      * Public API                                                              *
 684      *                                                                         *
 685      **************************************************************************/
 686 
 687     /** {@inheritDoc} */
 688     @Override public void dispose() {
 689         cleanUpSystemMenu();
 690         // call super.dispose last since it sets control to null
 691         super.dispose();
 692     }
 693 
 694     // Return empty insets when &quot;container&quot; is empty, which happens
 695     // when using the system menu bar.
 696 
 697     /** {@inheritDoc} */
 698     @Override protected double snappedTopInset() {
 699         return container.getChildren().isEmpty() ? 0 : super.snappedTopInset();
 700     }
 701     /** {@inheritDoc} */
 702     @Override protected double snappedBottomInset() {
 703         return container.getChildren().isEmpty() ? 0 : super.snappedBottomInset();
 704     }
 705     /** {@inheritDoc} */
 706     @Override protected double snappedLeftInset() {
 707         return container.getChildren().isEmpty() ? 0 : super.snappedLeftInset();
 708     }
 709     /** {@inheritDoc} */
 710     @Override protected double snappedRightInset() {
 711         return container.getChildren().isEmpty() ? 0 : super.snappedRightInset();
 712     }
 713 
 714     /**
 715      * Layout the menu bar. This is a simple horizontal layout like an hbox.
 716      * Any menu items which don&#39;t fit into it will simply be made invisible.
 717      */
 718     /** {@inheritDoc} */
 719     @Override protected void layoutChildren(final double x, final double y,
 720                                             final double w, final double h) {
 721         // layout the menus one after another
 722         container.resizeRelocate(x, y, w, h);
 723     }
 724 
 725     /** {@inheritDoc} */
 726     @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
 727         return container.minWidth(height) + snappedLeftInset() + snappedRightInset();
 728     }
 729 
 730     /** {@inheritDoc} */
 731     @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
 732         return container.prefWidth(height) + snappedLeftInset() + snappedRightInset();
 733     }
 734 
 735     /** {@inheritDoc} */
 736     @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
 737         return container.minHeight(width) + snappedTopInset() + snappedBottomInset();
 738     }
 739 
 740     /** {@inheritDoc} */
 741     @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
 742         return container.prefHeight(width) + snappedTopInset() + snappedBottomInset();
 743     }
 744 
 745     // grow horizontally, but not vertically
 746     /** {@inheritDoc} */
 747     @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
 748         return getSkinnable().prefHeight(-1);
 749     }
 750 
 751 
 752 
 753     /***************************************************************************
 754      *                                                                         *
 755      * Private implementation                                                  *
 756      *                                                                         *
 757      **************************************************************************/
 758 
 759     // For testing purpose only.
 760     MenuButton getNodeForMenu(int i) {
 761         if (i &lt; container.getChildren().size()) {
 762             return (MenuBarButton)container.getChildren().get(i);
 763         }
 764         return null;
 765     }
 766 
 767     int getFocusedMenuIndex() {
 768         return focusedMenuIndex;
 769     }
 770 
 771     private boolean menusContainCustomMenuItem() {
 772         for (Menu menu : getSkinnable().getMenus()) {
 773             if (menuContainsCustomMenuItem(menu)) {
 774                 System.err.println(&quot;Warning: MenuBar ignored property useSystemMenuBar because menus contain CustomMenuItem&quot;);
 775                 return true;
 776             }
 777         }
 778         return false;
 779     }
 780 
 781     private boolean menuContainsCustomMenuItem(Menu menu) {
 782         for (MenuItem mi : menu.getItems()) {
 783             if (mi instanceof CustomMenuItem &amp;&amp; !(mi instanceof SeparatorMenuItem)) {
 784                 return true;
 785             } else if (mi instanceof Menu) {
 786                 if (menuContainsCustomMenuItem((Menu)mi)) {
 787                     return true;
 788                 }
 789             }
 790         }
 791         return false;
 792     }
 793 
 794     private int getMenuBarButtonIndex(MenuBarButton m) {
 795         for (int i= 0; i &lt; container.getChildren().size(); i++) {
 796             MenuBarButton menuButton = (MenuBarButton)container.getChildren().get(i);
 797             if (m == menuButton) {
 798                 return i;
 799             }
 800         }
 801         return -1;
 802     }
 803 
 804     private void updateActionListeners(MenuItem item, boolean add) {
 805         if (item instanceof Menu) {
 806             Menu menu = (Menu) item;
 807 
 808             if (add) {
 809                 menu.getItems().addListener(menuItemListener);
 810             } else {
 811                 menu.getItems().removeListener(menuItemListener);
 812             }
 813 
 814             for (MenuItem mi : menu.getItems()) {
 815                 updateActionListeners(mi, add);
 816             }
 817         } else {
 818             if (add) {
 819                 item.addEventHandler(ActionEvent.ACTION, menuActionEventHandler);
 820             } else {
 821                 item.removeEventHandler(ActionEvent.ACTION, menuActionEventHandler);
 822             }
 823         }
 824     }
 825 
 826     private void rebuildUI() {
 827         getSkinnable().focusedProperty().removeListener(menuBarFocusedPropertyListener);
 828         for (Menu m : getSkinnable().getMenus()) {
 829             // remove action listeners
 830             updateActionListeners(m, false);
 831 
 832             m.visibleProperty().removeListener(menuVisibilityChangeListener);
 833         }
 834         for (Node n : container.getChildren()) {
 835             // Stop observing menu&#39;s showing &amp; disable property for changes.
 836             // Need to unbind before clearing container&#39;s children.
 837             MenuBarButton menuButton = (MenuBarButton)n;
 838             menuButton.hide();
 839             menuButton.menu.showingProperty().removeListener(menuButton.menuListener);
 840             menuButton.disableProperty().unbind();
 841             menuButton.textProperty().unbind();
 842             menuButton.graphicProperty().unbind();
 843             menuButton.styleProperty().unbind();
 844 
 845             menuButton.dispose();
 846 
 847             // RT-29729 : old instance of context menu window/popup for this MenuButton needs
 848             // to be cleaned up. Setting the skin to null - results in a call to dispose()
 849             // on the skin which in this case MenuButtonSkinBase - does the subsequent
 850             // clean up to ContextMenu/popup window.
 851             menuButton.setSkin(null);
 852             menuButton = null;
 853         }
 854         container.getChildren().clear();
 855 
 856         if (Toolkit.getToolkit().getSystemMenu().isSupported()) {
 857             final Scene scene = getSkinnable().getScene();
 858             if (scene != null) {
 859                 // RT-36554 - make sure system menu is updated when this MenuBar&#39;s scene changes.
 860                 if (sceneChangeListener == null) {
 861                     sceneChangeListener = (observable, oldValue, newValue) -&gt; {
 862 
 863                         if (oldValue != null) {
 864                             if (oldValue.getWindow() instanceof Stage) {
 865                                 final Stage stage = (Stage) oldValue.getWindow();
 866                                 final MenuBarSkin curMBSkin = getMenuBarSkin(stage);
 867                                 if (curMBSkin == MenuBarSkin.this) {
 868                                     curMBSkin.wrappedMenus = null;
 869                                     systemMenuMap.remove(stage);
 870                                     if (currentMenuBarStage == stage) {
 871                                         currentMenuBarStage = null;
 872                                         setSystemMenu(stage);
 873                                     }
 874                                 } else {
 875                                     if (getSkinnable().isUseSystemMenuBar() &amp;&amp;
 876                                             curMBSkin != null &amp;&amp; curMBSkin.getSkinnable() != null &amp;&amp;
 877                                             curMBSkin.getSkinnable().isUseSystemMenuBar()) {
 878                                         curMBSkin.getSkinnable().setUseSystemMenuBar(false);
 879                                     }
 880                                 }
 881                             }
 882                         }
 883 
 884                         if (newValue != null) {
 885                             if (getSkinnable().isUseSystemMenuBar() &amp;&amp; !menusContainCustomMenuItem()) {
 886                                 if (newValue.getWindow() instanceof Stage) {
 887                                     final Stage stage = (Stage) newValue.getWindow();
 888                                     if (systemMenuMap == null) {
 889                                         initSystemMenuBar();
 890                                     }
 891                                     wrappedMenus = new ArrayList&lt;&gt;();
 892                                     systemMenuMap.put(stage, new WeakReference&lt;&gt;(this));
 893                                     for (Menu menu : getSkinnable().getMenus()) {
 894                                         wrappedMenus.add(GlobalMenuAdapter.adapt(menu));
 895                                     }
 896                                     currentMenuBarStage = null;
 897                                     setSystemMenu(stage);
 898 
 899                                     // TODO: Why two request layout calls here?
 900                                     getSkinnable().requestLayout();
 901                                     javafx.application.Platform.runLater(() -&gt; getSkinnable().requestLayout());
 902                                 }
 903                             }
 904                         }
 905                     };
 906                     getSkinnable().sceneProperty().addListener(sceneChangeListener);
 907                 }
 908 
 909                 // Fake a change event to trigger an update to the system menu.
 910                 sceneChangeListener.changed(getSkinnable().sceneProperty(), scene, scene);
 911 
 912                 // If the system menu references this MenuBarSkin, then we&#39;re done with rebuilding the UI.
 913                 // If the system menu does not reference this MenuBarSkin, then the MenuBar is a child of the scene
 914                 // and we continue with the update.
 915                 // If there is no system menu but this skinnable uses the system menu bar, then the
 916                 // stage just isn&#39;t focused yet (see setSystemMenu) and we&#39;re done rebuilding the UI.
 917                 if (currentMenuBarStage != null ? getMenuBarSkin(currentMenuBarStage) == MenuBarSkin.this : getSkinnable().isUseSystemMenuBar()) {
 918                     return;
 919                 }
 920 
 921             } else {
 922                 // if scene is null, make sure this MenuBarSkin isn&#39;t left behind as the system menu
 923                 if (currentMenuBarStage != null) {
 924                     final MenuBarSkin curMBSkin = getMenuBarSkin(currentMenuBarStage);
 925                     if (curMBSkin == MenuBarSkin.this) {
 926                         setSystemMenu(null);
 927                     }
 928                 }
 929             }
 930         }
 931 
 932         getSkinnable().focusedProperty().addListener(menuBarFocusedPropertyListener);
 933         for (final Menu menu : getSkinnable().getMenus()) {
 934 
 935             menu.visibleProperty().addListener(menuVisibilityChangeListener);
 936 
 937             if (!menu.isVisible()) continue;
 938             final MenuBarButton menuButton = new MenuBarButton(this, menu);
 939             menuButton.setFocusTraversable(false);
 940             menuButton.getStyleClass().add(&quot;menu&quot;);
 941             menuButton.setStyle(menu.getStyle()); // copy style
 942 
 943             menuButton.getItems().setAll(menu.getItems());
 944             container.getChildren().add(menuButton);
 945 
 946             menuButton.menuListener = (observable, oldValue, newValue) -&gt; {
 947                 if (menu.isShowing()) {
 948                     menuButton.show();
 949                     menuModeStart(container.getChildren().indexOf(menuButton));
 950                 } else {
 951                     menuButton.hide();
 952                 }
 953             };
 954             menuButton.menu = menu;
 955             menu.showingProperty().addListener(menuButton.menuListener);
 956             menuButton.disableProperty().bindBidirectional(menu.disableProperty());
 957             menuButton.textProperty().bind(menu.textProperty());
 958             menuButton.graphicProperty().bind(menu.graphicProperty());
 959             menuButton.styleProperty().bind(menu.styleProperty());
 960             menuButton.getProperties().addListener((MapChangeListener&lt;Object, Object&gt;) c -&gt; {
 961                  if (c.wasAdded() &amp;&amp; MenuButtonSkin.AUTOHIDE.equals(c.getKey())) {
 962                     menuButton.getProperties().remove(MenuButtonSkin.AUTOHIDE);
 963                     menu.hide();
 964                 }
 965             });
 966             menuButton.showingProperty().addListener((observable, oldValue, isShowing) -&gt; {
 967                 if (isShowing) {
 968                     if(openMenuButton == null &amp;&amp; focusedMenuIndex != -1)
 969                         openMenuButton = (MenuBarButton)container.getChildren().get(focusedMenuIndex);
 970 
 971                     if (openMenuButton != null &amp;&amp; openMenuButton != menuButton) {
 972                         openMenuButton.clearHover();
 973                     }
 974                     openMenuButton = menuButton;
 975                     showMenu(menu);
 976                 } else {
 977                     // Fix for JDK-8167138 - we need to clear out the openMenu / openMenuButton
 978                     // when the menu is hidden (e.g. via autoHide), so that we can open it again
 979                     // the next time (if it is the first menu requested to show)
 980                     openMenu = null;
 981                     openMenuButton = null;
 982                 }
 983             });
 984 
 985             menuButton.setOnMousePressed(event -&gt; {
 986                 pendingDismiss = menuButton.isShowing();
 987 
 988                 // check if the owner window has focus
 989                 if (menuButton.getScene().getWindow().isFocused()) {
 990                     showMenu(menu);
 991                     // update FocusedIndex
 992                     menuModeStart(getMenuBarButtonIndex(menuButton));
 993                 }
 994             });
 995 
 996             menuButton.setOnMouseReleased(event -&gt; {
 997                 // check if the owner window has focus
 998                 if (menuButton.getScene().getWindow().isFocused()) {
 999                     if (pendingDismiss) {
1000                         resetOpenMenu();
1001                     }
1002                 }
1003                 pendingDismiss = false;
1004             });
1005 
1006             menuButton.setOnMouseEntered(event -&gt; {
1007                 // check if the owner window has focus
1008                 if (menuButton.getScene() != null &amp;&amp; menuButton.getScene().getWindow() != null &amp;&amp;
1009                         menuButton.getScene().getWindow().isFocused()) {
1010                     if (openMenuButton != null &amp;&amp; openMenuButton != menuButton) {
1011                             openMenuButton.clearHover();
1012                             openMenuButton = null;
1013                             openMenuButton = menuButton;
1014                     }
1015                     updateFocusedIndex();
1016                     if (openMenu != null &amp;&amp; openMenu != menu) {
1017                         showMenu(menu);
1018                     }
1019                 }
1020             });
1021             updateActionListeners(menu, true);
1022         }
1023         getSkinnable().requestLayout();
1024     }
1025 
1026     private void cleanUpSystemMenu() {
1027         if (sceneChangeListener != null &amp;&amp; getSkinnable() != null) {
1028             getSkinnable().sceneProperty().removeListener(sceneChangeListener);
1029             // rebuildUI creates sceneChangeListener and adds sceneChangeListener to sceneProperty,
1030             // so sceneChangeListener needs to be reset to null in the off chance that this
1031             // skin instance is reused.
1032             sceneChangeListener = null;
1033         }
1034 
1035         if (currentMenuBarStage != null &amp;&amp; getMenuBarSkin(currentMenuBarStage) == MenuBarSkin.this) {
1036             setSystemMenu(null);
1037         }
1038 
1039         if (systemMenuMap != null) {
1040             Iterator&lt;Map.Entry&lt;Stage,Reference&lt;MenuBarSkin&gt;&gt;&gt; iterator = systemMenuMap.entrySet().iterator();
1041             while (iterator.hasNext()) {
1042                 Map.Entry&lt;Stage,Reference&lt;MenuBarSkin&gt;&gt; entry = iterator.next();
1043                 Reference&lt;MenuBarSkin&gt; ref = entry.getValue();
1044                 MenuBarSkin skin = ref != null ? ref.get() : null;
1045                 if (skin == null || skin == MenuBarSkin.this) {
1046                     iterator.remove();
1047                 }
1048             }
1049         }
1050     }
1051 
1052     private boolean isMenuEmpty(Menu menu) {
1053         boolean retVal = true;
1054         if (menu != null) {
1055             for (MenuItem m : menu.getItems()) {
1056                 if (m != null &amp;&amp; m.isVisible()) retVal = false;
1057             }
1058         }
1059         return retVal;
1060     }
1061 
1062     private void resetOpenMenu() {
1063         if (openMenu != null) {
1064             openMenu.hide();
1065             openMenu = null;
1066         }
1067     }
1068 
1069     private void unSelectMenus() {
1070         clearMenuButtonHover();
1071         if (focusedMenuIndex == -1) return;
1072         if (openMenu != null) {
1073             openMenu.hide();
1074             openMenu = null;
1075         }
1076         if (openMenuButton != null) {
1077             openMenuButton.clearHover();
1078             openMenuButton = null;
1079         }
1080         menuModeEnd();
1081     }
1082 
1083     private void menuModeStart(int newIndex) {
1084         if (focusedMenuIndex == -1) {
1085             SceneHelper.getSceneAccessor().setTransientFocusContainer(getSkinnable().getScene(), getSkinnable());
1086         }
1087         setFocusedMenuIndex(newIndex);
1088     }
1089 
1090     private void menuModeEnd() {
1091         if (focusedMenuIndex != -1) {
1092             SceneHelper.getSceneAccessor().setTransientFocusContainer(getSkinnable().getScene(), null);
1093 
1094             /* Return the a11y focus to a control in the scene. */
1095             getSkinnable().notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_NODE);
1096         }
1097         setFocusedMenuIndex(-1);
1098     }
1099 
1100     private void moveToMenu(Direction dir, boolean doShow) {
1101         boolean showNextMenu = doShow &amp;&amp; focusedMenu.isShowing();
1102         findSibling(dir, focusedMenuIndex).ifPresent(p -&gt; {
1103             setFocusedMenuIndex(p.getValue());
1104             if (showNextMenu) {
1105                 // we explicitly do *not* allow selection - we are moving
1106                 // to a sibling menu, and therefore selection should be reset
1107                 showMenu(p.getKey(), false);
1108             }
1109         });
1110     }
1111 
1112     private Optional&lt;Pair&lt;Menu,Integer&gt;&gt; findSibling(Direction dir, int startIndex) {
1113         if (startIndex == -1) {
1114             return Optional.empty();
1115         }
1116 
1117         final int totalMenus = getSkinnable().getMenus().size();
1118         int i = 0;
1119         int nextIndex = 0;
1120 
1121         // Traverse all menus in menubar to find nextIndex
1122         while (i &lt; totalMenus) {
1123             i++;
1124 
1125             nextIndex = (startIndex + (dir.isForward() ? 1 : -1)) % totalMenus;
1126 
1127             if (nextIndex == -1) {
1128                 // loop backwards to end
1129                 nextIndex = totalMenus - 1;
1130             }
1131 
1132             // if menu at nextIndex is disabled, skip it
1133             if (getSkinnable().getMenus().get(nextIndex).isDisable()) {
1134                 // Calculate new nextIndex by continuing loop
1135                 startIndex = nextIndex;
1136             } else {
1137                 // nextIndex is to be highlighted
1138                 break;
1139             }
1140         }
1141 
1142         clearMenuButtonHover();
1143         return Optional.of(new Pair&lt;&gt;(getSkinnable().getMenus().get(nextIndex), nextIndex));
1144     }
1145 
1146     private void updateFocusedIndex() {
1147         int index = 0;
1148         for(Node n : container.getChildren()) {
1149             if (n.isHover()) {
1150                 setFocusedMenuIndex(index);
1151                 return;
1152             }
1153             index++;
1154         }
1155         menuModeEnd();
1156     }
1157 
1158     private void clearMenuButtonHover() {
1159          for(Node n : container.getChildren()) {
1160             if (n.isHover()) {
1161                 ((MenuBarButton)n).clearHover();
1162                 ((MenuBarButton)n).disarm();
1163                 return;
1164             }
1165         }
1166     }
1167 
1168 
1169 
1170     /***************************************************************************
1171      *                                                                         *
1172      * CSS                                                                     *
1173      *                                                                         *
1174      **************************************************************************/
1175 
1176     private static final CssMetaData&lt;MenuBar,Number&gt; SPACING =
1177             new CssMetaData&lt;MenuBar,Number&gt;(&quot;-fx-spacing&quot;,
1178                     SizeConverter.getInstance(), 0.0) {
1179 
1180                 @Override
1181                 public boolean isSettable(MenuBar n) {
1182                     final MenuBarSkin skin = (MenuBarSkin) n.getSkin();
1183                     return skin.spacing == null || !skin.spacing.isBound();
1184                 }
1185 
1186                 @Override
1187                 public StyleableProperty&lt;Number&gt; getStyleableProperty(MenuBar n) {
1188                     final MenuBarSkin skin = (MenuBarSkin) n.getSkin();
1189                     return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)skin.spacingProperty();
1190                 }
1191             };
1192 
1193     private static final CssMetaData&lt;MenuBar,Pos&gt; ALIGNMENT =
1194             new CssMetaData&lt;MenuBar,Pos&gt;(&quot;-fx-alignment&quot;,
1195                     new EnumConverter&lt;Pos&gt;(Pos.class), Pos.TOP_LEFT ) {
1196 
1197                 @Override
1198                 public boolean isSettable(MenuBar n) {
1199                     final MenuBarSkin skin = (MenuBarSkin) n.getSkin();
1200                     return skin.containerAlignment == null || !skin.containerAlignment.isBound();
1201                 }
1202 
1203                 @Override
1204                 public StyleableProperty&lt;Pos&gt; getStyleableProperty(MenuBar n) {
1205                     final MenuBarSkin skin = (MenuBarSkin) n.getSkin();
1206                     return (StyleableProperty&lt;Pos&gt;)(WritableValue&lt;Pos&gt;)skin.containerAlignmentProperty();
1207                 }
1208             };
1209 
1210 
1211     private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
1212     static {
1213 
1214         final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1215                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
1216 
1217         // StackPane also has -fx-alignment. Replace it with
1218         // MenuBarSkin&#39;s.
1219         // TODO: Really should be able to reference StackPane.StyleableProperties.ALIGNMENT
1220         final String alignmentProperty = ALIGNMENT.getProperty();
1221         for (int n=0, nMax=styleables.size(); n&lt;nMax; n++) {
1222             final CssMetaData&lt;?,?&gt; prop = styleables.get(n);
1223             if (alignmentProperty.equals(prop.getProperty())) styleables.remove(prop);
1224         }
1225 
1226         styleables.add(SPACING);
1227         styleables.add(ALIGNMENT);
1228         STYLEABLES = Collections.unmodifiableList(styleables);
1229 
1230     }
1231 
1232     /**
1233      * Returns the CssMetaData associated with this class, which may include the
1234      * CssMetaData of its superclasses.
1235      * @return the CssMetaData associated with this class, which may include the
1236      * CssMetaData of its superclasses
1237      */
1238     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1239         return STYLEABLES;
1240     }
1241 
1242     /**
1243      * {@inheritDoc}
1244      */
1245     @Override
1246     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
1247         return getClassCssMetaData();
1248     }
1249 
1250     /***************************************************************************
1251      *                                                                         *
1252      * Accessibility handling                                                  *
1253      *                                                                         *
1254      **************************************************************************/
1255 
1256     /** {@inheritDoc} */
1257     @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1258         switch (attribute) {
1259             case FOCUS_NODE: return openMenuButton;
1260             default: return super.queryAccessibleAttribute(attribute, parameters);
1261         }
1262     }
1263 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
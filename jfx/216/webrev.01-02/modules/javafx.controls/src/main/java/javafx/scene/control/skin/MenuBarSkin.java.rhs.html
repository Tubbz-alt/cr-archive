<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/skin/MenuBarSkin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control.skin;
  27 
  28 import static com.sun.javafx.FXPermissions.ACCESS_WINDOW_LIST_PERMISSION;
  29 
  30 import com.sun.javafx.scene.traversal.Direction;
  31 import javafx.css.converter.EnumConverter;
  32 import javafx.css.converter.SizeConverter;
  33 import com.sun.javafx.scene.control.MenuBarButton;
  34 import com.sun.javafx.scene.control.skin.Utils;
  35 import com.sun.javafx.scene.traversal.ParentTraversalEngine;
  36 import javafx.beans.InvalidationListener;
  37 import javafx.beans.property.DoubleProperty;
  38 import javafx.beans.property.ObjectProperty;
  39 import javafx.beans.property.ReadOnlyProperty;
  40 import javafx.beans.value.ChangeListener;
  41 import javafx.beans.value.WeakChangeListener;
  42 import javafx.beans.value.WritableValue;
  43 import javafx.collections.ListChangeListener;
  44 import javafx.collections.MapChangeListener;
  45 import javafx.collections.ObservableList;
  46 import javafx.css.CssMetaData;
  47 import javafx.css.Styleable;
  48 import javafx.css.StyleableDoubleProperty;
  49 import javafx.css.StyleableObjectProperty;
  50 import javafx.css.StyleableProperty;
  51 import javafx.event.ActionEvent;
  52 import javafx.event.EventHandler;
  53 import javafx.event.WeakEventHandler;
  54 import javafx.geometry.Bounds;
  55 import javafx.geometry.NodeOrientation;
  56 import javafx.geometry.Pos;
  57 import javafx.scene.AccessibleAttribute;
  58 import javafx.scene.Node;
  59 import javafx.scene.Scene;
  60 import javafx.scene.control.Control;
  61 import javafx.scene.control.CustomMenuItem;
  62 import javafx.scene.control.Menu;
  63 import javafx.scene.control.MenuBar;
  64 import javafx.scene.control.MenuButton;
  65 import javafx.scene.control.MenuItem;
  66 import javafx.scene.control.SeparatorMenuItem;
  67 import javafx.scene.control.Skin;
  68 import javafx.scene.control.SkinBase;
  69 import javafx.scene.input.KeyCombination;
  70 import javafx.scene.input.KeyEvent;
  71 import javafx.scene.input.MouseEvent;
  72 import javafx.scene.layout.HBox;
  73 import javafx.stage.Stage;
  74 
  75 import static javafx.scene.input.KeyCode.*;
  76 
  77 import java.lang.ref.Reference;
  78 import java.lang.ref.WeakReference;
  79 import java.util.ArrayList;
  80 import java.util.Collections;
  81 import java.util.Iterator;
  82 import java.util.List;
  83 import java.util.Map;
  84 import java.util.Optional;
  85 import java.util.WeakHashMap;
  86 
  87 import com.sun.javafx.menu.MenuBase;
  88 import com.sun.javafx.scene.ParentHelper;
  89 import com.sun.javafx.scene.SceneHelper;
  90 import com.sun.javafx.scene.control.GlobalMenuAdapter;
  91 import com.sun.javafx.tk.Toolkit;
  92 import java.util.function.Predicate;
  93 import javafx.stage.Window;
  94 import javafx.util.Pair;
  95 
  96 import java.security.AccessController;
  97 import java.security.PrivilegedAction;
  98 
  99 /**
 100  * Default skin implementation for the {@link MenuBar} control. In essence it is
 101  * a simple toolbar. For the time being there is no overflow behavior and we just
 102  * hide nodes which fall outside the bounds.
 103  *
 104  * @see MenuBar
 105  * @since 9
 106  */
 107 public class MenuBarSkin extends SkinBase&lt;MenuBar&gt; {
 108 
 109     private static final ObservableList&lt;Window&gt; stages;
 110 
 111     static {
 112         final Predicate&lt;Window&gt; findStage = (w) -&gt; w instanceof Stage;
 113         ObservableList&lt;Window&gt; windows = AccessController.doPrivileged(
 114             (PrivilegedAction&lt;ObservableList&lt;Window&gt;&gt;) () -&gt; Window.getWindows(),
 115             null,
 116             ACCESS_WINDOW_LIST_PERMISSION);
 117         stages = windows.filtered(findStage);
 118     }
 119 
 120     /***************************************************************************
 121      *                                                                         *
 122      * Private fields                                                          *
 123      *                                                                         *
 124      **************************************************************************/
 125 
 126     private final HBox container;
 127 
 128     // represents the currently _open_ menu
 129     private Menu openMenu;
 130     private MenuBarButton openMenuButton;
 131 
 132     // represents the currently _focused_ menu. If openMenu is non-null, this should equal
 133     // openMenu. If openMenu is null, this can be any menu in the menu bar.
 134     private Menu focusedMenu;
 135     private int focusedMenuIndex = -1;
 136 
 137     private static WeakHashMap&lt;Stage, Reference&lt;MenuBarSkin&gt;&gt; systemMenuMap;
 138     private static List&lt;MenuBase&gt; wrappedDefaultMenus = new ArrayList&lt;&gt;();
 139     private static Stage currentMenuBarStage;
 140     private List&lt;MenuBase&gt; wrappedMenus;
 141 
 142     private WeakEventHandler&lt;KeyEvent&gt; weakSceneKeyEventHandler;
 143     private WeakEventHandler&lt;MouseEvent&gt; weakSceneMouseEventHandler;
 144     private WeakEventHandler&lt;KeyEvent&gt; weakSceneAltKeyEventHandler;
 145     private WeakChangeListener&lt;Boolean&gt; weakWindowFocusListener;
 146     private WeakChangeListener&lt;Window&gt; weakWindowSceneListener;
 147     private EventHandler&lt;KeyEvent&gt; keyEventHandler;
 148     private EventHandler&lt;KeyEvent&gt; altKeyEventHandler;
 149     private EventHandler&lt;MouseEvent&gt; mouseEventHandler;
 150     private ChangeListener&lt;Boolean&gt; menuBarFocusedPropertyListener;
 151     private ChangeListener&lt;Scene&gt; sceneChangeListener;
 152     private ChangeListener&lt;Boolean&gt; menuVisibilityChangeListener;
 153 
 154     private boolean pendingDismiss = false;
 155 
 156     private boolean altKeyPressed = false;
 157 
 158 
 159     /***************************************************************************
 160      *                                                                         *
 161      * Listeners / Callbacks                                                   *
 162      *                                                                         *
 163      **************************************************************************/
 164 
 165     // RT-20411 : reset menu selected/focused state
 166     private EventHandler&lt;ActionEvent&gt; menuActionEventHandler = t -&gt; {
 167         if (t.getSource() instanceof CustomMenuItem) {
 168             // RT-29614 If CustomMenuItem hideOnClick is false, dont hide
 169             CustomMenuItem cmi = (CustomMenuItem)t.getSource();
 170             if (!cmi.isHideOnClick()) return;
 171         }
 172         unSelectMenus();
 173     };
 174 
 175     private ListChangeListener&lt;MenuItem&gt; menuItemListener = (c) -&gt; {
 176         while (c.next()) {
 177             for (MenuItem mi : c.getAddedSubList()) {
 178                 updateActionListeners(mi, true);
 179             }
 180             for (MenuItem mi: c.getRemoved()) {
 181                 updateActionListeners(mi, false);
 182             }
 183         }
 184     };
 185 
 186     Runnable firstMenuRunnable = new Runnable() {
 187         public void run() {
 188             /*
 189             ** check that this menubar&#39;s container has contents,
 190             ** and that the first item is a MenuButton....
 191             ** otherwise the transfer is off!
 192             */
 193             if (container.getChildren().size() &gt; 0) {
 194                 if (container.getChildren().get(0) instanceof MenuButton) {
 195 //                        container.getChildren().get(0).requestFocus();
 196                     if (focusedMenuIndex != 0) {
 197                         unSelectMenus();
 198                         menuModeStart(0);
 199                         openMenuButton = ((MenuBarButton)container.getChildren().get(0));
 200 //                        openMenu = getSkinnable().getMenus().get(0);
 201                         openMenuButton.setHover();
 202                     }
 203                     else {
 204                         unSelectMenus();
 205                     }
 206                 }
 207             }
 208         }
 209     };
 210 
 211 
 212 
 213     /***************************************************************************
 214      *                                                                         *
 215      * Constructors                                                            *
 216      *                                                                         *
 217      **************************************************************************/
 218 
 219     /**
 220      * Creates a new MenuBarSkin instance, installing the necessary child
 221      * nodes into the Control {@link Control#getChildren() children} list, as
 222      * well as the necessary input mappings for handling key, mouse, etc events.
 223      *
 224      * @param control The control that this skin should be installed onto.
 225      */
 226     public MenuBarSkin(final MenuBar control) {
 227         super(control);
 228 
 229         container = new HBox();
 230         container.getStyleClass().add(&quot;container&quot;);
 231         getChildren().add(container);
 232 
 233         // Key navigation
 234         keyEventHandler = event -&gt; {
 235             // process right left and may be tab key events
 236             if (focusedMenu != null) {
 237                 switch (event.getCode()) {
 238                     case LEFT: {
 239                         boolean isRTL = control.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT;
 240                         if (control.getScene().getWindow().isFocused()) {
 241                             if (openMenu != null &amp;&amp; !openMenu.isShowing()) {
 242                                 if (isRTL) {
 243                                     moveToMenu(Direction.NEXT, false); // just move the selection bar
 244                                 } else {
 245                                     moveToMenu(Direction.PREVIOUS, false); // just move the selection bar
 246                                 }
 247                                 event.consume();
 248                                 return;
 249                             }
 250                             if (isRTL) {
 251                                 moveToMenu(Direction.NEXT, true);
 252                             } else {
 253                                 moveToMenu(Direction.PREVIOUS, true);
 254                             }
 255                         }
 256                         event.consume();
 257                         break;
 258                     }
 259                     case RIGHT:
 260                     {
 261                         boolean isRTL = control.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT;
 262                         if (control.getScene().getWindow().isFocused()) {
 263                             if (openMenu != null &amp;&amp; !openMenu.isShowing()) {
 264                                 if (isRTL) {
 265                                     moveToMenu(Direction.PREVIOUS, false); // just move the selection bar
 266                                 } else {
 267                                     moveToMenu(Direction.NEXT, false); // just move the selection bar
 268                                 }
 269                                 event.consume();
 270                                 return;
 271                             }
 272                             if (isRTL) {
 273                                 moveToMenu(Direction.PREVIOUS, true);
 274                             } else {
 275                                 moveToMenu(Direction.NEXT, true);
 276                             }
 277                         }
 278                         event.consume();
 279                         break;
 280                     }
 281                     case DOWN:
 282                     //case SPACE:
 283                     //case ENTER:
 284                         // RT-18859: Doing nothing for space and enter
 285                         if (control.getScene().getWindow().isFocused()) {
 286                             if (focusedMenuIndex != -1) {
 287                                 Menu menuToOpen = getSkinnable().getMenus().get(focusedMenuIndex);
 288                                 showMenu(menuToOpen, true);
 289                                 event.consume();
 290                             }
 291                         }
 292                         break;
 293                     case ESCAPE:
 294                         unSelectMenus();
 295                         event.consume();
 296                         break;
 297                 default:
 298                     break;
 299                 }
 300             }
 301         };
 302         menuBarFocusedPropertyListener = (ov, t, t1) -&gt; {
 303             unSelectMenus();
 304             if (t1 &amp;&amp; !container.getChildren().isEmpty()) {
 305                 // RT-23147 when MenuBar&#39;s focusTraversable is true the first
 306                 // menu will visually indicate focus
 307                 menuModeStart(0);
 308                 openMenuButton = ((MenuBarButton)container.getChildren().get(0));
 309                 setFocusedMenuIndex(0);
 310                 openMenuButton.setHover();
 311             }
 312          };
 313         weakSceneKeyEventHandler = new WeakEventHandler&lt;KeyEvent&gt;(keyEventHandler);
 314         Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -&gt; {
 315             scene.addEventFilter(KeyEvent.KEY_PRESSED, weakSceneKeyEventHandler);
 316         });
 317 
 318         // When we click else where in the scene - menu selection should be cleared.
 319         mouseEventHandler = t -&gt; {
 320             Bounds containerScreenBounds = container.localToScreen(container.getLayoutBounds());
 321             if (containerScreenBounds == null || !containerScreenBounds.contains(t.getScreenX(), t.getScreenY())) {
 322                 unSelectMenus();
 323             }
 324         };
 325         weakSceneMouseEventHandler = new WeakEventHandler&lt;MouseEvent&gt;(mouseEventHandler);
 326         Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -&gt; {
 327             scene.addEventFilter(MouseEvent.MOUSE_CLICKED, weakSceneMouseEventHandler);
 328         });
 329 
 330         weakWindowFocusListener = new WeakChangeListener&lt;Boolean&gt;((ov, t, t1) -&gt; {
 331             if (!t1) {
 332               unSelectMenus();
 333             }
 334         });
 335         // When the parent window looses focus - menu selection should be cleared
 336         Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -&gt; {
 337             if (scene.getWindow() != null) {
 338                 scene.getWindow().focusedProperty().addListener(weakWindowFocusListener);
 339             } else {
 340                 ChangeListener&lt;Window&gt; sceneWindowListener = (observable, oldValue, newValue) -&gt; {
 341                     if (oldValue != null)
 342                         oldValue.focusedProperty().removeListener(weakWindowFocusListener);
 343                     if (newValue != null)
 344                         newValue.focusedProperty().addListener(weakWindowFocusListener);
 345                 };
 346                 weakWindowSceneListener = new WeakChangeListener&lt;&gt;(sceneWindowListener);
 347                 scene.windowProperty().addListener(weakWindowSceneListener);
 348             }
 349         });
 350 
 351         menuVisibilityChangeListener = (ov, t, t1) -&gt; {
 352             rebuildUI();
 353         };
 354 
 355         rebuildUI();
 356         control.getMenus().addListener((ListChangeListener&lt;Menu&gt;) c -&gt; {
 357             rebuildUI();
 358         });
 359 
 360         if (Toolkit.getToolkit().getSystemMenu().isSupported()) {
 361             control.useSystemMenuBarProperty().addListener(valueModel -&gt; {
 362                 rebuildUI();
 363             });
 364         }
 365 
 366         // When the mouse leaves the menu, the last hovered item should lose
 367         // it&#39;s focus so that it is no longer selected. This code returns focus
 368         // to the MenuBar itself, such that keyboard navigation can continue.
 369           // fix RT-12254 : menu bar should not request focus on mouse exit.
 370 //        addEventFilter(MouseEvent.MOUSE_EXITED, new EventHandler&lt;MouseEvent&gt;() {
 371 //            @Override
 372 //            public void handle(MouseEvent event) {
 373 //                requestFocus();
 374 //            }
 375 //        });
 376 
 377         /*
 378         ** add an accelerator for F10 on windows and ctrl+F10 on mac/linux
 379         ** pressing f10 will select the first menu button on a menubar
 380         */
 381         final KeyCombination acceleratorKeyCombo;
 382         if (com.sun.javafx.util.Utils.isMac()) {
 383            acceleratorKeyCombo = KeyCombination.keyCombination(&quot;ctrl+F10&quot;);
 384         } else {
 385            acceleratorKeyCombo = KeyCombination.keyCombination(&quot;F10&quot;);
 386         }
 387 
 388         altKeyEventHandler = e -&gt; {
 389             if (e.getEventType() == KeyEvent.KEY_PRESSED) {
 390                 // Clear menu selection when ALT is pressed by itself
 391                 altKeyPressed = false;
 392                 if (e.getCode() == ALT &amp;&amp; !e.isConsumed()) {
 393                     if (focusedMenuIndex == -1) {
 394                         altKeyPressed = true;
 395                     }
 396                     unSelectMenus();
 397                 }
 398             } else if (e.getEventType() == KeyEvent.KEY_RELEASED) {
 399                 // Put focus on the first menu when ALT is released
 400                 // directly after being pressed by itself
 401                 if (altKeyPressed &amp;&amp; e.getCode() == ALT &amp;&amp; !e.isConsumed()) {
 402                     firstMenuRunnable.run();
 403                 }
 404                 altKeyPressed = false;
 405             }
 406         };
 407         weakSceneAltKeyEventHandler = new WeakEventHandler&lt;&gt;(altKeyEventHandler);
 408 
 409         Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -&gt; {
 410             scene.getAccelerators().put(acceleratorKeyCombo, firstMenuRunnable);
 411             scene.addEventHandler(KeyEvent.ANY, weakSceneAltKeyEventHandler);
 412         });
 413 
 414         ParentTraversalEngine engine = new ParentTraversalEngine(getSkinnable());
 415         engine.addTraverseListener((node, bounds) -&gt; {
 416             if (openMenu != null) openMenu.hide();
 417             setFocusedMenuIndex(0);
 418         });
 419         ParentHelper.setTraversalEngine(getSkinnable(), engine);
 420 
 421         control.sceneProperty().addListener((ov, t, t1) -&gt; {
 422             // remove event handlers / filters from the old scene (t)
 423             if (t != null) {
 424                 if (weakSceneKeyEventHandler != null) {
 425                     t.removeEventFilter(KeyEvent.KEY_PRESSED, weakSceneKeyEventHandler);
 426                 }
 427                 if (weakSceneMouseEventHandler != null) {
 428                     t.removeEventFilter(MouseEvent.MOUSE_CLICKED, weakSceneMouseEventHandler);
 429                 }
 430                 if (weakSceneAltKeyEventHandler != null) {
 431                     t.removeEventHandler(KeyEvent.ANY, weakSceneAltKeyEventHandler);
 432                 }
 433             }
 434 
 435             /**
 436              * remove the f10 accelerator from the old scene
 437              * add it to the new scene
 438              */
 439             if (t != null) {
 440                 t.getAccelerators().remove(acceleratorKeyCombo);
 441             }
 442             if (t1 != null ) {
 443                 t1.getAccelerators().put(acceleratorKeyCombo, firstMenuRunnable);
 444             }
 445         });
 446     }
 447 
 448     private void showMenu(Menu menu) {
 449         showMenu(menu, false);
 450     }
 451 
 452     private void showMenu(Menu menu, boolean selectFirstItem) {
 453         // hide the currently visible menu, and move to the next one
 454         if (openMenu == menu) return;
 455         if (openMenu != null) {
 456             openMenu.hide();
 457         }
 458 
 459         openMenu = menu;
 460         if (!menu.isShowing() &amp;&amp; !isMenuEmpty(menu)) {
 461             if (selectFirstItem) {
 462                 // put selection / focus on first item in menu
 463                 MenuButton menuButton = getNodeForMenu(focusedMenuIndex);
 464                 Skin&lt;?&gt; skin = menuButton.getSkin();
 465                 if (skin instanceof MenuButtonSkinBase) {
 466                     ((MenuButtonSkinBase)skin).requestFocusOnFirstMenuItem();
 467                 }
 468             }
 469 
 470             openMenu.show();
 471         }
 472     }
 473 
 474     private void setFocusedMenuIndex(int index) {
<a name="1" id="anc1"></a><span class="line-modified"> 475         focusedMenuIndex = (index &gt;= -1 &amp;&amp; index &lt; getSkinnable().getMenus().size())? index : -1;</span>
<span class="line-modified"> 476         focusedMenu = (focusedMenuIndex != -1)? getSkinnable().getMenus().get(index) : null;</span>
 477 
<a name="2" id="anc2"></a><span class="line-modified"> 478         if (focusedMenuIndex != -1) {</span>




 479             openMenuButton = (MenuBarButton)container.getChildren().get(focusedMenuIndex);
 480             openMenuButton.setHover();
 481         }
 482     }
 483 
 484 
 485 
 486     /***************************************************************************
 487      *                                                                         *
 488      * Static methods                                                          *
 489      *                                                                         *
 490      **************************************************************************/
 491 
 492     // RT-22480: This is intended as private API for SceneBuilder,
 493     // pending fix for RT-19857: Keeping menu in the Mac menu bar when
 494     // there is no more stage
 495     /**
 496      * Set the default system menu bar. This allows an application to keep menu
 497      * in the system menu bar after the last Window is closed.
 498      * @param menuBar the menu bar
 499      */
 500     public static void setDefaultSystemMenuBar(final MenuBar menuBar) {
 501         if (Toolkit.getToolkit().getSystemMenu().isSupported()) {
 502             wrappedDefaultMenus.clear();
 503             for (Menu menu : menuBar.getMenus()) {
 504                 wrappedDefaultMenus.add(GlobalMenuAdapter.adapt(menu));
 505             }
 506             menuBar.getMenus().addListener((ListChangeListener&lt;Menu&gt;) c -&gt; {
 507                 wrappedDefaultMenus.clear();
 508                 for (Menu menu : menuBar.getMenus()) {
 509                     wrappedDefaultMenus.add(GlobalMenuAdapter.adapt(menu));
 510                 }
 511             });
 512         }
 513     }
 514 
 515     private static MenuBarSkin getMenuBarSkin(Stage stage) {
 516         if (systemMenuMap == null) return null;
 517         Reference&lt;MenuBarSkin&gt; skinRef = systemMenuMap.get(stage);
 518         return skinRef == null ? null : skinRef.get();
 519     }
 520 
 521     private static void setSystemMenu(Stage stage) {
 522         if (stage != null &amp;&amp; stage.isFocused()) {
 523             while (stage != null &amp;&amp; stage.getOwner() instanceof Stage) {
 524                 MenuBarSkin skin = getMenuBarSkin(stage);
 525                 if (skin != null &amp;&amp; skin.wrappedMenus != null) {
 526                     break;
 527                 } else {
 528                     // This is a secondary stage (dialog) that doesn&#39;t
 529                     // have own menu bar.
 530                     //
 531                     // Continue looking for a menu bar in the parent stage.
 532                     stage = (Stage)stage.getOwner();
 533                 }
 534             }
 535         } else {
 536             stage = null;
 537         }
 538 
 539         if (stage != currentMenuBarStage) {
 540             List&lt;MenuBase&gt; menuList = null;
 541             if (stage != null) {
 542                 MenuBarSkin skin = getMenuBarSkin(stage);
 543                 if (skin != null) {
 544                     menuList = skin.wrappedMenus;
 545                 }
 546             }
 547             if (menuList == null) {
 548                 menuList = wrappedDefaultMenus;
 549             }
 550             Toolkit.getToolkit().getSystemMenu().setMenus(menuList);
 551             currentMenuBarStage = stage;
 552         }
 553     }
 554 
 555     private static void initSystemMenuBar() {
 556         systemMenuMap = new WeakHashMap&lt;&gt;();
 557 
 558         final InvalidationListener focusedStageListener = ov -&gt; {
 559             setSystemMenu((Stage)((ReadOnlyProperty&lt;?&gt;)ov).getBean());
 560         };
 561 
 562         for (Window stage : stages) {
 563             stage.focusedProperty().addListener(focusedStageListener);
 564         }
 565         stages.addListener((ListChangeListener&lt;Window&gt;) c -&gt; {
 566             while (c.next()) {
 567                 for (Window stage : c.getRemoved()) {
 568                     stage.focusedProperty().removeListener(focusedStageListener);
 569                 }
 570                 for (Window stage : c.getAddedSubList()) {
 571                     stage.focusedProperty().addListener(focusedStageListener);
 572                     setSystemMenu((Stage) stage);
 573                 }
 574             }
 575         });
 576     }
 577 
 578 
 579 
 580     /***************************************************************************
 581      *                                                                         *
 582      * Properties                                                              *
 583      *                                                                         *
 584      **************************************************************************/
 585 
 586     /**
 587      * Specifies the spacing between menu buttons on the MenuBar.
 588      */
 589     // --- spacing
 590     private DoubleProperty spacing;
 591     public final void setSpacing(double value) {
 592         spacingProperty().set(snapSpaceX(value));
 593     }
 594 
 595     public final double getSpacing() {
 596         return spacing == null ? 0.0 : snapSpaceX(spacing.get());
 597     }
 598 
 599     public final DoubleProperty spacingProperty() {
 600         if (spacing == null) {
 601             spacing = new StyleableDoubleProperty() {
 602 
 603                 @Override
 604                 protected void invalidated() {
 605                     final double value = get();
 606                     container.setSpacing(value);
 607                 }
 608 
 609                 @Override
 610                 public Object getBean() {
 611                     return MenuBarSkin.this;
 612                 }
 613 
 614                 @Override
 615                 public String getName() {
 616                     return &quot;spacing&quot;;
 617                 }
 618 
 619                 @Override
 620                 public CssMetaData&lt;MenuBar,Number&gt; getCssMetaData() {
 621                     return SPACING;
 622                 }
 623             };
 624         }
 625         return spacing;
 626     }
 627 
 628     /**
 629      * Specifies the alignment of the menu buttons inside the MenuBar (by default
 630      * it is Pos.TOP_LEFT).
 631      */
 632     // --- container alignment
 633     private ObjectProperty&lt;Pos&gt; containerAlignment;
 634     public final void setContainerAlignment(Pos value) {
 635         containerAlignmentProperty().set(value);
 636     }
 637 
 638     public final Pos getContainerAlignment() {
 639         return containerAlignment == null ? Pos.TOP_LEFT : containerAlignment.get();
 640     }
 641 
 642     public final ObjectProperty&lt;Pos&gt; containerAlignmentProperty() {
 643         if (containerAlignment == null) {
 644             containerAlignment = new StyleableObjectProperty&lt;Pos&gt;(Pos.TOP_LEFT) {
 645 
 646                 @Override
 647                 public void invalidated() {
 648                     final Pos value = get();
 649                     container.setAlignment(value);
 650                 }
 651 
 652                 @Override
 653                 public Object getBean() {
 654                     return MenuBarSkin.this;
 655                 }
 656 
 657                 @Override
 658                 public String getName() {
 659                     return &quot;containerAlignment&quot;;
 660                 }
 661 
 662                 @Override
 663                 public CssMetaData&lt;MenuBar,Pos&gt; getCssMetaData() {
 664                     return ALIGNMENT;
 665                 }
 666             };
 667         }
 668         return containerAlignment;
 669     }
 670 
 671 
 672 
 673     /***************************************************************************
 674      *                                                                         *
 675      * Public API                                                              *
 676      *                                                                         *
 677      **************************************************************************/
 678 
 679     /** {@inheritDoc} */
 680     @Override public void dispose() {
 681         cleanUpSystemMenu();
 682         // call super.dispose last since it sets control to null
 683         super.dispose();
 684     }
 685 
 686     // Return empty insets when &quot;container&quot; is empty, which happens
 687     // when using the system menu bar.
 688 
 689     /** {@inheritDoc} */
 690     @Override protected double snappedTopInset() {
 691         return container.getChildren().isEmpty() ? 0 : super.snappedTopInset();
 692     }
 693     /** {@inheritDoc} */
 694     @Override protected double snappedBottomInset() {
 695         return container.getChildren().isEmpty() ? 0 : super.snappedBottomInset();
 696     }
 697     /** {@inheritDoc} */
 698     @Override protected double snappedLeftInset() {
 699         return container.getChildren().isEmpty() ? 0 : super.snappedLeftInset();
 700     }
 701     /** {@inheritDoc} */
 702     @Override protected double snappedRightInset() {
 703         return container.getChildren().isEmpty() ? 0 : super.snappedRightInset();
 704     }
 705 
 706     /**
 707      * Layout the menu bar. This is a simple horizontal layout like an hbox.
 708      * Any menu items which don&#39;t fit into it will simply be made invisible.
 709      */
 710     /** {@inheritDoc} */
 711     @Override protected void layoutChildren(final double x, final double y,
 712                                             final double w, final double h) {
 713         // layout the menus one after another
 714         container.resizeRelocate(x, y, w, h);
 715     }
 716 
 717     /** {@inheritDoc} */
 718     @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
 719         return container.minWidth(height) + snappedLeftInset() + snappedRightInset();
 720     }
 721 
 722     /** {@inheritDoc} */
 723     @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
 724         return container.prefWidth(height) + snappedLeftInset() + snappedRightInset();
 725     }
 726 
 727     /** {@inheritDoc} */
 728     @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
 729         return container.minHeight(width) + snappedTopInset() + snappedBottomInset();
 730     }
 731 
 732     /** {@inheritDoc} */
 733     @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
 734         return container.prefHeight(width) + snappedTopInset() + snappedBottomInset();
 735     }
 736 
 737     // grow horizontally, but not vertically
 738     /** {@inheritDoc} */
 739     @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
 740         return getSkinnable().prefHeight(-1);
 741     }
 742 
 743 
 744 
 745     /***************************************************************************
 746      *                                                                         *
 747      * Private implementation                                                  *
 748      *                                                                         *
 749      **************************************************************************/
 750 
 751     // For testing purpose only.
 752     MenuButton getNodeForMenu(int i) {
 753         if (i &lt; container.getChildren().size()) {
 754             return (MenuBarButton)container.getChildren().get(i);
 755         }
 756         return null;
 757     }
 758 
 759     int getFocusedMenuIndex() {
 760         return focusedMenuIndex;
 761     }
 762 
<a name="3" id="anc3"></a><span class="line-added"> 763     void setFocusedIndex(int index) {</span>
<span class="line-added"> 764         this.setFocusedMenuIndex(0);</span>
<span class="line-added"> 765     }</span>
<span class="line-added"> 766 </span>
 767     private boolean menusContainCustomMenuItem() {
 768         for (Menu menu : getSkinnable().getMenus()) {
 769             if (menuContainsCustomMenuItem(menu)) {
 770                 System.err.println(&quot;Warning: MenuBar ignored property useSystemMenuBar because menus contain CustomMenuItem&quot;);
 771                 return true;
 772             }
 773         }
 774         return false;
 775     }
 776 
 777     private boolean menuContainsCustomMenuItem(Menu menu) {
 778         for (MenuItem mi : menu.getItems()) {
 779             if (mi instanceof CustomMenuItem &amp;&amp; !(mi instanceof SeparatorMenuItem)) {
 780                 return true;
 781             } else if (mi instanceof Menu) {
 782                 if (menuContainsCustomMenuItem((Menu)mi)) {
 783                     return true;
 784                 }
 785             }
 786         }
 787         return false;
 788     }
 789 
 790     private int getMenuBarButtonIndex(MenuBarButton m) {
 791         for (int i= 0; i &lt; container.getChildren().size(); i++) {
 792             MenuBarButton menuButton = (MenuBarButton)container.getChildren().get(i);
 793             if (m == menuButton) {
 794                 return i;
 795             }
 796         }
 797         return -1;
 798     }
 799 
 800     private void updateActionListeners(MenuItem item, boolean add) {
 801         if (item instanceof Menu) {
 802             Menu menu = (Menu) item;
 803 
 804             if (add) {
 805                 menu.getItems().addListener(menuItemListener);
 806             } else {
 807                 menu.getItems().removeListener(menuItemListener);
 808             }
 809 
 810             for (MenuItem mi : menu.getItems()) {
 811                 updateActionListeners(mi, add);
 812             }
 813         } else {
 814             if (add) {
 815                 item.addEventHandler(ActionEvent.ACTION, menuActionEventHandler);
 816             } else {
 817                 item.removeEventHandler(ActionEvent.ACTION, menuActionEventHandler);
 818             }
 819         }
 820     }
 821 
 822     private void rebuildUI() {
 823         getSkinnable().focusedProperty().removeListener(menuBarFocusedPropertyListener);
 824         for (Menu m : getSkinnable().getMenus()) {
 825             // remove action listeners
 826             updateActionListeners(m, false);
 827 
 828             m.visibleProperty().removeListener(menuVisibilityChangeListener);
 829         }
 830         for (Node n : container.getChildren()) {
 831             // Stop observing menu&#39;s showing &amp; disable property for changes.
 832             // Need to unbind before clearing container&#39;s children.
 833             MenuBarButton menuButton = (MenuBarButton)n;
 834             menuButton.hide();
 835             menuButton.menu.showingProperty().removeListener(menuButton.menuListener);
 836             menuButton.disableProperty().unbind();
 837             menuButton.textProperty().unbind();
 838             menuButton.graphicProperty().unbind();
 839             menuButton.styleProperty().unbind();
 840 
 841             menuButton.dispose();
 842 
 843             // RT-29729 : old instance of context menu window/popup for this MenuButton needs
 844             // to be cleaned up. Setting the skin to null - results in a call to dispose()
 845             // on the skin which in this case MenuButtonSkinBase - does the subsequent
 846             // clean up to ContextMenu/popup window.
 847             menuButton.setSkin(null);
 848             menuButton = null;
 849         }
 850         container.getChildren().clear();
 851 
 852         if (Toolkit.getToolkit().getSystemMenu().isSupported()) {
 853             final Scene scene = getSkinnable().getScene();
 854             if (scene != null) {
 855                 // RT-36554 - make sure system menu is updated when this MenuBar&#39;s scene changes.
 856                 if (sceneChangeListener == null) {
 857                     sceneChangeListener = (observable, oldValue, newValue) -&gt; {
 858 
 859                         if (oldValue != null) {
 860                             if (oldValue.getWindow() instanceof Stage) {
 861                                 final Stage stage = (Stage) oldValue.getWindow();
 862                                 final MenuBarSkin curMBSkin = getMenuBarSkin(stage);
 863                                 if (curMBSkin == MenuBarSkin.this) {
 864                                     curMBSkin.wrappedMenus = null;
 865                                     systemMenuMap.remove(stage);
 866                                     if (currentMenuBarStage == stage) {
 867                                         currentMenuBarStage = null;
 868                                         setSystemMenu(stage);
 869                                     }
 870                                 } else {
 871                                     if (getSkinnable().isUseSystemMenuBar() &amp;&amp;
 872                                             curMBSkin != null &amp;&amp; curMBSkin.getSkinnable() != null &amp;&amp;
 873                                             curMBSkin.getSkinnable().isUseSystemMenuBar()) {
 874                                         curMBSkin.getSkinnable().setUseSystemMenuBar(false);
 875                                     }
 876                                 }
 877                             }
 878                         }
 879 
 880                         if (newValue != null) {
 881                             if (getSkinnable().isUseSystemMenuBar() &amp;&amp; !menusContainCustomMenuItem()) {
 882                                 if (newValue.getWindow() instanceof Stage) {
 883                                     final Stage stage = (Stage) newValue.getWindow();
 884                                     if (systemMenuMap == null) {
 885                                         initSystemMenuBar();
 886                                     }
 887                                     wrappedMenus = new ArrayList&lt;&gt;();
 888                                     systemMenuMap.put(stage, new WeakReference&lt;&gt;(this));
 889                                     for (Menu menu : getSkinnable().getMenus()) {
 890                                         wrappedMenus.add(GlobalMenuAdapter.adapt(menu));
 891                                     }
 892                                     currentMenuBarStage = null;
 893                                     setSystemMenu(stage);
 894 
 895                                     // TODO: Why two request layout calls here?
 896                                     getSkinnable().requestLayout();
 897                                     javafx.application.Platform.runLater(() -&gt; getSkinnable().requestLayout());
 898                                 }
 899                             }
 900                         }
 901                     };
 902                     getSkinnable().sceneProperty().addListener(sceneChangeListener);
 903                 }
 904 
 905                 // Fake a change event to trigger an update to the system menu.
 906                 sceneChangeListener.changed(getSkinnable().sceneProperty(), scene, scene);
 907 
 908                 // If the system menu references this MenuBarSkin, then we&#39;re done with rebuilding the UI.
 909                 // If the system menu does not reference this MenuBarSkin, then the MenuBar is a child of the scene
 910                 // and we continue with the update.
 911                 // If there is no system menu but this skinnable uses the system menu bar, then the
 912                 // stage just isn&#39;t focused yet (see setSystemMenu) and we&#39;re done rebuilding the UI.
 913                 if (currentMenuBarStage != null ? getMenuBarSkin(currentMenuBarStage) == MenuBarSkin.this : getSkinnable().isUseSystemMenuBar()) {
 914                     return;
 915                 }
 916 
 917             } else {
 918                 // if scene is null, make sure this MenuBarSkin isn&#39;t left behind as the system menu
 919                 if (currentMenuBarStage != null) {
 920                     final MenuBarSkin curMBSkin = getMenuBarSkin(currentMenuBarStage);
 921                     if (curMBSkin == MenuBarSkin.this) {
 922                         setSystemMenu(null);
 923                     }
 924                 }
 925             }
 926         }
 927 
 928         getSkinnable().focusedProperty().addListener(menuBarFocusedPropertyListener);
 929         for (final Menu menu : getSkinnable().getMenus()) {
 930 
 931             menu.visibleProperty().addListener(menuVisibilityChangeListener);
 932 
 933             if (!menu.isVisible()) continue;
 934             final MenuBarButton menuButton = new MenuBarButton(this, menu);
 935             menuButton.setFocusTraversable(false);
 936             menuButton.getStyleClass().add(&quot;menu&quot;);
 937             menuButton.setStyle(menu.getStyle()); // copy style
 938 
 939             menuButton.getItems().setAll(menu.getItems());
 940             container.getChildren().add(menuButton);
 941 
 942             menuButton.menuListener = (observable, oldValue, newValue) -&gt; {
 943                 if (menu.isShowing()) {
 944                     menuButton.show();
 945                     menuModeStart(container.getChildren().indexOf(menuButton));
 946                 } else {
 947                     menuButton.hide();
 948                 }
 949             };
 950             menuButton.menu = menu;
 951             menu.showingProperty().addListener(menuButton.menuListener);
 952             menuButton.disableProperty().bindBidirectional(menu.disableProperty());
 953             menuButton.textProperty().bind(menu.textProperty());
 954             menuButton.graphicProperty().bind(menu.graphicProperty());
 955             menuButton.styleProperty().bind(menu.styleProperty());
 956             menuButton.getProperties().addListener((MapChangeListener&lt;Object, Object&gt;) c -&gt; {
 957                  if (c.wasAdded() &amp;&amp; MenuButtonSkin.AUTOHIDE.equals(c.getKey())) {
 958                     menuButton.getProperties().remove(MenuButtonSkin.AUTOHIDE);
 959                     menu.hide();
 960                 }
 961             });
 962             menuButton.showingProperty().addListener((observable, oldValue, isShowing) -&gt; {
 963                 if (isShowing) {
 964                     if(openMenuButton == null &amp;&amp; focusedMenuIndex != -1)
 965                         openMenuButton = (MenuBarButton)container.getChildren().get(focusedMenuIndex);
 966 
 967                     if (openMenuButton != null &amp;&amp; openMenuButton != menuButton) {
 968                         openMenuButton.clearHover();
 969                     }
 970                     openMenuButton = menuButton;
 971                     showMenu(menu);
 972                 } else {
 973                     // Fix for JDK-8167138 - we need to clear out the openMenu / openMenuButton
 974                     // when the menu is hidden (e.g. via autoHide), so that we can open it again
 975                     // the next time (if it is the first menu requested to show)
 976                     openMenu = null;
 977                     openMenuButton = null;
 978                 }
 979             });
 980 
 981             menuButton.setOnMousePressed(event -&gt; {
 982                 pendingDismiss = menuButton.isShowing();
 983 
 984                 // check if the owner window has focus
 985                 if (menuButton.getScene().getWindow().isFocused()) {
 986                     showMenu(menu);
 987                     // update FocusedIndex
 988                     menuModeStart(getMenuBarButtonIndex(menuButton));
 989                 }
 990             });
 991 
 992             menuButton.setOnMouseReleased(event -&gt; {
 993                 // check if the owner window has focus
 994                 if (menuButton.getScene().getWindow().isFocused()) {
 995                     if (pendingDismiss) {
 996                         resetOpenMenu();
 997                     }
 998                 }
 999                 pendingDismiss = false;
1000             });
1001 
1002             menuButton.setOnMouseEntered(event -&gt; {
1003                 // check if the owner window has focus
1004                 if (menuButton.getScene() != null &amp;&amp; menuButton.getScene().getWindow() != null &amp;&amp;
1005                         menuButton.getScene().getWindow().isFocused()) {
1006                     if (openMenuButton != null &amp;&amp; openMenuButton != menuButton) {
1007                             openMenuButton.clearHover();
1008                             openMenuButton = null;
1009                             openMenuButton = menuButton;
1010                     }
1011                     updateFocusedIndex();
1012                     if (openMenu != null &amp;&amp; openMenu != menu) {
1013                         showMenu(menu);
1014                     }
1015                 }
1016             });
1017             updateActionListeners(menu, true);
1018         }
1019         getSkinnable().requestLayout();
1020     }
1021 
1022     private void cleanUpSystemMenu() {
1023         if (sceneChangeListener != null &amp;&amp; getSkinnable() != null) {
1024             getSkinnable().sceneProperty().removeListener(sceneChangeListener);
1025             // rebuildUI creates sceneChangeListener and adds sceneChangeListener to sceneProperty,
1026             // so sceneChangeListener needs to be reset to null in the off chance that this
1027             // skin instance is reused.
1028             sceneChangeListener = null;
1029         }
1030 
1031         if (currentMenuBarStage != null &amp;&amp; getMenuBarSkin(currentMenuBarStage) == MenuBarSkin.this) {
1032             setSystemMenu(null);
1033         }
1034 
1035         if (systemMenuMap != null) {
1036             Iterator&lt;Map.Entry&lt;Stage,Reference&lt;MenuBarSkin&gt;&gt;&gt; iterator = systemMenuMap.entrySet().iterator();
1037             while (iterator.hasNext()) {
1038                 Map.Entry&lt;Stage,Reference&lt;MenuBarSkin&gt;&gt; entry = iterator.next();
1039                 Reference&lt;MenuBarSkin&gt; ref = entry.getValue();
1040                 MenuBarSkin skin = ref != null ? ref.get() : null;
1041                 if (skin == null || skin == MenuBarSkin.this) {
1042                     iterator.remove();
1043                 }
1044             }
1045         }
1046     }
1047 
1048     private boolean isMenuEmpty(Menu menu) {
1049         boolean retVal = true;
1050         if (menu != null) {
1051             for (MenuItem m : menu.getItems()) {
1052                 if (m != null &amp;&amp; m.isVisible()) retVal = false;
1053             }
1054         }
1055         return retVal;
1056     }
1057 
1058     private void resetOpenMenu() {
1059         if (openMenu != null) {
1060             openMenu.hide();
1061             openMenu = null;
1062         }
1063     }
1064 
1065     private void unSelectMenus() {
1066         clearMenuButtonHover();
1067         if (focusedMenuIndex == -1) return;
1068         if (openMenu != null) {
1069             openMenu.hide();
1070             openMenu = null;
1071         }
1072         if (openMenuButton != null) {
1073             openMenuButton.clearHover();
1074             openMenuButton = null;
1075         }
1076         menuModeEnd();
1077     }
1078 
1079     private void menuModeStart(int newIndex) {
1080         if (focusedMenuIndex == -1) {
1081             SceneHelper.getSceneAccessor().setTransientFocusContainer(getSkinnable().getScene(), getSkinnable());
1082         }
1083         setFocusedMenuIndex(newIndex);
1084     }
1085 
1086     private void menuModeEnd() {
1087         if (focusedMenuIndex != -1) {
1088             SceneHelper.getSceneAccessor().setTransientFocusContainer(getSkinnable().getScene(), null);
1089 
1090             /* Return the a11y focus to a control in the scene. */
1091             getSkinnable().notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_NODE);
1092         }
1093         setFocusedMenuIndex(-1);
1094     }
1095 
1096     private void moveToMenu(Direction dir, boolean doShow) {
1097         boolean showNextMenu = doShow &amp;&amp; focusedMenu.isShowing();
1098         findSibling(dir, focusedMenuIndex).ifPresent(p -&gt; {
1099             setFocusedMenuIndex(p.getValue());
1100             if (showNextMenu) {
1101                 // we explicitly do *not* allow selection - we are moving
1102                 // to a sibling menu, and therefore selection should be reset
1103                 showMenu(p.getKey(), false);
1104             }
1105         });
1106     }
1107 
1108     private Optional&lt;Pair&lt;Menu,Integer&gt;&gt; findSibling(Direction dir, int startIndex) {
1109         if (startIndex == -1) {
1110             return Optional.empty();
1111         }
1112 
1113         final int totalMenus = getSkinnable().getMenus().size();
1114         int i = 0;
1115         int nextIndex = 0;
1116 
1117         // Traverse all menus in menubar to find nextIndex
1118         while (i &lt; totalMenus) {
1119             i++;
1120 
1121             nextIndex = (startIndex + (dir.isForward() ? 1 : -1)) % totalMenus;
1122 
1123             if (nextIndex == -1) {
1124                 // loop backwards to end
1125                 nextIndex = totalMenus - 1;
1126             }
1127 
1128             // if menu at nextIndex is disabled, skip it
1129             if (getSkinnable().getMenus().get(nextIndex).isDisable()) {
1130                 // Calculate new nextIndex by continuing loop
1131                 startIndex = nextIndex;
1132             } else {
1133                 // nextIndex is to be highlighted
1134                 break;
1135             }
1136         }
1137 
1138         clearMenuButtonHover();
1139         return Optional.of(new Pair&lt;&gt;(getSkinnable().getMenus().get(nextIndex), nextIndex));
1140     }
1141 
1142     private void updateFocusedIndex() {
1143         int index = 0;
1144         for(Node n : container.getChildren()) {
1145             if (n.isHover()) {
1146                 setFocusedMenuIndex(index);
1147                 return;
1148             }
1149             index++;
1150         }
1151         menuModeEnd();
1152     }
1153 
1154     private void clearMenuButtonHover() {
1155          for(Node n : container.getChildren()) {
1156             if (n.isHover()) {
1157                 ((MenuBarButton)n).clearHover();
1158                 ((MenuBarButton)n).disarm();
1159                 return;
1160             }
1161         }
1162     }
1163 
1164 
1165 
1166     /***************************************************************************
1167      *                                                                         *
1168      * CSS                                                                     *
1169      *                                                                         *
1170      **************************************************************************/
1171 
1172     private static final CssMetaData&lt;MenuBar,Number&gt; SPACING =
1173             new CssMetaData&lt;MenuBar,Number&gt;(&quot;-fx-spacing&quot;,
1174                     SizeConverter.getInstance(), 0.0) {
1175 
1176                 @Override
1177                 public boolean isSettable(MenuBar n) {
1178                     final MenuBarSkin skin = (MenuBarSkin) n.getSkin();
1179                     return skin.spacing == null || !skin.spacing.isBound();
1180                 }
1181 
1182                 @Override
1183                 public StyleableProperty&lt;Number&gt; getStyleableProperty(MenuBar n) {
1184                     final MenuBarSkin skin = (MenuBarSkin) n.getSkin();
1185                     return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)skin.spacingProperty();
1186                 }
1187             };
1188 
1189     private static final CssMetaData&lt;MenuBar,Pos&gt; ALIGNMENT =
1190             new CssMetaData&lt;MenuBar,Pos&gt;(&quot;-fx-alignment&quot;,
1191                     new EnumConverter&lt;Pos&gt;(Pos.class), Pos.TOP_LEFT ) {
1192 
1193                 @Override
1194                 public boolean isSettable(MenuBar n) {
1195                     final MenuBarSkin skin = (MenuBarSkin) n.getSkin();
1196                     return skin.containerAlignment == null || !skin.containerAlignment.isBound();
1197                 }
1198 
1199                 @Override
1200                 public StyleableProperty&lt;Pos&gt; getStyleableProperty(MenuBar n) {
1201                     final MenuBarSkin skin = (MenuBarSkin) n.getSkin();
1202                     return (StyleableProperty&lt;Pos&gt;)(WritableValue&lt;Pos&gt;)skin.containerAlignmentProperty();
1203                 }
1204             };
1205 
1206 
1207     private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
1208     static {
1209 
1210         final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1211                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
1212 
1213         // StackPane also has -fx-alignment. Replace it with
1214         // MenuBarSkin&#39;s.
1215         // TODO: Really should be able to reference StackPane.StyleableProperties.ALIGNMENT
1216         final String alignmentProperty = ALIGNMENT.getProperty();
1217         for (int n=0, nMax=styleables.size(); n&lt;nMax; n++) {
1218             final CssMetaData&lt;?,?&gt; prop = styleables.get(n);
1219             if (alignmentProperty.equals(prop.getProperty())) styleables.remove(prop);
1220         }
1221 
1222         styleables.add(SPACING);
1223         styleables.add(ALIGNMENT);
1224         STYLEABLES = Collections.unmodifiableList(styleables);
1225 
1226     }
1227 
1228     /**
1229      * Returns the CssMetaData associated with this class, which may include the
1230      * CssMetaData of its superclasses.
1231      * @return the CssMetaData associated with this class, which may include the
1232      * CssMetaData of its superclasses
1233      */
1234     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1235         return STYLEABLES;
1236     }
1237 
1238     /**
1239      * {@inheritDoc}
1240      */
1241     @Override
1242     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
1243         return getClassCssMetaData();
1244     }
1245 
1246     /***************************************************************************
1247      *                                                                         *
1248      * Accessibility handling                                                  *
1249      *                                                                         *
1250      **************************************************************************/
1251 
1252     /** {@inheritDoc} */
1253     @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1254         switch (attribute) {
1255             case FOCUS_NODE: return openMenuButton;
1256             default: return super.queryAccessibleAttribute(attribute, parameters);
1257         }
1258     }
1259 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
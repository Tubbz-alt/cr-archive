<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/java/com/sun/media/jfxmediaimpl/NativeMediaPlayer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.media.jfxmediaimpl;
  27 
  28 import java.lang.annotation.Native;
  29 import com.sun.media.jfxmedia.Media;
  30 import com.sun.media.jfxmedia.MediaError;
  31 import com.sun.media.jfxmedia.MediaException;
  32 import com.sun.media.jfxmedia.MediaPlayer;
  33 import com.sun.media.jfxmedia.control.VideoRenderControl;
  34 import com.sun.media.jfxmedia.effects.AudioEqualizer;
  35 import com.sun.media.jfxmedia.effects.AudioSpectrum;
  36 import com.sun.media.jfxmedia.events.AudioSpectrumEvent;
  37 import com.sun.media.jfxmedia.events.AudioSpectrumListener;
  38 import com.sun.media.jfxmedia.events.BufferListener;
  39 import com.sun.media.jfxmedia.events.BufferProgressEvent;
  40 import com.sun.media.jfxmedia.events.MarkerEvent;
  41 import com.sun.media.jfxmedia.events.MarkerListener;
  42 import com.sun.media.jfxmedia.events.MediaErrorListener;
  43 import com.sun.media.jfxmedia.events.NewFrameEvent;
  44 import com.sun.media.jfxmedia.events.PlayerEvent;
  45 import com.sun.media.jfxmedia.events.PlayerStateEvent;
  46 import com.sun.media.jfxmedia.events.PlayerStateEvent.PlayerState;
  47 import com.sun.media.jfxmedia.events.PlayerStateListener;
  48 import com.sun.media.jfxmedia.events.PlayerTimeListener;
  49 import com.sun.media.jfxmedia.events.VideoFrameRateListener;
  50 import com.sun.media.jfxmedia.events.VideoRendererListener;
  51 import com.sun.media.jfxmedia.events.VideoTrackSizeListener;
  52 import com.sun.media.jfxmedia.logging.Logger;
  53 import com.sun.media.jfxmedia.track.AudioTrack;
  54 import com.sun.media.jfxmedia.track.SubtitleTrack;
  55 import com.sun.media.jfxmedia.track.Track;
  56 import com.sun.media.jfxmedia.track.Track.Encoding;
  57 import com.sun.media.jfxmedia.track.VideoResolution;
  58 import com.sun.media.jfxmedia.track.VideoTrack;
  59 import java.lang.ref.WeakReference;
  60 import java.util.*;
  61 import java.util.concurrent.BlockingQueue;
  62 import java.util.concurrent.LinkedBlockingQueue;
  63 import java.util.concurrent.atomic.AtomicBoolean;
  64 import java.util.concurrent.locks.Lock;
  65 import java.util.concurrent.locks.ReentrantLock;
  66 
  67 /**
  68  * Base implementation of a
  69  * &lt;code&gt;MediaPlayer&lt;/code&gt;.
  70  */
  71 public abstract class NativeMediaPlayer implements MediaPlayer, MarkerStateListener {
  72     //***** Event IDs for PlayerStateEvent.  IDs sent from native JNI layer.
  73 
  74     @Native public final static int eventPlayerUnknown = 100;
  75     @Native public final static int eventPlayerReady = 101;
  76     @Native public final static int eventPlayerPlaying = 102;
  77     @Native public final static int eventPlayerPaused = 103;
  78     @Native public final static int eventPlayerStopped = 104;
  79     @Native public final static int eventPlayerStalled = 105;
  80     @Native public final static int eventPlayerFinished = 106;
  81     @Native public final static int eventPlayerError = 107;
  82     // Nominal video frames per second.
  83     @Native private static final int NOMINAL_VIDEO_FPS = 30;
  84     // Nanoseconds per second.
  85     @Native public static final long ONE_SECOND = 1000000000L;
  86 
  87     /**
  88      * The
  89      * &lt;code&gt;Media&lt;/code&gt; corresponding to the media source.
  90      */
  91     private NativeMedia media;
  92     private VideoRenderControl videoRenderControl;
  93     private final List&lt;WeakReference&lt;MediaErrorListener&gt;&gt; errorListeners = new ArrayList&lt;&gt;();
  94     private final List&lt;WeakReference&lt;PlayerStateListener&gt;&gt; playerStateListeners = new ArrayList&lt;&gt;();
  95     private final List&lt;WeakReference&lt;PlayerTimeListener&gt;&gt; playerTimeListeners = new ArrayList&lt;&gt;();
  96     private final List&lt;WeakReference&lt;VideoTrackSizeListener&gt;&gt; videoTrackSizeListeners = new ArrayList&lt;&gt;();
  97     private final List&lt;WeakReference&lt;VideoRendererListener&gt;&gt; videoUpdateListeners = new ArrayList&lt;&gt;();
  98     private final List&lt;WeakReference&lt;VideoFrameRateListener&gt;&gt; videoFrameRateListeners = new ArrayList&lt;&gt;();
  99     private final List&lt;WeakReference&lt;MarkerListener&gt;&gt; markerListeners = new ArrayList&lt;&gt;();
 100     private final List&lt;WeakReference&lt;BufferListener&gt;&gt; bufferListeners = new ArrayList&lt;&gt;();
 101     private final List&lt;WeakReference&lt;AudioSpectrumListener&gt;&gt; audioSpectrumListeners = new ArrayList&lt;&gt;();
 102     private final List&lt;PlayerStateEvent&gt; cachedStateEvents = new ArrayList&lt;&gt;();
 103     private final List&lt;PlayerTimeEvent&gt; cachedTimeEvents = new ArrayList&lt;&gt;();
 104     private final List&lt;BufferProgressEvent&gt; cachedBufferEvents = new ArrayList&lt;&gt;();
 105     private final List&lt;MediaErrorEvent&gt; cachedErrorEvents = new ArrayList&lt;&gt;();
 106     private boolean isFirstFrame = true;
 107     private NewFrameEvent firstFrameEvent = null;
 108     private double firstFrameTime;
 109     private final Object firstFrameLock = new Object();
 110     private EventQueueThread eventLoop = new EventQueueThread();
 111     private int frameWidth = -1;
 112     private int frameHeight = -1;
 113     private final AtomicBoolean isMediaPulseEnabled = new AtomicBoolean(false);
 114     private final Lock mediaPulseLock = new ReentrantLock();
 115     private Timer mediaPulseTimer;
 116     private final Lock markerLock = new ReentrantLock();
 117     private boolean checkSeek = false;
 118     private double timeBeforeSeek = 0.0;
 119     private double timeAfterSeek = 0.0;
 120     private double previousTime = 0.0;
 121     private double firedMarkerTime = -1.0;
 122     private double startTime = 0.0;
 123     private double stopTime = Double.POSITIVE_INFINITY;
 124     private boolean isStartTimeUpdated = false;
 125     private boolean isStopTimeSet = false;
 126 
 127     // --- Begin decoded frame rate fields
 128     private double encodedFrameRate = 0.0;
 129     private boolean recomputeFrameRate = true;
 130     private double previousFrameTime;
 131     private long numFramesSincePlaying;
 132     private double meanFrameDuration;
 133     private double decodedFrameRate;
 134     // --- End decoded frame rate fields
 135     private PlayerState playerState = PlayerState.UNKNOWN;
 136     private final Lock disposeLock = new ReentrantLock();
 137     private boolean isDisposed = false;
 138     private Runnable onDispose;
 139 
 140     //**************************************************************************
 141     //***** Constructors
 142     //**************************************************************************
 143     /**
 144      * Construct a NativeMediaPlayer for the referenced clip.
 145      *
 146      * @param clip Media object
 147      * @throws IllegalArgumentException if
 148      * &lt;code&gt;clip&lt;/code&gt; is
 149      * &lt;code&gt;null&lt;/code&gt;.
 150      */
 151     protected NativeMediaPlayer(NativeMedia clip) {
 152         if (clip == null) {
 153             throw new IllegalArgumentException(&quot;clip == null!&quot;);
 154         }
 155         media = clip;
 156         videoRenderControl = new VideoRenderer();
 157     }
 158 
 159     /**
 160      * Initialization method which must be called after construction to
 161      * initialize the internal state of the player. This method should be
 162      * invoked directly after the player is constructed.
 163      */
 164     protected void init() {
 165         media.addMarkerStateListener(this);
 166         eventLoop.start();
 167     }
 168 
 169     /**
 170      * Set a callback to invoke when the player is disposed.
 171      *
 172      * @param onDispose object on which to invoke {@link Runnable#run()} in
 173      * {@link #dispose()}.
 174      */
 175     void setOnDispose(Runnable onDispose) {
 176         disposeLock.lock();
 177         try {
 178             if (!isDisposed) {
 179                 this.onDispose = onDispose;
 180             }
 181         } finally {
 182             disposeLock.unlock();
 183         }
 184     }
 185 
 186     /**
 187      * Event to be posted to any registered {@link MediaErrorListener}s.
 188      */
 189     private static class WarningEvent extends PlayerEvent {
 190 
 191         private final Object source;
 192         private final String message;
 193 
 194         WarningEvent(Object source, String message) {
 195             this.source = source;
 196             this.message = message;
 197         }
 198 
 199         public Object getSource() {
 200             return source;
 201         }
 202 
 203         public String getMessage() {
 204             return message;
 205         }
 206     }
 207 
 208     /**
 209      * Event to be posted to any registered (@link MediaErrorListener)s
 210      */
 211     public static class MediaErrorEvent extends PlayerEvent {
 212 
 213         private final Object source;
 214         private final MediaError error;
 215 
 216         public MediaErrorEvent(Object source, MediaError error) {
 217             this.source = source;
 218             this.error = error;
 219         }
 220 
 221         public Object getSource() {
 222             return source;
 223         }
 224 
 225         public String getMessage() {
 226             return error.description();
 227         }
 228 
 229         public int getErrorCode() {
 230             return error.code();
 231         }
 232     }
 233 
 234     private static class PlayerTimeEvent extends PlayerEvent {
 235 
 236         private final double time;
 237 
 238         public PlayerTimeEvent(double time) {
 239             this.time = time;
 240         }
 241 
 242         public double getTime() {
 243             return time;
 244         }
 245     }
 246 
 247     /**
 248      * Event to be posted to any registered {@link PlayerStateListener}s.
 249      */
 250     private static class TrackEvent extends PlayerEvent {
 251 
 252         private final Track track;
 253 
 254         TrackEvent(Track track) {
 255             this.track = track;
 256         }
 257 
 258         public Track getTrack() {
 259             return this.track;
 260         }
 261     }
 262 
 263     /**
 264      * Event to be posted to any registered {@link VideoTrackSizeListener}s.
 265      */
 266     private static class FrameSizeChangedEvent extends PlayerEvent {
 267 
 268         private final int width;
 269         private final int height;
 270 
 271         public FrameSizeChangedEvent(int width, int height) {
 272             if (width &gt; 0) {
 273                 this.width = width;
 274             } else {
 275                 this.width = 0;
 276             }
 277 
 278             if (height &gt; 0) {
 279                 this.height = height;
 280             } else {
 281                 this.height = 0;
 282             }
 283         }
 284 
 285         public int getWidth() {
 286             return width;
 287         }
 288 
 289         public int getHeight() {
 290             return height;
 291         }
 292     }
 293 
 294     /**
 295      * Helper class which managers {@link VideoRendererListener}s. This allows
 296      * any registered listeners, specifically AWT and Prism, to receive video
 297      * frames.
 298      */
 299     private class VideoRenderer implements VideoRenderControl {
 300 
 301         /**
 302          * adds the listener to the player&#39;s videoUpdate. The listener will be
 303          * called whenever a new frame of video is ready to be painted or
 304          * fetched by getData()
 305          *
 306          * @param listener the object which provides the VideoUpdateListener
 307          * callback interface
 308          */
 309         @Override
 310         public void addVideoRendererListener(VideoRendererListener listener) {
 311             if (listener != null) {
 312                 synchronized (firstFrameLock) {
 313                     // If the first frame is cached, post it to the listener
 314                     // directly. The lock is obtained first so the cached
 315                     // frame is not cleared between the non-null test and
 316                     // posting the event.
 317                     if (firstFrameEvent != null) {
 318                         listener.videoFrameUpdated(firstFrameEvent);
 319                     }
 320                 }
 321                 videoUpdateListeners.add(new WeakReference&lt;&gt;(listener));
 322             }
 323         }
 324 
 325         /**
 326          * removes the listener from the player.
 327          *
 328          * @param listener to be removed from the player
 329          */
 330         @Override
 331         public void removeVideoRendererListener(VideoRendererListener listener) {
 332             if (listener != null) {
 333                 for (ListIterator&lt;WeakReference&lt;VideoRendererListener&gt;&gt; it = videoUpdateListeners.listIterator(); it.hasNext();) {
 334                     VideoRendererListener l = it.next().get();
 335                     if (l == null || l == listener) {
 336                         it.remove();
 337                     }
 338                 }
 339             }
 340         }
 341 
 342         @Override
 343         public void addVideoFrameRateListener(VideoFrameRateListener listener) {
 344             if (listener != null) {
 345                 videoFrameRateListeners.add(new WeakReference&lt;&gt;(listener));
 346             }
 347         }
 348 
 349         @Override
 350         public void removeVideoFrameRateListener(VideoFrameRateListener listener) {
 351             if (listener != null) {
 352                 for (ListIterator&lt;WeakReference&lt;VideoFrameRateListener&gt;&gt; it = videoFrameRateListeners.listIterator(); it.hasNext();) {
 353                     VideoFrameRateListener l = it.next().get();
 354                     if (l == null || l == listener) {
 355                         it.remove();
 356                     }
 357                 }
 358             }
 359         }
 360 
 361         @Override
 362         public int getFrameWidth() {
 363             return frameWidth;
 364         }
 365 
 366         @Override
 367         public int getFrameHeight() {
 368             return frameHeight;
 369         }
 370     }
 371 
 372     //***** EventQueueThread Helper Class -- Provides event handling.
 373     /**
 374      * Thread for media player event processing. The thread maintains an
 375      * internal queue of
 376      * &lt;code&gt;PlayerEvent&lt;/code&gt;s to which callers post using
 377      * &lt;code&gt;postEvent()&lt;/code&gt;. The thread blocks until an event becomes
 378      * available on the queue, and then removes the event from the queue and
 379      * posts it to any registered listeners appropriate to the type of event.
 380      */
 381     private class EventQueueThread extends Thread {
 382 
 383         private final BlockingQueue&lt;PlayerEvent&gt; eventQueue =
 384                 new LinkedBlockingQueue&lt;&gt;();
 385         private volatile boolean stopped = false;
 386 
 387         EventQueueThread() {
 388             setName(&quot;JFXMedia Player EventQueueThread&quot;);
 389             setDaemon(true);
 390         }
 391 
 392         @Override
 393         public void run() {
 394             while (!stopped) {
 395                 try {
 396                     // trying to take an event from the queue.
 397                     // this method will block until an event becomes available.
 398                     PlayerEvent evt = eventQueue.take();
 399 
 400                     if (!stopped) {
 401                         if (evt instanceof NewFrameEvent) {
 402                             try {
 403                                 HandleRendererEvents((NewFrameEvent) evt);
 404                             } catch (Throwable t) {
 405                                 if (Logger.canLog(Logger.ERROR)) {
 406                                     Logger.logMsg(Logger.ERROR, &quot;Caught exception in HandleRendererEvents: &quot; + t.toString());
 407                                 }
 408                             }
 409                         } else if (evt instanceof PlayerStateEvent) {
 410                             HandleStateEvents((PlayerStateEvent) evt);
 411                         } else if (evt instanceof FrameSizeChangedEvent) {
 412                             HandleFrameSizeChangedEvents((FrameSizeChangedEvent) evt);
 413                         } else if (evt instanceof TrackEvent) {
 414                             HandleTrackEvents((TrackEvent) evt);
 415                         } else if (evt instanceof MarkerEvent) {
 416                             HandleMarkerEvents((MarkerEvent) evt);
 417                         } else if (evt instanceof WarningEvent) {
 418                             HandleWarningEvents((WarningEvent) evt);
 419                         } else if (evt instanceof PlayerTimeEvent) {
 420                             HandlePlayerTimeEvents((PlayerTimeEvent) evt);
 421                         } else if (evt instanceof BufferProgressEvent) {
 422                             HandleBufferEvents((BufferProgressEvent) evt);
 423                         } else if (evt instanceof AudioSpectrumEvent) {
 424                             HandleAudioSpectrumEvents((AudioSpectrumEvent) evt);
 425                         } else if (evt instanceof MediaErrorEvent) {
 426                             HandleErrorEvents((MediaErrorEvent) evt);
 427                         }
 428                     }
 429                 } catch (Exception e) {
 430                     // eventQueue.take() can throw InterruptedException,
 431                     // also in rare case it can throw wrong
 432                     // IllegalMonitorStateException
 433                     // so we catch Exception
 434                     // nothing to do, restart the loop unless it was properly stopped.
 435                 }
 436             }
 437 
 438             eventQueue.clear();
 439         }
 440 
 441         private void HandleRendererEvents(NewFrameEvent evt) {
 442             if (isFirstFrame) {
 443                 // Cache first frame. Frames are delivered time-sequentially
 444                 // so there should be no thread contention problem here.
 445                 isFirstFrame = false;
 446                 synchronized (firstFrameLock) {
 447                     firstFrameEvent = evt;
 448                     firstFrameTime = firstFrameEvent.getFrameData().getTimestamp();
 449                     firstFrameEvent.getFrameData().holdFrame(); // hold as long as we cache it, else we&#39;ll crash
 450                 }
 451             } else if (firstFrameEvent != null
 452                     &amp;&amp; firstFrameTime != evt.getFrameData().getTimestamp()) {
 453                 // If this branch is entered then it cannot be the first frame.
 454                 // This means that the player must be in the PLAYING state as
 455                 // the first frame will arrive upon completion of prerolling.
 456                 // When playing, listeners should receive the current frame,
 457                 // not the first frame in the stream.
 458 
 459                 // Clear the cached first frame. Obtain the lock first to avoid
 460                 // a race condition with a listener newly being added.
 461                 synchronized (firstFrameLock) {
 462                     firstFrameEvent.getFrameData().releaseFrame();
 463                     firstFrameEvent = null;
 464                 }
 465             }
 466 
 467             // notify videoUpdateListeners
 468             for (ListIterator&lt;WeakReference&lt;VideoRendererListener&gt;&gt; it = videoUpdateListeners.listIterator(); it.hasNext();) {
 469                 VideoRendererListener l = it.next().get();
 470                 if (l != null) {
 471                     l.videoFrameUpdated(evt);
 472                 } else {
 473                     it.remove();
 474                 }
 475             }
 476             // done with the frame, we can release our hold now
 477             evt.getFrameData().releaseFrame();
 478 
 479             if (!videoFrameRateListeners.isEmpty()) {
 480                 // Decoded frame rate calculations.
 481                 double currentFrameTime = System.nanoTime() / (double) ONE_SECOND;
 482 
 483                 if (recomputeFrameRate) {
 484                     // First frame in new computation sequence.
 485                     recomputeFrameRate = false;
 486                     previousFrameTime = currentFrameTime;
 487                     numFramesSincePlaying = 1;
 488                 } else {
 489                     boolean fireFrameRateEvent = false;
 490 
 491                     if (numFramesSincePlaying == 1) {
 492                         // Second frame. Estimate the initial frame rate and
 493                         // set event flag.
 494                         meanFrameDuration = currentFrameTime - previousFrameTime;
 495                         if (meanFrameDuration &gt; 0.0) {
 496                             decodedFrameRate = 1.0 / meanFrameDuration;
 497                             fireFrameRateEvent = true;
 498                         }
 499                     } else {
 500                         // Update decoded frame rate estimate using a moving
 501                         // average over encodedFrameRate frames.
 502                         double previousMeanFrameDuration = meanFrameDuration;
 503 
 504                         // Determine moving average length.
 505                         int movingAverageLength = encodedFrameRate != 0.0
 506                                 ? ((int) (encodedFrameRate + 0.5)) : NOMINAL_VIDEO_FPS;
 507 
 508                         // Claculate number of frames in current average.
 509                         long numFrames = numFramesSincePlaying &lt; movingAverageLength
 510                                 ? numFramesSincePlaying : movingAverageLength;
 511 
 512                         // Update the mean frame duration.
 513                         meanFrameDuration = ((numFrames - 1) * previousMeanFrameDuration
 514                                 + currentFrameTime - previousFrameTime) / numFrames;
 515 
 516                         // If mean frame duration changed by more than 0.5 set
 517                         // event flag.
 518                         if (meanFrameDuration &gt; 0.0
 519                                 &amp;&amp; Math.abs(decodedFrameRate - 1.0 / meanFrameDuration) &gt; 0.5) {
 520                             decodedFrameRate = 1.0 / meanFrameDuration;
 521                             fireFrameRateEvent = true;
 522                         }
 523                     }
 524 
 525                     if (fireFrameRateEvent) {
 526                         // Fire event.
 527                         for (ListIterator&lt;WeakReference&lt;VideoFrameRateListener&gt;&gt; it = videoFrameRateListeners.listIterator(); it.hasNext();) {
 528                             VideoFrameRateListener l = it.next().get();
 529                             if (l != null) {
 530                                 l.onFrameRateChanged(decodedFrameRate);
 531                             } else {
 532                                 it.remove();
 533                             }
 534                         }
 535                     }
 536 
 537                     // Update running values.
 538                     previousFrameTime = currentFrameTime;
 539                     numFramesSincePlaying++;
 540                 }
 541             }
 542         }
 543 
 544         private void HandleStateEvents(PlayerStateEvent evt) {
 545             playerState = evt.getState();
 546 
 547             recomputeFrameRate = PlayerState.PLAYING == evt.getState();
 548 
 549             switch (playerState) {
 550                 case READY:
 551                     onNativeInit();
 552                     sendFakeBufferProgressEvent();
 553                     break;
 554                 case PLAYING:
 555                     isMediaPulseEnabled.set(true);
 556                     break;
 557                 case STOPPED:
 558                 case FINISHED:
 559                     // Force a time update here to catch the time going to
 560                     // zero for STOPPED and any trailing markers for FINISHED.
 561                     doMediaPulseTask();
 562                 case PAUSED:
 563                 case STALLED:
 564                 case HALTED:
 565                     isMediaPulseEnabled.set(false);
 566                     break;
 567                 default:
 568                     break;
 569             }
 570 
 571             synchronized (cachedStateEvents) {
 572                 if (playerStateListeners.isEmpty()) {
 573                     // Cache event for processing when first listener registers.
 574                     cachedStateEvents.add(evt);
 575                     return;
 576                 }
 577             }
 578 
 579             for (ListIterator&lt;WeakReference&lt;PlayerStateListener&gt;&gt; it = playerStateListeners.listIterator(); it.hasNext();) {
 580                 PlayerStateListener listener = it.next().get();
 581                 if (listener != null) {
 582                     switch (playerState) {
 583                         case READY:
 584                             onNativeInit();
 585                             sendFakeBufferProgressEvent();
 586                             listener.onReady(evt);
 587                             break;
 588 
 589                         case PLAYING:
 590                             listener.onPlaying(evt);
 591                             break;
 592 
 593                         case PAUSED:
 594                             listener.onPause(evt);
 595                             break;
 596 
 597                         case STOPPED:
 598                             listener.onStop(evt);
 599                             break;
 600 
 601                         case STALLED:
 602                             listener.onStall(evt);
 603                             break;
 604 
 605                         case FINISHED:
 606                             listener.onFinish(evt);
 607                             break;
 608 
 609                         case HALTED:
 610                             listener.onHalt(evt);
 611                             break;
 612 
 613                         default:
 614                             break;
 615                     }
 616                 } else {
 617                     it.remove();
 618                 }
 619             }
 620         }
 621 
 622         private void HandlePlayerTimeEvents(PlayerTimeEvent evt) {
 623             synchronized (cachedTimeEvents) {
 624                 if (playerTimeListeners.isEmpty()) {
 625                     // Cache event for processing when first listener registers.
 626                     cachedTimeEvents.add(evt);
 627                     return;
 628                 }
 629             }
 630 
 631             for (ListIterator&lt;WeakReference&lt;PlayerTimeListener&gt;&gt; it = playerTimeListeners.listIterator(); it.hasNext();) {
 632                 PlayerTimeListener listener = it.next().get();
 633                 if (listener != null) {
 634                     listener.onDurationChanged(evt.getTime());
 635                 } else {
 636                     it.remove();
 637                 }
 638             }
 639         }
 640 
 641         private void HandleFrameSizeChangedEvents(FrameSizeChangedEvent evt) {
 642             frameWidth = evt.getWidth();
 643             frameHeight = evt.getHeight();
 644             Logger.logMsg(Logger.DEBUG, &quot;** Frame size changed (&quot; + frameWidth + &quot;, &quot; + frameHeight + &quot;)&quot;);
 645             for (ListIterator&lt;WeakReference&lt;VideoTrackSizeListener&gt;&gt; it = videoTrackSizeListeners.listIterator(); it.hasNext();) {
 646                 VideoTrackSizeListener listener = it.next().get();
 647                 if (listener != null) {
 648                     listener.onSizeChanged(frameWidth, frameHeight);
 649                 } else {
 650                     it.remove();
 651                 }
 652             }
 653         }
 654 
 655         private void HandleTrackEvents(TrackEvent evt) {
 656             media.addTrack(evt.getTrack());
 657 
 658             if (evt.getTrack() instanceof VideoTrack) {
 659                 encodedFrameRate = ((VideoTrack) evt.getTrack()).getEncodedFrameRate();
 660             }
 661         }
 662 
 663         private void HandleMarkerEvents(MarkerEvent evt) {
 664             for (ListIterator&lt;WeakReference&lt;MarkerListener&gt;&gt; it = markerListeners.listIterator(); it.hasNext();) {
 665                 MarkerListener listener = it.next().get();
 666                 if (listener != null) {
 667                     listener.onMarker(evt);
 668                 } else {
 669                     it.remove();
 670                 }
 671             }
 672         }
 673 
 674         private void HandleWarningEvents(WarningEvent evt) {
 675             Logger.logMsg(Logger.WARNING, evt.getSource() + evt.getMessage());
 676         }
 677 
 678         private void HandleErrorEvents(MediaErrorEvent evt) {
 679             Logger.logMsg(Logger.ERROR, evt.getMessage());
 680 
 681             synchronized (cachedErrorEvents) {
 682                 if (errorListeners.isEmpty()) {
 683                     // cache error events until at least one listener is added
 684                     cachedErrorEvents.add(evt);
 685                     return;
 686                 }
 687             }
 688 
 689             for (ListIterator&lt;WeakReference&lt;MediaErrorListener&gt;&gt; it = errorListeners.listIterator(); it.hasNext();) {
 690                 MediaErrorListener l = it.next().get();
 691                 if (l != null) {
 692                     l.onError(evt.getSource(), evt.getErrorCode(), evt.getMessage());
 693                 } else {
 694                     it.remove();
 695                 }
 696             }
 697         }
 698 
 699         private void HandleBufferEvents(BufferProgressEvent evt) {
 700             synchronized (cachedBufferEvents) {
 701                 if (bufferListeners.isEmpty()) {
 702                     // Cache event for processing when first listener registers.
 703                     cachedBufferEvents.add(evt);
 704                     return;
 705                 }
 706             }
 707 
 708             for (ListIterator&lt;WeakReference&lt;BufferListener&gt;&gt; it = bufferListeners.listIterator(); it.hasNext();) {
 709                 BufferListener listener = it.next().get();
 710                 if (listener != null) {
 711                     listener.onBufferProgress(evt);
 712                 } else {
 713                     it.remove();
 714                 }
 715             }
 716         }
 717 
 718         private void HandleAudioSpectrumEvents(AudioSpectrumEvent evt) {
 719             for (ListIterator&lt;WeakReference&lt;AudioSpectrumListener&gt;&gt; it = audioSpectrumListeners.listIterator(); it.hasNext();) {
 720                 AudioSpectrumListener listener = it.next().get();
 721                 if (listener != null) {
 722                     // OSXPlatfrom will set queryTimestamp to true, so we can request
 723                     // time here from EventQueueThread, since requesting time from
 724                     // audio processing thread might hang. See JDK-8240694.
 725                     if (evt.queryTimestamp()) {
 726                         double timestamp = playerGetPresentationTime();
 727                         evt.setTimestamp(timestamp);
 728                     }
 729 
 730                     listener.onAudioSpectrumEvent(evt);
 731                 } else {
 732                     it.remove();
 733                 }
 734             }
 735         }
 736 
 737         /**
 738          * Puts an event to the EventQuery.
 739          */
 740         public void postEvent(PlayerEvent event) {
 741             if (eventQueue != null) {
 742                 eventQueue.offer(event);
 743             }
 744         }
 745 
 746         /**
 747          * Signals the thread to terminate.
 748          */
 749         public void terminateLoop() {
 750             stopped = true;
 751             // put an event to unblock eventQueue.take()
 752             try {
 753                 eventQueue.put(new PlayerEvent());
 754             } catch(InterruptedException ex) {}
 755         }
 756 
 757         private void sendFakeBufferProgressEvent() {
 758             // Send fake 100% buffer progress event for HLS or !http protcol
 759             String contentType = media.getLocator().getContentType();
 760             String protocol = media.getLocator().getProtocol();
 761             if ((contentType != null &amp;&amp; (contentType.equals(MediaUtils.CONTENT_TYPE_M3U) || contentType.equals(MediaUtils.CONTENT_TYPE_M3U8)))
 762                     || (protocol != null &amp;&amp; !protocol.equals(&quot;http&quot;) &amp;&amp; !protocol.equals(&quot;https&quot;))) {
 763                 HandleBufferEvents(new BufferProgressEvent(getDuration(), 0, 1, 1));
 764             }
 765         }
 766     }
 767 
 768     /**
 769      * Internal function to get called when the native player is ready.
 770      */
 771     private synchronized void onNativeInit() {
 772         try {
 773             playerInit();
 774         } catch (MediaException me) {
 775             sendPlayerMediaErrorEvent(me.getMediaError().code());
 776         }
 777     }
 778 
 779     //**************************************************************************
 780     //***** MediaPlayer implementation
 781     //**************************************************************************
 782     //***** Listener (un)registration.
 783     @Override
 784     public void addMediaErrorListener(MediaErrorListener listener) {
 785         if (listener != null) {
 786             this.errorListeners.add(new WeakReference&lt;&gt;(listener));
 787 
 788             synchronized (cachedErrorEvents) {
 789                 if (!cachedErrorEvents.isEmpty() &amp;&amp; !errorListeners.isEmpty()) {
 790                     cachedErrorEvents.stream().forEach((evt) -&gt; {
 791                         sendPlayerEvent(evt);
 792                     });
 793                     cachedErrorEvents.clear();
 794                 }
 795             }
 796         }
 797     }
 798 
 799     @Override
 800     public void removeMediaErrorListener(MediaErrorListener listener) {
 801         if (listener != null) {
 802             for (ListIterator&lt;WeakReference&lt;MediaErrorListener&gt;&gt; it = errorListeners.listIterator(); it.hasNext();) {
 803                 MediaErrorListener l = it.next().get();
 804                 if (l == null || l == listener) {
 805                     it.remove();
 806                 }
 807             }
 808         }
 809     }
 810 
 811     @Override
 812     public void addMediaPlayerListener(PlayerStateListener listener) {
 813         if (listener != null) {
 814             synchronized (cachedStateEvents) {
 815                 if (!cachedStateEvents.isEmpty() &amp;&amp; playerStateListeners.isEmpty()) {
 816                     // Forward all cached state events to first listener to register.
 817                     Iterator&lt;PlayerStateEvent&gt; events = cachedStateEvents.iterator();
 818                     while (events.hasNext()) {
 819                         PlayerStateEvent evt = events.next();
 820                         switch (evt.getState()) {
 821                             case READY:
 822                                 listener.onReady(evt);
 823                                 break;
 824                             case PLAYING:
 825                                 listener.onPlaying(evt);
 826                                 break;
 827                             case PAUSED:
 828                                 listener.onPause(evt);
 829                                 break;
 830                             case STOPPED:
 831                                 listener.onStop(evt);
 832                                 break;
 833                             case STALLED:
 834                                 listener.onStall(evt);
 835                                 break;
 836                             case FINISHED:
 837                                 listener.onFinish(evt);
 838                                 break;
 839                             case HALTED:
 840                                 listener.onHalt(evt);
 841                                 break;
 842                             default:
 843                                 break;
 844                         }
 845                     }
 846 
 847                     // Clear state event cache.
 848                     cachedStateEvents.clear();
 849                 }
 850 
 851                 playerStateListeners.add(new WeakReference(listener));
 852             }
 853         }
 854     }
 855 
 856     @Override
 857     public void removeMediaPlayerListener(PlayerStateListener listener) {
 858         if (listener != null) {
 859             for (ListIterator&lt;WeakReference&lt;PlayerStateListener&gt;&gt; it = playerStateListeners.listIterator(); it.hasNext();) {
 860                 PlayerStateListener l = it.next().get();
 861                 if (l == null || l == listener) {
 862                     it.remove();
 863                 }
 864             }
 865         }
 866     }
 867 
 868     @Override
 869     public void addMediaTimeListener(PlayerTimeListener listener) {
 870         if (listener != null) {
 871             synchronized (cachedTimeEvents) {
 872                 if (!cachedTimeEvents.isEmpty() &amp;&amp; playerTimeListeners.isEmpty()) {
 873                     // Forward all cached time events to first listener to register.
 874                     Iterator&lt;PlayerTimeEvent&gt; events = cachedTimeEvents.iterator();
 875                     while (events.hasNext()) {
 876                         PlayerTimeEvent evt = events.next();
 877                         listener.onDurationChanged(evt.getTime());
 878                     }
 879 
 880                     // Clear time event cache.
 881                     cachedTimeEvents.clear();
 882                 } else {
 883                     // Let listener to know about duration
 884                     double duration = getDuration();
 885                     if (duration != Double.POSITIVE_INFINITY) {
 886                         listener.onDurationChanged(duration);
 887                     }
 888                 }
 889 
 890                 playerTimeListeners.add(new WeakReference(listener));
 891             }
 892         }
 893     }
 894 
 895     @Override
 896     public void removeMediaTimeListener(PlayerTimeListener listener) {
 897         if (listener != null) {
 898             for (ListIterator&lt;WeakReference&lt;PlayerTimeListener&gt;&gt; it = playerTimeListeners.listIterator(); it.hasNext();) {
 899                 PlayerTimeListener l = it.next().get();
 900                 if (l == null || l == listener) {
 901                     it.remove();
 902                 }
 903             }
 904         }
 905     }
 906 
 907     @Override
 908     public void addVideoTrackSizeListener(VideoTrackSizeListener listener) {
 909         if (listener != null) {
 910             if (frameWidth != -1 &amp;&amp; frameHeight != -1) {
 911                 listener.onSizeChanged(frameWidth, frameHeight);
 912             }
 913             videoTrackSizeListeners.add(new WeakReference(listener));
 914         }
 915     }
 916 
 917     @Override
 918     public void removeVideoTrackSizeListener(VideoTrackSizeListener listener) {
 919         if (listener != null) {
 920             for (ListIterator&lt;WeakReference&lt;VideoTrackSizeListener&gt;&gt; it = videoTrackSizeListeners.listIterator(); it.hasNext();) {
 921                 VideoTrackSizeListener l = it.next().get();
 922                 if (l == null || l == listener) {
 923                     it.remove();
 924                 }
 925             }
 926         }
 927     }
 928 
 929     @Override
 930     public void addMarkerListener(MarkerListener listener) {
 931         if (listener != null) {
 932             markerListeners.add(new WeakReference(listener));
 933         }
 934     }
 935 
 936     @Override
 937     public void removeMarkerListener(MarkerListener listener) {
 938         if (listener != null) {
 939             for (ListIterator&lt;WeakReference&lt;MarkerListener&gt;&gt; it = markerListeners.listIterator(); it.hasNext();) {
 940                 MarkerListener l = it.next().get();
 941                 if (l == null || l == listener) {
 942                     it.remove();
 943                 }
 944             }
 945         }
 946     }
 947 
 948     @Override
 949     public void addBufferListener(BufferListener listener) {
 950         if (listener != null) {
 951             synchronized (cachedBufferEvents) {
 952                 if (!cachedBufferEvents.isEmpty() &amp;&amp; bufferListeners.isEmpty()) {
 953                     cachedBufferEvents.stream().forEach((evt) -&gt; {
 954                         listener.onBufferProgress(evt);
 955                     });
 956                     // Clear buffer event cache.
 957                     cachedBufferEvents.clear();
 958                 }
 959 
 960                 bufferListeners.add(new WeakReference(listener));
 961             }
 962         }
 963     }
 964 
 965     @Override
 966     public void removeBufferListener(BufferListener listener) {
 967         if (listener != null) {
 968             for (ListIterator&lt;WeakReference&lt;BufferListener&gt;&gt; it = bufferListeners.listIterator(); it.hasNext();) {
 969                 BufferListener l = it.next().get();
 970                 if (l == null || l == listener) {
 971                     it.remove();
 972                 }
 973             }
 974         }
 975     }
 976 
 977     @Override
 978     public void addAudioSpectrumListener(AudioSpectrumListener listener) {
 979         if (listener != null) {
 980             audioSpectrumListeners.add(new WeakReference(listener));
 981         }
 982     }
 983 
 984     @Override
 985     public void removeAudioSpectrumListener(AudioSpectrumListener listener) {
 986         if (listener != null) {
 987             for (ListIterator&lt;WeakReference&lt;AudioSpectrumListener&gt;&gt; it = audioSpectrumListeners.listIterator(); it.hasNext();) {
 988                 AudioSpectrumListener l = it.next().get();
 989                 if (l == null || l == listener) {
 990                     it.remove();
 991                 }
 992             }
 993         }
 994     }
 995 
 996     //***** Control functions
 997     @Override
 998     public VideoRenderControl getVideoRenderControl() {
 999         return videoRenderControl;
1000     }
1001 
1002     @Override
1003     public Media getMedia() {
1004         return media;
1005     }
1006 
1007     @Override
1008     public void setAudioSyncDelay(long delay) {
1009         try {
1010             playerSetAudioSyncDelay(delay);
1011         } catch (MediaException me) {
1012             sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1013         }
1014     }
1015 
1016     @Override
1017     public long getAudioSyncDelay() {
1018         try {
1019             return playerGetAudioSyncDelay();
1020         } catch (MediaException me) {
1021             sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1022         }
1023         return 0;
1024     }
1025 
1026     @Override
1027     public void play() {
1028         try {
1029             if (isStartTimeUpdated) {
1030                 playerSeek(startTime);
1031             }
1032             isMediaPulseEnabled.set(true);
1033             playerPlay();
1034         } catch (MediaException me) {
1035             sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1036         }
1037     }
1038 
1039     @Override
1040     public void stop() {
1041         try {
1042             playerStop();
1043             playerSeek(startTime);
1044         } catch (MediaException me) {
1045 //            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1046             MediaUtils.warning(this, &quot;stop() failed!&quot;);
1047         }
1048     }
1049 
1050     @Override
1051     public void pause() {
1052         try {
1053             playerPause();
1054         } catch (MediaException me) {
1055             sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1056         }
1057     }
1058 
1059     @Override
1060     public float getRate() {
1061         try {
1062             return playerGetRate();
1063         } catch (MediaException me) {
1064             sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1065         }
1066         return 0;
1067     }
1068 
1069     //***** Public properties
1070     @Override
1071     public void setRate(float rate) {
1072         try {
1073             playerSetRate(rate);
1074         } catch (MediaException me) {
1075 //            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1076             MediaUtils.warning(this, &quot;setRate(&quot; + rate + &quot;) failed!&quot;);
1077         }
1078     }
1079 
1080     @Override
1081     public double getPresentationTime() {
1082         try {
1083             return playerGetPresentationTime();
1084         } catch (MediaException me) {
1085 //            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1086         }
1087         return -1.0;
1088     }
1089 
1090     @Override
1091     public float getVolume() {
1092         try {
1093             return playerGetVolume();
1094         } catch (MediaException me) {
1095             sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1096         }
1097         return 0;
1098     }
1099 
1100     @Override
1101     public void setVolume(float vol) {
1102         if (vol &lt; 0.0F) {
1103             vol = 0.0F;
1104         } else if (vol &gt; 1.0F) {
1105             vol = 1.0F;
1106         }
1107 
1108         try {
1109             playerSetVolume(vol);
1110         } catch (MediaException me) {
1111             sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1112         }
1113     }
1114 
1115     @Override
1116     public boolean getMute() {
1117         try {
1118             return playerGetMute();
1119         } catch (MediaException me) {
1120             sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1121         }
1122         return false;
1123     }
1124 
1125     /**
1126      * Enables/disable mute. If mute is enabled then disabled, the previous
1127      * volume goes into effect.
1128      */
1129     @Override
1130     public void setMute(boolean enable) {
1131         try {
1132             playerSetMute(enable);
1133         } catch (MediaException me) {
1134             sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1135         }
1136     }
1137 
1138     @Override
1139     public float getBalance() {
1140         try {
1141             return playerGetBalance();
1142         } catch (MediaException me) {
1143             sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1144         }
1145         return 0;
1146     }
1147 
1148     @Override
1149     public void setBalance(float bal) {
1150         if (bal &lt; -1.0F) {
1151             bal = -1.0F;
1152         } else if (bal &gt; 1.0F) {
1153             bal = 1.0F;
1154         }
1155 
1156         try {
1157             playerSetBalance(bal);
1158         } catch (MediaException me) {
1159             sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1160         }
1161     }
1162 
1163     @Override
1164     public abstract AudioEqualizer getEqualizer();
1165 
1166     @Override
1167     public abstract AudioSpectrum getAudioSpectrum();
1168 
1169     @Override
1170     public double getDuration() {
1171         try {
1172             return playerGetDuration();
1173         } catch (MediaException me) {
1174 //            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1175         }
1176         return Double.POSITIVE_INFINITY;
1177     }
1178 
1179     /**
1180      * Gets the time within the duration of the media to start playing.
1181      */
1182     @Override
1183     public double getStartTime() {
1184         return startTime;
1185     }
1186 
1187     /**
1188      * Sets the start time within the media to play.
1189      */
1190     @Override
1191     public void setStartTime(double startTime) {
1192         try {
1193             markerLock.lock();
1194             this.startTime = startTime;
1195             if (playerState != PlayerState.PLAYING &amp;&amp; playerState != PlayerState.FINISHED &amp;&amp; playerState != PlayerState.STOPPED) {
1196                 playerSeek(startTime);
1197             } else if (playerState == PlayerState.STOPPED) {
1198                 isStartTimeUpdated = true;
1199             }
1200         } finally {
1201             markerLock.unlock();
1202         }
1203     }
1204 
1205     /**
1206      * Gets the time within the duration of the media to stop playing.
1207      */
1208     @Override
1209     public double getStopTime() {
1210         return stopTime;
1211     }
1212 
1213     /**
1214      * Sets the stop time within the media to stop playback.
1215      */
1216     @Override
1217     public void setStopTime(double stopTime) {
1218         try {
1219             markerLock.lock();
1220             this.stopTime = stopTime;
1221             isStopTimeSet = true;
1222             createMediaPulse();
1223         } finally {
1224             markerLock.unlock();
1225         }
1226     }
1227 
1228     @Override
1229     public void seek(double streamTime) {
1230         if (playerState == PlayerState.STOPPED) {
1231             return; // No seek in stopped state
1232         }
1233 
1234         if (streamTime &lt; 0.0) {
1235             streamTime = 0.0;
1236         } else {
1237             double duration = getDuration();
1238             if (duration &gt;= 0.0 &amp;&amp; streamTime &gt; duration) {
1239                 streamTime = duration;
1240             }
1241         }
1242 
1243         if (!isMediaPulseEnabled.get()) {
1244             if ((playerState == PlayerState.PLAYING
1245                     || playerState == PlayerState.PAUSED
1246                     || playerState == PlayerState.FINISHED)
1247                     &amp;&amp; getStartTime() &lt;= streamTime &amp;&amp; streamTime &lt;= getStopTime()) {
1248                 isMediaPulseEnabled.set(true);
1249             }
1250         }
1251 
1252         markerLock.lock();
1253         try {
1254             timeBeforeSeek = getPresentationTime();
1255             timeAfterSeek = streamTime;
1256             checkSeek = timeBeforeSeek != timeAfterSeek;
1257             previousTime = streamTime;
1258             firedMarkerTime = -1.0;
1259 //            System.out.println(&quot;seek @ &quot;+System.currentTimeMillis());
1260 //            System.out.println(&quot;seek to &quot;+streamTime+&quot; previousTime &quot;+previousTime);
1261 
1262             try {
1263                 playerSeek(streamTime);
1264             } catch (MediaException me) {
1265                 //sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1266                 MediaUtils.warning(this, &quot;seek(&quot; + streamTime + &quot;) failed!&quot;);
1267             }
1268         } finally {
1269             markerLock.unlock();
1270         }
1271     }
1272 
1273     protected abstract long playerGetAudioSyncDelay() throws MediaException;
1274 
1275     protected abstract void playerSetAudioSyncDelay(long delay) throws MediaException;
1276 
1277     protected abstract void playerPlay() throws MediaException;
1278 
1279     protected abstract void playerStop() throws MediaException;
1280 
1281     protected abstract void playerPause() throws MediaException;
1282 
1283     protected abstract void playerFinish() throws MediaException;
1284 
1285     protected abstract float playerGetRate() throws MediaException;
1286 
1287     protected abstract void playerSetRate(float rate) throws MediaException;
1288 
1289     protected abstract double playerGetPresentationTime() throws MediaException;
1290 
1291     protected abstract boolean playerGetMute() throws MediaException;
1292 
1293     protected abstract void playerSetMute(boolean state) throws MediaException;
1294 
1295     protected abstract float playerGetVolume() throws MediaException;
1296 
1297     protected abstract void playerSetVolume(float volume) throws MediaException;
1298 
1299     protected abstract float playerGetBalance() throws MediaException;
1300 
1301     protected abstract void playerSetBalance(float balance) throws MediaException;
1302 
1303     protected abstract double playerGetDuration() throws MediaException;
1304 
1305     protected abstract void playerSeek(double streamTime) throws MediaException;
1306 
1307     protected abstract void playerInit() throws MediaException;
1308 
1309     protected abstract void playerDispose();
1310 
1311     /**
1312      * Retrieves the current {@link PlayerState state} of the player.
1313      *
1314      * @return the current player state.
1315      */
1316     @Override
1317     public PlayerState getState() {
1318         return playerState;
1319     }
1320 
1321     @Override
1322     final public void dispose() {
1323         disposeLock.lock();
1324         try {
1325             if (!isDisposed) {
1326                 // Terminate event firing
1327                 destroyMediaPulse();
1328 
1329                 if (eventLoop != null) {
1330                     eventLoop.terminateLoop();
1331                     eventLoop = null;
1332                 }
1333 
1334                 synchronized (firstFrameLock) {
1335                     if (firstFrameEvent != null) {
1336                         firstFrameEvent.getFrameData().releaseFrame();
1337                         firstFrameEvent = null;
1338                     }
1339                 }
1340 
1341                 // Terminate native layer
1342                 playerDispose();
1343 
1344                 // Dispose media object and clear reference
1345                 if (media != null) {
1346                     media.dispose();
1347                     media = null;
1348                 }
1349 
1350                 if (videoUpdateListeners != null) {
1351                     for (ListIterator&lt;WeakReference&lt;VideoRendererListener&gt;&gt; it = videoUpdateListeners.listIterator(); it.hasNext();) {
1352                         VideoRendererListener l = it.next().get();
1353                         if (l != null) {
1354                             l.releaseVideoFrames();
1355                         } else {
1356                             it.remove();
1357                         }
1358                     }
1359 
1360                     videoUpdateListeners.clear();
1361                 }
1362 
1363                 if (playerStateListeners != null) {
1364                     playerStateListeners.clear();
1365                 }
1366 
1367                 if (videoTrackSizeListeners != null) {
1368                     videoTrackSizeListeners.clear();
1369                 }
1370 
1371                 if (videoFrameRateListeners != null) {
1372                     videoFrameRateListeners.clear();
1373                 }
1374 
1375                 if (cachedStateEvents != null) {
1376                     cachedStateEvents.clear();
1377                 }
1378 
1379                 if (cachedTimeEvents != null) {
1380                     cachedTimeEvents.clear();
1381                 }
1382 
1383                 if (cachedBufferEvents != null) {
1384                     cachedBufferEvents.clear();
1385                 }
1386 
1387                 if (errorListeners != null) {
1388                     errorListeners.clear();
1389                 }
1390 
1391                 if (playerTimeListeners != null) {
1392                     playerTimeListeners.clear();
1393                 }
1394 
1395                 if (markerListeners != null) {
1396                     markerListeners.clear();
1397                 }
1398 
1399                 if (bufferListeners != null) {
1400                     bufferListeners.clear();
1401                 }
1402 
1403                 if (audioSpectrumListeners != null) {
1404                     audioSpectrumListeners.clear();
1405                 }
1406 
1407                 if (videoRenderControl != null) {
1408                     videoRenderControl = null;
1409                 }
1410 
1411                 if (onDispose != null) {
1412                     onDispose.run();
1413                 }
1414 
1415                 isDisposed = true;
1416             }
1417         } finally {
1418             disposeLock.unlock();
1419         }
1420     }
1421 
1422     @Override
1423     public boolean isErrorEventCached() {
1424         synchronized (cachedErrorEvents) {
1425             if (cachedErrorEvents.isEmpty()) {
1426                 return false;
1427             } else {
1428                 return true;
1429             }
1430         }
1431     }
1432 
1433     //**************************************************************************
1434     //***** Non-JNI methods called by the native layer. These methods are called
1435     //***** from the native layer via the invocation API. Their purpose is to
1436     //***** dispatch certain events to the Java layer. Each of these methods
1437     //***** posts an event on the &lt;code&gt;EventQueueThread&lt;/code&gt; which in turn
1438     //***** forwards the event to any registered listeners.
1439     //**************************************************************************
1440     protected void sendWarning(int warningCode, String warningMessage) {
1441         if (eventLoop != null) {
1442             String message = String.format(MediaUtils.NATIVE_MEDIA_WARNING_FORMAT,
1443                     warningCode);
1444             if (warningMessage != null) {
1445                 message += &quot;: &quot; + warningMessage;
1446             }
1447             eventLoop.postEvent(new WarningEvent(this, message));
1448         }
1449     }
1450 
1451     protected void sendPlayerEvent(PlayerEvent evt) {
1452         if (eventLoop != null) {
1453             eventLoop.postEvent(evt);
1454         }
1455     }
1456 
1457     protected void sendPlayerHaltEvent(String message, double time) {
1458         // Log the error.  Since these are most likely playback engine message (e.g. GStreamer or PacketVideo),
1459         // it makes no sense to propogate it above.
1460         Logger.logMsg(Logger.ERROR, message);
1461 
1462         if (eventLoop != null) {
1463             eventLoop.postEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.HALTED, time, message));
1464         }
1465     }
1466 
1467     protected void sendPlayerMediaErrorEvent(int errorCode) {
1468         sendPlayerEvent(new MediaErrorEvent(this, MediaError.getFromCode(errorCode)));
1469     }
1470 
1471     protected void sendPlayerStateEvent(int eventID, double time) {
1472         switch (eventID) {
1473             case eventPlayerReady:
1474                 sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.READY, time));
1475                 break;
1476             case eventPlayerPlaying:
1477                 sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.PLAYING, time));
1478                 break;
1479             case eventPlayerPaused:
1480                 sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.PAUSED, time));
1481                 break;
1482             case eventPlayerStopped:
1483                 sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.STOPPED, time));
1484                 break;
1485             case eventPlayerStalled:
1486                 sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.STALLED, time));
1487                 break;
1488             case eventPlayerFinished:
1489                 sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.FINISHED, time));
1490                 break;
1491             default:
1492                 break;
1493         }
1494     }
1495 
1496     protected void sendNewFrameEvent(long nativeRef) {
1497         NativeVideoBuffer newFrameData = NativeVideoBuffer.createVideoBuffer(nativeRef);
1498         // createVideoBuffer puts a hold on the frame
1499         // we need to keep that hold until the event thread can process this event
1500         sendPlayerEvent(new NewFrameEvent(newFrameData));
1501     }
1502 
1503     protected void sendFrameSizeChangedEvent(int width, int height) {
1504         sendPlayerEvent(new FrameSizeChangedEvent(width, height));
1505     }
1506 
1507     protected void sendAudioTrack(boolean enabled, long trackID, String name, int encoding,
1508             String language, int numChannels,
1509             int channelMask, float sampleRate) {
1510         Locale locale = null;
1511         if (!language.equals(&quot;und&quot;)) {
1512             locale = new Locale(language);
1513         }
1514 
1515         Track track = new AudioTrack(enabled, trackID, name,
1516                 locale, Encoding.toEncoding(encoding),
1517                 numChannels, channelMask, sampleRate);
1518 
1519         TrackEvent evt = new TrackEvent(track);
1520 
1521         sendPlayerEvent(evt);
1522     }
1523 
1524     protected void sendVideoTrack(boolean enabled, long trackID, String name, int encoding,
1525             int width, int height, float frameRate,
1526             boolean hasAlphaChannel) {
1527         // No locale (currently) for video, so pass null
1528         Track track = new VideoTrack(enabled, trackID, name, null,
1529                 Encoding.toEncoding(encoding),
1530                 new VideoResolution(width, height), frameRate, hasAlphaChannel);
1531 
1532         TrackEvent evt = new TrackEvent(track);
1533 
1534         sendPlayerEvent(evt);
1535     }
1536 
1537     protected void sendSubtitleTrack(boolean enabled, long trackID, String name,
1538             int encoding, String language)
1539     {
1540         Locale locale = null;
1541         if (null != language) {
1542             locale = new Locale(language);
1543         }
1544         Track track = new SubtitleTrack(enabled, trackID, name, locale,
1545                 Encoding.toEncoding(encoding));
1546 
1547         sendPlayerEvent(new TrackEvent(track));
1548     }
1549 
1550     protected void sendMarkerEvent(String name, double time) {
1551         sendPlayerEvent(new MarkerEvent(name, time));
1552     }
1553 
1554     protected void sendDurationUpdateEvent(double duration) {
1555         sendPlayerEvent(new PlayerTimeEvent(duration));
1556     }
1557 
1558     protected void sendBufferProgressEvent(double clipDuration, long bufferStart, long bufferStop, long bufferPosition) {
1559         sendPlayerEvent(new BufferProgressEvent(clipDuration, bufferStart, bufferStop, bufferPosition));
1560     }
1561 
1562     protected void sendAudioSpectrumEvent(double timestamp, double duration, boolean queryTimestamp) {
1563         sendPlayerEvent(new AudioSpectrumEvent(getAudioSpectrum(), timestamp, duration, queryTimestamp));
1564     }
1565 
1566     @Override
1567     public void markerStateChanged(boolean hasMarkers) {
1568         if (hasMarkers) {
1569             markerLock.lock();
1570             try {
1571                 previousTime = getPresentationTime();
1572             } finally {
1573                 markerLock.unlock();
1574             }
1575             createMediaPulse();
1576         } else {
1577             if (!isStopTimeSet) {
1578                 destroyMediaPulse();
1579             }
1580         }
1581     }
1582 
1583     private void createMediaPulse() {
1584         mediaPulseLock.lock();
1585         try {
1586             if (mediaPulseTimer == null) {
1587                 mediaPulseTimer = new Timer(true);
1588                 mediaPulseTimer.scheduleAtFixedRate(new MediaPulseTask(this), 0, 40 /*
1589                          * period ms
1590                          */);
1591             }
1592         } finally {
1593             mediaPulseLock.unlock();
1594         }
1595     }
1596 
1597     private void destroyMediaPulse() {
1598         mediaPulseLock.lock();
1599         try {
1600             if (mediaPulseTimer != null) {
1601                 mediaPulseTimer.cancel();
1602                 mediaPulseTimer = null;
1603             }
1604         } finally {
1605             mediaPulseLock.unlock();
1606         }
1607     }
1608 
1609     boolean doMediaPulseTask() {
1610         if (this.isMediaPulseEnabled.get()) {
1611             disposeLock.lock();
1612 
1613             if (isDisposed) {
1614                 disposeLock.unlock();
1615                 return false;
1616             }
1617 
1618             double thisTime = getPresentationTime();
1619 
1620             markerLock.lock();
1621 
1622             try {
1623                 //System.out.println(&quot;Media pulse @ pts &quot;+thisTime+&quot; previous &quot;+previousTime);
1624 
1625                 if (checkSeek) {
1626                     if (timeAfterSeek &gt; timeBeforeSeek) {
1627                         // Forward seek
1628                         if (thisTime &gt;= timeAfterSeek) {
1629 //                        System.out.println(&quot;bail 1&quot;);
1630                             checkSeek = false;
1631                         } else {
1632                             return true;
1633                         }
1634                     } else if (timeAfterSeek &lt; timeBeforeSeek) {
1635                         // Backward seek
1636                         if (thisTime &gt;= timeBeforeSeek) {
1637 //                        System.out.println(&quot;bail 2&quot;);
1638                             return true;
1639                         } else {
1640                             checkSeek = false;
1641                         }
1642                     }
1643                 }
1644 
1645                 Map.Entry&lt;Double, String&gt; marker = media.getNextMarker(previousTime, true);
1646 //                System.out.println(&quot;marker &quot;+marker);
1647 //                System.out.println(&quot;Checking: &quot; + previousTime + &quot; &quot; + thisTime + &quot; &quot;
1648 //                        + getStartTime() + &quot; &quot; + getStopTime() + &quot; &quot;
1649 //                        + marker.getKey());
1650 
1651                 while (marker != null) {
1652                     double nextMarkerTime = marker.getKey();
1653                     if (nextMarkerTime &gt; thisTime) {
1654                         break;
1655                     } else if (nextMarkerTime != firedMarkerTime
1656                             &amp;&amp; nextMarkerTime &gt;= previousTime
1657                             &amp;&amp; nextMarkerTime &gt;= getStartTime()
1658                             &amp;&amp; nextMarkerTime &lt;= getStopTime()) {
1659 //                            System.out.println(&quot;Firing: &quot;+previousTime+&quot; &quot;+thisTime+&quot; &quot;+
1660 //                                    getStartTime()+&quot; &quot;+getStopTime()+&quot; &quot;+
1661 //                                    nextMarkerTime);
1662                         MarkerEvent evt = new MarkerEvent(marker.getValue(), nextMarkerTime);
1663                         for (ListIterator&lt;WeakReference&lt;MarkerListener&gt;&gt; it = markerListeners.listIterator(); it.hasNext();) {
1664                             MarkerListener listener = it.next().get();
1665                             if (listener != null) {
1666                                 listener.onMarker(evt);
1667                             } else {
1668                                 it.remove();
1669                             }
1670                         }
1671                         firedMarkerTime = nextMarkerTime;
1672                     }
1673                     marker = media.getNextMarker(nextMarkerTime, false);
1674                 }
1675 
1676                 previousTime = thisTime;
1677 
1678                 // Do stopTime
1679                 if (isStopTimeSet &amp;&amp; thisTime &gt;= stopTime) {
1680                     playerFinish();
1681                 }
1682             } finally {
1683                 disposeLock.unlock();
1684                 markerLock.unlock();
1685             }
1686         }
1687 
1688         return true;
1689     }
1690 
1691     /* Audio EQ and spectrum creation, used by sub-classes */
1692     protected AudioEqualizer createNativeAudioEqualizer(long nativeRef) {
1693         return new NativeAudioEqualizer(nativeRef);
1694     }
1695 
1696     protected AudioSpectrum createNativeAudioSpectrum(long nativeRef) {
1697         return new NativeAudioSpectrum(nativeRef);
1698     }
1699 }
1700 
1701 class MediaPulseTask extends TimerTask {
1702 
1703     WeakReference&lt;NativeMediaPlayer&gt; playerRef;
1704 
1705     MediaPulseTask(NativeMediaPlayer player) {
1706         playerRef = new WeakReference&lt;&gt;(player);
1707     }
1708 
1709     @Override
1710     public void run() {
1711         final NativeMediaPlayer player = playerRef.get();
1712         if (player != null) {
1713             if (!player.doMediaPulseTask()) {
1714                 cancel(); // Stop if doMediaPulseTask() returns false. False means doMediaPulseTask() cannot continue (like after dispose).cy
1715             }
1716         } else {
1717             cancel();
1718         }
1719     }
1720 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/java/com/sun/media/jfxmediaimpl/NativeMediaPlayer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.media.jfxmediaimpl;
  27 
  28 import java.lang.annotation.Native;
  29 import com.sun.media.jfxmedia.Media;
  30 import com.sun.media.jfxmedia.MediaError;
  31 import com.sun.media.jfxmedia.MediaException;
  32 import com.sun.media.jfxmedia.MediaPlayer;
  33 import com.sun.media.jfxmedia.control.VideoRenderControl;
  34 import com.sun.media.jfxmedia.effects.AudioEqualizer;
  35 import com.sun.media.jfxmedia.effects.AudioSpectrum;
  36 import com.sun.media.jfxmedia.events.AudioSpectrumEvent;
  37 import com.sun.media.jfxmedia.events.AudioSpectrumListener;
  38 import com.sun.media.jfxmedia.events.BufferListener;
  39 import com.sun.media.jfxmedia.events.BufferProgressEvent;
  40 import com.sun.media.jfxmedia.events.MarkerEvent;
  41 import com.sun.media.jfxmedia.events.MarkerListener;
  42 import com.sun.media.jfxmedia.events.MediaErrorListener;
  43 import com.sun.media.jfxmedia.events.NewFrameEvent;
  44 import com.sun.media.jfxmedia.events.PlayerEvent;
  45 import com.sun.media.jfxmedia.events.PlayerStateEvent;
  46 import com.sun.media.jfxmedia.events.PlayerStateEvent.PlayerState;
  47 import com.sun.media.jfxmedia.events.PlayerStateListener;
  48 import com.sun.media.jfxmedia.events.PlayerTimeListener;
  49 import com.sun.media.jfxmedia.events.VideoFrameRateListener;
  50 import com.sun.media.jfxmedia.events.VideoRendererListener;
  51 import com.sun.media.jfxmedia.events.VideoTrackSizeListener;
  52 import com.sun.media.jfxmedia.logging.Logger;
  53 import com.sun.media.jfxmedia.track.AudioTrack;
  54 import com.sun.media.jfxmedia.track.SubtitleTrack;
  55 import com.sun.media.jfxmedia.track.Track;
  56 import com.sun.media.jfxmedia.track.Track.Encoding;
  57 import com.sun.media.jfxmedia.track.VideoResolution;
  58 import com.sun.media.jfxmedia.track.VideoTrack;
  59 import java.lang.ref.WeakReference;
  60 import java.util.*;
  61 import java.util.concurrent.BlockingQueue;
  62 import java.util.concurrent.LinkedBlockingQueue;
  63 import java.util.concurrent.atomic.AtomicBoolean;
  64 import java.util.concurrent.locks.Lock;
  65 import java.util.concurrent.locks.ReentrantLock;
  66 
  67 /**
  68  * Base implementation of a
  69  * &lt;code&gt;MediaPlayer&lt;/code&gt;.
  70  */
  71 public abstract class NativeMediaPlayer implements MediaPlayer, MarkerStateListener {
  72     //***** Event IDs for PlayerStateEvent.  IDs sent from native JNI layer.
  73 
  74     @Native public final static int eventPlayerUnknown = 100;
  75     @Native public final static int eventPlayerReady = 101;
  76     @Native public final static int eventPlayerPlaying = 102;
  77     @Native public final static int eventPlayerPaused = 103;
  78     @Native public final static int eventPlayerStopped = 104;
  79     @Native public final static int eventPlayerStalled = 105;
  80     @Native public final static int eventPlayerFinished = 106;
  81     @Native public final static int eventPlayerError = 107;
  82     // Nominal video frames per second.
  83     @Native private static final int NOMINAL_VIDEO_FPS = 30;
  84     // Nanoseconds per second.
  85     @Native public static final long ONE_SECOND = 1000000000L;
  86 
  87     /**
  88      * The
  89      * &lt;code&gt;Media&lt;/code&gt; corresponding to the media source.
  90      */
  91     private NativeMedia media;
  92     private VideoRenderControl videoRenderControl;
  93     private final List&lt;WeakReference&lt;MediaErrorListener&gt;&gt; errorListeners = new ArrayList&lt;&gt;();
  94     private final List&lt;WeakReference&lt;PlayerStateListener&gt;&gt; playerStateListeners = new ArrayList&lt;&gt;();
  95     private final List&lt;WeakReference&lt;PlayerTimeListener&gt;&gt; playerTimeListeners = new ArrayList&lt;&gt;();
  96     private final List&lt;WeakReference&lt;VideoTrackSizeListener&gt;&gt; videoTrackSizeListeners = new ArrayList&lt;&gt;();
  97     private final List&lt;WeakReference&lt;VideoRendererListener&gt;&gt; videoUpdateListeners = new ArrayList&lt;&gt;();
  98     private final List&lt;WeakReference&lt;VideoFrameRateListener&gt;&gt; videoFrameRateListeners = new ArrayList&lt;&gt;();
  99     private final List&lt;WeakReference&lt;MarkerListener&gt;&gt; markerListeners = new ArrayList&lt;&gt;();
 100     private final List&lt;WeakReference&lt;BufferListener&gt;&gt; bufferListeners = new ArrayList&lt;&gt;();
 101     private final List&lt;WeakReference&lt;AudioSpectrumListener&gt;&gt; audioSpectrumListeners = new ArrayList&lt;&gt;();
 102     private final List&lt;PlayerStateEvent&gt; cachedStateEvents = new ArrayList&lt;&gt;();
 103     private final List&lt;PlayerTimeEvent&gt; cachedTimeEvents = new ArrayList&lt;&gt;();
 104     private final List&lt;BufferProgressEvent&gt; cachedBufferEvents = new ArrayList&lt;&gt;();
 105     private final List&lt;MediaErrorEvent&gt; cachedErrorEvents = new ArrayList&lt;&gt;();
 106     private boolean isFirstFrame = true;
 107     private NewFrameEvent firstFrameEvent = null;
 108     private double firstFrameTime;
 109     private final Object firstFrameLock = new Object();
 110     private EventQueueThread eventLoop = new EventQueueThread();
 111     private int frameWidth = -1;
 112     private int frameHeight = -1;
 113     private final AtomicBoolean isMediaPulseEnabled = new AtomicBoolean(false);
 114     private final Lock mediaPulseLock = new ReentrantLock();
 115     private Timer mediaPulseTimer;
 116     private final Lock markerLock = new ReentrantLock();
 117     private boolean checkSeek = false;
 118     private double timeBeforeSeek = 0.0;
 119     private double timeAfterSeek = 0.0;
 120     private double previousTime = 0.0;
 121     private double firedMarkerTime = -1.0;
 122     private double startTime = 0.0;
 123     private double stopTime = Double.POSITIVE_INFINITY;
 124     private boolean isStartTimeUpdated = false;
 125     private boolean isStopTimeSet = false;
 126 
 127     // --- Begin decoded frame rate fields
 128     private double encodedFrameRate = 0.0;
 129     private boolean recomputeFrameRate = true;
 130     private double previousFrameTime;
 131     private long numFramesSincePlaying;
 132     private double meanFrameDuration;
 133     private double decodedFrameRate;
 134     // --- End decoded frame rate fields
 135     private PlayerState playerState = PlayerState.UNKNOWN;
 136     private final Lock disposeLock = new ReentrantLock();
 137     private boolean isDisposed = false;
 138     private Runnable onDispose;
 139 
 140     //**************************************************************************
 141     //***** Constructors
 142     //**************************************************************************
 143     /**
 144      * Construct a NativeMediaPlayer for the referenced clip.
 145      *
 146      * @param clip Media object
 147      * @throws IllegalArgumentException if
 148      * &lt;code&gt;clip&lt;/code&gt; is
 149      * &lt;code&gt;null&lt;/code&gt;.
 150      */
 151     protected NativeMediaPlayer(NativeMedia clip) {
 152         if (clip == null) {
 153             throw new IllegalArgumentException(&quot;clip == null!&quot;);
 154         }
 155         media = clip;
 156         videoRenderControl = new VideoRenderer();
 157     }
 158 
 159     /**
 160      * Initialization method which must be called after construction to
 161      * initialize the internal state of the player. This method should be
 162      * invoked directly after the player is constructed.
 163      */
 164     protected void init() {
 165         media.addMarkerStateListener(this);
 166         eventLoop.start();
 167     }
 168 
 169     /**
 170      * Set a callback to invoke when the player is disposed.
 171      *
 172      * @param onDispose object on which to invoke {@link Runnable#run()} in
 173      * {@link #dispose()}.
 174      */
 175     void setOnDispose(Runnable onDispose) {
 176         disposeLock.lock();
 177         try {
 178             if (!isDisposed) {
 179                 this.onDispose = onDispose;
 180             }
 181         } finally {
 182             disposeLock.unlock();
 183         }
 184     }
 185 
 186     /**
 187      * Event to be posted to any registered {@link MediaErrorListener}s.
 188      */
 189     private static class WarningEvent extends PlayerEvent {
 190 
 191         private final Object source;
 192         private final String message;
 193 
 194         WarningEvent(Object source, String message) {
 195             this.source = source;
 196             this.message = message;
 197         }
 198 
 199         public Object getSource() {
 200             return source;
 201         }
 202 
 203         public String getMessage() {
 204             return message;
 205         }
 206     }
 207 
 208     /**
 209      * Event to be posted to any registered (@link MediaErrorListener)s
 210      */
 211     public static class MediaErrorEvent extends PlayerEvent {
 212 
 213         private final Object source;
 214         private final MediaError error;
 215 
 216         public MediaErrorEvent(Object source, MediaError error) {
 217             this.source = source;
 218             this.error = error;
 219         }
 220 
 221         public Object getSource() {
 222             return source;
 223         }
 224 
 225         public String getMessage() {
 226             return error.description();
 227         }
 228 
 229         public int getErrorCode() {
 230             return error.code();
 231         }
 232     }
 233 
 234     private static class PlayerTimeEvent extends PlayerEvent {
 235 
 236         private final double time;
 237 
 238         public PlayerTimeEvent(double time) {
 239             this.time = time;
 240         }
 241 
 242         public double getTime() {
 243             return time;
 244         }
 245     }
 246 
 247     /**
 248      * Event to be posted to any registered {@link PlayerStateListener}s.
 249      */
 250     private static class TrackEvent extends PlayerEvent {
 251 
 252         private final Track track;
 253 
 254         TrackEvent(Track track) {
 255             this.track = track;
 256         }
 257 
 258         public Track getTrack() {
 259             return this.track;
 260         }
 261     }
 262 
 263     /**
 264      * Event to be posted to any registered {@link VideoTrackSizeListener}s.
 265      */
 266     private static class FrameSizeChangedEvent extends PlayerEvent {
 267 
 268         private final int width;
 269         private final int height;
 270 
 271         public FrameSizeChangedEvent(int width, int height) {
 272             if (width &gt; 0) {
 273                 this.width = width;
 274             } else {
 275                 this.width = 0;
 276             }
 277 
 278             if (height &gt; 0) {
 279                 this.height = height;
 280             } else {
 281                 this.height = 0;
 282             }
 283         }
 284 
 285         public int getWidth() {
 286             return width;
 287         }
 288 
 289         public int getHeight() {
 290             return height;
 291         }
 292     }
 293 
 294     /**
 295      * Helper class which managers {@link VideoRendererListener}s. This allows
 296      * any registered listeners, specifically AWT and Prism, to receive video
 297      * frames.
 298      */
 299     private class VideoRenderer implements VideoRenderControl {
 300 
 301         /**
 302          * adds the listener to the player&#39;s videoUpdate. The listener will be
 303          * called whenever a new frame of video is ready to be painted or
 304          * fetched by getData()
 305          *
 306          * @param listener the object which provides the VideoUpdateListener
 307          * callback interface
 308          */
 309         @Override
 310         public void addVideoRendererListener(VideoRendererListener listener) {
 311             if (listener != null) {
 312                 synchronized (firstFrameLock) {
 313                     // If the first frame is cached, post it to the listener
 314                     // directly. The lock is obtained first so the cached
 315                     // frame is not cleared between the non-null test and
 316                     // posting the event.
 317                     if (firstFrameEvent != null) {
 318                         listener.videoFrameUpdated(firstFrameEvent);
 319                     }
 320                 }
 321                 videoUpdateListeners.add(new WeakReference&lt;&gt;(listener));
 322             }
 323         }
 324 
 325         /**
 326          * removes the listener from the player.
 327          *
 328          * @param listener to be removed from the player
 329          */
 330         @Override
 331         public void removeVideoRendererListener(VideoRendererListener listener) {
 332             if (listener != null) {
 333                 for (ListIterator&lt;WeakReference&lt;VideoRendererListener&gt;&gt; it = videoUpdateListeners.listIterator(); it.hasNext();) {
 334                     VideoRendererListener l = it.next().get();
 335                     if (l == null || l == listener) {
 336                         it.remove();
 337                     }
 338                 }
 339             }
 340         }
 341 
 342         @Override
 343         public void addVideoFrameRateListener(VideoFrameRateListener listener) {
 344             if (listener != null) {
 345                 videoFrameRateListeners.add(new WeakReference&lt;&gt;(listener));
 346             }
 347         }
 348 
 349         @Override
 350         public void removeVideoFrameRateListener(VideoFrameRateListener listener) {
 351             if (listener != null) {
 352                 for (ListIterator&lt;WeakReference&lt;VideoFrameRateListener&gt;&gt; it = videoFrameRateListeners.listIterator(); it.hasNext();) {
 353                     VideoFrameRateListener l = it.next().get();
 354                     if (l == null || l == listener) {
 355                         it.remove();
 356                     }
 357                 }
 358             }
 359         }
 360 
 361         @Override
 362         public int getFrameWidth() {
 363             return frameWidth;
 364         }
 365 
 366         @Override
 367         public int getFrameHeight() {
 368             return frameHeight;
 369         }
 370     }
 371 
 372     //***** EventQueueThread Helper Class -- Provides event handling.
 373     /**
 374      * Thread for media player event processing. The thread maintains an
 375      * internal queue of
 376      * &lt;code&gt;PlayerEvent&lt;/code&gt;s to which callers post using
 377      * &lt;code&gt;postEvent()&lt;/code&gt;. The thread blocks until an event becomes
 378      * available on the queue, and then removes the event from the queue and
 379      * posts it to any registered listeners appropriate to the type of event.
 380      */
 381     private class EventQueueThread extends Thread {
 382 
 383         private final BlockingQueue&lt;PlayerEvent&gt; eventQueue =
 384                 new LinkedBlockingQueue&lt;&gt;();
 385         private volatile boolean stopped = false;
 386 
 387         EventQueueThread() {
 388             setName(&quot;JFXMedia Player EventQueueThread&quot;);
 389             setDaemon(true);
 390         }
 391 
 392         @Override
 393         public void run() {
 394             while (!stopped) {
 395                 try {
 396                     // trying to take an event from the queue.
 397                     // this method will block until an event becomes available.
 398                     PlayerEvent evt = eventQueue.take();
 399 
 400                     if (!stopped) {
 401                         if (evt instanceof NewFrameEvent) {
 402                             try {
 403                                 HandleRendererEvents((NewFrameEvent) evt);
 404                             } catch (Throwable t) {
 405                                 if (Logger.canLog(Logger.ERROR)) {
 406                                     Logger.logMsg(Logger.ERROR, &quot;Caught exception in HandleRendererEvents: &quot; + t.toString());
 407                                 }
 408                             }
 409                         } else if (evt instanceof PlayerStateEvent) {
 410                             HandleStateEvents((PlayerStateEvent) evt);
 411                         } else if (evt instanceof FrameSizeChangedEvent) {
 412                             HandleFrameSizeChangedEvents((FrameSizeChangedEvent) evt);
 413                         } else if (evt instanceof TrackEvent) {
 414                             HandleTrackEvents((TrackEvent) evt);
 415                         } else if (evt instanceof MarkerEvent) {
 416                             HandleMarkerEvents((MarkerEvent) evt);
 417                         } else if (evt instanceof WarningEvent) {
 418                             HandleWarningEvents((WarningEvent) evt);
 419                         } else if (evt instanceof PlayerTimeEvent) {
 420                             HandlePlayerTimeEvents((PlayerTimeEvent) evt);
 421                         } else if (evt instanceof BufferProgressEvent) {
 422                             HandleBufferEvents((BufferProgressEvent) evt);
 423                         } else if (evt instanceof AudioSpectrumEvent) {
 424                             HandleAudioSpectrumEvents((AudioSpectrumEvent) evt);
 425                         } else if (evt instanceof MediaErrorEvent) {
 426                             HandleErrorEvents((MediaErrorEvent) evt);
 427                         }
 428                     }
 429                 } catch (Exception e) {
 430                     // eventQueue.take() can throw InterruptedException,
 431                     // also in rare case it can throw wrong
 432                     // IllegalMonitorStateException
 433                     // so we catch Exception
 434                     // nothing to do, restart the loop unless it was properly stopped.
 435                 }
 436             }
 437 
 438             eventQueue.clear();
 439         }
 440 
 441         private void HandleRendererEvents(NewFrameEvent evt) {
 442             if (isFirstFrame) {
 443                 // Cache first frame. Frames are delivered time-sequentially
 444                 // so there should be no thread contention problem here.
 445                 isFirstFrame = false;
 446                 synchronized (firstFrameLock) {
 447                     firstFrameEvent = evt;
 448                     firstFrameTime = firstFrameEvent.getFrameData().getTimestamp();
 449                     firstFrameEvent.getFrameData().holdFrame(); // hold as long as we cache it, else we&#39;ll crash
 450                 }
 451             } else if (firstFrameEvent != null
 452                     &amp;&amp; firstFrameTime != evt.getFrameData().getTimestamp()) {
 453                 // If this branch is entered then it cannot be the first frame.
 454                 // This means that the player must be in the PLAYING state as
 455                 // the first frame will arrive upon completion of prerolling.
 456                 // When playing, listeners should receive the current frame,
 457                 // not the first frame in the stream.
 458 
 459                 // Clear the cached first frame. Obtain the lock first to avoid
 460                 // a race condition with a listener newly being added.
 461                 synchronized (firstFrameLock) {
 462                     firstFrameEvent.getFrameData().releaseFrame();
 463                     firstFrameEvent = null;
 464                 }
 465             }
 466 
 467             // notify videoUpdateListeners
 468             for (ListIterator&lt;WeakReference&lt;VideoRendererListener&gt;&gt; it = videoUpdateListeners.listIterator(); it.hasNext();) {
 469                 VideoRendererListener l = it.next().get();
 470                 if (l != null) {
 471                     l.videoFrameUpdated(evt);
 472                 } else {
 473                     it.remove();
 474                 }
 475             }
 476             // done with the frame, we can release our hold now
 477             evt.getFrameData().releaseFrame();
 478 
 479             if (!videoFrameRateListeners.isEmpty()) {
 480                 // Decoded frame rate calculations.
 481                 double currentFrameTime = System.nanoTime() / (double) ONE_SECOND;
 482 
 483                 if (recomputeFrameRate) {
 484                     // First frame in new computation sequence.
 485                     recomputeFrameRate = false;
 486                     previousFrameTime = currentFrameTime;
 487                     numFramesSincePlaying = 1;
 488                 } else {
 489                     boolean fireFrameRateEvent = false;
 490 
 491                     if (numFramesSincePlaying == 1) {
 492                         // Second frame. Estimate the initial frame rate and
 493                         // set event flag.
 494                         meanFrameDuration = currentFrameTime - previousFrameTime;
 495                         if (meanFrameDuration &gt; 0.0) {
 496                             decodedFrameRate = 1.0 / meanFrameDuration;
 497                             fireFrameRateEvent = true;
 498                         }
 499                     } else {
 500                         // Update decoded frame rate estimate using a moving
 501                         // average over encodedFrameRate frames.
 502                         double previousMeanFrameDuration = meanFrameDuration;
 503 
 504                         // Determine moving average length.
 505                         int movingAverageLength = encodedFrameRate != 0.0
 506                                 ? ((int) (encodedFrameRate + 0.5)) : NOMINAL_VIDEO_FPS;
 507 
 508                         // Claculate number of frames in current average.
 509                         long numFrames = numFramesSincePlaying &lt; movingAverageLength
 510                                 ? numFramesSincePlaying : movingAverageLength;
 511 
 512                         // Update the mean frame duration.
 513                         meanFrameDuration = ((numFrames - 1) * previousMeanFrameDuration
 514                                 + currentFrameTime - previousFrameTime) / numFrames;
 515 
 516                         // If mean frame duration changed by more than 0.5 set
 517                         // event flag.
 518                         if (meanFrameDuration &gt; 0.0
 519                                 &amp;&amp; Math.abs(decodedFrameRate - 1.0 / meanFrameDuration) &gt; 0.5) {
 520                             decodedFrameRate = 1.0 / meanFrameDuration;
 521                             fireFrameRateEvent = true;
 522                         }
 523                     }
 524 
 525                     if (fireFrameRateEvent) {
 526                         // Fire event.
 527                         for (ListIterator&lt;WeakReference&lt;VideoFrameRateListener&gt;&gt; it = videoFrameRateListeners.listIterator(); it.hasNext();) {
 528                             VideoFrameRateListener l = it.next().get();
 529                             if (l != null) {
 530                                 l.onFrameRateChanged(decodedFrameRate);
 531                             } else {
 532                                 it.remove();
 533                             }
 534                         }
 535                     }
 536 
 537                     // Update running values.
 538                     previousFrameTime = currentFrameTime;
 539                     numFramesSincePlaying++;
 540                 }
 541             }
 542         }
 543 
 544         private void HandleStateEvents(PlayerStateEvent evt) {
 545             playerState = evt.getState();
 546 
 547             recomputeFrameRate = PlayerState.PLAYING == evt.getState();
 548 
 549             switch (playerState) {
 550                 case READY:
 551                     onNativeInit();
 552                     sendFakeBufferProgressEvent();
 553                     break;
 554                 case PLAYING:
 555                     isMediaPulseEnabled.set(true);
 556                     break;
 557                 case STOPPED:
 558                 case FINISHED:
 559                     // Force a time update here to catch the time going to
 560                     // zero for STOPPED and any trailing markers for FINISHED.
 561                     doMediaPulseTask();
 562                 case PAUSED:
 563                 case STALLED:
 564                 case HALTED:
 565                     isMediaPulseEnabled.set(false);
 566                     break;
 567                 default:
 568                     break;
 569             }
 570 
 571             synchronized (cachedStateEvents) {
 572                 if (playerStateListeners.isEmpty()) {
 573                     // Cache event for processing when first listener registers.
 574                     cachedStateEvents.add(evt);
 575                     return;
 576                 }
 577             }
 578 
 579             for (ListIterator&lt;WeakReference&lt;PlayerStateListener&gt;&gt; it = playerStateListeners.listIterator(); it.hasNext();) {
 580                 PlayerStateListener listener = it.next().get();
 581                 if (listener != null) {
 582                     switch (playerState) {
 583                         case READY:
 584                             onNativeInit();
 585                             sendFakeBufferProgressEvent();
 586                             listener.onReady(evt);
 587                             break;
 588 
 589                         case PLAYING:
 590                             listener.onPlaying(evt);
 591                             break;
 592 
 593                         case PAUSED:
 594                             listener.onPause(evt);
 595                             break;
 596 
 597                         case STOPPED:
 598                             listener.onStop(evt);
 599                             break;
 600 
 601                         case STALLED:
 602                             listener.onStall(evt);
 603                             break;
 604 
 605                         case FINISHED:
 606                             listener.onFinish(evt);
 607                             break;
 608 
 609                         case HALTED:
 610                             listener.onHalt(evt);
 611                             break;
 612 
 613                         default:
 614                             break;
 615                     }
 616                 } else {
 617                     it.remove();
 618                 }
 619             }
 620         }
 621 
 622         private void HandlePlayerTimeEvents(PlayerTimeEvent evt) {
 623             synchronized (cachedTimeEvents) {
 624                 if (playerTimeListeners.isEmpty()) {
 625                     // Cache event for processing when first listener registers.
 626                     cachedTimeEvents.add(evt);
 627                     return;
 628                 }
 629             }
 630 
 631             for (ListIterator&lt;WeakReference&lt;PlayerTimeListener&gt;&gt; it = playerTimeListeners.listIterator(); it.hasNext();) {
 632                 PlayerTimeListener listener = it.next().get();
 633                 if (listener != null) {
 634                     listener.onDurationChanged(evt.getTime());
 635                 } else {
 636                     it.remove();
 637                 }
 638             }
 639         }
 640 
 641         private void HandleFrameSizeChangedEvents(FrameSizeChangedEvent evt) {
 642             frameWidth = evt.getWidth();
 643             frameHeight = evt.getHeight();
 644             Logger.logMsg(Logger.DEBUG, &quot;** Frame size changed (&quot; + frameWidth + &quot;, &quot; + frameHeight + &quot;)&quot;);
 645             for (ListIterator&lt;WeakReference&lt;VideoTrackSizeListener&gt;&gt; it = videoTrackSizeListeners.listIterator(); it.hasNext();) {
 646                 VideoTrackSizeListener listener = it.next().get();
 647                 if (listener != null) {
 648                     listener.onSizeChanged(frameWidth, frameHeight);
 649                 } else {
 650                     it.remove();
 651                 }
 652             }
 653         }
 654 
 655         private void HandleTrackEvents(TrackEvent evt) {
 656             media.addTrack(evt.getTrack());
 657 
 658             if (evt.getTrack() instanceof VideoTrack) {
 659                 encodedFrameRate = ((VideoTrack) evt.getTrack()).getEncodedFrameRate();
 660             }
 661         }
 662 
 663         private void HandleMarkerEvents(MarkerEvent evt) {
 664             for (ListIterator&lt;WeakReference&lt;MarkerListener&gt;&gt; it = markerListeners.listIterator(); it.hasNext();) {
 665                 MarkerListener listener = it.next().get();
 666                 if (listener != null) {
 667                     listener.onMarker(evt);
 668                 } else {
 669                     it.remove();
 670                 }
 671             }
 672         }
 673 
 674         private void HandleWarningEvents(WarningEvent evt) {
 675             Logger.logMsg(Logger.WARNING, evt.getSource() + evt.getMessage());
 676         }
 677 
 678         private void HandleErrorEvents(MediaErrorEvent evt) {
 679             Logger.logMsg(Logger.ERROR, evt.getMessage());
 680 
 681             synchronized (cachedErrorEvents) {
 682                 if (errorListeners.isEmpty()) {
 683                     // cache error events until at least one listener is added
 684                     cachedErrorEvents.add(evt);
 685                     return;
 686                 }
 687             }
 688 
 689             for (ListIterator&lt;WeakReference&lt;MediaErrorListener&gt;&gt; it = errorListeners.listIterator(); it.hasNext();) {
 690                 MediaErrorListener l = it.next().get();
 691                 if (l != null) {
 692                     l.onError(evt.getSource(), evt.getErrorCode(), evt.getMessage());
 693                 } else {
 694                     it.remove();
 695                 }
 696             }
 697         }
 698 
 699         private void HandleBufferEvents(BufferProgressEvent evt) {
 700             synchronized (cachedBufferEvents) {
 701                 if (bufferListeners.isEmpty()) {
 702                     // Cache event for processing when first listener registers.
 703                     cachedBufferEvents.add(evt);
 704                     return;
 705                 }
 706             }
 707 
 708             for (ListIterator&lt;WeakReference&lt;BufferListener&gt;&gt; it = bufferListeners.listIterator(); it.hasNext();) {
 709                 BufferListener listener = it.next().get();
 710                 if (listener != null) {
 711                     listener.onBufferProgress(evt);
 712                 } else {
 713                     it.remove();
 714                 }
 715             }
 716         }
 717 
 718         private void HandleAudioSpectrumEvents(AudioSpectrumEvent evt) {
 719             for (ListIterator&lt;WeakReference&lt;AudioSpectrumListener&gt;&gt; it = audioSpectrumListeners.listIterator(); it.hasNext();) {
 720                 AudioSpectrumListener listener = it.next().get();
 721                 if (listener != null) {
<a name="2" id="anc2"></a><span class="line-added"> 722                     if (evt.queryTimestamp()) {</span>
<span class="line-added"> 723                         double timestamp = playerGetPresentationTime();</span>
<span class="line-added"> 724                         evt.setTimestamp(timestamp);</span>
<span class="line-added"> 725                     }</span>
<span class="line-added"> 726 </span>
 727                     listener.onAudioSpectrumEvent(evt);
 728                 } else {
 729                     it.remove();
 730                 }
 731             }
 732         }
 733 
 734         /**
 735          * Puts an event to the EventQuery.
 736          */
 737         public void postEvent(PlayerEvent event) {
 738             if (eventQueue != null) {
 739                 eventQueue.offer(event);
 740             }
 741         }
 742 
 743         /**
 744          * Signals the thread to terminate.
 745          */
 746         public void terminateLoop() {
 747             stopped = true;
 748             // put an event to unblock eventQueue.take()
 749             try {
 750                 eventQueue.put(new PlayerEvent());
 751             } catch(InterruptedException ex) {}
 752         }
 753 
 754         private void sendFakeBufferProgressEvent() {
 755             // Send fake 100% buffer progress event for HLS or !http protcol
 756             String contentType = media.getLocator().getContentType();
 757             String protocol = media.getLocator().getProtocol();
 758             if ((contentType != null &amp;&amp; (contentType.equals(MediaUtils.CONTENT_TYPE_M3U) || contentType.equals(MediaUtils.CONTENT_TYPE_M3U8)))
 759                     || (protocol != null &amp;&amp; !protocol.equals(&quot;http&quot;) &amp;&amp; !protocol.equals(&quot;https&quot;))) {
 760                 HandleBufferEvents(new BufferProgressEvent(getDuration(), 0, 1, 1));
 761             }
 762         }
 763     }
 764 
 765     /**
 766      * Internal function to get called when the native player is ready.
 767      */
 768     private synchronized void onNativeInit() {
 769         try {
 770             playerInit();
 771         } catch (MediaException me) {
 772             sendPlayerMediaErrorEvent(me.getMediaError().code());
 773         }
 774     }
 775 
 776     //**************************************************************************
 777     //***** MediaPlayer implementation
 778     //**************************************************************************
 779     //***** Listener (un)registration.
 780     @Override
 781     public void addMediaErrorListener(MediaErrorListener listener) {
 782         if (listener != null) {
 783             this.errorListeners.add(new WeakReference&lt;&gt;(listener));
 784 
 785             synchronized (cachedErrorEvents) {
 786                 if (!cachedErrorEvents.isEmpty() &amp;&amp; !errorListeners.isEmpty()) {
 787                     cachedErrorEvents.stream().forEach((evt) -&gt; {
 788                         sendPlayerEvent(evt);
 789                     });
 790                     cachedErrorEvents.clear();
 791                 }
 792             }
 793         }
 794     }
 795 
 796     @Override
 797     public void removeMediaErrorListener(MediaErrorListener listener) {
 798         if (listener != null) {
 799             for (ListIterator&lt;WeakReference&lt;MediaErrorListener&gt;&gt; it = errorListeners.listIterator(); it.hasNext();) {
 800                 MediaErrorListener l = it.next().get();
 801                 if (l == null || l == listener) {
 802                     it.remove();
 803                 }
 804             }
 805         }
 806     }
 807 
 808     @Override
 809     public void addMediaPlayerListener(PlayerStateListener listener) {
 810         if (listener != null) {
 811             synchronized (cachedStateEvents) {
 812                 if (!cachedStateEvents.isEmpty() &amp;&amp; playerStateListeners.isEmpty()) {
 813                     // Forward all cached state events to first listener to register.
 814                     Iterator&lt;PlayerStateEvent&gt; events = cachedStateEvents.iterator();
 815                     while (events.hasNext()) {
 816                         PlayerStateEvent evt = events.next();
 817                         switch (evt.getState()) {
 818                             case READY:
 819                                 listener.onReady(evt);
 820                                 break;
 821                             case PLAYING:
 822                                 listener.onPlaying(evt);
 823                                 break;
 824                             case PAUSED:
 825                                 listener.onPause(evt);
 826                                 break;
 827                             case STOPPED:
 828                                 listener.onStop(evt);
 829                                 break;
 830                             case STALLED:
 831                                 listener.onStall(evt);
 832                                 break;
 833                             case FINISHED:
 834                                 listener.onFinish(evt);
 835                                 break;
 836                             case HALTED:
 837                                 listener.onHalt(evt);
 838                                 break;
 839                             default:
 840                                 break;
 841                         }
 842                     }
 843 
 844                     // Clear state event cache.
 845                     cachedStateEvents.clear();
 846                 }
 847 
 848                 playerStateListeners.add(new WeakReference(listener));
 849             }
 850         }
 851     }
 852 
 853     @Override
 854     public void removeMediaPlayerListener(PlayerStateListener listener) {
 855         if (listener != null) {
 856             for (ListIterator&lt;WeakReference&lt;PlayerStateListener&gt;&gt; it = playerStateListeners.listIterator(); it.hasNext();) {
 857                 PlayerStateListener l = it.next().get();
 858                 if (l == null || l == listener) {
 859                     it.remove();
 860                 }
 861             }
 862         }
 863     }
 864 
 865     @Override
 866     public void addMediaTimeListener(PlayerTimeListener listener) {
 867         if (listener != null) {
 868             synchronized (cachedTimeEvents) {
 869                 if (!cachedTimeEvents.isEmpty() &amp;&amp; playerTimeListeners.isEmpty()) {
 870                     // Forward all cached time events to first listener to register.
 871                     Iterator&lt;PlayerTimeEvent&gt; events = cachedTimeEvents.iterator();
 872                     while (events.hasNext()) {
 873                         PlayerTimeEvent evt = events.next();
 874                         listener.onDurationChanged(evt.getTime());
 875                     }
 876 
 877                     // Clear time event cache.
 878                     cachedTimeEvents.clear();
 879                 } else {
 880                     // Let listener to know about duration
 881                     double duration = getDuration();
 882                     if (duration != Double.POSITIVE_INFINITY) {
 883                         listener.onDurationChanged(duration);
 884                     }
 885                 }
 886 
 887                 playerTimeListeners.add(new WeakReference(listener));
 888             }
 889         }
 890     }
 891 
 892     @Override
 893     public void removeMediaTimeListener(PlayerTimeListener listener) {
 894         if (listener != null) {
 895             for (ListIterator&lt;WeakReference&lt;PlayerTimeListener&gt;&gt; it = playerTimeListeners.listIterator(); it.hasNext();) {
 896                 PlayerTimeListener l = it.next().get();
 897                 if (l == null || l == listener) {
 898                     it.remove();
 899                 }
 900             }
 901         }
 902     }
 903 
 904     @Override
 905     public void addVideoTrackSizeListener(VideoTrackSizeListener listener) {
 906         if (listener != null) {
 907             if (frameWidth != -1 &amp;&amp; frameHeight != -1) {
 908                 listener.onSizeChanged(frameWidth, frameHeight);
 909             }
 910             videoTrackSizeListeners.add(new WeakReference(listener));
 911         }
 912     }
 913 
 914     @Override
 915     public void removeVideoTrackSizeListener(VideoTrackSizeListener listener) {
 916         if (listener != null) {
 917             for (ListIterator&lt;WeakReference&lt;VideoTrackSizeListener&gt;&gt; it = videoTrackSizeListeners.listIterator(); it.hasNext();) {
 918                 VideoTrackSizeListener l = it.next().get();
 919                 if (l == null || l == listener) {
 920                     it.remove();
 921                 }
 922             }
 923         }
 924     }
 925 
 926     @Override
 927     public void addMarkerListener(MarkerListener listener) {
 928         if (listener != null) {
 929             markerListeners.add(new WeakReference(listener));
 930         }
 931     }
 932 
 933     @Override
 934     public void removeMarkerListener(MarkerListener listener) {
 935         if (listener != null) {
 936             for (ListIterator&lt;WeakReference&lt;MarkerListener&gt;&gt; it = markerListeners.listIterator(); it.hasNext();) {
 937                 MarkerListener l = it.next().get();
 938                 if (l == null || l == listener) {
 939                     it.remove();
 940                 }
 941             }
 942         }
 943     }
 944 
 945     @Override
 946     public void addBufferListener(BufferListener listener) {
 947         if (listener != null) {
 948             synchronized (cachedBufferEvents) {
 949                 if (!cachedBufferEvents.isEmpty() &amp;&amp; bufferListeners.isEmpty()) {
 950                     cachedBufferEvents.stream().forEach((evt) -&gt; {
 951                         listener.onBufferProgress(evt);
 952                     });
 953                     // Clear buffer event cache.
 954                     cachedBufferEvents.clear();
 955                 }
 956 
 957                 bufferListeners.add(new WeakReference(listener));
 958             }
 959         }
 960     }
 961 
 962     @Override
 963     public void removeBufferListener(BufferListener listener) {
 964         if (listener != null) {
 965             for (ListIterator&lt;WeakReference&lt;BufferListener&gt;&gt; it = bufferListeners.listIterator(); it.hasNext();) {
 966                 BufferListener l = it.next().get();
 967                 if (l == null || l == listener) {
 968                     it.remove();
 969                 }
 970             }
 971         }
 972     }
 973 
 974     @Override
 975     public void addAudioSpectrumListener(AudioSpectrumListener listener) {
 976         if (listener != null) {
 977             audioSpectrumListeners.add(new WeakReference(listener));
 978         }
 979     }
 980 
 981     @Override
 982     public void removeAudioSpectrumListener(AudioSpectrumListener listener) {
 983         if (listener != null) {
 984             for (ListIterator&lt;WeakReference&lt;AudioSpectrumListener&gt;&gt; it = audioSpectrumListeners.listIterator(); it.hasNext();) {
 985                 AudioSpectrumListener l = it.next().get();
 986                 if (l == null || l == listener) {
 987                     it.remove();
 988                 }
 989             }
 990         }
 991     }
 992 
 993     //***** Control functions
 994     @Override
 995     public VideoRenderControl getVideoRenderControl() {
 996         return videoRenderControl;
 997     }
 998 
 999     @Override
1000     public Media getMedia() {
1001         return media;
1002     }
1003 
1004     @Override
1005     public void setAudioSyncDelay(long delay) {
1006         try {
1007             playerSetAudioSyncDelay(delay);
1008         } catch (MediaException me) {
1009             sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1010         }
1011     }
1012 
1013     @Override
1014     public long getAudioSyncDelay() {
1015         try {
1016             return playerGetAudioSyncDelay();
1017         } catch (MediaException me) {
1018             sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1019         }
1020         return 0;
1021     }
1022 
1023     @Override
1024     public void play() {
1025         try {
1026             if (isStartTimeUpdated) {
1027                 playerSeek(startTime);
1028             }
1029             isMediaPulseEnabled.set(true);
1030             playerPlay();
1031         } catch (MediaException me) {
1032             sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1033         }
1034     }
1035 
1036     @Override
1037     public void stop() {
1038         try {
1039             playerStop();
1040             playerSeek(startTime);
1041         } catch (MediaException me) {
1042 //            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1043             MediaUtils.warning(this, &quot;stop() failed!&quot;);
1044         }
1045     }
1046 
1047     @Override
1048     public void pause() {
1049         try {
1050             playerPause();
1051         } catch (MediaException me) {
1052             sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1053         }
1054     }
1055 
1056     @Override
1057     public float getRate() {
1058         try {
1059             return playerGetRate();
1060         } catch (MediaException me) {
1061             sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1062         }
1063         return 0;
1064     }
1065 
1066     //***** Public properties
1067     @Override
1068     public void setRate(float rate) {
1069         try {
1070             playerSetRate(rate);
1071         } catch (MediaException me) {
1072 //            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1073             MediaUtils.warning(this, &quot;setRate(&quot; + rate + &quot;) failed!&quot;);
1074         }
1075     }
1076 
1077     @Override
1078     public double getPresentationTime() {
1079         try {
1080             return playerGetPresentationTime();
1081         } catch (MediaException me) {
1082 //            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1083         }
1084         return -1.0;
1085     }
1086 
1087     @Override
1088     public float getVolume() {
1089         try {
1090             return playerGetVolume();
1091         } catch (MediaException me) {
1092             sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1093         }
1094         return 0;
1095     }
1096 
1097     @Override
1098     public void setVolume(float vol) {
1099         if (vol &lt; 0.0F) {
1100             vol = 0.0F;
1101         } else if (vol &gt; 1.0F) {
1102             vol = 1.0F;
1103         }
1104 
1105         try {
1106             playerSetVolume(vol);
1107         } catch (MediaException me) {
1108             sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1109         }
1110     }
1111 
1112     @Override
1113     public boolean getMute() {
1114         try {
1115             return playerGetMute();
1116         } catch (MediaException me) {
1117             sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1118         }
1119         return false;
1120     }
1121 
1122     /**
1123      * Enables/disable mute. If mute is enabled then disabled, the previous
1124      * volume goes into effect.
1125      */
1126     @Override
1127     public void setMute(boolean enable) {
1128         try {
1129             playerSetMute(enable);
1130         } catch (MediaException me) {
1131             sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1132         }
1133     }
1134 
1135     @Override
1136     public float getBalance() {
1137         try {
1138             return playerGetBalance();
1139         } catch (MediaException me) {
1140             sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1141         }
1142         return 0;
1143     }
1144 
1145     @Override
1146     public void setBalance(float bal) {
1147         if (bal &lt; -1.0F) {
1148             bal = -1.0F;
1149         } else if (bal &gt; 1.0F) {
1150             bal = 1.0F;
1151         }
1152 
1153         try {
1154             playerSetBalance(bal);
1155         } catch (MediaException me) {
1156             sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1157         }
1158     }
1159 
1160     @Override
1161     public abstract AudioEqualizer getEqualizer();
1162 
1163     @Override
1164     public abstract AudioSpectrum getAudioSpectrum();
1165 
1166     @Override
1167     public double getDuration() {
1168         try {
1169             return playerGetDuration();
1170         } catch (MediaException me) {
1171 //            sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1172         }
1173         return Double.POSITIVE_INFINITY;
1174     }
1175 
1176     /**
1177      * Gets the time within the duration of the media to start playing.
1178      */
1179     @Override
1180     public double getStartTime() {
1181         return startTime;
1182     }
1183 
1184     /**
1185      * Sets the start time within the media to play.
1186      */
1187     @Override
1188     public void setStartTime(double startTime) {
1189         try {
1190             markerLock.lock();
1191             this.startTime = startTime;
1192             if (playerState != PlayerState.PLAYING &amp;&amp; playerState != PlayerState.FINISHED &amp;&amp; playerState != PlayerState.STOPPED) {
1193                 playerSeek(startTime);
1194             } else if (playerState == PlayerState.STOPPED) {
1195                 isStartTimeUpdated = true;
1196             }
1197         } finally {
1198             markerLock.unlock();
1199         }
1200     }
1201 
1202     /**
1203      * Gets the time within the duration of the media to stop playing.
1204      */
1205     @Override
1206     public double getStopTime() {
1207         return stopTime;
1208     }
1209 
1210     /**
1211      * Sets the stop time within the media to stop playback.
1212      */
1213     @Override
1214     public void setStopTime(double stopTime) {
1215         try {
1216             markerLock.lock();
1217             this.stopTime = stopTime;
1218             isStopTimeSet = true;
1219             createMediaPulse();
1220         } finally {
1221             markerLock.unlock();
1222         }
1223     }
1224 
1225     @Override
1226     public void seek(double streamTime) {
1227         if (playerState == PlayerState.STOPPED) {
1228             return; // No seek in stopped state
1229         }
1230 
1231         if (streamTime &lt; 0.0) {
1232             streamTime = 0.0;
1233         } else {
1234             double duration = getDuration();
1235             if (duration &gt;= 0.0 &amp;&amp; streamTime &gt; duration) {
1236                 streamTime = duration;
1237             }
1238         }
1239 
1240         if (!isMediaPulseEnabled.get()) {
1241             if ((playerState == PlayerState.PLAYING
1242                     || playerState == PlayerState.PAUSED
1243                     || playerState == PlayerState.FINISHED)
1244                     &amp;&amp; getStartTime() &lt;= streamTime &amp;&amp; streamTime &lt;= getStopTime()) {
1245                 isMediaPulseEnabled.set(true);
1246             }
1247         }
1248 
1249         markerLock.lock();
1250         try {
1251             timeBeforeSeek = getPresentationTime();
1252             timeAfterSeek = streamTime;
1253             checkSeek = timeBeforeSeek != timeAfterSeek;
1254             previousTime = streamTime;
1255             firedMarkerTime = -1.0;
1256 //            System.out.println(&quot;seek @ &quot;+System.currentTimeMillis());
1257 //            System.out.println(&quot;seek to &quot;+streamTime+&quot; previousTime &quot;+previousTime);
1258 
1259             try {
1260                 playerSeek(streamTime);
1261             } catch (MediaException me) {
1262                 //sendPlayerEvent(new MediaErrorEvent(this, me.getMediaError()));
1263                 MediaUtils.warning(this, &quot;seek(&quot; + streamTime + &quot;) failed!&quot;);
1264             }
1265         } finally {
1266             markerLock.unlock();
1267         }
1268     }
1269 
1270     protected abstract long playerGetAudioSyncDelay() throws MediaException;
1271 
1272     protected abstract void playerSetAudioSyncDelay(long delay) throws MediaException;
1273 
1274     protected abstract void playerPlay() throws MediaException;
1275 
1276     protected abstract void playerStop() throws MediaException;
1277 
1278     protected abstract void playerPause() throws MediaException;
1279 
1280     protected abstract void playerFinish() throws MediaException;
1281 
1282     protected abstract float playerGetRate() throws MediaException;
1283 
1284     protected abstract void playerSetRate(float rate) throws MediaException;
1285 
1286     protected abstract double playerGetPresentationTime() throws MediaException;
1287 
1288     protected abstract boolean playerGetMute() throws MediaException;
1289 
1290     protected abstract void playerSetMute(boolean state) throws MediaException;
1291 
1292     protected abstract float playerGetVolume() throws MediaException;
1293 
1294     protected abstract void playerSetVolume(float volume) throws MediaException;
1295 
1296     protected abstract float playerGetBalance() throws MediaException;
1297 
1298     protected abstract void playerSetBalance(float balance) throws MediaException;
1299 
1300     protected abstract double playerGetDuration() throws MediaException;
1301 
1302     protected abstract void playerSeek(double streamTime) throws MediaException;
1303 
1304     protected abstract void playerInit() throws MediaException;
1305 
1306     protected abstract void playerDispose();
1307 
1308     /**
1309      * Retrieves the current {@link PlayerState state} of the player.
1310      *
1311      * @return the current player state.
1312      */
1313     @Override
1314     public PlayerState getState() {
1315         return playerState;
1316     }
1317 
1318     @Override
1319     final public void dispose() {
1320         disposeLock.lock();
1321         try {
1322             if (!isDisposed) {
1323                 // Terminate event firing
1324                 destroyMediaPulse();
1325 
1326                 if (eventLoop != null) {
1327                     eventLoop.terminateLoop();
1328                     eventLoop = null;
1329                 }
1330 
1331                 synchronized (firstFrameLock) {
1332                     if (firstFrameEvent != null) {
1333                         firstFrameEvent.getFrameData().releaseFrame();
1334                         firstFrameEvent = null;
1335                     }
1336                 }
1337 
1338                 // Terminate native layer
1339                 playerDispose();
1340 
1341                 // Dispose media object and clear reference
1342                 if (media != null) {
1343                     media.dispose();
1344                     media = null;
1345                 }
1346 
1347                 if (videoUpdateListeners != null) {
1348                     for (ListIterator&lt;WeakReference&lt;VideoRendererListener&gt;&gt; it = videoUpdateListeners.listIterator(); it.hasNext();) {
1349                         VideoRendererListener l = it.next().get();
1350                         if (l != null) {
1351                             l.releaseVideoFrames();
1352                         } else {
1353                             it.remove();
1354                         }
1355                     }
1356 
1357                     videoUpdateListeners.clear();
1358                 }
1359 
1360                 if (playerStateListeners != null) {
1361                     playerStateListeners.clear();
1362                 }
1363 
1364                 if (videoTrackSizeListeners != null) {
1365                     videoTrackSizeListeners.clear();
1366                 }
1367 
1368                 if (videoFrameRateListeners != null) {
1369                     videoFrameRateListeners.clear();
1370                 }
1371 
1372                 if (cachedStateEvents != null) {
1373                     cachedStateEvents.clear();
1374                 }
1375 
1376                 if (cachedTimeEvents != null) {
1377                     cachedTimeEvents.clear();
1378                 }
1379 
1380                 if (cachedBufferEvents != null) {
1381                     cachedBufferEvents.clear();
1382                 }
1383 
1384                 if (errorListeners != null) {
1385                     errorListeners.clear();
1386                 }
1387 
1388                 if (playerTimeListeners != null) {
1389                     playerTimeListeners.clear();
1390                 }
1391 
1392                 if (markerListeners != null) {
1393                     markerListeners.clear();
1394                 }
1395 
1396                 if (bufferListeners != null) {
1397                     bufferListeners.clear();
1398                 }
1399 
1400                 if (audioSpectrumListeners != null) {
1401                     audioSpectrumListeners.clear();
1402                 }
1403 
1404                 if (videoRenderControl != null) {
1405                     videoRenderControl = null;
1406                 }
1407 
1408                 if (onDispose != null) {
1409                     onDispose.run();
1410                 }
1411 
1412                 isDisposed = true;
1413             }
1414         } finally {
1415             disposeLock.unlock();
1416         }
1417     }
1418 
1419     @Override
1420     public boolean isErrorEventCached() {
1421         synchronized (cachedErrorEvents) {
1422             if (cachedErrorEvents.isEmpty()) {
1423                 return false;
1424             } else {
1425                 return true;
1426             }
1427         }
1428     }
1429 
1430     //**************************************************************************
1431     //***** Non-JNI methods called by the native layer. These methods are called
1432     //***** from the native layer via the invocation API. Their purpose is to
1433     //***** dispatch certain events to the Java layer. Each of these methods
1434     //***** posts an event on the &lt;code&gt;EventQueueThread&lt;/code&gt; which in turn
1435     //***** forwards the event to any registered listeners.
1436     //**************************************************************************
1437     protected void sendWarning(int warningCode, String warningMessage) {
1438         if (eventLoop != null) {
1439             String message = String.format(MediaUtils.NATIVE_MEDIA_WARNING_FORMAT,
1440                     warningCode);
1441             if (warningMessage != null) {
1442                 message += &quot;: &quot; + warningMessage;
1443             }
1444             eventLoop.postEvent(new WarningEvent(this, message));
1445         }
1446     }
1447 
1448     protected void sendPlayerEvent(PlayerEvent evt) {
1449         if (eventLoop != null) {
1450             eventLoop.postEvent(evt);
1451         }
1452     }
1453 
1454     protected void sendPlayerHaltEvent(String message, double time) {
1455         // Log the error.  Since these are most likely playback engine message (e.g. GStreamer or PacketVideo),
1456         // it makes no sense to propogate it above.
1457         Logger.logMsg(Logger.ERROR, message);
1458 
1459         if (eventLoop != null) {
1460             eventLoop.postEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.HALTED, time, message));
1461         }
1462     }
1463 
1464     protected void sendPlayerMediaErrorEvent(int errorCode) {
1465         sendPlayerEvent(new MediaErrorEvent(this, MediaError.getFromCode(errorCode)));
1466     }
1467 
1468     protected void sendPlayerStateEvent(int eventID, double time) {
1469         switch (eventID) {
1470             case eventPlayerReady:
1471                 sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.READY, time));
1472                 break;
1473             case eventPlayerPlaying:
1474                 sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.PLAYING, time));
1475                 break;
1476             case eventPlayerPaused:
1477                 sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.PAUSED, time));
1478                 break;
1479             case eventPlayerStopped:
1480                 sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.STOPPED, time));
1481                 break;
1482             case eventPlayerStalled:
1483                 sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.STALLED, time));
1484                 break;
1485             case eventPlayerFinished:
1486                 sendPlayerEvent(new PlayerStateEvent(PlayerStateEvent.PlayerState.FINISHED, time));
1487                 break;
1488             default:
1489                 break;
1490         }
1491     }
1492 
1493     protected void sendNewFrameEvent(long nativeRef) {
1494         NativeVideoBuffer newFrameData = NativeVideoBuffer.createVideoBuffer(nativeRef);
1495         // createVideoBuffer puts a hold on the frame
1496         // we need to keep that hold until the event thread can process this event
1497         sendPlayerEvent(new NewFrameEvent(newFrameData));
1498     }
1499 
1500     protected void sendFrameSizeChangedEvent(int width, int height) {
1501         sendPlayerEvent(new FrameSizeChangedEvent(width, height));
1502     }
1503 
1504     protected void sendAudioTrack(boolean enabled, long trackID, String name, int encoding,
1505             String language, int numChannels,
1506             int channelMask, float sampleRate) {
1507         Locale locale = null;
1508         if (!language.equals(&quot;und&quot;)) {
1509             locale = new Locale(language);
1510         }
1511 
1512         Track track = new AudioTrack(enabled, trackID, name,
1513                 locale, Encoding.toEncoding(encoding),
1514                 numChannels, channelMask, sampleRate);
1515 
1516         TrackEvent evt = new TrackEvent(track);
1517 
1518         sendPlayerEvent(evt);
1519     }
1520 
1521     protected void sendVideoTrack(boolean enabled, long trackID, String name, int encoding,
1522             int width, int height, float frameRate,
1523             boolean hasAlphaChannel) {
1524         // No locale (currently) for video, so pass null
1525         Track track = new VideoTrack(enabled, trackID, name, null,
1526                 Encoding.toEncoding(encoding),
1527                 new VideoResolution(width, height), frameRate, hasAlphaChannel);
1528 
1529         TrackEvent evt = new TrackEvent(track);
1530 
1531         sendPlayerEvent(evt);
1532     }
1533 
1534     protected void sendSubtitleTrack(boolean enabled, long trackID, String name,
1535             int encoding, String language)
1536     {
1537         Locale locale = null;
1538         if (null != language) {
1539             locale = new Locale(language);
1540         }
1541         Track track = new SubtitleTrack(enabled, trackID, name, locale,
1542                 Encoding.toEncoding(encoding));
1543 
1544         sendPlayerEvent(new TrackEvent(track));
1545     }
1546 
1547     protected void sendMarkerEvent(String name, double time) {
1548         sendPlayerEvent(new MarkerEvent(name, time));
1549     }
1550 
1551     protected void sendDurationUpdateEvent(double duration) {
1552         sendPlayerEvent(new PlayerTimeEvent(duration));
1553     }
1554 
1555     protected void sendBufferProgressEvent(double clipDuration, long bufferStart, long bufferStop, long bufferPosition) {
1556         sendPlayerEvent(new BufferProgressEvent(clipDuration, bufferStart, bufferStop, bufferPosition));
1557     }
1558 
<a name="3" id="anc3"></a><span class="line-modified">1559     protected void sendAudioSpectrumEvent(double timestamp, double duration, boolean queryTimestamp) {</span>
<span class="line-modified">1560         sendPlayerEvent(new AudioSpectrumEvent(getAudioSpectrum(), timestamp, duration, queryTimestamp));</span>
1561     }
1562 
1563     @Override
1564     public void markerStateChanged(boolean hasMarkers) {
1565         if (hasMarkers) {
1566             markerLock.lock();
1567             try {
1568                 previousTime = getPresentationTime();
1569             } finally {
1570                 markerLock.unlock();
1571             }
1572             createMediaPulse();
1573         } else {
1574             if (!isStopTimeSet) {
1575                 destroyMediaPulse();
1576             }
1577         }
1578     }
1579 
1580     private void createMediaPulse() {
1581         mediaPulseLock.lock();
1582         try {
1583             if (mediaPulseTimer == null) {
1584                 mediaPulseTimer = new Timer(true);
1585                 mediaPulseTimer.scheduleAtFixedRate(new MediaPulseTask(this), 0, 40 /*
1586                          * period ms
1587                          */);
1588             }
1589         } finally {
1590             mediaPulseLock.unlock();
1591         }
1592     }
1593 
1594     private void destroyMediaPulse() {
1595         mediaPulseLock.lock();
1596         try {
1597             if (mediaPulseTimer != null) {
1598                 mediaPulseTimer.cancel();
1599                 mediaPulseTimer = null;
1600             }
1601         } finally {
1602             mediaPulseLock.unlock();
1603         }
1604     }
1605 
1606     boolean doMediaPulseTask() {
1607         if (this.isMediaPulseEnabled.get()) {
1608             disposeLock.lock();
1609 
1610             if (isDisposed) {
1611                 disposeLock.unlock();
1612                 return false;
1613             }
1614 
1615             double thisTime = getPresentationTime();
1616 
1617             markerLock.lock();
1618 
1619             try {
1620                 //System.out.println(&quot;Media pulse @ pts &quot;+thisTime+&quot; previous &quot;+previousTime);
1621 
1622                 if (checkSeek) {
1623                     if (timeAfterSeek &gt; timeBeforeSeek) {
1624                         // Forward seek
1625                         if (thisTime &gt;= timeAfterSeek) {
1626 //                        System.out.println(&quot;bail 1&quot;);
1627                             checkSeek = false;
1628                         } else {
1629                             return true;
1630                         }
1631                     } else if (timeAfterSeek &lt; timeBeforeSeek) {
1632                         // Backward seek
1633                         if (thisTime &gt;= timeBeforeSeek) {
1634 //                        System.out.println(&quot;bail 2&quot;);
1635                             return true;
1636                         } else {
1637                             checkSeek = false;
1638                         }
1639                     }
1640                 }
1641 
1642                 Map.Entry&lt;Double, String&gt; marker = media.getNextMarker(previousTime, true);
1643 //                System.out.println(&quot;marker &quot;+marker);
1644 //                System.out.println(&quot;Checking: &quot; + previousTime + &quot; &quot; + thisTime + &quot; &quot;
1645 //                        + getStartTime() + &quot; &quot; + getStopTime() + &quot; &quot;
1646 //                        + marker.getKey());
1647 
1648                 while (marker != null) {
1649                     double nextMarkerTime = marker.getKey();
1650                     if (nextMarkerTime &gt; thisTime) {
1651                         break;
1652                     } else if (nextMarkerTime != firedMarkerTime
1653                             &amp;&amp; nextMarkerTime &gt;= previousTime
1654                             &amp;&amp; nextMarkerTime &gt;= getStartTime()
1655                             &amp;&amp; nextMarkerTime &lt;= getStopTime()) {
1656 //                            System.out.println(&quot;Firing: &quot;+previousTime+&quot; &quot;+thisTime+&quot; &quot;+
1657 //                                    getStartTime()+&quot; &quot;+getStopTime()+&quot; &quot;+
1658 //                                    nextMarkerTime);
1659                         MarkerEvent evt = new MarkerEvent(marker.getValue(), nextMarkerTime);
1660                         for (ListIterator&lt;WeakReference&lt;MarkerListener&gt;&gt; it = markerListeners.listIterator(); it.hasNext();) {
1661                             MarkerListener listener = it.next().get();
1662                             if (listener != null) {
1663                                 listener.onMarker(evt);
1664                             } else {
1665                                 it.remove();
1666                             }
1667                         }
1668                         firedMarkerTime = nextMarkerTime;
1669                     }
1670                     marker = media.getNextMarker(nextMarkerTime, false);
1671                 }
1672 
1673                 previousTime = thisTime;
1674 
1675                 // Do stopTime
1676                 if (isStopTimeSet &amp;&amp; thisTime &gt;= stopTime) {
1677                     playerFinish();
1678                 }
1679             } finally {
1680                 disposeLock.unlock();
1681                 markerLock.unlock();
1682             }
1683         }
1684 
1685         return true;
1686     }
1687 
1688     /* Audio EQ and spectrum creation, used by sub-classes */
1689     protected AudioEqualizer createNativeAudioEqualizer(long nativeRef) {
1690         return new NativeAudioEqualizer(nativeRef);
1691     }
1692 
1693     protected AudioSpectrum createNativeAudioSpectrum(long nativeRef) {
1694         return new NativeAudioSpectrum(nativeRef);
1695     }
1696 }
1697 
1698 class MediaPulseTask extends TimerTask {
1699 
1700     WeakReference&lt;NativeMediaPlayer&gt; playerRef;
1701 
1702     MediaPulseTask(NativeMediaPlayer player) {
1703         playerRef = new WeakReference&lt;&gt;(player);
1704     }
1705 
1706     @Override
1707     public void run() {
1708         final NativeMediaPlayer player = playerRef.get();
1709         if (player != null) {
1710             if (!player.doMediaPulseTask()) {
1711                 cancel(); // Stop if doMediaPulseTask() returns false. False means doMediaPulseTask() cannot continue (like after dispose).cy
1712             }
1713         } else {
1714             cancel();
1715         }
1716     }
1717 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
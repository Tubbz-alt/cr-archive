<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/ios/java/com/sun/javafx/scene/web/HTMLEditorSkin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.web;
  27 
  28 import java.util.ResourceBundle;
  29 import com.sun.javafx.scene.ParentHelper;
  30 import com.sun.javafx.application.PlatformImpl;
  31 import com.sun.javafx.scene.traversal.Algorithm;
  32 import com.sun.javafx.scene.traversal.Direction;
  33 import com.sun.javafx.scene.traversal.ParentTraversalEngine;
  34 import com.sun.javafx.scene.traversal.TraversalContext;
  35 import javafx.geometry.Orientation;
  36 import org.w3c.dom.html.HTMLDocument;
  37 import org.w3c.dom.html.HTMLElement;
  38 
  39 import javafx.application.ConditionalFeature;
  40 import javafx.application.Platform;
  41 import javafx.beans.value.ChangeListener;
  42 import javafx.beans.value.ObservableValue;
  43 import javafx.collections.FXCollections;
  44 import javafx.collections.ObservableList;
  45 import javafx.css.StyleableProperty;
  46 import javafx.event.ActionEvent;
  47 import javafx.event.EventHandler;
  48 import javafx.geometry.Bounds;
  49 import javafx.geometry.NodeOrientation;
  50 import javafx.scene.Node;
  51 import javafx.scene.control.Button;
  52 import javafx.scene.control.ComboBox;
  53 import javafx.scene.control.ListCell;
  54 import javafx.scene.control.ListView;
  55 import javafx.scene.control.Separator;
  56 import javafx.scene.control.TextInputControl;
  57 import javafx.scene.control.ToggleButton;
  58 import javafx.scene.control.ToggleGroup;
  59 import javafx.scene.control.ToolBar;
  60 import javafx.scene.control.Tooltip;
  61 import javafx.scene.image.Image;
  62 import javafx.scene.image.ImageView;
  63 import javafx.scene.input.KeyCode;
  64 import javafx.scene.input.KeyEvent;
  65 import javafx.scene.input.MouseEvent;
  66 import javafx.scene.layout.ColumnConstraints;
  67 import javafx.scene.layout.GridPane;
  68 import javafx.scene.layout.Priority;
  69 import javafx.scene.paint.Color;
  70 import javafx.scene.text.Font;
  71 import javafx.scene.web.HTMLEditor;
  72 import javafx.scene.web.WebView;
  73 import javafx.util.Callback;
  74 
  75 import javafx.scene.control.skin.ColorPickerSkin;
  76 import com.sun.javafx.scene.control.skin.FXVK;
  77 import com.sun.javafx.scene.web.behavior.HTMLEditorBehavior;
  78 import com.sun.javafx.scene.traversal.TraversalEngine;
  79 import com.sun.javafx.scene.traversal.TraverseListener;
  80 
  81 import java.security.AccessController;
  82 import java.security.PrivilegedAction;
  83 
  84 import java.util.HashMap;
  85 import java.util.Locale;
  86 import java.util.Map;
  87 import javafx.scene.Scene;
  88 import javafx.scene.control.*;
  89 import javafx.scene.layout.*;
  90 import javafx.collections.ListChangeListener;
  91 
  92 import static javafx.geometry.NodeOrientation.*;
  93 
  94 import static javafx.scene.web.HTMLEditorSkin.Command.*;
  95 
  96 
  97 /**
  98  * HTML editor skin.
  99  */
 100 public class HTMLEditorSkin extends SkinBase&lt;HTMLEditor&gt; implements TraverseListener {
 101     private GridPane gridPane;
 102 
 103     private ToolBar toolbar1;
 104     private ToolBar toolbar2;
 105 
 106     private Button cutButton;
 107     private Button copyButton;
 108     private Button pasteButton;
 109 
 110 
 111     private Button insertHorizontalRuleButton;
 112 
 113     private ToggleGroup alignmentToggleGroup;
 114     private ToggleButton alignLeftButton;
 115     private ToggleButton alignCenterButton;
 116     private ToggleButton alignRightButton;
 117     private ToggleButton alignJustifyButton;
 118 
 119     private ToggleButton bulletsButton;
 120     private ToggleButton numbersButton;
 121 
 122     private Button indentButton;
 123     private Button outdentButton;
 124 
 125     private ComboBox&lt;String&gt; formatComboBox;
 126     private Map&lt;String, String&gt; formatStyleMap;
 127     private Map&lt;String, String&gt; styleFormatMap;
 128 
 129     private ComboBox&lt;String&gt; fontFamilyComboBox;
 130 
 131     private ComboBox&lt;String&gt; fontSizeComboBox;
 132     private Map&lt;String, String&gt; fontSizeMap;
 133     private Map&lt;String, String&gt; sizeFontMap;
 134 
 135     private ToggleButton boldButton;
 136     private ToggleButton italicButton;
 137     private ToggleButton underlineButton;
 138     private ToggleButton strikethroughButton;
 139 
 140     private ColorPicker fgColorButton;
 141     private ColorPicker bgColorButton;
 142 
 143     private WebView webView;
 144 
 145     private static final String CUT_COMMAND = &quot;cut&quot;;
 146     private static final String COPY_COMMAND = &quot;copy&quot;;
 147     private static final String PASTE_COMMAND = &quot;paste&quot;;
 148 
 149     private static final String UNDO_COMMAND = &quot;undo&quot;;
 150     private static final String REDO_COMMAND = &quot;redo&quot;;
 151 
 152     private static final String INSERT_HORIZONTAL_RULE_COMMAND = &quot;inserthorizontalrule&quot;;
 153 
 154     private static final String ALIGN_LEFT_COMMAND = &quot;justifyleft&quot;;
 155     private static final String ALIGN_CENTER_COMMAND = &quot;justifycenter&quot;;
 156     private static final String ALIGN_RIGHT_COMMAND = &quot;justifyright&quot;;
 157     private static final String ALIGN_JUSTIFY_COMMAND = &quot;justifyfull&quot;;
 158 
 159     private static final String BULLETS_COMMAND = &quot;insertUnorderedList&quot;;
 160     private static final String NUMBERS_COMMAND = &quot;insertOrderedList&quot;;
 161 
 162     private static final String INDENT_COMMAND = &quot;indent&quot;;
 163     private static final String OUTDENT_COMMAND = &quot;outdent&quot;;
 164 
 165     private static final String FORMAT_COMMAND = &quot;formatblock&quot;;
 166     private static final String FONT_FAMILY_COMMAND = &quot;fontname&quot;;
 167     private static final String FONT_SIZE_COMMAND = &quot;fontsize&quot;;
 168 
 169     private static final String BOLD_COMMAND = &quot;bold&quot;;
 170     private static final String ITALIC_COMMAND = &quot;italic&quot;;
 171     private static final String UNDERLINE_COMMAND = &quot;underline&quot;;
 172     private static final String STRIKETHROUGH_COMMAND = &quot;strikethrough&quot;;
 173 
 174     private static final String FOREGROUND_COLOR_COMMAND = &quot;forecolor&quot;;
 175     private static final String BACKGROUND_COLOR_COMMAND = &quot;backcolor&quot;;
 176 
 177     private static final Color DEFAULT_BG_COLOR = Color.WHITE;
 178     private static final Color DEFAULT_FG_COLOR = Color.BLACK;
 179 
 180     private static final String FORMAT_PARAGRAPH = &quot;&lt;p&gt;&quot;;
 181     private static final String FORMAT_HEADING_1 = &quot;&lt;h1&gt;&quot;;
 182     private static final String FORMAT_HEADING_2 = &quot;&lt;h2&gt;&quot;;
 183     private static final String FORMAT_HEADING_3 = &quot;&lt;h3&gt;&quot;;
 184     private static final String FORMAT_HEADING_4 = &quot;&lt;h4&gt;&quot;;
 185     private static final String FORMAT_HEADING_5 = &quot;&lt;h5&gt;&quot;;
 186     private static final String FORMAT_HEADING_6 = &quot;&lt;h6&gt;&quot;;
 187 
 188     private static final String SIZE_XX_SMALL = &quot;1&quot;;
 189     private static final String SIZE_X_SMALL = &quot;2&quot;;
 190     private static final String SIZE_SMALL = &quot;3&quot;;
 191     private static final String SIZE_MEDIUM = &quot;4&quot;;
 192     private static final String SIZE_LARGE = &quot;5&quot;;
 193     private static final String SIZE_X_LARGE = &quot;6&quot;;
 194     private static final String SIZE_XX_LARGE = &quot;7&quot;;
 195 
 196     private static final String INSERT_NEW_LINE_COMMAND = &quot;insertnewline&quot;;
 197     private static final String INSERT_TAB_COMMAND = &quot;inserttab&quot;;
 198 
 199     // As per RT-16330: default format -&gt; bold/size mappings are as follows:
 200     private static final String[][] DEFAULT_FORMAT_MAPPINGS = {
 201         { FORMAT_PARAGRAPH,   &quot;&quot;,             SIZE_SMALL     },
 202         { FORMAT_HEADING_1,   BOLD_COMMAND,   SIZE_X_LARGE   },
 203         { FORMAT_HEADING_2,   BOLD_COMMAND,   SIZE_LARGE     },
 204         { FORMAT_HEADING_3,   BOLD_COMMAND,   SIZE_MEDIUM    },
 205         { FORMAT_HEADING_4,   BOLD_COMMAND,   SIZE_SMALL     },
 206         { FORMAT_HEADING_5,   BOLD_COMMAND,   SIZE_X_SMALL   },
 207         { FORMAT_HEADING_6,   BOLD_COMMAND,   SIZE_XX_SMALL  },
 208     };
 209 
 210     // As per RT-16379: default OS -&gt; font mappings:
 211     private static final String[] DEFAULT_WINDOWS_7_MAPPINGS = {
 212         &quot;Windows 7&quot;,       &quot;Segoe UI&quot;,        &quot;12px&quot;,   &quot;&quot;,     &quot;120&quot;
 213     };
 214     private static final String[][] DEFAULT_OS_MAPPINGS = {
 215         // OS               Font name           size      weight  DPI
 216         { &quot;Windows XP&quot;,      &quot;Tahoma&quot;,          &quot;12px&quot;,   &quot;&quot;,     &quot;96&quot;  },
 217         { &quot;Windows Vista&quot;,   &quot;Segoe UI&quot;,        &quot;12px&quot;,   &quot;&quot;,     &quot;96&quot;  },
 218         DEFAULT_WINDOWS_7_MAPPINGS,
 219         { &quot;Mac OS X&quot;,        &quot;Lucida Grande&quot;,   &quot;12px&quot;,   &quot;&quot;,     &quot;72&quot;  },
 220         { &quot;Linux&quot;,           &quot;Lucida Sans&quot;,   &quot;12px&quot;,   &quot;&quot;,     &quot;96&quot;  },
 221     };
 222     private static final String DEFAULT_OS_FONT = getOSMappings()[1];
 223 
 224     private static final Label IOS_UNSUPPORTED_LABEL =
 225             new Label(&quot;HTML Editor component is not supported on iOS platform&quot;);
 226 
 227     private static String[] getOSMappings() {
 228         String os = System.getProperty(&quot;os.name&quot;);
 229         for  (int i = 0; i &lt; DEFAULT_OS_MAPPINGS.length; i++) {
 230             if (os.equals(DEFAULT_OS_MAPPINGS[i][0])) {
 231                 return DEFAULT_OS_MAPPINGS[i];
 232             }
 233         }
 234 
 235         return DEFAULT_WINDOWS_7_MAPPINGS;
 236     }
 237 
 238     private ParentTraversalEngine engine;
 239 
 240     private boolean resetToolbarState = false;
 241     private String cachedHTMLText = &quot;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;;
 242     private ListChangeListener&lt;Node&gt; itemsListener = new ListChangeListener&lt;Node&gt;() {
 243         @Override public void onChanged(ListChangeListener.Change&lt;? extends Node&gt; c) {
 244 //            while (c.next()) {
 245 //                if (c.getRemovedSize() &gt; 0) {
 246 //                    for (Node n : c.getList()) {
 247 //                        if (n instanceof WebView) {
 248 //                            // RT-28611 webView removed - set associated webPage to null
 249 //                            webPage.dispose();
 250 //                        }
 251 //                    }
 252 //                }
 253 //            }
 254         }
 255     };
 256     public HTMLEditorSkin(HTMLEditor htmlEditor) {
 257         super(htmlEditor);
 258 
 259         getChildren().clear();
 260 
 261         gridPane = new GridPane();
 262         gridPane.getStyleClass().add(&quot;grid&quot;);
 263         getChildren().addAll(gridPane);
 264 
 265         toolbar1 = new ToolBar();
 266         toolbar1.getStyleClass().add(&quot;top-toolbar&quot;);
 267         gridPane.add(toolbar1, 0, 0);
 268 
 269         toolbar2 = new ToolBar();
 270         toolbar2.getStyleClass().add(&quot;bottom-toolbar&quot;);
 271         gridPane.add(toolbar2, 0, 1);
 272 
 273 //        populateToolbars();
 274 
 275         webView = new WebView();
 276         gridPane.add(/*webView*/IOS_UNSUPPORTED_LABEL, 0, 2);
 277 
 278         ColumnConstraints column = new ColumnConstraints();
 279         column.setHgrow(Priority.ALWAYS);
 280         gridPane.getColumnConstraints().add(column);
 281 
 282 //        webPage = Accessor.getPageFor(webView.getEngine());
 283 
 284         webView.addEventHandler(MouseEvent.ANY, new EventHandler&lt;MouseEvent&gt;() {
 285             @Override public void handle(MouseEvent event) {
 286                 Platform.runLater(new Runnable() {
 287                     @Override public void run() {
 288                         updateToolbarState(true);
 289                     }
 290                 });
 291             }
 292         });
 293 
 294 
 295         webView.addEventHandler(KeyEvent.KEY_PRESSED, new EventHandler&lt;KeyEvent&gt;() {
 296             @Override public void handle(final KeyEvent event) {
 297                 applyTextFormatting();
 298                 if (event.getCode() == KeyCode.CONTROL || event.getCode() == KeyCode.META) {
 299                     return;
 300                 }
 301                 if (event.getCode() == KeyCode.TAB &amp;&amp; !event.isControlDown()) {
 302                     if (!event.isShiftDown()) {
 303                         /*
 304                         ** if we are in either Bullet or Numbers mode then the
 305                         ** TAB key tells us to indent again.
 306                         */
 307                         if (getCommandState(BULLETS_COMMAND) || getCommandState(NUMBERS_COMMAND)) {
 308                             executeCommand(INDENT_COMMAND, null);
 309                         }
 310                         else {
 311                             executeCommand(INSERT_TAB_COMMAND, null);
 312                         }
 313                     }
 314                     else {
 315                         /*
 316                         ** if we are in either Bullet or Numbers mode then the
 317                         ** Shift-TAB key tells us to outdent.
 318                         */
 319                         if (getCommandState(BULLETS_COMMAND) || getCommandState(NUMBERS_COMMAND)) {
 320                             executeCommand(OUTDENT_COMMAND, null);
 321                         }
 322                     }
 323                     return;
 324                 }
 325                 // Work around for bug that sends events from ColorPicker to this Scene
 326                 if ((fgColorButton != null &amp;&amp; fgColorButton.isShowing()) ||
 327                     (bgColorButton != null &amp;&amp; bgColorButton.isShowing())) {
 328                     return;
 329                 }
 330                 Platform.runLater(new Runnable() {
 331                     @Override public void run() {
 332 //                        if (webPage.getClientSelectedText().isEmpty()) {
 333 //                            if (event.getCode() == KeyCode.UP || event.getCode() == KeyCode.DOWN ||
 334 //                                event.getCode() == KeyCode.LEFT || event.getCode() == KeyCode.RIGHT ||
 335 //                                event.getCode() == KeyCode.HOME || event.getCode() == KeyCode.END) {
 336 //                                updateToolbarState(true);
 337 //                            } else if (event.isControlDown() || event.isMetaDown()) {
 338 //                                if (event.getCode() == KeyCode.B) {
 339 //                                    keyboardShortcuts(BOLD_COMMAND);
 340 //                                } else if(event.getCode() == KeyCode.I) {
 341 //                                    keyboardShortcuts(ITALIC_COMMAND);
 342 //                                } else if (event.getCode() == KeyCode.U) {
 343 //                                    keyboardShortcuts(UNDERLINE_COMMAND);
 344 //                                }
 345 //                                updateToolbarState(true);
 346 //                            } else {
 347 //                                resetToolbarState = event.getCode() == KeyCode.ENTER;
 348 //                                if (resetToolbarState) {
 349 //                                    if (getCommandState(BOLD_COMMAND) !=  boldButton.selectedProperty().getValue()) {
 350 //                                        executeCommand(BOLD_COMMAND, boldButton.selectedProperty().getValue().toString());
 351 //                                    }
 352 //                                }
 353 //                                updateToolbarState(false);
 354 //                            }
 355 //                            resetToolbarState = false;
 356 //                        }
 357 //                        else if (event.isShiftDown() &amp;&amp;
 358 //                                 (event.getCode() == KeyCode.UP || event.getCode() == KeyCode.DOWN ||
 359 //                                  event.getCode() == KeyCode.LEFT || event.getCode() == KeyCode.RIGHT)) {
 360 //                            updateToolbarState(true);
 361 //                        }
 362                     }
 363                 });
 364             }
 365         });
 366 
 367         webView.addEventHandler(KeyEvent.KEY_RELEASED, new EventHandler&lt;KeyEvent&gt;() {
 368             @Override public void handle(final KeyEvent event) {
 369                 if (event.getCode() == KeyCode.CONTROL || event.getCode() == KeyCode.META) {
 370                     return;
 371                 }
 372                 // Work around for bug that sends events from ColorPicker to this Scene
 373                 if ((fgColorButton != null &amp;&amp; fgColorButton.isShowing()) ||
 374                     (bgColorButton != null &amp;&amp; bgColorButton.isShowing())) {
 375                     return;
 376                 }
 377                 Platform.runLater(new Runnable() {
 378                     @Override public void run() {
 379 //                        if (webPage.getClientSelectedText().isEmpty()) {
 380 //                            if (event.getCode() == KeyCode.UP || event.getCode() == KeyCode.DOWN ||
 381 //                                event.getCode() == KeyCode.LEFT || event.getCode() == KeyCode.RIGHT ||
 382 //                                event.getCode() == KeyCode.HOME || event.getCode() == KeyCode.END) {
 383 //                                updateToolbarState(true);
 384 //                            } else if (event.isControlDown() || event.isMetaDown()) {
 385 //                                if (event.getCode() == KeyCode.B) {
 386 //                                    keyboardShortcuts(BOLD_COMMAND);
 387 //                                } else if(event.getCode() == KeyCode.I) {
 388 //                                    keyboardShortcuts(ITALIC_COMMAND);
 389 //                                } else if (event.getCode() == KeyCode.U) {
 390 //                                    keyboardShortcuts(UNDERLINE_COMMAND);
 391 //                                }
 392 //                                updateToolbarState(true);
 393 //                            } else {
 394 //                                resetToolbarState = event.getCode() == KeyCode.ENTER;
 395 //                                if (!resetToolbarState) {
 396 //                                    updateToolbarState(false);
 397 //                                }
 398 //                            }
 399 //                            resetToolbarState = false;
 400 //                        }
 401                     }
 402                 });
 403             }
 404         });
 405 
 406         getSkinnable().focusedProperty().addListener(new ChangeListener&lt;Boolean&gt;() {
 407             @Override
 408             public void changed(ObservableValue&lt;? extends Boolean&gt; observable, Boolean oldValue, final Boolean newValue) {
 409                 Platform.runLater(new Runnable() {
 410                     @Override public void run() {
 411                         if (newValue) {
 412                             webView.requestFocus();
 413                         }
 414                     }
 415                 });
 416             }
 417         });
 418 
 419         webView.focusedProperty().addListener(new ChangeListener&lt;Boolean&gt;() {
 420             @Override
 421             public void changed(ObservableValue&lt;? extends Boolean&gt; observable, Boolean oldValue, final Boolean newValue) {
 422                 if (newValue) {
 423 //                    webPage.dispatchFocusEvent(new WCFocusEvent(WCFocusEvent.FOCUS_GAINED, WCFocusEvent.FORWARD));
 424                     enableToolbar(true);
 425                 } else {
 426 //                    webPage.dispatchFocusEvent(new WCFocusEvent(WCFocusEvent.FOCUS_LOST, WCFocusEvent.FORWARD));
 427                     enableToolbar(false);
 428                 }
 429                 Platform.runLater(new Runnable() {
 430                     @Override public void run() {
 431                         updateToolbarState(true);
 432                     }
 433                 });
 434 
 435                 if (PlatformImpl.isSupported(ConditionalFeature.VIRTUAL_KEYBOARD)) {
 436                     Platform.runLater(new Runnable() {
 437                         public void run() {
 438                             Scene scene = getSkinnable().getScene();
 439                             if (newValue) {
 440                                 FXVK.attach(webView);
 441                             } else if (scene == null ||
 442                                        scene.getWindow() == null ||
 443                                        !scene.getWindow().isFocused() ||
 444                                        !(scene.getFocusOwner() instanceof TextInputControl /*||
 445                                          getScene().getFocusOwner() instanceof WebView*/)) {
 446                                 FXVK.detach();
 447                             }
 448                         }
 449                     });
 450                 }
 451             }
 452         });
 453 
 454         webView.getEngine().getLoadWorker().workDoneProperty().addListener(new ChangeListener&lt;Number&gt;() {
 455             @Override
 456             public void changed(ObservableValue&lt;? extends Number&gt; observable, final Number oldValue, final Number newValue) {
 457                 Platform.runLater(new Runnable() {
 458                     @Override public void run() {
 459                         webView.requestLayout();
 460                     }
 461                 });
 462 
 463                 double totalWork = webView.getEngine().getLoadWorker().getTotalWork();
 464                 if (newValue.doubleValue() == totalWork) {
 465                     cachedHTMLText = null;
 466                     Platform.runLater(new Runnable() {
 467                         @Override public void run() {
 468                             setContentEditable(true);
 469                             updateToolbarState(true);
 470                             updateNodeOrientation();
 471                         }
 472                     });
 473                 }
 474             }
 475         });
 476 
 477         enableToolbar(true);
 478         setHTMLText(cachedHTMLText);
 479 
 480         engine = new ParentTraversalEngine(getSkinnable(), new Algorithm() {
 481             @Override
 482             public Node select(Node owner, Direction dir, TraversalContext context) {
 483                 return cutButton;
 484             }
 485 
 486             @Override
 487             public Node selectFirst(TraversalContext context) {
 488                 return cutButton;
 489             }
 490 
 491             @Override
 492             public Node selectLast(TraversalContext context) {
 493                 return cutButton;
 494             }
 495         });
 496         ParentHelper.setTraversalEngine(getSkinnable(), engine);
 497         webView.setFocusTraversable(true);
 498         gridPane.getChildren().addListener(itemsListener);
 499     }
 500 
 501     public final String getHTMLText() {
 502         // RT17203 setHTMLText is asynchronous.  We use the cached version of
 503         // the html text until the page finishes loading.
 504         return cachedHTMLText != null ? cachedHTMLText : null;//webPage.getHtml(webPage.getMainFrame());
 505     }
 506 
 507     public final void setHTMLText(String htmlText) {
 508         cachedHTMLText = htmlText;
 509 //        webPage.load(webPage.getMainFrame(), htmlText, &quot;text/html&quot;);
 510 
 511         Platform.runLater(new Runnable() {
 512             @Override public void run() {
 513                 updateToolbarState(true);
 514             }
 515         });
 516     }
 517 
 518     private ResourceBundle resources;
 519 
 520     private void populateToolbars() {
 521         resources = ResourceBundle.getBundle(HTMLEditorSkin.class.getName());
 522 
 523         // Toolbar 1
 524         cutButton = addButton(toolbar1, resources.getString(&quot;cutIcon&quot;), resources.getString(&quot;cut&quot;), CUT_COMMAND, &quot;html-editor-cut&quot;);
 525         copyButton = addButton(toolbar1, resources.getString(&quot;copyIcon&quot;), resources.getString(&quot;copy&quot;), COPY_COMMAND, &quot;html-editor-copy&quot;);
 526         pasteButton = addButton(toolbar1, resources.getString(&quot;pasteIcon&quot;), resources.getString(&quot;paste&quot;), PASTE_COMMAND, &quot;html-editor-paste&quot;);
 527 
 528         toolbar1.getItems().add(new Separator());
 529 
 530 //        undoButton = addButton(toolbar1, &quot;undoIcon&quot;, resources.getString(&quot;undo&quot;), UNDO_COMMAND);
 531 //        redoButton = addButton(toolbar1, &quot;redoIcon&quot;, resources.getString(&quot;redo&quot;), REDO_COMMAND);//
 532 //        toolbar1.getItems().add(new Separator());
 533 
 534          alignmentToggleGroup = new ToggleGroup();
 535          alignLeftButton = addToggleButton(toolbar1, alignmentToggleGroup,
 536             resources.getString(&quot;alignLeftIcon&quot;), resources.getString(&quot;alignLeft&quot;), ALIGN_LEFT_COMMAND, &quot;html-editor-align-left&quot;);
 537          alignCenterButton = addToggleButton(toolbar1, alignmentToggleGroup,
 538             resources.getString(&quot;alignCenterIcon&quot;), resources.getString(&quot;alignCenter&quot;), ALIGN_CENTER_COMMAND, &quot;html-editor-align-center&quot;);
 539          alignRightButton = addToggleButton(toolbar1, alignmentToggleGroup,
 540             resources.getString(&quot;alignRightIcon&quot;), resources.getString(&quot;alignRight&quot;), ALIGN_RIGHT_COMMAND, &quot;html-editor-align-right&quot;);
 541          alignJustifyButton = addToggleButton(toolbar1, alignmentToggleGroup,
 542             resources.getString(&quot;alignJustifyIcon&quot;), resources.getString(&quot;alignJustify&quot;), ALIGN_JUSTIFY_COMMAND, &quot;html-editor-align-justify&quot;);
 543 
 544         toolbar1.getItems().add(new Separator());
 545 
 546         outdentButton = addButton(toolbar1, resources.getString(&quot;outdentIcon&quot;), resources.getString(&quot;outdent&quot;), OUTDENT_COMMAND, &quot;html-editor-outdent&quot;);
 547         if (outdentButton.getGraphic() != null) outdentButton.getGraphic().setNodeOrientation(NodeOrientation.INHERIT);
 548         indentButton = addButton(toolbar1, resources.getString(&quot;indentIcon&quot;), resources.getString(&quot;indent&quot;), INDENT_COMMAND, &quot;html-editor-indent&quot;);
 549         if (indentButton.getGraphic() != null) indentButton.getGraphic().setNodeOrientation(NodeOrientation.INHERIT);
 550 
 551         toolbar1.getItems().add(new Separator());
 552 
 553          ToggleGroup listStyleToggleGroup = new ToggleGroup();
 554          bulletsButton = addToggleButton(toolbar1, listStyleToggleGroup,
 555             resources.getString(&quot;bulletsIcon&quot;), resources.getString(&quot;bullets&quot;), BULLETS_COMMAND, &quot;html-editor-bullets&quot;);
 556          if (bulletsButton.getGraphic() != null) bulletsButton.getGraphic().setNodeOrientation(NodeOrientation.INHERIT);
 557          numbersButton = addToggleButton(toolbar1, listStyleToggleGroup,
 558             resources.getString(&quot;numbersIcon&quot;), resources.getString(&quot;numbers&quot;), NUMBERS_COMMAND, &quot;html-editor-numbers&quot;);
 559 
 560         toolbar1.getItems().add(new Separator());
 561 
 562         //toolbar1.getItems().add(new Separator());
 563 
 564         // Toolbar 2
 565         formatComboBox = new ComboBox&lt;String&gt;();
 566         formatComboBox.getStyleClass().add(&quot;font-menu-button&quot;);
 567         formatComboBox.setFocusTraversable(false);
 568         formatComboBox.setMinWidth(Region.USE_PREF_SIZE);
 569         toolbar2.getItems().add(formatComboBox);
 570 
 571         formatStyleMap = new HashMap&lt;String, String&gt;();
 572         styleFormatMap = new HashMap&lt;String, String&gt;();
 573 
 574         createFormatMenuItem(FORMAT_PARAGRAPH, resources.getString(&quot;paragraph&quot;));
 575         Platform.runLater(new Runnable() {
 576             @Override
 577             public void run() {
 578                 formatComboBox.setValue(resources.getString(&quot;paragraph&quot;));
 579             }
 580         });
 581         createFormatMenuItem(FORMAT_HEADING_1, resources.getString(&quot;heading1&quot;));
 582         createFormatMenuItem(FORMAT_HEADING_2, resources.getString(&quot;heading2&quot;));
 583         createFormatMenuItem(FORMAT_HEADING_3, resources.getString(&quot;heading3&quot;));
 584         createFormatMenuItem(FORMAT_HEADING_4, resources.getString(&quot;heading4&quot;));
 585         createFormatMenuItem(FORMAT_HEADING_5, resources.getString(&quot;heading5&quot;));
 586         createFormatMenuItem(FORMAT_HEADING_6, resources.getString(&quot;heading6&quot;));
 587 
 588 //        formatComboBox.setCellFactory(new Callback&lt;ListView&lt;String&gt;, ListCell&lt;String&gt;&gt;() {
 589 //            @Override public ListCell&lt;String&gt; call(ListView&lt;String&gt; param) {
 590 //                final ListCell&lt;String&gt; cell = new ListCell&lt;String&gt;() {
 591 //                    @Override public void updateItem(String item, boolean empty) {
 592 //                        super.updateItem(item, empty);
 593 //                        if (item != null) {
 594 //                            setText(item);
 595 //                        }
 596 //                    }
 597 //                };
 598 //                return cell;
 599 //            }
 600 //        });
 601 
 602         formatComboBox.setTooltip(new Tooltip(resources.getString(&quot;format&quot;)));
 603 
 604         formatComboBox.valueProperty().addListener(new ChangeListener&lt;String&gt;() {
 605             @Override
 606             public void changed(ObservableValue&lt;? extends String&gt; observable, String oldValue, String newValue) {
 607                 if (newValue == null) {
 608                     formatComboBox.setValue(null);
 609                 } else {
 610                     String formatValue = formatStyleMap.get(newValue);
 611                     executeCommand(FORMAT_COMMAND, formatValue);
 612                     updateToolbarState(false);
 613 
 614                     // RT-16330 match the new font format with the required weight and size
 615                     for (int i = 0; i &lt; DEFAULT_FORMAT_MAPPINGS.length; i++) {
 616                         String[] mapping = DEFAULT_FORMAT_MAPPINGS[i];
 617                         if (mapping[0].equalsIgnoreCase(formatValue)) {
 618                             executeCommand(FONT_SIZE_COMMAND, mapping[2]);
 619                             updateToolbarState(false);
 620                             break;
 621                         }
 622                     }
 623                 }
 624             }
 625         });
 626 
 627         fontFamilyComboBox = new ComboBox&lt;String&gt;();
 628         fontFamilyComboBox.getStyleClass().add(&quot;font-menu-button&quot;);
 629         fontFamilyComboBox.setMinWidth(FONT_FAMILY_MENUBUTTON_WIDTH);
 630         fontFamilyComboBox.setPrefWidth(FONT_FAMILY_MENUBUTTON_WIDTH);
 631         fontFamilyComboBox.setMaxWidth(FONT_FAMILY_MENUBUTTON_WIDTH);
 632         fontFamilyComboBox.setFocusTraversable(false);
 633         fontFamilyComboBox.setTooltip(new Tooltip(resources.getString(&quot;fontFamily&quot;)));
 634         toolbar2.getItems().add(fontFamilyComboBox);
 635 
 636         fontFamilyComboBox.setCellFactory(new Callback&lt;ListView&lt;String&gt;, ListCell&lt;String&gt;&gt;() {
 637             @Override public ListCell&lt;String&gt; call(ListView&lt;String&gt; param) {
 638                 final ListCell&lt;String&gt; cell = new ListCell&lt;String&gt;() {
 639                     @Override public void updateItem(String item, boolean empty) {
 640                         super.updateItem(item, empty);
 641                         if (item != null) {
 642                             setText(item);
 643                             setFont(new Font(item, 12));
 644                         }
 645                     }
 646                 };
 647                 cell.setMinWidth(FONT_FAMILY_MENU_WIDTH);
 648                 cell.setPrefWidth(FONT_FAMILY_MENU_WIDTH);
 649                 cell.setMaxWidth(FONT_FAMILY_MENU_WIDTH);
 650                 return cell;
 651             }
 652         });
 653 
 654         Platform.runLater(new Runnable() {
 655                 @Override public void run() {
 656                     final ObservableList&lt;String&gt; fonts = FXCollections.observableArrayList(Font.getFamilies());
 657                     for (String fontFamily : fonts) {
 658                         if (DEFAULT_OS_FONT.equals(fontFamily)) {
 659                             fontFamilyComboBox.setValue(fontFamily);
 660                         }
 661                         fontFamilyComboBox.setItems(fonts);
 662                     }
 663                 }
 664             });
 665 
 666         fontFamilyComboBox.valueProperty().addListener(new ChangeListener&lt;String&gt;() {
 667             @Override
 668             public void changed(ObservableValue&lt;? extends String&gt; observable, String oldValue, String newValue) {
 669                 executeCommand(FONT_FAMILY_COMMAND, newValue);
 670             }
 671         });
 672 
 673         fontSizeComboBox = new ComboBox&lt;String&gt;();
 674         fontSizeComboBox.getStyleClass().add(&quot;font-menu-button&quot;);
 675         fontSizeComboBox.setFocusTraversable(false);
 676         toolbar2.getItems().add(fontSizeComboBox);
 677 
 678         fontSizeMap = new HashMap&lt;String, String&gt;();
 679         sizeFontMap = new HashMap&lt;String, String&gt;();
 680 
 681         createFontSizeMenuItem(SIZE_XX_SMALL, resources.getString(&quot;extraExtraSmall&quot;));
 682         createFontSizeMenuItem(SIZE_X_SMALL, resources.getString(&quot;extraSmall&quot;));
 683         createFontSizeMenuItem(SIZE_SMALL, resources.getString(&quot;small&quot;));
 684         Platform.runLater(new Runnable() {
 685             @Override
 686             public void run() {
 687                 fontSizeComboBox.setValue(resources.getString(&quot;small&quot;));
 688             }
 689         });
 690         createFontSizeMenuItem(SIZE_MEDIUM, resources.getString(&quot;medium&quot;));
 691         createFontSizeMenuItem(SIZE_LARGE, resources.getString(&quot;large&quot;));
 692         createFontSizeMenuItem(SIZE_X_LARGE, resources.getString(&quot;extraLarge&quot;));
 693         createFontSizeMenuItem(SIZE_XX_LARGE, resources.getString(&quot;extraExtraLarge&quot;));
 694         fontSizeComboBox.setTooltip(new Tooltip(resources.getString(&quot;fontSize&quot;)));
 695 
 696         fontSizeComboBox.setCellFactory(new Callback&lt;ListView&lt;String&gt;, ListCell&lt;String&gt;&gt;() {
 697             @Override public ListCell&lt;String&gt; call(ListView&lt;String&gt; param) {
 698                 final ListCell&lt;String&gt; cell = new ListCell&lt;String&gt;() {
 699                     @Override public void updateItem(String item, boolean empty) {
 700                         super.updateItem(item, empty);
 701                         if (item != null) {
 702                             setText(item);
 703                             setFont(new Font((String)fontFamilyComboBox.getValue(), Double.valueOf(item.substring(0, item.indexOf(&quot; &quot;)))));
 704                         }
 705                     }
 706                 };
 707                 return cell;
 708             }
 709         });
 710 
 711 
 712         fontSizeComboBox.valueProperty().addListener(new ChangeListener&lt;String&gt;() {
 713             @Override
 714             public void changed(ObservableValue&lt;? extends String&gt; observable, String oldValue, String newValue) {
 715                 Object fontSizeValue = getCommandValue(FONT_SIZE_COMMAND);
 716                 if (!newValue.equals(fontSizeValue)) {
 717                     executeCommand(FONT_SIZE_COMMAND, fontSizeMap.get(newValue));
 718                 }
 719             }
 720         });
 721 
 722         toolbar2.getItems().add(new Separator());
 723 
 724         boldButton = addToggleButton(toolbar2, null,
 725             resources.getString(&quot;boldIcon&quot;), resources.getString(&quot;bold&quot;), BOLD_COMMAND, &quot;html-editor-bold&quot;);
 726         boldButton.setOnAction(new EventHandler&lt;ActionEvent&gt;() {
 727             @Override
 728             public void handle(ActionEvent event) {
 729                 // Only use the bold button for paragraphs.  We don&#39;t
 730                 // want to turn bold off for headings.
 731 
 732                 if (&quot;&lt;p&gt;&quot;.equals(formatStyleMap.get(formatComboBox.getValue())))  {
 733                     executeCommand(BOLD_COMMAND, boldButton.selectedProperty().getValue().toString());
 734                 }
 735             }
 736         });
 737         italicButton = addToggleButton(toolbar2, null,
 738             resources.getString(&quot;italicIcon&quot;), resources.getString(&quot;italic&quot;), ITALIC_COMMAND, &quot;html-editor-italic&quot;);
 739         underlineButton = addToggleButton(toolbar2, null,
 740             resources.getString(&quot;underlineIcon&quot;), resources.getString(&quot;underline&quot;), UNDERLINE_COMMAND, &quot;html-editor-underline&quot;);
 741         strikethroughButton = addToggleButton(toolbar2, null,
 742             resources.getString(&quot;strikethroughIcon&quot;), resources.getString(&quot;strikethrough&quot;), STRIKETHROUGH_COMMAND, &quot;html-editor-strike&quot;);
 743 
 744         toolbar2.getItems().add(new Separator());
 745 
 746         insertHorizontalRuleButton = addButton(toolbar2, resources.getString(&quot;insertHorizontalRuleIcon&quot;),
 747             resources.getString(&quot;insertHorizontalRule&quot;), INSERT_HORIZONTAL_RULE_COMMAND, &quot;html-editor-hr&quot;);
 748         // We override setOnAction to insert a new line.  This fixes RT-16453
 749         insertHorizontalRuleButton.setOnAction(new EventHandler&lt;ActionEvent&gt;() {
 750             @Override
 751             public void handle(ActionEvent event) {
 752                 executeCommand(INSERT_NEW_LINE_COMMAND, null);
 753                 executeCommand(INSERT_HORIZONTAL_RULE_COMMAND, null);
 754                 updateToolbarState(false);
 755             }
 756         });
 757 
 758         fgColorButton = new ColorPicker();
 759         fgColorButton.getStyleClass().add(&quot;html-editor-foreground&quot;);
 760         fgColorButton.setFocusTraversable(false);
 761         toolbar1.getItems().add(fgColorButton);
 762 
 763         // fgColorButton.applyCss();
 764         // ColorPickerSkin fgColorPickerSkin = (ColorPickerSkin) fgColorButton.getSkin();
 765         // String fgIcon = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {
 766             // @Override public String run() {
 767                 // return HTMLEditorSkin.class.getResource(resources.getString(&quot;foregroundColorIcon&quot;)).toString();
 768             // }
 769         // });
 770         // ((StyleableProperty)fgColorPickerSkin.imageUrlProperty()).applyStyle(null,fgIcon);
 771 
 772         fgColorButton.setValue(DEFAULT_FG_COLOR);
 773         fgColorButton.setTooltip(new Tooltip(resources.getString(&quot;foregroundColor&quot;)));
 774         fgColorButton.setOnAction(new EventHandler&lt;ActionEvent&gt;() {
 775             @Override public void handle(ActionEvent ev) {
 776                 Color newValue = fgColorButton.getValue();
 777                 if (newValue != null) {
 778                     executeCommand(FOREGROUND_COLOR_COMMAND, colorValueToHex(newValue));
 779                     fgColorButton.hide();
 780                 }
 781             }
 782         });
 783 
 784         bgColorButton = new ColorPicker();
 785         bgColorButton.getStyleClass().add(&quot;html-editor-background&quot;);
 786         bgColorButton.setFocusTraversable(false);
 787         toolbar1.getItems().add(bgColorButton);
 788 
 789         // bgColorButton.applyCss();
 790         // ColorPickerSkin  bgColorPickerSkin = (ColorPickerSkin) bgColorButton.getSkin();
 791         // String bgIcon = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {
 792             // @Override public String run() {
 793                 // return HTMLEditorSkin.class.getResource(resources.getString(&quot;backgroundColorIcon&quot;)).toString();
 794             // }
 795         // });
 796         // ((StyleableProperty)bgColorPickerSkin.imageUrlProperty()).applyStyle(null,bgIcon);
 797 
 798         bgColorButton.setValue(DEFAULT_BG_COLOR);
 799         bgColorButton.setTooltip(new Tooltip(resources.getString(&quot;backgroundColor&quot;)));
 800 
 801         bgColorButton.setOnAction(new EventHandler&lt;ActionEvent&gt;() {
 802             @Override public void handle(ActionEvent ev) {
 803                 Color newValue = bgColorButton.getValue();
 804                 if (newValue != null) {
 805                     executeCommand(BACKGROUND_COLOR_COMMAND, colorValueToHex(newValue));
 806                     bgColorButton.hide();
 807                 }
 808             }
 809         });
 810     }
 811 
 812     private String colorValueToHex(Color c) {
 813         return String.format((Locale)null, &quot;#%02x%02x%02x&quot;,
 814                              Math.round(c.getRed() * 255),
 815                              Math.round(c.getGreen() * 255),
 816                              Math.round(c.getBlue() * 255));
 817     }
 818 
 819     private Button addButton(ToolBar toolbar, final String iconName, String tooltipText,
 820             final String command, final String styleClass) {
 821         Button button = new Button();
 822         button.setFocusTraversable(false);
 823         button.getStyleClass().add(styleClass);
 824         toolbar.getItems().add(button);
 825 
 826         Image icon = AccessController.doPrivileged(new PrivilegedAction&lt;Image&gt;() {
 827             @Override public Image run() {
 828                 return new Image(HTMLEditorSkin.class.getResource(iconName).toString());
 829             }
 830         });
 831 //        button.setGraphic(new ImageView(icon));
 832         ((StyleableProperty)button.graphicProperty()).applyStyle(null,new ImageView(icon));
 833         button.setTooltip(new Tooltip(tooltipText));
 834 
 835         button.setOnAction(new EventHandler&lt;ActionEvent&gt;() {
 836             @Override
 837             public void handle(ActionEvent event) {
 838                 executeCommand(command, null);
 839                 updateToolbarState(false);
 840             }
 841         });
 842 
 843         return button;
 844     }
 845 
 846     private ToggleButton addToggleButton(ToolBar toolbar, ToggleGroup toggleGroup,
 847             final String iconName, String tooltipText, final String command, final String styleClass) {
 848         ToggleButton toggleButton = new ToggleButton();
 849         toggleButton.setUserData(command);
 850         toggleButton.setFocusTraversable(false);
 851         toggleButton.getStyleClass().add(styleClass);
 852         toolbar.getItems().add(toggleButton);
 853         if (toggleGroup != null) {
 854             toggleButton.setToggleGroup(toggleGroup);
 855         }
 856 
 857         Image icon = AccessController.doPrivileged(new PrivilegedAction&lt;Image&gt;() {
 858             @Override public Image run() {
 859                 return new Image(HTMLEditorSkin.class.getResource(iconName).toString());
 860             }
 861         });
 862         ((StyleableProperty)toggleButton.graphicProperty()).applyStyle(null,new ImageView(icon));
 863 //        toggleButton.setGraphic(new ImageView(icon));
 864 
 865         toggleButton.setTooltip(new Tooltip(tooltipText));
 866 
 867         if (!BOLD_COMMAND.equals(command)) {
 868             toggleButton.selectedProperty().addListener(new ChangeListener&lt;Boolean&gt;() {
 869                 @Override
 870                 public void changed(ObservableValue&lt;? extends Boolean&gt; observable, Boolean oldValue, Boolean newValue) {
 871                     if (getCommandState(command) != newValue.booleanValue()) {
 872                         executeCommand(command, null);
 873                     }
 874                 }
 875             });
 876         }
 877         return toggleButton;
 878     }
 879 
 880     private void createFormatMenuItem(String formatValue, String label) {
 881         formatComboBox.getItems().add(label);
 882         formatStyleMap.put(label, formatValue);
 883         styleFormatMap.put(formatValue, label);
 884     }
 885 
 886     private void createFontSizeMenuItem(String fontSizeValue, String label) {
 887         fontSizeComboBox.getItems().add(label);
 888         fontSizeMap.put(label, fontSizeValue);
 889         sizeFontMap.put(fontSizeValue, label);
 890     }
 891 
 892     private void updateNodeOrientation() {
 893         NodeOrientation orientation = getSkinnable().getEffectiveNodeOrientation();
 894 
 895 //        HTMLDocument htmlDocument = (HTMLDocument)webPage.getDocument(webPage.getMainFrame());
 896 //        HTMLElement htmlDocumentElement = (HTMLElement)htmlDocument.getDocumentElement();
 897 //        if (htmlDocumentElement.getAttribute(&quot;dir&quot;) == null) {
 898 //            htmlDocumentElement.setAttribute(&quot;dir&quot;, (orientation == RIGHT_TO_LEFT) ? &quot;rtl&quot; : &quot;ltr&quot;);
 899 //        }
 900 
 901         if (orientation == RIGHT_TO_LEFT) {
 902             try {
 903                 final String iconName = resources.getString(&quot;numbersIcon-rtl&quot;);
 904                 Image icon = AccessController.doPrivileged(new PrivilegedAction&lt;Image&gt;() {
 905                     @Override public Image run() {
 906                         return new Image(HTMLEditorSkin.class.getResource(iconName).toString());
 907                     }
 908                 });
 909                 numbersButton.setGraphic(new ImageView(icon));
 910             } catch (java.util.MissingResourceException ex) {
 911                 // ignore
 912             }
 913         }
 914     }
 915 
 916     private void updateToolbarState(final boolean updateAlignment) {
 917         if (!webView.isFocused()) {
 918             return;
 919         }
 920 
 921         // These command aways return true.
 922         copyButton.setDisable(!isCommandEnabled(CUT_COMMAND));
 923         cutButton.setDisable(!isCommandEnabled(COPY_COMMAND));
 924         pasteButton.setDisable(!isCommandEnabled(PASTE_COMMAND));
 925 
 926         // undoButton.setDisable(!isCommandEnabled(UNDO_COMMAND));
 927         // redoButton.setDisable(!isCommandEnabled(REDO_COMMAND));
 928 
 929 //        undoButton.setDisable(!isCommandEnabled(FORMAT_COMMAND));
 930 //        redoButton.setDisable(!isCommandEnabled(FORMAT_COMMAND));
 931 
 932         insertHorizontalRuleButton.setDisable(!isCommandEnabled(INSERT_HORIZONTAL_RULE_COMMAND));
 933 
 934         if (updateAlignment) {
 935             alignLeftButton.setDisable(!isCommandEnabled(ALIGN_LEFT_COMMAND));
 936             alignLeftButton.setSelected(getCommandState(ALIGN_LEFT_COMMAND));
 937             alignCenterButton.setDisable(!isCommandEnabled(ALIGN_CENTER_COMMAND));
 938             alignCenterButton.setSelected(getCommandState(ALIGN_CENTER_COMMAND));
 939             alignRightButton.setDisable(!isCommandEnabled(ALIGN_RIGHT_COMMAND));
 940             alignRightButton.setSelected(getCommandState(ALIGN_RIGHT_COMMAND));
 941             alignJustifyButton.setDisable(!isCommandEnabled(ALIGN_JUSTIFY_COMMAND));
 942             alignJustifyButton.setSelected(getCommandState(ALIGN_JUSTIFY_COMMAND));
 943         } else {
 944             if (alignmentToggleGroup.getSelectedToggle() != null) {
 945                 String command = alignmentToggleGroup.getSelectedToggle().getUserData().toString();
 946                 if (isCommandEnabled(command) &amp;&amp; !getCommandState(command) ) {
 947                     executeCommand(command, null);
 948                 }
 949             }
 950         }
 951 
 952         if (alignmentToggleGroup.getSelectedToggle() == null) {
 953             alignmentToggleGroup.selectToggle(alignLeftButton);
 954         }
 955 
 956         bulletsButton.setDisable(!isCommandEnabled(BULLETS_COMMAND));
 957         bulletsButton.setSelected(getCommandState(BULLETS_COMMAND));
 958         numbersButton.setDisable(!isCommandEnabled(NUMBERS_COMMAND));
 959         numbersButton.setSelected(getCommandState(NUMBERS_COMMAND));
 960 
 961         indentButton.setDisable(!isCommandEnabled(INDENT_COMMAND));
 962         outdentButton.setDisable(!isCommandEnabled(OUTDENT_COMMAND));
 963 
 964         formatComboBox.setDisable(!isCommandEnabled(FORMAT_COMMAND));
 965 
 966 
 967         String formatValue = getCommandValue(FORMAT_COMMAND);
 968         if (formatValue != null) {
 969             String htmlTag = &quot;&lt;&quot; + formatValue + &quot;&gt;&quot;;
 970             String comboFormatValue = styleFormatMap.get(htmlTag);
 971             String format = formatComboBox.getValue();
 972 
 973             // if the format value is then we assume that we&#39;re dealing with a paragraph,
 974             // which seems to correspond with the HTML output we receive.
 975             if ((resetToolbarState || htmlTag.equals(&quot;&lt;&gt;&quot;) || htmlTag.equalsIgnoreCase(&quot;&lt;div&gt;&quot;))) {
 976                 formatComboBox.setValue(resources.getString(&quot;paragraph&quot;));
 977             } else if (format != null &amp;&amp; ! format.equalsIgnoreCase(comboFormatValue)) {
 978                 formatComboBox.setValue(comboFormatValue);
 979             }
 980         }
 981 
 982         fontFamilyComboBox.setDisable(!isCommandEnabled(FONT_FAMILY_COMMAND));
 983         final String fontFamilyValue = getCommandValue(FONT_FAMILY_COMMAND);
 984         if (fontFamilyValue != null) {
 985             String fontFamilyStr = fontFamilyValue;
 986 
 987             // stripping out apostrophe characters, which are appended to either
 988             // end of the font face name when the font face has one or more spaces.
 989             if (fontFamilyStr.startsWith(&quot;&#39;&quot;)) {
 990                 fontFamilyStr = fontFamilyStr.substring(1);
 991             }
 992             if (fontFamilyStr.endsWith(&quot;&#39;&quot;)) {
 993                 fontFamilyStr = fontFamilyStr.substring(0,fontFamilyStr.length() - 1);
 994             }
 995 
 996             Object selectedFont = fontFamilyComboBox.getValue();
 997             if (selectedFont instanceof String) {
 998                 if (!selectedFont.equals(fontFamilyStr)) {
 999 
1000                     ObservableList&lt;String&gt; fontFamilyItems = fontFamilyComboBox.getItems();
1001                     String selectedComboFont = null;
1002                     for (String comboFontFamilyValue : fontFamilyItems) {
1003 
1004                         if (comboFontFamilyValue.equals(fontFamilyStr)) {
1005                             selectedComboFont = comboFontFamilyValue;
1006                             break;
1007                         }
1008                         // Note: By default, &#39;Dialog&#39; is the font returned from webview.
1009                         // For presidio, we&#39;re just mapping to an OS-specific font.
1010                         if (comboFontFamilyValue.equals(DEFAULT_OS_FONT) &amp;&amp; fontFamilyStr.equals(&quot;Dialog&quot;)) {
1011                             selectedComboFont = comboFontFamilyValue;
1012                             break;
1013                         }
1014                     }
1015 
1016                     if (selectedComboFont != null) {
1017                         fontFamilyComboBox.setValue(selectedComboFont);
1018                     }
1019                 }
1020             }
1021         }
1022 
1023         fontSizeComboBox.setDisable(!isCommandEnabled(FONT_SIZE_COMMAND));
1024         String fontSizeValue = getCommandValue(FONT_SIZE_COMMAND);
1025 
1026         if (resetToolbarState) {
1027             fontSizeComboBox.setValue(sizeFontMap.get(SIZE_SMALL));
1028         }
1029         else {
1030             if (fontSizeValue != null) {
1031                 if (!fontSizeComboBox.getValue().equals(sizeFontMap.get(fontSizeValue))) {
1032                     fontSizeComboBox.setValue(sizeFontMap.get(fontSizeValue));
1033                 }
1034             }
1035             else {
1036                 /*
1037                 ** these is no font size set in webview,
1038                 ** let&#39;s just use the default....
1039                 */
1040                 if (!fontSizeComboBox.getValue().equals(sizeFontMap.get(SIZE_SMALL))) {
1041                     fontSizeComboBox.setValue(sizeFontMap.get(SIZE_SMALL));
1042                 }
1043             }
1044         }
1045 
1046         boldButton.setDisable(!isCommandEnabled(BOLD_COMMAND));
1047         if (formatValue != null) {
1048             if (!resetToolbarState &amp;&amp; (&quot;p&quot;.equals(formatValue) || &quot;div&quot;.equals(formatValue))) {
1049                 boldButton.setSelected(getCommandState(BOLD_COMMAND));
1050             }
1051         }
1052         italicButton.setDisable(!isCommandEnabled(ITALIC_COMMAND));
1053         italicButton.setSelected(getCommandState(ITALIC_COMMAND));
1054         underlineButton.setDisable(!isCommandEnabled(UNDERLINE_COMMAND));
1055         underlineButton.setSelected(getCommandState(UNDERLINE_COMMAND));
1056         strikethroughButton.setDisable(!isCommandEnabled(STRIKETHROUGH_COMMAND));
1057         strikethroughButton.setSelected(getCommandState(STRIKETHROUGH_COMMAND));
1058 
1059         fgColorButton.setDisable(!isCommandEnabled(FOREGROUND_COLOR_COMMAND));
1060         String foregroundColorValue = getCommandValue(FOREGROUND_COLOR_COMMAND);
1061         if (foregroundColorValue != null) {
1062             Color c = Color.web(rgbToHex((String)foregroundColorValue));
1063             fgColorButton.setValue(c);
1064         }
1065 
1066         bgColorButton.setDisable(!isCommandEnabled(BACKGROUND_COLOR_COMMAND));
1067         String backgroundColorValue = getCommandValue(BACKGROUND_COLOR_COMMAND);
1068         if (backgroundColorValue != null) {
1069             Color c = Color.web(rgbToHex((String)backgroundColorValue));
1070             bgColorButton.setValue(c);
1071         }
1072     }
1073 
1074     private void enableToolbar(final boolean enable) {
1075         Platform.runLater(new Runnable() {
1076             @Override public void run() {
1077 
1078                 // Make sure buttons have been created to avoid NPE
1079                 if (copyButton == null) return;
1080 
1081                 /*
1082                 ** if we&#39;re to enable, we still only enable
1083                 ** the cut/copy/paste buttons that make sense
1084                 */
1085                 if (enable) {
1086                     copyButton.setDisable(!isCommandEnabled(COPY_COMMAND));
1087                     cutButton.setDisable(!isCommandEnabled(CUT_COMMAND));
1088                     pasteButton.setDisable(!isCommandEnabled(PASTE_COMMAND));
1089                 }
1090                 else {
1091                     copyButton.setDisable(true);
1092                     cutButton.setDisable(true);
1093                     pasteButton.setDisable(true);
1094                 }
1095 
1096 //                undoButton.setDisable(!enable);
1097 //                redoButton.setDisable(!enable);
1098                 insertHorizontalRuleButton.setDisable(!enable);
1099                 alignLeftButton.setDisable(!enable);
1100                 alignCenterButton.setDisable(!enable);
1101                 alignRightButton.setDisable(!enable);
1102                 alignJustifyButton.setDisable(!enable);
1103                 bulletsButton.setDisable(!enable);
1104                 numbersButton.setDisable(!enable);
1105                 indentButton.setDisable(!enable);
1106                 outdentButton.setDisable(!enable);
1107                 formatComboBox.setDisable(!enable);
1108                 fontFamilyComboBox.setDisable(!enable);
1109                 fontSizeComboBox.setDisable(!enable);
1110                 boldButton.setDisable(!enable);
1111                 italicButton.setDisable(!enable);
1112                 underlineButton.setDisable(!enable);
1113                 strikethroughButton.setDisable(!enable);
1114                 fgColorButton.setDisable(!enable);
1115                 bgColorButton.setDisable(!enable);
1116             }
1117         });
1118     }
1119 
1120     private boolean executeCommand(String command, String value) {
1121         return false; //webPage.executeCommand(command, value);
1122     }
1123 
1124     private boolean isCommandEnabled(String command) {
1125         return false;// webPage.queryCommandEnabled(command);
1126     }
1127 
1128     private void setContentEditable(boolean b) {
1129 //        HTMLDocument htmlDocument = (HTMLDocument)webPage.getDocument(webPage.getMainFrame());
1130 //        HTMLElement htmlDocumentElement = (HTMLElement)htmlDocument.getDocumentElement();
1131 //        HTMLElement htmlBodyElement = (HTMLElement)htmlDocumentElement.getElementsByTagName(&quot;body&quot;).item(0);
1132 //        htmlBodyElement.setAttribute(&quot;contenteditable&quot;, Boolean.toString(b));
1133     }
1134 
1135     private boolean getCommandState(String command) {
1136         return false;//webPage.queryCommandState(command);
1137     }
1138 
1139     private String getCommandValue(String command) {
1140         return null;//webPage.queryCommandValue(command);
1141     }
1142 
1143     private static String rgbToHex(String value) {
1144         if (value.startsWith(&quot;rgba&quot;)) {
1145             String[] components = value.substring(value.indexOf(&#39;(&#39;) + 1, value.lastIndexOf(&#39;)&#39;)).split(&quot;,&quot;);
1146             value = String.format(&quot;#%02X%02X%02X%02X&quot;,
1147                 Integer.parseInt(components[0].trim()),
1148                 Integer.parseInt(components[1].trim()),
1149                 Integer.parseInt(components[2].trim()),
1150                 Integer.parseInt(components[3].trim()));
1151             // The default background color for WebView, according to the HTML
1152             // standard is rgba=#00000000 (black). The canvas background is expected
1153             // to be white.
1154             if (&quot;#00000000&quot;.equals(value)) {
1155                 return &quot;#FFFFFFFF&quot;;
1156             }
1157         } else if (value.startsWith(&quot;rgb&quot;)) {
1158             String[] components = value.substring(value.indexOf(&#39;(&#39;) + 1, value.lastIndexOf(&#39;)&#39;)).split(&quot;,&quot;);
1159             value = String.format(&quot;#%02X%02X%02X&quot;,
1160                 Integer.parseInt(components[0].trim()),
1161                 Integer.parseInt(components[1].trim()),
1162                 Integer.parseInt(components[2].trim()));
1163         }
1164 
1165         return value;
1166     }
1167 
1168     private void applyTextFormatting() {
1169         if (getCommandState(BULLETS_COMMAND) || getCommandState(NUMBERS_COMMAND)) {
1170             return;
1171         }
1172 
1173 //        if (webPage.getClientCommittedTextLength() == 0) {
1174 //            String format = formatStyleMap.get(formatComboBox.getValue());
1175 //            String font   = fontFamilyComboBox.getValue().toString();
1176 //
1177 //            executeCommand(FORMAT_COMMAND, format);
1178 //            executeCommand(FONT_FAMILY_COMMAND, font);
1179 //        }
1180     }
1181 
1182     public void keyboardShortcuts(final String name) {
1183         if (&quot;bold&quot;.equals(name)) {
1184             boldButton.fire();
1185         } else if (&quot;italic&quot;.equals(name)) {
1186             italicButton.setSelected(!italicButton.isSelected());
1187         } else if (&quot;underline&quot;.equals(name)) {
1188             underlineButton.setSelected(!underlineButton.isSelected());
1189         }
1190     }
1191 
1192     @Override
1193     public void onTraverse(Node node, Bounds bounds) {
1194         cutButton.requestFocus();
1195     }
1196 
1197     private boolean isFirstRun = true;
1198 
1199     @Override
1200     protected void layoutChildren(final double x, final double y,
1201             final double w, final double h) {
1202 
1203         if (isFirstRun) {
1204             populateToolbars();
1205             isFirstRun = false;
1206         }
1207         super.layoutChildren(x,y,w,h);
1208         double toolbarWidth = Math.max(toolbar1.prefWidth(-1), toolbar2.prefWidth(-1));
1209         toolbar1.setMinWidth(toolbarWidth);
1210         toolbar1.setPrefWidth(toolbarWidth);
1211         toolbar2.setMinWidth(toolbarWidth);
1212         toolbar2.setPrefWidth(toolbarWidth);
1213     }
1214 
1215     private static final int FONT_FAMILY_MENUBUTTON_WIDTH = 150;
1216     private static final int FONT_FAMILY_MENU_WIDTH = 100;
1217     private static final int FONT_SIZE_MENUBUTTON_WIDTH = 80;
1218 
1219     public void performCommand(final Command command) {
1220         switch (command) {
1221             case BOLD: boldButton.fire(); break;
1222             case ITALIC: italicButton.setSelected(!italicButton.isSelected()); break;
1223             case UNDERLINE: underlineButton.setSelected(!underlineButton.isSelected()); break;
1224         }
1225     }
1226 
1227     public enum Command {
1228         CUT(&quot;cut&quot;),
1229         COPY(&quot;copy&quot;),
1230         PASTE(&quot;paste&quot;),
1231 
1232         UNDO(&quot;undo&quot;),
1233         REDO(&quot;redo&quot;),
1234 
1235         INSERT_HORIZONTAL_RULE(&quot;inserthorizontalrule&quot;),
1236 
1237         ALIGN_LEFT(&quot;justifyleft&quot;),
1238         ALIGN_CENTER(&quot;justifycenter&quot;),
1239         ALIGN_RIGHT(&quot;justifyright&quot;),
1240         ALIGN_JUSTIFY(&quot;justifyfull&quot;),
1241 
1242         BULLETS(&quot;insertUnorderedList&quot;),
1243         NUMBERS(&quot;insertOrderedList&quot;),
1244 
1245         INDENT(&quot;indent&quot;),
1246         OUTDENT(&quot;outdent&quot;),
1247 
1248         FORMAT(&quot;formatblock&quot;),
1249         FONT_FAMILY(&quot;fontname&quot;),
1250         FONT_SIZE(&quot;fontsize&quot;),
1251 
1252         BOLD(&quot;bold&quot;),
1253         ITALIC(&quot;italic&quot;),
1254         UNDERLINE(&quot;underline&quot;),
1255         STRIKETHROUGH(&quot;strikethrough&quot;),
1256 
1257         FOREGROUND_COLOR(&quot;forecolor&quot;),
1258         BACKGROUND_COLOR(&quot;backcolor&quot;),
1259         STYLEWITHCSS(&quot;styleWithCSS&quot;),
1260 
1261         INSERT_NEW_LINE(&quot;insertnewline&quot;),
1262         INSERT_TAB(&quot;inserttab&quot;);
1263 
1264         private final String command;
1265 
1266         Command(String command) {
1267             this.command = command;
1268         }
1269 
1270         public String getCommand() {
1271             return command;
1272         }
1273     }
1274 
1275 
1276 }
<a name="1" id="anc1"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="1" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/TableView.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control;
  27 
  28 import java.lang.ref.WeakReference;
  29 import java.util.ArrayList;
  30 import java.util.Collection;
  31 import java.util.Collections;
  32 import java.util.Comparator;
  33 import java.util.HashMap;
  34 import java.util.LinkedHashSet;
  35 import java.util.List;
  36 import java.util.Set;
  37 import java.util.WeakHashMap;
  38 
  39 import com.sun.javafx.logging.PlatformLogger.Level;
  40 import com.sun.javafx.scene.control.Logging;
  41 import com.sun.javafx.scene.control.Properties;
  42 import com.sun.javafx.scene.control.SelectedCellsMap;
  43 import com.sun.javafx.scene.control.behavior.TableCellBehavior;
  44 import com.sun.javafx.scene.control.behavior.TableCellBehaviorBase;
  45 
  46 import javafx.beans.*;
  47 import javafx.beans.Observable;
  48 import javafx.beans.property.BooleanProperty;
  49 import javafx.beans.property.DoubleProperty;
  50 import javafx.beans.property.ObjectProperty;
  51 import javafx.beans.property.ObjectPropertyBase;
  52 import javafx.beans.property.Property;
  53 import javafx.beans.property.ReadOnlyObjectProperty;
  54 import javafx.beans.property.ReadOnlyObjectWrapper;
  55 import javafx.beans.property.SimpleBooleanProperty;
  56 import javafx.beans.property.SimpleObjectProperty;
  57 import javafx.collections.FXCollections;
  58 import javafx.collections.ListChangeListener;
  59 import javafx.collections.MapChangeListener;
  60 import javafx.collections.ObservableList;
  61 import javafx.collections.WeakListChangeListener;
  62 import javafx.collections.transformation.SortedList;
  63 import javafx.css.CssMetaData;
  64 import javafx.css.PseudoClass;
  65 import javafx.css.Styleable;
  66 import javafx.css.StyleableDoubleProperty;
  67 import javafx.css.StyleableProperty;
  68 import javafx.event.EventHandler;
  69 import javafx.event.EventType;
  70 import javafx.scene.AccessibleAttribute;
  71 import javafx.scene.AccessibleRole;
  72 import javafx.scene.Node;
  73 import javafx.scene.layout.Region;
  74 import javafx.util.Callback;
  75 
  76 import com.sun.javafx.collections.MappingChange;
  77 import com.sun.javafx.collections.NonIterableChange;
  78 import javafx.css.converter.SizeConverter;
  79 import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;
  80 import com.sun.javafx.scene.control.TableColumnComparatorBase.TableColumnComparator;
  81 import javafx.scene.control.skin.TableViewSkin;
  82 
  83 /**
  84  * The TableView control is designed to visualize an unlimited number of rows
  85  * of data, broken out into columns. A TableView is therefore very similar to the
  86  * {@link ListView} control, with the addition of support for columns. For an
  87  * example on how to create a TableView, refer to the &#39;Creating a TableView&#39;
  88  * control section below.
  89  *
  90  * &lt;p&gt;The TableView control has a number of features, including:
  91  * &lt;ul&gt;
  92  * &lt;li&gt;Powerful {@link TableColumn} API:
  93  *   &lt;ul&gt;
  94  *   &lt;li&gt;Support for {@link TableColumn#cellFactoryProperty() cell factories} to
  95  *      easily customize {@link Cell cell} contents in both rendering and editing
  96  *      states.
  97  *   &lt;li&gt;Specification of {@link TableColumn#minWidthProperty() minWidth}/
  98  *      {@link TableColumn#prefWidthProperty() prefWidth}/
  99  *      {@link TableColumn#maxWidthProperty() maxWidth},
 100  *      and also {@link TableColumn#resizableProperty() fixed width columns}.
 101  *   &lt;li&gt;Width resizing by the user at runtime.
 102  *   &lt;li&gt;Column reordering by the user at runtime.
 103  *   &lt;li&gt;Built-in support for {@link TableColumn#getColumns() column nesting}
 104  *   &lt;/ul&gt;
 105  * &lt;li&gt;Different {@link #columnResizePolicyProperty() resizing policies} to
 106  *      dictate what happens when the user resizes columns.
 107  * &lt;li&gt;Support for {@link #getSortOrder() multiple column sorting} by clicking
 108  *      the column header (hold down Shift keyboard key whilst clicking on a
 109  *      header to sort by multiple columns).
 110  * &lt;/ul&gt;
 111  *
 112  * &lt;p&gt;Note that TableView is intended to be used to visualize data - it is not
 113  * intended to be used for laying out your user interface. If you want to lay
 114  * your user interface out in a grid-like fashion, consider the
 115  * {@link javafx.scene.layout.GridPane} layout instead.&lt;/p&gt;
 116  *
 117  * &lt;h2&gt;Creating a TableView&lt;/h2&gt;
 118  *
 119  * &lt;p&gt;
 120  * Creating a TableView is a multi-step process, and also depends on the
 121  * underlying data model needing to be represented. For this example we&#39;ll use
 122  * an {@literal ObservableList&lt;Person&gt;}, as it is the simplest way of showing data in a
 123  * TableView. The {@code Person} class will consist of a first
 124  * name and last name properties. That is:
 125  *
 126  * &lt;pre&gt; {@code public class Person {
 127  *     private StringProperty firstName;
 128  *     public void setFirstName(String value) { firstNameProperty().set(value); }
 129  *     public String getFirstName() { return firstNameProperty().get(); }
 130  *     public StringProperty firstNameProperty() {
 131  *         if (firstName == null) firstName = new SimpleStringProperty(this, &quot;firstName&quot;);
 132  *         return firstName;
 133  *     }
 134  *
 135  *     private StringProperty lastName;
 136  *     public void setLastName(String value) { lastNameProperty().set(value); }
 137  *     public String getLastName() { return lastNameProperty().get(); }
 138  *     public StringProperty lastNameProperty() {
 139  *         if (lastName == null) lastName = new SimpleStringProperty(this, &quot;lastName&quot;);
 140  *         return lastName;
 141  *     }
 142  *
 143  *     public Person(String firstName, String lastName) {
 144  *         setFirstName(firstName);
 145  *         setLastName(lastName);
 146  *     }
 147  * }}&lt;/pre&gt;
 148  *
 149  * &lt;p&gt;The data we will use for this example is:
 150  *
 151  * &lt;pre&gt; {@code List&lt;Person&gt; members = List.of(
 152  *     new Person(&quot;William&quot;, &quot;Reed&quot;),
 153  *     new Person(&quot;James&quot;, &quot;Michaelson&quot;),
 154  *     new Person(&quot;Julius&quot;, &quot;Dean&quot;));}&lt;/pre&gt;
 155  *
 156  * &lt;p&gt;Firstly, we need to create a data model. As mentioned,
 157  * for this example, we&#39;ll be using an {@literal ObservableList&lt;Person&gt;}:
 158  *
 159  * &lt;pre&gt; {@code ObservableList&lt;Person&gt; teamMembers = FXCollections.observableArrayList(members);}&lt;/pre&gt;
 160  *
 161  * &lt;p&gt;Then we create a TableView instance:
 162  *
 163  * &lt;pre&gt; {@code TableView&lt;Person&gt; table = new TableView&lt;&gt;();
 164  * table.setItems(teamMembers);}&lt;/pre&gt;
 165  *
 166  * &lt;p&gt;With the items set as such, TableView will automatically update whenever
 167  * the &lt;code&gt;teamMembers&lt;/code&gt; list changes. If the items list is available
 168  * before the TableView is instantiated, it is possible to pass it directly into
 169  * the constructor:
 170  *
 171  * &lt;pre&gt; {@code TableView&lt;Person&gt; table = new TableView&lt;&gt;(teamMembers);}&lt;/pre&gt;
 172  *
 173  * &lt;p&gt;At this point we now have a TableView hooked up to observe the
 174  * &lt;code&gt;teamMembers&lt;/code&gt; observableList. The missing ingredient
 175  * now is the means of splitting out the data contained within the model and
 176  * representing it in one or more {@link TableColumn TableColumn} instances. To
 177  * create a two-column TableView to show the firstName and lastName properties,
 178  * we extend the last code sample as follows:
 179  *
 180  * &lt;pre&gt; {@code TableColumn&lt;Person, String&gt; firstNameCol = new TableColumn&lt;&gt;(&quot;First Name&quot;);
 181  * firstNameCol.setCellValueFactory(new PropertyValueFactory&lt;&gt;(members.get(0).firstNameProperty().getName())));
 182  * TableColumn&lt;Person, String&gt; lastNameCol = new TableColumn&lt;&gt;(&quot;Last Name&quot;);
 183  * lastNameCol.setCellValueFactory(new PropertyValueFactory&lt;&gt;(members.get(0).lastNameProperty().getName())));
 184  *
 185  * table.getColumns().setAll(firstNameCol, lastNameCol);}&lt;/pre&gt;
 186  *
 187  * &lt;img src=&quot;doc-files/TableView.png&quot; alt=&quot;Image of the TableView control&quot;&gt;
 188  *
 189  * &lt;p&gt;With the code shown above we have fully defined the minimum properties
 190  * required to create a TableView instance. Running this code  will result in the
 191  * TableView being
 192  * shown with two columns for firstName and lastName. Any other properties of the
 193  * Person class will not be shown, as no TableColumns are defined.
 194  *
 195  * &lt;h3&gt;TableView support for classes that don&#39;t contain properties&lt;/h3&gt;
 196  *
 197  * &lt;p&gt;The code shown above is the shortest possible code for creating a TableView
 198  * when the domain objects are designed with JavaFX properties in mind
 199  * (additionally, {@link javafx.scene.control.cell.PropertyValueFactory} supports
 200  * normal JavaBean properties too, although there is a caveat to this, so refer
 201  * to the class documentation for more information). When this is not the case,
 202  * it is necessary to provide a custom cell value factory. More information
 203  * about cell value factories can be found in the {@link TableColumn} API
 204  * documentation, but briefly, here is how a TableColumn could be specified:
 205  *
 206  * &lt;pre&gt; {@code firstNameCol.setCellValueFactory(new Callback&lt;CellDataFeatures&lt;Person, String&gt;, ObservableValue&lt;String&gt;&gt;() {
 207  *     public ObservableValue&lt;String&gt; call(CellDataFeatures&lt;Person, String&gt; p) {
 208  *         // p.getValue() returns the Person instance for a particular TableView row
 209  *         return p.getValue().firstNameProperty();
 210  *     }
 211  * });
 212  *
 213  * // or with a lambda expression:
 214  * firstNameCol.setCellValueFactory(p -&gt; p.getValue().firstNameProperty());}&lt;/pre&gt;
 215  *
 216  * &lt;h3&gt;TableView Selection / Focus APIs&lt;/h3&gt;
 217  * &lt;p&gt;To track selection and focus, it is necessary to become familiar with the
 218  * {@link SelectionModel} and {@link FocusModel} classes. A TableView has at most
 219  * one instance of each of these classes, available from
 220  * {@link #selectionModelProperty() selectionModel} and
 221  * {@link #focusModelProperty() focusModel} properties respectively.
 222  * Whilst it is possible to use this API to set a new selection model, in
 223  * most circumstances this is not necessary - the default selection and focus
 224  * models should work in most circumstances.
 225  *
 226  * &lt;p&gt;The default {@link SelectionModel} used when instantiating a TableView is
 227  * an implementation of the {@link MultipleSelectionModel} abstract class.
 228  * However, as noted in the API documentation for
 229  * the {@link MultipleSelectionModel#selectionModeProperty() selectionMode}
 230  * property, the default value is {@link SelectionMode#SINGLE}. To enable
 231  * multiple selection in a default TableView instance, it is therefore necessary
 232  * to do the following:
 233  *
 234  * &lt;pre&gt; {@code tableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);}&lt;/pre&gt;
 235  *
 236  * &lt;h3&gt;Customizing TableView Visuals&lt;/h3&gt;
 237  * &lt;p&gt;The visuals of the TableView can be entirely customized by replacing the
 238  * default {@link #rowFactoryProperty() row factory}. A row factory is used to
 239  * generate {@link TableRow} instances, which are used to represent an entire
 240  * row in the TableView.
 241  *
 242  * &lt;p&gt;In many cases, this is not what is desired however, as it is more commonly
 243  * the case that cells be customized on a per-column basis, not a per-row basis.
 244  * It is therefore important to note that a {@link TableRow} is not a
 245  * {@link TableCell}. A  {@link TableRow} is simply a container for zero or more
 246  * {@link TableCell}, and in most circumstances it is more likely that you&#39;ll
 247  * want to create custom TableCells, rather than TableRows. The primary use case
 248  * for creating custom TableRow instances would most probably be to introduce
 249  * some form of column spanning support.
 250  *
 251  * &lt;p&gt;You can create custom {@link TableCell} instances per column by assigning
 252  * the appropriate function to the TableColumn
 253  * {@link TableColumn#cellFactoryProperty() cell factory} property.
 254  *
 255  * &lt;p&gt;See the {@link Cell} class documentation for a more complete
 256  * description of how to write custom Cells.
 257  *
 258  * &lt;h3&gt;Sorting&lt;/h3&gt;
 259  * &lt;p&gt;Prior to JavaFX 8.0, the TableView control would treat the
 260  * {@link #getItems() items} list as the view model, meaning that any changes to
 261  * the list would be immediately reflected visually. TableView would also modify
 262  * the order of this list directly when a user initiated a sort. This meant that
 263  * (again, prior to JavaFX 8.0) it was not possible to have the TableView return
 264  * to an unsorted state (after iterating through ascending and descending
 265  * orders).&lt;/p&gt;
 266  *
 267  * &lt;p&gt;Starting with JavaFX 8.0 (and the introduction of {@link SortedList}), it
 268  * is now possible to have the collection return to the unsorted state when
 269  * there are no columns as part of the TableView
 270  * {@link #getSortOrder() sort order}. To do this, you must create a SortedList
 271  * instance, and bind its
 272  * {@link javafx.collections.transformation.SortedList#comparatorProperty() comparator}
 273  * property to the TableView {@link #comparatorProperty() comparator} property,
 274  * list so:&lt;/p&gt;
 275  *
 276  * &lt;pre&gt; {@code // create a SortedList based on the provided ObservableList
 277  * SortedList sortedList = new SortedList(FXCollections.observableArrayList(2, 1, 3));
 278  *
 279  * // create a TableView with the sorted list set as the items it will show
 280  * final TableView&lt;Integer&gt; tableView = new TableView&lt;&gt;(sortedList);
 281  *
 282  * // bind the sortedList comparator to the TableView comparator
 283  * sortedList.comparatorProperty().bind(tableView.comparatorProperty());
 284  *
 285  * // Don&#39;t forget to define columns!}&lt;/pre&gt;
 286  *
 287  * &lt;h3&gt;Editing&lt;/h3&gt;
 288  * &lt;p&gt;This control supports inline editing of values, and this section attempts to
 289  * give an overview of the available APIs and how you should use them.&lt;/p&gt;
 290  *
 291  * &lt;p&gt;Firstly, cell editing most commonly requires a different user interface
 292  * than when a cell is not being edited. This is the responsibility of the
 293  * {@link Cell} implementation being used. For TableView, it is highly
 294  * recommended that editing be
 295  * {@link javafx.scene.control.TableColumn#cellFactoryProperty() per-TableColumn},
 296  * rather than {@link #rowFactoryProperty() per row}, as more often than not
 297  * you want users to edit each column value differently, and this approach allows
 298  * for editors specific to each column. It is your choice whether the cell is
 299  * permanently in an editing state (e.g. this is common for {@link CheckBox} cells),
 300  * or to switch to a different UI when editing begins (e.g. when a double-click
 301  * is received on a cell).&lt;/p&gt;
 302  *
 303  * &lt;p&gt;To know when editing has been requested on a cell,
 304  * simply override the {@link javafx.scene.control.Cell#startEdit()} method, and
 305  * update the cell {@link javafx.scene.control.Cell#textProperty() text} and
 306  * {@link javafx.scene.control.Cell#graphicProperty() graphic} properties as
 307  * appropriate (e.g. set the text to null and set the graphic to be a
 308  * {@link TextField}). Additionally, you should also override
 309  * {@link Cell#cancelEdit()} to reset the UI back to its original visual state
 310  * when the editing concludes. In both cases it is important that you also
 311  * ensure that you call the super method to have the cell perform all duties it
 312  * must do to enter or exit its editing mode.&lt;/p&gt;
 313  *
 314  * &lt;p&gt;Once your cell is in an editing state, the next thing you are most probably
 315  * interested in is how to commit or cancel the editing that is taking place. This is your
 316  * responsibility as the cell factory provider. Your cell implementation will know
 317  * when the editing is over, based on the user input (e.g. when the user presses
 318  * the Enter or ESC keys on their keyboard). When this happens, it is your
 319  * responsibility to call {@link Cell#commitEdit(Object)} or
 320  * {@link Cell#cancelEdit()}, as appropriate.&lt;/p&gt;
 321  *
 322  * &lt;p&gt;When you call {@link Cell#commitEdit(Object)} an event is fired to the
 323  * TableView, which you can observe by adding an {@link EventHandler} via
 324  * {@link TableColumn#setOnEditCommit(javafx.event.EventHandler)}. Similarly,
 325  * you can also observe edit events for
 326  * {@link TableColumn#setOnEditStart(javafx.event.EventHandler) edit start}
 327  * and {@link TableColumn#setOnEditCancel(javafx.event.EventHandler) edit cancel}.&lt;/p&gt;
 328  *
 329  * &lt;p&gt;By default the TableColumn edit commit handler is non-null, with a default
 330  * handler that attempts to overwrite the property value for the
 331  * item in the currently-being-edited row. It is able to do this as the
 332  * {@link Cell#commitEdit(Object)} method is passed in the new value, and this
 333  * is passed along to the edit commit handler via the
 334  * {@link javafx.scene.control.TableColumn.CellEditEvent CellEditEvent} that is
 335  * fired. It is simply a matter of calling
 336  * {@link javafx.scene.control.TableColumn.CellEditEvent#getNewValue()} to
 337  * retrieve this value.
 338  *
 339  * &lt;p&gt;It is very important to note that if you call
 340  * {@link TableColumn#setOnEditCommit(javafx.event.EventHandler)} with your own
 341  * {@link EventHandler}, then you will be removing the default handler. Unless
 342  * you then handle the writeback to the property (or the relevant data source),
 343  * nothing will happen. You can work around this by using the
 344  * {@link TableColumn#addEventHandler(javafx.event.EventType, javafx.event.EventHandler)}
 345  * method to add a {@link TableColumn#editCommitEvent()} {@link EventType} with
 346  * your desired {@link EventHandler} as the second argument. Using this method,
 347  * you will not replace the default implementation, but you will be notified when
 348  * an edit commit has occurred.&lt;/p&gt;
 349  *
 350  * &lt;p&gt;Hopefully this summary answers some of the commonly asked questions.
 351  * Fortunately, JavaFX ships with a number of pre-built cell factories that
 352  * handle all the editing requirements on your behalf. You can find these
 353  * pre-built cell factories in the javafx.scene.control.cell package.&lt;/p&gt;
 354  *
 355  * @see TableColumn
 356  * @see TablePosition
 357  * @param &lt;S&gt; The type of the objects contained within the TableView items list.
 358  * @since JavaFX 2.0
 359  */
 360 @DefaultProperty(&quot;items&quot;)
 361 public class TableView&lt;S&gt; extends Control {
 362 
 363     /***************************************************************************
 364      *                                                                         *
 365      * Static properties and methods                                           *
 366      *                                                                         *
 367      **************************************************************************/
 368 
 369     // strings used to communicate via the TableView properties map between
 370     // the control and the skin. Because they are private here, the strings
 371     // are also duplicated in the TableViewSkin class - so any changes to these
 372     // strings must also be duplicated there
 373     static final String SET_CONTENT_WIDTH = &quot;TableView.contentWidth&quot;;
 374 
 375     /**
 376      * &lt;p&gt;Very simple resize policy that just resizes the specified column by the
 377      * provided delta and shifts all other columns (to the right of the given column)
 378      * further to the right (when the delta is positive) or to the left (when the
 379      * delta is negative).
 380      *
 381      * &lt;p&gt;It also handles the case where we have nested columns by sharing the new space,
 382      * or subtracting the removed space, evenly between all immediate children columns.
 383      * Of course, the immediate children may themselves be nested, and they would
 384      * then use this policy on their children.
 385      */
 386     public static final Callback&lt;ResizeFeatures, Boolean&gt; UNCONSTRAINED_RESIZE_POLICY = new Callback&lt;ResizeFeatures, Boolean&gt;() {
 387         @Override public String toString() {
 388             return &quot;unconstrained-resize&quot;;
 389         }
 390 
 391         @Override public Boolean call(ResizeFeatures prop) {
 392             double result = TableUtil.resize(prop.getColumn(), prop.getDelta());
 393             return Double.compare(result, 0.0) == 0;
 394         }
 395     };
 396 
 397     /**
 398      * &lt;p&gt;Simple policy that ensures the width of all visible leaf columns in
 399      * this table sum up to equal the width of the table itself.
 400      *
 401      * &lt;p&gt;When the user resizes a column width with this policy, the table automatically
 402      * adjusts the width of the right hand side columns. When the user increases a
 403      * column width, the table decreases the width of the rightmost column until it
 404      * reaches its minimum width. Then it decreases the width of the second
 405      * rightmost column until it reaches minimum width and so on. When all right
 406      * hand side columns reach minimum size, the user cannot increase the size of
 407      * resized column any more.
 408      */
 409     public static final Callback&lt;ResizeFeatures, Boolean&gt; CONSTRAINED_RESIZE_POLICY = new Callback&lt;ResizeFeatures, Boolean&gt;() {
 410 
 411         private boolean isFirstRun = true;
 412 
 413         @Override public String toString() {
 414             return &quot;constrained-resize&quot;;
 415         }
 416 
 417         @Override public Boolean call(ResizeFeatures prop) {
 418             TableView&lt;?&gt; table = prop.getTable();
 419             List&lt;? extends TableColumnBase&lt;?,?&gt;&gt; visibleLeafColumns = table.getVisibleLeafColumns();
 420             Boolean result = TableUtil.constrainedResize(prop,
 421                                                isFirstRun,
 422                                                table.contentWidth,
 423                                                visibleLeafColumns);
 424             isFirstRun = ! isFirstRun ? false : ! result;
 425             return result;
 426         }
 427     };
 428 
 429     /**
 430      * The default {@link #sortPolicyProperty() sort policy} that this TableView
 431      * will use if no other policy is specified. The sort policy is a simple
 432      * {@link Callback} that accepts a TableView as the sole argument and expects
 433      * a Boolean response representing whether the sort succeeded or not. A Boolean
 434      * response of true represents success, and a response of false (or null) will
 435      * be considered to represent failure.
 436      * @since JavaFX 8.0
 437      */
 438     public static final Callback&lt;TableView, Boolean&gt; DEFAULT_SORT_POLICY = new Callback&lt;TableView, Boolean&gt;() {
 439         @Override public Boolean call(TableView table) {
 440             try {
 441                 ObservableList&lt;?&gt; itemsList = table.getItems();
 442                 if (itemsList instanceof SortedList) {
 443                     // it is the responsibility of the SortedList to bind to the
 444                     // comparator provided by the TableView. However, we don&#39;t
 445                     // want to fail the sort (which would put the UI in an
 446                     // inconsistent state), so we return true here, but only if
 447                     // the SortedList has its comparator bound to the TableView
 448                     // comparator property.
 449                     SortedList sortedList = (SortedList) itemsList;
 450                     boolean comparatorsBound = sortedList.comparatorProperty().
 451                             isEqualTo(table.comparatorProperty()).get();
 452 
 453                     if (! comparatorsBound) {
 454                         // this isn&#39;t a good situation to be in, so lets log it
 455                         // out in case the developer is unaware
 456                         if (Logging.getControlsLogger().isLoggable(Level.INFO)) {
 457                             String s = &quot;TableView items list is a SortedList, but the SortedList &quot; +
 458                                     &quot;comparator should be bound to the TableView comparator for &quot; +
 459                                     &quot;sorting to be enabled (e.g. &quot; +
 460                                     &quot;sortedList.comparatorProperty().bind(tableView.comparatorProperty());).&quot;;
 461                             Logging.getControlsLogger().info(s);
 462                         }
 463                     }
 464                     return comparatorsBound;
 465                 } else {
 466                     if (itemsList == null || itemsList.isEmpty()) {
 467                         // sorting is not supported on null or empty lists
 468                         return true;
 469                     }
 470 
 471                     Comparator comparator = table.getComparator();
 472                     if (comparator == null) {
 473                         return true;
 474                     }
 475 
 476                     // otherwise we attempt to do a manual sort, and if successful
 477                     // we return true
 478                     FXCollections.sort(itemsList, comparator);
 479                     return true;
 480                 }
 481             } catch (UnsupportedOperationException e) {
 482                 // TODO might need to support other exception types including:
 483                 // ClassCastException - if the class of the specified element prevents it from being added to this list
 484                 // NullPointerException - if the specified element is null and this list does not permit null elements
 485                 // IllegalArgumentException - if some property of this element prevents it from being added to this list
 486 
 487                 // If we are here the list does not support sorting, so we gracefully
 488                 // fail the sort request and ensure the UI is put back to its previous
 489                 // state. This is handled in the code that calls the sort policy.
 490 
 491                 return false;
 492             }
 493         }
 494     };
 495 
 496 
 497 
 498     /***************************************************************************
 499      *                                                                         *
 500      * Constructors                                                            *
 501      *                                                                         *
 502      **************************************************************************/
 503 
 504     /**
 505      * Creates a default TableView control with no content.
 506      *
 507      * &lt;p&gt;Refer to the {@link TableView} class documentation for details on the
 508      * default state of other properties.
 509      */
 510     public TableView() {
 511         this(FXCollections.&lt;S&gt;observableArrayList());
 512     }
 513 
 514     /**
 515      * Creates a TableView with the content provided in the items ObservableList.
 516      * This also sets up an observer such that any changes to the items list
 517      * will be immediately reflected in the TableView itself.
 518      *
 519      * &lt;p&gt;Refer to the {@link TableView} class documentation for details on the
 520      * default state of other properties.
 521      *
 522      * @param items The items to insert into the TableView, and the list to watch
 523      *          for changes (to automatically show in the TableView).
 524      */
 525     public TableView(ObservableList&lt;S&gt; items) {
 526         getStyleClass().setAll(DEFAULT_STYLE_CLASS);
 527         setAccessibleRole(AccessibleRole.TABLE_VIEW);
 528 
 529         // we quite happily accept items to be null here
 530         setItems(items);
 531 
 532         // install default selection and focus models
 533         // it&#39;s unlikely this will be changed by many users.
 534         setSelectionModel(new TableViewArrayListSelectionModel&lt;S&gt;(this));
 535         setFocusModel(new TableViewFocusModel&lt;S&gt;(this));
 536 
 537         // we watch the columns list, such that when it changes we can update
 538         // the leaf columns and visible leaf columns lists (which are read-only).
 539         getColumns().addListener(weakColumnsObserver);
 540 
 541         // watch for changes to the sort order list - and when it changes run
 542         // the sort method.
 543         getSortOrder().addListener((ListChangeListener&lt;TableColumn&lt;S, ?&gt;&gt;) c -&gt; {
 544             doSort(TableUtil.SortEventType.SORT_ORDER_CHANGE, c);
 545         });
 546 
 547         // We&#39;re watching for changes to the content width such
 548         // that the resize policy can be run if necessary. This comes from
 549         // TreeViewSkin.
 550         getProperties().addListener(new MapChangeListener&lt;Object, Object&gt;() {
 551             @Override
 552             public void onChanged(Change&lt;? extends Object, ? extends Object&gt; c) {
 553                 if (c.wasAdded() &amp;&amp; SET_CONTENT_WIDTH.equals(c.getKey())) {
 554                     if (c.getValueAdded() instanceof Number) {
 555                         setContentWidth((Double) c.getValueAdded());
 556                     }
 557                     getProperties().remove(SET_CONTENT_WIDTH);
 558                 }
 559             }
 560         });
 561 
 562         isInited = true;
 563     }
 564 
 565 
 566 
 567     /***************************************************************************
 568      *                                                                         *
 569      * Instance Variables                                                      *
 570      *                                                                         *
 571      **************************************************************************/
 572 
 573     // this is the only publicly writable list for columns. This represents the
 574     // columns as they are given initially by the developer.
 575     private final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; columns = FXCollections.observableArrayList();
 576 
 577     // Finally, as convenience, we also have an observable list that contains
 578     // only the leaf columns that are currently visible.
 579     private final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; visibleLeafColumns = FXCollections.observableArrayList();
 580     private final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; unmodifiableVisibleLeafColumns = FXCollections.unmodifiableObservableList(visibleLeafColumns);
 581 
 582 
 583     // Allows for multiple column sorting based on the order of the TableColumns
 584     // in this observableArrayList. Each TableColumn is responsible for whether it is
 585     // sorted using ascending or descending order.
 586     private ObservableList&lt;TableColumn&lt;S,?&gt;&gt; sortOrder = FXCollections.observableArrayList();
 587 
 588     // width of VirtualFlow minus the vbar width
 589     private double contentWidth;
 590 
 591     // Used to minimise the amount of work performed prior to the table being
 592     // completely initialised. In particular it reduces the amount of column
 593     // resize operations that occur, which slightly improves startup time.
 594     private boolean isInited = false;
 595 
 596 
 597 
 598     /***************************************************************************
 599      *                                                                         *
 600      * Callbacks and Events                                                    *
 601      *                                                                         *
 602      **************************************************************************/
 603 
 604     private final ListChangeListener&lt;TableColumn&lt;S,?&gt;&gt; columnsObserver = new ListChangeListener&lt;TableColumn&lt;S,?&gt;&gt;() {
 605         @Override public void onChanged(Change&lt;? extends TableColumn&lt;S,?&gt;&gt; c) {
 606             final List&lt;TableColumn&lt;S,?&gt;&gt; columns = getColumns();
 607 
 608             // Fix for RT-39822 - don&#39;t allow the same column to be installed twice
 609             while (c.next()) {
 610                 if (c.wasAdded()) {
 611                     List&lt;TableColumn&lt;S,?&gt;&gt; duplicates = new ArrayList&lt;&gt;();
 612                     for (TableColumn&lt;S,?&gt; addedColumn : c.getAddedSubList()) {
 613                         if (addedColumn == null) continue;
 614 
 615                         int count = 0;
 616                         for (TableColumn&lt;S,?&gt; column : columns) {
 617                             if (addedColumn == column) {
 618                                 count++;
 619                             }
 620                         }
 621 
 622                         if (count &gt; 1) {
 623                             duplicates.add(addedColumn);
 624                         }
 625                     }
 626 
 627                     if (!duplicates.isEmpty()) {
 628                         String titleList = &quot;&quot;;
 629                         for (TableColumn&lt;S,?&gt; dupe : duplicates) {
 630                             titleList += &quot;&#39;&quot; + dupe.getText() + &quot;&#39;, &quot;;
 631                         }
 632                         throw new IllegalStateException(&quot;Duplicate TableColumns detected in TableView columns list with titles &quot; + titleList);
 633                     }
 634                 }
 635             }
 636             c.reset();
 637 
 638             // Fix for RT-15194: Need to remove removed columns from the
 639             // sortOrder list.
 640             List&lt;TableColumn&lt;S,?&gt;&gt; toRemove = new ArrayList&lt;&gt;();
 641             while (c.next()) {
 642                 final List&lt;? extends TableColumn&lt;S, ?&gt;&gt; removed = c.getRemoved();
 643                 final List&lt;? extends TableColumn&lt;S, ?&gt;&gt; added = c.getAddedSubList();
 644 
 645                 if (c.wasRemoved()) {
 646                     toRemove.addAll(removed);
 647                     for (TableColumn&lt;S,?&gt; tc : removed) {
 648                         tc.setTableView(null);
 649                     }
 650                 }
 651 
 652                 if (c.wasAdded()) {
 653                     toRemove.removeAll(added);
 654                     for (TableColumn&lt;S,?&gt; tc : added) {
 655                         tc.setTableView(TableView.this);
 656                     }
 657                 }
 658 
 659                 // set up listeners
 660                 TableUtil.removeColumnsListener(removed, weakColumnsObserver);
 661                 TableUtil.addColumnsListener(added, weakColumnsObserver);
 662 
 663                 TableUtil.removeTableColumnListener(c.getRemoved(),
 664                         weakColumnVisibleObserver,
 665                         weakColumnSortableObserver,
 666                         weakColumnSortTypeObserver,
 667                         weakColumnComparatorObserver);
 668                 TableUtil.addTableColumnListener(c.getAddedSubList(),
 669                         weakColumnVisibleObserver,
 670                         weakColumnSortableObserver,
 671                         weakColumnSortTypeObserver,
 672                         weakColumnComparatorObserver);
 673             }
 674 
 675             // We don&#39;t maintain a bind for leafColumns, we simply call this update
 676             // function behind the scenes in the appropriate places.
 677             updateVisibleLeafColumns();
 678 
 679             sortOrder.removeAll(toRemove);
 680 
 681             // Fix for RT-38892.
 682             final TableViewFocusModel&lt;S&gt; fm = getFocusModel();
 683             final TableViewSelectionModel&lt;S&gt; sm = getSelectionModel();
 684             c.reset();
 685 
 686             // we need to collect together all removed and all added columns, because
 687             // the code below works on the actually removed columns. If we perform
 688             // the code within this while loop, we&#39;ll be deselecting columns that
 689             // should be deselected (because they have just moved place, for example).
 690             List&lt;TableColumn&lt;S,?&gt;&gt; removed = new ArrayList&lt;&gt;();
 691             List&lt;TableColumn&lt;S,?&gt;&gt; added = new ArrayList&lt;&gt;();
 692             while (c.next()) {
 693                 if (c.wasRemoved()) {
 694                     removed.addAll(c.getRemoved());
 695                 }
 696                 if (c.wasAdded()) {
 697                     added.addAll(c.getAddedSubList());
 698                 }
 699             }
 700             removed.removeAll(added);
 701 
 702             // Fix for focus - we simply move focus to a cell to the left
 703             // of the focused cell if the focused cell was located within
 704             // a column that has been removed.
 705             if (fm != null) {
 706                 TablePosition&lt;S, ?&gt; focusedCell = fm.getFocusedCell();
 707                 boolean match = false;
 708                 for (TableColumn&lt;S, ?&gt; tc : removed) {
 709                     match = focusedCell != null &amp;&amp; focusedCell.getTableColumn() == tc;
 710                     if (match) {
 711                         break;
 712                     }
 713                 }
 714 
 715                 if (match) {
 716                     int matchingColumnIndex = lastKnownColumnIndex.getOrDefault(focusedCell.getTableColumn(), 0);
 717                     int newFocusColumnIndex =
 718                             matchingColumnIndex == 0 ? 0 :
 719                             Math.min(getVisibleLeafColumns().size() - 1, matchingColumnIndex - 1);
 720                     fm.focus(focusedCell.getRow(), getVisibleLeafColumn(newFocusColumnIndex));
 721                 }
 722             }
 723 
 724             // Fix for selection - we remove selection from all cells that
 725             // were within the removed column.
 726             if (sm != null) {
 727                 List&lt;TablePosition&gt; selectedCells = new ArrayList&lt;&gt;(sm.getSelectedCells());
 728                 for (TablePosition selectedCell : selectedCells) {
 729                     boolean match = false;
 730                     for (TableColumn&lt;S, ?&gt; tc : removed) {
 731                         match = selectedCell != null &amp;&amp; selectedCell.getTableColumn() == tc;
 732                         if (match) break;
 733                     }
 734 
 735                     if (match) {
 736                         // we can&#39;t just use the selectedCell.getTableColumn(), as that
 737                         // column no longer exists and therefore its index is not correct.
 738                         int matchingColumnIndex = lastKnownColumnIndex.getOrDefault(selectedCell.getTableColumn(), -1);
 739                         if (matchingColumnIndex == -1) continue;
 740 
 741                         if (sm instanceof TableViewArrayListSelectionModel) {
 742                             // Also, because the table column no longer exists in the columns
 743                             // list at this point, we can&#39;t just call:
 744                             // sm.clearSelection(selectedCell.getRow(), selectedCell.getTableColumn());
 745                             // as the tableColumn would map to an index of -1, which means that
 746                             // selection will not be cleared. Instead, we have to create
 747                             // a new TablePosition with a fixed column index and use that.
 748                             TablePosition&lt;S,?&gt; fixedTablePosition =
 749                                     new TablePosition&lt;&gt;(TableView.this,
 750                                             selectedCell.getRow(),
 751                                             selectedCell.getTableColumn());
 752                             fixedTablePosition.fixedColumnIndex = matchingColumnIndex;
 753 
 754                             ((TableViewArrayListSelectionModel)sm).clearSelection(fixedTablePosition);
 755                         } else {
 756                             sm.clearSelection(selectedCell.getRow(), selectedCell.getTableColumn());
 757                         }
 758                     }
 759                 }
 760             }
 761 
 762 
 763             // update the lastKnownColumnIndex map
 764             lastKnownColumnIndex.clear();
 765             for (TableColumn&lt;S,?&gt; tc : getColumns()) {
 766                 int index = getVisibleLeafIndex(tc);
 767                 if (index &gt; -1) {
 768                     lastKnownColumnIndex.put(tc, index);
 769                 }
 770             }
 771         }
 772     };
 773 
 774     private final WeakHashMap&lt;TableColumn&lt;S,?&gt;, Integer&gt; lastKnownColumnIndex = new WeakHashMap&lt;&gt;();
 775 
 776     private final InvalidationListener columnVisibleObserver = valueModel -&gt; {
 777         updateVisibleLeafColumns();
 778     };
 779 
 780     private final InvalidationListener columnSortableObserver = valueModel -&gt; {
 781         Object col = ((Property&lt;?&gt;)valueModel).getBean();
 782         if (! getSortOrder().contains(col)) return;
 783         doSort(TableUtil.SortEventType.COLUMN_SORTABLE_CHANGE, col);
 784     };
 785 
 786     private final InvalidationListener columnSortTypeObserver = valueModel -&gt; {
 787         Object col = ((Property&lt;?&gt;)valueModel).getBean();
 788         if (! getSortOrder().contains(col)) return;
 789         doSort(TableUtil.SortEventType.COLUMN_SORT_TYPE_CHANGE, col);
 790     };
 791 
 792     private final InvalidationListener columnComparatorObserver = valueModel -&gt; {
 793         Object col = ((Property&lt;?&gt;)valueModel).getBean();
 794         if (! getSortOrder().contains(col)) return;
 795         doSort(TableUtil.SortEventType.COLUMN_COMPARATOR_CHANGE, col);
 796     };
 797 
 798     /* proxy pseudo-class state change from selectionModel&#39;s cellSelectionEnabledProperty */
 799     private final InvalidationListener cellSelectionModelInvalidationListener = o -&gt; {
 800         final boolean isCellSelection = ((BooleanProperty)o).get();
 801         pseudoClassStateChanged(PSEUDO_CLASS_CELL_SELECTION,  isCellSelection);
 802         pseudoClassStateChanged(PSEUDO_CLASS_ROW_SELECTION,  !isCellSelection);
 803     };
 804 
 805 
 806     private final WeakInvalidationListener weakColumnVisibleObserver =
 807             new WeakInvalidationListener(columnVisibleObserver);
 808 
 809     private final WeakInvalidationListener weakColumnSortableObserver =
 810             new WeakInvalidationListener(columnSortableObserver);
 811 
 812     private final WeakInvalidationListener weakColumnSortTypeObserver =
 813             new WeakInvalidationListener(columnSortTypeObserver);
 814 
 815     private final WeakInvalidationListener weakColumnComparatorObserver =
 816             new WeakInvalidationListener(columnComparatorObserver);
 817 
 818     private final WeakListChangeListener&lt;TableColumn&lt;S,?&gt;&gt; weakColumnsObserver =
 819             new WeakListChangeListener&lt;TableColumn&lt;S,?&gt;&gt;(columnsObserver);
 820 
 821     private final WeakInvalidationListener weakCellSelectionModelInvalidationListener =
 822             new WeakInvalidationListener(cellSelectionModelInvalidationListener);
 823 
 824 
 825 
 826     /***************************************************************************
 827      *                                                                         *
 828      * Properties                                                              *
 829      *                                                                         *
 830      **************************************************************************/
 831 
 832 
 833     // --- Items
 834     /**
 835      * The underlying data model for the TableView. Note that it has a generic
 836      * type that must match the type of the TableView itself.
 837      * @return the items property
 838      */
 839     public final ObjectProperty&lt;ObservableList&lt;S&gt;&gt; itemsProperty() { return items; }
 840     private ObjectProperty&lt;ObservableList&lt;S&gt;&gt; items =
 841         new SimpleObjectProperty&lt;ObservableList&lt;S&gt;&gt;(this, &quot;items&quot;) {
 842             WeakReference&lt;ObservableList&lt;S&gt;&gt; oldItemsRef;
 843 
 844             @Override protected void invalidated() {
 845                 final ObservableList&lt;S&gt; oldItems = oldItemsRef == null ? null : oldItemsRef.get();
 846                 final ObservableList&lt;S&gt; newItems = getItems();
 847 
 848                 // Fix for RT-36425
 849                 if (newItems != null &amp;&amp; newItems == oldItems) {
 850                     return;
 851                 }
 852 
 853                 // Fix for RT-35763
 854                 if (! (newItems instanceof SortedList)) {
 855                     getSortOrder().clear();
 856                 }
 857 
 858                 oldItemsRef = new WeakReference&lt;&gt;(newItems);
 859             }
 860         };
 861     public final void setItems(ObservableList&lt;S&gt; value) { itemsProperty().set(value); }
 862     public final ObservableList&lt;S&gt; getItems() {return items.get(); }
 863 
 864 
 865     // --- Table menu button visible
 866     private BooleanProperty tableMenuButtonVisible;
 867     /**
 868      * This controls whether a menu button is available when the user clicks
 869      * in a designated space within the TableView, within which is a radio menu
 870      * item for each TableColumn in this table. This menu allows for the user to
 871      * show and hide all TableColumns easily.
 872      * @return the tableMenuButtonVisible property
 873      */
 874     public final BooleanProperty tableMenuButtonVisibleProperty() {
 875         if (tableMenuButtonVisible == null) {
 876             tableMenuButtonVisible = new SimpleBooleanProperty(this, &quot;tableMenuButtonVisible&quot;);
 877         }
 878         return tableMenuButtonVisible;
 879     }
 880     public final void setTableMenuButtonVisible (boolean value) {
 881         tableMenuButtonVisibleProperty().set(value);
 882     }
 883     public final boolean isTableMenuButtonVisible() {
 884         return tableMenuButtonVisible == null ? false : tableMenuButtonVisible.get();
 885     }
 886 
 887 
 888     // --- Column Resize Policy
 889     private ObjectProperty&lt;Callback&lt;ResizeFeatures, Boolean&gt;&gt; columnResizePolicy;
 890     public final void setColumnResizePolicy(Callback&lt;ResizeFeatures, Boolean&gt; callback) {
 891         columnResizePolicyProperty().set(callback);
 892     }
 893     public final Callback&lt;ResizeFeatures, Boolean&gt; getColumnResizePolicy() {
 894         return columnResizePolicy == null ? UNCONSTRAINED_RESIZE_POLICY : columnResizePolicy.get();
 895     }
 896 
 897     /**
 898      * Called when the user completes a column-resize operation. The two most common
 899      * policies are available as static functions in the TableView class:
 900      * {@link #UNCONSTRAINED_RESIZE_POLICY} and {@link #CONSTRAINED_RESIZE_POLICY}.
 901      * @return columnResizePolicy property
 902      */
 903     public final ObjectProperty&lt;Callback&lt;ResizeFeatures, Boolean&gt;&gt; columnResizePolicyProperty() {
 904         if (columnResizePolicy == null) {
 905             columnResizePolicy = new SimpleObjectProperty&lt;Callback&lt;ResizeFeatures, Boolean&gt;&gt;(this, &quot;columnResizePolicy&quot;, UNCONSTRAINED_RESIZE_POLICY) {
 906                 private Callback&lt;ResizeFeatures, Boolean&gt; oldPolicy;
 907 
 908                 @Override protected void invalidated() {
 909                     if (isInited) {
 910                         get().call(new ResizeFeatures(TableView.this, null, 0.0));
 911 
 912                         if (oldPolicy != null) {
 913                             PseudoClass state = PseudoClass.getPseudoClass(oldPolicy.toString());
 914                             pseudoClassStateChanged(state, false);
 915                         }
 916                         if (get() != null) {
 917                             PseudoClass state = PseudoClass.getPseudoClass(get().toString());
 918                             pseudoClassStateChanged(state, true);
 919                         }
 920                         oldPolicy = get();
 921                     }
 922                 }
 923             };
 924         }
 925         return columnResizePolicy;
 926     }
 927 
 928 
 929     // --- Row Factory
 930     private ObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt;&gt; rowFactory;
 931 
 932     /**
 933      * A function which produces a TableRow. The system is responsible for
 934      * reusing TableRows. Return from this function a TableRow which
 935      * might be usable for representing a single row in a TableView.
 936      * &lt;p&gt;
 937      * Note that a TableRow is &lt;b&gt;not&lt;/b&gt; a TableCell. A TableRow is
 938      * simply a container for a TableCell, and in most circumstances it is more
 939      * likely that you&#39;ll want to create custom TableCells, rather than
 940      * TableRows. The primary use case for creating custom TableRow
 941      * instances would most probably be to introduce some form of column
 942      * spanning support.
 943      * &lt;p&gt;
 944      * You can create custom TableCell instances per column by assigning the
 945      * appropriate function to the cellFactory property in the TableColumn class.
 946      * @return rowFactory property
 947      */
 948     public final ObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt;&gt; rowFactoryProperty() {
 949         if (rowFactory == null) {
 950             rowFactory = new SimpleObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt;&gt;(this, &quot;rowFactory&quot;);
 951         }
 952         return rowFactory;
 953     }
 954     public final void setRowFactory(Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt; value) {
 955         rowFactoryProperty().set(value);
 956     }
 957     public final Callback&lt;TableView&lt;S&gt;, TableRow&lt;S&gt;&gt; getRowFactory() {
 958         return rowFactory == null ? null : rowFactory.get();
 959     }
 960 
 961 
 962     // --- Placeholder Node
 963     private ObjectProperty&lt;Node&gt; placeholder;
 964     /**
 965      * This Node is shown to the user when the table has no content to show.
 966      * This may be the case because the table model has no data in the first
 967      * place, that a filter has been applied to the table model, resulting
 968      * in there being nothing to show the user, or that there are no currently
 969      * visible columns.
 970      * @return placeholder property
 971      */
 972     public final ObjectProperty&lt;Node&gt; placeholderProperty() {
 973         if (placeholder == null) {
 974             placeholder = new SimpleObjectProperty&lt;Node&gt;(this, &quot;placeholder&quot;);
 975         }
 976         return placeholder;
 977     }
 978     public final void setPlaceholder(Node value) {
 979         placeholderProperty().set(value);
 980     }
 981     public final Node getPlaceholder() {
 982         return placeholder == null ? null : placeholder.get();
 983     }
 984 
 985 
 986     // --- Selection Model
 987     private ObjectProperty&lt;TableViewSelectionModel&lt;S&gt;&gt; selectionModel
 988             = new SimpleObjectProperty&lt;TableViewSelectionModel&lt;S&gt;&gt;(this, &quot;selectionModel&quot;) {
 989 
 990         TableViewSelectionModel&lt;S&gt; oldValue = null;
 991 
 992         @Override protected void invalidated() {
 993 
 994             if (oldValue != null) {
 995                 oldValue.cellSelectionEnabledProperty().removeListener(weakCellSelectionModelInvalidationListener);
 996 
 997                 if (oldValue instanceof TableViewArrayListSelectionModel) {
 998                     ((TableViewArrayListSelectionModel)oldValue).dispose();
 999                 }
1000             }
1001 
1002             oldValue = get();
1003 
1004             if (oldValue != null) {
1005                 oldValue.cellSelectionEnabledProperty().addListener(weakCellSelectionModelInvalidationListener);
1006                 // fake an invalidation to ensure updated pseudo-class state
1007                 weakCellSelectionModelInvalidationListener.invalidated(oldValue.cellSelectionEnabledProperty());
1008             }
1009         }
1010     };
1011 
1012     /**
1013      * The SelectionModel provides the API through which it is possible
1014      * to select single or multiple items within a TableView, as  well as inspect
1015      * which items have been selected by the user. Note that it has a generic
1016      * type that must match the type of the TableView itself.
1017      * @return selectionModel property
1018      */
1019     public final ObjectProperty&lt;TableViewSelectionModel&lt;S&gt;&gt; selectionModelProperty() {
1020         return selectionModel;
1021     }
1022     public final void setSelectionModel(TableViewSelectionModel&lt;S&gt; value) {
1023         selectionModelProperty().set(value);
1024     }
1025 
1026     public final TableViewSelectionModel&lt;S&gt; getSelectionModel() {
1027         return selectionModel.get();
1028     }
1029 
1030 
1031     // --- Focus Model
1032     private ObjectProperty&lt;TableViewFocusModel&lt;S&gt;&gt; focusModel;
1033     public final void setFocusModel(TableViewFocusModel&lt;S&gt; value) {
1034         focusModelProperty().set(value);
1035     }
1036     public final TableViewFocusModel&lt;S&gt; getFocusModel() {
1037         return focusModel == null ? null : focusModel.get();
1038     }
1039     /**
1040      * Represents the currently-installed {@link TableViewFocusModel} for this
1041      * TableView. Under almost all circumstances leaving this as the default
1042      * focus model will suffice.
1043      * @return focusModel property
1044      */
1045     public final ObjectProperty&lt;TableViewFocusModel&lt;S&gt;&gt; focusModelProperty() {
1046         if (focusModel == null) {
1047             focusModel = new SimpleObjectProperty&lt;TableViewFocusModel&lt;S&gt;&gt;(this, &quot;focusModel&quot;);
1048         }
1049         return focusModel;
1050     }
1051 
1052 
1053 //    // --- Span Model
1054 //    private ObjectProperty&lt;SpanModel&lt;S&gt;&gt; spanModel
1055 //            = new SimpleObjectProperty&lt;SpanModel&lt;S&gt;&gt;(this, &quot;spanModel&quot;) {
1056 //
1057 //        @Override protected void invalidated() {
1058 //            ObservableList&lt;String&gt; styleClass = getStyleClass();
1059 //            if (getSpanModel() == null) {
1060 //                styleClass.remove(CELL_SPAN_TABLE_VIEW_STYLE_CLASS);
1061 //            } else if (! styleClass.contains(CELL_SPAN_TABLE_VIEW_STYLE_CLASS)) {
1062 //                styleClass.add(CELL_SPAN_TABLE_VIEW_STYLE_CLASS);
1063 //            }
1064 //        }
1065 //    };
1066 //
1067 //    public final ObjectProperty&lt;SpanModel&lt;S&gt;&gt; spanModelProperty() {
1068 //        return spanModel;
1069 //    }
1070 //    public final void setSpanModel(SpanModel&lt;S&gt; value) {
1071 //        spanModelProperty().set(value);
1072 //    }
1073 //
1074 //    public final SpanModel&lt;S&gt; getSpanModel() {
1075 //        return spanModel.get();
1076 //    }
1077 
1078     // --- Editable
1079     private BooleanProperty editable;
1080     public final void setEditable(boolean value) {
1081         editableProperty().set(value);
1082     }
1083     public final boolean isEditable() {
1084         return editable == null ? false : editable.get();
1085     }
1086     /**
1087      * Specifies whether this TableView is editable - only if the TableView, the
1088      * TableColumn (if applicable) and the TableCells within it are both
1089      * editable will a TableCell be able to go into their editing state.
1090      * @return the editable property
1091      */
1092     public final BooleanProperty editableProperty() {
1093         if (editable == null) {
1094             editable = new SimpleBooleanProperty(this, &quot;editable&quot;, false);
1095         }
1096         return editable;
1097     }
1098 
1099 
1100     // --- Fixed cell size
1101     private DoubleProperty fixedCellSize;
1102 
1103     /**
1104      * Sets the new fixed cell size for this control. Any value greater than
1105      * zero will enable fixed cell size mode, whereas a zero or negative value
1106      * (or Region.USE_COMPUTED_SIZE) will be used to disabled fixed cell size
1107      * mode.
1108      *
1109      * @param value The new fixed cell size value, or a value less than or equal
1110      *              to zero (or Region.USE_COMPUTED_SIZE) to disable.
1111      * @since JavaFX 8.0
1112      */
1113     public final void setFixedCellSize(double value) {
1114         fixedCellSizeProperty().set(value);
1115     }
1116 
1117     /**
1118      * Returns the fixed cell size value. A value less than or equal to zero is
1119      * used to represent that fixed cell size mode is disabled, and a value
1120      * greater than zero represents the size of all cells in this control.
1121      *
1122      * @return A double representing the fixed cell size of this control, or a
1123      *      value less than or equal to zero if fixed cell size mode is disabled.
1124      * @since JavaFX 8.0
1125      */
1126     public final double getFixedCellSize() {
1127         return fixedCellSize == null ? Region.USE_COMPUTED_SIZE : fixedCellSize.get();
1128     }
1129     /**
1130      * Specifies whether this control has cells that are a fixed height (of the
1131      * specified value). If this value is less than or equal to zero,
1132      * then all cells are individually sized and positioned. This is a slow
1133      * operation. Therefore, when performance matters and developers are not
1134      * dependent on variable cell sizes it is a good idea to set the fixed cell
1135      * size value. Generally cells are around 24px, so setting a fixed cell size
1136      * of 24 is likely to result in very little difference in visuals, but a
1137      * improvement to performance.
1138      *
1139      * &lt;p&gt;To set this property via CSS, use the -fx-fixed-cell-size property.
1140      * This should not be confused with the -fx-cell-size property. The difference
1141      * between these two CSS properties is that -fx-cell-size will size all
1142      * cells to the specified size, but it will not enforce that this is the
1143      * only size (thus allowing for variable cell sizes, and preventing the
1144      * performance gains from being possible). Therefore, when performance matters
1145      * use -fx-fixed-cell-size, instead of -fx-cell-size. If both properties are
1146      * specified in CSS, -fx-fixed-cell-size takes precedence.&lt;/p&gt;
1147      *
1148      * @return fixedCellSize property
1149      * @since JavaFX 8.0
1150      */
1151     public final DoubleProperty fixedCellSizeProperty() {
1152         if (fixedCellSize == null) {
1153             fixedCellSize = new StyleableDoubleProperty(Region.USE_COMPUTED_SIZE) {
1154                 @Override public CssMetaData&lt;TableView&lt;?&gt;,Number&gt; getCssMetaData() {
1155                     return StyleableProperties.FIXED_CELL_SIZE;
1156                 }
1157 
1158                 @Override public Object getBean() {
1159                     return TableView.this;
1160                 }
1161 
1162                 @Override public String getName() {
1163                     return &quot;fixedCellSize&quot;;
1164                 }
1165             };
1166         }
1167         return fixedCellSize;
1168     }
1169 
1170 
1171     // --- Editing Cell
1172     private ReadOnlyObjectWrapper&lt;TablePosition&lt;S,?&gt;&gt; editingCell;
1173     private void setEditingCell(TablePosition&lt;S,?&gt; value) {
1174         editingCellPropertyImpl().set(value);
1175     }
1176     public final TablePosition&lt;S,?&gt; getEditingCell() {
1177         return editingCell == null ? null : editingCell.get();
1178     }
1179 
1180     /**
1181      * Represents the current cell being edited, or null if
1182      * there is no cell being edited.
1183      * @return the editingCell property
1184      */
1185     public final ReadOnlyObjectProperty&lt;TablePosition&lt;S,?&gt;&gt; editingCellProperty() {
1186         return editingCellPropertyImpl().getReadOnlyProperty();
1187     }
1188 
1189     private ReadOnlyObjectWrapper&lt;TablePosition&lt;S,?&gt;&gt; editingCellPropertyImpl() {
1190         if (editingCell == null) {
1191             editingCell = new ReadOnlyObjectWrapper&lt;TablePosition&lt;S,?&gt;&gt;(this, &quot;editingCell&quot;);
1192         }
1193         return editingCell;
1194     }
1195 
1196 
1197     // --- Comparator (built via sortOrder list, so read-only)
1198     /**
1199      * The comparator property is a read-only property that is representative of the
1200      * current state of the {@link #getSortOrder() sort order} list. The sort
1201      * order list contains the columns that have been added to it either programmatically
1202      * or via a user clicking on the headers themselves.
1203      * @since JavaFX 8.0
1204      */
1205     private ReadOnlyObjectWrapper&lt;Comparator&lt;S&gt;&gt; comparator;
1206     private void setComparator(Comparator&lt;S&gt; value) {
1207         comparatorPropertyImpl().set(value);
1208     }
1209     public final Comparator&lt;S&gt; getComparator() {
1210         return comparator == null ? null : comparator.get();
1211     }
1212     public final ReadOnlyObjectProperty&lt;Comparator&lt;S&gt;&gt; comparatorProperty() {
1213         return comparatorPropertyImpl().getReadOnlyProperty();
1214     }
1215     private ReadOnlyObjectWrapper&lt;Comparator&lt;S&gt;&gt; comparatorPropertyImpl() {
1216         if (comparator == null) {
1217             comparator = new ReadOnlyObjectWrapper&lt;Comparator&lt;S&gt;&gt;(this, &quot;comparator&quot;);
1218         }
1219         return comparator;
1220     }
1221 
1222 
1223     // --- sortPolicy
1224     /**
1225      * The sort policy specifies how sorting in this TableView should be performed.
1226      * For example, a basic sort policy may just call
1227      * {@code FXCollections.sort(tableView.getItems())}, whereas a more advanced
1228      * sort policy may call to a database to perform the necessary sorting on the
1229      * server-side.
1230      *
1231      * &lt;p&gt;TableView ships with a {@link TableView#DEFAULT_SORT_POLICY default
1232      * sort policy} that does precisely as mentioned above: it simply attempts
1233      * to sort the items list in-place.
1234      *
1235      * &lt;p&gt;It is recommended that rather than override the {@link TableView#sort() sort}
1236      * method that a different sort policy be provided instead.
1237      * @since JavaFX 8.0
1238      */
1239     private ObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, Boolean&gt;&gt; sortPolicy;
1240     public final void setSortPolicy(Callback&lt;TableView&lt;S&gt;, Boolean&gt; callback) {
1241         sortPolicyProperty().set(callback);
1242     }
1243     @SuppressWarnings(&quot;unchecked&quot;)
1244     public final Callback&lt;TableView&lt;S&gt;, Boolean&gt; getSortPolicy() {
1245         return sortPolicy == null ?
1246                 (Callback&lt;TableView&lt;S&gt;, Boolean&gt;)(Object) DEFAULT_SORT_POLICY :
1247                 sortPolicy.get();
1248     }
1249     @SuppressWarnings(&quot;unchecked&quot;)
1250     public final ObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, Boolean&gt;&gt; sortPolicyProperty() {
1251         if (sortPolicy == null) {
1252             sortPolicy = new SimpleObjectProperty&lt;Callback&lt;TableView&lt;S&gt;, Boolean&gt;&gt;(
1253                     this, &quot;sortPolicy&quot;, (Callback&lt;TableView&lt;S&gt;, Boolean&gt;)(Object) DEFAULT_SORT_POLICY) {
1254                 @Override protected void invalidated() {
1255                     sort();
1256                 }
1257             };
1258         }
1259         return sortPolicy;
1260     }
1261 
1262 
1263     // onSort
1264     /**
1265      * Called when there&#39;s a request to sort the control.
1266      * @since JavaFX 8.0
1267      */
1268     private ObjectProperty&lt;EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt;&gt; onSort;
1269 
1270     public void setOnSort(EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt; value) {
1271         onSortProperty().set(value);
1272     }
1273 
1274     public EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt; getOnSort() {
1275         if( onSort != null ) {
1276             return onSort.get();
1277         }
1278         return null;
1279     }
1280 
1281     public ObjectProperty&lt;EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt;&gt; onSortProperty() {
1282         if( onSort == null ) {
1283             onSort = new ObjectPropertyBase&lt;EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt;&gt;() {
1284                 @Override protected void invalidated() {
1285                     EventType&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt; eventType = SortEvent.sortEvent();
1286                     EventHandler&lt;SortEvent&lt;TableView&lt;S&gt;&gt;&gt; eventHandler = get();
1287                     setEventHandler(eventType, eventHandler);
1288                 }
1289 
1290                 @Override public Object getBean() {
1291                     return TableView.this;
1292                 }
1293 
1294                 @Override public String getName() {
1295                     return &quot;onSort&quot;;
1296                 }
1297             };
1298         }
1299         return onSort;
1300     }
1301 
1302 
1303     /***************************************************************************
1304      *                                                                         *
1305      * Public API                                                              *
1306      *                                                                         *
1307      **************************************************************************/
1308     /**
1309      * The TableColumns that are part of this TableView. As the user reorders
1310      * the TableView columns, this list will be updated to reflect the current
1311      * visual ordering.
1312      *
1313      * &lt;p&gt;Note: to display any data in a TableView, there must be at least one
1314      * TableColumn in this ObservableList.&lt;/p&gt;
1315      * @return the columns
1316      */
1317     public final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; getColumns() {
1318         return columns;
1319     }
1320 
1321     /**
1322      * The sortOrder list defines the order in which {@link TableColumn} instances
1323      * are sorted. An empty sortOrder list means that no sorting is being applied
1324      * on the TableView. If the sortOrder list has one TableColumn within it,
1325      * the TableView will be sorted using the
1326      * {@link TableColumn#sortTypeProperty() sortType} and
1327      * {@link TableColumn#comparatorProperty() comparator} properties of this
1328      * TableColumn (assuming
1329      * {@link TableColumn#sortableProperty() TableColumn.sortable} is true).
1330      * If the sortOrder list contains multiple TableColumn instances, then
1331      * the TableView is firstly sorted based on the properties of the first
1332      * TableColumn. If two elements are considered equal, then the second
1333      * TableColumn in the list is used to determine ordering. This repeats until
1334      * the results from all TableColumn comparators are considered, if necessary.
1335      *
1336      * @return An ObservableList containing zero or more TableColumn instances.
1337      */
1338     public final ObservableList&lt;TableColumn&lt;S,?&gt;&gt; getSortOrder() {
1339         return sortOrder;
1340     }
1341 
1342     /**
1343      * Scrolls the TableView so that the given index is visible within the viewport.
1344      * @param index The index of an item that should be visible to the user.
1345      */
1346     public void scrollTo(int index) {
1347        ControlUtils.scrollToIndex(this, index);
1348     }
1349 
1350     /**
1351      * Scrolls the TableView so that the given object is visible within the viewport.
1352      * @param object The object that should be visible to the user.
1353      * @since JavaFX 8.0
1354      */
1355     public void scrollTo(S object) {
1356         if( getItems() != null ) {
1357             int idx = getItems().indexOf(object);
1358             if( idx &gt;= 0 ) {
1359                 ControlUtils.scrollToIndex(this, idx);
1360             }
1361         }
1362     }
1363 
1364     /**
1365      * Called when there&#39;s a request to scroll an index into view using {@link #scrollTo(int)}
1366      * or {@link #scrollTo(Object)}
1367      * @since JavaFX 8.0
1368      */
1369     private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollTo;
1370 
1371     public void setOnScrollTo(EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; value) {
1372         onScrollToProperty().set(value);
1373     }
1374 
1375     public EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; getOnScrollTo() {
1376         if( onScrollTo != null ) {
1377             return onScrollTo.get();
1378         }
1379         return null;
1380     }
1381 
1382     public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollToProperty() {
1383         if( onScrollTo == null ) {
1384             onScrollTo = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt;() {
1385                 @Override
1386                 protected void invalidated() {
1387                     setEventHandler(ScrollToEvent.scrollToTopIndex(), get());
1388                 }
1389                 @Override
1390                 public Object getBean() {
1391                     return TableView.this;
1392                 }
1393 
1394                 @Override
1395                 public String getName() {
1396                     return &quot;onScrollTo&quot;;
1397                 }
1398             };
1399         }
1400         return onScrollTo;
1401     }
1402 
1403     /**
1404      * Scrolls the TableView so that the given column is visible within the viewport.
1405      * @param column The column that should be visible to the user.
1406      * @since JavaFX 8.0
1407      */
1408     public void scrollToColumn(TableColumn&lt;S, ?&gt; column) {
1409         ControlUtils.scrollToColumn(this, column);
1410     }
1411 
1412     /**
1413      * Scrolls the TableView so that the given index is visible within the viewport.
1414      * @param columnIndex The index of a column that should be visible to the user.
1415      * @since JavaFX 8.0
1416      */
1417     public void scrollToColumnIndex(int columnIndex) {
1418         if( getColumns() != null ) {
1419             ControlUtils.scrollToColumn(this, getColumns().get(columnIndex));
1420         }
1421     }
1422 
1423     /**
1424      * Called when there&#39;s a request to scroll a column into view using {@link #scrollToColumn(TableColumn)}
1425      * or {@link #scrollToColumnIndex(int)}
1426      * @since JavaFX 8.0
1427      */
1428     private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt;&gt; onScrollToColumn;
1429 
1430     public void setOnScrollToColumn(EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt; value) {
1431         onScrollToColumnProperty().set(value);
1432     }
1433 
1434     public EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt; getOnScrollToColumn() {
1435         if( onScrollToColumn != null ) {
1436             return onScrollToColumn.get();
1437         }
1438         return null;
1439     }
1440 
1441     public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt;&gt; onScrollToColumnProperty() {
1442         if( onScrollToColumn == null ) {
1443             onScrollToColumn = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt;&gt;() {
1444                 @Override protected void invalidated() {
1445                     EventType&lt;ScrollToEvent&lt;TableColumn&lt;S, ?&gt;&gt;&gt; type = ScrollToEvent.scrollToColumn();
1446                     setEventHandler(type, get());
1447                 }
1448 
1449                 @Override public Object getBean() {
1450                     return TableView.this;
1451                 }
1452 
1453                 @Override public String getName() {
1454                     return &quot;onScrollToColumn&quot;;
1455                 }
1456             };
1457         }
1458         return onScrollToColumn;
1459     }
1460 
1461     /**
1462      * Applies the currently installed resize policy against the given column,
1463      * resizing it based on the delta value provided.
1464      * @param column the column
1465      * @param delta the delta
1466      * @return true if column resize is allowed
1467      */
1468     public boolean resizeColumn(TableColumn&lt;S,?&gt; column, double delta) {
1469         if (column == null || Double.compare(delta, 0.0) == 0) return false;
1470 
1471         boolean allowed = getColumnResizePolicy().call(new ResizeFeatures&lt;S&gt;(TableView.this, column, delta));
1472         if (!allowed) return false;
1473 
1474         return true;
1475     }
1476 
1477     /**
1478      * Causes the cell at the given row/column view indexes to switch into
1479      * its editing state, if it is not already in it, and assuming that the
1480      * TableView and column are also editable.
1481      *
1482      * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method will cancel editing if the given row
1483      * value is less than zero and the given column is null.&lt;/p&gt;
1484      * @param row the row
1485      * @param column the column
1486      */
1487     public void edit(int row, TableColumn&lt;S,?&gt; column) {
1488         if (!isEditable() || (column != null &amp;&amp; ! column.isEditable())) {
1489             return;
1490         }
1491 
1492         if (row &lt; 0 &amp;&amp; column == null) {
1493             setEditingCell(null);
1494         } else {
1495             setEditingCell(new TablePosition&lt;&gt;(this, row, column));
1496         }
1497     }
1498 
1499     /**
1500      * Returns an unmodifiable list containing the currently visible leaf columns.
1501      * @return an unmodifiable list containing the currently visible leaf columns
1502      */
1503     public ObservableList&lt;TableColumn&lt;S,?&gt;&gt; getVisibleLeafColumns() {
1504         return unmodifiableVisibleLeafColumns;
1505     }
1506 
1507     /**
1508      * Returns the position of the given column, relative to all other
1509      * visible leaf columns.
1510      * @param column the column
1511      * @return the position of the given column, relative to all other
1512      * visible leaf columns
1513      */
1514     public int getVisibleLeafIndex(TableColumn&lt;S,?&gt; column) {
1515         return visibleLeafColumns.indexOf(column);
1516     }
1517 
1518     /**
1519      * Returns the TableColumn in the given column index, relative to all other
1520      * visible leaf columns.
1521      * @param column the column
1522      * @return the TableColumn in the given column index, relative to all other
1523      * visible leaf columns
1524      */
1525     public TableColumn&lt;S,?&gt; getVisibleLeafColumn(int column) {
1526         if (column &lt; 0 || column &gt;= visibleLeafColumns.size()) return null;
1527         return visibleLeafColumns.get(column);
1528     }
1529 
1530     /** {@inheritDoc} */
1531     @Override protected Skin&lt;?&gt; createDefaultSkin() {
1532         return new TableViewSkin&lt;S&gt;(this);
1533     }
1534 
1535     /**
1536      * The sort method forces the TableView to re-run its sorting algorithm. More
1537      * often than not it is not necessary to call this method directly, as it is
1538      * automatically called when the {@link #getSortOrder() sort order},
1539      * {@link #sortPolicyProperty() sort policy}, or the state of the
1540      * TableColumn {@link TableColumn#sortTypeProperty() sort type} properties
1541      * change. In other words, this method should only be called directly when
1542      * something external changes and a sort is required.
1543      * @since JavaFX 8.0
1544      */
1545     public void sort() {
1546         final ObservableList&lt;? extends TableColumnBase&lt;S,?&gt;&gt; sortOrder = getSortOrder();
1547 
1548         // update the Comparator property
1549         final Comparator&lt;S&gt; oldComparator = getComparator();
1550         setComparator(sortOrder.isEmpty() ? null : new TableColumnComparator(sortOrder));
1551 
1552         // fire the onSort event and check if it is consumed, if
1553         // so, don&#39;t run the sort
1554         SortEvent&lt;TableView&lt;S&gt;&gt; sortEvent = new SortEvent&lt;&gt;(TableView.this, TableView.this);
1555         fireEvent(sortEvent);
1556         if (sortEvent.isConsumed()) {
1557             // if the sort is consumed we could back out the last action (the code
1558             // is commented out right below), but we don&#39;t as we take it as a
1559             // sign that the developer has decided to handle the event themselves.
1560 
1561             // sortLock = true;
1562             // TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1563             // sortLock = false;
1564             return;
1565         }
1566 
1567         final List&lt;TablePosition&gt; prevState = new ArrayList&lt;&gt;(getSelectionModel().getSelectedCells());
1568         final int itemCount = prevState.size();
1569 
1570         // we set makeAtomic to true here, so that we don&#39;t fire intermediate
1571         // sort events - instead we send a single permutation event at the end
1572         // of this method.
1573         getSelectionModel().startAtomic();
1574 
1575         // get the sort policy and run it
1576         Callback&lt;TableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
1577         if (sortPolicy == null) return;
1578         Boolean success = sortPolicy.call(this);
1579 
1580         getSelectionModel().stopAtomic();
1581 
1582         if (success == null || ! success) {
1583             // the sort was a failure. Need to backout if possible
1584             sortLock = true;
1585             TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1586             setComparator(oldComparator);
1587             sortLock = false;
1588         } else {
1589             // sorting was a success, now we possibly fire an event on the
1590             // selection model that the items list has &#39;permutated&#39; to a new ordering
1591 
1592             // FIXME we should support alternative selection model implementations!
1593             if (getSelectionModel() instanceof TableViewArrayListSelectionModel) {
1594                 final TableViewArrayListSelectionModel&lt;S&gt; sm = (TableViewArrayListSelectionModel&lt;S&gt;) getSelectionModel();
1595                 final ObservableList&lt;TablePosition&lt;S,?&gt;&gt; newState = (ObservableList&lt;TablePosition&lt;S,?&gt;&gt;)(Object)sm.getSelectedCells();
1596 
1597                 List&lt;TablePosition&lt;S, ?&gt;&gt; removed = new ArrayList&lt;&gt;();
1598                 for (int i = 0; i &lt; itemCount; i++) {
1599                     TablePosition&lt;S, ?&gt; prevItem = prevState.get(i);
1600                     if (!newState.contains(prevItem)) {
1601                         removed.add(prevItem);
1602                     }
1603                 }
1604 
1605                 if (!removed.isEmpty()) {
1606                     // the sort operation effectively permutates the selectedCells list,
1607                     // but we cannot fire a permutation event as we are talking about
1608                     // TablePosition&#39;s changing (which may reside in the same list
1609                     // position before and after the sort). Therefore, we need to fire
1610                     // a single add/remove event to cover the added and removed positions.
1611                     ListChangeListener.Change&lt;TablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(0, itemCount, removed, newState);
1612                     sm.fireCustomSelectedCellsListChangeEvent(c);
1613                 }
1614             }
1615         }
1616     }
1617 
1618     /**
1619      * Calling {@code refresh()} forces the TableView control to recreate and
1620      * repopulate the cells necessary to populate the visual bounds of the control.
1621      * In other words, this forces the TableView to update what it is showing to
1622      * the user. This is useful in cases where the underlying data source has
1623      * changed in a way that is not observed by the TableView itself.
1624      *
1625      * @since JavaFX 8u60
1626      */
1627     public void refresh() {
1628         getProperties().put(Properties.RECREATE, Boolean.TRUE);
1629     }
1630 
1631 
1632 
1633     /***************************************************************************
1634      *                                                                         *
1635      * Private Implementation                                                  *
1636      *                                                                         *
1637      **************************************************************************/
1638 
1639     private boolean sortLock = false;
1640     private TableUtil.SortEventType lastSortEventType = null;
1641     private Object[] lastSortEventSupportInfo = null;
1642 
1643     private void doSort(final TableUtil.SortEventType sortEventType, final Object... supportInfo) {
1644         if (sortLock) {
1645             return;
1646         }
1647 
1648         this.lastSortEventType = sortEventType;
1649         this.lastSortEventSupportInfo = supportInfo;
1650         sort();
1651         this.lastSortEventType = null;
1652         this.lastSortEventSupportInfo = null;
1653     }
1654 
1655 
1656     // --- Content width
1657     private void setContentWidth(double contentWidth) {
1658         this.contentWidth = contentWidth;
1659         if (isInited) {
1660             // sometimes the current column resize policy will have to modify the
1661             // column width of all columns in the table if the table width changes,
1662             // so we short-circuit the resize function and just go straight there
1663             // with a null TableColumn, which indicates to the resize policy function
1664             // that it shouldn&#39;t actually do anything specific to one column.
1665             getColumnResizePolicy().call(new ResizeFeatures&lt;S&gt;(TableView.this, null, 0.0));
1666         }
1667     }
1668 
1669     /**
1670      * Recomputes the currently visible leaf columns in this TableView.
1671      */
1672     private void updateVisibleLeafColumns() {
1673         // update visible leaf columns list
1674         List&lt;TableColumn&lt;S,?&gt;&gt; cols = new ArrayList&lt;TableColumn&lt;S,?&gt;&gt;();
1675         buildVisibleLeafColumns(getColumns(), cols);
1676         visibleLeafColumns.setAll(cols);
1677 
1678         // sometimes the current column resize policy will have to modify the
1679         // column width of all columns in the table if the table width changes,
1680         // so we short-circuit the resize function and just go straight there
1681         // with a null TableColumn, which indicates to the resize policy function
1682         // that it shouldn&#39;t actually do anything specific to one column.
1683         getColumnResizePolicy().call(new ResizeFeatures&lt;S&gt;(TableView.this, null, 0.0));
1684     }
1685 
1686     private void buildVisibleLeafColumns(List&lt;TableColumn&lt;S,?&gt;&gt; cols, List&lt;TableColumn&lt;S,?&gt;&gt; vlc) {
1687         for (TableColumn&lt;S,?&gt; c : cols) {
1688             if (c == null) continue;
1689 
1690             boolean hasChildren = ! c.getColumns().isEmpty();
1691 
1692             if (hasChildren) {
1693                 buildVisibleLeafColumns(c.getColumns(), vlc);
1694             } else if (c.isVisible()) {
1695                 vlc.add(c);
1696             }
1697         }
1698     }
1699 
1700 
1701 
1702     /***************************************************************************
1703      *                                                                         *
1704      * Stylesheet Handling                                                     *
1705      *                                                                         *
1706      **************************************************************************/
1707 
1708     private static final String DEFAULT_STYLE_CLASS = &quot;table-view&quot;;
1709 
1710     private static final PseudoClass PSEUDO_CLASS_CELL_SELECTION =
1711             PseudoClass.getPseudoClass(&quot;cell-selection&quot;);
1712     private static final PseudoClass PSEUDO_CLASS_ROW_SELECTION =
1713             PseudoClass.getPseudoClass(&quot;row-selection&quot;);
1714 
1715     private static class StyleableProperties {
1716         private static final CssMetaData&lt;TableView&lt;?&gt;,Number&gt; FIXED_CELL_SIZE =
1717                 new CssMetaData&lt;TableView&lt;?&gt;,Number&gt;(&quot;-fx-fixed-cell-size&quot;,
1718                                                     SizeConverter.getInstance(),
1719                                                     Region.USE_COMPUTED_SIZE) {
1720 
1721                     @Override public Double getInitialValue(TableView&lt;?&gt; node) {
1722                         return node.getFixedCellSize();
1723                     }
1724 
1725                     @Override public boolean isSettable(TableView&lt;?&gt; n) {
1726                         return n.fixedCellSize == null || !n.fixedCellSize.isBound();
1727                     }
1728 
1729                     @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(TableView&lt;?&gt; n) {
1730                         return (StyleableProperty&lt;Number&gt;) n.fixedCellSizeProperty();
1731                     }
1732                 };
1733 
1734         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
1735         static {
1736             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1737                     new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
1738             styleables.add(FIXED_CELL_SIZE);
1739             STYLEABLES = Collections.unmodifiableList(styleables);
1740         }
1741     }
1742 
1743     /**
1744      * @return The CssMetaData associated with this class, which may include the
1745      * CssMetaData of its superclasses.
1746      * @since JavaFX 8.0
1747      */
1748     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1749         return StyleableProperties.STYLEABLES;
1750     }
1751 
1752     /**
1753      * {@inheritDoc}
1754      * @since JavaFX 8.0
1755      */
1756     @Override
1757     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
1758         return getClassCssMetaData();
1759     }
1760 
1761 
1762 
1763     /***************************************************************************
1764      *                                                                         *
1765      * Accessibility handling                                                  *
1766      *                                                                         *
1767      **************************************************************************/
1768 
1769     /** {@inheritDoc} */
1770     @Override
1771     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1772         switch (attribute) {
1773             case COLUMN_COUNT: return getVisibleLeafColumns().size();
1774             case ROW_COUNT: return getItems().size();
1775             case SELECTED_ITEMS: {
1776                 // TableViewSkin returns TableRows back to TableView.
1777                 // TableRowSkin returns TableCells back to TableRow.
1778                 @SuppressWarnings(&quot;unchecked&quot;)
1779                 ObservableList&lt;TableRow&lt;S&gt;&gt; rows = (ObservableList&lt;TableRow&lt;S&gt;&gt;)super.queryAccessibleAttribute(attribute, parameters);
1780                 List&lt;Node&gt; selection = new ArrayList&lt;&gt;();
1781                 for (TableRow&lt;S&gt; row : rows) {
1782                     @SuppressWarnings(&quot;unchecked&quot;)
1783                     ObservableList&lt;Node&gt; cells = (ObservableList&lt;Node&gt;)row.queryAccessibleAttribute(attribute, parameters);
1784                     if (cells != null) selection.addAll(cells);
1785                 }
1786                 return FXCollections.observableArrayList(selection);
1787             }
1788             case FOCUS_ITEM: {
1789                 Node row = (Node)super.queryAccessibleAttribute(attribute, parameters);
1790                 if (row == null) return null;
1791                 Node cell = (Node)row.queryAccessibleAttribute(attribute, parameters);
1792                 /* cell equals to null means the row is a placeholder node */
1793                 return cell != null ?  cell : row;
1794             }
1795             case CELL_AT_ROW_COLUMN: {
1796                 @SuppressWarnings(&quot;unchecked&quot;)
1797                 TableRow&lt;S&gt; row = (TableRow&lt;S&gt;)super.queryAccessibleAttribute(attribute, parameters);
1798                 return row != null ? row.queryAccessibleAttribute(attribute, parameters) : null;
1799             }
1800             case MULTIPLE_SELECTION: {
1801                 MultipleSelectionModel&lt;S&gt; sm = getSelectionModel();
1802                 return sm != null &amp;&amp; sm.getSelectionMode() == SelectionMode.MULTIPLE;
1803             }
1804             default: return super.queryAccessibleAttribute(attribute, parameters);
1805         }
1806     }
1807 
1808 
1809     /***************************************************************************
1810      *                                                                         *
1811      * Support Interfaces                                                      *
1812      *                                                                         *
1813      **************************************************************************/
1814 
1815      /**
1816       * An immutable wrapper class for use in the TableView
1817      * {@link TableView#columnResizePolicyProperty() column resize} functionality.
1818       * @since JavaFX 2.0
1819       */
1820      public static class ResizeFeatures&lt;S&gt; extends ResizeFeaturesBase&lt;S&gt; {
1821         private TableView&lt;S&gt; table;
1822 
1823         /**
1824          * Creates an instance of this class, with the provided TableView,
1825          * TableColumn and delta values being set and stored in this immutable
1826          * instance.
1827          *
1828          * @param table The TableView upon which the resize operation is occurring.
1829          * @param column The column upon which the resize is occurring, or null
1830          *      if this ResizeFeatures instance is being created as a result of a
1831          *      TableView resize operation.
1832          * @param delta The amount of horizontal space added or removed in the
1833          *      resize operation.
1834          */
1835         public ResizeFeatures(TableView&lt;S&gt; table, TableColumn&lt;S,?&gt; column, Double delta) {
1836             super(column, delta);
1837             this.table = table;
1838         }
1839 
1840         /**
1841          * Returns the column upon which the resize is occurring, or null
1842          * if this ResizeFeatures instance was created as a result of a
1843          * TableView resize operation.
1844          */
1845         @Override public TableColumn&lt;S,?&gt; getColumn() {
1846             return (TableColumn&lt;S,?&gt;) super.getColumn();
1847         }
1848 
1849         /**
1850          * Returns the TableView upon which the resize operation is occurring.
1851          * @return the TableView
1852          */
1853         public TableView&lt;S&gt; getTable() {
1854             return table;
1855         }
1856     }
1857 
1858 
1859 
1860     /***************************************************************************
1861      *                                                                         *
1862      * Support Classes                                                         *
1863      *                                                                         *
1864      **************************************************************************/
1865 
1866 
1867     /**
1868      * A simple extension of the {@link SelectionModel} abstract class to
1869      * allow for special support for TableView controls.
1870      * @since JavaFX 2.0
1871      */
1872     public static abstract class TableViewSelectionModel&lt;S&gt; extends TableSelectionModel&lt;S&gt; {
1873 
1874         /***********************************************************************
1875          *                                                                     *
1876          * Private fields                                                      *
1877          *                                                                     *
1878          **********************************************************************/
1879 
1880         private final TableView&lt;S&gt; tableView;
1881 
1882         boolean blockFocusCall = false;
1883 
1884 
1885 
1886         /***********************************************************************
1887          *                                                                     *
1888          * Constructors                                                        *
1889          *                                                                     *
1890          **********************************************************************/
1891 
1892         /**
1893          * Builds a default TableViewSelectionModel instance with the provided
1894          * TableView.
1895          * @param tableView The TableView upon which this selection model should
1896          *      operate.
1897          * @throws NullPointerException TableView can not be null.
1898          */
1899         public TableViewSelectionModel(final TableView&lt;S&gt; tableView) {
1900             if (tableView == null) {
1901                 throw new NullPointerException(&quot;TableView can not be null&quot;);
1902             }
1903 
1904             this.tableView = tableView;
1905         }
1906 
1907 
1908 
1909         /***********************************************************************
1910          *                                                                     *
1911          * Abstract API                                                        *
1912          *                                                                     *
1913          **********************************************************************/
1914 
1915         /**
1916          * A read-only ObservableList representing the currently selected cells
1917          * in this TableView. Rather than directly modify this list, please
1918          * use the other methods provided in the TableViewSelectionModel.
1919          * @return a read-only ObservableList representing the currently
1920          * selected cells in this TableView
1921          */
1922         public abstract ObservableList&lt;TablePosition&gt; getSelectedCells();
1923 
1924 
1925         /***********************************************************************
1926          *                                                                     *
1927          * Generic (type erasure) bridging                                     *
1928          *                                                                     *
1929          **********************************************************************/
1930 
1931         // --- isSelected
1932         /** {@inheritDoc} */
1933         @Override public boolean isSelected(int row, TableColumnBase&lt;S, ?&gt; column) {
1934             return isSelected(row, (TableColumn&lt;S,?&gt;)column);
1935         }
1936 
1937         /**
1938          * Convenience function which tests whether the given row and column index
1939          * is currently selected in this table instance.
1940          * @param row the row
1941          * @param column the column
1942          * @return true if row and column index is currently selected
1943          */
1944         public abstract boolean isSelected(int row, TableColumn&lt;S, ?&gt; column);
1945 
1946 
1947         // --- select
1948         /** {@inheritDoc} */
1949         @Override public void select(int row, TableColumnBase&lt;S, ?&gt; column) {
1950             select(row, (TableColumn&lt;S,?&gt;)column);
1951         }
1952 
1953         /**
1954          * Selects the cell at the given row/column intersection.
1955          * @param row the row
1956          * @param column the column
1957          */
1958         public abstract void select(int row, TableColumn&lt;S, ?&gt; column);
1959 
1960 
1961         // --- clearAndSelect
1962         /** {@inheritDoc} */
1963         @Override public void clearAndSelect(int row, TableColumnBase&lt;S,?&gt; column) {
1964             clearAndSelect(row, (TableColumn&lt;S,?&gt;) column);
1965         }
1966 
1967         /**
1968          * Clears all selection, and then selects the cell at the given row/column
1969          * intersection.
1970          * @param row the row
1971          * @param column the column
1972          */
1973         public abstract void clearAndSelect(int row, TableColumn&lt;S,?&gt; column);
1974 
1975 
1976         // --- clearSelection
1977         /** {@inheritDoc} */
1978         @Override public void clearSelection(int row, TableColumnBase&lt;S,?&gt; column) {
1979             clearSelection(row, (TableColumn&lt;S,?&gt;) column);
1980         }
1981 
1982         /**
1983          * Removes selection from the specified row/column position (in view indexes).
1984          * If this particular cell (or row if the column value is -1) is not selected,
1985          * nothing happens.
1986          * @param row the row
1987          * @param column the column
1988          */
1989         public abstract void clearSelection(int row, TableColumn&lt;S, ?&gt; column);
1990 
1991         /** {@inheritDoc} */
1992         @Override public void selectRange(int minRow, TableColumnBase&lt;S,?&gt; minColumn,
1993                                           int maxRow, TableColumnBase&lt;S,?&gt; maxColumn) {
1994             final int minColumnIndex = tableView.getVisibleLeafIndex((TableColumn&lt;S,?&gt;)minColumn);
1995             final int maxColumnIndex = tableView.getVisibleLeafIndex((TableColumn&lt;S,?&gt;)maxColumn);
1996             for (int _row = minRow; _row &lt;= maxRow; _row++) {
1997                 for (int _col = minColumnIndex; _col &lt;= maxColumnIndex; _col++) {
1998                     select(_row, tableView.getVisibleLeafColumn(_col));
1999                 }
2000             }
2001         }
2002 
2003 
2004 
2005         /***********************************************************************
2006          *                                                                     *
2007          * Public API                                                          *
2008          *                                                                     *
2009          **********************************************************************/
2010 
2011         /**
2012          * Returns the TableView instance that this selection model is installed in.
2013          * @return the TableView
2014          */
2015         public TableView&lt;S&gt; getTableView() {
2016             return tableView;
2017         }
2018 
2019         /**
2020          * Convenience method that returns getTableView().getItems().
2021          * @return The items list of the current TableView.
2022          */
2023         protected List&lt;S&gt; getTableModel()  {
2024             return tableView.getItems();
2025         }
2026 
2027         /** {@inheritDoc} */
2028         @Override protected S getModelItem(int index) {
2029             if (index &lt; 0 || index &gt;= getItemCount()) return null;
2030             return tableView.getItems().get(index);
2031         }
2032 
2033         /** {@inheritDoc} */
2034         @Override protected int getItemCount() {
2035             return getTableModel().size();
2036         }
2037 
2038         /** {@inheritDoc} */
2039         @Override public void focus(int row) {
2040             focus(row, null);
2041         }
2042 
2043         /** {@inheritDoc} */
2044         @Override public int getFocusedIndex() {
2045             return getFocusedCell().getRow();
2046         }
2047 
2048 
2049 
2050         /***********************************************************************
2051          *                                                                     *
2052          * Private implementation                                              *
2053          *                                                                     *
2054          **********************************************************************/
2055 
2056         void focus(int row, TableColumn&lt;S,?&gt; column) {
2057             focus(new TablePosition&lt;&gt;(getTableView(), row, column));
2058             getTableView().notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
2059         }
2060 
2061         void focus(TablePosition&lt;S,?&gt; pos) {
2062             if (blockFocusCall) return;
2063             if (getTableView().getFocusModel() == null) return;
2064 
2065             getTableView().getFocusModel().focus(pos.getRow(), pos.getTableColumn());
2066         }
2067 
2068         TablePosition&lt;S,?&gt; getFocusedCell() {
2069             if (getTableView().getFocusModel() == null) {
2070                 return new TablePosition&lt;&gt;(getTableView(), -1, null);
2071             }
2072             return getTableView().getFocusModel().getFocusedCell();
2073         }
2074     }
2075 
2076 
2077 
2078     /**
2079      * A primitive selection model implementation, using a List&lt;Integer&gt; to store all
2080      * selected indices.
2081      */
2082     // package for testing
2083     static class TableViewArrayListSelectionModel&lt;S&gt; extends TableViewSelectionModel&lt;S&gt; {
2084 
2085         private int itemCount = 0;
2086 
2087         private final MappingChange.Map&lt;TablePosition&lt;S,?&gt;,Integer&gt; cellToIndicesMap = f -&gt; f.getRow();
2088 
2089         /***********************************************************************
2090          *                                                                     *
2091          * Constructors                                                        *
2092          *                                                                     *
2093          **********************************************************************/
2094 
2095         public TableViewArrayListSelectionModel(final TableView&lt;S&gt; tableView) {
2096             super(tableView);
2097             this.tableView = tableView;
2098 
2099             this.itemsPropertyListener = new InvalidationListener() {
2100                 private WeakReference&lt;ObservableList&lt;S&gt;&gt; weakItemsRef = new WeakReference&lt;&gt;(tableView.getItems());
2101 
2102                 @Override public void invalidated(Observable observable) {
2103                     ObservableList&lt;S&gt; oldItems = weakItemsRef.get();
2104                     weakItemsRef = new WeakReference&lt;&gt;(tableView.getItems());
2105                     updateItemsObserver(oldItems, tableView.getItems());
2106                 }
2107             };
2108             this.tableView.itemsProperty().addListener(itemsPropertyListener);
2109 
2110             selectedCellsMap = new SelectedCellsMap&lt;TablePosition&lt;S,?&gt;&gt;(this::fireCustomSelectedCellsListChangeEvent) {
2111                 @Override public boolean isCellSelectionEnabled() {
2112                     return TableViewArrayListSelectionModel.this.isCellSelectionEnabled();
2113                 }
2114             };
2115 
2116             selectedCellsSeq = new ReadOnlyUnbackedObservableList&lt;TablePosition&lt;S,?&gt;&gt;() {
2117                 @Override public TablePosition&lt;S,?&gt; get(int i) {
2118                     return selectedCellsMap.get(i);
2119                 }
2120 
2121                 @Override public int size() {
2122                     return selectedCellsMap.size();
2123                 }
2124             };
2125 //            selectedCellsSeq.addListener((ListChangeListener&lt;? super TablePosition&lt;S,?&gt;&gt;) c -&gt; {
2126 //                ControlUtils.updateSelectedIndices(this, c);
2127 //            });
2128 
2129 
2130             /*
2131              * The following listener is used in conjunction with
2132              * SelectionModel.select(T obj) to allow for a developer to select
2133              * an item that is not actually in the data model. When this occurs,
2134              * we actively try to find an index that matches this object, going
2135              * so far as to actually watch for all changes to the items list,
2136              * rechecking each time.
2137              */
2138 
2139             // watching for changes to the items list content
2140             ObservableList&lt;S&gt; items = getTableView().getItems();
2141             if (items != null) {
2142                 items.addListener(weakItemsContentListener);
2143             }
2144 
2145 
2146             updateItemCount();
2147 
2148             updateDefaultSelection();
2149 
2150             cellSelectionEnabledProperty().addListener(o -&gt; {
2151                 updateDefaultSelection();
2152                 TableCellBehaviorBase.setAnchor(tableView, getFocusedCell(), true);
2153             });
2154         }
2155 
2156         private void dispose() {
2157             this.tableView.itemsProperty().removeListener(itemsPropertyListener);
2158 
2159             ObservableList&lt;S&gt; items = getTableView().getItems();
2160             if (items != null) {
2161                 items.removeListener(weakItemsContentListener);
2162             }
2163         }
2164 
2165         private final TableView&lt;S&gt; tableView;
2166 
2167         final InvalidationListener itemsPropertyListener;
2168 
2169         final ListChangeListener&lt;S&gt; itemsContentListener = c -&gt; {
2170             updateItemCount();
2171 
2172             List&lt;S&gt; items1 = getTableModel();
2173             boolean doSelectionUpdate = true;
2174 
2175             while (c.next()) {
2176                 if (c.wasReplaced() || c.getAddedSize() == getItemCount()) {
2177                     this.selectedItemChange = c;
2178                     updateDefaultSelection();
2179                     this.selectedItemChange = null;
2180                     return;
2181                 }
2182 
2183                 final S selectedItem = getSelectedItem();
2184                 final int selectedIndex = getSelectedIndex();
2185 
2186                 if (items1 == null || items1.isEmpty()) {
2187                     clearSelection();
2188                 } else if (getSelectedIndex() == -1 &amp;&amp; getSelectedItem() != null) {
2189                     int newIndex = items1.indexOf(getSelectedItem());
2190                     if (newIndex != -1) {
2191                         setSelectedIndex(newIndex);
2192                         doSelectionUpdate = false;
2193                     }
2194                 } else if (c.wasRemoved() &amp;&amp;
2195                         c.getRemovedSize() == 1 &amp;&amp;
2196                         ! c.wasAdded() &amp;&amp;
2197                         selectedItem != null &amp;&amp;
2198                         selectedItem.equals(c.getRemoved().get(0))) {
2199                     // Bug fix for RT-28637
2200                     if (getSelectedIndex() &lt; getItemCount()) {
2201                         final int previousRow = selectedIndex == 0 ? 0 : selectedIndex - 1;
2202                         S newSelectedItem = getModelItem(previousRow);
2203                         if (! selectedItem.equals(newSelectedItem)) {
2204                             clearAndSelect(previousRow);
2205                         }
2206                     }
2207                 }
2208             }
2209 
2210             if (doSelectionUpdate) {
2211                 updateSelection(c);
2212             }
2213         };
2214 
2215         final WeakListChangeListener&lt;S&gt; weakItemsContentListener
2216                 = new WeakListChangeListener&lt;&gt;(itemsContentListener);
2217 
2218 
2219 
2220         /***********************************************************************
2221          *                                                                     *
2222          * Observable properties (and getters/setters)                         *
2223          *                                                                     *
2224          **********************************************************************/
2225 
2226         // the only &#39;proper&#39; internal data structure, selectedItems and selectedIndices
2227         // are both &#39;read-only and unbacked&#39;.
2228         private final SelectedCellsMap&lt;TablePosition&lt;S,?&gt;&gt; selectedCellsMap;
2229 
2230         // we create a ReadOnlyUnbackedObservableList of selectedCells here so
2231         // that we can fire custom list change events.
2232         private final ReadOnlyUnbackedObservableList&lt;TablePosition&lt;S,?&gt;&gt; selectedCellsSeq;
2233         @Override public ObservableList&lt;TablePosition&gt; getSelectedCells() {
2234             return (ObservableList&lt;TablePosition&gt;)(Object)selectedCellsSeq;
2235         }
2236 
2237 
2238 
2239         /***********************************************************************
2240          *                                                                     *
2241          * Internal properties                                                 *
2242          *                                                                     *
2243          **********************************************************************/
2244 
2245         private int previousModelSize = 0;
2246 
2247         // Listen to changes in the tableview items list, such that when it
2248         // changes we can update the selected indices list to refer to the
2249         // new indices.
2250         private void updateSelection(ListChangeListener.Change&lt;? extends S&gt; c) {
2251             c.reset();
2252 
2253             int shift = 0;
2254             int startRow = -1;
2255             while (c.next()) {
2256                 if (c.wasReplaced()) {
2257                     if (c.getList().isEmpty()) {
2258                         // the entire items list was emptied - clear selection
2259                         clearSelection();
2260                     } else {
2261                         int index = getSelectedIndex();
2262 
2263                         if (previousModelSize == c.getRemovedSize()) {
2264                             // all items were removed from the model
2265                             clearSelection();
2266                         } else if (index &lt; getItemCount() &amp;&amp; index &gt;= 0) {
2267                             // Fix for RT-18969: the list had setAll called on it
2268                             // Use of makeAtomic is a fix for RT-20945
2269                             startAtomic();
2270                             clearSelection(index);
2271                             stopAtomic();
2272                             select(index);
2273                         } else {
2274                             // Fix for RT-22079
2275                             clearSelection();
2276                         }
2277                     }
2278                 } else if (c.wasAdded() || c.wasRemoved()) {
2279                     startRow = c.getFrom();
2280                     shift += c.wasAdded() ? c.getAddedSize() : -c.getRemovedSize();
2281                 } else if (c.wasPermutated()) {
2282                     // General approach:
2283                     //   -- detected a sort has happened
2284                     //   -- Create a permutation lookup map (1)
2285                     //   -- dump all the selected indices into a list (2)
2286                     //   -- create a list containing the new indices (3)
2287                     //   -- for each previously-selected index (4)
2288                     //     -- if index is in the permutation lookup map
2289                     //       -- add the new index to the new indices list
2290                     //   -- Perform batch selection (5)
2291 
2292                     startAtomic();
2293 
2294                     final int oldSelectedIndex = getSelectedIndex();
2295 
2296                     // (1)
2297                     int length = c.getTo() - c.getFrom();
2298                     HashMap&lt;Integer, Integer&gt; pMap = new HashMap&lt;&gt; (length);
2299                     for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
2300                         pMap.put(i, c.getPermutation(i));
2301                     }
2302 
2303                     // (2)
2304                     List&lt;TablePosition&lt;S,?&gt;&gt; selectedIndices = new ArrayList&lt;&gt;((ObservableList&lt;TablePosition&lt;S,?&gt;&gt;)(Object)getSelectedCells());
2305 
2306                     // (3)
2307                     List&lt;TablePosition&lt;S,?&gt;&gt; newIndices = new ArrayList&lt;&gt;(selectedIndices.size());
2308 
2309                     // (4)
2310                     boolean selectionIndicesChanged = false;
2311                     for (int i = 0; i &lt; selectedIndices.size(); i++) {
2312                         final TablePosition&lt;S,?&gt; oldIndex = selectedIndices.get(i);
2313                         final int oldRow = oldIndex.getRow();
2314 
2315                         if (pMap.containsKey(oldRow)) {
2316                             int newIndex = pMap.get(oldRow);
2317 
2318                             selectionIndicesChanged = selectionIndicesChanged || newIndex != oldRow;
2319 
2320                             newIndices.add(new TablePosition&lt;&gt;(oldIndex.getTableView(), newIndex, oldIndex.getTableColumn()));
2321                         }
2322                     }
2323 
2324                     if (selectionIndicesChanged) {
2325                         // (5)
2326                         quietClearSelection();
2327                         stopAtomic();
2328 
2329                         selectedCellsMap.setAll(newIndices);
2330 
2331                         if (oldSelectedIndex &gt;= 0 &amp;&amp; oldSelectedIndex &lt; itemCount) {
2332                             int newIndex = c.getPermutation(oldSelectedIndex);
2333                             setSelectedIndex(newIndex);
2334                             focus(newIndex);
2335                         }
2336                     } else {
2337                         stopAtomic();
2338                     }
2339                 }
2340             }
2341 
2342             TablePosition&lt;S,?&gt; anchor = TableCellBehavior.getAnchor(tableView, null);
2343             if (shift != 0 &amp;&amp; startRow &gt;= 0 &amp;&amp; anchor != null &amp;&amp; (c.wasRemoved() || c.wasAdded())) {
2344                 if (isSelected(anchor.getRow(), anchor.getTableColumn())) {
2345                     TablePosition&lt;S,?&gt; newAnchor = new TablePosition&lt;&gt;(tableView, anchor.getRow() + shift, anchor.getTableColumn());
2346                     TableCellBehavior.setAnchor(tableView, newAnchor, false);
2347                 }
2348             }
2349 
2350             shiftSelection(startRow, shift, new Callback&lt;ShiftParams, Void&gt;() {
2351                 @Override public Void call(ShiftParams param) {
2352 
2353                     // we make the shifts atomic, as otherwise listeners to
2354                     // the items / indices lists get a lot of intermediate
2355                     // noise. They eventually get the summary event fired
2356                     // from within shiftSelection, so this is ok.
2357                     startAtomic();
2358 
2359                     final int clearIndex = param.getClearIndex();
2360                     final int setIndex = param.getSetIndex();
2361                     TablePosition&lt;S,?&gt; oldTP = null;
2362                     if (clearIndex &gt; -1) {
2363                         for (int i = 0; i &lt; selectedCellsMap.size(); i++) {
2364                             TablePosition&lt;S,?&gt; tp = selectedCellsMap.get(i);
2365                             if (tp.getRow() == clearIndex) {
2366                                 oldTP = tp;
2367                                 selectedCellsMap.remove(tp);
2368                             } else if (tp.getRow() == setIndex &amp;&amp; !param.isSelected()) {
2369                                 selectedCellsMap.remove(tp);
2370                             }
2371                         }
2372                     }
2373 
2374                     if (oldTP != null &amp;&amp; param.isSelected()) {
2375                         TablePosition&lt;S,?&gt; newTP = new TablePosition&lt;&gt;(
2376                                 tableView, param.getSetIndex(), oldTP.getTableColumn());
2377 
2378                         selectedCellsMap.add(newTP);
2379                     }
2380 
2381                     stopAtomic();
2382 
2383                     return null;
2384                 }
2385             });
2386 
2387             previousModelSize = getItemCount();
2388         }
2389 
2390         /***********************************************************************
2391          *                                                                     *
2392          * Public selection API                                                *
2393          *                                                                     *
2394          **********************************************************************/
2395 
2396         @Override public void clearAndSelect(int row) {
2397             clearAndSelect(row, null);
2398         }
2399 
2400         @Override public void clearAndSelect(int row, TableColumn&lt;S,?&gt; column) {
2401             if (row &lt; 0 || row &gt;= getItemCount()) return;
2402 
2403             final TablePosition&lt;S,?&gt; newTablePosition = new TablePosition&lt;&gt;(getTableView(), row, column);
2404             final boolean isCellSelectionEnabled = isCellSelectionEnabled();
2405 
2406             // replace the anchor
2407             TableCellBehavior.setAnchor(tableView, newTablePosition, false);
2408 
2409             // firstly we make a copy of the selection, so that we can send out
2410             // the correct details in the selection change event.
2411             List&lt;TablePosition&lt;S,?&gt;&gt; previousSelection = new ArrayList&lt;&gt;(selectedCellsMap.getSelectedCells());
2412 
2413             // secondly we check if we can short-circuit out of here because the new selection
2414             // equals the current selection
2415             final boolean wasSelected = isSelected(row, column);
2416             if (wasSelected &amp;&amp; previousSelection.size() == 1) {
2417                 // before we return, we double-check that the selected item
2418                 // is equal to the item in the given index
2419                 TablePosition&lt;S,?&gt; selectedCell = getSelectedCells().get(0);
2420                 if (getSelectedItem() == getModelItem(row)) {
2421                     if (selectedCell.getRow() == row &amp;&amp; selectedCell.getTableColumn() == column) {
2422                         return;
2423                     }
2424                 }
2425             }
2426 
2427             // RT-32411 We used to call quietClearSelection() here, but this
2428             // resulted in the selectedItems and selectedIndices lists never
2429             // reporting that they were empty.
2430             // makeAtomic toggle added to resolve RT-32618
2431             startAtomic();
2432 
2433             // then clear the current selection
2434             clearSelection();
2435 
2436             // and select the new cell
2437             select(row, column);
2438 
2439             stopAtomic();
2440 
2441 
2442             // We remove the new selection from the list seeing as it is not removed.
2443             if (isCellSelectionEnabled) {
2444                 previousSelection.remove(newTablePosition);
2445             } else {
2446                 for (TablePosition&lt;S,?&gt; tp : previousSelection) {
2447                     if (tp.getRow() == row) {
2448                         previousSelection.remove(tp);
2449                         break;
2450                     }
2451                 }
2452             }
2453 
2454             // fire off a single add/remove/replace notification (rather than
2455             // individual remove and add notifications) - see RT-33324
2456             ListChangeListener.Change&lt;TablePosition&lt;S, ?&gt;&gt; change;
2457 
2458             /*
2459              * getFrom() documentation:
2460              *   If wasAdded is true, the interval contains all the values that were added.
2461              *   If wasPermutated is true, the interval marks the values that were permutated.
2462              *   If wasRemoved is true and wasAdded is false, getFrom() and getTo() should
2463              *   return the same number - the place where the removed elements were positioned in the list.
2464              */
2465             if (wasSelected) {
2466                 change = ControlUtils.buildClearAndSelectChange(selectedCellsSeq, previousSelection, row);
2467             } else {
2468                 final int changeIndex = isCellSelectionEnabled ? 0 : Math.max(0, selectedCellsSeq.indexOf(newTablePosition));
2469                 final int changeSize = isCellSelectionEnabled ? getSelectedCells().size() : 1;
2470                 change = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(
2471                         changeIndex, changeIndex + changeSize, previousSelection, selectedCellsSeq);
2472 //                selectedCellsSeq._beginChange();
2473 //                selectedCellsSeq._nextAdd(changeIndex, changeIndex + changeSize);
2474 //                selectedCellsSeq._nextRemove(changeIndex, previousSelection);
2475 //                selectedCellsSeq._endChange();
2476             }
2477             fireCustomSelectedCellsListChangeEvent(change);
2478         }
2479 
2480         @Override public void select(int row) {
2481             select(row, null);
2482         }
2483 
2484         @Override
2485         public void select(int row, TableColumn&lt;S,?&gt; column) {
2486             if (row &lt; 0 || row &gt;= getItemCount()) return;
2487 
2488             // if I&#39;m in cell selection mode but the column is null, select each
2489             // of the contained cells individually
2490             if (isCellSelectionEnabled() &amp;&amp; column == null) {
2491                 List&lt;TableColumn&lt;S,?&gt;&gt; columns = getTableView().getVisibleLeafColumns();
2492                 for (int i = 0; i &lt; columns.size(); i++) {
2493                     select(row, columns.get(i));
2494                 }
2495                 return;
2496             }
2497 
2498             if (TableCellBehavior.hasDefaultAnchor(tableView)) {
2499                 TableCellBehavior.removeAnchor(tableView);
2500             }
2501 
2502             if (getSelectionMode() == SelectionMode.SINGLE) {
2503                 quietClearSelection();
2504             }
2505             selectedCellsMap.add(new TablePosition&lt;&gt;(getTableView(), row, column));
2506 
2507             updateSelectedIndex(row);
2508             focus(row, column);
2509         }
2510 
2511         @Override public void select(S obj) {
2512             if (obj == null &amp;&amp; getSelectionMode() == SelectionMode.SINGLE) {
2513                 clearSelection();
2514                 return;
2515             }
2516 
2517             // We have no option but to iterate through the model and select the
2518             // first occurrence of the given object. Once we find the first one, we
2519             // don&#39;t proceed to select any others.
2520             S rowObj = null;
2521             for (int i = 0; i &lt; getItemCount(); i++) {
2522                 rowObj = getModelItem(i);
2523                 if (rowObj == null) continue;
2524 
2525                 if (rowObj.equals(obj)) {
2526                     if (isSelected(i)) {
2527                         return;
2528                     }
2529 
2530                     if (getSelectionMode() == SelectionMode.SINGLE) {
2531                         quietClearSelection();
2532                     }
2533 
2534                     select(i);
2535                     return;
2536                 }
2537             }
2538 
2539             // if we are here, we did not find the item in the entire data model.
2540             // Even still, we allow for this item to be set to the give object.
2541             // We expect that in concrete subclasses of this class we observe the
2542             // data model such that we check to see if the given item exists in it,
2543             // whilst SelectedIndex == -1 &amp;&amp; SelectedItem != null.
2544             setSelectedIndex(-1);
2545             setSelectedItem(obj);
2546         }
2547 
2548         @Override public void selectIndices(int row, int... rows) {
2549             if (rows == null) {
2550                 select(row);
2551                 return;
2552             }
2553 
2554             /*
2555              * Performance optimisation - if multiple selection is disabled, only
2556              * process the end-most row index.
2557              */
2558             int rowCount = getItemCount();
2559 
2560             if (getSelectionMode() == SelectionMode.SINGLE) {
2561                 quietClearSelection();
2562 
2563                 for (int i = rows.length - 1; i &gt;= 0; i--) {
2564                     int index = rows[i];
2565                     if (index &gt;= 0 &amp;&amp; index &lt; rowCount) {
2566                         select(index);
2567                         break;
2568                     }
2569                 }
2570 
2571                 if (selectedCellsMap.isEmpty()) {
2572                     if (row &gt; 0 &amp;&amp; row &lt; rowCount) {
2573                         select(row);
2574                     }
2575                 }
2576             } else {
2577                 int lastIndex = -1;
2578                 Set&lt;TablePosition&lt;S,?&gt;&gt; positions = new LinkedHashSet&lt;&gt;();
2579 
2580                 // --- firstly, we special-case the non-varargs &#39;row&#39; argument
2581                 if (row &gt;= 0 &amp;&amp; row &lt; rowCount) {
2582                     // if I&#39;m in cell selection mode, we want to select each
2583                     // of the contained cells individually
2584                     if (isCellSelectionEnabled()) {
2585                         List&lt;TableColumn&lt;S,?&gt;&gt; columns = getTableView().getVisibleLeafColumns();
2586                         for (int column = 0; column &lt; columns.size(); column++) {
2587                             if (! selectedCellsMap.isSelected(row, column)) {
2588                                 positions.add(new TablePosition&lt;&gt;(getTableView(), row, columns.get(column)));
2589                                 lastIndex = row;
2590                             }
2591                         }
2592                     } else {
2593                         boolean match = selectedCellsMap.isSelected(row, -1);
2594                         if (!match) {
2595                             positions.add(new TablePosition&lt;&gt;(getTableView(), row, null));
2596                         }
2597                     }
2598 
2599                     lastIndex = row;
2600                 }
2601 
2602                 // --- now we iterate through all varargs values
2603                 for (int i = 0; i &lt; rows.length; i++) {
2604                     int index = rows[i];
2605                     if (index &lt; 0 || index &gt;= rowCount) continue;
2606                     lastIndex = index;
2607 
2608                     if (isCellSelectionEnabled()) {
2609                         List&lt;TableColumn&lt;S,?&gt;&gt; columns = getTableView().getVisibleLeafColumns();
2610                         for (int column = 0; column &lt; columns.size(); column++) {
2611                             if (! selectedCellsMap.isSelected(index, column)) {
2612                                 positions.add(new TablePosition&lt;&gt;(getTableView(), index, columns.get(column)));
2613                                 lastIndex = index;
2614                             }
2615                         }
2616                     } else {
2617                         if (! selectedCellsMap.isSelected(index, -1)) {
2618                             // if we are here then we have successfully gotten through the for-loop above
2619                             positions.add(new TablePosition&lt;&gt;(getTableView(), index, null));
2620                         }
2621                     }
2622                 }
2623 
2624                 selectedCellsMap.addAll(positions);
2625 
2626                 if (lastIndex != -1) {
2627                     select(lastIndex);
2628                 }
2629             }
2630         }
2631 
2632         @Override public void selectAll() {
2633             if (getSelectionMode() == SelectionMode.SINGLE) return;
2634 
2635             if (isCellSelectionEnabled()) {
2636                 List&lt;TablePosition&lt;S,?&gt;&gt; indices = new ArrayList&lt;&gt;();
2637                 TableColumn&lt;S,?&gt; column;
2638                 TablePosition&lt;S,?&gt; tp = null;
2639                 for (int col = 0; col &lt; getTableView().getVisibleLeafColumns().size(); col++) {
2640                     column = getTableView().getVisibleLeafColumns().get(col);
2641                     for (int row = 0; row &lt; getItemCount(); row++) {
2642                         tp = new TablePosition&lt;&gt;(getTableView(), row, column);
2643                         indices.add(tp);
2644                     }
2645                 }
2646                 selectedCellsMap.setAll(indices);
2647 
2648                 if (tp != null) {
2649                     select(tp.getRow(), tp.getTableColumn());
2650                     focus(tp.getRow(), tp.getTableColumn());
2651                 }
2652             } else {
2653                 List&lt;TablePosition&lt;S,?&gt;&gt; indices = new ArrayList&lt;&gt;();
2654                 for (int i = 0; i &lt; getItemCount(); i++) {
2655                     indices.add(new TablePosition&lt;&gt;(getTableView(), i, null));
2656                 }
2657                 selectedCellsMap.setAll(indices);
2658 
2659                 int focusedIndex = getFocusedIndex();
2660                 if (focusedIndex == -1) {
2661                     final int itemCount = getItemCount();
2662                     if (itemCount &gt; 0) {
2663                         select(itemCount - 1);
2664                         focus(indices.get(indices.size() - 1));
2665                     }
2666                 } else {
2667                     select(focusedIndex);
2668                     focus(focusedIndex);
2669                 }
2670             }
2671         }
2672 
2673         @Override public void selectRange(int minRow, TableColumnBase&lt;S,?&gt; minColumn,
2674                                           int maxRow, TableColumnBase&lt;S,?&gt; maxColumn) {
2675             if (getSelectionMode() == SelectionMode.SINGLE) {
2676                 quietClearSelection();
2677                 select(maxRow, maxColumn);
2678                 return;
2679             }
2680 
2681             startAtomic();
2682 
2683             final int itemCount = getItemCount();
2684             final boolean isCellSelectionEnabled = isCellSelectionEnabled();
2685 
2686             final int minColumnIndex = tableView.getVisibleLeafIndex((TableColumn&lt;S,?&gt;)minColumn);
2687             final int maxColumnIndex = tableView.getVisibleLeafIndex((TableColumn&lt;S,?&gt;)maxColumn);
2688             final int _minColumnIndex = Math.min(minColumnIndex, maxColumnIndex);
2689             final int _maxColumnIndex = Math.max(minColumnIndex, maxColumnIndex);
2690 
2691             final int _minRow = Math.min(minRow, maxRow);
2692             final int _maxRow = Math.max(minRow, maxRow);
2693 
2694             List&lt;TablePosition&lt;S,?&gt;&gt; cellsToSelect = new ArrayList&lt;&gt;();
2695 
2696             for (int _row = _minRow; _row &lt;= _maxRow; _row++) {
2697                 // begin copy/paste of select(int, column) method (with some
2698                 // slight modifications)
2699                 if (_row &lt; 0 || _row &gt;= itemCount) continue;
2700 
2701                 if (! isCellSelectionEnabled) {
2702                     cellsToSelect.add(new TablePosition&lt;&gt;(tableView, _row, (TableColumn&lt;S,?&gt;)minColumn));
2703                 } else {
2704                     for (int _col = _minColumnIndex; _col &lt;= _maxColumnIndex; _col++) {
2705                         final TableColumn&lt;S, ?&gt; column = tableView.getVisibleLeafColumn(_col);
2706 
2707                         // if I&#39;m in cell selection mode but the column is null, I don&#39;t want
2708                         // to select the whole row instead...
2709                         if (column == null &amp;&amp; isCellSelectionEnabled) continue;
2710 
2711                         cellsToSelect.add(new TablePosition&lt;&gt;(tableView, _row, column));
2712                         // end copy/paste
2713                     }
2714                 }
2715             }
2716 
2717             // to prevent duplication we remove all currently selected cells from
2718             // our list of cells to select.
2719             cellsToSelect.removeAll(getSelectedCells());
2720 
2721             selectedCellsMap.addAll(cellsToSelect);
2722             stopAtomic();
2723 
2724             // fire off events.
2725             // Note that focus and selection always goes to maxRow, not _maxRow.
2726             updateSelectedIndex(maxRow);
2727             focus(maxRow, (TableColumn&lt;S,?&gt;)maxColumn);
2728 
2729             final TableColumn&lt;S,?&gt; startColumn = (TableColumn&lt;S,?&gt;)minColumn;
2730             final TableColumn&lt;S,?&gt; endColumn = isCellSelectionEnabled ? (TableColumn&lt;S,?&gt;)maxColumn : startColumn;
2731             final int startChangeIndex = selectedCellsMap.indexOf(new TablePosition&lt;&gt;(tableView, minRow, startColumn));
2732             final int endChangeIndex = selectedCellsMap.indexOf(new TablePosition&lt;&gt;(tableView, maxRow, endColumn));
2733 
2734             if (startChangeIndex &gt; -1 &amp;&amp; endChangeIndex &gt; -1) {
2735                 final int startIndex = Math.min(startChangeIndex, endChangeIndex);
2736                 final int endIndex = Math.max(startChangeIndex, endChangeIndex);
2737 
2738                 ListChangeListener.Change c = new NonIterableChange.SimpleAddChange&lt;&gt;(startIndex, endIndex + 1, selectedCellsSeq);
2739                 fireCustomSelectedCellsListChangeEvent(c);
2740 //                selectedCellsSeq.fireChange(() -&gt; selectedCellsSeq._nextAdd(startIndex, endIndex + 1));
2741             }
2742         }
2743 
2744         @Override public void clearSelection(int index) {
2745             clearSelection(index, null);
2746         }
2747 
2748         @Override
2749         public void clearSelection(int row, TableColumn&lt;S,?&gt; column) {
2750             clearSelection(new TablePosition&lt;&gt;(getTableView(), row, column));
2751         }
2752 
2753         private void clearSelection(TablePosition&lt;S,?&gt; tp) {
2754             final boolean csMode = isCellSelectionEnabled();
2755             final int row = tp.getRow();
2756             final boolean columnIsNull = tp.getTableColumn() == null;
2757 
2758             List&lt;TablePosition&gt; toRemove = new ArrayList&lt;&gt;();
2759             for (TablePosition pos : getSelectedCells()) {
2760                 if (!csMode) {
2761                     if (pos.getRow() == row) {
2762                         toRemove.add(pos);
2763                         break;
2764                     }
2765                 } else {
2766                     if (columnIsNull &amp;&amp; pos.getRow() == row) {
2767                         // if we are in cell selection mode and the column is null,
2768                         // we remove all items in the row
2769                         toRemove.add(pos);
2770                     } else if (pos.equals(tp)) {
2771                         toRemove.add(tp);
2772                         break;
2773                     }
2774                 }
2775             }
2776             toRemove.stream().forEach(selectedCellsMap::remove);
2777 
2778             if (isEmpty() &amp;&amp; ! isAtomic()) {
2779                 updateSelectedIndex(-1);
2780                 selectedCellsMap.clear();
2781             }
2782         }
2783 
2784         @Override public void clearSelection() {
2785             final List&lt;TablePosition&lt;S,?&gt;&gt; removed = new ArrayList&lt;&gt;((Collection)getSelectedCells());
2786 
2787             quietClearSelection();
2788 
2789             if (! isAtomic()) {
2790                 updateSelectedIndex(-1);
2791                 focus(-1);
2792 
2793                 if (!removed.isEmpty()) {
2794                     ListChangeListener.Change&lt;TablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange&lt;TablePosition&lt;S, ?&gt;&gt;(0, 0, selectedCellsSeq) {
2795                         @Override public List&lt;TablePosition&lt;S, ?&gt;&gt; getRemoved() {
2796                             return removed;
2797                         }
2798                     };
2799                     fireCustomSelectedCellsListChangeEvent(c);
2800 //                    selectedCellsSeq.fireChange(() -&gt; selectedCellsSeq._nextRemove(0, removed));
2801                 }
2802             }
2803         }
2804 
2805         private void quietClearSelection() {
2806             startAtomic();
2807             selectedCellsMap.clear();
2808             stopAtomic();
2809         }
2810 
2811         @Override public boolean isSelected(int index) {
2812             return isSelected(index, null);
2813         }
2814 
2815         @Override
2816         public boolean isSelected(int row, TableColumn&lt;S,?&gt; column) {
2817             // When in cell selection mode, if the column is null, then we interpret
2818             // the users query to be asking if _all_ of the cells in the row are selected,
2819             // rather than if _any_ of the cells in the row are selected.
2820             final boolean isCellSelectionEnabled = isCellSelectionEnabled();
2821             if (isCellSelectionEnabled &amp;&amp; column == null) {
2822                 int columnCount = tableView.getVisibleLeafColumns().size();
2823                 for (int col = 0; col &lt; columnCount; col++) {
2824                     if (!selectedCellsMap.isSelected(row, col)) {
2825                         return false;
2826                     }
2827                 }
2828                 return true;
2829             } else {
2830                 int columnIndex = !isCellSelectionEnabled || column == null ? -1 : tableView.getVisibleLeafIndex(column);
2831                 return selectedCellsMap.isSelected(row, columnIndex);
2832             }
2833         }
2834 
2835         @Override public boolean isEmpty() {
2836             return selectedCellsMap.isEmpty();
2837         }
2838 
2839         @Override public void selectPrevious() {
2840             if (isCellSelectionEnabled()) {
2841                 // in cell selection mode, we have to wrap around, going from
2842                 // right-to-left, and then wrapping to the end of the previous line
2843                 TablePosition&lt;S,?&gt; pos = getFocusedCell();
2844                 if (pos.getColumn() - 1 &gt;= 0) {
2845                     // go to previous row
2846                     select(pos.getRow(), getTableColumn(pos.getTableColumn(), -1));
2847                 } else if (pos.getRow() &lt; getItemCount() - 1) {
2848                     // wrap to end of previous row
2849                     select(pos.getRow() - 1, getTableColumn(getTableView().getVisibleLeafColumns().size() - 1));
2850                 }
2851             } else {
2852                 int focusIndex = getFocusedIndex();
2853                 if (focusIndex == -1) {
2854                     select(getItemCount() - 1);
2855                 } else if (focusIndex &gt; 0) {
2856                     select(focusIndex - 1);
2857                 }
2858             }
2859         }
2860 
2861         @Override public void selectNext() {
2862             if (isCellSelectionEnabled()) {
2863                 // in cell selection mode, we have to wrap around, going from
2864                 // left-to-right, and then wrapping to the start of the next line
2865                 TablePosition&lt;S,?&gt; pos = getFocusedCell();
2866                 if (pos.getColumn() + 1 &lt; getTableView().getVisibleLeafColumns().size()) {
2867                     // go to next column
2868                     select(pos.getRow(), getTableColumn(pos.getTableColumn(), 1));
2869                 } else if (pos.getRow() &lt; getItemCount() - 1) {
2870                     // wrap to start of next row
2871                     select(pos.getRow() + 1, getTableColumn(0));
2872                 }
2873             } else {
2874                 int focusIndex = getFocusedIndex();
2875                 if (focusIndex == -1) {
2876                     select(0);
2877                 } else if (focusIndex &lt; getItemCount() -1) {
2878                     select(focusIndex + 1);
2879                 }
2880             }
2881         }
2882 
2883         @Override public void selectAboveCell() {
2884             TablePosition&lt;S,?&gt; pos = getFocusedCell();
2885             if (pos.getRow() == -1) {
2886                 select(getItemCount() - 1);
2887             } else if (pos.getRow() &gt; 0) {
2888                 select(pos.getRow() - 1, pos.getTableColumn());
2889             }
2890         }
2891 
2892         @Override public void selectBelowCell() {
2893             TablePosition&lt;S,?&gt; pos = getFocusedCell();
2894 
2895             if (pos.getRow() == -1) {
2896                 select(0);
2897             } else if (pos.getRow() &lt; getItemCount() -1) {
2898                 select(pos.getRow() + 1, pos.getTableColumn());
2899             }
2900         }
2901 
2902         @Override public void selectFirst() {
2903             TablePosition&lt;S,?&gt; focusedCell = getFocusedCell();
2904 
2905             if (getSelectionMode() == SelectionMode.SINGLE) {
2906                 quietClearSelection();
2907             }
2908 
2909             if (getItemCount() &gt; 0) {
2910                 if (isCellSelectionEnabled()) {
2911                     select(0, focusedCell.getTableColumn());
2912                 } else {
2913                     select(0);
2914                 }
2915             }
2916         }
2917 
2918         @Override public void selectLast() {
2919             TablePosition&lt;S,?&gt; focusedCell = getFocusedCell();
2920 
2921             if (getSelectionMode() == SelectionMode.SINGLE) {
2922                 quietClearSelection();
2923             }
2924 
2925             int numItems = getItemCount();
2926             if (numItems &gt; 0 &amp;&amp; getSelectedIndex() &lt; numItems - 1) {
2927                 if (isCellSelectionEnabled()) {
2928                     select(numItems - 1, focusedCell.getTableColumn());
2929                 } else {
2930                     select(numItems - 1);
2931                 }
2932             }
2933         }
2934 
2935         @Override
2936         public void selectLeftCell() {
2937             if (! isCellSelectionEnabled()) return;
2938 
2939             TablePosition&lt;S,?&gt; pos = getFocusedCell();
2940             if (pos.getColumn() - 1 &gt;= 0) {
2941                 select(pos.getRow(), getTableColumn(pos.getTableColumn(), -1));
2942             }
2943         }
2944 
2945         @Override
2946         public void selectRightCell() {
2947             if (! isCellSelectionEnabled()) return;
2948 
2949             TablePosition&lt;S,?&gt; pos = getFocusedCell();
2950             if (pos.getColumn() + 1 &lt; getTableView().getVisibleLeafColumns().size()) {
2951                 select(pos.getRow(), getTableColumn(pos.getTableColumn(), 1));
2952             }
2953         }
2954 
2955 
2956 
2957         /***********************************************************************
2958          *                                                                     *
2959          * Support code                                                        *
2960          *                                                                     *
2961          **********************************************************************/
2962 
2963         private void updateItemsObserver(ObservableList&lt;S&gt; oldList, ObservableList&lt;S&gt; newList) {
2964             // the items list has changed, we need to observe
2965             // the new list, and remove any observer we had from the old list
2966             if (oldList != null) {
2967                 oldList.removeListener(weakItemsContentListener);
2968             }
2969             if (newList != null) {
2970                 newList.addListener(weakItemsContentListener);
2971             }
2972 
2973             updateItemCount();
2974             updateDefaultSelection();
2975         }
2976 
2977         private void updateDefaultSelection() {
2978             // when the items list totally changes, we should clear out
2979             // the selection
2980             int newSelectionIndex = -1;
2981             if (tableView.getItems() != null) {
2982                 S selectedItem = getSelectedItem();
2983                 if (selectedItem != null) {
2984                     newSelectionIndex = tableView.getItems().indexOf(selectedItem);
2985                 }
2986             }
2987 
2988             clearSelection();
2989             select(newSelectionIndex, isCellSelectionEnabled() ? getTableColumn(0) : null);
2990         }
2991 
2992         private TableColumn&lt;S,?&gt; getTableColumn(int pos) {
2993             return getTableView().getVisibleLeafColumn(pos);
2994         }
2995 
2996         // Gets a table column to the left or right of the current one, given an offset
2997         private TableColumn&lt;S,?&gt; getTableColumn(TableColumn&lt;S,?&gt; column, int offset) {
2998             int columnIndex = getTableView().getVisibleLeafIndex(column);
2999             int newColumnIndex = columnIndex + offset;
3000             return getTableView().getVisibleLeafColumn(newColumnIndex);
3001         }
3002 
3003         private void updateSelectedIndex(int row) {
3004             setSelectedIndex(row);
3005             setSelectedItem(getModelItem(row));
3006         }
3007 
3008         /** {@inheritDoc} */
3009         @Override protected int getItemCount() {
3010             return itemCount;
3011         }
3012 
3013         private void updateItemCount() {
3014             if (tableView == null) {
3015                 itemCount = -1;
3016             } else {
3017                 List&lt;S&gt; items = getTableModel();
3018                 itemCount = items == null ? -1 : items.size();
3019             }
3020         }
3021 
3022         private void fireCustomSelectedCellsListChangeEvent(ListChangeListener.Change&lt;? extends TablePosition&lt;S,?&gt;&gt; c) {
3023             ControlUtils.updateSelectedIndices(this, c);
3024 
3025             if (isAtomic()) {
3026                 return;
3027             }
3028 
3029             selectedCellsSeq.callObservers(new MappingChange&lt;&gt;(c, MappingChange.NOOP_MAP, selectedCellsSeq));
3030         }
3031     }
3032 
3033 
3034 
3035 
3036     /**
3037      * A {@link FocusModel} with additional functionality to support the requirements
3038      * of a TableView control.
3039      *
3040      * @see TableView
3041      * @since JavaFX 2.0
3042      */
3043     public static class TableViewFocusModel&lt;S&gt; extends TableFocusModel&lt;S, TableColumn&lt;S, ?&gt;&gt; {
3044 
3045         private final TableView&lt;S&gt; tableView;
3046 
3047         private final TablePosition&lt;S,?&gt; EMPTY_CELL;
3048 
3049         /**
3050          * Creates a default TableViewFocusModel instance that will be used to
3051          * manage focus of the provided TableView control.
3052          *
3053          * @param tableView The tableView upon which this focus model operates.
3054          * @throws NullPointerException The TableView argument can not be null.
3055          */
3056         public TableViewFocusModel(final TableView&lt;S&gt; tableView) {
3057             if (tableView == null) {
3058                 throw new NullPointerException(&quot;TableView can not be null&quot;);
3059             }
3060 
3061             this.tableView = tableView;
3062             this.EMPTY_CELL = new TablePosition&lt;&gt;(tableView, -1, null);
3063 
3064             itemsObserver = new InvalidationListener() {
3065                 private WeakReference&lt;ObservableList&lt;S&gt;&gt; weakItemsRef = new WeakReference&lt;&gt;(tableView.getItems());
3066 
3067                 @Override public void invalidated(Observable observable) {
3068                     ObservableList&lt;S&gt; oldItems = weakItemsRef.get();
3069                     weakItemsRef = new WeakReference&lt;&gt;(tableView.getItems());
3070                     updateItemsObserver(oldItems, tableView.getItems());
3071                 }
3072             };
3073             this.tableView.itemsProperty().addListener(new WeakInvalidationListener(itemsObserver));
3074             if (tableView.getItems() != null) {
3075                 this.tableView.getItems().addListener(weakItemsContentListener);
3076             }
3077 
3078             updateDefaultFocus();
3079 
3080             focusedCellProperty().addListener(o -&gt; {
3081                 tableView.notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
3082             });
3083         }
3084 
3085         private final InvalidationListener itemsObserver;
3086 
3087         // Listen to changes in the tableview items list, such that when it
3088         // changes we can update the focused index to refer to the new indices.
3089         private final ListChangeListener&lt;S&gt; itemsContentListener = c -&gt; {
3090             c.next();
3091 
3092             if (c.wasReplaced() || c.getAddedSize() == getItemCount()) {
3093                 updateDefaultFocus();
3094                 return;
3095             }
3096 
3097             TablePosition&lt;S,?&gt; focusedCell = getFocusedCell();
3098             final int focusedIndex = focusedCell.getRow();
3099             if (focusedIndex == -1 || c.getFrom() &gt; focusedIndex) {
3100                 return;
3101             }
3102 
3103             c.reset();
3104             boolean added = false;
3105             boolean removed = false;
3106             int addedSize = 0;
3107             int removedSize = 0;
3108             while (c.next()) {
3109                 added |= c.wasAdded();
3110                 removed |= c.wasRemoved();
3111                 addedSize += c.getAddedSize();
3112                 removedSize += c.getRemovedSize();
3113             }
3114 
3115             if (added &amp;&amp; ! removed) {
3116                 if (addedSize &lt; c.getList().size()) {
3117                     final int newFocusIndex = Math.min(getItemCount() - 1, getFocusedIndex() + addedSize);
3118                     focus(newFocusIndex, focusedCell.getTableColumn());
3119                 }
3120             } else if (!added &amp;&amp; removed) {
3121                 final int newFocusIndex = Math.max(0, getFocusedIndex() - removedSize);
3122                 if (newFocusIndex &lt; 0) {
3123                     focus(0, focusedCell.getTableColumn());
3124                 } else {
3125                     focus(newFocusIndex, focusedCell.getTableColumn());
3126                 }
3127             }
3128         };
3129 
3130         private WeakListChangeListener&lt;S&gt; weakItemsContentListener
3131                 = new WeakListChangeListener&lt;&gt;(itemsContentListener);
3132 
3133         private void updateItemsObserver(ObservableList&lt;S&gt; oldList, ObservableList&lt;S&gt; newList) {
3134             // the tableview items list has changed, we need to observe
3135             // the new list, and remove any observer we had from the old list
3136             if (oldList != null) oldList.removeListener(weakItemsContentListener);
3137             if (newList != null) newList.addListener(weakItemsContentListener);
3138 
3139             updateDefaultFocus();
3140         }
3141 
3142         /** {@inheritDoc} */
3143         @Override protected int getItemCount() {
3144             if (tableView.getItems() == null) return -1;
3145             return tableView.getItems().size();
3146         }
3147 
3148         /** {@inheritDoc} */
3149         @Override protected S getModelItem(int index) {
3150             if (tableView.getItems() == null) return null;
3151 
3152             if (index &lt; 0 || index &gt;= getItemCount()) return null;
3153 
3154             return tableView.getItems().get(index);
3155         }
3156 
3157         /**
3158          * The position of the current item in the TableView which has the focus.
3159          */
3160         private ReadOnlyObjectWrapper&lt;TablePosition&gt; focusedCell;
3161         public final ReadOnlyObjectProperty&lt;TablePosition&gt; focusedCellProperty() {
3162             return focusedCellPropertyImpl().getReadOnlyProperty();
3163         }
3164         private void setFocusedCell(TablePosition value) { focusedCellPropertyImpl().set(value);  }
3165         public final TablePosition getFocusedCell() { return focusedCell == null ? EMPTY_CELL : focusedCell.get(); }
3166 
3167         private ReadOnlyObjectWrapper&lt;TablePosition&gt; focusedCellPropertyImpl() {
3168             if (focusedCell == null) {
3169                 focusedCell = new ReadOnlyObjectWrapper&lt;TablePosition&gt;(EMPTY_CELL) {
3170                     private TablePosition old;
3171                     @Override protected void invalidated() {
3172                         if (get() == null) return;
3173 
3174                         if (old == null || !old.equals(get())) {
3175                             setFocusedIndex(get().getRow());
3176                             setFocusedItem(getModelItem(getValue().getRow()));
3177 
3178                             old = get();
3179                         }
3180                     }
3181 
3182                     @Override
3183                     public Object getBean() {
3184                         return TableViewFocusModel.this;
3185                     }
3186 
3187                     @Override
3188                     public String getName() {
3189                         return &quot;focusedCell&quot;;
3190                     }
3191                 };
3192             }
3193             return focusedCell;
3194         }
3195 
3196 
3197         /**
3198          * Causes the item at the given index to receive the focus.
3199          *
3200          * @param row The row index of the item to give focus to.
3201          * @param column The column of the item to give focus to. Can be null.
3202          */
3203         @Override public void focus(int row, TableColumn&lt;S,?&gt; column) {
3204             if (row &lt; 0 || row &gt;= getItemCount()) {
3205                 setFocusedCell(EMPTY_CELL);
3206             } else {
3207                 TablePosition&lt;S,?&gt; oldFocusCell = getFocusedCell();
3208                 TablePosition&lt;S,?&gt; newFocusCell = new TablePosition&lt;&gt;(tableView, row, column);
3209                 setFocusedCell(newFocusCell);
3210 
3211                 if (newFocusCell.equals(oldFocusCell)) {
3212                     // manually update the focus properties to ensure consistency
3213                     setFocusedIndex(row);
3214                     setFocusedItem(getModelItem(row));
3215                 }
3216             }
3217         }
3218 
3219         /**
3220          * Convenience method for setting focus on a particular row or cell
3221          * using a {@link TablePosition}.
3222          *
3223          * @param pos The table position where focus should be set.
3224          */
3225         public void focus(TablePosition pos) {
3226             if (pos == null) return;
3227             focus(pos.getRow(), pos.getTableColumn());
3228         }
3229 
3230 
3231         /***********************************************************************
3232          *                                                                     *
3233          * Public API                                                          *
3234          *                                                                     *
3235          **********************************************************************/
3236 
3237         /**
3238          * Tests whether the row / cell at the given location currently has the
3239          * focus within the TableView.
3240          */
3241         @Override public boolean isFocused(int row, TableColumn&lt;S,?&gt; column) {
3242             if (row &lt; 0 || row &gt;= getItemCount()) return false;
3243 
3244             TablePosition cell = getFocusedCell();
3245             boolean columnMatch = column == null || column.equals(cell.getTableColumn());
3246 
3247             return cell.getRow() == row &amp;&amp; columnMatch;
3248         }
3249 
3250         /**
3251          * Causes the item at the given index to receive the focus. This does not
3252          * cause the current selection to change. Updates the focusedItem and
3253          * focusedIndex properties such that &lt;code&gt;focusedIndex = -1&lt;/code&gt; unless
3254          * &lt;pre&gt;&lt;code&gt;0 &amp;lt;= index &amp;lt; model size&lt;/code&gt;&lt;/pre&gt;.
3255          *
3256          * @param index The index of the item to get focus.
3257          */
3258         @Override public void focus(int index) {
3259             if (index &lt; 0 || index &gt;= getItemCount()) {
3260                 setFocusedCell(EMPTY_CELL);
3261             } else {
3262                 setFocusedCell(new TablePosition&lt;&gt;(tableView, index, null));
3263             }
3264         }
3265 
3266         /**
3267          * Attempts to move focus to the cell above the currently focused cell.
3268          */
3269         @Override public void focusAboveCell() {
3270             TablePosition cell = getFocusedCell();
3271 
3272             if (getFocusedIndex() == -1) {
3273                 focus(getItemCount() - 1, cell.getTableColumn());
3274             } else if (getFocusedIndex() &gt; 0) {
3275                 focus(getFocusedIndex() - 1, cell.getTableColumn());
3276             }
3277         }
3278 
3279         /**
3280          * Attempts to move focus to the cell below the currently focused cell.
3281          */
3282         @Override public void focusBelowCell() {
3283             TablePosition cell = getFocusedCell();
3284             if (getFocusedIndex() == -1) {
3285                 focus(0, cell.getTableColumn());
3286             } else if (getFocusedIndex() != getItemCount() -1) {
3287                 focus(getFocusedIndex() + 1, cell.getTableColumn());
3288             }
3289         }
3290 
3291         /**
3292          * Attempts to move focus to the cell to the left of the currently focused cell.
3293          */
3294         @Override public void focusLeftCell() {
3295             TablePosition cell = getFocusedCell();
3296             if (cell.getColumn() &lt;= 0) return;
3297             focus(cell.getRow(), getTableColumn(cell.getTableColumn(), -1));
3298         }
3299 
3300         /**
3301          * Attempts to move focus to the cell to the right of the the currently focused cell.
3302          */
3303         @Override public void focusRightCell() {
3304             TablePosition cell = getFocusedCell();
3305             if (cell.getColumn() == getColumnCount() - 1) return;
3306             focus(cell.getRow(), getTableColumn(cell.getTableColumn(), 1));
3307         }
3308 
3309         /** {@inheritDoc} */
3310         @Override public void focusPrevious() {
3311             if (getFocusedIndex() == -1) {
3312                 focus(0);
3313             } else if (getFocusedIndex() &gt; 0) {
3314                 focusAboveCell();
3315             }
3316         }
3317 
3318         /** {@inheritDoc} */
3319         @Override public void focusNext() {
3320             if (getFocusedIndex() == -1) {
3321                 focus(0);
3322             } else if (getFocusedIndex() != getItemCount() -1) {
3323                 focusBelowCell();
3324             }
3325         }
3326 
3327         /***********************************************************************
3328          *                                                                     *
3329          * Private Implementation                                              *
3330          *                                                                     *
3331          **********************************************************************/
3332 
3333         private void updateDefaultFocus() {
3334             // when the items list totally changes, we should clear out
3335             // the focus
3336             int newValueIndex = -1;
3337             if (tableView.getItems() != null) {
3338                 S focusedItem = getFocusedItem();
3339                 if (focusedItem != null) {
3340                     newValueIndex = tableView.getItems().indexOf(focusedItem);
3341                 }
3342 
3343                 // we put focus onto the first item, if there is at least
3344                 // one item in the list
3345                 if (newValueIndex == -1) {
3346                     newValueIndex = tableView.getItems().size() &gt; 0 ? 0 : -1;
3347                 }
3348             }
3349 
3350             TablePosition&lt;S,?&gt; focusedCell = getFocusedCell();
3351             TableColumn&lt;S,?&gt; focusColumn = focusedCell != null &amp;&amp; !EMPTY_CELL.equals(focusedCell) ?
3352                focusedCell.getTableColumn() : tableView.getVisibleLeafColumn(0);
3353 
3354             focus(newValueIndex, focusColumn);
3355         }
3356 
3357         private int getColumnCount() {
3358             return tableView.getVisibleLeafColumns().size();
3359         }
3360 
3361         // Gets a table column to the left or right of the current one, given an offset
3362         private TableColumn&lt;S,?&gt; getTableColumn(TableColumn&lt;S,?&gt; column, int offset) {
3363             int columnIndex = tableView.getVisibleLeafIndex(column);
3364             int newColumnIndex = columnIndex + offset;
3365             return tableView.getVisibleLeafColumn(newColumnIndex);
3366         }
3367     }
3368 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
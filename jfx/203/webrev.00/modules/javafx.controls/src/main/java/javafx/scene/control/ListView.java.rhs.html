<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/ListView.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control;
  27 
  28 import java.util.ArrayList;
  29 import java.util.Collections;
  30 import java.util.HashMap;
  31 import java.util.List;
  32 
  33 import com.sun.javafx.scene.control.Properties;
  34 import com.sun.javafx.scene.control.behavior.ListCellBehavior;
  35 import javafx.beans.InvalidationListener;
  36 import javafx.beans.Observable;
  37 import javafx.beans.WeakInvalidationListener;
  38 import javafx.beans.property.BooleanProperty;
  39 import javafx.beans.property.DoubleProperty;
  40 import javafx.beans.property.ObjectProperty;
  41 import javafx.beans.property.ObjectPropertyBase;
  42 import javafx.beans.property.ReadOnlyIntegerProperty;
  43 import javafx.beans.property.ReadOnlyIntegerWrapper;
  44 import javafx.beans.property.SimpleBooleanProperty;
  45 import javafx.beans.property.SimpleObjectProperty;
  46 import javafx.beans.value.WritableValue;
  47 import javafx.collections.FXCollections;
  48 import javafx.collections.ListChangeListener;
  49 import javafx.collections.ListChangeListener.Change;
  50 import javafx.collections.MapChangeListener;
  51 import javafx.collections.ObservableList;
  52 import javafx.css.StyleableDoubleProperty;
  53 import javafx.event.Event;
  54 import javafx.event.EventHandler;
  55 import javafx.event.EventType;
  56 import javafx.geometry.Orientation;
  57 import javafx.scene.layout.Region;
  58 import javafx.util.Callback;
  59 import javafx.css.StyleableObjectProperty;
  60 import javafx.css.CssMetaData;
  61 
  62 import javafx.css.converter.EnumConverter;
  63 
  64 import javafx.collections.WeakListChangeListener;
  65 
  66 import javafx.css.converter.SizeConverter;
  67 import javafx.scene.control.skin.ListViewSkin;
  68 
  69 import java.lang.ref.WeakReference;
  70 
  71 import javafx.css.PseudoClass;
  72 import javafx.beans.DefaultProperty;
  73 import javafx.css.Styleable;
  74 import javafx.css.StyleableProperty;
  75 import javafx.scene.AccessibleAttribute;
  76 import javafx.scene.AccessibleRole;
  77 import javafx.scene.Node;
  78 import javafx.util.Pair;
  79 
  80 /**
  81  * A ListView displays a horizontal or vertical list of items from which the
  82  * user may select, or with which the user may interact. A ListView is able to
  83  * have its generic type set to represent the type of data in the backing model.
  84  * Doing this has the benefit of making various methods in the ListView, as well
  85  * as the supporting classes (mentioned below), type-safe. In addition, making
  86  * use of the generic type supports substantially simplified development of applications
  87  * making use of ListView, as all modern IDEs are able to auto-complete far
  88  * more successfully with the additional type information.
  89  *
  90  * &lt;h2&gt;Populating a ListView&lt;/h2&gt;
  91  * &lt;p&gt;A simple example of how to create and populate a ListView of names (Strings)
  92  * is shown here:
  93  *
  94  * &lt;pre&gt; {@code ObservableList&lt;String&gt; names = FXCollections.observableArrayList(
  95  *          &quot;Julia&quot;, &quot;Ian&quot;, &quot;Sue&quot;, &quot;Matthew&quot;, &quot;Hannah&quot;, &quot;Stephan&quot;, &quot;Denise&quot;);
  96  * ListView&lt;String&gt; listView = new ListView&lt;String&gt;(names);}&lt;/pre&gt;
  97  *
  98  * &lt;p&gt;The elements of the ListView are contained within the
  99  * {@link #itemsProperty() items} {@link ObservableList}. This
 100  * ObservableList is automatically observed by the ListView, such that any
 101  * changes that occur inside the ObservableList will be automatically shown in
 102  * the ListView itself. If passing the &lt;code&gt;ObservableList&lt;/code&gt; in to the
 103  * ListView constructor is not feasible, the recommended approach for setting
 104  * the items is to simply call:
 105  *
 106  * &lt;pre&gt; {@code ObservableList&lt;T&gt; content = ...
 107  * listView.setItems(content);}&lt;/pre&gt;
 108  *
 109  * &lt;img src=&quot;doc-files/ListView.png&quot; alt=&quot;Image of the ListView control&quot;&gt;
 110  *
 111  * &lt;p&gt;The end result of this is, as noted above, that the ListView will automatically
 112  * refresh the view to represent the items in the list.
 113  *
 114  * &lt;p&gt;Another approach, whilst accepted by the ListView, &lt;b&gt;is not the
 115  * recommended approach&lt;/b&gt;:
 116  *
 117  * &lt;pre&gt; {@code List&lt;T&gt; content = ...
 118  * getItems().setAll(content);}&lt;/pre&gt;
 119  *
 120  * The issue with the approach shown above is that the content list is being
 121  * copied into the items list - meaning that subsequent changes to the content
 122  * list are not observed, and will not be reflected visually within the ListView.
 123  *
 124  * &lt;h2&gt;ListView Selection / Focus APIs&lt;/h2&gt;
 125  * &lt;p&gt;To track selection and focus, it is necessary to become familiar with the
 126  * {@link SelectionModel} and {@link FocusModel} classes. A ListView has at most
 127  * one instance of each of these classes, available from
 128  * {@link #selectionModelProperty() selectionModel} and
 129  * {@link #focusModelProperty() focusModel} properties respectively.
 130  * Whilst it is possible to use this API to set a new selection model, in
 131  * most circumstances this is not necessary - the default selection and focus
 132  * models should work in most circumstances.
 133  *
 134  * &lt;p&gt;The default {@link SelectionModel} used when instantiating a ListView is
 135  * an implementation of the {@link MultipleSelectionModel} abstract class.
 136  * However, as noted in the API documentation for
 137  * the {@link MultipleSelectionModel#selectionModeProperty() selectionMode}
 138  * property, the default value is {@link SelectionMode#SINGLE}. To enable
 139  * multiple selection in a default ListView instance, it is therefore necessary
 140  * to do the following:
 141  *
 142  * &lt;pre&gt; {@code listView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);}&lt;/pre&gt;
 143  *
 144  * &lt;h2&gt;Customizing ListView Visuals&lt;/h2&gt;
 145  * &lt;p&gt;The visuals of the ListView can be entirely customized by replacing the
 146  * default {@link #cellFactoryProperty() cell factory}. A cell factory is used to
 147  * generate {@link ListCell} instances, which are used to represent an item in the
 148  * ListView. See the {@link Cell} class documentation for a more complete
 149  * description of how to write custom Cells.
 150  *
 151  * &lt;h2&gt;Editing&lt;/h2&gt;
 152  * &lt;p&gt;This control supports inline editing of values, and this section attempts to
 153  * give an overview of the available APIs and how you should use them.&lt;/p&gt;
 154  *
 155  * &lt;p&gt;Firstly, cell editing most commonly requires a different user interface
 156  * than when a cell is not being edited. This is the responsibility of the
 157  * {@link Cell} implementation being used. For ListView, this is the responsibility
 158  * of the {@link #cellFactoryProperty() cell factory}. It is your choice whether the cell is
 159  * permanently in an editing state (e.g. this is common for {@link CheckBox} cells),
 160  * or to switch to a different UI when editing begins (e.g. when a double-click
 161  * is received on a cell).&lt;/p&gt;
 162  *
 163  * &lt;p&gt;To know when editing has been requested on a cell,
 164  * simply override the {@link javafx.scene.control.Cell#startEdit()} method, and
 165  * update the cell {@link javafx.scene.control.Cell#textProperty() text} and
 166  * {@link javafx.scene.control.Cell#graphicProperty() graphic} properties as
 167  * appropriate (e.g. set the text to null and set the graphic to be a
 168  * {@link TextField}). Additionally, you should also override
 169  * {@link Cell#cancelEdit()} to reset the UI back to its original visual state
 170  * when the editing concludes. In both cases it is important that you also
 171  * ensure that you call the super method to have the cell perform all duties it
 172  * must do to enter or exit its editing mode.&lt;/p&gt;
 173  *
 174  * &lt;p&gt;Once your cell is in an editing state, the next thing you are most probably
 175  * interested in is how to commit or cancel the editing that is taking place. This is your
 176  * responsibility as the cell factory provider. Your cell implementation will know
 177  * when the editing is over, based on the user input (e.g. when the user presses
 178  * the Enter or ESC keys on their keyboard). When this happens, it is your
 179  * responsibility to call {@link Cell#commitEdit(Object)} or
 180  * {@link Cell#cancelEdit()}, as appropriate.&lt;/p&gt;
 181  *
 182  * &lt;p&gt;When you call {@link Cell#commitEdit(Object)} an event is fired to the
 183  * ListView, which you can observe by adding an {@link EventHandler} via
 184  * {@link ListView#setOnEditCommit(javafx.event.EventHandler)}. Similarly,
 185  * you can also observe edit events for
 186  * {@link ListView#setOnEditStart(javafx.event.EventHandler) edit start}
 187  * and {@link ListView#setOnEditCancel(javafx.event.EventHandler) edit cancel}.&lt;/p&gt;
 188  *
 189  * &lt;p&gt;By default the ListView edit commit handler is non-null, with a default
 190  * handler that attempts to overwrite the property value for the
 191  * item in the currently-being-edited row. It is able to do this as the
 192  * {@link Cell#commitEdit(Object)} method is passed in the new value, and this
 193  * is passed along to the edit commit handler via the
 194  * {@link EditEvent} that is fired. It is simply a matter of calling
 195  * {@link EditEvent#getNewValue()} to retrieve this value.
 196  *
 197  * &lt;p&gt;It is very important to note that if you call
 198  * {@link ListView#setOnEditCommit(javafx.event.EventHandler)} with your own
 199  * {@link EventHandler}, then you will be removing the default handler. Unless
 200  * you then handle the writeback to the property (or the relevant data source),
 201  * nothing will happen. You can work around this by using the
 202  * {@link ListView#addEventHandler(javafx.event.EventType, javafx.event.EventHandler)}
 203  * method to add a {@link ListView#editCommitEvent()} {@link EventType} with
 204  * your desired {@link EventHandler} as the second argument. Using this method,
 205  * you will not replace the default implementation, but you will be notified when
 206  * an edit commit has occurred.&lt;/p&gt;
 207  *
 208  * &lt;p&gt;Hopefully this summary answers some of the commonly asked questions.
 209  * Fortunately, JavaFX ships with a number of pre-built cell factories that
 210  * handle all the editing requirements on your behalf. You can find these
 211  * pre-built cell factories in the javafx.scene.control.cell package.&lt;/p&gt;
 212  *
 213  * @see ListCell
 214  * @see MultipleSelectionModel
 215  * @see FocusModel
 216  * @param &lt;T&gt; This type is used to represent the type of the objects stored in
 217  *          the ListViews {@link #itemsProperty() items} ObservableList. It is
 218  *          also used in the {@link #selectionModelProperty() selection model}
 219  *          and {@link #focusModelProperty() focus model}.
 220  * @since JavaFX 2.0
 221  */
 222 // TODO add code examples
 223 @DefaultProperty(&quot;items&quot;)
 224 public class ListView&lt;T&gt; extends Control {
 225 
 226     /***************************************************************************
 227      *                                                                         *
 228      * Static properties and methods                                           *
 229      *                                                                         *
 230      **************************************************************************/
 231 
 232     /**
 233      * An EventType that indicates some edit event has occurred. It is the parent
 234      * type of all other edit events: {@link #editStartEvent()},
 235      *  {@link #editCommitEvent()} and {@link #editCancelEvent()}.
 236      * @param &lt;T&gt; the type of the objects stored in this ListView
 237      * @return the event type
 238      */
 239     @SuppressWarnings(&quot;unchecked&quot;)
 240     public static &lt;T&gt; EventType&lt;ListView.EditEvent&lt;T&gt;&gt; editAnyEvent() {
 241         return (EventType&lt;ListView.EditEvent&lt;T&gt;&gt;) EDIT_ANY_EVENT;
 242     }
 243     private static final EventType&lt;?&gt; EDIT_ANY_EVENT =
 244             new EventType&lt;&gt;(Event.ANY, &quot;LIST_VIEW_EDIT&quot;);
 245 
 246     /**
 247      * An EventType used to indicate that an edit event has started within the
 248      * ListView upon which the event was fired.
 249      * @param &lt;T&gt; the type of the objects stored in this ListView
 250      * @return the event type
 251      */
 252     @SuppressWarnings(&quot;unchecked&quot;)
 253     public static &lt;T&gt; EventType&lt;ListView.EditEvent&lt;T&gt;&gt; editStartEvent() {
 254         return (EventType&lt;ListView.EditEvent&lt;T&gt;&gt;) EDIT_START_EVENT;
 255     }
 256     private static final EventType&lt;?&gt; EDIT_START_EVENT =
 257             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_START&quot;);
 258 
 259     /**
 260      * An EventType used to indicate that an edit event has just been canceled
 261      * within the ListView upon which the event was fired.
 262      * @param &lt;T&gt; the type of the objects stored in this ListView
 263      * @return the event type
 264      */
 265     @SuppressWarnings(&quot;unchecked&quot;)
 266     public static &lt;T&gt; EventType&lt;ListView.EditEvent&lt;T&gt;&gt; editCancelEvent() {
 267         return (EventType&lt;ListView.EditEvent&lt;T&gt;&gt;) EDIT_CANCEL_EVENT;
 268     }
 269     private static final EventType&lt;?&gt; EDIT_CANCEL_EVENT =
 270             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_CANCEL&quot;);
 271 
 272     /**
 273      * An EventType used to indicate that an edit event has been committed
 274      * within the ListView upon which the event was fired.
 275      * @param &lt;T&gt; the type of the objects stored in this ListView
 276      * @return the event type
 277      */
 278     @SuppressWarnings(&quot;unchecked&quot;)
 279     public static &lt;T&gt; EventType&lt;ListView.EditEvent&lt;T&gt;&gt; editCommitEvent() {
 280         return (EventType&lt;ListView.EditEvent&lt;T&gt;&gt;) EDIT_COMMIT_EVENT;
 281     }
 282     private static final EventType&lt;?&gt; EDIT_COMMIT_EVENT =
 283             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_COMMIT&quot;);
 284 
 285 
 286 
 287     /***************************************************************************
 288      *                                                                         *
 289      * Fields                                                                  *
 290      *                                                                         *
 291      **************************************************************************/
 292 
 293     // by default we always select the first row in the ListView, and when the
 294     // items list changes, we also reselect the first row. In some cases, such as
 295     // for the ComboBox, this is not desirable, so it can be disabled here.
 296     private boolean selectFirstRowByDefault = true;
 297 
 298 
 299 
 300     /***************************************************************************
 301      *                                                                         *
 302      * Constructors                                                            *
 303      *                                                                         *
 304      **************************************************************************/
 305 
 306     /**
 307      * Creates a default ListView which will display contents stacked vertically.
 308      * As no {@link ObservableList} is provided in this constructor, an empty
 309      * ObservableList is created, meaning that it is legal to directly call
 310      * {@link #getItems()} if so desired. However, as noted elsewhere, this
 311      * is not the recommended approach
 312      * (instead call {@link #setItems(javafx.collections.ObservableList)}).
 313      *
 314      * &lt;p&gt;Refer to the {@link ListView} class documentation for details on the
 315      * default state of other properties.
 316      */
 317     public ListView() {
 318         this(FXCollections.&lt;T&gt;observableArrayList());
 319     }
 320 
 321     /**
 322      * Creates a default ListView which will stack the contents retrieved from the
 323      * provided {@link ObservableList} vertically.
 324      *
 325      * &lt;p&gt;Attempts to add a listener to the {@link ObservableList}, such that all
 326      * subsequent changes inside the list will be shown to the user.
 327      *
 328      * &lt;p&gt;Refer to the {@link ListView} class documentation for details on the
 329      * default state of other properties.
 330      * @param items the list of items
 331      */
 332     public ListView(ObservableList&lt;T&gt; items) {
 333         getStyleClass().setAll(DEFAULT_STYLE_CLASS);
 334         setAccessibleRole(AccessibleRole.LIST_VIEW);
 335 
 336         setItems(items);
 337 
 338         // Install default....
 339         // ...selection model
 340         setSelectionModel(new ListView.ListViewBitSetSelectionModel&lt;T&gt;(this));
 341 
 342         // ...focus model
 343         setFocusModel(new ListView.ListViewFocusModel&lt;T&gt;(this));
 344 
 345         // ...edit commit handler
 346         setOnEditCommit(DEFAULT_EDIT_COMMIT_HANDLER);
 347 
 348         // Fix for RT-36651, which was introduced by RT-35679 (above) and resolved
 349         // by having special-case code to remove the listener when requested.
 350         // This is done by ComboBoxListViewSkin, so that selection is not done
 351         // when a ComboBox is shown.
 352         getProperties().addListener((MapChangeListener&lt;Object, Object&gt;) change -&gt; {
 353             if (change.wasAdded() &amp;&amp; &quot;selectFirstRowByDefault&quot;.equals(change.getKey())) {
 354                 Boolean _selectFirstRowByDefault = (Boolean) change.getValueAdded();
 355                 if (_selectFirstRowByDefault == null) return;
 356                 selectFirstRowByDefault = _selectFirstRowByDefault;
 357             }
 358         });
 359     }
 360 
 361 
 362 
 363     /***************************************************************************
 364      *                                                                         *
 365      * Callbacks and Events                                                    *
 366      *                                                                         *
 367      **************************************************************************/
 368 
 369     private EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt; DEFAULT_EDIT_COMMIT_HANDLER = t -&gt; {
 370         int index = t.getIndex();
 371         List&lt;T&gt; list = getItems();
 372         if (index &lt; 0 || index &gt;= list.size()) return;
 373         list.set(index, t.getNewValue());
 374     };
 375 
 376 
 377 
 378     /***************************************************************************
 379      *                                                                         *
 380      * Properties                                                              *
 381      *                                                                         *
 382      **************************************************************************/
 383 
 384     // --- Items
 385     private ObjectProperty&lt;ObservableList&lt;T&gt;&gt; items;
 386 
 387     /**
 388      * Sets the underlying data model for the ListView. Note that it has a generic
 389      * type that must match the type of the ListView itself.
 390      * @param value the list of items for this ListView
 391      */
 392     public final void setItems(ObservableList&lt;T&gt; value) {
 393         itemsProperty().set(value);
 394     }
 395 
 396     /**
 397      * Returns an {@link ObservableList} that contains the items currently being
 398      * shown to the user. This may be null if
 399      * {@link #setItems(javafx.collections.ObservableList)} has previously been
 400      * called, however, by default it is an empty ObservableList.
 401      *
 402      * @return An ObservableList containing the items to be shown to the user, or
 403      *      null if the items have previously been set to null.
 404      */
 405     public final ObservableList&lt;T&gt; getItems() {
 406         return items == null ? null : items.get();
 407     }
 408 
 409     /**
 410      * The underlying data model for the ListView. Note that it has a generic
 411      * type that must match the type of the ListView itself.
 412      * @return the items property for this ListView
 413      */
 414     public final ObjectProperty&lt;ObservableList&lt;T&gt;&gt; itemsProperty() {
 415         if (items == null) {
 416             items = new SimpleObjectProperty&lt;&gt;(this, &quot;items&quot;);
 417         }
 418         return items;
 419     }
 420 
 421 
 422     // --- Placeholder Node
 423     private ObjectProperty&lt;Node&gt; placeholder;
 424     /**
 425      * This Node is shown to the user when the listview has no content to show.
 426      * This may be the case because the table model has no data in the first
 427      * place or that a filter has been applied to the list model, resulting
 428      * in there being nothing to show the user..
 429      * @return the placeholder property for this ListView
 430      * @since JavaFX 8.0
 431      */
 432     public final ObjectProperty&lt;Node&gt; placeholderProperty() {
 433         if (placeholder == null) {
 434             placeholder = new SimpleObjectProperty&lt;Node&gt;(this, &quot;placeholder&quot;);
 435         }
 436         return placeholder;
 437     }
 438     public final void setPlaceholder(Node value) {
 439         placeholderProperty().set(value);
 440     }
 441     public final Node getPlaceholder() {
 442         return placeholder == null ? null : placeholder.get();
 443     }
 444 
 445 
 446     // --- Selection Model
 447     private ObjectProperty&lt;MultipleSelectionModel&lt;T&gt;&gt; selectionModel = new SimpleObjectProperty&lt;MultipleSelectionModel&lt;T&gt;&gt;(this, &quot;selectionModel&quot;);
 448 
 449     /**
 450      * Sets the {@link MultipleSelectionModel} to be used in the ListView.
 451      * Despite a ListView requiring a &lt;b&gt;Multiple&lt;/b&gt;SelectionModel, it is possible
 452      * to configure it to only allow single selection (see
 453      * {@link MultipleSelectionModel#setSelectionMode(javafx.scene.control.SelectionMode)}
 454      * for more information).
 455      * @param value the MultipleSelectionModel to be used in this ListView
 456      */
 457     public final void setSelectionModel(MultipleSelectionModel&lt;T&gt; value) {
 458         selectionModelProperty().set(value);
 459     }
 460 
 461     /**
 462      * Returns the currently installed selection model.
 463      * @return the currently installed selection model
 464      */
 465     public final MultipleSelectionModel&lt;T&gt; getSelectionModel() {
 466         return selectionModel == null ? null : selectionModel.get();
 467     }
 468 
 469     /**
 470      * The SelectionModel provides the API through which it is possible
 471      * to select single or multiple items within a ListView, as  well as inspect
 472      * which items have been selected by the user. Note that it has a generic
 473      * type that must match the type of the ListView itself.
 474      * @return the selectionModel property
 475      */
 476     public final ObjectProperty&lt;MultipleSelectionModel&lt;T&gt;&gt; selectionModelProperty() {
 477         return selectionModel;
 478     }
 479 
 480 
 481     // --- Focus Model
 482     private ObjectProperty&lt;FocusModel&lt;T&gt;&gt; focusModel;
 483 
 484     /**
 485      * Sets the {@link FocusModel} to be used in the ListView.
 486      * @param value the FocusModel to be used in the ListView
 487      */
 488     public final void setFocusModel(FocusModel&lt;T&gt; value) {
 489         focusModelProperty().set(value);
 490     }
 491 
 492     /**
 493      * Returns the currently installed {@link FocusModel}.
 494      * @return the currently installed FocusModel
 495      */
 496     public final FocusModel&lt;T&gt; getFocusModel() {
 497         return focusModel == null ? null : focusModel.get();
 498     }
 499 
 500     /**
 501      * The FocusModel provides the API through which it is possible
 502      * to both get and set the focus on a single item within a ListView. Note
 503      * that it has a generic type that must match the type of the ListView itself.
 504      * @return the FocusModel property
 505      */
 506     public final ObjectProperty&lt;FocusModel&lt;T&gt;&gt; focusModelProperty() {
 507         if (focusModel == null) {
 508             focusModel = new SimpleObjectProperty&lt;FocusModel&lt;T&gt;&gt;(this, &quot;focusModel&quot;);
 509         }
 510         return focusModel;
 511     }
 512 
 513 
 514     // --- Orientation
 515     private ObjectProperty&lt;Orientation&gt; orientation;
 516 
 517     /**
 518      * Sets the orientation of the ListView, which dictates whether
 519      * it scrolls vertically or horizontally.
 520      * @param value the orientation of the ListView
 521      */
 522     public final void setOrientation(Orientation value) {
 523         orientationProperty().set(value);
 524     };
 525 
 526     /**
 527      * Returns the current orientation of the ListView, which dictates whether
 528      * it scrolls vertically or horizontally.
 529      * @return the current orientation of the ListView
 530      */
 531     public final Orientation getOrientation() {
 532         return orientation == null ? Orientation.VERTICAL : orientation.get();
 533     }
 534 
 535     /**
 536      * The orientation of the {@code ListView} - this can either be horizontal
 537      * or vertical.
 538      * @return the orientation property of this ListView
 539      */
 540     public final ObjectProperty&lt;Orientation&gt; orientationProperty() {
 541         if (orientation == null) {
 542             orientation = new StyleableObjectProperty&lt;Orientation&gt;(Orientation.VERTICAL) {
 543                 @Override public void invalidated() {
 544                     final boolean active = (get() == Orientation.VERTICAL);
 545                     pseudoClassStateChanged(PSEUDO_CLASS_VERTICAL,    active);
 546                     pseudoClassStateChanged(PSEUDO_CLASS_HORIZONTAL, !active);
 547                 }
 548 
 549                 @Override
 550                 public CssMetaData&lt;ListView&lt;?&gt;,Orientation&gt; getCssMetaData() {
 551                     return ListView.StyleableProperties.ORIENTATION;
 552                 }
 553 
 554                 @Override
 555                 public Object getBean() {
 556                     return ListView.this;
 557                 }
 558 
 559                 @Override
 560                 public String getName() {
 561                     return &quot;orientation&quot;;
 562                 }
 563             };
 564         }
 565         return orientation;
 566     }
 567 
 568 
 569 
 570 
 571     // --- Cell Factory
 572     private ObjectProperty&lt;Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt;&gt; cellFactory;
 573 
 574     /**
 575      * Sets a new cell factory to use in the ListView. This forces all old
 576      * {@link ListCell}&#39;s to be thrown away, and new ListCell&#39;s created with
 577      * the new cell factory.
 578      * @param value cell factory to use in this ListView
 579      */
 580     public final void setCellFactory(Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt; value) {
 581         cellFactoryProperty().set(value);
 582     }
 583 
 584     /**
 585      * Returns the current cell factory.
 586      * @return the current cell factory
 587      */
 588     public final Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt; getCellFactory() {
 589         return cellFactory == null ? null : cellFactory.get();
 590     }
 591 
 592     /**
 593      * &lt;p&gt;Setting a custom cell factory has the effect of deferring all cell
 594      * creation, allowing for total customization of the cell. Internally, the
 595      * ListView is responsible for reusing ListCells - all that is necessary
 596      * is for the custom cell factory to return from this function a ListCell
 597      * which might be usable for representing any item in the ListView.
 598      *
 599      * &lt;p&gt;Refer to the {@link Cell} class documentation for more detail.
 600      * @return the cell factory property
 601      */
 602     public final ObjectProperty&lt;Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt;&gt; cellFactoryProperty() {
 603         if (cellFactory == null) {
 604             cellFactory = new SimpleObjectProperty&lt;Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt;&gt;(this, &quot;cellFactory&quot;);
 605         }
 606         return cellFactory;
 607     }
 608 
 609 
 610     // --- Fixed cell size
 611     private DoubleProperty fixedCellSize;
 612 
 613     /**
 614      * Sets the new fixed cell size for this control. Any value greater than
 615      * zero will enable fixed cell size mode, whereas a zero or negative value
 616      * (or Region.USE_COMPUTED_SIZE) will be used to disabled fixed cell size
 617      * mode.
 618      *
 619      * @param value The new fixed cell size value, or a value less than or equal
 620      *              to zero (or Region.USE_COMPUTED_SIZE) to disable.
 621      * @since JavaFX 8.0
 622      */
 623     public final void setFixedCellSize(double value) {
 624         fixedCellSizeProperty().set(value);
 625     }
 626 
 627     /**
 628      * Returns the fixed cell size value. A value less than or equal to zero is
 629      * used to represent that fixed cell size mode is disabled, and a value
 630      * greater than zero represents the size of all cells in this control.
 631      *
 632      * @return A double representing the fixed cell size of this control, or a
 633      *      value less than or equal to zero if fixed cell size mode is disabled.
 634      * @since JavaFX 8.0
 635      */
 636     public final double getFixedCellSize() {
 637         return fixedCellSize == null ? Region.USE_COMPUTED_SIZE : fixedCellSize.get();
 638     }
 639     /**
 640      * Specifies whether this control has cells that are a fixed height (of the
 641      * specified value). If this value is less than or equal to zero,
 642      * then all cells are individually sized and positioned. This is a slow
 643      * operation. Therefore, when performance matters and developers are not
 644      * dependent on variable cell sizes it is a good idea to set the fixed cell
 645      * size value. Generally cells are around 24px, so setting a fixed cell size
 646      * of 24 is likely to result in very little difference in visuals, but a
 647      * improvement to performance.
 648      *
 649      * &lt;p&gt;To set this property via CSS, use the -fx-fixed-cell-size property.
 650      * This should not be confused with the -fx-cell-size property. The difference
 651      * between these two CSS properties is that -fx-cell-size will size all
 652      * cells to the specified size, but it will not enforce that this is the
 653      * only size (thus allowing for variable cell sizes, and preventing the
 654      * performance gains from being possible). Therefore, when performance matters
 655      * use -fx-fixed-cell-size, instead of -fx-cell-size. If both properties are
 656      * specified in CSS, -fx-fixed-cell-size takes precedence.&lt;/p&gt;
 657      *
 658      * @return the fixed cell size property
 659      * @since JavaFX 8.0
 660      */
 661     public final DoubleProperty fixedCellSizeProperty() {
 662         if (fixedCellSize == null) {
 663             fixedCellSize = new StyleableDoubleProperty(Region.USE_COMPUTED_SIZE) {
 664                 @Override public CssMetaData&lt;ListView&lt;?&gt;,Number&gt; getCssMetaData() {
 665                     return StyleableProperties.FIXED_CELL_SIZE;
 666                 }
 667 
 668                 @Override public Object getBean() {
 669                     return ListView.this;
 670                 }
 671 
 672                 @Override public String getName() {
 673                     return &quot;fixedCellSize&quot;;
 674                 }
 675             };
 676         }
 677         return fixedCellSize;
 678     }
 679 
 680 
 681     // --- Editable
 682     private BooleanProperty editable;
 683     public final void setEditable(boolean value) {
 684         editableProperty().set(value);
 685     }
 686     public final boolean isEditable() {
 687         return editable == null ? false : editable.get();
 688     }
 689     /**
 690      * Specifies whether this ListView is editable - only if the ListView and
 691      * the ListCells within it are both editable will a ListCell be able to go
 692      * into their editing state.
 693      * @return the editable property
 694      */
 695     public final BooleanProperty editableProperty() {
 696         if (editable == null) {
 697             editable = new SimpleBooleanProperty(this, &quot;editable&quot;, false);
 698         }
 699         return editable;
 700     }
 701 
 702 
 703     // --- Editing Index
 704     private ReadOnlyIntegerWrapper editingIndex;
 705 
 706     private void setEditingIndex(int value) {
 707         editingIndexPropertyImpl().set(value);
 708     }
 709 
 710     /**
 711      * Returns the index of the item currently being edited in the ListView,
 712      * or -1 if no item is being edited.
 713      * @return the index of the item currently being edited
 714      */
 715     public final int getEditingIndex() {
 716         return editingIndex == null ? -1 : editingIndex.get();
 717     }
 718 
 719     /**
 720      * &lt;p&gt;A property used to represent the index of the item currently being edited
 721      * in the ListView, if editing is taking place, or -1 if no item is being edited.
 722      *
 723      * &lt;p&gt;It is not possible to set the editing index, instead it is required that
 724      * you call {@link #edit(int)}.
 725      * @return the editing index property
 726      */
 727     public final ReadOnlyIntegerProperty editingIndexProperty() {
 728         return editingIndexPropertyImpl().getReadOnlyProperty();
 729     }
 730 
 731     private ReadOnlyIntegerWrapper editingIndexPropertyImpl() {
 732         if (editingIndex == null) {
 733             editingIndex = new ReadOnlyIntegerWrapper(this, &quot;editingIndex&quot;, -1);
 734         }
 735         return editingIndex;
 736     }
 737 
 738 
 739     // --- On Edit Start
 740     private ObjectProperty&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt; onEditStart;
 741 
 742     /**
 743      * Sets the {@link EventHandler} that will be called when the user begins
 744      * an edit.
 745      *
 746      * &lt;p&gt;This is a convenience method - the same result can be
 747      * achieved by calling
 748      * &lt;code&gt;addEventHandler(ListView.EDIT_START_EVENT, eventHandler)&lt;/code&gt;.
 749      * @param value the EventHandler that will be called when the user begins
 750      * an edit
 751      */
 752     public final void setOnEditStart(EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt; value) {
 753         onEditStartProperty().set(value);
 754     }
 755 
 756     /**
 757      * Returns the {@link EventHandler} that will be called when the user begins
 758      * an edit.
 759      * @return the EventHandler that will be called when the user begins an edit
 760      */
 761     public final EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt; getOnEditStart() {
 762         return onEditStart == null ? null : onEditStart.get();
 763     }
 764 
 765     /**
 766      * This event handler will be fired when the user successfully initiates
 767      * editing.
 768      * @return the onEditStart event handler property
 769      */
 770     public final ObjectProperty&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt; onEditStartProperty() {
 771         if (onEditStart == null) {
 772             onEditStart = new ObjectPropertyBase&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt;() {
 773                 @Override protected void invalidated() {
 774                     setEventHandler(ListView.&lt;T&gt;editStartEvent(), get());
 775                 }
 776 
 777                 @Override
 778                 public Object getBean() {
 779                     return ListView.this;
 780                 }
 781 
 782                 @Override
 783                 public String getName() {
 784                     return &quot;onEditStart&quot;;
 785                 }
 786             };
 787         }
 788         return onEditStart;
 789     }
 790 
 791 
 792     // --- On Edit Commit
 793     private ObjectProperty&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt; onEditCommit;
 794 
 795     /**
 796      * Sets the {@link EventHandler} that will be called when the user has
 797      * completed their editing. This is called as part of the
 798      * {@link ListCell#commitEdit(java.lang.Object)} method.
 799      *
 800      * &lt;p&gt;This is a convenience method - the same result can be
 801      * achieved by calling
 802      * &lt;code&gt;addEventHandler(ListView.EDIT_START_EVENT, eventHandler)&lt;/code&gt;.
 803      * @param value the EventHandler that will be called when the user has
 804      * completed their editing
 805      */
 806     public final void setOnEditCommit(EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt; value) {
 807         onEditCommitProperty().set(value);
 808     }
 809 
 810     /**
 811      * Returns the {@link EventHandler} that will be called when the user commits
 812      * an edit.
 813      * @return the EventHandler that will be called when the user commits an edit
 814      */
 815     public final EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt; getOnEditCommit() {
 816         return onEditCommit == null ? null : onEditCommit.get();
 817     }
 818 
 819     /**
 820      * &lt;p&gt;This property is used when the user performs an action that should
 821      * result in their editing input being persisted.&lt;/p&gt;
 822      *
 823      * &lt;p&gt;The EventHandler in this property should not be called directly -
 824      * instead call {@link ListCell#commitEdit(java.lang.Object)} from within
 825      * your custom ListCell. This will handle firing this event, updating the
 826      * view, and switching out of the editing state.&lt;/p&gt;
 827      * @return the onEditCommit event handler property
 828      */
 829     public final ObjectProperty&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt; onEditCommitProperty() {
 830         if (onEditCommit == null) {
 831             onEditCommit = new ObjectPropertyBase&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt;() {
 832                 @Override protected void invalidated() {
 833                     setEventHandler(ListView.&lt;T&gt;editCommitEvent(), get());
 834                 }
 835 
 836                 @Override
 837                 public Object getBean() {
 838                     return ListView.this;
 839                 }
 840 
 841                 @Override
 842                 public String getName() {
 843                     return &quot;onEditCommit&quot;;
 844                 }
 845             };
 846         }
 847         return onEditCommit;
 848     }
 849 
 850 
 851     // --- On Edit Cancel
 852     private ObjectProperty&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt; onEditCancel;
 853 
 854     /**
 855      * Sets the {@link EventHandler} that will be called when the user cancels
 856      * an edit.
 857      * @param value the EventHandler that will be called when the user cancels
 858      * an edit
 859      */
 860     public final void setOnEditCancel(EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt; value) {
 861         onEditCancelProperty().set(value);
 862     }
 863 
 864     /**
 865      * Returns the {@link EventHandler} that will be called when the user cancels
 866      * an edit.
 867      * @return the EventHandler that will be called when the user cancels an edit
 868      */
 869     public final EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt; getOnEditCancel() {
 870         return onEditCancel == null ? null : onEditCancel.get();
 871     }
 872 
 873     /**
 874      * This event handler will be fired when the user cancels editing a cell.
 875      * @return the onEditCancel event handler property
 876      */
 877     public final ObjectProperty&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt; onEditCancelProperty() {
 878         if (onEditCancel == null) {
 879             onEditCancel = new ObjectPropertyBase&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt;() {
 880                 @Override protected void invalidated() {
 881                     setEventHandler(ListView.&lt;T&gt;editCancelEvent(), get());
 882                 }
 883 
 884                 @Override
 885                 public Object getBean() {
 886                     return ListView.this;
 887                 }
 888 
 889                 @Override
 890                 public String getName() {
 891                     return &quot;onEditCancel&quot;;
 892                 }
 893             };
 894         }
 895         return onEditCancel;
 896     }
 897 
 898 
 899 
 900 
 901     /***************************************************************************
 902      *                                                                         *
 903      * Public API                                                              *
 904      *                                                                         *
 905      **************************************************************************/
 906 
 907     /**
 908      * Instructs the ListView to begin editing the item in the given index, if
 909      * the ListView is {@link #editableProperty() editable}. Once
 910      * this method is called, if the current {@link #cellFactoryProperty()} is
 911      * set up to support editing, the Cell will switch its visual state to enable
 912      * for user input to take place.
 913      *
 914      * @param itemIndex The index of the item in the ListView that should be
 915      *     edited.
 916      */
 917     public void edit(int itemIndex) {
 918         if (!isEditable()) return;
 919         setEditingIndex(itemIndex);
 920     }
 921 
 922     /**
 923      * Scrolls the ListView such that the item in the given index is visible to
 924      * the end user.
 925      *
 926      * @param index The index that should be made visible to the user, assuming
 927      *      of course that it is greater than, or equal to 0, and less than the
 928      *      size of the items list contained within the given ListView.
 929      */
 930     public void scrollTo(int index) {
 931         ControlUtils.scrollToIndex(this, index);
 932     }
 933 
 934     /**
 935      * Scrolls the ListView so that the given object is visible within the viewport.
 936      * @param object The object that should be visible to the user.
 937      * @since JavaFX 8.0
 938      */
 939     public void scrollTo(T object) {
 940         if( getItems() != null ) {
 941             int idx = getItems().indexOf(object);
 942             if( idx &gt;= 0 ) {
 943                 ControlUtils.scrollToIndex(this, idx);
 944             }
 945         }
 946     }
 947 
 948     /**
 949      * Called when there&#39;s a request to scroll an index into view using {@link #scrollTo(int)}
 950      * or {@link #scrollTo(Object)}
 951      * @since JavaFX 8.0
 952      */
 953     private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollTo;
 954 
 955     public void setOnScrollTo(EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; value) {
 956         onScrollToProperty().set(value);
 957     }
 958 
 959     public EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; getOnScrollTo() {
 960         if( onScrollTo != null ) {
 961             return onScrollTo.get();
 962         }
 963         return null;
 964     }
 965 
 966     public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollToProperty() {
 967         if( onScrollTo == null ) {
 968             onScrollTo = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt;() {
 969                 @Override protected void invalidated() {
 970                     setEventHandler(ScrollToEvent.scrollToTopIndex(), get());
 971                 }
 972 
 973                 @Override public Object getBean() {
 974                     return ListView.this;
 975                 }
 976 
 977                 @Override public String getName() {
 978                     return &quot;onScrollTo&quot;;
 979                 }
 980             };
 981         }
 982         return onScrollTo;
 983     }
 984 
 985     /** {@inheritDoc} */
 986     @Override protected Skin&lt;?&gt; createDefaultSkin() {
 987         return new ListViewSkin&lt;T&gt;(this);
 988     }
 989 
 990     /**
 991      * Calling {@code refresh()} forces the ListView control to recreate and
 992      * repopulate the cells necessary to populate the visual bounds of the control.
 993      * In other words, this forces the ListView to update what it is showing to
 994      * the user. This is useful in cases where the underlying data source has
 995      * changed in a way that is not observed by the ListView itself.
 996      *
 997      * @since JavaFX 8u60
 998      */
 999     public void refresh() {
1000         getProperties().put(Properties.RECREATE, Boolean.TRUE);
1001     }
1002 
1003 
1004 
1005     /***************************************************************************
1006      *                                                                         *
1007      * Private Implementation                                                  *
1008      *                                                                         *
1009      **************************************************************************/
1010 
1011 
1012 
1013     /***************************************************************************
1014      *                                                                         *
1015      * Stylesheet Handling                                                     *
1016      *                                                                         *
1017      **************************************************************************/
1018 
1019     private static final String DEFAULT_STYLE_CLASS = &quot;list-view&quot;;
1020 
1021     private static class StyleableProperties {
1022         private static final CssMetaData&lt;ListView&lt;?&gt;,Orientation&gt; ORIENTATION =
1023             new CssMetaData&lt;ListView&lt;?&gt;,Orientation&gt;(&quot;-fx-orientation&quot;,
1024                 new EnumConverter&lt;Orientation&gt;(Orientation.class),
1025                 Orientation.VERTICAL) {
1026 
1027             @Override
1028             public Orientation getInitialValue(ListView&lt;?&gt; node) {
1029                 // A vertical ListView should remain vertical
1030                 return node.getOrientation();
1031             }
1032 
1033             @Override
1034             public boolean isSettable(ListView&lt;?&gt; n) {
1035                 return n.orientation == null || !n.orientation.isBound();
1036             }
1037 
1038             @SuppressWarnings(&quot;unchecked&quot;) // orientationProperty() is a StyleableProperty&lt;Orientation&gt;
1039             @Override
1040             public StyleableProperty&lt;Orientation&gt; getStyleableProperty(ListView&lt;?&gt; n) {
1041                 return (StyleableProperty&lt;Orientation&gt;)n.orientationProperty();
1042             }
1043         };
1044 
1045         private static final CssMetaData&lt;ListView&lt;?&gt;,Number&gt; FIXED_CELL_SIZE =
1046             new CssMetaData&lt;ListView&lt;?&gt;,Number&gt;(&quot;-fx-fixed-cell-size&quot;,
1047                                                 SizeConverter.getInstance(),
1048                                                 Region.USE_COMPUTED_SIZE) {
1049 
1050                 @Override public Double getInitialValue(ListView&lt;?&gt; node) {
1051                     return node.getFixedCellSize();
1052                 }
1053 
1054                 @Override public boolean isSettable(ListView&lt;?&gt; n) {
1055                     return n.fixedCellSize == null || !n.fixedCellSize.isBound();
1056                 }
1057 
1058                 @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(ListView&lt;?&gt; n) {
1059                     return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.fixedCellSizeProperty();
1060                 }
1061             };
1062 
1063         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
1064         static {
1065             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1066                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
1067             styleables.add(ORIENTATION);
1068             styleables.add(FIXED_CELL_SIZE);
1069             STYLEABLES = Collections.unmodifiableList(styleables);
1070         }
1071     }
1072 
1073     /**
1074      * @return The CssMetaData associated with this class, which may include the
1075      * CssMetaData of its superclasses.
1076      * @since JavaFX 8.0
1077      */
1078     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1079         return StyleableProperties.STYLEABLES;
1080     }
1081 
1082     /**
1083      * {@inheritDoc}
1084      * @since JavaFX 8.0
1085      */
1086     @Override
1087     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
1088         return getClassCssMetaData();
1089     }
1090 
1091     private static final PseudoClass PSEUDO_CLASS_VERTICAL =
1092             PseudoClass.getPseudoClass(&quot;vertical&quot;);
1093     private static final PseudoClass PSEUDO_CLASS_HORIZONTAL =
1094             PseudoClass.getPseudoClass(&quot;horizontal&quot;);
1095 
1096 
1097 
1098     /***************************************************************************
1099      *                                                                         *
1100      * Accessibility handling                                                  *
1101      *                                                                         *
1102      **************************************************************************/
1103 
1104     /** {@inheritDoc} */
1105     @Override
1106     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1107         switch (attribute) {
1108             case MULTIPLE_SELECTION: {
1109                 MultipleSelectionModel&lt;T&gt; sm = getSelectionModel();
1110                 return sm != null &amp;&amp; sm.getSelectionMode() == SelectionMode.MULTIPLE;
1111             }
1112             default: return super.queryAccessibleAttribute(attribute, parameters);
1113         }
1114     }
1115 
1116 
1117     /***************************************************************************
1118      *                                                                         *
1119      * Support Interfaces                                                      *
1120      *                                                                         *
1121      **************************************************************************/
1122 
1123 
1124 
1125     /***************************************************************************
1126      *                                                                         *
1127      * Support Classes                                                         *
1128      *                                                                         *
1129      **************************************************************************/
1130 
1131     /**
1132      * An {@link Event} subclass used specifically in ListView for representing
1133      * edit-related events. It provides additional API to easily access the
1134      * index that the edit event took place on, as well as the input provided
1135      * by the end user.
1136      *
1137      * @param &lt;T&gt; The type of the input, which is the same type as the ListView
1138      *      itself.
1139      * @since JavaFX 2.0
1140      */
1141     public static class EditEvent&lt;T&gt; extends Event {
1142         private final T newValue;
1143         private final int editIndex;
1144         private final ListView&lt;T&gt; source;
1145 
1146         private static final long serialVersionUID = 20130724L;
1147 
1148         /**
1149          * Common supertype for all edit event types.
1150          * @since JavaFX 8.0
1151          */
1152         public static final EventType&lt;?&gt; ANY = EDIT_ANY_EVENT;
1153 
1154         /**
1155          * Creates a new EditEvent instance to represent an edit event. This
1156          * event is used for {@link #editStartEvent()},
1157          * {@link #editCommitEvent()} and {@link #editCancelEvent()} types.
1158          * @param source the source
1159          * @param eventType the event type
1160          * @param newValue the new value
1161          * @param editIndex the edit index
1162          */
1163         public EditEvent(ListView&lt;T&gt; source,
1164                          EventType&lt;? extends ListView.EditEvent&lt;T&gt;&gt; eventType,
1165                          T newValue,
1166                          int editIndex) {
1167             super(source, Event.NULL_SOURCE_TARGET, eventType);
1168             this.source = source;
1169             this.editIndex = editIndex;
1170             this.newValue = newValue;
1171         }
1172 
1173         /**
1174          * Returns the ListView upon which the edit took place.
1175          */
1176         @Override public ListView&lt;T&gt; getSource() {
1177             return source;
1178         }
1179 
1180         /**
1181          * Returns the index in which the edit took place.
1182          * @return the index in which the edit took place
1183          */
1184         public int getIndex() {
1185             return editIndex;
1186         }
1187 
1188         /**
1189          * Returns the value of the new input provided by the end user.
1190          * @return the value of the new input provided by the end user
1191          */
1192         public T getNewValue() {
1193             return newValue;
1194         }
1195 
1196         /**
1197          * Returns a string representation of this {@code EditEvent} object.
1198          * @return a string representation of this {@code EditEvent} object.
1199          */
1200         @Override public String toString() {
1201             return &quot;ListViewEditEvent [ newValue: &quot; + getNewValue() + &quot;, ListView: &quot; + getSource() + &quot; ]&quot;;
1202         }
1203     }
1204 
1205 
1206 
1207     // package for testing
1208     static class ListViewBitSetSelectionModel&lt;T&gt; extends MultipleSelectionModelBase&lt;T&gt; {
1209 
1210         /***********************************************************************
1211          *                                                                     *
1212          * Constructors                                                        *
1213          *                                                                     *
1214          **********************************************************************/
1215 
1216         public ListViewBitSetSelectionModel(final ListView&lt;T&gt; listView) {
1217             if (listView == null) {
1218                 throw new IllegalArgumentException(&quot;ListView can not be null&quot;);
1219             }
1220 
1221             this.listView = listView;
1222 
1223             /*
1224              * The following two listeners are used in conjunction with
1225              * SelectionModel.select(T obj) to allow for a developer to select
1226              * an item that is not actually in the data model. When this occurs,
1227              * we actively try to find an index that matches this object, going
1228              * so far as to actually watch for all changes to the items list,
1229              * rechecking each time.
1230              */
1231             itemsObserver = new InvalidationListener() {
1232                 private WeakReference&lt;ObservableList&lt;T&gt;&gt; weakItemsRef = new WeakReference&lt;&gt;(listView.getItems());
1233 
1234                 @Override public void invalidated(Observable observable) {
1235                     ObservableList&lt;T&gt; oldItems = weakItemsRef.get();
1236                     weakItemsRef = new WeakReference&lt;&gt;(listView.getItems());
1237                     updateItemsObserver(oldItems, listView.getItems());
1238                 }
1239             };
1240 
1241             this.listView.itemsProperty().addListener(new WeakInvalidationListener(itemsObserver));
1242             if (listView.getItems() != null) {
1243                 this.listView.getItems().addListener(weakItemsContentObserver);
1244             }
1245 
1246             updateItemCount();
1247 
1248             updateDefaultSelection();
1249         }
1250 
1251         // watching for changes to the items list content
1252         private final ListChangeListener&lt;T&gt; itemsContentObserver = new ListChangeListener&lt;T&gt;() {
1253             @Override public void onChanged(Change&lt;? extends T&gt; c) {
1254                 updateItemCount();
1255 
1256                 boolean doSelectionUpdate = true;
1257 
1258                 while (c.next()) {
1259                     final T selectedItem = getSelectedItem();
1260                     final int selectedIndex = getSelectedIndex();
1261 
1262                     if (listView.getItems() == null || listView.getItems().isEmpty()) {
1263                         selectedItemChange = c;
1264                         clearSelection();
1265                         selectedItemChange = null;
1266                     } else if (selectedIndex == -1 &amp;&amp; selectedItem != null) {
1267                         int newIndex = listView.getItems().indexOf(selectedItem);
1268                         if (newIndex != -1) {
1269                             setSelectedIndex(newIndex);
1270                             doSelectionUpdate = false;
1271                         }
1272                     } else if (c.wasRemoved() &amp;&amp;
1273                             c.getRemovedSize() == 1 &amp;&amp;
1274                             ! c.wasAdded() &amp;&amp;
1275                             selectedItem != null &amp;&amp;
1276                             selectedItem.equals(c.getRemoved().get(0))) {
1277                         // Bug fix for RT-28637
1278                         if (getSelectedIndex() &lt; getItemCount()) {
1279                             final int previousRow = selectedIndex == 0 ? 0 : selectedIndex - 1;
1280                             T newSelectedItem = getModelItem(previousRow);
1281                             if (! selectedItem.equals(newSelectedItem)) {
1282                                 startAtomic();
1283                                 clearSelection(selectedIndex);
1284                                 stopAtomic();
1285                                 select(newSelectedItem);
1286                             }
1287                         }
1288                     }
1289                 }
1290 
1291                 if (doSelectionUpdate) {
1292                     updateSelection(c);
1293                 }
1294             }
1295         };
1296 
1297         // watching for changes to the items list
1298         private final InvalidationListener itemsObserver;
1299 
1300         private WeakListChangeListener&lt;T&gt; weakItemsContentObserver =
1301                 new WeakListChangeListener&lt;&gt;(itemsContentObserver);
1302 
1303 
1304 
1305 
1306         /***********************************************************************
1307          *                                                                     *
1308          * Internal properties                                                 *
1309          *                                                                     *
1310          **********************************************************************/
1311 
1312         private final ListView&lt;T&gt; listView;
1313 
1314         private int itemCount = 0;
1315 
1316         private int previousModelSize = 0;
1317 
1318         // Listen to changes in the listview items list, such that when it
1319         // changes we can update the selected indices bitset to refer to the
1320         // new indices.
1321         // At present this is basically a left/right shift operation, which
1322         // seems to work ok.
1323         private void updateSelection(Change&lt;? extends T&gt; c) {
1324 //            // debugging output
1325 //            System.out.println(listView.getId());
1326 //            if (c.wasAdded()) {
1327 //                System.out.println(&quot;\tAdded size: &quot; + c.getAddedSize() + &quot;, Added sublist: &quot; + c.getAddedSubList());
1328 //            }
1329 //            if (c.wasRemoved()) {
1330 //                System.out.println(&quot;\tRemoved size: &quot; + c.getRemovedSize() + &quot;, Removed sublist: &quot; + c.getRemoved());
1331 //            }
1332 //            if (c.wasReplaced()) {
1333 //                System.out.println(&quot;\tWas replaced&quot;);
1334 //            }
1335 //            if (c.wasPermutated()) {
1336 //                System.out.println(&quot;\tWas permutated&quot;);
1337 //            }
1338             c.reset();
1339 
1340             List&lt;Pair&lt;Integer, Integer&gt;&gt; shifts = new ArrayList&lt;&gt;();
1341             while (c.next()) {
1342                 if (c.wasReplaced()) {
1343                     if (c.getList().isEmpty()) {
1344                         // the entire items list was emptied - clear selection
1345                         clearSelection();
1346                     } else {
1347                         int index = getSelectedIndex();
1348 
1349                         if (previousModelSize == c.getRemovedSize()) {
1350                             // all items were removed from the model
1351                             clearSelection();
1352                         } else if (index &lt; getItemCount() &amp;&amp; index &gt;= 0) {
1353                             // Fix for RT-18969: the list had setAll called on it
1354                             // Use of makeAtomic is a fix for RT-20945
1355                             startAtomic();
1356                             clearSelection(index);
1357                             stopAtomic();
1358                             select(index);
1359                         } else {
1360                             // Fix for RT-22079
1361                             clearSelection();
1362                         }
1363                     }
1364                 } else if (c.wasAdded() || c.wasRemoved()) {
1365                     int shift = c.wasAdded() ? c.getAddedSize() : -c.getRemovedSize();
1366                     shifts.add(new Pair&lt;&gt;(c.getFrom(), shift));
1367                 } else if (c.wasPermutated()) {
1368 
1369                     // General approach:
1370                     //   -- detected a sort has happened
1371                     //   -- Create a permutation lookup map (1)
1372                     //   -- dump all the selected indices into a list (2)
1373                     //   -- clear the selected items / indexes (3)
1374                     //   -- create a list containing the new indices (4)
1375                     //   -- for each previously-selected index (5)
1376                     //     -- if index is in the permutation lookup map
1377                     //       -- add the new index to the new indices list
1378                     //   -- Perform batch selection (6)
1379 
1380                     // (1)
1381                     int length = c.getTo() - c.getFrom();
1382                     HashMap&lt;Integer, Integer&gt; pMap = new HashMap&lt;Integer, Integer&gt;(length);
1383                     for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
1384                         pMap.put(i, c.getPermutation(i));
1385                     }
1386 
1387                     // (2)
1388                     List&lt;Integer&gt; selectedIndices = new ArrayList&lt;Integer&gt;(getSelectedIndices());
1389 
1390 
1391                     // (3)
1392                     clearSelection();
1393 
1394                     // (4)
1395                     List&lt;Integer&gt; newIndices = new ArrayList&lt;Integer&gt;(getSelectedIndices().size());
1396 
1397                     // (5)
1398                     for (int i = 0; i &lt; selectedIndices.size(); i++) {
1399                         int oldIndex = selectedIndices.get(i);
1400 
1401                         if (pMap.containsKey(oldIndex)) {
1402                             Integer newIndex = pMap.get(oldIndex);
1403                             newIndices.add(newIndex);
1404                         }
1405                     }
1406 
1407                     // (6)
1408                     if (!newIndices.isEmpty()) {
1409                         if (newIndices.size() == 1) {
1410                             select(newIndices.get(0));
1411                         } else {
1412                             int[] ints = new int[newIndices.size() - 1];
1413                             for (int i = 0; i &lt; newIndices.size() - 1; i++) {
1414                                 ints[i] = newIndices.get(i + 1);
1415                             }
1416                             selectIndices(newIndices.get(0), ints);
1417                         }
1418                     }
1419                 }
1420             }
1421 
1422             if (!shifts.isEmpty()) {
1423                 shiftSelection(shifts, null);
1424             }
1425 
1426             previousModelSize = getItemCount();
1427         }
1428 
1429 
1430 
1431         /***********************************************************************
1432          *                                                                     *
1433          * Public selection API                                                *
1434          *                                                                     *
1435          **********************************************************************/
1436 
1437         /** {@inheritDoc} */
1438         @Override public void selectAll() {
1439             // when a selectAll happens, the anchor should not change, so we store it
1440             // before, and restore it afterwards
1441             final int anchor = ListCellBehavior.getAnchor(listView, -1);
1442             super.selectAll();
1443             ListCellBehavior.setAnchor(listView, anchor, false);
1444         }
1445 
1446         /** {@inheritDoc} */
1447         @Override public void clearAndSelect(int row) {
1448             ListCellBehavior.setAnchor(listView, row, false);
1449             super.clearAndSelect(row);
1450         }
1451 
1452         /** {@inheritDoc} */
1453         @Override protected void focus(int row) {
1454             if (listView.getFocusModel() == null) return;
1455             listView.getFocusModel().focus(row);
1456 
1457             listView.notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
1458         }
1459 
1460         /** {@inheritDoc} */
1461         @Override protected int getFocusedIndex() {
1462             if (listView.getFocusModel() == null) return -1;
1463             return listView.getFocusModel().getFocusedIndex();
1464         }
1465 
1466         @Override protected int getItemCount() {
1467             return itemCount;
1468         }
1469 
1470         @Override protected T getModelItem(int index) {
1471             List&lt;T&gt; items = listView.getItems();
1472             if (items == null) return null;
1473             if (index &lt; 0 || index &gt;= itemCount) return null;
1474 
1475             return items.get(index);
1476         }
1477 
1478 
1479 
1480         /***********************************************************************
1481          *                                                                     *
1482          * Private implementation                                              *
1483          *                                                                     *
1484          **********************************************************************/
1485 
1486         private void updateItemCount() {
1487             if (listView == null) {
1488                 itemCount = -1;
1489             } else {
1490                 List&lt;T&gt; items = listView.getItems();
1491                 itemCount = items == null ? -1 : items.size();
1492             }
1493         }
1494 
1495         private void updateItemsObserver(ObservableList&lt;T&gt; oldList, ObservableList&lt;T&gt; newList) {
1496             // update listeners
1497             if (oldList != null) {
1498                 oldList.removeListener(weakItemsContentObserver);
1499             }
1500             if (newList != null) {
1501                 newList.addListener(weakItemsContentObserver);
1502             }
1503 
1504             updateItemCount();
1505             updateDefaultSelection();
1506         }
1507 
1508         private void updateDefaultSelection() {
1509             // when the items list totally changes, we should clear out
1510             // the selection and focus
1511             int newSelectionIndex = -1;
1512             int newFocusIndex = -1;
1513             if (listView.getItems() != null) {
1514                 T selectedItem = getSelectedItem();
1515                 if (selectedItem != null) {
1516                     newSelectionIndex = listView.getItems().indexOf(selectedItem);
1517                     newFocusIndex = newSelectionIndex;
1518                 }
1519 
1520                 // we put focus onto the first item, if there is at least
1521                 // one item in the list
1522                 if (listView.selectFirstRowByDefault &amp;&amp; newFocusIndex == -1) {
1523                     newFocusIndex = listView.getItems().size() &gt; 0 ? 0 : -1;
1524                 }
1525             }
1526 
1527             clearSelection();
1528             select(newSelectionIndex);
1529 //            focus(newFocusIndex);
1530         }
1531     }
1532 
1533 
1534 
1535     // package for testing
1536     static class ListViewFocusModel&lt;T&gt; extends FocusModel&lt;T&gt; {
1537 
1538         private final ListView&lt;T&gt; listView;
1539         private int itemCount = 0;
1540 
1541         public ListViewFocusModel(final ListView&lt;T&gt; listView) {
1542             if (listView == null) {
1543                 throw new IllegalArgumentException(&quot;ListView can not be null&quot;);
1544             }
1545 
1546             this.listView = listView;
1547 
1548             itemsObserver = new InvalidationListener() {
1549                 private WeakReference&lt;ObservableList&lt;T&gt;&gt; weakItemsRef = new WeakReference&lt;&gt;(listView.getItems());
1550 
1551                 @Override public void invalidated(Observable observable) {
1552                     ObservableList&lt;T&gt; oldItems = weakItemsRef.get();
1553                     weakItemsRef = new WeakReference&lt;&gt;(listView.getItems());
1554                     updateItemsObserver(oldItems, listView.getItems());
1555                 }
1556             };
1557             this.listView.itemsProperty().addListener(new WeakInvalidationListener(itemsObserver));
1558             if (listView.getItems() != null) {
1559                 this.listView.getItems().addListener(weakItemsContentListener);
1560             }
1561 
1562             updateItemCount();
1563             updateDefaultFocus();
1564 
1565             focusedIndexProperty().addListener(o -&gt; {
1566                 listView.notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
1567             });
1568         }
1569 
1570 
1571         private void updateItemsObserver(ObservableList&lt;T&gt; oldList, ObservableList&lt;T&gt; newList) {
1572             // the listview items list has changed, we need to observe
1573             // the new list, and remove any observer we had from the old list
1574             if (oldList != null) oldList.removeListener(weakItemsContentListener);
1575             if (newList != null) newList.addListener(weakItemsContentListener);
1576 
1577             updateItemCount();
1578             updateDefaultFocus();
1579         }
1580 
1581         private final InvalidationListener itemsObserver;
1582 
1583         // Listen to changes in the listview items list, such that when it
1584         // changes we can update the focused index to refer to the new indices.
1585         private final ListChangeListener&lt;T&gt; itemsContentListener = c -&gt; {
1586             updateItemCount();
1587 
1588             while (c.next()) {
1589                 // looking at the first change
1590                 int from = c.getFrom();
1591 
1592                 if (c.wasReplaced() || c.getAddedSize() == getItemCount()) {
1593                     updateDefaultFocus();
1594                     return;
1595                 }
1596 
1597                 if (getFocusedIndex() == -1 || from &gt; getFocusedIndex()) {
1598                     return;
1599                 }
1600 
1601                 c.reset();
1602                 boolean added = false;
1603                 boolean removed = false;
1604                 int addedSize = 0;
1605                 int removedSize = 0;
1606                 while (c.next()) {
1607                     added |= c.wasAdded();
1608                     removed |= c.wasRemoved();
1609                     addedSize += c.getAddedSize();
1610                     removedSize += c.getRemovedSize();
1611                 }
1612 
1613                 if (added &amp;&amp; !removed) {
1614                     focus(Math.min(getItemCount() - 1, getFocusedIndex() + addedSize));
1615                 } else if (!added &amp;&amp; removed) {
1616                     focus(Math.max(0, getFocusedIndex() - removedSize));
1617                 }
1618             }
1619         };
1620 
1621         private WeakListChangeListener&lt;T&gt; weakItemsContentListener
1622                 = new WeakListChangeListener&lt;T&gt;(itemsContentListener);
1623 
1624         @Override protected int getItemCount() {
1625             return itemCount;
1626         }
1627 
1628         @Override protected T getModelItem(int index) {
1629             if (isEmpty()) return null;
1630             if (index &lt; 0 || index &gt;= itemCount) return null;
1631 
1632             return listView.getItems().get(index);
1633         }
1634 
1635         private boolean isEmpty() {
1636             return itemCount == -1;
1637         }
1638 
1639         private void updateItemCount() {
1640             if (listView == null) {
1641                 itemCount = -1;
1642             } else {
1643                 List&lt;T&gt; items = listView.getItems();
1644                 itemCount = items == null ? -1 : items.size();
1645             }
1646         }
1647 
1648         private void updateDefaultFocus() {
1649             // when the items list totally changes, we should clear out
1650             // the focus
1651             int newValueIndex = -1;
1652             if (listView.getItems() != null) {
1653                 T focusedItem = getFocusedItem();
1654                 if (focusedItem != null) {
1655                     newValueIndex = listView.getItems().indexOf(focusedItem);
1656                 }
1657 
1658                 // we put focus onto the first item, if there is at least
1659                 // one item in the list
1660                 if (newValueIndex == -1) {
1661                     newValueIndex = listView.getItems().size() &gt; 0 ? 0 : -1;
1662                 }
1663             }
1664 
1665             focus(newValueIndex);
1666         }
1667     }
1668 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
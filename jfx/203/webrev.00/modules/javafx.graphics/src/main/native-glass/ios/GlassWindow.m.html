<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.graphics/src/main/native-glass/ios/GlassWindow.m</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #import &lt;UIKit/UIKit.h&gt;
  27 #import &lt;Foundation/NSNotification.h&gt;
  28 
  29 #include &quot;GlassWindow.h&quot;
  30 
  31 #include &quot;com_sun_glass_events_WindowEvent.h&quot;
  32 #include &quot;com_sun_glass_ui_Window_Level.h&quot;
  33 #include &quot;com_sun_glass_ui_Window.h&quot;
  34 #include &quot;GlassViewGL.h&quot;
  35 #include &quot;GlassApplication.h&quot;
  36 #include &quot;GlassViewController.h&quot;
  37 
  38 static UIView * s_grabWindow = nil;
  39 static GlassWindow   * focusOwner; // currently focused GlassWindow - i.e. key events receiver
  40 
  41 
  42 @implementation GlassMainWindow
  43 
  44 -(id)initWithFrame:(CGRect)frame {
  45     self = [super initWithFrame:frame];
  46 
  47     [[NSNotificationCenter defaultCenter] addObserver:self
  48                                              selector:@selector(keyboardDidShow:)
  49                                                  name:UIKeyboardDidShowNotification
  50                                                object:nil];
  51 
  52     [[NSNotificationCenter defaultCenter] addObserver:self
  53                                              selector:@selector(keyboardDidHide:)
  54                                                  name:UIKeyboardDidHideNotification
  55                                                object:nil];
  56     return self;
  57 }
  58 
  59 // multitouch debugging
  60 - (void) sendEvent:(UIEvent *)event
  61 {
  62     GLASS_LOG(&quot;GlassMainWindow received UIEvent: %@&quot;, event);
  63     [super sendEvent:event];
  64 }
  65 
  66 - (void) keyboardDidShow:(NSNotification *) notification
  67 {
  68 #if MAT_IOS_DEBUG
  69     GLASS_LOG(&quot;[GlassMainWindow keyboardDidShow]&quot;);
  70     NSDictionary *info = [notification userInfo];
  71     CGRect keyboardFrame = [[info objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue];
  72     GLASS_LOG(&quot;Keyboard frame x = %f, y = %f, width = %f, height = %f&quot;, keyboardFrame.origin.x, keyboardFrame.origin.y, keyboardFrame.size.width, keyboardFrame.size.height);
  73 #endif
  74 }
  75 
  76 - (void) keyboardDidHide:(NSNotification *) notification
  77 {
  78     GLASS_LOG(&quot;[GlassMainWindow keyboardidHide]&quot;);
  79     [self resignFocusOwner];
  80 }
  81 
  82 - (void) resignFocusOwner {
  83     [focusOwner resignKeyWindow];
  84 }
  85 
  86 @end
  87 
  88 @implementation GlassMainView
  89 
  90 - (id) initWithFrame:(CGRect)frame
  91 {
  92     self = [super initWithFrame:frame];
  93     if (self != nil) {
  94         [GlassDragDelegate setDragViewParent:self];
  95     }
  96     return self;
  97 }
  98 
  99 - (void) dealloc {
 100     [GlassDragDelegate setDragViewParent:nil];
 101     [GlassDragDelegate cleanup];
 102     [super dealloc];
 103 }
 104 
 105 @end
 106 
 107 //Toplevel containers of all GlassWindows
 108 //once we support multiple screens on iOS - there will be one masterWindow/
 109 //masterWindowHost per screen
 110 static GlassMainWindow * masterWindow = nil;
 111 static GlassMainView * masterWindowHost = nil;
 112 
 113 @interface GlassWindow (JavaAdditions)
 114 - (void)displaySubviews;
 115 - (void)_setLevel;
 116 - (void)orderBack;
 117 - (void)_orderBack;
 118 - (void)orderFrontRegardless;
 119 - (void)_orderFrontRegardless;
 120 
 121 - (void)addChildWindow:(GlassWindow*)child;
 122 - (void)removeChildWindow:(GlassWindow*)child;
 123 
 124 - (void)_setAlpha;
 125 - (void)_setBoundsAndPosition;
 126 - (CGSize)_constrainBounds:(CGRect)cFrame;
 127 - (void)_setMinimumSize;
 128 - (void)_setMaximumSize;
 129 - (void)_setVisible;
 130 
 131 + (void)_resetGrab;
 132 - (void)_grabFocus;
 133 - (void)_ungrabFocus;
 134 - (void)_checkUngrab;
 135 
 136 - (void)_sendJavaWindowMoveEventForFrame:(CGRect)frame;
 137 - (void)_sendJavaWindowResizeEvent:(int)type forFrame:(CGRect)frame;
 138 
 139 - (void)becomeKeyWindow;
 140 - (void)resignKeyWindow;
 141 - (void)windowWillClose;
 142 - (void)sendEvent:(UIEvent *)event;
 143 @end
 144 
 145 
 146 @interface GlassWindow (Java)
 147 - (id)initWithScreen:(UIScreen *)screen jwindow:(jobject)jwindow;
 148 @end
 149 
 150 
 151 
 152 static inline GlassWindow *getGlassWindow(JNIEnv *env, jlong jPtr)
 153 {
 154     if (jPtr != 0L)
 155     {
 156         return (GlassWindow*)jlong_to_ptr(jPtr);
 157     }
 158     else
 159     {
 160         return nil;
 161     }
 162 }
 163 
 164 
 165 static inline UIView&lt;GlassView&gt;* getiOSView(JNIEnv *env, jobject jview)
 166 {
 167     if (jview != NULL)
 168     {
 169         return (UIView&lt;GlassView&gt;*)jlong_to_ptr((*env)-&gt;GetLongField(env, jview, (*env)-&gt;GetFieldID(env, mat_jViewClass, &quot;nativePtr&quot;, &quot;J&quot;)));
 170     }
 171     else
 172     {
 173         return nil;
 174     }
 175 }
 176 
 177 
 178 static inline void setWindowFrame(GlassWindow *window, CGFloat x, CGFloat y, CGFloat w, CGFloat h, jboolean display, jboolean animate)
 179 {
 180     // set help variables
 181     window-&gt;_setFrameX = x;
 182     window-&gt;_setFrameY = y;
 183     window-&gt;_setFrameWidth = w;
 184     window-&gt;_setFrameHeight = h;
 185     window-&gt;_setFrameDisplay = display;
 186     window-&gt;_setFrameAnimated = animate;
 187 
 188     if ([[NSThread currentThread] isMainThread] == YES)
 189     {
 190         [window _setBoundsAndPosition]; // update origin and bounds
 191         if (display == JNI_TRUE) {
 192             GLASS_LOG(&quot;calling displaySubviews&quot;);
 193             [window displaySubviews];
 194             GLASS_LOG(&quot;called displaySubviews&quot;);
 195         }
 196         GLASS_LOG(&quot;GlassWindow frame after setWindowFrame: %f,%f,%f,%f&quot;,[window center].x - [window bounds].size.width / 2,[window center].y - [window bounds].size.height / 2, [window bounds].size.width,[window bounds].size.height);
 197     }
 198     else
 199     {
 200         [window performSelectorOnMainThread:@selector(_setBoundsAndPosition) withObject:nil waitUntilDone:YES];
 201         if (display == JNI_TRUE)
 202             [window performSelectorOnMainThread:@selector(displaySubviews) withObject:nil waitUntilDone:YES];
 203     }
 204 }
 205 
 206 
 207 @implementation GlassWindow
 208 
 209 +(GlassMainWindow *)  getMasterWindow {
 210     return masterWindow;
 211 }
 212 
 213 +(GlassMainView *) getMasterWindowHost {
 214     return masterWindowHost;
 215 }
 216 
 217 - (BOOL) canBecomeFirstResponder {return YES;}
 218 
 219 - (BOOL)hasText {
 220         return YES;
 221 }
 222 
 223 - (void)insertText:(NSString *)theText {
 224     const char * inputString = [theText UTF8String];
 225     for(GlassViewGL * subView in [self-&gt;hostView subviews]) {
 226         if(subView != nil &amp;&amp; [subView isKindOfClass:[GlassViewGL class]] == YES) {
 227             [subView doInsertText:theText];
 228         }
 229     }
 230 }
 231 
 232 - (void)deleteBackward {
 233     for(GlassViewGL * subView in [self-&gt;hostView subviews]) {
 234         if(subView != nil &amp;&amp; [subView isKindOfClass:[GlassViewGL class]] == YES) {
 235             [subView doDeleteBackward];
 236         }
 237     }
 238 }
 239 
 240 JNIEXPORT void JNICALL Java_javafx_scene_control_skin_TextFieldSkinIos_showSoftwareKeyboard
 241 (JNIEnv *env, jobject jTextFieldSkin)
 242 {
 243     [focusOwner becomeFirstResponder];
 244 }
 245 
 246 JNIEXPORT void JNICALL Java_javafx_scene_control_skin_TextFieldSkinIos_hideSoftwareKeyboard
 247 (JNIEnv *env, jobject jTextFieldSkin)
 248 {
 249     [focusOwner resignFirstResponder];
 250 }
 251 
 252 JNIEXPORT void JNICALL Java_javafx_scene_control_skin_TextAreaSkinIos_showSoftwareKeyboard
 253 (JNIEnv *env, jobject jTextAreaSkin)
 254 {
 255     [focusOwner becomeFirstResponder];
 256 }
 257 
 258 JNIEXPORT void JNICALL Java_javafx_scene_control_skin_TextAreaSkinIos_hideSoftwareKeyboard
 259 (JNIEnv *env, jobject jTextAreaSkin)
 260 {
 261     [focusOwner resignFirstResponder];
 262 }
 263 
 264 
 265 // request subviews to repaint
 266 - (void) displaySubviews
 267 {
 268     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 269     for (UIView * subView in [self-&gt;hostView subviews]) {
 270         if (subView != nil) {
 271             [subView setNeedsDisplay];
 272         }
 273     }
 274 }
 275 
 276 #pragma mark ---
 277 
 278 // close window (hide and destroy it)
 279 - (void) close {
 280     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 281     [self _ungrabFocus];
 282     [self setHidden:YES];
 283 
 284     [self windowWillClose];
 285 
 286     [masterWindowHost release];
 287     [masterWindow release];//decrease retaincount
 288 }
 289 
 290 
 291 - (void)setEnabled:(BOOL)enabled
 292 {
 293     GLASS_LOG(&quot;GlassWindow setEnabled&quot;);
 294     self-&gt;isEnabled = enabled;
 295 }
 296 
 297 
 298 #pragma mark --- Java
 299 
 300 - (id)initWithScreen:(UIScreen *)screen jwindow:(jobject)jwindow
 301 {
 302     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 303     CGRect bounds = CGRectMake(0.0f,0.0f,0.0f,0.0f);
 304     self = (GlassWindow *)[super initWithFrame: bounds];
 305     if (self != nil)
 306     {
 307         self-&gt;jWindow = jwindow;
 308         self-&gt;isFocusable = YES; // can become key window
 309 
 310         self-&gt;suppressWindowMoveEvent = NO;
 311         self-&gt;suppressWindowResizeEvent = NO;
 312         self-&gt;isEnabled = YES;
 313 
 314         //default values of min/max frame sizes
 315         self-&gt;minWidth = self-&gt;minHeight = 0.0f;
 316         self-&gt;maxWidth = self-&gt;maxHeight = CGFLOAT_MAX;
 317 
 318         self-&gt;childWindows = [NSMutableArray arrayWithCapacity:(NSUInteger)1];
 319         self-&gt;childWindows = [self-&gt;childWindows retain];
 320 
 321         // default to opaque
 322         [self _setTransparent:NO];
 323 
 324         [self setAutoresizesSubviews:NO];
 325 
 326     }
 327     return self;
 328 }
 329 
 330 
 331 #pragma mark ---
 332 
 333 - (void)_setTransparent:(BOOL)state
 334 {
 335     GLASS_LOG(&quot;GlassWindow _setTransparent called.&quot;);
 336     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 337     // should we store original background color?
 338     // This is only set during window creation so I don&#39;t think it&#39;s necessary
 339     self-&gt;isTransparent = state;
 340     if (self-&gt;isTransparent == YES)
 341     {
 342         [super setBackgroundColor:[UIColor clearColor]];
 343         [super setOpaque:NO];
 344     }
 345     else
 346     {
 347         [super setBackgroundColor:[UIColor blackColor]];
 348         [super setOpaque:YES];
 349     }
 350 }
 351 
 352 
 353 #pragma mark --- JavaAdditions
 354 
 355 - (void)_setAlpha
 356 {
 357     GLASS_LOG(&quot;GlassWindow _setAlpha called.&quot;);
 358     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 359     [self setAlpha:_setAlpha];
 360 }
 361 
 362 
 363 - (void)_setBoundsAndPosition
 364 {
 365     GLASS_LOG(&quot;_GlassWindow _setFrame called&quot;);
 366     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 367     CGRect frameRect = CGRectMake(0.0, 0.0, self-&gt;_setFrameWidth, self-&gt;_setFrameHeight);
 368 
 369     GLASS_LOG(&quot;bounds width, height before constraining %f, %f &quot;, self-&gt;_setFrameWidth, self-&gt;_setFrameHeight);
 370 
 371     CGSize constrainedSize = [self _constrainBounds:frameRect];
 372     //if larger than maxSize | smaller than minSize
 373     if (frameRect.size.width != constrainedSize.width ||
 374         frameRect.size.height != constrainedSize.height) {
 375         self-&gt;_setFrameWidth = constrainedSize.width;
 376         self-&gt;_setFrameHeight = constrainedSize.height;
 377         frameRect.size.width = constrainedSize.width;
 378         frameRect.size.height = constrainedSize.height;
 379     }
 380 
 381     GLASS_LOG(&quot;bounds width, height after constraining %f, %f &quot;, self-&gt;_setFrameWidth, self-&gt;_setFrameHeight);
 382 
 383 
 384     [self setBounds: frameRect];
 385 
 386 
 387     CGPoint newCenter = CGPointMake(self-&gt;_setFrameX + self-&gt;_setFrameWidth / 2, self-&gt;_setFrameY + self-&gt;_setFrameHeight / 2);
 388 
 389     [self setCenter:newCenter];
 390 
 391     GLASS_LOG(&quot;BOUNDS after GlassWindow _setFrame == %f, %f, center == %f %f&quot;,[self bounds].size.width,[self bounds].size.height ,[self center].x, [self center].y);
 392 
 393     GLASS_LOG(&quot;FRAME after GlassWindow _setFrame == %f, %f, %f, %f&quot;,[self frame].size.width,[self frame].size.height ,[self frame].origin.x, [self frame].origin.y);
 394 }
 395 
 396 -(void) setBounds:(CGRect)bounds
 397 {
 398     CGRect frameRect = bounds;
 399     if (self-&gt;owner == nil) { // primary Stage
 400         GLASS_LOG(&quot;primaryStage was asked to resize to %f, %f&quot;,bounds.size.width, bounds.size.height);
 401         frameRect = [[self superview] bounds];
 402         GLASS_LOG(&quot;primaryStage resized to %f, %f&quot;,frameRect.size.width, frameRect.size.height);
 403     }
 404 
 405     [super setBounds:frameRect];
 406 
 407     [self-&gt;hostView setFrame:frameRect];//hostView is always same size as GlassWindow
 408 
 409     for(GlassViewGL * subView in [self-&gt;hostView subviews]) {
 410         if(subView != nil &amp;&amp; [subView isKindOfClass:[GlassViewGL class]] == YES) {
 411             [subView setFrame:frameRect];
 412         }
 413     }
 414 
 415     [self _sendJavaWindowResizeEvent:com_sun_glass_events_WindowEvent_RESIZE forFrame:[self bounds]];
 416 }
 417 
 418 -(void) setCenter:(CGPoint)center
 419 {
 420     CGPoint newCenter = center;
 421 
 422     if (self-&gt;owner == nil) { // primary Stage
 423         GLASS_LOG(&quot;primaryStage was asked to setCenter to %f, %f&quot;,center.x, center.y);
 424         CGRect frameRect = [[self superview] bounds];
 425         newCenter = CGPointMake(frameRect.size.width/2, frameRect.size.height/2);
 426 
 427         GLASS_LOG(&quot;primaryStage setCenter to %f, %f&quot;,newCenter.x, newCenter.y);
 428     }
 429 
 430     [super setCenter:newCenter];
 431 
 432     [self _sendJavaWindowMoveEventForFrame:CGRectMake([self center].x - [self bounds].size.width / 2, [self center].y - [self bounds].size.height / 2, [self bounds].size.width,[self bounds].size.height )];
 433 }
 434 
 435 
 436 - (CGSize)_constrainBounds:(CGRect)frame
 437 {
 438     GLASS_LOG(&quot;GlassWindow _constrainBounds called&quot;);
 439     CGSize size = frame.size;
 440 
 441     CGSize constrained = CGSizeMake(frame.size.width, frame.size.height);
 442     {
 443         if (size.width &lt; self-&gt;minWidth)
 444         {
 445             constrained.width = self-&gt;minWidth;
 446         }
 447         else if (size.width &gt; self-&gt;maxWidth)
 448         {
 449             constrained.width = self-&gt;maxWidth;
 450         }
 451         if (size.height &lt; self-&gt;minHeight)
 452         {
 453             constrained.height = self-&gt;minHeight;
 454         }
 455         else if (size.height &gt; self-&gt;maxHeight)
 456         {
 457             constrained.height = self-&gt;maxHeight;
 458         }
 459     }
 460     return constrained;
 461 }
 462 
 463 
 464 - (void)_setMinimumSize
 465 {
 466     GLASS_LOG(&quot;GlassWindow _setMinimumSize called. (w %f, h %f)&quot;,self-&gt;minWidth, self-&gt;minHeight);
 467     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 468     CGSize currentSize = [self bounds].size;
 469     if (currentSize.width &lt; self-&gt;minWidth || currentSize.height &lt; self-&gt;minHeight) {
 470         [self _setBoundsAndPosition];
 471         [self _sendJavaWindowResizeEvent:com_sun_glass_events_WindowEvent_RESIZE forFrame:[self bounds]];
 472     }
 473 }
 474 
 475 
 476 - (void)_setMaximumSize
 477 {
 478     GLASS_LOG(&quot;GlassWindow _setMaximumSize called. (w %f, h %f)&quot;,self-&gt;maxWidth, self-&gt;maxHeight);
 479     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 480     CGSize currentSize = [self bounds].size;
 481     if (currentSize.width &gt; self-&gt;maxWidth || currentSize.height &gt; self-&gt;maxHeight) {
 482         [self _setBoundsAndPosition];
 483         [self _sendJavaWindowResizeEvent:com_sun_glass_events_WindowEvent_RESIZE forFrame:[self bounds]];
 484     }
 485 }
 486 
 487 
 488 - (void)_setLevel
 489 {
 490     GLASS_LOG(&quot;GlassWindow _setLevel called.&quot;);
 491     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 492     UIWindowLevel level = UIWindowLevelNormal;
 493     switch (self-&gt;_setLevel)
 494     {
 495         case com_sun_glass_ui_Window_Level_FLOATING:
 496             level = UIWindowLevelStatusBar;
 497             break;
 498         case com_sun_glass_ui_Window_Level_TOPMOST:
 499             level = UIWindowLevelAlert;
 500             break;
 501     }
 502     //[self setWindowLevel:level];         // implemenation comes here
 503 }
 504 
 505 
 506 - (void)orderBack
 507 {
 508     GLASS_LOG(&quot;GlassWindow orderBack&quot;);
 509     if ([[NSThread currentThread] isMainThread] == YES) {
 510         [self _orderBack];
 511     } else {
 512         [self performSelectorOnMainThread:@selector(_orderBack) withObject:nil waitUntilDone:YES];
 513     }
 514 }
 515 
 516 
 517 - (void)_orderBack
 518 {
 519     GLASS_LOG(&quot;GlassWindow _orderBack&quot;);
 520     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 521     if ([self superview] != nil) {
 522         [[self superview] sendSubviewToBack:self];
 523     }
 524 }
 525 
 526 
 527 - (void) _orderFrontRegardless
 528 {
 529     GLASS_LOG(&quot;GlassWindow _orderFrontRegardless &quot;);
 530     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 531     if ([self superview] != nil) {
 532         [[self superview] bringSubviewToFront:self];
 533     }
 534 }
 535 
 536 
 537 - (void) orderFrontRegardless
 538 {
 539     if ([[NSThread currentThread] isMainThread] == YES) {
 540         [self _orderFrontRegardless];
 541     } else {
 542         [self performSelectorOnMainThread:@selector(_orderFrontRegardless) withObject:nil waitUntilDone:YES];
 543     }
 544 }
 545 
 546 
 547 - (void)addChildWindow:(GlassWindow*)child
 548 {
 549     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 550     if (child != nil) {
 551         child-&gt;parentWindow = self;
 552         [self-&gt;childWindows addObject:child];
 553 
 554         [child _setBoundsAndPosition];
 555     }
 556 }
 557 
 558 
 559 - (void)removeChildWindow:(GlassWindow*)child
 560 {
 561     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 562     if (child != nil) {
 563         child-&gt;parentWindow = nil;
 564         [self-&gt;childWindows removeObject:child];
 565     }
 566 }
 567 
 568 
 569 + (void)_resetGrab
 570 {
 571     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 572     if (s_grabWindow &amp;&amp; [s_grabWindow isKindOfClass:[GlassWindow class]]) {
 573         GlassWindow * window = (GlassWindow*)s_grabWindow;
 574         [window _ungrabFocus];
 575     }
 576     s_grabWindow = nil; // unconditionally
 577 }
 578 
 579 
 580 - (void)_ungrabFocus
 581 {
 582     if (s_grabWindow != self) {
 583         return;
 584     }
 585 
 586     GET_MAIN_JENV;
 587     (*env)-&gt;CallVoidMethod(env, self-&gt;jWindow, jWindowNotifyFocusUngrab);
 588 
 589     s_grabWindow = nil;
 590 }
 591 
 592 
 593 - (void)_checkUngrab
 594 {
 595     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 596     if (!s_grabWindow) {
 597         return;
 598     }
 599 
 600     // If this window doesn&#39;t belong to an owned windows hierarchy that
 601     // holds the grab currently, then the grab should be released.
 602     for (GlassWindow * window = self; window; window = window-&gt;parentWindow) {
 603         if (window == s_grabWindow) {
 604             return;
 605         }
 606     }
 607 
 608     [GlassWindow _resetGrab];
 609 }
 610 
 611 
 612 - (void)_grabFocus
 613 {
 614     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 615     if (s_grabWindow == self) {
 616         return;
 617     }
 618 
 619     [GlassWindow _resetGrab];
 620     s_grabWindow = self;
 621 }
 622 
 623 
 624 - (void)_setVisible
 625 {
 626     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 627     if (self-&gt;isEnabled == YES)
 628     {
 629         GLASS_LOG(&quot;making GlassWindow Visible %p&quot;,self);
 630         [self setHidden:NO];
 631 
 632         if (self-&gt;isFocusable == YES) {
 633             GLASS_LOG(&quot;making GlassWindow key %p&quot;,self);
 634             [self makeKeyWindow];
 635         }
 636 
 637         [self orderFrontRegardless];
 638     } else {
 639         [self orderFrontRegardless];
 640     }
 641 
 642     if ((self-&gt;owner != nil &amp;&amp; self-&gt;parentWindow == nil))
 643     {
 644         [(GlassWindow *)self-&gt;owner addChildWindow:self];
 645     }
 646 }
 647 
 648 
 649 - (void)_sendJavaWindowMoveEventForFrame:(CGRect)frame
 650 {
 651     if (self-&gt;suppressWindowMoveEvent == NO)
 652     {
 653         GET_MAIN_JENV;
 654         (*env)-&gt;CallVoidMethod(env, jWindow, mat_jWindowNotifyMove, (int)frame.origin.x,  (int)frame.origin.y);
 655     }
 656 }
 657 
 658 
 659 - (void)_sendJavaWindowResizeEvent:(int)type forFrame:(CGRect)frame
 660 {
 661     if (self-&gt;suppressWindowResizeEvent == NO)
 662     {
 663         GET_MAIN_JENV;
 664         (*env)-&gt;CallVoidMethod(env, jWindow, mat_jWindowNotifyResize, type, (int)frame.size.width, (int)frame.size.height);
 665     }
 666 }
 667 
 668 
 669 #pragma mark --- UIView
 670 
 671 - (void) setBackgroundColor:(UIColor *)color
 672 {
 673     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 674     if (self-&gt;isTransparent == NO)
 675     {
 676         // allow color if we&#39;re opaque
 677         [super setBackgroundColor:color];
 678     }
 679     else
 680     {
 681         // for transparent window, ignore and set to clear color
 682         // do we want to store the background color in case we switch to non-transparent mode?
 683         [super setBackgroundColor:[UIColor clearColor]];
 684     }
 685 }
 686 
 687 - (void) makeKeyWindow
 688 {
 689     if (self-&gt;isEnabled &amp;&amp; self-&gt;isFocusable &amp;&amp; focusOwner != self) {
 690 
 691         [focusOwner resignKeyWindow];
 692 
 693         [self becomeKeyWindow];
 694     }
 695 }
 696 
 697 - (BOOL) isKeyWindow
 698 {
 699     return self == focusOwner;
 700 }
 701 
 702 - (void)becomeKeyWindow
 703 {
 704     GLASS_LOG(&quot;Window did become key&quot;);
 705     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 706 
 707 
 708     GET_MAIN_JENV;
 709     if (!self-&gt;isEnabled)
 710     {
 711         (*env)-&gt;CallVoidMethod(env, self-&gt;jWindow, mat_jWindowNotifyFocusDisabled);
 712         return;
 713     }
 714 
 715     focusOwner = self;
 716 
 717     (*env)-&gt;CallVoidMethod(env, self-&gt;jWindow, mat_jWindowNotifyFocus, com_sun_glass_events_WindowEvent_FOCUS_GAINED);
 718 }
 719 
 720 
 721 - (void)resignKeyWindow
 722 {
 723     GLASS_LOG(&quot;Window did resign key&quot;);
 724     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 725 
 726     if (focusOwner == self) {
 727         focusOwner = nil;
 728     }
 729 
 730     [self _ungrabFocus];
 731 
 732     GET_MAIN_JENV;
 733     (*env)-&gt;CallVoidMethod(env, self-&gt;jWindow, mat_jWindowNotifyFocus, com_sun_glass_events_WindowEvent_FOCUS_LOST);
 734 }
 735 
 736 
 737 - (void)windowWillClose
 738 {
 739     GLASS_LOG(&quot;GlassWindow windowWillClose&quot;);
 740     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 741     // Unparent self
 742     if (self-&gt;parentWindow != nil)
 743     {
 744         [self-&gt;parentWindow removeChildWindow:self];
 745     }
 746 
 747     // Call the notification method
 748     GET_MAIN_JENV;
 749     (*env)-&gt;CallVoidMethod(env, self-&gt;jWindow, mat_jWindowNotifyDestroy);
 750 
 751     if (childWindows != NULL) {
 752 
 753         // Finally, close owned windows to mimic MS Windows behavior
 754         for (GlassWindow * child in self-&gt;childWindows)
 755         {
 756             [child close];
 757         }
 758 
 759         [childWindows release];
 760     }
 761 
 762     [self-&gt;hostView removeFromSuperview];
 763     [self-&gt;hostView release];
 764 
 765     if ([self superview] != nil) {
 766         [self removeFromSuperview];
 767     }
 768 
 769     if (focusOwner == self) {
 770         focusOwner = nil;
 771     }
 772 
 773     (*jEnv)-&gt;DeleteGlobalRef(jEnv, self-&gt;jWindow);
 774     GLASS_CHECK_EXCEPTION(jEnv);
 775 
 776     self-&gt;jWindow = NULL;
 777 }
 778 
 779 
 780 - (void) requestInput:(NSString *)text type:(int)type width:(double)width height:(double)height
 781                   mxx:(double)mxx mxy:(double)mxy mxz:(double)mxz mxt:(double)mxt
 782                   myx:(double)myx myy:(double)myy myz:(double)myz myt:(double)myt
 783                   mzx:(double)mzx mzy:(double)mzy mzz:(double)mzz mzt:(double)mzt
 784 
 785 {
 786     [view requestInput:text type:type width:width height:height
 787                    mxx:mxx mxy:mxy mxz:mxz mxt:mxt
 788                    myx:myx myy:myy myz:myz myt:myt
 789                    mzx:mzx mzy:mzy mzz:mzz mzt:mzt];
 790 }
 791 
 792 
 793 - (void) releaseInput
 794 {
 795     [view releaseInput];
 796 }
 797 
 798 @end
 799 
 800 
 801 
 802 jlong _1createWindow(JNIEnv *env, jobject jWindow, jlong jOwnerPtr, jlong jScreenPtr, jint jStyleMask)
 803 {
 804     [[NSThread currentThread] isMainThread];
 805     if ([[NSThread currentThread] isMainThread] == NO) NSLog(@&quot;[1] must be on main thread&quot;);
 806     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 807 
 808     GlassWindow *window;
 809 
 810     {
 811         UIScreen *screen = (UIScreen*)jlong_to_ptr(jScreenPtr);
 812         BOOL hidden = YES;
 813         if (jOwnerPtr == 0L) {
 814             // no owner means it is the primary stage; Decorated primary stage shows status bar by default
 815             hidden = ((jStyleMask &amp; com_sun_glass_ui_Window_TITLED) == 0);
 816 
 817             NSObject * values = [[NSBundle mainBundle] objectForInfoDictionaryKey:@&quot;UIStatusBarHidden&quot;];
 818             //we prefer explicit settings from .plist
 819             if (values != nil) {
 820                 hidden = (values == @(YES))?YES:NO;
 821             }
 822 
 823             [UIApplication sharedApplication].statusBarHidden = hidden;
 824         }
 825 
 826 
 827         if (masterWindow == nil) {
 828             //We have to remove rootViewController of splashscreen UIWindow in order to avoid
 829             //StatusBar orientation change ...
 830             UIWindow *splashScreen = [[UIApplication sharedApplication] keyWindow];
 831             splashScreen.rootViewController = nil;
 832 
 833             GLASS_LOG(&quot;SCREEN: %@&quot;, screen);
 834             CGRect applicationFrame = [screen bounds];
 835             GLASS_LOG(&quot;FRAME: %@&quot;, applicationFrame);
 836 
 837             masterWindow = [[GlassMainWindow alloc] initWithFrame:applicationFrame];
 838             masterWindowHost = [[GlassMainView alloc] initWithFrame:CGRectMake(0.0, 0.0, applicationFrame.size.width, applicationFrame.size.height)];
 839 
 840             // Set GlassViewController - responsible for orientation change, etc.
 841             GlassViewController *rvc = [[GlassViewController alloc] init];
 842             [rvc setView:masterWindowHost];
 843             [masterWindow setRootViewController:rvc];
 844             [rvc release];
 845 
 846             [masterWindow setHidden:NO];
 847             [masterWindowHost setHidden:NO];
 848         } else {
 849             masterWindow = [masterWindow retain];//increase retain count per each GlassWindow
 850             masterWindowHost = [masterWindowHost retain];
 851         }
 852 
 853         [masterWindow setAutoresizesSubviews:YES];
 854         [masterWindowHost setAutoresizesSubviews:NO];
 855 
 856         [masterWindow makeKeyWindow];
 857 
 858         GLASS_LOG(&quot;GlassWindow _1createWindow&quot;);
 859         window = [[GlassWindow alloc] initWithScreen:screen jwindow:jWindow];
 860 
 861         window-&gt;isResizable = NO;
 862 
 863         window-&gt;hostView = [[UIView alloc] init];
 864         [window-&gt;hostView setAutoresizesSubviews:NO];
 865 
 866         [window addSubview:window-&gt;hostView];
 867 
 868         window.backgroundColor = [UIColor whiteColor];
 869 
 870         if ((jStyleMask &amp; com_sun_glass_ui_Window_TRANSPARENT) != 0)
 871         {
 872             [window _setTransparent:YES];
 873         }
 874         else
 875         {
 876             [window _setTransparent:NO];
 877         }
 878 
 879         [masterWindowHost addSubview:window];
 880 
 881         if (jOwnerPtr != 0L)
 882         {
 883             GLASS_LOG(&quot;Adding %p window as usbview of owner window %lld&quot;, window, jOwnerPtr);
 884             window-&gt;owner = (UIWindow*)jlong_to_ptr(jOwnerPtr);
 885         } else {
 886             NSArray *views = [masterWindowHost subviews];
 887             // if there exists any secondary stage, its owner is primary stage internally if
 888             // not set explicitly
 889             if ([views count] &gt; 1) {
 890                 window-&gt;owner = [views objectAtIndex:0];
 891             }
 892         }
 893     }
 894     [pool drain];
 895 
 896     GLASS_CHECK_EXCEPTION(env);
 897 
 898     return ptr_to_jlong(window);
 899 }
 900 
 901 
 902 
 903 @interface GlassWindowDispatcher : NSObject
 904 {
 905 @public
 906     jobject     jWindow;
 907     jlong       jOwnerPtr;
 908     jlong       jScreenPtr;
 909     jint        jStyleMask;
 910     jlong       jlongReturn;
 911 }
 912 @end
 913 
 914 
 915 
 916 @implementation GlassWindowDispatcher
 917 
 918 - (void) _createWindow
 919 {
 920     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot;);
 921     GET_MAIN_JENV;
 922     self-&gt;jlongReturn = _1createWindow(env, self-&gt;jWindow, self-&gt;jOwnerPtr, self-&gt;jScreenPtr, self-&gt;jStyleMask);
 923 }
 924 
 925 @end
 926 
 927 
 928 
 929 /*
 930  * Class:     com_sun_glass_ui_ios_IosWindow
 931  * Method:    _createWindow
 932  * Signature: (JJZI)J
 933  */
 934 JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_ios_IosWindow__1createWindow
 935 (JNIEnv *env, jobject jwindow, jlong jownerPtr, jlong jscreenPtr, jint jstyleMask)
 936 {
 937     jlong value;
 938 
 939     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
 940     GLASS_POOL_ENTER;
 941     {
 942         GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1createWindow&quot;);
 943         jobject jWindowRef = (*env)-&gt;NewGlobalRef(env, jwindow);
 944         if ([[NSThread currentThread] isMainThread] == YES)
 945         {
 946             value = _1createWindow(env, jWindowRef, jownerPtr, jscreenPtr, jstyleMask);
 947             GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1createWindow  from NSMainThread called&quot;);
 948 
 949         }
 950         else
 951         {
 952             GlassWindowDispatcher *dispatcher = [[GlassWindowDispatcher alloc] autorelease];
 953             dispatcher-&gt;jWindow = jWindowRef;
 954             dispatcher-&gt;jOwnerPtr = jownerPtr;
 955             dispatcher-&gt;jScreenPtr = jscreenPtr;
 956             dispatcher-&gt;jStyleMask = jstyleMask;
 957             [dispatcher performSelectorOnMainThread:@selector(_createWindow) withObject:dispatcher waitUntilDone:YES];
 958             value = dispatcher-&gt;jlongReturn;
 959         }
 960     }
 961     GLASS_POOL_EXIT;
 962     GLASS_CHECK_EXCEPTION(env);
 963 
 964     return value;
 965 }
 966 
 967 
 968 /*
 969  * Class:     com_sun_glass_ui_ios_IosWindow
 970  * Method:    _createChildWindow
 971  * Signature: (J)J
 972  */
 973 JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_ios_IosWindow__1createChildWindow
 974 (JNIEnv *env, jobject jwindow, jlong parent) {
 975     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1createChildWindow&quot;);
 976     // implementation comes here
 977     return 0L;
 978 }
 979 
 980 
 981 /*
 982  * Class:     com_sun_glass_ui_ios_IosWindow
 983  * Method:    _close
 984  * Signature: (J)Z
 985  */
 986 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1close
 987 (JNIEnv *env, jclass jwindow, jlong ptr) {
 988     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1close&quot;);
 989     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
 990     GLASS_POOL_ENTER;
 991     {
 992         GlassWindow *window = (GlassWindow*)jlong_to_ptr(ptr);
 993         if ([[NSThread currentThread] isMainThread] == YES)
 994         {
 995             // this call will always close the window
 996             // without calling the windowShouldClose
 997             [window close];
 998             [window release];
 999         }
1000         else
1001         {
1002             // this call will always close the window
1003             // without calling the windowShouldClose
1004             [window performSelectorOnMainThread:@selector(close) withObject:nil waitUntilDone:YES];
1005             [window performSelectorOnMainThread:@selector(release) withObject:nil waitUntilDone:YES];
1006         }
1007         // The window is released here since we retain it - different from Mac OS X
1008     }
1009     GLASS_POOL_EXIT;
1010     GLASS_CHECK_EXCEPTION(env);
1011 
1012     return JNI_TRUE;
1013 }
1014 
1015 
1016 /*
1017  * Class:     com_sun_glass_ui_ios_IosWindow
1018  * Method:    _setView
1019  * Signature: (JLcom/sun/glass/ui/View;)Z
1020  */
1021 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setView
1022 (JNIEnv *env, jobject jwindow, jlong windowPtr, jobject jview) {
1023 
1024     if ([[NSThread currentThread] isMainThread] == NO) NSLog(@&quot;[2] must be on main thread&quot;);
1025 
1026     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1027     GLASS_POOL_ENTER;
1028     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setView&quot;);
1029     {
1030         GlassWindow *window = getGlassWindow(env, windowPtr);
1031 
1032         window-&gt;view = getiOSView(env, jview);
1033 
1034 
1035         GLASS_LOG(&quot;window: %@&quot;, window);
1036         GLASS_LOG(&quot;frame: %.2f,%.2f %.2fx%.2f&quot;, [window frame].origin.x, [window frame].origin.y, [window frame].size.width, [window frame].size.height);
1037         GLASS_LOG(&quot;view: %@&quot;, window-&gt;view);
1038         GLASS_LOG(&quot;frame: %.2f,%.2f %.2fx%.2f&quot;, [window-&gt;view frame].origin.x, [window-&gt;view frame].origin.y, [window-&gt;view frame].size.width, [window-&gt;view frame].size.height);
1039 
1040         if (window-&gt;view != nil)
1041         {
1042             window-&gt;suppressWindowMoveEvent = YES; // RT-11215
1043             {
1044                 CGRect viewFrame = [window-&gt;view bounds];
1045                 if ((viewFrame.size.width != 0.0f) &amp;&amp; (viewFrame.size.height != 0.0f))
1046                 {
1047                     CGRect windowFrame = CGRectMake(0.0, 0.0, viewFrame.size.width, viewFrame.size.height);
1048                     windowFrame.origin.x = [window center].x - viewFrame.size.width / 2 ;
1049                     windowFrame.origin.y = [window center].y - viewFrame.size.height / 2;
1050                     setWindowFrame(window, windowFrame.origin.x, windowFrame.origin.y, windowFrame.size.width, windowFrame.size.height, JNI_TRUE, JNI_FALSE);
1051                 }
1052 
1053                 if ([[NSThread currentThread] isMainThread] == YES)
1054                 {
1055                     [window-&gt;hostView addSubview: window-&gt;view];
1056                 }
1057                 else
1058                 {
1059                     [window-&gt;hostView performSelectorOnMainThread:@selector(addSubview:) withObject:window-&gt;view waitUntilDone:YES];
1060                 }
1061             }
1062             window-&gt;suppressWindowMoveEvent = NO;
1063         }
1064     }
1065     GLASS_POOL_EXIT;
1066     GLASS_CHECK_EXCEPTION(env);
1067 
1068     return JNI_TRUE;
1069 }
1070 
1071 
1072 /*
1073  * Class:     com_sun_glass_ui_ios_IosWindow
1074  * Method:    _setMenubar
1075  * Signature: (JJ)Z
1076  */
1077 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setMenubar
1078 (JNIEnv *env, jobject jwindow, jlong windowPtr, jlong menubarPtr) {
1079 
1080     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1081     GLASS_POOL_ENTER;
1082     {
1083         GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setMenubar - setMenuBar called.&quot;);
1084         // implementation comes here
1085     }
1086     GLASS_POOL_EXIT;
1087     GLASS_CHECK_EXCEPTION(env);
1088 
1089     return JNI_TRUE;
1090 }
1091 
1092 
1093 /*
1094  * Class:     com_sun_glass_ui_ios_IosWindow
1095  * Method:    _minimize
1096  * Signature: (JZ)Z
1097  */
1098 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1minimize
1099 (JNIEnv *env, jobject jwindow, jlong windowPtr, jboolean minimize) {
1100     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1minimize called.&quot;);
1101 
1102     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1103     GLASS_POOL_ENTER;
1104     {
1105         // implementation comes here
1106     }
1107     GLASS_POOL_EXIT;
1108     GLASS_CHECK_EXCEPTION(env);
1109 
1110     return JNI_TRUE;
1111 }
1112 
1113 
1114 /*
1115  * Class:     com_sun_glass_ui_ios_IosWindow
1116  * Method:    _maximize
1117  * Signature: (JZZ)Z
1118  */
1119 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1maximize
1120 (JNIEnv *env, jobject jwindow, jlong windowPtr, jboolean maximize, jboolean wasMaximized) {
1121     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1maximize called.&quot;);
1122     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1123     GLASS_POOL_ENTER;
1124     {
1125         // implementation comes here
1126     }
1127     GLASS_POOL_EXIT;
1128     GLASS_CHECK_EXCEPTION(env);
1129 
1130     return JNI_TRUE;
1131 }
1132 
1133 
1134 /*
1135  * Class:     com_sun_glass_ui_ios_IosWindow
1136  * Method:    _setBoundsAndPosition
1137  * Signature: (JIIZZIIIIFF)V
1138  */
1139 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setBounds
1140 (JNIEnv *env, jobject jWindow, jlong jPtr,
1141  jint x, jint y, jboolean xSet, jboolean ySet,
1142  jint w, jint h, jint cw, jint ch, jfloat xGravity, jfloat yGravity)
1143 {
1144     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setBounds&quot;);
1145     if ([[NSThread currentThread] isMainThread] == NO) NSLog(@&quot;[3] must be on main thread&quot;);
1146 
1147     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1148     GLASS_POOL_ENTER;
1149     {
1150         GLASS_LOG(&quot;Called setBounds with x %ld,y %ld,xSet %d,ySet %d,w %ld,h %ld,cw %ld,ch %ld&quot;,x,y,xSet,ySet,w,h,cw,ch);
1151 
1152         GlassWindow *window = (GlassWindow *)jlong_to_ptr(jPtr);
1153 
1154         CGPoint origin = CGPointMake([window center].x - [window bounds].size.width / 2, [window center].y - [window bounds].size.height / 2);
1155         GLASS_LOG(&quot;window original position x,y %f, %f&quot;,origin.x,origin.y);
1156 
1157         CGSize size = [window bounds].size;
1158         GLASS_LOG(&quot;window size w,h %f,%f&quot;,size.width,size.height);
1159 
1160         CGSize sizeForClient = CGRectMake(0, 0, cw &gt; 0 ? cw : 0, ch &gt; 0 ? ch : 0).size;
1161         GLASS_LOG(&quot;sizeForClient %f, %f&quot;, sizeForClient.width, sizeForClient.height);
1162 
1163         CGFloat newX = xSet == JNI_TRUE ? x : origin.x;
1164         CGFloat newY = ySet == JNI_TRUE ? y : origin.y;
1165         CGFloat newW = (w &gt; 0) ? w :
1166         (cw &gt; 0) ? sizeForClient.width : size.width;
1167         CGFloat newH = (h &gt; 0) ? h :
1168         (ch &gt; 0) ? sizeForClient.height : size.height;
1169         GLASS_LOG(&quot;FRAME: x,y,w,h - %f, %f, %f %f&quot;,newX, newY, newW, newH);
1170 
1171         setWindowFrame(window, newX, newY, newW, newH, JNI_TRUE, JNI_FALSE);
1172 
1173         //Let&#39;s notify JavaFX about move,size change (as we don&#39;t have window&#39;s size,position) Notifications on iOS
1174         if(xSet == JNI_TRUE || ySet == JNI_TRUE) {
1175             [window _sendJavaWindowMoveEventForFrame:CGRectMake([window center].x - [window bounds].size.width / 2, [window center].y - [window bounds].size.height / 2, [window bounds].size.width,[window bounds].size.height )];
1176         } else {
1177             [window _sendJavaWindowResizeEvent:com_sun_glass_events_WindowEvent_RESIZE forFrame:[window bounds]];
1178         }
1179     }
1180     GLASS_POOL_EXIT;
1181     GLASS_CHECK_EXCEPTION(env);
1182 }
1183 
1184 
1185 /*
1186  * Class:     com_sun_glass_ui_ios_IosWindow
1187  * Method:    _setVisible
1188  * Signature: (JZ)Z
1189  */
1190 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setVisible
1191 (JNIEnv *env, jobject jwindow, jlong windowPtr, jboolean visible) {
1192     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setVisible called.&quot;);
1193     jboolean now;
1194 
1195     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1196     GLASS_POOL_ENTER;
1197     {
1198         GlassWindow *window = getGlassWindow(env, windowPtr);
1199         if (visible == JNI_TRUE)
1200         {
1201             if ([[NSThread currentThread] isMainThread] == YES)
1202             {
1203                 [window _setVisible];
1204             }
1205             else
1206             {
1207                 [window performSelectorOnMainThread:@selector(_setVisible) withObject:nil waitUntilDone:YES];
1208             }
1209         }
1210         else
1211         {
1212             if ([[NSThread currentThread] isMainThread] == YES)
1213             {
1214                 [window _ungrabFocus];
1215                 if (window-&gt;owner != nil)
1216                 {
1217                     [(GlassWindow *)window-&gt;owner removeChildWindow: window];
1218                 }
1219                 //[window orderOut:window];
1220             }
1221             else
1222             {
1223                 [window performSelectorOnMainThread:@selector(_ungrabFocus) withObject:nil waitUntilDone:YES];
1224                 if (window-&gt;owner != nil)
1225                 {
1226                     [(GlassWindow *)(window-&gt;owner) performSelectorOnMainThread:@selector(removeChildWindow:) withObject:window waitUntilDone:YES];
1227                 }
1228                 //[window performSelectorOnMainThread:@selector(orderOut:) withObject:window waitUntilDone:YES];
1229             }
1230         }
1231         if ([[NSThread currentThread] isMainThread] == NO) NSLog(@&quot;[4] must be on main thread&quot;);
1232         now = ([window isHidden] == NO) ? JNI_TRUE : JNI_FALSE;
1233     }
1234     GLASS_POOL_EXIT;
1235     GLASS_CHECK_EXCEPTION(env);
1236 
1237     return now;
1238 }
1239 
1240 
1241 /*
1242  * Class:     com_sun_glass_ui_ios_IosWindow
1243  * Method:    _requestFocus
1244  * Signature: (J)Z
1245  */
1246 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1requestFocus
1247 (JNIEnv *env, jobject jwindow, jlong windowPtr) {
1248     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1requestFocus  called.&quot;);
1249     jboolean focused;
1250 
1251     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1252     GLASS_POOL_ENTER;
1253     {
1254         GlassWindow *window = getGlassWindow(env, windowPtr);
1255         if (window-&gt;isFocusable == YES) {
1256             if ([[NSThread currentThread] isMainThread] == YES)
1257             {
1258                 [window makeKeyWindow];//for iOS
1259                 [window orderFrontRegardless];
1260             }
1261             else
1262             {
1263                 [window performSelectorOnMainThread:@selector(makeKeyWindow) withObject:nil waitUntilDone:YES];
1264                 [window performSelectorOnMainThread:@selector(orderFrontRegardless) withObject:window waitUntilDone:YES];
1265             }
1266         }
1267         if ([[NSThread currentThread] isMainThread] == NO) NSLog(@&quot;[5] must be on main thread&quot;);
1268         focused = [window isKeyWindow] ? JNI_TRUE : JNI_FALSE;
1269     }
1270     GLASS_POOL_EXIT;
1271     GLASS_CHECK_EXCEPTION(env);
1272 
1273     return focused;
1274 }
1275 
1276 
1277 /*
1278  * Class:     com_sun_glass_ui_ios_IosWindow
1279  * Method:    _grabFocus
1280  * Signature: (J)Z
1281  */
1282 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1grabFocus
1283 (JNIEnv *env, jobject jwindow, jlong windowPtr) {
1284     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1grabFocus&quot;);
1285     jboolean ret;
1286 
1287     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1288     GLASS_POOL_ENTER;
1289     {
1290         GlassWindow * window = getGlassWindow(env, windowPtr);
1291         if ([[NSThread currentThread] isMainThread] == YES)
1292         {
1293             [window _grabFocus];
1294         }
1295         else
1296         {
1297             [window performSelectorOnMainThread:@selector(_grabFocus) withObject:nil waitUntilDone:YES];
1298         }
1299         ret = JNI_TRUE;
1300     }
1301     GLASS_POOL_EXIT;
1302     GLASS_CHECK_EXCEPTION(env);
1303 
1304     return ret;
1305 }
1306 
1307 
1308 /*
1309  * Class:     com_sun_glass_ui_ios_IosWindow
1310  * Method:    _ungrabFocus
1311  * Signature: (J)
1312  */
1313 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1ungrabFocus
1314 (JNIEnv *env, jobject jwindow, jlong windowPtr) {
1315     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1ungrabFocus&quot;);
1316 
1317     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1318     GLASS_POOL_ENTER;
1319     {
1320         GlassWindow * window = getGlassWindow(env, windowPtr);
1321 
1322         if ([[NSThread currentThread] isMainThread] == YES)
1323         {
1324             [window _ungrabFocus];
1325         } else {
1326             [window performSelectorOnMainThread:@selector(_ungrabFocus) withObject:nil waitUntilDone:YES];
1327         }
1328     }
1329     GLASS_POOL_EXIT;
1330     GLASS_CHECK_EXCEPTION(env);
1331 }
1332 
1333 
1334 /*
1335  * Class:     com_sun_glass_ui_ios_IosWindow
1336  * Method:    _setTitle
1337  * Signature: (JLjava/lang/String;)Z
1338  */
1339 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setTitle
1340 (JNIEnv *env, jobject jwindow, jlong windowPtr, jstring title) {
1341     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setTitle called.&quot;);
1342     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1343     GLASS_POOL_ENTER;
1344     {
1345         // implementation comes here when feature is requested on iOS
1346     }
1347     GLASS_POOL_EXIT;
1348     GLASS_CHECK_EXCEPTION(env);
1349 
1350     return JNI_TRUE;
1351 }
1352 
1353 
1354 /*
1355  * Class:     com_sun_glass_ui_ios_IosWindow
1356  * Method:    _setLevel
1357  * Signature: (JI)V
1358  */
1359 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setLevel
1360 (JNIEnv *env, jobject jwindow, jlong windowPtr, jint level) {
1361     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setLevel called.&quot;);
1362     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1363     GLASS_POOL_ENTER;
1364     {
1365         GlassWindow *window = getGlassWindow(env, windowPtr);
1366         window-&gt;_setLevel = level;
1367 
1368         if ([[NSThread currentThread] isMainThread] == YES)
1369         {
1370             [window _setLevel];
1371         }
1372         else
1373         {
1374             [window performSelectorOnMainThread:@selector(setLevel) withObject:nil waitUntilDone:YES];
1375         }
1376     }
1377     GLASS_POOL_EXIT;
1378     GLASS_CHECK_EXCEPTION(env);
1379 }
1380 
1381 
1382 /*
1383  * Class:     com_sun_glass_ui_ios_IosWindow
1384  * Method:    _setResizable
1385  * Signature: (JZ)Z
1386  */
1387 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setResizable
1388 (JNIEnv *env, jobject jwindow, jlong windowPtr, jboolean resizeable) {
1389     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1390     GLASS_POOL_ENTER;
1391     {
1392         GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setResizable called.&quot;);
1393         GlassWindow *window = getGlassWindow(env, windowPtr);
1394         if (window-&gt;isResizable != resizeable)
1395         {
1396             window-&gt;isResizable = resizeable;
1397         }
1398     }
1399     GLASS_POOL_EXIT;
1400     GLASS_CHECK_EXCEPTION(env);
1401 
1402     return JNI_TRUE;
1403 }
1404 
1405 
1406 /*
1407  * Class:     com_sun_glass_ui_ios_IosWindow
1408  * Method:    _setFocusable
1409  * Signature: (JZ)V
1410  */
1411 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setFocusable
1412 (JNIEnv *env, jobject jwindow, jlong windowPtr, jboolean isFocusable) {
1413     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setFocusable called.&quot;);
1414     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1415     GLASS_POOL_ENTER;
1416     {
1417         GlassWindow *window = getGlassWindow(env, windowPtr);
1418         window-&gt;isFocusable = isFocusable;
1419     }
1420     GLASS_POOL_EXIT;
1421     GLASS_CHECK_EXCEPTION(env);
1422 }
1423 
1424 
1425 /*
1426  * Class:     com_sun_glass_ui_ios_IosWindow
1427  * Method:    _setAlpha
1428  * Signature: (JF)V
1429  */
1430 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setAlpha
1431 (JNIEnv *env, jobject jwindow, jlong windowPtr, jfloat alpha) {
1432     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setAlpha(%f)&quot;,alpha);
1433     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1434     GLASS_POOL_ENTER;
1435     {
1436         GlassWindow *window = getGlassWindow(env, windowPtr);
1437         window-&gt;_setAlpha = alpha;
1438 
1439         if ([[NSThread currentThread] isMainThread] == YES)
1440         {
1441             [window _setAlpha];
1442         }
1443         else
1444         {
1445             [window performSelectorOnMainThread:@selector(_setAlpha) withObject:nil waitUntilDone:YES];
1446         }
1447     }
1448     GLASS_POOL_EXIT;
1449     GLASS_CHECK_EXCEPTION(env);
1450 }
1451 
1452 
1453 /*
1454  * Class:     com_sun_glass_ui_ios_IosWindow
1455  * Method:    _setBackground
1456  * Signature: (JFFF)Z
1457  */
1458 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setBackground
1459 (JNIEnv *env, jobject jwindow, jlong windowPtr, jfloat r, jfloat g, jfloat b) {
1460     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setBackground&quot;);
1461     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1462     GLASS_POOL_ENTER;
1463     {
1464         GlassWindow *window = getGlassWindow(env, windowPtr);
1465         if ([[NSThread currentThread] isMainThread] == YES)
1466         {
1467             [window setBackgroundColor:[UIColor colorWithRed:r green:g blue:b alpha:1.0f]];
1468         }
1469         else
1470         {
1471             [window performSelectorOnMainThread:@selector(setBackgroundColor:) withObject:[UIColor colorWithRed:r green:g blue:b alpha:1.0f] waitUntilDone:YES];
1472         }
1473     }
1474     GLASS_POOL_EXIT;
1475     GLASS_CHECK_EXCEPTION(env);
1476 
1477     return JNI_TRUE;
1478 }
1479 
1480 
1481 /*
1482  * Class:     com_sun_glass_ui_ios_IosWindow
1483  * Method:    _setMinimumSize
1484  * Signature: (JII)Z
1485  */
1486 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setMinimumSize
1487 (JNIEnv *env, jobject jwindow, jlong windowPtr, jint width, jint height) {
1488     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setMinimumSize called.&quot;);
1489     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1490     GLASS_POOL_ENTER;
1491     {
1492         GlassWindow *window = getGlassWindow(env, windowPtr);
1493         window-&gt;minWidth = (jfloat) width;
1494         window-&gt;minHeight = (jfloat) height;
1495 
1496         if ([[NSThread currentThread] isMainThread] == YES)
1497         {
1498             [window _setMinimumSize];
1499         }
1500         else
1501         {
1502             [window performSelectorOnMainThread:@selector(_setMinimumSize) withObject:nil waitUntilDone:YES];
1503         }
1504     }
1505     GLASS_POOL_EXIT;
1506     GLASS_CHECK_EXCEPTION(env);
1507 
1508     return JNI_TRUE;
1509 }
1510 
1511 
1512 /*
1513  * Class:     com_sun_glass_ui_ios_IosWindow
1514  * Method:    _setMaximumSize
1515  * Signature: (JII)Z
1516  */
1517 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setMaximumSize
1518 (JNIEnv *env, jobject jwindow, jlong windowPtr, jint width, jint height) {
1519     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setMaximumSize called.&quot;);
1520     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1521     GLASS_POOL_ENTER;
1522     {
1523         GlassWindow *window = getGlassWindow(env, windowPtr);
1524         window-&gt;maxWidth = (jfloat)(width &gt;= 0 ? width : CGFLOAT_MAX);
1525         window-&gt;maxHeight = (jfloat)(height &gt;= 0 ? height : CGFLOAT_MAX);
1526 
1527         if ([[NSThread currentThread] isMainThread] == YES)
1528         {
1529             [window _setMaximumSize];
1530         }
1531         else
1532         {
1533             [window performSelectorOnMainThread:@selector(_setMaximumSize) withObject:nil waitUntilDone:YES];
1534         }
1535     }
1536     GLASS_POOL_EXIT;
1537     GLASS_CHECK_EXCEPTION(env);
1538 
1539     return JNI_TRUE;
1540 }
1541 
1542 
1543 /*
1544  * Class:     com_sun_glass_ui_ios_IosWindow
1545  * Method:    _setIcon
1546  * Signature: (JIILjava/nio/ByteBuffer;)V
1547  */
1548 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setIcon
1549 (JNIEnv *env, jobject jwindow, jlong windowPtr, jobject pixels) {
1550     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setIcon called.&quot;);
1551     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1552     GLASS_POOL_ENTER;
1553     {
1554         // implemenation comes here
1555     }
1556     GLASS_POOL_EXIT;
1557     GLASS_CHECK_EXCEPTION(env);
1558 }
1559 
1560 
1561 /*
1562  * Class:     com_sun_glass_ui_ios_IosWindow
1563  * Method:    _toFront
1564  * Signature: (J)V
1565  */
1566 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1toFront
1567 (JNIEnv *env, jobject jwindow, jlong windowPtr) {
1568     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1toFront called.&quot;);
1569     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1570     GLASS_POOL_ENTER;
1571     {
1572         GlassWindow *window = getGlassWindow(env, windowPtr);
1573         [window orderFrontRegardless];
1574     }
1575     GLASS_POOL_EXIT;
1576     GLASS_CHECK_EXCEPTION(env);
1577 }
1578 
1579 
1580 /*
1581  * Class:     com_sun_glass_ui_ios_IosWindow
1582  * Method:    _toBack
1583  * Signature: (J)V
1584  */
1585 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1toBack
1586 (JNIEnv *env, jobject jwindow, jlong windowPtr) {
1587     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1toBack called.&quot;);
1588     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1589     GLASS_POOL_ENTER;
1590     {
1591         GlassWindow *window = getGlassWindow(env, windowPtr);
1592         [window orderBack];
1593     }
1594     GLASS_POOL_EXIT;
1595     GLASS_CHECK_EXCEPTION(env);
1596 }
1597 
1598 
1599 /*
1600  * Class:     com_sun_glass_ui_ios_IosWindow
1601  * Method:    _enterModal
1602  * Signature: (J)V
1603  */
1604 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1enterModal
1605 (JNIEnv *env, jobject jwindow, jlong windowPtr) {
1606     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1enterModal called.&quot;);
1607     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1608     GLASS_POOL_ENTER;
1609     {
1610         // implementation omes here
1611     }
1612     GLASS_POOL_EXIT;
1613     GLASS_CHECK_EXCEPTION(env);
1614 }
1615 
1616 
1617 /*
1618  * Class:     com_sun_glass_ui_ios_IosWindow
1619  * Method:    _enterModalWithWindow
1620  * Signature: (JJ)V
1621  */
1622 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1enterModalWithWindow
1623 (JNIEnv *env, jobject jwindow, jlong windowPtr, jlong window) {
1624     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1enterModalWithWindow called.&quot;);
1625     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1626     GLASS_POOL_ENTER;
1627     {
1628         // implemenation comes here
1629     }
1630     GLASS_POOL_EXIT;
1631     GLASS_CHECK_EXCEPTION(env);
1632 }
1633 
1634 
1635 /*
1636  * Class:     com_sun_glass_ui_ios_IosWindow
1637  * Method:    _exitModal
1638  * Signature: (J)V
1639  */
1640 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1exitModal
1641 (JNIEnv *env, jobject jwindow, jlong windowPtr) {
1642     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1exitModal called.&quot;);
1643     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1644     GLASS_POOL_ENTER;
1645     {
1646         // implementation comes here
1647     }
1648     GLASS_POOL_EXIT;
1649     GLASS_CHECK_EXCEPTION(env);
1650 }
1651 
1652 
1653 /*
1654  * Class:     com_sun_glass_ui_ios_IosWindow
1655  * Method:    _setEnabled
1656  * Signature: (JZ)V
1657  */
1658 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setEnabled
1659 (JNIEnv *env, jobject jwindow, jlong windowPtr, jboolean enabled) {
1660     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setEnabled called.&quot;);
1661     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1662     GLASS_POOL_ENTER;
1663 
1664     GlassWindow *window = (GlassWindow*)jlong_to_ptr(windowPtr);
1665     [window setEnabled:(BOOL)enabled];
1666 
1667     GLASS_POOL_EXIT;
1668     GLASS_CHECK_EXCEPTION(env);
1669 }
1670 
1671 
1672 /*
1673  * Class:     com_sun_glass_ui_ios_IosWindow
1674  * Method:    _requestInput
1675  * Signature: (JLjava/lang/String;IDDDDDDDDDDDDDD)V
1676  */
1677 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1requestInput
1678 (JNIEnv *env, jobject jwin, jlong ptr, jstring text, jint type, jdouble width, jdouble height,
1679     jdouble mxx, jdouble mxy, jdouble mxz, jdouble mxt,
1680     jdouble myx, jdouble myy, jdouble myz, jdouble myt,
1681     jdouble mzx, jdouble mzy, jdouble mzz, jdouble mzt)
1682 {
1683     fprintf(stderr, &quot;We should never be here!\n&quot;);
1684     return;
1685 }
1686 
1687 
1688 /*
1689  * Class:     com_sun_glass_ui_ios_IosWindow
1690  * Method:    _releaseInput
1691  * Signature: (J)V
1692  */
1693 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1releaseInput (JNIEnv *env, jobject jwin, jlong ptr)
1694 {
1695     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1696     GLASS_POOL_ENTER;
1697 
1698     GlassWindow *window = getGlassWindow(env, ptr);
1699     [window releaseInput];
1700 
1701     GLASS_POOL_EXIT;
1702     GLASS_CHECK_EXCEPTION(env);
1703 }
    </pre>
  </body>
</html>
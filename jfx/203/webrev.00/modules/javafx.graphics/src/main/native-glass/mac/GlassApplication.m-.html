<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.graphics/src/main/native-glass/mac/GlassApplication.m</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #import &quot;common.h&quot;
  27 #import &quot;com_sun_glass_ui_mac_MacApplication.h&quot;
  28 #import &quot;com_sun_glass_events_KeyEvent.h&quot;
  29 
  30 
  31 #import &quot;GlassMacros.h&quot;
  32 #import &quot;GlassApplication.h&quot;
  33 #import &quot;GlassHelper.h&quot;
  34 #import &quot;GlassKey.h&quot;
  35 #import &quot;GlassScreen.h&quot;
  36 #import &quot;GlassWindow.h&quot;
  37 #import &quot;GlassTouches.h&quot;
  38 #import &quot;RemoteLayerSupport.h&quot;
  39 
  40 #import &quot;ProcessInfo.h&quot;
  41 #import &lt;Security/SecRequirement.h&gt;
  42 
  43 //#define VERBOSE
  44 #ifndef VERBOSE
  45     #define LOG(MSG, ...)
  46 #else
  47     #define LOG(MSG, ...) GLASS_LOG(MSG, ## __VA_ARGS__);
  48 #endif
  49 
  50 //#define VERBOSE_LOAD
  51 
  52 static BOOL shouldKeepRunningNestedLoop = YES;
  53 static jobject nestedLoopReturnValue = NULL;
  54 static BOOL isFullScreenExitingLoop = NO;
  55 static NSMutableDictionary * keyCodeForCharMap = nil;
  56 static BOOL isEmbedded = NO;
  57 static BOOL disableSyncRendering = NO;
  58 
  59 #ifdef STATIC_BUILD
  60 jint JNICALL JNI_OnLoad_glass(JavaVM *vm, void *reserved)
  61 #else
  62 jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved)
  63 #endif
  64 {
  65     pthread_key_create(&amp;GlassThreadDataKey, NULL);
  66 
  67     memset(&amp;javaIDs, 0, sizeof(javaIDs));
  68     MAIN_JVM = vm;
  69     return JNI_VERSION_1_4;
  70 }
  71 
  72 #pragma mark --- GlassRunnable
  73 
  74 @interface GlassRunnable : NSObject
  75 {
  76     jobject jRunnable;
  77 }
  78 
  79 - (id)initWithRunnable:(jobject)runnable;
  80 - (void)run;
  81 
  82 @end
  83 
  84 @implementation GlassRunnable
  85 
  86 - (id)initWithRunnable:(jobject)runnable
  87 {
  88     self-&gt;jRunnable = runnable;
  89     return self;
  90 }
  91 
  92 - (void)run
  93 {
  94     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
  95     {
  96         assert(pthread_main_np() == 1);
  97         JNIEnv *env = jEnv;
  98         if (env != NULL)
  99         {
 100             (*env)-&gt;CallVoidMethod(env, self-&gt;jRunnable, jRunnableRun);
 101             GLASS_CHECK_EXCEPTION(env);
 102         }
 103 
 104         [self release];
 105     }
 106     [pool drain];
 107 }
 108 
 109 - (void)dealloc
 110 {
 111     assert(pthread_main_np() == 1);
 112     JNIEnv *env = jEnv;
 113     if (env != NULL)
 114     {
 115         (*env)-&gt;DeleteGlobalRef(env, self-&gt;jRunnable);
 116     }
 117     self-&gt;jRunnable = NULL;
 118 
 119     [super dealloc];
 120 }
 121 
 122 @end
 123 
 124 #pragma mark --- GlassApplication
 125 
 126 @implementation GlassApplication
 127 
 128 - (id)initWithEnv:(JNIEnv*)env application:(jobject)application launchable:(jobject)launchable taskbarApplication:(jboolean)isTaskbarApplication classLoader:(jobject)classLoader
 129 {
 130     self = [super init];
 131     if (self != nil)
 132     {
 133         self-&gt;started = NO;
 134         self-&gt;jTaskBarApp = isTaskbarApplication;
 135 
 136         self-&gt;jApplication = (*env)-&gt;NewGlobalRef(env, application);
 137         if (launchable != NULL)
 138         {
 139             self-&gt;jLaunchable = (*env)-&gt;NewGlobalRef(env, launchable);
 140         }
 141 
 142         if (classLoader != NULL)
 143         {
 144             [GlassHelper SetGlassClassLoader:classLoader withEnv:env];
 145         }
 146     }
 147     return self;
 148 }
 149 
 150 #pragma mark --- delegate methods
 151 
 152 - (void)GlassApplicationDidChangeScreenParameters
 153 {
 154     LOG(&quot;GlassApplicationDidChangeScreenParameters&quot;);
 155 
 156     assert(pthread_main_np() == 1);
 157     JNIEnv *env = jEnv;
 158     if (env != NULL)
 159     {
 160         GlassScreenDidChangeScreenParameters(env);
 161     }
 162 }
 163 
 164 - (void)applicationWillFinishLaunching:(NSNotification *)aNotification
 165 {
 166     LOG(&quot;GlassApplication:applicationWillFinishLaunching&quot;);
 167 
 168     GET_MAIN_JENV;
 169     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 170     {
 171         // unblock main thread. Glass is started at this point.
 172         self-&gt;started = YES;
 173 
 174         if (self-&gt;jLaunchable != NULL)
 175         {
 176             jclass runnableClass = [GlassHelper ClassForName:&quot;java.lang.Runnable&quot; withEnv:jEnv];
 177             if ((*env)-&gt;ExceptionCheck(env) == JNI_TRUE)
 178             {
 179                 (*env)-&gt;ExceptionDescribe(env);
 180                 (*env)-&gt;ExceptionClear(env);
 181             }
 182             if (runnableClass) {
 183                 jmethodID runMethod = (*env)-&gt;GetMethodID(env, runnableClass, &quot;run&quot;, &quot;()V&quot;);
 184                 if ((*env)-&gt;ExceptionCheck(env) == JNI_TRUE)
 185                 {
 186                     (*env)-&gt;ExceptionDescribe(env);
 187                     (*env)-&gt;ExceptionClear(env);
 188                 }
 189                 if (runMethod) {
 190                     (*env)-&gt;CallVoidMethod(env, self-&gt;jLaunchable, runMethod);
 191                     if ((*env)-&gt;ExceptionCheck(env) == JNI_TRUE)
 192                     {
 193                         (*env)-&gt;ExceptionDescribe(env);
 194                         (*env)-&gt;ExceptionClear(env);
 195                     }
 196                     else
 197                     {
 198                         [[NSNotificationCenter defaultCenter] addObserver:self
 199                                                                  selector:@selector(GlassApplicationDidChangeScreenParameters)
 200                                                                      name:NSApplicationDidChangeScreenParametersNotification
 201                                                                    object:nil];
 202 
 203                         // localMonitor = [NSEvent addLocalMonitorForEventsMatchingMask: NSRightMouseDownMask
 204                         //                                                      handler:^(NSEvent *incomingEvent) {
 205                         //                                                          NSEvent *result = incomingEvent;
 206                         //                                                          NSWindow *targetWindowForEvent = [incomingEvent window];
 207                         //                                                          LOG(&quot;NSRightMouseDownMask local&quot;);
 208                         //                                                          return result;
 209                         //                                                      }];
 210                         //
 211                         // globalMonitor = [NSEvent addGlobalMonitorForEventsMatchingMask: NSRightMouseDownMask
 212                         //                                                      handler:^(NSEvent *incomingEvent) {
 213                         //                                                          NSEvent *result = incomingEvent;
 214                         //                                                          NSWindow *targetWindowForEvent = [incomingEvent window];
 215                         //                                                          NSWindow *window = [[NSApplication sharedApplication]
 216                         //                                                                       windowWithWindowNumber:[incomingEvent windowNumber]];
 217                         //                                                          NSWindow *appWindow = [[NSApplication sharedApplication] mainWindow];
 218                         //                                                          LOG(&quot;NSRightMouseDownMask global: %p num %d win %p appwin %p&quot;,
 219                         //                                                              targetWindowForEvent, [incomingEvent windowNumber], window,
 220                         //                                                              [[NSApplication sharedApplication] mainWindow]);
 221                         //                                                     }];
 222                     }
 223                 } else {
 224                     NSLog(@&quot;ERROR: Glass could not find run() method\n&quot;);
 225                 }
 226             } else {
 227                 NSLog(@&quot;ERROR: Glass could not find Runnable class\n&quot;);
 228             }
 229         }
 230 
 231         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyWillFinishLaunchingMethod]);
 232     }
 233     [pool drain];
 234     GLASS_CHECK_EXCEPTION(env);
 235 }
 236 
 237 - (void)applicationDidFinishLaunching:(NSNotification *)aNotification
 238 {
 239     LOG(&quot;GlassApplication:applicationDidFinishLaunching&quot;);
 240 
 241     GET_MAIN_JENV;
 242     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 243     {
 244         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyDidFinishLaunchingMethod]);
 245     }
 246     [pool drain];
 247     GLASS_CHECK_EXCEPTION(env);
 248 }
 249 
 250 - (void)applicationWillBecomeActive:(NSNotification *)aNotification
 251 {
 252     LOG(&quot;GlassApplication:applicationWillBecomeActive&quot;);
 253 
 254     GET_MAIN_JENV;
 255     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 256     {
 257         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyWillBecomeActiveMethod]);
 258     }
 259     [pool drain];
 260     GLASS_CHECK_EXCEPTION(env);
 261 }
 262 
 263 - (void)applicationDidBecomeActive:(NSNotification *)aNotification
 264 {
 265     LOG(&quot;GlassApplication:applicationDidBecomeActive&quot;);
 266 
 267     GET_MAIN_JENV;
 268     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 269     {
 270         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyDidBecomeActiveMethod]);
 271     }
 272     [pool drain];
 273     GLASS_CHECK_EXCEPTION(env);
 274 }
 275 
 276 - (void)applicationWillResignActive:(NSNotification *)aNotification
 277 {
 278     LOG(&quot;GlassApplication:applicationWillResignActive&quot;);
 279 
 280     GET_MAIN_JENV;
 281     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 282     {
 283         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyWillResignActiveMethod]);
 284     }
 285     [pool drain];
 286     GLASS_CHECK_EXCEPTION(env);
 287 }
 288 
 289 - (void)applicationDidResignActive:(NSNotification *)aNotification
 290 {
 291     LOG(&quot;GlassApplication:applicationDidResignActive&quot;);
 292 
 293     GET_MAIN_JENV;
 294     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 295     {
 296         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyDidResignActiveMethod]);
 297     }
 298     [pool drain];
 299     GLASS_CHECK_EXCEPTION(env);
 300 }
 301 
 302 - (void)applicationWillHide:(NSNotification *)aNotification
 303 {
 304     LOG(&quot;GlassApplication:applicationWillHide&quot;);
 305 
 306     GET_MAIN_JENV;
 307     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 308     {
 309         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyWillHideMethod]);
 310     }
 311     [pool drain];
 312     GLASS_CHECK_EXCEPTION(env);
 313 }
 314 
 315 - (void)applicationDidHide:(NSNotification *)aNotification
 316 {
 317     LOG(&quot;GlassApplication:applicationDidHide&quot;);
 318 
 319     GET_MAIN_JENV;
 320     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 321     {
 322         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyDidHideMethod]);
 323     }
 324     [pool drain];
 325     GLASS_CHECK_EXCEPTION(env);
 326 }
 327 
 328 - (void)applicationWillUnhide:(NSNotification *)aNotification
 329 {
 330     LOG(&quot;GlassApplication:applicationWillUnhide&quot;);
 331 
 332     GET_MAIN_JENV;
 333     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 334     {
 335         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyWillUnhideMethod]);
 336     }
 337     [pool drain];
 338     GLASS_CHECK_EXCEPTION(env);
 339 }
 340 
 341 - (void)applicationDidUnhide:(NSNotification *)aNotification
 342 {
 343     LOG(&quot;GlassApplication:applicationDidUnhide&quot;);
 344 
 345     GET_MAIN_JENV;
 346     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 347     {
 348         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyDidUnhideMethod]);
 349     }
 350     [pool drain];
 351     GLASS_CHECK_EXCEPTION(env);
 352 }
 353 
 354 - (void)application:(NSApplication *)theApplication openFiles:(NSArray *)filenames
 355 {
 356     LOG(&quot;GlassApplication:application:openFiles&quot;);
 357 
 358     GET_MAIN_JENV;
 359     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 360     {
 361         NSUInteger count = [filenames count];
 362         jclass stringClass = [GlassHelper ClassForName:&quot;java.lang.String&quot; withEnv:env];
 363         if (!stringClass) {
 364             return;
 365         }
 366         jobjectArray files = (*env)-&gt;NewObjectArray(env, (jsize)count, stringClass, NULL);
 367         GLASS_CHECK_EXCEPTION(env);
 368         for (NSUInteger i=0; i&lt;count; i++)
 369         {
 370             NSString *file = [filenames objectAtIndex:i];
 371             if (file != nil)
 372             {
 373                 (*env)-&gt;SetObjectArrayElement(env, files, (jsize)i, (*env)-&gt;NewStringUTF(env, [file UTF8String]));
 374                 GLASS_CHECK_EXCEPTION(env);
 375             }
 376         }
 377         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyOpenFilesMethod], files);
 378     }
 379     [pool drain];
 380     GLASS_CHECK_EXCEPTION(env);
 381 
 382     [theApplication replyToOpenOrPrint:NSApplicationDelegateReplySuccess];
 383 }
 384 
 385 - (BOOL)application:(NSApplication *)theApplication openFile:(NSString *)filename
 386 {
 387     LOG(&quot;GlassApplication:application:openFile&quot;);
 388 
 389     // controlled by Info.plist -NSOpenfileName
 390     // http://developer.apple.com/library/mac/#documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html
 391     [self application:theApplication openFiles:[NSArray arrayWithObject:filename]];
 392 
 393     return YES;
 394 }
 395 
 396 - (BOOL)application:(id)theApplication openFileWithoutUI:(NSString *)filename
 397 {
 398     LOG(&quot;GlassApplication:application:openFileWithoutUI&quot;);
 399 
 400     // programmaticaly called by the client (even though GlassApplication does not currently call it, let&#39;s wire it in just in case)
 401     [self application:theApplication openFiles:[NSArray arrayWithObject:filename]];
 402 
 403     return YES;
 404 }
 405 
 406 - (BOOL)application:(NSApplication *)theApplication openTempFile:(NSString *)filename
 407 {
 408     LOG(&quot;GlassApplication:application:openTempFile&quot;);
 409 
 410     // controlled by Info.plist -NSOpenTempfileName
 411     // http://developer.apple.com/library/mac/#documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html
 412     // NOP
 413 
 414     return YES;
 415 }
 416 
 417 - (BOOL)applicationShouldOpenUntitledFile:(NSApplication *)sender
 418 {
 419     LOG(&quot;GlassApplication:applicationShouldOpenUntitledFile&quot;);
 420 
 421     // don&#39;t want
 422 
 423     return NO;
 424 }
 425 
 426 - (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication *)sender
 427 {
 428     LOG(&quot;GlassApplication:applicationShouldTerminate&quot;);
 429 
 430     GET_MAIN_JENV;
 431     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 432     {
 433         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyWillQuitMethod]);
 434     }
 435     [pool drain];
 436     GLASS_CHECK_EXCEPTION(env);
 437 
 438     return NSTerminateCancel;
 439 }
 440 
 441 
 442 - (BOOL)applicationOpenUntitledFile:(NSApplication *)theApplication
 443 {
 444     LOG(&quot;GlassApplication:applicationOpenUntitledFile&quot;);
 445 
 446     // NOP (should never be called because applicationShouldOpenUntitledFile returns NO)
 447 
 448     return YES;
 449 }
 450 
 451 #pragma mark --- Glass support
 452 
 453 - (void)runLoop:(id)selector
 454 {
 455     LOG(&quot;GlassApplication:runLoop ENTER&quot;);
 456 
 457     NSAutoreleasePool *pool1 = [[NSAutoreleasePool alloc] init];
 458 
 459     jint error = (*jVM)-&gt;AttachCurrentThread(jVM, (void **)&amp;jEnv, NULL);
 460     //jint error = (*jVM)-&gt;AttachCurrentThreadAsDaemon(jVM, (void **)&amp;jEnv, NULL);
 461     if (error == 0)
 462     {
 463         NSAutoreleasePool *pool2 = [[NSAutoreleasePool alloc] init];
 464 
 465         if ([[NSThread currentThread] name] == nil)
 466         {
 467             [[NSThread currentThread] setName:@&quot;Main Cocoa (UI) Thread&quot;];
 468         }
 469 
 470         GlassApplication *glassApp = (GlassApplication *)selector;
 471 
 472         // Load MacApplication class using the glass classloader
 473         jclass cls = [GlassHelper ClassForName:&quot;com.sun.glass.ui.mac.MacApplication&quot; withEnv:jEnv];
 474         if (!cls)
 475         {
 476             NSLog(@&quot;ERROR: can&#39;t find the MacApplication class&quot;);
 477         }
 478         else
 479         {
 480             jmethodID setEventThreadMID = (*jEnv)-&gt;GetMethodID(jEnv, cls, &quot;setEventThread&quot;, &quot;()V&quot;);
 481             if (!setEventThreadMID)
 482             {
 483                 NSLog(@&quot;ERROR: can&#39;t get MacApplication.setEventThread() method ID&quot;);
 484             }
 485             else
 486             {
 487                 (*jEnv)-&gt;CallVoidMethod(jEnv, glassApp-&gt;jApplication, setEventThreadMID);
 488             }
 489         }
 490         GLASS_CHECK_EXCEPTION(jEnv);
 491 
 492         NSBundle *mainBundle = [NSBundle mainBundle];
 493         {
 494             NSString *appName = [mainBundle objectForInfoDictionaryKey:@&quot;CFBundleDisplayName&quot;];
 495 
 496             if (appName == nil) {
 497                 appName = [mainBundle objectForInfoDictionaryKey:@&quot;CFBundleName&quot;];
 498             }
 499 
 500             if (appName) {
 501                 // make the name available to Java side, before Launchable.fnishLaunching callback
 502                 jstring jname = (*jEnv)-&gt;NewStringUTF(jEnv, [appName UTF8String]);
 503                 jmethodID setNameMethod = (*jEnv)-&gt;GetMethodID(jEnv, cls, &quot;setName&quot;, &quot;(Ljava/lang/String;)V&quot;);
 504                 GLASS_CHECK_EXCEPTION(jEnv);
 505                 if (setNameMethod != NULL) {
 506                     (*jEnv)-&gt;CallVoidMethod(jEnv, glassApp-&gt;jApplication, setNameMethod, jname);
 507                 }
 508                 GLASS_CHECK_EXCEPTION(jEnv);
 509             }
 510         }
 511 
 512         // Determine if we&#39;re running embedded (in AWT, SWT, elsewhere)
 513         NSApplication *app = [NSApplication sharedApplication];
 514         isEmbedded = [app isRunning];
 515 
 516         if (!isEmbedded)
 517         {
 518             if (self-&gt;jTaskBarApp == JNI_TRUE)
 519             {
 520                 // move process from background only to full on app with visible Dock icon
 521                 ProcessSerialNumber psn;
 522                 if (GetCurrentProcess(&amp;psn) == noErr)
 523                 {
 524                     TransformProcessType(&amp;psn, kProcessTransformToForegroundApplication);
 525                 }
 526 
 527                 NSString *CFBundleIconFile = [mainBundle objectForInfoDictionaryKey:@&quot;CFBundleIconFile&quot;];
 528                 NSString *iconPath = nil;
 529                 if (CFBundleIconFile != nil)
 530                 {
 531                     iconPath = [mainBundle pathForResource:[CFBundleIconFile stringByDeletingPathExtension] ofType:[CFBundleIconFile pathExtension]];
 532                 }
 533 
 534                 // -Xdock:icon can override CFBundleIconFile (but only if it actually points to a valid icon)
 535                 NSString *property = [NSString stringWithFormat:@&quot;APP_ICON_%d&quot;, [[NSProcessInfo processInfo] processIdentifier]];
 536                 char *path = getenv([property UTF8String]);
 537                 if (path != NULL)
 538                 {
 539                     NSString *overridenPath = [NSString stringWithFormat:@&quot;%s&quot;, path];
 540                     if ([[NSFileManager defaultManager] fileExistsAtPath:overridenPath isDirectory:NO] == YES)
 541                     {
 542                         iconPath = overridenPath;
 543                     }
 544                 }
 545                 if ([[NSFileManager defaultManager] fileExistsAtPath:iconPath isDirectory:NO] == NO)
 546                 {
 547                     // try again using Java generic icon (this icon might go away eventually ?)
 548                     iconPath = [NSString stringWithFormat:@&quot;%s&quot;, &quot;/System/Library/Frameworks/JavaVM.framework/Resources/GenericApp.icns&quot;];
 549                 }
 550 
 551                 NSImage *image = nil;
 552                 {
 553                     if ([[NSFileManager defaultManager] fileExistsAtPath:iconPath isDirectory:NO] == YES)
 554                     {
 555                         image = [[NSImage alloc] initWithContentsOfFile:iconPath];
 556                     }
 557                     if (image == nil)
 558                     {
 559                         // last resort - if still no icon, then ask for an empty standard app icon, which is guranteed to exist
 560                         image = [[NSImage imageNamed:@&quot;NSApplicationIcon&quot;] retain];
 561                     }
 562                 }
 563                 [app setApplicationIconImage:image];
 564                 [image release];
 565 
 566                 // Install a hidden Window menu. This allows the dock icon
 567                 // menu to show the list of open windows (NSWindow instances)
 568                 NSMenu *myMenu = [[NSMenu alloc] initWithTitle:@&quot;Window&quot;];
 569                 [app setWindowsMenu:myMenu];
 570                 [myMenu release];
 571 
 572                 [app setDelegate:self];
 573 
 574                 // [app activateIgnoringOtherApps:YES] won&#39;t activate the menu bar on OS X 10.9, so instead we do this:
 575                 [[NSRunningApplication currentApplication] activateWithOptions:(NSApplicationActivateIgnoringOtherApps | NSApplicationActivateAllWindows)];
 576             }
 577             else
 578             {
 579                 // allow background processes to change the cursor (10.8 only API so we&#39;ll have to dynamically call it if available)
 580                 {
 581                     BOOL yes = YES;
 582                     [GlassHelper InvokeSelectorIfAvailable:@selector(javaSetAllowsCursorSetInBackground:) forClass:[NSCursor class] withArgument:&amp;yes withReturnValue:NULL];
 583                 }
 584 
 585                 // http://developer.apple.com/library/ios/#documentation/DeveloperTools/Conceptual/cross_development/Using/using.html
 586                 if (floor(NSAppKitVersionNumber) &gt;= 1138) // NSAppKitVersionNumber10_7
 587                 {
 588                     // 10.7 or later: move process from background only process to a limited app with active windows,
 589                     // but no Dock icon
 590                     ProcessSerialNumber psn;
 591                     if (GetCurrentProcess(&amp;psn) == noErr)
 592                     {
 593                         TransformProcessType(&amp;psn, 4); // kProcessTransformToUIElementApplication
 594                     }
 595                 }
 596                 else
 597                 {
 598                     // 10.6 or earlier: applets are not officially supported on 10.6 and earlier
 599                     // so they will have limited applet functionality (no active windows)
 600                 }
 601                 [app setDelegate:self];
 602             }
 603 
 604 #if defined(VERBOSE_LOAD)
 605             jclass BooleanClass = [GlassHelper ClassForName:&quot;java.lang.Boolean&quot; withEnv:jEnv];
 606             if (BooleanClass != 0)
 607             {
 608                 jmethodID getBooleanMethod = (*jEnv)-&gt;GetStaticMethodID(jEnv, BooleanClass, &quot;getBoolean&quot;, &quot;(Ljava/lang/String;)Z&quot;);
 609                 if (getBooleanMethod != 0)
 610                 {
 611                     jstring flag = (*jEnv)-&gt;NewStringUTF(jEnv, &quot;glassload.verbose&quot;);
 612                     jboolean verbose = (*jEnv)-&gt;CallStaticBooleanMethod(jEnv, BooleanClass, getBooleanMethod, flag);
 613                     if (verbose == JNI_TRUE)
 614                     {
 615                         printLoadedLibraries(stderr);
 616                         printLoadedFiles(stderr);
 617                     }
 618                 }
 619             }
 620 #endif
 621 
 622             // drain the pool before entering runloop
 623             [pool2 drain];
 624 
 625             // enter runloop, this will not return until terminated
 626             [NSApp run];
 627 
 628             // Abort listerning to global touch input events
 629             [GlassTouches terminate];
 630 
 631             GLASS_CHECK_EXCEPTION(jEnv);
 632 
 633             (*jEnv)-&gt;CallVoidMethod(jEnv, self-&gt;jApplication, javaIDs.MacApplication.notifyApplicationDidTerminate);
 634             GLASS_CHECK_EXCEPTION(jEnv);
 635 
 636             jint err = (*jVM)-&gt;DetachCurrentThread(jVM);
 637             if (err &lt; 0)
 638             {
 639                 NSLog(@&quot;Unable to detach from JVM. Error code: %d\n&quot;, (int)err);
 640             }
 641 
 642             jEnv = NULL;
 643         }
 644         else // event loop is not started
 645         {
 646             if ([NSThread isMainThread] == YES) {
 647                 [glassApp applicationWillFinishLaunching: NULL];
 648             } else {
 649                 [glassApp performSelectorOnMainThread:@selector(applicationWillFinishLaunching:) withObject:NULL waitUntilDone:NO];
 650             }
 651             GLASS_CHECK_EXCEPTION(jEnv);
 652 
 653             [pool2 drain];
 654         }
 655     }
 656     else // attaching to JVM failed
 657     {
 658         NSLog(@&quot;ERROR: Glass could not attach to VM, result:%d\n&quot;, (int)error);
 659     }
 660 
 661     [pool1 drain];
 662 
 663     LOG(&quot;GlassApplication:runLoop EXIT&quot;);
 664 }
 665 
 666 - (BOOL)started
 667 {
 668     return self-&gt;started;
 669 }
 670 
 671 + (jobject)enterNestedEventLoopWithEnv:(JNIEnv*)env
 672 {
 673     jobject ret = NULL;
 674 
 675     NSRunLoop *theRL = [NSRunLoop currentRunLoop];
 676     NSApplication * app = [NSApplication sharedApplication];
 677     shouldKeepRunningNestedLoop = YES;
 678     // Cannot use [NSDate distantFuture] because the period is big the app could hang in a runloop
 679     // if the event came before entering the RL
 680     while (shouldKeepRunningNestedLoop &amp;&amp; [theRL runMode:NSDefaultRunLoopMode
 681                                               beforeDate:[NSDate dateWithTimeIntervalSinceNow:0.010]])
 682     {
 683         NSEvent * event = [app nextEventMatchingMask: 0xFFFFFFFF untilDate:nil inMode:NSDefaultRunLoopMode dequeue:YES];
 684 
 685         if (event != nil) {
 686             [app sendEvent: event];
 687         }
 688     }
 689 
 690     if (nestedLoopReturnValue != NULL) {
 691         ret = (*env)-&gt;NewLocalRef(env, nestedLoopReturnValue);
 692         (*env)-&gt;DeleteGlobalRef(env, nestedLoopReturnValue);
 693         nestedLoopReturnValue = NULL;
 694     }
 695 
 696     shouldKeepRunningNestedLoop = YES;
 697 
 698     return ret;
 699 }
 700 
 701 + (void)leaveNestedEventLoopWithEnv:(JNIEnv*)env retValue:(jobject)retValue
 702 {
 703     if (retValue != NULL) {
 704         nestedLoopReturnValue = (*env)-&gt;NewGlobalRef(env, retValue);
 705     }
 706     shouldKeepRunningNestedLoop = NO;
 707 }
 708 
 709 + (void)enterFullScreenExitingLoop
 710 {
 711     if (isFullScreenExitingLoop) {
 712         return;
 713     }
 714     isFullScreenExitingLoop = YES;
 715     GET_MAIN_JENV;
 716     (*env)-&gt;CallStaticObjectMethod(env, jApplicationClass,
 717             javaIDs.Application.enterNestedEventLoop);
 718     if ((*env)-&gt;ExceptionCheck(env) == JNI_TRUE) {
 719         (*env)-&gt;ExceptionDescribe(env);
 720         (*env)-&gt;ExceptionClear(env);
 721     }
 722     isFullScreenExitingLoop = NO;
 723 }
 724 
 725 + (void)leaveFullScreenExitingLoopIfNeeded
 726 {
 727     if (!isFullScreenExitingLoop) {
 728         return;
 729     }
 730     GET_MAIN_JENV;
 731     (*env)-&gt;CallStaticVoidMethod(env, jApplicationClass,
 732             javaIDs.Application.leaveNestedEventLoop, (jobject)NULL);
 733 }
 734 
 735 + (void)registerKeyEvent:(NSEvent*)event
 736 {
 737     if (!keyCodeForCharMap) {
 738         keyCodeForCharMap = [[NSMutableDictionary alloc] initWithCapacity:100];
 739         // Note: it&#39;s never released, just like, say, the jApplication reference...
 740     }
 741     [keyCodeForCharMap setObject:[NSNumber numberWithUnsignedShort:[event keyCode]] forKey:[event characters]];
 742 }
 743 
 744 + (jint)getKeyCodeForChar:(jchar)c;
 745 {
 746     id v = [keyCodeForCharMap objectForKey:[NSString stringWithCharacters: (UniChar *)&amp;c length:1]];
 747     if (!v) {
 748         return com_sun_glass_events_KeyEvent_VK_UNDEFINED;
 749     } else {
 750         return GetJavaKeyCodeFor([v unsignedShortValue]);
 751     }
 752 }
 753 
 754 + (BOOL)syncRenderingDisabled {
 755     return disableSyncRendering;
 756 }
 757 
 758 @end
 759 
 760 #pragma mark --- JNI
 761 
 762 /*
 763  * Class:     com_sun_glass_ui_mac_MacApplication
 764  * Method:    _initIDs
 765  * Signature: ()V
 766  */
 767 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacApplication__1initIDs
 768 (JNIEnv *env, jclass jClass, jboolean jDisableSyncRendering)
 769 {
 770     LOG(&quot;Java_com_sun_glass_ui_mac_MacApplication__1initIDs&quot;);
 771 
 772     disableSyncRendering = jDisableSyncRendering ? YES : NO;
 773 
 774     jApplicationClass = (*env)-&gt;NewGlobalRef(env, jClass);
 775 
 776     javaIDs.Application.createPixels = (*env)-&gt;GetStaticMethodID(
 777             env, jClass, &quot;createPixels&quot;, &quot;(II[IFF)Lcom/sun/glass/ui/Pixels;&quot;);
 778     if ((*env)-&gt;ExceptionCheck(env)) return;
 779 
 780     javaIDs.Application.getScaleFactor = (*env)-&gt;GetStaticMethodID(
 781             env, jClass, &quot;getScaleFactor&quot;, &quot;(IIII)F&quot;);
 782     if ((*env)-&gt;ExceptionCheck(env)) return;
 783 
 784     javaIDs.Application.reportException = (*env)-&gt;GetStaticMethodID(
 785             env, jClass, &quot;reportException&quot;, &quot;(Ljava/lang/Throwable;)V&quot;);
 786     if ((*env)-&gt;ExceptionCheck(env)) return;
 787 
 788     javaIDs.Application.enterNestedEventLoop = (*env)-&gt;GetStaticMethodID(
 789             env, jClass, &quot;enterNestedEventLoop&quot;, &quot;()Ljava/lang/Object;&quot;);
 790     if ((*env)-&gt;ExceptionCheck(env)) return;
 791 
 792     javaIDs.Application.leaveNestedEventLoop = (*env)-&gt;GetStaticMethodID(
 793             env, jClass, &quot;leaveNestedEventLoop&quot;, &quot;(Ljava/lang/Object;)V&quot;);
 794     if ((*env)-&gt;ExceptionCheck(env)) return;
 795 
 796     javaIDs.MacApplication.notifyApplicationDidTerminate = (*env)-&gt;GetMethodID(
 797             env, jClass, &quot;notifyApplicationDidTerminate&quot;, &quot;()V&quot;);
 798     if ((*env)-&gt;ExceptionCheck(env)) return;
 799 
 800     if (jRunnableRun == NULL)
 801     {
 802         jclass jcls = (*env)-&gt;FindClass(env, &quot;java/lang/Runnable&quot;);
 803         if ((*env)-&gt;ExceptionCheck(env)) return;
 804         jRunnableRun = (*env)-&gt;GetMethodID(env, jcls, &quot;run&quot;, &quot;()V&quot;);
 805         if ((*env)-&gt;ExceptionCheck(env)) return;
 806     }
 807 }
 808 
 809 /*
 810  * Class:     com_sun_glass_ui_mac_MacApplication
 811  * Method:    _runLoop
 812  * Signature: (Ljava/lang/ClassLoader;Ljava/lang/Runnable;Z)V
 813  */
 814 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacApplication__1runLoop
 815 (JNIEnv *env, jobject japplication, jobject classLoader,
 816  jobject jlaunchable, jboolean isTaskbarApplication)
 817 {
 818     LOG(&quot;Java_com_sun_glass_ui_mac_MacApplication__1runLoop&quot;);
 819 
 820     NSAutoreleasePool *glasspool = [[NSAutoreleasePool alloc] init];
 821     {
 822         if ([NSThread isMainThread] == YES)
 823         {
 824             //            fprintf(stderr, &quot;\nWARNING: Glass was started on 1st thread and will block this thread.\nYou most likely do not want to do this - please remove \&quot;-XstartOnFirstThread\&quot; from VM arguments.\n\n&quot;);
 825         }
 826         else
 827         {
 828             if ([[NSThread currentThread] name] == nil)
 829             {
 830                 [[NSThread currentThread] setName:@&quot;Main Java Thread&quot;];
 831             }
 832         }
 833 
 834         GlassApplication *glass = [[GlassApplication alloc] initWithEnv:env application:japplication launchable:jlaunchable taskbarApplication:isTaskbarApplication classLoader:classLoader];
 835         if ([NSThread isMainThread] == YES) {
 836             [glass runLoop: glass];
 837         } else {
 838             [glass performSelectorOnMainThread:@selector(runLoop:) withObject:glass waitUntilDone:[NSThread isMainThread]];
 839 
 840             // wait for Cocoa to enter its UI runloop
 841             while ([glass started] == NO)
 842             {
 843                 LOG(&quot;        waiting for [glass started]&quot;);
 844                 usleep(10000);
 845             }
 846         }
 847 
 848         // at this point Java main thread is allowed to proceed, but Cocoa&#39;s UI thread entered its runloop, so the VM will not quit
 849     }
 850     [glasspool drain]; glasspool=nil;
 851     GLASS_CHECK_EXCEPTION(env);
 852 }
 853 
 854 /*
 855  * Class:     com_sun_glass_ui_mac_MacApplication
 856  * Method:    _finishTerminating
 857  * Signature: ()V
 858  */
 859 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacApplication__1finishTerminating
 860 (JNIEnv *env, jobject japplication)
 861 {
 862     LOG(&quot;Java_com_sun_glass_ui_mac_MacApplication__1finishTerminating&quot;);
 863 
 864     if (isEmbedded) {
 865         return;
 866     }
 867 
 868     NSAutoreleasePool *glasspool = [[NSAutoreleasePool alloc] init];
 869     {
 870         [NSApp stop:nil];
 871         [NSApp hide:nil];
 872 
 873         // wake up the runloop one last time so that it can process the stop:
 874         // request, even if the app is inactive currently
 875         NSTimeInterval dummyEventTimestamp = [NSProcessInfo processInfo].systemUptime;
 876         NSEvent* event = [NSEvent otherEventWithType: NSApplicationDefined
 877                                             location: NSMakePoint(0,0)
 878                                        modifierFlags: 0
 879                                            timestamp: dummyEventTimestamp
 880                                         windowNumber: 0
 881                                              context: nil
 882                                              subtype: 0
 883                                                data1: 0
 884                                                data2: 0];
 885         [NSApp postEvent: event atStart: NO];
 886     }
 887     [glasspool drain]; glasspool=nil;
 888     GLASS_CHECK_EXCEPTION(env);
 889 }
 890 
 891 /*
 892  * Class:     com_sun_glass_ui_mac_MacApplication
 893  * Method:    _enterNestedEventLoopImpl
 894  * Signature: ()Ljava/lang/Object;
 895  */
 896 JNIEXPORT jobject JNICALL Java_com_sun_glass_ui_mac_MacApplication__1enterNestedEventLoopImpl
 897 (JNIEnv *env, jobject japplication)
 898 {
 899     LOG(&quot;Java_com_sun_glass_ui_mac_MacApplication__1enterNestedEventLoopImpl&quot;);
 900 
 901     jobject ret;
 902 
 903     NSAutoreleasePool *glasspool = [[NSAutoreleasePool alloc] init];
 904     {
 905         ret = [GlassApplication enterNestedEventLoopWithEnv:env];
 906     }
 907     [glasspool drain]; glasspool=nil;
 908     GLASS_CHECK_EXCEPTION(env);
 909 
 910     return ret;
 911 }
 912 
 913 /*
 914  * Class:     com_sun_glass_ui_mac_MacApplication
 915  * Method:    _leaveNestedEventLoopImpl
 916  * Signature: (Ljava/lang/Object;)V
 917  */
 918 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacApplication__1leaveNestedEventLoopImpl
 919 (JNIEnv *env, jobject japplication, jobject retValue)
 920 {
 921     LOG(&quot;Java_com_sun_glass_ui_mac_MacApplication__1leaveNestedEventLoopImpl&quot;);
 922 
 923     NSAutoreleasePool *glasspool = [[NSAutoreleasePool alloc] init];
 924     {
 925         [GlassApplication leaveNestedEventLoopWithEnv:env retValue:retValue];
 926     }
 927     [glasspool drain]; glasspool=nil;
 928     GLASS_CHECK_EXCEPTION(env);
 929 }
 930 
 931 /*
 932  * Class:     com_sun_glass_ui_Application
 933  * Method:    _submitForLaterInvocation
 934  * Signature: (Ljava/lang/Runnable;)V
 935  */
 936 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacApplication__1submitForLaterInvocation
 937 (JNIEnv *env, jobject japplication, jobject jRunnable)
 938 {
 939     //LOG(&quot;Java_com_sun_glass_ui_mac_MacApplication_submitForLaterInvocation&quot;);
 940 
 941     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
 942     if (jEnv != NULL)
 943     {
 944         GlassRunnable *runnable = [[GlassRunnable alloc] initWithRunnable:(*env)-&gt;NewGlobalRef(env, jRunnable)];
 945         [runnable performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];
 946     }
 947 }
 948 
 949 /*
 950  * Class:     com_sun_glass_ui_Application
 951  * Method:    _invokeAndWait
 952  * Signature: (Ljava/lang/Runnable;)V
 953  */
 954 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacApplication__1invokeAndWait
 955 (JNIEnv *env, jobject japplication, jobject jRunnable)
 956 {
 957     LOG(&quot;Java_com_sun_glass_ui_mac_MacApplication__1invokeAndWait&quot;);
 958 
 959     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
 960     if (jEnv != NULL)
 961     {
 962         GlassRunnable *runnable = [[GlassRunnable alloc] initWithRunnable:(*env)-&gt;NewGlobalRef(env, jRunnable)];
 963         [runnable performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES];
 964     }
 965 }
 966 
 967 /*
 968  * Class:     com_sun_glass_ui_mac_MacApplication
 969  * Method:    _getRemoteLayerServerName
 970  * Signature: ()Ljava/lang/String;
 971  */
 972 JNIEXPORT jstring JNICALL Java_com_sun_glass_ui_mac_MacApplication__1getRemoteLayerServerName
 973 (JNIEnv *env, jobject japplication)
 974 {
 975     LOG(&quot;Java_com_sun_glass_ui_mac_MacPasteboard__1getName&quot;);
 976 
 977     jstring name = NULL;
 978 
 979     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
 980     GLASS_POOL_ENTER;
 981     {
 982         static mach_port_t remoteLayerServerPort = MACH_PORT_NULL;
 983         if (remoteLayerServerPort == MACH_PORT_NULL)
 984         {
 985             remoteLayerServerPort = RemoteLayerStartServer();
 986         }
 987         NSString *remoteLayerServerName = RemoteLayerGetServerName(remoteLayerServerPort);
 988         name = (*env)-&gt;NewStringUTF(env, [remoteLayerServerName UTF8String]);
 989     }
 990     GLASS_POOL_EXIT;
 991     GLASS_CHECK_EXCEPTION(env);
 992 
 993     return name;
 994 }
 995 
 996 /*
 997  * Class:     com_sun_glass_ui_mac_MacApplication
 998  * Method:    staticScreen_getVideoRefreshPeriod
 999  * Signature: ()D
1000  */
1001 JNIEXPORT jdouble JNICALL
1002 Java_com_sun_glass_ui_mac_MacApplication_staticScreen_1getVideoRefreshPeriod
1003 (JNIEnv *env, jobject jApplication)
1004 {
1005     LOG(&quot;Java_com_sun_glass_ui_mac_MacApplication__1getVideoRefreshPeriod&quot;);
1006 
1007     if (GlassDisplayLink != NULL)
1008     {
1009         double outRefresh = CVDisplayLinkGetActualOutputVideoRefreshPeriod(GlassDisplayLink);
1010         LOG(&quot;CVDisplayLinkGetActualOutputVideoRefreshPeriod: %f&quot;, outRefresh);
1011         return (outRefresh * 1000.0); // to millis
1012     }
1013     else
1014     {
1015         return 0.0;
1016     }
1017 }
1018 
1019 /*
1020  * Class:     com_sun_glass_ui_mac_MacApplication
1021  * Method:    staticScreen_getScreens
1022  * Signature: ()[Lcom/sun/glass/ui/Screen;
1023  */
1024 JNIEXPORT jobjectArray JNICALL Java_com_sun_glass_ui_mac_MacApplication_staticScreen_1getScreens
1025 (JNIEnv *env, jobject jApplication)
1026 {
1027     LOG(&quot;Java_com_sun_glass_ui_mac_MacApplication__1getScreens&quot;);
1028 
1029     jobjectArray screenArray = nil;
1030 
1031     GLASS_POOL_ENTER;
1032     {
1033         screenArray = createJavaScreens(env);
1034     }
1035     GLASS_POOL_EXIT;
1036     GLASS_CHECK_EXCEPTION(env);
1037 
1038     return screenArray;
1039 }
1040 
1041 
1042 /*
1043  * Class:     com_sun_glass_ui_mac_MacApplication
1044  * Method:    _supportsSystemMenu
1045  * Signature: ()Z;
1046  */
1047 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_mac_MacApplication__1supportsSystemMenu
1048 (JNIEnv *env, jobject japplication)
1049 {
1050     return !isEmbedded;
1051 }
1052 
1053 /*
1054  * Class:     com_sun_glass_ui_mac_MacApplication
1055  * Method:    _hide
1056  * Signature: ()V;
1057  */
1058 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacApplication__1hide
1059 (JNIEnv *env, jobject japplication)
1060 {
1061     [NSApp hide:NSApp];
1062 }
1063 
1064 /*
1065  * Class:     com_sun_glass_ui_mac_MacApplication
1066  * Method:    _hideOtherApplications
1067  * Signature: ()V;
1068  */
1069 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacApplication__1hideOtherApplications
1070 (JNIEnv *env, jobject japplication)
1071 {
1072     [NSApp hideOtherApplications:NSApp];
1073 }
1074 
1075 /*
1076  * Class:     com_sun_glass_ui_mac_MacApplication
1077  * Method:    _unhideAllApplications
1078  * Signature: ()V;
1079  */
1080 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacApplication__1unhideAllApplications
1081 (JNIEnv *env, jobject japplication)
1082 {
1083     [NSApp unhideAllApplications:NSApp];
1084 }
1085 
1086 /*
1087  * Class:     com_sun_glass_ui_mac_MacApplication
1088  * Method:    _getDataDirectory
1089  * Signature: ()Ljava/lang/String;
1090  */
1091 JNIEXPORT jstring JNICALL Java_com_sun_glass_ui_mac_MacApplication__1getDataDirectory
1092 (JNIEnv * env, jobject japplication)
1093 {
1094     jstring string = nil;
1095 
1096     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1097     GLASS_POOL_ENTER;
1098     {
1099     NSArray *paths = NSSearchPathForDirectoriesInDomains(NSApplicationSupportDirectory, NSUserDomainMask, YES);
1100     if (paths &amp;&amp; [paths count] &gt; 0) {
1101         string = (*env)-&gt;NewStringUTF(jEnv, [[paths lastObject] UTF8String]);
1102     }
1103     }
1104     GLASS_POOL_EXIT;
1105     GLASS_CHECK_EXCEPTION(env);
1106 
1107     return string;
1108 }
1109 
1110 /*
1111  * Class:     com_sun_glass_ui_mac_MacApplication
1112  * Method:    _getMacKey
1113  * Signature: (I)I
1114  */
1115 JNIEXPORT jint JNICALL Java_com_sun_glass_ui_mac_MacApplication__1getMacKey
1116 (JNIEnv *env, jclass jClass, jint code)
1117 {
1118     unsigned short macCode = 0;
1119     GetMacKey(code, &amp;macCode);
1120     return (macCode &amp; 0xFFFF);
1121 }
    </pre>
  </body>
</html>
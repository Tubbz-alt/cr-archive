<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.graphics/src/main/java/com/sun/javafx/application/PlatformImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.javafx.application;
 27 
 28 import static com.sun.javafx.FXPermissions.CREATE_TRANSPARENT_WINDOW_PERMISSION;
 29 import com.sun.javafx.PlatformUtil;
 30 import com.sun.javafx.css.StyleManager;
 31 import com.sun.javafx.tk.TKListener;
 32 import com.sun.javafx.tk.TKStage;
 33 import com.sun.javafx.tk.Toolkit;
 34 import com.sun.javafx.util.ModuleHelper;
 35 
 36 import java.lang.reflect.InvocationTargetException;
 37 import java.lang.reflect.Method;
 38 import java.security.AccessControlContext;
 39 import java.security.AccessController;
 40 import java.security.PrivilegedAction;
 41 import java.util.ArrayList;
 42 import java.util.HashMap;
 43 import java.util.List;
 44 import java.util.Map;
 45 import java.util.Optional;
 46 import java.util.Set;
 47 import java.util.concurrent.CopyOnWriteArraySet;
 48 import java.util.concurrent.CountDownLatch;
 49 import java.util.concurrent.atomic.AtomicBoolean;
 50 import java.util.concurrent.atomic.AtomicInteger;
 51 import java.util.function.Predicate;
 52 
 53 import javafx.application.Application;
 54 import javafx.application.ConditionalFeature;
 55 import javafx.beans.property.BooleanProperty;
 56 import javafx.beans.property.SimpleBooleanProperty;
 57 import javafx.scene.Scene;
 58 import javafx.util.FXPermission;
 59 
 60 public class PlatformImpl {
 61 
 62     private static AtomicBoolean initialized = new AtomicBoolean(false);
 63     private static AtomicBoolean platformExit = new AtomicBoolean(false);
 64     private static AtomicBoolean toolkitExit = new AtomicBoolean(false);
 65     private static CountDownLatch startupLatch = new CountDownLatch(1);
 66     private static AtomicBoolean listenersRegistered = new AtomicBoolean(false);
 67     private static TKListener toolkitListener = null;
 68     private static volatile boolean implicitExit = true;
 69     private static boolean taskbarApplication = true;
 70     private static boolean contextual2DNavigation;
 71     private static AtomicInteger pendingRunnables = new AtomicInteger(0);
 72     private static AtomicInteger numWindows = new AtomicInteger(0);
 73     private static volatile boolean firstWindowShown = false;
 74     private static volatile boolean lastWindowClosed = false;
 75     private static AtomicBoolean reallyIdle = new AtomicBoolean(false);
 76     private static Set&lt;FinishListener&gt; finishListeners =
 77             new CopyOnWriteArraySet&lt;FinishListener&gt;();
 78     private final static Object runLaterLock = new Object();
 79     private static Boolean isGraphicsSupported;
 80     private static Boolean isControlsSupported;
 81     private static Boolean isMediaSupported;
 82     private static Boolean isWebSupported;
 83     private static Boolean isSWTSupported;
 84     private static Boolean isSwingSupported;
 85     private static Boolean isFXMLSupported;
 86     private static Boolean hasTwoLevelFocus;
 87     private static Boolean hasVirtualKeyboard;
 88     private static Boolean hasTouch;
 89     private static Boolean hasMultiTouch;
 90     private static Boolean hasPointer;
 91     private static boolean isThreadMerged = false;
 92     private static String applicationType = &quot;&quot;;
 93     private static BooleanProperty accessibilityActive = new SimpleBooleanProperty();
 94     private static CountDownLatch allNestedLoopsExitedLatch = new CountDownLatch(1);
 95 
 96     private static final boolean verbose
 97             = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt;
 98                 Boolean.getBoolean(&quot;javafx.verbose&quot;));
 99 
100     private static final boolean DEBUG
101             = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) ()
102                     -&gt; Boolean.getBoolean(&quot;com.sun.javafx.application.debug&quot;));
103 
104     // Internal permission used by FXCanvas (SWT interop)
105     private static final FXPermission FXCANVAS_PERMISSION =
106             new FXPermission(&quot;accessFXCanvasInternals&quot;);
107 
108     /**
109      * Set a flag indicating whether this application should show up in the
110      * task bar. The default value is true.
111      *
112      * @param taskbarApplication the new value of this attribute
113      */
114     public static void setTaskbarApplication(boolean taskbarApplication) {
115         PlatformImpl.taskbarApplication = taskbarApplication;
116     }
117 
118     /**
119      * Returns the current value of the taskBarApplication flag.
120      *
121      * @return the current state of the flag.
122      */
123     public static boolean isTaskbarApplication() {
124         return taskbarApplication;
125     }
126 
127     /**
128      * Sets the name of the this application based on the Application class.
129      * This method is called by the launcher, and is not
130      * called from the FX Application Thread, so we need to do it in a runLater.
131      * We do not need to wait for the result since it will complete before the
132      * Application start() method is called regardless.
133      *
134      * @param appClass the Application class.
135      */
136     public static void setApplicationName(final Class appClass) {
137         runLater(() -&gt; com.sun.glass.ui.Application.GetApplication().setName(appClass.getName()));
138     }
139 
140     /**
141      * Return whether or not focus navigation between controls is context-
142      * sensitive.
143      * @return true if the context-sensitive algorithm for focus navigation is
144      * used
145      */
146      public static boolean isContextual2DNavigation() {
147          return contextual2DNavigation;
148      }
149 
150     /**
151      * This method is invoked typically on the main thread. At this point,
152      * the JavaFX Application Thread has not been started. Any attempt
153      * to call startup more than once results in all subsequent calls turning into
154      * nothing more than a runLater call with the provided Runnable being called.
155      * @param r
156      */
157     public static void startup(final Runnable r) {
158         startup(r, false);
159     }
160 
161     /**
162      * This method is invoked typically on the main thread. At this point,
163      * the JavaFX Application Thread has not been started. If preventDuplicateCalls
164      * is true, calling this method multiple times will result in an
165      * IllegalStateException. If it is false, calling this method multiple times
166      * will result in all subsequent calls turning into
167      * nothing more than a runLater call with the provided Runnable being called.
168      * @param r
169      * @param preventDuplicateCalls
170      */
171     public static void startup(final Runnable r, boolean preventDuplicateCalls) {
172 
173         // NOTE: if we ever support re-launching an application and/or
174         // launching a second application in the same VM/classloader
175         // this will need to be changed.
176         if (platformExit.get()) {
177             throw new IllegalStateException(&quot;Platform.exit has been called&quot;);
178         }
179 
180         if (initialized.getAndSet(true)) {
181             if (preventDuplicateCalls) {
182                 throw new IllegalStateException(&quot;Toolkit already initialized&quot;);
183             }
184 
185             // If we&#39;ve already initialized, just put the runnable on the queue.
186             runLater(r);
187             return;
188         }
189 
190         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
191             applicationType = System.getProperty(&quot;com.sun.javafx.application.type&quot;);
192             if (applicationType == null) applicationType = &quot;&quot;;
193 
194             contextual2DNavigation = Boolean.getBoolean(
195                     &quot;com.sun.javafx.isContextual2DNavigation&quot;);
196             String s = System.getProperty(&quot;com.sun.javafx.twoLevelFocus&quot;);
197             if (s != null) {
198                 hasTwoLevelFocus = Boolean.valueOf(s);
199             }
200             s = System.getProperty(&quot;com.sun.javafx.virtualKeyboard&quot;);
201             if (s != null) {
202                 if (s.equalsIgnoreCase(&quot;none&quot;)) {
203                     hasVirtualKeyboard = false;
204                 } else if (s.equalsIgnoreCase(&quot;javafx&quot;)) {
205                     hasVirtualKeyboard = true;
206                 } else if (s.equalsIgnoreCase(&quot;native&quot;)) {
207                     hasVirtualKeyboard = true;
208                 }
209             }
210             s = System.getProperty(&quot;com.sun.javafx.touch&quot;);
211             if (s != null) {
212                 hasTouch = Boolean.valueOf(s);
213             }
214             s = System.getProperty(&quot;com.sun.javafx.multiTouch&quot;);
215             if (s != null) {
216                 hasMultiTouch = Boolean.valueOf(s);
217             }
218             s = System.getProperty(&quot;com.sun.javafx.pointer&quot;);
219             if (s != null) {
220                 hasPointer = Boolean.valueOf(s);
221             }
222             s = System.getProperty(&quot;javafx.embed.singleThread&quot;);
223             if (s != null) {
224                 isThreadMerged = Boolean.valueOf(s);
225                 if (isThreadMerged &amp;&amp; !isSupported(ConditionalFeature.SWING)) {
226                     isThreadMerged = false;
227                     if (verbose) {
228                         System.err.println(
229                         &quot;WARNING: javafx.embed.singleThread ignored (javafx.swing module not found)&quot;);
230                     }
231                 }
232             }
233             return null;
234         });
235 
236         if (DEBUG) {
237             System.err.println(&quot;PlatformImpl::startup : applicationType = &quot;
238                     + applicationType);
239         }
240         if (&quot;FXCanvas&quot;.equals(applicationType)) {
241             initFXCanvas();
242         }
243 
244         if (!taskbarApplication) {
245             AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
246                 System.setProperty(&quot;glass.taskbarApplication&quot;, &quot;false&quot;);
247                 return null;
248             });
249         }
250 
251         // Create Toolkit listener and register it with the Toolkit.
252         // Call notifyFinishListeners when we get notified.
253         toolkitListener = new TKListener() {
254             @Override public void changedTopLevelWindows(List&lt;TKStage&gt; windows) {
255                 numWindows.set(windows.size());
256                 checkIdle();
257             }
258 
259             @Override
260             public void exitedLastNestedLoop() {
261                 if (platformExit.get()) {
262                     allNestedLoopsExitedLatch.countDown();
263                 }
264                 checkIdle();
265             }
266         };
267         Toolkit.getToolkit().addTkListener(toolkitListener);
268 
269         Toolkit.getToolkit().startup(() -&gt; {
270             startupLatch.countDown();
271             r.run();
272         });
273 
274         //Initialize the thread merging mechanism
275         if (isThreadMerged) {
276             installFwEventQueue();
277         }
278     }
279 
280     // Pass certain system properties to glass via the device details Map
281     private static void initDeviceDetailsFXCanvas() {
282         // Read the javafx.embed.eventProc system property and store
283         // it in an entry in the glass Application device details map
284         final String eventProcProperty = &quot;javafx.embed.eventProc&quot;;
285         final long eventProc = AccessController.doPrivileged((PrivilegedAction&lt;Long&gt;) () -&gt;
286                 Long.getLong(eventProcProperty, 0));
287         if (eventProc != 0L) {
288             // Set the value for the javafx.embed.eventProc
289             // key in the glass Application map
290             Map map = com.sun.glass.ui.Application.getDeviceDetails();
291             if (map == null) {
292                 map = new HashMap();
293                 com.sun.glass.ui.Application.setDeviceDetails(map);
294             }
295             if (map.get(eventProcProperty) == null) {
296                 map.put(eventProcProperty, eventProc);
297             }
298         }
299     }
300 
301     // Add the necessary qualified exports to the calling module
302     private static void addExportsToFXCanvas(Class&lt;?&gt; fxCanvasClass) {
303         final String[] swtNeededPackages = {
304             &quot;com.sun.glass.ui&quot;,
305             &quot;com.sun.javafx.cursor&quot;,
306             &quot;com.sun.javafx.embed&quot;,
307             &quot;com.sun.javafx.stage&quot;,
308             &quot;com.sun.javafx.tk&quot;
309         };
310 
311         if (DEBUG) {
312             System.err.println(&quot;addExportsToFXCanvas: class = &quot; + fxCanvasClass);
313         }
314         Object thisModule = ModuleHelper.getModule(PlatformImpl.class);
315         Object javafxSwtModule = ModuleHelper.getModule(fxCanvasClass);
316         for (String pkg : swtNeededPackages) {
317             if (DEBUG) {
318                 System.err.println(&quot;add export of &quot; + pkg + &quot; from &quot;
319                         + thisModule + &quot; to &quot; + javafxSwtModule);
320             }
321             ModuleHelper.addExports(thisModule, pkg, javafxSwtModule);
322         }
323     }
324 
325     // FXCanvas-specific initialization
326     private static void initFXCanvas() {
327         // Verify that we have the appropriate permission
328         final SecurityManager sm = System.getSecurityManager();
329         if (sm != null) {
330             try {
331                 sm.checkPermission(FXCANVAS_PERMISSION);
332             } catch (SecurityException ex) {
333                 System.err.println(&quot;FXCanvas: no permission to access JavaFX internals&quot;);
334                 ex.printStackTrace();
335                 return;
336             }
337         }
338 
339         // Find the calling class, ignoring any stack frames from FX application classes
340         Predicate&lt;StackWalker.StackFrame&gt; classFilter = f -&gt;
341                 !f.getClassName().startsWith(&quot;javafx.application.&quot;)
342                         &amp;&amp; !f.getClassName().startsWith(&quot;com.sun.javafx.application.&quot;);
343 
344         final StackWalker walker = AccessController.doPrivileged((PrivilegedAction&lt;StackWalker&gt;) () -&gt;
345                 StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE));
346         Optional&lt;StackWalker.StackFrame&gt; frame = walker.walk(
347                 s -&gt; s.filter(classFilter).findFirst());
348 
349         if (frame.isPresent()) {
350             Class&lt;?&gt; caller = frame.get().getDeclaringClass();
351             if (DEBUG) {
352                 System.err.println(&quot;callerClassName = &quot; + caller);
353             }
354 
355             // Verify that the caller is javafx.embed.swt.FXCanvas
356             if (&quot;javafx.embed.swt.FXCanvas&quot;.equals(caller.getName())) {
357                 initDeviceDetailsFXCanvas();
358                 addExportsToFXCanvas(caller);
359             }
360         }
361     }
362 
363     private static void installFwEventQueue() {
364         invokeSwingFXUtilsMethod(&quot;installFwEventQueue&quot;);
365     }
366 
367     private static void removeFwEventQueue() {
368         invokeSwingFXUtilsMethod(&quot;removeFwEventQueue&quot;);
369     }
370 
371     private static void invokeSwingFXUtilsMethod(final String methodName) {
372         //Use reflection in case we are running compact profile
373         try {
374             Class swingFXUtilsClass = Class.forName(&quot;com.sun.javafx.embed.swing.SwingFXUtilsImpl&quot;);
375             Method installFwEventQueue = swingFXUtilsClass.getDeclaredMethod(methodName);
376 
377             waitForStart();
378             installFwEventQueue.invoke(null);
379 
380         } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException e) {
381             throw new RuntimeException(&quot;Property javafx.embed.singleThread is not supported&quot;);
382         } catch (InvocationTargetException e) {
383             throw new RuntimeException(e);
384         }
385     }
386 
387     private static void waitForStart() {
388         // If the startup runnable has not yet been called, then wait it.
389         // Note that we check the count before calling await() to avoid
390         // the try/catch which is unnecessary after startup.
391         if (startupLatch.getCount() &gt; 0) {
392             try {
393                 startupLatch.await();
394             } catch (InterruptedException ex) {
395                 ex.printStackTrace();
396             }
397         }
398     }
399 
400     public static boolean isFxApplicationThread() {
401         return Toolkit.getToolkit().isFxUserThread();
402     }
403 
404     public static void runLater(final Runnable r) {
405         runLater(r, false);
406     }
407 
408     private static void runLater(final Runnable r, boolean exiting) {
409         if (!initialized.get()) {
410             throw new IllegalStateException(&quot;Toolkit not initialized&quot;);
411         }
412 
413         pendingRunnables.incrementAndGet();
414         waitForStart();
415 
416         synchronized (runLaterLock) {
417             if (!exiting &amp;&amp; toolkitExit.get()) {
418                 // Don&#39;t schedule a runnable after we have exited the toolkit
419                 pendingRunnables.decrementAndGet();
420                 return;
421             }
422 
423             final AccessControlContext acc = AccessController.getContext();
424             // Don&#39;t catch exceptions, they are handled by Toolkit.defer()
425             Toolkit.getToolkit().defer(() -&gt; {
426                 try {
427                     AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
428                         r.run();
429                         return null;
430                     }, acc);
431                 } finally {
432                     pendingRunnables.decrementAndGet();
433                     checkIdle();
434                 }
435             });
436         }
437     }
438 
439     public static void runAndWait(final Runnable r) {
440         runAndWait(r, false);
441     }
442 
443     private static void runAndWait(final Runnable r, boolean exiting) {
444         if (isFxApplicationThread()) {
445              try {
446                  r.run();
447              } catch (Throwable t) {
448                  System.err.println(&quot;Exception in runnable&quot;);
449                  t.printStackTrace();
450              }
451         } else {
452             final CountDownLatch doneLatch = new CountDownLatch(1);
453             runLater(() -&gt; {
454                 try {
455                     r.run();
456                 } finally {
457                     doneLatch.countDown();
458                 }
459             }, exiting);
460 
461             if (!exiting &amp;&amp; toolkitExit.get()) {
462                 throw new IllegalStateException(&quot;Toolkit has exited&quot;);
463             }
464 
465             try {
466                 doneLatch.await();
467             } catch (InterruptedException ex) {
468                 ex.printStackTrace();
469             }
470         }
471     }
472 
473     public static void setImplicitExit(boolean implicitExit) {
474         PlatformImpl.implicitExit = implicitExit;
475         checkIdle();
476     }
477 
478     public static boolean isImplicitExit() {
479         return implicitExit;
480     }
481 
482     public static void addListener(FinishListener l) {
483         listenersRegistered.set(true);
484         finishListeners.add(l);
485     }
486 
487     public static void removeListener(FinishListener l) {
488         finishListeners.remove(l);
489         listenersRegistered.set(!finishListeners.isEmpty());
490         if (!listenersRegistered.get()) {
491             checkIdle();
492         }
493     }
494 
495     private static void notifyFinishListeners(boolean exitCalled) {
496         // Notify listeners if any are registered, else exit directly
497         if (listenersRegistered.get()) {
498             for (FinishListener l : finishListeners) {
499                 if (exitCalled) {
500                     l.exitCalled();
501                 } else {
502                     l.idle(implicitExit);
503                 }
504             }
505         } else if (implicitExit || platformExit.get()) {
506             tkExit();
507         }
508     }
509 
510     // Check for idle, meaning the last top-level window has been closed and
511     // there are no pending Runnables waiting to be run.
512     private static void checkIdle() {
513         // If we aren&#39;t initialized yet, then this method is a no-op.
514         if (!initialized.get()) {
515             return;
516         }
517 
518         if (!isFxApplicationThread()) {
519             // Add a dummy runnable to the runLater queue, which will then call
520             // checkIdle() on the FX application thread.
521             runLater(() -&gt; {
522             });
523             return;
524         }
525 
526         boolean doNotify = false;
527 
528         synchronized (PlatformImpl.class) {
529             int numWin = numWindows.get();
530             if (numWin &gt; 0) {
531                 firstWindowShown = true;
532                 lastWindowClosed = false;
533                 reallyIdle.set(false);
534             } else if (numWin == 0 &amp;&amp; firstWindowShown) {
535                 lastWindowClosed = true;
536             }
537 
538             // In case there is an event in process, allow for it to show
539             // another window. If no new window is shown before all pending
540             // runnables (including this one) are done and there is no running
541             // nested loops, then we will shutdown.
542             if (lastWindowClosed &amp;&amp; pendingRunnables.get() == 0
543                     &amp;&amp; (toolkitExit.get() || !Toolkit.getToolkit().isNestedLoopRunning())) {
544 //                System.err.println(&quot;Last window closed and no pending runnables&quot;);
545                 if (reallyIdle.getAndSet(true)) {
546 //                    System.err.println(&quot;Really idle now&quot;);
547                     doNotify = true;
548                     lastWindowClosed = false;
549                 } else {
550 //                    System.err.println(&quot;Queuing up a dummy idle check runnable&quot;);
551                     runLater(() -&gt; {
552 //                            System.err.println(&quot;Dummy runnable&quot;);
553                     });
554                 }
555             }
556         }
557 
558         if (doNotify) {
559             notifyFinishListeners(false);
560         }
561     }
562 
563     // package scope method for testing
564     private static final CountDownLatch platformExitLatch = new CountDownLatch(1);
565     static CountDownLatch test_getPlatformExitLatch() {
566         return platformExitLatch;
567     }
568 
569     public static void tkExit() {
570         if (toolkitExit.getAndSet(true)) {
571             return;
572         }
573 
574         if (initialized.get()) {
575             if (platformExit.get()) {
576                 PlatformImpl.runAndWait(() -&gt; {
577                     if (Toolkit.getToolkit().isNestedLoopRunning()) {
578                         Toolkit.getToolkit().exitAllNestedEventLoops();
579                     } else {
580                         allNestedLoopsExitedLatch.countDown();
581                     }
582                 }, true);
583 
584                 try {
585                     allNestedLoopsExitedLatch.await();
586                 } catch (InterruptedException e) {
587                     throw new RuntimeException(&quot;Could not exit all nested event loops&quot;);
588                 }
589             }
590 
591             // Always call toolkit exit on FX app thread
592 //            System.err.println(&quot;PlatformImpl.tkExit: scheduling Toolkit.exit&quot;);
593             PlatformImpl.runAndWait(() -&gt; {
594 //                System.err.println(&quot;PlatformImpl.tkExit: calling Toolkit.exit&quot;);
595                 Toolkit.getToolkit().exit();
596             }, true);
597 
598             if (isThreadMerged) {
599                 removeFwEventQueue();
600             }
601 
602             Toolkit.getToolkit().removeTkListener(toolkitListener);
603             toolkitListener = null;
604             platformExitLatch.countDown();
605         }
606     }
607 
608     public static BooleanProperty accessibilityActiveProperty() {
609         return accessibilityActive;
610     }
611 
612     public static void exit() {
613         platformExit.set(true);
614         notifyFinishListeners(true);
615     }
616 
617     private static Boolean checkForClass(String classname) {
618         try {
619             Class.forName(classname, false, PlatformImpl.class.getClassLoader());
620             return Boolean.TRUE;
621         } catch (ClassNotFoundException cnfe) {
622             return Boolean.FALSE;
623         }
624     }
625 
626     public static boolean isSupported(ConditionalFeature feature) {
627         final boolean supported = isSupportedImpl(feature);
628         if (supported &amp;&amp; (feature == ConditionalFeature.TRANSPARENT_WINDOW)) {
629             // some features require the application to have the corresponding
630             // permissions, if the application doesn&#39;t have them, the platform
631             // will behave as if the feature wasn&#39;t supported
632             final SecurityManager securityManager =
633                     System.getSecurityManager();
634             if (securityManager != null) {
635                 try {
636                     securityManager.checkPermission(CREATE_TRANSPARENT_WINDOW_PERMISSION);
637                 } catch (final SecurityException e) {
638                     return false;
639                 }
640             }
641 
642             return true;
643         }
644 
645         return supported;
646    }
647 
648     public static interface FinishListener {
649         public void idle(boolean implicitExit);
650         public void exitCalled();
651     }
652 
653     /**
654      * Set the platform user agent stylesheet to the default.
655      */
656     public static void setDefaultPlatformUserAgentStylesheet() {
657         setPlatformUserAgentStylesheet(Application.STYLESHEET_MODENA);
658     }
659 
660     private static boolean isModena = false;
661     private static boolean isCaspian = false;
662 
663     /**
664      * Current Platform User Agent Stylesheet is Modena.
665      *
666      * Note: Please think hard before using this as we really want to avoid special cases in the platform for specific
667      * themes. This was added to allow tempory work arounds in the platform for bugs.
668      *
669      * @return true if using modena stylesheet
670      */
671     public static boolean isModena() {
672         return isModena;
673     }
674 
675     /**
676      * Current Platform User Agent Stylesheet is Caspian.
677      *
678      * Note: Please think hard before using this as we really want to avoid special cases in the platform for specific
679      * themes. This was added to allow tempory work arounds in the platform for bugs.
680      *
681      * @return true if using caspian stylesheet
682      */
683     public static boolean isCaspian() {
684         return isCaspian;
685     }
686 
687     /**
688      * Set the platform user agent stylesheet to the given URL. This method has special handling for platform theme
689      * name constants.
690      */
691     public static void setPlatformUserAgentStylesheet(final String stylesheetUrl) {
692         if (isFxApplicationThread()) {
693             _setPlatformUserAgentStylesheet(stylesheetUrl);
694         } else {
695             runLater(() -&gt; _setPlatformUserAgentStylesheet(stylesheetUrl));
696         }
697     }
698 
699     private static String accessibilityTheme;
700     public static boolean setAccessibilityTheme(String platformTheme) {
701 
702         if (accessibilityTheme != null) {
703             StyleManager.getInstance().removeUserAgentStylesheet(accessibilityTheme);
704             accessibilityTheme = null;
705         }
706 
707         _setAccessibilityTheme(platformTheme);
708 
709         if (accessibilityTheme != null) {
710             StyleManager.getInstance().addUserAgentStylesheet(accessibilityTheme);
711             return true;
712         }
713         return false;
714 
715     }
716 
717     private static void _setAccessibilityTheme(String platformTheme) {
718 
719         // check to see if there is an override to enable a high-contrast theme
720         final String userTheme = AccessController.doPrivileged(
721                 (PrivilegedAction&lt;String&gt;) () -&gt; System.getProperty(&quot;com.sun.javafx.highContrastTheme&quot;));
722 
723         if (isCaspian()) {
724             if (platformTheme != null || userTheme != null) {
725                 // caspian has only one high contrast theme, use it regardless of the user or platform theme.
726                 accessibilityTheme = &quot;com/sun/javafx/scene/control/skin/caspian/highcontrast.css&quot;;
727             }
728         } else if (isModena()) {
729             // User-defined property takes precedence
730             if (userTheme != null) {
731                 switch (userTheme.toUpperCase()) {
732                     case &quot;BLACKONWHITE&quot;:
733                         accessibilityTheme = &quot;com/sun/javafx/scene/control/skin/modena/blackOnWhite.css&quot;;
734                         break;
735                     case &quot;WHITEONBLACK&quot;:
736                         accessibilityTheme = &quot;com/sun/javafx/scene/control/skin/modena/whiteOnBlack.css&quot;;
737                         break;
738                     case &quot;YELLOWONBLACK&quot;:
739                         accessibilityTheme = &quot;com/sun/javafx/scene/control/skin/modena/yellowOnBlack.css&quot;;
740                         break;
741                     default:
742                 }
743             } else {
744                 if (platformTheme != null) {
745                     // The following names are Platform specific (Windows 7 and 8)
746                     switch (platformTheme) {
747                         case &quot;High Contrast White&quot;:
748                             accessibilityTheme = &quot;com/sun/javafx/scene/control/skin/modena/blackOnWhite.css&quot;;
749                             break;
750                         case &quot;High Contrast Black&quot;:
751                             accessibilityTheme = &quot;com/sun/javafx/scene/control/skin/modena/whiteOnBlack.css&quot;;
752                             break;
753                         case &quot;High Contrast #1&quot;:
754                         case &quot;High Contrast #2&quot;: //TODO #2 should be green on black
755                             accessibilityTheme = &quot;com/sun/javafx/scene/control/skin/modena/yellowOnBlack.css&quot;;
756                             break;
757                         default:
758                     }
759                 }
760             }
761         }
762     }
763 
764     private static void _setPlatformUserAgentStylesheet(String stylesheetUrl) {
765         isModena = isCaspian = false;
766         // check for command line override
767         final String overrideStylesheetUrl = AccessController.doPrivileged(
768                 (PrivilegedAction&lt;String&gt;) () -&gt; System.getProperty(&quot;javafx.userAgentStylesheetUrl&quot;));
769 
770         if (overrideStylesheetUrl != null) {
771             stylesheetUrl = overrideStylesheetUrl;
772         }
773 
774         final List&lt;String&gt; uaStylesheets = new ArrayList&lt;&gt;();
775 
776         // check for named theme constants for modena and caspian
777         if (Application.STYLESHEET_CASPIAN.equalsIgnoreCase(stylesheetUrl)) {
778             isCaspian = true;
779 
780             uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/caspian/caspian.css&quot;);
781 
782             if (isSupported(ConditionalFeature.INPUT_TOUCH)) {
783                 uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/caspian/embedded.css&quot;);
784                 if (com.sun.javafx.util.Utils.isQVGAScreen()) {
785                     uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/caspian/embedded-qvga.css&quot;);
786                 }
787                 if (PlatformUtil.isAndroid()) {
788                     uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/caspian/android.css&quot;);
789                 }
790                 if (PlatformUtil.isIOS()) {
791                     uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/caspian/ios.css&quot;);
792                 }
793             }
794 
795             if (isSupported(ConditionalFeature.TWO_LEVEL_FOCUS)) {
796                 uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/caspian/two-level-focus.css&quot;);
797             }
798 
799             if (isSupported(ConditionalFeature.VIRTUAL_KEYBOARD)) {
800                 uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/caspian/fxvk.css&quot;);
801             }
802 
803             if (!isSupported(ConditionalFeature.TRANSPARENT_WINDOW)) {
804                 uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/caspian/caspian-no-transparency.css&quot;);
805             }
806 
807         } else if (Application.STYLESHEET_MODENA.equalsIgnoreCase(stylesheetUrl)) {
808             isModena = true;
809 
810             uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/modena/modena.css&quot;);
811 
812             if (isSupported(ConditionalFeature.INPUT_TOUCH)) {
813                 uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/modena/touch.css&quot;);
814             }
815             // when running on embedded add a extra stylesheet to tune performance of modena theme
816             if (PlatformUtil.isEmbedded()) {
817                 uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/modena/modena-embedded-performance.css&quot;);
818             }
819             if (PlatformUtil.isAndroid()) {
820                 uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/modena/android.css&quot;);
821             }
822             if (PlatformUtil.isIOS()) {
823                 uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/modena/ios.css&quot;);
824             }
825 
826             if (isSupported(ConditionalFeature.TWO_LEVEL_FOCUS)) {
827                 uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/modena/two-level-focus.css&quot;);
828             }
829 
830             if (isSupported(ConditionalFeature.VIRTUAL_KEYBOARD)) {
831                 uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/caspian/fxvk.css&quot;);
832             }
833 
834             if (!isSupported(ConditionalFeature.TRANSPARENT_WINDOW)) {
835                 uaStylesheets.add(&quot;com/sun/javafx/scene/control/skin/modena/modena-no-transparency.css&quot;);
836             }
837 
838         } else {
839             uaStylesheets.add(stylesheetUrl);
840         }
841 
842         // Ensure that accessibility starts right
843         _setAccessibilityTheme(Toolkit.getToolkit().getThemeName());
844         if (accessibilityTheme != null) {
845             uaStylesheets.add(accessibilityTheme);
846         }
847 
848         AccessController.doPrivileged((PrivilegedAction) () -&gt; {
849             StyleManager.getInstance().setUserAgentStylesheets(uaStylesheets);
850             return null;
851         });
852 
853     }
854 
855     public static void addNoTransparencyStylesheetToScene(final Scene scene) {
856         if (PlatformImpl.isCaspian()) {
857             AccessController.doPrivileged((PrivilegedAction) () -&gt; {
858                 StyleManager.getInstance().addUserAgentStylesheet(scene,
859                         &quot;com/sun/javafx/scene/control/skin/caspian/caspian-no-transparency.css&quot;);
860                 return null;
861             });
862         } else if (PlatformImpl.isModena()) {
863             AccessController.doPrivileged((PrivilegedAction) () -&gt; {
864                 StyleManager.getInstance().addUserAgentStylesheet(scene,
865                         &quot;com/sun/javafx/scene/control/skin/modena/modena-no-transparency.css&quot;);
866                 return null;
867             });
868         }
869     }
870 
871     private static boolean isSupportedImpl(ConditionalFeature feature) {
872         switch (feature) {
873             case GRAPHICS:
874                 if (isGraphicsSupported == null) {
875                     isGraphicsSupported = checkForClass(&quot;javafx.stage.Stage&quot;);
876                 }
877                 return isGraphicsSupported;
878             case CONTROLS:
879                 if (isControlsSupported == null) {
880                     isControlsSupported = checkForClass(
881                             &quot;javafx.scene.control.Control&quot;);
882                 }
883                 return isControlsSupported;
884             case MEDIA:
885                 if (isMediaSupported == null) {
886                     isMediaSupported = checkForClass(
887                             &quot;javafx.scene.media.MediaView&quot;);
888                     if (isMediaSupported &amp;&amp; PlatformUtil.isEmbedded()) {
889                         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
890                             String s = System.getProperty(
891                                     &quot;com.sun.javafx.experimental.embedded.media&quot;,
892                                     &quot;false&quot;);
893                             isMediaSupported = Boolean.valueOf(s);
894                             return null;
895 
896                         });
897                     }
898                 }
899                 return isMediaSupported;
900             case WEB:
901                 if (isWebSupported == null) {
902                     isWebSupported = checkForClass(&quot;javafx.scene.web.WebView&quot;);
903                     if (isWebSupported &amp;&amp; PlatformUtil.isEmbedded()) {
904                         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
905                             String s = System.getProperty(
906                                     &quot;com.sun.javafx.experimental.embedded.web&quot;,
907                                     &quot;false&quot;);
908                             isWebSupported = Boolean.valueOf(s);
909                             return null;
910 
911                         });
912                     }
913                 }
914                 return isWebSupported;
915             case SWT:
916                 if (isSWTSupported == null) {
917                     isSWTSupported = checkForClass(&quot;javafx.embed.swt.FXCanvas&quot;);
918                 }
919                 return isSWTSupported;
920             case SWING:
921                 if (isSwingSupported == null) {
922                     isSwingSupported =
923                         // check for JComponent first, it may not be present
924                         checkForClass(&quot;javax.swing.JComponent&quot;) &amp;&amp;
925                         checkForClass(&quot;javafx.embed.swing.JFXPanel&quot;);
926                 }
927                 return isSwingSupported;
928             case FXML:
929                 if (isFXMLSupported == null) {
930                     isFXMLSupported = checkForClass(&quot;javafx.fxml.FXMLLoader&quot;)
931                             &amp;&amp; checkForClass(&quot;javax.xml.stream.XMLInputFactory&quot;);
932                 }
933                 return isFXMLSupported;
934             case TWO_LEVEL_FOCUS:
935                 if (hasTwoLevelFocus == null) {
936                     return Toolkit.getToolkit().isSupported(feature);
937                 }
938                 return hasTwoLevelFocus;
939             case VIRTUAL_KEYBOARD:
940                 if (hasVirtualKeyboard == null) {
941                     return Toolkit.getToolkit().isSupported(feature);
942                 }
943                 return hasVirtualKeyboard;
944             case INPUT_TOUCH:
945                 if (hasTouch == null) {
946                     return Toolkit.getToolkit().isSupported(feature);
947                 }
948                 return hasTouch;
949             case INPUT_MULTITOUCH:
950                 if (hasMultiTouch == null) {
951                     return Toolkit.getToolkit().isSupported(feature);
952                 }
953                 return hasMultiTouch;
954             case INPUT_POINTER:
955                 if (hasPointer == null) {
956                     return Toolkit.getToolkit().isSupported(feature);
957                 }
958                 return hasPointer;
959             default:
960                 return Toolkit.getToolkit().isSupported(feature);
961         }
962     }
963 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/ThirdParty/sqlite/sqlite3.c</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="VERSION.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="sqlite3.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/sqlite/sqlite3.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,8 +1,8 @@</span>
  /******************************************************************************
  ** This file is an amalgamation of many separate C source files from SQLite
<span class="udiff-line-modified-removed">- ** version 3.31.1.  By combining all the individual C code files into this</span>
<span class="udiff-line-modified-added">+ ** version 3.32.3.  By combining all the individual C code files into this</span>
  ** single large file, the entire code can be compiled as a single translation
  ** unit.  This allows many compilers to do optimizations that would not be
  ** possible if the files were compiled separately.  Performance improvements
  ** of 5% or more are commonly seen when SQLite is compiled as a single
  ** translation unit.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -216,10 +216,13 @@</span>
    &quot;ENABLE_ATOMIC_WRITE&quot;,
  #endif
  #if SQLITE_ENABLE_BATCH_ATOMIC_WRITE
    &quot;ENABLE_BATCH_ATOMIC_WRITE&quot;,
  #endif
<span class="udiff-line-added">+ #if SQLITE_ENABLE_BYTECODE_VTAB</span>
<span class="udiff-line-added">+   &quot;ENABLE_BYTECODE_VTAB&quot;,</span>
<span class="udiff-line-added">+ #endif</span>
  #if SQLITE_ENABLE_CEROD
    &quot;ENABLE_CEROD=&quot; CTIMEOPT_VAL(SQLITE_ENABLE_CEROD),
  #endif
  #if SQLITE_ENABLE_COLUMN_METADATA
    &quot;ENABLE_COLUMN_METADATA&quot;,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -378,13 +381,10 @@</span>
    &quot;FTS5_ENABLE_TEST_MI&quot;,
  #endif
  #if SQLITE_FTS5_NO_WITHOUT_ROWID
    &quot;FTS5_NO_WITHOUT_ROWID&quot;,
  #endif
<span class="udiff-line-removed">- #if SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">-   &quot;HAS_CODEC&quot;,</span>
<span class="udiff-line-removed">- #endif</span>
  #if HAVE_ISNAN || SQLITE_HAVE_ISNAN
    &quot;HAVE_ISNAN&quot;,
  #endif
  #if SQLITE_HOMEGROWN_RECURSIVE_MUTEX
    &quot;HOMEGROWN_RECURSIVE_MUTEX&quot;,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -537,13 +537,10 @@</span>
    &quot;OMIT_BETWEEN_OPTIMIZATION&quot;,
  #endif
  #if SQLITE_OMIT_BLOB_LITERAL
    &quot;OMIT_BLOB_LITERAL&quot;,
  #endif
<span class="udiff-line-removed">- #if SQLITE_OMIT_BTREECOUNT</span>
<span class="udiff-line-removed">-   &quot;OMIT_BTREECOUNT&quot;,</span>
<span class="udiff-line-removed">- #endif</span>
  #if SQLITE_OMIT_CAST
    &quot;OMIT_CAST&quot;,
  #endif
  #if SQLITE_OMIT_CHECK
    &quot;OMIT_CHECK&quot;,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1163,13 +1160,13 @@</span>
  **
  ** See also: [sqlite3_libversion()],
  ** [sqlite3_libversion_number()], [sqlite3_sourceid()],
  ** [sqlite_version()] and [sqlite_source_id()].
  */
<span class="udiff-line-modified-removed">- #define SQLITE_VERSION        &quot;3.31.1&quot;</span>
<span class="udiff-line-modified-removed">- #define SQLITE_VERSION_NUMBER 3031001</span>
<span class="udiff-line-modified-removed">- #define SQLITE_SOURCE_ID      &quot;2020-01-27 19:55:54 3bfa9cc97da10598521b342961df8f5f68c7388fa117345eeb516eaa837bb4d6&quot;</span>
<span class="udiff-line-modified-added">+ #define SQLITE_VERSION        &quot;3.32.3&quot;</span>
<span class="udiff-line-modified-added">+ #define SQLITE_VERSION_NUMBER 3032003</span>
<span class="udiff-line-modified-added">+ #define SQLITE_SOURCE_ID      &quot;2020-06-18 14:00:33 7ebdfa80be8e8e73324b8d66b3460222eb74c7e9dfd655b48d6ca7e1933cc8fd&quot;</span>
  
  /*
  ** CAPI3REF: Run-Time Library Version Numbers
  ** KEYWORDS: sqlite3_version sqlite3_sourceid
  **
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1339,30 +1336,26 @@</span>
  ** for the [sqlite3] object.
  ** ^Calls to sqlite3_close() and sqlite3_close_v2() return [SQLITE_OK] if
  ** the [sqlite3] object is successfully destroyed and all associated
  ** resources are deallocated.
  **
<span class="udiff-line-modified-removed">- ** ^If the database connection is associated with unfinalized prepared</span>
<span class="udiff-line-modified-removed">- ** statements or unfinished sqlite3_backup objects then sqlite3_close()</span>
<span class="udiff-line-removed">- ** will leave the database connection open and return [SQLITE_BUSY].</span>
<span class="udiff-line-removed">- ** ^If sqlite3_close_v2() is called with unfinalized prepared statements</span>
<span class="udiff-line-removed">- ** and/or unfinished sqlite3_backups, then the database connection becomes</span>
<span class="udiff-line-removed">- ** an unusable &quot;zombie&quot; which will automatically be deallocated when the</span>
<span class="udiff-line-removed">- ** last prepared statement is finalized or the last sqlite3_backup is</span>
<span class="udiff-line-removed">- ** finished.  The sqlite3_close_v2() interface is intended for use with</span>
<span class="udiff-line-removed">- ** host languages that are garbage collected, and where the order in which</span>
<span class="udiff-line-removed">- ** destructors are called is arbitrary.</span>
<span class="udiff-line-removed">- **</span>
<span class="udiff-line-removed">- ** Applications should [sqlite3_finalize | finalize] all [prepared statements],</span>
<span class="udiff-line-removed">- ** [sqlite3_blob_close | close] all [BLOB handles], and</span>
<span class="udiff-line-modified-added">+ ** Ideally, applications should [sqlite3_finalize | finalize] all</span>
<span class="udiff-line-modified-added">+ ** [prepared statements], [sqlite3_blob_close | close] all [BLOB handles], and</span>
  ** [sqlite3_backup_finish | finish] all [sqlite3_backup] objects associated
<span class="udiff-line-modified-removed">- ** with the [sqlite3] object prior to attempting to close the object.  ^If</span>
<span class="udiff-line-modified-removed">- ** sqlite3_close_v2() is called on a [database connection] that still has</span>
<span class="udiff-line-modified-removed">- ** outstanding [prepared statements], [BLOB handles], and/or</span>
<span class="udiff-line-modified-removed">- ** [sqlite3_backup] objects then it returns [SQLITE_OK] and the deallocation</span>
<span class="udiff-line-modified-removed">- ** of resources is deferred until all [prepared statements], [BLOB handles],</span>
<span class="udiff-line-modified-removed">- ** and [sqlite3_backup] objects are also destroyed.</span>
<span class="udiff-line-modified-added">+ ** with the [sqlite3] object prior to attempting to close the object.</span>
<span class="udiff-line-modified-added">+ ** ^If the database connection is associated with unfinalized prepared</span>
<span class="udiff-line-modified-added">+ ** statements, BLOB handlers, and/or unfinished sqlite3_backup objects then</span>
<span class="udiff-line-modified-added">+ ** sqlite3_close() will leave the database connection open and return</span>
<span class="udiff-line-modified-added">+ ** [SQLITE_BUSY]. ^If sqlite3_close_v2() is called with unfinalized prepared</span>
<span class="udiff-line-modified-added">+ ** statements, unclosed BLOB handlers, and/or unfinished sqlite3_backups,</span>
<span class="udiff-line-added">+ ** it returns [SQLITE_OK] regardless, but instead of deallocating the database</span>
<span class="udiff-line-added">+ ** connection immediately, it marks the database connection as an unusable</span>
<span class="udiff-line-added">+ ** &quot;zombie&quot; and makes arrangements to automatically deallocate the database</span>
<span class="udiff-line-added">+ ** connection after all prepared statements are finalized, all BLOB handles</span>
<span class="udiff-line-added">+ ** are closed, and all backups have finished. The sqlite3_close_v2() interface</span>
<span class="udiff-line-added">+ ** is intended for use with host languages that are garbage collected, and</span>
<span class="udiff-line-added">+ ** where the order in which destructors are called is arbitrary.</span>
  **
  ** ^If an [sqlite3] object is destroyed while a transaction is open,
  ** the transaction is automatically rolled back.
  **
  ** The C parameter to [sqlite3_close(C)] and [sqlite3_close_v2(C)]
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1547,22 +1540,25 @@</span>
  #define SQLITE_IOERR_VNODE             (SQLITE_IOERR | (27&lt;&lt;8))
  #define SQLITE_IOERR_AUTH              (SQLITE_IOERR | (28&lt;&lt;8))
  #define SQLITE_IOERR_BEGIN_ATOMIC      (SQLITE_IOERR | (29&lt;&lt;8))
  #define SQLITE_IOERR_COMMIT_ATOMIC     (SQLITE_IOERR | (30&lt;&lt;8))
  #define SQLITE_IOERR_ROLLBACK_ATOMIC   (SQLITE_IOERR | (31&lt;&lt;8))
<span class="udiff-line-added">+ #define SQLITE_IOERR_DATA              (SQLITE_IOERR | (32&lt;&lt;8))</span>
  #define SQLITE_LOCKED_SHAREDCACHE      (SQLITE_LOCKED |  (1&lt;&lt;8))
  #define SQLITE_LOCKED_VTAB             (SQLITE_LOCKED |  (2&lt;&lt;8))
  #define SQLITE_BUSY_RECOVERY           (SQLITE_BUSY   |  (1&lt;&lt;8))
  #define SQLITE_BUSY_SNAPSHOT           (SQLITE_BUSY   |  (2&lt;&lt;8))
<span class="udiff-line-added">+ #define SQLITE_BUSY_TIMEOUT            (SQLITE_BUSY   |  (3&lt;&lt;8))</span>
  #define SQLITE_CANTOPEN_NOTEMPDIR      (SQLITE_CANTOPEN | (1&lt;&lt;8))
  #define SQLITE_CANTOPEN_ISDIR          (SQLITE_CANTOPEN | (2&lt;&lt;8))
  #define SQLITE_CANTOPEN_FULLPATH       (SQLITE_CANTOPEN | (3&lt;&lt;8))
  #define SQLITE_CANTOPEN_CONVPATH       (SQLITE_CANTOPEN | (4&lt;&lt;8))
  #define SQLITE_CANTOPEN_DIRTYWAL       (SQLITE_CANTOPEN | (5&lt;&lt;8)) /* Not Used */
  #define SQLITE_CANTOPEN_SYMLINK        (SQLITE_CANTOPEN | (6&lt;&lt;8))
  #define SQLITE_CORRUPT_VTAB            (SQLITE_CORRUPT | (1&lt;&lt;8))
  #define SQLITE_CORRUPT_SEQUENCE        (SQLITE_CORRUPT | (2&lt;&lt;8))
<span class="udiff-line-added">+ #define SQLITE_CORRUPT_INDEX           (SQLITE_CORRUPT | (3&lt;&lt;8))</span>
  #define SQLITE_READONLY_RECOVERY       (SQLITE_READONLY | (1&lt;&lt;8))
  #define SQLITE_READONLY_CANTLOCK       (SQLITE_READONLY | (2&lt;&lt;8))
  #define SQLITE_READONLY_ROLLBACK       (SQLITE_READONLY | (3&lt;&lt;8))
  #define SQLITE_READONLY_DBMOVED        (SQLITE_READONLY | (4&lt;&lt;8))
  #define SQLITE_READONLY_CANTINIT       (SQLITE_READONLY | (5&lt;&lt;8))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2127,14 +2123,16 @@</span>
  ** so that all subsequent write operations are independent.
  ** ^SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without
  ** a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].
  **
  ** &lt;li&gt;[[SQLITE_FCNTL_LOCK_TIMEOUT]]
<span class="udiff-line-modified-removed">- ** The [SQLITE_FCNTL_LOCK_TIMEOUT] opcode causes attempts to obtain</span>
<span class="udiff-line-modified-removed">- ** a file lock using the xLock or xShmLock methods of the VFS to wait</span>
<span class="udiff-line-modified-removed">- ** for up to M milliseconds before failing, where M is the single</span>
<span class="udiff-line-modified-removed">- ** unsigned integer parameter.</span>
<span class="udiff-line-modified-added">+ ** The [SQLITE_FCNTL_LOCK_TIMEOUT] opcode is used to configure a VFS</span>
<span class="udiff-line-modified-added">+ ** to block for up to M milliseconds before failing when attempting to</span>
<span class="udiff-line-modified-added">+ ** obtain a file lock using the xLock or xShmLock methods of the VFS.</span>
<span class="udiff-line-modified-added">+ ** The parameter is a pointer to a 32-bit signed integer that contains</span>
<span class="udiff-line-added">+ ** the value that M is to be set to. Before returning, the 32-bit signed</span>
<span class="udiff-line-added">+ ** integer is overwritten with the previous value of M.</span>
  **
  ** &lt;li&gt;[[SQLITE_FCNTL_DATA_VERSION]]
  ** The [SQLITE_FCNTL_DATA_VERSION] opcode is used to detect changes to
  ** a database file.  The argument is a pointer to a 32-bit unsigned integer.
  ** The &quot;data version&quot; for the pager is written into the pointer.  The
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2152,10 +2150,15 @@</span>
  ** but omits changes implemented by the database connection on which it is
  ** called.  This file control is the only mechanism to detect changes that
  ** happen either internally or externally and that are associated with
  ** a particular attached database.
  **
<span class="udiff-line-added">+ ** &lt;li&gt;[[SQLITE_FCNTL_CKPT_START]]</span>
<span class="udiff-line-added">+ ** The [SQLITE_FCNTL_CKPT_START] opcode is invoked from within a checkpoint</span>
<span class="udiff-line-added">+ ** in wal mode before the client starts to copy pages from the wal</span>
<span class="udiff-line-added">+ ** file to the database file.</span>
<span class="udiff-line-added">+ **</span>
  ** &lt;li&gt;[[SQLITE_FCNTL_CKPT_DONE]]
  ** The [SQLITE_FCNTL_CKPT_DONE] opcode is invoked from within a checkpoint
  ** in wal mode after the client has finished copying pages from the wal
  ** file to the database file, but before the *-shm file is updated to
  ** record the fact that the pages have been checkpointed.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2195,10 +2198,12 @@</span>
  #define SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE  33
  #define SQLITE_FCNTL_LOCK_TIMEOUT           34
  #define SQLITE_FCNTL_DATA_VERSION           35
  #define SQLITE_FCNTL_SIZE_LIMIT             36
  #define SQLITE_FCNTL_CKPT_DONE              37
<span class="udiff-line-added">+ #define SQLITE_FCNTL_RESERVE_BYTES          38</span>
<span class="udiff-line-added">+ #define SQLITE_FCNTL_CKPT_START             39</span>
  
  /* deprecated names */
  #define SQLITE_GET_LOCKPROXYFILE      SQLITE_FCNTL_GET_LOCKPROXYFILE
  #define SQLITE_SET_LOCKPROXYFILE      SQLITE_FCNTL_SET_LOCKPROXYFILE
  #define SQLITE_LAST_ERRNO             SQLITE_FCNTL_LAST_ERRNO
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4573,12 +4578,23 @@</span>
  **
  ** These are utility routines, useful to [VFS|custom VFS implementations],
  ** that check if a database file was a URI that contained a specific query
  ** parameter, and if so obtains the value of that query parameter.
  **
<span class="udiff-line-modified-removed">- ** If F is the database filename pointer passed into the xOpen() method of</span>
<span class="udiff-line-modified-removed">- ** a VFS implementation or it is the return value of [sqlite3_db_filename()]</span>
<span class="udiff-line-modified-added">+ ** The first parameter to these interfaces (hereafter referred to</span>
<span class="udiff-line-modified-added">+ ** as F) must be one of:</span>
<span class="udiff-line-added">+ ** &lt;ul&gt;</span>
<span class="udiff-line-added">+ ** &lt;li&gt; A database filename pointer created by the SQLite core and</span>
<span class="udiff-line-added">+ ** passed into the xOpen() method of a VFS implemention, or</span>
<span class="udiff-line-added">+ ** &lt;li&gt; A filename obtained from [sqlite3_db_filename()], or</span>
<span class="udiff-line-added">+ ** &lt;li&gt; A new filename constructed using [sqlite3_create_filename()].</span>
<span class="udiff-line-added">+ ** &lt;/ul&gt;</span>
<span class="udiff-line-added">+ ** If the F parameter is not one of the above, then the behavior is</span>
<span class="udiff-line-added">+ ** undefined and probably undesirable.  Older versions of SQLite were</span>
<span class="udiff-line-added">+ ** more tolerant of invalid F parameters than newer versions.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** If F is a suitable filename (as described in the previous paragraph)</span>
  ** and if P is the name of the query parameter, then
  ** sqlite3_uri_parameter(F,P) returns the value of the P
  ** parameter if it exists or a NULL pointer if P does not appear as a
  ** query parameter on F.  If P is a query parameter of F and it
  ** has no explicit value, then sqlite3_uri_parameter(F,P) returns
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4657,10 +4673,82 @@</span>
  */
  SQLITE_API const char *sqlite3_filename_database(const char*);
  SQLITE_API const char *sqlite3_filename_journal(const char*);
  SQLITE_API const char *sqlite3_filename_wal(const char*);
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** CAPI3REF:  Database File Corresponding To A Journal</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** ^If X is the name of a rollback or WAL-mode journal file that is</span>
<span class="udiff-line-added">+ ** passed into the xOpen method of [sqlite3_vfs], then</span>
<span class="udiff-line-added">+ ** sqlite3_database_file_object(X) returns a pointer to the [sqlite3_file]</span>
<span class="udiff-line-added">+ ** object that represents the main database file.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** This routine is intended for use in custom [VFS] implementations</span>
<span class="udiff-line-added">+ ** only.  It is not a general-purpose interface.</span>
<span class="udiff-line-added">+ ** The argument sqlite3_file_object(X) must be a filename pointer that</span>
<span class="udiff-line-added">+ ** has been passed into [sqlite3_vfs].xOpen method where the</span>
<span class="udiff-line-added">+ ** flags parameter to xOpen contains one of the bits</span>
<span class="udiff-line-added">+ ** [SQLITE_OPEN_MAIN_JOURNAL] or [SQLITE_OPEN_WAL].  Any other use</span>
<span class="udiff-line-added">+ ** of this routine results in undefined and probably undesirable</span>
<span class="udiff-line-added">+ ** behavior.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ SQLITE_API sqlite3_file *sqlite3_database_file_object(const char*);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** CAPI3REF: Create and Destroy VFS Filenames</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** These interfces are provided for use by [VFS shim] implementations and</span>
<span class="udiff-line-added">+ ** are not useful outside of that context.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** The sqlite3_create_filename(D,J,W,N,P) allocates memory to hold a version of</span>
<span class="udiff-line-added">+ ** database filename D with corresponding journal file J and WAL file W and</span>
<span class="udiff-line-added">+ ** with N URI parameters key/values pairs in the array P.  The result from</span>
<span class="udiff-line-added">+ ** sqlite3_create_filename(D,J,W,N,P) is a pointer to a database filename that</span>
<span class="udiff-line-added">+ ** is safe to pass to routines like:</span>
<span class="udiff-line-added">+ ** &lt;ul&gt;</span>
<span class="udiff-line-added">+ ** &lt;li&gt; [sqlite3_uri_parameter()],</span>
<span class="udiff-line-added">+ ** &lt;li&gt; [sqlite3_uri_boolean()],</span>
<span class="udiff-line-added">+ ** &lt;li&gt; [sqlite3_uri_int64()],</span>
<span class="udiff-line-added">+ ** &lt;li&gt; [sqlite3_uri_key()],</span>
<span class="udiff-line-added">+ ** &lt;li&gt; [sqlite3_filename_database()],</span>
<span class="udiff-line-added">+ ** &lt;li&gt; [sqlite3_filename_journal()], or</span>
<span class="udiff-line-added">+ ** &lt;li&gt; [sqlite3_filename_wal()].</span>
<span class="udiff-line-added">+ ** &lt;/ul&gt;</span>
<span class="udiff-line-added">+ ** If a memory allocation error occurs, sqlite3_create_filename() might</span>
<span class="udiff-line-added">+ ** return a NULL pointer.  The memory obtained from sqlite3_create_filename(X)</span>
<span class="udiff-line-added">+ ** must be released by a corresponding call to sqlite3_free_filename(Y).</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** The P parameter in sqlite3_create_filename(D,J,W,N,P) should be an array</span>
<span class="udiff-line-added">+ ** of 2*N pointers to strings.  Each pair of pointers in this array corresponds</span>
<span class="udiff-line-added">+ ** to a key and value for a query parameter.  The P parameter may be a NULL</span>
<span class="udiff-line-added">+ ** pointer if N is zero.  None of the 2*N pointers in the P array may be</span>
<span class="udiff-line-added">+ ** NULL pointers and key pointers should not be empty strings.</span>
<span class="udiff-line-added">+ ** None of the D, J, or W parameters to sqlite3_create_filename(D,J,W,N,P) may</span>
<span class="udiff-line-added">+ ** be NULL pointers, though they can be empty strings.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** The sqlite3_free_filename(Y) routine releases a memory allocation</span>
<span class="udiff-line-added">+ ** previously obtained from sqlite3_create_filename().  Invoking</span>
<span class="udiff-line-added">+ ** sqlite3_free_filename(Y) where Y is a NULL pointer is a harmless no-op.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** If the Y parameter to sqlite3_free_filename(Y) is anything other</span>
<span class="udiff-line-added">+ ** than a NULL pointer or a pointer previously acquired from</span>
<span class="udiff-line-added">+ ** sqlite3_create_filename(), then bad things such as heap</span>
<span class="udiff-line-added">+ ** corruption or segfaults may occur. The value Y should be</span>
<span class="udiff-line-added">+ ** used again after sqlite3_free_filename(Y) has been called.  This means</span>
<span class="udiff-line-added">+ ** that if the [sqlite3_vfs.xOpen()] method of a VFS has been called using Y,</span>
<span class="udiff-line-added">+ ** then the corresponding [sqlite3_module.xClose() method should also be</span>
<span class="udiff-line-added">+ ** invoked prior to calling sqlite3_free_filename(Y).</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ SQLITE_API char *sqlite3_create_filename(</span>
<span class="udiff-line-added">+   const char *zDatabase,</span>
<span class="udiff-line-added">+   const char *zJournal,</span>
<span class="udiff-line-added">+   const char *zWal,</span>
<span class="udiff-line-added">+   int nParam,</span>
<span class="udiff-line-added">+   const char **azParam</span>
<span class="udiff-line-added">+ );</span>
<span class="udiff-line-added">+ SQLITE_API void sqlite3_free_filename(char*);</span>
  
  /*
  ** CAPI3REF: Error Codes And Messages
  ** METHOD: sqlite3
  **
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5239,16 +5327,34 @@</span>
  ** occurrences have the same index as the first occurrence.
  ** ^The index for named parameters can be looked up using the
  ** [sqlite3_bind_parameter_index()] API if desired.  ^The index
  ** for &quot;?NNN&quot; parameters is the value of NNN.
  ** ^The NNN value must be between 1 and the [sqlite3_limit()]
<span class="udiff-line-modified-removed">- ** parameter [SQLITE_LIMIT_VARIABLE_NUMBER] (default value: 999).</span>
<span class="udiff-line-modified-added">+ ** parameter [SQLITE_LIMIT_VARIABLE_NUMBER] (default value: 32766).</span>
  **
  ** ^The third argument is the value to bind to the parameter.
  ** ^If the third parameter to sqlite3_bind_text() or sqlite3_bind_text16()
  ** or sqlite3_bind_blob() is a NULL pointer then the fourth parameter
  ** is ignored and the end result is the same as sqlite3_bind_null().
<span class="udiff-line-added">+ ** ^If the third parameter to sqlite3_bind_text() is not NULL, then</span>
<span class="udiff-line-added">+ ** it should be a pointer to well-formed UTF8 text.</span>
<span class="udiff-line-added">+ ** ^If the third parameter to sqlite3_bind_text16() is not NULL, then</span>
<span class="udiff-line-added">+ ** it should be a pointer to well-formed UTF16 text.</span>
<span class="udiff-line-added">+ ** ^If the third parameter to sqlite3_bind_text64() is not NULL, then</span>
<span class="udiff-line-added">+ ** it should be a pointer to a well-formed unicode string that is</span>
<span class="udiff-line-added">+ ** either UTF8 if the sixth parameter is SQLITE_UTF8, or UTF16</span>
<span class="udiff-line-added">+ ** otherwise.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** [[byte-order determination rules]] ^The byte-order of</span>
<span class="udiff-line-added">+ ** UTF16 input text is determined by the byte-order mark (BOM, U+FEFF)</span>
<span class="udiff-line-added">+ ** found in first character, which is removed, or in the absence of a BOM</span>
<span class="udiff-line-added">+ ** the byte order is the native byte order of the host</span>
<span class="udiff-line-added">+ ** machine for sqlite3_bind_text16() or the byte order specified in</span>
<span class="udiff-line-added">+ ** the 6th parameter for sqlite3_bind_text64().)^</span>
<span class="udiff-line-added">+ ** ^If UTF16 input text contains invalid unicode</span>
<span class="udiff-line-added">+ ** characters, then SQLite might change those invalid characters</span>
<span class="udiff-line-added">+ ** into the unicode replacement character: U+FFFD.</span>
  **
  ** ^(In those routines that have a fourth argument, its value is the
  ** number of bytes in the parameter.  To be clear: the value is the
  ** number of &lt;u&gt;bytes&lt;/u&gt; in the value, not the number of characters.)^
  ** ^If the fourth parameter to sqlite3_bind_text() or sqlite3_bind_text16()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5258,11 +5364,11 @@</span>
  ** the behavior is undefined.
  ** If a non-negative fourth parameter is provided to sqlite3_bind_text()
  ** or sqlite3_bind_text16() or sqlite3_bind_text64() then
  ** that parameter must be the byte offset
  ** where the NUL terminator would occur assuming the string were NUL
<span class="udiff-line-modified-removed">- ** terminated.  If any NUL characters occur at byte offsets less than</span>
<span class="udiff-line-modified-added">+ ** terminated.  If any NUL characters occurs at byte offsets less than</span>
  ** the value of the fourth parameter then the resulting string value will
  ** contain embedded NULs.  The result of expressions involving strings
  ** with embedded NULs is undefined.
  **
  ** ^The fifth argument to the BLOB and string binding interfaces
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6426,11 +6532,11 @@</span>
  ** when first called if N is less than or equal to zero or if a memory
  ** allocate error occurs.
  **
  ** ^(The amount of space allocated by sqlite3_aggregate_context(C,N) is
  ** determined by the N parameter on first successful call.  Changing the
<span class="udiff-line-modified-removed">- ** value of N in any subsequents call to sqlite3_aggregate_context() within</span>
<span class="udiff-line-modified-added">+ ** value of N in any subsequent call to sqlite3_aggregate_context() within</span>
  ** the same aggregate function instance will not resize the memory
  ** allocation.)^  Within the xFinal callback, it is customary to set
  ** N=0 in calls to sqlite3_aggregate_context(C,N) so that no
  ** pointless memory allocations occur.
  **
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6583,12 +6689,13 @@</span>
  ** cause the implemented SQL function to throw an exception.
  ** ^SQLite uses the string pointed to by the
  ** 2nd parameter of sqlite3_result_error() or sqlite3_result_error16()
  ** as the text of an error message.  ^SQLite interprets the error
  ** message string from sqlite3_result_error() as UTF-8. ^SQLite
<span class="udiff-line-modified-removed">- ** interprets the string from sqlite3_result_error16() as UTF-16 in native</span>
<span class="udiff-line-modified-removed">- ** byte order.  ^If the third parameter to sqlite3_result_error()</span>
<span class="udiff-line-modified-added">+ ** interprets the string from sqlite3_result_error16() as UTF-16 using</span>
<span class="udiff-line-modified-added">+ ** the same [byte-order determination rules] as [sqlite3_bind_text16()].</span>
<span class="udiff-line-added">+ ** ^If the third parameter to sqlite3_result_error()</span>
  ** or sqlite3_result_error16() is negative then SQLite takes as the error
  ** message all text up through the first zero character.
  ** ^If the third parameter to sqlite3_result_error() or
  ** sqlite3_result_error16() is non-negative then SQLite takes that many
  ** bytes (not characters) from the 2nd parameter as the error message.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6652,10 +6759,29 @@</span>
  ** ^If the 4th parameter to the sqlite3_result_text* interfaces
  ** or sqlite3_result_blob is the special constant SQLITE_TRANSIENT
  ** then SQLite makes a copy of the result into space obtained
  ** from [sqlite3_malloc()] before it returns.
  **
<span class="udiff-line-added">+ ** ^For the sqlite3_result_text16(), sqlite3_result_text16le(), and</span>
<span class="udiff-line-added">+ ** sqlite3_result_text16be() routines, and for sqlite3_result_text64()</span>
<span class="udiff-line-added">+ ** when the encoding is not UTF8, if the input UTF16 begins with a</span>
<span class="udiff-line-added">+ ** byte-order mark (BOM, U+FEFF) then the BOM is removed from the</span>
<span class="udiff-line-added">+ ** string and the rest of the string is interpreted according to the</span>
<span class="udiff-line-added">+ ** byte-order specified by the BOM.  ^The byte-order specified by</span>
<span class="udiff-line-added">+ ** the BOM at the beginning of the text overrides the byte-order</span>
<span class="udiff-line-added">+ ** specified by the interface procedure.  ^So, for example, if</span>
<span class="udiff-line-added">+ ** sqlite3_result_text16le() is invoked with text that begins</span>
<span class="udiff-line-added">+ ** with bytes 0xfe, 0xff (a big-endian byte-order mark) then the</span>
<span class="udiff-line-added">+ ** first two bytes of input are skipped and the remaining input</span>
<span class="udiff-line-added">+ ** is interpreted as UTF16BE text.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** ^For UTF16 input text to the sqlite3_result_text16(),</span>
<span class="udiff-line-added">+ ** sqlite3_result_text16be(), sqlite3_result_text16le(), and</span>
<span class="udiff-line-added">+ ** sqlite3_result_text64() routines, if the text contains invalid</span>
<span class="udiff-line-added">+ ** UTF16 characters, the invalid characters might be converted</span>
<span class="udiff-line-added">+ ** into the unicode replacement character, U+FFFD.</span>
<span class="udiff-line-added">+ **</span>
  ** ^The sqlite3_result_value() interface sets the result of
  ** the application-defined function to be a copy of the
  ** [unprotected sqlite3_value] object specified by the 2nd parameter.  ^The
  ** sqlite3_result_value() interface makes a copy of the [sqlite3_value]
  ** so that the [sqlite3_value] specified in the parameter may change or
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6857,55 +6983,10 @@</span>
    sqlite3*,
    void*,
    void(*)(void*,sqlite3*,int eTextRep,const void*)
  );
  
<span class="udiff-line-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">- /*</span>
<span class="udiff-line-removed">- ** Specify the key for an encrypted database.  This routine should be</span>
<span class="udiff-line-removed">- ** called right after sqlite3_open().</span>
<span class="udiff-line-removed">- **</span>
<span class="udiff-line-removed">- ** The code to implement this API is not available in the public release</span>
<span class="udiff-line-removed">- ** of SQLite.</span>
<span class="udiff-line-removed">- */</span>
<span class="udiff-line-removed">- SQLITE_API int sqlite3_key(</span>
<span class="udiff-line-removed">-   sqlite3 *db,                   /* Database to be rekeyed */</span>
<span class="udiff-line-removed">-   const void *pKey, int nKey     /* The key */</span>
<span class="udiff-line-removed">- );</span>
<span class="udiff-line-removed">- SQLITE_API int sqlite3_key_v2(</span>
<span class="udiff-line-removed">-   sqlite3 *db,                   /* Database to be rekeyed */</span>
<span class="udiff-line-removed">-   const char *zDbName,           /* Name of the database */</span>
<span class="udiff-line-removed">-   const void *pKey, int nKey     /* The key */</span>
<span class="udiff-line-removed">- );</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- /*</span>
<span class="udiff-line-removed">- ** Change the key on an open database.  If the current database is not</span>
<span class="udiff-line-removed">- ** encrypted, this routine will encrypt it.  If pNew==0 or nNew==0, the</span>
<span class="udiff-line-removed">- ** database is decrypted.</span>
<span class="udiff-line-removed">- **</span>
<span class="udiff-line-removed">- ** The code to implement this API is not available in the public release</span>
<span class="udiff-line-removed">- ** of SQLite.</span>
<span class="udiff-line-removed">- */</span>
<span class="udiff-line-removed">- SQLITE_API int sqlite3_rekey(</span>
<span class="udiff-line-removed">-   sqlite3 *db,                   /* Database to be rekeyed */</span>
<span class="udiff-line-removed">-   const void *pKey, int nKey     /* The new key */</span>
<span class="udiff-line-removed">- );</span>
<span class="udiff-line-removed">- SQLITE_API int sqlite3_rekey_v2(</span>
<span class="udiff-line-removed">-   sqlite3 *db,                   /* Database to be rekeyed */</span>
<span class="udiff-line-removed">-   const char *zDbName,           /* Name of the database */</span>
<span class="udiff-line-removed">-   const void *pKey, int nKey     /* The new key */</span>
<span class="udiff-line-removed">- );</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- /*</span>
<span class="udiff-line-removed">- ** Specify the activation key for a SEE database.  Unless</span>
<span class="udiff-line-removed">- ** activated, none of the SEE routines will work.</span>
<span class="udiff-line-removed">- */</span>
<span class="udiff-line-removed">- SQLITE_API void sqlite3_activate_see(</span>
<span class="udiff-line-removed">-   const char *zPassPhrase        /* Activation phrase */</span>
<span class="udiff-line-removed">- );</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
  #ifdef SQLITE_ENABLE_CEROD
  /*
  ** Specify the activation key for a CEROD database.  Unless
  ** activated, none of the CEROD routines will work.
  */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8644,11 +8725,11 @@</span>
  #define SQLITE_TESTCTRL_FAULT_INSTALL            9
  #define SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS     10
  #define SQLITE_TESTCTRL_PENDING_BYTE            11
  #define SQLITE_TESTCTRL_ASSERT                  12
  #define SQLITE_TESTCTRL_ALWAYS                  13
<span class="udiff-line-modified-removed">- #define SQLITE_TESTCTRL_RESERVE                 14</span>
<span class="udiff-line-modified-added">+ #define SQLITE_TESTCTRL_RESERVE                 14  /* NOT USED */</span>
  #define SQLITE_TESTCTRL_OPTIMIZATIONS           15
  #define SQLITE_TESTCTRL_ISKEYWORD               16  /* NOT USED */
  #define SQLITE_TESTCTRL_SCRATCHMALLOC           17  /* NOT USED */
  #define SQLITE_TESTCTRL_INTERNAL_FUNCTIONS      17
  #define SQLITE_TESTCTRL_LOCALTIME_FAULT         18
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13270,13 +13351,16 @@</span>
  #endif
  
  
  /*
  ** The maximum value of a ?nnn wildcard that the parser will accept.
<span class="udiff-line-added">+ ** If the value exceeds 32767 then extra space is required for the Expr</span>
<span class="udiff-line-added">+ ** structure.  But otherwise, we believe that the number can be as large</span>
<span class="udiff-line-added">+ ** as a signed 32-bit integer can hold.</span>
  */
  #ifndef SQLITE_MAX_VARIABLE_NUMBER
<span class="udiff-line-modified-removed">- # define SQLITE_MAX_VARIABLE_NUMBER 999</span>
<span class="udiff-line-modified-added">+ # define SQLITE_MAX_VARIABLE_NUMBER 32766</span>
  #endif
  
  /* Maximum page size.  The upper bound on this value is 65536.  This a limit
  ** imposed by the use of 16-bit offsets within each page.
  **
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -13361,10 +13445,25 @@</span>
  #pragma warn -aus /* Assigned value is never used */
  #pragma warn -csu /* Comparing signed and unsigned */
  #pragma warn -spa /* Suspicious pointer arithmetic */
  #endif
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** WAL mode depends on atomic aligned 32-bit loads and stores in a few</span>
<span class="udiff-line-added">+ ** places.  The following macros try to make this explicit.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ #ifndef __has_feature</span>
<span class="udiff-line-added">+ # define __has_feature(x) 0       /* compatibility with non-clang compilers */</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ #if GCC_VERSION&gt;=4007000 || __has_feature(c_atomic)</span>
<span class="udiff-line-added">+ # define AtomicLoad(PTR)       __atomic_load_n((PTR),__ATOMIC_RELAXED)</span>
<span class="udiff-line-added">+ # define AtomicStore(PTR,VAL)  __atomic_store_n((PTR),(VAL),__ATOMIC_RELAXED)</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+ # define AtomicLoad(PTR)       (*(PTR))</span>
<span class="udiff-line-added">+ # define AtomicStore(PTR,VAL)  (*(PTR) = (VAL))</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  /*
  ** Include standard header files as necessary
  */
  #ifdef HAVE_STDINT_H
  #include &lt;stdint.h&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -14438,11 +14537,10 @@</span>
  typedef struct BusyHandler BusyHandler;
  struct BusyHandler {
    int (*xBusyHandler)(void *,int);  /* The busy callback */
    void *pBusyArg;                   /* First arg to busy callback */
    int nBusy;                        /* Incremented with each busy call */
<span class="udiff-line-removed">-   u8 bExtraFileArg;                 /* Include sqlite3_file as callback arg */</span>
  };
  
  /*
  ** Name of the master database table.  The master database table
  ** is a special table that holds the names and attributes of all
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -14696,11 +14794,11 @@</span>
  SQLITE_PRIVATE int sqlite3BtreeSetPageSize(Btree *p, int nPagesize, int nReserve, int eFix);
  SQLITE_PRIVATE int sqlite3BtreeGetPageSize(Btree*);
  SQLITE_PRIVATE int sqlite3BtreeMaxPageCount(Btree*,int);
  SQLITE_PRIVATE u32 sqlite3BtreeLastPage(Btree*);
  SQLITE_PRIVATE int sqlite3BtreeSecureDelete(Btree*,int);
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE int sqlite3BtreeGetOptimalReserve(Btree*);</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE int sqlite3BtreeGetRequestedReserve(Btree*);</span>
  SQLITE_PRIVATE int sqlite3BtreeGetReserveNoMutex(Btree *p);
  SQLITE_PRIVATE int sqlite3BtreeSetAutoVacuum(Btree *, int);
  SQLITE_PRIVATE int sqlite3BtreeGetAutoVacuum(Btree *);
  SQLITE_PRIVATE int sqlite3BtreeBeginTrans(Btree*,int,int*);
  SQLITE_PRIVATE int sqlite3BtreeCommitPhaseOne(Btree*, const char *zMaster);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -14958,13 +15056,11 @@</span>
  #ifndef NDEBUG
  SQLITE_PRIVATE int sqlite3BtreeCursorIsValid(BtCursor*);
  #endif
  SQLITE_PRIVATE int sqlite3BtreeCursorIsValidNN(BtCursor*);
  
<span class="udiff-line-removed">- #ifndef SQLITE_OMIT_BTREECOUNT</span>
  SQLITE_PRIVATE int sqlite3BtreeCount(sqlite3*, BtCursor*, i64*);
<span class="udiff-line-removed">- #endif</span>
  
  #ifdef SQLITE_TEST
  SQLITE_PRIVATE int sqlite3BtreeCursorInfo(BtCursor*, int*, int);
  SQLITE_PRIVATE void sqlite3BtreeCursorList(Btree*);
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -15253,12 +15349,12 @@</span>
  #define OP_ElseNotEq      58 /* jump, same as TK_ESCAPE                    */
  #define OP_DecrJumpZero   59 /* jump, synopsis: if (--r[P1])==0 goto P2    */
  #define OP_IncrVacuum     60 /* jump                                       */
  #define OP_VNext          61 /* jump                                       */
  #define OP_Init           62 /* jump, synopsis: Start at P2                */
<span class="udiff-line-modified-removed">- #define OP_PureFunc       63 /* synopsis: r[P3]=func(r[P2@P5])             */</span>
<span class="udiff-line-modified-removed">- #define OP_Function       64 /* synopsis: r[P3]=func(r[P2@P5])             */</span>
<span class="udiff-line-modified-added">+ #define OP_PureFunc       63 /* synopsis: r[P3]=func(r[P2@NP])             */</span>
<span class="udiff-line-modified-added">+ #define OP_Function       64 /* synopsis: r[P3]=func(r[P2@NP])             */</span>
  #define OP_Return         65
  #define OP_EndCoroutine   66
  #define OP_HaltIfNull     67 /* synopsis: if r[P3]=null halt               */
  #define OP_Halt           68
  #define OP_Integer        69 /* synopsis: r[P2]=P1                         */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -15320,12 +15416,12 @@</span>
  #define OP_SorterData    125 /* synopsis: r[P2]=data                       */
  #define OP_RowData       126 /* synopsis: r[P2]=data                       */
  #define OP_Rowid         127 /* synopsis: r[P2]=rowid                      */
  #define OP_NullRow       128
  #define OP_SeekEnd       129
<span class="udiff-line-modified-removed">- #define OP_SorterInsert  130 /* synopsis: key=r[P2]                        */</span>
<span class="udiff-line-modified-removed">- #define OP_IdxInsert     131 /* synopsis: key=r[P2]                        */</span>
<span class="udiff-line-modified-added">+ #define OP_IdxInsert     130 /* synopsis: key=r[P2]                        */</span>
<span class="udiff-line-modified-added">+ #define OP_SorterInsert  131 /* synopsis: key=r[P2]                        */</span>
  #define OP_IdxDelete     132 /* synopsis: key=r[P2@P3]                     */
  #define OP_DeferredSeek  133 /* synopsis: Move P3 to P1.rowid if needed    */
  #define OP_IdxRowid      134 /* synopsis: r[P2]=rowid                      */
  #define OP_FinishSeek    135
  #define OP_Destroy       136
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -15475,10 +15571,11 @@</span>
  SQLITE_PRIVATE void sqlite3VdbeChangeP1(Vdbe*, int addr, int P1);
  SQLITE_PRIVATE void sqlite3VdbeChangeP2(Vdbe*, int addr, int P2);
  SQLITE_PRIVATE void sqlite3VdbeChangeP3(Vdbe*, int addr, int P3);
  SQLITE_PRIVATE void sqlite3VdbeChangeP5(Vdbe*, u16 P5);
  SQLITE_PRIVATE void sqlite3VdbeJumpHere(Vdbe*, int addr);
<span class="udiff-line-added">+ SQLITE_PRIVATE void sqlite3VdbeJumpHereOrPopInst(Vdbe*, int addr);</span>
  SQLITE_PRIVATE int sqlite3VdbeChangeToNoop(Vdbe*, int addr);
  SQLITE_PRIVATE int sqlite3VdbeDeletePriorOpcode(Vdbe*, u8 op);
  #ifdef SQLITE_DEBUG
  SQLITE_PRIVATE   void sqlite3VdbeReleaseRegisters(Parse*,int addr, int n, u32 mask, int);
  #else
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -15534,10 +15631,13 @@</span>
  
  SQLITE_PRIVATE void sqlite3VdbeLinkSubProgram(Vdbe *, SubProgram *);
  SQLITE_PRIVATE int sqlite3VdbeHasSubProgram(Vdbe*);
  
  SQLITE_PRIVATE int sqlite3NotPureFunc(sqlite3_context*);
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_BYTECODE_VTAB</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE int sqlite3VdbeBytecodeVtabInit(sqlite3*);</span>
<span class="udiff-line-added">+ #endif</span>
  
  /* Use SQLITE_ENABLE_COMMENTS to enable generation of extra comments on
  ** each VDBE opcode.
  **
  ** Use the SQLITE_ENABLE_MODULE_COMMENTS macro to see some extra no-op
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -15770,13 +15870,10 @@</span>
  SQLITE_PRIVATE int sqlite3PagerReadFileheader(Pager*, int, unsigned char*);
  
  /* Functions used to configure a Pager object. */
  SQLITE_PRIVATE void sqlite3PagerSetBusyHandler(Pager*, int(*)(void *), void *);
  SQLITE_PRIVATE int sqlite3PagerSetPagesize(Pager*, u32*, int);
<span class="udiff-line-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">- SQLITE_PRIVATE void sqlite3PagerAlignReserve(Pager*,Pager*);</span>
<span class="udiff-line-removed">- #endif</span>
  SQLITE_PRIVATE int sqlite3PagerMaxPageCount(Pager*, int);
  SQLITE_PRIVATE void sqlite3PagerSetCachesize(Pager*, int);
  SQLITE_PRIVATE int sqlite3PagerSetSpillsize(Pager*, int);
  SQLITE_PRIVATE void sqlite3PagerSetMmapLimit(Pager *, sqlite3_int64);
  SQLITE_PRIVATE void sqlite3PagerShrink(Pager*);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -15822,18 +15919,26 @@</span>
  SQLITE_PRIVATE   int sqlite3PagerWalSupported(Pager *pPager);
  SQLITE_PRIVATE   int sqlite3PagerWalCallback(Pager *pPager);
  SQLITE_PRIVATE   int sqlite3PagerOpenWal(Pager *pPager, int *pisOpen);
  SQLITE_PRIVATE   int sqlite3PagerCloseWal(Pager *pPager, sqlite3*);
  # ifdef SQLITE_ENABLE_SNAPSHOT
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE   int sqlite3PagerSnapshotGet(Pager *pPager, sqlite3_snapshot **ppSnapshot);</span>
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE   int sqlite3PagerSnapshotOpen(Pager *pPager, sqlite3_snapshot *pSnapshot);</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE   int sqlite3PagerSnapshotGet(Pager*, sqlite3_snapshot **ppSnapshot);</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE   int sqlite3PagerSnapshotOpen(Pager*, sqlite3_snapshot *pSnapshot);</span>
  SQLITE_PRIVATE   int sqlite3PagerSnapshotRecover(Pager *pPager);
  SQLITE_PRIVATE   int sqlite3PagerSnapshotCheck(Pager *pPager, sqlite3_snapshot *pSnapshot);
  SQLITE_PRIVATE   void sqlite3PagerSnapshotUnlock(Pager *pPager);
  # endif
  #endif
  
<span class="udiff-line-added">+ #if !defined(SQLITE_OMIT_WAL) &amp;&amp; defined(SQLITE_ENABLE_SETLK_TIMEOUT)</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE   int sqlite3PagerWalWriteLock(Pager*, int);</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE   void sqlite3PagerWalDb(Pager*, sqlite3*);</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+ # define sqlite3PagerWalWriteLock(y,z) SQLITE_OK</span>
<span class="udiff-line-added">+ # define sqlite3PagerWalDb(x,y)</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  #ifdef SQLITE_DIRECT_OVERFLOW_READ
  SQLITE_PRIVATE   int sqlite3PagerDirectReadOk(Pager *pPager, Pgno pgno);
  #endif
  
  #ifdef SQLITE_ENABLE_ZIPVFS
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -15855,25 +15960,16 @@</span>
  SQLITE_PRIVATE void *sqlite3PagerTempSpace(Pager*);
  SQLITE_PRIVATE int sqlite3PagerIsMemdb(Pager*);
  SQLITE_PRIVATE void sqlite3PagerCacheStat(Pager *, int, int, int *);
  SQLITE_PRIVATE void sqlite3PagerClearCache(Pager*);
  SQLITE_PRIVATE int sqlite3SectorSize(sqlite3_file *);
<span class="udiff-line-removed">- #ifdef SQLITE_ENABLE_SETLK_TIMEOUT</span>
<span class="udiff-line-removed">- SQLITE_PRIVATE void sqlite3PagerResetLockTimeout(Pager *pPager);</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">- # define sqlite3PagerResetLockTimeout(X)</span>
<span class="udiff-line-removed">- #endif</span>
  
  /* Functions used to truncate the database file. */
  SQLITE_PRIVATE void sqlite3PagerTruncateImage(Pager*,Pgno);
  
  SQLITE_PRIVATE void sqlite3PagerRekey(DbPage*, Pgno, u16);
  
<span class="udiff-line-removed">- #if defined(SQLITE_HAS_CODEC) &amp;&amp; !defined(SQLITE_OMIT_WAL)</span>
<span class="udiff-line-removed">- SQLITE_PRIVATE void *sqlite3PagerCodec(DbPage *);</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
  /* Functions to support testing and debugging. */
  #if !defined(NDEBUG) || defined(SQLITE_TEST)
  SQLITE_PRIVATE   Pgno sqlite3PagerPagenumber(DbPage*);
  SQLITE_PRIVATE   int sqlite3PagerIswriteable(DbPage*);
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -16537,11 +16633,10 @@</span>
  ** have been filled out.  If the schema changes, these column names might
  ** changes and so the view will need to be reset.
  */
  #define DB_SchemaLoaded    0x0001  /* The schema has been loaded */
  #define DB_UnresetViews    0x0002  /* Some views have defined column names */
<span class="udiff-line-removed">- #define DB_Empty           0x0004  /* The file is empty (length 0 bytes) */</span>
  #define DB_ResetWanted     0x0008  /* Reset the schema when nSchemaLock==0 */
  
  /*
  ** The number of different kinds of things that can be limited
  ** using the sqlite3_limit() interface.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -16695,11 +16790,11 @@</span>
  ** Each database connection is an instance of the following structure.
  */
  struct sqlite3 {
    sqlite3_vfs *pVfs;            /* OS Interface */
    struct Vdbe *pVdbe;           /* List of active virtual machines */
<span class="udiff-line-modified-removed">-   CollSeq *pDfltColl;           /* The default collating sequence (BINARY) */</span>
<span class="udiff-line-modified-added">+   CollSeq *pDfltColl;           /* BINARY collseq for the database encoding */</span>
    sqlite3_mutex *mutex;         /* Connection mutex */
    Db *aDb;                      /* All backends */
    int nDb;                      /* Number of backends currently in use */
    u32 mDbFlags;                 /* flags recording internal state */
    u64 flags;                    /* flags settable by pragmas. See below */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -16798,10 +16893,11 @@</span>
    Hash aFunc;                   /* Hash table of connection functions */
    Hash aCollSeq;                /* All collating sequences */
    BusyHandler busyHandler;      /* Busy callback */
    Db aDbStatic[2];              /* Static space for the 2 default backends */
    Savepoint *pSavepoint;        /* List of active savepoints */
<span class="udiff-line-added">+   int nAnalysisLimit;           /* Number of index rows to ANALYZE */</span>
    int busyTimeout;              /* Busy handler timeout, in msec */
    int nSavepoint;               /* Number of non-transaction savepoints */
    int nStatement;               /* Number of nested statement-transactions  */
    i64 nDeferredCons;            /* Net deferred constraints this transaction. */
    i64 nDeferredImmCons;         /* Net deferred immediate constraints */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -16904,10 +17000,11 @@</span>
  #define DBFLAG_PreferBuiltin  0x0002  /* Preference to built-in funcs */
  #define DBFLAG_Vacuum         0x0004  /* Currently in a VACUUM */
  #define DBFLAG_VacuumInto     0x0008  /* Currently running VACUUM INTO */
  #define DBFLAG_SchemaKnownOk  0x0010  /* Schema is known to be valid */
  #define DBFLAG_InternalFunc   0x0020  /* Allow use of internal functions */
<span class="udiff-line-added">+ #define DBFLAG_EncodingFixed  0x0040  /* No longer possible to change enc. */</span>
  
  /*
  ** Bits of the sqlite3.dbOptFlags field that are used by the
  ** sqlite3_test_control(SQLITE_TESTCTRL_OPTIMIZATIONS,...) interface to
  ** selectively disable various optimizations.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17022,11 +17119,11 @@</span>
  #define SQLITE_FUNC_EPHEM    0x0010 /* Ephemeral.  Delete with VDBE */
  #define SQLITE_FUNC_NEEDCOLL 0x0020 /* sqlite3GetFuncCollSeq() might be called*/
  #define SQLITE_FUNC_LENGTH   0x0040 /* Built-in length() function */
  #define SQLITE_FUNC_TYPEOF   0x0080 /* Built-in typeof() function */
  #define SQLITE_FUNC_COUNT    0x0100 /* Built-in count(*) aggregate */
<span class="udiff-line-modified-removed">- #define SQLITE_FUNC_COALESCE 0x0200 /* Built-in coalesce() or ifnull() */</span>
<span class="udiff-line-modified-added">+ /*                           0x0200 -- available for reuse */</span>
  #define SQLITE_FUNC_UNLIKELY 0x0400 /* Built-in unlikely() function */
  #define SQLITE_FUNC_CONSTANT 0x0800 /* Constant inputs give a constant output */
  #define SQLITE_FUNC_MINMAX   0x1000 /* True for min() and max() aggregates */
  #define SQLITE_FUNC_SLOCHNG  0x2000 /* &quot;Slow Change&quot;. Value constant during a
                                      ** single query - might change over time */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17043,10 +17140,11 @@</span>
  #define INLINEFUNC_coalesce             0
  #define INLINEFUNC_implies_nonnull_row  1
  #define INLINEFUNC_expr_implies_expr    2
  #define INLINEFUNC_expr_compare         3
  #define INLINEFUNC_affinity             4
<span class="udiff-line-added">+ #define INLINEFUNC_iif                  5</span>
  #define INLINEFUNC_unlikely            99  /* Default case */
  
  /*
  ** The following three macros, FUNCTION(), LIKEFUNC() and AGGREGATE() are
  ** used to create the initializers for the FuncDef structures.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17207,10 +17305,11 @@</span>
    Expr *pDflt;     /* Default value or GENERATED ALWAYS AS value */
    char *zColl;     /* Collating sequence.  If NULL, use the default */
    u8 notNull;      /* An OE_ code for handling a NOT NULL constraint */
    char affinity;   /* One of the SQLITE_AFF_... values */
    u8 szEst;        /* Estimated size of value in this column. sizeof(INT)==1 */
<span class="udiff-line-added">+   u8 hName;        /* Column name hash for faster lookup */</span>
    u16 colFlags;    /* Boolean properties.  See COLFLAG_ defines below */
  };
  
  /* Allowed values for Column.colFlags:
  */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17426,12 +17525,15 @@</span>
  ** done as a macro so that it will be optimized out when virtual
  ** table support is omitted from the build.
  */
  #ifndef SQLITE_OMIT_VIRTUALTABLE
  #  define IsVirtual(X)      ((X)-&gt;nModuleArg)
<span class="udiff-line-added">+ #  define ExprIsVtab(X)  \</span>
<span class="udiff-line-added">+               ((X)-&gt;op==TK_COLUMN &amp;&amp; (X)-&gt;y.pTab!=0 &amp;&amp; (X)-&gt;y.pTab-&gt;nModuleArg)</span>
  #else
  #  define IsVirtual(X)      0
<span class="udiff-line-added">+ #  define ExprIsVtab(X)     0</span>
  #endif
  
  /*
  ** Macros to determine if a column is hidden.  IsOrdinaryHiddenColumn()
  ** only works for non-virtual tables (ordinary tables and views) and is
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17739,11 +17841,11 @@</span>
  /*
  ** An instance of this structure contains information needed to generate
  ** code for a SELECT that contains aggregate functions.
  **
  ** If Expr.op==TK_AGG_COLUMN or TK_AGG_FUNCTION then Expr.pAggInfo is a
<span class="udiff-line-modified-removed">- ** pointer to this structure.  The Expr.iColumn field is the index in</span>
<span class="udiff-line-modified-added">+ ** pointer to this structure.  The Expr.iAgg field is the index in</span>
  ** AggInfo.aCol[] or AggInfo.aFunc[] of information needed to generate
  ** code for that node.
  **
  ** AggInfo.pGroupBy and AggInfo.aFunc.pExpr point to fields within the
  ** original Select structure that describes the SELECT statement.  These
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17759,15 +17861,15 @@</span>
    int nSortingColumn;     /* Number of columns in the sorting index */
    int mnReg, mxReg;       /* Range of registers allocated for aCol and aFunc */
    ExprList *pGroupBy;     /* The group by clause */
    struct AggInfo_col {    /* For each column used in source tables */
      Table *pTab;             /* Source table */
<span class="udiff-line-added">+     Expr *pExpr;             /* The original expression */</span>
      int iTable;              /* Cursor number of the source table */
<span class="udiff-line-removed">-     int iColumn;             /* Column number within the source table */</span>
<span class="udiff-line-removed">-     int iSorterColumn;       /* Column number in the sorting index */</span>
      int iMem;                /* Memory location that acts as accumulator */
<span class="udiff-line-modified-removed">-     Expr *pExpr;             /* The original expression */</span>
<span class="udiff-line-modified-added">+     i16 iColumn;             /* Column number within the source table */</span>
<span class="udiff-line-added">+     i16 iSorterColumn;       /* Column number in the sorting index */</span>
    } *aCol;
    int nColumn;            /* Number of used entries in aCol[] */
    int nAccumulator;       /* Number of columns that show through to the output.
                            ** Additional columns are used only as parameters to
                            ** aggregate functions */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17776,23 +17878,32 @@</span>
      FuncDef *pFunc;          /* The aggregate function implementation */
      int iMem;                /* Memory location that acts as accumulator */
      int iDistinct;           /* Ephemeral table used to enforce DISTINCT */
    } *aFunc;
    int nFunc;              /* Number of entries in aFunc[] */
<span class="udiff-line-added">+ #ifdef SQLITE_DEBUG</span>
<span class="udiff-line-added">+   int iAggMagic;          /* Magic number when valid */</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   AggInfo *pNext;         /* Next in list of them all */</span>
  };
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Value for AggInfo.iAggMagic when the structure is valid</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ #define AggInfoMagic  0x2059e99e</span>
<span class="udiff-line-added">+ </span>
  /*
  ** The datatype ynVar is a signed integer, either 16-bit or 32-bit.
  ** Usually it is 16-bits.  But if SQLITE_MAX_VARIABLE_NUMBER is greater
  ** than 32767 we have to make it 32-bit.  16-bit is preferred because
  ** it uses less memory in the Expr object, which is a big memory user
  ** in systems with lots of prepared statements.  And few applications
  ** need more than about 10 or 20 variables.  But some extreme users want
<span class="udiff-line-modified-removed">- ** to have prepared statements with over 32767 variables, and for them</span>
<span class="udiff-line-modified-added">+ ** to have prepared statements with over 32766 variables, and for them</span>
  ** the option is available (at compile-time).
  */
<span class="udiff-line-modified-removed">- #if SQLITE_MAX_VARIABLE_NUMBER&lt;=32767</span>
<span class="udiff-line-modified-added">+ #if SQLITE_MAX_VARIABLE_NUMBER&lt;32767</span>
  typedef i16 ynVar;
  #else
  typedef int ynVar;
  #endif
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17864,10 +17975,13 @@</span>
    char affExpr;          /* affinity, or RAISE type */
    u8 op2;                /* TK_REGISTER/TK_TRUTH: original value of Expr.op
                           ** TK_COLUMN: the value of p5 for OP_Column
                           ** TK_AGG_FUNCTION: nesting depth
                           ** TK_FUNCTION: NC_SelfRef flag if needs OP_PureFunc */
<span class="udiff-line-added">+ #ifdef SQLITE_DEBUG</span>
<span class="udiff-line-added">+   u8 vvaFlags;           /* Verification flags. */</span>
<span class="udiff-line-added">+ #endif</span>
    u32 flags;             /* Various flags.  EP_* See below */
    union {
      char *zToken;          /* Token value. Zero terminated and dequoted */
      int iValue;            /* Non-negative integer value if EP_IntValue */
    } u;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17938,11 +18052,11 @@</span>
  #define EP_Skip       0x001000 /* Operator does not contribute to affinity */
  #define EP_Reduced    0x002000 /* Expr struct EXPR_REDUCEDSIZE bytes only */
  #define EP_TokenOnly  0x004000 /* Expr struct EXPR_TOKENONLYSIZE bytes only */
  #define EP_Win        0x008000 /* Contains window functions */
  #define EP_MemToken   0x010000 /* Need to sqlite3DbFree() Expr.zToken */
<span class="udiff-line-modified-removed">- #define EP_NoReduce   0x020000 /* Cannot EXPRDUP_REDUCE this Expr */</span>
<span class="udiff-line-modified-added">+                   /*  0x020000 // available for reuse */</span>
  #define EP_Unlikely   0x040000 /* unlikely() or likelihood() function */
  #define EP_ConstFunc  0x080000 /* A SQLITE_FUNC_CONSTANT or _SLOCHNG function */
  #define EP_CanBeNull  0x100000 /* Can be null despite NOT NULL constraint */
  #define EP_Subquery   0x200000 /* Tree contains a TK_SELECT operator */
  #define EP_Alias      0x400000 /* Is an alias for a result set column */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17952,10 +18066,11 @@</span>
  #define EP_Quoted    0x4000000 /* TK_ID was originally quoted */
  #define EP_Static    0x8000000 /* Held in memory not obtained from malloc() */
  #define EP_IsTrue   0x10000000 /* Always has boolean value of TRUE */
  #define EP_IsFalse  0x20000000 /* Always has boolean value of FALSE */
  #define EP_FromDDL  0x40000000 /* Originates from sqlite_master */
<span class="udiff-line-added">+                /*   0x80000000 // Available */</span>
  
  /*
  ** The EP_Propagate mask is a set of properties that automatically propagate
  ** upwards into parent nodes.
  */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17970,18 +18085,28 @@</span>
  #define ExprSetProperty(E,P)     (E)-&gt;flags|=(P)
  #define ExprClearProperty(E,P)   (E)-&gt;flags&amp;=~(P)
  #define ExprAlwaysTrue(E)   (((E)-&gt;flags&amp;(EP_FromJoin|EP_IsTrue))==EP_IsTrue)
  #define ExprAlwaysFalse(E)  (((E)-&gt;flags&amp;(EP_FromJoin|EP_IsFalse))==EP_IsFalse)
  
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /* Flags for use with Expr.vvaFlags</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ #define EP_NoReduce   0x01  /* Cannot EXPRDUP_REDUCE this Expr */</span>
<span class="udiff-line-added">+ #define EP_Immutable  0x02  /* Do not change this Expr node */</span>
<span class="udiff-line-added">+ </span>
  /* The ExprSetVVAProperty() macro is used for Verification, Validation,
  ** and Accreditation only.  It works like ExprSetProperty() during VVA
  ** processes but is a no-op for delivery.
  */
  #ifdef SQLITE_DEBUG
<span class="udiff-line-modified-removed">- # define ExprSetVVAProperty(E,P)  (E)-&gt;flags|=(P)</span>
<span class="udiff-line-modified-added">+ # define ExprSetVVAProperty(E,P)   (E)-&gt;vvaFlags|=(P)</span>
<span class="udiff-line-added">+ # define ExprHasVVAProperty(E,P)   (((E)-&gt;vvaFlags&amp;(P))!=0)</span>
<span class="udiff-line-added">+ # define ExprClearVVAProperties(E) (E)-&gt;vvaFlags = 0</span>
  #else
  # define ExprSetVVAProperty(E,P)
<span class="udiff-line-added">+ # define ExprHasVVAProperty(E,P)   0</span>
<span class="udiff-line-added">+ # define ExprClearVVAProperties(E)</span>
  #endif
  
  /*
  ** Macros to determine the number of bytes required by a normal Expr
  ** struct, an Expr struct with the EP_Reduced flag set in Expr.flags
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -18344,10 +18469,11 @@</span>
  #define SF_IncludeHidden 0x0020000 /* Include hidden columns in output */
  #define SF_ComplexResult 0x0040000 /* Result contains subquery or function */
  #define SF_WhereBegin    0x0080000 /* Really a WhereBegin() call.  Debug Only */
  #define SF_WinRewrite    0x0100000 /* Window function rewrite accomplished */
  #define SF_View          0x0200000 /* SELECT statement is a view */
<span class="udiff-line-added">+ #define SF_NoopOrderBy   0x0400000 /* ORDER BY is ignored for this query */</span>
  
  /*
  ** The results of a SELECT can be distributed in several ways, as defined
  ** by one of the following macros.  The &quot;SRT&quot; prefix means &quot;SELECT Result
  ** Type&quot;.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -18560,10 +18686,11 @@</span>
  #endif
    AutoincInfo *pAinc;  /* Information about AUTOINCREMENT counters */
    Parse *pToplevel;    /* Parse structure for main program (or NULL) */
    Table *pTriggerTab;  /* Table triggers are being coded for */
    Parse *pParentParse; /* Parent parser if this parser is nested */
<span class="udiff-line-added">+   AggInfo *pAggList;   /* List of all AggInfo objects */</span>
    int addrCrTab;       /* Address of OP_CreateBtree opcode on CREATE TABLE */
    u32 nQueryLoop;      /* Est number of iterations of a query (10*log2(N)) */
    u32 oldmask;         /* Mask of old.* columns referenced */
    u32 newmask;         /* Mask of new.* columns referenced */
    u8 eTriggerOp;       /* TK_UPDATE, TK_INSERT or TK_DELETE */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -18951,10 +19078,11 @@</span>
      Select *pSelect;                          /* HAVING to WHERE clause ctx */
      struct WindowRewrite *pRewrite;           /* Window rewrite context */
      struct WhereConst *pConst;                /* WHERE clause constants */
      struct RenameCtx *pRename;                /* RENAME COLUMN context */
      struct Table *pTab;                       /* Table of generated column */
<span class="udiff-line-added">+     struct SrcList_item *pSrcItem;            /* A single FROM clause item */</span>
    } u;
  };
  
  /* Forward declarations */
  SQLITE_PRIVATE int sqlite3WalkExpr(Walker*, Expr*);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -18963,10 +19091,13 @@</span>
  SQLITE_PRIVATE int sqlite3WalkSelectExpr(Walker*, Select*);
  SQLITE_PRIVATE int sqlite3WalkSelectFrom(Walker*, Select*);
  SQLITE_PRIVATE int sqlite3ExprWalkNoop(Walker*, Expr*);
  SQLITE_PRIVATE int sqlite3SelectWalkNoop(Walker*, Select*);
  SQLITE_PRIVATE int sqlite3SelectWalkFail(Walker*, Select*);
<span class="udiff-line-added">+ SQLITE_PRIVATE int sqlite3WalkerDepthIncrease(Walker*,Select*);</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE void sqlite3WalkerDepthDecrease(Walker*,Select*);</span>
<span class="udiff-line-added">+ </span>
  #ifdef SQLITE_DEBUG
  SQLITE_PRIVATE void sqlite3SelectWalkAssert2(Walker*, Select*);
  #endif
  
  /*
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -19107,17 +19238,20 @@</span>
  #define SQLITE_MISUSE_BKPT sqlite3MisuseError(__LINE__)
  #define SQLITE_CANTOPEN_BKPT sqlite3CantopenError(__LINE__)
  #ifdef SQLITE_DEBUG
  SQLITE_PRIVATE   int sqlite3NomemError(int);
  SQLITE_PRIVATE   int sqlite3IoerrnomemError(int);
<span class="udiff-line-removed">- SQLITE_PRIVATE   int sqlite3CorruptPgnoError(int,Pgno);</span>
  # define SQLITE_NOMEM_BKPT sqlite3NomemError(__LINE__)
  # define SQLITE_IOERR_NOMEM_BKPT sqlite3IoerrnomemError(__LINE__)
<span class="udiff-line-removed">- # define SQLITE_CORRUPT_PGNO(P) sqlite3CorruptPgnoError(__LINE__,(P))</span>
  #else
  # define SQLITE_NOMEM_BKPT SQLITE_NOMEM
  # define SQLITE_IOERR_NOMEM_BKPT SQLITE_IOERR_NOMEM
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ #if defined(SQLITE_DEBUG) || defined(SQLITE_ENABLE_CORRUPT_PGNO)</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE   int sqlite3CorruptPgnoError(int,Pgno);</span>
<span class="udiff-line-added">+ # define SQLITE_CORRUPT_PGNO(P) sqlite3CorruptPgnoError(__LINE__,(P))</span>
<span class="udiff-line-added">+ #else</span>
  # define SQLITE_CORRUPT_PGNO(P) sqlite3CorruptError(__LINE__)
  #endif
  
  /*
  ** FTS3 and FTS4 both require virtual table support
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -19383,15 +19517,11 @@</span>
  SQLITE_PRIVATE void sqlite3AddCollateType(Parse*, Token*);
  SQLITE_PRIVATE void sqlite3AddGenerated(Parse*,Expr*,Token*);
  SQLITE_PRIVATE void sqlite3EndTable(Parse*,Token*,Token*,u8,Select*);
  SQLITE_PRIVATE int sqlite3ParseUri(const char*,const char*,unsigned int*,
                      sqlite3_vfs**,char**,char **);
<span class="udiff-line-modified-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">- SQLITE_PRIVATE   int sqlite3CodecQueryParameters(sqlite3*,const char*,const char*);</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">- # define sqlite3CodecQueryParameters(A,B,C) 0</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+ #define sqlite3CodecQueryParameters(A,B,C) 0</span>
  SQLITE_PRIVATE Btree *sqlite3DbNameToBtree(sqlite3*,const char*);
  
  #ifdef SQLITE_UNTESTABLE
  # define sqlite3FaultSim(X) SQLITE_OK
  #else
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -19496,11 +19626,11 @@</span>
  #ifndef SQLITE_OMIT_GENERATED_COLUMNS
  SQLITE_PRIVATE void sqlite3ExprCodeGeneratedColumn(Parse*, Column*, int);
  #endif
  SQLITE_PRIVATE void sqlite3ExprCodeCopy(Parse*, Expr*, int);
  SQLITE_PRIVATE void sqlite3ExprCodeFactorable(Parse*, Expr*, int);
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE int sqlite3ExprCodeAtInit(Parse*, Expr*, int);</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE int sqlite3ExprCodeRunJustOnce(Parse*, Expr*, int);</span>
  SQLITE_PRIVATE int sqlite3ExprCodeTemp(Parse*, Expr*, int*);
  SQLITE_PRIVATE int sqlite3ExprCodeTarget(Parse*, Expr*, int);
  SQLITE_PRIVATE int sqlite3ExprCodeExprList(Parse*, ExprList*, int, int, u8);
  #define SQLITE_ECEL_DUP      0x01  /* Deep, not shallow copies */
  #define SQLITE_ECEL_FACTOR   0x02  /* Factor out constant terms */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -19523,10 +19653,11 @@</span>
  SQLITE_PRIVATE int sqlite3ExprCompare(Parse*,Expr*, Expr*, int);
  SQLITE_PRIVATE int sqlite3ExprCompareSkip(Expr*, Expr*, int);
  SQLITE_PRIVATE int sqlite3ExprListCompare(ExprList*, ExprList*, int);
  SQLITE_PRIVATE int sqlite3ExprImpliesExpr(Parse*,Expr*, Expr*, int);
  SQLITE_PRIVATE int sqlite3ExprImpliesNonNullRow(Expr*,int);
<span class="udiff-line-added">+ SQLITE_PRIVATE void sqlite3AggInfoPersistWalkerInit(Walker*,Parse*);</span>
  SQLITE_PRIVATE void sqlite3ExprAnalyzeAggregates(NameContext*, Expr*);
  SQLITE_PRIVATE void sqlite3ExprAnalyzeAggList(NameContext*,ExprList*);
  SQLITE_PRIVATE int sqlite3ExprCoveredByIndex(Expr*, int iCur, Index *pIdx);
  SQLITE_PRIVATE int sqlite3FunctionUsesThisSrc(Expr*, SrcList*);
  SQLITE_PRIVATE Vdbe *sqlite3GetVdbe(Parse*);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -19651,10 +19782,11 @@</span>
  # define sqlite3AuthRead(a,b,c,d)
  # define sqlite3AuthCheck(a,b,c,d,e)    SQLITE_OK
  # define sqlite3AuthContextPush(a,b,c)
  # define sqlite3AuthContextPop(a)  ((void)(a))
  #endif
<span class="udiff-line-added">+ SQLITE_PRIVATE int sqlite3DbIsNamed(sqlite3 *db, int iDb, const char *zName);</span>
  SQLITE_PRIVATE void sqlite3Attach(Parse*, Expr*, Expr*, Expr*);
  SQLITE_PRIVATE void sqlite3Detach(Parse*, Expr*);
  SQLITE_PRIVATE void sqlite3FixInit(DbFixer*, Parse*, int, const char*, const Token*);
  SQLITE_PRIVATE int sqlite3FixSrcList(DbFixer*, SrcList*);
  SQLITE_PRIVATE int sqlite3FixSelect(DbFixer*, Select*);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -19699,23 +19831,25 @@</span>
  ** macros handle the common case without a procedure call, but then call
  ** the procedure for larger varints.
  */
  #define getVarint32(A,B)  \
    (u8)((*(A)&lt;(u8)0x80)?((B)=(u32)*(A)),1:sqlite3GetVarint32((A),(u32 *)&amp;(B)))
<span class="udiff-line-added">+ #define getVarint32NR(A,B) \</span>
<span class="udiff-line-added">+   B=(u32)*(A);if(B&gt;=0x80)sqlite3GetVarint32((A),(u32*)&amp;(B))</span>
  #define putVarint32(A,B)  \
    (u8)(((u32)(B)&lt;(u32)0x80)?(*(A)=(unsigned char)(B)),1:\
    sqlite3PutVarint((A),(B)))
  #define getVarint    sqlite3GetVarint
  #define putVarint    sqlite3PutVarint
  
  
  SQLITE_PRIVATE const char *sqlite3IndexAffinityStr(sqlite3*, Index*);
  SQLITE_PRIVATE void sqlite3TableAffinity(Vdbe*, Table*, int);
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE char sqlite3CompareAffinity(Expr *pExpr, char aff2);</span>
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE int sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity);</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE char sqlite3CompareAffinity(const Expr *pExpr, char aff2);</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE int sqlite3IndexAffinityOk(const Expr *pExpr, char idx_affinity);</span>
  SQLITE_PRIVATE char sqlite3TableColumnAffinity(Table*,int);
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE char sqlite3ExprAffinity(Expr *pExpr);</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE char sqlite3ExprAffinity(const Expr *pExpr);</span>
  SQLITE_PRIVATE int sqlite3Atoi64(const char*, i64*, int, u8);
  SQLITE_PRIVATE int sqlite3DecOrHexToI64(const char*, i64*);
  SQLITE_PRIVATE void sqlite3ErrorWithMsg(sqlite3*, int, const char*,...);
  SQLITE_PRIVATE void sqlite3Error(sqlite3*,int);
  SQLITE_PRIVATE void sqlite3SystemError(sqlite3*,int);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -19734,13 +19868,14 @@</span>
  SQLITE_PRIVATE const char *sqlite3ErrStr(int);
  SQLITE_PRIVATE int sqlite3ReadSchema(Parse *pParse);
  SQLITE_PRIVATE CollSeq *sqlite3FindCollSeq(sqlite3*,u8 enc, const char*,int);
  SQLITE_PRIVATE int sqlite3IsBinary(const CollSeq*);
  SQLITE_PRIVATE CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char*zName);
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr);</span>
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE CollSeq *sqlite3ExprNNCollSeq(Parse *pParse, Expr *pExpr);</span>
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE int sqlite3ExprCollSeqMatch(Parse*,Expr*,Expr*);</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE void sqlite3SetTextEncoding(sqlite3 *db, u8);</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE CollSeq *sqlite3ExprCollSeq(Parse *pParse, const Expr *pExpr);</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE CollSeq *sqlite3ExprNNCollSeq(Parse *pParse, const Expr *pExpr);</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE int sqlite3ExprCollSeqMatch(Parse*,const Expr*,const Expr*);</span>
  SQLITE_PRIVATE Expr *sqlite3ExprAddCollateToken(Parse *pParse, Expr*, const Token*, int);
  SQLITE_PRIVATE Expr *sqlite3ExprAddCollateString(Parse*,Expr*,const char*);
  SQLITE_PRIVATE Expr *sqlite3ExprSkipCollate(Expr*);
  SQLITE_PRIVATE Expr *sqlite3ExprSkipCollateAndLikely(Expr*);
  SQLITE_PRIVATE int sqlite3CheckCollSeq(Parse *, CollSeq *);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -19803,10 +19938,12 @@</span>
    const struct ExprList_item*,
    const char*,
    const char*,
    const char*
  );
<span class="udiff-line-added">+ SQLITE_PRIVATE Bitmask sqlite3ExprColUsed(Expr*);</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE u8 sqlite3StrIHash(const char*);</span>
  SQLITE_PRIVATE int sqlite3ResolveExprNames(NameContext*, Expr*);
  SQLITE_PRIVATE int sqlite3ResolveExprListNames(NameContext*, ExprList*);
  SQLITE_PRIVATE void sqlite3ResolveSelectNames(Parse*, Select*, NameContext*);
  SQLITE_PRIVATE int sqlite3ResolveSelfReference(Parse*,Table*,int,Expr*,ExprList*);
  SQLITE_PRIVATE int sqlite3ResolveOrderGroupBy(Parse*, Select*, ExprList*, const char*);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -19818,11 +19955,11 @@</span>
  SQLITE_PRIVATE void sqlite3RenameExprUnmap(Parse*, Expr*);
  SQLITE_PRIVATE void sqlite3RenameExprlistUnmap(Parse*, ExprList*);
  SQLITE_PRIVATE CollSeq *sqlite3GetCollSeq(Parse*, u8, CollSeq *, const char*);
  SQLITE_PRIVATE char sqlite3AffinityType(const char*, Column*);
  SQLITE_PRIVATE void sqlite3Analyze(Parse*, Token*, Token*);
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE int sqlite3InvokeBusyHandler(BusyHandler*, sqlite3_file*);</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE int sqlite3InvokeBusyHandler(BusyHandler*);</span>
  SQLITE_PRIVATE int sqlite3FindDb(sqlite3*, Token*);
  SQLITE_PRIVATE int sqlite3FindDbName(sqlite3 *, const char *);
  SQLITE_PRIVATE int sqlite3AnalysisLoad(sqlite3*,int iDB);
  SQLITE_PRIVATE void sqlite3DeleteIndexSamples(sqlite3*,Index*);
  SQLITE_PRIVATE void sqlite3DefaultRowEst(Index*);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -19943,12 +20080,14 @@</span>
  #  define sqlite3VtabInSync(db) ((db)-&gt;nVTrans&gt;0 &amp;&amp; (db)-&gt;aVTrans==0)
  #endif
  SQLITE_PRIVATE int sqlite3ReadOnlyShadowTables(sqlite3 *db);
  #ifndef SQLITE_OMIT_VIRTUALTABLE
  SQLITE_PRIVATE   int sqlite3ShadowTableName(sqlite3 *db, const char *zName);
<span class="udiff-line-added">+ SQLITE_PRIVATE   int sqlite3IsShadowTableOf(sqlite3*,Table*,const char*);</span>
  #else
  # define sqlite3ShadowTableName(A,B) 0
<span class="udiff-line-added">+ # define sqlite3IsShadowTableOf(A,B,C) 0</span>
  #endif
  SQLITE_PRIVATE int sqlite3VtabEponymousTableInit(Parse*,Module*);
  SQLITE_PRIVATE void sqlite3VtabEponymousTableClear(sqlite3*,Module*);
  SQLITE_PRIVATE void sqlite3VtabMakeWritable(Parse*,Table*);
  SQLITE_PRIVATE void sqlite3VtabBeginParse(Parse*, Token*, Token*, Token*, int);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -19967,12 +20106,12 @@</span>
  #ifdef SQLITE_ENABLE_NORMALIZE
  SQLITE_PRIVATE char *sqlite3Normalize(Vdbe*, const char*);
  #endif
  SQLITE_PRIVATE int sqlite3Reprepare(Vdbe*);
  SQLITE_PRIVATE void sqlite3ExprListCheckLength(Parse*, ExprList*, const char*);
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE CollSeq *sqlite3ExprCompareCollSeq(Parse*,Expr*);</span>
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE CollSeq *sqlite3BinaryCompareCollSeq(Parse *, Expr *, Expr *);</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE CollSeq *sqlite3ExprCompareCollSeq(Parse*,const Expr*);</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE CollSeq *sqlite3BinaryCompareCollSeq(Parse *, const Expr*, const Expr*);</span>
  SQLITE_PRIVATE int sqlite3TempInMemory(const sqlite3*);
  SQLITE_PRIVATE const char *sqlite3JournalModename(int);
  #ifndef SQLITE_OMIT_WAL
  SQLITE_PRIVATE   int sqlite3Checkpoint(sqlite3*, int, int, int*, int*);
  SQLITE_PRIVATE   int sqlite3WalDefaultHook(void*,sqlite3*,const char*,int);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -20322,20 +20461,13 @@</span>
  ** using the SQLITE_USE_URI=1 or SQLITE_USE_URI=0 compile-time options.
  **
  ** EVIDENCE-OF: R-43642-56306 By default, URI handling is globally
  ** disabled. The default value may be changed by compiling with the
  ** SQLITE_USE_URI symbol defined.
<span class="udiff-line-removed">- **</span>
<span class="udiff-line-removed">- ** URI filenames are enabled by default if SQLITE_HAS_CODEC is</span>
<span class="udiff-line-removed">- ** enabled.</span>
  */
  #ifndef SQLITE_USE_URI
<span class="udiff-line-modified-removed">- # ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">- #  define SQLITE_USE_URI 1</span>
<span class="udiff-line-removed">- # else</span>
<span class="udiff-line-removed">- #  define SQLITE_USE_URI 0</span>
<span class="udiff-line-removed">- # endif</span>
<span class="udiff-line-modified-added">+ # define SQLITE_USE_URI 0</span>
  #endif
  
  /* EVIDENCE-OF: R-38720-18127 The default setting is determined by the
  ** SQLITE_ALLOW_COVERING_INDEX_SCAN compile-time option, or is &quot;on&quot; if
  ** that compile-time option is omitted.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -20561,11 +20693,12 @@</span>
  /*
  ** VDBE_DISPLAY_P4 is true or false depending on whether or not the
  ** &quot;explain&quot; P4 display logic is enabled.
  */
  #if !defined(SQLITE_OMIT_EXPLAIN) || !defined(NDEBUG) \
<span class="udiff-line-modified-removed">-      || defined(VDBE_PROFILE) || defined(SQLITE_DEBUG)</span>
<span class="udiff-line-modified-added">+      || defined(VDBE_PROFILE) || defined(SQLITE_DEBUG) \</span>
<span class="udiff-line-added">+      || defined(SQLITE_ENABLE_BYTECODE_VTAB)</span>
  # define VDBE_DISPLAY_P4 1
  #else
  # define VDBE_DISPLAY_P4 0
  #endif
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -20948,13 +21081,13 @@</span>
  #endif
    u16 nResColumn;         /* Number of columns in one row of the result set */
    u8 errorAction;         /* Recovery action to do in case of an error */
    u8 minWriteFileFormat;  /* Minimum file format for writable database files */
    u8 prepFlags;           /* SQLITE_PREPARE_* flags */
<span class="udiff-line-added">+   u8 doingRerun;          /* True if rerunning after an auto-reprepare */</span>
    bft expired:2;          /* 1: recompile VM immediately  2: when convenient */
    bft explain:2;          /* True if EXPLAIN present on SQL command */
<span class="udiff-line-removed">-   bft doingRerun:1;       /* True if rerunning after an auto-reprepare */</span>
    bft changeCntOn:1;      /* True to update the change-counter */
    bft runOnlyOnce:1;      /* Automatically expire on reset */
    bft usesStmtJournal:1;  /* True if uses a statement journal */
    bft readOnly:1;         /* True for statements that do not write */
    bft bIsReader:1;        /* True for statements that read */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -21026,11 +21159,18 @@</span>
  
  int sqlite2BtreeKeyCompare(BtCursor *, const void *, int, int, int *);
  SQLITE_PRIVATE int sqlite3VdbeIdxKeyCompare(sqlite3*,VdbeCursor*,UnpackedRecord*,int*);
  SQLITE_PRIVATE int sqlite3VdbeIdxRowid(sqlite3*, BtCursor*, i64*);
  SQLITE_PRIVATE int sqlite3VdbeExec(Vdbe*);
<span class="udiff-line-modified-removed">- #ifndef SQLITE_OMIT_EXPLAIN</span>
<span class="udiff-line-modified-added">+ #if !defined(SQLITE_OMIT_EXPLAIN) || defined(SQLITE_ENABLE_BYTECODE_VTAB)</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE int sqlite3VdbeNextOpcode(Vdbe*,Mem*,int,int*,int*,Op**);</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE char *sqlite3VdbeDisplayP4(sqlite3*,Op*);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ #if defined(SQLITE_ENABLE_EXPLAIN_COMMENTS)</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE char *sqlite3VdbeDisplayComment(sqlite3*,const Op*,const char*);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ #if !defined(SQLITE_OMIT_EXPLAIN)</span>
  SQLITE_PRIVATE int sqlite3VdbeList(Vdbe*);
  #endif
  SQLITE_PRIVATE int sqlite3VdbeHalt(Vdbe*);
  SQLITE_PRIVATE int sqlite3VdbeChangeEncoding(Mem *, int);
  SQLITE_PRIVATE int sqlite3VdbeMemTooBig(Mem*);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -21062,16 +21202,17 @@</span>
  SQLITE_PRIVATE void sqlite3VdbeIntegerAffinity(Mem*);
  SQLITE_PRIVATE int sqlite3VdbeMemRealify(Mem*);
  SQLITE_PRIVATE int sqlite3VdbeMemNumerify(Mem*);
  SQLITE_PRIVATE int sqlite3VdbeMemCast(Mem*,u8,u8);
  SQLITE_PRIVATE int sqlite3VdbeMemFromBtree(BtCursor*,u32,u32,Mem*);
<span class="udiff-line-added">+ SQLITE_PRIVATE int sqlite3VdbeMemFromBtreeZeroOffset(BtCursor*,u32,Mem*);</span>
  SQLITE_PRIVATE void sqlite3VdbeMemRelease(Mem *p);
  SQLITE_PRIVATE int sqlite3VdbeMemFinalize(Mem*, FuncDef*);
  #ifndef SQLITE_OMIT_WINDOWFUNC
  SQLITE_PRIVATE int sqlite3VdbeMemAggValue(Mem*, Mem*, FuncDef*);
  #endif
<span class="udiff-line-modified-removed">- #ifndef SQLITE_OMIT_EXPLAIN</span>
<span class="udiff-line-modified-added">+ #if !defined(SQLITE_OMIT_EXPLAIN) || defined(SQLITE_ENABLE_BYTECODE_VTAB)</span>
  SQLITE_PRIVATE const char *sqlite3OpcodeName(int);
  #endif
  SQLITE_PRIVATE int sqlite3VdbeMemGrow(Mem *pMem, int n, int preserve);
  SQLITE_PRIVATE int sqlite3VdbeMemClearAndResize(Mem *pMem, int n);
  SQLITE_PRIVATE int sqlite3VdbeCloseStatement(Vdbe *, int);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -22147,16 +22288,16 @@</span>
    u8 nName;           /* Length of th name */
    char *zName;        /* Name of the transformation */
    double rLimit;      /* Maximum NNN value for this transform */
    double rXform;      /* Constant used for this transform */
  } aXformType[] = {
<span class="udiff-line-modified-removed">-   { 0, 6, &quot;second&quot;, 464269060800.0, 86400000.0/(24.0*60.0*60.0) },</span>
<span class="udiff-line-modified-removed">-   { 0, 6, &quot;minute&quot;, 7737817680.0,   86400000.0/(24.0*60.0)      },</span>
<span class="udiff-line-modified-removed">-   { 0, 4, &quot;hour&quot;,   128963628.0,    86400000.0/24.0             },</span>
<span class="udiff-line-modified-removed">-   { 0, 3, &quot;day&quot;,    5373485.0,      86400000.0                  },</span>
<span class="udiff-line-modified-removed">-   { 1, 5, &quot;month&quot;,  176546.0,       30.0*86400000.0             },</span>
<span class="udiff-line-modified-removed">-   { 2, 4, &quot;year&quot;,   14713.0,        365.0*86400000.0            },</span>
<span class="udiff-line-modified-added">+   { 0, 6, &quot;second&quot;, 464269060800.0, 1000.0         },</span>
<span class="udiff-line-modified-added">+   { 0, 6, &quot;minute&quot;, 7737817680.0,   60000.0        },</span>
<span class="udiff-line-modified-added">+   { 0, 4, &quot;hour&quot;,   128963628.0,    3600000.0      },</span>
<span class="udiff-line-modified-added">+   { 0, 3, &quot;day&quot;,    5373485.0,      86400000.0     },</span>
<span class="udiff-line-modified-added">+   { 1, 5, &quot;month&quot;,  176546.0,       2592000000.0   },</span>
<span class="udiff-line-modified-added">+   { 2, 4, &quot;year&quot;,   14713.0,        31536000000.0  },</span>
  };
  
  /*
  ** Process a modifier to a date-time stamp.  The modifiers are
  ** as follows:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -25712,10 +25853,11 @@</span>
  
  #ifdef SQLITE_DEBUG
    GLOBAL(int, mutexIsInit) = 1;
  #endif
  
<span class="udiff-line-added">+   sqlite3MemoryBarrier();</span>
    return rc;
  }
  
  /*
  ** Shutdown the mutex system. This call frees resources allocated by
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -27239,11 +27381,11 @@</span>
    if( mem0.hardLimit&gt;0 &amp;&amp; (n&gt;mem0.hardLimit || n==0) ){
      n = mem0.hardLimit;
    }
    mem0.alarmThreshold = n;
    nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);
<span class="udiff-line-modified-removed">-   mem0.nearlyFull = (n&gt;0 &amp;&amp; n&lt;=nUsed);</span>
<span class="udiff-line-modified-added">+   AtomicStore(&amp;mem0.nearlyFull, n&gt;0 &amp;&amp; n&lt;=nUsed);</span>
    sqlite3_mutex_leave(mem0.mutex);
    excess = sqlite3_memory_used() - n;
    if( excess&gt;0 ) sqlite3_release_memory((int)(excess &amp; 0x7fffffff));
    return priorLimit;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -27307,11 +27449,11 @@</span>
  ** Return true if the heap is currently under memory pressure - in other
  ** words if the amount of heap used is close to the limit set by
  ** sqlite3_soft_heap_limit().
  */
  SQLITE_PRIVATE int sqlite3HeapNearlyFull(void){
<span class="udiff-line-modified-removed">-   return mem0.nearlyFull;</span>
<span class="udiff-line-modified-added">+   return AtomicLoad(&amp;mem0.nearlyFull);</span>
  }
  
  /*
  ** Deinitialize the memory allocation subsystem.
  */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -27371,21 +27513,21 @@</span>
  
    sqlite3StatusHighwater(SQLITE_STATUS_MALLOC_SIZE, n);
    if( mem0.alarmThreshold&gt;0 ){
      sqlite3_int64 nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);
      if( nUsed &gt;= mem0.alarmThreshold - nFull ){
<span class="udiff-line-modified-removed">-       mem0.nearlyFull = 1;</span>
<span class="udiff-line-modified-added">+       AtomicStore(&amp;mem0.nearlyFull, 1);</span>
        sqlite3MallocAlarm(nFull);
        if( mem0.hardLimit ){
          nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);
          if( nUsed &gt;= mem0.hardLimit - nFull ){
            *pp = 0;
            return;
          }
        }
      }else{
<span class="udiff-line-modified-removed">-       mem0.nearlyFull = 0;</span>
<span class="udiff-line-modified-added">+       AtomicStore(&amp;mem0.nearlyFull, 0);</span>
      }
    }
    p = sqlite3GlobalConfig.m.xMalloc(nFull);
  #ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
    if( p==0 &amp;&amp; mem0.alarmThreshold&gt;0 ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -27610,14 +27752,16 @@</span>
      if( nDiff&gt;0 &amp;&amp; sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED) &gt;=
            mem0.alarmThreshold-nDiff ){
        sqlite3MallocAlarm(nDiff);
      }
      pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew);
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT</span>
      if( pNew==0 &amp;&amp; mem0.alarmThreshold&gt;0 ){
        sqlite3MallocAlarm((int)nBytes);
        pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew);
      }
<span class="udiff-line-added">+ #endif</span>
      if( pNew ){
        nNew = sqlite3MallocSize(pNew);
        sqlite3StatusUp(SQLITE_STATUS_MEMORY_USED, nNew-nOld);
      }
      sqlite3_mutex_leave(mem0.mutex);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -27798,11 +27942,11 @@</span>
        }
      }else{
        assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
        assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
        sqlite3MemdebugSetType(p, MEMTYPE_HEAP);
<span class="udiff-line-modified-removed">-       pNew = sqlite3_realloc64(p, n);</span>
<span class="udiff-line-modified-added">+       pNew = sqlite3Realloc(p, n);</span>
        if( !pNew ){
          sqlite3OomFault(db);
        }
        sqlite3MemdebugSetType(pNew,
              (db-&gt;lookaside.bDisable==0 ? MEMTYPE_LOOKASIDE : MEMTYPE_HEAP));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -27888,11 +28032,11 @@</span>
  */
  SQLITE_PRIVATE void sqlite3OomFault(sqlite3 *db){
    if( db-&gt;mallocFailed==0 &amp;&amp; db-&gt;bBenignMalloc==0 ){
      db-&gt;mallocFailed = 1;
      if( db-&gt;nVdbeExec&gt;0 ){
<span class="udiff-line-modified-removed">-       db-&gt;u1.isInterrupted = 1;</span>
<span class="udiff-line-modified-added">+       AtomicStore(&amp;db-&gt;u1.isInterrupted, 1);</span>
      }
      DisableLookaside;
      if( db-&gt;pParse ){
        db-&gt;pParse-&gt;rc = SQLITE_NOMEM_BKPT;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -27907,11 +28051,11 @@</span>
  ** VDBEs.
  */
  SQLITE_PRIVATE void sqlite3OomClear(sqlite3 *db){
    if( db-&gt;mallocFailed &amp;&amp; db-&gt;nVdbeExec==0 ){
      db-&gt;mallocFailed = 0;
<span class="udiff-line-modified-removed">-     db-&gt;u1.isInterrupted = 0;</span>
<span class="udiff-line-modified-added">+     AtomicStore(&amp;db-&gt;u1.isInterrupted, 0);</span>
      assert( db-&gt;lookaside.bDisable&gt;0 );
      EnableLookaside;
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -28145,10 +28289,17 @@</span>
  #ifndef SQLITE_PRINT_BUF_SIZE
  # define SQLITE_PRINT_BUF_SIZE 70
  #endif
  #define etBUFSIZE SQLITE_PRINT_BUF_SIZE  /* Size of the output buffer */
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Hard limit on the precision of floating-point conversions.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ #ifndef SQLITE_PRINTF_PRECISION_LIMIT</span>
<span class="udiff-line-added">+ # define SQLITE_FP_PRECISION_LIMIT 100000000</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  /*
  ** Render a string given by &quot;fmt&quot; into the StrAccum object.
  */
  SQLITE_API void sqlite3_str_vappendf(
    sqlite3_str *pAccum,       /* Accumulate results here */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -28345,10 +28496,12 @@</span>
      **   precision                   The specified precision.  The default
      **                               is -1.
      **   xtype                       The class of the conversion.
      **   infop                       Pointer to the appropriate info struct.
      */
<span class="udiff-line-added">+     assert( width&gt;=0 );</span>
<span class="udiff-line-added">+     assert( precision&gt;=(-1) );</span>
      switch( xtype ){
        case etPOINTER:
          flag_long = sizeof(char*)==sizeof(i64) ? 2 :
                       sizeof(char*)==sizeof(long int) ? 1 : 0;
          /* Fall through into the next case */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -28466,10 +28619,15 @@</span>
          }
  #ifdef SQLITE_OMIT_FLOATING_POINT
          length = 0;
  #else
          if( precision&lt;0 ) precision = 6;         /* Set default precision */
<span class="udiff-line-added">+ #ifdef SQLITE_FP_PRECISION_LIMIT</span>
<span class="udiff-line-added">+         if( precision&gt;SQLITE_FP_PRECISION_LIMIT ){</span>
<span class="udiff-line-added">+           precision = SQLITE_FP_PRECISION_LIMIT;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ #endif</span>
          if( realvalue&lt;0.0 ){
            realvalue = -realvalue;
            prefix = &#39;-&#39;;
          }else{
            prefix = flag_prefix;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -28748,11 +28906,11 @@</span>
          }else{
            escarg = va_arg(ap,char*);
          }
          isnull = escarg==0;
          if( isnull ) escarg = (xtype==etSQLESCAPE2 ? &quot;NULL&quot; : &quot;(NULL)&quot;);
<span class="udiff-line-modified-removed">-         /* For %q, %Q, and %w, the precision is the number of byte (or</span>
<span class="udiff-line-modified-added">+         /* For %q, %Q, and %w, the precision is the number of bytes (or</span>
          ** characters if the ! flags is present) to use from the input.
          ** Because of the extra quoting characters inserted, the number
          ** of output characters may be larger than the precision.
          */
          k = precision;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -28875,11 +29033,11 @@</span>
        p-&gt;nAlloc = (int)szNew;
      }
      if( p-&gt;db ){
        zNew = sqlite3DbRealloc(p-&gt;db, zOld, p-&gt;nAlloc);
      }else{
<span class="udiff-line-modified-removed">-       zNew = sqlite3_realloc64(zOld, p-&gt;nAlloc);</span>
<span class="udiff-line-modified-added">+       zNew = sqlite3Realloc(zOld, p-&gt;nAlloc);</span>
      }
      if( zNew ){
        assert( p-&gt;zText!=0 || p-&gt;nChar==0 );
        if( !isMalloced(p) &amp;&amp; p-&gt;nChar&gt;0 ) memcpy(zNew, p-&gt;zText, p-&gt;nChar);
        p-&gt;zText = zNew;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -29217,11 +29375,11 @@</span>
  ** and segfaults if you give it a long long int.
  */
  SQLITE_PRIVATE void sqlite3DebugPrintf(const char *zFormat, ...){
    va_list ap;
    StrAccum acc;
<span class="udiff-line-modified-removed">-   char zBuf[500];</span>
<span class="udiff-line-modified-added">+   char zBuf[SQLITE_PRINT_BUF_SIZE*10];</span>
    sqlite3StrAccumInit(&amp;acc, 0, zBuf, sizeof(zBuf), 0);
    va_start(ap,zFormat);
    sqlite3_str_vappendf(&amp;acc, zFormat, ap);
    va_end(ap);
    sqlite3StrAccumFinish(&amp;acc);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -29389,12 +29547,12 @@</span>
        sqlite3_str_appendf(&amp;x, &quot; %s.%s&quot;, pItem-&gt;zDatabase, pItem-&gt;zName);
      }else if( pItem-&gt;zName ){
        sqlite3_str_appendf(&amp;x, &quot; %s&quot;, pItem-&gt;zName);
      }
      if( pItem-&gt;pTab ){
<span class="udiff-line-modified-removed">-       sqlite3_str_appendf(&amp;x, &quot; tab=%Q nCol=%d ptr=%p&quot;,</span>
<span class="udiff-line-modified-removed">-            pItem-&gt;pTab-&gt;zName, pItem-&gt;pTab-&gt;nCol, pItem-&gt;pTab);</span>
<span class="udiff-line-modified-added">+       sqlite3_str_appendf(&amp;x, &quot; tab=%Q nCol=%d ptr=%p used=%llx&quot;,</span>
<span class="udiff-line-modified-added">+            pItem-&gt;pTab-&gt;zName, pItem-&gt;pTab-&gt;nCol, pItem-&gt;pTab, pItem-&gt;colUsed);</span>
      }
      if( pItem-&gt;zAlias ){
        sqlite3_str_appendf(&amp;x, &quot; (AS %s)&quot;, pItem-&gt;zAlias);
      }
      if( pItem-&gt;fg.jointype &amp; JT_LEFT ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -29649,28 +29807,31 @@</span>
  ** Generate a human-readable explanation of an expression tree.
  */
  SQLITE_PRIVATE void sqlite3TreeViewExpr(TreeView *pView, const Expr *pExpr, u8 moreToFollow){
    const char *zBinOp = 0;   /* Binary operator */
    const char *zUniOp = 0;   /* Unary operator */
<span class="udiff-line-modified-removed">-   char zFlgs[60];</span>
<span class="udiff-line-modified-added">+   char zFlgs[200];</span>
    pView = sqlite3TreeViewPush(pView, moreToFollow);
    if( pExpr==0 ){
      sqlite3TreeViewLine(pView, &quot;nil&quot;);
      sqlite3TreeViewPop(pView);
      return;
    }
<span class="udiff-line-modified-removed">-   if( pExpr-&gt;flags || pExpr-&gt;affExpr ){</span>
<span class="udiff-line-modified-added">+   if( pExpr-&gt;flags || pExpr-&gt;affExpr || pExpr-&gt;vvaFlags ){</span>
      StrAccum x;
      sqlite3StrAccumInit(&amp;x, 0, zFlgs, sizeof(zFlgs), 0);
      sqlite3_str_appendf(&amp;x, &quot; fg.af=%x.%c&quot;,
        pExpr-&gt;flags, pExpr-&gt;affExpr ? pExpr-&gt;affExpr : &#39;n&#39;);
      if( ExprHasProperty(pExpr, EP_FromJoin) ){
        sqlite3_str_appendf(&amp;x, &quot; iRJT=%d&quot;, pExpr-&gt;iRightJoinTable);
      }
      if( ExprHasProperty(pExpr, EP_FromDDL) ){
        sqlite3_str_appendf(&amp;x, &quot; DDL&quot;);
      }
<span class="udiff-line-added">+     if( ExprHasVVAProperty(pExpr, EP_Immutable) ){</span>
<span class="udiff-line-added">+       sqlite3_str_appendf(&amp;x, &quot; IMMUTABLE&quot;);</span>
<span class="udiff-line-added">+     }</span>
      sqlite3StrAccumFinish(&amp;x);
    }else{
      zFlgs[0] = 0;
    }
    switch( pExpr-&gt;op ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -29773,10 +29934,11 @@</span>
      case TK_SLASH:   zBinOp = &quot;DIV&quot;;    break;
      case TK_LSHIFT:  zBinOp = &quot;LSHIFT&quot;; break;
      case TK_RSHIFT:  zBinOp = &quot;RSHIFT&quot;; break;
      case TK_CONCAT:  zBinOp = &quot;CONCAT&quot;; break;
      case TK_DOT:     zBinOp = &quot;DOT&quot;;    break;
<span class="udiff-line-added">+     case TK_LIMIT:   zBinOp = &quot;LIMIT&quot;;  break;</span>
  
      case TK_UMINUS:  zUniOp = &quot;UMINUS&quot;; break;
      case TK_UPLUS:   zUniOp = &quot;UPLUS&quot;;  break;
      case TK_BITNOT:  zUniOp = &quot;BITNOT&quot;; break;
      case TK_NOT:     zUniOp = &quot;NOT&quot;;    break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -29829,12 +29991,13 @@</span>
  #else
          pWin = 0;
  #endif
        }
        if( pExpr-&gt;op==TK_AGG_FUNCTION ){
<span class="udiff-line-modified-removed">-         sqlite3TreeViewLine(pView, &quot;AGG_FUNCTION%d %Q%s&quot;,</span>
<span class="udiff-line-modified-removed">-                              pExpr-&gt;op2, pExpr-&gt;u.zToken, zFlgs);</span>
<span class="udiff-line-modified-added">+         sqlite3TreeViewLine(pView, &quot;AGG_FUNCTION%d %Q%s iAgg=%d agg=%p&quot;,</span>
<span class="udiff-line-modified-added">+                              pExpr-&gt;op2, pExpr-&gt;u.zToken, zFlgs,</span>
<span class="udiff-line-added">+                              pExpr-&gt;iAgg, pExpr-&gt;pAggInfo);</span>
        }else if( pExpr-&gt;op2!=0 ){
          const char *zOp2;
          char zBuf[8];
          sqlite3_snprintf(sizeof(zBuf),zBuf,&quot;0x%02x&quot;,pExpr-&gt;op2);
          zOp2 = zBuf;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -30544,30 +30707,10 @@</span>
      *zOut++ = (u8)(0x00DC + ((c&gt;&gt;8)&amp;0x03));                         \
      *zOut++ = (u8)(c&amp;0x00FF);                                       \
    }                                                                 \
  }
  
<span class="udiff-line-removed">- #define READ_UTF16LE(zIn, TERM, c){                                   \</span>
<span class="udiff-line-removed">-   c = (*zIn++);                                                       \</span>
<span class="udiff-line-removed">-   c += ((*zIn++)&lt;&lt;8);                                                 \</span>
<span class="udiff-line-removed">-   if( c&gt;=0xD800 &amp;&amp; c&lt;0xE000 &amp;&amp; TERM ){                                \</span>
<span class="udiff-line-removed">-     int c2 = (*zIn++);                                                \</span>
<span class="udiff-line-removed">-     c2 += ((*zIn++)&lt;&lt;8);                                              \</span>
<span class="udiff-line-removed">-     c = (c2&amp;0x03FF) + ((c&amp;0x003F)&lt;&lt;10) + (((c&amp;0x03C0)+0x0040)&lt;&lt;10);   \</span>
<span class="udiff-line-removed">-   }                                                                   \</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #define READ_UTF16BE(zIn, TERM, c){                                   \</span>
<span class="udiff-line-removed">-   c = ((*zIn++)&lt;&lt;8);                                                  \</span>
<span class="udiff-line-removed">-   c += (*zIn++);                                                      \</span>
<span class="udiff-line-removed">-   if( c&gt;=0xD800 &amp;&amp; c&lt;0xE000 &amp;&amp; TERM ){                                \</span>
<span class="udiff-line-removed">-     int c2 = ((*zIn++)&lt;&lt;8);                                           \</span>
<span class="udiff-line-removed">-     c2 += (*zIn++);                                                   \</span>
<span class="udiff-line-removed">-     c = (c2&amp;0x03FF) + ((c&amp;0x003F)&lt;&lt;10) + (((c&amp;0x03C0)+0x0040)&lt;&lt;10);   \</span>
<span class="udiff-line-removed">-   }                                                                   \</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  /*
  ** Translate a single UTF-8 character.  Return the unicode value.
  **
  ** During translation, assume that the byte that zTerm points
  ** is a 0x00.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -30740,17 +30883,63 @@</span>
    }else{
      assert( desiredEnc==SQLITE_UTF8 );
      if( pMem-&gt;enc==SQLITE_UTF16LE ){
        /* UTF-16 Little-endian -&gt; UTF-8 */
        while( zIn&lt;zTerm ){
<span class="udiff-line-modified-removed">-         READ_UTF16LE(zIn, zIn&lt;zTerm, c);</span>
<span class="udiff-line-modified-added">+         c = *(zIn++);</span>
<span class="udiff-line-added">+         c += (*(zIn++))&lt;&lt;8;</span>
<span class="udiff-line-added">+         if( c&gt;=0xd800 &amp;&amp; c&lt;0xe000 ){</span>
<span class="udiff-line-added">+ #ifdef SQLITE_REPLACE_INVALID_UTF</span>
<span class="udiff-line-added">+           if( c&gt;=0xdc00 || zIn&gt;=zTerm ){</span>
<span class="udiff-line-added">+             c = 0xfffd;</span>
<span class="udiff-line-added">+           }else{</span>
<span class="udiff-line-added">+             int c2 = *(zIn++);</span>
<span class="udiff-line-added">+             c2 += (*(zIn++))&lt;&lt;8;</span>
<span class="udiff-line-added">+             if( c2&lt;0xdc00 || c2&gt;=0xe000 ){</span>
<span class="udiff-line-added">+               zIn -= 2;</span>
<span class="udiff-line-added">+               c = 0xfffd;</span>
<span class="udiff-line-added">+             }else{</span>
<span class="udiff-line-added">+               c = ((c&amp;0x3ff)&lt;&lt;10) + (c2&amp;0x3ff) + 0x10000;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+           if( zIn&lt;zTerm ){</span>
<span class="udiff-line-added">+             int c2 = (*zIn++);</span>
<span class="udiff-line-added">+             c2 += ((*zIn++)&lt;&lt;8);</span>
<span class="udiff-line-added">+             c = (c2&amp;0x03FF) + ((c&amp;0x003F)&lt;&lt;10) + (((c&amp;0x03C0)+0x0040)&lt;&lt;10);</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+         }</span>
          WRITE_UTF8(z, c);
        }
      }else{
        /* UTF-16 Big-endian -&gt; UTF-8 */
        while( zIn&lt;zTerm ){
<span class="udiff-line-modified-removed">-         READ_UTF16BE(zIn, zIn&lt;zTerm, c);</span>
<span class="udiff-line-modified-added">+         c = (*(zIn++))&lt;&lt;8;</span>
<span class="udiff-line-added">+         c += *(zIn++);</span>
<span class="udiff-line-added">+         if( c&gt;=0xd800 &amp;&amp; c&lt;0xe000 ){</span>
<span class="udiff-line-added">+ #ifdef SQLITE_REPLACE_INVALID_UTF</span>
<span class="udiff-line-added">+           if( c&gt;=0xdc00 || zIn&gt;=zTerm ){</span>
<span class="udiff-line-added">+             c = 0xfffd;</span>
<span class="udiff-line-added">+           }else{</span>
<span class="udiff-line-added">+             int c2 = (*(zIn++))&lt;&lt;8;</span>
<span class="udiff-line-added">+             c2 += *(zIn++);</span>
<span class="udiff-line-added">+             if( c2&lt;0xdc00 || c2&gt;=0xe000 ){</span>
<span class="udiff-line-added">+               zIn -= 2;</span>
<span class="udiff-line-added">+               c = 0xfffd;</span>
<span class="udiff-line-added">+             }else{</span>
<span class="udiff-line-added">+               c = ((c&amp;0x3ff)&lt;&lt;10) + (c2&amp;0x3ff) + 0x10000;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+           if( zIn&lt;zTerm ){</span>
<span class="udiff-line-added">+             int c2 = ((*zIn++)&lt;&lt;8);</span>
<span class="udiff-line-added">+             c2 += (*zIn++);</span>
<span class="udiff-line-added">+             c = (c2&amp;0x03FF) + ((c&amp;0x003F)&lt;&lt;10) + (((c&amp;0x03C0)+0x0040)&lt;&lt;10);</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+         }</span>
          WRITE_UTF8(z, c);
        }
      }
      pMem-&gt;n = (int)(z - zOut);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -30905,22 +31094,19 @@</span>
  SQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *zIn, int nChar){
    int c;
    unsigned char const *z = zIn;
    int n = 0;
  
<span class="udiff-line-modified-removed">-   if( SQLITE_UTF16NATIVE==SQLITE_UTF16BE ){</span>
<span class="udiff-line-modified-removed">-     while( n&lt;nChar ){</span>
<span class="udiff-line-modified-removed">-       READ_UTF16BE(z, 1, c);</span>
<span class="udiff-line-modified-removed">-       n++;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">-   }else{</span>
<span class="udiff-line-removed">-     while( n&lt;nChar ){</span>
<span class="udiff-line-removed">-       READ_UTF16LE(z, 1, c);</span>
<span class="udiff-line-removed">-       n++;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   if( SQLITE_UTF16NATIVE==SQLITE_UTF16LE ) z++;</span>
<span class="udiff-line-modified-added">+   while( n&lt;nChar ){</span>
<span class="udiff-line-modified-added">+     c = z[0];</span>
<span class="udiff-line-modified-added">+     z += 2;</span>
<span class="udiff-line-modified-added">+     if( c&gt;=0xd8 &amp;&amp; c&lt;0xdc &amp;&amp; z[0]&gt;=0xdc &amp;&amp; z[0]&lt;0xe0 ) z += 2;</span>
<span class="udiff-line-modified-added">+     n++;</span>
    }
<span class="udiff-line-modified-removed">-   return (int)(z-(unsigned char const *)zIn);</span>
<span class="udiff-line-modified-added">+   return (int)(z-(unsigned char const *)zIn)</span>
<span class="udiff-line-added">+               - (SQLITE_UTF16NATIVE==SQLITE_UTF16LE);</span>
  }
  
  #if defined(SQLITE_TEST)
  /*
  ** This routine is called from the TCL test function &quot;translate_selftest&quot;.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -30946,34 +31132,10 @@</span>
      if( i&gt;=0xD800 &amp;&amp; i&lt;=0xDFFF ) t = 0xFFFD;
      if( (i&amp;0xFFFFFFFE)==0xFFFE ) t = 0xFFFD;
      assert( c==t );
      assert( (z-zBuf)==n );
    }
<span class="udiff-line-removed">-   for(i=0; i&lt;0x00110000; i++){</span>
<span class="udiff-line-removed">-     if( i&gt;=0xD800 &amp;&amp; i&lt;0xE000 ) continue;</span>
<span class="udiff-line-removed">-     z = zBuf;</span>
<span class="udiff-line-removed">-     WRITE_UTF16LE(z, i);</span>
<span class="udiff-line-removed">-     n = (int)(z-zBuf);</span>
<span class="udiff-line-removed">-     assert( n&gt;0 &amp;&amp; n&lt;=4 );</span>
<span class="udiff-line-removed">-     z[0] = 0;</span>
<span class="udiff-line-removed">-     z = zBuf;</span>
<span class="udiff-line-removed">-     READ_UTF16LE(z, 1, c);</span>
<span class="udiff-line-removed">-     assert( c==i );</span>
<span class="udiff-line-removed">-     assert( (z-zBuf)==n );</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   for(i=0; i&lt;0x00110000; i++){</span>
<span class="udiff-line-removed">-     if( i&gt;=0xD800 &amp;&amp; i&lt;0xE000 ) continue;</span>
<span class="udiff-line-removed">-     z = zBuf;</span>
<span class="udiff-line-removed">-     WRITE_UTF16BE(z, i);</span>
<span class="udiff-line-removed">-     n = (int)(z-zBuf);</span>
<span class="udiff-line-removed">-     assert( n&gt;0 &amp;&amp; n&lt;=4 );</span>
<span class="udiff-line-removed">-     z[0] = 0;</span>
<span class="udiff-line-removed">-     z = zBuf;</span>
<span class="udiff-line-removed">-     READ_UTF16BE(z, 1, c);</span>
<span class="udiff-line-removed">-     assert( c==i );</span>
<span class="udiff-line-removed">-     assert( (z-zBuf)==n );</span>
<span class="udiff-line-removed">-   }</span>
  }
  #endif /* SQLITE_TEST */
  #endif /* SQLITE_OMIT_UTF16 */
  
  /************** End of utf.c *************************************************/
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -31295,10 +31457,23 @@</span>
    b = (unsigned char *)zRight;
    while( N-- &gt; 0 &amp;&amp; *a!=0 &amp;&amp; UpperToLower[*a]==UpperToLower[*b]){ a++; b++; }
    return N&lt;0 ? 0 : UpperToLower[*a] - UpperToLower[*b];
  }
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Compute an 8-bit hash on a string that is insensitive to case differences</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE u8 sqlite3StrIHash(const char *z){</span>
<span class="udiff-line-added">+   u8 h = 0;</span>
<span class="udiff-line-added">+   if( z==0 ) return 0;</span>
<span class="udiff-line-added">+   while( z[0] ){</span>
<span class="udiff-line-added">+     h += UpperToLower[(unsigned char)z[0]];</span>
<span class="udiff-line-added">+     z++;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return h;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /*
  ** Compute 10 to the E-th power.  Examples:  E==1 results in 10.
  ** E==2 results in 100.  E==50 results in 1.0e50.
  **
  ** This routine only works for values of E between 1 and 341.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -32234,11 +32409,11 @@</span>
    h += 9*(1&amp;~(h&gt;&gt;4));
  #endif
    return (u8)(h &amp; 0xf);
  }
  
<span class="udiff-line-modified-removed">- #if !defined(SQLITE_OMIT_BLOB_LITERAL) || defined(SQLITE_HAS_CODEC)</span>
<span class="udiff-line-modified-added">+ #if !defined(SQLITE_OMIT_BLOB_LITERAL)</span>
  /*
  ** Convert a BLOB literal of the form &quot;x&#39;hhhhhh&#39;&quot; into its binary
  ** value.  Return a pointer to its binary value.  Space to hold the
  ** binary value has been obtained from malloc and must be freed by
  ** the calling routine.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -32255,11 +32430,11 @@</span>
      }
      zBlob[i/2] = 0;
    }
    return zBlob;
  }
<span class="udiff-line-modified-removed">- #endif /* !SQLITE_OMIT_BLOB_LITERAL || SQLITE_HAS_CODEC */</span>
<span class="udiff-line-modified-added">+ #endif /* !SQLITE_OMIT_BLOB_LITERAL */</span>
  
  /*
  ** Log an error that is an API call on a connection pointer that should
  ** not have been used.  The &quot;type&quot; of connection pointer is given as the
  ** argument.  The zType is a word like &quot;NULL&quot; or &quot;closed&quot; or &quot;invalid&quot;.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -32966,12 +33141,12 @@</span>
      /*  58 */ &quot;ElseNotEq&quot;        OpHelp(&quot;&quot;),
      /*  59 */ &quot;DecrJumpZero&quot;     OpHelp(&quot;if (--r[P1])==0 goto P2&quot;),
      /*  60 */ &quot;IncrVacuum&quot;       OpHelp(&quot;&quot;),
      /*  61 */ &quot;VNext&quot;            OpHelp(&quot;&quot;),
      /*  62 */ &quot;Init&quot;             OpHelp(&quot;Start at P2&quot;),
<span class="udiff-line-modified-removed">-     /*  63 */ &quot;PureFunc&quot;         OpHelp(&quot;r[P3]=func(r[P2@P5])&quot;),</span>
<span class="udiff-line-modified-removed">-     /*  64 */ &quot;Function&quot;         OpHelp(&quot;r[P3]=func(r[P2@P5])&quot;),</span>
<span class="udiff-line-modified-added">+     /*  63 */ &quot;PureFunc&quot;         OpHelp(&quot;r[P3]=func(r[P2@NP])&quot;),</span>
<span class="udiff-line-modified-added">+     /*  64 */ &quot;Function&quot;         OpHelp(&quot;r[P3]=func(r[P2@NP])&quot;),</span>
      /*  65 */ &quot;Return&quot;           OpHelp(&quot;&quot;),
      /*  66 */ &quot;EndCoroutine&quot;     OpHelp(&quot;&quot;),
      /*  67 */ &quot;HaltIfNull&quot;       OpHelp(&quot;if r[P3]=null halt&quot;),
      /*  68 */ &quot;Halt&quot;             OpHelp(&quot;&quot;),
      /*  69 */ &quot;Integer&quot;          OpHelp(&quot;r[P2]=P1&quot;),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -33033,12 +33208,12 @@</span>
      /* 125 */ &quot;SorterData&quot;       OpHelp(&quot;r[P2]=data&quot;),
      /* 126 */ &quot;RowData&quot;          OpHelp(&quot;r[P2]=data&quot;),
      /* 127 */ &quot;Rowid&quot;            OpHelp(&quot;r[P2]=rowid&quot;),
      /* 128 */ &quot;NullRow&quot;          OpHelp(&quot;&quot;),
      /* 129 */ &quot;SeekEnd&quot;          OpHelp(&quot;&quot;),
<span class="udiff-line-modified-removed">-     /* 130 */ &quot;SorterInsert&quot;     OpHelp(&quot;key=r[P2]&quot;),</span>
<span class="udiff-line-modified-removed">-     /* 131 */ &quot;IdxInsert&quot;        OpHelp(&quot;key=r[P2]&quot;),</span>
<span class="udiff-line-modified-added">+     /* 130 */ &quot;IdxInsert&quot;        OpHelp(&quot;key=r[P2]&quot;),</span>
<span class="udiff-line-modified-added">+     /* 131 */ &quot;SorterInsert&quot;     OpHelp(&quot;key=r[P2]&quot;),</span>
      /* 132 */ &quot;IdxDelete&quot;        OpHelp(&quot;key=r[P2@P3]&quot;),
      /* 133 */ &quot;DeferredSeek&quot;     OpHelp(&quot;Move P3 to P1.rowid if needed&quot;),
      /* 134 */ &quot;IdxRowid&quot;         OpHelp(&quot;r[P2]=rowid&quot;),
      /* 135 */ &quot;FinishSeek&quot;       OpHelp(&quot;&quot;),
      /* 136 */ &quot;Destroy&quot;          OpHelp(&quot;&quot;),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -33975,11 +34150,11 @@</span>
      if( fd&gt;=SQLITE_MINIMUM_FILE_DESCRIPTOR ) break;
      osClose(fd);
      sqlite3_log(SQLITE_WARNING,
                  &quot;attempt to open \&quot;%s\&quot; as file descriptor %d&quot;, z, fd);
      fd = -1;
<span class="udiff-line-modified-removed">-     if( osOpen(&quot;/dev/null&quot;, f, m)&lt;0 ) break;</span>
<span class="udiff-line-modified-added">+     if( osOpen(&quot;/dev/null&quot;, O_RDONLY, m)&lt;0 ) break;</span>
    }
    if( fd&gt;=0 ){
      if( m!=0 ){
        struct stat statbuf;
        if( osFstat(fd, &amp;statbuf)==0
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -34851,20 +35026,21 @@</span>
  static int osSetPosixAdvisoryLock(
    int h,                /* The file descriptor on which to take the lock */
    struct flock *pLock,  /* The description of the lock */
    unixFile *pFile       /* Structure holding timeout value */
  ){
<span class="udiff-line-added">+   int tm = pFile-&gt;iBusyTimeout;</span>
    int rc = osFcntl(h,F_SETLK,pLock);
<span class="udiff-line-modified-removed">-   while( rc&lt;0 &amp;&amp; pFile-&gt;iBusyTimeout&gt;0 ){</span>
<span class="udiff-line-modified-added">+   while( rc&lt;0 &amp;&amp; tm&gt;0 ){</span>
      /* On systems that support some kind of blocking file lock with a timeout,
      ** make appropriate changes here to invoke that blocking file lock.  On
      ** generic posix, however, there is no such API.  So we simply try the
      ** lock once every millisecond until either the timeout expires, or until
      ** the lock is obtained. */
      usleep(1000);
      rc = osFcntl(h,F_SETLK,pLock);
<span class="udiff-line-modified-removed">-     pFile-&gt;iBusyTimeout--;</span>
<span class="udiff-line-modified-added">+     tm--;</span>
    }
    return rc;
  }
  #endif /* SQLITE_ENABLE_SETLK_TIMEOUT */
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -36971,11 +37147,11 @@</span>
      zDirname[ii] = &#39;\0&#39;;
    }else{
      if( zDirname[0]!=&#39;/&#39; ) zDirname[0] = &#39;.&#39;;
      zDirname[1] = 0;
    }
<span class="udiff-line-modified-removed">-   fd = robust_open(zDirname, O_RDONLY|O_BINARY|O_NOFOLLOW, 0);</span>
<span class="udiff-line-modified-added">+   fd = robust_open(zDirname, O_RDONLY|O_BINARY, 0);</span>
    if( fd&gt;=0 ){
      OSTRACE((&quot;OPENDIR %-3d %s\n&quot;, fd, zDirname));
    }
    *pFd = fd;
    if( fd&gt;=0 ) return SQLITE_OK;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -37281,11 +37457,13 @@</span>
        *(int*)pArg = fileHasMoved(pFile);
        return SQLITE_OK;
      }
  #ifdef SQLITE_ENABLE_SETLK_TIMEOUT
      case SQLITE_FCNTL_LOCK_TIMEOUT: {
<span class="udiff-line-added">+       int iOld = pFile-&gt;iBusyTimeout;</span>
        pFile-&gt;iBusyTimeout = *(int*)pArg;
<span class="udiff-line-added">+       *(int*)pArg = iOld;</span>
        return SQLITE_OK;
      }
  #endif
  #if SQLITE_MAX_MMAP_SIZE&gt;0
      case SQLITE_FCNTL_MMAP_SIZE: {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -37600,17 +37778,24 @@</span>
  
    /* Locks are within range */
    assert( n&gt;=1 &amp;&amp; n&lt;=SQLITE_SHM_NLOCK );
  
    if( pShmNode-&gt;hShm&gt;=0 ){
<span class="udiff-line-added">+     int res;</span>
      /* Initialize the locking parameters */
      f.l_type = lockType;
      f.l_whence = SEEK_SET;
      f.l_start = ofst;
      f.l_len = n;
<span class="udiff-line-modified-removed">-     rc = osSetPosixAdvisoryLock(pShmNode-&gt;hShm, &amp;f, pFile);</span>
<span class="udiff-line-modified-removed">-     rc = (rc!=(-1)) ? SQLITE_OK : SQLITE_BUSY;</span>
<span class="udiff-line-modified-added">+     res = osSetPosixAdvisoryLock(pShmNode-&gt;hShm, &amp;f, pFile);</span>
<span class="udiff-line-modified-added">+     if( res==-1 ){</span>
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_SETLK_TIMEOUT</span>
<span class="udiff-line-added">+       rc = (pFile-&gt;iBusyTimeout ? SQLITE_BUSY_TIMEOUT : SQLITE_BUSY);</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+       rc = SQLITE_BUSY;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     }</span>
    }
  
    /* Update the global lock state and do debug tracing */
  #ifdef SQLITE_DEBUG
    { u16 mask;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -38103,10 +38288,29 @@</span>
         || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE) );
    assert( n==1 || (flags &amp; SQLITE_SHM_EXCLUSIVE)!=0 );
    assert( pShmNode-&gt;hShm&gt;=0 || pDbFd-&gt;pInode-&gt;bProcessLock==1 );
    assert( pShmNode-&gt;hShm&lt;0 || pDbFd-&gt;pInode-&gt;bProcessLock==0 );
  
<span class="udiff-line-added">+   /* Check that, if this to be a blocking lock, no locks that occur later</span>
<span class="udiff-line-added">+   ** in the following list than the lock being obtained are already held:</span>
<span class="udiff-line-added">+   **</span>
<span class="udiff-line-added">+   **   1. Checkpointer lock (ofst==1).</span>
<span class="udiff-line-added">+   **   2. Write lock (ofst==0).</span>
<span class="udiff-line-added">+   **   3. Read locks (ofst&gt;=3 &amp;&amp; ofst&lt;SQLITE_SHM_NLOCK).</span>
<span class="udiff-line-added">+   **</span>
<span class="udiff-line-added">+   ** In other words, if this is a blocking lock, none of the locks that</span>
<span class="udiff-line-added">+   ** occur later in the above list than the lock being obtained may be</span>
<span class="udiff-line-added">+   ** held.  */</span>
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_SETLK_TIMEOUT</span>
<span class="udiff-line-added">+   assert( (flags &amp; SQLITE_SHM_UNLOCK) || pDbFd-&gt;iBusyTimeout==0 || (</span>
<span class="udiff-line-added">+          (ofst!=2)                                   /* not RECOVER */</span>
<span class="udiff-line-added">+       &amp;&amp; (ofst!=1 || (p-&gt;exclMask|p-&gt;sharedMask)==0)</span>
<span class="udiff-line-added">+       &amp;&amp; (ofst!=0 || (p-&gt;exclMask|p-&gt;sharedMask)&lt;3)</span>
<span class="udiff-line-added">+       &amp;&amp; (ofst&lt;3  || (p-&gt;exclMask|p-&gt;sharedMask)&lt;(1&lt;&lt;ofst))</span>
<span class="udiff-line-added">+   ));</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
    mask = (1&lt;&lt;(ofst+n)) - (1&lt;&lt;ofst);
    assert( n&gt;1 || mask==(1&lt;&lt;ofst) );
    sqlite3_mutex_enter(pShmNode-&gt;pShmMutex);
    if( flags &amp; SQLITE_SHM_UNLOCK ){
      u16 allMask = 0; /* Mask of locks held by siblings */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -44893,10 +45097,11 @@</span>
  }
  
  /* Forward references to VFS helper methods used for temporary files */
  static int winGetTempname(sqlite3_vfs *, char **);
  static int winIsDir(const void *);
<span class="udiff-line-added">+ static BOOL winIsLongPathPrefix(const char *);</span>
  static BOOL winIsDriveLetterAndColon(const char *);
  
  /*
  ** Control and query of the open file handle.
  */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -46662,11 +46867,13 @@</span>
    pFile-&gt;pVfs = pVfs;
    pFile-&gt;h = h;
    if( isReadonly ){
      pFile-&gt;ctrlFlags |= WINFILE_RDONLY;
    }
<span class="udiff-line-modified-removed">-   if( sqlite3_uri_boolean(zName, &quot;psow&quot;, SQLITE_POWERSAFE_OVERWRITE) ){</span>
<span class="udiff-line-modified-added">+   if( (flags &amp; SQLITE_OPEN_MAIN_DB)</span>
<span class="udiff-line-added">+    &amp;&amp; sqlite3_uri_boolean(zName, &quot;psow&quot;, SQLITE_POWERSAFE_OVERWRITE)</span>
<span class="udiff-line-added">+   ){</span>
      pFile-&gt;ctrlFlags |= WINFILE_PSOW;
    }
    pFile-&gt;lastErrno = NO_ERROR;
    pFile-&gt;zPath = zName;
  #if SQLITE_MAX_MMAP_SIZE&gt;0
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -46872,10 +47079,21 @@</span>
    OSTRACE((&quot;ACCESS name=%s, pResOut=%p, *pResOut=%d, rc=SQLITE_OK\n&quot;,
             zFilename, pResOut, *pResOut));
    return SQLITE_OK;
  }
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Returns non-zero if the specified path name starts with the &quot;long path&quot;</span>
<span class="udiff-line-added">+ ** prefix.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static BOOL winIsLongPathPrefix(</span>
<span class="udiff-line-added">+   const char *zPathname</span>
<span class="udiff-line-added">+ ){</span>
<span class="udiff-line-added">+   return ( zPathname[0]==&#39;\\&#39; &amp;&amp; zPathname[1]==&#39;\\&#39;</span>
<span class="udiff-line-added">+         &amp;&amp; zPathname[2]==&#39;?&#39;  &amp;&amp; zPathname[3]==&#39;\\&#39; );</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /*
  ** Returns non-zero if the specified path name starts with a drive letter
  ** followed by a colon character.
  */
  static BOOL winIsDriveLetterAndColon(
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -46936,14 +47154,15 @@</span>
    DWORD nByte;
    void *zConverted;
    char *zOut;
  #endif
  
<span class="udiff-line-modified-removed">-   /* If this path name begins with &quot;/X:&quot;, where &quot;X&quot; is any alphabetic</span>
<span class="udiff-line-modified-removed">-   ** character, discard the initial &quot;/&quot; from the pathname.</span>
<span class="udiff-line-modified-added">+   /* If this path name begins with &quot;/X:&quot; or &quot;\\?\&quot;, where &quot;X&quot; is any</span>
<span class="udiff-line-modified-added">+   ** alphabetic character, discard the initial &quot;/&quot; from the pathname.</span>
    */
<span class="udiff-line-modified-removed">-   if( zRelative[0]==&#39;/&#39; &amp;&amp; winIsDriveLetterAndColon(zRelative+1) ){</span>
<span class="udiff-line-modified-added">+   if( zRelative[0]==&#39;/&#39; &amp;&amp; (winIsDriveLetterAndColon(zRelative+1)</span>
<span class="udiff-line-added">+        || winIsLongPathPrefix(zRelative+1)) ){</span>
      zRelative++;
    }
  
  #if defined(__CYGWIN__)
    SimulateIOError( return SQLITE_ERROR );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -47695,11 +47914,11 @@</span>
    if( newSz&gt;p-&gt;szMax ){
      return SQLITE_FULL;
    }
    newSz *= 2;
    if( newSz&gt;p-&gt;szMax ) newSz = p-&gt;szMax;
<span class="udiff-line-modified-removed">-   pNew = sqlite3_realloc64(p-&gt;aData, newSz);</span>
<span class="udiff-line-modified-added">+   pNew = sqlite3Realloc(p-&gt;aData, newSz);</span>
    if( pNew==0 ) return SQLITE_NOMEM;
    p-&gt;aData = pNew;
    p-&gt;szAlloc = newSz;
    return SQLITE_OK;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -48142,14 +48361,15 @@</span>
  */
  SQLITE_PRIVATE int sqlite3MemdbInit(void){
    sqlite3_vfs *pLower = sqlite3_vfs_find(0);
    int sz = pLower-&gt;szOsFile;
    memdb_vfs.pAppData = pLower;
<span class="udiff-line-modified-removed">-   /* In all known configurations of SQLite, the size of a default</span>
<span class="udiff-line-modified-removed">-   ** sqlite3_file is greater than the size of a memdb sqlite3_file.</span>
<span class="udiff-line-modified-removed">-   ** Should that ever change, remove the following NEVER() */</span>
<span class="udiff-line-modified-removed">-   if( NEVER(sz&lt;sizeof(MemFile)) ) sz = sizeof(MemFile);</span>
<span class="udiff-line-modified-added">+   /* The following conditional can only be true when compiled for</span>
<span class="udiff-line-modified-added">+   ** Windows x86 and SQLITE_MAX_MMAP_SIZE=0.  We always leave</span>
<span class="udiff-line-modified-added">+   ** it in, to be safe, but it is marked as NO_TEST since there</span>
<span class="udiff-line-modified-added">+   ** is no way to reach it under most builds. */</span>
<span class="udiff-line-added">+   if( sz&lt;sizeof(MemFile) ) sz = sizeof(MemFile); /*NO_TEST*/</span>
    memdb_vfs.szOsFile = sz;
    return sqlite3_vfs_register(&amp;memdb_vfs, 0);
  }
  #endif /* SQLITE_ENABLE_DESERIALIZE */
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -50911,11 +51131,11 @@</span>
  }
  
  /*
  ** Allocate a new RowSetEntry object that is associated with the
  ** given RowSet.  Return a pointer to the new and completely uninitialized
<span class="udiff-line-modified-removed">- ** objected.</span>
<span class="udiff-line-modified-added">+ ** object.</span>
  **
  ** In an OOM situation, the RowSet.db-&gt;mallocFailed flag is set and this
  ** routine returns NULL.
  */
  static struct RowSetEntry *rowSetEntryAlloc(RowSet *p){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -51187,11 +51407,11 @@</span>
    if( iBatch!=pRowSet-&gt;iBatch ){  /*OPTIMIZATION-IF-FALSE*/
      p = pRowSet-&gt;pEntry;
      if( p ){
        struct RowSetEntry **ppPrevTree = &amp;pRowSet-&gt;pForest;
        if( (pRowSet-&gt;rsFlags &amp; ROWSET_SORTED)==0 ){ /*OPTIMIZATION-IF-FALSE*/
<span class="udiff-line-modified-removed">-         /* Only sort the current set of entiries if they need it */</span>
<span class="udiff-line-modified-added">+         /* Only sort the current set of entries if they need it */</span>
          p = rowSetEntrySort(p);
        }
        for(pTree = pRowSet-&gt;pForest; pTree; pTree=pTree-&gt;pRight){
          ppPrevTree = &amp;pTree-&gt;pRight;
          if( pTree-&gt;pLeft==0 ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -51409,10 +51629,15 @@</span>
  #endif
  
  /* Return the sqlite3_file object for the WAL file */
  SQLITE_PRIVATE sqlite3_file *sqlite3WalFile(Wal *pWal);
  
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_SETLK_TIMEOUT</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE int sqlite3WalWriteLock(Wal *pWal, int bLock);</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE void sqlite3WalDb(Wal *pWal, sqlite3 *db);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  #endif /* ifndef SQLITE_OMIT_WAL */
  #endif /* SQLITE_WAL_H */
  
  /************** End of wal.h *************************************************/
  /************** Continuing where we left off in pager.c **********************/
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -51799,24 +52024,10 @@</span>
  ** Pager.eLock may only be set to UNKNOWN_LOCK when the pager is in
  ** PAGER_OPEN state.
  */
  #define UNKNOWN_LOCK                (EXCLUSIVE_LOCK+1)
  
<span class="udiff-line-removed">- /*</span>
<span class="udiff-line-removed">- ** A macro used for invoking the codec if there is one</span>
<span class="udiff-line-removed">- */</span>
<span class="udiff-line-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">- # define CODEC1(P,D,N,X,E) \</span>
<span class="udiff-line-removed">-     if( P-&gt;xCodec &amp;&amp; P-&gt;xCodec(P-&gt;pCodec,D,N,X)==0 ){ E; }</span>
<span class="udiff-line-removed">- # define CODEC2(P,D,N,X,E,O) \</span>
<span class="udiff-line-removed">-     if( P-&gt;xCodec==0 ){ O=(char*)D; }else \</span>
<span class="udiff-line-removed">-     if( (O=(char*)(P-&gt;xCodec(P-&gt;pCodec,D,N,X)))==0 ){ E; }</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">- # define CODEC1(P,D,N,X,E)   /* NO-OP */</span>
<span class="udiff-line-removed">- # define CODEC2(P,D,N,X,E,O) O=(char*)D</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
  /*
  ** The maximum allowed sector size. 64KiB. If the xSectorsize() method
  ** returns a value larger than this, then MAX_SECTOR_SIZE is used instead.
  ** This could conceivably cause corruption following a power failure on
  ** such a system. This is currently an undocumented limit.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -52098,16 +52309,10 @@</span>
  #ifdef SQLITE_TEST
    int nRead;                  /* Database pages read */
  #endif
    void (*xReiniter)(DbPage*); /* Call this routine when reloading pages */
    int (*xGet)(Pager*,Pgno,DbPage**,int); /* Routine to fetch a patch */
<span class="udiff-line-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">-   void *(*xCodec)(void*,void*,Pgno,int); /* Routine for en/decoding data */</span>
<span class="udiff-line-removed">-   void (*xCodecSizeChng)(void*,int,int); /* Notify of page size changes */</span>
<span class="udiff-line-removed">-   void (*xCodecFree)(void*);             /* Destructor for the codec */</span>
<span class="udiff-line-removed">-   void *pCodec;               /* First argument to xCodec... methods */</span>
<span class="udiff-line-removed">- #endif</span>
    char *pTmpSpace;            /* Pager.pageSize bytes of space for tmp use */
    PCache *pPCache;            /* Pointer to page cache object */
  #ifndef SQLITE_OMIT_WAL
    Wal *pWal;                  /* Write-ahead log used by &quot;journal_mode=wal&quot; */
    char *zWal;                 /* File name for write-ahead log */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -52230,13 +52435,10 @@</span>
  **   * the desired page is not currently in the wal file.
  */
  SQLITE_PRIVATE int sqlite3PagerDirectReadOk(Pager *pPager, Pgno pgno){
    if( pPager-&gt;fd-&gt;pMethods==0 ) return 0;
    if( sqlite3PCacheIsDirty(pPager-&gt;pPCache) ) return 0;
<span class="udiff-line-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">-   if( pPager-&gt;xCodec!=0 ) return 0;</span>
<span class="udiff-line-removed">- #endif</span>
  #ifndef SQLITE_OMIT_WAL
    if( pPager-&gt;pWal ){
      u32 iRead = 0;
      int rc;
      rc = sqlite3WalFindFrame(pPager-&gt;pWal, pgno, &amp;iRead);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -52466,15 +52668,11 @@</span>
  */
  static void setGetterMethod(Pager *pPager){
    if( pPager-&gt;errCode ){
      pPager-&gt;xGet = getPageError;
  #if SQLITE_MAX_MMAP_SIZE&gt;0
<span class="udiff-line-modified-removed">-   }else if( USEFETCH(pPager)</span>
<span class="udiff-line-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">-    &amp;&amp; pPager-&gt;xCodec==0</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-   ){</span>
<span class="udiff-line-modified-added">+   }else if( USEFETCH(pPager) ){</span>
      pPager-&gt;xGet = getPageMMap;
  #endif /* SQLITE_MAX_MMAP_SIZE&gt;0 */
    }else{
      pPager-&gt;xGet = getPageNormal;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -53618,39 +53816,10 @@</span>
      i -= 200;
    }
    return cksum;
  }
  
<span class="udiff-line-removed">- /*</span>
<span class="udiff-line-removed">- ** Report the current page size and number of reserved bytes back</span>
<span class="udiff-line-removed">- ** to the codec.</span>
<span class="udiff-line-removed">- */</span>
<span class="udiff-line-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">- static void pagerReportSize(Pager *pPager){</span>
<span class="udiff-line-removed">-   if( pPager-&gt;xCodecSizeChng ){</span>
<span class="udiff-line-removed">-     pPager-&gt;xCodecSizeChng(pPager-&gt;pCodec, pPager-&gt;pageSize,</span>
<span class="udiff-line-removed">-                            (int)pPager-&gt;nReserve);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">- # define pagerReportSize(X)     /* No-op if we do not support a codec */</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">- /*</span>
<span class="udiff-line-removed">- ** Make sure the number of reserved bits is the same in the destination</span>
<span class="udiff-line-removed">- ** pager as it is in the source.  This comes up when a VACUUM changes the</span>
<span class="udiff-line-removed">- ** number of reserved bits to the &quot;optimal&quot; amount.</span>
<span class="udiff-line-removed">- */</span>
<span class="udiff-line-removed">- SQLITE_PRIVATE void sqlite3PagerAlignReserve(Pager *pDest, Pager *pSrc){</span>
<span class="udiff-line-removed">-   if( pDest-&gt;nReserve!=pSrc-&gt;nReserve ){</span>
<span class="udiff-line-removed">-     pDest-&gt;nReserve = pSrc-&gt;nReserve;</span>
<span class="udiff-line-removed">-     pagerReportSize(pDest);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
  /*
  ** Read a single page from either the journal file (if isMainJrnl==1) or
  ** from the sub-journal (if isMainJrnl==0) and playback that page.
  ** The page begins at offset *pOffset into the file. The *pOffset
  ** value is increased to the start of the next page in the journal.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -53698,15 +53867,10 @@</span>
    Pgno pgno;                    /* The page number of a page in journal */
    u32 cksum;                    /* Checksum used for sanity checking */
    char *aData;                  /* Temporary storage for the page */
    sqlite3_file *jfd;            /* The file descriptor for the journal file */
    int isSynced;                 /* True if journal page is synced */
<span class="udiff-line-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">-   /* The jrnlEnc flag is true if Journal pages should be passed through</span>
<span class="udiff-line-removed">-   ** the codec.  It is false for pure in-memory journals. */</span>
<span class="udiff-line-removed">-   const int jrnlEnc = (isMainJrnl || pPager-&gt;subjInMemory==0);</span>
<span class="udiff-line-removed">- #endif</span>
  
    assert( (isMainJrnl&amp;~1)==0 );      /* isMainJrnl is 0 or 1 */
    assert( (isSavepnt&amp;~1)==0 );       /* isSavepnt is 0 or 1 */
    assert( isMainJrnl || pDone );     /* pDone always used on sub-journals */
    assert( isSavepnt || pDone==0 );   /* pDone never used on non-savepoint */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -53765,11 +53929,10 @@</span>
  
    /* When playing back page 1, restore the nReserve setting
    */
    if( pgno==1 &amp;&amp; pPager-&gt;nReserve!=((u8*)aData)[20] ){
      pPager-&gt;nReserve = ((u8*)aData)[20];
<span class="udiff-line-removed">-     pagerReportSize(pPager);</span>
    }
  
    /* If the pager is in CACHEMOD state, then there must be a copy of this
    ** page in the pager cache. In this case just update the pager cache,
    ** not the database file. The page is left marked dirty in this case.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -53833,30 +53996,16 @@</span>
      ** This is usually safe even for an encrypted database - as the data
      ** was encrypted before it was written to the journal file. The exception
      ** is if the data was just read from an in-memory sub-journal. In that
      ** case it must be encrypted here before it is copied into the database
      ** file.  */
<span class="udiff-line-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">-     if( !jrnlEnc ){</span>
<span class="udiff-line-removed">-       CODEC2(pPager, aData, pgno, 7, rc=SQLITE_NOMEM_BKPT, aData);</span>
<span class="udiff-line-removed">-       rc = sqlite3OsWrite(pPager-&gt;fd, (u8 *)aData, pPager-&gt;pageSize, ofst);</span>
<span class="udiff-line-removed">-       CODEC1(pPager, aData, pgno, 3, rc=SQLITE_NOMEM_BKPT);</span>
<span class="udiff-line-removed">-     }else</span>
<span class="udiff-line-removed">- #endif</span>
      rc = sqlite3OsWrite(pPager-&gt;fd, (u8 *)aData, pPager-&gt;pageSize, ofst);
  
      if( pgno&gt;pPager-&gt;dbFileSize ){
        pPager-&gt;dbFileSize = pgno;
      }
      if( pPager-&gt;pBackup ){
<span class="udiff-line-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">-       if( jrnlEnc ){</span>
<span class="udiff-line-removed">-         CODEC1(pPager, aData, pgno, 3, rc=SQLITE_NOMEM_BKPT);</span>
<span class="udiff-line-removed">-         sqlite3BackupUpdate(pPager-&gt;pBackup, pgno, (u8*)aData);</span>
<span class="udiff-line-removed">-         CODEC2(pPager, aData, pgno, 7, rc=SQLITE_NOMEM_BKPT,aData);</span>
<span class="udiff-line-removed">-       }else</span>
<span class="udiff-line-removed">- #endif</span>
        sqlite3BackupUpdate(pPager-&gt;pBackup, pgno, (u8*)aData);
      }
    }else if( !isMainJrnl &amp;&amp; pPg==0 ){
      /* If this is a rollback of a savepoint and data was not written to
      ** the database and the page is not in-memory, there is a potential
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -53903,15 +54052,10 @@</span>
      /* If this was page 1, then restore the value of Pager.dbFileVers.
      ** Do this before any decoding. */
      if( pgno==1 ){
        memcpy(&amp;pPager-&gt;dbFileVers, &amp;((u8*)pData)[24],sizeof(pPager-&gt;dbFileVers));
      }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /* Decode the page just read from disk */</span>
<span class="udiff-line-removed">- #if SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">-     if( jrnlEnc ){ CODEC1(pPager, pData, pPg-&gt;pgno, 3, rc=SQLITE_NOMEM_BKPT); }</span>
<span class="udiff-line-removed">- #endif</span>
      sqlite3PcacheRelease(pPg);
    }
    return rc;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -54010,13 +54154,16 @@</span>
      }
      if( exists ){
        /* One of the journals pointed to by the master journal exists.
        ** Open it and check if it points at the master journal. If
        ** so, return without deleting the master journal file.
<span class="udiff-line-added">+       ** NB:  zJournal is really a MAIN_JOURNAL.  But call it a</span>
<span class="udiff-line-added">+       ** MASTER_JOURNAL here so that the VFS will not send the zJournal</span>
<span class="udiff-line-added">+       ** name into sqlite3_database_file_object().</span>
        */
        int c;
<span class="udiff-line-modified-removed">-       int flags = (SQLITE_OPEN_READONLY|SQLITE_OPEN_MAIN_JOURNAL);</span>
<span class="udiff-line-modified-added">+       int flags = (SQLITE_OPEN_READONLY|SQLITE_OPEN_MASTER_JOURNAL);</span>
        rc = sqlite3OsOpen(pVfs, zJournal, pJournal, flags, 0);
        if( rc!=SQLITE_OK ){
          goto delmaster_out;
        }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -54467,12 +54614,10 @@</span>
      }else{
        u8 *dbFileVers = &amp;((u8*)pPg-&gt;pData)[24];
        memcpy(&amp;pPager-&gt;dbFileVers, dbFileVers, sizeof(pPager-&gt;dbFileVers));
      }
    }
<span class="udiff-line-removed">-   CODEC1(pPager, pPg-&gt;pData, pPg-&gt;pgno, 3, rc = SQLITE_NOMEM_BKPT);</span>
<span class="udiff-line-removed">- </span>
    PAGER_INCR(sqlite3_pager_readdb_count);
    PAGER_INCR(pPager-&gt;nRead);
    IOTRACE((&quot;PGIN %p %d\n&quot;, pPager, pPg-&gt;pgno));
    PAGERTRACE((&quot;FETCH %d page %d hash(%08x)\n&quot;,
                 PAGERID(pPager), pPg-&gt;pgno, pager_pagehash(pPg)));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -55212,11 +55357,10 @@</span>
    *pPageSize = pPager-&gt;pageSize;
    if( rc==SQLITE_OK ){
      if( nReserve&lt;0 ) nReserve = pPager-&gt;nReserve;
      assert( nReserve&gt;=0 &amp;&amp; nReserve&lt;1000 );
      pPager-&gt;nReserve = (i16)nReserve;
<span class="udiff-line-removed">-     pagerReportSize(pPager);</span>
      pagerFixMaplimit(pPager);
    }
    return rc;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -55608,15 +55752,10 @@</span>
    IOTRACE((&quot;CLOSE %p\n&quot;, pPager))
    sqlite3OsClose(pPager-&gt;jfd);
    sqlite3OsClose(pPager-&gt;fd);
    sqlite3PageFree(pTmp);
    sqlite3PcacheClose(pPager-&gt;pPCache);
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">-   if( pPager-&gt;xCodecFree ) pPager-&gt;xCodecFree(pPager-&gt;pCodec);</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
    assert( !pPager-&gt;aSavepoint &amp;&amp; !pPager-&gt;pInJournal );
    assert( !isOpen(pPager-&gt;jfd) &amp;&amp; !isOpen(pPager-&gt;sjfd) );
  
    sqlite3_free(pPager);
    return SQLITE_OK;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -55863,12 +56002,11 @@</span>
        char *pData;                                   /* Data to write */
  
        assert( (pList-&gt;flags&amp;PGHDR_NEED_SYNC)==0 );
        if( pList-&gt;pgno==1 ) pager_write_changecounter(pList);
  
<span class="udiff-line-modified-removed">-       /* Encode the database */</span>
<span class="udiff-line-removed">-       CODEC2(pPager, pList-&gt;pData, pgno, 6, return SQLITE_NOMEM_BKPT, pData);</span>
<span class="udiff-line-modified-added">+       pData = pList-&gt;pData;</span>
  
        /* Write out the page data. */
        rc = sqlite3OsWrite(pPager-&gt;fd, pData, pPager-&gt;pageSize, offset);
  
        /* If page 1 was just written, update Pager.dbFileVers to match
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -55953,16 +56091,10 @@</span>
      ** write the journal record into the file.  */
      if( rc==SQLITE_OK ){
        void *pData = pPg-&gt;pData;
        i64 offset = (i64)pPager-&gt;nSubRec*(4+pPager-&gt;pageSize);
        char *pData2;
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #if SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">-       if( !pPager-&gt;subjInMemory ){</span>
<span class="udiff-line-removed">-         CODEC2(pPager, pData, pPg-&gt;pgno, 7, return SQLITE_NOMEM_BKPT, pData2);</span>
<span class="udiff-line-removed">-       }else</span>
<span class="udiff-line-removed">- #endif</span>
        pData2 = pData;
        PAGERTRACE((&quot;STMT-JOURNAL %d page %d\n&quot;, PAGERID(pPager), pPg-&gt;pgno));
        rc = write32bits(pPager-&gt;sjfd, offset, pPg-&gt;pgno);
        if( rc==SQLITE_OK ){
          rc = sqlite3OsWrite(pPager-&gt;sjfd, pData2, pPager-&gt;pageSize, offset+4);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -56231,10 +56363,11 @@</span>
    **     Pager object                    (sizeof(Pager) bytes)
    **     PCache object                   (sqlite3PcacheSize() bytes)
    **     Database file handle            (pVfs-&gt;szOsFile bytes)
    **     Sub-journal file handle         (journalFileSize bytes)
    **     Main journal file handle        (journalFileSize bytes)
<span class="udiff-line-added">+   **     Ptr back to the Pager           (sizeof(Pager*) bytes)</span>
    **     \0\0\0\0 database prefix        (4 bytes)
    **     Database file name              (nPathname+1 bytes)
    **     URI query parameters            (nUriByte bytes)
    **     Journal filename                (nPathname+8+1 bytes)
    **     WAL filename                    (nPathname+4+1 bytes)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -56259,16 +56392,22 @@</span>
    **   - \0
    **   - Journal Path
    **   - \0
    **   - WAL Path (zWALName)
    **   - \0
<span class="udiff-line-added">+   **</span>
<span class="udiff-line-added">+   ** The sqlite3_create_filename() interface and the databaseFilename() utility</span>
<span class="udiff-line-added">+   ** that is used by sqlite3_filename_database() and kin also depend on the</span>
<span class="udiff-line-added">+   ** specific formatting and order of the various filenames, so if the format</span>
<span class="udiff-line-added">+   ** changes here, be sure to change it there as well.</span>
    */
    pPtr = (u8 *)sqlite3MallocZero(
      ROUND8(sizeof(*pPager)) +            /* Pager structure */
      ROUND8(pcacheSize) +                 /* PCache object */
      ROUND8(pVfs-&gt;szOsFile) +             /* The main db file */
      journalFileSize * 2 +                /* The two journal files */
<span class="udiff-line-added">+     sizeof(pPager) +                     /* Space to hold a pointer */</span>
      4 +                                  /* Database prefix */
      nPathname + 1 +                      /* database filename */
      nUriByte +                           /* query parameters */
      nPathname + 8 + 1 +                  /* Journal filename */
  #ifndef SQLITE_OMIT_WAL
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -56285,10 +56424,11 @@</span>
    pPager-&gt;pPCache = (PCache*)pPtr;        pPtr += ROUND8(pcacheSize);
    pPager-&gt;fd = (sqlite3_file*)pPtr;       pPtr += ROUND8(pVfs-&gt;szOsFile);
    pPager-&gt;sjfd = (sqlite3_file*)pPtr;     pPtr += journalFileSize;
    pPager-&gt;jfd =  (sqlite3_file*)pPtr;     pPtr += journalFileSize;
    assert( EIGHT_BYTE_ALIGNMENT(pPager-&gt;jfd) );
<span class="udiff-line-added">+   memcpy(pPtr, &amp;pPager, sizeof(pPager));  pPtr += sizeof(pPager);</span>
  
    /* Fill in the Pager.zFilename and pPager.zQueryParam fields */
                                            pPtr += 4;  /* Skip zero prefix */
    pPager-&gt;zFilename = (char*)pPtr;
    if( nPathname&gt;0 ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -56485,10 +56625,23 @@</span>
  
    *ppPager = pPager;
    return SQLITE_OK;
  }
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Return the sqlite3_file for the main database given the name</span>
<span class="udiff-line-added">+ ** of the corresonding WAL or Journal name as passed into</span>
<span class="udiff-line-added">+ ** xOpen.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ SQLITE_API sqlite3_file *sqlite3_database_file_object(const char *zName){</span>
<span class="udiff-line-added">+   Pager *pPager;</span>
<span class="udiff-line-added">+   while( zName[-1]!=0 || zName[-2]!=0 || zName[-3]!=0 || zName[-4]!=0 ){</span>
<span class="udiff-line-added">+     zName--;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   pPager = *(Pager**)(zName - 4 - sizeof(Pager*));</span>
<span class="udiff-line-added">+   return pPager-&gt;fd;</span>
<span class="udiff-line-added">+ }</span>
  
  
  /*
  ** This function is called after transitioning from PAGER_UNLOCK to
  ** PAGER_SHARED state. It tests if there is a hot journal present in
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -57040,13 +57193,10 @@</span>
    const int bMmapOk = (pgno&gt;1
     &amp;&amp; (pPager-&gt;eState==PAGER_READER || (flags &amp; PAGER_GET_READONLY))
    );
  
    assert( USEFETCH(pPager) );
<span class="udiff-line-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">-   assert( pPager-&gt;xCodec==0 );</span>
<span class="udiff-line-removed">- #endif</span>
  
    /* Optimization note:  Adding the &quot;pgno&lt;=1&quot; term before &quot;pgno==0&quot; here
    ** allows the compiler optimizer to reuse the results of the &quot;pgno&gt;1&quot;
    ** test in the previous statement, and avoid testing pgno==0 in the
    ** common case where pgno is large. */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -57173,11 +57323,10 @@</span>
    Pager *pPager;
    assert( pPg!=0 );
    assert( pPg-&gt;pgno==1 );
    assert( (pPg-&gt;flags &amp; PGHDR_MMAP)==0 ); /* Page1 is never memory mapped */
    pPager = pPg-&gt;pPager;
<span class="udiff-line-removed">-   sqlite3PagerResetLockTimeout(pPager);</span>
    sqlite3PcacheRelease(pPg);
    pagerUnlockIfUnused(pPager);
  }
  
  /*
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -57371,11 +57520,11 @@</span>
    ** contains the database locks.  The following assert verifies
    ** that we do not. */
    assert( pPg-&gt;pgno!=PAGER_MJ_PGNO(pPager) );
  
    assert( pPager-&gt;journalHdr&lt;=pPager-&gt;journalOff );
<span class="udiff-line-modified-removed">-   CODEC2(pPager, pPg-&gt;pData, pPg-&gt;pgno, 7, return SQLITE_NOMEM_BKPT, pData2);</span>
<span class="udiff-line-modified-added">+   pData2 = pPg-&gt;pData;</span>
    cksum = pager_cksum(pPager, (u8*)pData2);
  
    /* Even if an IO or diskfull error occurs while journalling the
    ** page in the block above, set the need-sync flag for the page.
    ** Otherwise, when the transaction is rolled back, the logic in
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -57736,11 +57885,11 @@</span>
  
        /* If running in direct mode, write the contents of page 1 to the file. */
        if( DIRECT_MODE ){
          const void *zBuf;
          assert( pPager-&gt;dbFileSize&gt;0 );
<span class="udiff-line-modified-removed">-         CODEC2(pPager, pPgHdr-&gt;pData, 1, 6, rc=SQLITE_NOMEM_BKPT, zBuf);</span>
<span class="udiff-line-modified-added">+         zBuf = pPgHdr-&gt;pData;</span>
          if( rc==SQLITE_OK ){
            rc = sqlite3OsWrite(pPager-&gt;fd, zBuf, pPager-&gt;pageSize, 0);
            pPager-&gt;aStat[PAGER_STAT_WRITE]++;
          }
          if( rc==SQLITE_OK ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -58446,11 +58595,11 @@</span>
  **
  ** The return value to this routine is always safe to use with
  ** sqlite3_uri_parameter() and sqlite3_filename_database() and friends.
  */
  SQLITE_PRIVATE const char *sqlite3PagerFilename(const Pager *pPager, int nullIfMemDb){
<span class="udiff-line-modified-removed">-   static const char zFake[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };</span>
<span class="udiff-line-modified-added">+   static const char zFake[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };</span>
    return (nullIfMemDb &amp;&amp; pPager-&gt;memDb) ? &amp;zFake[4] : pPager-&gt;zFilename;
  }
  
  /*
  ** Return the VFS structure for the pager.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -58466,20 +58615,10 @@</span>
  */
  SQLITE_PRIVATE sqlite3_file *sqlite3PagerFile(Pager *pPager){
    return pPager-&gt;fd;
  }
  
<span class="udiff-line-removed">- #ifdef SQLITE_ENABLE_SETLK_TIMEOUT</span>
<span class="udiff-line-removed">- /*</span>
<span class="udiff-line-removed">- ** Reset the lock timeout for pager.</span>
<span class="udiff-line-removed">- */</span>
<span class="udiff-line-removed">- SQLITE_PRIVATE void sqlite3PagerResetLockTimeout(Pager *pPager){</span>
<span class="udiff-line-removed">-   int x = 0;</span>
<span class="udiff-line-removed">-   sqlite3OsFileControl(pPager-&gt;fd, SQLITE_FCNTL_LOCK_TIMEOUT, &amp;x);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
  /*
  ** Return the file handle for the journal file (if it exists).
  ** This will be either the rollback journal or the WAL file.
  */
  SQLITE_PRIVATE sqlite3_file *sqlite3PagerJrnlFile(Pager *pPager){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -58495,58 +58634,10 @@</span>
  */
  SQLITE_PRIVATE const char *sqlite3PagerJournalname(Pager *pPager){
    return pPager-&gt;zJournal;
  }
  
<span class="udiff-line-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">- /*</span>
<span class="udiff-line-removed">- ** Set or retrieve the codec for this pager</span>
<span class="udiff-line-removed">- */</span>
<span class="udiff-line-removed">- SQLITE_PRIVATE void sqlite3PagerSetCodec(</span>
<span class="udiff-line-removed">-   Pager *pPager,</span>
<span class="udiff-line-removed">-   void *(*xCodec)(void*,void*,Pgno,int),</span>
<span class="udiff-line-removed">-   void (*xCodecSizeChng)(void*,int,int),</span>
<span class="udiff-line-removed">-   void (*xCodecFree)(void*),</span>
<span class="udiff-line-removed">-   void *pCodec</span>
<span class="udiff-line-removed">- ){</span>
<span class="udiff-line-removed">-   if( pPager-&gt;xCodecFree ){</span>
<span class="udiff-line-removed">-     pPager-&gt;xCodecFree(pPager-&gt;pCodec);</span>
<span class="udiff-line-removed">-   }else{</span>
<span class="udiff-line-removed">-     pager_reset(pPager);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   pPager-&gt;xCodec = pPager-&gt;memDb ? 0 : xCodec;</span>
<span class="udiff-line-removed">-   pPager-&gt;xCodecSizeChng = xCodecSizeChng;</span>
<span class="udiff-line-removed">-   pPager-&gt;xCodecFree = xCodecFree;</span>
<span class="udiff-line-removed">-   pPager-&gt;pCodec = pCodec;</span>
<span class="udiff-line-removed">-   setGetterMethod(pPager);</span>
<span class="udiff-line-removed">-   pagerReportSize(pPager);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- SQLITE_PRIVATE void *sqlite3PagerGetCodec(Pager *pPager){</span>
<span class="udiff-line-removed">-   return pPager-&gt;pCodec;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- /*</span>
<span class="udiff-line-removed">- ** This function is called by the wal module when writing page content</span>
<span class="udiff-line-removed">- ** into the log file.</span>
<span class="udiff-line-removed">- **</span>
<span class="udiff-line-removed">- ** This function returns a pointer to a buffer containing the encrypted</span>
<span class="udiff-line-removed">- ** page content. If a malloc fails, this function may return NULL.</span>
<span class="udiff-line-removed">- */</span>
<span class="udiff-line-removed">- SQLITE_PRIVATE void *sqlite3PagerCodec(PgHdr *pPg){</span>
<span class="udiff-line-removed">-   void *aData = 0;</span>
<span class="udiff-line-removed">-   CODEC2(pPg-&gt;pPager, pPg-&gt;pData, pPg-&gt;pgno, 6, return 0, aData);</span>
<span class="udiff-line-removed">-   return aData;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- /*</span>
<span class="udiff-line-removed">- ** Return the current pager state</span>
<span class="udiff-line-removed">- */</span>
<span class="udiff-line-removed">- SQLITE_PRIVATE int sqlite3PagerState(Pager *pPager){</span>
<span class="udiff-line-removed">-   return pPager-&gt;eState;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif /* SQLITE_HAS_CODEC */</span>
<span class="udiff-line-removed">- </span>
  #ifndef SQLITE_OMIT_AUTOVACUUM
  /*
  ** Move the page pPg to location pgno in the file.
  **
  ** There must be no references to the page previously located at
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -58937,11 +59028,10 @@</span>
          (eMode==SQLITE_CHECKPOINT_PASSIVE ? 0 : pPager-&gt;xBusyHandler),
          pPager-&gt;pBusyHandlerArg,
          pPager-&gt;walSyncFlags, pPager-&gt;pageSize, (u8 *)pPager-&gt;pTmpSpace,
          pnLog, pnCkpt
      );
<span class="udiff-line-removed">-     sqlite3PagerResetLockTimeout(pPager);</span>
    }
    return rc;
  }
  
  SQLITE_PRIVATE int sqlite3PagerWalCallback(Pager *pPager){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -59102,11 +59192,35 @@</span>
      }
    }
    return rc;
  }
  
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_SETLK_TIMEOUT</span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** If pager pPager is a wal-mode database not in exclusive locking mode,</span>
<span class="udiff-line-added">+ ** invoke the sqlite3WalWriteLock() function on the associated Wal object</span>
<span class="udiff-line-added">+ ** with the same db and bLock parameters as were passed to this function.</span>
<span class="udiff-line-added">+ ** Return an SQLite error code if an error occurs, or SQLITE_OK otherwise.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE int sqlite3PagerWalWriteLock(Pager *pPager, int bLock){</span>
<span class="udiff-line-added">+   int rc = SQLITE_OK;</span>
<span class="udiff-line-added">+   if( pagerUseWal(pPager) &amp;&amp; pPager-&gt;exclusiveMode==0 ){</span>
<span class="udiff-line-added">+     rc = sqlite3WalWriteLock(pPager-&gt;pWal, bLock);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return rc;</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Set the database handle used by the wal layer to determine if</span>
<span class="udiff-line-added">+ ** blocking locks are required.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE void sqlite3PagerWalDb(Pager *pPager, sqlite3 *db){</span>
<span class="udiff-line-added">+   if( pagerUseWal(pPager) ){</span>
<span class="udiff-line-added">+     sqlite3WalDb(pPager-&gt;pWal, db);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #endif</span>
  
  #ifdef SQLITE_ENABLE_SNAPSHOT
  /*
  ** If this is a WAL database, obtain a snapshot handle for the snapshot
  ** currently open. Otherwise, return an error.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -59122,11 +59236,14 @@</span>
  /*
  ** If this is a WAL database, store a pointer to pSnapshot. Next time a
  ** read transaction is opened, attempt to read from the snapshot it
  ** identifies. If this is not a WAL database, return an error.
  */
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE int sqlite3PagerSnapshotOpen(Pager *pPager, sqlite3_snapshot *pSnapshot){</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE int sqlite3PagerSnapshotOpen(</span>
<span class="udiff-line-added">+   Pager *pPager,</span>
<span class="udiff-line-added">+   sqlite3_snapshot *pSnapshot</span>
<span class="udiff-line-added">+ ){</span>
    int rc = SQLITE_OK;
    if( pPager-&gt;pWal ){
      sqlite3WalSnapshotOpen(pPager-&gt;pWal, pSnapshot);
    }else{
      rc = SQLITE_ERROR;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -59458,22 +59575,10 @@</span>
  # define WALTRACE(X)  if(sqlite3WalTrace) sqlite3DebugPrintf X
  #else
  # define WALTRACE(X)
  #endif
  
<span class="udiff-line-removed">- /*</span>
<span class="udiff-line-removed">- ** WAL mode depends on atomic aligned 32-bit loads and stores in a few</span>
<span class="udiff-line-removed">- ** places.  The following macros try to make this explicit.</span>
<span class="udiff-line-removed">- */</span>
<span class="udiff-line-removed">- #if GCC_VESRION&gt;=5004000</span>
<span class="udiff-line-removed">- # define AtomicLoad(PTR)       __atomic_load_n((PTR),__ATOMIC_RELAXED)</span>
<span class="udiff-line-removed">- # define AtomicStore(PTR,VAL)  __atomic_store_n((PTR),(VAL),__ATOMIC_RELAXED)</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">- # define AtomicLoad(PTR)       (*(PTR))</span>
<span class="udiff-line-removed">- # define AtomicStore(PTR,VAL)  (*(PTR) = (VAL))</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
  /*
  ** The maximum (and only) versions of the wal and wal-index formats
  ** that may be interpreted by this version of SQLite.
  **
  ** If a client begins recovering a WAL file and finds that (a) the checksum
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -59679,10 +59784,13 @@</span>
    u8 lockError;              /* True if a locking error has occurred */
  #endif
  #ifdef SQLITE_ENABLE_SNAPSHOT
    WalIndexHdr *pSnapshot;    /* Start transaction here if not NULL */
  #endif
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_SETLK_TIMEOUT</span>
<span class="udiff-line-added">+   sqlite3 *db;</span>
<span class="udiff-line-added">+ #endif</span>
  };
  
  /*
  ** Candidate values for Wal.exclusiveMode.
  */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -59777,11 +59885,11 @@</span>
  
    /* Enlarge the pWal-&gt;apWiData[] array if required */
    if( pWal-&gt;nWiData&lt;=iPage ){
      sqlite3_int64 nByte = sizeof(u32*)*(iPage+1);
      volatile u32 **apNew;
<span class="udiff-line-modified-removed">-     apNew = (volatile u32 **)sqlite3_realloc64((void *)pWal-&gt;apWiData, nByte);</span>
<span class="udiff-line-modified-added">+     apNew = (volatile u32 **)sqlite3Realloc((void *)pWal-&gt;apWiData, nByte);</span>
      if( !apNew ){
        *ppPage = 0;
        return SQLITE_NOMEM_BKPT;
      }
      memset((void*)&amp;apNew[pWal-&gt;nWiData], 0,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -59898,29 +60006,47 @@</span>
  
    aOut[0] = s1;
    aOut[1] = s2;
  }
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** If there is the possibility of concurrent access to the SHM file</span>
<span class="udiff-line-added">+ ** from multiple threads and/or processes, then do a memory barrier.</span>
<span class="udiff-line-added">+ */</span>
  static void walShmBarrier(Wal *pWal){
    if( pWal-&gt;exclusiveMode!=WAL_HEAPMEMORY_MODE ){
      sqlite3OsShmBarrier(pWal-&gt;pDbFd);
    }
  }
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Add the SQLITE_NO_TSAN as part of the return-type of a function</span>
<span class="udiff-line-added">+ ** definition as a hint that the function contains constructs that</span>
<span class="udiff-line-added">+ ** might give false-positive TSAN warnings.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** See tag-20200519-1.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ #if defined(__clang__) &amp;&amp; !defined(SQLITE_NO_TSAN)</span>
<span class="udiff-line-added">+ # define SQLITE_NO_TSAN __attribute__((no_sanitize_thread))</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+ # define SQLITE_NO_TSAN</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  /*
  ** Write the header information in pWal-&gt;hdr into the wal-index.
  **
  ** The checksum on pWal-&gt;hdr is updated before it is written.
  */
<span class="udiff-line-modified-removed">- static void walIndexWriteHdr(Wal *pWal){</span>
<span class="udiff-line-modified-added">+ static SQLITE_NO_TSAN void walIndexWriteHdr(Wal *pWal){</span>
    volatile WalIndexHdr *aHdr = walIndexHdr(pWal);
    const int nCksum = offsetof(WalIndexHdr, aCksum);
  
    assert( pWal-&gt;writeLock );
    pWal-&gt;hdr.isInit = 1;
    pWal-&gt;hdr.iVersion = WALINDEX_MAX_VERSION;
    walChecksumBytes(1, (u8*)&amp;pWal-&gt;hdr, nCksum, 0, pWal-&gt;hdr.aCksum);
<span class="udiff-line-added">+   /* Possible TSAN false-positive.  See tag-20200519-1 */</span>
    memcpy((void*)&amp;aHdr[1], (const void*)&amp;pWal-&gt;hdr, sizeof(WalIndexHdr));
    walShmBarrier(pWal);
    memcpy((void*)&amp;aHdr[0], (const void*)&amp;pWal-&gt;hdr, sizeof(WalIndexHdr));
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -60052,11 +60178,11 @@</span>
    if( pWal-&gt;exclusiveMode ) return SQLITE_OK;
    rc = sqlite3OsShmLock(pWal-&gt;pDbFd, lockIdx, 1,
                          SQLITE_SHM_LOCK | SQLITE_SHM_SHARED);
    WALTRACE((&quot;WAL%p: acquire SHARED-%s %s\n&quot;, pWal,
              walLockName(lockIdx), rc ? &quot;failed&quot; : &quot;ok&quot;));
<span class="udiff-line-modified-removed">-   VVA_ONLY( pWal-&gt;lockError = (u8)(rc!=SQLITE_OK &amp;&amp; rc!=SQLITE_BUSY); )</span>
<span class="udiff-line-modified-added">+   VVA_ONLY( pWal-&gt;lockError = (u8)(rc!=SQLITE_OK &amp;&amp; (rc&amp;0xFF)!=SQLITE_BUSY); )</span>
    return rc;
  }
  static void walUnlockShared(Wal *pWal, int lockIdx){
    if( pWal-&gt;exclusiveMode ) return;
    (void)sqlite3OsShmLock(pWal-&gt;pDbFd, lockIdx, 1,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -60068,11 +60194,11 @@</span>
    if( pWal-&gt;exclusiveMode ) return SQLITE_OK;
    rc = sqlite3OsShmLock(pWal-&gt;pDbFd, lockIdx, n,
                          SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE);
    WALTRACE((&quot;WAL%p: acquire EXCLUSIVE-%s cnt=%d %s\n&quot;, pWal,
              walLockName(lockIdx), n, rc ? &quot;failed&quot; : &quot;ok&quot;));
<span class="udiff-line-modified-removed">-   VVA_ONLY( pWal-&gt;lockError = (u8)(rc!=SQLITE_OK &amp;&amp; rc!=SQLITE_BUSY); )</span>
<span class="udiff-line-modified-added">+   VVA_ONLY( pWal-&gt;lockError = (u8)(rc!=SQLITE_OK &amp;&amp; (rc&amp;0xFF)!=SQLITE_BUSY); )</span>
    return rc;
  }
  static void walUnlockExclusive(Wal *pWal, int lockIdx, int n){
    if( pWal-&gt;exclusiveMode ) return;
    (void)sqlite3OsShmLock(pWal-&gt;pDbFd, lockIdx, n,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -60888,10 +61014,93 @@</span>
    }
    *pp = p;
    return rc;
  }
  
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_SETLK_TIMEOUT</span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Attempt to enable blocking locks. Blocking locks are enabled only if (a)</span>
<span class="udiff-line-added">+ ** they are supported by the VFS, and (b) the database handle is configured</span>
<span class="udiff-line-added">+ ** with a busy-timeout. Return 1 if blocking locks are successfully enabled,</span>
<span class="udiff-line-added">+ ** or 0 otherwise.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static int walEnableBlocking(Wal *pWal){</span>
<span class="udiff-line-added">+   int res = 0;</span>
<span class="udiff-line-added">+   if( pWal-&gt;db ){</span>
<span class="udiff-line-added">+     int tmout = pWal-&gt;db-&gt;busyTimeout;</span>
<span class="udiff-line-added">+     if( tmout ){</span>
<span class="udiff-line-added">+       int rc;</span>
<span class="udiff-line-added">+       rc = sqlite3OsFileControl(</span>
<span class="udiff-line-added">+           pWal-&gt;pDbFd, SQLITE_FCNTL_LOCK_TIMEOUT, (void*)&amp;tmout</span>
<span class="udiff-line-added">+       );</span>
<span class="udiff-line-added">+       res = (rc==SQLITE_OK);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return res;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Disable blocking locks.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static void walDisableBlocking(Wal *pWal){</span>
<span class="udiff-line-added">+   int tmout = 0;</span>
<span class="udiff-line-added">+   sqlite3OsFileControl(pWal-&gt;pDbFd, SQLITE_FCNTL_LOCK_TIMEOUT, (void*)&amp;tmout);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** If parameter bLock is true, attempt to enable blocking locks, take</span>
<span class="udiff-line-added">+ ** the WRITER lock, and then disable blocking locks. If blocking locks</span>
<span class="udiff-line-added">+ ** cannot be enabled, no attempt to obtain the WRITER lock is made. Return</span>
<span class="udiff-line-added">+ ** an SQLite error code if an error occurs, or SQLITE_OK otherwise. It is not</span>
<span class="udiff-line-added">+ ** an error if blocking locks can not be enabled.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** If the bLock parameter is false and the WRITER lock is held, release it.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE int sqlite3WalWriteLock(Wal *pWal, int bLock){</span>
<span class="udiff-line-added">+   int rc = SQLITE_OK;</span>
<span class="udiff-line-added">+   assert( pWal-&gt;readLock&lt;0 || bLock==0 );</span>
<span class="udiff-line-added">+   if( bLock ){</span>
<span class="udiff-line-added">+     assert( pWal-&gt;db );</span>
<span class="udiff-line-added">+     if( walEnableBlocking(pWal) ){</span>
<span class="udiff-line-added">+       rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1);</span>
<span class="udiff-line-added">+       if( rc==SQLITE_OK ){</span>
<span class="udiff-line-added">+         pWal-&gt;writeLock = 1;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       walDisableBlocking(pWal);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }else if( pWal-&gt;writeLock ){</span>
<span class="udiff-line-added">+     walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);</span>
<span class="udiff-line-added">+     pWal-&gt;writeLock = 0;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return rc;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Set the database handle used to determine if blocking locks are required.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE void sqlite3WalDb(Wal *pWal, sqlite3 *db){</span>
<span class="udiff-line-added">+   pWal-&gt;db = db;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Take an exclusive WRITE lock. Blocking if so configured.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static int walLockWriter(Wal *pWal){</span>
<span class="udiff-line-added">+   int rc;</span>
<span class="udiff-line-added">+   walEnableBlocking(pWal);</span>
<span class="udiff-line-added">+   rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1);</span>
<span class="udiff-line-added">+   walDisableBlocking(pWal);</span>
<span class="udiff-line-added">+   return rc;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+ # define walEnableBlocking(x) 0</span>
<span class="udiff-line-added">+ # define walDisableBlocking(x)</span>
<span class="udiff-line-added">+ # define walLockWriter(pWal) walLockExclusive((pWal), WAL_WRITE_LOCK, 1)</span>
<span class="udiff-line-added">+ # define sqlite3WalDb(pWal, db)</span>
<span class="udiff-line-added">+ #endif   /* ifdef SQLITE_ENABLE_SETLK_TIMEOUT */</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  /*
  ** Attempt to obtain the exclusive WAL lock defined by parameters lockIdx and
  ** n. If the attempt fails and parameter xBusy is not NULL, then it is a
  ** busy-handler function. Invoke it and retry the lock until either the
  ** lock is successfully obtained or the busy-handler returns 0.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -60905,10 +61114,16 @@</span>
  ){
    int rc;
    do {
      rc = walLockExclusive(pWal, lockIdx, n);
    }while( xBusy &amp;&amp; rc==SQLITE_BUSY &amp;&amp; xBusy(pBusyArg) );
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_SETLK_TIMEOUT</span>
<span class="udiff-line-added">+   if( rc==SQLITE_BUSY_TIMEOUT ){</span>
<span class="udiff-line-added">+     walDisableBlocking(pWal);</span>
<span class="udiff-line-added">+     rc = SQLITE_BUSY;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif</span>
    return rc;
  }
  
  /*
  ** The cache of the wal-index header must be valid to call this function.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -60942,11 +61157,11 @@</span>
    pWal-&gt;nCkpt++;
    pWal-&gt;hdr.mxFrame = 0;
    sqlite3Put4byte((u8*)&amp;aSalt[0], 1 + sqlite3Get4byte((u8*)&amp;aSalt[0]));
    memcpy(&amp;pWal-&gt;hdr.aSalt[1], &amp;salt1, 4);
    walIndexWriteHdr(pWal);
<span class="udiff-line-modified-removed">-   pInfo-&gt;nBackfill = 0;</span>
<span class="udiff-line-modified-added">+   AtomicStore(&amp;pInfo-&gt;nBackfill, 0);</span>
    pInfo-&gt;nBackfillAttempted = 0;
    pInfo-&gt;aReadMark[1] = 0;
    for(i=2; i&lt;WAL_NREADER; i++) pInfo-&gt;aReadMark[i] = READMARK_NOT_USED;
    assert( pInfo-&gt;aReadMark[0]==0 );
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61017,36 +61232,17 @@</span>
      ** cannot be backfilled from the WAL.
      */
      mxSafeFrame = pWal-&gt;hdr.mxFrame;
      mxPage = pWal-&gt;hdr.nPage;
      for(i=1; i&lt;WAL_NREADER; i++){
<span class="udiff-line-modified-removed">-       /* Thread-sanitizer reports that the following is an unsafe read,</span>
<span class="udiff-line-removed">-       ** as some other thread may be in the process of updating the value</span>
<span class="udiff-line-removed">-       ** of the aReadMark[] slot. The assumption here is that if that is</span>
<span class="udiff-line-removed">-       ** happening, the other client may only be increasing the value,</span>
<span class="udiff-line-removed">-       ** not decreasing it. So assuming either that either the &quot;old&quot; or</span>
<span class="udiff-line-removed">-       ** &quot;new&quot; version of the value is read, and not some arbitrary value</span>
<span class="udiff-line-removed">-       ** that would never be written by a real client, things are still</span>
<span class="udiff-line-removed">-       ** safe.</span>
<span class="udiff-line-removed">-       **</span>
<span class="udiff-line-removed">-       ** Astute readers have pointed out that the assumption stated in the</span>
<span class="udiff-line-removed">-       ** last sentence of the previous paragraph is not guaranteed to be</span>
<span class="udiff-line-removed">-       ** true for all conforming systems.  However, the assumption is true</span>
<span class="udiff-line-removed">-       ** for all compilers and architectures in common use today (circa</span>
<span class="udiff-line-removed">-       ** 2019-11-27) and the alternatives are both slow and complex, and</span>
<span class="udiff-line-removed">-       ** so we will continue to go with the current design for now.  If this</span>
<span class="udiff-line-removed">-       ** bothers you, or if you really are running on a system where aligned</span>
<span class="udiff-line-removed">-       ** 32-bit reads and writes are not atomic, then you can simply avoid</span>
<span class="udiff-line-removed">-       ** the use of WAL mode, or only use WAL mode together with</span>
<span class="udiff-line-removed">-       ** PRAGMA locking_mode=EXCLUSIVE and all will be well.</span>
<span class="udiff-line-removed">-       */</span>
<span class="udiff-line-removed">-       u32 y = pInfo-&gt;aReadMark[i];</span>
<span class="udiff-line-modified-added">+       u32 y = AtomicLoad(pInfo-&gt;aReadMark+i);</span>
        if( mxSafeFrame&gt;y ){
          assert( y&lt;=pWal-&gt;hdr.mxFrame );
          rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(i), 1);
          if( rc==SQLITE_OK ){
<span class="udiff-line-modified-removed">-           pInfo-&gt;aReadMark[i] = (i==1 ? mxSafeFrame : READMARK_NOT_USED);</span>
<span class="udiff-line-modified-added">+           u32 iMark = (i==1 ? mxSafeFrame : READMARK_NOT_USED);</span>
<span class="udiff-line-added">+           AtomicStore(pInfo-&gt;aReadMark+i, iMark);</span>
            walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);
          }else if( rc==SQLITE_BUSY ){
            mxSafeFrame = y;
            xBusy = 0;
          }else{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61060,11 +61256,11 @@</span>
        rc = walIteratorInit(pWal, pInfo-&gt;nBackfill, &amp;pIter);
        assert( rc==SQLITE_OK || pIter==0 );
      }
  
      if( pIter
<span class="udiff-line-modified-removed">-      &amp;&amp; (rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(0),1))==SQLITE_OK</span>
<span class="udiff-line-modified-added">+      &amp;&amp; (rc = walBusyLock(pWal,xBusy,pBusyArg,WAL_READ_LOCK(0),1))==SQLITE_OK</span>
      ){
        u32 nBackfill = pInfo-&gt;nBackfill;
  
        pInfo-&gt;nBackfillAttempted = mxSafeFrame;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61075,10 +61271,11 @@</span>
        ** about the eventual size of the db file to the VFS layer.
        */
        if( rc==SQLITE_OK ){
          i64 nReq = ((i64)mxPage * szPage);
          i64 nSize;                    /* Current size of database file */
<span class="udiff-line-added">+         sqlite3OsFileControl(pWal-&gt;pDbFd, SQLITE_FCNTL_CKPT_START, 0);</span>
          rc = sqlite3OsFileSize(pWal-&gt;pDbFd, &amp;nSize);
          if( rc==SQLITE_OK &amp;&amp; nSize&lt;nReq ){
            sqlite3OsFileControlHint(pWal-&gt;pDbFd, SQLITE_FCNTL_SIZE_HINT, &amp;nReq);
          }
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61086,11 +61283,11 @@</span>
  
        /* Iterate through the contents of the WAL, copying data to the db file */
        while( rc==SQLITE_OK &amp;&amp; 0==walIteratorNext(pIter, &amp;iDbpage, &amp;iFrame) ){
          i64 iOffset;
          assert( walFramePgno(pWal, iFrame)==iDbpage );
<span class="udiff-line-modified-removed">-         if( db-&gt;u1.isInterrupted ){</span>
<span class="udiff-line-modified-added">+         if( AtomicLoad(&amp;db-&gt;u1.isInterrupted) ){</span>
            rc = db-&gt;mallocFailed ? SQLITE_NOMEM_BKPT : SQLITE_INTERRUPT;
            break;
          }
          if( iFrame&lt;=nBackfill || iFrame&gt;mxSafeFrame || iDbpage&gt;mxPage ){
            continue;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61102,10 +61299,11 @@</span>
          iOffset = (iDbpage-1)*(i64)szPage;
          testcase( IS_BIG_INT(iOffset) );
          rc = sqlite3OsWrite(pWal-&gt;pDbFd, zBuf, szPage, iOffset);
          if( rc!=SQLITE_OK ) break;
        }
<span class="udiff-line-added">+       sqlite3OsFileControl(pWal-&gt;pDbFd, SQLITE_FCNTL_CKPT_DONE, 0);</span>
  
        /* If work was actually accomplished... */
        if( rc==SQLITE_OK ){
          if( mxSafeFrame==walIndexHdr(pWal)-&gt;mxFrame ){
            i64 szDb = pWal-&gt;hdr.nPage*(i64)szPage;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61114,15 +61312,11 @@</span>
            if( rc==SQLITE_OK ){
              rc = sqlite3OsSync(pWal-&gt;pDbFd, CKPT_SYNC_FLAGS(sync_flags));
            }
          }
          if( rc==SQLITE_OK ){
<span class="udiff-line-modified-removed">-           rc = sqlite3OsFileControl(pWal-&gt;pDbFd, SQLITE_FCNTL_CKPT_DONE, 0);</span>
<span class="udiff-line-removed">-           if( rc==SQLITE_NOTFOUND ) rc = SQLITE_OK;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if( rc==SQLITE_OK ){</span>
<span class="udiff-line-removed">-           pInfo-&gt;nBackfill = mxSafeFrame;</span>
<span class="udiff-line-modified-added">+           AtomicStore(&amp;pInfo-&gt;nBackfill, mxSafeFrame);</span>
          }
        }
  
        /* Release the reader lock held while backfilling */
        walUnlockExclusive(pWal, WAL_READ_LOCK(0), 1);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61277,11 +61471,11 @@</span>
  ** and *pChanged is set to 1.
  **
  ** If the checksum cannot be verified return non-zero. If the header
  ** is read successfully and the checksum verified, return zero.
  */
<span class="udiff-line-modified-removed">- static int walIndexTryHdr(Wal *pWal, int *pChanged){</span>
<span class="udiff-line-modified-added">+ static SQLITE_NO_TSAN int walIndexTryHdr(Wal *pWal, int *pChanged){</span>
    u32 aCksum[2];                  /* Checksum on the header content */
    WalIndexHdr h1, h2;             /* Two copies of the header content */
    WalIndexHdr volatile *aHdr;     /* Header in shared memory */
  
    /* The first page of the wal-index must be mapped at this point. */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61290,17 +61484,23 @@</span>
    /* Read the header. This might happen concurrently with a write to the
    ** same area of shared memory on a different CPU in a SMP,
    ** meaning it is possible that an inconsistent snapshot is read
    ** from the file. If this happens, return non-zero.
    **
<span class="udiff-line-added">+   ** tag-20200519-1:</span>
    ** There are two copies of the header at the beginning of the wal-index.
    ** When reading, read [0] first then [1].  Writes are in the reverse order.
    ** Memory barriers are used to prevent the compiler or the hardware from
<span class="udiff-line-modified-removed">-   ** reordering the reads and writes.</span>
<span class="udiff-line-modified-added">+   ** reordering the reads and writes.  TSAN and similar tools can sometimes</span>
<span class="udiff-line-added">+   ** give false-positive warnings about these accesses because the tools do not</span>
<span class="udiff-line-added">+   ** account for the double-read and the memory barrier. The use of mutexes</span>
<span class="udiff-line-added">+   ** here would be problematic as the memory being accessed is potentially</span>
<span class="udiff-line-added">+   ** shared among multiple processes and not all mutex implementions work</span>
<span class="udiff-line-added">+   ** reliably in that environment.</span>
    */
    aHdr = walIndexHdr(pWal);
<span class="udiff-line-modified-removed">-   memcpy(&amp;h1, (void *)&amp;aHdr[0], sizeof(h1));</span>
<span class="udiff-line-modified-added">+   memcpy(&amp;h1, (void *)&amp;aHdr[0], sizeof(h1)); /* Possible TSAN false-positive */</span>
    walShmBarrier(pWal);
    memcpy(&amp;h2, (void *)&amp;aHdr[1], sizeof(h2));
  
    if( memcmp(&amp;h1, &amp;h2, sizeof(h1))!=0 ){
      return 1;   /* Dirty read */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61386,32 +61586,36 @@</span>
    badHdr = (page0 ? walIndexTryHdr(pWal, pChanged) : 1);
  
    /* If the first attempt failed, it might have been due to a race
    ** with a writer.  So get a WRITE lock and try again.
    */
<span class="udiff-line-removed">-   assert( badHdr==0 || pWal-&gt;writeLock==0 );</span>
    if( badHdr ){
      if( pWal-&gt;bShmUnreliable==0 &amp;&amp; (pWal-&gt;readOnly &amp; WAL_SHM_RDONLY) ){
        if( SQLITE_OK==(rc = walLockShared(pWal, WAL_WRITE_LOCK)) ){
          walUnlockShared(pWal, WAL_WRITE_LOCK);
          rc = SQLITE_READONLY_RECOVERY;
        }
<span class="udiff-line-modified-removed">-     }else if( SQLITE_OK==(rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1)) ){</span>
<span class="udiff-line-modified-removed">-       pWal-&gt;writeLock = 1;</span>
<span class="udiff-line-modified-removed">-       if( SQLITE_OK==(rc = walIndexPage(pWal, 0, &amp;page0)) ){</span>
<span class="udiff-line-modified-removed">-         badHdr = walIndexTryHdr(pWal, pChanged);</span>
<span class="udiff-line-modified-removed">-         if( badHdr ){</span>
<span class="udiff-line-modified-removed">-           /* If the wal-index header is still malformed even while holding</span>
<span class="udiff-line-modified-removed">-           ** a WRITE lock, it can only mean that the header is corrupted and</span>
<span class="udiff-line-modified-removed">-           ** needs to be reconstructed.  So run recovery to do exactly that.</span>
<span class="udiff-line-modified-removed">-           */</span>
<span class="udiff-line-modified-removed">-           rc = walIndexRecover(pWal);</span>
<span class="udiff-line-modified-removed">-           *pChanged = 1;</span>
<span class="udiff-line-modified-added">+     }else{</span>
<span class="udiff-line-modified-added">+       int bWriteLock = pWal-&gt;writeLock;</span>
<span class="udiff-line-modified-added">+       if( bWriteLock || SQLITE_OK==(rc = walLockWriter(pWal)) ){</span>
<span class="udiff-line-modified-added">+         pWal-&gt;writeLock = 1;</span>
<span class="udiff-line-modified-added">+         if( SQLITE_OK==(rc = walIndexPage(pWal, 0, &amp;page0)) ){</span>
<span class="udiff-line-modified-added">+           badHdr = walIndexTryHdr(pWal, pChanged);</span>
<span class="udiff-line-modified-added">+           if( badHdr ){</span>
<span class="udiff-line-modified-added">+             /* If the wal-index header is still malformed even while holding</span>
<span class="udiff-line-modified-added">+             ** a WRITE lock, it can only mean that the header is corrupted and</span>
<span class="udiff-line-modified-added">+             ** needs to be reconstructed.  So run recovery to do exactly that.</span>
<span class="udiff-line-modified-added">+             */</span>
<span class="udiff-line-added">+             rc = walIndexRecover(pWal);</span>
<span class="udiff-line-added">+             *pChanged = 1;</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if( bWriteLock==0 ){</span>
<span class="udiff-line-added">+           pWal-&gt;writeLock = 0;</span>
<span class="udiff-line-added">+           walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);</span>
          }
        }
<span class="udiff-line-removed">-       pWal-&gt;writeLock = 0;</span>
<span class="udiff-line-removed">-       walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);</span>
      }
    }
  
    /* If the header is read successfully, check the version number to make
    ** sure the wal-index was not constructed with some future format that
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61737,11 +61941,11 @@</span>
    }
  
    assert( pWal-&gt;nWiData&gt;0 );
    assert( pWal-&gt;apWiData[0]!=0 );
    pInfo = walCkptInfo(pWal);
<span class="udiff-line-modified-removed">-   if( !useWal &amp;&amp; pInfo-&gt;nBackfill==pWal-&gt;hdr.mxFrame</span>
<span class="udiff-line-modified-added">+   if( !useWal &amp;&amp; AtomicLoad(&amp;pInfo-&gt;nBackfill)==pWal-&gt;hdr.mxFrame</span>
  #ifdef SQLITE_ENABLE_SNAPSHOT
     &amp;&amp; (pWal-&gt;pSnapshot==0 || pWal-&gt;hdr.mxFrame==0)
  #endif
    ){
      /* The WAL has been completely backfilled (or it is empty).
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61799,11 +62003,12 @@</span>
     &amp;&amp; (mxReadMark&lt;mxFrame || mxI==0)
    ){
      for(i=1; i&lt;WAL_NREADER; i++){
        rc = walLockExclusive(pWal, WAL_READ_LOCK(i), 1);
        if( rc==SQLITE_OK ){
<span class="udiff-line-modified-removed">-         mxReadMark = AtomicStore(pInfo-&gt;aReadMark+i,mxFrame);</span>
<span class="udiff-line-modified-added">+         AtomicStore(pInfo-&gt;aReadMark+i,mxFrame);</span>
<span class="udiff-line-added">+         mxReadMark = mxFrame;</span>
          mxI = i;
          walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);
          break;
        }else if( rc!=SQLITE_BUSY ){
          return rc;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61903,11 +62108,11 @@</span>
        void *pBuf2 = sqlite3_malloc(szPage);
        if( pBuf1==0 || pBuf2==0 ){
          rc = SQLITE_NOMEM;
        }else{
          u32 i = pInfo-&gt;nBackfillAttempted;
<span class="udiff-line-modified-removed">-         for(i=pInfo-&gt;nBackfillAttempted; i&gt;pInfo-&gt;nBackfill; i--){</span>
<span class="udiff-line-modified-added">+         for(i=pInfo-&gt;nBackfillAttempted; i&gt;AtomicLoad(&amp;pInfo-&gt;nBackfill); i--){</span>
            WalHashLoc sLoc;          /* Hash table location */
            u32 pgno;                 /* Page number in db file */
            i64 iDbOff;               /* Offset of db file entry */
            i64 iWalOff;              /* Offset of wal file entry */
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61958,16 +62163,39 @@</span>
  ** needs to be flushed.
  */
  SQLITE_PRIVATE int sqlite3WalBeginReadTransaction(Wal *pWal, int *pChanged){
    int rc;                         /* Return code */
    int cnt = 0;                    /* Number of TryBeginRead attempts */
<span class="udiff-line-removed">- </span>
  #ifdef SQLITE_ENABLE_SNAPSHOT
    int bChanged = 0;
    WalIndexHdr *pSnapshot = pWal-&gt;pSnapshot;
<span class="udiff-line-modified-removed">-   if( pSnapshot &amp;&amp; memcmp(pSnapshot, &amp;pWal-&gt;hdr, sizeof(WalIndexHdr))!=0 ){</span>
<span class="udiff-line-modified-removed">-     bChanged = 1;</span>
<span class="udiff-line-modified-added">+ #endif</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   assert( pWal-&gt;ckptLock==0 );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_SNAPSHOT</span>
<span class="udiff-line-added">+   if( pSnapshot ){</span>
<span class="udiff-line-added">+     if( memcmp(pSnapshot, &amp;pWal-&gt;hdr, sizeof(WalIndexHdr))!=0 ){</span>
<span class="udiff-line-added">+       bChanged = 1;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /* It is possible that there is a checkpointer thread running</span>
<span class="udiff-line-added">+     ** concurrent with this code. If this is the case, it may be that the</span>
<span class="udiff-line-added">+     ** checkpointer has already determined that it will checkpoint</span>
<span class="udiff-line-added">+     ** snapshot X, where X is later in the wal file than pSnapshot, but</span>
<span class="udiff-line-added">+     ** has not yet set the pInfo-&gt;nBackfillAttempted variable to indicate</span>
<span class="udiff-line-added">+     ** its intent. To avoid the race condition this leads to, ensure that</span>
<span class="udiff-line-added">+     ** there is no checkpointer process by taking a shared CKPT lock</span>
<span class="udiff-line-added">+     ** before checking pInfo-&gt;nBackfillAttempted.  */</span>
<span class="udiff-line-added">+     (void)walEnableBlocking(pWal);</span>
<span class="udiff-line-added">+     rc = walLockShared(pWal, WAL_CKPT_LOCK);</span>
<span class="udiff-line-added">+     walDisableBlocking(pWal);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if( rc!=SQLITE_OK ){</span>
<span class="udiff-line-added">+       return rc;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     pWal-&gt;ckptLock = 1;</span>
    }
  #endif
  
    do{
      rc = walTryBeginRead(pWal, pChanged, 0, ++cnt);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61996,52 +62224,46 @@</span>
        volatile WalCkptInfo *pInfo = walCkptInfo(pWal);
  
        assert( pWal-&gt;readLock&gt;0 || pWal-&gt;hdr.mxFrame==0 );
        assert( pInfo-&gt;aReadMark[pWal-&gt;readLock]&lt;=pSnapshot-&gt;mxFrame );
  
<span class="udiff-line-modified-removed">-       /* It is possible that there is a checkpointer thread running</span>
<span class="udiff-line-modified-removed">-       ** concurrent with this code. If this is the case, it may be that the</span>
<span class="udiff-line-modified-removed">-       ** checkpointer has already determined that it will checkpoint</span>
<span class="udiff-line-modified-removed">-       ** snapshot X, where X is later in the wal file than pSnapshot, but</span>
<span class="udiff-line-modified-removed">-       ** has not yet set the pInfo-&gt;nBackfillAttempted variable to indicate</span>
<span class="udiff-line-modified-removed">-       ** its intent. To avoid the race condition this leads to, ensure that</span>
<span class="udiff-line-modified-removed">-       ** there is no checkpointer process by taking a shared CKPT lock</span>
<span class="udiff-line-modified-removed">-       ** before checking pInfo-&gt;nBackfillAttempted.</span>
<span class="udiff-line-modified-removed">-       **</span>
<span class="udiff-line-modified-removed">-       ** TODO: Does the aReadMark[] lock prevent a checkpointer from doing</span>
<span class="udiff-line-modified-removed">-       **       this already?</span>
<span class="udiff-line-modified-removed">-       */</span>
<span class="udiff-line-modified-removed">-       rc = walLockShared(pWal, WAL_CKPT_LOCK);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-       if( rc==SQLITE_OK ){</span>
<span class="udiff-line-removed">-         /* Check that the wal file has not been wrapped. Assuming that it has</span>
<span class="udiff-line-removed">-         ** not, also check that no checkpointer has attempted to checkpoint any</span>
<span class="udiff-line-removed">-         ** frames beyond pSnapshot-&gt;mxFrame. If either of these conditions are</span>
<span class="udiff-line-removed">-         ** true, return SQLITE_ERROR_SNAPSHOT. Otherwise, overwrite pWal-&gt;hdr</span>
<span class="udiff-line-removed">-         ** with *pSnapshot and set *pChanged as appropriate for opening the</span>
<span class="udiff-line-removed">-         ** snapshot.  */</span>
<span class="udiff-line-removed">-         if( !memcmp(pSnapshot-&gt;aSalt, pWal-&gt;hdr.aSalt, sizeof(pWal-&gt;hdr.aSalt))</span>
<span class="udiff-line-removed">-          &amp;&amp; pSnapshot-&gt;mxFrame&gt;=pInfo-&gt;nBackfillAttempted</span>
<span class="udiff-line-removed">-         ){</span>
<span class="udiff-line-removed">-           assert( pWal-&gt;readLock&gt;0 );</span>
<span class="udiff-line-removed">-           memcpy(&amp;pWal-&gt;hdr, pSnapshot, sizeof(WalIndexHdr));</span>
<span class="udiff-line-removed">-           *pChanged = bChanged;</span>
<span class="udiff-line-removed">-         }else{</span>
<span class="udiff-line-removed">-           rc = SQLITE_ERROR_SNAPSHOT;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /* Release the shared CKPT lock obtained above. */</span>
<span class="udiff-line-removed">-         walUnlockShared(pWal, WAL_CKPT_LOCK);</span>
<span class="udiff-line-removed">-         pWal-&gt;minFrame = 1;</span>
<span class="udiff-line-modified-added">+       /* Check that the wal file has not been wrapped. Assuming that it has</span>
<span class="udiff-line-modified-added">+       ** not, also check that no checkpointer has attempted to checkpoint any</span>
<span class="udiff-line-modified-added">+       ** frames beyond pSnapshot-&gt;mxFrame. If either of these conditions are</span>
<span class="udiff-line-modified-added">+       ** true, return SQLITE_ERROR_SNAPSHOT. Otherwise, overwrite pWal-&gt;hdr</span>
<span class="udiff-line-modified-added">+       ** with *pSnapshot and set *pChanged as appropriate for opening the</span>
<span class="udiff-line-modified-added">+       ** snapshot.  */</span>
<span class="udiff-line-modified-added">+       if( !memcmp(pSnapshot-&gt;aSalt, pWal-&gt;hdr.aSalt, sizeof(pWal-&gt;hdr.aSalt))</span>
<span class="udiff-line-modified-added">+        &amp;&amp; pSnapshot-&gt;mxFrame&gt;=pInfo-&gt;nBackfillAttempted</span>
<span class="udiff-line-modified-added">+       ){</span>
<span class="udiff-line-modified-added">+         assert( pWal-&gt;readLock&gt;0 );</span>
<span class="udiff-line-modified-added">+         memcpy(&amp;pWal-&gt;hdr, pSnapshot, sizeof(WalIndexHdr));</span>
<span class="udiff-line-modified-added">+         *pChanged = bChanged;</span>
<span class="udiff-line-modified-added">+       }else{</span>
<span class="udiff-line-modified-added">+         rc = SQLITE_ERROR_SNAPSHOT;</span>
        }
  
<span class="udiff-line-added">+       /* A client using a non-current snapshot may not ignore any frames</span>
<span class="udiff-line-added">+       ** from the start of the wal file. This is because, for a system</span>
<span class="udiff-line-added">+       ** where (minFrame &lt; iSnapshot &lt; maxFrame), a checkpointer may</span>
<span class="udiff-line-added">+       ** have omitted to checkpoint a frame earlier than minFrame in</span>
<span class="udiff-line-added">+       ** the file because there exists a frame after iSnapshot that</span>
<span class="udiff-line-added">+       ** is the same database page.  */</span>
<span class="udiff-line-added">+       pWal-&gt;minFrame = 1;</span>
  
        if( rc!=SQLITE_OK ){
          sqlite3WalEndReadTransaction(pWal);
        }
      }
    }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   /* Release the shared CKPT lock obtained above. */</span>
<span class="udiff-line-added">+   if( pWal-&gt;ckptLock ){</span>
<span class="udiff-line-added">+     assert( pSnapshot );</span>
<span class="udiff-line-added">+     walUnlockShared(pWal, WAL_CKPT_LOCK);</span>
<span class="udiff-line-added">+     pWal-&gt;ckptLock = 0;</span>
<span class="udiff-line-added">+   }</span>
  #endif
    return rc;
  }
  
  /*
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -62117,26 +62339,28 @@</span>
    for(iHash=walFramePage(iLast); iHash&gt;=iMinHash; iHash--){
      WalHashLoc sLoc;              /* Hash table location */
      int iKey;                     /* Hash slot index */
      int nCollide;                 /* Number of hash collisions remaining */
      int rc;                       /* Error code */
<span class="udiff-line-added">+     u32 iH;</span>
  
      rc = walHashGet(pWal, iHash, &amp;sLoc);
      if( rc!=SQLITE_OK ){
        return rc;
      }
      nCollide = HASHTABLE_NSLOT;
<span class="udiff-line-modified-removed">-     for(iKey=walHash(pgno); sLoc.aHash[iKey]; iKey=walNextHash(iKey)){</span>
<span class="udiff-line-modified-removed">-       u32 iH = sLoc.aHash[iKey];</span>
<span class="udiff-line-modified-added">+     iKey = walHash(pgno);</span>
<span class="udiff-line-modified-added">+     while( (iH = AtomicLoad(&amp;sLoc.aHash[iKey]))!=0 ){</span>
        u32 iFrame = iH + sLoc.iZero;
        if( iFrame&lt;=iLast &amp;&amp; iFrame&gt;=pWal-&gt;minFrame &amp;&amp; sLoc.aPgno[iH]==pgno ){
          assert( iFrame&gt;iRead || CORRUPT_DB );
          iRead = iFrame;
        }
        if( (nCollide--)==0 ){
          return SQLITE_CORRUPT_BKPT;
        }
<span class="udiff-line-added">+       iKey = walNextHash(iKey);</span>
      }
      if( iRead ) break;
    }
  
  #ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -62208,10 +62432,20 @@</span>
  ** There can only be a single writer active at a time.
  */
  SQLITE_PRIVATE int sqlite3WalBeginWriteTransaction(Wal *pWal){
    int rc;
  
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_SETLK_TIMEOUT</span>
<span class="udiff-line-added">+   /* If the write-lock is already held, then it was obtained before the</span>
<span class="udiff-line-added">+   ** read-transaction was even opened, making this call a no-op.</span>
<span class="udiff-line-added">+   ** Return early. */</span>
<span class="udiff-line-added">+   if( pWal-&gt;writeLock ){</span>
<span class="udiff-line-added">+     assert( !memcmp(&amp;pWal-&gt;hdr,(void *)walIndexHdr(pWal),sizeof(WalIndexHdr)) );</span>
<span class="udiff-line-added">+     return SQLITE_OK;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
    /* Cannot start a write transaction without first holding a read
    ** transaction. */
    assert( pWal-&gt;readLock&gt;=0 );
    assert( pWal-&gt;writeLock==0 &amp;&amp; pWal-&gt;iReCksum==0 );
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -62453,15 +62687,11 @@</span>
    sqlite3_int64 iOffset       /* Byte offset at which to write */
  ){
    int rc;                         /* Result code from subfunctions */
    void *pData;                    /* Data actually written */
    u8 aFrame[WAL_FRAME_HDRSIZE];   /* Buffer to assemble frame-header in */
<span class="udiff-line-removed">- #if defined(SQLITE_HAS_CODEC)</span>
<span class="udiff-line-removed">-   if( (pData = sqlite3PagerCodec(pPage))==0 ) return SQLITE_NOMEM_BKPT;</span>
<span class="udiff-line-removed">- #else</span>
    pData = pPage-&gt;pData;
<span class="udiff-line-removed">- #endif</span>
    walEncodeFrame(p-&gt;pWal, pPage-&gt;pgno, nTruncate, pData, aFrame);
    rc = walWriteToLog(p, aFrame, sizeof(aFrame), iOffset);
    if( rc ) return rc;
    /* Write the page data */
    rc = walWriteToLog(p, pData, p-&gt;szPage, iOffset+sizeof(aFrame));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -62640,15 +62870,11 @@</span>
          i64 iOff = walFrameOffset(iWrite, szPage) + WAL_FRAME_HDRSIZE;
          void *pData;
          if( pWal-&gt;iReCksum==0 || iWrite&lt;pWal-&gt;iReCksum ){
            pWal-&gt;iReCksum = iWrite;
          }
<span class="udiff-line-removed">- #if defined(SQLITE_HAS_CODEC)</span>
<span class="udiff-line-removed">-         if( (pData = sqlite3PagerCodec(p))==0 ) return SQLITE_NOMEM;</span>
<span class="udiff-line-removed">- #else</span>
          pData = p-&gt;pData;
<span class="udiff-line-removed">- #endif</span>
          rc = sqlite3OsWrite(pWal-&gt;pWalFd, pData, szPage, iOff);
          if( rc ) return rc;
          p-&gt;flags &amp;= ~PGHDR_WAL_APPEND;
          continue;
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -62792,49 +63018,56 @@</span>
    assert( eMode!=SQLITE_CHECKPOINT_PASSIVE || xBusy==0 );
  
    if( pWal-&gt;readOnly ) return SQLITE_READONLY;
    WALTRACE((&quot;WAL%p: checkpoint begins\n&quot;, pWal));
  
<span class="udiff-line-added">+   /* Enable blocking locks, if possible. If blocking locks are successfully</span>
<span class="udiff-line-added">+   ** enabled, set xBusy2=0 so that the busy-handler is never invoked. */</span>
<span class="udiff-line-added">+   sqlite3WalDb(pWal, db);</span>
<span class="udiff-line-added">+   (void)walEnableBlocking(pWal);</span>
<span class="udiff-line-added">+ </span>
    /* IMPLEMENTATION-OF: R-62028-47212 All calls obtain an exclusive
<span class="udiff-line-modified-removed">-   ** &quot;checkpoint&quot; lock on the database file. */</span>
<span class="udiff-line-modified-added">+   ** &quot;checkpoint&quot; lock on the database file.</span>
<span class="udiff-line-added">+   ** EVIDENCE-OF: R-10421-19736 If any other process is running a</span>
<span class="udiff-line-added">+   ** checkpoint operation at the same time, the lock cannot be obtained and</span>
<span class="udiff-line-added">+   ** SQLITE_BUSY is returned.</span>
<span class="udiff-line-added">+   ** EVIDENCE-OF: R-53820-33897 Even if there is a busy-handler configured,</span>
<span class="udiff-line-added">+   ** it will not be invoked in this case.</span>
<span class="udiff-line-added">+   */</span>
    rc = walLockExclusive(pWal, WAL_CKPT_LOCK, 1);
<span class="udiff-line-modified-removed">-   if( rc ){</span>
<span class="udiff-line-modified-removed">-     /* EVIDENCE-OF: R-10421-19736 If any other process is running a</span>
<span class="udiff-line-modified-removed">-     ** checkpoint operation at the same time, the lock cannot be obtained and</span>
<span class="udiff-line-modified-removed">-     ** SQLITE_BUSY is returned.</span>
<span class="udiff-line-removed">-     ** EVIDENCE-OF: R-53820-33897 Even if there is a busy-handler configured,</span>
<span class="udiff-line-removed">-     ** it will not be invoked in this case.</span>
<span class="udiff-line-removed">-     */</span>
<span class="udiff-line-removed">-     testcase( rc==SQLITE_BUSY );</span>
<span class="udiff-line-removed">-     testcase( xBusy!=0 );</span>
<span class="udiff-line-removed">-     return rc;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   pWal-&gt;ckptLock = 1;</span>
<span class="udiff-line-modified-added">+   testcase( rc==SQLITE_BUSY );</span>
<span class="udiff-line-modified-added">+   testcase( rc!=SQLITE_OK &amp;&amp; xBusy2!=0 );</span>
<span class="udiff-line-modified-added">+   if( rc==SQLITE_OK ){</span>
<span class="udiff-line-modified-added">+     pWal-&gt;ckptLock = 1;</span>
  
<span class="udiff-line-modified-removed">-   /* IMPLEMENTATION-OF: R-59782-36818 The SQLITE_CHECKPOINT_FULL, RESTART and</span>
<span class="udiff-line-modified-removed">-   ** TRUNCATE modes also obtain the exclusive &quot;writer&quot; lock on the database</span>
<span class="udiff-line-modified-removed">-   ** file.</span>
<span class="udiff-line-modified-removed">-   **</span>
<span class="udiff-line-modified-removed">-   ** EVIDENCE-OF: R-60642-04082 If the writer lock cannot be obtained</span>
<span class="udiff-line-modified-removed">-   ** immediately, and a busy-handler is configured, it is invoked and the</span>
<span class="udiff-line-modified-removed">-   ** writer lock retried until either the busy-handler returns 0 or the</span>
<span class="udiff-line-modified-removed">-   ** lock is successfully obtained.</span>
<span class="udiff-line-modified-removed">-   */</span>
<span class="udiff-line-modified-removed">-   if( eMode!=SQLITE_CHECKPOINT_PASSIVE ){</span>
<span class="udiff-line-modified-removed">-     rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_WRITE_LOCK, 1);</span>
<span class="udiff-line-modified-removed">-     if( rc==SQLITE_OK ){</span>
<span class="udiff-line-modified-removed">-       pWal-&gt;writeLock = 1;</span>
<span class="udiff-line-modified-removed">-     }else if( rc==SQLITE_BUSY ){</span>
<span class="udiff-line-modified-removed">-       eMode2 = SQLITE_CHECKPOINT_PASSIVE;</span>
<span class="udiff-line-modified-removed">-       xBusy2 = 0;</span>
<span class="udiff-line-modified-removed">-       rc = SQLITE_OK;</span>
<span class="udiff-line-modified-added">+     /* IMPLEMENTATION-OF: R-59782-36818 The SQLITE_CHECKPOINT_FULL, RESTART and</span>
<span class="udiff-line-modified-added">+     ** TRUNCATE modes also obtain the exclusive &quot;writer&quot; lock on the database</span>
<span class="udiff-line-modified-added">+     ** file.</span>
<span class="udiff-line-modified-added">+     **</span>
<span class="udiff-line-modified-added">+     ** EVIDENCE-OF: R-60642-04082 If the writer lock cannot be obtained</span>
<span class="udiff-line-modified-added">+     ** immediately, and a busy-handler is configured, it is invoked and the</span>
<span class="udiff-line-modified-added">+     ** writer lock retried until either the busy-handler returns 0 or the</span>
<span class="udiff-line-modified-added">+     ** lock is successfully obtained.</span>
<span class="udiff-line-modified-added">+     */</span>
<span class="udiff-line-modified-added">+     if( eMode!=SQLITE_CHECKPOINT_PASSIVE ){</span>
<span class="udiff-line-modified-added">+       rc = walBusyLock(pWal, xBusy2, pBusyArg, WAL_WRITE_LOCK, 1);</span>
<span class="udiff-line-modified-added">+       if( rc==SQLITE_OK ){</span>
<span class="udiff-line-modified-added">+         pWal-&gt;writeLock = 1;</span>
<span class="udiff-line-modified-added">+       }else if( rc==SQLITE_BUSY ){</span>
<span class="udiff-line-modified-added">+         eMode2 = SQLITE_CHECKPOINT_PASSIVE;</span>
<span class="udiff-line-modified-added">+         xBusy2 = 0;</span>
<span class="udiff-line-modified-added">+         rc = SQLITE_OK;</span>
<span class="udiff-line-added">+       }</span>
      }
    }
  
<span class="udiff-line-added">+ </span>
    /* Read the wal-index header. */
    if( rc==SQLITE_OK ){
<span class="udiff-line-added">+     walDisableBlocking(pWal);</span>
      rc = walIndexReadHdr(pWal, &amp;isChanged);
<span class="udiff-line-added">+     (void)walEnableBlocking(pWal);</span>
      if( isChanged &amp;&amp; pWal-&gt;pDbFd-&gt;pMethods-&gt;iVersion&gt;=3 ){
        sqlite3OsUnfetch(pWal-&gt;pDbFd, 0, 0);
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -62862,15 +63095,23 @@</span>
      ** the cache needs to be reset.
      */
      memset(&amp;pWal-&gt;hdr, 0, sizeof(WalIndexHdr));
    }
  
<span class="udiff-line-added">+   walDisableBlocking(pWal);</span>
<span class="udiff-line-added">+   sqlite3WalDb(pWal, 0);</span>
<span class="udiff-line-added">+ </span>
    /* Release the locks. */
    sqlite3WalEndWriteTransaction(pWal);
<span class="udiff-line-modified-removed">-   walUnlockExclusive(pWal, WAL_CKPT_LOCK, 1);</span>
<span class="udiff-line-modified-removed">-   pWal-&gt;ckptLock = 0;</span>
<span class="udiff-line-modified-added">+   if( pWal-&gt;ckptLock ){</span>
<span class="udiff-line-modified-added">+     walUnlockExclusive(pWal, WAL_CKPT_LOCK, 1);</span>
<span class="udiff-line-added">+     pWal-&gt;ckptLock = 0;</span>
<span class="udiff-line-added">+   }</span>
    WALTRACE((&quot;WAL%p: checkpoint %s\n&quot;, pWal, rc ? &quot;failed&quot; : &quot;ok&quot;));
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_SETLK_TIMEOUT</span>
<span class="udiff-line-added">+   if( rc==SQLITE_BUSY_TIMEOUT ) rc = SQLITE_BUSY;</span>
<span class="udiff-line-added">+ #endif</span>
    return (rc==SQLITE_OK &amp;&amp; eMode!=eMode2 ? SQLITE_BUSY : rc);
  }
  
  /* Return the value to pass to a sqlite3_wal_hook callback, the
  ** number of frames in the WAL at the point of the last commit since
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -62983,11 +63224,14 @@</span>
    return rc;
  }
  
  /* Try to open on pSnapshot when the next read-transaction starts
  */
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE void sqlite3WalSnapshotOpen(Wal *pWal, sqlite3_snapshot *pSnapshot){</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE void sqlite3WalSnapshotOpen(</span>
<span class="udiff-line-added">+   Wal *pWal,</span>
<span class="udiff-line-added">+   sqlite3_snapshot *pSnapshot</span>
<span class="udiff-line-added">+ ){</span>
    pWal-&gt;pSnapshot = (WalIndexHdr*)pSnapshot;
  }
  
  /*
  ** Return a +ve value if snapshot p1 is newer than p2. A -ve value if
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -63502,13 +63746,11 @@</span>
    u8 incrVacuum;        /* True if incr-vacuum is enabled */
    u8 bDoTruncate;       /* True to truncate db on commit */
  #endif
    u8 inTransaction;     /* Transaction state */
    u8 max1bytePayload;   /* Maximum first byte of cell for a 1-byte payload */
<span class="udiff-line-modified-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">-   u8 optimalReserve;    /* Desired amount of reserved space per page */</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+   u8 nReserveWanted;    /* Desired number of extra bytes per page */</span>
    u16 btsFlags;         /* Boolean parameters.  See BTS_* macros below */
    u16 maxLocal;         /* Maximum local payload in non-LEAFDATA tables */
    u16 minLocal;         /* Minimum local payload in non-LEAFDATA tables */
    u16 maxLeaf;          /* Maximum local payload in a LEAFDATA table */
    u16 minLeaf;          /* Minimum local payload in a LEAFDATA table */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -64294,20 +64536,22 @@</span>
    ** b-trees, this is just the root page of the b-tree being read or
    ** written. For index b-trees, it is the root page of the associated
    ** table.  */
    if( isIndex ){
      HashElem *p;
<span class="udiff-line-added">+     int bSeen = 0;</span>
      for(p=sqliteHashFirst(&amp;pSchema-&gt;idxHash); p; p=sqliteHashNext(p)){
        Index *pIdx = (Index *)sqliteHashData(p);
        if( pIdx-&gt;tnum==(int)iRoot ){
<span class="udiff-line-modified-removed">-         if( iTab ){</span>
<span class="udiff-line-modified-added">+         if( bSeen ){</span>
            /* Two or more indexes share the same root page.  There must
            ** be imposter tables.  So just return true.  The assert is not
            ** useful in that case. */
            return 1;
          }
          iTab = pIdx-&gt;pTable-&gt;tnum;
<span class="udiff-line-added">+         bSeen = 1;</span>
        }
      }
    }else{
      iTab = iRoot;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -64705,11 +64949,11 @@</span>
  ** free-list for reuse. It returns false if it is safe to retrieve the
  ** page from the pager layer with the &#39;no-content&#39; flag set. True otherwise.
  */
  static int btreeGetHasContent(BtShared *pBt, Pgno pgno){
    Bitvec *p = pBt-&gt;pHasContent;
<span class="udiff-line-modified-removed">-   return (p &amp;&amp; (pgno&gt;sqlite3BitvecSize(p) || sqlite3BitvecTest(p, pgno)));</span>
<span class="udiff-line-modified-added">+   return p &amp;&amp; (pgno&gt;sqlite3BitvecSize(p) || sqlite3BitvecTestNotNull(p, pgno));</span>
  }
  
  /*
  ** Clear (destroy) the BtShared.pHasContent bitvec. This should be
  ** invoked at the conclusion of each write-transaction.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -65543,11 +65787,11 @@</span>
          u8 *pEnd = &amp;data[cellOffset + nCell*2];
          u8 *pAddr;
          int sz2 = 0;
          int sz = get2byte(&amp;data[iFree+2]);
          int top = get2byte(&amp;data[hdr+5]);
<span class="udiff-line-modified-removed">-         if( NEVER(top&gt;=iFree) ){</span>
<span class="udiff-line-modified-added">+         if( top&gt;=iFree ){</span>
            return SQLITE_CORRUPT_PAGE(pPage);
          }
          if( iFree2 ){
            if( iFree+sz&gt;iFree2 ) return SQLITE_CORRUPT_PAGE(pPage);
            sz2 = get2byte(&amp;data[iFree2+2]);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -65845,11 +66089,11 @@</span>
      */
      if( iFreeBlk &amp;&amp; iEnd+3&gt;=iFreeBlk ){
        nFrag = iFreeBlk - iEnd;
        if( iEnd&gt;iFreeBlk ) return SQLITE_CORRUPT_PAGE(pPage);
        iEnd = iFreeBlk + get2byte(&amp;data[iFreeBlk+2]);
<span class="udiff-line-modified-removed">-       if( NEVER(iEnd &gt; pPage-&gt;pBt-&gt;usableSize) ){</span>
<span class="udiff-line-modified-added">+       if( iEnd &gt; pPage-&gt;pBt-&gt;usableSize ){</span>
          return SQLITE_CORRUPT_PAGE(pPage);
        }
        iSize = iEnd - iStart;
        iFreeBlk = get2byte(&amp;data[iFreeBlk]);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -65874,11 +66118,11 @@</span>
    if( iStart&lt;=x ){
      /* The new freeblock is at the beginning of the cell content area,
      ** so just extend the cell content area rather than create another
      ** freelist entry */
      if( iStart&lt;x ) return SQLITE_CORRUPT_PAGE(pPage);
<span class="udiff-line-modified-removed">-     if( NEVER(iPtr!=hdr+1) ) return SQLITE_CORRUPT_PAGE(pPage);</span>
<span class="udiff-line-modified-added">+     if( iPtr!=hdr+1 ) return SQLITE_CORRUPT_PAGE(pPage);</span>
      put2byte(&amp;data[hdr+1], iFreeBlk);
      put2byte(&amp;data[hdr+5], iEnd);
    }else{
      /* Insert the new freeblock into the freelist */
      put2byte(&amp;data[iPtr], iStart);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -66398,12 +66642,11 @@</span>
  */
  static int btreeInvokeBusyHandler(void *pArg){
    BtShared *pBt = (BtShared*)pArg;
    assert( pBt-&gt;db );
    assert( sqlite3_mutex_held(pBt-&gt;db-&gt;mutex) );
<span class="udiff-line-modified-removed">-   return sqlite3InvokeBusyHandler(&amp;pBt-&gt;db-&gt;busyHandler,</span>
<span class="udiff-line-removed">-                                   sqlite3PagerFile(pBt-&gt;pPager));</span>
<span class="udiff-line-modified-added">+   return sqlite3InvokeBusyHandler(&amp;pBt-&gt;db-&gt;busyHandler);</span>
  }
  
  /*
  ** Open a database file.
  **
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -66950,23 +67193,21 @@</span>
  ** If the iFix!=0 then the BTS_PAGESIZE_FIXED flag is set so that the page size
  ** and autovacuum mode can no longer be changed.
  */
  SQLITE_PRIVATE int sqlite3BtreeSetPageSize(Btree *p, int pageSize, int nReserve, int iFix){
    int rc = SQLITE_OK;
<span class="udiff-line-added">+   int x;</span>
    BtShared *pBt = p-&gt;pBt;
<span class="udiff-line-modified-removed">-   assert( nReserve&gt;=-1 &amp;&amp; nReserve&lt;=255 );</span>
<span class="udiff-line-modified-added">+   assert( nReserve&gt;=0 &amp;&amp; nReserve&lt;=255 );</span>
    sqlite3BtreeEnter(p);
<span class="udiff-line-modified-removed">- #if SQLITE_HAS_CODEC</span>
<span class="udiff-line-modified-removed">-   if( nReserve&gt;pBt-&gt;optimalReserve ) pBt-&gt;optimalReserve = (u8)nReserve;</span>
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-added">+   pBt-&gt;nReserveWanted = nReserve;</span>
<span class="udiff-line-modified-added">+   x = pBt-&gt;pageSize - pBt-&gt;usableSize;</span>
<span class="udiff-line-modified-added">+   if( nReserve&lt;x ) nReserve = x;</span>
    if( pBt-&gt;btsFlags &amp; BTS_PAGESIZE_FIXED ){
      sqlite3BtreeLeave(p);
      return SQLITE_READONLY;
    }
<span class="udiff-line-removed">-   if( nReserve&lt;0 ){</span>
<span class="udiff-line-removed">-     nReserve = pBt-&gt;pageSize - pBt-&gt;usableSize;</span>
<span class="udiff-line-removed">-   }</span>
    assert( nReserve&gt;=0 &amp;&amp; nReserve&lt;=255 );
    if( pageSize&gt;=512 &amp;&amp; pageSize&lt;=SQLITE_MAX_PAGE_SIZE &amp;&amp;
          ((pageSize-1)&amp;pageSize)==0 ){
      assert( (pageSize &amp; 7)==0 );
      assert( !pBt-&gt;pCursor );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -67008,23 +67249,21 @@</span>
  /*
  ** Return the number of bytes of space at the end of every page that
  ** are intentually left unused.  This is the &quot;reserved&quot; space that is
  ** sometimes used by extensions.
  **
<span class="udiff-line-modified-removed">- ** If SQLITE_HAS_MUTEX is defined then the number returned is the</span>
<span class="udiff-line-modified-removed">- ** greater of the current reserved space and the maximum requested</span>
<span class="udiff-line-modified-removed">- ** reserve space.</span>
<span class="udiff-line-modified-added">+ ** The value returned is the larger of the current reserve size and</span>
<span class="udiff-line-modified-added">+ ** the latest reserve size requested by SQLITE_FILECTRL_RESERVE_BYTES.</span>
<span class="udiff-line-modified-added">+ ** The amount of reserve can only grow - never shrink.</span>
  */
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE int sqlite3BtreeGetOptimalReserve(Btree *p){</span>
<span class="udiff-line-modified-removed">-   int n;</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE int sqlite3BtreeGetRequestedReserve(Btree *p){</span>
<span class="udiff-line-modified-added">+   int n1, n2;</span>
    sqlite3BtreeEnter(p);
<span class="udiff-line-modified-removed">-   n = sqlite3BtreeGetReserveNoMutex(p);</span>
<span class="udiff-line-modified-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">-   if( n&lt;p-&gt;pBt-&gt;optimalReserve ) n = p-&gt;pBt-&gt;optimalReserve;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+   n1 = (int)p-&gt;pBt-&gt;nReserveWanted;</span>
<span class="udiff-line-modified-added">+   n2 = sqlite3BtreeGetReserveNoMutex(p);</span>
    sqlite3BtreeLeave(p);
<span class="udiff-line-modified-removed">-   return n;</span>
<span class="udiff-line-modified-added">+   return n1&gt;n2 ? n1 : n2;</span>
  }
  
  
  /*
  ** Set the maximum page count for a database if mxPage is positive.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -67470,10 +67709,11 @@</span>
  ** when A already has a read lock, we encourage A to give up and let B
  ** proceed.
  */
  SQLITE_PRIVATE int sqlite3BtreeBeginTrans(Btree *p, int wrflag, int *pSchemaVersion){
    BtShared *pBt = p-&gt;pBt;
<span class="udiff-line-added">+   Pager *pPager = pBt-&gt;pPager;</span>
    int rc = SQLITE_OK;
  
    sqlite3BtreeEnter(p);
    btreeIntegrity(p);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -67485,11 +67725,11 @@</span>
      goto trans_begun;
    }
    assert( pBt-&gt;inTransaction==TRANS_WRITE || IfNotOmitAV(pBt-&gt;bDoTruncate)==0 );
  
    if( (p-&gt;db-&gt;flags &amp; SQLITE_ResetDatabase)
<span class="udiff-line-modified-removed">-    &amp;&amp; sqlite3PagerIsreadonly(pBt-&gt;pPager)==0</span>
<span class="udiff-line-modified-added">+    &amp;&amp; sqlite3PagerIsreadonly(pPager)==0</span>
    ){
      pBt-&gt;btsFlags &amp;= ~BTS_READ_ONLY;
    }
  
    /* Write transactions are not possible on a read-only database */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -67533,10 +67773,22 @@</span>
    if( SQLITE_OK!=rc ) goto trans_begun;
  
    pBt-&gt;btsFlags &amp;= ~BTS_INITIALLY_EMPTY;
    if( pBt-&gt;nPage==0 ) pBt-&gt;btsFlags |= BTS_INITIALLY_EMPTY;
    do {
<span class="udiff-line-added">+     sqlite3PagerWalDb(pPager, p-&gt;db);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_SETLK_TIMEOUT</span>
<span class="udiff-line-added">+     /* If transitioning from no transaction directly to a write transaction,</span>
<span class="udiff-line-added">+     ** block for the WRITER lock first if possible. */</span>
<span class="udiff-line-added">+     if( pBt-&gt;pPage1==0 &amp;&amp; wrflag ){</span>
<span class="udiff-line-added">+       assert( pBt-&gt;inTransaction==TRANS_NONE );</span>
<span class="udiff-line-added">+       rc = sqlite3PagerWalWriteLock(pPager, 1);</span>
<span class="udiff-line-added">+       if( rc!=SQLITE_BUSY &amp;&amp; rc!=SQLITE_OK ) break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
      /* Call lockBtree() until either pBt-&gt;pPage1 is populated or
      ** lockBtree() returns something other than SQLITE_OK. lockBtree()
      ** may return SQLITE_OK but leave pBt-&gt;pPage1 set to 0 if after
      ** reading page 1 it discovers that the page-size of the database
      ** file is not pBt-&gt;pageSize. In this case lockBtree() will update
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -67546,11 +67798,11 @@</span>
  
      if( rc==SQLITE_OK &amp;&amp; wrflag ){
        if( (pBt-&gt;btsFlags &amp; BTS_READ_ONLY)!=0 ){
          rc = SQLITE_READONLY;
        }else{
<span class="udiff-line-modified-removed">-         rc = sqlite3PagerBegin(pBt-&gt;pPager,wrflag&gt;1,sqlite3TempInMemory(p-&gt;db));</span>
<span class="udiff-line-modified-added">+         rc = sqlite3PagerBegin(pPager, wrflag&gt;1, sqlite3TempInMemory(p-&gt;db));</span>
          if( rc==SQLITE_OK ){
            rc = newDatabase(pBt);
          }else if( rc==SQLITE_BUSY_SNAPSHOT &amp;&amp; pBt-&gt;inTransaction==TRANS_NONE ){
            /* if there was no transaction opened when this function was
            ** called and SQLITE_BUSY_SNAPSHOT is returned, change the error
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -67559,15 +67811,19 @@</span>
          }
        }
      }
  
      if( rc!=SQLITE_OK ){
<span class="udiff-line-added">+       (void)sqlite3PagerWalWriteLock(pPager, 0);</span>
        unlockBtreeIfUnused(pBt);
      }
    }while( (rc&amp;0xFF)==SQLITE_BUSY &amp;&amp; pBt-&gt;inTransaction==TRANS_NONE &amp;&amp;
            btreeInvokeBusyHandler(pBt) );
<span class="udiff-line-modified-removed">-   sqlite3PagerResetLockTimeout(pBt-&gt;pPager);</span>
<span class="udiff-line-modified-added">+   sqlite3PagerWalDb(pPager, 0);</span>
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_SETLK_TIMEOUT</span>
<span class="udiff-line-added">+   if( rc==SQLITE_BUSY_TIMEOUT ) rc = SQLITE_BUSY;</span>
<span class="udiff-line-added">+ #endif</span>
  
    if( rc==SQLITE_OK ){
      if( p-&gt;inTrans==TRANS_NONE ){
        pBt-&gt;nTransaction++;
  #ifndef SQLITE_OMIT_SHARED_CACHE
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -67615,11 +67871,11 @@</span>
      if( wrflag ){
        /* This call makes sure that the pager has the correct number of
        ** open savepoints. If the second parameter is greater than 0 and
        ** the sub-journal is not already open, then it will be opened here.
        */
<span class="udiff-line-modified-removed">-       rc = sqlite3PagerOpenSavepoint(pBt-&gt;pPager, p-&gt;db-&gt;nSavepoint);</span>
<span class="udiff-line-modified-added">+       rc = sqlite3PagerOpenSavepoint(pPager, p-&gt;db-&gt;nSavepoint);</span>
      }
    }
  
    btreeIntegrity(p);
    sqlite3BtreeLeave(p);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -71251,11 +71507,11 @@</span>
  
    /* Remove cells from the start and end of the page */
    assert( nCell&gt;=0 );
    if( iOld&lt;iNew ){
      int nShift = pageFreeArray(pPg, iOld, iNew-iOld, pCArray);
<span class="udiff-line-modified-removed">-     if( nShift&gt;nCell ) return SQLITE_CORRUPT_BKPT;</span>
<span class="udiff-line-modified-added">+     if( NEVER(nShift&gt;nCell) ) return SQLITE_CORRUPT_BKPT;</span>
      memmove(pPg-&gt;aCellIdx, &amp;pPg-&gt;aCellIdx[nShift*2], nCell*2);
      nCell -= nShift;
    }
    if( iNewEnd &lt; iOldEnd ){
      int nTail = pageFreeArray(pPg, iNewEnd, iOldEnd - iNewEnd, pCArray);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -73608,11 +73864,10 @@</span>
    }
    sqlite3BtreeLeave(p);
    return rc;
  }
  
<span class="udiff-line-removed">- #ifndef SQLITE_OMIT_BTREECOUNT</span>
  /*
  ** The first argument, pCur, is a cursor opened on some b-tree. Count the
  ** number of entries in the b-tree and write the result to *pnEntry.
  **
  ** SQLITE_OK is returned if the operation is successfully executed.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -73630,11 +73885,11 @@</span>
    }
  
    /* Unless an error occurs, the following loop runs one iteration for each
    ** page in the B-Tree structure (not including overflow pages).
    */
<span class="udiff-line-modified-removed">-   while( rc==SQLITE_OK &amp;&amp; !db-&gt;u1.isInterrupted ){</span>
<span class="udiff-line-modified-added">+   while( rc==SQLITE_OK &amp;&amp; !AtomicLoad(&amp;db-&gt;u1.isInterrupted) ){</span>
      int iIdx;                          /* Index of child node in parent */
      MemPage *pPage;                    /* Current page of the b-tree */
  
      /* If this is a leaf page or the tree is not an int-key tree, then
      ** this page contains countable entries. Increment the entry counter
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -73681,11 +73936,10 @@</span>
    }
  
    /* An error has occurred. Return an error code. */
    return rc;
  }
<span class="udiff-line-removed">- #endif</span>
  
  /*
  ** Return the pager associated with a BTree.  This routine is used for
  ** testing and debugging only.
  */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -73756,11 +74010,11 @@</span>
    }
    if( getPageReferenced(pCheck, iPage) ){
      checkAppendMsg(pCheck, &quot;2nd reference to page %d&quot;, iPage);
      return 1;
    }
<span class="udiff-line-modified-removed">-   if( pCheck-&gt;db-&gt;u1.isInterrupted ) return 1;</span>
<span class="udiff-line-modified-added">+   if( AtomicLoad(&amp;pCheck-&gt;db-&gt;u1.isInterrupted) ) return 1;</span>
    setPageReferenced(pCheck, iPage);
    return 0;
  }
  
  #ifndef SQLITE_OMIT_AUTOVACUUM
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -74732,11 +74986,11 @@</span>
  ** Attempt to set the page size of the destination to match the page size
  ** of the source.
  */
  static int setDestPgsz(sqlite3_backup *p){
    int rc;
<span class="udiff-line-modified-removed">-   rc = sqlite3BtreeSetPageSize(p-&gt;pDest,sqlite3BtreeGetPageSize(p-&gt;pSrc),-1,0);</span>
<span class="udiff-line-modified-added">+   rc = sqlite3BtreeSetPageSize(p-&gt;pDest,sqlite3BtreeGetPageSize(p-&gt;pSrc),0,0);</span>
    return rc;
  }
  
  /*
  ** Check that there is no open read-transaction on the b-tree passed as the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -74855,17 +75109,10 @@</span>
    Pager * const pDestPager = sqlite3BtreePager(p-&gt;pDest);
    const int nSrcPgsz = sqlite3BtreeGetPageSize(p-&gt;pSrc);
    int nDestPgsz = sqlite3BtreeGetPageSize(p-&gt;pDest);
    const int nCopy = MIN(nSrcPgsz, nDestPgsz);
    const i64 iEnd = (i64)iSrcPg*(i64)nSrcPgsz;
<span class="udiff-line-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">-   /* Use BtreeGetReserveNoMutex() for the source b-tree, as although it is</span>
<span class="udiff-line-removed">-   ** guaranteed that the shared-mutex is held by this thread, handle</span>
<span class="udiff-line-removed">-   ** p-&gt;pSrc may not actually be the owner.  */</span>
<span class="udiff-line-removed">-   int nSrcReserve = sqlite3BtreeGetReserveNoMutex(p-&gt;pSrc);</span>
<span class="udiff-line-removed">-   int nDestReserve = sqlite3BtreeGetOptimalReserve(p-&gt;pDest);</span>
<span class="udiff-line-removed">- #endif</span>
    int rc = SQLITE_OK;
    i64 iOff;
  
    assert( sqlite3BtreeGetReserveNoMutex(p-&gt;pSrc)&gt;=0 );
    assert( p-&gt;bDestLocked );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -74878,30 +75125,10 @@</span>
    */
    if( nSrcPgsz!=nDestPgsz &amp;&amp; sqlite3PagerIsMemdb(pDestPager) ){
      rc = SQLITE_READONLY;
    }
  
<span class="udiff-line-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">-   /* Backup is not possible if the page size of the destination is changing</span>
<span class="udiff-line-removed">-   ** and a codec is in use.</span>
<span class="udiff-line-removed">-   */</span>
<span class="udiff-line-removed">-   if( nSrcPgsz!=nDestPgsz &amp;&amp; sqlite3PagerGetCodec(pDestPager)!=0 ){</span>
<span class="udiff-line-removed">-     rc = SQLITE_READONLY;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   /* Backup is not possible if the number of bytes of reserve space differ</span>
<span class="udiff-line-removed">-   ** between source and destination.  If there is a difference, try to</span>
<span class="udiff-line-removed">-   ** fix the destination to agree with the source.  If that is not possible,</span>
<span class="udiff-line-removed">-   ** then the backup cannot proceed.</span>
<span class="udiff-line-removed">-   */</span>
<span class="udiff-line-removed">-   if( nSrcReserve!=nDestReserve ){</span>
<span class="udiff-line-removed">-     u32 newPgsz = nSrcPgsz;</span>
<span class="udiff-line-removed">-     rc = sqlite3PagerSetPagesize(pDestPager, &amp;newPgsz, nSrcReserve);</span>
<span class="udiff-line-removed">-     if( rc==SQLITE_OK &amp;&amp; newPgsz!=(u32)nSrcPgsz ) rc = SQLITE_READONLY;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
    /* This loop runs once for each destination page spanned by the source
    ** page. For each iteration, variable iOff is set to the byte offset
    ** of the destination page.
    */
    for(iOff=iEnd-(i64)nSrcPgsz; rc==SQLITE_OK &amp;&amp; iOff&lt;iEnd; iOff+=nDestPgsz){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -75393,14 +75620,10 @@</span>
    b.pSrcDb = pFrom-&gt;db;
    b.pSrc = pFrom;
    b.pDest = pTo;
    b.iNext = 1;
  
<span class="udiff-line-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">-   sqlite3PagerAlignReserve(sqlite3BtreePager(pTo), sqlite3BtreePager(pFrom));</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
    /* 0x7FFFFFFF is the hard limit for the number of pages in a database
    ** file. By passing this as the number of pages to copy to
    ** sqlite3_backup_step(), we can guarantee that the copy finishes
    ** within a single call (unless an error occurs). The assert() statement
    ** checks this assumption - (p-&gt;rc) should be set to either SQLITE_DONE
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -76386,23 +76609,18 @@</span>
        u16 mFlags;
        if( pVdbe-&gt;db-&gt;flags &amp; SQLITE_VdbeTrace ){
          sqlite3DebugPrintf(&quot;Invalidate R[%d] due to change in R[%d]\n&quot;,
            (int)(pX - pVdbe-&gt;aMem), (int)(pMem - pVdbe-&gt;aMem));
        }
<span class="udiff-line-modified-removed">-       /* If pX is marked as a shallow copy of pMem, then verify that</span>
<span class="udiff-line-modified-added">+       /* If pX is marked as a shallow copy of pMem, then try to verify that</span>
        ** no significant changes have been made to pX since the OP_SCopy.
        ** A significant change would indicated a missed call to this
        ** function for pX.  Minor changes, such as adding or removing a
        ** dual type, are allowed, as long as the underlying value is the
        ** same. */
        mFlags = pMem-&gt;flags &amp; pX-&gt;flags &amp; pX-&gt;mScopyFlags;
        assert( (mFlags&amp;(MEM_Int|MEM_IntReal))==0 || pMem-&gt;u.i==pX-&gt;u.i );
<span class="udiff-line-removed">-       /* assert( (mFlags&amp;MEM_Real)==0 || pMem-&gt;u.r==pX-&gt;u.r ); */</span>
<span class="udiff-line-removed">-       /*                                          ^^           */</span>
<span class="udiff-line-removed">-       /*       Cannot reliably compare doubles for equality    */</span>
<span class="udiff-line-removed">-       assert( (mFlags&amp;MEM_Str)==0  || (pMem-&gt;n==pX-&gt;n &amp;&amp; pMem-&gt;z==pX-&gt;z) );</span>
<span class="udiff-line-removed">-       assert( (mFlags&amp;MEM_Blob)==0  || sqlite3BlobCompare(pMem,pX)==0 );</span>
  
        /* pMem is the register that is changing.  But also mark pX as
        ** undefined so that we can quickly detect the shallow-copy error */
        pX-&gt;flags = MEM_Undefined;
        pX-&gt;pScopyFrom = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -76594,11 +76812,11 @@</span>
  ** destroyed.
  **
  ** If this routine fails for any reason (malloc returns NULL or unable
  ** to read from the disk) then the pMem is left in an inconsistent state.
  */
<span class="udiff-line-modified-removed">- static SQLITE_NOINLINE int vdbeMemFromBtreeResize(</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE int sqlite3VdbeMemFromBtree(</span>
    BtCursor *pCur,   /* Cursor pointing at record to retrieve. */
    u32 offset,       /* Offset from the start of data to return bytes from. */
    u32 amt,          /* Number of bytes to return. */
    Mem *pMem         /* OUT: Return data in this Mem structure. */
  ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -76617,35 +76835,32 @@</span>
        sqlite3VdbeMemRelease(pMem);
      }
    }
    return rc;
  }
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE int sqlite3VdbeMemFromBtree(</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE int sqlite3VdbeMemFromBtreeZeroOffset(</span>
    BtCursor *pCur,   /* Cursor pointing at record to retrieve. */
<span class="udiff-line-removed">-   u32 offset,       /* Offset from the start of data to return bytes from. */</span>
    u32 amt,          /* Number of bytes to return. */
    Mem *pMem         /* OUT: Return data in this Mem structure. */
  ){
<span class="udiff-line-removed">-   char *zData;        /* Data from the btree layer */</span>
    u32 available = 0;  /* Number of bytes available on the local btree page */
    int rc = SQLITE_OK; /* Return code */
  
    assert( sqlite3BtreeCursorIsValid(pCur) );
    assert( !VdbeMemDynamic(pMem) );
  
    /* Note: the calls to BtreeKeyFetch() and DataFetch() below assert()
    ** that both the BtShared and database handle mutexes are held. */
    assert( !sqlite3VdbeMemIsRowSet(pMem) );
<span class="udiff-line-modified-removed">-   zData = (char *)sqlite3BtreePayloadFetch(pCur, &amp;available);</span>
<span class="udiff-line-modified-removed">-   assert( zData!=0 );</span>
<span class="udiff-line-modified-added">+   pMem-&gt;z = (char *)sqlite3BtreePayloadFetch(pCur, &amp;available);</span>
<span class="udiff-line-modified-added">+   assert( pMem-&gt;z!=0 );</span>
  
<span class="udiff-line-modified-removed">-   if( offset+amt&lt;=available ){</span>
<span class="udiff-line-removed">-     pMem-&gt;z = &amp;zData[offset];</span>
<span class="udiff-line-modified-added">+   if( amt&lt;=available ){</span>
      pMem-&gt;flags = MEM_Blob|MEM_Ephem;
      pMem-&gt;n = (int)amt;
    }else{
<span class="udiff-line-modified-removed">-     rc = vdbeMemFromBtreeResize(pCur, offset, amt, pMem);</span>
<span class="udiff-line-modified-added">+     rc = sqlite3VdbeMemFromBtree(pCur, 0, amt, pMem);</span>
    }
  
    return rc;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -77756,11 +77971,11 @@</span>
    (void)z2;
  }
  #endif
  
  /*
<span class="udiff-line-modified-removed">- ** Add a new OP_ opcode.</span>
<span class="udiff-line-modified-added">+ ** Add a new OP_Explain opcode.</span>
  **
  ** If the bPush flag is true, then make this opcode the parent for
  ** subsequent Explains until sqlite3VdbeExplainPop() is called.
  */
  SQLITE_PRIVATE void sqlite3VdbeExplain(Parse *pParse, u8 bPush, const char *zFmt, ...){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -78397,10 +78612,38 @@</span>
  */
  SQLITE_PRIVATE void sqlite3VdbeJumpHere(Vdbe *p, int addr){
    sqlite3VdbeChangeP2(p, addr, p-&gt;nOp);
  }
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Change the P2 operand of the jump instruction at addr so that</span>
<span class="udiff-line-added">+ ** the jump lands on the next opcode.  Or if the jump instruction was</span>
<span class="udiff-line-added">+ ** the previous opcode (and is thus a no-op) then simply back up</span>
<span class="udiff-line-added">+ ** the next instruction counter by one slot so that the jump is</span>
<span class="udiff-line-added">+ ** overwritten by the next inserted opcode.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** This routine is an optimization of sqlite3VdbeJumpHere() that</span>
<span class="udiff-line-added">+ ** strives to omit useless byte-code like this:</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ **        7   Once 0 8 0</span>
<span class="udiff-line-added">+ **        8   ...</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE void sqlite3VdbeJumpHereOrPopInst(Vdbe *p, int addr){</span>
<span class="udiff-line-added">+   if( addr==p-&gt;nOp-1 ){</span>
<span class="udiff-line-added">+     assert( p-&gt;aOp[addr].opcode==OP_Once</span>
<span class="udiff-line-added">+          || p-&gt;aOp[addr].opcode==OP_If</span>
<span class="udiff-line-added">+          || p-&gt;aOp[addr].opcode==OP_FkIfZero );</span>
<span class="udiff-line-added">+     assert( p-&gt;aOp[addr].p4type==0 );</span>
<span class="udiff-line-added">+ #ifdef SQLITE_VDBE_COVERAGE</span>
<span class="udiff-line-added">+     sqlite3VdbeGetOp(p,-1)-&gt;iSrcLine = 0;  /* Erase VdbeCoverage() macros */</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     p-&gt;nOp--;</span>
<span class="udiff-line-added">+   }else{</span>
<span class="udiff-line-added">+     sqlite3VdbeChangeP2(p, addr, p-&gt;nOp);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  
  /*
  ** If the input FuncDef structure is ephemeral, then free it.  If
  ** the FuncDef is not ephermal, then do nothing.
  */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -78768,21 +79011,23 @@</span>
  **       &quot;PX&quot;      -&gt;  &quot;r[X]&quot;
  **       &quot;PX@PY&quot;   -&gt;  &quot;r[X..X+Y-1]&quot;  or &quot;r[x]&quot; if y is 0 or 1
  **       &quot;PX@PY+1&quot; -&gt;  &quot;r[X..X+Y]&quot;    or &quot;r[x]&quot; if y is 0
  **       &quot;PY..PY&quot;  -&gt;  &quot;r[X..Y]&quot;      or &quot;r[x]&quot; if y&lt;=x
  */
<span class="udiff-line-modified-removed">- static int displayComment(</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE char *sqlite3VdbeDisplayComment(</span>
<span class="udiff-line-added">+   sqlite3 *db,       /* Optional - Oom error reporting only */</span>
    const Op *pOp,     /* The opcode to be commented */
<span class="udiff-line-modified-removed">-   const char *zP4,   /* Previously obtained value for P4 */</span>
<span class="udiff-line-removed">-   char *zTemp,       /* Write result here */</span>
<span class="udiff-line-removed">-   int nTemp          /* Space available in zTemp[] */</span>
<span class="udiff-line-modified-added">+   const char *zP4    /* Previously obtained value for P4 */</span>
  ){
    const char *zOpName;
    const char *zSynopsis;
    int nOpName;
<span class="udiff-line-modified-removed">-   int ii, jj;</span>
<span class="udiff-line-modified-added">+   int ii;</span>
    char zAlt[50];
<span class="udiff-line-added">+   StrAccum x;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   sqlite3StrAccumInit(&amp;x, 0, 0, 0, SQLITE_MAX_LENGTH);</span>
    zOpName = sqlite3OpcodeName(pOp-&gt;opcode);
    nOpName = sqlite3Strlen30(zOpName);
    if( zOpName[nOpName+1] ){
      int seenCom = 0;
      char c;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -78793,57 +79038,68 @@</span>
        }else{
          sqlite3_snprintf(sizeof(zAlt), zAlt, &quot;if %s goto P2&quot;, zSynopsis+3);
        }
        zSynopsis = zAlt;
      }
<span class="udiff-line-modified-removed">-     for(ii=jj=0; jj&lt;nTemp-1 &amp;&amp; (c = zSynopsis[ii])!=0; ii++){</span>
<span class="udiff-line-modified-added">+     for(ii=0; (c = zSynopsis[ii])!=0; ii++){</span>
        if( c==&#39;P&#39; ){
          c = zSynopsis[++ii];
          if( c==&#39;4&#39; ){
<span class="udiff-line-modified-removed">-           sqlite3_snprintf(nTemp-jj, zTemp+jj, &quot;%s&quot;, zP4);</span>
<span class="udiff-line-modified-added">+           sqlite3_str_appendall(&amp;x, zP4);</span>
          }else if( c==&#39;X&#39; ){
<span class="udiff-line-modified-removed">-           sqlite3_snprintf(nTemp-jj, zTemp+jj, &quot;%s&quot;, pOp-&gt;zComment);</span>
<span class="udiff-line-modified-added">+           sqlite3_str_appendall(&amp;x, pOp-&gt;zComment);</span>
            seenCom = 1;
          }else{
            int v1 = translateP(c, pOp);
            int v2;
<span class="udiff-line-removed">-           sqlite3_snprintf(nTemp-jj, zTemp+jj, &quot;%d&quot;, v1);</span>
            if( strncmp(zSynopsis+ii+1, &quot;@P&quot;, 2)==0 ){
              ii += 3;
<span class="udiff-line-removed">-             jj += sqlite3Strlen30(zTemp+jj);</span>
              v2 = translateP(zSynopsis[ii], pOp);
              if( strncmp(zSynopsis+ii+1,&quot;+1&quot;,2)==0 ){
                ii += 2;
                v2++;
              }
<span class="udiff-line-modified-removed">-             if( v2&gt;1 ){</span>
<span class="udiff-line-modified-removed">-               sqlite3_snprintf(nTemp-jj, zTemp+jj, &quot;..%d&quot;, v1+v2-1);</span>
<span class="udiff-line-modified-added">+             if( v2&lt;2 ){</span>
<span class="udiff-line-modified-added">+               sqlite3_str_appendf(&amp;x, &quot;%d&quot;, v1);</span>
<span class="udiff-line-added">+             }else{</span>
<span class="udiff-line-added">+               sqlite3_str_appendf(&amp;x, &quot;%d..%d&quot;, v1, v1+v2-1);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+           }else if( strncmp(zSynopsis+ii+1, &quot;@NP&quot;, 3)==0 ){</span>
<span class="udiff-line-added">+             sqlite3_context *pCtx = pOp-&gt;p4.pCtx;</span>
<span class="udiff-line-added">+             if( pOp-&gt;p4type!=P4_FUNCCTX || pCtx-&gt;argc==1 ){</span>
<span class="udiff-line-added">+               sqlite3_str_appendf(&amp;x, &quot;%d&quot;, v1);</span>
<span class="udiff-line-added">+             }else if( pCtx-&gt;argc&gt;1 ){</span>
<span class="udiff-line-added">+               sqlite3_str_appendf(&amp;x, &quot;%d..%d&quot;, v1, v1+pCtx-&gt;argc-1);</span>
<span class="udiff-line-added">+             }else{</span>
<span class="udiff-line-added">+               assert( x.nChar&gt;2 );</span>
<span class="udiff-line-added">+               x.nChar -= 2;</span>
<span class="udiff-line-added">+               ii++;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             ii += 3;</span>
<span class="udiff-line-added">+           }else{</span>
<span class="udiff-line-added">+             sqlite3_str_appendf(&amp;x, &quot;%d&quot;, v1);</span>
<span class="udiff-line-added">+             if( strncmp(zSynopsis+ii+1, &quot;..P3&quot;, 4)==0 &amp;&amp; pOp-&gt;p3==0 ){</span>
<span class="udiff-line-added">+               ii += 4;</span>
              }
<span class="udiff-line-removed">-           }else if( strncmp(zSynopsis+ii+1, &quot;..P3&quot;, 4)==0 &amp;&amp; pOp-&gt;p3==0 ){</span>
<span class="udiff-line-removed">-             ii += 4;</span>
            }
          }
<span class="udiff-line-removed">-         jj += sqlite3Strlen30(zTemp+jj);</span>
        }else{
<span class="udiff-line-modified-removed">-         zTemp[jj++] = c;</span>
<span class="udiff-line-modified-added">+         sqlite3_str_appendchar(&amp;x, 1, c);</span>
        }
      }
<span class="udiff-line-modified-removed">-     if( !seenCom &amp;&amp; jj&lt;nTemp-5 &amp;&amp; pOp-&gt;zComment ){</span>
<span class="udiff-line-modified-removed">-       sqlite3_snprintf(nTemp-jj, zTemp+jj, &quot;; %s&quot;, pOp-&gt;zComment);</span>
<span class="udiff-line-removed">-       jj += sqlite3Strlen30(zTemp+jj);</span>
<span class="udiff-line-modified-added">+     if( !seenCom &amp;&amp; pOp-&gt;zComment ){</span>
<span class="udiff-line-modified-added">+       sqlite3_str_appendf(&amp;x, &quot;; %s&quot;, pOp-&gt;zComment);</span>
      }
<span class="udiff-line-removed">-     if( jj&lt;nTemp ) zTemp[jj] = 0;</span>
    }else if( pOp-&gt;zComment ){
<span class="udiff-line-modified-removed">-     sqlite3_snprintf(nTemp, zTemp, &quot;%s&quot;, pOp-&gt;zComment);</span>
<span class="udiff-line-modified-removed">-     jj = sqlite3Strlen30(zTemp);</span>
<span class="udiff-line-modified-removed">-   }else{</span>
<span class="udiff-line-modified-removed">-     zTemp[0] = 0;</span>
<span class="udiff-line-removed">-     jj = 0;</span>
<span class="udiff-line-modified-added">+     sqlite3_str_appendall(&amp;x, pOp-&gt;zComment);</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   if( (x.accError &amp; SQLITE_NOMEM)!=0 &amp;&amp; db!=0 ){</span>
<span class="udiff-line-modified-added">+     sqlite3OomFault(db);</span>
    }
<span class="udiff-line-modified-removed">-   return jj;</span>
<span class="udiff-line-modified-added">+   return sqlite3StrAccumFinish(&amp;x);</span>
  }
<span class="udiff-line-modified-removed">- #endif /* SQLITE_DEBUG */</span>
<span class="udiff-line-modified-added">+ #endif /* SQLITE_ENABLE_EXPLAIN_COMMENTS */</span>
  
  #if VDBE_DISPLAY_P4 &amp;&amp; defined(SQLITE_ENABLE_CURSOR_HINTS)
  /*
  ** Translate the P4.pExpr value for an OP_CursorHint opcode into text
  ** that can be displayed in the P4 column of EXPLAIN output.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -78920,15 +79176,15 @@</span>
  #if VDBE_DISPLAY_P4
  /*
  ** Compute a string that describes the P4 parameter for an opcode.
  ** Use zTemp for any required temporary buffer space.
  */
<span class="udiff-line-modified-removed">- static char *displayP4(Op *pOp, char *zTemp, int nTemp){</span>
<span class="udiff-line-modified-removed">-   char *zP4 = zTemp;</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE char *sqlite3VdbeDisplayP4(sqlite3 *db, Op *pOp){</span>
<span class="udiff-line-modified-added">+   char *zP4 = 0;</span>
    StrAccum x;
<span class="udiff-line-modified-removed">-   assert( nTemp&gt;=20 );</span>
<span class="udiff-line-modified-removed">-   sqlite3StrAccumInit(&amp;x, 0, zTemp, nTemp, 0);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   sqlite3StrAccumInit(&amp;x, 0, 0, 0, SQLITE_MAX_LENGTH);</span>
    switch( pOp-&gt;p4type ){
      case P4_KEYINFO: {
        int j;
        KeyInfo *pKeyInfo = pOp-&gt;p4.pKeyInfo;
        assert( pKeyInfo-&gt;aSortFlags!=0 );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -78950,12 +79206,15 @@</span>
        displayP4Expr(&amp;x, pOp-&gt;p4.pExpr);
        break;
      }
  #endif
      case P4_COLLSEQ: {
<span class="udiff-line-added">+       static const char *const encnames[] = {&quot;?&quot;, &quot;8&quot;, &quot;16LE&quot;, &quot;16BE&quot;};</span>
        CollSeq *pColl = pOp-&gt;p4.pColl;
<span class="udiff-line-modified-removed">-       sqlite3_str_appendf(&amp;x, &quot;(%.20s)&quot;, pColl-&gt;zName);</span>
<span class="udiff-line-modified-added">+       assert( pColl-&gt;enc&gt;=0 &amp;&amp; pColl-&gt;enc&lt;4 );</span>
<span class="udiff-line-added">+       sqlite3_str_appendf(&amp;x, &quot;%.18s-%s&quot;, pColl-&gt;zName,</span>
<span class="udiff-line-added">+                           encnames[pColl-&gt;enc]);</span>
        break;
      }
      case P4_FUNCDEF: {
        FuncDef *pDef = pOp-&gt;p4.pFunc;
        sqlite3_str_appendf(&amp;x, &quot;%s(%d)&quot;, pDef-&gt;zName, pDef-&gt;nArg);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -79005,40 +79264,36 @@</span>
        int i;
        int *ai = pOp-&gt;p4.ai;
        int n = ai[0];   /* The first element of an INTARRAY is always the
                         ** count of the number of elements to follow */
        for(i=1; i&lt;=n; i++){
<span class="udiff-line-modified-removed">-         sqlite3_str_appendf(&amp;x, &quot;,%d&quot;, ai[i]);</span>
<span class="udiff-line-modified-added">+         sqlite3_str_appendf(&amp;x, &quot;%c%d&quot;, (i==1 ? &#39;[&#39; : &#39;,&#39;), ai[i]);</span>
        }
<span class="udiff-line-removed">-       zTemp[0] = &#39;[&#39;;</span>
        sqlite3_str_append(&amp;x, &quot;]&quot;, 1);
        break;
      }
      case P4_SUBPROGRAM: {
<span class="udiff-line-modified-removed">-       sqlite3_str_appendf(&amp;x, &quot;program&quot;);</span>
<span class="udiff-line-modified-added">+       zP4 = &quot;program&quot;;</span>
        break;
      }
      case P4_DYNBLOB:
      case P4_ADVANCE: {
<span class="udiff-line-removed">-       zTemp[0] = 0;</span>
        break;
      }
      case P4_TABLE: {
<span class="udiff-line-modified-removed">-       sqlite3_str_appendf(&amp;x, &quot;%s&quot;, pOp-&gt;p4.pTab-&gt;zName);</span>
<span class="udiff-line-modified-added">+       zP4 = pOp-&gt;p4.pTab-&gt;zName;</span>
        break;
      }
      default: {
        zP4 = pOp-&gt;p4.z;
<span class="udiff-line-removed">-       if( zP4==0 ){</span>
<span class="udiff-line-removed">-         zP4 = zTemp;</span>
<span class="udiff-line-removed">-         zTemp[0] = 0;</span>
<span class="udiff-line-removed">-       }</span>
      }
    }
<span class="udiff-line-modified-removed">-   sqlite3StrAccumFinish(&amp;x);</span>
<span class="udiff-line-modified-removed">-   assert( zP4!=0 );</span>
<span class="udiff-line-modified-removed">-   return zP4;</span>
<span class="udiff-line-modified-added">+   if( zP4 ) sqlite3_str_appendall(&amp;x, zP4);</span>
<span class="udiff-line-modified-added">+   if( (x.accError &amp; SQLITE_NOMEM)!=0 ){</span>
<span class="udiff-line-modified-added">+     sqlite3OomFault(db);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return sqlite3StrAccumFinish(&amp;x);</span>
  }
  #endif /* VDBE_DISPLAY_P4 */
  
  /*
  ** Declare to the Vdbe that the BTree object at db-&gt;aDb[i] is used.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -79124,28 +79379,34 @@</span>
  /*
  ** Print a single opcode.  This routine is used for debugging only.
  */
  SQLITE_PRIVATE void sqlite3VdbePrintOp(FILE *pOut, int pc, VdbeOp *pOp){
    char *zP4;
<span class="udiff-line-modified-removed">-   char zPtr[50];</span>
<span class="udiff-line-modified-removed">-   char zCom[100];</span>
<span class="udiff-line-modified-added">+   char *zCom;</span>
<span class="udiff-line-modified-added">+   sqlite3 dummyDb;</span>
    static const char *zFormat1 = &quot;%4d %-13s %4d %4d %4d %-13s %.2X %s\n&quot;;
    if( pOut==0 ) pOut = stdout;
<span class="udiff-line-modified-removed">-   zP4 = displayP4(pOp, zPtr, sizeof(zPtr));</span>
<span class="udiff-line-modified-added">+   sqlite3BeginBenignMalloc();</span>
<span class="udiff-line-added">+   dummyDb.mallocFailed = 1;</span>
<span class="udiff-line-added">+   zP4 = sqlite3VdbeDisplayP4(&amp;dummyDb, pOp);</span>
  #ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
<span class="udiff-line-modified-removed">-   displayComment(pOp, zP4, zCom, sizeof(zCom));</span>
<span class="udiff-line-modified-added">+   zCom = sqlite3VdbeDisplayComment(0, pOp, zP4);</span>
  #else
<span class="udiff-line-modified-removed">-   zCom[0] = 0;</span>
<span class="udiff-line-modified-added">+   zCom = 0;</span>
  #endif
    /* NB:  The sqlite3OpcodeName() function is implemented by code created
    ** by the mkopcodeh.awk and mkopcodec.awk scripts which extract the
    ** information from the vdbe.c source text */
    fprintf(pOut, zFormat1, pc,
<span class="udiff-line-modified-removed">-       sqlite3OpcodeName(pOp-&gt;opcode), pOp-&gt;p1, pOp-&gt;p2, pOp-&gt;p3, zP4, pOp-&gt;p5,</span>
<span class="udiff-line-modified-removed">-       zCom</span>
<span class="udiff-line-modified-added">+       sqlite3OpcodeName(pOp-&gt;opcode), pOp-&gt;p1, pOp-&gt;p2, pOp-&gt;p3,</span>
<span class="udiff-line-modified-added">+       zP4 ? zP4 : &quot;&quot;, pOp-&gt;p5,</span>
<span class="udiff-line-added">+       zCom ? zCom : &quot;&quot;</span>
    );
    fflush(pOut);
<span class="udiff-line-added">+   sqlite3_free(zP4);</span>
<span class="udiff-line-added">+   sqlite3_free(zCom);</span>
<span class="udiff-line-added">+   sqlite3EndBenignMalloc();</span>
  }
  #endif
  
  /*
  ** Initialize an array of N Mem element.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -79232,116 +79493,65 @@</span>
    assert( sqlite3VdbeFrameIsValid(pFrame) );
    pFrame-&gt;pParent = pFrame-&gt;v-&gt;pDelFrame;
    pFrame-&gt;v-&gt;pDelFrame = pFrame;
  }
  
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">- /*</span>
<span class="udiff-line-removed">- ** Delete a VdbeFrame object and its contents. VdbeFrame objects are</span>
<span class="udiff-line-removed">- ** allocated by the OP_Program opcode in sqlite3VdbeExec().</span>
<span class="udiff-line-removed">- */</span>
<span class="udiff-line-removed">- SQLITE_PRIVATE void sqlite3VdbeFrameDelete(VdbeFrame *p){</span>
<span class="udiff-line-removed">-   int i;</span>
<span class="udiff-line-removed">-   Mem *aMem = VdbeFrameMem(p);</span>
<span class="udiff-line-removed">-   VdbeCursor **apCsr = (VdbeCursor **)&amp;aMem[p-&gt;nChildMem];</span>
<span class="udiff-line-removed">-   assert( sqlite3VdbeFrameIsValid(p) );</span>
<span class="udiff-line-removed">-   for(i=0; i&lt;p-&gt;nChildCsr; i++){</span>
<span class="udiff-line-removed">-     sqlite3VdbeFreeCursor(p-&gt;v, apCsr[i]);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   releaseMemArray(aMem, p-&gt;nChildMem);</span>
<span class="udiff-line-removed">-   sqlite3VdbeDeleteAuxData(p-&gt;v-&gt;db, &amp;p-&gt;pAuxData, -1, 0);</span>
<span class="udiff-line-removed">-   sqlite3DbFree(p-&gt;v-&gt;db, p);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifndef SQLITE_OMIT_EXPLAIN</span>
<span class="udiff-line-modified-added">+ #if defined(SQLITE_ENABLE_BYTECODE_VTAB) || !defined(SQLITE_OMIT_EXPLAIN)</span>
  /*
<span class="udiff-line-modified-removed">- ** Give a listing of the program in the virtual machine.</span>
<span class="udiff-line-modified-removed">- **</span>
<span class="udiff-line-removed">- ** The interface is the same as sqlite3VdbeExec().  But instead of</span>
<span class="udiff-line-removed">- ** running the code, it invokes the callback once for each instruction.</span>
<span class="udiff-line-removed">- ** This feature is used to implement &quot;EXPLAIN&quot;.</span>
<span class="udiff-line-removed">- **</span>
<span class="udiff-line-removed">- ** When p-&gt;explain==1, each instruction is listed.  When</span>
<span class="udiff-line-removed">- ** p-&gt;explain==2, only OP_Explain instructions are listed and these</span>
<span class="udiff-line-removed">- ** are shown in a different format.  p-&gt;explain==2 is used to implement</span>
<span class="udiff-line-removed">- ** EXPLAIN QUERY PLAN.</span>
<span class="udiff-line-removed">- ** 2018-04-24:  In p-&gt;explain==2 mode, the OP_Init opcodes of triggers</span>
<span class="udiff-line-removed">- ** are also shown, so that the boundaries between the main program and</span>
<span class="udiff-line-removed">- ** each trigger are clear.</span>
<span class="udiff-line-modified-added">+ ** Locate the next opcode to be displayed in EXPLAIN or EXPLAIN</span>
<span class="udiff-line-modified-added">+ ** QUERY PLAN output.</span>
  **
<span class="udiff-line-modified-removed">- ** When p-&gt;explain==1, first the main program is listed, then each of</span>
<span class="udiff-line-modified-removed">- ** the trigger subprograms are listed one by one.</span>
<span class="udiff-line-modified-added">+ ** Return SQLITE_ROW on success.  Return SQLITE_DONE if there are no</span>
<span class="udiff-line-modified-added">+ ** more opcodes to be displayed.</span>
  */
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE int sqlite3VdbeList(</span>
<span class="udiff-line-modified-removed">-   Vdbe *p                   /* The VDBE */</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE int sqlite3VdbeNextOpcode(</span>
<span class="udiff-line-modified-added">+   Vdbe *p,         /* The statement being explained */</span>
<span class="udiff-line-added">+   Mem *pSub,       /* Storage for keeping track of subprogram nesting */</span>
<span class="udiff-line-added">+   int eMode,       /* 0: normal.  1: EQP.  2:  TablesUsed */</span>
<span class="udiff-line-added">+   int *piPc,       /* IN/OUT: Current rowid.  Overwritten with next rowid */</span>
<span class="udiff-line-added">+   int *piAddr,     /* OUT: Write index into (*paOp)[] here */</span>
<span class="udiff-line-added">+   Op **paOp        /* OUT: Write the opcode array here */</span>
  ){
    int nRow;                            /* Stop when row count reaches this */
    int nSub = 0;                        /* Number of sub-vdbes seen so far */
    SubProgram **apSub = 0;              /* Array of sub-vdbes */
<span class="udiff-line-modified-removed">-   Mem *pSub = 0;                       /* Memory cell hold array of subprogs */</span>
<span class="udiff-line-modified-removed">-   sqlite3 *db = p-&gt;db;                 /* The database connection */</span>
<span class="udiff-line-modified-removed">-   int i;                               /* Loop counter */</span>
<span class="udiff-line-modified-removed">-   int rc = SQLITE_OK;                  /* Return code */</span>
<span class="udiff-line-removed">-   Mem *pMem = &amp;p-&gt;aMem[1];             /* First Mem of result set */</span>
<span class="udiff-line-removed">-   int bListSubprogs = (p-&gt;explain==1 || (db-&gt;flags &amp; SQLITE_TriggerEQP)!=0);</span>
<span class="udiff-line-removed">-   Op *pOp = 0;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   assert( p-&gt;explain );</span>
<span class="udiff-line-removed">-   assert( p-&gt;magic==VDBE_MAGIC_RUN );</span>
<span class="udiff-line-removed">-   assert( p-&gt;rc==SQLITE_OK || p-&gt;rc==SQLITE_BUSY || p-&gt;rc==SQLITE_NOMEM );</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   /* Even though this opcode does not use dynamic strings for</span>
<span class="udiff-line-removed">-   ** the result, result columns may become dynamic if the user calls</span>
<span class="udiff-line-removed">-   ** sqlite3_column_text16(), causing a translation to UTF-16 encoding.</span>
<span class="udiff-line-removed">-   */</span>
<span class="udiff-line-removed">-   releaseMemArray(pMem, 8);</span>
<span class="udiff-line-removed">-   p-&gt;pResultSet = 0;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if( p-&gt;rc==SQLITE_NOMEM ){</span>
<span class="udiff-line-removed">-     /* This happens if a malloc() inside a call to sqlite3_column_text() or</span>
<span class="udiff-line-removed">-     ** sqlite3_column_text16() failed.  */</span>
<span class="udiff-line-removed">-     sqlite3OomFault(db);</span>
<span class="udiff-line-removed">-     return SQLITE_ERROR;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   int i;                               /* Next instruction address */</span>
<span class="udiff-line-modified-added">+   int rc = SQLITE_OK;                  /* Result code */</span>
<span class="udiff-line-modified-added">+   Op *aOp = 0;                         /* Opcode array */</span>
<span class="udiff-line-modified-added">+   int iPc;                             /* Rowid.  Copy of value in *piPc */</span>
  
    /* When the number of output rows reaches nRow, that means the
    ** listing has finished and sqlite3_step() should return SQLITE_DONE.
    ** nRow is the sum of the number of rows in the main program, plus
    ** the sum of the number of rows in all trigger subprograms encountered
    ** so far.  The nRow value will increase as new trigger subprograms are
    ** encountered, but p-&gt;pc will eventually catch up to nRow.
    */
    nRow = p-&gt;nOp;
<span class="udiff-line-modified-removed">-   if( bListSubprogs ){</span>
<span class="udiff-line-removed">-     /* The first 8 memory cells are used for the result set.  So we will</span>
<span class="udiff-line-removed">-     ** commandeer the 9th cell to use as storage for an array of pointers</span>
<span class="udiff-line-removed">-     ** to trigger subprograms.  The VDBE is guaranteed to have at least 9</span>
<span class="udiff-line-removed">-     ** cells.  */</span>
<span class="udiff-line-removed">-     assert( p-&gt;nMem&gt;9 );</span>
<span class="udiff-line-removed">-     pSub = &amp;p-&gt;aMem[9];</span>
<span class="udiff-line-modified-added">+   if( pSub!=0 ){</span>
      if( pSub-&gt;flags&amp;MEM_Blob ){
<span class="udiff-line-modified-removed">-       /* On the first call to sqlite3_step(), pSub will hold a NULL.  It is</span>
<span class="udiff-line-modified-removed">-       ** initialized to a BLOB by the P4_SUBPROGRAM processing logic below */</span>
<span class="udiff-line-modified-added">+       /* pSub is initiallly NULL.  It is initialized to a BLOB by</span>
<span class="udiff-line-modified-added">+       ** the P4_SUBPROGRAM processing logic below */</span>
        nSub = pSub-&gt;n/sizeof(Vdbe*);
        apSub = (SubProgram **)pSub-&gt;z;
      }
      for(i=0; i&lt;nSub; i++){
        nRow += apSub[i]-&gt;nOp;
      }
    }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+   iPc = *piPc;</span>
    while(1){  /* Loop exits via break */
<span class="udiff-line-modified-removed">-     i = p-&gt;pc++;</span>
<span class="udiff-line-modified-added">+     i = iPc++;</span>
      if( i&gt;=nRow ){
        p-&gt;rc = SQLITE_OK;
        rc = SQLITE_DONE;
        break;
      }
      if( i&lt;p-&gt;nOp ){
<span class="udiff-line-modified-removed">-       /* The output line number is small enough that we are still in the</span>
<span class="udiff-line-modified-added">+       /* The rowid is small enough that we are still in the</span>
        ** main program. */
<span class="udiff-line-modified-removed">-       pOp = &amp;p-&gt;aOp[i];</span>
<span class="udiff-line-modified-added">+       aOp = p-&gt;aOp;</span>
      }else{
        /* We are currently listing subprograms.  Figure out which one and
        ** pick up the appropriate opcode. */
        int j;
        i -= p-&gt;nOp;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -79349,118 +79559,182 @@</span>
        assert( nSub&gt;0 );
        for(j=0; i&gt;=apSub[j]-&gt;nOp; j++){
          i -= apSub[j]-&gt;nOp;
          assert( i&lt;apSub[j]-&gt;nOp || j+1&lt;nSub );
        }
<span class="udiff-line-modified-removed">-       pOp = &amp;apSub[j]-&gt;aOp[i];</span>
<span class="udiff-line-modified-added">+       aOp = apSub[j]-&gt;aOp;</span>
      }
  
      /* When an OP_Program opcode is encounter (the only opcode that has
      ** a P4_SUBPROGRAM argument), expand the size of the array of subprograms
      ** kept in p-&gt;aMem[9].z to hold the new program - assuming this subprogram
      ** has not already been seen.
      */
<span class="udiff-line-modified-removed">-     if( bListSubprogs &amp;&amp; pOp-&gt;p4type==P4_SUBPROGRAM ){</span>
<span class="udiff-line-modified-added">+     if( pSub!=0 &amp;&amp; aOp[i].p4type==P4_SUBPROGRAM ){</span>
        int nByte = (nSub+1)*sizeof(SubProgram*);
        int j;
        for(j=0; j&lt;nSub; j++){
<span class="udiff-line-modified-removed">-         if( apSub[j]==pOp-&gt;p4.pProgram ) break;</span>
<span class="udiff-line-modified-added">+         if( apSub[j]==aOp[i].p4.pProgram ) break;</span>
        }
        if( j==nSub ){
          p-&gt;rc = sqlite3VdbeMemGrow(pSub, nByte, nSub!=0);
          if( p-&gt;rc!=SQLITE_OK ){
            rc = SQLITE_ERROR;
            break;
          }
          apSub = (SubProgram **)pSub-&gt;z;
<span class="udiff-line-modified-removed">-         apSub[nSub++] = pOp-&gt;p4.pProgram;</span>
<span class="udiff-line-modified-removed">-         pSub-&gt;flags |= MEM_Blob;</span>
<span class="udiff-line-modified-added">+         apSub[nSub++] = aOp[i].p4.pProgram;</span>
<span class="udiff-line-modified-added">+         MemSetTypeFlag(pSub, MEM_Blob);</span>
          pSub-&gt;n = nSub*sizeof(SubProgram*);
<span class="udiff-line-modified-removed">-         nRow += pOp-&gt;p4.pProgram-&gt;nOp;</span>
<span class="udiff-line-modified-added">+         nRow += aOp[i].p4.pProgram-&gt;nOp;</span>
        }
      }
<span class="udiff-line-modified-removed">-     if( p-&gt;explain&lt;2 ) break;</span>
<span class="udiff-line-modified-removed">-     if( pOp-&gt;opcode==OP_Explain ) break;</span>
<span class="udiff-line-modified-removed">-     if( pOp-&gt;opcode==OP_Init &amp;&amp; p-&gt;pc&gt;1 ) break;</span>
<span class="udiff-line-modified-added">+     if( eMode==0 ) break;</span>
<span class="udiff-line-modified-added">+ #ifdef SQLITE_ENABLE_BYTECODE_VTAB</span>
<span class="udiff-line-modified-added">+     if( eMode==2 ){</span>
<span class="udiff-line-added">+       Op *pOp = aOp + i;</span>
<span class="udiff-line-added">+       if( pOp-&gt;opcode==OP_OpenRead ) break;</span>
<span class="udiff-line-added">+       if( pOp-&gt;opcode==OP_OpenWrite &amp;&amp; (pOp-&gt;p5 &amp; OPFLAG_P2ISREG)==0 ) break;</span>
<span class="udiff-line-added">+       if( pOp-&gt;opcode==OP_ReopenIdx ) break;</span>
<span class="udiff-line-added">+     }else</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       assert( eMode==1 );</span>
<span class="udiff-line-added">+       if( aOp[i].opcode==OP_Explain ) break;</span>
<span class="udiff-line-added">+       if( aOp[i].opcode==OP_Init &amp;&amp; iPc&gt;1 ) break;</span>
<span class="udiff-line-added">+     }</span>
    }
<span class="udiff-line-added">+   *piPc = iPc;</span>
<span class="udiff-line-added">+   *piAddr = i;</span>
<span class="udiff-line-added">+   *paOp = aOp;</span>
<span class="udiff-line-added">+   return rc;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #endif /* SQLITE_ENABLE_BYTECODE_VTAB || !SQLITE_OMIT_EXPLAIN */</span>
  
<span class="udiff-line-removed">-   if( rc==SQLITE_OK ){</span>
<span class="udiff-line-removed">-     if( db-&gt;u1.isInterrupted ){</span>
<span class="udiff-line-removed">-       p-&gt;rc = SQLITE_INTERRUPT;</span>
<span class="udiff-line-removed">-       rc = SQLITE_ERROR;</span>
<span class="udiff-line-removed">-       sqlite3VdbeError(p, sqlite3ErrStr(p-&gt;rc));</span>
<span class="udiff-line-removed">-     }else{</span>
<span class="udiff-line-removed">-       char *zP4;</span>
<span class="udiff-line-removed">-       if( p-&gt;explain==1 ){</span>
<span class="udiff-line-removed">-         pMem-&gt;flags = MEM_Int;</span>
<span class="udiff-line-removed">-         pMem-&gt;u.i = i;                                /* Program counter */</span>
<span class="udiff-line-removed">-         pMem++;</span>
  
<span class="udiff-line-modified-removed">-         pMem-&gt;flags = MEM_Static|MEM_Str|MEM_Term;</span>
<span class="udiff-line-modified-removed">-         pMem-&gt;z = (char*)sqlite3OpcodeName(pOp-&gt;opcode); /* Opcode */</span>
<span class="udiff-line-modified-removed">-         assert( pMem-&gt;z!=0 );</span>
<span class="udiff-line-modified-removed">-         pMem-&gt;n = sqlite3Strlen30(pMem-&gt;z);</span>
<span class="udiff-line-modified-removed">-         pMem-&gt;enc = SQLITE_UTF8;</span>
<span class="udiff-line-modified-removed">-         pMem++;</span>
<span class="udiff-line-modified-removed">-       }</span>
<span class="udiff-line-modified-added">+ /*</span>
<span class="udiff-line-modified-added">+ ** Delete a VdbeFrame object and its contents. VdbeFrame objects are</span>
<span class="udiff-line-modified-added">+ ** allocated by the OP_Program opcode in sqlite3VdbeExec().</span>
<span class="udiff-line-modified-added">+ */</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE void sqlite3VdbeFrameDelete(VdbeFrame *p){</span>
<span class="udiff-line-modified-added">+   int i;</span>
<span class="udiff-line-modified-added">+   Mem *aMem = VdbeFrameMem(p);</span>
<span class="udiff-line-added">+   VdbeCursor **apCsr = (VdbeCursor **)&amp;aMem[p-&gt;nChildMem];</span>
<span class="udiff-line-added">+   assert( sqlite3VdbeFrameIsValid(p) );</span>
<span class="udiff-line-added">+   for(i=0; i&lt;p-&gt;nChildCsr; i++){</span>
<span class="udiff-line-added">+     sqlite3VdbeFreeCursor(p-&gt;v, apCsr[i]);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   releaseMemArray(aMem, p-&gt;nChildMem);</span>
<span class="udiff-line-added">+   sqlite3VdbeDeleteAuxData(p-&gt;v-&gt;db, &amp;p-&gt;pAuxData, -1, 0);</span>
<span class="udiff-line-added">+   sqlite3DbFree(p-&gt;v-&gt;db, p);</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-       pMem-&gt;flags = MEM_Int;</span>
<span class="udiff-line-modified-removed">-       pMem-&gt;u.i = pOp-&gt;p1;                          /* P1 */</span>
<span class="udiff-line-modified-removed">-       pMem++;</span>
<span class="udiff-line-modified-added">+ #ifndef SQLITE_OMIT_EXPLAIN</span>
<span class="udiff-line-modified-added">+ /*</span>
<span class="udiff-line-modified-added">+ ** Give a listing of the program in the virtual machine.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** The interface is the same as sqlite3VdbeExec().  But instead of</span>
<span class="udiff-line-added">+ ** running the code, it invokes the callback once for each instruction.</span>
<span class="udiff-line-added">+ ** This feature is used to implement &quot;EXPLAIN&quot;.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** When p-&gt;explain==1, each instruction is listed.  When</span>
<span class="udiff-line-added">+ ** p-&gt;explain==2, only OP_Explain instructions are listed and these</span>
<span class="udiff-line-added">+ ** are shown in a different format.  p-&gt;explain==2 is used to implement</span>
<span class="udiff-line-added">+ ** EXPLAIN QUERY PLAN.</span>
<span class="udiff-line-added">+ ** 2018-04-24:  In p-&gt;explain==2 mode, the OP_Init opcodes of triggers</span>
<span class="udiff-line-added">+ ** are also shown, so that the boundaries between the main program and</span>
<span class="udiff-line-added">+ ** each trigger are clear.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** When p-&gt;explain==1, first the main program is listed, then each of</span>
<span class="udiff-line-added">+ ** the trigger subprograms are listed one by one.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE int sqlite3VdbeList(</span>
<span class="udiff-line-added">+   Vdbe *p                   /* The VDBE */</span>
<span class="udiff-line-added">+ ){</span>
<span class="udiff-line-added">+   Mem *pSub = 0;                       /* Memory cell hold array of subprogs */</span>
<span class="udiff-line-added">+   sqlite3 *db = p-&gt;db;                 /* The database connection */</span>
<span class="udiff-line-added">+   int i;                               /* Loop counter */</span>
<span class="udiff-line-added">+   int rc = SQLITE_OK;                  /* Return code */</span>
<span class="udiff-line-added">+   Mem *pMem = &amp;p-&gt;aMem[1];             /* First Mem of result set */</span>
<span class="udiff-line-added">+   int bListSubprogs = (p-&gt;explain==1 || (db-&gt;flags &amp; SQLITE_TriggerEQP)!=0);</span>
<span class="udiff-line-added">+   Op *aOp;                             /* Array of opcodes */</span>
<span class="udiff-line-added">+   Op *pOp;                             /* Current opcode */</span>
  
<span class="udiff-line-modified-removed">-       pMem-&gt;flags = MEM_Int;</span>
<span class="udiff-line-modified-removed">-       pMem-&gt;u.i = pOp-&gt;p2;                          /* P2 */</span>
<span class="udiff-line-modified-removed">-       pMem++;</span>
<span class="udiff-line-modified-added">+   assert( p-&gt;explain );</span>
<span class="udiff-line-modified-added">+   assert( p-&gt;magic==VDBE_MAGIC_RUN );</span>
<span class="udiff-line-modified-added">+   assert( p-&gt;rc==SQLITE_OK || p-&gt;rc==SQLITE_BUSY || p-&gt;rc==SQLITE_NOMEM );</span>
  
<span class="udiff-line-modified-removed">-       pMem-&gt;flags = MEM_Int;</span>
<span class="udiff-line-modified-removed">-       pMem-&gt;u.i = pOp-&gt;p3;                          /* P3 */</span>
<span class="udiff-line-modified-removed">-       pMem++;</span>
<span class="udiff-line-modified-added">+   /* Even though this opcode does not use dynamic strings for</span>
<span class="udiff-line-modified-added">+   ** the result, result columns may become dynamic if the user calls</span>
<span class="udiff-line-modified-added">+   ** sqlite3_column_text16(), causing a translation to UTF-16 encoding.</span>
<span class="udiff-line-added">+   */</span>
<span class="udiff-line-added">+   releaseMemArray(pMem, 8);</span>
<span class="udiff-line-added">+   p-&gt;pResultSet = 0;</span>
  
<span class="udiff-line-modified-removed">-       if( sqlite3VdbeMemClearAndResize(pMem, 100) ){ /* P4 */</span>
<span class="udiff-line-modified-removed">-         assert( p-&gt;db-&gt;mallocFailed );</span>
<span class="udiff-line-modified-removed">-         return SQLITE_ERROR;</span>
<span class="udiff-line-modified-removed">-       }</span>
<span class="udiff-line-modified-removed">-       pMem-&gt;flags = MEM_Str|MEM_Term;</span>
<span class="udiff-line-modified-removed">-       zP4 = displayP4(pOp, pMem-&gt;z, pMem-&gt;szMalloc);</span>
<span class="udiff-line-removed">-       if( zP4!=pMem-&gt;z ){</span>
<span class="udiff-line-removed">-         pMem-&gt;n = 0;</span>
<span class="udiff-line-removed">-         sqlite3VdbeMemSetStr(pMem, zP4, -1, SQLITE_UTF8, 0);</span>
<span class="udiff-line-removed">-       }else{</span>
<span class="udiff-line-removed">-         assert( pMem-&gt;z!=0 );</span>
<span class="udiff-line-removed">-         pMem-&gt;n = sqlite3Strlen30(pMem-&gt;z);</span>
<span class="udiff-line-removed">-         pMem-&gt;enc = SQLITE_UTF8;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       pMem++;</span>
<span class="udiff-line-modified-added">+   if( p-&gt;rc==SQLITE_NOMEM ){</span>
<span class="udiff-line-modified-added">+     /* This happens if a malloc() inside a call to sqlite3_column_text() or</span>
<span class="udiff-line-modified-added">+     ** sqlite3_column_text16() failed.  */</span>
<span class="udiff-line-modified-added">+     sqlite3OomFault(db);</span>
<span class="udiff-line-modified-added">+     return SQLITE_ERROR;</span>
<span class="udiff-line-modified-added">+   }</span>
  
<span class="udiff-line-modified-removed">-       if( p-&gt;explain==1 ){</span>
<span class="udiff-line-modified-removed">-         if( sqlite3VdbeMemClearAndResize(pMem, 4) ){</span>
<span class="udiff-line-modified-removed">-           assert( p-&gt;db-&gt;mallocFailed );</span>
<span class="udiff-line-modified-removed">-           return SQLITE_ERROR;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         pMem-&gt;flags = MEM_Str|MEM_Term;</span>
<span class="udiff-line-modified-removed">-         pMem-&gt;n = 2;</span>
<span class="udiff-line-modified-removed">-         sqlite3_snprintf(3, pMem-&gt;z, &quot;%.2x&quot;, pOp-&gt;p5);   /* P5 */</span>
<span class="udiff-line-modified-removed">-         pMem-&gt;enc = SQLITE_UTF8;</span>
<span class="udiff-line-modified-removed">-         pMem++;</span>
<span class="udiff-line-modified-added">+   if( bListSubprogs ){</span>
<span class="udiff-line-modified-added">+     /* The first 8 memory cells are used for the result set.  So we will</span>
<span class="udiff-line-modified-added">+     ** commandeer the 9th cell to use as storage for an array of pointers</span>
<span class="udiff-line-modified-added">+     ** to trigger subprograms.  The VDBE is guaranteed to have at least 9</span>
<span class="udiff-line-modified-added">+     ** cells.  */</span>
<span class="udiff-line-modified-added">+     assert( p-&gt;nMem&gt;9 );</span>
<span class="udiff-line-modified-added">+     pSub = &amp;p-&gt;aMem[9];</span>
<span class="udiff-line-modified-added">+   }else{</span>
<span class="udiff-line-modified-added">+     pSub = 0;</span>
<span class="udiff-line-modified-added">+   }</span>
  
<span class="udiff-line-added">+   /* Figure out which opcode is next to display */</span>
<span class="udiff-line-added">+   rc = sqlite3VdbeNextOpcode(p, pSub, p-&gt;explain==2, &amp;p-&gt;pc, &amp;i, &amp;aOp);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if( rc==SQLITE_OK ){</span>
<span class="udiff-line-added">+     pOp = aOp + i;</span>
<span class="udiff-line-added">+     if( AtomicLoad(&amp;db-&gt;u1.isInterrupted) ){</span>
<span class="udiff-line-added">+       p-&gt;rc = SQLITE_INTERRUPT;</span>
<span class="udiff-line-added">+       rc = SQLITE_ERROR;</span>
<span class="udiff-line-added">+       sqlite3VdbeError(p, sqlite3ErrStr(p-&gt;rc));</span>
<span class="udiff-line-added">+     }else{</span>
<span class="udiff-line-added">+       char *zP4 = sqlite3VdbeDisplayP4(db, pOp);</span>
<span class="udiff-line-added">+       if( p-&gt;explain==2 ){</span>
<span class="udiff-line-added">+         sqlite3VdbeMemSetInt64(pMem, pOp-&gt;p1);</span>
<span class="udiff-line-added">+         sqlite3VdbeMemSetInt64(pMem+1, pOp-&gt;p2);</span>
<span class="udiff-line-added">+         sqlite3VdbeMemSetInt64(pMem+2, pOp-&gt;p3);</span>
<span class="udiff-line-added">+         sqlite3VdbeMemSetStr(pMem+3, zP4, -1, SQLITE_UTF8, sqlite3_free);</span>
<span class="udiff-line-added">+         p-&gt;nResColumn = 4;</span>
<span class="udiff-line-added">+       }else{</span>
<span class="udiff-line-added">+         sqlite3VdbeMemSetInt64(pMem+0, i);</span>
<span class="udiff-line-added">+         sqlite3VdbeMemSetStr(pMem+1, (char*)sqlite3OpcodeName(pOp-&gt;opcode),</span>
<span class="udiff-line-added">+                              -1, SQLITE_UTF8, SQLITE_STATIC);</span>
<span class="udiff-line-added">+         sqlite3VdbeMemSetInt64(pMem+2, pOp-&gt;p1);</span>
<span class="udiff-line-added">+         sqlite3VdbeMemSetInt64(pMem+3, pOp-&gt;p2);</span>
<span class="udiff-line-added">+         sqlite3VdbeMemSetInt64(pMem+4, pOp-&gt;p3);</span>
<span class="udiff-line-added">+         /* pMem+5 for p4 is done last */</span>
<span class="udiff-line-added">+         sqlite3VdbeMemSetInt64(pMem+6, pOp-&gt;p5);</span>
  #ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
<span class="udiff-line-modified-removed">-         if( sqlite3VdbeMemClearAndResize(pMem, 500) ){</span>
<span class="udiff-line-modified-removed">-           assert( p-&gt;db-&gt;mallocFailed );</span>
<span class="udiff-line-modified-removed">-           return SQLITE_ERROR;</span>
<span class="udiff-line-modified-added">+         {</span>
<span class="udiff-line-modified-added">+           char *zCom = sqlite3VdbeDisplayComment(db, pOp, zP4);</span>
<span class="udiff-line-modified-added">+           sqlite3VdbeMemSetStr(pMem+7, zCom, -1, SQLITE_UTF8, sqlite3_free);</span>
          }
<span class="udiff-line-removed">-         pMem-&gt;flags = MEM_Str|MEM_Term;</span>
<span class="udiff-line-removed">-         pMem-&gt;n = displayComment(pOp, zP4, pMem-&gt;z, 500);</span>
<span class="udiff-line-removed">-         pMem-&gt;enc = SQLITE_UTF8;</span>
  #else
<span class="udiff-line-modified-removed">-         pMem-&gt;flags = MEM_Null;                       /* Comment */</span>
<span class="udiff-line-modified-added">+         sqlite3VdbeMemSetNull(pMem+7);</span>
  #endif
<span class="udiff-line-added">+         sqlite3VdbeMemSetStr(pMem+5, zP4, -1, SQLITE_UTF8, sqlite3_free);</span>
<span class="udiff-line-added">+         p-&gt;nResColumn = 8;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       p-&gt;pResultSet = pMem;</span>
<span class="udiff-line-added">+       if( db-&gt;mallocFailed ){</span>
<span class="udiff-line-added">+         p-&gt;rc = SQLITE_NOMEM;</span>
<span class="udiff-line-added">+         rc = SQLITE_ERROR;</span>
<span class="udiff-line-added">+       }else{</span>
<span class="udiff-line-added">+         p-&gt;rc = SQLITE_OK;</span>
<span class="udiff-line-added">+         rc = SQLITE_ROW;</span>
        }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       p-&gt;nResColumn = 8 - 4*(p-&gt;explain-1);</span>
<span class="udiff-line-removed">-       p-&gt;pResultSet = &amp;p-&gt;aMem[1];</span>
<span class="udiff-line-removed">-       p-&gt;rc = SQLITE_OK;</span>
<span class="udiff-line-removed">-       rc = SQLITE_ROW;</span>
      }
    }
    return rc;
  }
  #endif /* SQLITE_OMIT_EXPLAIN */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -79664,10 +79938,11 @@</span>
         &quot;addr&quot;, &quot;opcode&quot;, &quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;, &quot;p4&quot;, &quot;p5&quot;, &quot;comment&quot;,
         &quot;id&quot;, &quot;parent&quot;, &quot;notused&quot;, &quot;detail&quot;
      };
      int iFirst, mx, i;
      if( nMem&lt;10 ) nMem = 10;
<span class="udiff-line-added">+     p-&gt;explain = pParse-&gt;explain;</span>
      if( pParse-&gt;explain==2 ){
        sqlite3VdbeSetNumCols(p, 4);
        iFirst = 8;
        mx = 12;
      }else{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -79714,11 +79989,10 @@</span>
      }
    }
  
    p-&gt;pVList = pParse-&gt;pVList;
    pParse-&gt;pVList =  0;
<span class="udiff-line-removed">-   p-&gt;explain = pParse-&gt;explain;</span>
    if( db-&gt;mallocFailed ){
      p-&gt;nVar = 0;
      p-&gt;nCursor = 0;
      p-&gt;nMem = 0;
    }else{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -80026,12 +80300,13 @@</span>
      int retryCount = 0;
      int nMainFile;
  
      /* Select a master journal file name */
      nMainFile = sqlite3Strlen30(zMainFile);
<span class="udiff-line-modified-removed">-     zMaster = sqlite3MPrintf(db, &quot;%s-mjXXXXXX9XXz%c%c&quot;, zMainFile, 0, 0);</span>
<span class="udiff-line-modified-added">+     zMaster = sqlite3MPrintf(db, &quot;%.4c%s%.16c&quot;, 0,zMainFile,0);</span>
      if( zMaster==0 ) return SQLITE_NOMEM_BKPT;
<span class="udiff-line-added">+     zMaster += 4;</span>
      do {
        u32 iRandom;
        if( retryCount ){
          if( retryCount&gt;100 ){
            sqlite3_log(SQLITE_FULL, &quot;MJ delete: %s&quot;, zMaster);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -80057,11 +80332,11 @@</span>
            SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|
            SQLITE_OPEN_EXCLUSIVE|SQLITE_OPEN_MASTER_JOURNAL, 0
        );
      }
      if( rc!=SQLITE_OK ){
<span class="udiff-line-modified-removed">-       sqlite3DbFree(db, zMaster);</span>
<span class="udiff-line-modified-added">+       sqlite3DbFree(db, zMaster-4);</span>
        return rc;
      }
  
      /* Write the name of each database file in the transaction into the new
      ** master journal file. If an error occurs at this point close
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -80080,11 +80355,11 @@</span>
          rc = sqlite3OsWrite(pMaster, zFile, sqlite3Strlen30(zFile)+1, offset);
          offset += sqlite3Strlen30(zFile)+1;
          if( rc!=SQLITE_OK ){
            sqlite3OsCloseFree(pMaster);
            sqlite3OsDelete(pVfs, zMaster, 0);
<span class="udiff-line-modified-removed">-           sqlite3DbFree(db, zMaster);</span>
<span class="udiff-line-modified-added">+           sqlite3DbFree(db, zMaster-4);</span>
            return rc;
          }
        }
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -80094,11 +80369,11 @@</span>
      if( 0==(sqlite3OsDeviceCharacteristics(pMaster)&amp;SQLITE_IOCAP_SEQUENTIAL)
       &amp;&amp; SQLITE_OK!=(rc = sqlite3OsSync(pMaster, SQLITE_SYNC_NORMAL))
      ){
        sqlite3OsCloseFree(pMaster);
        sqlite3OsDelete(pVfs, zMaster, 0);
<span class="udiff-line-modified-removed">-       sqlite3DbFree(db, zMaster);</span>
<span class="udiff-line-modified-added">+       sqlite3DbFree(db, zMaster-4);</span>
        return rc;
      }
  
      /* Sync all the db files involved in the transaction. The same call
      ** sets the master journal pointer in each individual journal. If
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -80117,20 +80392,20 @@</span>
        }
      }
      sqlite3OsCloseFree(pMaster);
      assert( rc!=SQLITE_BUSY );
      if( rc!=SQLITE_OK ){
<span class="udiff-line-modified-removed">-       sqlite3DbFree(db, zMaster);</span>
<span class="udiff-line-modified-added">+       sqlite3DbFree(db, zMaster-4);</span>
        return rc;
      }
  
      /* Delete the master journal file. This commits the transaction. After
      ** doing this the directory is synced again before any individual
      ** transaction files are deleted.
      */
      rc = sqlite3OsDelete(pVfs, zMaster, 1);
<span class="udiff-line-modified-removed">-     sqlite3DbFree(db, zMaster);</span>
<span class="udiff-line-modified-added">+     sqlite3DbFree(db, zMaster-4);</span>
      zMaster = 0;
      if( rc ){
        return rc;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -80832,11 +81107,11 @@</span>
  SQLITE_PRIVATE int sqlite3VdbeCursorMoveto(VdbeCursor **pp, int *piCol){
    VdbeCursor *p = *pp;
    assert( p-&gt;eCurType==CURTYPE_BTREE || p-&gt;eCurType==CURTYPE_PSEUDO );
    if( p-&gt;deferredMoveto ){
      int iMap;
<span class="udiff-line-modified-removed">-     if( p-&gt;aAltMap &amp;&amp; (iMap = p-&gt;aAltMap[1+*piCol])&gt;0 ){</span>
<span class="udiff-line-modified-added">+     if( p-&gt;aAltMap &amp;&amp; (iMap = p-&gt;aAltMap[1+*piCol])&gt;0 &amp;&amp; !p-&gt;nullRow ){</span>
        *pp = p-&gt;pAltCursor;
        *piCol = iMap - 1;
        return SQLITE_OK;
      }
      return sqlite3VdbeFinishMoveto(p);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -81835,11 +82110,11 @@</span>
        }
      }
  
      /* RHS is a string */
      else if( pRhs-&gt;flags &amp; MEM_Str ){
<span class="udiff-line-modified-removed">-       getVarint32(&amp;aKey1[idx1], serial_type);</span>
<span class="udiff-line-modified-added">+       getVarint32NR(&amp;aKey1[idx1], serial_type);</span>
        testcase( serial_type==12 );
        if( serial_type&lt;12 ){
          rc = -1;
        }else if( !(serial_type &amp; 0x01) ){
          rc = +1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -81869,11 +82144,11 @@</span>
      }
  
      /* RHS is a blob */
      else if( pRhs-&gt;flags &amp; MEM_Blob ){
        assert( (pRhs-&gt;flags &amp; MEM_Zero)==0 || pRhs-&gt;n==0 );
<span class="udiff-line-modified-removed">-       getVarint32(&amp;aKey1[idx1], serial_type);</span>
<span class="udiff-line-modified-added">+       getVarint32NR(&amp;aKey1[idx1], serial_type);</span>
        testcase( serial_type==12 );
        if( serial_type&lt;12 || (serial_type &amp; 0x01) ){
          rc = -1;
        }else{
          int nStr = (serial_type - 12) / 2;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -82058,11 +82333,14 @@</span>
    int serial_type;
    int res;
  
    assert( pPKey2-&gt;aMem[0].flags &amp; MEM_Str );
    vdbeAssertFieldCountWithinLimits(nKey1, pKey1, pPKey2-&gt;pKeyInfo);
<span class="udiff-line-modified-removed">-   getVarint32(&amp;aKey1[1], serial_type);</span>
<span class="udiff-line-modified-added">+   serial_type = (u8)(aKey1[1]);</span>
<span class="udiff-line-added">+   if( serial_type &gt;= 0x80 ){</span>
<span class="udiff-line-added">+     sqlite3GetVarint32(&amp;aKey1[1], (u32*)&amp;serial_type);</span>
<span class="udiff-line-added">+   }</span>
    if( serial_type&lt;12 ){
      res = pPKey2-&gt;r1;      /* (pKey1/nKey1) is a number or a null */
    }else if( !(serial_type &amp; 0x01) ){
      res = pPKey2-&gt;r2;      /* (pKey1/nKey1) is a blob */
    }else{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -82179,28 +82457,28 @@</span>
    nCellKey = sqlite3BtreePayloadSize(pCur);
    assert( (nCellKey &amp; SQLITE_MAX_U32)==(u64)nCellKey );
  
    /* Read in the complete content of the index entry */
    sqlite3VdbeMemInit(&amp;m, db, 0);
<span class="udiff-line-modified-removed">-   rc = sqlite3VdbeMemFromBtree(pCur, 0, (u32)nCellKey, &amp;m);</span>
<span class="udiff-line-modified-added">+   rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, (u32)nCellKey, &amp;m);</span>
    if( rc ){
      return rc;
    }
  
    /* The index entry must begin with a header size */
<span class="udiff-line-modified-removed">-   (void)getVarint32((u8*)m.z, szHdr);</span>
<span class="udiff-line-modified-added">+   getVarint32NR((u8*)m.z, szHdr);</span>
    testcase( szHdr==3 );
    testcase( szHdr==m.n );
    testcase( szHdr&gt;0x7fffffff );
    assert( m.n&gt;=0 );
    if( unlikely(szHdr&lt;3 || szHdr&gt;(unsigned)m.n) ){
      goto idx_rowid_corruption;
    }
  
    /* The last field of the index should be an integer - the ROWID.
    ** Verify that the last entry really is an integer. */
<span class="udiff-line-modified-removed">-   (void)getVarint32((u8*)&amp;m.z[szHdr-1], typeRowid);</span>
<span class="udiff-line-modified-added">+   getVarint32NR((u8*)&amp;m.z[szHdr-1], typeRowid);</span>
    testcase( typeRowid==1 );
    testcase( typeRowid==2 );
    testcase( typeRowid==3 );
    testcase( typeRowid==4 );
    testcase( typeRowid==5 );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -82261,11 +82539,11 @@</span>
    if( nCellKey&lt;=0 || nCellKey&gt;0x7fffffff ){
      *res = 0;
      return SQLITE_CORRUPT_BKPT;
    }
    sqlite3VdbeMemInit(&amp;m, db, 0);
<span class="udiff-line-modified-removed">-   rc = sqlite3VdbeMemFromBtree(pCur, 0, (u32)nCellKey, &amp;m);</span>
<span class="udiff-line-modified-added">+   rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, (u32)nCellKey, &amp;m);</span>
    if( rc ){
      return rc;
    }
    *res = sqlite3VdbeRecordCompareWithSkip(m.n, m.z, pUnpacked, 0);
    sqlite3VdbeMemRelease(&amp;m);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -83174,11 +83452,11 @@</span>
      /* If there are no other statements currently running, then
      ** reset the interrupt flag.  This prevents a call to sqlite3_interrupt
      ** from interrupting a statement that has not yet started.
      */
      if( db-&gt;nVdbeActive==0 ){
<span class="udiff-line-modified-removed">-       db-&gt;u1.isInterrupted = 0;</span>
<span class="udiff-line-modified-added">+       AtomicStore(&amp;db-&gt;u1.isInterrupted, 0);</span>
      }
  
      assert( db-&gt;nVdbeWrite&gt;0 || db-&gt;autoCommit==0
          || (db-&gt;nDeferredCons==0 &amp;&amp; db-&gt;nDeferredImmCons==0)
      );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -83866,11 +84144,11 @@</span>
    p-&gt;db-&gt;errCode = SQLITE_OK;
  
    /* If the bit corresponding to this variable in Vdbe.expmask is set, then
    ** binding a new value to this variable invalidates the current query plan.
    **
<span class="udiff-line-modified-removed">-   ** IMPLEMENTATION-OF: R-48440-37595 If the specific value bound to host</span>
<span class="udiff-line-modified-added">+   ** IMPLEMENTATION-OF: R-57496-20354 If the specific value bound to a host</span>
    ** parameter in the WHERE clause might influence the choice of query plan
    ** for a statement, then the statement will be automatically recompiled,
    ** as if there had been a schema change, on the first sqlite3_step() call
    ** following any change to the bindings of that parameter.
    */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -85554,16 +85832,18 @@</span>
      /* This happens if a malloc() inside a call to sqlite3_column_text() or
      ** sqlite3_column_text16() failed.  */
      goto no_mem;
    }
    assert( p-&gt;rc==SQLITE_OK || (p-&gt;rc&amp;0xff)==SQLITE_BUSY );
<span class="udiff-line-added">+   testcase( p-&gt;rc!=SQLITE_OK );</span>
<span class="udiff-line-added">+   p-&gt;rc = SQLITE_OK;</span>
    assert( p-&gt;bIsReader || p-&gt;readOnly!=0 );
    p-&gt;iCurrentTime = 0;
    assert( p-&gt;explain==0 );
    p-&gt;pResultSet = 0;
    db-&gt;busyHandler.nBusy = 0;
<span class="udiff-line-modified-removed">-   if( db-&gt;u1.isInterrupted ) goto abort_due_to_interrupt;</span>
<span class="udiff-line-modified-added">+   if( AtomicLoad(&amp;db-&gt;u1.isInterrupted) ) goto abort_due_to_interrupt;</span>
    sqlite3VdbeIOTraceSql(p);
  #ifdef SQLITE_DEBUG
    sqlite3BeginBenignMalloc();
    if( p-&gt;pc==0
     &amp;&amp; (p-&gt;db-&gt;flags &amp; (SQLITE_VdbeListing|SQLITE_VdbeEQP|SQLITE_VdbeTrace))!=0
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -85743,11 +86023,11 @@</span>
    ** But that is not due to sloppy coding habits. The code is written this
    ** way for performance, to avoid having to run the interrupt and progress
    ** checks on every opcode.  This helps sqlite3_step() to run about 1.5%
    ** faster according to &quot;valgrind --tool=cachegrind&quot; */
  check_for_interrupt:
<span class="udiff-line-modified-removed">-   if( db-&gt;u1.isInterrupted ) goto abort_due_to_interrupt;</span>
<span class="udiff-line-modified-added">+   if( AtomicLoad(&amp;db-&gt;u1.isInterrupted) ) goto abort_due_to_interrupt;</span>
  #ifndef SQLITE_OMIT_PROGRESS_CALLBACK
    /* Call the progress callback if it is configured and the required number
    ** of VDBE ops have been executed (either since this invocation of
    ** sqlite3VdbeExec() or since last time the progress callback was called).
    ** If the progress callback returns non-zero, exit the virtual machine with
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -86396,11 +86676,10 @@</span>
    u16 flags2;         /* Initial flags for P2 */
  
    pIn1 = &amp;aMem[pOp-&gt;p1];
    pIn2 = &amp;aMem[pOp-&gt;p2];
    pOut = &amp;aMem[pOp-&gt;p3];
<span class="udiff-line-removed">-   testcase( pIn1==pIn2 );</span>
    testcase( pOut==pIn2 );
    assert( pIn1!=pOut );
    flags1 = pIn1-&gt;flags;
    testcase( flags1 &amp; MEM_Null );
    testcase( pIn2-&gt;flags &amp; MEM_Null );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -86927,11 +87206,11 @@</span>
      affinity = pOp-&gt;p5 &amp; SQLITE_AFF_MASK;
      if( affinity&gt;=SQLITE_AFF_NUMERIC ){
        if( (flags1 | flags3)&amp;MEM_Str ){
          if( (flags1 &amp; (MEM_Int|MEM_IntReal|MEM_Real|MEM_Str))==MEM_Str ){
            applyNumericAffinity(pIn1,0);
<span class="udiff-line-modified-removed">-           testcase( flags3!=pIn3-&gt;flags );</span>
<span class="udiff-line-modified-added">+           testcase( flags3==pIn3-&gt;flags );</span>
            flags3 = pIn3-&gt;flags;
          }
          if( (flags3 &amp; (MEM_Int|MEM_IntReal|MEM_Real|MEM_Str))==MEM_Str ){
            applyNumericAffinity(pIn3,0);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -86950,11 +87229,11 @@</span>
          testcase( pIn1-&gt;flags &amp; MEM_Real );
          testcase( pIn1-&gt;flags &amp; MEM_IntReal );
          sqlite3VdbeMemStringify(pIn1, encoding, 1);
          testcase( (flags1&amp;MEM_Dyn) != (pIn1-&gt;flags&amp;MEM_Dyn) );
          flags1 = (pIn1-&gt;flags &amp; ~MEM_TypeMask) | (flags1 &amp; MEM_TypeMask);
<span class="udiff-line-modified-removed">-         if( pIn1==pIn3 ) flags3 = flags1 | MEM_Str;</span>
<span class="udiff-line-modified-added">+         if( NEVER(pIn1==pIn3) ) flags3 = flags1 | MEM_Str;</span>
        }
        if( (flags3 &amp; MEM_Str)==0 &amp;&amp; (flags3&amp;(MEM_Int|MEM_Real|MEM_IntReal))!=0 ){
          testcase( pIn3-&gt;flags &amp; MEM_Int );
          testcase( pIn3-&gt;flags &amp; MEM_Real );
          testcase( pIn3-&gt;flags &amp; MEM_IntReal );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -87565,11 +87844,11 @@</span>
      */
      if( pC-&gt;iHdrOffset&lt;aOffset[0] ){
        /* Make sure zData points to enough of the record to cover the header. */
        if( pC-&gt;aRow==0 ){
          memset(&amp;sMem, 0, sizeof(sMem));
<span class="udiff-line-modified-removed">-         rc = sqlite3VdbeMemFromBtree(pC-&gt;uc.pCursor, 0, aOffset[0], &amp;sMem);</span>
<span class="udiff-line-modified-added">+         rc = sqlite3VdbeMemFromBtreeZeroOffset(pC-&gt;uc.pCursor,aOffset[0],&amp;sMem);</span>
          if( rc!=SQLITE_OK ) goto abort_due_to_error;
          zData = (u8*)sMem.z;
        }else{
          zData = pC-&gt;aRow;
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -88040,32 +88319,38 @@</span>
    assert( pOp-&gt;p3&gt;0 &amp;&amp; pOp-&gt;p3&lt;=(p-&gt;nMem+1 - p-&gt;nCursor) );
    REGISTER_TRACE(pOp-&gt;p3, pOut);
    break;
  }
  
<span class="udiff-line-modified-removed">- /* Opcode: Count P1 P2 * * *</span>
<span class="udiff-line-modified-added">+ /* Opcode: Count P1 P2 p3 * *</span>
  ** Synopsis: r[P2]=count()
  **
  ** Store the number of entries (an integer value) in the table or index
<span class="udiff-line-modified-removed">- ** opened by cursor P1 in register P2</span>
<span class="udiff-line-modified-added">+ ** opened by cursor P1 in register P2.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** If P3==0, then an exact count is obtained, which involves visiting</span>
<span class="udiff-line-added">+ ** every btree page of the table.  But if P3 is non-zero, an estimate</span>
<span class="udiff-line-added">+ ** is returned based on the current cursor position.</span>
  */
<span class="udiff-line-removed">- #ifndef SQLITE_OMIT_BTREECOUNT</span>
  case OP_Count: {         /* out2 */
    i64 nEntry;
    BtCursor *pCrsr;
  
    assert( p-&gt;apCsr[pOp-&gt;p1]-&gt;eCurType==CURTYPE_BTREE );
    pCrsr = p-&gt;apCsr[pOp-&gt;p1]-&gt;uc.pCursor;
    assert( pCrsr );
<span class="udiff-line-modified-removed">-   nEntry = 0;  /* Not needed.  Only used to silence a warning. */</span>
<span class="udiff-line-modified-removed">-   rc = sqlite3BtreeCount(db, pCrsr, &amp;nEntry);</span>
<span class="udiff-line-modified-removed">-   if( rc ) goto abort_due_to_error;</span>
<span class="udiff-line-modified-added">+   if( pOp-&gt;p3 ){</span>
<span class="udiff-line-modified-added">+     nEntry = sqlite3BtreeRowCountEst(pCrsr);</span>
<span class="udiff-line-modified-added">+   }else{</span>
<span class="udiff-line-added">+     nEntry = 0;  /* Not needed.  Only used to silence a warning. */</span>
<span class="udiff-line-added">+     rc = sqlite3BtreeCount(db, pCrsr, &amp;nEntry);</span>
<span class="udiff-line-added">+     if( rc ) goto abort_due_to_error;</span>
<span class="udiff-line-added">+   }</span>
    pOut = out2Prerelease(p, pOp);
    pOut-&gt;u.i = nEntry;
    goto check_for_interrupt;
  }
<span class="udiff-line-removed">- #endif</span>
  
  /* Opcode: Savepoint P1 * * P4 *
  **
  ** Open, release or rollback the savepoint named by parameter P4, depending
  ** on the value of P1. To open a new savepoint set P1==0 (SAVEPOINT_BEGIN).
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -88517,11 +88802,11 @@</span>
  **
  ** Allowed P5 bits:
  ** &lt;ul&gt;
  ** &lt;li&gt;  &lt;b&gt;0x02 OPFLAG_SEEKEQ&lt;/b&gt;: This cursor will only be used for
  **       equality lookups (implemented as a pair of opcodes OP_SeekGE/OP_IdxGT
<span class="udiff-line-modified-removed">- **       of OP_SeekLE/OP_IdxGT)</span>
<span class="udiff-line-modified-added">+ **       of OP_SeekLE/OP_IdxLT)</span>
  ** &lt;/ul&gt;
  **
  ** The P4 value may be either an integer (P4_INT32) or a pointer to
  ** a KeyInfo structure (P4_KEYINFO). If it is a pointer to a KeyInfo
  ** object, then table being opened must be an [index b-tree] where the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -88547,11 +88832,11 @@</span>
  **
  ** Allowed P5 bits:
  ** &lt;ul&gt;
  ** &lt;li&gt;  &lt;b&gt;0x02 OPFLAG_SEEKEQ&lt;/b&gt;: This cursor will only be used for
  **       equality lookups (implemented as a pair of opcodes OP_SeekGE/OP_IdxGT
<span class="udiff-line-modified-removed">- **       of OP_SeekLE/OP_IdxGT)</span>
<span class="udiff-line-modified-added">+ **       of OP_SeekLE/OP_IdxLT)</span>
  ** &lt;/ul&gt;
  **
  ** See also: OP_OpenRead, OP_OpenWrite
  */
  /* Opcode: OpenWrite P1 P2 P3 P4 P5
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -88571,11 +88856,11 @@</span>
  **
  ** Allowed P5 bits:
  ** &lt;ul&gt;
  ** &lt;li&gt;  &lt;b&gt;0x02 OPFLAG_SEEKEQ&lt;/b&gt;: This cursor will only be used for
  **       equality lookups (implemented as a pair of opcodes OP_SeekGE/OP_IdxGT
<span class="udiff-line-modified-removed">- **       of OP_SeekLE/OP_IdxGT)</span>
<span class="udiff-line-modified-added">+ **       of OP_SeekLE/OP_IdxLT)</span>
  ** &lt;li&gt;  &lt;b&gt;0x08 OPFLAG_FORDELETE&lt;/b&gt;: This cursor is used only to seek
  **       and subsequently delete entries in an index btree.  This is a
  **       hint to the storage engine that the storage engine is allowed to
  **       ignore.  The hint is not used by the official SQLite b*tree storage
  **       engine, but is used by COMDB2.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -88683,13 +88968,11 @@</span>
  
  open_cursor_set_hints:
    assert( OPFLAG_BULKCSR==BTREE_BULKLOAD );
    assert( OPFLAG_SEEKEQ==BTREE_SEEK_EQ );
    testcase( pOp-&gt;p5 &amp; OPFLAG_BULKCSR );
<span class="udiff-line-removed">- #ifdef SQLITE_ENABLE_CURSOR_HINTS</span>
    testcase( pOp-&gt;p2 &amp; OPFLAG_SEEKEQ );
<span class="udiff-line-removed">- #endif</span>
    sqlite3BtreeCursorHintFlags(pCur-&gt;uc.pCursor,
                                 (pOp-&gt;p5 &amp; (OPFLAG_BULKCSR|OPFLAG_SEEKEQ)));
    if( rc ) goto abort_due_to_error;
    break;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -88941,15 +89224,17 @@</span>
  ** Reposition cursor P1 so that  it points to the smallest entry that
  ** is greater than or equal to the key value. If there are no records
  ** greater than or equal to the key and P2 is not zero, then jump to P2.
  **
  ** If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this
<span class="udiff-line-modified-removed">- ** opcode will always land on a record that equally equals the key, or</span>
<span class="udiff-line-modified-removed">- ** else jump immediately to P2.  When the cursor is OPFLAG_SEEKEQ, this</span>
<span class="udiff-line-modified-removed">- ** opcode must be followed by an IdxLE opcode with the same arguments.</span>
<span class="udiff-line-modified-removed">- ** The IdxLE opcode will be skipped if this opcode succeeds, but the</span>
<span class="udiff-line-modified-removed">- ** IdxLE opcode will be used on subsequent loop iterations.</span>
<span class="udiff-line-modified-added">+ ** opcode will either land on a record that exactly matches the key, or</span>
<span class="udiff-line-modified-added">+ ** else it will cause a jump to P2.  When the cursor is OPFLAG_SEEKEQ,</span>
<span class="udiff-line-modified-added">+ ** this opcode must be followed by an IdxLE opcode with the same arguments.</span>
<span class="udiff-line-modified-added">+ ** The IdxGT opcode will be skipped if this opcode succeeds, but the</span>
<span class="udiff-line-modified-added">+ ** IdxGT opcode will be used on subsequent loop iterations.  The</span>
<span class="udiff-line-added">+ ** OPFLAG_SEEKEQ flags is a hint to the btree layer to say that this</span>
<span class="udiff-line-added">+ ** is an equality search.</span>
  **
  ** This opcode leaves the cursor configured to move in forward order,
  ** from the beginning toward the end.  In other words, the cursor is
  ** configured to use Next, not Prev.
  **
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -88961,11 +89246,11 @@</span>
  ** If cursor P1 refers to an SQL table (B-Tree that uses integer keys),
  ** use the value in register P3 as a key. If cursor P1 refers
  ** to an SQL index, then P3 is the first in an array of P4 registers
  ** that are used as an unpacked index key.
  **
<span class="udiff-line-modified-removed">- ** Reposition cursor P1 so that  it points to the smallest entry that</span>
<span class="udiff-line-modified-added">+ ** Reposition cursor P1 so that it points to the smallest entry that</span>
  ** is greater than the key value. If there are no records greater than
  ** the key and P2 is not zero, then jump to P2.
  **
  ** This opcode leaves the cursor configured to move in forward order,
  ** from the beginning toward the end.  In other words, the cursor is
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -89006,15 +89291,17 @@</span>
  ** This opcode leaves the cursor configured to move in reverse order,
  ** from the end toward the beginning.  In other words, the cursor is
  ** configured to use Prev, not Next.
  **
  ** If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this
<span class="udiff-line-modified-removed">- ** opcode will always land on a record that equally equals the key, or</span>
<span class="udiff-line-modified-removed">- ** else jump immediately to P2.  When the cursor is OPFLAG_SEEKEQ, this</span>
<span class="udiff-line-modified-removed">- ** opcode must be followed by an IdxGE opcode with the same arguments.</span>
<span class="udiff-line-modified-added">+ ** opcode will either land on a record that exactly matches the key, or</span>
<span class="udiff-line-modified-added">+ ** else it will cause a jump to P2.  When the cursor is OPFLAG_SEEKEQ,</span>
<span class="udiff-line-modified-added">+ ** this opcode must be followed by an IdxLE opcode with the same arguments.</span>
  ** The IdxGE opcode will be skipped if this opcode succeeds, but the
<span class="udiff-line-modified-removed">- ** IdxGE opcode will be used on subsequent loop iterations.</span>
<span class="udiff-line-modified-added">+ ** IdxGE opcode will be used on subsequent loop iterations.  The</span>
<span class="udiff-line-added">+ ** OPFLAG_SEEKEQ flags is a hint to the btree layer to say that this</span>
<span class="udiff-line-added">+ ** is an equality search.</span>
  **
  ** See also: Found, NotFound, SeekGt, SeekGe, SeekLt
  */
  case OP_SeekLT:         /* jump, in3, group */
  case OP_SeekLE:         /* jump, in3, group */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -89047,11 +89334,11 @@</span>
  
    pC-&gt;deferredMoveto = 0;
    pC-&gt;cacheStatus = CACHE_STALE;
    if( pC-&gt;isTable ){
      u16 flags3, newType;
<span class="udiff-line-modified-removed">-     /* The BTREE_SEEK_EQ flag is only set on index cursors */</span>
<span class="udiff-line-modified-added">+     /* The OPFLAG_SEEKEQ/BTREE_SEEK_EQ flag is only set on index cursors */</span>
      assert( sqlite3BtreeCursorHasHint(pC-&gt;uc.pCursor, BTREE_SEEK_EQ)==0
                || CORRUPT_DB );
  
      /* The input value in P3 might be of any type: integer, real, string,
      ** blob, or NULL.  But it needs to be an integer before we can do
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -89106,18 +89393,21 @@</span>
      pC-&gt;movetoTarget = iKey;  /* Used by OP_Delete */
      if( rc!=SQLITE_OK ){
        goto abort_due_to_error;
      }
    }else{
<span class="udiff-line-modified-removed">-     /* For a cursor with the BTREE_SEEK_EQ hint, only the OP_SeekGE and</span>
<span class="udiff-line-modified-removed">-     ** OP_SeekLE opcodes are allowed, and these must be immediately followed</span>
<span class="udiff-line-modified-removed">-     ** by an OP_IdxGT or OP_IdxLT opcode, respectively, with the same key.</span>
<span class="udiff-line-modified-added">+     /* For a cursor with the OPFLAG_SEEKEQ/BTREE_SEEK_EQ hint, only the</span>
<span class="udiff-line-modified-added">+     ** OP_SeekGE and OP_SeekLE opcodes are allowed, and these must be</span>
<span class="udiff-line-modified-added">+     ** immediately followed by an OP_IdxGT or OP_IdxLT opcode, respectively,</span>
<span class="udiff-line-added">+     ** with the same key.</span>
      */
      if( sqlite3BtreeCursorHasHint(pC-&gt;uc.pCursor, BTREE_SEEK_EQ) ){
        eqOnly = 1;
        assert( pOp-&gt;opcode==OP_SeekGE || pOp-&gt;opcode==OP_SeekLE );
        assert( pOp[1].opcode==OP_IdxLT || pOp[1].opcode==OP_IdxGT );
<span class="udiff-line-added">+       assert( pOp-&gt;opcode==OP_SeekGE || pOp[1].opcode==OP_IdxLT );</span>
<span class="udiff-line-added">+       assert( pOp-&gt;opcode==OP_SeekLE || pOp[1].opcode==OP_IdxGT );</span>
        assert( pOp[1].p1==pOp[0].p1 );
        assert( pOp[1].p2==pOp[0].p2 );
        assert( pOp[1].p3==pOp[0].p3 );
        assert( pOp[1].p4.i==pOp[0].p4.i );
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -90061,11 +90351,11 @@</span>
    n = sqlite3BtreePayloadSize(pCrsr);
    if( n&gt;(u32)db-&gt;aLimit[SQLITE_LIMIT_LENGTH] ){
      goto too_big;
    }
    testcase( n==0 );
<span class="udiff-line-modified-removed">-   rc = sqlite3VdbeMemFromBtree(pCrsr, 0, n, pOut);</span>
<span class="udiff-line-modified-added">+   rc = sqlite3VdbeMemFromBtreeZeroOffset(pCrsr, n, pOut);</span>
    if( rc ) goto abort_due_to_error;
    if( !pOp-&gt;p3 ) Deephemeralize(pOut);
    UPDATE_MAX_BLOBSIZE(pOut);
    REGISTER_TRACE(pOp-&gt;p2, pOut);
    break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -90439,58 +90729,78 @@</span>
  ** to P2.
  **
  ** This instruction only works for indices.  The equivalent instruction
  ** for tables is OP_Insert.
  */
<span class="udiff-line-added">+ case OP_IdxInsert: {        /* in2 */</span>
<span class="udiff-line-added">+   VdbeCursor *pC;</span>
<span class="udiff-line-added">+   BtreePayload x;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   assert( pOp-&gt;p1&gt;=0 &amp;&amp; pOp-&gt;p1&lt;p-&gt;nCursor );</span>
<span class="udiff-line-added">+   pC = p-&gt;apCsr[pOp-&gt;p1];</span>
<span class="udiff-line-added">+   sqlite3VdbeIncrWriteCounter(p, pC);</span>
<span class="udiff-line-added">+   assert( pC!=0 );</span>
<span class="udiff-line-added">+   assert( !isSorter(pC) );</span>
<span class="udiff-line-added">+   pIn2 = &amp;aMem[pOp-&gt;p2];</span>
<span class="udiff-line-added">+   assert( pIn2-&gt;flags &amp; MEM_Blob );</span>
<span class="udiff-line-added">+   if( pOp-&gt;p5 &amp; OPFLAG_NCHANGE ) p-&gt;nChange++;</span>
<span class="udiff-line-added">+   assert( pC-&gt;eCurType==CURTYPE_BTREE );</span>
<span class="udiff-line-added">+   assert( pC-&gt;isTable==0 );</span>
<span class="udiff-line-added">+   rc = ExpandBlob(pIn2);</span>
<span class="udiff-line-added">+   if( rc ) goto abort_due_to_error;</span>
<span class="udiff-line-added">+   x.nKey = pIn2-&gt;n;</span>
<span class="udiff-line-added">+   x.pKey = pIn2-&gt;z;</span>
<span class="udiff-line-added">+   x.aMem = aMem + pOp-&gt;p3;</span>
<span class="udiff-line-added">+   x.nMem = (u16)pOp-&gt;p4.i;</span>
<span class="udiff-line-added">+   rc = sqlite3BtreeInsert(pC-&gt;uc.pCursor, &amp;x,</span>
<span class="udiff-line-added">+        (pOp-&gt;p5 &amp; (OPFLAG_APPEND|OPFLAG_SAVEPOSITION)),</span>
<span class="udiff-line-added">+       ((pOp-&gt;p5 &amp; OPFLAG_USESEEKRESULT) ? pC-&gt;seekResult : 0)</span>
<span class="udiff-line-added">+       );</span>
<span class="udiff-line-added">+   assert( pC-&gt;deferredMoveto==0 );</span>
<span class="udiff-line-added">+   pC-&gt;cacheStatus = CACHE_STALE;</span>
<span class="udiff-line-added">+   if( rc) goto abort_due_to_error;</span>
<span class="udiff-line-added">+   break;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /* Opcode: SorterInsert P1 P2 * * *
  ** Synopsis: key=r[P2]
  **
  ** Register P2 holds an SQL index key made using the
  ** MakeRecord instructions.  This opcode writes that key
  ** into the sorter P1.  Data for the entry is nil.
  */
<span class="udiff-line-modified-removed">- case OP_SorterInsert:       /* in2 */</span>
<span class="udiff-line-removed">- case OP_IdxInsert: {        /* in2 */</span>
<span class="udiff-line-modified-added">+ case OP_SorterInsert: {     /* in2 */</span>
    VdbeCursor *pC;
<span class="udiff-line-removed">-   BtreePayload x;</span>
  
    assert( pOp-&gt;p1&gt;=0 &amp;&amp; pOp-&gt;p1&lt;p-&gt;nCursor );
    pC = p-&gt;apCsr[pOp-&gt;p1];
    sqlite3VdbeIncrWriteCounter(p, pC);
    assert( pC!=0 );
<span class="udiff-line-modified-removed">-   assert( isSorter(pC)==(pOp-&gt;opcode==OP_SorterInsert) );</span>
<span class="udiff-line-modified-added">+   assert( isSorter(pC) );</span>
    pIn2 = &amp;aMem[pOp-&gt;p2];
    assert( pIn2-&gt;flags &amp; MEM_Blob );
<span class="udiff-line-removed">-   if( pOp-&gt;p5 &amp; OPFLAG_NCHANGE ) p-&gt;nChange++;</span>
<span class="udiff-line-removed">-   assert( pC-&gt;eCurType==CURTYPE_BTREE || pOp-&gt;opcode==OP_SorterInsert );</span>
    assert( pC-&gt;isTable==0 );
    rc = ExpandBlob(pIn2);
    if( rc ) goto abort_due_to_error;
<span class="udiff-line-modified-removed">-   if( pOp-&gt;opcode==OP_SorterInsert ){</span>
<span class="udiff-line-removed">-     rc = sqlite3VdbeSorterWrite(pC, pIn2);</span>
<span class="udiff-line-removed">-   }else{</span>
<span class="udiff-line-removed">-     x.nKey = pIn2-&gt;n;</span>
<span class="udiff-line-removed">-     x.pKey = pIn2-&gt;z;</span>
<span class="udiff-line-removed">-     x.aMem = aMem + pOp-&gt;p3;</span>
<span class="udiff-line-removed">-     x.nMem = (u16)pOp-&gt;p4.i;</span>
<span class="udiff-line-removed">-     rc = sqlite3BtreeInsert(pC-&gt;uc.pCursor, &amp;x,</span>
<span class="udiff-line-removed">-          (pOp-&gt;p5 &amp; (OPFLAG_APPEND|OPFLAG_SAVEPOSITION)),</span>
<span class="udiff-line-removed">-         ((pOp-&gt;p5 &amp; OPFLAG_USESEEKRESULT) ? pC-&gt;seekResult : 0)</span>
<span class="udiff-line-removed">-         );</span>
<span class="udiff-line-removed">-     assert( pC-&gt;deferredMoveto==0 );</span>
<span class="udiff-line-removed">-     pC-&gt;cacheStatus = CACHE_STALE;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   rc = sqlite3VdbeSorterWrite(pC, pIn2);</span>
    if( rc) goto abort_due_to_error;
    break;
  }
  
<span class="udiff-line-modified-removed">- /* Opcode: IdxDelete P1 P2 P3 * *</span>
<span class="udiff-line-modified-added">+ /* Opcode: IdxDelete P1 P2 P3 * P5</span>
  ** Synopsis: key=r[P2@P3]
  **
  ** The content of P3 registers starting at register P2 form
  ** an unpacked index key. This opcode removes that entry from the
  ** index opened by cursor P1.
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** If P5 is not zero, then raise an SQLITE_CORRUPT_INDEX error</span>
<span class="udiff-line-added">+ ** if no matching index entry is found.  This happens when running</span>
<span class="udiff-line-added">+ ** an UPDATE or DELETE statement and the index entry to be updated</span>
<span class="udiff-line-added">+ ** or deleted is not found.  For some uses of IdxDelete</span>
<span class="udiff-line-added">+ ** (example:  the EXCEPT operator) it does not matter that no matching</span>
<span class="udiff-line-added">+ ** entry is found.  For those cases, P5 is zero.</span>
  */
  case OP_IdxDelete: {
    VdbeCursor *pC;
    BtCursor *pCrsr;
    int res;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -90503,20 +90813,22 @@</span>
    assert( pC!=0 );
    assert( pC-&gt;eCurType==CURTYPE_BTREE );
    sqlite3VdbeIncrWriteCounter(p, pC);
    pCrsr = pC-&gt;uc.pCursor;
    assert( pCrsr!=0 );
<span class="udiff-line-removed">-   assert( pOp-&gt;p5==0 );</span>
    r.pKeyInfo = pC-&gt;pKeyInfo;
    r.nField = (u16)pOp-&gt;p3;
    r.default_rc = 0;
    r.aMem = &amp;aMem[pOp-&gt;p2];
    rc = sqlite3BtreeMovetoUnpacked(pCrsr, &amp;r, 0, 0, &amp;res);
    if( rc ) goto abort_due_to_error;
    if( res==0 ){
      rc = sqlite3BtreeDelete(pCrsr, BTREE_AUXDELETE);
      if( rc ) goto abort_due_to_error;
<span class="udiff-line-added">+   }else if( pOp-&gt;p5 ){</span>
<span class="udiff-line-added">+     rc = SQLITE_CORRUPT_INDEX;</span>
<span class="udiff-line-added">+     goto abort_due_to_error;</span>
    }
    assert( pC-&gt;deferredMoveto==0 );
    pC-&gt;cacheStatus = CACHE_STALE;
    pC-&gt;seekResult = 0;
    break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -91315,11 +91627,11 @@</span>
    ** try to reuse register values from the first use. */
    {
      int i;
      for(i=0; i&lt;p-&gt;nMem; i++){
        aMem[i].pScopyFrom = 0;  /* Prevent false-positive AboutToChange() errs */
<span class="udiff-line-modified-removed">-       aMem[i].flags |= MEM_Undefined; /* Cause a fault if this reg is reused */</span>
<span class="udiff-line-modified-added">+       MemSetTypeFlag(&amp;aMem[i], MEM_Undefined); /* Fault if this reg is reused */</span>
      }
    }
  #endif
    pOp = &amp;aOp[-1];
    goto check_for_interrupt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -92426,11 +92738,11 @@</span>
    break;
  }
  #endif
  
  /* Opcode: Function P1 P2 P3 P4 *
<span class="udiff-line-modified-removed">- ** Synopsis: r[P3]=func(r[P2@P5])</span>
<span class="udiff-line-modified-added">+ ** Synopsis: r[P3]=func(r[P2@NP])</span>
  **
  ** Invoke a user function (P4 is a pointer to an sqlite3_context object that
  ** contains a pointer to the function to be run) with arguments taken
  ** from register P2 and successors.  The number of arguments is in
  ** the sqlite3_context object that P4 points to.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -92445,11 +92757,11 @@</span>
  ** invocation of this opcode.
  **
  ** See also: AggStep, AggFinal, PureFunc
  */
  /* Opcode: PureFunc P1 P2 P3 P4 *
<span class="udiff-line-modified-removed">- ** Synopsis: r[P3]=func(r[P2@P5])</span>
<span class="udiff-line-modified-added">+ ** Synopsis: r[P3]=func(r[P2@NP])</span>
  **
  ** Invoke a user function (P4 is a pointer to an sqlite3_context object that
  ** contains a pointer to the function to be run) with arguments taken
  ** from register P2 and successors.  The number of arguments is in
  ** the sqlite3_context object that P4 points to.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -92834,11 +93146,11 @@</span>
  
    /* Jump to here if the sqlite3_interrupt() API sets the interrupt
    ** flag.
    */
  abort_due_to_interrupt:
<span class="udiff-line-modified-removed">-   assert( db-&gt;u1.isInterrupted );</span>
<span class="udiff-line-modified-added">+   assert( AtomicLoad(&amp;db-&gt;u1.isInterrupted) );</span>
    rc = db-&gt;mallocFailed ? SQLITE_NOMEM_BKPT : SQLITE_INTERRUPT;
    p-&gt;rc = rc;
    sqlite3VdbeError(p, &quot;%s&quot;, sqlite3ErrStr(rc));
    goto abort_due_to_error;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -94172,12 +94484,12 @@</span>
  
    int n1;
    int n2;
    int res;
  
<span class="udiff-line-modified-removed">-   getVarint32(&amp;p1[1], n1);</span>
<span class="udiff-line-modified-removed">-   getVarint32(&amp;p2[1], n2);</span>
<span class="udiff-line-modified-added">+   getVarint32NR(&amp;p1[1], n1);</span>
<span class="udiff-line-modified-added">+   getVarint32NR(&amp;p2[1], n2);</span>
    res = memcmp(v1, v2, (MIN(n1, n2) - 13)/2);
    if( res==0 ){
      res = n1 - n2;
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -95130,11 +95442,11 @@</span>
    int nPMA;                       /* Bytes of PMA space required */
    int t;                          /* serial type of first record field */
  
    assert( pCsr-&gt;eCurType==CURTYPE_SORTER );
    pSorter = pCsr-&gt;uc.pSorter;
<span class="udiff-line-modified-removed">-   getVarint32((const u8*)&amp;pVal-&gt;z[1], t);</span>
<span class="udiff-line-modified-added">+   getVarint32NR((const u8*)&amp;pVal-&gt;z[1], t);</span>
    if( t&gt;0 &amp;&amp; t&lt;10 &amp;&amp; t!=7 ){
      pSorter-&gt;typeMask &amp;= SORTER_TYPE_INTEGER;
    }else if( t&gt;10 &amp;&amp; (t &amp; 0x01) ){
      pSorter-&gt;typeMask &amp;= SORTER_TYPE_TEXT;
    }else{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -96117,10 +96429,437 @@</span>
    *pRes = sqlite3VdbeRecordCompare(pVal-&gt;n, pVal-&gt;z, r2);
    return SQLITE_OK;
  }
  
  /************** End of vdbesort.c ********************************************/
<span class="udiff-line-added">+ /************** Begin file vdbevtab.c ****************************************/</span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** 2020-03-23</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** The author disclaims copyright to this source code.  In place of</span>
<span class="udiff-line-added">+ ** a legal notice, here is a blessing:</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ **    May you do good and not evil.</span>
<span class="udiff-line-added">+ **    May you find forgiveness for yourself and forgive others.</span>
<span class="udiff-line-added">+ **    May you share freely, never taking more than you give.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ *************************************************************************</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** This file implements virtual-tables for examining the bytecode content</span>
<span class="udiff-line-added">+ ** of a prepared statement.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ /* #include &quot;sqliteInt.h&quot; */</span>
<span class="udiff-line-added">+ #if defined(SQLITE_ENABLE_BYTECODE_VTAB) &amp;&amp; !defined(SQLITE_OMIT_VIRTUALTABLE)</span>
<span class="udiff-line-added">+ /* #include &quot;vdbeInt.h&quot; */</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /* An instance of the bytecode() table-valued function.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ typedef struct bytecodevtab bytecodevtab;</span>
<span class="udiff-line-added">+ struct bytecodevtab {</span>
<span class="udiff-line-added">+   sqlite3_vtab base;     /* Base class - must be first */</span>
<span class="udiff-line-added">+   sqlite3 *db;           /* Database connection */</span>
<span class="udiff-line-added">+   int bTablesUsed;       /* 2 for tables_used().  0 for bytecode(). */</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /* A cursor for scanning through the bytecode</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ typedef struct bytecodevtab_cursor bytecodevtab_cursor;</span>
<span class="udiff-line-added">+ struct bytecodevtab_cursor {</span>
<span class="udiff-line-added">+   sqlite3_vtab_cursor base;  /* Base class - must be first */</span>
<span class="udiff-line-added">+   sqlite3_stmt *pStmt;       /* The statement whose bytecode is displayed */</span>
<span class="udiff-line-added">+   int iRowid;                /* The rowid of the output table */</span>
<span class="udiff-line-added">+   int iAddr;                 /* Address */</span>
<span class="udiff-line-added">+   int needFinalize;          /* Cursors owns pStmt and must finalize it */</span>
<span class="udiff-line-added">+   int showSubprograms;       /* Provide a listing of subprograms */</span>
<span class="udiff-line-added">+   Op *aOp;                   /* Operand array */</span>
<span class="udiff-line-added">+   char *zP4;                 /* Rendered P4 value */</span>
<span class="udiff-line-added">+   const char *zType;         /* tables_used.type */</span>
<span class="udiff-line-added">+   const char *zSchema;       /* tables_used.schema */</span>
<span class="udiff-line-added">+   const char *zName;         /* tables_used.name */</span>
<span class="udiff-line-added">+   Mem sub;                   /* Subprograms */</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Create a new bytecode() table-valued function.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static int bytecodevtabConnect(</span>
<span class="udiff-line-added">+   sqlite3 *db,</span>
<span class="udiff-line-added">+   void *pAux,</span>
<span class="udiff-line-added">+   int argc, const char *const*argv,</span>
<span class="udiff-line-added">+   sqlite3_vtab **ppVtab,</span>
<span class="udiff-line-added">+   char **pzErr</span>
<span class="udiff-line-added">+ ){</span>
<span class="udiff-line-added">+   bytecodevtab *pNew;</span>
<span class="udiff-line-added">+   int rc;</span>
<span class="udiff-line-added">+   int isTabUsed = pAux!=0;</span>
<span class="udiff-line-added">+   const char *azSchema[2] = {</span>
<span class="udiff-line-added">+     /* bytecode() schema */</span>
<span class="udiff-line-added">+     &quot;CREATE TABLE x(&quot;</span>
<span class="udiff-line-added">+       &quot;addr INT,&quot;</span>
<span class="udiff-line-added">+       &quot;opcode TEXT,&quot;</span>
<span class="udiff-line-added">+       &quot;p1 INT,&quot;</span>
<span class="udiff-line-added">+       &quot;p2 INT,&quot;</span>
<span class="udiff-line-added">+       &quot;p3 INT,&quot;</span>
<span class="udiff-line-added">+       &quot;p4 TEXT,&quot;</span>
<span class="udiff-line-added">+       &quot;p5 INT,&quot;</span>
<span class="udiff-line-added">+       &quot;comment TEXT,&quot;</span>
<span class="udiff-line-added">+       &quot;subprog TEXT,&quot;</span>
<span class="udiff-line-added">+       &quot;stmt HIDDEN&quot;</span>
<span class="udiff-line-added">+     &quot;);&quot;,</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /* Tables_used() schema */</span>
<span class="udiff-line-added">+     &quot;CREATE TABLE x(&quot;</span>
<span class="udiff-line-added">+       &quot;type TEXT,&quot;</span>
<span class="udiff-line-added">+       &quot;schema TEXT,&quot;</span>
<span class="udiff-line-added">+       &quot;name TEXT,&quot;</span>
<span class="udiff-line-added">+       &quot;wr INT,&quot;</span>
<span class="udiff-line-added">+       &quot;subprog TEXT,&quot;</span>
<span class="udiff-line-added">+       &quot;stmt HIDDEN&quot;</span>
<span class="udiff-line-added">+    &quot;);&quot;</span>
<span class="udiff-line-added">+   };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   rc = sqlite3_declare_vtab(db, azSchema[isTabUsed]);</span>
<span class="udiff-line-added">+   if( rc==SQLITE_OK ){</span>
<span class="udiff-line-added">+     pNew = sqlite3_malloc( sizeof(*pNew) );</span>
<span class="udiff-line-added">+     *ppVtab = (sqlite3_vtab*)pNew;</span>
<span class="udiff-line-added">+     if( pNew==0 ) return SQLITE_NOMEM;</span>
<span class="udiff-line-added">+     memset(pNew, 0, sizeof(*pNew));</span>
<span class="udiff-line-added">+     pNew-&gt;db = db;</span>
<span class="udiff-line-added">+     pNew-&gt;bTablesUsed = isTabUsed*2;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return rc;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** This method is the destructor for bytecodevtab objects.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static int bytecodevtabDisconnect(sqlite3_vtab *pVtab){</span>
<span class="udiff-line-added">+   bytecodevtab *p = (bytecodevtab*)pVtab;</span>
<span class="udiff-line-added">+   sqlite3_free(p);</span>
<span class="udiff-line-added">+   return SQLITE_OK;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Constructor for a new bytecodevtab_cursor object.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static int bytecodevtabOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){</span>
<span class="udiff-line-added">+   bytecodevtab *pVTab = (bytecodevtab*)p;</span>
<span class="udiff-line-added">+   bytecodevtab_cursor *pCur;</span>
<span class="udiff-line-added">+   pCur = sqlite3_malloc( sizeof(*pCur) );</span>
<span class="udiff-line-added">+   if( pCur==0 ) return SQLITE_NOMEM;</span>
<span class="udiff-line-added">+   memset(pCur, 0, sizeof(*pCur));</span>
<span class="udiff-line-added">+   sqlite3VdbeMemInit(&amp;pCur-&gt;sub, pVTab-&gt;db, 1);</span>
<span class="udiff-line-added">+   *ppCursor = &amp;pCur-&gt;base;</span>
<span class="udiff-line-added">+   return SQLITE_OK;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Clear all internal content from a bytecodevtab cursor.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static void bytecodevtabCursorClear(bytecodevtab_cursor *pCur){</span>
<span class="udiff-line-added">+   sqlite3_free(pCur-&gt;zP4);</span>
<span class="udiff-line-added">+   pCur-&gt;zP4 = 0;</span>
<span class="udiff-line-added">+   sqlite3VdbeMemRelease(&amp;pCur-&gt;sub);</span>
<span class="udiff-line-added">+   sqlite3VdbeMemSetNull(&amp;pCur-&gt;sub);</span>
<span class="udiff-line-added">+   if( pCur-&gt;needFinalize ){</span>
<span class="udiff-line-added">+     sqlite3_finalize(pCur-&gt;pStmt);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   pCur-&gt;pStmt = 0;</span>
<span class="udiff-line-added">+   pCur-&gt;needFinalize = 0;</span>
<span class="udiff-line-added">+   pCur-&gt;zType = 0;</span>
<span class="udiff-line-added">+   pCur-&gt;zSchema = 0;</span>
<span class="udiff-line-added">+   pCur-&gt;zName = 0;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Destructor for a bytecodevtab_cursor.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static int bytecodevtabClose(sqlite3_vtab_cursor *cur){</span>
<span class="udiff-line-added">+   bytecodevtab_cursor *pCur = (bytecodevtab_cursor*)cur;</span>
<span class="udiff-line-added">+   bytecodevtabCursorClear(pCur);</span>
<span class="udiff-line-added">+   sqlite3_free(pCur);</span>
<span class="udiff-line-added">+   return SQLITE_OK;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Advance a bytecodevtab_cursor to its next row of output.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static int bytecodevtabNext(sqlite3_vtab_cursor *cur){</span>
<span class="udiff-line-added">+   bytecodevtab_cursor *pCur = (bytecodevtab_cursor*)cur;</span>
<span class="udiff-line-added">+   bytecodevtab *pTab = (bytecodevtab*)cur-&gt;pVtab;</span>
<span class="udiff-line-added">+   int rc;</span>
<span class="udiff-line-added">+   if( pCur-&gt;zP4 ){</span>
<span class="udiff-line-added">+     sqlite3_free(pCur-&gt;zP4);</span>
<span class="udiff-line-added">+     pCur-&gt;zP4 = 0;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if( pCur-&gt;zName ){</span>
<span class="udiff-line-added">+     pCur-&gt;zName = 0;</span>
<span class="udiff-line-added">+     pCur-&gt;zType = 0;</span>
<span class="udiff-line-added">+     pCur-&gt;zSchema = 0;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   rc = sqlite3VdbeNextOpcode(</span>
<span class="udiff-line-added">+            (Vdbe*)pCur-&gt;pStmt,</span>
<span class="udiff-line-added">+            pCur-&gt;showSubprograms ? &amp;pCur-&gt;sub : 0,</span>
<span class="udiff-line-added">+            pTab-&gt;bTablesUsed,</span>
<span class="udiff-line-added">+            &amp;pCur-&gt;iRowid,</span>
<span class="udiff-line-added">+            &amp;pCur-&gt;iAddr,</span>
<span class="udiff-line-added">+            &amp;pCur-&gt;aOp);</span>
<span class="udiff-line-added">+   if( rc!=SQLITE_OK ){</span>
<span class="udiff-line-added">+     sqlite3VdbeMemSetNull(&amp;pCur-&gt;sub);</span>
<span class="udiff-line-added">+     pCur-&gt;aOp = 0;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return SQLITE_OK;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Return TRUE if the cursor has been moved off of the last</span>
<span class="udiff-line-added">+ ** row of output.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static int bytecodevtabEof(sqlite3_vtab_cursor *cur){</span>
<span class="udiff-line-added">+   bytecodevtab_cursor *pCur = (bytecodevtab_cursor*)cur;</span>
<span class="udiff-line-added">+   return pCur-&gt;aOp==0;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Return values of columns for the row at which the bytecodevtab_cursor</span>
<span class="udiff-line-added">+ ** is currently pointing.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static int bytecodevtabColumn(</span>
<span class="udiff-line-added">+   sqlite3_vtab_cursor *cur,   /* The cursor */</span>
<span class="udiff-line-added">+   sqlite3_context *ctx,       /* First argument to sqlite3_result_...() */</span>
<span class="udiff-line-added">+   int i                       /* Which column to return */</span>
<span class="udiff-line-added">+ ){</span>
<span class="udiff-line-added">+   bytecodevtab_cursor *pCur = (bytecodevtab_cursor*)cur;</span>
<span class="udiff-line-added">+   bytecodevtab *pVTab = (bytecodevtab*)cur-&gt;pVtab;</span>
<span class="udiff-line-added">+   Op *pOp = pCur-&gt;aOp + pCur-&gt;iAddr;</span>
<span class="udiff-line-added">+   if( pVTab-&gt;bTablesUsed ){</span>
<span class="udiff-line-added">+     if( i==4 ){</span>
<span class="udiff-line-added">+       i = 8;</span>
<span class="udiff-line-added">+     }else{</span>
<span class="udiff-line-added">+       if( i&lt;=2 &amp;&amp; pCur-&gt;zType==0 ){</span>
<span class="udiff-line-added">+         Schema *pSchema;</span>
<span class="udiff-line-added">+         HashElem *k;</span>
<span class="udiff-line-added">+         int iDb = pOp-&gt;p3;</span>
<span class="udiff-line-added">+         int iRoot = pOp-&gt;p2;</span>
<span class="udiff-line-added">+         sqlite3 *db = pVTab-&gt;db;</span>
<span class="udiff-line-added">+         pSchema = db-&gt;aDb[iDb].pSchema;</span>
<span class="udiff-line-added">+         pCur-&gt;zSchema = db-&gt;aDb[iDb].zDbSName;</span>
<span class="udiff-line-added">+         for(k=sqliteHashFirst(&amp;pSchema-&gt;tblHash); k; k=sqliteHashNext(k)){</span>
<span class="udiff-line-added">+           Table *pTab = (Table*)sqliteHashData(k);</span>
<span class="udiff-line-added">+           if( !IsVirtual(pTab) &amp;&amp; pTab-&gt;tnum==iRoot ){</span>
<span class="udiff-line-added">+             pCur-&gt;zName = pTab-&gt;zName;</span>
<span class="udiff-line-added">+             pCur-&gt;zType = &quot;table&quot;;</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if( pCur-&gt;zName==0 ){</span>
<span class="udiff-line-added">+           for(k=sqliteHashFirst(&amp;pSchema-&gt;idxHash); k; k=sqliteHashNext(k)){</span>
<span class="udiff-line-added">+             Index *pIdx = (Index*)sqliteHashData(k);</span>
<span class="udiff-line-added">+             if( pIdx-&gt;tnum==iRoot ){</span>
<span class="udiff-line-added">+               pCur-&gt;zName = pIdx-&gt;zName;</span>
<span class="udiff-line-added">+               pCur-&gt;zType = &quot;index&quot;;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       i += 10;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   switch( i ){</span>
<span class="udiff-line-added">+     case 0:   /* addr */</span>
<span class="udiff-line-added">+       sqlite3_result_int(ctx, pCur-&gt;iAddr);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case 1:   /* opcode */</span>
<span class="udiff-line-added">+       sqlite3_result_text(ctx, (char*)sqlite3OpcodeName(pOp-&gt;opcode),</span>
<span class="udiff-line-added">+                           -1, SQLITE_STATIC);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case 2:   /* p1 */</span>
<span class="udiff-line-added">+       sqlite3_result_int(ctx, pOp-&gt;p1);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case 3:   /* p2 */</span>
<span class="udiff-line-added">+       sqlite3_result_int(ctx, pOp-&gt;p2);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case 4:   /* p3 */</span>
<span class="udiff-line-added">+       sqlite3_result_int(ctx, pOp-&gt;p3);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case 5:   /* p4 */</span>
<span class="udiff-line-added">+     case 7:   /* comment */</span>
<span class="udiff-line-added">+       if( pCur-&gt;zP4==0 ){</span>
<span class="udiff-line-added">+         pCur-&gt;zP4 = sqlite3VdbeDisplayP4(pVTab-&gt;db, pOp);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       if( i==5 ){</span>
<span class="udiff-line-added">+         sqlite3_result_text(ctx, pCur-&gt;zP4, -1, SQLITE_STATIC);</span>
<span class="udiff-line-added">+       }else{</span>
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS</span>
<span class="udiff-line-added">+         char *zCom = sqlite3VdbeDisplayComment(pVTab-&gt;db, pOp, pCur-&gt;zP4);</span>
<span class="udiff-line-added">+         sqlite3_result_text(ctx, zCom, -1, sqlite3_free);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case 6:     /* p5 */</span>
<span class="udiff-line-added">+       sqlite3_result_int(ctx, pOp-&gt;p5);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case 8: {   /* subprog */</span>
<span class="udiff-line-added">+       Op *aOp = pCur-&gt;aOp;</span>
<span class="udiff-line-added">+       assert( aOp[0].opcode==OP_Init );</span>
<span class="udiff-line-added">+       assert( aOp[0].p4.z==0 || strncmp(aOp[0].p4.z,&quot;-&quot; &quot;- &quot;,3)==0 );</span>
<span class="udiff-line-added">+       if( pCur-&gt;iRowid==pCur-&gt;iAddr+1 ){</span>
<span class="udiff-line-added">+         break;  /* Result is NULL for the main program */</span>
<span class="udiff-line-added">+       }else if( aOp[0].p4.z!=0 ){</span>
<span class="udiff-line-added">+          sqlite3_result_text(ctx, aOp[0].p4.z+3, -1, SQLITE_STATIC);</span>
<span class="udiff-line-added">+       }else{</span>
<span class="udiff-line-added">+          sqlite3_result_text(ctx, &quot;(FK)&quot;, 4, SQLITE_STATIC);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     case 10:  /* tables_used.type */</span>
<span class="udiff-line-added">+       sqlite3_result_text(ctx, pCur-&gt;zType, -1, SQLITE_STATIC);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case 11:  /* tables_used.schema */</span>
<span class="udiff-line-added">+       sqlite3_result_text(ctx, pCur-&gt;zSchema, -1, SQLITE_STATIC);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case 12:  /* tables_used.name */</span>
<span class="udiff-line-added">+       sqlite3_result_text(ctx, pCur-&gt;zName, -1, SQLITE_STATIC);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case 13:  /* tables_used.wr */</span>
<span class="udiff-line-added">+       sqlite3_result_int(ctx, pOp-&gt;opcode==OP_OpenWrite);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return SQLITE_OK;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Return the rowid for the current row.  In this implementation, the</span>
<span class="udiff-line-added">+ ** rowid is the same as the output value.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static int bytecodevtabRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){</span>
<span class="udiff-line-added">+   bytecodevtab_cursor *pCur = (bytecodevtab_cursor*)cur;</span>
<span class="udiff-line-added">+   *pRowid = pCur-&gt;iRowid;</span>
<span class="udiff-line-added">+   return SQLITE_OK;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Initialize a cursor.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ **    idxNum==0     means show all subprograms</span>
<span class="udiff-line-added">+ **    idxNum==1     means show only the main bytecode and omit subprograms.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static int bytecodevtabFilter(</span>
<span class="udiff-line-added">+   sqlite3_vtab_cursor *pVtabCursor,</span>
<span class="udiff-line-added">+   int idxNum, const char *idxStr,</span>
<span class="udiff-line-added">+   int argc, sqlite3_value **argv</span>
<span class="udiff-line-added">+ ){</span>
<span class="udiff-line-added">+   bytecodevtab_cursor *pCur = (bytecodevtab_cursor *)pVtabCursor;</span>
<span class="udiff-line-added">+   bytecodevtab *pVTab = (bytecodevtab *)pVtabCursor-&gt;pVtab;</span>
<span class="udiff-line-added">+   int rc = SQLITE_OK;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bytecodevtabCursorClear(pCur);</span>
<span class="udiff-line-added">+   pCur-&gt;iRowid = 0;</span>
<span class="udiff-line-added">+   pCur-&gt;iAddr = 0;</span>
<span class="udiff-line-added">+   pCur-&gt;showSubprograms = idxNum==0;</span>
<span class="udiff-line-added">+   assert( argc==1 );</span>
<span class="udiff-line-added">+   if( sqlite3_value_type(argv[0])==SQLITE_TEXT ){</span>
<span class="udiff-line-added">+     const char *zSql = (const char*)sqlite3_value_text(argv[0]);</span>
<span class="udiff-line-added">+     if( zSql==0 ){</span>
<span class="udiff-line-added">+       rc = SQLITE_NOMEM;</span>
<span class="udiff-line-added">+     }else{</span>
<span class="udiff-line-added">+       rc = sqlite3_prepare_v2(pVTab-&gt;db, zSql, -1, &amp;pCur-&gt;pStmt, 0);</span>
<span class="udiff-line-added">+       pCur-&gt;needFinalize = 1;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }else{</span>
<span class="udiff-line-added">+     pCur-&gt;pStmt = (sqlite3_stmt*)sqlite3_value_pointer(argv[0],&quot;stmt-pointer&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if( pCur-&gt;pStmt==0 ){</span>
<span class="udiff-line-added">+     pVTab-&gt;base.zErrMsg = sqlite3_mprintf(</span>
<span class="udiff-line-added">+        &quot;argument to %s() is not a valid SQL statement&quot;,</span>
<span class="udiff-line-added">+        pVTab-&gt;bTablesUsed ? &quot;tables_used&quot; : &quot;bytecode&quot;</span>
<span class="udiff-line-added">+     );</span>
<span class="udiff-line-added">+     rc = SQLITE_ERROR;</span>
<span class="udiff-line-added">+   }else{</span>
<span class="udiff-line-added">+     bytecodevtabNext(pVtabCursor);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return rc;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** We must have a single stmt=? constraint that will be passed through</span>
<span class="udiff-line-added">+ ** into the xFilter method.  If there is no valid stmt=? constraint,</span>
<span class="udiff-line-added">+ ** then return an SQLITE_CONSTRAINT error.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static int bytecodevtabBestIndex(</span>
<span class="udiff-line-added">+   sqlite3_vtab *tab,</span>
<span class="udiff-line-added">+   sqlite3_index_info *pIdxInfo</span>
<span class="udiff-line-added">+ ){</span>
<span class="udiff-line-added">+   int i;</span>
<span class="udiff-line-added">+   int rc = SQLITE_CONSTRAINT;</span>
<span class="udiff-line-added">+   struct sqlite3_index_constraint *p;</span>
<span class="udiff-line-added">+   bytecodevtab *pVTab = (bytecodevtab*)tab;</span>
<span class="udiff-line-added">+   int iBaseCol = pVTab-&gt;bTablesUsed ? 4 : 8;</span>
<span class="udiff-line-added">+   pIdxInfo-&gt;estimatedCost = (double)100;</span>
<span class="udiff-line-added">+   pIdxInfo-&gt;estimatedRows = 100;</span>
<span class="udiff-line-added">+   pIdxInfo-&gt;idxNum = 0;</span>
<span class="udiff-line-added">+   for(i=0, p=pIdxInfo-&gt;aConstraint; i&lt;pIdxInfo-&gt;nConstraint; i++, p++){</span>
<span class="udiff-line-added">+     if( p-&gt;usable==0 ) continue;</span>
<span class="udiff-line-added">+     if( p-&gt;op==SQLITE_INDEX_CONSTRAINT_EQ &amp;&amp; p-&gt;iColumn==iBaseCol+1 ){</span>
<span class="udiff-line-added">+       rc = SQLITE_OK;</span>
<span class="udiff-line-added">+       pIdxInfo-&gt;aConstraintUsage[i].omit = 1;</span>
<span class="udiff-line-added">+       pIdxInfo-&gt;aConstraintUsage[i].argvIndex = 1;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if( p-&gt;op==SQLITE_INDEX_CONSTRAINT_ISNULL &amp;&amp; p-&gt;iColumn==iBaseCol ){</span>
<span class="udiff-line-added">+       pIdxInfo-&gt;aConstraintUsage[i].omit = 1;</span>
<span class="udiff-line-added">+       pIdxInfo-&gt;idxNum = 1;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return rc;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** This following structure defines all the methods for the</span>
<span class="udiff-line-added">+ ** virtual table.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static sqlite3_module bytecodevtabModule = {</span>
<span class="udiff-line-added">+   /* iVersion    */ 0,</span>
<span class="udiff-line-added">+   /* xCreate     */ 0,</span>
<span class="udiff-line-added">+   /* xConnect    */ bytecodevtabConnect,</span>
<span class="udiff-line-added">+   /* xBestIndex  */ bytecodevtabBestIndex,</span>
<span class="udiff-line-added">+   /* xDisconnect */ bytecodevtabDisconnect,</span>
<span class="udiff-line-added">+   /* xDestroy    */ 0,</span>
<span class="udiff-line-added">+   /* xOpen       */ bytecodevtabOpen,</span>
<span class="udiff-line-added">+   /* xClose      */ bytecodevtabClose,</span>
<span class="udiff-line-added">+   /* xFilter     */ bytecodevtabFilter,</span>
<span class="udiff-line-added">+   /* xNext       */ bytecodevtabNext,</span>
<span class="udiff-line-added">+   /* xEof        */ bytecodevtabEof,</span>
<span class="udiff-line-added">+   /* xColumn     */ bytecodevtabColumn,</span>
<span class="udiff-line-added">+   /* xRowid      */ bytecodevtabRowid,</span>
<span class="udiff-line-added">+   /* xUpdate     */ 0,</span>
<span class="udiff-line-added">+   /* xBegin      */ 0,</span>
<span class="udiff-line-added">+   /* xSync       */ 0,</span>
<span class="udiff-line-added">+   /* xCommit     */ 0,</span>
<span class="udiff-line-added">+   /* xRollback   */ 0,</span>
<span class="udiff-line-added">+   /* xFindMethod */ 0,</span>
<span class="udiff-line-added">+   /* xRename     */ 0,</span>
<span class="udiff-line-added">+   /* xSavepoint  */ 0,</span>
<span class="udiff-line-added">+   /* xRelease    */ 0,</span>
<span class="udiff-line-added">+   /* xRollbackTo */ 0,</span>
<span class="udiff-line-added">+   /* xShadowName */ 0</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ SQLITE_PRIVATE int sqlite3VdbeBytecodeVtabInit(sqlite3 *db){</span>
<span class="udiff-line-added">+   int rc;</span>
<span class="udiff-line-added">+   rc = sqlite3_create_module(db, &quot;bytecode&quot;, &amp;bytecodevtabModule, 0);</span>
<span class="udiff-line-added">+   if( rc==SQLITE_OK ){</span>
<span class="udiff-line-added">+     rc = sqlite3_create_module(db, &quot;tables_used&quot;, &amp;bytecodevtabModule, &amp;db);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return rc;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #elif defined(SQLITE_ENABLE_BYTECODE_VTAB)</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE int sqlite3VdbeBytecodeVtabInit(sqlite3 *db){ return SQLITE_OK; }</span>
<span class="udiff-line-added">+ #endif /* SQLITE_ENABLE_BYTECODE_VTAB */</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /************** End of vdbevtab.c ********************************************/</span>
  /************** Begin file memjournal.c **************************************/
  /*
  ** 2008 October 7
  **
  ** The author disclaims copyright to this source code.  In place of
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -96708,19 +97447,20 @@</span>
    SrcList *pSrc;
    int i;
    struct SrcList_item *pItem;
  
    pSrc = p-&gt;pSrc;
<span class="udiff-line-modified-removed">-   assert( pSrc!=0 );</span>
<span class="udiff-line-modified-removed">-   for(i=pSrc-&gt;nSrc, pItem=pSrc-&gt;a; i&gt;0; i--, pItem++){</span>
<span class="udiff-line-modified-removed">-     if( pItem-&gt;pSelect &amp;&amp; sqlite3WalkSelect(pWalker, pItem-&gt;pSelect) ){</span>
<span class="udiff-line-modified-removed">-       return WRC_Abort;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">-     if( pItem-&gt;fg.isTabFunc</span>
<span class="udiff-line-modified-removed">-      &amp;&amp; sqlite3WalkExprList(pWalker, pItem-&gt;u1.pFuncArg)</span>
<span class="udiff-line-modified-removed">-     ){</span>
<span class="udiff-line-modified-removed">-       return WRC_Abort;</span>
<span class="udiff-line-modified-added">+   if( pSrc ){</span>
<span class="udiff-line-modified-added">+     for(i=pSrc-&gt;nSrc, pItem=pSrc-&gt;a; i&gt;0; i--, pItem++){</span>
<span class="udiff-line-modified-added">+       if( pItem-&gt;pSelect &amp;&amp; sqlite3WalkSelect(pWalker, pItem-&gt;pSelect) ){</span>
<span class="udiff-line-modified-added">+         return WRC_Abort;</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+       if( pItem-&gt;fg.isTabFunc</span>
<span class="udiff-line-modified-added">+        &amp;&amp; sqlite3WalkExprList(pWalker, pItem-&gt;u1.pFuncArg)</span>
<span class="udiff-line-modified-added">+       ){</span>
<span class="udiff-line-modified-added">+         return WRC_Abort;</span>
<span class="udiff-line-added">+       }</span>
      }
    }
    return WRC_Continue;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -96759,10 +97499,47 @@</span>
      p = p-&gt;pPrior;
    }while( p!=0 );
    return WRC_Continue;
  }
  
<span class="udiff-line-added">+ /* Increase the walkerDepth when entering a subquery, and</span>
<span class="udiff-line-added">+ ** descrease when leaving the subquery.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE int sqlite3WalkerDepthIncrease(Walker *pWalker, Select *pSelect){</span>
<span class="udiff-line-added">+   UNUSED_PARAMETER(pSelect);</span>
<span class="udiff-line-added">+   pWalker-&gt;walkerDepth++;</span>
<span class="udiff-line-added">+   return WRC_Continue;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE void sqlite3WalkerDepthDecrease(Walker *pWalker, Select *pSelect){</span>
<span class="udiff-line-added">+   UNUSED_PARAMETER(pSelect);</span>
<span class="udiff-line-added">+   pWalker-&gt;walkerDepth--;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** No-op routine for the parse-tree walker.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** When this routine is the Walker.xExprCallback then expression trees</span>
<span class="udiff-line-added">+ ** are walked without any actions being taken at each node.  Presumably,</span>
<span class="udiff-line-added">+ ** when this routine is used for Walker.xExprCallback then</span>
<span class="udiff-line-added">+ ** Walker.xSelectCallback is set to do something useful for every</span>
<span class="udiff-line-added">+ ** subquery in the parser tree.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE int sqlite3ExprWalkNoop(Walker *NotUsed, Expr *NotUsed2){</span>
<span class="udiff-line-added">+   UNUSED_PARAMETER2(NotUsed, NotUsed2);</span>
<span class="udiff-line-added">+   return WRC_Continue;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** No-op routine for the parse-tree walker for SELECT statements.</span>
<span class="udiff-line-added">+ ** subquery in the parser tree.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE int sqlite3SelectWalkNoop(Walker *NotUsed, Select *NotUsed2){</span>
<span class="udiff-line-added">+   UNUSED_PARAMETER2(NotUsed, NotUsed2);</span>
<span class="udiff-line-added">+   return WRC_Continue;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /************** End of walker.c **********************************************/
  /************** Begin file resolve.c *****************************************/
  /*
  ** 2008 August 18
  **
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -96787,10 +97564,12 @@</span>
  ** This needs to occur when copying a TK_AGG_FUNCTION node from an
  ** outer query into an inner subquery.
  **
  ** incrAggFunctionDepth(pExpr,n) is the main routine.  incrAggDepth(..)
  ** is a helper function - a callback for the tree walker.
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** See also the sqlite3WindowExtraAggFuncDepth() routine in window.c</span>
  */
  static int incrAggDepth(Walker *pWalker, Expr *pExpr){
    if( pExpr-&gt;op==TK_AGG_FUNCTION ) pExpr-&gt;op2 += pWalker-&gt;u.n;
    return WRC_Continue;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -96903,11 +97682,11 @@</span>
    const char *zTab,
    const char *zDb
  ){
    int n;
    const char *zSpan;
<span class="udiff-line-modified-removed">-   if( NEVER(pItem-&gt;eEName!=ENAME_TAB) ) return 0;</span>
<span class="udiff-line-modified-added">+   if( pItem-&gt;eEName!=ENAME_TAB ) return 0;</span>
    zSpan = pItem-&gt;zEName;
    for(n=0; ALWAYS(zSpan[n]) &amp;&amp; zSpan[n]!=&#39;.&#39;; n++){}
    if( zDb &amp;&amp; (sqlite3StrNICmp(zSpan, zDb, n)!=0 || zDb[n]!=0) ){
      return 0;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -96938,10 +97717,35 @@</span>
      /* Currently parsing a DML statement */
      return (db-&gt;flags &amp; SQLITE_DqsDML)!=0;
    }
  }
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** The argument is guaranteed to be a non-NULL Expr node of type TK_COLUMN.</span>
<span class="udiff-line-added">+ ** return the appropriate colUsed mask.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE Bitmask sqlite3ExprColUsed(Expr *pExpr){</span>
<span class="udiff-line-added">+   int n;</span>
<span class="udiff-line-added">+   Table *pExTab;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   n = pExpr-&gt;iColumn;</span>
<span class="udiff-line-added">+   pExTab = pExpr-&gt;y.pTab;</span>
<span class="udiff-line-added">+   assert( pExTab!=0 );</span>
<span class="udiff-line-added">+   if( (pExTab-&gt;tabFlags &amp; TF_HasGenerated)!=0</span>
<span class="udiff-line-added">+    &amp;&amp; (pExTab-&gt;aCol[n].colFlags &amp; COLFLAG_GENERATED)!=0</span>
<span class="udiff-line-added">+   ){</span>
<span class="udiff-line-added">+     testcase( pExTab-&gt;nCol==BMS-1 );</span>
<span class="udiff-line-added">+     testcase( pExTab-&gt;nCol==BMS );</span>
<span class="udiff-line-added">+     return pExTab-&gt;nCol&gt;=BMS ? ALLBITS : MASKBIT(pExTab-&gt;nCol)-1;</span>
<span class="udiff-line-added">+   }else{</span>
<span class="udiff-line-added">+     testcase( n==BMS-1 );</span>
<span class="udiff-line-added">+     testcase( n==BMS );</span>
<span class="udiff-line-added">+     if( n&gt;=BMS ) n = BMS-1;</span>
<span class="udiff-line-added">+     return ((Bitmask)1)&lt;&lt;n;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /*
  ** Given the name of a column of the form X.Y.Z or Y.Z or just Z, look up
  ** that name in the set of source tables in pSrcList and make the pExpr
  ** expression node refer back to that source column.  The following changes
  ** are made to pExpr:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -97015,10 +97819,16 @@</span>
          if( sqlite3StrICmp(db-&gt;aDb[i].zDbSName,zDb)==0 ){
            pSchema = db-&gt;aDb[i].pSchema;
            break;
          }
        }
<span class="udiff-line-added">+       if( i==db-&gt;nDb &amp;&amp; sqlite3StrICmp(&quot;main&quot;, zDb)==0 ){</span>
<span class="udiff-line-added">+         /* This branch is taken when the main database has been renamed</span>
<span class="udiff-line-added">+         ** using SQLITE_DBCONFIG_MAINDBNAME. */</span>
<span class="udiff-line-added">+         pSchema = db-&gt;aDb[0].pSchema;</span>
<span class="udiff-line-added">+         zDb = db-&gt;aDb[0].zDbSName;</span>
<span class="udiff-line-added">+       }</span>
      }
    }
  
    /* Start at the inner-most context and move outward until a match is found */
    assert( pNC &amp;&amp; cnt==0 );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -97026,10 +97836,11 @@</span>
      ExprList *pEList;
      SrcList *pSrcList = pNC-&gt;pSrcList;
  
      if( pSrcList ){
        for(i=0, pItem=pSrcList-&gt;a; i&lt;pSrcList-&gt;nSrc; i++, pItem++){
<span class="udiff-line-added">+         u8 hCol;</span>
          pTab = pItem-&gt;pTab;
          assert( pTab!=0 &amp;&amp; pTab-&gt;zName!=0 );
          assert( pTab-&gt;nCol&gt;0 );
          if( pItem-&gt;pSelect &amp;&amp; (pItem-&gt;pSelect-&gt;selFlags &amp; SF_NestedFrom)!=0 ){
            int hit = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -97059,12 +97870,13 @@</span>
            }
          }
          if( 0==(cntTab++) ){
            pMatch = pItem;
          }
<span class="udiff-line-added">+         hCol = sqlite3StrIHash(zCol);</span>
          for(j=0, pCol=pTab-&gt;aCol; j&lt;pTab-&gt;nCol; j++, pCol++){
<span class="udiff-line-modified-removed">-           if( sqlite3StrICmp(pCol-&gt;zName, zCol)==0 ){</span>
<span class="udiff-line-modified-added">+           if( pCol-&gt;hName==hCol &amp;&amp; sqlite3StrICmp(pCol-&gt;zName, zCol)==0 ){</span>
              /* If there has been exactly one prior match and this match
              ** is for the right-hand table of a NATURAL JOIN or is in a
              ** USING clause, then skip this match.
              */
              if( cnt==1 ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -97121,14 +97933,15 @@</span>
        }
  #endif /* SQLITE_OMIT_UPSERT */
  
        if( pTab ){
          int iCol;
<span class="udiff-line-added">+         u8 hCol = sqlite3StrIHash(zCol);</span>
          pSchema = pTab-&gt;pSchema;
          cntTab++;
          for(iCol=0, pCol=pTab-&gt;aCol; iCol&lt;pTab-&gt;nCol; iCol++, pCol++){
<span class="udiff-line-modified-removed">-           if( sqlite3StrICmp(pCol-&gt;zName, zCol)==0 ){</span>
<span class="udiff-line-modified-added">+           if( pCol-&gt;hName==hCol &amp;&amp; sqlite3StrICmp(pCol-&gt;zName, zCol)==0 ){</span>
              if( iCol==pTab-&gt;iPKey ){
                iCol = -1;
              }
              break;
            }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -97334,26 +98147,11 @@</span>
    **
    ** If a generated column is referenced, set bits for every column
    ** of the table.
    */
    if( pExpr-&gt;iColumn&gt;=0 &amp;&amp; pMatch!=0 ){
<span class="udiff-line-modified-removed">-     int n = pExpr-&gt;iColumn;</span>
<span class="udiff-line-removed">-     Table *pExTab = pExpr-&gt;y.pTab;</span>
<span class="udiff-line-removed">-     assert( pExTab!=0 );</span>
<span class="udiff-line-removed">-     assert( pMatch-&gt;iCursor==pExpr-&gt;iTable );</span>
<span class="udiff-line-removed">-     if( (pExTab-&gt;tabFlags &amp; TF_HasGenerated)!=0</span>
<span class="udiff-line-removed">-      &amp;&amp; (pExTab-&gt;aCol[n].colFlags &amp; COLFLAG_GENERATED)!=0</span>
<span class="udiff-line-removed">-     ){</span>
<span class="udiff-line-removed">-       testcase( pExTab-&gt;nCol==BMS-1 );</span>
<span class="udiff-line-removed">-       testcase( pExTab-&gt;nCol==BMS );</span>
<span class="udiff-line-removed">-       pMatch-&gt;colUsed = pExTab-&gt;nCol&gt;=BMS ? ALLBITS : MASKBIT(pExTab-&gt;nCol)-1;</span>
<span class="udiff-line-removed">-     }else{</span>
<span class="udiff-line-removed">-       testcase( n==BMS-1 );</span>
<span class="udiff-line-removed">-       testcase( n==BMS );</span>
<span class="udiff-line-removed">-       if( n&gt;=BMS ) n = BMS-1;</span>
<span class="udiff-line-removed">-       pMatch-&gt;colUsed |= ((Bitmask)1)&lt;&lt;n;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     pMatch-&gt;colUsed |= sqlite3ExprColUsed(pExpr);</span>
    }
  
    /* Clean up and return
    */
    sqlite3ExprDelete(db, pExpr-&gt;pLeft);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -97814,11 +98612,11 @@</span>
      case TK_ISNOT: {
        Expr *pRight = sqlite3ExprSkipCollateAndLikely(pExpr-&gt;pRight);
        assert( !ExprHasProperty(pExpr, EP_Reduced) );
        /* Handle special cases of &quot;x IS TRUE&quot;, &quot;x IS FALSE&quot;, &quot;x IS NOT TRUE&quot;,
        ** and &quot;x IS NOT FALSE&quot;. */
<span class="udiff-line-modified-removed">-       if( pRight-&gt;op==TK_ID ){</span>
<span class="udiff-line-modified-added">+       if( pRight &amp;&amp; pRight-&gt;op==TK_ID ){</span>
          int rc = resolveExprStep(pWalker, pRight);
          if( rc==WRC_Abort ) return WRC_Abort;
          if( pRight-&gt;op==TK_TRUEFALSE ){
            pExpr-&gt;op2 = pExpr-&gt;op;
            pExpr-&gt;op = TK_TRUTH;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -97940,11 +98738,11 @@</span>
    nc.uNC.pEList = pEList;
    nc.ncFlags = NC_AllowAgg|NC_UEList;
    nc.nErr = 0;
    db = pParse-&gt;db;
    savedSuppErr = db-&gt;suppressErr;
<span class="udiff-line-modified-removed">-   db-&gt;suppressErr = 1;</span>
<span class="udiff-line-modified-added">+   if( IN_RENAME_OBJECT==0 ) db-&gt;suppressErr = 1;</span>
    rc = sqlite3ResolveExprNames(&amp;nc, pE);
    db-&gt;suppressErr = savedSuppErr;
    if( rc ) return 0;
  
    /* Try to match the ORDER BY expression against an expression
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -98575,15 +99373,45 @@</span>
  SQLITE_PRIVATE int sqlite3ResolveExprListNames(
    NameContext *pNC,       /* Namespace to resolve expressions in. */
    ExprList *pList         /* The expression list to be analyzed. */
  ){
    int i;
<span class="udiff-line-modified-removed">-   if( pList ){</span>
<span class="udiff-line-modified-removed">-     for(i=0; i&lt;pList-&gt;nExpr; i++){</span>
<span class="udiff-line-modified-removed">-       if( sqlite3ResolveExprNames(pNC, pList-&gt;a[i].pExpr) ) return WRC_Abort;</span>
<span class="udiff-line-modified-added">+   int savedHasAgg = 0;</span>
<span class="udiff-line-modified-added">+   Walker w;</span>
<span class="udiff-line-modified-added">+   if( pList==0 ) return WRC_Continue;</span>
<span class="udiff-line-added">+   w.pParse = pNC-&gt;pParse;</span>
<span class="udiff-line-added">+   w.xExprCallback = resolveExprStep;</span>
<span class="udiff-line-added">+   w.xSelectCallback = resolveSelectStep;</span>
<span class="udiff-line-added">+   w.xSelectCallback2 = 0;</span>
<span class="udiff-line-added">+   w.u.pNC = pNC;</span>
<span class="udiff-line-added">+   savedHasAgg = pNC-&gt;ncFlags &amp; (NC_HasAgg|NC_MinMaxAgg|NC_HasWin);</span>
<span class="udiff-line-added">+   pNC-&gt;ncFlags &amp;= ~(NC_HasAgg|NC_MinMaxAgg|NC_HasWin);</span>
<span class="udiff-line-added">+   for(i=0; i&lt;pList-&gt;nExpr; i++){</span>
<span class="udiff-line-added">+     Expr *pExpr = pList-&gt;a[i].pExpr;</span>
<span class="udiff-line-added">+     if( pExpr==0 ) continue;</span>
<span class="udiff-line-added">+ #if SQLITE_MAX_EXPR_DEPTH&gt;0</span>
<span class="udiff-line-added">+     w.pParse-&gt;nHeight += pExpr-&gt;nHeight;</span>
<span class="udiff-line-added">+     if( sqlite3ExprCheckHeight(w.pParse, w.pParse-&gt;nHeight) ){</span>
<span class="udiff-line-added">+       return WRC_Abort;</span>
      }
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     sqlite3WalkExpr(&amp;w, pExpr);</span>
<span class="udiff-line-added">+ #if SQLITE_MAX_EXPR_DEPTH&gt;0</span>
<span class="udiff-line-added">+     w.pParse-&gt;nHeight -= pExpr-&gt;nHeight;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     assert( EP_Agg==NC_HasAgg );</span>
<span class="udiff-line-added">+     assert( EP_Win==NC_HasWin );</span>
<span class="udiff-line-added">+     testcase( pNC-&gt;ncFlags &amp; NC_HasAgg );</span>
<span class="udiff-line-added">+     testcase( pNC-&gt;ncFlags &amp; NC_HasWin );</span>
<span class="udiff-line-added">+     if( pNC-&gt;ncFlags &amp; (NC_HasAgg|NC_MinMaxAgg|NC_HasWin) ){</span>
<span class="udiff-line-added">+       ExprSetProperty(pExpr, pNC-&gt;ncFlags &amp; (NC_HasAgg|NC_HasWin) );</span>
<span class="udiff-line-added">+       savedHasAgg |= pNC-&gt;ncFlags &amp; (NC_HasAgg|NC_MinMaxAgg|NC_HasWin);</span>
<span class="udiff-line-added">+       pNC-&gt;ncFlags &amp;= ~(NC_HasAgg|NC_MinMaxAgg|NC_HasWin);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if( pNC-&gt;nErr&gt;0 || w.pParse-&gt;nErr&gt;0 ) return WRC_Abort;</span>
    }
<span class="udiff-line-added">+   pNC-&gt;ncFlags |= savedHasAgg;</span>
    return WRC_Continue;
  }
  
  /*
  ** Resolve all names in all expressions of a SELECT and in all
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -98710,21 +99538,26 @@</span>
  ** CREATE TABLE t1(a);
  ** SELECT * FROM t1 WHERE a;
  ** SELECT a AS b FROM t1 WHERE b;
  ** SELECT * FROM t1 WHERE (select a from t1);
  */
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE char sqlite3ExprAffinity(Expr *pExpr){</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE char sqlite3ExprAffinity(const Expr *pExpr){</span>
    int op;
    while( ExprHasProperty(pExpr, EP_Skip) ){
<span class="udiff-line-modified-removed">-     assert( pExpr-&gt;op==TK_COLLATE );</span>
<span class="udiff-line-modified-added">+     assert( pExpr-&gt;op==TK_COLLATE || pExpr-&gt;op==TK_IF_NULL_ROW );</span>
      pExpr = pExpr-&gt;pLeft;
      assert( pExpr!=0 );
    }
    op = pExpr-&gt;op;
    if( op==TK_SELECT ){
      assert( pExpr-&gt;flags&amp;EP_xIsSelect );
<span class="udiff-line-modified-removed">-     return sqlite3ExprAffinity(pExpr-&gt;x.pSelect-&gt;pEList-&gt;a[0].pExpr);</span>
<span class="udiff-line-modified-added">+     if( ALWAYS(pExpr-&gt;x.pSelect)</span>
<span class="udiff-line-added">+      &amp;&amp; pExpr-&gt;x.pSelect-&gt;pEList</span>
<span class="udiff-line-added">+      &amp;&amp; ALWAYS(pExpr-&gt;x.pSelect-&gt;pEList-&gt;a[0].pExpr)</span>
<span class="udiff-line-added">+     ){</span>
<span class="udiff-line-added">+       return sqlite3ExprAffinity(pExpr-&gt;x.pSelect-&gt;pEList-&gt;a[0].pExpr);</span>
<span class="udiff-line-added">+     }</span>
    }
    if( op==TK_REGISTER ) op = pExpr-&gt;op2;
  #ifndef SQLITE_OMIT_CAST
    if( op==TK_CAST ){
      assert( !ExprHasProperty(pExpr, EP_IntValue) );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -98780,11 +99613,11 @@</span>
  /*
  ** Skip over any TK_COLLATE operators.
  */
  SQLITE_PRIVATE Expr *sqlite3ExprSkipCollate(Expr *pExpr){
    while( pExpr &amp;&amp; ExprHasProperty(pExpr, EP_Skip) ){
<span class="udiff-line-modified-removed">-     assert( pExpr-&gt;op==TK_COLLATE );</span>
<span class="udiff-line-modified-added">+     assert( pExpr-&gt;op==TK_COLLATE || pExpr-&gt;op==TK_IF_NULL_ROW );</span>
      pExpr = pExpr-&gt;pLeft;
    }
    return pExpr;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -98799,11 +99632,11 @@</span>
        assert( !ExprHasProperty(pExpr, EP_xIsSelect) );
        assert( pExpr-&gt;x.pList-&gt;nExpr&gt;0 );
        assert( pExpr-&gt;op==TK_FUNCTION );
        pExpr = pExpr-&gt;x.pList-&gt;a[0].pExpr;
      }else{
<span class="udiff-line-modified-removed">-       assert( pExpr-&gt;op==TK_COLLATE );</span>
<span class="udiff-line-modified-added">+       assert( pExpr-&gt;op==TK_COLLATE || pExpr-&gt;op==TK_IF_NULL_ROW );</span>
        pExpr = pExpr-&gt;pLeft;
      }
    }
    return pExpr;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -98820,14 +99653,14 @@</span>
  ** The collating sequence might be determined by a COLLATE operator
  ** or by the presence of a column with a defined collating sequence.
  ** COLLATE operators take first precedence.  Left operands take
  ** precedence over right operands.
  */
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr){</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE CollSeq *sqlite3ExprCollSeq(Parse *pParse, const Expr *pExpr){</span>
    sqlite3 *db = pParse-&gt;db;
    CollSeq *pColl = 0;
<span class="udiff-line-modified-removed">-   Expr *p = pExpr;</span>
<span class="udiff-line-modified-added">+   const Expr *p = pExpr;</span>
    while( p ){
      int op = p-&gt;op;
      if( op==TK_REGISTER ) op = p-&gt;op2;
      if( (op==TK_AGG_COLUMN || op==TK_COLUMN || op==TK_TRIGGER)
       &amp;&amp; p-&gt;y.pTab!=0
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -98892,32 +99725,32 @@</span>
  ** See also: sqlite3ExprCollSeq()
  **
  ** The sqlite3ExprCollSeq() routine works the same except that it
  ** returns NULL if there is no defined collation.
  */
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE CollSeq *sqlite3ExprNNCollSeq(Parse *pParse, Expr *pExpr){</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE CollSeq *sqlite3ExprNNCollSeq(Parse *pParse, const Expr *pExpr){</span>
    CollSeq *p = sqlite3ExprCollSeq(pParse, pExpr);
    if( p==0 ) p = pParse-&gt;db-&gt;pDfltColl;
    assert( p!=0 );
    return p;
  }
  
  /*
  ** Return TRUE if the two expressions have equivalent collating sequences.
  */
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE int sqlite3ExprCollSeqMatch(Parse *pParse, Expr *pE1, Expr *pE2){</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE int sqlite3ExprCollSeqMatch(Parse *pParse, const Expr *pE1, const Expr *pE2){</span>
    CollSeq *pColl1 = sqlite3ExprNNCollSeq(pParse, pE1);
    CollSeq *pColl2 = sqlite3ExprNNCollSeq(pParse, pE2);
    return sqlite3StrICmp(pColl1-&gt;zName, pColl2-&gt;zName)==0;
  }
  
  /*
  ** pExpr is an operand of a comparison operator.  aff2 is the
  ** type affinity of the other operand.  This routine returns the
  ** type affinity that should be used for the comparison operator.
  */
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE char sqlite3CompareAffinity(Expr *pExpr, char aff2){</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE char sqlite3CompareAffinity(const Expr *pExpr, char aff2){</span>
    char aff1 = sqlite3ExprAffinity(pExpr);
    if( aff1&gt;SQLITE_AFF_NONE &amp;&amp; aff2&gt;SQLITE_AFF_NONE ){
      /* Both sides of the comparison are columns. If one has numeric
      ** affinity, use that. Otherwise use no affinity.
      */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -98935,11 +99768,11 @@</span>
  
  /*
  ** pExpr is a comparison operator.  Return the type affinity that should
  ** be applied to both operands prior to doing the comparison.
  */
<span class="udiff-line-modified-removed">- static char comparisonAffinity(Expr *pExpr){</span>
<span class="udiff-line-modified-added">+ static char comparisonAffinity(const Expr *pExpr){</span>
    char aff;
    assert( pExpr-&gt;op==TK_EQ || pExpr-&gt;op==TK_IN || pExpr-&gt;op==TK_LT ||
            pExpr-&gt;op==TK_GT || pExpr-&gt;op==TK_GE || pExpr-&gt;op==TK_LE ||
            pExpr-&gt;op==TK_NE || pExpr-&gt;op==TK_IS || pExpr-&gt;op==TK_ISNOT );
    assert( pExpr-&gt;pLeft );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -98958,11 +99791,11 @@</span>
  ** pExpr is a comparison expression, eg. &#39;=&#39;, &#39;&lt;&#39;, IN(...) etc.
  ** idx_affinity is the affinity of an indexed column. Return true
  ** if the index with affinity idx_affinity may be used to implement
  ** the comparison in pExpr.
  */
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE int sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity){</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE int sqlite3IndexAffinityOk(const Expr *pExpr, char idx_affinity){</span>
    char aff = comparisonAffinity(pExpr);
    if( aff&lt;SQLITE_AFF_TEXT ){
      return 1;
    }
    if( aff==SQLITE_AFF_TEXT ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -98973,11 +99806,15 @@</span>
  
  /*
  ** Return the P5 value that should be used for a binary comparison
  ** opcode (OP_Eq, OP_Ge etc.) used to compare pExpr1 and pExpr2.
  */
<span class="udiff-line-modified-removed">- static u8 binaryCompareP5(Expr *pExpr1, Expr *pExpr2, int jumpIfNull){</span>
<span class="udiff-line-modified-added">+ static u8 binaryCompareP5(</span>
<span class="udiff-line-added">+   const Expr *pExpr1,   /* Left operand */</span>
<span class="udiff-line-added">+   const Expr *pExpr2,   /* Right operand */</span>
<span class="udiff-line-added">+   int jumpIfNull        /* Extra flags added to P5 */</span>
<span class="udiff-line-added">+ ){</span>
    u8 aff = (char)sqlite3ExprAffinity(pExpr2);
    aff = (u8)sqlite3CompareAffinity(pExpr1, aff) | (u8)jumpIfNull;
    return aff;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -98993,12 +99830,12 @@</span>
  ** Argument pRight (but not pLeft) may be a null pointer. In this case,
  ** it is not considered.
  */
  SQLITE_PRIVATE CollSeq *sqlite3BinaryCompareCollSeq(
    Parse *pParse,
<span class="udiff-line-modified-removed">-   Expr *pLeft,</span>
<span class="udiff-line-modified-removed">-   Expr *pRight</span>
<span class="udiff-line-modified-added">+   const Expr *pLeft,</span>
<span class="udiff-line-modified-added">+   const Expr *pRight</span>
  ){
    CollSeq *pColl;
    assert( pLeft );
    if( pLeft-&gt;flags &amp; EP_Collate ){
      pColl = sqlite3ExprCollSeq(pParse, pLeft);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -99019,11 +99856,11 @@</span>
  ** This is normally just a wrapper around sqlite3BinaryCompareCollSeq().
  ** However, if the OP_Commuted flag is set, then the order of the operands
  ** is reversed in the sqlite3BinaryCompareCollSeq() call so that the
  ** correct collating sequence is found.
  */
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE CollSeq *sqlite3ExprCompareCollSeq(Parse *pParse, Expr *p){</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE CollSeq *sqlite3ExprCompareCollSeq(Parse *pParse, const Expr *p){</span>
    if( ExprHasProperty(p, EP_Commuted) ){
      return sqlite3BinaryCompareCollSeq(pParse, p-&gt;pRight, p-&gt;pLeft);
    }else{
      return sqlite3BinaryCompareCollSeq(pParse, p-&gt;pLeft, p-&gt;pRight);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -99262,10 +100099,11 @@</span>
    int regRight = 0;
    u8 opx = op;
    int addrDone = sqlite3VdbeMakeLabel(pParse);
    int isCommuted = ExprHasProperty(pExpr,EP_Commuted);
  
<span class="udiff-line-added">+   assert( !ExprHasVVAProperty(pExpr,EP_Immutable) );</span>
    if( pParse-&gt;nErr ) return;
    if( nLeft!=sqlite3ExprVectorSize(pRight) ){
      sqlite3ErrorMsg(pParse, &quot;row value misused&quot;);
      return;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -99874,11 +100712,11 @@</span>
      nSize = EXPR_FULLSIZE;
    }else{
      assert( !ExprHasProperty(p, EP_TokenOnly|EP_Reduced) );
      assert( !ExprHasProperty(p, EP_FromJoin) );
      assert( !ExprHasProperty(p, EP_MemToken) );
<span class="udiff-line-modified-removed">-     assert( !ExprHasProperty(p, EP_NoReduce) );</span>
<span class="udiff-line-modified-added">+     assert( !ExprHasVVAProperty(p, EP_NoReduce) );</span>
      if( p-&gt;pLeft || p-&gt;x.pList ){
        nSize = EXPR_REDUCEDSIZE | EP_Reduced;
      }else{
        assert( p-&gt;pRight==0 );
        nSize = EXPR_TOKENONLYSIZE | EP_TokenOnly;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -99979,10 +100817,14 @@</span>
  
      /* Set the EP_Reduced, EP_TokenOnly, and EP_Static flags appropriately. */
      pNew-&gt;flags &amp;= ~(EP_Reduced|EP_TokenOnly|EP_Static|EP_MemToken);
      pNew-&gt;flags |= nStructSize &amp; (EP_Reduced|EP_TokenOnly);
      pNew-&gt;flags |= staticFlag;
<span class="udiff-line-added">+     ExprClearVVAProperties(pNew);</span>
<span class="udiff-line-added">+     if( dupFlags ){</span>
<span class="udiff-line-added">+       ExprSetVVAProperty(pNew, EP_Immutable);</span>
<span class="udiff-line-added">+     }</span>
  
      /* Copy the p-&gt;u.zToken string, if any. */
      if( nToken ){
        char *zToken = pNew-&gt;u.zToken = (char*)&amp;zAlloc[nNewSize];
        memcpy(zToken, p-&gt;u.zToken, nToken);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -100446,20 +101288,26 @@</span>
    ExprList *pList,        /* List to which to add the span. */
    Token *pName,           /* Name to be added */
    int dequote             /* True to cause the name to be dequoted */
  ){
    assert( pList!=0 || pParse-&gt;db-&gt;mallocFailed!=0 );
<span class="udiff-line-added">+   assert( pParse-&gt;eParseMode!=PARSE_MODE_UNMAP || dequote==0 );</span>
    if( pList ){
      struct ExprList_item *pItem;
      assert( pList-&gt;nExpr&gt;0 );
      pItem = &amp;pList-&gt;a[pList-&gt;nExpr-1];
      assert( pItem-&gt;zEName==0 );
      assert( pItem-&gt;eEName==ENAME_NAME );
      pItem-&gt;zEName = sqlite3DbStrNDup(pParse-&gt;db, pName-&gt;z, pName-&gt;n);
<span class="udiff-line-modified-removed">-     if( dequote ) sqlite3Dequote(pItem-&gt;zEName);</span>
<span class="udiff-line-modified-removed">-     if( IN_RENAME_OBJECT ){</span>
<span class="udiff-line-modified-removed">-       sqlite3RenameTokenMap(pParse, (void*)pItem-&gt;zEName, pName);</span>
<span class="udiff-line-modified-added">+     if( dequote ){</span>
<span class="udiff-line-modified-added">+       /* If dequote==0, then pName-&gt;z does not point to part of a DDL</span>
<span class="udiff-line-modified-added">+       ** statement handled by the parser. And so no token need be added</span>
<span class="udiff-line-added">+       ** to the token-map.  */</span>
<span class="udiff-line-added">+       sqlite3Dequote(pItem-&gt;zEName);</span>
<span class="udiff-line-added">+       if( IN_RENAME_OBJECT ){</span>
<span class="udiff-line-added">+         sqlite3RenameTokenMap(pParse, (void*)pItem-&gt;zEName, pName);</span>
<span class="udiff-line-added">+       }</span>
      }
    }
  }
  
  /*
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -100696,12 +101544,14 @@</span>
          return WRC_Continue;
        }
        /* Fall through */
      case TK_IF_NULL_ROW:
      case TK_REGISTER:
<span class="udiff-line-added">+     case TK_DOT:</span>
        testcase( pExpr-&gt;op==TK_REGISTER );
        testcase( pExpr-&gt;op==TK_IF_NULL_ROW );
<span class="udiff-line-added">+       testcase( pExpr-&gt;op==TK_DOT );</span>
        pWalker-&gt;eCode = 0;
        return WRC_Abort;
      case TK_VARIABLE:
        if( pWalker-&gt;eCode==5 ){
          /* Silently convert bound parameters that appear inside of CREATE
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -100755,11 +101605,11 @@</span>
  **   (3) the expression does not contain any EP_FixedCol TK_COLUMN
  **       operands created by the constant propagation optimization.
  **
  ** When this routine returns true, it indicates that the expression
  ** can be added to the pParse-&gt;pConstExpr list and evaluated once when
<span class="udiff-line-modified-removed">- ** the prepared statement starts up.  See sqlite3ExprCodeAtInit().</span>
<span class="udiff-line-modified-added">+ ** the prepared statement starts up.  See sqlite3ExprCodeRunJustOnce().</span>
  */
  SQLITE_PRIVATE int sqlite3ExprIsConstantNotJoin(Expr *p){
    return exprIsConst(p, 2, 0);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -101518,10 +102368,11 @@</span>
        return;
      }
  
      /* Begin coding the subroutine */
      ExprSetProperty(pExpr, EP_Subrtn);
<span class="udiff-line-added">+     assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );</span>
      pExpr-&gt;y.sub.regReturn = ++pParse-&gt;nMem;
      pExpr-&gt;y.sub.iAddr =
        sqlite3VdbeAddOp2(v, OP_Integer, 0, pExpr-&gt;y.sub.regReturn) + 1;
      VdbeComment((v, &quot;return address&quot;));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -101599,10 +102450,12 @@</span>
      struct ExprList_item *pItem;
      int r1, r2;
      affinity = sqlite3ExprAffinity(pLeft);
      if( affinity&lt;=SQLITE_AFF_NONE ){
        affinity = SQLITE_AFF_BLOB;
<span class="udiff-line-added">+     }else if( affinity==SQLITE_AFF_REAL ){</span>
<span class="udiff-line-added">+       affinity = SQLITE_AFF_NUMERIC;</span>
      }
      if( pKeyInfo ){
        assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );
        pKeyInfo-&gt;aColl[0] = sqlite3ExprCollSeq(pParse, pExpr-&gt;pLeft);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -101837,11 +102690,13 @@</span>
    int destStep6 = 0;    /* Start of code for Step 6 */
    int addrTruthOp;      /* Address of opcode that determines the IN is true */
    int destNotNull;      /* Jump here if a comparison is not true in step 6 */
    int addrTop;          /* Top of the step-6 loop */
    int iTab = 0;         /* Index to use */
<span class="udiff-line-added">+   u8 okConstFactor = pParse-&gt;okConstFactor;</span>
  
<span class="udiff-line-added">+   assert( !ExprHasVVAProperty(pExpr,EP_Immutable) );</span>
    pLeft = pExpr-&gt;pLeft;
    if( sqlite3ExprCheckIN(pParse, pExpr) ) return;
    zAff = exprINAffinity(pParse, pExpr);
    nVector = sqlite3ExprVectorSize(pExpr-&gt;pLeft);
    aiMap = (int*)sqlite3DbMallocZero(
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -101880,12 +102735,18 @@</span>
    **
    ** sqlite3FindInIndex() might have reordered the fields of the LHS vector
    ** so that the fields are in the same order as an existing index.   The
    ** aiMap[] array contains a mapping from the original LHS field order to
    ** the field order that matches the RHS index.
<span class="udiff-line-modified-removed">-   */</span>
<span class="udiff-line-modified-added">+   **</span>
<span class="udiff-line-added">+   ** Avoid factoring the LHS of the IN(...) expression out of the loop,</span>
<span class="udiff-line-added">+   ** even if it is constant, as OP_Affinity may be used on the register</span>
<span class="udiff-line-added">+   ** by code generated below.  */</span>
<span class="udiff-line-added">+   assert( pParse-&gt;okConstFactor==okConstFactor );</span>
<span class="udiff-line-added">+   pParse-&gt;okConstFactor = 0;</span>
    rLhsOrig = exprCodeVector(pParse, pLeft, &amp;iDummy);
<span class="udiff-line-added">+   pParse-&gt;okConstFactor = okConstFactor;</span>
    for(i=0; i&lt;nVector &amp;&amp; aiMap[i]==i; i++){} /* Are LHS fields reordered? */
    if( i==nVector ){
      /* LHS fields are not reordered */
      rLhs = rLhsOrig;
    }else{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -101907,25 +102768,17 @@</span>
      CollSeq *pColl = sqlite3ExprCollSeq(pParse, pExpr-&gt;pLeft);
      int labelOk = sqlite3VdbeMakeLabel(pParse);
      int r2, regToFree;
      int regCkNull = 0;
      int ii;
<span class="udiff-line-removed">-     int bLhsReal;  /* True if the LHS of the IN has REAL affinity */</span>
      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );
      if( destIfNull!=destIfFalse ){
        regCkNull = sqlite3GetTempReg(pParse);
        sqlite3VdbeAddOp3(v, OP_BitAnd, rLhs, rLhs, regCkNull);
      }
<span class="udiff-line-removed">-     bLhsReal = sqlite3ExprAffinity(pExpr-&gt;pLeft)==SQLITE_AFF_REAL;</span>
      for(ii=0; ii&lt;pList-&gt;nExpr; ii++){
<span class="udiff-line-modified-removed">-       if( bLhsReal ){</span>
<span class="udiff-line-removed">-         r2 = regToFree = sqlite3GetTempReg(pParse);</span>
<span class="udiff-line-removed">-         sqlite3ExprCode(pParse, pList-&gt;a[ii].pExpr, r2);</span>
<span class="udiff-line-removed">-         sqlite3VdbeAddOp4(v, OP_Affinity, r2, 1, 0, &quot;E&quot;, P4_STATIC);</span>
<span class="udiff-line-removed">-       }else{</span>
<span class="udiff-line-removed">-         r2 = sqlite3ExprCodeTemp(pParse, pList-&gt;a[ii].pExpr, &amp;regToFree);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+       r2 = sqlite3ExprCodeTemp(pParse, pList-&gt;a[ii].pExpr, &amp;regToFree);</span>
        if( regCkNull &amp;&amp; sqlite3ExprCanBeNull(pList-&gt;a[ii].pExpr) ){
          sqlite3VdbeAddOp3(v, OP_BitAnd, regCkNull, r2, regCkNull);
        }
        sqlite3ReleaseTempReg(pParse, regToFree);
        if( ii&lt;pList-&gt;nExpr-1 || destIfNull!=destIfFalse ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -102164,11 +103017,11 @@</span>
    if( pParse-&gt;iSelfTab&gt;0 ){
      iAddr = sqlite3VdbeAddOp3(v, OP_IfNullRow, pParse-&gt;iSelfTab-1, 0, regOut);
    }else{
      iAddr = 0;
    }
<span class="udiff-line-modified-removed">-   sqlite3ExprCode(pParse, pCol-&gt;pDflt, regOut);</span>
<span class="udiff-line-modified-added">+   sqlite3ExprCodeCopy(pParse, pCol-&gt;pDflt, regOut);</span>
    if( pCol-&gt;affinity&gt;=SQLITE_AFF_TEXT ){
      sqlite3VdbeAddOp4(v, OP_Affinity, regOut, 1, 0, &amp;pCol-&gt;affinity, 1);
    }
    if( iAddr ) sqlite3VdbeJumpHere(v, iAddr);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -102305,10 +103158,20 @@</span>
      }
    }
    return iResult;
  }
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** If the last opcode is a OP_Copy, then set the do-not-merge flag (p5)</span>
<span class="udiff-line-added">+ ** so that a subsequent copy will not be merged into this one.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static void setDoNotMergeFlagOnCopy(Vdbe *v){</span>
<span class="udiff-line-added">+   if( sqlite3VdbeGetOp(v, -1)-&gt;opcode==OP_Copy ){</span>
<span class="udiff-line-added">+     sqlite3VdbeChangeP5(v, 1);  /* Tag trailing OP_Copy as not mergable */</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /*
  ** Generate code to implement special SQL functions that are implemented
  ** in-line rather than by using the usual callbacks.
  */
  static int exprCodeInlineFunction(
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -102336,16 +103199,21 @@</span>
        for(i=1; i&lt;nFarg; i++){
          sqlite3VdbeAddOp2(v, OP_NotNull, target, endCoalesce);
          VdbeCoverage(v);
          sqlite3ExprCode(pParse, pFarg-&gt;a[i].pExpr, target);
        }
<span class="udiff-line-modified-removed">-       if( sqlite3VdbeGetOp(v, -1)-&gt;opcode==OP_Copy ){</span>
<span class="udiff-line-removed">-         sqlite3VdbeChangeP5(v, 1);  /* Tag trailing OP_Copy as not mergable */</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+       setDoNotMergeFlagOnCopy(v);</span>
        sqlite3VdbeResolveLabel(v, endCoalesce);
        break;
      }
<span class="udiff-line-added">+     case INLINEFUNC_iif: {</span>
<span class="udiff-line-added">+       Expr caseExpr;</span>
<span class="udiff-line-added">+       memset(&amp;caseExpr, 0, sizeof(caseExpr));</span>
<span class="udiff-line-added">+       caseExpr.op = TK_CASE;</span>
<span class="udiff-line-added">+       caseExpr.x.pList = pFarg;</span>
<span class="udiff-line-added">+       return sqlite3ExprCodeTarget(pParse, &amp;caseExpr, target);</span>
<span class="udiff-line-added">+     }</span>
  
      default: {
        /* The UNLIKELY() function is a no-op.  The result is the value
        ** of the first argument.
        */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -102440,22 +103308,35 @@</span>
  
  expr_code_doover:
    if( pExpr==0 ){
      op = TK_NULL;
    }else{
<span class="udiff-line-added">+     assert( !ExprHasVVAProperty(pExpr,EP_Immutable) );</span>
      op = pExpr-&gt;op;
    }
    switch( op ){
      case TK_AGG_COLUMN: {
        AggInfo *pAggInfo = pExpr-&gt;pAggInfo;
<span class="udiff-line-modified-removed">-       struct AggInfo_col *pCol = &amp;pAggInfo-&gt;aCol[pExpr-&gt;iAgg];</span>
<span class="udiff-line-modified-added">+       struct AggInfo_col *pCol;</span>
<span class="udiff-line-added">+       assert( pAggInfo!=0 );</span>
<span class="udiff-line-added">+       assert( pExpr-&gt;iAgg&gt;=0 &amp;&amp; pExpr-&gt;iAgg&lt;pAggInfo-&gt;nColumn );</span>
<span class="udiff-line-added">+       pCol = &amp;pAggInfo-&gt;aCol[pExpr-&gt;iAgg];</span>
        if( !pAggInfo-&gt;directMode ){
          assert( pCol-&gt;iMem&gt;0 );
          return pCol-&gt;iMem;
        }else if( pAggInfo-&gt;useSortingIdx ){
<span class="udiff-line-added">+         Table *pTab = pCol-&gt;pTab;</span>
          sqlite3VdbeAddOp3(v, OP_Column, pAggInfo-&gt;sortingIdxPTab,
                                pCol-&gt;iSorterColumn, target);
<span class="udiff-line-added">+         if( pCol-&gt;iColumn&lt;0 ){</span>
<span class="udiff-line-added">+           VdbeComment((v,&quot;%s.rowid&quot;,pTab-&gt;zName));</span>
<span class="udiff-line-added">+         }else{</span>
<span class="udiff-line-added">+           VdbeComment((v,&quot;%s.%s&quot;,pTab-&gt;zName,pTab-&gt;aCol[pCol-&gt;iColumn].zName));</span>
<span class="udiff-line-added">+           if( pTab-&gt;aCol[pCol-&gt;iColumn].affinity==SQLITE_AFF_REAL ){</span>
<span class="udiff-line-added">+             sqlite3VdbeAddOp1(v, OP_RealAffinity, target);</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+         }</span>
          return target;
        }
        /* Otherwise, fall thru into the TK_COLUMN case */
      }
      case TK_COLUMN: {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -102477,14 +103358,10 @@</span>
          }
          if( aff&gt;SQLITE_AFF_BLOB ){
            static const char zAff[] = &quot;B\000C\000D\000E&quot;;
            assert( SQLITE_AFF_BLOB==&#39;A&#39; );
            assert( SQLITE_AFF_TEXT==&#39;B&#39; );
<span class="udiff-line-removed">-           if( iReg!=target ){</span>
<span class="udiff-line-removed">-             sqlite3VdbeAddOp2(v, OP_SCopy, iReg, target);</span>
<span class="udiff-line-removed">-             iReg = target;</span>
<span class="udiff-line-removed">-           }</span>
            sqlite3VdbeAddOp4(v, OP_Affinity, iReg, 1, 0,
                              &amp;zAff[(aff-&#39;B&#39;)*2], P4_STATIC);
          }
          return iReg;
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -102694,10 +103571,11 @@</span>
  #endif
        }else{
          tempX.op = TK_INTEGER;
          tempX.flags = EP_IntValue|EP_TokenOnly;
          tempX.u.iValue = 0;
<span class="udiff-line-added">+         ExprClearVVAProperties(&amp;tempX);</span>
          r1 = sqlite3ExprCodeTemp(pParse, &amp;tempX, &amp;regFree1);
          r2 = sqlite3ExprCodeTemp(pParse, pExpr-&gt;pLeft, &amp;regFree2);
          sqlite3VdbeAddOp3(v, OP_Subtract, r2, r1, target);
          testcase( regFree2==0 );
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -102739,11 +103617,14 @@</span>
        sqlite3VdbeJumpHere(v, addr);
        break;
      }
      case TK_AGG_FUNCTION: {
        AggInfo *pInfo = pExpr-&gt;pAggInfo;
<span class="udiff-line-modified-removed">-       if( pInfo==0 ){</span>
<span class="udiff-line-modified-added">+       if( pInfo==0</span>
<span class="udiff-line-added">+        || NEVER(pExpr-&gt;iAgg&lt;0)</span>
<span class="udiff-line-added">+        || NEVER(pExpr-&gt;iAgg&gt;=pInfo-&gt;nFunc)</span>
<span class="udiff-line-added">+       ){</span>
          assert( !ExprHasProperty(pExpr, EP_IntValue) );
          sqlite3ErrorMsg(pParse, &quot;misuse of aggregate: %s()&quot;, pExpr-&gt;u.zToken);
        }else{
          return pInfo-&gt;aFunc[pExpr-&gt;iAgg].iMem;
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -102765,20 +103646,17 @@</span>
          return pExpr-&gt;y.pWin-&gt;regResult;
        }
  #endif
  
        if( ConstFactorOk(pParse) &amp;&amp; sqlite3ExprIsConstantNotJoin(pExpr) ){
<span class="udiff-line-modified-removed">-         /* SQL functions can be expensive. So try to move constant functions</span>
<span class="udiff-line-modified-removed">-         ** out of the inner loop, even if that means an extra OP_Copy. */</span>
<span class="udiff-line-modified-removed">-         return sqlite3ExprCodeAtInit(pParse, pExpr, -1);</span>
<span class="udiff-line-modified-added">+         /* SQL functions can be expensive. So try to avoid running them</span>
<span class="udiff-line-modified-added">+         ** multiple times if we know they always give the same result */</span>
<span class="udiff-line-modified-added">+         return sqlite3ExprCodeRunJustOnce(pParse, pExpr, -1);</span>
        }
        assert( !ExprHasProperty(pExpr, EP_xIsSelect) );
<span class="udiff-line-modified-removed">-       if( ExprHasProperty(pExpr, EP_TokenOnly) ){</span>
<span class="udiff-line-modified-removed">-         pFarg = 0;</span>
<span class="udiff-line-removed">-       }else{</span>
<span class="udiff-line-removed">-         pFarg = pExpr-&gt;x.pList;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+       assert( !ExprHasProperty(pExpr, EP_TokenOnly) );</span>
<span class="udiff-line-modified-added">+       pFarg = pExpr-&gt;x.pList;</span>
        nFarg = pFarg ? pFarg-&gt;nExpr : 0;
        assert( !ExprHasProperty(pExpr, EP_IntValue) );
        zId = pExpr-&gt;u.zToken;
        pDef = sqlite3FindFunction(db, zId, nFarg, enc, 0);
  #ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -103109,21 +103987,22 @@</span>
          sqlite3ExprCode(pParse, pEList-&gt;a[nExpr-1].pExpr, target);
        }else{
          sqlite3VdbeAddOp2(v, OP_Null, 0, target);
        }
        sqlite3ExprDelete(db, pDel);
<span class="udiff-line-added">+       setDoNotMergeFlagOnCopy(v);</span>
        sqlite3VdbeResolveLabel(v, endLabel);
        break;
      }
  #ifndef SQLITE_OMIT_TRIGGER
      case TK_RAISE: {
        assert( pExpr-&gt;affExpr==OE_Rollback
             || pExpr-&gt;affExpr==OE_Abort
             || pExpr-&gt;affExpr==OE_Fail
             || pExpr-&gt;affExpr==OE_Ignore
        );
<span class="udiff-line-modified-removed">-       if( !pParse-&gt;pTriggerTab ){</span>
<span class="udiff-line-modified-added">+       if( !pParse-&gt;pTriggerTab &amp;&amp; !pParse-&gt;nested ){</span>
          sqlite3ErrorMsg(pParse,
                         &quot;RAISE() may only be used within a trigger-program&quot;);
          return 0;
        }
        if( pExpr-&gt;affExpr==OE_Abort ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -103133,12 +104012,13 @@</span>
        if( pExpr-&gt;affExpr==OE_Ignore ){
          sqlite3VdbeAddOp4(
              v, OP_Halt, SQLITE_OK, OE_Ignore, 0, pExpr-&gt;u.zToken,0);
          VdbeCoverage(v);
        }else{
<span class="udiff-line-modified-removed">-         sqlite3HaltConstraint(pParse, SQLITE_CONSTRAINT_TRIGGER,</span>
<span class="udiff-line-modified-removed">-                               pExpr-&gt;affExpr, pExpr-&gt;u.zToken, 0, 0);</span>
<span class="udiff-line-modified-added">+         sqlite3HaltConstraint(pParse,</span>
<span class="udiff-line-modified-added">+              pParse-&gt;pTriggerTab ? SQLITE_CONSTRAINT_TRIGGER : SQLITE_ERROR,</span>
<span class="udiff-line-added">+              pExpr-&gt;affExpr, pExpr-&gt;u.zToken, 0, 0);</span>
        }
  
        break;
      }
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -103147,19 +104027,27 @@</span>
    sqlite3ReleaseTempReg(pParse, regFree2);
    return inReg;
  }
  
  /*
<span class="udiff-line-modified-removed">- ** Factor out the code of the given expression to initialization time.</span>
<span class="udiff-line-modified-added">+ ** Generate code that will evaluate expression pExpr just one time</span>
<span class="udiff-line-added">+ ** per prepared statement execution.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** If the expression uses functions (that might throw an exception) then</span>
<span class="udiff-line-added">+ ** guard them with an OP_Once opcode to ensure that the code is only executed</span>
<span class="udiff-line-added">+ ** once. If no functions are involved, then factor the code out and put it at</span>
<span class="udiff-line-added">+ ** the end of the prepared statement in the initialization section.</span>
  **
  ** If regDest&gt;=0 then the result is always stored in that register and the
  ** result is not reusable.  If regDest&lt;0 then this routine is free to
  ** store the value whereever it wants.  The register where the expression
<span class="udiff-line-modified-removed">- ** is stored is returned.  When regDest&lt;0, two identical expressions will</span>
<span class="udiff-line-modified-removed">- ** code to the same register.</span>
<span class="udiff-line-modified-added">+ ** is stored is returned.  When regDest&lt;0, two identical expressions might</span>
<span class="udiff-line-modified-added">+ ** code to the same register, if they do not contain function calls and hence</span>
<span class="udiff-line-added">+ ** are factored out into the initialization section at the end of the</span>
<span class="udiff-line-added">+ ** prepared statement.</span>
  */
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE int sqlite3ExprCodeAtInit(</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE int sqlite3ExprCodeRunJustOnce(</span>
    Parse *pParse,    /* Parsing context */
    Expr *pExpr,      /* The expression to code when the VDBE initializes */
    int regDest       /* Store the value in this register */
  ){
    ExprList *p;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -103173,18 +104061,33 @@</span>
          return pItem-&gt;u.iConstExprReg;
        }
      }
    }
    pExpr = sqlite3ExprDup(pParse-&gt;db, pExpr, 0);
<span class="udiff-line-modified-removed">-   p = sqlite3ExprListAppend(pParse, p, pExpr);</span>
<span class="udiff-line-modified-removed">-   if( p ){</span>
<span class="udiff-line-modified-removed">-      struct ExprList_item *pItem = &amp;p-&gt;a[p-&gt;nExpr-1];</span>
<span class="udiff-line-modified-removed">-      pItem-&gt;reusable = regDest&lt;0;</span>
<span class="udiff-line-modified-removed">-      if( regDest&lt;0 ) regDest = ++pParse-&gt;nMem;</span>
<span class="udiff-line-modified-removed">-      pItem-&gt;u.iConstExprReg = regDest;</span>
<span class="udiff-line-modified-added">+   if( pExpr!=0 &amp;&amp; ExprHasProperty(pExpr, EP_HasFunc) ){</span>
<span class="udiff-line-modified-added">+     Vdbe *v = pParse-&gt;pVdbe;</span>
<span class="udiff-line-modified-added">+     int addr;</span>
<span class="udiff-line-modified-added">+     assert( v );</span>
<span class="udiff-line-modified-added">+     addr = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);</span>
<span class="udiff-line-modified-added">+     pParse-&gt;okConstFactor = 0;</span>
<span class="udiff-line-added">+     if( !pParse-&gt;db-&gt;mallocFailed ){</span>
<span class="udiff-line-added">+       if( regDest&lt;0 ) regDest = ++pParse-&gt;nMem;</span>
<span class="udiff-line-added">+       sqlite3ExprCode(pParse, pExpr, regDest);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     pParse-&gt;okConstFactor = 1;</span>
<span class="udiff-line-added">+     sqlite3ExprDelete(pParse-&gt;db, pExpr);</span>
<span class="udiff-line-added">+     sqlite3VdbeJumpHere(v, addr);</span>
<span class="udiff-line-added">+   }else{</span>
<span class="udiff-line-added">+     p = sqlite3ExprListAppend(pParse, p, pExpr);</span>
<span class="udiff-line-added">+     if( p ){</span>
<span class="udiff-line-added">+        struct ExprList_item *pItem = &amp;p-&gt;a[p-&gt;nExpr-1];</span>
<span class="udiff-line-added">+        pItem-&gt;reusable = regDest&lt;0;</span>
<span class="udiff-line-added">+        if( regDest&lt;0 ) regDest = ++pParse-&gt;nMem;</span>
<span class="udiff-line-added">+        pItem-&gt;u.iConstExprReg = regDest;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     pParse-&gt;pConstExpr = p;</span>
    }
<span class="udiff-line-removed">-   pParse-&gt;pConstExpr = p;</span>
    return regDest;
  }
  
  /*
  ** Generate code to evaluate an expression and store the results
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -103205,11 +104108,11 @@</span>
    if( ConstFactorOk(pParse)
     &amp;&amp; pExpr-&gt;op!=TK_REGISTER
     &amp;&amp; sqlite3ExprIsConstantNotJoin(pExpr)
    ){
      *pReg  = 0;
<span class="udiff-line-modified-removed">-     r2 = sqlite3ExprCodeAtInit(pParse, pExpr, -1);</span>
<span class="udiff-line-modified-added">+     r2 = sqlite3ExprCodeRunJustOnce(pParse, pExpr, -1);</span>
    }else{
      int r1 = sqlite3GetTempReg(pParse);
      r2 = sqlite3ExprCodeTarget(pParse, pExpr, r1);
      if( r2==r1 ){
        *pReg = r1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -103227,10 +104130,11 @@</span>
  ** in register target.
  */
  SQLITE_PRIVATE void sqlite3ExprCode(Parse *pParse, Expr *pExpr, int target){
    int inReg;
  
<span class="udiff-line-added">+   assert( pExpr==0 || !ExprHasVVAProperty(pExpr,EP_Immutable) );</span>
    assert( target&gt;0 &amp;&amp; target&lt;=pParse-&gt;nMem );
    inReg = sqlite3ExprCodeTarget(pParse, pExpr, target);
    assert( pParse-&gt;pVdbe!=0 || pParse-&gt;db-&gt;mallocFailed );
    if( inReg!=target &amp;&amp; pParse-&gt;pVdbe ){
      u8 op;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -103261,13 +104165,13 @@</span>
  ** in register target.  If the expression is constant, then this routine
  ** might choose to code the expression at initialization time.
  */
  SQLITE_PRIVATE void sqlite3ExprCodeFactorable(Parse *pParse, Expr *pExpr, int target){
    if( pParse-&gt;okConstFactor &amp;&amp; sqlite3ExprIsConstantNotJoin(pExpr) ){
<span class="udiff-line-modified-removed">-     sqlite3ExprCodeAtInit(pParse, pExpr, target);</span>
<span class="udiff-line-modified-added">+     sqlite3ExprCodeRunJustOnce(pParse, pExpr, target);</span>
    }else{
<span class="udiff-line-modified-removed">-     sqlite3ExprCode(pParse, pExpr, target);</span>
<span class="udiff-line-modified-added">+     sqlite3ExprCodeCopy(pParse, pExpr, target);</span>
    }
  }
  
  /*
  ** Generate code that pushes the value of every element of the given
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -103321,11 +104225,11 @@</span>
          sqlite3VdbeAddOp2(v, copyOp, j+srcReg-1, target+i);
        }
      }else if( (flags &amp; SQLITE_ECEL_FACTOR)!=0
             &amp;&amp; sqlite3ExprIsConstantNotJoin(pExpr)
      ){
<span class="udiff-line-modified-removed">-       sqlite3ExprCodeAtInit(pParse, pExpr, target+i);</span>
<span class="udiff-line-modified-added">+       sqlite3ExprCodeRunJustOnce(pParse, pExpr, target+i);</span>
      }else{
        int inReg = sqlite3ExprCodeTarget(pParse, pExpr, target+i);
        if( inReg!=target+i ){
          VdbeOp *pOp;
          if( copyOp==OP_Copy
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -103444,10 +104348,11 @@</span>
    int r1, r2;
  
    assert( jumpIfNull==SQLITE_JUMPIFNULL || jumpIfNull==0 );
    if( NEVER(v==0) )     return;  /* Existence of VDBE checked by caller */
    if( NEVER(pExpr==0) ) return;  /* No way this can happen */
<span class="udiff-line-added">+   assert( !ExprHasVVAProperty(pExpr, EP_Immutable) );</span>
    op = pExpr-&gt;op;
    switch( op ){
      case TK_AND:
      case TK_OR: {
        Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -103585,10 +104490,11 @@</span>
    int r1, r2;
  
    assert( jumpIfNull==SQLITE_JUMPIFNULL || jumpIfNull==0 );
    if( NEVER(v==0) ) return; /* Existence of VDBE checked by caller */
    if( pExpr==0 )    return;
<span class="udiff-line-added">+   assert( !ExprHasVVAProperty(pExpr,EP_Immutable) );</span>
  
    /* The value of pExpr-&gt;op and op are related as follows:
    **
    **       pExpr-&gt;op            op
    **       ---------          ----------
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -103868,36 +104774,22 @@</span>
        return 2;
      }
    }
    if( (pA-&gt;flags &amp; (EP_Distinct|EP_Commuted))
       != (pB-&gt;flags &amp; (EP_Distinct|EP_Commuted)) ) return 2;
<span class="udiff-line-modified-removed">-   if( (combinedFlags &amp; EP_TokenOnly)==0 ){</span>
<span class="udiff-line-modified-added">+   if( ALWAYS((combinedFlags &amp; EP_TokenOnly)==0) ){</span>
      if( combinedFlags &amp; EP_xIsSelect ) return 2;
      if( (combinedFlags &amp; EP_FixedCol)==0
       &amp;&amp; sqlite3ExprCompare(pParse, pA-&gt;pLeft, pB-&gt;pLeft, iTab) ) return 2;
      if( sqlite3ExprCompare(pParse, pA-&gt;pRight, pB-&gt;pRight, iTab) ) return 2;
      if( sqlite3ExprListCompare(pA-&gt;x.pList, pB-&gt;x.pList, iTab) ) return 2;
      if( pA-&gt;op!=TK_STRING
       &amp;&amp; pA-&gt;op!=TK_TRUEFALSE
<span class="udiff-line-modified-removed">-      &amp;&amp; (combinedFlags &amp; EP_Reduced)==0</span>
<span class="udiff-line-modified-added">+      &amp;&amp; ALWAYS((combinedFlags &amp; EP_Reduced)==0)</span>
      ){
        if( pA-&gt;iColumn!=pB-&gt;iColumn ) return 2;
<span class="udiff-line-modified-removed">-       if( pA-&gt;op2!=pB-&gt;op2 ){</span>
<span class="udiff-line-removed">-         if( pA-&gt;op==TK_TRUTH ) return 2;</span>
<span class="udiff-line-removed">-         if( pA-&gt;op==TK_FUNCTION &amp;&amp; iTab&lt;0 ){</span>
<span class="udiff-line-removed">-           /* Ex: CREATE TABLE t1(a CHECK( a&lt;julianday(&#39;now&#39;) ));</span>
<span class="udiff-line-removed">-           **     INSERT INTO t1(a) VALUES(julianday(&#39;now&#39;)+10);</span>
<span class="udiff-line-removed">-           ** Without this test, sqlite3ExprCodeAtInit() will run on the</span>
<span class="udiff-line-removed">-           ** the julianday() of INSERT first, and remember that expression.</span>
<span class="udiff-line-removed">-           ** Then sqlite3ExprCodeInit() will see the julianday() in the CHECK</span>
<span class="udiff-line-removed">-           ** constraint as redundant, reusing the one from the INSERT, even</span>
<span class="udiff-line-removed">-           ** though the julianday() in INSERT lacks the critical NC_IsCheck</span>
<span class="udiff-line-removed">-           ** flag.  See ticket [830277d9db6c3ba1] (2019-10-30)</span>
<span class="udiff-line-removed">-           */</span>
<span class="udiff-line-removed">-           return 2;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+       if( pA-&gt;op2!=pB-&gt;op2 &amp;&amp; pA-&gt;op==TK_TRUTH ) return 2;</span>
        if( pA-&gt;op!=TK_IN &amp;&amp; pA-&gt;iTable!=pB-&gt;iTable &amp;&amp; pA-&gt;iTable!=iTab ){
          return 2;
        }
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -104131,23 +105023,29 @@</span>
      case TK_EQ:
      case TK_NE:
      case TK_LT:
      case TK_LE:
      case TK_GT:
<span class="udiff-line-modified-removed">-     case TK_GE:</span>
<span class="udiff-line-modified-added">+     case TK_GE: {</span>
<span class="udiff-line-added">+       Expr *pLeft = pExpr-&gt;pLeft;</span>
<span class="udiff-line-added">+       Expr *pRight = pExpr-&gt;pRight;</span>
        testcase( pExpr-&gt;op==TK_EQ );
        testcase( pExpr-&gt;op==TK_NE );
        testcase( pExpr-&gt;op==TK_LT );
        testcase( pExpr-&gt;op==TK_LE );
        testcase( pExpr-&gt;op==TK_GT );
        testcase( pExpr-&gt;op==TK_GE );
<span class="udiff-line-modified-removed">-       if( (pExpr-&gt;pLeft-&gt;op==TK_COLUMN &amp;&amp; IsVirtual(pExpr-&gt;pLeft-&gt;y.pTab))</span>
<span class="udiff-line-modified-removed">-        || (pExpr-&gt;pRight-&gt;op==TK_COLUMN &amp;&amp; IsVirtual(pExpr-&gt;pRight-&gt;y.pTab))</span>
<span class="udiff-line-modified-added">+       /* The y.pTab=0 assignment in wherecode.c always happens after the</span>
<span class="udiff-line-modified-added">+       ** impliesNotNullRow() test */</span>
<span class="udiff-line-added">+       if( (pLeft-&gt;op==TK_COLUMN &amp;&amp; ALWAYS(pLeft-&gt;y.pTab!=0)</span>
<span class="udiff-line-added">+                                &amp;&amp; IsVirtual(pLeft-&gt;y.pTab))</span>
<span class="udiff-line-added">+        || (pRight-&gt;op==TK_COLUMN &amp;&amp; ALWAYS(pRight-&gt;y.pTab!=0)</span>
<span class="udiff-line-added">+                                &amp;&amp; IsVirtual(pRight-&gt;y.pTab))</span>
        ){
<span class="udiff-line-modified-removed">-        return WRC_Prune;</span>
<span class="udiff-line-modified-added">+         return WRC_Prune;</span>
        }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+     }</span>
      default:
        return WRC_Continue;
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -104255,14 +105153,29 @@</span>
  ** aggregate function, in order to implement the
  ** sqlite3FunctionThisSrc() routine.
  */
  struct SrcCount {
    SrcList *pSrc;   /* One particular FROM clause in a nested query */
<span class="udiff-line-added">+   int iSrcInner;   /* Smallest cursor number in this context */</span>
    int nThis;       /* Number of references to columns in pSrcList */
    int nOther;      /* Number of references to columns in other FROM clauses */
  };
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** xSelect callback for sqlite3FunctionUsesThisSrc(). If this is the first</span>
<span class="udiff-line-added">+ ** SELECT with a FROM clause encountered during this iteration, set</span>
<span class="udiff-line-added">+ ** SrcCount.iSrcInner to the cursor number of the leftmost object in</span>
<span class="udiff-line-added">+ ** the FROM cause.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static int selectSrcCount(Walker *pWalker, Select *pSel){</span>
<span class="udiff-line-added">+   struct SrcCount *p = pWalker-&gt;u.pSrcCount;</span>
<span class="udiff-line-added">+   if( p-&gt;iSrcInner==0x7FFFFFFF &amp;&amp; ALWAYS(pSel-&gt;pSrc) &amp;&amp; pSel-&gt;pSrc-&gt;nSrc ){</span>
<span class="udiff-line-added">+     pWalker-&gt;u.pSrcCount-&gt;iSrcInner = pSel-&gt;pSrc-&gt;a[0].iCursor;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return WRC_Continue;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /*
  ** Count the number of references to columns.
  */
  static int exprSrcCount(Walker *pWalker, Expr *pExpr){
    /* There was once a NEVER() on the second term on the grounds that
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -104279,11 +105192,11 @@</span>
      for(i=0; i&lt;nSrc; i++){
        if( pExpr-&gt;iTable==pSrc-&gt;a[i].iCursor ) break;
      }
      if( i&lt;nSrc ){
        p-&gt;nThis++;
<span class="udiff-line-modified-removed">-     }else if( nSrc==0 || pExpr-&gt;iTable&lt;pSrc-&gt;a[0].iCursor ){</span>
<span class="udiff-line-modified-added">+     }else if( pExpr-&gt;iTable&lt;p-&gt;iSrcInner ){</span>
        /* In a well-formed parse tree (no name resolution errors),
        ** TK_COLUMN nodes with smaller Expr.iTable values are in an
        ** outer context.  Those are the only ones to count as &quot;other&quot; */
        p-&gt;nOther++;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -104301,13 +105214,14 @@</span>
    Walker w;
    struct SrcCount cnt;
    assert( pExpr-&gt;op==TK_AGG_FUNCTION );
    memset(&amp;w, 0, sizeof(w));
    w.xExprCallback = exprSrcCount;
<span class="udiff-line-modified-removed">-   w.xSelectCallback = sqlite3SelectWalkNoop;</span>
<span class="udiff-line-modified-added">+   w.xSelectCallback = selectSrcCount;</span>
    w.u.pSrcCount = &amp;cnt;
    cnt.pSrc = pSrcList;
<span class="udiff-line-added">+   cnt.iSrcInner = (pSrcList&amp;&amp;pSrcList-&gt;nSrc)?pSrcList-&gt;a[0].iCursor:0x7FFFFFFF;</span>
    cnt.nThis = 0;
    cnt.nOther = 0;
    sqlite3WalkExprList(&amp;w, pExpr-&gt;x.pList);
  #ifndef SQLITE_OMIT_WINDOWFUNC
    if( ExprHasProperty(pExpr, EP_WinFunc) ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -104315,10 +105229,68 @@</span>
    }
  #endif
    return cnt.nThis&gt;0 || cnt.nOther==0;
  }
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** This is a Walker expression node callback.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** For Expr nodes that contain pAggInfo pointers, make sure the AggInfo</span>
<span class="udiff-line-added">+ ** object that is referenced does not refer directly to the Expr.  If</span>
<span class="udiff-line-added">+ ** it does, make a copy.  This is done because the pExpr argument is</span>
<span class="udiff-line-added">+ ** subject to change.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** The copy is stored on pParse-&gt;pConstExpr with a register number of 0.</span>
<span class="udiff-line-added">+ ** This will cause the expression to be deleted automatically when the</span>
<span class="udiff-line-added">+ ** Parse object is destroyed, but the zero register number means that it</span>
<span class="udiff-line-added">+ ** will not generate any code in the preamble.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static int agginfoPersistExprCb(Walker *pWalker, Expr *pExpr){</span>
<span class="udiff-line-added">+   if( ALWAYS(!ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced))</span>
<span class="udiff-line-added">+    &amp;&amp; pExpr-&gt;pAggInfo!=0</span>
<span class="udiff-line-added">+   ){</span>
<span class="udiff-line-added">+     AggInfo *pAggInfo = pExpr-&gt;pAggInfo;</span>
<span class="udiff-line-added">+     int iAgg = pExpr-&gt;iAgg;</span>
<span class="udiff-line-added">+     Parse *pParse = pWalker-&gt;pParse;</span>
<span class="udiff-line-added">+     sqlite3 *db = pParse-&gt;db;</span>
<span class="udiff-line-added">+     assert( pExpr-&gt;op==TK_AGG_COLUMN || pExpr-&gt;op==TK_AGG_FUNCTION );</span>
<span class="udiff-line-added">+     if( pExpr-&gt;op==TK_AGG_COLUMN ){</span>
<span class="udiff-line-added">+       assert( iAgg&gt;=0 &amp;&amp; iAgg&lt;pAggInfo-&gt;nColumn );</span>
<span class="udiff-line-added">+       if( pAggInfo-&gt;aCol[iAgg].pExpr==pExpr ){</span>
<span class="udiff-line-added">+         pExpr = sqlite3ExprDup(db, pExpr, 0);</span>
<span class="udiff-line-added">+         if( pExpr ){</span>
<span class="udiff-line-added">+           pAggInfo-&gt;aCol[iAgg].pExpr = pExpr;</span>
<span class="udiff-line-added">+           pParse-&gt;pConstExpr =</span>
<span class="udiff-line-added">+              sqlite3ExprListAppend(pParse, pParse-&gt;pConstExpr, pExpr);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }else{</span>
<span class="udiff-line-added">+       assert( iAgg&gt;=0 &amp;&amp; iAgg&lt;pAggInfo-&gt;nFunc );</span>
<span class="udiff-line-added">+       if( pAggInfo-&gt;aFunc[iAgg].pExpr==pExpr ){</span>
<span class="udiff-line-added">+         pExpr = sqlite3ExprDup(db, pExpr, 0);</span>
<span class="udiff-line-added">+         if( pExpr ){</span>
<span class="udiff-line-added">+           pAggInfo-&gt;aFunc[iAgg].pExpr = pExpr;</span>
<span class="udiff-line-added">+           pParse-&gt;pConstExpr =</span>
<span class="udiff-line-added">+              sqlite3ExprListAppend(pParse, pParse-&gt;pConstExpr, pExpr);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return WRC_Continue;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Initialize a Walker object so that will persist AggInfo entries referenced</span>
<span class="udiff-line-added">+ ** by the tree that is walked.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE void sqlite3AggInfoPersistWalkerInit(Walker *pWalker, Parse *pParse){</span>
<span class="udiff-line-added">+   memset(pWalker, 0, sizeof(*pWalker));</span>
<span class="udiff-line-added">+   pWalker-&gt;pParse = pParse;</span>
<span class="udiff-line-added">+   pWalker-&gt;xExprCallback = agginfoPersistExprCb;</span>
<span class="udiff-line-added">+   pWalker-&gt;xSelectCallback = sqlite3SelectWalkNoop;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /*
  ** Add a new element to the pAggInfo-&gt;aCol[] array.  Return the index of
  ** the new element.  Return a negative number if malloc fails.
  */
  static int addAggInfoColumn(sqlite3 *db, AggInfo *pInfo){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -104478,19 +105450,10 @@</span>
        }
      }
    }
    return WRC_Continue;
  }
<span class="udiff-line-removed">- static int analyzeAggregatesInSelect(Walker *pWalker, Select *pSelect){</span>
<span class="udiff-line-removed">-   UNUSED_PARAMETER(pSelect);</span>
<span class="udiff-line-removed">-   pWalker-&gt;walkerDepth++;</span>
<span class="udiff-line-removed">-   return WRC_Continue;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- static void analyzeAggregatesInSelectEnd(Walker *pWalker, Select *pSelect){</span>
<span class="udiff-line-removed">-   UNUSED_PARAMETER(pSelect);</span>
<span class="udiff-line-removed">-   pWalker-&gt;walkerDepth--;</span>
<span class="udiff-line-removed">- }</span>
  
  /*
  ** Analyze the pExpr expression looking for aggregate functions and
  ** for variables that need to be added to AggInfo object that pNC-&gt;pAggInfo
  ** points to.  Additional entries are made on the AggInfo object as
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -104500,12 +105463,12 @@</span>
  ** analyzed by sqlite3ResolveExprNames().
  */
  SQLITE_PRIVATE void sqlite3ExprAnalyzeAggregates(NameContext *pNC, Expr *pExpr){
    Walker w;
    w.xExprCallback = analyzeAggregate;
<span class="udiff-line-modified-removed">-   w.xSelectCallback = analyzeAggregatesInSelect;</span>
<span class="udiff-line-modified-removed">-   w.xSelectCallback2 = analyzeAggregatesInSelectEnd;</span>
<span class="udiff-line-modified-added">+   w.xSelectCallback = sqlite3WalkerDepthIncrease;</span>
<span class="udiff-line-modified-added">+   w.xSelectCallback2 = sqlite3WalkerDepthDecrease;</span>
    w.walkerDepth = 0;
    w.u.pNC = pNC;
    w.pParse = 0;
    assert( pNC-&gt;pSrcList!=0 );
    sqlite3WalkExpr(&amp;w, pExpr);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -104740,11 +105703,14 @@</span>
    if( !zName ) goto exit_rename_table;
  
    /* Check that a table or index named &#39;zName&#39; does not already exist
    ** in database iDb. If so, this is an error.
    */
<span class="udiff-line-modified-removed">-   if( sqlite3FindTable(db, zName, zDb) || sqlite3FindIndex(db, zName, zDb) ){</span>
<span class="udiff-line-modified-added">+   if( sqlite3FindTable(db, zName, zDb)</span>
<span class="udiff-line-added">+    || sqlite3FindIndex(db, zName, zDb)</span>
<span class="udiff-line-added">+    || sqlite3IsShadowTableOf(db, pTab, zName)</span>
<span class="udiff-line-added">+   ){</span>
      sqlite3ErrorMsg(pParse,
          &quot;there is already another table or index with this name: %s&quot;, zName);
      goto exit_rename_table;
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -104872,10 +105838,26 @@</span>
    sqlite3SrcListDelete(db, pSrc);
    sqlite3DbFree(db, zName);
    db-&gt;mDbFlags = savedDbFlags;
  }
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Write code that will raise an error if the table described by</span>
<span class="udiff-line-added">+ ** zDb and zTab is not empty.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static void sqlite3ErrorIfNotEmpty(</span>
<span class="udiff-line-added">+   Parse *pParse,        /* Parsing context */</span>
<span class="udiff-line-added">+   const char *zDb,      /* Schema holding the table */</span>
<span class="udiff-line-added">+   const char *zTab,     /* Table to check for empty */</span>
<span class="udiff-line-added">+   const char *zErr      /* Error message text */</span>
<span class="udiff-line-added">+ ){</span>
<span class="udiff-line-added">+   sqlite3NestedParse(pParse,</span>
<span class="udiff-line-added">+      &quot;SELECT raise(ABORT,%Q) FROM \&quot;%w\&quot;.\&quot;%w\&quot;&quot;,</span>
<span class="udiff-line-added">+      zErr, zDb, zTab</span>
<span class="udiff-line-added">+   );</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /*
  ** This function is called after an &quot;ALTER TABLE ... ADD&quot; statement
  ** has been parsed. Argument pColDef contains the text of the new
  ** column definition.
  **
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -104924,11 +105906,12 @@</span>
    if( pCol-&gt;colFlags &amp; COLFLAG_PRIMKEY ){
      sqlite3ErrorMsg(pParse, &quot;Cannot add a PRIMARY KEY column&quot;);
      return;
    }
    if( pNew-&gt;pIndex ){
<span class="udiff-line-modified-removed">-     sqlite3ErrorMsg(pParse, &quot;Cannot add a UNIQUE column&quot;);</span>
<span class="udiff-line-modified-added">+     sqlite3ErrorMsg(pParse,</span>
<span class="udiff-line-added">+          &quot;Cannot add a UNIQUE column&quot;);</span>
      return;
    }
    if( (pCol-&gt;colFlags &amp; COLFLAG_GENERATED)==0 ){
      /* If the default value for the new column was specified with a
      ** literal NULL, then set pDflt to 0. This simplifies checking
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -104937,20 +105920,19 @@</span>
      assert( pDflt==0 || pDflt-&gt;op==TK_SPAN );
      if( pDflt &amp;&amp; pDflt-&gt;pLeft-&gt;op==TK_NULL ){
        pDflt = 0;
      }
      if( (db-&gt;flags&amp;SQLITE_ForeignKeys) &amp;&amp; pNew-&gt;pFKey &amp;&amp; pDflt ){
<span class="udiff-line-modified-removed">-       sqlite3ErrorMsg(pParse,</span>
<span class="udiff-line-modified-added">+       sqlite3ErrorIfNotEmpty(pParse, zDb, zTab,</span>
            &quot;Cannot add a REFERENCES column with non-NULL default value&quot;);
<span class="udiff-line-removed">-       return;</span>
      }
      if( pCol-&gt;notNull &amp;&amp; !pDflt ){
<span class="udiff-line-modified-removed">-       sqlite3ErrorMsg(pParse,</span>
<span class="udiff-line-modified-added">+       sqlite3ErrorIfNotEmpty(pParse, zDb, zTab,</span>
            &quot;Cannot add a NOT NULL column with default value NULL&quot;);
<span class="udiff-line-removed">-       return;</span>
      }
  
<span class="udiff-line-added">+ </span>
      /* Ensure the default expression is something that sqlite3ValueFromExpr()
      ** can handle (i.e. not CURRENT_TIME etc.)
      */
      if( pDflt ){
        sqlite3_value *pVal = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -104960,18 +105942,17 @@</span>
        if( rc!=SQLITE_OK ){
          assert( db-&gt;mallocFailed == 1 );
          return;
        }
        if( !pVal ){
<span class="udiff-line-modified-removed">-         sqlite3ErrorMsg(pParse,&quot;Cannot add a column with non-constant default&quot;);</span>
<span class="udiff-line-modified-removed">-         return;</span>
<span class="udiff-line-modified-added">+         sqlite3ErrorIfNotEmpty(pParse, zDb, zTab,</span>
<span class="udiff-line-modified-added">+            &quot;Cannot add a column with non-constant default&quot;);</span>
        }
        sqlite3ValueFree(pVal);
      }
    }else if( pCol-&gt;colFlags &amp; COLFLAG_STORED ){
<span class="udiff-line-modified-removed">-     sqlite3ErrorMsg(pParse, &quot;cannot add a STORED column&quot;);</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-modified-added">+     sqlite3ErrorIfNotEmpty(pParse, zDb, zTab, &quot;cannot add a STORED column&quot;);</span>
    }
  
  
    /* Modify the CREATE TABLE statement. */
    zCol = sqlite3DbStrNDup(db, (char*)pColDef-&gt;z, pColDef-&gt;n);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -105086,10 +106067,11 @@</span>
    }
    memcpy(pNew-&gt;aCol, pTab-&gt;aCol, sizeof(Column)*pNew-&gt;nCol);
    for(i=0; i&lt;pNew-&gt;nCol; i++){
      Column *pCol = &amp;pNew-&gt;aCol[i];
      pCol-&gt;zName = sqlite3DbStrDup(db, pCol-&gt;zName);
<span class="udiff-line-added">+     pCol-&gt;hName = sqlite3StrIHash(pCol-&gt;zName);</span>
      pCol-&gt;zColl = 0;
      pCol-&gt;pDflt = 0;
    }
    pNew-&gt;pSchema = db-&gt;aDb[iDb].pSchema;
    pNew-&gt;addColOffset = pTab-&gt;addColOffset;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -105314,11 +106296,11 @@</span>
  */
  SQLITE_PRIVATE void *sqlite3RenameTokenMap(Parse *pParse, void *pPtr, Token *pToken){
    RenameToken *pNew;
    assert( pPtr || pParse-&gt;db-&gt;mallocFailed );
    renameTokenCheckAll(pParse, pPtr);
<span class="udiff-line-modified-removed">-   if( pParse-&gt;eParseMode!=PARSE_MODE_UNMAP ){</span>
<span class="udiff-line-modified-added">+   if( ALWAYS(pParse-&gt;eParseMode!=PARSE_MODE_UNMAP) ){</span>
      pNew = sqlite3DbMallocZero(pParse-&gt;db, sizeof(RenameToken));
      if( pNew ){
        pNew-&gt;p = pPtr;
        pNew-&gt;t = *pToken;
        pNew-&gt;pNext = pParse-&gt;pRename;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -105372,10 +106354,25 @@</span>
        sqlite3RenameExprlistUnmap(pWalker-&gt;pParse, pWith-&gt;a[i].pCols);
      }
    }
  }
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Unmap all tokens in the IdList object passed as the second argument.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static void unmapColumnIdlistNames(</span>
<span class="udiff-line-added">+   Parse *pParse,</span>
<span class="udiff-line-added">+   IdList *pIdList</span>
<span class="udiff-line-added">+ ){</span>
<span class="udiff-line-added">+   if( pIdList ){</span>
<span class="udiff-line-added">+     int ii;</span>
<span class="udiff-line-added">+     for(ii=0; ii&lt;pIdList-&gt;nId; ii++){</span>
<span class="udiff-line-added">+       sqlite3RenameTokenRemap(pParse, 0, (void*)pIdList-&gt;a[ii].zName);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /*
  ** Walker callback used by sqlite3RenameExprUnmap().
  */
  static int renameUnmapSelectCb(Walker *pWalker, Select *p){
    Parse *pParse = pWalker-&gt;pParse;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -105393,10 +106390,11 @@</span>
    if( ALWAYS(p-&gt;pSrc) ){  /* Every Select as a SrcList, even if it is empty */
      SrcList *pSrc = p-&gt;pSrc;
      for(i=0; i&lt;pSrc-&gt;nSrc; i++){
        sqlite3RenameTokenRemap(pParse, 0, (void*)pSrc-&gt;a[i].zName);
        if( sqlite3WalkExpr(pWalker, pSrc-&gt;a[i].pOn) ) return WRC_Abort;
<span class="udiff-line-added">+       unmapColumnIdlistNames(pParse, pSrc-&gt;a[i].pUsing);</span>
      }
    }
  
    renameWalkWith(pWalker, p);
    return WRC_Continue;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -105601,10 +106599,11 @@</span>
        }
      }
    }
  }
  
<span class="udiff-line-added">+ </span>
  /*
  ** Parse the SQL statement zSql using Parse object (*p). The Parse object
  ** is initialized by this function before it is used.
  */
  static int renameParseSql(
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106512,10 +107511,15 @@</span>
    sqlite3 *db = pParse-&gt;db;
    Db *pDb;
    Vdbe *v = sqlite3GetVdbe(pParse);
    int aRoot[ArraySize(aTable)];
    u8 aCreateTbl[ArraySize(aTable)];
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_STAT4</span>
<span class="udiff-line-added">+   const int nToOpen = OptimizationEnabled(db,SQLITE_Stat4) ? 2 : 1;</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+   const int nToOpen = 1;</span>
<span class="udiff-line-added">+ #endif</span>
  
    if( v==0 ) return;
    assert( sqlite3BtreeHoldsAllMutexes(db) );
    assert( sqlite3VdbeDb(v)==db );
    pDb = &amp;db-&gt;aDb[iDb];
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106524,12 +107528,13 @@</span>
    ** if they do already exist.
    */
    for(i=0; i&lt;ArraySize(aTable); i++){
      const char *zTab = aTable[i].zName;
      Table *pStat;
<span class="udiff-line-added">+     aCreateTbl[i] = 0;</span>
      if( (pStat = sqlite3FindTable(db, zTab, pDb-&gt;zDbSName))==0 ){
<span class="udiff-line-modified-removed">-       if( aTable[i].zCols ){</span>
<span class="udiff-line-modified-added">+       if( i&lt;nToOpen ){</span>
          /* The sqlite_statN table does not exist. Create it. Note that a
          ** side-effect of the CREATE TABLE statement is to leave the rootpage
          ** of the new table in register pParse-&gt;regRoot. This is important
          ** because the OpenWrite opcode below will be needing it. */
          sqlite3NestedParse(pParse,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106541,11 +107546,10 @@</span>
      }else{
        /* The table already exists. If zWhere is not NULL, delete all entries
        ** associated with the table zWhere. If zWhere is NULL, delete the
        ** entire contents of the table. */
        aRoot[i] = pStat-&gt;tnum;
<span class="udiff-line-removed">-       aCreateTbl[i] = 0;</span>
        sqlite3TableLock(pParse, iDb, aRoot[i], 1, zTab);
        if( zWhere ){
          sqlite3NestedParse(pParse,
             &quot;DELETE FROM %Q.%s WHERE %s=%Q&quot;,
             pDb-&gt;zDbSName, zTab, zWhereType, zWhere
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106560,11 +107564,11 @@</span>
        }
      }
    }
  
    /* Open the sqlite_stat[134] tables for writing. */
<span class="udiff-line-modified-removed">-   for(i=0; aTable[i].zCols; i++){</span>
<span class="udiff-line-modified-added">+   for(i=0; i&lt;nToOpen; i++){</span>
      assert( i&lt;ArraySize(aTable) );
      sqlite3VdbeAddOp4Int(v, OP_OpenWrite, iStatCur+i, aRoot[i], iDb, 3);
      sqlite3VdbeChangeP5(v, aCreateTbl[i]);
      VdbeComment((v, aTable[i].zName));
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106580,13 +107584,13 @@</span>
  /*
  ** Three SQL functions - stat_init(), stat_push(), and stat_get() -
  ** share an instance of the following structure to hold their state
  ** information.
  */
<span class="udiff-line-modified-removed">- typedef struct Stat4Accum Stat4Accum;</span>
<span class="udiff-line-modified-removed">- typedef struct Stat4Sample Stat4Sample;</span>
<span class="udiff-line-modified-removed">- struct Stat4Sample {</span>
<span class="udiff-line-modified-added">+ typedef struct StatAccum StatAccum;</span>
<span class="udiff-line-modified-added">+ typedef struct StatSample StatSample;</span>
<span class="udiff-line-modified-added">+ struct StatSample {</span>
    tRowcnt *anEq;                  /* sqlite_stat4.nEq */
    tRowcnt *anDLt;                 /* sqlite_stat4.nDLt */
  #ifdef SQLITE_ENABLE_STAT4
    tRowcnt *anLt;                  /* sqlite_stat4.nLt */
    union {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106597,31 +107601,36 @@</span>
    u8 isPSample;                   /* True if a periodic sample */
    int iCol;                       /* If !isPSample, the reason for inclusion */
    u32 iHash;                      /* Tiebreaker hash */
  #endif
  };
<span class="udiff-line-modified-removed">- struct Stat4Accum {</span>
<span class="udiff-line-modified-removed">-   tRowcnt nRow;             /* Number of rows in the entire table */</span>
<span class="udiff-line-modified-removed">-   tRowcnt nPSample;         /* How often to do a periodic sample */</span>
<span class="udiff-line-modified-added">+ struct StatAccum {</span>
<span class="udiff-line-modified-added">+   sqlite3 *db;              /* Database connection, for malloc() */</span>
<span class="udiff-line-modified-added">+   tRowcnt nEst;             /* Estimated number of rows */</span>
<span class="udiff-line-added">+   tRowcnt nRow;             /* Number of rows visited so far */</span>
<span class="udiff-line-added">+   int nLimit;               /* Analysis row-scan limit */</span>
    int nCol;                 /* Number of columns in index + pk/rowid */
    int nKeyCol;              /* Number of index columns w/o the pk/rowid */
<span class="udiff-line-added">+   u8 nSkipAhead;            /* Number of times of skip-ahead */</span>
<span class="udiff-line-added">+   StatSample current;       /* Current row as a StatSample */</span>
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_STAT4</span>
<span class="udiff-line-added">+   tRowcnt nPSample;         /* How often to do a periodic sample */</span>
    int mxSample;             /* Maximum number of samples to accumulate */
<span class="udiff-line-removed">-   Stat4Sample current;      /* Current row as a Stat4Sample */</span>
    u32 iPrn;                 /* Pseudo-random number used for sampling */
<span class="udiff-line-modified-removed">-   Stat4Sample *aBest;       /* Array of nCol best samples */</span>
<span class="udiff-line-modified-added">+   StatSample *aBest;        /* Array of nCol best samples */</span>
    int iMin;                 /* Index in a[] of entry with minimum score */
    int nSample;              /* Current number of samples */
    int nMaxEqZero;           /* Max leading 0 in anEq[] for any a[] entry */
    int iGet;                 /* Index of current sample accessed by stat_get() */
<span class="udiff-line-modified-removed">-   Stat4Sample *a;           /* Array of mxSample Stat4Sample objects */</span>
<span class="udiff-line-modified-removed">-   sqlite3 *db;              /* Database connection, for malloc() */</span>
<span class="udiff-line-modified-added">+   StatSample *a;            /* Array of mxSample StatSample objects */</span>
<span class="udiff-line-modified-added">+ #endif</span>
  };
  
<span class="udiff-line-modified-removed">- /* Reclaim memory used by a Stat4Sample</span>
<span class="udiff-line-modified-added">+ /* Reclaim memory used by a StatSample</span>
  */
  #ifdef SQLITE_ENABLE_STAT4
<span class="udiff-line-modified-removed">- static void sampleClear(sqlite3 *db, Stat4Sample *p){</span>
<span class="udiff-line-modified-added">+ static void sampleClear(sqlite3 *db, StatSample *p){</span>
    assert( db!=0 );
    if( p-&gt;nRowid ){
      sqlite3DbFree(db, p-&gt;u.aRowid);
      p-&gt;nRowid = 0;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106629,11 +107638,11 @@</span>
  #endif
  
  /* Initialize the BLOB value of a ROWID
  */
  #ifdef SQLITE_ENABLE_STAT4
<span class="udiff-line-modified-removed">- static void sampleSetRowid(sqlite3 *db, Stat4Sample *p, int n, const u8 *pData){</span>
<span class="udiff-line-modified-added">+ static void sampleSetRowid(sqlite3 *db, StatSample *p, int n, const u8 *pData){</span>
    assert( db!=0 );
    if( p-&gt;nRowid ) sqlite3DbFree(db, p-&gt;u.aRowid);
    p-&gt;u.aRowid = sqlite3DbMallocRawNN(db, n);
    if( p-&gt;u.aRowid ){
      p-&gt;nRowid = n;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106645,11 +107654,11 @@</span>
  #endif
  
  /* Initialize the INTEGER value of a ROWID.
  */
  #ifdef SQLITE_ENABLE_STAT4
<span class="udiff-line-modified-removed">- static void sampleSetRowidInt64(sqlite3 *db, Stat4Sample *p, i64 iRowid){</span>
<span class="udiff-line-modified-added">+ static void sampleSetRowidInt64(sqlite3 *db, StatSample *p, i64 iRowid){</span>
    assert( db!=0 );
    if( p-&gt;nRowid ) sqlite3DbFree(db, p-&gt;u.aRowid);
    p-&gt;nRowid = 0;
    p-&gt;u.iRowid = iRowid;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106658,11 +107667,11 @@</span>
  
  /*
  ** Copy the contents of object (*pFrom) into (*pTo).
  */
  #ifdef SQLITE_ENABLE_STAT4
<span class="udiff-line-modified-removed">- static void sampleCopy(Stat4Accum *p, Stat4Sample *pTo, Stat4Sample *pFrom){</span>
<span class="udiff-line-modified-added">+ static void sampleCopy(StatAccum *p, StatSample *pTo, StatSample *pFrom){</span>
    pTo-&gt;isPSample = pFrom-&gt;isPSample;
    pTo-&gt;iCol = pFrom-&gt;iCol;
    pTo-&gt;iHash = pFrom-&gt;iHash;
    memcpy(pTo-&gt;anEq, pFrom-&gt;anEq, sizeof(tRowcnt)*p-&gt;nCol);
    memcpy(pTo-&gt;anLt, pFrom-&gt;anLt, sizeof(tRowcnt)*p-&gt;nCol);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106674,59 +107683,61 @@</span>
    }
  }
  #endif
  
  /*
<span class="udiff-line-modified-removed">- ** Reclaim all memory of a Stat4Accum structure.</span>
<span class="udiff-line-modified-added">+ ** Reclaim all memory of a StatAccum structure.</span>
  */
<span class="udiff-line-modified-removed">- static void stat4Destructor(void *pOld){</span>
<span class="udiff-line-modified-removed">-   Stat4Accum *p = (Stat4Accum*)pOld;</span>
<span class="udiff-line-modified-added">+ static void statAccumDestructor(void *pOld){</span>
<span class="udiff-line-modified-added">+   StatAccum *p = (StatAccum*)pOld;</span>
  #ifdef SQLITE_ENABLE_STAT4
<span class="udiff-line-modified-removed">-   int i;</span>
<span class="udiff-line-modified-removed">-   for(i=0; i&lt;p-&gt;nCol; i++) sampleClear(p-&gt;db, p-&gt;aBest+i);</span>
<span class="udiff-line-modified-removed">-   for(i=0; i&lt;p-&gt;mxSample; i++) sampleClear(p-&gt;db, p-&gt;a+i);</span>
<span class="udiff-line-modified-removed">-   sampleClear(p-&gt;db, &amp;p-&gt;current);</span>
<span class="udiff-line-modified-added">+   if( p-&gt;mxSample ){</span>
<span class="udiff-line-modified-added">+     int i;</span>
<span class="udiff-line-modified-added">+     for(i=0; i&lt;p-&gt;nCol; i++) sampleClear(p-&gt;db, p-&gt;aBest+i);</span>
<span class="udiff-line-modified-added">+     for(i=0; i&lt;p-&gt;mxSample; i++) sampleClear(p-&gt;db, p-&gt;a+i);</span>
<span class="udiff-line-added">+     sampleClear(p-&gt;db, &amp;p-&gt;current);</span>
<span class="udiff-line-added">+   }</span>
  #endif
    sqlite3DbFree(p-&gt;db, p);
  }
  
  /*
<span class="udiff-line-modified-removed">- ** Implementation of the stat_init(N,K,C) SQL function. The three parameters</span>
<span class="udiff-line-modified-added">+ ** Implementation of the stat_init(N,K,C,L) SQL function. The four parameters</span>
  ** are:
  **     N:    The number of columns in the index including the rowid/pk (note 1)
  **     K:    The number of columns in the index excluding the rowid/pk.
<span class="udiff-line-modified-removed">- **     C:    The number of rows in the index (note 2)</span>
<span class="udiff-line-modified-added">+ **     C:    Estimated number of rows in the index</span>
<span class="udiff-line-added">+ **     L:    A limit on the number of rows to scan, or 0 for no-limit</span>
  **
  ** Note 1:  In the special case of the covering index that implements a
  ** WITHOUT ROWID table, N is the number of PRIMARY KEY columns, not the
  ** total number of columns in the table.
  **
<span class="udiff-line-removed">- ** Note 2:  C is only used for STAT4.</span>
<span class="udiff-line-removed">- **</span>
  ** For indexes on ordinary rowid tables, N==K+1.  But for indexes on
  ** WITHOUT ROWID tables, N=K+P where P is the number of columns in the
  ** PRIMARY KEY of the table.  The covering index that implements the
  ** original WITHOUT ROWID table as N==K as a special case.
  **
<span class="udiff-line-modified-removed">- ** This routine allocates the Stat4Accum object in heap memory. The return</span>
<span class="udiff-line-modified-removed">- ** value is a pointer to the Stat4Accum object.  The datatype of the</span>
<span class="udiff-line-modified-removed">- ** return value is BLOB, but it is really just a pointer to the Stat4Accum</span>
<span class="udiff-line-modified-added">+ ** This routine allocates the StatAccum object in heap memory. The return</span>
<span class="udiff-line-modified-added">+ ** value is a pointer to the StatAccum object.  The datatype of the</span>
<span class="udiff-line-modified-added">+ ** return value is BLOB, but it is really just a pointer to the StatAccum</span>
  ** object.
  */
  static void statInit(
    sqlite3_context *context,
    int argc,
    sqlite3_value **argv
  ){
<span class="udiff-line-modified-removed">-   Stat4Accum *p;</span>
<span class="udiff-line-modified-added">+   StatAccum *p;</span>
    int nCol;                       /* Number of columns in index being sampled */
    int nKeyCol;                    /* Number of key columns */
    int nColUp;                     /* nCol rounded up for alignment */
    int n;                          /* Bytes of space to allocate */
<span class="udiff-line-modified-removed">-   sqlite3 *db;                    /* Database connection */</span>
<span class="udiff-line-modified-added">+   sqlite3 *db = sqlite3_context_db_handle(context);   /* Database connection */</span>
  #ifdef SQLITE_ENABLE_STAT4
<span class="udiff-line-modified-removed">-   int mxSample = SQLITE_STAT4_SAMPLES;</span>
<span class="udiff-line-modified-added">+   /* Maximum number of samples.  0 if STAT4 data is not collected */</span>
<span class="udiff-line-added">+   int mxSample = OptimizationEnabled(db,SQLITE_Stat4) ?SQLITE_STAT4_SAMPLES :0;</span>
  #endif
  
    /* Decode the three function arguments */
    UNUSED_PARAMETER(argc);
    nCol = sqlite3_value_int(argv[0]);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106734,47 +107745,51 @@</span>
    nColUp = sizeof(tRowcnt)&lt;8 ? (nCol+1)&amp;~1 : nCol;
    nKeyCol = sqlite3_value_int(argv[1]);
    assert( nKeyCol&lt;=nCol );
    assert( nKeyCol&gt;0 );
  
<span class="udiff-line-modified-removed">-   /* Allocate the space required for the Stat4Accum object */</span>
<span class="udiff-line-modified-added">+   /* Allocate the space required for the StatAccum object */</span>
    n = sizeof(*p)
<span class="udiff-line-modified-removed">-     + sizeof(tRowcnt)*nColUp                  /* Stat4Accum.anEq */</span>
<span class="udiff-line-modified-removed">-     + sizeof(tRowcnt)*nColUp                  /* Stat4Accum.anDLt */</span>
<span class="udiff-line-modified-added">+     + sizeof(tRowcnt)*nColUp                  /* StatAccum.anEq */</span>
<span class="udiff-line-modified-added">+     + sizeof(tRowcnt)*nColUp;                 /* StatAccum.anDLt */</span>
  #ifdef SQLITE_ENABLE_STAT4
<span class="udiff-line-modified-removed">-     + sizeof(tRowcnt)*nColUp                  /* Stat4Accum.anLt */</span>
<span class="udiff-line-modified-removed">-     + sizeof(Stat4Sample)*(nCol+mxSample)     /* Stat4Accum.aBest[], a[] */</span>
<span class="udiff-line-modified-removed">-     + sizeof(tRowcnt)*3*nColUp*(nCol+mxSample)</span>
<span class="udiff-line-modified-added">+   if( mxSample ){</span>
<span class="udiff-line-modified-added">+     n += sizeof(tRowcnt)*nColUp                  /* StatAccum.anLt */</span>
<span class="udiff-line-modified-added">+       + sizeof(StatSample)*(nCol+mxSample)       /* StatAccum.aBest[], a[] */</span>
<span class="udiff-line-added">+       + sizeof(tRowcnt)*3*nColUp*(nCol+mxSample);</span>
<span class="udiff-line-added">+   }</span>
  #endif
<span class="udiff-line-removed">-   ;</span>
    db = sqlite3_context_db_handle(context);
    p = sqlite3DbMallocZero(db, n);
    if( p==0 ){
      sqlite3_result_error_nomem(context);
      return;
    }
  
    p-&gt;db = db;
<span class="udiff-line-added">+   p-&gt;nEst = sqlite3_value_int64(argv[2]);</span>
    p-&gt;nRow = 0;
<span class="udiff-line-added">+   p-&gt;nLimit = sqlite3_value_int64(argv[3]);</span>
    p-&gt;nCol = nCol;
    p-&gt;nKeyCol = nKeyCol;
<span class="udiff-line-added">+   p-&gt;nSkipAhead = 0;</span>
    p-&gt;current.anDLt = (tRowcnt*)&amp;p[1];
    p-&gt;current.anEq = &amp;p-&gt;current.anDLt[nColUp];
  
  #ifdef SQLITE_ENABLE_STAT4
<span class="udiff-line-modified-removed">-   {</span>
<span class="udiff-line-modified-added">+   p-&gt;mxSample = p-&gt;nLimit==0 ? mxSample : 0;</span>
<span class="udiff-line-added">+   if( mxSample ){</span>
      u8 *pSpace;                     /* Allocated space not yet assigned */
      int i;                          /* Used to iterate through p-&gt;aSample[] */
  
      p-&gt;iGet = -1;
<span class="udiff-line-modified-removed">-     p-&gt;mxSample = mxSample;</span>
<span class="udiff-line-removed">-     p-&gt;nPSample = (tRowcnt)(sqlite3_value_int64(argv[2])/(mxSample/3+1) + 1);</span>
<span class="udiff-line-modified-added">+     p-&gt;nPSample = (tRowcnt)(p-&gt;nEst/(mxSample/3+1) + 1);</span>
      p-&gt;current.anLt = &amp;p-&gt;current.anEq[nColUp];
      p-&gt;iPrn = 0x689e962d*(u32)nCol ^ 0xd0944565*(u32)sqlite3_value_int(argv[2]);
  
<span class="udiff-line-modified-removed">-     /* Set up the Stat4Accum.a[] and aBest[] arrays */</span>
<span class="udiff-line-modified-removed">-     p-&gt;a = (struct Stat4Sample*)&amp;p-&gt;current.anLt[nColUp];</span>
<span class="udiff-line-modified-added">+     /* Set up the StatAccum.a[] and aBest[] arrays */</span>
<span class="udiff-line-modified-added">+     p-&gt;a = (struct StatSample*)&amp;p-&gt;current.anLt[nColUp];</span>
      p-&gt;aBest = &amp;p-&gt;a[mxSample];
      pSpace = (u8*)(&amp;p-&gt;a[mxSample+nCol]);
      for(i=0; i&lt;(mxSample+nCol); i++){
        p-&gt;a[i].anEq = (tRowcnt *)pSpace; pSpace += (sizeof(tRowcnt) * nColUp);
        p-&gt;a[i].anLt = (tRowcnt *)pSpace; pSpace += (sizeof(tRowcnt) * nColUp);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106790,14 +107805,14 @@</span>
  
    /* Return a pointer to the allocated object to the caller.  Note that
    ** only the pointer (the 2nd parameter) matters.  The size of the object
    ** (given by the 3rd parameter) is never used and can be any positive
    ** value. */
<span class="udiff-line-modified-removed">-   sqlite3_result_blob(context, p, sizeof(*p), stat4Destructor);</span>
<span class="udiff-line-modified-added">+   sqlite3_result_blob(context, p, sizeof(*p), statAccumDestructor);</span>
  }
  static const FuncDef statInitFuncdef = {
<span class="udiff-line-modified-removed">-   2+IsStat4,       /* nArg */</span>
<span class="udiff-line-modified-added">+   4,               /* nArg */</span>
    SQLITE_UTF8,     /* funcFlags */
    0,               /* pUserData */
    0,               /* pNext */
    statInit,        /* xSFunc */
    0,               /* xFinalize */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106817,13 +107832,13 @@</span>
  **
  ** This function assumes that for each argument sample, the contents of
  ** the anEq[] array from pSample-&gt;anEq[pSample-&gt;iCol+1] onwards are valid.
  */
  static int sampleIsBetterPost(
<span class="udiff-line-modified-removed">-   Stat4Accum *pAccum,</span>
<span class="udiff-line-modified-removed">-   Stat4Sample *pNew,</span>
<span class="udiff-line-modified-removed">-   Stat4Sample *pOld</span>
<span class="udiff-line-modified-added">+   StatAccum *pAccum,</span>
<span class="udiff-line-modified-added">+   StatSample *pNew,</span>
<span class="udiff-line-modified-added">+   StatSample *pOld</span>
  ){
    int nCol = pAccum-&gt;nCol;
    int i;
    assert( pNew-&gt;iCol==pOld-&gt;iCol );
    for(i=pNew-&gt;iCol+1; i&lt;nCol; i++){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106841,13 +107856,13 @@</span>
  **
  ** This function assumes that for each argument sample, the contents of
  ** the anEq[] array from pSample-&gt;anEq[pSample-&gt;iCol] onwards are valid.
  */
  static int sampleIsBetter(
<span class="udiff-line-modified-removed">-   Stat4Accum *pAccum,</span>
<span class="udiff-line-modified-removed">-   Stat4Sample *pNew,</span>
<span class="udiff-line-modified-removed">-   Stat4Sample *pOld</span>
<span class="udiff-line-modified-added">+   StatAccum *pAccum,</span>
<span class="udiff-line-modified-added">+   StatSample *pNew,</span>
<span class="udiff-line-modified-added">+   StatSample *pOld</span>
  ){
    tRowcnt nEqNew = pNew-&gt;anEq[pNew-&gt;iCol];
    tRowcnt nEqOld = pOld-&gt;anEq[pOld-&gt;iCol];
  
    assert( pOld-&gt;isPSample==0 &amp;&amp; pNew-&gt;isPSample==0 );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106863,34 +107878,34 @@</span>
  
  /*
  ** Copy the contents of sample *pNew into the p-&gt;a[] array. If necessary,
  ** remove the least desirable sample from p-&gt;a[] to make room.
  */
<span class="udiff-line-modified-removed">- static void sampleInsert(Stat4Accum *p, Stat4Sample *pNew, int nEqZero){</span>
<span class="udiff-line-modified-removed">-   Stat4Sample *pSample = 0;</span>
<span class="udiff-line-modified-added">+ static void sampleInsert(StatAccum *p, StatSample *pNew, int nEqZero){</span>
<span class="udiff-line-modified-added">+   StatSample *pSample = 0;</span>
    int i;
  
    assert( IsStat4 || nEqZero==0 );
  
<span class="udiff-line-modified-removed">-   /* Stat4Accum.nMaxEqZero is set to the maximum number of leading 0</span>
<span class="udiff-line-modified-removed">-   ** values in the anEq[] array of any sample in Stat4Accum.a[]. In</span>
<span class="udiff-line-modified-added">+   /* StatAccum.nMaxEqZero is set to the maximum number of leading 0</span>
<span class="udiff-line-modified-added">+   ** values in the anEq[] array of any sample in StatAccum.a[]. In</span>
    ** other words, if nMaxEqZero is n, then it is guaranteed that there
<span class="udiff-line-modified-removed">-   ** are no samples with Stat4Sample.anEq[m]==0 for (m&gt;=n). */</span>
<span class="udiff-line-modified-added">+   ** are no samples with StatSample.anEq[m]==0 for (m&gt;=n). */</span>
    if( nEqZero&gt;p-&gt;nMaxEqZero ){
      p-&gt;nMaxEqZero = nEqZero;
    }
    if( pNew-&gt;isPSample==0 ){
<span class="udiff-line-modified-removed">-     Stat4Sample *pUpgrade = 0;</span>
<span class="udiff-line-modified-added">+     StatSample *pUpgrade = 0;</span>
      assert( pNew-&gt;anEq[pNew-&gt;iCol]&gt;0 );
  
      /* This sample is being added because the prefix that ends in column
      ** iCol occurs many times in the table. However, if we have already
      ** added a sample that shares this prefix, there is no need to add
      ** this one. Instead, upgrade the priority of the highest priority
      ** existing sample that shares this prefix.  */
      for(i=p-&gt;nSample-1; i&gt;=0; i--){
<span class="udiff-line-modified-removed">-       Stat4Sample *pOld = &amp;p-&gt;a[i];</span>
<span class="udiff-line-modified-added">+       StatSample *pOld = &amp;p-&gt;a[i];</span>
        if( pOld-&gt;anEq[pNew-&gt;iCol]==0 ){
          if( pOld-&gt;isPSample ) return;
          assert( pOld-&gt;iCol&gt;pNew-&gt;iCol );
          assert( sampleIsBetter(p, pNew, pOld) );
          if( pUpgrade==0 || sampleIsBetter(p, pOld, pUpgrade) ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106905,11 +107920,11 @@</span>
      }
    }
  
    /* If necessary, remove sample iMin to make room for the new sample. */
    if( p-&gt;nSample&gt;=p-&gt;mxSample ){
<span class="udiff-line-modified-removed">-     Stat4Sample *pMin = &amp;p-&gt;a[p-&gt;iMin];</span>
<span class="udiff-line-modified-added">+     StatSample *pMin = &amp;p-&gt;a[p-&gt;iMin];</span>
      tRowcnt *anEq = pMin-&gt;anEq;
      tRowcnt *anLt = pMin-&gt;anLt;
      tRowcnt *anDLt = pMin-&gt;anDLt;
      sampleClear(p-&gt;db, pMin);
      memmove(pMin, &amp;pMin[1], sizeof(p-&gt;a[0])*(p-&gt;nSample-p-&gt;iMin-1));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106948,24 +107963,24 @@</span>
      p-&gt;iMin = iMin;
    }
  }
  #endif /* SQLITE_ENABLE_STAT4 */
  
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_STAT4</span>
  /*
  ** Field iChng of the index being scanned has changed. So at this point
  ** p-&gt;current contains a sample that reflects the previous row of the
  ** index. The value of anEq[iChng] and subsequent anEq[] elements are
  ** correct at this point.
  */
<span class="udiff-line-modified-removed">- static void samplePushPrevious(Stat4Accum *p, int iChng){</span>
<span class="udiff-line-removed">- #ifdef SQLITE_ENABLE_STAT4</span>
<span class="udiff-line-modified-added">+ static void samplePushPrevious(StatAccum *p, int iChng){</span>
    int i;
  
    /* Check if any samples from the aBest[] array should be pushed
    ** into IndexSample.a[] at this point.  */
    for(i=(p-&gt;nCol-2); i&gt;=iChng; i--){
<span class="udiff-line-modified-removed">-     Stat4Sample *pBest = &amp;p-&gt;aBest[i];</span>
<span class="udiff-line-modified-added">+     StatSample *pBest = &amp;p-&gt;aBest[i];</span>
      pBest-&gt;anEq[i] = p-&gt;current.anEq[i];
      if( p-&gt;nSample&lt;p-&gt;mxSample || sampleIsBetter(p, pBest, &amp;p-&gt;a[p-&gt;iMin]) ){
        sampleInsert(p, pBest, i);
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106985,31 +108000,29 @@</span>
          if( p-&gt;a[i].anEq[j]==0 ) p-&gt;a[i].anEq[j] = p-&gt;current.anEq[j];
        }
      }
      p-&gt;nMaxEqZero = iChng;
    }
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifndef SQLITE_ENABLE_STAT4</span>
<span class="udiff-line-removed">-   UNUSED_PARAMETER( p );</span>
<span class="udiff-line-removed">-   UNUSED_PARAMETER( iChng );</span>
<span class="udiff-line-removed">- #endif</span>
  }
<span class="udiff-line-added">+ #endif /* SQLITE_ENABLE_STAT4 */</span>
  
  /*
  ** Implementation of the stat_push SQL function:  stat_push(P,C,R)
  ** Arguments:
  **
<span class="udiff-line-modified-removed">- **    P     Pointer to the Stat4Accum object created by stat_init()</span>
<span class="udiff-line-modified-added">+ **    P     Pointer to the StatAccum object created by stat_init()</span>
  **    C     Index of left-most column to differ from previous row
  **    R     Rowid for the current row.  Might be a key record for
  **          WITHOUT ROWID tables.
  **
<span class="udiff-line-modified-removed">- ** This SQL function always returns NULL.  It&#39;s purpose it to accumulate</span>
<span class="udiff-line-modified-removed">- ** statistical data and/or samples in the Stat4Accum object about the</span>
<span class="udiff-line-modified-removed">- ** index being analyzed.  The stat_get() SQL function will later be used to</span>
<span class="udiff-line-modified-removed">- ** extract relevant information for constructing the sqlite_statN tables.</span>
<span class="udiff-line-modified-added">+ ** The purpose of this routine is to collect statistical data and/or</span>
<span class="udiff-line-modified-added">+ ** samples from the index being analyzed into the StatAccum object.</span>
<span class="udiff-line-modified-added">+ ** The stat_get() SQL function will be used afterwards to</span>
<span class="udiff-line-modified-added">+ ** retrieve the information gathered.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** This SQL function usually returns NULL, but might return an integer</span>
<span class="udiff-line-added">+ ** if it wants the byte-code to do special processing.</span>
  **
  ** The R parameter is only used for STAT4
  */
  static void statPush(
    sqlite3_context *context,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -107017,11 +108030,11 @@</span>
    sqlite3_value **argv
  ){
    int i;
  
    /* The three function arguments */
<span class="udiff-line-modified-removed">-   Stat4Accum *p = (Stat4Accum*)sqlite3_value_blob(argv[0]);</span>
<span class="udiff-line-modified-added">+   StatAccum *p = (StatAccum*)sqlite3_value_blob(argv[0]);</span>
    int iChng = sqlite3_value_int(argv[1]);
  
    UNUSED_PARAMETER( argc );
    UNUSED_PARAMETER( context );
    assert( p-&gt;nCol&gt;0 );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -107030,40 +108043,41 @@</span>
    if( p-&gt;nRow==0 ){
      /* This is the first call to this function. Do initialization. */
      for(i=0; i&lt;p-&gt;nCol; i++) p-&gt;current.anEq[i] = 1;
    }else{
      /* Second and subsequent calls get processed here */
<span class="udiff-line-modified-removed">-     samplePushPrevious(p, iChng);</span>
<span class="udiff-line-modified-added">+ #ifdef SQLITE_ENABLE_STAT4</span>
<span class="udiff-line-added">+     if( p-&gt;mxSample ) samplePushPrevious(p, iChng);</span>
<span class="udiff-line-added">+ #endif</span>
  
      /* Update anDLt[], anLt[] and anEq[] to reflect the values that apply
      ** to the current row of the index. */
      for(i=0; i&lt;iChng; i++){
        p-&gt;current.anEq[i]++;
      }
      for(i=iChng; i&lt;p-&gt;nCol; i++){
        p-&gt;current.anDLt[i]++;
  #ifdef SQLITE_ENABLE_STAT4
<span class="udiff-line-modified-removed">-       p-&gt;current.anLt[i] += p-&gt;current.anEq[i];</span>
<span class="udiff-line-modified-added">+       if( p-&gt;mxSample ) p-&gt;current.anLt[i] += p-&gt;current.anEq[i];</span>
  #endif
        p-&gt;current.anEq[i] = 1;
      }
    }
<span class="udiff-line-removed">-   p-&gt;nRow++;</span>
<span class="udiff-line-removed">- #ifdef SQLITE_ENABLE_STAT4</span>
<span class="udiff-line-removed">-   if( sqlite3_value_type(argv[2])==SQLITE_INTEGER ){</span>
<span class="udiff-line-removed">-     sampleSetRowidInt64(p-&gt;db, &amp;p-&gt;current, sqlite3_value_int64(argv[2]));</span>
<span class="udiff-line-removed">-   }else{</span>
<span class="udiff-line-removed">-     sampleSetRowid(p-&gt;db, &amp;p-&gt;current, sqlite3_value_bytes(argv[2]),</span>
<span class="udiff-line-removed">-                                        sqlite3_value_blob(argv[2]));</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   p-&gt;current.iHash = p-&gt;iPrn = p-&gt;iPrn*1103515245 + 12345;</span>
<span class="udiff-line-removed">- #endif</span>
  
<span class="udiff-line-added">+   p-&gt;nRow++;</span>
  #ifdef SQLITE_ENABLE_STAT4
<span class="udiff-line-modified-removed">-   {</span>
<span class="udiff-line-modified-removed">-     tRowcnt nLt = p-&gt;current.anLt[p-&gt;nCol-1];</span>
<span class="udiff-line-modified-added">+   if( p-&gt;mxSample ){</span>
<span class="udiff-line-modified-added">+     tRowcnt nLt;</span>
<span class="udiff-line-added">+     if( sqlite3_value_type(argv[2])==SQLITE_INTEGER ){</span>
<span class="udiff-line-added">+       sampleSetRowidInt64(p-&gt;db, &amp;p-&gt;current, sqlite3_value_int64(argv[2]));</span>
<span class="udiff-line-added">+     }else{</span>
<span class="udiff-line-added">+       sampleSetRowid(p-&gt;db, &amp;p-&gt;current, sqlite3_value_bytes(argv[2]),</span>
<span class="udiff-line-added">+                                          sqlite3_value_blob(argv[2]));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     p-&gt;current.iHash = p-&gt;iPrn = p-&gt;iPrn*1103515245 + 12345;</span>
  
<span class="udiff-line-added">+     nLt = p-&gt;current.anLt[p-&gt;nCol-1];</span>
      /* Check if this is to be a periodic sample. If so, add it. */
      if( (nLt/p-&gt;nPSample)!=(nLt+1)/p-&gt;nPSample ){
        p-&gt;current.isPSample = 1;
        p-&gt;current.iCol = 0;
        sampleInsert(p, &amp;p-&gt;current, p-&gt;nCol-1);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -107075,13 +108089,18 @@</span>
        p-&gt;current.iCol = i;
        if( i&gt;=iChng || sampleIsBetterPost(p, &amp;p-&gt;current, &amp;p-&gt;aBest[i]) ){
          sampleCopy(p, &amp;p-&gt;aBest[i], &amp;p-&gt;current);
        }
      }
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-added">+   }else</span>
  #endif
<span class="udiff-line-added">+   if( p-&gt;nLimit &amp;&amp; p-&gt;nRow&gt;(tRowcnt)p-&gt;nLimit*(p-&gt;nSkipAhead+1) ){</span>
<span class="udiff-line-added">+     p-&gt;nSkipAhead++;</span>
<span class="udiff-line-added">+     sqlite3_result_int(context, p-&gt;current.anDLt[0]&gt;0);</span>
<span class="udiff-line-added">+   }</span>
  }
<span class="udiff-line-added">+ </span>
  static const FuncDef statPushFuncdef = {
    2+IsStat4,       /* nArg */
    SQLITE_UTF8,     /* funcFlags */
    0,               /* pUserData */
    0,               /* pNext */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -107099,19 +108118,19 @@</span>
  #define STAT_GET_NDLT  4          /* &quot;ndlt&quot; column of stat[34] entry */
  
  /*
  ** Implementation of the stat_get(P,J) SQL function.  This routine is
  ** used to query statistical information that has been gathered into
<span class="udiff-line-modified-removed">- ** the Stat4Accum object by prior calls to stat_push().  The P parameter</span>
<span class="udiff-line-modified-removed">- ** has type BLOB but it is really just a pointer to the Stat4Accum object.</span>
<span class="udiff-line-modified-added">+ ** the StatAccum object by prior calls to stat_push().  The P parameter</span>
<span class="udiff-line-modified-added">+ ** has type BLOB but it is really just a pointer to the StatAccum object.</span>
  ** The content to returned is determined by the parameter J
  ** which is one of the STAT_GET_xxxx values defined above.
  **
  ** The stat_get(P,J) function is not available to generic SQL.  It is
  ** inserted as part of a manually constructed bytecode program.  (See
  ** the callStatGet() routine below.)  It is guaranteed that the P
<span class="udiff-line-modified-removed">- ** parameter will always be a poiner to a Stat4Accum object, never a</span>
<span class="udiff-line-modified-added">+ ** parameter will always be a pointer to a StatAccum object, never a</span>
  ** NULL.
  **
  ** If STAT4 is not enabled, then J is always
  ** STAT_GET_STAT1 and is hence omitted and this routine becomes
  ** a one-parameter function, stat_get(P), that always returns the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -107120,19 +108139,20 @@</span>
  static void statGet(
    sqlite3_context *context,
    int argc,
    sqlite3_value **argv
  ){
<span class="udiff-line-modified-removed">-   Stat4Accum *p = (Stat4Accum*)sqlite3_value_blob(argv[0]);</span>
<span class="udiff-line-modified-added">+   StatAccum *p = (StatAccum*)sqlite3_value_blob(argv[0]);</span>
  #ifdef SQLITE_ENABLE_STAT4
    /* STAT4 has a parameter on this routine. */
    int eCall = sqlite3_value_int(argv[1]);
    assert( argc==2 );
    assert( eCall==STAT_GET_STAT1 || eCall==STAT_GET_NEQ
         || eCall==STAT_GET_ROWID || eCall==STAT_GET_NLT
         || eCall==STAT_GET_NDLT
    );
<span class="udiff-line-added">+   assert( eCall==STAT_GET_STAT1 || p-&gt;mxSample );</span>
    if( eCall==STAT_GET_STAT1 )
  #else
    assert( argc==1 );
  #endif
    {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -107141,11 +108161,11 @@</span>
      **
      ** The value is a string composed of a list of integers describing
      ** the index. The first integer in the list is the total number of
      ** entries in the index. There is one additional integer in the list
      ** for each indexed column. This additional integer is an estimate of
<span class="udiff-line-modified-removed">-     ** the number of rows matched by a stabbing query on the index using</span>
<span class="udiff-line-modified-added">+     ** the number of rows matched by a equality query on the index using</span>
      ** a key with the corresponding number of fields. In other words,
      ** if the index is on columns (a,b) and the sqlite_stat1 value is
      ** &quot;100 10 2&quot;, then SQLite estimates that:
      **
      **   * the index contains 100 rows,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -107164,11 +108184,12 @@</span>
      if( zRet==0 ){
        sqlite3_result_error_nomem(context);
        return;
      }
  
<span class="udiff-line-modified-removed">-     sqlite3_snprintf(24, zRet, &quot;%llu&quot;, (u64)p-&gt;nRow);</span>
<span class="udiff-line-modified-added">+     sqlite3_snprintf(24, zRet, &quot;%llu&quot;,</span>
<span class="udiff-line-added">+         p-&gt;nSkipAhead ? (u64)p-&gt;nEst : (u64)p-&gt;nRow);</span>
      z = zRet + sqlite3Strlen30(zRet);
      for(i=0; i&lt;p-&gt;nKeyCol; i++){
        u64 nDistinct = p-&gt;current.anDLt[i] + 1;
        u64 iVal = (p-&gt;nRow + nDistinct - 1) / nDistinct;
        sqlite3_snprintf(24, z, &quot; %llu&quot;, iVal);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -107184,11 +108205,11 @@</span>
      if( p-&gt;iGet&lt;0 ){
        samplePushPrevious(p, 0);
        p-&gt;iGet = 0;
      }
      if( p-&gt;iGet&lt;p-&gt;nSample ){
<span class="udiff-line-modified-removed">-       Stat4Sample *pS = p-&gt;a + p-&gt;iGet;</span>
<span class="udiff-line-modified-added">+       StatSample *pS = p-&gt;a + p-&gt;iGet;</span>
        if( pS-&gt;nRowid==0 ){
          sqlite3_result_int64(context, pS-&gt;u.iRowid);
        }else{
          sqlite3_result_blob(context, pS-&gt;u.aRowid, pS-&gt;nRowid,
                              SQLITE_TRANSIENT);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -107240,20 +108261,20 @@</span>
    0, 0,            /* xValue, xInverse */
    &quot;stat_get&quot;,      /* zName */
    {0}
  };
  
<span class="udiff-line-modified-removed">- static void callStatGet(Parse *pParse, int regStat4, int iParam, int regOut){</span>
<span class="udiff-line-modified-added">+ static void callStatGet(Parse *pParse, int regStat, int iParam, int regOut){</span>
  #ifdef SQLITE_ENABLE_STAT4
<span class="udiff-line-modified-removed">-   sqlite3VdbeAddOp2(pParse-&gt;pVdbe, OP_Integer, iParam, regStat4+1);</span>
<span class="udiff-line-modified-added">+   sqlite3VdbeAddOp2(pParse-&gt;pVdbe, OP_Integer, iParam, regStat+1);</span>
  #elif SQLITE_DEBUG
    assert( iParam==STAT_GET_STAT1 );
  #else
    UNUSED_PARAMETER( iParam );
  #endif
<span class="udiff-line-modified-removed">-   assert( regOut!=regStat4 &amp;&amp; regOut!=regStat4+1 );</span>
<span class="udiff-line-modified-removed">-   sqlite3VdbeAddFunctionCall(pParse, 0, regStat4, regOut, 1+IsStat4,</span>
<span class="udiff-line-modified-added">+   assert( regOut!=regStat &amp;&amp; regOut!=regStat+1 );</span>
<span class="udiff-line-modified-added">+   sqlite3VdbeAddFunctionCall(pParse, 0, regStat, regOut, 1+IsStat4,</span>
                               &amp;statGetFuncdef, 0);
  }
  
  /*
  ** Generate code to do an analysis of all indices associated with
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -107275,16 +108296,15 @@</span>
    int i;                       /* Loop counter */
    int jZeroRows = -1;          /* Jump from here if number of rows is zero */
    int iDb;                     /* Index of database containing pTab */
    u8 needTableCnt = 1;         /* True to count the table */
    int regNewRowid = iMem++;    /* Rowid for the inserted record */
<span class="udiff-line-modified-removed">-   int regStat4 = iMem++;       /* Register to hold Stat4Accum object */</span>
<span class="udiff-line-modified-added">+   int regStat = iMem++;        /* Register to hold StatAccum object */</span>
    int regChng = iMem++;        /* Index of changed index field */
<span class="udiff-line-removed">- #ifdef SQLITE_ENABLE_STAT4</span>
    int regRowid = iMem++;       /* Rowid argument passed to stat_push() */
<span class="udiff-line-removed">- #endif</span>
    int regTemp = iMem++;        /* Temporary use register */
<span class="udiff-line-added">+   int regTemp2 = iMem++;       /* Second temporary use register */</span>
    int regTabname = iMem++;     /* Register containing table name */
    int regIdxname = iMem++;     /* Register containing index name */
    int regStat1 = iMem++;       /* Value for the stat column of sqlite_stat1 */
    int regPrev = iMem;          /* MUST BE LAST (see below) */
  #ifdef SQLITE_ENABLE_PREUPDATE_HOOK
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -107408,33 +108428,40 @@</span>
      /* Invoke the stat_init() function. The arguments are:
      **
      **    (1) the number of columns in the index including the rowid
      **        (or for a WITHOUT ROWID table, the number of PK columns),
      **    (2) the number of columns in the key without the rowid/pk
<span class="udiff-line-modified-removed">-     **    (3) the number of rows in the index,</span>
<span class="udiff-line-removed">-     **</span>
<span class="udiff-line-removed">-     **</span>
<span class="udiff-line-removed">-     ** The third argument is only used for STAT4</span>
<span class="udiff-line-modified-added">+     **    (3) estimated number of rows in the index,</span>
      */
<span class="udiff-line-added">+     sqlite3VdbeAddOp2(v, OP_Integer, nCol, regStat+1);</span>
<span class="udiff-line-added">+     assert( regRowid==regStat+2 );</span>
<span class="udiff-line-added">+     sqlite3VdbeAddOp2(v, OP_Integer, pIdx-&gt;nKeyCol, regRowid);</span>
  #ifdef SQLITE_ENABLE_STAT4
<span class="udiff-line-modified-removed">-     sqlite3VdbeAddOp2(v, OP_Count, iIdxCur, regStat4+3);</span>
<span class="udiff-line-modified-added">+     if( OptimizationEnabled(db, SQLITE_Stat4) ){</span>
<span class="udiff-line-added">+       sqlite3VdbeAddOp2(v, OP_Count, iIdxCur, regTemp);</span>
<span class="udiff-line-added">+       addrRewind = sqlite3VdbeAddOp1(v, OP_Rewind, iIdxCur);</span>
<span class="udiff-line-added">+       VdbeCoverage(v);</span>
<span class="udiff-line-added">+     }else</span>
  #endif
<span class="udiff-line-modified-removed">-     sqlite3VdbeAddOp2(v, OP_Integer, nCol, regStat4+1);</span>
<span class="udiff-line-modified-removed">-     sqlite3VdbeAddOp2(v, OP_Integer, pIdx-&gt;nKeyCol, regStat4+2);</span>
<span class="udiff-line-modified-removed">-     sqlite3VdbeAddFunctionCall(pParse, 0, regStat4+1, regStat4, 2+IsStat4,</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       addrRewind = sqlite3VdbeAddOp1(v, OP_Rewind, iIdxCur);</span>
<span class="udiff-line-modified-added">+       VdbeCoverage(v);</span>
<span class="udiff-line-added">+       sqlite3VdbeAddOp3(v, OP_Count, iIdxCur, regTemp, 1);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     assert( regTemp2==regStat+4 );</span>
<span class="udiff-line-added">+     sqlite3VdbeAddOp2(v, OP_Integer, db-&gt;nAnalysisLimit, regTemp2);</span>
<span class="udiff-line-added">+     sqlite3VdbeAddFunctionCall(pParse, 0, regStat+1, regStat, 4,</span>
                                 &amp;statInitFuncdef, 0);
  
      /* Implementation of the following:
      **
      **   Rewind csr
      **   if eof(csr) goto end_of_scan;
      **   regChng = 0
      **   goto next_push_0;
      **
      */
<span class="udiff-line-removed">-     addrRewind = sqlite3VdbeAddOp1(v, OP_Rewind, iIdxCur);</span>
<span class="udiff-line-removed">-     VdbeCoverage(v);</span>
      sqlite3VdbeAddOp2(v, OP_Integer, 0, regChng);
      addrNextRow = sqlite3VdbeCurrentAddr(v);
  
      if( nColTest&gt;0 ){
        int endDistinctTest = sqlite3VdbeMakeLabel(pParse);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -107463,10 +108490,11 @@</span>
        }
        for(i=0; i&lt;nColTest; i++){
          char *pColl = (char*)sqlite3LocateCollSeq(pParse, pIdx-&gt;azColl[i]);
          sqlite3VdbeAddOp2(v, OP_Integer, i, regChng);
          sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, i, regTemp);
<span class="udiff-line-added">+         VdbeComment((v, &quot;%s.column(%d)&quot;, pIdx-&gt;zName, i));</span>
          aGotoChng[i] =
          sqlite3VdbeAddOp4(v, OP_Ne, regTemp, 0, regPrev+i, pColl, P4_COLLSEQ);
          sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);
          VdbeCoverage(v);
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -107483,10 +108511,11 @@</span>
        */
        sqlite3VdbeJumpHere(v, addrNextRow-1);
        for(i=0; i&lt;nColTest; i++){
          sqlite3VdbeJumpHere(v, aGotoChng[i]);
          sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, i, regPrev+i);
<span class="udiff-line-added">+         VdbeComment((v, &quot;%s.column(%d)&quot;, pIdx-&gt;zName, i));</span>
        }
        sqlite3VdbeResolveLabel(v, endDistinctTest);
        sqlite3DbFree(db, aGotoChng);
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -107496,34 +108525,50 @@</span>
      **   stat_push(P, regChng, regRowid)  // 3rd parameter STAT4 only
      **   Next csr
      **   if !eof(csr) goto next_row;
      */
  #ifdef SQLITE_ENABLE_STAT4
<span class="udiff-line-modified-removed">-     assert( regRowid==(regStat4+2) );</span>
<span class="udiff-line-modified-removed">-     if( HasRowid(pTab) ){</span>
<span class="udiff-line-modified-removed">-       sqlite3VdbeAddOp2(v, OP_IdxRowid, iIdxCur, regRowid);</span>
<span class="udiff-line-modified-removed">-     }else{</span>
<span class="udiff-line-modified-removed">-       Index *pPk = sqlite3PrimaryKeyIndex(pIdx-&gt;pTable);</span>
<span class="udiff-line-modified-removed">-       int j, k, regKey;</span>
<span class="udiff-line-modified-removed">-       regKey = sqlite3GetTempRange(pParse, pPk-&gt;nKeyCol);</span>
<span class="udiff-line-modified-removed">-       for(j=0; j&lt;pPk-&gt;nKeyCol; j++){</span>
<span class="udiff-line-modified-removed">-         k = sqlite3TableColumnToIndex(pIdx, pPk-&gt;aiColumn[j]);</span>
<span class="udiff-line-modified-removed">-         assert( k&gt;=0 &amp;&amp; k&lt;pIdx-&gt;nColumn );</span>
<span class="udiff-line-modified-removed">-         sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, k, regKey+j);</span>
<span class="udiff-line-modified-removed">-         VdbeComment((v, &quot;%s&quot;, pTab-&gt;aCol[pPk-&gt;aiColumn[j]].zName));</span>
<span class="udiff-line-modified-added">+     if( OptimizationEnabled(db, SQLITE_Stat4) ){</span>
<span class="udiff-line-modified-added">+       assert( regRowid==(regStat+2) );</span>
<span class="udiff-line-modified-added">+       if( HasRowid(pTab) ){</span>
<span class="udiff-line-modified-added">+         sqlite3VdbeAddOp2(v, OP_IdxRowid, iIdxCur, regRowid);</span>
<span class="udiff-line-modified-added">+       }else{</span>
<span class="udiff-line-modified-added">+         Index *pPk = sqlite3PrimaryKeyIndex(pIdx-&gt;pTable);</span>
<span class="udiff-line-modified-added">+         int j, k, regKey;</span>
<span class="udiff-line-modified-added">+         regKey = sqlite3GetTempRange(pParse, pPk-&gt;nKeyCol);</span>
<span class="udiff-line-modified-added">+         for(j=0; j&lt;pPk-&gt;nKeyCol; j++){</span>
<span class="udiff-line-modified-added">+           k = sqlite3TableColumnToIndex(pIdx, pPk-&gt;aiColumn[j]);</span>
<span class="udiff-line-modified-added">+           assert( k&gt;=0 &amp;&amp; k&lt;pIdx-&gt;nColumn );</span>
<span class="udiff-line-modified-added">+           sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, k, regKey+j);</span>
<span class="udiff-line-added">+           VdbeComment((v, &quot;%s.column(%d)&quot;, pIdx-&gt;zName, i));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         sqlite3VdbeAddOp3(v, OP_MakeRecord, regKey, pPk-&gt;nKeyCol, regRowid);</span>
<span class="udiff-line-added">+         sqlite3ReleaseTempRange(pParse, regKey, pPk-&gt;nKeyCol);</span>
        }
<span class="udiff-line-removed">-       sqlite3VdbeAddOp3(v, OP_MakeRecord, regKey, pPk-&gt;nKeyCol, regRowid);</span>
<span class="udiff-line-removed">-       sqlite3ReleaseTempRange(pParse, regKey, pPk-&gt;nKeyCol);</span>
      }
  #endif
<span class="udiff-line-modified-removed">-     assert( regChng==(regStat4+1) );</span>
<span class="udiff-line-modified-removed">-     sqlite3VdbeAddFunctionCall(pParse, 1, regStat4, regTemp, 2+IsStat4,</span>
<span class="udiff-line-modified-removed">-                                &amp;statPushFuncdef, 0);</span>
<span class="udiff-line-modified-removed">-     sqlite3VdbeAddOp2(v, OP_Next, iIdxCur, addrNextRow); VdbeCoverage(v);</span>
<span class="udiff-line-modified-added">+     assert( regChng==(regStat+1) );</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       sqlite3VdbeAddFunctionCall(pParse, 1, regStat, regTemp, 2+IsStat4,</span>
<span class="udiff-line-modified-added">+                                  &amp;statPushFuncdef, 0);</span>
<span class="udiff-line-added">+       if( db-&gt;nAnalysisLimit ){</span>
<span class="udiff-line-added">+         int j1, j2, j3;</span>
<span class="udiff-line-added">+         j1 = sqlite3VdbeAddOp1(v, OP_IsNull, regTemp); VdbeCoverage(v);</span>
<span class="udiff-line-added">+         j2 = sqlite3VdbeAddOp1(v, OP_If, regTemp); VdbeCoverage(v);</span>
<span class="udiff-line-added">+         j3 = sqlite3VdbeAddOp4Int(v, OP_SeekGT, iIdxCur, 0, regPrev, 1);</span>
<span class="udiff-line-added">+         VdbeCoverage(v);</span>
<span class="udiff-line-added">+         sqlite3VdbeJumpHere(v, j1);</span>
<span class="udiff-line-added">+         sqlite3VdbeAddOp2(v, OP_Next, iIdxCur, addrNextRow); VdbeCoverage(v);</span>
<span class="udiff-line-added">+         sqlite3VdbeJumpHere(v, j2);</span>
<span class="udiff-line-added">+         sqlite3VdbeJumpHere(v, j3);</span>
<span class="udiff-line-added">+       }else{</span>
<span class="udiff-line-added">+         sqlite3VdbeAddOp2(v, OP_Next, iIdxCur, addrNextRow); VdbeCoverage(v);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
  
      /* Add the entry to the stat1 table. */
<span class="udiff-line-modified-removed">-     callStatGet(pParse, regStat4, STAT_GET_STAT1, regStat1);</span>
<span class="udiff-line-modified-added">+     callStatGet(pParse, regStat, STAT_GET_STAT1, regStat1);</span>
      assert( &quot;BBB&quot;[0]==SQLITE_AFF_TEXT );
      sqlite3VdbeAddOp4(v, OP_MakeRecord, regTabname, 3, regTemp, &quot;BBB&quot;, 0);
      sqlite3VdbeAddOp2(v, OP_NewRowid, iStatCur, regNewRowid);
      sqlite3VdbeAddOp3(v, OP_Insert, iStatCur, regTemp, regNewRowid);
  #ifdef SQLITE_ENABLE_PREUPDATE_HOOK
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -107531,11 +108576,11 @@</span>
  #endif
      sqlite3VdbeChangeP5(v, OPFLAG_APPEND);
  
      /* Add the entries to the stat4 table. */
  #ifdef SQLITE_ENABLE_STAT4
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-added">+     if( OptimizationEnabled(db, SQLITE_Stat4) &amp;&amp; db-&gt;nAnalysisLimit==0 ){</span>
        int regEq = regStat1;
        int regLt = regStat1+1;
        int regDLt = regStat1+2;
        int regSample = regStat1+3;
        int regCol = regStat1+4;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -107545,16 +108590,16 @@</span>
        u8 seekOp = HasRowid(pTab) ? OP_NotExists : OP_NotFound;
  
        pParse-&gt;nMem = MAX(pParse-&gt;nMem, regCol+nCol);
  
        addrNext = sqlite3VdbeCurrentAddr(v);
<span class="udiff-line-modified-removed">-       callStatGet(pParse, regStat4, STAT_GET_ROWID, regSampleRowid);</span>
<span class="udiff-line-modified-added">+       callStatGet(pParse, regStat, STAT_GET_ROWID, regSampleRowid);</span>
        addrIsNull = sqlite3VdbeAddOp1(v, OP_IsNull, regSampleRowid);
        VdbeCoverage(v);
<span class="udiff-line-modified-removed">-       callStatGet(pParse, regStat4, STAT_GET_NEQ, regEq);</span>
<span class="udiff-line-modified-removed">-       callStatGet(pParse, regStat4, STAT_GET_NLT, regLt);</span>
<span class="udiff-line-modified-removed">-       callStatGet(pParse, regStat4, STAT_GET_NDLT, regDLt);</span>
<span class="udiff-line-modified-added">+       callStatGet(pParse, regStat, STAT_GET_NEQ, regEq);</span>
<span class="udiff-line-modified-added">+       callStatGet(pParse, regStat, STAT_GET_NLT, regLt);</span>
<span class="udiff-line-modified-added">+       callStatGet(pParse, regStat, STAT_GET_NDLT, regDLt);</span>
        sqlite3VdbeAddOp4Int(v, seekOp, iTabCur, addrNext, regSampleRowid, 0);
        VdbeCoverage(v);
        for(i=0; i&lt;nCol; i++){
          sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, iTabCur, i, regCol+i);
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -108244,10 +109289,21 @@</span>
      }
    }
    return rc;
  }
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Return true if zName points to a name that may be used to refer to</span>
<span class="udiff-line-added">+ ** database iDb attached to handle db.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE int sqlite3DbIsNamed(sqlite3 *db, int iDb, const char *zName){</span>
<span class="udiff-line-added">+   return (</span>
<span class="udiff-line-added">+       sqlite3StrICmp(db-&gt;aDb[iDb].zDbSName, zName)==0</span>
<span class="udiff-line-added">+    || (iDb==0 &amp;&amp; sqlite3StrICmp(&quot;main&quot;, zName)==0)</span>
<span class="udiff-line-added">+   );</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /*
  ** An SQL user-function registered to do the work of an ATTACH statement. The
  ** three arguments to the function come directly from an attach statement:
  **
  **     ATTACH DATABASE x AS y KEY z
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -108316,13 +109372,12 @@</span>
          db-&gt;aLimit[SQLITE_LIMIT_ATTACHED]
        );
        goto attach_error;
      }
      for(i=0; i&lt;db-&gt;nDb; i++){
<span class="udiff-line-modified-removed">-       char *z = db-&gt;aDb[i].zDbSName;</span>
<span class="udiff-line-modified-removed">-       assert( z &amp;&amp; zName );</span>
<span class="udiff-line-removed">-       if( sqlite3StrICmp(z, zName)==0 ){</span>
<span class="udiff-line-modified-added">+       assert( zName );</span>
<span class="udiff-line-modified-added">+       if( sqlite3DbIsNamed(db, i, zName) ){</span>
          zErrDyn = sqlite3MPrintf(db, &quot;database %s is already in use&quot;, zName);
          goto attach_error;
        }
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -108386,47 +109441,11 @@</span>
    }
    pNew-&gt;safety_level = SQLITE_DEFAULT_SYNCHRONOUS+1;
    if( rc==SQLITE_OK &amp;&amp; pNew-&gt;zDbSName==0 ){
      rc = SQLITE_NOMEM_BKPT;
    }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">-   if( rc==SQLITE_OK ){</span>
<span class="udiff-line-removed">-     extern int sqlite3CodecAttach(sqlite3*, int, const void*, int);</span>
<span class="udiff-line-removed">-     extern void sqlite3CodecGetKey(sqlite3*, int, void**, int*);</span>
<span class="udiff-line-removed">-     int nKey;</span>
<span class="udiff-line-removed">-     char *zKey;</span>
<span class="udiff-line-removed">-     int t = sqlite3_value_type(argv[2]);</span>
<span class="udiff-line-removed">-     switch( t ){</span>
<span class="udiff-line-removed">-       case SQLITE_INTEGER:</span>
<span class="udiff-line-removed">-       case SQLITE_FLOAT:</span>
<span class="udiff-line-removed">-         zErrDyn = sqlite3DbStrDup(db, &quot;Invalid key value&quot;);</span>
<span class="udiff-line-removed">-         rc = SQLITE_ERROR;</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       case SQLITE_TEXT:</span>
<span class="udiff-line-removed">-       case SQLITE_BLOB:</span>
<span class="udiff-line-removed">-         nKey = sqlite3_value_bytes(argv[2]);</span>
<span class="udiff-line-removed">-         zKey = (char *)sqlite3_value_blob(argv[2]);</span>
<span class="udiff-line-removed">-         rc = sqlite3CodecAttach(db, db-&gt;nDb-1, zKey, nKey);</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       case SQLITE_NULL:</span>
<span class="udiff-line-removed">-         /* No key specified.  Use the key from URI filename, or if none,</span>
<span class="udiff-line-removed">-         ** use the key from the main database. */</span>
<span class="udiff-line-removed">-         if( sqlite3CodecQueryParameters(db, zName, zPath)==0 ){</span>
<span class="udiff-line-removed">-           sqlite3CodecGetKey(db, 0, (void**)&amp;zKey, &amp;nKey);</span>
<span class="udiff-line-removed">-           if( nKey || sqlite3BtreeGetOptimalReserve(db-&gt;aDb[0].pBt)&gt;0 ){</span>
<span class="udiff-line-removed">-             rc = sqlite3CodecAttach(db, db-&gt;nDb-1, zKey, nKey);</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-   sqlite3_free( zPath );</span>
<span class="udiff-line-modified-added">+   sqlite3_free_filename( zPath );</span>
  
    /* If the file was opened successfully, read the schema for the new database.
    ** If this fails, or if opening the file failed, then close the file and
    ** remove the entry from the db-&gt;aDb[] array. i.e. put everything back the
    ** way we found it.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -108507,11 +109526,11 @@</span>
  
    if( zName==0 ) zName = &quot;&quot;;
    for(i=0; i&lt;db-&gt;nDb; i++){
      pDb = &amp;db-&gt;aDb[i];
      if( pDb-&gt;pBt==0 ) continue;
<span class="udiff-line-modified-removed">-     if( sqlite3StrICmp(pDb-&gt;zDbSName, zName)==0 ) break;</span>
<span class="udiff-line-modified-added">+     if( sqlite3DbIsNamed(db, i, zName) ) break;</span>
    }
  
    if( i&gt;=db-&gt;nDb ){
      sqlite3_snprintf(sizeof(zErr),zErr, &quot;no such database: %s&quot;, zName);
      goto detach_error;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -108698,24 +109717,25 @@</span>
  SQLITE_PRIVATE int sqlite3FixSrcList(
    DbFixer *pFix,       /* Context of the fixation */
    SrcList *pList       /* The Source list to check and modify */
  ){
    int i;
<span class="udiff-line-removed">-   const char *zDb;</span>
    struct SrcList_item *pItem;
<span class="udiff-line-added">+   sqlite3 *db = pFix-&gt;pParse-&gt;db;</span>
<span class="udiff-line-added">+   int iDb = sqlite3FindDbName(db, pFix-&gt;zDb);</span>
  
    if( NEVER(pList==0) ) return 0;
<span class="udiff-line-modified-removed">-   zDb = pFix-&gt;zDb;</span>
<span class="udiff-line-modified-added">+ </span>
    for(i=0, pItem=pList-&gt;a; i&lt;pList-&gt;nSrc; i++, pItem++){
      if( pFix-&gt;bTemp==0 ){
<span class="udiff-line-modified-removed">-       if( pItem-&gt;zDatabase &amp;&amp; sqlite3StrICmp(pItem-&gt;zDatabase, zDb) ){</span>
<span class="udiff-line-modified-added">+       if( pItem-&gt;zDatabase &amp;&amp; iDb!=sqlite3FindDbName(db, pItem-&gt;zDatabase) ){</span>
          sqlite3ErrorMsg(pFix-&gt;pParse,
              &quot;%s %T cannot reference objects in database %s&quot;,
              pFix-&gt;zType, pFix-&gt;pName, pItem-&gt;zDatabase);
          return 1;
        }
<span class="udiff-line-modified-removed">-       sqlite3DbFree(pFix-&gt;pParse-&gt;db, pItem-&gt;zDatabase);</span>
<span class="udiff-line-modified-added">+       sqlite3DbFree(db, pItem-&gt;zDatabase);</span>
        pItem-&gt;zDatabase = 0;
        pItem-&gt;pSchema = pFix-&gt;pSchema;
        pItem-&gt;fg.fromDDL = 1;
      }
  #if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -109328,16 +110348,25 @@</span>
  
        /* Initialize any AUTOINCREMENT data structures required.
        */
        sqlite3AutoincrementBegin(pParse);
  
<span class="udiff-line-modified-removed">-       /* Code constant expressions that where factored out of inner loops */</span>
<span class="udiff-line-modified-added">+       /* Code constant expressions that where factored out of inner loops.</span>
<span class="udiff-line-added">+       **</span>
<span class="udiff-line-added">+       ** The pConstExpr list might also contain expressions that we simply</span>
<span class="udiff-line-added">+       ** want to keep around until the Parse object is deleted.  Such</span>
<span class="udiff-line-added">+       ** expressions have iConstExprReg==0.  Do not generate code for</span>
<span class="udiff-line-added">+       ** those expressions, of course.</span>
<span class="udiff-line-added">+       */</span>
        if( pParse-&gt;pConstExpr ){
          ExprList *pEL = pParse-&gt;pConstExpr;
          pParse-&gt;okConstFactor = 0;
          for(i=0; i&lt;pEL-&gt;nExpr; i++){
<span class="udiff-line-modified-removed">-           sqlite3ExprCode(pParse, pEL-&gt;a[i].pExpr, pEL-&gt;a[i].u.iConstExprReg);</span>
<span class="udiff-line-modified-added">+           int iReg = pEL-&gt;a[i].u.iConstExprReg;</span>
<span class="udiff-line-added">+           if( iReg&gt;0 ){</span>
<span class="udiff-line-added">+             sqlite3ExprCode(pParse, pEL-&gt;a[i].pExpr, iReg);</span>
<span class="udiff-line-added">+           }</span>
          }
        }
  
        /* Finally, jump back to the beginning of the executable code. */
        sqlite3VdbeGoto(v, 1);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -109433,26 +110462,43 @@</span>
    ** exists */
    if( db-&gt;auth.authLevel&lt;UAUTH_Admin &amp;&amp; sqlite3UserAuthTable(zName)!=0 ){
      return 0;
    }
  #endif
<span class="udiff-line-modified-removed">-   while(1){</span>
<span class="udiff-line-modified-removed">-     for(i=OMIT_TEMPDB; i&lt;db-&gt;nDb; i++){</span>
<span class="udiff-line-modified-removed">-       int j = (i&lt;2) ? i^1 : i;   /* Search TEMP before MAIN */</span>
<span class="udiff-line-modified-removed">-       if( zDatabase==0 || sqlite3StrICmp(zDatabase, db-&gt;aDb[j].zDbSName)==0 ){</span>
<span class="udiff-line-modified-removed">-         assert( sqlite3SchemaMutexHeld(db, j, 0) );</span>
<span class="udiff-line-modified-removed">-         p = sqlite3HashFind(&amp;db-&gt;aDb[j].pSchema-&gt;tblHash, zName);</span>
<span class="udiff-line-modified-removed">-         if( p ) return p;</span>
<span class="udiff-line-modified-added">+   if( zDatabase ){</span>
<span class="udiff-line-modified-added">+     for(i=0; i&lt;db-&gt;nDb; i++){</span>
<span class="udiff-line-modified-added">+       if( sqlite3StrICmp(zDatabase, db-&gt;aDb[i].zDbSName)==0 ) break;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     if( i&gt;=db-&gt;nDb ){</span>
<span class="udiff-line-modified-added">+       /* No match against the official names.  But always match &quot;main&quot;</span>
<span class="udiff-line-modified-added">+       ** to schema 0 as a legacy fallback. */</span>
<span class="udiff-line-added">+       if( sqlite3StrICmp(zDatabase,&quot;main&quot;)==0 ){</span>
<span class="udiff-line-added">+         i = 0;</span>
<span class="udiff-line-added">+       }else{</span>
<span class="udiff-line-added">+         return 0;</span>
        }
      }
<span class="udiff-line-modified-removed">-     /* Not found.  If the name we were looking for was temp.sqlite_master</span>
<span class="udiff-line-modified-removed">-     ** then change the name to sqlite_temp_master and try again. */</span>
<span class="udiff-line-modified-removed">-     if( sqlite3StrICmp(zName, MASTER_NAME)!=0 ) break;</span>
<span class="udiff-line-modified-removed">-     if( sqlite3_stricmp(zDatabase, db-&gt;aDb[1].zDbSName)!=0 ) break;</span>
<span class="udiff-line-modified-removed">-     zName = TEMP_MASTER_NAME;</span>
<span class="udiff-line-modified-added">+     p = sqlite3HashFind(&amp;db-&gt;aDb[i].pSchema-&gt;tblHash, zName);</span>
<span class="udiff-line-modified-added">+     if( p==0 &amp;&amp; i==1 &amp;&amp; sqlite3StrICmp(zName, MASTER_NAME)==0 ){</span>
<span class="udiff-line-modified-added">+       /* All temp.sqlite_master to be an alias for sqlite_temp_master */</span>
<span class="udiff-line-modified-added">+       p = sqlite3HashFind(&amp;db-&gt;aDb[1].pSchema-&gt;tblHash, TEMP_MASTER_NAME);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-added">+   }else{</span>
<span class="udiff-line-added">+     /* Match against TEMP first */</span>
<span class="udiff-line-added">+     p = sqlite3HashFind(&amp;db-&gt;aDb[1].pSchema-&gt;tblHash, zName);</span>
<span class="udiff-line-added">+     if( p ) return p;</span>
<span class="udiff-line-added">+     /* The main database is second */</span>
<span class="udiff-line-added">+     p = sqlite3HashFind(&amp;db-&gt;aDb[0].pSchema-&gt;tblHash, zName);</span>
<span class="udiff-line-added">+     if( p ) return p;</span>
<span class="udiff-line-added">+     /* Attached databases are in order of attachment */</span>
<span class="udiff-line-added">+     for(i=2; i&lt;db-&gt;nDb; i++){</span>
<span class="udiff-line-added">+       assert( sqlite3SchemaMutexHeld(db, i, 0) );</span>
<span class="udiff-line-added">+       p = sqlite3HashFind(&amp;db-&gt;aDb[i].pSchema-&gt;tblHash, zName);</span>
<span class="udiff-line-added">+       if( p ) break;</span>
<span class="udiff-line-added">+     }</span>
    }
<span class="udiff-line-modified-removed">-   return 0;</span>
<span class="udiff-line-modified-added">+   return p;</span>
  }
  
  /*
  ** Locate the in-memory structure that describes a particular database
  ** table given the name of that table and (optionally) the name of the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -109558,11 +110604,11 @@</span>
    assert( zDb!=0 || sqlite3BtreeHoldsAllMutexes(db) );
    for(i=OMIT_TEMPDB; i&lt;db-&gt;nDb; i++){
      int j = (i&lt;2) ? i^1 : i;  /* Search TEMP before MAIN */
      Schema *pSchema = db-&gt;aDb[j].pSchema;
      assert( pSchema );
<span class="udiff-line-modified-removed">-     if( zDb &amp;&amp; sqlite3StrICmp(zDb, db-&gt;aDb[j].zDbSName) ) continue;</span>
<span class="udiff-line-modified-added">+     if( zDb &amp;&amp; sqlite3DbIsNamed(db, j, zDb)==0 ) continue;</span>
      assert( sqlite3SchemaMutexHeld(db, j, 0) );
      p = sqlite3HashFind(&amp;pSchema-&gt;idxHash, zName);
      if( p ) break;
    }
    return p;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -109711,10 +110757,11 @@</span>
    int i;
    Column *pCol;
    assert( pTable!=0 );
    if( (pCol = pTable-&gt;aCol)!=0 ){
      for(i=0; i&lt;pTable-&gt;nCol; i++, pCol++){
<span class="udiff-line-added">+       assert( pCol-&gt;zName==0 || pCol-&gt;hName==sqlite3StrIHash(pCol-&gt;zName) );</span>
        sqlite3DbFree(db, pCol-&gt;zName);
        sqlite3ExprDelete(db, pCol-&gt;pDflt);
        sqlite3DbFree(db, pCol-&gt;zColl);
      }
      sqlite3DbFree(db, pTable-&gt;aCol);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -110359,10 +111406,11 @@</span>
      p-&gt;aCol = aNew;
    }
    pCol = &amp;p-&gt;aCol[p-&gt;nCol];
    memset(pCol, 0, sizeof(p-&gt;aCol[0]));
    pCol-&gt;zName = z;
<span class="udiff-line-added">+   pCol-&gt;hName = sqlite3StrIHash(z);</span>
    sqlite3ColumnPropertiesFromName(p, pCol);
  
    if( pType-&gt;n==0 ){
      /* If there is no type specified, columns have the default affinity
      ** &#39;BLOB&#39; with a default size of 4 bytes. */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -111250,10 +112298,32 @@</span>
    assert( pPk-&gt;nColumn==j );
    assert( pTab-&gt;nNVCol&lt;=j );
    recomputeColumnsNotIndexed(pPk);
  }
  
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifndef SQLITE_OMIT_VIRTUALTABLE</span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Return true if pTab is a virtual table and zName is a shadow table name</span>
<span class="udiff-line-added">+ ** for that virtual table.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE int sqlite3IsShadowTableOf(sqlite3 *db, Table *pTab, const char *zName){</span>
<span class="udiff-line-added">+   int nName;                    /* Length of zName */</span>
<span class="udiff-line-added">+   Module *pMod;                 /* Module for the virtual table */</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if( !IsVirtual(pTab) ) return 0;</span>
<span class="udiff-line-added">+   nName = sqlite3Strlen30(pTab-&gt;zName);</span>
<span class="udiff-line-added">+   if( sqlite3_strnicmp(zName, pTab-&gt;zName, nName)!=0 ) return 0;</span>
<span class="udiff-line-added">+   if( zName[nName]!=&#39;_&#39; ) return 0;</span>
<span class="udiff-line-added">+   pMod = (Module*)sqlite3HashFind(&amp;db-&gt;aModule, pTab-&gt;azModuleArg[0]);</span>
<span class="udiff-line-added">+   if( pMod==0 ) return 0;</span>
<span class="udiff-line-added">+   if( pMod-&gt;pModule-&gt;iVersion&lt;3 ) return 0;</span>
<span class="udiff-line-added">+   if( pMod-&gt;pModule-&gt;xShadowName==0 ) return 0;</span>
<span class="udiff-line-added">+   return pMod-&gt;pModule-&gt;xShadowName(zName+nName+1);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #endif /* ifndef SQLITE_OMIT_VIRTUALTABLE */</span>
<span class="udiff-line-added">+ </span>
  #ifndef SQLITE_OMIT_VIRTUALTABLE
  /*
  ** Return true if zName is a shadow table name in the current database
  ** connection.
  **
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -111261,27 +112331,48 @@</span>
  ** restored to its original value prior to this routine returning.
  */
  SQLITE_PRIVATE int sqlite3ShadowTableName(sqlite3 *db, const char *zName){
    char *zTail;                  /* Pointer to the last &quot;_&quot; in zName */
    Table *pTab;                  /* Table that zName is a shadow of */
<span class="udiff-line-removed">-   Module *pMod;                 /* Module for the virtual table */</span>
<span class="udiff-line-removed">- </span>
    zTail = strrchr(zName, &#39;_&#39;);
    if( zTail==0 ) return 0;
    *zTail = 0;
    pTab = sqlite3FindTable(db, zName, 0);
    *zTail = &#39;_&#39;;
    if( pTab==0 ) return 0;
    if( !IsVirtual(pTab) ) return 0;
<span class="udiff-line-modified-removed">-   pMod = (Module*)sqlite3HashFind(&amp;db-&gt;aModule, pTab-&gt;azModuleArg[0]);</span>
<span class="udiff-line-removed">-   if( pMod==0 ) return 0;</span>
<span class="udiff-line-removed">-   if( pMod-&gt;pModule-&gt;iVersion&lt;3 ) return 0;</span>
<span class="udiff-line-removed">-   if( pMod-&gt;pModule-&gt;xShadowName==0 ) return 0;</span>
<span class="udiff-line-removed">-   return pMod-&gt;pModule-&gt;xShadowName(zTail+1);</span>
<span class="udiff-line-modified-added">+   return sqlite3IsShadowTableOf(db, pTab, zName);</span>
  }
  #endif /* ifndef SQLITE_OMIT_VIRTUALTABLE */
  
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef SQLITE_DEBUG</span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Mark all nodes of an expression as EP_Immutable, indicating that</span>
<span class="udiff-line-added">+ ** they should not be changed.  Expressions attached to a table or</span>
<span class="udiff-line-added">+ ** index definition are tagged this way to help ensure that we do</span>
<span class="udiff-line-added">+ ** not pass them into code generator routines by mistake.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static int markImmutableExprStep(Walker *pWalker, Expr *pExpr){</span>
<span class="udiff-line-added">+   ExprSetVVAProperty(pExpr, EP_Immutable);</span>
<span class="udiff-line-added">+   return WRC_Continue;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ static void markExprListImmutable(ExprList *pList){</span>
<span class="udiff-line-added">+   if( pList ){</span>
<span class="udiff-line-added">+     Walker w;</span>
<span class="udiff-line-added">+     memset(&amp;w, 0, sizeof(w));</span>
<span class="udiff-line-added">+     w.xExprCallback = markImmutableExprStep;</span>
<span class="udiff-line-added">+     w.xSelectCallback = sqlite3SelectWalkNoop;</span>
<span class="udiff-line-added">+     w.xSelectCallback2 = 0;</span>
<span class="udiff-line-added">+     sqlite3WalkExprList(&amp;w, pList);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+ #define markExprListImmutable(X)  /* no-op */</span>
<span class="udiff-line-added">+ #endif /* SQLITE_DEBUG */</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  /*
  ** This routine is called to report the final &quot;)&quot; that terminates
  ** a CREATE TABLE statement.
  **
  ** The table structure that other action routines have been building
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -111370,10 +112461,12 @@</span>
      if( pParse-&gt;nErr ){
        /* If errors are seen, delete the CHECK constraints now, else they might
        ** actually be used if PRAGMA writable_schema=ON is set. */
        sqlite3ExprListDelete(db, p-&gt;pCheck);
        p-&gt;pCheck = 0;
<span class="udiff-line-added">+     }else{</span>
<span class="udiff-line-added">+       markExprListImmutable(p-&gt;pCheck);</span>
      }
    }
  #endif /* !defined(SQLITE_OMIT_CHECK) */
  #ifndef SQLITE_OMIT_GENERATED_COLUMNS
    if( p-&gt;tabFlags &amp; TF_HasGenerated ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -113721,11 +114814,11 @@</span>
        pParse-&gt;rc = rc;
        return 1;
      }
      db-&gt;aDb[1].pBt = pBt;
      assert( db-&gt;aDb[1].pSchema );
<span class="udiff-line-modified-removed">-     if( SQLITE_NOMEM==sqlite3BtreeSetPageSize(pBt, db-&gt;nextPagesize, -1, 0) ){</span>
<span class="udiff-line-modified-added">+     if( SQLITE_NOMEM==sqlite3BtreeSetPageSize(pBt, db-&gt;nextPagesize, 0, 0) ){</span>
        sqlite3OomFault(db);
        return 1;
      }
    }
    return 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -113832,11 +114925,11 @@</span>
    char *p4,         /* Error message */
    i8 p4type,        /* P4_STATIC or P4_TRANSIENT */
    u8 p5Errmsg       /* P5_ErrMsg type */
  ){
    Vdbe *v = sqlite3GetVdbe(pParse);
<span class="udiff-line-modified-removed">-   assert( (errCode&amp;0xff)==SQLITE_CONSTRAINT );</span>
<span class="udiff-line-modified-added">+   assert( (errCode&amp;0xff)==SQLITE_CONSTRAINT || pParse-&gt;nested );</span>
    if( onError==OE_Abort ){
      sqlite3MayAbort(pParse);
    }
    sqlite3VdbeAddOp4(v, OP_Halt, errCode, onError, 0, p4, p4type);
    sqlite3VdbeChangeP5(v, p5Errmsg);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -114311,21 +115404,34 @@</span>
    u8 enc,               /* Desired text encoding */
    const char *zName,    /* Name of the collating sequence.  Might be NULL */
    int create            /* True to create CollSeq if doesn&#39;t already exist */
  ){
    CollSeq *pColl;
<span class="udiff-line-added">+   assert( SQLITE_UTF8==1 &amp;&amp; SQLITE_UTF16LE==2 &amp;&amp; SQLITE_UTF16BE==3 );</span>
<span class="udiff-line-added">+   assert( enc&gt;=SQLITE_UTF8 &amp;&amp; enc&lt;=SQLITE_UTF16BE );</span>
    if( zName ){
      pColl = findCollSeqEntry(db, zName, create);
<span class="udiff-line-added">+     if( pColl ) pColl += enc-1;</span>
    }else{
      pColl = db-&gt;pDfltColl;
    }
<span class="udiff-line-removed">-   assert( SQLITE_UTF8==1 &amp;&amp; SQLITE_UTF16LE==2 &amp;&amp; SQLITE_UTF16BE==3 );</span>
<span class="udiff-line-removed">-   assert( enc&gt;=SQLITE_UTF8 &amp;&amp; enc&lt;=SQLITE_UTF16BE );</span>
<span class="udiff-line-removed">-   if( pColl ) pColl += enc-1;</span>
    return pColl;
  }
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Change the text encoding for a database connection. This means that</span>
<span class="udiff-line-added">+ ** the pDfltColl must change as well.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE void sqlite3SetTextEncoding(sqlite3 *db, u8 enc){</span>
<span class="udiff-line-added">+   assert( enc==SQLITE_UTF8 || enc==SQLITE_UTF16LE || enc==SQLITE_UTF16BE );</span>
<span class="udiff-line-added">+   db-&gt;enc = enc;</span>
<span class="udiff-line-added">+   /* EVIDENCE-OF: R-08308-17224 The default collating function for all</span>
<span class="udiff-line-added">+   ** strings is BINARY.</span>
<span class="udiff-line-added">+   */</span>
<span class="udiff-line-added">+   db-&gt;pDfltColl = sqlite3FindCollSeq(db, enc, sqlite3StrBINARY, 0);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /*
  ** This function is responsible for invoking the collation factory callback
  ** or substituting a collation sequence of a different encoding when the
  ** requested collation sequence is not available in the desired encoding.
  **
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -115207,11 +116313,13 @@</span>
        testcase( IsVirtual(pTab) );
        sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenWrite, OPFLAG_FORDELETE,
                                   iTabCur, aToOpen, &amp;iDataCur, &amp;iIdxCur);
        assert( pPk || IsVirtual(pTab) || iDataCur==iTabCur );
        assert( pPk || IsVirtual(pTab) || iIdxCur==iDataCur+1 );
<span class="udiff-line-modified-removed">-       if( eOnePass==ONEPASS_MULTI ) sqlite3VdbeJumpHere(v, iAddrOnce);</span>
<span class="udiff-line-modified-added">+       if( eOnePass==ONEPASS_MULTI ){</span>
<span class="udiff-line-added">+         sqlite3VdbeJumpHereOrPopInst(v, iAddrOnce);</span>
<span class="udiff-line-added">+       }</span>
      }
  
      /* Set up a loop over the rowids/primary-keys that were found in the
      ** where-clause loop above.
      */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -115530,10 +116638,11 @@</span>
      VdbeModuleComment((v, &quot;GenRowIdxDel for %s&quot;, pIdx-&gt;zName));
      r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 1,
          &amp;iPartIdxLabel, pPrior, r1);
      sqlite3VdbeAddOp3(v, OP_IdxDelete, iIdxCur+i, r1,
          pIdx-&gt;uniqNotNull ? pIdx-&gt;nKeyCol : pIdx-&gt;nColumn);
<span class="udiff-line-added">+     sqlite3VdbeChangeP5(v, 1);  /* Cause IdxDelete to error if no entry found */</span>
      sqlite3ResolvePartIdxLabel(pParse, iPartIdxLabel);
      pPrior = pIdx;
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -116493,10 +117602,11 @@</span>
    const unsigned char *zA, *zB;
    u32 escape;
    int nPat;
    sqlite3 *db = sqlite3_context_db_handle(context);
    struct compareInfo *pInfo = sqlite3_user_data(context);
<span class="udiff-line-added">+   struct compareInfo backupInfo;</span>
  
  #ifdef SQLITE_LIKE_DOESNT_MATCH_BLOBS
    if( sqlite3_value_type(argv[0])==SQLITE_BLOB
     || sqlite3_value_type(argv[1])==SQLITE_BLOB
    ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -116528,10 +117638,16 @@</span>
        sqlite3_result_error(context,
            &quot;ESCAPE expression must be a single character&quot;, -1);
        return;
      }
      escape = sqlite3Utf8Read(&amp;zEsc);
<span class="udiff-line-added">+     if( escape==pInfo-&gt;matchAll || escape==pInfo-&gt;matchOne ){</span>
<span class="udiff-line-added">+       memcpy(&amp;backupInfo, pInfo, sizeof(backupInfo));</span>
<span class="udiff-line-added">+       pInfo = &amp;backupInfo;</span>
<span class="udiff-line-added">+       if( escape==pInfo-&gt;matchAll ) pInfo-&gt;matchAll = 0;</span>
<span class="udiff-line-added">+       if( escape==pInfo-&gt;matchOne ) pInfo-&gt;matchOne = 0;</span>
<span class="udiff-line-added">+     }</span>
    }else{
      escape = pInfo-&gt;matchSet;
    }
    zB = sqlite3_value_text(argv[0]);
    zA = sqlite3_value_text(argv[1]);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -116916,11 +118032,11 @@</span>
          if( (cntExpand&amp;(cntExpand-1))==0 ){
            /* Grow the size of the output buffer only on substitutions
            ** whose index is a power of two: 1, 2, 4, 8, 16, 32, ... */
            u8 *zOld;
            zOld = zOut;
<span class="udiff-line-modified-removed">-           zOut = sqlite3_realloc64(zOut, (int)nOut + (nOut - nStr - 1));</span>
<span class="udiff-line-modified-added">+           zOut = sqlite3Realloc(zOut, (int)nOut + (nOut - nStr - 1));</span>
            if( zOut==0 ){
              sqlite3_result_error_nomem(context);
              sqlite3_free(zOld);
              return;
            }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -117510,29 +118626,33 @@</span>
    if( pDef==0 ) return 0;
  #endif
    if( NEVER(pDef==0) || (pDef-&gt;funcFlags &amp; SQLITE_FUNC_LIKE)==0 ){
      return 0;
    }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   /* The memcpy() statement assumes that the wildcard characters are</span>
<span class="udiff-line-added">+   ** the first three statements in the compareInfo structure.  The</span>
<span class="udiff-line-added">+   ** asserts() that follow verify that assumption</span>
<span class="udiff-line-added">+   */</span>
<span class="udiff-line-added">+   memcpy(aWc, pDef-&gt;pUserData, 3);</span>
<span class="udiff-line-added">+   assert( (char*)&amp;likeInfoAlt == (char*)&amp;likeInfoAlt.matchAll );</span>
<span class="udiff-line-added">+   assert( &amp;((char*)&amp;likeInfoAlt)[1] == (char*)&amp;likeInfoAlt.matchOne );</span>
<span class="udiff-line-added">+   assert( &amp;((char*)&amp;likeInfoAlt)[2] == (char*)&amp;likeInfoAlt.matchSet );</span>
<span class="udiff-line-added">+ </span>
    if( nExpr&lt;3 ){
      aWc[3] = 0;
    }else{
      Expr *pEscape = pExpr-&gt;x.pList-&gt;a[2].pExpr;
      char *zEscape;
      if( pEscape-&gt;op!=TK_STRING ) return 0;
      zEscape = pEscape-&gt;u.zToken;
      if( zEscape[0]==0 || zEscape[1]!=0 ) return 0;
<span class="udiff-line-added">+     if( zEscape[0]==aWc[0] ) return 0;</span>
<span class="udiff-line-added">+     if( zEscape[0]==aWc[1] ) return 0;</span>
      aWc[3] = zEscape[0];
    }
  
<span class="udiff-line-removed">-   /* The memcpy() statement assumes that the wildcard characters are</span>
<span class="udiff-line-removed">-   ** the first three statements in the compareInfo structure.  The</span>
<span class="udiff-line-removed">-   ** asserts() that follow verify that assumption</span>
<span class="udiff-line-removed">-   */</span>
<span class="udiff-line-removed">-   memcpy(aWc, pDef-&gt;pUserData, 3);</span>
<span class="udiff-line-removed">-   assert( (char*)&amp;likeInfoAlt == (char*)&amp;likeInfoAlt.matchAll );</span>
<span class="udiff-line-removed">-   assert( &amp;((char*)&amp;likeInfoAlt)[1] == (char*)&amp;likeInfoAlt.matchOne );</span>
<span class="udiff-line-removed">-   assert( &amp;((char*)&amp;likeInfoAlt)[2] == (char*)&amp;likeInfoAlt.matchSet );</span>
    *pIsNocase = (pDef-&gt;funcFlags &amp; SQLITE_FUNC_CASE)==0;
    return 1;
  }
  
  /*
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -117609,11 +118729,11 @@</span>
      FUNCTION(round,              2, 0, 0, roundFunc        ),
  #endif
      FUNCTION(upper,              1, 0, 0, upperFunc        ),
      FUNCTION(lower,              1, 0, 0, lowerFunc        ),
      FUNCTION(hex,                1, 0, 0, hexFunc          ),
<span class="udiff-line-modified-removed">-     INLINE_FUNC(ifnull,          2, INLINEFUNC_coalesce, SQLITE_FUNC_COALESCE),</span>
<span class="udiff-line-modified-added">+     INLINE_FUNC(ifnull,          2, INLINEFUNC_coalesce, 0 ),</span>
      VFUNCTION(random,            0, 0, 0, randomFunc       ),
      VFUNCTION(randomblob,        1, 0, 0, randomBlob       ),
      FUNCTION(nullif,             2, 0, 1, nullifFunc       ),
      DFUNCTION(sqlite_version,    0, 0, 0, versionFunc      ),
      DFUNCTION(sqlite_source_id,  0, 0, 0, sourceidFunc     ),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -117649,11 +118769,12 @@</span>
  #ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION
      FUNCTION(unknown,           -1, 0, 0, unknownFunc      ),
  #endif
      FUNCTION(coalesce,           1, 0, 0, 0                ),
      FUNCTION(coalesce,           0, 0, 0, 0                ),
<span class="udiff-line-modified-removed">-     INLINE_FUNC(coalesce,       -1, INLINEFUNC_coalesce, SQLITE_FUNC_COALESCE),</span>
<span class="udiff-line-modified-added">+     INLINE_FUNC(coalesce,       -1, INLINEFUNC_coalesce, 0 ),</span>
<span class="udiff-line-added">+     INLINE_FUNC(iif,             3, INLINEFUNC_iif,      0 ),</span>
    };
  #ifndef SQLITE_OMIT_ALTERTABLE
    sqlite3AlterFunctions();
  #endif
    sqlite3WindowFunctions();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -118337,11 +119458,11 @@</span>
    }
  
    /* Clean up the WHERE clause constructed above. */
    sqlite3ExprDelete(db, pWhere);
    if( iFkIfZero ){
<span class="udiff-line-modified-removed">-     sqlite3VdbeJumpHere(v, iFkIfZero);</span>
<span class="udiff-line-modified-added">+     sqlite3VdbeJumpHereOrPopInst(v, iFkIfZero);</span>
    }
  }
  
  /*
  ** This function returns a linked list of FKey objects (connected by
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -120736,11 +121857,11 @@</span>
            case OE_Replace: {
              int addr1 = sqlite3VdbeAddOp1(v, OP_NotNull, iReg);
              VdbeCoverage(v);
              assert( (pCol-&gt;colFlags &amp; COLFLAG_GENERATED)==0 );
              nSeenReplace++;
<span class="udiff-line-modified-removed">-             sqlite3ExprCode(pParse, pCol-&gt;pDflt, iReg);</span>
<span class="udiff-line-modified-added">+             sqlite3ExprCodeCopy(pParse, pCol-&gt;pDflt, iReg);</span>
              sqlite3VdbeJumpHere(v, addr1);
              break;
            }
            case OE_Abort:
              sqlite3MayAbort(pParse);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -120791,21 +121912,30 @@</span>
      ExprList *pCheck = pTab-&gt;pCheck;
      pParse-&gt;iSelfTab = -(regNewData+1);
      onError = overrideError!=OE_Default ? overrideError : OE_Abort;
      for(i=0; i&lt;pCheck-&gt;nExpr; i++){
        int allOk;
<span class="udiff-line-added">+       Expr *pCopy;</span>
        Expr *pExpr = pCheck-&gt;a[i].pExpr;
        if( aiChng
         &amp;&amp; !sqlite3ExprReferencesUpdatedColumn(pExpr, aiChng, pkChng)
        ){
          /* The check constraints do not reference any of the columns being
          ** updated so there is no point it verifying the check constraint */
          continue;
        }
<span class="udiff-line-added">+       if( bAffinityDone==0 ){</span>
<span class="udiff-line-added">+         sqlite3TableAffinity(v, pTab, regNewData+1);</span>
<span class="udiff-line-added">+         bAffinityDone = 1;</span>
<span class="udiff-line-added">+       }</span>
        allOk = sqlite3VdbeMakeLabel(pParse);
        sqlite3VdbeVerifyAbortable(v, onError);
<span class="udiff-line-modified-removed">-       sqlite3ExprIfTrue(pParse, pExpr, allOk, SQLITE_JUMPIFNULL);</span>
<span class="udiff-line-modified-added">+       pCopy = sqlite3ExprDup(db, pExpr, 0);</span>
<span class="udiff-line-added">+       if( !db-&gt;mallocFailed ){</span>
<span class="udiff-line-added">+         sqlite3ExprIfTrue(pParse, pCopy, allOk, SQLITE_JUMPIFNULL);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       sqlite3ExprDelete(db, pCopy);</span>
        if( onError==OE_Ignore ){
          sqlite3VdbeGoto(v, ignoreDest);
        }else{
          char *zName = pCheck-&gt;a[i].zEName;
          if( zName==0 ) zName = pTab-&gt;zName;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -121065,11 +122195,11 @@</span>
      }
      if( bAffinityDone==0 &amp;&amp; (pUpIdx==0 || pUpIdx==pIdx) ){
        sqlite3TableAffinity(v, pTab, regNewData+1);
        bAffinityDone = 1;
      }
<span class="udiff-line-modified-removed">-     VdbeNoopComment((v, &quot;uniqueness check for %s&quot;, pIdx-&gt;zName));</span>
<span class="udiff-line-modified-added">+     VdbeNoopComment((v, &quot;prep index %s&quot;, pIdx-&gt;zName));</span>
      iThisCur = iIdxCur+ix;
  
  
      /* Skip partial indices for which the WHERE clause is not true */
      if( pIdx-&gt;pPartIdxWhere ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -121300,16 +122430,18 @@</span>
              ** Hence, make a complete copy of the opcode, rather than using
              ** a pointer to the opcode. */
              x = *sqlite3VdbeGetOp(v, addrConflictCk);
              if( x.opcode!=OP_IdxRowid ){
                int p2;      /* New P2 value for copied conflict check opcode */
<span class="udiff-line-added">+               const char *zP4;</span>
                if( sqlite3OpcodeProperty[x.opcode]&amp;OPFLG_JUMP ){
                  p2 = lblRecheckOk;
                }else{
                  p2 = x.p2;
                }
<span class="udiff-line-modified-removed">-               sqlite3VdbeAddOp4(v, x.opcode, x.p1, p2, x.p3, x.p4.z, x.p4type);</span>
<span class="udiff-line-modified-added">+               zP4 = x.p4type==P4_INT32 ? SQLITE_INT_TO_PTR(x.p4.i) : x.p4.z;</span>
<span class="udiff-line-added">+               sqlite3VdbeAddOp4(v, x.opcode, x.p1, p2, x.p3, zP4, x.p4type);</span>
                sqlite3VdbeChangeP5(v, x.p5);
                VdbeCoverageIf(v, p2!=x.p2);
              }
              nConflictCk--;
              addrConflictCk++;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -121913,18 +123045,17 @@</span>
        addr1 = sqlite3VdbeAddOp2(v, OP_NewRowid, iDest, regRowid);
      }else{
        addr1 = sqlite3VdbeAddOp2(v, OP_Rowid, iSrc, regRowid);
        assert( (pDest-&gt;tabFlags &amp; TF_Autoincrement)==0 );
      }
<span class="udiff-line-removed">-     sqlite3VdbeAddOp3(v, OP_RowData, iSrc, regData, 1);</span>
      if( db-&gt;mDbFlags &amp; DBFLAG_Vacuum ){
        sqlite3VdbeAddOp1(v, OP_SeekEnd, iDest);
<span class="udiff-line-modified-removed">-       insFlags = OPFLAG_NCHANGE|OPFLAG_LASTROWID|</span>
<span class="udiff-line-removed">-                            OPFLAG_APPEND|OPFLAG_USESEEKRESULT;</span>
<span class="udiff-line-modified-added">+       insFlags = OPFLAG_APPEND|OPFLAG_USESEEKRESULT;</span>
      }else{
        insFlags = OPFLAG_NCHANGE|OPFLAG_LASTROWID|OPFLAG_APPEND;
      }
<span class="udiff-line-added">+     sqlite3VdbeAddOp3(v, OP_RowData, iSrc, regData, 1);</span>
      sqlite3VdbeAddOp4(v, OP_Insert, iDest, regData, regRowid,
                        (char*)pDest, P4_TABLE);
      sqlite3VdbeChangeP5(v, insFlags);
      sqlite3VdbeAddOp2(v, OP_Next, iSrc, addr1); VdbeCoverage(v);
      sqlite3VdbeAddOp2(v, OP_Close, iSrc, 0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -121945,11 +123076,10 @@</span>
      sqlite3VdbeAddOp3(v, OP_OpenWrite, iDest, pDestIdx-&gt;tnum, iDbDest);
      sqlite3VdbeSetP4KeyInfo(pParse, pDestIdx);
      sqlite3VdbeChangeP5(v, OPFLAG_BULKCSR);
      VdbeComment((v, &quot;%s&quot;, pDestIdx-&gt;zName));
      addr1 = sqlite3VdbeAddOp2(v, OP_Rewind, iSrc, 0); VdbeCoverage(v);
<span class="udiff-line-removed">-     sqlite3VdbeAddOp3(v, OP_RowData, iSrc, regData, 1);</span>
      if( db-&gt;mDbFlags &amp; DBFLAG_Vacuum ){
        /* This INSERT command is part of a VACUUM operation, which guarantees
        ** that the destination table is empty. If all indexed columns use
        ** collation sequence BINARY, then it can also be assumed that the
        ** index will be populated by inserting keys in strictly sorted
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -121969,14 +123099,14 @@</span>
        }
        if( i==pSrcIdx-&gt;nColumn ){
          idxInsFlags = OPFLAG_USESEEKRESULT;
          sqlite3VdbeAddOp1(v, OP_SeekEnd, iDest);
        }
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-removed">-     if( !HasRowid(pSrc) &amp;&amp; pDestIdx-&gt;idxType==SQLITE_IDXTYPE_PRIMARYKEY ){</span>
<span class="udiff-line-modified-added">+     }else if( !HasRowid(pSrc) &amp;&amp; pDestIdx-&gt;idxType==SQLITE_IDXTYPE_PRIMARYKEY ){</span>
        idxInsFlags |= OPFLAG_NCHANGE;
      }
<span class="udiff-line-added">+     sqlite3VdbeAddOp3(v, OP_RowData, iSrc, regData, 1);</span>
      sqlite3VdbeAddOp2(v, OP_IdxInsert, iDest, regData);
      sqlite3VdbeChangeP5(v, idxInsFlags|OPFLAG_APPEND);
      sqlite3VdbeAddOp2(v, OP_Next, iSrc, addr1+1); VdbeCoverage(v);
      sqlite3VdbeJumpHere(v, addr1);
      sqlite3VdbeAddOp2(v, OP_Close, iSrc, 0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -122493,10 +123623,15 @@</span>
    sqlite3_int64 (*hard_heap_limit64)(sqlite3_int64);
    const char *(*uri_key)(const char*,int);
    const char *(*filename_database)(const char*);
    const char *(*filename_journal)(const char*);
    const char *(*filename_wal)(const char*);
<span class="udiff-line-added">+   /* Version 3.32.0 and later */</span>
<span class="udiff-line-added">+   char *(*create_filename)(const char*,const char*,const char*,</span>
<span class="udiff-line-added">+                            int,const char**);</span>
<span class="udiff-line-added">+   void (*free_filename)(char*);</span>
<span class="udiff-line-added">+   sqlite3_file *(*database_file_object)(const char*);</span>
  };
  
  /*
  ** This is the function signature used for all extension entry points.  It
  ** is also defined in the file &quot;loadext.c&quot;.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -122793,10 +123928,14 @@</span>
  #define sqlite3_hard_heap_limit64      sqlite3_api-&gt;hard_heap_limit64
  #define sqlite3_uri_key                sqlite3_api-&gt;uri_key
  #define sqlite3_filename_database      sqlite3_api-&gt;filename_database
  #define sqlite3_filename_journal       sqlite3_api-&gt;filename_journal
  #define sqlite3_filename_wal           sqlite3_api-&gt;filename_wal
<span class="udiff-line-added">+ /* Version 3.32.0 and later */</span>
<span class="udiff-line-added">+ #define sqlite3_create_filename        sqlite3_api-&gt;create_filename</span>
<span class="udiff-line-added">+ #define sqlite3_free_filename          sqlite3_api-&gt;free_filename</span>
<span class="udiff-line-added">+ #define sqlite3_database_file_object   sqlite3_api-&gt;database_file_object</span>
  #endif /* !defined(SQLITE_CORE) &amp;&amp; !defined(SQLITE_OMIT_LOAD_EXTENSION) */
  
  #if !defined(SQLITE_CORE) &amp;&amp; !defined(SQLITE_OMIT_LOAD_EXTENSION)
    /* This case when the file really is being compiled as a loadable
    ** extension */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -123271,12 +124410,24 @@</span>
    sqlite3_hard_heap_limit64,
    sqlite3_uri_key,
    sqlite3_filename_database,
    sqlite3_filename_journal,
    sqlite3_filename_wal,
<span class="udiff-line-added">+   /* Version 3.32.0 and later */</span>
<span class="udiff-line-added">+   sqlite3_create_filename,</span>
<span class="udiff-line-added">+   sqlite3_free_filename,</span>
<span class="udiff-line-added">+   sqlite3_database_file_object,</span>
  };
  
<span class="udiff-line-added">+ /* True if x is the directory separator character</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ #if SQLITE_OS_WIN</span>
<span class="udiff-line-added">+ # define DirSep(X)  ((X)==&#39;/&#39;||(X)==&#39;\\&#39;)</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+ # define DirSep(X)  ((X)==&#39;/&#39;)</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  /*
  ** Attempt to load an SQLite extension library contained in the file
  ** zFile.  The entry point is zProc.  zProc may be 0 in which case a
  ** default entry point name (sqlite3_extension_init) is used.  Use
  ** of the default name is recommended.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -123374,11 +124525,11 @@</span>
      if( zAltEntry==0 ){
        sqlite3OsDlClose(pVfs, handle);
        return SQLITE_NOMEM_BKPT;
      }
      memcpy(zAltEntry, &quot;sqlite3_&quot;, 8);
<span class="udiff-line-modified-removed">-     for(iFile=ncFile-1; iFile&gt;=0 &amp;&amp; zFile[iFile]!=&#39;/&#39;; iFile--){}</span>
<span class="udiff-line-modified-added">+     for(iFile=ncFile-1; iFile&gt;=0 &amp;&amp; !DirSep(zFile[iFile]); iFile--){}</span>
      iFile++;
      if( sqlite3_strnicmp(zFile+iFile, &quot;lib&quot;, 3)==0 ) iFile += 3;
      for(iEntry=8; (c = zFile[iFile])!=0 &amp;&amp; c!=&#39;.&#39;; iFile++){
        if( sqlite3Isalpha(c) ){
          zAltEntry[iEntry++] = (char)sqlite3UpperToLower[(unsigned)c];
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -123677,53 +124828,53 @@</span>
  ** ../tool/mkpragmatab.tcl.  To update the set of pragmas, edit
  ** that script and rerun it.
  */
  
  /* The various pragma types */
<span class="udiff-line-modified-removed">- #define PragTyp_HEADER_VALUE                   0</span>
<span class="udiff-line-modified-removed">- #define PragTyp_AUTO_VACUUM                    1</span>
<span class="udiff-line-modified-removed">- #define PragTyp_FLAG                           2</span>
<span class="udiff-line-modified-removed">- #define PragTyp_BUSY_TIMEOUT                   3</span>
<span class="udiff-line-modified-removed">- #define PragTyp_CACHE_SIZE                     4</span>
<span class="udiff-line-modified-removed">- #define PragTyp_CACHE_SPILL                    5</span>
<span class="udiff-line-modified-removed">- #define PragTyp_CASE_SENSITIVE_LIKE            6</span>
<span class="udiff-line-modified-removed">- #define PragTyp_COLLATION_LIST                 7</span>
<span class="udiff-line-modified-removed">- #define PragTyp_COMPILE_OPTIONS                8</span>
<span class="udiff-line-modified-removed">- #define PragTyp_DATA_STORE_DIRECTORY           9</span>
<span class="udiff-line-modified-removed">- #define PragTyp_DATABASE_LIST                 10</span>
<span class="udiff-line-modified-removed">- #define PragTyp_DEFAULT_CACHE_SIZE            11</span>
<span class="udiff-line-modified-removed">- #define PragTyp_ENCODING                      12</span>
<span class="udiff-line-modified-removed">- #define PragTyp_FOREIGN_KEY_CHECK             13</span>
<span class="udiff-line-modified-removed">- #define PragTyp_FOREIGN_KEY_LIST              14</span>
<span class="udiff-line-modified-removed">- #define PragTyp_FUNCTION_LIST                 15</span>
<span class="udiff-line-modified-removed">- #define PragTyp_HARD_HEAP_LIMIT               16</span>
<span class="udiff-line-modified-removed">- #define PragTyp_INCREMENTAL_VACUUM            17</span>
<span class="udiff-line-modified-removed">- #define PragTyp_INDEX_INFO                    18</span>
<span class="udiff-line-modified-removed">- #define PragTyp_INDEX_LIST                    19</span>
<span class="udiff-line-modified-removed">- #define PragTyp_INTEGRITY_CHECK               20</span>
<span class="udiff-line-modified-removed">- #define PragTyp_JOURNAL_MODE                  21</span>
<span class="udiff-line-modified-removed">- #define PragTyp_JOURNAL_SIZE_LIMIT            22</span>
<span class="udiff-line-modified-removed">- #define PragTyp_LOCK_PROXY_FILE               23</span>
<span class="udiff-line-modified-removed">- #define PragTyp_LOCKING_MODE                  24</span>
<span class="udiff-line-modified-removed">- #define PragTyp_PAGE_COUNT                    25</span>
<span class="udiff-line-modified-removed">- #define PragTyp_MMAP_SIZE                     26</span>
<span class="udiff-line-modified-removed">- #define PragTyp_MODULE_LIST                   27</span>
<span class="udiff-line-modified-removed">- #define PragTyp_OPTIMIZE                      28</span>
<span class="udiff-line-modified-removed">- #define PragTyp_PAGE_SIZE                     29</span>
<span class="udiff-line-modified-removed">- #define PragTyp_PRAGMA_LIST                   30</span>
<span class="udiff-line-modified-removed">- #define PragTyp_SECURE_DELETE                 31</span>
<span class="udiff-line-modified-removed">- #define PragTyp_SHRINK_MEMORY                 32</span>
<span class="udiff-line-modified-removed">- #define PragTyp_SOFT_HEAP_LIMIT               33</span>
<span class="udiff-line-modified-removed">- #define PragTyp_SYNCHRONOUS                   34</span>
<span class="udiff-line-modified-removed">- #define PragTyp_TABLE_INFO                    35</span>
<span class="udiff-line-modified-removed">- #define PragTyp_TEMP_STORE                    36</span>
<span class="udiff-line-modified-removed">- #define PragTyp_TEMP_STORE_DIRECTORY          37</span>
<span class="udiff-line-modified-removed">- #define PragTyp_THREADS                       38</span>
<span class="udiff-line-modified-removed">- #define PragTyp_WAL_AUTOCHECKPOINT            39</span>
<span class="udiff-line-modified-removed">- #define PragTyp_WAL_CHECKPOINT                40</span>
<span class="udiff-line-modified-removed">- #define PragTyp_ACTIVATE_EXTENSIONS           41</span>
<span class="udiff-line-modified-removed">- #define PragTyp_KEY                           42</span>
<span class="udiff-line-modified-added">+ #define PragTyp_ACTIVATE_EXTENSIONS            0</span>
<span class="udiff-line-modified-added">+ #define PragTyp_ANALYSIS_LIMIT                 1</span>
<span class="udiff-line-modified-added">+ #define PragTyp_HEADER_VALUE                   2</span>
<span class="udiff-line-modified-added">+ #define PragTyp_AUTO_VACUUM                    3</span>
<span class="udiff-line-modified-added">+ #define PragTyp_FLAG                           4</span>
<span class="udiff-line-modified-added">+ #define PragTyp_BUSY_TIMEOUT                   5</span>
<span class="udiff-line-modified-added">+ #define PragTyp_CACHE_SIZE                     6</span>
<span class="udiff-line-modified-added">+ #define PragTyp_CACHE_SPILL                    7</span>
<span class="udiff-line-modified-added">+ #define PragTyp_CASE_SENSITIVE_LIKE            8</span>
<span class="udiff-line-modified-added">+ #define PragTyp_COLLATION_LIST                 9</span>
<span class="udiff-line-modified-added">+ #define PragTyp_COMPILE_OPTIONS               10</span>
<span class="udiff-line-modified-added">+ #define PragTyp_DATA_STORE_DIRECTORY          11</span>
<span class="udiff-line-modified-added">+ #define PragTyp_DATABASE_LIST                 12</span>
<span class="udiff-line-modified-added">+ #define PragTyp_DEFAULT_CACHE_SIZE            13</span>
<span class="udiff-line-modified-added">+ #define PragTyp_ENCODING                      14</span>
<span class="udiff-line-modified-added">+ #define PragTyp_FOREIGN_KEY_CHECK             15</span>
<span class="udiff-line-modified-added">+ #define PragTyp_FOREIGN_KEY_LIST              16</span>
<span class="udiff-line-modified-added">+ #define PragTyp_FUNCTION_LIST                 17</span>
<span class="udiff-line-modified-added">+ #define PragTyp_HARD_HEAP_LIMIT               18</span>
<span class="udiff-line-modified-added">+ #define PragTyp_INCREMENTAL_VACUUM            19</span>
<span class="udiff-line-modified-added">+ #define PragTyp_INDEX_INFO                    20</span>
<span class="udiff-line-modified-added">+ #define PragTyp_INDEX_LIST                    21</span>
<span class="udiff-line-modified-added">+ #define PragTyp_INTEGRITY_CHECK               22</span>
<span class="udiff-line-modified-added">+ #define PragTyp_JOURNAL_MODE                  23</span>
<span class="udiff-line-modified-added">+ #define PragTyp_JOURNAL_SIZE_LIMIT            24</span>
<span class="udiff-line-modified-added">+ #define PragTyp_LOCK_PROXY_FILE               25</span>
<span class="udiff-line-modified-added">+ #define PragTyp_LOCKING_MODE                  26</span>
<span class="udiff-line-modified-added">+ #define PragTyp_PAGE_COUNT                    27</span>
<span class="udiff-line-modified-added">+ #define PragTyp_MMAP_SIZE                     28</span>
<span class="udiff-line-modified-added">+ #define PragTyp_MODULE_LIST                   29</span>
<span class="udiff-line-modified-added">+ #define PragTyp_OPTIMIZE                      30</span>
<span class="udiff-line-modified-added">+ #define PragTyp_PAGE_SIZE                     31</span>
<span class="udiff-line-modified-added">+ #define PragTyp_PRAGMA_LIST                   32</span>
<span class="udiff-line-modified-added">+ #define PragTyp_SECURE_DELETE                 33</span>
<span class="udiff-line-modified-added">+ #define PragTyp_SHRINK_MEMORY                 34</span>
<span class="udiff-line-modified-added">+ #define PragTyp_SOFT_HEAP_LIMIT               35</span>
<span class="udiff-line-modified-added">+ #define PragTyp_SYNCHRONOUS                   36</span>
<span class="udiff-line-modified-added">+ #define PragTyp_TABLE_INFO                    37</span>
<span class="udiff-line-modified-added">+ #define PragTyp_TEMP_STORE                    38</span>
<span class="udiff-line-modified-added">+ #define PragTyp_TEMP_STORE_DIRECTORY          39</span>
<span class="udiff-line-modified-added">+ #define PragTyp_THREADS                       40</span>
<span class="udiff-line-modified-added">+ #define PragTyp_WAL_AUTOCHECKPOINT            41</span>
<span class="udiff-line-modified-added">+ #define PragTyp_WAL_CHECKPOINT                42</span>
  #define PragTyp_LOCK_STATUS                   43
  #define PragTyp_STATS                         44
  
  /* Property flags associated with various pragma. */
  #define PragFlg_NeedSchema 0x01 /* Force schema load before running */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -123805,17 +124956,22 @@</span>
    u8 iPragCName;           /* Start of column names in pragCName[] */
    u8 nPragCName;           /* Num of col names. 0 means use pragma name */
    u64 iArg;                /* Extra argument */
  } PragmaName;
  static const PragmaName aPragmaName[] = {
<span class="udiff-line-modified-removed">- #if defined(SQLITE_HAS_CODEC) || defined(SQLITE_ENABLE_CEROD)</span>
<span class="udiff-line-modified-added">+ #if defined(SQLITE_ENABLE_CEROD)</span>
   {/* zName:     */ &quot;activate_extensions&quot;,
    /* ePragTyp:  */ PragTyp_ACTIVATE_EXTENSIONS,
    /* ePragFlg:  */ 0,
    /* ColNames:  */ 0, 0,
    /* iArg:      */ 0 },
  #endif
<span class="udiff-line-added">+  {/* zName:     */ &quot;analysis_limit&quot;,</span>
<span class="udiff-line-added">+   /* ePragTyp:  */ PragTyp_ANALYSIS_LIMIT,</span>
<span class="udiff-line-added">+   /* ePragFlg:  */ PragFlg_Result0,</span>
<span class="udiff-line-added">+   /* ColNames:  */ 0, 0,</span>
<span class="udiff-line-added">+   /* iArg:      */ 0 },</span>
  #if !defined(SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS)
   {/* zName:     */ &quot;application_id&quot;,
    /* ePragTyp:  */ PragTyp_HEADER_VALUE,
    /* ePragFlg:  */ PragFlg_NoColumns1|PragFlg_Result0,
    /* ColNames:  */ 0, 0,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -124001,22 +125157,10 @@</span>
   {/* zName:     */ &quot;hard_heap_limit&quot;,
    /* ePragTyp:  */ PragTyp_HARD_HEAP_LIMIT,
    /* ePragFlg:  */ PragFlg_Result0,
    /* ColNames:  */ 0, 0,
    /* iArg:      */ 0 },
<span class="udiff-line-removed">- #if defined(SQLITE_HAS_CODEC)</span>
<span class="udiff-line-removed">-  {/* zName:     */ &quot;hexkey&quot;,</span>
<span class="udiff-line-removed">-   /* ePragTyp:  */ PragTyp_KEY,</span>
<span class="udiff-line-removed">-   /* ePragFlg:  */ 0,</span>
<span class="udiff-line-removed">-   /* ColNames:  */ 0, 0,</span>
<span class="udiff-line-removed">-   /* iArg:      */ 2 },</span>
<span class="udiff-line-removed">-  {/* zName:     */ &quot;hexrekey&quot;,</span>
<span class="udiff-line-removed">-   /* ePragTyp:  */ PragTyp_KEY,</span>
<span class="udiff-line-removed">-   /* ePragFlg:  */ 0,</span>
<span class="udiff-line-removed">-   /* ColNames:  */ 0, 0,</span>
<span class="udiff-line-removed">-   /* iArg:      */ 3 },</span>
<span class="udiff-line-removed">- #endif</span>
  #if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
  #if !defined(SQLITE_OMIT_CHECK)
   {/* zName:     */ &quot;ignore_check_constraints&quot;,
    /* ePragTyp:  */ PragTyp_FLAG,
    /* ePragFlg:  */ PragFlg_Result0|PragFlg_NoColumns1,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -124065,17 +125209,10 @@</span>
    /* ePragTyp:  */ PragTyp_JOURNAL_SIZE_LIMIT,
    /* ePragFlg:  */ PragFlg_Result0|PragFlg_SchemaReq,
    /* ColNames:  */ 0, 0,
    /* iArg:      */ 0 },
  #endif
<span class="udiff-line-removed">- #if defined(SQLITE_HAS_CODEC)</span>
<span class="udiff-line-removed">-  {/* zName:     */ &quot;key&quot;,</span>
<span class="udiff-line-removed">-   /* ePragTyp:  */ PragTyp_KEY,</span>
<span class="udiff-line-removed">-   /* ePragFlg:  */ 0,</span>
<span class="udiff-line-removed">-   /* ColNames:  */ 0, 0,</span>
<span class="udiff-line-removed">-   /* iArg:      */ 0 },</span>
<span class="udiff-line-removed">- #endif</span>
  #if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
   {/* zName:     */ &quot;legacy_alter_table&quot;,
    /* ePragTyp:  */ PragTyp_FLAG,
    /* ePragFlg:  */ PragFlg_Result0|PragFlg_NoColumns1,
    /* ColNames:  */ 0, 0,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -124179,19 +125316,10 @@</span>
   {/* zName:     */ &quot;recursive_triggers&quot;,
    /* ePragTyp:  */ PragTyp_FLAG,
    /* ePragFlg:  */ PragFlg_Result0|PragFlg_NoColumns1,
    /* ColNames:  */ 0, 0,
    /* iArg:      */ SQLITE_RecTriggers },
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- #if defined(SQLITE_HAS_CODEC)</span>
<span class="udiff-line-removed">-  {/* zName:     */ &quot;rekey&quot;,</span>
<span class="udiff-line-removed">-   /* ePragTyp:  */ PragTyp_KEY,</span>
<span class="udiff-line-removed">-   /* ePragFlg:  */ 0,</span>
<span class="udiff-line-removed">-   /* ColNames:  */ 0, 0,</span>
<span class="udiff-line-removed">-   /* iArg:      */ 1 },</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- #if !defined(SQLITE_OMIT_FLAG_PRAGMAS)</span>
   {/* zName:     */ &quot;reverse_unordered_selects&quot;,
    /* ePragTyp:  */ PragTyp_FLAG,
    /* ePragFlg:  */ PragFlg_Result0|PragFlg_NoColumns1,
    /* ColNames:  */ 0, 0,
    /* iArg:      */ SQLITE_ReverseOrder },
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -124271,22 +125399,10 @@</span>
   {/* zName:     */ &quot;temp_store_directory&quot;,
    /* ePragTyp:  */ PragTyp_TEMP_STORE_DIRECTORY,
    /* ePragFlg:  */ PragFlg_NoColumns1,
    /* ColNames:  */ 0, 0,
    /* iArg:      */ 0 },
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- #if defined(SQLITE_HAS_CODEC)</span>
<span class="udiff-line-removed">-  {/* zName:     */ &quot;textkey&quot;,</span>
<span class="udiff-line-removed">-   /* ePragTyp:  */ PragTyp_KEY,</span>
<span class="udiff-line-removed">-   /* ePragFlg:  */ 0,</span>
<span class="udiff-line-removed">-   /* ColNames:  */ 0, 0,</span>
<span class="udiff-line-removed">-   /* iArg:      */ 4 },</span>
<span class="udiff-line-removed">-  {/* zName:     */ &quot;textrekey&quot;,</span>
<span class="udiff-line-removed">-   /* ePragTyp:  */ PragTyp_KEY,</span>
<span class="udiff-line-removed">-   /* ePragFlg:  */ 0,</span>
<span class="udiff-line-removed">-   /* ColNames:  */ 0, 0,</span>
<span class="udiff-line-removed">-   /* iArg:      */ 5 },</span>
  #endif
   {/* zName:     */ &quot;threads&quot;,
    /* ePragTyp:  */ PragTyp_THREADS,
    /* ePragFlg:  */ PragFlg_Result0,
    /* ColNames:  */ 0, 0,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -124352,11 +125468,11 @@</span>
    /* ePragFlg:  */ PragFlg_Result0|PragFlg_NoColumns1,
    /* ColNames:  */ 0, 0,
    /* iArg:      */ SQLITE_WriteSchema|SQLITE_NoSchemaError },
  #endif
  };
<span class="udiff-line-modified-removed">- /* Number of pragmas: 66 on by default, 82 total. */</span>
<span class="udiff-line-modified-added">+ /* Number of pragmas: 67 on by default, 77 total. */</span>
  
  /************** End of pragma.h **********************************************/
  /************** Continuing where we left off in pragma.c *********************/
  
  /*
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -124882,11 +125998,11 @@</span>
      }else{
        /* Malloc may fail when setting the page-size, as there is an internal
        ** buffer that the pager module resizes using sqlite3_realloc().
        */
        db-&gt;nextPagesize = sqlite3Atoi(zRight);
<span class="udiff-line-modified-removed">-       if( SQLITE_NOMEM==sqlite3BtreeSetPageSize(pBt, db-&gt;nextPagesize,-1,0) ){</span>
<span class="udiff-line-modified-added">+       if( SQLITE_NOMEM==sqlite3BtreeSetPageSize(pBt, db-&gt;nextPagesize,0,0) ){</span>
          sqlite3OomFault(db);
        }
      }
      break;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -126056,11 +127172,10 @@</span>
              sqlite3ResolvePartIdxLabel(pParse, jmp3);
            }
          }
          sqlite3VdbeAddOp2(v, OP_Next, iDataCur, loopTop); VdbeCoverage(v);
          sqlite3VdbeJumpHere(v, loopTop-1);
<span class="udiff-line-removed">- #ifndef SQLITE_OMIT_BTREECOUNT</span>
          if( !isQuick ){
            sqlite3VdbeLoadString(v, 2, &quot;wrong # of entries in index &quot;);
            for(j=0, pIdx=pTab-&gt;pIndex; pIdx; pIdx=pIdx-&gt;pNext, j++){
              if( pPk==pIdx ) continue;
              sqlite3VdbeAddOp2(v, OP_Count, iIdxCur+j, 3);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -126070,11 +127185,10 @@</span>
              sqlite3VdbeAddOp3(v, OP_Concat, 4, 2, 3);
              integrityCheckResultRow(v);
              sqlite3VdbeJumpHere(v, addr);
            }
          }
<span class="udiff-line-removed">- #endif /* SQLITE_OMIT_BTREECOUNT */</span>
        }
      }
      {
        static const int iLn = VDBE_OFFSET_LINENO(2);
        static const VdbeOpList endCode[] = {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -126151,25 +127265,16 @@</span>
        /* Only change the value of sqlite.enc if the database handle is not
        ** initialized. If the main database exists, the new sqlite.enc value
        ** will be overwritten when the schema is next loaded. If it does not
        ** already exists, it will be created to use the new encoding value.
        */
<span class="udiff-line-modified-removed">-       int canChangeEnc = 1;  /* True if allowed to change the encoding */</span>
<span class="udiff-line-removed">-       int i;                 /* For looping over all attached databases */</span>
<span class="udiff-line-removed">-       for(i=0; i&lt;db-&gt;nDb; i++){</span>
<span class="udiff-line-removed">-         if( db-&gt;aDb[i].pBt!=0</span>
<span class="udiff-line-removed">-          &amp;&amp; DbHasProperty(db,i,DB_SchemaLoaded)</span>
<span class="udiff-line-removed">-          &amp;&amp; !DbHasProperty(db,i,DB_Empty)</span>
<span class="udiff-line-removed">-         ){</span>
<span class="udiff-line-removed">-           canChangeEnc = 0;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       if( canChangeEnc ){</span>
<span class="udiff-line-modified-added">+       if( (db-&gt;mDbFlags &amp; DBFLAG_EncodingFixed)==0 ){</span>
          for(pEnc=&amp;encnames[0]; pEnc-&gt;zName; pEnc++){
            if( 0==sqlite3StrICmp(zRight, pEnc-&gt;zName) ){
<span class="udiff-line-modified-removed">-             SCHEMA_ENC(db) = ENC(db) =</span>
<span class="udiff-line-modified-removed">-                 pEnc-&gt;enc ? pEnc-&gt;enc : SQLITE_UTF16NATIVE;</span>
<span class="udiff-line-modified-added">+             u8 enc = pEnc-&gt;enc ? pEnc-&gt;enc : SQLITE_UTF16NATIVE;</span>
<span class="udiff-line-modified-added">+             SCHEMA_ENC(db) = enc;</span>
<span class="udiff-line-added">+             sqlite3SetTextEncoding(db, enc);</span>
              break;
            }
          }
          if( !pEnc-&gt;zName ){
            sqlite3ErrorMsg(pParse, &quot;unsupported encoding: %s&quot;, zRight);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -126514,10 +127619,29 @@</span>
      }
      returnSingleInt(v, sqlite3_limit(db, SQLITE_LIMIT_WORKER_THREADS, -1));
      break;
    }
  
<span class="udiff-line-added">+   /*</span>
<span class="udiff-line-added">+   **   PRAGMA analysis_limit</span>
<span class="udiff-line-added">+   **   PRAGMA analysis_limit = N</span>
<span class="udiff-line-added">+   **</span>
<span class="udiff-line-added">+   ** Configure the maximum number of rows that ANALYZE will examine</span>
<span class="udiff-line-added">+   ** in each index that it looks at.  Return the new limit.</span>
<span class="udiff-line-added">+   */</span>
<span class="udiff-line-added">+   case PragTyp_ANALYSIS_LIMIT: {</span>
<span class="udiff-line-added">+     sqlite3_int64 N;</span>
<span class="udiff-line-added">+     if( zRight</span>
<span class="udiff-line-added">+      &amp;&amp; sqlite3DecOrHexToI64(zRight, &amp;N)==SQLITE_OK</span>
<span class="udiff-line-added">+      &amp;&amp; N&gt;=0</span>
<span class="udiff-line-added">+     ){</span>
<span class="udiff-line-added">+       db-&gt;nAnalysisLimit = (int)(N&amp;0x7fffffff);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     returnSingleInt(v, db-&gt;nAnalysisLimit);</span>
<span class="udiff-line-added">+     break;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
  #if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
    /*
    ** Report the current state of file logs for all databases
    */
    case PragTyp_LOCK_STATUS: {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -126542,63 +127666,15 @@</span>
      }
      break;
    }
  #endif
  
<span class="udiff-line-modified-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">-   /* Pragma        iArg</span>
<span class="udiff-line-removed">-   ** ----------   ------</span>
<span class="udiff-line-removed">-   **  key           0</span>
<span class="udiff-line-removed">-   **  rekey         1</span>
<span class="udiff-line-removed">-   **  hexkey        2</span>
<span class="udiff-line-removed">-   **  hexrekey      3</span>
<span class="udiff-line-removed">-   **  textkey       4</span>
<span class="udiff-line-removed">-   **  textrekey     5</span>
<span class="udiff-line-removed">-   */</span>
<span class="udiff-line-removed">-   case PragTyp_KEY: {</span>
<span class="udiff-line-removed">-     if( zRight ){</span>
<span class="udiff-line-removed">-       char zBuf[40];</span>
<span class="udiff-line-removed">-       const char *zKey = zRight;</span>
<span class="udiff-line-removed">-       int n;</span>
<span class="udiff-line-removed">-       if( pPragma-&gt;iArg==2 || pPragma-&gt;iArg==3 ){</span>
<span class="udiff-line-removed">-         u8 iByte;</span>
<span class="udiff-line-removed">-         int i;</span>
<span class="udiff-line-removed">-         for(i=0, iByte=0; i&lt;sizeof(zBuf)*2 &amp;&amp; sqlite3Isxdigit(zRight[i]); i++){</span>
<span class="udiff-line-removed">-           iByte = (iByte&lt;&lt;4) + sqlite3HexToInt(zRight[i]);</span>
<span class="udiff-line-removed">-           if( (i&amp;1)!=0 ) zBuf[i/2] = iByte;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         zKey = zBuf;</span>
<span class="udiff-line-removed">-         n = i/2;</span>
<span class="udiff-line-removed">-       }else{</span>
<span class="udiff-line-removed">-         n = pPragma-&gt;iArg&lt;4 ? sqlite3Strlen30(zRight) : -1;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       if( (pPragma-&gt;iArg &amp; 1)==0 ){</span>
<span class="udiff-line-removed">-         rc = sqlite3_key_v2(db, zDb, zKey, n);</span>
<span class="udiff-line-removed">-       }else{</span>
<span class="udiff-line-removed">-         rc = sqlite3_rekey_v2(db, zDb, zKey, n);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       if( rc==SQLITE_OK &amp;&amp; n!=0 ){</span>
<span class="udiff-line-removed">-         sqlite3VdbeSetNumCols(v, 1);</span>
<span class="udiff-line-removed">-         sqlite3VdbeSetColName(v, 0, COLNAME_NAME, &quot;ok&quot;, SQLITE_STATIC);</span>
<span class="udiff-line-removed">-         returnSingleText(v, &quot;ok&quot;);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     break;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- #if defined(SQLITE_HAS_CODEC) || defined(SQLITE_ENABLE_CEROD)</span>
<span class="udiff-line-modified-added">+ #if defined(SQLITE_ENABLE_CEROD)</span>
    case PragTyp_ACTIVATE_EXTENSIONS: if( zRight ){
<span class="udiff-line-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">-     if( sqlite3StrNICmp(zRight, &quot;see-&quot;, 4)==0 ){</span>
<span class="udiff-line-removed">-       sqlite3_activate_see(&amp;zRight[4]);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- #ifdef SQLITE_ENABLE_CEROD</span>
      if( sqlite3StrNICmp(zRight, &quot;cerod-&quot;, 6)==0 ){
        sqlite3_activate_cerod(&amp;zRight[6]);
      }
<span class="udiff-line-removed">- #endif</span>
    }
    break;
  #endif
  
    } /* End of the PRAGMA switch */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -127022,11 +128098,11 @@</span>
    int iDb = pData-&gt;iDb;
  
    assert( argc==5 );
    UNUSED_PARAMETER2(NotUsed, argc);
    assert( sqlite3_mutex_held(db-&gt;mutex) );
<span class="udiff-line-modified-removed">-   DbClearProperty(db, iDb, DB_Empty);</span>
<span class="udiff-line-modified-added">+   db-&gt;mDbFlags |= DBFLAG_EncodingFixed;</span>
    pData-&gt;nInitRow++;
    if( db-&gt;mallocFailed ){
      corruptSchema(pData, argv[1], 0);
      return 1;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -127110,10 +128186,11 @@</span>
    char const *azArg[6];
    int meta[5];
    InitData initData;
    const char *zMasterName;
    int openedTransaction = 0;
<span class="udiff-line-added">+   int mask = ((db-&gt;mDbFlags &amp; DBFLAG_EncodingFixed) | ~DBFLAG_EncodingFixed);</span>
  
    assert( (db-&gt;mDbFlags &amp; DBFLAG_SchemaKnownOk)==0 );
    assert( iDb&gt;=0 &amp;&amp; iDb&lt;db-&gt;nDb );
    assert( db-&gt;aDb[iDb].pSchema );
    assert( sqlite3_mutex_held(db-&gt;mutex) );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -127138,10 +128215,11 @@</span>
    initData.rc = SQLITE_OK;
    initData.pzErrMsg = pzErrMsg;
    initData.mInitFlags = mFlags;
    initData.nInitRow = 0;
    sqlite3InitCallback(&amp;initData, 5, (char **)azArg, 0);
<span class="udiff-line-added">+   db-&gt;mDbFlags &amp;= mask;</span>
    if( initData.rc ){
      rc = initData.rc;
      goto error_out;
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -127197,31 +128275,29 @@</span>
    ** main database, set sqlite3.enc to the encoding of the main database.
    ** For an attached db, it is an error if the encoding is not the same
    ** as sqlite3.enc.
    */
    if( meta[BTREE_TEXT_ENCODING-1] ){  /* text encoding */
<span class="udiff-line-modified-removed">-     if( iDb==0 ){</span>
<span class="udiff-line-removed">- #ifndef SQLITE_OMIT_UTF16</span>
<span class="udiff-line-modified-added">+     if( iDb==0 &amp;&amp; (db-&gt;mDbFlags &amp; DBFLAG_EncodingFixed)==0 ){</span>
        u8 encoding;
<span class="udiff-line-added">+ #ifndef SQLITE_OMIT_UTF16</span>
        /* If opening the main database, set ENC(db). */
        encoding = (u8)meta[BTREE_TEXT_ENCODING-1] &amp; 3;
        if( encoding==0 ) encoding = SQLITE_UTF8;
<span class="udiff-line-removed">-       ENC(db) = encoding;</span>
  #else
<span class="udiff-line-modified-removed">-       ENC(db) = SQLITE_UTF8;</span>
<span class="udiff-line-modified-added">+       encoding = SQLITE_UTF8;</span>
  #endif
<span class="udiff-line-added">+       sqlite3SetTextEncoding(db, encoding);</span>
      }else{
        /* If opening an attached database, the encoding much match ENC(db) */
<span class="udiff-line-modified-removed">-       if( meta[BTREE_TEXT_ENCODING-1]!=ENC(db) ){</span>
<span class="udiff-line-modified-added">+       if( (meta[BTREE_TEXT_ENCODING-1] &amp; 3)!=ENC(db) ){</span>
          sqlite3SetString(pzErrMsg, db, &quot;attached databases must use the same&quot;
              &quot; text encoding as main database&quot;);
          rc = SQLITE_ERROR;
          goto initone_error_out;
        }
      }
<span class="udiff-line-removed">-   }else{</span>
<span class="udiff-line-removed">-     DbSetProperty(db, iDb, DB_Empty);</span>
    }
    pDb-&gt;pSchema-&gt;enc = ENC(db);
  
    if( pDb-&gt;pSchema-&gt;cache_size==0 ){
  #ifndef SQLITE_OMIT_DEPRECATED
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -127329,12 +128405,11 @@</span>
  ** used to store temporary tables, and any additional database files
  ** created using ATTACH statements.  Return a success code.  If an
  ** error occurs, write an error message into *pzErrMsg.
  **
  ** After a database is initialized, the DB_SchemaLoaded bit is set
<span class="udiff-line-modified-removed">- ** bit is set in the flags field of the Db structure. If the database</span>
<span class="udiff-line-removed">- ** file was of zero-length, then the DB_Empty flag is also set.</span>
<span class="udiff-line-modified-added">+ ** bit is set in the flags field of the Db structure.</span>
  */
  SQLITE_PRIVATE int sqlite3Init(sqlite3 *db, char **pzErrMsg){
    int i, rc;
    int commit_internal = !(db-&gt;mDbFlags&amp;DBFLAG_SchemaChange);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -127461,15 +128536,30 @@</span>
      assert( i&gt;=0 &amp;&amp; i&lt;db-&gt;nDb );
    }
    return i;
  }
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Deallocate a single AggInfo object</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static void agginfoFree(sqlite3 *db, AggInfo *p){</span>
<span class="udiff-line-added">+   sqlite3DbFree(db, p-&gt;aCol);</span>
<span class="udiff-line-added">+   sqlite3DbFree(db, p-&gt;aFunc);</span>
<span class="udiff-line-added">+   sqlite3DbFree(db, p);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /*
  ** Free all memory allocations in the pParse object
  */
  SQLITE_PRIVATE void sqlite3ParserReset(Parse *pParse){
    sqlite3 *db = pParse-&gt;db;
<span class="udiff-line-added">+   AggInfo *pThis = pParse-&gt;pAggList;</span>
<span class="udiff-line-added">+   while( pThis ){</span>
<span class="udiff-line-added">+     AggInfo *pNext = pThis-&gt;pNext;</span>
<span class="udiff-line-added">+     agginfoFree(db, pThis);</span>
<span class="udiff-line-added">+     pThis = pNext;</span>
<span class="udiff-line-added">+   }</span>
    sqlite3DbFree(db, pParse-&gt;aLabel);
    sqlite3ExprListDelete(db, pParse-&gt;pConstExpr);
    if( db ){
      assert( db-&gt;lookaside.bDisable &gt;= pParse-&gt;disableLookaside );
      db-&gt;lookaside.bDisable -= pParse-&gt;disableLookaside;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -127966,11 +129056,10 @@</span>
      sqlite3ExprDelete(db, p-&gt;pLimit);
  #ifndef SQLITE_OMIT_WINDOWFUNC
      if( OK_IF_ALWAYS_TRUE(p-&gt;pWinDefn) ){
        sqlite3WindowListDelete(db, p-&gt;pWinDefn);
      }
<span class="udiff-line-removed">-     assert( p-&gt;pWin==0 );</span>
  #endif
      if( OK_IF_ALWAYS_TRUE(p-&gt;pWith) ) sqlite3WithDelete(db, p-&gt;pWith);
      if( bFree ) sqlite3DbFreeNN(db, p);
      p = pPrior;
      bFree = 1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -129887,10 +130976,11 @@</span>
        }
        zName = sqlite3MPrintf(db, &quot;%.*z:%u&quot;, nName, zName, ++cnt);
        if( cnt&gt;3 ) sqlite3_randomness(sizeof(cnt), &amp;cnt);
      }
      pCol-&gt;zName = zName;
<span class="udiff-line-added">+     pCol-&gt;hName = sqlite3StrIHash(zName);</span>
      sqlite3ColumnPropertiesFromName(0, pCol);
      if( zName &amp;&amp; sqlite3HashInsert(&amp;ht, zName, pCol)==pCol ){
        sqlite3OomFault(db);
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -130580,13 +131670,11 @@</span>
          uniondest.eDest = op;
          ExplainQueryPlan((pParse, 1, &quot;%s USING TEMP B-TREE&quot;,
                            selectOpName(p-&gt;op)));
          rc = sqlite3Select(pParse, p, &amp;uniondest);
          testcase( rc!=SQLITE_OK );
<span class="udiff-line-modified-removed">-         /* Query flattening in sqlite3Select() might refill p-&gt;pOrderBy.</span>
<span class="udiff-line-removed">-         ** Be sure to delete p-&gt;pOrderBy, therefore, to avoid a memory leak. */</span>
<span class="udiff-line-removed">-         sqlite3ExprListDelete(db, p-&gt;pOrderBy);</span>
<span class="udiff-line-modified-added">+         assert( p-&gt;pOrderBy==0 );</span>
          pDelete = p-&gt;pPrior;
          p-&gt;pPrior = pPrior;
          p-&gt;pOrderBy = 0;
          if( p-&gt;op==TK_UNION ){
            p-&gt;nSelectRow = sqlite3LogEstAdd(p-&gt;nSelectRow, pPrior-&gt;nSelectRow);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -130669,10 +131757,11 @@</span>
          p-&gt;pLimit = pLimit;
  
          /* Generate code to take the intersection of the two temporary
          ** tables.
          */
<span class="udiff-line-added">+         if( rc ) break;</span>
          assert( p-&gt;pEList );
          iBreak = sqlite3VdbeMakeLabel(pParse);
          iCont = sqlite3VdbeMakeLabel(pParse);
          computeLimitRegisters(pParse, p, iBreak);
          sqlite3VdbeAddOp2(v, OP_Rewind, tab1, iBreak); VdbeCoverage(v);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -131339,11 +132428,14 @@</span>
    if( ExprHasProperty(pExpr, EP_FromJoin)
     &amp;&amp; pExpr-&gt;iRightJoinTable==pSubst-&gt;iTable
    ){
      pExpr-&gt;iRightJoinTable = pSubst-&gt;iNewTable;
    }
<span class="udiff-line-modified-removed">-   if( pExpr-&gt;op==TK_COLUMN &amp;&amp; pExpr-&gt;iTable==pSubst-&gt;iTable ){</span>
<span class="udiff-line-modified-added">+   if( pExpr-&gt;op==TK_COLUMN</span>
<span class="udiff-line-added">+    &amp;&amp; pExpr-&gt;iTable==pSubst-&gt;iTable</span>
<span class="udiff-line-added">+    &amp;&amp; !ExprHasProperty(pExpr, EP_FixedCol)</span>
<span class="udiff-line-added">+   ){</span>
      if( pExpr-&gt;iColumn&lt;0 ){
        pExpr-&gt;op = TK_NULL;
      }else{
        Expr *pNew;
        Expr *pCopy = pSubst-&gt;pEList-&gt;a[pExpr-&gt;iColumn].pExpr;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -131357,10 +132449,11 @@</span>
          if( pSubst-&gt;isLeftJoin &amp;&amp; pCopy-&gt;op!=TK_COLUMN ){
            memset(&amp;ifNullRow, 0, sizeof(ifNullRow));
            ifNullRow.op = TK_IF_NULL_ROW;
            ifNullRow.pLeft = pCopy;
            ifNullRow.iTable = pSubst-&gt;iNewTable;
<span class="udiff-line-added">+           ifNullRow.flags = EP_Skip;</span>
            pCopy = &amp;ifNullRow;
          }
          testcase( ExprHasProperty(pCopy, EP_Subquery) );
          pNew = sqlite3ExprDup(db, pCopy, 0);
          if( pNew &amp;&amp; pSubst-&gt;isLeftJoin ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -131443,10 +132536,42 @@</span>
      }
    }while( doPrior &amp;&amp; (p = p-&gt;pPrior)!=0 );
  }
  #endif /* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */
  
<span class="udiff-line-added">+ #if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)</span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** pSelect is a SELECT statement and pSrcItem is one item in the FROM</span>
<span class="udiff-line-added">+ ** clause of that SELECT.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** This routine scans the entire SELECT statement and recomputes the</span>
<span class="udiff-line-added">+ ** pSrcItem-&gt;colUsed mask.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static int recomputeColumnsUsedExpr(Walker *pWalker, Expr *pExpr){</span>
<span class="udiff-line-added">+   struct SrcList_item *pItem;</span>
<span class="udiff-line-added">+   if( pExpr-&gt;op!=TK_COLUMN ) return WRC_Continue;</span>
<span class="udiff-line-added">+   pItem = pWalker-&gt;u.pSrcItem;</span>
<span class="udiff-line-added">+   if( pItem-&gt;iCursor!=pExpr-&gt;iTable ) return WRC_Continue;</span>
<span class="udiff-line-added">+   if( pExpr-&gt;iColumn&lt;0 ) return WRC_Continue;</span>
<span class="udiff-line-added">+   pItem-&gt;colUsed |= sqlite3ExprColUsed(pExpr);</span>
<span class="udiff-line-added">+   return WRC_Continue;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ static void recomputeColumnsUsed(</span>
<span class="udiff-line-added">+   Select *pSelect,                 /* The complete SELECT statement */</span>
<span class="udiff-line-added">+   struct SrcList_item *pSrcItem    /* Which FROM clause item to recompute */</span>
<span class="udiff-line-added">+ ){</span>
<span class="udiff-line-added">+   Walker w;</span>
<span class="udiff-line-added">+   if( NEVER(pSrcItem-&gt;pTab==0) ) return;</span>
<span class="udiff-line-added">+   memset(&amp;w, 0, sizeof(w));</span>
<span class="udiff-line-added">+   w.xExprCallback = recomputeColumnsUsedExpr;</span>
<span class="udiff-line-added">+   w.xSelectCallback = sqlite3SelectWalkNoop;</span>
<span class="udiff-line-added">+   w.u.pSrcItem = pSrcItem;</span>
<span class="udiff-line-added">+   pSrcItem-&gt;colUsed = 0;</span>
<span class="udiff-line-added">+   sqlite3WalkSelect(&amp;w, pSelect);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #endif /* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */</span>
<span class="udiff-line-added">+ </span>
  #if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
  /*
  ** This routine attempts to flatten subqueries as a performance optimization.
  ** This routine returns 1 if it makes changes and 0 if no flattening occurs.
  **
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -131618,10 +132743,11 @@</span>
    int isLeftJoin = 0; /* True if pSub is the right side of a LEFT JOIN */
    int i;              /* Loop counter */
    Expr *pWhere;                    /* The WHERE clause */
    struct SrcList_item *pSubitem;   /* The subquery */
    sqlite3 *db = pParse-&gt;db;
<span class="udiff-line-added">+   Walker w;                        /* Walker to persist agginfo data */</span>
  
    /* Check to see if flattening is permitted.  Return 0 if not.
    */
    assert( p!=0 );
    assert( p-&gt;pPrior==0 );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -131931,11 +133057,11 @@</span>
      **    \_____________________ outer query ______________________________/
      **
      ** We look at every expression in the outer query and every place we see
      ** &quot;a&quot; we substitute &quot;x*3&quot; and every place we see &quot;b&quot; we substitute &quot;y+10&quot;.
      */
<span class="udiff-line-modified-removed">-     if( pSub-&gt;pOrderBy ){</span>
<span class="udiff-line-modified-added">+     if( pSub-&gt;pOrderBy &amp;&amp; (pParent-&gt;selFlags &amp; SF_NoopOrderBy)==0 ){</span>
        /* At this point, any non-zero iOrderByCol values indicate that the
        ** ORDER BY column expression is identical to the iOrderByCol&#39;th
        ** expression returned by SELECT statement pSub. Since these values
        ** do not necessarily correspond to columns in SELECT statement pParent,
        ** zero them before transfering the ORDER BY clause.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -131955,11 +133081,17 @@</span>
      pWhere = pSub-&gt;pWhere;
      pSub-&gt;pWhere = 0;
      if( isLeftJoin&gt;0 ){
        sqlite3SetJoinExpr(pWhere, iNewParent);
      }
<span class="udiff-line-modified-removed">-     pParent-&gt;pWhere = sqlite3ExprAnd(pParse, pWhere, pParent-&gt;pWhere);</span>
<span class="udiff-line-modified-added">+     if( pWhere ){</span>
<span class="udiff-line-added">+       if( pParent-&gt;pWhere ){</span>
<span class="udiff-line-added">+         pParent-&gt;pWhere = sqlite3PExpr(pParse, TK_AND, pWhere, pParent-&gt;pWhere);</span>
<span class="udiff-line-added">+       }else{</span>
<span class="udiff-line-added">+         pParent-&gt;pWhere = pWhere;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
      if( db-&gt;mallocFailed==0 ){
        SubstContext x;
        x.pParse = pParse;
        x.iTable = iParent;
        x.iNewTable = iNewParent;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -131981,15 +133113,23 @@</span>
      */
      if( pSub-&gt;pLimit ){
        pParent-&gt;pLimit = pSub-&gt;pLimit;
        pSub-&gt;pLimit = 0;
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /* Recompute the SrcList_item.colUsed masks for the flattened</span>
<span class="udiff-line-added">+     ** tables. */</span>
<span class="udiff-line-added">+     for(i=0; i&lt;nSubSrc; i++){</span>
<span class="udiff-line-added">+       recomputeColumnsUsed(pParent, &amp;pSrc-&gt;a[i+iFrom]);</span>
<span class="udiff-line-added">+     }</span>
    }
  
    /* Finially, delete what is left of the subquery and return
    ** success.
    */
<span class="udiff-line-added">+   sqlite3AggInfoPersistWalkerInit(&amp;w, pParse);</span>
<span class="udiff-line-added">+   sqlite3WalkSelect(&amp;w,pSub1);</span>
    sqlite3SelectDelete(db, pSub1);
  
  #if SELECTTRACE_ENABLED
    if( sqlite3SelectTrace &amp; 0x100 ){
      SELECTTRACE(0x100,pParse,p,(&quot;After flattening:\n&quot;));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -132029,13 +133169,12 @@</span>
  ){
    int i;
    assert( pColumn-&gt;op==TK_COLUMN );
    assert( sqlite3ExprIsConstant(pValue) );
  
<span class="udiff-line-modified-removed">-   if( !ExprHasProperty(pValue, EP_FixedCol) &amp;&amp; sqlite3ExprAffinity(pValue)!=0 ){</span>
<span class="udiff-line-modified-removed">-     return;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   if( ExprHasProperty(pColumn, EP_FixedCol) ) return;</span>
<span class="udiff-line-modified-added">+   if( sqlite3ExprAffinity(pValue)!=0 ) return;</span>
    if( !sqlite3IsBinary(sqlite3ExprCompareCollSeq(pConst-&gt;pParse,pExpr)) ){
      return;
    }
  
    /* 2018-10-25 ticket [cf5ed20f]
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -132054,13 +133193,10 @@</span>
    pConst-&gt;apExpr = sqlite3DbReallocOrFree(pConst-&gt;pParse-&gt;db, pConst-&gt;apExpr,
                           pConst-&gt;nConst*2*sizeof(Expr*));
    if( pConst-&gt;apExpr==0 ){
      pConst-&gt;nConst = 0;
    }else{
<span class="udiff-line-removed">-     if( ExprHasProperty(pValue, EP_FixedCol) ){</span>
<span class="udiff-line-removed">-       pValue = pValue-&gt;pLeft;</span>
<span class="udiff-line-removed">-     }</span>
      pConst-&gt;apExpr[pConst-&gt;nConst*2-2] = pColumn;
      pConst-&gt;apExpr[pConst-&gt;nConst*2-1] = pValue;
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -132250,15 +133386,18 @@</span>
    int iCursor,          /* Cursor number of the subquery */
    int isLeftJoin        /* True if pSubq is the right term of a LEFT JOIN */
  ){
    Expr *pNew;
    int nChng = 0;
<span class="udiff-line-added">+   Select *pSel;</span>
    if( pWhere==0 ) return 0;
    if( pSubq-&gt;selFlags &amp; SF_Recursive ) return 0;  /* restriction (2) */
  
  #ifndef SQLITE_OMIT_WINDOWFUNC
<span class="udiff-line-modified-removed">-   if( pSubq-&gt;pWin ) return 0;    /* restriction (6) */</span>
<span class="udiff-line-modified-added">+   for(pSel=pSubq; pSel; pSel=pSel-&gt;pPrior){</span>
<span class="udiff-line-added">+     if( pSel-&gt;pWin ) return 0;    /* restriction (6) */</span>
<span class="udiff-line-added">+   }</span>
  #endif
  
  #ifdef SQLITE_DEBUG
    /* Only the first term of a compound can have a WITH clause.  But make
    ** sure no other terms are marked SF_Recursive in case something changes
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -132332,22 +133471,24 @@</span>
  static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax){
    int eRet = WHERE_ORDERBY_NORMAL;      /* Return value */
    ExprList *pEList = pFunc-&gt;x.pList;    /* Arguments to agg function */
    const char *zFunc;                    /* Name of aggregate function pFunc */
    ExprList *pOrderBy;
<span class="udiff-line-modified-removed">-   u8 sortFlags;</span>
<span class="udiff-line-modified-added">+   u8 sortFlags = 0;</span>
  
    assert( *ppMinMax==0 );
    assert( pFunc-&gt;op==TK_AGG_FUNCTION );
    assert( !IsWindowFunc(pFunc) );
    if( pEList==0 || pEList-&gt;nExpr!=1 || ExprHasProperty(pFunc, EP_WinFunc) ){
      return eRet;
    }
    zFunc = pFunc-&gt;u.zToken;
    if( sqlite3StrICmp(zFunc, &quot;min&quot;)==0 ){
      eRet = WHERE_ORDERBY_MIN;
<span class="udiff-line-modified-removed">-     sortFlags = KEYINFO_ORDER_BIGNULL;</span>
<span class="udiff-line-modified-added">+     if( sqlite3ExprCanBeNull(pEList-&gt;a[0].pExpr) ){</span>
<span class="udiff-line-added">+       sortFlags = KEYINFO_ORDER_BIGNULL;</span>
<span class="udiff-line-added">+     }</span>
    }else if( sqlite3StrICmp(zFunc, &quot;max&quot;)==0 ){
      eRet = WHERE_ORDERBY_MAX;
      sortFlags = KEYINFO_ORDER_DESC;
    }else{
      return eRet;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -132452,10 +133593,18 @@</span>
    if( p-&gt;pPrior==0 ) return WRC_Continue;
    if( p-&gt;pOrderBy==0 ) return WRC_Continue;
    for(pX=p; pX &amp;&amp; (pX-&gt;op==TK_ALL || pX-&gt;op==TK_SELECT); pX=pX-&gt;pPrior){}
    if( pX==0 ) return WRC_Continue;
    a = p-&gt;pOrderBy-&gt;a;
<span class="udiff-line-added">+ #ifndef SQLITE_OMIT_WINDOWFUNC</span>
<span class="udiff-line-added">+   /* If iOrderByCol is already non-zero, then it has already been matched</span>
<span class="udiff-line-added">+   ** to a result column of the SELECT statement. This occurs when the</span>
<span class="udiff-line-added">+   ** SELECT is rewritten for window-functions processing and then passed</span>
<span class="udiff-line-added">+   ** to sqlite3SelectPrep() and similar a second time. The rewriting done</span>
<span class="udiff-line-added">+   ** by this function is not required in this case. */</span>
<span class="udiff-line-added">+   if( a[0].u.x.iOrderByCol ) return WRC_Continue;</span>
<span class="udiff-line-added">+ #endif</span>
    for(i=p-&gt;pOrderBy-&gt;nExpr-1; i&gt;=0; i--){
      if( a[i].pExpr-&gt;flags &amp; EP_Collate ) break;
    }
    if( i&lt;0 ) return WRC_Continue;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -133011,11 +134160,11 @@</span>
                pExpr = pRight;
              }
              pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);
              sqlite3TokenInit(&amp;sColname, zColname);
              sqlite3ExprListSetName(pParse, pNew, &amp;sColname, 0);
<span class="udiff-line-modified-removed">-             if( pNew &amp;&amp; (p-&gt;selFlags &amp; SF_NestedFrom)!=0 ){</span>
<span class="udiff-line-modified-added">+             if( pNew &amp;&amp; (p-&gt;selFlags &amp; SF_NestedFrom)!=0 &amp;&amp; !IN_RENAME_OBJECT ){</span>
                struct ExprList_item *pX = &amp;pNew-&gt;a[pNew-&gt;nExpr-1];
                sqlite3DbFree(db, pX-&gt;zEName);
                if( pSub ){
                  pX-&gt;zEName = sqlite3DbStrDup(db, pSub-&gt;pEList-&gt;a[j].zEName);
                  testcase( pX-&gt;zEName==0 );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -133051,33 +134200,10 @@</span>
      }
    }
    return WRC_Continue;
  }
  
<span class="udiff-line-removed">- /*</span>
<span class="udiff-line-removed">- ** No-op routine for the parse-tree walker.</span>
<span class="udiff-line-removed">- **</span>
<span class="udiff-line-removed">- ** When this routine is the Walker.xExprCallback then expression trees</span>
<span class="udiff-line-removed">- ** are walked without any actions being taken at each node.  Presumably,</span>
<span class="udiff-line-removed">- ** when this routine is used for Walker.xExprCallback then</span>
<span class="udiff-line-removed">- ** Walker.xSelectCallback is set to do something useful for every</span>
<span class="udiff-line-removed">- ** subquery in the parser tree.</span>
<span class="udiff-line-removed">- */</span>
<span class="udiff-line-removed">- SQLITE_PRIVATE int sqlite3ExprWalkNoop(Walker *NotUsed, Expr *NotUsed2){</span>
<span class="udiff-line-removed">-   UNUSED_PARAMETER2(NotUsed, NotUsed2);</span>
<span class="udiff-line-removed">-   return WRC_Continue;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- /*</span>
<span class="udiff-line-removed">- ** No-op routine for the parse-tree walker for SELECT statements.</span>
<span class="udiff-line-removed">- ** subquery in the parser tree.</span>
<span class="udiff-line-removed">- */</span>
<span class="udiff-line-removed">- SQLITE_PRIVATE int sqlite3SelectWalkNoop(Walker *NotUsed, Select *NotUsed2){</span>
<span class="udiff-line-removed">-   UNUSED_PARAMETER2(NotUsed, NotUsed2);</span>
<span class="udiff-line-removed">-   return WRC_Continue;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  #if SQLITE_DEBUG
  /*
  ** Always assert.  This xSelectCallback2 implementation proves that the
  ** xSelectCallback2 is never invoked.
  */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -133215,10 +134341,11 @@</span>
    Vdbe *v = pParse-&gt;pVdbe;
    int i;
    struct AggInfo_func *pFunc;
    int nReg = pAggInfo-&gt;nFunc + pAggInfo-&gt;nColumn;
    if( nReg==0 ) return;
<span class="udiff-line-added">+   if( pParse-&gt;nErr ) return;</span>
  #ifdef SQLITE_DEBUG
    /* Verify that all AggInfo registers are within the range specified by
    ** AggInfo.mnReg..AggInfo.mxReg */
    assert( nReg==pAggInfo-&gt;mxReg-pAggInfo-&gt;mnReg+1 );
    for(i=0; i&lt;pAggInfo-&gt;nColumn; i++){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -133356,11 +134483,11 @@</span>
      sqlite3ExprCode(pParse, pC-&gt;pExpr, pC-&gt;iMem);
    }
  
    pAggInfo-&gt;directMode = 0;
    if( addrHitTest ){
<span class="udiff-line-modified-removed">-     sqlite3VdbeJumpHere(v, addrHitTest);</span>
<span class="udiff-line-modified-added">+     sqlite3VdbeJumpHereOrPopInst(v, addrHitTest);</span>
    }
  }
  
  /*
  ** Add a single OP_Explain instruction to the VDBE to explain a simple
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -133594,14 +134721,14 @@</span>
    ExprList *pEList = 0;  /* List of columns to extract. */
    SrcList *pTabList;     /* List of tables to select from */
    Expr *pWhere;          /* The WHERE clause.  May be NULL */
    ExprList *pGroupBy;    /* The GROUP BY clause.  May be NULL */
    Expr *pHaving;         /* The HAVING clause.  May be NULL */
<span class="udiff-line-added">+   AggInfo *pAggInfo = 0; /* Aggregate information */</span>
    int rc = 1;            /* Value to return from this function */
    DistinctCtx sDistinct; /* Info on how to code the DISTINCT keyword */
    SortCtx sSort;         /* Info on how to code the ORDER BY clause */
<span class="udiff-line-removed">-   AggInfo sAggInfo;      /* Information used by aggregate queries */</span>
    int iEnd;              /* Address of the end of the query */
    sqlite3 *db;           /* The database connection */
    ExprList *pMinMaxOrderBy = 0;  /* Added ORDER BY for min/max queries */
    u8 minMaxFlag;                 /* Flag for min/max queries */
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -133609,11 +134736,10 @@</span>
    v = sqlite3GetVdbe(pParse);
    if( p==0 || db-&gt;mallocFailed || pParse-&gt;nErr ){
      return 1;
    }
    if( sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0) ) return 1;
<span class="udiff-line-removed">-   memset(&amp;sAggInfo, 0, sizeof(sAggInfo));</span>
  #if SELECTTRACE_ENABLED
    SELECTTRACE(1,pParse,p, (&quot;begin processing:\n&quot;, pParse-&gt;addrExplain));
    if( sqlite3SelectTrace &amp; 0x100 ){
      sqlite3TreeViewSelect(0, p, 0);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -133631,10 +134757,11 @@</span>
      /* If ORDER BY makes no difference in the output then neither does
      ** DISTINCT so it can be removed too. */
      sqlite3ExprListDelete(db, p-&gt;pOrderBy);
      p-&gt;pOrderBy = 0;
      p-&gt;selFlags &amp;= ~SF_Distinct;
<span class="udiff-line-added">+     p-&gt;selFlags |= SF_NoopOrderBy;</span>
    }
    sqlite3SelectPrep(pParse, p, 0);
    if( pParse-&gt;nErr || db-&gt;mallocFailed ){
      goto select_end;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -134199,18 +135326,24 @@</span>
  
      /* Convert TK_COLUMN nodes into TK_AGG_COLUMN and make entries in
      ** sAggInfo for all TK_AGG_FUNCTION nodes in expressions of the
      ** SELECT statement.
      */
<span class="udiff-line-added">+     pAggInfo = sqlite3DbMallocZero(db, sizeof(*pAggInfo) );</span>
<span class="udiff-line-added">+     if( pAggInfo==0 ){</span>
<span class="udiff-line-added">+       goto select_end;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     pAggInfo-&gt;pNext = pParse-&gt;pAggList;</span>
<span class="udiff-line-added">+     pParse-&gt;pAggList = pAggInfo;</span>
      memset(&amp;sNC, 0, sizeof(sNC));
      sNC.pParse = pParse;
      sNC.pSrcList = pTabList;
<span class="udiff-line-modified-removed">-     sNC.uNC.pAggInfo = &amp;sAggInfo;</span>
<span class="udiff-line-modified-added">+     sNC.uNC.pAggInfo = pAggInfo;</span>
      VVA_ONLY( sNC.ncFlags = NC_UAggInfo; )
<span class="udiff-line-modified-removed">-     sAggInfo.mnReg = pParse-&gt;nMem+1;</span>
<span class="udiff-line-modified-removed">-     sAggInfo.nSortingColumn = pGroupBy ? pGroupBy-&gt;nExpr : 0;</span>
<span class="udiff-line-modified-removed">-     sAggInfo.pGroupBy = pGroupBy;</span>
<span class="udiff-line-modified-added">+     pAggInfo-&gt;mnReg = pParse-&gt;nMem+1;</span>
<span class="udiff-line-modified-added">+     pAggInfo-&gt;nSortingColumn = pGroupBy ? pGroupBy-&gt;nExpr : 0;</span>
<span class="udiff-line-modified-added">+     pAggInfo-&gt;pGroupBy = pGroupBy;</span>
      sqlite3ExprAnalyzeAggList(&amp;sNC, pEList);
      sqlite3ExprAnalyzeAggList(&amp;sNC, sSort.pOrderBy);
      if( pHaving ){
        if( pGroupBy ){
          assert( pWhere==p-&gt;pWhere );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -134219,18 +135352,18 @@</span>
          havingToWhere(pParse, p);
          pWhere = p-&gt;pWhere;
        }
        sqlite3ExprAnalyzeAggregates(&amp;sNC, pHaving);
      }
<span class="udiff-line-modified-removed">-     sAggInfo.nAccumulator = sAggInfo.nColumn;</span>
<span class="udiff-line-modified-removed">-     if( p-&gt;pGroupBy==0 &amp;&amp; p-&gt;pHaving==0 &amp;&amp; sAggInfo.nFunc==1 ){</span>
<span class="udiff-line-modified-removed">-       minMaxFlag = minMaxQuery(db, sAggInfo.aFunc[0].pExpr, &amp;pMinMaxOrderBy);</span>
<span class="udiff-line-modified-added">+     pAggInfo-&gt;nAccumulator = pAggInfo-&gt;nColumn;</span>
<span class="udiff-line-modified-added">+     if( p-&gt;pGroupBy==0 &amp;&amp; p-&gt;pHaving==0 &amp;&amp; pAggInfo-&gt;nFunc==1 ){</span>
<span class="udiff-line-modified-added">+       minMaxFlag = minMaxQuery(db, pAggInfo-&gt;aFunc[0].pExpr, &amp;pMinMaxOrderBy);</span>
      }else{
        minMaxFlag = WHERE_ORDERBY_NORMAL;
      }
<span class="udiff-line-modified-removed">-     for(i=0; i&lt;sAggInfo.nFunc; i++){</span>
<span class="udiff-line-modified-removed">-       Expr *pExpr = sAggInfo.aFunc[i].pExpr;</span>
<span class="udiff-line-modified-added">+     for(i=0; i&lt;pAggInfo-&gt;nFunc; i++){</span>
<span class="udiff-line-modified-added">+       Expr *pExpr = pAggInfo-&gt;aFunc[i].pExpr;</span>
        assert( !ExprHasProperty(pExpr, EP_xIsSelect) );
        sNC.ncFlags |= NC_InAggFunc;
        sqlite3ExprAnalyzeAggList(&amp;sNC, pExpr-&gt;x.pList);
  #ifndef SQLITE_OMIT_WINDOWFUNC
        assert( !IsWindowFunc(pExpr) );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -134238,26 +135371,26 @@</span>
          sqlite3ExprAnalyzeAggregates(&amp;sNC, pExpr-&gt;y.pWin-&gt;pFilter);
        }
  #endif
        sNC.ncFlags &amp;= ~NC_InAggFunc;
      }
<span class="udiff-line-modified-removed">-     sAggInfo.mxReg = pParse-&gt;nMem;</span>
<span class="udiff-line-modified-added">+     pAggInfo-&gt;mxReg = pParse-&gt;nMem;</span>
      if( db-&gt;mallocFailed ) goto select_end;
  #if SELECTTRACE_ENABLED
      if( sqlite3SelectTrace &amp; 0x400 ){
        int ii;
<span class="udiff-line-modified-removed">-       SELECTTRACE(0x400,pParse,p,(&quot;After aggregate analysis:\n&quot;));</span>
<span class="udiff-line-modified-added">+       SELECTTRACE(0x400,pParse,p,(&quot;After aggregate analysis %p:\n&quot;, pAggInfo));</span>
        sqlite3TreeViewSelect(0, p, 0);
<span class="udiff-line-modified-removed">-       for(ii=0; ii&lt;sAggInfo.nColumn; ii++){</span>
<span class="udiff-line-modified-added">+       for(ii=0; ii&lt;pAggInfo-&gt;nColumn; ii++){</span>
          sqlite3DebugPrintf(&quot;agg-column[%d] iMem=%d\n&quot;,
<span class="udiff-line-modified-removed">-             ii, sAggInfo.aCol[ii].iMem);</span>
<span class="udiff-line-modified-removed">-         sqlite3TreeViewExpr(0, sAggInfo.aCol[ii].pExpr, 0);</span>
<span class="udiff-line-modified-added">+             ii, pAggInfo-&gt;aCol[ii].iMem);</span>
<span class="udiff-line-modified-added">+         sqlite3TreeViewExpr(0, pAggInfo-&gt;aCol[ii].pExpr, 0);</span>
        }
<span class="udiff-line-modified-removed">-       for(ii=0; ii&lt;sAggInfo.nFunc; ii++){</span>
<span class="udiff-line-modified-added">+       for(ii=0; ii&lt;pAggInfo-&gt;nFunc; ii++){</span>
          sqlite3DebugPrintf(&quot;agg-func[%d]: iMem=%d\n&quot;,
<span class="udiff-line-modified-removed">-             ii, sAggInfo.aFunc[ii].iMem);</span>
<span class="udiff-line-modified-removed">-         sqlite3TreeViewExpr(0, sAggInfo.aFunc[ii].pExpr, 0);</span>
<span class="udiff-line-modified-added">+             ii, pAggInfo-&gt;aFunc[ii].iMem);</span>
<span class="udiff-line-modified-added">+         sqlite3TreeViewExpr(0, pAggInfo-&gt;aFunc[ii].pExpr, 0);</span>
        }
      }
  #endif
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -134278,14 +135411,15 @@</span>
        /* If there is a GROUP BY clause we might need a sorting index to
        ** implement it.  Allocate that sorting index now.  If it turns out
        ** that we do not need it after all, the OP_SorterOpen instruction
        ** will be converted into a Noop.
        */
<span class="udiff-line-modified-removed">-       sAggInfo.sortingIdx = pParse-&gt;nTab++;</span>
<span class="udiff-line-modified-removed">-       pKeyInfo = sqlite3KeyInfoFromExprList(pParse,pGroupBy,0,sAggInfo.nColumn);</span>
<span class="udiff-line-modified-added">+       pAggInfo-&gt;sortingIdx = pParse-&gt;nTab++;</span>
<span class="udiff-line-modified-added">+       pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pGroupBy,</span>
<span class="udiff-line-added">+                                             0, pAggInfo-&gt;nColumn);</span>
        addrSortingIdx = sqlite3VdbeAddOp4(v, OP_SorterOpen,
<span class="udiff-line-modified-removed">-           sAggInfo.sortingIdx, sAggInfo.nSortingColumn,</span>
<span class="udiff-line-modified-added">+           pAggInfo-&gt;sortingIdx, pAggInfo-&gt;nSortingColumn,</span>
            0, (char*)pKeyInfo, P4_KEYINFO);
  
        /* Initialize memory locations used by GROUP BY aggregate processing
        */
        iUseFlag = ++pParse-&gt;nMem;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -134336,40 +135470,40 @@</span>
  
          groupBySort = 1;
          nGroupBy = pGroupBy-&gt;nExpr;
          nCol = nGroupBy;
          j = nGroupBy;
<span class="udiff-line-modified-removed">-         for(i=0; i&lt;sAggInfo.nColumn; i++){</span>
<span class="udiff-line-modified-removed">-           if( sAggInfo.aCol[i].iSorterColumn&gt;=j ){</span>
<span class="udiff-line-modified-added">+         for(i=0; i&lt;pAggInfo-&gt;nColumn; i++){</span>
<span class="udiff-line-modified-added">+           if( pAggInfo-&gt;aCol[i].iSorterColumn&gt;=j ){</span>
              nCol++;
              j++;
            }
          }
          regBase = sqlite3GetTempRange(pParse, nCol);
          sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0, 0);
          j = nGroupBy;
<span class="udiff-line-modified-removed">-         for(i=0; i&lt;sAggInfo.nColumn; i++){</span>
<span class="udiff-line-modified-removed">-           struct AggInfo_col *pCol = &amp;sAggInfo.aCol[i];</span>
<span class="udiff-line-modified-added">+         for(i=0; i&lt;pAggInfo-&gt;nColumn; i++){</span>
<span class="udiff-line-modified-added">+           struct AggInfo_col *pCol = &amp;pAggInfo-&gt;aCol[i];</span>
            if( pCol-&gt;iSorterColumn&gt;=j ){
              int r1 = j + regBase;
              sqlite3ExprCodeGetColumnOfTable(v,
                                 pCol-&gt;pTab, pCol-&gt;iTable, pCol-&gt;iColumn, r1);
              j++;
            }
          }
          regRecord = sqlite3GetTempReg(pParse);
          sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nCol, regRecord);
<span class="udiff-line-modified-removed">-         sqlite3VdbeAddOp2(v, OP_SorterInsert, sAggInfo.sortingIdx, regRecord);</span>
<span class="udiff-line-modified-added">+         sqlite3VdbeAddOp2(v, OP_SorterInsert, pAggInfo-&gt;sortingIdx, regRecord);</span>
          sqlite3ReleaseTempReg(pParse, regRecord);
          sqlite3ReleaseTempRange(pParse, regBase, nCol);
          sqlite3WhereEnd(pWInfo);
<span class="udiff-line-modified-removed">-         sAggInfo.sortingIdxPTab = sortPTab = pParse-&gt;nTab++;</span>
<span class="udiff-line-modified-added">+         pAggInfo-&gt;sortingIdxPTab = sortPTab = pParse-&gt;nTab++;</span>
          sortOut = sqlite3GetTempReg(pParse);
          sqlite3VdbeAddOp3(v, OP_OpenPseudo, sortPTab, sortOut, nCol);
<span class="udiff-line-modified-removed">-         sqlite3VdbeAddOp2(v, OP_SorterSort, sAggInfo.sortingIdx, addrEnd);</span>
<span class="udiff-line-modified-added">+         sqlite3VdbeAddOp2(v, OP_SorterSort, pAggInfo-&gt;sortingIdx, addrEnd);</span>
          VdbeComment((v, &quot;GROUP BY sort&quot;)); VdbeCoverage(v);
<span class="udiff-line-modified-removed">-         sAggInfo.useSortingIdx = 1;</span>
<span class="udiff-line-modified-added">+         pAggInfo-&gt;useSortingIdx = 1;</span>
        }
  
        /* If the index or temporary table used by the GROUP BY sort
        ** will naturally deliver rows in the order required by the ORDER BY
        ** clause, cancel the ephemeral table open coded earlier.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -134389,18 +135523,18 @@</span>
        ** Then compare the current GROUP BY terms against the GROUP BY terms
        ** from the previous row currently stored in a0, a1, a2...
        */
        addrTopOfLoop = sqlite3VdbeCurrentAddr(v);
        if( groupBySort ){
<span class="udiff-line-modified-removed">-         sqlite3VdbeAddOp3(v, OP_SorterData, sAggInfo.sortingIdx,</span>
<span class="udiff-line-modified-added">+         sqlite3VdbeAddOp3(v, OP_SorterData, pAggInfo-&gt;sortingIdx,</span>
                            sortOut, sortPTab);
        }
        for(j=0; j&lt;pGroupBy-&gt;nExpr; j++){
          if( groupBySort ){
            sqlite3VdbeAddOp3(v, OP_Column, sortPTab, j, iBMem+j);
          }else{
<span class="udiff-line-modified-removed">-           sAggInfo.directMode = 1;</span>
<span class="udiff-line-modified-added">+           pAggInfo-&gt;directMode = 1;</span>
            sqlite3ExprCode(pParse, pGroupBy-&gt;a[j].pExpr, iBMem+j);
          }
        }
        sqlite3VdbeAddOp4(v, OP_Compare, iAMem, iBMem, pGroupBy-&gt;nExpr,
                            (char*)sqlite3KeyInfoRef(pKeyInfo), P4_KEYINFO);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -134426,18 +135560,18 @@</span>
  
        /* Update the aggregate accumulators based on the content of
        ** the current row
        */
        sqlite3VdbeJumpHere(v, addr1);
<span class="udiff-line-modified-removed">-       updateAccumulator(pParse, iUseFlag, &amp;sAggInfo);</span>
<span class="udiff-line-modified-added">+       updateAccumulator(pParse, iUseFlag, pAggInfo);</span>
        sqlite3VdbeAddOp2(v, OP_Integer, 1, iUseFlag);
        VdbeComment((v, &quot;indicate data in accumulator&quot;));
  
        /* End of the loop
        */
        if( groupBySort ){
<span class="udiff-line-modified-removed">-         sqlite3VdbeAddOp2(v, OP_SorterNext, sAggInfo.sortingIdx, addrTopOfLoop);</span>
<span class="udiff-line-modified-added">+         sqlite3VdbeAddOp2(v, OP_SorterNext, pAggInfo-&gt;sortingIdx, addrTopOfLoop);</span>
          VdbeCoverage(v);
        }else{
          sqlite3WhereEnd(pWInfo);
          sqlite3VdbeChangeToNoop(v, addrSortingIdx);
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -134466,31 +135600,30 @@</span>
        addrOutputRow = sqlite3VdbeCurrentAddr(v);
        sqlite3VdbeAddOp2(v, OP_IfPos, iUseFlag, addrOutputRow+2);
        VdbeCoverage(v);
        VdbeComment((v, &quot;Groupby result generator entry point&quot;));
        sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);
<span class="udiff-line-modified-removed">-       finalizeAggFunctions(pParse, &amp;sAggInfo);</span>
<span class="udiff-line-modified-added">+       finalizeAggFunctions(pParse, pAggInfo);</span>
        sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow+1, SQLITE_JUMPIFNULL);
        selectInnerLoop(pParse, p, -1, &amp;sSort,
                        &amp;sDistinct, pDest,
                        addrOutputRow+1, addrSetAbort);
        sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);
        VdbeComment((v, &quot;end groupby result generator&quot;));
  
        /* Generate a subroutine that will reset the group-by accumulator
        */
        sqlite3VdbeResolveLabel(v, addrReset);
<span class="udiff-line-modified-removed">-       resetAccumulator(pParse, &amp;sAggInfo);</span>
<span class="udiff-line-modified-added">+       resetAccumulator(pParse, pAggInfo);</span>
        sqlite3VdbeAddOp2(v, OP_Integer, 0, iUseFlag);
        VdbeComment((v, &quot;indicate accumulator empty&quot;));
        sqlite3VdbeAddOp1(v, OP_Return, regReset);
  
      } /* endif pGroupBy.  Begin aggregate queries without GROUP BY: */
      else {
<span class="udiff-line-removed">- #ifndef SQLITE_OMIT_BTREECOUNT</span>
        Table *pTab;
<span class="udiff-line-modified-removed">-       if( (pTab = isSimpleCount(p, &amp;sAggInfo))!=0 ){</span>
<span class="udiff-line-modified-added">+       if( (pTab = isSimpleCount(p, pAggInfo))!=0 ){</span>
          /* If isSimpleCount() returns a pointer to a Table structure, then
          ** the SQL statement is of the form:
          **
          **   SELECT count(*) FROM &lt;tbl&gt;
          **
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -134520,17 +135653,19 @@</span>
          **
          ** In practice the KeyInfo structure will not be used. It is only
          ** passed to keep OP_OpenRead happy.
          */
          if( !HasRowid(pTab) ) pBest = sqlite3PrimaryKeyIndex(pTab);
<span class="udiff-line-modified-removed">-         for(pIdx=pTab-&gt;pIndex; pIdx; pIdx=pIdx-&gt;pNext){</span>
<span class="udiff-line-modified-removed">-           if( pIdx-&gt;bUnordered==0</span>
<span class="udiff-line-modified-removed">-            &amp;&amp; pIdx-&gt;szIdxRow&lt;pTab-&gt;szTabRow</span>
<span class="udiff-line-modified-removed">-            &amp;&amp; pIdx-&gt;pPartIdxWhere==0</span>
<span class="udiff-line-modified-removed">-            &amp;&amp; (!pBest || pIdx-&gt;szIdxRow&lt;pBest-&gt;szIdxRow)</span>
<span class="udiff-line-modified-removed">-           ){</span>
<span class="udiff-line-modified-removed">-             pBest = pIdx;</span>
<span class="udiff-line-modified-added">+         if( !p-&gt;pSrc-&gt;a[0].fg.notIndexed ){</span>
<span class="udiff-line-modified-added">+           for(pIdx=pTab-&gt;pIndex; pIdx; pIdx=pIdx-&gt;pNext){</span>
<span class="udiff-line-modified-added">+             if( pIdx-&gt;bUnordered==0</span>
<span class="udiff-line-modified-added">+              &amp;&amp; pIdx-&gt;szIdxRow&lt;pTab-&gt;szTabRow</span>
<span class="udiff-line-modified-added">+              &amp;&amp; pIdx-&gt;pPartIdxWhere==0</span>
<span class="udiff-line-modified-added">+              &amp;&amp; (!pBest || pIdx-&gt;szIdxRow&lt;pBest-&gt;szIdxRow)</span>
<span class="udiff-line-modified-added">+             ){</span>
<span class="udiff-line-added">+               pBest = pIdx;</span>
<span class="udiff-line-added">+             }</span>
            }
          }
          if( pBest ){
            iRoot = pBest-&gt;tnum;
            pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pBest);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -134539,16 +135674,14 @@</span>
          /* Open a read-only cursor, execute the OP_Count, close the cursor. */
          sqlite3VdbeAddOp4Int(v, OP_OpenRead, iCsr, iRoot, iDb, 1);
          if( pKeyInfo ){
            sqlite3VdbeChangeP4(v, -1, (char *)pKeyInfo, P4_KEYINFO);
          }
<span class="udiff-line-modified-removed">-         sqlite3VdbeAddOp2(v, OP_Count, iCsr, sAggInfo.aFunc[0].iMem);</span>
<span class="udiff-line-modified-added">+         sqlite3VdbeAddOp2(v, OP_Count, iCsr, pAggInfo-&gt;aFunc[0].iMem);</span>
          sqlite3VdbeAddOp1(v, OP_Close, iCsr);
          explainSimpleCount(pParse, pTab, pBest);
<span class="udiff-line-modified-removed">-       }else</span>
<span class="udiff-line-removed">- #endif /* SQLITE_OMIT_BTREECOUNT */</span>
<span class="udiff-line-removed">-       {</span>
<span class="udiff-line-modified-added">+       }else{</span>
          int regAcc = 0;           /* &quot;populate accumulators&quot; flag */
  
          /* If there are accumulator registers but no min() or max() functions
          ** without FILTER clauses, allocate register regAcc. Register regAcc
          ** will contain 0 the first time the inner loop runs, and 1 thereafter.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -134556,27 +135689,31 @@</span>
          ** that the accumulator registers are (a) updated only once if
          ** there are no min() or max functions or (b) always updated for the
          ** first row visited by the aggregate, so that they are updated at
          ** least once even if the FILTER clause means the min() or max()
          ** function visits zero rows.  */
<span class="udiff-line-modified-removed">-         if( sAggInfo.nAccumulator ){</span>
<span class="udiff-line-modified-removed">-           for(i=0; i&lt;sAggInfo.nFunc; i++){</span>
<span class="udiff-line-modified-removed">-             if( ExprHasProperty(sAggInfo.aFunc[i].pExpr, EP_WinFunc) ) continue;</span>
<span class="udiff-line-modified-removed">-             if( sAggInfo.aFunc[i].pFunc-&gt;funcFlags&amp;SQLITE_FUNC_NEEDCOLL ) break;</span>
<span class="udiff-line-modified-added">+         if( pAggInfo-&gt;nAccumulator ){</span>
<span class="udiff-line-modified-added">+           for(i=0; i&lt;pAggInfo-&gt;nFunc; i++){</span>
<span class="udiff-line-modified-added">+             if( ExprHasProperty(pAggInfo-&gt;aFunc[i].pExpr, EP_WinFunc) ){</span>
<span class="udiff-line-modified-added">+               continue;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if( pAggInfo-&gt;aFunc[i].pFunc-&gt;funcFlags&amp;SQLITE_FUNC_NEEDCOLL ){</span>
<span class="udiff-line-added">+               break;</span>
<span class="udiff-line-added">+             }</span>
            }
<span class="udiff-line-modified-removed">-           if( i==sAggInfo.nFunc ){</span>
<span class="udiff-line-modified-added">+           if( i==pAggInfo-&gt;nFunc ){</span>
              regAcc = ++pParse-&gt;nMem;
              sqlite3VdbeAddOp2(v, OP_Integer, 0, regAcc);
            }
          }
  
          /* This case runs if the aggregate has no GROUP BY clause.  The
          ** processing is much simpler since there is only a single row
          ** of output.
          */
          assert( p-&gt;pGroupBy==0 );
<span class="udiff-line-modified-removed">-         resetAccumulator(pParse, &amp;sAggInfo);</span>
<span class="udiff-line-modified-added">+         resetAccumulator(pParse, pAggInfo);</span>
  
          /* If this query is a candidate for the min/max optimization, then
          ** minMaxFlag will have been previously set to either
          ** WHERE_ORDERBY_MIN or WHERE_ORDERBY_MAX and pMinMaxOrderBy will
          ** be an appropriate ORDER BY expression for the optimization.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -134588,19 +135725,19 @@</span>
          pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy,
                                     0, minMaxFlag, 0);
          if( pWInfo==0 ){
            goto select_end;
          }
<span class="udiff-line-modified-removed">-         updateAccumulator(pParse, regAcc, &amp;sAggInfo);</span>
<span class="udiff-line-modified-added">+         updateAccumulator(pParse, regAcc, pAggInfo);</span>
          if( regAcc ) sqlite3VdbeAddOp2(v, OP_Integer, 1, regAcc);
          if( sqlite3WhereIsOrdered(pWInfo)&gt;0 ){
            sqlite3VdbeGoto(v, sqlite3WhereBreakLabel(pWInfo));
            VdbeComment((v, &quot;%s() by index&quot;,
                  (minMaxFlag==WHERE_ORDERBY_MIN?&quot;min&quot;:&quot;max&quot;)));
          }
          sqlite3WhereEnd(pWInfo);
<span class="udiff-line-modified-removed">-         finalizeAggFunctions(pParse, &amp;sAggInfo);</span>
<span class="udiff-line-modified-added">+         finalizeAggFunctions(pParse, pAggInfo);</span>
        }
  
        sSort.pOrderBy = 0;
        sqlite3ExprIfFalse(pParse, pHaving, addrEnd, SQLITE_JUMPIFNULL);
        selectInnerLoop(pParse, p, -1, 0, 0,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -134635,12 +135772,29 @@</span>
    /* Control jumps to here if an error is encountered above, or upon
    ** successful coding of the SELECT.
    */
  select_end:
    sqlite3ExprListDelete(db, pMinMaxOrderBy);
<span class="udiff-line-modified-removed">-   sqlite3DbFree(db, sAggInfo.aCol);</span>
<span class="udiff-line-modified-removed">-   sqlite3DbFree(db, sAggInfo.aFunc);</span>
<span class="udiff-line-modified-added">+ #ifdef SQLITE_DEBUG</span>
<span class="udiff-line-modified-added">+   if( pAggInfo &amp;&amp; !db-&gt;mallocFailed ){</span>
<span class="udiff-line-added">+     for(i=0; i&lt;pAggInfo-&gt;nColumn; i++){</span>
<span class="udiff-line-added">+       Expr *pExpr = pAggInfo-&gt;aCol[i].pExpr;</span>
<span class="udiff-line-added">+       assert( pExpr!=0 || db-&gt;mallocFailed );</span>
<span class="udiff-line-added">+       if( pExpr==0 ) continue;</span>
<span class="udiff-line-added">+       assert( pExpr-&gt;pAggInfo==pAggInfo );</span>
<span class="udiff-line-added">+       assert( pExpr-&gt;iAgg==i );</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     for(i=0; i&lt;pAggInfo-&gt;nFunc; i++){</span>
<span class="udiff-line-added">+       Expr *pExpr = pAggInfo-&gt;aFunc[i].pExpr;</span>
<span class="udiff-line-added">+       assert( pExpr!=0 || db-&gt;mallocFailed );</span>
<span class="udiff-line-added">+       if( pExpr==0 ) continue;</span>
<span class="udiff-line-added">+       assert( pExpr-&gt;pAggInfo==pAggInfo );</span>
<span class="udiff-line-added">+       assert( pExpr-&gt;iAgg==i );</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  #if SELECTTRACE_ENABLED
    SELECTTRACE(0x1,pParse,p,(&quot;end processing\n&quot;));
    if( (sqlite3SelectTrace &amp; 0x2000)!=0 &amp;&amp; ExplainQueryPlanParent(pParse)==0 ){
      sqlite3TreeViewSelect(0, p, 0);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -134707,11 +135861,11 @@</span>
      need = nCol;
    }
    if( p-&gt;nData + need &gt; p-&gt;nAlloc ){
      char **azNew;
      p-&gt;nAlloc = p-&gt;nAlloc*2 + need;
<span class="udiff-line-modified-removed">-     azNew = sqlite3_realloc64( p-&gt;azResult, sizeof(char*)*p-&gt;nAlloc );</span>
<span class="udiff-line-modified-added">+     azNew = sqlite3Realloc( p-&gt;azResult, sizeof(char*)*p-&gt;nAlloc );</span>
      if( azNew==0 ) goto malloc_failed;
      p-&gt;azResult = azNew;
    }
  
    /* If this is the first row, then generate an extra row containing
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -134816,11 +135970,11 @@</span>
      sqlite3_free_table(&amp;res.azResult[1]);
      return rc;
    }
    if( res.nAlloc&gt;res.nData ){
      char **azNew;
<span class="udiff-line-modified-removed">-     azNew = sqlite3_realloc64( res.azResult, sizeof(char*)*res.nData );</span>
<span class="udiff-line-modified-added">+     azNew = sqlite3Realloc( res.azResult, sizeof(char*)*res.nData );</span>
      if( azNew==0 ){
        sqlite3_free_table(&amp;res.azResult[1]);
        db-&gt;errCode = SQLITE_NOMEM;
        return SQLITE_NOMEM_BKPT;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -135432,11 +136586,11 @@</span>
    zDb = pName-&gt;a[0].zDatabase;
    zName = pName-&gt;a[0].zName;
    assert( zDb!=0 || sqlite3BtreeHoldsAllMutexes(db) );
    for(i=OMIT_TEMPDB; i&lt;db-&gt;nDb; i++){
      int j = (i&lt;2) ? i^1 : i;  /* Search TEMP before MAIN */
<span class="udiff-line-modified-removed">-     if( zDb &amp;&amp; sqlite3StrICmp(db-&gt;aDb[j].zDbSName, zDb) ) continue;</span>
<span class="udiff-line-modified-added">+     if( zDb &amp;&amp; sqlite3DbIsNamed(db, j, zDb)==0 ) continue;</span>
      assert( sqlite3SchemaMutexHeld(db, j, 0) );
      pTrigger = sqlite3HashFind(&amp;(db-&gt;aDb[j].pSchema-&gt;trigHash), zName);
      if( pTrigger ) break;
    }
    if( !pTrigger ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -136106,14 +137260,14 @@</span>
  ** Therefore, the P4 parameter is only required if the default value for
  ** the column is a literal number, string or null. The sqlite3ValueFromExpr()
  ** function is capable of transforming these types of expressions into
  ** sqlite3_value objects.
  **
<span class="udiff-line-modified-removed">- ** If parameter iReg is not negative, code an OP_RealAffinity instruction</span>
<span class="udiff-line-modified-removed">- ** on register iReg. This is used when an equivalent integer value is</span>
<span class="udiff-line-modified-removed">- ** stored in place of an 8-byte floating point value in order to save</span>
<span class="udiff-line-modified-removed">- ** space.</span>
<span class="udiff-line-modified-added">+ ** If column as REAL affinity and the table is an ordinary b-tree table</span>
<span class="udiff-line-modified-added">+ ** (not a virtual table) then the value might have been stored as an</span>
<span class="udiff-line-modified-added">+ ** integer.  In that case, add an OP_RealAffinity opcode to make sure</span>
<span class="udiff-line-modified-added">+ ** it has been converted into REAL.</span>
  */
  SQLITE_PRIVATE void sqlite3ColumnDefault(Vdbe *v, Table *pTab, int i, int iReg){
    assert( pTab!=0 );
    if( !pTab-&gt;pSelect ){
      sqlite3_value *pValue = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -136126,11 +137280,11 @@</span>
      if( pValue ){
        sqlite3VdbeAppendP4(v, pValue, P4_MEM);
      }
    }
  #ifndef SQLITE_OMIT_FLOATING_POINT
<span class="udiff-line-modified-removed">-   if( pTab-&gt;aCol[i].affinity==SQLITE_AFF_REAL ){</span>
<span class="udiff-line-modified-added">+   if( pTab-&gt;aCol[i].affinity==SQLITE_AFF_REAL &amp;&amp; !IsVirtual(pTab) ){</span>
      sqlite3VdbeAddOp1(v, OP_RealAffinity, iReg);
    }
  #endif
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -136669,11 +137823,13 @@</span>
        if( eOnePass==ONEPASS_MULTI &amp;&amp; (nIdx-(aiCurOnePass[1]&gt;=0))&gt;0 ){
          addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);
        }
        sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenWrite, 0, iBaseCur,
                                   aToOpen, 0, 0);
<span class="udiff-line-modified-removed">-       if( addrOnce ) sqlite3VdbeJumpHere(v, addrOnce);</span>
<span class="udiff-line-modified-added">+       if( addrOnce ){</span>
<span class="udiff-line-added">+         sqlite3VdbeJumpHereOrPopInst(v, addrOnce);</span>
<span class="udiff-line-added">+       }</span>
      }
  
      /* Top of the update loop */
      if( eOnePass!=ONEPASS_OFF ){
        if( !isView &amp;&amp; aiCurOnePass[0]!=iDataCur &amp;&amp; aiCurOnePass[1]!=iDataCur ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -137622,22 +138778,11 @@</span>
        sqlite3SetString(pzErrMsg, db, &quot;output file already exists&quot;);
        goto end_of_vacuum;
      }
      db-&gt;mDbFlags |= DBFLAG_VacuumInto;
    }
<span class="udiff-line-modified-removed">-   nRes = sqlite3BtreeGetOptimalReserve(pMain);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   /* A VACUUM cannot change the pagesize of an encrypted database. */</span>
<span class="udiff-line-removed">- #ifdef SQLITE_HAS_CODEC</span>
<span class="udiff-line-removed">-   if( db-&gt;nextPagesize ){</span>
<span class="udiff-line-removed">-     extern void sqlite3CodecGetKey(sqlite3*, int, void**, int*);</span>
<span class="udiff-line-removed">-     int nKey;</span>
<span class="udiff-line-removed">-     char *zKey;</span>
<span class="udiff-line-removed">-     sqlite3CodecGetKey(db, iDb, (void**)&amp;zKey, &amp;nKey);</span>
<span class="udiff-line-removed">-     if( nKey ) db-&gt;nextPagesize = 0;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+   nRes = sqlite3BtreeGetRequestedReserve(pMain);</span>
  
    sqlite3BtreeSetCacheSize(pTemp, db-&gt;aDb[iDb].pSchema-&gt;cache_size);
    sqlite3BtreeSetSpillSize(pTemp, sqlite3BtreeSetSpillSize(pMain,0));
    sqlite3BtreeSetPagerFlags(pTemp, PAGER_SYNCHRONOUS_OFF|PAGER_CACHESPILL);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -137777,11 +138922,11 @@</span>
    db-&gt;mDbFlags = saved_mDbFlags;
    db-&gt;flags = saved_flags;
    db-&gt;nChange = saved_nChange;
    db-&gt;nTotalChange = saved_nTotalChange;
    db-&gt;mTrace = saved_mTrace;
<span class="udiff-line-modified-removed">-   sqlite3BtreeSetPageSize(pMain, -1, -1, 1);</span>
<span class="udiff-line-modified-added">+   sqlite3BtreeSetPageSize(pMain, -1, 0, 1);</span>
  
    /* Currently there is an SQL level transaction open on the vacuum
    ** database. No locks are held on any other files (since the main file
    ** was committed at the btree level). So it safe to end the transaction
    ** by manually setting the autoCommit flag to true and detaching the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -138984,11 +140129,11 @@</span>
    assert( IsVirtual(pTab) );
    for(i=0; i&lt;pToplevel-&gt;nVtabLock; i++){
      if( pTab==pToplevel-&gt;apVtabLock[i] ) return;
    }
    n = (pToplevel-&gt;nVtabLock+1)*sizeof(pToplevel-&gt;apVtabLock[0]);
<span class="udiff-line-modified-removed">-   apVtabLock = sqlite3_realloc64(pToplevel-&gt;apVtabLock, n);</span>
<span class="udiff-line-modified-added">+   apVtabLock = sqlite3Realloc(pToplevel-&gt;apVtabLock, n);</span>
    if( apVtabLock ){
      pToplevel-&gt;apVtabLock = apVtabLock;
      pToplevel-&gt;apVtabLock[pToplevel-&gt;nVtabLock++] = pTab;
    }else{
      sqlite3OomFault(pToplevel-&gt;db);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -139441,10 +140586,16 @@</span>
  #define TERM_LIKEOPT    0x0100 /* Virtual terms from the LIKE optimization */
  #define TERM_LIKECOND   0x0200 /* Conditionally this LIKE operator term */
  #define TERM_LIKE       0x0400 /* The original LIKE operator */
  #define TERM_IS         0x0800 /* Term.pExpr is an IS operator */
  #define TERM_VARSELECT  0x1000 /* Term.pExpr contains a correlated sub-query */
<span class="udiff-line-added">+ #define TERM_HEURTRUTH  0x2000 /* Heuristic truthProb used */</span>
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_STAT4</span>
<span class="udiff-line-added">+ #  define TERM_HIGHTRUTH  0x4000 /* Term excludes few rows */</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+ #  define TERM_HIGHTRUTH  0      /* Only used with STAT4 */</span>
<span class="udiff-line-added">+ #endif</span>
  
  /*
  ** An instance of the WhereScan object is used as an iterator for locating
  ** terms in the WHERE clause that are useful to the query planner.
  */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -139555,17 +140706,20 @@</span>
    WhereOrSet *pOrSet;       /* Record best loops here, if not NULL */
  #ifdef SQLITE_ENABLE_STAT4
    UnpackedRecord *pRec;     /* Probe for stat4 (if required) */
    int nRecValid;            /* Number of valid fields currently in pRec */
  #endif
<span class="udiff-line-modified-removed">-   unsigned int bldFlags;    /* SQLITE_BLDF_* flags */</span>
<span class="udiff-line-modified-added">+   unsigned char bldFlags1;  /* First set of SQLITE_BLDF_* flags */</span>
<span class="udiff-line-added">+   unsigned char bldFlags2;  /* Second set of SQLITE_BLDF_* flags */</span>
    unsigned int iPlanLimit;  /* Search limiter */
  };
  
  /* Allowed values for WhereLoopBuider.bldFlags */
<span class="udiff-line-modified-removed">- #define SQLITE_BLDF_INDEXED  0x0001   /* An index is used */</span>
<span class="udiff-line-modified-removed">- #define SQLITE_BLDF_UNIQUE   0x0002   /* All keys of a UNIQUE index used */</span>
<span class="udiff-line-modified-added">+ #define SQLITE_BLDF1_INDEXED  0x0001   /* An index is used */</span>
<span class="udiff-line-modified-added">+ #define SQLITE_BLDF1_UNIQUE   0x0002   /* All keys of a UNIQUE index used */</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define SQLITE_BLDF2_2NDPASS  0x0004   /* Second builder pass needed */</span>
  
  /* The WhereLoopBuilder.iPlanLimit is used to limit the number of
  ** index+constraint combinations the query planner will consider for a
  ** particular query.  If this parameter is unlimited, then certain
  ** pathological queries can spend excess time in the sqlite3WhereBegin()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -141175,11 +142329,13 @@</span>
          if( pCompare ){
            pCompare-&gt;pLeft = pTerm-&gt;pExpr-&gt;pLeft;
            pCompare-&gt;pRight = pRight = sqlite3Expr(db, TK_REGISTER, 0);
            if( pRight ){
              pRight-&gt;iTable = iReg+j+2;
<span class="udiff-line-modified-removed">-             sqlite3ExprIfFalse(pParse, pCompare, pLevel-&gt;addrCont, 0);</span>
<span class="udiff-line-modified-added">+             sqlite3ExprIfFalse(</span>
<span class="udiff-line-added">+                 pParse, pCompare, pLevel-&gt;addrCont, SQLITE_JUMPIFNULL</span>
<span class="udiff-line-added">+             );</span>
            }
            pCompare-&gt;pLeft = 0;
            sqlite3ExprDelete(db, pCompare);
          }
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -141452,10 +142608,13 @@</span>
        assert( pRangeEnd==0 &amp;&amp; pRangeStart==0 );
        testcase( pLoop-&gt;nSkip&gt;0 );
        nExtraReg = 1;
        bSeekPastNull = 1;
        pLevel-&gt;regBignull = regBignull = ++pParse-&gt;nMem;
<span class="udiff-line-added">+       if( pLevel-&gt;iLeftJoin ){</span>
<span class="udiff-line-added">+         sqlite3VdbeAddOp2(v, OP_Integer, 0, regBignull);</span>
<span class="udiff-line-added">+       }</span>
        pLevel-&gt;addrBignull = sqlite3VdbeMakeLabel(pParse);
      }
  
      /* If we are doing a reverse order scan on an ascending index, or
      ** a forward order scan on a descending index, interchange the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -142589,11 +143748,12 @@</span>
      **
      **       vtab_column MATCH expression
      **       MATCH(expression,vtab_column)
      */
      pCol = pList-&gt;a[1].pExpr;
<span class="udiff-line-modified-removed">-     if( pCol-&gt;op==TK_COLUMN &amp;&amp; IsVirtual(pCol-&gt;y.pTab) ){</span>
<span class="udiff-line-modified-added">+     testcase( pCol-&gt;op==TK_COLUMN &amp;&amp; pCol-&gt;y.pTab==0 );</span>
<span class="udiff-line-added">+     if( ExprIsVtab(pCol) ){</span>
        for(i=0; i&lt;ArraySize(aOp); i++){
          if( sqlite3StrICmp(pExpr-&gt;u.zToken, aOp[i].zOp)==0 ){
            *peOp2 = aOp[i].eOp2;
            *ppRight = pList-&gt;a[0].pExpr;
            *ppLeft = pCol;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -142611,11 +143771,12 @@</span>
      ** Historically, xFindFunction expected to see lower-case function
      ** names.  But for this use case, xFindFunction is expected to deal
      ** with function names in an arbitrary case.
      */
      pCol = pList-&gt;a[0].pExpr;
<span class="udiff-line-modified-removed">-     if( pCol-&gt;op==TK_COLUMN &amp;&amp; IsVirtual(pCol-&gt;y.pTab) ){</span>
<span class="udiff-line-modified-added">+     testcase( pCol-&gt;op==TK_COLUMN &amp;&amp; pCol-&gt;y.pTab==0 );</span>
<span class="udiff-line-added">+     if( ExprIsVtab(pCol) ){</span>
        sqlite3_vtab *pVtab;
        sqlite3_module *pMod;
        void (*xNotUsed)(sqlite3_context*,int,sqlite3_value**);
        void *pNotUsed;
        pVtab = sqlite3GetVTable(db, pCol-&gt;y.pTab)-&gt;pVtab;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -142634,14 +143795,16 @@</span>
      }
    }else if( pExpr-&gt;op==TK_NE || pExpr-&gt;op==TK_ISNOT || pExpr-&gt;op==TK_NOTNULL ){
      int res = 0;
      Expr *pLeft = pExpr-&gt;pLeft;
      Expr *pRight = pExpr-&gt;pRight;
<span class="udiff-line-modified-removed">-     if( pLeft-&gt;op==TK_COLUMN &amp;&amp; IsVirtual(pLeft-&gt;y.pTab) ){</span>
<span class="udiff-line-modified-added">+     testcase( pLeft-&gt;op==TK_COLUMN &amp;&amp; pLeft-&gt;y.pTab==0 );</span>
<span class="udiff-line-added">+     if( ExprIsVtab(pLeft) ){</span>
        res++;
      }
<span class="udiff-line-modified-removed">-     if( pRight &amp;&amp; pRight-&gt;op==TK_COLUMN &amp;&amp; IsVirtual(pRight-&gt;y.pTab) ){</span>
<span class="udiff-line-modified-added">+     testcase( pRight &amp;&amp; pRight-&gt;op==TK_COLUMN &amp;&amp; pRight-&gt;y.pTab==0 );</span>
<span class="udiff-line-added">+     if( pRight &amp;&amp; ExprIsVtab(pRight) ){</span>
        res++;
        SWAP(Expr*, pLeft, pRight);
      }
      *ppLeft = pLeft;
      *ppRight = pRight;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -146121,20 +147284,25 @@</span>
          pLoop-&gt;nOut += pTerm-&gt;truthProb;
        }else{
          /* In the absence of explicit truth probabilities, use heuristics to
          ** guess a reasonable truth probability. */
          pLoop-&gt;nOut--;
<span class="udiff-line-modified-removed">-         if( pTerm-&gt;eOperator&amp;(WO_EQ|WO_IS) ){</span>
<span class="udiff-line-modified-added">+         if( (pTerm-&gt;eOperator&amp;(WO_EQ|WO_IS))!=0</span>
<span class="udiff-line-added">+          &amp;&amp; (pTerm-&gt;wtFlags &amp; TERM_HIGHTRUTH)==0  /* tag-20200224-1 */</span>
<span class="udiff-line-added">+         ){</span>
            Expr *pRight = pTerm-&gt;pExpr-&gt;pRight;
            int k = 0;
            testcase( pTerm-&gt;pExpr-&gt;op==TK_IS );
            if( sqlite3ExprIsInteger(pRight, &amp;k) &amp;&amp; k&gt;=(-1) &amp;&amp; k&lt;=1 ){
              k = 10;
            }else{
              k = 20;
            }
<span class="udiff-line-modified-removed">-           if( iReduce&lt;k ) iReduce = k;</span>
<span class="udiff-line-modified-added">+           if( iReduce&lt;k ){</span>
<span class="udiff-line-added">+             pTerm-&gt;wtFlags |= TERM_HEURTRUTH;</span>
<span class="udiff-line-added">+             iReduce = k;</span>
<span class="udiff-line-added">+           }</span>
          }
        }
      }
    }
    if( pLoop-&gt;nOut &gt; nRow-iReduce )  pLoop-&gt;nOut = nRow - iReduce;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -146312,13 +147480,13 @@</span>
      ){
        continue;
      }
  
      if( IsUniqueIndex(pProbe) &amp;&amp; saved_nEq==pProbe-&gt;nKeyCol-1 ){
<span class="udiff-line-modified-removed">-       pBuilder-&gt;bldFlags |= SQLITE_BLDF_UNIQUE;</span>
<span class="udiff-line-modified-added">+       pBuilder-&gt;bldFlags1 |= SQLITE_BLDF1_UNIQUE;</span>
      }else{
<span class="udiff-line-modified-removed">-       pBuilder-&gt;bldFlags |= SQLITE_BLDF_INDEXED;</span>
<span class="udiff-line-modified-added">+       pBuilder-&gt;bldFlags1 |= SQLITE_BLDF1_INDEXED;</span>
      }
      pNew-&gt;wsFlags = saved_wsFlags;
      pNew-&gt;u.btree.nEq = saved_nEq;
      pNew-&gt;u.btree.nBtm = saved_nBtm;
      pNew-&gt;u.btree.nTop = saved_nTop;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -146479,10 +147647,31 @@</span>
            }
            if( rc==SQLITE_NOTFOUND ) rc = SQLITE_OK;
            if( rc!=SQLITE_OK ) break;          /* Jump out of the pTerm loop */
            if( nOut ){
              pNew-&gt;nOut = sqlite3LogEst(nOut);
<span class="udiff-line-added">+             if( nEq==1</span>
<span class="udiff-line-added">+              /* TUNING: Mark terms as &quot;low selectivity&quot; if they seem likely</span>
<span class="udiff-line-added">+              ** to be true for half or more of the rows in the table.</span>
<span class="udiff-line-added">+              ** See tag-202002240-1 */</span>
<span class="udiff-line-added">+              &amp;&amp; pNew-&gt;nOut+10 &gt; pProbe-&gt;aiRowLogEst[0]</span>
<span class="udiff-line-added">+             ){</span>
<span class="udiff-line-added">+ #if WHERETRACE_ENABLED /* 0x01 */</span>
<span class="udiff-line-added">+               if( sqlite3WhereTrace &amp; 0x01 ){</span>
<span class="udiff-line-added">+                 sqlite3DebugPrintf(</span>
<span class="udiff-line-added">+                    &quot;STAT4 determines term has low selectivity:\n&quot;);</span>
<span class="udiff-line-added">+                 sqlite3WhereTermPrint(pTerm, 999);</span>
<span class="udiff-line-added">+               }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+               pTerm-&gt;wtFlags |= TERM_HIGHTRUTH;</span>
<span class="udiff-line-added">+               if( pTerm-&gt;wtFlags &amp; TERM_HEURTRUTH ){</span>
<span class="udiff-line-added">+                 /* If the term has previously been used with an assumption of</span>
<span class="udiff-line-added">+                 ** higher selectivity, then set the flag to rerun the</span>
<span class="udiff-line-added">+                 ** loop computations. */</span>
<span class="udiff-line-added">+                 pBuilder-&gt;bldFlags2 |= SQLITE_BLDF2_2NDPASS;</span>
<span class="udiff-line-added">+               }</span>
<span class="udiff-line-added">+             }</span>
              if( pNew-&gt;nOut&gt;saved_nOut ) pNew-&gt;nOut = saved_nOut;
              pNew-&gt;nOut -= nIn;
            }
          }
          if( nOut==0 )
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -146555,10 +147744,11 @@</span>
    assert( 42==sqlite3LogEst(18) );
    if( saved_nEq==saved_nSkip
     &amp;&amp; saved_nEq+1&lt;pProbe-&gt;nKeyCol
     &amp;&amp; saved_nEq==pNew-&gt;nLTerm
     &amp;&amp; pProbe-&gt;noSkipScan==0
<span class="udiff-line-added">+    &amp;&amp; pProbe-&gt;hasStat1!=0</span>
     &amp;&amp; OptimizationEnabled(db, SQLITE_SkipScan)
     &amp;&amp; pProbe-&gt;aiRowLogEst[saved_nEq+1]&gt;=42  /* TUNING: Minimum for skip-scan */
     &amp;&amp; (rc = whereLoopResize(db, pNew, pNew-&gt;nLTerm+1))==SQLITE_OK
    ){
      LogEst nIter;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -146902,13 +148092,13 @@</span>
          pNew-&gt;nOut = rSize;
          if( rc ) break;
        }
      }
  
<span class="udiff-line-modified-removed">-     pBuilder-&gt;bldFlags = 0;</span>
<span class="udiff-line-modified-added">+     pBuilder-&gt;bldFlags1 = 0;</span>
      rc = whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, 0);
<span class="udiff-line-modified-removed">-     if( pBuilder-&gt;bldFlags==SQLITE_BLDF_INDEXED ){</span>
<span class="udiff-line-modified-added">+     if( pBuilder-&gt;bldFlags1==SQLITE_BLDF1_INDEXED ){</span>
        /* If a non-unique index is used, or if a prefix of the key for
        ** unique index is used (making the index functionally non-unique)
        ** then the sqlite_stat1 data becomes important for scoring the
        ** plan */
        pTab-&gt;tabFlags |= TF_StatsUsed;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -147575,12 +148765,15 @@</span>
          assert( wctrlFlags &amp; WHERE_ORDERBY_LIMIT );
          for(j=0; j&lt;pLoop-&gt;nLTerm &amp;&amp; pTerm!=pLoop-&gt;aLTerm[j]; j++){}
          if( j&gt;=pLoop-&gt;nLTerm ) continue;
        }
        if( (pTerm-&gt;eOperator&amp;(WO_EQ|WO_IS))!=0 &amp;&amp; pOBExpr-&gt;iColumn&gt;=0 ){
<span class="udiff-line-modified-removed">-         if( sqlite3ExprCollSeqMatch(pWInfo-&gt;pParse,</span>
<span class="udiff-line-modified-removed">-                   pOrderBy-&gt;a[i].pExpr, pTerm-&gt;pExpr)==0 ){</span>
<span class="udiff-line-modified-added">+         Parse *pParse = pWInfo-&gt;pParse;</span>
<span class="udiff-line-modified-added">+         CollSeq *pColl1 = sqlite3ExprNNCollSeq(pParse, pOrderBy-&gt;a[i].pExpr);</span>
<span class="udiff-line-added">+         CollSeq *pColl2 = sqlite3ExprCompareCollSeq(pParse, pTerm-&gt;pExpr);</span>
<span class="udiff-line-added">+         assert( pColl1 );</span>
<span class="udiff-line-added">+         if( pColl2==0 || sqlite3StrICmp(pColl1-&gt;zName, pColl2-&gt;zName) ){</span>
            continue;
          }
          testcase( pTerm-&gt;pExpr-&gt;op==TK_IS );
        }
        obSat |= MASKBIT(i);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -148356,10 +149549,32 @@</span>
    w.xSelectCallback = sqlite3SelectWalkFail;
    sqlite3WalkExpr(&amp;w, p);
    return w.eCode;
  }
  
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef WHERETRACE_ENABLED</span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Display all WhereLoops in pWInfo</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static void showAllWhereLoops(WhereInfo *pWInfo, WhereClause *pWC){</span>
<span class="udiff-line-added">+   if( sqlite3WhereTrace ){    /* Display all of the WhereLoop objects */</span>
<span class="udiff-line-added">+     WhereLoop *p;</span>
<span class="udiff-line-added">+     int i;</span>
<span class="udiff-line-added">+     static const char zLabel[] = &quot;0123456789abcdefghijklmnopqrstuvwyxz&quot;</span>
<span class="udiff-line-added">+                                            &quot;ABCDEFGHIJKLMNOPQRSTUVWYXZ&quot;;</span>
<span class="udiff-line-added">+     for(p=pWInfo-&gt;pLoops, i=0; p; p=p-&gt;pNextLoop, i++){</span>
<span class="udiff-line-added">+       p-&gt;cId = zLabel[i%(sizeof(zLabel)-1)];</span>
<span class="udiff-line-added">+       sqlite3WhereLoopPrint(p, pWC);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ # define WHERETRACE_ALL_LOOPS(W,C) showAllWhereLoops(W,C)</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+ # define WHERETRACE_ALL_LOOPS(W,C)</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  /*
  ** Generate the beginning of the loop used for WHERE clause processing.
  ** The return value is a pointer to an opaque structure that contains
  ** information needed to terminate the loop.  Later, the calling routine
  ** should invoke sqlite3WhereEnd() with the return value of this function
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -148658,22 +149873,31 @@</span>
  
    if( nTabList!=1 || whereShortCut(&amp;sWLB)==0 ){
      rc = whereLoopAddAll(&amp;sWLB);
      if( rc ) goto whereBeginError;
  
<span class="udiff-line-modified-removed">- #ifdef WHERETRACE_ENABLED</span>
<span class="udiff-line-modified-removed">-     if( sqlite3WhereTrace ){    /* Display all of the WhereLoop objects */</span>
<span class="udiff-line-modified-removed">-       WhereLoop *p;</span>
<span class="udiff-line-modified-removed">-       int i;</span>
<span class="udiff-line-modified-removed">-       static const char zLabel[] = &quot;0123456789abcdefghijklmnopqrstuvwyxz&quot;</span>
<span class="udiff-line-modified-removed">-                                              &quot;ABCDEFGHIJKLMNOPQRSTUVWYXZ&quot;;</span>
<span class="udiff-line-modified-removed">-       for(p=pWInfo-&gt;pLoops, i=0; p; p=p-&gt;pNextLoop, i++){</span>
<span class="udiff-line-modified-removed">-         p-&gt;cId = zLabel[i%(sizeof(zLabel)-1)];</span>
<span class="udiff-line-modified-removed">-         sqlite3WhereLoopPrint(p, sWLB.pWC);</span>
<span class="udiff-line-modified-removed">-       }</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-added">+ #ifdef SQLITE_ENABLE_STAT4</span>
<span class="udiff-line-modified-added">+     /* If one or more WhereTerm.truthProb values were used in estimating</span>
<span class="udiff-line-modified-added">+     ** loop parameters, but then those truthProb values were subsequently</span>
<span class="udiff-line-modified-added">+     ** changed based on STAT4 information while computing subsequent loops,</span>
<span class="udiff-line-modified-added">+     ** then we need to rerun the whole loop building process so that all</span>
<span class="udiff-line-modified-added">+     ** loops will be built using the revised truthProb values. */</span>
<span class="udiff-line-modified-added">+     if( sWLB.bldFlags2 &amp; SQLITE_BLDF2_2NDPASS ){</span>
<span class="udiff-line-modified-added">+       WHERETRACE_ALL_LOOPS(pWInfo, sWLB.pWC);</span>
<span class="udiff-line-modified-added">+       WHERETRACE(0xffff,</span>
<span class="udiff-line-modified-added">+            (&quot;**** Redo all loop computations due to&quot;</span>
<span class="udiff-line-modified-added">+             &quot; TERM_HIGHTRUTH changes ****\n&quot;));</span>
<span class="udiff-line-modified-added">+       while( pWInfo-&gt;pLoops ){</span>
<span class="udiff-line-added">+         WhereLoop *p = pWInfo-&gt;pLoops;</span>
<span class="udiff-line-added">+         pWInfo-&gt;pLoops = p-&gt;pNextLoop;</span>
<span class="udiff-line-added">+         whereLoopDelete(db, p);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       rc = whereLoopAddAll(&amp;sWLB);</span>
<span class="udiff-line-added">+       if( rc ) goto whereBeginError;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     WHERETRACE_ALL_LOOPS(pWInfo, sWLB.pWC);</span>
  
      wherePathSolver(pWInfo, 0);
      if( db-&gt;mallocFailed ) goto whereBeginError;
      if( pWInfo-&gt;pOrderBy ){
         wherePathSolver(pWInfo, pWInfo-&gt;nRowOut+1);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -148940,11 +150164,11 @@</span>
           &amp;&amp; (pLoop-&gt;wsFlags &amp; (WHERE_COLUMN_RANGE|WHERE_SKIPSCAN))==0
           &amp;&amp; (pLoop-&gt;wsFlags &amp; WHERE_BIGNULL_SORT)==0
           &amp;&amp; (pWInfo-&gt;wctrlFlags&amp;WHERE_ORDERBY_MIN)==0
           &amp;&amp; pWInfo-&gt;eDistinct!=WHERE_DISTINCT_ORDERED
          ){
<span class="udiff-line-modified-removed">-           sqlite3VdbeChangeP5(v, OPFLAG_SEEKEQ); /* Hint to COMDB2 */</span>
<span class="udiff-line-modified-added">+           sqlite3VdbeChangeP5(v, OPFLAG_SEEKEQ);</span>
          }
          VdbeComment((v, &quot;%s&quot;, pIx-&gt;zName));
  #ifdef SQLITE_ENABLE_COLUMN_USED_MASK
          {
            u64 colUsed = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -149098,30 +150322,31 @@</span>
        for(j=pLevel-&gt;u.in.nIn, pIn=&amp;pLevel-&gt;u.in.aInLoop[j-1]; j&gt;0; j--, pIn--){
          sqlite3VdbeJumpHere(v, pIn-&gt;addrInTop+1);
          if( pIn-&gt;eEndLoopOp!=OP_Noop ){
            if( pIn-&gt;nPrefix ){
              assert( pLoop-&gt;wsFlags &amp; WHERE_IN_EARLYOUT );
<span class="udiff-line-removed">-             if( (pLoop-&gt;wsFlags &amp; WHERE_VIRTUALTABLE)==0 ){</span>
<span class="udiff-line-removed">-               sqlite3VdbeAddOp4Int(v, OP_IfNoHope, pLevel-&gt;iIdxCur,</span>
<span class="udiff-line-removed">-                   sqlite3VdbeCurrentAddr(v)+2+(pLevel-&gt;iLeftJoin!=0),</span>
<span class="udiff-line-removed">-                   pIn-&gt;iBase, pIn-&gt;nPrefix);</span>
<span class="udiff-line-removed">-               VdbeCoverage(v);</span>
<span class="udiff-line-removed">-             }</span>
              if( pLevel-&gt;iLeftJoin ){
                /* For LEFT JOIN queries, cursor pIn-&gt;iCur may not have been
                ** opened yet. This occurs for WHERE clauses such as
                ** &quot;a = ? AND b IN (...)&quot;, where the index is on (a, b). If
                ** the RHS of the (a=?) is NULL, then the &quot;b IN (...)&quot; may
                ** never have been coded, but the body of the loop run to
                ** return the null-row. So, if the cursor is not open yet,
                ** jump over the OP_Next or OP_Prev instruction about to
                ** be coded.  */
                sqlite3VdbeAddOp2(v, OP_IfNotOpen, pIn-&gt;iCur,
<span class="udiff-line-modified-removed">-                   sqlite3VdbeCurrentAddr(v) + 2</span>
<span class="udiff-line-modified-added">+                   sqlite3VdbeCurrentAddr(v) + 2 +</span>
<span class="udiff-line-added">+                      ((pLoop-&gt;wsFlags &amp; WHERE_VIRTUALTABLE)==0)</span>
                );
                VdbeCoverage(v);
              }
<span class="udiff-line-added">+             if( (pLoop-&gt;wsFlags &amp; WHERE_VIRTUALTABLE)==0 ){</span>
<span class="udiff-line-added">+               sqlite3VdbeAddOp4Int(v, OP_IfNoHope, pLevel-&gt;iIdxCur,</span>
<span class="udiff-line-added">+                   sqlite3VdbeCurrentAddr(v)+2,</span>
<span class="udiff-line-added">+                   pIn-&gt;iBase, pIn-&gt;nPrefix);</span>
<span class="udiff-line-added">+               VdbeCoverage(v);</span>
<span class="udiff-line-added">+             }</span>
            }
            sqlite3VdbeAddOp2(v, pIn-&gt;eEndLoopOp, pIn-&gt;iCur, pIn-&gt;addrInTop);
            VdbeCoverage(v);
            VdbeCoverageIf(v, pIn-&gt;eEndLoopOp==OP_Prev);
            VdbeCoverageIf(v, pIn-&gt;eEndLoopOp==OP_Next);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -150196,25 +151421,48 @@</span>
  ){
    if( pAppend ){
      int i;
      int nInit = pList ? pList-&gt;nExpr : 0;
      for(i=0; i&lt;pAppend-&gt;nExpr; i++){
<span class="udiff-line-removed">-       int iDummy;</span>
        Expr *pDup = sqlite3ExprDup(pParse-&gt;db, pAppend-&gt;a[i].pExpr, 0);
        assert( pDup==0 || !ExprHasProperty(pDup, EP_MemToken) );
<span class="udiff-line-modified-removed">-       if( bIntToNull &amp;&amp; pDup &amp;&amp; sqlite3ExprIsInteger(pDup, &amp;iDummy) ){</span>
<span class="udiff-line-modified-removed">-         pDup-&gt;op = TK_NULL;</span>
<span class="udiff-line-modified-removed">-         pDup-&gt;flags &amp;= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);</span>
<span class="udiff-line-modified-removed">-         pDup-&gt;u.zToken = 0;</span>
<span class="udiff-line-modified-added">+       if( bIntToNull &amp;&amp; pDup ){</span>
<span class="udiff-line-modified-added">+         int iDummy;</span>
<span class="udiff-line-modified-added">+         Expr *pSub;</span>
<span class="udiff-line-modified-added">+         for(pSub=pDup; ExprHasProperty(pSub, EP_Skip); pSub=pSub-&gt;pLeft){</span>
<span class="udiff-line-added">+           assert( pSub );</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if( sqlite3ExprIsInteger(pSub, &amp;iDummy) ){</span>
<span class="udiff-line-added">+           pSub-&gt;op = TK_NULL;</span>
<span class="udiff-line-added">+           pSub-&gt;flags &amp;= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);</span>
<span class="udiff-line-added">+           pSub-&gt;u.zToken = 0;</span>
<span class="udiff-line-added">+         }</span>
        }
        pList = sqlite3ExprListAppend(pParse, pList, pDup);
        if( pList ) pList-&gt;a[nInit+i].sortFlags = pAppend-&gt;a[i].sortFlags;
      }
    }
    return pList;
  }
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** When rewriting a query, if the new subquery in the FROM clause</span>
<span class="udiff-line-added">+ ** contains TK_AGG_FUNCTION nodes that refer to an outer query,</span>
<span class="udiff-line-added">+ ** then we have to increase the Expr-&gt;op2 values of those nodes</span>
<span class="udiff-line-added">+ ** due to the extra subquery layer that was added.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** See also the incrAggDepth() routine in resolve.c</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static int sqlite3WindowExtraAggFuncDepth(Walker *pWalker, Expr *pExpr){</span>
<span class="udiff-line-added">+   if( pExpr-&gt;op==TK_AGG_FUNCTION</span>
<span class="udiff-line-added">+    &amp;&amp; pExpr-&gt;op2&gt;=pWalker-&gt;walkerDepth</span>
<span class="udiff-line-added">+   ){</span>
<span class="udiff-line-added">+     pExpr-&gt;op2++;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return WRC_Continue;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /*
  ** If the SELECT statement passed as the second argument does not invoke
  ** any SQL window functions, this function is a no-op. Otherwise, it
  ** rewrites the SELECT statement so that window function xStep functions
  ** are invoked in the correct order as described under &quot;SELECT REWRITING&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -150234,15 +151482,20 @@</span>
  
      ExprList *pSublist = 0;       /* Expression list for sub-query */
      Window *pMWin = p-&gt;pWin;      /* Master window object */
      Window *pWin;                 /* Window object iterator */
      Table *pTab;
<span class="udiff-line-added">+     Walker w;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     u32 selFlags = p-&gt;selFlags;</span>
  
      pTab = sqlite3DbMallocZero(db, sizeof(Table));
      if( pTab==0 ){
        return sqlite3ErrorToParser(db, SQLITE_NOMEM);
      }
<span class="udiff-line-added">+     sqlite3AggInfoPersistWalkerInit(&amp;w, pParse);</span>
<span class="udiff-line-added">+     sqlite3WalkSelect(&amp;w, p);</span>
  
      p-&gt;pSrc = 0;
      p-&gt;pWhere = 0;
      p-&gt;pGroupBy = 0;
      p-&gt;pHaving = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -150323,20 +151576,26 @@</span>
        Table *pTab2;
        p-&gt;pSrc-&gt;a[0].pSelect = pSub;
        sqlite3SrcListAssignCursors(pParse, p-&gt;pSrc);
        pSub-&gt;selFlags |= SF_Expanded;
        pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, SQLITE_AFF_NONE);
<span class="udiff-line-added">+       pSub-&gt;selFlags |= (selFlags &amp; SF_Aggregate);</span>
        if( pTab2==0 ){
          /* Might actually be some other kind of error, but in that case
          ** pParse-&gt;nErr will be set, so if SQLITE_NOMEM is set, we will get
          ** the correct error message regardless. */
          rc = SQLITE_NOMEM;
        }else{
          memcpy(pTab, pTab2, sizeof(Table));
          pTab-&gt;tabFlags |= TF_Ephemeral;
          p-&gt;pSrc-&gt;a[0].pTab = pTab;
          pTab = pTab2;
<span class="udiff-line-added">+         memset(&amp;w, 0, sizeof(w));</span>
<span class="udiff-line-added">+         w.xExprCallback = sqlite3WindowExtraAggFuncDepth;</span>
<span class="udiff-line-added">+         w.xSelectCallback = sqlite3WalkerDepthIncrease;</span>
<span class="udiff-line-added">+         w.xSelectCallback2 = sqlite3WalkerDepthDecrease;</span>
<span class="udiff-line-added">+         sqlite3WalkSelect(&amp;w, pSub);</span>
        }
      }else{
        sqlite3SelectDelete(db, pSub);
      }
      if( db-&gt;mallocFailed ) rc = SQLITE_NOMEM;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -151211,10 +152470,11 @@</span>
    int regArg;
    int nArg = 0;
    Window *pWin;
    for(pWin=pMWin; pWin; pWin=pWin-&gt;pNextWin){
      FuncDef *pFunc = pWin-&gt;pFunc;
<span class="udiff-line-added">+     assert( pWin-&gt;regAccum );</span>
      sqlite3VdbeAddOp2(v, OP_Null, 0, pWin-&gt;regAccum);
      nArg = MAX(nArg, windowArgCount(pWin));
      if( pMWin-&gt;regStartRowid==0 ){
        if( pFunc-&gt;zName==nth_valueName || pFunc-&gt;zName==first_valueName ){
          sqlite3VdbeAddOp2(v, OP_Integer, 0, pWin-&gt;regApp);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -151589,10 +152849,14 @@</span>
        pNew-&gt;eFrmType = p-&gt;eFrmType;
        pNew-&gt;eEnd = p-&gt;eEnd;
        pNew-&gt;eStart = p-&gt;eStart;
        pNew-&gt;eExclude = p-&gt;eExclude;
        pNew-&gt;regResult = p-&gt;regResult;
<span class="udiff-line-added">+       pNew-&gt;regAccum = p-&gt;regAccum;</span>
<span class="udiff-line-added">+       pNew-&gt;iArgCol = p-&gt;iArgCol;</span>
<span class="udiff-line-added">+       pNew-&gt;iEphCsr = p-&gt;iEphCsr;</span>
<span class="udiff-line-added">+       pNew-&gt;bExprArgs = p-&gt;bExprArgs;</span>
        pNew-&gt;pStart = sqlite3ExprDup(db, p-&gt;pStart, 0);
        pNew-&gt;pEnd = sqlite3ExprDup(db, p-&gt;pEnd, 0);
        pNew-&gt;pOwner = pOwner;
        pNew-&gt;bImplicitFrame = p-&gt;bImplicitFrame;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -152426,10 +153690,11 @@</span>
      if( p ){
        /* memset(p, 0, sizeof(Expr)); */
        p-&gt;op = (u8)op;
        p-&gt;affExpr = 0;
        p-&gt;flags = EP_Leaf;
<span class="udiff-line-added">+       ExprClearVVAProperties(p);</span>
        p-&gt;iAgg = -1;
        p-&gt;pLeft = p-&gt;pRight = 0;
        p-&gt;x.pList = 0;
        p-&gt;pAggInfo = 0;
        p-&gt;y.pTab = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -156494,10 +157759,17 @@</span>
        ** simplify to constants 0 (false) and 1 (true), respectively,
        ** regardless of the value of expr1.
        */
        sqlite3ExprUnmapAndDelete(pParse, yymsp[-4].minor.yy202);
        yymsp[-4].minor.yy202 = sqlite3Expr(pParse-&gt;db, TK_INTEGER, yymsp[-3].minor.yy192 ? &quot;1&quot; : &quot;0&quot;);
<span class="udiff-line-added">+     }else if( yymsp[-1].minor.yy242-&gt;nExpr==1 &amp;&amp; sqlite3ExprIsConstant(yymsp[-1].minor.yy242-&gt;a[0].pExpr) ){</span>
<span class="udiff-line-added">+       Expr *pRHS = yymsp[-1].minor.yy242-&gt;a[0].pExpr;</span>
<span class="udiff-line-added">+       yymsp[-1].minor.yy242-&gt;a[0].pExpr = 0;</span>
<span class="udiff-line-added">+       sqlite3ExprListDelete(pParse-&gt;db, yymsp[-1].minor.yy242);</span>
<span class="udiff-line-added">+       pRHS = sqlite3PExpr(pParse, TK_UPLUS, pRHS, 0);</span>
<span class="udiff-line-added">+       yymsp[-4].minor.yy202 = sqlite3PExpr(pParse, TK_EQ, yymsp[-4].minor.yy202, pRHS);</span>
<span class="udiff-line-added">+       if( yymsp[-3].minor.yy192 ) yymsp[-4].minor.yy202 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy202, 0);</span>
      }else{
        yymsp[-4].minor.yy202 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy202, 0);
        if( yymsp[-4].minor.yy202 ){
          yymsp[-4].minor.yy202-&gt;x.pList = yymsp[-1].minor.yy242;
          sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy202);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -157765,16 +159037,21 @@</span>
    const char *zKW;
    if( n&gt;=2 ){
      i = ((charMap(z[0])*4) ^ (charMap(z[n-1])*3) ^ n) % 127;
      for(i=((int)aKWHash[i])-1; i&gt;=0; i=((int)aKWNext[i])-1){
        if( aKWLen[i]!=n ) continue;
<span class="udiff-line-removed">-       j = 0;</span>
        zKW = &amp;zKWText[aKWOffset[i]];
  #ifdef SQLITE_ASCII
<span class="udiff-line-added">+       if( (z[0]&amp;~0x20)!=zKW[0] ) continue;</span>
<span class="udiff-line-added">+       if( (z[1]&amp;~0x20)!=zKW[1] ) continue;</span>
<span class="udiff-line-added">+       j = 2;</span>
        while( j&lt;n &amp;&amp; (z[j]&amp;~0x20)==zKW[j] ){ j++; }
  #endif
  #ifdef SQLITE_EBCDIC
<span class="udiff-line-added">+       if( toupper(z[0])!=zKW[0] ) continue;</span>
<span class="udiff-line-added">+       if( toupper(z[1])!=zKW[1] ) continue;</span>
<span class="udiff-line-added">+       j = 2;</span>
        while( j&lt;n &amp;&amp; toupper(z[j])==zKW[j] ){ j++; }
  #endif
        if( j&lt;n ) continue;
        testcase( i==0 ); /* REINDEX */
        testcase( i==1 ); /* INDEXED */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -158368,11 +159645,11 @@</span>
    VVA_ONLY( u8 startedWithOom = db-&gt;mallocFailed );
  
    assert( zSql!=0 );
    mxSqlLen = db-&gt;aLimit[SQLITE_LIMIT_SQL_LENGTH];
    if( db-&gt;nVdbeActive==0 ){
<span class="udiff-line-modified-removed">-     db-&gt;u1.isInterrupted = 0;</span>
<span class="udiff-line-modified-added">+     AtomicStore(&amp;db-&gt;u1.isInterrupted, 0);</span>
    }
    pParse-&gt;rc = SQLITE_OK;
    pParse-&gt;zTail = zSql;
    assert( pzErrMsg!=0 );
  #ifdef SQLITE_DEBUG
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -158413,11 +159690,11 @@</span>
        );
  #else
      if( tokenType&gt;=TK_SPACE ){
        assert( tokenType==TK_SPACE || tokenType==TK_ILLEGAL );
  #endif /* SQLITE_OMIT_WINDOWFUNC */
<span class="udiff-line-modified-removed">-       if( db-&gt;u1.isInterrupted ){</span>
<span class="udiff-line-modified-added">+       if( AtomicLoad(&amp;db-&gt;u1.isInterrupted) ){</span>
          pParse-&gt;rc = SQLITE_INTERRUPT;
          break;
        }
        if( tokenType==TK_SPACE ){
          zSql += n;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -159080,19 +160357,82 @@</span>
  
  
  /************** End of sqliteicu.h *******************************************/
  /************** Continuing where we left off in main.c ***********************/
  #endif
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** This is an extension initializer that is a no-op and always</span>
<span class="udiff-line-added">+ ** succeeds, except that it fails if the fault-simulation is set</span>
<span class="udiff-line-added">+ ** to 500.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static int sqlite3TestExtInit(sqlite3 *db){</span>
<span class="udiff-line-added">+   (void)db;</span>
<span class="udiff-line-added">+   return sqlite3FaultSim(500);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Forward declarations of external module initializer functions</span>
<span class="udiff-line-added">+ ** for modules that need them.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_FTS1</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE int sqlite3Fts1Init(sqlite3*);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_FTS2</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE int sqlite3Fts2Init(sqlite3*);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_FTS5</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE int sqlite3Fts5Init(sqlite3*);</span>
<span class="udiff-line-added">+ #endif</span>
  #ifdef SQLITE_ENABLE_JSON1
  SQLITE_PRIVATE int sqlite3Json1Init(sqlite3*);
  #endif
  #ifdef SQLITE_ENABLE_STMTVTAB
  SQLITE_PRIVATE int sqlite3StmtVtabInit(sqlite3*);
  #endif
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** An array of pointers to extension initializer functions for</span>
<span class="udiff-line-added">+ ** built-in extensions.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static int (*const sqlite3BuiltinExtensions[])(sqlite3*) = {</span>
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_FTS1</span>
<span class="udiff-line-added">+   sqlite3Fts1Init,</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_FTS2</span>
<span class="udiff-line-added">+   sqlite3Fts2Init,</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_FTS3</span>
<span class="udiff-line-added">+   sqlite3Fts3Init,</span>
<span class="udiff-line-added">+ #endif</span>
  #ifdef SQLITE_ENABLE_FTS5
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE int sqlite3Fts5Init(sqlite3*);</span>
<span class="udiff-line-modified-added">+   sqlite3Fts5Init,</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ #if defined(SQLITE_ENABLE_ICU) || defined(SQLITE_ENABLE_ICU_COLLATIONS)</span>
<span class="udiff-line-added">+   sqlite3IcuInit,</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_RTREE</span>
<span class="udiff-line-added">+   sqlite3RtreeInit,</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_DBPAGE_VTAB</span>
<span class="udiff-line-added">+   sqlite3DbpageRegister,</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_DBSTAT_VTAB</span>
<span class="udiff-line-added">+   sqlite3DbstatRegister,</span>
  #endif
<span class="udiff-line-added">+   sqlite3TestExtInit,</span>
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_JSON1</span>
<span class="udiff-line-added">+   sqlite3Json1Init,</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_STMTVTAB</span>
<span class="udiff-line-added">+   sqlite3StmtVtabInit,</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ #ifdef SQLITE_ENABLE_BYTECODE_VTAB</span>
<span class="udiff-line-added">+   sqlite3VdbeBytecodeVtabInit,</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ };</span>
  
  #ifndef SQLITE_AMALGAMATION
  /* IMPLEMENTATION-OF: R-46656-45156 The sqlite3_version[] string constant
  ** contains the text of SQLITE_VERSION macro.
  */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -159216,11 +160556,14 @@</span>
    /* If SQLite is already completely initialized, then this call
    ** to sqlite3_initialize() should be a no-op.  But the initialization
    ** must be complete.  So isInit must not be set until the very end
    ** of this routine.
    */
<span class="udiff-line-modified-removed">-   if( sqlite3GlobalConfig.isInit ) return SQLITE_OK;</span>
<span class="udiff-line-modified-added">+   if( sqlite3GlobalConfig.isInit ){</span>
<span class="udiff-line-added">+     sqlite3MemoryBarrier();</span>
<span class="udiff-line-added">+     return SQLITE_OK;</span>
<span class="udiff-line-added">+   }</span>
  
    /* Make sure the mutex subsystem is initialized.  If unable to
    ** initialize the mutex subsystem, return early with the error.
    ** If the system is so sick that we are unable to allocate a mutex,
    ** there is not much SQLite is going to be able to do.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -159302,10 +160645,11 @@</span>
      }
  #endif
      if( rc==SQLITE_OK ){
        sqlite3PCacheBufferSetup( sqlite3GlobalConfig.pPage,
            sqlite3GlobalConfig.szPage, sqlite3GlobalConfig.nPage);
<span class="udiff-line-added">+       sqlite3MemoryBarrier();</span>
        sqlite3GlobalConfig.isInit = 1;
  #ifdef SQLITE_EXTRA_INIT
        bRunExtraInit = 1;
  #endif
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -160603,12 +161947,11 @@</span>
  ** Return non-zero to retry the lock.  Return zero to stop trying
  ** and cause SQLite to return SQLITE_BUSY.
  */
  static int sqliteDefaultBusyCallback(
    void *ptr,               /* Database connection */
<span class="udiff-line-modified-removed">-   int count,               /* Number of times table has been busy */</span>
<span class="udiff-line-removed">-   sqlite3_file *pFile      /* The file on which the lock occurred */</span>
<span class="udiff-line-modified-added">+   int count                /* Number of times table has been busy */</span>
  ){
  #if SQLITE_OS_WIN || HAVE_USLEEP
    /* This case is for systems that have support for sleeping for fractions of
    ** a second.  Examples:  All windows systems, unix systems with usleep() */
    static const u8 delays[] =
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -160618,23 +161961,10 @@</span>
  # define NDELAY ArraySize(delays)
    sqlite3 *db = (sqlite3 *)ptr;
    int tmout = db-&gt;busyTimeout;
    int delay, prior;
  
<span class="udiff-line-removed">- #ifdef SQLITE_ENABLE_SETLK_TIMEOUT</span>
<span class="udiff-line-removed">-   if( sqlite3OsFileControl(pFile,SQLITE_FCNTL_LOCK_TIMEOUT,&amp;tmout)==SQLITE_OK ){</span>
<span class="udiff-line-removed">-     if( count ){</span>
<span class="udiff-line-removed">-       tmout = 0;</span>
<span class="udiff-line-removed">-       sqlite3OsFileControl(pFile, SQLITE_FCNTL_LOCK_TIMEOUT, &amp;tmout);</span>
<span class="udiff-line-removed">-       return 0;</span>
<span class="udiff-line-removed">-     }else{</span>
<span class="udiff-line-removed">-       return 1;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-   UNUSED_PARAMETER(pFile);</span>
<span class="udiff-line-removed">- #endif</span>
    assert( count&gt;=0 );
    if( count &lt; NDELAY ){
      delay = delays[count];
      prior = totals[count];
    }else{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -160650,11 +161980,10 @@</span>
  #else
    /* This case for unix systems that lack usleep() support.  Sleeping
    ** must be done in increments of whole seconds */
    sqlite3 *db = (sqlite3 *)ptr;
    int tmout = ((sqlite3 *)ptr)-&gt;busyTimeout;
<span class="udiff-line-removed">-   UNUSED_PARAMETER(pFile);</span>
    if( (count+1)*1000 &gt; tmout ){
      return 0;
    }
    sqlite3OsSleep(db-&gt;pVfs, 1000000);
    return 1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -160668,23 +161997,14 @@</span>
  ** lock on VFS file pFile.
  **
  ** If this routine returns non-zero, the lock is retried.  If it
  ** returns 0, the operation aborts with an SQLITE_BUSY error.
  */
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE int sqlite3InvokeBusyHandler(BusyHandler *p, sqlite3_file *pFile){</span>
<span class="udiff-line-modified-added">+ SQLITE_PRIVATE int sqlite3InvokeBusyHandler(BusyHandler *p){</span>
    int rc;
    if( p-&gt;xBusyHandler==0 || p-&gt;nBusy&lt;0 ) return 0;
<span class="udiff-line-modified-removed">-   if( p-&gt;bExtraFileArg ){</span>
<span class="udiff-line-removed">-     /* Add an extra parameter with the pFile pointer to the end of the</span>
<span class="udiff-line-removed">-     ** callback argument list */</span>
<span class="udiff-line-removed">-     int (*xTra)(void*,int,sqlite3_file*);</span>
<span class="udiff-line-removed">-     xTra = (int(*)(void*,int,sqlite3_file*))p-&gt;xBusyHandler;</span>
<span class="udiff-line-removed">-     rc = xTra(p-&gt;pBusyArg, p-&gt;nBusy, pFile);</span>
<span class="udiff-line-removed">-   }else{</span>
<span class="udiff-line-removed">-     /* Legacy style busy handler callback */</span>
<span class="udiff-line-removed">-     rc = p-&gt;xBusyHandler(p-&gt;pBusyArg, p-&gt;nBusy);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   rc = p-&gt;xBusyHandler(p-&gt;pBusyArg, p-&gt;nBusy);</span>
    if( rc==0 ){
      p-&gt;nBusy = -1;
    }else{
      p-&gt;nBusy++;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -160705,11 +162025,10 @@</span>
  #endif
    sqlite3_mutex_enter(db-&gt;mutex);
    db-&gt;busyHandler.xBusyHandler = xBusy;
    db-&gt;busyHandler.pBusyArg = pArg;
    db-&gt;busyHandler.nBusy = 0;
<span class="udiff-line-removed">-   db-&gt;busyHandler.bExtraFileArg = 0;</span>
    db-&gt;busyTimeout = 0;
    sqlite3_mutex_leave(db-&gt;mutex);
    return SQLITE_OK;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -160756,11 +162075,10 @@</span>
  #endif
    if( ms&gt;0 ){
      sqlite3_busy_handler(db, (int(*)(void*,int))sqliteDefaultBusyCallback,
                               (void*)db);
      db-&gt;busyTimeout = ms;
<span class="udiff-line-removed">-     db-&gt;busyHandler.bExtraFileArg = 1;</span>
    }else{
      sqlite3_busy_handler(db, 0, 0);
    }
    return SQLITE_OK;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -160773,11 +162091,11 @@</span>
    if( !sqlite3SafetyCheckOk(db) &amp;&amp; (db==0 || db-&gt;magic!=SQLITE_MAGIC_ZOMBIE) ){
      (void)SQLITE_MISUSE_BKPT;
      return;
    }
  #endif
<span class="udiff-line-modified-removed">-   db-&gt;u1.isInterrupted = 1;</span>
<span class="udiff-line-modified-added">+   AtomicStore(&amp;db-&gt;u1.isInterrupted, 1);</span>
  }
  
  
  /*
  ** This function is exactly the same as sqlite3_create_function(), except
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -161395,11 +162713,11 @@</span>
    rc = sqlite3ApiExit(db, rc);
  
    /* If there are no active statements, clear the interrupt flag at this
    ** point.  */
    if( db-&gt;nVdbeActive==0 ){
<span class="udiff-line-modified-removed">-     db-&gt;u1.isInterrupted = 0;</span>
<span class="udiff-line-modified-added">+     AtomicStore(&amp;db-&gt;u1.isInterrupted, 0);</span>
    }
  
    sqlite3_mutex_leave(db-&gt;mutex);
    return rc;
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -161805,13 +163123,15 @@</span>
  ** *pFlags may be updated before returning if the URI filename contains
  ** &quot;cache=xxx&quot; or &quot;mode=xxx&quot; query parameters.
  **
  ** If successful, SQLITE_OK is returned. In this case *ppVfs is set to point to
  ** the VFS that should be used to open the database file. *pzFile is set to
<span class="udiff-line-modified-removed">- ** point to a buffer containing the name of the file to open. It is the</span>
<span class="udiff-line-modified-removed">- ** responsibility of the caller to eventually call sqlite3_free() to release</span>
<span class="udiff-line-modified-removed">- ** this buffer.</span>
<span class="udiff-line-modified-added">+ ** point to a buffer containing the name of the file to open.  The value</span>
<span class="udiff-line-modified-added">+ ** stored in *pzFile is a database name acceptable to sqlite3_uri_parameter()</span>
<span class="udiff-line-modified-added">+ ** and is in the same format as names created using sqlite3_create_filename().</span>
<span class="udiff-line-added">+ ** The caller must invoke sqlite3_free_filename() (not sqlite3_free()!) on</span>
<span class="udiff-line-added">+ ** the value returned in *pzFile to avoid a memory leak.</span>
  **
  ** If an error occurs, then an SQLite error code is returned and *pzErrMsg
  ** may be set to point to a buffer containing an English language error
  ** message. It is the responsibility of the caller to eventually release
  ** this buffer by calling sqlite3_free().
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -161839,20 +163159,23 @@</span>
    ){
      char *zOpt;
      int eState;                   /* Parser state when parsing URI */
      int iIn;                      /* Input character index */
      int iOut = 0;                 /* Output character index */
<span class="udiff-line-modified-removed">-     u64 nByte = nUri+2;           /* Bytes of space to allocate */</span>
<span class="udiff-line-modified-added">+     u64 nByte = nUri+8;           /* Bytes of space to allocate */</span>
  
      /* Make sure the SQLITE_OPEN_URI flag is set to indicate to the VFS xOpen
      ** method that there may be extra parameters following the file-name.  */
      flags |= SQLITE_OPEN_URI;
  
      for(iIn=0; iIn&lt;nUri; iIn++) nByte += (zUri[iIn]==&#39;&amp;&#39;);
      zFile = sqlite3_malloc64(nByte);
      if( !zFile ) return SQLITE_NOMEM_BKPT;
  
<span class="udiff-line-added">+     memset(zFile, 0, 4);  /* 4-byte of 0x00 is the start of DB name marker */</span>
<span class="udiff-line-added">+     zFile += 4;</span>
<span class="udiff-line-added">+ </span>
      iIn = 5;
  #ifdef SQLITE_ALLOW_URI_AUTHORITY
      if( strncmp(zUri+5, &quot;///&quot;, 3)==0 ){
        iIn = 7;
        /* The following condition causes URIs with five leading / characters
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -161938,12 +163261,11 @@</span>
          eState = 1;
        }
        zFile[iOut++] = c;
      }
      if( eState==1 ) zFile[iOut++] = &#39;\0&#39;;
<span class="udiff-line-modified-removed">-     zFile[iOut++] = &#39;\0&#39;;</span>
<span class="udiff-line-removed">-     zFile[iOut++] = &#39;\0&#39;;</span>
<span class="udiff-line-modified-added">+     memset(zFile+iOut, 0, 4); /* end-of-options + empty journal filenames */</span>
  
      /* Check if there were any options specified that should be interpreted
      ** here. Options that are interpreted here include &quot;vfs&quot; and those that
      ** correspond to flags that may be passed to the sqlite3_open_v2()
      ** method. */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -162019,68 +163341,51 @@</span>
  
        zOpt = &amp;zVal[nVal+1];
      }
  
    }else{
<span class="udiff-line-modified-removed">-     zFile = sqlite3_malloc64(nUri+2);</span>
<span class="udiff-line-modified-added">+     zFile = sqlite3_malloc64(nUri+8);</span>
      if( !zFile ) return SQLITE_NOMEM_BKPT;
<span class="udiff-line-added">+     memset(zFile, 0, 4);</span>
<span class="udiff-line-added">+     zFile += 4;</span>
      if( nUri ){
        memcpy(zFile, zUri, nUri);
      }
<span class="udiff-line-modified-removed">-     zFile[nUri] = &#39;\0&#39;;</span>
<span class="udiff-line-removed">-     zFile[nUri+1] = &#39;\0&#39;;</span>
<span class="udiff-line-modified-added">+     memset(zFile+nUri, 0, 4);</span>
      flags &amp;= ~SQLITE_OPEN_URI;
    }
  
    *ppVfs = sqlite3_vfs_find(zVfs);
    if( *ppVfs==0 ){
      *pzErrMsg = sqlite3_mprintf(&quot;no such vfs: %s&quot;, zVfs);
      rc = SQLITE_ERROR;
    }
   parse_uri_out:
    if( rc!=SQLITE_OK ){
<span class="udiff-line-modified-removed">-     sqlite3_free(zFile);</span>
<span class="udiff-line-modified-added">+     sqlite3_free_filename(zFile);</span>
      zFile = 0;
    }
    *pFlags = flags;
    *pzFile = zFile;
    return rc;
  }
  
<span class="udiff-line-removed">- #if defined(SQLITE_HAS_CODEC)</span>
  /*
<span class="udiff-line-modified-removed">- ** Process URI filename query parameters relevant to the SQLite Encryption</span>
<span class="udiff-line-modified-removed">- ** Extension.  Return true if any of the relevant query parameters are</span>
<span class="udiff-line-removed">- ** seen and return false if not.</span>
<span class="udiff-line-modified-added">+ ** This routine does the core work of extracting URI parameters from a</span>
<span class="udiff-line-modified-added">+ ** database filename for the sqlite3_uri_parameter() interface.</span>
  */
<span class="udiff-line-modified-removed">- SQLITE_PRIVATE int sqlite3CodecQueryParameters(</span>
<span class="udiff-line-modified-removed">-   sqlite3 *db,           /* Database connection */</span>
<span class="udiff-line-modified-removed">-   const char *zDb,       /* Which schema is being created/attached */</span>
<span class="udiff-line-modified-removed">-   const char *zUri       /* URI filename */</span>
<span class="udiff-line-modified-removed">- ){</span>
<span class="udiff-line-modified-removed">-   const char *zKey;</span>
<span class="udiff-line-modified-removed">-   if( (zKey = sqlite3_uri_parameter(zUri, &quot;hexkey&quot;))!=0 &amp;&amp; zKey[0] ){</span>
<span class="udiff-line-removed">-     u8 iByte;</span>
<span class="udiff-line-removed">-     int i;</span>
<span class="udiff-line-removed">-     char zDecoded[40];</span>
<span class="udiff-line-removed">-     for(i=0, iByte=0; i&lt;sizeof(zDecoded)*2 &amp;&amp; sqlite3Isxdigit(zKey[i]); i++){</span>
<span class="udiff-line-removed">-       iByte = (iByte&lt;&lt;4) + sqlite3HexToInt(zKey[i]);</span>
<span class="udiff-line-removed">-       if( (i&amp;1)!=0 ) zDecoded[i/2] = iByte;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     sqlite3_key_v2(db, zDb, zDecoded, i/2);</span>
<span class="udiff-line-removed">-     return 1;</span>
<span class="udiff-line-removed">-   }else if( (zKey = sqlite3_uri_parameter(zUri, &quot;key&quot;))!=0 ){</span>
<span class="udiff-line-removed">-     sqlite3_key_v2(db, zDb, zKey, sqlite3Strlen30(zKey));</span>
<span class="udiff-line-removed">-     return 1;</span>
<span class="udiff-line-removed">-   }else if( (zKey = sqlite3_uri_parameter(zUri, &quot;textkey&quot;))!=0 ){</span>
<span class="udiff-line-removed">-     sqlite3_key_v2(db, zDb, zKey, -1);</span>
<span class="udiff-line-removed">-     return 1;</span>
<span class="udiff-line-removed">-   }else{</span>
<span class="udiff-line-removed">-     return 0;</span>
<span class="udiff-line-modified-added">+ static const char *uriParameter(const char *zFilename, const char *zParam){</span>
<span class="udiff-line-modified-added">+   zFilename += sqlite3Strlen30(zFilename) + 1;</span>
<span class="udiff-line-modified-added">+   while( zFilename[0] ){</span>
<span class="udiff-line-modified-added">+     int x = strcmp(zFilename, zParam);</span>
<span class="udiff-line-modified-added">+     zFilename += sqlite3Strlen30(zFilename) + 1;</span>
<span class="udiff-line-modified-added">+     if( x==0 ) return zFilename;</span>
<span class="udiff-line-modified-added">+     zFilename += sqlite3Strlen30(zFilename) + 1;</span>
    }
<span class="udiff-line-added">+   return 0;</span>
  }
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-added">+ </span>
  
  
  /*
  ** This routine does the work of opening a database on behalf of
  ** sqlite3_open() and sqlite3_open16(). The database filename &quot;zFilename&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -162095,10 +163400,11 @@</span>
    sqlite3 *db;                    /* Store allocated handle here */
    int rc;                         /* Return code */
    int isThreadsafe;               /* True for threadsafe connections */
    char *zOpen = 0;                /* Filename argument to pass to BtreeOpen() */
    char *zErrMsg = 0;              /* Error message from sqlite3ParseUri() */
<span class="udiff-line-added">+   int i;                          /* Loop counter */</span>
  
  #ifdef SQLITE_ENABLE_API_ARMOR
    if( ppDb==0 ) return SQLITE_MISUSE_BKPT;
  #endif
    *ppDb = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -162242,10 +163548,13 @@</span>
  #if defined(SQLITE_ENABLE_QPSG)
                   | SQLITE_EnableQPSG
  #endif
  #if defined(SQLITE_DEFAULT_DEFENSIVE)
                   | SQLITE_Defensive
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ #if defined(SQLITE_DEFAULT_LEGACY_ALTER_TABLE)</span>
<span class="udiff-line-added">+                  | SQLITE_LegacyAlter</span>
  #endif
        ;
    sqlite3HashInit(&amp;db-&gt;aCollSeq);
  #ifndef SQLITE_OMIT_VIRTUALTABLE
    sqlite3HashInit(&amp;db-&gt;aModule);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -162264,15 +163573,10 @@</span>
    createCollation(db, &quot;NOCASE&quot;, SQLITE_UTF8, 0, nocaseCollatingFunc, 0);
    createCollation(db, &quot;RTRIM&quot;, SQLITE_UTF8, 0, rtrimCollFunc, 0);
    if( db-&gt;mallocFailed ){
      goto opendb_out;
    }
<span class="udiff-line-removed">-   /* EVIDENCE-OF: R-08308-17224 The default collating function for all</span>
<span class="udiff-line-removed">-   ** strings is BINARY.</span>
<span class="udiff-line-removed">-   */</span>
<span class="udiff-line-removed">-   db-&gt;pDfltColl = sqlite3FindCollSeq(db, SQLITE_UTF8, sqlite3StrBINARY, 0);</span>
<span class="udiff-line-removed">-   assert( db-&gt;pDfltColl!=0 );</span>
  
    /* Parse the filename/URI argument
    **
    ** Only allow sensible combinations of bits in the flags argument.
    ** Throw an error if any non-sense combination is used.  If we
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -162290,11 +163594,11 @@</span>
    assert( SQLITE_OPEN_CREATE    == 0x04 );
    testcase( (1&lt;&lt;(flags&amp;7))==0x02 ); /* READONLY */
    testcase( (1&lt;&lt;(flags&amp;7))==0x04 ); /* READWRITE */
    testcase( (1&lt;&lt;(flags&amp;7))==0x40 ); /* READWRITE | CREATE */
    if( ((1&lt;&lt;(flags&amp;7)) &amp; 0x46)==0 ){
<span class="udiff-line-modified-removed">-     rc = SQLITE_MISUSE_BKPT;  /* IMP: R-65497-44594 */</span>
<span class="udiff-line-modified-added">+     rc = SQLITE_MISUSE_BKPT;  /* IMP: R-18321-05872 */</span>
    }else{
      rc = sqlite3ParseUri(zVfs, zFilename, &amp;flags, &amp;db-&gt;pVfs, &amp;zOpen, &amp;zErrMsg);
    }
    if( rc!=SQLITE_OK ){
      if( rc==SQLITE_NOMEM ) sqlite3OomFault(db);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -162313,11 +163617,13 @@</span>
      sqlite3Error(db, rc);
      goto opendb_out;
    }
    sqlite3BtreeEnter(db-&gt;aDb[0].pBt);
    db-&gt;aDb[0].pSchema = sqlite3SchemaGet(db, db-&gt;aDb[0].pBt);
<span class="udiff-line-modified-removed">-   if( !db-&gt;mallocFailed ) ENC(db) = SCHEMA_ENC(db);</span>
<span class="udiff-line-modified-added">+   if( !db-&gt;mallocFailed ){</span>
<span class="udiff-line-added">+     sqlite3SetTextEncoding(db, SCHEMA_ENC(db));</span>
<span class="udiff-line-added">+   }</span>
    sqlite3BtreeLeave(db-&gt;aDb[0].pBt);
    db-&gt;aDb[1].pSchema = sqlite3SchemaGet(db, 0);
  
    /* The default safety_level for the main database is FULL; for the temp
    ** database it is OFF. This matches the pager layer defaults.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -162338,18 +163644,15 @@</span>
    */
    sqlite3Error(db, SQLITE_OK);
    sqlite3RegisterPerConnectionBuiltinFunctions(db);
    rc = sqlite3_errcode(db);
  
<span class="udiff-line-modified-removed">- #ifdef SQLITE_ENABLE_FTS5</span>
<span class="udiff-line-modified-removed">-   /* Register any built-in FTS5 module before loading the automatic</span>
<span class="udiff-line-modified-removed">-   ** extensions. This allows automatic extensions to register FTS5</span>
<span class="udiff-line-modified-removed">-   ** tokenizers and auxiliary functions.  */</span>
<span class="udiff-line-removed">-   if( !db-&gt;mallocFailed &amp;&amp; rc==SQLITE_OK ){</span>
<span class="udiff-line-removed">-     rc = sqlite3Fts5Init(db);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   /* Load compiled-in extensions */</span>
<span class="udiff-line-modified-added">+   for(i=0; rc==SQLITE_OK &amp;&amp; i&lt;ArraySize(sqlite3BuiltinExtensions); i++){</span>
<span class="udiff-line-modified-added">+     rc = sqlite3BuiltinExtensions[i](db);</span>
    }
<span class="udiff-line-removed">- #endif</span>
  
    /* Load automatic extensions - extensions that have been registered
    ** using the sqlite3_automatic_extension() API.
    */
    if( rc==SQLITE_OK ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -162358,66 +163661,10 @@</span>
      if( rc!=SQLITE_OK ){
        goto opendb_out;
      }
    }
  
<span class="udiff-line-removed">- #ifdef SQLITE_ENABLE_FTS1</span>
<span class="udiff-line-removed">-   if( !db-&gt;mallocFailed ){</span>
<span class="udiff-line-removed">-     extern int sqlite3Fts1Init(sqlite3*);</span>
<span class="udiff-line-removed">-     rc = sqlite3Fts1Init(db);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef SQLITE_ENABLE_FTS2</span>
<span class="udiff-line-removed">-   if( !db-&gt;mallocFailed &amp;&amp; rc==SQLITE_OK ){</span>
<span class="udiff-line-removed">-     extern int sqlite3Fts2Init(sqlite3*);</span>
<span class="udiff-line-removed">-     rc = sqlite3Fts2Init(db);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef SQLITE_ENABLE_FTS3 /* automatically defined by SQLITE_ENABLE_FTS4 */</span>
<span class="udiff-line-removed">-   if( !db-&gt;mallocFailed &amp;&amp; rc==SQLITE_OK ){</span>
<span class="udiff-line-removed">-     rc = sqlite3Fts3Init(db);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #if defined(SQLITE_ENABLE_ICU) || defined(SQLITE_ENABLE_ICU_COLLATIONS)</span>
<span class="udiff-line-removed">-   if( !db-&gt;mallocFailed &amp;&amp; rc==SQLITE_OK ){</span>
<span class="udiff-line-removed">-     rc = sqlite3IcuInit(db);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef SQLITE_ENABLE_RTREE</span>
<span class="udiff-line-removed">-   if( !db-&gt;mallocFailed &amp;&amp; rc==SQLITE_OK){</span>
<span class="udiff-line-removed">-     rc = sqlite3RtreeInit(db);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef SQLITE_ENABLE_DBPAGE_VTAB</span>
<span class="udiff-line-removed">-   if( !db-&gt;mallocFailed &amp;&amp; rc==SQLITE_OK){</span>
<span class="udiff-line-removed">-     rc = sqlite3DbpageRegister(db);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef SQLITE_ENABLE_DBSTAT_VTAB</span>
<span class="udiff-line-removed">-   if( !db-&gt;mallocFailed &amp;&amp; rc==SQLITE_OK){</span>
<span class="udiff-line-removed">-     rc = sqlite3DbstatRegister(db);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef SQLITE_ENABLE_JSON1</span>
<span class="udiff-line-removed">-   if( !db-&gt;mallocFailed &amp;&amp; rc==SQLITE_OK){</span>
<span class="udiff-line-removed">-     rc = sqlite3Json1Init(db);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef SQLITE_ENABLE_STMTVTAB</span>
<span class="udiff-line-removed">-   if( !db-&gt;mallocFailed &amp;&amp; rc==SQLITE_OK){</span>
<span class="udiff-line-removed">-     rc = sqlite3StmtVtabInit(db);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
  #ifdef SQLITE_ENABLE_INTERNAL_FUNCTIONS
    /* Testing use only!!! The -DSQLITE_ENABLE_INTERNAL_FUNCTIONS=1 compile-time
    ** option gives access to internal functions by default.
    ** Testing use only!!! */
    db-&gt;mDbFlags |= DBFLAG_InternalFunc;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -162461,14 +163708,11 @@</span>
      /* Opening a db handle. Fourth parameter is passed 0. */
      void *pArg = sqlite3GlobalConfig.pSqllogArg;
      sqlite3GlobalConfig.xSqllog(pArg, db, zFilename, 0);
    }
  #endif
<span class="udiff-line-modified-removed">- #if defined(SQLITE_HAS_CODEC)</span>
<span class="udiff-line-removed">-   if( rc==SQLITE_OK ) sqlite3CodecQueryParameters(db, 0, zOpen);</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-   sqlite3_free(zOpen);</span>
<span class="udiff-line-modified-added">+   sqlite3_free_filename(zOpen);</span>
    return rc &amp; 0xff;
  }
  
  
  /*
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -162691,17 +163935,19 @@</span>
  }
  SQLITE_PRIVATE int sqlite3CantopenError(int lineno){
    testcase( sqlite3GlobalConfig.xLog!=0 );
    return sqlite3ReportError(SQLITE_CANTOPEN, lineno, &quot;cannot open file&quot;);
  }
<span class="udiff-line-modified-removed">- #ifdef SQLITE_DEBUG</span>
<span class="udiff-line-modified-added">+ #if defined(SQLITE_DEBUG) || defined(SQLITE_ENABLE_CORRUPT_PGNO)</span>
  SQLITE_PRIVATE int sqlite3CorruptPgnoError(int lineno, Pgno pgno){
    char zMsg[100];
    sqlite3_snprintf(sizeof(zMsg), zMsg, &quot;database corruption page %d&quot;, pgno);
    testcase( sqlite3GlobalConfig.xLog!=0 );
    return sqlite3ReportError(SQLITE_CORRUPT, lineno, zMsg);
  }
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ #ifdef SQLITE_DEBUG</span>
  SQLITE_PRIVATE int sqlite3NomemError(int lineno){
    testcase( sqlite3GlobalConfig.xLog!=0 );
    return sqlite3ReportError(SQLITE_NOMEM, lineno, &quot;OOM&quot;);
  }
  SQLITE_PRIVATE int sqlite3IoerrnomemError(int lineno){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -162900,10 +164146,17 @@</span>
        *(sqlite3_file**)pArg = sqlite3PagerJrnlFile(pPager);
        rc = SQLITE_OK;
      }else if( op==SQLITE_FCNTL_DATA_VERSION ){
        *(unsigned int*)pArg = sqlite3PagerDataVersion(pPager);
        rc = SQLITE_OK;
<span class="udiff-line-added">+     }else if( op==SQLITE_FCNTL_RESERVE_BYTES ){</span>
<span class="udiff-line-added">+       int iNew = *(int*)pArg;</span>
<span class="udiff-line-added">+       *(int*)pArg = sqlite3BtreeGetRequestedReserve(pBtree);</span>
<span class="udiff-line-added">+       if( iNew&gt;=0 &amp;&amp; iNew&lt;=255 ){</span>
<span class="udiff-line-added">+         sqlite3BtreeSetPageSize(pBtree, 0, iNew, 0);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       rc = SQLITE_OK;</span>
      }else{
        rc = sqlite3OsFileControl(fd, op, pArg);
      }
      sqlite3BtreeLeave(pBtree);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -163116,24 +164369,10 @@</span>
      case SQLITE_TESTCTRL_BYTEORDER: {
        rc = SQLITE_BYTEORDER*100 + SQLITE_LITTLEENDIAN*10 + SQLITE_BIGENDIAN;
        break;
      }
  
<span class="udiff-line-removed">-     /*   sqlite3_test_control(SQLITE_TESTCTRL_RESERVE, sqlite3 *db, int N)</span>
<span class="udiff-line-removed">-     **</span>
<span class="udiff-line-removed">-     ** Set the nReserve size to N for the main database on the database</span>
<span class="udiff-line-removed">-     ** connection db.</span>
<span class="udiff-line-removed">-     */</span>
<span class="udiff-line-removed">-     case SQLITE_TESTCTRL_RESERVE: {</span>
<span class="udiff-line-removed">-       sqlite3 *db = va_arg(ap, sqlite3*);</span>
<span class="udiff-line-removed">-       int x = va_arg(ap,int);</span>
<span class="udiff-line-removed">-       sqlite3_mutex_enter(db-&gt;mutex);</span>
<span class="udiff-line-removed">-       sqlite3BtreeSetPageSize(db-&gt;aDb[0].pBt, 0, x, 0);</span>
<span class="udiff-line-removed">-       sqlite3_mutex_leave(db-&gt;mutex);</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      /*  sqlite3_test_control(SQLITE_TESTCTRL_OPTIMIZATIONS, sqlite3 *db, int N)
      **
      ** Enable or disable various optimizations for testing purposes.  The
      ** argument N is a bitmask of optimizations to be disabled.  For normal
      ** operation N should be 0.  The idea is that a test program (like the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -163313,10 +164552,72 @@</span>
      zName--;
    }
    return zName;
  }
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Append text z[] to the end of p[].  Return a pointer to the first</span>
<span class="udiff-line-added">+ ** character after then zero terminator on the new text in p[].</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ static char *appendText(char *p, const char *z){</span>
<span class="udiff-line-added">+   size_t n = strlen(z);</span>
<span class="udiff-line-added">+   memcpy(p, z, n+1);</span>
<span class="udiff-line-added">+   return p+n+1;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Allocate memory to hold names for a database, journal file, WAL file,</span>
<span class="udiff-line-added">+ ** and query parameters.  The pointer returned is valid for use by</span>
<span class="udiff-line-added">+ ** sqlite3_filename_database() and sqlite3_uri_parameter() and related</span>
<span class="udiff-line-added">+ ** functions.</span>
<span class="udiff-line-added">+ **</span>
<span class="udiff-line-added">+ ** Memory layout must be compatible with that generated by the pager</span>
<span class="udiff-line-added">+ ** and expected by sqlite3_uri_parameter() and databaseName().</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ SQLITE_API char *sqlite3_create_filename(</span>
<span class="udiff-line-added">+   const char *zDatabase,</span>
<span class="udiff-line-added">+   const char *zJournal,</span>
<span class="udiff-line-added">+   const char *zWal,</span>
<span class="udiff-line-added">+   int nParam,</span>
<span class="udiff-line-added">+   const char **azParam</span>
<span class="udiff-line-added">+ ){</span>
<span class="udiff-line-added">+   sqlite3_int64 nByte;</span>
<span class="udiff-line-added">+   int i;</span>
<span class="udiff-line-added">+   char *pResult, *p;</span>
<span class="udiff-line-added">+   nByte = strlen(zDatabase) + strlen(zJournal) + strlen(zWal) + 10;</span>
<span class="udiff-line-added">+   for(i=0; i&lt;nParam*2; i++){</span>
<span class="udiff-line-added">+     nByte += strlen(azParam[i])+1;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   pResult = p = sqlite3_malloc64( nByte );</span>
<span class="udiff-line-added">+   if( p==0 ) return 0;</span>
<span class="udiff-line-added">+   memset(p, 0, 4);</span>
<span class="udiff-line-added">+   p += 4;</span>
<span class="udiff-line-added">+   p = appendText(p, zDatabase);</span>
<span class="udiff-line-added">+   for(i=0; i&lt;nParam*2; i++){</span>
<span class="udiff-line-added">+     p = appendText(p, azParam[i]);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   *(p++) = 0;</span>
<span class="udiff-line-added">+   p = appendText(p, zJournal);</span>
<span class="udiff-line-added">+   p = appendText(p, zWal);</span>
<span class="udiff-line-added">+   *(p++) = 0;</span>
<span class="udiff-line-added">+   *(p++) = 0;</span>
<span class="udiff-line-added">+   assert( (sqlite3_int64)(p - pResult)==nByte );</span>
<span class="udiff-line-added">+   return pResult + 4;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Free memory obtained from sqlite3_create_filename().  It is a severe</span>
<span class="udiff-line-added">+ ** error to call this routine with any parameter other than a pointer</span>
<span class="udiff-line-added">+ ** previously obtained from sqlite3_create_filename() or a NULL pointer.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ SQLITE_API void sqlite3_free_filename(char *p){</span>
<span class="udiff-line-added">+   if( p==0 ) return;</span>
<span class="udiff-line-added">+   p = (char*)databaseName(p);</span>
<span class="udiff-line-added">+   sqlite3_free(p - 4);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  /*
  ** This is a utility routine, useful to VFS implementations, that checks
  ** to see if a database file was a URI that contained a specific query
  ** parameter, and if so obtains the value of the query parameter.
  **
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -163327,18 +164628,11 @@</span>
  ** returns a NULL pointer.
  */
  SQLITE_API const char *sqlite3_uri_parameter(const char *zFilename, const char *zParam){
    if( zFilename==0 || zParam==0 ) return 0;
    zFilename = databaseName(zFilename);
<span class="udiff-line-modified-removed">-   zFilename += sqlite3Strlen30(zFilename) + 1;</span>
<span class="udiff-line-removed">-   while( zFilename[0] ){</span>
<span class="udiff-line-removed">-     int x = strcmp(zFilename, zParam);</span>
<span class="udiff-line-removed">-     zFilename += sqlite3Strlen30(zFilename) + 1;</span>
<span class="udiff-line-removed">-     if( x==0 ) return zFilename;</span>
<span class="udiff-line-removed">-     zFilename += sqlite3Strlen30(zFilename) + 1;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return 0;</span>
<span class="udiff-line-modified-added">+   return uriParameter(zFilename, zParam);</span>
  }
  
  /*
  ** Return a pointer to the name of Nth query parameter of the filename.
  */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -163388,11 +164682,10 @@</span>
  ** an error that we cannot easily detect but that will likely cause memory
  ** corruption.
  */
  SQLITE_API const char *sqlite3_filename_database(const char *zFilename){
    return databaseName(zFilename);
<span class="udiff-line-removed">-   return sqlite3_uri_parameter(zFilename - 3, &quot;\003&quot;);</span>
  }
  SQLITE_API const char *sqlite3_filename_journal(const char *zFilename){
    zFilename = databaseName(zFilename);
    zFilename += sqlite3Strlen30(zFilename) + 1;
    while( zFilename[0] ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -165137,10 +166430,11 @@</span>
  SQLITE_PRIVATE void sqlite3Fts3DoclistPrev(int,char*,int,char**,sqlite3_int64*,int*,u8*);
  SQLITE_PRIVATE int sqlite3Fts3EvalPhraseStats(Fts3Cursor *, Fts3Expr *, u32 *);
  SQLITE_PRIVATE int sqlite3Fts3FirstFilter(sqlite3_int64, char *, int, char *);
  SQLITE_PRIVATE void sqlite3Fts3CreateStatTable(int*, Fts3Table*);
  SQLITE_PRIVATE int sqlite3Fts3EvalTestDeferred(Fts3Cursor *pCsr, int *pRc);
<span class="udiff-line-added">+ SQLITE_PRIVATE int sqlite3Fts3ReadInt(const char *z, int *pnOut);</span>
  
  /* fts3_tokenizer.c */
  SQLITE_PRIVATE const char *sqlite3Fts3NextToken(const char *, int *);
  SQLITE_PRIVATE int sqlite3Fts3InitHashTable(sqlite3 *, Fts3Hash *, const char *);
  SQLITE_PRIVATE int sqlite3Fts3InitTokenizer(Fts3Hash *pHash, const char *,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -165869,10 +167163,26 @@</span>
    }
    sqlite3_free(zFree);
    return zRet;
  }
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+ ** Buffer z contains a positive integer value encoded as utf-8 text.</span>
<span class="udiff-line-added">+ ** Decode this value and store it in *pnOut, returning the number of bytes</span>
<span class="udiff-line-added">+ ** consumed. If an overflow error occurs return a negative value.</span>
<span class="udiff-line-added">+ */</span>
<span class="udiff-line-added">+ SQLITE_PRIVATE int sqlite3Fts3ReadInt(const char *z, int *pnOut){</span>
<span class="udiff-line-added">+   u64 iVal = 0;</span>
<span class="udiff-line-added">+   int i;</span>
<span class="udiff-line-added">+   for(i=0; z[i]&gt;=&#39;0&#39; &amp;&amp; z[i]&lt;=&#39;9&#39;; i++){</span>
<span class="udiff-line-added">+     iVal = iVal*10 + (z[i] - &#39;0&#39;);</span>
<span class="udiff-line-added">+     if( iVal&gt;0x7FFFFFFF ) return -1;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   *pnOut = (int)iVal;</span>
<span class="udiff-line-added">+   return i;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /*
  ** This function interprets the string at (*pp) as a non-negative integer
  ** value. It reads the integer and sets *pnOut to the value read, then
  ** sets *pp to point to the byte immediately following the last byte of
  ** the integer value.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -165884,23 +167194,21 @@</span>
  **
  ** This function is used when parsing the &quot;prefix=&quot; FTS4 parameter.
  */
  static int fts3GobbleInt(const char **pp, int *pnOut){
    const int MAX_NPREFIX = 10000000;
<span class="udiff-line-removed">-   const char *p;                  /* Iterator pointer */</span>
    int nInt = 0;                   /* Output value */
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   for(p=*pp; p[0]&gt;=&#39;0&#39; &amp;&amp; p[0]&lt;=&#39;9&#39;; p++){</span>
<span class="udiff-line-modified-removed">-     nInt = nInt * 10 + (p[0] - &#39;0&#39;);</span>
<span class="udiff-line-modified-removed">-     if( nInt&gt;MAX_NPREFIX ){</span>
<span class="udiff-line-modified-removed">-       nInt = 0;</span>
<span class="udiff-line-modified-removed">-       break;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   int nByte;</span>
<span class="udiff-line-modified-added">+   nByte = sqlite3Fts3ReadInt(*pp, &amp;nInt);</span>
<span class="udiff-line-modified-added">+   if( nInt&gt;MAX_NPREFIX ){</span>
<span class="udiff-line-modified-added">+     nInt = 0;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   if( nByte==0 ){</span>
<span class="udiff-line-modified-added">+     return SQLITE_ERROR;</span>
    }
<span class="udiff-line-removed">-   if( p==*pp ) return SQLITE_ERROR;</span>
    *pnOut = nInt;
<span class="udiff-line-modified-removed">-   *pp = p;</span>
<span class="udiff-line-modified-added">+   *pp += nByte;</span>
    return SQLITE_OK;
  }
  
  /*
  ** This function is called to allocate an array of Fts3Index structures
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -166791,10 +168099,11 @@</span>
    const char *zEnd = &amp;zCsr[nNode];/* End of interior node buffer */
    char *zBuffer = 0;              /* Buffer to load terms into */
    i64 nAlloc = 0;                 /* Size of allocated buffer */
    int isFirstTerm = 1;            /* True when processing first term on page */
    sqlite3_int64 iChild;           /* Block id of child node to descend to */
<span class="udiff-line-added">+   int nBuffer = 0;                /* Total term size */</span>
  
    /* Skip over the &#39;height&#39; varint that occurs at the start of every
    ** interior node. Then load the blockid of the left-child of the b-tree
    ** node into variable iChild.
    **
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -166815,16 +168124,19 @@</span>
  
    while( zCsr&lt;zEnd &amp;&amp; (piFirst || piLast) ){
      int cmp;                      /* memcmp() result */
      int nSuffix;                  /* Size of term suffix */
      int nPrefix = 0;              /* Size of term prefix */
<span class="udiff-line-removed">-     int nBuffer;                  /* Total term size */</span>
  
      /* Load the next term on the node into zBuffer. Use realloc() to expand
      ** the size of zBuffer if required.  */
      if( !isFirstTerm ){
        zCsr += fts3GetVarint32(zCsr, &amp;nPrefix);
<span class="udiff-line-added">+       if( nPrefix&gt;nBuffer ){</span>
<span class="udiff-line-added">+         rc = FTS_CORRUPT_VTAB;</span>
<span class="udiff-line-added">+         goto finish_scan;</span>
<span class="udiff-line-added">+       }</span>
      }
      isFirstTerm = 0;
      zCsr += fts3GetVarint32(zCsr, &amp;nSuffix);
  
      assert( nPrefix&gt;=0 &amp;&amp; nSuffix&gt;=0 );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -167074,11 +168386,13 @@</span>
  static void fts3ReadNextPos(
    char **pp,                    /* IN/OUT: Pointer into position-list buffer */
    sqlite3_int64 *pi             /* IN/OUT: Value read from position-list */
  ){
    if( (**pp)&amp;0xFE ){
<span class="udiff-line-modified-removed">-     fts3GetDeltaVarint(pp, pi);</span>
<span class="udiff-line-modified-added">+     int iVal;</span>
<span class="udiff-line-added">+     *pp += fts3GetVarint32((*pp), &amp;iVal);</span>
<span class="udiff-line-added">+     *pi += iVal;</span>
      *pi -= 2;
    }else{
      *pi = POSITION_LIST_END;
    }
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -167154,10 +168468,13 @@</span>
        ** after the list written. No terminator (POS_END or POS_COLUMN) is
        ** written to the output.
        */
        fts3GetDeltaVarint(&amp;p1, &amp;i1);
        fts3GetDeltaVarint(&amp;p2, &amp;i2);
<span class="udiff-line-added">+       if( i1&lt;2 || i2&lt;2 ){</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+       }</span>
        do {
          fts3PutDeltaVarint(&amp;p, &amp;iPrev, (i1&lt;i2) ? i1 : i2);
          iPrev -= 2;
          if( i1==i2 ){
            fts3ReadNextPos(&amp;p1, &amp;i1);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -167222,11 +168539,11 @@</span>
    int iCol2 = 0;
  
    /* Never set both isSaveLeft and isExact for the same invocation. */
    assert( isSaveLeft==0 || isExact==0 );
  
<span class="udiff-line-modified-removed">-   assert( p!=0 &amp;&amp; *p1!=0 &amp;&amp; *p2!=0 );</span>
<span class="udiff-line-modified-added">+   assert_fts3_nc( p!=0 &amp;&amp; *p1!=0 &amp;&amp; *p2!=0 );</span>
    if( *p1==POS_COLUMN ){
      p1++;
      p1 += fts3GetVarint32(p1, &amp;iCol1);
    }
    if( *p2==POS_COLUMN ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -169407,11 +170724,11 @@</span>
  ){
    char *p = *ppIter;
  
    assert( nDoclist&gt;0 );
    assert( *pbEof==0 );
<span class="udiff-line-modified-removed">-   assert( p || *piDocid==0 );</span>
<span class="udiff-line-modified-added">+   assert_fts3_nc( p || *piDocid==0 );</span>
    assert( !p || (p&gt;=aDoclist &amp;&amp; p&lt;=&amp;aDoclist[nDoclist]) );
  
    if( p==0 ){
      p = aDoclist;
      p += sqlite3Fts3GetVarint(p, piDocid);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -170057,11 +171374,11 @@</span>
  **
  **     abc NEAR/5 &quot;def ghi&quot;
  **
  ** Parameter nNear is passed the NEAR distance of the expression (5 in
  ** the example above). When this function is called, *paPoslist points to
<span class="udiff-line-modified-removed">- ** the position list, and *pnToken is the number of phrase tokens in, the</span>
<span class="udiff-line-modified-added">+ ** the position list, and *pnToken is the number of phrase tokens in the</span>
  ** phrase on the other side of the NEAR operator to pPhrase. For example,
  ** if pPhrase refers to the &quot;def ghi&quot; phrase, then *paPoslist points to
  ** the position list associated with phrase &quot;abc&quot;.
  **
  ** All positions in the pPhrase position list that are not sufficiently
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -170204,10 +171521,11 @@</span>
                while( *pRc==SQLITE_OK &amp;&amp; pLeft-&gt;bEof==0 ){
                  memset(pDl-&gt;pList, 0, pDl-&gt;nList);
                  fts3EvalNextRow(pCsr, pLeft, pRc);
                }
              }
<span class="udiff-line-added">+             pRight-&gt;bEof = pLeft-&gt;bEof = 1;</span>
            }
          }
          break;
        }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -171974,14 +173292,11 @@</span>
  
        /* If this is a &quot;NEAR&quot; keyword, check for an explicit nearness. */
        if( pKey-&gt;eType==FTSQUERY_NEAR ){
          assert( nKey==4 );
          if( zInput[4]==&#39;/&#39; &amp;&amp; zInput[5]&gt;=&#39;0&#39; &amp;&amp; zInput[5]&lt;=&#39;9&#39; ){
<span class="udiff-line-modified-removed">-           nNear = 0;</span>
<span class="udiff-line-removed">-           for(nKey=5; zInput[nKey]&gt;=&#39;0&#39; &amp;&amp; zInput[nKey]&lt;=&#39;9&#39;; nKey++){</span>
<span class="udiff-line-removed">-             nNear = nNear * 10 + (zInput[nKey] - &#39;0&#39;);</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-modified-added">+           nKey += 1+sqlite3Fts3ReadInt(&amp;zInput[nKey+1], &amp;nNear);</span>
          }
        }
  
        /* At this point this is probably a keyword. But for that to be true,
        ** the next byte must contain either whitespace, an open or close
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -174983,11 +176298,11 @@</span>
      int nByte = sqlite3_value_bytes(apVal[0]);
      pCsr-&gt;zInput = sqlite3_malloc64(nByte+1);
      if( pCsr-&gt;zInput==0 ){
        rc = SQLITE_NOMEM;
      }else{
<span class="udiff-line-modified-removed">-       memcpy(pCsr-&gt;zInput, zByte, nByte);</span>
<span class="udiff-line-modified-added">+       if( nByte&gt;0 ) memcpy(pCsr-&gt;zInput, zByte, nByte);</span>
        pCsr-&gt;zInput[nByte] = 0;
        rc = pTab-&gt;pMod-&gt;xOpen(pTab-&gt;pTok, pCsr-&gt;zInput, nByte, &amp;pCsr-&gt;pCsr);
        if( rc==SQLITE_OK ){
          pCsr-&gt;pCsr-&gt;pTokenizer = pTab-&gt;pTok;
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -176506,10 +177821,11 @@</span>
    ** b-tree node. And that the final byte of the doclist is 0x00. If either
    ** of these statements is untrue, then the data structure is corrupt.
    */
    if( pReader-&gt;nDoclist &gt; pReader-&gt;nNode-(pReader-&gt;aDoclist-pReader-&gt;aNode)
     || (pReader-&gt;nPopulate==0 &amp;&amp; pReader-&gt;aDoclist[pReader-&gt;nDoclist-1])
<span class="udiff-line-added">+    || pReader-&gt;nDoclist==0</span>
    ){
      return FTS_CORRUPT_VTAB;
    }
    return SQLITE_OK;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -177593,11 +178909,11 @@</span>
    sqlite3_stmt *pStmt;
    int rc = fts3SqlStmt(p, SQL_SELECT_SEGDIR_MAX_LEVEL, &amp;pStmt, 0);
    if( rc!=SQLITE_OK ) return rc;
    sqlite3_bind_int64(pStmt, 1, iAbsLevel+1);
    sqlite3_bind_int64(pStmt, 2,
<span class="udiff-line-modified-removed">-       ((iAbsLevel/FTS3_SEGDIR_MAXLEVEL)+1) * FTS3_SEGDIR_MAXLEVEL</span>
<span class="udiff-line-modified-added">+       (((u64)iAbsLevel/FTS3_SEGDIR_MAXLEVEL)+1) * FTS3_SEGDIR_MAXLEVEL</span>
    );
  
    *pbMax = 0;
    if( SQLITE_ROW==sqlite3_step(pStmt) ){
      *pbMax = sqlite3_column_type(pStmt, 0)==SQLITE_NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -178159,25 +179475,25 @@</span>
  ){
    const unsigned char *zText = sqlite3_column_text(pStmt, iCol);
    if( zText ){
      int i;
      int iMul = 1;
<span class="udiff-line-modified-removed">-     i64 iVal = 0;</span>
<span class="udiff-line-modified-added">+     u64 iVal = 0;</span>
      for(i=0; zText[i]&gt;=&#39;0&#39; &amp;&amp; zText[i]&lt;=&#39;9&#39;; i++){
        iVal = iVal*10 + (zText[i] - &#39;0&#39;);
      }
<span class="udiff-line-modified-removed">-     *piEndBlock = iVal;</span>
<span class="udiff-line-modified-added">+     *piEndBlock = (i64)iVal;</span>
      while( zText[i]==&#39; &#39; ) i++;
      iVal = 0;
      if( zText[i]==&#39;-&#39; ){
        i++;
        iMul = -1;
      }
      for(/* no-op */; zText[i]&gt;=&#39;0&#39; &amp;&amp; zText[i]&lt;=&#39;9&#39;; i++){
        iVal = iVal*10 + (zText[i] - &#39;0&#39;);
      }
<span class="udiff-line-modified-removed">-     *pnByte = (iVal * (i64)iMul);</span>
<span class="udiff-line-modified-added">+     *pnByte = ((i64)iVal * (i64)iMul);</span>
    }
  }
  
  
  /*
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -180044,10 +181360,16 @@</span>
      /* If nSeg is less that zero, then there is no level with at least
      ** nMin segments and no hint in the %_stat table. No work to do.
      ** Exit early in this case.  */
      if( nSeg&lt;=0 ) break;
  
<span class="udiff-line-added">+     assert( nMod&lt;=0x7FFFFFFF );</span>
<span class="udiff-line-added">+     if( iAbsLevel&lt;0 || iAbsLevel&gt;(nMod&lt;&lt;32) ){</span>
<span class="udiff-line-added">+       rc = FTS_CORRUPT_VTAB;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /* Open a cursor to iterate through the contents of the oldest nSeg
      ** indexes of absolute level iAbsLevel. If this cursor is opened using
      ** the &#39;hint&#39; parameters, it is possible that there are less than nSeg
      ** segments available in level iAbsLevel. In this case, no work is
      ** done on iAbsLevel - fall through to the next iteration of the loop
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -181745,11 +183067,11 @@</span>
      iStart = pExpr-&gt;iPhrase * p-&gt;nCol;
    }else{
      iStart = pExpr-&gt;iPhrase * ((p-&gt;nCol + 31) / 32);
    }
  
<span class="udiff-line-modified-removed">-   while( 1 ){</span>
<span class="udiff-line-modified-added">+   if( pIter ) while( 1 ){</span>
      int nHit = fts3ColumnlistCount(&amp;pIter);
      if( (pPhrase-&gt;iColumn&gt;=pTab-&gt;nColumn || pPhrase-&gt;iColumn==iCol) ){
        if( p-&gt;flag==FTS3_MATCHINFO_LHITS ){
          p-&gt;aMatchinfo[iStart + iCol] = (u32)nHit;
        }else if( nHit ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -183659,10 +184981,11 @@</span>
  }
  
  /* Append N bytes from zIn onto the end of the JsonString string.
  */
  static void jsonAppendRaw(JsonString *p, const char *zIn, u32 N){
<span class="udiff-line-added">+   if( N==0 ) return;</span>
    if( (N+p-&gt;nUsed &gt;= p-&gt;nAlloc) &amp;&amp; jsonGrow(p,N)!=0 ) return;
    memcpy(p-&gt;zBuf+p-&gt;nUsed, zIn, N);
    p-&gt;nUsed += N;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -189779,12 +191102,14 @@</span>
        pRtree-&gt;nAux++;
        sqlite3_str_appendf(pSql, &quot;,%.*s&quot;, rtreeTokenLength(zArg+1), zArg+1);
      }else if( pRtree-&gt;nAux&gt;0 ){
        break;
      }else{
<span class="udiff-line-added">+       static const char *azFormat[] = {&quot;,%.*s REAL&quot;, &quot;,%.*s INT&quot;};</span>
        pRtree-&gt;nDim2++;
<span class="udiff-line-modified-removed">-       sqlite3_str_appendf(pSql, &quot;,%.*s NUM&quot;, rtreeTokenLength(zArg), zArg);</span>
<span class="udiff-line-modified-added">+       sqlite3_str_appendf(pSql, azFormat[eCoordType],</span>
<span class="udiff-line-added">+                           rtreeTokenLength(zArg), zArg);</span>
      }
    }
    sqlite3_str_appendf(pSql, &quot;);&quot;);
    zSql = sqlite3_str_finish(pSql);
    if( !zSql ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -192516,11 +193841,11 @@</span>
      **     1. uPattern is an unescaped match-all character &quot;%&quot;,
      **     2. uPattern is an unescaped match-one character &quot;_&quot;,
      **     3. uPattern is an unescaped escape character, or
      **     4. uPattern is to be handled as an ordinary character
      */
<span class="udiff-line-modified-removed">-     if( !prevEscape &amp;&amp; uPattern==MATCH_ALL ){</span>
<span class="udiff-line-modified-added">+     if( uPattern==MATCH_ALL &amp;&amp; !prevEscape &amp;&amp; uPattern!=(uint32_t)uEsc ){</span>
        /* Case 1. */
        uint8_t c;
  
        /* Skip any MATCH_ALL or MATCH_ONE characters that follow a
        ** MATCH_ALL. For each MATCH_ONE, skip one character in the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -192542,16 +193867,16 @@</span>
          }
          SQLITE_ICU_SKIP_UTF8(zString);
        }
        return 0;
  
<span class="udiff-line-modified-removed">-     }else if( !prevEscape &amp;&amp; uPattern==MATCH_ONE ){</span>
<span class="udiff-line-modified-added">+     }else if( uPattern==MATCH_ONE &amp;&amp; !prevEscape &amp;&amp; uPattern!=(uint32_t)uEsc ){</span>
        /* Case 2. */
        if( *zString==0 ) return 0;
        SQLITE_ICU_SKIP_UTF8(zString);
  
<span class="udiff-line-modified-removed">-     }else if( !prevEscape &amp;&amp; uPattern==(uint32_t)uEsc){</span>
<span class="udiff-line-modified-added">+     }else if( uPattern==(uint32_t)uEsc &amp;&amp; !prevEscape ){</span>
        /* Case 3. */
        prevEscape = 1;
  
      }else{
        /* Case 4. */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -199349,10 +200674,11 @@</span>
      }
    }
    i = 0;
    if( iSchema&gt;=0 ){
      pIdxInfo-&gt;aConstraintUsage[iSchema].argvIndex = ++i;
<span class="udiff-line-added">+     pIdxInfo-&gt;aConstraintUsage[iSchema].omit = 1;</span>
      pIdxInfo-&gt;idxNum |= 0x01;
    }
    if( iName&gt;=0 ){
      pIdxInfo-&gt;aConstraintUsage[iName].argvIndex = ++i;
      pIdxInfo-&gt;idxNum |= 0x02;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -199563,11 +200889,13 @@</span>
          assert( nPayload&gt;=(u32)nLocal );
          assert( nLocal&lt;=(nUsable-35) );
          if( nPayload&gt;(u32)nLocal ){
            int j;
            int nOvfl = ((nPayload - nLocal) + nUsable-4 - 1) / (nUsable - 4);
<span class="udiff-line-modified-removed">-           if( iOff+nLocal&gt;nUsable ) goto statPageIsCorrupt;</span>
<span class="udiff-line-modified-added">+           if( iOff+nLocal&gt;nUsable || nPayload&gt;0x7fffffff ){</span>
<span class="udiff-line-added">+             goto statPageIsCorrupt;</span>
<span class="udiff-line-added">+           }</span>
            pCell-&gt;nLastOvfl = (nPayload-nLocal) - (nOvfl-1) * (nUsable-4);
            pCell-&gt;nOvfl = nOvfl;
            pCell-&gt;aOvfl = sqlite3_malloc64(sizeof(u32)*nOvfl);
            if( pCell-&gt;aOvfl==0 ) return SQLITE_NOMEM_BKPT;
            pCell-&gt;aOvfl[0] = sqlite3Get4byte(&amp;aData[iOff+nLocal]);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -203896,11 +205224,11 @@</span>
    const char *zSep = &quot;&quot;;
    int rc = SQLITE_OK;
    SessionBuffer buf = {0, 0, 0};
    int nPk = 0;
  
<span class="udiff-line-modified-removed">-   sessionAppendStr(&amp;buf, &quot;DELETE FROM &quot;, &amp;rc);</span>
<span class="udiff-line-modified-added">+   sessionAppendStr(&amp;buf, &quot;DELETE FROM main.&quot;, &amp;rc);</span>
    sessionAppendIdent(&amp;buf, zTab, &amp;rc);
    sessionAppendStr(&amp;buf, &quot; WHERE &quot;, &amp;rc);
  
    for(i=0; i&lt;p-&gt;nCol; i++){
      if( p-&gt;abPK[i] ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -203979,11 +205307,11 @@</span>
    int i;
    const char *zSep = &quot;&quot;;
    SessionBuffer buf = {0, 0, 0};
  
    /* Append &quot;UPDATE tbl SET &quot; */
<span class="udiff-line-modified-removed">-   sessionAppendStr(&amp;buf, &quot;UPDATE &quot;, &amp;rc);</span>
<span class="udiff-line-modified-added">+   sessionAppendStr(&amp;buf, &quot;UPDATE main.&quot;, &amp;rc);</span>
    sessionAppendIdent(&amp;buf, zTab, &amp;rc);
    sessionAppendStr(&amp;buf, &quot; SET &quot;, &amp;rc);
  
    /* Append the assignments */
    for(i=0; i&lt;p-&gt;nCol; i++){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -223665,11 +224993,11 @@</span>
    int nArg,                       /* Number of args */
    sqlite3_value **apUnused        /* Function arguments */
  ){
    assert( nArg==0 );
    UNUSED_PARAM2(nArg, apUnused);
<span class="udiff-line-modified-removed">-   sqlite3_result_text(pCtx, &quot;fts5: 2020-01-27 19:55:54 3bfa9cc97da10598521b342961df8f5f68c7388fa117345eeb516eaa837bb4d6&quot;, -1, SQLITE_TRANSIENT);</span>
<span class="udiff-line-modified-added">+   sqlite3_result_text(pCtx, &quot;fts5: 2020-06-18 14:00:33 7ebdfa80be8e8e73324b8d66b3460222eb74c7e9dfd655b48d6ca7e1933cc8fd&quot;, -1, SQLITE_TRANSIENT);</span>
  }
  
  /*
  ** Return true if zName is the extension on one of the shadow tables used
  ** by this module.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -227408,10 +228736,11 @@</span>
    char *zFts5Tbl;                 /* Name of fts5 table */
    char *zFts5Db;                  /* Db containing fts5 table */
    sqlite3 *db;                    /* Database handle */
    Fts5Global *pGlobal;            /* FTS5 global object for this database */
    int eType;                      /* FTS5_VOCAB_COL, ROW or INSTANCE */
<span class="udiff-line-added">+   unsigned bBusy;                 /* True if busy */</span>
  };
  
  struct Fts5VocabCursor {
    sqlite3_vtab_cursor base;
    sqlite3_stmt *pStmt;            /* Statement holding lock on pIndex */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -227690,10 +229019,16 @@</span>
    Fts5VocabCursor *pCsr = 0;
    int rc = SQLITE_OK;
    sqlite3_stmt *pStmt = 0;
    char *zSql = 0;
  
<span class="udiff-line-added">+   if( pTab-&gt;bBusy ){</span>
<span class="udiff-line-added">+     pVTab-&gt;zErrMsg = sqlite3_mprintf(</span>
<span class="udiff-line-added">+        &quot;recursive definition for %s.%s&quot;, pTab-&gt;zFts5Db, pTab-&gt;zFts5Tbl</span>
<span class="udiff-line-added">+     );</span>
<span class="udiff-line-added">+     return SQLITE_ERROR;</span>
<span class="udiff-line-added">+   }</span>
    zSql = sqlite3Fts5Mprintf(&amp;rc,
        &quot;SELECT t.%Q FROM %Q.%Q AS t WHERE t.%Q MATCH &#39;*id&#39;&quot;,
        pTab-&gt;zFts5Tbl, pTab-&gt;zFts5Db, pTab-&gt;zFts5Tbl, pTab-&gt;zFts5Tbl
    );
    if( zSql ){
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -227701,14 +229036,16 @@</span>
    }
    sqlite3_free(zSql);
    assert( rc==SQLITE_OK || pStmt==0 );
    if( rc==SQLITE_ERROR ) rc = SQLITE_OK;
  
<span class="udiff-line-added">+   pTab-&gt;bBusy = 1;</span>
    if( pStmt &amp;&amp; sqlite3_step(pStmt)==SQLITE_ROW ){
      i64 iId = sqlite3_column_int64(pStmt, 0);
      pFts5 = sqlite3Fts5TableFromCsrid(pTab-&gt;pGlobal, iId);
    }
<span class="udiff-line-added">+   pTab-&gt;bBusy = 0;</span>
  
    if( rc==SQLITE_OK ){
      if( pFts5==0 ){
        rc = sqlite3_finalize(pStmt);
        pStmt = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -228307,11 +229644,12 @@</span>
      }
      case STMT_COLUMN_BUSY: {
        sqlite3_result_int(ctx, sqlite3_stmt_busy(pCur-&gt;pStmt));
        break;
      }
<span class="udiff-line-modified-removed">-     case STMT_COLUMN_MEM: {</span>
<span class="udiff-line-modified-added">+     default: {</span>
<span class="udiff-line-added">+       assert( i==STMT_COLUMN_MEM );</span>
        i = SQLITE_STMTSTATUS_MEMUSED +
              STMT_COLUMN_NSCAN - SQLITE_STMTSTATUS_FULLSCAN_STEP;
        /* Fall thru */
      }
      case STMT_COLUMN_NSCAN:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -228438,12 +229776,12 @@</span>
  }
  #endif /* SQLITE_CORE */
  #endif /* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_STMTVTAB) */
  
  /************** End of stmt.c ************************************************/
<span class="udiff-line-modified-removed">- #if __LINE__!=228443</span>
<span class="udiff-line-modified-added">+ #if __LINE__!=229781</span>
  #undef SQLITE_SOURCE_ID
<span class="udiff-line-modified-removed">- #define SQLITE_SOURCE_ID      &quot;2020-01-27 19:55:54 3bfa9cc97da10598521b342961df8f5f68c7388fa117345eeb516eaa837balt2&quot;</span>
<span class="udiff-line-modified-added">+ #define SQLITE_SOURCE_ID      &quot;2020-06-18 14:00:33 7ebdfa80be8e8e73324b8d66b3460222eb74c7e9dfd655b48d6ca7e1933calt2&quot;</span>
  #endif
  /* Return the source-id for this library */
  SQLITE_API const char *sqlite3_sourceid(void){ return SQLITE_SOURCE_ID; }
  /************************** End of sqlite3.c ******************************/
</pre>
<center><a href="VERSION.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="sqlite3.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
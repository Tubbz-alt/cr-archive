<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.graphics/src/main/java/com/sun/openpisces/Helpers.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.openpisces;
 27 
 28 import java.util.Arrays;
 29 import static java.lang.Math.PI;
 30 import static java.lang.Math.cos;
 31 import static java.lang.Math.sqrt;
 32 import static java.lang.Math.cbrt;
 33 import static java.lang.Math.acos;
 34 
 35 
 36 final class Helpers {
 37     private Helpers() {
 38         throw new Error(&quot;This is a non instantiable class&quot;);
 39     }
 40 
 41     static boolean within(final float x, final float y, final float err) {
 42         final float d = y - x;
 43         return (d &lt;= err &amp;&amp; d &gt;= -err);
 44     }
 45 
 46     static boolean within(final double x, final double y, final double err) {
 47         final double d = y - x;
 48         return (d &lt;= err &amp;&amp; d &gt;= -err);
 49     }
 50 
 51     static int quadraticRoots(final float a, final float b,
 52                               final float c, float[] zeroes, final int off)
 53     {
 54         int ret = off;
 55         float t;
 56         if (a != 0f) {
 57             final float dis = b*b - 4*a*c;
 58             if (dis &gt; 0) {
 59                 final float sqrtDis = (float)Math.sqrt(dis);
 60                 // depending on the sign of b we use a slightly different
 61                 // algorithm than the traditional one to find one of the roots
 62                 // so we can avoid adding numbers of different signs (which
 63                 // might result in loss of precision).
 64                 if (b &gt;= 0) {
 65                     zeroes[ret++] = (2 * c) / (-b - sqrtDis);
 66                     zeroes[ret++] = (-b - sqrtDis) / (2 * a);
 67                 } else {
 68                     zeroes[ret++] = (-b + sqrtDis) / (2 * a);
 69                     zeroes[ret++] = (2 * c) / (-b + sqrtDis);
 70                 }
 71             } else if (dis == 0f) {
 72                 t = (-b) / (2 * a);
 73                 zeroes[ret++] = t;
 74             }
 75         } else {
 76             if (b != 0f) {
 77                 t = (-c) / b;
 78                 zeroes[ret++] = t;
 79             }
 80         }
 81         return ret - off;
 82     }
 83 
 84     // find the roots of g(t) = d*t^3 + a*t^2 + b*t + c in [A,B)
 85     static int cubicRootsInAB(float d, float a, float b, float c,
 86                               float[] pts, final int off,
 87                               final float A, final float B)
 88     {
 89         if (d == 0) {
 90             int num = quadraticRoots(a, b, c, pts, off);
 91             return filterOutNotInAB(pts, off, num, A, B) - off;
 92         }
 93         // From Graphics Gems:
 94         // http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c
 95         // (also from awt.geom.CubicCurve2D. But here we don&#39;t need as
 96         // much accuracy and we don&#39;t want to create arrays so we use
 97         // our own customized version).
 98 
 99         /* normal form: x^3 + ax^2 + bx + c = 0 */
100         a /= d;
101         b /= d;
102         c /= d;
103 
104         //  substitute x = y - A/3 to eliminate quadratic term:
105         //     x^3 +Px + Q = 0
106         //
107         // Since we actually need P/3 and Q/2 for all of the
108         // calculations that follow, we will calculate
109         // p = P/3
110         // q = Q/2
111         // instead and use those values for simplicity of the code.
112         double sq_A = a * a;
113         double p = 1.0/3 * (-1.0/3 * sq_A + b);
114         double q = 1.0/2 * (2.0/27 * a * sq_A - 1.0/3 * a * b + c);
115 
116         /* use Cardano&#39;s formula */
117 
118         double cb_p = p * p * p;
119         double D = q * q + cb_p;
120 
121         int num;
122         if (D &lt; 0) {
123             // see: http://en.wikipedia.org/wiki/Cubic_function#Trigonometric_.28and_hyperbolic.29_method
124             final double phi = 1.0/3 * acos(-q / sqrt(-cb_p));
125             final double t = 2 * sqrt(-p);
126 
127             pts[ off+0 ] =  (float)( t * cos(phi));
128             pts[ off+1 ] =  (float)(-t * cos(phi + PI / 3));
129             pts[ off+2 ] =  (float)(-t * cos(phi - PI / 3));
130             num = 3;
131         } else {
132             final double sqrt_D = sqrt(D);
133             final double u = cbrt(sqrt_D - q);
134             final double v = - cbrt(sqrt_D + q);
135 
136             pts[ off ] = (float)(u + v);
137             num = 1;
138 
139             if (within(D, 0, 1e-8)) {
140                 pts[off+1] = -(pts[off] / 2);
141                 num = 2;
142             }
143         }
144 
145         final float sub = 1.0f/3 * a;
146 
147         for (int i = 0; i &lt; num; ++i) {
148             pts[ off+i ] -= sub;
149         }
150 
151         return filterOutNotInAB(pts, off, num, A, B) - off;
152     }
153 
154     // These use a hardcoded factor of 2 for increasing sizes. Perhaps this
155     // should be provided as an argument.
156     static float[] widenArray(float[] in, final int cursize, final int numToAdd) {
157         if (in.length &gt;= cursize + numToAdd) {
158             return in;
159         }
160         return Arrays.copyOf(in, 2 * (cursize + numToAdd));
161     }
162 
163     static int[] widenArray(int[] in, final int cursize, final int numToAdd) {
164         if (in.length &gt;= cursize + numToAdd) {
165             return in;
166         }
167         return Arrays.copyOf(in, 2 * (cursize + numToAdd));
168     }
169 
170     static float evalCubic(final float a, final float b,
171                            final float c, final float d,
172                            final float t)
173     {
174         return t * (t * (t * a + b) + c) + d;
175     }
176 
177     static float evalQuad(final float a, final float b,
178                           final float c, final float t)
179     {
180         return t * (t * a + b) + c;
181     }
182 
183     // returns the index 1 past the last valid element remaining after filtering
184     static int filterOutNotInAB(float[] nums, final int off, final int len,
185                                 final float a, final float b)
186     {
187         int ret = off;
188         for (int i = off; i &lt; off + len; i++) {
189             if (nums[i] &gt;= a &amp;&amp; nums[i] &lt; b) {
190                 nums[ret++] = nums[i];
191             }
192         }
193         return ret;
194     }
195 
196     static float polyLineLength(float[] poly, final int off, final int nCoords) {
197         assert nCoords % 2 == 0 &amp;&amp; poly.length &gt;= off + nCoords : &quot;&quot;;
198         float acc = 0;
199         for (int i = off + 2; i &lt; off + nCoords; i += 2) {
200             acc += linelen(poly[i], poly[i+1], poly[i-2], poly[i-1]);
201         }
202         return acc;
203     }
204 
205     static float linelen(float x1, float y1, float x2, float y2) {
206         final float dx = x2 - x1;
207         final float dy = y2 - y1;
208         return (float)Math.sqrt(dx*dx + dy*dy);
209     }
210 
211     static void subdivide(float[] src, int srcoff, float[] left, int leftoff,
212                           float[] right, int rightoff, int type)
213     {
214         switch(type) {
215         case 6:
216             Helpers.subdivideQuad(src, srcoff, left, leftoff, right, rightoff);
217             break;
218         case 8:
219             Helpers.subdivideCubic(src, srcoff, left, leftoff, right, rightoff);
220             break;
221         default:
222             throw new InternalError(&quot;Unsupported curve type&quot;);
223         }
224     }
225 
226     static void isort(float[] a, int off, int len) {
227         for (int i = off + 1; i &lt; off + len; i++) {
228             float ai = a[i];
229             int j = i - 1;
230             for (; j &gt;= off &amp;&amp; a[j] &gt; ai; j--) {
231                 a[j+1] = a[j];
232             }
233             a[j+1] = ai;
234         }
235     }
236 
237     // Most of these are copied from classes in java.awt.geom because we need
238     // float versions of these functions, and Line2D, CubicCurve2D,
239     // QuadCurve2D don&#39;t provide them.
240     /**
241      * Subdivides the cubic curve specified by the coordinates
242      * stored in the &lt;code&gt;src&lt;/code&gt; array at indices &lt;code&gt;srcoff&lt;/code&gt;
243      * through (&lt;code&gt;srcoff&lt;/code&gt;&amp;nbsp;+&amp;nbsp;7) and stores the
244      * resulting two subdivided curves into the two result arrays at the
245      * corresponding indices.
246      * Either or both of the &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt;
247      * arrays may be &lt;code&gt;null&lt;/code&gt; or a reference to the same array
248      * as the &lt;code&gt;src&lt;/code&gt; array.
249      * Note that the last point in the first subdivided curve is the
250      * same as the first point in the second subdivided curve. Thus,
251      * it is possible to pass the same array for &lt;code&gt;left&lt;/code&gt;
252      * and &lt;code&gt;right&lt;/code&gt; and to use offsets, such as &lt;code&gt;rightoff&lt;/code&gt;
253      * equals (&lt;code&gt;leftoff&lt;/code&gt; + 6), in order
254      * to avoid allocating extra storage for this common point.
255      * @param src the array holding the coordinates for the source curve
256      * @param srcoff the offset into the array of the beginning of the
257      * the 6 source coordinates
258      * @param left the array for storing the coordinates for the first
259      * half of the subdivided curve
260      * @param leftoff the offset into the array of the beginning of the
261      * the 6 left coordinates
262      * @param right the array for storing the coordinates for the second
263      * half of the subdivided curve
264      * @param rightoff the offset into the array of the beginning of the
265      * the 6 right coordinates
266      */
267     static void subdivideCubic(float src[], int srcoff,
268                                float left[], int leftoff,
269                                float right[], int rightoff)
270     {
271         float x1 = src[srcoff + 0];
272         float y1 = src[srcoff + 1];
273         float ctrlx1 = src[srcoff + 2];
274         float ctrly1 = src[srcoff + 3];
275         float ctrlx2 = src[srcoff + 4];
276         float ctrly2 = src[srcoff + 5];
277         float x2 = src[srcoff + 6];
278         float y2 = src[srcoff + 7];
279         if (left != null) {
280             left[leftoff + 0] = x1;
281             left[leftoff + 1] = y1;
282         }
283         if (right != null) {
284             right[rightoff + 6] = x2;
285             right[rightoff + 7] = y2;
286         }
287         x1 = (x1 + ctrlx1) / 2.0f;
288         y1 = (y1 + ctrly1) / 2.0f;
289         x2 = (x2 + ctrlx2) / 2.0f;
290         y2 = (y2 + ctrly2) / 2.0f;
291         float centerx = (ctrlx1 + ctrlx2) / 2.0f;
292         float centery = (ctrly1 + ctrly2) / 2.0f;
293         ctrlx1 = (x1 + centerx) / 2.0f;
294         ctrly1 = (y1 + centery) / 2.0f;
295         ctrlx2 = (x2 + centerx) / 2.0f;
296         ctrly2 = (y2 + centery) / 2.0f;
297         centerx = (ctrlx1 + ctrlx2) / 2.0f;
298         centery = (ctrly1 + ctrly2) / 2.0f;
299         if (left != null) {
300             left[leftoff + 2] = x1;
301             left[leftoff + 3] = y1;
302             left[leftoff + 4] = ctrlx1;
303             left[leftoff + 5] = ctrly1;
304             left[leftoff + 6] = centerx;
305             left[leftoff + 7] = centery;
306         }
307         if (right != null) {
308             right[rightoff + 0] = centerx;
309             right[rightoff + 1] = centery;
310             right[rightoff + 2] = ctrlx2;
311             right[rightoff + 3] = ctrly2;
312             right[rightoff + 4] = x2;
313             right[rightoff + 5] = y2;
314         }
315     }
316 
317 
318     static void subdivideCubicAt(float t, float src[], int srcoff,
319                                  float left[], int leftoff,
320                                  float right[], int rightoff)
321     {
322         float x1 = src[srcoff + 0];
323         float y1 = src[srcoff + 1];
324         float ctrlx1 = src[srcoff + 2];
325         float ctrly1 = src[srcoff + 3];
326         float ctrlx2 = src[srcoff + 4];
327         float ctrly2 = src[srcoff + 5];
328         float x2 = src[srcoff + 6];
329         float y2 = src[srcoff + 7];
330         if (left != null) {
331             left[leftoff + 0] = x1;
332             left[leftoff + 1] = y1;
333         }
334         if (right != null) {
335             right[rightoff + 6] = x2;
336             right[rightoff + 7] = y2;
337         }
338         x1 = x1 + t * (ctrlx1 - x1);
339         y1 = y1 + t * (ctrly1 - y1);
340         x2 = ctrlx2 + t * (x2 - ctrlx2);
341         y2 = ctrly2 + t * (y2 - ctrly2);
342         float centerx = ctrlx1 + t * (ctrlx2 - ctrlx1);
343         float centery = ctrly1 + t * (ctrly2 - ctrly1);
344         ctrlx1 = x1 + t * (centerx - x1);
345         ctrly1 = y1 + t * (centery - y1);
346         ctrlx2 = centerx + t * (x2 - centerx);
347         ctrly2 = centery + t * (y2 - centery);
348         centerx = ctrlx1 + t * (ctrlx2 - ctrlx1);
349         centery = ctrly1 + t * (ctrly2 - ctrly1);
350         if (left != null) {
351             left[leftoff + 2] = x1;
352             left[leftoff + 3] = y1;
353             left[leftoff + 4] = ctrlx1;
354             left[leftoff + 5] = ctrly1;
355             left[leftoff + 6] = centerx;
356             left[leftoff + 7] = centery;
357         }
358         if (right != null) {
359             right[rightoff + 0] = centerx;
360             right[rightoff + 1] = centery;
361             right[rightoff + 2] = ctrlx2;
362             right[rightoff + 3] = ctrly2;
363             right[rightoff + 4] = x2;
364             right[rightoff + 5] = y2;
365         }
366     }
367 
368     static void subdivideQuad(float src[], int srcoff,
369                               float left[], int leftoff,
370                               float right[], int rightoff)
371     {
372         float x1 = src[srcoff + 0];
373         float y1 = src[srcoff + 1];
374         float ctrlx = src[srcoff + 2];
375         float ctrly = src[srcoff + 3];
376         float x2 = src[srcoff + 4];
377         float y2 = src[srcoff + 5];
378         if (left != null) {
379             left[leftoff + 0] = x1;
380             left[leftoff + 1] = y1;
381         }
382         if (right != null) {
383             right[rightoff + 4] = x2;
384             right[rightoff + 5] = y2;
385         }
386         x1 = (x1 + ctrlx) / 2.0f;
387         y1 = (y1 + ctrly) / 2.0f;
388         x2 = (x2 + ctrlx) / 2.0f;
389         y2 = (y2 + ctrly) / 2.0f;
390         ctrlx = (x1 + x2) / 2.0f;
391         ctrly = (y1 + y2) / 2.0f;
392         if (left != null) {
393             left[leftoff + 2] = x1;
394             left[leftoff + 3] = y1;
395             left[leftoff + 4] = ctrlx;
396             left[leftoff + 5] = ctrly;
397         }
398         if (right != null) {
399             right[rightoff + 0] = ctrlx;
400             right[rightoff + 1] = ctrly;
401             right[rightoff + 2] = x2;
402             right[rightoff + 3] = y2;
403         }
404     }
405 
406     static void subdivideQuadAt(float t, float src[], int srcoff,
407                                 float left[], int leftoff,
408                                 float right[], int rightoff)
409     {
410         float x1 = src[srcoff + 0];
411         float y1 = src[srcoff + 1];
412         float ctrlx = src[srcoff + 2];
413         float ctrly = src[srcoff + 3];
414         float x2 = src[srcoff + 4];
415         float y2 = src[srcoff + 5];
416         if (left != null) {
417             left[leftoff + 0] = x1;
418             left[leftoff + 1] = y1;
419         }
420         if (right != null) {
421             right[rightoff + 4] = x2;
422             right[rightoff + 5] = y2;
423         }
424         x1 = x1 + t * (ctrlx - x1);
425         y1 = y1 + t * (ctrly - y1);
426         x2 = ctrlx + t * (x2 - ctrlx);
427         y2 = ctrly + t * (y2 - ctrly);
428         ctrlx = x1 + t * (x2 - x1);
429         ctrly = y1 + t * (y2 - y1);
430         if (left != null) {
431             left[leftoff + 2] = x1;
432             left[leftoff + 3] = y1;
433             left[leftoff + 4] = ctrlx;
434             left[leftoff + 5] = ctrly;
435         }
436         if (right != null) {
437             right[rightoff + 0] = ctrlx;
438             right[rightoff + 1] = ctrly;
439             right[rightoff + 2] = x2;
440             right[rightoff + 3] = y2;
441         }
442     }
443 
444     static void subdivideAt(float t, float src[], int srcoff,
445                             float left[], int leftoff,
446                             float right[], int rightoff, int size)
447     {
448         switch(size) {
449         case 8:
450             subdivideCubicAt(t, src, srcoff, left, leftoff, right, rightoff);
451             break;
452         case 6:
453             subdivideQuadAt(t, src, srcoff, left, leftoff, right, rightoff);
454             break;
455         }
456     }
457 }
    </pre>
  </body>
</html>
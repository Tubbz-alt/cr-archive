<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.graphics/src/main/java/com/sun/prism/impl/shape/OpenPiscesPrismUtils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.prism.impl.shape;
 27 
 28 
 29 import com.sun.javafx.geom.PathConsumer2D;
 30 import com.sun.javafx.geom.PathIterator;
 31 import com.sun.javafx.geom.Path2D;
 32 import com.sun.javafx.geom.Rectangle;
 33 import com.sun.javafx.geom.Shape;
 34 import com.sun.javafx.geom.transform.BaseTransform;
 35 import com.sun.openpisces.Dasher;
 36 import com.sun.openpisces.Renderer;
 37 import com.sun.openpisces.Stroker;
 38 import com.sun.openpisces.TransformingPathConsumer2D;
 39 import com.sun.prism.BasicStroke;
 40 
 41 public class OpenPiscesPrismUtils {
 42     private static final Renderer savedAARenderer = new Renderer(3, 3);
 43     private static final Renderer savedRenderer = new Renderer(0, 0);
 44     private static final Stroker savedStroker = new Stroker(savedRenderer);
 45     private static final Dasher savedDasher = new Dasher(savedStroker);
 46 
 47     private static TransformingPathConsumer2D.FilterSet transformer =
 48         new TransformingPathConsumer2D.FilterSet();
 49 
 50     private static PathConsumer2D initRenderer(BasicStroke stroke,
 51                                                BaseTransform tx,
 52                                                Rectangle clip,
 53                                                int pirule,
 54                                                Renderer renderer)
 55     {
 56         int oprule = (stroke == null &amp;&amp; pirule == PathIterator.WIND_EVEN_ODD) ?
 57             Renderer.WIND_EVEN_ODD : Renderer.WIND_NON_ZERO;
 58         renderer.reset(clip.x, clip.y, clip.width, clip.height, oprule);
 59         PathConsumer2D ret = transformer.getConsumer(renderer, tx);
 60         if (stroke != null) {
 61             savedStroker.reset(stroke.getLineWidth(), stroke.getEndCap(),
 62                                stroke.getLineJoin(), stroke.getMiterLimit());
 63             savedStroker.setConsumer(ret);
 64             ret = savedStroker;
 65             float dashes[] = stroke.getDashArray();
 66             if (dashes != null) {
 67                 savedDasher.reset(dashes, stroke.getDashPhase());
 68                 ret = savedDasher;
 69             }
 70         }
 71         return ret;
 72     }
 73 
 74     public static void feedConsumer(PathIterator pi, PathConsumer2D pc) {
 75         float[] coords = new float[6];
 76         while (!pi.isDone()) {
 77             int type = pi.currentSegment(coords);
 78             switch (type) {
 79                 case PathIterator.SEG_MOVETO:
 80                     pc.moveTo(coords[0], coords[1]);
 81                     break;
 82                 case PathIterator.SEG_LINETO:
 83                     pc.lineTo(coords[0], coords[1]);
 84                     break;
 85                 case PathIterator.SEG_QUADTO:
 86                     pc.quadTo(coords[0], coords[1],
 87                               coords[2], coords[3]);
 88                     break;
 89                 case PathIterator.SEG_CUBICTO:
 90                     pc.curveTo(coords[0], coords[1],
 91                                coords[2], coords[3],
 92                                coords[4], coords[5]);
 93                     break;
 94                 case PathIterator.SEG_CLOSE:
 95                     pc.closePath();
 96                     break;
 97             }
 98             pi.next();
 99         }
100         pc.pathDone();
101     }
102 
103     public static Renderer setupRenderer(Shape shape,
104                                   BasicStroke stroke,
105                                   BaseTransform xform,
106                                   Rectangle rclip,
107                                   boolean antialiasedShape)
108     {
109         PathIterator pi = shape.getPathIterator(null);
110         Renderer r = antialiasedShape ? savedAARenderer : savedRenderer;
111         feedConsumer(pi, initRenderer(stroke, xform, rclip, pi.getWindingRule(), r));
112         return r;
113     }
114 
115     public static Renderer setupRenderer(Path2D p2d,
116                                   BasicStroke stroke,
117                                   BaseTransform xform,
118                                   Rectangle rclip,
119                                   boolean antialiasedShape)
120     {
121         Renderer r = antialiasedShape ? savedAARenderer : savedRenderer;
122         PathConsumer2D pc2d = initRenderer(stroke, xform, rclip, p2d.getWindingRule(), r);
123 
124         float coords[] = p2d.getFloatCoordsNoClone();
125         byte types[] = p2d.getCommandsNoClone();
126         int nsegs = p2d.getNumCommands();
127         int coff = 0;
128         for (int i = 0; i &lt; nsegs; i++) {
129             switch (types[i]) {
130                 case PathIterator.SEG_MOVETO:
131                     pc2d.moveTo(coords[coff+0], coords[coff+1]);
132                     coff += 2;
133                     break;
134                 case PathIterator.SEG_LINETO:
135                     pc2d.lineTo(coords[coff+0], coords[coff+1]);
136                     coff += 2;
137                     break;
138                 case PathIterator.SEG_QUADTO:
139                     pc2d.quadTo(coords[coff+0], coords[coff+1],
140                                 coords[coff+2], coords[coff+3]);
141                     coff += 4;
142                     break;
143                 case PathIterator.SEG_CUBICTO:
144                     pc2d.curveTo(coords[coff+0], coords[coff+1],
145                                  coords[coff+2], coords[coff+3],
146                                  coords[coff+4], coords[coff+5]);
147                     coff += 6;
148                     break;
149                 case PathIterator.SEG_CLOSE:
150                     pc2d.closePath();
151                     break;
152             }
153         }
154         pc2d.pathDone();
155         return r;
156     }
157 }
    </pre>
  </body>
</html>
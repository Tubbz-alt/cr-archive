<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.graphics/src/main/java/com/sun/openpisces/TransformingPathConsumer2D.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.openpisces;
 27 
 28 import com.sun.javafx.geom.PathConsumer2D;
 29 import com.sun.javafx.geom.transform.BaseTransform;
 30 
 31 public abstract class TransformingPathConsumer2D implements PathConsumer2D {
 32     protected PathConsumer2D out;
 33 
 34     public TransformingPathConsumer2D(PathConsumer2D out) {
 35         this.out = out;
 36     }
 37 
 38     public void setConsumer(PathConsumer2D out) {
 39         this.out = out;
 40     }
 41 /*
 42     public static PathConsumer2D
 43         transformConsumer(PathConsumer2D out,
 44                           AffineTransform at)
 45     {
 46         if (at == null) {
 47             return out;
 48         }
 49         float Mxx = (float) at.getScaleX();
 50         float Mxy = (float) at.getShearX();
 51         float Mxt = (float) at.getTranslateX();
 52         float Myx = (float) at.getShearY();
 53         float Myy = (float) at.getScaleY();
 54         float Myt = (float) at.getTranslateY();
 55         if (Mxy == 0f &amp;&amp; Myx == 0f) {
 56             if (Mxx == 1f &amp;&amp; Myy == 1f) {
 57                 if (Mxt == 0f &amp;&amp; Myt == 0f) {
 58                     return out;
 59                 } else {
 60                     return new TranslateFilter(out, Mxt, Myt);
 61                 }
 62             } else {
 63                 if (Mxt == 0f &amp;&amp; Myt == 0f) {
 64                     return new DeltaScaleFilter(out, Mxx, Myy);
 65                 } else {
 66                     return new ScaleTranslateFilter(out, Mxx, Myy, Mxt, Myt);
 67                 }
 68             }
 69         } else if (Mxt == 0f &amp;&amp; Myt == 0f) {
 70             return new DeltaTransformFilter(out, Mxx, Mxy, Myx, Myy);
 71         } else {
 72             return new TransformFilter(out, Mxx, Mxy, Mxt, Myx, Myy, Myt);
 73         }
 74     }
 75 
 76     public static PathConsumer2D
 77         deltaTransformConsumer(PathConsumer2D out,
 78                                AffineTransform at)
 79     {
 80         if (at == null) {
 81             return out;
 82         }
 83         float Mxx = (float) at.getScaleX();
 84         float Mxy = (float) at.getShearX();
 85         float Myx = (float) at.getShearY();
 86         float Myy = (float) at.getScaleY();
 87         if (Mxy == 0f &amp;&amp; Myx == 0f) {
 88             if (Mxx == 1f &amp;&amp; Myy == 1f) {
 89                 return out;
 90             } else {
 91                 return new DeltaScaleFilter(out, Mxx, Myy);
 92             }
 93         } else {
 94             return new DeltaTransformFilter(out, Mxx, Mxy, Myx, Myy);
 95         }
 96     }
 97 
 98     public static PathConsumer2D
 99         inverseDeltaTransformConsumer(PathConsumer2D out,
100                                       AffineTransform at)
101     {
102         if (at == null) {
103             return out;
104         }
105         float Mxx = (float) at.getScaleX();
106         float Mxy = (float) at.getShearX();
107         float Myx = (float) at.getShearY();
108         float Myy = (float) at.getScaleY();
109         if (Mxy == 0f &amp;&amp; Myx == 0f) {
110             if (Mxx == 1f &amp;&amp; Myy == 1f) {
111                 return out;
112             } else {
113                 return new DeltaScaleFilter(out, 1.0f/Mxx, 1.0f/Myy);
114             }
115         } else {
116             float det = Mxx * Myy - Mxy * Myx;
117             return new DeltaTransformFilter(out,
118                                             Myy / det,
119                                             -Mxy / det,
120                                             -Myx / det,
121                                             Mxx / det);
122         }
123     }
124 */
125 
126     public static final class FilterSet {
127         private TranslateFilter translater;
128         private DeltaScaleFilter deltascaler;
129         private ScaleTranslateFilter scaletranslater;
130         private DeltaTransformFilter deltatransformer;
131         private TransformFilter transformer;
132 
133         public FilterSet() {
134         }
135 
136         public PathConsumer2D getConsumer(PathConsumer2D out,
137                                           BaseTransform tx)
138         {
139             if (tx == null) {
140                 return out;
141             }
142             float Mxx = (float) tx.getMxx();
143             float Mxy = (float) tx.getMxy();
144             float Mxt = (float) tx.getMxt();
145             float Myx = (float) tx.getMyx();
146             float Myy = (float) tx.getMyy();
147             float Myt = (float) tx.getMyt();
148             if (Mxy == 0f &amp;&amp; Myx == 0f) {
149                 if (Mxx == 1f &amp;&amp; Myy == 1f) {
150                     if (Mxt == 0f &amp;&amp; Myt == 0f) {
151                         return out;
152                     } else {
153                         if (translater == null) {
154                             translater = new TranslateFilter(out, Mxt, Myt);
155                         } else {
156                             translater.set(Mxt, Myt);
157                         }
158                         return translater;
159                     }
160                 } else {
161                     if (Mxt == 0f &amp;&amp; Myt == 0f) {
162                         if (deltascaler == null) {
163                             deltascaler = new DeltaScaleFilter(out, Mxx, Myy);
164                         } else {
165                             deltascaler.set(Mxx, Myy);
166                         }
167                         return deltascaler;
168                     } else {
169                         if (scaletranslater == null) {
170                             scaletranslater =
171                                 new ScaleTranslateFilter(out, Mxx, Myy, Mxt, Myt);
172                         } else {
173                             scaletranslater.set(Mxx, Myy, Mxt, Myt);
174                         }
175                         return scaletranslater;
176                     }
177                 }
178             } else if (Mxt == 0f &amp;&amp; Myt == 0f) {
179                 if (deltatransformer == null) {
180                     deltatransformer =
181                         new DeltaTransformFilter(out, Mxx, Mxy, Myx, Myy);
182                 } else {
183                     deltatransformer.set(Mxx, Mxy, Myx, Myy);
184                 }
185                 return deltatransformer;
186             } else {
187                 if (transformer == null) {
188                     transformer =
189                         new TransformFilter(out, Mxx, Mxy, Mxt, Myx, Myy, Myt);
190                 } else {
191                     transformer.set(Mxx, Mxy, Mxt, Myx, Myy, Myt);
192                 }
193                 return transformer;
194             }
195         }
196     }
197 
198     static final class TranslateFilter extends TransformingPathConsumer2D {
199         private float tx;
200         private float ty;
201 
202         TranslateFilter(PathConsumer2D out,
203                         float tx, float ty)
204         {
205             super(out);
206             set(tx, ty);
207         }
208 
209         public void set(float tx, float ty) {
210             this.tx = tx;
211             this.ty = ty;
212         }
213 
214         public void moveTo(float x0, float y0) {
215             out.moveTo(x0 + tx, y0 + ty);
216         }
217 
218         public void lineTo(float x1, float y1) {
219             out.lineTo(x1 + tx, y1 + ty);
220         }
221 
222         public void quadTo(float x1, float y1,
223                            float x2, float y2)
224         {
225             out.quadTo(x1 + tx, y1 + ty,
226                        x2 + tx, y2 + ty);
227         }
228 
229         public void curveTo(float x1, float y1,
230                             float x2, float y2,
231                             float x3, float y3)
232         {
233             out.curveTo(x1 + tx, y1 + ty,
234                         x2 + tx, y2 + ty,
235                         x3 + tx, y3 + ty);
236         }
237 
238         public void closePath() {
239             out.closePath();
240         }
241 
242         public void pathDone() {
243             out.pathDone();
244         }
245 
246         public long getNativeConsumer() {
247             return 0;
248         }
249     }
250 
251     static final class ScaleTranslateFilter extends TransformingPathConsumer2D {
252         private float sx;
253         private float sy;
254         private float tx;
255         private float ty;
256 
257         ScaleTranslateFilter(PathConsumer2D out,
258                     float sx, float sy, float tx, float ty)
259         {
260             super(out);
261             set(sx, sy, tx, ty);
262         }
263 
264         public void set(float sx, float sy, float tx, float ty) {
265             this.sx = sx;
266             this.sy = sy;
267             this.tx = tx;
268             this.ty = ty;
269         }
270 
271         public void moveTo(float x0, float y0) {
272             out.moveTo(x0 * sx + tx, y0 * sy + ty);
273         }
274 
275         public void lineTo(float x1, float y1) {
276             out.lineTo(x1 * sx + tx, y1 * sy + ty);
277         }
278 
279         public void quadTo(float x1, float y1,
280                            float x2, float y2)
281         {
282             out.quadTo(x1 * sx + tx, y1 * sy + ty,
283                        x2 * sx + tx, y2 * sy + ty);
284         }
285 
286         public void curveTo(float x1, float y1,
287                             float x2, float y2,
288                             float x3, float y3)
289         {
290             out.curveTo(x1 * sx + tx, y1 * sy + ty,
291                         x2 * sx + tx, y2 * sy + ty,
292                         x3 * sx + tx, y3 * sy + ty);
293         }
294 
295         public void closePath() {
296             out.closePath();
297         }
298 
299         public void pathDone() {
300             out.pathDone();
301         }
302 
303         public long getNativeConsumer() {
304             return 0;
305         }
306     }
307 
308     static final class TransformFilter extends TransformingPathConsumer2D {
309         private float Mxx;
310         private float Mxy;
311         private float Mxt;
312         private float Myx;
313         private float Myy;
314         private float Myt;
315 
316         TransformFilter(PathConsumer2D out,
317                         float Mxx, float Mxy, float Mxt,
318                         float Myx, float Myy, float Myt)
319         {
320             super(out);
321             set(Mxx, Mxy, Mxt, Myx, Myy, Myt);
322         }
323 
324         public void set(float Mxx, float Mxy, float Mxt,
325                         float Myx, float Myy, float Myt)
326         {
327             this.Mxx = Mxx;
328             this.Mxy = Mxy;
329             this.Mxt = Mxt;
330             this.Myx = Myx;
331             this.Myy = Myy;
332             this.Myt = Myt;
333         }
334 
335         public void moveTo(float x0, float y0) {
336             out.moveTo(x0 * Mxx + y0 * Mxy + Mxt,
337                        x0 * Myx + y0 * Myy + Myt);
338         }
339 
340         public void lineTo(float x1, float y1) {
341             out.lineTo(x1 * Mxx + y1 * Mxy + Mxt,
342                        x1 * Myx + y1 * Myy + Myt);
343         }
344 
345         public void quadTo(float x1, float y1,
346                            float x2, float y2)
347         {
348             out.quadTo(x1 * Mxx + y1 * Mxy + Mxt,
349                        x1 * Myx + y1 * Myy + Myt,
350                        x2 * Mxx + y2 * Mxy + Mxt,
351                        x2 * Myx + y2 * Myy + Myt);
352         }
353 
354         public void curveTo(float x1, float y1,
355                             float x2, float y2,
356                             float x3, float y3)
357         {
358             out.curveTo(x1 * Mxx + y1 * Mxy + Mxt,
359                         x1 * Myx + y1 * Myy + Myt,
360                         x2 * Mxx + y2 * Mxy + Mxt,
361                         x2 * Myx + y2 * Myy + Myt,
362                         x3 * Mxx + y3 * Mxy + Mxt,
363                         x3 * Myx + y3 * Myy + Myt);
364         }
365 
366         public void closePath() {
367             out.closePath();
368         }
369 
370         public void pathDone() {
371             out.pathDone();
372         }
373 
374         public long getNativeConsumer() {
375             return 0;
376         }
377     }
378 
379     static final class DeltaScaleFilter extends TransformingPathConsumer2D {
380         private float sx;
381         private float sy;
382 
383         public DeltaScaleFilter(PathConsumer2D out, float Mxx, float Myy) {
384             super(out);
385             set(Mxx, Myy);
386         }
387 
388         public void set(float Mxx, float Myy) {
389             sx = Mxx;
390             sy = Myy;
391         }
392 
393         public void moveTo(float x0, float y0) {
394             out.moveTo(x0 * sx, y0 * sy);
395         }
396 
397         public void lineTo(float x1, float y1) {
398             out.lineTo(x1 * sx, y1 * sy);
399         }
400 
401         public void quadTo(float x1, float y1,
402                            float x2, float y2)
403         {
404             out.quadTo(x1 * sx, y1 * sy,
405                        x2 * sx, y2 * sy);
406         }
407 
408         public void curveTo(float x1, float y1,
409                             float x2, float y2,
410                             float x3, float y3)
411         {
412             out.curveTo(x1 * sx, y1 * sy,
413                         x2 * sx, y2 * sy,
414                         x3 * sx, y3 * sy);
415         }
416 
417         public void closePath() {
418             out.closePath();
419         }
420 
421         public void pathDone() {
422             out.pathDone();
423         }
424 
425         public long getNativeConsumer() {
426             return 0;
427         }
428     }
429 
430     static final class DeltaTransformFilter extends TransformingPathConsumer2D {
431         private float Mxx;
432         private float Mxy;
433         private float Myx;
434         private float Myy;
435 
436         DeltaTransformFilter(PathConsumer2D out,
437                              float Mxx, float Mxy,
438                              float Myx, float Myy)
439         {
440             super(out);
441             set(Mxx, Mxy, Myx, Myy);
442         }
443 
444         public void set(float Mxx, float Mxy,
445                         float Myx, float Myy)
446         {
447             this.Mxx = Mxx;
448             this.Mxy = Mxy;
449             this.Myx = Myx;
450             this.Myy = Myy;
451         }
452 
453         public void moveTo(float x0, float y0) {
454             out.moveTo(x0 * Mxx + y0 * Mxy,
455                        x0 * Myx + y0 * Myy);
456         }
457 
458         public void lineTo(float x1, float y1) {
459             out.lineTo(x1 * Mxx + y1 * Mxy,
460                        x1 * Myx + y1 * Myy);
461         }
462 
463         public void quadTo(float x1, float y1,
464                            float x2, float y2)
465         {
466             out.quadTo(x1 * Mxx + y1 * Mxy,
467                        x1 * Myx + y1 * Myy,
468                        x2 * Mxx + y2 * Mxy,
469                        x2 * Myx + y2 * Myy);
470         }
471 
472         public void curveTo(float x1, float y1,
473                             float x2, float y2,
474                             float x3, float y3)
475         {
476             out.curveTo(x1 * Mxx + y1 * Mxy,
477                         x1 * Myx + y1 * Myy,
478                         x2 * Mxx + y2 * Mxy,
479                         x2 * Myx + y2 * Myy,
480                         x3 * Mxx + y3 * Mxy,
481                         x3 * Myx + y3 * Myy);
482         }
483 
484         public void closePath() {
485             out.closePath();
486         }
487 
488         public void pathDone() {
489             out.pathDone();
490         }
491 
492         public long getNativeConsumer() {
493             return 0;
494         }
495     }
496 }
    </pre>
  </body>
</html>
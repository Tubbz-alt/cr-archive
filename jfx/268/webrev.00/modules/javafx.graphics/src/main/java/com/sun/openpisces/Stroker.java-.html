<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.graphics/src/main/java/com/sun/openpisces/Stroker.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.openpisces;
  27 
  28 import com.sun.javafx.geom.PathConsumer2D;
  29 import java.util.Arrays;
  30 import java.util.Iterator;
  31 
  32 // TODO: some of the arithmetic here is too verbose and prone to hard to
  33 // debug typos. We should consider making a small Point/Vector class that
  34 // has methods like plus(Point), minus(Point), dot(Point), cross(Point)and such
  35 // (RT-26922)
  36 public final class Stroker implements PathConsumer2D {
  37 
  38     private static final int MOVE_TO = 0;
  39     private static final int DRAWING_OP_TO = 1; // ie. curve, line, or quad
  40     private static final int CLOSE = 2;
  41 
  42     /**
  43      * Constant value for join style.
  44      */
  45     public static final int JOIN_MITER = 0;
  46 
  47     /**
  48      * Constant value for join style.
  49      */
  50     public static final int JOIN_ROUND = 1;
  51 
  52     /**
  53      * Constant value for join style.
  54      */
  55     public static final int JOIN_BEVEL = 2;
  56 
  57     /**
  58      * Constant value for end cap style.
  59      */
  60     public static final int CAP_BUTT = 0;
  61 
  62     /**
  63      * Constant value for end cap style.
  64      */
  65     public static final int CAP_ROUND = 1;
  66 
  67     /**
  68      * Constant value for end cap style.
  69      */
  70     public static final int CAP_SQUARE = 2;
  71 
  72     private PathConsumer2D out;
  73 
  74     private int capStyle;
  75     private int joinStyle;
  76 
  77     private float lineWidth2;
  78 
  79     private final float[][] offset = new float[3][2];
  80     private final float[] miter = new float[2];
  81     private float miterLimitSq;
  82 
  83     private int prev;
  84 
  85     // The starting point of the path, and the slope there.
  86     private float sx0, sy0, sdx, sdy;
  87     // the current point and the slope there.
  88     private float cx0, cy0, cdx, cdy; // c stands for current
  89     // vectors that when added to (sx0,sy0) and (cx0,cy0) respectively yield the
  90     // first and last points on the left parallel path. Since this path is
  91     // parallel, it&#39;s slope at any point is parallel to the slope of the
  92     // original path (thought they may have different directions), so these
  93     // could be computed from sdx,sdy and cdx,cdy (and vice versa), but that
  94     // would be error prone and hard to read, so we keep these anyway.
  95     private float smx, smy, cmx, cmy;
  96 
  97     private final PolyStack reverse = new PolyStack();
  98 
  99     /**
 100      * Constructs a &lt;code&gt;Stroker&lt;/code&gt;.
 101      *
 102      * @param pc2d an output &lt;code&gt;PathConsumer2D&lt;/code&gt;.
 103      * @param lineWidth the desired line width in pixels
 104      * @param capStyle the desired end cap style, one of
 105      * &lt;code&gt;CAP_BUTT&lt;/code&gt;, &lt;code&gt;CAP_ROUND&lt;/code&gt; or
 106      * &lt;code&gt;CAP_SQUARE&lt;/code&gt;.
 107      * @param joinStyle the desired line join style, one of
 108      * &lt;code&gt;JOIN_MITER&lt;/code&gt;, &lt;code&gt;JOIN_ROUND&lt;/code&gt; or
 109      * &lt;code&gt;JOIN_BEVEL&lt;/code&gt;.
 110      * @param miterLimit the desired miter limit
 111      */
 112     public Stroker(PathConsumer2D pc2d,
 113                    float lineWidth,
 114                    int capStyle,
 115                    int joinStyle,
 116                    float miterLimit)
 117     {
 118         this(pc2d);
 119 
 120         reset(lineWidth, capStyle, joinStyle, miterLimit);
 121     }
 122 
 123     public Stroker(PathConsumer2D pc2d) {
 124         setConsumer(pc2d);
 125     }
 126 
 127     public void setConsumer(PathConsumer2D pc2d) {
 128         this.out = pc2d;
 129     }
 130 
 131     public void reset(float lineWidth, int capStyle, int joinStyle,
 132                       float miterLimit) {
 133         this.lineWidth2 = lineWidth / 2;
 134         this.capStyle = capStyle;
 135         this.joinStyle = joinStyle;
 136 
 137         float limit = miterLimit * lineWidth2;
 138         this.miterLimitSq = limit*limit;
 139 
 140         this.prev = CLOSE;
 141     }
 142 
 143     private static void computeOffset(final float lx, final float ly,
 144                                       final float w, final float[] m)
 145     {
 146         final float len = (float)Math.sqrt(lx*lx + ly*ly);
 147         if (len == 0) {
 148             m[0] = m[1] = 0;
 149         } else {
 150             m[0] = (ly * w)/len;
 151             m[1] = -(lx * w)/len;
 152         }
 153     }
 154 
 155     // Returns true if the vectors (dx1, dy1) and (dx2, dy2) are
 156     // clockwise (if dx1,dy1 needs to be rotated clockwise to close
 157     // the smallest angle between it and dx2,dy2).
 158     // This is equivalent to detecting whether a point q is on the right side
 159     // of a line passing through points p1, p2 where p2 = p1+(dx1,dy1) and
 160     // q = p2+(dx2,dy2), which is the same as saying p1, p2, q are in a
 161     // clockwise order.
 162     // NOTE: &quot;clockwise&quot; here assumes coordinates with 0,0 at the bottom left.
 163     private static boolean isCW(final float dx1, final float dy1,
 164                                 final float dx2, final float dy2)
 165     {
 166         return dx1 * dy2 &lt;= dy1 * dx2;
 167     }
 168 
 169     // pisces used to use fixed point arithmetic with 16 decimal digits. I
 170     // didn&#39;t want to change the values of the constant below when I converted
 171     // it to floating point, so that&#39;s why the divisions by 2^16 are there.
 172     private static final float ROUND_JOIN_THRESHOLD = 1000/65536f;
 173 
 174     private void drawRoundJoin(float x, float y,
 175                                float omx, float omy, float mx, float my,
 176                                boolean rev,
 177                                float threshold)
 178     {
 179         if ((omx == 0 &amp;&amp; omy == 0) || (mx == 0 &amp;&amp; my == 0)) {
 180             return;
 181         }
 182 
 183         float domx = omx - mx;
 184         float domy = omy - my;
 185         float len = domx*domx + domy*domy;
 186         if (len &lt; threshold) {
 187             return;
 188         }
 189 
 190         if (rev) {
 191             omx = -omx;
 192             omy = -omy;
 193             mx = -mx;
 194             my = -my;
 195         }
 196         drawRoundJoin(x, y, omx, omy, mx, my, rev);
 197     }
 198 
 199     private void drawRoundJoin(float cx, float cy,
 200                                float omx, float omy,
 201                                float mx, float my,
 202                                boolean rev)
 203     {
 204         // The sign of the dot product of mx,my and omx,omy is equal to the
 205         // the sign of the cosine of ext
 206         // (ext is the angle between omx,omy and mx,my).
 207         double cosext = omx * mx + omy * my;
 208         // If it is &gt;=0, we know that abs(ext) is &lt;= 90 degrees, so we only
 209         // need 1 curve to approximate the circle section that joins omx,omy
 210         // and mx,my.
 211         final int numCurves = cosext &gt;= 0 ? 1 : 2;
 212 
 213         switch (numCurves) {
 214         case 1:
 215             drawBezApproxForArc(cx, cy, omx, omy, mx, my, rev);
 216             break;
 217         case 2:
 218             // we need to split the arc into 2 arcs spanning the same angle.
 219             // The point we want will be one of the 2 intersections of the
 220             // perpendicular bisector of the chord (omx,omy)-&gt;(mx,my) and the
 221             // circle. We could find this by scaling the vector
 222             // (omx+mx, omy+my)/2 so that it has length=lineWidth2 (and thus lies
 223             // on the circle), but that can have numerical problems when the angle
 224             // between omx,omy and mx,my is close to 180 degrees. So we compute a
 225             // normal of (omx,omy)-(mx,my). This will be the direction of the
 226             // perpendicular bisector. To get one of the intersections, we just scale
 227             // this vector that its length is lineWidth2 (this works because the
 228             // perpendicular bisector goes through the origin). This scaling doesn&#39;t
 229             // have numerical problems because we know that lineWidth2 divided by
 230             // this normal&#39;s length is at least 0.5 and at most sqrt(2)/2 (because
 231             // we know the angle of the arc is &gt; 90 degrees).
 232             float nx = my - omy, ny = omx - mx;
 233             float nlen = (float)Math.sqrt(nx*nx + ny*ny);
 234             float scale = lineWidth2/nlen;
 235             float mmx = nx * scale, mmy = ny * scale;
 236 
 237             // if (isCW(omx, omy, mx, my) != isCW(mmx, mmy, mx, my)) then we&#39;ve
 238             // computed the wrong intersection so we get the other one.
 239             // The test above is equivalent to if (rev).
 240             if (rev) {
 241                 mmx = -mmx;
 242                 mmy = -mmy;
 243             }
 244             drawBezApproxForArc(cx, cy, omx, omy, mmx, mmy, rev);
 245             drawBezApproxForArc(cx, cy, mmx, mmy, mx, my, rev);
 246             break;
 247         }
 248     }
 249 
 250     // the input arc defined by omx,omy and mx,my must span &lt;= 90 degrees.
 251     private void drawBezApproxForArc(final float cx, final float cy,
 252                                      final float omx, final float omy,
 253                                      final float mx, final float my,
 254                                      boolean rev)
 255     {
 256         float cosext2 = (omx * mx + omy * my) / (2 * lineWidth2 * lineWidth2);
 257         // cv is the length of P1-P0 and P2-P3 divided by the radius of the arc
 258         // (so, cv assumes the arc has radius 1). P0, P1, P2, P3 are the points that
 259         // define the bezier curve we&#39;re computing.
 260         // It is computed using the constraints that P1-P0 and P3-P2 are parallel
 261         // to the arc tangents at the endpoints, and that |P1-P0|=|P3-P2|.
 262         float cv = (float)((4.0 / 3.0) * Math.sqrt(0.5-cosext2) /
 263                            (1.0 + Math.sqrt(cosext2+0.5)));
 264         // if clockwise, we need to negate cv.
 265         if (rev) { // rev is equivalent to isCW(omx, omy, mx, my)
 266             cv = -cv;
 267         }
 268         final float x1 = cx + omx;
 269         final float y1 = cy + omy;
 270         final float x2 = x1 - cv * omy;
 271         final float y2 = y1 + cv * omx;
 272 
 273         final float x4 = cx + mx;
 274         final float y4 = cy + my;
 275         final float x3 = x4 + cv * my;
 276         final float y3 = y4 - cv * mx;
 277 
 278         emitCurveTo(x1, y1, x2, y2, x3, y3, x4, y4, rev);
 279     }
 280 
 281     private void drawRoundCap(float cx, float cy, float mx, float my) {
 282         final float C = 0.5522847498307933f;
 283         // the first and second arguments of the following two calls
 284         // are really will be ignored by emitCurveTo (because of the false),
 285         // but we put them in anyway, as opposed to just giving it 4 zeroes,
 286         // because it&#39;s just 4 additions and it&#39;s not good to rely on this
 287         // sort of assumption (right now it&#39;s true, but that may change).
 288         emitCurveTo(cx+mx,      cy+my,
 289                     cx+mx-C*my, cy+my+C*mx,
 290                     cx-my+C*mx, cy+mx+C*my,
 291                     cx-my,      cy+mx,
 292                     false);
 293         emitCurveTo(cx-my,      cy+mx,
 294                     cx-my-C*mx, cy+mx-C*my,
 295                     cx-mx-C*my, cy-my+C*mx,
 296                     cx-mx,      cy-my,
 297                     false);
 298     }
 299 
 300     // Return the intersection point of the lines (x0, y0) -&gt; (x1, y1)
 301     // and (x0p, y0p) -&gt; (x1p, y1p) in m[0] and m[1]
 302     private void computeMiter(final float x0, final float y0,
 303                               final float x1, final float y1,
 304                               final float x0p, final float y0p,
 305                               final float x1p, final float y1p,
 306                               final float[] m, int off)
 307     {
 308         float x10 = x1 - x0;
 309         float y10 = y1 - y0;
 310         float x10p = x1p - x0p;
 311         float y10p = y1p - y0p;
 312 
 313         // if this is 0, the lines are parallel. If they go in the
 314         // same direction, there is no intersection so m[off] and
 315         // m[off+1] will contain infinity, so no miter will be drawn.
 316         // If they go in the same direction that means that the start of the
 317         // current segment and the end of the previous segment have the same
 318         // tangent, in which case this method won&#39;t even be involved in
 319         // miter drawing because it won&#39;t be called by drawMiter (because
 320         // (mx == omx &amp;&amp; my == omy) will be true, and drawMiter will return
 321         // immediately).
 322         float den = x10*y10p - x10p*y10;
 323         float t = x10p*(y0-y0p) - y10p*(x0-x0p);
 324         t /= den;
 325         m[off++] = x0 + t*x10;
 326         m[off] = y0 + t*y10;
 327     }
 328 
 329     // Return the intersection point of the lines (x0, y0) -&gt; (x1, y1)
 330     // and (x0p, y0p) -&gt; (x1p, y1p) in m[0] and m[1]
 331     private void safecomputeMiter(final float x0, final float y0,
 332                                   final float x1, final float y1,
 333                                   final float x0p, final float y0p,
 334                                   final float x1p, final float y1p,
 335                                   final float[] m, int off)
 336     {
 337         float x10 = x1 - x0;
 338         float y10 = y1 - y0;
 339         float x10p = x1p - x0p;
 340         float y10p = y1p - y0p;
 341 
 342         // if this is 0, the lines are parallel. If they go in the
 343         // same direction, there is no intersection so m[off] and
 344         // m[off+1] will contain infinity, so no miter will be drawn.
 345         // If they go in the same direction that means that the start of the
 346         // current segment and the end of the previous segment have the same
 347         // tangent, in which case this method won&#39;t even be involved in
 348         // miter drawing because it won&#39;t be called by drawMiter (because
 349         // (mx == omx &amp;&amp; my == omy) will be true, and drawMiter will return
 350         // immediately).
 351         float den = x10*y10p - x10p*y10;
 352         if (den == 0) {
 353             m[off++] = (x0 + x0p) / 2.0f;
 354             m[off] = (y0 + y0p) / 2.0f;
 355             return;
 356         }
 357         float t = x10p*(y0-y0p) - y10p*(x0-x0p);
 358         t /= den;
 359         m[off++] = x0 + t*x10;
 360         m[off] = y0 + t*y10;
 361     }
 362 
 363     private void drawMiter(final float pdx, final float pdy,
 364                            final float x0, final float y0,
 365                            final float dx, final float dy,
 366                            float omx, float omy, float mx, float my,
 367                            boolean rev)
 368     {
 369         if ((mx == omx &amp;&amp; my == omy) ||
 370             (pdx == 0 &amp;&amp; pdy == 0) ||
 371             (dx == 0 &amp;&amp; dy == 0)) {
 372             return;
 373         }
 374 
 375         if (rev) {
 376             omx = -omx;
 377             omy = -omy;
 378             mx = -mx;
 379             my = -my;
 380         }
 381 
 382         computeMiter((x0 - pdx) + omx, (y0 - pdy) + omy, x0 + omx, y0 + omy,
 383                      (dx + x0) + mx, (dy + y0) + my, x0 + mx, y0 + my,
 384                      miter, 0);
 385 
 386         float lenSq = (miter[0]-x0)*(miter[0]-x0) + (miter[1]-y0)*(miter[1]-y0);
 387 
 388         if (lenSq &lt; miterLimitSq) {
 389             emitLineTo(miter[0], miter[1], rev);
 390         }
 391     }
 392 
 393     public void moveTo(float x0, float y0) {
 394         if (prev == DRAWING_OP_TO) {
 395             finish();
 396         }
 397         this.sx0 = this.cx0 = x0;
 398         this.sy0 = this.cy0 = y0;
 399         this.cdx = this.sdx = 1;
 400         this.cdy = this.sdy = 0;
 401         this.prev = MOVE_TO;
 402     }
 403 
 404     public void lineTo(float x1, float y1) {
 405         float dx = x1 - cx0;
 406         float dy = y1 - cy0;
 407         if (dx == 0f &amp;&amp; dy == 0f) {
 408             dx = 1;
 409         }
 410         computeOffset(dx, dy, lineWidth2, offset[0]);
 411         float mx = offset[0][0];
 412         float my = offset[0][1];
 413 
 414         drawJoin(cdx, cdy, cx0, cy0, dx, dy, cmx, cmy, mx, my);
 415 
 416         emitLineTo(cx0 + mx, cy0 + my);
 417         emitLineTo(x1 + mx, y1 + my);
 418 
 419         emitLineTo(cx0 - mx, cy0 - my, true);
 420         emitLineTo(x1 - mx, y1 - my, true);
 421 
 422         this.cmx = mx;
 423         this.cmy = my;
 424         this.cdx = dx;
 425         this.cdy = dy;
 426         this.cx0 = x1;
 427         this.cy0 = y1;
 428         this.prev = DRAWING_OP_TO;
 429     }
 430 
 431     public void closePath() {
 432         if (prev != DRAWING_OP_TO) {
 433             if (prev == CLOSE) {
 434                 return;
 435             }
 436             emitMoveTo(cx0, cy0 - lineWidth2);
 437             this.cmx = this.smx = 0;
 438             this.cmy = this.smy = -lineWidth2;
 439             this.cdx = this.sdx = 1;
 440             this.cdy = this.sdy = 0;
 441             finish();
 442             return;
 443         }
 444 
 445         if (cx0 != sx0 || cy0 != sy0) {
 446             lineTo(sx0, sy0);
 447         }
 448 
 449         drawJoin(cdx, cdy, cx0, cy0, sdx, sdy, cmx, cmy, smx, smy);
 450 
 451         emitLineTo(sx0 + smx, sy0 + smy);
 452 
 453         emitMoveTo(sx0 - smx, sy0 - smy);
 454         emitReverse();
 455 
 456         this.prev = CLOSE;
 457         emitClose();
 458     }
 459 
 460     private void emitReverse() {
 461         while(!reverse.isEmpty()) {
 462             reverse.pop(out);
 463         }
 464     }
 465 
 466     public void pathDone() {
 467         if (prev == DRAWING_OP_TO) {
 468             finish();
 469         }
 470 
 471         out.pathDone();
 472         // this shouldn&#39;t matter since this object won&#39;t be used
 473         // after the call to this method.
 474         this.prev = CLOSE;
 475     }
 476 
 477     private void finish() {
 478         if (capStyle == CAP_ROUND) {
 479             drawRoundCap(cx0, cy0, cmx, cmy);
 480         } else if (capStyle == CAP_SQUARE) {
 481             emitLineTo(cx0 - cmy + cmx, cy0 + cmx + cmy);
 482             emitLineTo(cx0 - cmy - cmx, cy0 + cmx - cmy);
 483         }
 484 
 485         emitReverse();
 486 
 487         if (capStyle == CAP_ROUND) {
 488             drawRoundCap(sx0, sy0, -smx, -smy);
 489         } else if (capStyle == CAP_SQUARE) {
 490             emitLineTo(sx0 + smy - smx, sy0 - smx - smy);
 491             emitLineTo(sx0 + smy + smx, sy0 - smx + smy);
 492         }
 493 
 494         emitClose();
 495     }
 496 
 497     private void emitMoveTo(final float x0, final float y0) {
 498         out.moveTo(x0, y0);
 499     }
 500 
 501     private void emitLineTo(final float x1, final float y1) {
 502         out.lineTo(x1, y1);
 503     }
 504 
 505     private void emitLineTo(final float x1, final float y1,
 506                             final boolean rev)
 507     {
 508         if (rev) {
 509             reverse.pushLine(x1, y1);
 510         } else {
 511             emitLineTo(x1, y1);
 512         }
 513     }
 514 
 515     private void emitQuadTo(final float x0, final float y0,
 516                             final float x1, final float y1,
 517                             final float x2, final float y2, final boolean rev)
 518     {
 519         if (rev) {
 520             reverse.pushQuad(x0, y0, x1, y1);
 521         } else {
 522             out.quadTo(x1, y1, x2, y2);
 523         }
 524     }
 525 
 526     private void emitCurveTo(final float x0, final float y0,
 527                              final float x1, final float y1,
 528                              final float x2, final float y2,
 529                              final float x3, final float y3, final boolean rev)
 530     {
 531         if (rev) {
 532             reverse.pushCubic(x0, y0, x1, y1, x2, y2);
 533         } else {
 534             out.curveTo(x1, y1, x2, y2, x3, y3);
 535         }
 536     }
 537 
 538     private void emitClose() {
 539         out.closePath();
 540     }
 541 
 542     private void drawJoin(float pdx, float pdy,
 543                           float x0, float y0,
 544                           float dx, float dy,
 545                           float omx, float omy,
 546                           float mx, float my)
 547     {
 548         if (prev != DRAWING_OP_TO) {
 549             emitMoveTo(x0 + mx, y0 + my);
 550             this.sdx = dx;
 551             this.sdy = dy;
 552             this.smx = mx;
 553             this.smy = my;
 554         } else {
 555             boolean cw = isCW(pdx, pdy, dx, dy);
 556             if (joinStyle == JOIN_MITER) {
 557                 drawMiter(pdx, pdy, x0, y0, dx, dy, omx, omy, mx, my, cw);
 558             } else if (joinStyle == JOIN_ROUND) {
 559                 drawRoundJoin(x0, y0,
 560                               omx, omy,
 561                               mx, my, cw,
 562                               ROUND_JOIN_THRESHOLD);
 563             }
 564             emitLineTo(x0, y0, !cw);
 565         }
 566         prev = DRAWING_OP_TO;
 567     }
 568 
 569     private static boolean within(final float x1, final float y1,
 570                                   final float x2, final float y2,
 571                                   final float ERR)
 572     {
 573         assert ERR &gt; 0 : &quot;&quot;;
 574         // compare taxicab distance. ERR will always be small, so using
 575         // true distance won&#39;t give much benefit
 576         return (Helpers.within(x1, x2, ERR) &amp;&amp;  // we want to avoid calling Math.abs
 577                 Helpers.within(y1, y2, ERR)); // this is just as good.
 578     }
 579 
 580     private void getLineOffsets(float x1, float y1,
 581                                 float x2, float y2,
 582                                 float[] left, float[] right) {
 583         computeOffset(x2 - x1, y2 - y1, lineWidth2, offset[0]);
 584         left[0] = x1 + offset[0][0];
 585         left[1] = y1 + offset[0][1];
 586         left[2] = x2 + offset[0][0];
 587         left[3] = y2 + offset[0][1];
 588         right[0] = x1 - offset[0][0];
 589         right[1] = y1 - offset[0][1];
 590         right[2] = x2 - offset[0][0];
 591         right[3] = y2 - offset[0][1];
 592     }
 593 
 594     private int computeOffsetCubic(float[] pts, final int off,
 595                                    float[] leftOff, float[] rightOff)
 596     {
 597         // if p1=p2 or p3=p4 it means that the derivative at the endpoint
 598         // vanishes, which creates problems with computeOffset. Usually
 599         // this happens when this stroker object is trying to winden
 600         // a curve with a cusp. What happens is that curveTo splits
 601         // the input curve at the cusp, and passes it to this function.
 602         // because of inaccuracies in the splitting, we consider points
 603         // equal if they&#39;re very close to each other.
 604         final float x1 = pts[off + 0], y1 = pts[off + 1];
 605         final float x2 = pts[off + 2], y2 = pts[off + 3];
 606         final float x3 = pts[off + 4], y3 = pts[off + 5];
 607         final float x4 = pts[off + 6], y4 = pts[off + 7];
 608 
 609         float dx4 = x4 - x3;
 610         float dy4 = y4 - y3;
 611         float dx1 = x2 - x1;
 612         float dy1 = y2 - y1;
 613 
 614         // if p1 == p2 &amp;&amp; p3 == p4: draw line from p1-&gt;p4, unless p1 == p4,
 615         // in which case ignore if p1 == p2
 616         final boolean p1eqp2 = within(x1,y1,x2,y2, 6 * Math.ulp(y2));
 617         final boolean p3eqp4 = within(x3,y3,x4,y4, 6 * Math.ulp(y4));
 618         if (p1eqp2 &amp;&amp; p3eqp4) {
 619             getLineOffsets(x1, y1, x4, y4, leftOff, rightOff);
 620             return 4;
 621         } else if (p1eqp2) {
 622             dx1 = x3 - x1;
 623             dy1 = y3 - y1;
 624         } else if (p3eqp4) {
 625             dx4 = x4 - x2;
 626             dy4 = y4 - y2;
 627         }
 628 
 629         // if p2-p1 and p4-p3 are parallel, that must mean this curve is a line
 630         float dotsq = (dx1 * dx4 + dy1 * dy4);
 631         dotsq = dotsq * dotsq;
 632         float l1sq = dx1 * dx1 + dy1 * dy1, l4sq = dx4 * dx4 + dy4 * dy4;
 633         if (Helpers.within(dotsq, l1sq * l4sq, 4 * Math.ulp(dotsq))) {
 634             getLineOffsets(x1, y1, x4, y4, leftOff, rightOff);
 635             return 4;
 636         }
 637 
 638 //      What we&#39;re trying to do in this function is to approximate an ideal
 639 //      offset curve (call it I) of the input curve B using a bezier curve Bp.
 640 //      The constraints I use to get the equations are:
 641 //
 642 //      1. The computed curve Bp should go through I(0) and I(1). These are
 643 //      x1p, y1p, x4p, y4p, which are p1p and p4p. We still need to find
 644 //      4 variables: the x and y components of p2p and p3p (i.e. x2p, y2p, x3p, y3p).
 645 //
 646 //      2. Bp should have slope equal in absolute value to I at the endpoints. So,
 647 //      (by the way, the operator || in the comments below means &quot;aligned with&quot;.
 648 //      It is defined on vectors, so when we say I&#39;(0) || Bp&#39;(0) we mean that
 649 //      vectors I&#39;(0) and Bp&#39;(0) are aligned, which is the same as saying
 650 //      that the tangent lines of I and Bp at 0 are parallel. Mathematically
 651 //      this means (I&#39;(t) || Bp&#39;(t)) &lt;==&gt; (I&#39;(t) = c * Bp&#39;(t)) where c is some
 652 //      nonzero constant.)
 653 //      I&#39;(0) || Bp&#39;(0) and I&#39;(1) || Bp&#39;(1). Obviously, I&#39;(0) || B&#39;(0) and
 654 //      I&#39;(1) || B&#39;(1); therefore, Bp&#39;(0) || B&#39;(0) and Bp&#39;(1) || B&#39;(1).
 655 //      We know that Bp&#39;(0) || (p2p-p1p) and Bp&#39;(1) || (p4p-p3p) and the same
 656 //      is true for any bezier curve; therefore, we get the equations
 657 //          (1) p2p = c1 * (p2-p1) + p1p
 658 //          (2) p3p = c2 * (p4-p3) + p4p
 659 //      We know p1p, p4p, p2, p1, p3, and p4; therefore, this reduces the number
 660 //      of unknowns from 4 to 2 (i.e. just c1 and c2).
 661 //      To eliminate these 2 unknowns we use the following constraint:
 662 //
 663 //      3. Bp(0.5) == I(0.5). Bp(0.5)=(x,y) and I(0.5)=(xi,yi), and I should note
 664 //      that I(0.5) is *the only* reason for computing dxm,dym. This gives us
 665 //          (3) Bp(0.5) = (p1p + 3 * (p2p + p3p) + p4p)/8, which is equivalent to
 666 //          (4) p2p + p3p = (Bp(0.5)*8 - p1p - p4p) / 3
 667 //      We can substitute (1) and (2) from above into (4) and we get:
 668 //          (5) c1*(p2-p1) + c2*(p4-p3) = (Bp(0.5)*8 - p1p - p4p)/3 - p1p - p4p
 669 //      which is equivalent to
 670 //          (6) c1*(p2-p1) + c2*(p4-p3) = (4/3) * (Bp(0.5) * 2 - p1p - p4p)
 671 //
 672 //      The right side of this is a 2D vector, and we know I(0.5), which gives us
 673 //      Bp(0.5), which gives us the value of the right side.
 674 //      The left side is just a matrix vector multiplication in disguise. It is
 675 //
 676 //      [x2-x1, x4-x3][c1]
 677 //      [y2-y1, y4-y3][c2]
 678 //      which, is equal to
 679 //      [dx1, dx4][c1]
 680 //      [dy1, dy4][c2]
 681 //      At this point we are left with a simple linear system and we solve it by
 682 //      getting the inverse of the matrix above. Then we use [c1,c2] to compute
 683 //      p2p and p3p.
 684 
 685         float x = 0.125f * (x1 + 3 * (x2 + x3) + x4);
 686         float y = 0.125f * (y1 + 3 * (y2 + y3) + y4);
 687         // (dxm,dym) is some tangent of B at t=0.5. This means it&#39;s equal to
 688         // c*B&#39;(0.5) for some constant c.
 689         float dxm = x3 + x4 - x1 - x2, dym = y3 + y4 - y1 - y2;
 690 
 691         // this computes the offsets at t=0, 0.5, 1, using the property that
 692         // for any bezier curve the vectors p2-p1 and p4-p3 are parallel to
 693         // the (dx/dt, dy/dt) vectors at the endpoints.
 694         computeOffset(dx1, dy1, lineWidth2, offset[0]);
 695         computeOffset(dxm, dym, lineWidth2, offset[1]);
 696         computeOffset(dx4, dy4, lineWidth2, offset[2]);
 697         float x1p = x1 + offset[0][0]; // start
 698         float y1p = y1 + offset[0][1]; // point
 699         float xi  = x + offset[1][0]; // interpolation
 700         float yi  = y + offset[1][1]; // point
 701         float x4p = x4 + offset[2][0]; // end
 702         float y4p = y4 + offset[2][1]; // point
 703 
 704         float invdet43 = 4f / (3f * (dx1 * dy4 - dy1 * dx4));
 705 
 706         float two_pi_m_p1_m_p4x = 2*xi - x1p - x4p;
 707         float two_pi_m_p1_m_p4y = 2*yi - y1p - y4p;
 708         float c1 = invdet43 * (dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y);
 709         float c2 = invdet43 * (dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x);
 710 
 711         float x2p, y2p, x3p, y3p;
 712         x2p = x1p + c1*dx1;
 713         y2p = y1p + c1*dy1;
 714         x3p = x4p + c2*dx4;
 715         y3p = y4p + c2*dy4;
 716 
 717         leftOff[0] = x1p; leftOff[1] = y1p;
 718         leftOff[2] = x2p; leftOff[3] = y2p;
 719         leftOff[4] = x3p; leftOff[5] = y3p;
 720         leftOff[6] = x4p; leftOff[7] = y4p;
 721 
 722         x1p = x1 - offset[0][0]; y1p = y1 - offset[0][1];
 723         xi = xi - 2 * offset[1][0]; yi = yi - 2 * offset[1][1];
 724         x4p = x4 - offset[2][0]; y4p = y4 - offset[2][1];
 725 
 726         two_pi_m_p1_m_p4x = 2*xi - x1p - x4p;
 727         two_pi_m_p1_m_p4y = 2*yi - y1p - y4p;
 728         c1 = invdet43 * (dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y);
 729         c2 = invdet43 * (dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x);
 730 
 731         x2p = x1p + c1*dx1;
 732         y2p = y1p + c1*dy1;
 733         x3p = x4p + c2*dx4;
 734         y3p = y4p + c2*dy4;
 735 
 736         rightOff[0] = x1p; rightOff[1] = y1p;
 737         rightOff[2] = x2p; rightOff[3] = y2p;
 738         rightOff[4] = x3p; rightOff[5] = y3p;
 739         rightOff[6] = x4p; rightOff[7] = y4p;
 740         return 8;
 741     }
 742 
 743     // compute offset curves using bezier spline through t=0.5 (i.e.
 744     // ComputedCurve(0.5) == IdealParallelCurve(0.5))
 745     // return the kind of curve in the right and left arrays.
 746     private int computeOffsetQuad(float[] pts, final int off,
 747                                   float[] leftOff, float[] rightOff)
 748     {
 749         final float x1 = pts[off + 0], y1 = pts[off + 1];
 750         final float x2 = pts[off + 2], y2 = pts[off + 3];
 751         final float x3 = pts[off + 4], y3 = pts[off + 5];
 752 
 753         float dx3 = x3 - x2;
 754         float dy3 = y3 - y2;
 755         float dx1 = x2 - x1;
 756         float dy1 = y2 - y1;
 757 
 758         // if p1=p2 or p3=p4 it means that the derivative at the endpoint
 759         // vanishes, which creates problems with computeOffset. Usually
 760         // this happens when this stroker object is trying to winden
 761         // a curve with a cusp. What happens is that curveTo splits
 762         // the input curve at the cusp, and passes it to this function.
 763         // because of inaccuracies in the splitting, we consider points
 764         // equal if they&#39;re very close to each other.
 765 
 766         // if p1 == p2 &amp;&amp; p3 == p4: draw line from p1-&gt;p4, unless p1 == p4,
 767         // in which case ignore.
 768         final boolean p1eqp2 = within(x1,y1,x2,y2, 6 * Math.ulp(y2));
 769         final boolean p2eqp3 = within(x2,y2,x3,y3, 6 * Math.ulp(y3));
 770         if (p1eqp2 || p2eqp3) {
 771             getLineOffsets(x1, y1, x3, y3, leftOff, rightOff);
 772             return 4;
 773         }
 774 
 775         // if p2-p1 and p4-p3 are parallel, that must mean this curve is a line
 776         float dotsq = (dx1 * dx3 + dy1 * dy3);
 777         dotsq = dotsq * dotsq;
 778         float l1sq = dx1 * dx1 + dy1 * dy1, l3sq = dx3 * dx3 + dy3 * dy3;
 779         if (Helpers.within(dotsq, l1sq * l3sq, 4 * Math.ulp(dotsq))) {
 780             getLineOffsets(x1, y1, x3, y3, leftOff, rightOff);
 781             return 4;
 782         }
 783 
 784         // this computes the offsets at t=0, 0.5, 1, using the property that
 785         // for any bezier curve the vectors p2-p1 and p4-p3 are parallel to
 786         // the (dx/dt, dy/dt) vectors at the endpoints.
 787         computeOffset(dx1, dy1, lineWidth2, offset[0]);
 788         computeOffset(dx3, dy3, lineWidth2, offset[1]);
 789         float x1p = x1 + offset[0][0]; // start
 790         float y1p = y1 + offset[0][1]; // point
 791         float x3p = x3 + offset[1][0]; // end
 792         float y3p = y3 + offset[1][1]; // point
 793 
 794         safecomputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, leftOff, 2);
 795         leftOff[0] = x1p; leftOff[1] = y1p;
 796         leftOff[4] = x3p; leftOff[5] = y3p;
 797         x1p = x1 - offset[0][0]; y1p = y1 - offset[0][1];
 798         x3p = x3 - offset[1][0]; y3p = y3 - offset[1][1];
 799         safecomputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, rightOff, 2);
 800         rightOff[0] = x1p; rightOff[1] = y1p;
 801         rightOff[4] = x3p; rightOff[5] = y3p;
 802         return 6;
 803     }
 804 
 805     // This is where the curve to be processed is put. We give it
 806     // enough room to store 2 curves: one for the current subdivision, the
 807     // other for the rest of the curve.
 808     private float[] middle = new float[MAX_N_CURVES*8];
 809     private float[] lp = new float[8];
 810     private float[] rp = new float[8];
 811     private static final int MAX_N_CURVES = 11;
 812     private float[] subdivTs = new float[MAX_N_CURVES - 1];
 813 
 814     // If this class is compiled with ecj, then Hotspot crashes when OSR
 815     // compiling this function. See bugs 7004570 and 6675699
 816     // TODO: until those are fixed, we should work around that by
 817     // manually inlining this into curveTo and quadTo.
 818 /******************************* WORKAROUND **********************************
 819     private void somethingTo(final int type) {
 820         // need these so we can update the state at the end of this method
 821         final float xf = middle[type-2], yf = middle[type-1];
 822         float dxs = middle[2] - middle[0];
 823         float dys = middle[3] - middle[1];
 824         float dxf = middle[type - 2] - middle[type - 4];
 825         float dyf = middle[type - 1] - middle[type - 3];
 826         switch(type) {
 827         case 6:
 828             if ((dxs == 0f &amp;&amp; dys == 0f) ||
 829                 (dxf == 0f &amp;&amp; dyf == 0f)) {
 830                dxs = dxf = middle[4] - middle[0];
 831                dys = dyf = middle[5] - middle[1];
 832             }
 833             break;
 834         case 8:
 835             boolean p1eqp2 = (dxs == 0f &amp;&amp; dys == 0f);
 836             boolean p3eqp4 = (dxf == 0f &amp;&amp; dyf == 0f);
 837             if (p1eqp2) {
 838                 dxs = middle[4] - middle[0];
 839                 dys = middle[5] - middle[1];
 840                 if (dxs == 0f &amp;&amp; dys == 0f) {
 841                     dxs = middle[6] - middle[0];
 842                     dys = middle[7] - middle[1];
 843                 }
 844             }
 845             if (p3eqp4) {
 846                 dxf = middle[6] - middle[2];
 847                 dyf = middle[7] - middle[3];
 848                 if (dxf == 0f &amp;&amp; dyf == 0f) {
 849                     dxf = middle[6] - middle[0];
 850                     dyf = middle[7] - middle[1];
 851                 }
 852             }
 853         }
 854         if (dxs == 0f &amp;&amp; dys == 0f) {
 855             // this happens iff the &quot;curve&quot; is just a point
 856             lineTo(middle[0], middle[1]);
 857             return;
 858         }
 859         // if these vectors are too small, normalize them, to avoid future
 860         // precision problems.
 861         if (Math.abs(dxs) &lt; 0.1f &amp;&amp; Math.abs(dys) &lt; 0.1f) {
 862             float len = (float)Math.sqrt(dxs*dxs + dys*dys);
 863             dxs /= len;
 864             dys /= len;
 865         }
 866         if (Math.abs(dxf) &lt; 0.1f &amp;&amp; Math.abs(dyf) &lt; 0.1f) {
 867             float len = (float)Math.sqrt(dxf*dxf + dyf*dyf);
 868             dxf /= len;
 869             dyf /= len;
 870         }
 871 
 872         computeOffset(dxs, dys, lineWidth2, offset[0]);
 873         final float mx = offset[0][0];
 874         final float my = offset[0][1];
 875         drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, mx, my);
 876 
 877         int nSplits = findSubdivPoints(middle, subdivTs, type, lineWidth2);
 878 
 879         int kind = 0;
 880         Iterator&lt;Integer&gt; it = Curve.breakPtsAtTs(middle, type, subdivTs, nSplits);
 881         while(it.hasNext()) {
 882             int curCurveOff = it.next();
 883 
 884             kind = 0;
 885             switch (type) {
 886             case 8:
 887                 kind = computeOffsetCubic(middle, curCurveOff, lp, rp);
 888                 break;
 889             case 6:
 890                 kind = computeOffsetQuad(middle, curCurveOff, lp, rp);
 891                 break;
 892             }
 893             if (kind != 0) {
 894                 emitLineTo(lp[0], lp[1]);
 895                 switch(kind) {
 896                 case 8:
 897                     emitCurveTo(lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], lp[6], lp[7], false);
 898                     emitCurveTo(rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], rp[6], rp[7], true);
 899                     break;
 900                 case 6:
 901                     emitQuadTo(lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], false);
 902                     emitQuadTo(rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], true);
 903                     break;
 904                 case 4:
 905                     emitLineTo(lp[2], lp[3]);
 906                     emitLineTo(rp[0], rp[1], true);
 907                     break;
 908                 }
 909                 emitLineTo(rp[kind - 2], rp[kind - 1], true);
 910             }
 911         }
 912 
 913         this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
 914         this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
 915         this.cdx = dxf;
 916         this.cdy = dyf;
 917         this.cx0 = xf;
 918         this.cy0 = yf;
 919         this.prev = DRAWING_OP_TO;
 920     }
 921 ****************************** END WORKAROUND *******************************/
 922 
 923     // finds values of t where the curve in pts should be subdivided in order
 924     // to get good offset curves a distance of w away from the middle curve.
 925     // Stores the points in ts, and returns how many of them there were.
 926     private static Curve c = new Curve();
 927     private static int findSubdivPoints(float[] pts, float[] ts,
 928                                         final int type, final float w)
 929     {
 930         final float x12 = pts[2] - pts[0];
 931         final float y12 = pts[3] - pts[1];
 932         // if the curve is already parallel to either axis we gain nothing
 933         // from rotating it.
 934         if (y12 != 0f &amp;&amp; x12 != 0f) {
 935             // we rotate it so that the first vector in the control polygon is
 936             // parallel to the x-axis. This will ensure that rotated quarter
 937             // circles won&#39;t be subdivided.
 938             final float hypot = (float)Math.sqrt(x12 * x12 + y12 * y12);
 939             final float cos = x12 / hypot;
 940             final float sin = y12 / hypot;
 941             final float x1 = cos * pts[0] + sin * pts[1];
 942             final float y1 = cos * pts[1] - sin * pts[0];
 943             final float x2 = cos * pts[2] + sin * pts[3];
 944             final float y2 = cos * pts[3] - sin * pts[2];
 945             final float x3 = cos * pts[4] + sin * pts[5];
 946             final float y3 = cos * pts[5] - sin * pts[4];
 947             switch(type) {
 948             case 8:
 949                 final float x4 = cos * pts[6] + sin * pts[7];
 950                 final float y4 = cos * pts[7] - sin * pts[6];
 951                 c.set(x1, y1, x2, y2, x3, y3, x4, y4);
 952                 break;
 953             case 6:
 954                 c.set(x1, y1, x2, y2, x3, y3);
 955                 break;
 956             }
 957         } else {
 958             c.set(pts, type);
 959         }
 960 
 961         int ret = 0;
 962         // we subdivide at values of t such that the remaining rotated
 963         // curves are monotonic in x and y.
 964         ret += c.dxRoots(ts, ret);
 965         ret += c.dyRoots(ts, ret);
 966         // subdivide at inflection points.
 967         if (type == 8) {
 968             // quadratic curves can&#39;t have inflection points
 969             ret += c.infPoints(ts, ret);
 970         }
 971 
 972         // now we must subdivide at points where one of the offset curves will have
 973         // a cusp. This happens at ts where the radius of curvature is equal to w.
 974         ret += c.rootsOfROCMinusW(ts, ret, w, 0.0001f);
 975 
 976         ret = Helpers.filterOutNotInAB(ts, 0, ret, 0.0001f, 0.9999f);
 977         Helpers.isort(ts, 0, ret);
 978         return ret;
 979     }
 980 
 981     @Override public void curveTo(float x1, float y1,
 982                                   float x2, float y2,
 983                                   float x3, float y3)
 984     {
 985         middle[0] = cx0; middle[1] = cy0;
 986         middle[2] = x1;  middle[3] = y1;
 987         middle[4] = x2;  middle[5] = y2;
 988         middle[6] = x3;  middle[7] = y3;
 989 
 990         // inlined version of somethingTo(8);
 991         // See the TODO on somethingTo
 992         // (JDK-6675699)
 993 
 994         // need these so we can update the state at the end of this method
 995         final float xf = middle[6], yf = middle[7];
 996         float dxs = middle[2] - middle[0];
 997         float dys = middle[3] - middle[1];
 998         float dxf = middle[6] - middle[4];
 999         float dyf = middle[7] - middle[5];
1000 
1001         boolean p1eqp2 = (dxs == 0f &amp;&amp; dys == 0f);
1002         boolean p3eqp4 = (dxf == 0f &amp;&amp; dyf == 0f);
1003         if (p1eqp2) {
1004             dxs = middle[4] - middle[0];
1005             dys = middle[5] - middle[1];
1006             if (dxs == 0f &amp;&amp; dys == 0f) {
1007                 dxs = middle[6] - middle[0];
1008                 dys = middle[7] - middle[1];
1009             }
1010         }
1011         if (p3eqp4) {
1012             dxf = middle[6] - middle[2];
1013             dyf = middle[7] - middle[3];
1014             if (dxf == 0f &amp;&amp; dyf == 0f) {
1015                 dxf = middle[6] - middle[0];
1016                 dyf = middle[7] - middle[1];
1017             }
1018         }
1019         if (dxs == 0f &amp;&amp; dys == 0f) {
1020             // this happens iff the &quot;curve&quot; is just a point
1021             lineTo(middle[0], middle[1]);
1022             return;
1023         }
1024 
1025         // if these vectors are too small, normalize them, to avoid future
1026         // precision problems.
1027         if (Math.abs(dxs) &lt; 0.1f &amp;&amp; Math.abs(dys) &lt; 0.1f) {
1028             float len = (float)Math.sqrt(dxs*dxs + dys*dys);
1029             dxs /= len;
1030             dys /= len;
1031         }
1032         if (Math.abs(dxf) &lt; 0.1f &amp;&amp; Math.abs(dyf) &lt; 0.1f) {
1033             float len = (float)Math.sqrt(dxf*dxf + dyf*dyf);
1034             dxf /= len;
1035             dyf /= len;
1036         }
1037 
1038         computeOffset(dxs, dys, lineWidth2, offset[0]);
1039         final float mx = offset[0][0];
1040         final float my = offset[0][1];
1041         drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, mx, my);
1042 
1043         int nSplits = findSubdivPoints(middle, subdivTs, 8, lineWidth2);
1044         float prevT = 0f;
1045         for (int i = 0; i &lt; nSplits; i++) {
1046             float t = subdivTs[i];
1047             Helpers.subdivideCubicAt((t - prevT) / (1 - prevT),
1048                                      middle, i*6,
1049                                      middle, i*6,
1050                                      middle, i*6+6);
1051             prevT = t;
1052         }
1053 
1054         int kind = 0;
1055         for (int i = 0; i &lt;= nSplits; i++) {
1056             kind = computeOffsetCubic(middle, i*6, lp, rp);
1057             if (kind != 0) {
1058                 emitLineTo(lp[0], lp[1]);
1059                 switch(kind) {
1060                 case 8:
1061                     emitCurveTo(lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], lp[6], lp[7], false);
1062                     emitCurveTo(rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], rp[6], rp[7], true);
1063                     break;
1064                 case 4:
1065                     emitLineTo(lp[2], lp[3]);
1066                     emitLineTo(rp[0], rp[1], true);
1067                     break;
1068                 }
1069                 emitLineTo(rp[kind - 2], rp[kind - 1], true);
1070             }
1071         }
1072 
1073         this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
1074         this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
1075         this.cdx = dxf;
1076         this.cdy = dyf;
1077         this.cx0 = xf;
1078         this.cy0 = yf;
1079         this.prev = DRAWING_OP_TO;
1080     }
1081 
1082     @Override public void quadTo(float x1, float y1, float x2, float y2) {
1083         middle[0] = cx0; middle[1] = cy0;
1084         middle[2] = x1;  middle[3] = y1;
1085         middle[4] = x2;  middle[5] = y2;
1086 
1087         // inlined version of somethingTo(8);
1088         // See the TODO on somethingTo
1089         // (JDK-6675699)
1090 
1091         // need these so we can update the state at the end of this method
1092         final float xf = middle[4], yf = middle[5];
1093         float dxs = middle[2] - middle[0];
1094         float dys = middle[3] - middle[1];
1095         float dxf = middle[4] - middle[2];
1096         float dyf = middle[5] - middle[3];
1097         if ((dxs == 0f &amp;&amp; dys == 0f) || (dxf == 0f &amp;&amp; dyf == 0f)) {
1098             dxs = dxf = middle[4] - middle[0];
1099             dys = dyf = middle[5] - middle[1];
1100         }
1101         if (dxs == 0f &amp;&amp; dys == 0f) {
1102             // this happens iff the &quot;curve&quot; is just a point
1103             lineTo(middle[0], middle[1]);
1104             return;
1105         }
1106         // if these vectors are too small, normalize them, to avoid future
1107         // precision problems.
1108         if (Math.abs(dxs) &lt; 0.1f &amp;&amp; Math.abs(dys) &lt; 0.1f) {
1109             float len = (float)Math.sqrt(dxs*dxs + dys*dys);
1110             dxs /= len;
1111             dys /= len;
1112         }
1113         if (Math.abs(dxf) &lt; 0.1f &amp;&amp; Math.abs(dyf) &lt; 0.1f) {
1114             float len = (float)Math.sqrt(dxf*dxf + dyf*dyf);
1115             dxf /= len;
1116             dyf /= len;
1117         }
1118 
1119         computeOffset(dxs, dys, lineWidth2, offset[0]);
1120         final float mx = offset[0][0];
1121         final float my = offset[0][1];
1122         drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, mx, my);
1123 
1124         int nSplits = findSubdivPoints(middle, subdivTs, 6, lineWidth2);
1125         float prevt = 0f;
1126         for (int i = 0; i &lt; nSplits; i++) {
1127             float t = subdivTs[i];
1128             Helpers.subdivideQuadAt((t - prevt) / (1 - prevt),
1129                                     middle, i*4,
1130                                     middle, i*4,
1131                                     middle, i*4+4);
1132             prevt = t;
1133         }
1134 
1135         int kind = 0;
1136         for (int i = 0; i &lt;= nSplits; i++) {
1137             kind = computeOffsetQuad(middle, i*4, lp, rp);
1138             if (kind != 0) {
1139                 emitLineTo(lp[0], lp[1]);
1140                 switch(kind) {
1141                 case 6:
1142                     emitQuadTo(lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], false);
1143                     emitQuadTo(rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], true);
1144                     break;
1145                 case 4:
1146                     emitLineTo(lp[2], lp[3]);
1147                     emitLineTo(rp[0], rp[1], true);
1148                     break;
1149                 }
1150                 emitLineTo(rp[kind - 2], rp[kind - 1], true);
1151             }
1152         }
1153 
1154         this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
1155         this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
1156         this.cdx = dxf;
1157         this.cdy = dyf;
1158         this.cx0 = xf;
1159         this.cy0 = yf;
1160         this.prev = DRAWING_OP_TO;
1161     }
1162 
1163 //    @Override public long getNativeConsumer() {
1164 //        throw new InternalError(&quot;Stroker doesn&#39;t use a native consumer&quot;);
1165 //    }
1166 
1167     // a stack of polynomial curves where each curve shares endpoints with
1168     // adjacent ones.
1169     private static final class PolyStack {
1170         float[] curves;
1171         int end;
1172         int[] curveTypes;
1173         int numCurves;
1174 
1175         private static final int INIT_SIZE = 50;
1176 
1177         PolyStack() {
1178             curves = new float[8 * INIT_SIZE];
1179             curveTypes = new int[INIT_SIZE];
1180             end = 0;
1181             numCurves = 0;
1182         }
1183 
1184         public boolean isEmpty() {
1185             return numCurves == 0;
1186         }
1187 
1188         private void ensureSpace(int n) {
1189             if (end + n &gt;= curves.length) {
1190                 int newSize = (end + n) * 2;
1191                 curves = Arrays.copyOf(curves, newSize);
1192             }
1193             if (numCurves &gt;= curveTypes.length) {
1194                 int newSize = numCurves * 2;
1195                 curveTypes = Arrays.copyOf(curveTypes, newSize);
1196             }
1197         }
1198 
1199         public void pushCubic(float x0, float y0,
1200                               float x1, float y1,
1201                               float x2, float y2)
1202         {
1203             ensureSpace(6);
1204             curveTypes[numCurves++] = 8;
1205             // assert(x0 == lastX &amp;&amp; y0 == lastY)
1206 
1207             // we reverse the coordinate order to make popping easier
1208             curves[end++] = x2;    curves[end++] = y2;
1209             curves[end++] = x1;    curves[end++] = y1;
1210             curves[end++] = x0;    curves[end++] = y0;
1211         }
1212 
1213         public void pushQuad(float x0, float y0,
1214                              float x1, float y1)
1215         {
1216             ensureSpace(4);
1217             curveTypes[numCurves++] = 6;
1218             // assert(x0 == lastX &amp;&amp; y0 == lastY)
1219             curves[end++] = x1;    curves[end++] = y1;
1220             curves[end++] = x0;    curves[end++] = y0;
1221         }
1222 
1223         public void pushLine(float x, float y) {
1224             ensureSpace(2);
1225             curveTypes[numCurves++] = 4;
1226             // assert(x0 == lastX &amp;&amp; y0 == lastY)
1227             curves[end++] = x;    curves[end++] = y;
1228         }
1229 
1230         @SuppressWarnings(&quot;unused&quot;)
1231         public int pop(float[] pts) {
1232             int ret = curveTypes[numCurves - 1];
1233             numCurves--;
1234             end -= (ret - 2);
1235             System.arraycopy(curves, end, pts, 0, ret - 2);
1236             return ret;
1237         }
1238 
1239         public void pop(PathConsumer2D io) {
1240             numCurves--;
1241             int type = curveTypes[numCurves];
1242             end -= (type - 2);
1243             switch(type) {
1244             case 8:
1245                 io.curveTo(curves[end+0], curves[end+1],
1246                            curves[end+2], curves[end+3],
1247                            curves[end+4], curves[end+5]);
1248                 break;
1249             case 6:
1250                 io.quadTo(curves[end+0], curves[end+1],
1251                            curves[end+2], curves[end+3]);
1252                  break;
1253             case 4:
1254                 io.lineTo(curves[end], curves[end+1]);
1255             }
1256         }
1257 
1258         @Override
1259         public String toString() {
1260             String ret = &quot;&quot;;
1261             int nc = numCurves;
1262             int last = this.end;
1263             while (nc &gt; 0) {
1264                 nc--;
1265                 int type = curveTypes[numCurves];
1266                 last -= (type - 2);
1267                 switch(type) {
1268                 case 8:
1269                     ret += &quot;cubic: &quot;;
1270                     break;
1271                 case 6:
1272                     ret += &quot;quad: &quot;;
1273                     break;
1274                 case 4:
1275                     ret += &quot;line: &quot;;
1276                     break;
1277                 }
1278                 ret += Arrays.toString(Arrays.copyOfRange(curves, last, last+type-2)) + &quot;\n&quot;;
1279             }
1280             return ret;
1281         }
1282     }
1283 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.graphics/src/main/native-prism/Dasher.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;math.h&gt;
 27 #include &lt;stdlib.h&gt;
 28 #include &lt;string.h&gt;
 29 
 30 #include &quot;PathConsumer.h&quot;
 31 
 32 #include &quot;Helpers.h&quot;
 33 #include &quot;Dasher.h&quot;
 34 
 35 static void LIinitializeIterationOnCurve(LengthIterator *pLI, jfloat pts[], jint type);
 36 static jfloat LInext(LengthIterator *pLI, const jfloat len);
 37 static jfloat LIlastSegLen(LengthIterator *pLI);
 38 static void LIgoLeft(LengthIterator *pLI);
 39 static void LIgoToNextLeaf(LengthIterator *pLI);
 40 static jfloat LIonLeaf(LengthIterator *pLI);
 41 
 42 /**
 43  * The &lt;code&gt;Dasher&lt;/code&gt; class takes a series of linear commands
 44  * (&lt;code&gt;moveTo&lt;/code&gt;, &lt;code&gt;lineTo&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt; and
 45  * &lt;code&gt;end&lt;/code&gt;) and breaks them into smaller segments according to a
 46  * dash pattern array and a starting dash phase.
 47  *
 48  * &lt;p&gt; Issues: in J2Se, a zero length dash segment as drawn as a very
 49  * short dash, whereas Pisces does not draw anything.  The PostScript
 50  * semantics are unclear.
 51  *
 52  */
 53 
 54 static MoveToFunc       Dasher_MoveTo;
 55 static LineToFunc       Dasher_LineTo;
 56 static QuadToFunc       Dasher_QuadTo;
 57 static CurveToFunc      Dasher_CurveTo;
 58 static ClosePathFunc    Dasher_ClosePath;
 59 static PathDoneFunc     Dasher_PathDone;
 60 
 61 #define this (*(Dasher *)pDasher)
 62 
 63     /**
 64      * Constructs a &lt;code&gt;Dasher&lt;/code&gt;.
 65      *
 66      * @param out an output &lt;code&gt;PathConsumer2D&lt;/code&gt;.
 67      * @param dash an array of &lt;code&gt;float&lt;/code&gt;s containing the dash pattern
 68      * @param phase a &lt;code&gt;float&lt;/code&gt; containing the dash phase
 69     public Dasher(PathConsumer2D out, float[] dash, float phase) {
 70         this(out);
 71         reset(dash, phase);
 72     }
 73 
 74     public Dasher(PathConsumer2D out) {
 75         this.out = out;
 76 
 77         // we need curCurvepts to be able to contain 2 curves because when
 78         // dashing curves, we need to subdivide it
 79         curCurvepts = new float[8 * 2];
 80     }
 81      */
 82 
 83 void Dasher_init(Dasher *pDasher,
 84                  PathConsumer *out,
 85                  jfloat dash[], jint numdashes,
 86                  jfloat phase)
 87 {
 88     memset(pDasher, 0, sizeof(Dasher));
 89     PathConsumer_init(&amp;this.consumer,
 90                       Dasher_MoveTo,
 91                       Dasher_LineTo,
 92                       Dasher_QuadTo,
 93                       Dasher_CurveTo,
 94                       Dasher_ClosePath,
 95                       Dasher_PathDone);
 96 
 97     this.firstSegmentsBufferSIZE = 7;
 98     this.firstSegmentsBuffer = new_float(this.firstSegmentsBufferSIZE);
 99     this.firstSegidx = 0;
100 
101     this.out = out;
102     Dasher_reset(pDasher, dash, numdashes, phase);
103 }
104 
105 #define MAX_CYCLES 16000000.0f
106 void Dasher_reset(Dasher *pDasher, jfloat dash[], jint ndashes, jfloat phase) {
107     jint sidx;
108     jfloat d, sum, cycles;
109     jint i;
110 
111     // Normalize so 0 &lt;= phase &lt; dash[0]
112     sidx = 0;
113     this.dashOn = JNI_TRUE;
114     sum = 0.0f;
115     for (i = 0; i &lt; ndashes; i++) {
116         sum += dash[i];
117     }
118     cycles = phase / sum;
119     if (phase &lt; 0) {
120         if (-cycles &gt;= MAX_CYCLES) {
121             phase = 0;
122         } else {
123             jint fullcycles = (jint) floor(-cycles);
124             if ((fullcycles &amp; ndashes &amp; 1) != 0) {
125                 this.dashOn = !this.dashOn;
126             }
127             phase += fullcycles * sum;
128             while (phase &lt; 0) {
129                 if (--sidx &lt; 0) sidx = ndashes-1;
130                 phase += dash[sidx];
131                 this.dashOn = !this.dashOn;
132             }
133         }
134     } else if (phase &gt; 0) {
135         if (cycles &gt;= MAX_CYCLES) {
136             phase = 0;
137         } else {
138             jint fullcycles = (jint) floor(cycles);
139             if ((fullcycles &amp; ndashes &amp; 1) != 0) {
140                 this.dashOn = !this.dashOn;
141             }
142             phase -= fullcycles * sum;
143             while (phase &gt;= (d = dash[sidx])) {
144                 phase -= d;
145                 sidx = (sidx + 1) % ndashes;
146                 this.dashOn = !this.dashOn;
147             }
148         }
149     }
150 
151     this.dash = dash;
152     this.numdashes = ndashes;
153     this.startPhase = this.phase = phase;
154     this.startDashOn = this.dashOn;
155     this.startIdx = sidx;
156     this.starting = JNI_TRUE;
157 }
158 
159 void Dasher_destroy(Dasher *pDasher) {
160     free(pDasher-&gt;firstSegmentsBuffer);
161     pDasher-&gt;firstSegmentsBuffer = NULL;
162     pDasher-&gt;firstSegmentsBufferSIZE = 0;
163 }
164 
165 static jint emitSeg(PathConsumer *pDasher, jfloat buf[], jint off, jint type) {
166     switch (type) {
167     case 8:
168         return this.out-&gt;curveTo(this.out,
169                           buf[off+0], buf[off+1],
170                           buf[off+2], buf[off+3],
171                           buf[off+4], buf[off+5]);
172         break;
173     case 6:
174         return this.out-&gt;quadTo(this.out,
175                          buf[off+0], buf[off+1],
176                          buf[off+2], buf[off+3]);
177         break;
178     case 4:
179         return this.out-&gt;lineTo(this.out, buf[off], buf[off+1]);
180     }
181     return ERROR_NONE;
182 }
183 
184 static jint emitFirstSegments(PathConsumer *pDasher) {
185     jint i;
186     for (i = 0; i &lt; this.firstSegidx; ) {
187         jint status;
188         status = emitSeg(pDasher, this.firstSegmentsBuffer, i+1, (jint) this.firstSegmentsBuffer[i]);
189         if (status != ERROR_NONE) {
190             return status;
191         }
192         i += (((jint) this.firstSegmentsBuffer[i]) - 1);
193     }
194     this.firstSegidx = 0;
195     return ERROR_NONE;
196 }
197 
198 // precondition: pts must be in relative coordinates (relative to x0,y0)
199 // fullCurve is true iff the curve in pts has not been split.
200 static jint goTo(PathConsumer *pDasher, jfloat pts[], jint off, jint type) {
201     jint status = ERROR_NONE;
202     jfloat x = pts[off + type - 4];
203     jfloat y = pts[off + type - 3];
204     if (this.dashOn) {
205         if (this.starting) {
206             if (this.firstSegmentsBufferSIZE &lt; this.firstSegidx + (type-1)) {
207                 jint newSize = (this.firstSegidx + (type-1)) * 2;
208                 jfloat *newSegs = new_float(newSize);
209                 if (!newSegs) {
210                     return ERROR_OOM;
211                 }
212                 System_arraycopy(this.firstSegmentsBuffer, 0, newSegs, 0, this.firstSegidx);
213                 free(this.firstSegmentsBuffer);
214                 this.firstSegmentsBuffer = newSegs;
215                 this.firstSegmentsBufferSIZE = newSize;
216             }
217             this.firstSegmentsBuffer[this.firstSegidx++] = (jfloat) type;
218             System_arraycopy(pts, off, this.firstSegmentsBuffer, this.firstSegidx, type - 2);
219             this.firstSegidx += type - 2;
220         } else {
221             if (this.needsMoveTo) {
222                 status = this.out-&gt;moveTo(this.out, this.x0, this.y0);
223                 if (status != ERROR_NONE) {
224                     return status;
225                 }
226                 this.needsMoveTo = JNI_FALSE;
227             }
228             status = emitSeg(pDasher, pts, off, type);
229             if (status != ERROR_NONE) {
230                 return status;
231             }
232         }
233     } else {
234         this.starting = JNI_FALSE;
235         this.needsMoveTo = JNI_TRUE;
236     }
237     this.x0 = x;
238     this.y0 = y;
239     return status;
240 }
241 
242 static jint Dasher_MoveTo(PathConsumer *pDasher, jfloat newx0, jfloat newy0) {
243     jint status = ERROR_NONE;
244     if (this.firstSegidx &gt; 0) {
245         status = this.out-&gt;moveTo(this.out, this.sx, this.sy);
246         if (status != ERROR_NONE) {
247             return status;
248         }
249         status = emitFirstSegments(pDasher);
250         if (status != ERROR_NONE) {
251             return status;
252         }
253     }
254     this.needsMoveTo = JNI_TRUE;
255     this.idx = this.startIdx;
256     this.dashOn = this.startDashOn;
257     this.phase = this.startPhase;
258     this.sx = this.x0 = newx0;
259     this.sy = this.y0 = newy0;
260     this.starting = JNI_TRUE;
261     return status;
262 }
263 
264 static jint Dasher_LineTo(PathConsumer *pDasher, jfloat x1, jfloat y1) {
265     jint status = ERROR_NONE;
266     jfloat cx, cy;
267     jfloat dx = x1 - this.x0;
268     jfloat dy = y1 - this.y0;
269 
270     jfloat len = (jfloat) sqrt(dx*dx + dy*dy);
271 
272     if (len == 0) {
273         return status;
274     }
275 
276     // The scaling factors needed to get the dx and dy of the
277     // transformed dash segments.
278     cx = dx / len;
279     cy = dy / len;
280 
281     while (1) {
282         jfloat dashdx, dashdy;
283         jfloat leftInThisDashSegment = this.dash[this.idx] - this.phase;
284         if (len &lt;= leftInThisDashSegment) {
285             this.curCurvepts[0] = x1;
286             this.curCurvepts[1] = y1;
287             status = goTo(pDasher, this.curCurvepts, 0, 4);
288             if (status != ERROR_NONE) {
289                 return status;
290             }
291             // Advance phase within current dash segment
292             this.phase += len;
293             if (len == leftInThisDashSegment) {
294                 this.phase = 0.0f;
295                 this.idx = (this.idx + 1) % this.numdashes;
296                 this.dashOn = !this.dashOn;
297             }
298             return status;
299         }
300 
301         dashdx = this.dash[this.idx] * cx;
302         dashdy = this.dash[this.idx] * cy;
303         if (this.phase == 0) {
304             this.curCurvepts[0] = this.x0 + dashdx;
305             this.curCurvepts[1] = this.y0 + dashdy;
306         } else {
307             jfloat p = leftInThisDashSegment / this.dash[this.idx];
308             this.curCurvepts[0] = this.x0 + p * dashdx;
309             this.curCurvepts[1] = this.y0 + p * dashdy;
310         }
311 
312         status = goTo(pDasher, this.curCurvepts, 0, 4);
313         if (status != ERROR_NONE) {
314             return status;
315         }
316 
317         len -= leftInThisDashSegment;
318         // Advance to next dash segment
319         this.idx = (this.idx + 1) % this.numdashes;
320         this.dashOn = !this.dashOn;
321         this.phase = 0;
322     }
323     return status;
324 }
325 
326 static jboolean pointCurve(jfloat curve[], jint type) {
327     jint i;
328     for (i = 2; i &lt; type; i++) {
329         if (curve[i] != curve[i-2]) {
330             return JNI_FALSE;
331         }
332     }
333     return JNI_TRUE;
334 }
335 
336 //    private LengthIterator li = null;
337 
338 // preconditions: curCurvepts must be an array of length at least 2 * type,
339 // that contains the curve we want to dash in the first type elements
340 static jint somethingTo(PathConsumer *pDasher, jint type) {
341     jint status = ERROR_NONE;
342     jint curCurveoff;
343     jfloat lastSplitT;
344     jfloat t;
345     jfloat leftInThisDashSegment;
346 
347     if (pointCurve(this.curCurvepts, type)) {
348         return status;
349     }
350     LIinitializeIterationOnCurve(&amp;this.li, this.curCurvepts, type);
351 
352     curCurveoff = 0; // initially the current curve is at curCurvepts[0...type]
353     lastSplitT = 0;
354     t = 0;
355     leftInThisDashSegment = this.dash[this.idx] - this.phase;
356     while ((t = LInext(&amp;this.li, leftInThisDashSegment)) &lt; 1) {
357         if (t != 0) {
358             Helpers_subdivideAt((t - lastSplitT) / (1 - lastSplitT),
359                                 this.curCurvepts, curCurveoff,
360                                 this.curCurvepts, 0,
361                                 this.curCurvepts, type, type);
362             lastSplitT = t;
363             status = goTo(pDasher, this.curCurvepts, 2, type);
364             if (status != ERROR_NONE) {
365                 return status;
366             }
367             curCurveoff = type;
368         }
369         // Advance to next dash segment
370         this.idx = (this.idx + 1) % this.numdashes;
371         this.dashOn = !this.dashOn;
372         this.phase = 0;
373         leftInThisDashSegment = this.dash[this.idx];
374     }
375     status = goTo(pDasher, this.curCurvepts, curCurveoff+2, type);
376     if (status != ERROR_NONE) {
377         return status;
378     }
379     this.phase += LIlastSegLen(&amp;this.li);
380     if (this.phase &gt;= this.dash[this.idx]) {
381         this.phase = 0.0f;
382         this.idx = (this.idx + 1) % this.numdashes;
383         this.dashOn = !this.dashOn;
384     }
385     return status;
386 }
387 
388 static jint Dasher_CurveTo(PathConsumer *pDasher,
389                            jfloat x1, jfloat y1,
390                            jfloat x2, jfloat y2,
391                            jfloat x3, jfloat y3)
392 {
393     this.curCurvepts[0] = this.x0;   this.curCurvepts[1] = this.y0;
394     this.curCurvepts[2] = x1;        this.curCurvepts[3] = y1;
395     this.curCurvepts[4] = x2;        this.curCurvepts[5] = y2;
396     this.curCurvepts[6] = x3;        this.curCurvepts[7] = y3;
397     return somethingTo(pDasher, 8);
398 }
399 
400 static jint Dasher_QuadTo(PathConsumer *pDasher,
401                           jfloat x1, jfloat y1,
402                           jfloat x2, jfloat y2)
403 {
404     this.curCurvepts[0] = this.x0;   this.curCurvepts[1] = this.y0;
405     this.curCurvepts[2] = x1;        this.curCurvepts[3] = y1;
406     this.curCurvepts[4] = x2;        this.curCurvepts[5] = y2;
407     return somethingTo(pDasher, 6);
408 }
409 
410 static jint Dasher_ClosePath(PathConsumer *pDasher) {
411     jint status = ERROR_NONE;
412     status = Dasher_LineTo(pDasher, this.sx, this.sy);
413     if (status != ERROR_NONE) {
414         return status;
415     }
416     if (this.firstSegidx &gt; 0) {
417         if (!this.dashOn || this.needsMoveTo) {
418             status = this.out-&gt;moveTo(this.out, this.sx, this.sy);
419             if (status != ERROR_NONE) {
420                 return status;
421             }
422         }
423         status = emitFirstSegments(pDasher);
424         if (status != ERROR_NONE) {
425             return status;
426         }
427     }
428     return Dasher_MoveTo(pDasher, this.sx, this.sy);
429 }
430 
431 static jint Dasher_PathDone(PathConsumer *pDasher) {
432     jint status = ERROR_NONE;
433     if (this.firstSegidx &gt; 0) {
434         status = this.out-&gt;moveTo(this.out, this.sx, this.sy);
435         if (status != ERROR_NONE) {
436             return status;
437         }
438         status = emitFirstSegments(pDasher);
439         if (status != ERROR_NONE) {
440             return status;
441         }
442     }
443     return this.out-&gt;pathDone(this.out);
444 }
445 
446 
447 /*
448         public LengthIterator(jint reclimit, float err) {
449             this.limit = reclimit;
450             this.minTincrement = 1f / (1 &lt;&lt; limit);
451             this.ERR = err;
452             this.recCurveStack = new float[reclimit+1][8];
453             this.sides = new Side[reclimit];
454             // if any methods are called without first initializing this object on
455             // a curve, we want it to fail ASAP.
456             this.nextT = Float.MAX_VALUE;
457             this.lenAtNextT = Float.MAX_VALUE;
458             this.lenAtLastSplit = Float.MIN_VALUE;
459             this.recLevel = Integer.MIN_VALUE;
460             this.lastSegLen = Float.MAX_VALUE;
461             this.done = true;
462         }
463  */
464 
465 #undef this
466 #define this (*((LengthIterator *) pLI))
467 
468 static void LIinitializeIterationOnCurve(LengthIterator *pLI, jfloat pts[], jint type) {
469     System_arraycopy(pts, 0, this.recCurveStack[0], 0, type);
470     this.curveType = type;
471     this.recLevel = 0;
472     this.lastT = 0;
473     this.lenAtLastT = 0;
474     this.nextT = 0;
475     this.lenAtNextT = 0;
476     LIgoLeft(pLI); // initializes nextT and lenAtNextT properly
477     this.lenAtLastSplit = 0;
478     if (this.recLevel &gt; 0) {
479         this.sides[0] = LEFT;
480         this.done = JNI_FALSE;
481     } else {
482         // the root of the tree is a leaf so we&#39;re done.
483         this.sides[0] = RIGHT;
484         this.done = JNI_TRUE;
485     }
486     this.lastSegLen = 0;
487     this.cachedHaveLowAcceleration = -1;
488     /* = {0, 0, -1, 0}*/;
489     this.flatLeafCoefCache[0] = 0;
490     this.flatLeafCoefCache[1] = 0;
491     this.flatLeafCoefCache[2] = -1;
492     this.flatLeafCoefCache[3] = 0;
493 }
494 
495 static jboolean LIhaveLowAcceleration(LengthIterator *pLI, jfloat err) {
496     if (this.cachedHaveLowAcceleration == -1) {
497         const jfloat len1 = this.curLeafCtrlPolyLengths[0];
498         const jfloat len2 = this.curLeafCtrlPolyLengths[1];
499         // the test below is equivalent to !within(len1/len2, 1, err).
500         // It is using a multiplication instead of a division, so it
501         // should be a bit faster.
502         if (!Helpers_within(len1, len2, err*len2)) {
503             this.cachedHaveLowAcceleration = 0;
504             return JNI_FALSE;
505         }
506         if (this.curveType == 8) {
507             const jfloat len3 = this.curLeafCtrlPolyLengths[2];
508             // if len1 is close to 2 and 2 is close to 3, that probably
509             // means 1 is close to 3 so the second part of this test might
510             // not be needed, but it doesn&#39;t hurt to include it.
511             if (!(Helpers_within(len2, len3, err*len3) &amp;&amp;
512                   Helpers_within(len1, len3, err*len3)))
513             {
514                 this.cachedHaveLowAcceleration = 0;
515                 return JNI_FALSE;
516             }
517         }
518         this.cachedHaveLowAcceleration = 1;
519         return JNI_TRUE;
520     }
521 
522     return (this.cachedHaveLowAcceleration == 1);
523 }
524 
525 // returns the t value where the remaining curve should be split in
526 // order for the left subdivided curve to have length len. If len
527 // is &gt;= than the length of the uniterated curve, it returns 1.
528 static jfloat LInext(LengthIterator *pLI, const jfloat len) {
529     const jfloat targetLength = this.lenAtLastSplit + len;
530     jfloat leaflen;
531     jfloat t;
532     while(this.lenAtNextT &lt; targetLength) {
533         if (this.done) {
534             this.lastSegLen = this.lenAtNextT - this.lenAtLastSplit;
535             return 1;
536         }
537         LIgoToNextLeaf(pLI);
538     }
539     this.lenAtLastSplit = targetLength;
540     leaflen = this.lenAtNextT - this.lenAtLastT;
541     t = (targetLength - this.lenAtLastT) / leaflen;
542 
543     // cubicRootsInAB is a fairly expensive call, so we just don&#39;t do it
544     // if the acceleration in this section of the curve is small enough.
545     if (!LIhaveLowAcceleration(pLI, 0.05f)) {
546         jfloat a, b, c, d;
547         jint n;
548         // We flatten the current leaf along the x axis, so that we&#39;re
549         // left with a, b, c which define a 1D Bezier curve. We then
550         // solve this to get the parameter of the original leaf that
551         // gives us the desired length.
552 
553         if (this.flatLeafCoefCache[2] &lt; 0) {
554             jfloat x = 0+this.curLeafCtrlPolyLengths[0],
555                     y = x+this.curLeafCtrlPolyLengths[1];
556             if (this.curveType == 8) {
557                 jfloat z = y + this.curLeafCtrlPolyLengths[2];
558                 this.flatLeafCoefCache[0] = 3*(x - y) + z;
559                 this.flatLeafCoefCache[1] = 3*(y - 2*x);
560                 this.flatLeafCoefCache[2] = 3*x;
561                 this.flatLeafCoefCache[3] = -z;
562             } else if (this.curveType == 6) {
563                 this.flatLeafCoefCache[0] = 0.0f;
564                 this.flatLeafCoefCache[1] = y - 2*x;
565                 this.flatLeafCoefCache[2] = 2*x;
566                 this.flatLeafCoefCache[3] = -y;
567             }
568         }
569         a = this.flatLeafCoefCache[0];
570         b = this.flatLeafCoefCache[1];
571         c = this.flatLeafCoefCache[2];
572         d = t*this.flatLeafCoefCache[3];
573 
574         // we use cubicRootsInAB here, because we want only roots in 0, 1,
575         // and our quadratic root finder doesn&#39;t filter, so it&#39;s just a
576         // matter of convenience.
577         n = Helpers_cubicRootsInAB(a, b, c, d, this.nextRoots, 0, 0, 1);
578         if (n == 1 &amp;&amp; !Math_isnan(this.nextRoots[0])) {
579             t = this.nextRoots[0];
580         }
581     }
582     // t is relative to the current leaf, so we must make it a valid parameter
583     // of the original curve.
584     t = t * (this.nextT - this.lastT) + this.lastT;
585     if (t &gt;= 1) {
586         t = 1;
587         this.done = JNI_TRUE;
588     }
589     // even if done = true, if we&#39;re here, that means targetLength
590     // is equal to, or very, very close to the total length of the
591     // curve, so lastSegLen won&#39;t be too high. In cases where len
592     // overshoots the curve, this method will exit in the while
593     // loop, and lastSegLen will still be set to the right value.
594     this.lastSegLen = len;
595     return t;
596 }
597 
598 static jfloat LIlastSegLen(LengthIterator *pLI) {
599     return this.lastSegLen;
600 }
601 
602 // go to the next leaf (in an inorder traversal) in the recursion tree
603 // preconditions: must be on a leaf, and that leaf must not be the root.
604 static void LIgoToNextLeaf(LengthIterator *pLI) {
605     // We must go to the first ancestor node that has an unvisited
606     // right child.
607     this.recLevel--;
608     while(this.sides[this.recLevel] == RIGHT) {
609         if (this.recLevel == 0) {
610             this.done = JNI_TRUE;
611             return;
612         }
613         this.recLevel--;
614     }
615 
616     this.sides[this.recLevel] = RIGHT;
617     System_arraycopy(this.recCurveStack[this.recLevel], 0,
618                      this.recCurveStack[this.recLevel+1], 0, this.curveType);
619     this.recLevel++;
620     LIgoLeft(pLI);
621 }
622 
623 // go to the leftmost node from the current node. Return its length.
624 static void LIgoLeft(LengthIterator *pLI) {
625     jfloat len = LIonLeaf(pLI);
626     if (len &gt;= 0) {
627         this.lastT = this.nextT;
628         this.lenAtLastT = this.lenAtNextT;
629         this.nextT += (1 &lt;&lt; (REC_LIMIT - this.recLevel)) * MIN_T_INCREMENT;
630         this.lenAtNextT += len;
631         // invalidate caches
632         this.flatLeafCoefCache[2] = -1;
633         this.cachedHaveLowAcceleration = -1;
634     } else {
635         Helpers_subdivide(this.recCurveStack[this.recLevel], 0,
636                           this.recCurveStack[this.recLevel+1], 0,
637                           this.recCurveStack[this.recLevel], 0, this.curveType);
638         this.sides[this.recLevel] = LEFT;
639         this.recLevel++;
640         LIgoLeft(pLI);
641     }
642 }
643 
644 // this is a bit of a hack. It returns -1 if we&#39;re not on a leaf, and
645 // the length of the leaf if we are on a leaf.
646 static jfloat LIonLeaf(LengthIterator *pLI) {
647     jfloat *curve = this.recCurveStack[this.recLevel];
648     jfloat polyLen = 0;
649     jfloat lineLen;
650 
651     jfloat x0 = curve[0], y0 = curve[1];
652     jint i;
653     for (i = 2; i &lt; this.curveType; i += 2) {
654         const jfloat x1 = curve[i], y1 = curve[i+1];
655         const jfloat len = Helpers_linelen(x0, y0, x1, y1);
656         polyLen += len;
657         this.curLeafCtrlPolyLengths[i/2 - 1] = len;
658         x0 = x1;
659         y0 = y1;
660     }
661 
662     lineLen = Helpers_linelen(curve[0], curve[1], curve[this.curveType-2], curve[this.curveType-1]);
663     if (polyLen - lineLen &lt; ERR || this.recLevel == REC_LIMIT) {
664         return (polyLen + lineLen)/2;
665     }
666     return -1;
667 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.graphics/src/main/native-prism/Renderer.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;math.h&gt;
 27 #include &lt;stdlib.h&gt;
 28 #include &lt;jni.h&gt;
 29 #include &lt;string.h&gt;
 30 
 31 #include &quot;Helpers.h&quot;
 32 #include &quot;Renderer.h&quot;
 33 #include &quot;AlphaConsumer.h&quot;
 34 
 35 //public final class Renderer implements PathConsumer2D {
 36 
 37 //    private final class ScanlineIterator {
 38 
 39 #define this (*((ScanlineIterator *) pIterator))
 40 
 41 static void ScanlineIterator_reset(ScanlineIterator *pIterator,
 42                                    Renderer *pRenderer);
 43 
 44 static void ScanlineIterator_init(ScanlineIterator *pIterator,
 45                                   Renderer *pRenderer)
 46 {
 47     this.crossings = new_int(INIT_CROSSINGS_SIZE);
 48     this.crossingsSIZE = INIT_CROSSINGS_SIZE;
 49     this.edgePtrs = new_int(INIT_CROSSINGS_SIZE);
 50     this.edgePtrsSIZE = INIT_CROSSINGS_SIZE;
 51     ScanlineIterator_reset(pIterator, pRenderer);
 52 }
 53 
 54 static void ScanlineIterator_destroy(ScanlineIterator *pIterator) {
 55     free(this.crossings);
 56     this.crossings = NULL;
 57     this.crossingsSIZE = 0;
 58     free(this.edgePtrs);
 59     this.edgePtrs = NULL;
 60     this.edgePtrsSIZE = 0;
 61 }
 62 
 63 static void ScanlineIterator_reset(ScanlineIterator *pIterator,
 64                                    Renderer *pRenderer)
 65 {
 66     // We don&#39;t care if we clip some of the line off with ceil, since
 67     // no scan line crossings will be eliminated (in fact, the ceil is
 68     // the y of the first scan line crossing).
 69     this.nextY = pRenderer-&gt;sampleRowMin;
 70     this.edgeCount = 0;
 71 }
 72 
 73 // Iterate to the next scanline and return the number of crossings.
 74 // A count of -1 is returned to indicate OOM.
 75 static jint ScanlineIterator_next(ScanlineIterator *pIterator, Renderer *pRenderer) {
 76     jint i, ecur;
 77     jint *xings;
 78     // NOTE: make function that convert from y value to bucket idx?
 79     jint cury = this.nextY++;
 80     jint bucket = cury - pRenderer-&gt;boundsMinY;
 81     jint count = this.edgeCount;
 82     jint *ptrs = this.edgePtrs;
 83     jfloat *edges = pRenderer-&gt;edges;
 84     jint bucketcount = pRenderer-&gt;edgeBuckets[bucket*2 + 1];
 85 
 86     if ((bucketcount &amp; 0x1) != 0) {
 87         jint newCount = 0;
 88         jint i;
 89         for (i = 0; i &lt; count; i++) {
 90             jint ecur = ptrs[i];
 91             if (edges[ecur+YMAX] &gt; cury) {
 92                 ptrs[newCount++] = ecur;
 93             }
 94         }
 95         count = newCount;
 96     }
 97     if (this.edgePtrsSIZE &lt; count + (bucketcount &gt;&gt; 1)) {
 98         jint newSize = (count + (bucketcount &gt;&gt; 1)) * 2;
 99         jint *newPtrs = new_int(newSize);
100         if (!newPtrs) {
101             return -1;
102         }
103         System_arraycopy(this.edgePtrs, 0, newPtrs, 0, count);
104         free(this.edgePtrs);
105         this.edgePtrs = newPtrs;
106         this.edgePtrsSIZE = newSize;
107     }
108     ptrs = this.edgePtrs;
109     for (ecur = pRenderer-&gt;edgeBuckets[bucket*2];
110          ecur != 0;
111          ecur = (jint) edges[ecur+NEXT])
112     {
113         ptrs[count++] = --ecur;
114         // REMIND: Adjust start Y if necessary
115     }
116     this.edgePtrs = ptrs;
117     this.edgeCount = count;
118 //    if ((count &amp; 0x1) != 0) {
119 //        System.out.println(&quot;ODD NUMBER OF EDGES!!!!&quot;);
120 //    }
121     xings = this.crossings;
122     if (this.crossingsSIZE &lt; count) {
123         free(this.crossings);
124         this.crossings = xings = new_int(this.edgePtrsSIZE);
125         if (!xings) {
126             return -1;
127         }
128         this.crossingsSIZE = this.edgePtrsSIZE;
129     }
130     for (i = 0; i &lt; count; i++) {
131         jint ecur = ptrs[i];
132         jfloat curx = edges[ecur+CURX];
133         jint cross = ((jint) ceil(curx - 0.5f)) &lt;&lt; 1;
134         jint j;
135         edges[ecur+CURX] = curx + edges[ecur+SLOPE];
136         if (edges[ecur+OR] &gt; 0) {
137             cross |= 1;
138         }
139         j = i;
140         while (--j &gt;= 0) {
141             jint jcross = xings[j];
142             if (jcross &lt;= cross) {
143                 break;
144             }
145             xings[j+1] = jcross;
146             ptrs[j+1] = ptrs[j];
147         }
148         xings[j+1] = cross;
149         ptrs[j+1] = ecur;
150     }
151     return count;
152 }
153 
154 static jboolean ScanlineIterator_hasNext(ScanlineIterator *pIterator, Renderer *pRenderer) {
155     return this.nextY &lt; pRenderer-&gt;sampleRowMax;
156 }
157 
158 static jint ScanlineIterator_curY(ScanlineIterator *pIterator) {
159     return this.nextY - 1;
160 }
161 
162 #undef this
163 #define this (*((Renderer *) pRenderer))
164 
165 //////////////////////////////////////////////////////////////////////////////
166 //  EDGE LIST
167 //////////////////////////////////////////////////////////////////////////////
168 // NOTE(maybe): very tempting to use fixed point here. A lot of opportunities
169 // for shifts and just removing certain operations altogether.
170 
171 
172 // each bucket is a linked list. this method adds eptr to the
173 // start &quot;bucket&quot;th linked list.
174 static jint addEdgeToBucket(PathConsumer *pRenderer, const jint eptr, const jint bucket) {
175     // we could implement this in terms of insertEdge, but this is a special
176     // case, so we optimize a bit.
177     if (this.edgeBuckets[bucket*2] &gt;= MAX_EDGE_IDX) {
178         return ERROR_AIOOBE;
179     }
180     this.edges[eptr+NEXT] = (jfloat) this.edgeBuckets[bucket*2];
181     this.edgeBuckets[bucket*2] = eptr + 1;
182     this.edgeBuckets[bucket*2 + 1] += 2;
183     return ERROR_NONE;
184 }
185 
186 static jint addLine(PathConsumer *pRenderer,
187                     jfloat x1, jfloat y1,
188                     jfloat x2, jfloat y2);
189 
190 // Flattens using adaptive forward differencing. This only carries out
191 // one iteration of the AFD loop. All it does is update AFD variables (i.e.
192 // X0, Y0, D*[X|Y], COUNT; not variables used for computing scanline crossings).
193 static jint quadBreakIntoLinesAndAdd(PathConsumer *pRenderer,
194                                      jfloat x0, jfloat y0,
195                                      const Curve c,
196                                      const jfloat x2, const jfloat y2)
197 {
198     jint status = ERROR_NONE;
199     jfloat ddx, ddy, dx, dy;
200     const jfloat QUAD_DEC_BND = 32;
201     const jint countlg = 4;
202     jint count = 1 &lt;&lt; countlg;
203     jint countsq = count * count;
204     jfloat maxDD = Math_max(c.dbx / countsq, c.dby / countsq);
205     while (maxDD &gt; QUAD_DEC_BND) {
206         maxDD /= 4;
207         count &lt;&lt;= 1;
208     }
209 
210     countsq = count * count;
211     ddx = c.dbx / countsq;
212     ddy = c.dby / countsq;
213     dx = c.bx / countsq + c.cx / count;
214     dy = c.by / countsq + c.cy / count;
215 
216     while (count-- &gt; 1) {
217         jfloat x1 = x0 + dx;
218         jfloat y1 = y0 + dy;
219         dx += ddx;
220         dy += ddy;
221         status = addLine(pRenderer, x0, y0, x1, y1);
222         if (status != ERROR_NONE) {
223             return status;
224         }
225         x0 = x1;
226         y0 = y1;
227     }
228     return addLine(pRenderer, x0, y0, x2, y2);
229 }
230 
231 // x0, y0 and x3,y3 are the endpoints of the curve. We could compute these
232 // using c.xat(0),c.yat(0) and c.xat(1),c.yat(1), but this might introduce
233 // numerical errors, and our callers already have the exact values.
234 // Another alternative would be to pass all the control points, and call c.set
235 // here, but then too many numbers are passed around.
236 static jint curveBreakIntoLinesAndAdd(PathConsumer *pRenderer,
237                                       jfloat x0, jfloat y0,
238                                       const Curve c,
239                                       const jfloat x3, const jfloat y3)
240 {
241     jint status = ERROR_NONE;
242     const jint countlg = 3;
243     jint count = 1 &lt;&lt; countlg;
244     jfloat x1, y1;
245 
246     // the dx and dy refer to forward differencing variables, not the last
247     // coefficients of the &quot;points&quot; polynomial
248     jfloat dddx, dddy, ddx, ddy, dx, dy;
249     dddx = 2.0f * c.dax / (1 &lt;&lt; (3 * countlg));
250     dddy = 2.0f * c.day / (1 &lt;&lt; (3 * countlg));
251 
252     ddx = dddx + c.dbx / (1 &lt;&lt; (2 * countlg));
253     ddy = dddy + c.dby / (1 &lt;&lt; (2 * countlg));
254     dx = c.ax / (1 &lt;&lt; (3 * countlg)) + c.bx / (1 &lt;&lt; (2 * countlg)) + c.cx / (1 &lt;&lt; countlg);
255     dy = c.ay / (1 &lt;&lt; (3 * countlg)) + c.by / (1 &lt;&lt; (2 * countlg)) + c.cy / (1 &lt;&lt; countlg);
256 
257     // we use x0, y0 to walk the line
258     x1 = x0;
259     y1 = y0;
260     while (count &gt; 0) {
261         while (fabs(ddx) &gt; DEC_BND || fabs(ddy) &gt; DEC_BND) {
262             dddx /= 8;
263             dddy /= 8;
264             ddx = ddx/4 - dddx;
265             ddy = ddy/4 - dddy;
266             dx = (dx - ddx) / 2;
267             dy = (dy - ddy) / 2;
268             count &lt;&lt;= 1;
269         }
270         // can only do this on even &quot;count&quot; values, because we must divide count by 2
271         while (count % 2 == 0 &amp;&amp; fabs(dx) &lt;= INC_BND &amp;&amp; fabs(dy) &lt;= INC_BND) {
272             dx = 2 * dx + ddx;
273             dy = 2 * dy + ddy;
274             ddx = 4 * (ddx + dddx);
275             ddy = 4 * (ddy + dddy);
276             dddx = 8 * dddx;
277             dddy = 8 * dddy;
278             count &gt;&gt;= 1;
279         }
280         count--;
281         if (count &gt; 0) {
282             x1 += dx;
283             dx += ddx;
284             ddx += dddx;
285             y1 += dy;
286             dy += ddy;
287             ddy += dddy;
288         } else {
289             x1 = x3;
290             y1 = y3;
291         }
292         status = addLine(pRenderer, x0, y0, x1, y1);
293         if (status != ERROR_NONE) {
294             return status;
295         }
296         x0 = x1;
297         y0 = y1;
298     }
299     return status;
300 }
301 
302 static jint addLine(PathConsumer *pRenderer,
303                     jfloat x1, jfloat y1,
304                     jfloat x2, jfloat y2)
305 {
306     jint status = ERROR_NONE;
307     jfloat or = 1; // orientation of the line. 1 if y increases, 0 otherwise.
308     jint firstCrossing, lastCrossing;
309     jfloat slope;
310     jint ptr, bucketIdx;
311 
312     if (y2 &lt; y1) {
313         or = y2; // no need to declare a temp variable. We have or.
314         y2 = y1;
315         y1 = or;
316         or = x2;
317         x2 = x1;
318         x1 = or;
319         or = 0;
320     }
321     firstCrossing = Math_max((jint) ceil(y1 - 0.5f), this.boundsMinY);
322     lastCrossing = Math_min((jint) ceil(y2 - 0.5f), this.boundsMaxY);
323     if (firstCrossing &gt;= lastCrossing) {
324         return status;
325     }
326     if (firstCrossing &lt; this.sampleRowMin) { this.sampleRowMin = firstCrossing; }
327     if (lastCrossing &gt; this.sampleRowMax) { this.sampleRowMax = lastCrossing; }
328 
329     slope = (x2 - x1) / (y2 - y1);
330 
331     if (slope &gt; 0) { // &lt;==&gt; x1 &lt; x2
332         if (x1 &lt; this.edgeMinX) { this.edgeMinX = x1; }
333         if (x2 &gt; this.edgeMaxX) { this.edgeMaxX = x2; }
334     } else {
335         if (x2 &lt; this.edgeMinX) { this.edgeMinX = x2; }
336         if (x1 &gt; this.edgeMaxX) { this.edgeMaxX = x1; }
337     }
338 
339     bucketIdx = firstCrossing - this.boundsMinY;
340     if (this.edgeBuckets[bucketIdx*2] &gt;= MAX_EDGE_IDX) {
341         return ERROR_AIOOBE;
342     }
343 
344     ptr = this.numEdges * SIZEOF_EDGE;
345     if (this.edgesSIZE &lt; ptr + SIZEOF_EDGE) {
346         jint newSize = (ptr + SIZEOF_EDGE) * 2;
347         jfloat *newEdges = new_float(newSize);
348         if (!newEdges) {
349             return ERROR_OOM;
350         }
351         System_arraycopy(this.edges, 0, newEdges, 0, ptr);
352         free(this.edges);
353         this.edges = newEdges;
354         this.edgesSIZE = newSize;
355     }
356     this.numEdges++;
357     this.edges[ptr+OR] = or;
358     this.edges[ptr+CURX] = x1 + (firstCrossing + 0.5f - y1) * slope;
359     this.edges[ptr+SLOPE] = slope;
360     this.edges[ptr+YMAX] = (jfloat) lastCrossing;
361     status = addEdgeToBucket(pRenderer, ptr, bucketIdx);
362     if (status != ERROR_NONE) {
363         return status;
364     }
365     this.edgeBuckets[(lastCrossing - this.boundsMinY)*2 + 1] |= 1;
366     return status;
367 }
368 
369 // END EDGE LIST
370 //////////////////////////////////////////////////////////////////////////////
371 static MoveToFunc       Renderer_moveTo;
372 static LineToFunc       Renderer_lineTo;
373 static QuadToFunc       Renderer_quadTo;
374 static CurveToFunc      Renderer_curveTo;
375 static ClosePathFunc    Renderer_closePath;
376 static PathDoneFunc     Renderer_pathDone;
377 
378 // Antialiasing
379 static jint SUBPIXEL_LG_POSITIONS_X;
380 static jint SUBPIXEL_LG_POSITIONS_Y;
381 static jint SUBPIXEL_POSITIONS_X;
382 static jint SUBPIXEL_POSITIONS_Y;
383 static jint SUBPIXEL_MASK_X;
384 static jint SUBPIXEL_MASK_Y;
385 //static jint MAX_AA_ALPHA;
386 
387 // We keep 2 alpha maps around which map from the number of sub-pixel
388 // samples to a byte-based alpha value from 0 to 255.  We only ever
389 // use 2 different sub-pixel sample counts in practice (depending on
390 // AA vs. non-AA rendering), so these 2 should satisfy all of our needs.
391 static jbyte *alphaMap = NULL;
392 static jint alphaMax;
393 static jbyte *altAlphaMap = NULL;
394 static jint altAlphaMax;
395 
396 static void setMaxAlpha(jint maxalpha);
397 
398 void Renderer_setup(jint subpixelLgPositionsX, jint subpixelLgPositionsY) {
399     SUBPIXEL_LG_POSITIONS_X = subpixelLgPositionsX;
400     SUBPIXEL_LG_POSITIONS_Y = subpixelLgPositionsY;
401     SUBPIXEL_POSITIONS_X = 1 &lt;&lt; (SUBPIXEL_LG_POSITIONS_X);
402     SUBPIXEL_POSITIONS_Y = 1 &lt;&lt; (SUBPIXEL_LG_POSITIONS_Y);
403     SUBPIXEL_MASK_X = SUBPIXEL_POSITIONS_X - 1;
404     SUBPIXEL_MASK_Y = SUBPIXEL_POSITIONS_Y - 1;
405 //    MAX_AA_ALPHA = (SUBPIXEL_POSITIONS_X * SUBPIXEL_POSITIONS_Y);
406     setMaxAlpha((SUBPIXEL_POSITIONS_X * SUBPIXEL_POSITIONS_Y));
407 }
408 
409 void Renderer_init(Renderer *pRenderer) {
410     memset(pRenderer, 0, sizeof(Renderer));
411     PathConsumer_init(&amp;pRenderer-&gt;consumer,
412                       Renderer_moveTo,
413                       Renderer_lineTo,
414                       Renderer_quadTo,
415                       Renderer_curveTo,
416                       Renderer_closePath,
417                       Renderer_pathDone);
418 }
419 
420 void Renderer_reset(Renderer *pRenderer,
421                     jint pix_boundsX, jint pix_boundsY,
422                     jint pix_boundsWidth, jint pix_boundsHeight,
423                     jint windingRule)
424 {
425     jint numBuckets;
426 
427     this.windingRule = windingRule;
428 
429     this.boundsMinX = pix_boundsX * SUBPIXEL_POSITIONS_X;
430     this.boundsMinY = pix_boundsY * SUBPIXEL_POSITIONS_Y;
431     this.boundsMaxX = (pix_boundsX + pix_boundsWidth) * SUBPIXEL_POSITIONS_X;
432     this.boundsMaxY = (pix_boundsY + pix_boundsHeight) * SUBPIXEL_POSITIONS_Y;
433 
434     this.edgeMinX = BIGGEST_FLOAT;
435     this.edgeMaxX = -BIGGEST_FLOAT;
436     this.sampleRowMax = this.boundsMinY;
437     this.sampleRowMin = this.boundsMaxY;
438 
439     numBuckets = this.boundsMaxY - this.boundsMinY;
440     if (this.edgeBuckets == NULL || this.edgeBucketsSIZE &lt; numBuckets*2+2) {
441         // The last 2 entries are ignored and only used to store unused
442         // values for segments ending on the last line of the bounds
443         // so we can avoid having to check the bounds on this array.
444         this.edgeBuckets = new_int(numBuckets*2 + 2);
445         this.edgeBucketsSIZE = numBuckets*2 + 2;
446     } else {
447         // Only need to fill the first numBuckets*2 entries since the
448         // last 2 entries are write-only for overflow avoidance only.
449         Arrays_fill(this.edgeBuckets, 0, numBuckets*2, 0);
450     }
451     if (this.edges == NULL) {
452         this.edges = new_float(SIZEOF_EDGE * 32);
453         this.edgesSIZE = SIZEOF_EDGE * 32;
454     }
455     this.numEdges = 0;
456     this.pix_sx0 = this.pix_sy0 = this.x0 = this.y0 = 0.0f;
457 }
458 
459 void Renderer_destroy(Renderer *pRenderer) {
460     free(pRenderer-&gt;edgeBuckets);
461     pRenderer-&gt;edgeBuckets = NULL;
462     pRenderer-&gt;edgeBucketsSIZE = 0;
463     free(pRenderer-&gt;edges);
464     pRenderer-&gt;edges = NULL;
465     pRenderer-&gt;edgesSIZE = 0;
466 }
467 
468 static jfloat tosubpixx(jfloat pix_x) {
469     return pix_x * SUBPIXEL_POSITIONS_X;
470 }
471 static jfloat tosubpixy(jfloat pix_y) {
472     return pix_y * SUBPIXEL_POSITIONS_Y;
473 }
474 
475 static jint Renderer_moveTo(PathConsumer *pRenderer,
476                             jfloat pix_x0, jfloat pix_y0)
477 {
478     jint status = Renderer_closePath(pRenderer);
479     if (status != ERROR_NONE) {
480         return status;
481     }
482     this.pix_sx0 = pix_x0;
483     this.pix_sy0 = pix_y0;
484     this.y0 = tosubpixy(pix_y0);
485     this.x0 = tosubpixx(pix_x0);
486     return status;
487 }
488 
489 static jint Renderer_lineTo(PathConsumer *pRenderer,
490                             jfloat pix_x1, jfloat pix_y1)
491 {
492     jfloat x1 = tosubpixx(pix_x1);
493     jfloat y1 = tosubpixy(pix_y1);
494     jint status = addLine(pRenderer, this.x0, this.y0, x1, y1);
495     if (status != ERROR_NONE) {
496         return status;
497     }
498     this.x0 = x1;
499     this.y0 = y1;
500     return status;
501 }
502 
503 static jint Renderer_curveTo(PathConsumer *pRenderer,
504                              jfloat x1, jfloat y1,
505                              jfloat x2, jfloat y2,
506                              jfloat x3, jfloat y3)
507 {
508     jint status = ERROR_NONE;
509     const jfloat xe = tosubpixx(x3);
510     const jfloat ye = tosubpixy(y3);
511     Curve_setcubic(&amp;this.c,
512                    this.x0, this.y0,
513                    tosubpixx(x1), tosubpixy(y1),
514                    tosubpixx(x2), tosubpixy(y2),
515                    xe, ye);
516     status = curveBreakIntoLinesAndAdd(pRenderer, this.x0, this.y0, this.c, xe, ye);
517     if (status != ERROR_NONE) {
518         return status;
519     }
520     this.x0 = xe;
521     this.y0 = ye;
522     return status;
523 }
524 
525 jint Renderer_quadTo(PathConsumer *pRenderer,
526                      jfloat x1, jfloat y1,
527                      jfloat x2, jfloat y2)
528 {
529     jint status = ERROR_NONE;
530     const jfloat xe = tosubpixx(x2);
531     const jfloat ye = tosubpixy(y2);
532     Curve_setquad(&amp;this.c,
533                   this.x0, this.y0,
534                   tosubpixx(x1), tosubpixy(y1),
535                   xe, ye);
536     status = quadBreakIntoLinesAndAdd(pRenderer, this.x0, this.y0, this.c, xe, ye);
537     if (status != ERROR_NONE) {
538         return status;
539     }
540     this.x0 = xe;
541     this.y0 = ye;
542     return status;
543 }
544 
545 static jint Renderer_closePath(PathConsumer *pRenderer) {
546     // lineTo expects its input in pixel coordinates.
547     return Renderer_lineTo(pRenderer, this.pix_sx0, this.pix_sy0);
548 }
549 
550 static jint Renderer_pathDone(PathConsumer *pRenderer) {
551     return Renderer_closePath(pRenderer);
552 }
553 
554 static void setAndClearRelativeAlphas(AlphaConsumer *pAC,
555                                       jint alphaRow[], jint pix_y,
556                                       jint pix_from, jint pix_to);
557 
558 jint Renderer_produceAlphas(Renderer *pRenderer, AlphaConsumer *pAC) {
559 //    ac.setMaxAlpha(MAX_AA_ALPHA);
560 
561     // Mask to determine the relevant bit of the crossing sum
562     // 0x1 if EVEN_ODD, all bits if NON_ZERO
563     jint mask = (this.windingRule == WIND_EVEN_ODD) ? 0x1 : ~0x0;
564     jint bboxx0, bboxx1;
565     jint pix_minX, pix_maxX;
566     jint y;
567     ScanlineIterator it;
568 
569     // add 2 to better deal with the last pixel in a pixel row.
570     jint width = pAC-&gt;width;
571     jint savedAlpha[1024];
572     jint *alpha;
573     if (1024 &lt; width+2) {
574         alpha = new_int(width+2);
575         if (!alpha) {
576             return ERROR_OOM;
577         }
578     } else {
579         alpha = savedAlpha;
580     }
581     Arrays_fill(alpha, 0, width+2, 0);
582 
583     bboxx0 = pAC-&gt;originX &lt;&lt; SUBPIXEL_LG_POSITIONS_X;
584     bboxx1 = bboxx0 + (width &lt;&lt; SUBPIXEL_LG_POSITIONS_X);
585 
586     // Now we iterate through the scanlines. We must tell emitRow the coord
587     // of the first non-transparent pixel, so we must keep accumulators for
588     // the first and last pixels of the section of the current pixel row
589     // that we will emit.
590     // We also need to accumulate pix_bbox*, but the iterator does it
591     // for us. We will just get the values from it once this loop is done
592     pix_maxX = bboxx1 &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
593     pix_minX = bboxx0 &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;
594 
595     y = this.boundsMinY; // needs to be declared here so we emit the last row properly.
596     ScanlineIterator_init(&amp;it, pRenderer);
597     for ( ; ScanlineIterator_hasNext(&amp;it, pRenderer); ) {
598         jint numCrossings = ScanlineIterator_next(&amp;it, pRenderer);
599         jint *crossings = it.crossings;
600         jint sum, prev;
601         jint i;
602 
603         if (numCrossings &lt; 0) {
604             ScanlineIterator_destroy(&amp;it);
605             if (alpha != savedAlpha) free (alpha);
606             return ERROR_OOM;
607         }
608 
609         y = ScanlineIterator_curY(&amp;it);
610 
611         if (numCrossings &gt; 0) {
612             jint lowx = crossings[0] &gt;&gt; 1;
613             jint highx = crossings[numCrossings - 1] &gt;&gt; 1;
614             jint x0 = Math_max(lowx, bboxx0);
615             jint x1 = Math_min(highx, bboxx1);
616 
617             pix_minX = Math_min(pix_minX, x0 &gt;&gt; SUBPIXEL_LG_POSITIONS_X);
618             pix_maxX = Math_max(pix_maxX, x1 &gt;&gt; SUBPIXEL_LG_POSITIONS_X);
619         }
620 
621         sum = 0;
622         prev = bboxx0;
623         for (i = 0; i &lt; numCrossings; i++) {
624             jint curxo = crossings[i];
625             jint curx = curxo &gt;&gt; 1;
626             jint crorientation = ((curxo &amp; 0x1) &lt;&lt; 1) - 1;
627             if ((sum &amp; mask) != 0) {
628                 jint x0 = Math_max(prev, bboxx0);
629                 jint x1 = Math_min(curx, bboxx1);
630                 if (x0 &lt; x1) {
631                     jint pix_x, pix_xmaxm1;
632 
633                     x0 -= bboxx0; // turn x0, x1 from coords to indices
634                     x1 -= bboxx0; // in the alpha array.
635 
636                     pix_x = x0 &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
637                     pix_xmaxm1 = (x1 - 1) &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
638 
639                     if (pix_x == pix_xmaxm1) {
640                         // Start and end in same pixel
641                         alpha[pix_x] += (x1 - x0);
642                         alpha[pix_x+1] -= (x1 - x0);
643                     } else {
644                         jint pix_xmax = x1 &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
645                         alpha[pix_x] += SUBPIXEL_POSITIONS_X - (x0 &amp; SUBPIXEL_MASK_X);
646                         alpha[pix_x+1] += (x0 &amp; SUBPIXEL_MASK_X);
647                         alpha[pix_xmax] -= SUBPIXEL_POSITIONS_X - (x1 &amp; SUBPIXEL_MASK_X);
648                         alpha[pix_xmax+1] -= (x1 &amp; SUBPIXEL_MASK_X);
649                     }
650                 }
651             }
652             sum += crorientation;
653             prev = curx;
654         }
655 
656         // even if this last row had no crossings, alpha will be zeroed
657         // from the last emitRow call. But this doesn&#39;t matter because
658         // maxX &lt; minX, so no row will be emitted to the cache.
659         if ((y &amp; SUBPIXEL_MASK_Y) == SUBPIXEL_MASK_Y) {
660             setAndClearRelativeAlphas(pAC, alpha, y &gt;&gt; SUBPIXEL_LG_POSITIONS_Y,
661                                       pix_minX, pix_maxX);
662             pix_maxX = bboxx1 &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
663             pix_minX = bboxx0 &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;
664         }
665     }
666 
667     // Emit final row.
668     // Note, if y is on a MASK row then it was already sent above...
669     if ((y &amp; SUBPIXEL_MASK_Y) &lt; SUBPIXEL_MASK_Y) {
670         setAndClearRelativeAlphas(pAC, alpha, y &gt;&gt; SUBPIXEL_LG_POSITIONS_Y,
671                                   pix_minX, pix_maxX);
672     }
673     ScanlineIterator_destroy(&amp;it);
674     if (alpha != savedAlpha) free (alpha);
675 
676     return ERROR_NONE;
677 }
678 
679 //@Override
680 static void setMaxAlpha(jint maxalpha) {
681     jint i, altMax;
682     jbyte *altMap;
683 
684     // Attempt to reuse either alphaMap or altAlphaMap.
685     // In practice, we should not get here if alphaMap is the right size
686     // due to checks above in our calling chain, but we check for that
687     // condition for completeness.
688     // Also in practice, we only ever have 2 values for maxalpha, but we
689     // protect against running into a 3rd value for maxalpha just in case.
690     if (alphaMap != NULL) {
691         if (maxalpha == alphaMax) {
692             return;
693         }
694         // We will either free the alt values and calculate a new map,
695         // or we will swap them to the main alpha* variables.  In either
696         // case, the main alpha* variables will become the new alt values.
697         altMap = altAlphaMap;
698         altMax = altAlphaMax;
699         altAlphaMap = alphaMap;
700         altAlphaMax = alphaMax;
701         if (altMap != NULL) {
702             if (maxalpha == altMax) {
703                 alphaMap = altMap;
704                 alphaMax = altMax;
705                 return;
706             }
707             free(altMap);
708         }
709         alphaMap = NULL;
710     }
711     // assert alphaMap == NULL
712     alphaMap = malloc(maxalpha+1);
713     alphaMax = maxalpha;
714     for (i = 0; i &lt;= maxalpha; i++) {
715         alphaMap[i] = (jbyte) ((i*255 + maxalpha/2)/maxalpha);
716     }
717 }
718 
719 static void setAndClearRelativeAlphas(AlphaConsumer *pAC,
720                                       jint alphaRow[], jint pix_y,
721                                       jint pix_from, jint pix_to)
722 {
723 //    System.out.println(&quot;setting row &quot;+(pix_y - y)+
724 //                       &quot; out of &quot;+width+&quot; x &quot;+height);
725     jint w = pAC-&gt;width;
726     jint off = (pix_y - pAC-&gt;originY) * w;
727     jbyte *out = pAC-&gt;alphas;
728     jint a = 0;
729     jint i;
730     for (i = 0; i &lt; w; i++) {
731         a += alphaRow[i];
732         alphaRow[i] = 0;
733         out[off+i] = alphaMap[a];
734     }
735 }
736 
737 static jint getSubpixMinX(Renderer *pRenderer) {
738     jint sampleColMin = (jint) ceil(this.edgeMinX - 0.5f);
739     if (sampleColMin &lt; this.boundsMinX) sampleColMin = this.boundsMinX;
740     return sampleColMin;
741 }
742 
743 static jint getSubpixMaxX(Renderer *pRenderer) {
744     jint sampleColMax = (jint) ceil(this.edgeMaxX - 0.5f);
745     if (sampleColMax &gt; this.boundsMaxX) sampleColMax = this.boundsMaxX;
746     return sampleColMax;
747 }
748 
749 static jint getSubpixMinY(Renderer *pRenderer) {
750     return this.sampleRowMin;
751 }
752 
753 static jint getSubpixMaxY(Renderer *pRenderer) {
754     return this.sampleRowMax;
755 }
756 
757 static jint getOutpixMinX(Renderer *pRenderer) {
758     return (getSubpixMinX(pRenderer) &gt;&gt; SUBPIXEL_LG_POSITIONS_X);
759 }
760 
761 static jint getOutpixMaxX(Renderer *pRenderer) {
762     return (getSubpixMaxX(pRenderer) + SUBPIXEL_MASK_X) &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
763 }
764 
765 static jint getOutpixMinY(Renderer *pRenderer) {
766     return (this.sampleRowMin &gt;&gt; SUBPIXEL_LG_POSITIONS_Y);
767 }
768 
769 static jint getOutpixMaxY(Renderer *pRenderer) {
770     return (this.sampleRowMax + SUBPIXEL_MASK_Y) &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;
771 }
772 
773 void Renderer_getOutputBounds(Renderer *pRenderer, jint bounds[]) {
774     bounds[0] = getOutpixMinX(pRenderer);
775     bounds[1] = getOutpixMinY(pRenderer);
776     bounds[2] = getOutpixMaxX(pRenderer);
777     bounds[3] = getOutpixMaxY(pRenderer);
778 }
    </pre>
  </body>
</html>
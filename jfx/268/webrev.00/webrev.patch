diff a/modules/javafx.graphics/src/main/java/com/sun/openpisces/Curve.java b/modules/javafx.graphics/src/main/java/com/sun/openpisces/Curve.java
--- a/modules/javafx.graphics/src/main/java/com/sun/openpisces/Curve.java
+++ /dev/null
@@ -1,290 +0,0 @@
-/*
- * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.openpisces;
-
-import java.util.Iterator;
-
-final class Curve {
-
-    float ax, ay, bx, by, cx, cy, dx, dy;
-    float dax, day, dbx, dby;
-
-    Curve() {
-    }
-
-    void set(float[] points, int type) {
-        switch(type) {
-        case 8:
-            set(points[0], points[1],
-                points[2], points[3],
-                points[4], points[5],
-                points[6], points[7]);
-            break;
-        case 6:
-            set(points[0], points[1],
-                points[2], points[3],
-                points[4], points[5]);
-            break;
-        default:
-            throw new InternalError("Curves can only be cubic or quadratic");
-        }
-    }
-
-    void set(float x1, float y1,
-             float x2, float y2,
-             float x3, float y3,
-             float x4, float y4)
-    {
-        ax = 3 * (x2 - x3) + x4 - x1;
-        ay = 3 * (y2 - y3) + y4 - y1;
-        bx = 3 * (x1 - 2 * x2 + x3);
-        by = 3 * (y1 - 2 * y2 + y3);
-        cx = 3 * (x2 - x1);
-        cy = 3 * (y2 - y1);
-        dx = x1;
-        dy = y1;
-        dax = 3 * ax; day = 3 * ay;
-        dbx = 2 * bx; dby = 2 * by;
-    }
-
-    void set(float x1, float y1,
-             float x2, float y2,
-             float x3, float y3)
-    {
-        ax = ay = 0f;
-
-        bx = x1 - 2 * x2 + x3;
-        by = y1 - 2 * y2 + y3;
-        cx = 2 * (x2 - x1);
-        cy = 2 * (y2 - y1);
-        dx = x1;
-        dy = y1;
-        dax = 0; day = 0;
-        dbx = 2 * bx; dby = 2 * by;
-    }
-
-    float xat(float t) {
-        return t * (t * (t * ax + bx) + cx) + dx;
-    }
-    float yat(float t) {
-        return t * (t * (t * ay + by) + cy) + dy;
-    }
-
-    float dxat(float t) {
-        return t * (t * dax + dbx) + cx;
-    }
-
-    float dyat(float t) {
-        return t * (t * day + dby) + cy;
-    }
-
-    int dxRoots(float[] roots, int off) {
-        return Helpers.quadraticRoots(dax, dbx, cx, roots, off);
-    }
-
-    int dyRoots(float[] roots, int off) {
-        return Helpers.quadraticRoots(day, dby, cy, roots, off);
-    }
-
-    int infPoints(float[] pts, int off) {
-        // inflection point at t if -f'(t)x*f''(t)y + f'(t)y*f''(t)x == 0
-        // Fortunately, this turns out to be quadratic, so there are at
-        // most 2 inflection points.
-        final float a = dax * dby - dbx * day;
-        final float b = 2 * (cy * dax - day * cx);
-        final float c = cy * dbx - cx * dby;
-
-        return Helpers.quadraticRoots(a, b, c, pts, off);
-    }
-
-    // finds points where the first and second derivative are
-    // perpendicular. This happens when g(t) = f'(t)*f''(t) == 0 (where
-    // * is a dot product). Unfortunately, we have to solve a cubic.
-    private int perpendiculardfddf(float[] pts, int off) {
-        assert pts.length >= off + 4;
-
-        // these are the coefficients of some multiple of g(t) (not g(t),
-        // because the roots of a polynomial are not changed after multiplication
-        // by a constant, and this way we save a few multiplications).
-        final float a = 2*(dax*dax + day*day);
-        final float b = 3*(dax*dbx + day*dby);
-        final float c = 2*(dax*cx + day*cy) + dbx*dbx + dby*dby;
-        final float d = dbx*cx + dby*cy;
-        return Helpers.cubicRootsInAB(a, b, c, d, pts, off, 0f, 1f);
-    }
-
-    // Tries to find the roots of the function ROC(t)-w in [0, 1). It uses
-    // a variant of the false position algorithm to find the roots. False
-    // position requires that 2 initial values x0,x1 be given, and that the
-    // function must have opposite signs at those values. To find such
-    // values, we need the local extrema of the ROC function, for which we
-    // need the roots of its derivative; however, it's harder to find the
-    // roots of the derivative in this case than it is to find the roots
-    // of the original function. So, we find all points where this curve's
-    // first and second derivative are perpendicular, and we pretend these
-    // are our local extrema. There are at most 3 of these, so we will check
-    // at most 4 sub-intervals of (0,1). ROC has asymptotes at inflection
-    // points, so roc-w can have at least 6 roots. This shouldn't be a
-    // problem for what we're trying to do (draw a nice looking curve).
-    int rootsOfROCMinusW(float[] roots, int off, final float w, final float err) {
-        // no OOB exception, because by now off<=6, and roots.length >= 10
-        assert off <= 6 && roots.length >= 10;
-        int ret = off;
-        int numPerpdfddf = perpendiculardfddf(roots, off);
-        float t0 = 0, ft0 = ROCsq(t0) - w*w;
-        roots[off + numPerpdfddf] = 1f; // always check interval end points
-        numPerpdfddf++;
-        for (int i = off; i < off + numPerpdfddf; i++) {
-            float t1 = roots[i], ft1 = ROCsq(t1) - w*w;
-            if (ft0 == 0f) {
-                roots[ret++] = t0;
-            } else if (ft1 * ft0 < 0f) { // have opposite signs
-                // (ROC(t)^2 == w^2) == (ROC(t) == w) is true because
-                // ROC(t) >= 0 for all t.
-                roots[ret++] = falsePositionROCsqMinusX(t0, t1, w*w, err);
-            }
-            t0 = t1;
-            ft0 = ft1;
-        }
-
-        return ret - off;
-    }
-
-    private static float eliminateInf(float x) {
-        return (x == Float.POSITIVE_INFINITY ? Float.MAX_VALUE :
-            (x == Float.NEGATIVE_INFINITY ? Float.MIN_VALUE : x));
-    }
-
-    // A slight modification of the false position algorithm on wikipedia.
-    // This only works for the ROCsq-x functions. It might be nice to have
-    // the function as an argument, but that would be awkward in java6.
-    // TODO: It is something to consider for java8 (or whenever lambda
-    // expressions make it into the language), depending on how closures
-    // and turn out. Same goes for the newton's method
-    // algorithm in Helpers.java (RT-26922)
-    private float falsePositionROCsqMinusX(float x0, float x1,
-                                           final float x, final float err)
-    {
-        final int iterLimit = 100;
-        int side = 0;
-        float t = x1, ft = eliminateInf(ROCsq(t) - x);
-        float s = x0, fs = eliminateInf(ROCsq(s) - x);
-        float r = s, fr;
-        for (int i = 0; i < iterLimit && Math.abs(t - s) > err * Math.abs(t + s); i++) {
-            r = (fs * t - ft * s) / (fs - ft);
-            fr = ROCsq(r) - x;
-            if (sameSign(fr, ft)) {
-                ft = fr; t = r;
-                if (side < 0) {
-                    fs /= (1 << (-side));
-                    side--;
-                } else {
-                    side = -1;
-                }
-            } else if (fr * fs > 0) {
-                fs = fr; s = r;
-                if (side > 0) {
-                    ft /= (1 << side);
-                    side++;
-                } else {
-                    side = 1;
-                }
-            } else {
-                break;
-            }
-        }
-        return r;
-    }
-
-    private static boolean sameSign(double x, double y) {
-        // another way is to test if x*y > 0. This is bad for small x, y.
-        return (x < 0 && y < 0) || (x > 0 && y > 0);
-    }
-
-    // returns the radius of curvature squared at t of this curve
-    // see http://en.wikipedia.org/wiki/Radius_of_curvature_(applications)
-    private float ROCsq(final float t) {
-        // dx=xat(t) and dy=yat(t). These calls have been inlined for efficiency
-        final float dx = t * (t * dax + dbx) + cx;
-        final float dy = t * (t * day + dby) + cy;
-        final float ddx = 2 * dax * t + dbx;
-        final float ddy = 2 * day * t + dby;
-        final float dx2dy2 = dx*dx + dy*dy;
-        final float ddx2ddy2 = ddx*ddx + ddy*ddy;
-        final float ddxdxddydy = ddx*dx + ddy*dy;
-        return dx2dy2*((dx2dy2*dx2dy2) / (dx2dy2 * ddx2ddy2 - ddxdxddydy*ddxdxddydy));
-    }
-
-    // curve to be broken should be in pts
-    // this will change the contents of pts but not Ts
-    // TODO: There's no reason for Ts to be an array. All we need is a sequence
-    // of t values at which to subdivide. An array statisfies this condition,
-    // but is unnecessarily restrictive. Ts should be an Iterator<Float> instead.
-    // Doing this will also make dashing easier, since we could easily make
-    // LengthIterator an Iterator<Float> and feed it to this function to simplify
-    // the loop in Dasher.somethingTo. (RT-26922)
-    static Iterator<Integer> breakPtsAtTs(final float[] pts, final int type,
-                                          final float[] Ts, final int numTs)
-    {
-        assert pts.length >= 2*type && numTs <= Ts.length;
-        return new Iterator<Integer>() {
-            // these prevent object creation and destruction during autoboxing.
-            // Because of this, the compiler should be able to completely
-            // eliminate the boxing costs.
-            final Integer i0 = 0;
-            final Integer itype = type;
-            int nextCurveIdx = 0;
-            Integer curCurveOff = i0;
-            float prevT = 0;
-
-            @Override public boolean hasNext() {
-                return nextCurveIdx < numTs + 1;
-            }
-
-            @Override public Integer next() {
-                Integer ret;
-                if (nextCurveIdx < numTs) {
-                    float curT = Ts[nextCurveIdx];
-                    float splitT = (curT - prevT) / (1 - prevT);
-                    Helpers.subdivideAt(splitT,
-                                        pts, curCurveOff,
-                                        pts, 0,
-                                        pts, type, type);
-                    prevT = curT;
-                    ret = i0;
-                    curCurveOff = itype;
-                } else {
-                    ret = curCurveOff;
-                }
-                nextCurveIdx++;
-                return ret;
-            }
-
-            @Override public void remove() {}
-        };
-    }
-}
-
diff a/modules/javafx.graphics/src/main/java/com/sun/openpisces/Dasher.java b/modules/javafx.graphics/src/main/java/com/sun/openpisces/Dasher.java
--- a/modules/javafx.graphics/src/main/java/com/sun/openpisces/Dasher.java
+++ /dev/null
@@ -1,616 +0,0 @@
-/*
- * Copyright (c) 2007, 2014, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.openpisces;
-
-import com.sun.javafx.geom.PathConsumer2D;
-
-/**
- * The <code>Dasher</code> class takes a series of linear commands
- * (<code>moveTo</code>, <code>lineTo</code>, <code>close</code> and
- * <code>end</code>) and breaks them into smaller segments according to a
- * dash pattern array and a starting dash phase.
- *
- * <p> Issues: in J2Se, a zero length dash segment as drawn as a very
- * short dash, whereas Pisces does not draw anything.  The PostScript
- * semantics are unclear.
- *
- */
-public final class Dasher implements PathConsumer2D {
-
-    private final PathConsumer2D out;
-    private float[] dash;
-    private float startPhase;
-    private boolean startDashOn;
-    private int startIdx;
-
-    private boolean starting;
-    private boolean needsMoveTo;
-
-    private int idx;
-    private boolean dashOn;
-    private float phase;
-
-    private float sx, sy;
-    private float x0, y0;
-
-    // temporary storage for the current curve
-    private float[] curCurvepts;
-
-    /**
-     * Constructs a <code>Dasher</code>.
-     *
-     * @param out an output <code>PathConsumer2D</code>.
-     * @param dash an array of <code>float</code>s containing the dash pattern
-     * @param phase a <code>float</code> containing the dash phase
-     */
-    public Dasher(PathConsumer2D out, float[] dash, float phase) {
-        this(out);
-        reset(dash, phase);
-    }
-
-    public Dasher(PathConsumer2D out) {
-        this.out = out;
-
-        // we need curCurvepts to be able to contain 2 curves because when
-        // dashing curves, we need to subdivide it
-        curCurvepts = new float[8 * 2];
-    }
-
-    // More than 24 bits of mantissa means we can no longer accurately
-    // measure the number of times cycled through the dash array so we
-    // punt and override the phase to just be 0 past that point.
-    static float MAX_CYCLES = 16000000f;
-    public void reset(float[] dash, float phase) {
-        // Normalize so 0 <= phase < dash[0]
-        int sidx = 0;
-        dashOn = true;
-        float sum = 0f;
-        for (float d : dash) {
-            sum += d;
-        }
-        float cycles = phase / sum;
-        if (phase < 0) {
-            if (-cycles >= MAX_CYCLES) {
-                phase = 0;
-            } else {
-                int fullcycles = (int) Math.floor(-cycles);
-                if ((fullcycles & dash.length & 1) != 0) {
-                    dashOn = !dashOn;
-                }
-                phase += fullcycles * sum;
-                while (phase < 0) {
-                    if (--sidx < 0) sidx = dash.length-1;
-                    phase += dash[sidx];
-                    dashOn = !dashOn;
-                }
-            }
-        } else if (phase > 0) {
-            if (cycles >= MAX_CYCLES) {
-                phase = 0;
-            } else {
-                int fullcycles = (int) Math.floor(cycles);
-                if ((fullcycles & dash.length & 1) != 0) {
-                    dashOn = !dashOn;
-                }
-                phase -= fullcycles * sum;
-                float d;
-                while (phase >= (d = dash[sidx])) {
-                    phase -= d;
-                    sidx = (sidx + 1) % dash.length;
-                    dashOn = !dashOn;
-                }
-            }
-        }
-
-        this.dash = dash;
-        this.startPhase = this.phase = phase;
-        this.startDashOn = dashOn;
-        this.startIdx = sidx;
-        this.starting = true;
-    }
-
-    public void moveTo(float x0, float y0) {
-        if (firstSegidx > 0) {
-            out.moveTo(sx, sy);
-            emitFirstSegments();
-        }
-        needsMoveTo = true;
-        this.idx = startIdx;
-        this.dashOn = this.startDashOn;
-        this.phase = this.startPhase;
-        this.sx = this.x0 = x0;
-        this.sy = this.y0 = y0;
-        this.starting = true;
-    }
-
-    private void emitSeg(float[] buf, int off, int type) {
-        switch (type) {
-        case 8:
-            out.curveTo(buf[off+0], buf[off+1],
-                        buf[off+2], buf[off+3],
-                        buf[off+4], buf[off+5]);
-            break;
-        case 6:
-            out.quadTo(buf[off+0], buf[off+1],
-                       buf[off+2], buf[off+3]);
-            break;
-        case 4:
-            out.lineTo(buf[off], buf[off+1]);
-        }
-    }
-
-    private void emitFirstSegments() {
-        for (int i = 0; i < firstSegidx; ) {
-            emitSeg(firstSegmentsBuffer, i+1, (int)firstSegmentsBuffer[i]);
-            i += (((int)firstSegmentsBuffer[i]) - 1);
-        }
-        firstSegidx = 0;
-    }
-
-    // We don't emit the first dash right away. If we did, caps would be
-    // drawn on it, but we need joins to be drawn if there's a closePath()
-    // So, we store the path elements that make up the first dash in the
-    // buffer below.
-    private float[] firstSegmentsBuffer = new float[7];
-    private int firstSegidx = 0;
-    // precondition: pts must be in relative coordinates (relative to x0,y0)
-    // fullCurve is true iff the curve in pts has not been split.
-    private void goTo(float[] pts, int off, final int type) {
-        float x = pts[off + type - 4];
-        float y = pts[off + type - 3];
-        if (dashOn) {
-            if (starting) {
-                firstSegmentsBuffer =
-                    Helpers.widenArray(firstSegmentsBuffer,
-                                       firstSegidx, type - 1);
-                firstSegmentsBuffer[firstSegidx++] = type;
-                System.arraycopy(pts, off, firstSegmentsBuffer, firstSegidx, type - 2);
-                firstSegidx += type - 2;
-            } else {
-                if (needsMoveTo) {
-                    out.moveTo(x0, y0);
-                    needsMoveTo = false;
-                }
-                emitSeg(pts, off, type);
-            }
-        } else {
-            starting = false;
-            needsMoveTo = true;
-        }
-        this.x0 = x;
-        this.y0 = y;
-    }
-
-    public void lineTo(float x1, float y1) {
-        float dx = x1 - x0;
-        float dy = y1 - y0;
-
-        float len = (float) Math.sqrt(dx*dx + dy*dy);
-
-        if (len == 0) {
-            return;
-        }
-
-        // The scaling factors needed to get the dx and dy of the
-        // transformed dash segments.
-        float cx = dx / len;
-        float cy = dy / len;
-
-        while (true) {
-            float leftInThisDashSegment = dash[idx] - phase;
-            if (len <= leftInThisDashSegment) {
-                curCurvepts[0] = x1;
-                curCurvepts[1] = y1;
-                goTo(curCurvepts, 0, 4);
-                // Advance phase within current dash segment
-                phase += len;
-                if (len == leftInThisDashSegment) {
-                    phase = 0f;
-                    idx = (idx + 1) % dash.length;
-                    dashOn = !dashOn;
-                }
-                return;
-            }
-
-            float dashdx = dash[idx] * cx;
-            float dashdy = dash[idx] * cy;
-            if (phase == 0) {
-                curCurvepts[0] = x0 + dashdx;
-                curCurvepts[1] = y0 + dashdy;
-            } else {
-                float p = leftInThisDashSegment / dash[idx];
-                curCurvepts[0] = x0 + p * dashdx;
-                curCurvepts[1] = y0 + p * dashdy;
-            }
-
-            goTo(curCurvepts, 0, 4);
-
-            len -= leftInThisDashSegment;
-            // Advance to next dash segment
-            idx = (idx + 1) % dash.length;
-            dashOn = !dashOn;
-            phase = 0;
-        }
-    }
-
-    private LengthIterator li = null;
-
-    // preconditions: curCurvepts must be an array of length at least 2 * type,
-    // that contains the curve we want to dash in the first type elements
-    private void somethingTo(int type) {
-        if (pointCurve(curCurvepts, type)) {
-            return;
-        }
-        if (li == null) {
-            li = new LengthIterator(4, 0.01f);
-        }
-        li.initializeIterationOnCurve(curCurvepts, type);
-
-        int curCurveoff = 0; // initially the current curve is at curCurvepts[0...type]
-        float lastSplitT = 0;
-        float t = 0;
-        float leftInThisDashSegment = dash[idx] - phase;
-        while ((t = li.next(leftInThisDashSegment)) < 1) {
-            if (t != 0) {
-                Helpers.subdivideAt((t - lastSplitT) / (1 - lastSplitT),
-                                    curCurvepts, curCurveoff,
-                                    curCurvepts, 0,
-                                    curCurvepts, type, type);
-                lastSplitT = t;
-                goTo(curCurvepts, 2, type);
-                curCurveoff = type;
-            }
-            // Advance to next dash segment
-            idx = (idx + 1) % dash.length;
-            dashOn = !dashOn;
-            phase = 0;
-            leftInThisDashSegment = dash[idx];
-        }
-        goTo(curCurvepts, curCurveoff+2, type);
-        phase += li.lastSegLen();
-        if (phase >= dash[idx]) {
-            phase = 0f;
-            idx = (idx + 1) % dash.length;
-            dashOn = !dashOn;
-        }
-    }
-
-    private static boolean pointCurve(float[] curve, int type) {
-        for (int i = 2; i < type; i++) {
-            if (curve[i] != curve[i-2]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    // Objects of this class are used to iterate through curves. They return
-    // t values where the left side of the curve has a specified length.
-    // It does this by subdividing the input curve until a certain error
-    // condition has been met. A recursive subdivision procedure would
-    // return as many as 1<<limit curves, but this is an iterator and we
-    // don't need all the curves all at once, so what we carry out a
-    // lazy inorder traversal of the recursion tree (meaning we only move
-    // through the tree when we need the next subdivided curve). This saves
-    // us a lot of memory because at any one time we only need to store
-    // limit+1 curves - one for each level of the tree + 1.
-    // NOTE: the way we do things here is not enough to traverse a general
-    // tree; however, the trees we are interested in have the property that
-    // every non leaf node has exactly 2 children
-    private static class LengthIterator {
-        private enum Side {LEFT, RIGHT};
-        // Holds the curves at various levels of the recursion. The root
-        // (i.e. the original curve) is at recCurveStack[0] (but then it
-        // gets subdivided, the left half is put at 1, so most of the time
-        // only the right half of the original curve is at 0)
-        private float[][] recCurveStack;
-        // sides[i] indicates whether the node at level i+1 in the path from
-        // the root to the current leaf is a left or right child of its parent.
-        private Side[] sides;
-        private int curveType;
-        private final int limit;
-        private final float ERR;
-        private final float minTincrement;
-        // lastT and nextT delimit the current leaf.
-        private float nextT;
-        private float lenAtNextT;
-        private float lastT;
-        private float lenAtLastT;
-        private float lenAtLastSplit;
-        private float lastSegLen;
-        // the current level in the recursion tree. 0 is the root. limit
-        // is the deepest possible leaf.
-        private int recLevel;
-        private boolean done;
-
-        // the lengths of the lines of the control polygon. Only its first
-        // curveType/2 - 1 elements are valid. This is an optimization. See
-        // next(float) for more detail.
-        private float[] curLeafCtrlPolyLengths = new float[3];
-
-        public LengthIterator(int reclimit, float err) {
-            this.limit = reclimit;
-            this.minTincrement = 1f / (1 << limit);
-            this.ERR = err;
-            this.recCurveStack = new float[reclimit+1][8];
-            this.sides = new Side[reclimit];
-            // if any methods are called without first initializing this object on
-            // a curve, we want it to fail ASAP.
-            this.nextT = Float.MAX_VALUE;
-            this.lenAtNextT = Float.MAX_VALUE;
-            this.lenAtLastSplit = Float.MIN_VALUE;
-            this.recLevel = Integer.MIN_VALUE;
-            this.lastSegLen = Float.MAX_VALUE;
-            this.done = true;
-        }
-
-        public void initializeIterationOnCurve(float[] pts, int type) {
-            System.arraycopy(pts, 0, recCurveStack[0], 0, type);
-            this.curveType = type;
-            this.recLevel = 0;
-            this.lastT = 0;
-            this.lenAtLastT = 0;
-            this.nextT = 0;
-            this.lenAtNextT = 0;
-            goLeft(); // initializes nextT and lenAtNextT properly
-            this.lenAtLastSplit = 0;
-            if (recLevel > 0) {
-                this.sides[0] = Side.LEFT;
-                this.done = false;
-            } else {
-                // the root of the tree is a leaf so we're done.
-                this.sides[0] = Side.RIGHT;
-                this.done = true;
-            }
-            this.lastSegLen = 0;
-        }
-
-        // 0 == false, 1 == true, -1 == invalid cached value.
-        private int cachedHaveLowAcceleration = -1;
-
-        private boolean haveLowAcceleration(float err) {
-            if (cachedHaveLowAcceleration == -1) {
-                final float len1 = curLeafCtrlPolyLengths[0];
-                final float len2 = curLeafCtrlPolyLengths[1];
-                // the test below is equivalent to !within(len1/len2, 1, err).
-                // It is using a multiplication instead of a division, so it
-                // should be a bit faster.
-                if (!Helpers.within(len1, len2, err*len2)) {
-                    cachedHaveLowAcceleration = 0;
-                    return false;
-                }
-                if (curveType == 8) {
-                    final float len3 = curLeafCtrlPolyLengths[2];
-                    // if len1 is close to 2 and 2 is close to 3, that probably
-                    // means 1 is close to 3 so the second part of this test might
-                    // not be needed, but it doesn't hurt to include it.
-                    if (!(Helpers.within(len2, len3, err*len3) &&
-                          Helpers.within(len1, len3, err*len3))) {
-                        cachedHaveLowAcceleration = 0;
-                        return false;
-                    }
-                }
-                cachedHaveLowAcceleration = 1;
-                return true;
-            }
-
-            return (cachedHaveLowAcceleration == 1);
-        }
-
-        // we want to avoid allocations/gc so we keep this array so we
-        // can put roots in it,
-        private float[] nextRoots = new float[4];
-
-        // caches the coefficients of the current leaf in its flattened
-        // form (see inside next() for what that means). The cache is
-        // invalid when it's third element is negative, since in any
-        // valid flattened curve, this would be >= 0.
-        private float[] flatLeafCoefCache = new float[] {0, 0, -1, 0};
-        // returns the t value where the remaining curve should be split in
-        // order for the left subdivided curve to have length len. If len
-        // is >= than the length of the uniterated curve, it returns 1.
-        public float next(final float len) {
-            final float targetLength = lenAtLastSplit + len;
-            while(lenAtNextT < targetLength) {
-                if (done) {
-                    lastSegLen = lenAtNextT - lenAtLastSplit;
-                    return 1;
-                }
-                goToNextLeaf();
-            }
-            lenAtLastSplit = targetLength;
-            final float leaflen = lenAtNextT - lenAtLastT;
-            float t = (targetLength - lenAtLastT) / leaflen;
-
-            // cubicRootsInAB is a fairly expensive call, so we just don't do it
-            // if the acceleration in this section of the curve is small enough.
-            if (!haveLowAcceleration(0.05f)) {
-                // We flatten the current leaf along the x axis, so that we're
-                // left with a, b, c which define a 1D Bezier curve. We then
-                // solve this to get the parameter of the original leaf that
-                // gives us the desired length.
-
-                if (flatLeafCoefCache[2] < 0) {
-                    float x = 0+curLeafCtrlPolyLengths[0],
-                          y = x+curLeafCtrlPolyLengths[1];
-                    if (curveType == 8) {
-                        float z = y + curLeafCtrlPolyLengths[2];
-                        flatLeafCoefCache[0] = 3*(x - y) + z;
-                        flatLeafCoefCache[1] = 3*(y - 2*x);
-                        flatLeafCoefCache[2] = 3*x;
-                        flatLeafCoefCache[3] = -z;
-                    } else if (curveType == 6) {
-                        flatLeafCoefCache[0] = 0f;
-                        flatLeafCoefCache[1] = y - 2*x;
-                        flatLeafCoefCache[2] = 2*x;
-                        flatLeafCoefCache[3] = -y;
-                    }
-                }
-                float a = flatLeafCoefCache[0];
-                float b = flatLeafCoefCache[1];
-                float c = flatLeafCoefCache[2];
-                float d = t*flatLeafCoefCache[3];
-
-                // we use cubicRootsInAB here, because we want only roots in 0, 1,
-                // and our quadratic root finder doesn't filter, so it's just a
-                // matter of convenience.
-                int n = Helpers.cubicRootsInAB(a, b, c, d, nextRoots, 0, 0, 1);
-                if (n == 1 && !Float.isNaN(nextRoots[0])) {
-                    t = nextRoots[0];
-                }
-            }
-            // t is relative to the current leaf, so we must make it a valid parameter
-            // of the original curve.
-            t = t * (nextT - lastT) + lastT;
-            if (t >= 1) {
-                t = 1;
-                done = true;
-            }
-            // even if done = true, if we're here, that means targetLength
-            // is equal to, or very, very close to the total length of the
-            // curve, so lastSegLen won't be too high. In cases where len
-            // overshoots the curve, this method will exit in the while
-            // loop, and lastSegLen will still be set to the right value.
-            lastSegLen = len;
-            return t;
-        }
-
-        public float lastSegLen() {
-            return lastSegLen;
-        }
-
-        // go to the next leaf (in an inorder traversal) in the recursion tree
-        // preconditions: must be on a leaf, and that leaf must not be the root.
-        private void goToNextLeaf() {
-            // We must go to the first ancestor node that has an unvisited
-            // right child.
-            recLevel--;
-            while(sides[recLevel] == Side.RIGHT) {
-                if (recLevel == 0) {
-                    done = true;
-                    return;
-                }
-                recLevel--;
-            }
-
-            sides[recLevel] = Side.RIGHT;
-            System.arraycopy(recCurveStack[recLevel], 0,
-                             recCurveStack[recLevel+1], 0, curveType);
-            recLevel++;
-            goLeft();
-        }
-
-        // go to the leftmost node from the current node. Return its length.
-        private void goLeft() {
-            float len = onLeaf();
-            if (len >= 0) {
-                lastT = nextT;
-                lenAtLastT = lenAtNextT;
-                nextT += (1 << (limit - recLevel)) * minTincrement;
-                lenAtNextT += len;
-                // invalidate caches
-                flatLeafCoefCache[2] = -1;
-                cachedHaveLowAcceleration = -1;
-            } else {
-                Helpers.subdivide(recCurveStack[recLevel], 0,
-                                  recCurveStack[recLevel+1], 0,
-                                  recCurveStack[recLevel], 0, curveType);
-                sides[recLevel] = Side.LEFT;
-                recLevel++;
-                goLeft();
-            }
-        }
-
-        // this is a bit of a hack. It returns -1 if we're not on a leaf, and
-        // the length of the leaf if we are on a leaf.
-        private float onLeaf() {
-            float[] curve = recCurveStack[recLevel];
-            float polyLen = 0;
-
-            float x0 = curve[0], y0 = curve[1];
-            for (int i = 2; i < curveType; i += 2) {
-                final float x1 = curve[i], y1 = curve[i+1];
-                final float len = Helpers.linelen(x0, y0, x1, y1);
-                polyLen += len;
-                curLeafCtrlPolyLengths[i/2 - 1] = len;
-                x0 = x1;
-                y0 = y1;
-            }
-
-            final float lineLen =
-                Helpers.linelen(curve[0], curve[1], curve[curveType-2], curve[curveType-1]);
-            if (polyLen - lineLen < ERR || recLevel == limit) {
-                return (polyLen + lineLen)/2;
-            }
-            return -1;
-        }
-    }
-
-    @Override
-    public void curveTo(float x1, float y1,
-                        float x2, float y2,
-                        float x3, float y3)
-    {
-        curCurvepts[0] = x0;        curCurvepts[1] = y0;
-        curCurvepts[2] = x1;        curCurvepts[3] = y1;
-        curCurvepts[4] = x2;        curCurvepts[5] = y2;
-        curCurvepts[6] = x3;        curCurvepts[7] = y3;
-        somethingTo(8);
-    }
-
-    @Override
-    public void quadTo(float x1, float y1, float x2, float y2) {
-        curCurvepts[0] = x0;        curCurvepts[1] = y0;
-        curCurvepts[2] = x1;        curCurvepts[3] = y1;
-        curCurvepts[4] = x2;        curCurvepts[5] = y2;
-        somethingTo(6);
-    }
-
-    public void closePath() {
-        lineTo(sx, sy);
-        if (firstSegidx > 0) {
-            if (!dashOn || needsMoveTo) {
-                out.moveTo(sx, sy);
-            }
-            emitFirstSegments();
-        }
-        moveTo(sx, sy);
-    }
-
-    public void pathDone() {
-        if (firstSegidx > 0) {
-            out.moveTo(sx, sy);
-            emitFirstSegments();
-        }
-        out.pathDone();
-    }
-
-//    @Override
-//    public long getNativeConsumer() {
-//        throw new InternalError("Dasher does not use a native consumer");
-//    }
-}
-
diff a/modules/javafx.graphics/src/main/java/com/sun/openpisces/Helpers.java b/modules/javafx.graphics/src/main/java/com/sun/openpisces/Helpers.java
--- a/modules/javafx.graphics/src/main/java/com/sun/openpisces/Helpers.java
+++ /dev/null
@@ -1,457 +0,0 @@
-/*
- * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.openpisces;
-
-import java.util.Arrays;
-import static java.lang.Math.PI;
-import static java.lang.Math.cos;
-import static java.lang.Math.sqrt;
-import static java.lang.Math.cbrt;
-import static java.lang.Math.acos;
-
-
-final class Helpers {
-    private Helpers() {
-        throw new Error("This is a non instantiable class");
-    }
-
-    static boolean within(final float x, final float y, final float err) {
-        final float d = y - x;
-        return (d <= err && d >= -err);
-    }
-
-    static boolean within(final double x, final double y, final double err) {
-        final double d = y - x;
-        return (d <= err && d >= -err);
-    }
-
-    static int quadraticRoots(final float a, final float b,
-                              final float c, float[] zeroes, final int off)
-    {
-        int ret = off;
-        float t;
-        if (a != 0f) {
-            final float dis = b*b - 4*a*c;
-            if (dis > 0) {
-                final float sqrtDis = (float)Math.sqrt(dis);
-                // depending on the sign of b we use a slightly different
-                // algorithm than the traditional one to find one of the roots
-                // so we can avoid adding numbers of different signs (which
-                // might result in loss of precision).
-                if (b >= 0) {
-                    zeroes[ret++] = (2 * c) / (-b - sqrtDis);
-                    zeroes[ret++] = (-b - sqrtDis) / (2 * a);
-                } else {
-                    zeroes[ret++] = (-b + sqrtDis) / (2 * a);
-                    zeroes[ret++] = (2 * c) / (-b + sqrtDis);
-                }
-            } else if (dis == 0f) {
-                t = (-b) / (2 * a);
-                zeroes[ret++] = t;
-            }
-        } else {
-            if (b != 0f) {
-                t = (-c) / b;
-                zeroes[ret++] = t;
-            }
-        }
-        return ret - off;
-    }
-
-    // find the roots of g(t) = d*t^3 + a*t^2 + b*t + c in [A,B)
-    static int cubicRootsInAB(float d, float a, float b, float c,
-                              float[] pts, final int off,
-                              final float A, final float B)
-    {
-        if (d == 0) {
-            int num = quadraticRoots(a, b, c, pts, off);
-            return filterOutNotInAB(pts, off, num, A, B) - off;
-        }
-        // From Graphics Gems:
-        // http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c
-        // (also from awt.geom.CubicCurve2D. But here we don't need as
-        // much accuracy and we don't want to create arrays so we use
-        // our own customized version).
-
-        /* normal form: x^3 + ax^2 + bx + c = 0 */
-        a /= d;
-        b /= d;
-        c /= d;
-
-        //  substitute x = y - A/3 to eliminate quadratic term:
-        //     x^3 +Px + Q = 0
-        //
-        // Since we actually need P/3 and Q/2 for all of the
-        // calculations that follow, we will calculate
-        // p = P/3
-        // q = Q/2
-        // instead and use those values for simplicity of the code.
-        double sq_A = a * a;
-        double p = 1.0/3 * (-1.0/3 * sq_A + b);
-        double q = 1.0/2 * (2.0/27 * a * sq_A - 1.0/3 * a * b + c);
-
-        /* use Cardano's formula */
-
-        double cb_p = p * p * p;
-        double D = q * q + cb_p;
-
-        int num;
-        if (D < 0) {
-            // see: http://en.wikipedia.org/wiki/Cubic_function#Trigonometric_.28and_hyperbolic.29_method
-            final double phi = 1.0/3 * acos(-q / sqrt(-cb_p));
-            final double t = 2 * sqrt(-p);
-
-            pts[ off+0 ] =  (float)( t * cos(phi));
-            pts[ off+1 ] =  (float)(-t * cos(phi + PI / 3));
-            pts[ off+2 ] =  (float)(-t * cos(phi - PI / 3));
-            num = 3;
-        } else {
-            final double sqrt_D = sqrt(D);
-            final double u = cbrt(sqrt_D - q);
-            final double v = - cbrt(sqrt_D + q);
-
-            pts[ off ] = (float)(u + v);
-            num = 1;
-
-            if (within(D, 0, 1e-8)) {
-                pts[off+1] = -(pts[off] / 2);
-                num = 2;
-            }
-        }
-
-        final float sub = 1.0f/3 * a;
-
-        for (int i = 0; i < num; ++i) {
-            pts[ off+i ] -= sub;
-        }
-
-        return filterOutNotInAB(pts, off, num, A, B) - off;
-    }
-
-    // These use a hardcoded factor of 2 for increasing sizes. Perhaps this
-    // should be provided as an argument.
-    static float[] widenArray(float[] in, final int cursize, final int numToAdd) {
-        if (in.length >= cursize + numToAdd) {
-            return in;
-        }
-        return Arrays.copyOf(in, 2 * (cursize + numToAdd));
-    }
-
-    static int[] widenArray(int[] in, final int cursize, final int numToAdd) {
-        if (in.length >= cursize + numToAdd) {
-            return in;
-        }
-        return Arrays.copyOf(in, 2 * (cursize + numToAdd));
-    }
-
-    static float evalCubic(final float a, final float b,
-                           final float c, final float d,
-                           final float t)
-    {
-        return t * (t * (t * a + b) + c) + d;
-    }
-
-    static float evalQuad(final float a, final float b,
-                          final float c, final float t)
-    {
-        return t * (t * a + b) + c;
-    }
-
-    // returns the index 1 past the last valid element remaining after filtering
-    static int filterOutNotInAB(float[] nums, final int off, final int len,
-                                final float a, final float b)
-    {
-        int ret = off;
-        for (int i = off; i < off + len; i++) {
-            if (nums[i] >= a && nums[i] < b) {
-                nums[ret++] = nums[i];
-            }
-        }
-        return ret;
-    }
-
-    static float polyLineLength(float[] poly, final int off, final int nCoords) {
-        assert nCoords % 2 == 0 && poly.length >= off + nCoords : "";
-        float acc = 0;
-        for (int i = off + 2; i < off + nCoords; i += 2) {
-            acc += linelen(poly[i], poly[i+1], poly[i-2], poly[i-1]);
-        }
-        return acc;
-    }
-
-    static float linelen(float x1, float y1, float x2, float y2) {
-        final float dx = x2 - x1;
-        final float dy = y2 - y1;
-        return (float)Math.sqrt(dx*dx + dy*dy);
-    }
-
-    static void subdivide(float[] src, int srcoff, float[] left, int leftoff,
-                          float[] right, int rightoff, int type)
-    {
-        switch(type) {
-        case 6:
-            Helpers.subdivideQuad(src, srcoff, left, leftoff, right, rightoff);
-            break;
-        case 8:
-            Helpers.subdivideCubic(src, srcoff, left, leftoff, right, rightoff);
-            break;
-        default:
-            throw new InternalError("Unsupported curve type");
-        }
-    }
-
-    static void isort(float[] a, int off, int len) {
-        for (int i = off + 1; i < off + len; i++) {
-            float ai = a[i];
-            int j = i - 1;
-            for (; j >= off && a[j] > ai; j--) {
-                a[j+1] = a[j];
-            }
-            a[j+1] = ai;
-        }
-    }
-
-    // Most of these are copied from classes in java.awt.geom because we need
-    // float versions of these functions, and Line2D, CubicCurve2D,
-    // QuadCurve2D don't provide them.
-    /**
-     * Subdivides the cubic curve specified by the coordinates
-     * stored in the <code>src</code> array at indices <code>srcoff</code>
-     * through (<code>srcoff</code>&nbsp;+&nbsp;7) and stores the
-     * resulting two subdivided curves into the two result arrays at the
-     * corresponding indices.
-     * Either or both of the <code>left</code> and <code>right</code>
-     * arrays may be <code>null</code> or a reference to the same array
-     * as the <code>src</code> array.
-     * Note that the last point in the first subdivided curve is the
-     * same as the first point in the second subdivided curve. Thus,
-     * it is possible to pass the same array for <code>left</code>
-     * and <code>right</code> and to use offsets, such as <code>rightoff</code>
-     * equals (<code>leftoff</code> + 6), in order
-     * to avoid allocating extra storage for this common point.
-     * @param src the array holding the coordinates for the source curve
-     * @param srcoff the offset into the array of the beginning of the
-     * the 6 source coordinates
-     * @param left the array for storing the coordinates for the first
-     * half of the subdivided curve
-     * @param leftoff the offset into the array of the beginning of the
-     * the 6 left coordinates
-     * @param right the array for storing the coordinates for the second
-     * half of the subdivided curve
-     * @param rightoff the offset into the array of the beginning of the
-     * the 6 right coordinates
-     */
-    static void subdivideCubic(float src[], int srcoff,
-                               float left[], int leftoff,
-                               float right[], int rightoff)
-    {
-        float x1 = src[srcoff + 0];
-        float y1 = src[srcoff + 1];
-        float ctrlx1 = src[srcoff + 2];
-        float ctrly1 = src[srcoff + 3];
-        float ctrlx2 = src[srcoff + 4];
-        float ctrly2 = src[srcoff + 5];
-        float x2 = src[srcoff + 6];
-        float y2 = src[srcoff + 7];
-        if (left != null) {
-            left[leftoff + 0] = x1;
-            left[leftoff + 1] = y1;
-        }
-        if (right != null) {
-            right[rightoff + 6] = x2;
-            right[rightoff + 7] = y2;
-        }
-        x1 = (x1 + ctrlx1) / 2.0f;
-        y1 = (y1 + ctrly1) / 2.0f;
-        x2 = (x2 + ctrlx2) / 2.0f;
-        y2 = (y2 + ctrly2) / 2.0f;
-        float centerx = (ctrlx1 + ctrlx2) / 2.0f;
-        float centery = (ctrly1 + ctrly2) / 2.0f;
-        ctrlx1 = (x1 + centerx) / 2.0f;
-        ctrly1 = (y1 + centery) / 2.0f;
-        ctrlx2 = (x2 + centerx) / 2.0f;
-        ctrly2 = (y2 + centery) / 2.0f;
-        centerx = (ctrlx1 + ctrlx2) / 2.0f;
-        centery = (ctrly1 + ctrly2) / 2.0f;
-        if (left != null) {
-            left[leftoff + 2] = x1;
-            left[leftoff + 3] = y1;
-            left[leftoff + 4] = ctrlx1;
-            left[leftoff + 5] = ctrly1;
-            left[leftoff + 6] = centerx;
-            left[leftoff + 7] = centery;
-        }
-        if (right != null) {
-            right[rightoff + 0] = centerx;
-            right[rightoff + 1] = centery;
-            right[rightoff + 2] = ctrlx2;
-            right[rightoff + 3] = ctrly2;
-            right[rightoff + 4] = x2;
-            right[rightoff + 5] = y2;
-        }
-    }
-
-
-    static void subdivideCubicAt(float t, float src[], int srcoff,
-                                 float left[], int leftoff,
-                                 float right[], int rightoff)
-    {
-        float x1 = src[srcoff + 0];
-        float y1 = src[srcoff + 1];
-        float ctrlx1 = src[srcoff + 2];
-        float ctrly1 = src[srcoff + 3];
-        float ctrlx2 = src[srcoff + 4];
-        float ctrly2 = src[srcoff + 5];
-        float x2 = src[srcoff + 6];
-        float y2 = src[srcoff + 7];
-        if (left != null) {
-            left[leftoff + 0] = x1;
-            left[leftoff + 1] = y1;
-        }
-        if (right != null) {
-            right[rightoff + 6] = x2;
-            right[rightoff + 7] = y2;
-        }
-        x1 = x1 + t * (ctrlx1 - x1);
-        y1 = y1 + t * (ctrly1 - y1);
-        x2 = ctrlx2 + t * (x2 - ctrlx2);
-        y2 = ctrly2 + t * (y2 - ctrly2);
-        float centerx = ctrlx1 + t * (ctrlx2 - ctrlx1);
-        float centery = ctrly1 + t * (ctrly2 - ctrly1);
-        ctrlx1 = x1 + t * (centerx - x1);
-        ctrly1 = y1 + t * (centery - y1);
-        ctrlx2 = centerx + t * (x2 - centerx);
-        ctrly2 = centery + t * (y2 - centery);
-        centerx = ctrlx1 + t * (ctrlx2 - ctrlx1);
-        centery = ctrly1 + t * (ctrly2 - ctrly1);
-        if (left != null) {
-            left[leftoff + 2] = x1;
-            left[leftoff + 3] = y1;
-            left[leftoff + 4] = ctrlx1;
-            left[leftoff + 5] = ctrly1;
-            left[leftoff + 6] = centerx;
-            left[leftoff + 7] = centery;
-        }
-        if (right != null) {
-            right[rightoff + 0] = centerx;
-            right[rightoff + 1] = centery;
-            right[rightoff + 2] = ctrlx2;
-            right[rightoff + 3] = ctrly2;
-            right[rightoff + 4] = x2;
-            right[rightoff + 5] = y2;
-        }
-    }
-
-    static void subdivideQuad(float src[], int srcoff,
-                              float left[], int leftoff,
-                              float right[], int rightoff)
-    {
-        float x1 = src[srcoff + 0];
-        float y1 = src[srcoff + 1];
-        float ctrlx = src[srcoff + 2];
-        float ctrly = src[srcoff + 3];
-        float x2 = src[srcoff + 4];
-        float y2 = src[srcoff + 5];
-        if (left != null) {
-            left[leftoff + 0] = x1;
-            left[leftoff + 1] = y1;
-        }
-        if (right != null) {
-            right[rightoff + 4] = x2;
-            right[rightoff + 5] = y2;
-        }
-        x1 = (x1 + ctrlx) / 2.0f;
-        y1 = (y1 + ctrly) / 2.0f;
-        x2 = (x2 + ctrlx) / 2.0f;
-        y2 = (y2 + ctrly) / 2.0f;
-        ctrlx = (x1 + x2) / 2.0f;
-        ctrly = (y1 + y2) / 2.0f;
-        if (left != null) {
-            left[leftoff + 2] = x1;
-            left[leftoff + 3] = y1;
-            left[leftoff + 4] = ctrlx;
-            left[leftoff + 5] = ctrly;
-        }
-        if (right != null) {
-            right[rightoff + 0] = ctrlx;
-            right[rightoff + 1] = ctrly;
-            right[rightoff + 2] = x2;
-            right[rightoff + 3] = y2;
-        }
-    }
-
-    static void subdivideQuadAt(float t, float src[], int srcoff,
-                                float left[], int leftoff,
-                                float right[], int rightoff)
-    {
-        float x1 = src[srcoff + 0];
-        float y1 = src[srcoff + 1];
-        float ctrlx = src[srcoff + 2];
-        float ctrly = src[srcoff + 3];
-        float x2 = src[srcoff + 4];
-        float y2 = src[srcoff + 5];
-        if (left != null) {
-            left[leftoff + 0] = x1;
-            left[leftoff + 1] = y1;
-        }
-        if (right != null) {
-            right[rightoff + 4] = x2;
-            right[rightoff + 5] = y2;
-        }
-        x1 = x1 + t * (ctrlx - x1);
-        y1 = y1 + t * (ctrly - y1);
-        x2 = ctrlx + t * (x2 - ctrlx);
-        y2 = ctrly + t * (y2 - ctrly);
-        ctrlx = x1 + t * (x2 - x1);
-        ctrly = y1 + t * (y2 - y1);
-        if (left != null) {
-            left[leftoff + 2] = x1;
-            left[leftoff + 3] = y1;
-            left[leftoff + 4] = ctrlx;
-            left[leftoff + 5] = ctrly;
-        }
-        if (right != null) {
-            right[rightoff + 0] = ctrlx;
-            right[rightoff + 1] = ctrly;
-            right[rightoff + 2] = x2;
-            right[rightoff + 3] = y2;
-        }
-    }
-
-    static void subdivideAt(float t, float src[], int srcoff,
-                            float left[], int leftoff,
-                            float right[], int rightoff, int size)
-    {
-        switch(size) {
-        case 8:
-            subdivideCubicAt(t, src, srcoff, left, leftoff, right, rightoff);
-            break;
-        case 6:
-            subdivideQuadAt(t, src, srcoff, left, leftoff, right, rightoff);
-            break;
-        }
-    }
-}
diff a/modules/javafx.graphics/src/main/java/com/sun/openpisces/Renderer.java b/modules/javafx.graphics/src/main/java/com/sun/openpisces/Renderer.java
--- a/modules/javafx.graphics/src/main/java/com/sun/openpisces/Renderer.java
+++ /dev/null
@@ -1,595 +0,0 @@
-/*
- * Copyright (c) 2007, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.openpisces;
-
-import com.sun.javafx.geom.PathConsumer2D;
-import java.util.Arrays;
-
-/**
- */
-public final class Renderer implements PathConsumer2D {
-
-    private final class ScanlineIterator {
-
-        private int[] crossings;
-        private int[] edgePtrs;
-        private int edgeCount;
-
-        // crossing bounds. The bounds are not necessarily tight (the scan line
-        // at minY, for example, might have no crossings). The x bounds will
-        // be accumulated as crossings are computed.
-        private int nextY;
-
-        private static final int INIT_CROSSINGS_SIZE = 10;
-
-        private ScanlineIterator() {
-            crossings = new int[INIT_CROSSINGS_SIZE];
-            edgePtrs = new int[INIT_CROSSINGS_SIZE];
-            reset();
-        }
-
-        public void reset() {
-            // We don't care if we clip some of the line off with ceil, since
-            // no scan line crossings will be eliminated (in fact, the ceil is
-            // the y of the first scan line crossing).
-            nextY = sampleRowMin;
-            edgeCount = 0;
-        }
-
-        private int next() {
-            // TODO: make function that convert from y value to bucket idx?
-            // (RT-26922)
-            int cury = nextY++;
-            int bucket = cury - boundsMinY;
-            int count = this.edgeCount;
-            int ptrs[] = this.edgePtrs;
-            float edges[] = Renderer.this.edges;
-            int bucketcount = edgeBuckets[bucket*2 + 1];
-            if ((bucketcount & 0x1) != 0) {
-                int newCount = 0;
-                for (int i = 0; i < count; i++) {
-                    int ecur = ptrs[i];
-                    if (edges[ecur+YMAX] > cury) {
-                        ptrs[newCount++] = ecur;
-                    }
-                }
-                count = newCount;
-            }
-            ptrs = Helpers.widenArray(ptrs, count, bucketcount >> 1);
-            for (int ecur = edgeBuckets[bucket*2];
-                 ecur != 0;
-                 ecur = (int)edges[ecur+NEXT])
-            {
-                ptrs[count++] = --ecur;
-                // REMIND: Adjust start Y if necessary
-            }
-            this.edgePtrs = ptrs;
-            this.edgeCount = count;
-//            if ((count & 0x1) != 0) {
-//                System.out.println("ODD NUMBER OF EDGES!!!!");
-//            }
-            int xings[] = this.crossings;
-            if (xings.length < count) {
-                this.crossings = xings = new int[ptrs.length];
-            }
-            for (int i = 0; i < count; i++) {
-                int ecur = ptrs[i];
-                float curx = edges[ecur+CURX];
-                int cross = ((int) Math.ceil(curx - 0.5f)) << 1;
-                edges[ecur+CURX] = curx + edges[ecur+SLOPE];
-                if (edges[ecur+OR] > 0) {
-                    cross |= 1;
-                }
-                int j = i;
-                while (--j >= 0) {
-                    int jcross = xings[j];
-                    if (jcross <= cross) {
-                        break;
-                    }
-                    xings[j+1] = jcross;
-                    ptrs[j+1] = ptrs[j];
-                }
-                xings[j+1] = cross;
-                ptrs[j+1] = ecur;
-            }
-            return count;
-        }
-
-        private boolean hasNext() {
-            return nextY < sampleRowMax;
-        }
-
-        private int curY() {
-            return nextY - 1;
-        }
-    }
-
-
-//////////////////////////////////////////////////////////////////////////////
-//  EDGE LIST
-//////////////////////////////////////////////////////////////////////////////
-// TODO(maybe): very tempting to use fixed point here. A lot of opportunities
-// for shifts and just removing certain operations altogether. (RT-26922)
-
-    // common to all types of input path segments.
-    private static final int YMAX = 0;
-    private static final int CURX = 1;
-    // NEXT and OR are meant to be indeces into "int" fields, but arrays must
-    // be homogenous, so every field is a float. However floats can represent
-    // exactly up to 24 bit ints, so we're ok as long as we check for overflow.
-    private static final int OR   = 2;
-    private static final int SLOPE = 3;
-    private static final int NEXT = 4;
-    private static final int SIZEOF_EDGE = 5;
-
-    private static final int MAX_EDGE_IDX = 1 << 24;
-
-    private int sampleRowMin;
-    private int sampleRowMax;
-    private float edgeMinX;
-    private float edgeMaxX;
-
-    private float[] edges;
-    private int[] edgeBuckets;
-    private int numEdges;
-
-    private static final float DEC_BND = 1.0f;
-    private static final float INC_BND = 0.4f;
-
-    // each bucket is a linked list. this method adds eptr to the
-    // start "bucket"th linked list.
-    private void addEdgeToBucket(final int eptr, final int bucket) {
-        // we could implement this in terms of insertEdge, but this is a special
-        // case, so we optimize a bit.
-        if (edgeBuckets[bucket*2] >= MAX_EDGE_IDX) {
-            throw new ArrayIndexOutOfBoundsException(edgeBuckets[bucket*2]);
-        }
-        edges[eptr+NEXT] = edgeBuckets[bucket*2];
-        edgeBuckets[bucket*2] = eptr + 1;
-        edgeBuckets[bucket*2 + 1] += 2;
-    }
-
-    // Flattens using adaptive forward differencing. This only carries out
-    // one iteration of the AFD loop. All it does is update AFD variables (i.e.
-    // X0, Y0, D*[X|Y], COUNT; not variables used for computing scanline crossings).
-    private void quadBreakIntoLinesAndAdd(float x0, float y0,
-                                          final Curve c,
-                                          final float x2, final float y2)
-    {
-        final float QUAD_DEC_BND = 32;
-        final int countlg = 4;
-        int count = 1 << countlg;
-        int countsq = count * count;
-        float maxDD = Math.max(c.dbx / countsq, c.dby / countsq);
-        while (maxDD > QUAD_DEC_BND) {
-            maxDD /= 4;
-            count <<= 1;
-        }
-
-        countsq = count * count;
-        final float ddx = c.dbx / countsq;
-        final float ddy = c.dby / countsq;
-        float dx = c.bx / countsq + c.cx / count;
-        float dy = c.by / countsq + c.cy / count;
-
-        while (count-- > 1) {
-            float x1 = x0 + dx;
-            dx += ddx;
-            float y1 = y0 + dy;
-            dy += ddy;
-            addLine(x0, y0, x1, y1);
-            x0 = x1;
-            y0 = y1;
-        }
-        addLine(x0, y0, x2, y2);
-    }
-
-    // x0, y0 and x3,y3 are the endpoints of the curve. We could compute these
-    // using c.xat(0),c.yat(0) and c.xat(1),c.yat(1), but this might introduce
-    // numerical errors, and our callers already have the exact values.
-    // Another alternative would be to pass all the control points, and call c.set
-    // here, but then too many numbers are passed around.
-    private void curveBreakIntoLinesAndAdd(float x0, float y0,
-                                           final Curve c,
-                                           final float x3, final float y3)
-    {
-        final int countlg = 3;
-        int count = 1 << countlg;
-
-        // the dx and dy refer to forward differencing variables, not the last
-        // coefficients of the "points" polynomial
-        float dddx, dddy, ddx, ddy, dx, dy;
-        dddx = 2f * c.dax / (1 << (3 * countlg));
-        dddy = 2f * c.day / (1 << (3 * countlg));
-
-        ddx = dddx + c.dbx / (1 << (2 * countlg));
-        ddy = dddy + c.dby / (1 << (2 * countlg));
-        dx = c.ax / (1 << (3 * countlg)) + c.bx / (1 << (2 * countlg)) + c.cx / (1 << countlg);
-        dy = c.ay / (1 << (3 * countlg)) + c.by / (1 << (2 * countlg)) + c.cy / (1 << countlg);
-
-        // we use x0, y0 to walk the line
-        float x1 = x0, y1 = y0;
-        while (count > 0) {
-            while (Math.abs(ddx) > DEC_BND || Math.abs(ddy) > DEC_BND) {
-                dddx /= 8;
-                dddy /= 8;
-                ddx = ddx/4 - dddx;
-                ddy = ddy/4 - dddy;
-                dx = (dx - ddx) / 2;
-                dy = (dy - ddy) / 2;
-                count <<= 1;
-            }
-            // can only do this on even "count" values, because we must divide count by 2
-            while (count % 2 == 0 && Math.abs(dx) <= INC_BND && Math.abs(dy) <= INC_BND) {
-                dx = 2 * dx + ddx;
-                dy = 2 * dy + ddy;
-                ddx = 4 * (ddx + dddx);
-                ddy = 4 * (ddy + dddy);
-                dddx = 8 * dddx;
-                dddy = 8 * dddy;
-                count >>= 1;
-            }
-            count--;
-            if (count > 0) {
-                x1 += dx;
-                dx += ddx;
-                ddx += dddx;
-                y1 += dy;
-                dy += ddy;
-                ddy += dddy;
-            } else {
-                x1 = x3;
-                y1 = y3;
-            }
-            addLine(x0, y0, x1, y1);
-            x0 = x1;
-            y0 = y1;
-        }
-    }
-
-    private void addLine(float x1, float y1, float x2, float y2) {
-        float or = 1; // orientation of the line. 1 if y increases, 0 otherwise.
-        if (y2 < y1) {
-            or = y2; // no need to declare a temp variable. We have or.
-            y2 = y1;
-            y1 = or;
-            or = x2;
-            x2 = x1;
-            x1 = or;
-            or = 0;
-        }
-        final int firstCrossing = Math.max((int) Math.ceil(y1 - 0.5f), boundsMinY);
-        final int lastCrossing = Math.min((int) Math.ceil(y2 - 0.5f), boundsMaxY);
-        if (firstCrossing >= lastCrossing) {
-            return;
-        }
-        if (firstCrossing < sampleRowMin) { sampleRowMin = firstCrossing; }
-        if (lastCrossing > sampleRowMax) { sampleRowMax = lastCrossing; }
-
-        final float slope = (x2 - x1) / (y2 - y1);
-
-        if (slope > 0) { // <==> x1 < x2
-            if (x1 < edgeMinX) { edgeMinX = x1; }
-            if (x2 > edgeMaxX) { edgeMaxX = x2; }
-        } else {
-            if (x2 < edgeMinX) { edgeMinX = x2; }
-            if (x1 > edgeMaxX) { edgeMaxX = x1; }
-        }
-
-        final int bucketIdx = firstCrossing - boundsMinY;
-        final int nextCurrEdge = edgeBuckets[bucketIdx*2];
-        if (nextCurrEdge >= MAX_EDGE_IDX) {
-            throw new ArrayIndexOutOfBoundsException(nextCurrEdge);
-        }
-
-        final int ptr = numEdges * SIZEOF_EDGE;
-        edges = Helpers.widenArray(edges, ptr, SIZEOF_EDGE);
-        numEdges++;
-        edges[ptr+OR] = or;
-        edges[ptr+CURX] = x1 + (firstCrossing + 0.5f - y1) * slope;
-        edges[ptr+SLOPE] = slope;
-        edges[ptr+YMAX] = lastCrossing;
-        addEdgeToBucket(ptr, bucketIdx);
-        edgeBuckets[(lastCrossing - boundsMinY)*2 + 1] |= 1;
-    }
-
-// END EDGE LIST
-//////////////////////////////////////////////////////////////////////////////
-
-
-    public static final int WIND_EVEN_ODD = 0;
-    public static final int WIND_NON_ZERO = 1;
-
-    // Antialiasing
-    final private int SUBPIXEL_LG_POSITIONS_X;
-    final private int SUBPIXEL_LG_POSITIONS_Y;
-    final private int SUBPIXEL_POSITIONS_X;
-    final private int SUBPIXEL_POSITIONS_Y;
-    final private int SUBPIXEL_MASK_X;
-    final private int SUBPIXEL_MASK_Y;
-    final int MAX_AA_ALPHA;
-
-    // Bounds of the drawing region, at subpixel precision.
-    private int boundsMinX, boundsMinY, boundsMaxX, boundsMaxY;
-
-    // Current winding rule
-    private int windingRule;
-
-    // Current drawing position, i.e., final point of last segment
-    private float x0, y0;
-
-    // Position of most recent 'moveTo' command
-    private float pix_sx0, pix_sy0;
-
-    public Renderer(int subpixelLgPositionsX, int subpixelLgPositionsY)
-    {
-        this.SUBPIXEL_LG_POSITIONS_X = subpixelLgPositionsX;
-        this.SUBPIXEL_LG_POSITIONS_Y = subpixelLgPositionsY;
-        this.SUBPIXEL_POSITIONS_X = 1 << (SUBPIXEL_LG_POSITIONS_X);
-        this.SUBPIXEL_POSITIONS_Y = 1 << (SUBPIXEL_LG_POSITIONS_Y);
-        this.SUBPIXEL_MASK_X = SUBPIXEL_POSITIONS_X - 1;
-        this.SUBPIXEL_MASK_Y = SUBPIXEL_POSITIONS_Y - 1;
-        this.MAX_AA_ALPHA = (SUBPIXEL_POSITIONS_X * SUBPIXEL_POSITIONS_Y);
-    }
-
-    public Renderer(int subpixelLgPositionsX, int subpixelLgPositionsY,
-            int pix_boundsX, int pix_boundsY,
-            int pix_boundsWidth, int pix_boundsHeight,
-            int windingRule)
-    {
-        this(subpixelLgPositionsX, subpixelLgPositionsY);
-        reset(pix_boundsX, pix_boundsY, pix_boundsWidth, pix_boundsHeight,
-              windingRule);
-    }
-
-    public void reset(int pix_boundsX, int pix_boundsY,
-                      int pix_boundsWidth, int pix_boundsHeight,
-                      int windingRule)
-    {
-        this.windingRule = windingRule;
-
-        this.boundsMinX = pix_boundsX * SUBPIXEL_POSITIONS_X;
-        this.boundsMinY = pix_boundsY * SUBPIXEL_POSITIONS_Y;
-        this.boundsMaxX = (pix_boundsX + pix_boundsWidth) * SUBPIXEL_POSITIONS_X;
-        this.boundsMaxY = (pix_boundsY + pix_boundsHeight) * SUBPIXEL_POSITIONS_Y;
-
-        this.edgeMinX = Float.POSITIVE_INFINITY;
-        this.edgeMaxX = Float.NEGATIVE_INFINITY;
-        this.sampleRowMax = boundsMinY;
-        this.sampleRowMin = boundsMaxY;
-
-        int numBuckets = boundsMaxY - boundsMinY;
-        if (edgeBuckets == null || edgeBuckets.length < numBuckets*2+2) {
-            // The last 2 entries are ignored and only used to store unused
-            // values for segments ending on the last line of the bounds
-            // so we can avoid having to check the bounds on this array.
-            edgeBuckets = new int[numBuckets*2 + 2];
-        } else {
-            // Only need to fill the first numBuckets*2 entries since the
-            // last 2 entries are write-only for overflow avoidance only.
-            Arrays.fill(edgeBuckets, 0, numBuckets*2, 0);
-        }
-        if (edges == null) {
-            edges = new float[SIZEOF_EDGE * 32];
-        }
-        numEdges = 0;
-        pix_sx0 = pix_sy0 = x0 = y0 = 0f;
-    }
-
-    private float tosubpixx(float pix_x) {
-        return pix_x * SUBPIXEL_POSITIONS_X;
-    }
-    private float tosubpixy(float pix_y) {
-        return pix_y * SUBPIXEL_POSITIONS_Y;
-    }
-
-    public void moveTo(float pix_x0, float pix_y0) {
-        closePath();
-        this.pix_sx0 = pix_x0;
-        this.pix_sy0 = pix_y0;
-        this.y0 = tosubpixy(pix_y0);
-        this.x0 = tosubpixx(pix_x0);
-    }
-
-    public void lineTo(float pix_x1, float pix_y1) {
-        float x1 = tosubpixx(pix_x1);
-        float y1 = tosubpixy(pix_y1);
-        addLine(x0, y0, x1, y1);
-        x0 = x1;
-        y0 = y1;
-    }
-
-    private Curve c = new Curve();
-    @Override public void curveTo(float x1, float y1,
-                                  float x2, float y2,
-                                  float x3, float y3)
-    {
-        final float xe = tosubpixx(x3);
-        final float ye = tosubpixy(y3);
-        c.set(x0, y0, tosubpixx(x1), tosubpixy(y1), tosubpixx(x2), tosubpixy(y2), xe, ye);
-        curveBreakIntoLinesAndAdd(x0, y0, c, xe, ye);
-        x0 = xe;
-        y0 = ye;
-    }
-
-    @Override public void quadTo(float x1, float y1, float x2, float y2) {
-        final float xe = tosubpixx(x2);
-        final float ye = tosubpixy(y2);
-        c.set(x0, y0, tosubpixx(x1), tosubpixy(y1), xe, ye);
-        quadBreakIntoLinesAndAdd(x0, y0, c, xe, ye);
-        x0 = xe;
-        y0 = ye;
-    }
-
-    public void closePath() {
-        // lineTo expects its input in pixel coordinates.
-        lineTo(pix_sx0, pix_sy0);
-    }
-
-    public void pathDone() {
-        closePath();
-    }
-
-    private int savedAlpha[];
-    private ScanlineIterator savedIterator;
-    public void produceAlphas(AlphaConsumer ac) {
-        ac.setMaxAlpha(MAX_AA_ALPHA);
-
-        // Mask to determine the relevant bit of the crossing sum
-        // 0x1 if EVEN_ODD, all bits if NON_ZERO
-        int mask = (windingRule == WIND_EVEN_ODD) ? 0x1 : ~0x0;
-
-        // add 2 to better deal with the last pixel in a pixel row.
-        int width = ac.getWidth();
-        int alpha[] = savedAlpha;
-        if (alpha == null || alpha.length < width+2) {
-            savedAlpha = alpha = new int[width+2];
-        } else {
-            Arrays.fill(alpha, 0, width+2, 0);
-        }
-
-        int bboxx0 = ac.getOriginX() << SUBPIXEL_LG_POSITIONS_X;
-        int bboxx1 = bboxx0 + (width << SUBPIXEL_LG_POSITIONS_X);
-
-        // Now we iterate through the scanlines. We must tell emitRow the coord
-        // of the first non-transparent pixel, so we must keep accumulators for
-        // the first and last pixels of the section of the current pixel row
-        // that we will emit.
-        // We also need to accumulate pix_bbox*, but the iterator does it
-        // for us. We will just get the values from it once this loop is done
-        int pix_maxX = bboxx1 >> SUBPIXEL_LG_POSITIONS_X;
-        int pix_minX = bboxx0 >> SUBPIXEL_LG_POSITIONS_Y;
-
-        int y = boundsMinY; // needs to be declared here so we emit the last row properly.
-        ScanlineIterator it = savedIterator;
-        if (it == null) {
-            savedIterator = it = new ScanlineIterator();
-        } else {
-            it.reset();
-        }
-        for ( ; it.hasNext(); ) {
-            int numCrossings = it.next();
-            int[] crossings = it.crossings;
-            y = it.curY();
-
-            if (numCrossings > 0) {
-                int lowx = crossings[0] >> 1;
-                int highx = crossings[numCrossings - 1] >> 1;
-                int x0 = Math.max(lowx, bboxx0);
-                int x1 = Math.min(highx, bboxx1);
-
-                pix_minX = Math.min(pix_minX, x0 >> SUBPIXEL_LG_POSITIONS_X);
-                pix_maxX = Math.max(pix_maxX, x1 >> SUBPIXEL_LG_POSITIONS_X);
-            }
-
-            int sum = 0;
-            int prev = bboxx0;
-            for (int i = 0; i < numCrossings; i++) {
-                int curxo = crossings[i];
-                int curx = curxo >> 1;
-                int crorientation = ((curxo & 0x1) << 1) - 1;
-                if ((sum & mask) != 0) {
-                    int x0 = Math.max(prev, bboxx0);
-                    int x1 = Math.min(curx, bboxx1);
-                    if (x0 < x1) {
-                        x0 -= bboxx0; // turn x0, x1 from coords to indices
-                        x1 -= bboxx0; // in the alpha array.
-
-                        int pix_x = x0 >> SUBPIXEL_LG_POSITIONS_X;
-                        int pix_xmaxm1 = (x1 - 1) >> SUBPIXEL_LG_POSITIONS_X;
-
-                        if (pix_x == pix_xmaxm1) {
-                            // Start and end in same pixel
-                            alpha[pix_x] += (x1 - x0);
-                            alpha[pix_x+1] -= (x1 - x0);
-                        } else {
-                            int pix_xmax = x1 >> SUBPIXEL_LG_POSITIONS_X;
-                            alpha[pix_x] += SUBPIXEL_POSITIONS_X - (x0 & SUBPIXEL_MASK_X);
-                            alpha[pix_x+1] += (x0 & SUBPIXEL_MASK_X);
-                            alpha[pix_xmax] -= SUBPIXEL_POSITIONS_X - (x1 & SUBPIXEL_MASK_X);
-                            alpha[pix_xmax+1] -= (x1 & SUBPIXEL_MASK_X);
-                        }
-                    }
-                }
-                sum += crorientation;
-                prev = curx;
-            }
-
-            // even if this last row had no crossings, alpha will be zeroed
-            // from the last emitRow call. But this doesn't matter because
-            // maxX < minX, so no row will be emitted to the cache.
-            if ((y & SUBPIXEL_MASK_Y) == SUBPIXEL_MASK_Y) {
-                ac.setAndClearRelativeAlphas(alpha, y >> SUBPIXEL_LG_POSITIONS_Y,
-                                             pix_minX, pix_maxX);
-                pix_maxX = bboxx1 >> SUBPIXEL_LG_POSITIONS_X;
-                pix_minX = bboxx0 >> SUBPIXEL_LG_POSITIONS_Y;
-            }
-        }
-
-        // Emit final row.
-        // Note, if y is on a MASK row then it was already sent above...
-        if ((y & SUBPIXEL_MASK_Y) < SUBPIXEL_MASK_Y) {
-            ac.setAndClearRelativeAlphas(alpha, y >> SUBPIXEL_LG_POSITIONS_Y,
-                                         pix_minX, pix_maxX);
-        }
-    }
-
-    public int getSubpixMinX() {
-        int sampleColMin = (int) Math.ceil(edgeMinX - 0.5f);
-        if (sampleColMin < boundsMinX) sampleColMin = boundsMinX;
-        return sampleColMin;
-    }
-
-    public int getSubpixMaxX() {
-        int sampleColMax = (int) Math.ceil(edgeMaxX - 0.5f);
-        if (sampleColMax > boundsMaxX) sampleColMax = boundsMaxX;
-        return sampleColMax;
-    }
-
-    public int getSubpixMinY() {
-        return sampleRowMin;
-    }
-
-    public int getSubpixMaxY() {
-        return sampleRowMax;
-    }
-
-    public int getOutpixMinX() {
-        return (getSubpixMinX() >> SUBPIXEL_LG_POSITIONS_X);
-    }
-
-    public int getOutpixMaxX() {
-        return (getSubpixMaxX() + SUBPIXEL_MASK_X) >> SUBPIXEL_LG_POSITIONS_X;
-    }
-
-    public int getOutpixMinY() {
-        return (sampleRowMin >> SUBPIXEL_LG_POSITIONS_Y);
-    }
-
-    public int getOutpixMaxY() {
-        return (sampleRowMax + SUBPIXEL_MASK_Y) >> SUBPIXEL_LG_POSITIONS_Y;
-    }
-}
diff a/modules/javafx.graphics/src/main/java/com/sun/openpisces/Stroker.java b/modules/javafx.graphics/src/main/java/com/sun/openpisces/Stroker.java
--- a/modules/javafx.graphics/src/main/java/com/sun/openpisces/Stroker.java
+++ /dev/null
@@ -1,1283 +0,0 @@
-/*
- * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.openpisces;
-
-import com.sun.javafx.geom.PathConsumer2D;
-import java.util.Arrays;
-import java.util.Iterator;
-
-// TODO: some of the arithmetic here is too verbose and prone to hard to
-// debug typos. We should consider making a small Point/Vector class that
-// has methods like plus(Point), minus(Point), dot(Point), cross(Point)and such
-// (RT-26922)
-public final class Stroker implements PathConsumer2D {
-
-    private static final int MOVE_TO = 0;
-    private static final int DRAWING_OP_TO = 1; // ie. curve, line, or quad
-    private static final int CLOSE = 2;
-
-    /**
-     * Constant value for join style.
-     */
-    public static final int JOIN_MITER = 0;
-
-    /**
-     * Constant value for join style.
-     */
-    public static final int JOIN_ROUND = 1;
-
-    /**
-     * Constant value for join style.
-     */
-    public static final int JOIN_BEVEL = 2;
-
-    /**
-     * Constant value for end cap style.
-     */
-    public static final int CAP_BUTT = 0;
-
-    /**
-     * Constant value for end cap style.
-     */
-    public static final int CAP_ROUND = 1;
-
-    /**
-     * Constant value for end cap style.
-     */
-    public static final int CAP_SQUARE = 2;
-
-    private PathConsumer2D out;
-
-    private int capStyle;
-    private int joinStyle;
-
-    private float lineWidth2;
-
-    private final float[][] offset = new float[3][2];
-    private final float[] miter = new float[2];
-    private float miterLimitSq;
-
-    private int prev;
-
-    // The starting point of the path, and the slope there.
-    private float sx0, sy0, sdx, sdy;
-    // the current point and the slope there.
-    private float cx0, cy0, cdx, cdy; // c stands for current
-    // vectors that when added to (sx0,sy0) and (cx0,cy0) respectively yield the
-    // first and last points on the left parallel path. Since this path is
-    // parallel, it's slope at any point is parallel to the slope of the
-    // original path (thought they may have different directions), so these
-    // could be computed from sdx,sdy and cdx,cdy (and vice versa), but that
-    // would be error prone and hard to read, so we keep these anyway.
-    private float smx, smy, cmx, cmy;
-
-    private final PolyStack reverse = new PolyStack();
-
-    /**
-     * Constructs a <code>Stroker</code>.
-     *
-     * @param pc2d an output <code>PathConsumer2D</code>.
-     * @param lineWidth the desired line width in pixels
-     * @param capStyle the desired end cap style, one of
-     * <code>CAP_BUTT</code>, <code>CAP_ROUND</code> or
-     * <code>CAP_SQUARE</code>.
-     * @param joinStyle the desired line join style, one of
-     * <code>JOIN_MITER</code>, <code>JOIN_ROUND</code> or
-     * <code>JOIN_BEVEL</code>.
-     * @param miterLimit the desired miter limit
-     */
-    public Stroker(PathConsumer2D pc2d,
-                   float lineWidth,
-                   int capStyle,
-                   int joinStyle,
-                   float miterLimit)
-    {
-        this(pc2d);
-
-        reset(lineWidth, capStyle, joinStyle, miterLimit);
-    }
-
-    public Stroker(PathConsumer2D pc2d) {
-        setConsumer(pc2d);
-    }
-
-    public void setConsumer(PathConsumer2D pc2d) {
-        this.out = pc2d;
-    }
-
-    public void reset(float lineWidth, int capStyle, int joinStyle,
-                      float miterLimit) {
-        this.lineWidth2 = lineWidth / 2;
-        this.capStyle = capStyle;
-        this.joinStyle = joinStyle;
-
-        float limit = miterLimit * lineWidth2;
-        this.miterLimitSq = limit*limit;
-
-        this.prev = CLOSE;
-    }
-
-    private static void computeOffset(final float lx, final float ly,
-                                      final float w, final float[] m)
-    {
-        final float len = (float)Math.sqrt(lx*lx + ly*ly);
-        if (len == 0) {
-            m[0] = m[1] = 0;
-        } else {
-            m[0] = (ly * w)/len;
-            m[1] = -(lx * w)/len;
-        }
-    }
-
-    // Returns true if the vectors (dx1, dy1) and (dx2, dy2) are
-    // clockwise (if dx1,dy1 needs to be rotated clockwise to close
-    // the smallest angle between it and dx2,dy2).
-    // This is equivalent to detecting whether a point q is on the right side
-    // of a line passing through points p1, p2 where p2 = p1+(dx1,dy1) and
-    // q = p2+(dx2,dy2), which is the same as saying p1, p2, q are in a
-    // clockwise order.
-    // NOTE: "clockwise" here assumes coordinates with 0,0 at the bottom left.
-    private static boolean isCW(final float dx1, final float dy1,
-                                final float dx2, final float dy2)
-    {
-        return dx1 * dy2 <= dy1 * dx2;
-    }
-
-    // pisces used to use fixed point arithmetic with 16 decimal digits. I
-    // didn't want to change the values of the constant below when I converted
-    // it to floating point, so that's why the divisions by 2^16 are there.
-    private static final float ROUND_JOIN_THRESHOLD = 1000/65536f;
-
-    private void drawRoundJoin(float x, float y,
-                               float omx, float omy, float mx, float my,
-                               boolean rev,
-                               float threshold)
-    {
-        if ((omx == 0 && omy == 0) || (mx == 0 && my == 0)) {
-            return;
-        }
-
-        float domx = omx - mx;
-        float domy = omy - my;
-        float len = domx*domx + domy*domy;
-        if (len < threshold) {
-            return;
-        }
-
-        if (rev) {
-            omx = -omx;
-            omy = -omy;
-            mx = -mx;
-            my = -my;
-        }
-        drawRoundJoin(x, y, omx, omy, mx, my, rev);
-    }
-
-    private void drawRoundJoin(float cx, float cy,
-                               float omx, float omy,
-                               float mx, float my,
-                               boolean rev)
-    {
-        // The sign of the dot product of mx,my and omx,omy is equal to the
-        // the sign of the cosine of ext
-        // (ext is the angle between omx,omy and mx,my).
-        double cosext = omx * mx + omy * my;
-        // If it is >=0, we know that abs(ext) is <= 90 degrees, so we only
-        // need 1 curve to approximate the circle section that joins omx,omy
-        // and mx,my.
-        final int numCurves = cosext >= 0 ? 1 : 2;
-
-        switch (numCurves) {
-        case 1:
-            drawBezApproxForArc(cx, cy, omx, omy, mx, my, rev);
-            break;
-        case 2:
-            // we need to split the arc into 2 arcs spanning the same angle.
-            // The point we want will be one of the 2 intersections of the
-            // perpendicular bisector of the chord (omx,omy)->(mx,my) and the
-            // circle. We could find this by scaling the vector
-            // (omx+mx, omy+my)/2 so that it has length=lineWidth2 (and thus lies
-            // on the circle), but that can have numerical problems when the angle
-            // between omx,omy and mx,my is close to 180 degrees. So we compute a
-            // normal of (omx,omy)-(mx,my). This will be the direction of the
-            // perpendicular bisector. To get one of the intersections, we just scale
-            // this vector that its length is lineWidth2 (this works because the
-            // perpendicular bisector goes through the origin). This scaling doesn't
-            // have numerical problems because we know that lineWidth2 divided by
-            // this normal's length is at least 0.5 and at most sqrt(2)/2 (because
-            // we know the angle of the arc is > 90 degrees).
-            float nx = my - omy, ny = omx - mx;
-            float nlen = (float)Math.sqrt(nx*nx + ny*ny);
-            float scale = lineWidth2/nlen;
-            float mmx = nx * scale, mmy = ny * scale;
-
-            // if (isCW(omx, omy, mx, my) != isCW(mmx, mmy, mx, my)) then we've
-            // computed the wrong intersection so we get the other one.
-            // The test above is equivalent to if (rev).
-            if (rev) {
-                mmx = -mmx;
-                mmy = -mmy;
-            }
-            drawBezApproxForArc(cx, cy, omx, omy, mmx, mmy, rev);
-            drawBezApproxForArc(cx, cy, mmx, mmy, mx, my, rev);
-            break;
-        }
-    }
-
-    // the input arc defined by omx,omy and mx,my must span <= 90 degrees.
-    private void drawBezApproxForArc(final float cx, final float cy,
-                                     final float omx, final float omy,
-                                     final float mx, final float my,
-                                     boolean rev)
-    {
-        float cosext2 = (omx * mx + omy * my) / (2 * lineWidth2 * lineWidth2);
-        // cv is the length of P1-P0 and P2-P3 divided by the radius of the arc
-        // (so, cv assumes the arc has radius 1). P0, P1, P2, P3 are the points that
-        // define the bezier curve we're computing.
-        // It is computed using the constraints that P1-P0 and P3-P2 are parallel
-        // to the arc tangents at the endpoints, and that |P1-P0|=|P3-P2|.
-        float cv = (float)((4.0 / 3.0) * Math.sqrt(0.5-cosext2) /
-                           (1.0 + Math.sqrt(cosext2+0.5)));
-        // if clockwise, we need to negate cv.
-        if (rev) { // rev is equivalent to isCW(omx, omy, mx, my)
-            cv = -cv;
-        }
-        final float x1 = cx + omx;
-        final float y1 = cy + omy;
-        final float x2 = x1 - cv * omy;
-        final float y2 = y1 + cv * omx;
-
-        final float x4 = cx + mx;
-        final float y4 = cy + my;
-        final float x3 = x4 + cv * my;
-        final float y3 = y4 - cv * mx;
-
-        emitCurveTo(x1, y1, x2, y2, x3, y3, x4, y4, rev);
-    }
-
-    private void drawRoundCap(float cx, float cy, float mx, float my) {
-        final float C = 0.5522847498307933f;
-        // the first and second arguments of the following two calls
-        // are really will be ignored by emitCurveTo (because of the false),
-        // but we put them in anyway, as opposed to just giving it 4 zeroes,
-        // because it's just 4 additions and it's not good to rely on this
-        // sort of assumption (right now it's true, but that may change).
-        emitCurveTo(cx+mx,      cy+my,
-                    cx+mx-C*my, cy+my+C*mx,
-                    cx-my+C*mx, cy+mx+C*my,
-                    cx-my,      cy+mx,
-                    false);
-        emitCurveTo(cx-my,      cy+mx,
-                    cx-my-C*mx, cy+mx-C*my,
-                    cx-mx-C*my, cy-my+C*mx,
-                    cx-mx,      cy-my,
-                    false);
-    }
-
-    // Return the intersection point of the lines (x0, y0) -> (x1, y1)
-    // and (x0p, y0p) -> (x1p, y1p) in m[0] and m[1]
-    private void computeMiter(final float x0, final float y0,
-                              final float x1, final float y1,
-                              final float x0p, final float y0p,
-                              final float x1p, final float y1p,
-                              final float[] m, int off)
-    {
-        float x10 = x1 - x0;
-        float y10 = y1 - y0;
-        float x10p = x1p - x0p;
-        float y10p = y1p - y0p;
-
-        // if this is 0, the lines are parallel. If they go in the
-        // same direction, there is no intersection so m[off] and
-        // m[off+1] will contain infinity, so no miter will be drawn.
-        // If they go in the same direction that means that the start of the
-        // current segment and the end of the previous segment have the same
-        // tangent, in which case this method won't even be involved in
-        // miter drawing because it won't be called by drawMiter (because
-        // (mx == omx && my == omy) will be true, and drawMiter will return
-        // immediately).
-        float den = x10*y10p - x10p*y10;
-        float t = x10p*(y0-y0p) - y10p*(x0-x0p);
-        t /= den;
-        m[off++] = x0 + t*x10;
-        m[off] = y0 + t*y10;
-    }
-
-    // Return the intersection point of the lines (x0, y0) -> (x1, y1)
-    // and (x0p, y0p) -> (x1p, y1p) in m[0] and m[1]
-    private void safecomputeMiter(final float x0, final float y0,
-                                  final float x1, final float y1,
-                                  final float x0p, final float y0p,
-                                  final float x1p, final float y1p,
-                                  final float[] m, int off)
-    {
-        float x10 = x1 - x0;
-        float y10 = y1 - y0;
-        float x10p = x1p - x0p;
-        float y10p = y1p - y0p;
-
-        // if this is 0, the lines are parallel. If they go in the
-        // same direction, there is no intersection so m[off] and
-        // m[off+1] will contain infinity, so no miter will be drawn.
-        // If they go in the same direction that means that the start of the
-        // current segment and the end of the previous segment have the same
-        // tangent, in which case this method won't even be involved in
-        // miter drawing because it won't be called by drawMiter (because
-        // (mx == omx && my == omy) will be true, and drawMiter will return
-        // immediately).
-        float den = x10*y10p - x10p*y10;
-        if (den == 0) {
-            m[off++] = (x0 + x0p) / 2.0f;
-            m[off] = (y0 + y0p) / 2.0f;
-            return;
-        }
-        float t = x10p*(y0-y0p) - y10p*(x0-x0p);
-        t /= den;
-        m[off++] = x0 + t*x10;
-        m[off] = y0 + t*y10;
-    }
-
-    private void drawMiter(final float pdx, final float pdy,
-                           final float x0, final float y0,
-                           final float dx, final float dy,
-                           float omx, float omy, float mx, float my,
-                           boolean rev)
-    {
-        if ((mx == omx && my == omy) ||
-            (pdx == 0 && pdy == 0) ||
-            (dx == 0 && dy == 0)) {
-            return;
-        }
-
-        if (rev) {
-            omx = -omx;
-            omy = -omy;
-            mx = -mx;
-            my = -my;
-        }
-
-        computeMiter((x0 - pdx) + omx, (y0 - pdy) + omy, x0 + omx, y0 + omy,
-                     (dx + x0) + mx, (dy + y0) + my, x0 + mx, y0 + my,
-                     miter, 0);
-
-        float lenSq = (miter[0]-x0)*(miter[0]-x0) + (miter[1]-y0)*(miter[1]-y0);
-
-        if (lenSq < miterLimitSq) {
-            emitLineTo(miter[0], miter[1], rev);
-        }
-    }
-
-    public void moveTo(float x0, float y0) {
-        if (prev == DRAWING_OP_TO) {
-            finish();
-        }
-        this.sx0 = this.cx0 = x0;
-        this.sy0 = this.cy0 = y0;
-        this.cdx = this.sdx = 1;
-        this.cdy = this.sdy = 0;
-        this.prev = MOVE_TO;
-    }
-
-    public void lineTo(float x1, float y1) {
-        float dx = x1 - cx0;
-        float dy = y1 - cy0;
-        if (dx == 0f && dy == 0f) {
-            dx = 1;
-        }
-        computeOffset(dx, dy, lineWidth2, offset[0]);
-        float mx = offset[0][0];
-        float my = offset[0][1];
-
-        drawJoin(cdx, cdy, cx0, cy0, dx, dy, cmx, cmy, mx, my);
-
-        emitLineTo(cx0 + mx, cy0 + my);
-        emitLineTo(x1 + mx, y1 + my);
-
-        emitLineTo(cx0 - mx, cy0 - my, true);
-        emitLineTo(x1 - mx, y1 - my, true);
-
-        this.cmx = mx;
-        this.cmy = my;
-        this.cdx = dx;
-        this.cdy = dy;
-        this.cx0 = x1;
-        this.cy0 = y1;
-        this.prev = DRAWING_OP_TO;
-    }
-
-    public void closePath() {
-        if (prev != DRAWING_OP_TO) {
-            if (prev == CLOSE) {
-                return;
-            }
-            emitMoveTo(cx0, cy0 - lineWidth2);
-            this.cmx = this.smx = 0;
-            this.cmy = this.smy = -lineWidth2;
-            this.cdx = this.sdx = 1;
-            this.cdy = this.sdy = 0;
-            finish();
-            return;
-        }
-
-        if (cx0 != sx0 || cy0 != sy0) {
-            lineTo(sx0, sy0);
-        }
-
-        drawJoin(cdx, cdy, cx0, cy0, sdx, sdy, cmx, cmy, smx, smy);
-
-        emitLineTo(sx0 + smx, sy0 + smy);
-
-        emitMoveTo(sx0 - smx, sy0 - smy);
-        emitReverse();
-
-        this.prev = CLOSE;
-        emitClose();
-    }
-
-    private void emitReverse() {
-        while(!reverse.isEmpty()) {
-            reverse.pop(out);
-        }
-    }
-
-    public void pathDone() {
-        if (prev == DRAWING_OP_TO) {
-            finish();
-        }
-
-        out.pathDone();
-        // this shouldn't matter since this object won't be used
-        // after the call to this method.
-        this.prev = CLOSE;
-    }
-
-    private void finish() {
-        if (capStyle == CAP_ROUND) {
-            drawRoundCap(cx0, cy0, cmx, cmy);
-        } else if (capStyle == CAP_SQUARE) {
-            emitLineTo(cx0 - cmy + cmx, cy0 + cmx + cmy);
-            emitLineTo(cx0 - cmy - cmx, cy0 + cmx - cmy);
-        }
-
-        emitReverse();
-
-        if (capStyle == CAP_ROUND) {
-            drawRoundCap(sx0, sy0, -smx, -smy);
-        } else if (capStyle == CAP_SQUARE) {
-            emitLineTo(sx0 + smy - smx, sy0 - smx - smy);
-            emitLineTo(sx0 + smy + smx, sy0 - smx + smy);
-        }
-
-        emitClose();
-    }
-
-    private void emitMoveTo(final float x0, final float y0) {
-        out.moveTo(x0, y0);
-    }
-
-    private void emitLineTo(final float x1, final float y1) {
-        out.lineTo(x1, y1);
-    }
-
-    private void emitLineTo(final float x1, final float y1,
-                            final boolean rev)
-    {
-        if (rev) {
-            reverse.pushLine(x1, y1);
-        } else {
-            emitLineTo(x1, y1);
-        }
-    }
-
-    private void emitQuadTo(final float x0, final float y0,
-                            final float x1, final float y1,
-                            final float x2, final float y2, final boolean rev)
-    {
-        if (rev) {
-            reverse.pushQuad(x0, y0, x1, y1);
-        } else {
-            out.quadTo(x1, y1, x2, y2);
-        }
-    }
-
-    private void emitCurveTo(final float x0, final float y0,
-                             final float x1, final float y1,
-                             final float x2, final float y2,
-                             final float x3, final float y3, final boolean rev)
-    {
-        if (rev) {
-            reverse.pushCubic(x0, y0, x1, y1, x2, y2);
-        } else {
-            out.curveTo(x1, y1, x2, y2, x3, y3);
-        }
-    }
-
-    private void emitClose() {
-        out.closePath();
-    }
-
-    private void drawJoin(float pdx, float pdy,
-                          float x0, float y0,
-                          float dx, float dy,
-                          float omx, float omy,
-                          float mx, float my)
-    {
-        if (prev != DRAWING_OP_TO) {
-            emitMoveTo(x0 + mx, y0 + my);
-            this.sdx = dx;
-            this.sdy = dy;
-            this.smx = mx;
-            this.smy = my;
-        } else {
-            boolean cw = isCW(pdx, pdy, dx, dy);
-            if (joinStyle == JOIN_MITER) {
-                drawMiter(pdx, pdy, x0, y0, dx, dy, omx, omy, mx, my, cw);
-            } else if (joinStyle == JOIN_ROUND) {
-                drawRoundJoin(x0, y0,
-                              omx, omy,
-                              mx, my, cw,
-                              ROUND_JOIN_THRESHOLD);
-            }
-            emitLineTo(x0, y0, !cw);
-        }
-        prev = DRAWING_OP_TO;
-    }
-
-    private static boolean within(final float x1, final float y1,
-                                  final float x2, final float y2,
-                                  final float ERR)
-    {
-        assert ERR > 0 : "";
-        // compare taxicab distance. ERR will always be small, so using
-        // true distance won't give much benefit
-        return (Helpers.within(x1, x2, ERR) &&  // we want to avoid calling Math.abs
-                Helpers.within(y1, y2, ERR)); // this is just as good.
-    }
-
-    private void getLineOffsets(float x1, float y1,
-                                float x2, float y2,
-                                float[] left, float[] right) {
-        computeOffset(x2 - x1, y2 - y1, lineWidth2, offset[0]);
-        left[0] = x1 + offset[0][0];
-        left[1] = y1 + offset[0][1];
-        left[2] = x2 + offset[0][0];
-        left[3] = y2 + offset[0][1];
-        right[0] = x1 - offset[0][0];
-        right[1] = y1 - offset[0][1];
-        right[2] = x2 - offset[0][0];
-        right[3] = y2 - offset[0][1];
-    }
-
-    private int computeOffsetCubic(float[] pts, final int off,
-                                   float[] leftOff, float[] rightOff)
-    {
-        // if p1=p2 or p3=p4 it means that the derivative at the endpoint
-        // vanishes, which creates problems with computeOffset. Usually
-        // this happens when this stroker object is trying to winden
-        // a curve with a cusp. What happens is that curveTo splits
-        // the input curve at the cusp, and passes it to this function.
-        // because of inaccuracies in the splitting, we consider points
-        // equal if they're very close to each other.
-        final float x1 = pts[off + 0], y1 = pts[off + 1];
-        final float x2 = pts[off + 2], y2 = pts[off + 3];
-        final float x3 = pts[off + 4], y3 = pts[off + 5];
-        final float x4 = pts[off + 6], y4 = pts[off + 7];
-
-        float dx4 = x4 - x3;
-        float dy4 = y4 - y3;
-        float dx1 = x2 - x1;
-        float dy1 = y2 - y1;
-
-        // if p1 == p2 && p3 == p4: draw line from p1->p4, unless p1 == p4,
-        // in which case ignore if p1 == p2
-        final boolean p1eqp2 = within(x1,y1,x2,y2, 6 * Math.ulp(y2));
-        final boolean p3eqp4 = within(x3,y3,x4,y4, 6 * Math.ulp(y4));
-        if (p1eqp2 && p3eqp4) {
-            getLineOffsets(x1, y1, x4, y4, leftOff, rightOff);
-            return 4;
-        } else if (p1eqp2) {
-            dx1 = x3 - x1;
-            dy1 = y3 - y1;
-        } else if (p3eqp4) {
-            dx4 = x4 - x2;
-            dy4 = y4 - y2;
-        }
-
-        // if p2-p1 and p4-p3 are parallel, that must mean this curve is a line
-        float dotsq = (dx1 * dx4 + dy1 * dy4);
-        dotsq = dotsq * dotsq;
-        float l1sq = dx1 * dx1 + dy1 * dy1, l4sq = dx4 * dx4 + dy4 * dy4;
-        if (Helpers.within(dotsq, l1sq * l4sq, 4 * Math.ulp(dotsq))) {
-            getLineOffsets(x1, y1, x4, y4, leftOff, rightOff);
-            return 4;
-        }
-
-//      What we're trying to do in this function is to approximate an ideal
-//      offset curve (call it I) of the input curve B using a bezier curve Bp.
-//      The constraints I use to get the equations are:
-//
-//      1. The computed curve Bp should go through I(0) and I(1). These are
-//      x1p, y1p, x4p, y4p, which are p1p and p4p. We still need to find
-//      4 variables: the x and y components of p2p and p3p (i.e. x2p, y2p, x3p, y3p).
-//
-//      2. Bp should have slope equal in absolute value to I at the endpoints. So,
-//      (by the way, the operator || in the comments below means "aligned with".
-//      It is defined on vectors, so when we say I'(0) || Bp'(0) we mean that
-//      vectors I'(0) and Bp'(0) are aligned, which is the same as saying
-//      that the tangent lines of I and Bp at 0 are parallel. Mathematically
-//      this means (I'(t) || Bp'(t)) <==> (I'(t) = c * Bp'(t)) where c is some
-//      nonzero constant.)
-//      I'(0) || Bp'(0) and I'(1) || Bp'(1). Obviously, I'(0) || B'(0) and
-//      I'(1) || B'(1); therefore, Bp'(0) || B'(0) and Bp'(1) || B'(1).
-//      We know that Bp'(0) || (p2p-p1p) and Bp'(1) || (p4p-p3p) and the same
-//      is true for any bezier curve; therefore, we get the equations
-//          (1) p2p = c1 * (p2-p1) + p1p
-//          (2) p3p = c2 * (p4-p3) + p4p
-//      We know p1p, p4p, p2, p1, p3, and p4; therefore, this reduces the number
-//      of unknowns from 4 to 2 (i.e. just c1 and c2).
-//      To eliminate these 2 unknowns we use the following constraint:
-//
-//      3. Bp(0.5) == I(0.5). Bp(0.5)=(x,y) and I(0.5)=(xi,yi), and I should note
-//      that I(0.5) is *the only* reason for computing dxm,dym. This gives us
-//          (3) Bp(0.5) = (p1p + 3 * (p2p + p3p) + p4p)/8, which is equivalent to
-//          (4) p2p + p3p = (Bp(0.5)*8 - p1p - p4p) / 3
-//      We can substitute (1) and (2) from above into (4) and we get:
-//          (5) c1*(p2-p1) + c2*(p4-p3) = (Bp(0.5)*8 - p1p - p4p)/3 - p1p - p4p
-//      which is equivalent to
-//          (6) c1*(p2-p1) + c2*(p4-p3) = (4/3) * (Bp(0.5) * 2 - p1p - p4p)
-//
-//      The right side of this is a 2D vector, and we know I(0.5), which gives us
-//      Bp(0.5), which gives us the value of the right side.
-//      The left side is just a matrix vector multiplication in disguise. It is
-//
-//      [x2-x1, x4-x3][c1]
-//      [y2-y1, y4-y3][c2]
-//      which, is equal to
-//      [dx1, dx4][c1]
-//      [dy1, dy4][c2]
-//      At this point we are left with a simple linear system and we solve it by
-//      getting the inverse of the matrix above. Then we use [c1,c2] to compute
-//      p2p and p3p.
-
-        float x = 0.125f * (x1 + 3 * (x2 + x3) + x4);
-        float y = 0.125f * (y1 + 3 * (y2 + y3) + y4);
-        // (dxm,dym) is some tangent of B at t=0.5. This means it's equal to
-        // c*B'(0.5) for some constant c.
-        float dxm = x3 + x4 - x1 - x2, dym = y3 + y4 - y1 - y2;
-
-        // this computes the offsets at t=0, 0.5, 1, using the property that
-        // for any bezier curve the vectors p2-p1 and p4-p3 are parallel to
-        // the (dx/dt, dy/dt) vectors at the endpoints.
-        computeOffset(dx1, dy1, lineWidth2, offset[0]);
-        computeOffset(dxm, dym, lineWidth2, offset[1]);
-        computeOffset(dx4, dy4, lineWidth2, offset[2]);
-        float x1p = x1 + offset[0][0]; // start
-        float y1p = y1 + offset[0][1]; // point
-        float xi  = x + offset[1][0]; // interpolation
-        float yi  = y + offset[1][1]; // point
-        float x4p = x4 + offset[2][0]; // end
-        float y4p = y4 + offset[2][1]; // point
-
-        float invdet43 = 4f / (3f * (dx1 * dy4 - dy1 * dx4));
-
-        float two_pi_m_p1_m_p4x = 2*xi - x1p - x4p;
-        float two_pi_m_p1_m_p4y = 2*yi - y1p - y4p;
-        float c1 = invdet43 * (dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y);
-        float c2 = invdet43 * (dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x);
-
-        float x2p, y2p, x3p, y3p;
-        x2p = x1p + c1*dx1;
-        y2p = y1p + c1*dy1;
-        x3p = x4p + c2*dx4;
-        y3p = y4p + c2*dy4;
-
-        leftOff[0] = x1p; leftOff[1] = y1p;
-        leftOff[2] = x2p; leftOff[3] = y2p;
-        leftOff[4] = x3p; leftOff[5] = y3p;
-        leftOff[6] = x4p; leftOff[7] = y4p;
-
-        x1p = x1 - offset[0][0]; y1p = y1 - offset[0][1];
-        xi = xi - 2 * offset[1][0]; yi = yi - 2 * offset[1][1];
-        x4p = x4 - offset[2][0]; y4p = y4 - offset[2][1];
-
-        two_pi_m_p1_m_p4x = 2*xi - x1p - x4p;
-        two_pi_m_p1_m_p4y = 2*yi - y1p - y4p;
-        c1 = invdet43 * (dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y);
-        c2 = invdet43 * (dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x);
-
-        x2p = x1p + c1*dx1;
-        y2p = y1p + c1*dy1;
-        x3p = x4p + c2*dx4;
-        y3p = y4p + c2*dy4;
-
-        rightOff[0] = x1p; rightOff[1] = y1p;
-        rightOff[2] = x2p; rightOff[3] = y2p;
-        rightOff[4] = x3p; rightOff[5] = y3p;
-        rightOff[6] = x4p; rightOff[7] = y4p;
-        return 8;
-    }
-
-    // compute offset curves using bezier spline through t=0.5 (i.e.
-    // ComputedCurve(0.5) == IdealParallelCurve(0.5))
-    // return the kind of curve in the right and left arrays.
-    private int computeOffsetQuad(float[] pts, final int off,
-                                  float[] leftOff, float[] rightOff)
-    {
-        final float x1 = pts[off + 0], y1 = pts[off + 1];
-        final float x2 = pts[off + 2], y2 = pts[off + 3];
-        final float x3 = pts[off + 4], y3 = pts[off + 5];
-
-        float dx3 = x3 - x2;
-        float dy3 = y3 - y2;
-        float dx1 = x2 - x1;
-        float dy1 = y2 - y1;
-
-        // if p1=p2 or p3=p4 it means that the derivative at the endpoint
-        // vanishes, which creates problems with computeOffset. Usually
-        // this happens when this stroker object is trying to winden
-        // a curve with a cusp. What happens is that curveTo splits
-        // the input curve at the cusp, and passes it to this function.
-        // because of inaccuracies in the splitting, we consider points
-        // equal if they're very close to each other.
-
-        // if p1 == p2 && p3 == p4: draw line from p1->p4, unless p1 == p4,
-        // in which case ignore.
-        final boolean p1eqp2 = within(x1,y1,x2,y2, 6 * Math.ulp(y2));
-        final boolean p2eqp3 = within(x2,y2,x3,y3, 6 * Math.ulp(y3));
-        if (p1eqp2 || p2eqp3) {
-            getLineOffsets(x1, y1, x3, y3, leftOff, rightOff);
-            return 4;
-        }
-
-        // if p2-p1 and p4-p3 are parallel, that must mean this curve is a line
-        float dotsq = (dx1 * dx3 + dy1 * dy3);
-        dotsq = dotsq * dotsq;
-        float l1sq = dx1 * dx1 + dy1 * dy1, l3sq = dx3 * dx3 + dy3 * dy3;
-        if (Helpers.within(dotsq, l1sq * l3sq, 4 * Math.ulp(dotsq))) {
-            getLineOffsets(x1, y1, x3, y3, leftOff, rightOff);
-            return 4;
-        }
-
-        // this computes the offsets at t=0, 0.5, 1, using the property that
-        // for any bezier curve the vectors p2-p1 and p4-p3 are parallel to
-        // the (dx/dt, dy/dt) vectors at the endpoints.
-        computeOffset(dx1, dy1, lineWidth2, offset[0]);
-        computeOffset(dx3, dy3, lineWidth2, offset[1]);
-        float x1p = x1 + offset[0][0]; // start
-        float y1p = y1 + offset[0][1]; // point
-        float x3p = x3 + offset[1][0]; // end
-        float y3p = y3 + offset[1][1]; // point
-
-        safecomputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, leftOff, 2);
-        leftOff[0] = x1p; leftOff[1] = y1p;
-        leftOff[4] = x3p; leftOff[5] = y3p;
-        x1p = x1 - offset[0][0]; y1p = y1 - offset[0][1];
-        x3p = x3 - offset[1][0]; y3p = y3 - offset[1][1];
-        safecomputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, rightOff, 2);
-        rightOff[0] = x1p; rightOff[1] = y1p;
-        rightOff[4] = x3p; rightOff[5] = y3p;
-        return 6;
-    }
-
-    // This is where the curve to be processed is put. We give it
-    // enough room to store 2 curves: one for the current subdivision, the
-    // other for the rest of the curve.
-    private float[] middle = new float[MAX_N_CURVES*8];
-    private float[] lp = new float[8];
-    private float[] rp = new float[8];
-    private static final int MAX_N_CURVES = 11;
-    private float[] subdivTs = new float[MAX_N_CURVES - 1];
-
-    // If this class is compiled with ecj, then Hotspot crashes when OSR
-    // compiling this function. See bugs 7004570 and 6675699
-    // TODO: until those are fixed, we should work around that by
-    // manually inlining this into curveTo and quadTo.
-/******************************* WORKAROUND **********************************
-    private void somethingTo(final int type) {
-        // need these so we can update the state at the end of this method
-        final float xf = middle[type-2], yf = middle[type-1];
-        float dxs = middle[2] - middle[0];
-        float dys = middle[3] - middle[1];
-        float dxf = middle[type - 2] - middle[type - 4];
-        float dyf = middle[type - 1] - middle[type - 3];
-        switch(type) {
-        case 6:
-            if ((dxs == 0f && dys == 0f) ||
-                (dxf == 0f && dyf == 0f)) {
-               dxs = dxf = middle[4] - middle[0];
-               dys = dyf = middle[5] - middle[1];
-            }
-            break;
-        case 8:
-            boolean p1eqp2 = (dxs == 0f && dys == 0f);
-            boolean p3eqp4 = (dxf == 0f && dyf == 0f);
-            if (p1eqp2) {
-                dxs = middle[4] - middle[0];
-                dys = middle[5] - middle[1];
-                if (dxs == 0f && dys == 0f) {
-                    dxs = middle[6] - middle[0];
-                    dys = middle[7] - middle[1];
-                }
-            }
-            if (p3eqp4) {
-                dxf = middle[6] - middle[2];
-                dyf = middle[7] - middle[3];
-                if (dxf == 0f && dyf == 0f) {
-                    dxf = middle[6] - middle[0];
-                    dyf = middle[7] - middle[1];
-                }
-            }
-        }
-        if (dxs == 0f && dys == 0f) {
-            // this happens iff the "curve" is just a point
-            lineTo(middle[0], middle[1]);
-            return;
-        }
-        // if these vectors are too small, normalize them, to avoid future
-        // precision problems.
-        if (Math.abs(dxs) < 0.1f && Math.abs(dys) < 0.1f) {
-            float len = (float)Math.sqrt(dxs*dxs + dys*dys);
-            dxs /= len;
-            dys /= len;
-        }
-        if (Math.abs(dxf) < 0.1f && Math.abs(dyf) < 0.1f) {
-            float len = (float)Math.sqrt(dxf*dxf + dyf*dyf);
-            dxf /= len;
-            dyf /= len;
-        }
-
-        computeOffset(dxs, dys, lineWidth2, offset[0]);
-        final float mx = offset[0][0];
-        final float my = offset[0][1];
-        drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, mx, my);
-
-        int nSplits = findSubdivPoints(middle, subdivTs, type, lineWidth2);
-
-        int kind = 0;
-        Iterator<Integer> it = Curve.breakPtsAtTs(middle, type, subdivTs, nSplits);
-        while(it.hasNext()) {
-            int curCurveOff = it.next();
-
-            kind = 0;
-            switch (type) {
-            case 8:
-                kind = computeOffsetCubic(middle, curCurveOff, lp, rp);
-                break;
-            case 6:
-                kind = computeOffsetQuad(middle, curCurveOff, lp, rp);
-                break;
-            }
-            if (kind != 0) {
-                emitLineTo(lp[0], lp[1]);
-                switch(kind) {
-                case 8:
-                    emitCurveTo(lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], lp[6], lp[7], false);
-                    emitCurveTo(rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], rp[6], rp[7], true);
-                    break;
-                case 6:
-                    emitQuadTo(lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], false);
-                    emitQuadTo(rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], true);
-                    break;
-                case 4:
-                    emitLineTo(lp[2], lp[3]);
-                    emitLineTo(rp[0], rp[1], true);
-                    break;
-                }
-                emitLineTo(rp[kind - 2], rp[kind - 1], true);
-            }
-        }
-
-        this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
-        this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
-        this.cdx = dxf;
-        this.cdy = dyf;
-        this.cx0 = xf;
-        this.cy0 = yf;
-        this.prev = DRAWING_OP_TO;
-    }
-****************************** END WORKAROUND *******************************/
-
-    // finds values of t where the curve in pts should be subdivided in order
-    // to get good offset curves a distance of w away from the middle curve.
-    // Stores the points in ts, and returns how many of them there were.
-    private static Curve c = new Curve();
-    private static int findSubdivPoints(float[] pts, float[] ts,
-                                        final int type, final float w)
-    {
-        final float x12 = pts[2] - pts[0];
-        final float y12 = pts[3] - pts[1];
-        // if the curve is already parallel to either axis we gain nothing
-        // from rotating it.
-        if (y12 != 0f && x12 != 0f) {
-            // we rotate it so that the first vector in the control polygon is
-            // parallel to the x-axis. This will ensure that rotated quarter
-            // circles won't be subdivided.
-            final float hypot = (float)Math.sqrt(x12 * x12 + y12 * y12);
-            final float cos = x12 / hypot;
-            final float sin = y12 / hypot;
-            final float x1 = cos * pts[0] + sin * pts[1];
-            final float y1 = cos * pts[1] - sin * pts[0];
-            final float x2 = cos * pts[2] + sin * pts[3];
-            final float y2 = cos * pts[3] - sin * pts[2];
-            final float x3 = cos * pts[4] + sin * pts[5];
-            final float y3 = cos * pts[5] - sin * pts[4];
-            switch(type) {
-            case 8:
-                final float x4 = cos * pts[6] + sin * pts[7];
-                final float y4 = cos * pts[7] - sin * pts[6];
-                c.set(x1, y1, x2, y2, x3, y3, x4, y4);
-                break;
-            case 6:
-                c.set(x1, y1, x2, y2, x3, y3);
-                break;
-            }
-        } else {
-            c.set(pts, type);
-        }
-
-        int ret = 0;
-        // we subdivide at values of t such that the remaining rotated
-        // curves are monotonic in x and y.
-        ret += c.dxRoots(ts, ret);
-        ret += c.dyRoots(ts, ret);
-        // subdivide at inflection points.
-        if (type == 8) {
-            // quadratic curves can't have inflection points
-            ret += c.infPoints(ts, ret);
-        }
-
-        // now we must subdivide at points where one of the offset curves will have
-        // a cusp. This happens at ts where the radius of curvature is equal to w.
-        ret += c.rootsOfROCMinusW(ts, ret, w, 0.0001f);
-
-        ret = Helpers.filterOutNotInAB(ts, 0, ret, 0.0001f, 0.9999f);
-        Helpers.isort(ts, 0, ret);
-        return ret;
-    }
-
-    @Override public void curveTo(float x1, float y1,
-                                  float x2, float y2,
-                                  float x3, float y3)
-    {
-        middle[0] = cx0; middle[1] = cy0;
-        middle[2] = x1;  middle[3] = y1;
-        middle[4] = x2;  middle[5] = y2;
-        middle[6] = x3;  middle[7] = y3;
-
-        // inlined version of somethingTo(8);
-        // See the TODO on somethingTo
-        // (JDK-6675699)
-
-        // need these so we can update the state at the end of this method
-        final float xf = middle[6], yf = middle[7];
-        float dxs = middle[2] - middle[0];
-        float dys = middle[3] - middle[1];
-        float dxf = middle[6] - middle[4];
-        float dyf = middle[7] - middle[5];
-
-        boolean p1eqp2 = (dxs == 0f && dys == 0f);
-        boolean p3eqp4 = (dxf == 0f && dyf == 0f);
-        if (p1eqp2) {
-            dxs = middle[4] - middle[0];
-            dys = middle[5] - middle[1];
-            if (dxs == 0f && dys == 0f) {
-                dxs = middle[6] - middle[0];
-                dys = middle[7] - middle[1];
-            }
-        }
-        if (p3eqp4) {
-            dxf = middle[6] - middle[2];
-            dyf = middle[7] - middle[3];
-            if (dxf == 0f && dyf == 0f) {
-                dxf = middle[6] - middle[0];
-                dyf = middle[7] - middle[1];
-            }
-        }
-        if (dxs == 0f && dys == 0f) {
-            // this happens iff the "curve" is just a point
-            lineTo(middle[0], middle[1]);
-            return;
-        }
-
-        // if these vectors are too small, normalize them, to avoid future
-        // precision problems.
-        if (Math.abs(dxs) < 0.1f && Math.abs(dys) < 0.1f) {
-            float len = (float)Math.sqrt(dxs*dxs + dys*dys);
-            dxs /= len;
-            dys /= len;
-        }
-        if (Math.abs(dxf) < 0.1f && Math.abs(dyf) < 0.1f) {
-            float len = (float)Math.sqrt(dxf*dxf + dyf*dyf);
-            dxf /= len;
-            dyf /= len;
-        }
-
-        computeOffset(dxs, dys, lineWidth2, offset[0]);
-        final float mx = offset[0][0];
-        final float my = offset[0][1];
-        drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, mx, my);
-
-        int nSplits = findSubdivPoints(middle, subdivTs, 8, lineWidth2);
-        float prevT = 0f;
-        for (int i = 0; i < nSplits; i++) {
-            float t = subdivTs[i];
-            Helpers.subdivideCubicAt((t - prevT) / (1 - prevT),
-                                     middle, i*6,
-                                     middle, i*6,
-                                     middle, i*6+6);
-            prevT = t;
-        }
-
-        int kind = 0;
-        for (int i = 0; i <= nSplits; i++) {
-            kind = computeOffsetCubic(middle, i*6, lp, rp);
-            if (kind != 0) {
-                emitLineTo(lp[0], lp[1]);
-                switch(kind) {
-                case 8:
-                    emitCurveTo(lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], lp[6], lp[7], false);
-                    emitCurveTo(rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], rp[6], rp[7], true);
-                    break;
-                case 4:
-                    emitLineTo(lp[2], lp[3]);
-                    emitLineTo(rp[0], rp[1], true);
-                    break;
-                }
-                emitLineTo(rp[kind - 2], rp[kind - 1], true);
-            }
-        }
-
-        this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
-        this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
-        this.cdx = dxf;
-        this.cdy = dyf;
-        this.cx0 = xf;
-        this.cy0 = yf;
-        this.prev = DRAWING_OP_TO;
-    }
-
-    @Override public void quadTo(float x1, float y1, float x2, float y2) {
-        middle[0] = cx0; middle[1] = cy0;
-        middle[2] = x1;  middle[3] = y1;
-        middle[4] = x2;  middle[5] = y2;
-
-        // inlined version of somethingTo(8);
-        // See the TODO on somethingTo
-        // (JDK-6675699)
-
-        // need these so we can update the state at the end of this method
-        final float xf = middle[4], yf = middle[5];
-        float dxs = middle[2] - middle[0];
-        float dys = middle[3] - middle[1];
-        float dxf = middle[4] - middle[2];
-        float dyf = middle[5] - middle[3];
-        if ((dxs == 0f && dys == 0f) || (dxf == 0f && dyf == 0f)) {
-            dxs = dxf = middle[4] - middle[0];
-            dys = dyf = middle[5] - middle[1];
-        }
-        if (dxs == 0f && dys == 0f) {
-            // this happens iff the "curve" is just a point
-            lineTo(middle[0], middle[1]);
-            return;
-        }
-        // if these vectors are too small, normalize them, to avoid future
-        // precision problems.
-        if (Math.abs(dxs) < 0.1f && Math.abs(dys) < 0.1f) {
-            float len = (float)Math.sqrt(dxs*dxs + dys*dys);
-            dxs /= len;
-            dys /= len;
-        }
-        if (Math.abs(dxf) < 0.1f && Math.abs(dyf) < 0.1f) {
-            float len = (float)Math.sqrt(dxf*dxf + dyf*dyf);
-            dxf /= len;
-            dyf /= len;
-        }
-
-        computeOffset(dxs, dys, lineWidth2, offset[0]);
-        final float mx = offset[0][0];
-        final float my = offset[0][1];
-        drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, mx, my);
-
-        int nSplits = findSubdivPoints(middle, subdivTs, 6, lineWidth2);
-        float prevt = 0f;
-        for (int i = 0; i < nSplits; i++) {
-            float t = subdivTs[i];
-            Helpers.subdivideQuadAt((t - prevt) / (1 - prevt),
-                                    middle, i*4,
-                                    middle, i*4,
-                                    middle, i*4+4);
-            prevt = t;
-        }
-
-        int kind = 0;
-        for (int i = 0; i <= nSplits; i++) {
-            kind = computeOffsetQuad(middle, i*4, lp, rp);
-            if (kind != 0) {
-                emitLineTo(lp[0], lp[1]);
-                switch(kind) {
-                case 6:
-                    emitQuadTo(lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], false);
-                    emitQuadTo(rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], true);
-                    break;
-                case 4:
-                    emitLineTo(lp[2], lp[3]);
-                    emitLineTo(rp[0], rp[1], true);
-                    break;
-                }
-                emitLineTo(rp[kind - 2], rp[kind - 1], true);
-            }
-        }
-
-        this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
-        this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
-        this.cdx = dxf;
-        this.cdy = dyf;
-        this.cx0 = xf;
-        this.cy0 = yf;
-        this.prev = DRAWING_OP_TO;
-    }
-
-//    @Override public long getNativeConsumer() {
-//        throw new InternalError("Stroker doesn't use a native consumer");
-//    }
-
-    // a stack of polynomial curves where each curve shares endpoints with
-    // adjacent ones.
-    private static final class PolyStack {
-        float[] curves;
-        int end;
-        int[] curveTypes;
-        int numCurves;
-
-        private static final int INIT_SIZE = 50;
-
-        PolyStack() {
-            curves = new float[8 * INIT_SIZE];
-            curveTypes = new int[INIT_SIZE];
-            end = 0;
-            numCurves = 0;
-        }
-
-        public boolean isEmpty() {
-            return numCurves == 0;
-        }
-
-        private void ensureSpace(int n) {
-            if (end + n >= curves.length) {
-                int newSize = (end + n) * 2;
-                curves = Arrays.copyOf(curves, newSize);
-            }
-            if (numCurves >= curveTypes.length) {
-                int newSize = numCurves * 2;
-                curveTypes = Arrays.copyOf(curveTypes, newSize);
-            }
-        }
-
-        public void pushCubic(float x0, float y0,
-                              float x1, float y1,
-                              float x2, float y2)
-        {
-            ensureSpace(6);
-            curveTypes[numCurves++] = 8;
-            // assert(x0 == lastX && y0 == lastY)
-
-            // we reverse the coordinate order to make popping easier
-            curves[end++] = x2;    curves[end++] = y2;
-            curves[end++] = x1;    curves[end++] = y1;
-            curves[end++] = x0;    curves[end++] = y0;
-        }
-
-        public void pushQuad(float x0, float y0,
-                             float x1, float y1)
-        {
-            ensureSpace(4);
-            curveTypes[numCurves++] = 6;
-            // assert(x0 == lastX && y0 == lastY)
-            curves[end++] = x1;    curves[end++] = y1;
-            curves[end++] = x0;    curves[end++] = y0;
-        }
-
-        public void pushLine(float x, float y) {
-            ensureSpace(2);
-            curveTypes[numCurves++] = 4;
-            // assert(x0 == lastX && y0 == lastY)
-            curves[end++] = x;    curves[end++] = y;
-        }
-
-        @SuppressWarnings("unused")
-        public int pop(float[] pts) {
-            int ret = curveTypes[numCurves - 1];
-            numCurves--;
-            end -= (ret - 2);
-            System.arraycopy(curves, end, pts, 0, ret - 2);
-            return ret;
-        }
-
-        public void pop(PathConsumer2D io) {
-            numCurves--;
-            int type = curveTypes[numCurves];
-            end -= (type - 2);
-            switch(type) {
-            case 8:
-                io.curveTo(curves[end+0], curves[end+1],
-                           curves[end+2], curves[end+3],
-                           curves[end+4], curves[end+5]);
-                break;
-            case 6:
-                io.quadTo(curves[end+0], curves[end+1],
-                           curves[end+2], curves[end+3]);
-                 break;
-            case 4:
-                io.lineTo(curves[end], curves[end+1]);
-            }
-        }
-
-        @Override
-        public String toString() {
-            String ret = "";
-            int nc = numCurves;
-            int last = this.end;
-            while (nc > 0) {
-                nc--;
-                int type = curveTypes[numCurves];
-                last -= (type - 2);
-                switch(type) {
-                case 8:
-                    ret += "cubic: ";
-                    break;
-                case 6:
-                    ret += "quad: ";
-                    break;
-                case 4:
-                    ret += "line: ";
-                    break;
-                }
-                ret += Arrays.toString(Arrays.copyOfRange(curves, last, last+type-2)) + "\n";
-            }
-            return ret;
-        }
-    }
-}
diff a/modules/javafx.graphics/src/main/java/com/sun/openpisces/TransformingPathConsumer2D.java b/modules/javafx.graphics/src/main/java/com/sun/openpisces/TransformingPathConsumer2D.java
--- a/modules/javafx.graphics/src/main/java/com/sun/openpisces/TransformingPathConsumer2D.java
+++ /dev/null
@@ -1,496 +0,0 @@
-/*
- * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.openpisces;
-
-import com.sun.javafx.geom.PathConsumer2D;
-import com.sun.javafx.geom.transform.BaseTransform;
-
-public abstract class TransformingPathConsumer2D implements PathConsumer2D {
-    protected PathConsumer2D out;
-
-    public TransformingPathConsumer2D(PathConsumer2D out) {
-        this.out = out;
-    }
-
-    public void setConsumer(PathConsumer2D out) {
-        this.out = out;
-    }
-/*
-    public static PathConsumer2D
-        transformConsumer(PathConsumer2D out,
-                          AffineTransform at)
-    {
-        if (at == null) {
-            return out;
-        }
-        float Mxx = (float) at.getScaleX();
-        float Mxy = (float) at.getShearX();
-        float Mxt = (float) at.getTranslateX();
-        float Myx = (float) at.getShearY();
-        float Myy = (float) at.getScaleY();
-        float Myt = (float) at.getTranslateY();
-        if (Mxy == 0f && Myx == 0f) {
-            if (Mxx == 1f && Myy == 1f) {
-                if (Mxt == 0f && Myt == 0f) {
-                    return out;
-                } else {
-                    return new TranslateFilter(out, Mxt, Myt);
-                }
-            } else {
-                if (Mxt == 0f && Myt == 0f) {
-                    return new DeltaScaleFilter(out, Mxx, Myy);
-                } else {
-                    return new ScaleTranslateFilter(out, Mxx, Myy, Mxt, Myt);
-                }
-            }
-        } else if (Mxt == 0f && Myt == 0f) {
-            return new DeltaTransformFilter(out, Mxx, Mxy, Myx, Myy);
-        } else {
-            return new TransformFilter(out, Mxx, Mxy, Mxt, Myx, Myy, Myt);
-        }
-    }
-
-    public static PathConsumer2D
-        deltaTransformConsumer(PathConsumer2D out,
-                               AffineTransform at)
-    {
-        if (at == null) {
-            return out;
-        }
-        float Mxx = (float) at.getScaleX();
-        float Mxy = (float) at.getShearX();
-        float Myx = (float) at.getShearY();
-        float Myy = (float) at.getScaleY();
-        if (Mxy == 0f && Myx == 0f) {
-            if (Mxx == 1f && Myy == 1f) {
-                return out;
-            } else {
-                return new DeltaScaleFilter(out, Mxx, Myy);
-            }
-        } else {
-            return new DeltaTransformFilter(out, Mxx, Mxy, Myx, Myy);
-        }
-    }
-
-    public static PathConsumer2D
-        inverseDeltaTransformConsumer(PathConsumer2D out,
-                                      AffineTransform at)
-    {
-        if (at == null) {
-            return out;
-        }
-        float Mxx = (float) at.getScaleX();
-        float Mxy = (float) at.getShearX();
-        float Myx = (float) at.getShearY();
-        float Myy = (float) at.getScaleY();
-        if (Mxy == 0f && Myx == 0f) {
-            if (Mxx == 1f && Myy == 1f) {
-                return out;
-            } else {
-                return new DeltaScaleFilter(out, 1.0f/Mxx, 1.0f/Myy);
-            }
-        } else {
-            float det = Mxx * Myy - Mxy * Myx;
-            return new DeltaTransformFilter(out,
-                                            Myy / det,
-                                            -Mxy / det,
-                                            -Myx / det,
-                                            Mxx / det);
-        }
-    }
-*/
-
-    public static final class FilterSet {
-        private TranslateFilter translater;
-        private DeltaScaleFilter deltascaler;
-        private ScaleTranslateFilter scaletranslater;
-        private DeltaTransformFilter deltatransformer;
-        private TransformFilter transformer;
-
-        public FilterSet() {
-        }
-
-        public PathConsumer2D getConsumer(PathConsumer2D out,
-                                          BaseTransform tx)
-        {
-            if (tx == null) {
-                return out;
-            }
-            float Mxx = (float) tx.getMxx();
-            float Mxy = (float) tx.getMxy();
-            float Mxt = (float) tx.getMxt();
-            float Myx = (float) tx.getMyx();
-            float Myy = (float) tx.getMyy();
-            float Myt = (float) tx.getMyt();
-            if (Mxy == 0f && Myx == 0f) {
-                if (Mxx == 1f && Myy == 1f) {
-                    if (Mxt == 0f && Myt == 0f) {
-                        return out;
-                    } else {
-                        if (translater == null) {
-                            translater = new TranslateFilter(out, Mxt, Myt);
-                        } else {
-                            translater.set(Mxt, Myt);
-                        }
-                        return translater;
-                    }
-                } else {
-                    if (Mxt == 0f && Myt == 0f) {
-                        if (deltascaler == null) {
-                            deltascaler = new DeltaScaleFilter(out, Mxx, Myy);
-                        } else {
-                            deltascaler.set(Mxx, Myy);
-                        }
-                        return deltascaler;
-                    } else {
-                        if (scaletranslater == null) {
-                            scaletranslater =
-                                new ScaleTranslateFilter(out, Mxx, Myy, Mxt, Myt);
-                        } else {
-                            scaletranslater.set(Mxx, Myy, Mxt, Myt);
-                        }
-                        return scaletranslater;
-                    }
-                }
-            } else if (Mxt == 0f && Myt == 0f) {
-                if (deltatransformer == null) {
-                    deltatransformer =
-                        new DeltaTransformFilter(out, Mxx, Mxy, Myx, Myy);
-                } else {
-                    deltatransformer.set(Mxx, Mxy, Myx, Myy);
-                }
-                return deltatransformer;
-            } else {
-                if (transformer == null) {
-                    transformer =
-                        new TransformFilter(out, Mxx, Mxy, Mxt, Myx, Myy, Myt);
-                } else {
-                    transformer.set(Mxx, Mxy, Mxt, Myx, Myy, Myt);
-                }
-                return transformer;
-            }
-        }
-    }
-
-    static final class TranslateFilter extends TransformingPathConsumer2D {
-        private float tx;
-        private float ty;
-
-        TranslateFilter(PathConsumer2D out,
-                        float tx, float ty)
-        {
-            super(out);
-            set(tx, ty);
-        }
-
-        public void set(float tx, float ty) {
-            this.tx = tx;
-            this.ty = ty;
-        }
-
-        public void moveTo(float x0, float y0) {
-            out.moveTo(x0 + tx, y0 + ty);
-        }
-
-        public void lineTo(float x1, float y1) {
-            out.lineTo(x1 + tx, y1 + ty);
-        }
-
-        public void quadTo(float x1, float y1,
-                           float x2, float y2)
-        {
-            out.quadTo(x1 + tx, y1 + ty,
-                       x2 + tx, y2 + ty);
-        }
-
-        public void curveTo(float x1, float y1,
-                            float x2, float y2,
-                            float x3, float y3)
-        {
-            out.curveTo(x1 + tx, y1 + ty,
-                        x2 + tx, y2 + ty,
-                        x3 + tx, y3 + ty);
-        }
-
-        public void closePath() {
-            out.closePath();
-        }
-
-        public void pathDone() {
-            out.pathDone();
-        }
-
-        public long getNativeConsumer() {
-            return 0;
-        }
-    }
-
-    static final class ScaleTranslateFilter extends TransformingPathConsumer2D {
-        private float sx;
-        private float sy;
-        private float tx;
-        private float ty;
-
-        ScaleTranslateFilter(PathConsumer2D out,
-                    float sx, float sy, float tx, float ty)
-        {
-            super(out);
-            set(sx, sy, tx, ty);
-        }
-
-        public void set(float sx, float sy, float tx, float ty) {
-            this.sx = sx;
-            this.sy = sy;
-            this.tx = tx;
-            this.ty = ty;
-        }
-
-        public void moveTo(float x0, float y0) {
-            out.moveTo(x0 * sx + tx, y0 * sy + ty);
-        }
-
-        public void lineTo(float x1, float y1) {
-            out.lineTo(x1 * sx + tx, y1 * sy + ty);
-        }
-
-        public void quadTo(float x1, float y1,
-                           float x2, float y2)
-        {
-            out.quadTo(x1 * sx + tx, y1 * sy + ty,
-                       x2 * sx + tx, y2 * sy + ty);
-        }
-
-        public void curveTo(float x1, float y1,
-                            float x2, float y2,
-                            float x3, float y3)
-        {
-            out.curveTo(x1 * sx + tx, y1 * sy + ty,
-                        x2 * sx + tx, y2 * sy + ty,
-                        x3 * sx + tx, y3 * sy + ty);
-        }
-
-        public void closePath() {
-            out.closePath();
-        }
-
-        public void pathDone() {
-            out.pathDone();
-        }
-
-        public long getNativeConsumer() {
-            return 0;
-        }
-    }
-
-    static final class TransformFilter extends TransformingPathConsumer2D {
-        private float Mxx;
-        private float Mxy;
-        private float Mxt;
-        private float Myx;
-        private float Myy;
-        private float Myt;
-
-        TransformFilter(PathConsumer2D out,
-                        float Mxx, float Mxy, float Mxt,
-                        float Myx, float Myy, float Myt)
-        {
-            super(out);
-            set(Mxx, Mxy, Mxt, Myx, Myy, Myt);
-        }
-
-        public void set(float Mxx, float Mxy, float Mxt,
-                        float Myx, float Myy, float Myt)
-        {
-            this.Mxx = Mxx;
-            this.Mxy = Mxy;
-            this.Mxt = Mxt;
-            this.Myx = Myx;
-            this.Myy = Myy;
-            this.Myt = Myt;
-        }
-
-        public void moveTo(float x0, float y0) {
-            out.moveTo(x0 * Mxx + y0 * Mxy + Mxt,
-                       x0 * Myx + y0 * Myy + Myt);
-        }
-
-        public void lineTo(float x1, float y1) {
-            out.lineTo(x1 * Mxx + y1 * Mxy + Mxt,
-                       x1 * Myx + y1 * Myy + Myt);
-        }
-
-        public void quadTo(float x1, float y1,
-                           float x2, float y2)
-        {
-            out.quadTo(x1 * Mxx + y1 * Mxy + Mxt,
-                       x1 * Myx + y1 * Myy + Myt,
-                       x2 * Mxx + y2 * Mxy + Mxt,
-                       x2 * Myx + y2 * Myy + Myt);
-        }
-
-        public void curveTo(float x1, float y1,
-                            float x2, float y2,
-                            float x3, float y3)
-        {
-            out.curveTo(x1 * Mxx + y1 * Mxy + Mxt,
-                        x1 * Myx + y1 * Myy + Myt,
-                        x2 * Mxx + y2 * Mxy + Mxt,
-                        x2 * Myx + y2 * Myy + Myt,
-                        x3 * Mxx + y3 * Mxy + Mxt,
-                        x3 * Myx + y3 * Myy + Myt);
-        }
-
-        public void closePath() {
-            out.closePath();
-        }
-
-        public void pathDone() {
-            out.pathDone();
-        }
-
-        public long getNativeConsumer() {
-            return 0;
-        }
-    }
-
-    static final class DeltaScaleFilter extends TransformingPathConsumer2D {
-        private float sx;
-        private float sy;
-
-        public DeltaScaleFilter(PathConsumer2D out, float Mxx, float Myy) {
-            super(out);
-            set(Mxx, Myy);
-        }
-
-        public void set(float Mxx, float Myy) {
-            sx = Mxx;
-            sy = Myy;
-        }
-
-        public void moveTo(float x0, float y0) {
-            out.moveTo(x0 * sx, y0 * sy);
-        }
-
-        public void lineTo(float x1, float y1) {
-            out.lineTo(x1 * sx, y1 * sy);
-        }
-
-        public void quadTo(float x1, float y1,
-                           float x2, float y2)
-        {
-            out.quadTo(x1 * sx, y1 * sy,
-                       x2 * sx, y2 * sy);
-        }
-
-        public void curveTo(float x1, float y1,
-                            float x2, float y2,
-                            float x3, float y3)
-        {
-            out.curveTo(x1 * sx, y1 * sy,
-                        x2 * sx, y2 * sy,
-                        x3 * sx, y3 * sy);
-        }
-
-        public void closePath() {
-            out.closePath();
-        }
-
-        public void pathDone() {
-            out.pathDone();
-        }
-
-        public long getNativeConsumer() {
-            return 0;
-        }
-    }
-
-    static final class DeltaTransformFilter extends TransformingPathConsumer2D {
-        private float Mxx;
-        private float Mxy;
-        private float Myx;
-        private float Myy;
-
-        DeltaTransformFilter(PathConsumer2D out,
-                             float Mxx, float Mxy,
-                             float Myx, float Myy)
-        {
-            super(out);
-            set(Mxx, Mxy, Myx, Myy);
-        }
-
-        public void set(float Mxx, float Mxy,
-                        float Myx, float Myy)
-        {
-            this.Mxx = Mxx;
-            this.Mxy = Mxy;
-            this.Myx = Myx;
-            this.Myy = Myy;
-        }
-
-        public void moveTo(float x0, float y0) {
-            out.moveTo(x0 * Mxx + y0 * Mxy,
-                       x0 * Myx + y0 * Myy);
-        }
-
-        public void lineTo(float x1, float y1) {
-            out.lineTo(x1 * Mxx + y1 * Mxy,
-                       x1 * Myx + y1 * Myy);
-        }
-
-        public void quadTo(float x1, float y1,
-                           float x2, float y2)
-        {
-            out.quadTo(x1 * Mxx + y1 * Mxy,
-                       x1 * Myx + y1 * Myy,
-                       x2 * Mxx + y2 * Mxy,
-                       x2 * Myx + y2 * Myy);
-        }
-
-        public void curveTo(float x1, float y1,
-                            float x2, float y2,
-                            float x3, float y3)
-        {
-            out.curveTo(x1 * Mxx + y1 * Mxy,
-                        x1 * Myx + y1 * Myy,
-                        x2 * Mxx + y2 * Mxy,
-                        x2 * Myx + y2 * Myy,
-                        x3 * Mxx + y3 * Mxy,
-                        x3 * Myx + y3 * Myy);
-        }
-
-        public void closePath() {
-            out.closePath();
-        }
-
-        public void pathDone() {
-            out.pathDone();
-        }
-
-        public long getNativeConsumer() {
-            return 0;
-        }
-    }
-}
diff a/modules/javafx.graphics/src/main/java/com/sun/prism/impl/PrismSettings.java b/modules/javafx.graphics/src/main/java/com/sun/prism/impl/PrismSettings.java
--- a/modules/javafx.graphics/src/main/java/com/sun/prism/impl/PrismSettings.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/prism/impl/PrismSettings.java
@@ -85,12 +85,10 @@
     public static final boolean forceUploadingPainter;
     public static final boolean forceAlphaTestShader;
     public static final boolean forceNonAntialiasedShape;
 
     public static enum RasterizerType {
-        JavaPisces("Java-based Pisces Rasterizer"),
-        NativePisces("Native-based Pisces Rasterizer"),
         FloatMarlin("Float Precision Marlin Rasterizer"),
         DoubleMarlin("Double Precision Marlin Rasterizer");
 
         private String publicName;
         private RasterizerType(String publicname) {
@@ -229,21 +227,10 @@
         RasterizerType rSpec = null;
         String rOrder = systemProperties.getProperty("prism.rasterizerorder");
         if (rOrder != null) {
             for (String s : split(rOrder.toLowerCase(), ",")) {
                 switch (s) {
-                    case "pisces":
-                        rSpec = PlatformUtil.isEmbedded() || !PlatformUtil.isLinux()
-                                ? RasterizerType.NativePisces
-                                : RasterizerType.JavaPisces;
-                        break;
-                    case "nativepisces":
-                        rSpec = RasterizerType.NativePisces;
-                        break;
-                    case "javapisces":
-                        rSpec = RasterizerType.JavaPisces;
-                        break;
                     case "marlin":
                     case "doublemarlin":
                         rSpec = RasterizerType.DoubleMarlin;
                         break;
                     case "floatmarlin":
@@ -254,29 +241,15 @@
                 }
                 break;
             }
         }
         if (rSpec == null) {
-            boolean useMarlinRasterizer, useMarlinRasterizerDP;
-            useMarlinRasterizer   = getBoolean(systemProperties, "prism.marlinrasterizer", true);
+            boolean useMarlinRasterizerDP;
             useMarlinRasterizerDP = getBoolean(systemProperties, "prism.marlin.double", true);
-            if (useMarlinRasterizer) {
-                rSpec = useMarlinRasterizerDP
-                        ? RasterizerType.DoubleMarlin
-                        : RasterizerType.FloatMarlin;
-            } else {
-                boolean doNativePisces;
-                String npprop = systemProperties.getProperty("prism.nativepisces");
-                if (npprop == null) {
-                    doNativePisces = PlatformUtil.isEmbedded() || !PlatformUtil.isLinux();
-                } else {
-                    doNativePisces = Boolean.parseBoolean(npprop);
-                }
-                rSpec = doNativePisces
-                        ? RasterizerType.NativePisces
-                        : RasterizerType.JavaPisces;
-            }
+            rSpec = useMarlinRasterizerDP
+                    ? RasterizerType.DoubleMarlin
+                    : RasterizerType.FloatMarlin;
         }
         rasterizerSpec = rSpec;
 
         String primtex = systemProperties.getProperty("prism.primtextures");
         if (primtex == null) {
diff a/modules/javafx.graphics/src/main/java/com/sun/prism/impl/shape/NativePiscesRasterizer.java b/modules/javafx.graphics/src/main/java/com/sun/prism/impl/shape/NativePiscesRasterizer.java
--- a/modules/javafx.graphics/src/main/java/com/sun/prism/impl/shape/NativePiscesRasterizer.java
+++ /dev/null
@@ -1,192 +0,0 @@
-/*
- * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.prism.impl.shape;
-
-import com.sun.glass.utils.NativeLibLoader;
-import com.sun.javafx.geom.Path2D;
-import com.sun.javafx.geom.PathIterator;
-import com.sun.javafx.geom.RectBounds;
-import com.sun.javafx.geom.Shape;
-import com.sun.javafx.geom.transform.BaseTransform;
-import com.sun.javafx.util.Logging;
-import com.sun.prism.BasicStroke;
-import com.sun.prism.impl.PrismSettings;
-import java.nio.ByteBuffer;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-
-public class NativePiscesRasterizer implements ShapeRasterizer {
-    private static MaskData emptyData = MaskData.create(new byte[1], 0, 0, 1, 1);
-
-    private static final byte SEG_MOVETO  = PathIterator.SEG_MOVETO;
-    private static final byte SEG_LINETO  = PathIterator.SEG_LINETO;
-    private static final byte SEG_QUADTO  = PathIterator.SEG_QUADTO;
-    private static final byte SEG_CUBICTO = PathIterator.SEG_CUBICTO;
-    private static final byte SEG_CLOSE   = PathIterator.SEG_CLOSE;
-
-    private byte cachedMask[];
-    private ByteBuffer cachedBuffer;
-    private MaskData cachedData;
-    private int bounds[] = new int[4];
-    private boolean lastAntialiasedShape;
-    private boolean firstTimeAASetting = true;
-
-    native static void init(int subpixelLgPositionsX, int subpixelLgPositionsY);
-
-    native static void produceFillAlphas(float coords[], byte commands[], int nsegs, boolean nonzero,
-                                         double mxx, double mxy, double mxt,
-                                         double myx, double myy, double myt,
-                                         int bounds[], byte mask[]);
-    native static void produceStrokeAlphas(float coords[], byte commands[], int nsegs,
-                                           float lw, int cap, int join, float mlimit,
-                                           float dashes[], float dashoff,
-                                           double mxx, double mxy, double mxt,
-                                           double myx, double myy, double myt,
-                                           int bounds[], byte mask[]);
-
-    static {
-        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {
-            String libName = "prism_common";
-
-            if (PrismSettings.verbose) {
-                System.out.println("Loading Prism common native library ...");
-            }
-            NativeLibLoader.loadLibrary(libName);
-            if (PrismSettings.verbose) {
-                System.out.println("\tsucceeded.");
-            }
-            return null;
-        });
-    }
-
-    @Override
-    public MaskData getMaskData(Shape shape, BasicStroke stroke,
-                                RectBounds xformBounds, BaseTransform xform,
-                                boolean close, boolean antialiasedShape)
-    {
-
-        if (firstTimeAASetting || (lastAntialiasedShape != antialiasedShape)) {
-            int subpixelLgPositions = antialiasedShape ? 3 : 0;
-            NativePiscesRasterizer.init(subpixelLgPositions, subpixelLgPositions);
-            firstTimeAASetting = false;
-            lastAntialiasedShape = antialiasedShape;
-        }
-
-        if (stroke != null && stroke.getType() != BasicStroke.TYPE_CENTERED) {
-            // RT-27427
-            // TODO: Optimize the combinatorial strokes for simple
-            // shapes and/or teach the rasterizer to be able to
-            // do a "differential fill" between two shapes.
-            // Note that most simple shapes will use a more optimized path
-            // than this method for the INNER/OUTER strokes anyway.
-            shape = stroke.createStrokedShape(shape);
-            stroke = null;
-        }
-        if (xformBounds == null) {
-            if (stroke != null) {
-                // Note that all places that pass null for xformbounds also
-                // pass null for stroke so that the following is not typically
-                // executed, but just here as a safety net.
-                shape = stroke.createStrokedShape(shape);
-                stroke = null;
-            }
-
-            xformBounds = new RectBounds();
-            //TODO: Need to verify that this is a safe cast ... (RT-27427)
-            xformBounds = (RectBounds) xform.transform(shape.getBounds(), xformBounds);
-        }
-        bounds[0] = (int) Math.floor(xformBounds.getMinX());
-        bounds[1] = (int) Math.floor(xformBounds.getMinY());
-        bounds[2] = (int) Math.ceil(xformBounds.getMaxX());
-        bounds[3] = (int) Math.ceil(xformBounds.getMaxY());
-        if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {
-            return emptyData;
-        }
-        Path2D p2d = (shape instanceof Path2D) ? (Path2D) shape : new Path2D(shape);
-        double mxx, mxy, mxt, myx, myy, myt;
-        if (xform == null || xform.isIdentity()) {
-            mxx = myy = 1.0;
-            mxy = myx = 0.0;
-            mxt = myt = 0.0;
-        } else {
-            mxx = xform.getMxx();
-            mxy = xform.getMxy();
-            mxt = xform.getMxt();
-            myx = xform.getMyx();
-            myy = xform.getMyy();
-            myt = xform.getMyt();
-        }
-        int x = bounds[0];
-        int y = bounds[1];
-        int w = bounds[2] - x;
-        int h = bounds[3] - y;
-        if (w <= 0 || h <= 0) {
-            return emptyData;
-        }
-        if (cachedMask == null || w * h > cachedMask.length) {
-            cachedMask = null;
-            cachedBuffer = null;
-            cachedData = new MaskData();
-            int csize = (w * h + 0xfff) & (~0xfff);
-            cachedMask = new byte[csize];
-            cachedBuffer = ByteBuffer.wrap(cachedMask);
-        }
-        try {
-            if (stroke != null) {
-                produceStrokeAlphas(p2d.getFloatCoordsNoClone(),
-                                    p2d.getCommandsNoClone(),
-                                    p2d.getNumCommands(),
-                                    stroke.getLineWidth(), stroke.getEndCap(),
-                                    stroke.getLineJoin(), stroke.getMiterLimit(),
-                                    stroke.getDashArray(), stroke.getDashPhase(),
-                                    mxx, mxy, mxt, myx, myy, myt,
-                                    bounds, cachedMask);
-            } else {
-                produceFillAlphas(p2d.getFloatCoordsNoClone(),
-                                  p2d.getCommandsNoClone(),
-                                  p2d.getNumCommands(), p2d.getWindingRule() == Path2D.WIND_NON_ZERO,
-                                  mxx, mxy, mxt, myx, myy, myt,
-                                  bounds, cachedMask);
-            }
-        } catch (Throwable ex) {
-            if (PrismSettings.verbose) {
-                ex.printStackTrace();
-            }
-            Logging.getJavaFXLogger().warning("Cannot rasterize Shape: "
-                    + ex.toString());
-            return emptyData;
-        }
-        x = bounds[0];
-        y = bounds[1];
-        w = bounds[2] - x;
-        h = bounds[3] - y;
-        if (w <= 0 || h <= 0) {
-            return emptyData;
-        }
-        cachedData.update(cachedBuffer, x, y, w, h);
-        return cachedData;
-    }
-}
diff a/modules/javafx.graphics/src/main/java/com/sun/prism/impl/shape/OpenPiscesPrismUtils.java b/modules/javafx.graphics/src/main/java/com/sun/prism/impl/shape/OpenPiscesPrismUtils.java
--- a/modules/javafx.graphics/src/main/java/com/sun/prism/impl/shape/OpenPiscesPrismUtils.java
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
- * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.prism.impl.shape;
-
-
-import com.sun.javafx.geom.PathConsumer2D;
-import com.sun.javafx.geom.PathIterator;
-import com.sun.javafx.geom.Path2D;
-import com.sun.javafx.geom.Rectangle;
-import com.sun.javafx.geom.Shape;
-import com.sun.javafx.geom.transform.BaseTransform;
-import com.sun.openpisces.Dasher;
-import com.sun.openpisces.Renderer;
-import com.sun.openpisces.Stroker;
-import com.sun.openpisces.TransformingPathConsumer2D;
-import com.sun.prism.BasicStroke;
-
-public class OpenPiscesPrismUtils {
-    private static final Renderer savedAARenderer = new Renderer(3, 3);
-    private static final Renderer savedRenderer = new Renderer(0, 0);
-    private static final Stroker savedStroker = new Stroker(savedRenderer);
-    private static final Dasher savedDasher = new Dasher(savedStroker);
-
-    private static TransformingPathConsumer2D.FilterSet transformer =
-        new TransformingPathConsumer2D.FilterSet();
-
-    private static PathConsumer2D initRenderer(BasicStroke stroke,
-                                               BaseTransform tx,
-                                               Rectangle clip,
-                                               int pirule,
-                                               Renderer renderer)
-    {
-        int oprule = (stroke == null && pirule == PathIterator.WIND_EVEN_ODD) ?
-            Renderer.WIND_EVEN_ODD : Renderer.WIND_NON_ZERO;
-        renderer.reset(clip.x, clip.y, clip.width, clip.height, oprule);
-        PathConsumer2D ret = transformer.getConsumer(renderer, tx);
-        if (stroke != null) {
-            savedStroker.reset(stroke.getLineWidth(), stroke.getEndCap(),
-                               stroke.getLineJoin(), stroke.getMiterLimit());
-            savedStroker.setConsumer(ret);
-            ret = savedStroker;
-            float dashes[] = stroke.getDashArray();
-            if (dashes != null) {
-                savedDasher.reset(dashes, stroke.getDashPhase());
-                ret = savedDasher;
-            }
-        }
-        return ret;
-    }
-
-    public static void feedConsumer(PathIterator pi, PathConsumer2D pc) {
-        float[] coords = new float[6];
-        while (!pi.isDone()) {
-            int type = pi.currentSegment(coords);
-            switch (type) {
-                case PathIterator.SEG_MOVETO:
-                    pc.moveTo(coords[0], coords[1]);
-                    break;
-                case PathIterator.SEG_LINETO:
-                    pc.lineTo(coords[0], coords[1]);
-                    break;
-                case PathIterator.SEG_QUADTO:
-                    pc.quadTo(coords[0], coords[1],
-                              coords[2], coords[3]);
-                    break;
-                case PathIterator.SEG_CUBICTO:
-                    pc.curveTo(coords[0], coords[1],
-                               coords[2], coords[3],
-                               coords[4], coords[5]);
-                    break;
-                case PathIterator.SEG_CLOSE:
-                    pc.closePath();
-                    break;
-            }
-            pi.next();
-        }
-        pc.pathDone();
-    }
-
-    public static Renderer setupRenderer(Shape shape,
-                                  BasicStroke stroke,
-                                  BaseTransform xform,
-                                  Rectangle rclip,
-                                  boolean antialiasedShape)
-    {
-        PathIterator pi = shape.getPathIterator(null);
-        Renderer r = antialiasedShape ? savedAARenderer : savedRenderer;
-        feedConsumer(pi, initRenderer(stroke, xform, rclip, pi.getWindingRule(), r));
-        return r;
-    }
-
-    public static Renderer setupRenderer(Path2D p2d,
-                                  BasicStroke stroke,
-                                  BaseTransform xform,
-                                  Rectangle rclip,
-                                  boolean antialiasedShape)
-    {
-        Renderer r = antialiasedShape ? savedAARenderer : savedRenderer;
-        PathConsumer2D pc2d = initRenderer(stroke, xform, rclip, p2d.getWindingRule(), r);
-
-        float coords[] = p2d.getFloatCoordsNoClone();
-        byte types[] = p2d.getCommandsNoClone();
-        int nsegs = p2d.getNumCommands();
-        int coff = 0;
-        for (int i = 0; i < nsegs; i++) {
-            switch (types[i]) {
-                case PathIterator.SEG_MOVETO:
-                    pc2d.moveTo(coords[coff+0], coords[coff+1]);
-                    coff += 2;
-                    break;
-                case PathIterator.SEG_LINETO:
-                    pc2d.lineTo(coords[coff+0], coords[coff+1]);
-                    coff += 2;
-                    break;
-                case PathIterator.SEG_QUADTO:
-                    pc2d.quadTo(coords[coff+0], coords[coff+1],
-                                coords[coff+2], coords[coff+3]);
-                    coff += 4;
-                    break;
-                case PathIterator.SEG_CUBICTO:
-                    pc2d.curveTo(coords[coff+0], coords[coff+1],
-                                 coords[coff+2], coords[coff+3],
-                                 coords[coff+4], coords[coff+5]);
-                    coff += 6;
-                    break;
-                case PathIterator.SEG_CLOSE:
-                    pc2d.closePath();
-                    break;
-            }
-        }
-        pc2d.pathDone();
-        return r;
-    }
-}
diff a/modules/javafx.graphics/src/main/java/com/sun/prism/impl/shape/OpenPiscesRasterizer.java b/modules/javafx.graphics/src/main/java/com/sun/prism/impl/shape/OpenPiscesRasterizer.java
--- a/modules/javafx.graphics/src/main/java/com/sun/prism/impl/shape/OpenPiscesRasterizer.java
+++ /dev/null
@@ -1,238 +0,0 @@
-/*
- * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.prism.impl.shape;
-
-import com.sun.javafx.geom.RectBounds;
-import com.sun.javafx.geom.Path2D;
-import com.sun.javafx.geom.Rectangle;
-import com.sun.javafx.geom.Shape;
-import com.sun.javafx.geom.transform.BaseTransform;
-import com.sun.javafx.util.Logging;
-import com.sun.openpisces.AlphaConsumer;
-import com.sun.openpisces.Renderer;
-import com.sun.prism.BasicStroke;
-import com.sun.prism.impl.PrismSettings;
-import java.nio.ByteBuffer;
-
-public class OpenPiscesRasterizer implements ShapeRasterizer {
-    private static MaskData emptyData = MaskData.create(new byte[1], 0, 0, 1, 1);
-
-    private static Consumer savedConsumer;
-
-    @Override
-    public MaskData getMaskData(Shape shape,
-                                BasicStroke stroke,
-                                RectBounds xformBounds,
-                                BaseTransform xform,
-                                boolean close, boolean antialiasedShape)
-    {
-        if (stroke != null && stroke.getType() != BasicStroke.TYPE_CENTERED) {
-            // RT-27427
-            // TODO: Optimize the combinatorial strokes for simple
-            // shapes and/or teach the rasterizer to be able to
-            // do a "differential fill" between two shapes.
-            // Note that most simple shapes will use a more optimized path
-            // than this method for the INNER/OUTER strokes anyway.
-            shape = stroke.createStrokedShape(shape);
-            stroke = null;
-        }
-        if (xformBounds == null) {
-            if (stroke != null) {
-                // Note that all places that pass null for xformbounds also
-                // pass null for stroke so that the following is not typically
-                // executed, but just here as a safety net.
-                shape = stroke.createStrokedShape(shape);
-                stroke = null;
-            }
-
-            xformBounds = new RectBounds();
-            //TODO: Need to verify that this is a safe cast ... (RT-27427)
-            xformBounds = (RectBounds) xform.transform(shape.getBounds(), xformBounds);
-        }
-        Rectangle rclip = new Rectangle(xformBounds);
-        if (rclip.isEmpty()) {
-            return emptyData;
-        }
-        Renderer renderer = null;
-        try {
-            if (shape instanceof Path2D) {
-                renderer = OpenPiscesPrismUtils.setupRenderer((Path2D) shape,
-                        stroke, xform, rclip, antialiasedShape);
-            }
-            if (renderer == null) {
-                renderer = OpenPiscesPrismUtils.setupRenderer(shape,
-                        stroke, xform, rclip, antialiasedShape);
-            }
-            int outpix_xmin = renderer.getOutpixMinX();
-            int outpix_ymin = renderer.getOutpixMinY();
-            int outpix_xmax = renderer.getOutpixMaxX();
-            int outpix_ymax = renderer.getOutpixMaxY();
-            int w = outpix_xmax - outpix_xmin;
-            int h = outpix_ymax - outpix_ymin;
-            if (w <= 0 || h <= 0) {
-                return emptyData;
-            }
-
-            Consumer consumer = savedConsumer;
-            if (consumer == null || w * h > consumer.getAlphaLength()) {
-                int csize = (w * h + 0xfff) & (~0xfff);
-                savedConsumer = consumer = new Consumer(csize);
-                if (PrismSettings.verbose) {
-                System.out.println("new alphas");
-                }
-            }
-            consumer.setBoundsNoClone(outpix_xmin, outpix_ymin, w, h);
-            renderer.produceAlphas(consumer);
-            return consumer.getMaskData();
-        } catch (Throwable ex) {
-            if (PrismSettings.verbose) {
-                ex.printStackTrace();
-            }
-            Logging.getJavaFXLogger().warning("Cannot rasterize Shape: "
-                    + ex.toString());
-            return emptyData;
-        }
-    }
-
-    private static class Consumer implements AlphaConsumer {
-        static byte savedAlphaMap[];
-        int x, y, width, height;
-        byte alphas[];
-        byte alphaMap[];
-        ByteBuffer alphabuffer;
-        MaskData maskdata = new MaskData();
-
-        public Consumer(int alphalen) {
-            this.alphas = new byte[alphalen];
-            alphabuffer = ByteBuffer.wrap(alphas);
-        }
-
-        public void setBoundsNoClone(int x, int y, int w, int h) {
-            this.x = x;
-            this.y = y;
-            this.width = w;
-            this.height = h;
-            maskdata.update(alphabuffer, x, y, w, h);
-        }
-
-        @Override
-        public int getOriginX() {
-            return x;
-        }
-
-        @Override
-        public int getOriginY() {
-            return y;
-        }
-
-        @Override
-        public int getWidth() {
-            return width;
-        }
-
-        @Override
-        public int getHeight() {
-            return height;
-        }
-
-        public byte[] getAlphasNoClone() {
-            return alphas;
-        }
-
-        public int getAlphaLength() {
-            return alphas.length;
-        }
-
-        public MaskData getMaskData() {
-            return maskdata;
-        }
-
-        @Override
-        public void setMaxAlpha(int maxalpha) {
-            byte map[] = savedAlphaMap;
-            if (map == null || map.length != maxalpha+1) {
-                map = new byte[maxalpha+1];
-                for (int i = 0; i <= maxalpha; i++) {
-                    map[i] = (byte) ((i*255 + maxalpha/2)/maxalpha);
-                }
-                savedAlphaMap = map;
-            }
-            this.alphaMap = map;
-        }
-
-        @Override
-        public void setAndClearRelativeAlphas(int[] alphaRow, int pix_y,
-                                              int pix_from, int pix_to)
-        {
-//            System.out.println("setting row "+(pix_y - y)+
-//                               " out of "+width+" x "+height);
-            int w = width;
-            int off = (pix_y - y) * w;
-            byte out[] = this.alphas;
-            byte map[] = this.alphaMap;
-            int a = 0;
-            for (int i = 0; i < w; i++) {
-                a += alphaRow[i];
-                alphaRow[i] = 0;
-                out[off+i] = map[a];
-            }
-        }
-
-        public void setAndClearRelativeAlphas2(int[] alphaDeltas, int pix_y,
-                                               int pix_from, int pix_to)
-        {
-            if (pix_to >= pix_from) {
-                byte out[] = this.alphas;
-                byte map[] = this.alphaMap;
-                int from = pix_from - x;
-                int to = pix_to - x;
-                int w = width;
-                int off = (pix_y - y) * w;
-
-                int i = 0;
-                while (i < from) {
-                    out[off+i] = 0;
-                    i++;
-                }
-                int curAlpha = 0;
-                while (i <= to) {
-                    curAlpha += alphaDeltas[i];
-                    alphaDeltas[i] = 0;
-                    byte a = map[curAlpha];
-                    out[off+i] = a;
-                    i++;
-                }
-                alphaDeltas[i] = 0;
-                while (i < w) {
-                    out[off+i] = 0;
-                    i++;
-                }
-            } else {
-                java.util.Arrays.fill(alphaDeltas, 0);
-            }
-        }
-    }
-}
diff a/modules/javafx.graphics/src/main/java/com/sun/prism/impl/shape/ShapeUtil.java b/modules/javafx.graphics/src/main/java/com/sun/prism/impl/shape/ShapeUtil.java
--- a/modules/javafx.graphics/src/main/java/com/sun/prism/impl/shape/ShapeUtil.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/prism/impl/shape/ShapeUtil.java
@@ -37,16 +37,10 @@
 public class ShapeUtil {
 
     private static final ShapeRasterizer shapeRasterizer;
     static {
         switch (PrismSettings.rasterizerSpec) {
-            case JavaPisces:
-                shapeRasterizer = new OpenPiscesRasterizer();
-                break;
-            case NativePisces:
-                shapeRasterizer = new NativePiscesRasterizer();
-                break;
             case FloatMarlin:
                 shapeRasterizer = new MarlinRasterizer();
                 break;
             default:
             case DoubleMarlin:
@@ -62,42 +56,17 @@
                                           boolean close, boolean antialiasedShape)
     {
         return shapeRasterizer.getMaskData(shape, stroke, xformBounds, xform, close, antialiasedShape);
     }
 
-    public static Shape createCenteredStrokedShape(Shape s, BasicStroke stroke)
-    {
-        if (PrismSettings.rasterizerSpec == RasterizerType.DoubleMarlin) {
-            return DMarlinRasterizer.createCenteredStrokedShape(s, stroke);
-        }
+    public static Shape createCenteredStrokedShape(Shape s, BasicStroke stroke) {
         if (PrismSettings.rasterizerSpec == RasterizerType.FloatMarlin) {
             return MarlinRasterizer.createCenteredStrokedShape(s, stroke);
         }
-        // JavaPisces fallback:
-        return createCenteredStrokedShapeOpenPisces(s, stroke);
-    }
-
-    private static Shape createCenteredStrokedShapeOpenPisces(Shape s, BasicStroke stroke)
-    {
-        final float lw = (stroke.getType() == BasicStroke.TYPE_CENTERED) ?
-                             stroke.getLineWidth() : stroke.getLineWidth() * 2.0f;
-
-        final Path2D p2d = new Path2D(Path2D.WIND_NON_ZERO);
-
-        PathConsumer2D pc2d =
-            new com.sun.openpisces.Stroker(p2d, lw, stroke.getEndCap(),
-                                                    stroke.getLineJoin(),
-                                                    stroke.getMiterLimit());
-
-        if (stroke.isDashed()) {
-            pc2d = new com.sun.openpisces.Dasher(pc2d, stroke.getDashArray(),
-                                                       stroke.getDashPhase());
-        }
-        com.sun.prism.impl.shape.OpenPiscesPrismUtils.feedConsumer(
-                s.getPathIterator(null), pc2d);
 
-        return p2d;
+        // Default to DoubleMarlin
+        return DMarlinRasterizer.createCenteredStrokedShape(s, stroke);
     }
 
     /**
      * Private constructor to prevent instantiation.
      */
diff a/modules/javafx.graphics/src/main/java/com/sun/prism/sw/DirectRTPiscesAlphaConsumer.java b/modules/javafx.graphics/src/main/java/com/sun/prism/sw/DirectRTPiscesAlphaConsumer.java
--- a/modules/javafx.graphics/src/main/java/com/sun/prism/sw/DirectRTPiscesAlphaConsumer.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.prism.sw;
-
-import com.sun.openpisces.AlphaConsumer;
-import com.sun.openpisces.Renderer;
-import com.sun.pisces.PiscesRenderer;
-
-final class DirectRTPiscesAlphaConsumer implements AlphaConsumer {
-
-    private byte alpha_map[];
-    private int outpix_xmin;
-    private int outpix_ymin;
-    private int w;
-    private int h;
-    private int rowNum;
-
-    private PiscesRenderer pr;
-
-    void initConsumer(Renderer renderer, PiscesRenderer pr) {
-        outpix_xmin = renderer.getOutpixMinX();
-        outpix_ymin = renderer.getOutpixMinY();
-        w = renderer.getOutpixMaxX() - outpix_xmin;
-        if (w < 0) { w = 0; }
-        h = renderer.getOutpixMaxY() - outpix_ymin;
-        if (h < 0) { h = 0; }
-        rowNum = 0;
-        this.pr = pr;
-    }
-
-    @Override
-    public int getOriginX() {
-        return outpix_xmin;
-    }
-
-    @Override
-    public int getOriginY() {
-        return outpix_ymin;
-    }
-
-    @Override
-    public int getWidth() {
-        return w;
-    }
-
-    @Override
-    public int getHeight() {
-        return h;
-    }
-
-    @Override
-    public void setMaxAlpha(int maxalpha) {
-        if ((alpha_map == null) || (alpha_map.length != maxalpha+1)) {
-            alpha_map = new byte[maxalpha+1];
-            for (int i = 0; i <= maxalpha; i++) {
-                alpha_map[i] = (byte) ((i*255 + maxalpha/2)/maxalpha);
-            }
-        }
-    }
-
-    @Override
-    public void setAndClearRelativeAlphas(int[] alphaDeltas, int pix_y, int firstdelta, int lastdelta) {
-        pr.emitAndClearAlphaRow(alpha_map, alphaDeltas, pix_y, firstdelta, lastdelta, rowNum);
-        rowNum++;
-    }
-}
diff a/modules/javafx.graphics/src/main/java/com/sun/prism/sw/SWContext.java b/modules/javafx.graphics/src/main/java/com/sun/prism/sw/SWContext.java
--- a/modules/javafx.graphics/src/main/java/com/sun/prism/sw/SWContext.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/prism/sw/SWContext.java
@@ -37,21 +37,19 @@
 import com.sun.marlin.MarlinAlphaConsumer;
 import com.sun.marlin.MarlinConst;
 import com.sun.marlin.MarlinRenderer;
 import com.sun.marlin.MarlinRenderingEngine;
 import com.sun.marlin.RendererContext;
-import com.sun.openpisces.Renderer;
 import com.sun.pisces.PiscesRenderer;
 import com.sun.prism.BasicStroke;
 import com.sun.prism.PixelFormat;
 import com.sun.prism.ResourceFactory;
 import com.sun.prism.Texture;
 import com.sun.prism.impl.PrismSettings;
 import com.sun.prism.impl.shape.DMarlinPrismUtils;
 import com.sun.prism.impl.shape.MarlinPrismUtils;
 import com.sun.prism.impl.shape.MaskData;
-import com.sun.prism.impl.shape.OpenPiscesPrismUtils;
 import com.sun.prism.impl.shape.ShapeUtil;
 
 import java.lang.ref.SoftReference;
 
 final class SWContext {
@@ -64,94 +62,10 @@
     interface ShapeRenderer {
         void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape);
         void dispose();
     }
 
-    class NativeShapeRenderer implements ShapeRenderer {
-        private SoftReference<SWMaskTexture> maskTextureRef;
-
-        public void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape) {
-            try {
-                final MaskData mask = ShapeUtil.rasterizeShape(shape, stroke, clip.toRectBounds(), tr, true, antialiasedShape);
-                final SWMaskTexture tex = this.validateMaskTexture(mask.getWidth(), mask.getHeight());
-                mask.uploadToTexture(tex, 0, 0, false);
-                pr.fillAlphaMask(tex.getDataNoClone(), mask.getOriginX(), mask.getOriginY(),
-                                 mask.getWidth(), mask.getHeight(), 0, tex.getPhysicalWidth());
-            } catch (Throwable ex) {
-                if (PrismSettings.verbose) {
-                    ex.printStackTrace();
-                }
-                Logging.getJavaFXLogger().warning("Cannot rasterize Shape: "
-                        + ex.toString());
-            }
-        }
-
-        private SWMaskTexture initMaskTexture(int width, int height) {
-            final SWMaskTexture tex = (SWMaskTexture)factory.createMaskTexture(width, height, Texture.WrapMode.CLAMP_NOT_NEEDED);
-            maskTextureRef = new SoftReference<SWMaskTexture>(tex);
-            return tex;
-        }
-
-        private void disposeMaskTexture() {
-            if (maskTextureRef != null){
-                maskTextureRef.clear();
-                maskTextureRef = null;
-            }
-        }
-
-        private SWMaskTexture validateMaskTexture(int width, int height) {
-            SWMaskTexture tex;
-            if (maskTextureRef == null) {
-                tex = this.initMaskTexture(width, height);
-            } else {
-                tex = maskTextureRef.get();
-                if (tex == null ||
-                    tex.getPhysicalWidth() < width ||
-                    tex.getPhysicalHeight() < height)
-                {
-                    this.disposeMaskTexture();
-                    tex = this.initMaskTexture(width, height);
-                }
-            }
-            return tex;
-        }
-
-        public void dispose() {
-            this.disposeMaskTexture();
-        }
-    }
-
-    static final class JavaShapeRenderer implements ShapeRenderer {
-        private final DirectRTPiscesAlphaConsumer alphaConsumer = new DirectRTPiscesAlphaConsumer();
-
-        public void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape) {
-            if (stroke != null && stroke.getType() != BasicStroke.TYPE_CENTERED) {
-                // RT-27427
-                // TODO: Optimize the combinatorial strokes for simple
-                // shapes and/or teach the rasterizer to be able to
-                // do a "differential fill" between two shapes.
-                // Note that most simple shapes will use a more optimized path
-                // than this method for the INNER/OUTER strokes anyway.
-                shape = stroke.createStrokedShape(shape);
-                stroke = null;
-            }
-            try {
-                final Renderer r = OpenPiscesPrismUtils.setupRenderer(shape, stroke, tr, clip, antialiasedShape);
-                alphaConsumer.initConsumer(r, pr);
-                r.produceAlphas(alphaConsumer);
-            } catch (Throwable ex) {
-                if (PrismSettings.verbose) {
-                    ex.printStackTrace();
-                }
-                Logging.getJavaFXLogger().warning("Cannot rasterize Shape: "
-                        + ex.toString());
-            }
-        }
-
-        public void dispose() { }
-    }
-
     static final class MarlinShapeRenderer implements ShapeRenderer {
         private final DirectRTMarlinAlphaConsumer alphaConsumer = new DirectRTMarlinAlphaConsumer();
 
         @Override
         public void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape) {
@@ -339,16 +253,10 @@
     }
 
     SWContext(ResourceFactory factory) {
         this.factory = factory;
         switch (PrismSettings.rasterizerSpec) {
-            case JavaPisces:
-                this.shapeRenderer = new JavaShapeRenderer();
-                break;
-            case NativePisces:
-                this.shapeRenderer = new NativeShapeRenderer();
-                break;
             case FloatMarlin:
                 this.shapeRenderer = new MarlinShapeRenderer();
                 break;
             default:
             case DoubleMarlin:
diff a/modules/javafx.graphics/src/main/native-prism/AlphaConsumer.h b/modules/javafx.graphics/src/main/native-prism/AlphaConsumer.h
--- a/modules/javafx.graphics/src/main/native-prism/AlphaConsumer.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifndef ALPHACONSUMER_H
-#define ALPHACONSUMER_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct {
-    jint originX;
-    jint originY;
-    jint width;
-    jint height;
-    jbyte *alphas;
-//    public void setMaxAlpha(jint maxalpha);
-//    public void setAndClearRelativeAlphas(jint alphaDeltas[], jint pix_y,
-//                                          jint firstdelta, jint lastdelta);
-} AlphaConsumer;
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ALPHACONSUMER_H */
-
diff a/modules/javafx.graphics/src/main/native-prism/Curve.c b/modules/javafx.graphics/src/main/native-prism/Curve.c
--- a/modules/javafx.graphics/src/main/native-prism/Curve.c
+++ /dev/null
@@ -1,305 +0,0 @@
-/*
- * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#include <math.h>
-#include <jni.h>
-
-#include "Curve.h"
-#include "Helpers.h"
-
-//final class Curve {
-
-#define this (*((Curve *) pCurve))
-
-void Curve_set(Curve *pCurve, jfloat points[], jint type) {
-    switch(type) {
-    case 8:
-        Curve_setcubic(pCurve,
-                       points[0], points[1],
-                       points[2], points[3],
-                       points[4], points[5],
-                       points[6], points[7]);
-        break;
-    case 6:
-        Curve_setquad(pCurve,
-                      points[0], points[1],
-                      points[2], points[3],
-                      points[4], points[5]);
-        break;
-//    default:
-//        throw new InternalError("Curves can only be cubic or quadratic");
-    }
-}
-
-void Curve_setcubic(Curve *pCurve,
-                    jfloat x1, jfloat y1,
-                    jfloat x2, jfloat y2,
-                    jfloat x3, jfloat y3,
-                    jfloat x4, jfloat y4)
-{
-    this.ax = 3 * (x2 - x3) + x4 - x1;
-    this.ay = 3 * (y2 - y3) + y4 - y1;
-    this.bx = 3 * (x1 - 2 * x2 + x3);
-    this.by = 3 * (y1 - 2 * y2 + y3);
-    this.cx = 3 * (x2 - x1);
-    this.cy = 3 * (y2 - y1);
-    this.dx = x1;
-    this.dy = y1;
-    this.dax = 3 * this.ax; this.day = 3 * this.ay;
-    this.dbx = 2 * this.bx; this.dby = 2 * this.by;
-}
-
-void Curve_setquad(Curve *pCurve,
-                   jfloat x1, jfloat y1,
-                   jfloat x2, jfloat y2,
-                   jfloat x3, jfloat y3)
-{
-    this.ax = this.ay = 0.0f;
-
-    this.bx = x1 - 2 * x2 + x3;
-    this.by = y1 - 2 * y2 + y3;
-    this.cx = 2 * (x2 - x1);
-    this.cy = 2 * (y2 - y1);
-    this.dx = x1;
-    this.dy = y1;
-    this.dax = 0; this.day = 0;
-    this.dbx = 2 * this.bx; this.dby = 2 * this.by;
-}
-
-static jfloat xat(Curve *pCurve, jfloat t) {
-    return t * (t * (t * this.ax + this.bx) + this.cx) + this.dx;
-}
-static jfloat yat(Curve *pCurve, jfloat t) {
-    return t * (t * (t * this.ay + this.by) + this.cy) + this.dy;
-}
-
-static jfloat dxat(Curve *pCurve, jfloat t) {
-    return t * (t * this.dax + this.dbx) + this.cx;
-}
-static jfloat dyat(Curve *pCurve, jfloat t) {
-    return t * (t * this.day + this.dby) + this.cy;
-}
-
-jint Curve_dxRoots(Curve *pCurve, jfloat roots[], jint off) {
-    return Helpers_quadraticRoots(this.dax, this.dbx, this.cx, roots, off);
-}
-jint Curve_dyRoots(Curve *pCurve, jfloat roots[], jint off) {
-    return Helpers_quadraticRoots(this.day, this.dby, this.cy, roots, off);
-}
-
-jint Curve_infPoints(Curve *pCurve, jfloat pts[], jint off) {
-    // inflection point at t if -f'(t)x*f''(t)y + f'(t)y*f''(t)x == 0
-    // Fortunately, this turns out to be quadratic, so there are at
-    // most 2 inflection points.
-    const jfloat a = this.dax * this.dby - this.dbx * this.day;
-    const jfloat b = 2 * (this.cy * this.dax - this.day * this.cx);
-    const jfloat c = this.cy * this.dbx - this.cx * this.dby;
-
-    return Helpers_quadraticRoots(a, b, c, pts, off);
-}
-
-// finds points where the first and second derivative are
-// perpendicular. This happens when g(t) = f'(t)*f''(t) == 0 (where
-// * is a dot product). Unfortunately, we have to solve a cubic.
-static jint perpendiculardfddf(Curve *pCurve, jfloat pts[], jint off) {
-//    assert pts.length >= off + 4;
-
-    // these are the coefficients of some multiple of g(t) (not g(t),
-    // because the roots of a polynomial are not changed after multiplication
-    // by a constant, and this way we save a few multiplications).
-    const jfloat a = 2*(this.dax*this.dax + this.day*this.day);
-    const jfloat b = 3*(this.dax*this.dbx + this.day*this.dby);
-    const jfloat c = 2*(this.dax*this.cx + this.day*this.cy)
-                      + this.dbx*this.dbx + this.dby*this.dby;
-    const jfloat d = this.dbx*this.cx + this.dby*this.cy;
-    return Helpers_cubicRootsInAB(a, b, c, d, pts, off, 0.0f, 1.0f);
-}
-
-static jfloat ROCsq(Curve *pCurve, const jfloat t);
-static jfloat falsePositionROCsqMinusX(Curve *pCurve,
-                                       jfloat x0, jfloat x1,
-                                       const jfloat x, const jfloat err);
-static jboolean sameSign(double x, double y);
-
-// Tries to find the roots of the function ROC(t)-w in [0, 1). It uses
-// a variant of the false position algorithm to find the roots. False
-// position requires that 2 initial values x0,x1 be given, and that the
-// function must have opposite signs at those values. To find such
-// values, we need the local extrema of the ROC function, for which we
-// need the roots of its derivative; however, it's harder to find the
-// roots of the derivative in this case than it is to find the roots
-// of the original function. So, we find all points where this curve's
-// first and second derivative are perpendicular, and we pretend these
-// are our local extrema. There are at most 3 of these, so we will check
-// at most 4 sub-intervals of (0,1). ROC has asymptotes at inflection
-// points, so roc-w can have at least 6 roots. This shouldn't be a
-// problem for what we're trying to do (draw a nice looking curve).
-jint Curve_rootsOfROCMinusW(Curve *pCurve,
-                            jfloat roots[], jint off,
-                            const jfloat w, const jfloat err)
-{
-    // no OOB exception, because by now off<=6, and roots.length >= 10
-//    assert off <= 6 && roots.length >= 10;
-    jint i;
-    jint ret = off;
-    jint numPerpdfddf = perpendiculardfddf(pCurve, roots, off);
-    jfloat t0 = 0, ft0 = ROCsq(pCurve, t0) - w*w;
-    roots[off + numPerpdfddf] = 1.0f; // always check interval end points
-    numPerpdfddf++;
-    for (i = off; i < off + numPerpdfddf; i++) {
-        jfloat t1 = roots[i], ft1 = ROCsq(pCurve, t1) - w*w;
-        if (ft0 == 0.0f) {
-            roots[ret++] = t0;
-        } else if (ft1 * ft0 < 0.0f) { // have opposite signs
-            // (ROC(t)^2 == w^2) == (ROC(t) == w) is true because
-            // ROC(t) >= 0 for all t.
-            roots[ret++] = falsePositionROCsqMinusX(pCurve, t0, t1, w*w, err);
-        }
-        t0 = t1;
-        ft0 = ft1;
-    }
-
-    return ret - off;
-}
-
-static jfloat eliminateInf(jfloat x) {
-    return (x > BIGGEST_FLOAT ? BIGGEST_FLOAT :
-            (x < -BIGGEST_FLOAT ? -BIGGEST_FLOAT : x));
-//    return (x == Float.POSITIVE_INFINITY ? Float.MAX_VALUE :
-//        (x == Float.NEGATIVE_INFINITY ? Float.MIN_VALUE : x));
-}
-
-// A slight modification of the false position algorithm on wikipedia.
-// This only works for the ROCsq-x functions. It might be nice to have
-// the function as an argument, but that would be awkward in java6.
-// NOTE: It is something to consider for java8 (or whenever lambda
-// expressions make it into the language), depending on how closures
-// and turn out. Same goes for the newton's method
-// algorithm in Helpers.java
-static jfloat falsePositionROCsqMinusX(Curve *pCurve,
-                                       jfloat x0, jfloat x1,
-                                       const jfloat x, const jfloat err)
-{
-    const jint iterLimit = 100;
-    jint side = 0;
-    jfloat t = x1, ft = eliminateInf(ROCsq(pCurve, t) - x);
-    jfloat s = x0, fs = eliminateInf(ROCsq(pCurve, s) - x);
-    jfloat r = s, fr;
-    jint i;
-    for (i = 0; i < iterLimit && fabs(t - s) > err * fabs(t + s); i++) {
-        r = (fs * t - ft * s) / (fs - ft);
-        fr = ROCsq(pCurve, r) - x;
-        if (sameSign(fr, ft)) {
-            ft = fr; t = r;
-            if (side < 0) {
-                fs /= (1 << (-side));
-                side--;
-            } else {
-                side = -1;
-            }
-        } else if (fr * fs > 0) {
-            fs = fr; s = r;
-            if (side > 0) {
-                ft /= (1 << side);
-                side++;
-            } else {
-                side = 1;
-            }
-        } else {
-            break;
-        }
-    }
-    return r;
-}
-
-static jboolean sameSign(double x, double y) {
-    // another way is to test if x*y > 0. This is bad for small x, y.
-    return (x < 0 && y < 0) || (x > 0 && y > 0);
-}
-
-// returns the radius of curvature squared at t of this curve
-// see http://en.wikipedia.org/wiki/Radius_of_curvature_(applications)
-static jfloat ROCsq(Curve *pCurve, const jfloat t) {
-    // dx=xat(t) and dy=yat(t). These calls have been inlined for efficiency
-    const jfloat dx = t * (t * this.dax + this.dbx) + this.cx;
-    const jfloat dy = t * (t * this.day + this.dby) + this.cy;
-    const jfloat ddx = 2 * this.dax * t + this.dbx;
-    const jfloat ddy = 2 * this.day * t + this.dby;
-    const jfloat dx2dy2 = dx*dx + dy*dy;
-    const jfloat ddx2ddy2 = ddx*ddx + ddy*ddy;
-    const jfloat ddxdxddydy = ddx*dx + ddy*dy;
-    return dx2dy2*((dx2dy2*dx2dy2) / (dx2dy2 * ddx2ddy2 - ddxdxddydy*ddxdxddydy));
-}
-
-/*
-    // curve to be broken should be in pts
-    // this will change the contents of pts but not Ts
-    // NOTE: There's no reason for Ts to be an array. All we need is a sequence
-    // of t values at which to subdivide. An array statisfies this condition,
-    // but is unnecessarily restrictive. Ts should be an Iterator<Float> instead.
-    // Doing this will also make dashing easier, since we could easily make
-    // LengthIterator an Iterator<Float> and feed it to this function to simplify
-    // the loop in Dasher.somethingTo.
-    static Iterator<Integer> breakPtsAtTs(const jfloat[] pts, const int type,
-                                          const jfloat[] Ts, const int numTs)
-    {
-        assert pts.length >= 2*type && numTs <= Ts.length;
-        return new Iterator<Integer>() {
-            // these prevent object creation and destruction during autoboxing.
-            // Because of this, the compiler should be able to completely
-            // eliminate the boxing costs.
-            const Integer i0 = 0;
-            const Integer itype = type;
-            int nextCurveIdx = 0;
-            Integer curCurveOff = i0;
-            jfloat prevT = 0;
-
-            @Override public boolean hasNext() {
-                return nextCurveIdx < numTs + 1;
-            }
-
-            @Override public Integer next() {
-                Integer ret;
-                if (nextCurveIdx < numTs) {
-                    jfloat curT = Ts[nextCurveIdx];
-                    jfloat splitT = (curT - prevT) / (1 - prevT);
-                    Helpers.subdivideAt(splitT,
-                                        pts, curCurveOff,
-                                        pts, 0,
-                                        pts, type, type);
-                    prevT = curT;
-                    ret = i0;
-                    curCurveOff = itype;
-                } else {
-                    ret = curCurveOff;
-                }
-                nextCurveIdx++;
-                return ret;
-            }
-
-            @Override public void remove() {}
-        };
-    }
- */
diff a/modules/javafx.graphics/src/main/native-prism/Curve.h b/modules/javafx.graphics/src/main/native-prism/Curve.h
--- a/modules/javafx.graphics/src/main/native-prism/Curve.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifndef CURVE_H
-#define CURVE_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct {
-    jfloat ax, ay, bx, by, cx, cy, dx, dy;
-    jfloat dax, day, dbx, dby;
-} Curve;
-
-extern void Curve_set(Curve *pCurve, jfloat points[], jint type);
-
-extern void Curve_setquad(Curve *pCurve,
-                          jfloat x1, jfloat y1,
-                          jfloat x2, jfloat y2,
-                          jfloat x3, jfloat y3);
-
-extern void Curve_setcubic(Curve *pCurve,
-                           jfloat x1, jfloat y1,
-                           jfloat x2, jfloat y2,
-                           jfloat x3, jfloat y3,
-                           jfloat x4, jfloat y4);
-
-extern jint Curve_dxRoots(Curve *pCurve, jfloat roots[], jint off);
-
-extern jint Curve_dyRoots(Curve *pCurve, jfloat roots[], jint off);
-
-extern jint Curve_infPoints(Curve *pCurve, jfloat pts[], jint off);
-
-extern jint Curve_rootsOfROCMinusW(Curve *pCurve,
-                                   jfloat roots[], jint off,
-                                  const jfloat w, const jfloat err);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* CURVE_H */
-
diff a/modules/javafx.graphics/src/main/native-prism/Dasher.c b/modules/javafx.graphics/src/main/native-prism/Dasher.c
--- a/modules/javafx.graphics/src/main/native-prism/Dasher.c
+++ /dev/null
@@ -1,667 +0,0 @@
-/*
- * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#include <math.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "PathConsumer.h"
-
-#include "Helpers.h"
-#include "Dasher.h"
-
-static void LIinitializeIterationOnCurve(LengthIterator *pLI, jfloat pts[], jint type);
-static jfloat LInext(LengthIterator *pLI, const jfloat len);
-static jfloat LIlastSegLen(LengthIterator *pLI);
-static void LIgoLeft(LengthIterator *pLI);
-static void LIgoToNextLeaf(LengthIterator *pLI);
-static jfloat LIonLeaf(LengthIterator *pLI);
-
-/**
- * The <code>Dasher</code> class takes a series of linear commands
- * (<code>moveTo</code>, <code>lineTo</code>, <code>close</code> and
- * <code>end</code>) and breaks them into smaller segments according to a
- * dash pattern array and a starting dash phase.
- *
- * <p> Issues: in J2Se, a zero length dash segment as drawn as a very
- * short dash, whereas Pisces does not draw anything.  The PostScript
- * semantics are unclear.
- *
- */
-
-static MoveToFunc       Dasher_MoveTo;
-static LineToFunc       Dasher_LineTo;
-static QuadToFunc       Dasher_QuadTo;
-static CurveToFunc      Dasher_CurveTo;
-static ClosePathFunc    Dasher_ClosePath;
-static PathDoneFunc     Dasher_PathDone;
-
-#define this (*(Dasher *)pDasher)
-
-    /**
-     * Constructs a <code>Dasher</code>.
-     *
-     * @param out an output <code>PathConsumer2D</code>.
-     * @param dash an array of <code>float</code>s containing the dash pattern
-     * @param phase a <code>float</code> containing the dash phase
-    public Dasher(PathConsumer2D out, float[] dash, float phase) {
-        this(out);
-        reset(dash, phase);
-    }
-
-    public Dasher(PathConsumer2D out) {
-        this.out = out;
-
-        // we need curCurvepts to be able to contain 2 curves because when
-        // dashing curves, we need to subdivide it
-        curCurvepts = new float[8 * 2];
-    }
-     */
-
-void Dasher_init(Dasher *pDasher,
-                 PathConsumer *out,
-                 jfloat dash[], jint numdashes,
-                 jfloat phase)
-{
-    memset(pDasher, 0, sizeof(Dasher));
-    PathConsumer_init(&this.consumer,
-                      Dasher_MoveTo,
-                      Dasher_LineTo,
-                      Dasher_QuadTo,
-                      Dasher_CurveTo,
-                      Dasher_ClosePath,
-                      Dasher_PathDone);
-
-    this.firstSegmentsBufferSIZE = 7;
-    this.firstSegmentsBuffer = new_float(this.firstSegmentsBufferSIZE);
-    this.firstSegidx = 0;
-
-    this.out = out;
-    Dasher_reset(pDasher, dash, numdashes, phase);
-}
-
-#define MAX_CYCLES 16000000.0f
-void Dasher_reset(Dasher *pDasher, jfloat dash[], jint ndashes, jfloat phase) {
-    jint sidx;
-    jfloat d, sum, cycles;
-    jint i;
-
-    // Normalize so 0 <= phase < dash[0]
-    sidx = 0;
-    this.dashOn = JNI_TRUE;
-    sum = 0.0f;
-    for (i = 0; i < ndashes; i++) {
-        sum += dash[i];
-    }
-    cycles = phase / sum;
-    if (phase < 0) {
-        if (-cycles >= MAX_CYCLES) {
-            phase = 0;
-        } else {
-            jint fullcycles = (jint) floor(-cycles);
-            if ((fullcycles & ndashes & 1) != 0) {
-                this.dashOn = !this.dashOn;
-            }
-            phase += fullcycles * sum;
-            while (phase < 0) {
-                if (--sidx < 0) sidx = ndashes-1;
-                phase += dash[sidx];
-                this.dashOn = !this.dashOn;
-            }
-        }
-    } else if (phase > 0) {
-        if (cycles >= MAX_CYCLES) {
-            phase = 0;
-        } else {
-            jint fullcycles = (jint) floor(cycles);
-            if ((fullcycles & ndashes & 1) != 0) {
-                this.dashOn = !this.dashOn;
-            }
-            phase -= fullcycles * sum;
-            while (phase >= (d = dash[sidx])) {
-                phase -= d;
-                sidx = (sidx + 1) % ndashes;
-                this.dashOn = !this.dashOn;
-            }
-        }
-    }
-
-    this.dash = dash;
-    this.numdashes = ndashes;
-    this.startPhase = this.phase = phase;
-    this.startDashOn = this.dashOn;
-    this.startIdx = sidx;
-    this.starting = JNI_TRUE;
-}
-
-void Dasher_destroy(Dasher *pDasher) {
-    free(pDasher->firstSegmentsBuffer);
-    pDasher->firstSegmentsBuffer = NULL;
-    pDasher->firstSegmentsBufferSIZE = 0;
-}
-
-static jint emitSeg(PathConsumer *pDasher, jfloat buf[], jint off, jint type) {
-    switch (type) {
-    case 8:
-        return this.out->curveTo(this.out,
-                          buf[off+0], buf[off+1],
-                          buf[off+2], buf[off+3],
-                          buf[off+4], buf[off+5]);
-        break;
-    case 6:
-        return this.out->quadTo(this.out,
-                         buf[off+0], buf[off+1],
-                         buf[off+2], buf[off+3]);
-        break;
-    case 4:
-        return this.out->lineTo(this.out, buf[off], buf[off+1]);
-    }
-    return ERROR_NONE;
-}
-
-static jint emitFirstSegments(PathConsumer *pDasher) {
-    jint i;
-    for (i = 0; i < this.firstSegidx; ) {
-        jint status;
-        status = emitSeg(pDasher, this.firstSegmentsBuffer, i+1, (jint) this.firstSegmentsBuffer[i]);
-        if (status != ERROR_NONE) {
-            return status;
-        }
-        i += (((jint) this.firstSegmentsBuffer[i]) - 1);
-    }
-    this.firstSegidx = 0;
-    return ERROR_NONE;
-}
-
-// precondition: pts must be in relative coordinates (relative to x0,y0)
-// fullCurve is true iff the curve in pts has not been split.
-static jint goTo(PathConsumer *pDasher, jfloat pts[], jint off, jint type) {
-    jint status = ERROR_NONE;
-    jfloat x = pts[off + type - 4];
-    jfloat y = pts[off + type - 3];
-    if (this.dashOn) {
-        if (this.starting) {
-            if (this.firstSegmentsBufferSIZE < this.firstSegidx + (type-1)) {
-                jint newSize = (this.firstSegidx + (type-1)) * 2;
-                jfloat *newSegs = new_float(newSize);
-                if (!newSegs) {
-                    return ERROR_OOM;
-                }
-                System_arraycopy(this.firstSegmentsBuffer, 0, newSegs, 0, this.firstSegidx);
-                free(this.firstSegmentsBuffer);
-                this.firstSegmentsBuffer = newSegs;
-                this.firstSegmentsBufferSIZE = newSize;
-            }
-            this.firstSegmentsBuffer[this.firstSegidx++] = (jfloat) type;
-            System_arraycopy(pts, off, this.firstSegmentsBuffer, this.firstSegidx, type - 2);
-            this.firstSegidx += type - 2;
-        } else {
-            if (this.needsMoveTo) {
-                status = this.out->moveTo(this.out, this.x0, this.y0);
-                if (status != ERROR_NONE) {
-                    return status;
-                }
-                this.needsMoveTo = JNI_FALSE;
-            }
-            status = emitSeg(pDasher, pts, off, type);
-            if (status != ERROR_NONE) {
-                return status;
-            }
-        }
-    } else {
-        this.starting = JNI_FALSE;
-        this.needsMoveTo = JNI_TRUE;
-    }
-    this.x0 = x;
-    this.y0 = y;
-    return status;
-}
-
-static jint Dasher_MoveTo(PathConsumer *pDasher, jfloat newx0, jfloat newy0) {
-    jint status = ERROR_NONE;
-    if (this.firstSegidx > 0) {
-        status = this.out->moveTo(this.out, this.sx, this.sy);
-        if (status != ERROR_NONE) {
-            return status;
-        }
-        status = emitFirstSegments(pDasher);
-        if (status != ERROR_NONE) {
-            return status;
-        }
-    }
-    this.needsMoveTo = JNI_TRUE;
-    this.idx = this.startIdx;
-    this.dashOn = this.startDashOn;
-    this.phase = this.startPhase;
-    this.sx = this.x0 = newx0;
-    this.sy = this.y0 = newy0;
-    this.starting = JNI_TRUE;
-    return status;
-}
-
-static jint Dasher_LineTo(PathConsumer *pDasher, jfloat x1, jfloat y1) {
-    jint status = ERROR_NONE;
-    jfloat cx, cy;
-    jfloat dx = x1 - this.x0;
-    jfloat dy = y1 - this.y0;
-
-    jfloat len = (jfloat) sqrt(dx*dx + dy*dy);
-
-    if (len == 0) {
-        return status;
-    }
-
-    // The scaling factors needed to get the dx and dy of the
-    // transformed dash segments.
-    cx = dx / len;
-    cy = dy / len;
-
-    while (1) {
-        jfloat dashdx, dashdy;
-        jfloat leftInThisDashSegment = this.dash[this.idx] - this.phase;
-        if (len <= leftInThisDashSegment) {
-            this.curCurvepts[0] = x1;
-            this.curCurvepts[1] = y1;
-            status = goTo(pDasher, this.curCurvepts, 0, 4);
-            if (status != ERROR_NONE) {
-                return status;
-            }
-            // Advance phase within current dash segment
-            this.phase += len;
-            if (len == leftInThisDashSegment) {
-                this.phase = 0.0f;
-                this.idx = (this.idx + 1) % this.numdashes;
-                this.dashOn = !this.dashOn;
-            }
-            return status;
-        }
-
-        dashdx = this.dash[this.idx] * cx;
-        dashdy = this.dash[this.idx] * cy;
-        if (this.phase == 0) {
-            this.curCurvepts[0] = this.x0 + dashdx;
-            this.curCurvepts[1] = this.y0 + dashdy;
-        } else {
-            jfloat p = leftInThisDashSegment / this.dash[this.idx];
-            this.curCurvepts[0] = this.x0 + p * dashdx;
-            this.curCurvepts[1] = this.y0 + p * dashdy;
-        }
-
-        status = goTo(pDasher, this.curCurvepts, 0, 4);
-        if (status != ERROR_NONE) {
-            return status;
-        }
-
-        len -= leftInThisDashSegment;
-        // Advance to next dash segment
-        this.idx = (this.idx + 1) % this.numdashes;
-        this.dashOn = !this.dashOn;
-        this.phase = 0;
-    }
-    return status;
-}
-
-static jboolean pointCurve(jfloat curve[], jint type) {
-    jint i;
-    for (i = 2; i < type; i++) {
-        if (curve[i] != curve[i-2]) {
-            return JNI_FALSE;
-        }
-    }
-    return JNI_TRUE;
-}
-
-//    private LengthIterator li = null;
-
-// preconditions: curCurvepts must be an array of length at least 2 * type,
-// that contains the curve we want to dash in the first type elements
-static jint somethingTo(PathConsumer *pDasher, jint type) {
-    jint status = ERROR_NONE;
-    jint curCurveoff;
-    jfloat lastSplitT;
-    jfloat t;
-    jfloat leftInThisDashSegment;
-
-    if (pointCurve(this.curCurvepts, type)) {
-        return status;
-    }
-    LIinitializeIterationOnCurve(&this.li, this.curCurvepts, type);
-
-    curCurveoff = 0; // initially the current curve is at curCurvepts[0...type]
-    lastSplitT = 0;
-    t = 0;
-    leftInThisDashSegment = this.dash[this.idx] - this.phase;
-    while ((t = LInext(&this.li, leftInThisDashSegment)) < 1) {
-        if (t != 0) {
-            Helpers_subdivideAt((t - lastSplitT) / (1 - lastSplitT),
-                                this.curCurvepts, curCurveoff,
-                                this.curCurvepts, 0,
-                                this.curCurvepts, type, type);
-            lastSplitT = t;
-            status = goTo(pDasher, this.curCurvepts, 2, type);
-            if (status != ERROR_NONE) {
-                return status;
-            }
-            curCurveoff = type;
-        }
-        // Advance to next dash segment
-        this.idx = (this.idx + 1) % this.numdashes;
-        this.dashOn = !this.dashOn;
-        this.phase = 0;
-        leftInThisDashSegment = this.dash[this.idx];
-    }
-    status = goTo(pDasher, this.curCurvepts, curCurveoff+2, type);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-    this.phase += LIlastSegLen(&this.li);
-    if (this.phase >= this.dash[this.idx]) {
-        this.phase = 0.0f;
-        this.idx = (this.idx + 1) % this.numdashes;
-        this.dashOn = !this.dashOn;
-    }
-    return status;
-}
-
-static jint Dasher_CurveTo(PathConsumer *pDasher,
-                           jfloat x1, jfloat y1,
-                           jfloat x2, jfloat y2,
-                           jfloat x3, jfloat y3)
-{
-    this.curCurvepts[0] = this.x0;   this.curCurvepts[1] = this.y0;
-    this.curCurvepts[2] = x1;        this.curCurvepts[3] = y1;
-    this.curCurvepts[4] = x2;        this.curCurvepts[5] = y2;
-    this.curCurvepts[6] = x3;        this.curCurvepts[7] = y3;
-    return somethingTo(pDasher, 8);
-}
-
-static jint Dasher_QuadTo(PathConsumer *pDasher,
-                          jfloat x1, jfloat y1,
-                          jfloat x2, jfloat y2)
-{
-    this.curCurvepts[0] = this.x0;   this.curCurvepts[1] = this.y0;
-    this.curCurvepts[2] = x1;        this.curCurvepts[3] = y1;
-    this.curCurvepts[4] = x2;        this.curCurvepts[5] = y2;
-    return somethingTo(pDasher, 6);
-}
-
-static jint Dasher_ClosePath(PathConsumer *pDasher) {
-    jint status = ERROR_NONE;
-    status = Dasher_LineTo(pDasher, this.sx, this.sy);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-    if (this.firstSegidx > 0) {
-        if (!this.dashOn || this.needsMoveTo) {
-            status = this.out->moveTo(this.out, this.sx, this.sy);
-            if (status != ERROR_NONE) {
-                return status;
-            }
-        }
-        status = emitFirstSegments(pDasher);
-        if (status != ERROR_NONE) {
-            return status;
-        }
-    }
-    return Dasher_MoveTo(pDasher, this.sx, this.sy);
-}
-
-static jint Dasher_PathDone(PathConsumer *pDasher) {
-    jint status = ERROR_NONE;
-    if (this.firstSegidx > 0) {
-        status = this.out->moveTo(this.out, this.sx, this.sy);
-        if (status != ERROR_NONE) {
-            return status;
-        }
-        status = emitFirstSegments(pDasher);
-        if (status != ERROR_NONE) {
-            return status;
-        }
-    }
-    return this.out->pathDone(this.out);
-}
-
-
-/*
-        public LengthIterator(jint reclimit, float err) {
-            this.limit = reclimit;
-            this.minTincrement = 1f / (1 << limit);
-            this.ERR = err;
-            this.recCurveStack = new float[reclimit+1][8];
-            this.sides = new Side[reclimit];
-            // if any methods are called without first initializing this object on
-            // a curve, we want it to fail ASAP.
-            this.nextT = Float.MAX_VALUE;
-            this.lenAtNextT = Float.MAX_VALUE;
-            this.lenAtLastSplit = Float.MIN_VALUE;
-            this.recLevel = Integer.MIN_VALUE;
-            this.lastSegLen = Float.MAX_VALUE;
-            this.done = true;
-        }
- */
-
-#undef this
-#define this (*((LengthIterator *) pLI))
-
-static void LIinitializeIterationOnCurve(LengthIterator *pLI, jfloat pts[], jint type) {
-    System_arraycopy(pts, 0, this.recCurveStack[0], 0, type);
-    this.curveType = type;
-    this.recLevel = 0;
-    this.lastT = 0;
-    this.lenAtLastT = 0;
-    this.nextT = 0;
-    this.lenAtNextT = 0;
-    LIgoLeft(pLI); // initializes nextT and lenAtNextT properly
-    this.lenAtLastSplit = 0;
-    if (this.recLevel > 0) {
-        this.sides[0] = LEFT;
-        this.done = JNI_FALSE;
-    } else {
-        // the root of the tree is a leaf so we're done.
-        this.sides[0] = RIGHT;
-        this.done = JNI_TRUE;
-    }
-    this.lastSegLen = 0;
-    this.cachedHaveLowAcceleration = -1;
-    /* = {0, 0, -1, 0}*/;
-    this.flatLeafCoefCache[0] = 0;
-    this.flatLeafCoefCache[1] = 0;
-    this.flatLeafCoefCache[2] = -1;
-    this.flatLeafCoefCache[3] = 0;
-}
-
-static jboolean LIhaveLowAcceleration(LengthIterator *pLI, jfloat err) {
-    if (this.cachedHaveLowAcceleration == -1) {
-        const jfloat len1 = this.curLeafCtrlPolyLengths[0];
-        const jfloat len2 = this.curLeafCtrlPolyLengths[1];
-        // the test below is equivalent to !within(len1/len2, 1, err).
-        // It is using a multiplication instead of a division, so it
-        // should be a bit faster.
-        if (!Helpers_within(len1, len2, err*len2)) {
-            this.cachedHaveLowAcceleration = 0;
-            return JNI_FALSE;
-        }
-        if (this.curveType == 8) {
-            const jfloat len3 = this.curLeafCtrlPolyLengths[2];
-            // if len1 is close to 2 and 2 is close to 3, that probably
-            // means 1 is close to 3 so the second part of this test might
-            // not be needed, but it doesn't hurt to include it.
-            if (!(Helpers_within(len2, len3, err*len3) &&
-                  Helpers_within(len1, len3, err*len3)))
-            {
-                this.cachedHaveLowAcceleration = 0;
-                return JNI_FALSE;
-            }
-        }
-        this.cachedHaveLowAcceleration = 1;
-        return JNI_TRUE;
-    }
-
-    return (this.cachedHaveLowAcceleration == 1);
-}
-
-// returns the t value where the remaining curve should be split in
-// order for the left subdivided curve to have length len. If len
-// is >= than the length of the uniterated curve, it returns 1.
-static jfloat LInext(LengthIterator *pLI, const jfloat len) {
-    const jfloat targetLength = this.lenAtLastSplit + len;
-    jfloat leaflen;
-    jfloat t;
-    while(this.lenAtNextT < targetLength) {
-        if (this.done) {
-            this.lastSegLen = this.lenAtNextT - this.lenAtLastSplit;
-            return 1;
-        }
-        LIgoToNextLeaf(pLI);
-    }
-    this.lenAtLastSplit = targetLength;
-    leaflen = this.lenAtNextT - this.lenAtLastT;
-    t = (targetLength - this.lenAtLastT) / leaflen;
-
-    // cubicRootsInAB is a fairly expensive call, so we just don't do it
-    // if the acceleration in this section of the curve is small enough.
-    if (!LIhaveLowAcceleration(pLI, 0.05f)) {
-        jfloat a, b, c, d;
-        jint n;
-        // We flatten the current leaf along the x axis, so that we're
-        // left with a, b, c which define a 1D Bezier curve. We then
-        // solve this to get the parameter of the original leaf that
-        // gives us the desired length.
-
-        if (this.flatLeafCoefCache[2] < 0) {
-            jfloat x = 0+this.curLeafCtrlPolyLengths[0],
-                    y = x+this.curLeafCtrlPolyLengths[1];
-            if (this.curveType == 8) {
-                jfloat z = y + this.curLeafCtrlPolyLengths[2];
-                this.flatLeafCoefCache[0] = 3*(x - y) + z;
-                this.flatLeafCoefCache[1] = 3*(y - 2*x);
-                this.flatLeafCoefCache[2] = 3*x;
-                this.flatLeafCoefCache[3] = -z;
-            } else if (this.curveType == 6) {
-                this.flatLeafCoefCache[0] = 0.0f;
-                this.flatLeafCoefCache[1] = y - 2*x;
-                this.flatLeafCoefCache[2] = 2*x;
-                this.flatLeafCoefCache[3] = -y;
-            }
-        }
-        a = this.flatLeafCoefCache[0];
-        b = this.flatLeafCoefCache[1];
-        c = this.flatLeafCoefCache[2];
-        d = t*this.flatLeafCoefCache[3];
-
-        // we use cubicRootsInAB here, because we want only roots in 0, 1,
-        // and our quadratic root finder doesn't filter, so it's just a
-        // matter of convenience.
-        n = Helpers_cubicRootsInAB(a, b, c, d, this.nextRoots, 0, 0, 1);
-        if (n == 1 && !Math_isnan(this.nextRoots[0])) {
-            t = this.nextRoots[0];
-        }
-    }
-    // t is relative to the current leaf, so we must make it a valid parameter
-    // of the original curve.
-    t = t * (this.nextT - this.lastT) + this.lastT;
-    if (t >= 1) {
-        t = 1;
-        this.done = JNI_TRUE;
-    }
-    // even if done = true, if we're here, that means targetLength
-    // is equal to, or very, very close to the total length of the
-    // curve, so lastSegLen won't be too high. In cases where len
-    // overshoots the curve, this method will exit in the while
-    // loop, and lastSegLen will still be set to the right value.
-    this.lastSegLen = len;
-    return t;
-}
-
-static jfloat LIlastSegLen(LengthIterator *pLI) {
-    return this.lastSegLen;
-}
-
-// go to the next leaf (in an inorder traversal) in the recursion tree
-// preconditions: must be on a leaf, and that leaf must not be the root.
-static void LIgoToNextLeaf(LengthIterator *pLI) {
-    // We must go to the first ancestor node that has an unvisited
-    // right child.
-    this.recLevel--;
-    while(this.sides[this.recLevel] == RIGHT) {
-        if (this.recLevel == 0) {
-            this.done = JNI_TRUE;
-            return;
-        }
-        this.recLevel--;
-    }
-
-    this.sides[this.recLevel] = RIGHT;
-    System_arraycopy(this.recCurveStack[this.recLevel], 0,
-                     this.recCurveStack[this.recLevel+1], 0, this.curveType);
-    this.recLevel++;
-    LIgoLeft(pLI);
-}
-
-// go to the leftmost node from the current node. Return its length.
-static void LIgoLeft(LengthIterator *pLI) {
-    jfloat len = LIonLeaf(pLI);
-    if (len >= 0) {
-        this.lastT = this.nextT;
-        this.lenAtLastT = this.lenAtNextT;
-        this.nextT += (1 << (REC_LIMIT - this.recLevel)) * MIN_T_INCREMENT;
-        this.lenAtNextT += len;
-        // invalidate caches
-        this.flatLeafCoefCache[2] = -1;
-        this.cachedHaveLowAcceleration = -1;
-    } else {
-        Helpers_subdivide(this.recCurveStack[this.recLevel], 0,
-                          this.recCurveStack[this.recLevel+1], 0,
-                          this.recCurveStack[this.recLevel], 0, this.curveType);
-        this.sides[this.recLevel] = LEFT;
-        this.recLevel++;
-        LIgoLeft(pLI);
-    }
-}
-
-// this is a bit of a hack. It returns -1 if we're not on a leaf, and
-// the length of the leaf if we are on a leaf.
-static jfloat LIonLeaf(LengthIterator *pLI) {
-    jfloat *curve = this.recCurveStack[this.recLevel];
-    jfloat polyLen = 0;
-    jfloat lineLen;
-
-    jfloat x0 = curve[0], y0 = curve[1];
-    jint i;
-    for (i = 2; i < this.curveType; i += 2) {
-        const jfloat x1 = curve[i], y1 = curve[i+1];
-        const jfloat len = Helpers_linelen(x0, y0, x1, y1);
-        polyLen += len;
-        this.curLeafCtrlPolyLengths[i/2 - 1] = len;
-        x0 = x1;
-        y0 = y1;
-    }
-
-    lineLen = Helpers_linelen(curve[0], curve[1], curve[this.curveType-2], curve[this.curveType-1]);
-    if (polyLen - lineLen < ERR || this.recLevel == REC_LIMIT) {
-        return (polyLen + lineLen)/2;
-    }
-    return -1;
-}
diff a/modules/javafx.graphics/src/main/native-prism/Dasher.h b/modules/javafx.graphics/src/main/native-prism/Dasher.h
--- a/modules/javafx.graphics/src/main/native-prism/Dasher.h
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifndef DASHER_H
-#define DASHER_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-enum Side {LEFT, RIGHT};
-
-typedef struct {
-    // Objects of this class are used to iterate through curves. They return
-    // t values where the left side of the curve has a specified length.
-    // It does this by subdividing the input curve until a certain error
-    // condition has been met. A recursive subdivision procedure would
-    // return as many as 1<<limit curves, but this is an iterator and we
-    // don't need all the curves all at once, so what we carry out a
-    // lazy inorder traversal of the recursion tree (meaning we only move
-    // through the tree when we need the next subdivided curve). This saves
-    // us a lot of memory because at any one time we only need to store
-    // limit+1 curves - one for each level of the tree + 1.
-    // NOTE: the way we do things here is not enough to traverse a general
-    // tree; however, the trees we are interested in have the property that
-    // every non leaf node has exactly 2 children
-    //    private static class LengthIterator {
-    #define REC_LIMIT 4
-    #define ERR .01f
-    #define MIN_T_INCREMENT (1.0f / (1 << REC_LIMIT))
-
-    // Holds the curves at various levels of the recursion. The root
-    // (i.e. the original curve) is at recCurveStack[0] (but then it
-    // gets subdivided, the left half is put at 1, so most of the time
-    // only the right half of the original curve is at 0)
-    jfloat recCurveStack[REC_LIMIT+1][8];
-    // sides[i] indicates whether the node at level i+1 in the path from
-    // the root to the current leaf is a left or right child of its parent.
-    enum Side sides[REC_LIMIT];
-    jint curveType;
-//    const jint limit = REC_LIMIT;
-//    const jfloat minTincrement = 1.0f / (1 << REC_LIMIT);
-    // lastT and nextT delimit the current leaf.
-    jfloat nextT;
-    jfloat lenAtNextT;
-    jfloat lastT;
-    jfloat lenAtLastT;
-    jfloat lenAtLastSplit;
-    jfloat lastSegLen;
-    // the current level in the recursion tree. 0 is the root. limit
-    // is the deepest possible leaf.
-    jint recLevel;
-    jboolean done;
-
-    // the lengths of the lines of the control polygon. Only its first
-    // curveType/2 - 1 elements are valid. This is an optimization. See
-    // next(float) for more detail.
-    jfloat curLeafCtrlPolyLengths[3];
-
-    // 0 == false, 1 == true, -1 == invalid cached value.
-    jint cachedHaveLowAcceleration;
-
-    // we want to avoid allocations/gc so we keep this array so we
-    // can put roots in it,
-    jfloat nextRoots[4];
-
-    // caches the coefficients of the current leaf in its flattened
-    // form (see inside next() for what that means). The cache is
-    // invalid when it's third element is negative, since in any
-    // valid flattened curve, this would be >= 0.
-    jfloat flatLeafCoefCache[4];
-} LengthIterator;
-
-typedef struct {
-    PathConsumer consumer;
-    PathConsumer *out;
-
-    jfloat *dash;
-    jint numdashes;
-    jfloat startPhase;
-    jboolean startDashOn;
-    jint startIdx;
-
-    jboolean starting;
-    jboolean needsMoveTo;
-
-    jint idx;
-    jboolean dashOn;
-    jfloat phase;
-
-    jfloat sx, sy;
-    jfloat x0, y0;
-
-    // temporary storage for the current curve
-    jfloat curCurvepts[8 * 2];
-
-    // We don't emit the first dash right away. If we did, caps would be
-    // drawn on it, but we need joins to be drawn if there's a closePath()
-    // So, we store the path elements that make up the first dash in the
-    // buffer below.
-    jint firstSegmentsBufferSIZE /* = 7*/;
-    jfloat *firstSegmentsBuffer /* = malloc(firstSegmentsBufferSIZE * sizeof(jfloat))*/;
-    jint firstSegidx /* = 0*/;
-
-    LengthIterator li;
-} Dasher;
-
-void Dasher_init(Dasher *pDasher,
-                 PathConsumer *out,
-                 jfloat dash[], jint numdashes,
-                 jfloat phase);
-
-void Dasher_reset(Dasher *pDasher, jfloat dash[], jint ndashes, jfloat phase);
-
-void Dasher_destroy(Dasher *pDasher);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* DASHER_H */
-
diff a/modules/javafx.graphics/src/main/native-prism/Helpers.c b/modules/javafx.graphics/src/main/native-prism/Helpers.c
--- a/modules/javafx.graphics/src/main/native-prism/Helpers.c
+++ /dev/null
@@ -1,547 +0,0 @@
-/*
- * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#include <jni.h>
-#ifdef ANDROID_NDK
-#include <stddef.h>
-#endif
-
-#include "math.h"
-#include "Helpers.h"
-#include "PathConsumer.h"
-
-#ifdef __APPLE__
-
-#include <TargetConditionals.h>
-
-#if TARGET_OS_IPHONE /* iOS */
-
-JNIEXPORT jint JNICALL
-JNI_OnLoad_prism_common(JavaVM* vm, void* reserved) {
-#ifdef JNI_VERSION_1_8
-    //min. returned JNI_VERSION required by JDK8 for builtin libraries
-    JNIEnv *env;
-    if ((*vm)->GetEnv(vm, (void **)&env, JNI_VERSION_1_8) != JNI_OK) {
-        return JNI_VERSION_1_4;
-    }
-    return JNI_VERSION_1_8;
-#else
-    return JNI_VERSION_1_4;
-#endif
-}
-
-#endif
-#endif
-
-void PathConsumer_init(PathConsumer *pConsumer,
-                       MoveToFunc       *moveTo,
-                       LineToFunc       *lineTo,
-                       QuadToFunc       *quadTo,
-                       CurveToFunc      *curveTo,
-                       ClosePathFunc    *closePath,
-                       PathDoneFunc     *pathDone)
-{
-    pConsumer->moveTo = moveTo;
-    pConsumer->lineTo = lineTo;
-    pConsumer->quadTo = quadTo;
-    pConsumer->curveTo = curveTo;
-    pConsumer->closePath = closePath;
-    pConsumer->pathDone = pathDone;
-}
-
-// Usable AlmostEqual function
-// See http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm
-jboolean Helpers_withinULP(const jfloat A, const jfloat B, const int maxUlps) {
-    // Make sure maxUlps is non-negative and small enough that the
-    // default NAN won't compare as equal to anything.
-//    assert(maxUlps > 0 && maxUlps < 4 * 1024 * 1024);
-    jint aInt, bInt;
-
-    // Make aInt lexicographically ordered as a twos-complement int
-    // This cast can induce "false positive" warnings from various compilers
-    // or bug checking tools, but is correct as sizeof(jint) == sizeof(jfloat)
-    aInt = *((jint *) &A);
-    if (aInt < 0) {
-        aInt = 0x80000000 - aInt;
-    }
-
-    // Make bInt lexicographically ordered as a twos-complement int
-    // This cast can induce "false positive" warnings from various compilers
-    // or bug checking tools, but is correct as sizeof(jint) == sizeof(jfloat)
-    bInt = *((jint *) &B);
-    if (bInt < 0) {
-        bInt = 0x80000000 - bInt;
-    }
-
-    // aInt,bInt are in the range [-0x7fffffff, +0x7fffffff]
-    // assuming maxUlps is much smaller than 0x7fffffff
-    // (<negative number> + maxUlps) will never overflow
-    // (<positive number> - maxUlps) will never overflow
-    if (aInt < bInt) {
-        return (aInt < 0) ? aInt + maxUlps >= bInt : bInt - maxUlps <= aInt;
-    } else {
-        return (bInt < 0) ? bInt + maxUlps >= aInt : aInt - maxUlps <= bInt;
-    }
-}
-
-jboolean Helpers_within(const jfloat x, const jfloat y, const jfloat err) {
-    const jfloat d = y - x;
-    return (d <= err && d >= -err);
-}
-
-jboolean Helpers_withind(const double x, const double y, const double err) {
-    const double d = y - x;
-    return (d <= err && d >= -err);
-}
-
-jint Helpers_quadraticRoots(const jfloat a, const jfloat b, const jfloat c,
-                            jfloat zeroes[], const jint off)
-{
-    jint ret = off;
-    jfloat t;
-    if (a != 0.0f) {
-        const jfloat dis = b*b - 4*a*c;
-        if (dis > 0) {
-            const jfloat sqrtDis = (jfloat) sqrt(dis);
-            // depending on the sign of b we use a slightly different
-            // algorithm than the traditional one to find one of the roots
-            // so we can avoid adding numbers of different signs (which
-            // might result in loss of precision).
-            if (b >= 0) {
-                zeroes[ret++] = (2 * c) / (-b - sqrtDis);
-                zeroes[ret++] = (-b - sqrtDis) / (2 * a);
-            } else {
-                zeroes[ret++] = (-b + sqrtDis) / (2 * a);
-                zeroes[ret++] = (2 * c) / (-b + sqrtDis);
-            }
-        } else if (dis == 0.0f) {
-            t = (-b) / (2 * a);
-            zeroes[ret++] = t;
-        }
-    } else {
-        if (b != 0.0f) {
-            t = (-c) / b;
-            zeroes[ret++] = t;
-        }
-    }
-    return ret - off;
-}
-
-static double Math_cbrt(double v) {
-    if (v < 0) {
-        return -pow(-v, 1.0/3.0);
-    } else {
-        return pow(v, 1.0/3.0);
-    }
-}
-
-// find the roots of g(t) = d*t^3 + a*t^2 + b*t + c in [A,B)
-jint Helpers_cubicRootsInAB(jfloat d, jfloat a, jfloat b, jfloat c,
-                            jfloat pts[], const jint off,
-                            const jfloat A, const jfloat B)
-{
-    double sq_A, p, q;
-    double cb_p, D;
-    jint num;
-    jfloat sub;
-    jint i;
-
-    if (d == 0) {
-        jint num = Helpers_quadraticRoots(a, b, c, pts, off);
-        return Helpers_filterOutNotInAB(pts, off, num, A, B) - off;
-    }
-    // From Graphics Gems:
-    // http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c
-    // (also from awt.geom.CubicCurve2D. But here we don't need as
-    // much accuracy and we don't want to create arrays so we use
-    // our own customized version).
-
-    /* normal form: x^3 + ax^2 + bx + c = 0 */
-    a /= d;
-    b /= d;
-    c /= d;
-
-    //  substitute x = y - A/3 to eliminate quadratic term:
-    //     x^3 +Px + Q = 0
-    //
-    // Since we actually need P/3 and Q/2 for all of the
-    // calculations that follow, we will calculate
-    // p = P/3
-    // q = Q/2
-    // instead and use those values for simplicity of the code.
-    sq_A = a * a;
-    p = 1.0/3 * (-1.0/3 * sq_A + b);
-    q = 1.0/2 * (2.0/27 * a * sq_A - 1.0/3 * a * b + c);
-
-    /* use Cardano's formula */
-
-    cb_p = p * p * p;
-    D = q * q + cb_p;
-
-    if (D < 0) {
-        // see: http://en.wikipedia.org/wiki/Cubic_function#Trigonometric_.28and_hyperbolic.29_method
-        const double phi = 1.0/3 * acos(-q / sqrt(-cb_p));
-        const double t = 2 * sqrt(-p);
-
-        pts[ off+0 ] =  (jfloat)( t * cos(phi));
-        pts[ off+1 ] =  (jfloat)(-t * cos(phi + PI / 3));
-        pts[ off+2 ] =  (jfloat)(-t * cos(phi - PI / 3));
-        num = 3;
-    } else {
-        const double sqrt_D = sqrt(D);
-        const double u = Math_cbrt(sqrt_D - q);
-        const double v = - Math_cbrt(sqrt_D + q);
-
-        pts[ off ] = (jfloat)(u + v);
-        num = 1;
-
-        if (Helpers_withind(D, 0, 1e-8)) {
-            pts[off+1] = -(pts[off] / 2);
-            num = 2;
-        }
-    }
-
-    sub = 1.0f/3 * a;
-
-    for (i = 0; i < num; ++i) {
-        pts[ off+i ] -= sub;
-    }
-
-    return Helpers_filterOutNotInAB(pts, off, num, A, B) - off;
-}
-
-// These use a hardcoded factor of 2 for increasing sizes. Perhaps this
-// should be provided as an argument.
-//static jfloat *widenArray(jfloat *in, const int cursize, const int numToAdd) {
-//    if (in.length >= cursize + numToAdd) {
-//        return in;
-//    }
-//    return Arrays.copyOf(in, 2 * (cursize + numToAdd));
-//}
-
-//    static int[] widenArray(int[] in, const int cursize, const int numToAdd) {
-//        if (in.length >= cursize + numToAdd) {
-//            return in;
-//        }
-//        return Arrays.copyOf(in, 2 * (cursize + numToAdd));
-//    }
-
-jfloat Helpers_evalCubic(const jfloat a, const jfloat b,
-                         const jfloat c, const jfloat d,
-                         const jfloat t)
-{
-    return t * (t * (t * a + b) + c) + d;
-}
-
-jfloat Helpers_evalQuad(const jfloat a, const jfloat b,
-                        const jfloat c, const jfloat t)
-{
-    return t * (t * a + b) + c;
-}
-
-// returns the index 1 past the last valid element remaining after filtering
-jint Helpers_filterOutNotInAB(jfloat nums[], const jint off, const jint len,
-                              const jfloat a, const jfloat b)
-{
-    jint ret = off;
-    jint i;
-    for (i = off; i < off + len; i++) {
-        if (nums[i] >= a && nums[i] < b) {
-            nums[ret++] = nums[i];
-        }
-    }
-    return ret;
-}
-
-jfloat Helpers_polyLineLength(jfloat poly[], const jint off, const jint nCoords) {
-//    assert nCoords % 2 == 0 && poly.length >= off + nCoords : "";
-    jfloat acc = 0;
-    jint i;
-    for (i = off + 2; i < off + nCoords; i += 2) {
-        acc += Helpers_linelen(poly[i], poly[i+1], poly[i-2], poly[i-1]);
-    }
-    return acc;
-}
-
-jfloat Helpers_linelen(jfloat x1, jfloat y1, jfloat x2, jfloat y2) {
-    const jfloat dx = x2 - x1;
-    const jfloat dy = y2 - y1;
-    return (jfloat) sqrt(dx*dx + dy*dy);
-}
-
-void Helpers_subdivide(jfloat src[], jint srcoff,
-                       jfloat left[], jint leftoff,
-                       jfloat right[], jint rightoff, jint type)
-{
-    switch(type) {
-    case 6:
-        Helpers_subdivideQuad(src, srcoff, left, leftoff, right, rightoff);
-        break;
-    case 8:
-        Helpers_subdivideCubic(src, srcoff, left, leftoff, right, rightoff);
-        break;
-//    default:
-//        fprintf(stderr, "Unsupported curve type");
-        //throw new InternalError("Unsupported curve type");
-    }
-}
-
-void Helpers_isort(jfloat a[], jint off, jint len) {
-    jint i;
-    for (i = off + 1; i < off + len; i++) {
-        jfloat ai = a[i];
-        jint j = i - 1;
-        for (; j >= off && a[j] > ai; j--) {
-            a[j+1] = a[j];
-        }
-        a[j+1] = ai;
-    }
-}
-
-// Most of these are copied from classes in java.awt.geom because we need
-// float versions of these functions, and Line2D, CubicCurve2D,
-// QuadCurve2D don't provide them.
-/**
- * Subdivides the cubic curve specified by the coordinates
- * stored in the <code>src</code> array at indices <code>srcoff</code>
- * through (<code>srcoff</code>&nbsp;+&nbsp;7) and stores the
- * resulting two subdivided curves into the two result arrays at the
- * corresponding indices.
- * Either or both of the <code>left</code> and <code>right</code>
- * arrays may be <code>null</code> or a reference to the same array
- * as the <code>src</code> array.
- * Note that the last point in the first subdivided curve is the
- * same as the first point in the second subdivided curve. Thus,
- * it is possible to pass the same array for <code>left</code>
- * and <code>right</code> and to use offsets, such as <code>rightoff</code>
- * equals (<code>leftoff</code> + 6), in order
- * to avoid allocating extra storage for this common point.
- * @param src the array holding the coordinates for the source curve
- * @param srcoff the offset into the array of the beginning of the
- * the 6 source coordinates
- * @param left the array for storing the coordinates for the first
- * half of the subdivided curve
- * @param leftoff the offset into the array of the beginning of the
- * the 6 left coordinates
- * @param right the array for storing the coordinates for the second
- * half of the subdivided curve
- * @param rightoff the offset into the array of the beginning of the
- * the 6 right coordinates
- * @since 1.7
- */
-void Helpers_subdivideCubic(jfloat src[], jint srcoff,
-                            jfloat left[], jint leftoff,
-                            jfloat right[], jint rightoff)
-{
-    jfloat x1 = src[srcoff + 0];
-    jfloat y1 = src[srcoff + 1];
-    jfloat ctrlx1 = src[srcoff + 2];
-    jfloat ctrly1 = src[srcoff + 3];
-    jfloat ctrlx2 = src[srcoff + 4];
-    jfloat ctrly2 = src[srcoff + 5];
-    jfloat x2 = src[srcoff + 6];
-    jfloat y2 = src[srcoff + 7];
-    jfloat centerx, centery;
-    if (left != NULL) {
-        left[leftoff + 0] = x1;
-        left[leftoff + 1] = y1;
-    }
-    if (right != NULL) {
-        right[rightoff + 6] = x2;
-        right[rightoff + 7] = y2;
-    }
-    x1 = (x1 + ctrlx1) / 2.0f;
-    y1 = (y1 + ctrly1) / 2.0f;
-    x2 = (x2 + ctrlx2) / 2.0f;
-    y2 = (y2 + ctrly2) / 2.0f;
-    centerx = (ctrlx1 + ctrlx2) / 2.0f;
-    centery = (ctrly1 + ctrly2) / 2.0f;
-    ctrlx1 = (x1 + centerx) / 2.0f;
-    ctrly1 = (y1 + centery) / 2.0f;
-    ctrlx2 = (x2 + centerx) / 2.0f;
-    ctrly2 = (y2 + centery) / 2.0f;
-    centerx = (ctrlx1 + ctrlx2) / 2.0f;
-    centery = (ctrly1 + ctrly2) / 2.0f;
-    if (left != NULL) {
-        left[leftoff + 2] = x1;
-        left[leftoff + 3] = y1;
-        left[leftoff + 4] = ctrlx1;
-        left[leftoff + 5] = ctrly1;
-        left[leftoff + 6] = centerx;
-        left[leftoff + 7] = centery;
-    }
-    if (right != NULL) {
-        right[rightoff + 0] = centerx;
-        right[rightoff + 1] = centery;
-        right[rightoff + 2] = ctrlx2;
-        right[rightoff + 3] = ctrly2;
-        right[rightoff + 4] = x2;
-        right[rightoff + 5] = y2;
-    }
-}
-
-void Helpers_subdivideCubicAt(jfloat t,
-                              jfloat src[], jint srcoff,
-                              jfloat left[], jint leftoff,
-                              jfloat right[], jint rightoff)
-{
-    jfloat x1 = src[srcoff + 0];
-    jfloat y1 = src[srcoff + 1];
-    jfloat ctrlx1 = src[srcoff + 2];
-    jfloat ctrly1 = src[srcoff + 3];
-    jfloat ctrlx2 = src[srcoff + 4];
-    jfloat ctrly2 = src[srcoff + 5];
-    jfloat x2 = src[srcoff + 6];
-    jfloat y2 = src[srcoff + 7];
-    jfloat centerx, centery;
-    if (left != NULL) {
-        left[leftoff + 0] = x1;
-        left[leftoff + 1] = y1;
-    }
-    if (right != NULL) {
-        right[rightoff + 6] = x2;
-        right[rightoff + 7] = y2;
-    }
-    x1 = x1 + t * (ctrlx1 - x1);
-    y1 = y1 + t * (ctrly1 - y1);
-    x2 = ctrlx2 + t * (x2 - ctrlx2);
-    y2 = ctrly2 + t * (y2 - ctrly2);
-    centerx = ctrlx1 + t * (ctrlx2 - ctrlx1);
-    centery = ctrly1 + t * (ctrly2 - ctrly1);
-    ctrlx1 = x1 + t * (centerx - x1);
-    ctrly1 = y1 + t * (centery - y1);
-    ctrlx2 = centerx + t * (x2 - centerx);
-    ctrly2 = centery + t * (y2 - centery);
-    centerx = ctrlx1 + t * (ctrlx2 - ctrlx1);
-    centery = ctrly1 + t * (ctrly2 - ctrly1);
-    if (left != NULL) {
-        left[leftoff + 2] = x1;
-        left[leftoff + 3] = y1;
-        left[leftoff + 4] = ctrlx1;
-        left[leftoff + 5] = ctrly1;
-        left[leftoff + 6] = centerx;
-        left[leftoff + 7] = centery;
-    }
-    if (right != NULL) {
-        right[rightoff + 0] = centerx;
-        right[rightoff + 1] = centery;
-        right[rightoff + 2] = ctrlx2;
-        right[rightoff + 3] = ctrly2;
-        right[rightoff + 4] = x2;
-        right[rightoff + 5] = y2;
-    }
-}
-
-void Helpers_subdivideQuad(jfloat src[], jint srcoff,
-                           jfloat left[], jint leftoff,
-                           jfloat right[], jint rightoff)
-{
-    jfloat x1 = src[srcoff + 0];
-    jfloat y1 = src[srcoff + 1];
-    jfloat ctrlx = src[srcoff + 2];
-    jfloat ctrly = src[srcoff + 3];
-    jfloat x2 = src[srcoff + 4];
-    jfloat y2 = src[srcoff + 5];
-    if (left != NULL) {
-        left[leftoff + 0] = x1;
-        left[leftoff + 1] = y1;
-    }
-    if (right != NULL) {
-        right[rightoff + 4] = x2;
-        right[rightoff + 5] = y2;
-    }
-    x1 = (x1 + ctrlx) / 2.0f;
-    y1 = (y1 + ctrly) / 2.0f;
-    x2 = (x2 + ctrlx) / 2.0f;
-    y2 = (y2 + ctrly) / 2.0f;
-    ctrlx = (x1 + x2) / 2.0f;
-    ctrly = (y1 + y2) / 2.0f;
-    if (left != NULL) {
-        left[leftoff + 2] = x1;
-        left[leftoff + 3] = y1;
-        left[leftoff + 4] = ctrlx;
-        left[leftoff + 5] = ctrly;
-    }
-    if (right != NULL) {
-        right[rightoff + 0] = ctrlx;
-        right[rightoff + 1] = ctrly;
-        right[rightoff + 2] = x2;
-        right[rightoff + 3] = y2;
-    }
-}
-
-void Helpers_subdivideQuadAt(jfloat t,
-                             jfloat src[], jint srcoff,
-                             jfloat left[], jint leftoff,
-                             jfloat right[], jint rightoff)
-{
-    jfloat x1 = src[srcoff + 0];
-    jfloat y1 = src[srcoff + 1];
-    jfloat ctrlx = src[srcoff + 2];
-    jfloat ctrly = src[srcoff + 3];
-    jfloat x2 = src[srcoff + 4];
-    jfloat y2 = src[srcoff + 5];
-    if (left != NULL) {
-        left[leftoff + 0] = x1;
-        left[leftoff + 1] = y1;
-    }
-    if (right != NULL) {
-        right[rightoff + 4] = x2;
-        right[rightoff + 5] = y2;
-    }
-    x1 = x1 + t * (ctrlx - x1);
-    y1 = y1 + t * (ctrly - y1);
-    x2 = ctrlx + t * (x2 - ctrlx);
-    y2 = ctrly + t * (y2 - ctrly);
-    ctrlx = x1 + t * (x2 - x1);
-    ctrly = y1 + t * (y2 - y1);
-    if (left != NULL) {
-        left[leftoff + 2] = x1;
-        left[leftoff + 3] = y1;
-        left[leftoff + 4] = ctrlx;
-        left[leftoff + 5] = ctrly;
-    }
-    if (right != NULL) {
-        right[rightoff + 0] = ctrlx;
-        right[rightoff + 1] = ctrly;
-        right[rightoff + 2] = x2;
-        right[rightoff + 3] = y2;
-    }
-}
-
-void Helpers_subdivideAt(jfloat t,
-                         jfloat src[], jint srcoff,
-                         jfloat left[], jint leftoff,
-                         jfloat right[], jint rightoff, jint size)
-{
-    switch(size) {
-    case 8:
-        Helpers_subdivideCubicAt(t, src, srcoff, left, leftoff, right, rightoff);
-        break;
-    case 6:
-        Helpers_subdivideQuadAt(t, src, srcoff, left, leftoff, right, rightoff);
-        break;
-    }
-}
diff a/modules/javafx.graphics/src/main/native-prism/Helpers.h b/modules/javafx.graphics/src/main/native-prism/Helpers.h
--- a/modules/javafx.graphics/src/main/native-prism/Helpers.h
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifndef HELPERS_H
-#define HELPERS_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define BIGGEST_FLOAT 3.4028234663852886E38f
-#define PI 3.141592653589793
-
-#define new_float(s)   ((jfloat *) calloc((s), sizeof(jfloat)))
-#define new_int(s)     ((jint   *) calloc((s), sizeof(jint)))
-
-#define Math_max(a, b)  (((a) > (b)) ? (a) : (b))
-#define Math_min(a, b)  (((a) < (b)) ? (a) : (b))
-#define Math_isnan(v)    (!((v) == (v)))
-
-#define System_arraycopy(arr1, off1, arr2, off2, n)       \
-    do {                                                  \
-        jint __i;                                         \
-        for (__i = 0; __i < (n); ++__i) {                 \
-            (arr2)[(off2) + __i] = (arr1)[(off1) + __i];  \
-        }                                                 \
-    } while (0)
-
-#define Arrays_fill(arr, from, to, val)                   \
-    do {                                                  \
-        jint __i;                                         \
-        jint __to = (to);                                 \
-        for (__i = (from); __i < __to; ++__i) {           \
-            (arr)[__i] = (val);                           \
-        }                                                 \
-    } while (0)
-
-extern jboolean Helpers_withinULP(const jfloat x, const jfloat y, const int maxUlps);
-
-extern jboolean Helpers_within(const jfloat x, const jfloat y, const jfloat err);
-
-extern jint Helpers_quadraticRoots(const jfloat a, const jfloat b, const jfloat c,
-                                   jfloat zeroes[], const jint off);
-
-// find the roots of g(t) = d*t^3 + a*t^2 + b*t + c in [A,B)
-extern jint Helpers_cubicRootsInAB(jfloat d, jfloat a, jfloat b, jfloat c,
-                                   jfloat pts[], const jint off,
-                                   const jfloat A, const jfloat B);
-
-extern jfloat Helpers_evalCubic(const jfloat a, const jfloat b,
-                                const jfloat c, const jfloat d,
-                                const jfloat t);
-
-extern jfloat Helpers_evalQuad(const jfloat a, const jfloat b,
-                               const jfloat c, const jfloat t);
-
-// returns the index 1 past the last valid element remaining after filtering
-extern jint Helpers_filterOutNotInAB(jfloat nums[], const jint off, const jint len,
-                                     const jfloat a, const jfloat b);
-
-extern jfloat Helpers_polyLineLength(jfloat poly[], const jint off, const jint nCoords);
-
-extern jfloat Helpers_linelen(jfloat x1, jfloat y1, jfloat x2, jfloat y2);
-
-extern void Helpers_subdivide(jfloat src[], jint srcoff, jfloat left[], jint leftoff,
-                              jfloat right[], jint rightoff, jint type);
-
-extern void Helpers_isort(jfloat a[], jint off, jint len);
-
-// Most of these are copied from classes in java.awt.geom because we need
-// float versions of these functions, and Line2D, CubicCurve2D,
-// QuadCurve2D don't provide them.
-/**
- * Subdivides the cubic curve specified by the coordinates
- * stored in the <code>src</code> array at indices <code>srcoff</code>
- * through (<code>srcoff</code>&nbsp;+&nbsp;7) and stores the
- * resulting two subdivided curves into the two result arrays at the
- * corresponding indices.
- * Either or both of the <code>left</code> and <code>right</code>
- * arrays may be <code>null</code> or a reference to the same array
- * as the <code>src</code> array.
- * Note that the last point in the first subdivided curve is the
- * same as the first point in the second subdivided curve. Thus,
- * it is possible to pass the same array for <code>left</code>
- * and <code>right</code> and to use offsets, such as <code>rightoff</code>
- * equals (<code>leftoff</code> + 6), in order
- * to avoid allocating extra storage for this common point.
- * @param src the array holding the coordinates for the source curve
- * @param srcoff the offset into the array of the beginning of the
- * the 6 source coordinates
- * @param left the array for storing the coordinates for the first
- * half of the subdivided curve
- * @param leftoff the offset into the array of the beginning of the
- * the 6 left coordinates
- * @param right the array for storing the coordinates for the second
- * half of the subdivided curve
- * @param rightoff the offset into the array of the beginning of the
- * the 6 right coordinates
- * @since 1.7
- */
-extern void Helpers_subdivideCubic(jfloat src[], jint srcoff,
-                                   jfloat left[], jint leftoff,
-                                   jfloat right[], jint rightoff);
-
-extern void Helpers_subdivideCubicAt(jfloat t, jfloat src[], jint srcoff,
-                                     jfloat left[], jint leftoff,
-                                     jfloat right[], jint rightoff);
-
-extern void Helpers_subdivideQuad(jfloat src[], jint srcoff,
-                                  jfloat left[], jint leftoff,
-                                  jfloat right[], jint rightoff);
-
-extern void Helpers_subdivideQuadAt(jfloat t, jfloat src[], jint srcoff,
-                                    jfloat left[], jint leftoff,
-                                    jfloat right[], jint rightoff);
-
-extern void Helpers_subdivideAt(jfloat t, jfloat src[], jint srcoff,
-                                jfloat left[], jint leftoff,
-                                jfloat right[], jint rightoff, jint size);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* HELPERS_H */
-
diff a/modules/javafx.graphics/src/main/native-prism/NativePiscesRasterizer.c b/modules/javafx.graphics/src/main/native-prism/NativePiscesRasterizer.c
--- a/modules/javafx.graphics/src/main/native-prism/NativePiscesRasterizer.c
+++ /dev/null
@@ -1,363 +0,0 @@
-/*
- * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#include <jni.h>
-#ifdef ANDROID_NDK
-#include <stddef.h>
-#endif
-#include "com_sun_prism_impl_shape_NativePiscesRasterizer.h"
-
-#include "Renderer.h"
-#include "Stroker.h"
-#include "Dasher.h"
-#include "Transformer.h"
-#include "AlphaConsumer.h"
-
-#define SEG(T) com_sun_prism_impl_shape_NativePiscesRasterizer_SEG_ ## T
-
-#define SEG_MOVETO   SEG(MOVETO)
-#define SEG_LINETO   SEG(LINETO)
-#define SEG_QUADTO   SEG(QUADTO)
-#define SEG_CUBICTO  SEG(CUBICTO)
-#define SEG_CLOSE    SEG(CLOSE)
-
-#define NPException    "java/lang/NullPointerException"
-#define AIOOBException "java/lang/ArrayIndexOutOfBoundsException"
-#define OOMError       "java/lang/OutOfMemoryError"
-#define IError         "java/lang/InternalError"
-
-#define CheckNPE(env, a)                                \
-    do {                                                \
-        if (a == NULL) {                                \
-            Throw(env, NPException, #a);                \
-            return;                                     \
-        }                                               \
-    } while (0)
-
-#define CheckLen(env, a, len)                           \
-    do {                                                \
-        if ((*env)->GetArrayLength(env, a) < len) {     \
-            Throw(env, AIOOBException, #a);             \
-            return;                                     \
-        }                                               \
-    } while (0)
-
-
-static void Throw(JNIEnv *env, char *throw_class_name, char *detail) {
-    jclass throw_class = (*env)->FindClass(env, throw_class_name);
-    if (throw_class != NULL) {
-        (*env)->ThrowNew(env, throw_class, detail);
-    }
-}
-
-static char * errorToString(jint errorCode) {
-    switch (errorCode) {
-        case ERROR_NONE:
-            return NULL;
-        case ERROR_OOM:
-            return "Out of Memory";
-        case ERROR_AIOOBE:
-            return "[PathConsumer";
-        default:
-            return "Unknown error";
-    }
-}
-
-static char * feedConsumer
-    (JNIEnv *env, PathConsumer *consumer,
-     jfloatArray coordsArray, jint coordSize,
-     jbyteArray commandsArray, jint numCommands)
-{
-    jint status = ERROR_NONE;
-    char *failure = NULL;
-    jfloat *coords;
-
-    coords = (*env)->GetPrimitiveArrayCritical(env, coordsArray, 0);
-    if (coords == NULL) {
-        failure = "";
-    } else {
-        jbyte *commands = (*env)->GetPrimitiveArrayCritical(env, commandsArray, 0);
-        if (commands == NULL) {
-            failure = "";
-        } else {
-            jint cmdoff, coordoff = 0;
-            for (cmdoff = 0; cmdoff < numCommands && failure == NULL; cmdoff++) {
-                switch (commands[cmdoff]) {
-                    case SEG_MOVETO:
-                        if (coordoff + 2 > coordSize) {
-                            failure = "[not enough coordinates for moveTo";
-                        } else {
-                            status = consumer->moveTo(consumer,
-                                             coords[coordoff+0], coords[coordoff+1]);
-                            if (status != ERROR_NONE) {
-                                failure = errorToString(status);
-                            }
-                            coordoff += 2;
-                        }
-                        break;
-                    case SEG_LINETO:
-                        if (coordoff + 2 > coordSize) {
-                            failure = "[not enough coordinates for lineTo";
-                        } else {
-                            status = consumer->lineTo(consumer,
-                                             coords[coordoff+0], coords[coordoff+1]);
-                            if (status != ERROR_NONE) {
-                                failure = errorToString(status);
-                            }
-                            coordoff += 2;
-                        }
-                        break;
-                    case SEG_QUADTO:
-                        if (coordoff + 4 > coordSize) {
-                            failure = "[not enough coordinates for quadTo";
-                        } else {
-                            status = consumer->quadTo(consumer,
-                                             coords[coordoff+0], coords[coordoff+1],
-                                             coords[coordoff+2], coords[coordoff+3]);
-                            if (status != ERROR_NONE) {
-                                failure = errorToString(status);
-                            }
-                            coordoff += 4;
-                        }
-                        break;
-                    case SEG_CUBICTO:
-                        if (coordoff + 6 > coordSize) {
-                            failure = "[not enough coordinates for curveTo";
-                        } else {
-                            status = consumer->curveTo(consumer,
-                                              coords[coordoff+0], coords[coordoff+1],
-                                              coords[coordoff+2], coords[coordoff+3],
-                                              coords[coordoff+4], coords[coordoff+5]);
-                            if (status != ERROR_NONE) {
-                                failure = errorToString(status);
-                            }
-                            coordoff += 6;
-                        }
-                        break;
-                    case SEG_CLOSE:
-                        status = consumer->closePath(consumer);
-                        if (status != ERROR_NONE) {
-                            failure = errorToString(status);
-                        }
-                        break;
-                    default:
-                        failure = "unrecognized Path segment";
-                        break;
-                }
-            }
-            (*env)->ReleasePrimitiveArrayCritical(env, commandsArray, commands, JNI_ABORT);
-        }
-        (*env)->ReleasePrimitiveArrayCritical(env, coordsArray, coords, JNI_ABORT);
-        if (failure == NULL) {
-            status = consumer->pathDone(consumer);
-            if (status != ERROR_NONE) {
-                failure = errorToString(status);
-            }
-        }
-    }
-    return failure;
-}
-
-/*
- * Class:     com_sun_prism_impl_shape_NativePiscesRasterizer
- * Method:    init
- * Signature: (II)V
- */
-JNIEXPORT void JNICALL
-Java_com_sun_prism_impl_shape_NativePiscesRasterizer_init
-    (JNIEnv *env, jclass klass,
-     jint subpixelLgPositionsX, jint subpixelLgPositionsY)
-{
-    Renderer_setup(subpixelLgPositionsX, subpixelLgPositionsY);
-}
-
-/*
- * Class:     com_sun_prism_impl_shape_NativePiscesRasterizer
- * Method:    produceFillAlphas
- * Signature: ([F[BIZDDDDDD[I[B)V
- */
-JNIEXPORT void JNICALL
-Java_com_sun_prism_impl_shape_NativePiscesRasterizer_produceFillAlphas
-    (JNIEnv *env, jclass klass,
-     jfloatArray coordsArray, jbyteArray commandsArray, jint numCommands, jboolean nonzero,
-     jdouble mxx, jdouble mxy, jdouble mxt, jdouble myx, jdouble myy, jdouble myt,
-     jintArray boundsArray, jbyteArray maskArray)
-{
-    jint bounds[4];
-    Transformer transformer;
-    Renderer renderer;
-    PathConsumer *consumer;
-    char *failure;
-    jint coordSize;
-
-    CheckNPE(env, coordsArray);
-    CheckNPE(env, commandsArray);
-    CheckNPE(env, boundsArray);
-    CheckNPE(env, maskArray);
-    CheckLen(env, boundsArray, 4);
-    CheckLen(env, commandsArray, numCommands);
-
-    (*env)->GetIntArrayRegion(env, boundsArray, 0, 4, bounds);
-    coordSize = (*env)->GetArrayLength(env, coordsArray);
-    Renderer_init(&renderer);
-    Renderer_reset(&renderer,
-                   bounds[0], bounds[1], bounds[2] - bounds[0], bounds[3] - bounds[1],
-                   nonzero ? WIND_NON_ZERO : WIND_EVEN_ODD);
-    consumer = Transformer_init(&transformer, &renderer.consumer,
-                                mxx, mxy, mxt, myx, myy, myt);
-    failure = feedConsumer(env, consumer,
-                           coordsArray, coordSize, commandsArray, numCommands);
-    if (failure == NULL) {
-        Renderer_getOutputBounds(&renderer, bounds);
-        (*env)->SetIntArrayRegion(env, boundsArray, 0, 4, bounds);
-        if (bounds[0] < bounds[2] && bounds[1] < bounds[3]) {
-            AlphaConsumer ac = {
-                bounds[0],
-                bounds[1],
-                bounds[2] - bounds[0],
-                bounds[3] - bounds[1],
-            };
-            if ((*env)->GetArrayLength(env, maskArray) / ac.width < ac.height) {
-                Throw(env, AIOOBException, "maskArray");
-            } else {
-                ac.alphas = (*env)->GetPrimitiveArrayCritical(env, maskArray, 0);
-                if (ac.alphas != NULL) {
-                    jint status;
-                    if ((status = Renderer_produceAlphas(&renderer, &ac)) != ERROR_NONE) {
-                        if (status == ERROR_OOM) {
-                            Throw(env, OOMError, "produceAlphas");
-                        } else {
-                            Throw(env, AIOOBException, "produceAlphas");
-                        }
-                    }
-                    (*env)->ReleasePrimitiveArrayCritical(env, maskArray, ac.alphas, 0);
-                }
-            }
-        }
-    } else if (*failure != 0) {
-        if (*failure == '[') {
-            Throw(env, AIOOBException, failure + 1);
-        } else {
-            Throw(env, IError, failure);
-        }
-    }
-    Renderer_destroy(&renderer);
-}
-
-/*
- * Class:     com_sun_prism_impl_shape_NativePiscesRasterizer
- * Method:    produceStrokeAlphas
- * Signature: ([F[BIFIIF[FFDDDDDD[I[B)V
- */
-JNIEXPORT void JNICALL
-Java_com_sun_prism_impl_shape_NativePiscesRasterizer_produceStrokeAlphas
-    (JNIEnv *env, jclass klass,
-     jfloatArray coordsArray, jbyteArray commandsArray, jint numCommands,
-     jfloat linewidth, jint linecap, jint linejoin, jfloat miterlimit,
-     jfloatArray dashArray, jfloat dashphase,
-     jdouble mxx, jdouble mxy, jdouble mxt, jdouble myx, jdouble myy, jdouble myt,
-     jintArray boundsArray, jbyteArray maskArray)
-{
-    jint bounds[4];
-    Stroker stroker;
-    Dasher dasher;
-    Renderer renderer;
-    Transformer transformer;
-    PathConsumer *consumer;
-    jint coordSize;
-    jfloat *dashes;
-    char *failure;
-
-    CheckNPE(env, coordsArray);
-    CheckNPE(env, commandsArray);
-    CheckNPE(env, boundsArray);
-    CheckNPE(env, maskArray);
-    CheckLen(env, boundsArray, 4);
-    CheckLen(env, commandsArray, numCommands);
-
-    (*env)->GetIntArrayRegion(env, boundsArray, 0, 4, bounds);
-    coordSize = (*env)->GetArrayLength(env, coordsArray);
-    Renderer_init(&renderer);
-    Renderer_reset(&renderer,
-                   bounds[0], bounds[1], bounds[2] - bounds[0], bounds[3] - bounds[1],
-                   WIND_NON_ZERO);
-    consumer = Transformer_init(&transformer, &renderer.consumer,
-                                mxx, mxy, mxt, myx, myy, myt);
-    Stroker_init(&stroker, consumer, linewidth, linecap, linejoin, miterlimit);
-    if (dashArray == NULL) {
-        dashes = NULL;
-        consumer = &stroker.consumer;
-    } else {
-        jint numdashes = (*env)->GetArrayLength(env, dashArray);
-        dashes = (*env)->GetPrimitiveArrayCritical(env, dashArray, 0);
-        if (dashes == NULL) {
-            return;
-        }
-        Dasher_init(&dasher, &stroker.consumer, dashes, numdashes, dashphase);
-        consumer = &dasher.consumer;
-    }
-    failure = feedConsumer(env, consumer,
-                           coordsArray, coordSize, commandsArray, numCommands);
-    if (dashArray != NULL) {
-        (*env)->ReleasePrimitiveArrayCritical(env, dashArray, dashes, JNI_ABORT);
-        Dasher_destroy(&dasher);
-    }
-    Stroker_destroy(&stroker);
-    if (failure == NULL) {
-        Renderer_getOutputBounds(&renderer, bounds);
-        (*env)->SetIntArrayRegion(env, boundsArray, 0, 4, bounds);
-        if (bounds[0] < bounds[2] && bounds[1] < bounds[3]) {
-            AlphaConsumer ac = {
-                bounds[0],
-                bounds[1],
-                bounds[2] - bounds[0],
-                bounds[3] - bounds[1],
-            };
-            if ((*env)->GetArrayLength(env, maskArray) / ac.width < ac.height) {
-                Throw(env, AIOOBException, "Mask");
-            } else {
-                ac.alphas = (*env)->GetPrimitiveArrayCritical(env, maskArray, 0);
-                if (ac.alphas != NULL) {
-                    jint status;
-                    if ((status = Renderer_produceAlphas(&renderer, &ac)) != ERROR_NONE) {
-                        if (status == ERROR_OOM) {
-                            Throw(env, OOMError, "produceAlphas");
-                        } else {
-                            Throw(env, AIOOBException, "produceAlphas");
-                        }
-                    }
-                    (*env)->ReleasePrimitiveArrayCritical(env, maskArray, ac.alphas, 0);
-                }
-            }
-        }
-    } else if (*failure != 0) {
-        if (*failure == '[') {
-            Throw(env, AIOOBException, failure + 1);
-        } else {
-            Throw(env, IError, failure);
-        }
-    }
-    Renderer_destroy(&renderer);
-}
diff a/modules/javafx.graphics/src/main/native-prism/PathConsumer.h b/modules/javafx.graphics/src/main/native-prism/PathConsumer.h
--- a/modules/javafx.graphics/src/main/native-prism/PathConsumer.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifndef PATHCONSUMER_H
-#define PATHCONSUMER_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <jni.h>
-
-// Pisces error codes
-#define ERROR_NONE   0
-#define ERROR_OOM    1
-#define ERROR_AIOOBE 2
-
-typedef struct _PathConsumer PathConsumer;
-
-typedef jint MoveToFunc(PathConsumer *pConsumer,
-                        jfloat x0, jfloat y0);
-typedef jint LineToFunc(PathConsumer *pConsumer,
-                        jfloat x1, jfloat y1);
-typedef jint QuadToFunc(PathConsumer *pConsumer,
-                        jfloat xc, jfloat yc,
-                        jfloat x1, jfloat y1);
-typedef jint CurveToFunc(PathConsumer *pConsumer,
-                         jfloat xc0, jfloat yc0,
-                         jfloat xc1, jfloat yc1,
-                         jfloat x1, jfloat y1);
-typedef jint ClosePathFunc(PathConsumer *pConsumer);
-typedef jint PathDoneFunc(PathConsumer *pConsumer);
-
-struct _PathConsumer {
-    MoveToFunc       *moveTo;
-    LineToFunc       *lineTo;
-    QuadToFunc       *quadTo;
-    CurveToFunc      *curveTo;
-    ClosePathFunc    *closePath;
-    PathDoneFunc     *pathDone;
-};
-
-extern void PathConsumer_init(PathConsumer *pConsumer,
-                              MoveToFunc       *moveTo,
-                              LineToFunc       *lineTo,
-                              QuadToFunc       *quadTo,
-                              CurveToFunc      *curveTo,
-                              ClosePathFunc    *closePath,
-                              PathDoneFunc     *pathDone);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* PATHCONSUMER_H */
-
diff a/modules/javafx.graphics/src/main/native-prism/Renderer.c b/modules/javafx.graphics/src/main/native-prism/Renderer.c
--- a/modules/javafx.graphics/src/main/native-prism/Renderer.c
+++ /dev/null
@@ -1,778 +0,0 @@
-/*
- * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#include <math.h>
-#include <stdlib.h>
-#include <jni.h>
-#include <string.h>
-
-#include "Helpers.h"
-#include "Renderer.h"
-#include "AlphaConsumer.h"
-
-//public final class Renderer implements PathConsumer2D {
-
-//    private final class ScanlineIterator {
-
-#define this (*((ScanlineIterator *) pIterator))
-
-static void ScanlineIterator_reset(ScanlineIterator *pIterator,
-                                   Renderer *pRenderer);
-
-static void ScanlineIterator_init(ScanlineIterator *pIterator,
-                                  Renderer *pRenderer)
-{
-    this.crossings = new_int(INIT_CROSSINGS_SIZE);
-    this.crossingsSIZE = INIT_CROSSINGS_SIZE;
-    this.edgePtrs = new_int(INIT_CROSSINGS_SIZE);
-    this.edgePtrsSIZE = INIT_CROSSINGS_SIZE;
-    ScanlineIterator_reset(pIterator, pRenderer);
-}
-
-static void ScanlineIterator_destroy(ScanlineIterator *pIterator) {
-    free(this.crossings);
-    this.crossings = NULL;
-    this.crossingsSIZE = 0;
-    free(this.edgePtrs);
-    this.edgePtrs = NULL;
-    this.edgePtrsSIZE = 0;
-}
-
-static void ScanlineIterator_reset(ScanlineIterator *pIterator,
-                                   Renderer *pRenderer)
-{
-    // We don't care if we clip some of the line off with ceil, since
-    // no scan line crossings will be eliminated (in fact, the ceil is
-    // the y of the first scan line crossing).
-    this.nextY = pRenderer->sampleRowMin;
-    this.edgeCount = 0;
-}
-
-// Iterate to the next scanline and return the number of crossings.
-// A count of -1 is returned to indicate OOM.
-static jint ScanlineIterator_next(ScanlineIterator *pIterator, Renderer *pRenderer) {
-    jint i, ecur;
-    jint *xings;
-    // NOTE: make function that convert from y value to bucket idx?
-    jint cury = this.nextY++;
-    jint bucket = cury - pRenderer->boundsMinY;
-    jint count = this.edgeCount;
-    jint *ptrs = this.edgePtrs;
-    jfloat *edges = pRenderer->edges;
-    jint bucketcount = pRenderer->edgeBuckets[bucket*2 + 1];
-
-    if ((bucketcount & 0x1) != 0) {
-        jint newCount = 0;
-        jint i;
-        for (i = 0; i < count; i++) {
-            jint ecur = ptrs[i];
-            if (edges[ecur+YMAX] > cury) {
-                ptrs[newCount++] = ecur;
-            }
-        }
-        count = newCount;
-    }
-    if (this.edgePtrsSIZE < count + (bucketcount >> 1)) {
-        jint newSize = (count + (bucketcount >> 1)) * 2;
-        jint *newPtrs = new_int(newSize);
-        if (!newPtrs) {
-            return -1;
-        }
-        System_arraycopy(this.edgePtrs, 0, newPtrs, 0, count);
-        free(this.edgePtrs);
-        this.edgePtrs = newPtrs;
-        this.edgePtrsSIZE = newSize;
-    }
-    ptrs = this.edgePtrs;
-    for (ecur = pRenderer->edgeBuckets[bucket*2];
-         ecur != 0;
-         ecur = (jint) edges[ecur+NEXT])
-    {
-        ptrs[count++] = --ecur;
-        // REMIND: Adjust start Y if necessary
-    }
-    this.edgePtrs = ptrs;
-    this.edgeCount = count;
-//    if ((count & 0x1) != 0) {
-//        System.out.println("ODD NUMBER OF EDGES!!!!");
-//    }
-    xings = this.crossings;
-    if (this.crossingsSIZE < count) {
-        free(this.crossings);
-        this.crossings = xings = new_int(this.edgePtrsSIZE);
-        if (!xings) {
-            return -1;
-        }
-        this.crossingsSIZE = this.edgePtrsSIZE;
-    }
-    for (i = 0; i < count; i++) {
-        jint ecur = ptrs[i];
-        jfloat curx = edges[ecur+CURX];
-        jint cross = ((jint) ceil(curx - 0.5f)) << 1;
-        jint j;
-        edges[ecur+CURX] = curx + edges[ecur+SLOPE];
-        if (edges[ecur+OR] > 0) {
-            cross |= 1;
-        }
-        j = i;
-        while (--j >= 0) {
-            jint jcross = xings[j];
-            if (jcross <= cross) {
-                break;
-            }
-            xings[j+1] = jcross;
-            ptrs[j+1] = ptrs[j];
-        }
-        xings[j+1] = cross;
-        ptrs[j+1] = ecur;
-    }
-    return count;
-}
-
-static jboolean ScanlineIterator_hasNext(ScanlineIterator *pIterator, Renderer *pRenderer) {
-    return this.nextY < pRenderer->sampleRowMax;
-}
-
-static jint ScanlineIterator_curY(ScanlineIterator *pIterator) {
-    return this.nextY - 1;
-}
-
-#undef this
-#define this (*((Renderer *) pRenderer))
-
-//////////////////////////////////////////////////////////////////////////////
-//  EDGE LIST
-//////////////////////////////////////////////////////////////////////////////
-// NOTE(maybe): very tempting to use fixed point here. A lot of opportunities
-// for shifts and just removing certain operations altogether.
-
-
-// each bucket is a linked list. this method adds eptr to the
-// start "bucket"th linked list.
-static jint addEdgeToBucket(PathConsumer *pRenderer, const jint eptr, const jint bucket) {
-    // we could implement this in terms of insertEdge, but this is a special
-    // case, so we optimize a bit.
-    if (this.edgeBuckets[bucket*2] >= MAX_EDGE_IDX) {
-        return ERROR_AIOOBE;
-    }
-    this.edges[eptr+NEXT] = (jfloat) this.edgeBuckets[bucket*2];
-    this.edgeBuckets[bucket*2] = eptr + 1;
-    this.edgeBuckets[bucket*2 + 1] += 2;
-    return ERROR_NONE;
-}
-
-static jint addLine(PathConsumer *pRenderer,
-                    jfloat x1, jfloat y1,
-                    jfloat x2, jfloat y2);
-
-// Flattens using adaptive forward differencing. This only carries out
-// one iteration of the AFD loop. All it does is update AFD variables (i.e.
-// X0, Y0, D*[X|Y], COUNT; not variables used for computing scanline crossings).
-static jint quadBreakIntoLinesAndAdd(PathConsumer *pRenderer,
-                                     jfloat x0, jfloat y0,
-                                     const Curve c,
-                                     const jfloat x2, const jfloat y2)
-{
-    jint status = ERROR_NONE;
-    jfloat ddx, ddy, dx, dy;
-    const jfloat QUAD_DEC_BND = 32;
-    const jint countlg = 4;
-    jint count = 1 << countlg;
-    jint countsq = count * count;
-    jfloat maxDD = Math_max(c.dbx / countsq, c.dby / countsq);
-    while (maxDD > QUAD_DEC_BND) {
-        maxDD /= 4;
-        count <<= 1;
-    }
-
-    countsq = count * count;
-    ddx = c.dbx / countsq;
-    ddy = c.dby / countsq;
-    dx = c.bx / countsq + c.cx / count;
-    dy = c.by / countsq + c.cy / count;
-
-    while (count-- > 1) {
-        jfloat x1 = x0 + dx;
-        jfloat y1 = y0 + dy;
-        dx += ddx;
-        dy += ddy;
-        status = addLine(pRenderer, x0, y0, x1, y1);
-        if (status != ERROR_NONE) {
-            return status;
-        }
-        x0 = x1;
-        y0 = y1;
-    }
-    return addLine(pRenderer, x0, y0, x2, y2);
-}
-
-// x0, y0 and x3,y3 are the endpoints of the curve. We could compute these
-// using c.xat(0),c.yat(0) and c.xat(1),c.yat(1), but this might introduce
-// numerical errors, and our callers already have the exact values.
-// Another alternative would be to pass all the control points, and call c.set
-// here, but then too many numbers are passed around.
-static jint curveBreakIntoLinesAndAdd(PathConsumer *pRenderer,
-                                      jfloat x0, jfloat y0,
-                                      const Curve c,
-                                      const jfloat x3, const jfloat y3)
-{
-    jint status = ERROR_NONE;
-    const jint countlg = 3;
-    jint count = 1 << countlg;
-    jfloat x1, y1;
-
-    // the dx and dy refer to forward differencing variables, not the last
-    // coefficients of the "points" polynomial
-    jfloat dddx, dddy, ddx, ddy, dx, dy;
-    dddx = 2.0f * c.dax / (1 << (3 * countlg));
-    dddy = 2.0f * c.day / (1 << (3 * countlg));
-
-    ddx = dddx + c.dbx / (1 << (2 * countlg));
-    ddy = dddy + c.dby / (1 << (2 * countlg));
-    dx = c.ax / (1 << (3 * countlg)) + c.bx / (1 << (2 * countlg)) + c.cx / (1 << countlg);
-    dy = c.ay / (1 << (3 * countlg)) + c.by / (1 << (2 * countlg)) + c.cy / (1 << countlg);
-
-    // we use x0, y0 to walk the line
-    x1 = x0;
-    y1 = y0;
-    while (count > 0) {
-        while (fabs(ddx) > DEC_BND || fabs(ddy) > DEC_BND) {
-            dddx /= 8;
-            dddy /= 8;
-            ddx = ddx/4 - dddx;
-            ddy = ddy/4 - dddy;
-            dx = (dx - ddx) / 2;
-            dy = (dy - ddy) / 2;
-            count <<= 1;
-        }
-        // can only do this on even "count" values, because we must divide count by 2
-        while (count % 2 == 0 && fabs(dx) <= INC_BND && fabs(dy) <= INC_BND) {
-            dx = 2 * dx + ddx;
-            dy = 2 * dy + ddy;
-            ddx = 4 * (ddx + dddx);
-            ddy = 4 * (ddy + dddy);
-            dddx = 8 * dddx;
-            dddy = 8 * dddy;
-            count >>= 1;
-        }
-        count--;
-        if (count > 0) {
-            x1 += dx;
-            dx += ddx;
-            ddx += dddx;
-            y1 += dy;
-            dy += ddy;
-            ddy += dddy;
-        } else {
-            x1 = x3;
-            y1 = y3;
-        }
-        status = addLine(pRenderer, x0, y0, x1, y1);
-        if (status != ERROR_NONE) {
-            return status;
-        }
-        x0 = x1;
-        y0 = y1;
-    }
-    return status;
-}
-
-static jint addLine(PathConsumer *pRenderer,
-                    jfloat x1, jfloat y1,
-                    jfloat x2, jfloat y2)
-{
-    jint status = ERROR_NONE;
-    jfloat or = 1; // orientation of the line. 1 if y increases, 0 otherwise.
-    jint firstCrossing, lastCrossing;
-    jfloat slope;
-    jint ptr, bucketIdx;
-
-    if (y2 < y1) {
-        or = y2; // no need to declare a temp variable. We have or.
-        y2 = y1;
-        y1 = or;
-        or = x2;
-        x2 = x1;
-        x1 = or;
-        or = 0;
-    }
-    firstCrossing = Math_max((jint) ceil(y1 - 0.5f), this.boundsMinY);
-    lastCrossing = Math_min((jint) ceil(y2 - 0.5f), this.boundsMaxY);
-    if (firstCrossing >= lastCrossing) {
-        return status;
-    }
-    if (firstCrossing < this.sampleRowMin) { this.sampleRowMin = firstCrossing; }
-    if (lastCrossing > this.sampleRowMax) { this.sampleRowMax = lastCrossing; }
-
-    slope = (x2 - x1) / (y2 - y1);
-
-    if (slope > 0) { // <==> x1 < x2
-        if (x1 < this.edgeMinX) { this.edgeMinX = x1; }
-        if (x2 > this.edgeMaxX) { this.edgeMaxX = x2; }
-    } else {
-        if (x2 < this.edgeMinX) { this.edgeMinX = x2; }
-        if (x1 > this.edgeMaxX) { this.edgeMaxX = x1; }
-    }
-
-    bucketIdx = firstCrossing - this.boundsMinY;
-    if (this.edgeBuckets[bucketIdx*2] >= MAX_EDGE_IDX) {
-        return ERROR_AIOOBE;
-    }
-
-    ptr = this.numEdges * SIZEOF_EDGE;
-    if (this.edgesSIZE < ptr + SIZEOF_EDGE) {
-        jint newSize = (ptr + SIZEOF_EDGE) * 2;
-        jfloat *newEdges = new_float(newSize);
-        if (!newEdges) {
-            return ERROR_OOM;
-        }
-        System_arraycopy(this.edges, 0, newEdges, 0, ptr);
-        free(this.edges);
-        this.edges = newEdges;
-        this.edgesSIZE = newSize;
-    }
-    this.numEdges++;
-    this.edges[ptr+OR] = or;
-    this.edges[ptr+CURX] = x1 + (firstCrossing + 0.5f - y1) * slope;
-    this.edges[ptr+SLOPE] = slope;
-    this.edges[ptr+YMAX] = (jfloat) lastCrossing;
-    status = addEdgeToBucket(pRenderer, ptr, bucketIdx);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-    this.edgeBuckets[(lastCrossing - this.boundsMinY)*2 + 1] |= 1;
-    return status;
-}
-
-// END EDGE LIST
-//////////////////////////////////////////////////////////////////////////////
-static MoveToFunc       Renderer_moveTo;
-static LineToFunc       Renderer_lineTo;
-static QuadToFunc       Renderer_quadTo;
-static CurveToFunc      Renderer_curveTo;
-static ClosePathFunc    Renderer_closePath;
-static PathDoneFunc     Renderer_pathDone;
-
-// Antialiasing
-static jint SUBPIXEL_LG_POSITIONS_X;
-static jint SUBPIXEL_LG_POSITIONS_Y;
-static jint SUBPIXEL_POSITIONS_X;
-static jint SUBPIXEL_POSITIONS_Y;
-static jint SUBPIXEL_MASK_X;
-static jint SUBPIXEL_MASK_Y;
-//static jint MAX_AA_ALPHA;
-
-// We keep 2 alpha maps around which map from the number of sub-pixel
-// samples to a byte-based alpha value from 0 to 255.  We only ever
-// use 2 different sub-pixel sample counts in practice (depending on
-// AA vs. non-AA rendering), so these 2 should satisfy all of our needs.
-static jbyte *alphaMap = NULL;
-static jint alphaMax;
-static jbyte *altAlphaMap = NULL;
-static jint altAlphaMax;
-
-static void setMaxAlpha(jint maxalpha);
-
-void Renderer_setup(jint subpixelLgPositionsX, jint subpixelLgPositionsY) {
-    SUBPIXEL_LG_POSITIONS_X = subpixelLgPositionsX;
-    SUBPIXEL_LG_POSITIONS_Y = subpixelLgPositionsY;
-    SUBPIXEL_POSITIONS_X = 1 << (SUBPIXEL_LG_POSITIONS_X);
-    SUBPIXEL_POSITIONS_Y = 1 << (SUBPIXEL_LG_POSITIONS_Y);
-    SUBPIXEL_MASK_X = SUBPIXEL_POSITIONS_X - 1;
-    SUBPIXEL_MASK_Y = SUBPIXEL_POSITIONS_Y - 1;
-//    MAX_AA_ALPHA = (SUBPIXEL_POSITIONS_X * SUBPIXEL_POSITIONS_Y);
-    setMaxAlpha((SUBPIXEL_POSITIONS_X * SUBPIXEL_POSITIONS_Y));
-}
-
-void Renderer_init(Renderer *pRenderer) {
-    memset(pRenderer, 0, sizeof(Renderer));
-    PathConsumer_init(&pRenderer->consumer,
-                      Renderer_moveTo,
-                      Renderer_lineTo,
-                      Renderer_quadTo,
-                      Renderer_curveTo,
-                      Renderer_closePath,
-                      Renderer_pathDone);
-}
-
-void Renderer_reset(Renderer *pRenderer,
-                    jint pix_boundsX, jint pix_boundsY,
-                    jint pix_boundsWidth, jint pix_boundsHeight,
-                    jint windingRule)
-{
-    jint numBuckets;
-
-    this.windingRule = windingRule;
-
-    this.boundsMinX = pix_boundsX * SUBPIXEL_POSITIONS_X;
-    this.boundsMinY = pix_boundsY * SUBPIXEL_POSITIONS_Y;
-    this.boundsMaxX = (pix_boundsX + pix_boundsWidth) * SUBPIXEL_POSITIONS_X;
-    this.boundsMaxY = (pix_boundsY + pix_boundsHeight) * SUBPIXEL_POSITIONS_Y;
-
-    this.edgeMinX = BIGGEST_FLOAT;
-    this.edgeMaxX = -BIGGEST_FLOAT;
-    this.sampleRowMax = this.boundsMinY;
-    this.sampleRowMin = this.boundsMaxY;
-
-    numBuckets = this.boundsMaxY - this.boundsMinY;
-    if (this.edgeBuckets == NULL || this.edgeBucketsSIZE < numBuckets*2+2) {
-        // The last 2 entries are ignored and only used to store unused
-        // values for segments ending on the last line of the bounds
-        // so we can avoid having to check the bounds on this array.
-        this.edgeBuckets = new_int(numBuckets*2 + 2);
-        this.edgeBucketsSIZE = numBuckets*2 + 2;
-    } else {
-        // Only need to fill the first numBuckets*2 entries since the
-        // last 2 entries are write-only for overflow avoidance only.
-        Arrays_fill(this.edgeBuckets, 0, numBuckets*2, 0);
-    }
-    if (this.edges == NULL) {
-        this.edges = new_float(SIZEOF_EDGE * 32);
-        this.edgesSIZE = SIZEOF_EDGE * 32;
-    }
-    this.numEdges = 0;
-    this.pix_sx0 = this.pix_sy0 = this.x0 = this.y0 = 0.0f;
-}
-
-void Renderer_destroy(Renderer *pRenderer) {
-    free(pRenderer->edgeBuckets);
-    pRenderer->edgeBuckets = NULL;
-    pRenderer->edgeBucketsSIZE = 0;
-    free(pRenderer->edges);
-    pRenderer->edges = NULL;
-    pRenderer->edgesSIZE = 0;
-}
-
-static jfloat tosubpixx(jfloat pix_x) {
-    return pix_x * SUBPIXEL_POSITIONS_X;
-}
-static jfloat tosubpixy(jfloat pix_y) {
-    return pix_y * SUBPIXEL_POSITIONS_Y;
-}
-
-static jint Renderer_moveTo(PathConsumer *pRenderer,
-                            jfloat pix_x0, jfloat pix_y0)
-{
-    jint status = Renderer_closePath(pRenderer);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-    this.pix_sx0 = pix_x0;
-    this.pix_sy0 = pix_y0;
-    this.y0 = tosubpixy(pix_y0);
-    this.x0 = tosubpixx(pix_x0);
-    return status;
-}
-
-static jint Renderer_lineTo(PathConsumer *pRenderer,
-                            jfloat pix_x1, jfloat pix_y1)
-{
-    jfloat x1 = tosubpixx(pix_x1);
-    jfloat y1 = tosubpixy(pix_y1);
-    jint status = addLine(pRenderer, this.x0, this.y0, x1, y1);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-    this.x0 = x1;
-    this.y0 = y1;
-    return status;
-}
-
-static jint Renderer_curveTo(PathConsumer *pRenderer,
-                             jfloat x1, jfloat y1,
-                             jfloat x2, jfloat y2,
-                             jfloat x3, jfloat y3)
-{
-    jint status = ERROR_NONE;
-    const jfloat xe = tosubpixx(x3);
-    const jfloat ye = tosubpixy(y3);
-    Curve_setcubic(&this.c,
-                   this.x0, this.y0,
-                   tosubpixx(x1), tosubpixy(y1),
-                   tosubpixx(x2), tosubpixy(y2),
-                   xe, ye);
-    status = curveBreakIntoLinesAndAdd(pRenderer, this.x0, this.y0, this.c, xe, ye);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-    this.x0 = xe;
-    this.y0 = ye;
-    return status;
-}
-
-jint Renderer_quadTo(PathConsumer *pRenderer,
-                     jfloat x1, jfloat y1,
-                     jfloat x2, jfloat y2)
-{
-    jint status = ERROR_NONE;
-    const jfloat xe = tosubpixx(x2);
-    const jfloat ye = tosubpixy(y2);
-    Curve_setquad(&this.c,
-                  this.x0, this.y0,
-                  tosubpixx(x1), tosubpixy(y1),
-                  xe, ye);
-    status = quadBreakIntoLinesAndAdd(pRenderer, this.x0, this.y0, this.c, xe, ye);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-    this.x0 = xe;
-    this.y0 = ye;
-    return status;
-}
-
-static jint Renderer_closePath(PathConsumer *pRenderer) {
-    // lineTo expects its input in pixel coordinates.
-    return Renderer_lineTo(pRenderer, this.pix_sx0, this.pix_sy0);
-}
-
-static jint Renderer_pathDone(PathConsumer *pRenderer) {
-    return Renderer_closePath(pRenderer);
-}
-
-static void setAndClearRelativeAlphas(AlphaConsumer *pAC,
-                                      jint alphaRow[], jint pix_y,
-                                      jint pix_from, jint pix_to);
-
-jint Renderer_produceAlphas(Renderer *pRenderer, AlphaConsumer *pAC) {
-//    ac.setMaxAlpha(MAX_AA_ALPHA);
-
-    // Mask to determine the relevant bit of the crossing sum
-    // 0x1 if EVEN_ODD, all bits if NON_ZERO
-    jint mask = (this.windingRule == WIND_EVEN_ODD) ? 0x1 : ~0x0;
-    jint bboxx0, bboxx1;
-    jint pix_minX, pix_maxX;
-    jint y;
-    ScanlineIterator it;
-
-    // add 2 to better deal with the last pixel in a pixel row.
-    jint width = pAC->width;
-    jint savedAlpha[1024];
-    jint *alpha;
-    if (1024 < width+2) {
-        alpha = new_int(width+2);
-        if (!alpha) {
-            return ERROR_OOM;
-        }
-    } else {
-        alpha = savedAlpha;
-    }
-    Arrays_fill(alpha, 0, width+2, 0);
-
-    bboxx0 = pAC->originX << SUBPIXEL_LG_POSITIONS_X;
-    bboxx1 = bboxx0 + (width << SUBPIXEL_LG_POSITIONS_X);
-
-    // Now we iterate through the scanlines. We must tell emitRow the coord
-    // of the first non-transparent pixel, so we must keep accumulators for
-    // the first and last pixels of the section of the current pixel row
-    // that we will emit.
-    // We also need to accumulate pix_bbox*, but the iterator does it
-    // for us. We will just get the values from it once this loop is done
-    pix_maxX = bboxx1 >> SUBPIXEL_LG_POSITIONS_X;
-    pix_minX = bboxx0 >> SUBPIXEL_LG_POSITIONS_Y;
-
-    y = this.boundsMinY; // needs to be declared here so we emit the last row properly.
-    ScanlineIterator_init(&it, pRenderer);
-    for ( ; ScanlineIterator_hasNext(&it, pRenderer); ) {
-        jint numCrossings = ScanlineIterator_next(&it, pRenderer);
-        jint *crossings = it.crossings;
-        jint sum, prev;
-        jint i;
-
-        if (numCrossings < 0) {
-            ScanlineIterator_destroy(&it);
-            if (alpha != savedAlpha) free (alpha);
-            return ERROR_OOM;
-        }
-
-        y = ScanlineIterator_curY(&it);
-
-        if (numCrossings > 0) {
-            jint lowx = crossings[0] >> 1;
-            jint highx = crossings[numCrossings - 1] >> 1;
-            jint x0 = Math_max(lowx, bboxx0);
-            jint x1 = Math_min(highx, bboxx1);
-
-            pix_minX = Math_min(pix_minX, x0 >> SUBPIXEL_LG_POSITIONS_X);
-            pix_maxX = Math_max(pix_maxX, x1 >> SUBPIXEL_LG_POSITIONS_X);
-        }
-
-        sum = 0;
-        prev = bboxx0;
-        for (i = 0; i < numCrossings; i++) {
-            jint curxo = crossings[i];
-            jint curx = curxo >> 1;
-            jint crorientation = ((curxo & 0x1) << 1) - 1;
-            if ((sum & mask) != 0) {
-                jint x0 = Math_max(prev, bboxx0);
-                jint x1 = Math_min(curx, bboxx1);
-                if (x0 < x1) {
-                    jint pix_x, pix_xmaxm1;
-
-                    x0 -= bboxx0; // turn x0, x1 from coords to indices
-                    x1 -= bboxx0; // in the alpha array.
-
-                    pix_x = x0 >> SUBPIXEL_LG_POSITIONS_X;
-                    pix_xmaxm1 = (x1 - 1) >> SUBPIXEL_LG_POSITIONS_X;
-
-                    if (pix_x == pix_xmaxm1) {
-                        // Start and end in same pixel
-                        alpha[pix_x] += (x1 - x0);
-                        alpha[pix_x+1] -= (x1 - x0);
-                    } else {
-                        jint pix_xmax = x1 >> SUBPIXEL_LG_POSITIONS_X;
-                        alpha[pix_x] += SUBPIXEL_POSITIONS_X - (x0 & SUBPIXEL_MASK_X);
-                        alpha[pix_x+1] += (x0 & SUBPIXEL_MASK_X);
-                        alpha[pix_xmax] -= SUBPIXEL_POSITIONS_X - (x1 & SUBPIXEL_MASK_X);
-                        alpha[pix_xmax+1] -= (x1 & SUBPIXEL_MASK_X);
-                    }
-                }
-            }
-            sum += crorientation;
-            prev = curx;
-        }
-
-        // even if this last row had no crossings, alpha will be zeroed
-        // from the last emitRow call. But this doesn't matter because
-        // maxX < minX, so no row will be emitted to the cache.
-        if ((y & SUBPIXEL_MASK_Y) == SUBPIXEL_MASK_Y) {
-            setAndClearRelativeAlphas(pAC, alpha, y >> SUBPIXEL_LG_POSITIONS_Y,
-                                      pix_minX, pix_maxX);
-            pix_maxX = bboxx1 >> SUBPIXEL_LG_POSITIONS_X;
-            pix_minX = bboxx0 >> SUBPIXEL_LG_POSITIONS_Y;
-        }
-    }
-
-    // Emit final row.
-    // Note, if y is on a MASK row then it was already sent above...
-    if ((y & SUBPIXEL_MASK_Y) < SUBPIXEL_MASK_Y) {
-        setAndClearRelativeAlphas(pAC, alpha, y >> SUBPIXEL_LG_POSITIONS_Y,
-                                  pix_minX, pix_maxX);
-    }
-    ScanlineIterator_destroy(&it);
-    if (alpha != savedAlpha) free (alpha);
-
-    return ERROR_NONE;
-}
-
-//@Override
-static void setMaxAlpha(jint maxalpha) {
-    jint i, altMax;
-    jbyte *altMap;
-
-    // Attempt to reuse either alphaMap or altAlphaMap.
-    // In practice, we should not get here if alphaMap is the right size
-    // due to checks above in our calling chain, but we check for that
-    // condition for completeness.
-    // Also in practice, we only ever have 2 values for maxalpha, but we
-    // protect against running into a 3rd value for maxalpha just in case.
-    if (alphaMap != NULL) {
-        if (maxalpha == alphaMax) {
-            return;
-        }
-        // We will either free the alt values and calculate a new map,
-        // or we will swap them to the main alpha* variables.  In either
-        // case, the main alpha* variables will become the new alt values.
-        altMap = altAlphaMap;
-        altMax = altAlphaMax;
-        altAlphaMap = alphaMap;
-        altAlphaMax = alphaMax;
-        if (altMap != NULL) {
-            if (maxalpha == altMax) {
-                alphaMap = altMap;
-                alphaMax = altMax;
-                return;
-            }
-            free(altMap);
-        }
-        alphaMap = NULL;
-    }
-    // assert alphaMap == NULL
-    alphaMap = malloc(maxalpha+1);
-    alphaMax = maxalpha;
-    for (i = 0; i <= maxalpha; i++) {
-        alphaMap[i] = (jbyte) ((i*255 + maxalpha/2)/maxalpha);
-    }
-}
-
-static void setAndClearRelativeAlphas(AlphaConsumer *pAC,
-                                      jint alphaRow[], jint pix_y,
-                                      jint pix_from, jint pix_to)
-{
-//    System.out.println("setting row "+(pix_y - y)+
-//                       " out of "+width+" x "+height);
-    jint w = pAC->width;
-    jint off = (pix_y - pAC->originY) * w;
-    jbyte *out = pAC->alphas;
-    jint a = 0;
-    jint i;
-    for (i = 0; i < w; i++) {
-        a += alphaRow[i];
-        alphaRow[i] = 0;
-        out[off+i] = alphaMap[a];
-    }
-}
-
-static jint getSubpixMinX(Renderer *pRenderer) {
-    jint sampleColMin = (jint) ceil(this.edgeMinX - 0.5f);
-    if (sampleColMin < this.boundsMinX) sampleColMin = this.boundsMinX;
-    return sampleColMin;
-}
-
-static jint getSubpixMaxX(Renderer *pRenderer) {
-    jint sampleColMax = (jint) ceil(this.edgeMaxX - 0.5f);
-    if (sampleColMax > this.boundsMaxX) sampleColMax = this.boundsMaxX;
-    return sampleColMax;
-}
-
-static jint getSubpixMinY(Renderer *pRenderer) {
-    return this.sampleRowMin;
-}
-
-static jint getSubpixMaxY(Renderer *pRenderer) {
-    return this.sampleRowMax;
-}
-
-static jint getOutpixMinX(Renderer *pRenderer) {
-    return (getSubpixMinX(pRenderer) >> SUBPIXEL_LG_POSITIONS_X);
-}
-
-static jint getOutpixMaxX(Renderer *pRenderer) {
-    return (getSubpixMaxX(pRenderer) + SUBPIXEL_MASK_X) >> SUBPIXEL_LG_POSITIONS_X;
-}
-
-static jint getOutpixMinY(Renderer *pRenderer) {
-    return (this.sampleRowMin >> SUBPIXEL_LG_POSITIONS_Y);
-}
-
-static jint getOutpixMaxY(Renderer *pRenderer) {
-    return (this.sampleRowMax + SUBPIXEL_MASK_Y) >> SUBPIXEL_LG_POSITIONS_Y;
-}
-
-void Renderer_getOutputBounds(Renderer *pRenderer, jint bounds[]) {
-    bounds[0] = getOutpixMinX(pRenderer);
-    bounds[1] = getOutpixMinY(pRenderer);
-    bounds[2] = getOutpixMaxX(pRenderer);
-    bounds[3] = getOutpixMaxY(pRenderer);
-}
diff a/modules/javafx.graphics/src/main/native-prism/Renderer.h b/modules/javafx.graphics/src/main/native-prism/Renderer.h
--- a/modules/javafx.graphics/src/main/native-prism/Renderer.h
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifndef RENDERER_H
-#define RENDERER_H
-
-#include "PathConsumer.h"
-#include "AlphaConsumer.h"
-#include "Curve.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define INIT_CROSSINGS_SIZE   10
-typedef struct {
-    jint *crossings;
-    jint crossingsSIZE;
-    jint *edgePtrs;
-    jint edgePtrsSIZE;
-    jint edgeCount;
-
-    // crossing bounds. The bounds are not necessarily tight (the scan line
-    // at minY, for example, might have no crossings). The x bounds will
-    // be accumulated as crossings are computed.
-    jint nextY;
-} ScanlineIterator;
-
-// common to all types of input path segments.
-#define YMAX         0
-#define CURX         1
-
-// NEXT and OR are meant to be indices into "int" fields, but arrays must
-// be homogenous, so every field is a float. However floats can represent
-// exactly up to 24 bit ints, so we're ok as long as we check for overflow.
-#define OR           2
-#define SLOPE        3
-#define NEXT         4
-#define SIZEOF_EDGE  5
-
-#define MAX_EDGE_IDX (1 << 24)
-
-#define WIND_EVEN_ODD   0
-#define WIND_NON_ZERO   1
-
-#define DEC_BND   1.0f
-#define INC_BND   0.4f
-
-typedef struct {
-    PathConsumer consumer;
-
-    ScanlineIterator iterator;
-
-    jint sampleRowMin;
-    jint sampleRowMax;
-    jfloat edgeMinX;
-    jfloat edgeMaxX;
-
-    jfloat *edges;
-    jint edgesSIZE;
-    jint *edgeBuckets;
-    jint edgeBucketsSIZE;
-    jint numEdges;
-
-    // Bounds of the drawing region, at subpixel precision.
-    jint boundsMinX, boundsMinY, boundsMaxX, boundsMaxY;
-
-    // Current winding rule
-    jint windingRule;
-
-    // Current drawing position, i.e., final point of last segment
-    jfloat x0, y0;
-
-    // Position of most recent 'moveTo' command
-    jfloat pix_sx0, pix_sy0;
-
-    Curve c;
-} Renderer;
-
-extern void Renderer_setup(jint subpixelLgPositionsX, jint subpixelLgPositionsY);
-
-extern void Renderer_init(Renderer *pRenderer);
-
-extern void Renderer_reset(Renderer *pRenderer,
-                           jint pix_boundsX, jint pix_boundsY,
-                           jint pix_boundsWidth, jint pix_boundsHeight,
-                           jint windingRule);
-
-extern void Renderer_destroy(Renderer *pRenderer);
-
-extern void Renderer_getOutputBounds(Renderer *pRenderer, jint bounds[]);
-
-extern jint Renderer_produceAlphas(Renderer *pRenderer, AlphaConsumer *pAC);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* RENDERER_H */
-
diff a/modules/javafx.graphics/src/main/native-prism/Stroker.c b/modules/javafx.graphics/src/main/native-prism/Stroker.c
--- a/modules/javafx.graphics/src/main/native-prism/Stroker.c
+++ /dev/null
@@ -1,1587 +0,0 @@
-/*
- * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-#include <jni.h>
-
-#include "Helpers.h"
-#include "PathConsumer.h"
-
-#include "Stroker.h"
-
-// NOTE: some of the arithmetic here is too verbose and prone to hard to
-// debug typos. We should consider making a small Point/Vector class that
-// has methods like plus(Point), minus(Point), dot(Point), cross(Point)and such
-//public final class Stroker implements PathConsumer2D {
-
-#define MOVE_TO  0
-#define DRAWING_OP_TO  1 // ie. curve, line, or quad
-#define CLOSE  2
-
-static MoveToFunc       Stroker_moveTo;
-static LineToFunc       Stroker_lineTo;
-static QuadToFunc       Stroker_quadTo;
-static CurveToFunc      Stroker_curveTo;
-static ClosePathFunc    Stroker_closePath;
-static PathDoneFunc     Stroker_pathDone;
-
-#define this (*((Stroker *) pStroker))
-
-static jint drawJoin(PathConsumer *pStroker,
-                     jfloat pdx, jfloat pdy,
-                     jfloat x0, jfloat y0,
-                     jfloat dx, jfloat dy,
-                     jfloat omx, jfloat omy,
-                     jfloat mx, jfloat my);
-
-static jint drawRoundJoin2(PathConsumer *pStroker,
-                           jfloat cx, jfloat cy,
-                           jfloat omx, jfloat omy,
-                           jfloat mx, jfloat my,
-                           jboolean rev);
-
-static jint drawBezApproxForArc(PathConsumer *pStroker,
-                                const jfloat cx, const jfloat cy,
-                                const jfloat omx, const jfloat omy,
-                                const jfloat mx, const jfloat my,
-                                jboolean rev);
-
-static jint emitMoveTo(PathConsumer *pStroker, const jfloat x0, const jfloat y0);
-
-static jint emitLineTo(PathConsumer *pStroker, const jfloat x1, const jfloat y1,
-                       const jboolean rev);
-
-static jint emitCurveTo(PathConsumer *pStroker,
-                        const jfloat x0, const jfloat y0,
-                        const jfloat x1, const jfloat y1,
-                        const jfloat x2, const jfloat y2,
-                        const jfloat x3, const jfloat y3, const jboolean rev);
-
-static jint emitClose(PathConsumer *pStroker);
-
-static jint emitReverse(PathConsumer *pStroker);
-
-static jint finish(PathConsumer *pStroker);
-
-extern void PolyStack_init(PolyStack *pStack);
-
-extern void PolyStack_destroy(PolyStack *pStack);
-
-extern jboolean PolyStack_isEmpty(PolyStack *pStack);
-
-extern jint PolyStack_pushLine(PolyStack *pStack,
-                               jfloat x, jfloat y);
-
-extern jint PolyStack_pushCubic(PolyStack *pStack,
-                                jfloat x0, jfloat y0,
-                                jfloat x1, jfloat y1,
-                                jfloat x2, jfloat y2);
-
-extern jint PolyStack_pushQuad(PolyStack *pStack,
-                               jfloat x0, jfloat y0,
-                               jfloat x1, jfloat y1);
-
-extern jint PolyStack_pop(PolyStack *pStack, PathConsumer *io);
-
-    /**
-     * Constructs a <code>Stroker</code>.
-     *
-     * @param pc2d an output <code>PathConsumer2D</code>.
-     * @param lineWidth the desired line width in pixels
-     * @param capStyle the desired end cap style, one of
-     * <code>CAP_BUTT</code>, <code>CAP_ROUND</code> or
-     * <code>CAP_SQUARE</code>.
-     * @param joinStyle the desired line join style, one of
-     * <code>JOIN_MITER</code>, <code>JOIN_ROUND</code> or
-     * <code>JOIN_BEVEL</code>.
-     * @param miterLimit the desired miter limit
-    public Stroker(PathConsumer2D pc2d,
-                   float lineWidth,
-                   jint capStyle,
-                   jint joinStyle,
-                   float miterLimit)
-    {
-        this(pc2d);
-
-        reset(lineWidth, capStyle, joinStyle, miterLimit);
-    }
-
-    public Stroker(PathConsumer2D pc2d) {
-        setConsumer(pc2d);
-    }
-
-    public void setConsumer(PathConsumer2D pc2d) {
-        this.out = pc2d;
-    }
-     */
-
-extern void Stroker_reset(Stroker *pStroker, jfloat lineWidth,
-                          jint capStyle, jint joinStyle, jfloat miterLimit);
-
-void Stroker_init(Stroker *pStroker,
-                  PathConsumer *out,
-                  jfloat lineWidth,
-                  jint capStyle,
-                  jint joinStyle,
-                  jfloat miterLimit)
-{
-    memset(pStroker, 0, sizeof(Stroker));
-    PathConsumer_init(&this.consumer,
-                      Stroker_moveTo,
-                      Stroker_lineTo,
-                      Stroker_quadTo,
-                      Stroker_curveTo,
-                      Stroker_closePath,
-                      Stroker_pathDone);
-
-    this.out = out;
-    Stroker_reset(pStroker, lineWidth, capStyle, joinStyle, miterLimit);
-    PolyStack_init(&pStroker->reverse);
-}
-
-void Stroker_reset(Stroker *pStroker, jfloat lineWidth,
-                   jint capStyle, jint joinStyle, jfloat miterLimit)
-{
-    jfloat limit;
-
-    this.lineWidth2 = lineWidth / 2;
-    this.capStyle = capStyle;
-    this.joinStyle = joinStyle;
-
-    limit = miterLimit * this.lineWidth2;
-    this.miterLimitSq = limit*limit;
-
-    this.prev = CLOSE;
-}
-
-void Stroker_destroy(Stroker *pStroker) {
-    PolyStack_destroy(&pStroker->reverse);
-}
-
-void computeOffset(const jfloat lx, const jfloat ly,
-                   const jfloat w, jfloat m[])
-{
-    const jfloat len = (jfloat) sqrt(lx*lx + ly*ly);
-    if (len == 0) {
-        m[0] = m[1] = 0;
-    } else {
-        m[0] = (ly * w)/len;
-        m[1] = -(lx * w)/len;
-    }
-}
-
-// Returns true if the vectors (dx1, dy1) and (dx2, dy2) are
-// clockwise (if dx1,dy1 needs to be rotated clockwise to close
-// the smallest angle between it and dx2,dy2).
-// This is equivalent to detecting whether a point q is on the right side
-// of a line passing through points p1, p2 where p2 = p1+(dx1,dy1) and
-// q = p2+(dx2,dy2), which is the same as saying p1, p2, q are in a
-// clockwise order.
-// NOTE: "clockwise" here assumes coordinates with 0,0 at the bottom left.
-static jboolean isCW(const jfloat dx1, const jfloat dy1,
-                     const jfloat dx2, const jfloat dy2)
-{
-    return dx1 * dy2 <= dy1 * dx2;
-}
-
-// pisces used to use fixed point arithmetic with 16 decimal digits. I
-// didn't want to change the values of the constant below when I converted
-// it to floating point, so that's why the divisions by 2^16 are there.
-#define ROUND_JOIN_THRESHOLD   (1000/65536.0f)
-
-static jint drawRoundJoin(PathConsumer *pStroker,
-                          jfloat x, jfloat y,
-                          jfloat omx, jfloat omy, jfloat mx, jfloat my,
-                          jboolean rev,
-                          jfloat threshold)
-{
-    jfloat domx, domy, len;
-
-    if ((omx == 0 && omy == 0) || (mx == 0 && my == 0)) {
-        return ERROR_NONE;
-    }
-
-    domx = omx - mx;
-    domy = omy - my;
-    len = domx*domx + domy*domy;
-    if (len < threshold) {
-        return ERROR_NONE;
-    }
-
-    if (rev) {
-        omx = -omx;
-        omy = -omy;
-        mx = -mx;
-        my = -my;
-    }
-    return drawRoundJoin2(pStroker, x, y, omx, omy, mx, my, rev);
-}
-
-static jint drawRoundJoin2(PathConsumer *pStroker,
-                           jfloat cx, jfloat cy,
-                           jfloat omx, jfloat omy,
-                           jfloat mx, jfloat my,
-                           jboolean rev)
-{
-    jint status = ERROR_NONE;
-
-    // The sign of the dot product of mx,my and omx,omy is equal to the
-    // the sign of the cosine of ext
-    // (ext is the angle between omx,omy and mx,my).
-    jdouble cosext = omx * mx + omy * my;
-    // If it is >=0, we know that abs(ext) is <= 90 degrees, so we only
-    // need 1 curve to approximate the circle section that joins omx,omy
-    // and mx,my.
-    const jint numCurves = cosext >= 0 ? 1 : 2;
-
-    switch (numCurves) {
-    case 1:
-        status = drawBezApproxForArc(pStroker, cx, cy, omx, omy, mx, my, rev);
-        break;
-    case 2:
-        {
-            // we need to split the arc into 2 arcs spanning the same angle.
-            // The point we want will be one of the 2 intersections of the
-            // perpendicular bisector of the chord (omx,omy)->(mx,my) and the
-            // circle. We could find this by scaling the vector
-            // (omx+mx, omy+my)/2 so that it has length=lineWidth2 (and thus lies
-            // on the circle), but that can have numerical problems when the angle
-            // between omx,omy and mx,my is close to 180 degrees. So we compute a
-            // normal of (omx,omy)-(mx,my). This will be the direction of the
-            // perpendicular bisector. To get one of the intersections, we just scale
-            // this vector that its length is lineWidth2 (this works because the
-            // perpendicular bisector goes through the origin). This scaling doesn't
-            // have numerical problems because we know that lineWidth2 divided by
-            // this normal's length is at least 0.5 and at most sqrt(2)/2 (because
-            // we know the angle of the arc is > 90 degrees).
-            jfloat nx = my - omy, ny = omx - mx;
-            jfloat nlen = (jfloat) sqrt(nx*nx + ny*ny);
-            jfloat scale = this.lineWidth2/nlen;
-            jfloat mmx = nx * scale, mmy = ny * scale;
-
-            // if (isCW(omx, omy, mx, my) != isCW(mmx, mmy, mx, my)) then we've
-            // computed the wrong intersection so we get the other one.
-            // The test above is equivalent to if (rev).
-            if (rev) {
-                mmx = -mmx;
-                mmy = -mmy;
-            }
-            status = drawBezApproxForArc(pStroker, cx, cy, omx, omy, mmx, mmy, rev);
-            if (status != ERROR_NONE) {
-                return status;
-            }
-            status = drawBezApproxForArc(pStroker, cx, cy, mmx, mmy, mx, my, rev);
-            break;
-        }
-    }
-    return status;
-}
-
-// the input arc defined by omx,omy and mx,my must span <= 90 degrees.
-static jint drawBezApproxForArc(PathConsumer *pStroker,
-                                const jfloat cx, const jfloat cy,
-                                const jfloat omx, const jfloat omy,
-                                const jfloat mx, const jfloat my,
-                                jboolean rev)
-{
-    jfloat cosext2 = (omx * mx + omy * my) / (2 * this.lineWidth2 * this.lineWidth2);
-    // cv is the length of P1-P0 and P2-P3 divided by the radius of the arc
-    // (so, cv assumes the arc has radius 1). P0, P1, P2, P3 are the points that
-    // define the bezier curve we're computing.
-    // It is computed using the constraints that P1-P0 and P3-P2 are parallel
-    // to the arc tangents at the endpoints, and that |P1-P0|=|P3-P2|.
-    jfloat cv = (jfloat) ((4.0 / 3.0) * sqrt(0.5-cosext2) /
-                          (1.0 + sqrt(cosext2+0.5)));
-    jfloat x1, y1, x2, y2, x3, y3, x4, y4;
-
-    // if clockwise, we need to negate cv.
-    if (rev) { // rev is equivalent to isCW(omx, omy, mx, my)
-        cv = -cv;
-    }
-    x1 = cx + omx;
-    y1 = cy + omy;
-    x2 = x1 - cv * omy;
-    y2 = y1 + cv * omx;
-
-    x4 = cx + mx;
-    y4 = cy + my;
-    x3 = x4 + cv * my;
-    y3 = y4 - cv * mx;
-
-    return emitCurveTo(pStroker, x1, y1, x2, y2, x3, y3, x4, y4, rev);
-}
-
-static jint drawRoundCap(PathConsumer *pStroker, jfloat cx, jfloat cy, jfloat mx, jfloat my) {
-    jint status = ERROR_NONE;
-    const jfloat C = 0.5522847498307933f;
-    // the first and second arguments of the following two calls
-    // are really will be ignored by emitCurveTo (because of the false),
-    // but we put them in anyway, as opposed to just giving it 4 zeroes,
-    // because it's just 4 additions and it's not good to rely on this
-    // sort of assumption (right now it's true, but that may change).
-    status = emitCurveTo(pStroker,
-                cx+mx,      cy+my,
-                cx+mx-C*my, cy+my+C*mx,
-                cx-my+C*mx, cy+mx+C*my,
-                cx-my,      cy+mx,
-                JNI_FALSE);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-    status = emitCurveTo(pStroker,
-                cx-my,      cy+mx,
-                cx-my-C*mx, cy+mx-C*my,
-                cx-mx-C*my, cy-my+C*mx,
-                cx-mx,      cy-my,
-                JNI_FALSE);
-    return status;
-}
-
-// Return the intersection point of the lines (x0, y0) -> (x1, y1)
-// and (x0p, y0p) -> (x1p, y1p) in m[0] and m[1]
-static void computeMiter(const jfloat x0, const jfloat y0,
-                         const jfloat x1, const jfloat y1,
-                         const jfloat x0p, const jfloat y0p,
-                         const jfloat x1p, const jfloat y1p,
-                         jfloat m[], jint off)
-{
-    jfloat x10 = x1 - x0;
-    jfloat y10 = y1 - y0;
-    jfloat x10p = x1p - x0p;
-    jfloat y10p = y1p - y0p;
-
-    // if this is 0, the lines are parallel. If they go in the
-    // same direction, there is no intersection so m[off] and
-    // m[off+1] will contain infinity, so no miter will be drawn.
-    // If they go in the same direction that means that the start of the
-    // current segment and the end of the previous segment have the same
-    // tangent, in which case this method won't even be involved in
-    // miter drawing because it won't be called by drawMiter (because
-    // (mx == omx && my == omy) will be true, and drawMiter will return
-    // immediately).
-    jfloat den = x10*y10p - x10p*y10;
-    jfloat t = x10p*(y0-y0p) - y10p*(x0-x0p);
-    t /= den;
-    m[off++] = x0 + t*x10;
-    m[off] = y0 + t*y10;
-}
-
-// Return the intersection point of the lines (x0, y0) -> (x1, y1)
-// and (x0p, y0p) -> (x1p, y1p) in m[0] and m[1]
-static void safecomputeMiter(const jfloat x0, const jfloat y0,
-                             const jfloat x1, const jfloat y1,
-                             const jfloat x0p, const jfloat y0p,
-                             const jfloat x1p, const jfloat y1p,
-                             jfloat m[], jint off)
-{
-    jfloat x10 = x1 - x0;
-    jfloat y10 = y1 - y0;
-    jfloat x10p = x1p - x0p;
-    jfloat y10p = y1p - y0p;
-
-    // if this is 0, the lines are parallel. If they go in the
-    // same direction, there is no intersection so m[off] and
-    // m[off+1] will contain infinity, so no miter will be drawn.
-    // If they go in the same direction that means that the start of the
-    // current segment and the end of the previous segment have the same
-    // tangent, in which case this method won't even be involved in
-    // miter drawing because it won't be called by drawMiter (because
-    // (mx == omx && my == omy) will be true, and drawMiter will return
-    // immediately).
-    jfloat den = x10*y10p - x10p*y10;
-    jfloat t;
-
-    if (den == 0) {
-        m[off++] = (x0 + x0p) / 2.0f;
-        m[off] = (y0 + y0p) / 2.0f;
-        return;
-    }
-    t = x10p*(y0-y0p) - y10p*(x0-x0p);
-    t /= den;
-    m[off++] = x0 + t*x10;
-    m[off] = y0 + t*y10;
-}
-
-static jint drawMiter(PathConsumer *pStroker,
-                      const jfloat pdx, const jfloat pdy,
-                      const jfloat x0, const jfloat y0,
-                      const jfloat dx, const jfloat dy,
-                      jfloat omx, jfloat omy, jfloat mx, jfloat my,
-                      jboolean rev)
-{
-    jfloat lenSq;
-
-    if ((mx == omx && my == omy) ||
-        (pdx == 0 && pdy == 0) ||
-        (dx == 0 && dy == 0)) {
-        return ERROR_NONE;
-    }
-
-    if (rev) {
-        omx = -omx;
-        omy = -omy;
-        mx = -mx;
-        my = -my;
-    }
-
-    computeMiter((x0 - pdx) + omx, (y0 - pdy) + omy, x0 + omx, y0 + omy,
-                 (dx + x0) + mx, (dy + y0) + my, x0 + mx, y0 + my,
-                 this.miter, 0);
-
-    lenSq = (this.miter[0]-x0)*(this.miter[0]-x0) + (this.miter[1]-y0)*(this.miter[1]-y0);
-
-    if (lenSq < this.miterLimitSq) {
-        return emitLineTo(pStroker, this.miter[0], this.miter[1], rev);
-    }
-    return ERROR_NONE;
-}
-
-static jint Stroker_moveTo(PathConsumer *pStroker, jfloat x0, jfloat y0) {
-    jint status = ERROR_NONE;
-    if (this.prev == DRAWING_OP_TO) {
-        status = finish(pStroker);
-        if (status != ERROR_NONE) {
-            return status;
-        }
-    }
-    this.sx0 = this.cx0 = x0;
-    this.sy0 = this.cy0 = y0;
-    this.cdx = this.sdx = 1;
-    this.cdy = this.sdy = 0;
-    this.prev = MOVE_TO;
-    return status;
-}
-
-static jint Stroker_lineTo(PathConsumer *pStroker, jfloat x1, jfloat y1) {
-    jint status = ERROR_NONE;
-    jfloat dx = x1 - this.cx0;
-    jfloat dy = y1 - this.cy0;
-    jfloat mx, my;
-
-    if (dx == 0.0f && dy == 0.0f) {
-        dx = 1;
-    }
-    computeOffset(dx, dy, this.lineWidth2, this.offset[0]);
-    mx = this.offset[0][0];
-    my = this.offset[0][1];
-
-    status = drawJoin(pStroker,
-             this.cdx, this.cdy, this.cx0, this.cy0,
-             dx, dy, this.cmx, this.cmy, mx, my);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-
-    status = emitLineTo(pStroker, this.cx0 + mx, this.cy0 + my, JNI_FALSE);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-    status = emitLineTo(pStroker, x1 + mx, y1 + my, JNI_FALSE);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-
-    status = emitLineTo(pStroker, this.cx0 - mx, this.cy0 - my, JNI_TRUE);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-    status = emitLineTo(pStroker, x1 - mx, y1 - my, JNI_TRUE);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-
-    this.cmx = mx;
-    this.cmy = my;
-    this.cdx = dx;
-    this.cdy = dy;
-    this.cx0 = x1;
-    this.cy0 = y1;
-    this.prev = DRAWING_OP_TO;
-    return status;
-}
-
-static jint Stroker_closePath(PathConsumer *pStroker) {
-    jint status = ERROR_NONE;
-    if (this.prev != DRAWING_OP_TO) {
-        if (this.prev == CLOSE) {
-            return status;
-        }
-        status = emitMoveTo(pStroker, this.cx0, this.cy0 - this.lineWidth2);
-        if (status != ERROR_NONE) {
-            return status;
-        }
-        this.cmx = this.smx = 0;
-        this.cmy = this.smy = -this.lineWidth2;
-        this.cdx = this.sdx = 1;
-        this.cdy = this.sdy = 0;
-        return finish(pStroker);
-    }
-
-    if (this.cx0 != this.sx0 || this.cy0 != this.sy0) {
-        status = Stroker_lineTo(pStroker, this.sx0, this.sy0);
-        if (status != ERROR_NONE) {
-            return status;
-        }
-    }
-
-    status = drawJoin(pStroker,
-             this.cdx, this.cdy, this.cx0, this.cy0,
-             this.sdx, this.sdy, this.cmx, this.cmy,
-             this.smx, this.smy);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-
-    status = emitLineTo(pStroker, this.sx0 + this.smx, this.sy0 + this.smy, JNI_FALSE);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-
-    status = emitMoveTo(pStroker, this.sx0 - this.smx, this.sy0 - this.smy);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-    status = emitReverse(pStroker);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-
-    this.prev = CLOSE;
-    return emitClose(pStroker);
-}
-
-static jint emitReverse(PathConsumer *pStroker) {
-    jint status = ERROR_NONE;
-    while (!PolyStack_isEmpty(&this.reverse)) {
-        status = PolyStack_pop(&this.reverse, this.out);
-        if (status != ERROR_NONE) {
-            return status;
-        }
-    }
-    return status;
-}
-
-static jint Stroker_pathDone(PathConsumer *pStroker) {
-    jint status = ERROR_NONE;
-    if (this.prev == DRAWING_OP_TO) {
-        status = finish(pStroker);
-        if (status != ERROR_NONE) {
-            return status;
-        }
-    }
-
-    status = this.out->pathDone(this.out);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-    // this shouldn't matter since this object won't be used
-    // after the call to this method.
-    this.prev = CLOSE;
-    return status;
-}
-
-static jint finish(PathConsumer *pStroker) {
-    jint status = ERROR_NONE;
-    if (this.capStyle == CAP_ROUND) {
-        status = drawRoundCap(pStroker, this.cx0, this.cy0, this.cmx, this.cmy);
-        if (status != ERROR_NONE) {
-            return status;
-        }
-    } else if (this.capStyle == CAP_SQUARE) {
-        status = emitLineTo(pStroker, this.cx0 - this.cmy + this.cmx, this.cy0 + this.cmx + this.cmy, JNI_FALSE);
-        if (status != ERROR_NONE) {
-            return status;
-        }
-        status = emitLineTo(pStroker, this.cx0 - this.cmy - this.cmx, this.cy0 + this.cmx - this.cmy, JNI_FALSE);
-        if (status != ERROR_NONE) {
-            return status;
-        }
-    }
-
-    status = emitReverse(pStroker);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-
-    if (this.capStyle == CAP_ROUND) {
-        status = drawRoundCap(pStroker, this.sx0, this.sy0, -this.smx, -this.smy);
-        if (status != ERROR_NONE) {
-            return status;
-        }
-    } else if (this.capStyle == CAP_SQUARE) {
-        status = emitLineTo(pStroker, this.sx0 + this.smy - this.smx, this.sy0 - this.smx - this.smy, JNI_FALSE);
-        if (status != ERROR_NONE) {
-            return status;
-        }
-        status = emitLineTo(pStroker, this.sx0 + this.smy + this.smx, this.sy0 - this.smx + this.smy, JNI_FALSE);
-        if (status != ERROR_NONE) {
-            return status;
-        }
-    }
-
-    return emitClose(pStroker);
-}
-
-static jint emitMoveTo(PathConsumer *pStroker, const jfloat x0, const jfloat y0) {
-    return this.out->moveTo(this.out, x0, y0);
-}
-
-static jint emitLineTo(PathConsumer *pStroker, const jfloat x1, const jfloat y1,
-                       const jboolean rev)
-{
-    if (rev) {
-        return PolyStack_pushLine(&this.reverse, x1, y1);
-    } else {
-        return this.out->lineTo(this.out, x1, y1);
-    }
-}
-
-static jint emitQuadTo(PathConsumer *pStroker,
-                       const jfloat x0, const jfloat y0,
-                       const jfloat x1, const jfloat y1,
-                       const jfloat x2, const jfloat y2, const jboolean rev)
-{
-    if (rev) {
-        return PolyStack_pushQuad(&this.reverse, x0, y0, x1, y1);
-    } else {
-        return this.out->quadTo(this.out, x1, y1, x2, y2);
-    }
-}
-
-static jint emitCurveTo(PathConsumer *pStroker,
-                        const jfloat x0, const jfloat y0,
-                        const jfloat x1, const jfloat y1,
-                        const jfloat x2, const jfloat y2,
-                        const jfloat x3, const jfloat y3, const jboolean rev)
-{
-    if (rev) {
-        return PolyStack_pushCubic(&this.reverse, x0, y0, x1, y1, x2, y2);
-    } else {
-        return this.out->curveTo(this.out, x1, y1, x2, y2, x3, y3);
-    }
-}
-
-static jint emitClose(PathConsumer *pStroker) {
-    return this.out->closePath(this.out);
-}
-
-static jint drawJoin(PathConsumer *pStroker,
-                     jfloat pdx, jfloat pdy,
-                     jfloat x0, jfloat y0,
-                     jfloat dx, jfloat dy,
-                     jfloat omx, jfloat omy,
-                     jfloat mx, jfloat my)
-{
-    jint status = ERROR_NONE;
-    if (this.prev != DRAWING_OP_TO) {
-        status = emitMoveTo(pStroker, x0 + mx, y0 + my);
-        if (status != ERROR_NONE) {
-            return status;
-        }
-        this.sdx = dx;
-        this.sdy = dy;
-        this.smx = mx;
-        this.smy = my;
-    } else {
-        jboolean cw = isCW(pdx, pdy, dx, dy);
-        if (this.joinStyle == JOIN_MITER) {
-            status = drawMiter(pStroker, pdx, pdy, x0, y0, dx, dy, omx, omy, mx, my, cw);
-            if (status != ERROR_NONE) {
-                return status;
-            }
-        } else if (this.joinStyle == JOIN_ROUND) {
-            status = drawRoundJoin(pStroker,
-                          x0, y0,
-                          omx, omy,
-                          mx, my, cw,
-                          ROUND_JOIN_THRESHOLD);
-            if (status != ERROR_NONE) {
-                return status;
-            }
-        }
-        status = emitLineTo(pStroker, x0, y0, !cw);
-        if (status != ERROR_NONE) {
-            return status;
-        }
-    }
-    this.prev = DRAWING_OP_TO;
-    return status;
-}
-
-static jboolean withinULP(const jfloat x1, const jfloat y1,
-                          const jfloat x2, const jfloat y2,
-                          const int maxUlps)
-{
-//    assert maxUlps is much smaller than 0x7fffffff;
-    // compare taxicab distance. ERR will always be small, so using
-    // true distance won't give much benefit
-    return (Helpers_withinULP(x1, x2, maxUlps) &&
-            Helpers_withinULP(y1, y2, maxUlps));
-}
-
-static void getLineOffsets(PathConsumer *pStroker,
-                           jfloat x1, jfloat y1,
-                           jfloat x2, jfloat y2,
-                           jfloat left[], jfloat right[]) {
-    computeOffset(x2 - x1, y2 - y1, this.lineWidth2, this.offset[0]);
-    left[0] = x1 + this.offset[0][0];
-    left[1] = y1 + this.offset[0][1];
-    left[2] = x2 + this.offset[0][0];
-    left[3] = y2 + this.offset[0][1];
-    right[0] = x1 - this.offset[0][0];
-    right[1] = y1 - this.offset[0][1];
-    right[2] = x2 - this.offset[0][0];
-    right[3] = y2 - this.offset[0][1];
-}
-
-static jint computeOffsetCubic(PathConsumer *pStroker,
-                               jfloat pts[], const jint off,
-                               jfloat leftOff[], jfloat rightOff[])
-{
-    jfloat dotsq, l1sq, l4sq;
-    jfloat x, y, dxm, dym;
-
-    // if p1=p2 or p3=p4 it means that the derivative at the endpoint
-    // vanishes, which creates problems with computeOffset. Usually
-    // this happens when this stroker object is trying to winden
-    // a curve with a cusp. What happens is that curveTo splits
-    // the input curve at the cusp, and passes it to this function.
-    // because of inaccuracies in the splitting, we consider points
-    // equal if they're very close to each other.
-    const jfloat x1 = pts[off + 0], y1 = pts[off + 1];
-    const jfloat x2 = pts[off + 2], y2 = pts[off + 3];
-    const jfloat x3 = pts[off + 4], y3 = pts[off + 5];
-    const jfloat x4 = pts[off + 6], y4 = pts[off + 7];
-
-    jfloat dx4 = x4 - x3;
-    jfloat dy4 = y4 - y3;
-    jfloat dx1 = x2 - x1;
-    jfloat dy1 = y2 - y1;
-
-    // if p1 == p2 && p3 == p4: draw line from p1->p4, unless p1 == p4,
-    // in which case ignore if p1 == p2
-    const jboolean p1eqp2 = withinULP(x1,y1,x2,y2, 6);
-    const jboolean p3eqp4 = withinULP(x3,y3,x4,y4, 6);
-    if (p1eqp2 && p3eqp4) {
-        getLineOffsets(pStroker, x1, y1, x4, y4, leftOff, rightOff);
-        return 4;
-    } else if (p1eqp2) {
-        dx1 = x3 - x1;
-        dy1 = y3 - y1;
-    } else if (p3eqp4) {
-        dx4 = x4 - x2;
-        dy4 = y4 - y2;
-    }
-
-    // if p2-p1 and p4-p3 are parallel, that must mean this curve is a line
-    dotsq = (dx1 * dx4 + dy1 * dy4);
-    dotsq = dotsq * dotsq;
-    l1sq = dx1 * dx1 + dy1 * dy1;
-    l4sq = dx4 * dx4 + dy4 * dy4;
-    if (Helpers_withinULP(dotsq, l1sq * l4sq, 4)) {
-        getLineOffsets(pStroker, x1, y1, x4, y4, leftOff, rightOff);
-        return 4;
-    }
-
-//      What we're trying to do in this function is to approximate an ideal
-//      offset curve (call it I) of the input curve B using a bezier curve Bp.
-//      The constraints I use to get the equations are:
-//
-//      1. The computed curve Bp should go through I(0) and I(1). These are
-//      x1p, y1p, x4p, y4p, which are p1p and p4p. We still need to find
-//      4 variables: the x and y components of p2p and p3p (i.e. x2p, y2p, x3p, y3p).
-//
-//      2. Bp should have slope equal in absolute value to I at the endpoints. So,
-//      (by the way, the operator || in the comments below means "aligned with".
-//      It is defined on vectors, so when we say I'(0) || Bp'(0) we mean that
-//      vectors I'(0) and Bp'(0) are aligned, which is the same as saying
-//      that the tangent lines of I and Bp at 0 are parallel. Mathematically
-//      this means (I'(t) || Bp'(t)) <==> (I'(t) = c * Bp'(t)) where c is some
-//      nonzero constant.)
-//      I'(0) || Bp'(0) and I'(1) || Bp'(1). Obviously, I'(0) || B'(0) and
-//      I'(1) || B'(1); therefore, Bp'(0) || B'(0) and Bp'(1) || B'(1).
-//      We know that Bp'(0) || (p2p-p1p) and Bp'(1) || (p4p-p3p) and the same
-//      is true for any bezier curve; therefore, we get the equations
-//          (1) p2p = c1 * (p2-p1) + p1p
-//          (2) p3p = c2 * (p4-p3) + p4p
-//      We know p1p, p4p, p2, p1, p3, and p4; therefore, this reduces the number
-//      of unknowns from 4 to 2 (i.e. just c1 and c2).
-//      To eliminate these 2 unknowns we use the following constraint:
-//
-//      3. Bp(0.5) == I(0.5). Bp(0.5)=(x,y) and I(0.5)=(xi,yi), and I should note
-//      that I(0.5) is *the only* reason for computing dxm,dym. This gives us
-//          (3) Bp(0.5) = (p1p + 3 * (p2p + p3p) + p4p)/8, which is equivalent to
-//          (4) p2p + p3p = (Bp(0.5)*8 - p1p - p4p) / 3
-//      We can substitute (1) and (2) from above into (4) and we get:
-//          (5) c1*(p2-p1) + c2*(p4-p3) = (Bp(0.5)*8 - p1p - p4p)/3 - p1p - p4p
-//      which is equivalent to
-//          (6) c1*(p2-p1) + c2*(p4-p3) = (4/3) * (Bp(0.5) * 2 - p1p - p4p)
-//
-//      The right side of this is a 2D vector, and we know I(0.5), which gives us
-//      Bp(0.5), which gives us the value of the right side.
-//      The left side is just a matrix vector multiplication in disguise. It is
-//
-//      [x2-x1, x4-x3][c1]
-//      [y2-y1, y4-y3][c2]
-//      which, is equal to
-//      [dx1, dx4][c1]
-//      [dy1, dy4][c2]
-//      At this point we are left with a simple linear system and we solve it by
-//      getting the inverse of the matrix above. Then we use [c1,c2] to compute
-//      p2p and p3p.
-
-    x = 0.125f * (x1 + 3 * (x2 + x3) + x4);
-    y = 0.125f * (y1 + 3 * (y2 + y3) + y4);
-    // (dxm,dym) is some tangent of B at t=0.5. This means it's equal to
-    // c*B'(0.5) for some constant c.
-    dxm = x3 + x4 - x1 - x2;
-    dym = y3 + y4 - y1 - y2;
-
-    // this computes the offsets at t=0, 0.5, 1, using the property that
-    // for any bezier curve the vectors p2-p1 and p4-p3 are parallel to
-    // the (dx/dt, dy/dt) vectors at the endpoints.
-    computeOffset(dx1, dy1, this.lineWidth2, this.offset[0]);
-    computeOffset(dxm, dym, this.lineWidth2, this.offset[1]);
-    computeOffset(dx4, dy4, this.lineWidth2, this.offset[2]);
-    {
-        jfloat x1p = x1 + this.offset[0][0]; // start
-        jfloat y1p = y1 + this.offset[0][1]; // point
-        jfloat xi  = x  + this.offset[1][0]; // interpolation
-        jfloat yi  = y  + this.offset[1][1]; // point
-        jfloat x4p = x4 + this.offset[2][0]; // end
-        jfloat y4p = y4 + this.offset[2][1]; // point
-
-        jfloat invdet43 = 4.0f / (3.0f * (dx1 * dy4 - dy1 * dx4));
-
-        jfloat two_pi_m_p1_m_p4x = 2*xi - x1p - x4p;
-        jfloat two_pi_m_p1_m_p4y = 2*yi - y1p - y4p;
-        jfloat c1 = invdet43 * (dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y);
-        jfloat c2 = invdet43 * (dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x);
-
-        jfloat x2p, y2p, x3p, y3p;
-        x2p = x1p + c1*dx1;
-        y2p = y1p + c1*dy1;
-        x3p = x4p + c2*dx4;
-        y3p = y4p + c2*dy4;
-
-        leftOff[0] = x1p; leftOff[1] = y1p;
-        leftOff[2] = x2p; leftOff[3] = y2p;
-        leftOff[4] = x3p; leftOff[5] = y3p;
-        leftOff[6] = x4p; leftOff[7] = y4p;
-
-        x1p = x1 -     this.offset[0][0]; y1p = y1 -     this.offset[0][1];
-        xi  = xi - 2 * this.offset[1][0]; yi  = yi - 2 * this.offset[1][1];
-        x4p = x4 -     this.offset[2][0]; y4p = y4 -     this.offset[2][1];
-
-        two_pi_m_p1_m_p4x = 2*xi - x1p - x4p;
-        two_pi_m_p1_m_p4y = 2*yi - y1p - y4p;
-        c1 = invdet43 * (dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y);
-        c2 = invdet43 * (dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x);
-
-        x2p = x1p + c1*dx1;
-        y2p = y1p + c1*dy1;
-        x3p = x4p + c2*dx4;
-        y3p = y4p + c2*dy4;
-
-        rightOff[0] = x1p; rightOff[1] = y1p;
-        rightOff[2] = x2p; rightOff[3] = y2p;
-        rightOff[4] = x3p; rightOff[5] = y3p;
-        rightOff[6] = x4p; rightOff[7] = y4p;
-    }
-    return 8;
-}
-
-// compute offset curves using bezier spline through t=0.5 (i.e.
-// ComputedCurve(0.5) == IdealParallelCurve(0.5))
-// return the kind of curve in the right and left arrays.
-static jint computeOffsetQuad(PathConsumer *pStroker,
-                              jfloat pts[], const jint off,
-                              jfloat leftOff[], jfloat rightOff[])
-{
-    const jfloat x1 = pts[off + 0], y1 = pts[off + 1];
-    const jfloat x2 = pts[off + 2], y2 = pts[off + 3];
-    const jfloat x3 = pts[off + 4], y3 = pts[off + 5];
-    jfloat dotsq, l1sq, l3sq;
-
-    jfloat dx3 = x3 - x2;
-    jfloat dy3 = y3 - y2;
-    jfloat dx1 = x2 - x1;
-    jfloat dy1 = y2 - y1;
-
-    // if p1=p2 or p3=p4 it means that the derivative at the endpoint
-    // vanishes, which creates problems with computeOffset. Usually
-    // this happens when this stroker object is trying to winden
-    // a curve with a cusp. What happens is that curveTo splits
-    // the input curve at the cusp, and passes it to this function.
-    // because of inaccuracies in the splitting, we consider points
-    // equal if they're very close to each other.
-
-    // if p1 == p2 && p3 == p4: draw line from p1->p4, unless p1 == p4,
-    // in which case ignore.
-    const jboolean p1eqp2 = withinULP(x1,y1,x2,y2, 6);
-    const jboolean p2eqp3 = withinULP(x2,y2,x3,y3, 6);
-    if (p1eqp2 || p2eqp3) {
-        getLineOffsets(pStroker, x1, y1, x3, y3, leftOff, rightOff);
-        return 4;
-    }
-
-    // if p2-p1 and p4-p3 are parallel, that must mean this curve is a line
-    dotsq = (dx1 * dx3 + dy1 * dy3);
-    dotsq = dotsq * dotsq;
-    l1sq = dx1 * dx1 + dy1 * dy1;
-    l3sq = dx3 * dx3 + dy3 * dy3;
-    if (Helpers_withinULP(dotsq, l1sq * l3sq, 4)) {
-        getLineOffsets(pStroker, x1, y1, x3, y3, leftOff, rightOff);
-        return 4;
-    }
-
-    // this computes the offsets at t=0, 0.5, 1, using the property that
-    // for any bezier curve the vectors p2-p1 and p4-p3 are parallel to
-    // the (dx/dt, dy/dt) vectors at the endpoints.
-    computeOffset(dx1, dy1, this.lineWidth2, this.offset[0]);
-    computeOffset(dx3, dy3, this.lineWidth2, this.offset[1]);
-    {
-        jfloat x1p = x1 + this.offset[0][0]; // start
-        jfloat y1p = y1 + this.offset[0][1]; // point
-        jfloat x3p = x3 + this.offset[1][0]; // end
-        jfloat y3p = y3 + this.offset[1][1]; // point
-
-        safecomputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, leftOff, 2);
-        leftOff[0] = x1p; leftOff[1] = y1p;
-        leftOff[4] = x3p; leftOff[5] = y3p;
-        x1p = x1 - this.offset[0][0]; y1p = y1 - this.offset[0][1];
-        x3p = x3 - this.offset[1][0]; y3p = y3 - this.offset[1][1];
-        safecomputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, rightOff, 2);
-        rightOff[0] = x1p; rightOff[1] = y1p;
-        rightOff[4] = x3p; rightOff[5] = y3p;
-    }
-    return 6;
-}
-
-// This is where the curve to be processed is put. We give it
-// enough room to store 2 curves: one for the current subdivision, the
-// other for the rest of the curve.
-#define MAX_N_CURVES   11
-
-static jfloat middle[MAX_N_CURVES*8];
-static jfloat lp[8];
-static jfloat rp[8];
-static jfloat subdivTs[MAX_N_CURVES - 1];
-
-// The following variation of somethingTo() caused problems when this was
-// Java code as indicated by the following comment.  Now that this code has
-// been converted into C, we should look at investigating the potential
-// performance benefits of using this version instead of the "safer" version
-// that survived in the Java sources and is currently being used below.
-    // If this class is compiled with ecj, then Hotspot crashes when OSR
-    // compiling this function. See bugs 7004570 and 6675699
-    // NOTE: until those are fixed, we should work around that by
-    // manually inlining this into curveTo and quadTo.
-/******************************* WORKAROUND **********************************
-    private void somethingTo(final int type) {
-        // need these so we can update the state at the end of this method
-        final float xf = middle[type-2], yf = middle[type-1];
-        float dxs = middle[2] - middle[0];
-        float dys = middle[3] - middle[1];
-        float dxf = middle[type - 2] - middle[type - 4];
-        float dyf = middle[type - 1] - middle[type - 3];
-        switch(type) {
-        case 6:
-            if ((dxs == 0f && dys == 0f) ||
-                (dxf == 0f && dyf == 0f)) {
-               dxs = dxf = middle[4] - middle[0];
-               dys = dyf = middle[5] - middle[1];
-            }
-            break;
-        case 8:
-            boolean p1eqp2 = (dxs == 0f && dys == 0f);
-            boolean p3eqp4 = (dxf == 0f && dyf == 0f);
-            if (p1eqp2) {
-                dxs = middle[4] - middle[0];
-                dys = middle[5] - middle[1];
-                if (dxs == 0f && dys == 0f) {
-                    dxs = middle[6] - middle[0];
-                    dys = middle[7] - middle[1];
-                }
-            }
-            if (p3eqp4) {
-                dxf = middle[6] - middle[2];
-                dyf = middle[7] - middle[3];
-                if (dxf == 0f && dyf == 0f) {
-                    dxf = middle[6] - middle[0];
-                    dyf = middle[7] - middle[1];
-                }
-            }
-        }
-        if (dxs == 0f && dys == 0f) {
-            // this happens iff the "curve" is just a point
-            lineTo(middle[0], middle[1]);
-            return;
-        }
-        // if these vectors are too small, normalize them, to avoid future
-        // precision problems.
-        if (Math.abs(dxs) < 0.1f && Math.abs(dys) < 0.1f) {
-            float len = (float)Math.sqrt(dxs*dxs + dys*dys);
-            dxs /= len;
-            dys /= len;
-        }
-        if (Math.abs(dxf) < 0.1f && Math.abs(dyf) < 0.1f) {
-            float len = (float)Math.sqrt(dxf*dxf + dyf*dyf);
-            dxf /= len;
-            dyf /= len;
-        }
-
-        computeOffset(dxs, dys, lineWidth2, offset[0]);
-        final float mx = offset[0][0];
-        final float my = offset[0][1];
-        drawJoin(pStroker, cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, mx, my);
-
-        int nSplits = findSubdivPoints(pStroker, middle, subdivTs, type, lineWidth2);
-
-        int kind = 0;
-        Iterator<Integer> it = Curve.breakPtsAtTs(middle, type, subdivTs, nSplits);
-        while(it.hasNext()) {
-            int curCurveOff = it.next();
-
-            kind = 0;
-            switch (type) {
-            case 8:
-                kind = computeOffsetCubic(middle, curCurveOff, lp, rp);
-                break;
-            case 6:
-                kind = computeOffsetQuad(middle, curCurveOff, lp, rp);
-                break;
-            }
-            if (kind != 0) {
-                emitLineTo(pStroker, lp[0], lp[1], JNI_FALSE);
-                switch(kind) {
-                case 8:
-                    emitCurveTo(pStroker, lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], lp[6], lp[7], false);
-                    emitCurveTo(pStroker, rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], rp[6], rp[7], true);
-                    break;
-                case 6:
-                    emitQuadTo(pStroker, lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], false);
-                    emitQuadTo(pStroker, rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], true);
-                    break;
-                case 4:
-                    emitLineTo(pStroker, lp[2], lp[3], JNI_FALSE);
-                    emitLineTo(pStroker, rp[0], rp[1], JNI_TRUE);
-                    break;
-                }
-                emitLineTo(pStroker, rp[kind - 2], rp[kind - 1], true);
-            }
-        }
-
-        this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
-        this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
-        this.cdx = dxf;
-        this.cdy = dyf;
-        this.cx0 = xf;
-        this.cy0 = yf;
-        this.prev = DRAWING_OP_TO;
-    }
-****************************** END WORKAROUND *******************************/
-
-// finds values of t where the curve in pts should be subdivided in order
-// to get good offset curves a distance of w away from the middle curve.
-// Stores the points in ts, and returns how many of them there were.
-static jint findSubdivPoints(PathConsumer *pStroker,
-                             jfloat pts[], jfloat ts[],
-                             const jint type, const jfloat w)
-{
-    jint ret = 0;
-
-    const jfloat x12 = pts[2] - pts[0];
-    const jfloat y12 = pts[3] - pts[1];
-    // if the curve is already parallel to either axis we gain nothing
-    // from rotating it.
-    if (y12 != 0.0f && x12 != 0.0f) {
-        // we rotate it so that the first vector in the control polygon is
-        // parallel to the x-axis. This will ensure that rotated quarter
-        // circles won't be subdivided.
-        const jfloat hypot = (jfloat) sqrt(x12 * x12 + y12 * y12);
-        const jfloat cos = x12 / hypot;
-        const jfloat sin = y12 / hypot;
-        const jfloat x1 = cos * pts[0] + sin * pts[1];
-        const jfloat y1 = cos * pts[1] - sin * pts[0];
-        const jfloat x2 = cos * pts[2] + sin * pts[3];
-        const jfloat y2 = cos * pts[3] - sin * pts[2];
-        const jfloat x3 = cos * pts[4] + sin * pts[5];
-        const jfloat y3 = cos * pts[5] - sin * pts[4];
-        switch(type) {
-        case 8:
-        {
-            const jfloat x4 = cos * pts[6] + sin * pts[7];
-            const jfloat y4 = cos * pts[7] - sin * pts[6];
-            Curve_setcubic(&this.c, x1, y1, x2, y2, x3, y3, x4, y4);
-            break;
-        }
-        case 6:
-            Curve_setquad(&this.c, x1, y1, x2, y2, x3, y3);
-            break;
-        }
-    } else {
-        Curve_set(&this.c, pts, type);
-    }
-
-    // we subdivide at values of t such that the remaining rotated
-    // curves are monotonic in x and y.
-    ret += Curve_dxRoots(&this.c, ts, ret);
-    ret += Curve_dyRoots(&this.c, ts, ret);
-    // subdivide at inflection points.
-    if (type == 8) {
-        // quadratic curves can't have inflection points
-        ret += Curve_infPoints(&this.c, ts, ret);
-    }
-
-    // now we must subdivide at points where one of the offset curves will have
-    // a cusp. This happens at ts where the radius of curvature is equal to w.
-    ret += Curve_rootsOfROCMinusW(&this.c, ts, ret, w, 0.0001f);
-
-    ret = Helpers_filterOutNotInAB(ts, 0, ret, 0.0001f, 0.9999f);
-    Helpers_isort(ts, 0, ret);
-    return ret;
-}
-
-static jint Stroker_curveTo(PathConsumer *pStroker,
-                           jfloat x1, jfloat y1,
-                           jfloat x2, jfloat y2,
-                           jfloat x3, jfloat y3)
-{
-    jint status = ERROR_NONE;
-    jfloat xf, yf, dxs, dys, dxf, dyf;
-    jfloat mx, my;
-    jint nSplits;
-    jfloat prevT;
-    jint i, kind;
-    jboolean p1eqp2, p3eqp4;
-
-    middle[0] = this.cx0; middle[1] = this.cy0;
-    middle[2] = x1;  middle[3] = y1;
-    middle[4] = x2;  middle[5] = y2;
-    middle[6] = x3;  middle[7] = y3;
-
-    // inlined version of somethingTo(8);
-    // See the NOTE on somethingTo
-
-    // need these so we can update the state at the end of this method
-    xf = middle[6], yf = middle[7];
-    dxs = middle[2] - middle[0];
-    dys = middle[3] - middle[1];
-    dxf = middle[6] - middle[4];
-    dyf = middle[7] - middle[5];
-
-    p1eqp2 = (dxs == 0.0f && dys == 0.0f);
-    p3eqp4 = (dxf == 0.0f && dyf == 0.0f);
-    if (p1eqp2) {
-        dxs = middle[4] - middle[0];
-        dys = middle[5] - middle[1];
-        if (dxs == 0.0f && dys == 0.0f) {
-            dxs = middle[6] - middle[0];
-            dys = middle[7] - middle[1];
-        }
-    }
-    if (p3eqp4) {
-        dxf = middle[6] - middle[2];
-        dyf = middle[7] - middle[3];
-        if (dxf == 0.0f && dyf == 0.0f) {
-            dxf = middle[6] - middle[0];
-            dyf = middle[7] - middle[1];
-        }
-    }
-    if (dxs == 0.0f && dys == 0.0f) {
-        // this happens iff the "curve" is just a point
-        return Stroker_lineTo(pStroker, middle[0], middle[1]);
-    }
-
-    // if these vectors are too small, normalize them, to avoid future
-    // precision problems.
-    if (fabs(dxs) < 0.1f && fabs(dys) < 0.1f) {
-        jfloat len = (jfloat) sqrt(dxs*dxs + dys*dys);
-        dxs /= len;
-        dys /= len;
-    }
-    if (fabs(dxf) < 0.1f && fabs(dyf) < 0.1f) {
-        jfloat len = (jfloat) sqrt(dxf*dxf + dyf*dyf);
-        dxf /= len;
-        dyf /= len;
-    }
-
-    computeOffset(dxs, dys, this.lineWidth2, this.offset[0]);
-    mx = this.offset[0][0];
-    my = this.offset[0][1];
-    status = drawJoin(pStroker,
-             this.cdx, this.cdy, this.cx0, this.cy0,
-             dxs, dys, this.cmx, this.cmy,
-             mx, my);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-
-    nSplits = findSubdivPoints(pStroker, middle, subdivTs, 8, this.lineWidth2);
-    prevT = 0.0f;
-    for (i = 0; i < nSplits; i++) {
-        jfloat t = subdivTs[i];
-        Helpers_subdivideCubicAt((t - prevT) / (1 - prevT),
-                                 middle, i*6,
-                                 middle, i*6,
-                                 middle, i*6+6);
-        prevT = t;
-    }
-
-    kind = 0;
-    for (i = 0; i <= nSplits; i++) {
-        kind = computeOffsetCubic(pStroker, middle, i*6, lp, rp);
-        if (kind != 0) {
-            status = emitLineTo(pStroker, lp[0], lp[1], JNI_FALSE);
-            if (status != ERROR_NONE) {
-                return status;
-            }
-            switch(kind) {
-            case 8:
-                status = emitCurveTo(pStroker, lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], lp[6], lp[7], JNI_FALSE);
-                if (status != ERROR_NONE) {
-                    return status;
-                }
-                status = emitCurveTo(pStroker, rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], rp[6], rp[7], JNI_TRUE);
-                if (status != ERROR_NONE) {
-                    return status;
-                }
-                break;
-            case 4:
-                status = emitLineTo(pStroker, lp[2], lp[3], JNI_FALSE);
-                if (status != ERROR_NONE) {
-                    return status;
-                }
-                status = emitLineTo(pStroker, rp[0], rp[1], JNI_TRUE);
-                if (status != ERROR_NONE) {
-                    return status;
-                }
-                break;
-            }
-            status = emitLineTo(pStroker, rp[kind - 2], rp[kind - 1], JNI_TRUE);
-            if (status != ERROR_NONE) {
-                return status;
-            }
-        }
-    }
-
-    this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
-    this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
-    this.cdx = dxf;
-    this.cdy = dyf;
-    this.cx0 = xf;
-    this.cy0 = yf;
-    this.prev = DRAWING_OP_TO;
-    return status;
-}
-
-static jint Stroker_quadTo(PathConsumer *pStroker,
-                          jfloat x1, jfloat y1,
-                          jfloat x2, jfloat y2)
-{
-    jint status = ERROR_NONE;
-    jfloat xf, yf, dxs, dys, dxf, dyf;
-    jfloat mx, my;
-    jint nSplits, i, kind;
-    jfloat prevt;
-
-    middle[0] = this.cx0; middle[1] = this.cy0;
-    middle[2] = x1;  middle[3] = y1;
-    middle[4] = x2;  middle[5] = y2;
-
-    // inlined version of somethingTo(8);
-    // See the NOTE on somethingTo
-
-    // need these so we can update the state at the end of this method
-    xf = middle[4], yf = middle[5];
-    dxs = middle[2] - middle[0];
-    dys = middle[3] - middle[1];
-    dxf = middle[4] - middle[2];
-    dyf = middle[5] - middle[3];
-    if ((dxs == 0.0f && dys == 0.0f) || (dxf == 0.0f && dyf == 0.0f)) {
-        dxs = dxf = middle[4] - middle[0];
-        dys = dyf = middle[5] - middle[1];
-    }
-    if (dxs == 0.0f && dys == 0.0f) {
-        // this happens iff the "curve" is just a point
-        return Stroker_lineTo(pStroker, middle[0], middle[1]);
-    }
-    // if these vectors are too small, normalize them, to avoid future
-    // precision problems.
-    if (fabs(dxs) < 0.1f && fabs(dys) < 0.1f) {
-        jfloat len = (jfloat) sqrt(dxs*dxs + dys*dys);
-        dxs /= len;
-        dys /= len;
-    }
-    if (fabs(dxf) < 0.1f && fabs(dyf) < 0.1f) {
-        jfloat len = (jfloat) sqrt(dxf*dxf + dyf*dyf);
-        dxf /= len;
-        dyf /= len;
-    }
-
-    computeOffset(dxs, dys, this.lineWidth2, this.offset[0]);
-    mx = this.offset[0][0];
-    my = this.offset[0][1];
-    status = drawJoin(pStroker,
-             this.cdx, this.cdy, this.cx0, this.cy0,
-             dxs, dys, this.cmx, this.cmy,
-             mx, my);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-
-    nSplits = findSubdivPoints(pStroker, middle, subdivTs, 6, this.lineWidth2);
-    prevt = 0.0f;
-    for (i = 0; i < nSplits; i++) {
-        jfloat t = subdivTs[i];
-        Helpers_subdivideQuadAt((t - prevt) / (1 - prevt),
-                                middle, i*4,
-                                middle, i*4,
-                                middle, i*4+4);
-        prevt = t;
-    }
-
-    kind = 0;
-    for (i = 0; i <= nSplits; i++) {
-        kind = computeOffsetQuad(pStroker, middle, i*4, lp, rp);
-        if (kind != 0) {
-            status = emitLineTo(pStroker, lp[0], lp[1], JNI_FALSE);
-            if (status != ERROR_NONE) {
-                return status;
-            }
-            switch(kind) {
-            case 6:
-                status = emitQuadTo(pStroker, lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], JNI_FALSE);
-                if (status != ERROR_NONE) {
-                    return status;
-                }
-                status = emitQuadTo(pStroker, rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], JNI_TRUE);
-                if (status != ERROR_NONE) {
-                    return status;
-                }
-                break;
-            case 4:
-                status = emitLineTo(pStroker, lp[2], lp[3], JNI_FALSE);
-                if (status != ERROR_NONE) {
-                    return status;
-                }
-                status = emitLineTo(pStroker, rp[0], rp[1], JNI_TRUE);
-                if (status != ERROR_NONE) {
-                    return status;
-                }
-                break;
-            }
-            status = emitLineTo(pStroker, rp[kind - 2], rp[kind - 1], JNI_TRUE);
-            if (status != ERROR_NONE) {
-                return status;
-            }
-        }
-    }
-
-    this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
-    this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
-    this.cdx = dxf;
-    this.cdy = dyf;
-    this.cx0 = xf;
-    this.cy0 = yf;
-    this.prev = DRAWING_OP_TO;
-    return status;
-}
-
-// a stack of polynomial curves where each curve shares endpoints with
-// adjacent ones.
-/*
-    private static const class PolyStack {
-        jfloat[] curves;
-        int end;
-        int[] curveTypes;
-        int numCurves;
- */
-
-#define INIT_SIZE   50
-
-#undef this
-#define this (*((PolyStack *)pStack))
-
-void PolyStack_init(PolyStack *pStack) {
-    this.curves = new_float(8 * INIT_SIZE);
-    this.curvesSIZE = 8 * INIT_SIZE;
-    this.curveTypes = new_int(INIT_SIZE);
-    this.curveTypesSIZE = INIT_SIZE;
-    this.end = 0;
-    this.numCurves = 0;
-}
-
-void PolyStack_destroy(PolyStack *pStack) {
-    free(this.curves);
-    this.curves = NULL;
-    this.curvesSIZE = 0;
-    free(this.curveTypes);
-    this.curveTypes = NULL;
-    this.curveTypesSIZE = 0;
-}
-
-jboolean PolyStack_isEmpty(PolyStack *pStack) {
-    return this.numCurves == 0;
-}
-
-static jint ensureSpace(PolyStack *pStack, jint n) {
-    if (this.end + n >= this.curvesSIZE) {
-        jint newSize = (this.end + n) * 2;
-        jfloat *newCurves = new_float(newSize);
-        if (!newCurves) {
-            return ERROR_OOM;
-        }
-        System_arraycopy(this.curves, 0, newCurves, 0, this.end);
-        free(this.curves);
-        this.curves = newCurves;
-        this.curvesSIZE = newSize;
-    }
-    if (this.numCurves >= this.curveTypesSIZE) {
-        jint newSize = this.numCurves * 2;
-        jint *newTypes = new_int(newSize);
-        if (!newTypes) {
-            return ERROR_OOM;
-        }
-        System_arraycopy(this.curveTypes, 0, newTypes, 0, this.numCurves);
-        free(this.curveTypes);
-        this.curveTypes = newTypes;
-        this.curveTypesSIZE = newSize;
-    }
-    return ERROR_NONE;
-}
-
-jint PolyStack_pushCubic(PolyStack *pStack,
-                         jfloat x0, jfloat y0,
-                         jfloat x1, jfloat y1,
-                         jfloat x2, jfloat y2)
-{
-    jint status = ensureSpace(pStack, 6);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-    this.curveTypes[this.numCurves++] = 8;
-    // assert(x0 == lastX && y0 == lastY)
-
-    // we reverse the coordinate order to make popping easier
-    this.curves[this.end++] = x2;    this.curves[this.end++] = y2;
-    this.curves[this.end++] = x1;    this.curves[this.end++] = y1;
-    this.curves[this.end++] = x0;    this.curves[this.end++] = y0;
-    return status;
-}
-
-jint PolyStack_pushQuad(PolyStack *pStack,
-                        jfloat x0, jfloat y0,
-                        jfloat x1, jfloat y1)
-{
-    jint status = ensureSpace(pStack, 4);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-    this.curveTypes[this.numCurves++] = 6;
-    // assert(x0 == lastX && y0 == lastY)
-    this.curves[this.end++] = x1;    this.curves[this.end++] = y1;
-    this.curves[this.end++] = x0;    this.curves[this.end++] = y0;
-    return status;
-}
-
-jint PolyStack_pushLine(PolyStack *pStack,
-                        jfloat x, jfloat y)
-{
-    jint status = ensureSpace(pStack, 2);
-    if (status != ERROR_NONE) {
-        return status;
-    }
-    this.curveTypes[this.numCurves++] = 4;
-    // assert(x0 == lastX && y0 == lastY)
-    this.curves[this.end++] = x;    this.curves[this.end++] = y;
-    return status;
-}
-
-//@SuppressWarnings("unused")
-/*
-jint PolyStack_pop(PolyStack *pStack, jfloat pts[]) {
-    jint ret = this.curveTypes[this.numCurves - 1];
-    this.numCurves--;
-    this.end -= (ret - 2);
-    System_arraycopy(curves, end, pts, 0, ret - 2);
-    return ret;
-}
-*/
-
-jint PolyStack_pop(PolyStack *pStack, PathConsumer *io) {
-    jint status = ERROR_NONE;
-    jint type;
-
-    this.numCurves--;
-    type = this.curveTypes[this.numCurves];
-    this.end -= (type - 2);
-    switch(type) {
-    case 8:
-        status = io->curveTo(io,
-                    this.curves[this.end+0], this.curves[this.end+1],
-                    this.curves[this.end+2], this.curves[this.end+3],
-                    this.curves[this.end+4], this.curves[this.end+5]);
-        break;
-    case 6:
-        status = io->quadTo(io,
-                   this.curves[this.end+0], this.curves[this.end+1],
-                   this.curves[this.end+2], this.curves[this.end+3]);
-        break;
-    case 4:
-        status = io->lineTo(io, this.curves[this.end], this.curves[this.end+1]);
-    }
-    return status;
-}
-
-//@Override
-/*
-public String toString() {
-    String ret = "";
-    jint nc = numCurves;
-    jint last = this.end;
-    while (nc > 0) {
-        nc--;
-        jint type = curveTypes[numCurves];
-        last -= (type - 2);
-        switch(type) {
-        case 8:
-            ret += "cubic: ";
-            break;
-        case 6:
-            ret += "quad: ";
-            break;
-        case 4:
-            ret += "line: ";
-            break;
-        }
-        ret += Arrays.toString(Arrays.copyOfRange(curves, last, last+type-2)) + "\n";
-    }
-    return ret;
-}
- */
diff a/modules/javafx.graphics/src/main/native-prism/Stroker.h b/modules/javafx.graphics/src/main/native-prism/Stroker.h
--- a/modules/javafx.graphics/src/main/native-prism/Stroker.h
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifndef STROKER_H
-#define STROKER_H
-
-#include "Curve.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * Constant value for join style.
- */
-#define JOIN_MITER  0
-
-/**
- * Constant value for join style.
- */
-#define JOIN_ROUND  1
-
-/**
- * Constant value for join style.
- */
-#define JOIN_BEVEL  2
-
-/**
- * Constant value for end cap style.
- */
-#define CAP_BUTT    0
-
-/**
- * Constant value for end cap style.
- */
-#define CAP_ROUND   1
-
-/**
- * Constant value for end cap style.
- */
-#define CAP_SQUARE  2
-
-typedef struct {
-    jfloat *curves;
-    jint curvesSIZE;
-    jint end;
-    jint *curveTypes;
-    jint curveTypesSIZE;
-    jint numCurves;
-} PolyStack;
-
-typedef struct {
-    PathConsumer consumer;
-    PathConsumer *out;
-
-    jint capStyle;
-    jint joinStyle;
-
-    jfloat lineWidth2;
-
-    jfloat offset[3][2];
-    jfloat miter[2];
-    jfloat miterLimitSq;
-
-    jint prev;
-
-    // The starting point of the path, and the slope there.
-    jfloat sx0, sy0, sdx, sdy;
-    // the current point and the slope there.
-    jfloat cx0, cy0, cdx, cdy; // c stands for current
-    // vectors that when added to (sx0,sy0) and (cx0,cy0) respectively yield the
-    // first and last points on the left parallel path. Since this path is
-    // parallel, it's slope at any point is parallel to the slope of the
-    // original path (thought they may have different directions), so these
-    // could be computed from sdx,sdy and cdx,cdy (and vice versa), but that
-    // would be error prone and hard to read, so we keep these anyway.
-    jfloat smx, smy, cmx, cmy;
-
-    PolyStack reverse;
-    Curve c;
-} Stroker;
-
-extern void Stroker_reset(Stroker *pStroker, jfloat lineWidth,
-                          jint capStyle, jint joinStyle, jfloat miterLimit);
-
-extern void Stroker_init(Stroker *pStroker,
-                         PathConsumer *out,
-                         jfloat lineWidth,
-                         jint capStyle,
-                         jint joinStyle,
-                         jfloat miterLimit);
-
-extern void Stroker_destroy(Stroker *pStroker);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* STROKER_H */
-
diff a/modules/javafx.graphics/src/main/native-prism/Transformer.c b/modules/javafx.graphics/src/main/native-prism/Transformer.c
--- a/modules/javafx.graphics/src/main/native-prism/Transformer.c
+++ /dev/null
@@ -1,302 +0,0 @@
-/*
- * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#include <jni.h>
-
-#include "Transformer.h"
-
-#define this (*((Transformer *) pTransformer))
-
-#define TX_Declare(TX_TYPE)                     \
-static MoveToFunc       TX_TYPE ## _moveTo;     \
-static LineToFunc       TX_TYPE ## _lineTo;     \
-static QuadToFunc       TX_TYPE ## _quadTo;     \
-static CurveToFunc      TX_TYPE ## _curveTo;
-
-TX_Declare(Translate)
-TX_Declare(DeltaScale)
-TX_Declare(ScaleTranslate)
-TX_Declare(DeltaTransform)
-TX_Declare(Transform)
-
-static ClosePathFunc    Transformer_closePath;
-static PathDoneFunc     Transformer_pathDone;
-
-#define TX_Init(TX_TYPE)                          \
-    PathConsumer_init(&pTransformer->consumer,    \
-                      TX_TYPE ## _moveTo,         \
-                      TX_TYPE ## _lineTo,         \
-                      TX_TYPE ## _quadTo,         \
-                      TX_TYPE ## _curveTo,        \
-                      Transformer_closePath,      \
-                      Transformer_pathDone)
-
-PathConsumer *Transformer_init(Transformer *pTransformer,
-                               PathConsumer *out,
-                               jdouble mxx, jdouble mxy, jdouble mxt,
-                               jdouble myx, jdouble myy, jdouble myt)
-{
-    if (mxy == 0.0 && myx == 0.0) {
-        if (mxx == 1.0 && myy == 1.0) {
-            if (mxt == 0.0 && myt == 0.0) {
-                return out;
-            } else {
-                TX_Init(Translate);
-            }
-        } else {
-            if (mxt == 0.0 && myt == 0.0) {
-                TX_Init(DeltaScale);
-            } else {
-                TX_Init(ScaleTranslate);
-            }
-        }
-    } else if (mxt == 0.0 && myt == 0.0) {
-        TX_Init(DeltaTransform);
-    } else {
-        TX_Init(Transform);
-    }
-
-    this.out = out;
-    this.mxx = mxx;
-    this.mxy = mxy;
-    this.mxt = mxt;
-    this.myx = myx;
-    this.myy = myy;
-    this.myt = myt;
-    return &pTransformer->consumer;
-}
-
-static jint Translate_moveTo(PathConsumer *pTransformer,
-                             jfloat x0, jfloat y0)
-{
-    return this.out->moveTo(this.out,
-                     (jfloat) (x0 + this.mxt),
-                     (jfloat) (y0 + this.myt));
-}
-
-static jint Translate_lineTo(PathConsumer *pTransformer,
-                             jfloat x1, jfloat y1)
-{
-    return this.out->lineTo(this.out,
-                     (jfloat) (x1 + this.mxt),
-                     (jfloat) (y1 + this.myt));
-}
-
-static jint Translate_quadTo(PathConsumer *pTransformer,
-                             jfloat xc, jfloat yc,
-                             jfloat x1, jfloat y1)
-{
-    return this.out->quadTo(this.out,
-                     (jfloat) (xc + this.mxt),
-                     (jfloat) (yc + this.myt),
-                     (jfloat) (x1 + this.mxt),
-                     (jfloat) (y1 + this.myt));
-}
-
-static jint Translate_curveTo(PathConsumer *pTransformer,
-                              jfloat xc0, jfloat yc0,
-                              jfloat xc1, jfloat yc1,
-                              jfloat x1, jfloat y1)
-{
-    return this.out->curveTo(this.out,
-                      (jfloat) (xc0 + this.mxt),
-                      (jfloat) (yc0 + this.myt),
-                      (jfloat) (xc1 + this.mxt),
-                      (jfloat) (yc1 + this.myt),
-                      (jfloat) (x1  + this.mxt),
-                      (jfloat) (y1  + this.myt));
-}
-
-static jint DeltaScale_moveTo(PathConsumer *pTransformer,
-                              jfloat x0, jfloat y0)
-{
-    return this.out->moveTo(this.out,
-                     (jfloat) (x0 * this.mxx),
-                     (jfloat) (y0 * this.myy));
-}
-
-static jint DeltaScale_lineTo(PathConsumer *pTransformer,
-                              jfloat x1, jfloat y1)
-{
-    return this.out->lineTo(this.out,
-                     (jfloat) (x1 * this.mxx),
-                     (jfloat) (y1 * this.myy));
-}
-
-static jint DeltaScale_quadTo(PathConsumer *pTransformer,
-                              jfloat xc, jfloat yc,
-                              jfloat x1, jfloat y1)
-{
-    return this.out->quadTo(this.out,
-                     (jfloat) (xc * this.mxx),
-                     (jfloat) (yc * this.myy),
-                     (jfloat) (x1 * this.mxx),
-                     (jfloat) (y1 * this.myy));
-}
-
-static jint DeltaScale_curveTo(PathConsumer *pTransformer,
-                               jfloat xc0, jfloat yc0,
-                               jfloat xc1, jfloat yc1,
-                               jfloat x1, jfloat y1)
-{
-    return this.out->curveTo(this.out,
-                      (jfloat) (xc0 * this.mxx),
-                      (jfloat) (yc0 * this.myy),
-                      (jfloat) (xc1 * this.mxx),
-                      (jfloat) (yc1 * this.myy),
-                      (jfloat) (x1  * this.mxx),
-                      (jfloat) (y1  * this.myy));
-}
-
-static jint DeltaTransform_moveTo(PathConsumer *pTransformer,
-                                  jfloat x0, jfloat y0)
-{
-    return this.out->moveTo(this.out,
-                     (jfloat) (x0 * this.mxx + y0 * this.mxy),
-                     (jfloat) (x0 * this.myx + y0 * this.myy));
-}
-
-static jint DeltaTransform_lineTo(PathConsumer *pTransformer,
-                                  jfloat x1, jfloat y1)
-{
-    return this.out->lineTo(this.out,
-                     (jfloat) (x1 * this.mxx + y1 * this.mxy),
-                     (jfloat) (x1 * this.myx + y1 * this.myy));
-}
-
-static jint DeltaTransform_quadTo(PathConsumer *pTransformer,
-                                  jfloat xc, jfloat yc,
-                                  jfloat x1, jfloat y1)
-{
-    return this.out->quadTo(this.out,
-                     (jfloat) (xc * this.mxx + yc * this.mxy),
-                     (jfloat) (xc * this.myx + yc * this.myy),
-                     (jfloat) (x1 * this.mxx + y1 * this.mxy),
-                     (jfloat) (x1 * this.myx + y1 * this.myy));
-}
-
-static jint DeltaTransform_curveTo(PathConsumer *pTransformer,
-                                   jfloat xc0, jfloat yc0,
-                                   jfloat xc1, jfloat yc1,
-                                   jfloat x1, jfloat y1)
-{
-    return this.out->curveTo(this.out,
-                      (jfloat) (xc0 * this.mxx + yc0 * this.mxy),
-                      (jfloat) (xc0 * this.myx + yc0 * this.myy),
-                      (jfloat) (xc1 * this.mxx + yc1 * this.mxy),
-                      (jfloat) (xc1 * this.myx + yc1 * this.myy),
-                      (jfloat) (x1  * this.mxx + y1  * this.mxy),
-                      (jfloat) (x1  * this.myx + y1  * this.myy));
-}
-
-static jint ScaleTranslate_moveTo(PathConsumer *pTransformer,
-                                  jfloat x0, jfloat y0)
-{
-    return this.out->moveTo(this.out,
-                     (jfloat) (x0 * this.mxx + this.mxt),
-                     (jfloat) (y0 * this.myy + this.myt));
-}
-
-static jint ScaleTranslate_lineTo(PathConsumer *pTransformer,
-                                  jfloat x1, jfloat y1)
-{
-    return this.out->lineTo(this.out,
-                     (jfloat) (x1 * this.mxx + this.mxt),
-                     (jfloat) (y1 * this.myy + this.myt));
-}
-
-static jint ScaleTranslate_quadTo(PathConsumer *pTransformer,
-                                  jfloat xc, jfloat yc,
-                                  jfloat x1, jfloat y1)
-{
-    return this.out->quadTo(this.out,
-                     (jfloat) (xc * this.mxx + this.mxt),
-                     (jfloat) (yc * this.myy + this.myt),
-                     (jfloat) (x1 * this.mxx + this.mxt),
-                     (jfloat) (y1 * this.myy + this.myt));
-}
-
-static jint ScaleTranslate_curveTo(PathConsumer *pTransformer,
-                                   jfloat xc0, jfloat yc0,
-                                   jfloat xc1, jfloat yc1,
-                                   jfloat x1, jfloat y1)
-{
-    return this.out->curveTo(this.out,
-                      (jfloat) (xc0 * this.mxx + this.mxt),
-                      (jfloat) (yc0 * this.myy + this.myt),
-                      (jfloat) (xc1 * this.mxx + this.mxt),
-                      (jfloat) (yc1 * this.myy + this.myt),
-                      (jfloat) (x1  * this.mxx + this.mxt),
-                      (jfloat) (y1  * this.myy + this.myt));
-}
-
-static jint Transform_moveTo(PathConsumer *pTransformer,
-                             jfloat x0, jfloat y0)
-{
-    return this.out->moveTo(this.out,
-                     (jfloat) (x0 * this.mxx + y0 * this.mxy + this.mxt),
-                     (jfloat) (x0 * this.myx + y0 * this.myy + this.myt));
-}
-
-static jint Transform_lineTo(PathConsumer *pTransformer,
-                             jfloat x1, jfloat y1)
-{
-    return this.out->lineTo(this.out,
-                     (jfloat) (x1 * this.mxx + y1 * this.mxy + this.mxt),
-                     (jfloat) (x1 * this.myx + y1 * this.myy + this.myt));
-}
-
-static jint Transform_quadTo(PathConsumer *pTransformer,
-                             jfloat xc, jfloat yc,
-                             jfloat x1, jfloat y1)
-{
-    return this.out->quadTo(this.out,
-                     (jfloat) (xc * this.mxx + yc * this.mxy + this.mxt),
-                     (jfloat) (xc * this.myx + yc * this.myy + this.myt),
-                     (jfloat) (x1 * this.mxx + y1 * this.mxy + this.mxt),
-                     (jfloat) (x1 * this.myx + y1 * this.myy + this.myt));
-}
-
-static jint Transform_curveTo(PathConsumer *pTransformer,
-                              jfloat xc0, jfloat yc0,
-                              jfloat xc1, jfloat yc1,
-                              jfloat x1, jfloat y1)
-{
-    return this.out->curveTo(this.out,
-                      (jfloat) (xc0 * this.mxx + yc0 * this.mxy + this.mxt),
-                      (jfloat) (xc0 * this.myx + yc0 * this.myy + this.myt),
-                      (jfloat) (xc1 * this.mxx + yc1 * this.mxy + this.mxt),
-                      (jfloat) (xc1 * this.myx + yc1 * this.myy + this.myt),
-                      (jfloat) (x1  * this.mxx + y1  * this.mxy + this.mxt),
-                      (jfloat) (x1  * this.myx + y1  * this.myy + this.myt));
-}
-
-static jint Transformer_closePath(PathConsumer *pTransformer) {
-    return this.out->closePath(this.out);
-}
-
-static jint Transformer_pathDone(PathConsumer *pTransformer) {
-    return this.out->pathDone(this.out);
-}
diff a/modules/javafx.graphics/src/main/native-prism/Transformer.h b/modules/javafx.graphics/src/main/native-prism/Transformer.h
--- a/modules/javafx.graphics/src/main/native-prism/Transformer.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifndef TRANSFORM_H
-#define TRANSFORM_H
-
-#include "PathConsumer.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct {
-    PathConsumer consumer;
-    PathConsumer *out;
-
-    jdouble mxx;
-    jdouble mxy;
-    jdouble mxt;
-    jdouble myx;
-    jdouble myy;
-    jdouble myt;
-} Transformer;
-
-extern PathConsumer *Transformer_init(Transformer *pTransformer,
-                                      PathConsumer *out,
-                                      jdouble mxx, jdouble mxy, jdouble mxt,
-                                      jdouble myx, jdouble myy, jdouble myt);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* TRANSFORM_H */
-
diff a/modules/javafx.graphics/src/shims/java/com/sun/prism/impl/shape/NativePiscesRasterizerShim.java b/modules/javafx.graphics/src/shims/java/com/sun/prism/impl/shape/NativePiscesRasterizerShim.java
--- a/modules/javafx.graphics/src/shims/java/com/sun/prism/impl/shape/NativePiscesRasterizerShim.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.prism.impl.shape;
-
-public class NativePiscesRasterizerShim {
-
-    public static void produceFillAlphas(float coords[], byte commands[], int nsegs, boolean nonzero,
-                                         double mxx, double mxy, double mxt,
-                                         double myx, double myy, double myt,
-                                         int bounds[], byte mask[]) {
-        NativePiscesRasterizer.produceFillAlphas(
-                coords, commands, nsegs, nonzero,
-                mxx, mxy, mxt,
-                myx, myy, myt,
-                bounds, mask);
-    }
-
-    public static void produceStrokeAlphas(float coords[], byte commands[], int nsegs,
-                                           float lw, int cap, int join, float mlimit,
-                                           float dashes[], float dashoff,
-                                           double mxx, double mxy, double mxt,
-                                           double myx, double myy, double myt,
-                                           int bounds[], byte mask[]) {
-        NativePiscesRasterizer.produceStrokeAlphas(
-                coords, commands, nsegs,
-                lw, cap, join, mlimit,
-                dashes, dashoff,
-                mxx, mxy, mxt,
-                myx, myy, myt,
-                bounds, mask);
-    }
-
-}
diff a/modules/javafx.graphics/src/test/java/test/com/sun/prism/impl/shape/NativePiscesRasterizerTest.java b/modules/javafx.graphics/src/test/java/test/com/sun/prism/impl/shape/NativePiscesRasterizerTest.java
--- a/modules/javafx.graphics/src/test/java/test/com/sun/prism/impl/shape/NativePiscesRasterizerTest.java
+++ /dev/null
@@ -1,262 +0,0 @@
-/*
- * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package test.com.sun.prism.impl.shape;
-
-import com.sun.javafx.geom.PathIterator;
-import com.sun.prism.BasicStroke;
-import com.sun.prism.impl.shape.NativePiscesRasterizerShim;
-import org.junit.Test;
-
-public class NativePiscesRasterizerTest {
-    static final int JOIN_BEVEL = BasicStroke.JOIN_BEVEL;
-    static final int JOIN_MITER = BasicStroke.JOIN_MITER;
-    static final int JOIN_ROUND = BasicStroke.JOIN_ROUND;
-
-    static final int CAP_SQUARE = BasicStroke.CAP_SQUARE;
-    static final int CAP_ROUND  = BasicStroke.CAP_ROUND;
-    static final int CAP_BUTT   = BasicStroke.CAP_BUTT;
-
-    static final byte SEG_MOVETO  = PathIterator.SEG_MOVETO;
-    static final byte SEG_LINETO  = PathIterator.SEG_LINETO;
-    static final byte SEG_QUADTO  = PathIterator.SEG_QUADTO;
-    static final byte SEG_CUBICTO = PathIterator.SEG_CUBICTO;
-    static final byte SEG_CLOSE   = PathIterator.SEG_CLOSE;
-
-    static final float coords6[] = new float[6];
-    static final float coords1[] = new float[1];
-    static final float coords3[] = new float[3];
-    static final float coords5[] = new float[5];
-    static final float coords7[] = new float[7];
-    static final byte move_arr[] = { SEG_MOVETO };
-    static final byte moveline_arr[] = { SEG_MOVETO, SEG_LINETO };
-    static final byte movequad_arr[] = { SEG_MOVETO, SEG_QUADTO };
-    static final byte movecubic_arr[] = { SEG_MOVETO, SEG_CUBICTO };
-    static final int bounds10[] = { 0, 0, 10, 10 };
-    static final byte mask1k[] = new byte[1024];
-
-    @Test(expected=java.lang.NullPointerException.class)
-    public void FillNullCoords() {
-        NativePiscesRasterizerShim.produceFillAlphas(null, move_arr, 1, true,
-                                                 1, 0, 0, 0, 1, 0,
-                                                 bounds10, mask1k);
-    }
-
-    @Test(expected=java.lang.NullPointerException.class)
-    public void FillNullCommands() {
-        NativePiscesRasterizerShim.produceFillAlphas(coords6, null, 1, true,
-                                                 1, 0, 0, 0, 1, 0,
-                                                 bounds10, mask1k);
-    }
-
-    @Test(expected=java.lang.NullPointerException.class)
-    public void FillNullBounds() {
-        NativePiscesRasterizerShim.produceFillAlphas(coords6, move_arr, 1, true,
-                                                 1, 0, 0, 0, 1, 0,
-                                                 null, mask1k);
-    }
-
-    @Test(expected=java.lang.NullPointerException.class)
-    public void FillNullMask() {
-        NativePiscesRasterizerShim.produceFillAlphas(coords6, move_arr, 1, true,
-                                                 1, 0, 0, 0, 1, 0,
-                                                 bounds10, null);
-    }
-
-    @Test(expected=java.lang.ArrayIndexOutOfBoundsException.class)
-    public void FillShortBounds() {
-        NativePiscesRasterizerShim.produceFillAlphas(coords6, move_arr, 1, true,
-                                                 1, 0, 0, 0, 1, 0,
-                                                 new int[3], mask1k);
-    }
-
-    @Test(expected=java.lang.ArrayIndexOutOfBoundsException.class)
-    public void FillShortCommands() {
-        NativePiscesRasterizerShim.produceFillAlphas(coords6, move_arr, 2, true,
-                                                 1, 0, 0, 0, 1, 0,
-                                                 bounds10, mask1k);
-    }
-
-    @Test
-    public void FillBadCommands() {
-        byte badcmd_arr[] = new byte[2];
-        badcmd_arr[0] = SEG_MOVETO;
-        for (int i = 0; i < 256; i++) {
-            switch (i) {
-                case SEG_MOVETO:
-                case SEG_LINETO:
-                case SEG_QUADTO:
-                case SEG_CUBICTO:
-                case SEG_CLOSE:
-                    continue;
-                default:
-                    badcmd_arr[1] = (byte) i;
-                    try {
-                        NativePiscesRasterizerShim.produceFillAlphas(coords6, badcmd_arr, 2, true,
-                                                                 1, 0, 0, 0, 1, 0,
-                                                                 bounds10, mask1k);
-                        throw new RuntimeException("allowed bad command: "+i);
-                    } catch (InternalError e) {
-                    }
-                    break;
-            }
-        }
-    }
-
-    @Test(expected=java.lang.ArrayIndexOutOfBoundsException.class)
-    public void FillShortMoveCoords() {
-        NativePiscesRasterizerShim.produceFillAlphas(coords1, move_arr, 1, true,
-                                                 1, 0, 0, 0, 1, 0,
-                                                 bounds10, mask1k);
-    }
-
-    @Test(expected=java.lang.ArrayIndexOutOfBoundsException.class)
-    public void FillShortLineCoords() {
-        NativePiscesRasterizerShim.produceFillAlphas(coords3, moveline_arr, 2, true,
-                                                 1, 0, 0, 0, 1, 0,
-                                                 bounds10, mask1k);
-    }
-
-    @Test(expected=java.lang.ArrayIndexOutOfBoundsException.class)
-    public void FillShortQuadCoords() {
-        NativePiscesRasterizerShim.produceFillAlphas(coords5, movequad_arr, 2, true,
-                                                 1, 0, 0, 0, 1, 0,
-                                                 bounds10, mask1k);
-    }
-
-    @Test(expected=java.lang.ArrayIndexOutOfBoundsException.class)
-    public void FillShortCubicCoords() {
-        NativePiscesRasterizerShim.produceFillAlphas(coords7, movecubic_arr, 2, true,
-                                                 1, 0, 0, 0, 1, 0,
-                                                 bounds10, mask1k);
-    }
-
-    @Test(expected=java.lang.NullPointerException.class)
-    public void StrokeNullCoords() {
-        NativePiscesRasterizerShim.produceStrokeAlphas(null, move_arr, 1,
-                                                   10, CAP_ROUND, JOIN_ROUND, 10, null, 0,
-                                                   1, 0, 0, 0, 1, 0,
-                                                   bounds10, mask1k);
-    }
-
-    @Test(expected=java.lang.NullPointerException.class)
-    public void StrokeNullCommands() {
-        NativePiscesRasterizerShim.produceStrokeAlphas(coords6, null, 1,
-                                                   10, CAP_ROUND, JOIN_ROUND, 10, null, 0,
-                                                   1, 0, 0, 0, 1, 0,
-                                                   bounds10, mask1k);
-    }
-
-    @Test(expected=java.lang.NullPointerException.class)
-    public void StrokeNullBounds() {
-        NativePiscesRasterizerShim.produceStrokeAlphas(coords6, move_arr, 1,
-                                                   10, CAP_ROUND, JOIN_ROUND, 10, null, 0,
-                                                   1, 0, 0, 0, 1, 0,
-                                                   null, mask1k);
-    }
-
-    @Test(expected=java.lang.NullPointerException.class)
-    public void StrokeNullMask() {
-        NativePiscesRasterizerShim.produceStrokeAlphas(coords6, move_arr, 1,
-                                                   10, CAP_ROUND, JOIN_ROUND, 10, null, 0,
-                                                   1, 0, 0, 0, 1, 0,
-                                                   bounds10, null);
-    }
-
-    @Test(expected=java.lang.ArrayIndexOutOfBoundsException.class)
-    public void StrokeShortBounds() {
-        NativePiscesRasterizerShim.produceStrokeAlphas(coords6, move_arr, 1,
-                                                   10, CAP_ROUND, JOIN_ROUND, 10, null, 0,
-                                                   1, 0, 0, 0, 1, 0,
-                                                   new int[3], mask1k);
-    }
-
-    @Test(expected=java.lang.ArrayIndexOutOfBoundsException.class)
-    public void StrokeShortCommands() {
-        NativePiscesRasterizerShim.produceStrokeAlphas(coords6, move_arr, 2,
-                                                   10, CAP_ROUND, JOIN_ROUND, 10, null, 0,
-                                                   1, 0, 0, 0, 1, 0,
-                                                   bounds10, mask1k);
-    }
-
-    @Test
-    public void StrokeBadCommands() {
-        byte badcmd_arr[] = new byte[2];
-        badcmd_arr[0] = SEG_MOVETO;
-        for (int i = 0; i < 256; i++) {
-            switch (i) {
-                case SEG_MOVETO:
-                case SEG_LINETO:
-                case SEG_QUADTO:
-                case SEG_CUBICTO:
-                case SEG_CLOSE:
-                    continue;
-                default:
-                    badcmd_arr[1] = (byte) i;
-                    try {
-                        NativePiscesRasterizerShim.produceStrokeAlphas(coords6, badcmd_arr, 2,
-                                                                   10, CAP_ROUND, JOIN_ROUND, 10, null, 0,
-                                                                   1, 0, 0, 0, 1, 0,
-                                                                   bounds10, mask1k);
-                        throw new RuntimeException("allowed bad command: "+i);
-                    } catch (InternalError e) {
-                    }
-                    break;
-            }
-        }
-    }
-
-    @Test(expected=java.lang.ArrayIndexOutOfBoundsException.class)
-    public void StrokeShortMoveCoords() {
-        NativePiscesRasterizerShim.produceStrokeAlphas(coords1, move_arr, 1,
-                                                   10, CAP_ROUND, JOIN_ROUND, 10, null, 0,
-                                                   1, 0, 0, 0, 1, 0,
-                                                   bounds10, mask1k);
-    }
-
-    @Test(expected=java.lang.ArrayIndexOutOfBoundsException.class)
-    public void StrokeShortLineCoords() {
-        NativePiscesRasterizerShim.produceStrokeAlphas(coords3, moveline_arr, 2,
-                                                   10, CAP_ROUND, JOIN_ROUND, 10, null, 0,
-                                                   1, 0, 0, 0, 1, 0,
-                                                   bounds10, mask1k);
-    }
-
-    @Test(expected=java.lang.ArrayIndexOutOfBoundsException.class)
-    public void StrokeShortQuadCoords() {
-        NativePiscesRasterizerShim.produceStrokeAlphas(coords5, movequad_arr, 2,
-                                                   10, CAP_ROUND, JOIN_ROUND, 10, null, 0,
-                                                   1, 0, 0, 0, 1, 0,
-                                                   bounds10, mask1k);
-    }
-
-    @Test(expected=java.lang.ArrayIndexOutOfBoundsException.class)
-    public void StrokeShortCubicCoords() {
-        NativePiscesRasterizerShim.produceStrokeAlphas(coords7, movecubic_arr, 2,
-                                                   10, CAP_ROUND, JOIN_ROUND, 10, null, 0,
-                                                   1, 0, 0, 0, 1, 0,
-                                                   bounds10, mask1k);
-    }
-}

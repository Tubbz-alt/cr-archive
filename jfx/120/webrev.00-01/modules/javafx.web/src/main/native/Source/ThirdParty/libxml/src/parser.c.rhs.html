<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/parser.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 /*
    2  * parser.c : an XML 1.0 parser, namespaces and validity support are mostly
    3  *            implemented on top of the SAX interfaces
    4  *
    5  * References:
    6  *   The XML specification:
    7  *     http://www.w3.org/TR/REC-xml
    8  *   Original 1.0 version:
    9  *     http://www.w3.org/TR/1998/REC-xml-19980210
   10  *   XML second edition working draft
   11  *     http://www.w3.org/TR/2000/WD-xml-2e-20000814
   12  *
   13  * Okay this is a big file, the parser core is around 7000 lines, then it
   14  * is followed by the progressive parser top routines, then the various
   15  * high level APIs to call the parser and a few miscellaneous functions.
   16  * A number of helper functions and deprecated ones have been moved to
   17  * parserInternals.c to reduce this file size.
   18  * As much as possible the functions are associated with their relative
   19  * production in the XML specification. A few productions defining the
   20  * different ranges of character are actually implanted either in
   21  * parserInternals.h or parserInternals.c
   22  * The DOM tree build is realized from the default SAX callbacks in
   23  * the module SAX.c.
   24  * The routines doing the validation checks are in valid.c and called either
   25  * from the SAX callbacks or as standalone functions using a preparsed
   26  * document.
   27  *
   28  * See Copyright for the status of this software.
   29  *
   30  * daniel@veillard.com
   31  */
   32 
   33 /* To avoid EBCDIC trouble when parsing on zOS */
   34 #if defined(__MVS__)
   35 #pragma convert(&quot;ISO8859-1&quot;)
   36 #endif
   37 
   38 #define IN_LIBXML
   39 #include &quot;libxml.h&quot;
   40 
   41 #if defined(_WIN32) &amp;&amp; !defined (__CYGWIN__)
   42 #define XML_DIR_SEP &#39;\\&#39;
   43 #else
   44 #define XML_DIR_SEP &#39;/&#39;
   45 #endif
   46 
   47 #include &lt;stdlib.h&gt;
   48 #include &lt;limits.h&gt;
   49 #include &lt;string.h&gt;
   50 #include &lt;stdarg.h&gt;
   51 #include &lt;stddef.h&gt;
   52 #include &lt;libxml/xmlmemory.h&gt;
   53 #include &lt;libxml/threads.h&gt;
   54 #include &lt;libxml/globals.h&gt;
   55 #include &lt;libxml/tree.h&gt;
   56 #include &lt;libxml/parser.h&gt;
   57 #include &lt;libxml/parserInternals.h&gt;
   58 #include &lt;libxml/valid.h&gt;
   59 #include &lt;libxml/entities.h&gt;
   60 #include &lt;libxml/xmlerror.h&gt;
   61 #include &lt;libxml/encoding.h&gt;
   62 #include &lt;libxml/xmlIO.h&gt;
   63 #include &lt;libxml/uri.h&gt;
   64 #ifdef LIBXML_CATALOG_ENABLED
   65 #include &lt;libxml/catalog.h&gt;
   66 #endif
   67 #ifdef LIBXML_SCHEMAS_ENABLED
   68 #include &lt;libxml/xmlschemastypes.h&gt;
   69 #include &lt;libxml/relaxng.h&gt;
   70 #endif
   71 #ifdef HAVE_CTYPE_H
   72 #include &lt;ctype.h&gt;
   73 #endif
   74 #ifdef HAVE_STDLIB_H
   75 #include &lt;stdlib.h&gt;
   76 #endif
   77 #ifdef HAVE_SYS_STAT_H
   78 #include &lt;sys/stat.h&gt;
   79 #endif
   80 #ifdef HAVE_FCNTL_H
   81 #include &lt;fcntl.h&gt;
   82 #endif
   83 #ifdef HAVE_UNISTD_H
   84 #include &lt;unistd.h&gt;
   85 #endif
   86 
   87 #include &quot;buf.h&quot;
   88 #include &quot;enc.h&quot;
   89 
   90 static void
   91 xmlFatalErr(xmlParserCtxtPtr ctxt, xmlParserErrors error, const char *info);
   92 
   93 static xmlParserCtxtPtr
   94 xmlCreateEntityParserCtxtInternal(const xmlChar *URL, const xmlChar *ID,
   95                       const xmlChar *base, xmlParserCtxtPtr pctx);
   96 
   97 static void xmlHaltParser(xmlParserCtxtPtr ctxt);
   98 
   99 static int
  100 xmlParseElementStart(xmlParserCtxtPtr ctxt);
  101 
  102 static void
  103 xmlParseElementEnd(xmlParserCtxtPtr ctxt);
  104 
  105 /************************************************************************
  106  *                                  *
  107  *  Arbitrary limits set in the parser. See XML_PARSE_HUGE      *
  108  *                                  *
  109  ************************************************************************/
  110 
  111 #define XML_PARSER_BIG_ENTITY 1000
  112 #define XML_PARSER_LOT_ENTITY 5000
  113 
  114 /*
  115  * XML_PARSER_NON_LINEAR is the threshold where the ratio of parsed entity
  116  *    replacement over the size in byte of the input indicates that you have
  117  *    and exponential behaviour. A value of 10 correspond to at least 3 entity
  118  *    replacement per byte of input.
  119  */
  120 #define XML_PARSER_NON_LINEAR 10
  121 
  122 /*
  123  * xmlParserEntityCheck
  124  *
  125  * Function to check non-linear entity expansion behaviour
  126  * This is here to detect and stop exponential linear entity expansion
  127  * This is not a limitation of the parser but a safety
  128  * boundary feature. It can be disabled with the XML_PARSE_HUGE
  129  * parser option.
  130  */
  131 static int
  132 xmlParserEntityCheck(xmlParserCtxtPtr ctxt, size_t size,
  133                      xmlEntityPtr ent, size_t replacement)
  134 {
  135     size_t consumed = 0;
  136 
  137     if ((ctxt == NULL) || (ctxt-&gt;options &amp; XML_PARSE_HUGE))
  138         return (0);
  139     if (ctxt-&gt;lastError.code == XML_ERR_ENTITY_LOOP)
  140         return (1);
  141 
  142     /*
  143      * This may look absurd but is needed to detect
  144      * entities problems
  145      */
  146     if ((ent != NULL) &amp;&amp; (ent-&gt;etype != XML_INTERNAL_PREDEFINED_ENTITY) &amp;&amp;
  147     (ent-&gt;content != NULL) &amp;&amp; (ent-&gt;checked == 0) &amp;&amp;
  148     (ctxt-&gt;errNo != XML_ERR_ENTITY_LOOP)) {
  149     unsigned long oldnbent = ctxt-&gt;nbentities, diff;
  150     xmlChar *rep;
  151 
  152     ent-&gt;checked = 1;
  153 
  154         ++ctxt-&gt;depth;
  155     rep = xmlStringDecodeEntities(ctxt, ent-&gt;content,
  156                   XML_SUBSTITUTE_REF, 0, 0, 0);
  157         --ctxt-&gt;depth;
  158     if ((rep == NULL) || (ctxt-&gt;errNo == XML_ERR_ENTITY_LOOP)) {
  159         ent-&gt;content[0] = 0;
  160     }
  161 
  162         diff = ctxt-&gt;nbentities - oldnbent + 1;
  163         if (diff &gt; INT_MAX / 2)
  164             diff = INT_MAX / 2;
  165     ent-&gt;checked = diff * 2;
  166     if (rep != NULL) {
  167         if (xmlStrchr(rep, &#39;&lt;&#39;))
  168         ent-&gt;checked |= 1;
  169         xmlFree(rep);
  170         rep = NULL;
  171     }
  172     }
  173     if (replacement != 0) {
  174     if (replacement &lt; XML_MAX_TEXT_LENGTH)
  175         return(0);
  176 
  177         /*
  178      * If the volume of entity copy reaches 10 times the
  179      * amount of parsed data and over the large text threshold
  180      * then that&#39;s very likely to be an abuse.
  181      */
  182         if (ctxt-&gt;input != NULL) {
  183         consumed = ctxt-&gt;input-&gt;consumed +
  184                    (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
  185     }
  186         consumed += ctxt-&gt;sizeentities;
  187 
  188         if (replacement &lt; XML_PARSER_NON_LINEAR * consumed)
  189         return(0);
  190     } else if (size != 0) {
  191         /*
  192          * Do the check based on the replacement size of the entity
  193          */
  194         if (size &lt; XML_PARSER_BIG_ENTITY)
  195         return(0);
  196 
  197         /*
  198          * A limit on the amount of text data reasonably used
  199          */
  200         if (ctxt-&gt;input != NULL) {
  201             consumed = ctxt-&gt;input-&gt;consumed +
  202                 (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
  203         }
  204         consumed += ctxt-&gt;sizeentities;
  205 
  206         if ((size &lt; XML_PARSER_NON_LINEAR * consumed) &amp;&amp;
  207         (ctxt-&gt;nbentities * 3 &lt; XML_PARSER_NON_LINEAR * consumed))
  208             return (0);
  209     } else if (ent != NULL) {
  210         /*
  211          * use the number of parsed entities in the replacement
  212          */
  213         size = ent-&gt;checked / 2;
  214 
  215         /*
  216          * The amount of data parsed counting entities size only once
  217          */
  218         if (ctxt-&gt;input != NULL) {
  219             consumed = ctxt-&gt;input-&gt;consumed +
  220                 (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
  221         }
  222         consumed += ctxt-&gt;sizeentities;
  223 
  224         /*
  225          * Check the density of entities for the amount of data
  226      * knowing an entity reference will take at least 3 bytes
  227          */
  228         if (size * 3 &lt; consumed * XML_PARSER_NON_LINEAR)
  229             return (0);
  230     } else {
  231         /*
  232          * strange we got no data for checking
  233          */
  234     if (((ctxt-&gt;lastError.code != XML_ERR_UNDECLARED_ENTITY) &amp;&amp;
  235          (ctxt-&gt;lastError.code != XML_WAR_UNDECLARED_ENTITY)) ||
  236         (ctxt-&gt;nbentities &lt;= 10000))
  237         return (0);
  238     }
  239     xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
  240     return (1);
  241 }
  242 
  243 /**
  244  * xmlParserMaxDepth:
  245  *
  246  * arbitrary depth limit for the XML documents that we allow to
  247  * process. This is not a limitation of the parser but a safety
  248  * boundary feature. It can be disabled with the XML_PARSE_HUGE
  249  * parser option.
  250  */
  251 unsigned int xmlParserMaxDepth = 256;
  252 
  253 
  254 
  255 #define SAX2 1
  256 #define XML_PARSER_BIG_BUFFER_SIZE 300
  257 #define XML_PARSER_BUFFER_SIZE 100
  258 #define SAX_COMPAT_MODE BAD_CAST &quot;SAX compatibility mode document&quot;
  259 
  260 /**
  261  * XML_PARSER_CHUNK_SIZE
  262  *
  263  * When calling GROW that&#39;s the minimal amount of data
  264  * the parser expected to have received. It is not a hard
  265  * limit but an optimization when reading strings like Names
  266  * It is not strictly needed as long as inputs available characters
  267  * are followed by 0, which should be provided by the I/O level
  268  */
  269 #define XML_PARSER_CHUNK_SIZE 100
  270 
  271 /*
  272  * List of XML prefixed PI allowed by W3C specs
  273  */
  274 
  275 static const char *xmlW3CPIs[] = {
  276     &quot;xml-stylesheet&quot;,
  277     &quot;xml-model&quot;,
  278     NULL
  279 };
  280 
  281 
  282 /* DEPR void xmlParserHandleReference(xmlParserCtxtPtr ctxt); */
  283 static xmlEntityPtr xmlParseStringPEReference(xmlParserCtxtPtr ctxt,
  284                                               const xmlChar **str);
  285 
  286 static xmlParserErrors
  287 xmlParseExternalEntityPrivate(xmlDocPtr doc, xmlParserCtxtPtr oldctxt,
  288                   xmlSAXHandlerPtr sax,
  289               void *user_data, int depth, const xmlChar *URL,
  290               const xmlChar *ID, xmlNodePtr *list);
  291 
  292 static int
  293 xmlCtxtUseOptionsInternal(xmlParserCtxtPtr ctxt, int options,
  294                           const char *encoding);
  295 #ifdef LIBXML_LEGACY_ENABLED
  296 static void
  297 xmlAddEntityReference(xmlEntityPtr ent, xmlNodePtr firstNode,
  298                       xmlNodePtr lastNode);
  299 #endif /* LIBXML_LEGACY_ENABLED */
  300 
  301 static xmlParserErrors
  302 xmlParseBalancedChunkMemoryInternal(xmlParserCtxtPtr oldctxt,
  303               const xmlChar *string, void *user_data, xmlNodePtr *lst);
  304 
  305 static int
  306 xmlLoadEntityContent(xmlParserCtxtPtr ctxt, xmlEntityPtr entity);
  307 
  308 /************************************************************************
  309  *                                  *
  310  *      Some factorized error routines              *
  311  *                                  *
  312  ************************************************************************/
  313 
  314 /**
  315  * xmlErrAttributeDup:
  316  * @ctxt:  an XML parser context
  317  * @prefix:  the attribute prefix
  318  * @localname:  the attribute localname
  319  *
  320  * Handle a redefinition of attribute error
  321  */
  322 static void
  323 xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
  324                    const xmlChar * localname)
  325 {
  326     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  327         (ctxt-&gt;instate == XML_PARSER_EOF))
  328     return;
  329     if (ctxt != NULL)
  330     ctxt-&gt;errNo = XML_ERR_ATTRIBUTE_REDEFINED;
  331 
  332     if (prefix == NULL)
  333         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,
  334                         XML_ERR_ATTRIBUTE_REDEFINED, XML_ERR_FATAL, NULL, 0,
  335                         (const char *) localname, NULL, NULL, 0, 0,
  336                         &quot;Attribute %s redefined\n&quot;, localname);
  337     else
  338         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,
  339                         XML_ERR_ATTRIBUTE_REDEFINED, XML_ERR_FATAL, NULL, 0,
  340                         (const char *) prefix, (const char *) localname,
  341                         NULL, 0, 0, &quot;Attribute %s:%s redefined\n&quot;, prefix,
  342                         localname);
  343     if (ctxt != NULL) {
  344     ctxt-&gt;wellFormed = 0;
  345     if (ctxt-&gt;recovery == 0)
  346         ctxt-&gt;disableSAX = 1;
  347     }
  348 }
  349 
  350 /**
  351  * xmlFatalErr:
  352  * @ctxt:  an XML parser context
  353  * @error:  the error number
  354  * @extra:  extra information string
  355  *
  356  * Handle a fatal parser error, i.e. violating Well-Formedness constraints
  357  */
  358 static void
  359 xmlFatalErr(xmlParserCtxtPtr ctxt, xmlParserErrors error, const char *info)
  360 {
  361     const char *errmsg;
  362 
  363     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  364         (ctxt-&gt;instate == XML_PARSER_EOF))
  365     return;
  366     switch (error) {
  367         case XML_ERR_INVALID_HEX_CHARREF:
  368             errmsg = &quot;CharRef: invalid hexadecimal value&quot;;
  369             break;
  370         case XML_ERR_INVALID_DEC_CHARREF:
  371             errmsg = &quot;CharRef: invalid decimal value&quot;;
  372             break;
  373         case XML_ERR_INVALID_CHARREF:
  374             errmsg = &quot;CharRef: invalid value&quot;;
  375             break;
  376         case XML_ERR_INTERNAL_ERROR:
  377             errmsg = &quot;internal error&quot;;
  378             break;
  379         case XML_ERR_PEREF_AT_EOF:
  380             errmsg = &quot;PEReference at end of document&quot;;
  381             break;
  382         case XML_ERR_PEREF_IN_PROLOG:
  383             errmsg = &quot;PEReference in prolog&quot;;
  384             break;
  385         case XML_ERR_PEREF_IN_EPILOG:
  386             errmsg = &quot;PEReference in epilog&quot;;
  387             break;
  388         case XML_ERR_PEREF_NO_NAME:
  389             errmsg = &quot;PEReference: no name&quot;;
  390             break;
  391         case XML_ERR_PEREF_SEMICOL_MISSING:
  392             errmsg = &quot;PEReference: expecting &#39;;&#39;&quot;;
  393             break;
  394         case XML_ERR_ENTITY_LOOP:
  395             errmsg = &quot;Detected an entity reference loop&quot;;
  396             break;
  397         case XML_ERR_ENTITY_NOT_STARTED:
  398             errmsg = &quot;EntityValue: \&quot; or &#39; expected&quot;;
  399             break;
  400         case XML_ERR_ENTITY_PE_INTERNAL:
  401             errmsg = &quot;PEReferences forbidden in internal subset&quot;;
  402             break;
  403         case XML_ERR_ENTITY_NOT_FINISHED:
  404             errmsg = &quot;EntityValue: \&quot; or &#39; expected&quot;;
  405             break;
  406         case XML_ERR_ATTRIBUTE_NOT_STARTED:
  407             errmsg = &quot;AttValue: \&quot; or &#39; expected&quot;;
  408             break;
  409         case XML_ERR_LT_IN_ATTRIBUTE:
  410             errmsg = &quot;Unescaped &#39;&lt;&#39; not allowed in attributes values&quot;;
  411             break;
  412         case XML_ERR_LITERAL_NOT_STARTED:
  413             errmsg = &quot;SystemLiteral \&quot; or &#39; expected&quot;;
  414             break;
  415         case XML_ERR_LITERAL_NOT_FINISHED:
  416             errmsg = &quot;Unfinished System or Public ID \&quot; or &#39; expected&quot;;
  417             break;
  418         case XML_ERR_MISPLACED_CDATA_END:
  419             errmsg = &quot;Sequence &#39;]]&gt;&#39; not allowed in content&quot;;
  420             break;
  421         case XML_ERR_URI_REQUIRED:
  422             errmsg = &quot;SYSTEM or PUBLIC, the URI is missing&quot;;
  423             break;
  424         case XML_ERR_PUBID_REQUIRED:
  425             errmsg = &quot;PUBLIC, the Public Identifier is missing&quot;;
  426             break;
  427         case XML_ERR_HYPHEN_IN_COMMENT:
  428             errmsg = &quot;Comment must not contain &#39;--&#39; (double-hyphen)&quot;;
  429             break;
  430         case XML_ERR_PI_NOT_STARTED:
  431             errmsg = &quot;xmlParsePI : no target name&quot;;
  432             break;
  433         case XML_ERR_RESERVED_XML_NAME:
  434             errmsg = &quot;Invalid PI name&quot;;
  435             break;
  436         case XML_ERR_NOTATION_NOT_STARTED:
  437             errmsg = &quot;NOTATION: Name expected here&quot;;
  438             break;
  439         case XML_ERR_NOTATION_NOT_FINISHED:
  440             errmsg = &quot;&#39;&gt;&#39; required to close NOTATION declaration&quot;;
  441             break;
  442         case XML_ERR_VALUE_REQUIRED:
  443             errmsg = &quot;Entity value required&quot;;
  444             break;
  445         case XML_ERR_URI_FRAGMENT:
  446             errmsg = &quot;Fragment not allowed&quot;;
  447             break;
  448         case XML_ERR_ATTLIST_NOT_STARTED:
  449             errmsg = &quot;&#39;(&#39; required to start ATTLIST enumeration&quot;;
  450             break;
  451         case XML_ERR_NMTOKEN_REQUIRED:
  452             errmsg = &quot;NmToken expected in ATTLIST enumeration&quot;;
  453             break;
  454         case XML_ERR_ATTLIST_NOT_FINISHED:
  455             errmsg = &quot;&#39;)&#39; required to finish ATTLIST enumeration&quot;;
  456             break;
  457         case XML_ERR_MIXED_NOT_STARTED:
  458             errmsg = &quot;MixedContentDecl : &#39;|&#39; or &#39;)*&#39; expected&quot;;
  459             break;
  460         case XML_ERR_PCDATA_REQUIRED:
  461             errmsg = &quot;MixedContentDecl : &#39;#PCDATA&#39; expected&quot;;
  462             break;
  463         case XML_ERR_ELEMCONTENT_NOT_STARTED:
  464             errmsg = &quot;ContentDecl : Name or &#39;(&#39; expected&quot;;
  465             break;
  466         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
  467             errmsg = &quot;ContentDecl : &#39;,&#39; &#39;|&#39; or &#39;)&#39; expected&quot;;
  468             break;
  469         case XML_ERR_PEREF_IN_INT_SUBSET:
  470             errmsg =
  471                 &quot;PEReference: forbidden within markup decl in internal subset&quot;;
  472             break;
  473         case XML_ERR_GT_REQUIRED:
  474             errmsg = &quot;expected &#39;&gt;&#39;&quot;;
  475             break;
  476         case XML_ERR_CONDSEC_INVALID:
  477             errmsg = &quot;XML conditional section &#39;[&#39; expected&quot;;
  478             break;
  479         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
  480             errmsg = &quot;Content error in the external subset&quot;;
  481             break;
  482         case XML_ERR_CONDSEC_INVALID_KEYWORD:
  483             errmsg =
  484                 &quot;conditional section INCLUDE or IGNORE keyword expected&quot;;
  485             break;
  486         case XML_ERR_CONDSEC_NOT_FINISHED:
  487             errmsg = &quot;XML conditional section not closed&quot;;
  488             break;
  489         case XML_ERR_XMLDECL_NOT_STARTED:
  490             errmsg = &quot;Text declaration &#39;&lt;?xml&#39; required&quot;;
  491             break;
  492         case XML_ERR_XMLDECL_NOT_FINISHED:
  493             errmsg = &quot;parsing XML declaration: &#39;?&gt;&#39; expected&quot;;
  494             break;
  495         case XML_ERR_EXT_ENTITY_STANDALONE:
  496             errmsg = &quot;external parsed entities cannot be standalone&quot;;
  497             break;
  498         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
  499             errmsg = &quot;EntityRef: expecting &#39;;&#39;&quot;;
  500             break;
  501         case XML_ERR_DOCTYPE_NOT_FINISHED:
  502             errmsg = &quot;DOCTYPE improperly terminated&quot;;
  503             break;
  504         case XML_ERR_LTSLASH_REQUIRED:
  505             errmsg = &quot;EndTag: &#39;&lt;/&#39; not found&quot;;
  506             break;
  507         case XML_ERR_EQUAL_REQUIRED:
  508             errmsg = &quot;expected &#39;=&#39;&quot;;
  509             break;
  510         case XML_ERR_STRING_NOT_CLOSED:
  511             errmsg = &quot;String not closed expecting \&quot; or &#39;&quot;;
  512             break;
  513         case XML_ERR_STRING_NOT_STARTED:
  514             errmsg = &quot;String not started expecting &#39; or \&quot;&quot;;
  515             break;
  516         case XML_ERR_ENCODING_NAME:
  517             errmsg = &quot;Invalid XML encoding name&quot;;
  518             break;
  519         case XML_ERR_STANDALONE_VALUE:
  520             errmsg = &quot;standalone accepts only &#39;yes&#39; or &#39;no&#39;&quot;;
  521             break;
  522         case XML_ERR_DOCUMENT_EMPTY:
  523             errmsg = &quot;Document is empty&quot;;
  524             break;
  525         case XML_ERR_DOCUMENT_END:
  526             errmsg = &quot;Extra content at the end of the document&quot;;
  527             break;
  528         case XML_ERR_NOT_WELL_BALANCED:
  529             errmsg = &quot;chunk is not well balanced&quot;;
  530             break;
  531         case XML_ERR_EXTRA_CONTENT:
  532             errmsg = &quot;extra content at the end of well balanced chunk&quot;;
  533             break;
  534         case XML_ERR_VERSION_MISSING:
  535             errmsg = &quot;Malformed declaration expecting version&quot;;
  536             break;
  537         case XML_ERR_NAME_TOO_LONG:
  538             errmsg = &quot;Name too long use XML_PARSE_HUGE option&quot;;
  539             break;
  540 #if 0
  541         case:
  542             errmsg = &quot;&quot;;
  543             break;
  544 #endif
  545         default:
  546             errmsg = &quot;Unregistered error message&quot;;
  547     }
  548     if (ctxt != NULL)
  549     ctxt-&gt;errNo = error;
  550     if (info == NULL) {
  551         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
  552                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, &quot;%s\n&quot;,
  553                         errmsg);
  554     } else {
  555         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
  556                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, &quot;%s: %s\n&quot;,
  557                         errmsg, info);
  558     }
  559     if (ctxt != NULL) {
  560     ctxt-&gt;wellFormed = 0;
  561     if (ctxt-&gt;recovery == 0)
  562         ctxt-&gt;disableSAX = 1;
  563     }
  564 }
  565 
  566 /**
  567  * xmlFatalErrMsg:
  568  * @ctxt:  an XML parser context
  569  * @error:  the error number
  570  * @msg:  the error message
  571  *
  572  * Handle a fatal parser error, i.e. violating Well-Formedness constraints
  573  */
  574 static void LIBXML_ATTR_FORMAT(3,0)
  575 xmlFatalErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
  576                const char *msg)
  577 {
  578     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  579         (ctxt-&gt;instate == XML_PARSER_EOF))
  580     return;
  581     if (ctxt != NULL)
  582     ctxt-&gt;errNo = error;
  583     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
  584                     XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, &quot;%s&quot;, msg);
  585     if (ctxt != NULL) {
  586     ctxt-&gt;wellFormed = 0;
  587     if (ctxt-&gt;recovery == 0)
  588         ctxt-&gt;disableSAX = 1;
  589     }
  590 }
  591 
  592 /**
  593  * xmlWarningMsg:
  594  * @ctxt:  an XML parser context
  595  * @error:  the error number
  596  * @msg:  the error message
  597  * @str1:  extra data
  598  * @str2:  extra data
  599  *
  600  * Handle a warning.
  601  */
  602 static void LIBXML_ATTR_FORMAT(3,0)
  603 xmlWarningMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
  604               const char *msg, const xmlChar *str1, const xmlChar *str2)
  605 {
  606     xmlStructuredErrorFunc schannel = NULL;
  607 
  608     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  609         (ctxt-&gt;instate == XML_PARSER_EOF))
  610     return;
  611     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;sax != NULL) &amp;&amp;
  612         (ctxt-&gt;sax-&gt;initialized == XML_SAX2_MAGIC))
  613         schannel = ctxt-&gt;sax-&gt;serror;
  614     if (ctxt != NULL) {
  615         __xmlRaiseError(schannel,
  616                     (ctxt-&gt;sax) ? ctxt-&gt;sax-&gt;warning : NULL,
  617                     ctxt-&gt;userData,
  618                     ctxt, NULL, XML_FROM_PARSER, error,
  619                     XML_ERR_WARNING, NULL, 0,
  620             (const char *) str1, (const char *) str2, NULL, 0, 0,
  621             msg, (const char *) str1, (const char *) str2);
  622     } else {
  623         __xmlRaiseError(schannel, NULL, NULL,
  624                     ctxt, NULL, XML_FROM_PARSER, error,
  625                     XML_ERR_WARNING, NULL, 0,
  626             (const char *) str1, (const char *) str2, NULL, 0, 0,
  627             msg, (const char *) str1, (const char *) str2);
  628     }
  629 }
  630 
  631 /**
  632  * xmlValidityError:
  633  * @ctxt:  an XML parser context
  634  * @error:  the error number
  635  * @msg:  the error message
  636  * @str1:  extra data
  637  *
  638  * Handle a validity error.
  639  */
  640 static void LIBXML_ATTR_FORMAT(3,0)
  641 xmlValidityError(xmlParserCtxtPtr ctxt, xmlParserErrors error,
  642               const char *msg, const xmlChar *str1, const xmlChar *str2)
  643 {
  644     xmlStructuredErrorFunc schannel = NULL;
  645 
  646     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  647         (ctxt-&gt;instate == XML_PARSER_EOF))
  648     return;
  649     if (ctxt != NULL) {
  650     ctxt-&gt;errNo = error;
  651     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;initialized == XML_SAX2_MAGIC))
  652         schannel = ctxt-&gt;sax-&gt;serror;
  653     }
  654     if (ctxt != NULL) {
  655         __xmlRaiseError(schannel,
  656                     ctxt-&gt;vctxt.error, ctxt-&gt;vctxt.userData,
  657                     ctxt, NULL, XML_FROM_DTD, error,
  658                     XML_ERR_ERROR, NULL, 0, (const char *) str1,
  659             (const char *) str2, NULL, 0, 0,
  660             msg, (const char *) str1, (const char *) str2);
  661     ctxt-&gt;valid = 0;
  662     } else {
  663         __xmlRaiseError(schannel, NULL, NULL,
  664                     ctxt, NULL, XML_FROM_DTD, error,
  665                     XML_ERR_ERROR, NULL, 0, (const char *) str1,
  666             (const char *) str2, NULL, 0, 0,
  667             msg, (const char *) str1, (const char *) str2);
  668     }
  669 }
  670 
  671 /**
  672  * xmlFatalErrMsgInt:
  673  * @ctxt:  an XML parser context
  674  * @error:  the error number
  675  * @msg:  the error message
  676  * @val:  an integer value
  677  *
  678  * Handle a fatal parser error, i.e. violating Well-Formedness constraints
  679  */
  680 static void LIBXML_ATTR_FORMAT(3,0)
  681 xmlFatalErrMsgInt(xmlParserCtxtPtr ctxt, xmlParserErrors error,
  682                   const char *msg, int val)
  683 {
  684     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  685         (ctxt-&gt;instate == XML_PARSER_EOF))
  686     return;
  687     if (ctxt != NULL)
  688     ctxt-&gt;errNo = error;
  689     __xmlRaiseError(NULL, NULL, NULL,
  690                     ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
  691                     NULL, 0, NULL, NULL, NULL, val, 0, msg, val);
  692     if (ctxt != NULL) {
  693     ctxt-&gt;wellFormed = 0;
  694     if (ctxt-&gt;recovery == 0)
  695         ctxt-&gt;disableSAX = 1;
  696     }
  697 }
  698 
  699 /**
  700  * xmlFatalErrMsgStrIntStr:
  701  * @ctxt:  an XML parser context
  702  * @error:  the error number
  703  * @msg:  the error message
  704  * @str1:  an string info
  705  * @val:  an integer value
  706  * @str2:  an string info
  707  *
  708  * Handle a fatal parser error, i.e. violating Well-Formedness constraints
  709  */
  710 static void LIBXML_ATTR_FORMAT(3,0)
  711 xmlFatalErrMsgStrIntStr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
  712                   const char *msg, const xmlChar *str1, int val,
  713           const xmlChar *str2)
  714 {
  715     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  716         (ctxt-&gt;instate == XML_PARSER_EOF))
  717     return;
  718     if (ctxt != NULL)
  719     ctxt-&gt;errNo = error;
  720     __xmlRaiseError(NULL, NULL, NULL,
  721                     ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
  722                     NULL, 0, (const char *) str1, (const char *) str2,
  723             NULL, val, 0, msg, str1, val, str2);
  724     if (ctxt != NULL) {
  725     ctxt-&gt;wellFormed = 0;
  726     if (ctxt-&gt;recovery == 0)
  727         ctxt-&gt;disableSAX = 1;
  728     }
  729 }
  730 
  731 /**
  732  * xmlFatalErrMsgStr:
  733  * @ctxt:  an XML parser context
  734  * @error:  the error number
  735  * @msg:  the error message
  736  * @val:  a string value
  737  *
  738  * Handle a fatal parser error, i.e. violating Well-Formedness constraints
  739  */
  740 static void LIBXML_ATTR_FORMAT(3,0)
  741 xmlFatalErrMsgStr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
  742                   const char *msg, const xmlChar * val)
  743 {
  744     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  745         (ctxt-&gt;instate == XML_PARSER_EOF))
  746     return;
  747     if (ctxt != NULL)
  748     ctxt-&gt;errNo = error;
  749     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL,
  750                     XML_FROM_PARSER, error, XML_ERR_FATAL,
  751                     NULL, 0, (const char *) val, NULL, NULL, 0, 0, msg,
  752                     val);
  753     if (ctxt != NULL) {
  754     ctxt-&gt;wellFormed = 0;
  755     if (ctxt-&gt;recovery == 0)
  756         ctxt-&gt;disableSAX = 1;
  757     }
  758 }
  759 
  760 /**
  761  * xmlErrMsgStr:
  762  * @ctxt:  an XML parser context
  763  * @error:  the error number
  764  * @msg:  the error message
  765  * @val:  a string value
  766  *
  767  * Handle a non fatal parser error
  768  */
  769 static void LIBXML_ATTR_FORMAT(3,0)
  770 xmlErrMsgStr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
  771                   const char *msg, const xmlChar * val)
  772 {
  773     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  774         (ctxt-&gt;instate == XML_PARSER_EOF))
  775     return;
  776     if (ctxt != NULL)
  777     ctxt-&gt;errNo = error;
  778     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL,
  779                     XML_FROM_PARSER, error, XML_ERR_ERROR,
  780                     NULL, 0, (const char *) val, NULL, NULL, 0, 0, msg,
  781                     val);
  782 }
  783 
  784 /**
  785  * xmlNsErr:
  786  * @ctxt:  an XML parser context
  787  * @error:  the error number
  788  * @msg:  the message
  789  * @info1:  extra information string
  790  * @info2:  extra information string
  791  *
  792  * Handle a fatal parser error, i.e. violating Well-Formedness constraints
  793  */
  794 static void LIBXML_ATTR_FORMAT(3,0)
  795 xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
  796          const char *msg,
  797          const xmlChar * info1, const xmlChar * info2,
  798          const xmlChar * info3)
  799 {
  800     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  801         (ctxt-&gt;instate == XML_PARSER_EOF))
  802     return;
  803     if (ctxt != NULL)
  804     ctxt-&gt;errNo = error;
  805     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
  806                     XML_ERR_ERROR, NULL, 0, (const char *) info1,
  807                     (const char *) info2, (const char *) info3, 0, 0, msg,
  808                     info1, info2, info3);
  809     if (ctxt != NULL)
  810     ctxt-&gt;nsWellFormed = 0;
  811 }
  812 
  813 /**
  814  * xmlNsWarn
  815  * @ctxt:  an XML parser context
  816  * @error:  the error number
  817  * @msg:  the message
  818  * @info1:  extra information string
  819  * @info2:  extra information string
  820  *
  821  * Handle a namespace warning error
  822  */
  823 static void LIBXML_ATTR_FORMAT(3,0)
  824 xmlNsWarn(xmlParserCtxtPtr ctxt, xmlParserErrors error,
  825          const char *msg,
  826          const xmlChar * info1, const xmlChar * info2,
  827          const xmlChar * info3)
  828 {
  829     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  830         (ctxt-&gt;instate == XML_PARSER_EOF))
  831     return;
  832     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
  833                     XML_ERR_WARNING, NULL, 0, (const char *) info1,
  834                     (const char *) info2, (const char *) info3, 0, 0, msg,
  835                     info1, info2, info3);
  836 }
  837 
  838 /************************************************************************
  839  *                                  *
  840  *      Library wide options                    *
  841  *                                  *
  842  ************************************************************************/
  843 
  844 /**
  845   * xmlHasFeature:
  846   * @feature: the feature to be examined
  847   *
  848   * Examines if the library has been compiled with a given feature.
  849   *
  850   * Returns a non-zero value if the feature exist, otherwise zero.
  851   * Returns zero (0) if the feature does not exist or an unknown
  852   * unknown feature is requested, non-zero otherwise.
  853   */
  854 int
  855 xmlHasFeature(xmlFeature feature)
  856 {
  857     switch (feature) {
  858     case XML_WITH_THREAD:
  859 #ifdef LIBXML_THREAD_ENABLED
  860         return(1);
  861 #else
  862         return(0);
  863 #endif
  864         case XML_WITH_TREE:
  865 #ifdef LIBXML_TREE_ENABLED
  866             return(1);
  867 #else
  868             return(0);
  869 #endif
  870         case XML_WITH_OUTPUT:
  871 #ifdef LIBXML_OUTPUT_ENABLED
  872             return(1);
  873 #else
  874             return(0);
  875 #endif
  876         case XML_WITH_PUSH:
  877 #ifdef LIBXML_PUSH_ENABLED
  878             return(1);
  879 #else
  880             return(0);
  881 #endif
  882         case XML_WITH_READER:
  883 #ifdef LIBXML_READER_ENABLED
  884             return(1);
  885 #else
  886             return(0);
  887 #endif
  888         case XML_WITH_PATTERN:
  889 #ifdef LIBXML_PATTERN_ENABLED
  890             return(1);
  891 #else
  892             return(0);
  893 #endif
  894         case XML_WITH_WRITER:
  895 #ifdef LIBXML_WRITER_ENABLED
  896             return(1);
  897 #else
  898             return(0);
  899 #endif
  900         case XML_WITH_SAX1:
  901 #ifdef LIBXML_SAX1_ENABLED
  902             return(1);
  903 #else
  904             return(0);
  905 #endif
  906         case XML_WITH_FTP:
  907 #ifdef LIBXML_FTP_ENABLED
  908             return(1);
  909 #else
  910             return(0);
  911 #endif
  912         case XML_WITH_HTTP:
  913 #ifdef LIBXML_HTTP_ENABLED
  914             return(1);
  915 #else
  916             return(0);
  917 #endif
  918         case XML_WITH_VALID:
  919 #ifdef LIBXML_VALID_ENABLED
  920             return(1);
  921 #else
  922             return(0);
  923 #endif
  924         case XML_WITH_HTML:
  925 #ifdef LIBXML_HTML_ENABLED
  926             return(1);
  927 #else
  928             return(0);
  929 #endif
  930         case XML_WITH_LEGACY:
  931 #ifdef LIBXML_LEGACY_ENABLED
  932             return(1);
  933 #else
  934             return(0);
  935 #endif
  936         case XML_WITH_C14N:
  937 #ifdef LIBXML_C14N_ENABLED
  938             return(1);
  939 #else
  940             return(0);
  941 #endif
  942         case XML_WITH_CATALOG:
  943 #ifdef LIBXML_CATALOG_ENABLED
  944             return(1);
  945 #else
  946             return(0);
  947 #endif
  948         case XML_WITH_XPATH:
  949 #ifdef LIBXML_XPATH_ENABLED
  950             return(1);
  951 #else
  952             return(0);
  953 #endif
  954         case XML_WITH_XPTR:
  955 #ifdef LIBXML_XPTR_ENABLED
  956             return(1);
  957 #else
  958             return(0);
  959 #endif
  960         case XML_WITH_XINCLUDE:
  961 #ifdef LIBXML_XINCLUDE_ENABLED
  962             return(1);
  963 #else
  964             return(0);
  965 #endif
  966         case XML_WITH_ICONV:
  967 #ifdef LIBXML_ICONV_ENABLED
  968             return(1);
  969 #else
  970             return(0);
  971 #endif
  972         case XML_WITH_ISO8859X:
  973 #ifdef LIBXML_ISO8859X_ENABLED
  974             return(1);
  975 #else
  976             return(0);
  977 #endif
  978         case XML_WITH_UNICODE:
  979 #ifdef LIBXML_UNICODE_ENABLED
  980             return(1);
  981 #else
  982             return(0);
  983 #endif
  984         case XML_WITH_REGEXP:
  985 #ifdef LIBXML_REGEXP_ENABLED
  986             return(1);
  987 #else
  988             return(0);
  989 #endif
  990         case XML_WITH_AUTOMATA:
  991 #ifdef LIBXML_AUTOMATA_ENABLED
  992             return(1);
  993 #else
  994             return(0);
  995 #endif
  996         case XML_WITH_EXPR:
  997 #ifdef LIBXML_EXPR_ENABLED
  998             return(1);
  999 #else
 1000             return(0);
 1001 #endif
 1002         case XML_WITH_SCHEMAS:
 1003 #ifdef LIBXML_SCHEMAS_ENABLED
 1004             return(1);
 1005 #else
 1006             return(0);
 1007 #endif
 1008         case XML_WITH_SCHEMATRON:
 1009 #ifdef LIBXML_SCHEMATRON_ENABLED
 1010             return(1);
 1011 #else
 1012             return(0);
 1013 #endif
 1014         case XML_WITH_MODULES:
 1015 #ifdef LIBXML_MODULES_ENABLED
 1016             return(1);
 1017 #else
 1018             return(0);
 1019 #endif
 1020         case XML_WITH_DEBUG:
 1021 #ifdef LIBXML_DEBUG_ENABLED
 1022             return(1);
 1023 #else
 1024             return(0);
 1025 #endif
 1026         case XML_WITH_DEBUG_MEM:
 1027 #ifdef DEBUG_MEMORY_LOCATION
 1028             return(1);
 1029 #else
 1030             return(0);
 1031 #endif
 1032         case XML_WITH_DEBUG_RUN:
 1033 #ifdef LIBXML_DEBUG_RUNTIME
 1034             return(1);
 1035 #else
 1036             return(0);
 1037 #endif
 1038         case XML_WITH_ZLIB:
 1039 #ifdef LIBXML_ZLIB_ENABLED
 1040             return(1);
 1041 #else
 1042             return(0);
 1043 #endif
 1044         case XML_WITH_LZMA:
 1045 #ifdef LIBXML_LZMA_ENABLED
 1046             return(1);
 1047 #else
 1048             return(0);
 1049 #endif
 1050         case XML_WITH_ICU:
 1051 #ifdef LIBXML_ICU_ENABLED
 1052             return(1);
 1053 #else
 1054             return(0);
 1055 #endif
 1056         default:
 1057         break;
 1058      }
 1059      return(0);
 1060 }
 1061 
 1062 /************************************************************************
 1063  *                                  *
 1064  *      SAX2 defaulted attributes handling          *
 1065  *                                  *
 1066  ************************************************************************/
 1067 
 1068 /**
 1069  * xmlDetectSAX2:
 1070  * @ctxt:  an XML parser context
 1071  *
 1072  * Do the SAX2 detection and specific initialization
 1073  */
 1074 static void
 1075 xmlDetectSAX2(xmlParserCtxtPtr ctxt) {
 1076     if (ctxt == NULL) return;
 1077 #ifdef LIBXML_SAX1_ENABLED
 1078     if ((ctxt-&gt;sax) &amp;&amp;  (ctxt-&gt;sax-&gt;initialized == XML_SAX2_MAGIC) &amp;&amp;
 1079         ((ctxt-&gt;sax-&gt;startElementNs != NULL) ||
 1080          (ctxt-&gt;sax-&gt;endElementNs != NULL))) ctxt-&gt;sax2 = 1;
 1081 #else
 1082     ctxt-&gt;sax2 = 1;
 1083 #endif /* LIBXML_SAX1_ENABLED */
 1084 
 1085     ctxt-&gt;str_xml = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xml&quot;, 3);
 1086     ctxt-&gt;str_xmlns = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xmlns&quot;, 5);
 1087     ctxt-&gt;str_xml_ns = xmlDictLookup(ctxt-&gt;dict, XML_XML_NAMESPACE, 36);
 1088     if ((ctxt-&gt;str_xml==NULL) || (ctxt-&gt;str_xmlns==NULL) ||
 1089         (ctxt-&gt;str_xml_ns == NULL)) {
 1090         xmlErrMemory(ctxt, NULL);
 1091     }
 1092 }
 1093 
 1094 typedef struct _xmlDefAttrs xmlDefAttrs;
 1095 typedef xmlDefAttrs *xmlDefAttrsPtr;
 1096 struct _xmlDefAttrs {
 1097     int nbAttrs;    /* number of defaulted attributes on that element */
 1098     int maxAttrs;       /* the size of the array */
 1099 #if __STDC_VERSION__ &gt;= 199901L
 1100     /* Using a C99 flexible array member avoids UBSan errors. */
 1101     const xmlChar *values[]; /* array of localname/prefix/values/external */
 1102 #else
 1103     const xmlChar *values[5];
 1104 #endif
 1105 };
 1106 
 1107 /**
 1108  * xmlAttrNormalizeSpace:
 1109  * @src: the source string
 1110  * @dst: the target string
 1111  *
 1112  * Normalize the space in non CDATA attribute values:
 1113  * If the attribute type is not CDATA, then the XML processor MUST further
 1114  * process the normalized attribute value by discarding any leading and
 1115  * trailing space (#x20) characters, and by replacing sequences of space
 1116  * (#x20) characters by a single space (#x20) character.
 1117  * Note that the size of dst need to be at least src, and if one doesn&#39;t need
 1118  * to preserve dst (and it doesn&#39;t come from a dictionary or read-only) then
 1119  * passing src as dst is just fine.
 1120  *
 1121  * Returns a pointer to the normalized value (dst) or NULL if no conversion
 1122  *         is needed.
 1123  */
 1124 static xmlChar *
 1125 xmlAttrNormalizeSpace(const xmlChar *src, xmlChar *dst)
 1126 {
 1127     if ((src == NULL) || (dst == NULL))
 1128         return(NULL);
 1129 
 1130     while (*src == 0x20) src++;
 1131     while (*src != 0) {
 1132     if (*src == 0x20) {
 1133         while (*src == 0x20) src++;
 1134         if (*src != 0)
 1135         *dst++ = 0x20;
 1136     } else {
 1137         *dst++ = *src++;
 1138     }
 1139     }
 1140     *dst = 0;
 1141     if (dst == src)
 1142        return(NULL);
 1143     return(dst);
 1144 }
 1145 
 1146 /**
 1147  * xmlAttrNormalizeSpace2:
 1148  * @src: the source string
 1149  *
 1150  * Normalize the space in non CDATA attribute values, a slightly more complex
 1151  * front end to avoid allocation problems when running on attribute values
 1152  * coming from the input.
 1153  *
 1154  * Returns a pointer to the normalized value (dst) or NULL if no conversion
 1155  *         is needed.
 1156  */
 1157 static const xmlChar *
 1158 xmlAttrNormalizeSpace2(xmlParserCtxtPtr ctxt, xmlChar *src, int *len)
 1159 {
 1160     int i;
 1161     int remove_head = 0;
 1162     int need_realloc = 0;
 1163     const xmlChar *cur;
 1164 
 1165     if ((ctxt == NULL) || (src == NULL) || (len == NULL))
 1166         return(NULL);
 1167     i = *len;
 1168     if (i &lt;= 0)
 1169         return(NULL);
 1170 
 1171     cur = src;
 1172     while (*cur == 0x20) {
 1173         cur++;
 1174     remove_head++;
 1175     }
 1176     while (*cur != 0) {
 1177     if (*cur == 0x20) {
 1178         cur++;
 1179         if ((*cur == 0x20) || (*cur == 0)) {
 1180             need_realloc = 1;
 1181         break;
 1182         }
 1183     } else
 1184         cur++;
 1185     }
 1186     if (need_realloc) {
 1187         xmlChar *ret;
 1188 
 1189     ret = xmlStrndup(src + remove_head, i - remove_head + 1);
 1190     if (ret == NULL) {
 1191         xmlErrMemory(ctxt, NULL);
 1192         return(NULL);
 1193     }
 1194     xmlAttrNormalizeSpace(ret, ret);
 1195     *len = (int) strlen((const char *)ret);
 1196         return(ret);
 1197     } else if (remove_head) {
 1198         *len -= remove_head;
 1199         memmove(src, src + remove_head, 1 + *len);
 1200     return(src);
 1201     }
 1202     return(NULL);
 1203 }
 1204 
 1205 /**
 1206  * xmlAddDefAttrs:
 1207  * @ctxt:  an XML parser context
 1208  * @fullname:  the element fullname
 1209  * @fullattr:  the attribute fullname
 1210  * @value:  the attribute value
 1211  *
 1212  * Add a defaulted attribute for an element
 1213  */
 1214 static void
 1215 xmlAddDefAttrs(xmlParserCtxtPtr ctxt,
 1216                const xmlChar *fullname,
 1217                const xmlChar *fullattr,
 1218                const xmlChar *value) {
 1219     xmlDefAttrsPtr defaults;
 1220     int len;
 1221     const xmlChar *name;
 1222     const xmlChar *prefix;
 1223 
 1224     /*
 1225      * Allows to detect attribute redefinitions
 1226      */
 1227     if (ctxt-&gt;attsSpecial != NULL) {
 1228         if (xmlHashLookup2(ctxt-&gt;attsSpecial, fullname, fullattr) != NULL)
 1229         return;
 1230     }
 1231 
 1232     if (ctxt-&gt;attsDefault == NULL) {
 1233         ctxt-&gt;attsDefault = xmlHashCreateDict(10, ctxt-&gt;dict);
 1234     if (ctxt-&gt;attsDefault == NULL)
 1235         goto mem_error;
 1236     }
 1237 
 1238     /*
 1239      * split the element name into prefix:localname , the string found
 1240      * are within the DTD and then not associated to namespace names.
 1241      */
 1242     name = xmlSplitQName3(fullname, &amp;len);
 1243     if (name == NULL) {
 1244         name = xmlDictLookup(ctxt-&gt;dict, fullname, -1);
 1245     prefix = NULL;
 1246     } else {
 1247         name = xmlDictLookup(ctxt-&gt;dict, name, -1);
 1248     prefix = xmlDictLookup(ctxt-&gt;dict, fullname, len);
 1249     }
 1250 
 1251     /*
 1252      * make sure there is some storage
 1253      */
 1254     defaults = xmlHashLookup2(ctxt-&gt;attsDefault, name, prefix);
 1255     if (defaults == NULL) {
 1256         defaults = (xmlDefAttrsPtr) xmlMalloc(sizeof(xmlDefAttrs) +
 1257                        (4 * 5) * sizeof(const xmlChar *));
 1258     if (defaults == NULL)
 1259         goto mem_error;
 1260     defaults-&gt;nbAttrs = 0;
 1261     defaults-&gt;maxAttrs = 4;
 1262     if (xmlHashUpdateEntry2(ctxt-&gt;attsDefault, name, prefix,
 1263                             defaults, NULL) &lt; 0) {
 1264         xmlFree(defaults);
 1265         goto mem_error;
 1266     }
 1267     } else if (defaults-&gt;nbAttrs &gt;= defaults-&gt;maxAttrs) {
 1268         xmlDefAttrsPtr temp;
 1269 
 1270         temp = (xmlDefAttrsPtr) xmlRealloc(defaults, sizeof(xmlDefAttrs) +
 1271                (2 * defaults-&gt;maxAttrs * 5) * sizeof(const xmlChar *));
 1272     if (temp == NULL)
 1273         goto mem_error;
 1274     defaults = temp;
 1275     defaults-&gt;maxAttrs *= 2;
 1276     if (xmlHashUpdateEntry2(ctxt-&gt;attsDefault, name, prefix,
 1277                             defaults, NULL) &lt; 0) {
 1278         xmlFree(defaults);
 1279         goto mem_error;
 1280     }
 1281     }
 1282 
 1283     /*
 1284      * Split the element name into prefix:localname , the string found
 1285      * are within the DTD and hen not associated to namespace names.
 1286      */
 1287     name = xmlSplitQName3(fullattr, &amp;len);
 1288     if (name == NULL) {
 1289         name = xmlDictLookup(ctxt-&gt;dict, fullattr, -1);
 1290     prefix = NULL;
 1291     } else {
 1292         name = xmlDictLookup(ctxt-&gt;dict, name, -1);
 1293     prefix = xmlDictLookup(ctxt-&gt;dict, fullattr, len);
 1294     }
 1295 
 1296     defaults-&gt;values[5 * defaults-&gt;nbAttrs] = name;
 1297     defaults-&gt;values[5 * defaults-&gt;nbAttrs + 1] = prefix;
 1298     /* intern the string and precompute the end */
 1299     len = xmlStrlen(value);
 1300     value = xmlDictLookup(ctxt-&gt;dict, value, len);
 1301     defaults-&gt;values[5 * defaults-&gt;nbAttrs + 2] = value;
 1302     defaults-&gt;values[5 * defaults-&gt;nbAttrs + 3] = value + len;
 1303     if (ctxt-&gt;external)
 1304         defaults-&gt;values[5 * defaults-&gt;nbAttrs + 4] = BAD_CAST &quot;external&quot;;
 1305     else
 1306         defaults-&gt;values[5 * defaults-&gt;nbAttrs + 4] = NULL;
 1307     defaults-&gt;nbAttrs++;
 1308 
 1309     return;
 1310 
 1311 mem_error:
 1312     xmlErrMemory(ctxt, NULL);
 1313     return;
 1314 }
 1315 
 1316 /**
 1317  * xmlAddSpecialAttr:
 1318  * @ctxt:  an XML parser context
 1319  * @fullname:  the element fullname
 1320  * @fullattr:  the attribute fullname
 1321  * @type:  the attribute type
 1322  *
 1323  * Register this attribute type
 1324  */
 1325 static void
 1326 xmlAddSpecialAttr(xmlParserCtxtPtr ctxt,
 1327           const xmlChar *fullname,
 1328           const xmlChar *fullattr,
 1329           int type)
 1330 {
 1331     if (ctxt-&gt;attsSpecial == NULL) {
 1332         ctxt-&gt;attsSpecial = xmlHashCreateDict(10, ctxt-&gt;dict);
 1333     if (ctxt-&gt;attsSpecial == NULL)
 1334         goto mem_error;
 1335     }
 1336 
 1337     if (xmlHashLookup2(ctxt-&gt;attsSpecial, fullname, fullattr) != NULL)
 1338         return;
 1339 
 1340     xmlHashAddEntry2(ctxt-&gt;attsSpecial, fullname, fullattr,
 1341                      (void *) (ptrdiff_t) type);
 1342     return;
 1343 
 1344 mem_error:
 1345     xmlErrMemory(ctxt, NULL);
 1346     return;
 1347 }
 1348 
 1349 /**
 1350  * xmlCleanSpecialAttrCallback:
 1351  *
 1352  * Removes CDATA attributes from the special attribute table
 1353  */
 1354 static void
 1355 xmlCleanSpecialAttrCallback(void *payload, void *data,
 1356                             const xmlChar *fullname, const xmlChar *fullattr,
 1357                             const xmlChar *unused ATTRIBUTE_UNUSED) {
 1358     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) data;
 1359 
 1360     if (((ptrdiff_t) payload) == XML_ATTRIBUTE_CDATA) {
 1361         xmlHashRemoveEntry2(ctxt-&gt;attsSpecial, fullname, fullattr, NULL);
 1362     }
 1363 }
 1364 
 1365 /**
 1366  * xmlCleanSpecialAttr:
 1367  * @ctxt:  an XML parser context
 1368  *
 1369  * Trim the list of attributes defined to remove all those of type
 1370  * CDATA as they are not special. This call should be done when finishing
 1371  * to parse the DTD and before starting to parse the document root.
 1372  */
 1373 static void
 1374 xmlCleanSpecialAttr(xmlParserCtxtPtr ctxt)
 1375 {
 1376     if (ctxt-&gt;attsSpecial == NULL)
 1377         return;
 1378 
 1379     xmlHashScanFull(ctxt-&gt;attsSpecial, xmlCleanSpecialAttrCallback, ctxt);
 1380 
 1381     if (xmlHashSize(ctxt-&gt;attsSpecial) == 0) {
 1382         xmlHashFree(ctxt-&gt;attsSpecial, NULL);
 1383         ctxt-&gt;attsSpecial = NULL;
 1384     }
 1385     return;
 1386 }
 1387 
 1388 /**
 1389  * xmlCheckLanguageID:
 1390  * @lang:  pointer to the string value
 1391  *
 1392  * Checks that the value conforms to the LanguageID production:
 1393  *
 1394  * NOTE: this is somewhat deprecated, those productions were removed from
 1395  *       the XML Second edition.
 1396  *
 1397  * [33] LanguageID ::= Langcode (&#39;-&#39; Subcode)*
 1398  * [34] Langcode ::= ISO639Code |  IanaCode |  UserCode
 1399  * [35] ISO639Code ::= ([a-z] | [A-Z]) ([a-z] | [A-Z])
 1400  * [36] IanaCode ::= (&#39;i&#39; | &#39;I&#39;) &#39;-&#39; ([a-z] | [A-Z])+
 1401  * [37] UserCode ::= (&#39;x&#39; | &#39;X&#39;) &#39;-&#39; ([a-z] | [A-Z])+
 1402  * [38] Subcode ::= ([a-z] | [A-Z])+
 1403  *
 1404  * The current REC reference the successors of RFC 1766, currently 5646
 1405  *
 1406  * http://www.rfc-editor.org/rfc/rfc5646.txt
 1407  * langtag       = language
 1408  *                 [&quot;-&quot; script]
 1409  *                 [&quot;-&quot; region]
 1410  *                 *(&quot;-&quot; variant)
 1411  *                 *(&quot;-&quot; extension)
 1412  *                 [&quot;-&quot; privateuse]
 1413  * language      = 2*3ALPHA            ; shortest ISO 639 code
 1414  *                 [&quot;-&quot; extlang]       ; sometimes followed by
 1415  *                                     ; extended language subtags
 1416  *               / 4ALPHA              ; or reserved for future use
 1417  *               / 5*8ALPHA            ; or registered language subtag
 1418  *
 1419  * extlang       = 3ALPHA              ; selected ISO 639 codes
 1420  *                 *2(&quot;-&quot; 3ALPHA)      ; permanently reserved
 1421  *
 1422  * script        = 4ALPHA              ; ISO 15924 code
 1423  *
 1424  * region        = 2ALPHA              ; ISO 3166-1 code
 1425  *               / 3DIGIT              ; UN M.49 code
 1426  *
 1427  * variant       = 5*8alphanum         ; registered variants
 1428  *               / (DIGIT 3alphanum)
 1429  *
 1430  * extension     = singleton 1*(&quot;-&quot; (2*8alphanum))
 1431  *
 1432  *                                     ; Single alphanumerics
 1433  *                                     ; &quot;x&quot; reserved for private use
 1434  * singleton     = DIGIT               ; 0 - 9
 1435  *               / %x41-57             ; A - W
 1436  *               / %x59-5A             ; Y - Z
 1437  *               / %x61-77             ; a - w
 1438  *               / %x79-7A             ; y - z
 1439  *
 1440  * it sounds right to still allow Irregular i-xxx IANA and user codes too
 1441  * The parser below doesn&#39;t try to cope with extension or privateuse
 1442  * that could be added but that&#39;s not interoperable anyway
 1443  *
 1444  * Returns 1 if correct 0 otherwise
 1445  **/
 1446 int
 1447 xmlCheckLanguageID(const xmlChar * lang)
 1448 {
 1449     const xmlChar *cur = lang, *nxt;
 1450 
 1451     if (cur == NULL)
 1452         return (0);
 1453     if (((cur[0] == &#39;i&#39;) &amp;&amp; (cur[1] == &#39;-&#39;)) ||
 1454         ((cur[0] == &#39;I&#39;) &amp;&amp; (cur[1] == &#39;-&#39;)) ||
 1455         ((cur[0] == &#39;x&#39;) &amp;&amp; (cur[1] == &#39;-&#39;)) ||
 1456         ((cur[0] == &#39;X&#39;) &amp;&amp; (cur[1] == &#39;-&#39;))) {
 1457         /*
 1458          * Still allow IANA code and user code which were coming
 1459          * from the previous version of the XML-1.0 specification
 1460          * it&#39;s deprecated but we should not fail
 1461          */
 1462         cur += 2;
 1463         while (((cur[0] &gt;= &#39;A&#39;) &amp;&amp; (cur[0] &lt;= &#39;Z&#39;)) ||
 1464                ((cur[0] &gt;= &#39;a&#39;) &amp;&amp; (cur[0] &lt;= &#39;z&#39;)))
 1465             cur++;
 1466         return(cur[0] == 0);
 1467     }
 1468     nxt = cur;
 1469     while (((nxt[0] &gt;= &#39;A&#39;) &amp;&amp; (nxt[0] &lt;= &#39;Z&#39;)) ||
 1470            ((nxt[0] &gt;= &#39;a&#39;) &amp;&amp; (nxt[0] &lt;= &#39;z&#39;)))
 1471            nxt++;
 1472     if (nxt - cur &gt;= 4) {
 1473         /*
 1474          * Reserved
 1475          */
 1476         if ((nxt - cur &gt; 8) || (nxt[0] != 0))
 1477             return(0);
 1478         return(1);
 1479     }
 1480     if (nxt - cur &lt; 2)
 1481         return(0);
 1482     /* we got an ISO 639 code */
 1483     if (nxt[0] == 0)
 1484         return(1);
 1485     if (nxt[0] != &#39;-&#39;)
 1486         return(0);
 1487 
 1488     nxt++;
 1489     cur = nxt;
 1490     /* now we can have extlang or script or region or variant */
 1491     if ((nxt[0] &gt;= &#39;0&#39;) &amp;&amp; (nxt[0] &lt;= &#39;9&#39;))
 1492         goto region_m49;
 1493 
 1494     while (((nxt[0] &gt;= &#39;A&#39;) &amp;&amp; (nxt[0] &lt;= &#39;Z&#39;)) ||
 1495            ((nxt[0] &gt;= &#39;a&#39;) &amp;&amp; (nxt[0] &lt;= &#39;z&#39;)))
 1496            nxt++;
 1497     if (nxt - cur == 4)
 1498         goto script;
 1499     if (nxt - cur == 2)
 1500         goto region;
 1501     if ((nxt - cur &gt;= 5) &amp;&amp; (nxt - cur &lt;= 8))
 1502         goto variant;
 1503     if (nxt - cur != 3)
 1504         return(0);
 1505     /* we parsed an extlang */
 1506     if (nxt[0] == 0)
 1507         return(1);
 1508     if (nxt[0] != &#39;-&#39;)
 1509         return(0);
 1510 
 1511     nxt++;
 1512     cur = nxt;
 1513     /* now we can have script or region or variant */
 1514     if ((nxt[0] &gt;= &#39;0&#39;) &amp;&amp; (nxt[0] &lt;= &#39;9&#39;))
 1515         goto region_m49;
 1516 
 1517     while (((nxt[0] &gt;= &#39;A&#39;) &amp;&amp; (nxt[0] &lt;= &#39;Z&#39;)) ||
 1518            ((nxt[0] &gt;= &#39;a&#39;) &amp;&amp; (nxt[0] &lt;= &#39;z&#39;)))
 1519            nxt++;
 1520     if (nxt - cur == 2)
 1521         goto region;
 1522     if ((nxt - cur &gt;= 5) &amp;&amp; (nxt - cur &lt;= 8))
 1523         goto variant;
 1524     if (nxt - cur != 4)
 1525         return(0);
 1526     /* we parsed a script */
 1527 script:
 1528     if (nxt[0] == 0)
 1529         return(1);
 1530     if (nxt[0] != &#39;-&#39;)
 1531         return(0);
 1532 
 1533     nxt++;
 1534     cur = nxt;
 1535     /* now we can have region or variant */
 1536     if ((nxt[0] &gt;= &#39;0&#39;) &amp;&amp; (nxt[0] &lt;= &#39;9&#39;))
 1537         goto region_m49;
 1538 
 1539     while (((nxt[0] &gt;= &#39;A&#39;) &amp;&amp; (nxt[0] &lt;= &#39;Z&#39;)) ||
 1540            ((nxt[0] &gt;= &#39;a&#39;) &amp;&amp; (nxt[0] &lt;= &#39;z&#39;)))
 1541            nxt++;
 1542 
 1543     if ((nxt - cur &gt;= 5) &amp;&amp; (nxt - cur &lt;= 8))
 1544         goto variant;
 1545     if (nxt - cur != 2)
 1546         return(0);
 1547     /* we parsed a region */
 1548 region:
 1549     if (nxt[0] == 0)
 1550         return(1);
 1551     if (nxt[0] != &#39;-&#39;)
 1552         return(0);
 1553 
 1554     nxt++;
 1555     cur = nxt;
 1556     /* now we can just have a variant */
 1557     while (((nxt[0] &gt;= &#39;A&#39;) &amp;&amp; (nxt[0] &lt;= &#39;Z&#39;)) ||
 1558            ((nxt[0] &gt;= &#39;a&#39;) &amp;&amp; (nxt[0] &lt;= &#39;z&#39;)))
 1559            nxt++;
 1560 
 1561     if ((nxt - cur &lt; 5) || (nxt - cur &gt; 8))
 1562         return(0);
 1563 
 1564     /* we parsed a variant */
 1565 variant:
 1566     if (nxt[0] == 0)
 1567         return(1);
 1568     if (nxt[0] != &#39;-&#39;)
 1569         return(0);
 1570     /* extensions and private use subtags not checked */
 1571     return (1);
 1572 
 1573 region_m49:
 1574     if (((nxt[1] &gt;= &#39;0&#39;) &amp;&amp; (nxt[1] &lt;= &#39;9&#39;)) &amp;&amp;
 1575         ((nxt[2] &gt;= &#39;0&#39;) &amp;&amp; (nxt[2] &lt;= &#39;9&#39;))) {
 1576         nxt += 3;
 1577         goto region;
 1578     }
 1579     return(0);
 1580 }
 1581 
 1582 /************************************************************************
 1583  *                                  *
 1584  *      Parser stacks related functions and macros      *
 1585  *                                  *
 1586  ************************************************************************/
 1587 
 1588 static xmlEntityPtr xmlParseStringEntityRef(xmlParserCtxtPtr ctxt,
 1589                                             const xmlChar ** str);
 1590 
 1591 #ifdef SAX2
 1592 /**
 1593  * nsPush:
 1594  * @ctxt:  an XML parser context
 1595  * @prefix:  the namespace prefix or NULL
 1596  * @URL:  the namespace name
 1597  *
 1598  * Pushes a new parser namespace on top of the ns stack
 1599  *
 1600  * Returns -1 in case of error, -2 if the namespace should be discarded
 1601  *     and the index in the stack otherwise.
 1602  */
 1603 static int
 1604 nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL)
 1605 {
 1606     if (ctxt-&gt;options &amp; XML_PARSE_NSCLEAN) {
 1607         int i;
 1608     for (i = ctxt-&gt;nsNr - 2;i &gt;= 0;i -= 2) {
 1609         if (ctxt-&gt;nsTab[i] == prefix) {
 1610         /* in scope */
 1611             if (ctxt-&gt;nsTab[i + 1] == URL)
 1612             return(-2);
 1613         /* out of scope keep it */
 1614         break;
 1615         }
 1616     }
 1617     }
 1618     if ((ctxt-&gt;nsMax == 0) || (ctxt-&gt;nsTab == NULL)) {
 1619     ctxt-&gt;nsMax = 10;
 1620     ctxt-&gt;nsNr = 0;
 1621     ctxt-&gt;nsTab = (const xmlChar **)
 1622                   xmlMalloc(ctxt-&gt;nsMax * sizeof(xmlChar *));
 1623     if (ctxt-&gt;nsTab == NULL) {
 1624         xmlErrMemory(ctxt, NULL);
 1625         ctxt-&gt;nsMax = 0;
 1626             return (-1);
 1627     }
 1628     } else if (ctxt-&gt;nsNr &gt;= ctxt-&gt;nsMax) {
 1629         const xmlChar ** tmp;
 1630         ctxt-&gt;nsMax *= 2;
 1631         tmp = (const xmlChar **) xmlRealloc((char *) ctxt-&gt;nsTab,
 1632                     ctxt-&gt;nsMax * sizeof(ctxt-&gt;nsTab[0]));
 1633         if (tmp == NULL) {
 1634             xmlErrMemory(ctxt, NULL);
 1635         ctxt-&gt;nsMax /= 2;
 1636             return (-1);
 1637         }
 1638     ctxt-&gt;nsTab = tmp;
 1639     }
 1640     ctxt-&gt;nsTab[ctxt-&gt;nsNr++] = prefix;
 1641     ctxt-&gt;nsTab[ctxt-&gt;nsNr++] = URL;
 1642     return (ctxt-&gt;nsNr);
 1643 }
 1644 /**
 1645  * nsPop:
 1646  * @ctxt: an XML parser context
 1647  * @nr:  the number to pop
 1648  *
 1649  * Pops the top @nr parser prefix/namespace from the ns stack
 1650  *
 1651  * Returns the number of namespaces removed
 1652  */
 1653 static int
 1654 nsPop(xmlParserCtxtPtr ctxt, int nr)
 1655 {
 1656     int i;
 1657 
 1658     if (ctxt-&gt;nsTab == NULL) return(0);
 1659     if (ctxt-&gt;nsNr &lt; nr) {
 1660         xmlGenericError(xmlGenericErrorContext, &quot;Pbm popping %d NS\n&quot;, nr);
 1661         nr = ctxt-&gt;nsNr;
 1662     }
 1663     if (ctxt-&gt;nsNr &lt;= 0)
 1664         return (0);
 1665 
 1666     for (i = 0;i &lt; nr;i++) {
 1667          ctxt-&gt;nsNr--;
 1668      ctxt-&gt;nsTab[ctxt-&gt;nsNr] = NULL;
 1669     }
 1670     return(nr);
 1671 }
 1672 #endif
 1673 
 1674 static int
 1675 xmlCtxtGrowAttrs(xmlParserCtxtPtr ctxt, int nr) {
 1676     const xmlChar **atts;
 1677     int *attallocs;
 1678     int maxatts;
 1679 
 1680     if (ctxt-&gt;atts == NULL) {
 1681     maxatts = 55; /* allow for 10 attrs by default */
 1682     atts = (const xmlChar **)
 1683            xmlMalloc(maxatts * sizeof(xmlChar *));
 1684     if (atts == NULL) goto mem_error;
 1685     ctxt-&gt;atts = atts;
 1686     attallocs = (int *) xmlMalloc((maxatts / 5) * sizeof(int));
 1687     if (attallocs == NULL) goto mem_error;
 1688     ctxt-&gt;attallocs = attallocs;
 1689     ctxt-&gt;maxatts = maxatts;
 1690     } else if (nr + 5 &gt; ctxt-&gt;maxatts) {
 1691     maxatts = (nr + 5) * 2;
 1692     atts = (const xmlChar **) xmlRealloc((void *) ctxt-&gt;atts,
 1693                      maxatts * sizeof(const xmlChar *));
 1694     if (atts == NULL) goto mem_error;
 1695     ctxt-&gt;atts = atts;
 1696     attallocs = (int *) xmlRealloc((void *) ctxt-&gt;attallocs,
 1697                                  (maxatts / 5) * sizeof(int));
 1698     if (attallocs == NULL) goto mem_error;
 1699     ctxt-&gt;attallocs = attallocs;
 1700     ctxt-&gt;maxatts = maxatts;
 1701     }
 1702     return(ctxt-&gt;maxatts);
 1703 mem_error:
 1704     xmlErrMemory(ctxt, NULL);
 1705     return(-1);
 1706 }
 1707 
 1708 /**
 1709  * inputPush:
 1710  * @ctxt:  an XML parser context
 1711  * @value:  the parser input
 1712  *
 1713  * Pushes a new parser input on top of the input stack
 1714  *
 1715  * Returns -1 in case of error, the index in the stack otherwise
 1716  */
 1717 int
 1718 inputPush(xmlParserCtxtPtr ctxt, xmlParserInputPtr value)
 1719 {
 1720     if ((ctxt == NULL) || (value == NULL))
 1721         return(-1);
 1722     if (ctxt-&gt;inputNr &gt;= ctxt-&gt;inputMax) {
 1723         ctxt-&gt;inputMax *= 2;
 1724         ctxt-&gt;inputTab =
 1725             (xmlParserInputPtr *) xmlRealloc(ctxt-&gt;inputTab,
 1726                                              ctxt-&gt;inputMax *
 1727                                              sizeof(ctxt-&gt;inputTab[0]));
 1728         if (ctxt-&gt;inputTab == NULL) {
 1729             xmlErrMemory(ctxt, NULL);
 1730         xmlFreeInputStream(value);
 1731         ctxt-&gt;inputMax /= 2;
 1732         value = NULL;
 1733             return (-1);
 1734         }
 1735     }
 1736     ctxt-&gt;inputTab[ctxt-&gt;inputNr] = value;
 1737     ctxt-&gt;input = value;
 1738     return (ctxt-&gt;inputNr++);
 1739 }
 1740 /**
 1741  * inputPop:
 1742  * @ctxt: an XML parser context
 1743  *
 1744  * Pops the top parser input from the input stack
 1745  *
 1746  * Returns the input just removed
 1747  */
 1748 xmlParserInputPtr
 1749 inputPop(xmlParserCtxtPtr ctxt)
 1750 {
 1751     xmlParserInputPtr ret;
 1752 
 1753     if (ctxt == NULL)
 1754         return(NULL);
 1755     if (ctxt-&gt;inputNr &lt;= 0)
 1756         return (NULL);
 1757     ctxt-&gt;inputNr--;
 1758     if (ctxt-&gt;inputNr &gt; 0)
 1759         ctxt-&gt;input = ctxt-&gt;inputTab[ctxt-&gt;inputNr - 1];
 1760     else
 1761         ctxt-&gt;input = NULL;
 1762     ret = ctxt-&gt;inputTab[ctxt-&gt;inputNr];
 1763     ctxt-&gt;inputTab[ctxt-&gt;inputNr] = NULL;
 1764     return (ret);
 1765 }
 1766 /**
 1767  * nodePush:
 1768  * @ctxt:  an XML parser context
 1769  * @value:  the element node
 1770  *
 1771  * Pushes a new element node on top of the node stack
 1772  *
 1773  * Returns -1 in case of error, the index in the stack otherwise
 1774  */
 1775 int
 1776 nodePush(xmlParserCtxtPtr ctxt, xmlNodePtr value)
 1777 {
 1778     if (ctxt == NULL) return(0);
 1779     if (ctxt-&gt;nodeNr &gt;= ctxt-&gt;nodeMax) {
 1780         xmlNodePtr *tmp;
 1781 
 1782     tmp = (xmlNodePtr *) xmlRealloc(ctxt-&gt;nodeTab,
 1783                                       ctxt-&gt;nodeMax * 2 *
 1784                                       sizeof(ctxt-&gt;nodeTab[0]));
 1785         if (tmp == NULL) {
 1786             xmlErrMemory(ctxt, NULL);
 1787             return (-1);
 1788         }
 1789         ctxt-&gt;nodeTab = tmp;
 1790     ctxt-&gt;nodeMax *= 2;
 1791     }
 1792     if ((((unsigned int) ctxt-&gt;nodeNr) &gt; xmlParserMaxDepth) &amp;&amp;
 1793         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 1794     xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
 1795          &quot;Excessive depth in document: %d use XML_PARSE_HUGE option\n&quot;,
 1796               xmlParserMaxDepth);
 1797     xmlHaltParser(ctxt);
 1798     return(-1);
 1799     }
 1800     ctxt-&gt;nodeTab[ctxt-&gt;nodeNr] = value;
 1801     ctxt-&gt;node = value;
 1802     return (ctxt-&gt;nodeNr++);
 1803 }
 1804 
 1805 /**
 1806  * nodePop:
 1807  * @ctxt: an XML parser context
 1808  *
 1809  * Pops the top element node from the node stack
 1810  *
 1811  * Returns the node just removed
 1812  */
 1813 xmlNodePtr
 1814 nodePop(xmlParserCtxtPtr ctxt)
 1815 {
 1816     xmlNodePtr ret;
 1817 
 1818     if (ctxt == NULL) return(NULL);
 1819     if (ctxt-&gt;nodeNr &lt;= 0)
 1820         return (NULL);
 1821     ctxt-&gt;nodeNr--;
 1822     if (ctxt-&gt;nodeNr &gt; 0)
 1823         ctxt-&gt;node = ctxt-&gt;nodeTab[ctxt-&gt;nodeNr - 1];
 1824     else
 1825         ctxt-&gt;node = NULL;
 1826     ret = ctxt-&gt;nodeTab[ctxt-&gt;nodeNr];
 1827     ctxt-&gt;nodeTab[ctxt-&gt;nodeNr] = NULL;
 1828     return (ret);
 1829 }
 1830 
 1831 /**
 1832  * nameNsPush:
 1833  * @ctxt:  an XML parser context
 1834  * @value:  the element name
 1835  * @prefix:  the element prefix
 1836  * @URI:  the element namespace name
 1837  *
 1838  * Pushes a new element name/prefix/URL on top of the name stack
 1839  *
 1840  * Returns -1 in case of error, the index in the stack otherwise
 1841  */
 1842 static int
 1843 nameNsPush(xmlParserCtxtPtr ctxt, const xmlChar * value,
 1844            const xmlChar *prefix, const xmlChar *URI, int nsNr)
 1845 {
 1846     if (ctxt-&gt;nameNr &gt;= ctxt-&gt;nameMax) {
 1847         const xmlChar * *tmp;
 1848         void **tmp2;
 1849         ctxt-&gt;nameMax *= 2;
 1850         tmp = (const xmlChar * *) xmlRealloc((xmlChar * *)ctxt-&gt;nameTab,
 1851                                     ctxt-&gt;nameMax *
 1852                                     sizeof(ctxt-&gt;nameTab[0]));
 1853         if (tmp == NULL) {
 1854         ctxt-&gt;nameMax /= 2;
 1855         goto mem_error;
 1856         }
 1857     ctxt-&gt;nameTab = tmp;
 1858         tmp2 = (void **) xmlRealloc((void * *)ctxt-&gt;pushTab,
 1859                                     ctxt-&gt;nameMax * 3 *
 1860                                     sizeof(ctxt-&gt;pushTab[0]));
 1861         if (tmp2 == NULL) {
 1862         ctxt-&gt;nameMax /= 2;
 1863         goto mem_error;
 1864         }
 1865     ctxt-&gt;pushTab = tmp2;
 1866     } else if (ctxt-&gt;pushTab == NULL) {
 1867         ctxt-&gt;pushTab = (void **) xmlMalloc(ctxt-&gt;nameMax * 3 *
 1868                                             sizeof(ctxt-&gt;pushTab[0]));
 1869         if (ctxt-&gt;pushTab == NULL)
 1870             goto mem_error;
 1871     }
 1872     ctxt-&gt;nameTab[ctxt-&gt;nameNr] = value;
 1873     ctxt-&gt;name = value;
 1874     ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3] = (void *) prefix;
 1875     ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 + 1] = (void *) URI;
 1876     ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 + 2] = (void *) (ptrdiff_t) nsNr;
 1877     return (ctxt-&gt;nameNr++);
 1878 mem_error:
 1879     xmlErrMemory(ctxt, NULL);
 1880     return (-1);
 1881 }
 1882 #ifdef LIBXML_PUSH_ENABLED
 1883 /**
 1884  * nameNsPop:
 1885  * @ctxt: an XML parser context
 1886  *
 1887  * Pops the top element/prefix/URI name from the name stack
 1888  *
 1889  * Returns the name just removed
 1890  */
 1891 static const xmlChar *
 1892 nameNsPop(xmlParserCtxtPtr ctxt)
 1893 {
 1894     const xmlChar *ret;
 1895 
 1896     if (ctxt-&gt;nameNr &lt;= 0)
 1897         return (NULL);
 1898     ctxt-&gt;nameNr--;
 1899     if (ctxt-&gt;nameNr &gt; 0)
 1900         ctxt-&gt;name = ctxt-&gt;nameTab[ctxt-&gt;nameNr - 1];
 1901     else
 1902         ctxt-&gt;name = NULL;
 1903     ret = ctxt-&gt;nameTab[ctxt-&gt;nameNr];
 1904     ctxt-&gt;nameTab[ctxt-&gt;nameNr] = NULL;
 1905     return (ret);
 1906 }
 1907 #endif /* LIBXML_PUSH_ENABLED */
 1908 
 1909 /**
 1910  * namePush:
 1911  * @ctxt:  an XML parser context
 1912  * @value:  the element name
 1913  *
 1914  * Pushes a new element name on top of the name stack
 1915  *
 1916  * Returns -1 in case of error, the index in the stack otherwise
 1917  */
 1918 int
 1919 namePush(xmlParserCtxtPtr ctxt, const xmlChar * value)
 1920 {
 1921     if (ctxt == NULL) return (-1);
 1922 
 1923     if (ctxt-&gt;nameNr &gt;= ctxt-&gt;nameMax) {
 1924         const xmlChar * *tmp;
 1925         tmp = (const xmlChar * *) xmlRealloc((xmlChar * *)ctxt-&gt;nameTab,
 1926                                     ctxt-&gt;nameMax * 2 *
 1927                                     sizeof(ctxt-&gt;nameTab[0]));
 1928         if (tmp == NULL) {
 1929         goto mem_error;
 1930         }
 1931     ctxt-&gt;nameTab = tmp;
 1932         ctxt-&gt;nameMax *= 2;
 1933     }
 1934     ctxt-&gt;nameTab[ctxt-&gt;nameNr] = value;
 1935     ctxt-&gt;name = value;
 1936     return (ctxt-&gt;nameNr++);
 1937 mem_error:
 1938     xmlErrMemory(ctxt, NULL);
 1939     return (-1);
 1940 }
 1941 /**
 1942  * namePop:
 1943  * @ctxt: an XML parser context
 1944  *
 1945  * Pops the top element name from the name stack
 1946  *
 1947  * Returns the name just removed
 1948  */
 1949 const xmlChar *
 1950 namePop(xmlParserCtxtPtr ctxt)
 1951 {
 1952     const xmlChar *ret;
 1953 
 1954     if ((ctxt == NULL) || (ctxt-&gt;nameNr &lt;= 0))
 1955         return (NULL);
 1956     ctxt-&gt;nameNr--;
 1957     if (ctxt-&gt;nameNr &gt; 0)
 1958         ctxt-&gt;name = ctxt-&gt;nameTab[ctxt-&gt;nameNr - 1];
 1959     else
 1960         ctxt-&gt;name = NULL;
 1961     ret = ctxt-&gt;nameTab[ctxt-&gt;nameNr];
 1962     ctxt-&gt;nameTab[ctxt-&gt;nameNr] = NULL;
 1963     return (ret);
 1964 }
 1965 
 1966 static int spacePush(xmlParserCtxtPtr ctxt, int val) {
 1967     if (ctxt-&gt;spaceNr &gt;= ctxt-&gt;spaceMax) {
 1968         int *tmp;
 1969 
 1970     ctxt-&gt;spaceMax *= 2;
 1971         tmp = (int *) xmlRealloc(ctxt-&gt;spaceTab,
 1972                              ctxt-&gt;spaceMax * sizeof(ctxt-&gt;spaceTab[0]));
 1973         if (tmp == NULL) {
 1974         xmlErrMemory(ctxt, NULL);
 1975         ctxt-&gt;spaceMax /=2;
 1976         return(-1);
 1977     }
 1978     ctxt-&gt;spaceTab = tmp;
 1979     }
 1980     ctxt-&gt;spaceTab[ctxt-&gt;spaceNr] = val;
 1981     ctxt-&gt;space = &amp;ctxt-&gt;spaceTab[ctxt-&gt;spaceNr];
 1982     return(ctxt-&gt;spaceNr++);
 1983 }
 1984 
 1985 static int spacePop(xmlParserCtxtPtr ctxt) {
 1986     int ret;
 1987     if (ctxt-&gt;spaceNr &lt;= 0) return(0);
 1988     ctxt-&gt;spaceNr--;
 1989     if (ctxt-&gt;spaceNr &gt; 0)
 1990     ctxt-&gt;space = &amp;ctxt-&gt;spaceTab[ctxt-&gt;spaceNr - 1];
 1991     else
 1992         ctxt-&gt;space = &amp;ctxt-&gt;spaceTab[0];
 1993     ret = ctxt-&gt;spaceTab[ctxt-&gt;spaceNr];
 1994     ctxt-&gt;spaceTab[ctxt-&gt;spaceNr] = -1;
 1995     return(ret);
 1996 }
 1997 
 1998 /*
 1999  * Macros for accessing the content. Those should be used only by the parser,
 2000  * and not exported.
 2001  *
 2002  * Dirty macros, i.e. one often need to make assumption on the context to
 2003  * use them
 2004  *
 2005  *   CUR_PTR return the current pointer to the xmlChar to be parsed.
 2006  *           To be used with extreme caution since operations consuming
 2007  *           characters may move the input buffer to a different location !
 2008  *   CUR     returns the current xmlChar value, i.e. a 8 bit value if compiled
 2009  *           This should be used internally by the parser
 2010  *           only to compare to ASCII values otherwise it would break when
 2011  *           running with UTF-8 encoding.
 2012  *   RAW     same as CUR but in the input buffer, bypass any token
 2013  *           extraction that may have been done
 2014  *   NXT(n)  returns the n&#39;th next xmlChar. Same as CUR is should be used only
 2015  *           to compare on ASCII based substring.
 2016  *   SKIP(n) Skip n xmlChar, and must also be used only to skip ASCII defined
 2017  *           strings without newlines within the parser.
 2018  *   NEXT1(l) Skip 1 xmlChar, and must also be used only to skip 1 non-newline ASCII
 2019  *           defined char within the parser.
 2020  * Clean macros, not dependent of an ASCII context, expect UTF-8 encoding
 2021  *
 2022  *   NEXT    Skip to the next character, this does the proper decoding
 2023  *           in UTF-8 mode. It also pop-up unfinished entities on the fly.
 2024  *   NEXTL(l) Skip the current unicode character of l xmlChars long.
 2025  *   CUR_CHAR(l) returns the current unicode character (int), set l
 2026  *           to the number of xmlChars used for the encoding [0-5].
 2027  *   CUR_SCHAR  same but operate on a string instead of the context
 2028  *   COPY_BUF  copy the current unicode char to the target buffer, increment
 2029  *            the index
 2030  *   GROW, SHRINK  handling of input buffers
 2031  */
 2032 
 2033 #define RAW (*ctxt-&gt;input-&gt;cur)
 2034 #define CUR (*ctxt-&gt;input-&gt;cur)
 2035 #define NXT(val) ctxt-&gt;input-&gt;cur[(val)]
 2036 #define CUR_PTR ctxt-&gt;input-&gt;cur
 2037 #define BASE_PTR ctxt-&gt;input-&gt;base
 2038 
 2039 #define CMP4( s, c1, c2, c3, c4 ) \
 2040   ( ((unsigned char *) s)[ 0 ] == c1 &amp;&amp; ((unsigned char *) s)[ 1 ] == c2 &amp;&amp; \
 2041     ((unsigned char *) s)[ 2 ] == c3 &amp;&amp; ((unsigned char *) s)[ 3 ] == c4 )
 2042 #define CMP5( s, c1, c2, c3, c4, c5 ) \
 2043   ( CMP4( s, c1, c2, c3, c4 ) &amp;&amp; ((unsigned char *) s)[ 4 ] == c5 )
 2044 #define CMP6( s, c1, c2, c3, c4, c5, c6 ) \
 2045   ( CMP5( s, c1, c2, c3, c4, c5 ) &amp;&amp; ((unsigned char *) s)[ 5 ] == c6 )
 2046 #define CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) \
 2047   ( CMP6( s, c1, c2, c3, c4, c5, c6 ) &amp;&amp; ((unsigned char *) s)[ 6 ] == c7 )
 2048 #define CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) \
 2049   ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) &amp;&amp; ((unsigned char *) s)[ 7 ] == c8 )
 2050 #define CMP9( s, c1, c2, c3, c4, c5, c6, c7, c8, c9 ) \
 2051   ( CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) &amp;&amp; \
 2052     ((unsigned char *) s)[ 8 ] == c9 )
 2053 #define CMP10( s, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10 ) \
 2054   ( CMP9( s, c1, c2, c3, c4, c5, c6, c7, c8, c9 ) &amp;&amp; \
 2055     ((unsigned char *) s)[ 9 ] == c10 )
 2056 
 2057 #define SKIP(val) do {                          \
 2058     ctxt-&gt;nbChars += (val),ctxt-&gt;input-&gt;cur += (val),ctxt-&gt;input-&gt;col+=(val);           \
 2059     if (*ctxt-&gt;input-&gt;cur == 0)                     \
 2060         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);           \
 2061   } while (0)
 2062 
 2063 #define SKIPL(val) do {                         \
 2064     int skipl;                              \
 2065     for(skipl=0; skipl&lt;val; skipl++) {                  \
 2066     if (*(ctxt-&gt;input-&gt;cur) == &#39;\n&#39;) {              \
 2067     ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;          \
 2068     } else ctxt-&gt;input-&gt;col++;                  \
 2069     ctxt-&gt;nbChars++;                        \
 2070     ctxt-&gt;input-&gt;cur++;                     \
 2071     }                                   \
 2072     if (*ctxt-&gt;input-&gt;cur == 0)                     \
 2073         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);           \
 2074   } while (0)
 2075 
 2076 #define SHRINK if ((ctxt-&gt;progressive == 0) &amp;&amp;              \
 2077            (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base &gt; 2 * INPUT_CHUNK) &amp;&amp; \
 2078            (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; 2 * INPUT_CHUNK)) \
 2079     xmlSHRINK (ctxt);
 2080 
 2081 static void xmlSHRINK (xmlParserCtxtPtr ctxt) {
 2082     xmlParserInputShrink(ctxt-&gt;input);
 2083     if (*ctxt-&gt;input-&gt;cur == 0)
 2084         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 2085 }
 2086 
 2087 #define GROW if ((ctxt-&gt;progressive == 0) &amp;&amp;                \
 2088          (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; INPUT_CHUNK))   \
 2089     xmlGROW (ctxt);
 2090 
 2091 static void xmlGROW (xmlParserCtxtPtr ctxt) {
 2092     ptrdiff_t curEnd = ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur;
 2093     ptrdiff_t curBase = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
 2094 
 2095     if (((curEnd &gt; XML_MAX_LOOKUP_LIMIT) ||
 2096          (curBase &gt; XML_MAX_LOOKUP_LIMIT)) &amp;&amp;
 2097          ((ctxt-&gt;input-&gt;buf) &amp;&amp;
 2098           (ctxt-&gt;input-&gt;buf-&gt;readcallback != xmlInputReadCallbackNop)) &amp;&amp;
 2099         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 2100         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, &quot;Huge input lookup&quot;);
 2101         xmlHaltParser(ctxt);
 2102     return;
 2103     }
 2104     xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 2105     if ((ctxt-&gt;input-&gt;cur &gt; ctxt-&gt;input-&gt;end) ||
 2106         (ctxt-&gt;input-&gt;cur &lt; ctxt-&gt;input-&gt;base)) {
 2107         xmlHaltParser(ctxt);
 2108         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, &quot;cur index out of bound&quot;);
 2109     return;
 2110     }
 2111     if ((ctxt-&gt;input-&gt;cur != NULL) &amp;&amp; (*ctxt-&gt;input-&gt;cur == 0))
 2112         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 2113 }
 2114 
 2115 #define SKIP_BLANKS xmlSkipBlankChars(ctxt)
 2116 
 2117 #define NEXT xmlNextChar(ctxt)
 2118 
 2119 #define NEXT1 {                             \
 2120     ctxt-&gt;input-&gt;col++;                     \
 2121     ctxt-&gt;input-&gt;cur++;                     \
 2122     ctxt-&gt;nbChars++;                        \
 2123     if (*ctxt-&gt;input-&gt;cur == 0)                 \
 2124         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);       \
 2125     }
 2126 
 2127 #define NEXTL(l) do {                           \
 2128     if (*(ctxt-&gt;input-&gt;cur) == &#39;\n&#39;) {                  \
 2129     ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;          \
 2130     } else ctxt-&gt;input-&gt;col++;                      \
 2131     ctxt-&gt;input-&gt;cur += l;              \
 2132   } while (0)
 2133 
 2134 #define CUR_CHAR(l) xmlCurrentChar(ctxt, &amp;l)
 2135 #define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &amp;l)
 2136 
 2137 #define COPY_BUF(l,b,i,v)                       \
 2138     if (l == 1) b[i++] = (xmlChar) v;                   \
 2139     else i += xmlCopyCharMultiByte(&amp;b[i],v)
 2140 
 2141 /**
 2142  * xmlSkipBlankChars:
 2143  * @ctxt:  the XML parser context
 2144  *
 2145  * skip all blanks character found at that point in the input streams.
 2146  * It pops up finished entities in the process if allowable at that point.
 2147  *
 2148  * Returns the number of space chars skipped
 2149  */
 2150 
 2151 int
 2152 xmlSkipBlankChars(xmlParserCtxtPtr ctxt) {
 2153     int res = 0;
 2154 
 2155     /*
 2156      * It&#39;s Okay to use CUR/NEXT here since all the blanks are on
 2157      * the ASCII range.
 2158      */
 2159     if ((ctxt-&gt;inputNr == 1) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_DTD)) {
 2160     const xmlChar *cur;
 2161     /*
 2162      * if we are in the document content, go really fast
 2163      */
 2164     cur = ctxt-&gt;input-&gt;cur;
 2165     while (IS_BLANK_CH(*cur)) {
 2166         if (*cur == &#39;\n&#39;) {
 2167         ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;
 2168         } else {
 2169         ctxt-&gt;input-&gt;col++;
 2170         }
 2171         cur++;
 2172         res++;
 2173         if (*cur == 0) {
 2174         ctxt-&gt;input-&gt;cur = cur;
 2175         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 2176         cur = ctxt-&gt;input-&gt;cur;
 2177         }
 2178     }
 2179     ctxt-&gt;input-&gt;cur = cur;
 2180     } else {
 2181         int expandPE = ((ctxt-&gt;external != 0) || (ctxt-&gt;inputNr != 1));
 2182 
 2183     while (1) {
 2184             if (IS_BLANK_CH(CUR)) { /* CHECKED tstblanks.xml */
 2185         NEXT;
 2186         } else if (CUR == &#39;%&#39;) {
 2187                 /*
 2188                  * Need to handle support of entities branching here
 2189                  */
 2190             if ((expandPE == 0) || (IS_BLANK_CH(NXT(1))) || (NXT(1) == 0))
 2191                     break;
 2192             xmlParsePEReference(ctxt);
 2193             } else if (CUR == 0) {
 2194                 if (ctxt-&gt;inputNr &lt;= 1)
 2195                     break;
 2196                 xmlPopInput(ctxt);
 2197             } else {
 2198                 break;
 2199             }
 2200 
 2201             /*
 2202              * Also increase the counter when entering or exiting a PERef.
 2203              * The spec says: &quot;When a parameter-entity reference is recognized
 2204              * in the DTD and included, its replacement text MUST be enlarged
 2205              * by the attachment of one leading and one following space (#x20)
 2206              * character.&quot;
 2207              */
 2208         res++;
 2209         }
 2210     }
 2211     return(res);
 2212 }
 2213 
 2214 /************************************************************************
 2215  *                                  *
 2216  *      Commodity functions to handle entities          *
 2217  *                                  *
 2218  ************************************************************************/
 2219 
 2220 /**
 2221  * xmlPopInput:
 2222  * @ctxt:  an XML parser context
 2223  *
 2224  * xmlPopInput: the current input pointed by ctxt-&gt;input came to an end
 2225  *          pop it and return the next char.
 2226  *
 2227  * Returns the current xmlChar in the parser context
 2228  */
 2229 xmlChar
 2230 xmlPopInput(xmlParserCtxtPtr ctxt) {
 2231     if ((ctxt == NULL) || (ctxt-&gt;inputNr &lt;= 1)) return(0);
 2232     if (xmlParserDebugEntities)
 2233     xmlGenericError(xmlGenericErrorContext,
 2234         &quot;Popping input %d\n&quot;, ctxt-&gt;inputNr);
 2235     if ((ctxt-&gt;inputNr &gt; 1) &amp;&amp; (ctxt-&gt;inSubset == 0) &amp;&amp;
 2236         (ctxt-&gt;instate != XML_PARSER_EOF))
 2237         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 2238                     &quot;Unfinished entity outside the DTD&quot;);
 2239     xmlFreeInputStream(inputPop(ctxt));
 2240     if (*ctxt-&gt;input-&gt;cur == 0)
 2241         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 2242     return(CUR);
 2243 }
 2244 
 2245 /**
 2246  * xmlPushInput:
 2247  * @ctxt:  an XML parser context
 2248  * @input:  an XML parser input fragment (entity, XML fragment ...).
 2249  *
 2250  * xmlPushInput: switch to a new input stream which is stacked on top
 2251  *               of the previous one(s).
 2252  * Returns -1 in case of error or the index in the input stack
 2253  */
 2254 int
 2255 xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {
 2256     int ret;
 2257     if (input == NULL) return(-1);
 2258 
 2259     if (xmlParserDebugEntities) {
 2260     if ((ctxt-&gt;input != NULL) &amp;&amp; (ctxt-&gt;input-&gt;filename))
 2261         xmlGenericError(xmlGenericErrorContext,
 2262             &quot;%s(%d): &quot;, ctxt-&gt;input-&gt;filename,
 2263             ctxt-&gt;input-&gt;line);
 2264     xmlGenericError(xmlGenericErrorContext,
 2265         &quot;Pushing input %d : %.30s\n&quot;, ctxt-&gt;inputNr+1, input-&gt;cur);
 2266     }
 2267     if (((ctxt-&gt;inputNr &gt; 40) &amp;&amp; ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) ||
 2268         (ctxt-&gt;inputNr &gt; 1024)) {
 2269         xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 2270         while (ctxt-&gt;inputNr &gt; 1)
 2271             xmlFreeInputStream(inputPop(ctxt));
 2272     return(-1);
 2273     }
 2274     ret = inputPush(ctxt, input);
 2275     if (ctxt-&gt;instate == XML_PARSER_EOF)
 2276         return(-1);
 2277     GROW;
 2278     return(ret);
 2279 }
 2280 
 2281 /**
 2282  * xmlParseCharRef:
 2283  * @ctxt:  an XML parser context
 2284  *
 2285  * parse Reference declarations
 2286  *
 2287  * [66] CharRef ::= &#39;&amp;#&#39; [0-9]+ &#39;;&#39; |
 2288  *                  &#39;&amp;#x&#39; [0-9a-fA-F]+ &#39;;&#39;
 2289  *
 2290  * [ WFC: Legal Character ]
 2291  * Characters referred to using character references must match the
 2292  * production for Char.
 2293  *
 2294  * Returns the value parsed (as an int), 0 in case of error
 2295  */
 2296 int
 2297 xmlParseCharRef(xmlParserCtxtPtr ctxt) {
 2298     int val = 0;
 2299     int count = 0;
 2300 
 2301     /*
 2302      * Using RAW/CUR/NEXT is okay since we are working on ASCII range here
 2303      */
 2304     if ((RAW == &#39;&amp;&#39;) &amp;&amp; (NXT(1) == &#39;#&#39;) &amp;&amp;
 2305         (NXT(2) == &#39;x&#39;)) {
 2306     SKIP(3);
 2307     GROW;
 2308     while (RAW != &#39;;&#39;) { /* loop blocked by count */
 2309         if (count++ &gt; 20) {
 2310         count = 0;
 2311         GROW;
 2312                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 2313                     return(0);
 2314         }
 2315         if ((RAW &gt;= &#39;0&#39;) &amp;&amp; (RAW &lt;= &#39;9&#39;))
 2316             val = val * 16 + (CUR - &#39;0&#39;);
 2317         else if ((RAW &gt;= &#39;a&#39;) &amp;&amp; (RAW &lt;= &#39;f&#39;) &amp;&amp; (count &lt; 20))
 2318             val = val * 16 + (CUR - &#39;a&#39;) + 10;
 2319         else if ((RAW &gt;= &#39;A&#39;) &amp;&amp; (RAW &lt;= &#39;F&#39;) &amp;&amp; (count &lt; 20))
 2320             val = val * 16 + (CUR - &#39;A&#39;) + 10;
 2321         else {
 2322         xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);
 2323         val = 0;
 2324         break;
 2325         }
 2326         if (val &gt; 0x110000)
 2327             val = 0x110000;
 2328 
 2329         NEXT;
 2330         count++;
 2331     }
 2332     if (RAW == &#39;;&#39;) {
 2333         /* on purpose to avoid reentrancy problems with NEXT and SKIP */
 2334         ctxt-&gt;input-&gt;col++;
 2335         ctxt-&gt;nbChars ++;
 2336         ctxt-&gt;input-&gt;cur++;
 2337     }
 2338     } else if  ((RAW == &#39;&amp;&#39;) &amp;&amp; (NXT(1) == &#39;#&#39;)) {
 2339     SKIP(2);
 2340     GROW;
 2341     while (RAW != &#39;;&#39;) { /* loop blocked by count */
 2342         if (count++ &gt; 20) {
 2343         count = 0;
 2344         GROW;
 2345                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 2346                     return(0);
 2347         }
 2348         if ((RAW &gt;= &#39;0&#39;) &amp;&amp; (RAW &lt;= &#39;9&#39;))
 2349             val = val * 10 + (CUR - &#39;0&#39;);
 2350         else {
 2351         xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);
 2352         val = 0;
 2353         break;
 2354         }
 2355         if (val &gt; 0x110000)
 2356             val = 0x110000;
 2357 
 2358         NEXT;
 2359         count++;
 2360     }
 2361     if (RAW == &#39;;&#39;) {
 2362         /* on purpose to avoid reentrancy problems with NEXT and SKIP */
 2363         ctxt-&gt;input-&gt;col++;
 2364         ctxt-&gt;nbChars ++;
 2365         ctxt-&gt;input-&gt;cur++;
 2366     }
 2367     } else {
 2368         xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);
 2369     }
 2370 
 2371     /*
 2372      * [ WFC: Legal Character ]
 2373      * Characters referred to using character references must match the
 2374      * production for Char.
 2375      */
 2376     if (val &gt;= 0x110000) {
 2377         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 2378                 &quot;xmlParseCharRef: character reference out of bounds\n&quot;,
 2379             val);
 2380     } else if (IS_CHAR(val)) {
 2381         return(val);
 2382     } else {
 2383         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 2384                           &quot;xmlParseCharRef: invalid xmlChar value %d\n&quot;,
 2385                       val);
 2386     }
 2387     return(0);
 2388 }
 2389 
 2390 /**
 2391  * xmlParseStringCharRef:
 2392  * @ctxt:  an XML parser context
 2393  * @str:  a pointer to an index in the string
 2394  *
 2395  * parse Reference declarations, variant parsing from a string rather
 2396  * than an an input flow.
 2397  *
 2398  * [66] CharRef ::= &#39;&amp;#&#39; [0-9]+ &#39;;&#39; |
 2399  *                  &#39;&amp;#x&#39; [0-9a-fA-F]+ &#39;;&#39;
 2400  *
 2401  * [ WFC: Legal Character ]
 2402  * Characters referred to using character references must match the
 2403  * production for Char.
 2404  *
 2405  * Returns the value parsed (as an int), 0 in case of error, str will be
 2406  *         updated to the current value of the index
 2407  */
 2408 static int
 2409 xmlParseStringCharRef(xmlParserCtxtPtr ctxt, const xmlChar **str) {
 2410     const xmlChar *ptr;
 2411     xmlChar cur;
 2412     int val = 0;
 2413 
 2414     if ((str == NULL) || (*str == NULL)) return(0);
 2415     ptr = *str;
 2416     cur = *ptr;
 2417     if ((cur == &#39;&amp;&#39;) &amp;&amp; (ptr[1] == &#39;#&#39;) &amp;&amp; (ptr[2] == &#39;x&#39;)) {
 2418     ptr += 3;
 2419     cur = *ptr;
 2420     while (cur != &#39;;&#39;) { /* Non input consuming loop */
 2421         if ((cur &gt;= &#39;0&#39;) &amp;&amp; (cur &lt;= &#39;9&#39;))
 2422             val = val * 16 + (cur - &#39;0&#39;);
 2423         else if ((cur &gt;= &#39;a&#39;) &amp;&amp; (cur &lt;= &#39;f&#39;))
 2424             val = val * 16 + (cur - &#39;a&#39;) + 10;
 2425         else if ((cur &gt;= &#39;A&#39;) &amp;&amp; (cur &lt;= &#39;F&#39;))
 2426             val = val * 16 + (cur - &#39;A&#39;) + 10;
 2427         else {
 2428         xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);
 2429         val = 0;
 2430         break;
 2431         }
 2432         if (val &gt; 0x110000)
 2433             val = 0x110000;
 2434 
 2435         ptr++;
 2436         cur = *ptr;
 2437     }
 2438     if (cur == &#39;;&#39;)
 2439         ptr++;
 2440     } else if  ((cur == &#39;&amp;&#39;) &amp;&amp; (ptr[1] == &#39;#&#39;)){
 2441     ptr += 2;
 2442     cur = *ptr;
 2443     while (cur != &#39;;&#39;) { /* Non input consuming loops */
 2444         if ((cur &gt;= &#39;0&#39;) &amp;&amp; (cur &lt;= &#39;9&#39;))
 2445             val = val * 10 + (cur - &#39;0&#39;);
 2446         else {
 2447         xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);
 2448         val = 0;
 2449         break;
 2450         }
 2451         if (val &gt; 0x110000)
 2452             val = 0x110000;
 2453 
 2454         ptr++;
 2455         cur = *ptr;
 2456     }
 2457     if (cur == &#39;;&#39;)
 2458         ptr++;
 2459     } else {
 2460     xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);
 2461     return(0);
 2462     }
 2463     *str = ptr;
 2464 
 2465     /*
 2466      * [ WFC: Legal Character ]
 2467      * Characters referred to using character references must match the
 2468      * production for Char.
 2469      */
 2470     if (val &gt;= 0x110000) {
 2471         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 2472                 &quot;xmlParseStringCharRef: character reference out of bounds\n&quot;,
 2473                 val);
 2474     } else if (IS_CHAR(val)) {
 2475         return(val);
 2476     } else {
 2477         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 2478               &quot;xmlParseStringCharRef: invalid xmlChar value %d\n&quot;,
 2479               val);
 2480     }
 2481     return(0);
 2482 }
 2483 
 2484 /**
 2485  * xmlParserHandlePEReference:
 2486  * @ctxt:  the parser context
 2487  *
 2488  * [69] PEReference ::= &#39;%&#39; Name &#39;;&#39;
 2489  *
 2490  * [ WFC: No Recursion ]
 2491  * A parsed entity must not contain a recursive
 2492  * reference to itself, either directly or indirectly.
 2493  *
 2494  * [ WFC: Entity Declared ]
 2495  * In a document without any DTD, a document with only an internal DTD
 2496  * subset which contains no parameter entity references, or a document
 2497  * with &quot;standalone=&#39;yes&#39;&quot;, ...  ... The declaration of a parameter
 2498  * entity must precede any reference to it...
 2499  *
 2500  * [ VC: Entity Declared ]
 2501  * In a document with an external subset or external parameter entities
 2502  * with &quot;standalone=&#39;no&#39;&quot;, ...  ... The declaration of a parameter entity
 2503  * must precede any reference to it...
 2504  *
 2505  * [ WFC: In DTD ]
 2506  * Parameter-entity references may only appear in the DTD.
 2507  * NOTE: misleading but this is handled.
 2508  *
 2509  * A PEReference may have been detected in the current input stream
 2510  * the handling is done accordingly to
 2511  *      http://www.w3.org/TR/REC-xml#entproc
 2512  * i.e.
 2513  *   - Included in literal in entity values
 2514  *   - Included as Parameter Entity reference within DTDs
 2515  */
 2516 void
 2517 xmlParserHandlePEReference(xmlParserCtxtPtr ctxt) {
 2518     switch(ctxt-&gt;instate) {
 2519     case XML_PARSER_CDATA_SECTION:
 2520         return;
 2521         case XML_PARSER_COMMENT:
 2522         return;
 2523     case XML_PARSER_START_TAG:
 2524         return;
 2525     case XML_PARSER_END_TAG:
 2526         return;
 2527         case XML_PARSER_EOF:
 2528         xmlFatalErr(ctxt, XML_ERR_PEREF_AT_EOF, NULL);
 2529         return;
 2530         case XML_PARSER_PROLOG:
 2531     case XML_PARSER_START:
 2532     case XML_PARSER_MISC:
 2533         xmlFatalErr(ctxt, XML_ERR_PEREF_IN_PROLOG, NULL);
 2534         return;
 2535     case XML_PARSER_ENTITY_DECL:
 2536         case XML_PARSER_CONTENT:
 2537         case XML_PARSER_ATTRIBUTE_VALUE:
 2538         case XML_PARSER_PI:
 2539     case XML_PARSER_SYSTEM_LITERAL:
 2540     case XML_PARSER_PUBLIC_LITERAL:
 2541         /* we just ignore it there */
 2542         return;
 2543         case XML_PARSER_EPILOG:
 2544         xmlFatalErr(ctxt, XML_ERR_PEREF_IN_EPILOG, NULL);
 2545         return;
 2546     case XML_PARSER_ENTITY_VALUE:
 2547         /*
 2548          * NOTE: in the case of entity values, we don&#39;t do the
 2549          *       substitution here since we need the literal
 2550          *       entity value to be able to save the internal
 2551          *       subset of the document.
 2552          *       This will be handled by xmlStringDecodeEntities
 2553          */
 2554         return;
 2555         case XML_PARSER_DTD:
 2556         /*
 2557          * [WFC: Well-Formedness Constraint: PEs in Internal Subset]
 2558          * In the internal DTD subset, parameter-entity references
 2559          * can occur only where markup declarations can occur, not
 2560          * within markup declarations.
 2561          * In that case this is handled in xmlParseMarkupDecl
 2562          */
 2563         if ((ctxt-&gt;external == 0) &amp;&amp; (ctxt-&gt;inputNr == 1))
 2564         return;
 2565         if (IS_BLANK_CH(NXT(1)) || NXT(1) == 0)
 2566         return;
 2567             break;
 2568         case XML_PARSER_IGNORE:
 2569             return;
 2570     }
 2571 
 2572     xmlParsePEReference(ctxt);
 2573 }
 2574 
 2575 /*
 2576  * Macro used to grow the current buffer.
 2577  * buffer##_size is expected to be a size_t
 2578  * mem_error: is expected to handle memory allocation failures
 2579  */
 2580 #define growBuffer(buffer, n) {                     \
 2581     xmlChar *tmp;                           \
 2582     size_t new_size = buffer##_size * 2 + n;                            \
 2583     if (new_size &lt; buffer##_size) goto mem_error;                       \
 2584     tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
 2585     if (tmp == NULL) goto mem_error;                    \
 2586     buffer = tmp;                           \
 2587     buffer##_size = new_size;                                           \
 2588 }
 2589 
 2590 /**
 2591  * xmlStringLenDecodeEntities:
 2592  * @ctxt:  the parser context
 2593  * @str:  the input string
 2594  * @len: the string length
 2595  * @what:  combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF
 2596  * @end:  an end marker xmlChar, 0 if none
 2597  * @end2:  an end marker xmlChar, 0 if none
 2598  * @end3:  an end marker xmlChar, 0 if none
 2599  *
 2600  * Takes a entity string content and process to do the adequate substitutions.
 2601  *
 2602  * [67] Reference ::= EntityRef | CharRef
 2603  *
 2604  * [69] PEReference ::= &#39;%&#39; Name &#39;;&#39;
 2605  *
 2606  * Returns A newly allocated string with the substitution done. The caller
 2607  *      must deallocate it !
 2608  */
 2609 xmlChar *
 2610 xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int len,
 2611               int what, xmlChar end, xmlChar  end2, xmlChar end3) {
 2612     xmlChar *buffer = NULL;
 2613     size_t buffer_size = 0;
 2614     size_t nbchars = 0;
 2615 
 2616     xmlChar *current = NULL;
 2617     xmlChar *rep = NULL;
 2618     const xmlChar *last;
 2619     xmlEntityPtr ent;
 2620     int c,l;
 2621 
 2622     if ((ctxt == NULL) || (str == NULL) || (len &lt; 0))
 2623     return(NULL);
 2624     last = str + len;
 2625 
 2626     if (((ctxt-&gt;depth &gt; 40) &amp;&amp;
 2627          ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) ||
 2628     (ctxt-&gt;depth &gt; 1024)) {
 2629     xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 2630     return(NULL);
 2631     }
 2632 
 2633     /*
 2634      * allocate a translation buffer.
 2635      */
 2636     buffer_size = XML_PARSER_BIG_BUFFER_SIZE;
 2637     buffer = (xmlChar *) xmlMallocAtomic(buffer_size);
 2638     if (buffer == NULL) goto mem_error;
 2639 
 2640     /*
 2641      * OK loop until we reach one of the ending char or a size limit.
 2642      * we are operating on already parsed values.
 2643      */
 2644     if (str &lt; last)
 2645     c = CUR_SCHAR(str, l);
 2646     else
 2647         c = 0;
 2648     while ((c != 0) &amp;&amp; (c != end) &amp;&amp; /* non input consuming loop */
<a name="1" id="anc1"></a><span class="line-modified"> 2649            (c != end2) &amp;&amp; (c != end3) &amp;&amp;</span>
<span class="line-added"> 2650            (ctxt-&gt;instate != XML_PARSER_EOF)) {</span>
 2651 
 2652     if (c == 0) break;
 2653         if ((c == &#39;&amp;&#39;) &amp;&amp; (str[1] == &#39;#&#39;)) {
 2654         int val = xmlParseStringCharRef(ctxt, &amp;str);
 2655         if (val == 0)
 2656                 goto int_error;
 2657         COPY_BUF(0,buffer,nbchars,val);
 2658         if (nbchars + XML_PARSER_BUFFER_SIZE &gt; buffer_size) {
 2659             growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
 2660         }
 2661     } else if ((c == &#39;&amp;&#39;) &amp;&amp; (what &amp; XML_SUBSTITUTE_REF)) {
 2662         if (xmlParserDebugEntities)
 2663         xmlGenericError(xmlGenericErrorContext,
 2664             &quot;String decoding Entity Reference: %.30s\n&quot;,
 2665             str);
 2666         ent = xmlParseStringEntityRef(ctxt, &amp;str);
 2667         xmlParserEntityCheck(ctxt, 0, ent, 0);
 2668         if (ent != NULL)
 2669             ctxt-&gt;nbentities += ent-&gt;checked / 2;
 2670         if ((ent != NULL) &amp;&amp;
 2671         (ent-&gt;etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
 2672         if (ent-&gt;content != NULL) {
 2673             COPY_BUF(0,buffer,nbchars,ent-&gt;content[0]);
 2674             if (nbchars + XML_PARSER_BUFFER_SIZE &gt; buffer_size) {
 2675             growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
 2676             }
 2677         } else {
 2678             xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
 2679                 &quot;predefined entity has no content\n&quot;);
 2680                     goto int_error;
 2681         }
 2682         } else if ((ent != NULL) &amp;&amp; (ent-&gt;content != NULL)) {
 2683         ctxt-&gt;depth++;
 2684         rep = xmlStringDecodeEntities(ctxt, ent-&gt;content, what,
 2685                                   0, 0, 0);
 2686         ctxt-&gt;depth--;
 2687         if (rep == NULL)
 2688                     goto int_error;
 2689 
 2690                 current = rep;
 2691                 while (*current != 0) { /* non input consuming loop */
 2692                     buffer[nbchars++] = *current++;
 2693                     if (nbchars + XML_PARSER_BUFFER_SIZE &gt; buffer_size) {
 2694                         if (xmlParserEntityCheck(ctxt, nbchars, ent, 0))
 2695                             goto int_error;
 2696                         growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
 2697                     }
 2698                 }
 2699                 xmlFree(rep);
 2700                 rep = NULL;
 2701         } else if (ent != NULL) {
 2702         int i = xmlStrlen(ent-&gt;name);
 2703         const xmlChar *cur = ent-&gt;name;
 2704 
 2705         buffer[nbchars++] = &#39;&amp;&#39;;
 2706         if (nbchars + i + XML_PARSER_BUFFER_SIZE &gt; buffer_size) {
 2707             growBuffer(buffer, i + XML_PARSER_BUFFER_SIZE);
 2708         }
 2709         for (;i &gt; 0;i--)
 2710             buffer[nbchars++] = *cur++;
 2711         buffer[nbchars++] = &#39;;&#39;;
 2712         }
 2713     } else if (c == &#39;%&#39; &amp;&amp; (what &amp; XML_SUBSTITUTE_PEREF)) {
 2714         if (xmlParserDebugEntities)
 2715         xmlGenericError(xmlGenericErrorContext,
 2716             &quot;String decoding PE Reference: %.30s\n&quot;, str);
 2717         ent = xmlParseStringPEReference(ctxt, &amp;str);
 2718         xmlParserEntityCheck(ctxt, 0, ent, 0);
 2719         if (ent != NULL)
 2720             ctxt-&gt;nbentities += ent-&gt;checked / 2;
 2721         if (ent != NULL) {
 2722                 if (ent-&gt;content == NULL) {
 2723             /*
 2724              * Note: external parsed entities will not be loaded,
 2725              * it is not required for a non-validating parser to
 2726              * complete external PEReferences coming from the
 2727              * internal subset
 2728              */
 2729             if (((ctxt-&gt;options &amp; XML_PARSE_NOENT) != 0) ||
 2730             ((ctxt-&gt;options &amp; XML_PARSE_DTDVALID) != 0) ||
 2731             (ctxt-&gt;validate != 0)) {
 2732             xmlLoadEntityContent(ctxt, ent);
 2733             } else {
 2734             xmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
 2735           &quot;not validating will not read content for PE entity %s\n&quot;,
 2736                               ent-&gt;name, NULL);
 2737             }
 2738         }
 2739         ctxt-&gt;depth++;
 2740         rep = xmlStringDecodeEntities(ctxt, ent-&gt;content, what,
 2741                                   0, 0, 0);
 2742         ctxt-&gt;depth--;
 2743         if (rep == NULL)
 2744                     goto int_error;
 2745                 current = rep;
 2746                 while (*current != 0) { /* non input consuming loop */
 2747                     buffer[nbchars++] = *current++;
 2748                     if (nbchars + XML_PARSER_BUFFER_SIZE &gt; buffer_size) {
 2749                         if (xmlParserEntityCheck(ctxt, nbchars, ent, 0))
 2750                             goto int_error;
 2751                         growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
 2752                     }
 2753                 }
 2754                 xmlFree(rep);
 2755                 rep = NULL;
 2756         }
 2757     } else {
 2758         COPY_BUF(l,buffer,nbchars,c);
 2759         str += l;
 2760         if (nbchars + XML_PARSER_BUFFER_SIZE &gt; buffer_size) {
 2761             growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
 2762         }
 2763     }
 2764     if (str &lt; last)
 2765         c = CUR_SCHAR(str, l);
 2766     else
 2767         c = 0;
 2768     }
 2769     buffer[nbchars] = 0;
 2770     return(buffer);
 2771 
 2772 mem_error:
 2773     xmlErrMemory(ctxt, NULL);
 2774 int_error:
 2775     if (rep != NULL)
 2776         xmlFree(rep);
 2777     if (buffer != NULL)
 2778         xmlFree(buffer);
 2779     return(NULL);
 2780 }
 2781 
 2782 /**
 2783  * xmlStringDecodeEntities:
 2784  * @ctxt:  the parser context
 2785  * @str:  the input string
 2786  * @what:  combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF
 2787  * @end:  an end marker xmlChar, 0 if none
 2788  * @end2:  an end marker xmlChar, 0 if none
 2789  * @end3:  an end marker xmlChar, 0 if none
 2790  *
 2791  * Takes a entity string content and process to do the adequate substitutions.
 2792  *
 2793  * [67] Reference ::= EntityRef | CharRef
 2794  *
 2795  * [69] PEReference ::= &#39;%&#39; Name &#39;;&#39;
 2796  *
 2797  * Returns A newly allocated string with the substitution done. The caller
 2798  *      must deallocate it !
 2799  */
 2800 xmlChar *
 2801 xmlStringDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int what,
 2802                 xmlChar end, xmlChar  end2, xmlChar end3) {
 2803     if ((ctxt == NULL) || (str == NULL)) return(NULL);
 2804     return(xmlStringLenDecodeEntities(ctxt, str, xmlStrlen(str), what,
 2805            end, end2, end3));
 2806 }
 2807 
 2808 /************************************************************************
 2809  *                                  *
 2810  *      Commodity functions, cleanup needed ?           *
 2811  *                                  *
 2812  ************************************************************************/
 2813 
 2814 /**
 2815  * areBlanks:
 2816  * @ctxt:  an XML parser context
 2817  * @str:  a xmlChar *
 2818  * @len:  the size of @str
 2819  * @blank_chars: we know the chars are blanks
 2820  *
 2821  * Is this a sequence of blank chars that one can ignore ?
 2822  *
 2823  * Returns 1 if ignorable 0 otherwise.
 2824  */
 2825 
 2826 static int areBlanks(xmlParserCtxtPtr ctxt, const xmlChar *str, int len,
 2827                      int blank_chars) {
 2828     int i, ret;
 2829     xmlNodePtr lastChild;
 2830 
 2831     /*
 2832      * Don&#39;t spend time trying to differentiate them, the same callback is
 2833      * used !
 2834      */
 2835     if (ctxt-&gt;sax-&gt;ignorableWhitespace == ctxt-&gt;sax-&gt;characters)
 2836     return(0);
 2837 
 2838     /*
 2839      * Check for xml:space value.
 2840      */
 2841     if ((ctxt-&gt;space == NULL) || (*(ctxt-&gt;space) == 1) ||
 2842         (*(ctxt-&gt;space) == -2))
 2843     return(0);
 2844 
 2845     /*
 2846      * Check that the string is made of blanks
 2847      */
 2848     if (blank_chars == 0) {
 2849     for (i = 0;i &lt; len;i++)
 2850         if (!(IS_BLANK_CH(str[i]))) return(0);
 2851     }
 2852 
 2853     /*
 2854      * Look if the element is mixed content in the DTD if available
 2855      */
 2856     if (ctxt-&gt;node == NULL) return(0);
 2857     if (ctxt-&gt;myDoc != NULL) {
 2858     ret = xmlIsMixedElement(ctxt-&gt;myDoc, ctxt-&gt;node-&gt;name);
 2859         if (ret == 0) return(1);
 2860         if (ret == 1) return(0);
 2861     }
 2862 
 2863     /*
 2864      * Otherwise, heuristic :-\
 2865      */
 2866     if ((RAW != &#39;&lt;&#39;) &amp;&amp; (RAW != 0xD)) return(0);
 2867     if ((ctxt-&gt;node-&gt;children == NULL) &amp;&amp;
 2868     (RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) return(0);
 2869 
 2870     lastChild = xmlGetLastChild(ctxt-&gt;node);
 2871     if (lastChild == NULL) {
 2872         if ((ctxt-&gt;node-&gt;type != XML_ELEMENT_NODE) &amp;&amp;
 2873             (ctxt-&gt;node-&gt;content != NULL)) return(0);
 2874     } else if (xmlNodeIsText(lastChild))
 2875         return(0);
 2876     else if ((ctxt-&gt;node-&gt;children != NULL) &amp;&amp;
 2877              (xmlNodeIsText(ctxt-&gt;node-&gt;children)))
 2878         return(0);
 2879     return(1);
 2880 }
 2881 
 2882 /************************************************************************
 2883  *                                  *
 2884  *      Extra stuff for namespace support           *
 2885  *  Relates to http://www.w3.org/TR/WD-xml-names            *
 2886  *                                  *
 2887  ************************************************************************/
 2888 
 2889 /**
 2890  * xmlSplitQName:
 2891  * @ctxt:  an XML parser context
 2892  * @name:  an XML parser context
 2893  * @prefix:  a xmlChar **
 2894  *
 2895  * parse an UTF8 encoded XML qualified name string
 2896  *
 2897  * [NS 5] QName ::= (Prefix &#39;:&#39;)? LocalPart
 2898  *
 2899  * [NS 6] Prefix ::= NCName
 2900  *
 2901  * [NS 7] LocalPart ::= NCName
 2902  *
 2903  * Returns the local part, and prefix is updated
 2904  *   to get the Prefix if any.
 2905  */
 2906 
 2907 xmlChar *
 2908 xmlSplitQName(xmlParserCtxtPtr ctxt, const xmlChar *name, xmlChar **prefix) {
 2909     xmlChar buf[XML_MAX_NAMELEN + 5];
 2910     xmlChar *buffer = NULL;
 2911     int len = 0;
 2912     int max = XML_MAX_NAMELEN;
 2913     xmlChar *ret = NULL;
 2914     const xmlChar *cur = name;
 2915     int c;
 2916 
 2917     if (prefix == NULL) return(NULL);
 2918     *prefix = NULL;
 2919 
 2920     if (cur == NULL) return(NULL);
 2921 
 2922 #ifndef XML_XML_NAMESPACE
 2923     /* xml: prefix is not really a namespace */
 2924     if ((cur[0] == &#39;x&#39;) &amp;&amp; (cur[1] == &#39;m&#39;) &amp;&amp;
 2925         (cur[2] == &#39;l&#39;) &amp;&amp; (cur[3] == &#39;:&#39;))
 2926     return(xmlStrdup(name));
 2927 #endif
 2928 
 2929     /* nasty but well=formed */
 2930     if (cur[0] == &#39;:&#39;)
 2931     return(xmlStrdup(name));
 2932 
 2933     c = *cur++;
 2934     while ((c != 0) &amp;&amp; (c != &#39;:&#39;) &amp;&amp; (len &lt; max)) { /* tested bigname.xml */
 2935     buf[len++] = c;
 2936     c = *cur++;
 2937     }
 2938     if (len &gt;= max) {
 2939     /*
 2940      * Okay someone managed to make a huge name, so he&#39;s ready to pay
 2941      * for the processing speed.
 2942      */
 2943     max = len * 2;
 2944 
 2945     buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));
 2946     if (buffer == NULL) {
 2947         xmlErrMemory(ctxt, NULL);
 2948         return(NULL);
 2949     }
 2950     memcpy(buffer, buf, len);
 2951     while ((c != 0) &amp;&amp; (c != &#39;:&#39;)) { /* tested bigname.xml */
 2952         if (len + 10 &gt; max) {
 2953             xmlChar *tmp;
 2954 
 2955         max *= 2;
 2956         tmp = (xmlChar *) xmlRealloc(buffer,
 2957                         max * sizeof(xmlChar));
 2958         if (tmp == NULL) {
 2959             xmlFree(buffer);
 2960             xmlErrMemory(ctxt, NULL);
 2961             return(NULL);
 2962         }
 2963         buffer = tmp;
 2964         }
 2965         buffer[len++] = c;
 2966         c = *cur++;
 2967     }
 2968     buffer[len] = 0;
 2969     }
 2970 
 2971     if ((c == &#39;:&#39;) &amp;&amp; (*cur == 0)) {
 2972         if (buffer != NULL)
 2973         xmlFree(buffer);
 2974     *prefix = NULL;
 2975     return(xmlStrdup(name));
 2976     }
 2977 
 2978     if (buffer == NULL)
 2979     ret = xmlStrndup(buf, len);
 2980     else {
 2981     ret = buffer;
 2982     buffer = NULL;
 2983     max = XML_MAX_NAMELEN;
 2984     }
 2985 
 2986 
 2987     if (c == &#39;:&#39;) {
 2988     c = *cur;
 2989         *prefix = ret;
 2990     if (c == 0) {
 2991         return(xmlStrndup(BAD_CAST &quot;&quot;, 0));
 2992     }
 2993     len = 0;
 2994 
 2995     /*
 2996      * Check that the first character is proper to start
 2997      * a new name
 2998      */
 2999     if (!(((c &gt;= 0x61) &amp;&amp; (c &lt;= 0x7A)) ||
 3000           ((c &gt;= 0x41) &amp;&amp; (c &lt;= 0x5A)) ||
 3001           (c == &#39;_&#39;) || (c == &#39;:&#39;))) {
 3002         int l;
 3003         int first = CUR_SCHAR(cur, l);
 3004 
 3005         if (!IS_LETTER(first) &amp;&amp; (first != &#39;_&#39;)) {
 3006         xmlFatalErrMsgStr(ctxt, XML_NS_ERR_QNAME,
 3007                 &quot;Name %s is not XML Namespace compliant\n&quot;,
 3008                   name);
 3009         }
 3010     }
 3011     cur++;
 3012 
 3013     while ((c != 0) &amp;&amp; (len &lt; max)) { /* tested bigname2.xml */
 3014         buf[len++] = c;
 3015         c = *cur++;
 3016     }
 3017     if (len &gt;= max) {
 3018         /*
 3019          * Okay someone managed to make a huge name, so he&#39;s ready to pay
 3020          * for the processing speed.
 3021          */
 3022         max = len * 2;
 3023 
 3024         buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));
 3025         if (buffer == NULL) {
 3026             xmlErrMemory(ctxt, NULL);
 3027         return(NULL);
 3028         }
 3029         memcpy(buffer, buf, len);
 3030         while (c != 0) { /* tested bigname2.xml */
 3031         if (len + 10 &gt; max) {
 3032             xmlChar *tmp;
 3033 
 3034             max *= 2;
 3035             tmp = (xmlChar *) xmlRealloc(buffer,
 3036                             max * sizeof(xmlChar));
 3037             if (tmp == NULL) {
 3038             xmlErrMemory(ctxt, NULL);
 3039             xmlFree(buffer);
 3040             return(NULL);
 3041             }
 3042             buffer = tmp;
 3043         }
 3044         buffer[len++] = c;
 3045         c = *cur++;
 3046         }
 3047         buffer[len] = 0;
 3048     }
 3049 
 3050     if (buffer == NULL)
 3051         ret = xmlStrndup(buf, len);
 3052     else {
 3053         ret = buffer;
 3054     }
 3055     }
 3056 
 3057     return(ret);
 3058 }
 3059 
 3060 /************************************************************************
 3061  *                                  *
 3062  *          The parser itself               *
 3063  *  Relates to http://www.w3.org/TR/REC-xml             *
 3064  *                                  *
 3065  ************************************************************************/
 3066 
 3067 /************************************************************************
 3068  *                                  *
 3069  *  Routines to parse Name, NCName and NmToken          *
 3070  *                                  *
 3071  ************************************************************************/
 3072 #ifdef DEBUG
 3073 static unsigned long nbParseName = 0;
 3074 static unsigned long nbParseNmToken = 0;
 3075 static unsigned long nbParseNCName = 0;
 3076 static unsigned long nbParseNCNameComplex = 0;
 3077 static unsigned long nbParseNameComplex = 0;
 3078 static unsigned long nbParseStringName = 0;
 3079 #endif
 3080 
 3081 /*
 3082  * The two following functions are related to the change of accepted
 3083  * characters for Name and NmToken in the Revision 5 of XML-1.0
 3084  * They correspond to the modified production [4] and the new production [4a]
 3085  * changes in that revision. Also note that the macros used for the
 3086  * productions Letter, Digit, CombiningChar and Extender are not needed
 3087  * anymore.
 3088  * We still keep compatibility to pre-revision5 parsing semantic if the
 3089  * new XML_PARSE_OLD10 option is given to the parser.
 3090  */
 3091 static int
 3092 xmlIsNameStartChar(xmlParserCtxtPtr ctxt, int c) {
 3093     if ((ctxt-&gt;options &amp; XML_PARSE_OLD10) == 0) {
 3094         /*
 3095      * Use the new checks of production [4] [4a] amd [5] of the
 3096      * Update 5 of XML-1.0
 3097      */
 3098     if ((c != &#39; &#39;) &amp;&amp; (c != &#39;&gt;&#39;) &amp;&amp; (c != &#39;/&#39;) &amp;&amp; /* accelerators */
 3099         (((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;z&#39;)) ||
 3100          ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;Z&#39;)) ||
 3101          (c == &#39;_&#39;) || (c == &#39;:&#39;) ||
 3102          ((c &gt;= 0xC0) &amp;&amp; (c &lt;= 0xD6)) ||
 3103          ((c &gt;= 0xD8) &amp;&amp; (c &lt;= 0xF6)) ||
 3104          ((c &gt;= 0xF8) &amp;&amp; (c &lt;= 0x2FF)) ||
 3105          ((c &gt;= 0x370) &amp;&amp; (c &lt;= 0x37D)) ||
 3106          ((c &gt;= 0x37F) &amp;&amp; (c &lt;= 0x1FFF)) ||
 3107          ((c &gt;= 0x200C) &amp;&amp; (c &lt;= 0x200D)) ||
 3108          ((c &gt;= 0x2070) &amp;&amp; (c &lt;= 0x218F)) ||
 3109          ((c &gt;= 0x2C00) &amp;&amp; (c &lt;= 0x2FEF)) ||
 3110          ((c &gt;= 0x3001) &amp;&amp; (c &lt;= 0xD7FF)) ||
 3111          ((c &gt;= 0xF900) &amp;&amp; (c &lt;= 0xFDCF)) ||
 3112          ((c &gt;= 0xFDF0) &amp;&amp; (c &lt;= 0xFFFD)) ||
 3113          ((c &gt;= 0x10000) &amp;&amp; (c &lt;= 0xEFFFF))))
 3114         return(1);
 3115     } else {
 3116         if (IS_LETTER(c) || (c == &#39;_&#39;) || (c == &#39;:&#39;))
 3117         return(1);
 3118     }
 3119     return(0);
 3120 }
 3121 
 3122 static int
 3123 xmlIsNameChar(xmlParserCtxtPtr ctxt, int c) {
 3124     if ((ctxt-&gt;options &amp; XML_PARSE_OLD10) == 0) {
 3125         /*
 3126      * Use the new checks of production [4] [4a] amd [5] of the
 3127      * Update 5 of XML-1.0
 3128      */
 3129     if ((c != &#39; &#39;) &amp;&amp; (c != &#39;&gt;&#39;) &amp;&amp; (c != &#39;/&#39;) &amp;&amp; /* accelerators */
 3130         (((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;z&#39;)) ||
 3131          ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;Z&#39;)) ||
 3132          ((c &gt;= &#39;0&#39;) &amp;&amp; (c &lt;= &#39;9&#39;)) || /* !start */
 3133          (c == &#39;_&#39;) || (c == &#39;:&#39;) ||
 3134          (c == &#39;-&#39;) || (c == &#39;.&#39;) || (c == 0xB7) || /* !start */
 3135          ((c &gt;= 0xC0) &amp;&amp; (c &lt;= 0xD6)) ||
 3136          ((c &gt;= 0xD8) &amp;&amp; (c &lt;= 0xF6)) ||
 3137          ((c &gt;= 0xF8) &amp;&amp; (c &lt;= 0x2FF)) ||
 3138          ((c &gt;= 0x300) &amp;&amp; (c &lt;= 0x36F)) || /* !start */
 3139          ((c &gt;= 0x370) &amp;&amp; (c &lt;= 0x37D)) ||
 3140          ((c &gt;= 0x37F) &amp;&amp; (c &lt;= 0x1FFF)) ||
 3141          ((c &gt;= 0x200C) &amp;&amp; (c &lt;= 0x200D)) ||
 3142          ((c &gt;= 0x203F) &amp;&amp; (c &lt;= 0x2040)) || /* !start */
 3143          ((c &gt;= 0x2070) &amp;&amp; (c &lt;= 0x218F)) ||
 3144          ((c &gt;= 0x2C00) &amp;&amp; (c &lt;= 0x2FEF)) ||
 3145          ((c &gt;= 0x3001) &amp;&amp; (c &lt;= 0xD7FF)) ||
 3146          ((c &gt;= 0xF900) &amp;&amp; (c &lt;= 0xFDCF)) ||
 3147          ((c &gt;= 0xFDF0) &amp;&amp; (c &lt;= 0xFFFD)) ||
 3148          ((c &gt;= 0x10000) &amp;&amp; (c &lt;= 0xEFFFF))))
 3149          return(1);
 3150     } else {
 3151         if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
 3152             (c == &#39;.&#39;) || (c == &#39;-&#39;) ||
 3153         (c == &#39;_&#39;) || (c == &#39;:&#39;) ||
 3154         (IS_COMBINING(c)) ||
 3155         (IS_EXTENDER(c)))
 3156         return(1);
 3157     }
 3158     return(0);
 3159 }
 3160 
 3161 static xmlChar * xmlParseAttValueInternal(xmlParserCtxtPtr ctxt,
 3162                                           int *len, int *alloc, int normalize);
 3163 
 3164 static const xmlChar *
 3165 xmlParseNameComplex(xmlParserCtxtPtr ctxt) {
 3166     int len = 0, l;
 3167     int c;
 3168     int count = 0;
 3169 
 3170 #ifdef DEBUG
 3171     nbParseNameComplex++;
 3172 #endif
 3173 
 3174     /*
 3175      * Handler for more complex cases
 3176      */
 3177     GROW;
 3178     if (ctxt-&gt;instate == XML_PARSER_EOF)
 3179         return(NULL);
 3180     c = CUR_CHAR(l);
 3181     if ((ctxt-&gt;options &amp; XML_PARSE_OLD10) == 0) {
 3182         /*
 3183      * Use the new checks of production [4] [4a] amd [5] of the
 3184      * Update 5 of XML-1.0
 3185      */
 3186     if ((c == &#39; &#39;) || (c == &#39;&gt;&#39;) || (c == &#39;/&#39;) || /* accelerators */
 3187         (!(((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;z&#39;)) ||
 3188            ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;Z&#39;)) ||
 3189            (c == &#39;_&#39;) || (c == &#39;:&#39;) ||
 3190            ((c &gt;= 0xC0) &amp;&amp; (c &lt;= 0xD6)) ||
 3191            ((c &gt;= 0xD8) &amp;&amp; (c &lt;= 0xF6)) ||
 3192            ((c &gt;= 0xF8) &amp;&amp; (c &lt;= 0x2FF)) ||
 3193            ((c &gt;= 0x370) &amp;&amp; (c &lt;= 0x37D)) ||
 3194            ((c &gt;= 0x37F) &amp;&amp; (c &lt;= 0x1FFF)) ||
 3195            ((c &gt;= 0x200C) &amp;&amp; (c &lt;= 0x200D)) ||
 3196            ((c &gt;= 0x2070) &amp;&amp; (c &lt;= 0x218F)) ||
 3197            ((c &gt;= 0x2C00) &amp;&amp; (c &lt;= 0x2FEF)) ||
 3198            ((c &gt;= 0x3001) &amp;&amp; (c &lt;= 0xD7FF)) ||
 3199            ((c &gt;= 0xF900) &amp;&amp; (c &lt;= 0xFDCF)) ||
 3200            ((c &gt;= 0xFDF0) &amp;&amp; (c &lt;= 0xFFFD)) ||
 3201            ((c &gt;= 0x10000) &amp;&amp; (c &lt;= 0xEFFFF))))) {
 3202         return(NULL);
 3203     }
 3204     len += l;
 3205     NEXTL(l);
 3206     c = CUR_CHAR(l);
 3207     while ((c != &#39; &#39;) &amp;&amp; (c != &#39;&gt;&#39;) &amp;&amp; (c != &#39;/&#39;) &amp;&amp; /* accelerators */
 3208            (((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;z&#39;)) ||
 3209             ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;Z&#39;)) ||
 3210             ((c &gt;= &#39;0&#39;) &amp;&amp; (c &lt;= &#39;9&#39;)) || /* !start */
 3211             (c == &#39;_&#39;) || (c == &#39;:&#39;) ||
 3212             (c == &#39;-&#39;) || (c == &#39;.&#39;) || (c == 0xB7) || /* !start */
 3213             ((c &gt;= 0xC0) &amp;&amp; (c &lt;= 0xD6)) ||
 3214             ((c &gt;= 0xD8) &amp;&amp; (c &lt;= 0xF6)) ||
 3215             ((c &gt;= 0xF8) &amp;&amp; (c &lt;= 0x2FF)) ||
 3216             ((c &gt;= 0x300) &amp;&amp; (c &lt;= 0x36F)) || /* !start */
 3217             ((c &gt;= 0x370) &amp;&amp; (c &lt;= 0x37D)) ||
 3218             ((c &gt;= 0x37F) &amp;&amp; (c &lt;= 0x1FFF)) ||
 3219             ((c &gt;= 0x200C) &amp;&amp; (c &lt;= 0x200D)) ||
 3220             ((c &gt;= 0x203F) &amp;&amp; (c &lt;= 0x2040)) || /* !start */
 3221             ((c &gt;= 0x2070) &amp;&amp; (c &lt;= 0x218F)) ||
 3222             ((c &gt;= 0x2C00) &amp;&amp; (c &lt;= 0x2FEF)) ||
 3223             ((c &gt;= 0x3001) &amp;&amp; (c &lt;= 0xD7FF)) ||
 3224             ((c &gt;= 0xF900) &amp;&amp; (c &lt;= 0xFDCF)) ||
 3225             ((c &gt;= 0xFDF0) &amp;&amp; (c &lt;= 0xFFFD)) ||
 3226             ((c &gt;= 0x10000) &amp;&amp; (c &lt;= 0xEFFFF))
 3227         )) {
 3228         if (count++ &gt; XML_PARSER_CHUNK_SIZE) {
 3229         count = 0;
 3230         GROW;
 3231                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 3232                     return(NULL);
 3233         }
 3234         len += l;
 3235         NEXTL(l);
 3236         c = CUR_CHAR(l);
 3237     }
 3238     } else {
 3239     if ((c == &#39; &#39;) || (c == &#39;&gt;&#39;) || (c == &#39;/&#39;) || /* accelerators */
 3240         (!IS_LETTER(c) &amp;&amp; (c != &#39;_&#39;) &amp;&amp;
 3241          (c != &#39;:&#39;))) {
 3242         return(NULL);
 3243     }
 3244     len += l;
 3245     NEXTL(l);
 3246     c = CUR_CHAR(l);
 3247 
 3248     while ((c != &#39; &#39;) &amp;&amp; (c != &#39;&gt;&#39;) &amp;&amp; (c != &#39;/&#39;) &amp;&amp; /* test bigname.xml */
 3249            ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
 3250         (c == &#39;.&#39;) || (c == &#39;-&#39;) ||
 3251         (c == &#39;_&#39;) || (c == &#39;:&#39;) ||
 3252         (IS_COMBINING(c)) ||
 3253         (IS_EXTENDER(c)))) {
 3254         if (count++ &gt; XML_PARSER_CHUNK_SIZE) {
 3255         count = 0;
 3256         GROW;
 3257                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 3258                     return(NULL);
 3259         }
 3260         len += l;
 3261         NEXTL(l);
 3262         c = CUR_CHAR(l);
 3263     }
 3264     }
 3265     if ((len &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3266         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3267         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;Name&quot;);
 3268         return(NULL);
 3269     }
 3270     if (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base &lt; len) {
 3271         /*
 3272          * There were a couple of bugs where PERefs lead to to a change
 3273          * of the buffer. Check the buffer size to avoid passing an invalid
 3274          * pointer to xmlDictLookup.
 3275          */
 3276         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 3277                     &quot;unexpected change of input buffer&quot;);
 3278         return (NULL);
 3279     }
 3280     if ((*ctxt-&gt;input-&gt;cur == &#39;\n&#39;) &amp;&amp; (ctxt-&gt;input-&gt;cur[-1] == &#39;\r&#39;))
 3281         return(xmlDictLookup(ctxt-&gt;dict, ctxt-&gt;input-&gt;cur - (len + 1), len));
 3282     return(xmlDictLookup(ctxt-&gt;dict, ctxt-&gt;input-&gt;cur - len, len));
 3283 }
 3284 
 3285 /**
 3286  * xmlParseName:
 3287  * @ctxt:  an XML parser context
 3288  *
 3289  * parse an XML name.
 3290  *
 3291  * [4] NameChar ::= Letter | Digit | &#39;.&#39; | &#39;-&#39; | &#39;_&#39; | &#39;:&#39; |
 3292  *                  CombiningChar | Extender
 3293  *
 3294  * [5] Name ::= (Letter | &#39;_&#39; | &#39;:&#39;) (NameChar)*
 3295  *
 3296  * [6] Names ::= Name (#x20 Name)*
 3297  *
 3298  * Returns the Name parsed or NULL
 3299  */
 3300 
 3301 const xmlChar *
 3302 xmlParseName(xmlParserCtxtPtr ctxt) {
 3303     const xmlChar *in;
 3304     const xmlChar *ret;
 3305     int count = 0;
 3306 
 3307     GROW;
 3308 
 3309 #ifdef DEBUG
 3310     nbParseName++;
 3311 #endif
 3312 
 3313     /*
 3314      * Accelerator for simple ASCII names
 3315      */
 3316     in = ctxt-&gt;input-&gt;cur;
 3317     if (((*in &gt;= 0x61) &amp;&amp; (*in &lt;= 0x7A)) ||
 3318     ((*in &gt;= 0x41) &amp;&amp; (*in &lt;= 0x5A)) ||
 3319     (*in == &#39;_&#39;) || (*in == &#39;:&#39;)) {
 3320     in++;
 3321     while (((*in &gt;= 0x61) &amp;&amp; (*in &lt;= 0x7A)) ||
 3322            ((*in &gt;= 0x41) &amp;&amp; (*in &lt;= 0x5A)) ||
 3323            ((*in &gt;= 0x30) &amp;&amp; (*in &lt;= 0x39)) ||
 3324            (*in == &#39;_&#39;) || (*in == &#39;-&#39;) ||
 3325            (*in == &#39;:&#39;) || (*in == &#39;.&#39;))
 3326         in++;
 3327     if ((*in &gt; 0) &amp;&amp; (*in &lt; 0x80)) {
 3328         count = in - ctxt-&gt;input-&gt;cur;
 3329             if ((count &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3330                 ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3331                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;Name&quot;);
 3332                 return(NULL);
 3333             }
 3334         ret = xmlDictLookup(ctxt-&gt;dict, ctxt-&gt;input-&gt;cur, count);
 3335         ctxt-&gt;input-&gt;cur = in;
 3336         ctxt-&gt;nbChars += count;
 3337         ctxt-&gt;input-&gt;col += count;
 3338         if (ret == NULL)
 3339             xmlErrMemory(ctxt, NULL);
 3340         return(ret);
 3341     }
 3342     }
 3343     /* accelerator for special cases */
 3344     return(xmlParseNameComplex(ctxt));
 3345 }
 3346 
 3347 static const xmlChar *
 3348 xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) {
 3349     int len = 0, l;
 3350     int c;
 3351     int count = 0;
 3352     size_t startPosition = 0;
 3353 
 3354 #ifdef DEBUG
 3355     nbParseNCNameComplex++;
 3356 #endif
 3357 
 3358     /*
 3359      * Handler for more complex cases
 3360      */
 3361     GROW;
 3362     startPosition = CUR_PTR - BASE_PTR;
 3363     c = CUR_CHAR(l);
 3364     if ((c == &#39; &#39;) || (c == &#39;&gt;&#39;) || (c == &#39;/&#39;) || /* accelerators */
 3365     (!xmlIsNameStartChar(ctxt, c) || (c == &#39;:&#39;))) {
 3366     return(NULL);
 3367     }
 3368 
 3369     while ((c != &#39; &#39;) &amp;&amp; (c != &#39;&gt;&#39;) &amp;&amp; (c != &#39;/&#39;) &amp;&amp; /* test bigname.xml */
 3370        (xmlIsNameChar(ctxt, c) &amp;&amp; (c != &#39;:&#39;))) {
 3371     if (count++ &gt; XML_PARSER_CHUNK_SIZE) {
 3372             if ((len &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3373                 ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3374                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;NCName&quot;);
 3375                 return(NULL);
 3376             }
 3377         count = 0;
 3378         GROW;
 3379             if (ctxt-&gt;instate == XML_PARSER_EOF)
 3380                 return(NULL);
 3381     }
 3382     len += l;
 3383     NEXTL(l);
 3384     c = CUR_CHAR(l);
 3385     if (c == 0) {
 3386         count = 0;
 3387         /*
 3388          * when shrinking to extend the buffer we really need to preserve
 3389          * the part of the name we already parsed. Hence rolling back
 3390          * by current length.
 3391          */
 3392         ctxt-&gt;input-&gt;cur -= l;
 3393         GROW;
 3394             if (ctxt-&gt;instate == XML_PARSER_EOF)
 3395                 return(NULL);
 3396         ctxt-&gt;input-&gt;cur += l;
 3397         c = CUR_CHAR(l);
 3398     }
 3399     }
 3400     if ((len &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3401         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3402         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;NCName&quot;);
 3403         return(NULL);
 3404     }
 3405     return(xmlDictLookup(ctxt-&gt;dict, (BASE_PTR + startPosition), len));
 3406 }
 3407 
 3408 /**
 3409  * xmlParseNCName:
 3410  * @ctxt:  an XML parser context
 3411  * @len:  length of the string parsed
 3412  *
 3413  * parse an XML name.
 3414  *
 3415  * [4NS] NCNameChar ::= Letter | Digit | &#39;.&#39; | &#39;-&#39; | &#39;_&#39; |
 3416  *                      CombiningChar | Extender
 3417  *
 3418  * [5NS] NCName ::= (Letter | &#39;_&#39;) (NCNameChar)*
 3419  *
 3420  * Returns the Name parsed or NULL
 3421  */
 3422 
 3423 static const xmlChar *
 3424 xmlParseNCName(xmlParserCtxtPtr ctxt) {
 3425     const xmlChar *in, *e;
 3426     const xmlChar *ret;
 3427     int count = 0;
 3428 
 3429 #ifdef DEBUG
 3430     nbParseNCName++;
 3431 #endif
 3432 
 3433     /*
 3434      * Accelerator for simple ASCII names
 3435      */
 3436     in = ctxt-&gt;input-&gt;cur;
 3437     e = ctxt-&gt;input-&gt;end;
 3438     if ((((*in &gt;= 0x61) &amp;&amp; (*in &lt;= 0x7A)) ||
 3439      ((*in &gt;= 0x41) &amp;&amp; (*in &lt;= 0x5A)) ||
 3440      (*in == &#39;_&#39;)) &amp;&amp; (in &lt; e)) {
 3441     in++;
 3442     while ((((*in &gt;= 0x61) &amp;&amp; (*in &lt;= 0x7A)) ||
 3443             ((*in &gt;= 0x41) &amp;&amp; (*in &lt;= 0x5A)) ||
 3444             ((*in &gt;= 0x30) &amp;&amp; (*in &lt;= 0x39)) ||
 3445             (*in == &#39;_&#39;) || (*in == &#39;-&#39;) ||
 3446             (*in == &#39;.&#39;)) &amp;&amp; (in &lt; e))
 3447         in++;
 3448     if (in &gt;= e)
 3449         goto complex;
 3450     if ((*in &gt; 0) &amp;&amp; (*in &lt; 0x80)) {
 3451         count = in - ctxt-&gt;input-&gt;cur;
 3452             if ((count &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3453                 ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3454                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;NCName&quot;);
 3455                 return(NULL);
 3456             }
 3457         ret = xmlDictLookup(ctxt-&gt;dict, ctxt-&gt;input-&gt;cur, count);
 3458         ctxt-&gt;input-&gt;cur = in;
 3459         ctxt-&gt;nbChars += count;
 3460         ctxt-&gt;input-&gt;col += count;
 3461         if (ret == NULL) {
 3462             xmlErrMemory(ctxt, NULL);
 3463         }
 3464         return(ret);
 3465     }
 3466     }
 3467 complex:
 3468     return(xmlParseNCNameComplex(ctxt));
 3469 }
 3470 
 3471 /**
 3472  * xmlParseNameAndCompare:
 3473  * @ctxt:  an XML parser context
 3474  *
 3475  * parse an XML name and compares for match
 3476  * (specialized for endtag parsing)
 3477  *
 3478  * Returns NULL for an illegal name, (xmlChar*) 1 for success
 3479  * and the name for mismatch
 3480  */
 3481 
 3482 static const xmlChar *
 3483 xmlParseNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *other) {
 3484     register const xmlChar *cmp = other;
 3485     register const xmlChar *in;
 3486     const xmlChar *ret;
 3487 
 3488     GROW;
 3489     if (ctxt-&gt;instate == XML_PARSER_EOF)
 3490         return(NULL);
 3491 
 3492     in = ctxt-&gt;input-&gt;cur;
 3493     while (*in != 0 &amp;&amp; *in == *cmp) {
 3494     ++in;
 3495     ++cmp;
 3496     ctxt-&gt;input-&gt;col++;
 3497     }
 3498     if (*cmp == 0 &amp;&amp; (*in == &#39;&gt;&#39; || IS_BLANK_CH (*in))) {
 3499     /* success */
 3500     ctxt-&gt;input-&gt;cur = in;
 3501     return (const xmlChar*) 1;
 3502     }
 3503     /* failure (or end of input buffer), check with full function */
 3504     ret = xmlParseName (ctxt);
 3505     /* strings coming from the dictionary direct compare possible */
 3506     if (ret == other) {
 3507     return (const xmlChar*) 1;
 3508     }
 3509     return ret;
 3510 }
 3511 
 3512 /**
 3513  * xmlParseStringName:
 3514  * @ctxt:  an XML parser context
 3515  * @str:  a pointer to the string pointer (IN/OUT)
 3516  *
 3517  * parse an XML name.
 3518  *
 3519  * [4] NameChar ::= Letter | Digit | &#39;.&#39; | &#39;-&#39; | &#39;_&#39; | &#39;:&#39; |
 3520  *                  CombiningChar | Extender
 3521  *
 3522  * [5] Name ::= (Letter | &#39;_&#39; | &#39;:&#39;) (NameChar)*
 3523  *
 3524  * [6] Names ::= Name (#x20 Name)*
 3525  *
 3526  * Returns the Name parsed or NULL. The @str pointer
 3527  * is updated to the current location in the string.
 3528  */
 3529 
 3530 static xmlChar *
 3531 xmlParseStringName(xmlParserCtxtPtr ctxt, const xmlChar** str) {
 3532     xmlChar buf[XML_MAX_NAMELEN + 5];
 3533     const xmlChar *cur = *str;
 3534     int len = 0, l;
 3535     int c;
 3536 
 3537 #ifdef DEBUG
 3538     nbParseStringName++;
 3539 #endif
 3540 
 3541     c = CUR_SCHAR(cur, l);
 3542     if (!xmlIsNameStartChar(ctxt, c)) {
 3543     return(NULL);
 3544     }
 3545 
 3546     COPY_BUF(l,buf,len,c);
 3547     cur += l;
 3548     c = CUR_SCHAR(cur, l);
 3549     while (xmlIsNameChar(ctxt, c)) {
 3550     COPY_BUF(l,buf,len,c);
 3551     cur += l;
 3552     c = CUR_SCHAR(cur, l);
 3553     if (len &gt;= XML_MAX_NAMELEN) { /* test bigentname.xml */
 3554         /*
 3555          * Okay someone managed to make a huge name, so he&#39;s ready to pay
 3556          * for the processing speed.
 3557          */
 3558         xmlChar *buffer;
 3559         int max = len * 2;
 3560 
 3561         buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));
 3562         if (buffer == NULL) {
 3563             xmlErrMemory(ctxt, NULL);
 3564         return(NULL);
 3565         }
 3566         memcpy(buffer, buf, len);
 3567         while (xmlIsNameChar(ctxt, c)) {
 3568         if (len + 10 &gt; max) {
 3569             xmlChar *tmp;
 3570 
 3571                     if ((len &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3572                         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3573                         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;NCName&quot;);
 3574             xmlFree(buffer);
 3575                         return(NULL);
 3576                     }
 3577             max *= 2;
 3578             tmp = (xmlChar *) xmlRealloc(buffer,
 3579                                         max * sizeof(xmlChar));
 3580             if (tmp == NULL) {
 3581             xmlErrMemory(ctxt, NULL);
 3582             xmlFree(buffer);
 3583             return(NULL);
 3584             }
 3585             buffer = tmp;
 3586         }
 3587         COPY_BUF(l,buffer,len,c);
 3588         cur += l;
 3589         c = CUR_SCHAR(cur, l);
 3590         }
 3591         buffer[len] = 0;
 3592         *str = cur;
 3593         return(buffer);
 3594     }
 3595     }
 3596     if ((len &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3597         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3598         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;NCName&quot;);
 3599         return(NULL);
 3600     }
 3601     *str = cur;
 3602     return(xmlStrndup(buf, len));
 3603 }
 3604 
 3605 /**
 3606  * xmlParseNmtoken:
 3607  * @ctxt:  an XML parser context
 3608  *
 3609  * parse an XML Nmtoken.
 3610  *
 3611  * [7] Nmtoken ::= (NameChar)+
 3612  *
 3613  * [8] Nmtokens ::= Nmtoken (#x20 Nmtoken)*
 3614  *
 3615  * Returns the Nmtoken parsed or NULL
 3616  */
 3617 
 3618 xmlChar *
 3619 xmlParseNmtoken(xmlParserCtxtPtr ctxt) {
 3620     xmlChar buf[XML_MAX_NAMELEN + 5];
 3621     int len = 0, l;
 3622     int c;
 3623     int count = 0;
 3624 
 3625 #ifdef DEBUG
 3626     nbParseNmToken++;
 3627 #endif
 3628 
 3629     GROW;
 3630     if (ctxt-&gt;instate == XML_PARSER_EOF)
 3631         return(NULL);
 3632     c = CUR_CHAR(l);
 3633 
 3634     while (xmlIsNameChar(ctxt, c)) {
 3635     if (count++ &gt; XML_PARSER_CHUNK_SIZE) {
 3636         count = 0;
 3637         GROW;
 3638     }
 3639     COPY_BUF(l,buf,len,c);
 3640     NEXTL(l);
 3641     c = CUR_CHAR(l);
 3642     if (c == 0) {
 3643         count = 0;
 3644         GROW;
 3645         if (ctxt-&gt;instate == XML_PARSER_EOF)
 3646         return(NULL);
 3647             c = CUR_CHAR(l);
 3648     }
 3649     if (len &gt;= XML_MAX_NAMELEN) {
 3650         /*
 3651          * Okay someone managed to make a huge token, so he&#39;s ready to pay
 3652          * for the processing speed.
 3653          */
 3654         xmlChar *buffer;
 3655         int max = len * 2;
 3656 
 3657         buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));
 3658         if (buffer == NULL) {
 3659             xmlErrMemory(ctxt, NULL);
 3660         return(NULL);
 3661         }
 3662         memcpy(buffer, buf, len);
 3663         while (xmlIsNameChar(ctxt, c)) {
 3664         if (count++ &gt; XML_PARSER_CHUNK_SIZE) {
 3665             count = 0;
 3666             GROW;
 3667                     if (ctxt-&gt;instate == XML_PARSER_EOF) {
 3668                         xmlFree(buffer);
 3669                         return(NULL);
 3670                     }
 3671         }
 3672         if (len + 10 &gt; max) {
 3673             xmlChar *tmp;
 3674 
 3675                     if ((max &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3676                         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3677                         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;NmToken&quot;);
 3678                         xmlFree(buffer);
 3679                         return(NULL);
 3680                     }
 3681             max *= 2;
 3682             tmp = (xmlChar *) xmlRealloc(buffer,
 3683                                         max * sizeof(xmlChar));
 3684             if (tmp == NULL) {
 3685             xmlErrMemory(ctxt, NULL);
 3686             xmlFree(buffer);
 3687             return(NULL);
 3688             }
 3689             buffer = tmp;
 3690         }
 3691         COPY_BUF(l,buffer,len,c);
 3692         NEXTL(l);
 3693         c = CUR_CHAR(l);
 3694         }
 3695         buffer[len] = 0;
 3696         return(buffer);
 3697     }
 3698     }
 3699     if (len == 0)
 3700         return(NULL);
 3701     if ((len &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3702         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3703         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;NmToken&quot;);
 3704         return(NULL);
 3705     }
 3706     return(xmlStrndup(buf, len));
 3707 }
 3708 
 3709 /**
 3710  * xmlParseEntityValue:
 3711  * @ctxt:  an XML parser context
 3712  * @orig:  if non-NULL store a copy of the original entity value
 3713  *
 3714  * parse a value for ENTITY declarations
 3715  *
 3716  * [9] EntityValue ::= &#39;&quot;&#39; ([^%&amp;&quot;] | PEReference | Reference)* &#39;&quot;&#39; |
 3717  *                 &quot;&#39;&quot; ([^%&amp;&#39;] | PEReference | Reference)* &quot;&#39;&quot;
 3718  *
 3719  * Returns the EntityValue parsed with reference substituted or NULL
 3720  */
 3721 
 3722 xmlChar *
 3723 xmlParseEntityValue(xmlParserCtxtPtr ctxt, xmlChar **orig) {
 3724     xmlChar *buf = NULL;
 3725     int len = 0;
 3726     int size = XML_PARSER_BUFFER_SIZE;
 3727     int c, l;
 3728     xmlChar stop;
 3729     xmlChar *ret = NULL;
 3730     const xmlChar *cur = NULL;
 3731     xmlParserInputPtr input;
 3732 
 3733     if (RAW == &#39;&quot;&#39;) stop = &#39;&quot;&#39;;
 3734     else if (RAW == &#39;\&#39;&#39;) stop = &#39;\&#39;&#39;;
 3735     else {
 3736     xmlFatalErr(ctxt, XML_ERR_ENTITY_NOT_STARTED, NULL);
 3737     return(NULL);
 3738     }
 3739     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));
 3740     if (buf == NULL) {
 3741     xmlErrMemory(ctxt, NULL);
 3742     return(NULL);
 3743     }
 3744 
 3745     /*
 3746      * The content of the entity definition is copied in a buffer.
 3747      */
 3748 
 3749     ctxt-&gt;instate = XML_PARSER_ENTITY_VALUE;
 3750     input = ctxt-&gt;input;
 3751     GROW;
 3752     if (ctxt-&gt;instate == XML_PARSER_EOF)
 3753         goto error;
 3754     NEXT;
 3755     c = CUR_CHAR(l);
 3756     /*
 3757      * NOTE: 4.4.5 Included in Literal
 3758      * When a parameter entity reference appears in a literal entity
 3759      * value, ... a single or double quote character in the replacement
 3760      * text is always treated as a normal data character and will not
 3761      * terminate the literal.
 3762      * In practice it means we stop the loop only when back at parsing
 3763      * the initial entity and the quote is found
 3764      */
 3765     while (((IS_CHAR(c)) &amp;&amp; ((c != stop) || /* checked */
 3766         (ctxt-&gt;input != input))) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF)) {
 3767     if (len + 5 &gt;= size) {
 3768         xmlChar *tmp;
 3769 
 3770         size *= 2;
 3771         tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));
 3772         if (tmp == NULL) {
 3773         xmlErrMemory(ctxt, NULL);
 3774                 goto error;
 3775         }
 3776         buf = tmp;
 3777     }
 3778     COPY_BUF(l,buf,len,c);
 3779     NEXTL(l);
 3780 
 3781     GROW;
 3782     c = CUR_CHAR(l);
 3783     if (c == 0) {
 3784         GROW;
 3785         c = CUR_CHAR(l);
 3786     }
 3787     }
 3788     buf[len] = 0;
 3789     if (ctxt-&gt;instate == XML_PARSER_EOF)
 3790         goto error;
 3791     if (c != stop) {
 3792         xmlFatalErr(ctxt, XML_ERR_ENTITY_NOT_FINISHED, NULL);
 3793         goto error;
 3794     }
 3795     NEXT;
 3796 
 3797     /*
 3798      * Raise problem w.r.t. &#39;&amp;&#39; and &#39;%&#39; being used in non-entities
 3799      * reference constructs. Note Charref will be handled in
 3800      * xmlStringDecodeEntities()
 3801      */
 3802     cur = buf;
 3803     while (*cur != 0) { /* non input consuming */
 3804     if ((*cur == &#39;%&#39;) || ((*cur == &#39;&amp;&#39;) &amp;&amp; (cur[1] != &#39;#&#39;))) {
 3805         xmlChar *name;
 3806         xmlChar tmp = *cur;
 3807             int nameOk = 0;
 3808 
 3809         cur++;
 3810         name = xmlParseStringName(ctxt, &amp;cur);
 3811             if (name != NULL) {
 3812                 nameOk = 1;
 3813                 xmlFree(name);
 3814             }
 3815             if ((nameOk == 0) || (*cur != &#39;;&#39;)) {
 3816         xmlFatalErrMsgInt(ctxt, XML_ERR_ENTITY_CHAR_ERROR,
 3817         &quot;EntityValue: &#39;%c&#39; forbidden except for entities references\n&quot;,
 3818                               tmp);
 3819                 goto error;
 3820         }
 3821         if ((tmp == &#39;%&#39;) &amp;&amp; (ctxt-&gt;inSubset == 1) &amp;&amp;
 3822         (ctxt-&gt;inputNr == 1)) {
 3823         xmlFatalErr(ctxt, XML_ERR_ENTITY_PE_INTERNAL, NULL);
 3824                 goto error;
 3825         }
 3826         if (*cur == 0)
 3827             break;
 3828     }
 3829     cur++;
 3830     }
 3831 
 3832     /*
 3833      * Then PEReference entities are substituted.
 3834      *
 3835      * NOTE: 4.4.7 Bypassed
 3836      * When a general entity reference appears in the EntityValue in
 3837      * an entity declaration, it is bypassed and left as is.
 3838      * so XML_SUBSTITUTE_REF is not set here.
 3839      */
 3840     ++ctxt-&gt;depth;
 3841     ret = xmlStringDecodeEntities(ctxt, buf, XML_SUBSTITUTE_PEREF,
 3842                                   0, 0, 0);
 3843     --ctxt-&gt;depth;
 3844     if (orig != NULL) {
 3845         *orig = buf;
 3846         buf = NULL;
 3847     }
 3848 
 3849 error:
 3850     if (buf != NULL)
 3851         xmlFree(buf);
 3852     return(ret);
 3853 }
 3854 
 3855 /**
 3856  * xmlParseAttValueComplex:
 3857  * @ctxt:  an XML parser context
 3858  * @len:   the resulting attribute len
 3859  * @normalize:  whether to apply the inner normalization
 3860  *
 3861  * parse a value for an attribute, this is the fallback function
 3862  * of xmlParseAttValue() when the attribute parsing requires handling
 3863  * of non-ASCII characters, or normalization compaction.
 3864  *
 3865  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.
 3866  */
 3867 static xmlChar *
 3868 xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
 3869     xmlChar limit = 0;
 3870     xmlChar *buf = NULL;
 3871     xmlChar *rep = NULL;
 3872     size_t len = 0;
 3873     size_t buf_size = 0;
 3874     int c, l, in_space = 0;
 3875     xmlChar *current = NULL;
 3876     xmlEntityPtr ent;
 3877 
 3878     if (NXT(0) == &#39;&quot;&#39;) {
 3879     ctxt-&gt;instate = XML_PARSER_ATTRIBUTE_VALUE;
 3880     limit = &#39;&quot;&#39;;
 3881         NEXT;
 3882     } else if (NXT(0) == &#39;\&#39;&#39;) {
 3883     limit = &#39;\&#39;&#39;;
 3884     ctxt-&gt;instate = XML_PARSER_ATTRIBUTE_VALUE;
 3885         NEXT;
 3886     } else {
 3887     xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
 3888     return(NULL);
 3889     }
 3890 
 3891     /*
 3892      * allocate a translation buffer.
 3893      */
 3894     buf_size = XML_PARSER_BUFFER_SIZE;
 3895     buf = (xmlChar *) xmlMallocAtomic(buf_size);
 3896     if (buf == NULL) goto mem_error;
 3897 
 3898     /*
 3899      * OK loop until we reach one of the ending char or a size limit.
 3900      */
 3901     c = CUR_CHAR(l);
 3902     while (((NXT(0) != limit) &amp;&amp; /* checked */
 3903             (IS_CHAR(c)) &amp;&amp; (c != &#39;&lt;&#39;)) &amp;&amp;
 3904             (ctxt-&gt;instate != XML_PARSER_EOF)) {
 3905         /*
 3906          * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE
 3907          * special option is given
 3908          */
 3909         if ((len &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 3910             ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3911             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 3912                            &quot;AttValue length too long\n&quot;);
 3913             goto mem_error;
 3914         }
 3915     if (c == 0) break;
 3916     if (c == &#39;&amp;&#39;) {
 3917         in_space = 0;
 3918         if (NXT(1) == &#39;#&#39;) {
 3919         int val = xmlParseCharRef(ctxt);
 3920 
 3921         if (val == &#39;&amp;&#39;) {
 3922             if (ctxt-&gt;replaceEntities) {
 3923             if (len + 10 &gt; buf_size) {
 3924                 growBuffer(buf, 10);
 3925             }
 3926             buf[len++] = &#39;&amp;&#39;;
 3927             } else {
 3928             /*
 3929              * The reparsing will be done in xmlStringGetNodeList()
 3930              * called by the attribute() function in SAX.c
 3931              */
 3932             if (len + 10 &gt; buf_size) {
 3933                 growBuffer(buf, 10);
 3934             }
 3935             buf[len++] = &#39;&amp;&#39;;
 3936             buf[len++] = &#39;#&#39;;
 3937             buf[len++] = &#39;3&#39;;
 3938             buf[len++] = &#39;8&#39;;
 3939             buf[len++] = &#39;;&#39;;
 3940             }
 3941         } else if (val != 0) {
 3942             if (len + 10 &gt; buf_size) {
 3943             growBuffer(buf, 10);
 3944             }
 3945             len += xmlCopyChar(0, &amp;buf[len], val);
 3946         }
 3947         } else {
 3948         ent = xmlParseEntityRef(ctxt);
 3949         ctxt-&gt;nbentities++;
 3950         if (ent != NULL)
 3951             ctxt-&gt;nbentities += ent-&gt;owner;
 3952         if ((ent != NULL) &amp;&amp;
 3953             (ent-&gt;etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
 3954             if (len + 10 &gt; buf_size) {
 3955             growBuffer(buf, 10);
 3956             }
 3957             if ((ctxt-&gt;replaceEntities == 0) &amp;&amp;
 3958                 (ent-&gt;content[0] == &#39;&amp;&#39;)) {
 3959             buf[len++] = &#39;&amp;&#39;;
 3960             buf[len++] = &#39;#&#39;;
 3961             buf[len++] = &#39;3&#39;;
 3962             buf[len++] = &#39;8&#39;;
 3963             buf[len++] = &#39;;&#39;;
 3964             } else {
 3965             buf[len++] = ent-&gt;content[0];
 3966             }
 3967         } else if ((ent != NULL) &amp;&amp;
 3968                    (ctxt-&gt;replaceEntities != 0)) {
 3969             if (ent-&gt;etype != XML_INTERNAL_PREDEFINED_ENTITY) {
 3970             ++ctxt-&gt;depth;
 3971             rep = xmlStringDecodeEntities(ctxt, ent-&gt;content,
 3972                               XML_SUBSTITUTE_REF,
 3973                               0, 0, 0);
 3974             --ctxt-&gt;depth;
 3975             if (rep != NULL) {
 3976                 current = rep;
 3977                 while (*current != 0) { /* non input consuming */
 3978                                 if ((*current == 0xD) || (*current == 0xA) ||
 3979                                     (*current == 0x9)) {
 3980                                     buf[len++] = 0x20;
 3981                                     current++;
 3982                                 } else
 3983                                     buf[len++] = *current++;
 3984                 if (len + 10 &gt; buf_size) {
 3985                     growBuffer(buf, 10);
 3986                 }
 3987                 }
 3988                 xmlFree(rep);
 3989                 rep = NULL;
 3990             }
 3991             } else {
 3992             if (len + 10 &gt; buf_size) {
 3993                 growBuffer(buf, 10);
 3994             }
 3995             if (ent-&gt;content != NULL)
 3996                 buf[len++] = ent-&gt;content[0];
 3997             }
 3998         } else if (ent != NULL) {
 3999             int i = xmlStrlen(ent-&gt;name);
 4000             const xmlChar *cur = ent-&gt;name;
 4001 
 4002             /*
 4003              * This may look absurd but is needed to detect
 4004              * entities problems
 4005              */
 4006             if ((ent-&gt;etype != XML_INTERNAL_PREDEFINED_ENTITY) &amp;&amp;
 4007             (ent-&gt;content != NULL) &amp;&amp; (ent-&gt;checked == 0)) {
 4008             unsigned long oldnbent = ctxt-&gt;nbentities, diff;
 4009 
 4010             ++ctxt-&gt;depth;
 4011             rep = xmlStringDecodeEntities(ctxt, ent-&gt;content,
 4012                           XML_SUBSTITUTE_REF, 0, 0, 0);
 4013             --ctxt-&gt;depth;
 4014 
 4015                         diff = ctxt-&gt;nbentities - oldnbent + 1;
 4016                         if (diff &gt; INT_MAX / 2)
 4017                             diff = INT_MAX / 2;
 4018                         ent-&gt;checked = diff * 2;
 4019             if (rep != NULL) {
 4020                 if (xmlStrchr(rep, &#39;&lt;&#39;))
 4021                     ent-&gt;checked |= 1;
 4022                 xmlFree(rep);
 4023                 rep = NULL;
 4024             } else {
 4025                             ent-&gt;content[0] = 0;
 4026                         }
 4027             }
 4028 
 4029             /*
 4030              * Just output the reference
 4031              */
 4032             buf[len++] = &#39;&amp;&#39;;
 4033             while (len + i + 10 &gt; buf_size) {
 4034             growBuffer(buf, i + 10);
 4035             }
 4036             for (;i &gt; 0;i--)
 4037             buf[len++] = *cur++;
 4038             buf[len++] = &#39;;&#39;;
 4039         }
 4040         }
 4041     } else {
 4042         if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {
 4043             if ((len != 0) || (!normalize)) {
 4044             if ((!normalize) || (!in_space)) {
 4045             COPY_BUF(l,buf,len,0x20);
 4046             while (len + 10 &gt; buf_size) {
 4047                 growBuffer(buf, 10);
 4048             }
 4049             }
 4050             in_space = 1;
 4051         }
 4052         } else {
 4053             in_space = 0;
 4054         COPY_BUF(l,buf,len,c);
 4055         if (len + 10 &gt; buf_size) {
 4056             growBuffer(buf, 10);
 4057         }
 4058         }
 4059         NEXTL(l);
 4060     }
 4061     GROW;
 4062     c = CUR_CHAR(l);
 4063     }
 4064     if (ctxt-&gt;instate == XML_PARSER_EOF)
 4065         goto error;
 4066 
 4067     if ((in_space) &amp;&amp; (normalize)) {
 4068         while ((len &gt; 0) &amp;&amp; (buf[len - 1] == 0x20)) len--;
 4069     }
 4070     buf[len] = 0;
 4071     if (RAW == &#39;&lt;&#39;) {
 4072     xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);
 4073     } else if (RAW != limit) {
 4074     if ((c != 0) &amp;&amp; (!IS_CHAR(c))) {
 4075         xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
 4076                &quot;invalid character in attribute value\n&quot;);
 4077     } else {
 4078         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 4079                &quot;AttValue: &#39; expected\n&quot;);
 4080         }
 4081     } else
 4082     NEXT;
 4083 
 4084     /*
 4085      * There we potentially risk an overflow, don&#39;t allow attribute value of
 4086      * length more than INT_MAX it is a very reasonable assumption !
 4087      */
 4088     if (len &gt;= INT_MAX) {
 4089         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 4090                        &quot;AttValue length too long\n&quot;);
 4091         goto mem_error;
 4092     }
 4093 
 4094     if (attlen != NULL) *attlen = (int) len;
 4095     return(buf);
 4096 
 4097 mem_error:
 4098     xmlErrMemory(ctxt, NULL);
 4099 error:
 4100     if (buf != NULL)
 4101         xmlFree(buf);
 4102     if (rep != NULL)
 4103         xmlFree(rep);
 4104     return(NULL);
 4105 }
 4106 
 4107 /**
 4108  * xmlParseAttValue:
 4109  * @ctxt:  an XML parser context
 4110  *
 4111  * parse a value for an attribute
 4112  * Note: the parser won&#39;t do substitution of entities here, this
 4113  * will be handled later in xmlStringGetNodeList
 4114  *
 4115  * [10] AttValue ::= &#39;&quot;&#39; ([^&lt;&amp;&quot;] | Reference)* &#39;&quot;&#39; |
 4116  *                   &quot;&#39;&quot; ([^&lt;&amp;&#39;] | Reference)* &quot;&#39;&quot;
 4117  *
 4118  * 3.3.3 Attribute-Value Normalization:
 4119  * Before the value of an attribute is passed to the application or
 4120  * checked for validity, the XML processor must normalize it as follows:
 4121  * - a character reference is processed by appending the referenced
 4122  *   character to the attribute value
 4123  * - an entity reference is processed by recursively processing the
 4124  *   replacement text of the entity
 4125  * - a whitespace character (#x20, #xD, #xA, #x9) is processed by
 4126  *   appending #x20 to the normalized value, except that only a single
 4127  *   #x20 is appended for a &quot;#xD#xA&quot; sequence that is part of an external
 4128  *   parsed entity or the literal entity value of an internal parsed entity
 4129  * - other characters are processed by appending them to the normalized value
 4130  * If the declared value is not CDATA, then the XML processor must further
 4131  * process the normalized attribute value by discarding any leading and
 4132  * trailing space (#x20) characters, and by replacing sequences of space
 4133  * (#x20) characters by a single space (#x20) character.
 4134  * All attributes for which no declaration has been read should be treated
 4135  * by a non-validating parser as if declared CDATA.
 4136  *
 4137  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.
 4138  */
 4139 
 4140 
 4141 xmlChar *
 4142 xmlParseAttValue(xmlParserCtxtPtr ctxt) {
 4143     if ((ctxt == NULL) || (ctxt-&gt;input == NULL)) return(NULL);
 4144     return(xmlParseAttValueInternal(ctxt, NULL, NULL, 0));
 4145 }
 4146 
 4147 /**
 4148  * xmlParseSystemLiteral:
 4149  * @ctxt:  an XML parser context
 4150  *
 4151  * parse an XML Literal
 4152  *
 4153  * [11] SystemLiteral ::= (&#39;&quot;&#39; [^&quot;]* &#39;&quot;&#39;) | (&quot;&#39;&quot; [^&#39;]* &quot;&#39;&quot;)
 4154  *
 4155  * Returns the SystemLiteral parsed or NULL
 4156  */
 4157 
 4158 xmlChar *
 4159 xmlParseSystemLiteral(xmlParserCtxtPtr ctxt) {
 4160     xmlChar *buf = NULL;
 4161     int len = 0;
 4162     int size = XML_PARSER_BUFFER_SIZE;
 4163     int cur, l;
 4164     xmlChar stop;
 4165     int state = ctxt-&gt;instate;
 4166     int count = 0;
 4167 
 4168     SHRINK;
 4169     if (RAW == &#39;&quot;&#39;) {
 4170         NEXT;
 4171     stop = &#39;&quot;&#39;;
 4172     } else if (RAW == &#39;\&#39;&#39;) {
 4173         NEXT;
 4174     stop = &#39;\&#39;&#39;;
 4175     } else {
 4176     xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);
 4177     return(NULL);
 4178     }
 4179 
 4180     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));
 4181     if (buf == NULL) {
 4182         xmlErrMemory(ctxt, NULL);
 4183     return(NULL);
 4184     }
 4185     ctxt-&gt;instate = XML_PARSER_SYSTEM_LITERAL;
 4186     cur = CUR_CHAR(l);
 4187     while ((IS_CHAR(cur)) &amp;&amp; (cur != stop)) { /* checked */
 4188     if (len + 5 &gt;= size) {
 4189         xmlChar *tmp;
 4190 
 4191             if ((size &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 4192                 ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 4193                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;SystemLiteral&quot;);
 4194                 xmlFree(buf);
 4195         ctxt-&gt;instate = (xmlParserInputState) state;
 4196                 return(NULL);
 4197             }
 4198         size *= 2;
 4199         tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));
 4200         if (tmp == NULL) {
 4201             xmlFree(buf);
 4202         xmlErrMemory(ctxt, NULL);
 4203         ctxt-&gt;instate = (xmlParserInputState) state;
 4204         return(NULL);
 4205         }
 4206         buf = tmp;
 4207     }
 4208     count++;
 4209     if (count &gt; 50) {
 4210         GROW;
 4211         count = 0;
 4212             if (ctxt-&gt;instate == XML_PARSER_EOF) {
 4213             xmlFree(buf);
 4214         return(NULL);
 4215             }
 4216     }
 4217     COPY_BUF(l,buf,len,cur);
 4218     NEXTL(l);
 4219     cur = CUR_CHAR(l);
 4220     if (cur == 0) {
 4221         GROW;
 4222         SHRINK;
 4223         cur = CUR_CHAR(l);
 4224     }
 4225     }
 4226     buf[len] = 0;
 4227     ctxt-&gt;instate = (xmlParserInputState) state;
 4228     if (!IS_CHAR(cur)) {
 4229     xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED, NULL);
 4230     } else {
 4231     NEXT;
 4232     }
 4233     return(buf);
 4234 }
 4235 
 4236 /**
 4237  * xmlParsePubidLiteral:
 4238  * @ctxt:  an XML parser context
 4239  *
 4240  * parse an XML public literal
 4241  *
 4242  * [12] PubidLiteral ::= &#39;&quot;&#39; PubidChar* &#39;&quot;&#39; | &quot;&#39;&quot; (PubidChar - &quot;&#39;&quot;)* &quot;&#39;&quot;
 4243  *
 4244  * Returns the PubidLiteral parsed or NULL.
 4245  */
 4246 
 4247 xmlChar *
 4248 xmlParsePubidLiteral(xmlParserCtxtPtr ctxt) {
 4249     xmlChar *buf = NULL;
 4250     int len = 0;
 4251     int size = XML_PARSER_BUFFER_SIZE;
 4252     xmlChar cur;
 4253     xmlChar stop;
 4254     int count = 0;
 4255     xmlParserInputState oldstate = ctxt-&gt;instate;
 4256 
 4257     SHRINK;
 4258     if (RAW == &#39;&quot;&#39;) {
 4259         NEXT;
 4260     stop = &#39;&quot;&#39;;
 4261     } else if (RAW == &#39;\&#39;&#39;) {
 4262         NEXT;
 4263     stop = &#39;\&#39;&#39;;
 4264     } else {
 4265     xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);
 4266     return(NULL);
 4267     }
 4268     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));
 4269     if (buf == NULL) {
 4270     xmlErrMemory(ctxt, NULL);
 4271     return(NULL);
 4272     }
 4273     ctxt-&gt;instate = XML_PARSER_PUBLIC_LITERAL;
 4274     cur = CUR;
 4275     while ((IS_PUBIDCHAR_CH(cur)) &amp;&amp; (cur != stop)) { /* checked */
 4276     if (len + 1 &gt;= size) {
 4277         xmlChar *tmp;
 4278 
 4279             if ((size &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 4280                 ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 4281                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;Public ID&quot;);
 4282                 xmlFree(buf);
 4283                 return(NULL);
 4284             }
 4285         size *= 2;
 4286         tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));
 4287         if (tmp == NULL) {
 4288         xmlErrMemory(ctxt, NULL);
 4289         xmlFree(buf);
 4290         return(NULL);
 4291         }
 4292         buf = tmp;
 4293     }
 4294     buf[len++] = cur;
 4295     count++;
 4296     if (count &gt; 50) {
 4297         GROW;
 4298         count = 0;
 4299             if (ctxt-&gt;instate == XML_PARSER_EOF) {
 4300         xmlFree(buf);
 4301         return(NULL);
 4302             }
 4303     }
 4304     NEXT;
 4305     cur = CUR;
 4306     if (cur == 0) {
 4307         GROW;
 4308         SHRINK;
 4309         cur = CUR;
 4310     }
 4311     }
 4312     buf[len] = 0;
 4313     if (cur != stop) {
 4314     xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED, NULL);
 4315     } else {
 4316     NEXT;
 4317     }
 4318     ctxt-&gt;instate = oldstate;
 4319     return(buf);
 4320 }
 4321 
 4322 static void xmlParseCharDataComplex(xmlParserCtxtPtr ctxt, int cdata);
 4323 
 4324 /*
 4325  * used for the test in the inner loop of the char data testing
 4326  */
 4327 static const unsigned char test_char_data[256] = {
 4328     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4329     0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x9, CR/LF separated */
 4330     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4331     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4332     0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x00, 0x27, /* &amp; */
 4333     0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
 4334     0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
 4335     0x38, 0x39, 0x3A, 0x3B, 0x00, 0x3D, 0x3E, 0x3F, /* &lt; */
 4336     0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
 4337     0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
 4338     0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
 4339     0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x00, 0x5E, 0x5F, /* ] */
 4340     0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
 4341     0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
 4342     0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
 4343     0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
 4344     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* non-ascii */
 4345     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4346     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4347     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4348     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4349     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4350     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4351     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4352     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4353     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4354     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4355     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4356     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4357     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4358     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4359     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 4360 };
 4361 
 4362 /**
 4363  * xmlParseCharData:
 4364  * @ctxt:  an XML parser context
 4365  * @cdata:  int indicating whether we are within a CDATA section
 4366  *
 4367  * parse a CharData section.
 4368  * if we are within a CDATA section &#39;]]&gt;&#39; marks an end of section.
 4369  *
 4370  * The right angle bracket (&gt;) may be represented using the string &quot;&amp;gt;&quot;,
 4371  * and must, for compatibility, be escaped using &quot;&amp;gt;&quot; or a character
 4372  * reference when it appears in the string &quot;]]&gt;&quot; in content, when that
 4373  * string is not marking the end of a CDATA section.
 4374  *
 4375  * [14] CharData ::= [^&lt;&amp;]* - ([^&lt;&amp;]* &#39;]]&gt;&#39; [^&lt;&amp;]*)
 4376  */
 4377 
 4378 void
 4379 xmlParseCharData(xmlParserCtxtPtr ctxt, int cdata) {
 4380     const xmlChar *in;
 4381     int nbchar = 0;
 4382     int line = ctxt-&gt;input-&gt;line;
 4383     int col = ctxt-&gt;input-&gt;col;
 4384     int ccol;
 4385 
 4386     SHRINK;
 4387     GROW;
 4388     /*
 4389      * Accelerated common case where input don&#39;t need to be
 4390      * modified before passing it to the handler.
 4391      */
 4392     if (!cdata) {
 4393     in = ctxt-&gt;input-&gt;cur;
 4394     do {
 4395 get_more_space:
 4396         while (*in == 0x20) { in++; ctxt-&gt;input-&gt;col++; }
 4397         if (*in == 0xA) {
 4398         do {
 4399             ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;
 4400             in++;
 4401         } while (*in == 0xA);
 4402         goto get_more_space;
 4403         }
 4404         if (*in == &#39;&lt;&#39;) {
 4405         nbchar = in - ctxt-&gt;input-&gt;cur;
 4406         if (nbchar &gt; 0) {
 4407             const xmlChar *tmp = ctxt-&gt;input-&gt;cur;
 4408             ctxt-&gt;input-&gt;cur = in;
 4409 
 4410             if ((ctxt-&gt;sax != NULL) &amp;&amp;
 4411                 (ctxt-&gt;sax-&gt;ignorableWhitespace !=
 4412                  ctxt-&gt;sax-&gt;characters)) {
 4413             if (areBlanks(ctxt, tmp, nbchar, 1)) {
 4414                 if (ctxt-&gt;sax-&gt;ignorableWhitespace != NULL)
 4415                 ctxt-&gt;sax-&gt;ignorableWhitespace(ctxt-&gt;userData,
 4416                                tmp, nbchar);
 4417             } else {
 4418                 if (ctxt-&gt;sax-&gt;characters != NULL)
 4419                 ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData,
 4420                               tmp, nbchar);
 4421                 if (*ctxt-&gt;space == -1)
 4422                     *ctxt-&gt;space = -2;
 4423             }
 4424             } else if ((ctxt-&gt;sax != NULL) &amp;&amp;
 4425                        (ctxt-&gt;sax-&gt;characters != NULL)) {
 4426             ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData,
 4427                           tmp, nbchar);
 4428             }
 4429         }
 4430         return;
 4431         }
 4432 
 4433 get_more:
 4434             ccol = ctxt-&gt;input-&gt;col;
 4435         while (test_char_data[*in]) {
 4436         in++;
 4437         ccol++;
 4438         }
 4439         ctxt-&gt;input-&gt;col = ccol;
 4440         if (*in == 0xA) {
 4441         do {
 4442             ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;
 4443             in++;
 4444         } while (*in == 0xA);
 4445         goto get_more;
 4446         }
 4447         if (*in == &#39;]&#39;) {
 4448         if ((in[1] == &#39;]&#39;) &amp;&amp; (in[2] == &#39;&gt;&#39;)) {
 4449             xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);
 4450             ctxt-&gt;input-&gt;cur = in + 1;
 4451             return;
 4452         }
 4453         in++;
 4454         ctxt-&gt;input-&gt;col++;
 4455         goto get_more;
 4456         }
 4457         nbchar = in - ctxt-&gt;input-&gt;cur;
 4458         if (nbchar &gt; 0) {
 4459         if ((ctxt-&gt;sax != NULL) &amp;&amp;
 4460             (ctxt-&gt;sax-&gt;ignorableWhitespace !=
 4461              ctxt-&gt;sax-&gt;characters) &amp;&amp;
 4462             (IS_BLANK_CH(*ctxt-&gt;input-&gt;cur))) {
 4463             const xmlChar *tmp = ctxt-&gt;input-&gt;cur;
 4464             ctxt-&gt;input-&gt;cur = in;
 4465 
 4466             if (areBlanks(ctxt, tmp, nbchar, 0)) {
 4467                 if (ctxt-&gt;sax-&gt;ignorableWhitespace != NULL)
 4468                 ctxt-&gt;sax-&gt;ignorableWhitespace(ctxt-&gt;userData,
 4469                                tmp, nbchar);
 4470             } else {
 4471                 if (ctxt-&gt;sax-&gt;characters != NULL)
 4472                 ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData,
 4473                           tmp, nbchar);
 4474             if (*ctxt-&gt;space == -1)
 4475                 *ctxt-&gt;space = -2;
 4476             }
 4477                     line = ctxt-&gt;input-&gt;line;
 4478                     col = ctxt-&gt;input-&gt;col;
 4479         } else if (ctxt-&gt;sax != NULL) {
 4480             if (ctxt-&gt;sax-&gt;characters != NULL)
 4481             ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData,
 4482                           ctxt-&gt;input-&gt;cur, nbchar);
 4483                     line = ctxt-&gt;input-&gt;line;
 4484                     col = ctxt-&gt;input-&gt;col;
 4485         }
 4486                 /* something really bad happened in the SAX callback */
 4487                 if (ctxt-&gt;instate != XML_PARSER_CONTENT)
 4488                     return;
 4489         }
 4490         ctxt-&gt;input-&gt;cur = in;
 4491         if (*in == 0xD) {
 4492         in++;
 4493         if (*in == 0xA) {
 4494             ctxt-&gt;input-&gt;cur = in;
 4495             in++;
 4496             ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;
 4497             continue; /* while */
 4498         }
 4499         in--;
 4500         }
 4501         if (*in == &#39;&lt;&#39;) {
 4502         return;
 4503         }
 4504         if (*in == &#39;&amp;&#39;) {
 4505         return;
 4506         }
 4507         SHRINK;
 4508         GROW;
 4509             if (ctxt-&gt;instate == XML_PARSER_EOF)
 4510         return;
 4511         in = ctxt-&gt;input-&gt;cur;
 4512     } while (((*in &gt;= 0x20) &amp;&amp; (*in &lt;= 0x7F)) || (*in == 0x09));
 4513     nbchar = 0;
 4514     }
 4515     ctxt-&gt;input-&gt;line = line;
 4516     ctxt-&gt;input-&gt;col = col;
 4517     xmlParseCharDataComplex(ctxt, cdata);
 4518 }
 4519 
 4520 /**
 4521  * xmlParseCharDataComplex:
 4522  * @ctxt:  an XML parser context
 4523  * @cdata:  int indicating whether we are within a CDATA section
 4524  *
 4525  * parse a CharData section.this is the fallback function
 4526  * of xmlParseCharData() when the parsing requires handling
 4527  * of non-ASCII characters.
 4528  */
 4529 static void
 4530 xmlParseCharDataComplex(xmlParserCtxtPtr ctxt, int cdata) {
 4531     xmlChar buf[XML_PARSER_BIG_BUFFER_SIZE + 5];
 4532     int nbchar = 0;
 4533     int cur, l;
 4534     int count = 0;
 4535 
 4536     SHRINK;
 4537     GROW;
 4538     cur = CUR_CHAR(l);
 4539     while ((cur != &#39;&lt;&#39;) &amp;&amp; /* checked */
 4540            (cur != &#39;&amp;&#39;) &amp;&amp;
 4541        (IS_CHAR(cur))) /* test also done in xmlCurrentChar() */ {
 4542     if ((cur == &#39;]&#39;) &amp;&amp; (NXT(1) == &#39;]&#39;) &amp;&amp;
 4543         (NXT(2) == &#39;&gt;&#39;)) {
 4544         if (cdata) break;
 4545         else {
 4546         xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);
 4547         }
 4548     }
 4549     COPY_BUF(l,buf,nbchar,cur);
 4550     if (nbchar &gt;= XML_PARSER_BIG_BUFFER_SIZE) {
 4551         buf[nbchar] = 0;
 4552 
 4553         /*
 4554          * OK the segment is to be consumed as chars.
 4555          */
 4556         if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX)) {
 4557         if (areBlanks(ctxt, buf, nbchar, 0)) {
 4558             if (ctxt-&gt;sax-&gt;ignorableWhitespace != NULL)
 4559             ctxt-&gt;sax-&gt;ignorableWhitespace(ctxt-&gt;userData,
 4560                                            buf, nbchar);
 4561         } else {
 4562             if (ctxt-&gt;sax-&gt;characters != NULL)
 4563             ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, buf, nbchar);
 4564             if ((ctxt-&gt;sax-&gt;characters !=
 4565                  ctxt-&gt;sax-&gt;ignorableWhitespace) &amp;&amp;
 4566             (*ctxt-&gt;space == -1))
 4567             *ctxt-&gt;space = -2;
 4568         }
 4569         }
 4570         nbchar = 0;
 4571             /* something really bad happened in the SAX callback */
 4572             if (ctxt-&gt;instate != XML_PARSER_CONTENT)
 4573                 return;
 4574     }
 4575     count++;
 4576     if (count &gt; 50) {
 4577         GROW;
 4578         count = 0;
 4579             if (ctxt-&gt;instate == XML_PARSER_EOF)
 4580         return;
 4581     }
 4582     NEXTL(l);
 4583     cur = CUR_CHAR(l);
 4584     }
 4585     if (nbchar != 0) {
 4586         buf[nbchar] = 0;
 4587     /*
 4588      * OK the segment is to be consumed as chars.
 4589      */
 4590     if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX)) {
 4591         if (areBlanks(ctxt, buf, nbchar, 0)) {
 4592         if (ctxt-&gt;sax-&gt;ignorableWhitespace != NULL)
 4593             ctxt-&gt;sax-&gt;ignorableWhitespace(ctxt-&gt;userData, buf, nbchar);
 4594         } else {
 4595         if (ctxt-&gt;sax-&gt;characters != NULL)
 4596             ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, buf, nbchar);
 4597         if ((ctxt-&gt;sax-&gt;characters != ctxt-&gt;sax-&gt;ignorableWhitespace) &amp;&amp;
 4598             (*ctxt-&gt;space == -1))
 4599             *ctxt-&gt;space = -2;
 4600         }
 4601     }
 4602     }
 4603     if ((cur != 0) &amp;&amp; (!IS_CHAR(cur))) {
 4604     /* Generate the error and skip the offending character */
 4605         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4606                           &quot;PCDATA invalid Char value %d\n&quot;,
 4607                       cur);
 4608     NEXTL(l);
 4609     }
 4610 }
 4611 
 4612 /**
 4613  * xmlParseExternalID:
 4614  * @ctxt:  an XML parser context
 4615  * @publicID:  a xmlChar** receiving PubidLiteral
 4616  * @strict: indicate whether we should restrict parsing to only
 4617  *          production [75], see NOTE below
 4618  *
 4619  * Parse an External ID or a Public ID
 4620  *
 4621  * NOTE: Productions [75] and [83] interact badly since [75] can generate
 4622  *       &#39;PUBLIC&#39; S PubidLiteral S SystemLiteral
 4623  *
 4624  * [75] ExternalID ::= &#39;SYSTEM&#39; S SystemLiteral
 4625  *                   | &#39;PUBLIC&#39; S PubidLiteral S SystemLiteral
 4626  *
 4627  * [83] PublicID ::= &#39;PUBLIC&#39; S PubidLiteral
 4628  *
 4629  * Returns the function returns SystemLiteral and in the second
 4630  *                case publicID receives PubidLiteral, is strict is off
 4631  *                it is possible to return NULL and have publicID set.
 4632  */
 4633 
 4634 xmlChar *
 4635 xmlParseExternalID(xmlParserCtxtPtr ctxt, xmlChar **publicID, int strict) {
 4636     xmlChar *URI = NULL;
 4637 
 4638     SHRINK;
 4639 
 4640     *publicID = NULL;
 4641     if (CMP6(CUR_PTR, &#39;S&#39;, &#39;Y&#39;, &#39;S&#39;, &#39;T&#39;, &#39;E&#39;, &#39;M&#39;)) {
 4642         SKIP(6);
 4643     if (SKIP_BLANKS == 0) {
 4644         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 4645                        &quot;Space required after &#39;SYSTEM&#39;\n&quot;);
 4646     }
 4647     URI = xmlParseSystemLiteral(ctxt);
 4648     if (URI == NULL) {
 4649         xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);
 4650         }
 4651     } else if (CMP6(CUR_PTR, &#39;P&#39;, &#39;U&#39;, &#39;B&#39;, &#39;L&#39;, &#39;I&#39;, &#39;C&#39;)) {
 4652         SKIP(6);
 4653     if (SKIP_BLANKS == 0) {
 4654         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 4655             &quot;Space required after &#39;PUBLIC&#39;\n&quot;);
 4656     }
 4657     *publicID = xmlParsePubidLiteral(ctxt);
 4658     if (*publicID == NULL) {
 4659         xmlFatalErr(ctxt, XML_ERR_PUBID_REQUIRED, NULL);
 4660     }
 4661     if (strict) {
 4662         /*
 4663          * We don&#39;t handle [83] so &quot;S SystemLiteral&quot; is required.
 4664          */
 4665         if (SKIP_BLANKS == 0) {
 4666         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 4667             &quot;Space required after the Public Identifier\n&quot;);
 4668         }
 4669     } else {
 4670         /*
 4671          * We handle [83] so we return immediately, if
 4672          * &quot;S SystemLiteral&quot; is not detected. We skip blanks if no
 4673              * system literal was found, but this is harmless since we must
 4674              * be at the end of a NotationDecl.
 4675          */
 4676         if (SKIP_BLANKS == 0) return(NULL);
 4677         if ((CUR != &#39;\&#39;&#39;) &amp;&amp; (CUR != &#39;&quot;&#39;)) return(NULL);
 4678     }
 4679     URI = xmlParseSystemLiteral(ctxt);
 4680     if (URI == NULL) {
 4681         xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);
 4682         }
 4683     }
 4684     return(URI);
 4685 }
 4686 
 4687 /**
 4688  * xmlParseCommentComplex:
 4689  * @ctxt:  an XML parser context
 4690  * @buf:  the already parsed part of the buffer
 4691  * @len:  number of bytes in the buffer
 4692  * @size:  allocated size of the buffer
 4693  *
 4694  * Skip an XML (SGML) comment &lt;!-- .... --&gt;
 4695  *  The spec says that &quot;For compatibility, the string &quot;--&quot; (double-hyphen)
 4696  *  must not occur within comments. &quot;
 4697  * This is the slow routine in case the accelerator for ascii didn&#39;t work
 4698  *
 4699  * [15] Comment ::= &#39;&lt;!--&#39; ((Char - &#39;-&#39;) | (&#39;-&#39; (Char - &#39;-&#39;)))* &#39;--&gt;&#39;
 4700  */
 4701 static void
 4702 xmlParseCommentComplex(xmlParserCtxtPtr ctxt, xmlChar *buf,
 4703                        size_t len, size_t size) {
 4704     int q, ql;
 4705     int r, rl;
 4706     int cur, l;
 4707     size_t count = 0;
 4708     int inputid;
 4709 
 4710     inputid = ctxt-&gt;input-&gt;id;
 4711 
 4712     if (buf == NULL) {
 4713         len = 0;
 4714     size = XML_PARSER_BUFFER_SIZE;
 4715     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));
 4716     if (buf == NULL) {
 4717         xmlErrMemory(ctxt, NULL);
 4718         return;
 4719     }
 4720     }
 4721     GROW;   /* Assure there&#39;s enough input data */
 4722     q = CUR_CHAR(ql);
 4723     if (q == 0)
 4724         goto not_terminated;
 4725     if (!IS_CHAR(q)) {
 4726         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4727                           &quot;xmlParseComment: invalid xmlChar value %d\n&quot;,
 4728                       q);
 4729     xmlFree (buf);
 4730     return;
 4731     }
 4732     NEXTL(ql);
 4733     r = CUR_CHAR(rl);
 4734     if (r == 0)
 4735         goto not_terminated;
 4736     if (!IS_CHAR(r)) {
 4737         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4738                           &quot;xmlParseComment: invalid xmlChar value %d\n&quot;,
 4739                       q);
 4740     xmlFree (buf);
 4741     return;
 4742     }
 4743     NEXTL(rl);
 4744     cur = CUR_CHAR(l);
 4745     if (cur == 0)
 4746         goto not_terminated;
 4747     while (IS_CHAR(cur) &amp;&amp; /* checked */
 4748            ((cur != &#39;&gt;&#39;) ||
 4749         (r != &#39;-&#39;) || (q != &#39;-&#39;))) {
 4750     if ((r == &#39;-&#39;) &amp;&amp; (q == &#39;-&#39;)) {
 4751         xmlFatalErr(ctxt, XML_ERR_HYPHEN_IN_COMMENT, NULL);
 4752     }
 4753         if ((len &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 4754             ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 4755             xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 4756                          &quot;Comment too big found&quot;, NULL);
 4757             xmlFree (buf);
 4758             return;
 4759         }
 4760     if (len + 5 &gt;= size) {
 4761         xmlChar *new_buf;
 4762             size_t new_size;
 4763 
 4764         new_size = size * 2;
 4765         new_buf = (xmlChar *) xmlRealloc(buf, new_size);
 4766         if (new_buf == NULL) {
 4767         xmlFree (buf);
 4768         xmlErrMemory(ctxt, NULL);
 4769         return;
 4770         }
 4771         buf = new_buf;
 4772             size = new_size;
 4773     }
 4774     COPY_BUF(ql,buf,len,q);
 4775     q = r;
 4776     ql = rl;
 4777     r = cur;
 4778     rl = l;
 4779 
 4780     count++;
 4781     if (count &gt; 50) {
 4782         GROW;
 4783         count = 0;
 4784             if (ctxt-&gt;instate == XML_PARSER_EOF) {
 4785         xmlFree(buf);
 4786         return;
 4787             }
 4788     }
 4789     NEXTL(l);
 4790     cur = CUR_CHAR(l);
 4791     if (cur == 0) {
 4792         SHRINK;
 4793         GROW;
 4794         cur = CUR_CHAR(l);
 4795     }
 4796     }
 4797     buf[len] = 0;
 4798     if (cur == 0) {
 4799     xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 4800                          &quot;Comment not terminated \n&lt;!--%.50s\n&quot;, buf);
 4801     } else if (!IS_CHAR(cur)) {
 4802         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4803                           &quot;xmlParseComment: invalid xmlChar value %d\n&quot;,
 4804                       cur);
 4805     } else {
 4806     if (inputid != ctxt-&gt;input-&gt;id) {
 4807         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 4808                    &quot;Comment doesn&#39;t start and stop in the same&quot;
 4809                            &quot; entity\n&quot;);
 4810     }
 4811         NEXT;
 4812     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;comment != NULL) &amp;&amp;
 4813         (!ctxt-&gt;disableSAX))
 4814         ctxt-&gt;sax-&gt;comment(ctxt-&gt;userData, buf);
 4815     }
 4816     xmlFree(buf);
 4817     return;
 4818 not_terminated:
 4819     xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 4820              &quot;Comment not terminated\n&quot;, NULL);
 4821     xmlFree(buf);
 4822     return;
 4823 }
 4824 
 4825 /**
 4826  * xmlParseComment:
 4827  * @ctxt:  an XML parser context
 4828  *
 4829  * Skip an XML (SGML) comment &lt;!-- .... --&gt;
 4830  *  The spec says that &quot;For compatibility, the string &quot;--&quot; (double-hyphen)
 4831  *  must not occur within comments. &quot;
 4832  *
 4833  * [15] Comment ::= &#39;&lt;!--&#39; ((Char - &#39;-&#39;) | (&#39;-&#39; (Char - &#39;-&#39;)))* &#39;--&gt;&#39;
 4834  */
 4835 void
 4836 xmlParseComment(xmlParserCtxtPtr ctxt) {
 4837     xmlChar *buf = NULL;
 4838     size_t size = XML_PARSER_BUFFER_SIZE;
 4839     size_t len = 0;
 4840     xmlParserInputState state;
 4841     const xmlChar *in;
 4842     size_t nbchar = 0;
 4843     int ccol;
 4844     int inputid;
 4845 
 4846     /*
 4847      * Check that there is a comment right here.
 4848      */
 4849     if ((RAW != &#39;&lt;&#39;) || (NXT(1) != &#39;!&#39;) ||
 4850         (NXT(2) != &#39;-&#39;) || (NXT(3) != &#39;-&#39;)) return;
 4851     state = ctxt-&gt;instate;
 4852     ctxt-&gt;instate = XML_PARSER_COMMENT;
 4853     inputid = ctxt-&gt;input-&gt;id;
 4854     SKIP(4);
 4855     SHRINK;
 4856     GROW;
 4857 
 4858     /*
 4859      * Accelerated common case where input don&#39;t need to be
 4860      * modified before passing it to the handler.
 4861      */
 4862     in = ctxt-&gt;input-&gt;cur;
 4863     do {
 4864     if (*in == 0xA) {
 4865         do {
 4866         ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;
 4867         in++;
 4868         } while (*in == 0xA);
 4869     }
 4870 get_more:
 4871         ccol = ctxt-&gt;input-&gt;col;
 4872     while (((*in &gt; &#39;-&#39;) &amp;&amp; (*in &lt;= 0x7F)) ||
 4873            ((*in &gt;= 0x20) &amp;&amp; (*in &lt; &#39;-&#39;)) ||
 4874            (*in == 0x09)) {
 4875             in++;
 4876             ccol++;
 4877     }
 4878     ctxt-&gt;input-&gt;col = ccol;
 4879     if (*in == 0xA) {
 4880         do {
 4881         ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;
 4882         in++;
 4883         } while (*in == 0xA);
 4884         goto get_more;
 4885     }
 4886     nbchar = in - ctxt-&gt;input-&gt;cur;
 4887     /*
 4888      * save current set of data
 4889      */
 4890     if (nbchar &gt; 0) {
 4891         if ((ctxt-&gt;sax != NULL) &amp;&amp;
 4892         (ctxt-&gt;sax-&gt;comment != NULL)) {
 4893         if (buf == NULL) {
 4894             if ((*in == &#39;-&#39;) &amp;&amp; (in[1] == &#39;-&#39;))
 4895                 size = nbchar + 1;
 4896             else
 4897                 size = XML_PARSER_BUFFER_SIZE + nbchar;
 4898             buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));
 4899             if (buf == NULL) {
 4900                 xmlErrMemory(ctxt, NULL);
 4901             ctxt-&gt;instate = state;
 4902             return;
 4903             }
 4904             len = 0;
 4905         } else if (len + nbchar + 1 &gt;= size) {
 4906             xmlChar *new_buf;
 4907             size  += len + nbchar + XML_PARSER_BUFFER_SIZE;
 4908             new_buf = (xmlChar *) xmlRealloc(buf,
 4909                                              size * sizeof(xmlChar));
 4910             if (new_buf == NULL) {
 4911                 xmlFree (buf);
 4912             xmlErrMemory(ctxt, NULL);
 4913             ctxt-&gt;instate = state;
 4914             return;
 4915             }
 4916             buf = new_buf;
 4917         }
 4918         memcpy(&amp;buf[len], ctxt-&gt;input-&gt;cur, nbchar);
 4919         len += nbchar;
 4920         buf[len] = 0;
 4921         }
 4922     }
 4923         if ((len &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 4924             ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 4925             xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 4926                          &quot;Comment too big found&quot;, NULL);
 4927             xmlFree (buf);
 4928             return;
 4929         }
 4930     ctxt-&gt;input-&gt;cur = in;
 4931     if (*in == 0xA) {
 4932         in++;
 4933         ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;
 4934     }
 4935     if (*in == 0xD) {
 4936         in++;
 4937         if (*in == 0xA) {
 4938         ctxt-&gt;input-&gt;cur = in;
 4939         in++;
 4940         ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;
 4941         continue; /* while */
 4942         }
 4943         in--;
 4944     }
 4945     SHRINK;
 4946     GROW;
 4947         if (ctxt-&gt;instate == XML_PARSER_EOF) {
 4948             xmlFree(buf);
 4949             return;
 4950         }
 4951     in = ctxt-&gt;input-&gt;cur;
 4952     if (*in == &#39;-&#39;) {
 4953         if (in[1] == &#39;-&#39;) {
 4954             if (in[2] == &#39;&gt;&#39;) {
 4955             if (ctxt-&gt;input-&gt;id != inputid) {
 4956             xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 4957                            &quot;comment doesn&#39;t start and stop in the&quot;
 4958                                        &quot; same entity\n&quot;);
 4959             }
 4960             SKIP(3);
 4961             if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;comment != NULL) &amp;&amp;
 4962                 (!ctxt-&gt;disableSAX)) {
 4963             if (buf != NULL)
 4964                 ctxt-&gt;sax-&gt;comment(ctxt-&gt;userData, buf);
 4965             else
 4966                 ctxt-&gt;sax-&gt;comment(ctxt-&gt;userData, BAD_CAST &quot;&quot;);
 4967             }
 4968             if (buf != NULL)
 4969                 xmlFree(buf);
 4970             if (ctxt-&gt;instate != XML_PARSER_EOF)
 4971             ctxt-&gt;instate = state;
 4972             return;
 4973         }
 4974         if (buf != NULL) {
 4975             xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
 4976                               &quot;Double hyphen within comment: &quot;
 4977                                       &quot;&lt;!--%.50s\n&quot;,
 4978                       buf);
 4979         } else
 4980             xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
 4981                               &quot;Double hyphen within comment\n&quot;, NULL);
 4982                 if (ctxt-&gt;instate == XML_PARSER_EOF) {
 4983                     xmlFree(buf);
 4984                     return;
 4985                 }
 4986         in++;
 4987         ctxt-&gt;input-&gt;col++;
 4988         }
 4989         in++;
 4990         ctxt-&gt;input-&gt;col++;
 4991         goto get_more;
 4992     }
 4993     } while (((*in &gt;= 0x20) &amp;&amp; (*in &lt;= 0x7F)) || (*in == 0x09));
 4994     xmlParseCommentComplex(ctxt, buf, len, size);
 4995     ctxt-&gt;instate = state;
 4996     return;
 4997 }
 4998 
 4999 
 5000 /**
 5001  * xmlParsePITarget:
 5002  * @ctxt:  an XML parser context
 5003  *
 5004  * parse the name of a PI
 5005  *
 5006  * [17] PITarget ::= Name - ((&#39;X&#39; | &#39;x&#39;) (&#39;M&#39; | &#39;m&#39;) (&#39;L&#39; | &#39;l&#39;))
 5007  *
 5008  * Returns the PITarget name or NULL
 5009  */
 5010 
 5011 const xmlChar *
 5012 xmlParsePITarget(xmlParserCtxtPtr ctxt) {
 5013     const xmlChar *name;
 5014 
 5015     name = xmlParseName(ctxt);
 5016     if ((name != NULL) &amp;&amp;
 5017         ((name[0] == &#39;x&#39;) || (name[0] == &#39;X&#39;)) &amp;&amp;
 5018         ((name[1] == &#39;m&#39;) || (name[1] == &#39;M&#39;)) &amp;&amp;
 5019         ((name[2] == &#39;l&#39;) || (name[2] == &#39;L&#39;))) {
 5020     int i;
 5021     if ((name[0] == &#39;x&#39;) &amp;&amp; (name[1] == &#39;m&#39;) &amp;&amp;
 5022         (name[2] == &#39;l&#39;) &amp;&amp; (name[3] == 0)) {
 5023         xmlFatalErrMsg(ctxt, XML_ERR_RESERVED_XML_NAME,
 5024          &quot;XML declaration allowed only at the start of the document\n&quot;);
 5025         return(name);
 5026     } else if (name[3] == 0) {
 5027         xmlFatalErr(ctxt, XML_ERR_RESERVED_XML_NAME, NULL);
 5028         return(name);
 5029     }
 5030     for (i = 0;;i++) {
 5031         if (xmlW3CPIs[i] == NULL) break;
 5032         if (xmlStrEqual(name, (const xmlChar *)xmlW3CPIs[i]))
 5033             return(name);
 5034     }
 5035     xmlWarningMsg(ctxt, XML_ERR_RESERVED_XML_NAME,
 5036               &quot;xmlParsePITarget: invalid name prefix &#39;xml&#39;\n&quot;,
 5037               NULL, NULL);
 5038     }
 5039     if ((name != NULL) &amp;&amp; (xmlStrchr(name, &#39;:&#39;) != NULL)) {
 5040     xmlNsErr(ctxt, XML_NS_ERR_COLON,
 5041          &quot;colons are forbidden from PI names &#39;%s&#39;\n&quot;, name, NULL, NULL);
 5042     }
 5043     return(name);
 5044 }
 5045 
 5046 #ifdef LIBXML_CATALOG_ENABLED
 5047 /**
 5048  * xmlParseCatalogPI:
 5049  * @ctxt:  an XML parser context
 5050  * @catalog:  the PI value string
 5051  *
 5052  * parse an XML Catalog Processing Instruction.
 5053  *
 5054  * &lt;?oasis-xml-catalog catalog=&quot;http://example.com/catalog.xml&quot;?&gt;
 5055  *
 5056  * Occurs only if allowed by the user and if happening in the Misc
 5057  * part of the document before any doctype informations
 5058  * This will add the given catalog to the parsing context in order
 5059  * to be used if there is a resolution need further down in the document
 5060  */
 5061 
 5062 static void
 5063 xmlParseCatalogPI(xmlParserCtxtPtr ctxt, const xmlChar *catalog) {
 5064     xmlChar *URL = NULL;
 5065     const xmlChar *tmp, *base;
 5066     xmlChar marker;
 5067 
 5068     tmp = catalog;
 5069     while (IS_BLANK_CH(*tmp)) tmp++;
 5070     if (xmlStrncmp(tmp, BAD_CAST&quot;catalog&quot;, 7))
 5071     goto error;
 5072     tmp += 7;
 5073     while (IS_BLANK_CH(*tmp)) tmp++;
 5074     if (*tmp != &#39;=&#39;) {
 5075     return;
 5076     }
 5077     tmp++;
 5078     while (IS_BLANK_CH(*tmp)) tmp++;
 5079     marker = *tmp;
 5080     if ((marker != &#39;\&#39;&#39;) &amp;&amp; (marker != &#39;&quot;&#39;))
 5081     goto error;
 5082     tmp++;
 5083     base = tmp;
 5084     while ((*tmp != 0) &amp;&amp; (*tmp != marker)) tmp++;
 5085     if (*tmp == 0)
 5086     goto error;
 5087     URL = xmlStrndup(base, tmp - base);
 5088     tmp++;
 5089     while (IS_BLANK_CH(*tmp)) tmp++;
 5090     if (*tmp != 0)
 5091     goto error;
 5092 
 5093     if (URL != NULL) {
 5094     ctxt-&gt;catalogs = xmlCatalogAddLocal(ctxt-&gt;catalogs, URL);
 5095     xmlFree(URL);
 5096     }
 5097     return;
 5098 
 5099 error:
 5100     xmlWarningMsg(ctxt, XML_WAR_CATALOG_PI,
 5101               &quot;Catalog PI syntax error: %s\n&quot;,
 5102           catalog, NULL);
 5103     if (URL != NULL)
 5104     xmlFree(URL);
 5105 }
 5106 #endif
 5107 
 5108 /**
 5109  * xmlParsePI:
 5110  * @ctxt:  an XML parser context
 5111  *
 5112  * parse an XML Processing Instruction.
 5113  *
 5114  * [16] PI ::= &#39;&lt;?&#39; PITarget (S (Char* - (Char* &#39;?&gt;&#39; Char*)))? &#39;?&gt;&#39;
 5115  *
 5116  * The processing is transferred to SAX once parsed.
 5117  */
 5118 
 5119 void
 5120 xmlParsePI(xmlParserCtxtPtr ctxt) {
 5121     xmlChar *buf = NULL;
 5122     size_t len = 0;
 5123     size_t size = XML_PARSER_BUFFER_SIZE;
 5124     int cur, l;
 5125     const xmlChar *target;
 5126     xmlParserInputState state;
 5127     int count = 0;
 5128 
 5129     if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;?&#39;)) {
 5130     int inputid = ctxt-&gt;input-&gt;id;
 5131     state = ctxt-&gt;instate;
 5132         ctxt-&gt;instate = XML_PARSER_PI;
 5133     /*
 5134      * this is a Processing Instruction.
 5135      */
 5136     SKIP(2);
 5137     SHRINK;
 5138 
 5139     /*
 5140      * Parse the target name and check for special support like
 5141      * namespace.
 5142      */
 5143         target = xmlParsePITarget(ctxt);
 5144     if (target != NULL) {
 5145         if ((RAW == &#39;?&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;)) {
 5146         if (inputid != ctxt-&gt;input-&gt;id) {
 5147             xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5148                                &quot;PI declaration doesn&#39;t start and stop in&quot;
 5149                                    &quot; the same entity\n&quot;);
 5150         }
 5151         SKIP(2);
 5152 
 5153         /*
 5154          * SAX: PI detected.
 5155          */
 5156         if ((ctxt-&gt;sax) &amp;&amp; (!ctxt-&gt;disableSAX) &amp;&amp;
 5157             (ctxt-&gt;sax-&gt;processingInstruction != NULL))
 5158             ctxt-&gt;sax-&gt;processingInstruction(ctxt-&gt;userData,
 5159                                              target, NULL);
 5160         if (ctxt-&gt;instate != XML_PARSER_EOF)
 5161             ctxt-&gt;instate = state;
 5162         return;
 5163         }
 5164         buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));
 5165         if (buf == NULL) {
 5166         xmlErrMemory(ctxt, NULL);
 5167         ctxt-&gt;instate = state;
 5168         return;
 5169         }
 5170         if (SKIP_BLANKS == 0) {
 5171         xmlFatalErrMsgStr(ctxt, XML_ERR_SPACE_REQUIRED,
 5172               &quot;ParsePI: PI %s space expected\n&quot;, target);
 5173         }
 5174         cur = CUR_CHAR(l);
 5175         while (IS_CHAR(cur) &amp;&amp; /* checked */
 5176            ((cur != &#39;?&#39;) || (NXT(1) != &#39;&gt;&#39;))) {
 5177         if (len + 5 &gt;= size) {
 5178             xmlChar *tmp;
 5179                     size_t new_size = size * 2;
 5180             tmp = (xmlChar *) xmlRealloc(buf, new_size);
 5181             if (tmp == NULL) {
 5182             xmlErrMemory(ctxt, NULL);
 5183             xmlFree(buf);
 5184             ctxt-&gt;instate = state;
 5185             return;
 5186             }
 5187             buf = tmp;
 5188                     size = new_size;
 5189         }
 5190         count++;
 5191         if (count &gt; 50) {
 5192             GROW;
 5193                     if (ctxt-&gt;instate == XML_PARSER_EOF) {
 5194                         xmlFree(buf);
 5195                         return;
 5196                     }
 5197             count = 0;
 5198                     if ((len &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 5199                         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 5200                         xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,
 5201                                           &quot;PI %s too big found&quot;, target);
 5202                         xmlFree(buf);
 5203                         ctxt-&gt;instate = state;
 5204                         return;
 5205                     }
 5206         }
 5207         COPY_BUF(l,buf,len,cur);
 5208         NEXTL(l);
 5209         cur = CUR_CHAR(l);
 5210         if (cur == 0) {
 5211             SHRINK;
 5212             GROW;
 5213             cur = CUR_CHAR(l);
 5214         }
 5215         }
 5216             if ((len &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 5217                 ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 5218                 xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,
 5219                                   &quot;PI %s too big found&quot;, target);
 5220                 xmlFree(buf);
 5221                 ctxt-&gt;instate = state;
 5222                 return;
 5223             }
 5224         buf[len] = 0;
 5225         if (cur != &#39;?&#39;) {
 5226         xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,
 5227               &quot;ParsePI: PI %s never end ...\n&quot;, target);
 5228         } else {
 5229         if (inputid != ctxt-&gt;input-&gt;id) {
 5230             xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5231                                &quot;PI declaration doesn&#39;t start and stop in&quot;
 5232                                    &quot; the same entity\n&quot;);
 5233         }
 5234         SKIP(2);
 5235 
 5236 #ifdef LIBXML_CATALOG_ENABLED
 5237         if (((state == XML_PARSER_MISC) ||
 5238                  (state == XML_PARSER_START)) &amp;&amp;
 5239             (xmlStrEqual(target, XML_CATALOG_PI))) {
 5240             xmlCatalogAllow allow = xmlCatalogGetDefaults();
 5241             if ((allow == XML_CATA_ALLOW_DOCUMENT) ||
 5242             (allow == XML_CATA_ALLOW_ALL))
 5243             xmlParseCatalogPI(ctxt, buf);
 5244         }
 5245 #endif
 5246 
 5247 
 5248         /*
 5249          * SAX: PI detected.
 5250          */
 5251         if ((ctxt-&gt;sax) &amp;&amp; (!ctxt-&gt;disableSAX) &amp;&amp;
 5252             (ctxt-&gt;sax-&gt;processingInstruction != NULL))
 5253             ctxt-&gt;sax-&gt;processingInstruction(ctxt-&gt;userData,
 5254                                              target, buf);
 5255         }
 5256         xmlFree(buf);
 5257     } else {
 5258         xmlFatalErr(ctxt, XML_ERR_PI_NOT_STARTED, NULL);
 5259     }
 5260     if (ctxt-&gt;instate != XML_PARSER_EOF)
 5261         ctxt-&gt;instate = state;
 5262     }
 5263 }
 5264 
 5265 /**
 5266  * xmlParseNotationDecl:
 5267  * @ctxt:  an XML parser context
 5268  *
 5269  * parse a notation declaration
 5270  *
 5271  * [82] NotationDecl ::= &#39;&lt;!NOTATION&#39; S Name S (ExternalID |  PublicID) S? &#39;&gt;&#39;
 5272  *
 5273  * Hence there is actually 3 choices:
 5274  *     &#39;PUBLIC&#39; S PubidLiteral
 5275  *     &#39;PUBLIC&#39; S PubidLiteral S SystemLiteral
 5276  * and &#39;SYSTEM&#39; S SystemLiteral
 5277  *
 5278  * See the NOTE on xmlParseExternalID().
 5279  */
 5280 
 5281 void
 5282 xmlParseNotationDecl(xmlParserCtxtPtr ctxt) {
 5283     const xmlChar *name;
 5284     xmlChar *Pubid;
 5285     xmlChar *Systemid;
 5286 
 5287     if (CMP10(CUR_PTR, &#39;&lt;&#39;, &#39;!&#39;, &#39;N&#39;, &#39;O&#39;, &#39;T&#39;, &#39;A&#39;, &#39;T&#39;, &#39;I&#39;, &#39;O&#39;, &#39;N&#39;)) {
 5288     int inputid = ctxt-&gt;input-&gt;id;
 5289     SHRINK;
 5290     SKIP(10);
 5291     if (SKIP_BLANKS == 0) {
 5292         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5293                &quot;Space required after &#39;&lt;!NOTATION&#39;\n&quot;);
 5294         return;
 5295     }
 5296 
 5297         name = xmlParseName(ctxt);
 5298     if (name == NULL) {
 5299         xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_STARTED, NULL);
 5300         return;
 5301     }
 5302     if (xmlStrchr(name, &#39;:&#39;) != NULL) {
 5303         xmlNsErr(ctxt, XML_NS_ERR_COLON,
 5304              &quot;colons are forbidden from notation names &#39;%s&#39;\n&quot;,
 5305              name, NULL, NULL);
 5306     }
 5307     if (SKIP_BLANKS == 0) {
 5308         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5309              &quot;Space required after the NOTATION name&#39;\n&quot;);
 5310         return;
 5311     }
 5312 
 5313     /*
 5314      * Parse the IDs.
 5315      */
 5316     Systemid = xmlParseExternalID(ctxt, &amp;Pubid, 0);
 5317     SKIP_BLANKS;
 5318 
 5319     if (RAW == &#39;&gt;&#39;) {
 5320         if (inputid != ctxt-&gt;input-&gt;id) {
 5321         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5322                            &quot;Notation declaration doesn&#39;t start and stop&quot;
 5323                                &quot; in the same entity\n&quot;);
 5324         }
 5325         NEXT;
 5326         if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX) &amp;&amp;
 5327         (ctxt-&gt;sax-&gt;notationDecl != NULL))
 5328         ctxt-&gt;sax-&gt;notationDecl(ctxt-&gt;userData, name, Pubid, Systemid);
 5329     } else {
 5330         xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_FINISHED, NULL);
 5331     }
 5332     if (Systemid != NULL) xmlFree(Systemid);
 5333     if (Pubid != NULL) xmlFree(Pubid);
 5334     }
 5335 }
 5336 
 5337 /**
 5338  * xmlParseEntityDecl:
 5339  * @ctxt:  an XML parser context
 5340  *
 5341  * parse &lt;!ENTITY declarations
 5342  *
 5343  * [70] EntityDecl ::= GEDecl | PEDecl
 5344  *
 5345  * [71] GEDecl ::= &#39;&lt;!ENTITY&#39; S Name S EntityDef S? &#39;&gt;&#39;
 5346  *
 5347  * [72] PEDecl ::= &#39;&lt;!ENTITY&#39; S &#39;%&#39; S Name S PEDef S? &#39;&gt;&#39;
 5348  *
 5349  * [73] EntityDef ::= EntityValue | (ExternalID NDataDecl?)
 5350  *
 5351  * [74] PEDef ::= EntityValue | ExternalID
 5352  *
 5353  * [76] NDataDecl ::= S &#39;NDATA&#39; S Name
 5354  *
 5355  * [ VC: Notation Declared ]
 5356  * The Name must match the declared name of a notation.
 5357  */
 5358 
 5359 void
 5360 xmlParseEntityDecl(xmlParserCtxtPtr ctxt) {
 5361     const xmlChar *name = NULL;
 5362     xmlChar *value = NULL;
 5363     xmlChar *URI = NULL, *literal = NULL;
 5364     const xmlChar *ndata = NULL;
 5365     int isParameter = 0;
 5366     xmlChar *orig = NULL;
 5367 
 5368     /* GROW; done in the caller */
 5369     if (CMP8(CUR_PTR, &#39;&lt;&#39;, &#39;!&#39;, &#39;E&#39;, &#39;N&#39;, &#39;T&#39;, &#39;I&#39;, &#39;T&#39;, &#39;Y&#39;)) {
 5370     int inputid = ctxt-&gt;input-&gt;id;
 5371     SHRINK;
 5372     SKIP(8);
 5373     if (SKIP_BLANKS == 0) {
 5374         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5375                &quot;Space required after &#39;&lt;!ENTITY&#39;\n&quot;);
 5376     }
 5377 
 5378     if (RAW == &#39;%&#39;) {
 5379         NEXT;
 5380         if (SKIP_BLANKS == 0) {
 5381         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5382                    &quot;Space required after &#39;%%&#39;\n&quot;);
 5383         }
 5384         isParameter = 1;
 5385     }
 5386 
 5387         name = xmlParseName(ctxt);
 5388     if (name == NULL) {
 5389         xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 5390                        &quot;xmlParseEntityDecl: no name\n&quot;);
 5391             return;
 5392     }
 5393     if (xmlStrchr(name, &#39;:&#39;) != NULL) {
 5394         xmlNsErr(ctxt, XML_NS_ERR_COLON,
 5395              &quot;colons are forbidden from entities names &#39;%s&#39;\n&quot;,
 5396              name, NULL, NULL);
 5397     }
 5398     if (SKIP_BLANKS == 0) {
 5399         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5400                &quot;Space required after the entity name\n&quot;);
 5401     }
 5402 
 5403     ctxt-&gt;instate = XML_PARSER_ENTITY_DECL;
 5404     /*
 5405      * handle the various case of definitions...
 5406      */
 5407     if (isParameter) {
 5408         if ((RAW == &#39;&quot;&#39;) || (RAW == &#39;\&#39;&#39;)) {
 5409             value = xmlParseEntityValue(ctxt, &amp;orig);
 5410         if (value) {
 5411             if ((ctxt-&gt;sax != NULL) &amp;&amp;
 5412             (!ctxt-&gt;disableSAX) &amp;&amp; (ctxt-&gt;sax-&gt;entityDecl != NULL))
 5413             ctxt-&gt;sax-&gt;entityDecl(ctxt-&gt;userData, name,
 5414                             XML_INTERNAL_PARAMETER_ENTITY,
 5415                     NULL, NULL, value);
 5416         }
 5417         } else {
 5418             URI = xmlParseExternalID(ctxt, &amp;literal, 1);
 5419         if ((URI == NULL) &amp;&amp; (literal == NULL)) {
 5420             xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL);
 5421         }
 5422         if (URI) {
 5423             xmlURIPtr uri;
 5424 
 5425             uri = xmlParseURI((const char *) URI);
 5426             if (uri == NULL) {
 5427                 xmlErrMsgStr(ctxt, XML_ERR_INVALID_URI,
 5428                      &quot;Invalid URI: %s\n&quot;, URI);
 5429             /*
 5430              * This really ought to be a well formedness error
 5431              * but the XML Core WG decided otherwise c.f. issue
 5432              * E26 of the XML erratas.
 5433              */
 5434             } else {
 5435             if (uri-&gt;fragment != NULL) {
 5436                 /*
 5437                  * Okay this is foolish to block those but not
 5438                  * invalid URIs.
 5439                  */
 5440                 xmlFatalErr(ctxt, XML_ERR_URI_FRAGMENT, NULL);
 5441             } else {
 5442                 if ((ctxt-&gt;sax != NULL) &amp;&amp;
 5443                 (!ctxt-&gt;disableSAX) &amp;&amp;
 5444                 (ctxt-&gt;sax-&gt;entityDecl != NULL))
 5445                 ctxt-&gt;sax-&gt;entityDecl(ctxt-&gt;userData, name,
 5446                         XML_EXTERNAL_PARAMETER_ENTITY,
 5447                         literal, URI, NULL);
 5448             }
 5449             xmlFreeURI(uri);
 5450             }
 5451         }
 5452         }
 5453     } else {
 5454         if ((RAW == &#39;&quot;&#39;) || (RAW == &#39;\&#39;&#39;)) {
 5455             value = xmlParseEntityValue(ctxt, &amp;orig);
 5456         if ((ctxt-&gt;sax != NULL) &amp;&amp;
 5457             (!ctxt-&gt;disableSAX) &amp;&amp; (ctxt-&gt;sax-&gt;entityDecl != NULL))
 5458             ctxt-&gt;sax-&gt;entityDecl(ctxt-&gt;userData, name,
 5459                 XML_INTERNAL_GENERAL_ENTITY,
 5460                 NULL, NULL, value);
 5461         /*
 5462          * For expat compatibility in SAX mode.
 5463          */
 5464         if ((ctxt-&gt;myDoc == NULL) ||
 5465             (xmlStrEqual(ctxt-&gt;myDoc-&gt;version, SAX_COMPAT_MODE))) {
 5466             if (ctxt-&gt;myDoc == NULL) {
 5467             ctxt-&gt;myDoc = xmlNewDoc(SAX_COMPAT_MODE);
 5468             if (ctxt-&gt;myDoc == NULL) {
 5469                 xmlErrMemory(ctxt, &quot;New Doc failed&quot;);
 5470                 return;
 5471             }
 5472             ctxt-&gt;myDoc-&gt;properties = XML_DOC_INTERNAL;
 5473             }
 5474             if (ctxt-&gt;myDoc-&gt;intSubset == NULL)
 5475             ctxt-&gt;myDoc-&gt;intSubset = xmlNewDtd(ctxt-&gt;myDoc,
 5476                         BAD_CAST &quot;fake&quot;, NULL, NULL);
 5477 
 5478             xmlSAX2EntityDecl(ctxt, name, XML_INTERNAL_GENERAL_ENTITY,
 5479                           NULL, NULL, value);
 5480         }
 5481         } else {
 5482             URI = xmlParseExternalID(ctxt, &amp;literal, 1);
 5483         if ((URI == NULL) &amp;&amp; (literal == NULL)) {
 5484             xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL);
 5485         }
 5486         if (URI) {
 5487             xmlURIPtr uri;
 5488 
 5489             uri = xmlParseURI((const char *)URI);
 5490             if (uri == NULL) {
 5491                 xmlErrMsgStr(ctxt, XML_ERR_INVALID_URI,
 5492                      &quot;Invalid URI: %s\n&quot;, URI);
 5493             /*
 5494              * This really ought to be a well formedness error
 5495              * but the XML Core WG decided otherwise c.f. issue
 5496              * E26 of the XML erratas.
 5497              */
 5498             } else {
 5499             if (uri-&gt;fragment != NULL) {
 5500                 /*
 5501                  * Okay this is foolish to block those but not
 5502                  * invalid URIs.
 5503                  */
 5504                 xmlFatalErr(ctxt, XML_ERR_URI_FRAGMENT, NULL);
 5505             }
 5506             xmlFreeURI(uri);
 5507             }
 5508         }
 5509         if ((RAW != &#39;&gt;&#39;) &amp;&amp; (SKIP_BLANKS == 0)) {
 5510             xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5511                    &quot;Space required before &#39;NDATA&#39;\n&quot;);
 5512         }
 5513         if (CMP5(CUR_PTR, &#39;N&#39;, &#39;D&#39;, &#39;A&#39;, &#39;T&#39;, &#39;A&#39;)) {
 5514             SKIP(5);
 5515             if (SKIP_BLANKS == 0) {
 5516             xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5517                        &quot;Space required after &#39;NDATA&#39;\n&quot;);
 5518             }
 5519             ndata = xmlParseName(ctxt);
 5520             if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX) &amp;&amp;
 5521                 (ctxt-&gt;sax-&gt;unparsedEntityDecl != NULL))
 5522             ctxt-&gt;sax-&gt;unparsedEntityDecl(ctxt-&gt;userData, name,
 5523                     literal, URI, ndata);
 5524         } else {
 5525             if ((ctxt-&gt;sax != NULL) &amp;&amp;
 5526                 (!ctxt-&gt;disableSAX) &amp;&amp; (ctxt-&gt;sax-&gt;entityDecl != NULL))
 5527             ctxt-&gt;sax-&gt;entityDecl(ctxt-&gt;userData, name,
 5528                     XML_EXTERNAL_GENERAL_PARSED_ENTITY,
 5529                     literal, URI, NULL);
 5530             /*
 5531              * For expat compatibility in SAX mode.
 5532              * assuming the entity replacement was asked for
 5533              */
 5534             if ((ctxt-&gt;replaceEntities != 0) &amp;&amp;
 5535             ((ctxt-&gt;myDoc == NULL) ||
 5536             (xmlStrEqual(ctxt-&gt;myDoc-&gt;version, SAX_COMPAT_MODE)))) {
 5537             if (ctxt-&gt;myDoc == NULL) {
 5538                 ctxt-&gt;myDoc = xmlNewDoc(SAX_COMPAT_MODE);
 5539                 if (ctxt-&gt;myDoc == NULL) {
 5540                     xmlErrMemory(ctxt, &quot;New Doc failed&quot;);
 5541                 return;
 5542                 }
 5543                 ctxt-&gt;myDoc-&gt;properties = XML_DOC_INTERNAL;
 5544             }
 5545 
 5546             if (ctxt-&gt;myDoc-&gt;intSubset == NULL)
 5547                 ctxt-&gt;myDoc-&gt;intSubset = xmlNewDtd(ctxt-&gt;myDoc,
 5548                         BAD_CAST &quot;fake&quot;, NULL, NULL);
 5549             xmlSAX2EntityDecl(ctxt, name,
 5550                           XML_EXTERNAL_GENERAL_PARSED_ENTITY,
 5551                           literal, URI, NULL);
 5552             }
 5553         }
 5554         }
 5555     }
 5556     if (ctxt-&gt;instate == XML_PARSER_EOF)
 5557         goto done;
 5558     SKIP_BLANKS;
 5559     if (RAW != &#39;&gt;&#39;) {
 5560         xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_NOT_FINISHED,
 5561                 &quot;xmlParseEntityDecl: entity %s not terminated\n&quot;, name);
 5562         xmlHaltParser(ctxt);
 5563     } else {
 5564         if (inputid != ctxt-&gt;input-&gt;id) {
 5565         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5566                            &quot;Entity declaration doesn&#39;t start and stop in&quot;
 5567                                &quot; the same entity\n&quot;);
 5568         }
 5569         NEXT;
 5570     }
 5571     if (orig != NULL) {
 5572         /*
 5573          * Ugly mechanism to save the raw entity value.
 5574          */
 5575         xmlEntityPtr cur = NULL;
 5576 
 5577         if (isParameter) {
 5578             if ((ctxt-&gt;sax != NULL) &amp;&amp;
 5579             (ctxt-&gt;sax-&gt;getParameterEntity != NULL))
 5580             cur = ctxt-&gt;sax-&gt;getParameterEntity(ctxt-&gt;userData, name);
 5581         } else {
 5582             if ((ctxt-&gt;sax != NULL) &amp;&amp;
 5583             (ctxt-&gt;sax-&gt;getEntity != NULL))
 5584             cur = ctxt-&gt;sax-&gt;getEntity(ctxt-&gt;userData, name);
 5585         if ((cur == NULL) &amp;&amp; (ctxt-&gt;userData==ctxt)) {
 5586             cur = xmlSAX2GetEntity(ctxt, name);
 5587         }
 5588         }
 5589             if ((cur != NULL) &amp;&amp; (cur-&gt;orig == NULL)) {
 5590         cur-&gt;orig = orig;
 5591                 orig = NULL;
 5592         }
 5593     }
 5594 
 5595 done:
 5596     if (value != NULL) xmlFree(value);
 5597     if (URI != NULL) xmlFree(URI);
 5598     if (literal != NULL) xmlFree(literal);
 5599         if (orig != NULL) xmlFree(orig);
 5600     }
 5601 }
 5602 
 5603 /**
 5604  * xmlParseDefaultDecl:
 5605  * @ctxt:  an XML parser context
 5606  * @value:  Receive a possible fixed default value for the attribute
 5607  *
 5608  * Parse an attribute default declaration
 5609  *
 5610  * [60] DefaultDecl ::= &#39;#REQUIRED&#39; | &#39;#IMPLIED&#39; | ((&#39;#FIXED&#39; S)? AttValue)
 5611  *
 5612  * [ VC: Required Attribute ]
 5613  * if the default declaration is the keyword #REQUIRED, then the
 5614  * attribute must be specified for all elements of the type in the
 5615  * attribute-list declaration.
 5616  *
 5617  * [ VC: Attribute Default Legal ]
 5618  * The declared default value must meet the lexical constraints of
 5619  * the declared attribute type c.f. xmlValidateAttributeDecl()
 5620  *
 5621  * [ VC: Fixed Attribute Default ]
 5622  * if an attribute has a default value declared with the #FIXED
 5623  * keyword, instances of that attribute must match the default value.
 5624  *
 5625  * [ WFC: No &lt; in Attribute Values ]
 5626  * handled in xmlParseAttValue()
 5627  *
 5628  * returns: XML_ATTRIBUTE_NONE, XML_ATTRIBUTE_REQUIRED, XML_ATTRIBUTE_IMPLIED
 5629  *          or XML_ATTRIBUTE_FIXED.
 5630  */
 5631 
 5632 int
 5633 xmlParseDefaultDecl(xmlParserCtxtPtr ctxt, xmlChar **value) {
 5634     int val;
 5635     xmlChar *ret;
 5636 
 5637     *value = NULL;
 5638     if (CMP9(CUR_PTR, &#39;#&#39;, &#39;R&#39;, &#39;E&#39;, &#39;Q&#39;, &#39;U&#39;, &#39;I&#39;, &#39;R&#39;, &#39;E&#39;, &#39;D&#39;)) {
 5639     SKIP(9);
 5640     return(XML_ATTRIBUTE_REQUIRED);
 5641     }
 5642     if (CMP8(CUR_PTR, &#39;#&#39;, &#39;I&#39;, &#39;M&#39;, &#39;P&#39;, &#39;L&#39;, &#39;I&#39;, &#39;E&#39;, &#39;D&#39;)) {
 5643     SKIP(8);
 5644     return(XML_ATTRIBUTE_IMPLIED);
 5645     }
 5646     val = XML_ATTRIBUTE_NONE;
 5647     if (CMP6(CUR_PTR, &#39;#&#39;, &#39;F&#39;, &#39;I&#39;, &#39;X&#39;, &#39;E&#39;, &#39;D&#39;)) {
 5648     SKIP(6);
 5649     val = XML_ATTRIBUTE_FIXED;
 5650     if (SKIP_BLANKS == 0) {
 5651         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5652                &quot;Space required after &#39;#FIXED&#39;\n&quot;);
 5653     }
 5654     }
 5655     ret = xmlParseAttValue(ctxt);
 5656     ctxt-&gt;instate = XML_PARSER_DTD;
 5657     if (ret == NULL) {
 5658     xmlFatalErrMsg(ctxt, (xmlParserErrors)ctxt-&gt;errNo,
 5659                &quot;Attribute default value declaration error\n&quot;);
 5660     } else
 5661         *value = ret;
 5662     return(val);
 5663 }
 5664 
 5665 /**
 5666  * xmlParseNotationType:
 5667  * @ctxt:  an XML parser context
 5668  *
 5669  * parse an Notation attribute type.
 5670  *
 5671  * Note: the leading &#39;NOTATION&#39; S part has already being parsed...
 5672  *
 5673  * [58] NotationType ::= &#39;NOTATION&#39; S &#39;(&#39; S? Name (S? &#39;|&#39; S? Name)* S? &#39;)&#39;
 5674  *
 5675  * [ VC: Notation Attributes ]
 5676  * Values of this type must match one of the notation names included
 5677  * in the declaration; all notation names in the declaration must be declared.
 5678  *
 5679  * Returns: the notation attribute tree built while parsing
 5680  */
 5681 
 5682 xmlEnumerationPtr
 5683 xmlParseNotationType(xmlParserCtxtPtr ctxt) {
 5684     const xmlChar *name;
 5685     xmlEnumerationPtr ret = NULL, last = NULL, cur, tmp;
 5686 
 5687     if (RAW != &#39;(&#39;) {
 5688     xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_STARTED, NULL);
 5689     return(NULL);
 5690     }
 5691     SHRINK;
 5692     do {
 5693         NEXT;
 5694     SKIP_BLANKS;
 5695         name = xmlParseName(ctxt);
 5696     if (name == NULL) {
 5697         xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 5698                &quot;Name expected in NOTATION declaration\n&quot;);
 5699             xmlFreeEnumeration(ret);
 5700         return(NULL);
 5701     }
 5702     tmp = ret;
 5703     while (tmp != NULL) {
 5704         if (xmlStrEqual(name, tmp-&gt;name)) {
 5705         xmlValidityError(ctxt, XML_DTD_DUP_TOKEN,
 5706       &quot;standalone: attribute notation value token %s duplicated\n&quot;,
 5707                  name, NULL);
 5708         if (!xmlDictOwns(ctxt-&gt;dict, name))
 5709             xmlFree((xmlChar *) name);
 5710         break;
 5711         }
 5712         tmp = tmp-&gt;next;
 5713     }
 5714     if (tmp == NULL) {
 5715         cur = xmlCreateEnumeration(name);
 5716         if (cur == NULL) {
 5717                 xmlFreeEnumeration(ret);
 5718                 return(NULL);
 5719             }
 5720         if (last == NULL) ret = last = cur;
 5721         else {
 5722         last-&gt;next = cur;
 5723         last = cur;
 5724         }
 5725     }
 5726     SKIP_BLANKS;
 5727     } while (RAW == &#39;|&#39;);
 5728     if (RAW != &#39;)&#39;) {
 5729     xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_FINISHED, NULL);
 5730         xmlFreeEnumeration(ret);
 5731     return(NULL);
 5732     }
 5733     NEXT;
 5734     return(ret);
 5735 }
 5736 
 5737 /**
 5738  * xmlParseEnumerationType:
 5739  * @ctxt:  an XML parser context
 5740  *
 5741  * parse an Enumeration attribute type.
 5742  *
 5743  * [59] Enumeration ::= &#39;(&#39; S? Nmtoken (S? &#39;|&#39; S? Nmtoken)* S? &#39;)&#39;
 5744  *
 5745  * [ VC: Enumeration ]
 5746  * Values of this type must match one of the Nmtoken tokens in
 5747  * the declaration
 5748  *
 5749  * Returns: the enumeration attribute tree built while parsing
 5750  */
 5751 
 5752 xmlEnumerationPtr
 5753 xmlParseEnumerationType(xmlParserCtxtPtr ctxt) {
 5754     xmlChar *name;
 5755     xmlEnumerationPtr ret = NULL, last = NULL, cur, tmp;
 5756 
 5757     if (RAW != &#39;(&#39;) {
 5758     xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_STARTED, NULL);
 5759     return(NULL);
 5760     }
 5761     SHRINK;
 5762     do {
 5763         NEXT;
 5764     SKIP_BLANKS;
 5765         name = xmlParseNmtoken(ctxt);
 5766     if (name == NULL) {
 5767         xmlFatalErr(ctxt, XML_ERR_NMTOKEN_REQUIRED, NULL);
 5768         return(ret);
 5769     }
 5770     tmp = ret;
 5771     while (tmp != NULL) {
 5772         if (xmlStrEqual(name, tmp-&gt;name)) {
 5773         xmlValidityError(ctxt, XML_DTD_DUP_TOKEN,
 5774       &quot;standalone: attribute enumeration value token %s duplicated\n&quot;,
 5775                  name, NULL);
 5776         if (!xmlDictOwns(ctxt-&gt;dict, name))
 5777             xmlFree(name);
 5778         break;
 5779         }
 5780         tmp = tmp-&gt;next;
 5781     }
 5782     if (tmp == NULL) {
 5783         cur = xmlCreateEnumeration(name);
 5784         if (!xmlDictOwns(ctxt-&gt;dict, name))
 5785         xmlFree(name);
 5786         if (cur == NULL) {
 5787                 xmlFreeEnumeration(ret);
 5788                 return(NULL);
 5789             }
 5790         if (last == NULL) ret = last = cur;
 5791         else {
 5792         last-&gt;next = cur;
 5793         last = cur;
 5794         }
 5795     }
 5796     SKIP_BLANKS;
 5797     } while (RAW == &#39;|&#39;);
 5798     if (RAW != &#39;)&#39;) {
 5799     xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_FINISHED, NULL);
 5800     return(ret);
 5801     }
 5802     NEXT;
 5803     return(ret);
 5804 }
 5805 
 5806 /**
 5807  * xmlParseEnumeratedType:
 5808  * @ctxt:  an XML parser context
 5809  * @tree:  the enumeration tree built while parsing
 5810  *
 5811  * parse an Enumerated attribute type.
 5812  *
 5813  * [57] EnumeratedType ::= NotationType | Enumeration
 5814  *
 5815  * [58] NotationType ::= &#39;NOTATION&#39; S &#39;(&#39; S? Name (S? &#39;|&#39; S? Name)* S? &#39;)&#39;
 5816  *
 5817  *
 5818  * Returns: XML_ATTRIBUTE_ENUMERATION or XML_ATTRIBUTE_NOTATION
 5819  */
 5820 
 5821 int
 5822 xmlParseEnumeratedType(xmlParserCtxtPtr ctxt, xmlEnumerationPtr *tree) {
 5823     if (CMP8(CUR_PTR, &#39;N&#39;, &#39;O&#39;, &#39;T&#39;, &#39;A&#39;, &#39;T&#39;, &#39;I&#39;, &#39;O&#39;, &#39;N&#39;)) {
 5824     SKIP(8);
 5825     if (SKIP_BLANKS == 0) {
 5826         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5827                &quot;Space required after &#39;NOTATION&#39;\n&quot;);
 5828         return(0);
 5829     }
 5830     *tree = xmlParseNotationType(ctxt);
 5831     if (*tree == NULL) return(0);
 5832     return(XML_ATTRIBUTE_NOTATION);
 5833     }
 5834     *tree = xmlParseEnumerationType(ctxt);
 5835     if (*tree == NULL) return(0);
 5836     return(XML_ATTRIBUTE_ENUMERATION);
 5837 }
 5838 
 5839 /**
 5840  * xmlParseAttributeType:
 5841  * @ctxt:  an XML parser context
 5842  * @tree:  the enumeration tree built while parsing
 5843  *
 5844  * parse the Attribute list def for an element
 5845  *
 5846  * [54] AttType ::= StringType | TokenizedType | EnumeratedType
 5847  *
 5848  * [55] StringType ::= &#39;CDATA&#39;
 5849  *
 5850  * [56] TokenizedType ::= &#39;ID&#39; | &#39;IDREF&#39; | &#39;IDREFS&#39; | &#39;ENTITY&#39; |
 5851  *                        &#39;ENTITIES&#39; | &#39;NMTOKEN&#39; | &#39;NMTOKENS&#39;
 5852  *
 5853  * Validity constraints for attribute values syntax are checked in
 5854  * xmlValidateAttributeValue()
 5855  *
 5856  * [ VC: ID ]
 5857  * Values of type ID must match the Name production. A name must not
 5858  * appear more than once in an XML document as a value of this type;
 5859  * i.e., ID values must uniquely identify the elements which bear them.
 5860  *
 5861  * [ VC: One ID per Element Type ]
 5862  * No element type may have more than one ID attribute specified.
 5863  *
 5864  * [ VC: ID Attribute Default ]
 5865  * An ID attribute must have a declared default of #IMPLIED or #REQUIRED.
 5866  *
 5867  * [ VC: IDREF ]
 5868  * Values of type IDREF must match the Name production, and values
 5869  * of type IDREFS must match Names; each IDREF Name must match the value
 5870  * of an ID attribute on some element in the XML document; i.e. IDREF
 5871  * values must match the value of some ID attribute.
 5872  *
 5873  * [ VC: Entity Name ]
 5874  * Values of type ENTITY must match the Name production, values
 5875  * of type ENTITIES must match Names; each Entity Name must match the
 5876  * name of an unparsed entity declared in the DTD.
 5877  *
 5878  * [ VC: Name Token ]
 5879  * Values of type NMTOKEN must match the Nmtoken production; values
 5880  * of type NMTOKENS must match Nmtokens.
 5881  *
 5882  * Returns the attribute type
 5883  */
 5884 int
 5885 xmlParseAttributeType(xmlParserCtxtPtr ctxt, xmlEnumerationPtr *tree) {
 5886     SHRINK;
 5887     if (CMP5(CUR_PTR, &#39;C&#39;, &#39;D&#39;, &#39;A&#39;, &#39;T&#39;, &#39;A&#39;)) {
 5888     SKIP(5);
 5889     return(XML_ATTRIBUTE_CDATA);
 5890      } else if (CMP6(CUR_PTR, &#39;I&#39;, &#39;D&#39;, &#39;R&#39;, &#39;E&#39;, &#39;F&#39;, &#39;S&#39;)) {
 5891     SKIP(6);
 5892     return(XML_ATTRIBUTE_IDREFS);
 5893      } else if (CMP5(CUR_PTR, &#39;I&#39;, &#39;D&#39;, &#39;R&#39;, &#39;E&#39;, &#39;F&#39;)) {
 5894     SKIP(5);
 5895     return(XML_ATTRIBUTE_IDREF);
 5896      } else if ((RAW == &#39;I&#39;) &amp;&amp; (NXT(1) == &#39;D&#39;)) {
 5897         SKIP(2);
 5898     return(XML_ATTRIBUTE_ID);
 5899      } else if (CMP6(CUR_PTR, &#39;E&#39;, &#39;N&#39;, &#39;T&#39;, &#39;I&#39;, &#39;T&#39;, &#39;Y&#39;)) {
 5900     SKIP(6);
 5901     return(XML_ATTRIBUTE_ENTITY);
 5902      } else if (CMP8(CUR_PTR, &#39;E&#39;, &#39;N&#39;, &#39;T&#39;, &#39;I&#39;, &#39;T&#39;, &#39;I&#39;, &#39;E&#39;, &#39;S&#39;)) {
 5903     SKIP(8);
 5904     return(XML_ATTRIBUTE_ENTITIES);
 5905      } else if (CMP8(CUR_PTR, &#39;N&#39;, &#39;M&#39;, &#39;T&#39;, &#39;O&#39;, &#39;K&#39;, &#39;E&#39;, &#39;N&#39;, &#39;S&#39;)) {
 5906     SKIP(8);
 5907     return(XML_ATTRIBUTE_NMTOKENS);
 5908      } else if (CMP7(CUR_PTR, &#39;N&#39;, &#39;M&#39;, &#39;T&#39;, &#39;O&#39;, &#39;K&#39;, &#39;E&#39;, &#39;N&#39;)) {
 5909     SKIP(7);
 5910     return(XML_ATTRIBUTE_NMTOKEN);
 5911      }
 5912      return(xmlParseEnumeratedType(ctxt, tree));
 5913 }
 5914 
 5915 /**
 5916  * xmlParseAttributeListDecl:
 5917  * @ctxt:  an XML parser context
 5918  *
 5919  * : parse the Attribute list def for an element
 5920  *
 5921  * [52] AttlistDecl ::= &#39;&lt;!ATTLIST&#39; S Name AttDef* S? &#39;&gt;&#39;
 5922  *
 5923  * [53] AttDef ::= S Name S AttType S DefaultDecl
 5924  *
 5925  */
 5926 void
 5927 xmlParseAttributeListDecl(xmlParserCtxtPtr ctxt) {
 5928     const xmlChar *elemName;
 5929     const xmlChar *attrName;
 5930     xmlEnumerationPtr tree;
 5931 
 5932     if (CMP9(CUR_PTR, &#39;&lt;&#39;, &#39;!&#39;, &#39;A&#39;, &#39;T&#39;, &#39;T&#39;, &#39;L&#39;, &#39;I&#39;, &#39;S&#39;, &#39;T&#39;)) {
 5933     int inputid = ctxt-&gt;input-&gt;id;
 5934 
 5935     SKIP(9);
 5936     if (SKIP_BLANKS == 0) {
 5937         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5938                          &quot;Space required after &#39;&lt;!ATTLIST&#39;\n&quot;);
 5939     }
 5940         elemName = xmlParseName(ctxt);
 5941     if (elemName == NULL) {
 5942         xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 5943                &quot;ATTLIST: no name for Element\n&quot;);
 5944         return;
 5945     }
 5946     SKIP_BLANKS;
 5947     GROW;
 5948     while ((RAW != &#39;&gt;&#39;) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF)) {
 5949         int type;
 5950         int def;
 5951         xmlChar *defaultValue = NULL;
 5952 
 5953         GROW;
 5954             tree = NULL;
 5955         attrName = xmlParseName(ctxt);
 5956         if (attrName == NULL) {
 5957         xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 5958                    &quot;ATTLIST: no name for Attribute\n&quot;);
 5959         break;
 5960         }
 5961         GROW;
 5962         if (SKIP_BLANKS == 0) {
 5963         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5964                 &quot;Space required after the attribute name\n&quot;);
 5965         break;
 5966         }
 5967 
 5968         type = xmlParseAttributeType(ctxt, &amp;tree);
 5969         if (type &lt;= 0) {
 5970             break;
 5971         }
 5972 
 5973         GROW;
 5974         if (SKIP_BLANKS == 0) {
 5975         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5976                    &quot;Space required after the attribute type\n&quot;);
 5977             if (tree != NULL)
 5978             xmlFreeEnumeration(tree);
 5979         break;
 5980         }
 5981 
 5982         def = xmlParseDefaultDecl(ctxt, &amp;defaultValue);
 5983         if (def &lt;= 0) {
 5984                 if (defaultValue != NULL)
 5985             xmlFree(defaultValue);
 5986             if (tree != NULL)
 5987             xmlFreeEnumeration(tree);
 5988             break;
 5989         }
 5990         if ((type != XML_ATTRIBUTE_CDATA) &amp;&amp; (defaultValue != NULL))
 5991             xmlAttrNormalizeSpace(defaultValue, defaultValue);
 5992 
 5993         GROW;
 5994             if (RAW != &#39;&gt;&#39;) {
 5995         if (SKIP_BLANKS == 0) {
 5996             xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5997             &quot;Space required after the attribute default value\n&quot;);
 5998             if (defaultValue != NULL)
 5999             xmlFree(defaultValue);
 6000             if (tree != NULL)
 6001             xmlFreeEnumeration(tree);
 6002             break;
 6003         }
 6004         }
 6005         if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX) &amp;&amp;
 6006         (ctxt-&gt;sax-&gt;attributeDecl != NULL))
 6007         ctxt-&gt;sax-&gt;attributeDecl(ctxt-&gt;userData, elemName, attrName,
 6008                             type, def, defaultValue, tree);
 6009         else if (tree != NULL)
 6010         xmlFreeEnumeration(tree);
 6011 
 6012         if ((ctxt-&gt;sax2) &amp;&amp; (defaultValue != NULL) &amp;&amp;
 6013             (def != XML_ATTRIBUTE_IMPLIED) &amp;&amp;
 6014         (def != XML_ATTRIBUTE_REQUIRED)) {
 6015         xmlAddDefAttrs(ctxt, elemName, attrName, defaultValue);
 6016         }
 6017         if (ctxt-&gt;sax2) {
 6018         xmlAddSpecialAttr(ctxt, elemName, attrName, type);
 6019         }
 6020         if (defaultValue != NULL)
 6021             xmlFree(defaultValue);
 6022         GROW;
 6023     }
 6024     if (RAW == &#39;&gt;&#39;) {
 6025         if (inputid != ctxt-&gt;input-&gt;id) {
 6026         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6027                                &quot;Attribute list declaration doesn&#39;t start and&quot;
 6028                                &quot; stop in the same entity\n&quot;);
 6029         }
 6030         NEXT;
 6031     }
 6032     }
 6033 }
 6034 
 6035 /**
 6036  * xmlParseElementMixedContentDecl:
 6037  * @ctxt:  an XML parser context
 6038  * @inputchk:  the input used for the current entity, needed for boundary checks
 6039  *
 6040  * parse the declaration for a Mixed Element content
 6041  * The leading &#39;(&#39; and spaces have been skipped in xmlParseElementContentDecl
 6042  *
 6043  * [51] Mixed ::= &#39;(&#39; S? &#39;#PCDATA&#39; (S? &#39;|&#39; S? Name)* S? &#39;)*&#39; |
 6044  *                &#39;(&#39; S? &#39;#PCDATA&#39; S? &#39;)&#39;
 6045  *
 6046  * [ VC: Proper Group/PE Nesting ] applies to [51] too (see [49])
 6047  *
 6048  * [ VC: No Duplicate Types ]
 6049  * The same name must not appear more than once in a single
 6050  * mixed-content declaration.
 6051  *
 6052  * returns: the list of the xmlElementContentPtr describing the element choices
 6053  */
 6054 xmlElementContentPtr
 6055 xmlParseElementMixedContentDecl(xmlParserCtxtPtr ctxt, int inputchk) {
 6056     xmlElementContentPtr ret = NULL, cur = NULL, n;
 6057     const xmlChar *elem = NULL;
 6058 
 6059     GROW;
 6060     if (CMP7(CUR_PTR, &#39;#&#39;, &#39;P&#39;, &#39;C&#39;, &#39;D&#39;, &#39;A&#39;, &#39;T&#39;, &#39;A&#39;)) {
 6061     SKIP(7);
 6062     SKIP_BLANKS;
 6063     SHRINK;
 6064     if (RAW == &#39;)&#39;) {
 6065         if (ctxt-&gt;input-&gt;id != inputchk) {
 6066         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6067                                &quot;Element content declaration doesn&#39;t start and&quot;
 6068                                &quot; stop in the same entity\n&quot;);
 6069         }
 6070         NEXT;
 6071         ret = xmlNewDocElementContent(ctxt-&gt;myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);
 6072         if (ret == NULL)
 6073             return(NULL);
 6074         if (RAW == &#39;*&#39;) {
 6075         ret-&gt;ocur = XML_ELEMENT_CONTENT_MULT;
 6076         NEXT;
 6077         }
 6078         return(ret);
 6079     }
 6080     if ((RAW == &#39;(&#39;) || (RAW == &#39;|&#39;)) {
 6081         ret = cur = xmlNewDocElementContent(ctxt-&gt;myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);
 6082         if (ret == NULL) return(NULL);
 6083     }
 6084     while ((RAW == &#39;|&#39;) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF)) {
 6085         NEXT;
 6086         if (elem == NULL) {
 6087             ret = xmlNewDocElementContent(ctxt-&gt;myDoc, NULL, XML_ELEMENT_CONTENT_OR);
 6088         if (ret == NULL) return(NULL);
 6089         ret-&gt;c1 = cur;
 6090         if (cur != NULL)
 6091             cur-&gt;parent = ret;
 6092         cur = ret;
 6093         } else {
 6094             n = xmlNewDocElementContent(ctxt-&gt;myDoc, NULL, XML_ELEMENT_CONTENT_OR);
 6095         if (n == NULL) return(NULL);
 6096         n-&gt;c1 = xmlNewDocElementContent(ctxt-&gt;myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);
 6097         if (n-&gt;c1 != NULL)
 6098             n-&gt;c1-&gt;parent = n;
 6099             cur-&gt;c2 = n;
 6100         if (n != NULL)
 6101             n-&gt;parent = cur;
 6102         cur = n;
 6103         }
 6104         SKIP_BLANKS;
 6105         elem = xmlParseName(ctxt);
 6106         if (elem == NULL) {
 6107         xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 6108             &quot;xmlParseElementMixedContentDecl : Name expected\n&quot;);
 6109         xmlFreeDocElementContent(ctxt-&gt;myDoc, ret);
 6110         return(NULL);
 6111         }
 6112         SKIP_BLANKS;
 6113         GROW;
 6114     }
 6115     if ((RAW == &#39;)&#39;) &amp;&amp; (NXT(1) == &#39;*&#39;)) {
 6116         if (elem != NULL) {
 6117         cur-&gt;c2 = xmlNewDocElementContent(ctxt-&gt;myDoc, elem,
 6118                                        XML_ELEMENT_CONTENT_ELEMENT);
 6119         if (cur-&gt;c2 != NULL)
 6120             cur-&gt;c2-&gt;parent = cur;
 6121             }
 6122             if (ret != NULL)
 6123                 ret-&gt;ocur = XML_ELEMENT_CONTENT_MULT;
 6124         if (ctxt-&gt;input-&gt;id != inputchk) {
 6125         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6126                                &quot;Element content declaration doesn&#39;t start and&quot;
 6127                                &quot; stop in the same entity\n&quot;);
 6128         }
 6129         SKIP(2);
 6130     } else {
 6131         xmlFreeDocElementContent(ctxt-&gt;myDoc, ret);
 6132         xmlFatalErr(ctxt, XML_ERR_MIXED_NOT_STARTED, NULL);
 6133         return(NULL);
 6134     }
 6135 
 6136     } else {
 6137     xmlFatalErr(ctxt, XML_ERR_PCDATA_REQUIRED, NULL);
 6138     }
 6139     return(ret);
 6140 }
 6141 
 6142 /**
 6143  * xmlParseElementChildrenContentDeclPriv:
 6144  * @ctxt:  an XML parser context
 6145  * @inputchk:  the input used for the current entity, needed for boundary checks
 6146  * @depth: the level of recursion
 6147  *
 6148  * parse the declaration for a Mixed Element content
 6149  * The leading &#39;(&#39; and spaces have been skipped in xmlParseElementContentDecl
 6150  *
 6151  *
 6152  * [47] children ::= (choice | seq) (&#39;?&#39; | &#39;*&#39; | &#39;+&#39;)?
 6153  *
 6154  * [48] cp ::= (Name | choice | seq) (&#39;?&#39; | &#39;*&#39; | &#39;+&#39;)?
 6155  *
 6156  * [49] choice ::= &#39;(&#39; S? cp ( S? &#39;|&#39; S? cp )* S? &#39;)&#39;
 6157  *
 6158  * [50] seq ::= &#39;(&#39; S? cp ( S? &#39;,&#39; S? cp )* S? &#39;)&#39;
 6159  *
 6160  * [ VC: Proper Group/PE Nesting ] applies to [49] and [50]
 6161  * TODO Parameter-entity replacement text must be properly nested
 6162  *  with parenthesized groups. That is to say, if either of the
 6163  *  opening or closing parentheses in a choice, seq, or Mixed
 6164  *  construct is contained in the replacement text for a parameter
 6165  *  entity, both must be contained in the same replacement text. For
 6166  *  interoperability, if a parameter-entity reference appears in a
 6167  *  choice, seq, or Mixed construct, its replacement text should not
 6168  *  be empty, and neither the first nor last non-blank character of
 6169  *  the replacement text should be a connector (| or ,).
 6170  *
 6171  * Returns the tree of xmlElementContentPtr describing the element
 6172  *          hierarchy.
 6173  */
 6174 static xmlElementContentPtr
 6175 xmlParseElementChildrenContentDeclPriv(xmlParserCtxtPtr ctxt, int inputchk,
 6176                                        int depth) {
 6177     xmlElementContentPtr ret = NULL, cur = NULL, last = NULL, op = NULL;
 6178     const xmlChar *elem;
 6179     xmlChar type = 0;
 6180 
 6181     if (((depth &gt; 128) &amp;&amp; ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) ||
 6182         (depth &gt;  2048)) {
 6183         xmlFatalErrMsgInt(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED,
 6184 &quot;xmlParseElementChildrenContentDecl : depth %d too deep, use XML_PARSE_HUGE\n&quot;,
 6185                           depth);
 6186     return(NULL);
 6187     }
 6188     SKIP_BLANKS;
 6189     GROW;
 6190     if (RAW == &#39;(&#39;) {
 6191     int inputid = ctxt-&gt;input-&gt;id;
 6192 
 6193         /* Recurse on first child */
 6194     NEXT;
 6195     SKIP_BLANKS;
 6196         cur = ret = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,
 6197                                                            depth + 1);
 6198     SKIP_BLANKS;
 6199     GROW;
 6200     } else {
 6201     elem = xmlParseName(ctxt);
 6202     if (elem == NULL) {
 6203         xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);
 6204         return(NULL);
 6205     }
 6206         cur = ret = xmlNewDocElementContent(ctxt-&gt;myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);
 6207     if (cur == NULL) {
 6208         xmlErrMemory(ctxt, NULL);
 6209         return(NULL);
 6210     }
 6211     GROW;
 6212     if (RAW == &#39;?&#39;) {
 6213         cur-&gt;ocur = XML_ELEMENT_CONTENT_OPT;
 6214         NEXT;
 6215     } else if (RAW == &#39;*&#39;) {
 6216         cur-&gt;ocur = XML_ELEMENT_CONTENT_MULT;
 6217         NEXT;
 6218     } else if (RAW == &#39;+&#39;) {
 6219         cur-&gt;ocur = XML_ELEMENT_CONTENT_PLUS;
 6220         NEXT;
 6221     } else {
 6222         cur-&gt;ocur = XML_ELEMENT_CONTENT_ONCE;
 6223     }
 6224     GROW;
 6225     }
 6226     SKIP_BLANKS;
 6227     SHRINK;
 6228     while ((RAW != &#39;)&#39;) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF)) {
 6229         /*
 6230      * Each loop we parse one separator and one element.
 6231      */
 6232         if (RAW == &#39;,&#39;) {
 6233         if (type == 0) type = CUR;
 6234 
 6235         /*
 6236          * Detect &quot;Name | Name , Name&quot; error
 6237          */
 6238         else if (type != CUR) {
 6239         xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,
 6240             &quot;xmlParseElementChildrenContentDecl : &#39;%c&#39; expected\n&quot;,
 6241                           type);
 6242         if ((last != NULL) &amp;&amp; (last != ret))
 6243             xmlFreeDocElementContent(ctxt-&gt;myDoc, last);
 6244         if (ret != NULL)
 6245             xmlFreeDocElementContent(ctxt-&gt;myDoc, ret);
 6246         return(NULL);
 6247         }
 6248         NEXT;
 6249 
 6250         op = xmlNewDocElementContent(ctxt-&gt;myDoc, NULL, XML_ELEMENT_CONTENT_SEQ);
 6251         if (op == NULL) {
 6252         if ((last != NULL) &amp;&amp; (last != ret))
 6253             xmlFreeDocElementContent(ctxt-&gt;myDoc, last);
 6254             xmlFreeDocElementContent(ctxt-&gt;myDoc, ret);
 6255         return(NULL);
 6256         }
 6257         if (last == NULL) {
 6258         op-&gt;c1 = ret;
 6259         if (ret != NULL)
 6260             ret-&gt;parent = op;
 6261         ret = cur = op;
 6262         } else {
 6263             cur-&gt;c2 = op;
 6264         if (op != NULL)
 6265             op-&gt;parent = cur;
 6266         op-&gt;c1 = last;
 6267         if (last != NULL)
 6268             last-&gt;parent = op;
 6269         cur =op;
 6270         last = NULL;
 6271         }
 6272     } else if (RAW == &#39;|&#39;) {
 6273         if (type == 0) type = CUR;
 6274 
 6275         /*
 6276          * Detect &quot;Name , Name | Name&quot; error
 6277          */
 6278         else if (type != CUR) {
 6279         xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,
 6280             &quot;xmlParseElementChildrenContentDecl : &#39;%c&#39; expected\n&quot;,
 6281                   type);
 6282         if ((last != NULL) &amp;&amp; (last != ret))
 6283             xmlFreeDocElementContent(ctxt-&gt;myDoc, last);
 6284         if (ret != NULL)
 6285             xmlFreeDocElementContent(ctxt-&gt;myDoc, ret);
 6286         return(NULL);
 6287         }
 6288         NEXT;
 6289 
 6290         op = xmlNewDocElementContent(ctxt-&gt;myDoc, NULL, XML_ELEMENT_CONTENT_OR);
 6291         if (op == NULL) {
 6292         if ((last != NULL) &amp;&amp; (last != ret))
 6293             xmlFreeDocElementContent(ctxt-&gt;myDoc, last);
 6294         if (ret != NULL)
 6295             xmlFreeDocElementContent(ctxt-&gt;myDoc, ret);
 6296         return(NULL);
 6297         }
 6298         if (last == NULL) {
 6299         op-&gt;c1 = ret;
 6300         if (ret != NULL)
 6301             ret-&gt;parent = op;
 6302         ret = cur = op;
 6303         } else {
 6304             cur-&gt;c2 = op;
 6305         if (op != NULL)
 6306             op-&gt;parent = cur;
 6307         op-&gt;c1 = last;
 6308         if (last != NULL)
 6309             last-&gt;parent = op;
 6310         cur =op;
 6311         last = NULL;
 6312         }
 6313     } else {
 6314         xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED, NULL);
 6315         if ((last != NULL) &amp;&amp; (last != ret))
 6316             xmlFreeDocElementContent(ctxt-&gt;myDoc, last);
 6317         if (ret != NULL)
 6318         xmlFreeDocElementContent(ctxt-&gt;myDoc, ret);
 6319         return(NULL);
 6320     }
 6321     GROW;
 6322     SKIP_BLANKS;
 6323     GROW;
 6324     if (RAW == &#39;(&#39;) {
 6325         int inputid = ctxt-&gt;input-&gt;id;
 6326         /* Recurse on second child */
 6327         NEXT;
 6328         SKIP_BLANKS;
 6329         last = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,
 6330                                                           depth + 1);
 6331         SKIP_BLANKS;
 6332     } else {
 6333         elem = xmlParseName(ctxt);
 6334         if (elem == NULL) {
 6335         xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);
 6336         if (ret != NULL)
 6337             xmlFreeDocElementContent(ctxt-&gt;myDoc, ret);
 6338         return(NULL);
 6339         }
 6340         last = xmlNewDocElementContent(ctxt-&gt;myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);
 6341         if (last == NULL) {
 6342         if (ret != NULL)
 6343             xmlFreeDocElementContent(ctxt-&gt;myDoc, ret);
 6344         return(NULL);
 6345         }
 6346         if (RAW == &#39;?&#39;) {
 6347         last-&gt;ocur = XML_ELEMENT_CONTENT_OPT;
 6348         NEXT;
 6349         } else if (RAW == &#39;*&#39;) {
 6350         last-&gt;ocur = XML_ELEMENT_CONTENT_MULT;
 6351         NEXT;
 6352         } else if (RAW == &#39;+&#39;) {
 6353         last-&gt;ocur = XML_ELEMENT_CONTENT_PLUS;
 6354         NEXT;
 6355         } else {
 6356         last-&gt;ocur = XML_ELEMENT_CONTENT_ONCE;
 6357         }
 6358     }
 6359     SKIP_BLANKS;
 6360     GROW;
 6361     }
 6362     if ((cur != NULL) &amp;&amp; (last != NULL)) {
 6363         cur-&gt;c2 = last;
 6364     if (last != NULL)
 6365         last-&gt;parent = cur;
 6366     }
 6367     if (ctxt-&gt;input-&gt;id != inputchk) {
 6368     xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6369                        &quot;Element content declaration doesn&#39;t start and stop in&quot;
 6370                        &quot; the same entity\n&quot;);
 6371     }
 6372     NEXT;
 6373     if (RAW == &#39;?&#39;) {
 6374     if (ret != NULL) {
 6375         if ((ret-&gt;ocur == XML_ELEMENT_CONTENT_PLUS) ||
 6376             (ret-&gt;ocur == XML_ELEMENT_CONTENT_MULT))
 6377             ret-&gt;ocur = XML_ELEMENT_CONTENT_MULT;
 6378         else
 6379             ret-&gt;ocur = XML_ELEMENT_CONTENT_OPT;
 6380     }
 6381     NEXT;
 6382     } else if (RAW == &#39;*&#39;) {
 6383     if (ret != NULL) {
 6384         ret-&gt;ocur = XML_ELEMENT_CONTENT_MULT;
 6385         cur = ret;
 6386         /*
 6387          * Some normalization:
 6388          * (a | b* | c?)* == (a | b | c)*
 6389          */
 6390         while ((cur != NULL) &amp;&amp; (cur-&gt;type == XML_ELEMENT_CONTENT_OR)) {
 6391         if ((cur-&gt;c1 != NULL) &amp;&amp;
 6392                 ((cur-&gt;c1-&gt;ocur == XML_ELEMENT_CONTENT_OPT) ||
 6393              (cur-&gt;c1-&gt;ocur == XML_ELEMENT_CONTENT_MULT)))
 6394             cur-&gt;c1-&gt;ocur = XML_ELEMENT_CONTENT_ONCE;
 6395         if ((cur-&gt;c2 != NULL) &amp;&amp;
 6396                 ((cur-&gt;c2-&gt;ocur == XML_ELEMENT_CONTENT_OPT) ||
 6397              (cur-&gt;c2-&gt;ocur == XML_ELEMENT_CONTENT_MULT)))
 6398             cur-&gt;c2-&gt;ocur = XML_ELEMENT_CONTENT_ONCE;
 6399         cur = cur-&gt;c2;
 6400         }
 6401     }
 6402     NEXT;
 6403     } else if (RAW == &#39;+&#39;) {
 6404     if (ret != NULL) {
 6405         int found = 0;
 6406 
 6407         if ((ret-&gt;ocur == XML_ELEMENT_CONTENT_OPT) ||
 6408             (ret-&gt;ocur == XML_ELEMENT_CONTENT_MULT))
 6409             ret-&gt;ocur = XML_ELEMENT_CONTENT_MULT;
 6410         else
 6411             ret-&gt;ocur = XML_ELEMENT_CONTENT_PLUS;
 6412         /*
 6413          * Some normalization:
 6414          * (a | b*)+ == (a | b)*
 6415          * (a | b?)+ == (a | b)*
 6416          */
 6417         while ((cur != NULL) &amp;&amp; (cur-&gt;type == XML_ELEMENT_CONTENT_OR)) {
 6418         if ((cur-&gt;c1 != NULL) &amp;&amp;
 6419                 ((cur-&gt;c1-&gt;ocur == XML_ELEMENT_CONTENT_OPT) ||
 6420              (cur-&gt;c1-&gt;ocur == XML_ELEMENT_CONTENT_MULT))) {
 6421             cur-&gt;c1-&gt;ocur = XML_ELEMENT_CONTENT_ONCE;
 6422             found = 1;
 6423         }
 6424         if ((cur-&gt;c2 != NULL) &amp;&amp;
 6425                 ((cur-&gt;c2-&gt;ocur == XML_ELEMENT_CONTENT_OPT) ||
 6426              (cur-&gt;c2-&gt;ocur == XML_ELEMENT_CONTENT_MULT))) {
 6427             cur-&gt;c2-&gt;ocur = XML_ELEMENT_CONTENT_ONCE;
 6428             found = 1;
 6429         }
 6430         cur = cur-&gt;c2;
 6431         }
 6432         if (found)
 6433         ret-&gt;ocur = XML_ELEMENT_CONTENT_MULT;
 6434     }
 6435     NEXT;
 6436     }
 6437     return(ret);
 6438 }
 6439 
 6440 /**
 6441  * xmlParseElementChildrenContentDecl:
 6442  * @ctxt:  an XML parser context
 6443  * @inputchk:  the input used for the current entity, needed for boundary checks
 6444  *
 6445  * parse the declaration for a Mixed Element content
 6446  * The leading &#39;(&#39; and spaces have been skipped in xmlParseElementContentDecl
 6447  *
 6448  * [47] children ::= (choice | seq) (&#39;?&#39; | &#39;*&#39; | &#39;+&#39;)?
 6449  *
 6450  * [48] cp ::= (Name | choice | seq) (&#39;?&#39; | &#39;*&#39; | &#39;+&#39;)?
 6451  *
 6452  * [49] choice ::= &#39;(&#39; S? cp ( S? &#39;|&#39; S? cp )* S? &#39;)&#39;
 6453  *
 6454  * [50] seq ::= &#39;(&#39; S? cp ( S? &#39;,&#39; S? cp )* S? &#39;)&#39;
 6455  *
 6456  * [ VC: Proper Group/PE Nesting ] applies to [49] and [50]
 6457  * TODO Parameter-entity replacement text must be properly nested
 6458  *  with parenthesized groups. That is to say, if either of the
 6459  *  opening or closing parentheses in a choice, seq, or Mixed
 6460  *  construct is contained in the replacement text for a parameter
 6461  *  entity, both must be contained in the same replacement text. For
 6462  *  interoperability, if a parameter-entity reference appears in a
 6463  *  choice, seq, or Mixed construct, its replacement text should not
 6464  *  be empty, and neither the first nor last non-blank character of
 6465  *  the replacement text should be a connector (| or ,).
 6466  *
 6467  * Returns the tree of xmlElementContentPtr describing the element
 6468  *          hierarchy.
 6469  */
 6470 xmlElementContentPtr
 6471 xmlParseElementChildrenContentDecl(xmlParserCtxtPtr ctxt, int inputchk) {
 6472     /* stub left for API/ABI compat */
 6473     return(xmlParseElementChildrenContentDeclPriv(ctxt, inputchk, 1));
 6474 }
 6475 
 6476 /**
 6477  * xmlParseElementContentDecl:
 6478  * @ctxt:  an XML parser context
 6479  * @name:  the name of the element being defined.
 6480  * @result:  the Element Content pointer will be stored here if any
 6481  *
 6482  * parse the declaration for an Element content either Mixed or Children,
 6483  * the cases EMPTY and ANY are handled directly in xmlParseElementDecl
 6484  *
 6485  * [46] contentspec ::= &#39;EMPTY&#39; | &#39;ANY&#39; | Mixed | children
 6486  *
 6487  * returns: the type of element content XML_ELEMENT_TYPE_xxx
 6488  */
 6489 
 6490 int
 6491 xmlParseElementContentDecl(xmlParserCtxtPtr ctxt, const xmlChar *name,
 6492                            xmlElementContentPtr *result) {
 6493 
 6494     xmlElementContentPtr tree = NULL;
 6495     int inputid = ctxt-&gt;input-&gt;id;
 6496     int res;
 6497 
 6498     *result = NULL;
 6499 
 6500     if (RAW != &#39;(&#39;) {
 6501     xmlFatalErrMsgStr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,
 6502         &quot;xmlParseElementContentDecl : %s &#39;(&#39; expected\n&quot;, name);
 6503     return(-1);
 6504     }
 6505     NEXT;
 6506     GROW;
 6507     if (ctxt-&gt;instate == XML_PARSER_EOF)
 6508         return(-1);
 6509     SKIP_BLANKS;
 6510     if (CMP7(CUR_PTR, &#39;#&#39;, &#39;P&#39;, &#39;C&#39;, &#39;D&#39;, &#39;A&#39;, &#39;T&#39;, &#39;A&#39;)) {
 6511         tree = xmlParseElementMixedContentDecl(ctxt, inputid);
 6512     res = XML_ELEMENT_TYPE_MIXED;
 6513     } else {
 6514         tree = xmlParseElementChildrenContentDeclPriv(ctxt, inputid, 1);
 6515     res = XML_ELEMENT_TYPE_ELEMENT;
 6516     }
 6517     SKIP_BLANKS;
 6518     *result = tree;
 6519     return(res);
 6520 }
 6521 
 6522 /**
 6523  * xmlParseElementDecl:
 6524  * @ctxt:  an XML parser context
 6525  *
 6526  * parse an Element declaration.
 6527  *
 6528  * [45] elementdecl ::= &#39;&lt;!ELEMENT&#39; S Name S contentspec S? &#39;&gt;&#39;
 6529  *
 6530  * [ VC: Unique Element Type Declaration ]
 6531  * No element type may be declared more than once
 6532  *
 6533  * Returns the type of the element, or -1 in case of error
 6534  */
 6535 int
 6536 xmlParseElementDecl(xmlParserCtxtPtr ctxt) {
 6537     const xmlChar *name;
 6538     int ret = -1;
 6539     xmlElementContentPtr content  = NULL;
 6540 
 6541     /* GROW; done in the caller */
 6542     if (CMP9(CUR_PTR, &#39;&lt;&#39;, &#39;!&#39;, &#39;E&#39;, &#39;L&#39;, &#39;E&#39;, &#39;M&#39;, &#39;E&#39;, &#39;N&#39;, &#39;T&#39;)) {
 6543     int inputid = ctxt-&gt;input-&gt;id;
 6544 
 6545     SKIP(9);
 6546     if (SKIP_BLANKS == 0) {
 6547         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6548                    &quot;Space required after &#39;ELEMENT&#39;\n&quot;);
 6549         return(-1);
 6550     }
 6551         name = xmlParseName(ctxt);
 6552     if (name == NULL) {
 6553         xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 6554                &quot;xmlParseElementDecl: no name for Element\n&quot;);
 6555         return(-1);
 6556     }
 6557     if (SKIP_BLANKS == 0) {
 6558         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6559                &quot;Space required after the element name\n&quot;);
 6560     }
 6561     if (CMP5(CUR_PTR, &#39;E&#39;, &#39;M&#39;, &#39;P&#39;, &#39;T&#39;, &#39;Y&#39;)) {
 6562         SKIP(5);
 6563         /*
 6564          * Element must always be empty.
 6565          */
 6566         ret = XML_ELEMENT_TYPE_EMPTY;
 6567     } else if ((RAW == &#39;A&#39;) &amp;&amp; (NXT(1) == &#39;N&#39;) &amp;&amp;
 6568                (NXT(2) == &#39;Y&#39;)) {
 6569         SKIP(3);
 6570         /*
 6571          * Element is a generic container.
 6572          */
 6573         ret = XML_ELEMENT_TYPE_ANY;
 6574     } else if (RAW == &#39;(&#39;) {
 6575         ret = xmlParseElementContentDecl(ctxt, name, &amp;content);
 6576     } else {
 6577         /*
 6578          * [ WFC: PEs in Internal Subset ] error handling.
 6579          */
 6580         if ((RAW == &#39;%&#39;) &amp;&amp; (ctxt-&gt;external == 0) &amp;&amp;
 6581             (ctxt-&gt;inputNr == 1)) {
 6582         xmlFatalErrMsg(ctxt, XML_ERR_PEREF_IN_INT_SUBSET,
 6583       &quot;PEReference: forbidden within markup decl in internal subset\n&quot;);
 6584         } else {
 6585         xmlFatalErrMsg(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,
 6586               &quot;xmlParseElementDecl: &#39;EMPTY&#39;, &#39;ANY&#39; or &#39;(&#39; expected\n&quot;);
 6587             }
 6588         return(-1);
 6589     }
 6590 
 6591     SKIP_BLANKS;
 6592 
 6593     if (RAW != &#39;&gt;&#39;) {
 6594         xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
 6595         if (content != NULL) {
 6596         xmlFreeDocElementContent(ctxt-&gt;myDoc, content);
 6597         }
 6598     } else {
 6599         if (inputid != ctxt-&gt;input-&gt;id) {
 6600         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6601                                &quot;Element declaration doesn&#39;t start and stop in&quot;
 6602                                &quot; the same entity\n&quot;);
 6603         }
 6604 
 6605         NEXT;
 6606         if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX) &amp;&amp;
 6607         (ctxt-&gt;sax-&gt;elementDecl != NULL)) {
 6608         if (content != NULL)
 6609             content-&gt;parent = NULL;
 6610             ctxt-&gt;sax-&gt;elementDecl(ctxt-&gt;userData, name, ret,
 6611                                content);
 6612         if ((content != NULL) &amp;&amp; (content-&gt;parent == NULL)) {
 6613             /*
 6614              * this is a trick: if xmlAddElementDecl is called,
 6615              * instead of copying the full tree it is plugged directly
 6616              * if called from the parser. Avoid duplicating the
 6617              * interfaces or change the API/ABI
 6618              */
 6619             xmlFreeDocElementContent(ctxt-&gt;myDoc, content);
 6620         }
 6621         } else if (content != NULL) {
 6622         xmlFreeDocElementContent(ctxt-&gt;myDoc, content);
 6623         }
 6624     }
 6625     }
 6626     return(ret);
 6627 }
 6628 
 6629 /**
 6630  * xmlParseConditionalSections
 6631  * @ctxt:  an XML parser context
 6632  *
 6633  * [61] conditionalSect ::= includeSect | ignoreSect
 6634  * [62] includeSect ::= &#39;&lt;![&#39; S? &#39;INCLUDE&#39; S? &#39;[&#39; extSubsetDecl &#39;]]&gt;&#39;
 6635  * [63] ignoreSect ::= &#39;&lt;![&#39; S? &#39;IGNORE&#39; S? &#39;[&#39; ignoreSectContents* &#39;]]&gt;&#39;
 6636  * [64] ignoreSectContents ::= Ignore (&#39;&lt;![&#39; ignoreSectContents &#39;]]&gt;&#39; Ignore)*
 6637  * [65] Ignore ::= Char* - (Char* (&#39;&lt;![&#39; | &#39;]]&gt;&#39;) Char*)
 6638  */
 6639 
 6640 static void
 6641 xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
 6642     int *inputIds = NULL;
 6643     size_t inputIdsSize = 0;
 6644     size_t depth = 0;
 6645 
 6646     while (ctxt-&gt;instate != XML_PARSER_EOF) {
 6647         if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {
 6648     int id = ctxt-&gt;input-&gt;id;
 6649 
 6650     SKIP(3);
 6651     SKIP_BLANKS;
 6652 
 6653     if (CMP7(CUR_PTR, &#39;I&#39;, &#39;N&#39;, &#39;C&#39;, &#39;L&#39;, &#39;U&#39;, &#39;D&#39;, &#39;E&#39;)) {
 6654     SKIP(7);
 6655     SKIP_BLANKS;
 6656     if (RAW != &#39;[&#39;) {
 6657         xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
 6658         xmlHaltParser(ctxt);
 6659                     goto error;
 6660                 }
 6661         if (ctxt-&gt;input-&gt;id != id) {
 6662         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6663                                    &quot;All markup of the conditional section is&quot;
 6664                                    &quot; not in the same entity\n&quot;);
 6665         }
 6666         NEXT;
 6667 
 6668                 if (inputIdsSize &lt;= depth) {
 6669                     int *tmp;
 6670 
 6671                     inputIdsSize = (inputIdsSize == 0 ? 4 : inputIdsSize * 2);
 6672                     tmp = (int *) xmlRealloc(inputIds,
 6673                             inputIdsSize * sizeof(int));
 6674                     if (tmp == NULL) {
 6675                         xmlErrMemory(ctxt, NULL);
 6676                         goto error;
 6677         }
 6678                     inputIds = tmp;
 6679     }
 6680                 inputIds[depth] = id;
 6681                 depth++;
 6682     } else if (CMP6(CUR_PTR, &#39;I&#39;, &#39;G&#39;, &#39;N&#39;, &#39;O&#39;, &#39;R&#39;, &#39;E&#39;)) {
 6683     int state;
 6684     xmlParserInputState instate;
 6685                 size_t ignoreDepth = 0;
 6686 
 6687     SKIP(6);
 6688     SKIP_BLANKS;
 6689     if (RAW != &#39;[&#39;) {
 6690         xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
 6691         xmlHaltParser(ctxt);
 6692                     goto error;
 6693                 }
 6694         if (ctxt-&gt;input-&gt;id != id) {
 6695         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6696                                    &quot;All markup of the conditional section is&quot;
 6697                                    &quot; not in the same entity\n&quot;);
 6698         }
 6699         NEXT;
 6700 
 6701     /*
 6702                  * Parse up to the end of the conditional section but disable
 6703                  * SAX event generating DTD building in the meantime
 6704      */
 6705     state = ctxt-&gt;disableSAX;
 6706     instate = ctxt-&gt;instate;
 6707     if (ctxt-&gt;recovery == 0) ctxt-&gt;disableSAX = 1;
 6708     ctxt-&gt;instate = XML_PARSER_IGNORE;
 6709 
 6710                 while (RAW != 0) {
 6711       if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {
 6712         SKIP(3);
 6713                         ignoreDepth++;
 6714                         /* Check for integer overflow */
 6715                         if (ignoreDepth == 0) {
 6716                             xmlErrMemory(ctxt, NULL);
 6717                             goto error;
 6718       }
 6719                     } else if ((RAW == &#39;]&#39;) &amp;&amp; (NXT(1) == &#39;]&#39;) &amp;&amp;
 6720                                (NXT(2) == &#39;&gt;&#39;)) {
 6721                         if (ignoreDepth == 0)
 6722                             break;
 6723                         SKIP(3);
 6724                         ignoreDepth--;
 6725                     } else {
 6726       NEXT;
 6727                     }
 6728     }
 6729 
 6730     ctxt-&gt;disableSAX = state;
 6731     ctxt-&gt;instate = instate;
 6732 
 6733         if (RAW == 0) {
 6734             xmlFatalErr(ctxt, XML_ERR_CONDSEC_NOT_FINISHED, NULL);
 6735                     goto error;
 6736     }
 6737                 if (ctxt-&gt;input-&gt;id != id) {
 6738                     xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6739                                    &quot;All markup of the conditional section is&quot;
 6740                                    &quot; not in the same entity\n&quot;);
 6741                 }
 6742                 SKIP(3);
 6743     } else {
 6744     xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID_KEYWORD, NULL);
 6745     xmlHaltParser(ctxt);
 6746                 goto error;
 6747     }
 6748         } else if ((depth &gt; 0) &amp;&amp;
 6749                    (RAW == &#39;]&#39;) &amp;&amp; (NXT(1) == &#39;]&#39;) &amp;&amp; (NXT(2) == &#39;&gt;&#39;)) {
 6750             depth--;
 6751             if (ctxt-&gt;input-&gt;id != inputIds[depth]) {
 6752         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6753                                &quot;All markup of the conditional section is not&quot;
 6754                                &quot; in the same entity\n&quot;);
 6755     }
 6756         SKIP(3);
 6757         } else {
 6758             const xmlChar *check = CUR_PTR;
 6759             unsigned int cons = ctxt-&gt;input-&gt;consumed;
 6760 
 6761             xmlParseMarkupDecl(ctxt);
 6762 
 6763             if ((CUR_PTR == check) &amp;&amp; (cons == ctxt-&gt;input-&gt;consumed)) {
 6764                 xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
 6765                 xmlHaltParser(ctxt);
 6766                 goto error;
 6767             }
 6768     }
 6769 
 6770         if (depth == 0)
 6771             break;
 6772 
 6773         SKIP_BLANKS;
 6774         GROW;
 6775     }
 6776 
 6777 error:
 6778     xmlFree(inputIds);
 6779 }
 6780 
 6781 /**
 6782  * xmlParseMarkupDecl:
 6783  * @ctxt:  an XML parser context
 6784  *
 6785  * parse Markup declarations
 6786  *
 6787  * [29] markupdecl ::= elementdecl | AttlistDecl | EntityDecl |
 6788  *                     NotationDecl | PI | Comment
 6789  *
 6790  * [ VC: Proper Declaration/PE Nesting ]
 6791  * Parameter-entity replacement text must be properly nested with
 6792  * markup declarations. That is to say, if either the first character
 6793  * or the last character of a markup declaration (markupdecl above) is
 6794  * contained in the replacement text for a parameter-entity reference,
 6795  * both must be contained in the same replacement text.
 6796  *
 6797  * [ WFC: PEs in Internal Subset ]
 6798  * In the internal DTD subset, parameter-entity references can occur
 6799  * only where markup declarations can occur, not within markup declarations.
 6800  * (This does not apply to references that occur in external parameter
 6801  * entities or to the external subset.)
 6802  */
 6803 void
 6804 xmlParseMarkupDecl(xmlParserCtxtPtr ctxt) {
 6805     GROW;
 6806     if (CUR == &#39;&lt;&#39;) {
 6807         if (NXT(1) == &#39;!&#39;) {
 6808         switch (NXT(2)) {
 6809             case &#39;E&#39;:
 6810             if (NXT(3) == &#39;L&#39;)
 6811             xmlParseElementDecl(ctxt);
 6812             else if (NXT(3) == &#39;N&#39;)
 6813             xmlParseEntityDecl(ctxt);
 6814             break;
 6815             case &#39;A&#39;:
 6816             xmlParseAttributeListDecl(ctxt);
 6817             break;
 6818             case &#39;N&#39;:
 6819             xmlParseNotationDecl(ctxt);
 6820             break;
 6821             case &#39;-&#39;:
 6822             xmlParseComment(ctxt);
 6823             break;
 6824         default:
 6825             /* there is an error but it will be detected later */
 6826             break;
 6827         }
 6828     } else if (NXT(1) == &#39;?&#39;) {
 6829         xmlParsePI(ctxt);
 6830     }
 6831     }
 6832 
 6833     /*
 6834      * detect requirement to exit there and act accordingly
 6835      * and avoid having instate overridden later on
 6836      */
 6837     if (ctxt-&gt;instate == XML_PARSER_EOF)
 6838         return;
 6839 
 6840     ctxt-&gt;instate = XML_PARSER_DTD;
 6841 }
 6842 
 6843 /**
 6844  * xmlParseTextDecl:
 6845  * @ctxt:  an XML parser context
 6846  *
 6847  * parse an XML declaration header for external entities
 6848  *
 6849  * [77] TextDecl ::= &#39;&lt;?xml&#39; VersionInfo? EncodingDecl S? &#39;?&gt;&#39;
 6850  */
 6851 
 6852 void
 6853 xmlParseTextDecl(xmlParserCtxtPtr ctxt) {
 6854     xmlChar *version;
 6855     const xmlChar *encoding;
 6856 
 6857     /*
 6858      * We know that &#39;&lt;?xml&#39; is here.
 6859      */
 6860     if ((CMP5(CUR_PTR, &#39;&lt;&#39;, &#39;?&#39;, &#39;x&#39;, &#39;m&#39;, &#39;l&#39;)) &amp;&amp; (IS_BLANK_CH(NXT(5)))) {
 6861     SKIP(5);
 6862     } else {
 6863     xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_STARTED, NULL);
 6864     return;
 6865     }
 6866 
 6867     if (SKIP_BLANKS == 0) {
 6868     xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6869                &quot;Space needed after &#39;&lt;?xml&#39;\n&quot;);
 6870     }
 6871 
 6872     /*
 6873      * We may have the VersionInfo here.
 6874      */
 6875     version = xmlParseVersionInfo(ctxt);
 6876     if (version == NULL)
 6877     version = xmlCharStrdup(XML_DEFAULT_VERSION);
 6878     else {
 6879     if (SKIP_BLANKS == 0) {
 6880         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6881                    &quot;Space needed here\n&quot;);
 6882     }
 6883     }
 6884     ctxt-&gt;input-&gt;version = version;
 6885 
 6886     /*
 6887      * We must have the encoding declaration
 6888      */
 6889     encoding = xmlParseEncodingDecl(ctxt);
 6890     if (ctxt-&gt;errNo == XML_ERR_UNSUPPORTED_ENCODING) {
 6891     /*
 6892      * The XML REC instructs us to stop parsing right here
 6893      */
 6894         return;
 6895     }
 6896     if ((encoding == NULL) &amp;&amp; (ctxt-&gt;errNo == XML_ERR_OK)) {
 6897     xmlFatalErrMsg(ctxt, XML_ERR_MISSING_ENCODING,
 6898                &quot;Missing encoding in text declaration\n&quot;);
 6899     }
 6900 
 6901     SKIP_BLANKS;
 6902     if ((RAW == &#39;?&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;)) {
 6903         SKIP(2);
 6904     } else if (RAW == &#39;&gt;&#39;) {
 6905         /* Deprecated old WD ... */
 6906     xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
 6907     NEXT;
 6908     } else {
 6909     xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
 6910     MOVETO_ENDTAG(CUR_PTR);
 6911     NEXT;
 6912     }
 6913 }
 6914 
 6915 /**
 6916  * xmlParseExternalSubset:
 6917  * @ctxt:  an XML parser context
 6918  * @ExternalID: the external identifier
 6919  * @SystemID: the system identifier (or URL)
 6920  *
 6921  * parse Markup declarations from an external subset
 6922  *
 6923  * [30] extSubset ::= textDecl? extSubsetDecl
 6924  *
 6925  * [31] extSubsetDecl ::= (markupdecl | conditionalSect | PEReference | S) *
 6926  */
 6927 void
 6928 xmlParseExternalSubset(xmlParserCtxtPtr ctxt, const xmlChar *ExternalID,
 6929                        const xmlChar *SystemID) {
 6930     xmlDetectSAX2(ctxt);
 6931     GROW;
 6932 
 6933     if ((ctxt-&gt;encoding == NULL) &amp;&amp;
 6934         (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &gt;= 4)) {
 6935         xmlChar start[4];
 6936     xmlCharEncoding enc;
 6937 
 6938     start[0] = RAW;
 6939     start[1] = NXT(1);
 6940     start[2] = NXT(2);
 6941     start[3] = NXT(3);
 6942     enc = xmlDetectCharEncoding(start, 4);
 6943     if (enc != XML_CHAR_ENCODING_NONE)
 6944         xmlSwitchEncoding(ctxt, enc);
 6945     }
 6946 
 6947     if (CMP5(CUR_PTR, &#39;&lt;&#39;, &#39;?&#39;, &#39;x&#39;, &#39;m&#39;, &#39;l&#39;)) {
 6948     xmlParseTextDecl(ctxt);
 6949     if (ctxt-&gt;errNo == XML_ERR_UNSUPPORTED_ENCODING) {
 6950         /*
 6951          * The XML REC instructs us to stop parsing right here
 6952          */
 6953         xmlHaltParser(ctxt);
 6954         return;
 6955     }
 6956     }
 6957     if (ctxt-&gt;myDoc == NULL) {
 6958         ctxt-&gt;myDoc = xmlNewDoc(BAD_CAST &quot;1.0&quot;);
 6959     if (ctxt-&gt;myDoc == NULL) {
 6960         xmlErrMemory(ctxt, &quot;New Doc failed&quot;);
 6961         return;
 6962     }
 6963     ctxt-&gt;myDoc-&gt;properties = XML_DOC_INTERNAL;
 6964     }
 6965     if ((ctxt-&gt;myDoc != NULL) &amp;&amp; (ctxt-&gt;myDoc-&gt;intSubset == NULL))
 6966         xmlCreateIntSubset(ctxt-&gt;myDoc, NULL, ExternalID, SystemID);
 6967 
 6968     ctxt-&gt;instate = XML_PARSER_DTD;
 6969     ctxt-&gt;external = 1;
 6970     SKIP_BLANKS;
 6971     while (((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;?&#39;)) ||
 6972            ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;)) ||
 6973        (RAW == &#39;%&#39;)) {
 6974     const xmlChar *check = CUR_PTR;
 6975     unsigned int cons = ctxt-&gt;input-&gt;consumed;
 6976 
 6977     GROW;
 6978         if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {
 6979         xmlParseConditionalSections(ctxt);
 6980     } else
 6981         xmlParseMarkupDecl(ctxt);
 6982         SKIP_BLANKS;
 6983 
 6984     if ((CUR_PTR == check) &amp;&amp; (cons == ctxt-&gt;input-&gt;consumed)) {
 6985         xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
 6986         break;
 6987     }
 6988     }
 6989 
 6990     if (RAW != 0) {
 6991     xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
 6992     }
 6993 
 6994 }
 6995 
 6996 /**
 6997  * xmlParseReference:
 6998  * @ctxt:  an XML parser context
 6999  *
 7000  * parse and handle entity references in content, depending on the SAX
 7001  * interface, this may end-up in a call to character() if this is a
 7002  * CharRef, a predefined entity, if there is no reference() callback.
 7003  * or if the parser was asked to switch to that mode.
 7004  *
 7005  * [67] Reference ::= EntityRef | CharRef
 7006  */
 7007 void
 7008 xmlParseReference(xmlParserCtxtPtr ctxt) {
 7009     xmlEntityPtr ent;
 7010     xmlChar *val;
 7011     int was_checked;
 7012     xmlNodePtr list = NULL;
 7013     xmlParserErrors ret = XML_ERR_OK;
 7014 
 7015 
 7016     if (RAW != &#39;&amp;&#39;)
 7017         return;
 7018 
 7019     /*
 7020      * Simple case of a CharRef
 7021      */
 7022     if (NXT(1) == &#39;#&#39;) {
 7023     int i = 0;
 7024     xmlChar out[16];
 7025     int hex = NXT(2);
 7026     int value = xmlParseCharRef(ctxt);
 7027 
 7028     if (value == 0)
 7029         return;
 7030     if (ctxt-&gt;charset != XML_CHAR_ENCODING_UTF8) {
 7031         /*
 7032          * So we are using non-UTF-8 buffers
 7033          * Check that the char fit on 8bits, if not
 7034          * generate a CharRef.
 7035          */
 7036         if (value &lt;= 0xFF) {
 7037         out[0] = value;
 7038         out[1] = 0;
 7039         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;characters != NULL) &amp;&amp;
 7040             (!ctxt-&gt;disableSAX))
 7041             ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, out, 1);
 7042         } else {
 7043         if ((hex == &#39;x&#39;) || (hex == &#39;X&#39;))
 7044             snprintf((char *)out, sizeof(out), &quot;#x%X&quot;, value);
 7045         else
 7046             snprintf((char *)out, sizeof(out), &quot;#%d&quot;, value);
 7047         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;reference != NULL) &amp;&amp;
 7048             (!ctxt-&gt;disableSAX))
 7049             ctxt-&gt;sax-&gt;reference(ctxt-&gt;userData, out);
 7050         }
 7051     } else {
 7052         /*
 7053          * Just encode the value in UTF-8
 7054          */
 7055         COPY_BUF(0 ,out, i, value);
 7056         out[i] = 0;
 7057         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;characters != NULL) &amp;&amp;
 7058         (!ctxt-&gt;disableSAX))
 7059         ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, out, i);
 7060     }
 7061     return;
 7062     }
 7063 
 7064     /*
 7065      * We are seeing an entity reference
 7066      */
 7067     ent = xmlParseEntityRef(ctxt);
 7068     if (ent == NULL) return;
 7069     if (!ctxt-&gt;wellFormed)
 7070     return;
 7071     was_checked = ent-&gt;checked;
 7072 
 7073     /* special case of predefined entities */
 7074     if ((ent-&gt;name == NULL) ||
 7075         (ent-&gt;etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
 7076     val = ent-&gt;content;
 7077     if (val == NULL) return;
 7078     /*
 7079      * inline the entity.
 7080      */
 7081     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;characters != NULL) &amp;&amp;
 7082         (!ctxt-&gt;disableSAX))
 7083         ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, val, xmlStrlen(val));
 7084     return;
 7085     }
 7086 
 7087     /*
 7088      * The first reference to the entity trigger a parsing phase
 7089      * where the ent-&gt;children is filled with the result from
 7090      * the parsing.
 7091      * Note: external parsed entities will not be loaded, it is not
 7092      * required for a non-validating parser, unless the parsing option
 7093      * of validating, or substituting entities were given. Doing so is
 7094      * far more secure as the parser will only process data coming from
 7095      * the document entity by default.
 7096      */
 7097     if (((ent-&gt;checked == 0) ||
 7098          ((ent-&gt;children == NULL) &amp;&amp; (ctxt-&gt;options &amp; XML_PARSE_NOENT))) &amp;&amp;
 7099         ((ent-&gt;etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
 7100          (ctxt-&gt;options &amp; (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {
 7101     unsigned long oldnbent = ctxt-&gt;nbentities, diff;
 7102 
 7103     /*
 7104      * This is a bit hackish but this seems the best
 7105      * way to make sure both SAX and DOM entity support
 7106      * behaves okay.
 7107      */
 7108     void *user_data;
 7109     if (ctxt-&gt;userData == ctxt)
 7110         user_data = NULL;
 7111     else
 7112         user_data = ctxt-&gt;userData;
 7113 
 7114     /*
 7115      * Check that this entity is well formed
 7116      * 4.3.2: An internal general parsed entity is well-formed
 7117      * if its replacement text matches the production labeled
 7118      * content.
 7119      */
 7120     if (ent-&gt;etype == XML_INTERNAL_GENERAL_ENTITY) {
 7121         ctxt-&gt;depth++;
 7122         ret = xmlParseBalancedChunkMemoryInternal(ctxt, ent-&gt;content,
 7123                                                   user_data, &amp;list);
 7124         ctxt-&gt;depth--;
 7125 
 7126     } else if (ent-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
 7127         ctxt-&gt;depth++;
 7128         ret = xmlParseExternalEntityPrivate(ctxt-&gt;myDoc, ctxt, ctxt-&gt;sax,
 7129                                        user_data, ctxt-&gt;depth, ent-&gt;URI,
 7130                        ent-&gt;ExternalID, &amp;list);
 7131         ctxt-&gt;depth--;
 7132     } else {
 7133         ret = XML_ERR_ENTITY_PE_INTERNAL;
 7134         xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,
 7135              &quot;invalid entity type found\n&quot;, NULL);
 7136     }
 7137 
 7138     /*
 7139      * Store the number of entities needing parsing for this entity
 7140      * content and do checkings
 7141      */
 7142         diff = ctxt-&gt;nbentities - oldnbent + 1;
 7143         if (diff &gt; INT_MAX / 2)
 7144             diff = INT_MAX / 2;
 7145         ent-&gt;checked = diff * 2;
 7146     if ((ent-&gt;content != NULL) &amp;&amp; (xmlStrchr(ent-&gt;content, &#39;&lt;&#39;)))
 7147         ent-&gt;checked |= 1;
 7148     if (ret == XML_ERR_ENTITY_LOOP) {
 7149         xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 7150         xmlFreeNodeList(list);
 7151         return;
 7152     }
 7153     if (xmlParserEntityCheck(ctxt, 0, ent, 0)) {
 7154         xmlFreeNodeList(list);
 7155         return;
 7156     }
 7157 
 7158     if ((ret == XML_ERR_OK) &amp;&amp; (list != NULL)) {
 7159         if (((ent-&gt;etype == XML_INTERNAL_GENERAL_ENTITY) ||
 7160          (ent-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY))&amp;&amp;
 7161         (ent-&gt;children == NULL)) {
 7162         ent-&gt;children = list;
 7163         if (ctxt-&gt;replaceEntities) {
 7164             /*
 7165              * Prune it directly in the generated document
 7166              * except for single text nodes.
 7167              */
 7168             if (((list-&gt;type == XML_TEXT_NODE) &amp;&amp;
 7169              (list-&gt;next == NULL)) ||
 7170             (ctxt-&gt;parseMode == XML_PARSE_READER)) {
 7171             list-&gt;parent = (xmlNodePtr) ent;
 7172             list = NULL;
 7173             ent-&gt;owner = 1;
 7174             } else {
 7175             ent-&gt;owner = 0;
 7176             while (list != NULL) {
 7177                 list-&gt;parent = (xmlNodePtr) ctxt-&gt;node;
 7178                 list-&gt;doc = ctxt-&gt;myDoc;
 7179                 if (list-&gt;next == NULL)
 7180                 ent-&gt;last = list;
 7181                 list = list-&gt;next;
 7182             }
 7183             list = ent-&gt;children;
 7184 #ifdef LIBXML_LEGACY_ENABLED
 7185             if (ent-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
 7186               xmlAddEntityReference(ent, list, NULL);
 7187 #endif /* LIBXML_LEGACY_ENABLED */
 7188             }
 7189         } else {
 7190             ent-&gt;owner = 1;
 7191             while (list != NULL) {
 7192             list-&gt;parent = (xmlNodePtr) ent;
 7193             xmlSetTreeDoc(list, ent-&gt;doc);
 7194             if (list-&gt;next == NULL)
 7195                 ent-&gt;last = list;
 7196             list = list-&gt;next;
 7197             }
 7198         }
 7199         } else {
 7200         xmlFreeNodeList(list);
 7201         list = NULL;
 7202         }
 7203     } else if ((ret != XML_ERR_OK) &amp;&amp;
 7204            (ret != XML_WAR_UNDECLARED_ENTITY)) {
 7205         xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 7206              &quot;Entity &#39;%s&#39; failed to parse\n&quot;, ent-&gt;name);
 7207             if (ent-&gt;content != NULL)
 7208                 ent-&gt;content[0] = 0;
 7209         xmlParserEntityCheck(ctxt, 0, ent, 0);
 7210     } else if (list != NULL) {
 7211         xmlFreeNodeList(list);
 7212         list = NULL;
 7213     }
 7214     if (ent-&gt;checked == 0)
 7215         ent-&gt;checked = 2;
 7216 
 7217         /* Prevent entity from being parsed and expanded twice (Bug 760367). */
 7218         was_checked = 0;
 7219     } else if (ent-&gt;checked != 1) {
 7220     ctxt-&gt;nbentities += ent-&gt;checked / 2;
 7221     }
 7222 
 7223     /*
 7224      * Now that the entity content has been gathered
 7225      * provide it to the application, this can take different forms based
 7226      * on the parsing modes.
 7227      */
 7228     if (ent-&gt;children == NULL) {
 7229     /*
 7230      * Probably running in SAX mode and the callbacks don&#39;t
 7231      * build the entity content. So unless we already went
 7232      * though parsing for first checking go though the entity
 7233      * content to generate callbacks associated to the entity
 7234      */
 7235     if (was_checked != 0) {
 7236         void *user_data;
 7237         /*
 7238          * This is a bit hackish but this seems the best
 7239          * way to make sure both SAX and DOM entity support
 7240          * behaves okay.
 7241          */
 7242         if (ctxt-&gt;userData == ctxt)
 7243         user_data = NULL;
 7244         else
 7245         user_data = ctxt-&gt;userData;
 7246 
 7247         if (ent-&gt;etype == XML_INTERNAL_GENERAL_ENTITY) {
 7248         ctxt-&gt;depth++;
 7249         ret = xmlParseBalancedChunkMemoryInternal(ctxt,
 7250                    ent-&gt;content, user_data, NULL);
 7251         ctxt-&gt;depth--;
 7252         } else if (ent-&gt;etype ==
 7253                XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
 7254         ctxt-&gt;depth++;
 7255         ret = xmlParseExternalEntityPrivate(ctxt-&gt;myDoc, ctxt,
 7256                ctxt-&gt;sax, user_data, ctxt-&gt;depth,
 7257                ent-&gt;URI, ent-&gt;ExternalID, NULL);
 7258         ctxt-&gt;depth--;
 7259         } else {
 7260         ret = XML_ERR_ENTITY_PE_INTERNAL;
 7261         xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,
 7262                  &quot;invalid entity type found\n&quot;, NULL);
 7263         }
 7264         if (ret == XML_ERR_ENTITY_LOOP) {
 7265         xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 7266         return;
 7267         }
 7268     }
 7269     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;reference != NULL) &amp;&amp;
 7270         (ctxt-&gt;replaceEntities == 0) &amp;&amp; (!ctxt-&gt;disableSAX)) {
 7271         /*
 7272          * Entity reference callback comes second, it&#39;s somewhat
 7273          * superfluous but a compatibility to historical behaviour
 7274          */
 7275         ctxt-&gt;sax-&gt;reference(ctxt-&gt;userData, ent-&gt;name);
 7276     }
 7277     return;
 7278     }
 7279 
 7280     /*
 7281      * If we didn&#39;t get any children for the entity being built
 7282      */
 7283     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;reference != NULL) &amp;&amp;
 7284     (ctxt-&gt;replaceEntities == 0) &amp;&amp; (!ctxt-&gt;disableSAX)) {
 7285     /*
 7286      * Create a node.
 7287      */
 7288     ctxt-&gt;sax-&gt;reference(ctxt-&gt;userData, ent-&gt;name);
 7289     return;
 7290     }
 7291 
 7292     if ((ctxt-&gt;replaceEntities) || (ent-&gt;children == NULL))  {
 7293     /*
 7294      * There is a problem on the handling of _private for entities
 7295      * (bug 155816): Should we copy the content of the field from
 7296      * the entity (possibly overwriting some value set by the user
 7297      * when a copy is created), should we leave it alone, or should
 7298      * we try to take care of different situations?  The problem
 7299      * is exacerbated by the usage of this field by the xmlReader.
 7300      * To fix this bug, we look at _private on the created node
 7301      * and, if it&#39;s NULL, we copy in whatever was in the entity.
 7302      * If it&#39;s not NULL we leave it alone.  This is somewhat of a
 7303      * hack - maybe we should have further tests to determine
 7304      * what to do.
 7305      */
 7306     if ((ctxt-&gt;node != NULL) &amp;&amp; (ent-&gt;children != NULL)) {
 7307         /*
 7308          * Seems we are generating the DOM content, do
 7309          * a simple tree copy for all references except the first
 7310          * In the first occurrence list contains the replacement.
 7311          */
 7312         if (((list == NULL) &amp;&amp; (ent-&gt;owner == 0)) ||
 7313         (ctxt-&gt;parseMode == XML_PARSE_READER)) {
 7314         xmlNodePtr nw = NULL, cur, firstChild = NULL;
 7315 
 7316         /*
 7317          * We are copying here, make sure there is no abuse
 7318          */
 7319         ctxt-&gt;sizeentcopy += ent-&gt;length + 5;
 7320         if (xmlParserEntityCheck(ctxt, 0, ent, ctxt-&gt;sizeentcopy))
 7321             return;
 7322 
 7323         /*
 7324          * when operating on a reader, the entities definitions
 7325          * are always owning the entities subtree.
 7326         if (ctxt-&gt;parseMode == XML_PARSE_READER)
 7327             ent-&gt;owner = 1;
 7328          */
 7329 
 7330         cur = ent-&gt;children;
 7331         while (cur != NULL) {
 7332             nw = xmlDocCopyNode(cur, ctxt-&gt;myDoc, 1);
 7333             if (nw != NULL) {
 7334             if (nw-&gt;_private == NULL)
 7335                 nw-&gt;_private = cur-&gt;_private;
 7336             if (firstChild == NULL){
 7337                 firstChild = nw;
 7338             }
 7339             nw = xmlAddChild(ctxt-&gt;node, nw);
 7340             }
 7341             if (cur == ent-&gt;last) {
 7342             /*
 7343              * needed to detect some strange empty
 7344              * node cases in the reader tests
 7345              */
 7346             if ((ctxt-&gt;parseMode == XML_PARSE_READER) &amp;&amp;
 7347                 (nw != NULL) &amp;&amp;
 7348                 (nw-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
 7349                 (nw-&gt;children == NULL))
 7350                 nw-&gt;extra = 1;
 7351 
 7352             break;
 7353             }
 7354             cur = cur-&gt;next;
 7355         }
 7356 #ifdef LIBXML_LEGACY_ENABLED
 7357         if (ent-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
 7358           xmlAddEntityReference(ent, firstChild, nw);
 7359 #endif /* LIBXML_LEGACY_ENABLED */
 7360         } else if ((list == NULL) || (ctxt-&gt;inputNr &gt; 0)) {
 7361         xmlNodePtr nw = NULL, cur, next, last,
 7362                firstChild = NULL;
 7363 
 7364         /*
 7365          * We are copying here, make sure there is no abuse
 7366          */
 7367         ctxt-&gt;sizeentcopy += ent-&gt;length + 5;
 7368         if (xmlParserEntityCheck(ctxt, 0, ent, ctxt-&gt;sizeentcopy))
 7369             return;
 7370 
 7371         /*
 7372          * Copy the entity child list and make it the new
 7373          * entity child list. The goal is to make sure any
 7374          * ID or REF referenced will be the one from the
 7375          * document content and not the entity copy.
 7376          */
 7377         cur = ent-&gt;children;
 7378         ent-&gt;children = NULL;
 7379         last = ent-&gt;last;
 7380         ent-&gt;last = NULL;
 7381         while (cur != NULL) {
 7382             next = cur-&gt;next;
 7383             cur-&gt;next = NULL;
 7384             cur-&gt;parent = NULL;
 7385             nw = xmlDocCopyNode(cur, ctxt-&gt;myDoc, 1);
 7386             if (nw != NULL) {
 7387             if (nw-&gt;_private == NULL)
 7388                 nw-&gt;_private = cur-&gt;_private;
 7389             if (firstChild == NULL){
 7390                 firstChild = cur;
 7391             }
 7392             xmlAddChild((xmlNodePtr) ent, nw);
 7393             xmlAddChild(ctxt-&gt;node, cur);
 7394             }
 7395             if (cur == last)
 7396             break;
 7397             cur = next;
 7398         }
 7399         if (ent-&gt;owner == 0)
 7400             ent-&gt;owner = 1;
 7401 #ifdef LIBXML_LEGACY_ENABLED
 7402         if (ent-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
 7403           xmlAddEntityReference(ent, firstChild, nw);
 7404 #endif /* LIBXML_LEGACY_ENABLED */
 7405         } else {
 7406         const xmlChar *nbktext;
 7407 
 7408         /*
 7409          * the name change is to avoid coalescing of the
 7410          * node with a possible previous text one which
 7411          * would make ent-&gt;children a dangling pointer
 7412          */
 7413         nbktext = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;nbktext&quot;,
 7414                     -1);
 7415         if (ent-&gt;children-&gt;type == XML_TEXT_NODE)
 7416             ent-&gt;children-&gt;name = nbktext;
 7417         if ((ent-&gt;last != ent-&gt;children) &amp;&amp;
 7418             (ent-&gt;last-&gt;type == XML_TEXT_NODE))
 7419             ent-&gt;last-&gt;name = nbktext;
 7420         xmlAddChildList(ctxt-&gt;node, ent-&gt;children);
 7421         }
 7422 
 7423         /*
 7424          * This is to avoid a nasty side effect, see
 7425          * characters() in SAX.c
 7426          */
 7427         ctxt-&gt;nodemem = 0;
 7428         ctxt-&gt;nodelen = 0;
 7429         return;
 7430     }
 7431     }
 7432 }
 7433 
 7434 /**
 7435  * xmlParseEntityRef:
 7436  * @ctxt:  an XML parser context
 7437  *
 7438  * parse ENTITY references declarations
 7439  *
 7440  * [68] EntityRef ::= &#39;&amp;&#39; Name &#39;;&#39;
 7441  *
 7442  * [ WFC: Entity Declared ]
 7443  * In a document without any DTD, a document with only an internal DTD
 7444  * subset which contains no parameter entity references, or a document
 7445  * with &quot;standalone=&#39;yes&#39;&quot;, the Name given in the entity reference
 7446  * must match that in an entity declaration, except that well-formed
 7447  * documents need not declare any of the following entities: amp, lt,
 7448  * gt, apos, quot.  The declaration of a parameter entity must precede
 7449  * any reference to it.  Similarly, the declaration of a general entity
 7450  * must precede any reference to it which appears in a default value in an
 7451  * attribute-list declaration. Note that if entities are declared in the
 7452  * external subset or in external parameter entities, a non-validating
 7453  * processor is not obligated to read and process their declarations;
 7454  * for such documents, the rule that an entity must be declared is a
 7455  * well-formedness constraint only if standalone=&#39;yes&#39;.
 7456  *
 7457  * [ WFC: Parsed Entity ]
 7458  * An entity reference must not contain the name of an unparsed entity
 7459  *
 7460  * Returns the xmlEntityPtr if found, or NULL otherwise.
 7461  */
 7462 xmlEntityPtr
 7463 xmlParseEntityRef(xmlParserCtxtPtr ctxt) {
 7464     const xmlChar *name;
 7465     xmlEntityPtr ent = NULL;
 7466 
 7467     GROW;
 7468     if (ctxt-&gt;instate == XML_PARSER_EOF)
 7469         return(NULL);
 7470 
 7471     if (RAW != &#39;&amp;&#39;)
 7472         return(NULL);
 7473     NEXT;
 7474     name = xmlParseName(ctxt);
 7475     if (name == NULL) {
 7476     xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 7477                &quot;xmlParseEntityRef: no name\n&quot;);
 7478         return(NULL);
 7479     }
 7480     if (RAW != &#39;;&#39;) {
 7481     xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
 7482     return(NULL);
 7483     }
 7484     NEXT;
 7485 
 7486     /*
 7487      * Predefined entities override any extra definition
 7488      */
 7489     if ((ctxt-&gt;options &amp; XML_PARSE_OLDSAX) == 0) {
 7490         ent = xmlGetPredefinedEntity(name);
 7491         if (ent != NULL)
 7492             return(ent);
 7493     }
 7494 
 7495     /*
 7496      * Increase the number of entity references parsed
 7497      */
 7498     ctxt-&gt;nbentities++;
 7499 
 7500     /*
 7501      * Ask first SAX for entity resolution, otherwise try the
 7502      * entities which may have stored in the parser context.
 7503      */
 7504     if (ctxt-&gt;sax != NULL) {
 7505     if (ctxt-&gt;sax-&gt;getEntity != NULL)
 7506         ent = ctxt-&gt;sax-&gt;getEntity(ctxt-&gt;userData, name);
 7507     if ((ctxt-&gt;wellFormed == 1 ) &amp;&amp; (ent == NULL) &amp;&amp;
 7508         (ctxt-&gt;options &amp; XML_PARSE_OLDSAX))
 7509         ent = xmlGetPredefinedEntity(name);
 7510     if ((ctxt-&gt;wellFormed == 1 ) &amp;&amp; (ent == NULL) &amp;&amp;
 7511         (ctxt-&gt;userData==ctxt)) {
 7512         ent = xmlSAX2GetEntity(ctxt, name);
 7513     }
 7514     }
 7515     if (ctxt-&gt;instate == XML_PARSER_EOF)
 7516     return(NULL);
 7517     /*
 7518      * [ WFC: Entity Declared ]
 7519      * In a document without any DTD, a document with only an
 7520      * internal DTD subset which contains no parameter entity
 7521      * references, or a document with &quot;standalone=&#39;yes&#39;&quot;, the
 7522      * Name given in the entity reference must match that in an
 7523      * entity declaration, except that well-formed documents
 7524      * need not declare any of the following entities: amp, lt,
 7525      * gt, apos, quot.
 7526      * The declaration of a parameter entity must precede any
 7527      * reference to it.
 7528      * Similarly, the declaration of a general entity must
 7529      * precede any reference to it which appears in a default
 7530      * value in an attribute-list declaration. Note that if
 7531      * entities are declared in the external subset or in
 7532      * external parameter entities, a non-validating processor
 7533      * is not obligated to read and process their declarations;
 7534      * for such documents, the rule that an entity must be
 7535      * declared is a well-formedness constraint only if
 7536      * standalone=&#39;yes&#39;.
 7537      */
 7538     if (ent == NULL) {
 7539     if ((ctxt-&gt;standalone == 1) ||
 7540         ((ctxt-&gt;hasExternalSubset == 0) &amp;&amp;
 7541          (ctxt-&gt;hasPErefs == 0))) {
 7542         xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 7543              &quot;Entity &#39;%s&#39; not defined\n&quot;, name);
 7544     } else {
 7545         xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,
 7546              &quot;Entity &#39;%s&#39; not defined\n&quot;, name);
 7547         if ((ctxt-&gt;inSubset == 0) &amp;&amp;
 7548         (ctxt-&gt;sax != NULL) &amp;&amp;
 7549         (ctxt-&gt;sax-&gt;reference != NULL)) {
 7550         ctxt-&gt;sax-&gt;reference(ctxt-&gt;userData, name);
 7551         }
 7552     }
 7553     xmlParserEntityCheck(ctxt, 0, ent, 0);
 7554     ctxt-&gt;valid = 0;
 7555     }
 7556 
 7557     /*
 7558      * [ WFC: Parsed Entity ]
 7559      * An entity reference must not contain the name of an
 7560      * unparsed entity
 7561      */
 7562     else if (ent-&gt;etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {
 7563     xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,
 7564          &quot;Entity reference to unparsed entity %s\n&quot;, name);
 7565     }
 7566 
 7567     /*
 7568      * [ WFC: No External Entity References ]
 7569      * Attribute values cannot contain direct or indirect
 7570      * entity references to external entities.
 7571      */
 7572     else if ((ctxt-&gt;instate == XML_PARSER_ATTRIBUTE_VALUE) &amp;&amp;
 7573          (ent-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {
 7574     xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,
 7575          &quot;Attribute references external entity &#39;%s&#39;\n&quot;, name);
 7576     }
 7577     /*
 7578      * [ WFC: No &lt; in Attribute Values ]
 7579      * The replacement text of any entity referred to directly or
 7580      * indirectly in an attribute value (other than &quot;&amp;lt;&quot;) must
 7581      * not contain a &lt;.
 7582      */
 7583     else if ((ctxt-&gt;instate == XML_PARSER_ATTRIBUTE_VALUE) &amp;&amp;
 7584          (ent != NULL) &amp;&amp;
 7585          (ent-&gt;etype != XML_INTERNAL_PREDEFINED_ENTITY)) {
 7586     if (((ent-&gt;checked &amp; 1) || (ent-&gt;checked == 0)) &amp;&amp;
 7587          (ent-&gt;content != NULL) &amp;&amp; (xmlStrchr(ent-&gt;content, &#39;&lt;&#39;))) {
 7588         xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,
 7589     &quot;&#39;&lt;&#39; in entity &#39;%s&#39; is not allowed in attributes values\n&quot;, name);
 7590         }
 7591     }
 7592 
 7593     /*
 7594      * Internal check, no parameter entities here ...
 7595      */
 7596     else {
 7597     switch (ent-&gt;etype) {
 7598         case XML_INTERNAL_PARAMETER_ENTITY:
 7599         case XML_EXTERNAL_PARAMETER_ENTITY:
 7600         xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,
 7601          &quot;Attempt to reference the parameter entity &#39;%s&#39;\n&quot;,
 7602                   name);
 7603         break;
 7604         default:
 7605         break;
 7606     }
 7607     }
 7608 
 7609     /*
 7610      * [ WFC: No Recursion ]
 7611      * A parsed entity must not contain a recursive reference
 7612      * to itself, either directly or indirectly.
 7613      * Done somewhere else
 7614      */
 7615     return(ent);
 7616 }
 7617 
 7618 /**
 7619  * xmlParseStringEntityRef:
 7620  * @ctxt:  an XML parser context
 7621  * @str:  a pointer to an index in the string
 7622  *
 7623  * parse ENTITY references declarations, but this version parses it from
 7624  * a string value.
 7625  *
 7626  * [68] EntityRef ::= &#39;&amp;&#39; Name &#39;;&#39;
 7627  *
 7628  * [ WFC: Entity Declared ]
 7629  * In a document without any DTD, a document with only an internal DTD
 7630  * subset which contains no parameter entity references, or a document
 7631  * with &quot;standalone=&#39;yes&#39;&quot;, the Name given in the entity reference
 7632  * must match that in an entity declaration, except that well-formed
 7633  * documents need not declare any of the following entities: amp, lt,
 7634  * gt, apos, quot.  The declaration of a parameter entity must precede
 7635  * any reference to it.  Similarly, the declaration of a general entity
 7636  * must precede any reference to it which appears in a default value in an
 7637  * attribute-list declaration. Note that if entities are declared in the
 7638  * external subset or in external parameter entities, a non-validating
 7639  * processor is not obligated to read and process their declarations;
 7640  * for such documents, the rule that an entity must be declared is a
 7641  * well-formedness constraint only if standalone=&#39;yes&#39;.
 7642  *
 7643  * [ WFC: Parsed Entity ]
 7644  * An entity reference must not contain the name of an unparsed entity
 7645  *
 7646  * Returns the xmlEntityPtr if found, or NULL otherwise. The str pointer
 7647  * is updated to the current location in the string.
 7648  */
 7649 static xmlEntityPtr
 7650 xmlParseStringEntityRef(xmlParserCtxtPtr ctxt, const xmlChar ** str) {
 7651     xmlChar *name;
 7652     const xmlChar *ptr;
 7653     xmlChar cur;
 7654     xmlEntityPtr ent = NULL;
 7655 
 7656     if ((str == NULL) || (*str == NULL))
 7657         return(NULL);
 7658     ptr = *str;
 7659     cur = *ptr;
 7660     if (cur != &#39;&amp;&#39;)
 7661     return(NULL);
 7662 
 7663     ptr++;
 7664     name = xmlParseStringName(ctxt, &amp;ptr);
 7665     if (name == NULL) {
 7666     xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 7667                &quot;xmlParseStringEntityRef: no name\n&quot;);
 7668     *str = ptr;
 7669     return(NULL);
 7670     }
 7671     if (*ptr != &#39;;&#39;) {
 7672     xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
 7673         xmlFree(name);
 7674     *str = ptr;
 7675     return(NULL);
 7676     }
 7677     ptr++;
 7678 
 7679 
 7680     /*
 7681      * Predefined entities override any extra definition
 7682      */
 7683     if ((ctxt-&gt;options &amp; XML_PARSE_OLDSAX) == 0) {
 7684         ent = xmlGetPredefinedEntity(name);
 7685         if (ent != NULL) {
 7686             xmlFree(name);
 7687             *str = ptr;
 7688             return(ent);
 7689         }
 7690     }
 7691 
 7692     /*
 7693      * Increase the number of entity references parsed
 7694      */
 7695     ctxt-&gt;nbentities++;
 7696 
 7697     /*
 7698      * Ask first SAX for entity resolution, otherwise try the
 7699      * entities which may have stored in the parser context.
 7700      */
 7701     if (ctxt-&gt;sax != NULL) {
 7702     if (ctxt-&gt;sax-&gt;getEntity != NULL)
 7703         ent = ctxt-&gt;sax-&gt;getEntity(ctxt-&gt;userData, name);
 7704     if ((ent == NULL) &amp;&amp; (ctxt-&gt;options &amp; XML_PARSE_OLDSAX))
 7705         ent = xmlGetPredefinedEntity(name);
 7706     if ((ent == NULL) &amp;&amp; (ctxt-&gt;userData==ctxt)) {
 7707         ent = xmlSAX2GetEntity(ctxt, name);
 7708     }
 7709     }
 7710     if (ctxt-&gt;instate == XML_PARSER_EOF) {
 7711     xmlFree(name);
 7712     return(NULL);
 7713     }
 7714 
 7715     /*
 7716      * [ WFC: Entity Declared ]
 7717      * In a document without any DTD, a document with only an
 7718      * internal DTD subset which contains no parameter entity
 7719      * references, or a document with &quot;standalone=&#39;yes&#39;&quot;, the
 7720      * Name given in the entity reference must match that in an
 7721      * entity declaration, except that well-formed documents
 7722      * need not declare any of the following entities: amp, lt,
 7723      * gt, apos, quot.
 7724      * The declaration of a parameter entity must precede any
 7725      * reference to it.
 7726      * Similarly, the declaration of a general entity must
 7727      * precede any reference to it which appears in a default
 7728      * value in an attribute-list declaration. Note that if
 7729      * entities are declared in the external subset or in
 7730      * external parameter entities, a non-validating processor
 7731      * is not obligated to read and process their declarations;
 7732      * for such documents, the rule that an entity must be
 7733      * declared is a well-formedness constraint only if
 7734      * standalone=&#39;yes&#39;.
 7735      */
 7736     if (ent == NULL) {
 7737     if ((ctxt-&gt;standalone == 1) ||
 7738         ((ctxt-&gt;hasExternalSubset == 0) &amp;&amp;
 7739          (ctxt-&gt;hasPErefs == 0))) {
 7740         xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 7741              &quot;Entity &#39;%s&#39; not defined\n&quot;, name);
 7742     } else {
 7743         xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,
 7744               &quot;Entity &#39;%s&#39; not defined\n&quot;,
 7745               name);
 7746     }
 7747     xmlParserEntityCheck(ctxt, 0, ent, 0);
 7748     /* TODO ? check regressions ctxt-&gt;valid = 0; */
 7749     }
 7750 
 7751     /*
 7752      * [ WFC: Parsed Entity ]
 7753      * An entity reference must not contain the name of an
 7754      * unparsed entity
 7755      */
 7756     else if (ent-&gt;etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {
 7757     xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,
 7758          &quot;Entity reference to unparsed entity %s\n&quot;, name);
 7759     }
 7760 
 7761     /*
 7762      * [ WFC: No External Entity References ]
 7763      * Attribute values cannot contain direct or indirect
 7764      * entity references to external entities.
 7765      */
 7766     else if ((ctxt-&gt;instate == XML_PARSER_ATTRIBUTE_VALUE) &amp;&amp;
 7767          (ent-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {
 7768     xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,
 7769      &quot;Attribute references external entity &#39;%s&#39;\n&quot;, name);
 7770     }
 7771     /*
 7772      * [ WFC: No &lt; in Attribute Values ]
 7773      * The replacement text of any entity referred to directly or
 7774      * indirectly in an attribute value (other than &quot;&amp;lt;&quot;) must
 7775      * not contain a &lt;.
 7776      */
 7777     else if ((ctxt-&gt;instate == XML_PARSER_ATTRIBUTE_VALUE) &amp;&amp;
 7778          (ent != NULL) &amp;&amp; (ent-&gt;content != NULL) &amp;&amp;
 7779          (ent-&gt;etype != XML_INTERNAL_PREDEFINED_ENTITY) &amp;&amp;
 7780          (xmlStrchr(ent-&gt;content, &#39;&lt;&#39;))) {
 7781     xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,
 7782      &quot;&#39;&lt;&#39; in entity &#39;%s&#39; is not allowed in attributes values\n&quot;,
 7783               name);
 7784     }
 7785 
 7786     /*
 7787      * Internal check, no parameter entities here ...
 7788      */
 7789     else {
 7790     switch (ent-&gt;etype) {
 7791         case XML_INTERNAL_PARAMETER_ENTITY:
 7792         case XML_EXTERNAL_PARAMETER_ENTITY:
 7793         xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,
 7794          &quot;Attempt to reference the parameter entity &#39;%s&#39;\n&quot;,
 7795                   name);
 7796         break;
 7797         default:
 7798         break;
 7799     }
 7800     }
 7801 
 7802     /*
 7803      * [ WFC: No Recursion ]
 7804      * A parsed entity must not contain a recursive reference
 7805      * to itself, either directly or indirectly.
 7806      * Done somewhere else
 7807      */
 7808 
 7809     xmlFree(name);
 7810     *str = ptr;
 7811     return(ent);
 7812 }
 7813 
 7814 /**
 7815  * xmlParsePEReference:
 7816  * @ctxt:  an XML parser context
 7817  *
 7818  * parse PEReference declarations
 7819  * The entity content is handled directly by pushing it&#39;s content as
 7820  * a new input stream.
 7821  *
 7822  * [69] PEReference ::= &#39;%&#39; Name &#39;;&#39;
 7823  *
 7824  * [ WFC: No Recursion ]
 7825  * A parsed entity must not contain a recursive
 7826  * reference to itself, either directly or indirectly.
 7827  *
 7828  * [ WFC: Entity Declared ]
 7829  * In a document without any DTD, a document with only an internal DTD
 7830  * subset which contains no parameter entity references, or a document
 7831  * with &quot;standalone=&#39;yes&#39;&quot;, ...  ... The declaration of a parameter
 7832  * entity must precede any reference to it...
 7833  *
 7834  * [ VC: Entity Declared ]
 7835  * In a document with an external subset or external parameter entities
 7836  * with &quot;standalone=&#39;no&#39;&quot;, ...  ... The declaration of a parameter entity
 7837  * must precede any reference to it...
 7838  *
 7839  * [ WFC: In DTD ]
 7840  * Parameter-entity references may only appear in the DTD.
 7841  * NOTE: misleading but this is handled.
 7842  */
 7843 void
 7844 xmlParsePEReference(xmlParserCtxtPtr ctxt)
 7845 {
 7846     const xmlChar *name;
 7847     xmlEntityPtr entity = NULL;
 7848     xmlParserInputPtr input;
 7849 
 7850     if (RAW != &#39;%&#39;)
 7851         return;
 7852     NEXT;
 7853     name = xmlParseName(ctxt);
 7854     if (name == NULL) {
 7855     xmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, &quot;PEReference: no name\n&quot;);
 7856     return;
 7857     }
 7858     if (xmlParserDebugEntities)
 7859     xmlGenericError(xmlGenericErrorContext,
 7860         &quot;PEReference: %s\n&quot;, name);
 7861     if (RAW != &#39;;&#39;) {
 7862     xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);
 7863         return;
 7864     }
 7865 
 7866     NEXT;
 7867 
 7868     /*
 7869      * Increase the number of entity references parsed
 7870      */
 7871     ctxt-&gt;nbentities++;
 7872 
 7873     /*
 7874      * Request the entity from SAX
 7875      */
 7876     if ((ctxt-&gt;sax != NULL) &amp;&amp;
 7877     (ctxt-&gt;sax-&gt;getParameterEntity != NULL))
 7878     entity = ctxt-&gt;sax-&gt;getParameterEntity(ctxt-&gt;userData, name);
 7879     if (ctxt-&gt;instate == XML_PARSER_EOF)
 7880     return;
 7881     if (entity == NULL) {
 7882     /*
 7883      * [ WFC: Entity Declared ]
 7884      * In a document without any DTD, a document with only an
 7885      * internal DTD subset which contains no parameter entity
 7886      * references, or a document with &quot;standalone=&#39;yes&#39;&quot;, ...
 7887      * ... The declaration of a parameter entity must precede
 7888      * any reference to it...
 7889      */
 7890     if ((ctxt-&gt;standalone == 1) ||
 7891         ((ctxt-&gt;hasExternalSubset == 0) &amp;&amp;
 7892          (ctxt-&gt;hasPErefs == 0))) {
 7893         xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 7894                   &quot;PEReference: %%%s; not found\n&quot;,
 7895                   name);
 7896     } else {
 7897         /*
 7898          * [ VC: Entity Declared ]
 7899          * In a document with an external subset or external
 7900          * parameter entities with &quot;standalone=&#39;no&#39;&quot;, ...
 7901          * ... The declaration of a parameter entity must
 7902          * precede any reference to it...
 7903          */
 7904             if ((ctxt-&gt;validate) &amp;&amp; (ctxt-&gt;vctxt.error != NULL)) {
 7905                 xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY,
 7906                                  &quot;PEReference: %%%s; not found\n&quot;,
 7907                                  name, NULL);
 7908             } else
 7909                 xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
 7910                               &quot;PEReference: %%%s; not found\n&quot;,
 7911                               name, NULL);
 7912             ctxt-&gt;valid = 0;
 7913     }
 7914     xmlParserEntityCheck(ctxt, 0, NULL, 0);
 7915     } else {
 7916     /*
 7917      * Internal checking in case the entity quest barfed
 7918      */
 7919     if ((entity-&gt;etype != XML_INTERNAL_PARAMETER_ENTITY) &amp;&amp;
 7920         (entity-&gt;etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
 7921         xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
 7922           &quot;Internal: %%%s; is not a parameter entity\n&quot;,
 7923               name, NULL);
 7924     } else {
 7925             xmlChar start[4];
 7926             xmlCharEncoding enc;
 7927 
 7928         if ((entity-&gt;etype == XML_EXTERNAL_PARAMETER_ENTITY) &amp;&amp;
 7929             ((ctxt-&gt;options &amp; XML_PARSE_NOENT) == 0) &amp;&amp;
 7930         ((ctxt-&gt;options &amp; XML_PARSE_DTDVALID) == 0) &amp;&amp;
 7931         ((ctxt-&gt;options &amp; XML_PARSE_DTDLOAD) == 0) &amp;&amp;
 7932         ((ctxt-&gt;options &amp; XML_PARSE_DTDATTR) == 0) &amp;&amp;
 7933         (ctxt-&gt;replaceEntities == 0) &amp;&amp;
 7934         (ctxt-&gt;validate == 0))
 7935         return;
 7936 
 7937         input = xmlNewEntityInputStream(ctxt, entity);
 7938         if (xmlPushInput(ctxt, input) &lt; 0) {
 7939                 xmlFreeInputStream(input);
 7940         return;
 7941             }
 7942 
 7943         if (entity-&gt;etype == XML_EXTERNAL_PARAMETER_ENTITY) {
 7944                 /*
 7945                  * Get the 4 first bytes and decode the charset
 7946                  * if enc != XML_CHAR_ENCODING_NONE
 7947                  * plug some encoding conversion routines.
 7948                  * Note that, since we may have some non-UTF8
 7949                  * encoding (like UTF16, bug 135229), the &#39;length&#39;
 7950                  * is not known, but we can calculate based upon
 7951                  * the amount of data in the buffer.
 7952                  */
 7953                 GROW
 7954                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 7955                     return;
 7956                 if ((ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur)&gt;=4) {
 7957                     start[0] = RAW;
 7958                     start[1] = NXT(1);
 7959                     start[2] = NXT(2);
 7960                     start[3] = NXT(3);
 7961                     enc = xmlDetectCharEncoding(start, 4);
 7962                     if (enc != XML_CHAR_ENCODING_NONE) {
 7963                         xmlSwitchEncoding(ctxt, enc);
 7964                     }
 7965                 }
 7966 
 7967                 if ((CMP5(CUR_PTR, &#39;&lt;&#39;, &#39;?&#39;, &#39;x&#39;, &#39;m&#39;, &#39;l&#39;)) &amp;&amp;
 7968                     (IS_BLANK_CH(NXT(5)))) {
 7969                     xmlParseTextDecl(ctxt);
 7970                 }
 7971             }
 7972     }
 7973     }
 7974     ctxt-&gt;hasPErefs = 1;
 7975 }
 7976 
 7977 /**
 7978  * xmlLoadEntityContent:
 7979  * @ctxt:  an XML parser context
 7980  * @entity: an unloaded system entity
 7981  *
 7982  * Load the original content of the given system entity from the
 7983  * ExternalID/SystemID given. This is to be used for Included in Literal
 7984  * http://www.w3.org/TR/REC-xml/#inliteral processing of entities references
 7985  *
 7986  * Returns 0 in case of success and -1 in case of failure
 7987  */
 7988 static int
 7989 xmlLoadEntityContent(xmlParserCtxtPtr ctxt, xmlEntityPtr entity) {
 7990     xmlParserInputPtr input;
 7991     xmlBufferPtr buf;
 7992     int l, c;
 7993     int count = 0;
 7994 
 7995     if ((ctxt == NULL) || (entity == NULL) ||
 7996         ((entity-&gt;etype != XML_EXTERNAL_PARAMETER_ENTITY) &amp;&amp;
 7997      (entity-&gt;etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY)) ||
 7998     (entity-&gt;content != NULL)) {
 7999     xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 8000                 &quot;xmlLoadEntityContent parameter error&quot;);
 8001         return(-1);
 8002     }
 8003 
 8004     if (xmlParserDebugEntities)
 8005     xmlGenericError(xmlGenericErrorContext,
 8006         &quot;Reading %s entity content input\n&quot;, entity-&gt;name);
 8007 
 8008     buf = xmlBufferCreate();
 8009     if (buf == NULL) {
 8010     xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 8011                 &quot;xmlLoadEntityContent parameter error&quot;);
 8012         return(-1);
 8013     }
 8014 
 8015     input = xmlNewEntityInputStream(ctxt, entity);
 8016     if (input == NULL) {
 8017     xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 8018                 &quot;xmlLoadEntityContent input error&quot;);
 8019     xmlBufferFree(buf);
 8020         return(-1);
 8021     }
 8022 
 8023     /*
 8024      * Push the entity as the current input, read char by char
 8025      * saving to the buffer until the end of the entity or an error
 8026      */
 8027     if (xmlPushInput(ctxt, input) &lt; 0) {
 8028         xmlBufferFree(buf);
 8029     return(-1);
 8030     }
 8031 
 8032     GROW;
 8033     c = CUR_CHAR(l);
 8034     while ((ctxt-&gt;input == input) &amp;&amp; (ctxt-&gt;input-&gt;cur &lt; ctxt-&gt;input-&gt;end) &amp;&amp;
 8035            (IS_CHAR(c))) {
 8036         xmlBufferAdd(buf, ctxt-&gt;input-&gt;cur, l);
 8037     if (count++ &gt; XML_PARSER_CHUNK_SIZE) {
 8038         count = 0;
 8039         GROW;
 8040             if (ctxt-&gt;instate == XML_PARSER_EOF) {
 8041                 xmlBufferFree(buf);
 8042                 return(-1);
 8043             }
 8044     }
 8045     NEXTL(l);
 8046     c = CUR_CHAR(l);
 8047     if (c == 0) {
 8048         count = 0;
 8049         GROW;
 8050             if (ctxt-&gt;instate == XML_PARSER_EOF) {
 8051                 xmlBufferFree(buf);
 8052                 return(-1);
 8053             }
 8054         c = CUR_CHAR(l);
 8055     }
 8056     }
 8057 
 8058     if ((ctxt-&gt;input == input) &amp;&amp; (ctxt-&gt;input-&gt;cur &gt;= ctxt-&gt;input-&gt;end)) {
 8059         xmlPopInput(ctxt);
 8060     } else if (!IS_CHAR(c)) {
 8061         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 8062                           &quot;xmlLoadEntityContent: invalid char value %d\n&quot;,
 8063                       c);
 8064     xmlBufferFree(buf);
 8065     return(-1);
 8066     }
 8067     entity-&gt;content = buf-&gt;content;
 8068     buf-&gt;content = NULL;
 8069     xmlBufferFree(buf);
 8070 
 8071     return(0);
 8072 }
 8073 
 8074 /**
 8075  * xmlParseStringPEReference:
 8076  * @ctxt:  an XML parser context
 8077  * @str:  a pointer to an index in the string
 8078  *
 8079  * parse PEReference declarations
 8080  *
 8081  * [69] PEReference ::= &#39;%&#39; Name &#39;;&#39;
 8082  *
 8083  * [ WFC: No Recursion ]
 8084  * A parsed entity must not contain a recursive
 8085  * reference to itself, either directly or indirectly.
 8086  *
 8087  * [ WFC: Entity Declared ]
 8088  * In a document without any DTD, a document with only an internal DTD
 8089  * subset which contains no parameter entity references, or a document
 8090  * with &quot;standalone=&#39;yes&#39;&quot;, ...  ... The declaration of a parameter
 8091  * entity must precede any reference to it...
 8092  *
 8093  * [ VC: Entity Declared ]
 8094  * In a document with an external subset or external parameter entities
 8095  * with &quot;standalone=&#39;no&#39;&quot;, ...  ... The declaration of a parameter entity
 8096  * must precede any reference to it...
 8097  *
 8098  * [ WFC: In DTD ]
 8099  * Parameter-entity references may only appear in the DTD.
 8100  * NOTE: misleading but this is handled.
 8101  *
 8102  * Returns the string of the entity content.
 8103  *         str is updated to the current value of the index
 8104  */
 8105 static xmlEntityPtr
 8106 xmlParseStringPEReference(xmlParserCtxtPtr ctxt, const xmlChar **str) {
 8107     const xmlChar *ptr;
 8108     xmlChar cur;
 8109     xmlChar *name;
 8110     xmlEntityPtr entity = NULL;
 8111 
 8112     if ((str == NULL) || (*str == NULL)) return(NULL);
 8113     ptr = *str;
 8114     cur = *ptr;
 8115     if (cur != &#39;%&#39;)
 8116         return(NULL);
 8117     ptr++;
 8118     name = xmlParseStringName(ctxt, &amp;ptr);
 8119     if (name == NULL) {
 8120     xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 8121                &quot;xmlParseStringPEReference: no name\n&quot;);
 8122     *str = ptr;
 8123     return(NULL);
 8124     }
 8125     cur = *ptr;
 8126     if (cur != &#39;;&#39;) {
 8127     xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
 8128     xmlFree(name);
 8129     *str = ptr;
 8130     return(NULL);
 8131     }
 8132     ptr++;
 8133 
 8134     /*
 8135      * Increase the number of entity references parsed
 8136      */
 8137     ctxt-&gt;nbentities++;
 8138 
 8139     /*
 8140      * Request the entity from SAX
 8141      */
 8142     if ((ctxt-&gt;sax != NULL) &amp;&amp;
 8143     (ctxt-&gt;sax-&gt;getParameterEntity != NULL))
 8144     entity = ctxt-&gt;sax-&gt;getParameterEntity(ctxt-&gt;userData, name);
 8145     if (ctxt-&gt;instate == XML_PARSER_EOF) {
 8146     xmlFree(name);
 8147     *str = ptr;
 8148     return(NULL);
 8149     }
 8150     if (entity == NULL) {
 8151     /*
 8152      * [ WFC: Entity Declared ]
 8153      * In a document without any DTD, a document with only an
 8154      * internal DTD subset which contains no parameter entity
 8155      * references, or a document with &quot;standalone=&#39;yes&#39;&quot;, ...
 8156      * ... The declaration of a parameter entity must precede
 8157      * any reference to it...
 8158      */
 8159     if ((ctxt-&gt;standalone == 1) ||
 8160         ((ctxt-&gt;hasExternalSubset == 0) &amp;&amp; (ctxt-&gt;hasPErefs == 0))) {
 8161         xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 8162          &quot;PEReference: %%%s; not found\n&quot;, name);
 8163     } else {
 8164         /*
 8165          * [ VC: Entity Declared ]
 8166          * In a document with an external subset or external
 8167          * parameter entities with &quot;standalone=&#39;no&#39;&quot;, ...
 8168          * ... The declaration of a parameter entity must
 8169          * precede any reference to it...
 8170          */
 8171         xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
 8172               &quot;PEReference: %%%s; not found\n&quot;,
 8173               name, NULL);
 8174         ctxt-&gt;valid = 0;
 8175     }
 8176     xmlParserEntityCheck(ctxt, 0, NULL, 0);
 8177     } else {
 8178     /*
 8179      * Internal checking in case the entity quest barfed
 8180      */
 8181     if ((entity-&gt;etype != XML_INTERNAL_PARAMETER_ENTITY) &amp;&amp;
 8182         (entity-&gt;etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
 8183         xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
 8184               &quot;%%%s; is not a parameter entity\n&quot;,
 8185               name, NULL);
 8186     }
 8187     }
 8188     ctxt-&gt;hasPErefs = 1;
 8189     xmlFree(name);
 8190     *str = ptr;
 8191     return(entity);
 8192 }
 8193 
 8194 /**
 8195  * xmlParseDocTypeDecl:
 8196  * @ctxt:  an XML parser context
 8197  *
 8198  * parse a DOCTYPE declaration
 8199  *
 8200  * [28] doctypedecl ::= &#39;&lt;!DOCTYPE&#39; S Name (S ExternalID)? S?
 8201  *                      (&#39;[&#39; (markupdecl | PEReference | S)* &#39;]&#39; S?)? &#39;&gt;&#39;
 8202  *
 8203  * [ VC: Root Element Type ]
 8204  * The Name in the document type declaration must match the element
 8205  * type of the root element.
 8206  */
 8207 
 8208 void
 8209 xmlParseDocTypeDecl(xmlParserCtxtPtr ctxt) {
 8210     const xmlChar *name = NULL;
 8211     xmlChar *ExternalID = NULL;
 8212     xmlChar *URI = NULL;
 8213 
 8214     /*
 8215      * We know that &#39;&lt;!DOCTYPE&#39; has been detected.
 8216      */
 8217     SKIP(9);
 8218 
 8219     SKIP_BLANKS;
 8220 
 8221     /*
 8222      * Parse the DOCTYPE name.
 8223      */
 8224     name = xmlParseName(ctxt);
 8225     if (name == NULL) {
 8226     xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 8227                &quot;xmlParseDocTypeDecl : no DOCTYPE name !\n&quot;);
 8228     }
 8229     ctxt-&gt;intSubName = name;
 8230 
 8231     SKIP_BLANKS;
 8232 
 8233     /*
 8234      * Check for SystemID and ExternalID
 8235      */
 8236     URI = xmlParseExternalID(ctxt, &amp;ExternalID, 1);
 8237 
 8238     if ((URI != NULL) || (ExternalID != NULL)) {
 8239         ctxt-&gt;hasExternalSubset = 1;
 8240     }
 8241     ctxt-&gt;extSubURI = URI;
 8242     ctxt-&gt;extSubSystem = ExternalID;
 8243 
 8244     SKIP_BLANKS;
 8245 
 8246     /*
 8247      * Create and update the internal subset.
 8248      */
 8249     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;internalSubset != NULL) &amp;&amp;
 8250     (!ctxt-&gt;disableSAX))
 8251     ctxt-&gt;sax-&gt;internalSubset(ctxt-&gt;userData, name, ExternalID, URI);
 8252     if (ctxt-&gt;instate == XML_PARSER_EOF)
 8253     return;
 8254 
 8255     /*
 8256      * Is there any internal subset declarations ?
 8257      * they are handled separately in xmlParseInternalSubset()
 8258      */
 8259     if (RAW == &#39;[&#39;)
 8260     return;
 8261 
 8262     /*
 8263      * We should be at the end of the DOCTYPE declaration.
 8264      */
 8265     if (RAW != &#39;&gt;&#39;) {
 8266     xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);
 8267     }
 8268     NEXT;
 8269 }
 8270 
 8271 /**
 8272  * xmlParseInternalSubset:
 8273  * @ctxt:  an XML parser context
 8274  *
 8275  * parse the internal subset declaration
 8276  *
 8277  * [28 end] (&#39;[&#39; (markupdecl | PEReference | S)* &#39;]&#39; S?)? &#39;&gt;&#39;
 8278  */
 8279 
 8280 static void
 8281 xmlParseInternalSubset(xmlParserCtxtPtr ctxt) {
 8282     /*
 8283      * Is there any DTD definition ?
 8284      */
 8285     if (RAW == &#39;[&#39;) {
 8286         int baseInputNr = ctxt-&gt;inputNr;
 8287         ctxt-&gt;instate = XML_PARSER_DTD;
 8288         NEXT;
 8289     /*
 8290      * Parse the succession of Markup declarations and
 8291      * PEReferences.
 8292      * Subsequence (markupdecl | PEReference | S)*
 8293      */
 8294     while (((RAW != &#39;]&#39;) || (ctxt-&gt;inputNr &gt; baseInputNr)) &amp;&amp;
 8295                (ctxt-&gt;instate != XML_PARSER_EOF)) {
 8296         const xmlChar *check = CUR_PTR;
 8297         unsigned int cons = ctxt-&gt;input-&gt;consumed;
 8298 
 8299         SKIP_BLANKS;
 8300         xmlParseMarkupDecl(ctxt);
 8301         xmlParsePEReference(ctxt);
 8302 
 8303             /*
 8304              * Conditional sections are allowed from external entities included
 8305              * by PE References in the internal subset.
 8306              */
 8307             if ((ctxt-&gt;inputNr &gt; 1) &amp;&amp; (ctxt-&gt;input-&gt;filename != NULL) &amp;&amp;
 8308                 (RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {
 8309                 xmlParseConditionalSections(ctxt);
 8310             }
 8311 
 8312         if ((CUR_PTR == check) &amp;&amp; (cons == ctxt-&gt;input-&gt;consumed)) {
 8313         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 8314          &quot;xmlParseInternalSubset: error detected in Markup declaration\n&quot;);
 8315                 if (ctxt-&gt;inputNr &gt; baseInputNr)
 8316                     xmlPopInput(ctxt);
 8317                 else
 8318             break;
 8319         }
 8320     }
 8321     if (RAW == &#39;]&#39;) {
 8322         NEXT;
 8323         SKIP_BLANKS;
 8324     }
 8325     }
 8326 
 8327     /*
 8328      * We should be at the end of the DOCTYPE declaration.
 8329      */
 8330     if (RAW != &#39;&gt;&#39;) {
 8331     xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);
 8332     return;
 8333     }
 8334     NEXT;
 8335 }
 8336 
 8337 #ifdef LIBXML_SAX1_ENABLED
 8338 /**
 8339  * xmlParseAttribute:
 8340  * @ctxt:  an XML parser context
 8341  * @value:  a xmlChar ** used to store the value of the attribute
 8342  *
 8343  * parse an attribute
 8344  *
 8345  * [41] Attribute ::= Name Eq AttValue
 8346  *
 8347  * [ WFC: No External Entity References ]
 8348  * Attribute values cannot contain direct or indirect entity references
 8349  * to external entities.
 8350  *
 8351  * [ WFC: No &lt; in Attribute Values ]
 8352  * The replacement text of any entity referred to directly or indirectly in
 8353  * an attribute value (other than &quot;&amp;lt;&quot;) must not contain a &lt;.
 8354  *
 8355  * [ VC: Attribute Value Type ]
 8356  * The attribute must have been declared; the value must be of the type
 8357  * declared for it.
 8358  *
 8359  * [25] Eq ::= S? &#39;=&#39; S?
 8360  *
 8361  * With namespace:
 8362  *
 8363  * [NS 11] Attribute ::= QName Eq AttValue
 8364  *
 8365  * Also the case QName == xmlns:??? is handled independently as a namespace
 8366  * definition.
 8367  *
 8368  * Returns the attribute name, and the value in *value.
 8369  */
 8370 
 8371 const xmlChar *
 8372 xmlParseAttribute(xmlParserCtxtPtr ctxt, xmlChar **value) {
 8373     const xmlChar *name;
 8374     xmlChar *val;
 8375 
 8376     *value = NULL;
 8377     GROW;
 8378     name = xmlParseName(ctxt);
 8379     if (name == NULL) {
 8380     xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 8381                    &quot;error parsing attribute name\n&quot;);
 8382         return(NULL);
 8383     }
 8384 
 8385     /*
 8386      * read the value
 8387      */
 8388     SKIP_BLANKS;
 8389     if (RAW == &#39;=&#39;) {
 8390         NEXT;
 8391     SKIP_BLANKS;
 8392     val = xmlParseAttValue(ctxt);
 8393     ctxt-&gt;instate = XML_PARSER_CONTENT;
 8394     } else {
 8395     xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,
 8396            &quot;Specification mandates value for attribute %s\n&quot;, name);
 8397     return(NULL);
 8398     }
 8399 
 8400     /*
 8401      * Check that xml:lang conforms to the specification
 8402      * No more registered as an error, just generate a warning now
 8403      * since this was deprecated in XML second edition
 8404      */
 8405     if ((ctxt-&gt;pedantic) &amp;&amp; (xmlStrEqual(name, BAD_CAST &quot;xml:lang&quot;))) {
 8406     if (!xmlCheckLanguageID(val)) {
 8407         xmlWarningMsg(ctxt, XML_WAR_LANG_VALUE,
 8408                   &quot;Malformed value for xml:lang : %s\n&quot;,
 8409               val, NULL);
 8410     }
 8411     }
 8412 
 8413     /*
 8414      * Check that xml:space conforms to the specification
 8415      */
 8416     if (xmlStrEqual(name, BAD_CAST &quot;xml:space&quot;)) {
 8417     if (xmlStrEqual(val, BAD_CAST &quot;default&quot;))
 8418         *(ctxt-&gt;space) = 0;
 8419     else if (xmlStrEqual(val, BAD_CAST &quot;preserve&quot;))
 8420         *(ctxt-&gt;space) = 1;
 8421     else {
 8422         xmlWarningMsg(ctxt, XML_WAR_SPACE_VALUE,
 8423 &quot;Invalid value \&quot;%s\&quot; for xml:space : \&quot;default\&quot; or \&quot;preserve\&quot; expected\n&quot;,
 8424                                  val, NULL);
 8425     }
 8426     }
 8427 
 8428     *value = val;
 8429     return(name);
 8430 }
 8431 
 8432 /**
 8433  * xmlParseStartTag:
 8434  * @ctxt:  an XML parser context
 8435  *
 8436  * parse a start of tag either for rule element or
 8437  * EmptyElement. In both case we don&#39;t parse the tag closing chars.
 8438  *
 8439  * [40] STag ::= &#39;&lt;&#39; Name (S Attribute)* S? &#39;&gt;&#39;
 8440  *
 8441  * [ WFC: Unique Att Spec ]
 8442  * No attribute name may appear more than once in the same start-tag or
 8443  * empty-element tag.
 8444  *
 8445  * [44] EmptyElemTag ::= &#39;&lt;&#39; Name (S Attribute)* S? &#39;/&gt;&#39;
 8446  *
 8447  * [ WFC: Unique Att Spec ]
 8448  * No attribute name may appear more than once in the same start-tag or
 8449  * empty-element tag.
 8450  *
 8451  * With namespace:
 8452  *
 8453  * [NS 8] STag ::= &#39;&lt;&#39; QName (S Attribute)* S? &#39;&gt;&#39;
 8454  *
 8455  * [NS 10] EmptyElement ::= &#39;&lt;&#39; QName (S Attribute)* S? &#39;/&gt;&#39;
 8456  *
 8457  * Returns the element name parsed
 8458  */
 8459 
 8460 const xmlChar *
 8461 xmlParseStartTag(xmlParserCtxtPtr ctxt) {
 8462     const xmlChar *name;
 8463     const xmlChar *attname;
 8464     xmlChar *attvalue;
 8465     const xmlChar **atts = ctxt-&gt;atts;
 8466     int nbatts = 0;
 8467     int maxatts = ctxt-&gt;maxatts;
 8468     int i;
 8469 
 8470     if (RAW != &#39;&lt;&#39;) return(NULL);
 8471     NEXT1;
 8472 
 8473     name = xmlParseName(ctxt);
 8474     if (name == NULL) {
 8475     xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 8476          &quot;xmlParseStartTag: invalid element name\n&quot;);
 8477         return(NULL);
 8478     }
 8479 
 8480     /*
 8481      * Now parse the attributes, it ends up with the ending
 8482      *
 8483      * (S Attribute)* S?
 8484      */
 8485     SKIP_BLANKS;
 8486     GROW;
 8487 
 8488     while (((RAW != &#39;&gt;&#39;) &amp;&amp;
 8489        ((RAW != &#39;/&#39;) || (NXT(1) != &#39;&gt;&#39;)) &amp;&amp;
 8490        (IS_BYTE_CHAR(RAW))) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF)) {
 8491     const xmlChar *q = CUR_PTR;
 8492     unsigned int cons = ctxt-&gt;input-&gt;consumed;
 8493 
 8494     attname = xmlParseAttribute(ctxt, &amp;attvalue);
 8495         if ((attname != NULL) &amp;&amp; (attvalue != NULL)) {
 8496         /*
 8497          * [ WFC: Unique Att Spec ]
 8498          * No attribute name may appear more than once in the same
 8499          * start-tag or empty-element tag.
 8500          */
 8501         for (i = 0; i &lt; nbatts;i += 2) {
 8502             if (xmlStrEqual(atts[i], attname)) {
 8503             xmlErrAttributeDup(ctxt, NULL, attname);
 8504             xmlFree(attvalue);
 8505             goto failed;
 8506         }
 8507         }
 8508         /*
 8509          * Add the pair to atts
 8510          */
 8511         if (atts == NULL) {
 8512             maxatts = 22; /* allow for 10 attrs by default */
 8513             atts = (const xmlChar **)
 8514                xmlMalloc(maxatts * sizeof(xmlChar *));
 8515         if (atts == NULL) {
 8516             xmlErrMemory(ctxt, NULL);
 8517             if (attvalue != NULL)
 8518             xmlFree(attvalue);
 8519             goto failed;
 8520         }
 8521         ctxt-&gt;atts = atts;
 8522         ctxt-&gt;maxatts = maxatts;
 8523         } else if (nbatts + 4 &gt; maxatts) {
 8524             const xmlChar **n;
 8525 
 8526             maxatts *= 2;
 8527             n = (const xmlChar **) xmlRealloc((void *) atts,
 8528                          maxatts * sizeof(const xmlChar *));
 8529         if (n == NULL) {
 8530             xmlErrMemory(ctxt, NULL);
 8531             if (attvalue != NULL)
 8532             xmlFree(attvalue);
 8533             goto failed;
 8534         }
 8535         atts = n;
 8536         ctxt-&gt;atts = atts;
 8537         ctxt-&gt;maxatts = maxatts;
 8538         }
 8539         atts[nbatts++] = attname;
 8540         atts[nbatts++] = attvalue;
 8541         atts[nbatts] = NULL;
 8542         atts[nbatts + 1] = NULL;
 8543     } else {
 8544         if (attvalue != NULL)
 8545         xmlFree(attvalue);
 8546     }
 8547 
 8548 failed:
 8549 
 8550     GROW
 8551     if ((RAW == &#39;&gt;&#39;) || (((RAW == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;))))
 8552         break;
 8553     if (SKIP_BLANKS == 0) {
 8554         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 8555                &quot;attributes construct error\n&quot;);
 8556     }
 8557         if ((cons == ctxt-&gt;input-&gt;consumed) &amp;&amp; (q == CUR_PTR) &amp;&amp;
 8558             (attname == NULL) &amp;&amp; (attvalue == NULL)) {
 8559         xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
 8560                &quot;xmlParseStartTag: problem parsing attributes\n&quot;);
 8561         break;
 8562     }
 8563     SHRINK;
 8564         GROW;
 8565     }
 8566 
 8567     /*
 8568      * SAX: Start of Element !
 8569      */
 8570     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;startElement != NULL) &amp;&amp;
 8571     (!ctxt-&gt;disableSAX)) {
 8572     if (nbatts &gt; 0)
 8573         ctxt-&gt;sax-&gt;startElement(ctxt-&gt;userData, name, atts);
 8574     else
 8575         ctxt-&gt;sax-&gt;startElement(ctxt-&gt;userData, name, NULL);
 8576     }
 8577 
 8578     if (atts != NULL) {
 8579         /* Free only the content strings */
 8580         for (i = 1;i &lt; nbatts;i+=2)
 8581         if (atts[i] != NULL)
 8582            xmlFree((xmlChar *) atts[i]);
 8583     }
 8584     return(name);
 8585 }
 8586 
 8587 /**
 8588  * xmlParseEndTag1:
 8589  * @ctxt:  an XML parser context
 8590  * @line:  line of the start tag
 8591  * @nsNr:  number of namespaces on the start tag
 8592  *
 8593  * parse an end of tag
 8594  *
 8595  * [42] ETag ::= &#39;&lt;/&#39; Name S? &#39;&gt;&#39;
 8596  *
 8597  * With namespace
 8598  *
 8599  * [NS 9] ETag ::= &#39;&lt;/&#39; QName S? &#39;&gt;&#39;
 8600  */
 8601 
 8602 static void
 8603 xmlParseEndTag1(xmlParserCtxtPtr ctxt, int line) {
 8604     const xmlChar *name;
 8605 
 8606     GROW;
 8607     if ((RAW != &#39;&lt;&#39;) || (NXT(1) != &#39;/&#39;)) {
 8608     xmlFatalErrMsg(ctxt, XML_ERR_LTSLASH_REQUIRED,
 8609                &quot;xmlParseEndTag: &#39;&lt;/&#39; not found\n&quot;);
 8610     return;
 8611     }
 8612     SKIP(2);
 8613 
 8614     name = xmlParseNameAndCompare(ctxt,ctxt-&gt;name);
 8615 
 8616     /*
 8617      * We should definitely be at the ending &quot;S? &#39;&gt;&#39;&quot; part
 8618      */
 8619     GROW;
 8620     SKIP_BLANKS;
 8621     if ((!IS_BYTE_CHAR(RAW)) || (RAW != &#39;&gt;&#39;)) {
 8622     xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
 8623     } else
 8624     NEXT1;
 8625 
 8626     /*
 8627      * [ WFC: Element Type Match ]
 8628      * The Name in an element&#39;s end-tag must match the element type in the
 8629      * start-tag.
 8630      *
 8631      */
 8632     if (name != (xmlChar*)1) {
 8633         if (name == NULL) name = BAD_CAST &quot;unparseable&quot;;
 8634         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
 8635              &quot;Opening and ending tag mismatch: %s line %d and %s\n&quot;,
 8636                         ctxt-&gt;name, line, name);
 8637     }
 8638 
 8639     /*
 8640      * SAX: End of Tag
 8641      */
 8642     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElement != NULL) &amp;&amp;
 8643     (!ctxt-&gt;disableSAX))
 8644         ctxt-&gt;sax-&gt;endElement(ctxt-&gt;userData, ctxt-&gt;name);
 8645 
 8646     namePop(ctxt);
 8647     spacePop(ctxt);
 8648     return;
 8649 }
 8650 
 8651 /**
 8652  * xmlParseEndTag:
 8653  * @ctxt:  an XML parser context
 8654  *
 8655  * parse an end of tag
 8656  *
 8657  * [42] ETag ::= &#39;&lt;/&#39; Name S? &#39;&gt;&#39;
 8658  *
 8659  * With namespace
 8660  *
 8661  * [NS 9] ETag ::= &#39;&lt;/&#39; QName S? &#39;&gt;&#39;
 8662  */
 8663 
 8664 void
 8665 xmlParseEndTag(xmlParserCtxtPtr ctxt) {
 8666     xmlParseEndTag1(ctxt, 0);
 8667 }
 8668 #endif /* LIBXML_SAX1_ENABLED */
 8669 
 8670 /************************************************************************
 8671  *                                  *
 8672  *            SAX 2 specific operations             *
 8673  *                                  *
 8674  ************************************************************************/
 8675 
 8676 /*
 8677  * xmlGetNamespace:
 8678  * @ctxt:  an XML parser context
 8679  * @prefix:  the prefix to lookup
 8680  *
 8681  * Lookup the namespace name for the @prefix (which ca be NULL)
 8682  * The prefix must come from the @ctxt-&gt;dict dictionary
 8683  *
 8684  * Returns the namespace name or NULL if not bound
 8685  */
 8686 static const xmlChar *
 8687 xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) {
 8688     int i;
 8689 
 8690     if (prefix == ctxt-&gt;str_xml) return(ctxt-&gt;str_xml_ns);
 8691     for (i = ctxt-&gt;nsNr - 2;i &gt;= 0;i-=2)
 8692         if (ctxt-&gt;nsTab[i] == prefix) {
 8693         if ((prefix == NULL) &amp;&amp; (*ctxt-&gt;nsTab[i + 1] == 0))
 8694             return(NULL);
 8695         return(ctxt-&gt;nsTab[i + 1]);
 8696     }
 8697     return(NULL);
 8698 }
 8699 
 8700 /**
 8701  * xmlParseQName:
 8702  * @ctxt:  an XML parser context
 8703  * @prefix:  pointer to store the prefix part
 8704  *
 8705  * parse an XML Namespace QName
 8706  *
 8707  * [6]  QName  ::= (Prefix &#39;:&#39;)? LocalPart
 8708  * [7]  Prefix  ::= NCName
 8709  * [8]  LocalPart  ::= NCName
 8710  *
 8711  * Returns the Name parsed or NULL
 8712  */
 8713 
 8714 static const xmlChar *
 8715 xmlParseQName(xmlParserCtxtPtr ctxt, const xmlChar **prefix) {
 8716     const xmlChar *l, *p;
 8717 
 8718     GROW;
 8719 
 8720     l = xmlParseNCName(ctxt);
 8721     if (l == NULL) {
 8722         if (CUR == &#39;:&#39;) {
 8723         l = xmlParseName(ctxt);
 8724         if (l != NULL) {
 8725             xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8726                  &quot;Failed to parse QName &#39;%s&#39;\n&quot;, l, NULL, NULL);
 8727         *prefix = NULL;
 8728         return(l);
 8729         }
 8730     }
 8731         return(NULL);
 8732     }
 8733     if (CUR == &#39;:&#39;) {
 8734         NEXT;
 8735     p = l;
 8736     l = xmlParseNCName(ctxt);
 8737     if (l == NULL) {
 8738         xmlChar *tmp;
 8739 
 8740             if (ctxt-&gt;instate == XML_PARSER_EOF)
 8741                 return(NULL);
 8742             xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8743                  &quot;Failed to parse QName &#39;%s:&#39;\n&quot;, p, NULL, NULL);
 8744         l = xmlParseNmtoken(ctxt);
 8745         if (l == NULL) {
 8746                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 8747                     return(NULL);
 8748         tmp = xmlBuildQName(BAD_CAST &quot;&quot;, p, NULL, 0);
 8749             } else {
 8750         tmp = xmlBuildQName(l, p, NULL, 0);
 8751         xmlFree((char *)l);
 8752         }
 8753         p = xmlDictLookup(ctxt-&gt;dict, tmp, -1);
 8754         if (tmp != NULL) xmlFree(tmp);
 8755         *prefix = NULL;
 8756         return(p);
 8757     }
 8758     if (CUR == &#39;:&#39;) {
 8759         xmlChar *tmp;
 8760 
 8761             xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8762                  &quot;Failed to parse QName &#39;%s:%s:&#39;\n&quot;, p, l, NULL);
 8763         NEXT;
 8764         tmp = (xmlChar *) xmlParseName(ctxt);
 8765         if (tmp != NULL) {
 8766             tmp = xmlBuildQName(tmp, l, NULL, 0);
 8767         l = xmlDictLookup(ctxt-&gt;dict, tmp, -1);
 8768         if (tmp != NULL) xmlFree(tmp);
 8769         *prefix = p;
 8770         return(l);
 8771         }
 8772             if (ctxt-&gt;instate == XML_PARSER_EOF)
 8773                 return(NULL);
 8774         tmp = xmlBuildQName(BAD_CAST &quot;&quot;, l, NULL, 0);
 8775         l = xmlDictLookup(ctxt-&gt;dict, tmp, -1);
 8776         if (tmp != NULL) xmlFree(tmp);
 8777         *prefix = p;
 8778         return(l);
 8779     }
 8780     *prefix = p;
 8781     } else
 8782         *prefix = NULL;
 8783     return(l);
 8784 }
 8785 
 8786 /**
 8787  * xmlParseQNameAndCompare:
 8788  * @ctxt:  an XML parser context
 8789  * @name:  the localname
 8790  * @prefix:  the prefix, if any.
 8791  *
 8792  * parse an XML name and compares for match
 8793  * (specialized for endtag parsing)
 8794  *
 8795  * Returns NULL for an illegal name, (xmlChar*) 1 for success
 8796  * and the name for mismatch
 8797  */
 8798 
 8799 static const xmlChar *
 8800 xmlParseQNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *name,
 8801                         xmlChar const *prefix) {
 8802     const xmlChar *cmp;
 8803     const xmlChar *in;
 8804     const xmlChar *ret;
 8805     const xmlChar *prefix2;
 8806 
 8807     if (prefix == NULL) return(xmlParseNameAndCompare(ctxt, name));
 8808 
 8809     GROW;
 8810     in = ctxt-&gt;input-&gt;cur;
 8811 
 8812     cmp = prefix;
 8813     while (*in != 0 &amp;&amp; *in == *cmp) {
 8814     ++in;
 8815     ++cmp;
 8816     }
 8817     if ((*cmp == 0) &amp;&amp; (*in == &#39;:&#39;)) {
 8818         in++;
 8819     cmp = name;
 8820     while (*in != 0 &amp;&amp; *in == *cmp) {
 8821         ++in;
 8822         ++cmp;
 8823     }
 8824     if (*cmp == 0 &amp;&amp; (*in == &#39;&gt;&#39; || IS_BLANK_CH (*in))) {
 8825         /* success */
 8826         ctxt-&gt;input-&gt;cur = in;
 8827         return((const xmlChar*) 1);
 8828     }
 8829     }
 8830     /*
 8831      * all strings coms from the dictionary, equality can be done directly
 8832      */
 8833     ret = xmlParseQName (ctxt, &amp;prefix2);
 8834     if ((ret == name) &amp;&amp; (prefix == prefix2))
 8835     return((const xmlChar*) 1);
 8836     return ret;
 8837 }
 8838 
 8839 /**
 8840  * xmlParseAttValueInternal:
 8841  * @ctxt:  an XML parser context
 8842  * @len:  attribute len result
 8843  * @alloc:  whether the attribute was reallocated as a new string
 8844  * @normalize:  if 1 then further non-CDATA normalization must be done
 8845  *
 8846  * parse a value for an attribute.
 8847  * NOTE: if no normalization is needed, the routine will return pointers
 8848  *       directly from the data buffer.
 8849  *
 8850  * 3.3.3 Attribute-Value Normalization:
 8851  * Before the value of an attribute is passed to the application or
 8852  * checked for validity, the XML processor must normalize it as follows:
 8853  * - a character reference is processed by appending the referenced
 8854  *   character to the attribute value
 8855  * - an entity reference is processed by recursively processing the
 8856  *   replacement text of the entity
 8857  * - a whitespace character (#x20, #xD, #xA, #x9) is processed by
 8858  *   appending #x20 to the normalized value, except that only a single
 8859  *   #x20 is appended for a &quot;#xD#xA&quot; sequence that is part of an external
 8860  *   parsed entity or the literal entity value of an internal parsed entity
 8861  * - other characters are processed by appending them to the normalized value
 8862  * If the declared value is not CDATA, then the XML processor must further
 8863  * process the normalized attribute value by discarding any leading and
 8864  * trailing space (#x20) characters, and by replacing sequences of space
 8865  * (#x20) characters by a single space (#x20) character.
 8866  * All attributes for which no declaration has been read should be treated
 8867  * by a non-validating parser as if declared CDATA.
 8868  *
 8869  * Returns the AttValue parsed or NULL. The value has to be freed by the
 8870  *     caller if it was copied, this can be detected by val[*len] == 0.
 8871  */
 8872 
 8873 #define GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end) \
 8874     const xmlChar *oldbase = ctxt-&gt;input-&gt;base;\
 8875     GROW;\
 8876     if (ctxt-&gt;instate == XML_PARSER_EOF)\
 8877         return(NULL);\
 8878     if (oldbase != ctxt-&gt;input-&gt;base) {\
 8879         ptrdiff_t delta = ctxt-&gt;input-&gt;base - oldbase;\
 8880         start = start + delta;\
 8881         in = in + delta;\
 8882     }\
 8883     end = ctxt-&gt;input-&gt;end;
 8884 
 8885 static xmlChar *
 8886 xmlParseAttValueInternal(xmlParserCtxtPtr ctxt, int *len, int *alloc,
 8887                          int normalize)
 8888 {
 8889     xmlChar limit = 0;
 8890     const xmlChar *in = NULL, *start, *end, *last;
 8891     xmlChar *ret = NULL;
 8892     int line, col;
 8893 
 8894     GROW;
 8895     in = (xmlChar *) CUR_PTR;
 8896     line = ctxt-&gt;input-&gt;line;
 8897     col = ctxt-&gt;input-&gt;col;
 8898     if (*in != &#39;&quot;&#39; &amp;&amp; *in != &#39;\&#39;&#39;) {
 8899         xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
 8900         return (NULL);
 8901     }
 8902     ctxt-&gt;instate = XML_PARSER_ATTRIBUTE_VALUE;
 8903 
 8904     /*
 8905      * try to handle in this routine the most common case where no
 8906      * allocation of a new string is required and where content is
 8907      * pure ASCII.
 8908      */
 8909     limit = *in++;
 8910     col++;
 8911     end = ctxt-&gt;input-&gt;end;
 8912     start = in;
 8913     if (in &gt;= end) {
 8914         GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
 8915     }
 8916     if (normalize) {
 8917         /*
 8918      * Skip any leading spaces
 8919      */
 8920     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp;
 8921            ((*in == 0x20) || (*in == 0x9) ||
 8922             (*in == 0xA) || (*in == 0xD))) {
 8923         if (*in == 0xA) {
 8924             line++; col = 1;
 8925         } else {
 8926             col++;
 8927         }
 8928         in++;
 8929         start = in;
 8930         if (in &gt;= end) {
 8931                 GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
 8932                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8933                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8934                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8935                                    &quot;AttValue length too long\n&quot;);
 8936                     return(NULL);
 8937                 }
 8938         }
 8939     }
 8940     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp; (*in &gt;= 0x20) &amp;&amp;
 8941            (*in &lt;= 0x7f) &amp;&amp; (*in != &#39;&amp;&#39;) &amp;&amp; (*in != &#39;&lt;&#39;)) {
 8942         col++;
 8943         if ((*in++ == 0x20) &amp;&amp; (*in == 0x20)) break;
 8944         if (in &gt;= end) {
 8945                 GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
 8946                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8947                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8948                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8949                                    &quot;AttValue length too long\n&quot;);
 8950                     return(NULL);
 8951                 }
 8952         }
 8953     }
 8954     last = in;
 8955     /*
 8956      * skip the trailing blanks
 8957      */
 8958     while ((last[-1] == 0x20) &amp;&amp; (last &gt; start)) last--;
 8959     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp;
 8960            ((*in == 0x20) || (*in == 0x9) ||
 8961             (*in == 0xA) || (*in == 0xD))) {
 8962         if (*in == 0xA) {
 8963             line++, col = 1;
 8964         } else {
 8965             col++;
 8966         }
 8967         in++;
 8968         if (in &gt;= end) {
 8969         const xmlChar *oldbase = ctxt-&gt;input-&gt;base;
 8970         GROW;
 8971                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 8972                     return(NULL);
 8973         if (oldbase != ctxt-&gt;input-&gt;base) {
 8974             ptrdiff_t delta = ctxt-&gt;input-&gt;base - oldbase;
 8975             start = start + delta;
 8976             in = in + delta;
 8977             last = last + delta;
 8978         }
 8979         end = ctxt-&gt;input-&gt;end;
 8980                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8981                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8982                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8983                                    &quot;AttValue length too long\n&quot;);
 8984                     return(NULL);
 8985                 }
 8986         }
 8987     }
 8988         if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8989             ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8990             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8991                            &quot;AttValue length too long\n&quot;);
 8992             return(NULL);
 8993         }
 8994     if (*in != limit) goto need_complex;
 8995     } else {
 8996     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp; (*in &gt;= 0x20) &amp;&amp;
 8997            (*in &lt;= 0x7f) &amp;&amp; (*in != &#39;&amp;&#39;) &amp;&amp; (*in != &#39;&lt;&#39;)) {
 8998         in++;
 8999         col++;
 9000         if (in &gt;= end) {
 9001                 GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
 9002                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 9003                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 9004                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9005                                    &quot;AttValue length too long\n&quot;);
 9006                     return(NULL);
 9007                 }
 9008         }
 9009     }
 9010     last = in;
 9011         if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 9012             ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 9013             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9014                            &quot;AttValue length too long\n&quot;);
 9015             return(NULL);
 9016         }
 9017     if (*in != limit) goto need_complex;
 9018     }
 9019     in++;
 9020     col++;
 9021     if (len != NULL) {
 9022         *len = last - start;
 9023         ret = (xmlChar *) start;
 9024     } else {
 9025         if (alloc) *alloc = 1;
 9026         ret = xmlStrndup(start, last - start);
 9027     }
 9028     CUR_PTR = in;
 9029     ctxt-&gt;input-&gt;line = line;
 9030     ctxt-&gt;input-&gt;col = col;
 9031     if (alloc) *alloc = 0;
 9032     return ret;
 9033 need_complex:
 9034     if (alloc) *alloc = 1;
 9035     return xmlParseAttValueComplex(ctxt, len, normalize);
 9036 }
 9037 
 9038 /**
 9039  * xmlParseAttribute2:
 9040  * @ctxt:  an XML parser context
 9041  * @pref:  the element prefix
 9042  * @elem:  the element name
 9043  * @prefix:  a xmlChar ** used to store the value of the attribute prefix
 9044  * @value:  a xmlChar ** used to store the value of the attribute
 9045  * @len:  an int * to save the length of the attribute
 9046  * @alloc:  an int * to indicate if the attribute was allocated
 9047  *
 9048  * parse an attribute in the new SAX2 framework.
 9049  *
 9050  * Returns the attribute name, and the value in *value, .
 9051  */
 9052 
 9053 static const xmlChar *
 9054 xmlParseAttribute2(xmlParserCtxtPtr ctxt,
 9055                    const xmlChar * pref, const xmlChar * elem,
 9056                    const xmlChar ** prefix, xmlChar ** value,
 9057                    int *len, int *alloc)
 9058 {
 9059     const xmlChar *name;
 9060     xmlChar *val, *internal_val = NULL;
 9061     int normalize = 0;
 9062 
 9063     *value = NULL;
 9064     GROW;
 9065     name = xmlParseQName(ctxt, prefix);
 9066     if (name == NULL) {
 9067         xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 9068                        &quot;error parsing attribute name\n&quot;);
 9069         return (NULL);
 9070     }
 9071 
 9072     /*
 9073      * get the type if needed
 9074      */
 9075     if (ctxt-&gt;attsSpecial != NULL) {
 9076         int type;
 9077 
 9078         type = (int) (ptrdiff_t) xmlHashQLookup2(ctxt-&gt;attsSpecial,
 9079                                                  pref, elem, *prefix, name);
 9080         if (type != 0)
 9081             normalize = 1;
 9082     }
 9083 
 9084     /*
 9085      * read the value
 9086      */
 9087     SKIP_BLANKS;
 9088     if (RAW == &#39;=&#39;) {
 9089         NEXT;
 9090         SKIP_BLANKS;
 9091         val = xmlParseAttValueInternal(ctxt, len, alloc, normalize);
 9092     if (normalize) {
 9093         /*
 9094          * Sometimes a second normalisation pass for spaces is needed
 9095          * but that only happens if charrefs or entities references
 9096          * have been used in the attribute value, i.e. the attribute
 9097          * value have been extracted in an allocated string already.
 9098          */
 9099         if (*alloc) {
 9100             const xmlChar *val2;
 9101 
 9102             val2 = xmlAttrNormalizeSpace2(ctxt, val, len);
 9103         if ((val2 != NULL) &amp;&amp; (val2 != val)) {
 9104             xmlFree(val);
 9105             val = (xmlChar *) val2;
 9106         }
 9107         }
 9108     }
 9109         ctxt-&gt;instate = XML_PARSER_CONTENT;
 9110     } else {
 9111         xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,
 9112                           &quot;Specification mandates value for attribute %s\n&quot;,
 9113                           name);
 9114         return (NULL);
 9115     }
 9116 
 9117     if (*prefix == ctxt-&gt;str_xml) {
 9118         /*
 9119          * Check that xml:lang conforms to the specification
 9120          * No more registered as an error, just generate a warning now
 9121          * since this was deprecated in XML second edition
 9122          */
 9123         if ((ctxt-&gt;pedantic) &amp;&amp; (xmlStrEqual(name, BAD_CAST &quot;lang&quot;))) {
 9124             internal_val = xmlStrndup(val, *len);
 9125             if (!xmlCheckLanguageID(internal_val)) {
 9126                 xmlWarningMsg(ctxt, XML_WAR_LANG_VALUE,
 9127                               &quot;Malformed value for xml:lang : %s\n&quot;,
 9128                               internal_val, NULL);
 9129             }
 9130         }
 9131 
 9132         /*
 9133          * Check that xml:space conforms to the specification
 9134          */
 9135         if (xmlStrEqual(name, BAD_CAST &quot;space&quot;)) {
 9136             internal_val = xmlStrndup(val, *len);
 9137             if (xmlStrEqual(internal_val, BAD_CAST &quot;default&quot;))
 9138                 *(ctxt-&gt;space) = 0;
 9139             else if (xmlStrEqual(internal_val, BAD_CAST &quot;preserve&quot;))
 9140                 *(ctxt-&gt;space) = 1;
 9141             else {
 9142                 xmlWarningMsg(ctxt, XML_WAR_SPACE_VALUE,
 9143                               &quot;Invalid value \&quot;%s\&quot; for xml:space : \&quot;default\&quot; or \&quot;preserve\&quot; expected\n&quot;,
 9144                               internal_val, NULL);
 9145             }
 9146         }
 9147         if (internal_val) {
 9148             xmlFree(internal_val);
 9149         }
 9150     }
 9151 
 9152     *value = val;
 9153     return (name);
 9154 }
 9155 /**
 9156  * xmlParseStartTag2:
 9157  * @ctxt:  an XML parser context
 9158  *
 9159  * parse a start of tag either for rule element or
 9160  * EmptyElement. In both case we don&#39;t parse the tag closing chars.
 9161  * This routine is called when running SAX2 parsing
 9162  *
 9163  * [40] STag ::= &#39;&lt;&#39; Name (S Attribute)* S? &#39;&gt;&#39;
 9164  *
 9165  * [ WFC: Unique Att Spec ]
 9166  * No attribute name may appear more than once in the same start-tag or
 9167  * empty-element tag.
 9168  *
 9169  * [44] EmptyElemTag ::= &#39;&lt;&#39; Name (S Attribute)* S? &#39;/&gt;&#39;
 9170  *
 9171  * [ WFC: Unique Att Spec ]
 9172  * No attribute name may appear more than once in the same start-tag or
 9173  * empty-element tag.
 9174  *
 9175  * With namespace:
 9176  *
 9177  * [NS 8] STag ::= &#39;&lt;&#39; QName (S Attribute)* S? &#39;&gt;&#39;
 9178  *
 9179  * [NS 10] EmptyElement ::= &#39;&lt;&#39; QName (S Attribute)* S? &#39;/&gt;&#39;
 9180  *
 9181  * Returns the element name parsed
 9182  */
 9183 
 9184 static const xmlChar *
 9185 xmlParseStartTag2(xmlParserCtxtPtr ctxt, const xmlChar **pref,
 9186                   const xmlChar **URI, int *tlen) {
 9187     const xmlChar *localname;
 9188     const xmlChar *prefix;
 9189     const xmlChar *attname;
 9190     const xmlChar *aprefix;
 9191     const xmlChar *nsname;
 9192     xmlChar *attvalue;
 9193     const xmlChar **atts = ctxt-&gt;atts;
 9194     int maxatts = ctxt-&gt;maxatts;
 9195     int nratts, nbatts, nbdef, inputid;
 9196     int i, j, nbNs, attval;
 9197     unsigned long cur;
 9198     int nsNr = ctxt-&gt;nsNr;
 9199 
 9200     if (RAW != &#39;&lt;&#39;) return(NULL);
 9201     NEXT1;
 9202 
 9203     /*
 9204      * NOTE: it is crucial with the SAX2 API to never call SHRINK beyond that
 9205      *       point since the attribute values may be stored as pointers to
 9206      *       the buffer and calling SHRINK would destroy them !
 9207      *       The Shrinking is only possible once the full set of attribute
 9208      *       callbacks have been done.
 9209      */
 9210     SHRINK;
 9211     cur = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
 9212     inputid = ctxt-&gt;input-&gt;id;
 9213     nbatts = 0;
 9214     nratts = 0;
 9215     nbdef = 0;
 9216     nbNs = 0;
 9217     attval = 0;
 9218     /* Forget any namespaces added during an earlier parse of this element. */
 9219     ctxt-&gt;nsNr = nsNr;
 9220 
 9221     localname = xmlParseQName(ctxt, &amp;prefix);
 9222     if (localname == NULL) {
 9223     xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 9224                &quot;StartTag: invalid element name\n&quot;);
 9225         return(NULL);
 9226     }
 9227     *tlen = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base - cur;
 9228 
 9229     /*
 9230      * Now parse the attributes, it ends up with the ending
 9231      *
 9232      * (S Attribute)* S?
 9233      */
 9234     SKIP_BLANKS;
 9235     GROW;
 9236 
 9237     while (((RAW != &#39;&gt;&#39;) &amp;&amp;
 9238        ((RAW != &#39;/&#39;) || (NXT(1) != &#39;&gt;&#39;)) &amp;&amp;
 9239        (IS_BYTE_CHAR(RAW))) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF)) {
 9240     const xmlChar *q = CUR_PTR;
 9241     unsigned int cons = ctxt-&gt;input-&gt;consumed;
 9242     int len = -1, alloc = 0;
 9243 
 9244     attname = xmlParseAttribute2(ctxt, prefix, localname,
 9245                                  &amp;aprefix, &amp;attvalue, &amp;len, &amp;alloc);
 9246         if ((attname == NULL) || (attvalue == NULL))
 9247             goto next_attr;
 9248     if (len &lt; 0) len = xmlStrlen(attvalue);
 9249 
 9250         if ((attname == ctxt-&gt;str_xmlns) &amp;&amp; (aprefix == NULL)) {
 9251             const xmlChar *URL = xmlDictLookup(ctxt-&gt;dict, attvalue, len);
 9252             xmlURIPtr uri;
 9253 
 9254             if (URL == NULL) {
 9255                 xmlErrMemory(ctxt, &quot;dictionary allocation failure&quot;);
 9256                 if ((attvalue != NULL) &amp;&amp; (alloc != 0))
 9257                     xmlFree(attvalue);
 9258                 localname = NULL;
 9259                 goto done;
 9260             }
 9261             if (*URL != 0) {
 9262                 uri = xmlParseURI((const char *) URL);
 9263                 if (uri == NULL) {
 9264                     xmlNsErr(ctxt, XML_WAR_NS_URI,
 9265                              &quot;xmlns: &#39;%s&#39; is not a valid URI\n&quot;,
 9266                                        URL, NULL, NULL);
 9267                 } else {
 9268                     if (uri-&gt;scheme == NULL) {
 9269                         xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
 9270                                   &quot;xmlns: URI %s is not absolute\n&quot;,
 9271                                   URL, NULL, NULL);
 9272                     }
 9273                     xmlFreeURI(uri);
 9274                 }
 9275                 if (URL == ctxt-&gt;str_xml_ns) {
 9276                     if (attname != ctxt-&gt;str_xml) {
 9277                         xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9278                      &quot;xml namespace URI cannot be the default namespace\n&quot;,
 9279                                  NULL, NULL, NULL);
 9280                     }
 9281                     goto next_attr;
 9282                 }
 9283                 if ((len == 29) &amp;&amp;
 9284                     (xmlStrEqual(URL,
 9285                              BAD_CAST &quot;http://www.w3.org/2000/xmlns/&quot;))) {
 9286                     xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9287                          &quot;reuse of the xmlns namespace name is forbidden\n&quot;,
 9288                              NULL, NULL, NULL);
 9289                     goto next_attr;
 9290                 }
 9291             }
 9292             /*
 9293              * check that it&#39;s not a defined namespace
 9294              */
 9295             for (j = 1;j &lt;= nbNs;j++)
 9296                 if (ctxt-&gt;nsTab[ctxt-&gt;nsNr - 2 * j] == NULL)
 9297                     break;
 9298             if (j &lt;= nbNs)
 9299                 xmlErrAttributeDup(ctxt, NULL, attname);
 9300             else
 9301                 if (nsPush(ctxt, NULL, URL) &gt; 0) nbNs++;
 9302 
 9303         } else if (aprefix == ctxt-&gt;str_xmlns) {
 9304             const xmlChar *URL = xmlDictLookup(ctxt-&gt;dict, attvalue, len);
 9305             xmlURIPtr uri;
 9306 
 9307             if (attname == ctxt-&gt;str_xml) {
 9308                 if (URL != ctxt-&gt;str_xml_ns) {
 9309                     xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9310                              &quot;xml namespace prefix mapped to wrong URI\n&quot;,
 9311                              NULL, NULL, NULL);
 9312                 }
 9313                 /*
 9314                  * Do not keep a namespace definition node
 9315                  */
 9316                 goto next_attr;
 9317             }
 9318             if (URL == ctxt-&gt;str_xml_ns) {
 9319                 if (attname != ctxt-&gt;str_xml) {
 9320                     xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9321                              &quot;xml namespace URI mapped to wrong prefix\n&quot;,
 9322                              NULL, NULL, NULL);
 9323                 }
 9324                 goto next_attr;
 9325             }
 9326             if (attname == ctxt-&gt;str_xmlns) {
 9327                 xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9328                          &quot;redefinition of the xmlns prefix is forbidden\n&quot;,
 9329                          NULL, NULL, NULL);
 9330                 goto next_attr;
 9331             }
 9332             if ((len == 29) &amp;&amp;
 9333                 (xmlStrEqual(URL,
 9334                              BAD_CAST &quot;http://www.w3.org/2000/xmlns/&quot;))) {
 9335                 xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9336                          &quot;reuse of the xmlns namespace name is forbidden\n&quot;,
 9337                          NULL, NULL, NULL);
 9338                 goto next_attr;
 9339             }
 9340             if ((URL == NULL) || (URL[0] == 0)) {
 9341                 xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9342                          &quot;xmlns:%s: Empty XML namespace is not allowed\n&quot;,
 9343                               attname, NULL, NULL);
 9344                 goto next_attr;
 9345             } else {
 9346                 uri = xmlParseURI((const char *) URL);
 9347                 if (uri == NULL) {
 9348                     xmlNsErr(ctxt, XML_WAR_NS_URI,
 9349                          &quot;xmlns:%s: &#39;%s&#39; is not a valid URI\n&quot;,
 9350                                        attname, URL, NULL);
 9351                 } else {
 9352                     if ((ctxt-&gt;pedantic) &amp;&amp; (uri-&gt;scheme == NULL)) {
 9353                         xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
 9354                                   &quot;xmlns:%s: URI %s is not absolute\n&quot;,
 9355                                   attname, URL, NULL);
 9356                     }
 9357                     xmlFreeURI(uri);
 9358                 }
 9359             }
 9360 
 9361             /*
 9362              * check that it&#39;s not a defined namespace
 9363              */
 9364             for (j = 1;j &lt;= nbNs;j++)
 9365                 if (ctxt-&gt;nsTab[ctxt-&gt;nsNr - 2 * j] == attname)
 9366                     break;
 9367             if (j &lt;= nbNs)
 9368                 xmlErrAttributeDup(ctxt, aprefix, attname);
 9369             else
 9370                 if (nsPush(ctxt, attname, URL) &gt; 0) nbNs++;
 9371 
 9372         } else {
 9373             /*
 9374              * Add the pair to atts
 9375              */
 9376             if ((atts == NULL) || (nbatts + 5 &gt; maxatts)) {
 9377                 if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) &lt; 0) {
 9378                     goto next_attr;
 9379                 }
 9380                 maxatts = ctxt-&gt;maxatts;
 9381                 atts = ctxt-&gt;atts;
 9382             }
 9383             ctxt-&gt;attallocs[nratts++] = alloc;
 9384             atts[nbatts++] = attname;
 9385             atts[nbatts++] = aprefix;
 9386             /*
 9387              * The namespace URI field is used temporarily to point at the
 9388              * base of the current input buffer for non-alloced attributes.
 9389              * When the input buffer is reallocated, all the pointers become
 9390              * invalid, but they can be reconstructed later.
 9391              */
 9392             if (alloc)
 9393                 atts[nbatts++] = NULL;
 9394             else
 9395                 atts[nbatts++] = ctxt-&gt;input-&gt;base;
 9396             atts[nbatts++] = attvalue;
 9397             attvalue += len;
 9398             atts[nbatts++] = attvalue;
 9399             /*
 9400              * tag if some deallocation is needed
 9401              */
 9402             if (alloc != 0) attval = 1;
 9403             attvalue = NULL; /* moved into atts */
 9404         }
 9405 
 9406 next_attr:
 9407         if ((attvalue != NULL) &amp;&amp; (alloc != 0)) {
 9408             xmlFree(attvalue);
 9409             attvalue = NULL;
 9410         }
 9411 
 9412     GROW
 9413         if (ctxt-&gt;instate == XML_PARSER_EOF)
 9414             break;
 9415     if ((RAW == &#39;&gt;&#39;) || (((RAW == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;))))
 9416         break;
 9417     if (SKIP_BLANKS == 0) {
 9418         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 9419                &quot;attributes construct error\n&quot;);
 9420         break;
 9421     }
 9422         if ((cons == ctxt-&gt;input-&gt;consumed) &amp;&amp; (q == CUR_PTR) &amp;&amp;
 9423             (attname == NULL) &amp;&amp; (attvalue == NULL)) {
 9424         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 9425              &quot;xmlParseStartTag: problem parsing attributes\n&quot;);
 9426         break;
 9427     }
 9428         GROW;
 9429     }
 9430 
 9431     if (ctxt-&gt;input-&gt;id != inputid) {
 9432         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 9433                     &quot;Unexpected change of input\n&quot;);
 9434         localname = NULL;
 9435         goto done;
 9436     }
 9437 
 9438     /* Reconstruct attribute value pointers. */
 9439     for (i = 0, j = 0; j &lt; nratts; i += 5, j++) {
 9440         if (atts[i+2] != NULL) {
 9441             /*
 9442              * Arithmetic on dangling pointers is technically undefined
 9443              * behavior, but well...
 9444              */
 9445             ptrdiff_t offset = ctxt-&gt;input-&gt;base - atts[i+2];
 9446             atts[i+2]  = NULL;    /* Reset repurposed namespace URI */
 9447             atts[i+3] += offset;  /* value */
 9448             atts[i+4] += offset;  /* valuend */
 9449         }
 9450     }
 9451 
 9452     /*
 9453      * The attributes defaulting
 9454      */
 9455     if (ctxt-&gt;attsDefault != NULL) {
 9456         xmlDefAttrsPtr defaults;
 9457 
 9458     defaults = xmlHashLookup2(ctxt-&gt;attsDefault, localname, prefix);
 9459     if (defaults != NULL) {
 9460         for (i = 0;i &lt; defaults-&gt;nbAttrs;i++) {
 9461             attname = defaults-&gt;values[5 * i];
 9462         aprefix = defaults-&gt;values[5 * i + 1];
 9463 
 9464                 /*
 9465          * special work for namespaces defaulted defs
 9466          */
 9467         if ((attname == ctxt-&gt;str_xmlns) &amp;&amp; (aprefix == NULL)) {
 9468             /*
 9469              * check that it&#39;s not a defined namespace
 9470              */
 9471             for (j = 1;j &lt;= nbNs;j++)
 9472                 if (ctxt-&gt;nsTab[ctxt-&gt;nsNr - 2 * j] == NULL)
 9473                 break;
 9474                 if (j &lt;= nbNs) continue;
 9475 
 9476             nsname = xmlGetNamespace(ctxt, NULL);
 9477             if (nsname != defaults-&gt;values[5 * i + 2]) {
 9478             if (nsPush(ctxt, NULL,
 9479                        defaults-&gt;values[5 * i + 2]) &gt; 0)
 9480                 nbNs++;
 9481             }
 9482         } else if (aprefix == ctxt-&gt;str_xmlns) {
 9483             /*
 9484              * check that it&#39;s not a defined namespace
 9485              */
 9486             for (j = 1;j &lt;= nbNs;j++)
 9487                 if (ctxt-&gt;nsTab[ctxt-&gt;nsNr - 2 * j] == attname)
 9488                 break;
 9489                 if (j &lt;= nbNs) continue;
 9490 
 9491             nsname = xmlGetNamespace(ctxt, attname);
 9492             if (nsname != defaults-&gt;values[2]) {
 9493             if (nsPush(ctxt, attname,
 9494                        defaults-&gt;values[5 * i + 2]) &gt; 0)
 9495                 nbNs++;
 9496             }
 9497         } else {
 9498             /*
 9499              * check that it&#39;s not a defined attribute
 9500              */
 9501             for (j = 0;j &lt; nbatts;j+=5) {
 9502             if ((attname == atts[j]) &amp;&amp; (aprefix == atts[j+1]))
 9503                 break;
 9504             }
 9505             if (j &lt; nbatts) continue;
 9506 
 9507             if ((atts == NULL) || (nbatts + 5 &gt; maxatts)) {
 9508             if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) &lt; 0) {
 9509                             localname = NULL;
 9510                             goto done;
 9511             }
 9512             maxatts = ctxt-&gt;maxatts;
 9513             atts = ctxt-&gt;atts;
 9514             }
 9515             atts[nbatts++] = attname;
 9516             atts[nbatts++] = aprefix;
 9517             if (aprefix == NULL)
 9518             atts[nbatts++] = NULL;
 9519             else
 9520                 atts[nbatts++] = xmlGetNamespace(ctxt, aprefix);
 9521             atts[nbatts++] = defaults-&gt;values[5 * i + 2];
 9522             atts[nbatts++] = defaults-&gt;values[5 * i + 3];
 9523             if ((ctxt-&gt;standalone == 1) &amp;&amp;
 9524                 (defaults-&gt;values[5 * i + 4] != NULL)) {
 9525             xmlValidityError(ctxt, XML_DTD_STANDALONE_DEFAULTED,
 9526       &quot;standalone: attribute %s on %s defaulted from external subset\n&quot;,
 9527                                      attname, localname);
 9528             }
 9529             nbdef++;
 9530         }
 9531         }
 9532     }
 9533     }
 9534 
 9535     /*
 9536      * The attributes checkings
 9537      */
 9538     for (i = 0; i &lt; nbatts;i += 5) {
 9539         /*
 9540     * The default namespace does not apply to attribute names.
 9541     */
 9542     if (atts[i + 1] != NULL) {
 9543         nsname = xmlGetNamespace(ctxt, atts[i + 1]);
 9544         if (nsname == NULL) {
 9545         xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 9546             &quot;Namespace prefix %s for %s on %s is not defined\n&quot;,
 9547             atts[i + 1], atts[i], localname);
 9548         }
 9549         atts[i + 2] = nsname;
 9550     } else
 9551         nsname = NULL;
 9552     /*
 9553      * [ WFC: Unique Att Spec ]
 9554      * No attribute name may appear more than once in the same
 9555      * start-tag or empty-element tag.
 9556      * As extended by the Namespace in XML REC.
 9557      */
 9558         for (j = 0; j &lt; i;j += 5) {
 9559         if (atts[i] == atts[j]) {
 9560             if (atts[i+1] == atts[j+1]) {
 9561             xmlErrAttributeDup(ctxt, atts[i+1], atts[i]);
 9562             break;
 9563         }
 9564         if ((nsname != NULL) &amp;&amp; (atts[j + 2] == nsname)) {
 9565             xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED,
 9566                  &quot;Namespaced Attribute %s in &#39;%s&#39; redefined\n&quot;,
 9567                  atts[i], nsname, NULL);
 9568             break;
 9569         }
 9570         }
 9571     }
 9572     }
 9573 
 9574     nsname = xmlGetNamespace(ctxt, prefix);
 9575     if ((prefix != NULL) &amp;&amp; (nsname == NULL)) {
 9576     xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 9577              &quot;Namespace prefix %s on %s is not defined\n&quot;,
 9578          prefix, localname, NULL);
 9579     }
 9580     *pref = prefix;
 9581     *URI = nsname;
 9582 
 9583     /*
 9584      * SAX: Start of Element !
 9585      */
 9586     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;startElementNs != NULL) &amp;&amp;
 9587     (!ctxt-&gt;disableSAX)) {
 9588     if (nbNs &gt; 0)
 9589         ctxt-&gt;sax-&gt;startElementNs(ctxt-&gt;userData, localname, prefix,
 9590               nsname, nbNs, &amp;ctxt-&gt;nsTab[ctxt-&gt;nsNr - 2 * nbNs],
 9591               nbatts / 5, nbdef, atts);
 9592     else
 9593         ctxt-&gt;sax-&gt;startElementNs(ctxt-&gt;userData, localname, prefix,
 9594                       nsname, 0, NULL, nbatts / 5, nbdef, atts);
 9595     }
 9596 
 9597 done:
 9598     /*
 9599      * Free up attribute allocated strings if needed
 9600      */
 9601     if (attval != 0) {
 9602     for (i = 3,j = 0; j &lt; nratts;i += 5,j++)
 9603         if ((ctxt-&gt;attallocs[j] != 0) &amp;&amp; (atts[i] != NULL))
 9604             xmlFree((xmlChar *) atts[i]);
 9605     }
 9606 
 9607     return(localname);
 9608 }
 9609 
 9610 /**
 9611  * xmlParseEndTag2:
 9612  * @ctxt:  an XML parser context
 9613  * @line:  line of the start tag
 9614  * @nsNr:  number of namespaces on the start tag
 9615  *
 9616  * parse an end of tag
 9617  *
 9618  * [42] ETag ::= &#39;&lt;/&#39; Name S? &#39;&gt;&#39;
 9619  *
 9620  * With namespace
 9621  *
 9622  * [NS 9] ETag ::= &#39;&lt;/&#39; QName S? &#39;&gt;&#39;
 9623  */
 9624 
 9625 static void
 9626 xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,
 9627                 const xmlChar *URI, int line, int nsNr, int tlen) {
 9628     const xmlChar *name;
 9629     size_t curLength;
 9630 
 9631     GROW;
 9632     if ((RAW != &#39;&lt;&#39;) || (NXT(1) != &#39;/&#39;)) {
 9633     xmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, NULL);
 9634     return;
 9635     }
 9636     SKIP(2);
 9637 
 9638     curLength = ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur;
 9639     if ((tlen &gt; 0) &amp;&amp; (curLength &gt;= (size_t)tlen) &amp;&amp;
 9640         (xmlStrncmp(ctxt-&gt;input-&gt;cur, ctxt-&gt;name, tlen) == 0)) {
 9641         if ((curLength &gt;= (size_t)(tlen + 1)) &amp;&amp;
 9642         (ctxt-&gt;input-&gt;cur[tlen] == &#39;&gt;&#39;)) {
 9643         ctxt-&gt;input-&gt;cur += tlen + 1;
 9644         ctxt-&gt;input-&gt;col += tlen + 1;
 9645         goto done;
 9646     }
 9647     ctxt-&gt;input-&gt;cur += tlen;
 9648     ctxt-&gt;input-&gt;col += tlen;
 9649     name = (xmlChar*)1;
 9650     } else {
 9651     if (prefix == NULL)
 9652         name = xmlParseNameAndCompare(ctxt, ctxt-&gt;name);
 9653     else
 9654         name = xmlParseQNameAndCompare(ctxt, ctxt-&gt;name, prefix);
 9655     }
 9656 
 9657     /*
 9658      * We should definitely be at the ending &quot;S? &#39;&gt;&#39;&quot; part
 9659      */
 9660     GROW;
 9661     if (ctxt-&gt;instate == XML_PARSER_EOF)
 9662         return;
 9663     SKIP_BLANKS;
 9664     if ((!IS_BYTE_CHAR(RAW)) || (RAW != &#39;&gt;&#39;)) {
 9665     xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
 9666     } else
 9667     NEXT1;
 9668 
 9669     /*
 9670      * [ WFC: Element Type Match ]
 9671      * The Name in an element&#39;s end-tag must match the element type in the
 9672      * start-tag.
 9673      *
 9674      */
 9675     if (name != (xmlChar*)1) {
 9676         if (name == NULL) name = BAD_CAST &quot;unparseable&quot;;
 9677         if ((line == 0) &amp;&amp; (ctxt-&gt;node != NULL))
 9678             line = ctxt-&gt;node-&gt;line;
 9679         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
 9680              &quot;Opening and ending tag mismatch: %s line %d and %s\n&quot;,
 9681                         ctxt-&gt;name, line, name);
 9682     }
 9683 
 9684     /*
 9685      * SAX: End of Tag
 9686      */
 9687 done:
 9688     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElementNs != NULL) &amp;&amp;
 9689     (!ctxt-&gt;disableSAX))
 9690     ctxt-&gt;sax-&gt;endElementNs(ctxt-&gt;userData, ctxt-&gt;name, prefix, URI);
 9691 
 9692     spacePop(ctxt);
 9693     if (nsNr != 0)
 9694     nsPop(ctxt, nsNr);
 9695     return;
 9696 }
 9697 
 9698 /**
 9699  * xmlParseCDSect:
 9700  * @ctxt:  an XML parser context
 9701  *
 9702  * Parse escaped pure raw content.
 9703  *
 9704  * [18] CDSect ::= CDStart CData CDEnd
 9705  *
 9706  * [19] CDStart ::= &#39;&lt;![CDATA[&#39;
 9707  *
 9708  * [20] Data ::= (Char* - (Char* &#39;]]&gt;&#39; Char*))
 9709  *
 9710  * [21] CDEnd ::= &#39;]]&gt;&#39;
 9711  */
 9712 void
 9713 xmlParseCDSect(xmlParserCtxtPtr ctxt) {
 9714     xmlChar *buf = NULL;
 9715     int len = 0;
 9716     int size = XML_PARSER_BUFFER_SIZE;
 9717     int r, rl;
 9718     int s, sl;
 9719     int cur, l;
 9720     int count = 0;
 9721 
 9722     /* Check 2.6.0 was NXT(0) not RAW */
 9723     if (CMP9(CUR_PTR, &#39;&lt;&#39;, &#39;!&#39;, &#39;[&#39;, &#39;C&#39;, &#39;D&#39;, &#39;A&#39;, &#39;T&#39;, &#39;A&#39;, &#39;[&#39;)) {
 9724     SKIP(9);
 9725     } else
 9726         return;
 9727 
 9728     ctxt-&gt;instate = XML_PARSER_CDATA_SECTION;
 9729     r = CUR_CHAR(rl);
 9730     if (!IS_CHAR(r)) {
 9731     xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);
 9732     ctxt-&gt;instate = XML_PARSER_CONTENT;
 9733         return;
 9734     }
 9735     NEXTL(rl);
 9736     s = CUR_CHAR(sl);
 9737     if (!IS_CHAR(s)) {
 9738     xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);
 9739     ctxt-&gt;instate = XML_PARSER_CONTENT;
 9740         return;
 9741     }
 9742     NEXTL(sl);
 9743     cur = CUR_CHAR(l);
 9744     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));
 9745     if (buf == NULL) {
 9746     xmlErrMemory(ctxt, NULL);
 9747     return;
 9748     }
 9749     while (IS_CHAR(cur) &amp;&amp;
 9750            ((r != &#39;]&#39;) || (s != &#39;]&#39;) || (cur != &#39;&gt;&#39;))) {
 9751     if (len + 5 &gt;= size) {
 9752         xmlChar *tmp;
 9753 
 9754             if ((size &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 9755                 ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 9756                 xmlFatalErrMsgStr(ctxt, XML_ERR_CDATA_NOT_FINISHED,
 9757                              &quot;CData section too big found&quot;, NULL);
 9758                 xmlFree (buf);
 9759                 return;
 9760             }
 9761         tmp = (xmlChar *) xmlRealloc(buf, size * 2 * sizeof(xmlChar));
 9762         if (tmp == NULL) {
 9763             xmlFree(buf);
 9764         xmlErrMemory(ctxt, NULL);
 9765         return;
 9766         }
 9767         buf = tmp;
 9768         size *= 2;
 9769     }
 9770     COPY_BUF(rl,buf,len,r);
 9771     r = s;
 9772     rl = sl;
 9773     s = cur;
 9774     sl = l;
 9775     count++;
 9776     if (count &gt; 50) {
 9777         GROW;
 9778             if (ctxt-&gt;instate == XML_PARSER_EOF) {
 9779         xmlFree(buf);
 9780         return;
 9781             }
 9782         count = 0;
 9783     }
 9784     NEXTL(l);
 9785     cur = CUR_CHAR(l);
 9786     }
 9787     buf[len] = 0;
 9788     ctxt-&gt;instate = XML_PARSER_CONTENT;
 9789     if (cur != &#39;&gt;&#39;) {
 9790     xmlFatalErrMsgStr(ctxt, XML_ERR_CDATA_NOT_FINISHED,
 9791                          &quot;CData section not finished\n%.50s\n&quot;, buf);
 9792     xmlFree(buf);
 9793         return;
 9794     }
 9795     NEXTL(l);
 9796 
 9797     /*
 9798      * OK the buffer is to be consumed as cdata.
 9799      */
 9800     if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX)) {
 9801     if (ctxt-&gt;sax-&gt;cdataBlock != NULL)
 9802         ctxt-&gt;sax-&gt;cdataBlock(ctxt-&gt;userData, buf, len);
 9803     else if (ctxt-&gt;sax-&gt;characters != NULL)
 9804         ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, buf, len);
 9805     }
 9806     xmlFree(buf);
 9807 }
 9808 
 9809 /**
 9810  * xmlParseContent:
 9811  * @ctxt:  an XML parser context
 9812  *
 9813  * Parse a content:
 9814  *
 9815  * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
 9816  */
 9817 
 9818 void
 9819 xmlParseContent(xmlParserCtxtPtr ctxt) {
 9820     int nameNr = ctxt-&gt;nameNr;
 9821 
 9822     GROW;
 9823     while ((RAW != 0) &amp;&amp;
 9824        (ctxt-&gt;instate != XML_PARSER_EOF)) {
 9825     const xmlChar *test = CUR_PTR;
 9826     unsigned int cons = ctxt-&gt;input-&gt;consumed;
 9827     const xmlChar *cur = ctxt-&gt;input-&gt;cur;
 9828 
 9829     /*
 9830      * First case : a Processing Instruction.
 9831      */
 9832     if ((*cur == &#39;&lt;&#39;) &amp;&amp; (cur[1] == &#39;?&#39;)) {
 9833         xmlParsePI(ctxt);
 9834     }
 9835 
 9836     /*
 9837      * Second case : a CDSection
 9838      */
 9839     /* 2.6.0 test was *cur not RAW */
 9840     else if (CMP9(CUR_PTR, &#39;&lt;&#39;, &#39;!&#39;, &#39;[&#39;, &#39;C&#39;, &#39;D&#39;, &#39;A&#39;, &#39;T&#39;, &#39;A&#39;, &#39;[&#39;)) {
 9841         xmlParseCDSect(ctxt);
 9842     }
 9843 
 9844     /*
 9845      * Third case :  a comment
 9846      */
 9847     else if ((*cur == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp;
 9848          (NXT(2) == &#39;-&#39;) &amp;&amp; (NXT(3) == &#39;-&#39;)) {
 9849         xmlParseComment(ctxt);
 9850         ctxt-&gt;instate = XML_PARSER_CONTENT;
 9851     }
 9852 
 9853     /*
 9854      * Fourth case :  a sub-element.
 9855      */
 9856     else if (*cur == &#39;&lt;&#39;) {
 9857             if (NXT(1) == &#39;/&#39;) {
 9858                 if (ctxt-&gt;nameNr &lt;= nameNr)
 9859                     break;
 9860             xmlParseElementEnd(ctxt);
 9861             } else {
 9862             xmlParseElementStart(ctxt);
 9863             }
 9864     }
 9865 
 9866     /*
 9867      * Fifth case : a reference. If if has not been resolved,
 9868      *    parsing returns it&#39;s Name, create the node
 9869      */
 9870 
 9871     else if (*cur == &#39;&amp;&#39;) {
 9872         xmlParseReference(ctxt);
 9873     }
 9874 
 9875     /*
 9876      * Last case, text. Note that References are handled directly.
 9877      */
 9878     else {
 9879         xmlParseCharData(ctxt, 0);
 9880     }
 9881 
 9882     GROW;
 9883     SHRINK;
 9884 
 9885     if ((cons == ctxt-&gt;input-&gt;consumed) &amp;&amp; (test == CUR_PTR)) {
 9886         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 9887                     &quot;detected an error in element content\n&quot;);
 9888         xmlHaltParser(ctxt);
 9889             break;
 9890     }
 9891     }
 9892 }
 9893 
 9894 /**
 9895  * xmlParseElement:
 9896  * @ctxt:  an XML parser context
 9897  *
 9898  * parse an XML element
 9899  *
 9900  * [39] element ::= EmptyElemTag | STag content ETag
 9901  *
 9902  * [ WFC: Element Type Match ]
 9903  * The Name in an element&#39;s end-tag must match the element type in the
 9904  * start-tag.
 9905  *
 9906  */
 9907 
 9908 void
 9909 xmlParseElement(xmlParserCtxtPtr ctxt) {
 9910     if (xmlParseElementStart(ctxt) != 0)
 9911         return;
 9912     xmlParseContent(ctxt);
 9913     if (ctxt-&gt;instate == XML_PARSER_EOF)
 9914     return;
 9915     xmlParseElementEnd(ctxt);
 9916 }
 9917 
 9918 /**
 9919  * xmlParseElementStart:
 9920  * @ctxt:  an XML parser context
 9921  *
 9922  * Parse the start of an XML element. Returns -1 in case of error, 0 if an
 9923  * opening tag was parsed, 1 if an empty element was parsed.
 9924  */
 9925 static int
 9926 xmlParseElementStart(xmlParserCtxtPtr ctxt) {
 9927     const xmlChar *name;
 9928     const xmlChar *prefix = NULL;
 9929     const xmlChar *URI = NULL;
 9930     xmlParserNodeInfo node_info;
 9931     int line, tlen = 0;
 9932     xmlNodePtr ret;
 9933     int nsNr = ctxt-&gt;nsNr;
 9934 
 9935     if (((unsigned int) ctxt-&gt;nameNr &gt; xmlParserMaxDepth) &amp;&amp;
 9936         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 9937     xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
 9938          &quot;Excessive depth in document: %d use XML_PARSE_HUGE option\n&quot;,
 9939               xmlParserMaxDepth);
 9940     xmlHaltParser(ctxt);
 9941     return(-1);
 9942     }
 9943 
 9944     /* Capture start position */
 9945     if (ctxt-&gt;record_info) {
 9946         node_info.begin_pos = ctxt-&gt;input-&gt;consumed +
 9947                           (CUR_PTR - ctxt-&gt;input-&gt;base);
 9948     node_info.begin_line = ctxt-&gt;input-&gt;line;
 9949     }
 9950 
 9951     if (ctxt-&gt;spaceNr == 0)
 9952     spacePush(ctxt, -1);
 9953     else if (*ctxt-&gt;space == -2)
 9954     spacePush(ctxt, -1);
 9955     else
 9956     spacePush(ctxt, *ctxt-&gt;space);
 9957 
 9958     line = ctxt-&gt;input-&gt;line;
 9959 #ifdef LIBXML_SAX1_ENABLED
 9960     if (ctxt-&gt;sax2)
 9961 #endif /* LIBXML_SAX1_ENABLED */
 9962         name = xmlParseStartTag2(ctxt, &amp;prefix, &amp;URI, &amp;tlen);
 9963 #ifdef LIBXML_SAX1_ENABLED
 9964     else
 9965     name = xmlParseStartTag(ctxt);
 9966 #endif /* LIBXML_SAX1_ENABLED */
 9967     if (ctxt-&gt;instate == XML_PARSER_EOF)
 9968     return(-1);
 9969     if (name == NULL) {
 9970     spacePop(ctxt);
 9971         return(-1);
 9972     }
 9973     if (ctxt-&gt;sax2)
 9974         nameNsPush(ctxt, name, prefix, URI, ctxt-&gt;nsNr - nsNr);
 9975 #ifdef LIBXML_SAX1_ENABLED
 9976     else
 9977     namePush(ctxt, name);
 9978 #endif /* LIBXML_SAX1_ENABLED */
 9979     ret = ctxt-&gt;node;
 9980 
 9981 #ifdef LIBXML_VALID_ENABLED
 9982     /*
 9983      * [ VC: Root Element Type ]
 9984      * The Name in the document type declaration must match the element
 9985      * type of the root element.
 9986      */
 9987     if (ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp; ctxt-&gt;myDoc &amp;&amp;
 9988         ctxt-&gt;node &amp;&amp; (ctxt-&gt;node == ctxt-&gt;myDoc-&gt;children))
 9989         ctxt-&gt;valid &amp;= xmlValidateRoot(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc);
 9990 #endif /* LIBXML_VALID_ENABLED */
 9991 
 9992     /*
 9993      * Check for an Empty Element.
 9994      */
 9995     if ((RAW == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;)) {
 9996         SKIP(2);
 9997     if (ctxt-&gt;sax2) {
 9998         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElementNs != NULL) &amp;&amp;
 9999         (!ctxt-&gt;disableSAX))
10000         ctxt-&gt;sax-&gt;endElementNs(ctxt-&gt;userData, name, prefix, URI);
10001 #ifdef LIBXML_SAX1_ENABLED
10002     } else {
10003         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElement != NULL) &amp;&amp;
10004         (!ctxt-&gt;disableSAX))
10005         ctxt-&gt;sax-&gt;endElement(ctxt-&gt;userData, name);
10006 #endif /* LIBXML_SAX1_ENABLED */
10007     }
10008     namePop(ctxt);
10009     spacePop(ctxt);
10010     if (nsNr != ctxt-&gt;nsNr)
10011         nsPop(ctxt, ctxt-&gt;nsNr - nsNr);
10012     if ( ret != NULL &amp;&amp; ctxt-&gt;record_info ) {
10013        node_info.end_pos = ctxt-&gt;input-&gt;consumed +
10014                   (CUR_PTR - ctxt-&gt;input-&gt;base);
10015        node_info.end_line = ctxt-&gt;input-&gt;line;
10016        node_info.node = ret;
10017        xmlParserAddNodeInfo(ctxt, &amp;node_info);
10018     }
10019     return(1);
10020     }
10021     if (RAW == &#39;&gt;&#39;) {
10022         NEXT1;
10023     } else {
10024         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_GT_REQUIRED,
10025              &quot;Couldn&#39;t find end of Start Tag %s line %d\n&quot;,
10026                         name, line, NULL);
10027 
10028     /*
10029      * end of parsing of this node.
10030      */
10031     nodePop(ctxt);
10032     namePop(ctxt);
10033     spacePop(ctxt);
10034     if (nsNr != ctxt-&gt;nsNr)
10035         nsPop(ctxt, ctxt-&gt;nsNr - nsNr);
10036 
10037     /*
10038      * Capture end position and add node
10039      */
10040     if ( ret != NULL &amp;&amp; ctxt-&gt;record_info ) {
10041        node_info.end_pos = ctxt-&gt;input-&gt;consumed +
10042                   (CUR_PTR - ctxt-&gt;input-&gt;base);
10043        node_info.end_line = ctxt-&gt;input-&gt;line;
10044        node_info.node = ret;
10045        xmlParserAddNodeInfo(ctxt, &amp;node_info);
10046     }
10047     return(-1);
10048     }
10049 
10050     return(0);
10051 }
10052 
10053 /**
10054  * xmlParseElementEnd:
10055  * @ctxt:  an XML parser context
10056  *
10057  * Parse the end of an XML element.
10058      */
10059 static void
10060 xmlParseElementEnd(xmlParserCtxtPtr ctxt) {
10061     xmlParserNodeInfo node_info;
10062     xmlNodePtr ret = ctxt-&gt;node;
10063 
10064     if (ctxt-&gt;nameNr &lt;= 0)
10065     return;
10066 
10067     /*
10068      * parse the end of tag: &#39;&lt;/&#39; should be here.
10069      */
10070     if (ctxt-&gt;sax2) {
10071         const xmlChar *prefix = ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 - 3];
10072         const xmlChar *URI = ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 - 2];
10073         int nsNr = (ptrdiff_t) ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 - 1];
10074     xmlParseEndTag2(ctxt, prefix, URI, 0, nsNr, 0);
10075     namePop(ctxt);
10076     }
10077 #ifdef LIBXML_SAX1_ENABLED
10078       else
10079     xmlParseEndTag1(ctxt, 0);
10080 #endif /* LIBXML_SAX1_ENABLED */
10081 
10082     /*
10083      * Capture end position and add node
10084      */
10085     if ( ret != NULL &amp;&amp; ctxt-&gt;record_info ) {
10086        node_info.end_pos = ctxt-&gt;input-&gt;consumed +
10087                           (CUR_PTR - ctxt-&gt;input-&gt;base);
10088        node_info.end_line = ctxt-&gt;input-&gt;line;
10089        node_info.node = ret;
10090        xmlParserAddNodeInfo(ctxt, &amp;node_info);
10091     }
10092 }
10093 
10094 /**
10095  * xmlParseVersionNum:
10096  * @ctxt:  an XML parser context
10097  *
10098  * parse the XML version value.
10099  *
10100  * [26] VersionNum ::= &#39;1.&#39; [0-9]+
10101  *
10102  * In practice allow [0-9].[0-9]+ at that level
10103  *
10104  * Returns the string giving the XML version number, or NULL
10105  */
10106 xmlChar *
10107 xmlParseVersionNum(xmlParserCtxtPtr ctxt) {
10108     xmlChar *buf = NULL;
10109     int len = 0;
10110     int size = 10;
10111     xmlChar cur;
10112 
10113     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));
10114     if (buf == NULL) {
10115     xmlErrMemory(ctxt, NULL);
10116     return(NULL);
10117     }
10118     cur = CUR;
10119     if (!((cur &gt;= &#39;0&#39;) &amp;&amp; (cur &lt;= &#39;9&#39;))) {
10120     xmlFree(buf);
10121     return(NULL);
10122     }
10123     buf[len++] = cur;
10124     NEXT;
10125     cur=CUR;
10126     if (cur != &#39;.&#39;) {
10127     xmlFree(buf);
10128     return(NULL);
10129     }
10130     buf[len++] = cur;
10131     NEXT;
10132     cur=CUR;
10133     while ((cur &gt;= &#39;0&#39;) &amp;&amp; (cur &lt;= &#39;9&#39;)) {
10134     if (len + 1 &gt;= size) {
10135         xmlChar *tmp;
10136 
10137         size *= 2;
10138         tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));
10139         if (tmp == NULL) {
10140             xmlFree(buf);
10141         xmlErrMemory(ctxt, NULL);
10142         return(NULL);
10143         }
10144         buf = tmp;
10145     }
10146     buf[len++] = cur;
10147     NEXT;
10148     cur=CUR;
10149     }
10150     buf[len] = 0;
10151     return(buf);
10152 }
10153 
10154 /**
10155  * xmlParseVersionInfo:
10156  * @ctxt:  an XML parser context
10157  *
10158  * parse the XML version.
10159  *
10160  * [24] VersionInfo ::= S &#39;version&#39; Eq (&#39; VersionNum &#39; | &quot; VersionNum &quot;)
10161  *
10162  * [25] Eq ::= S? &#39;=&#39; S?
10163  *
10164  * Returns the version string, e.g. &quot;1.0&quot;
10165  */
10166 
10167 xmlChar *
10168 xmlParseVersionInfo(xmlParserCtxtPtr ctxt) {
10169     xmlChar *version = NULL;
10170 
10171     if (CMP7(CUR_PTR, &#39;v&#39;, &#39;e&#39;, &#39;r&#39;, &#39;s&#39;, &#39;i&#39;, &#39;o&#39;, &#39;n&#39;)) {
10172     SKIP(7);
10173     SKIP_BLANKS;
10174     if (RAW != &#39;=&#39;) {
10175         xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
10176         return(NULL);
10177         }
10178     NEXT;
10179     SKIP_BLANKS;
10180     if (RAW == &#39;&quot;&#39;) {
10181         NEXT;
10182         version = xmlParseVersionNum(ctxt);
10183         if (RAW != &#39;&quot;&#39;) {
10184         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10185         } else
10186             NEXT;
10187     } else if (RAW == &#39;\&#39;&#39;){
10188         NEXT;
10189         version = xmlParseVersionNum(ctxt);
10190         if (RAW != &#39;\&#39;&#39;) {
10191         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10192         } else
10193             NEXT;
10194     } else {
10195         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10196     }
10197     }
10198     return(version);
10199 }
10200 
10201 /**
10202  * xmlParseEncName:
10203  * @ctxt:  an XML parser context
10204  *
10205  * parse the XML encoding name
10206  *
10207  * [81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | &#39;-&#39;)*
10208  *
10209  * Returns the encoding name value or NULL
10210  */
10211 xmlChar *
10212 xmlParseEncName(xmlParserCtxtPtr ctxt) {
10213     xmlChar *buf = NULL;
10214     int len = 0;
10215     int size = 10;
10216     xmlChar cur;
10217 
10218     cur = CUR;
10219     if (((cur &gt;= &#39;a&#39;) &amp;&amp; (cur &lt;= &#39;z&#39;)) ||
10220         ((cur &gt;= &#39;A&#39;) &amp;&amp; (cur &lt;= &#39;Z&#39;))) {
10221     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));
10222     if (buf == NULL) {
10223         xmlErrMemory(ctxt, NULL);
10224         return(NULL);
10225     }
10226 
10227     buf[len++] = cur;
10228     NEXT;
10229     cur = CUR;
10230     while (((cur &gt;= &#39;a&#39;) &amp;&amp; (cur &lt;= &#39;z&#39;)) ||
10231            ((cur &gt;= &#39;A&#39;) &amp;&amp; (cur &lt;= &#39;Z&#39;)) ||
10232            ((cur &gt;= &#39;0&#39;) &amp;&amp; (cur &lt;= &#39;9&#39;)) ||
10233            (cur == &#39;.&#39;) || (cur == &#39;_&#39;) ||
10234            (cur == &#39;-&#39;)) {
10235         if (len + 1 &gt;= size) {
10236             xmlChar *tmp;
10237 
10238         size *= 2;
10239         tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));
10240         if (tmp == NULL) {
10241             xmlErrMemory(ctxt, NULL);
10242             xmlFree(buf);
10243             return(NULL);
10244         }
10245         buf = tmp;
10246         }
10247         buf[len++] = cur;
10248         NEXT;
10249         cur = CUR;
10250         if (cur == 0) {
10251             SHRINK;
10252         GROW;
10253         cur = CUR;
10254         }
10255         }
10256     buf[len] = 0;
10257     } else {
10258     xmlFatalErr(ctxt, XML_ERR_ENCODING_NAME, NULL);
10259     }
10260     return(buf);
10261 }
10262 
10263 /**
10264  * xmlParseEncodingDecl:
10265  * @ctxt:  an XML parser context
10266  *
10267  * parse the XML encoding declaration
10268  *
10269  * [80] EncodingDecl ::= S &#39;encoding&#39; Eq (&#39;&quot;&#39; EncName &#39;&quot;&#39; |  &quot;&#39;&quot; EncName &quot;&#39;&quot;)
10270  *
10271  * this setups the conversion filters.
10272  *
10273  * Returns the encoding value or NULL
10274  */
10275 
10276 const xmlChar *
10277 xmlParseEncodingDecl(xmlParserCtxtPtr ctxt) {
10278     xmlChar *encoding = NULL;
10279 
10280     SKIP_BLANKS;
10281     if (CMP8(CUR_PTR, &#39;e&#39;, &#39;n&#39;, &#39;c&#39;, &#39;o&#39;, &#39;d&#39;, &#39;i&#39;, &#39;n&#39;, &#39;g&#39;)) {
10282     SKIP(8);
10283     SKIP_BLANKS;
10284     if (RAW != &#39;=&#39;) {
10285         xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
10286         return(NULL);
10287         }
10288     NEXT;
10289     SKIP_BLANKS;
10290     if (RAW == &#39;&quot;&#39;) {
10291         NEXT;
10292         encoding = xmlParseEncName(ctxt);
10293         if (RAW != &#39;&quot;&#39;) {
10294         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10295         xmlFree((xmlChar *) encoding);
10296         return(NULL);
10297         } else
10298             NEXT;
10299     } else if (RAW == &#39;\&#39;&#39;){
10300         NEXT;
10301         encoding = xmlParseEncName(ctxt);
10302         if (RAW != &#39;\&#39;&#39;) {
10303         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10304         xmlFree((xmlChar *) encoding);
10305         return(NULL);
10306         } else
10307             NEXT;
10308     } else {
10309         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10310     }
10311 
10312         /*
10313          * Non standard parsing, allowing the user to ignore encoding
10314          */
10315         if (ctxt-&gt;options &amp; XML_PARSE_IGNORE_ENC) {
10316         xmlFree((xmlChar *) encoding);
10317             return(NULL);
10318     }
10319 
10320     /*
10321      * UTF-16 encoding switch has already taken place at this stage,
10322      * more over the little-endian/big-endian selection is already done
10323      */
10324         if ((encoding != NULL) &amp;&amp;
10325         ((!xmlStrcasecmp(encoding, BAD_CAST &quot;UTF-16&quot;)) ||
10326          (!xmlStrcasecmp(encoding, BAD_CAST &quot;UTF16&quot;)))) {
10327         /*
10328          * If no encoding was passed to the parser, that we are
10329          * using UTF-16 and no decoder is present i.e. the
10330          * document is apparently UTF-8 compatible, then raise an
10331          * encoding mismatch fatal error
10332          */
10333         if ((ctxt-&gt;encoding == NULL) &amp;&amp;
10334             (ctxt-&gt;input-&gt;buf != NULL) &amp;&amp;
10335             (ctxt-&gt;input-&gt;buf-&gt;encoder == NULL)) {
10336         xmlFatalErrMsg(ctxt, XML_ERR_INVALID_ENCODING,
10337           &quot;Document labelled UTF-16 but has UTF-8 content\n&quot;);
10338         }
10339         if (ctxt-&gt;encoding != NULL)
10340         xmlFree((xmlChar *) ctxt-&gt;encoding);
10341         ctxt-&gt;encoding = encoding;
10342     }
10343     /*
10344      * UTF-8 encoding is handled natively
10345      */
10346         else if ((encoding != NULL) &amp;&amp;
10347         ((!xmlStrcasecmp(encoding, BAD_CAST &quot;UTF-8&quot;)) ||
10348          (!xmlStrcasecmp(encoding, BAD_CAST &quot;UTF8&quot;)))) {
10349         if (ctxt-&gt;encoding != NULL)
10350         xmlFree((xmlChar *) ctxt-&gt;encoding);
10351         ctxt-&gt;encoding = encoding;
10352     }
10353     else if (encoding != NULL) {
10354         xmlCharEncodingHandlerPtr handler;
10355 
10356         if (ctxt-&gt;input-&gt;encoding != NULL)
10357         xmlFree((xmlChar *) ctxt-&gt;input-&gt;encoding);
10358         ctxt-&gt;input-&gt;encoding = encoding;
10359 
10360             handler = xmlFindCharEncodingHandler((const char *) encoding);
10361         if (handler != NULL) {
10362         if (xmlSwitchToEncoding(ctxt, handler) &lt; 0) {
10363             /* failed to convert */
10364             ctxt-&gt;errNo = XML_ERR_UNSUPPORTED_ENCODING;
10365             return(NULL);
10366         }
10367         } else {
10368         xmlFatalErrMsgStr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
10369             &quot;Unsupported encoding %s\n&quot;, encoding);
10370         return(NULL);
10371         }
10372     }
10373     }
10374     return(encoding);
10375 }
10376 
10377 /**
10378  * xmlParseSDDecl:
10379  * @ctxt:  an XML parser context
10380  *
10381  * parse the XML standalone declaration
10382  *
10383  * [32] SDDecl ::= S &#39;standalone&#39; Eq
10384  *                 ((&quot;&#39;&quot; (&#39;yes&#39; | &#39;no&#39;) &quot;&#39;&quot;) | (&#39;&quot;&#39; (&#39;yes&#39; | &#39;no&#39;)&#39;&quot;&#39;))
10385  *
10386  * [ VC: Standalone Document Declaration ]
10387  * TODO The standalone document declaration must have the value &quot;no&quot;
10388  * if any external markup declarations contain declarations of:
10389  *  - attributes with default values, if elements to which these
10390  *    attributes apply appear in the document without specifications
10391  *    of values for these attributes, or
10392  *  - entities (other than amp, lt, gt, apos, quot), if references
10393  *    to those entities appear in the document, or
10394  *  - attributes with values subject to normalization, where the
10395  *    attribute appears in the document with a value which will change
10396  *    as a result of normalization, or
10397  *  - element types with element content, if white space occurs directly
10398  *    within any instance of those types.
10399  *
10400  * Returns:
10401  *   1 if standalone=&quot;yes&quot;
10402  *   0 if standalone=&quot;no&quot;
10403  *  -2 if standalone attribute is missing or invalid
10404  *    (A standalone value of -2 means that the XML declaration was found,
10405  *     but no value was specified for the standalone attribute).
10406  */
10407 
10408 int
10409 xmlParseSDDecl(xmlParserCtxtPtr ctxt) {
10410     int standalone = -2;
10411 
10412     SKIP_BLANKS;
10413     if (CMP10(CUR_PTR, &#39;s&#39;, &#39;t&#39;, &#39;a&#39;, &#39;n&#39;, &#39;d&#39;, &#39;a&#39;, &#39;l&#39;, &#39;o&#39;, &#39;n&#39;, &#39;e&#39;)) {
10414     SKIP(10);
10415         SKIP_BLANKS;
10416     if (RAW != &#39;=&#39;) {
10417         xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
10418         return(standalone);
10419         }
10420     NEXT;
10421     SKIP_BLANKS;
10422         if (RAW == &#39;\&#39;&#39;){
10423         NEXT;
10424         if ((RAW == &#39;n&#39;) &amp;&amp; (NXT(1) == &#39;o&#39;)) {
10425             standalone = 0;
10426                 SKIP(2);
10427         } else if ((RAW == &#39;y&#39;) &amp;&amp; (NXT(1) == &#39;e&#39;) &amp;&amp;
10428                    (NXT(2) == &#39;s&#39;)) {
10429             standalone = 1;
10430         SKIP(3);
10431             } else {
10432         xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);
10433         }
10434         if (RAW != &#39;\&#39;&#39;) {
10435         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10436         } else
10437             NEXT;
10438     } else if (RAW == &#39;&quot;&#39;){
10439         NEXT;
10440         if ((RAW == &#39;n&#39;) &amp;&amp; (NXT(1) == &#39;o&#39;)) {
10441             standalone = 0;
10442         SKIP(2);
10443         } else if ((RAW == &#39;y&#39;) &amp;&amp; (NXT(1) == &#39;e&#39;) &amp;&amp;
10444                    (NXT(2) == &#39;s&#39;)) {
10445             standalone = 1;
10446                 SKIP(3);
10447             } else {
10448         xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);
10449         }
10450         if (RAW != &#39;&quot;&#39;) {
10451         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10452         } else
10453             NEXT;
10454     } else {
10455         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10456         }
10457     }
10458     return(standalone);
10459 }
10460 
10461 /**
10462  * xmlParseXMLDecl:
10463  * @ctxt:  an XML parser context
10464  *
10465  * parse an XML declaration header
10466  *
10467  * [23] XMLDecl ::= &#39;&lt;?xml&#39; VersionInfo EncodingDecl? SDDecl? S? &#39;?&gt;&#39;
10468  */
10469 
10470 void
10471 xmlParseXMLDecl(xmlParserCtxtPtr ctxt) {
10472     xmlChar *version;
10473 
10474     /*
10475      * This value for standalone indicates that the document has an
10476      * XML declaration but it does not have a standalone attribute.
10477      * It will be overwritten later if a standalone attribute is found.
10478      */
10479     ctxt-&gt;input-&gt;standalone = -2;
10480 
10481     /*
10482      * We know that &#39;&lt;?xml&#39; is here.
10483      */
10484     SKIP(5);
10485 
10486     if (!IS_BLANK_CH(RAW)) {
10487     xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
10488                    &quot;Blank needed after &#39;&lt;?xml&#39;\n&quot;);
10489     }
10490     SKIP_BLANKS;
10491 
10492     /*
10493      * We must have the VersionInfo here.
10494      */
10495     version = xmlParseVersionInfo(ctxt);
10496     if (version == NULL) {
10497     xmlFatalErr(ctxt, XML_ERR_VERSION_MISSING, NULL);
10498     } else {
10499     if (!xmlStrEqual(version, (const xmlChar *) XML_DEFAULT_VERSION)) {
10500         /*
10501          * Changed here for XML-1.0 5th edition
10502          */
10503         if (ctxt-&gt;options &amp; XML_PARSE_OLD10) {
10504         xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,
10505                       &quot;Unsupported version &#39;%s&#39;\n&quot;,
10506                       version);
10507         } else {
10508             if ((version[0] == &#39;1&#39;) &amp;&amp; ((version[1] == &#39;.&#39;))) {
10509             xmlWarningMsg(ctxt, XML_WAR_UNKNOWN_VERSION,
10510                           &quot;Unsupported version &#39;%s&#39;\n&quot;,
10511                   version, NULL);
10512         } else {
10513             xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,
10514                       &quot;Unsupported version &#39;%s&#39;\n&quot;,
10515                       version);
10516         }
10517         }
10518     }
10519     if (ctxt-&gt;version != NULL)
10520         xmlFree((void *) ctxt-&gt;version);
10521     ctxt-&gt;version = version;
10522     }
10523 
10524     /*
10525      * We may have the encoding declaration
10526      */
10527     if (!IS_BLANK_CH(RAW)) {
10528         if ((RAW == &#39;?&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;)) {
10529         SKIP(2);
10530         return;
10531     }
10532     xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, &quot;Blank needed here\n&quot;);
10533     }
10534     xmlParseEncodingDecl(ctxt);
10535     if ((ctxt-&gt;errNo == XML_ERR_UNSUPPORTED_ENCODING) ||
10536          (ctxt-&gt;instate == XML_PARSER_EOF)) {
10537     /*
10538      * The XML REC instructs us to stop parsing right here
10539      */
10540         return;
10541     }
10542 
10543     /*
10544      * We may have the standalone status.
10545      */
10546     if ((ctxt-&gt;input-&gt;encoding != NULL) &amp;&amp; (!IS_BLANK_CH(RAW))) {
10547         if ((RAW == &#39;?&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;)) {
10548         SKIP(2);
10549         return;
10550     }
10551     xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, &quot;Blank needed here\n&quot;);
10552     }
10553 
10554     /*
10555      * We can grow the input buffer freely at that point
10556      */
10557     GROW;
10558 
10559     SKIP_BLANKS;
10560     ctxt-&gt;input-&gt;standalone = xmlParseSDDecl(ctxt);
10561 
10562     SKIP_BLANKS;
10563     if ((RAW == &#39;?&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;)) {
10564         SKIP(2);
10565     } else if (RAW == &#39;&gt;&#39;) {
10566         /* Deprecated old WD ... */
10567     xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
10568     NEXT;
10569     } else {
10570     xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
10571     MOVETO_ENDTAG(CUR_PTR);
10572     NEXT;
10573     }
10574 }
10575 
10576 /**
10577  * xmlParseMisc:
10578  * @ctxt:  an XML parser context
10579  *
10580  * parse an XML Misc* optional field.
10581  *
10582  * [27] Misc ::= Comment | PI |  S
10583  */
10584 
10585 void
10586 xmlParseMisc(xmlParserCtxtPtr ctxt) {
10587     while ((ctxt-&gt;instate != XML_PARSER_EOF) &amp;&amp;
10588            (((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;?&#39;)) ||
10589             (CMP4(CUR_PTR, &#39;&lt;&#39;, &#39;!&#39;, &#39;-&#39;, &#39;-&#39;)) ||
10590             IS_BLANK_CH(CUR))) {
10591         if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;?&#39;)) {
10592         xmlParsePI(ctxt);
10593     } else if (IS_BLANK_CH(CUR)) {
10594         NEXT;
10595     } else
10596         xmlParseComment(ctxt);
10597     }
10598 }
10599 
10600 /**
10601  * xmlParseDocument:
10602  * @ctxt:  an XML parser context
10603  *
10604  * parse an XML document (and build a tree if using the standard SAX
10605  * interface).
10606  *
10607  * [1] document ::= prolog element Misc*
10608  *
10609  * [22] prolog ::= XMLDecl? Misc* (doctypedecl Misc*)?
10610  *
10611  * Returns 0, -1 in case of error. the parser context is augmented
10612  *                as a result of the parsing.
10613  */
10614 
10615 int
10616 xmlParseDocument(xmlParserCtxtPtr ctxt) {
10617     xmlChar start[4];
10618     xmlCharEncoding enc;
10619 
10620     xmlInitParser();
10621 
10622     if ((ctxt == NULL) || (ctxt-&gt;input == NULL))
10623         return(-1);
10624 
10625     GROW;
10626 
10627     /*
10628      * SAX: detecting the level.
10629      */
10630     xmlDetectSAX2(ctxt);
10631 
10632     /*
10633      * SAX: beginning of the document processing.
10634      */
10635     if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;setDocumentLocator))
10636         ctxt-&gt;sax-&gt;setDocumentLocator(ctxt-&gt;userData, &amp;xmlDefaultSAXLocator);
10637     if (ctxt-&gt;instate == XML_PARSER_EOF)
10638     return(-1);
10639 
10640     if ((ctxt-&gt;encoding == NULL) &amp;&amp;
10641         ((ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur) &gt;= 4)) {
10642     /*
10643      * Get the 4 first bytes and decode the charset
10644      * if enc != XML_CHAR_ENCODING_NONE
10645      * plug some encoding conversion routines.
10646      */
10647     start[0] = RAW;
10648     start[1] = NXT(1);
10649     start[2] = NXT(2);
10650     start[3] = NXT(3);
10651     enc = xmlDetectCharEncoding(&amp;start[0], 4);
10652     if (enc != XML_CHAR_ENCODING_NONE) {
10653         xmlSwitchEncoding(ctxt, enc);
10654     }
10655     }
10656 
10657 
10658     if (CUR == 0) {
10659     xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
10660     return(-1);
10661     }
10662 
10663     /*
10664      * Check for the XMLDecl in the Prolog.
10665      * do not GROW here to avoid the detected encoder to decode more
10666      * than just the first line, unless the amount of data is really
10667      * too small to hold &quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;foo&quot;
10668      */
10669     if ((ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur) &lt; 35) {
10670        GROW;
10671     }
10672     if ((CMP5(CUR_PTR, &#39;&lt;&#39;, &#39;?&#39;, &#39;x&#39;, &#39;m&#39;, &#39;l&#39;)) &amp;&amp; (IS_BLANK_CH(NXT(5)))) {
10673 
10674     /*
10675      * Note that we will switch encoding on the fly.
10676      */
10677     xmlParseXMLDecl(ctxt);
10678     if ((ctxt-&gt;errNo == XML_ERR_UNSUPPORTED_ENCODING) ||
10679         (ctxt-&gt;instate == XML_PARSER_EOF)) {
10680         /*
10681          * The XML REC instructs us to stop parsing right here
10682          */
10683         return(-1);
10684     }
10685     ctxt-&gt;standalone = ctxt-&gt;input-&gt;standalone;
10686     SKIP_BLANKS;
10687     } else {
10688     ctxt-&gt;version = xmlCharStrdup(XML_DEFAULT_VERSION);
10689     }
10690     if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;startDocument) &amp;&amp; (!ctxt-&gt;disableSAX))
10691         ctxt-&gt;sax-&gt;startDocument(ctxt-&gt;userData);
10692     if (ctxt-&gt;instate == XML_PARSER_EOF)
10693     return(-1);
10694     if ((ctxt-&gt;myDoc != NULL) &amp;&amp; (ctxt-&gt;input != NULL) &amp;&amp;
10695         (ctxt-&gt;input-&gt;buf != NULL) &amp;&amp; (ctxt-&gt;input-&gt;buf-&gt;compressed &gt;= 0)) {
10696     ctxt-&gt;myDoc-&gt;compression = ctxt-&gt;input-&gt;buf-&gt;compressed;
10697     }
10698 
10699     /*
10700      * The Misc part of the Prolog
10701      */
10702     GROW;
10703     xmlParseMisc(ctxt);
10704 
10705     /*
10706      * Then possibly doc type declaration(s) and more Misc
10707      * (doctypedecl Misc*)?
10708      */
10709     GROW;
10710     if (CMP9(CUR_PTR, &#39;&lt;&#39;, &#39;!&#39;, &#39;D&#39;, &#39;O&#39;, &#39;C&#39;, &#39;T&#39;, &#39;Y&#39;, &#39;P&#39;, &#39;E&#39;)) {
10711 
10712     ctxt-&gt;inSubset = 1;
10713     xmlParseDocTypeDecl(ctxt);
10714     if (RAW == &#39;[&#39;) {
10715         ctxt-&gt;instate = XML_PARSER_DTD;
10716         xmlParseInternalSubset(ctxt);
10717         if (ctxt-&gt;instate == XML_PARSER_EOF)
10718         return(-1);
10719     }
10720 
10721     /*
10722      * Create and update the external subset.
10723      */
10724     ctxt-&gt;inSubset = 2;
10725     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;externalSubset != NULL) &amp;&amp;
10726         (!ctxt-&gt;disableSAX))
10727         ctxt-&gt;sax-&gt;externalSubset(ctxt-&gt;userData, ctxt-&gt;intSubName,
10728                                   ctxt-&gt;extSubSystem, ctxt-&gt;extSubURI);
10729     if (ctxt-&gt;instate == XML_PARSER_EOF)
10730         return(-1);
10731     ctxt-&gt;inSubset = 0;
10732 
10733         xmlCleanSpecialAttr(ctxt);
10734 
10735     ctxt-&gt;instate = XML_PARSER_PROLOG;
10736     xmlParseMisc(ctxt);
10737     }
10738 
10739     /*
10740      * Time to start parsing the tree itself
10741      */
10742     GROW;
10743     if (RAW != &#39;&lt;&#39;) {
10744     xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,
10745                &quot;Start tag expected, &#39;&lt;&#39; not found\n&quot;);
10746     } else {
10747     ctxt-&gt;instate = XML_PARSER_CONTENT;
10748     xmlParseElement(ctxt);
10749     ctxt-&gt;instate = XML_PARSER_EPILOG;
10750 
10751 
10752     /*
10753      * The Misc part at the end
10754      */
10755     xmlParseMisc(ctxt);
10756 
10757     if (RAW != 0) {
10758         xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);
10759     }
10760     ctxt-&gt;instate = XML_PARSER_EOF;
10761     }
10762 
10763     /*
10764      * SAX: end of the document processing.
10765      */
10766     if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;endDocument != NULL))
10767         ctxt-&gt;sax-&gt;endDocument(ctxt-&gt;userData);
10768 
10769     /*
10770      * Remove locally kept entity definitions if the tree was not built
10771      */
10772     if ((ctxt-&gt;myDoc != NULL) &amp;&amp;
10773     (xmlStrEqual(ctxt-&gt;myDoc-&gt;version, SAX_COMPAT_MODE))) {
10774     xmlFreeDoc(ctxt-&gt;myDoc);
10775     ctxt-&gt;myDoc = NULL;
10776     }
10777 
10778     if ((ctxt-&gt;wellFormed) &amp;&amp; (ctxt-&gt;myDoc != NULL)) {
10779         ctxt-&gt;myDoc-&gt;properties |= XML_DOC_WELLFORMED;
10780     if (ctxt-&gt;valid)
10781         ctxt-&gt;myDoc-&gt;properties |= XML_DOC_DTDVALID;
10782     if (ctxt-&gt;nsWellFormed)
10783         ctxt-&gt;myDoc-&gt;properties |= XML_DOC_NSVALID;
10784     if (ctxt-&gt;options &amp; XML_PARSE_OLD10)
10785         ctxt-&gt;myDoc-&gt;properties |= XML_DOC_OLD10;
10786     }
10787     if (! ctxt-&gt;wellFormed) {
10788     ctxt-&gt;valid = 0;
10789     return(-1);
10790     }
10791     return(0);
10792 }
10793 
10794 /**
10795  * xmlParseExtParsedEnt:
10796  * @ctxt:  an XML parser context
10797  *
10798  * parse a general parsed entity
10799  * An external general parsed entity is well-formed if it matches the
10800  * production labeled extParsedEnt.
10801  *
10802  * [78] extParsedEnt ::= TextDecl? content
10803  *
10804  * Returns 0, -1 in case of error. the parser context is augmented
10805  *                as a result of the parsing.
10806  */
10807 
10808 int
10809 xmlParseExtParsedEnt(xmlParserCtxtPtr ctxt) {
10810     xmlChar start[4];
10811     xmlCharEncoding enc;
10812 
10813     if ((ctxt == NULL) || (ctxt-&gt;input == NULL))
10814         return(-1);
10815 
10816     xmlDefaultSAXHandlerInit();
10817 
10818     xmlDetectSAX2(ctxt);
10819 
10820     GROW;
10821 
10822     /*
10823      * SAX: beginning of the document processing.
10824      */
10825     if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;setDocumentLocator))
10826         ctxt-&gt;sax-&gt;setDocumentLocator(ctxt-&gt;userData, &amp;xmlDefaultSAXLocator);
10827 
10828     /*
10829      * Get the 4 first bytes and decode the charset
10830      * if enc != XML_CHAR_ENCODING_NONE
10831      * plug some encoding conversion routines.
10832      */
10833     if ((ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur) &gt;= 4) {
10834     start[0] = RAW;
10835     start[1] = NXT(1);
10836     start[2] = NXT(2);
10837     start[3] = NXT(3);
10838     enc = xmlDetectCharEncoding(start, 4);
10839     if (enc != XML_CHAR_ENCODING_NONE) {
10840         xmlSwitchEncoding(ctxt, enc);
10841     }
10842     }
10843 
10844 
10845     if (CUR == 0) {
10846     xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
10847     }
10848 
10849     /*
10850      * Check for the XMLDecl in the Prolog.
10851      */
10852     GROW;
10853     if ((CMP5(CUR_PTR, &#39;&lt;&#39;, &#39;?&#39;, &#39;x&#39;, &#39;m&#39;, &#39;l&#39;)) &amp;&amp; (IS_BLANK_CH(NXT(5)))) {
10854 
10855     /*
10856      * Note that we will switch encoding on the fly.
10857      */
10858     xmlParseXMLDecl(ctxt);
10859     if (ctxt-&gt;errNo == XML_ERR_UNSUPPORTED_ENCODING) {
10860         /*
10861          * The XML REC instructs us to stop parsing right here
10862          */
10863         return(-1);
10864     }
10865     SKIP_BLANKS;
10866     } else {
10867     ctxt-&gt;version = xmlCharStrdup(XML_DEFAULT_VERSION);
10868     }
10869     if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;startDocument) &amp;&amp; (!ctxt-&gt;disableSAX))
10870         ctxt-&gt;sax-&gt;startDocument(ctxt-&gt;userData);
10871     if (ctxt-&gt;instate == XML_PARSER_EOF)
10872     return(-1);
10873 
10874     /*
10875      * Doing validity checking on chunk doesn&#39;t make sense
10876      */
10877     ctxt-&gt;instate = XML_PARSER_CONTENT;
10878     ctxt-&gt;validate = 0;
10879     ctxt-&gt;loadsubset = 0;
10880     ctxt-&gt;depth = 0;
10881 
10882     xmlParseContent(ctxt);
10883     if (ctxt-&gt;instate == XML_PARSER_EOF)
10884     return(-1);
10885 
10886     if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
10887     xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
10888     } else if (RAW != 0) {
10889     xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
10890     }
10891 
10892     /*
10893      * SAX: end of the document processing.
10894      */
10895     if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;endDocument != NULL))
10896         ctxt-&gt;sax-&gt;endDocument(ctxt-&gt;userData);
10897 
10898     if (! ctxt-&gt;wellFormed) return(-1);
10899     return(0);
10900 }
10901 
10902 #ifdef LIBXML_PUSH_ENABLED
10903 /************************************************************************
10904  *                                  *
10905  *      Progressive parsing interfaces              *
10906  *                                  *
10907  ************************************************************************/
10908 
10909 /**
10910  * xmlParseLookupSequence:
10911  * @ctxt:  an XML parser context
10912  * @first:  the first char to lookup
10913  * @next:  the next char to lookup or zero
10914  * @third:  the next char to lookup or zero
10915  *
10916  * Try to find if a sequence (first, next, third) or  just (first next) or
10917  * (first) is available in the input stream.
10918  * This function has a side effect of (possibly) incrementing ctxt-&gt;checkIndex
10919  * to avoid rescanning sequences of bytes, it DOES change the state of the
10920  * parser, do not use liberally.
10921  *
10922  * Returns the index to the current parsing point if the full sequence
10923  *      is available, -1 otherwise.
10924  */
10925 static int
10926 xmlParseLookupSequence(xmlParserCtxtPtr ctxt, xmlChar first,
10927                        xmlChar next, xmlChar third) {
10928     int base, len;
10929     xmlParserInputPtr in;
10930     const xmlChar *buf;
10931 
10932     in = ctxt-&gt;input;
10933     if (in == NULL) return(-1);
10934     base = in-&gt;cur - in-&gt;base;
10935     if (base &lt; 0) return(-1);
10936     if (ctxt-&gt;checkIndex &gt; base)
10937         base = ctxt-&gt;checkIndex;
10938     if (in-&gt;buf == NULL) {
10939     buf = in-&gt;base;
10940     len = in-&gt;length;
10941     } else {
10942     buf = xmlBufContent(in-&gt;buf-&gt;buffer);
10943     len = xmlBufUse(in-&gt;buf-&gt;buffer);
10944     }
10945     /* take into account the sequence length */
10946     if (third) len -= 2;
10947     else if (next) len --;
10948     for (;base &lt; len;base++) {
10949         if (buf[base] == first) {
10950         if (third != 0) {
10951         if ((buf[base + 1] != next) ||
10952             (buf[base + 2] != third)) continue;
10953         } else if (next != 0) {
10954         if (buf[base + 1] != next) continue;
10955         }
10956         ctxt-&gt;checkIndex = 0;
10957 #ifdef DEBUG_PUSH
10958         if (next == 0)
10959         xmlGenericError(xmlGenericErrorContext,
10960             &quot;PP: lookup &#39;%c&#39; found at %d\n&quot;,
10961             first, base);
10962         else if (third == 0)
10963         xmlGenericError(xmlGenericErrorContext,
10964             &quot;PP: lookup &#39;%c%c&#39; found at %d\n&quot;,
10965             first, next, base);
10966         else
10967         xmlGenericError(xmlGenericErrorContext,
10968             &quot;PP: lookup &#39;%c%c%c&#39; found at %d\n&quot;,
10969             first, next, third, base);
10970 #endif
10971         return(base - (in-&gt;cur - in-&gt;base));
10972     }
10973     }
10974     ctxt-&gt;checkIndex = base;
10975 #ifdef DEBUG_PUSH
10976     if (next == 0)
10977     xmlGenericError(xmlGenericErrorContext,
10978         &quot;PP: lookup &#39;%c&#39; failed\n&quot;, first);
10979     else if (third == 0)
10980     xmlGenericError(xmlGenericErrorContext,
10981         &quot;PP: lookup &#39;%c%c&#39; failed\n&quot;, first, next);
10982     else
10983     xmlGenericError(xmlGenericErrorContext,
10984         &quot;PP: lookup &#39;%c%c%c&#39; failed\n&quot;, first, next, third);
10985 #endif
10986     return(-1);
10987 }
10988 
10989 /**
10990  * xmlParseGetLasts:
10991  * @ctxt:  an XML parser context
10992  * @lastlt:  pointer to store the last &#39;&lt;&#39; from the input
10993  * @lastgt:  pointer to store the last &#39;&gt;&#39; from the input
10994  *
10995  * Lookup the last &lt; and &gt; in the current chunk
10996  */
10997 static void
10998 xmlParseGetLasts(xmlParserCtxtPtr ctxt, const xmlChar **lastlt,
10999                  const xmlChar **lastgt) {
11000     const xmlChar *tmp;
11001 
11002     if ((ctxt == NULL) || (lastlt == NULL) || (lastgt == NULL)) {
11003     xmlGenericError(xmlGenericErrorContext,
11004             &quot;Internal error: xmlParseGetLasts\n&quot;);
11005     return;
11006     }
11007     if ((ctxt-&gt;progressive != 0) &amp;&amp; (ctxt-&gt;inputNr == 1)) {
11008         tmp = ctxt-&gt;input-&gt;end;
11009     tmp--;
11010     while ((tmp &gt;= ctxt-&gt;input-&gt;base) &amp;&amp; (*tmp != &#39;&lt;&#39;)) tmp--;
11011     if (tmp &lt; ctxt-&gt;input-&gt;base) {
11012         *lastlt = NULL;
11013         *lastgt = NULL;
11014     } else {
11015         *lastlt = tmp;
11016         tmp++;
11017         while ((tmp &lt; ctxt-&gt;input-&gt;end) &amp;&amp; (*tmp != &#39;&gt;&#39;)) {
11018             if (*tmp == &#39;\&#39;&#39;) {
11019             tmp++;
11020             while ((tmp &lt; ctxt-&gt;input-&gt;end) &amp;&amp; (*tmp != &#39;\&#39;&#39;)) tmp++;
11021             if (tmp &lt; ctxt-&gt;input-&gt;end) tmp++;
11022         } else if (*tmp == &#39;&quot;&#39;) {
11023             tmp++;
11024             while ((tmp &lt; ctxt-&gt;input-&gt;end) &amp;&amp; (*tmp != &#39;&quot;&#39;)) tmp++;
11025             if (tmp &lt; ctxt-&gt;input-&gt;end) tmp++;
11026         } else
11027             tmp++;
11028         }
11029         if (tmp &lt; ctxt-&gt;input-&gt;end)
11030             *lastgt = tmp;
11031         else {
11032             tmp = *lastlt;
11033         tmp--;
11034         while ((tmp &gt;= ctxt-&gt;input-&gt;base) &amp;&amp; (*tmp != &#39;&gt;&#39;)) tmp--;
11035         if (tmp &gt;= ctxt-&gt;input-&gt;base)
11036             *lastgt = tmp;
11037         else
11038             *lastgt = NULL;
11039         }
11040     }
11041     } else {
11042         *lastlt = NULL;
11043     *lastgt = NULL;
11044     }
11045 }
11046 /**
11047  * xmlCheckCdataPush:
11048  * @cur: pointer to the block of characters
11049  * @len: length of the block in bytes
11050  * @complete: 1 if complete CDATA block is passed in, 0 if partial block
11051  *
11052  * Check that the block of characters is okay as SCdata content [20]
11053  *
11054  * Returns the number of bytes to pass if okay, a negative index where an
11055  *         UTF-8 error occurred otherwise
11056  */
11057 static int
11058 xmlCheckCdataPush(const xmlChar *utf, int len, int complete) {
11059     int ix;
11060     unsigned char c;
11061     int codepoint;
11062 
11063     if ((utf == NULL) || (len &lt;= 0))
11064         return(0);
11065 
11066     for (ix = 0; ix &lt; len;) {      /* string is 0-terminated */
11067         c = utf[ix];
11068         if ((c &amp; 0x80) == 0x00) {   /* 1-byte code, starts with 10 */
11069         if (c &gt;= 0x20)
11070         ix++;
11071         else if ((c == 0xA) || (c == 0xD) || (c == 0x9))
11072             ix++;
11073         else
11074             return(-ix);
11075     } else if ((c &amp; 0xe0) == 0xc0) {/* 2-byte code, starts with 110 */
11076         if (ix + 2 &gt; len) return(complete ? -ix : ix);
11077         if ((utf[ix+1] &amp; 0xc0 ) != 0x80)
11078             return(-ix);
11079         codepoint = (utf[ix] &amp; 0x1f) &lt;&lt; 6;
11080         codepoint |= utf[ix+1] &amp; 0x3f;
11081         if (!xmlIsCharQ(codepoint))
11082             return(-ix);
11083         ix += 2;
11084     } else if ((c &amp; 0xf0) == 0xe0) {/* 3-byte code, starts with 1110 */
11085         if (ix + 3 &gt; len) return(complete ? -ix : ix);
11086         if (((utf[ix+1] &amp; 0xc0) != 0x80) ||
11087             ((utf[ix+2] &amp; 0xc0) != 0x80))
11088             return(-ix);
11089         codepoint = (utf[ix] &amp; 0xf) &lt;&lt; 12;
11090         codepoint |= (utf[ix+1] &amp; 0x3f) &lt;&lt; 6;
11091         codepoint |= utf[ix+2] &amp; 0x3f;
11092         if (!xmlIsCharQ(codepoint))
11093             return(-ix);
11094         ix += 3;
11095     } else if ((c &amp; 0xf8) == 0xf0) {/* 4-byte code, starts with 11110 */
11096         if (ix + 4 &gt; len) return(complete ? -ix : ix);
11097         if (((utf[ix+1] &amp; 0xc0) != 0x80) ||
11098             ((utf[ix+2] &amp; 0xc0) != 0x80) ||
11099         ((utf[ix+3] &amp; 0xc0) != 0x80))
11100             return(-ix);
11101         codepoint = (utf[ix] &amp; 0x7) &lt;&lt; 18;
11102         codepoint |= (utf[ix+1] &amp; 0x3f) &lt;&lt; 12;
11103         codepoint |= (utf[ix+2] &amp; 0x3f) &lt;&lt; 6;
11104         codepoint |= utf[ix+3] &amp; 0x3f;
11105         if (!xmlIsCharQ(codepoint))
11106             return(-ix);
11107         ix += 4;
11108     } else              /* unknown encoding */
11109         return(-ix);
11110       }
11111       return(ix);
11112 }
11113 
11114 /**
11115  * xmlParseTryOrFinish:
11116  * @ctxt:  an XML parser context
11117  * @terminate:  last chunk indicator
11118  *
11119  * Try to progress on parsing
11120  *
11121  * Returns zero if no parsing was possible
11122  */
11123 static int
11124 xmlParseTryOrFinish(xmlParserCtxtPtr ctxt, int terminate) {
11125     int ret = 0;
11126     int avail, tlen;
11127     xmlChar cur, next;
11128     const xmlChar *lastlt, *lastgt;
11129 
11130     if (ctxt-&gt;input == NULL)
11131         return(0);
11132 
11133 #ifdef DEBUG_PUSH
11134     switch (ctxt-&gt;instate) {
11135     case XML_PARSER_EOF:
11136         xmlGenericError(xmlGenericErrorContext,
11137             &quot;PP: try EOF\n&quot;); break;
11138     case XML_PARSER_START:
11139         xmlGenericError(xmlGenericErrorContext,
11140             &quot;PP: try START\n&quot;); break;
11141     case XML_PARSER_MISC:
11142         xmlGenericError(xmlGenericErrorContext,
11143             &quot;PP: try MISC\n&quot;);break;
11144     case XML_PARSER_COMMENT:
11145         xmlGenericError(xmlGenericErrorContext,
11146             &quot;PP: try COMMENT\n&quot;);break;
11147     case XML_PARSER_PROLOG:
11148         xmlGenericError(xmlGenericErrorContext,
11149             &quot;PP: try PROLOG\n&quot;);break;
11150     case XML_PARSER_START_TAG:
11151         xmlGenericError(xmlGenericErrorContext,
11152             &quot;PP: try START_TAG\n&quot;);break;
11153     case XML_PARSER_CONTENT:
11154         xmlGenericError(xmlGenericErrorContext,
11155             &quot;PP: try CONTENT\n&quot;);break;
11156     case XML_PARSER_CDATA_SECTION:
11157         xmlGenericError(xmlGenericErrorContext,
11158             &quot;PP: try CDATA_SECTION\n&quot;);break;
11159     case XML_PARSER_END_TAG:
11160         xmlGenericError(xmlGenericErrorContext,
11161             &quot;PP: try END_TAG\n&quot;);break;
11162     case XML_PARSER_ENTITY_DECL:
11163         xmlGenericError(xmlGenericErrorContext,
11164             &quot;PP: try ENTITY_DECL\n&quot;);break;
11165     case XML_PARSER_ENTITY_VALUE:
11166         xmlGenericError(xmlGenericErrorContext,
11167             &quot;PP: try ENTITY_VALUE\n&quot;);break;
11168     case XML_PARSER_ATTRIBUTE_VALUE:
11169         xmlGenericError(xmlGenericErrorContext,
11170             &quot;PP: try ATTRIBUTE_VALUE\n&quot;);break;
11171     case XML_PARSER_DTD:
11172         xmlGenericError(xmlGenericErrorContext,
11173             &quot;PP: try DTD\n&quot;);break;
11174     case XML_PARSER_EPILOG:
11175         xmlGenericError(xmlGenericErrorContext,
11176             &quot;PP: try EPILOG\n&quot;);break;
11177     case XML_PARSER_PI:
11178         xmlGenericError(xmlGenericErrorContext,
11179             &quot;PP: try PI\n&quot;);break;
11180         case XML_PARSER_IGNORE:
11181             xmlGenericError(xmlGenericErrorContext,
11182             &quot;PP: try IGNORE\n&quot;);break;
11183     }
11184 #endif
11185 
11186     if ((ctxt-&gt;input != NULL) &amp;&amp;
11187         (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base &gt; 4096)) {
11188     xmlSHRINK(ctxt);
11189     ctxt-&gt;checkIndex = 0;
11190     }
11191     xmlParseGetLasts(ctxt, &amp;lastlt, &amp;lastgt);
11192 
11193     while (ctxt-&gt;instate != XML_PARSER_EOF) {
11194     if ((ctxt-&gt;errNo != XML_ERR_OK) &amp;&amp; (ctxt-&gt;disableSAX == 1))
11195         return(0);
11196 
11197     if (ctxt-&gt;input == NULL) break;
11198     if (ctxt-&gt;input-&gt;buf == NULL)
11199         avail = ctxt-&gt;input-&gt;length -
11200                 (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11201     else {
11202         /*
11203          * If we are operating on converted input, try to flush
11204          * remaining chars to avoid them stalling in the non-converted
11205          * buffer. But do not do this in document start where
11206          * encoding=&quot;...&quot; may not have been read and we work on a
11207          * guessed encoding.
11208          */
11209         if ((ctxt-&gt;instate != XML_PARSER_START) &amp;&amp;
11210             (ctxt-&gt;input-&gt;buf-&gt;raw != NULL) &amp;&amp;
11211         (xmlBufIsEmpty(ctxt-&gt;input-&gt;buf-&gt;raw) == 0)) {
11212                 size_t base = xmlBufGetInputBase(ctxt-&gt;input-&gt;buf-&gt;buffer,
11213                                                  ctxt-&gt;input);
11214         size_t current = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
11215 
11216         xmlParserInputBufferPush(ctxt-&gt;input-&gt;buf, 0, &quot;&quot;);
11217                 xmlBufSetInputBaseCur(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input,
11218                                       base, current);
11219         }
11220         avail = xmlBufUse(ctxt-&gt;input-&gt;buf-&gt;buffer) -
11221             (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11222     }
11223         if (avail &lt; 1)
11224         goto done;
11225         switch (ctxt-&gt;instate) {
11226             case XML_PARSER_EOF:
11227             /*
11228          * Document parsing is done !
11229          */
11230             goto done;
11231             case XML_PARSER_START:
11232         if (ctxt-&gt;charset == XML_CHAR_ENCODING_NONE) {
11233             xmlChar start[4];
11234             xmlCharEncoding enc;
11235 
11236             /*
11237              * Very first chars read from the document flow.
11238              */
11239             if (avail &lt; 4)
11240             goto done;
11241 
11242             /*
11243              * Get the 4 first bytes and decode the charset
11244              * if enc != XML_CHAR_ENCODING_NONE
11245              * plug some encoding conversion routines,
11246              * else xmlSwitchEncoding will set to (default)
11247              * UTF8.
11248              */
11249             start[0] = RAW;
11250             start[1] = NXT(1);
11251             start[2] = NXT(2);
11252             start[3] = NXT(3);
11253             enc = xmlDetectCharEncoding(start, 4);
11254             xmlSwitchEncoding(ctxt, enc);
11255             break;
11256         }
11257 
11258         if (avail &lt; 2)
11259             goto done;
11260         cur = ctxt-&gt;input-&gt;cur[0];
11261         next = ctxt-&gt;input-&gt;cur[1];
11262         if (cur == 0) {
11263             if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;setDocumentLocator))
11264             ctxt-&gt;sax-&gt;setDocumentLocator(ctxt-&gt;userData,
11265                               &amp;xmlDefaultSAXLocator);
11266             xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
11267             xmlHaltParser(ctxt);
11268 #ifdef DEBUG_PUSH
11269             xmlGenericError(xmlGenericErrorContext,
11270                 &quot;PP: entering EOF\n&quot;);
11271 #endif
11272             if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;endDocument != NULL))
11273             ctxt-&gt;sax-&gt;endDocument(ctxt-&gt;userData);
11274             goto done;
11275         }
11276             if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;?&#39;)) {
11277             /* PI or XML decl */
11278             if (avail &lt; 5) return(ret);
11279             if ((!terminate) &amp;&amp;
11280                 (xmlParseLookupSequence(ctxt, &#39;?&#39;, &#39;&gt;&#39;, 0) &lt; 0))
11281             return(ret);
11282             if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;setDocumentLocator))
11283             ctxt-&gt;sax-&gt;setDocumentLocator(ctxt-&gt;userData,
11284                               &amp;xmlDefaultSAXLocator);
11285             if ((ctxt-&gt;input-&gt;cur[2] == &#39;x&#39;) &amp;&amp;
11286             (ctxt-&gt;input-&gt;cur[3] == &#39;m&#39;) &amp;&amp;
11287             (ctxt-&gt;input-&gt;cur[4] == &#39;l&#39;) &amp;&amp;
11288             (IS_BLANK_CH(ctxt-&gt;input-&gt;cur[5]))) {
11289             ret += 5;
11290 #ifdef DEBUG_PUSH
11291             xmlGenericError(xmlGenericErrorContext,
11292                 &quot;PP: Parsing XML Decl\n&quot;);
11293 #endif
11294             xmlParseXMLDecl(ctxt);
11295             if (ctxt-&gt;errNo == XML_ERR_UNSUPPORTED_ENCODING) {
11296                 /*
11297                  * The XML REC instructs us to stop parsing right
11298                  * here
11299                  */
11300                 xmlHaltParser(ctxt);
11301                 return(0);
11302             }
11303             ctxt-&gt;standalone = ctxt-&gt;input-&gt;standalone;
11304             if ((ctxt-&gt;encoding == NULL) &amp;&amp;
11305                 (ctxt-&gt;input-&gt;encoding != NULL))
11306                 ctxt-&gt;encoding = xmlStrdup(ctxt-&gt;input-&gt;encoding);
11307             if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;startDocument) &amp;&amp;
11308                 (!ctxt-&gt;disableSAX))
11309                 ctxt-&gt;sax-&gt;startDocument(ctxt-&gt;userData);
11310             ctxt-&gt;instate = XML_PARSER_MISC;
11311 #ifdef DEBUG_PUSH
11312             xmlGenericError(xmlGenericErrorContext,
11313                 &quot;PP: entering MISC\n&quot;);
11314 #endif
11315             } else {
11316             ctxt-&gt;version = xmlCharStrdup(XML_DEFAULT_VERSION);
11317             if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;startDocument) &amp;&amp;
11318                 (!ctxt-&gt;disableSAX))
11319                 ctxt-&gt;sax-&gt;startDocument(ctxt-&gt;userData);
11320             ctxt-&gt;instate = XML_PARSER_MISC;
11321 #ifdef DEBUG_PUSH
11322             xmlGenericError(xmlGenericErrorContext,
11323                 &quot;PP: entering MISC\n&quot;);
11324 #endif
11325             }
11326         } else {
11327             if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;setDocumentLocator))
11328             ctxt-&gt;sax-&gt;setDocumentLocator(ctxt-&gt;userData,
11329                               &amp;xmlDefaultSAXLocator);
11330             ctxt-&gt;version = xmlCharStrdup(XML_DEFAULT_VERSION);
11331             if (ctxt-&gt;version == NULL) {
11332                 xmlErrMemory(ctxt, NULL);
11333             break;
11334             }
11335             if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;startDocument) &amp;&amp;
11336                 (!ctxt-&gt;disableSAX))
11337             ctxt-&gt;sax-&gt;startDocument(ctxt-&gt;userData);
11338             ctxt-&gt;instate = XML_PARSER_MISC;
11339 #ifdef DEBUG_PUSH
11340             xmlGenericError(xmlGenericErrorContext,
11341                 &quot;PP: entering MISC\n&quot;);
11342 #endif
11343         }
11344         break;
11345             case XML_PARSER_START_TAG: {
11346             const xmlChar *name;
11347         const xmlChar *prefix = NULL;
11348         const xmlChar *URI = NULL;
11349         int nsNr = ctxt-&gt;nsNr;
11350 
11351         if ((avail &lt; 2) &amp;&amp; (ctxt-&gt;inputNr == 1))
11352             goto done;
11353         cur = ctxt-&gt;input-&gt;cur[0];
11354             if (cur != &#39;&lt;&#39;) {
11355             xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
11356             xmlHaltParser(ctxt);
11357             if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;endDocument != NULL))
11358             ctxt-&gt;sax-&gt;endDocument(ctxt-&gt;userData);
11359             goto done;
11360         }
11361         if (!terminate) {
11362             if (ctxt-&gt;progressive) {
11363                 /* &gt; can be found unescaped in attribute values */
11364                 if ((lastgt == NULL) || (ctxt-&gt;input-&gt;cur &gt;= lastgt))
11365                 goto done;
11366             } else if (xmlParseLookupSequence(ctxt, &#39;&gt;&#39;, 0, 0) &lt; 0) {
11367             goto done;
11368             }
11369         }
11370         if (ctxt-&gt;spaceNr == 0)
11371             spacePush(ctxt, -1);
11372         else if (*ctxt-&gt;space == -2)
11373             spacePush(ctxt, -1);
11374         else
11375             spacePush(ctxt, *ctxt-&gt;space);
11376 #ifdef LIBXML_SAX1_ENABLED
11377         if (ctxt-&gt;sax2)
11378 #endif /* LIBXML_SAX1_ENABLED */
11379             name = xmlParseStartTag2(ctxt, &amp;prefix, &amp;URI, &amp;tlen);
11380 #ifdef LIBXML_SAX1_ENABLED
11381         else
11382             name = xmlParseStartTag(ctxt);
11383 #endif /* LIBXML_SAX1_ENABLED */
11384         if (ctxt-&gt;instate == XML_PARSER_EOF)
11385             goto done;
11386         if (name == NULL) {
11387             spacePop(ctxt);
11388             xmlHaltParser(ctxt);
11389             if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;endDocument != NULL))
11390             ctxt-&gt;sax-&gt;endDocument(ctxt-&gt;userData);
11391             goto done;
11392         }
11393 #ifdef LIBXML_VALID_ENABLED
11394         /*
11395          * [ VC: Root Element Type ]
11396          * The Name in the document type declaration must match
11397          * the element type of the root element.
11398          */
11399         if (ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp; ctxt-&gt;myDoc &amp;&amp;
11400             ctxt-&gt;node &amp;&amp; (ctxt-&gt;node == ctxt-&gt;myDoc-&gt;children))
11401             ctxt-&gt;valid &amp;= xmlValidateRoot(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc);
11402 #endif /* LIBXML_VALID_ENABLED */
11403 
11404         /*
11405          * Check for an Empty Element.
11406          */
11407         if ((RAW == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;)) {
11408             SKIP(2);
11409 
11410             if (ctxt-&gt;sax2) {
11411             if ((ctxt-&gt;sax != NULL) &amp;&amp;
11412                 (ctxt-&gt;sax-&gt;endElementNs != NULL) &amp;&amp;
11413                 (!ctxt-&gt;disableSAX))
11414                 ctxt-&gt;sax-&gt;endElementNs(ctxt-&gt;userData, name,
11415                                         prefix, URI);
11416             if (ctxt-&gt;nsNr - nsNr &gt; 0)
11417                 nsPop(ctxt, ctxt-&gt;nsNr - nsNr);
11418 #ifdef LIBXML_SAX1_ENABLED
11419             } else {
11420             if ((ctxt-&gt;sax != NULL) &amp;&amp;
11421                 (ctxt-&gt;sax-&gt;endElement != NULL) &amp;&amp;
11422                 (!ctxt-&gt;disableSAX))
11423                 ctxt-&gt;sax-&gt;endElement(ctxt-&gt;userData, name);
11424 #endif /* LIBXML_SAX1_ENABLED */
11425             }
11426             if (ctxt-&gt;instate == XML_PARSER_EOF)
11427             goto done;
11428             spacePop(ctxt);
11429             if (ctxt-&gt;nameNr == 0) {
11430             ctxt-&gt;instate = XML_PARSER_EPILOG;
11431             } else {
11432             ctxt-&gt;instate = XML_PARSER_CONTENT;
11433             }
11434                     ctxt-&gt;progressive = 1;
11435             break;
11436         }
11437         if (RAW == &#39;&gt;&#39;) {
11438             NEXT;
11439         } else {
11440             xmlFatalErrMsgStr(ctxt, XML_ERR_GT_REQUIRED,
11441                      &quot;Couldn&#39;t find end of Start Tag %s\n&quot;,
11442                      name);
11443             nodePop(ctxt);
11444             spacePop(ctxt);
11445         }
11446         if (ctxt-&gt;sax2)
11447             nameNsPush(ctxt, name, prefix, URI, ctxt-&gt;nsNr - nsNr);
11448 #ifdef LIBXML_SAX1_ENABLED
11449         else
11450             namePush(ctxt, name);
11451 #endif /* LIBXML_SAX1_ENABLED */
11452 
11453         ctxt-&gt;instate = XML_PARSER_CONTENT;
11454                 ctxt-&gt;progressive = 1;
11455                 break;
11456         }
11457             case XML_PARSER_CONTENT: {
11458         const xmlChar *test;
11459         unsigned int cons;
11460         if ((avail &lt; 2) &amp;&amp; (ctxt-&gt;inputNr == 1))
11461             goto done;
11462         cur = ctxt-&gt;input-&gt;cur[0];
11463         next = ctxt-&gt;input-&gt;cur[1];
11464 
11465         test = CUR_PTR;
11466             cons = ctxt-&gt;input-&gt;consumed;
11467         if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;/&#39;)) {
11468             ctxt-&gt;instate = XML_PARSER_END_TAG;
11469             break;
11470             } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;?&#39;)) {
11471             if ((!terminate) &amp;&amp;
11472                 (xmlParseLookupSequence(ctxt, &#39;?&#39;, &#39;&gt;&#39;, 0) &lt; 0)) {
11473                         ctxt-&gt;progressive = XML_PARSER_PI;
11474             goto done;
11475                     }
11476             xmlParsePI(ctxt);
11477             ctxt-&gt;instate = XML_PARSER_CONTENT;
11478                     ctxt-&gt;progressive = 1;
11479         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next != &#39;!&#39;)) {
11480             ctxt-&gt;instate = XML_PARSER_START_TAG;
11481             break;
11482         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
11483                    (ctxt-&gt;input-&gt;cur[2] == &#39;-&#39;) &amp;&amp;
11484                (ctxt-&gt;input-&gt;cur[3] == &#39;-&#39;)) {
11485             int term;
11486 
11487                 if (avail &lt; 4)
11488                 goto done;
11489             ctxt-&gt;input-&gt;cur += 4;
11490             term = xmlParseLookupSequence(ctxt, &#39;-&#39;, &#39;-&#39;, &#39;&gt;&#39;);
11491             ctxt-&gt;input-&gt;cur -= 4;
11492             if ((!terminate) &amp;&amp; (term &lt; 0)) {
11493                         ctxt-&gt;progressive = XML_PARSER_COMMENT;
11494             goto done;
11495                     }
11496             xmlParseComment(ctxt);
11497             ctxt-&gt;instate = XML_PARSER_CONTENT;
11498                     ctxt-&gt;progressive = 1;
11499         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (ctxt-&gt;input-&gt;cur[1] == &#39;!&#39;) &amp;&amp;
11500             (ctxt-&gt;input-&gt;cur[2] == &#39;[&#39;) &amp;&amp;
11501             (ctxt-&gt;input-&gt;cur[3] == &#39;C&#39;) &amp;&amp;
11502             (ctxt-&gt;input-&gt;cur[4] == &#39;D&#39;) &amp;&amp;
11503             (ctxt-&gt;input-&gt;cur[5] == &#39;A&#39;) &amp;&amp;
11504             (ctxt-&gt;input-&gt;cur[6] == &#39;T&#39;) &amp;&amp;
11505             (ctxt-&gt;input-&gt;cur[7] == &#39;A&#39;) &amp;&amp;
11506             (ctxt-&gt;input-&gt;cur[8] == &#39;[&#39;)) {
11507             SKIP(9);
11508             ctxt-&gt;instate = XML_PARSER_CDATA_SECTION;
11509             break;
11510         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
11511                    (avail &lt; 9)) {
11512             goto done;
11513         } else if (cur == &#39;&amp;&#39;) {
11514             if ((!terminate) &amp;&amp;
11515                 (xmlParseLookupSequence(ctxt, &#39;;&#39;, 0, 0) &lt; 0))
11516             goto done;
11517             xmlParseReference(ctxt);
11518         } else {
11519             /* TODO Avoid the extra copy, handle directly !!! */
11520             /*
11521              * Goal of the following test is:
11522              *  - minimize calls to the SAX &#39;character&#39; callback
11523              *    when they are mergeable
11524              *  - handle an problem for isBlank when we only parse
11525              *    a sequence of blank chars and the next one is
11526              *    not available to check against &#39;&lt;&#39; presence.
11527              *  - tries to homogenize the differences in SAX
11528              *    callbacks between the push and pull versions
11529              *    of the parser.
11530              */
11531             if ((ctxt-&gt;inputNr == 1) &amp;&amp;
11532                 (avail &lt; XML_PARSER_BIG_BUFFER_SIZE)) {
11533             if (!terminate) {
11534                 if (ctxt-&gt;progressive) {
11535                 if ((lastlt == NULL) ||
11536                     (ctxt-&gt;input-&gt;cur &gt; lastlt))
11537                     goto done;
11538                 } else if (xmlParseLookupSequence(ctxt,
11539                                                   &#39;&lt;&#39;, 0, 0) &lt; 0) {
11540                 goto done;
11541                 }
11542             }
11543                     }
11544             ctxt-&gt;checkIndex = 0;
11545             xmlParseCharData(ctxt, 0);
11546         }
11547         if ((cons == ctxt-&gt;input-&gt;consumed) &amp;&amp; (test == CUR_PTR)) {
11548             xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
11549                         &quot;detected an error in element content\n&quot;);
11550             xmlHaltParser(ctxt);
11551             break;
11552         }
11553         break;
11554         }
11555             case XML_PARSER_END_TAG:
11556         if (avail &lt; 2)
11557             goto done;
11558         if (!terminate) {
11559             if (ctxt-&gt;progressive) {
11560                 /* &gt; can be found unescaped in attribute values */
11561                 if ((lastgt == NULL) || (ctxt-&gt;input-&gt;cur &gt;= lastgt))
11562                 goto done;
11563             } else if (xmlParseLookupSequence(ctxt, &#39;&gt;&#39;, 0, 0) &lt; 0) {
11564             goto done;
11565             }
11566         }
11567         if (ctxt-&gt;sax2) {
11568             xmlParseEndTag2(ctxt,
11569                     (void *) ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 - 3],
11570                     (void *) ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 - 2], 0,
11571                     (int) (ptrdiff_t)
11572                                 ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 - 1], 0);
11573             nameNsPop(ctxt);
11574         }
11575 #ifdef LIBXML_SAX1_ENABLED
11576           else
11577             xmlParseEndTag1(ctxt, 0);
11578 #endif /* LIBXML_SAX1_ENABLED */
11579         if (ctxt-&gt;instate == XML_PARSER_EOF) {
11580             /* Nothing */
11581         } else if (ctxt-&gt;nameNr == 0) {
11582             ctxt-&gt;instate = XML_PARSER_EPILOG;
11583         } else {
11584             ctxt-&gt;instate = XML_PARSER_CONTENT;
11585         }
11586         break;
11587             case XML_PARSER_CDATA_SECTION: {
11588             /*
11589          * The Push mode need to have the SAX callback for
11590          * cdataBlock merge back contiguous callbacks.
11591          */
11592         int base;
11593 
11594         base = xmlParseLookupSequence(ctxt, &#39;]&#39;, &#39;]&#39;, &#39;&gt;&#39;);
11595         if (base &lt; 0) {
11596             if (avail &gt;= XML_PARSER_BIG_BUFFER_SIZE + 2) {
11597                 int tmp;
11598 
11599             tmp = xmlCheckCdataPush(ctxt-&gt;input-&gt;cur,
11600                                     XML_PARSER_BIG_BUFFER_SIZE, 0);
11601             if (tmp &lt; 0) {
11602                 tmp = -tmp;
11603                 ctxt-&gt;input-&gt;cur += tmp;
11604                 goto encoding_error;
11605             }
11606             if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX)) {
11607                 if (ctxt-&gt;sax-&gt;cdataBlock != NULL)
11608                 ctxt-&gt;sax-&gt;cdataBlock(ctxt-&gt;userData,
11609                                       ctxt-&gt;input-&gt;cur, tmp);
11610                 else if (ctxt-&gt;sax-&gt;characters != NULL)
11611                 ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData,
11612                                       ctxt-&gt;input-&gt;cur, tmp);
11613             }
11614             if (ctxt-&gt;instate == XML_PARSER_EOF)
11615                 goto done;
11616             SKIPL(tmp);
11617             ctxt-&gt;checkIndex = 0;
11618             }
11619             goto done;
11620         } else {
11621             int tmp;
11622 
11623             tmp = xmlCheckCdataPush(ctxt-&gt;input-&gt;cur, base, 1);
11624             if ((tmp &lt; 0) || (tmp != base)) {
11625             tmp = -tmp;
11626             ctxt-&gt;input-&gt;cur += tmp;
11627             goto encoding_error;
11628             }
11629             if ((ctxt-&gt;sax != NULL) &amp;&amp; (base == 0) &amp;&amp;
11630                 (ctxt-&gt;sax-&gt;cdataBlock != NULL) &amp;&amp;
11631                 (!ctxt-&gt;disableSAX)) {
11632             /*
11633              * Special case to provide identical behaviour
11634              * between pull and push parsers on enpty CDATA
11635              * sections
11636              */
11637              if ((ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base &gt;= 9) &amp;&amp;
11638                  (!strncmp((const char *)&amp;ctxt-&gt;input-&gt;cur[-9],
11639                            &quot;&lt;![CDATA[&quot;, 9)))
11640                  ctxt-&gt;sax-&gt;cdataBlock(ctxt-&gt;userData,
11641                                        BAD_CAST &quot;&quot;, 0);
11642             } else if ((ctxt-&gt;sax != NULL) &amp;&amp; (base &gt; 0) &amp;&amp;
11643             (!ctxt-&gt;disableSAX)) {
11644             if (ctxt-&gt;sax-&gt;cdataBlock != NULL)
11645                 ctxt-&gt;sax-&gt;cdataBlock(ctxt-&gt;userData,
11646                           ctxt-&gt;input-&gt;cur, base);
11647             else if (ctxt-&gt;sax-&gt;characters != NULL)
11648                 ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData,
11649                           ctxt-&gt;input-&gt;cur, base);
11650             }
11651             if (ctxt-&gt;instate == XML_PARSER_EOF)
11652             goto done;
11653             SKIPL(base + 3);
11654             ctxt-&gt;checkIndex = 0;
11655             ctxt-&gt;instate = XML_PARSER_CONTENT;
11656 #ifdef DEBUG_PUSH
11657             xmlGenericError(xmlGenericErrorContext,
11658                 &quot;PP: entering CONTENT\n&quot;);
11659 #endif
11660         }
11661         break;
11662         }
11663             case XML_PARSER_MISC:
11664         SKIP_BLANKS;
11665         if (ctxt-&gt;input-&gt;buf == NULL)
11666             avail = ctxt-&gt;input-&gt;length -
11667                     (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11668         else
11669             avail = xmlBufUse(ctxt-&gt;input-&gt;buf-&gt;buffer) -
11670                     (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11671         if (avail &lt; 2)
11672             goto done;
11673         cur = ctxt-&gt;input-&gt;cur[0];
11674         next = ctxt-&gt;input-&gt;cur[1];
11675             if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;?&#39;)) {
11676             if ((!terminate) &amp;&amp;
11677                 (xmlParseLookupSequence(ctxt, &#39;?&#39;, &#39;&gt;&#39;, 0) &lt; 0)) {
11678                         ctxt-&gt;progressive = XML_PARSER_PI;
11679             goto done;
11680                     }
11681 #ifdef DEBUG_PUSH
11682             xmlGenericError(xmlGenericErrorContext,
11683                 &quot;PP: Parsing PI\n&quot;);
11684 #endif
11685             xmlParsePI(ctxt);
11686             if (ctxt-&gt;instate == XML_PARSER_EOF)
11687             goto done;
11688             ctxt-&gt;instate = XML_PARSER_MISC;
11689                     ctxt-&gt;progressive = 1;
11690             ctxt-&gt;checkIndex = 0;
11691         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
11692             (ctxt-&gt;input-&gt;cur[2] == &#39;-&#39;) &amp;&amp;
11693             (ctxt-&gt;input-&gt;cur[3] == &#39;-&#39;)) {
11694             if ((!terminate) &amp;&amp;
11695                 (xmlParseLookupSequence(ctxt, &#39;-&#39;, &#39;-&#39;, &#39;&gt;&#39;) &lt; 0)) {
11696                         ctxt-&gt;progressive = XML_PARSER_COMMENT;
11697             goto done;
11698                     }
11699 #ifdef DEBUG_PUSH
11700             xmlGenericError(xmlGenericErrorContext,
11701                 &quot;PP: Parsing Comment\n&quot;);
11702 #endif
11703             xmlParseComment(ctxt);
11704             if (ctxt-&gt;instate == XML_PARSER_EOF)
11705             goto done;
11706             ctxt-&gt;instate = XML_PARSER_MISC;
11707                     ctxt-&gt;progressive = 1;
11708             ctxt-&gt;checkIndex = 0;
11709         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
11710             (ctxt-&gt;input-&gt;cur[2] == &#39;D&#39;) &amp;&amp;
11711             (ctxt-&gt;input-&gt;cur[3] == &#39;O&#39;) &amp;&amp;
11712             (ctxt-&gt;input-&gt;cur[4] == &#39;C&#39;) &amp;&amp;
11713             (ctxt-&gt;input-&gt;cur[5] == &#39;T&#39;) &amp;&amp;
11714             (ctxt-&gt;input-&gt;cur[6] == &#39;Y&#39;) &amp;&amp;
11715             (ctxt-&gt;input-&gt;cur[7] == &#39;P&#39;) &amp;&amp;
11716             (ctxt-&gt;input-&gt;cur[8] == &#39;E&#39;)) {
11717             if ((!terminate) &amp;&amp;
11718                 (xmlParseLookupSequence(ctxt, &#39;&gt;&#39;, 0, 0) &lt; 0)) {
11719                         ctxt-&gt;progressive = XML_PARSER_DTD;
11720             goto done;
11721                     }
11722 #ifdef DEBUG_PUSH
11723             xmlGenericError(xmlGenericErrorContext,
11724                 &quot;PP: Parsing internal subset\n&quot;);
11725 #endif
11726             ctxt-&gt;inSubset = 1;
11727                     ctxt-&gt;progressive = 0;
11728             ctxt-&gt;checkIndex = 0;
11729             xmlParseDocTypeDecl(ctxt);
11730             if (ctxt-&gt;instate == XML_PARSER_EOF)
11731             goto done;
11732             if (RAW == &#39;[&#39;) {
11733             ctxt-&gt;instate = XML_PARSER_DTD;
11734 #ifdef DEBUG_PUSH
11735             xmlGenericError(xmlGenericErrorContext,
11736                 &quot;PP: entering DTD\n&quot;);
11737 #endif
11738             } else {
11739             /*
11740              * Create and update the external subset.
11741              */
11742             ctxt-&gt;inSubset = 2;
11743             if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX) &amp;&amp;
11744                 (ctxt-&gt;sax-&gt;externalSubset != NULL))
11745                 ctxt-&gt;sax-&gt;externalSubset(ctxt-&gt;userData,
11746                     ctxt-&gt;intSubName, ctxt-&gt;extSubSystem,
11747                     ctxt-&gt;extSubURI);
11748             ctxt-&gt;inSubset = 0;
11749             xmlCleanSpecialAttr(ctxt);
11750             ctxt-&gt;instate = XML_PARSER_PROLOG;
11751 #ifdef DEBUG_PUSH
11752             xmlGenericError(xmlGenericErrorContext,
11753                 &quot;PP: entering PROLOG\n&quot;);
11754 #endif
11755             }
11756         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
11757                    (avail &lt; 9)) {
11758             goto done;
11759         } else {
11760             ctxt-&gt;instate = XML_PARSER_START_TAG;
11761             ctxt-&gt;progressive = XML_PARSER_START_TAG;
11762             xmlParseGetLasts(ctxt, &amp;lastlt, &amp;lastgt);
11763 #ifdef DEBUG_PUSH
11764             xmlGenericError(xmlGenericErrorContext,
11765                 &quot;PP: entering START_TAG\n&quot;);
11766 #endif
11767         }
11768         break;
11769             case XML_PARSER_PROLOG:
11770         SKIP_BLANKS;
11771         if (ctxt-&gt;input-&gt;buf == NULL)
11772             avail = ctxt-&gt;input-&gt;length - (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11773         else
11774             avail = xmlBufUse(ctxt-&gt;input-&gt;buf-&gt;buffer) -
11775                             (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11776         if (avail &lt; 2)
11777             goto done;
11778         cur = ctxt-&gt;input-&gt;cur[0];
11779         next = ctxt-&gt;input-&gt;cur[1];
11780             if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;?&#39;)) {
11781             if ((!terminate) &amp;&amp;
11782                 (xmlParseLookupSequence(ctxt, &#39;?&#39;, &#39;&gt;&#39;, 0) &lt; 0)) {
11783                         ctxt-&gt;progressive = XML_PARSER_PI;
11784             goto done;
11785                     }
11786 #ifdef DEBUG_PUSH
11787             xmlGenericError(xmlGenericErrorContext,
11788                 &quot;PP: Parsing PI\n&quot;);
11789 #endif
11790             xmlParsePI(ctxt);
11791             if (ctxt-&gt;instate == XML_PARSER_EOF)
11792             goto done;
11793             ctxt-&gt;instate = XML_PARSER_PROLOG;
11794                     ctxt-&gt;progressive = 1;
11795         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
11796             (ctxt-&gt;input-&gt;cur[2] == &#39;-&#39;) &amp;&amp; (ctxt-&gt;input-&gt;cur[3] == &#39;-&#39;)) {
11797             if ((!terminate) &amp;&amp;
11798                 (xmlParseLookupSequence(ctxt, &#39;-&#39;, &#39;-&#39;, &#39;&gt;&#39;) &lt; 0)) {
11799                         ctxt-&gt;progressive = XML_PARSER_COMMENT;
11800             goto done;
11801                     }
11802 #ifdef DEBUG_PUSH
11803             xmlGenericError(xmlGenericErrorContext,
11804                 &quot;PP: Parsing Comment\n&quot;);
11805 #endif
11806             xmlParseComment(ctxt);
11807             if (ctxt-&gt;instate == XML_PARSER_EOF)
11808             goto done;
11809             ctxt-&gt;instate = XML_PARSER_PROLOG;
11810                     ctxt-&gt;progressive = 1;
11811         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
11812                    (avail &lt; 4)) {
11813             goto done;
11814         } else {
11815             ctxt-&gt;instate = XML_PARSER_START_TAG;
11816             if (ctxt-&gt;progressive == 0)
11817             ctxt-&gt;progressive = XML_PARSER_START_TAG;
11818             xmlParseGetLasts(ctxt, &amp;lastlt, &amp;lastgt);
11819 #ifdef DEBUG_PUSH
11820             xmlGenericError(xmlGenericErrorContext,
11821                 &quot;PP: entering START_TAG\n&quot;);
11822 #endif
11823         }
11824         break;
11825             case XML_PARSER_EPILOG:
11826         SKIP_BLANKS;
11827         if (ctxt-&gt;input-&gt;buf == NULL)
11828             avail = ctxt-&gt;input-&gt;length - (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11829         else
11830             avail = xmlBufUse(ctxt-&gt;input-&gt;buf-&gt;buffer) -
11831                             (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11832         if (avail &lt; 2)
11833             goto done;
11834         cur = ctxt-&gt;input-&gt;cur[0];
11835         next = ctxt-&gt;input-&gt;cur[1];
11836             if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;?&#39;)) {
11837             if ((!terminate) &amp;&amp;
11838                 (xmlParseLookupSequence(ctxt, &#39;?&#39;, &#39;&gt;&#39;, 0) &lt; 0)) {
11839                         ctxt-&gt;progressive = XML_PARSER_PI;
11840             goto done;
11841                     }
11842 #ifdef DEBUG_PUSH
11843             xmlGenericError(xmlGenericErrorContext,
11844                 &quot;PP: Parsing PI\n&quot;);
11845 #endif
11846             xmlParsePI(ctxt);
11847             if (ctxt-&gt;instate == XML_PARSER_EOF)
11848             goto done;
11849             ctxt-&gt;instate = XML_PARSER_EPILOG;
11850                     ctxt-&gt;progressive = 1;
11851         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
11852             (ctxt-&gt;input-&gt;cur[2] == &#39;-&#39;) &amp;&amp; (ctxt-&gt;input-&gt;cur[3] == &#39;-&#39;)) {
11853             if ((!terminate) &amp;&amp;
11854                 (xmlParseLookupSequence(ctxt, &#39;-&#39;, &#39;-&#39;, &#39;&gt;&#39;) &lt; 0)) {
11855                         ctxt-&gt;progressive = XML_PARSER_COMMENT;
11856             goto done;
11857                     }
11858 #ifdef DEBUG_PUSH
11859             xmlGenericError(xmlGenericErrorContext,
11860                 &quot;PP: Parsing Comment\n&quot;);
11861 #endif
11862             xmlParseComment(ctxt);
11863             if (ctxt-&gt;instate == XML_PARSER_EOF)
11864             goto done;
11865             ctxt-&gt;instate = XML_PARSER_EPILOG;
11866                     ctxt-&gt;progressive = 1;
11867         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
11868                    (avail &lt; 4)) {
11869             goto done;
11870         } else {
11871             xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);
11872             xmlHaltParser(ctxt);
11873 #ifdef DEBUG_PUSH
11874             xmlGenericError(xmlGenericErrorContext,
11875                 &quot;PP: entering EOF\n&quot;);
11876 #endif
11877             if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;endDocument != NULL))
11878             ctxt-&gt;sax-&gt;endDocument(ctxt-&gt;userData);
11879             goto done;
11880         }
11881         break;
11882             case XML_PARSER_DTD: {
11883             /*
11884          * Sorry but progressive parsing of the internal subset
11885          * is not expected to be supported. We first check that
11886          * the full content of the internal subset is available and
11887          * the parsing is launched only at that point.
11888          * Internal subset ends up with &quot;&#39;]&#39; S? &#39;&gt;&#39;&quot; in an unescaped
11889          * section and not in a &#39;]]&gt;&#39; sequence which are conditional
11890          * sections (whoever argued to keep that crap in XML deserve
11891          * a place in hell !).
11892          */
11893         int base, i;
11894         xmlChar *buf;
11895             xmlChar quote = 0;
11896                 size_t use;
11897 
11898         base = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
11899         if (base &lt; 0) return(0);
11900         if (ctxt-&gt;checkIndex &gt; base)
11901             base = ctxt-&gt;checkIndex;
11902         buf = xmlBufContent(ctxt-&gt;input-&gt;buf-&gt;buffer);
11903                 use = xmlBufUse(ctxt-&gt;input-&gt;buf-&gt;buffer);
11904         for (;(unsigned int) base &lt; use; base++) {
11905             if (quote != 0) {
11906                 if (buf[base] == quote)
11907                 quote = 0;
11908             continue;
11909             }
11910             if ((quote == 0) &amp;&amp; (buf[base] == &#39;&lt;&#39;)) {
11911                 int found  = 0;
11912             /* special handling of comments */
11913                 if (((unsigned int) base + 4 &lt; use) &amp;&amp;
11914                 (buf[base + 1] == &#39;!&#39;) &amp;&amp;
11915                 (buf[base + 2] == &#39;-&#39;) &amp;&amp;
11916                 (buf[base + 3] == &#39;-&#39;)) {
11917                 for (;(unsigned int) base + 3 &lt; use; base++) {
11918                 if ((buf[base] == &#39;-&#39;) &amp;&amp;
11919                     (buf[base + 1] == &#39;-&#39;) &amp;&amp;
11920                     (buf[base + 2] == &#39;&gt;&#39;)) {
11921                     found = 1;
11922                     base += 2;
11923                     break;
11924                 }
11925                     }
11926                 if (!found) {
11927 #if 0
11928                     fprintf(stderr, &quot;unfinished comment\n&quot;);
11929 #endif
11930                     break; /* for */
11931                     }
11932                     continue;
11933             }
11934             }
11935             if (buf[base] == &#39;&quot;&#39;) {
11936                 quote = &#39;&quot;&#39;;
11937             continue;
11938             }
11939             if (buf[base] == &#39;\&#39;&#39;) {
11940                 quote = &#39;\&#39;&#39;;
11941             continue;
11942             }
11943             if (buf[base] == &#39;]&#39;) {
11944 #if 0
11945                 fprintf(stderr, &quot;%c%c%c%c: &quot;, buf[base],
11946                     buf[base + 1], buf[base + 2], buf[base + 3]);
11947 #endif
11948                 if ((unsigned int) base +1 &gt;= use)
11949                 break;
11950             if (buf[base + 1] == &#39;]&#39;) {
11951                 /* conditional crap, skip both &#39;]&#39; ! */
11952                 base++;
11953                 continue;
11954             }
11955                 for (i = 1; (unsigned int) base + i &lt; use; i++) {
11956                 if (buf[base + i] == &#39;&gt;&#39;) {
11957 #if 0
11958                     fprintf(stderr, &quot;found\n&quot;);
11959 #endif
11960                     goto found_end_int_subset;
11961                 }
11962                 if (!IS_BLANK_CH(buf[base + i])) {
11963 #if 0
11964                     fprintf(stderr, &quot;not found\n&quot;);
11965 #endif
11966                     goto not_end_of_int_subset;
11967                 }
11968             }
11969 #if 0
11970             fprintf(stderr, &quot;end of stream\n&quot;);
11971 #endif
11972                 break;
11973 
11974             }
11975 not_end_of_int_subset:
11976                     continue; /* for */
11977         }
11978         /*
11979          * We didn&#39;t found the end of the Internal subset
11980          */
11981                 if (quote == 0)
11982                     ctxt-&gt;checkIndex = base;
11983                 else
11984                     ctxt-&gt;checkIndex = 0;
11985 #ifdef DEBUG_PUSH
11986         if (next == 0)
11987             xmlGenericError(xmlGenericErrorContext,
11988                 &quot;PP: lookup of int subset end filed\n&quot;);
11989 #endif
11990             goto done;
11991 
11992 found_end_int_subset:
11993                 ctxt-&gt;checkIndex = 0;
11994         xmlParseInternalSubset(ctxt);
11995         if (ctxt-&gt;instate == XML_PARSER_EOF)
11996             goto done;
11997         ctxt-&gt;inSubset = 2;
11998         if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX) &amp;&amp;
11999             (ctxt-&gt;sax-&gt;externalSubset != NULL))
12000             ctxt-&gt;sax-&gt;externalSubset(ctxt-&gt;userData, ctxt-&gt;intSubName,
12001                 ctxt-&gt;extSubSystem, ctxt-&gt;extSubURI);
12002         ctxt-&gt;inSubset = 0;
12003         xmlCleanSpecialAttr(ctxt);
12004         if (ctxt-&gt;instate == XML_PARSER_EOF)
12005             goto done;
12006         ctxt-&gt;instate = XML_PARSER_PROLOG;
12007         ctxt-&gt;checkIndex = 0;
12008 #ifdef DEBUG_PUSH
12009         xmlGenericError(xmlGenericErrorContext,
12010             &quot;PP: entering PROLOG\n&quot;);
12011 #endif
12012                 break;
12013         }
12014             case XML_PARSER_COMMENT:
12015         xmlGenericError(xmlGenericErrorContext,
12016             &quot;PP: internal error, state == COMMENT\n&quot;);
12017         ctxt-&gt;instate = XML_PARSER_CONTENT;
12018 #ifdef DEBUG_PUSH
12019         xmlGenericError(xmlGenericErrorContext,
12020             &quot;PP: entering CONTENT\n&quot;);
12021 #endif
12022         break;
12023             case XML_PARSER_IGNORE:
12024         xmlGenericError(xmlGenericErrorContext,
12025             &quot;PP: internal error, state == IGNORE&quot;);
12026             ctxt-&gt;instate = XML_PARSER_DTD;
12027 #ifdef DEBUG_PUSH
12028         xmlGenericError(xmlGenericErrorContext,
12029             &quot;PP: entering DTD\n&quot;);
12030 #endif
12031             break;
12032             case XML_PARSER_PI:
12033         xmlGenericError(xmlGenericErrorContext,
12034             &quot;PP: internal error, state == PI\n&quot;);
12035         ctxt-&gt;instate = XML_PARSER_CONTENT;
12036 #ifdef DEBUG_PUSH
12037         xmlGenericError(xmlGenericErrorContext,
12038             &quot;PP: entering CONTENT\n&quot;);
12039 #endif
12040         break;
12041             case XML_PARSER_ENTITY_DECL:
12042         xmlGenericError(xmlGenericErrorContext,
12043             &quot;PP: internal error, state == ENTITY_DECL\n&quot;);
12044         ctxt-&gt;instate = XML_PARSER_DTD;
12045 #ifdef DEBUG_PUSH
12046         xmlGenericError(xmlGenericErrorContext,
12047             &quot;PP: entering DTD\n&quot;);
12048 #endif
12049         break;
12050             case XML_PARSER_ENTITY_VALUE:
12051         xmlGenericError(xmlGenericErrorContext,
12052             &quot;PP: internal error, state == ENTITY_VALUE\n&quot;);
12053         ctxt-&gt;instate = XML_PARSER_CONTENT;
12054 #ifdef DEBUG_PUSH
12055         xmlGenericError(xmlGenericErrorContext,
12056             &quot;PP: entering DTD\n&quot;);
12057 #endif
12058         break;
12059             case XML_PARSER_ATTRIBUTE_VALUE:
12060         xmlGenericError(xmlGenericErrorContext,
12061             &quot;PP: internal error, state == ATTRIBUTE_VALUE\n&quot;);
12062         ctxt-&gt;instate = XML_PARSER_START_TAG;
12063 #ifdef DEBUG_PUSH
12064         xmlGenericError(xmlGenericErrorContext,
12065             &quot;PP: entering START_TAG\n&quot;);
12066 #endif
12067         break;
12068             case XML_PARSER_SYSTEM_LITERAL:
12069         xmlGenericError(xmlGenericErrorContext,
12070             &quot;PP: internal error, state == SYSTEM_LITERAL\n&quot;);
12071         ctxt-&gt;instate = XML_PARSER_START_TAG;
12072 #ifdef DEBUG_PUSH
12073         xmlGenericError(xmlGenericErrorContext,
12074             &quot;PP: entering START_TAG\n&quot;);
12075 #endif
12076         break;
12077             case XML_PARSER_PUBLIC_LITERAL:
12078         xmlGenericError(xmlGenericErrorContext,
12079             &quot;PP: internal error, state == PUBLIC_LITERAL\n&quot;);
12080         ctxt-&gt;instate = XML_PARSER_START_TAG;
12081 #ifdef DEBUG_PUSH
12082         xmlGenericError(xmlGenericErrorContext,
12083             &quot;PP: entering START_TAG\n&quot;);
12084 #endif
12085         break;
12086     }
12087     }
12088 done:
12089 #ifdef DEBUG_PUSH
12090     xmlGenericError(xmlGenericErrorContext, &quot;PP: done %d\n&quot;, ret);
12091 #endif
12092     return(ret);
12093 encoding_error:
12094     {
12095         char buffer[150];
12096 
12097     snprintf(buffer, 149, &quot;Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n&quot;,
12098             ctxt-&gt;input-&gt;cur[0], ctxt-&gt;input-&gt;cur[1],
12099             ctxt-&gt;input-&gt;cur[2], ctxt-&gt;input-&gt;cur[3]);
12100     __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
12101              &quot;Input is not proper UTF-8, indicate encoding !\n%s&quot;,
12102              BAD_CAST buffer, NULL);
12103     }
12104     return(0);
12105 }
12106 
12107 /**
12108  * xmlParseCheckTransition:
12109  * @ctxt:  an XML parser context
12110  * @chunk:  a char array
12111  * @size:  the size in byte of the chunk
12112  *
12113  * Check depending on the current parser state if the chunk given must be
12114  * processed immediately or one need more data to advance on parsing.
12115  *
12116  * Returns -1 in case of error, 0 if the push is not needed and 1 if needed
12117  */
12118 static int
12119 xmlParseCheckTransition(xmlParserCtxtPtr ctxt, const char *chunk, int size) {
12120     if ((ctxt == NULL) || (chunk == NULL) || (size &lt; 0))
12121         return(-1);
12122     if (ctxt-&gt;instate == XML_PARSER_START_TAG) {
12123         if (memchr(chunk, &#39;&gt;&#39;, size) != NULL)
12124             return(1);
12125         return(0);
12126     }
12127     if (ctxt-&gt;progressive == XML_PARSER_COMMENT) {
12128         if (memchr(chunk, &#39;&gt;&#39;, size) != NULL)
12129             return(1);
12130         return(0);
12131     }
12132     if (ctxt-&gt;instate == XML_PARSER_CDATA_SECTION) {
12133         if (memchr(chunk, &#39;&gt;&#39;, size) != NULL)
12134             return(1);
12135         return(0);
12136     }
12137     if (ctxt-&gt;progressive == XML_PARSER_PI) {
12138         if (memchr(chunk, &#39;&gt;&#39;, size) != NULL)
12139             return(1);
12140         return(0);
12141     }
12142     if (ctxt-&gt;instate == XML_PARSER_END_TAG) {
12143         if (memchr(chunk, &#39;&gt;&#39;, size) != NULL)
12144             return(1);
12145         return(0);
12146     }
12147     if ((ctxt-&gt;progressive == XML_PARSER_DTD) ||
12148         (ctxt-&gt;instate == XML_PARSER_DTD)) {
12149         if (memchr(chunk, &#39;&gt;&#39;, size) != NULL)
12150             return(1);
12151         return(0);
12152     }
12153     return(1);
12154 }
12155 
12156 /**
12157  * xmlParseChunk:
12158  * @ctxt:  an XML parser context
12159  * @chunk:  an char array
12160  * @size:  the size in byte of the chunk
12161  * @terminate:  last chunk indicator
12162  *
12163  * Parse a Chunk of memory
12164  *
12165  * Returns zero if no error, the xmlParserErrors otherwise.
12166  */
12167 int
12168 xmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size,
12169               int terminate) {
12170     int end_in_lf = 0;
12171     int remain = 0;
12172     size_t old_avail = 0;
12173     size_t avail = 0;
12174 
12175     if (ctxt == NULL)
12176         return(XML_ERR_INTERNAL_ERROR);
12177     if ((ctxt-&gt;errNo != XML_ERR_OK) &amp;&amp; (ctxt-&gt;disableSAX == 1))
12178         return(ctxt-&gt;errNo);
12179     if (ctxt-&gt;instate == XML_PARSER_EOF)
12180         return(-1);
12181     if (ctxt-&gt;instate == XML_PARSER_START)
12182         xmlDetectSAX2(ctxt);
12183     if ((size &gt; 0) &amp;&amp; (chunk != NULL) &amp;&amp; (!terminate) &amp;&amp;
12184         (chunk[size - 1] == &#39;\r&#39;)) {
12185     end_in_lf = 1;
12186     size--;
12187     }
12188 
12189 xmldecl_done:
12190 
12191     if ((size &gt; 0) &amp;&amp; (chunk != NULL) &amp;&amp; (ctxt-&gt;input != NULL) &amp;&amp;
12192         (ctxt-&gt;input-&gt;buf != NULL) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF))  {
12193     size_t base = xmlBufGetInputBase(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input);
12194     size_t cur = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
12195     int res;
12196 
12197         old_avail = xmlBufUse(ctxt-&gt;input-&gt;buf-&gt;buffer);
12198         /*
12199          * Specific handling if we autodetected an encoding, we should not
12200          * push more than the first line ... which depend on the encoding
12201          * And only push the rest once the final encoding was detected
12202          */
12203         if ((ctxt-&gt;instate == XML_PARSER_START) &amp;&amp; (ctxt-&gt;input != NULL) &amp;&amp;
12204             (ctxt-&gt;input-&gt;buf != NULL) &amp;&amp; (ctxt-&gt;input-&gt;buf-&gt;encoder != NULL)) {
12205             unsigned int len = 45;
12206 
12207             if ((xmlStrcasestr(BAD_CAST ctxt-&gt;input-&gt;buf-&gt;encoder-&gt;name,
12208                                BAD_CAST &quot;UTF-16&quot;)) ||
12209                 (xmlStrcasestr(BAD_CAST ctxt-&gt;input-&gt;buf-&gt;encoder-&gt;name,
12210                                BAD_CAST &quot;UTF16&quot;)))
12211                 len = 90;
12212             else if ((xmlStrcasestr(BAD_CAST ctxt-&gt;input-&gt;buf-&gt;encoder-&gt;name,
12213                                     BAD_CAST &quot;UCS-4&quot;)) ||
12214                      (xmlStrcasestr(BAD_CAST ctxt-&gt;input-&gt;buf-&gt;encoder-&gt;name,
12215                                     BAD_CAST &quot;UCS4&quot;)))
12216                 len = 180;
12217 
12218             if (ctxt-&gt;input-&gt;buf-&gt;rawconsumed &lt; len)
12219                 len -= ctxt-&gt;input-&gt;buf-&gt;rawconsumed;
12220 
12221             /*
12222              * Change size for reading the initial declaration only
12223              * if size is greater than len. Otherwise, memmove in xmlBufferAdd
12224              * will blindly copy extra bytes from memory.
12225              */
12226             if ((unsigned int) size &gt; len) {
12227                 remain = size - len;
12228                 size = len;
12229             } else {
12230                 remain = 0;
12231             }
12232         }
12233     res = xmlParserInputBufferPush(ctxt-&gt;input-&gt;buf, size, chunk);
12234     if (res &lt; 0) {
12235         ctxt-&gt;errNo = XML_PARSER_EOF;
12236         xmlHaltParser(ctxt);
12237         return (XML_PARSER_EOF);
12238     }
12239         xmlBufSetInputBaseCur(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input, base, cur);
12240 #ifdef DEBUG_PUSH
12241     xmlGenericError(xmlGenericErrorContext, &quot;PP: pushed %d\n&quot;, size);
12242 #endif
12243 
12244     } else if (ctxt-&gt;instate != XML_PARSER_EOF) {
12245     if ((ctxt-&gt;input != NULL) &amp;&amp; ctxt-&gt;input-&gt;buf != NULL) {
12246         xmlParserInputBufferPtr in = ctxt-&gt;input-&gt;buf;
12247         if ((in-&gt;encoder != NULL) &amp;&amp; (in-&gt;buffer != NULL) &amp;&amp;
12248             (in-&gt;raw != NULL)) {
12249         int nbchars;
12250         size_t base = xmlBufGetInputBase(in-&gt;buffer, ctxt-&gt;input);
12251         size_t current = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
12252 
12253         nbchars = xmlCharEncInput(in, terminate);
12254         if (nbchars &lt; 0) {
12255             /* TODO 2.6.0 */
12256             xmlGenericError(xmlGenericErrorContext,
12257                     &quot;xmlParseChunk: encoder error\n&quot;);
12258                     xmlHaltParser(ctxt);
12259             return(XML_ERR_INVALID_ENCODING);
12260         }
12261         xmlBufSetInputBaseCur(in-&gt;buffer, ctxt-&gt;input, base, current);
12262         }
12263     }
12264     }
12265     if (remain != 0) {
12266         xmlParseTryOrFinish(ctxt, 0);
12267     } else {
12268         if ((ctxt-&gt;input != NULL) &amp;&amp; (ctxt-&gt;input-&gt;buf != NULL))
12269             avail = xmlBufUse(ctxt-&gt;input-&gt;buf-&gt;buffer);
12270         /*
12271          * Depending on the current state it may not be such
12272          * a good idea to try parsing if there is nothing in the chunk
12273          * which would be worth doing a parser state transition and we
12274          * need to wait for more data
12275          */
12276         if ((terminate) || (avail &gt; XML_MAX_TEXT_LENGTH) ||
12277             (old_avail == 0) || (avail == 0) ||
12278             (xmlParseCheckTransition(ctxt,
12279                        (const char *)&amp;ctxt-&gt;input-&gt;base[old_avail],
12280                                      avail - old_avail)))
12281             xmlParseTryOrFinish(ctxt, terminate);
12282     }
12283     if (ctxt-&gt;instate == XML_PARSER_EOF)
12284         return(ctxt-&gt;errNo);
12285 
12286     if ((ctxt-&gt;input != NULL) &amp;&amp;
12287          (((ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur) &gt; XML_MAX_LOOKUP_LIMIT) ||
12288          ((ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base) &gt; XML_MAX_LOOKUP_LIMIT)) &amp;&amp;
12289         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
12290         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, &quot;Huge input lookup&quot;);
12291         xmlHaltParser(ctxt);
12292     }
12293     if ((ctxt-&gt;errNo != XML_ERR_OK) &amp;&amp; (ctxt-&gt;disableSAX == 1))
12294         return(ctxt-&gt;errNo);
12295 
12296     if (remain != 0) {
12297         chunk += size;
12298         size = remain;
12299         remain = 0;
12300         goto xmldecl_done;
12301     }
12302     if ((end_in_lf == 1) &amp;&amp; (ctxt-&gt;input != NULL) &amp;&amp;
12303         (ctxt-&gt;input-&gt;buf != NULL)) {
12304     size_t base = xmlBufGetInputBase(ctxt-&gt;input-&gt;buf-&gt;buffer,
12305                      ctxt-&gt;input);
12306     size_t current = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
12307 
12308     xmlParserInputBufferPush(ctxt-&gt;input-&gt;buf, 1, &quot;\r&quot;);
12309 
12310     xmlBufSetInputBaseCur(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input,
12311                   base, current);
12312     }
12313     if (terminate) {
12314     /*
12315      * Check for termination
12316      */
12317     int cur_avail = 0;
12318 
12319     if (ctxt-&gt;input != NULL) {
12320         if (ctxt-&gt;input-&gt;buf == NULL)
12321         cur_avail = ctxt-&gt;input-&gt;length -
12322                 (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
12323         else
12324         cur_avail = xmlBufUse(ctxt-&gt;input-&gt;buf-&gt;buffer) -
12325                           (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
12326     }
12327 
12328     if ((ctxt-&gt;instate != XML_PARSER_EOF) &amp;&amp;
12329         (ctxt-&gt;instate != XML_PARSER_EPILOG)) {
12330         xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);
12331     }
12332     if ((ctxt-&gt;instate == XML_PARSER_EPILOG) &amp;&amp; (cur_avail &gt; 0)) {
12333         xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);
12334     }
12335     if (ctxt-&gt;instate != XML_PARSER_EOF) {
12336         if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;endDocument != NULL))
12337         ctxt-&gt;sax-&gt;endDocument(ctxt-&gt;userData);
12338     }
12339     ctxt-&gt;instate = XML_PARSER_EOF;
12340     }
12341     if (ctxt-&gt;wellFormed == 0)
12342     return((xmlParserErrors) ctxt-&gt;errNo);
12343     else
12344         return(0);
12345 }
12346 
12347 /************************************************************************
12348  *                                  *
12349  *      I/O front end functions to the parser           *
12350  *                                  *
12351  ************************************************************************/
12352 
12353 /**
12354  * xmlCreatePushParserCtxt:
12355  * @sax:  a SAX handler
12356  * @user_data:  The user data returned on SAX callbacks
12357  * @chunk:  a pointer to an array of chars
12358  * @size:  number of chars in the array
12359  * @filename:  an optional file name or URI
12360  *
12361  * Create a parser context for using the XML parser in push mode.
12362  * If @buffer and @size are non-NULL, the data is used to detect
12363  * the encoding.  The remaining characters will be parsed so they
12364  * don&#39;t need to be fed in again through xmlParseChunk.
12365  * To allow content encoding detection, @size should be &gt;= 4
12366  * The value of @filename is used for fetching external entities
12367  * and error/warning reports.
12368  *
12369  * Returns the new parser context or NULL
12370  */
12371 
12372 xmlParserCtxtPtr
12373 xmlCreatePushParserCtxt(xmlSAXHandlerPtr sax, void *user_data,
12374                         const char *chunk, int size, const char *filename) {
12375     xmlParserCtxtPtr ctxt;
12376     xmlParserInputPtr inputStream;
12377     xmlParserInputBufferPtr buf;
12378     xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;
12379 
12380     /*
12381      * plug some encoding conversion routines
12382      */
12383     if ((chunk != NULL) &amp;&amp; (size &gt;= 4))
12384     enc = xmlDetectCharEncoding((const xmlChar *) chunk, size);
12385 
12386     buf = xmlAllocParserInputBuffer(enc);
12387     if (buf == NULL) return(NULL);
12388 
12389     ctxt = xmlNewParserCtxt();
12390     if (ctxt == NULL) {
12391         xmlErrMemory(NULL, &quot;creating parser: out of memory\n&quot;);
12392     xmlFreeParserInputBuffer(buf);
12393     return(NULL);
12394     }
12395     ctxt-&gt;dictNames = 1;
12396     if (sax != NULL) {
12397 #ifdef LIBXML_SAX1_ENABLED
12398     if (ctxt-&gt;sax != (xmlSAXHandlerPtr) &amp;xmlDefaultSAXHandler)
12399 #endif /* LIBXML_SAX1_ENABLED */
12400         xmlFree(ctxt-&gt;sax);
12401     ctxt-&gt;sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(xmlSAXHandler));
12402     if (ctxt-&gt;sax == NULL) {
12403         xmlErrMemory(ctxt, NULL);
12404         xmlFreeParserInputBuffer(buf);
12405         xmlFreeParserCtxt(ctxt);
12406         return(NULL);
12407     }
12408     memset(ctxt-&gt;sax, 0, sizeof(xmlSAXHandler));
12409     if (sax-&gt;initialized == XML_SAX2_MAGIC)
12410         memcpy(ctxt-&gt;sax, sax, sizeof(xmlSAXHandler));
12411     else
12412         memcpy(ctxt-&gt;sax, sax, sizeof(xmlSAXHandlerV1));
12413     if (user_data != NULL)
12414         ctxt-&gt;userData = user_data;
12415     }
12416     if (filename == NULL) {
12417     ctxt-&gt;directory = NULL;
12418     } else {
12419         ctxt-&gt;directory = xmlParserGetDirectory(filename);
12420     }
12421 
12422     inputStream = xmlNewInputStream(ctxt);
12423     if (inputStream == NULL) {
12424     xmlFreeParserCtxt(ctxt);
12425     xmlFreeParserInputBuffer(buf);
12426     return(NULL);
12427     }
12428 
12429     if (filename == NULL)
12430     inputStream-&gt;filename = NULL;
12431     else {
12432     inputStream-&gt;filename = (char *)
12433         xmlCanonicPath((const xmlChar *) filename);
12434     if (inputStream-&gt;filename == NULL) {
12435         xmlFreeParserCtxt(ctxt);
12436         xmlFreeParserInputBuffer(buf);
12437         return(NULL);
12438     }
12439     }
12440     inputStream-&gt;buf = buf;
12441     xmlBufResetInput(inputStream-&gt;buf-&gt;buffer, inputStream);
12442     inputPush(ctxt, inputStream);
12443 
12444     /*
12445      * If the caller didn&#39;t provide an initial &#39;chunk&#39; for determining
12446      * the encoding, we set the context to XML_CHAR_ENCODING_NONE so
12447      * that it can be automatically determined later
12448      */
12449     if ((size == 0) || (chunk == NULL)) {
12450     ctxt-&gt;charset = XML_CHAR_ENCODING_NONE;
12451     } else if ((ctxt-&gt;input != NULL) &amp;&amp; (ctxt-&gt;input-&gt;buf != NULL)) {
12452     size_t base = xmlBufGetInputBase(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input);
12453     size_t cur = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
12454 
12455     xmlParserInputBufferPush(ctxt-&gt;input-&gt;buf, size, chunk);
12456 
12457         xmlBufSetInputBaseCur(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input, base, cur);
12458 #ifdef DEBUG_PUSH
12459     xmlGenericError(xmlGenericErrorContext, &quot;PP: pushed %d\n&quot;, size);
12460 #endif
12461     }
12462 
12463     if (enc != XML_CHAR_ENCODING_NONE) {
12464         xmlSwitchEncoding(ctxt, enc);
12465     }
12466 
12467     return(ctxt);
12468 }
12469 #endif /* LIBXML_PUSH_ENABLED */
12470 
12471 /**
12472  * xmlHaltParser:
12473  * @ctxt:  an XML parser context
12474  *
12475  * Blocks further parser processing don&#39;t override error
12476  * for internal use
12477  */
12478 static void
12479 xmlHaltParser(xmlParserCtxtPtr ctxt) {
12480     if (ctxt == NULL)
12481         return;
12482     ctxt-&gt;instate = XML_PARSER_EOF;
12483     ctxt-&gt;disableSAX = 1;
12484     while (ctxt-&gt;inputNr &gt; 1)
12485         xmlFreeInputStream(inputPop(ctxt));
12486     if (ctxt-&gt;input != NULL) {
12487         /*
12488      * in case there was a specific allocation deallocate before
12489      * overriding base
12490      */
12491         if (ctxt-&gt;input-&gt;free != NULL) {
12492         ctxt-&gt;input-&gt;free((xmlChar *) ctxt-&gt;input-&gt;base);
12493         ctxt-&gt;input-&gt;free = NULL;
12494     }
12495         if (ctxt-&gt;input-&gt;buf != NULL) {
12496             xmlFreeParserInputBuffer(ctxt-&gt;input-&gt;buf);
12497             ctxt-&gt;input-&gt;buf = NULL;
12498         }
12499     ctxt-&gt;input-&gt;cur = BAD_CAST&quot;&quot;;
12500         ctxt-&gt;input-&gt;length = 0;
12501     ctxt-&gt;input-&gt;base = ctxt-&gt;input-&gt;cur;
12502         ctxt-&gt;input-&gt;end = ctxt-&gt;input-&gt;cur;
12503     }
12504 }
12505 
12506 /**
12507  * xmlStopParser:
12508  * @ctxt:  an XML parser context
12509  *
12510  * Blocks further parser processing
12511  */
12512 void
12513 xmlStopParser(xmlParserCtxtPtr ctxt) {
12514     if (ctxt == NULL)
12515         return;
12516     xmlHaltParser(ctxt);
12517     ctxt-&gt;errNo = XML_ERR_USER_STOP;
12518 }
12519 
12520 /**
12521  * xmlCreateIOParserCtxt:
12522  * @sax:  a SAX handler
12523  * @user_data:  The user data returned on SAX callbacks
12524  * @ioread:  an I/O read function
12525  * @ioclose:  an I/O close function
12526  * @ioctx:  an I/O handler
12527  * @enc:  the charset encoding if known
12528  *
12529  * Create a parser context for using the XML parser with an existing
12530  * I/O stream
12531  *
12532  * Returns the new parser context or NULL
12533  */
12534 xmlParserCtxtPtr
12535 xmlCreateIOParserCtxt(xmlSAXHandlerPtr sax, void *user_data,
12536     xmlInputReadCallback   ioread, xmlInputCloseCallback  ioclose,
12537     void *ioctx, xmlCharEncoding enc) {
12538     xmlParserCtxtPtr ctxt;
12539     xmlParserInputPtr inputStream;
12540     xmlParserInputBufferPtr buf;
12541 
12542     if (ioread == NULL) return(NULL);
12543 
12544     buf = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx, enc);
12545     if (buf == NULL) {
12546         if (ioclose != NULL)
12547             ioclose(ioctx);
12548         return (NULL);
12549     }
12550 
12551     ctxt = xmlNewParserCtxt();
12552     if (ctxt == NULL) {
12553     xmlFreeParserInputBuffer(buf);
12554     return(NULL);
12555     }
12556     if (sax != NULL) {
12557 #ifdef LIBXML_SAX1_ENABLED
12558     if (ctxt-&gt;sax != (xmlSAXHandlerPtr) &amp;xmlDefaultSAXHandler)
12559 #endif /* LIBXML_SAX1_ENABLED */
12560         xmlFree(ctxt-&gt;sax);
12561     ctxt-&gt;sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(xmlSAXHandler));
12562     if (ctxt-&gt;sax == NULL) {
12563         xmlErrMemory(ctxt, NULL);
12564         xmlFreeParserCtxt(ctxt);
12565         return(NULL);
12566     }
12567     memset(ctxt-&gt;sax, 0, sizeof(xmlSAXHandler));
12568     if (sax-&gt;initialized == XML_SAX2_MAGIC)
12569         memcpy(ctxt-&gt;sax, sax, sizeof(xmlSAXHandler));
12570     else
12571         memcpy(ctxt-&gt;sax, sax, sizeof(xmlSAXHandlerV1));
12572     if (user_data != NULL)
12573         ctxt-&gt;userData = user_data;
12574     }
12575 
12576     inputStream = xmlNewIOInputStream(ctxt, buf, enc);
12577     if (inputStream == NULL) {
12578     xmlFreeParserCtxt(ctxt);
12579     return(NULL);
12580     }
12581     inputPush(ctxt, inputStream);
12582 
12583     return(ctxt);
12584 }
12585 
12586 #ifdef LIBXML_VALID_ENABLED
12587 /************************************************************************
12588  *                                  *
12589  *      Front ends when parsing a DTD               *
12590  *                                  *
12591  ************************************************************************/
12592 
12593 /**
12594  * xmlIOParseDTD:
12595  * @sax:  the SAX handler block or NULL
12596  * @input:  an Input Buffer
12597  * @enc:  the charset encoding if known
12598  *
12599  * Load and parse a DTD
12600  *
12601  * Returns the resulting xmlDtdPtr or NULL in case of error.
12602  * @input will be freed by the function in any case.
12603  */
12604 
12605 xmlDtdPtr
12606 xmlIOParseDTD(xmlSAXHandlerPtr sax, xmlParserInputBufferPtr input,
12607           xmlCharEncoding enc) {
12608     xmlDtdPtr ret = NULL;
12609     xmlParserCtxtPtr ctxt;
12610     xmlParserInputPtr pinput = NULL;
12611     xmlChar start[4];
12612 
12613     if (input == NULL)
12614     return(NULL);
12615 
12616     ctxt = xmlNewParserCtxt();
12617     if (ctxt == NULL) {
12618         xmlFreeParserInputBuffer(input);
12619     return(NULL);
12620     }
12621 
12622     /* We are loading a DTD */
12623     ctxt-&gt;options |= XML_PARSE_DTDLOAD;
12624 
12625     /*
12626      * Set-up the SAX context
12627      */
12628     if (sax != NULL) {
12629     if (ctxt-&gt;sax != NULL)
12630         xmlFree(ctxt-&gt;sax);
12631         ctxt-&gt;sax = sax;
12632         ctxt-&gt;userData = ctxt;
12633     }
12634     xmlDetectSAX2(ctxt);
12635 
12636     /*
12637      * generate a parser input from the I/O handler
12638      */
12639 
12640     pinput = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
12641     if (pinput == NULL) {
12642         if (sax != NULL) ctxt-&gt;sax = NULL;
12643         xmlFreeParserInputBuffer(input);
12644     xmlFreeParserCtxt(ctxt);
12645     return(NULL);
12646     }
12647 
12648     /*
12649      * plug some encoding conversion routines here.
12650      */
12651     if (xmlPushInput(ctxt, pinput) &lt; 0) {
12652         if (sax != NULL) ctxt-&gt;sax = NULL;
12653     xmlFreeParserCtxt(ctxt);
12654     return(NULL);
12655     }
12656     if (enc != XML_CHAR_ENCODING_NONE) {
12657         xmlSwitchEncoding(ctxt, enc);
12658     }
12659 
12660     pinput-&gt;filename = NULL;
12661     pinput-&gt;line = 1;
12662     pinput-&gt;col = 1;
12663     pinput-&gt;base = ctxt-&gt;input-&gt;cur;
12664     pinput-&gt;cur = ctxt-&gt;input-&gt;cur;
12665     pinput-&gt;free = NULL;
12666 
12667     /*
12668      * let&#39;s parse that entity knowing it&#39;s an external subset.
12669      */
12670     ctxt-&gt;inSubset = 2;
12671     ctxt-&gt;myDoc = xmlNewDoc(BAD_CAST &quot;1.0&quot;);
12672     if (ctxt-&gt;myDoc == NULL) {
12673     xmlErrMemory(ctxt, &quot;New Doc failed&quot;);
12674     return(NULL);
12675     }
12676     ctxt-&gt;myDoc-&gt;properties = XML_DOC_INTERNAL;
12677     ctxt-&gt;myDoc-&gt;extSubset = xmlNewDtd(ctxt-&gt;myDoc, BAD_CAST &quot;none&quot;,
12678                                    BAD_CAST &quot;none&quot;, BAD_CAST &quot;none&quot;);
12679 
12680     if ((enc == XML_CHAR_ENCODING_NONE) &amp;&amp;
12681         ((ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur) &gt;= 4)) {
12682     /*
12683      * Get the 4 first bytes and decode the charset
12684      * if enc != XML_CHAR_ENCODING_NONE
12685      * plug some encoding conversion routines.
12686      */
12687     start[0] = RAW;
12688     start[1] = NXT(1);
12689     start[2] = NXT(2);
12690     start[3] = NXT(3);
12691     enc = xmlDetectCharEncoding(start, 4);
12692     if (enc != XML_CHAR_ENCODING_NONE) {
12693         xmlSwitchEncoding(ctxt, enc);
12694     }
12695     }
12696 
12697     xmlParseExternalSubset(ctxt, BAD_CAST &quot;none&quot;, BAD_CAST &quot;none&quot;);
12698 
12699     if (ctxt-&gt;myDoc != NULL) {
12700     if (ctxt-&gt;wellFormed) {
12701         ret = ctxt-&gt;myDoc-&gt;extSubset;
12702         ctxt-&gt;myDoc-&gt;extSubset = NULL;
12703         if (ret != NULL) {
12704         xmlNodePtr tmp;
12705 
12706         ret-&gt;doc = NULL;
12707         tmp = ret-&gt;children;
12708         while (tmp != NULL) {
12709             tmp-&gt;doc = NULL;
12710             tmp = tmp-&gt;next;
12711         }
12712         }
12713     } else {
12714         ret = NULL;
12715     }
12716         xmlFreeDoc(ctxt-&gt;myDoc);
12717         ctxt-&gt;myDoc = NULL;
12718     }
12719     if (sax != NULL) ctxt-&gt;sax = NULL;
12720     xmlFreeParserCtxt(ctxt);
12721 
12722     return(ret);
12723 }
12724 
12725 /**
12726  * xmlSAXParseDTD:
12727  * @sax:  the SAX handler block
12728  * @ExternalID:  a NAME* containing the External ID of the DTD
12729  * @SystemID:  a NAME* containing the URL to the DTD
12730  *
12731  * Load and parse an external subset.
12732  *
12733  * Returns the resulting xmlDtdPtr or NULL in case of error.
12734  */
12735 
12736 xmlDtdPtr
12737 xmlSAXParseDTD(xmlSAXHandlerPtr sax, const xmlChar *ExternalID,
12738                           const xmlChar *SystemID) {
12739     xmlDtdPtr ret = NULL;
12740     xmlParserCtxtPtr ctxt;
12741     xmlParserInputPtr input = NULL;
12742     xmlCharEncoding enc;
12743     xmlChar* systemIdCanonic;
12744 
12745     if ((ExternalID == NULL) &amp;&amp; (SystemID == NULL)) return(NULL);
12746 
12747     ctxt = xmlNewParserCtxt();
12748     if (ctxt == NULL) {
12749     return(NULL);
12750     }
12751 
12752     /* We are loading a DTD */
12753     ctxt-&gt;options |= XML_PARSE_DTDLOAD;
12754 
12755     /*
12756      * Set-up the SAX context
12757      */
12758     if (sax != NULL) {
12759     if (ctxt-&gt;sax != NULL)
12760         xmlFree(ctxt-&gt;sax);
12761         ctxt-&gt;sax = sax;
12762         ctxt-&gt;userData = ctxt;
12763     }
12764 
12765     /*
12766      * Canonicalise the system ID
12767      */
12768     systemIdCanonic = xmlCanonicPath(SystemID);
12769     if ((SystemID != NULL) &amp;&amp; (systemIdCanonic == NULL)) {
12770     xmlFreeParserCtxt(ctxt);
12771     return(NULL);
12772     }
12773 
12774     /*
12775      * Ask the Entity resolver to load the damn thing
12776      */
12777 
12778     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;resolveEntity != NULL))
12779     input = ctxt-&gt;sax-&gt;resolveEntity(ctxt-&gt;userData, ExternalID,
12780                                      systemIdCanonic);
12781     if (input == NULL) {
12782         if (sax != NULL) ctxt-&gt;sax = NULL;
12783     xmlFreeParserCtxt(ctxt);
12784     if (systemIdCanonic != NULL)
12785         xmlFree(systemIdCanonic);
12786     return(NULL);
12787     }
12788 
12789     /*
12790      * plug some encoding conversion routines here.
12791      */
12792     if (xmlPushInput(ctxt, input) &lt; 0) {
12793         if (sax != NULL) ctxt-&gt;sax = NULL;
12794     xmlFreeParserCtxt(ctxt);
12795     if (systemIdCanonic != NULL)
12796         xmlFree(systemIdCanonic);
12797     return(NULL);
12798     }
12799     if ((ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur) &gt;= 4) {
12800     enc = xmlDetectCharEncoding(ctxt-&gt;input-&gt;cur, 4);
12801     xmlSwitchEncoding(ctxt, enc);
12802     }
12803 
12804     if (input-&gt;filename == NULL)
12805     input-&gt;filename = (char *) systemIdCanonic;
12806     else
12807     xmlFree(systemIdCanonic);
12808     input-&gt;line = 1;
12809     input-&gt;col = 1;
12810     input-&gt;base = ctxt-&gt;input-&gt;cur;
12811     input-&gt;cur = ctxt-&gt;input-&gt;cur;
12812     input-&gt;free = NULL;
12813 
12814     /*
12815      * let&#39;s parse that entity knowing it&#39;s an external subset.
12816      */
12817     ctxt-&gt;inSubset = 2;
12818     ctxt-&gt;myDoc = xmlNewDoc(BAD_CAST &quot;1.0&quot;);
12819     if (ctxt-&gt;myDoc == NULL) {
12820     xmlErrMemory(ctxt, &quot;New Doc failed&quot;);
12821         if (sax != NULL) ctxt-&gt;sax = NULL;
12822     xmlFreeParserCtxt(ctxt);
12823     return(NULL);
12824     }
12825     ctxt-&gt;myDoc-&gt;properties = XML_DOC_INTERNAL;
12826     ctxt-&gt;myDoc-&gt;extSubset = xmlNewDtd(ctxt-&gt;myDoc, BAD_CAST &quot;none&quot;,
12827                                    ExternalID, SystemID);
12828     xmlParseExternalSubset(ctxt, ExternalID, SystemID);
12829 
12830     if (ctxt-&gt;myDoc != NULL) {
12831     if (ctxt-&gt;wellFormed) {
12832         ret = ctxt-&gt;myDoc-&gt;extSubset;
12833         ctxt-&gt;myDoc-&gt;extSubset = NULL;
12834         if (ret != NULL) {
12835         xmlNodePtr tmp;
12836 
12837         ret-&gt;doc = NULL;
12838         tmp = ret-&gt;children;
12839         while (tmp != NULL) {
12840             tmp-&gt;doc = NULL;
12841             tmp = tmp-&gt;next;
12842         }
12843         }
12844     } else {
12845         ret = NULL;
12846     }
12847         xmlFreeDoc(ctxt-&gt;myDoc);
12848         ctxt-&gt;myDoc = NULL;
12849     }
12850     if (sax != NULL) ctxt-&gt;sax = NULL;
12851     xmlFreeParserCtxt(ctxt);
12852 
12853     return(ret);
12854 }
12855 
12856 
12857 /**
12858  * xmlParseDTD:
12859  * @ExternalID:  a NAME* containing the External ID of the DTD
12860  * @SystemID:  a NAME* containing the URL to the DTD
12861  *
12862  * Load and parse an external subset.
12863  *
12864  * Returns the resulting xmlDtdPtr or NULL in case of error.
12865  */
12866 
12867 xmlDtdPtr
12868 xmlParseDTD(const xmlChar *ExternalID, const xmlChar *SystemID) {
12869     return(xmlSAXParseDTD(NULL, ExternalID, SystemID));
12870 }
12871 #endif /* LIBXML_VALID_ENABLED */
12872 
12873 /************************************************************************
12874  *                                  *
12875  *      Front ends when parsing an Entity           *
12876  *                                  *
12877  ************************************************************************/
12878 
12879 /**
12880  * xmlParseCtxtExternalEntity:
12881  * @ctx:  the existing parsing context
12882  * @URL:  the URL for the entity to load
12883  * @ID:  the System ID for the entity to load
12884  * @lst:  the return value for the set of parsed nodes
12885  *
12886  * Parse an external general entity within an existing parsing context
12887  * An external general parsed entity is well-formed if it matches the
12888  * production labeled extParsedEnt.
12889  *
12890  * [78] extParsedEnt ::= TextDecl? content
12891  *
12892  * Returns 0 if the entity is well formed, -1 in case of args problem and
12893  *    the parser error code otherwise
12894  */
12895 
12896 int
12897 xmlParseCtxtExternalEntity(xmlParserCtxtPtr ctx, const xmlChar *URL,
12898                    const xmlChar *ID, xmlNodePtr *lst) {
12899     xmlParserCtxtPtr ctxt;
12900     xmlDocPtr newDoc;
12901     xmlNodePtr newRoot;
12902     xmlSAXHandlerPtr oldsax = NULL;
12903     int ret = 0;
12904     xmlChar start[4];
12905     xmlCharEncoding enc;
12906 
12907     if (ctx == NULL) return(-1);
12908 
12909     if (((ctx-&gt;depth &gt; 40) &amp;&amp; ((ctx-&gt;options &amp; XML_PARSE_HUGE) == 0)) ||
12910         (ctx-&gt;depth &gt; 1024)) {
12911     return(XML_ERR_ENTITY_LOOP);
12912     }
12913 
12914     if (lst != NULL)
12915         *lst = NULL;
12916     if ((URL == NULL) &amp;&amp; (ID == NULL))
12917     return(-1);
12918     if (ctx-&gt;myDoc == NULL) /* @@ relax but check for dereferences */
12919     return(-1);
12920 
12921     ctxt = xmlCreateEntityParserCtxtInternal(URL, ID, NULL, ctx);
12922     if (ctxt == NULL) {
12923     return(-1);
12924     }
12925 
12926     oldsax = ctxt-&gt;sax;
12927     ctxt-&gt;sax = ctx-&gt;sax;
12928     xmlDetectSAX2(ctxt);
12929     newDoc = xmlNewDoc(BAD_CAST &quot;1.0&quot;);
12930     if (newDoc == NULL) {
12931     xmlFreeParserCtxt(ctxt);
12932     return(-1);
12933     }
12934     newDoc-&gt;properties = XML_DOC_INTERNAL;
12935     if (ctx-&gt;myDoc-&gt;dict) {
12936     newDoc-&gt;dict = ctx-&gt;myDoc-&gt;dict;
12937     xmlDictReference(newDoc-&gt;dict);
12938     }
12939     if (ctx-&gt;myDoc != NULL) {
12940     newDoc-&gt;intSubset = ctx-&gt;myDoc-&gt;intSubset;
12941     newDoc-&gt;extSubset = ctx-&gt;myDoc-&gt;extSubset;
12942     }
12943     if (ctx-&gt;myDoc-&gt;URL != NULL) {
12944     newDoc-&gt;URL = xmlStrdup(ctx-&gt;myDoc-&gt;URL);
12945     }
12946     newRoot = xmlNewDocNode(newDoc, NULL, BAD_CAST &quot;pseudoroot&quot;, NULL);
12947     if (newRoot == NULL) {
12948     ctxt-&gt;sax = oldsax;
12949     xmlFreeParserCtxt(ctxt);
12950     newDoc-&gt;intSubset = NULL;
12951     newDoc-&gt;extSubset = NULL;
12952         xmlFreeDoc(newDoc);
12953     return(-1);
12954     }
12955     xmlAddChild((xmlNodePtr) newDoc, newRoot);
12956     nodePush(ctxt, newDoc-&gt;children);
12957     if (ctx-&gt;myDoc == NULL) {
12958     ctxt-&gt;myDoc = newDoc;
12959     } else {
12960     ctxt-&gt;myDoc = ctx-&gt;myDoc;
12961     newDoc-&gt;children-&gt;doc = ctx-&gt;myDoc;
12962     }
12963 
12964     /*
12965      * Get the 4 first bytes and decode the charset
12966      * if enc != XML_CHAR_ENCODING_NONE
12967      * plug some encoding conversion routines.
12968      */
12969     GROW
12970     if ((ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur) &gt;= 4) {
12971     start[0] = RAW;
12972     start[1] = NXT(1);
12973     start[2] = NXT(2);
12974     start[3] = NXT(3);
12975     enc = xmlDetectCharEncoding(start, 4);
12976     if (enc != XML_CHAR_ENCODING_NONE) {
12977         xmlSwitchEncoding(ctxt, enc);
12978     }
12979     }
12980 
12981     /*
12982      * Parse a possible text declaration first
12983      */
12984     if ((CMP5(CUR_PTR, &#39;&lt;&#39;, &#39;?&#39;, &#39;x&#39;, &#39;m&#39;, &#39;l&#39;)) &amp;&amp; (IS_BLANK_CH(NXT(5)))) {
12985     xmlParseTextDecl(ctxt);
12986     /*
12987      * An XML-1.0 document can&#39;t reference an entity not XML-1.0
12988      */
12989     if ((xmlStrEqual(ctx-&gt;version, BAD_CAST &quot;1.0&quot;)) &amp;&amp;
12990         (!xmlStrEqual(ctxt-&gt;input-&gt;version, BAD_CAST &quot;1.0&quot;))) {
12991         xmlFatalErrMsg(ctxt, XML_ERR_VERSION_MISMATCH,
12992                        &quot;Version mismatch between document and entity\n&quot;);
12993     }
12994     }
12995 
12996     /*
12997      * If the user provided its own SAX callbacks then reuse the
12998      * useData callback field, otherwise the expected setup in a
12999      * DOM builder is to have userData == ctxt
13000      */
13001     if (ctx-&gt;userData == ctx)
13002         ctxt-&gt;userData = ctxt;
13003     else
13004         ctxt-&gt;userData = ctx-&gt;userData;
13005 
13006     /*
13007      * Doing validity checking on chunk doesn&#39;t make sense
13008      */
13009     ctxt-&gt;instate = XML_PARSER_CONTENT;
13010     ctxt-&gt;validate = ctx-&gt;validate;
13011     ctxt-&gt;valid = ctx-&gt;valid;
13012     ctxt-&gt;loadsubset = ctx-&gt;loadsubset;
13013     ctxt-&gt;depth = ctx-&gt;depth + 1;
13014     ctxt-&gt;replaceEntities = ctx-&gt;replaceEntities;
13015     if (ctxt-&gt;validate) {
13016     ctxt-&gt;vctxt.error = ctx-&gt;vctxt.error;
13017     ctxt-&gt;vctxt.warning = ctx-&gt;vctxt.warning;
13018     } else {
13019     ctxt-&gt;vctxt.error = NULL;
13020     ctxt-&gt;vctxt.warning = NULL;
13021     }
13022     ctxt-&gt;vctxt.nodeTab = NULL;
13023     ctxt-&gt;vctxt.nodeNr = 0;
13024     ctxt-&gt;vctxt.nodeMax = 0;
13025     ctxt-&gt;vctxt.node = NULL;
13026     if (ctxt-&gt;dict != NULL) xmlDictFree(ctxt-&gt;dict);
13027     ctxt-&gt;dict = ctx-&gt;dict;
13028     ctxt-&gt;str_xml = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xml&quot;, 3);
13029     ctxt-&gt;str_xmlns = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xmlns&quot;, 5);
13030     ctxt-&gt;str_xml_ns = xmlDictLookup(ctxt-&gt;dict, XML_XML_NAMESPACE, 36);
13031     ctxt-&gt;dictNames = ctx-&gt;dictNames;
13032     ctxt-&gt;attsDefault = ctx-&gt;attsDefault;
13033     ctxt-&gt;attsSpecial = ctx-&gt;attsSpecial;
13034     ctxt-&gt;linenumbers = ctx-&gt;linenumbers;
13035 
13036     xmlParseContent(ctxt);
13037 
13038     ctx-&gt;validate = ctxt-&gt;validate;
13039     ctx-&gt;valid = ctxt-&gt;valid;
13040     if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
13041     xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13042     } else if (RAW != 0) {
13043     xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
13044     }
13045     if (ctxt-&gt;node != newDoc-&gt;children) {
13046     xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13047     }
13048 
13049     if (!ctxt-&gt;wellFormed) {
13050         if (ctxt-&gt;errNo == 0)
13051         ret = 1;
13052     else
13053         ret = ctxt-&gt;errNo;
13054     } else {
13055     if (lst != NULL) {
13056         xmlNodePtr cur;
13057 
13058         /*
13059          * Return the newly created nodeset after unlinking it from
13060          * they pseudo parent.
13061          */
13062         cur = newDoc-&gt;children-&gt;children;
13063         *lst = cur;
13064         while (cur != NULL) {
13065         cur-&gt;parent = NULL;
13066         cur = cur-&gt;next;
13067         }
13068             newDoc-&gt;children-&gt;children = NULL;
13069     }
13070     ret = 0;
13071     }
13072     ctxt-&gt;sax = oldsax;
13073     ctxt-&gt;dict = NULL;
13074     ctxt-&gt;attsDefault = NULL;
13075     ctxt-&gt;attsSpecial = NULL;
13076     xmlFreeParserCtxt(ctxt);
13077     newDoc-&gt;intSubset = NULL;
13078     newDoc-&gt;extSubset = NULL;
13079     xmlFreeDoc(newDoc);
13080 
13081     return(ret);
13082 }
13083 
13084 /**
13085  * xmlParseExternalEntityPrivate:
13086  * @doc:  the document the chunk pertains to
13087  * @oldctxt:  the previous parser context if available
13088  * @sax:  the SAX handler bloc (possibly NULL)
13089  * @user_data:  The user data returned on SAX callbacks (possibly NULL)
13090  * @depth:  Used for loop detection, use 0
13091  * @URL:  the URL for the entity to load
13092  * @ID:  the System ID for the entity to load
13093  * @list:  the return value for the set of parsed nodes
13094  *
13095  * Private version of xmlParseExternalEntity()
13096  *
13097  * Returns 0 if the entity is well formed, -1 in case of args problem and
13098  *    the parser error code otherwise
13099  */
13100 
13101 static xmlParserErrors
13102 xmlParseExternalEntityPrivate(xmlDocPtr doc, xmlParserCtxtPtr oldctxt,
13103                   xmlSAXHandlerPtr sax,
13104               void *user_data, int depth, const xmlChar *URL,
13105               const xmlChar *ID, xmlNodePtr *list) {
13106     xmlParserCtxtPtr ctxt;
13107     xmlDocPtr newDoc;
13108     xmlNodePtr newRoot;
13109     xmlSAXHandlerPtr oldsax = NULL;
13110     xmlParserErrors ret = XML_ERR_OK;
13111     xmlChar start[4];
13112     xmlCharEncoding enc;
13113 
13114     if (((depth &gt; 40) &amp;&amp;
13115     ((oldctxt == NULL) || (oldctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) ||
13116     (depth &gt; 1024)) {
13117     return(XML_ERR_ENTITY_LOOP);
13118     }
13119 
13120     if (list != NULL)
13121         *list = NULL;
13122     if ((URL == NULL) &amp;&amp; (ID == NULL))
13123     return(XML_ERR_INTERNAL_ERROR);
13124     if (doc == NULL)
13125     return(XML_ERR_INTERNAL_ERROR);
13126 
13127 
13128     ctxt = xmlCreateEntityParserCtxtInternal(URL, ID, NULL, oldctxt);
13129     if (ctxt == NULL) return(XML_WAR_UNDECLARED_ENTITY);
13130     ctxt-&gt;userData = ctxt;
13131     if (oldctxt != NULL) {
13132     ctxt-&gt;_private = oldctxt-&gt;_private;
13133     ctxt-&gt;loadsubset = oldctxt-&gt;loadsubset;
13134     ctxt-&gt;validate = oldctxt-&gt;validate;
13135     ctxt-&gt;external = oldctxt-&gt;external;
13136     ctxt-&gt;record_info = oldctxt-&gt;record_info;
13137     ctxt-&gt;node_seq.maximum = oldctxt-&gt;node_seq.maximum;
13138     ctxt-&gt;node_seq.length = oldctxt-&gt;node_seq.length;
13139     ctxt-&gt;node_seq.buffer = oldctxt-&gt;node_seq.buffer;
13140     } else {
13141     /*
13142      * Doing validity checking on chunk without context
13143      * doesn&#39;t make sense
13144      */
13145     ctxt-&gt;_private = NULL;
13146     ctxt-&gt;validate = 0;
13147     ctxt-&gt;external = 2;
13148     ctxt-&gt;loadsubset = 0;
13149     }
13150     if (sax != NULL) {
13151     oldsax = ctxt-&gt;sax;
13152         ctxt-&gt;sax = sax;
13153     if (user_data != NULL)
13154         ctxt-&gt;userData = user_data;
13155     }
13156     xmlDetectSAX2(ctxt);
13157     newDoc = xmlNewDoc(BAD_CAST &quot;1.0&quot;);
13158     if (newDoc == NULL) {
13159     ctxt-&gt;node_seq.maximum = 0;
13160     ctxt-&gt;node_seq.length = 0;
13161     ctxt-&gt;node_seq.buffer = NULL;
13162     xmlFreeParserCtxt(ctxt);
13163     return(XML_ERR_INTERNAL_ERROR);
13164     }
13165     newDoc-&gt;properties = XML_DOC_INTERNAL;
13166     newDoc-&gt;intSubset = doc-&gt;intSubset;
13167     newDoc-&gt;extSubset = doc-&gt;extSubset;
13168     newDoc-&gt;dict = doc-&gt;dict;
13169     xmlDictReference(newDoc-&gt;dict);
13170 
13171     if (doc-&gt;URL != NULL) {
13172     newDoc-&gt;URL = xmlStrdup(doc-&gt;URL);
13173     }
13174     newRoot = xmlNewDocNode(newDoc, NULL, BAD_CAST &quot;pseudoroot&quot;, NULL);
13175     if (newRoot == NULL) {
13176     if (sax != NULL)
13177         ctxt-&gt;sax = oldsax;
13178     ctxt-&gt;node_seq.maximum = 0;
13179     ctxt-&gt;node_seq.length = 0;
13180     ctxt-&gt;node_seq.buffer = NULL;
13181     xmlFreeParserCtxt(ctxt);
13182     newDoc-&gt;intSubset = NULL;
13183     newDoc-&gt;extSubset = NULL;
13184         xmlFreeDoc(newDoc);
13185     return(XML_ERR_INTERNAL_ERROR);
13186     }
13187     xmlAddChild((xmlNodePtr) newDoc, newRoot);
13188     nodePush(ctxt, newDoc-&gt;children);
13189     ctxt-&gt;myDoc = doc;
13190     newRoot-&gt;doc = doc;
13191 
13192     /*
13193      * Get the 4 first bytes and decode the charset
13194      * if enc != XML_CHAR_ENCODING_NONE
13195      * plug some encoding conversion routines.
13196      */
13197     GROW;
13198     if ((ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur) &gt;= 4) {
13199     start[0] = RAW;
13200     start[1] = NXT(1);
13201     start[2] = NXT(2);
13202     start[3] = NXT(3);
13203     enc = xmlDetectCharEncoding(start, 4);
13204     if (enc != XML_CHAR_ENCODING_NONE) {
13205         xmlSwitchEncoding(ctxt, enc);
13206     }
13207     }
13208 
13209     /*
13210      * Parse a possible text declaration first
13211      */
13212     if ((CMP5(CUR_PTR, &#39;&lt;&#39;, &#39;?&#39;, &#39;x&#39;, &#39;m&#39;, &#39;l&#39;)) &amp;&amp; (IS_BLANK_CH(NXT(5)))) {
13213     xmlParseTextDecl(ctxt);
13214     }
13215 
13216     ctxt-&gt;instate = XML_PARSER_CONTENT;
13217     ctxt-&gt;depth = depth;
13218 
13219     xmlParseContent(ctxt);
13220 
13221     if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
13222     xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13223     } else if (RAW != 0) {
13224     xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
13225     }
13226     if (ctxt-&gt;node != newDoc-&gt;children) {
13227     xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13228     }
13229 
13230     if (!ctxt-&gt;wellFormed) {
13231         if (ctxt-&gt;errNo == 0)
13232         ret = XML_ERR_INTERNAL_ERROR;
13233     else
13234         ret = (xmlParserErrors)ctxt-&gt;errNo;
13235     } else {
13236     if (list != NULL) {
13237         xmlNodePtr cur;
13238 
13239         /*
13240          * Return the newly created nodeset after unlinking it from
13241          * they pseudo parent.
13242          */
13243         cur = newDoc-&gt;children-&gt;children;
13244         *list = cur;
13245         while (cur != NULL) {
13246         cur-&gt;parent = NULL;
13247         cur = cur-&gt;next;
13248         }
13249             newDoc-&gt;children-&gt;children = NULL;
13250     }
13251     ret = XML_ERR_OK;
13252     }
13253 
13254     /*
13255      * Record in the parent context the number of entities replacement
13256      * done when parsing that reference.
13257      */
13258     if (oldctxt != NULL)
13259         oldctxt-&gt;nbentities += ctxt-&gt;nbentities;
13260 
13261     /*
13262      * Also record the size of the entity parsed
13263      */
13264     if (ctxt-&gt;input != NULL &amp;&amp; oldctxt != NULL) {
13265     oldctxt-&gt;sizeentities += ctxt-&gt;input-&gt;consumed;
13266     oldctxt-&gt;sizeentities += (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
13267     }
13268     /*
13269      * And record the last error if any
13270      */
13271     if ((oldctxt != NULL) &amp;&amp; (ctxt-&gt;lastError.code != XML_ERR_OK))
13272         xmlCopyError(&amp;ctxt-&gt;lastError, &amp;oldctxt-&gt;lastError);
13273 
13274     if (sax != NULL)
13275     ctxt-&gt;sax = oldsax;
13276     if (oldctxt != NULL) {
13277         oldctxt-&gt;node_seq.maximum = ctxt-&gt;node_seq.maximum;
13278         oldctxt-&gt;node_seq.length = ctxt-&gt;node_seq.length;
13279         oldctxt-&gt;node_seq.buffer = ctxt-&gt;node_seq.buffer;
13280     }
13281     ctxt-&gt;node_seq.maximum = 0;
13282     ctxt-&gt;node_seq.length = 0;
13283     ctxt-&gt;node_seq.buffer = NULL;
13284     xmlFreeParserCtxt(ctxt);
13285     newDoc-&gt;intSubset = NULL;
13286     newDoc-&gt;extSubset = NULL;
13287     xmlFreeDoc(newDoc);
13288 
13289     return(ret);
13290 }
13291 
13292 #ifdef LIBXML_SAX1_ENABLED
13293 /**
13294  * xmlParseExternalEntity:
13295  * @doc:  the document the chunk pertains to
13296  * @sax:  the SAX handler bloc (possibly NULL)
13297  * @user_data:  The user data returned on SAX callbacks (possibly NULL)
13298  * @depth:  Used for loop detection, use 0
13299  * @URL:  the URL for the entity to load
13300  * @ID:  the System ID for the entity to load
13301  * @lst:  the return value for the set of parsed nodes
13302  *
13303  * Parse an external general entity
13304  * An external general parsed entity is well-formed if it matches the
13305  * production labeled extParsedEnt.
13306  *
13307  * [78] extParsedEnt ::= TextDecl? content
13308  *
13309  * Returns 0 if the entity is well formed, -1 in case of args problem and
13310  *    the parser error code otherwise
13311  */
13312 
13313 int
13314 xmlParseExternalEntity(xmlDocPtr doc, xmlSAXHandlerPtr sax, void *user_data,
13315       int depth, const xmlChar *URL, const xmlChar *ID, xmlNodePtr *lst) {
13316     return(xmlParseExternalEntityPrivate(doc, NULL, sax, user_data, depth, URL,
13317                                ID, lst));
13318 }
13319 
13320 /**
13321  * xmlParseBalancedChunkMemory:
13322  * @doc:  the document the chunk pertains to
13323  * @sax:  the SAX handler bloc (possibly NULL)
13324  * @user_data:  The user data returned on SAX callbacks (possibly NULL)
13325  * @depth:  Used for loop detection, use 0
13326  * @string:  the input string in UTF8 or ISO-Latin (zero terminated)
13327  * @lst:  the return value for the set of parsed nodes
13328  *
13329  * Parse a well-balanced chunk of an XML document
13330  * called by the parser
13331  * The allowed sequence for the Well Balanced Chunk is the one defined by
13332  * the content production in the XML grammar:
13333  *
13334  * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
13335  *
13336  * Returns 0 if the chunk is well balanced, -1 in case of args problem and
13337  *    the parser error code otherwise
13338  */
13339 
13340 int
13341 xmlParseBalancedChunkMemory(xmlDocPtr doc, xmlSAXHandlerPtr sax,
13342      void *user_data, int depth, const xmlChar *string, xmlNodePtr *lst) {
13343     return xmlParseBalancedChunkMemoryRecover( doc, sax, user_data,
13344                                                 depth, string, lst, 0 );
13345 }
13346 #endif /* LIBXML_SAX1_ENABLED */
13347 
13348 /**
13349  * xmlParseBalancedChunkMemoryInternal:
13350  * @oldctxt:  the existing parsing context
13351  * @string:  the input string in UTF8 or ISO-Latin (zero terminated)
13352  * @user_data:  the user data field for the parser context
13353  * @lst:  the return value for the set of parsed nodes
13354  *
13355  *
13356  * Parse a well-balanced chunk of an XML document
13357  * called by the parser
13358  * The allowed sequence for the Well Balanced Chunk is the one defined by
13359  * the content production in the XML grammar:
13360  *
13361  * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
13362  *
13363  * Returns XML_ERR_OK if the chunk is well balanced, and the parser
13364  * error code otherwise
13365  *
13366  * In case recover is set to 1, the nodelist will not be empty even if
13367  * the parsed chunk is not well balanced.
13368  */
13369 static xmlParserErrors
13370 xmlParseBalancedChunkMemoryInternal(xmlParserCtxtPtr oldctxt,
13371     const xmlChar *string, void *user_data, xmlNodePtr *lst) {
13372     xmlParserCtxtPtr ctxt;
13373     xmlDocPtr newDoc = NULL;
13374     xmlNodePtr newRoot;
13375     xmlSAXHandlerPtr oldsax = NULL;
13376     xmlNodePtr content = NULL;
13377     xmlNodePtr last = NULL;
13378     int size;
13379     xmlParserErrors ret = XML_ERR_OK;
13380 #ifdef SAX2
13381     int i;
13382 #endif
13383 
13384     if (((oldctxt-&gt;depth &gt; 40) &amp;&amp; ((oldctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) ||
13385         (oldctxt-&gt;depth &gt;  1024)) {
13386     return(XML_ERR_ENTITY_LOOP);
13387     }
13388 
13389 
13390     if (lst != NULL)
13391         *lst = NULL;
13392     if (string == NULL)
13393         return(XML_ERR_INTERNAL_ERROR);
13394 
13395     size = xmlStrlen(string);
13396 
13397     ctxt = xmlCreateMemoryParserCtxt((char *) string, size);
13398     if (ctxt == NULL) return(XML_WAR_UNDECLARED_ENTITY);
13399     if (user_data != NULL)
13400     ctxt-&gt;userData = user_data;
13401     else
13402     ctxt-&gt;userData = ctxt;
13403     if (ctxt-&gt;dict != NULL) xmlDictFree(ctxt-&gt;dict);
13404     ctxt-&gt;dict = oldctxt-&gt;dict;
13405     ctxt-&gt;input_id = oldctxt-&gt;input_id + 1;
13406     ctxt-&gt;str_xml = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xml&quot;, 3);
13407     ctxt-&gt;str_xmlns = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xmlns&quot;, 5);
13408     ctxt-&gt;str_xml_ns = xmlDictLookup(ctxt-&gt;dict, XML_XML_NAMESPACE, 36);
13409 
13410 #ifdef SAX2
13411     /* propagate namespaces down the entity */
13412     for (i = 0;i &lt; oldctxt-&gt;nsNr;i += 2) {
13413         nsPush(ctxt, oldctxt-&gt;nsTab[i], oldctxt-&gt;nsTab[i+1]);
13414     }
13415 #endif
13416 
13417     oldsax = ctxt-&gt;sax;
13418     ctxt-&gt;sax = oldctxt-&gt;sax;
13419     xmlDetectSAX2(ctxt);
13420     ctxt-&gt;replaceEntities = oldctxt-&gt;replaceEntities;
13421     ctxt-&gt;options = oldctxt-&gt;options;
13422 
13423     ctxt-&gt;_private = oldctxt-&gt;_private;
13424     if (oldctxt-&gt;myDoc == NULL) {
13425     newDoc = xmlNewDoc(BAD_CAST &quot;1.0&quot;);
13426     if (newDoc == NULL) {
13427         ctxt-&gt;sax = oldsax;
13428         ctxt-&gt;dict = NULL;
13429         xmlFreeParserCtxt(ctxt);
13430         return(XML_ERR_INTERNAL_ERROR);
13431     }
13432     newDoc-&gt;properties = XML_DOC_INTERNAL;
13433     newDoc-&gt;dict = ctxt-&gt;dict;
13434     xmlDictReference(newDoc-&gt;dict);
13435     ctxt-&gt;myDoc = newDoc;
13436     } else {
13437     ctxt-&gt;myDoc = oldctxt-&gt;myDoc;
13438         content = ctxt-&gt;myDoc-&gt;children;
13439     last = ctxt-&gt;myDoc-&gt;last;
13440     }
13441     newRoot = xmlNewDocNode(ctxt-&gt;myDoc, NULL, BAD_CAST &quot;pseudoroot&quot;, NULL);
13442     if (newRoot == NULL) {
13443     ctxt-&gt;sax = oldsax;
13444     ctxt-&gt;dict = NULL;
13445     xmlFreeParserCtxt(ctxt);
13446     if (newDoc != NULL) {
13447         xmlFreeDoc(newDoc);
13448     }
13449     return(XML_ERR_INTERNAL_ERROR);
13450     }
13451     ctxt-&gt;myDoc-&gt;children = NULL;
13452     ctxt-&gt;myDoc-&gt;last = NULL;
13453     xmlAddChild((xmlNodePtr) ctxt-&gt;myDoc, newRoot);
13454     nodePush(ctxt, ctxt-&gt;myDoc-&gt;children);
13455     ctxt-&gt;instate = XML_PARSER_CONTENT;
13456     ctxt-&gt;depth = oldctxt-&gt;depth + 1;
13457 
13458     ctxt-&gt;validate = 0;
13459     ctxt-&gt;loadsubset = oldctxt-&gt;loadsubset;
13460     if ((oldctxt-&gt;validate) || (oldctxt-&gt;replaceEntities != 0)) {
13461     /*
13462      * ID/IDREF registration will be done in xmlValidateElement below
13463      */
13464     ctxt-&gt;loadsubset |= XML_SKIP_IDS;
13465     }
13466     ctxt-&gt;dictNames = oldctxt-&gt;dictNames;
13467     ctxt-&gt;attsDefault = oldctxt-&gt;attsDefault;
13468     ctxt-&gt;attsSpecial = oldctxt-&gt;attsSpecial;
13469 
13470     xmlParseContent(ctxt);
13471     if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
13472     xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13473     } else if (RAW != 0) {
13474     xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
13475     }
13476     if (ctxt-&gt;node != ctxt-&gt;myDoc-&gt;children) {
13477     xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13478     }
13479 
13480     if (!ctxt-&gt;wellFormed) {
13481         if (ctxt-&gt;errNo == 0)
13482         ret = XML_ERR_INTERNAL_ERROR;
13483     else
13484         ret = (xmlParserErrors)ctxt-&gt;errNo;
13485     } else {
13486       ret = XML_ERR_OK;
13487     }
13488 
13489     if ((lst != NULL) &amp;&amp; (ret == XML_ERR_OK)) {
13490     xmlNodePtr cur;
13491 
13492     /*
13493      * Return the newly created nodeset after unlinking it from
13494      * they pseudo parent.
13495      */
13496     cur = ctxt-&gt;myDoc-&gt;children-&gt;children;
13497     *lst = cur;
13498     while (cur != NULL) {
13499 #ifdef LIBXML_VALID_ENABLED
13500         if ((oldctxt-&gt;validate) &amp;&amp; (oldctxt-&gt;wellFormed) &amp;&amp;
13501         (oldctxt-&gt;myDoc) &amp;&amp; (oldctxt-&gt;myDoc-&gt;intSubset) &amp;&amp;
13502         (cur-&gt;type == XML_ELEMENT_NODE)) {
13503         oldctxt-&gt;valid &amp;= xmlValidateElement(&amp;oldctxt-&gt;vctxt,
13504             oldctxt-&gt;myDoc, cur);
13505         }
13506 #endif /* LIBXML_VALID_ENABLED */
13507         cur-&gt;parent = NULL;
13508         cur = cur-&gt;next;
13509     }
13510     ctxt-&gt;myDoc-&gt;children-&gt;children = NULL;
13511     }
13512     if (ctxt-&gt;myDoc != NULL) {
13513     xmlFreeNode(ctxt-&gt;myDoc-&gt;children);
13514         ctxt-&gt;myDoc-&gt;children = content;
13515         ctxt-&gt;myDoc-&gt;last = last;
13516     }
13517 
13518     /*
13519      * Record in the parent context the number of entities replacement
13520      * done when parsing that reference.
13521      */
13522     if (oldctxt != NULL)
13523         oldctxt-&gt;nbentities += ctxt-&gt;nbentities;
13524 
13525     /*
13526      * Also record the last error if any
13527      */
13528     if (ctxt-&gt;lastError.code != XML_ERR_OK)
13529         xmlCopyError(&amp;ctxt-&gt;lastError, &amp;oldctxt-&gt;lastError);
13530 
13531     ctxt-&gt;sax = oldsax;
13532     ctxt-&gt;dict = NULL;
13533     ctxt-&gt;attsDefault = NULL;
13534     ctxt-&gt;attsSpecial = NULL;
13535     xmlFreeParserCtxt(ctxt);
13536     if (newDoc != NULL) {
13537     xmlFreeDoc(newDoc);
13538     }
13539 
13540     return(ret);
13541 }
13542 
13543 /**
13544  * xmlParseInNodeContext:
13545  * @node:  the context node
13546  * @data:  the input string
13547  * @datalen:  the input string length in bytes
13548  * @options:  a combination of xmlParserOption
13549  * @lst:  the return value for the set of parsed nodes
13550  *
13551  * Parse a well-balanced chunk of an XML document
13552  * within the context (DTD, namespaces, etc ...) of the given node.
13553  *
13554  * The allowed sequence for the data is a Well Balanced Chunk defined by
13555  * the content production in the XML grammar:
13556  *
13557  * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
13558  *
13559  * Returns XML_ERR_OK if the chunk is well balanced, and the parser
13560  * error code otherwise
13561  */
13562 xmlParserErrors
13563 xmlParseInNodeContext(xmlNodePtr node, const char *data, int datalen,
13564                       int options, xmlNodePtr *lst) {
13565 #ifdef SAX2
13566     xmlParserCtxtPtr ctxt;
13567     xmlDocPtr doc = NULL;
13568     xmlNodePtr fake, cur;
13569     int nsnr = 0;
13570 
13571     xmlParserErrors ret = XML_ERR_OK;
13572 
13573     /*
13574      * check all input parameters, grab the document
13575      */
13576     if ((lst == NULL) || (node == NULL) || (data == NULL) || (datalen &lt; 0))
13577         return(XML_ERR_INTERNAL_ERROR);
13578     switch (node-&gt;type) {
13579         case XML_ELEMENT_NODE:
13580         case XML_ATTRIBUTE_NODE:
13581         case XML_TEXT_NODE:
13582         case XML_CDATA_SECTION_NODE:
13583         case XML_ENTITY_REF_NODE:
13584         case XML_PI_NODE:
13585         case XML_COMMENT_NODE:
13586         case XML_DOCUMENT_NODE:
13587         case XML_HTML_DOCUMENT_NODE:
13588         break;
13589     default:
13590         return(XML_ERR_INTERNAL_ERROR);
13591 
13592     }
13593     while ((node != NULL) &amp;&amp; (node-&gt;type != XML_ELEMENT_NODE) &amp;&amp;
13594            (node-&gt;type != XML_DOCUMENT_NODE) &amp;&amp;
13595        (node-&gt;type != XML_HTML_DOCUMENT_NODE))
13596     node = node-&gt;parent;
13597     if (node == NULL)
13598     return(XML_ERR_INTERNAL_ERROR);
13599     if (node-&gt;type == XML_ELEMENT_NODE)
13600     doc = node-&gt;doc;
13601     else
13602         doc = (xmlDocPtr) node;
13603     if (doc == NULL)
13604     return(XML_ERR_INTERNAL_ERROR);
13605 
13606     /*
13607      * allocate a context and set-up everything not related to the
13608      * node position in the tree
13609      */
13610     if (doc-&gt;type == XML_DOCUMENT_NODE)
13611     ctxt = xmlCreateMemoryParserCtxt((char *) data, datalen);
13612 #ifdef LIBXML_HTML_ENABLED
13613     else if (doc-&gt;type == XML_HTML_DOCUMENT_NODE) {
13614     ctxt = htmlCreateMemoryParserCtxt((char *) data, datalen);
13615         /*
13616          * When parsing in context, it makes no sense to add implied
13617          * elements like html/body/etc...
13618          */
13619         options |= HTML_PARSE_NOIMPLIED;
13620     }
13621 #endif
13622     else
13623         return(XML_ERR_INTERNAL_ERROR);
13624 
13625     if (ctxt == NULL)
13626         return(XML_ERR_NO_MEMORY);
13627 
13628     /*
13629      * Use input doc&#39;s dict if present, else assure XML_PARSE_NODICT is set.
13630      * We need a dictionary for xmlDetectSAX2, so if there&#39;s no doc dict
13631      * we must wait until the last moment to free the original one.
13632      */
13633     if (doc-&gt;dict != NULL) {
13634         if (ctxt-&gt;dict != NULL)
13635         xmlDictFree(ctxt-&gt;dict);
13636     ctxt-&gt;dict = doc-&gt;dict;
13637     } else
13638         options |= XML_PARSE_NODICT;
13639 
13640     if (doc-&gt;encoding != NULL) {
13641         xmlCharEncodingHandlerPtr hdlr;
13642 
13643         if (ctxt-&gt;encoding != NULL)
13644         xmlFree((xmlChar *) ctxt-&gt;encoding);
13645         ctxt-&gt;encoding = xmlStrdup((const xmlChar *) doc-&gt;encoding);
13646 
13647         hdlr = xmlFindCharEncodingHandler((const char *) doc-&gt;encoding);
13648         if (hdlr != NULL) {
13649             xmlSwitchToEncoding(ctxt, hdlr);
13650     } else {
13651             return(XML_ERR_UNSUPPORTED_ENCODING);
13652         }
13653     }
13654 
13655     xmlCtxtUseOptionsInternal(ctxt, options, NULL);
13656     xmlDetectSAX2(ctxt);
13657     ctxt-&gt;myDoc = doc;
13658     /* parsing in context, i.e. as within existing content */
13659     ctxt-&gt;input_id = 2;
13660     ctxt-&gt;instate = XML_PARSER_CONTENT;
13661 
13662     fake = xmlNewComment(NULL);
13663     if (fake == NULL) {
13664         xmlFreeParserCtxt(ctxt);
13665     return(XML_ERR_NO_MEMORY);
13666     }
13667     xmlAddChild(node, fake);
13668 
13669     if (node-&gt;type == XML_ELEMENT_NODE) {
13670     nodePush(ctxt, node);
13671     /*
13672      * initialize the SAX2 namespaces stack
13673      */
13674     cur = node;
13675     while ((cur != NULL) &amp;&amp; (cur-&gt;type == XML_ELEMENT_NODE)) {
13676         xmlNsPtr ns = cur-&gt;nsDef;
13677         const xmlChar *iprefix, *ihref;
13678 
13679         while (ns != NULL) {
13680         if (ctxt-&gt;dict) {
13681             iprefix = xmlDictLookup(ctxt-&gt;dict, ns-&gt;prefix, -1);
13682             ihref = xmlDictLookup(ctxt-&gt;dict, ns-&gt;href, -1);
13683         } else {
13684             iprefix = ns-&gt;prefix;
13685             ihref = ns-&gt;href;
13686         }
13687 
13688             if (xmlGetNamespace(ctxt, iprefix) == NULL) {
13689             nsPush(ctxt, iprefix, ihref);
13690             nsnr++;
13691         }
13692         ns = ns-&gt;next;
13693         }
13694         cur = cur-&gt;parent;
13695     }
13696     }
13697 
13698     if ((ctxt-&gt;validate) || (ctxt-&gt;replaceEntities != 0)) {
13699     /*
13700      * ID/IDREF registration will be done in xmlValidateElement below
13701      */
13702     ctxt-&gt;loadsubset |= XML_SKIP_IDS;
13703     }
13704 
13705 #ifdef LIBXML_HTML_ENABLED
13706     if (doc-&gt;type == XML_HTML_DOCUMENT_NODE)
13707         __htmlParseContent(ctxt);
13708     else
13709 #endif
13710     xmlParseContent(ctxt);
13711 
13712     nsPop(ctxt, nsnr);
13713     if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
13714     xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13715     } else if (RAW != 0) {
13716     xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
13717     }
13718     if ((ctxt-&gt;node != NULL) &amp;&amp; (ctxt-&gt;node != node)) {
13719     xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13720     ctxt-&gt;wellFormed = 0;
13721     }
13722 
13723     if (!ctxt-&gt;wellFormed) {
13724         if (ctxt-&gt;errNo == 0)
13725         ret = XML_ERR_INTERNAL_ERROR;
13726     else
13727         ret = (xmlParserErrors)ctxt-&gt;errNo;
13728     } else {
13729         ret = XML_ERR_OK;
13730     }
13731 
13732     /*
13733      * Return the newly created nodeset after unlinking it from
13734      * the pseudo sibling.
13735      */
13736 
13737     cur = fake-&gt;next;
13738     fake-&gt;next = NULL;
13739     node-&gt;last = fake;
13740 
13741     if (cur != NULL) {
13742     cur-&gt;prev = NULL;
13743     }
13744 
13745     *lst = cur;
13746 
13747     while (cur != NULL) {
13748     cur-&gt;parent = NULL;
13749     cur = cur-&gt;next;
13750     }
13751 
13752     xmlUnlinkNode(fake);
13753     xmlFreeNode(fake);
13754 
13755 
13756     if (ret != XML_ERR_OK) {
13757         xmlFreeNodeList(*lst);
13758     *lst = NULL;
13759     }
13760 
13761     if (doc-&gt;dict != NULL)
13762         ctxt-&gt;dict = NULL;
13763     xmlFreeParserCtxt(ctxt);
13764 
13765     return(ret);
13766 #else /* !SAX2 */
13767     return(XML_ERR_INTERNAL_ERROR);
13768 #endif
13769 }
13770 
13771 #ifdef LIBXML_SAX1_ENABLED
13772 /**
13773  * xmlParseBalancedChunkMemoryRecover:
13774  * @doc:  the document the chunk pertains to
13775  * @sax:  the SAX handler bloc (possibly NULL)
13776  * @user_data:  The user data returned on SAX callbacks (possibly NULL)
13777  * @depth:  Used for loop detection, use 0
13778  * @string:  the input string in UTF8 or ISO-Latin (zero terminated)
13779  * @lst:  the return value for the set of parsed nodes
13780  * @recover: return nodes even if the data is broken (use 0)
13781  *
13782  *
13783  * Parse a well-balanced chunk of an XML document
13784  * called by the parser
13785  * The allowed sequence for the Well Balanced Chunk is the one defined by
13786  * the content production in the XML grammar:
13787  *
13788  * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
13789  *
13790  * Returns 0 if the chunk is well balanced, -1 in case of args problem and
13791  *    the parser error code otherwise
13792  *
13793  * In case recover is set to 1, the nodelist will not be empty even if
13794  * the parsed chunk is not well balanced, assuming the parsing succeeded to
13795  * some extent.
13796  */
13797 int
13798 xmlParseBalancedChunkMemoryRecover(xmlDocPtr doc, xmlSAXHandlerPtr sax,
13799      void *user_data, int depth, const xmlChar *string, xmlNodePtr *lst,
13800      int recover) {
13801     xmlParserCtxtPtr ctxt;
13802     xmlDocPtr newDoc;
13803     xmlSAXHandlerPtr oldsax = NULL;
13804     xmlNodePtr content, newRoot;
13805     int size;
13806     int ret = 0;
13807 
13808     if (depth &gt; 40) {
13809     return(XML_ERR_ENTITY_LOOP);
13810     }
13811 
13812 
13813     if (lst != NULL)
13814         *lst = NULL;
13815     if (string == NULL)
13816         return(-1);
13817 
13818     size = xmlStrlen(string);
13819 
13820     ctxt = xmlCreateMemoryParserCtxt((char *) string, size);
13821     if (ctxt == NULL) return(-1);
13822     ctxt-&gt;userData = ctxt;
13823     if (sax != NULL) {
13824     oldsax = ctxt-&gt;sax;
13825         ctxt-&gt;sax = sax;
13826     if (user_data != NULL)
13827         ctxt-&gt;userData = user_data;
13828     }
13829     newDoc = xmlNewDoc(BAD_CAST &quot;1.0&quot;);
13830     if (newDoc == NULL) {
13831     xmlFreeParserCtxt(ctxt);
13832     return(-1);
13833     }
13834     newDoc-&gt;properties = XML_DOC_INTERNAL;
13835     if ((doc != NULL) &amp;&amp; (doc-&gt;dict != NULL)) {
13836         xmlDictFree(ctxt-&gt;dict);
13837     ctxt-&gt;dict = doc-&gt;dict;
13838     xmlDictReference(ctxt-&gt;dict);
13839     ctxt-&gt;str_xml = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xml&quot;, 3);
13840     ctxt-&gt;str_xmlns = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xmlns&quot;, 5);
13841     ctxt-&gt;str_xml_ns = xmlDictLookup(ctxt-&gt;dict, XML_XML_NAMESPACE, 36);
13842     ctxt-&gt;dictNames = 1;
13843     } else {
13844     xmlCtxtUseOptionsInternal(ctxt, XML_PARSE_NODICT, NULL);
13845     }
13846     if (doc != NULL) {
13847     newDoc-&gt;intSubset = doc-&gt;intSubset;
13848     newDoc-&gt;extSubset = doc-&gt;extSubset;
13849     }
13850     newRoot = xmlNewDocNode(newDoc, NULL, BAD_CAST &quot;pseudoroot&quot;, NULL);
13851     if (newRoot == NULL) {
13852     if (sax != NULL)
13853         ctxt-&gt;sax = oldsax;
13854     xmlFreeParserCtxt(ctxt);
13855     newDoc-&gt;intSubset = NULL;
13856     newDoc-&gt;extSubset = NULL;
13857         xmlFreeDoc(newDoc);
13858     return(-1);
13859     }
13860     xmlAddChild((xmlNodePtr) newDoc, newRoot);
13861     nodePush(ctxt, newRoot);
13862     if (doc == NULL) {
13863     ctxt-&gt;myDoc = newDoc;
13864     } else {
13865     ctxt-&gt;myDoc = newDoc;
13866     newDoc-&gt;children-&gt;doc = doc;
13867     /* Ensure that doc has XML spec namespace */
13868     xmlSearchNsByHref(doc, (xmlNodePtr)doc, XML_XML_NAMESPACE);
13869     newDoc-&gt;oldNs = doc-&gt;oldNs;
13870     }
13871     ctxt-&gt;instate = XML_PARSER_CONTENT;
13872     ctxt-&gt;input_id = 2;
13873     ctxt-&gt;depth = depth;
13874 
13875     /*
13876      * Doing validity checking on chunk doesn&#39;t make sense
13877      */
13878     ctxt-&gt;validate = 0;
13879     ctxt-&gt;loadsubset = 0;
13880     xmlDetectSAX2(ctxt);
13881 
13882     if ( doc != NULL ){
13883         content = doc-&gt;children;
13884         doc-&gt;children = NULL;
13885         xmlParseContent(ctxt);
13886         doc-&gt;children = content;
13887     }
13888     else {
13889         xmlParseContent(ctxt);
13890     }
13891     if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
13892     xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13893     } else if (RAW != 0) {
13894     xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
13895     }
13896     if (ctxt-&gt;node != newDoc-&gt;children) {
13897     xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13898     }
13899 
13900     if (!ctxt-&gt;wellFormed) {
13901         if (ctxt-&gt;errNo == 0)
13902         ret = 1;
13903     else
13904         ret = ctxt-&gt;errNo;
13905     } else {
13906       ret = 0;
13907     }
13908 
13909     if ((lst != NULL) &amp;&amp; ((ret == 0) || (recover == 1))) {
13910     xmlNodePtr cur;
13911 
13912     /*
13913      * Return the newly created nodeset after unlinking it from
13914      * they pseudo parent.
13915      */
13916     cur = newDoc-&gt;children-&gt;children;
13917     *lst = cur;
13918     while (cur != NULL) {
13919         xmlSetTreeDoc(cur, doc);
13920         cur-&gt;parent = NULL;
13921         cur = cur-&gt;next;
13922     }
13923     newDoc-&gt;children-&gt;children = NULL;
13924     }
13925 
13926     if (sax != NULL)
13927     ctxt-&gt;sax = oldsax;
13928     xmlFreeParserCtxt(ctxt);
13929     newDoc-&gt;intSubset = NULL;
13930     newDoc-&gt;extSubset = NULL;
13931     if(doc != NULL)
13932     newDoc-&gt;oldNs = NULL;
13933     xmlFreeDoc(newDoc);
13934 
13935     return(ret);
13936 }
13937 
13938 /**
13939  * xmlSAXParseEntity:
13940  * @sax:  the SAX handler block
13941  * @filename:  the filename
13942  *
13943  * parse an XML external entity out of context and build a tree.
13944  * It use the given SAX function block to handle the parsing callback.
13945  * If sax is NULL, fallback to the default DOM tree building routines.
13946  *
13947  * [78] extParsedEnt ::= TextDecl? content
13948  *
13949  * This correspond to a &quot;Well Balanced&quot; chunk
13950  *
13951  * Returns the resulting document tree
13952  */
13953 
13954 xmlDocPtr
13955 xmlSAXParseEntity(xmlSAXHandlerPtr sax, const char *filename) {
13956     xmlDocPtr ret;
13957     xmlParserCtxtPtr ctxt;
13958 
13959     ctxt = xmlCreateFileParserCtxt(filename);
13960     if (ctxt == NULL) {
13961     return(NULL);
13962     }
13963     if (sax != NULL) {
13964     if (ctxt-&gt;sax != NULL)
13965         xmlFree(ctxt-&gt;sax);
13966         ctxt-&gt;sax = sax;
13967         ctxt-&gt;userData = NULL;
13968     }
13969 
13970     xmlParseExtParsedEnt(ctxt);
13971 
13972     if (ctxt-&gt;wellFormed)
13973     ret = ctxt-&gt;myDoc;
13974     else {
13975         ret = NULL;
13976         xmlFreeDoc(ctxt-&gt;myDoc);
13977         ctxt-&gt;myDoc = NULL;
13978     }
13979     if (sax != NULL)
13980         ctxt-&gt;sax = NULL;
13981     xmlFreeParserCtxt(ctxt);
13982 
13983     return(ret);
13984 }
13985 
13986 /**
13987  * xmlParseEntity:
13988  * @filename:  the filename
13989  *
13990  * parse an XML external entity out of context and build a tree.
13991  *
13992  * [78] extParsedEnt ::= TextDecl? content
13993  *
13994  * This correspond to a &quot;Well Balanced&quot; chunk
13995  *
13996  * Returns the resulting document tree
13997  */
13998 
13999 xmlDocPtr
14000 xmlParseEntity(const char *filename) {
14001     return(xmlSAXParseEntity(NULL, filename));
14002 }
14003 #endif /* LIBXML_SAX1_ENABLED */
14004 
14005 /**
14006  * xmlCreateEntityParserCtxtInternal:
14007  * @URL:  the entity URL
14008  * @ID:  the entity PUBLIC ID
14009  * @base:  a possible base for the target URI
14010  * @pctx:  parser context used to set options on new context
14011  *
14012  * Create a parser context for an external entity
14013  * Automatic support for ZLIB/Compress compressed document is provided
14014  * by default if found at compile-time.
14015  *
14016  * Returns the new parser context or NULL
14017  */
14018 static xmlParserCtxtPtr
14019 xmlCreateEntityParserCtxtInternal(const xmlChar *URL, const xmlChar *ID,
14020                       const xmlChar *base, xmlParserCtxtPtr pctx) {
14021     xmlParserCtxtPtr ctxt;
14022     xmlParserInputPtr inputStream;
14023     char *directory = NULL;
14024     xmlChar *uri;
14025 
14026     ctxt = xmlNewParserCtxt();
14027     if (ctxt == NULL) {
14028     return(NULL);
14029     }
14030 
14031     if (pctx != NULL) {
14032         ctxt-&gt;options = pctx-&gt;options;
14033         ctxt-&gt;_private = pctx-&gt;_private;
14034     /*
14035      * this is a subparser of pctx, so the input_id should be
14036      * incremented to distinguish from main entity
14037      */
14038     ctxt-&gt;input_id = pctx-&gt;input_id + 1;
14039     }
14040 
14041     /* Don&#39;t read from stdin. */
14042     if (xmlStrcmp(URL, BAD_CAST &quot;-&quot;) == 0)
14043         URL = BAD_CAST &quot;./-&quot;;
14044 
14045     uri = xmlBuildURI(URL, base);
14046 
14047     if (uri == NULL) {
14048     inputStream = xmlLoadExternalEntity((char *)URL, (char *)ID, ctxt);
14049     if (inputStream == NULL) {
14050         xmlFreeParserCtxt(ctxt);
14051         return(NULL);
14052     }
14053 
14054     inputPush(ctxt, inputStream);
14055 
14056     if ((ctxt-&gt;directory == NULL) &amp;&amp; (directory == NULL))
14057         directory = xmlParserGetDirectory((char *)URL);
14058     if ((ctxt-&gt;directory == NULL) &amp;&amp; (directory != NULL))
14059         ctxt-&gt;directory = directory;
14060     } else {
14061     inputStream = xmlLoadExternalEntity((char *)uri, (char *)ID, ctxt);
14062     if (inputStream == NULL) {
14063         xmlFree(uri);
14064         xmlFreeParserCtxt(ctxt);
14065         return(NULL);
14066     }
14067 
14068     inputPush(ctxt, inputStream);
14069 
14070     if ((ctxt-&gt;directory == NULL) &amp;&amp; (directory == NULL))
14071         directory = xmlParserGetDirectory((char *)uri);
14072     if ((ctxt-&gt;directory == NULL) &amp;&amp; (directory != NULL))
14073         ctxt-&gt;directory = directory;
14074     xmlFree(uri);
14075     }
14076     return(ctxt);
14077 }
14078 
14079 /**
14080  * xmlCreateEntityParserCtxt:
14081  * @URL:  the entity URL
14082  * @ID:  the entity PUBLIC ID
14083  * @base:  a possible base for the target URI
14084  *
14085  * Create a parser context for an external entity
14086  * Automatic support for ZLIB/Compress compressed document is provided
14087  * by default if found at compile-time.
14088  *
14089  * Returns the new parser context or NULL
14090  */
14091 xmlParserCtxtPtr
14092 xmlCreateEntityParserCtxt(const xmlChar *URL, const xmlChar *ID,
14093                       const xmlChar *base) {
14094     return xmlCreateEntityParserCtxtInternal(URL, ID, base, NULL);
14095 
14096 }
14097 
14098 /************************************************************************
14099  *                                  *
14100  *      Front ends when parsing from a file         *
14101  *                                  *
14102  ************************************************************************/
14103 
14104 /**
14105  * xmlCreateURLParserCtxt:
14106  * @filename:  the filename or URL
14107  * @options:  a combination of xmlParserOption
14108  *
14109  * Create a parser context for a file or URL content.
14110  * Automatic support for ZLIB/Compress compressed document is provided
14111  * by default if found at compile-time and for file accesses
14112  *
14113  * Returns the new parser context or NULL
14114  */
14115 xmlParserCtxtPtr
14116 xmlCreateURLParserCtxt(const char *filename, int options)
14117 {
14118     xmlParserCtxtPtr ctxt;
14119     xmlParserInputPtr inputStream;
14120     char *directory = NULL;
14121 
14122     ctxt = xmlNewParserCtxt();
14123     if (ctxt == NULL) {
14124     xmlErrMemory(NULL, &quot;cannot allocate parser context&quot;);
14125     return(NULL);
14126     }
14127 
14128     if (options)
14129     xmlCtxtUseOptionsInternal(ctxt, options, NULL);
14130     ctxt-&gt;linenumbers = 1;
14131 
14132     inputStream = xmlLoadExternalEntity(filename, NULL, ctxt);
14133     if (inputStream == NULL) {
14134     xmlFreeParserCtxt(ctxt);
14135     return(NULL);
14136     }
14137 
14138     inputPush(ctxt, inputStream);
14139     if ((ctxt-&gt;directory == NULL) &amp;&amp; (directory == NULL))
14140         directory = xmlParserGetDirectory(filename);
14141     if ((ctxt-&gt;directory == NULL) &amp;&amp; (directory != NULL))
14142         ctxt-&gt;directory = directory;
14143 
14144     return(ctxt);
14145 }
14146 
14147 /**
14148  * xmlCreateFileParserCtxt:
14149  * @filename:  the filename
14150  *
14151  * Create a parser context for a file content.
14152  * Automatic support for ZLIB/Compress compressed document is provided
14153  * by default if found at compile-time.
14154  *
14155  * Returns the new parser context or NULL
14156  */
14157 xmlParserCtxtPtr
14158 xmlCreateFileParserCtxt(const char *filename)
14159 {
14160     return(xmlCreateURLParserCtxt(filename, 0));
14161 }
14162 
14163 #ifdef LIBXML_SAX1_ENABLED
14164 /**
14165  * xmlSAXParseFileWithData:
14166  * @sax:  the SAX handler block
14167  * @filename:  the filename
14168  * @recovery:  work in recovery mode, i.e. tries to read no Well Formed
14169  *             documents
14170  * @data:  the userdata
14171  *
14172  * parse an XML file and build a tree. Automatic support for ZLIB/Compress
14173  * compressed document is provided by default if found at compile-time.
14174  * It use the given SAX function block to handle the parsing callback.
14175  * If sax is NULL, fallback to the default DOM tree building routines.
14176  *
14177  * User data (void *) is stored within the parser context in the
14178  * context&#39;s _private member, so it is available nearly everywhere in libxml
14179  *
14180  * Returns the resulting document tree
14181  */
14182 
14183 xmlDocPtr
14184 xmlSAXParseFileWithData(xmlSAXHandlerPtr sax, const char *filename,
14185                         int recovery, void *data) {
14186     xmlDocPtr ret;
14187     xmlParserCtxtPtr ctxt;
14188 
14189     xmlInitParser();
14190 
14191     ctxt = xmlCreateFileParserCtxt(filename);
14192     if (ctxt == NULL) {
14193     return(NULL);
14194     }
14195     if (sax != NULL) {
14196     if (ctxt-&gt;sax != NULL)
14197         xmlFree(ctxt-&gt;sax);
14198         ctxt-&gt;sax = sax;
14199     }
14200     xmlDetectSAX2(ctxt);
14201     if (data!=NULL) {
14202     ctxt-&gt;_private = data;
14203     }
14204 
14205     if (ctxt-&gt;directory == NULL)
14206         ctxt-&gt;directory = xmlParserGetDirectory(filename);
14207 
14208     ctxt-&gt;recovery = recovery;
14209 
14210     xmlParseDocument(ctxt);
14211 
14212     if ((ctxt-&gt;wellFormed) || recovery) {
14213         ret = ctxt-&gt;myDoc;
14214     if (ret != NULL) {
14215         if (ctxt-&gt;input-&gt;buf-&gt;compressed &gt; 0)
14216         ret-&gt;compression = 9;
14217         else
14218         ret-&gt;compression = ctxt-&gt;input-&gt;buf-&gt;compressed;
14219     }
14220     }
14221     else {
14222        ret = NULL;
14223        xmlFreeDoc(ctxt-&gt;myDoc);
14224        ctxt-&gt;myDoc = NULL;
14225     }
14226     if (sax != NULL)
14227         ctxt-&gt;sax = NULL;
14228     xmlFreeParserCtxt(ctxt);
14229 
14230     return(ret);
14231 }
14232 
14233 /**
14234  * xmlSAXParseFile:
14235  * @sax:  the SAX handler block
14236  * @filename:  the filename
14237  * @recovery:  work in recovery mode, i.e. tries to read no Well Formed
14238  *             documents
14239  *
14240  * parse an XML file and build a tree. Automatic support for ZLIB/Compress
14241  * compressed document is provided by default if found at compile-time.
14242  * It use the given SAX function block to handle the parsing callback.
14243  * If sax is NULL, fallback to the default DOM tree building routines.
14244  *
14245  * Returns the resulting document tree
14246  */
14247 
14248 xmlDocPtr
14249 xmlSAXParseFile(xmlSAXHandlerPtr sax, const char *filename,
14250                           int recovery) {
14251     return(xmlSAXParseFileWithData(sax,filename,recovery,NULL));
14252 }
14253 
14254 /**
14255  * xmlRecoverDoc:
14256  * @cur:  a pointer to an array of xmlChar
14257  *
14258  * parse an XML in-memory document and build a tree.
14259  * In the case the document is not Well Formed, a attempt to build a
14260  * tree is tried anyway
14261  *
14262  * Returns the resulting document tree or NULL in case of failure
14263  */
14264 
14265 xmlDocPtr
14266 xmlRecoverDoc(const xmlChar *cur) {
14267     return(xmlSAXParseDoc(NULL, cur, 1));
14268 }
14269 
14270 /**
14271  * xmlParseFile:
14272  * @filename:  the filename
14273  *
14274  * parse an XML file and build a tree. Automatic support for ZLIB/Compress
14275  * compressed document is provided by default if found at compile-time.
14276  *
14277  * Returns the resulting document tree if the file was wellformed,
14278  * NULL otherwise.
14279  */
14280 
14281 xmlDocPtr
14282 xmlParseFile(const char *filename) {
14283     return(xmlSAXParseFile(NULL, filename, 0));
14284 }
14285 
14286 /**
14287  * xmlRecoverFile:
14288  * @filename:  the filename
14289  *
14290  * parse an XML file and build a tree. Automatic support for ZLIB/Compress
14291  * compressed document is provided by default if found at compile-time.
14292  * In the case the document is not Well Formed, it attempts to build
14293  * a tree anyway
14294  *
14295  * Returns the resulting document tree or NULL in case of failure
14296  */
14297 
14298 xmlDocPtr
14299 xmlRecoverFile(const char *filename) {
14300     return(xmlSAXParseFile(NULL, filename, 1));
14301 }
14302 
14303 
14304 /**
14305  * xmlSetupParserForBuffer:
14306  * @ctxt:  an XML parser context
14307  * @buffer:  a xmlChar * buffer
14308  * @filename:  a file name
14309  *
14310  * Setup the parser context to parse a new buffer; Clears any prior
14311  * contents from the parser context. The buffer parameter must not be
14312  * NULL, but the filename parameter can be
14313  */
14314 void
14315 xmlSetupParserForBuffer(xmlParserCtxtPtr ctxt, const xmlChar* buffer,
14316                              const char* filename)
14317 {
14318     xmlParserInputPtr input;
14319 
14320     if ((ctxt == NULL) || (buffer == NULL))
14321         return;
14322 
14323     input = xmlNewInputStream(ctxt);
14324     if (input == NULL) {
14325         xmlErrMemory(NULL, &quot;parsing new buffer: out of memory\n&quot;);
14326         xmlClearParserCtxt(ctxt);
14327         return;
14328     }
14329 
14330     xmlClearParserCtxt(ctxt);
14331     if (filename != NULL)
14332         input-&gt;filename = (char *) xmlCanonicPath((const xmlChar *)filename);
14333     input-&gt;base = buffer;
14334     input-&gt;cur = buffer;
14335     input-&gt;end = &amp;buffer[xmlStrlen(buffer)];
14336     inputPush(ctxt, input);
14337 }
14338 
14339 /**
14340  * xmlSAXUserParseFile:
14341  * @sax:  a SAX handler
14342  * @user_data:  The user data returned on SAX callbacks
14343  * @filename:  a file name
14344  *
14345  * parse an XML file and call the given SAX handler routines.
14346  * Automatic support for ZLIB/Compress compressed document is provided
14347  *
14348  * Returns 0 in case of success or a error number otherwise
14349  */
14350 int
14351 xmlSAXUserParseFile(xmlSAXHandlerPtr sax, void *user_data,
14352                     const char *filename) {
14353     int ret = 0;
14354     xmlParserCtxtPtr ctxt;
14355 
14356     ctxt = xmlCreateFileParserCtxt(filename);
14357     if (ctxt == NULL) return -1;
14358     if (ctxt-&gt;sax != (xmlSAXHandlerPtr) &amp;xmlDefaultSAXHandler)
14359     xmlFree(ctxt-&gt;sax);
14360     ctxt-&gt;sax = sax;
14361     xmlDetectSAX2(ctxt);
14362 
14363     if (user_data != NULL)
14364     ctxt-&gt;userData = user_data;
14365 
14366     xmlParseDocument(ctxt);
14367 
14368     if (ctxt-&gt;wellFormed)
14369     ret = 0;
14370     else {
14371         if (ctxt-&gt;errNo != 0)
14372         ret = ctxt-&gt;errNo;
14373     else
14374         ret = -1;
14375     }
14376     if (sax != NULL)
14377     ctxt-&gt;sax = NULL;
14378     if (ctxt-&gt;myDoc != NULL) {
14379         xmlFreeDoc(ctxt-&gt;myDoc);
14380     ctxt-&gt;myDoc = NULL;
14381     }
14382     xmlFreeParserCtxt(ctxt);
14383 
14384     return ret;
14385 }
14386 #endif /* LIBXML_SAX1_ENABLED */
14387 
14388 /************************************************************************
14389  *                                  *
14390  *      Front ends when parsing from memory         *
14391  *                                  *
14392  ************************************************************************/
14393 
14394 /**
14395  * xmlCreateMemoryParserCtxt:
14396  * @buffer:  a pointer to a char array
14397  * @size:  the size of the array
14398  *
14399  * Create a parser context for an XML in-memory document.
14400  *
14401  * Returns the new parser context or NULL
14402  */
14403 xmlParserCtxtPtr
14404 xmlCreateMemoryParserCtxt(const char *buffer, int size) {
14405     xmlParserCtxtPtr ctxt;
14406     xmlParserInputPtr input;
14407     xmlParserInputBufferPtr buf;
14408 
14409     if (buffer == NULL)
14410     return(NULL);
14411     if (size &lt;= 0)
14412     return(NULL);
14413 
14414     ctxt = xmlNewParserCtxt();
14415     if (ctxt == NULL)
14416     return(NULL);
14417 
14418     /* TODO: xmlParserInputBufferCreateStatic, requires some serious changes */
14419     buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
14420     if (buf == NULL) {
14421     xmlFreeParserCtxt(ctxt);
14422     return(NULL);
14423     }
14424 
14425     input = xmlNewInputStream(ctxt);
14426     if (input == NULL) {
14427     xmlFreeParserInputBuffer(buf);
14428     xmlFreeParserCtxt(ctxt);
14429     return(NULL);
14430     }
14431 
14432     input-&gt;filename = NULL;
14433     input-&gt;buf = buf;
14434     xmlBufResetInput(input-&gt;buf-&gt;buffer, input);
14435 
14436     inputPush(ctxt, input);
14437     return(ctxt);
14438 }
14439 
14440 #ifdef LIBXML_SAX1_ENABLED
14441 /**
14442  * xmlSAXParseMemoryWithData:
14443  * @sax:  the SAX handler block
14444  * @buffer:  an pointer to a char array
14445  * @size:  the size of the array
14446  * @recovery:  work in recovery mode, i.e. tries to read no Well Formed
14447  *             documents
14448  * @data:  the userdata
14449  *
14450  * parse an XML in-memory block and use the given SAX function block
14451  * to handle the parsing callback. If sax is NULL, fallback to the default
14452  * DOM tree building routines.
14453  *
14454  * User data (void *) is stored within the parser context in the
14455  * context&#39;s _private member, so it is available nearly everywhere in libxml
14456  *
14457  * Returns the resulting document tree
14458  */
14459 
14460 xmlDocPtr
14461 xmlSAXParseMemoryWithData(xmlSAXHandlerPtr sax, const char *buffer,
14462               int size, int recovery, void *data) {
14463     xmlDocPtr ret;
14464     xmlParserCtxtPtr ctxt;
14465 
14466     xmlInitParser();
14467 
14468     ctxt = xmlCreateMemoryParserCtxt(buffer, size);
14469     if (ctxt == NULL) return(NULL);
14470     if (sax != NULL) {
14471     if (ctxt-&gt;sax != NULL)
14472         xmlFree(ctxt-&gt;sax);
14473         ctxt-&gt;sax = sax;
14474     }
14475     xmlDetectSAX2(ctxt);
14476     if (data!=NULL) {
14477     ctxt-&gt;_private=data;
14478     }
14479 
14480     ctxt-&gt;recovery = recovery;
14481 
14482     xmlParseDocument(ctxt);
14483 
14484     if ((ctxt-&gt;wellFormed) || recovery) ret = ctxt-&gt;myDoc;
14485     else {
14486        ret = NULL;
14487        xmlFreeDoc(ctxt-&gt;myDoc);
14488        ctxt-&gt;myDoc = NULL;
14489     }
14490     if (sax != NULL)
14491     ctxt-&gt;sax = NULL;
14492     xmlFreeParserCtxt(ctxt);
14493 
14494     return(ret);
14495 }
14496 
14497 /**
14498  * xmlSAXParseMemory:
14499  * @sax:  the SAX handler block
14500  * @buffer:  an pointer to a char array
14501  * @size:  the size of the array
14502  * @recovery:  work in recovery mode, i.e. tries to read not Well Formed
14503  *             documents
14504  *
14505  * parse an XML in-memory block and use the given SAX function block
14506  * to handle the parsing callback. If sax is NULL, fallback to the default
14507  * DOM tree building routines.
14508  *
14509  * Returns the resulting document tree
14510  */
14511 xmlDocPtr
14512 xmlSAXParseMemory(xmlSAXHandlerPtr sax, const char *buffer,
14513               int size, int recovery) {
14514     return xmlSAXParseMemoryWithData(sax, buffer, size, recovery, NULL);
14515 }
14516 
14517 /**
14518  * xmlParseMemory:
14519  * @buffer:  an pointer to a char array
14520  * @size:  the size of the array
14521  *
14522  * parse an XML in-memory block and build a tree.
14523  *
14524  * Returns the resulting document tree
14525  */
14526 
14527 xmlDocPtr xmlParseMemory(const char *buffer, int size) {
14528    return(xmlSAXParseMemory(NULL, buffer, size, 0));
14529 }
14530 
14531 /**
14532  * xmlRecoverMemory:
14533  * @buffer:  an pointer to a char array
14534  * @size:  the size of the array
14535  *
14536  * parse an XML in-memory block and build a tree.
14537  * In the case the document is not Well Formed, an attempt to
14538  * build a tree is tried anyway
14539  *
14540  * Returns the resulting document tree or NULL in case of error
14541  */
14542 
14543 xmlDocPtr xmlRecoverMemory(const char *buffer, int size) {
14544    return(xmlSAXParseMemory(NULL, buffer, size, 1));
14545 }
14546 
14547 /**
14548  * xmlSAXUserParseMemory:
14549  * @sax:  a SAX handler
14550  * @user_data:  The user data returned on SAX callbacks
14551  * @buffer:  an in-memory XML document input
14552  * @size:  the length of the XML document in bytes
14553  *
14554  * A better SAX parsing routine.
14555  * parse an XML in-memory buffer and call the given SAX handler routines.
14556  *
14557  * Returns 0 in case of success or a error number otherwise
14558  */
14559 int xmlSAXUserParseMemory(xmlSAXHandlerPtr sax, void *user_data,
14560               const char *buffer, int size) {
14561     int ret = 0;
14562     xmlParserCtxtPtr ctxt;
14563 
14564     xmlInitParser();
14565 
14566     ctxt = xmlCreateMemoryParserCtxt(buffer, size);
14567     if (ctxt == NULL) return -1;
14568     if (ctxt-&gt;sax != (xmlSAXHandlerPtr) &amp;xmlDefaultSAXHandler)
14569         xmlFree(ctxt-&gt;sax);
14570     ctxt-&gt;sax = sax;
14571     xmlDetectSAX2(ctxt);
14572 
14573     if (user_data != NULL)
14574     ctxt-&gt;userData = user_data;
14575 
14576     xmlParseDocument(ctxt);
14577 
14578     if (ctxt-&gt;wellFormed)
14579     ret = 0;
14580     else {
14581         if (ctxt-&gt;errNo != 0)
14582         ret = ctxt-&gt;errNo;
14583     else
14584         ret = -1;
14585     }
14586     if (sax != NULL)
14587         ctxt-&gt;sax = NULL;
14588     if (ctxt-&gt;myDoc != NULL) {
14589         xmlFreeDoc(ctxt-&gt;myDoc);
14590     ctxt-&gt;myDoc = NULL;
14591     }
14592     xmlFreeParserCtxt(ctxt);
14593 
14594     return ret;
14595 }
14596 #endif /* LIBXML_SAX1_ENABLED */
14597 
14598 /**
14599  * xmlCreateDocParserCtxt:
14600  * @cur:  a pointer to an array of xmlChar
14601  *
14602  * Creates a parser context for an XML in-memory document.
14603  *
14604  * Returns the new parser context or NULL
14605  */
14606 xmlParserCtxtPtr
14607 xmlCreateDocParserCtxt(const xmlChar *cur) {
14608     int len;
14609 
14610     if (cur == NULL)
14611     return(NULL);
14612     len = xmlStrlen(cur);
14613     return(xmlCreateMemoryParserCtxt((const char *)cur, len));
14614 }
14615 
14616 #ifdef LIBXML_SAX1_ENABLED
14617 /**
14618  * xmlSAXParseDoc:
14619  * @sax:  the SAX handler block
14620  * @cur:  a pointer to an array of xmlChar
14621  * @recovery:  work in recovery mode, i.e. tries to read no Well Formed
14622  *             documents
14623  *
14624  * parse an XML in-memory document and build a tree.
14625  * It use the given SAX function block to handle the parsing callback.
14626  * If sax is NULL, fallback to the default DOM tree building routines.
14627  *
14628  * Returns the resulting document tree
14629  */
14630 
14631 xmlDocPtr
14632 xmlSAXParseDoc(xmlSAXHandlerPtr sax, const xmlChar *cur, int recovery) {
14633     xmlDocPtr ret;
14634     xmlParserCtxtPtr ctxt;
14635     xmlSAXHandlerPtr oldsax = NULL;
14636 
14637     if (cur == NULL) return(NULL);
14638 
14639 
14640     ctxt = xmlCreateDocParserCtxt(cur);
14641     if (ctxt == NULL) return(NULL);
14642     if (sax != NULL) {
14643         oldsax = ctxt-&gt;sax;
14644         ctxt-&gt;sax = sax;
14645         ctxt-&gt;userData = NULL;
14646     }
14647     xmlDetectSAX2(ctxt);
14648 
14649     xmlParseDocument(ctxt);
14650     if ((ctxt-&gt;wellFormed) || recovery) ret = ctxt-&gt;myDoc;
14651     else {
14652        ret = NULL;
14653        xmlFreeDoc(ctxt-&gt;myDoc);
14654        ctxt-&gt;myDoc = NULL;
14655     }
14656     if (sax != NULL)
14657     ctxt-&gt;sax = oldsax;
14658     xmlFreeParserCtxt(ctxt);
14659 
14660     return(ret);
14661 }
14662 
14663 /**
14664  * xmlParseDoc:
14665  * @cur:  a pointer to an array of xmlChar
14666  *
14667  * parse an XML in-memory document and build a tree.
14668  *
14669  * Returns the resulting document tree
14670  */
14671 
14672 xmlDocPtr
14673 xmlParseDoc(const xmlChar *cur) {
14674     return(xmlSAXParseDoc(NULL, cur, 0));
14675 }
14676 #endif /* LIBXML_SAX1_ENABLED */
14677 
14678 #ifdef LIBXML_LEGACY_ENABLED
14679 /************************************************************************
14680  *                                  *
14681  *  Specific function to keep track of entities references      *
14682  *  and used by the XSLT debugger                   *
14683  *                                  *
14684  ************************************************************************/
14685 
14686 static xmlEntityReferenceFunc xmlEntityRefFunc = NULL;
14687 
14688 /**
14689  * xmlAddEntityReference:
14690  * @ent : A valid entity
14691  * @firstNode : A valid first node for children of entity
14692  * @lastNode : A valid last node of children entity
14693  *
14694  * Notify of a reference to an entity of type XML_EXTERNAL_GENERAL_PARSED_ENTITY
14695  */
14696 static void
14697 xmlAddEntityReference(xmlEntityPtr ent, xmlNodePtr firstNode,
14698                       xmlNodePtr lastNode)
14699 {
14700     if (xmlEntityRefFunc != NULL) {
14701         (*xmlEntityRefFunc) (ent, firstNode, lastNode);
14702     }
14703 }
14704 
14705 
14706 /**
14707  * xmlSetEntityReferenceFunc:
14708  * @func: A valid function
14709  *
14710  * Set the function to call call back when a xml reference has been made
14711  */
14712 void
14713 xmlSetEntityReferenceFunc(xmlEntityReferenceFunc func)
14714 {
14715     xmlEntityRefFunc = func;
14716 }
14717 #endif /* LIBXML_LEGACY_ENABLED */
14718 
14719 /************************************************************************
14720  *                                  *
14721  *              Miscellaneous               *
14722  *                                  *
14723  ************************************************************************/
14724 
14725 #ifdef LIBXML_XPATH_ENABLED
14726 #include &lt;libxml/xpath.h&gt;
14727 #endif
14728 
14729 extern void XMLCDECL xmlGenericErrorDefaultFunc(void *ctx, const char *msg, ...);
14730 static int xmlParserInitialized = 0;
14731 
14732 /**
14733  * xmlInitParser:
14734  *
14735  * Initialization function for the XML parser.
14736  * This is not reentrant. Call once before processing in case of
14737  * use in multithreaded programs.
14738  */
14739 
14740 void
14741 xmlInitParser(void) {
14742     if (xmlParserInitialized != 0)
14743     return;
14744 
14745 #ifdef LIBXML_THREAD_ENABLED
14746     __xmlGlobalInitMutexLock();
14747     if (xmlParserInitialized == 0) {
14748 #endif
14749     xmlInitThreads();
14750     xmlInitGlobals();
14751     if ((xmlGenericError == xmlGenericErrorDefaultFunc) ||
14752         (xmlGenericError == NULL))
14753         initGenericErrorDefaultFunc(NULL);
14754     xmlInitMemory();
14755         xmlInitializeDict();
14756     xmlInitCharEncodingHandlers();
14757     xmlDefaultSAXHandlerInit();
14758     xmlRegisterDefaultInputCallbacks();
14759 #ifdef LIBXML_OUTPUT_ENABLED
14760     xmlRegisterDefaultOutputCallbacks();
14761 #endif /* LIBXML_OUTPUT_ENABLED */
14762 #ifdef LIBXML_HTML_ENABLED
14763     htmlInitAutoClose();
14764     htmlDefaultSAXHandlerInit();
14765 #endif
14766 #ifdef LIBXML_XPATH_ENABLED
14767     xmlXPathInit();
14768 #endif
14769     xmlParserInitialized = 1;
14770 #ifdef LIBXML_THREAD_ENABLED
14771     }
14772     __xmlGlobalInitMutexUnlock();
14773 #endif
14774 }
14775 
14776 /**
14777  * xmlCleanupParser:
14778  *
14779  * This function name is somewhat misleading. It does not clean up
14780  * parser state, it cleans up memory allocated by the library itself.
14781  * It is a cleanup function for the XML library. It tries to reclaim all
14782  * related global memory allocated for the library processing.
14783  * It doesn&#39;t deallocate any document related memory. One should
14784  * call xmlCleanupParser() only when the process has finished using
14785  * the library and all XML/HTML documents built with it.
14786  * See also xmlInitParser() which has the opposite function of preparing
14787  * the library for operations.
14788  *
14789  * WARNING: if your application is multithreaded or has plugin support
14790  *          calling this may crash the application if another thread or
14791  *          a plugin is still using libxml2. It&#39;s sometimes very hard to
14792  *          guess if libxml2 is in use in the application, some libraries
14793  *          or plugins may use it without notice. In case of doubt abstain
14794  *          from calling this function or do it just before calling exit()
14795  *          to avoid leak reports from valgrind !
14796  */
14797 
14798 void
14799 xmlCleanupParser(void) {
14800     if (!xmlParserInitialized)
14801     return;
14802 
14803     xmlCleanupCharEncodingHandlers();
14804 #ifdef LIBXML_CATALOG_ENABLED
14805     xmlCatalogCleanup();
14806 #endif
14807     xmlDictCleanup();
14808     xmlCleanupInputCallbacks();
14809 #ifdef LIBXML_OUTPUT_ENABLED
14810     xmlCleanupOutputCallbacks();
14811 #endif
14812 #ifdef LIBXML_SCHEMAS_ENABLED
14813     xmlSchemaCleanupTypes();
14814     xmlRelaxNGCleanupTypes();
14815 #endif
14816     xmlResetLastError();
14817     xmlCleanupGlobals();
14818     xmlCleanupThreads(); /* must be last if called not from the main thread */
14819     xmlCleanupMemory();
14820     xmlParserInitialized = 0;
14821 }
14822 
14823 /************************************************************************
14824  *                                  *
14825  *  New set (2.6.0) of simpler and more flexible APIs       *
14826  *                                  *
14827  ************************************************************************/
14828 
14829 /**
14830  * DICT_FREE:
14831  * @str:  a string
14832  *
14833  * Free a string if it is not owned by the &quot;dict&quot; dictionary in the
14834  * current scope
14835  */
14836 #define DICT_FREE(str)                      \
14837     if ((str) &amp;&amp; ((!dict) ||                \
14838         (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))  \
14839         xmlFree((char *)(str));
14840 
14841 /**
14842  * xmlCtxtReset:
14843  * @ctxt: an XML parser context
14844  *
14845  * Reset a parser context
14846  */
14847 void
14848 xmlCtxtReset(xmlParserCtxtPtr ctxt)
14849 {
14850     xmlParserInputPtr input;
14851     xmlDictPtr dict;
14852 
14853     if (ctxt == NULL)
14854         return;
14855 
14856     dict = ctxt-&gt;dict;
14857 
14858     while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */
14859         xmlFreeInputStream(input);
14860     }
14861     ctxt-&gt;inputNr = 0;
14862     ctxt-&gt;input = NULL;
14863 
14864     ctxt-&gt;spaceNr = 0;
14865     if (ctxt-&gt;spaceTab != NULL) {
14866     ctxt-&gt;spaceTab[0] = -1;
14867     ctxt-&gt;space = &amp;ctxt-&gt;spaceTab[0];
14868     } else {
14869         ctxt-&gt;space = NULL;
14870     }
14871 
14872 
14873     ctxt-&gt;nodeNr = 0;
14874     ctxt-&gt;node = NULL;
14875 
14876     ctxt-&gt;nameNr = 0;
14877     ctxt-&gt;name = NULL;
14878 
14879     DICT_FREE(ctxt-&gt;version);
14880     ctxt-&gt;version = NULL;
14881     DICT_FREE(ctxt-&gt;encoding);
14882     ctxt-&gt;encoding = NULL;
14883     DICT_FREE(ctxt-&gt;directory);
14884     ctxt-&gt;directory = NULL;
14885     DICT_FREE(ctxt-&gt;extSubURI);
14886     ctxt-&gt;extSubURI = NULL;
14887     DICT_FREE(ctxt-&gt;extSubSystem);
14888     ctxt-&gt;extSubSystem = NULL;
14889     if (ctxt-&gt;myDoc != NULL)
14890         xmlFreeDoc(ctxt-&gt;myDoc);
14891     ctxt-&gt;myDoc = NULL;
14892 
14893     ctxt-&gt;standalone = -1;
14894     ctxt-&gt;hasExternalSubset = 0;
14895     ctxt-&gt;hasPErefs = 0;
14896     ctxt-&gt;html = 0;
14897     ctxt-&gt;external = 0;
14898     ctxt-&gt;instate = XML_PARSER_START;
14899     ctxt-&gt;token = 0;
14900 
14901     ctxt-&gt;wellFormed = 1;
14902     ctxt-&gt;nsWellFormed = 1;
14903     ctxt-&gt;disableSAX = 0;
14904     ctxt-&gt;valid = 1;
14905 #if 0
14906     ctxt-&gt;vctxt.userData = ctxt;
14907     ctxt-&gt;vctxt.error = xmlParserValidityError;
14908     ctxt-&gt;vctxt.warning = xmlParserValidityWarning;
14909 #endif
14910     ctxt-&gt;record_info = 0;
14911     ctxt-&gt;nbChars = 0;
14912     ctxt-&gt;checkIndex = 0;
14913     ctxt-&gt;inSubset = 0;
14914     ctxt-&gt;errNo = XML_ERR_OK;
14915     ctxt-&gt;depth = 0;
14916     ctxt-&gt;charset = XML_CHAR_ENCODING_UTF8;
14917     ctxt-&gt;catalogs = NULL;
14918     ctxt-&gt;nbentities = 0;
14919     ctxt-&gt;sizeentities = 0;
14920     ctxt-&gt;sizeentcopy = 0;
14921     xmlInitNodeInfoSeq(&amp;ctxt-&gt;node_seq);
14922 
14923     if (ctxt-&gt;attsDefault != NULL) {
14924         xmlHashFree(ctxt-&gt;attsDefault, xmlHashDefaultDeallocator);
14925         ctxt-&gt;attsDefault = NULL;
14926     }
14927     if (ctxt-&gt;attsSpecial != NULL) {
14928         xmlHashFree(ctxt-&gt;attsSpecial, NULL);
14929         ctxt-&gt;attsSpecial = NULL;
14930     }
14931 
14932 #ifdef LIBXML_CATALOG_ENABLED
14933     if (ctxt-&gt;catalogs != NULL)
14934     xmlCatalogFreeLocal(ctxt-&gt;catalogs);
14935 #endif
14936     if (ctxt-&gt;lastError.code != XML_ERR_OK)
14937         xmlResetError(&amp;ctxt-&gt;lastError);
14938 }
14939 
14940 /**
14941  * xmlCtxtResetPush:
14942  * @ctxt: an XML parser context
14943  * @chunk:  a pointer to an array of chars
14944  * @size:  number of chars in the array
14945  * @filename:  an optional file name or URI
14946  * @encoding:  the document encoding, or NULL
14947  *
14948  * Reset a push parser context
14949  *
14950  * Returns 0 in case of success and 1 in case of error
14951  */
14952 int
14953 xmlCtxtResetPush(xmlParserCtxtPtr ctxt, const char *chunk,
14954                  int size, const char *filename, const char *encoding)
14955 {
14956     xmlParserInputPtr inputStream;
14957     xmlParserInputBufferPtr buf;
14958     xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;
14959 
14960     if (ctxt == NULL)
14961         return(1);
14962 
14963     if ((encoding == NULL) &amp;&amp; (chunk != NULL) &amp;&amp; (size &gt;= 4))
14964         enc = xmlDetectCharEncoding((const xmlChar *) chunk, size);
14965 
14966     buf = xmlAllocParserInputBuffer(enc);
14967     if (buf == NULL)
14968         return(1);
14969 
14970     if (ctxt == NULL) {
14971         xmlFreeParserInputBuffer(buf);
14972         return(1);
14973     }
14974 
14975     xmlCtxtReset(ctxt);
14976 
14977     if (filename == NULL) {
14978         ctxt-&gt;directory = NULL;
14979     } else {
14980         ctxt-&gt;directory = xmlParserGetDirectory(filename);
14981     }
14982 
14983     inputStream = xmlNewInputStream(ctxt);
14984     if (inputStream == NULL) {
14985         xmlFreeParserInputBuffer(buf);
14986         return(1);
14987     }
14988 
14989     if (filename == NULL)
14990         inputStream-&gt;filename = NULL;
14991     else
14992         inputStream-&gt;filename = (char *)
14993             xmlCanonicPath((const xmlChar *) filename);
14994     inputStream-&gt;buf = buf;
14995     xmlBufResetInput(buf-&gt;buffer, inputStream);
14996 
14997     inputPush(ctxt, inputStream);
14998 
14999     if ((size &gt; 0) &amp;&amp; (chunk != NULL) &amp;&amp; (ctxt-&gt;input != NULL) &amp;&amp;
15000         (ctxt-&gt;input-&gt;buf != NULL)) {
15001     size_t base = xmlBufGetInputBase(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input);
15002         size_t cur = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
15003 
15004         xmlParserInputBufferPush(ctxt-&gt;input-&gt;buf, size, chunk);
15005 
15006         xmlBufSetInputBaseCur(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input, base, cur);
15007 #ifdef DEBUG_PUSH
15008         xmlGenericError(xmlGenericErrorContext, &quot;PP: pushed %d\n&quot;, size);
15009 #endif
15010     }
15011 
15012     if (encoding != NULL) {
15013         xmlCharEncodingHandlerPtr hdlr;
15014 
15015         if (ctxt-&gt;encoding != NULL)
15016         xmlFree((xmlChar *) ctxt-&gt;encoding);
15017         ctxt-&gt;encoding = xmlStrdup((const xmlChar *) encoding);
15018 
15019         hdlr = xmlFindCharEncodingHandler(encoding);
15020         if (hdlr != NULL) {
15021             xmlSwitchToEncoding(ctxt, hdlr);
15022     } else {
15023         xmlFatalErrMsgStr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
15024                   &quot;Unsupported encoding %s\n&quot;, BAD_CAST encoding);
15025         }
15026     } else if (enc != XML_CHAR_ENCODING_NONE) {
15027         xmlSwitchEncoding(ctxt, enc);
15028     }
15029 
15030     return(0);
15031 }
15032 
15033 
15034 /**
15035  * xmlCtxtUseOptionsInternal:
15036  * @ctxt: an XML parser context
15037  * @options:  a combination of xmlParserOption
15038  * @encoding:  the user provided encoding to use
15039  *
15040  * Applies the options to the parser context
15041  *
15042  * Returns 0 in case of success, the set of unknown or unimplemented options
15043  *         in case of error.
15044  */
15045 static int
15046 xmlCtxtUseOptionsInternal(xmlParserCtxtPtr ctxt, int options, const char *encoding)
15047 {
15048     if (ctxt == NULL)
15049         return(-1);
15050     if (encoding != NULL) {
15051         if (ctxt-&gt;encoding != NULL)
15052         xmlFree((xmlChar *) ctxt-&gt;encoding);
15053         ctxt-&gt;encoding = xmlStrdup((const xmlChar *) encoding);
15054     }
15055     if (options &amp; XML_PARSE_RECOVER) {
15056         ctxt-&gt;recovery = 1;
15057         options -= XML_PARSE_RECOVER;
15058     ctxt-&gt;options |= XML_PARSE_RECOVER;
15059     } else
15060         ctxt-&gt;recovery = 0;
15061     if (options &amp; XML_PARSE_DTDLOAD) {
15062         ctxt-&gt;loadsubset = XML_DETECT_IDS;
15063         options -= XML_PARSE_DTDLOAD;
15064     ctxt-&gt;options |= XML_PARSE_DTDLOAD;
15065     } else
15066         ctxt-&gt;loadsubset = 0;
15067     if (options &amp; XML_PARSE_DTDATTR) {
15068         ctxt-&gt;loadsubset |= XML_COMPLETE_ATTRS;
15069         options -= XML_PARSE_DTDATTR;
15070     ctxt-&gt;options |= XML_PARSE_DTDATTR;
15071     }
15072     if (options &amp; XML_PARSE_NOENT) {
15073         ctxt-&gt;replaceEntities = 1;
15074         /* ctxt-&gt;loadsubset |= XML_DETECT_IDS; */
15075         options -= XML_PARSE_NOENT;
15076     ctxt-&gt;options |= XML_PARSE_NOENT;
15077     } else
15078         ctxt-&gt;replaceEntities = 0;
15079     if (options &amp; XML_PARSE_PEDANTIC) {
15080         ctxt-&gt;pedantic = 1;
15081         options -= XML_PARSE_PEDANTIC;
15082     ctxt-&gt;options |= XML_PARSE_PEDANTIC;
15083     } else
15084         ctxt-&gt;pedantic = 0;
15085     if (options &amp; XML_PARSE_NOBLANKS) {
15086         ctxt-&gt;keepBlanks = 0;
15087         ctxt-&gt;sax-&gt;ignorableWhitespace = xmlSAX2IgnorableWhitespace;
15088         options -= XML_PARSE_NOBLANKS;
15089     ctxt-&gt;options |= XML_PARSE_NOBLANKS;
15090     } else
15091         ctxt-&gt;keepBlanks = 1;
15092     if (options &amp; XML_PARSE_DTDVALID) {
15093         ctxt-&gt;validate = 1;
15094         if (options &amp; XML_PARSE_NOWARNING)
15095             ctxt-&gt;vctxt.warning = NULL;
15096         if (options &amp; XML_PARSE_NOERROR)
15097             ctxt-&gt;vctxt.error = NULL;
15098         options -= XML_PARSE_DTDVALID;
15099     ctxt-&gt;options |= XML_PARSE_DTDVALID;
15100     } else
15101         ctxt-&gt;validate = 0;
15102     if (options &amp; XML_PARSE_NOWARNING) {
15103         ctxt-&gt;sax-&gt;warning = NULL;
15104         options -= XML_PARSE_NOWARNING;
15105     }
15106     if (options &amp; XML_PARSE_NOERROR) {
15107         ctxt-&gt;sax-&gt;error = NULL;
15108         ctxt-&gt;sax-&gt;fatalError = NULL;
15109         options -= XML_PARSE_NOERROR;
15110     }
15111 #ifdef LIBXML_SAX1_ENABLED
15112     if (options &amp; XML_PARSE_SAX1) {
15113         ctxt-&gt;sax-&gt;startElement = xmlSAX2StartElement;
15114         ctxt-&gt;sax-&gt;endElement = xmlSAX2EndElement;
15115         ctxt-&gt;sax-&gt;startElementNs = NULL;
15116         ctxt-&gt;sax-&gt;endElementNs = NULL;
15117         ctxt-&gt;sax-&gt;initialized = 1;
15118         options -= XML_PARSE_SAX1;
15119     ctxt-&gt;options |= XML_PARSE_SAX1;
15120     }
15121 #endif /* LIBXML_SAX1_ENABLED */
15122     if (options &amp; XML_PARSE_NODICT) {
15123         ctxt-&gt;dictNames = 0;
15124         options -= XML_PARSE_NODICT;
15125     ctxt-&gt;options |= XML_PARSE_NODICT;
15126     } else {
15127         ctxt-&gt;dictNames = 1;
15128     }
15129     if (options &amp; XML_PARSE_NOCDATA) {
15130         ctxt-&gt;sax-&gt;cdataBlock = NULL;
15131         options -= XML_PARSE_NOCDATA;
15132     ctxt-&gt;options |= XML_PARSE_NOCDATA;
15133     }
15134     if (options &amp; XML_PARSE_NSCLEAN) {
15135     ctxt-&gt;options |= XML_PARSE_NSCLEAN;
15136         options -= XML_PARSE_NSCLEAN;
15137     }
15138     if (options &amp; XML_PARSE_NONET) {
15139     ctxt-&gt;options |= XML_PARSE_NONET;
15140         options -= XML_PARSE_NONET;
15141     }
15142     if (options &amp; XML_PARSE_COMPACT) {
15143     ctxt-&gt;options |= XML_PARSE_COMPACT;
15144         options -= XML_PARSE_COMPACT;
15145     }
15146     if (options &amp; XML_PARSE_OLD10) {
15147     ctxt-&gt;options |= XML_PARSE_OLD10;
15148         options -= XML_PARSE_OLD10;
15149     }
15150     if (options &amp; XML_PARSE_NOBASEFIX) {
15151     ctxt-&gt;options |= XML_PARSE_NOBASEFIX;
15152         options -= XML_PARSE_NOBASEFIX;
15153     }
15154     if (options &amp; XML_PARSE_HUGE) {
15155     ctxt-&gt;options |= XML_PARSE_HUGE;
15156         options -= XML_PARSE_HUGE;
15157         if (ctxt-&gt;dict != NULL)
15158             xmlDictSetLimit(ctxt-&gt;dict, 0);
15159     }
15160     if (options &amp; XML_PARSE_OLDSAX) {
15161     ctxt-&gt;options |= XML_PARSE_OLDSAX;
15162         options -= XML_PARSE_OLDSAX;
15163     }
15164     if (options &amp; XML_PARSE_IGNORE_ENC) {
15165     ctxt-&gt;options |= XML_PARSE_IGNORE_ENC;
15166         options -= XML_PARSE_IGNORE_ENC;
15167     }
15168     if (options &amp; XML_PARSE_BIG_LINES) {
15169     ctxt-&gt;options |= XML_PARSE_BIG_LINES;
15170         options -= XML_PARSE_BIG_LINES;
15171     }
15172     ctxt-&gt;linenumbers = 1;
15173     return (options);
15174 }
15175 
15176 /**
15177  * xmlCtxtUseOptions:
15178  * @ctxt: an XML parser context
15179  * @options:  a combination of xmlParserOption
15180  *
15181  * Applies the options to the parser context
15182  *
15183  * Returns 0 in case of success, the set of unknown or unimplemented options
15184  *         in case of error.
15185  */
15186 int
15187 xmlCtxtUseOptions(xmlParserCtxtPtr ctxt, int options)
15188 {
15189    return(xmlCtxtUseOptionsInternal(ctxt, options, NULL));
15190 }
15191 
15192 /**
15193  * xmlDoRead:
15194  * @ctxt:  an XML parser context
15195  * @URL:  the base URL to use for the document
15196  * @encoding:  the document encoding, or NULL
15197  * @options:  a combination of xmlParserOption
15198  * @reuse:  keep the context for reuse
15199  *
15200  * Common front-end for the xmlRead functions
15201  *
15202  * Returns the resulting document tree or NULL
15203  */
15204 static xmlDocPtr
15205 xmlDoRead(xmlParserCtxtPtr ctxt, const char *URL, const char *encoding,
15206           int options, int reuse)
15207 {
15208     xmlDocPtr ret;
15209 
15210     xmlCtxtUseOptionsInternal(ctxt, options, encoding);
15211     if (encoding != NULL) {
15212         xmlCharEncodingHandlerPtr hdlr;
15213 
15214     hdlr = xmlFindCharEncodingHandler(encoding);
15215     if (hdlr != NULL)
15216         xmlSwitchToEncoding(ctxt, hdlr);
15217     }
15218     if ((URL != NULL) &amp;&amp; (ctxt-&gt;input != NULL) &amp;&amp;
15219         (ctxt-&gt;input-&gt;filename == NULL))
15220         ctxt-&gt;input-&gt;filename = (char *) xmlStrdup((const xmlChar *) URL);
15221     xmlParseDocument(ctxt);
15222     if ((ctxt-&gt;wellFormed) || ctxt-&gt;recovery)
15223         ret = ctxt-&gt;myDoc;
15224     else {
15225         ret = NULL;
15226     if (ctxt-&gt;myDoc != NULL) {
15227         xmlFreeDoc(ctxt-&gt;myDoc);
15228     }
15229     }
15230     ctxt-&gt;myDoc = NULL;
15231     if (!reuse) {
15232     xmlFreeParserCtxt(ctxt);
15233     }
15234 
15235     return (ret);
15236 }
15237 
15238 /**
15239  * xmlReadDoc:
15240  * @cur:  a pointer to a zero terminated string
15241  * @URL:  the base URL to use for the document
15242  * @encoding:  the document encoding, or NULL
15243  * @options:  a combination of xmlParserOption
15244  *
15245  * parse an XML in-memory document and build a tree.
15246  *
15247  * Returns the resulting document tree
15248  */
15249 xmlDocPtr
15250 xmlReadDoc(const xmlChar * cur, const char *URL, const char *encoding, int options)
15251 {
15252     xmlParserCtxtPtr ctxt;
15253 
15254     if (cur == NULL)
15255         return (NULL);
15256     xmlInitParser();
15257 
15258     ctxt = xmlCreateDocParserCtxt(cur);
15259     if (ctxt == NULL)
15260         return (NULL);
15261     return (xmlDoRead(ctxt, URL, encoding, options, 0));
15262 }
15263 
15264 /**
15265  * xmlReadFile:
15266  * @filename:  a file or URL
15267  * @encoding:  the document encoding, or NULL
15268  * @options:  a combination of xmlParserOption
15269  *
15270  * parse an XML file from the filesystem or the network.
15271  *
15272  * Returns the resulting document tree
15273  */
15274 xmlDocPtr
15275 xmlReadFile(const char *filename, const char *encoding, int options)
15276 {
15277     xmlParserCtxtPtr ctxt;
15278 
15279     xmlInitParser();
15280     ctxt = xmlCreateURLParserCtxt(filename, options);
15281     if (ctxt == NULL)
15282         return (NULL);
15283     return (xmlDoRead(ctxt, NULL, encoding, options, 0));
15284 }
15285 
15286 /**
15287  * xmlReadMemory:
15288  * @buffer:  a pointer to a char array
15289  * @size:  the size of the array
15290  * @URL:  the base URL to use for the document
15291  * @encoding:  the document encoding, or NULL
15292  * @options:  a combination of xmlParserOption
15293  *
15294  * parse an XML in-memory document and build a tree.
15295  *
15296  * Returns the resulting document tree
15297  */
15298 xmlDocPtr
15299 xmlReadMemory(const char *buffer, int size, const char *URL, const char *encoding, int options)
15300 {
15301     xmlParserCtxtPtr ctxt;
15302 
15303     xmlInitParser();
15304     ctxt = xmlCreateMemoryParserCtxt(buffer, size);
15305     if (ctxt == NULL)
15306         return (NULL);
15307     return (xmlDoRead(ctxt, URL, encoding, options, 0));
15308 }
15309 
15310 /**
15311  * xmlReadFd:
15312  * @fd:  an open file descriptor
15313  * @URL:  the base URL to use for the document
15314  * @encoding:  the document encoding, or NULL
15315  * @options:  a combination of xmlParserOption
15316  *
15317  * parse an XML from a file descriptor and build a tree.
15318  * NOTE that the file descriptor will not be closed when the
15319  *      reader is closed or reset.
15320  *
15321  * Returns the resulting document tree
15322  */
15323 xmlDocPtr
15324 xmlReadFd(int fd, const char *URL, const char *encoding, int options)
15325 {
15326     xmlParserCtxtPtr ctxt;
15327     xmlParserInputBufferPtr input;
15328     xmlParserInputPtr stream;
15329 
15330     if (fd &lt; 0)
15331         return (NULL);
15332     xmlInitParser();
15333 
15334     input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
15335     if (input == NULL)
15336         return (NULL);
15337     input-&gt;closecallback = NULL;
15338     ctxt = xmlNewParserCtxt();
15339     if (ctxt == NULL) {
15340         xmlFreeParserInputBuffer(input);
15341         return (NULL);
15342     }
15343     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
15344     if (stream == NULL) {
15345         xmlFreeParserInputBuffer(input);
15346     xmlFreeParserCtxt(ctxt);
15347         return (NULL);
15348     }
15349     inputPush(ctxt, stream);
15350     return (xmlDoRead(ctxt, URL, encoding, options, 0));
15351 }
15352 
15353 /**
15354  * xmlReadIO:
15355  * @ioread:  an I/O read function
15356  * @ioclose:  an I/O close function
15357  * @ioctx:  an I/O handler
15358  * @URL:  the base URL to use for the document
15359  * @encoding:  the document encoding, or NULL
15360  * @options:  a combination of xmlParserOption
15361  *
15362  * parse an XML document from I/O functions and source and build a tree.
15363  *
15364  * Returns the resulting document tree
15365  */
15366 xmlDocPtr
15367 xmlReadIO(xmlInputReadCallback ioread, xmlInputCloseCallback ioclose,
15368           void *ioctx, const char *URL, const char *encoding, int options)
15369 {
15370     xmlParserCtxtPtr ctxt;
15371     xmlParserInputBufferPtr input;
15372     xmlParserInputPtr stream;
15373 
15374     if (ioread == NULL)
15375         return (NULL);
15376     xmlInitParser();
15377 
15378     input = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx,
15379                                          XML_CHAR_ENCODING_NONE);
15380     if (input == NULL) {
15381         if (ioclose != NULL)
15382             ioclose(ioctx);
15383         return (NULL);
15384     }
15385     ctxt = xmlNewParserCtxt();
15386     if (ctxt == NULL) {
15387         xmlFreeParserInputBuffer(input);
15388         return (NULL);
15389     }
15390     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
15391     if (stream == NULL) {
15392         xmlFreeParserInputBuffer(input);
15393     xmlFreeParserCtxt(ctxt);
15394         return (NULL);
15395     }
15396     inputPush(ctxt, stream);
15397     return (xmlDoRead(ctxt, URL, encoding, options, 0));
15398 }
15399 
15400 /**
15401  * xmlCtxtReadDoc:
15402  * @ctxt:  an XML parser context
15403  * @cur:  a pointer to a zero terminated string
15404  * @URL:  the base URL to use for the document
15405  * @encoding:  the document encoding, or NULL
15406  * @options:  a combination of xmlParserOption
15407  *
15408  * parse an XML in-memory document and build a tree.
15409  * This reuses the existing @ctxt parser context
15410  *
15411  * Returns the resulting document tree
15412  */
15413 xmlDocPtr
15414 xmlCtxtReadDoc(xmlParserCtxtPtr ctxt, const xmlChar * cur,
15415                const char *URL, const char *encoding, int options)
15416 {
15417     xmlParserInputPtr stream;
15418 
15419     if (cur == NULL)
15420         return (NULL);
15421     if (ctxt == NULL)
15422         return (NULL);
15423     xmlInitParser();
15424 
15425     xmlCtxtReset(ctxt);
15426 
15427     stream = xmlNewStringInputStream(ctxt, cur);
15428     if (stream == NULL) {
15429         return (NULL);
15430     }
15431     inputPush(ctxt, stream);
15432     return (xmlDoRead(ctxt, URL, encoding, options, 1));
15433 }
15434 
15435 /**
15436  * xmlCtxtReadFile:
15437  * @ctxt:  an XML parser context
15438  * @filename:  a file or URL
15439  * @encoding:  the document encoding, or NULL
15440  * @options:  a combination of xmlParserOption
15441  *
15442  * parse an XML file from the filesystem or the network.
15443  * This reuses the existing @ctxt parser context
15444  *
15445  * Returns the resulting document tree
15446  */
15447 xmlDocPtr
15448 xmlCtxtReadFile(xmlParserCtxtPtr ctxt, const char *filename,
15449                 const char *encoding, int options)
15450 {
15451     xmlParserInputPtr stream;
15452 
15453     if (filename == NULL)
15454         return (NULL);
15455     if (ctxt == NULL)
15456         return (NULL);
15457     xmlInitParser();
15458 
15459     xmlCtxtReset(ctxt);
15460 
15461     stream = xmlLoadExternalEntity(filename, NULL, ctxt);
15462     if (stream == NULL) {
15463         return (NULL);
15464     }
15465     inputPush(ctxt, stream);
15466     return (xmlDoRead(ctxt, NULL, encoding, options, 1));
15467 }
15468 
15469 /**
15470  * xmlCtxtReadMemory:
15471  * @ctxt:  an XML parser context
15472  * @buffer:  a pointer to a char array
15473  * @size:  the size of the array
15474  * @URL:  the base URL to use for the document
15475  * @encoding:  the document encoding, or NULL
15476  * @options:  a combination of xmlParserOption
15477  *
15478  * parse an XML in-memory document and build a tree.
15479  * This reuses the existing @ctxt parser context
15480  *
15481  * Returns the resulting document tree
15482  */
15483 xmlDocPtr
15484 xmlCtxtReadMemory(xmlParserCtxtPtr ctxt, const char *buffer, int size,
15485                   const char *URL, const char *encoding, int options)
15486 {
15487     xmlParserInputBufferPtr input;
15488     xmlParserInputPtr stream;
15489 
15490     if (ctxt == NULL)
15491         return (NULL);
15492     if (buffer == NULL)
15493         return (NULL);
15494     xmlInitParser();
15495 
15496     xmlCtxtReset(ctxt);
15497 
15498     input = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
15499     if (input == NULL) {
15500     return(NULL);
15501     }
15502 
15503     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
15504     if (stream == NULL) {
15505     xmlFreeParserInputBuffer(input);
15506     return(NULL);
15507     }
15508 
15509     inputPush(ctxt, stream);
15510     return (xmlDoRead(ctxt, URL, encoding, options, 1));
15511 }
15512 
15513 /**
15514  * xmlCtxtReadFd:
15515  * @ctxt:  an XML parser context
15516  * @fd:  an open file descriptor
15517  * @URL:  the base URL to use for the document
15518  * @encoding:  the document encoding, or NULL
15519  * @options:  a combination of xmlParserOption
15520  *
15521  * parse an XML from a file descriptor and build a tree.
15522  * This reuses the existing @ctxt parser context
15523  * NOTE that the file descriptor will not be closed when the
15524  *      reader is closed or reset.
15525  *
15526  * Returns the resulting document tree
15527  */
15528 xmlDocPtr
15529 xmlCtxtReadFd(xmlParserCtxtPtr ctxt, int fd,
15530               const char *URL, const char *encoding, int options)
15531 {
15532     xmlParserInputBufferPtr input;
15533     xmlParserInputPtr stream;
15534 
15535     if (fd &lt; 0)
15536         return (NULL);
15537     if (ctxt == NULL)
15538         return (NULL);
15539     xmlInitParser();
15540 
15541     xmlCtxtReset(ctxt);
15542 
15543 
15544     input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
15545     if (input == NULL)
15546         return (NULL);
15547     input-&gt;closecallback = NULL;
15548     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
15549     if (stream == NULL) {
15550         xmlFreeParserInputBuffer(input);
15551         return (NULL);
15552     }
15553     inputPush(ctxt, stream);
15554     return (xmlDoRead(ctxt, URL, encoding, options, 1));
15555 }
15556 
15557 /**
15558  * xmlCtxtReadIO:
15559  * @ctxt:  an XML parser context
15560  * @ioread:  an I/O read function
15561  * @ioclose:  an I/O close function
15562  * @ioctx:  an I/O handler
15563  * @URL:  the base URL to use for the document
15564  * @encoding:  the document encoding, or NULL
15565  * @options:  a combination of xmlParserOption
15566  *
15567  * parse an XML document from I/O functions and source and build a tree.
15568  * This reuses the existing @ctxt parser context
15569  *
15570  * Returns the resulting document tree
15571  */
15572 xmlDocPtr
15573 xmlCtxtReadIO(xmlParserCtxtPtr ctxt, xmlInputReadCallback ioread,
15574               xmlInputCloseCallback ioclose, void *ioctx,
15575           const char *URL,
15576               const char *encoding, int options)
15577 {
15578     xmlParserInputBufferPtr input;
15579     xmlParserInputPtr stream;
15580 
15581     if (ioread == NULL)
15582         return (NULL);
15583     if (ctxt == NULL)
15584         return (NULL);
15585     xmlInitParser();
15586 
15587     xmlCtxtReset(ctxt);
15588 
15589     input = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx,
15590                                          XML_CHAR_ENCODING_NONE);
15591     if (input == NULL) {
15592         if (ioclose != NULL)
15593             ioclose(ioctx);
15594         return (NULL);
15595     }
15596     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
15597     if (stream == NULL) {
15598         xmlFreeParserInputBuffer(input);
15599         return (NULL);
15600     }
15601     inputPush(ctxt, stream);
15602     return (xmlDoRead(ctxt, URL, encoding, options, 1));
15603 }
15604 
15605 #define bottom_parser
15606 #include &quot;elfgcchack.h&quot;
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
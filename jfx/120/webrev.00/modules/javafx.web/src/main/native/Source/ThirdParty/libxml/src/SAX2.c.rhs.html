<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/SAX2.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * SAX2.c : Default SAX2 handler to build a tree.
   3  *
   4  * See Copyright for the status of this software.
   5  *
   6  * Daniel Veillard &lt;daniel@veillard.com&gt;
   7  */
   8 
   9 
  10 #define IN_LIBXML
  11 #include &quot;libxml.h&quot;
  12 #include &lt;stdlib.h&gt;
  13 #include &lt;string.h&gt;
  14 #include &lt;limits.h&gt;
  15 #include &lt;stddef.h&gt;
  16 #include &lt;libxml/xmlmemory.h&gt;
  17 #include &lt;libxml/tree.h&gt;
  18 #include &lt;libxml/parser.h&gt;
  19 #include &lt;libxml/parserInternals.h&gt;
  20 #include &lt;libxml/valid.h&gt;
  21 #include &lt;libxml/entities.h&gt;
  22 #include &lt;libxml/xmlerror.h&gt;
  23 #include &lt;libxml/debugXML.h&gt;
  24 #include &lt;libxml/xmlIO.h&gt;
  25 #include &lt;libxml/SAX.h&gt;
  26 #include &lt;libxml/uri.h&gt;
  27 #include &lt;libxml/valid.h&gt;
  28 #include &lt;libxml/HTMLtree.h&gt;
  29 #include &lt;libxml/globals.h&gt;
  30 
  31 /* Define SIZE_T_MAX unless defined through &lt;limits.h&gt;. */
  32 #ifndef SIZE_T_MAX
  33 # define SIZE_T_MAX     ((size_t)-1)
  34 #endif /* !SIZE_T_MAX */
  35 
  36 /* #define DEBUG_SAX2 */
  37 /* #define DEBUG_SAX2_TREE */
  38 
  39 /**
  40  * TODO:
  41  *
  42  * macro to flag unimplemented blocks
<a name="1" id="anc1"></a><span class="line-modified">  43  * XML_CATALOG_PREFER user env to select between system/public preferred</span>
  44  * option. C.f. Richard Tobin &lt;richard@cogsci.ed.ac.uk&gt;
  45  *&gt; Just FYI, I am using an environment variable XML_CATALOG_PREFER with
  46  *&gt; values &quot;system&quot; and &quot;public&quot;.  I have made the default be &quot;system&quot; to
  47  *&gt; match yours.
  48  */
  49 #define TODO                                \
  50     xmlGenericError(xmlGenericErrorContext,             \
  51         &quot;Unimplemented block at %s:%d\n&quot;,               \
  52             __FILE__, __LINE__);
  53 
  54 /*
  55  * xmlSAX2ErrMemory:
  56  * @ctxt:  an XML validation parser context
  57  * @msg:   a string to accompany the error message
  58  */
  59 static void LIBXML_ATTR_FORMAT(2,0)
  60 xmlSAX2ErrMemory(xmlParserCtxtPtr ctxt, const char *msg) {
  61     xmlStructuredErrorFunc schannel = NULL;
  62     const char *str1 = &quot;out of memory\n&quot;;
  63 
  64     if (ctxt != NULL) {
  65     ctxt-&gt;errNo = XML_ERR_NO_MEMORY;
  66     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;initialized == XML_SAX2_MAGIC))
  67         schannel = ctxt-&gt;sax-&gt;serror;
  68     __xmlRaiseError(schannel,
  69             ctxt-&gt;vctxt.error, ctxt-&gt;vctxt.userData,
  70             ctxt, NULL, XML_FROM_PARSER, XML_ERR_NO_MEMORY,
  71             XML_ERR_ERROR, NULL, 0, (const char *) str1,
  72             NULL, NULL, 0, 0,
  73             msg, (const char *) str1, NULL);
  74     ctxt-&gt;errNo = XML_ERR_NO_MEMORY;
  75     ctxt-&gt;instate = XML_PARSER_EOF;
  76     ctxt-&gt;disableSAX = 1;
  77     } else {
  78     __xmlRaiseError(schannel,
  79             NULL, NULL,
  80             ctxt, NULL, XML_FROM_PARSER, XML_ERR_NO_MEMORY,
  81             XML_ERR_ERROR, NULL, 0, (const char *) str1,
  82             NULL, NULL, 0, 0,
  83             msg, (const char *) str1, NULL);
  84     }
  85 }
  86 
  87 /**
  88  * xmlValidError:
  89  * @ctxt:  an XML validation parser context
  90  * @error:  the error number
  91  * @msg:  the error message
  92  * @str1:  extra data
  93  * @str2:  extra data
  94  *
  95  * Handle a validation error
  96  */
  97 static void LIBXML_ATTR_FORMAT(3,0)
  98 xmlErrValid(xmlParserCtxtPtr ctxt, xmlParserErrors error,
  99             const char *msg, const char *str1, const char *str2)
 100 {
 101     xmlStructuredErrorFunc schannel = NULL;
 102 
 103     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
 104         (ctxt-&gt;instate == XML_PARSER_EOF))
 105     return;
 106     if (ctxt != NULL) {
 107     ctxt-&gt;errNo = error;
 108     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;initialized == XML_SAX2_MAGIC))
 109         schannel = ctxt-&gt;sax-&gt;serror;
 110     __xmlRaiseError(schannel,
 111             ctxt-&gt;vctxt.error, ctxt-&gt;vctxt.userData,
 112             ctxt, NULL, XML_FROM_DTD, error,
 113             XML_ERR_ERROR, NULL, 0, (const char *) str1,
 114             (const char *) str2, NULL, 0, 0,
 115             msg, (const char *) str1, (const char *) str2);
 116     ctxt-&gt;valid = 0;
 117     } else {
 118     __xmlRaiseError(schannel,
 119             NULL, NULL,
 120             ctxt, NULL, XML_FROM_DTD, error,
 121             XML_ERR_ERROR, NULL, 0, (const char *) str1,
 122             (const char *) str2, NULL, 0, 0,
 123             msg, (const char *) str1, (const char *) str2);
 124     }
 125 }
 126 
 127 /**
 128  * xmlFatalErrMsg:
 129  * @ctxt:  an XML parser context
 130  * @error:  the error number
 131  * @msg:  the error message
 132  * @str1:  an error string
 133  * @str2:  an error string
 134  *
 135  * Handle a fatal parser error, i.e. violating Well-Formedness constraints
 136  */
 137 static void LIBXML_ATTR_FORMAT(3,0)
 138 xmlFatalErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 139                const char *msg, const xmlChar *str1, const xmlChar *str2)
 140 {
 141     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
 142         (ctxt-&gt;instate == XML_PARSER_EOF))
 143     return;
 144     if (ctxt != NULL)
 145     ctxt-&gt;errNo = error;
 146     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
 147                     XML_ERR_FATAL, NULL, 0,
 148             (const char *) str1, (const char *) str2,
 149             NULL, 0, 0, msg, str1, str2);
 150     if (ctxt != NULL) {
 151     ctxt-&gt;wellFormed = 0;
 152     ctxt-&gt;valid = 0;
 153     if (ctxt-&gt;recovery == 0)
 154         ctxt-&gt;disableSAX = 1;
 155     }
 156 }
 157 
 158 /**
 159  * xmlWarnMsg:
 160  * @ctxt:  an XML parser context
 161  * @error:  the error number
 162  * @msg:  the error message
 163  * @str1:  an error string
 164  * @str2:  an error string
 165  *
 166  * Handle a parser warning
 167  */
 168 static void LIBXML_ATTR_FORMAT(3,0)
 169 xmlWarnMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 170                const char *msg, const xmlChar *str1)
 171 {
 172     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
 173         (ctxt-&gt;instate == XML_PARSER_EOF))
 174     return;
 175     if (ctxt != NULL)
 176     ctxt-&gt;errNo = error;
 177     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
 178                     XML_ERR_WARNING, NULL, 0,
 179             (const char *) str1, NULL,
 180             NULL, 0, 0, msg, str1);
 181 }
 182 
 183 /**
 184  * xmlNsErrMsg:
 185  * @ctxt:  an XML parser context
 186  * @error:  the error number
 187  * @msg:  the error message
 188  * @str1:  an error string
 189  * @str2:  an error string
 190  *
 191  * Handle a namespace error
 192  */
 193 static void LIBXML_ATTR_FORMAT(3,0)
 194 xmlNsErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 195             const char *msg, const xmlChar *str1, const xmlChar *str2)
 196 {
 197     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
 198         (ctxt-&gt;instate == XML_PARSER_EOF))
 199     return;
 200     if (ctxt != NULL)
 201     ctxt-&gt;errNo = error;
 202     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
 203                     XML_ERR_ERROR, NULL, 0,
 204             (const char *) str1, (const char *) str2,
 205             NULL, 0, 0, msg, str1, str2);
 206 }
 207 
 208 /**
 209  * xmlNsWarnMsg:
 210  * @ctxt:  an XML parser context
 211  * @error:  the error number
 212  * @msg:  the error message
 213  * @str1:  an error string
 214  *
 215  * Handle a namespace warning
 216  */
 217 static void LIBXML_ATTR_FORMAT(3,0)
 218 xmlNsWarnMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 219              const char *msg, const xmlChar *str1, const xmlChar *str2)
 220 {
 221     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
 222         (ctxt-&gt;instate == XML_PARSER_EOF))
 223     return;
 224     if (ctxt != NULL)
 225     ctxt-&gt;errNo = error;
 226     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
 227                     XML_ERR_WARNING, NULL, 0,
 228             (const char *) str1, (const char *) str2,
 229             NULL, 0, 0, msg, str1, str2);
 230 }
 231 
 232 /**
 233  * xmlSAX2GetPublicId:
 234  * @ctx: the user data (XML parser context)
 235  *
 236  * Provides the public ID e.g. &quot;-//SGMLSOURCE//DTD DEMO//EN&quot;
 237  *
 238  * Returns a xmlChar *
 239  */
 240 const xmlChar *
 241 xmlSAX2GetPublicId(void *ctx ATTRIBUTE_UNUSED)
 242 {
 243     /* xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx; */
 244     return(NULL);
 245 }
 246 
 247 /**
 248  * xmlSAX2GetSystemId:
 249  * @ctx: the user data (XML parser context)
 250  *
 251  * Provides the system ID, basically URL or filename e.g.
 252  * http://www.sgmlsource.com/dtds/memo.dtd
 253  *
 254  * Returns a xmlChar *
 255  */
 256 const xmlChar *
 257 xmlSAX2GetSystemId(void *ctx)
 258 {
 259     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 260     if ((ctx == NULL) || (ctxt-&gt;input == NULL)) return(NULL);
 261     return((const xmlChar *) ctxt-&gt;input-&gt;filename);
 262 }
 263 
 264 /**
 265  * xmlSAX2GetLineNumber:
 266  * @ctx: the user data (XML parser context)
 267  *
 268  * Provide the line number of the current parsing point.
 269  *
 270  * Returns an int
 271  */
 272 int
 273 xmlSAX2GetLineNumber(void *ctx)
 274 {
 275     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 276     if ((ctx == NULL) || (ctxt-&gt;input == NULL)) return(0);
 277     return(ctxt-&gt;input-&gt;line);
 278 }
 279 
 280 /**
 281  * xmlSAX2GetColumnNumber:
 282  * @ctx: the user data (XML parser context)
 283  *
 284  * Provide the column number of the current parsing point.
 285  *
 286  * Returns an int
 287  */
 288 int
 289 xmlSAX2GetColumnNumber(void *ctx)
 290 {
 291     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 292     if ((ctx == NULL) || (ctxt-&gt;input == NULL)) return(0);
 293     return(ctxt-&gt;input-&gt;col);
 294 }
 295 
 296 /**
 297  * xmlSAX2IsStandalone:
 298  * @ctx: the user data (XML parser context)
 299  *
 300  * Is this document tagged standalone ?
 301  *
 302  * Returns 1 if true
 303  */
 304 int
 305 xmlSAX2IsStandalone(void *ctx)
 306 {
 307     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 308     if ((ctx == NULL) || (ctxt-&gt;myDoc == NULL)) return(0);
 309     return(ctxt-&gt;myDoc-&gt;standalone == 1);
 310 }
 311 
 312 /**
 313  * xmlSAX2HasInternalSubset:
 314  * @ctx: the user data (XML parser context)
 315  *
 316  * Does this document has an internal subset
 317  *
 318  * Returns 1 if true
 319  */
 320 int
 321 xmlSAX2HasInternalSubset(void *ctx)
 322 {
 323     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 324     if ((ctxt == NULL) || (ctxt-&gt;myDoc == NULL)) return(0);
 325     return(ctxt-&gt;myDoc-&gt;intSubset != NULL);
 326 }
 327 
 328 /**
 329  * xmlSAX2HasExternalSubset:
 330  * @ctx: the user data (XML parser context)
 331  *
 332  * Does this document has an external subset
 333  *
 334  * Returns 1 if true
 335  */
 336 int
 337 xmlSAX2HasExternalSubset(void *ctx)
 338 {
 339     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 340     if ((ctxt == NULL) || (ctxt-&gt;myDoc == NULL)) return(0);
 341     return(ctxt-&gt;myDoc-&gt;extSubset != NULL);
 342 }
 343 
 344 /**
 345  * xmlSAX2InternalSubset:
 346  * @ctx:  the user data (XML parser context)
 347  * @name:  the root element name
 348  * @ExternalID:  the external ID
 349  * @SystemID:  the SYSTEM ID (e.g. filename or URL)
 350  *
 351  * Callback on internal subset declaration.
 352  */
 353 void
 354 xmlSAX2InternalSubset(void *ctx, const xmlChar *name,
 355            const xmlChar *ExternalID, const xmlChar *SystemID)
 356 {
 357     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 358     xmlDtdPtr dtd;
 359     if (ctx == NULL) return;
 360 #ifdef DEBUG_SAX
 361     xmlGenericError(xmlGenericErrorContext,
 362         &quot;SAX.xmlSAX2InternalSubset(%s, %s, %s)\n&quot;,
 363             name, ExternalID, SystemID);
 364 #endif
 365 
 366     if (ctxt-&gt;myDoc == NULL)
 367     return;
 368     dtd = xmlGetIntSubset(ctxt-&gt;myDoc);
 369     if (dtd != NULL) {
 370     if (ctxt-&gt;html)
 371         return;
 372     xmlUnlinkNode((xmlNodePtr) dtd);
 373     xmlFreeDtd(dtd);
 374     ctxt-&gt;myDoc-&gt;intSubset = NULL;
 375     }
 376     ctxt-&gt;myDoc-&gt;intSubset =
 377     xmlCreateIntSubset(ctxt-&gt;myDoc, name, ExternalID, SystemID);
 378     if (ctxt-&gt;myDoc-&gt;intSubset == NULL)
 379         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2InternalSubset&quot;);
 380 }
 381 
 382 /**
 383  * xmlSAX2ExternalSubset:
 384  * @ctx: the user data (XML parser context)
 385  * @name:  the root element name
 386  * @ExternalID:  the external ID
 387  * @SystemID:  the SYSTEM ID (e.g. filename or URL)
 388  *
 389  * Callback on external subset declaration.
 390  */
 391 void
 392 xmlSAX2ExternalSubset(void *ctx, const xmlChar *name,
 393            const xmlChar *ExternalID, const xmlChar *SystemID)
 394 {
 395     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 396     if (ctx == NULL) return;
 397 #ifdef DEBUG_SAX
 398     xmlGenericError(xmlGenericErrorContext,
 399         &quot;SAX.xmlSAX2ExternalSubset(%s, %s, %s)\n&quot;,
 400             name, ExternalID, SystemID);
 401 #endif
 402     if (((ExternalID != NULL) || (SystemID != NULL)) &amp;&amp;
 403         (((ctxt-&gt;validate) || (ctxt-&gt;loadsubset != 0)) &amp;&amp;
 404      (ctxt-&gt;wellFormed &amp;&amp; ctxt-&gt;myDoc))) {
 405     /*
 406      * Try to fetch and parse the external subset.
 407      */
 408     xmlParserInputPtr oldinput;
 409     int oldinputNr;
 410     int oldinputMax;
 411     xmlParserInputPtr *oldinputTab;
 412     xmlParserInputPtr input = NULL;
 413     xmlCharEncoding enc;
 414     int oldcharset;
 415     const xmlChar *oldencoding;
 416 
 417     /*
 418      * Ask the Entity resolver to load the damn thing
 419      */
 420     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;resolveEntity != NULL))
 421         input = ctxt-&gt;sax-&gt;resolveEntity(ctxt-&gt;userData, ExternalID,
 422                                             SystemID);
 423     if (input == NULL) {
 424         return;
 425     }
 426 
 427     xmlNewDtd(ctxt-&gt;myDoc, name, ExternalID, SystemID);
 428 
 429     /*
 430      * make sure we won&#39;t destroy the main document context
 431      */
 432     oldinput = ctxt-&gt;input;
 433     oldinputNr = ctxt-&gt;inputNr;
 434     oldinputMax = ctxt-&gt;inputMax;
 435     oldinputTab = ctxt-&gt;inputTab;
 436     oldcharset = ctxt-&gt;charset;
 437     oldencoding = ctxt-&gt;encoding;
 438     ctxt-&gt;encoding = NULL;
 439 
 440     ctxt-&gt;inputTab = (xmlParserInputPtr *)
 441                      xmlMalloc(5 * sizeof(xmlParserInputPtr));
 442     if (ctxt-&gt;inputTab == NULL) {
 443         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2ExternalSubset&quot;);
 444         ctxt-&gt;input = oldinput;
 445         ctxt-&gt;inputNr = oldinputNr;
 446         ctxt-&gt;inputMax = oldinputMax;
 447         ctxt-&gt;inputTab = oldinputTab;
 448         ctxt-&gt;charset = oldcharset;
 449         ctxt-&gt;encoding = oldencoding;
 450         return;
 451     }
 452     ctxt-&gt;inputNr = 0;
 453     ctxt-&gt;inputMax = 5;
 454     ctxt-&gt;input = NULL;
 455     xmlPushInput(ctxt, input);
 456 
 457     /*
 458      * On the fly encoding conversion if needed
 459      */
 460     if (ctxt-&gt;input-&gt;length &gt;= 4) {
 461         enc = xmlDetectCharEncoding(ctxt-&gt;input-&gt;cur, 4);
 462         xmlSwitchEncoding(ctxt, enc);
 463     }
 464 
 465     if (input-&gt;filename == NULL)
 466         input-&gt;filename = (char *) xmlCanonicPath(SystemID);
 467     input-&gt;line = 1;
 468     input-&gt;col = 1;
 469     input-&gt;base = ctxt-&gt;input-&gt;cur;
 470     input-&gt;cur = ctxt-&gt;input-&gt;cur;
 471     input-&gt;free = NULL;
 472 
 473     /*
 474      * let&#39;s parse that entity knowing it&#39;s an external subset.
 475      */
 476     xmlParseExternalSubset(ctxt, ExternalID, SystemID);
 477 
 478         /*
 479      * Free up the external entities
 480      */
 481 
 482     while (ctxt-&gt;inputNr &gt; 1)
 483         xmlPopInput(ctxt);
 484     xmlFreeInputStream(ctxt-&gt;input);
 485         xmlFree(ctxt-&gt;inputTab);
 486 
 487     /*
 488      * Restore the parsing context of the main entity
 489      */
 490     ctxt-&gt;input = oldinput;
 491     ctxt-&gt;inputNr = oldinputNr;
 492     ctxt-&gt;inputMax = oldinputMax;
 493     ctxt-&gt;inputTab = oldinputTab;
 494     ctxt-&gt;charset = oldcharset;
 495     if ((ctxt-&gt;encoding != NULL) &amp;&amp;
 496         ((ctxt-&gt;dict == NULL) ||
 497          (!xmlDictOwns(ctxt-&gt;dict, ctxt-&gt;encoding))))
 498         xmlFree((xmlChar *) ctxt-&gt;encoding);
 499     ctxt-&gt;encoding = oldencoding;
 500     /* ctxt-&gt;wellFormed = oldwellFormed; */
 501     }
 502 }
 503 
 504 /**
 505  * xmlSAX2ResolveEntity:
 506  * @ctx: the user data (XML parser context)
 507  * @publicId: The public ID of the entity
 508  * @systemId: The system ID of the entity
 509  *
 510  * The entity loader, to control the loading of external entities,
 511  * the application can either:
 512  *    - override this xmlSAX2ResolveEntity() callback in the SAX block
 513  *    - or better use the xmlSetExternalEntityLoader() function to
 514  *      set up it&#39;s own entity resolution routine
 515  *
 516  * Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.
 517  */
 518 xmlParserInputPtr
 519 xmlSAX2ResolveEntity(void *ctx, const xmlChar *publicId, const xmlChar *systemId)
 520 {
 521     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 522     xmlParserInputPtr ret;
 523     xmlChar *URI;
 524     const char *base = NULL;
 525 
 526     if (ctx == NULL) return(NULL);
 527     if (ctxt-&gt;input != NULL)
 528     base = ctxt-&gt;input-&gt;filename;
 529     if (base == NULL)
 530     base = ctxt-&gt;directory;
 531 
 532     URI = xmlBuildURI(systemId, (const xmlChar *) base);
 533 
 534 #ifdef DEBUG_SAX
 535     xmlGenericError(xmlGenericErrorContext,
 536         &quot;SAX.xmlSAX2ResolveEntity(%s, %s)\n&quot;, publicId, systemId);
 537 #endif
 538 
 539     ret = xmlLoadExternalEntity((const char *) URI,
 540                 (const char *) publicId, ctxt);
 541     if (URI != NULL)
 542     xmlFree(URI);
 543     return(ret);
 544 }
 545 
 546 /**
 547  * xmlSAX2GetEntity:
 548  * @ctx: the user data (XML parser context)
 549  * @name: The entity name
 550  *
 551  * Get an entity by name
 552  *
 553  * Returns the xmlEntityPtr if found.
 554  */
 555 xmlEntityPtr
 556 xmlSAX2GetEntity(void *ctx, const xmlChar *name)
 557 {
 558     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 559     xmlEntityPtr ret = NULL;
 560 
 561     if (ctx == NULL) return(NULL);
 562 #ifdef DEBUG_SAX
 563     xmlGenericError(xmlGenericErrorContext,
 564         &quot;SAX.xmlSAX2GetEntity(%s)\n&quot;, name);
 565 #endif
 566 
 567     if (ctxt-&gt;inSubset == 0) {
 568     ret = xmlGetPredefinedEntity(name);
 569     if (ret != NULL)
 570         return(ret);
 571     }
 572     if ((ctxt-&gt;myDoc != NULL) &amp;&amp; (ctxt-&gt;myDoc-&gt;standalone == 1)) {
 573     if (ctxt-&gt;inSubset == 2) {
 574         ctxt-&gt;myDoc-&gt;standalone = 0;
 575         ret = xmlGetDocEntity(ctxt-&gt;myDoc, name);
 576         ctxt-&gt;myDoc-&gt;standalone = 1;
 577     } else {
 578         ret = xmlGetDocEntity(ctxt-&gt;myDoc, name);
 579         if (ret == NULL) {
 580         ctxt-&gt;myDoc-&gt;standalone = 0;
 581         ret = xmlGetDocEntity(ctxt-&gt;myDoc, name);
 582         if (ret != NULL) {
 583             xmlFatalErrMsg(ctxt, XML_ERR_NOT_STANDALONE,
 584      &quot;Entity(%s) document marked standalone but requires external subset\n&quot;,
 585                    name, NULL);
 586         }
 587         ctxt-&gt;myDoc-&gt;standalone = 1;
 588         }
 589     }
 590     } else {
 591     ret = xmlGetDocEntity(ctxt-&gt;myDoc, name);
 592     }
 593     if ((ret != NULL) &amp;&amp;
 594     ((ctxt-&gt;validate) || (ctxt-&gt;replaceEntities)) &amp;&amp;
 595     (ret-&gt;children == NULL) &amp;&amp;
 596     (ret-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {
 597     int val;
 598 
 599     /*
 600      * for validation purposes we really need to fetch and
 601      * parse the external entity
 602      */
 603     xmlNodePtr children;
 604     unsigned long oldnbent = ctxt-&gt;nbentities;
 605 
 606         val = xmlParseCtxtExternalEntity(ctxt, ret-&gt;URI,
 607                                  ret-&gt;ExternalID, &amp;children);
 608     if (val == 0) {
 609         xmlAddChildList((xmlNodePtr) ret, children);
 610     } else {
 611         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
 612                    &quot;Failure to process entity %s\n&quot;, name, NULL);
 613         ctxt-&gt;validate = 0;
 614         return(NULL);
 615     }
 616     ret-&gt;owner = 1;
 617     if (ret-&gt;checked == 0) {
 618         ret-&gt;checked = (ctxt-&gt;nbentities - oldnbent + 1) * 2;
 619         if ((ret-&gt;content != NULL) &amp;&amp; (xmlStrchr(ret-&gt;content, &#39;&lt;&#39;)))
 620             ret-&gt;checked |= 1;
 621     }
 622     }
 623     return(ret);
 624 }
 625 
 626 /**
 627  * xmlSAX2GetParameterEntity:
 628  * @ctx: the user data (XML parser context)
 629  * @name: The entity name
 630  *
 631  * Get a parameter entity by name
 632  *
 633  * Returns the xmlEntityPtr if found.
 634  */
 635 xmlEntityPtr
 636 xmlSAX2GetParameterEntity(void *ctx, const xmlChar *name)
 637 {
 638     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 639     xmlEntityPtr ret;
 640 
 641     if (ctx == NULL) return(NULL);
 642 #ifdef DEBUG_SAX
 643     xmlGenericError(xmlGenericErrorContext,
 644         &quot;SAX.xmlSAX2GetParameterEntity(%s)\n&quot;, name);
 645 #endif
 646 
 647     ret = xmlGetParameterEntity(ctxt-&gt;myDoc, name);
 648     return(ret);
 649 }
 650 
 651 
 652 /**
 653  * xmlSAX2EntityDecl:
 654  * @ctx: the user data (XML parser context)
 655  * @name:  the entity name
 656  * @type:  the entity type
 657  * @publicId: The public ID of the entity
 658  * @systemId: The system ID of the entity
 659  * @content: the entity value (without processing).
 660  *
 661  * An entity definition has been parsed
 662  */
 663 void
 664 xmlSAX2EntityDecl(void *ctx, const xmlChar *name, int type,
 665           const xmlChar *publicId, const xmlChar *systemId, xmlChar *content)
 666 {
 667     xmlEntityPtr ent;
 668     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 669 
 670     if (ctx == NULL) return;
 671 #ifdef DEBUG_SAX
 672     xmlGenericError(xmlGenericErrorContext,
 673         &quot;SAX.xmlSAX2EntityDecl(%s, %d, %s, %s, %s)\n&quot;,
 674             name, type, publicId, systemId, content);
 675 #endif
 676     if (ctxt-&gt;inSubset == 1) {
 677     ent = xmlAddDocEntity(ctxt-&gt;myDoc, name, type, publicId,
 678                       systemId, content);
 679     if ((ent == NULL) &amp;&amp; (ctxt-&gt;pedantic))
 680         xmlWarnMsg(ctxt, XML_WAR_ENTITY_REDEFINED,
 681          &quot;Entity(%s) already defined in the internal subset\n&quot;,
 682                    name);
 683     if ((ent != NULL) &amp;&amp; (ent-&gt;URI == NULL) &amp;&amp; (systemId != NULL)) {
 684         xmlChar *URI;
 685         const char *base = NULL;
 686 
 687         if (ctxt-&gt;input != NULL)
 688         base = ctxt-&gt;input-&gt;filename;
 689         if (base == NULL)
 690         base = ctxt-&gt;directory;
 691 
 692         URI = xmlBuildURI(systemId, (const xmlChar *) base);
 693         ent-&gt;URI = URI;
 694     }
 695     } else if (ctxt-&gt;inSubset == 2) {
 696     ent = xmlAddDtdEntity(ctxt-&gt;myDoc, name, type, publicId,
 697                       systemId, content);
 698     if ((ent == NULL) &amp;&amp; (ctxt-&gt;pedantic) &amp;&amp;
 699         (ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;warning != NULL))
 700         ctxt-&gt;sax-&gt;warning(ctxt-&gt;userData,
 701          &quot;Entity(%s) already defined in the external subset\n&quot;, name);
 702     if ((ent != NULL) &amp;&amp; (ent-&gt;URI == NULL) &amp;&amp; (systemId != NULL)) {
 703         xmlChar *URI;
 704         const char *base = NULL;
 705 
 706         if (ctxt-&gt;input != NULL)
 707         base = ctxt-&gt;input-&gt;filename;
 708         if (base == NULL)
 709         base = ctxt-&gt;directory;
 710 
 711         URI = xmlBuildURI(systemId, (const xmlChar *) base);
 712         ent-&gt;URI = URI;
 713     }
 714     } else {
 715     xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
 716                    &quot;SAX.xmlSAX2EntityDecl(%s) called while not in subset\n&quot;,
 717                name, NULL);
 718     }
 719 }
 720 
 721 /**
 722  * xmlSAX2AttributeDecl:
 723  * @ctx: the user data (XML parser context)
 724  * @elem:  the name of the element
 725  * @fullname:  the attribute name
 726  * @type:  the attribute type
 727  * @def:  the type of default value
 728  * @defaultValue: the attribute default value
 729  * @tree:  the tree of enumerated value set
 730  *
 731  * An attribute definition has been parsed
 732  */
 733 void
 734 xmlSAX2AttributeDecl(void *ctx, const xmlChar *elem, const xmlChar *fullname,
 735               int type, int def, const xmlChar *defaultValue,
 736           xmlEnumerationPtr tree)
 737 {
 738     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 739     xmlAttributePtr attr;
 740     xmlChar *name = NULL, *prefix = NULL;
 741 
 742     if ((ctxt == NULL) || (ctxt-&gt;myDoc == NULL))
 743         return;
 744 
 745 #ifdef DEBUG_SAX
 746     xmlGenericError(xmlGenericErrorContext,
 747         &quot;SAX.xmlSAX2AttributeDecl(%s, %s, %d, %d, %s, ...)\n&quot;,
 748             elem, fullname, type, def, defaultValue);
 749 #endif
 750     if ((xmlStrEqual(fullname, BAD_CAST &quot;xml:id&quot;)) &amp;&amp;
 751         (type != XML_ATTRIBUTE_ID)) {
 752     /*
 753      * Raise the error but keep the validity flag
 754      */
 755     int tmp = ctxt-&gt;valid;
 756     xmlErrValid(ctxt, XML_DTD_XMLID_TYPE,
 757           &quot;xml:id : attribute type should be ID\n&quot;, NULL, NULL);
 758     ctxt-&gt;valid = tmp;
 759     }
 760     /* TODO: optimize name/prefix allocation */
 761     name = xmlSplitQName(ctxt, fullname, &amp;prefix);
 762     ctxt-&gt;vctxt.valid = 1;
 763     if (ctxt-&gt;inSubset == 1)
 764     attr = xmlAddAttributeDecl(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc-&gt;intSubset, elem,
 765            name, prefix, (xmlAttributeType) type,
 766            (xmlAttributeDefault) def, defaultValue, tree);
 767     else if (ctxt-&gt;inSubset == 2)
 768     attr = xmlAddAttributeDecl(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc-&gt;extSubset, elem,
 769        name, prefix, (xmlAttributeType) type,
 770        (xmlAttributeDefault) def, defaultValue, tree);
 771     else {
 772         xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
 773          &quot;SAX.xmlSAX2AttributeDecl(%s) called while not in subset\n&quot;,
 774                    name, NULL);
 775     xmlFreeEnumeration(tree);
 776     return;
 777     }
 778 #ifdef LIBXML_VALID_ENABLED
 779     if (ctxt-&gt;vctxt.valid == 0)
 780     ctxt-&gt;valid = 0;
 781     if ((attr != NULL) &amp;&amp; (ctxt-&gt;validate) &amp;&amp; (ctxt-&gt;wellFormed) &amp;&amp;
 782         (ctxt-&gt;myDoc-&gt;intSubset != NULL))
 783     ctxt-&gt;valid &amp;= xmlValidateAttributeDecl(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc,
 784                                             attr);
 785 #endif /* LIBXML_VALID_ENABLED */
 786     if (prefix != NULL)
 787     xmlFree(prefix);
 788     if (name != NULL)
 789     xmlFree(name);
 790 }
 791 
 792 /**
 793  * xmlSAX2ElementDecl:
 794  * @ctx: the user data (XML parser context)
 795  * @name:  the element name
 796  * @type:  the element type
 797  * @content: the element value tree
 798  *
 799  * An element definition has been parsed
 800  */
 801 void
 802 xmlSAX2ElementDecl(void *ctx, const xmlChar * name, int type,
 803             xmlElementContentPtr content)
 804 {
 805     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 806     xmlElementPtr elem = NULL;
 807 
 808     if ((ctxt == NULL) || (ctxt-&gt;myDoc == NULL))
 809         return;
 810 
 811 #ifdef DEBUG_SAX
 812     xmlGenericError(xmlGenericErrorContext,
 813                     &quot;SAX.xmlSAX2ElementDecl(%s, %d, ...)\n&quot;, name, type);
 814 #endif
 815 
 816     if (ctxt-&gt;inSubset == 1)
 817         elem = xmlAddElementDecl(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc-&gt;intSubset,
 818                                  name, (xmlElementTypeVal) type, content);
 819     else if (ctxt-&gt;inSubset == 2)
 820         elem = xmlAddElementDecl(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc-&gt;extSubset,
 821                                  name, (xmlElementTypeVal) type, content);
 822     else {
 823         xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
 824          &quot;SAX.xmlSAX2ElementDecl(%s) called while not in subset\n&quot;,
 825                    name, NULL);
 826         return;
 827     }
 828 #ifdef LIBXML_VALID_ENABLED
 829     if (elem == NULL)
 830         ctxt-&gt;valid = 0;
 831     if (ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp;
 832         ctxt-&gt;myDoc &amp;&amp; ctxt-&gt;myDoc-&gt;intSubset)
 833         ctxt-&gt;valid &amp;=
 834             xmlValidateElementDecl(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc, elem);
 835 #endif /* LIBXML_VALID_ENABLED */
 836 }
 837 
 838 /**
 839  * xmlSAX2NotationDecl:
 840  * @ctx: the user data (XML parser context)
 841  * @name: The name of the notation
 842  * @publicId: The public ID of the entity
 843  * @systemId: The system ID of the entity
 844  *
 845  * What to do when a notation declaration has been parsed.
 846  */
 847 void
 848 xmlSAX2NotationDecl(void *ctx, const xmlChar *name,
 849          const xmlChar *publicId, const xmlChar *systemId)
 850 {
 851     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 852     xmlNotationPtr nota = NULL;
 853 
 854     if ((ctxt == NULL) || (ctxt-&gt;myDoc == NULL))
 855         return;
 856 
 857 #ifdef DEBUG_SAX
 858     xmlGenericError(xmlGenericErrorContext,
 859         &quot;SAX.xmlSAX2NotationDecl(%s, %s, %s)\n&quot;, name, publicId, systemId);
 860 #endif
 861 
 862     if ((publicId == NULL) &amp;&amp; (systemId == NULL)) {
 863     xmlFatalErrMsg(ctxt, XML_ERR_NOTATION_PROCESSING,
 864          &quot;SAX.xmlSAX2NotationDecl(%s) externalID or PublicID missing\n&quot;,
 865                    name, NULL);
 866     return;
 867     } else if (ctxt-&gt;inSubset == 1)
 868     nota = xmlAddNotationDecl(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc-&gt;intSubset, name,
 869                               publicId, systemId);
 870     else if (ctxt-&gt;inSubset == 2)
 871     nota = xmlAddNotationDecl(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc-&gt;extSubset, name,
 872                               publicId, systemId);
 873     else {
 874     xmlFatalErrMsg(ctxt, XML_ERR_NOTATION_PROCESSING,
 875          &quot;SAX.xmlSAX2NotationDecl(%s) called while not in subset\n&quot;,
 876                    name, NULL);
 877     return;
 878     }
 879 #ifdef LIBXML_VALID_ENABLED
 880     if (nota == NULL) ctxt-&gt;valid = 0;
 881     if ((ctxt-&gt;validate) &amp;&amp; (ctxt-&gt;wellFormed) &amp;&amp;
 882         (ctxt-&gt;myDoc-&gt;intSubset != NULL))
 883     ctxt-&gt;valid &amp;= xmlValidateNotationDecl(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc,
 884                                            nota);
 885 #endif /* LIBXML_VALID_ENABLED */
 886 }
 887 
 888 /**
 889  * xmlSAX2UnparsedEntityDecl:
 890  * @ctx: the user data (XML parser context)
 891  * @name: The name of the entity
 892  * @publicId: The public ID of the entity
 893  * @systemId: The system ID of the entity
 894  * @notationName: the name of the notation
 895  *
 896  * What to do when an unparsed entity declaration is parsed
 897  */
 898 void
 899 xmlSAX2UnparsedEntityDecl(void *ctx, const xmlChar *name,
 900            const xmlChar *publicId, const xmlChar *systemId,
 901            const xmlChar *notationName)
 902 {
 903     xmlEntityPtr ent;
 904     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 905     if (ctx == NULL) return;
 906 #ifdef DEBUG_SAX
 907     xmlGenericError(xmlGenericErrorContext,
 908         &quot;SAX.xmlSAX2UnparsedEntityDecl(%s, %s, %s, %s)\n&quot;,
 909             name, publicId, systemId, notationName);
 910 #endif
 911     if (ctxt-&gt;inSubset == 1) {
 912     ent = xmlAddDocEntity(ctxt-&gt;myDoc, name,
 913             XML_EXTERNAL_GENERAL_UNPARSED_ENTITY,
 914             publicId, systemId, notationName);
 915     if ((ent == NULL) &amp;&amp; (ctxt-&gt;pedantic) &amp;&amp;
 916         (ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;warning != NULL))
 917         ctxt-&gt;sax-&gt;warning(ctxt-&gt;userData,
 918          &quot;Entity(%s) already defined in the internal subset\n&quot;, name);
 919     if ((ent != NULL) &amp;&amp; (ent-&gt;URI == NULL) &amp;&amp; (systemId != NULL)) {
 920         xmlChar *URI;
 921         const char *base = NULL;
 922 
 923         if (ctxt-&gt;input != NULL)
 924         base = ctxt-&gt;input-&gt;filename;
 925         if (base == NULL)
 926         base = ctxt-&gt;directory;
 927 
 928         URI = xmlBuildURI(systemId, (const xmlChar *) base);
 929         ent-&gt;URI = URI;
 930     }
 931     } else if (ctxt-&gt;inSubset == 2) {
 932     ent = xmlAddDtdEntity(ctxt-&gt;myDoc, name,
 933             XML_EXTERNAL_GENERAL_UNPARSED_ENTITY,
 934             publicId, systemId, notationName);
 935     if ((ent == NULL) &amp;&amp; (ctxt-&gt;pedantic) &amp;&amp;
 936         (ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;warning != NULL))
 937         ctxt-&gt;sax-&gt;warning(ctxt-&gt;userData,
 938          &quot;Entity(%s) already defined in the external subset\n&quot;, name);
 939     if ((ent != NULL) &amp;&amp; (ent-&gt;URI == NULL) &amp;&amp; (systemId != NULL)) {
 940         xmlChar *URI;
 941         const char *base = NULL;
 942 
 943         if (ctxt-&gt;input != NULL)
 944         base = ctxt-&gt;input-&gt;filename;
 945         if (base == NULL)
 946         base = ctxt-&gt;directory;
 947 
 948         URI = xmlBuildURI(systemId, (const xmlChar *) base);
 949         ent-&gt;URI = URI;
 950     }
 951     } else {
 952         xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
 953          &quot;SAX.xmlSAX2UnparsedEntityDecl(%s) called while not in subset\n&quot;,
 954                    name, NULL);
 955     }
 956 }
 957 
 958 /**
 959  * xmlSAX2SetDocumentLocator:
 960  * @ctx: the user data (XML parser context)
 961  * @loc: A SAX Locator
 962  *
 963  * Receive the document locator at startup, actually xmlDefaultSAXLocator
 964  * Everything is available on the context, so this is useless in our case.
 965  */
 966 void
 967 xmlSAX2SetDocumentLocator(void *ctx ATTRIBUTE_UNUSED, xmlSAXLocatorPtr loc ATTRIBUTE_UNUSED)
 968 {
 969     /* xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx; */
 970 #ifdef DEBUG_SAX
 971     xmlGenericError(xmlGenericErrorContext,
 972         &quot;SAX.xmlSAX2SetDocumentLocator()\n&quot;);
 973 #endif
 974 }
 975 
 976 /**
 977  * xmlSAX2StartDocument:
 978  * @ctx: the user data (XML parser context)
 979  *
 980  * called when the document start being processed.
 981  */
 982 void
 983 xmlSAX2StartDocument(void *ctx)
 984 {
 985     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 986     xmlDocPtr doc;
 987 
 988     if (ctx == NULL) return;
 989 
 990 #ifdef DEBUG_SAX
 991     xmlGenericError(xmlGenericErrorContext,
 992         &quot;SAX.xmlSAX2StartDocument()\n&quot;);
 993 #endif
 994     if (ctxt-&gt;html) {
 995 #ifdef LIBXML_HTML_ENABLED
 996     if (ctxt-&gt;myDoc == NULL)
 997         ctxt-&gt;myDoc = htmlNewDocNoDtD(NULL, NULL);
 998     if (ctxt-&gt;myDoc == NULL) {
 999         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartDocument&quot;);
1000         return;
1001     }
1002     ctxt-&gt;myDoc-&gt;properties = XML_DOC_HTML;
1003     ctxt-&gt;myDoc-&gt;parseFlags = ctxt-&gt;options;
1004 #else
1005         xmlGenericError(xmlGenericErrorContext,
1006         &quot;libxml2 built without HTML support\n&quot;);
1007     ctxt-&gt;errNo = XML_ERR_INTERNAL_ERROR;
1008     ctxt-&gt;instate = XML_PARSER_EOF;
1009     ctxt-&gt;disableSAX = 1;
1010     return;
1011 #endif
1012     } else {
1013     doc = ctxt-&gt;myDoc = xmlNewDoc(ctxt-&gt;version);
1014     if (doc != NULL) {
1015         doc-&gt;properties = 0;
1016         if (ctxt-&gt;options &amp; XML_PARSE_OLD10)
1017             doc-&gt;properties |= XML_DOC_OLD10;
1018         doc-&gt;parseFlags = ctxt-&gt;options;
1019         if (ctxt-&gt;encoding != NULL)
1020         doc-&gt;encoding = xmlStrdup(ctxt-&gt;encoding);
1021         else
1022         doc-&gt;encoding = NULL;
1023         doc-&gt;standalone = ctxt-&gt;standalone;
1024     } else {
1025         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartDocument&quot;);
1026         return;
1027     }
1028     if ((ctxt-&gt;dictNames) &amp;&amp; (doc != NULL)) {
1029         doc-&gt;dict = ctxt-&gt;dict;
1030         xmlDictReference(doc-&gt;dict);
1031     }
1032     }
1033     if ((ctxt-&gt;myDoc != NULL) &amp;&amp; (ctxt-&gt;myDoc-&gt;URL == NULL) &amp;&amp;
1034     (ctxt-&gt;input != NULL) &amp;&amp; (ctxt-&gt;input-&gt;filename != NULL)) {
1035     ctxt-&gt;myDoc-&gt;URL = xmlPathToURI((const xmlChar *)ctxt-&gt;input-&gt;filename);
1036     if (ctxt-&gt;myDoc-&gt;URL == NULL)
1037         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartDocument&quot;);
1038     }
1039 }
1040 
1041 /**
1042  * xmlSAX2EndDocument:
1043  * @ctx: the user data (XML parser context)
1044  *
1045  * called when the document end has been detected.
1046  */
1047 void
1048 xmlSAX2EndDocument(void *ctx)
1049 {
1050     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
1051 #ifdef DEBUG_SAX
1052     xmlGenericError(xmlGenericErrorContext,
1053         &quot;SAX.xmlSAX2EndDocument()\n&quot;);
1054 #endif
1055     if (ctx == NULL) return;
1056 #ifdef LIBXML_VALID_ENABLED
1057     if (ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp;
1058         ctxt-&gt;myDoc &amp;&amp; ctxt-&gt;myDoc-&gt;intSubset)
1059     ctxt-&gt;valid &amp;= xmlValidateDocumentFinal(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc);
1060 #endif /* LIBXML_VALID_ENABLED */
1061 
1062     /*
1063      * Grab the encoding if it was added on-the-fly
1064      */
1065     if ((ctxt-&gt;encoding != NULL) &amp;&amp; (ctxt-&gt;myDoc != NULL) &amp;&amp;
1066     (ctxt-&gt;myDoc-&gt;encoding == NULL)) {
1067     ctxt-&gt;myDoc-&gt;encoding = ctxt-&gt;encoding;
1068     ctxt-&gt;encoding = NULL;
1069     }
1070     if ((ctxt-&gt;inputTab != NULL) &amp;&amp;
1071         (ctxt-&gt;inputNr &gt; 0) &amp;&amp; (ctxt-&gt;inputTab[0] != NULL) &amp;&amp;
1072         (ctxt-&gt;inputTab[0]-&gt;encoding != NULL) &amp;&amp; (ctxt-&gt;myDoc != NULL) &amp;&amp;
1073     (ctxt-&gt;myDoc-&gt;encoding == NULL)) {
1074     ctxt-&gt;myDoc-&gt;encoding = xmlStrdup(ctxt-&gt;inputTab[0]-&gt;encoding);
1075     }
1076     if ((ctxt-&gt;charset != XML_CHAR_ENCODING_NONE) &amp;&amp; (ctxt-&gt;myDoc != NULL) &amp;&amp;
1077     (ctxt-&gt;myDoc-&gt;charset == XML_CHAR_ENCODING_NONE)) {
1078     ctxt-&gt;myDoc-&gt;charset = ctxt-&gt;charset;
1079     }
1080 }
1081 
1082 #if defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_DOCB_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
1083 /**
1084  * xmlSAX2AttributeInternal:
1085  * @ctx: the user data (XML parser context)
1086  * @fullname:  The attribute name, including namespace prefix
1087  * @value:  The attribute value
1088  * @prefix: the prefix on the element node
1089  *
1090  * Handle an attribute that has been read by the parser.
1091  * The default handling is to convert the attribute into an
1092  * DOM subtree and past it in a new xmlAttr element added to
1093  * the element.
1094  */
1095 static void
1096 xmlSAX2AttributeInternal(void *ctx, const xmlChar *fullname,
1097              const xmlChar *value, const xmlChar *prefix ATTRIBUTE_UNUSED)
1098 {
1099     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
1100     xmlAttrPtr ret;
1101     xmlChar *name;
1102     xmlChar *ns;
1103     xmlChar *nval;
1104     xmlNsPtr namespace;
1105 
1106     if (ctxt-&gt;html) {
1107     name = xmlStrdup(fullname);
1108     ns = NULL;
1109     namespace = NULL;
1110     } else {
1111     /*
1112      * Split the full name into a namespace prefix and the tag name
1113      */
1114     name = xmlSplitQName(ctxt, fullname, &amp;ns);
1115     if ((name != NULL) &amp;&amp; (name[0] == 0)) {
1116         if (xmlStrEqual(ns, BAD_CAST &quot;xmlns&quot;)) {
1117         xmlNsErrMsg(ctxt, XML_ERR_NS_DECL_ERROR,
1118                 &quot;invalid namespace declaration &#39;%s&#39;\n&quot;,
1119                 fullname, NULL);
1120         } else {
1121         xmlNsWarnMsg(ctxt, XML_WAR_NS_COLUMN,
1122                  &quot;Avoid attribute ending with &#39;:&#39; like &#39;%s&#39;\n&quot;,
1123                  fullname, NULL);
1124         }
1125         if (ns != NULL)
1126         xmlFree(ns);
1127         ns = NULL;
1128         xmlFree(name);
1129         name = xmlStrdup(fullname);
1130     }
1131     }
1132     if (name == NULL) {
1133         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartElement&quot;);
1134     if (ns != NULL)
1135         xmlFree(ns);
1136     return;
1137     }
1138 
1139 #ifdef LIBXML_HTML_ENABLED
1140     if ((ctxt-&gt;html) &amp;&amp;
1141         (value == NULL) &amp;&amp; (htmlIsBooleanAttr(fullname))) {
1142             nval = xmlStrdup(fullname);
1143             value = (const xmlChar *) nval;
1144     } else
1145 #endif
1146     {
1147 #ifdef LIBXML_VALID_ENABLED
1148         /*
1149          * Do the last stage of the attribute normalization
1150          * Needed for HTML too:
1151          *   http://www.w3.org/TR/html4/types.html#h-6.2
1152          */
1153         ctxt-&gt;vctxt.valid = 1;
1154         nval = xmlValidCtxtNormalizeAttributeValue(&amp;ctxt-&gt;vctxt,
1155                                                ctxt-&gt;myDoc, ctxt-&gt;node,
1156                                                fullname, value);
1157         if (ctxt-&gt;vctxt.valid != 1) {
1158             ctxt-&gt;valid = 0;
1159         }
1160         if (nval != NULL)
1161             value = nval;
1162 #else
1163         nval = NULL;
1164 #endif /* LIBXML_VALID_ENABLED */
1165     }
1166 
1167     /*
1168      * Check whether it&#39;s a namespace definition
1169      */
1170     if ((!ctxt-&gt;html) &amp;&amp; (ns == NULL) &amp;&amp;
1171         (name[0] == &#39;x&#39;) &amp;&amp; (name[1] == &#39;m&#39;) &amp;&amp; (name[2] == &#39;l&#39;) &amp;&amp;
1172         (name[3] == &#39;n&#39;) &amp;&amp; (name[4] == &#39;s&#39;) &amp;&amp; (name[5] == 0)) {
1173     xmlNsPtr nsret;
1174     xmlChar *val;
1175 
1176         if (!ctxt-&gt;replaceEntities) {
1177         ctxt-&gt;depth++;
1178         val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF,
1179                                   0,0,0);
1180         ctxt-&gt;depth--;
1181         if (val == NULL) {
1182             xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartElement&quot;);
1183         if (name != NULL)
1184             xmlFree(name);
1185                 if (nval != NULL)
1186                     xmlFree(nval);
1187         return;
1188         }
1189     } else {
1190         val = (xmlChar *) value;
1191     }
1192 
1193     if (val[0] != 0) {
1194         xmlURIPtr uri;
1195 
1196         uri = xmlParseURI((const char *)val);
1197         if (uri == NULL) {
1198         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;warning != NULL))
1199             ctxt-&gt;sax-&gt;warning(ctxt-&gt;userData,
1200              &quot;xmlns: %s not a valid URI\n&quot;, val);
1201         } else {
1202         if (uri-&gt;scheme == NULL) {
1203             if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;warning != NULL))
1204             ctxt-&gt;sax-&gt;warning(ctxt-&gt;userData,
1205                  &quot;xmlns: URI %s is not absolute\n&quot;, val);
1206         }
1207         xmlFreeURI(uri);
1208         }
1209     }
1210 
1211     /* a default namespace definition */
1212     nsret = xmlNewNs(ctxt-&gt;node, val, NULL);
1213 
1214 #ifdef LIBXML_VALID_ENABLED
1215     /*
1216      * Validate also for namespace decls, they are attributes from
1217      * an XML-1.0 perspective
1218      */
1219         if (nsret != NULL &amp;&amp; ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp;
1220         ctxt-&gt;myDoc &amp;&amp; ctxt-&gt;myDoc-&gt;intSubset)
1221         ctxt-&gt;valid &amp;= xmlValidateOneNamespace(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc,
1222                        ctxt-&gt;node, prefix, nsret, val);
1223 #endif /* LIBXML_VALID_ENABLED */
1224     if (name != NULL)
1225         xmlFree(name);
1226     if (nval != NULL)
1227         xmlFree(nval);
1228     if (val != value)
1229         xmlFree(val);
1230     return;
1231     }
1232     if ((!ctxt-&gt;html) &amp;&amp;
1233     (ns != NULL) &amp;&amp; (ns[0] == &#39;x&#39;) &amp;&amp; (ns[1] == &#39;m&#39;) &amp;&amp; (ns[2] == &#39;l&#39;) &amp;&amp;
1234         (ns[3] == &#39;n&#39;) &amp;&amp; (ns[4] == &#39;s&#39;) &amp;&amp; (ns[5] == 0)) {
1235     xmlNsPtr nsret;
1236     xmlChar *val;
1237 
1238         if (!ctxt-&gt;replaceEntities) {
1239         ctxt-&gt;depth++;
1240         val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF,
1241                                   0,0,0);
1242         ctxt-&gt;depth--;
1243         if (val == NULL) {
1244             xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartElement&quot;);
1245             xmlFree(ns);
1246         if (name != NULL)
1247             xmlFree(name);
1248                 if (nval != NULL)
1249                     xmlFree(nval);
1250         return;
1251         }
1252     } else {
1253         val = (xmlChar *) value;
1254     }
1255 
1256     if (val[0] == 0) {
1257         xmlNsErrMsg(ctxt, XML_NS_ERR_EMPTY,
1258                 &quot;Empty namespace name for prefix %s\n&quot;, name, NULL);
1259     }
1260     if ((ctxt-&gt;pedantic != 0) &amp;&amp; (val[0] != 0)) {
1261         xmlURIPtr uri;
1262 
1263         uri = xmlParseURI((const char *)val);
1264         if (uri == NULL) {
1265             xmlNsWarnMsg(ctxt, XML_WAR_NS_URI,
1266              &quot;xmlns:%s: %s not a valid URI\n&quot;, name, value);
1267         } else {
1268         if (uri-&gt;scheme == NULL) {
1269             xmlNsWarnMsg(ctxt, XML_WAR_NS_URI_RELATIVE,
1270                &quot;xmlns:%s: URI %s is not absolute\n&quot;, name, value);
1271         }
1272         xmlFreeURI(uri);
1273         }
1274     }
1275 
1276     /* a standard namespace definition */
1277     nsret = xmlNewNs(ctxt-&gt;node, val, name);
1278     xmlFree(ns);
1279 #ifdef LIBXML_VALID_ENABLED
1280     /*
1281      * Validate also for namespace decls, they are attributes from
1282      * an XML-1.0 perspective
1283      */
1284         if (nsret != NULL &amp;&amp; ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp;
1285         ctxt-&gt;myDoc &amp;&amp; ctxt-&gt;myDoc-&gt;intSubset)
1286         ctxt-&gt;valid &amp;= xmlValidateOneNamespace(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc,
1287                        ctxt-&gt;node, prefix, nsret, value);
1288 #endif /* LIBXML_VALID_ENABLED */
1289     if (name != NULL)
1290         xmlFree(name);
1291     if (nval != NULL)
1292         xmlFree(nval);
1293     if (val != value)
1294         xmlFree(val);
1295     return;
1296     }
1297 
1298     if (ns != NULL) {
1299     namespace = xmlSearchNs(ctxt-&gt;myDoc, ctxt-&gt;node, ns);
1300 
1301     if (namespace == NULL) {
1302         xmlNsErrMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
1303             &quot;Namespace prefix %s of attribute %s is not defined\n&quot;,
1304                      ns, name);
1305     } else {
1306             xmlAttrPtr prop;
1307 
1308             prop = ctxt-&gt;node-&gt;properties;
1309             while (prop != NULL) {
1310                 if (prop-&gt;ns != NULL) {
1311                     if ((xmlStrEqual(name, prop-&gt;name)) &amp;&amp;
1312                         ((namespace == prop-&gt;ns) ||
1313                          (xmlStrEqual(namespace-&gt;href, prop-&gt;ns-&gt;href)))) {
1314                             xmlNsErrMsg(ctxt, XML_ERR_ATTRIBUTE_REDEFINED,
1315                                     &quot;Attribute %s in %s redefined\n&quot;,
1316                                              name, namespace-&gt;href);
1317                         ctxt-&gt;wellFormed = 0;
1318                         if (ctxt-&gt;recovery == 0) ctxt-&gt;disableSAX = 1;
1319                         if (name != NULL)
1320                             xmlFree(name);
1321                         goto error;
1322                     }
1323                 }
1324                 prop = prop-&gt;next;
1325             }
1326         }
1327     } else {
1328     namespace = NULL;
1329     }
1330 
1331     /* !!!!!! &lt;a toto:arg=&quot;&quot; xmlns:toto=&quot;http://toto.com&quot;&gt; */
1332     ret = xmlNewNsPropEatName(ctxt-&gt;node, namespace, name, NULL);
1333 
1334     if (ret != NULL) {
1335         if ((ctxt-&gt;replaceEntities == 0) &amp;&amp; (!ctxt-&gt;html)) {
1336         xmlNodePtr tmp;
1337 
1338         ret-&gt;children = xmlStringGetNodeList(ctxt-&gt;myDoc, value);
1339         tmp = ret-&gt;children;
1340         while (tmp != NULL) {
1341         tmp-&gt;parent = (xmlNodePtr) ret;
1342         if (tmp-&gt;next == NULL)
1343             ret-&gt;last = tmp;
1344         tmp = tmp-&gt;next;
1345         }
1346     } else if (value != NULL) {
1347         ret-&gt;children = xmlNewDocText(ctxt-&gt;myDoc, value);
1348         ret-&gt;last = ret-&gt;children;
1349         if (ret-&gt;children != NULL)
1350         ret-&gt;children-&gt;parent = (xmlNodePtr) ret;
1351     }
1352     }
1353 
1354 #ifdef LIBXML_VALID_ENABLED
1355     if ((!ctxt-&gt;html) &amp;&amp; ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp;
1356         ctxt-&gt;myDoc &amp;&amp; ctxt-&gt;myDoc-&gt;intSubset) {
1357 
1358     /*
1359      * If we don&#39;t substitute entities, the validation should be
1360      * done on a value with replaced entities anyway.
1361      */
1362         if (!ctxt-&gt;replaceEntities) {
1363         xmlChar *val;
1364 
1365         ctxt-&gt;depth++;
1366         val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF,
1367                                   0,0,0);
1368         ctxt-&gt;depth--;
1369 
1370         if (val == NULL)
1371         ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
1372                 ctxt-&gt;myDoc, ctxt-&gt;node, ret, value);
1373         else {
1374         xmlChar *nvalnorm;
1375 
1376         /*
1377          * Do the last stage of the attribute normalization
1378          * It need to be done twice ... it&#39;s an extra burden related
1379          * to the ability to keep xmlSAX2References in attributes
1380          */
1381         nvalnorm = xmlValidNormalizeAttributeValue(ctxt-&gt;myDoc,
1382                         ctxt-&gt;node, fullname, val);
1383         if (nvalnorm != NULL) {
1384             xmlFree(val);
1385             val = nvalnorm;
1386         }
1387 
1388         ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
1389                     ctxt-&gt;myDoc, ctxt-&gt;node, ret, val);
1390                 xmlFree(val);
1391         }
1392     } else {
1393         ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc,
1394                            ctxt-&gt;node, ret, value);
1395     }
1396     } else
1397 #endif /* LIBXML_VALID_ENABLED */
1398            if (((ctxt-&gt;loadsubset &amp; XML_SKIP_IDS) == 0) &amp;&amp;
1399            (((ctxt-&gt;replaceEntities == 0) &amp;&amp; (ctxt-&gt;external != 2)) ||
1400             ((ctxt-&gt;replaceEntities != 0) &amp;&amp; (ctxt-&gt;inSubset == 0)))) {
1401         /*
1402      * when validating, the ID registration is done at the attribute
1403      * validation level. Otherwise we have to do specific handling here.
1404      */
1405     if (xmlStrEqual(fullname, BAD_CAST &quot;xml:id&quot;)) {
1406         /*
1407          * Add the xml:id value
1408          *
1409          * Open issue: normalization of the value.
1410          */
1411         if (xmlValidateNCName(value, 1) != 0) {
1412             xmlErrValid(ctxt, XML_DTD_XMLID_VALUE,
1413               &quot;xml:id : attribute value %s is not an NCName\n&quot;,
1414                 (const char *) value, NULL);
1415         }
1416         xmlAddID(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc, value, ret);
1417     } else if (xmlIsID(ctxt-&gt;myDoc, ctxt-&gt;node, ret))
1418         xmlAddID(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc, value, ret);
1419     else if (xmlIsRef(ctxt-&gt;myDoc, ctxt-&gt;node, ret))
1420         xmlAddRef(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc, value, ret);
1421     }
1422 
1423 error:
1424     if (nval != NULL)
1425     xmlFree(nval);
1426     if (ns != NULL)
1427     xmlFree(ns);
1428 }
1429 
1430 /*
1431  * xmlCheckDefaultedAttributes:
1432  *
1433  * Check defaulted attributes from the DTD
1434  */
1435 static void
1436 xmlCheckDefaultedAttributes(xmlParserCtxtPtr ctxt, const xmlChar *name,
1437     const xmlChar *prefix, const xmlChar **atts) {
1438     xmlElementPtr elemDecl;
1439     const xmlChar *att;
1440     int internal = 1;
1441     int i;
1442 
1443     elemDecl = xmlGetDtdQElementDesc(ctxt-&gt;myDoc-&gt;intSubset, name, prefix);
1444     if (elemDecl == NULL) {
1445     elemDecl = xmlGetDtdQElementDesc(ctxt-&gt;myDoc-&gt;extSubset, name, prefix);
1446     internal = 0;
1447     }
1448 
1449 process_external_subset:
1450 
1451     if (elemDecl != NULL) {
1452     xmlAttributePtr attr = elemDecl-&gt;attributes;
1453     /*
1454      * Check against defaulted attributes from the external subset
1455      * if the document is stamped as standalone
1456      */
1457     if ((ctxt-&gt;myDoc-&gt;standalone == 1) &amp;&amp;
1458         (ctxt-&gt;myDoc-&gt;extSubset != NULL) &amp;&amp;
1459         (ctxt-&gt;validate)) {
1460         while (attr != NULL) {
1461         if ((attr-&gt;defaultValue != NULL) &amp;&amp;
1462             (xmlGetDtdQAttrDesc(ctxt-&gt;myDoc-&gt;extSubset,
1463                     attr-&gt;elem, attr-&gt;name,
1464                     attr-&gt;prefix) == attr) &amp;&amp;
1465             (xmlGetDtdQAttrDesc(ctxt-&gt;myDoc-&gt;intSubset,
1466                     attr-&gt;elem, attr-&gt;name,
1467                     attr-&gt;prefix) == NULL)) {
1468             xmlChar *fulln;
1469 
1470             if (attr-&gt;prefix != NULL) {
1471             fulln = xmlStrdup(attr-&gt;prefix);
1472             fulln = xmlStrcat(fulln, BAD_CAST &quot;:&quot;);
1473             fulln = xmlStrcat(fulln, attr-&gt;name);
1474             } else {
1475             fulln = xmlStrdup(attr-&gt;name);
1476             }
1477                     if (fulln == NULL) {
1478                         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartElement&quot;);
1479                         break;
1480                     }
1481 
1482             /*
1483              * Check that the attribute is not declared in the
1484              * serialization
1485              */
1486             att = NULL;
1487             if (atts != NULL) {
1488             i = 0;
1489             att = atts[i];
1490             while (att != NULL) {
1491                 if (xmlStrEqual(att, fulln))
1492                 break;
1493                 i += 2;
1494                 att = atts[i];
1495             }
1496             }
1497             if (att == NULL) {
1498                 xmlErrValid(ctxt, XML_DTD_STANDALONE_DEFAULTED,
1499       &quot;standalone: attribute %s on %s defaulted from external subset\n&quot;,
1500                     (const char *)fulln,
1501                     (const char *)attr-&gt;elem);
1502             }
1503                     xmlFree(fulln);
1504         }
1505         attr = attr-&gt;nexth;
1506         }
1507     }
1508 
1509     /*
1510      * Actually insert defaulted values when needed
1511      */
1512     attr = elemDecl-&gt;attributes;
1513     while (attr != NULL) {
1514         /*
<a name="2" id="anc2"></a><span class="line-modified">1515          * Make sure that attributes redefinition occurring in the</span>
<span class="line-modified">1516          * internal subset are not overridden by definitions in the</span>
1517          * external subset.
1518          */
1519         if (attr-&gt;defaultValue != NULL) {
1520         /*
1521          * the element should be instantiated in the tree if:
1522          *  - this is a namespace prefix
1523          *  - the user required for completion in the tree
1524          *    like XSLT
1525          *  - there isn&#39;t already an attribute definition
1526          *    in the internal subset overriding it.
1527          */
1528         if (((attr-&gt;prefix != NULL) &amp;&amp;
1529              (xmlStrEqual(attr-&gt;prefix, BAD_CAST &quot;xmlns&quot;))) ||
1530             ((attr-&gt;prefix == NULL) &amp;&amp;
1531              (xmlStrEqual(attr-&gt;name, BAD_CAST &quot;xmlns&quot;))) ||
1532             (ctxt-&gt;loadsubset &amp; XML_COMPLETE_ATTRS)) {
1533             xmlAttributePtr tst;
1534 
1535             tst = xmlGetDtdQAttrDesc(ctxt-&gt;myDoc-&gt;intSubset,
1536                          attr-&gt;elem, attr-&gt;name,
1537                          attr-&gt;prefix);
1538             if ((tst == attr) || (tst == NULL)) {
1539                 xmlChar fn[50];
1540             xmlChar *fulln;
1541 
1542                         fulln = xmlBuildQName(attr-&gt;name, attr-&gt;prefix, fn, 50);
1543             if (fulln == NULL) {
1544                 xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartElement&quot;);
1545                 return;
1546             }
1547 
1548             /*
1549              * Check that the attribute is not declared in the
1550              * serialization
1551              */
1552             att = NULL;
1553             if (atts != NULL) {
1554                 i = 0;
1555                 att = atts[i];
1556                 while (att != NULL) {
1557                 if (xmlStrEqual(att, fulln))
1558                     break;
1559                 i += 2;
1560                 att = atts[i];
1561                 }
1562             }
1563             if (att == NULL) {
1564                 xmlSAX2AttributeInternal(ctxt, fulln,
1565                          attr-&gt;defaultValue, prefix);
1566             }
1567             if ((fulln != fn) &amp;&amp; (fulln != attr-&gt;name))
1568                 xmlFree(fulln);
1569             }
1570         }
1571         }
1572         attr = attr-&gt;nexth;
1573     }
1574     if (internal == 1) {
1575         elemDecl = xmlGetDtdQElementDesc(ctxt-&gt;myDoc-&gt;extSubset,
1576                                      name, prefix);
1577         internal = 0;
1578         goto process_external_subset;
1579     }
1580     }
1581 }
1582 
1583 /**
1584  * xmlSAX2StartElement:
1585  * @ctx: the user data (XML parser context)
1586  * @fullname:  The element name, including namespace prefix
1587  * @atts:  An array of name/value attributes pairs, NULL terminated
1588  *
1589  * called when an opening tag has been processed.
1590  */
1591 void
1592 xmlSAX2StartElement(void *ctx, const xmlChar *fullname, const xmlChar **atts)
1593 {
1594     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
1595     xmlNodePtr ret;
1596     xmlNodePtr parent;
1597     xmlNsPtr ns;
1598     xmlChar *name;
1599     xmlChar *prefix;
1600     const xmlChar *att;
1601     const xmlChar *value;
1602     int i;
1603 
1604     if ((ctx == NULL) || (fullname == NULL) || (ctxt-&gt;myDoc == NULL)) return;
1605     parent = ctxt-&gt;node;
1606 #ifdef DEBUG_SAX
1607     xmlGenericError(xmlGenericErrorContext,
1608         &quot;SAX.xmlSAX2StartElement(%s)\n&quot;, fullname);
1609 #endif
1610 
1611     /*
1612      * First check on validity:
1613      */
1614     if (ctxt-&gt;validate &amp;&amp; (ctxt-&gt;myDoc-&gt;extSubset == NULL) &amp;&amp;
1615         ((ctxt-&gt;myDoc-&gt;intSubset == NULL) ||
1616      ((ctxt-&gt;myDoc-&gt;intSubset-&gt;notations == NULL) &amp;&amp;
1617       (ctxt-&gt;myDoc-&gt;intSubset-&gt;elements == NULL) &amp;&amp;
1618       (ctxt-&gt;myDoc-&gt;intSubset-&gt;attributes == NULL) &amp;&amp;
1619       (ctxt-&gt;myDoc-&gt;intSubset-&gt;entities == NULL)))) {
1620     xmlErrValid(ctxt, XML_ERR_NO_DTD,
1621       &quot;Validation failed: no DTD found !&quot;, NULL, NULL);
1622     ctxt-&gt;validate = 0;
1623     }
1624 
1625 
1626     /*
1627      * Split the full name into a namespace prefix and the tag name
1628      */
1629     name = xmlSplitQName(ctxt, fullname, &amp;prefix);
1630 
1631 
1632     /*
1633      * Note : the namespace resolution is deferred until the end of the
1634      *        attributes parsing, since local namespace can be defined as
1635      *        an attribute at this level.
1636      */
1637     ret = xmlNewDocNodeEatName(ctxt-&gt;myDoc, NULL, name, NULL);
1638     if (ret == NULL) {
1639         if (prefix != NULL)
1640         xmlFree(prefix);
1641     xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartElement&quot;);
1642         return;
1643     }
1644     if (ctxt-&gt;myDoc-&gt;children == NULL) {
1645 #ifdef DEBUG_SAX_TREE
1646     xmlGenericError(xmlGenericErrorContext, &quot;Setting %s as root\n&quot;, name);
1647 #endif
1648         xmlAddChild((xmlNodePtr) ctxt-&gt;myDoc, (xmlNodePtr) ret);
1649     } else if (parent == NULL) {
1650         parent = ctxt-&gt;myDoc-&gt;children;
1651     }
1652     ctxt-&gt;nodemem = -1;
1653     if (ctxt-&gt;linenumbers) {
1654     if (ctxt-&gt;input != NULL) {
1655         if (ctxt-&gt;input-&gt;line &lt; 65535)
1656         ret-&gt;line = (short) ctxt-&gt;input-&gt;line;
1657         else
1658             ret-&gt;line = 65535;
1659     }
1660     }
1661 
1662     /*
1663      * We are parsing a new node.
1664      */
1665 #ifdef DEBUG_SAX_TREE
1666     xmlGenericError(xmlGenericErrorContext, &quot;pushing(%s)\n&quot;, name);
1667 #endif
1668     if (nodePush(ctxt, ret) &lt; 0) {
1669         xmlUnlinkNode(ret);
1670         xmlFreeNode(ret);
<a name="3" id="anc3"></a><span class="line-added">1671         if (prefix != NULL)</span>
<span class="line-added">1672             xmlFree(prefix);</span>
1673         return;
1674     }
1675 
1676     /*
1677      * Link the child element
1678      */
1679     if (parent != NULL) {
1680         if (parent-&gt;type == XML_ELEMENT_NODE) {
1681 #ifdef DEBUG_SAX_TREE
1682         xmlGenericError(xmlGenericErrorContext,
1683             &quot;adding child %s to %s\n&quot;, name, parent-&gt;name);
1684 #endif
1685         xmlAddChild(parent, ret);
1686     } else {
1687 #ifdef DEBUG_SAX_TREE
1688         xmlGenericError(xmlGenericErrorContext,
1689             &quot;adding sibling %s to &quot;, name);
1690         xmlDebugDumpOneNode(stderr, parent, 0);
1691 #endif
1692         xmlAddSibling(parent, ret);
1693     }
1694     }
1695 
1696     /*
1697      * Insert all the defaulted attributes from the DTD especially namespaces
1698      */
1699     if ((!ctxt-&gt;html) &amp;&amp;
1700     ((ctxt-&gt;myDoc-&gt;intSubset != NULL) ||
1701      (ctxt-&gt;myDoc-&gt;extSubset != NULL))) {
1702     xmlCheckDefaultedAttributes(ctxt, name, prefix, atts);
1703     }
1704 
1705     /*
1706      * process all the attributes whose name start with &quot;xmlns&quot;
1707      */
1708     if (atts != NULL) {
1709         i = 0;
1710     att = atts[i++];
1711     value = atts[i++];
1712     if (!ctxt-&gt;html) {
1713         while ((att != NULL) &amp;&amp; (value != NULL)) {
1714         if ((att[0] == &#39;x&#39;) &amp;&amp; (att[1] == &#39;m&#39;) &amp;&amp; (att[2] == &#39;l&#39;) &amp;&amp;
1715             (att[3] == &#39;n&#39;) &amp;&amp; (att[4] == &#39;s&#39;))
1716             xmlSAX2AttributeInternal(ctxt, att, value, prefix);
1717 
1718         att = atts[i++];
1719         value = atts[i++];
1720         }
1721     }
1722     }
1723 
1724     /*
1725      * Search the namespace, note that since the attributes have been
1726      * processed, the local namespaces are available.
1727      */
1728     ns = xmlSearchNs(ctxt-&gt;myDoc, ret, prefix);
1729     if ((ns == NULL) &amp;&amp; (parent != NULL))
1730     ns = xmlSearchNs(ctxt-&gt;myDoc, parent, prefix);
1731     if ((prefix != NULL) &amp;&amp; (ns == NULL)) {
1732     ns = xmlNewNs(ret, NULL, prefix);
1733     xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
1734              &quot;Namespace prefix %s is not defined\n&quot;,
1735              prefix, NULL);
1736     }
1737 
1738     /*
<a name="4" id="anc4"></a><span class="line-modified">1739      * set the namespace node, making sure that if the default namespace</span>
<span class="line-modified">1740      * is unbound on a parent we simply keep it NULL</span>
1741      */
1742     if ((ns != NULL) &amp;&amp; (ns-&gt;href != NULL) &amp;&amp;
1743     ((ns-&gt;href[0] != 0) || (ns-&gt;prefix != NULL)))
1744     xmlSetNs(ret, ns);
1745 
1746     /*
1747      * process all the other attributes
1748      */
1749     if (atts != NULL) {
1750         i = 0;
1751     att = atts[i++];
1752     value = atts[i++];
1753     if (ctxt-&gt;html) {
1754         while (att != NULL) {
1755         xmlSAX2AttributeInternal(ctxt, att, value, NULL);
1756         att = atts[i++];
1757         value = atts[i++];
1758         }
1759     } else {
1760         while ((att != NULL) &amp;&amp; (value != NULL)) {
1761         if ((att[0] != &#39;x&#39;) || (att[1] != &#39;m&#39;) || (att[2] != &#39;l&#39;) ||
1762             (att[3] != &#39;n&#39;) || (att[4] != &#39;s&#39;))
1763             xmlSAX2AttributeInternal(ctxt, att, value, NULL);
1764 
1765         /*
1766          * Next ones
1767          */
1768         att = atts[i++];
1769         value = atts[i++];
1770         }
1771     }
1772     }
1773 
1774 #ifdef LIBXML_VALID_ENABLED
1775     /*
1776      * If it&#39;s the Document root, finish the DTD validation and
1777      * check the document root element for validity
1778      */
1779     if ((ctxt-&gt;validate) &amp;&amp; (ctxt-&gt;vctxt.finishDtd == XML_CTXT_FINISH_DTD_0)) {
1780     int chk;
1781 
1782     chk = xmlValidateDtdFinal(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc);
1783     if (chk &lt;= 0)
1784         ctxt-&gt;valid = 0;
1785     if (chk &lt; 0)
1786         ctxt-&gt;wellFormed = 0;
1787     ctxt-&gt;valid &amp;= xmlValidateRoot(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc);
1788     ctxt-&gt;vctxt.finishDtd = XML_CTXT_FINISH_DTD_1;
1789     }
1790 #endif /* LIBXML_VALID_ENABLED */
1791 
1792     if (prefix != NULL)
1793     xmlFree(prefix);
1794 
1795 }
1796 
1797 /**
1798  * xmlSAX2EndElement:
1799  * @ctx: the user data (XML parser context)
1800  * @name:  The element name
1801  *
1802  * called when the end of an element has been detected.
1803  */
1804 void
1805 xmlSAX2EndElement(void *ctx, const xmlChar *name ATTRIBUTE_UNUSED)
1806 {
1807     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
1808     xmlNodePtr cur;
1809 
1810     if (ctx == NULL) return;
1811     cur = ctxt-&gt;node;
1812 #ifdef DEBUG_SAX
1813     if (name == NULL)
1814         xmlGenericError(xmlGenericErrorContext, &quot;SAX.xmlSAX2EndElement(NULL)\n&quot;);
1815     else
1816     xmlGenericError(xmlGenericErrorContext, &quot;SAX.xmlSAX2EndElement(%s)\n&quot;, name);
1817 #endif
1818 
1819     /* Capture end position and add node */
1820     if (cur != NULL &amp;&amp; ctxt-&gt;record_info) {
1821       ctxt-&gt;nodeInfo-&gt;end_pos = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
1822       ctxt-&gt;nodeInfo-&gt;end_line = ctxt-&gt;input-&gt;line;
1823       ctxt-&gt;nodeInfo-&gt;node = cur;
1824       xmlParserAddNodeInfo(ctxt, ctxt-&gt;nodeInfo);
1825     }
1826     ctxt-&gt;nodemem = -1;
1827 
1828 #ifdef LIBXML_VALID_ENABLED
1829     if (ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp;
1830         ctxt-&gt;myDoc &amp;&amp; ctxt-&gt;myDoc-&gt;intSubset)
1831         ctxt-&gt;valid &amp;= xmlValidateOneElement(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc,
1832                          cur);
1833 #endif /* LIBXML_VALID_ENABLED */
1834 
1835 
1836     /*
1837      * end of parsing of this node.
1838      */
1839 #ifdef DEBUG_SAX_TREE
1840     xmlGenericError(xmlGenericErrorContext, &quot;popping(%s)\n&quot;, cur-&gt;name);
1841 #endif
1842     nodePop(ctxt);
1843 }
1844 #endif /* LIBXML_SAX1_ENABLED || LIBXML_HTML_ENABLED || LIBXML_LEGACY_ENABLED */
1845 
1846 /*
1847  * xmlSAX2TextNode:
1848  * @ctxt:  the parser context
1849  * @str:  the input string
1850  * @len: the string length
1851  *
1852  * Callback for a text node
1853  *
1854  * Returns the newly allocated string or NULL if not needed or error
1855  */
1856 static xmlNodePtr
1857 xmlSAX2TextNode(xmlParserCtxtPtr ctxt, const xmlChar *str, int len) {
1858     xmlNodePtr ret;
1859     const xmlChar *intern = NULL;
1860 
1861     /*
1862      * Allocate
1863      */
1864     if (ctxt-&gt;freeElems != NULL) {
1865     ret = ctxt-&gt;freeElems;
1866     ctxt-&gt;freeElems = ret-&gt;next;
1867     ctxt-&gt;freeElemsNr--;
1868     } else {
1869     ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
1870     }
1871     if (ret == NULL) {
1872         xmlErrMemory(ctxt, &quot;xmlSAX2Characters&quot;);
1873     return(NULL);
1874     }
1875     memset(ret, 0, sizeof(xmlNode));
1876     /*
1877      * intern the formatting blanks found between tags, or the
1878      * very short strings
1879      */
1880     if (ctxt-&gt;dictNames) {
1881         xmlChar cur = str[len];
1882 
1883     if ((len &lt; (int) (2 * sizeof(void *))) &amp;&amp;
1884         (ctxt-&gt;options &amp; XML_PARSE_COMPACT)) {
1885         /* store the string in the node overriding properties and nsDef */
1886         xmlChar *tmp = (xmlChar *) &amp;(ret-&gt;properties);
1887         memcpy(tmp, str, len);
1888         tmp[len] = 0;
1889         intern = tmp;
1890     } else if ((len &lt;= 3) &amp;&amp; ((cur == &#39;&quot;&#39;) || (cur == &#39;\&#39;&#39;) ||
1891         ((cur == &#39;&lt;&#39;) &amp;&amp; (str[len + 1] != &#39;!&#39;)))) {
1892         intern = xmlDictLookup(ctxt-&gt;dict, str, len);
1893     } else if (IS_BLANK_CH(*str) &amp;&amp; (len &lt; 60) &amp;&amp; (cur == &#39;&lt;&#39;) &amp;&amp;
1894                (str[len + 1] != &#39;!&#39;)) {
1895         int i;
1896 
1897         for (i = 1;i &lt; len;i++) {
1898         if (!IS_BLANK_CH(str[i])) goto skip;
1899         }
1900         intern = xmlDictLookup(ctxt-&gt;dict, str, len);
1901     }
1902     }
1903 skip:
1904     ret-&gt;type = XML_TEXT_NODE;
1905 
1906     ret-&gt;name = xmlStringText;
1907     if (intern == NULL) {
1908     ret-&gt;content = xmlStrndup(str, len);
1909     if (ret-&gt;content == NULL) {
1910         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2TextNode&quot;);
1911         xmlFree(ret);
1912         return(NULL);
1913     }
1914     } else
1915     ret-&gt;content = (xmlChar *) intern;
1916 
1917     if (ctxt-&gt;linenumbers) {
1918     if (ctxt-&gt;input != NULL) {
1919         if (ctxt-&gt;input-&gt;line &lt; 65535)
1920         ret-&gt;line = (short) ctxt-&gt;input-&gt;line;
1921         else {
1922             ret-&gt;line = 65535;
1923         if (ctxt-&gt;options &amp; XML_PARSE_BIG_LINES)
1924             ret-&gt;psvi = (void *) (ptrdiff_t) ctxt-&gt;input-&gt;line;
1925         }
1926     }
1927     }
1928 
1929     if ((__xmlRegisterCallbacks) &amp;&amp; (xmlRegisterNodeDefaultValue))
1930     xmlRegisterNodeDefaultValue(ret);
1931     return(ret);
1932 }
1933 
1934 #ifdef LIBXML_VALID_ENABLED
1935 /*
1936  * xmlSAX2DecodeAttrEntities:
1937  * @ctxt:  the parser context
1938  * @str:  the input string
1939  * @len: the string length
1940  *
1941  * Remove the entities from an attribute value
1942  *
1943  * Returns the newly allocated string or NULL if not needed or error
1944  */
1945 static xmlChar *
1946 xmlSAX2DecodeAttrEntities(xmlParserCtxtPtr ctxt, const xmlChar *str,
1947                           const xmlChar *end) {
1948     const xmlChar *in;
1949     xmlChar *ret;
1950 
1951     in = str;
1952     while (in &lt; end)
1953         if (*in++ == &#39;&amp;&#39;)
1954         goto decode;
1955     return(NULL);
1956 decode:
1957     ctxt-&gt;depth++;
1958     ret = xmlStringLenDecodeEntities(ctxt, str, end - str,
1959                      XML_SUBSTITUTE_REF, 0,0,0);
1960     ctxt-&gt;depth--;
1961     return(ret);
1962 }
1963 #endif /* LIBXML_VALID_ENABLED */
1964 
1965 /**
1966  * xmlSAX2AttributeNs:
1967  * @ctx: the user data (XML parser context)
1968  * @localname:  the local name of the attribute
1969  * @prefix:  the attribute namespace prefix if available
1970  * @URI:  the attribute namespace name if available
1971  * @value:  Start of the attribute value
1972  * @valueend: end of the attribute value
1973  *
1974  * Handle an attribute that has been read by the parser.
1975  * The default handling is to convert the attribute into an
1976  * DOM subtree and past it in a new xmlAttr element added to
1977  * the element.
1978  */
1979 static void
1980 xmlSAX2AttributeNs(xmlParserCtxtPtr ctxt,
1981                    const xmlChar * localname,
1982                    const xmlChar * prefix,
1983            const xmlChar * value,
1984            const xmlChar * valueend)
1985 {
1986     xmlAttrPtr ret;
1987     xmlNsPtr namespace = NULL;
1988     xmlChar *dup = NULL;
1989 
1990     /*
1991      * Note: if prefix == NULL, the attribute is not in the default namespace
1992      */
1993     if (prefix != NULL)
1994     namespace = xmlSearchNs(ctxt-&gt;myDoc, ctxt-&gt;node, prefix);
1995 
1996     /*
1997      * allocate the node
1998      */
1999     if (ctxt-&gt;freeAttrs != NULL) {
2000         ret = ctxt-&gt;freeAttrs;
2001     ctxt-&gt;freeAttrs = ret-&gt;next;
2002     ctxt-&gt;freeAttrsNr--;
2003     memset(ret, 0, sizeof(xmlAttr));
2004     ret-&gt;type = XML_ATTRIBUTE_NODE;
2005 
2006     ret-&gt;parent = ctxt-&gt;node;
2007     ret-&gt;doc = ctxt-&gt;myDoc;
2008     ret-&gt;ns = namespace;
2009 
2010     if (ctxt-&gt;dictNames)
2011         ret-&gt;name = localname;
2012     else
2013         ret-&gt;name = xmlStrdup(localname);
2014 
<a name="5" id="anc5"></a><span class="line-modified">2015         /* link at the end to preserve order, TODO speed up with a last */</span>
2016     if (ctxt-&gt;node-&gt;properties == NULL) {
2017         ctxt-&gt;node-&gt;properties = ret;
2018     } else {
2019         xmlAttrPtr prev = ctxt-&gt;node-&gt;properties;
2020 
2021         while (prev-&gt;next != NULL) prev = prev-&gt;next;
2022         prev-&gt;next = ret;
2023         ret-&gt;prev = prev;
2024     }
2025 
2026     if ((__xmlRegisterCallbacks) &amp;&amp; (xmlRegisterNodeDefaultValue))
2027         xmlRegisterNodeDefaultValue((xmlNodePtr)ret);
2028     } else {
2029     if (ctxt-&gt;dictNames)
2030         ret = xmlNewNsPropEatName(ctxt-&gt;node, namespace,
2031                                   (xmlChar *) localname, NULL);
2032     else
2033         ret = xmlNewNsProp(ctxt-&gt;node, namespace, localname, NULL);
2034     if (ret == NULL) {
2035         xmlErrMemory(ctxt, &quot;xmlSAX2AttributeNs&quot;);
2036         return;
2037     }
2038     }
2039 
2040     if ((ctxt-&gt;replaceEntities == 0) &amp;&amp; (!ctxt-&gt;html)) {
2041     xmlNodePtr tmp;
2042 
2043     /*
2044      * We know that if there is an entity reference, then
2045      * the string has been dup&#39;ed and terminates with 0
2046      * otherwise with &#39; or &quot;
2047      */
2048     if (*valueend != 0) {
2049         tmp = xmlSAX2TextNode(ctxt, value, valueend - value);
2050         ret-&gt;children = tmp;
2051         ret-&gt;last = tmp;
2052         if (tmp != NULL) {
2053         tmp-&gt;doc = ret-&gt;doc;
2054         tmp-&gt;parent = (xmlNodePtr) ret;
2055         }
2056     } else {
2057         ret-&gt;children = xmlStringLenGetNodeList(ctxt-&gt;myDoc, value,
2058                             valueend - value);
2059         tmp = ret-&gt;children;
2060         while (tmp != NULL) {
2061             tmp-&gt;doc = ret-&gt;doc;
2062         tmp-&gt;parent = (xmlNodePtr) ret;
2063         if (tmp-&gt;next == NULL)
2064             ret-&gt;last = tmp;
2065         tmp = tmp-&gt;next;
2066         }
2067     }
2068     } else if (value != NULL) {
2069     xmlNodePtr tmp;
2070 
2071     tmp = xmlSAX2TextNode(ctxt, value, valueend - value);
2072     ret-&gt;children = tmp;
2073     ret-&gt;last = tmp;
2074     if (tmp != NULL) {
2075         tmp-&gt;doc = ret-&gt;doc;
2076         tmp-&gt;parent = (xmlNodePtr) ret;
2077     }
2078     }
2079 
2080 #ifdef LIBXML_VALID_ENABLED
2081     if ((!ctxt-&gt;html) &amp;&amp; ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp;
2082         ctxt-&gt;myDoc &amp;&amp; ctxt-&gt;myDoc-&gt;intSubset) {
2083     /*
2084      * If we don&#39;t substitute entities, the validation should be
2085      * done on a value with replaced entities anyway.
2086      */
2087         if (!ctxt-&gt;replaceEntities) {
2088         dup = xmlSAX2DecodeAttrEntities(ctxt, value, valueend);
2089         if (dup == NULL) {
2090             if (*valueend == 0) {
2091             ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
2092                     ctxt-&gt;myDoc, ctxt-&gt;node, ret, value);
2093         } else {
2094             /*
2095              * That should already be normalized.
2096              * cheaper to finally allocate here than duplicate
2097              * entry points in the full validation code
2098              */
2099             dup = xmlStrndup(value, valueend - value);
2100 
2101             ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
2102                     ctxt-&gt;myDoc, ctxt-&gt;node, ret, dup);
2103         }
2104         } else {
2105             /*
2106          * dup now contains a string of the flattened attribute
<a name="6" id="anc6"></a><span class="line-modified">2107          * content with entities substituted. Check if we need to</span>
2108          * apply an extra layer of normalization.
2109          * It need to be done twice ... it&#39;s an extra burden related
2110          * to the ability to keep references in attributes
2111          */
2112         if (ctxt-&gt;attsSpecial != NULL) {
2113             xmlChar *nvalnorm;
2114             xmlChar fn[50];
2115             xmlChar *fullname;
2116 
2117             fullname = xmlBuildQName(localname, prefix, fn, 50);
2118             if (fullname != NULL) {
2119             ctxt-&gt;vctxt.valid = 1;
2120                 nvalnorm = xmlValidCtxtNormalizeAttributeValue(
2121                              &amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc,
2122                      ctxt-&gt;node, fullname, dup);
2123             if (ctxt-&gt;vctxt.valid != 1)
2124                 ctxt-&gt;valid = 0;
2125 
2126             if ((fullname != fn) &amp;&amp; (fullname != localname))
2127                 xmlFree(fullname);
2128             if (nvalnorm != NULL) {
2129                 xmlFree(dup);
2130                 dup = nvalnorm;
2131             }
2132             }
2133         }
2134 
2135         ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
2136                     ctxt-&gt;myDoc, ctxt-&gt;node, ret, dup);
2137         }
2138     } else {
2139         /*
<a name="7" id="anc7"></a><span class="line-modified">2140          * if entities already have been substituted, then</span>
2141          * the attribute as passed is already normalized
2142          */
2143         dup = xmlStrndup(value, valueend - value);
2144 
2145         ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
2146                                  ctxt-&gt;myDoc, ctxt-&gt;node, ret, dup);
2147     }
2148     } else
2149 #endif /* LIBXML_VALID_ENABLED */
2150            if (((ctxt-&gt;loadsubset &amp; XML_SKIP_IDS) == 0) &amp;&amp;
2151            (((ctxt-&gt;replaceEntities == 0) &amp;&amp; (ctxt-&gt;external != 2)) ||
2152             ((ctxt-&gt;replaceEntities != 0) &amp;&amp; (ctxt-&gt;inSubset == 0)))) {
2153         /*
2154      * when validating, the ID registration is done at the attribute
2155      * validation level. Otherwise we have to do specific handling here.
2156      */
2157         if ((prefix == ctxt-&gt;str_xml) &amp;&amp;
2158                (localname[0] == &#39;i&#39;) &amp;&amp; (localname[1] == &#39;d&#39;) &amp;&amp;
2159            (localname[2] == 0)) {
2160         /*
2161          * Add the xml:id value
2162          *
2163          * Open issue: normalization of the value.
2164          */
2165         if (dup == NULL)
2166             dup = xmlStrndup(value, valueend - value);
2167 #if defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_DOCB_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
2168 #ifdef LIBXML_VALID_ENABLED
2169         if (xmlValidateNCName(dup, 1) != 0) {
2170             xmlErrValid(ctxt, XML_DTD_XMLID_VALUE,
2171               &quot;xml:id : attribute value %s is not an NCName\n&quot;,
2172                 (const char *) dup, NULL);
2173         }
2174 #endif
2175 #endif
2176         xmlAddID(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc, dup, ret);
2177     } else if (xmlIsID(ctxt-&gt;myDoc, ctxt-&gt;node, ret)) {
2178         /* might be worth duplicate entry points and not copy */
2179         if (dup == NULL)
2180             dup = xmlStrndup(value, valueend - value);
2181         xmlAddID(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc, dup, ret);
2182     } else if (xmlIsRef(ctxt-&gt;myDoc, ctxt-&gt;node, ret)) {
2183         if (dup == NULL)
2184             dup = xmlStrndup(value, valueend - value);
2185         xmlAddRef(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc, dup, ret);
2186     }
2187     }
2188     if (dup != NULL)
2189     xmlFree(dup);
2190 }
2191 
2192 /**
2193  * xmlSAX2StartElementNs:
2194  * @ctx:  the user data (XML parser context)
2195  * @localname:  the local name of the element
2196  * @prefix:  the element namespace prefix if available
2197  * @URI:  the element namespace name if available
2198  * @nb_namespaces:  number of namespace definitions on that node
2199  * @namespaces:  pointer to the array of prefix/URI pairs namespace definitions
2200  * @nb_attributes:  the number of attributes on that node
2201  * @nb_defaulted:  the number of defaulted attributes.
2202  * @attributes:  pointer to the array of (localname/prefix/URI/value/end)
2203  *               attribute values.
2204  *
2205  * SAX2 callback when an element start has been detected by the parser.
2206  * It provides the namespace informations for the element, as well as
2207  * the new namespace declarations on the element.
2208  */
2209 void
2210 xmlSAX2StartElementNs(void *ctx,
2211                       const xmlChar *localname,
2212               const xmlChar *prefix,
2213               const xmlChar *URI,
2214               int nb_namespaces,
2215               const xmlChar **namespaces,
2216               int nb_attributes,
2217               int nb_defaulted,
2218               const xmlChar **attributes)
2219 {
2220     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
2221     xmlNodePtr ret;
2222     xmlNodePtr parent;
2223     xmlNsPtr last = NULL, ns;
2224     const xmlChar *uri, *pref;
2225     xmlChar *lname = NULL;
2226     int i, j;
2227 
2228     if (ctx == NULL) return;
2229     parent = ctxt-&gt;node;
2230     /*
2231      * First check on validity:
2232      */
2233     if (ctxt-&gt;validate &amp;&amp; (ctxt-&gt;myDoc-&gt;extSubset == NULL) &amp;&amp;
2234         ((ctxt-&gt;myDoc-&gt;intSubset == NULL) ||
2235      ((ctxt-&gt;myDoc-&gt;intSubset-&gt;notations == NULL) &amp;&amp;
2236       (ctxt-&gt;myDoc-&gt;intSubset-&gt;elements == NULL) &amp;&amp;
2237       (ctxt-&gt;myDoc-&gt;intSubset-&gt;attributes == NULL) &amp;&amp;
2238       (ctxt-&gt;myDoc-&gt;intSubset-&gt;entities == NULL)))) {
2239     xmlErrValid(ctxt, XML_DTD_NO_DTD,
2240       &quot;Validation failed: no DTD found !&quot;, NULL, NULL);
2241     ctxt-&gt;validate = 0;
2242     }
2243 
2244     /*
2245      * Take care of the rare case of an undefined namespace prefix
2246      */
2247     if ((prefix != NULL) &amp;&amp; (URI == NULL)) {
2248         if (ctxt-&gt;dictNames) {
2249         const xmlChar *fullname;
2250 
2251         fullname = xmlDictQLookup(ctxt-&gt;dict, prefix, localname);
2252         if (fullname != NULL)
2253             localname = fullname;
2254     } else {
2255         lname = xmlBuildQName(localname, prefix, NULL, 0);
2256     }
2257     }
2258     /*
2259      * allocate the node
2260      */
2261     if (ctxt-&gt;freeElems != NULL) {
2262         ret = ctxt-&gt;freeElems;
2263     ctxt-&gt;freeElems = ret-&gt;next;
2264     ctxt-&gt;freeElemsNr--;
2265     memset(ret, 0, sizeof(xmlNode));
2266         ret-&gt;doc = ctxt-&gt;myDoc;
2267     ret-&gt;type = XML_ELEMENT_NODE;
2268 
2269     if (ctxt-&gt;dictNames)
2270         ret-&gt;name = localname;
2271     else {
2272         if (lname == NULL)
2273         ret-&gt;name = xmlStrdup(localname);
2274         else
2275             ret-&gt;name = lname;
2276         if (ret-&gt;name == NULL) {
2277             xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartElementNs&quot;);
2278         return;
2279         }
2280     }
2281     if ((__xmlRegisterCallbacks) &amp;&amp; (xmlRegisterNodeDefaultValue))
2282         xmlRegisterNodeDefaultValue(ret);
2283     } else {
2284     if (ctxt-&gt;dictNames)
2285         ret = xmlNewDocNodeEatName(ctxt-&gt;myDoc, NULL,
2286                                    (xmlChar *) localname, NULL);
2287     else if (lname == NULL)
2288         ret = xmlNewDocNode(ctxt-&gt;myDoc, NULL, localname, NULL);
2289     else
2290         ret = xmlNewDocNodeEatName(ctxt-&gt;myDoc, NULL,
2291                                    (xmlChar *) lname, NULL);
2292     if (ret == NULL) {
2293         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartElementNs&quot;);
2294         return;
2295     }
2296     }
2297     if (ctxt-&gt;linenumbers) {
2298     if (ctxt-&gt;input != NULL) {
2299         if (ctxt-&gt;input-&gt;line &lt; 65535)
2300         ret-&gt;line = (short) ctxt-&gt;input-&gt;line;
2301         else
2302             ret-&gt;line = 65535;
2303     }
2304     }
2305 
2306     if (parent == NULL) {
2307         xmlAddChild((xmlNodePtr) ctxt-&gt;myDoc, (xmlNodePtr) ret);
2308     }
2309     /*
2310      * Build the namespace list
2311      */
2312     for (i = 0,j = 0;j &lt; nb_namespaces;j++) {
2313         pref = namespaces[i++];
2314     uri = namespaces[i++];
2315     ns = xmlNewNs(NULL, uri, pref);
2316     if (ns != NULL) {
2317         if (last == NULL) {
2318             ret-&gt;nsDef = last = ns;
2319         } else {
2320             last-&gt;next = ns;
2321         last = ns;
2322         }
2323         if ((URI != NULL) &amp;&amp; (prefix == pref))
2324         ret-&gt;ns = ns;
2325     } else {
2326             /*
2327              * any out of memory error would already have been raised
2328              * but we can&#39;t be guaranteed it&#39;s the actual error due to the
2329              * API, best is to skip in this case
2330              */
2331         continue;
2332     }
2333 #ifdef LIBXML_VALID_ENABLED
2334     if ((!ctxt-&gt;html) &amp;&amp; ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp;
2335         ctxt-&gt;myDoc &amp;&amp; ctxt-&gt;myDoc-&gt;intSubset) {
2336         ctxt-&gt;valid &amp;= xmlValidateOneNamespace(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc,
2337                                                ret, prefix, ns, uri);
2338     }
2339 #endif /* LIBXML_VALID_ENABLED */
2340     }
2341     ctxt-&gt;nodemem = -1;
2342 
2343     /*
2344      * We are parsing a new node.
2345      */
2346     if (nodePush(ctxt, ret) &lt; 0) {
2347         xmlUnlinkNode(ret);
2348         xmlFreeNode(ret);
2349         return;
2350     }
2351 
2352     /*
2353      * Link the child element
2354      */
2355     if (parent != NULL) {
2356         if (parent-&gt;type == XML_ELEMENT_NODE) {
2357         xmlAddChild(parent, ret);
2358     } else {
2359         xmlAddSibling(parent, ret);
2360     }
2361     }
2362 
2363     /*
2364      * Insert the defaulted attributes from the DTD only if requested:
2365      */
2366     if ((nb_defaulted != 0) &amp;&amp;
2367         ((ctxt-&gt;loadsubset &amp; XML_COMPLETE_ATTRS) == 0))
2368     nb_attributes -= nb_defaulted;
2369 
2370     /*
2371      * Search the namespace if it wasn&#39;t already found
2372      * Note that, if prefix is NULL, this searches for the default Ns
2373      */
2374     if ((URI != NULL) &amp;&amp; (ret-&gt;ns == NULL)) {
2375         ret-&gt;ns = xmlSearchNs(ctxt-&gt;myDoc, parent, prefix);
2376     if ((ret-&gt;ns == NULL) &amp;&amp; (xmlStrEqual(prefix, BAD_CAST &quot;xml&quot;))) {
2377         ret-&gt;ns = xmlSearchNs(ctxt-&gt;myDoc, ret, prefix);
2378     }
2379     if (ret-&gt;ns == NULL) {
2380         ns = xmlNewNs(ret, NULL, prefix);
2381         if (ns == NULL) {
2382 
2383             xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartElementNs&quot;);
2384         return;
2385         }
2386             if (prefix != NULL)
2387                 xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
2388                              &quot;Namespace prefix %s was not found\n&quot;,
2389                              prefix, NULL);
2390             else
2391                 xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
2392                              &quot;Namespace default prefix was not found\n&quot;,
2393                              NULL, NULL);
2394     }
2395     }
2396 
2397     /*
2398      * process all the other attributes
2399      */
2400     if (nb_attributes &gt; 0) {
2401         for (j = 0,i = 0;i &lt; nb_attributes;i++,j+=5) {
2402         /*
<a name="8" id="anc8"></a><span class="line-modified">2403          * Handle the rare case of an undefined attribute prefix</span>
2404          */
2405         if ((attributes[j+1] != NULL) &amp;&amp; (attributes[j+2] == NULL)) {
2406         if (ctxt-&gt;dictNames) {
2407             const xmlChar *fullname;
2408 
2409             fullname = xmlDictQLookup(ctxt-&gt;dict, attributes[j+1],
2410                                       attributes[j]);
2411             if (fullname != NULL) {
2412             xmlSAX2AttributeNs(ctxt, fullname, NULL,
2413                                attributes[j+3], attributes[j+4]);
2414                 continue;
2415             }
2416         } else {
2417             lname = xmlBuildQName(attributes[j], attributes[j+1],
2418                                   NULL, 0);
2419             if (lname != NULL) {
2420             xmlSAX2AttributeNs(ctxt, lname, NULL,
2421                                attributes[j+3], attributes[j+4]);
2422             xmlFree(lname);
2423                 continue;
2424             }
2425         }
2426         }
2427         xmlSAX2AttributeNs(ctxt, attributes[j], attributes[j+1],
2428                    attributes[j+3], attributes[j+4]);
2429     }
2430     }
2431 
2432 #ifdef LIBXML_VALID_ENABLED
2433     /*
2434      * If it&#39;s the Document root, finish the DTD validation and
2435      * check the document root element for validity
2436      */
2437     if ((ctxt-&gt;validate) &amp;&amp; (ctxt-&gt;vctxt.finishDtd == XML_CTXT_FINISH_DTD_0)) {
2438     int chk;
2439 
2440     chk = xmlValidateDtdFinal(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc);
2441     if (chk &lt;= 0)
2442         ctxt-&gt;valid = 0;
2443     if (chk &lt; 0)
2444         ctxt-&gt;wellFormed = 0;
2445     ctxt-&gt;valid &amp;= xmlValidateRoot(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc);
2446     ctxt-&gt;vctxt.finishDtd = XML_CTXT_FINISH_DTD_1;
2447     }
2448 #endif /* LIBXML_VALID_ENABLED */
2449 }
2450 
2451 /**
2452  * xmlSAX2EndElementNs:
2453  * @ctx:  the user data (XML parser context)
2454  * @localname:  the local name of the element
2455  * @prefix:  the element namespace prefix if available
2456  * @URI:  the element namespace name if available
2457  *
2458  * SAX2 callback when an element end has been detected by the parser.
2459  * It provides the namespace informations for the element.
2460  */
2461 void
2462 xmlSAX2EndElementNs(void *ctx,
2463                     const xmlChar * localname ATTRIBUTE_UNUSED,
2464                     const xmlChar * prefix ATTRIBUTE_UNUSED,
2465             const xmlChar * URI ATTRIBUTE_UNUSED)
2466 {
2467     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
2468     xmlParserNodeInfo node_info;
2469     xmlNodePtr cur;
2470 
2471     if (ctx == NULL) return;
2472     cur = ctxt-&gt;node;
2473     /* Capture end position and add node */
2474     if ((ctxt-&gt;record_info) &amp;&amp; (cur != NULL)) {
2475         node_info.end_pos = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
2476         node_info.end_line = ctxt-&gt;input-&gt;line;
2477         node_info.node = cur;
2478         xmlParserAddNodeInfo(ctxt, &amp;node_info);
2479     }
2480     ctxt-&gt;nodemem = -1;
2481 
2482 #ifdef LIBXML_VALID_ENABLED
2483     if (ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp;
2484         ctxt-&gt;myDoc &amp;&amp; ctxt-&gt;myDoc-&gt;intSubset)
2485         ctxt-&gt;valid &amp;= xmlValidateOneElement(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc, cur);
2486 #endif /* LIBXML_VALID_ENABLED */
2487 
2488     /*
2489      * end of parsing of this node.
2490      */
2491     nodePop(ctxt);
2492 }
2493 
2494 /**
2495  * xmlSAX2Reference:
2496  * @ctx: the user data (XML parser context)
2497  * @name:  The entity name
2498  *
2499  * called when an entity xmlSAX2Reference is detected.
2500  */
2501 void
2502 xmlSAX2Reference(void *ctx, const xmlChar *name)
2503 {
2504     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
2505     xmlNodePtr ret;
2506 
2507     if (ctx == NULL) return;
2508 #ifdef DEBUG_SAX
2509     xmlGenericError(xmlGenericErrorContext,
2510         &quot;SAX.xmlSAX2Reference(%s)\n&quot;, name);
2511 #endif
2512     if (name[0] == &#39;#&#39;)
2513     ret = xmlNewCharRef(ctxt-&gt;myDoc, name);
2514     else
2515     ret = xmlNewReference(ctxt-&gt;myDoc, name);
2516 #ifdef DEBUG_SAX_TREE
2517     xmlGenericError(xmlGenericErrorContext,
2518         &quot;add xmlSAX2Reference %s to %s \n&quot;, name, ctxt-&gt;node-&gt;name);
2519 #endif
2520     if (xmlAddChild(ctxt-&gt;node, ret) == NULL) {
2521         xmlFreeNode(ret);
2522     }
2523 }
2524 
2525 /**
2526  * xmlSAX2Characters:
2527  * @ctx: the user data (XML parser context)
2528  * @ch:  a xmlChar string
2529  * @len: the number of xmlChar
2530  *
2531  * receiving some chars from the parser.
2532  */
2533 void
2534 xmlSAX2Characters(void *ctx, const xmlChar *ch, int len)
2535 {
2536     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
2537     xmlNodePtr lastChild;
2538 
2539     if (ctx == NULL) return;
2540 #ifdef DEBUG_SAX
2541     xmlGenericError(xmlGenericErrorContext,
2542         &quot;SAX.xmlSAX2Characters(%.30s, %d)\n&quot;, ch, len);
2543 #endif
2544     /*
2545      * Handle the data if any. If there is no child
2546      * add it as content, otherwise if the last child is text,
2547      * concatenate it, else create a new node of type text.
2548      */
2549 
2550     if (ctxt-&gt;node == NULL) {
2551 #ifdef DEBUG_SAX_TREE
2552     xmlGenericError(xmlGenericErrorContext,
2553         &quot;add chars: ctxt-&gt;node == NULL !\n&quot;);
2554 #endif
2555         return;
2556     }
2557     lastChild = ctxt-&gt;node-&gt;last;
2558 #ifdef DEBUG_SAX_TREE
2559     xmlGenericError(xmlGenericErrorContext,
2560         &quot;add chars to %s \n&quot;, ctxt-&gt;node-&gt;name);
2561 #endif
2562 
2563     /*
2564      * Here we needed an accelerator mechanism in case of very large
2565      * elements. Use an attribute in the structure !!!
2566      */
2567     if (lastChild == NULL) {
2568         lastChild = xmlSAX2TextNode(ctxt, ch, len);
2569     if (lastChild != NULL) {
2570         ctxt-&gt;node-&gt;children = lastChild;
2571         ctxt-&gt;node-&gt;last = lastChild;
2572         lastChild-&gt;parent = ctxt-&gt;node;
2573         lastChild-&gt;doc = ctxt-&gt;node-&gt;doc;
2574         ctxt-&gt;nodelen = len;
2575         ctxt-&gt;nodemem = len + 1;
2576     } else {
2577         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2Characters&quot;);
2578         return;
2579     }
2580     } else {
2581     int coalesceText = (lastChild != NULL) &amp;&amp;
2582         (lastChild-&gt;type == XML_TEXT_NODE) &amp;&amp;
2583         (lastChild-&gt;name == xmlStringText);
2584     if ((coalesceText) &amp;&amp; (ctxt-&gt;nodemem != 0)) {
2585         /*
2586          * The whole point of maintaining nodelen and nodemem,
2587          * xmlTextConcat is too costly, i.e. compute length,
2588          * reallocate a new buffer, move data, append ch. Here
<a name="9" id="anc9"></a><span class="line-modified">2589          * We try to minimize realloc() uses and avoid copying</span>
2590          * and recomputing length over and over.
2591          */
2592         if (lastChild-&gt;content == (xmlChar *)&amp;(lastChild-&gt;properties)) {
2593         lastChild-&gt;content = xmlStrdup(lastChild-&gt;content);
2594         lastChild-&gt;properties = NULL;
2595         } else if ((ctxt-&gt;nodemem == ctxt-&gt;nodelen + 1) &amp;&amp;
2596                    (xmlDictOwns(ctxt-&gt;dict, lastChild-&gt;content))) {
2597         lastChild-&gt;content = xmlStrdup(lastChild-&gt;content);
2598         }
2599         if (lastChild-&gt;content == NULL) {
2600         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2Characters: xmlStrdup returned NULL&quot;);
2601         return;
2602         }
2603             if (((size_t)ctxt-&gt;nodelen + (size_t)len &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
2604                 ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
2605                 xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2Characters: huge text node&quot;);
2606                 return;
2607             }
2608         if ((size_t)ctxt-&gt;nodelen &gt; SIZE_T_MAX - (size_t)len ||
2609             (size_t)ctxt-&gt;nodemem + (size_t)len &gt; SIZE_T_MAX / 2) {
2610                 xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2Characters overflow prevented&quot;);
2611                 return;
2612         }
2613         if (ctxt-&gt;nodelen + len &gt;= ctxt-&gt;nodemem) {
2614         xmlChar *newbuf;
2615         size_t size;
2616 
2617         size = ctxt-&gt;nodemem + len;
2618         size *= 2;
2619                 newbuf = (xmlChar *) xmlRealloc(lastChild-&gt;content,size);
2620         if (newbuf == NULL) {
2621             xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2Characters&quot;);
2622             return;
2623         }
2624         ctxt-&gt;nodemem = size;
2625         lastChild-&gt;content = newbuf;
2626         }
2627         memcpy(&amp;lastChild-&gt;content[ctxt-&gt;nodelen], ch, len);
2628         ctxt-&gt;nodelen += len;
2629         lastChild-&gt;content[ctxt-&gt;nodelen] = 0;
2630     } else if (coalesceText) {
2631         if (xmlTextConcat(lastChild, ch, len)) {
2632         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2Characters&quot;);
2633         }
2634         if (ctxt-&gt;node-&gt;children != NULL) {
2635         ctxt-&gt;nodelen = xmlStrlen(lastChild-&gt;content);
2636         ctxt-&gt;nodemem = ctxt-&gt;nodelen + 1;
2637         }
2638     } else {
2639         /* Mixed content, first time */
2640         lastChild = xmlSAX2TextNode(ctxt, ch, len);
2641         if (lastChild != NULL) {
2642         xmlAddChild(ctxt-&gt;node, lastChild);
2643         if (ctxt-&gt;node-&gt;children != NULL) {
2644             ctxt-&gt;nodelen = len;
2645             ctxt-&gt;nodemem = len + 1;
2646         }
2647         }
2648     }
2649     }
2650 }
2651 
2652 /**
2653  * xmlSAX2IgnorableWhitespace:
2654  * @ctx: the user data (XML parser context)
2655  * @ch:  a xmlChar string
2656  * @len: the number of xmlChar
2657  *
2658  * receiving some ignorable whitespaces from the parser.
2659  * UNUSED: by default the DOM building will use xmlSAX2Characters
2660  */
2661 void
2662 xmlSAX2IgnorableWhitespace(void *ctx ATTRIBUTE_UNUSED, const xmlChar *ch ATTRIBUTE_UNUSED, int len ATTRIBUTE_UNUSED)
2663 {
2664     /* xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx; */
2665 #ifdef DEBUG_SAX
2666     xmlGenericError(xmlGenericErrorContext,
2667         &quot;SAX.xmlSAX2IgnorableWhitespace(%.30s, %d)\n&quot;, ch, len);
2668 #endif
2669 }
2670 
2671 /**
2672  * xmlSAX2ProcessingInstruction:
2673  * @ctx: the user data (XML parser context)
2674  * @target:  the target name
2675  * @data: the PI data&#39;s
2676  *
2677  * A processing instruction has been parsed.
2678  */
2679 void
2680 xmlSAX2ProcessingInstruction(void *ctx, const xmlChar *target,
2681                       const xmlChar *data)
2682 {
2683     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
2684     xmlNodePtr ret;
2685     xmlNodePtr parent;
2686 
2687     if (ctx == NULL) return;
2688     parent = ctxt-&gt;node;
2689 #ifdef DEBUG_SAX
2690     xmlGenericError(xmlGenericErrorContext,
2691         &quot;SAX.xmlSAX2ProcessingInstruction(%s, %s)\n&quot;, target, data);
2692 #endif
2693 
2694     ret = xmlNewDocPI(ctxt-&gt;myDoc, target, data);
2695     if (ret == NULL) return;
2696 
2697     if (ctxt-&gt;linenumbers) {
2698     if (ctxt-&gt;input != NULL) {
2699         if (ctxt-&gt;input-&gt;line &lt; 65535)
2700         ret-&gt;line = (short) ctxt-&gt;input-&gt;line;
2701         else
2702             ret-&gt;line = 65535;
2703     }
2704     }
2705     if (ctxt-&gt;inSubset == 1) {
2706     xmlAddChild((xmlNodePtr) ctxt-&gt;myDoc-&gt;intSubset, ret);
2707     return;
2708     } else if (ctxt-&gt;inSubset == 2) {
2709     xmlAddChild((xmlNodePtr) ctxt-&gt;myDoc-&gt;extSubset, ret);
2710     return;
2711     }
2712     if (parent == NULL) {
2713 #ifdef DEBUG_SAX_TREE
2714         xmlGenericError(xmlGenericErrorContext,
2715             &quot;Setting PI %s as root\n&quot;, target);
2716 #endif
2717         xmlAddChild((xmlNodePtr) ctxt-&gt;myDoc, (xmlNodePtr) ret);
2718     return;
2719     }
2720     if (parent-&gt;type == XML_ELEMENT_NODE) {
2721 #ifdef DEBUG_SAX_TREE
2722     xmlGenericError(xmlGenericErrorContext,
2723         &quot;adding PI %s child to %s\n&quot;, target, parent-&gt;name);
2724 #endif
2725     xmlAddChild(parent, ret);
2726     } else {
2727 #ifdef DEBUG_SAX_TREE
2728     xmlGenericError(xmlGenericErrorContext,
2729         &quot;adding PI %s sibling to &quot;, target);
2730     xmlDebugDumpOneNode(stderr, parent, 0);
2731 #endif
2732     xmlAddSibling(parent, ret);
2733     }
2734 }
2735 
2736 /**
2737  * xmlSAX2Comment:
2738  * @ctx: the user data (XML parser context)
2739  * @value:  the xmlSAX2Comment content
2740  *
2741  * A xmlSAX2Comment has been parsed.
2742  */
2743 void
2744 xmlSAX2Comment(void *ctx, const xmlChar *value)
2745 {
2746     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
2747     xmlNodePtr ret;
2748     xmlNodePtr parent;
2749 
2750     if (ctx == NULL) return;
2751     parent = ctxt-&gt;node;
2752 #ifdef DEBUG_SAX
2753     xmlGenericError(xmlGenericErrorContext, &quot;SAX.xmlSAX2Comment(%s)\n&quot;, value);
2754 #endif
2755     ret = xmlNewDocComment(ctxt-&gt;myDoc, value);
2756     if (ret == NULL) return;
2757     if (ctxt-&gt;linenumbers) {
2758     if (ctxt-&gt;input != NULL) {
2759         if (ctxt-&gt;input-&gt;line &lt; 65535)
2760         ret-&gt;line = (short) ctxt-&gt;input-&gt;line;
2761         else
2762             ret-&gt;line = 65535;
2763     }
2764     }
2765 
2766     if (ctxt-&gt;inSubset == 1) {
2767     xmlAddChild((xmlNodePtr) ctxt-&gt;myDoc-&gt;intSubset, ret);
2768     return;
2769     } else if (ctxt-&gt;inSubset == 2) {
2770     xmlAddChild((xmlNodePtr) ctxt-&gt;myDoc-&gt;extSubset, ret);
2771     return;
2772     }
2773     if (parent == NULL) {
2774 #ifdef DEBUG_SAX_TREE
2775         xmlGenericError(xmlGenericErrorContext,
2776             &quot;Setting xmlSAX2Comment as root\n&quot;);
2777 #endif
2778         xmlAddChild((xmlNodePtr) ctxt-&gt;myDoc, (xmlNodePtr) ret);
2779     return;
2780     }
2781     if (parent-&gt;type == XML_ELEMENT_NODE) {
2782 #ifdef DEBUG_SAX_TREE
2783     xmlGenericError(xmlGenericErrorContext,
2784         &quot;adding xmlSAX2Comment child to %s\n&quot;, parent-&gt;name);
2785 #endif
2786     xmlAddChild(parent, ret);
2787     } else {
2788 #ifdef DEBUG_SAX_TREE
2789     xmlGenericError(xmlGenericErrorContext,
2790         &quot;adding xmlSAX2Comment sibling to &quot;);
2791     xmlDebugDumpOneNode(stderr, parent, 0);
2792 #endif
2793     xmlAddSibling(parent, ret);
2794     }
2795 }
2796 
2797 /**
2798  * xmlSAX2CDataBlock:
2799  * @ctx: the user data (XML parser context)
2800  * @value:  The pcdata content
2801  * @len:  the block length
2802  *
2803  * called when a pcdata block has been parsed
2804  */
2805 void
2806 xmlSAX2CDataBlock(void *ctx, const xmlChar *value, int len)
2807 {
2808     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
2809     xmlNodePtr ret, lastChild;
2810 
2811     if (ctx == NULL) return;
2812 #ifdef DEBUG_SAX
2813     xmlGenericError(xmlGenericErrorContext,
2814         &quot;SAX.pcdata(%.10s, %d)\n&quot;, value, len);
2815 #endif
2816     lastChild = xmlGetLastChild(ctxt-&gt;node);
2817 #ifdef DEBUG_SAX_TREE
2818     xmlGenericError(xmlGenericErrorContext,
2819         &quot;add chars to %s \n&quot;, ctxt-&gt;node-&gt;name);
2820 #endif
2821     if ((lastChild != NULL) &amp;&amp;
2822         (lastChild-&gt;type == XML_CDATA_SECTION_NODE)) {
2823     xmlTextConcat(lastChild, value, len);
2824     } else {
2825     ret = xmlNewCDataBlock(ctxt-&gt;myDoc, value, len);
2826     if (xmlAddChild(ctxt-&gt;node, ret) == NULL)
2827         xmlFreeNode(ret);
2828     }
2829 }
2830 
2831 static int xmlSAX2DefaultVersionValue = 2;
2832 
2833 #ifdef LIBXML_SAX1_ENABLED
2834 /**
2835  * xmlSAXDefaultVersion:
2836  * @version:  the version, 1 or 2
2837  *
2838  * Set the default version of SAX used globally by the library.
2839  * By default, during initialization the default is set to 2.
2840  * Note that it is generally a better coding style to use
2841  * xmlSAXVersion() to set up the version explicitly for a given
2842  * parsing context.
2843  *
2844  * Returns the previous value in case of success and -1 in case of error.
2845  */
2846 int
2847 xmlSAXDefaultVersion(int version)
2848 {
2849     int ret = xmlSAX2DefaultVersionValue;
2850 
2851     if ((version != 1) &amp;&amp; (version != 2))
2852         return(-1);
2853     xmlSAX2DefaultVersionValue = version;
2854     return(ret);
2855 }
2856 #endif /* LIBXML_SAX1_ENABLED */
2857 
2858 /**
2859  * xmlSAXVersion:
2860  * @hdlr:  the SAX handler
2861  * @version:  the version, 1 or 2
2862  *
2863  * Initialize the default XML SAX handler according to the version
2864  *
2865  * Returns 0 in case of success and -1 in case of error.
2866  */
2867 int
2868 xmlSAXVersion(xmlSAXHandler *hdlr, int version)
2869 {
2870     if (hdlr == NULL) return(-1);
2871     if (version == 2) {
2872     hdlr-&gt;startElement = NULL;
2873     hdlr-&gt;endElement = NULL;
2874     hdlr-&gt;startElementNs = xmlSAX2StartElementNs;
2875     hdlr-&gt;endElementNs = xmlSAX2EndElementNs;
2876     hdlr-&gt;serror = NULL;
2877     hdlr-&gt;initialized = XML_SAX2_MAGIC;
2878 #ifdef LIBXML_SAX1_ENABLED
2879     } else if (version == 1) {
2880     hdlr-&gt;startElement = xmlSAX2StartElement;
2881     hdlr-&gt;endElement = xmlSAX2EndElement;
2882     hdlr-&gt;initialized = 1;
2883 #endif /* LIBXML_SAX1_ENABLED */
2884     } else
2885         return(-1);
2886     hdlr-&gt;internalSubset = xmlSAX2InternalSubset;
2887     hdlr-&gt;externalSubset = xmlSAX2ExternalSubset;
2888     hdlr-&gt;isStandalone = xmlSAX2IsStandalone;
2889     hdlr-&gt;hasInternalSubset = xmlSAX2HasInternalSubset;
2890     hdlr-&gt;hasExternalSubset = xmlSAX2HasExternalSubset;
2891     hdlr-&gt;resolveEntity = xmlSAX2ResolveEntity;
2892     hdlr-&gt;getEntity = xmlSAX2GetEntity;
2893     hdlr-&gt;getParameterEntity = xmlSAX2GetParameterEntity;
2894     hdlr-&gt;entityDecl = xmlSAX2EntityDecl;
2895     hdlr-&gt;attributeDecl = xmlSAX2AttributeDecl;
2896     hdlr-&gt;elementDecl = xmlSAX2ElementDecl;
2897     hdlr-&gt;notationDecl = xmlSAX2NotationDecl;
2898     hdlr-&gt;unparsedEntityDecl = xmlSAX2UnparsedEntityDecl;
2899     hdlr-&gt;setDocumentLocator = xmlSAX2SetDocumentLocator;
2900     hdlr-&gt;startDocument = xmlSAX2StartDocument;
2901     hdlr-&gt;endDocument = xmlSAX2EndDocument;
2902     hdlr-&gt;reference = xmlSAX2Reference;
2903     hdlr-&gt;characters = xmlSAX2Characters;
2904     hdlr-&gt;cdataBlock = xmlSAX2CDataBlock;
2905     hdlr-&gt;ignorableWhitespace = xmlSAX2Characters;
2906     hdlr-&gt;processingInstruction = xmlSAX2ProcessingInstruction;
2907     hdlr-&gt;comment = xmlSAX2Comment;
2908     hdlr-&gt;warning = xmlParserWarning;
2909     hdlr-&gt;error = xmlParserError;
2910     hdlr-&gt;fatalError = xmlParserError;
2911 
2912     return(0);
2913 }
2914 
2915 /**
2916  * xmlSAX2InitDefaultSAXHandler:
2917  * @hdlr:  the SAX handler
2918  * @warning:  flag if non-zero sets the handler warning procedure
2919  *
2920  * Initialize the default XML SAX2 handler
2921  */
2922 void
2923 xmlSAX2InitDefaultSAXHandler(xmlSAXHandler *hdlr, int warning)
2924 {
2925     if ((hdlr == NULL) || (hdlr-&gt;initialized != 0))
2926     return;
2927 
2928     xmlSAXVersion(hdlr, xmlSAX2DefaultVersionValue);
2929     if (warning == 0)
2930     hdlr-&gt;warning = NULL;
2931     else
2932     hdlr-&gt;warning = xmlParserWarning;
2933 }
2934 
2935 /**
2936  * xmlDefaultSAXHandlerInit:
2937  *
2938  * Initialize the default SAX2 handler
2939  */
2940 void
2941 xmlDefaultSAXHandlerInit(void)
2942 {
2943 #ifdef LIBXML_SAX1_ENABLED
2944     xmlSAXVersion((xmlSAXHandlerPtr) &amp;xmlDefaultSAXHandler, 1);
2945 #endif /* LIBXML_SAX1_ENABLED */
2946 }
2947 
2948 #ifdef LIBXML_HTML_ENABLED
2949 
2950 /**
2951  * xmlSAX2InitHtmlDefaultSAXHandler:
2952  * @hdlr:  the SAX handler
2953  *
2954  * Initialize the default HTML SAX2 handler
2955  */
2956 void
2957 xmlSAX2InitHtmlDefaultSAXHandler(xmlSAXHandler *hdlr)
2958 {
2959     if ((hdlr == NULL) || (hdlr-&gt;initialized != 0))
2960     return;
2961 
2962     hdlr-&gt;internalSubset = xmlSAX2InternalSubset;
2963     hdlr-&gt;externalSubset = NULL;
2964     hdlr-&gt;isStandalone = NULL;
2965     hdlr-&gt;hasInternalSubset = NULL;
2966     hdlr-&gt;hasExternalSubset = NULL;
2967     hdlr-&gt;resolveEntity = NULL;
2968     hdlr-&gt;getEntity = xmlSAX2GetEntity;
2969     hdlr-&gt;getParameterEntity = NULL;
2970     hdlr-&gt;entityDecl = NULL;
2971     hdlr-&gt;attributeDecl = NULL;
2972     hdlr-&gt;elementDecl = NULL;
2973     hdlr-&gt;notationDecl = NULL;
2974     hdlr-&gt;unparsedEntityDecl = NULL;
2975     hdlr-&gt;setDocumentLocator = xmlSAX2SetDocumentLocator;
2976     hdlr-&gt;startDocument = xmlSAX2StartDocument;
2977     hdlr-&gt;endDocument = xmlSAX2EndDocument;
2978     hdlr-&gt;startElement = xmlSAX2StartElement;
2979     hdlr-&gt;endElement = xmlSAX2EndElement;
2980     hdlr-&gt;reference = NULL;
2981     hdlr-&gt;characters = xmlSAX2Characters;
2982     hdlr-&gt;cdataBlock = xmlSAX2CDataBlock;
2983     hdlr-&gt;ignorableWhitespace = xmlSAX2IgnorableWhitespace;
2984     hdlr-&gt;processingInstruction = xmlSAX2ProcessingInstruction;
2985     hdlr-&gt;comment = xmlSAX2Comment;
2986     hdlr-&gt;warning = xmlParserWarning;
2987     hdlr-&gt;error = xmlParserError;
2988     hdlr-&gt;fatalError = xmlParserError;
2989 
2990     hdlr-&gt;initialized = 1;
2991 }
2992 
2993 /**
2994  * htmlDefaultSAXHandlerInit:
2995  *
2996  * Initialize the default SAX handler
2997  */
2998 void
2999 htmlDefaultSAXHandlerInit(void)
3000 {
3001     xmlSAX2InitHtmlDefaultSAXHandler((xmlSAXHandlerPtr) &amp;htmlDefaultSAXHandler);
3002 }
3003 
3004 #endif /* LIBXML_HTML_ENABLED */
3005 
3006 #ifdef LIBXML_DOCB_ENABLED
3007 
3008 /**
3009  * xmlSAX2InitDocbDefaultSAXHandler:
3010  * @hdlr:  the SAX handler
3011  *
3012  * Initialize the default DocBook SAX2 handler
3013  */
3014 void
3015 xmlSAX2InitDocbDefaultSAXHandler(xmlSAXHandler *hdlr)
3016 {
3017     if ((hdlr == NULL) || (hdlr-&gt;initialized != 0))
3018     return;
3019 
3020     hdlr-&gt;internalSubset = xmlSAX2InternalSubset;
3021     hdlr-&gt;externalSubset = NULL;
3022     hdlr-&gt;isStandalone = xmlSAX2IsStandalone;
3023     hdlr-&gt;hasInternalSubset = xmlSAX2HasInternalSubset;
3024     hdlr-&gt;hasExternalSubset = xmlSAX2HasExternalSubset;
3025     hdlr-&gt;resolveEntity = xmlSAX2ResolveEntity;
3026     hdlr-&gt;getEntity = xmlSAX2GetEntity;
3027     hdlr-&gt;getParameterEntity = NULL;
3028     hdlr-&gt;entityDecl = xmlSAX2EntityDecl;
3029     hdlr-&gt;attributeDecl = NULL;
3030     hdlr-&gt;elementDecl = NULL;
3031     hdlr-&gt;notationDecl = NULL;
3032     hdlr-&gt;unparsedEntityDecl = NULL;
3033     hdlr-&gt;setDocumentLocator = xmlSAX2SetDocumentLocator;
3034     hdlr-&gt;startDocument = xmlSAX2StartDocument;
3035     hdlr-&gt;endDocument = xmlSAX2EndDocument;
3036     hdlr-&gt;startElement = xmlSAX2StartElement;
3037     hdlr-&gt;endElement = xmlSAX2EndElement;
3038     hdlr-&gt;reference = xmlSAX2Reference;
3039     hdlr-&gt;characters = xmlSAX2Characters;
3040     hdlr-&gt;cdataBlock = NULL;
3041     hdlr-&gt;ignorableWhitespace = xmlSAX2IgnorableWhitespace;
3042     hdlr-&gt;processingInstruction = NULL;
3043     hdlr-&gt;comment = xmlSAX2Comment;
3044     hdlr-&gt;warning = xmlParserWarning;
3045     hdlr-&gt;error = xmlParserError;
3046     hdlr-&gt;fatalError = xmlParserError;
3047 
3048     hdlr-&gt;initialized = 1;
3049 }
3050 
3051 /**
3052  * docbDefaultSAXHandlerInit:
3053  *
3054  * Initialize the default SAX handler
3055  */
3056 void
3057 docbDefaultSAXHandlerInit(void)
3058 {
3059     xmlSAX2InitDocbDefaultSAXHandler((xmlSAXHandlerPtr) &amp;docbDefaultSAXHandler);
3060 }
3061 
3062 #endif /* LIBXML_DOCB_ENABLED */
3063 #define bottom_SAX2
3064 #include &quot;elfgcchack.h&quot;
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
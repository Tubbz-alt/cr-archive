<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/parser.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 /*
    2  * parser.c : an XML 1.0 parser, namespaces and validity support are mostly
    3  *            implemented on top of the SAX interfaces
    4  *
    5  * References:
    6  *   The XML specification:
    7  *     http://www.w3.org/TR/REC-xml
    8  *   Original 1.0 version:
    9  *     http://www.w3.org/TR/1998/REC-xml-19980210
   10  *   XML second edition working draft
   11  *     http://www.w3.org/TR/2000/WD-xml-2e-20000814
   12  *
   13  * Okay this is a big file, the parser core is around 7000 lines, then it
   14  * is followed by the progressive parser top routines, then the various
   15  * high level APIs to call the parser and a few miscellaneous functions.
   16  * A number of helper functions and deprecated ones have been moved to
   17  * parserInternals.c to reduce this file size.
   18  * As much as possible the functions are associated with their relative
   19  * production in the XML specification. A few productions defining the
   20  * different ranges of character are actually implanted either in
   21  * parserInternals.h or parserInternals.c
   22  * The DOM tree build is realized from the default SAX callbacks in
   23  * the module SAX.c.
   24  * The routines doing the validation checks are in valid.c and called either
   25  * from the SAX callbacks or as standalone functions using a preparsed
   26  * document.
   27  *
   28  * See Copyright for the status of this software.
   29  *
   30  * daniel@veillard.com
   31  */
   32 
   33 /* To avoid EBCDIC trouble when parsing on zOS */
   34 #if defined(__MVS__)
   35 #pragma convert(&quot;ISO8859-1&quot;)
   36 #endif
   37 
   38 #define IN_LIBXML
   39 #include &quot;libxml.h&quot;
   40 
   41 #if defined(_WIN32) &amp;&amp; !defined (__CYGWIN__)
   42 #define XML_DIR_SEP &#39;\\&#39;
   43 #else
   44 #define XML_DIR_SEP &#39;/&#39;
   45 #endif
   46 
   47 #include &lt;stdlib.h&gt;
   48 #include &lt;limits.h&gt;
   49 #include &lt;string.h&gt;
   50 #include &lt;stdarg.h&gt;
   51 #include &lt;stddef.h&gt;
   52 #include &lt;libxml/xmlmemory.h&gt;
   53 #include &lt;libxml/threads.h&gt;
   54 #include &lt;libxml/globals.h&gt;
   55 #include &lt;libxml/tree.h&gt;
   56 #include &lt;libxml/parser.h&gt;
   57 #include &lt;libxml/parserInternals.h&gt;
   58 #include &lt;libxml/valid.h&gt;
   59 #include &lt;libxml/entities.h&gt;
   60 #include &lt;libxml/xmlerror.h&gt;
   61 #include &lt;libxml/encoding.h&gt;
   62 #include &lt;libxml/xmlIO.h&gt;
   63 #include &lt;libxml/uri.h&gt;
   64 #ifdef LIBXML_CATALOG_ENABLED
   65 #include &lt;libxml/catalog.h&gt;
   66 #endif
   67 #ifdef LIBXML_SCHEMAS_ENABLED
   68 #include &lt;libxml/xmlschemastypes.h&gt;
   69 #include &lt;libxml/relaxng.h&gt;
   70 #endif
   71 #ifdef HAVE_CTYPE_H
   72 #include &lt;ctype.h&gt;
   73 #endif
   74 #ifdef HAVE_STDLIB_H
   75 #include &lt;stdlib.h&gt;
   76 #endif
   77 #ifdef HAVE_SYS_STAT_H
   78 #include &lt;sys/stat.h&gt;
   79 #endif
   80 #ifdef HAVE_FCNTL_H
   81 #include &lt;fcntl.h&gt;
   82 #endif
   83 #ifdef HAVE_UNISTD_H
   84 #include &lt;unistd.h&gt;
   85 #endif
   86 
   87 #include &quot;buf.h&quot;
   88 #include &quot;enc.h&quot;
   89 
   90 static void
   91 xmlFatalErr(xmlParserCtxtPtr ctxt, xmlParserErrors error, const char *info);
   92 
   93 static xmlParserCtxtPtr
   94 xmlCreateEntityParserCtxtInternal(const xmlChar *URL, const xmlChar *ID,
   95                       const xmlChar *base, xmlParserCtxtPtr pctx);
   96 
   97 static void xmlHaltParser(xmlParserCtxtPtr ctxt);
   98 
<a name="1" id="anc1"></a><span class="line-added">   99 static int</span>
<span class="line-added">  100 xmlParseElementStart(xmlParserCtxtPtr ctxt);</span>
<span class="line-added">  101 </span>
<span class="line-added">  102 static void</span>
<span class="line-added">  103 xmlParseElementEnd(xmlParserCtxtPtr ctxt);</span>
<span class="line-added">  104 </span>
  105 /************************************************************************
  106  *                                  *
  107  *  Arbitrary limits set in the parser. See XML_PARSE_HUGE      *
  108  *                                  *
  109  ************************************************************************/
  110 
  111 #define XML_PARSER_BIG_ENTITY 1000
  112 #define XML_PARSER_LOT_ENTITY 5000
  113 
  114 /*
  115  * XML_PARSER_NON_LINEAR is the threshold where the ratio of parsed entity
  116  *    replacement over the size in byte of the input indicates that you have
<a name="2" id="anc2"></a><span class="line-modified">  117  *    and exponential behaviour. A value of 10 correspond to at least 3 entity</span>
  118  *    replacement per byte of input.
  119  */
  120 #define XML_PARSER_NON_LINEAR 10
  121 
  122 /*
  123  * xmlParserEntityCheck
  124  *
  125  * Function to check non-linear entity expansion behaviour
  126  * This is here to detect and stop exponential linear entity expansion
  127  * This is not a limitation of the parser but a safety
  128  * boundary feature. It can be disabled with the XML_PARSE_HUGE
  129  * parser option.
  130  */
  131 static int
  132 xmlParserEntityCheck(xmlParserCtxtPtr ctxt, size_t size,
  133                      xmlEntityPtr ent, size_t replacement)
  134 {
  135     size_t consumed = 0;
  136 
  137     if ((ctxt == NULL) || (ctxt-&gt;options &amp; XML_PARSE_HUGE))
  138         return (0);
  139     if (ctxt-&gt;lastError.code == XML_ERR_ENTITY_LOOP)
  140         return (1);
  141 
  142     /*
  143      * This may look absurd but is needed to detect
  144      * entities problems
  145      */
  146     if ((ent != NULL) &amp;&amp; (ent-&gt;etype != XML_INTERNAL_PREDEFINED_ENTITY) &amp;&amp;
  147     (ent-&gt;content != NULL) &amp;&amp; (ent-&gt;checked == 0) &amp;&amp;
  148     (ctxt-&gt;errNo != XML_ERR_ENTITY_LOOP)) {
<a name="3" id="anc3"></a><span class="line-modified">  149     unsigned long oldnbent = ctxt-&gt;nbentities, diff;</span>
  150     xmlChar *rep;
  151 
  152     ent-&gt;checked = 1;
  153 
  154         ++ctxt-&gt;depth;
  155     rep = xmlStringDecodeEntities(ctxt, ent-&gt;content,
  156                   XML_SUBSTITUTE_REF, 0, 0, 0);
  157         --ctxt-&gt;depth;
  158     if ((rep == NULL) || (ctxt-&gt;errNo == XML_ERR_ENTITY_LOOP)) {
  159         ent-&gt;content[0] = 0;
  160     }
  161 
<a name="4" id="anc4"></a><span class="line-modified">  162         diff = ctxt-&gt;nbentities - oldnbent + 1;</span>
<span class="line-added">  163         if (diff &gt; INT_MAX / 2)</span>
<span class="line-added">  164             diff = INT_MAX / 2;</span>
<span class="line-added">  165     ent-&gt;checked = diff * 2;</span>
  166     if (rep != NULL) {
  167         if (xmlStrchr(rep, &#39;&lt;&#39;))
  168         ent-&gt;checked |= 1;
  169         xmlFree(rep);
  170         rep = NULL;
  171     }
  172     }
  173     if (replacement != 0) {
  174     if (replacement &lt; XML_MAX_TEXT_LENGTH)
  175         return(0);
  176 
  177         /*
  178      * If the volume of entity copy reaches 10 times the
  179      * amount of parsed data and over the large text threshold
  180      * then that&#39;s very likely to be an abuse.
  181      */
  182         if (ctxt-&gt;input != NULL) {
  183         consumed = ctxt-&gt;input-&gt;consumed +
  184                    (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
  185     }
  186         consumed += ctxt-&gt;sizeentities;
  187 
  188         if (replacement &lt; XML_PARSER_NON_LINEAR * consumed)
  189         return(0);
  190     } else if (size != 0) {
  191         /*
  192          * Do the check based on the replacement size of the entity
  193          */
  194         if (size &lt; XML_PARSER_BIG_ENTITY)
  195         return(0);
  196 
  197         /*
  198          * A limit on the amount of text data reasonably used
  199          */
  200         if (ctxt-&gt;input != NULL) {
  201             consumed = ctxt-&gt;input-&gt;consumed +
  202                 (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
  203         }
  204         consumed += ctxt-&gt;sizeentities;
  205 
  206         if ((size &lt; XML_PARSER_NON_LINEAR * consumed) &amp;&amp;
  207         (ctxt-&gt;nbentities * 3 &lt; XML_PARSER_NON_LINEAR * consumed))
  208             return (0);
  209     } else if (ent != NULL) {
  210         /*
  211          * use the number of parsed entities in the replacement
  212          */
  213         size = ent-&gt;checked / 2;
  214 
  215         /*
  216          * The amount of data parsed counting entities size only once
  217          */
  218         if (ctxt-&gt;input != NULL) {
  219             consumed = ctxt-&gt;input-&gt;consumed +
  220                 (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
  221         }
  222         consumed += ctxt-&gt;sizeentities;
  223 
  224         /*
  225          * Check the density of entities for the amount of data
  226      * knowing an entity reference will take at least 3 bytes
  227          */
  228         if (size * 3 &lt; consumed * XML_PARSER_NON_LINEAR)
  229             return (0);
  230     } else {
  231         /*
  232          * strange we got no data for checking
  233          */
  234     if (((ctxt-&gt;lastError.code != XML_ERR_UNDECLARED_ENTITY) &amp;&amp;
  235          (ctxt-&gt;lastError.code != XML_WAR_UNDECLARED_ENTITY)) ||
  236         (ctxt-&gt;nbentities &lt;= 10000))
  237         return (0);
  238     }
  239     xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
  240     return (1);
  241 }
  242 
  243 /**
  244  * xmlParserMaxDepth:
  245  *
  246  * arbitrary depth limit for the XML documents that we allow to
  247  * process. This is not a limitation of the parser but a safety
  248  * boundary feature. It can be disabled with the XML_PARSE_HUGE
  249  * parser option.
  250  */
  251 unsigned int xmlParserMaxDepth = 256;
  252 
  253 
  254 
  255 #define SAX2 1
  256 #define XML_PARSER_BIG_BUFFER_SIZE 300
  257 #define XML_PARSER_BUFFER_SIZE 100
  258 #define SAX_COMPAT_MODE BAD_CAST &quot;SAX compatibility mode document&quot;
  259 
  260 /**
  261  * XML_PARSER_CHUNK_SIZE
  262  *
  263  * When calling GROW that&#39;s the minimal amount of data
  264  * the parser expected to have received. It is not a hard
  265  * limit but an optimization when reading strings like Names
  266  * It is not strictly needed as long as inputs available characters
  267  * are followed by 0, which should be provided by the I/O level
  268  */
  269 #define XML_PARSER_CHUNK_SIZE 100
  270 
  271 /*
  272  * List of XML prefixed PI allowed by W3C specs
  273  */
  274 
  275 static const char *xmlW3CPIs[] = {
  276     &quot;xml-stylesheet&quot;,
  277     &quot;xml-model&quot;,
  278     NULL
  279 };
  280 
  281 
  282 /* DEPR void xmlParserHandleReference(xmlParserCtxtPtr ctxt); */
  283 static xmlEntityPtr xmlParseStringPEReference(xmlParserCtxtPtr ctxt,
  284                                               const xmlChar **str);
  285 
  286 static xmlParserErrors
  287 xmlParseExternalEntityPrivate(xmlDocPtr doc, xmlParserCtxtPtr oldctxt,
  288                   xmlSAXHandlerPtr sax,
  289               void *user_data, int depth, const xmlChar *URL,
  290               const xmlChar *ID, xmlNodePtr *list);
  291 
  292 static int
  293 xmlCtxtUseOptionsInternal(xmlParserCtxtPtr ctxt, int options,
  294                           const char *encoding);
  295 #ifdef LIBXML_LEGACY_ENABLED
  296 static void
  297 xmlAddEntityReference(xmlEntityPtr ent, xmlNodePtr firstNode,
  298                       xmlNodePtr lastNode);
  299 #endif /* LIBXML_LEGACY_ENABLED */
  300 
  301 static xmlParserErrors
  302 xmlParseBalancedChunkMemoryInternal(xmlParserCtxtPtr oldctxt,
  303               const xmlChar *string, void *user_data, xmlNodePtr *lst);
  304 
  305 static int
  306 xmlLoadEntityContent(xmlParserCtxtPtr ctxt, xmlEntityPtr entity);
  307 
  308 /************************************************************************
  309  *                                  *
  310  *      Some factorized error routines              *
  311  *                                  *
  312  ************************************************************************/
  313 
  314 /**
  315  * xmlErrAttributeDup:
  316  * @ctxt:  an XML parser context
  317  * @prefix:  the attribute prefix
  318  * @localname:  the attribute localname
  319  *
  320  * Handle a redefinition of attribute error
  321  */
  322 static void
  323 xmlErrAttributeDup(xmlParserCtxtPtr ctxt, const xmlChar * prefix,
  324                    const xmlChar * localname)
  325 {
  326     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  327         (ctxt-&gt;instate == XML_PARSER_EOF))
  328     return;
  329     if (ctxt != NULL)
  330     ctxt-&gt;errNo = XML_ERR_ATTRIBUTE_REDEFINED;
  331 
  332     if (prefix == NULL)
  333         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,
  334                         XML_ERR_ATTRIBUTE_REDEFINED, XML_ERR_FATAL, NULL, 0,
  335                         (const char *) localname, NULL, NULL, 0, 0,
  336                         &quot;Attribute %s redefined\n&quot;, localname);
  337     else
  338         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,
  339                         XML_ERR_ATTRIBUTE_REDEFINED, XML_ERR_FATAL, NULL, 0,
  340                         (const char *) prefix, (const char *) localname,
  341                         NULL, 0, 0, &quot;Attribute %s:%s redefined\n&quot;, prefix,
  342                         localname);
  343     if (ctxt != NULL) {
  344     ctxt-&gt;wellFormed = 0;
  345     if (ctxt-&gt;recovery == 0)
  346         ctxt-&gt;disableSAX = 1;
  347     }
  348 }
  349 
  350 /**
  351  * xmlFatalErr:
  352  * @ctxt:  an XML parser context
  353  * @error:  the error number
  354  * @extra:  extra information string
  355  *
  356  * Handle a fatal parser error, i.e. violating Well-Formedness constraints
  357  */
  358 static void
  359 xmlFatalErr(xmlParserCtxtPtr ctxt, xmlParserErrors error, const char *info)
  360 {
  361     const char *errmsg;
  362 
  363     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  364         (ctxt-&gt;instate == XML_PARSER_EOF))
  365     return;
  366     switch (error) {
  367         case XML_ERR_INVALID_HEX_CHARREF:
  368             errmsg = &quot;CharRef: invalid hexadecimal value&quot;;
  369             break;
  370         case XML_ERR_INVALID_DEC_CHARREF:
  371             errmsg = &quot;CharRef: invalid decimal value&quot;;
  372             break;
  373         case XML_ERR_INVALID_CHARREF:
  374             errmsg = &quot;CharRef: invalid value&quot;;
  375             break;
  376         case XML_ERR_INTERNAL_ERROR:
  377             errmsg = &quot;internal error&quot;;
  378             break;
  379         case XML_ERR_PEREF_AT_EOF:
  380             errmsg = &quot;PEReference at end of document&quot;;
  381             break;
  382         case XML_ERR_PEREF_IN_PROLOG:
  383             errmsg = &quot;PEReference in prolog&quot;;
  384             break;
  385         case XML_ERR_PEREF_IN_EPILOG:
  386             errmsg = &quot;PEReference in epilog&quot;;
  387             break;
  388         case XML_ERR_PEREF_NO_NAME:
  389             errmsg = &quot;PEReference: no name&quot;;
  390             break;
  391         case XML_ERR_PEREF_SEMICOL_MISSING:
  392             errmsg = &quot;PEReference: expecting &#39;;&#39;&quot;;
  393             break;
  394         case XML_ERR_ENTITY_LOOP:
  395             errmsg = &quot;Detected an entity reference loop&quot;;
  396             break;
  397         case XML_ERR_ENTITY_NOT_STARTED:
  398             errmsg = &quot;EntityValue: \&quot; or &#39; expected&quot;;
  399             break;
  400         case XML_ERR_ENTITY_PE_INTERNAL:
  401             errmsg = &quot;PEReferences forbidden in internal subset&quot;;
  402             break;
  403         case XML_ERR_ENTITY_NOT_FINISHED:
  404             errmsg = &quot;EntityValue: \&quot; or &#39; expected&quot;;
  405             break;
  406         case XML_ERR_ATTRIBUTE_NOT_STARTED:
  407             errmsg = &quot;AttValue: \&quot; or &#39; expected&quot;;
  408             break;
  409         case XML_ERR_LT_IN_ATTRIBUTE:
  410             errmsg = &quot;Unescaped &#39;&lt;&#39; not allowed in attributes values&quot;;
  411             break;
  412         case XML_ERR_LITERAL_NOT_STARTED:
  413             errmsg = &quot;SystemLiteral \&quot; or &#39; expected&quot;;
  414             break;
  415         case XML_ERR_LITERAL_NOT_FINISHED:
  416             errmsg = &quot;Unfinished System or Public ID \&quot; or &#39; expected&quot;;
  417             break;
  418         case XML_ERR_MISPLACED_CDATA_END:
  419             errmsg = &quot;Sequence &#39;]]&gt;&#39; not allowed in content&quot;;
  420             break;
  421         case XML_ERR_URI_REQUIRED:
  422             errmsg = &quot;SYSTEM or PUBLIC, the URI is missing&quot;;
  423             break;
  424         case XML_ERR_PUBID_REQUIRED:
  425             errmsg = &quot;PUBLIC, the Public Identifier is missing&quot;;
  426             break;
  427         case XML_ERR_HYPHEN_IN_COMMENT:
  428             errmsg = &quot;Comment must not contain &#39;--&#39; (double-hyphen)&quot;;
  429             break;
  430         case XML_ERR_PI_NOT_STARTED:
  431             errmsg = &quot;xmlParsePI : no target name&quot;;
  432             break;
  433         case XML_ERR_RESERVED_XML_NAME:
  434             errmsg = &quot;Invalid PI name&quot;;
  435             break;
  436         case XML_ERR_NOTATION_NOT_STARTED:
  437             errmsg = &quot;NOTATION: Name expected here&quot;;
  438             break;
  439         case XML_ERR_NOTATION_NOT_FINISHED:
  440             errmsg = &quot;&#39;&gt;&#39; required to close NOTATION declaration&quot;;
  441             break;
  442         case XML_ERR_VALUE_REQUIRED:
  443             errmsg = &quot;Entity value required&quot;;
  444             break;
  445         case XML_ERR_URI_FRAGMENT:
  446             errmsg = &quot;Fragment not allowed&quot;;
  447             break;
  448         case XML_ERR_ATTLIST_NOT_STARTED:
  449             errmsg = &quot;&#39;(&#39; required to start ATTLIST enumeration&quot;;
  450             break;
  451         case XML_ERR_NMTOKEN_REQUIRED:
  452             errmsg = &quot;NmToken expected in ATTLIST enumeration&quot;;
  453             break;
  454         case XML_ERR_ATTLIST_NOT_FINISHED:
  455             errmsg = &quot;&#39;)&#39; required to finish ATTLIST enumeration&quot;;
  456             break;
  457         case XML_ERR_MIXED_NOT_STARTED:
  458             errmsg = &quot;MixedContentDecl : &#39;|&#39; or &#39;)*&#39; expected&quot;;
  459             break;
  460         case XML_ERR_PCDATA_REQUIRED:
  461             errmsg = &quot;MixedContentDecl : &#39;#PCDATA&#39; expected&quot;;
  462             break;
  463         case XML_ERR_ELEMCONTENT_NOT_STARTED:
  464             errmsg = &quot;ContentDecl : Name or &#39;(&#39; expected&quot;;
  465             break;
  466         case XML_ERR_ELEMCONTENT_NOT_FINISHED:
  467             errmsg = &quot;ContentDecl : &#39;,&#39; &#39;|&#39; or &#39;)&#39; expected&quot;;
  468             break;
  469         case XML_ERR_PEREF_IN_INT_SUBSET:
  470             errmsg =
  471                 &quot;PEReference: forbidden within markup decl in internal subset&quot;;
  472             break;
  473         case XML_ERR_GT_REQUIRED:
  474             errmsg = &quot;expected &#39;&gt;&#39;&quot;;
  475             break;
  476         case XML_ERR_CONDSEC_INVALID:
  477             errmsg = &quot;XML conditional section &#39;[&#39; expected&quot;;
  478             break;
  479         case XML_ERR_EXT_SUBSET_NOT_FINISHED:
  480             errmsg = &quot;Content error in the external subset&quot;;
  481             break;
  482         case XML_ERR_CONDSEC_INVALID_KEYWORD:
  483             errmsg =
  484                 &quot;conditional section INCLUDE or IGNORE keyword expected&quot;;
  485             break;
  486         case XML_ERR_CONDSEC_NOT_FINISHED:
  487             errmsg = &quot;XML conditional section not closed&quot;;
  488             break;
  489         case XML_ERR_XMLDECL_NOT_STARTED:
  490             errmsg = &quot;Text declaration &#39;&lt;?xml&#39; required&quot;;
  491             break;
  492         case XML_ERR_XMLDECL_NOT_FINISHED:
  493             errmsg = &quot;parsing XML declaration: &#39;?&gt;&#39; expected&quot;;
  494             break;
  495         case XML_ERR_EXT_ENTITY_STANDALONE:
  496             errmsg = &quot;external parsed entities cannot be standalone&quot;;
  497             break;
  498         case XML_ERR_ENTITYREF_SEMICOL_MISSING:
  499             errmsg = &quot;EntityRef: expecting &#39;;&#39;&quot;;
  500             break;
  501         case XML_ERR_DOCTYPE_NOT_FINISHED:
  502             errmsg = &quot;DOCTYPE improperly terminated&quot;;
  503             break;
  504         case XML_ERR_LTSLASH_REQUIRED:
  505             errmsg = &quot;EndTag: &#39;&lt;/&#39; not found&quot;;
  506             break;
  507         case XML_ERR_EQUAL_REQUIRED:
  508             errmsg = &quot;expected &#39;=&#39;&quot;;
  509             break;
  510         case XML_ERR_STRING_NOT_CLOSED:
  511             errmsg = &quot;String not closed expecting \&quot; or &#39;&quot;;
  512             break;
  513         case XML_ERR_STRING_NOT_STARTED:
  514             errmsg = &quot;String not started expecting &#39; or \&quot;&quot;;
  515             break;
  516         case XML_ERR_ENCODING_NAME:
  517             errmsg = &quot;Invalid XML encoding name&quot;;
  518             break;
  519         case XML_ERR_STANDALONE_VALUE:
  520             errmsg = &quot;standalone accepts only &#39;yes&#39; or &#39;no&#39;&quot;;
  521             break;
  522         case XML_ERR_DOCUMENT_EMPTY:
  523             errmsg = &quot;Document is empty&quot;;
  524             break;
  525         case XML_ERR_DOCUMENT_END:
  526             errmsg = &quot;Extra content at the end of the document&quot;;
  527             break;
  528         case XML_ERR_NOT_WELL_BALANCED:
  529             errmsg = &quot;chunk is not well balanced&quot;;
  530             break;
  531         case XML_ERR_EXTRA_CONTENT:
  532             errmsg = &quot;extra content at the end of well balanced chunk&quot;;
  533             break;
  534         case XML_ERR_VERSION_MISSING:
  535             errmsg = &quot;Malformed declaration expecting version&quot;;
  536             break;
  537         case XML_ERR_NAME_TOO_LONG:
  538             errmsg = &quot;Name too long use XML_PARSE_HUGE option&quot;;
  539             break;
  540 #if 0
  541         case:
  542             errmsg = &quot;&quot;;
  543             break;
  544 #endif
  545         default:
  546             errmsg = &quot;Unregistered error message&quot;;
  547     }
  548     if (ctxt != NULL)
  549     ctxt-&gt;errNo = error;
  550     if (info == NULL) {
  551         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
  552                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, &quot;%s\n&quot;,
  553                         errmsg);
  554     } else {
  555         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
  556                         XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, &quot;%s: %s\n&quot;,
  557                         errmsg, info);
  558     }
  559     if (ctxt != NULL) {
  560     ctxt-&gt;wellFormed = 0;
  561     if (ctxt-&gt;recovery == 0)
  562         ctxt-&gt;disableSAX = 1;
  563     }
  564 }
  565 
  566 /**
  567  * xmlFatalErrMsg:
  568  * @ctxt:  an XML parser context
  569  * @error:  the error number
  570  * @msg:  the error message
  571  *
  572  * Handle a fatal parser error, i.e. violating Well-Formedness constraints
  573  */
  574 static void LIBXML_ATTR_FORMAT(3,0)
  575 xmlFatalErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
  576                const char *msg)
  577 {
  578     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  579         (ctxt-&gt;instate == XML_PARSER_EOF))
  580     return;
  581     if (ctxt != NULL)
  582     ctxt-&gt;errNo = error;
  583     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
  584                     XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, &quot;%s&quot;, msg);
  585     if (ctxt != NULL) {
  586     ctxt-&gt;wellFormed = 0;
  587     if (ctxt-&gt;recovery == 0)
  588         ctxt-&gt;disableSAX = 1;
  589     }
  590 }
  591 
  592 /**
  593  * xmlWarningMsg:
  594  * @ctxt:  an XML parser context
  595  * @error:  the error number
  596  * @msg:  the error message
  597  * @str1:  extra data
  598  * @str2:  extra data
  599  *
  600  * Handle a warning.
  601  */
  602 static void LIBXML_ATTR_FORMAT(3,0)
  603 xmlWarningMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
  604               const char *msg, const xmlChar *str1, const xmlChar *str2)
  605 {
  606     xmlStructuredErrorFunc schannel = NULL;
  607 
  608     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  609         (ctxt-&gt;instate == XML_PARSER_EOF))
  610     return;
  611     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;sax != NULL) &amp;&amp;
  612         (ctxt-&gt;sax-&gt;initialized == XML_SAX2_MAGIC))
  613         schannel = ctxt-&gt;sax-&gt;serror;
  614     if (ctxt != NULL) {
  615         __xmlRaiseError(schannel,
  616                     (ctxt-&gt;sax) ? ctxt-&gt;sax-&gt;warning : NULL,
  617                     ctxt-&gt;userData,
  618                     ctxt, NULL, XML_FROM_PARSER, error,
  619                     XML_ERR_WARNING, NULL, 0,
  620             (const char *) str1, (const char *) str2, NULL, 0, 0,
  621             msg, (const char *) str1, (const char *) str2);
  622     } else {
  623         __xmlRaiseError(schannel, NULL, NULL,
  624                     ctxt, NULL, XML_FROM_PARSER, error,
  625                     XML_ERR_WARNING, NULL, 0,
  626             (const char *) str1, (const char *) str2, NULL, 0, 0,
  627             msg, (const char *) str1, (const char *) str2);
  628     }
  629 }
  630 
  631 /**
  632  * xmlValidityError:
  633  * @ctxt:  an XML parser context
  634  * @error:  the error number
  635  * @msg:  the error message
  636  * @str1:  extra data
  637  *
  638  * Handle a validity error.
  639  */
  640 static void LIBXML_ATTR_FORMAT(3,0)
  641 xmlValidityError(xmlParserCtxtPtr ctxt, xmlParserErrors error,
  642               const char *msg, const xmlChar *str1, const xmlChar *str2)
  643 {
  644     xmlStructuredErrorFunc schannel = NULL;
  645 
  646     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  647         (ctxt-&gt;instate == XML_PARSER_EOF))
  648     return;
  649     if (ctxt != NULL) {
  650     ctxt-&gt;errNo = error;
  651     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;initialized == XML_SAX2_MAGIC))
  652         schannel = ctxt-&gt;sax-&gt;serror;
  653     }
  654     if (ctxt != NULL) {
  655         __xmlRaiseError(schannel,
  656                     ctxt-&gt;vctxt.error, ctxt-&gt;vctxt.userData,
  657                     ctxt, NULL, XML_FROM_DTD, error,
  658                     XML_ERR_ERROR, NULL, 0, (const char *) str1,
  659             (const char *) str2, NULL, 0, 0,
  660             msg, (const char *) str1, (const char *) str2);
  661     ctxt-&gt;valid = 0;
  662     } else {
  663         __xmlRaiseError(schannel, NULL, NULL,
  664                     ctxt, NULL, XML_FROM_DTD, error,
  665                     XML_ERR_ERROR, NULL, 0, (const char *) str1,
  666             (const char *) str2, NULL, 0, 0,
  667             msg, (const char *) str1, (const char *) str2);
  668     }
  669 }
  670 
  671 /**
  672  * xmlFatalErrMsgInt:
  673  * @ctxt:  an XML parser context
  674  * @error:  the error number
  675  * @msg:  the error message
  676  * @val:  an integer value
  677  *
  678  * Handle a fatal parser error, i.e. violating Well-Formedness constraints
  679  */
  680 static void LIBXML_ATTR_FORMAT(3,0)
  681 xmlFatalErrMsgInt(xmlParserCtxtPtr ctxt, xmlParserErrors error,
  682                   const char *msg, int val)
  683 {
  684     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  685         (ctxt-&gt;instate == XML_PARSER_EOF))
  686     return;
  687     if (ctxt != NULL)
  688     ctxt-&gt;errNo = error;
  689     __xmlRaiseError(NULL, NULL, NULL,
  690                     ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
  691                     NULL, 0, NULL, NULL, NULL, val, 0, msg, val);
  692     if (ctxt != NULL) {
  693     ctxt-&gt;wellFormed = 0;
  694     if (ctxt-&gt;recovery == 0)
  695         ctxt-&gt;disableSAX = 1;
  696     }
  697 }
  698 
  699 /**
  700  * xmlFatalErrMsgStrIntStr:
  701  * @ctxt:  an XML parser context
  702  * @error:  the error number
  703  * @msg:  the error message
  704  * @str1:  an string info
  705  * @val:  an integer value
  706  * @str2:  an string info
  707  *
  708  * Handle a fatal parser error, i.e. violating Well-Formedness constraints
  709  */
  710 static void LIBXML_ATTR_FORMAT(3,0)
  711 xmlFatalErrMsgStrIntStr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
  712                   const char *msg, const xmlChar *str1, int val,
  713           const xmlChar *str2)
  714 {
  715     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  716         (ctxt-&gt;instate == XML_PARSER_EOF))
  717     return;
  718     if (ctxt != NULL)
  719     ctxt-&gt;errNo = error;
  720     __xmlRaiseError(NULL, NULL, NULL,
  721                     ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
  722                     NULL, 0, (const char *) str1, (const char *) str2,
  723             NULL, val, 0, msg, str1, val, str2);
  724     if (ctxt != NULL) {
  725     ctxt-&gt;wellFormed = 0;
  726     if (ctxt-&gt;recovery == 0)
  727         ctxt-&gt;disableSAX = 1;
  728     }
  729 }
  730 
  731 /**
  732  * xmlFatalErrMsgStr:
  733  * @ctxt:  an XML parser context
  734  * @error:  the error number
  735  * @msg:  the error message
  736  * @val:  a string value
  737  *
  738  * Handle a fatal parser error, i.e. violating Well-Formedness constraints
  739  */
  740 static void LIBXML_ATTR_FORMAT(3,0)
  741 xmlFatalErrMsgStr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
  742                   const char *msg, const xmlChar * val)
  743 {
  744     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  745         (ctxt-&gt;instate == XML_PARSER_EOF))
  746     return;
  747     if (ctxt != NULL)
  748     ctxt-&gt;errNo = error;
  749     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL,
  750                     XML_FROM_PARSER, error, XML_ERR_FATAL,
  751                     NULL, 0, (const char *) val, NULL, NULL, 0, 0, msg,
  752                     val);
  753     if (ctxt != NULL) {
  754     ctxt-&gt;wellFormed = 0;
  755     if (ctxt-&gt;recovery == 0)
  756         ctxt-&gt;disableSAX = 1;
  757     }
  758 }
  759 
  760 /**
  761  * xmlErrMsgStr:
  762  * @ctxt:  an XML parser context
  763  * @error:  the error number
  764  * @msg:  the error message
  765  * @val:  a string value
  766  *
  767  * Handle a non fatal parser error
  768  */
  769 static void LIBXML_ATTR_FORMAT(3,0)
  770 xmlErrMsgStr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
  771                   const char *msg, const xmlChar * val)
  772 {
  773     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  774         (ctxt-&gt;instate == XML_PARSER_EOF))
  775     return;
  776     if (ctxt != NULL)
  777     ctxt-&gt;errNo = error;
  778     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL,
  779                     XML_FROM_PARSER, error, XML_ERR_ERROR,
  780                     NULL, 0, (const char *) val, NULL, NULL, 0, 0, msg,
  781                     val);
  782 }
  783 
  784 /**
  785  * xmlNsErr:
  786  * @ctxt:  an XML parser context
  787  * @error:  the error number
  788  * @msg:  the message
  789  * @info1:  extra information string
  790  * @info2:  extra information string
  791  *
  792  * Handle a fatal parser error, i.e. violating Well-Formedness constraints
  793  */
  794 static void LIBXML_ATTR_FORMAT(3,0)
  795 xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
  796          const char *msg,
  797          const xmlChar * info1, const xmlChar * info2,
  798          const xmlChar * info3)
  799 {
  800     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  801         (ctxt-&gt;instate == XML_PARSER_EOF))
  802     return;
  803     if (ctxt != NULL)
  804     ctxt-&gt;errNo = error;
  805     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
  806                     XML_ERR_ERROR, NULL, 0, (const char *) info1,
  807                     (const char *) info2, (const char *) info3, 0, 0, msg,
  808                     info1, info2, info3);
  809     if (ctxt != NULL)
  810     ctxt-&gt;nsWellFormed = 0;
  811 }
  812 
  813 /**
  814  * xmlNsWarn
  815  * @ctxt:  an XML parser context
  816  * @error:  the error number
  817  * @msg:  the message
  818  * @info1:  extra information string
  819  * @info2:  extra information string
  820  *
  821  * Handle a namespace warning error
  822  */
  823 static void LIBXML_ATTR_FORMAT(3,0)
  824 xmlNsWarn(xmlParserCtxtPtr ctxt, xmlParserErrors error,
  825          const char *msg,
  826          const xmlChar * info1, const xmlChar * info2,
  827          const xmlChar * info3)
  828 {
  829     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  830         (ctxt-&gt;instate == XML_PARSER_EOF))
  831     return;
  832     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
  833                     XML_ERR_WARNING, NULL, 0, (const char *) info1,
  834                     (const char *) info2, (const char *) info3, 0, 0, msg,
  835                     info1, info2, info3);
  836 }
  837 
  838 /************************************************************************
  839  *                                  *
  840  *      Library wide options                    *
  841  *                                  *
  842  ************************************************************************/
  843 
  844 /**
  845   * xmlHasFeature:
  846   * @feature: the feature to be examined
  847   *
  848   * Examines if the library has been compiled with a given feature.
  849   *
  850   * Returns a non-zero value if the feature exist, otherwise zero.
  851   * Returns zero (0) if the feature does not exist or an unknown
  852   * unknown feature is requested, non-zero otherwise.
  853   */
  854 int
  855 xmlHasFeature(xmlFeature feature)
  856 {
  857     switch (feature) {
  858     case XML_WITH_THREAD:
  859 #ifdef LIBXML_THREAD_ENABLED
  860         return(1);
  861 #else
  862         return(0);
  863 #endif
  864         case XML_WITH_TREE:
  865 #ifdef LIBXML_TREE_ENABLED
  866             return(1);
  867 #else
  868             return(0);
  869 #endif
  870         case XML_WITH_OUTPUT:
  871 #ifdef LIBXML_OUTPUT_ENABLED
  872             return(1);
  873 #else
  874             return(0);
  875 #endif
  876         case XML_WITH_PUSH:
  877 #ifdef LIBXML_PUSH_ENABLED
  878             return(1);
  879 #else
  880             return(0);
  881 #endif
  882         case XML_WITH_READER:
  883 #ifdef LIBXML_READER_ENABLED
  884             return(1);
  885 #else
  886             return(0);
  887 #endif
  888         case XML_WITH_PATTERN:
  889 #ifdef LIBXML_PATTERN_ENABLED
  890             return(1);
  891 #else
  892             return(0);
  893 #endif
  894         case XML_WITH_WRITER:
  895 #ifdef LIBXML_WRITER_ENABLED
  896             return(1);
  897 #else
  898             return(0);
  899 #endif
  900         case XML_WITH_SAX1:
  901 #ifdef LIBXML_SAX1_ENABLED
  902             return(1);
  903 #else
  904             return(0);
  905 #endif
  906         case XML_WITH_FTP:
  907 #ifdef LIBXML_FTP_ENABLED
  908             return(1);
  909 #else
  910             return(0);
  911 #endif
  912         case XML_WITH_HTTP:
  913 #ifdef LIBXML_HTTP_ENABLED
  914             return(1);
  915 #else
  916             return(0);
  917 #endif
  918         case XML_WITH_VALID:
  919 #ifdef LIBXML_VALID_ENABLED
  920             return(1);
  921 #else
  922             return(0);
  923 #endif
  924         case XML_WITH_HTML:
  925 #ifdef LIBXML_HTML_ENABLED
  926             return(1);
  927 #else
  928             return(0);
  929 #endif
  930         case XML_WITH_LEGACY:
  931 #ifdef LIBXML_LEGACY_ENABLED
  932             return(1);
  933 #else
  934             return(0);
  935 #endif
  936         case XML_WITH_C14N:
  937 #ifdef LIBXML_C14N_ENABLED
  938             return(1);
  939 #else
  940             return(0);
  941 #endif
  942         case XML_WITH_CATALOG:
  943 #ifdef LIBXML_CATALOG_ENABLED
  944             return(1);
  945 #else
  946             return(0);
  947 #endif
  948         case XML_WITH_XPATH:
  949 #ifdef LIBXML_XPATH_ENABLED
  950             return(1);
  951 #else
  952             return(0);
  953 #endif
  954         case XML_WITH_XPTR:
  955 #ifdef LIBXML_XPTR_ENABLED
  956             return(1);
  957 #else
  958             return(0);
  959 #endif
  960         case XML_WITH_XINCLUDE:
  961 #ifdef LIBXML_XINCLUDE_ENABLED
  962             return(1);
  963 #else
  964             return(0);
  965 #endif
  966         case XML_WITH_ICONV:
  967 #ifdef LIBXML_ICONV_ENABLED
  968             return(1);
  969 #else
  970             return(0);
  971 #endif
  972         case XML_WITH_ISO8859X:
  973 #ifdef LIBXML_ISO8859X_ENABLED
  974             return(1);
  975 #else
  976             return(0);
  977 #endif
  978         case XML_WITH_UNICODE:
  979 #ifdef LIBXML_UNICODE_ENABLED
  980             return(1);
  981 #else
  982             return(0);
  983 #endif
  984         case XML_WITH_REGEXP:
  985 #ifdef LIBXML_REGEXP_ENABLED
  986             return(1);
  987 #else
  988             return(0);
  989 #endif
  990         case XML_WITH_AUTOMATA:
  991 #ifdef LIBXML_AUTOMATA_ENABLED
  992             return(1);
  993 #else
  994             return(0);
  995 #endif
  996         case XML_WITH_EXPR:
  997 #ifdef LIBXML_EXPR_ENABLED
  998             return(1);
  999 #else
 1000             return(0);
 1001 #endif
 1002         case XML_WITH_SCHEMAS:
 1003 #ifdef LIBXML_SCHEMAS_ENABLED
 1004             return(1);
 1005 #else
 1006             return(0);
 1007 #endif
 1008         case XML_WITH_SCHEMATRON:
 1009 #ifdef LIBXML_SCHEMATRON_ENABLED
 1010             return(1);
 1011 #else
 1012             return(0);
 1013 #endif
 1014         case XML_WITH_MODULES:
 1015 #ifdef LIBXML_MODULES_ENABLED
 1016             return(1);
 1017 #else
 1018             return(0);
 1019 #endif
 1020         case XML_WITH_DEBUG:
 1021 #ifdef LIBXML_DEBUG_ENABLED
 1022             return(1);
 1023 #else
 1024             return(0);
 1025 #endif
 1026         case XML_WITH_DEBUG_MEM:
 1027 #ifdef DEBUG_MEMORY_LOCATION
 1028             return(1);
 1029 #else
 1030             return(0);
 1031 #endif
 1032         case XML_WITH_DEBUG_RUN:
 1033 #ifdef LIBXML_DEBUG_RUNTIME
 1034             return(1);
 1035 #else
 1036             return(0);
 1037 #endif
 1038         case XML_WITH_ZLIB:
 1039 #ifdef LIBXML_ZLIB_ENABLED
 1040             return(1);
 1041 #else
 1042             return(0);
 1043 #endif
 1044         case XML_WITH_LZMA:
 1045 #ifdef LIBXML_LZMA_ENABLED
 1046             return(1);
 1047 #else
 1048             return(0);
 1049 #endif
 1050         case XML_WITH_ICU:
 1051 #ifdef LIBXML_ICU_ENABLED
 1052             return(1);
 1053 #else
 1054             return(0);
 1055 #endif
 1056         default:
 1057         break;
 1058      }
 1059      return(0);
 1060 }
 1061 
 1062 /************************************************************************
 1063  *                                  *
 1064  *      SAX2 defaulted attributes handling          *
 1065  *                                  *
 1066  ************************************************************************/
 1067 
 1068 /**
 1069  * xmlDetectSAX2:
 1070  * @ctxt:  an XML parser context
 1071  *
<a name="5" id="anc5"></a><span class="line-modified"> 1072  * Do the SAX2 detection and specific initialization</span>
 1073  */
 1074 static void
 1075 xmlDetectSAX2(xmlParserCtxtPtr ctxt) {
 1076     if (ctxt == NULL) return;
 1077 #ifdef LIBXML_SAX1_ENABLED
 1078     if ((ctxt-&gt;sax) &amp;&amp;  (ctxt-&gt;sax-&gt;initialized == XML_SAX2_MAGIC) &amp;&amp;
 1079         ((ctxt-&gt;sax-&gt;startElementNs != NULL) ||
 1080          (ctxt-&gt;sax-&gt;endElementNs != NULL))) ctxt-&gt;sax2 = 1;
 1081 #else
 1082     ctxt-&gt;sax2 = 1;
 1083 #endif /* LIBXML_SAX1_ENABLED */
 1084 
 1085     ctxt-&gt;str_xml = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xml&quot;, 3);
 1086     ctxt-&gt;str_xmlns = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xmlns&quot;, 5);
 1087     ctxt-&gt;str_xml_ns = xmlDictLookup(ctxt-&gt;dict, XML_XML_NAMESPACE, 36);
 1088     if ((ctxt-&gt;str_xml==NULL) || (ctxt-&gt;str_xmlns==NULL) ||
 1089         (ctxt-&gt;str_xml_ns == NULL)) {
 1090         xmlErrMemory(ctxt, NULL);
 1091     }
 1092 }
 1093 
 1094 typedef struct _xmlDefAttrs xmlDefAttrs;
 1095 typedef xmlDefAttrs *xmlDefAttrsPtr;
 1096 struct _xmlDefAttrs {
 1097     int nbAttrs;    /* number of defaulted attributes on that element */
 1098     int maxAttrs;       /* the size of the array */
 1099 #if __STDC_VERSION__ &gt;= 199901L
 1100     /* Using a C99 flexible array member avoids UBSan errors. */
 1101     const xmlChar *values[]; /* array of localname/prefix/values/external */
 1102 #else
 1103     const xmlChar *values[5];
 1104 #endif
 1105 };
 1106 
 1107 /**
 1108  * xmlAttrNormalizeSpace:
 1109  * @src: the source string
 1110  * @dst: the target string
 1111  *
 1112  * Normalize the space in non CDATA attribute values:
 1113  * If the attribute type is not CDATA, then the XML processor MUST further
 1114  * process the normalized attribute value by discarding any leading and
 1115  * trailing space (#x20) characters, and by replacing sequences of space
 1116  * (#x20) characters by a single space (#x20) character.
 1117  * Note that the size of dst need to be at least src, and if one doesn&#39;t need
 1118  * to preserve dst (and it doesn&#39;t come from a dictionary or read-only) then
 1119  * passing src as dst is just fine.
 1120  *
 1121  * Returns a pointer to the normalized value (dst) or NULL if no conversion
 1122  *         is needed.
 1123  */
 1124 static xmlChar *
 1125 xmlAttrNormalizeSpace(const xmlChar *src, xmlChar *dst)
 1126 {
 1127     if ((src == NULL) || (dst == NULL))
 1128         return(NULL);
 1129 
 1130     while (*src == 0x20) src++;
 1131     while (*src != 0) {
 1132     if (*src == 0x20) {
 1133         while (*src == 0x20) src++;
 1134         if (*src != 0)
 1135         *dst++ = 0x20;
 1136     } else {
 1137         *dst++ = *src++;
 1138     }
 1139     }
 1140     *dst = 0;
 1141     if (dst == src)
 1142        return(NULL);
 1143     return(dst);
 1144 }
 1145 
 1146 /**
 1147  * xmlAttrNormalizeSpace2:
 1148  * @src: the source string
 1149  *
 1150  * Normalize the space in non CDATA attribute values, a slightly more complex
 1151  * front end to avoid allocation problems when running on attribute values
 1152  * coming from the input.
 1153  *
 1154  * Returns a pointer to the normalized value (dst) or NULL if no conversion
 1155  *         is needed.
 1156  */
 1157 static const xmlChar *
 1158 xmlAttrNormalizeSpace2(xmlParserCtxtPtr ctxt, xmlChar *src, int *len)
 1159 {
 1160     int i;
 1161     int remove_head = 0;
 1162     int need_realloc = 0;
 1163     const xmlChar *cur;
 1164 
 1165     if ((ctxt == NULL) || (src == NULL) || (len == NULL))
 1166         return(NULL);
 1167     i = *len;
 1168     if (i &lt;= 0)
 1169         return(NULL);
 1170 
 1171     cur = src;
 1172     while (*cur == 0x20) {
 1173         cur++;
 1174     remove_head++;
 1175     }
 1176     while (*cur != 0) {
 1177     if (*cur == 0x20) {
 1178         cur++;
 1179         if ((*cur == 0x20) || (*cur == 0)) {
 1180             need_realloc = 1;
 1181         break;
 1182         }
 1183     } else
 1184         cur++;
 1185     }
 1186     if (need_realloc) {
 1187         xmlChar *ret;
 1188 
 1189     ret = xmlStrndup(src + remove_head, i - remove_head + 1);
 1190     if (ret == NULL) {
 1191         xmlErrMemory(ctxt, NULL);
 1192         return(NULL);
 1193     }
 1194     xmlAttrNormalizeSpace(ret, ret);
 1195     *len = (int) strlen((const char *)ret);
 1196         return(ret);
 1197     } else if (remove_head) {
 1198         *len -= remove_head;
 1199         memmove(src, src + remove_head, 1 + *len);
 1200     return(src);
 1201     }
 1202     return(NULL);
 1203 }
 1204 
 1205 /**
 1206  * xmlAddDefAttrs:
 1207  * @ctxt:  an XML parser context
 1208  * @fullname:  the element fullname
 1209  * @fullattr:  the attribute fullname
 1210  * @value:  the attribute value
 1211  *
 1212  * Add a defaulted attribute for an element
 1213  */
 1214 static void
 1215 xmlAddDefAttrs(xmlParserCtxtPtr ctxt,
 1216                const xmlChar *fullname,
 1217                const xmlChar *fullattr,
 1218                const xmlChar *value) {
 1219     xmlDefAttrsPtr defaults;
 1220     int len;
 1221     const xmlChar *name;
 1222     const xmlChar *prefix;
 1223 
 1224     /*
 1225      * Allows to detect attribute redefinitions
 1226      */
 1227     if (ctxt-&gt;attsSpecial != NULL) {
 1228         if (xmlHashLookup2(ctxt-&gt;attsSpecial, fullname, fullattr) != NULL)
 1229         return;
 1230     }
 1231 
 1232     if (ctxt-&gt;attsDefault == NULL) {
 1233         ctxt-&gt;attsDefault = xmlHashCreateDict(10, ctxt-&gt;dict);
 1234     if (ctxt-&gt;attsDefault == NULL)
 1235         goto mem_error;
 1236     }
 1237 
 1238     /*
 1239      * split the element name into prefix:localname , the string found
 1240      * are within the DTD and then not associated to namespace names.
 1241      */
 1242     name = xmlSplitQName3(fullname, &amp;len);
 1243     if (name == NULL) {
 1244         name = xmlDictLookup(ctxt-&gt;dict, fullname, -1);
 1245     prefix = NULL;
 1246     } else {
 1247         name = xmlDictLookup(ctxt-&gt;dict, name, -1);
 1248     prefix = xmlDictLookup(ctxt-&gt;dict, fullname, len);
 1249     }
 1250 
 1251     /*
 1252      * make sure there is some storage
 1253      */
 1254     defaults = xmlHashLookup2(ctxt-&gt;attsDefault, name, prefix);
 1255     if (defaults == NULL) {
 1256         defaults = (xmlDefAttrsPtr) xmlMalloc(sizeof(xmlDefAttrs) +
 1257                        (4 * 5) * sizeof(const xmlChar *));
 1258     if (defaults == NULL)
 1259         goto mem_error;
 1260     defaults-&gt;nbAttrs = 0;
 1261     defaults-&gt;maxAttrs = 4;
 1262     if (xmlHashUpdateEntry2(ctxt-&gt;attsDefault, name, prefix,
 1263                             defaults, NULL) &lt; 0) {
 1264         xmlFree(defaults);
 1265         goto mem_error;
 1266     }
 1267     } else if (defaults-&gt;nbAttrs &gt;= defaults-&gt;maxAttrs) {
 1268         xmlDefAttrsPtr temp;
 1269 
 1270         temp = (xmlDefAttrsPtr) xmlRealloc(defaults, sizeof(xmlDefAttrs) +
 1271                (2 * defaults-&gt;maxAttrs * 5) * sizeof(const xmlChar *));
 1272     if (temp == NULL)
 1273         goto mem_error;
 1274     defaults = temp;
 1275     defaults-&gt;maxAttrs *= 2;
 1276     if (xmlHashUpdateEntry2(ctxt-&gt;attsDefault, name, prefix,
 1277                             defaults, NULL) &lt; 0) {
 1278         xmlFree(defaults);
 1279         goto mem_error;
 1280     }
 1281     }
 1282 
 1283     /*
 1284      * Split the element name into prefix:localname , the string found
 1285      * are within the DTD and hen not associated to namespace names.
 1286      */
 1287     name = xmlSplitQName3(fullattr, &amp;len);
 1288     if (name == NULL) {
 1289         name = xmlDictLookup(ctxt-&gt;dict, fullattr, -1);
 1290     prefix = NULL;
 1291     } else {
 1292         name = xmlDictLookup(ctxt-&gt;dict, name, -1);
 1293     prefix = xmlDictLookup(ctxt-&gt;dict, fullattr, len);
 1294     }
 1295 
 1296     defaults-&gt;values[5 * defaults-&gt;nbAttrs] = name;
 1297     defaults-&gt;values[5 * defaults-&gt;nbAttrs + 1] = prefix;
 1298     /* intern the string and precompute the end */
 1299     len = xmlStrlen(value);
 1300     value = xmlDictLookup(ctxt-&gt;dict, value, len);
 1301     defaults-&gt;values[5 * defaults-&gt;nbAttrs + 2] = value;
 1302     defaults-&gt;values[5 * defaults-&gt;nbAttrs + 3] = value + len;
 1303     if (ctxt-&gt;external)
 1304         defaults-&gt;values[5 * defaults-&gt;nbAttrs + 4] = BAD_CAST &quot;external&quot;;
 1305     else
 1306         defaults-&gt;values[5 * defaults-&gt;nbAttrs + 4] = NULL;
 1307     defaults-&gt;nbAttrs++;
 1308 
 1309     return;
 1310 
 1311 mem_error:
 1312     xmlErrMemory(ctxt, NULL);
 1313     return;
 1314 }
 1315 
 1316 /**
 1317  * xmlAddSpecialAttr:
 1318  * @ctxt:  an XML parser context
 1319  * @fullname:  the element fullname
 1320  * @fullattr:  the attribute fullname
 1321  * @type:  the attribute type
 1322  *
 1323  * Register this attribute type
 1324  */
 1325 static void
 1326 xmlAddSpecialAttr(xmlParserCtxtPtr ctxt,
 1327           const xmlChar *fullname,
 1328           const xmlChar *fullattr,
 1329           int type)
 1330 {
 1331     if (ctxt-&gt;attsSpecial == NULL) {
 1332         ctxt-&gt;attsSpecial = xmlHashCreateDict(10, ctxt-&gt;dict);
 1333     if (ctxt-&gt;attsSpecial == NULL)
 1334         goto mem_error;
 1335     }
 1336 
 1337     if (xmlHashLookup2(ctxt-&gt;attsSpecial, fullname, fullattr) != NULL)
 1338         return;
 1339 
 1340     xmlHashAddEntry2(ctxt-&gt;attsSpecial, fullname, fullattr,
 1341                      (void *) (ptrdiff_t) type);
 1342     return;
 1343 
 1344 mem_error:
 1345     xmlErrMemory(ctxt, NULL);
 1346     return;
 1347 }
 1348 
 1349 /**
 1350  * xmlCleanSpecialAttrCallback:
 1351  *
 1352  * Removes CDATA attributes from the special attribute table
 1353  */
 1354 static void
 1355 xmlCleanSpecialAttrCallback(void *payload, void *data,
 1356                             const xmlChar *fullname, const xmlChar *fullattr,
 1357                             const xmlChar *unused ATTRIBUTE_UNUSED) {
 1358     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) data;
 1359 
 1360     if (((ptrdiff_t) payload) == XML_ATTRIBUTE_CDATA) {
 1361         xmlHashRemoveEntry2(ctxt-&gt;attsSpecial, fullname, fullattr, NULL);
 1362     }
 1363 }
 1364 
 1365 /**
 1366  * xmlCleanSpecialAttr:
 1367  * @ctxt:  an XML parser context
 1368  *
 1369  * Trim the list of attributes defined to remove all those of type
 1370  * CDATA as they are not special. This call should be done when finishing
 1371  * to parse the DTD and before starting to parse the document root.
 1372  */
 1373 static void
 1374 xmlCleanSpecialAttr(xmlParserCtxtPtr ctxt)
 1375 {
 1376     if (ctxt-&gt;attsSpecial == NULL)
 1377         return;
 1378 
 1379     xmlHashScanFull(ctxt-&gt;attsSpecial, xmlCleanSpecialAttrCallback, ctxt);
 1380 
 1381     if (xmlHashSize(ctxt-&gt;attsSpecial) == 0) {
 1382         xmlHashFree(ctxt-&gt;attsSpecial, NULL);
 1383         ctxt-&gt;attsSpecial = NULL;
 1384     }
 1385     return;
 1386 }
 1387 
 1388 /**
 1389  * xmlCheckLanguageID:
 1390  * @lang:  pointer to the string value
 1391  *
 1392  * Checks that the value conforms to the LanguageID production:
 1393  *
 1394  * NOTE: this is somewhat deprecated, those productions were removed from
 1395  *       the XML Second edition.
 1396  *
 1397  * [33] LanguageID ::= Langcode (&#39;-&#39; Subcode)*
 1398  * [34] Langcode ::= ISO639Code |  IanaCode |  UserCode
 1399  * [35] ISO639Code ::= ([a-z] | [A-Z]) ([a-z] | [A-Z])
 1400  * [36] IanaCode ::= (&#39;i&#39; | &#39;I&#39;) &#39;-&#39; ([a-z] | [A-Z])+
 1401  * [37] UserCode ::= (&#39;x&#39; | &#39;X&#39;) &#39;-&#39; ([a-z] | [A-Z])+
 1402  * [38] Subcode ::= ([a-z] | [A-Z])+
 1403  *
<a name="6" id="anc6"></a><span class="line-modified"> 1404  * The current REC reference the successors of RFC 1766, currently 5646</span>
 1405  *
 1406  * http://www.rfc-editor.org/rfc/rfc5646.txt
 1407  * langtag       = language
 1408  *                 [&quot;-&quot; script]
 1409  *                 [&quot;-&quot; region]
 1410  *                 *(&quot;-&quot; variant)
 1411  *                 *(&quot;-&quot; extension)
 1412  *                 [&quot;-&quot; privateuse]
 1413  * language      = 2*3ALPHA            ; shortest ISO 639 code
 1414  *                 [&quot;-&quot; extlang]       ; sometimes followed by
 1415  *                                     ; extended language subtags
 1416  *               / 4ALPHA              ; or reserved for future use
 1417  *               / 5*8ALPHA            ; or registered language subtag
 1418  *
 1419  * extlang       = 3ALPHA              ; selected ISO 639 codes
 1420  *                 *2(&quot;-&quot; 3ALPHA)      ; permanently reserved
 1421  *
 1422  * script        = 4ALPHA              ; ISO 15924 code
 1423  *
 1424  * region        = 2ALPHA              ; ISO 3166-1 code
 1425  *               / 3DIGIT              ; UN M.49 code
 1426  *
 1427  * variant       = 5*8alphanum         ; registered variants
 1428  *               / (DIGIT 3alphanum)
 1429  *
 1430  * extension     = singleton 1*(&quot;-&quot; (2*8alphanum))
 1431  *
 1432  *                                     ; Single alphanumerics
 1433  *                                     ; &quot;x&quot; reserved for private use
 1434  * singleton     = DIGIT               ; 0 - 9
 1435  *               / %x41-57             ; A - W
 1436  *               / %x59-5A             ; Y - Z
 1437  *               / %x61-77             ; a - w
 1438  *               / %x79-7A             ; y - z
 1439  *
 1440  * it sounds right to still allow Irregular i-xxx IANA and user codes too
 1441  * The parser below doesn&#39;t try to cope with extension or privateuse
 1442  * that could be added but that&#39;s not interoperable anyway
 1443  *
 1444  * Returns 1 if correct 0 otherwise
 1445  **/
 1446 int
 1447 xmlCheckLanguageID(const xmlChar * lang)
 1448 {
 1449     const xmlChar *cur = lang, *nxt;
 1450 
 1451     if (cur == NULL)
 1452         return (0);
 1453     if (((cur[0] == &#39;i&#39;) &amp;&amp; (cur[1] == &#39;-&#39;)) ||
 1454         ((cur[0] == &#39;I&#39;) &amp;&amp; (cur[1] == &#39;-&#39;)) ||
 1455         ((cur[0] == &#39;x&#39;) &amp;&amp; (cur[1] == &#39;-&#39;)) ||
 1456         ((cur[0] == &#39;X&#39;) &amp;&amp; (cur[1] == &#39;-&#39;))) {
 1457         /*
 1458          * Still allow IANA code and user code which were coming
 1459          * from the previous version of the XML-1.0 specification
 1460          * it&#39;s deprecated but we should not fail
 1461          */
 1462         cur += 2;
 1463         while (((cur[0] &gt;= &#39;A&#39;) &amp;&amp; (cur[0] &lt;= &#39;Z&#39;)) ||
 1464                ((cur[0] &gt;= &#39;a&#39;) &amp;&amp; (cur[0] &lt;= &#39;z&#39;)))
 1465             cur++;
 1466         return(cur[0] == 0);
 1467     }
 1468     nxt = cur;
 1469     while (((nxt[0] &gt;= &#39;A&#39;) &amp;&amp; (nxt[0] &lt;= &#39;Z&#39;)) ||
 1470            ((nxt[0] &gt;= &#39;a&#39;) &amp;&amp; (nxt[0] &lt;= &#39;z&#39;)))
 1471            nxt++;
 1472     if (nxt - cur &gt;= 4) {
 1473         /*
 1474          * Reserved
 1475          */
 1476         if ((nxt - cur &gt; 8) || (nxt[0] != 0))
 1477             return(0);
 1478         return(1);
 1479     }
 1480     if (nxt - cur &lt; 2)
 1481         return(0);
 1482     /* we got an ISO 639 code */
 1483     if (nxt[0] == 0)
 1484         return(1);
 1485     if (nxt[0] != &#39;-&#39;)
 1486         return(0);
 1487 
 1488     nxt++;
 1489     cur = nxt;
 1490     /* now we can have extlang or script or region or variant */
 1491     if ((nxt[0] &gt;= &#39;0&#39;) &amp;&amp; (nxt[0] &lt;= &#39;9&#39;))
 1492         goto region_m49;
 1493 
 1494     while (((nxt[0] &gt;= &#39;A&#39;) &amp;&amp; (nxt[0] &lt;= &#39;Z&#39;)) ||
 1495            ((nxt[0] &gt;= &#39;a&#39;) &amp;&amp; (nxt[0] &lt;= &#39;z&#39;)))
 1496            nxt++;
 1497     if (nxt - cur == 4)
 1498         goto script;
 1499     if (nxt - cur == 2)
 1500         goto region;
 1501     if ((nxt - cur &gt;= 5) &amp;&amp; (nxt - cur &lt;= 8))
 1502         goto variant;
 1503     if (nxt - cur != 3)
 1504         return(0);
 1505     /* we parsed an extlang */
 1506     if (nxt[0] == 0)
 1507         return(1);
 1508     if (nxt[0] != &#39;-&#39;)
 1509         return(0);
 1510 
 1511     nxt++;
 1512     cur = nxt;
 1513     /* now we can have script or region or variant */
 1514     if ((nxt[0] &gt;= &#39;0&#39;) &amp;&amp; (nxt[0] &lt;= &#39;9&#39;))
 1515         goto region_m49;
 1516 
 1517     while (((nxt[0] &gt;= &#39;A&#39;) &amp;&amp; (nxt[0] &lt;= &#39;Z&#39;)) ||
 1518            ((nxt[0] &gt;= &#39;a&#39;) &amp;&amp; (nxt[0] &lt;= &#39;z&#39;)))
 1519            nxt++;
 1520     if (nxt - cur == 2)
 1521         goto region;
 1522     if ((nxt - cur &gt;= 5) &amp;&amp; (nxt - cur &lt;= 8))
 1523         goto variant;
 1524     if (nxt - cur != 4)
 1525         return(0);
 1526     /* we parsed a script */
 1527 script:
 1528     if (nxt[0] == 0)
 1529         return(1);
 1530     if (nxt[0] != &#39;-&#39;)
 1531         return(0);
 1532 
 1533     nxt++;
 1534     cur = nxt;
 1535     /* now we can have region or variant */
 1536     if ((nxt[0] &gt;= &#39;0&#39;) &amp;&amp; (nxt[0] &lt;= &#39;9&#39;))
 1537         goto region_m49;
 1538 
 1539     while (((nxt[0] &gt;= &#39;A&#39;) &amp;&amp; (nxt[0] &lt;= &#39;Z&#39;)) ||
 1540            ((nxt[0] &gt;= &#39;a&#39;) &amp;&amp; (nxt[0] &lt;= &#39;z&#39;)))
 1541            nxt++;
 1542 
 1543     if ((nxt - cur &gt;= 5) &amp;&amp; (nxt - cur &lt;= 8))
 1544         goto variant;
 1545     if (nxt - cur != 2)
 1546         return(0);
 1547     /* we parsed a region */
 1548 region:
 1549     if (nxt[0] == 0)
 1550         return(1);
 1551     if (nxt[0] != &#39;-&#39;)
 1552         return(0);
 1553 
 1554     nxt++;
 1555     cur = nxt;
 1556     /* now we can just have a variant */
 1557     while (((nxt[0] &gt;= &#39;A&#39;) &amp;&amp; (nxt[0] &lt;= &#39;Z&#39;)) ||
 1558            ((nxt[0] &gt;= &#39;a&#39;) &amp;&amp; (nxt[0] &lt;= &#39;z&#39;)))
 1559            nxt++;
 1560 
 1561     if ((nxt - cur &lt; 5) || (nxt - cur &gt; 8))
 1562         return(0);
 1563 
 1564     /* we parsed a variant */
 1565 variant:
 1566     if (nxt[0] == 0)
 1567         return(1);
 1568     if (nxt[0] != &#39;-&#39;)
 1569         return(0);
 1570     /* extensions and private use subtags not checked */
 1571     return (1);
 1572 
 1573 region_m49:
 1574     if (((nxt[1] &gt;= &#39;0&#39;) &amp;&amp; (nxt[1] &lt;= &#39;9&#39;)) &amp;&amp;
 1575         ((nxt[2] &gt;= &#39;0&#39;) &amp;&amp; (nxt[2] &lt;= &#39;9&#39;))) {
 1576         nxt += 3;
 1577         goto region;
 1578     }
 1579     return(0);
 1580 }
 1581 
 1582 /************************************************************************
 1583  *                                  *
 1584  *      Parser stacks related functions and macros      *
 1585  *                                  *
 1586  ************************************************************************/
 1587 
 1588 static xmlEntityPtr xmlParseStringEntityRef(xmlParserCtxtPtr ctxt,
 1589                                             const xmlChar ** str);
 1590 
 1591 #ifdef SAX2
 1592 /**
 1593  * nsPush:
 1594  * @ctxt:  an XML parser context
 1595  * @prefix:  the namespace prefix or NULL
 1596  * @URL:  the namespace name
 1597  *
 1598  * Pushes a new parser namespace on top of the ns stack
 1599  *
 1600  * Returns -1 in case of error, -2 if the namespace should be discarded
 1601  *     and the index in the stack otherwise.
 1602  */
 1603 static int
 1604 nsPush(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URL)
 1605 {
 1606     if (ctxt-&gt;options &amp; XML_PARSE_NSCLEAN) {
 1607         int i;
 1608     for (i = ctxt-&gt;nsNr - 2;i &gt;= 0;i -= 2) {
 1609         if (ctxt-&gt;nsTab[i] == prefix) {
 1610         /* in scope */
 1611             if (ctxt-&gt;nsTab[i + 1] == URL)
 1612             return(-2);
 1613         /* out of scope keep it */
 1614         break;
 1615         }
 1616     }
 1617     }
 1618     if ((ctxt-&gt;nsMax == 0) || (ctxt-&gt;nsTab == NULL)) {
 1619     ctxt-&gt;nsMax = 10;
 1620     ctxt-&gt;nsNr = 0;
 1621     ctxt-&gt;nsTab = (const xmlChar **)
 1622                   xmlMalloc(ctxt-&gt;nsMax * sizeof(xmlChar *));
 1623     if (ctxt-&gt;nsTab == NULL) {
 1624         xmlErrMemory(ctxt, NULL);
 1625         ctxt-&gt;nsMax = 0;
 1626             return (-1);
 1627     }
 1628     } else if (ctxt-&gt;nsNr &gt;= ctxt-&gt;nsMax) {
 1629         const xmlChar ** tmp;
 1630         ctxt-&gt;nsMax *= 2;
 1631         tmp = (const xmlChar **) xmlRealloc((char *) ctxt-&gt;nsTab,
 1632                     ctxt-&gt;nsMax * sizeof(ctxt-&gt;nsTab[0]));
 1633         if (tmp == NULL) {
 1634             xmlErrMemory(ctxt, NULL);
 1635         ctxt-&gt;nsMax /= 2;
 1636             return (-1);
 1637         }
 1638     ctxt-&gt;nsTab = tmp;
 1639     }
 1640     ctxt-&gt;nsTab[ctxt-&gt;nsNr++] = prefix;
 1641     ctxt-&gt;nsTab[ctxt-&gt;nsNr++] = URL;
 1642     return (ctxt-&gt;nsNr);
 1643 }
 1644 /**
 1645  * nsPop:
 1646  * @ctxt: an XML parser context
 1647  * @nr:  the number to pop
 1648  *
 1649  * Pops the top @nr parser prefix/namespace from the ns stack
 1650  *
 1651  * Returns the number of namespaces removed
 1652  */
 1653 static int
 1654 nsPop(xmlParserCtxtPtr ctxt, int nr)
 1655 {
 1656     int i;
 1657 
 1658     if (ctxt-&gt;nsTab == NULL) return(0);
 1659     if (ctxt-&gt;nsNr &lt; nr) {
 1660         xmlGenericError(xmlGenericErrorContext, &quot;Pbm popping %d NS\n&quot;, nr);
 1661         nr = ctxt-&gt;nsNr;
 1662     }
 1663     if (ctxt-&gt;nsNr &lt;= 0)
 1664         return (0);
 1665 
 1666     for (i = 0;i &lt; nr;i++) {
 1667          ctxt-&gt;nsNr--;
 1668      ctxt-&gt;nsTab[ctxt-&gt;nsNr] = NULL;
 1669     }
 1670     return(nr);
 1671 }
 1672 #endif
 1673 
 1674 static int
 1675 xmlCtxtGrowAttrs(xmlParserCtxtPtr ctxt, int nr) {
 1676     const xmlChar **atts;
 1677     int *attallocs;
 1678     int maxatts;
 1679 
 1680     if (ctxt-&gt;atts == NULL) {
 1681     maxatts = 55; /* allow for 10 attrs by default */
 1682     atts = (const xmlChar **)
 1683            xmlMalloc(maxatts * sizeof(xmlChar *));
 1684     if (atts == NULL) goto mem_error;
 1685     ctxt-&gt;atts = atts;
 1686     attallocs = (int *) xmlMalloc((maxatts / 5) * sizeof(int));
 1687     if (attallocs == NULL) goto mem_error;
 1688     ctxt-&gt;attallocs = attallocs;
 1689     ctxt-&gt;maxatts = maxatts;
 1690     } else if (nr + 5 &gt; ctxt-&gt;maxatts) {
 1691     maxatts = (nr + 5) * 2;
 1692     atts = (const xmlChar **) xmlRealloc((void *) ctxt-&gt;atts,
 1693                      maxatts * sizeof(const xmlChar *));
 1694     if (atts == NULL) goto mem_error;
 1695     ctxt-&gt;atts = atts;
 1696     attallocs = (int *) xmlRealloc((void *) ctxt-&gt;attallocs,
 1697                                  (maxatts / 5) * sizeof(int));
 1698     if (attallocs == NULL) goto mem_error;
 1699     ctxt-&gt;attallocs = attallocs;
 1700     ctxt-&gt;maxatts = maxatts;
 1701     }
 1702     return(ctxt-&gt;maxatts);
 1703 mem_error:
 1704     xmlErrMemory(ctxt, NULL);
 1705     return(-1);
 1706 }
 1707 
 1708 /**
 1709  * inputPush:
 1710  * @ctxt:  an XML parser context
 1711  * @value:  the parser input
 1712  *
 1713  * Pushes a new parser input on top of the input stack
 1714  *
 1715  * Returns -1 in case of error, the index in the stack otherwise
 1716  */
 1717 int
 1718 inputPush(xmlParserCtxtPtr ctxt, xmlParserInputPtr value)
 1719 {
 1720     if ((ctxt == NULL) || (value == NULL))
 1721         return(-1);
 1722     if (ctxt-&gt;inputNr &gt;= ctxt-&gt;inputMax) {
 1723         ctxt-&gt;inputMax *= 2;
 1724         ctxt-&gt;inputTab =
 1725             (xmlParserInputPtr *) xmlRealloc(ctxt-&gt;inputTab,
 1726                                              ctxt-&gt;inputMax *
 1727                                              sizeof(ctxt-&gt;inputTab[0]));
 1728         if (ctxt-&gt;inputTab == NULL) {
 1729             xmlErrMemory(ctxt, NULL);
 1730         xmlFreeInputStream(value);
 1731         ctxt-&gt;inputMax /= 2;
 1732         value = NULL;
 1733             return (-1);
 1734         }
 1735     }
 1736     ctxt-&gt;inputTab[ctxt-&gt;inputNr] = value;
 1737     ctxt-&gt;input = value;
 1738     return (ctxt-&gt;inputNr++);
 1739 }
 1740 /**
 1741  * inputPop:
 1742  * @ctxt: an XML parser context
 1743  *
 1744  * Pops the top parser input from the input stack
 1745  *
 1746  * Returns the input just removed
 1747  */
 1748 xmlParserInputPtr
 1749 inputPop(xmlParserCtxtPtr ctxt)
 1750 {
 1751     xmlParserInputPtr ret;
 1752 
 1753     if (ctxt == NULL)
 1754         return(NULL);
 1755     if (ctxt-&gt;inputNr &lt;= 0)
 1756         return (NULL);
 1757     ctxt-&gt;inputNr--;
 1758     if (ctxt-&gt;inputNr &gt; 0)
 1759         ctxt-&gt;input = ctxt-&gt;inputTab[ctxt-&gt;inputNr - 1];
 1760     else
 1761         ctxt-&gt;input = NULL;
 1762     ret = ctxt-&gt;inputTab[ctxt-&gt;inputNr];
 1763     ctxt-&gt;inputTab[ctxt-&gt;inputNr] = NULL;
 1764     return (ret);
 1765 }
 1766 /**
 1767  * nodePush:
 1768  * @ctxt:  an XML parser context
 1769  * @value:  the element node
 1770  *
 1771  * Pushes a new element node on top of the node stack
 1772  *
 1773  * Returns -1 in case of error, the index in the stack otherwise
 1774  */
 1775 int
 1776 nodePush(xmlParserCtxtPtr ctxt, xmlNodePtr value)
 1777 {
 1778     if (ctxt == NULL) return(0);
 1779     if (ctxt-&gt;nodeNr &gt;= ctxt-&gt;nodeMax) {
 1780         xmlNodePtr *tmp;
 1781 
 1782     tmp = (xmlNodePtr *) xmlRealloc(ctxt-&gt;nodeTab,
 1783                                       ctxt-&gt;nodeMax * 2 *
 1784                                       sizeof(ctxt-&gt;nodeTab[0]));
 1785         if (tmp == NULL) {
 1786             xmlErrMemory(ctxt, NULL);
 1787             return (-1);
 1788         }
 1789         ctxt-&gt;nodeTab = tmp;
 1790     ctxt-&gt;nodeMax *= 2;
 1791     }
 1792     if ((((unsigned int) ctxt-&gt;nodeNr) &gt; xmlParserMaxDepth) &amp;&amp;
 1793         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 1794     xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
 1795          &quot;Excessive depth in document: %d use XML_PARSE_HUGE option\n&quot;,
 1796               xmlParserMaxDepth);
 1797     xmlHaltParser(ctxt);
 1798     return(-1);
 1799     }
 1800     ctxt-&gt;nodeTab[ctxt-&gt;nodeNr] = value;
 1801     ctxt-&gt;node = value;
 1802     return (ctxt-&gt;nodeNr++);
 1803 }
 1804 
 1805 /**
 1806  * nodePop:
 1807  * @ctxt: an XML parser context
 1808  *
 1809  * Pops the top element node from the node stack
 1810  *
 1811  * Returns the node just removed
 1812  */
 1813 xmlNodePtr
 1814 nodePop(xmlParserCtxtPtr ctxt)
 1815 {
 1816     xmlNodePtr ret;
 1817 
 1818     if (ctxt == NULL) return(NULL);
 1819     if (ctxt-&gt;nodeNr &lt;= 0)
 1820         return (NULL);
 1821     ctxt-&gt;nodeNr--;
 1822     if (ctxt-&gt;nodeNr &gt; 0)
 1823         ctxt-&gt;node = ctxt-&gt;nodeTab[ctxt-&gt;nodeNr - 1];
 1824     else
 1825         ctxt-&gt;node = NULL;
 1826     ret = ctxt-&gt;nodeTab[ctxt-&gt;nodeNr];
 1827     ctxt-&gt;nodeTab[ctxt-&gt;nodeNr] = NULL;
 1828     return (ret);
 1829 }
 1830 
<a name="7" id="anc7"></a>
 1831 /**
 1832  * nameNsPush:
 1833  * @ctxt:  an XML parser context
 1834  * @value:  the element name
 1835  * @prefix:  the element prefix
 1836  * @URI:  the element namespace name
 1837  *
 1838  * Pushes a new element name/prefix/URL on top of the name stack
 1839  *
 1840  * Returns -1 in case of error, the index in the stack otherwise
 1841  */
 1842 static int
 1843 nameNsPush(xmlParserCtxtPtr ctxt, const xmlChar * value,
 1844            const xmlChar *prefix, const xmlChar *URI, int nsNr)
 1845 {
 1846     if (ctxt-&gt;nameNr &gt;= ctxt-&gt;nameMax) {
 1847         const xmlChar * *tmp;
 1848         void **tmp2;
 1849         ctxt-&gt;nameMax *= 2;
 1850         tmp = (const xmlChar * *) xmlRealloc((xmlChar * *)ctxt-&gt;nameTab,
 1851                                     ctxt-&gt;nameMax *
 1852                                     sizeof(ctxt-&gt;nameTab[0]));
 1853         if (tmp == NULL) {
 1854         ctxt-&gt;nameMax /= 2;
 1855         goto mem_error;
 1856         }
 1857     ctxt-&gt;nameTab = tmp;
 1858         tmp2 = (void **) xmlRealloc((void * *)ctxt-&gt;pushTab,
 1859                                     ctxt-&gt;nameMax * 3 *
 1860                                     sizeof(ctxt-&gt;pushTab[0]));
 1861         if (tmp2 == NULL) {
 1862         ctxt-&gt;nameMax /= 2;
 1863         goto mem_error;
 1864         }
 1865     ctxt-&gt;pushTab = tmp2;
<a name="8" id="anc8"></a><span class="line-added"> 1866     } else if (ctxt-&gt;pushTab == NULL) {</span>
<span class="line-added"> 1867         ctxt-&gt;pushTab = (void **) xmlMalloc(ctxt-&gt;nameMax * 3 *</span>
<span class="line-added"> 1868                                             sizeof(ctxt-&gt;pushTab[0]));</span>
<span class="line-added"> 1869         if (ctxt-&gt;pushTab == NULL)</span>
<span class="line-added"> 1870             goto mem_error;</span>
 1871     }
 1872     ctxt-&gt;nameTab[ctxt-&gt;nameNr] = value;
 1873     ctxt-&gt;name = value;
 1874     ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3] = (void *) prefix;
 1875     ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 + 1] = (void *) URI;
 1876     ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 + 2] = (void *) (ptrdiff_t) nsNr;
 1877     return (ctxt-&gt;nameNr++);
 1878 mem_error:
 1879     xmlErrMemory(ctxt, NULL);
 1880     return (-1);
 1881 }
<a name="9" id="anc9"></a><span class="line-added"> 1882 #ifdef LIBXML_PUSH_ENABLED</span>
 1883 /**
 1884  * nameNsPop:
 1885  * @ctxt: an XML parser context
 1886  *
 1887  * Pops the top element/prefix/URI name from the name stack
 1888  *
 1889  * Returns the name just removed
 1890  */
 1891 static const xmlChar *
 1892 nameNsPop(xmlParserCtxtPtr ctxt)
 1893 {
 1894     const xmlChar *ret;
 1895 
 1896     if (ctxt-&gt;nameNr &lt;= 0)
 1897         return (NULL);
 1898     ctxt-&gt;nameNr--;
 1899     if (ctxt-&gt;nameNr &gt; 0)
 1900         ctxt-&gt;name = ctxt-&gt;nameTab[ctxt-&gt;nameNr - 1];
 1901     else
 1902         ctxt-&gt;name = NULL;
 1903     ret = ctxt-&gt;nameTab[ctxt-&gt;nameNr];
 1904     ctxt-&gt;nameTab[ctxt-&gt;nameNr] = NULL;
 1905     return (ret);
 1906 }
 1907 #endif /* LIBXML_PUSH_ENABLED */
 1908 
 1909 /**
 1910  * namePush:
 1911  * @ctxt:  an XML parser context
 1912  * @value:  the element name
 1913  *
 1914  * Pushes a new element name on top of the name stack
 1915  *
 1916  * Returns -1 in case of error, the index in the stack otherwise
 1917  */
 1918 int
 1919 namePush(xmlParserCtxtPtr ctxt, const xmlChar * value)
 1920 {
 1921     if (ctxt == NULL) return (-1);
 1922 
 1923     if (ctxt-&gt;nameNr &gt;= ctxt-&gt;nameMax) {
 1924         const xmlChar * *tmp;
 1925         tmp = (const xmlChar * *) xmlRealloc((xmlChar * *)ctxt-&gt;nameTab,
 1926                                     ctxt-&gt;nameMax * 2 *
 1927                                     sizeof(ctxt-&gt;nameTab[0]));
 1928         if (tmp == NULL) {
 1929         goto mem_error;
 1930         }
 1931     ctxt-&gt;nameTab = tmp;
 1932         ctxt-&gt;nameMax *= 2;
 1933     }
 1934     ctxt-&gt;nameTab[ctxt-&gt;nameNr] = value;
 1935     ctxt-&gt;name = value;
 1936     return (ctxt-&gt;nameNr++);
 1937 mem_error:
 1938     xmlErrMemory(ctxt, NULL);
 1939     return (-1);
 1940 }
 1941 /**
 1942  * namePop:
 1943  * @ctxt: an XML parser context
 1944  *
 1945  * Pops the top element name from the name stack
 1946  *
 1947  * Returns the name just removed
 1948  */
 1949 const xmlChar *
 1950 namePop(xmlParserCtxtPtr ctxt)
 1951 {
 1952     const xmlChar *ret;
 1953 
 1954     if ((ctxt == NULL) || (ctxt-&gt;nameNr &lt;= 0))
 1955         return (NULL);
 1956     ctxt-&gt;nameNr--;
 1957     if (ctxt-&gt;nameNr &gt; 0)
 1958         ctxt-&gt;name = ctxt-&gt;nameTab[ctxt-&gt;nameNr - 1];
 1959     else
 1960         ctxt-&gt;name = NULL;
 1961     ret = ctxt-&gt;nameTab[ctxt-&gt;nameNr];
 1962     ctxt-&gt;nameTab[ctxt-&gt;nameNr] = NULL;
 1963     return (ret);
 1964 }
 1965 
 1966 static int spacePush(xmlParserCtxtPtr ctxt, int val) {
 1967     if (ctxt-&gt;spaceNr &gt;= ctxt-&gt;spaceMax) {
 1968         int *tmp;
 1969 
 1970     ctxt-&gt;spaceMax *= 2;
 1971         tmp = (int *) xmlRealloc(ctxt-&gt;spaceTab,
 1972                              ctxt-&gt;spaceMax * sizeof(ctxt-&gt;spaceTab[0]));
 1973         if (tmp == NULL) {
 1974         xmlErrMemory(ctxt, NULL);
 1975         ctxt-&gt;spaceMax /=2;
 1976         return(-1);
 1977     }
 1978     ctxt-&gt;spaceTab = tmp;
 1979     }
 1980     ctxt-&gt;spaceTab[ctxt-&gt;spaceNr] = val;
 1981     ctxt-&gt;space = &amp;ctxt-&gt;spaceTab[ctxt-&gt;spaceNr];
 1982     return(ctxt-&gt;spaceNr++);
 1983 }
 1984 
 1985 static int spacePop(xmlParserCtxtPtr ctxt) {
 1986     int ret;
 1987     if (ctxt-&gt;spaceNr &lt;= 0) return(0);
 1988     ctxt-&gt;spaceNr--;
 1989     if (ctxt-&gt;spaceNr &gt; 0)
 1990     ctxt-&gt;space = &amp;ctxt-&gt;spaceTab[ctxt-&gt;spaceNr - 1];
 1991     else
 1992         ctxt-&gt;space = &amp;ctxt-&gt;spaceTab[0];
 1993     ret = ctxt-&gt;spaceTab[ctxt-&gt;spaceNr];
 1994     ctxt-&gt;spaceTab[ctxt-&gt;spaceNr] = -1;
 1995     return(ret);
 1996 }
 1997 
 1998 /*
 1999  * Macros for accessing the content. Those should be used only by the parser,
 2000  * and not exported.
 2001  *
 2002  * Dirty macros, i.e. one often need to make assumption on the context to
 2003  * use them
 2004  *
 2005  *   CUR_PTR return the current pointer to the xmlChar to be parsed.
 2006  *           To be used with extreme caution since operations consuming
 2007  *           characters may move the input buffer to a different location !
 2008  *   CUR     returns the current xmlChar value, i.e. a 8 bit value if compiled
 2009  *           This should be used internally by the parser
 2010  *           only to compare to ASCII values otherwise it would break when
 2011  *           running with UTF-8 encoding.
 2012  *   RAW     same as CUR but in the input buffer, bypass any token
 2013  *           extraction that may have been done
 2014  *   NXT(n)  returns the n&#39;th next xmlChar. Same as CUR is should be used only
 2015  *           to compare on ASCII based substring.
 2016  *   SKIP(n) Skip n xmlChar, and must also be used only to skip ASCII defined
 2017  *           strings without newlines within the parser.
 2018  *   NEXT1(l) Skip 1 xmlChar, and must also be used only to skip 1 non-newline ASCII
 2019  *           defined char within the parser.
 2020  * Clean macros, not dependent of an ASCII context, expect UTF-8 encoding
 2021  *
 2022  *   NEXT    Skip to the next character, this does the proper decoding
 2023  *           in UTF-8 mode. It also pop-up unfinished entities on the fly.
 2024  *   NEXTL(l) Skip the current unicode character of l xmlChars long.
 2025  *   CUR_CHAR(l) returns the current unicode character (int), set l
 2026  *           to the number of xmlChars used for the encoding [0-5].
 2027  *   CUR_SCHAR  same but operate on a string instead of the context
 2028  *   COPY_BUF  copy the current unicode char to the target buffer, increment
 2029  *            the index
 2030  *   GROW, SHRINK  handling of input buffers
 2031  */
 2032 
 2033 #define RAW (*ctxt-&gt;input-&gt;cur)
 2034 #define CUR (*ctxt-&gt;input-&gt;cur)
 2035 #define NXT(val) ctxt-&gt;input-&gt;cur[(val)]
 2036 #define CUR_PTR ctxt-&gt;input-&gt;cur
 2037 #define BASE_PTR ctxt-&gt;input-&gt;base
 2038 
 2039 #define CMP4( s, c1, c2, c3, c4 ) \
 2040   ( ((unsigned char *) s)[ 0 ] == c1 &amp;&amp; ((unsigned char *) s)[ 1 ] == c2 &amp;&amp; \
 2041     ((unsigned char *) s)[ 2 ] == c3 &amp;&amp; ((unsigned char *) s)[ 3 ] == c4 )
 2042 #define CMP5( s, c1, c2, c3, c4, c5 ) \
 2043   ( CMP4( s, c1, c2, c3, c4 ) &amp;&amp; ((unsigned char *) s)[ 4 ] == c5 )
 2044 #define CMP6( s, c1, c2, c3, c4, c5, c6 ) \
 2045   ( CMP5( s, c1, c2, c3, c4, c5 ) &amp;&amp; ((unsigned char *) s)[ 5 ] == c6 )
 2046 #define CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) \
 2047   ( CMP6( s, c1, c2, c3, c4, c5, c6 ) &amp;&amp; ((unsigned char *) s)[ 6 ] == c7 )
 2048 #define CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) \
 2049   ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) &amp;&amp; ((unsigned char *) s)[ 7 ] == c8 )
 2050 #define CMP9( s, c1, c2, c3, c4, c5, c6, c7, c8, c9 ) \
 2051   ( CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) &amp;&amp; \
 2052     ((unsigned char *) s)[ 8 ] == c9 )
 2053 #define CMP10( s, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10 ) \
 2054   ( CMP9( s, c1, c2, c3, c4, c5, c6, c7, c8, c9 ) &amp;&amp; \
 2055     ((unsigned char *) s)[ 9 ] == c10 )
 2056 
 2057 #define SKIP(val) do {                          \
 2058     ctxt-&gt;nbChars += (val),ctxt-&gt;input-&gt;cur += (val),ctxt-&gt;input-&gt;col+=(val);           \
 2059     if (*ctxt-&gt;input-&gt;cur == 0)                     \
 2060         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);           \
 2061   } while (0)
 2062 
 2063 #define SKIPL(val) do {                         \
 2064     int skipl;                              \
 2065     for(skipl=0; skipl&lt;val; skipl++) {                  \
 2066     if (*(ctxt-&gt;input-&gt;cur) == &#39;\n&#39;) {              \
 2067     ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;          \
 2068     } else ctxt-&gt;input-&gt;col++;                  \
 2069     ctxt-&gt;nbChars++;                        \
 2070     ctxt-&gt;input-&gt;cur++;                     \
 2071     }                                   \
 2072     if (*ctxt-&gt;input-&gt;cur == 0)                     \
 2073         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);           \
 2074   } while (0)
 2075 
 2076 #define SHRINK if ((ctxt-&gt;progressive == 0) &amp;&amp;              \
 2077            (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base &gt; 2 * INPUT_CHUNK) &amp;&amp; \
 2078            (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; 2 * INPUT_CHUNK)) \
 2079     xmlSHRINK (ctxt);
 2080 
 2081 static void xmlSHRINK (xmlParserCtxtPtr ctxt) {
 2082     xmlParserInputShrink(ctxt-&gt;input);
 2083     if (*ctxt-&gt;input-&gt;cur == 0)
 2084         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 2085 }
 2086 
 2087 #define GROW if ((ctxt-&gt;progressive == 0) &amp;&amp;                \
 2088          (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; INPUT_CHUNK))   \
 2089     xmlGROW (ctxt);
 2090 
 2091 static void xmlGROW (xmlParserCtxtPtr ctxt) {
<a name="10" id="anc10"></a><span class="line-modified"> 2092     ptrdiff_t curEnd = ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur;</span>
<span class="line-modified"> 2093     ptrdiff_t curBase = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;</span>
 2094 
<a name="11" id="anc11"></a><span class="line-modified"> 2095     if (((curEnd &gt; XML_MAX_LOOKUP_LIMIT) ||</span>
<span class="line-modified"> 2096          (curBase &gt; XML_MAX_LOOKUP_LIMIT)) &amp;&amp;</span>
 2097          ((ctxt-&gt;input-&gt;buf) &amp;&amp;
 2098           (ctxt-&gt;input-&gt;buf-&gt;readcallback != xmlInputReadCallbackNop)) &amp;&amp;
 2099         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 2100         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, &quot;Huge input lookup&quot;);
 2101         xmlHaltParser(ctxt);
 2102     return;
 2103     }
 2104     xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 2105     if ((ctxt-&gt;input-&gt;cur &gt; ctxt-&gt;input-&gt;end) ||
 2106         (ctxt-&gt;input-&gt;cur &lt; ctxt-&gt;input-&gt;base)) {
 2107         xmlHaltParser(ctxt);
 2108         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, &quot;cur index out of bound&quot;);
 2109     return;
 2110     }
 2111     if ((ctxt-&gt;input-&gt;cur != NULL) &amp;&amp; (*ctxt-&gt;input-&gt;cur == 0))
 2112         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 2113 }
 2114 
 2115 #define SKIP_BLANKS xmlSkipBlankChars(ctxt)
 2116 
 2117 #define NEXT xmlNextChar(ctxt)
 2118 
 2119 #define NEXT1 {                             \
 2120     ctxt-&gt;input-&gt;col++;                     \
 2121     ctxt-&gt;input-&gt;cur++;                     \
 2122     ctxt-&gt;nbChars++;                        \
 2123     if (*ctxt-&gt;input-&gt;cur == 0)                 \
 2124         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);       \
 2125     }
 2126 
 2127 #define NEXTL(l) do {                           \
 2128     if (*(ctxt-&gt;input-&gt;cur) == &#39;\n&#39;) {                  \
 2129     ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;          \
 2130     } else ctxt-&gt;input-&gt;col++;                      \
 2131     ctxt-&gt;input-&gt;cur += l;              \
 2132   } while (0)
 2133 
 2134 #define CUR_CHAR(l) xmlCurrentChar(ctxt, &amp;l)
 2135 #define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &amp;l)
 2136 
 2137 #define COPY_BUF(l,b,i,v)                       \
 2138     if (l == 1) b[i++] = (xmlChar) v;                   \
 2139     else i += xmlCopyCharMultiByte(&amp;b[i],v)
 2140 
 2141 /**
 2142  * xmlSkipBlankChars:
 2143  * @ctxt:  the XML parser context
 2144  *
 2145  * skip all blanks character found at that point in the input streams.
 2146  * It pops up finished entities in the process if allowable at that point.
 2147  *
 2148  * Returns the number of space chars skipped
 2149  */
 2150 
 2151 int
 2152 xmlSkipBlankChars(xmlParserCtxtPtr ctxt) {
 2153     int res = 0;
 2154 
 2155     /*
 2156      * It&#39;s Okay to use CUR/NEXT here since all the blanks are on
 2157      * the ASCII range.
 2158      */
 2159     if ((ctxt-&gt;inputNr == 1) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_DTD)) {
 2160     const xmlChar *cur;
 2161     /*
 2162      * if we are in the document content, go really fast
 2163      */
 2164     cur = ctxt-&gt;input-&gt;cur;
 2165     while (IS_BLANK_CH(*cur)) {
 2166         if (*cur == &#39;\n&#39;) {
 2167         ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;
 2168         } else {
 2169         ctxt-&gt;input-&gt;col++;
 2170         }
 2171         cur++;
 2172         res++;
 2173         if (*cur == 0) {
 2174         ctxt-&gt;input-&gt;cur = cur;
 2175         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 2176         cur = ctxt-&gt;input-&gt;cur;
 2177         }
 2178     }
 2179     ctxt-&gt;input-&gt;cur = cur;
 2180     } else {
 2181         int expandPE = ((ctxt-&gt;external != 0) || (ctxt-&gt;inputNr != 1));
 2182 
 2183     while (1) {
 2184             if (IS_BLANK_CH(CUR)) { /* CHECKED tstblanks.xml */
 2185         NEXT;
 2186         } else if (CUR == &#39;%&#39;) {
 2187                 /*
 2188                  * Need to handle support of entities branching here
 2189                  */
 2190             if ((expandPE == 0) || (IS_BLANK_CH(NXT(1))) || (NXT(1) == 0))
 2191                     break;
 2192             xmlParsePEReference(ctxt);
 2193             } else if (CUR == 0) {
 2194                 if (ctxt-&gt;inputNr &lt;= 1)
 2195                     break;
 2196                 xmlPopInput(ctxt);
 2197             } else {
 2198                 break;
 2199             }
 2200 
 2201             /*
 2202              * Also increase the counter when entering or exiting a PERef.
 2203              * The spec says: &quot;When a parameter-entity reference is recognized
 2204              * in the DTD and included, its replacement text MUST be enlarged
 2205              * by the attachment of one leading and one following space (#x20)
 2206              * character.&quot;
 2207              */
 2208         res++;
 2209         }
 2210     }
 2211     return(res);
 2212 }
 2213 
 2214 /************************************************************************
 2215  *                                  *
 2216  *      Commodity functions to handle entities          *
 2217  *                                  *
 2218  ************************************************************************/
 2219 
 2220 /**
 2221  * xmlPopInput:
 2222  * @ctxt:  an XML parser context
 2223  *
 2224  * xmlPopInput: the current input pointed by ctxt-&gt;input came to an end
 2225  *          pop it and return the next char.
 2226  *
 2227  * Returns the current xmlChar in the parser context
 2228  */
 2229 xmlChar
 2230 xmlPopInput(xmlParserCtxtPtr ctxt) {
 2231     if ((ctxt == NULL) || (ctxt-&gt;inputNr &lt;= 1)) return(0);
 2232     if (xmlParserDebugEntities)
 2233     xmlGenericError(xmlGenericErrorContext,
 2234         &quot;Popping input %d\n&quot;, ctxt-&gt;inputNr);
 2235     if ((ctxt-&gt;inputNr &gt; 1) &amp;&amp; (ctxt-&gt;inSubset == 0) &amp;&amp;
 2236         (ctxt-&gt;instate != XML_PARSER_EOF))
 2237         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 2238                     &quot;Unfinished entity outside the DTD&quot;);
 2239     xmlFreeInputStream(inputPop(ctxt));
 2240     if (*ctxt-&gt;input-&gt;cur == 0)
 2241         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 2242     return(CUR);
 2243 }
 2244 
 2245 /**
 2246  * xmlPushInput:
 2247  * @ctxt:  an XML parser context
 2248  * @input:  an XML parser input fragment (entity, XML fragment ...).
 2249  *
 2250  * xmlPushInput: switch to a new input stream which is stacked on top
 2251  *               of the previous one(s).
 2252  * Returns -1 in case of error or the index in the input stack
 2253  */
 2254 int
 2255 xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {
 2256     int ret;
 2257     if (input == NULL) return(-1);
 2258 
 2259     if (xmlParserDebugEntities) {
 2260     if ((ctxt-&gt;input != NULL) &amp;&amp; (ctxt-&gt;input-&gt;filename))
 2261         xmlGenericError(xmlGenericErrorContext,
 2262             &quot;%s(%d): &quot;, ctxt-&gt;input-&gt;filename,
 2263             ctxt-&gt;input-&gt;line);
 2264     xmlGenericError(xmlGenericErrorContext,
 2265         &quot;Pushing input %d : %.30s\n&quot;, ctxt-&gt;inputNr+1, input-&gt;cur);
 2266     }
 2267     if (((ctxt-&gt;inputNr &gt; 40) &amp;&amp; ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) ||
 2268         (ctxt-&gt;inputNr &gt; 1024)) {
 2269         xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 2270         while (ctxt-&gt;inputNr &gt; 1)
 2271             xmlFreeInputStream(inputPop(ctxt));
 2272     return(-1);
 2273     }
 2274     ret = inputPush(ctxt, input);
 2275     if (ctxt-&gt;instate == XML_PARSER_EOF)
 2276         return(-1);
 2277     GROW;
 2278     return(ret);
 2279 }
 2280 
 2281 /**
 2282  * xmlParseCharRef:
 2283  * @ctxt:  an XML parser context
 2284  *
 2285  * parse Reference declarations
 2286  *
 2287  * [66] CharRef ::= &#39;&amp;#&#39; [0-9]+ &#39;;&#39; |
 2288  *                  &#39;&amp;#x&#39; [0-9a-fA-F]+ &#39;;&#39;
 2289  *
 2290  * [ WFC: Legal Character ]
 2291  * Characters referred to using character references must match the
 2292  * production for Char.
 2293  *
 2294  * Returns the value parsed (as an int), 0 in case of error
 2295  */
 2296 int
 2297 xmlParseCharRef(xmlParserCtxtPtr ctxt) {
<a name="12" id="anc12"></a><span class="line-modified"> 2298     int val = 0;</span>
 2299     int count = 0;
<a name="13" id="anc13"></a>
 2300 
 2301     /*
 2302      * Using RAW/CUR/NEXT is okay since we are working on ASCII range here
 2303      */
 2304     if ((RAW == &#39;&amp;&#39;) &amp;&amp; (NXT(1) == &#39;#&#39;) &amp;&amp;
 2305         (NXT(2) == &#39;x&#39;)) {
 2306     SKIP(3);
 2307     GROW;
 2308     while (RAW != &#39;;&#39;) { /* loop blocked by count */
 2309         if (count++ &gt; 20) {
 2310         count = 0;
 2311         GROW;
 2312                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 2313                     return(0);
 2314         }
 2315         if ((RAW &gt;= &#39;0&#39;) &amp;&amp; (RAW &lt;= &#39;9&#39;))
 2316             val = val * 16 + (CUR - &#39;0&#39;);
 2317         else if ((RAW &gt;= &#39;a&#39;) &amp;&amp; (RAW &lt;= &#39;f&#39;) &amp;&amp; (count &lt; 20))
 2318             val = val * 16 + (CUR - &#39;a&#39;) + 10;
 2319         else if ((RAW &gt;= &#39;A&#39;) &amp;&amp; (RAW &lt;= &#39;F&#39;) &amp;&amp; (count &lt; 20))
 2320             val = val * 16 + (CUR - &#39;A&#39;) + 10;
 2321         else {
 2322         xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);
 2323         val = 0;
 2324         break;
 2325         }
<a name="14" id="anc14"></a><span class="line-modified"> 2326         if (val &gt; 0x110000)</span>
<span class="line-modified"> 2327             val = 0x110000;</span>
 2328 
 2329         NEXT;
 2330         count++;
 2331     }
 2332     if (RAW == &#39;;&#39;) {
 2333         /* on purpose to avoid reentrancy problems with NEXT and SKIP */
 2334         ctxt-&gt;input-&gt;col++;
 2335         ctxt-&gt;nbChars ++;
 2336         ctxt-&gt;input-&gt;cur++;
 2337     }
 2338     } else if  ((RAW == &#39;&amp;&#39;) &amp;&amp; (NXT(1) == &#39;#&#39;)) {
 2339     SKIP(2);
 2340     GROW;
 2341     while (RAW != &#39;;&#39;) { /* loop blocked by count */
 2342         if (count++ &gt; 20) {
 2343         count = 0;
 2344         GROW;
 2345                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 2346                     return(0);
 2347         }
 2348         if ((RAW &gt;= &#39;0&#39;) &amp;&amp; (RAW &lt;= &#39;9&#39;))
 2349             val = val * 10 + (CUR - &#39;0&#39;);
 2350         else {
 2351         xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);
 2352         val = 0;
 2353         break;
 2354         }
<a name="15" id="anc15"></a><span class="line-modified"> 2355         if (val &gt; 0x110000)</span>
<span class="line-modified"> 2356             val = 0x110000;</span>
 2357 
 2358         NEXT;
 2359         count++;
 2360     }
 2361     if (RAW == &#39;;&#39;) {
 2362         /* on purpose to avoid reentrancy problems with NEXT and SKIP */
 2363         ctxt-&gt;input-&gt;col++;
 2364         ctxt-&gt;nbChars ++;
 2365         ctxt-&gt;input-&gt;cur++;
 2366     }
 2367     } else {
 2368         xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);
 2369     }
 2370 
 2371     /*
 2372      * [ WFC: Legal Character ]
 2373      * Characters referred to using character references must match the
 2374      * production for Char.
 2375      */
<a name="16" id="anc16"></a><span class="line-modified"> 2376     if (val &gt;= 0x110000) {</span>
<span class="line-added"> 2377         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,</span>
<span class="line-added"> 2378                 &quot;xmlParseCharRef: character reference out of bounds\n&quot;,</span>
<span class="line-added"> 2379             val);</span>
<span class="line-added"> 2380     } else if (IS_CHAR(val)) {</span>
 2381         return(val);
 2382     } else {
 2383         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 2384                           &quot;xmlParseCharRef: invalid xmlChar value %d\n&quot;,
 2385                       val);
 2386     }
 2387     return(0);
 2388 }
 2389 
 2390 /**
 2391  * xmlParseStringCharRef:
 2392  * @ctxt:  an XML parser context
 2393  * @str:  a pointer to an index in the string
 2394  *
 2395  * parse Reference declarations, variant parsing from a string rather
 2396  * than an an input flow.
 2397  *
 2398  * [66] CharRef ::= &#39;&amp;#&#39; [0-9]+ &#39;;&#39; |
 2399  *                  &#39;&amp;#x&#39; [0-9a-fA-F]+ &#39;;&#39;
 2400  *
 2401  * [ WFC: Legal Character ]
 2402  * Characters referred to using character references must match the
 2403  * production for Char.
 2404  *
 2405  * Returns the value parsed (as an int), 0 in case of error, str will be
 2406  *         updated to the current value of the index
 2407  */
 2408 static int
 2409 xmlParseStringCharRef(xmlParserCtxtPtr ctxt, const xmlChar **str) {
 2410     const xmlChar *ptr;
 2411     xmlChar cur;
<a name="17" id="anc17"></a><span class="line-modified"> 2412     int val = 0;</span>

 2413 
 2414     if ((str == NULL) || (*str == NULL)) return(0);
 2415     ptr = *str;
 2416     cur = *ptr;
 2417     if ((cur == &#39;&amp;&#39;) &amp;&amp; (ptr[1] == &#39;#&#39;) &amp;&amp; (ptr[2] == &#39;x&#39;)) {
 2418     ptr += 3;
 2419     cur = *ptr;
 2420     while (cur != &#39;;&#39;) { /* Non input consuming loop */
 2421         if ((cur &gt;= &#39;0&#39;) &amp;&amp; (cur &lt;= &#39;9&#39;))
 2422             val = val * 16 + (cur - &#39;0&#39;);
 2423         else if ((cur &gt;= &#39;a&#39;) &amp;&amp; (cur &lt;= &#39;f&#39;))
 2424             val = val * 16 + (cur - &#39;a&#39;) + 10;
 2425         else if ((cur &gt;= &#39;A&#39;) &amp;&amp; (cur &lt;= &#39;F&#39;))
 2426             val = val * 16 + (cur - &#39;A&#39;) + 10;
 2427         else {
 2428         xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);
 2429         val = 0;
 2430         break;
 2431         }
<a name="18" id="anc18"></a><span class="line-modified"> 2432         if (val &gt; 0x110000)</span>
<span class="line-modified"> 2433             val = 0x110000;</span>
 2434 
 2435         ptr++;
 2436         cur = *ptr;
 2437     }
 2438     if (cur == &#39;;&#39;)
 2439         ptr++;
 2440     } else if  ((cur == &#39;&amp;&#39;) &amp;&amp; (ptr[1] == &#39;#&#39;)){
 2441     ptr += 2;
 2442     cur = *ptr;
 2443     while (cur != &#39;;&#39;) { /* Non input consuming loops */
 2444         if ((cur &gt;= &#39;0&#39;) &amp;&amp; (cur &lt;= &#39;9&#39;))
 2445             val = val * 10 + (cur - &#39;0&#39;);
 2446         else {
 2447         xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);
 2448         val = 0;
 2449         break;
 2450         }
<a name="19" id="anc19"></a><span class="line-modified"> 2451         if (val &gt; 0x110000)</span>
<span class="line-modified"> 2452             val = 0x110000;</span>
 2453 
 2454         ptr++;
 2455         cur = *ptr;
 2456     }
 2457     if (cur == &#39;;&#39;)
 2458         ptr++;
 2459     } else {
 2460     xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);
 2461     return(0);
 2462     }
 2463     *str = ptr;
 2464 
 2465     /*
 2466      * [ WFC: Legal Character ]
 2467      * Characters referred to using character references must match the
 2468      * production for Char.
 2469      */
<a name="20" id="anc20"></a><span class="line-modified"> 2470     if (val &gt;= 0x110000) {</span>
<span class="line-added"> 2471         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,</span>
<span class="line-added"> 2472                 &quot;xmlParseStringCharRef: character reference out of bounds\n&quot;,</span>
<span class="line-added"> 2473                 val);</span>
<span class="line-added"> 2474     } else if (IS_CHAR(val)) {</span>
 2475         return(val);
 2476     } else {
 2477         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 2478               &quot;xmlParseStringCharRef: invalid xmlChar value %d\n&quot;,
 2479               val);
 2480     }
 2481     return(0);
 2482 }
 2483 
 2484 /**
 2485  * xmlParserHandlePEReference:
 2486  * @ctxt:  the parser context
 2487  *
 2488  * [69] PEReference ::= &#39;%&#39; Name &#39;;&#39;
 2489  *
 2490  * [ WFC: No Recursion ]
 2491  * A parsed entity must not contain a recursive
 2492  * reference to itself, either directly or indirectly.
 2493  *
 2494  * [ WFC: Entity Declared ]
 2495  * In a document without any DTD, a document with only an internal DTD
 2496  * subset which contains no parameter entity references, or a document
 2497  * with &quot;standalone=&#39;yes&#39;&quot;, ...  ... The declaration of a parameter
 2498  * entity must precede any reference to it...
 2499  *
 2500  * [ VC: Entity Declared ]
 2501  * In a document with an external subset or external parameter entities
 2502  * with &quot;standalone=&#39;no&#39;&quot;, ...  ... The declaration of a parameter entity
 2503  * must precede any reference to it...
 2504  *
 2505  * [ WFC: In DTD ]
 2506  * Parameter-entity references may only appear in the DTD.
 2507  * NOTE: misleading but this is handled.
 2508  *
 2509  * A PEReference may have been detected in the current input stream
 2510  * the handling is done accordingly to
 2511  *      http://www.w3.org/TR/REC-xml#entproc
 2512  * i.e.
 2513  *   - Included in literal in entity values
 2514  *   - Included as Parameter Entity reference within DTDs
 2515  */
 2516 void
 2517 xmlParserHandlePEReference(xmlParserCtxtPtr ctxt) {
 2518     switch(ctxt-&gt;instate) {
 2519     case XML_PARSER_CDATA_SECTION:
 2520         return;
 2521         case XML_PARSER_COMMENT:
 2522         return;
 2523     case XML_PARSER_START_TAG:
 2524         return;
 2525     case XML_PARSER_END_TAG:
 2526         return;
 2527         case XML_PARSER_EOF:
 2528         xmlFatalErr(ctxt, XML_ERR_PEREF_AT_EOF, NULL);
 2529         return;
 2530         case XML_PARSER_PROLOG:
 2531     case XML_PARSER_START:
 2532     case XML_PARSER_MISC:
 2533         xmlFatalErr(ctxt, XML_ERR_PEREF_IN_PROLOG, NULL);
 2534         return;
 2535     case XML_PARSER_ENTITY_DECL:
 2536         case XML_PARSER_CONTENT:
 2537         case XML_PARSER_ATTRIBUTE_VALUE:
 2538         case XML_PARSER_PI:
 2539     case XML_PARSER_SYSTEM_LITERAL:
 2540     case XML_PARSER_PUBLIC_LITERAL:
 2541         /* we just ignore it there */
 2542         return;
 2543         case XML_PARSER_EPILOG:
 2544         xmlFatalErr(ctxt, XML_ERR_PEREF_IN_EPILOG, NULL);
 2545         return;
 2546     case XML_PARSER_ENTITY_VALUE:
 2547         /*
 2548          * NOTE: in the case of entity values, we don&#39;t do the
 2549          *       substitution here since we need the literal
 2550          *       entity value to be able to save the internal
 2551          *       subset of the document.
 2552          *       This will be handled by xmlStringDecodeEntities
 2553          */
 2554         return;
 2555         case XML_PARSER_DTD:
 2556         /*
 2557          * [WFC: Well-Formedness Constraint: PEs in Internal Subset]
 2558          * In the internal DTD subset, parameter-entity references
 2559          * can occur only where markup declarations can occur, not
 2560          * within markup declarations.
 2561          * In that case this is handled in xmlParseMarkupDecl
 2562          */
 2563         if ((ctxt-&gt;external == 0) &amp;&amp; (ctxt-&gt;inputNr == 1))
 2564         return;
 2565         if (IS_BLANK_CH(NXT(1)) || NXT(1) == 0)
 2566         return;
 2567             break;
 2568         case XML_PARSER_IGNORE:
 2569             return;
 2570     }
 2571 
 2572     xmlParsePEReference(ctxt);
 2573 }
 2574 
 2575 /*
 2576  * Macro used to grow the current buffer.
 2577  * buffer##_size is expected to be a size_t
 2578  * mem_error: is expected to handle memory allocation failures
 2579  */
 2580 #define growBuffer(buffer, n) {                     \
 2581     xmlChar *tmp;                           \
 2582     size_t new_size = buffer##_size * 2 + n;                            \
 2583     if (new_size &lt; buffer##_size) goto mem_error;                       \
 2584     tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
 2585     if (tmp == NULL) goto mem_error;                    \
 2586     buffer = tmp;                           \
 2587     buffer##_size = new_size;                                           \
 2588 }
 2589 
 2590 /**
 2591  * xmlStringLenDecodeEntities:
 2592  * @ctxt:  the parser context
 2593  * @str:  the input string
 2594  * @len: the string length
 2595  * @what:  combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF
 2596  * @end:  an end marker xmlChar, 0 if none
 2597  * @end2:  an end marker xmlChar, 0 if none
 2598  * @end3:  an end marker xmlChar, 0 if none
 2599  *
 2600  * Takes a entity string content and process to do the adequate substitutions.
 2601  *
 2602  * [67] Reference ::= EntityRef | CharRef
 2603  *
 2604  * [69] PEReference ::= &#39;%&#39; Name &#39;;&#39;
 2605  *
 2606  * Returns A newly allocated string with the substitution done. The caller
 2607  *      must deallocate it !
 2608  */
 2609 xmlChar *
 2610 xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int len,
 2611               int what, xmlChar end, xmlChar  end2, xmlChar end3) {
 2612     xmlChar *buffer = NULL;
 2613     size_t buffer_size = 0;
 2614     size_t nbchars = 0;
 2615 
 2616     xmlChar *current = NULL;
 2617     xmlChar *rep = NULL;
 2618     const xmlChar *last;
 2619     xmlEntityPtr ent;
 2620     int c,l;
 2621 
 2622     if ((ctxt == NULL) || (str == NULL) || (len &lt; 0))
 2623     return(NULL);
 2624     last = str + len;
 2625 
 2626     if (((ctxt-&gt;depth &gt; 40) &amp;&amp;
 2627          ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) ||
 2628     (ctxt-&gt;depth &gt; 1024)) {
 2629     xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 2630     return(NULL);
 2631     }
 2632 
 2633     /*
 2634      * allocate a translation buffer.
 2635      */
 2636     buffer_size = XML_PARSER_BIG_BUFFER_SIZE;
 2637     buffer = (xmlChar *) xmlMallocAtomic(buffer_size);
 2638     if (buffer == NULL) goto mem_error;
 2639 
 2640     /*
 2641      * OK loop until we reach one of the ending char or a size limit.
 2642      * we are operating on already parsed values.
 2643      */
 2644     if (str &lt; last)
 2645     c = CUR_SCHAR(str, l);
 2646     else
 2647         c = 0;
 2648     while ((c != 0) &amp;&amp; (c != end) &amp;&amp; /* non input consuming loop */
 2649        (c != end2) &amp;&amp; (c != end3)) {
 2650 
 2651     if (c == 0) break;
 2652         if ((c == &#39;&amp;&#39;) &amp;&amp; (str[1] == &#39;#&#39;)) {
 2653         int val = xmlParseStringCharRef(ctxt, &amp;str);
 2654         if (val == 0)
 2655                 goto int_error;
 2656         COPY_BUF(0,buffer,nbchars,val);
 2657         if (nbchars + XML_PARSER_BUFFER_SIZE &gt; buffer_size) {
 2658             growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
 2659         }
 2660     } else if ((c == &#39;&amp;&#39;) &amp;&amp; (what &amp; XML_SUBSTITUTE_REF)) {
 2661         if (xmlParserDebugEntities)
 2662         xmlGenericError(xmlGenericErrorContext,
 2663             &quot;String decoding Entity Reference: %.30s\n&quot;,
 2664             str);
 2665         ent = xmlParseStringEntityRef(ctxt, &amp;str);
 2666         xmlParserEntityCheck(ctxt, 0, ent, 0);
 2667         if (ent != NULL)
 2668             ctxt-&gt;nbentities += ent-&gt;checked / 2;
 2669         if ((ent != NULL) &amp;&amp;
 2670         (ent-&gt;etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
 2671         if (ent-&gt;content != NULL) {
 2672             COPY_BUF(0,buffer,nbchars,ent-&gt;content[0]);
 2673             if (nbchars + XML_PARSER_BUFFER_SIZE &gt; buffer_size) {
 2674             growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
 2675             }
 2676         } else {
 2677             xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
 2678                 &quot;predefined entity has no content\n&quot;);
 2679                     goto int_error;
 2680         }
 2681         } else if ((ent != NULL) &amp;&amp; (ent-&gt;content != NULL)) {
 2682         ctxt-&gt;depth++;
 2683         rep = xmlStringDecodeEntities(ctxt, ent-&gt;content, what,
 2684                                   0, 0, 0);
 2685         ctxt-&gt;depth--;
 2686         if (rep == NULL)
 2687                     goto int_error;
 2688 
 2689                 current = rep;
 2690                 while (*current != 0) { /* non input consuming loop */
 2691                     buffer[nbchars++] = *current++;
 2692                     if (nbchars + XML_PARSER_BUFFER_SIZE &gt; buffer_size) {
 2693                         if (xmlParserEntityCheck(ctxt, nbchars, ent, 0))
 2694                             goto int_error;
 2695                         growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
 2696                     }
 2697                 }
 2698                 xmlFree(rep);
 2699                 rep = NULL;
 2700         } else if (ent != NULL) {
 2701         int i = xmlStrlen(ent-&gt;name);
 2702         const xmlChar *cur = ent-&gt;name;
 2703 
 2704         buffer[nbchars++] = &#39;&amp;&#39;;
 2705         if (nbchars + i + XML_PARSER_BUFFER_SIZE &gt; buffer_size) {
 2706             growBuffer(buffer, i + XML_PARSER_BUFFER_SIZE);
 2707         }
 2708         for (;i &gt; 0;i--)
 2709             buffer[nbchars++] = *cur++;
 2710         buffer[nbchars++] = &#39;;&#39;;
 2711         }
 2712     } else if (c == &#39;%&#39; &amp;&amp; (what &amp; XML_SUBSTITUTE_PEREF)) {
 2713         if (xmlParserDebugEntities)
 2714         xmlGenericError(xmlGenericErrorContext,
 2715             &quot;String decoding PE Reference: %.30s\n&quot;, str);
 2716         ent = xmlParseStringPEReference(ctxt, &amp;str);
 2717         xmlParserEntityCheck(ctxt, 0, ent, 0);
 2718         if (ent != NULL)
 2719             ctxt-&gt;nbentities += ent-&gt;checked / 2;
 2720         if (ent != NULL) {
 2721                 if (ent-&gt;content == NULL) {
 2722             /*
 2723              * Note: external parsed entities will not be loaded,
 2724              * it is not required for a non-validating parser to
<a name="21" id="anc21"></a><span class="line-modified"> 2725              * complete external PEReferences coming from the</span>
 2726              * internal subset
 2727              */
 2728             if (((ctxt-&gt;options &amp; XML_PARSE_NOENT) != 0) ||
 2729             ((ctxt-&gt;options &amp; XML_PARSE_DTDVALID) != 0) ||
 2730             (ctxt-&gt;validate != 0)) {
 2731             xmlLoadEntityContent(ctxt, ent);
 2732             } else {
 2733             xmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
 2734           &quot;not validating will not read content for PE entity %s\n&quot;,
 2735                               ent-&gt;name, NULL);
 2736             }
 2737         }
 2738         ctxt-&gt;depth++;
 2739         rep = xmlStringDecodeEntities(ctxt, ent-&gt;content, what,
 2740                                   0, 0, 0);
 2741         ctxt-&gt;depth--;
 2742         if (rep == NULL)
 2743                     goto int_error;
 2744                 current = rep;
 2745                 while (*current != 0) { /* non input consuming loop */
 2746                     buffer[nbchars++] = *current++;
 2747                     if (nbchars + XML_PARSER_BUFFER_SIZE &gt; buffer_size) {
 2748                         if (xmlParserEntityCheck(ctxt, nbchars, ent, 0))
 2749                             goto int_error;
 2750                         growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
 2751                     }
 2752                 }
 2753                 xmlFree(rep);
 2754                 rep = NULL;
 2755         }
 2756     } else {
 2757         COPY_BUF(l,buffer,nbchars,c);
 2758         str += l;
 2759         if (nbchars + XML_PARSER_BUFFER_SIZE &gt; buffer_size) {
 2760             growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
 2761         }
 2762     }
 2763     if (str &lt; last)
 2764         c = CUR_SCHAR(str, l);
 2765     else
 2766         c = 0;
 2767     }
 2768     buffer[nbchars] = 0;
 2769     return(buffer);
 2770 
 2771 mem_error:
 2772     xmlErrMemory(ctxt, NULL);
 2773 int_error:
 2774     if (rep != NULL)
 2775         xmlFree(rep);
 2776     if (buffer != NULL)
 2777         xmlFree(buffer);
 2778     return(NULL);
 2779 }
 2780 
 2781 /**
 2782  * xmlStringDecodeEntities:
 2783  * @ctxt:  the parser context
 2784  * @str:  the input string
 2785  * @what:  combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF
 2786  * @end:  an end marker xmlChar, 0 if none
 2787  * @end2:  an end marker xmlChar, 0 if none
 2788  * @end3:  an end marker xmlChar, 0 if none
 2789  *
 2790  * Takes a entity string content and process to do the adequate substitutions.
 2791  *
 2792  * [67] Reference ::= EntityRef | CharRef
 2793  *
 2794  * [69] PEReference ::= &#39;%&#39; Name &#39;;&#39;
 2795  *
 2796  * Returns A newly allocated string with the substitution done. The caller
 2797  *      must deallocate it !
 2798  */
 2799 xmlChar *
 2800 xmlStringDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int what,
 2801                 xmlChar end, xmlChar  end2, xmlChar end3) {
 2802     if ((ctxt == NULL) || (str == NULL)) return(NULL);
 2803     return(xmlStringLenDecodeEntities(ctxt, str, xmlStrlen(str), what,
 2804            end, end2, end3));
 2805 }
 2806 
 2807 /************************************************************************
 2808  *                                  *
 2809  *      Commodity functions, cleanup needed ?           *
 2810  *                                  *
 2811  ************************************************************************/
 2812 
 2813 /**
 2814  * areBlanks:
 2815  * @ctxt:  an XML parser context
 2816  * @str:  a xmlChar *
 2817  * @len:  the size of @str
 2818  * @blank_chars: we know the chars are blanks
 2819  *
 2820  * Is this a sequence of blank chars that one can ignore ?
 2821  *
 2822  * Returns 1 if ignorable 0 otherwise.
 2823  */
 2824 
 2825 static int areBlanks(xmlParserCtxtPtr ctxt, const xmlChar *str, int len,
 2826                      int blank_chars) {
 2827     int i, ret;
 2828     xmlNodePtr lastChild;
 2829 
 2830     /*
 2831      * Don&#39;t spend time trying to differentiate them, the same callback is
 2832      * used !
 2833      */
 2834     if (ctxt-&gt;sax-&gt;ignorableWhitespace == ctxt-&gt;sax-&gt;characters)
 2835     return(0);
 2836 
 2837     /*
 2838      * Check for xml:space value.
 2839      */
 2840     if ((ctxt-&gt;space == NULL) || (*(ctxt-&gt;space) == 1) ||
 2841         (*(ctxt-&gt;space) == -2))
 2842     return(0);
 2843 
 2844     /*
 2845      * Check that the string is made of blanks
 2846      */
 2847     if (blank_chars == 0) {
 2848     for (i = 0;i &lt; len;i++)
 2849         if (!(IS_BLANK_CH(str[i]))) return(0);
 2850     }
 2851 
 2852     /*
 2853      * Look if the element is mixed content in the DTD if available
 2854      */
 2855     if (ctxt-&gt;node == NULL) return(0);
 2856     if (ctxt-&gt;myDoc != NULL) {
 2857     ret = xmlIsMixedElement(ctxt-&gt;myDoc, ctxt-&gt;node-&gt;name);
 2858         if (ret == 0) return(1);
 2859         if (ret == 1) return(0);
 2860     }
 2861 
 2862     /*
 2863      * Otherwise, heuristic :-\
 2864      */
 2865     if ((RAW != &#39;&lt;&#39;) &amp;&amp; (RAW != 0xD)) return(0);
 2866     if ((ctxt-&gt;node-&gt;children == NULL) &amp;&amp;
 2867     (RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) return(0);
 2868 
 2869     lastChild = xmlGetLastChild(ctxt-&gt;node);
 2870     if (lastChild == NULL) {
 2871         if ((ctxt-&gt;node-&gt;type != XML_ELEMENT_NODE) &amp;&amp;
 2872             (ctxt-&gt;node-&gt;content != NULL)) return(0);
 2873     } else if (xmlNodeIsText(lastChild))
 2874         return(0);
 2875     else if ((ctxt-&gt;node-&gt;children != NULL) &amp;&amp;
 2876              (xmlNodeIsText(ctxt-&gt;node-&gt;children)))
 2877         return(0);
 2878     return(1);
 2879 }
 2880 
 2881 /************************************************************************
 2882  *                                  *
 2883  *      Extra stuff for namespace support           *
 2884  *  Relates to http://www.w3.org/TR/WD-xml-names            *
 2885  *                                  *
 2886  ************************************************************************/
 2887 
 2888 /**
 2889  * xmlSplitQName:
 2890  * @ctxt:  an XML parser context
 2891  * @name:  an XML parser context
 2892  * @prefix:  a xmlChar **
 2893  *
 2894  * parse an UTF8 encoded XML qualified name string
 2895  *
 2896  * [NS 5] QName ::= (Prefix &#39;:&#39;)? LocalPart
 2897  *
 2898  * [NS 6] Prefix ::= NCName
 2899  *
 2900  * [NS 7] LocalPart ::= NCName
 2901  *
 2902  * Returns the local part, and prefix is updated
 2903  *   to get the Prefix if any.
 2904  */
 2905 
 2906 xmlChar *
 2907 xmlSplitQName(xmlParserCtxtPtr ctxt, const xmlChar *name, xmlChar **prefix) {
 2908     xmlChar buf[XML_MAX_NAMELEN + 5];
 2909     xmlChar *buffer = NULL;
 2910     int len = 0;
 2911     int max = XML_MAX_NAMELEN;
 2912     xmlChar *ret = NULL;
 2913     const xmlChar *cur = name;
 2914     int c;
 2915 
 2916     if (prefix == NULL) return(NULL);
 2917     *prefix = NULL;
 2918 
 2919     if (cur == NULL) return(NULL);
 2920 
 2921 #ifndef XML_XML_NAMESPACE
 2922     /* xml: prefix is not really a namespace */
 2923     if ((cur[0] == &#39;x&#39;) &amp;&amp; (cur[1] == &#39;m&#39;) &amp;&amp;
 2924         (cur[2] == &#39;l&#39;) &amp;&amp; (cur[3] == &#39;:&#39;))
 2925     return(xmlStrdup(name));
 2926 #endif
 2927 
 2928     /* nasty but well=formed */
 2929     if (cur[0] == &#39;:&#39;)
 2930     return(xmlStrdup(name));
 2931 
 2932     c = *cur++;
 2933     while ((c != 0) &amp;&amp; (c != &#39;:&#39;) &amp;&amp; (len &lt; max)) { /* tested bigname.xml */
 2934     buf[len++] = c;
 2935     c = *cur++;
 2936     }
 2937     if (len &gt;= max) {
 2938     /*
 2939      * Okay someone managed to make a huge name, so he&#39;s ready to pay
 2940      * for the processing speed.
 2941      */
 2942     max = len * 2;
 2943 
 2944     buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));
 2945     if (buffer == NULL) {
 2946         xmlErrMemory(ctxt, NULL);
 2947         return(NULL);
 2948     }
 2949     memcpy(buffer, buf, len);
 2950     while ((c != 0) &amp;&amp; (c != &#39;:&#39;)) { /* tested bigname.xml */
 2951         if (len + 10 &gt; max) {
 2952             xmlChar *tmp;
 2953 
 2954         max *= 2;
 2955         tmp = (xmlChar *) xmlRealloc(buffer,
 2956                         max * sizeof(xmlChar));
 2957         if (tmp == NULL) {
 2958             xmlFree(buffer);
 2959             xmlErrMemory(ctxt, NULL);
 2960             return(NULL);
 2961         }
 2962         buffer = tmp;
 2963         }
 2964         buffer[len++] = c;
 2965         c = *cur++;
 2966     }
 2967     buffer[len] = 0;
 2968     }
 2969 
 2970     if ((c == &#39;:&#39;) &amp;&amp; (*cur == 0)) {
 2971         if (buffer != NULL)
 2972         xmlFree(buffer);
 2973     *prefix = NULL;
 2974     return(xmlStrdup(name));
 2975     }
 2976 
 2977     if (buffer == NULL)
 2978     ret = xmlStrndup(buf, len);
 2979     else {
 2980     ret = buffer;
 2981     buffer = NULL;
 2982     max = XML_MAX_NAMELEN;
 2983     }
 2984 
 2985 
 2986     if (c == &#39;:&#39;) {
 2987     c = *cur;
 2988         *prefix = ret;
 2989     if (c == 0) {
 2990         return(xmlStrndup(BAD_CAST &quot;&quot;, 0));
 2991     }
 2992     len = 0;
 2993 
 2994     /*
 2995      * Check that the first character is proper to start
 2996      * a new name
 2997      */
 2998     if (!(((c &gt;= 0x61) &amp;&amp; (c &lt;= 0x7A)) ||
 2999           ((c &gt;= 0x41) &amp;&amp; (c &lt;= 0x5A)) ||
 3000           (c == &#39;_&#39;) || (c == &#39;:&#39;))) {
 3001         int l;
 3002         int first = CUR_SCHAR(cur, l);
 3003 
 3004         if (!IS_LETTER(first) &amp;&amp; (first != &#39;_&#39;)) {
 3005         xmlFatalErrMsgStr(ctxt, XML_NS_ERR_QNAME,
 3006                 &quot;Name %s is not XML Namespace compliant\n&quot;,
 3007                   name);
 3008         }
 3009     }
 3010     cur++;
 3011 
 3012     while ((c != 0) &amp;&amp; (len &lt; max)) { /* tested bigname2.xml */
 3013         buf[len++] = c;
 3014         c = *cur++;
 3015     }
 3016     if (len &gt;= max) {
 3017         /*
 3018          * Okay someone managed to make a huge name, so he&#39;s ready to pay
 3019          * for the processing speed.
 3020          */
 3021         max = len * 2;
 3022 
 3023         buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));
 3024         if (buffer == NULL) {
 3025             xmlErrMemory(ctxt, NULL);
 3026         return(NULL);
 3027         }
 3028         memcpy(buffer, buf, len);
 3029         while (c != 0) { /* tested bigname2.xml */
 3030         if (len + 10 &gt; max) {
 3031             xmlChar *tmp;
 3032 
 3033             max *= 2;
 3034             tmp = (xmlChar *) xmlRealloc(buffer,
 3035                             max * sizeof(xmlChar));
 3036             if (tmp == NULL) {
 3037             xmlErrMemory(ctxt, NULL);
 3038             xmlFree(buffer);
 3039             return(NULL);
 3040             }
 3041             buffer = tmp;
 3042         }
 3043         buffer[len++] = c;
 3044         c = *cur++;
 3045         }
 3046         buffer[len] = 0;
 3047     }
 3048 
 3049     if (buffer == NULL)
 3050         ret = xmlStrndup(buf, len);
 3051     else {
 3052         ret = buffer;
 3053     }
 3054     }
 3055 
 3056     return(ret);
 3057 }
 3058 
 3059 /************************************************************************
 3060  *                                  *
 3061  *          The parser itself               *
 3062  *  Relates to http://www.w3.org/TR/REC-xml             *
 3063  *                                  *
 3064  ************************************************************************/
 3065 
 3066 /************************************************************************
 3067  *                                  *
 3068  *  Routines to parse Name, NCName and NmToken          *
 3069  *                                  *
 3070  ************************************************************************/
 3071 #ifdef DEBUG
 3072 static unsigned long nbParseName = 0;
 3073 static unsigned long nbParseNmToken = 0;
 3074 static unsigned long nbParseNCName = 0;
 3075 static unsigned long nbParseNCNameComplex = 0;
 3076 static unsigned long nbParseNameComplex = 0;
 3077 static unsigned long nbParseStringName = 0;
 3078 #endif
 3079 
 3080 /*
 3081  * The two following functions are related to the change of accepted
 3082  * characters for Name and NmToken in the Revision 5 of XML-1.0
 3083  * They correspond to the modified production [4] and the new production [4a]
 3084  * changes in that revision. Also note that the macros used for the
 3085  * productions Letter, Digit, CombiningChar and Extender are not needed
 3086  * anymore.
 3087  * We still keep compatibility to pre-revision5 parsing semantic if the
 3088  * new XML_PARSE_OLD10 option is given to the parser.
 3089  */
 3090 static int
 3091 xmlIsNameStartChar(xmlParserCtxtPtr ctxt, int c) {
 3092     if ((ctxt-&gt;options &amp; XML_PARSE_OLD10) == 0) {
 3093         /*
 3094      * Use the new checks of production [4] [4a] amd [5] of the
 3095      * Update 5 of XML-1.0
 3096      */
 3097     if ((c != &#39; &#39;) &amp;&amp; (c != &#39;&gt;&#39;) &amp;&amp; (c != &#39;/&#39;) &amp;&amp; /* accelerators */
 3098         (((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;z&#39;)) ||
 3099          ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;Z&#39;)) ||
 3100          (c == &#39;_&#39;) || (c == &#39;:&#39;) ||
 3101          ((c &gt;= 0xC0) &amp;&amp; (c &lt;= 0xD6)) ||
 3102          ((c &gt;= 0xD8) &amp;&amp; (c &lt;= 0xF6)) ||
 3103          ((c &gt;= 0xF8) &amp;&amp; (c &lt;= 0x2FF)) ||
 3104          ((c &gt;= 0x370) &amp;&amp; (c &lt;= 0x37D)) ||
 3105          ((c &gt;= 0x37F) &amp;&amp; (c &lt;= 0x1FFF)) ||
 3106          ((c &gt;= 0x200C) &amp;&amp; (c &lt;= 0x200D)) ||
 3107          ((c &gt;= 0x2070) &amp;&amp; (c &lt;= 0x218F)) ||
 3108          ((c &gt;= 0x2C00) &amp;&amp; (c &lt;= 0x2FEF)) ||
 3109          ((c &gt;= 0x3001) &amp;&amp; (c &lt;= 0xD7FF)) ||
 3110          ((c &gt;= 0xF900) &amp;&amp; (c &lt;= 0xFDCF)) ||
 3111          ((c &gt;= 0xFDF0) &amp;&amp; (c &lt;= 0xFFFD)) ||
 3112          ((c &gt;= 0x10000) &amp;&amp; (c &lt;= 0xEFFFF))))
 3113         return(1);
 3114     } else {
 3115         if (IS_LETTER(c) || (c == &#39;_&#39;) || (c == &#39;:&#39;))
 3116         return(1);
 3117     }
 3118     return(0);
 3119 }
 3120 
 3121 static int
 3122 xmlIsNameChar(xmlParserCtxtPtr ctxt, int c) {
 3123     if ((ctxt-&gt;options &amp; XML_PARSE_OLD10) == 0) {
 3124         /*
 3125      * Use the new checks of production [4] [4a] amd [5] of the
 3126      * Update 5 of XML-1.0
 3127      */
 3128     if ((c != &#39; &#39;) &amp;&amp; (c != &#39;&gt;&#39;) &amp;&amp; (c != &#39;/&#39;) &amp;&amp; /* accelerators */
 3129         (((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;z&#39;)) ||
 3130          ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;Z&#39;)) ||
 3131          ((c &gt;= &#39;0&#39;) &amp;&amp; (c &lt;= &#39;9&#39;)) || /* !start */
 3132          (c == &#39;_&#39;) || (c == &#39;:&#39;) ||
 3133          (c == &#39;-&#39;) || (c == &#39;.&#39;) || (c == 0xB7) || /* !start */
 3134          ((c &gt;= 0xC0) &amp;&amp; (c &lt;= 0xD6)) ||
 3135          ((c &gt;= 0xD8) &amp;&amp; (c &lt;= 0xF6)) ||
 3136          ((c &gt;= 0xF8) &amp;&amp; (c &lt;= 0x2FF)) ||
 3137          ((c &gt;= 0x300) &amp;&amp; (c &lt;= 0x36F)) || /* !start */
 3138          ((c &gt;= 0x370) &amp;&amp; (c &lt;= 0x37D)) ||
 3139          ((c &gt;= 0x37F) &amp;&amp; (c &lt;= 0x1FFF)) ||
 3140          ((c &gt;= 0x200C) &amp;&amp; (c &lt;= 0x200D)) ||
 3141          ((c &gt;= 0x203F) &amp;&amp; (c &lt;= 0x2040)) || /* !start */
 3142          ((c &gt;= 0x2070) &amp;&amp; (c &lt;= 0x218F)) ||
 3143          ((c &gt;= 0x2C00) &amp;&amp; (c &lt;= 0x2FEF)) ||
 3144          ((c &gt;= 0x3001) &amp;&amp; (c &lt;= 0xD7FF)) ||
 3145          ((c &gt;= 0xF900) &amp;&amp; (c &lt;= 0xFDCF)) ||
 3146          ((c &gt;= 0xFDF0) &amp;&amp; (c &lt;= 0xFFFD)) ||
 3147          ((c &gt;= 0x10000) &amp;&amp; (c &lt;= 0xEFFFF))))
 3148          return(1);
 3149     } else {
 3150         if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
 3151             (c == &#39;.&#39;) || (c == &#39;-&#39;) ||
 3152         (c == &#39;_&#39;) || (c == &#39;:&#39;) ||
 3153         (IS_COMBINING(c)) ||
 3154         (IS_EXTENDER(c)))
 3155         return(1);
 3156     }
 3157     return(0);
 3158 }
 3159 
 3160 static xmlChar * xmlParseAttValueInternal(xmlParserCtxtPtr ctxt,
 3161                                           int *len, int *alloc, int normalize);
 3162 
 3163 static const xmlChar *
 3164 xmlParseNameComplex(xmlParserCtxtPtr ctxt) {
 3165     int len = 0, l;
 3166     int c;
 3167     int count = 0;
 3168 
 3169 #ifdef DEBUG
 3170     nbParseNameComplex++;
 3171 #endif
 3172 
 3173     /*
 3174      * Handler for more complex cases
 3175      */
 3176     GROW;
 3177     if (ctxt-&gt;instate == XML_PARSER_EOF)
 3178         return(NULL);
 3179     c = CUR_CHAR(l);
 3180     if ((ctxt-&gt;options &amp; XML_PARSE_OLD10) == 0) {
 3181         /*
 3182      * Use the new checks of production [4] [4a] amd [5] of the
 3183      * Update 5 of XML-1.0
 3184      */
 3185     if ((c == &#39; &#39;) || (c == &#39;&gt;&#39;) || (c == &#39;/&#39;) || /* accelerators */
 3186         (!(((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;z&#39;)) ||
 3187            ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;Z&#39;)) ||
 3188            (c == &#39;_&#39;) || (c == &#39;:&#39;) ||
 3189            ((c &gt;= 0xC0) &amp;&amp; (c &lt;= 0xD6)) ||
 3190            ((c &gt;= 0xD8) &amp;&amp; (c &lt;= 0xF6)) ||
 3191            ((c &gt;= 0xF8) &amp;&amp; (c &lt;= 0x2FF)) ||
 3192            ((c &gt;= 0x370) &amp;&amp; (c &lt;= 0x37D)) ||
 3193            ((c &gt;= 0x37F) &amp;&amp; (c &lt;= 0x1FFF)) ||
 3194            ((c &gt;= 0x200C) &amp;&amp; (c &lt;= 0x200D)) ||
 3195            ((c &gt;= 0x2070) &amp;&amp; (c &lt;= 0x218F)) ||
 3196            ((c &gt;= 0x2C00) &amp;&amp; (c &lt;= 0x2FEF)) ||
 3197            ((c &gt;= 0x3001) &amp;&amp; (c &lt;= 0xD7FF)) ||
 3198            ((c &gt;= 0xF900) &amp;&amp; (c &lt;= 0xFDCF)) ||
 3199            ((c &gt;= 0xFDF0) &amp;&amp; (c &lt;= 0xFFFD)) ||
 3200            ((c &gt;= 0x10000) &amp;&amp; (c &lt;= 0xEFFFF))))) {
 3201         return(NULL);
 3202     }
 3203     len += l;
 3204     NEXTL(l);
 3205     c = CUR_CHAR(l);
 3206     while ((c != &#39; &#39;) &amp;&amp; (c != &#39;&gt;&#39;) &amp;&amp; (c != &#39;/&#39;) &amp;&amp; /* accelerators */
 3207            (((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;z&#39;)) ||
 3208             ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;Z&#39;)) ||
 3209             ((c &gt;= &#39;0&#39;) &amp;&amp; (c &lt;= &#39;9&#39;)) || /* !start */
 3210             (c == &#39;_&#39;) || (c == &#39;:&#39;) ||
 3211             (c == &#39;-&#39;) || (c == &#39;.&#39;) || (c == 0xB7) || /* !start */
 3212             ((c &gt;= 0xC0) &amp;&amp; (c &lt;= 0xD6)) ||
 3213             ((c &gt;= 0xD8) &amp;&amp; (c &lt;= 0xF6)) ||
 3214             ((c &gt;= 0xF8) &amp;&amp; (c &lt;= 0x2FF)) ||
 3215             ((c &gt;= 0x300) &amp;&amp; (c &lt;= 0x36F)) || /* !start */
 3216             ((c &gt;= 0x370) &amp;&amp; (c &lt;= 0x37D)) ||
 3217             ((c &gt;= 0x37F) &amp;&amp; (c &lt;= 0x1FFF)) ||
 3218             ((c &gt;= 0x200C) &amp;&amp; (c &lt;= 0x200D)) ||
 3219             ((c &gt;= 0x203F) &amp;&amp; (c &lt;= 0x2040)) || /* !start */
 3220             ((c &gt;= 0x2070) &amp;&amp; (c &lt;= 0x218F)) ||
 3221             ((c &gt;= 0x2C00) &amp;&amp; (c &lt;= 0x2FEF)) ||
 3222             ((c &gt;= 0x3001) &amp;&amp; (c &lt;= 0xD7FF)) ||
 3223             ((c &gt;= 0xF900) &amp;&amp; (c &lt;= 0xFDCF)) ||
 3224             ((c &gt;= 0xFDF0) &amp;&amp; (c &lt;= 0xFFFD)) ||
 3225             ((c &gt;= 0x10000) &amp;&amp; (c &lt;= 0xEFFFF))
 3226         )) {
 3227         if (count++ &gt; XML_PARSER_CHUNK_SIZE) {
 3228         count = 0;
 3229         GROW;
 3230                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 3231                     return(NULL);
 3232         }
 3233         len += l;
 3234         NEXTL(l);
 3235         c = CUR_CHAR(l);
 3236     }
 3237     } else {
 3238     if ((c == &#39; &#39;) || (c == &#39;&gt;&#39;) || (c == &#39;/&#39;) || /* accelerators */
 3239         (!IS_LETTER(c) &amp;&amp; (c != &#39;_&#39;) &amp;&amp;
 3240          (c != &#39;:&#39;))) {
 3241         return(NULL);
 3242     }
 3243     len += l;
 3244     NEXTL(l);
 3245     c = CUR_CHAR(l);
 3246 
 3247     while ((c != &#39; &#39;) &amp;&amp; (c != &#39;&gt;&#39;) &amp;&amp; (c != &#39;/&#39;) &amp;&amp; /* test bigname.xml */
 3248            ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
 3249         (c == &#39;.&#39;) || (c == &#39;-&#39;) ||
 3250         (c == &#39;_&#39;) || (c == &#39;:&#39;) ||
 3251         (IS_COMBINING(c)) ||
 3252         (IS_EXTENDER(c)))) {
 3253         if (count++ &gt; XML_PARSER_CHUNK_SIZE) {
 3254         count = 0;
 3255         GROW;
 3256                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 3257                     return(NULL);
 3258         }
 3259         len += l;
 3260         NEXTL(l);
 3261         c = CUR_CHAR(l);
 3262     }
 3263     }
 3264     if ((len &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3265         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3266         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;Name&quot;);
 3267         return(NULL);
 3268     }
 3269     if (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base &lt; len) {
 3270         /*
 3271          * There were a couple of bugs where PERefs lead to to a change
 3272          * of the buffer. Check the buffer size to avoid passing an invalid
 3273          * pointer to xmlDictLookup.
 3274          */
 3275         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 3276                     &quot;unexpected change of input buffer&quot;);
 3277         return (NULL);
 3278     }
 3279     if ((*ctxt-&gt;input-&gt;cur == &#39;\n&#39;) &amp;&amp; (ctxt-&gt;input-&gt;cur[-1] == &#39;\r&#39;))
 3280         return(xmlDictLookup(ctxt-&gt;dict, ctxt-&gt;input-&gt;cur - (len + 1), len));
 3281     return(xmlDictLookup(ctxt-&gt;dict, ctxt-&gt;input-&gt;cur - len, len));
 3282 }
 3283 
 3284 /**
 3285  * xmlParseName:
 3286  * @ctxt:  an XML parser context
 3287  *
 3288  * parse an XML name.
 3289  *
 3290  * [4] NameChar ::= Letter | Digit | &#39;.&#39; | &#39;-&#39; | &#39;_&#39; | &#39;:&#39; |
 3291  *                  CombiningChar | Extender
 3292  *
 3293  * [5] Name ::= (Letter | &#39;_&#39; | &#39;:&#39;) (NameChar)*
 3294  *
 3295  * [6] Names ::= Name (#x20 Name)*
 3296  *
 3297  * Returns the Name parsed or NULL
 3298  */
 3299 
 3300 const xmlChar *
 3301 xmlParseName(xmlParserCtxtPtr ctxt) {
 3302     const xmlChar *in;
 3303     const xmlChar *ret;
 3304     int count = 0;
 3305 
 3306     GROW;
 3307 
 3308 #ifdef DEBUG
 3309     nbParseName++;
 3310 #endif
 3311 
 3312     /*
 3313      * Accelerator for simple ASCII names
 3314      */
 3315     in = ctxt-&gt;input-&gt;cur;
 3316     if (((*in &gt;= 0x61) &amp;&amp; (*in &lt;= 0x7A)) ||
 3317     ((*in &gt;= 0x41) &amp;&amp; (*in &lt;= 0x5A)) ||
 3318     (*in == &#39;_&#39;) || (*in == &#39;:&#39;)) {
 3319     in++;
 3320     while (((*in &gt;= 0x61) &amp;&amp; (*in &lt;= 0x7A)) ||
 3321            ((*in &gt;= 0x41) &amp;&amp; (*in &lt;= 0x5A)) ||
 3322            ((*in &gt;= 0x30) &amp;&amp; (*in &lt;= 0x39)) ||
 3323            (*in == &#39;_&#39;) || (*in == &#39;-&#39;) ||
 3324            (*in == &#39;:&#39;) || (*in == &#39;.&#39;))
 3325         in++;
 3326     if ((*in &gt; 0) &amp;&amp; (*in &lt; 0x80)) {
 3327         count = in - ctxt-&gt;input-&gt;cur;
 3328             if ((count &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3329                 ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3330                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;Name&quot;);
 3331                 return(NULL);
 3332             }
 3333         ret = xmlDictLookup(ctxt-&gt;dict, ctxt-&gt;input-&gt;cur, count);
 3334         ctxt-&gt;input-&gt;cur = in;
 3335         ctxt-&gt;nbChars += count;
 3336         ctxt-&gt;input-&gt;col += count;
 3337         if (ret == NULL)
 3338             xmlErrMemory(ctxt, NULL);
 3339         return(ret);
 3340     }
 3341     }
 3342     /* accelerator for special cases */
 3343     return(xmlParseNameComplex(ctxt));
 3344 }
 3345 
 3346 static const xmlChar *
 3347 xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) {
 3348     int len = 0, l;
 3349     int c;
 3350     int count = 0;
 3351     size_t startPosition = 0;
 3352 
 3353 #ifdef DEBUG
 3354     nbParseNCNameComplex++;
 3355 #endif
 3356 
 3357     /*
 3358      * Handler for more complex cases
 3359      */
 3360     GROW;
 3361     startPosition = CUR_PTR - BASE_PTR;
 3362     c = CUR_CHAR(l);
 3363     if ((c == &#39; &#39;) || (c == &#39;&gt;&#39;) || (c == &#39;/&#39;) || /* accelerators */
 3364     (!xmlIsNameStartChar(ctxt, c) || (c == &#39;:&#39;))) {
 3365     return(NULL);
 3366     }
 3367 
 3368     while ((c != &#39; &#39;) &amp;&amp; (c != &#39;&gt;&#39;) &amp;&amp; (c != &#39;/&#39;) &amp;&amp; /* test bigname.xml */
 3369        (xmlIsNameChar(ctxt, c) &amp;&amp; (c != &#39;:&#39;))) {
 3370     if (count++ &gt; XML_PARSER_CHUNK_SIZE) {
 3371             if ((len &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3372                 ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3373                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;NCName&quot;);
 3374                 return(NULL);
 3375             }
 3376         count = 0;
 3377         GROW;
 3378             if (ctxt-&gt;instate == XML_PARSER_EOF)
 3379                 return(NULL);
 3380     }
 3381     len += l;
 3382     NEXTL(l);
 3383     c = CUR_CHAR(l);
 3384     if (c == 0) {
 3385         count = 0;
 3386         /*
 3387          * when shrinking to extend the buffer we really need to preserve
 3388          * the part of the name we already parsed. Hence rolling back
<a name="22" id="anc22"></a><span class="line-modified"> 3389          * by current length.</span>
 3390          */
 3391         ctxt-&gt;input-&gt;cur -= l;
 3392         GROW;
 3393             if (ctxt-&gt;instate == XML_PARSER_EOF)
 3394                 return(NULL);
 3395         ctxt-&gt;input-&gt;cur += l;
 3396         c = CUR_CHAR(l);
 3397     }
 3398     }
 3399     if ((len &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3400         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3401         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;NCName&quot;);
 3402         return(NULL);
 3403     }
 3404     return(xmlDictLookup(ctxt-&gt;dict, (BASE_PTR + startPosition), len));
 3405 }
 3406 
 3407 /**
 3408  * xmlParseNCName:
 3409  * @ctxt:  an XML parser context
 3410  * @len:  length of the string parsed
 3411  *
 3412  * parse an XML name.
 3413  *
 3414  * [4NS] NCNameChar ::= Letter | Digit | &#39;.&#39; | &#39;-&#39; | &#39;_&#39; |
 3415  *                      CombiningChar | Extender
 3416  *
 3417  * [5NS] NCName ::= (Letter | &#39;_&#39;) (NCNameChar)*
 3418  *
 3419  * Returns the Name parsed or NULL
 3420  */
 3421 
 3422 static const xmlChar *
 3423 xmlParseNCName(xmlParserCtxtPtr ctxt) {
 3424     const xmlChar *in, *e;
 3425     const xmlChar *ret;
 3426     int count = 0;
 3427 
 3428 #ifdef DEBUG
 3429     nbParseNCName++;
 3430 #endif
 3431 
 3432     /*
 3433      * Accelerator for simple ASCII names
 3434      */
 3435     in = ctxt-&gt;input-&gt;cur;
 3436     e = ctxt-&gt;input-&gt;end;
 3437     if ((((*in &gt;= 0x61) &amp;&amp; (*in &lt;= 0x7A)) ||
 3438      ((*in &gt;= 0x41) &amp;&amp; (*in &lt;= 0x5A)) ||
 3439      (*in == &#39;_&#39;)) &amp;&amp; (in &lt; e)) {
 3440     in++;
 3441     while ((((*in &gt;= 0x61) &amp;&amp; (*in &lt;= 0x7A)) ||
 3442             ((*in &gt;= 0x41) &amp;&amp; (*in &lt;= 0x5A)) ||
 3443             ((*in &gt;= 0x30) &amp;&amp; (*in &lt;= 0x39)) ||
 3444             (*in == &#39;_&#39;) || (*in == &#39;-&#39;) ||
 3445             (*in == &#39;.&#39;)) &amp;&amp; (in &lt; e))
 3446         in++;
 3447     if (in &gt;= e)
 3448         goto complex;
 3449     if ((*in &gt; 0) &amp;&amp; (*in &lt; 0x80)) {
 3450         count = in - ctxt-&gt;input-&gt;cur;
 3451             if ((count &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3452                 ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3453                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;NCName&quot;);
 3454                 return(NULL);
 3455             }
 3456         ret = xmlDictLookup(ctxt-&gt;dict, ctxt-&gt;input-&gt;cur, count);
 3457         ctxt-&gt;input-&gt;cur = in;
 3458         ctxt-&gt;nbChars += count;
 3459         ctxt-&gt;input-&gt;col += count;
 3460         if (ret == NULL) {
 3461             xmlErrMemory(ctxt, NULL);
 3462         }
 3463         return(ret);
 3464     }
 3465     }
 3466 complex:
 3467     return(xmlParseNCNameComplex(ctxt));
 3468 }
 3469 
 3470 /**
 3471  * xmlParseNameAndCompare:
 3472  * @ctxt:  an XML parser context
 3473  *
 3474  * parse an XML name and compares for match
 3475  * (specialized for endtag parsing)
 3476  *
 3477  * Returns NULL for an illegal name, (xmlChar*) 1 for success
 3478  * and the name for mismatch
 3479  */
 3480 
 3481 static const xmlChar *
 3482 xmlParseNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *other) {
 3483     register const xmlChar *cmp = other;
 3484     register const xmlChar *in;
 3485     const xmlChar *ret;
 3486 
 3487     GROW;
 3488     if (ctxt-&gt;instate == XML_PARSER_EOF)
 3489         return(NULL);
 3490 
 3491     in = ctxt-&gt;input-&gt;cur;
 3492     while (*in != 0 &amp;&amp; *in == *cmp) {
 3493     ++in;
 3494     ++cmp;
 3495     ctxt-&gt;input-&gt;col++;
 3496     }
 3497     if (*cmp == 0 &amp;&amp; (*in == &#39;&gt;&#39; || IS_BLANK_CH (*in))) {
 3498     /* success */
 3499     ctxt-&gt;input-&gt;cur = in;
 3500     return (const xmlChar*) 1;
 3501     }
 3502     /* failure (or end of input buffer), check with full function */
 3503     ret = xmlParseName (ctxt);
 3504     /* strings coming from the dictionary direct compare possible */
 3505     if (ret == other) {
 3506     return (const xmlChar*) 1;
 3507     }
 3508     return ret;
 3509 }
 3510 
 3511 /**
 3512  * xmlParseStringName:
 3513  * @ctxt:  an XML parser context
 3514  * @str:  a pointer to the string pointer (IN/OUT)
 3515  *
 3516  * parse an XML name.
 3517  *
 3518  * [4] NameChar ::= Letter | Digit | &#39;.&#39; | &#39;-&#39; | &#39;_&#39; | &#39;:&#39; |
 3519  *                  CombiningChar | Extender
 3520  *
 3521  * [5] Name ::= (Letter | &#39;_&#39; | &#39;:&#39;) (NameChar)*
 3522  *
 3523  * [6] Names ::= Name (#x20 Name)*
 3524  *
 3525  * Returns the Name parsed or NULL. The @str pointer
 3526  * is updated to the current location in the string.
 3527  */
 3528 
 3529 static xmlChar *
 3530 xmlParseStringName(xmlParserCtxtPtr ctxt, const xmlChar** str) {
 3531     xmlChar buf[XML_MAX_NAMELEN + 5];
 3532     const xmlChar *cur = *str;
 3533     int len = 0, l;
 3534     int c;
 3535 
 3536 #ifdef DEBUG
 3537     nbParseStringName++;
 3538 #endif
 3539 
 3540     c = CUR_SCHAR(cur, l);
 3541     if (!xmlIsNameStartChar(ctxt, c)) {
 3542     return(NULL);
 3543     }
 3544 
 3545     COPY_BUF(l,buf,len,c);
 3546     cur += l;
 3547     c = CUR_SCHAR(cur, l);
 3548     while (xmlIsNameChar(ctxt, c)) {
 3549     COPY_BUF(l,buf,len,c);
 3550     cur += l;
 3551     c = CUR_SCHAR(cur, l);
 3552     if (len &gt;= XML_MAX_NAMELEN) { /* test bigentname.xml */
 3553         /*
 3554          * Okay someone managed to make a huge name, so he&#39;s ready to pay
 3555          * for the processing speed.
 3556          */
 3557         xmlChar *buffer;
 3558         int max = len * 2;
 3559 
 3560         buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));
 3561         if (buffer == NULL) {
 3562             xmlErrMemory(ctxt, NULL);
 3563         return(NULL);
 3564         }
 3565         memcpy(buffer, buf, len);
 3566         while (xmlIsNameChar(ctxt, c)) {
 3567         if (len + 10 &gt; max) {
 3568             xmlChar *tmp;
 3569 
 3570                     if ((len &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3571                         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3572                         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;NCName&quot;);
 3573             xmlFree(buffer);
 3574                         return(NULL);
 3575                     }
 3576             max *= 2;
 3577             tmp = (xmlChar *) xmlRealloc(buffer,
 3578                                         max * sizeof(xmlChar));
 3579             if (tmp == NULL) {
 3580             xmlErrMemory(ctxt, NULL);
 3581             xmlFree(buffer);
 3582             return(NULL);
 3583             }
 3584             buffer = tmp;
 3585         }
 3586         COPY_BUF(l,buffer,len,c);
 3587         cur += l;
 3588         c = CUR_SCHAR(cur, l);
 3589         }
 3590         buffer[len] = 0;
 3591         *str = cur;
 3592         return(buffer);
 3593     }
 3594     }
 3595     if ((len &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3596         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3597         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;NCName&quot;);
 3598         return(NULL);
 3599     }
 3600     *str = cur;
 3601     return(xmlStrndup(buf, len));
 3602 }
 3603 
 3604 /**
 3605  * xmlParseNmtoken:
 3606  * @ctxt:  an XML parser context
 3607  *
 3608  * parse an XML Nmtoken.
 3609  *
 3610  * [7] Nmtoken ::= (NameChar)+
 3611  *
 3612  * [8] Nmtokens ::= Nmtoken (#x20 Nmtoken)*
 3613  *
 3614  * Returns the Nmtoken parsed or NULL
 3615  */
 3616 
 3617 xmlChar *
 3618 xmlParseNmtoken(xmlParserCtxtPtr ctxt) {
 3619     xmlChar buf[XML_MAX_NAMELEN + 5];
 3620     int len = 0, l;
 3621     int c;
 3622     int count = 0;
 3623 
 3624 #ifdef DEBUG
 3625     nbParseNmToken++;
 3626 #endif
 3627 
 3628     GROW;
 3629     if (ctxt-&gt;instate == XML_PARSER_EOF)
 3630         return(NULL);
 3631     c = CUR_CHAR(l);
 3632 
 3633     while (xmlIsNameChar(ctxt, c)) {
 3634     if (count++ &gt; XML_PARSER_CHUNK_SIZE) {
 3635         count = 0;
 3636         GROW;
 3637     }
 3638     COPY_BUF(l,buf,len,c);
 3639     NEXTL(l);
 3640     c = CUR_CHAR(l);
 3641     if (c == 0) {
 3642         count = 0;
 3643         GROW;
 3644         if (ctxt-&gt;instate == XML_PARSER_EOF)
 3645         return(NULL);
 3646             c = CUR_CHAR(l);
 3647     }
 3648     if (len &gt;= XML_MAX_NAMELEN) {
 3649         /*
 3650          * Okay someone managed to make a huge token, so he&#39;s ready to pay
 3651          * for the processing speed.
 3652          */
 3653         xmlChar *buffer;
 3654         int max = len * 2;
 3655 
 3656         buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));
 3657         if (buffer == NULL) {
 3658             xmlErrMemory(ctxt, NULL);
 3659         return(NULL);
 3660         }
 3661         memcpy(buffer, buf, len);
 3662         while (xmlIsNameChar(ctxt, c)) {
 3663         if (count++ &gt; XML_PARSER_CHUNK_SIZE) {
 3664             count = 0;
 3665             GROW;
 3666                     if (ctxt-&gt;instate == XML_PARSER_EOF) {
 3667                         xmlFree(buffer);
 3668                         return(NULL);
 3669                     }
 3670         }
 3671         if (len + 10 &gt; max) {
 3672             xmlChar *tmp;
 3673 
 3674                     if ((max &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3675                         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3676                         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;NmToken&quot;);
 3677                         xmlFree(buffer);
 3678                         return(NULL);
 3679                     }
 3680             max *= 2;
 3681             tmp = (xmlChar *) xmlRealloc(buffer,
 3682                                         max * sizeof(xmlChar));
 3683             if (tmp == NULL) {
 3684             xmlErrMemory(ctxt, NULL);
 3685             xmlFree(buffer);
 3686             return(NULL);
 3687             }
 3688             buffer = tmp;
 3689         }
 3690         COPY_BUF(l,buffer,len,c);
 3691         NEXTL(l);
 3692         c = CUR_CHAR(l);
 3693         }
 3694         buffer[len] = 0;
 3695         return(buffer);
 3696     }
 3697     }
 3698     if (len == 0)
 3699         return(NULL);
 3700     if ((len &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3701         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3702         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;NmToken&quot;);
 3703         return(NULL);
 3704     }
 3705     return(xmlStrndup(buf, len));
 3706 }
 3707 
 3708 /**
 3709  * xmlParseEntityValue:
 3710  * @ctxt:  an XML parser context
 3711  * @orig:  if non-NULL store a copy of the original entity value
 3712  *
 3713  * parse a value for ENTITY declarations
 3714  *
 3715  * [9] EntityValue ::= &#39;&quot;&#39; ([^%&amp;&quot;] | PEReference | Reference)* &#39;&quot;&#39; |
 3716  *                 &quot;&#39;&quot; ([^%&amp;&#39;] | PEReference | Reference)* &quot;&#39;&quot;
 3717  *
 3718  * Returns the EntityValue parsed with reference substituted or NULL
 3719  */
 3720 
 3721 xmlChar *
 3722 xmlParseEntityValue(xmlParserCtxtPtr ctxt, xmlChar **orig) {
 3723     xmlChar *buf = NULL;
 3724     int len = 0;
 3725     int size = XML_PARSER_BUFFER_SIZE;
 3726     int c, l;
 3727     xmlChar stop;
 3728     xmlChar *ret = NULL;
 3729     const xmlChar *cur = NULL;
 3730     xmlParserInputPtr input;
 3731 
 3732     if (RAW == &#39;&quot;&#39;) stop = &#39;&quot;&#39;;
 3733     else if (RAW == &#39;\&#39;&#39;) stop = &#39;\&#39;&#39;;
 3734     else {
 3735     xmlFatalErr(ctxt, XML_ERR_ENTITY_NOT_STARTED, NULL);
 3736     return(NULL);
 3737     }
 3738     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));
 3739     if (buf == NULL) {
 3740     xmlErrMemory(ctxt, NULL);
 3741     return(NULL);
 3742     }
 3743 
 3744     /*
 3745      * The content of the entity definition is copied in a buffer.
 3746      */
 3747 
 3748     ctxt-&gt;instate = XML_PARSER_ENTITY_VALUE;
 3749     input = ctxt-&gt;input;
 3750     GROW;
 3751     if (ctxt-&gt;instate == XML_PARSER_EOF)
 3752         goto error;
 3753     NEXT;
 3754     c = CUR_CHAR(l);
 3755     /*
 3756      * NOTE: 4.4.5 Included in Literal
 3757      * When a parameter entity reference appears in a literal entity
 3758      * value, ... a single or double quote character in the replacement
 3759      * text is always treated as a normal data character and will not
 3760      * terminate the literal.
 3761      * In practice it means we stop the loop only when back at parsing
 3762      * the initial entity and the quote is found
 3763      */
 3764     while (((IS_CHAR(c)) &amp;&amp; ((c != stop) || /* checked */
 3765         (ctxt-&gt;input != input))) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF)) {
 3766     if (len + 5 &gt;= size) {
 3767         xmlChar *tmp;
 3768 
 3769         size *= 2;
 3770         tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));
 3771         if (tmp == NULL) {
 3772         xmlErrMemory(ctxt, NULL);
 3773                 goto error;
 3774         }
 3775         buf = tmp;
 3776     }
 3777     COPY_BUF(l,buf,len,c);
 3778     NEXTL(l);
 3779 
 3780     GROW;
 3781     c = CUR_CHAR(l);
 3782     if (c == 0) {
 3783         GROW;
 3784         c = CUR_CHAR(l);
 3785     }
 3786     }
 3787     buf[len] = 0;
 3788     if (ctxt-&gt;instate == XML_PARSER_EOF)
 3789         goto error;
 3790     if (c != stop) {
 3791         xmlFatalErr(ctxt, XML_ERR_ENTITY_NOT_FINISHED, NULL);
 3792         goto error;
 3793     }
 3794     NEXT;
 3795 
 3796     /*
 3797      * Raise problem w.r.t. &#39;&amp;&#39; and &#39;%&#39; being used in non-entities
 3798      * reference constructs. Note Charref will be handled in
 3799      * xmlStringDecodeEntities()
 3800      */
 3801     cur = buf;
 3802     while (*cur != 0) { /* non input consuming */
 3803     if ((*cur == &#39;%&#39;) || ((*cur == &#39;&amp;&#39;) &amp;&amp; (cur[1] != &#39;#&#39;))) {
 3804         xmlChar *name;
 3805         xmlChar tmp = *cur;
 3806             int nameOk = 0;
 3807 
 3808         cur++;
 3809         name = xmlParseStringName(ctxt, &amp;cur);
 3810             if (name != NULL) {
 3811                 nameOk = 1;
 3812                 xmlFree(name);
 3813             }
 3814             if ((nameOk == 0) || (*cur != &#39;;&#39;)) {
 3815         xmlFatalErrMsgInt(ctxt, XML_ERR_ENTITY_CHAR_ERROR,
 3816         &quot;EntityValue: &#39;%c&#39; forbidden except for entities references\n&quot;,
 3817                               tmp);
 3818                 goto error;
 3819         }
 3820         if ((tmp == &#39;%&#39;) &amp;&amp; (ctxt-&gt;inSubset == 1) &amp;&amp;
 3821         (ctxt-&gt;inputNr == 1)) {
 3822         xmlFatalErr(ctxt, XML_ERR_ENTITY_PE_INTERNAL, NULL);
 3823                 goto error;
 3824         }
 3825         if (*cur == 0)
 3826             break;
 3827     }
 3828     cur++;
 3829     }
 3830 
 3831     /*
 3832      * Then PEReference entities are substituted.
 3833      *
 3834      * NOTE: 4.4.7 Bypassed
 3835      * When a general entity reference appears in the EntityValue in
 3836      * an entity declaration, it is bypassed and left as is.
 3837      * so XML_SUBSTITUTE_REF is not set here.
 3838      */
 3839     ++ctxt-&gt;depth;
 3840     ret = xmlStringDecodeEntities(ctxt, buf, XML_SUBSTITUTE_PEREF,
 3841                                   0, 0, 0);
 3842     --ctxt-&gt;depth;
 3843     if (orig != NULL) {
 3844         *orig = buf;
 3845         buf = NULL;
 3846     }
 3847 
 3848 error:
 3849     if (buf != NULL)
 3850         xmlFree(buf);
 3851     return(ret);
 3852 }
 3853 
 3854 /**
 3855  * xmlParseAttValueComplex:
 3856  * @ctxt:  an XML parser context
 3857  * @len:   the resulting attribute len
<a name="23" id="anc23"></a><span class="line-modified"> 3858  * @normalize:  whether to apply the inner normalization</span>
 3859  *
 3860  * parse a value for an attribute, this is the fallback function
 3861  * of xmlParseAttValue() when the attribute parsing requires handling
 3862  * of non-ASCII characters, or normalization compaction.
 3863  *
 3864  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.
 3865  */
 3866 static xmlChar *
 3867 xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
 3868     xmlChar limit = 0;
 3869     xmlChar *buf = NULL;
 3870     xmlChar *rep = NULL;
 3871     size_t len = 0;
 3872     size_t buf_size = 0;
 3873     int c, l, in_space = 0;
 3874     xmlChar *current = NULL;
 3875     xmlEntityPtr ent;
 3876 
 3877     if (NXT(0) == &#39;&quot;&#39;) {
 3878     ctxt-&gt;instate = XML_PARSER_ATTRIBUTE_VALUE;
 3879     limit = &#39;&quot;&#39;;
 3880         NEXT;
 3881     } else if (NXT(0) == &#39;\&#39;&#39;) {
 3882     limit = &#39;\&#39;&#39;;
 3883     ctxt-&gt;instate = XML_PARSER_ATTRIBUTE_VALUE;
 3884         NEXT;
 3885     } else {
 3886     xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
 3887     return(NULL);
 3888     }
 3889 
 3890     /*
 3891      * allocate a translation buffer.
 3892      */
 3893     buf_size = XML_PARSER_BUFFER_SIZE;
 3894     buf = (xmlChar *) xmlMallocAtomic(buf_size);
 3895     if (buf == NULL) goto mem_error;
 3896 
 3897     /*
 3898      * OK loop until we reach one of the ending char or a size limit.
 3899      */
 3900     c = CUR_CHAR(l);
 3901     while (((NXT(0) != limit) &amp;&amp; /* checked */
 3902             (IS_CHAR(c)) &amp;&amp; (c != &#39;&lt;&#39;)) &amp;&amp;
 3903             (ctxt-&gt;instate != XML_PARSER_EOF)) {
 3904         /*
 3905          * Impose a reasonable limit on attribute size, unless XML_PARSE_HUGE
 3906          * special option is given
 3907          */
 3908         if ((len &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 3909             ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3910             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 3911                            &quot;AttValue length too long\n&quot;);
 3912             goto mem_error;
 3913         }
 3914     if (c == 0) break;
 3915     if (c == &#39;&amp;&#39;) {
 3916         in_space = 0;
 3917         if (NXT(1) == &#39;#&#39;) {
 3918         int val = xmlParseCharRef(ctxt);
 3919 
 3920         if (val == &#39;&amp;&#39;) {
 3921             if (ctxt-&gt;replaceEntities) {
 3922             if (len + 10 &gt; buf_size) {
 3923                 growBuffer(buf, 10);
 3924             }
 3925             buf[len++] = &#39;&amp;&#39;;
 3926             } else {
 3927             /*
 3928              * The reparsing will be done in xmlStringGetNodeList()
 3929              * called by the attribute() function in SAX.c
 3930              */
 3931             if (len + 10 &gt; buf_size) {
 3932                 growBuffer(buf, 10);
 3933             }
 3934             buf[len++] = &#39;&amp;&#39;;
 3935             buf[len++] = &#39;#&#39;;
 3936             buf[len++] = &#39;3&#39;;
 3937             buf[len++] = &#39;8&#39;;
 3938             buf[len++] = &#39;;&#39;;
 3939             }
 3940         } else if (val != 0) {
 3941             if (len + 10 &gt; buf_size) {
 3942             growBuffer(buf, 10);
 3943             }
 3944             len += xmlCopyChar(0, &amp;buf[len], val);
 3945         }
 3946         } else {
 3947         ent = xmlParseEntityRef(ctxt);
 3948         ctxt-&gt;nbentities++;
 3949         if (ent != NULL)
 3950             ctxt-&gt;nbentities += ent-&gt;owner;
 3951         if ((ent != NULL) &amp;&amp;
 3952             (ent-&gt;etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
 3953             if (len + 10 &gt; buf_size) {
 3954             growBuffer(buf, 10);
 3955             }
 3956             if ((ctxt-&gt;replaceEntities == 0) &amp;&amp;
 3957                 (ent-&gt;content[0] == &#39;&amp;&#39;)) {
 3958             buf[len++] = &#39;&amp;&#39;;
 3959             buf[len++] = &#39;#&#39;;
 3960             buf[len++] = &#39;3&#39;;
 3961             buf[len++] = &#39;8&#39;;
 3962             buf[len++] = &#39;;&#39;;
 3963             } else {
 3964             buf[len++] = ent-&gt;content[0];
 3965             }
 3966         } else if ((ent != NULL) &amp;&amp;
 3967                    (ctxt-&gt;replaceEntities != 0)) {
 3968             if (ent-&gt;etype != XML_INTERNAL_PREDEFINED_ENTITY) {
 3969             ++ctxt-&gt;depth;
 3970             rep = xmlStringDecodeEntities(ctxt, ent-&gt;content,
 3971                               XML_SUBSTITUTE_REF,
 3972                               0, 0, 0);
 3973             --ctxt-&gt;depth;
 3974             if (rep != NULL) {
 3975                 current = rep;
 3976                 while (*current != 0) { /* non input consuming */
 3977                                 if ((*current == 0xD) || (*current == 0xA) ||
 3978                                     (*current == 0x9)) {
 3979                                     buf[len++] = 0x20;
 3980                                     current++;
 3981                                 } else
 3982                                     buf[len++] = *current++;
 3983                 if (len + 10 &gt; buf_size) {
 3984                     growBuffer(buf, 10);
 3985                 }
 3986                 }
 3987                 xmlFree(rep);
 3988                 rep = NULL;
 3989             }
 3990             } else {
 3991             if (len + 10 &gt; buf_size) {
 3992                 growBuffer(buf, 10);
 3993             }
 3994             if (ent-&gt;content != NULL)
 3995                 buf[len++] = ent-&gt;content[0];
 3996             }
 3997         } else if (ent != NULL) {
 3998             int i = xmlStrlen(ent-&gt;name);
 3999             const xmlChar *cur = ent-&gt;name;
 4000 
 4001             /*
 4002              * This may look absurd but is needed to detect
 4003              * entities problems
 4004              */
 4005             if ((ent-&gt;etype != XML_INTERNAL_PREDEFINED_ENTITY) &amp;&amp;
 4006             (ent-&gt;content != NULL) &amp;&amp; (ent-&gt;checked == 0)) {
<a name="24" id="anc24"></a><span class="line-modified"> 4007             unsigned long oldnbent = ctxt-&gt;nbentities, diff;</span>
 4008 
 4009             ++ctxt-&gt;depth;
 4010             rep = xmlStringDecodeEntities(ctxt, ent-&gt;content,
 4011                           XML_SUBSTITUTE_REF, 0, 0, 0);
 4012             --ctxt-&gt;depth;
 4013 
<a name="25" id="anc25"></a><span class="line-modified"> 4014                         diff = ctxt-&gt;nbentities - oldnbent + 1;</span>
<span class="line-added"> 4015                         if (diff &gt; INT_MAX / 2)</span>
<span class="line-added"> 4016                             diff = INT_MAX / 2;</span>
<span class="line-added"> 4017                         ent-&gt;checked = diff * 2;</span>
 4018             if (rep != NULL) {
 4019                 if (xmlStrchr(rep, &#39;&lt;&#39;))
 4020                     ent-&gt;checked |= 1;
 4021                 xmlFree(rep);
 4022                 rep = NULL;
 4023             } else {
 4024                             ent-&gt;content[0] = 0;
 4025                         }
 4026             }
 4027 
 4028             /*
 4029              * Just output the reference
 4030              */
 4031             buf[len++] = &#39;&amp;&#39;;
 4032             while (len + i + 10 &gt; buf_size) {
 4033             growBuffer(buf, i + 10);
 4034             }
 4035             for (;i &gt; 0;i--)
 4036             buf[len++] = *cur++;
 4037             buf[len++] = &#39;;&#39;;
 4038         }
 4039         }
 4040     } else {
 4041         if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {
 4042             if ((len != 0) || (!normalize)) {
 4043             if ((!normalize) || (!in_space)) {
 4044             COPY_BUF(l,buf,len,0x20);
 4045             while (len + 10 &gt; buf_size) {
 4046                 growBuffer(buf, 10);
 4047             }
 4048             }
 4049             in_space = 1;
 4050         }
 4051         } else {
 4052             in_space = 0;
 4053         COPY_BUF(l,buf,len,c);
 4054         if (len + 10 &gt; buf_size) {
 4055             growBuffer(buf, 10);
 4056         }
 4057         }
 4058         NEXTL(l);
 4059     }
 4060     GROW;
 4061     c = CUR_CHAR(l);
 4062     }
 4063     if (ctxt-&gt;instate == XML_PARSER_EOF)
 4064         goto error;
 4065 
 4066     if ((in_space) &amp;&amp; (normalize)) {
 4067         while ((len &gt; 0) &amp;&amp; (buf[len - 1] == 0x20)) len--;
 4068     }
 4069     buf[len] = 0;
 4070     if (RAW == &#39;&lt;&#39;) {
 4071     xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);
 4072     } else if (RAW != limit) {
 4073     if ((c != 0) &amp;&amp; (!IS_CHAR(c))) {
 4074         xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
 4075                &quot;invalid character in attribute value\n&quot;);
 4076     } else {
 4077         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 4078                &quot;AttValue: &#39; expected\n&quot;);
 4079         }
 4080     } else
 4081     NEXT;
 4082 
 4083     /*
 4084      * There we potentially risk an overflow, don&#39;t allow attribute value of
<a name="26" id="anc26"></a><span class="line-modified"> 4085      * length more than INT_MAX it is a very reasonable assumption !</span>
 4086      */
 4087     if (len &gt;= INT_MAX) {
 4088         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 4089                        &quot;AttValue length too long\n&quot;);
 4090         goto mem_error;
 4091     }
 4092 
 4093     if (attlen != NULL) *attlen = (int) len;
 4094     return(buf);
 4095 
 4096 mem_error:
 4097     xmlErrMemory(ctxt, NULL);
 4098 error:
 4099     if (buf != NULL)
 4100         xmlFree(buf);
 4101     if (rep != NULL)
 4102         xmlFree(rep);
 4103     return(NULL);
 4104 }
 4105 
 4106 /**
 4107  * xmlParseAttValue:
 4108  * @ctxt:  an XML parser context
 4109  *
 4110  * parse a value for an attribute
 4111  * Note: the parser won&#39;t do substitution of entities here, this
 4112  * will be handled later in xmlStringGetNodeList
 4113  *
 4114  * [10] AttValue ::= &#39;&quot;&#39; ([^&lt;&amp;&quot;] | Reference)* &#39;&quot;&#39; |
 4115  *                   &quot;&#39;&quot; ([^&lt;&amp;&#39;] | Reference)* &quot;&#39;&quot;
 4116  *
 4117  * 3.3.3 Attribute-Value Normalization:
 4118  * Before the value of an attribute is passed to the application or
 4119  * checked for validity, the XML processor must normalize it as follows:
 4120  * - a character reference is processed by appending the referenced
 4121  *   character to the attribute value
 4122  * - an entity reference is processed by recursively processing the
 4123  *   replacement text of the entity
 4124  * - a whitespace character (#x20, #xD, #xA, #x9) is processed by
 4125  *   appending #x20 to the normalized value, except that only a single
 4126  *   #x20 is appended for a &quot;#xD#xA&quot; sequence that is part of an external
 4127  *   parsed entity or the literal entity value of an internal parsed entity
 4128  * - other characters are processed by appending them to the normalized value
 4129  * If the declared value is not CDATA, then the XML processor must further
 4130  * process the normalized attribute value by discarding any leading and
 4131  * trailing space (#x20) characters, and by replacing sequences of space
 4132  * (#x20) characters by a single space (#x20) character.
 4133  * All attributes for which no declaration has been read should be treated
 4134  * by a non-validating parser as if declared CDATA.
 4135  *
 4136  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.
 4137  */
 4138 
 4139 
 4140 xmlChar *
 4141 xmlParseAttValue(xmlParserCtxtPtr ctxt) {
 4142     if ((ctxt == NULL) || (ctxt-&gt;input == NULL)) return(NULL);
 4143     return(xmlParseAttValueInternal(ctxt, NULL, NULL, 0));
 4144 }
 4145 
 4146 /**
 4147  * xmlParseSystemLiteral:
 4148  * @ctxt:  an XML parser context
 4149  *
 4150  * parse an XML Literal
 4151  *
 4152  * [11] SystemLiteral ::= (&#39;&quot;&#39; [^&quot;]* &#39;&quot;&#39;) | (&quot;&#39;&quot; [^&#39;]* &quot;&#39;&quot;)
 4153  *
 4154  * Returns the SystemLiteral parsed or NULL
 4155  */
 4156 
 4157 xmlChar *
 4158 xmlParseSystemLiteral(xmlParserCtxtPtr ctxt) {
 4159     xmlChar *buf = NULL;
 4160     int len = 0;
 4161     int size = XML_PARSER_BUFFER_SIZE;
 4162     int cur, l;
 4163     xmlChar stop;
 4164     int state = ctxt-&gt;instate;
 4165     int count = 0;
 4166 
 4167     SHRINK;
 4168     if (RAW == &#39;&quot;&#39;) {
 4169         NEXT;
 4170     stop = &#39;&quot;&#39;;
 4171     } else if (RAW == &#39;\&#39;&#39;) {
 4172         NEXT;
 4173     stop = &#39;\&#39;&#39;;
 4174     } else {
 4175     xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);
 4176     return(NULL);
 4177     }
 4178 
 4179     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));
 4180     if (buf == NULL) {
 4181         xmlErrMemory(ctxt, NULL);
 4182     return(NULL);
 4183     }
 4184     ctxt-&gt;instate = XML_PARSER_SYSTEM_LITERAL;
 4185     cur = CUR_CHAR(l);
 4186     while ((IS_CHAR(cur)) &amp;&amp; (cur != stop)) { /* checked */
 4187     if (len + 5 &gt;= size) {
 4188         xmlChar *tmp;
 4189 
 4190             if ((size &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 4191                 ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 4192                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;SystemLiteral&quot;);
 4193                 xmlFree(buf);
 4194         ctxt-&gt;instate = (xmlParserInputState) state;
 4195                 return(NULL);
 4196             }
 4197         size *= 2;
 4198         tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));
 4199         if (tmp == NULL) {
 4200             xmlFree(buf);
 4201         xmlErrMemory(ctxt, NULL);
 4202         ctxt-&gt;instate = (xmlParserInputState) state;
 4203         return(NULL);
 4204         }
 4205         buf = tmp;
 4206     }
 4207     count++;
 4208     if (count &gt; 50) {
 4209         GROW;
 4210         count = 0;
 4211             if (ctxt-&gt;instate == XML_PARSER_EOF) {
 4212             xmlFree(buf);
 4213         return(NULL);
 4214             }
 4215     }
 4216     COPY_BUF(l,buf,len,cur);
 4217     NEXTL(l);
 4218     cur = CUR_CHAR(l);
 4219     if (cur == 0) {
 4220         GROW;
 4221         SHRINK;
 4222         cur = CUR_CHAR(l);
 4223     }
 4224     }
 4225     buf[len] = 0;
 4226     ctxt-&gt;instate = (xmlParserInputState) state;
 4227     if (!IS_CHAR(cur)) {
 4228     xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED, NULL);
 4229     } else {
 4230     NEXT;
 4231     }
 4232     return(buf);
 4233 }
 4234 
 4235 /**
 4236  * xmlParsePubidLiteral:
 4237  * @ctxt:  an XML parser context
 4238  *
 4239  * parse an XML public literal
 4240  *
 4241  * [12] PubidLiteral ::= &#39;&quot;&#39; PubidChar* &#39;&quot;&#39; | &quot;&#39;&quot; (PubidChar - &quot;&#39;&quot;)* &quot;&#39;&quot;
 4242  *
 4243  * Returns the PubidLiteral parsed or NULL.
 4244  */
 4245 
 4246 xmlChar *
 4247 xmlParsePubidLiteral(xmlParserCtxtPtr ctxt) {
 4248     xmlChar *buf = NULL;
 4249     int len = 0;
 4250     int size = XML_PARSER_BUFFER_SIZE;
 4251     xmlChar cur;
 4252     xmlChar stop;
 4253     int count = 0;
 4254     xmlParserInputState oldstate = ctxt-&gt;instate;
 4255 
 4256     SHRINK;
 4257     if (RAW == &#39;&quot;&#39;) {
 4258         NEXT;
 4259     stop = &#39;&quot;&#39;;
 4260     } else if (RAW == &#39;\&#39;&#39;) {
 4261         NEXT;
 4262     stop = &#39;\&#39;&#39;;
 4263     } else {
 4264     xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);
 4265     return(NULL);
 4266     }
 4267     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));
 4268     if (buf == NULL) {
 4269     xmlErrMemory(ctxt, NULL);
 4270     return(NULL);
 4271     }
 4272     ctxt-&gt;instate = XML_PARSER_PUBLIC_LITERAL;
 4273     cur = CUR;
 4274     while ((IS_PUBIDCHAR_CH(cur)) &amp;&amp; (cur != stop)) { /* checked */
 4275     if (len + 1 &gt;= size) {
 4276         xmlChar *tmp;
 4277 
 4278             if ((size &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 4279                 ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 4280                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;Public ID&quot;);
 4281                 xmlFree(buf);
 4282                 return(NULL);
 4283             }
 4284         size *= 2;
 4285         tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));
 4286         if (tmp == NULL) {
 4287         xmlErrMemory(ctxt, NULL);
 4288         xmlFree(buf);
 4289         return(NULL);
 4290         }
 4291         buf = tmp;
 4292     }
 4293     buf[len++] = cur;
 4294     count++;
 4295     if (count &gt; 50) {
 4296         GROW;
 4297         count = 0;
 4298             if (ctxt-&gt;instate == XML_PARSER_EOF) {
 4299         xmlFree(buf);
 4300         return(NULL);
 4301             }
 4302     }
 4303     NEXT;
 4304     cur = CUR;
 4305     if (cur == 0) {
 4306         GROW;
 4307         SHRINK;
 4308         cur = CUR;
 4309     }
 4310     }
 4311     buf[len] = 0;
 4312     if (cur != stop) {
 4313     xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED, NULL);
 4314     } else {
 4315     NEXT;
 4316     }
 4317     ctxt-&gt;instate = oldstate;
 4318     return(buf);
 4319 }
 4320 
 4321 static void xmlParseCharDataComplex(xmlParserCtxtPtr ctxt, int cdata);
 4322 
 4323 /*
 4324  * used for the test in the inner loop of the char data testing
 4325  */
 4326 static const unsigned char test_char_data[256] = {
 4327     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4328     0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 0x9, CR/LF separated */
 4329     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4330     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4331     0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x00, 0x27, /* &amp; */
 4332     0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
 4333     0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
 4334     0x38, 0x39, 0x3A, 0x3B, 0x00, 0x3D, 0x3E, 0x3F, /* &lt; */
 4335     0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
 4336     0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
 4337     0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
 4338     0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x00, 0x5E, 0x5F, /* ] */
 4339     0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
 4340     0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
 4341     0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
 4342     0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
 4343     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* non-ascii */
 4344     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4345     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4346     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4347     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4348     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4349     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4350     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4351     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4352     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4353     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4354     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4355     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4356     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4357     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 4358     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 4359 };
 4360 
 4361 /**
 4362  * xmlParseCharData:
 4363  * @ctxt:  an XML parser context
 4364  * @cdata:  int indicating whether we are within a CDATA section
 4365  *
 4366  * parse a CharData section.
 4367  * if we are within a CDATA section &#39;]]&gt;&#39; marks an end of section.
 4368  *
 4369  * The right angle bracket (&gt;) may be represented using the string &quot;&amp;gt;&quot;,
 4370  * and must, for compatibility, be escaped using &quot;&amp;gt;&quot; or a character
 4371  * reference when it appears in the string &quot;]]&gt;&quot; in content, when that
 4372  * string is not marking the end of a CDATA section.
 4373  *
 4374  * [14] CharData ::= [^&lt;&amp;]* - ([^&lt;&amp;]* &#39;]]&gt;&#39; [^&lt;&amp;]*)
 4375  */
 4376 
 4377 void
 4378 xmlParseCharData(xmlParserCtxtPtr ctxt, int cdata) {
 4379     const xmlChar *in;
 4380     int nbchar = 0;
 4381     int line = ctxt-&gt;input-&gt;line;
 4382     int col = ctxt-&gt;input-&gt;col;
 4383     int ccol;
 4384 
 4385     SHRINK;
 4386     GROW;
 4387     /*
 4388      * Accelerated common case where input don&#39;t need to be
 4389      * modified before passing it to the handler.
 4390      */
 4391     if (!cdata) {
 4392     in = ctxt-&gt;input-&gt;cur;
 4393     do {
 4394 get_more_space:
 4395         while (*in == 0x20) { in++; ctxt-&gt;input-&gt;col++; }
 4396         if (*in == 0xA) {
 4397         do {
 4398             ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;
 4399             in++;
 4400         } while (*in == 0xA);
 4401         goto get_more_space;
 4402         }
 4403         if (*in == &#39;&lt;&#39;) {
 4404         nbchar = in - ctxt-&gt;input-&gt;cur;
 4405         if (nbchar &gt; 0) {
 4406             const xmlChar *tmp = ctxt-&gt;input-&gt;cur;
 4407             ctxt-&gt;input-&gt;cur = in;
 4408 
 4409             if ((ctxt-&gt;sax != NULL) &amp;&amp;
 4410                 (ctxt-&gt;sax-&gt;ignorableWhitespace !=
 4411                  ctxt-&gt;sax-&gt;characters)) {
 4412             if (areBlanks(ctxt, tmp, nbchar, 1)) {
 4413                 if (ctxt-&gt;sax-&gt;ignorableWhitespace != NULL)
 4414                 ctxt-&gt;sax-&gt;ignorableWhitespace(ctxt-&gt;userData,
 4415                                tmp, nbchar);
 4416             } else {
 4417                 if (ctxt-&gt;sax-&gt;characters != NULL)
 4418                 ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData,
 4419                               tmp, nbchar);
 4420                 if (*ctxt-&gt;space == -1)
 4421                     *ctxt-&gt;space = -2;
 4422             }
 4423             } else if ((ctxt-&gt;sax != NULL) &amp;&amp;
 4424                        (ctxt-&gt;sax-&gt;characters != NULL)) {
 4425             ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData,
 4426                           tmp, nbchar);
 4427             }
 4428         }
 4429         return;
 4430         }
 4431 
 4432 get_more:
 4433             ccol = ctxt-&gt;input-&gt;col;
 4434         while (test_char_data[*in]) {
 4435         in++;
 4436         ccol++;
 4437         }
 4438         ctxt-&gt;input-&gt;col = ccol;
 4439         if (*in == 0xA) {
 4440         do {
 4441             ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;
 4442             in++;
 4443         } while (*in == 0xA);
 4444         goto get_more;
 4445         }
 4446         if (*in == &#39;]&#39;) {
 4447         if ((in[1] == &#39;]&#39;) &amp;&amp; (in[2] == &#39;&gt;&#39;)) {
 4448             xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);
 4449             ctxt-&gt;input-&gt;cur = in + 1;
 4450             return;
 4451         }
 4452         in++;
 4453         ctxt-&gt;input-&gt;col++;
 4454         goto get_more;
 4455         }
 4456         nbchar = in - ctxt-&gt;input-&gt;cur;
 4457         if (nbchar &gt; 0) {
 4458         if ((ctxt-&gt;sax != NULL) &amp;&amp;
 4459             (ctxt-&gt;sax-&gt;ignorableWhitespace !=
 4460              ctxt-&gt;sax-&gt;characters) &amp;&amp;
 4461             (IS_BLANK_CH(*ctxt-&gt;input-&gt;cur))) {
 4462             const xmlChar *tmp = ctxt-&gt;input-&gt;cur;
 4463             ctxt-&gt;input-&gt;cur = in;
 4464 
 4465             if (areBlanks(ctxt, tmp, nbchar, 0)) {
 4466                 if (ctxt-&gt;sax-&gt;ignorableWhitespace != NULL)
 4467                 ctxt-&gt;sax-&gt;ignorableWhitespace(ctxt-&gt;userData,
 4468                                tmp, nbchar);
 4469             } else {
 4470                 if (ctxt-&gt;sax-&gt;characters != NULL)
 4471                 ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData,
 4472                           tmp, nbchar);
 4473             if (*ctxt-&gt;space == -1)
 4474                 *ctxt-&gt;space = -2;
 4475             }
 4476                     line = ctxt-&gt;input-&gt;line;
 4477                     col = ctxt-&gt;input-&gt;col;
 4478         } else if (ctxt-&gt;sax != NULL) {
 4479             if (ctxt-&gt;sax-&gt;characters != NULL)
 4480             ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData,
 4481                           ctxt-&gt;input-&gt;cur, nbchar);
 4482                     line = ctxt-&gt;input-&gt;line;
 4483                     col = ctxt-&gt;input-&gt;col;
 4484         }
 4485                 /* something really bad happened in the SAX callback */
 4486                 if (ctxt-&gt;instate != XML_PARSER_CONTENT)
 4487                     return;
 4488         }
 4489         ctxt-&gt;input-&gt;cur = in;
 4490         if (*in == 0xD) {
 4491         in++;
 4492         if (*in == 0xA) {
 4493             ctxt-&gt;input-&gt;cur = in;
 4494             in++;
 4495             ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;
 4496             continue; /* while */
 4497         }
 4498         in--;
 4499         }
 4500         if (*in == &#39;&lt;&#39;) {
 4501         return;
 4502         }
 4503         if (*in == &#39;&amp;&#39;) {
 4504         return;
 4505         }
 4506         SHRINK;
 4507         GROW;
 4508             if (ctxt-&gt;instate == XML_PARSER_EOF)
 4509         return;
 4510         in = ctxt-&gt;input-&gt;cur;
 4511     } while (((*in &gt;= 0x20) &amp;&amp; (*in &lt;= 0x7F)) || (*in == 0x09));
 4512     nbchar = 0;
 4513     }
 4514     ctxt-&gt;input-&gt;line = line;
 4515     ctxt-&gt;input-&gt;col = col;
 4516     xmlParseCharDataComplex(ctxt, cdata);
 4517 }
 4518 
 4519 /**
 4520  * xmlParseCharDataComplex:
 4521  * @ctxt:  an XML parser context
 4522  * @cdata:  int indicating whether we are within a CDATA section
 4523  *
 4524  * parse a CharData section.this is the fallback function
 4525  * of xmlParseCharData() when the parsing requires handling
 4526  * of non-ASCII characters.
 4527  */
 4528 static void
 4529 xmlParseCharDataComplex(xmlParserCtxtPtr ctxt, int cdata) {
 4530     xmlChar buf[XML_PARSER_BIG_BUFFER_SIZE + 5];
 4531     int nbchar = 0;
 4532     int cur, l;
 4533     int count = 0;
 4534 
 4535     SHRINK;
 4536     GROW;
 4537     cur = CUR_CHAR(l);
 4538     while ((cur != &#39;&lt;&#39;) &amp;&amp; /* checked */
 4539            (cur != &#39;&amp;&#39;) &amp;&amp;
 4540        (IS_CHAR(cur))) /* test also done in xmlCurrentChar() */ {
 4541     if ((cur == &#39;]&#39;) &amp;&amp; (NXT(1) == &#39;]&#39;) &amp;&amp;
 4542         (NXT(2) == &#39;&gt;&#39;)) {
 4543         if (cdata) break;
 4544         else {
 4545         xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);
 4546         }
 4547     }
 4548     COPY_BUF(l,buf,nbchar,cur);
 4549     if (nbchar &gt;= XML_PARSER_BIG_BUFFER_SIZE) {
 4550         buf[nbchar] = 0;
 4551 
 4552         /*
 4553          * OK the segment is to be consumed as chars.
 4554          */
 4555         if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX)) {
 4556         if (areBlanks(ctxt, buf, nbchar, 0)) {
 4557             if (ctxt-&gt;sax-&gt;ignorableWhitespace != NULL)
 4558             ctxt-&gt;sax-&gt;ignorableWhitespace(ctxt-&gt;userData,
 4559                                            buf, nbchar);
 4560         } else {
 4561             if (ctxt-&gt;sax-&gt;characters != NULL)
 4562             ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, buf, nbchar);
 4563             if ((ctxt-&gt;sax-&gt;characters !=
 4564                  ctxt-&gt;sax-&gt;ignorableWhitespace) &amp;&amp;
 4565             (*ctxt-&gt;space == -1))
 4566             *ctxt-&gt;space = -2;
 4567         }
 4568         }
 4569         nbchar = 0;
 4570             /* something really bad happened in the SAX callback */
 4571             if (ctxt-&gt;instate != XML_PARSER_CONTENT)
 4572                 return;
 4573     }
 4574     count++;
 4575     if (count &gt; 50) {
 4576         GROW;
 4577         count = 0;
 4578             if (ctxt-&gt;instate == XML_PARSER_EOF)
 4579         return;
 4580     }
 4581     NEXTL(l);
 4582     cur = CUR_CHAR(l);
 4583     }
 4584     if (nbchar != 0) {
 4585         buf[nbchar] = 0;
 4586     /*
 4587      * OK the segment is to be consumed as chars.
 4588      */
 4589     if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX)) {
 4590         if (areBlanks(ctxt, buf, nbchar, 0)) {
 4591         if (ctxt-&gt;sax-&gt;ignorableWhitespace != NULL)
 4592             ctxt-&gt;sax-&gt;ignorableWhitespace(ctxt-&gt;userData, buf, nbchar);
 4593         } else {
 4594         if (ctxt-&gt;sax-&gt;characters != NULL)
 4595             ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, buf, nbchar);
 4596         if ((ctxt-&gt;sax-&gt;characters != ctxt-&gt;sax-&gt;ignorableWhitespace) &amp;&amp;
 4597             (*ctxt-&gt;space == -1))
 4598             *ctxt-&gt;space = -2;
 4599         }
 4600     }
 4601     }
 4602     if ((cur != 0) &amp;&amp; (!IS_CHAR(cur))) {
 4603     /* Generate the error and skip the offending character */
 4604         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4605                           &quot;PCDATA invalid Char value %d\n&quot;,
 4606                       cur);
 4607     NEXTL(l);
 4608     }
 4609 }
 4610 
 4611 /**
 4612  * xmlParseExternalID:
 4613  * @ctxt:  an XML parser context
 4614  * @publicID:  a xmlChar** receiving PubidLiteral
 4615  * @strict: indicate whether we should restrict parsing to only
 4616  *          production [75], see NOTE below
 4617  *
 4618  * Parse an External ID or a Public ID
 4619  *
 4620  * NOTE: Productions [75] and [83] interact badly since [75] can generate
 4621  *       &#39;PUBLIC&#39; S PubidLiteral S SystemLiteral
 4622  *
 4623  * [75] ExternalID ::= &#39;SYSTEM&#39; S SystemLiteral
 4624  *                   | &#39;PUBLIC&#39; S PubidLiteral S SystemLiteral
 4625  *
 4626  * [83] PublicID ::= &#39;PUBLIC&#39; S PubidLiteral
 4627  *
 4628  * Returns the function returns SystemLiteral and in the second
 4629  *                case publicID receives PubidLiteral, is strict is off
 4630  *                it is possible to return NULL and have publicID set.
 4631  */
 4632 
 4633 xmlChar *
 4634 xmlParseExternalID(xmlParserCtxtPtr ctxt, xmlChar **publicID, int strict) {
 4635     xmlChar *URI = NULL;
 4636 
 4637     SHRINK;
 4638 
 4639     *publicID = NULL;
 4640     if (CMP6(CUR_PTR, &#39;S&#39;, &#39;Y&#39;, &#39;S&#39;, &#39;T&#39;, &#39;E&#39;, &#39;M&#39;)) {
 4641         SKIP(6);
 4642     if (SKIP_BLANKS == 0) {
 4643         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 4644                        &quot;Space required after &#39;SYSTEM&#39;\n&quot;);
 4645     }
 4646     URI = xmlParseSystemLiteral(ctxt);
 4647     if (URI == NULL) {
 4648         xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);
 4649         }
 4650     } else if (CMP6(CUR_PTR, &#39;P&#39;, &#39;U&#39;, &#39;B&#39;, &#39;L&#39;, &#39;I&#39;, &#39;C&#39;)) {
 4651         SKIP(6);
 4652     if (SKIP_BLANKS == 0) {
 4653         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 4654             &quot;Space required after &#39;PUBLIC&#39;\n&quot;);
 4655     }
 4656     *publicID = xmlParsePubidLiteral(ctxt);
 4657     if (*publicID == NULL) {
 4658         xmlFatalErr(ctxt, XML_ERR_PUBID_REQUIRED, NULL);
 4659     }
 4660     if (strict) {
 4661         /*
 4662          * We don&#39;t handle [83] so &quot;S SystemLiteral&quot; is required.
 4663          */
 4664         if (SKIP_BLANKS == 0) {
 4665         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 4666             &quot;Space required after the Public Identifier\n&quot;);
 4667         }
 4668     } else {
 4669         /*
 4670          * We handle [83] so we return immediately, if
 4671          * &quot;S SystemLiteral&quot; is not detected. We skip blanks if no
 4672              * system literal was found, but this is harmless since we must
 4673              * be at the end of a NotationDecl.
 4674          */
 4675         if (SKIP_BLANKS == 0) return(NULL);
 4676         if ((CUR != &#39;\&#39;&#39;) &amp;&amp; (CUR != &#39;&quot;&#39;)) return(NULL);
 4677     }
 4678     URI = xmlParseSystemLiteral(ctxt);
 4679     if (URI == NULL) {
 4680         xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);
 4681         }
 4682     }
 4683     return(URI);
 4684 }
 4685 
 4686 /**
 4687  * xmlParseCommentComplex:
 4688  * @ctxt:  an XML parser context
 4689  * @buf:  the already parsed part of the buffer
<a name="27" id="anc27"></a><span class="line-modified"> 4690  * @len:  number of bytes in the buffer</span>
 4691  * @size:  allocated size of the buffer
 4692  *
 4693  * Skip an XML (SGML) comment &lt;!-- .... --&gt;
 4694  *  The spec says that &quot;For compatibility, the string &quot;--&quot; (double-hyphen)
 4695  *  must not occur within comments. &quot;
 4696  * This is the slow routine in case the accelerator for ascii didn&#39;t work
 4697  *
 4698  * [15] Comment ::= &#39;&lt;!--&#39; ((Char - &#39;-&#39;) | (&#39;-&#39; (Char - &#39;-&#39;)))* &#39;--&gt;&#39;
 4699  */
 4700 static void
 4701 xmlParseCommentComplex(xmlParserCtxtPtr ctxt, xmlChar *buf,
 4702                        size_t len, size_t size) {
 4703     int q, ql;
 4704     int r, rl;
 4705     int cur, l;
 4706     size_t count = 0;
 4707     int inputid;
 4708 
 4709     inputid = ctxt-&gt;input-&gt;id;
 4710 
 4711     if (buf == NULL) {
 4712         len = 0;
 4713     size = XML_PARSER_BUFFER_SIZE;
 4714     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));
 4715     if (buf == NULL) {
 4716         xmlErrMemory(ctxt, NULL);
 4717         return;
 4718     }
 4719     }
 4720     GROW;   /* Assure there&#39;s enough input data */
 4721     q = CUR_CHAR(ql);
 4722     if (q == 0)
 4723         goto not_terminated;
 4724     if (!IS_CHAR(q)) {
 4725         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4726                           &quot;xmlParseComment: invalid xmlChar value %d\n&quot;,
 4727                       q);
 4728     xmlFree (buf);
 4729     return;
 4730     }
 4731     NEXTL(ql);
 4732     r = CUR_CHAR(rl);
 4733     if (r == 0)
 4734         goto not_terminated;
 4735     if (!IS_CHAR(r)) {
 4736         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4737                           &quot;xmlParseComment: invalid xmlChar value %d\n&quot;,
 4738                       q);
 4739     xmlFree (buf);
 4740     return;
 4741     }
 4742     NEXTL(rl);
 4743     cur = CUR_CHAR(l);
 4744     if (cur == 0)
 4745         goto not_terminated;
 4746     while (IS_CHAR(cur) &amp;&amp; /* checked */
 4747            ((cur != &#39;&gt;&#39;) ||
 4748         (r != &#39;-&#39;) || (q != &#39;-&#39;))) {
 4749     if ((r == &#39;-&#39;) &amp;&amp; (q == &#39;-&#39;)) {
 4750         xmlFatalErr(ctxt, XML_ERR_HYPHEN_IN_COMMENT, NULL);
 4751     }
 4752         if ((len &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 4753             ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 4754             xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 4755                          &quot;Comment too big found&quot;, NULL);
 4756             xmlFree (buf);
 4757             return;
 4758         }
 4759     if (len + 5 &gt;= size) {
 4760         xmlChar *new_buf;
 4761             size_t new_size;
 4762 
 4763         new_size = size * 2;
 4764         new_buf = (xmlChar *) xmlRealloc(buf, new_size);
 4765         if (new_buf == NULL) {
 4766         xmlFree (buf);
 4767         xmlErrMemory(ctxt, NULL);
 4768         return;
 4769         }
 4770         buf = new_buf;
 4771             size = new_size;
 4772     }
 4773     COPY_BUF(ql,buf,len,q);
 4774     q = r;
 4775     ql = rl;
 4776     r = cur;
 4777     rl = l;
 4778 
 4779     count++;
 4780     if (count &gt; 50) {
 4781         GROW;
 4782         count = 0;
 4783             if (ctxt-&gt;instate == XML_PARSER_EOF) {
 4784         xmlFree(buf);
 4785         return;
 4786             }
 4787     }
 4788     NEXTL(l);
 4789     cur = CUR_CHAR(l);
 4790     if (cur == 0) {
 4791         SHRINK;
 4792         GROW;
 4793         cur = CUR_CHAR(l);
 4794     }
 4795     }
 4796     buf[len] = 0;
 4797     if (cur == 0) {
 4798     xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 4799                          &quot;Comment not terminated \n&lt;!--%.50s\n&quot;, buf);
 4800     } else if (!IS_CHAR(cur)) {
 4801         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4802                           &quot;xmlParseComment: invalid xmlChar value %d\n&quot;,
 4803                       cur);
 4804     } else {
 4805     if (inputid != ctxt-&gt;input-&gt;id) {
 4806         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 4807                    &quot;Comment doesn&#39;t start and stop in the same&quot;
 4808                            &quot; entity\n&quot;);
 4809     }
 4810         NEXT;
 4811     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;comment != NULL) &amp;&amp;
 4812         (!ctxt-&gt;disableSAX))
 4813         ctxt-&gt;sax-&gt;comment(ctxt-&gt;userData, buf);
 4814     }
 4815     xmlFree(buf);
 4816     return;
 4817 not_terminated:
 4818     xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 4819              &quot;Comment not terminated\n&quot;, NULL);
 4820     xmlFree(buf);
 4821     return;
 4822 }
 4823 
 4824 /**
 4825  * xmlParseComment:
 4826  * @ctxt:  an XML parser context
 4827  *
 4828  * Skip an XML (SGML) comment &lt;!-- .... --&gt;
 4829  *  The spec says that &quot;For compatibility, the string &quot;--&quot; (double-hyphen)
 4830  *  must not occur within comments. &quot;
 4831  *
 4832  * [15] Comment ::= &#39;&lt;!--&#39; ((Char - &#39;-&#39;) | (&#39;-&#39; (Char - &#39;-&#39;)))* &#39;--&gt;&#39;
 4833  */
 4834 void
 4835 xmlParseComment(xmlParserCtxtPtr ctxt) {
 4836     xmlChar *buf = NULL;
 4837     size_t size = XML_PARSER_BUFFER_SIZE;
 4838     size_t len = 0;
 4839     xmlParserInputState state;
 4840     const xmlChar *in;
 4841     size_t nbchar = 0;
 4842     int ccol;
 4843     int inputid;
 4844 
 4845     /*
 4846      * Check that there is a comment right here.
 4847      */
 4848     if ((RAW != &#39;&lt;&#39;) || (NXT(1) != &#39;!&#39;) ||
 4849         (NXT(2) != &#39;-&#39;) || (NXT(3) != &#39;-&#39;)) return;
 4850     state = ctxt-&gt;instate;
 4851     ctxt-&gt;instate = XML_PARSER_COMMENT;
 4852     inputid = ctxt-&gt;input-&gt;id;
 4853     SKIP(4);
 4854     SHRINK;
 4855     GROW;
 4856 
 4857     /*
 4858      * Accelerated common case where input don&#39;t need to be
 4859      * modified before passing it to the handler.
 4860      */
 4861     in = ctxt-&gt;input-&gt;cur;
 4862     do {
 4863     if (*in == 0xA) {
 4864         do {
 4865         ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;
 4866         in++;
 4867         } while (*in == 0xA);
 4868     }
 4869 get_more:
 4870         ccol = ctxt-&gt;input-&gt;col;
 4871     while (((*in &gt; &#39;-&#39;) &amp;&amp; (*in &lt;= 0x7F)) ||
 4872            ((*in &gt;= 0x20) &amp;&amp; (*in &lt; &#39;-&#39;)) ||
 4873            (*in == 0x09)) {
 4874             in++;
 4875             ccol++;
 4876     }
 4877     ctxt-&gt;input-&gt;col = ccol;
 4878     if (*in == 0xA) {
 4879         do {
 4880         ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;
 4881         in++;
 4882         } while (*in == 0xA);
 4883         goto get_more;
 4884     }
 4885     nbchar = in - ctxt-&gt;input-&gt;cur;
 4886     /*
 4887      * save current set of data
 4888      */
 4889     if (nbchar &gt; 0) {
 4890         if ((ctxt-&gt;sax != NULL) &amp;&amp;
 4891         (ctxt-&gt;sax-&gt;comment != NULL)) {
 4892         if (buf == NULL) {
 4893             if ((*in == &#39;-&#39;) &amp;&amp; (in[1] == &#39;-&#39;))
 4894                 size = nbchar + 1;
 4895             else
 4896                 size = XML_PARSER_BUFFER_SIZE + nbchar;
 4897             buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));
 4898             if (buf == NULL) {
 4899                 xmlErrMemory(ctxt, NULL);
 4900             ctxt-&gt;instate = state;
 4901             return;
 4902             }
 4903             len = 0;
 4904         } else if (len + nbchar + 1 &gt;= size) {
 4905             xmlChar *new_buf;
 4906             size  += len + nbchar + XML_PARSER_BUFFER_SIZE;
 4907             new_buf = (xmlChar *) xmlRealloc(buf,
 4908                                              size * sizeof(xmlChar));
 4909             if (new_buf == NULL) {
 4910                 xmlFree (buf);
 4911             xmlErrMemory(ctxt, NULL);
 4912             ctxt-&gt;instate = state;
 4913             return;
 4914             }
 4915             buf = new_buf;
 4916         }
 4917         memcpy(&amp;buf[len], ctxt-&gt;input-&gt;cur, nbchar);
 4918         len += nbchar;
 4919         buf[len] = 0;
 4920         }
 4921     }
 4922         if ((len &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 4923             ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 4924             xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 4925                          &quot;Comment too big found&quot;, NULL);
 4926             xmlFree (buf);
 4927             return;
 4928         }
 4929     ctxt-&gt;input-&gt;cur = in;
 4930     if (*in == 0xA) {
 4931         in++;
 4932         ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;
 4933     }
 4934     if (*in == 0xD) {
 4935         in++;
 4936         if (*in == 0xA) {
 4937         ctxt-&gt;input-&gt;cur = in;
 4938         in++;
 4939         ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;
 4940         continue; /* while */
 4941         }
 4942         in--;
 4943     }
 4944     SHRINK;
 4945     GROW;
 4946         if (ctxt-&gt;instate == XML_PARSER_EOF) {
 4947             xmlFree(buf);
 4948             return;
 4949         }
 4950     in = ctxt-&gt;input-&gt;cur;
 4951     if (*in == &#39;-&#39;) {
 4952         if (in[1] == &#39;-&#39;) {
 4953             if (in[2] == &#39;&gt;&#39;) {
 4954             if (ctxt-&gt;input-&gt;id != inputid) {
 4955             xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 4956                            &quot;comment doesn&#39;t start and stop in the&quot;
 4957                                        &quot; same entity\n&quot;);
 4958             }
 4959             SKIP(3);
 4960             if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;comment != NULL) &amp;&amp;
 4961                 (!ctxt-&gt;disableSAX)) {
 4962             if (buf != NULL)
 4963                 ctxt-&gt;sax-&gt;comment(ctxt-&gt;userData, buf);
 4964             else
 4965                 ctxt-&gt;sax-&gt;comment(ctxt-&gt;userData, BAD_CAST &quot;&quot;);
 4966             }
 4967             if (buf != NULL)
 4968                 xmlFree(buf);
 4969             if (ctxt-&gt;instate != XML_PARSER_EOF)
 4970             ctxt-&gt;instate = state;
 4971             return;
 4972         }
 4973         if (buf != NULL) {
 4974             xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
 4975                               &quot;Double hyphen within comment: &quot;
 4976                                       &quot;&lt;!--%.50s\n&quot;,
 4977                       buf);
 4978         } else
 4979             xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
 4980                               &quot;Double hyphen within comment\n&quot;, NULL);
<a name="28" id="anc28"></a><span class="line-added"> 4981                 if (ctxt-&gt;instate == XML_PARSER_EOF) {</span>
<span class="line-added"> 4982                     xmlFree(buf);</span>
<span class="line-added"> 4983                     return;</span>
<span class="line-added"> 4984                 }</span>
 4985         in++;
 4986         ctxt-&gt;input-&gt;col++;
 4987         }
 4988         in++;
 4989         ctxt-&gt;input-&gt;col++;
 4990         goto get_more;
 4991     }
 4992     } while (((*in &gt;= 0x20) &amp;&amp; (*in &lt;= 0x7F)) || (*in == 0x09));
 4993     xmlParseCommentComplex(ctxt, buf, len, size);
 4994     ctxt-&gt;instate = state;
 4995     return;
 4996 }
 4997 
 4998 
 4999 /**
 5000  * xmlParsePITarget:
 5001  * @ctxt:  an XML parser context
 5002  *
 5003  * parse the name of a PI
 5004  *
 5005  * [17] PITarget ::= Name - ((&#39;X&#39; | &#39;x&#39;) (&#39;M&#39; | &#39;m&#39;) (&#39;L&#39; | &#39;l&#39;))
 5006  *
 5007  * Returns the PITarget name or NULL
 5008  */
 5009 
 5010 const xmlChar *
 5011 xmlParsePITarget(xmlParserCtxtPtr ctxt) {
 5012     const xmlChar *name;
 5013 
 5014     name = xmlParseName(ctxt);
 5015     if ((name != NULL) &amp;&amp;
 5016         ((name[0] == &#39;x&#39;) || (name[0] == &#39;X&#39;)) &amp;&amp;
 5017         ((name[1] == &#39;m&#39;) || (name[1] == &#39;M&#39;)) &amp;&amp;
 5018         ((name[2] == &#39;l&#39;) || (name[2] == &#39;L&#39;))) {
 5019     int i;
 5020     if ((name[0] == &#39;x&#39;) &amp;&amp; (name[1] == &#39;m&#39;) &amp;&amp;
 5021         (name[2] == &#39;l&#39;) &amp;&amp; (name[3] == 0)) {
 5022         xmlFatalErrMsg(ctxt, XML_ERR_RESERVED_XML_NAME,
 5023          &quot;XML declaration allowed only at the start of the document\n&quot;);
 5024         return(name);
 5025     } else if (name[3] == 0) {
 5026         xmlFatalErr(ctxt, XML_ERR_RESERVED_XML_NAME, NULL);
 5027         return(name);
 5028     }
 5029     for (i = 0;;i++) {
 5030         if (xmlW3CPIs[i] == NULL) break;
 5031         if (xmlStrEqual(name, (const xmlChar *)xmlW3CPIs[i]))
 5032             return(name);
 5033     }
 5034     xmlWarningMsg(ctxt, XML_ERR_RESERVED_XML_NAME,
 5035               &quot;xmlParsePITarget: invalid name prefix &#39;xml&#39;\n&quot;,
 5036               NULL, NULL);
 5037     }
 5038     if ((name != NULL) &amp;&amp; (xmlStrchr(name, &#39;:&#39;) != NULL)) {
 5039     xmlNsErr(ctxt, XML_NS_ERR_COLON,
 5040          &quot;colons are forbidden from PI names &#39;%s&#39;\n&quot;, name, NULL, NULL);
 5041     }
 5042     return(name);
 5043 }
 5044 
 5045 #ifdef LIBXML_CATALOG_ENABLED
 5046 /**
 5047  * xmlParseCatalogPI:
 5048  * @ctxt:  an XML parser context
 5049  * @catalog:  the PI value string
 5050  *
 5051  * parse an XML Catalog Processing Instruction.
 5052  *
 5053  * &lt;?oasis-xml-catalog catalog=&quot;http://example.com/catalog.xml&quot;?&gt;
 5054  *
 5055  * Occurs only if allowed by the user and if happening in the Misc
 5056  * part of the document before any doctype informations
 5057  * This will add the given catalog to the parsing context in order
 5058  * to be used if there is a resolution need further down in the document
 5059  */
 5060 
 5061 static void
 5062 xmlParseCatalogPI(xmlParserCtxtPtr ctxt, const xmlChar *catalog) {
 5063     xmlChar *URL = NULL;
 5064     const xmlChar *tmp, *base;
 5065     xmlChar marker;
 5066 
 5067     tmp = catalog;
 5068     while (IS_BLANK_CH(*tmp)) tmp++;
 5069     if (xmlStrncmp(tmp, BAD_CAST&quot;catalog&quot;, 7))
 5070     goto error;
 5071     tmp += 7;
 5072     while (IS_BLANK_CH(*tmp)) tmp++;
 5073     if (*tmp != &#39;=&#39;) {
 5074     return;
 5075     }
 5076     tmp++;
 5077     while (IS_BLANK_CH(*tmp)) tmp++;
 5078     marker = *tmp;
 5079     if ((marker != &#39;\&#39;&#39;) &amp;&amp; (marker != &#39;&quot;&#39;))
 5080     goto error;
 5081     tmp++;
 5082     base = tmp;
 5083     while ((*tmp != 0) &amp;&amp; (*tmp != marker)) tmp++;
 5084     if (*tmp == 0)
 5085     goto error;
 5086     URL = xmlStrndup(base, tmp - base);
 5087     tmp++;
 5088     while (IS_BLANK_CH(*tmp)) tmp++;
 5089     if (*tmp != 0)
 5090     goto error;
 5091 
 5092     if (URL != NULL) {
 5093     ctxt-&gt;catalogs = xmlCatalogAddLocal(ctxt-&gt;catalogs, URL);
 5094     xmlFree(URL);
 5095     }
 5096     return;
 5097 
 5098 error:
 5099     xmlWarningMsg(ctxt, XML_WAR_CATALOG_PI,
 5100               &quot;Catalog PI syntax error: %s\n&quot;,
 5101           catalog, NULL);
 5102     if (URL != NULL)
 5103     xmlFree(URL);
 5104 }
 5105 #endif
 5106 
 5107 /**
 5108  * xmlParsePI:
 5109  * @ctxt:  an XML parser context
 5110  *
 5111  * parse an XML Processing Instruction.
 5112  *
 5113  * [16] PI ::= &#39;&lt;?&#39; PITarget (S (Char* - (Char* &#39;?&gt;&#39; Char*)))? &#39;?&gt;&#39;
 5114  *
<a name="29" id="anc29"></a><span class="line-modified"> 5115  * The processing is transferred to SAX once parsed.</span>
 5116  */
 5117 
 5118 void
 5119 xmlParsePI(xmlParserCtxtPtr ctxt) {
 5120     xmlChar *buf = NULL;
 5121     size_t len = 0;
 5122     size_t size = XML_PARSER_BUFFER_SIZE;
 5123     int cur, l;
 5124     const xmlChar *target;
 5125     xmlParserInputState state;
 5126     int count = 0;
 5127 
 5128     if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;?&#39;)) {
 5129     int inputid = ctxt-&gt;input-&gt;id;
 5130     state = ctxt-&gt;instate;
 5131         ctxt-&gt;instate = XML_PARSER_PI;
 5132     /*
 5133      * this is a Processing Instruction.
 5134      */
 5135     SKIP(2);
 5136     SHRINK;
 5137 
 5138     /*
 5139      * Parse the target name and check for special support like
 5140      * namespace.
 5141      */
 5142         target = xmlParsePITarget(ctxt);
 5143     if (target != NULL) {
 5144         if ((RAW == &#39;?&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;)) {
 5145         if (inputid != ctxt-&gt;input-&gt;id) {
 5146             xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5147                                &quot;PI declaration doesn&#39;t start and stop in&quot;
 5148                                    &quot; the same entity\n&quot;);
 5149         }
 5150         SKIP(2);
 5151 
 5152         /*
 5153          * SAX: PI detected.
 5154          */
 5155         if ((ctxt-&gt;sax) &amp;&amp; (!ctxt-&gt;disableSAX) &amp;&amp;
 5156             (ctxt-&gt;sax-&gt;processingInstruction != NULL))
 5157             ctxt-&gt;sax-&gt;processingInstruction(ctxt-&gt;userData,
 5158                                              target, NULL);
 5159         if (ctxt-&gt;instate != XML_PARSER_EOF)
 5160             ctxt-&gt;instate = state;
 5161         return;
 5162         }
 5163         buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));
 5164         if (buf == NULL) {
 5165         xmlErrMemory(ctxt, NULL);
 5166         ctxt-&gt;instate = state;
 5167         return;
 5168         }
 5169         if (SKIP_BLANKS == 0) {
 5170         xmlFatalErrMsgStr(ctxt, XML_ERR_SPACE_REQUIRED,
 5171               &quot;ParsePI: PI %s space expected\n&quot;, target);
 5172         }
 5173         cur = CUR_CHAR(l);
 5174         while (IS_CHAR(cur) &amp;&amp; /* checked */
 5175            ((cur != &#39;?&#39;) || (NXT(1) != &#39;&gt;&#39;))) {
 5176         if (len + 5 &gt;= size) {
 5177             xmlChar *tmp;
 5178                     size_t new_size = size * 2;
 5179             tmp = (xmlChar *) xmlRealloc(buf, new_size);
 5180             if (tmp == NULL) {
 5181             xmlErrMemory(ctxt, NULL);
 5182             xmlFree(buf);
 5183             ctxt-&gt;instate = state;
 5184             return;
 5185             }
 5186             buf = tmp;
 5187                     size = new_size;
 5188         }
 5189         count++;
 5190         if (count &gt; 50) {
 5191             GROW;
 5192                     if (ctxt-&gt;instate == XML_PARSER_EOF) {
 5193                         xmlFree(buf);
 5194                         return;
 5195                     }
 5196             count = 0;
 5197                     if ((len &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 5198                         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 5199                         xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,
 5200                                           &quot;PI %s too big found&quot;, target);
 5201                         xmlFree(buf);
 5202                         ctxt-&gt;instate = state;
 5203                         return;
 5204                     }
 5205         }
 5206         COPY_BUF(l,buf,len,cur);
 5207         NEXTL(l);
 5208         cur = CUR_CHAR(l);
 5209         if (cur == 0) {
 5210             SHRINK;
 5211             GROW;
 5212             cur = CUR_CHAR(l);
 5213         }
 5214         }
 5215             if ((len &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 5216                 ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 5217                 xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,
 5218                                   &quot;PI %s too big found&quot;, target);
 5219                 xmlFree(buf);
 5220                 ctxt-&gt;instate = state;
 5221                 return;
 5222             }
 5223         buf[len] = 0;
 5224         if (cur != &#39;?&#39;) {
 5225         xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,
 5226               &quot;ParsePI: PI %s never end ...\n&quot;, target);
 5227         } else {
 5228         if (inputid != ctxt-&gt;input-&gt;id) {
 5229             xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5230                                &quot;PI declaration doesn&#39;t start and stop in&quot;
 5231                                    &quot; the same entity\n&quot;);
 5232         }
 5233         SKIP(2);
 5234 
 5235 #ifdef LIBXML_CATALOG_ENABLED
 5236         if (((state == XML_PARSER_MISC) ||
 5237                  (state == XML_PARSER_START)) &amp;&amp;
 5238             (xmlStrEqual(target, XML_CATALOG_PI))) {
 5239             xmlCatalogAllow allow = xmlCatalogGetDefaults();
 5240             if ((allow == XML_CATA_ALLOW_DOCUMENT) ||
 5241             (allow == XML_CATA_ALLOW_ALL))
 5242             xmlParseCatalogPI(ctxt, buf);
 5243         }
 5244 #endif
 5245 
 5246 
 5247         /*
 5248          * SAX: PI detected.
 5249          */
 5250         if ((ctxt-&gt;sax) &amp;&amp; (!ctxt-&gt;disableSAX) &amp;&amp;
 5251             (ctxt-&gt;sax-&gt;processingInstruction != NULL))
 5252             ctxt-&gt;sax-&gt;processingInstruction(ctxt-&gt;userData,
 5253                                              target, buf);
 5254         }
 5255         xmlFree(buf);
 5256     } else {
 5257         xmlFatalErr(ctxt, XML_ERR_PI_NOT_STARTED, NULL);
 5258     }
 5259     if (ctxt-&gt;instate != XML_PARSER_EOF)
 5260         ctxt-&gt;instate = state;
 5261     }
 5262 }
 5263 
 5264 /**
 5265  * xmlParseNotationDecl:
 5266  * @ctxt:  an XML parser context
 5267  *
 5268  * parse a notation declaration
 5269  *
 5270  * [82] NotationDecl ::= &#39;&lt;!NOTATION&#39; S Name S (ExternalID |  PublicID) S? &#39;&gt;&#39;
 5271  *
 5272  * Hence there is actually 3 choices:
 5273  *     &#39;PUBLIC&#39; S PubidLiteral
 5274  *     &#39;PUBLIC&#39; S PubidLiteral S SystemLiteral
 5275  * and &#39;SYSTEM&#39; S SystemLiteral
 5276  *
 5277  * See the NOTE on xmlParseExternalID().
 5278  */
 5279 
 5280 void
 5281 xmlParseNotationDecl(xmlParserCtxtPtr ctxt) {
 5282     const xmlChar *name;
 5283     xmlChar *Pubid;
 5284     xmlChar *Systemid;
 5285 
 5286     if (CMP10(CUR_PTR, &#39;&lt;&#39;, &#39;!&#39;, &#39;N&#39;, &#39;O&#39;, &#39;T&#39;, &#39;A&#39;, &#39;T&#39;, &#39;I&#39;, &#39;O&#39;, &#39;N&#39;)) {
 5287     int inputid = ctxt-&gt;input-&gt;id;
 5288     SHRINK;
 5289     SKIP(10);
 5290     if (SKIP_BLANKS == 0) {
 5291         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5292                &quot;Space required after &#39;&lt;!NOTATION&#39;\n&quot;);
 5293         return;
 5294     }
 5295 
 5296         name = xmlParseName(ctxt);
 5297     if (name == NULL) {
 5298         xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_STARTED, NULL);
 5299         return;
 5300     }
 5301     if (xmlStrchr(name, &#39;:&#39;) != NULL) {
 5302         xmlNsErr(ctxt, XML_NS_ERR_COLON,
 5303              &quot;colons are forbidden from notation names &#39;%s&#39;\n&quot;,
 5304              name, NULL, NULL);
 5305     }
 5306     if (SKIP_BLANKS == 0) {
 5307         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5308              &quot;Space required after the NOTATION name&#39;\n&quot;);
 5309         return;
 5310     }
 5311 
 5312     /*
 5313      * Parse the IDs.
 5314      */
 5315     Systemid = xmlParseExternalID(ctxt, &amp;Pubid, 0);
 5316     SKIP_BLANKS;
 5317 
 5318     if (RAW == &#39;&gt;&#39;) {
 5319         if (inputid != ctxt-&gt;input-&gt;id) {
 5320         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5321                            &quot;Notation declaration doesn&#39;t start and stop&quot;
 5322                                &quot; in the same entity\n&quot;);
 5323         }
 5324         NEXT;
 5325         if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX) &amp;&amp;
 5326         (ctxt-&gt;sax-&gt;notationDecl != NULL))
 5327         ctxt-&gt;sax-&gt;notationDecl(ctxt-&gt;userData, name, Pubid, Systemid);
 5328     } else {
 5329         xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_FINISHED, NULL);
 5330     }
 5331     if (Systemid != NULL) xmlFree(Systemid);
 5332     if (Pubid != NULL) xmlFree(Pubid);
 5333     }
 5334 }
 5335 
 5336 /**
 5337  * xmlParseEntityDecl:
 5338  * @ctxt:  an XML parser context
 5339  *
 5340  * parse &lt;!ENTITY declarations
 5341  *
 5342  * [70] EntityDecl ::= GEDecl | PEDecl
 5343  *
 5344  * [71] GEDecl ::= &#39;&lt;!ENTITY&#39; S Name S EntityDef S? &#39;&gt;&#39;
 5345  *
 5346  * [72] PEDecl ::= &#39;&lt;!ENTITY&#39; S &#39;%&#39; S Name S PEDef S? &#39;&gt;&#39;
 5347  *
 5348  * [73] EntityDef ::= EntityValue | (ExternalID NDataDecl?)
 5349  *
 5350  * [74] PEDef ::= EntityValue | ExternalID
 5351  *
 5352  * [76] NDataDecl ::= S &#39;NDATA&#39; S Name
 5353  *
 5354  * [ VC: Notation Declared ]
 5355  * The Name must match the declared name of a notation.
 5356  */
 5357 
 5358 void
 5359 xmlParseEntityDecl(xmlParserCtxtPtr ctxt) {
 5360     const xmlChar *name = NULL;
 5361     xmlChar *value = NULL;
 5362     xmlChar *URI = NULL, *literal = NULL;
 5363     const xmlChar *ndata = NULL;
 5364     int isParameter = 0;
 5365     xmlChar *orig = NULL;
 5366 
 5367     /* GROW; done in the caller */
 5368     if (CMP8(CUR_PTR, &#39;&lt;&#39;, &#39;!&#39;, &#39;E&#39;, &#39;N&#39;, &#39;T&#39;, &#39;I&#39;, &#39;T&#39;, &#39;Y&#39;)) {
 5369     int inputid = ctxt-&gt;input-&gt;id;
 5370     SHRINK;
 5371     SKIP(8);
 5372     if (SKIP_BLANKS == 0) {
 5373         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5374                &quot;Space required after &#39;&lt;!ENTITY&#39;\n&quot;);
 5375     }
 5376 
 5377     if (RAW == &#39;%&#39;) {
 5378         NEXT;
 5379         if (SKIP_BLANKS == 0) {
 5380         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5381                    &quot;Space required after &#39;%%&#39;\n&quot;);
 5382         }
 5383         isParameter = 1;
 5384     }
 5385 
 5386         name = xmlParseName(ctxt);
 5387     if (name == NULL) {
 5388         xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 5389                        &quot;xmlParseEntityDecl: no name\n&quot;);
 5390             return;
 5391     }
 5392     if (xmlStrchr(name, &#39;:&#39;) != NULL) {
 5393         xmlNsErr(ctxt, XML_NS_ERR_COLON,
 5394              &quot;colons are forbidden from entities names &#39;%s&#39;\n&quot;,
 5395              name, NULL, NULL);
 5396     }
 5397     if (SKIP_BLANKS == 0) {
 5398         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5399                &quot;Space required after the entity name\n&quot;);
 5400     }
 5401 
 5402     ctxt-&gt;instate = XML_PARSER_ENTITY_DECL;
 5403     /*
 5404      * handle the various case of definitions...
 5405      */
 5406     if (isParameter) {
 5407         if ((RAW == &#39;&quot;&#39;) || (RAW == &#39;\&#39;&#39;)) {
 5408             value = xmlParseEntityValue(ctxt, &amp;orig);
 5409         if (value) {
 5410             if ((ctxt-&gt;sax != NULL) &amp;&amp;
 5411             (!ctxt-&gt;disableSAX) &amp;&amp; (ctxt-&gt;sax-&gt;entityDecl != NULL))
 5412             ctxt-&gt;sax-&gt;entityDecl(ctxt-&gt;userData, name,
 5413                             XML_INTERNAL_PARAMETER_ENTITY,
 5414                     NULL, NULL, value);
 5415         }
 5416         } else {
 5417             URI = xmlParseExternalID(ctxt, &amp;literal, 1);
 5418         if ((URI == NULL) &amp;&amp; (literal == NULL)) {
 5419             xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL);
 5420         }
 5421         if (URI) {
 5422             xmlURIPtr uri;
 5423 
 5424             uri = xmlParseURI((const char *) URI);
 5425             if (uri == NULL) {
 5426                 xmlErrMsgStr(ctxt, XML_ERR_INVALID_URI,
 5427                      &quot;Invalid URI: %s\n&quot;, URI);
 5428             /*
 5429              * This really ought to be a well formedness error
 5430              * but the XML Core WG decided otherwise c.f. issue
 5431              * E26 of the XML erratas.
 5432              */
 5433             } else {
 5434             if (uri-&gt;fragment != NULL) {
 5435                 /*
 5436                  * Okay this is foolish to block those but not
 5437                  * invalid URIs.
 5438                  */
 5439                 xmlFatalErr(ctxt, XML_ERR_URI_FRAGMENT, NULL);
 5440             } else {
 5441                 if ((ctxt-&gt;sax != NULL) &amp;&amp;
 5442                 (!ctxt-&gt;disableSAX) &amp;&amp;
 5443                 (ctxt-&gt;sax-&gt;entityDecl != NULL))
 5444                 ctxt-&gt;sax-&gt;entityDecl(ctxt-&gt;userData, name,
 5445                         XML_EXTERNAL_PARAMETER_ENTITY,
 5446                         literal, URI, NULL);
 5447             }
 5448             xmlFreeURI(uri);
 5449             }
 5450         }
 5451         }
 5452     } else {
 5453         if ((RAW == &#39;&quot;&#39;) || (RAW == &#39;\&#39;&#39;)) {
 5454             value = xmlParseEntityValue(ctxt, &amp;orig);
 5455         if ((ctxt-&gt;sax != NULL) &amp;&amp;
 5456             (!ctxt-&gt;disableSAX) &amp;&amp; (ctxt-&gt;sax-&gt;entityDecl != NULL))
 5457             ctxt-&gt;sax-&gt;entityDecl(ctxt-&gt;userData, name,
 5458                 XML_INTERNAL_GENERAL_ENTITY,
 5459                 NULL, NULL, value);
 5460         /*
 5461          * For expat compatibility in SAX mode.
 5462          */
 5463         if ((ctxt-&gt;myDoc == NULL) ||
 5464             (xmlStrEqual(ctxt-&gt;myDoc-&gt;version, SAX_COMPAT_MODE))) {
 5465             if (ctxt-&gt;myDoc == NULL) {
 5466             ctxt-&gt;myDoc = xmlNewDoc(SAX_COMPAT_MODE);
 5467             if (ctxt-&gt;myDoc == NULL) {
 5468                 xmlErrMemory(ctxt, &quot;New Doc failed&quot;);
 5469                 return;
 5470             }
 5471             ctxt-&gt;myDoc-&gt;properties = XML_DOC_INTERNAL;
 5472             }
 5473             if (ctxt-&gt;myDoc-&gt;intSubset == NULL)
 5474             ctxt-&gt;myDoc-&gt;intSubset = xmlNewDtd(ctxt-&gt;myDoc,
 5475                         BAD_CAST &quot;fake&quot;, NULL, NULL);
 5476 
 5477             xmlSAX2EntityDecl(ctxt, name, XML_INTERNAL_GENERAL_ENTITY,
 5478                           NULL, NULL, value);
 5479         }
 5480         } else {
 5481             URI = xmlParseExternalID(ctxt, &amp;literal, 1);
 5482         if ((URI == NULL) &amp;&amp; (literal == NULL)) {
 5483             xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL);
 5484         }
 5485         if (URI) {
 5486             xmlURIPtr uri;
 5487 
 5488             uri = xmlParseURI((const char *)URI);
 5489             if (uri == NULL) {
 5490                 xmlErrMsgStr(ctxt, XML_ERR_INVALID_URI,
 5491                      &quot;Invalid URI: %s\n&quot;, URI);
 5492             /*
 5493              * This really ought to be a well formedness error
 5494              * but the XML Core WG decided otherwise c.f. issue
 5495              * E26 of the XML erratas.
 5496              */
 5497             } else {
 5498             if (uri-&gt;fragment != NULL) {
 5499                 /*
 5500                  * Okay this is foolish to block those but not
 5501                  * invalid URIs.
 5502                  */
 5503                 xmlFatalErr(ctxt, XML_ERR_URI_FRAGMENT, NULL);
 5504             }
 5505             xmlFreeURI(uri);
 5506             }
 5507         }
 5508         if ((RAW != &#39;&gt;&#39;) &amp;&amp; (SKIP_BLANKS == 0)) {
 5509             xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5510                    &quot;Space required before &#39;NDATA&#39;\n&quot;);
 5511         }
 5512         if (CMP5(CUR_PTR, &#39;N&#39;, &#39;D&#39;, &#39;A&#39;, &#39;T&#39;, &#39;A&#39;)) {
 5513             SKIP(5);
 5514             if (SKIP_BLANKS == 0) {
 5515             xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5516                        &quot;Space required after &#39;NDATA&#39;\n&quot;);
 5517             }
 5518             ndata = xmlParseName(ctxt);
 5519             if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX) &amp;&amp;
 5520                 (ctxt-&gt;sax-&gt;unparsedEntityDecl != NULL))
 5521             ctxt-&gt;sax-&gt;unparsedEntityDecl(ctxt-&gt;userData, name,
 5522                     literal, URI, ndata);
 5523         } else {
 5524             if ((ctxt-&gt;sax != NULL) &amp;&amp;
 5525                 (!ctxt-&gt;disableSAX) &amp;&amp; (ctxt-&gt;sax-&gt;entityDecl != NULL))
 5526             ctxt-&gt;sax-&gt;entityDecl(ctxt-&gt;userData, name,
 5527                     XML_EXTERNAL_GENERAL_PARSED_ENTITY,
 5528                     literal, URI, NULL);
 5529             /*
 5530              * For expat compatibility in SAX mode.
<a name="30" id="anc30"></a><span class="line-modified"> 5531              * assuming the entity replacement was asked for</span>
 5532              */
 5533             if ((ctxt-&gt;replaceEntities != 0) &amp;&amp;
 5534             ((ctxt-&gt;myDoc == NULL) ||
 5535             (xmlStrEqual(ctxt-&gt;myDoc-&gt;version, SAX_COMPAT_MODE)))) {
 5536             if (ctxt-&gt;myDoc == NULL) {
 5537                 ctxt-&gt;myDoc = xmlNewDoc(SAX_COMPAT_MODE);
 5538                 if (ctxt-&gt;myDoc == NULL) {
 5539                     xmlErrMemory(ctxt, &quot;New Doc failed&quot;);
 5540                 return;
 5541                 }
 5542                 ctxt-&gt;myDoc-&gt;properties = XML_DOC_INTERNAL;
 5543             }
 5544 
 5545             if (ctxt-&gt;myDoc-&gt;intSubset == NULL)
 5546                 ctxt-&gt;myDoc-&gt;intSubset = xmlNewDtd(ctxt-&gt;myDoc,
 5547                         BAD_CAST &quot;fake&quot;, NULL, NULL);
 5548             xmlSAX2EntityDecl(ctxt, name,
 5549                           XML_EXTERNAL_GENERAL_PARSED_ENTITY,
 5550                           literal, URI, NULL);
 5551             }
 5552         }
 5553         }
 5554     }
 5555     if (ctxt-&gt;instate == XML_PARSER_EOF)
 5556         goto done;
 5557     SKIP_BLANKS;
 5558     if (RAW != &#39;&gt;&#39;) {
 5559         xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_NOT_FINISHED,
 5560                 &quot;xmlParseEntityDecl: entity %s not terminated\n&quot;, name);
 5561         xmlHaltParser(ctxt);
 5562     } else {
 5563         if (inputid != ctxt-&gt;input-&gt;id) {
 5564         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5565                            &quot;Entity declaration doesn&#39;t start and stop in&quot;
 5566                                &quot; the same entity\n&quot;);
 5567         }
 5568         NEXT;
 5569     }
 5570     if (orig != NULL) {
 5571         /*
 5572          * Ugly mechanism to save the raw entity value.
 5573          */
 5574         xmlEntityPtr cur = NULL;
 5575 
 5576         if (isParameter) {
 5577             if ((ctxt-&gt;sax != NULL) &amp;&amp;
 5578             (ctxt-&gt;sax-&gt;getParameterEntity != NULL))
 5579             cur = ctxt-&gt;sax-&gt;getParameterEntity(ctxt-&gt;userData, name);
 5580         } else {
 5581             if ((ctxt-&gt;sax != NULL) &amp;&amp;
 5582             (ctxt-&gt;sax-&gt;getEntity != NULL))
 5583             cur = ctxt-&gt;sax-&gt;getEntity(ctxt-&gt;userData, name);
 5584         if ((cur == NULL) &amp;&amp; (ctxt-&gt;userData==ctxt)) {
 5585             cur = xmlSAX2GetEntity(ctxt, name);
 5586         }
 5587         }
 5588             if ((cur != NULL) &amp;&amp; (cur-&gt;orig == NULL)) {
 5589         cur-&gt;orig = orig;
 5590                 orig = NULL;
 5591         }
 5592     }
 5593 
 5594 done:
 5595     if (value != NULL) xmlFree(value);
 5596     if (URI != NULL) xmlFree(URI);
 5597     if (literal != NULL) xmlFree(literal);
 5598         if (orig != NULL) xmlFree(orig);
 5599     }
 5600 }
 5601 
 5602 /**
 5603  * xmlParseDefaultDecl:
 5604  * @ctxt:  an XML parser context
 5605  * @value:  Receive a possible fixed default value for the attribute
 5606  *
 5607  * Parse an attribute default declaration
 5608  *
 5609  * [60] DefaultDecl ::= &#39;#REQUIRED&#39; | &#39;#IMPLIED&#39; | ((&#39;#FIXED&#39; S)? AttValue)
 5610  *
 5611  * [ VC: Required Attribute ]
 5612  * if the default declaration is the keyword #REQUIRED, then the
 5613  * attribute must be specified for all elements of the type in the
 5614  * attribute-list declaration.
 5615  *
 5616  * [ VC: Attribute Default Legal ]
 5617  * The declared default value must meet the lexical constraints of
 5618  * the declared attribute type c.f. xmlValidateAttributeDecl()
 5619  *
 5620  * [ VC: Fixed Attribute Default ]
 5621  * if an attribute has a default value declared with the #FIXED
 5622  * keyword, instances of that attribute must match the default value.
 5623  *
 5624  * [ WFC: No &lt; in Attribute Values ]
 5625  * handled in xmlParseAttValue()
 5626  *
 5627  * returns: XML_ATTRIBUTE_NONE, XML_ATTRIBUTE_REQUIRED, XML_ATTRIBUTE_IMPLIED
 5628  *          or XML_ATTRIBUTE_FIXED.
 5629  */
 5630 
 5631 int
 5632 xmlParseDefaultDecl(xmlParserCtxtPtr ctxt, xmlChar **value) {
 5633     int val;
 5634     xmlChar *ret;
 5635 
 5636     *value = NULL;
 5637     if (CMP9(CUR_PTR, &#39;#&#39;, &#39;R&#39;, &#39;E&#39;, &#39;Q&#39;, &#39;U&#39;, &#39;I&#39;, &#39;R&#39;, &#39;E&#39;, &#39;D&#39;)) {
 5638     SKIP(9);
 5639     return(XML_ATTRIBUTE_REQUIRED);
 5640     }
 5641     if (CMP8(CUR_PTR, &#39;#&#39;, &#39;I&#39;, &#39;M&#39;, &#39;P&#39;, &#39;L&#39;, &#39;I&#39;, &#39;E&#39;, &#39;D&#39;)) {
 5642     SKIP(8);
 5643     return(XML_ATTRIBUTE_IMPLIED);
 5644     }
 5645     val = XML_ATTRIBUTE_NONE;
 5646     if (CMP6(CUR_PTR, &#39;#&#39;, &#39;F&#39;, &#39;I&#39;, &#39;X&#39;, &#39;E&#39;, &#39;D&#39;)) {
 5647     SKIP(6);
 5648     val = XML_ATTRIBUTE_FIXED;
 5649     if (SKIP_BLANKS == 0) {
 5650         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5651                &quot;Space required after &#39;#FIXED&#39;\n&quot;);
 5652     }
 5653     }
 5654     ret = xmlParseAttValue(ctxt);
 5655     ctxt-&gt;instate = XML_PARSER_DTD;
 5656     if (ret == NULL) {
 5657     xmlFatalErrMsg(ctxt, (xmlParserErrors)ctxt-&gt;errNo,
 5658                &quot;Attribute default value declaration error\n&quot;);
 5659     } else
 5660         *value = ret;
 5661     return(val);
 5662 }
 5663 
 5664 /**
 5665  * xmlParseNotationType:
 5666  * @ctxt:  an XML parser context
 5667  *
 5668  * parse an Notation attribute type.
 5669  *
 5670  * Note: the leading &#39;NOTATION&#39; S part has already being parsed...
 5671  *
 5672  * [58] NotationType ::= &#39;NOTATION&#39; S &#39;(&#39; S? Name (S? &#39;|&#39; S? Name)* S? &#39;)&#39;
 5673  *
 5674  * [ VC: Notation Attributes ]
 5675  * Values of this type must match one of the notation names included
 5676  * in the declaration; all notation names in the declaration must be declared.
 5677  *
 5678  * Returns: the notation attribute tree built while parsing
 5679  */
 5680 
 5681 xmlEnumerationPtr
 5682 xmlParseNotationType(xmlParserCtxtPtr ctxt) {
 5683     const xmlChar *name;
 5684     xmlEnumerationPtr ret = NULL, last = NULL, cur, tmp;
 5685 
 5686     if (RAW != &#39;(&#39;) {
 5687     xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_STARTED, NULL);
 5688     return(NULL);
 5689     }
 5690     SHRINK;
 5691     do {
 5692         NEXT;
 5693     SKIP_BLANKS;
 5694         name = xmlParseName(ctxt);
 5695     if (name == NULL) {
 5696         xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 5697                &quot;Name expected in NOTATION declaration\n&quot;);
 5698             xmlFreeEnumeration(ret);
 5699         return(NULL);
 5700     }
 5701     tmp = ret;
 5702     while (tmp != NULL) {
 5703         if (xmlStrEqual(name, tmp-&gt;name)) {
 5704         xmlValidityError(ctxt, XML_DTD_DUP_TOKEN,
 5705       &quot;standalone: attribute notation value token %s duplicated\n&quot;,
 5706                  name, NULL);
 5707         if (!xmlDictOwns(ctxt-&gt;dict, name))
 5708             xmlFree((xmlChar *) name);
 5709         break;
 5710         }
 5711         tmp = tmp-&gt;next;
 5712     }
 5713     if (tmp == NULL) {
 5714         cur = xmlCreateEnumeration(name);
 5715         if (cur == NULL) {
 5716                 xmlFreeEnumeration(ret);
 5717                 return(NULL);
 5718             }
 5719         if (last == NULL) ret = last = cur;
 5720         else {
 5721         last-&gt;next = cur;
 5722         last = cur;
 5723         }
 5724     }
 5725     SKIP_BLANKS;
 5726     } while (RAW == &#39;|&#39;);
 5727     if (RAW != &#39;)&#39;) {
 5728     xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_FINISHED, NULL);
 5729         xmlFreeEnumeration(ret);
 5730     return(NULL);
 5731     }
 5732     NEXT;
 5733     return(ret);
 5734 }
 5735 
 5736 /**
 5737  * xmlParseEnumerationType:
 5738  * @ctxt:  an XML parser context
 5739  *
 5740  * parse an Enumeration attribute type.
 5741  *
 5742  * [59] Enumeration ::= &#39;(&#39; S? Nmtoken (S? &#39;|&#39; S? Nmtoken)* S? &#39;)&#39;
 5743  *
 5744  * [ VC: Enumeration ]
 5745  * Values of this type must match one of the Nmtoken tokens in
 5746  * the declaration
 5747  *
 5748  * Returns: the enumeration attribute tree built while parsing
 5749  */
 5750 
 5751 xmlEnumerationPtr
 5752 xmlParseEnumerationType(xmlParserCtxtPtr ctxt) {
 5753     xmlChar *name;
 5754     xmlEnumerationPtr ret = NULL, last = NULL, cur, tmp;
 5755 
 5756     if (RAW != &#39;(&#39;) {
 5757     xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_STARTED, NULL);
 5758     return(NULL);
 5759     }
 5760     SHRINK;
 5761     do {
 5762         NEXT;
 5763     SKIP_BLANKS;
 5764         name = xmlParseNmtoken(ctxt);
 5765     if (name == NULL) {
 5766         xmlFatalErr(ctxt, XML_ERR_NMTOKEN_REQUIRED, NULL);
 5767         return(ret);
 5768     }
 5769     tmp = ret;
 5770     while (tmp != NULL) {
 5771         if (xmlStrEqual(name, tmp-&gt;name)) {
 5772         xmlValidityError(ctxt, XML_DTD_DUP_TOKEN,
 5773       &quot;standalone: attribute enumeration value token %s duplicated\n&quot;,
 5774                  name, NULL);
 5775         if (!xmlDictOwns(ctxt-&gt;dict, name))
 5776             xmlFree(name);
 5777         break;
 5778         }
 5779         tmp = tmp-&gt;next;
 5780     }
 5781     if (tmp == NULL) {
 5782         cur = xmlCreateEnumeration(name);
 5783         if (!xmlDictOwns(ctxt-&gt;dict, name))
 5784         xmlFree(name);
 5785         if (cur == NULL) {
 5786                 xmlFreeEnumeration(ret);
 5787                 return(NULL);
 5788             }
 5789         if (last == NULL) ret = last = cur;
 5790         else {
 5791         last-&gt;next = cur;
 5792         last = cur;
 5793         }
 5794     }
 5795     SKIP_BLANKS;
 5796     } while (RAW == &#39;|&#39;);
 5797     if (RAW != &#39;)&#39;) {
 5798     xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_FINISHED, NULL);
 5799     return(ret);
 5800     }
 5801     NEXT;
 5802     return(ret);
 5803 }
 5804 
 5805 /**
 5806  * xmlParseEnumeratedType:
 5807  * @ctxt:  an XML parser context
 5808  * @tree:  the enumeration tree built while parsing
 5809  *
 5810  * parse an Enumerated attribute type.
 5811  *
 5812  * [57] EnumeratedType ::= NotationType | Enumeration
 5813  *
 5814  * [58] NotationType ::= &#39;NOTATION&#39; S &#39;(&#39; S? Name (S? &#39;|&#39; S? Name)* S? &#39;)&#39;
 5815  *
 5816  *
 5817  * Returns: XML_ATTRIBUTE_ENUMERATION or XML_ATTRIBUTE_NOTATION
 5818  */
 5819 
 5820 int
 5821 xmlParseEnumeratedType(xmlParserCtxtPtr ctxt, xmlEnumerationPtr *tree) {
 5822     if (CMP8(CUR_PTR, &#39;N&#39;, &#39;O&#39;, &#39;T&#39;, &#39;A&#39;, &#39;T&#39;, &#39;I&#39;, &#39;O&#39;, &#39;N&#39;)) {
 5823     SKIP(8);
 5824     if (SKIP_BLANKS == 0) {
 5825         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5826                &quot;Space required after &#39;NOTATION&#39;\n&quot;);
 5827         return(0);
 5828     }
 5829     *tree = xmlParseNotationType(ctxt);
 5830     if (*tree == NULL) return(0);
 5831     return(XML_ATTRIBUTE_NOTATION);
 5832     }
 5833     *tree = xmlParseEnumerationType(ctxt);
 5834     if (*tree == NULL) return(0);
 5835     return(XML_ATTRIBUTE_ENUMERATION);
 5836 }
 5837 
 5838 /**
 5839  * xmlParseAttributeType:
 5840  * @ctxt:  an XML parser context
 5841  * @tree:  the enumeration tree built while parsing
 5842  *
 5843  * parse the Attribute list def for an element
 5844  *
 5845  * [54] AttType ::= StringType | TokenizedType | EnumeratedType
 5846  *
 5847  * [55] StringType ::= &#39;CDATA&#39;
 5848  *
 5849  * [56] TokenizedType ::= &#39;ID&#39; | &#39;IDREF&#39; | &#39;IDREFS&#39; | &#39;ENTITY&#39; |
 5850  *                        &#39;ENTITIES&#39; | &#39;NMTOKEN&#39; | &#39;NMTOKENS&#39;
 5851  *
 5852  * Validity constraints for attribute values syntax are checked in
 5853  * xmlValidateAttributeValue()
 5854  *
 5855  * [ VC: ID ]
 5856  * Values of type ID must match the Name production. A name must not
 5857  * appear more than once in an XML document as a value of this type;
 5858  * i.e., ID values must uniquely identify the elements which bear them.
 5859  *
 5860  * [ VC: One ID per Element Type ]
 5861  * No element type may have more than one ID attribute specified.
 5862  *
 5863  * [ VC: ID Attribute Default ]
 5864  * An ID attribute must have a declared default of #IMPLIED or #REQUIRED.
 5865  *
 5866  * [ VC: IDREF ]
 5867  * Values of type IDREF must match the Name production, and values
 5868  * of type IDREFS must match Names; each IDREF Name must match the value
 5869  * of an ID attribute on some element in the XML document; i.e. IDREF
 5870  * values must match the value of some ID attribute.
 5871  *
 5872  * [ VC: Entity Name ]
 5873  * Values of type ENTITY must match the Name production, values
 5874  * of type ENTITIES must match Names; each Entity Name must match the
 5875  * name of an unparsed entity declared in the DTD.
 5876  *
 5877  * [ VC: Name Token ]
 5878  * Values of type NMTOKEN must match the Nmtoken production; values
 5879  * of type NMTOKENS must match Nmtokens.
 5880  *
 5881  * Returns the attribute type
 5882  */
 5883 int
 5884 xmlParseAttributeType(xmlParserCtxtPtr ctxt, xmlEnumerationPtr *tree) {
 5885     SHRINK;
 5886     if (CMP5(CUR_PTR, &#39;C&#39;, &#39;D&#39;, &#39;A&#39;, &#39;T&#39;, &#39;A&#39;)) {
 5887     SKIP(5);
 5888     return(XML_ATTRIBUTE_CDATA);
 5889      } else if (CMP6(CUR_PTR, &#39;I&#39;, &#39;D&#39;, &#39;R&#39;, &#39;E&#39;, &#39;F&#39;, &#39;S&#39;)) {
 5890     SKIP(6);
 5891     return(XML_ATTRIBUTE_IDREFS);
 5892      } else if (CMP5(CUR_PTR, &#39;I&#39;, &#39;D&#39;, &#39;R&#39;, &#39;E&#39;, &#39;F&#39;)) {
 5893     SKIP(5);
 5894     return(XML_ATTRIBUTE_IDREF);
 5895      } else if ((RAW == &#39;I&#39;) &amp;&amp; (NXT(1) == &#39;D&#39;)) {
 5896         SKIP(2);
 5897     return(XML_ATTRIBUTE_ID);
 5898      } else if (CMP6(CUR_PTR, &#39;E&#39;, &#39;N&#39;, &#39;T&#39;, &#39;I&#39;, &#39;T&#39;, &#39;Y&#39;)) {
 5899     SKIP(6);
 5900     return(XML_ATTRIBUTE_ENTITY);
 5901      } else if (CMP8(CUR_PTR, &#39;E&#39;, &#39;N&#39;, &#39;T&#39;, &#39;I&#39;, &#39;T&#39;, &#39;I&#39;, &#39;E&#39;, &#39;S&#39;)) {
 5902     SKIP(8);
 5903     return(XML_ATTRIBUTE_ENTITIES);
 5904      } else if (CMP8(CUR_PTR, &#39;N&#39;, &#39;M&#39;, &#39;T&#39;, &#39;O&#39;, &#39;K&#39;, &#39;E&#39;, &#39;N&#39;, &#39;S&#39;)) {
 5905     SKIP(8);
 5906     return(XML_ATTRIBUTE_NMTOKENS);
 5907      } else if (CMP7(CUR_PTR, &#39;N&#39;, &#39;M&#39;, &#39;T&#39;, &#39;O&#39;, &#39;K&#39;, &#39;E&#39;, &#39;N&#39;)) {
 5908     SKIP(7);
 5909     return(XML_ATTRIBUTE_NMTOKEN);
 5910      }
 5911      return(xmlParseEnumeratedType(ctxt, tree));
 5912 }
 5913 
 5914 /**
 5915  * xmlParseAttributeListDecl:
 5916  * @ctxt:  an XML parser context
 5917  *
 5918  * : parse the Attribute list def for an element
 5919  *
 5920  * [52] AttlistDecl ::= &#39;&lt;!ATTLIST&#39; S Name AttDef* S? &#39;&gt;&#39;
 5921  *
 5922  * [53] AttDef ::= S Name S AttType S DefaultDecl
 5923  *
 5924  */
 5925 void
 5926 xmlParseAttributeListDecl(xmlParserCtxtPtr ctxt) {
 5927     const xmlChar *elemName;
 5928     const xmlChar *attrName;
 5929     xmlEnumerationPtr tree;
 5930 
 5931     if (CMP9(CUR_PTR, &#39;&lt;&#39;, &#39;!&#39;, &#39;A&#39;, &#39;T&#39;, &#39;T&#39;, &#39;L&#39;, &#39;I&#39;, &#39;S&#39;, &#39;T&#39;)) {
 5932     int inputid = ctxt-&gt;input-&gt;id;
 5933 
 5934     SKIP(9);
 5935     if (SKIP_BLANKS == 0) {
 5936         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5937                          &quot;Space required after &#39;&lt;!ATTLIST&#39;\n&quot;);
 5938     }
 5939         elemName = xmlParseName(ctxt);
 5940     if (elemName == NULL) {
 5941         xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 5942                &quot;ATTLIST: no name for Element\n&quot;);
 5943         return;
 5944     }
 5945     SKIP_BLANKS;
 5946     GROW;
 5947     while ((RAW != &#39;&gt;&#39;) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF)) {
 5948         int type;
 5949         int def;
 5950         xmlChar *defaultValue = NULL;
 5951 
 5952         GROW;
 5953             tree = NULL;
 5954         attrName = xmlParseName(ctxt);
 5955         if (attrName == NULL) {
 5956         xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 5957                    &quot;ATTLIST: no name for Attribute\n&quot;);
 5958         break;
 5959         }
 5960         GROW;
 5961         if (SKIP_BLANKS == 0) {
 5962         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5963                 &quot;Space required after the attribute name\n&quot;);
 5964         break;
 5965         }
 5966 
 5967         type = xmlParseAttributeType(ctxt, &amp;tree);
 5968         if (type &lt;= 0) {
 5969             break;
 5970         }
 5971 
 5972         GROW;
 5973         if (SKIP_BLANKS == 0) {
 5974         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5975                    &quot;Space required after the attribute type\n&quot;);
 5976             if (tree != NULL)
 5977             xmlFreeEnumeration(tree);
 5978         break;
 5979         }
 5980 
 5981         def = xmlParseDefaultDecl(ctxt, &amp;defaultValue);
 5982         if (def &lt;= 0) {
 5983                 if (defaultValue != NULL)
 5984             xmlFree(defaultValue);
 5985             if (tree != NULL)
 5986             xmlFreeEnumeration(tree);
 5987             break;
 5988         }
 5989         if ((type != XML_ATTRIBUTE_CDATA) &amp;&amp; (defaultValue != NULL))
 5990             xmlAttrNormalizeSpace(defaultValue, defaultValue);
 5991 
 5992         GROW;
 5993             if (RAW != &#39;&gt;&#39;) {
 5994         if (SKIP_BLANKS == 0) {
 5995             xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5996             &quot;Space required after the attribute default value\n&quot;);
 5997             if (defaultValue != NULL)
 5998             xmlFree(defaultValue);
 5999             if (tree != NULL)
 6000             xmlFreeEnumeration(tree);
 6001             break;
 6002         }
 6003         }
 6004         if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX) &amp;&amp;
 6005         (ctxt-&gt;sax-&gt;attributeDecl != NULL))
 6006         ctxt-&gt;sax-&gt;attributeDecl(ctxt-&gt;userData, elemName, attrName,
 6007                             type, def, defaultValue, tree);
 6008         else if (tree != NULL)
 6009         xmlFreeEnumeration(tree);
 6010 
 6011         if ((ctxt-&gt;sax2) &amp;&amp; (defaultValue != NULL) &amp;&amp;
 6012             (def != XML_ATTRIBUTE_IMPLIED) &amp;&amp;
 6013         (def != XML_ATTRIBUTE_REQUIRED)) {
 6014         xmlAddDefAttrs(ctxt, elemName, attrName, defaultValue);
 6015         }
 6016         if (ctxt-&gt;sax2) {
 6017         xmlAddSpecialAttr(ctxt, elemName, attrName, type);
 6018         }
 6019         if (defaultValue != NULL)
 6020             xmlFree(defaultValue);
 6021         GROW;
 6022     }
 6023     if (RAW == &#39;&gt;&#39;) {
 6024         if (inputid != ctxt-&gt;input-&gt;id) {
 6025         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6026                                &quot;Attribute list declaration doesn&#39;t start and&quot;
 6027                                &quot; stop in the same entity\n&quot;);
 6028         }
 6029         NEXT;
 6030     }
 6031     }
 6032 }
 6033 
 6034 /**
 6035  * xmlParseElementMixedContentDecl:
 6036  * @ctxt:  an XML parser context
 6037  * @inputchk:  the input used for the current entity, needed for boundary checks
 6038  *
 6039  * parse the declaration for a Mixed Element content
 6040  * The leading &#39;(&#39; and spaces have been skipped in xmlParseElementContentDecl
 6041  *
 6042  * [51] Mixed ::= &#39;(&#39; S? &#39;#PCDATA&#39; (S? &#39;|&#39; S? Name)* S? &#39;)*&#39; |
 6043  *                &#39;(&#39; S? &#39;#PCDATA&#39; S? &#39;)&#39;
 6044  *
 6045  * [ VC: Proper Group/PE Nesting ] applies to [51] too (see [49])
 6046  *
 6047  * [ VC: No Duplicate Types ]
 6048  * The same name must not appear more than once in a single
 6049  * mixed-content declaration.
 6050  *
 6051  * returns: the list of the xmlElementContentPtr describing the element choices
 6052  */
 6053 xmlElementContentPtr
 6054 xmlParseElementMixedContentDecl(xmlParserCtxtPtr ctxt, int inputchk) {
 6055     xmlElementContentPtr ret = NULL, cur = NULL, n;
 6056     const xmlChar *elem = NULL;
 6057 
 6058     GROW;
 6059     if (CMP7(CUR_PTR, &#39;#&#39;, &#39;P&#39;, &#39;C&#39;, &#39;D&#39;, &#39;A&#39;, &#39;T&#39;, &#39;A&#39;)) {
 6060     SKIP(7);
 6061     SKIP_BLANKS;
 6062     SHRINK;
 6063     if (RAW == &#39;)&#39;) {
 6064         if (ctxt-&gt;input-&gt;id != inputchk) {
 6065         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6066                                &quot;Element content declaration doesn&#39;t start and&quot;
 6067                                &quot; stop in the same entity\n&quot;);
 6068         }
 6069         NEXT;
 6070         ret = xmlNewDocElementContent(ctxt-&gt;myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);
 6071         if (ret == NULL)
 6072             return(NULL);
 6073         if (RAW == &#39;*&#39;) {
 6074         ret-&gt;ocur = XML_ELEMENT_CONTENT_MULT;
 6075         NEXT;
 6076         }
 6077         return(ret);
 6078     }
 6079     if ((RAW == &#39;(&#39;) || (RAW == &#39;|&#39;)) {
 6080         ret = cur = xmlNewDocElementContent(ctxt-&gt;myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);
 6081         if (ret == NULL) return(NULL);
 6082     }
 6083     while ((RAW == &#39;|&#39;) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF)) {
 6084         NEXT;
 6085         if (elem == NULL) {
 6086             ret = xmlNewDocElementContent(ctxt-&gt;myDoc, NULL, XML_ELEMENT_CONTENT_OR);
 6087         if (ret == NULL) return(NULL);
 6088         ret-&gt;c1 = cur;
 6089         if (cur != NULL)
 6090             cur-&gt;parent = ret;
 6091         cur = ret;
 6092         } else {
 6093             n = xmlNewDocElementContent(ctxt-&gt;myDoc, NULL, XML_ELEMENT_CONTENT_OR);
 6094         if (n == NULL) return(NULL);
 6095         n-&gt;c1 = xmlNewDocElementContent(ctxt-&gt;myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);
 6096         if (n-&gt;c1 != NULL)
 6097             n-&gt;c1-&gt;parent = n;
 6098             cur-&gt;c2 = n;
 6099         if (n != NULL)
 6100             n-&gt;parent = cur;
 6101         cur = n;
 6102         }
 6103         SKIP_BLANKS;
 6104         elem = xmlParseName(ctxt);
 6105         if (elem == NULL) {
 6106         xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 6107             &quot;xmlParseElementMixedContentDecl : Name expected\n&quot;);
 6108         xmlFreeDocElementContent(ctxt-&gt;myDoc, ret);
 6109         return(NULL);
 6110         }
 6111         SKIP_BLANKS;
 6112         GROW;
 6113     }
 6114     if ((RAW == &#39;)&#39;) &amp;&amp; (NXT(1) == &#39;*&#39;)) {
 6115         if (elem != NULL) {
 6116         cur-&gt;c2 = xmlNewDocElementContent(ctxt-&gt;myDoc, elem,
 6117                                        XML_ELEMENT_CONTENT_ELEMENT);
 6118         if (cur-&gt;c2 != NULL)
 6119             cur-&gt;c2-&gt;parent = cur;
 6120             }
 6121             if (ret != NULL)
 6122                 ret-&gt;ocur = XML_ELEMENT_CONTENT_MULT;
 6123         if (ctxt-&gt;input-&gt;id != inputchk) {
 6124         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6125                                &quot;Element content declaration doesn&#39;t start and&quot;
 6126                                &quot; stop in the same entity\n&quot;);
 6127         }
 6128         SKIP(2);
 6129     } else {
 6130         xmlFreeDocElementContent(ctxt-&gt;myDoc, ret);
 6131         xmlFatalErr(ctxt, XML_ERR_MIXED_NOT_STARTED, NULL);
 6132         return(NULL);
 6133     }
 6134 
 6135     } else {
 6136     xmlFatalErr(ctxt, XML_ERR_PCDATA_REQUIRED, NULL);
 6137     }
 6138     return(ret);
 6139 }
 6140 
 6141 /**
 6142  * xmlParseElementChildrenContentDeclPriv:
 6143  * @ctxt:  an XML parser context
 6144  * @inputchk:  the input used for the current entity, needed for boundary checks
 6145  * @depth: the level of recursion
 6146  *
 6147  * parse the declaration for a Mixed Element content
 6148  * The leading &#39;(&#39; and spaces have been skipped in xmlParseElementContentDecl
 6149  *
 6150  *
 6151  * [47] children ::= (choice | seq) (&#39;?&#39; | &#39;*&#39; | &#39;+&#39;)?
 6152  *
 6153  * [48] cp ::= (Name | choice | seq) (&#39;?&#39; | &#39;*&#39; | &#39;+&#39;)?
 6154  *
 6155  * [49] choice ::= &#39;(&#39; S? cp ( S? &#39;|&#39; S? cp )* S? &#39;)&#39;
 6156  *
 6157  * [50] seq ::= &#39;(&#39; S? cp ( S? &#39;,&#39; S? cp )* S? &#39;)&#39;
 6158  *
 6159  * [ VC: Proper Group/PE Nesting ] applies to [49] and [50]
 6160  * TODO Parameter-entity replacement text must be properly nested
 6161  *  with parenthesized groups. That is to say, if either of the
 6162  *  opening or closing parentheses in a choice, seq, or Mixed
 6163  *  construct is contained in the replacement text for a parameter
 6164  *  entity, both must be contained in the same replacement text. For
 6165  *  interoperability, if a parameter-entity reference appears in a
 6166  *  choice, seq, or Mixed construct, its replacement text should not
 6167  *  be empty, and neither the first nor last non-blank character of
 6168  *  the replacement text should be a connector (| or ,).
 6169  *
 6170  * Returns the tree of xmlElementContentPtr describing the element
 6171  *          hierarchy.
 6172  */
 6173 static xmlElementContentPtr
 6174 xmlParseElementChildrenContentDeclPriv(xmlParserCtxtPtr ctxt, int inputchk,
 6175                                        int depth) {
 6176     xmlElementContentPtr ret = NULL, cur = NULL, last = NULL, op = NULL;
 6177     const xmlChar *elem;
 6178     xmlChar type = 0;
 6179 
 6180     if (((depth &gt; 128) &amp;&amp; ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) ||
 6181         (depth &gt;  2048)) {
 6182         xmlFatalErrMsgInt(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED,
 6183 &quot;xmlParseElementChildrenContentDecl : depth %d too deep, use XML_PARSE_HUGE\n&quot;,
 6184                           depth);
 6185     return(NULL);
 6186     }
 6187     SKIP_BLANKS;
 6188     GROW;
 6189     if (RAW == &#39;(&#39;) {
 6190     int inputid = ctxt-&gt;input-&gt;id;
 6191 
 6192         /* Recurse on first child */
 6193     NEXT;
 6194     SKIP_BLANKS;
 6195         cur = ret = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,
 6196                                                            depth + 1);
 6197     SKIP_BLANKS;
 6198     GROW;
 6199     } else {
 6200     elem = xmlParseName(ctxt);
 6201     if (elem == NULL) {
 6202         xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);
 6203         return(NULL);
 6204     }
 6205         cur = ret = xmlNewDocElementContent(ctxt-&gt;myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);
 6206     if (cur == NULL) {
 6207         xmlErrMemory(ctxt, NULL);
 6208         return(NULL);
 6209     }
 6210     GROW;
 6211     if (RAW == &#39;?&#39;) {
 6212         cur-&gt;ocur = XML_ELEMENT_CONTENT_OPT;
 6213         NEXT;
 6214     } else if (RAW == &#39;*&#39;) {
 6215         cur-&gt;ocur = XML_ELEMENT_CONTENT_MULT;
 6216         NEXT;
 6217     } else if (RAW == &#39;+&#39;) {
 6218         cur-&gt;ocur = XML_ELEMENT_CONTENT_PLUS;
 6219         NEXT;
 6220     } else {
 6221         cur-&gt;ocur = XML_ELEMENT_CONTENT_ONCE;
 6222     }
 6223     GROW;
 6224     }
 6225     SKIP_BLANKS;
 6226     SHRINK;
 6227     while ((RAW != &#39;)&#39;) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF)) {
 6228         /*
 6229      * Each loop we parse one separator and one element.
 6230      */
 6231         if (RAW == &#39;,&#39;) {
 6232         if (type == 0) type = CUR;
 6233 
 6234         /*
 6235          * Detect &quot;Name | Name , Name&quot; error
 6236          */
 6237         else if (type != CUR) {
 6238         xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,
 6239             &quot;xmlParseElementChildrenContentDecl : &#39;%c&#39; expected\n&quot;,
 6240                           type);
 6241         if ((last != NULL) &amp;&amp; (last != ret))
 6242             xmlFreeDocElementContent(ctxt-&gt;myDoc, last);
 6243         if (ret != NULL)
 6244             xmlFreeDocElementContent(ctxt-&gt;myDoc, ret);
 6245         return(NULL);
 6246         }
 6247         NEXT;
 6248 
 6249         op = xmlNewDocElementContent(ctxt-&gt;myDoc, NULL, XML_ELEMENT_CONTENT_SEQ);
 6250         if (op == NULL) {
 6251         if ((last != NULL) &amp;&amp; (last != ret))
 6252             xmlFreeDocElementContent(ctxt-&gt;myDoc, last);
 6253             xmlFreeDocElementContent(ctxt-&gt;myDoc, ret);
 6254         return(NULL);
 6255         }
 6256         if (last == NULL) {
 6257         op-&gt;c1 = ret;
 6258         if (ret != NULL)
 6259             ret-&gt;parent = op;
 6260         ret = cur = op;
 6261         } else {
 6262             cur-&gt;c2 = op;
 6263         if (op != NULL)
 6264             op-&gt;parent = cur;
 6265         op-&gt;c1 = last;
 6266         if (last != NULL)
 6267             last-&gt;parent = op;
 6268         cur =op;
 6269         last = NULL;
 6270         }
 6271     } else if (RAW == &#39;|&#39;) {
 6272         if (type == 0) type = CUR;
 6273 
 6274         /*
 6275          * Detect &quot;Name , Name | Name&quot; error
 6276          */
 6277         else if (type != CUR) {
 6278         xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,
 6279             &quot;xmlParseElementChildrenContentDecl : &#39;%c&#39; expected\n&quot;,
 6280                   type);
 6281         if ((last != NULL) &amp;&amp; (last != ret))
 6282             xmlFreeDocElementContent(ctxt-&gt;myDoc, last);
 6283         if (ret != NULL)
 6284             xmlFreeDocElementContent(ctxt-&gt;myDoc, ret);
 6285         return(NULL);
 6286         }
 6287         NEXT;
 6288 
 6289         op = xmlNewDocElementContent(ctxt-&gt;myDoc, NULL, XML_ELEMENT_CONTENT_OR);
 6290         if (op == NULL) {
 6291         if ((last != NULL) &amp;&amp; (last != ret))
 6292             xmlFreeDocElementContent(ctxt-&gt;myDoc, last);
 6293         if (ret != NULL)
 6294             xmlFreeDocElementContent(ctxt-&gt;myDoc, ret);
 6295         return(NULL);
 6296         }
 6297         if (last == NULL) {
 6298         op-&gt;c1 = ret;
 6299         if (ret != NULL)
 6300             ret-&gt;parent = op;
 6301         ret = cur = op;
 6302         } else {
 6303             cur-&gt;c2 = op;
 6304         if (op != NULL)
 6305             op-&gt;parent = cur;
 6306         op-&gt;c1 = last;
 6307         if (last != NULL)
 6308             last-&gt;parent = op;
 6309         cur =op;
 6310         last = NULL;
 6311         }
 6312     } else {
 6313         xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED, NULL);
 6314         if ((last != NULL) &amp;&amp; (last != ret))
 6315             xmlFreeDocElementContent(ctxt-&gt;myDoc, last);
 6316         if (ret != NULL)
 6317         xmlFreeDocElementContent(ctxt-&gt;myDoc, ret);
 6318         return(NULL);
 6319     }
 6320     GROW;
 6321     SKIP_BLANKS;
 6322     GROW;
 6323     if (RAW == &#39;(&#39;) {
 6324         int inputid = ctxt-&gt;input-&gt;id;
 6325         /* Recurse on second child */
 6326         NEXT;
 6327         SKIP_BLANKS;
 6328         last = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,
 6329                                                           depth + 1);
 6330         SKIP_BLANKS;
 6331     } else {
 6332         elem = xmlParseName(ctxt);
 6333         if (elem == NULL) {
 6334         xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);
 6335         if (ret != NULL)
 6336             xmlFreeDocElementContent(ctxt-&gt;myDoc, ret);
 6337         return(NULL);
 6338         }
 6339         last = xmlNewDocElementContent(ctxt-&gt;myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);
 6340         if (last == NULL) {
 6341         if (ret != NULL)
 6342             xmlFreeDocElementContent(ctxt-&gt;myDoc, ret);
 6343         return(NULL);
 6344         }
 6345         if (RAW == &#39;?&#39;) {
 6346         last-&gt;ocur = XML_ELEMENT_CONTENT_OPT;
 6347         NEXT;
 6348         } else if (RAW == &#39;*&#39;) {
 6349         last-&gt;ocur = XML_ELEMENT_CONTENT_MULT;
 6350         NEXT;
 6351         } else if (RAW == &#39;+&#39;) {
 6352         last-&gt;ocur = XML_ELEMENT_CONTENT_PLUS;
 6353         NEXT;
 6354         } else {
 6355         last-&gt;ocur = XML_ELEMENT_CONTENT_ONCE;
 6356         }
 6357     }
 6358     SKIP_BLANKS;
 6359     GROW;
 6360     }
 6361     if ((cur != NULL) &amp;&amp; (last != NULL)) {
 6362         cur-&gt;c2 = last;
 6363     if (last != NULL)
 6364         last-&gt;parent = cur;
 6365     }
 6366     if (ctxt-&gt;input-&gt;id != inputchk) {
 6367     xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6368                        &quot;Element content declaration doesn&#39;t start and stop in&quot;
 6369                        &quot; the same entity\n&quot;);
 6370     }
 6371     NEXT;
 6372     if (RAW == &#39;?&#39;) {
 6373     if (ret != NULL) {
 6374         if ((ret-&gt;ocur == XML_ELEMENT_CONTENT_PLUS) ||
 6375             (ret-&gt;ocur == XML_ELEMENT_CONTENT_MULT))
 6376             ret-&gt;ocur = XML_ELEMENT_CONTENT_MULT;
 6377         else
 6378             ret-&gt;ocur = XML_ELEMENT_CONTENT_OPT;
 6379     }
 6380     NEXT;
 6381     } else if (RAW == &#39;*&#39;) {
 6382     if (ret != NULL) {
 6383         ret-&gt;ocur = XML_ELEMENT_CONTENT_MULT;
 6384         cur = ret;
 6385         /*
 6386          * Some normalization:
 6387          * (a | b* | c?)* == (a | b | c)*
 6388          */
 6389         while ((cur != NULL) &amp;&amp; (cur-&gt;type == XML_ELEMENT_CONTENT_OR)) {
 6390         if ((cur-&gt;c1 != NULL) &amp;&amp;
 6391                 ((cur-&gt;c1-&gt;ocur == XML_ELEMENT_CONTENT_OPT) ||
 6392              (cur-&gt;c1-&gt;ocur == XML_ELEMENT_CONTENT_MULT)))
 6393             cur-&gt;c1-&gt;ocur = XML_ELEMENT_CONTENT_ONCE;
 6394         if ((cur-&gt;c2 != NULL) &amp;&amp;
 6395                 ((cur-&gt;c2-&gt;ocur == XML_ELEMENT_CONTENT_OPT) ||
 6396              (cur-&gt;c2-&gt;ocur == XML_ELEMENT_CONTENT_MULT)))
 6397             cur-&gt;c2-&gt;ocur = XML_ELEMENT_CONTENT_ONCE;
 6398         cur = cur-&gt;c2;
 6399         }
 6400     }
 6401     NEXT;
 6402     } else if (RAW == &#39;+&#39;) {
 6403     if (ret != NULL) {
 6404         int found = 0;
 6405 
 6406         if ((ret-&gt;ocur == XML_ELEMENT_CONTENT_OPT) ||
 6407             (ret-&gt;ocur == XML_ELEMENT_CONTENT_MULT))
 6408             ret-&gt;ocur = XML_ELEMENT_CONTENT_MULT;
 6409         else
 6410             ret-&gt;ocur = XML_ELEMENT_CONTENT_PLUS;
 6411         /*
 6412          * Some normalization:
 6413          * (a | b*)+ == (a | b)*
 6414          * (a | b?)+ == (a | b)*
 6415          */
 6416         while ((cur != NULL) &amp;&amp; (cur-&gt;type == XML_ELEMENT_CONTENT_OR)) {
 6417         if ((cur-&gt;c1 != NULL) &amp;&amp;
 6418                 ((cur-&gt;c1-&gt;ocur == XML_ELEMENT_CONTENT_OPT) ||
 6419              (cur-&gt;c1-&gt;ocur == XML_ELEMENT_CONTENT_MULT))) {
 6420             cur-&gt;c1-&gt;ocur = XML_ELEMENT_CONTENT_ONCE;
 6421             found = 1;
 6422         }
 6423         if ((cur-&gt;c2 != NULL) &amp;&amp;
 6424                 ((cur-&gt;c2-&gt;ocur == XML_ELEMENT_CONTENT_OPT) ||
 6425              (cur-&gt;c2-&gt;ocur == XML_ELEMENT_CONTENT_MULT))) {
 6426             cur-&gt;c2-&gt;ocur = XML_ELEMENT_CONTENT_ONCE;
 6427             found = 1;
 6428         }
 6429         cur = cur-&gt;c2;
 6430         }
 6431         if (found)
 6432         ret-&gt;ocur = XML_ELEMENT_CONTENT_MULT;
 6433     }
 6434     NEXT;
 6435     }
 6436     return(ret);
 6437 }
 6438 
 6439 /**
 6440  * xmlParseElementChildrenContentDecl:
 6441  * @ctxt:  an XML parser context
 6442  * @inputchk:  the input used for the current entity, needed for boundary checks
 6443  *
 6444  * parse the declaration for a Mixed Element content
 6445  * The leading &#39;(&#39; and spaces have been skipped in xmlParseElementContentDecl
 6446  *
 6447  * [47] children ::= (choice | seq) (&#39;?&#39; | &#39;*&#39; | &#39;+&#39;)?
 6448  *
 6449  * [48] cp ::= (Name | choice | seq) (&#39;?&#39; | &#39;*&#39; | &#39;+&#39;)?
 6450  *
 6451  * [49] choice ::= &#39;(&#39; S? cp ( S? &#39;|&#39; S? cp )* S? &#39;)&#39;
 6452  *
 6453  * [50] seq ::= &#39;(&#39; S? cp ( S? &#39;,&#39; S? cp )* S? &#39;)&#39;
 6454  *
 6455  * [ VC: Proper Group/PE Nesting ] applies to [49] and [50]
 6456  * TODO Parameter-entity replacement text must be properly nested
 6457  *  with parenthesized groups. That is to say, if either of the
 6458  *  opening or closing parentheses in a choice, seq, or Mixed
 6459  *  construct is contained in the replacement text for a parameter
 6460  *  entity, both must be contained in the same replacement text. For
 6461  *  interoperability, if a parameter-entity reference appears in a
 6462  *  choice, seq, or Mixed construct, its replacement text should not
 6463  *  be empty, and neither the first nor last non-blank character of
 6464  *  the replacement text should be a connector (| or ,).
 6465  *
 6466  * Returns the tree of xmlElementContentPtr describing the element
 6467  *          hierarchy.
 6468  */
 6469 xmlElementContentPtr
 6470 xmlParseElementChildrenContentDecl(xmlParserCtxtPtr ctxt, int inputchk) {
 6471     /* stub left for API/ABI compat */
 6472     return(xmlParseElementChildrenContentDeclPriv(ctxt, inputchk, 1));
 6473 }
 6474 
 6475 /**
 6476  * xmlParseElementContentDecl:
 6477  * @ctxt:  an XML parser context
 6478  * @name:  the name of the element being defined.
 6479  * @result:  the Element Content pointer will be stored here if any
 6480  *
 6481  * parse the declaration for an Element content either Mixed or Children,
 6482  * the cases EMPTY and ANY are handled directly in xmlParseElementDecl
 6483  *
 6484  * [46] contentspec ::= &#39;EMPTY&#39; | &#39;ANY&#39; | Mixed | children
 6485  *
 6486  * returns: the type of element content XML_ELEMENT_TYPE_xxx
 6487  */
 6488 
 6489 int
 6490 xmlParseElementContentDecl(xmlParserCtxtPtr ctxt, const xmlChar *name,
 6491                            xmlElementContentPtr *result) {
 6492 
 6493     xmlElementContentPtr tree = NULL;
 6494     int inputid = ctxt-&gt;input-&gt;id;
 6495     int res;
 6496 
 6497     *result = NULL;
 6498 
 6499     if (RAW != &#39;(&#39;) {
 6500     xmlFatalErrMsgStr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,
 6501         &quot;xmlParseElementContentDecl : %s &#39;(&#39; expected\n&quot;, name);
 6502     return(-1);
 6503     }
 6504     NEXT;
 6505     GROW;
 6506     if (ctxt-&gt;instate == XML_PARSER_EOF)
 6507         return(-1);
 6508     SKIP_BLANKS;
 6509     if (CMP7(CUR_PTR, &#39;#&#39;, &#39;P&#39;, &#39;C&#39;, &#39;D&#39;, &#39;A&#39;, &#39;T&#39;, &#39;A&#39;)) {
 6510         tree = xmlParseElementMixedContentDecl(ctxt, inputid);
 6511     res = XML_ELEMENT_TYPE_MIXED;
 6512     } else {
 6513         tree = xmlParseElementChildrenContentDeclPriv(ctxt, inputid, 1);
 6514     res = XML_ELEMENT_TYPE_ELEMENT;
 6515     }
 6516     SKIP_BLANKS;
 6517     *result = tree;
 6518     return(res);
 6519 }
 6520 
 6521 /**
 6522  * xmlParseElementDecl:
 6523  * @ctxt:  an XML parser context
 6524  *
 6525  * parse an Element declaration.
 6526  *
 6527  * [45] elementdecl ::= &#39;&lt;!ELEMENT&#39; S Name S contentspec S? &#39;&gt;&#39;
 6528  *
 6529  * [ VC: Unique Element Type Declaration ]
 6530  * No element type may be declared more than once
 6531  *
 6532  * Returns the type of the element, or -1 in case of error
 6533  */
 6534 int
 6535 xmlParseElementDecl(xmlParserCtxtPtr ctxt) {
 6536     const xmlChar *name;
 6537     int ret = -1;
 6538     xmlElementContentPtr content  = NULL;
 6539 
 6540     /* GROW; done in the caller */
 6541     if (CMP9(CUR_PTR, &#39;&lt;&#39;, &#39;!&#39;, &#39;E&#39;, &#39;L&#39;, &#39;E&#39;, &#39;M&#39;, &#39;E&#39;, &#39;N&#39;, &#39;T&#39;)) {
 6542     int inputid = ctxt-&gt;input-&gt;id;
 6543 
 6544     SKIP(9);
 6545     if (SKIP_BLANKS == 0) {
 6546         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6547                    &quot;Space required after &#39;ELEMENT&#39;\n&quot;);
 6548         return(-1);
 6549     }
 6550         name = xmlParseName(ctxt);
 6551     if (name == NULL) {
 6552         xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 6553                &quot;xmlParseElementDecl: no name for Element\n&quot;);
 6554         return(-1);
 6555     }
 6556     if (SKIP_BLANKS == 0) {
 6557         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6558                &quot;Space required after the element name\n&quot;);
 6559     }
 6560     if (CMP5(CUR_PTR, &#39;E&#39;, &#39;M&#39;, &#39;P&#39;, &#39;T&#39;, &#39;Y&#39;)) {
 6561         SKIP(5);
 6562         /*
 6563          * Element must always be empty.
 6564          */
 6565         ret = XML_ELEMENT_TYPE_EMPTY;
 6566     } else if ((RAW == &#39;A&#39;) &amp;&amp; (NXT(1) == &#39;N&#39;) &amp;&amp;
 6567                (NXT(2) == &#39;Y&#39;)) {
 6568         SKIP(3);
 6569         /*
 6570          * Element is a generic container.
 6571          */
 6572         ret = XML_ELEMENT_TYPE_ANY;
 6573     } else if (RAW == &#39;(&#39;) {
 6574         ret = xmlParseElementContentDecl(ctxt, name, &amp;content);
 6575     } else {
 6576         /*
 6577          * [ WFC: PEs in Internal Subset ] error handling.
 6578          */
 6579         if ((RAW == &#39;%&#39;) &amp;&amp; (ctxt-&gt;external == 0) &amp;&amp;
 6580             (ctxt-&gt;inputNr == 1)) {
 6581         xmlFatalErrMsg(ctxt, XML_ERR_PEREF_IN_INT_SUBSET,
 6582       &quot;PEReference: forbidden within markup decl in internal subset\n&quot;);
 6583         } else {
 6584         xmlFatalErrMsg(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,
 6585               &quot;xmlParseElementDecl: &#39;EMPTY&#39;, &#39;ANY&#39; or &#39;(&#39; expected\n&quot;);
 6586             }
 6587         return(-1);
 6588     }
 6589 
 6590     SKIP_BLANKS;
 6591 
 6592     if (RAW != &#39;&gt;&#39;) {
 6593         xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
 6594         if (content != NULL) {
 6595         xmlFreeDocElementContent(ctxt-&gt;myDoc, content);
 6596         }
 6597     } else {
 6598         if (inputid != ctxt-&gt;input-&gt;id) {
 6599         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6600                                &quot;Element declaration doesn&#39;t start and stop in&quot;
 6601                                &quot; the same entity\n&quot;);
 6602         }
 6603 
 6604         NEXT;
 6605         if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX) &amp;&amp;
 6606         (ctxt-&gt;sax-&gt;elementDecl != NULL)) {
 6607         if (content != NULL)
 6608             content-&gt;parent = NULL;
 6609             ctxt-&gt;sax-&gt;elementDecl(ctxt-&gt;userData, name, ret,
 6610                                content);
 6611         if ((content != NULL) &amp;&amp; (content-&gt;parent == NULL)) {
 6612             /*
 6613              * this is a trick: if xmlAddElementDecl is called,
 6614              * instead of copying the full tree it is plugged directly
 6615              * if called from the parser. Avoid duplicating the
 6616              * interfaces or change the API/ABI
 6617              */
 6618             xmlFreeDocElementContent(ctxt-&gt;myDoc, content);
 6619         }
 6620         } else if (content != NULL) {
 6621         xmlFreeDocElementContent(ctxt-&gt;myDoc, content);
 6622         }
 6623     }
 6624     }
 6625     return(ret);
 6626 }
 6627 
 6628 /**
 6629  * xmlParseConditionalSections
 6630  * @ctxt:  an XML parser context
 6631  *
 6632  * [61] conditionalSect ::= includeSect | ignoreSect
 6633  * [62] includeSect ::= &#39;&lt;![&#39; S? &#39;INCLUDE&#39; S? &#39;[&#39; extSubsetDecl &#39;]]&gt;&#39;
 6634  * [63] ignoreSect ::= &#39;&lt;![&#39; S? &#39;IGNORE&#39; S? &#39;[&#39; ignoreSectContents* &#39;]]&gt;&#39;
 6635  * [64] ignoreSectContents ::= Ignore (&#39;&lt;![&#39; ignoreSectContents &#39;]]&gt;&#39; Ignore)*
 6636  * [65] Ignore ::= Char* - (Char* (&#39;&lt;![&#39; | &#39;]]&gt;&#39;) Char*)
 6637  */
 6638 
 6639 static void
 6640 xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
<a name="31" id="anc31"></a><span class="line-added"> 6641     int *inputIds = NULL;</span>
<span class="line-added"> 6642     size_t inputIdsSize = 0;</span>
<span class="line-added"> 6643     size_t depth = 0;</span>
<span class="line-added"> 6644 </span>
<span class="line-added"> 6645     while (ctxt-&gt;instate != XML_PARSER_EOF) {</span>
<span class="line-added"> 6646         if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {</span>
 6647     int id = ctxt-&gt;input-&gt;id;
 6648 
 6649     SKIP(3);
 6650     SKIP_BLANKS;
<a name="32" id="anc32"></a><span class="line-added"> 6651 </span>
 6652     if (CMP7(CUR_PTR, &#39;I&#39;, &#39;N&#39;, &#39;C&#39;, &#39;L&#39;, &#39;U&#39;, &#39;D&#39;, &#39;E&#39;)) {
 6653     SKIP(7);
 6654     SKIP_BLANKS;
 6655     if (RAW != &#39;[&#39;) {
 6656         xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
 6657         xmlHaltParser(ctxt);
<a name="33" id="anc33"></a><span class="line-modified"> 6658                     goto error;</span>
<span class="line-modified"> 6659                 }</span>
 6660         if (ctxt-&gt;input-&gt;id != id) {
 6661         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
<a name="34" id="anc34"></a><span class="line-modified"> 6662                                    &quot;All markup of the conditional section is&quot;</span>
<span class="line-modified"> 6663                                    &quot; not in the same entity\n&quot;);</span>
 6664         }
 6665         NEXT;
<a name="35" id="anc35"></a>








 6666 
<a name="36" id="anc36"></a><span class="line-modified"> 6667                 if (inputIdsSize &lt;= depth) {</span>
<span class="line-modified"> 6668                     int *tmp;</span>












 6669 
<a name="37" id="anc37"></a><span class="line-modified"> 6670                     inputIdsSize = (inputIdsSize == 0 ? 4 : inputIdsSize * 2);</span>
<span class="line-modified"> 6671                     tmp = (int *) xmlRealloc(inputIds,</span>
<span class="line-modified"> 6672                             inputIdsSize * sizeof(int));</span>
<span class="line-modified"> 6673                     if (tmp == NULL) {</span>
<span class="line-added"> 6674                         xmlErrMemory(ctxt, NULL);</span>
<span class="line-added"> 6675                         goto error;</span>
 6676         }
<a name="38" id="anc38"></a><span class="line-added"> 6677                     inputIds = tmp;</span>
 6678     }
<a name="39" id="anc39"></a><span class="line-modified"> 6679                 inputIds[depth] = id;</span>
<span class="line-modified"> 6680                 depth++;</span>







 6681     } else if (CMP6(CUR_PTR, &#39;I&#39;, &#39;G&#39;, &#39;N&#39;, &#39;O&#39;, &#39;R&#39;, &#39;E&#39;)) {
 6682     int state;
 6683     xmlParserInputState instate;
<a name="40" id="anc40"></a><span class="line-modified"> 6684                 size_t ignoreDepth = 0;</span>
 6685 
 6686     SKIP(6);
 6687     SKIP_BLANKS;
 6688     if (RAW != &#39;[&#39;) {
 6689         xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
 6690         xmlHaltParser(ctxt);
<a name="41" id="anc41"></a><span class="line-modified"> 6691                     goto error;</span>
<span class="line-modified"> 6692                 }</span>
 6693         if (ctxt-&gt;input-&gt;id != id) {
 6694         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
<a name="42" id="anc42"></a><span class="line-modified"> 6695                                    &quot;All markup of the conditional section is&quot;</span>
<span class="line-modified"> 6696                                    &quot; not in the same entity\n&quot;);</span>
 6697         }
 6698         NEXT;
<a name="43" id="anc43"></a>








 6699 
 6700     /*
<a name="44" id="anc44"></a><span class="line-modified"> 6701                  * Parse up to the end of the conditional section but disable</span>
<span class="line-modified"> 6702                  * SAX event generating DTD building in the meantime</span>
 6703      */
 6704     state = ctxt-&gt;disableSAX;
 6705     instate = ctxt-&gt;instate;
 6706     if (ctxt-&gt;recovery == 0) ctxt-&gt;disableSAX = 1;
 6707     ctxt-&gt;instate = XML_PARSER_IGNORE;
 6708 
<a name="45" id="anc45"></a><span class="line-modified"> 6709                 while (RAW != 0) {</span>

 6710       if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {
<a name="46" id="anc46"></a>
 6711         SKIP(3);
<a name="47" id="anc47"></a><span class="line-modified"> 6712                         ignoreDepth++;</span>
<span class="line-modified"> 6713                         /* Check for integer overflow */</span>
<span class="line-modified"> 6714                         if (ignoreDepth == 0) {</span>
<span class="line-modified"> 6715                             xmlErrMemory(ctxt, NULL);</span>
<span class="line-modified"> 6716                             goto error;</span>
 6717       }
<a name="48" id="anc48"></a><span class="line-added"> 6718                     } else if ((RAW == &#39;]&#39;) &amp;&amp; (NXT(1) == &#39;]&#39;) &amp;&amp;</span>
<span class="line-added"> 6719                                (NXT(2) == &#39;&gt;&#39;)) {</span>
<span class="line-added"> 6720                         if (ignoreDepth == 0)</span>
<span class="line-added"> 6721                             break;</span>
<span class="line-added"> 6722                         SKIP(3);</span>
<span class="line-added"> 6723                         ignoreDepth--;</span>
<span class="line-added"> 6724                     } else {</span>
 6725       NEXT;
<a name="49" id="anc49"></a><span class="line-modified"> 6726                     }</span>
 6727     }
 6728 
 6729     ctxt-&gt;disableSAX = state;
 6730     ctxt-&gt;instate = instate;
 6731 
<a name="50" id="anc50"></a><span class="line-modified"> 6732         if (RAW == 0) {</span>
<span class="line-modified"> 6733             xmlFatalErr(ctxt, XML_ERR_CONDSEC_NOT_FINISHED, NULL);</span>
<span class="line-modified"> 6734                     goto error;</span>




 6735     }
<a name="51" id="anc51"></a><span class="line-modified"> 6736                 if (ctxt-&gt;input-&gt;id != id) {</span>
<span class="line-added"> 6737                     xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,</span>
<span class="line-added"> 6738                                    &quot;All markup of the conditional section is&quot;</span>
<span class="line-added"> 6739                                    &quot; not in the same entity\n&quot;);</span>
<span class="line-added"> 6740                 }</span>
<span class="line-added"> 6741                 SKIP(3);</span>
 6742     } else {
 6743     xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID_KEYWORD, NULL);
 6744     xmlHaltParser(ctxt);
<a name="52" id="anc52"></a><span class="line-modified"> 6745                 goto error;</span>
 6746     }
<a name="53" id="anc53"></a><span class="line-modified"> 6747         } else if ((depth &gt; 0) &amp;&amp;</span>
<span class="line-modified"> 6748                    (RAW == &#39;]&#39;) &amp;&amp; (NXT(1) == &#39;]&#39;) &amp;&amp; (NXT(2) == &#39;&gt;&#39;)) {</span>
<span class="line-modified"> 6749             depth--;</span>
<span class="line-modified"> 6750             if (ctxt-&gt;input-&gt;id != inputIds[depth]) {</span>




 6751         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
<a name="54" id="anc54"></a><span class="line-modified"> 6752                                &quot;All markup of the conditional section is not&quot;</span>
<span class="line-modified"> 6753                                &quot; in the same entity\n&quot;);</span>
 6754     }
<a name="55" id="anc55"></a>

 6755         SKIP(3);
<a name="56" id="anc56"></a><span class="line-added"> 6756         } else {</span>
<span class="line-added"> 6757             const xmlChar *check = CUR_PTR;</span>
<span class="line-added"> 6758             unsigned int cons = ctxt-&gt;input-&gt;consumed;</span>
<span class="line-added"> 6759 </span>
<span class="line-added"> 6760             xmlParseMarkupDecl(ctxt);</span>
<span class="line-added"> 6761 </span>
<span class="line-added"> 6762             if ((CUR_PTR == check) &amp;&amp; (cons == ctxt-&gt;input-&gt;consumed)) {</span>
<span class="line-added"> 6763                 xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);</span>
<span class="line-added"> 6764                 xmlHaltParser(ctxt);</span>
<span class="line-added"> 6765                 goto error;</span>
<span class="line-added"> 6766             }</span>
<span class="line-added"> 6767     }</span>
<span class="line-added"> 6768 </span>
<span class="line-added"> 6769         if (depth == 0)</span>
<span class="line-added"> 6770             break;</span>
<span class="line-added"> 6771 </span>
<span class="line-added"> 6772         SKIP_BLANKS;</span>
<span class="line-added"> 6773         GROW;</span>
 6774     }
<a name="57" id="anc57"></a><span class="line-added"> 6775 </span>
<span class="line-added"> 6776 error:</span>
<span class="line-added"> 6777     xmlFree(inputIds);</span>
 6778 }
 6779 
 6780 /**
 6781  * xmlParseMarkupDecl:
 6782  * @ctxt:  an XML parser context
 6783  *
 6784  * parse Markup declarations
 6785  *
 6786  * [29] markupdecl ::= elementdecl | AttlistDecl | EntityDecl |
 6787  *                     NotationDecl | PI | Comment
 6788  *
 6789  * [ VC: Proper Declaration/PE Nesting ]
 6790  * Parameter-entity replacement text must be properly nested with
 6791  * markup declarations. That is to say, if either the first character
 6792  * or the last character of a markup declaration (markupdecl above) is
 6793  * contained in the replacement text for a parameter-entity reference,
 6794  * both must be contained in the same replacement text.
 6795  *
 6796  * [ WFC: PEs in Internal Subset ]
 6797  * In the internal DTD subset, parameter-entity references can occur
 6798  * only where markup declarations can occur, not within markup declarations.
 6799  * (This does not apply to references that occur in external parameter
 6800  * entities or to the external subset.)
 6801  */
 6802 void
 6803 xmlParseMarkupDecl(xmlParserCtxtPtr ctxt) {
 6804     GROW;
 6805     if (CUR == &#39;&lt;&#39;) {
 6806         if (NXT(1) == &#39;!&#39;) {
 6807         switch (NXT(2)) {
 6808             case &#39;E&#39;:
 6809             if (NXT(3) == &#39;L&#39;)
 6810             xmlParseElementDecl(ctxt);
 6811             else if (NXT(3) == &#39;N&#39;)
 6812             xmlParseEntityDecl(ctxt);
 6813             break;
 6814             case &#39;A&#39;:
 6815             xmlParseAttributeListDecl(ctxt);
 6816             break;
 6817             case &#39;N&#39;:
 6818             xmlParseNotationDecl(ctxt);
 6819             break;
 6820             case &#39;-&#39;:
 6821             xmlParseComment(ctxt);
 6822             break;
 6823         default:
 6824             /* there is an error but it will be detected later */
 6825             break;
 6826         }
 6827     } else if (NXT(1) == &#39;?&#39;) {
 6828         xmlParsePI(ctxt);
 6829     }
 6830     }
 6831 
 6832     /*
 6833      * detect requirement to exit there and act accordingly
<a name="58" id="anc58"></a><span class="line-modified"> 6834      * and avoid having instate overridden later on</span>
 6835      */
 6836     if (ctxt-&gt;instate == XML_PARSER_EOF)
 6837         return;
 6838 
<a name="59" id="anc59"></a>









 6839     ctxt-&gt;instate = XML_PARSER_DTD;
 6840 }
 6841 
 6842 /**
 6843  * xmlParseTextDecl:
 6844  * @ctxt:  an XML parser context
 6845  *
 6846  * parse an XML declaration header for external entities
 6847  *
 6848  * [77] TextDecl ::= &#39;&lt;?xml&#39; VersionInfo? EncodingDecl S? &#39;?&gt;&#39;
 6849  */
 6850 
 6851 void
 6852 xmlParseTextDecl(xmlParserCtxtPtr ctxt) {
 6853     xmlChar *version;
 6854     const xmlChar *encoding;
 6855 
 6856     /*
 6857      * We know that &#39;&lt;?xml&#39; is here.
 6858      */
 6859     if ((CMP5(CUR_PTR, &#39;&lt;&#39;, &#39;?&#39;, &#39;x&#39;, &#39;m&#39;, &#39;l&#39;)) &amp;&amp; (IS_BLANK_CH(NXT(5)))) {
 6860     SKIP(5);
 6861     } else {
 6862     xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_STARTED, NULL);
 6863     return;
 6864     }
 6865 
 6866     if (SKIP_BLANKS == 0) {
 6867     xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6868                &quot;Space needed after &#39;&lt;?xml&#39;\n&quot;);
 6869     }
 6870 
 6871     /*
 6872      * We may have the VersionInfo here.
 6873      */
 6874     version = xmlParseVersionInfo(ctxt);
 6875     if (version == NULL)
 6876     version = xmlCharStrdup(XML_DEFAULT_VERSION);
 6877     else {
 6878     if (SKIP_BLANKS == 0) {
 6879         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6880                    &quot;Space needed here\n&quot;);
 6881     }
 6882     }
 6883     ctxt-&gt;input-&gt;version = version;
 6884 
 6885     /*
 6886      * We must have the encoding declaration
 6887      */
 6888     encoding = xmlParseEncodingDecl(ctxt);
 6889     if (ctxt-&gt;errNo == XML_ERR_UNSUPPORTED_ENCODING) {
 6890     /*
 6891      * The XML REC instructs us to stop parsing right here
 6892      */
 6893         return;
 6894     }
 6895     if ((encoding == NULL) &amp;&amp; (ctxt-&gt;errNo == XML_ERR_OK)) {
 6896     xmlFatalErrMsg(ctxt, XML_ERR_MISSING_ENCODING,
 6897                &quot;Missing encoding in text declaration\n&quot;);
 6898     }
 6899 
 6900     SKIP_BLANKS;
 6901     if ((RAW == &#39;?&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;)) {
 6902         SKIP(2);
 6903     } else if (RAW == &#39;&gt;&#39;) {
 6904         /* Deprecated old WD ... */
 6905     xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
 6906     NEXT;
 6907     } else {
 6908     xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
 6909     MOVETO_ENDTAG(CUR_PTR);
 6910     NEXT;
 6911     }
 6912 }
 6913 
 6914 /**
 6915  * xmlParseExternalSubset:
 6916  * @ctxt:  an XML parser context
 6917  * @ExternalID: the external identifier
 6918  * @SystemID: the system identifier (or URL)
 6919  *
 6920  * parse Markup declarations from an external subset
 6921  *
 6922  * [30] extSubset ::= textDecl? extSubsetDecl
 6923  *
 6924  * [31] extSubsetDecl ::= (markupdecl | conditionalSect | PEReference | S) *
 6925  */
 6926 void
 6927 xmlParseExternalSubset(xmlParserCtxtPtr ctxt, const xmlChar *ExternalID,
 6928                        const xmlChar *SystemID) {
 6929     xmlDetectSAX2(ctxt);
 6930     GROW;
 6931 
 6932     if ((ctxt-&gt;encoding == NULL) &amp;&amp;
 6933         (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &gt;= 4)) {
 6934         xmlChar start[4];
 6935     xmlCharEncoding enc;
 6936 
 6937     start[0] = RAW;
 6938     start[1] = NXT(1);
 6939     start[2] = NXT(2);
 6940     start[3] = NXT(3);
 6941     enc = xmlDetectCharEncoding(start, 4);
 6942     if (enc != XML_CHAR_ENCODING_NONE)
 6943         xmlSwitchEncoding(ctxt, enc);
 6944     }
 6945 
 6946     if (CMP5(CUR_PTR, &#39;&lt;&#39;, &#39;?&#39;, &#39;x&#39;, &#39;m&#39;, &#39;l&#39;)) {
 6947     xmlParseTextDecl(ctxt);
 6948     if (ctxt-&gt;errNo == XML_ERR_UNSUPPORTED_ENCODING) {
 6949         /*
 6950          * The XML REC instructs us to stop parsing right here
 6951          */
 6952         xmlHaltParser(ctxt);
 6953         return;
 6954     }
 6955     }
 6956     if (ctxt-&gt;myDoc == NULL) {
 6957         ctxt-&gt;myDoc = xmlNewDoc(BAD_CAST &quot;1.0&quot;);
 6958     if (ctxt-&gt;myDoc == NULL) {
 6959         xmlErrMemory(ctxt, &quot;New Doc failed&quot;);
 6960         return;
 6961     }
 6962     ctxt-&gt;myDoc-&gt;properties = XML_DOC_INTERNAL;
 6963     }
 6964     if ((ctxt-&gt;myDoc != NULL) &amp;&amp; (ctxt-&gt;myDoc-&gt;intSubset == NULL))
 6965         xmlCreateIntSubset(ctxt-&gt;myDoc, NULL, ExternalID, SystemID);
 6966 
 6967     ctxt-&gt;instate = XML_PARSER_DTD;
 6968     ctxt-&gt;external = 1;
 6969     SKIP_BLANKS;
 6970     while (((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;?&#39;)) ||
 6971            ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;)) ||
 6972        (RAW == &#39;%&#39;)) {
 6973     const xmlChar *check = CUR_PTR;
 6974     unsigned int cons = ctxt-&gt;input-&gt;consumed;
 6975 
 6976     GROW;
 6977         if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {
 6978         xmlParseConditionalSections(ctxt);
 6979     } else
 6980         xmlParseMarkupDecl(ctxt);
 6981         SKIP_BLANKS;
 6982 
 6983     if ((CUR_PTR == check) &amp;&amp; (cons == ctxt-&gt;input-&gt;consumed)) {
 6984         xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
 6985         break;
 6986     }
 6987     }
 6988 
 6989     if (RAW != 0) {
 6990     xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
 6991     }
 6992 
 6993 }
 6994 
 6995 /**
 6996  * xmlParseReference:
 6997  * @ctxt:  an XML parser context
 6998  *
 6999  * parse and handle entity references in content, depending on the SAX
 7000  * interface, this may end-up in a call to character() if this is a
 7001  * CharRef, a predefined entity, if there is no reference() callback.
 7002  * or if the parser was asked to switch to that mode.
 7003  *
 7004  * [67] Reference ::= EntityRef | CharRef
 7005  */
 7006 void
 7007 xmlParseReference(xmlParserCtxtPtr ctxt) {
 7008     xmlEntityPtr ent;
 7009     xmlChar *val;
 7010     int was_checked;
 7011     xmlNodePtr list = NULL;
 7012     xmlParserErrors ret = XML_ERR_OK;
 7013 
 7014 
 7015     if (RAW != &#39;&amp;&#39;)
 7016         return;
 7017 
 7018     /*
 7019      * Simple case of a CharRef
 7020      */
 7021     if (NXT(1) == &#39;#&#39;) {
 7022     int i = 0;
<a name="60" id="anc60"></a><span class="line-modified"> 7023     xmlChar out[16];</span>
 7024     int hex = NXT(2);
 7025     int value = xmlParseCharRef(ctxt);
 7026 
 7027     if (value == 0)
 7028         return;
 7029     if (ctxt-&gt;charset != XML_CHAR_ENCODING_UTF8) {
 7030         /*
 7031          * So we are using non-UTF-8 buffers
 7032          * Check that the char fit on 8bits, if not
 7033          * generate a CharRef.
 7034          */
 7035         if (value &lt;= 0xFF) {
 7036         out[0] = value;
 7037         out[1] = 0;
 7038         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;characters != NULL) &amp;&amp;
 7039             (!ctxt-&gt;disableSAX))
 7040             ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, out, 1);
 7041         } else {
 7042         if ((hex == &#39;x&#39;) || (hex == &#39;X&#39;))
 7043             snprintf((char *)out, sizeof(out), &quot;#x%X&quot;, value);
 7044         else
 7045             snprintf((char *)out, sizeof(out), &quot;#%d&quot;, value);
 7046         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;reference != NULL) &amp;&amp;
 7047             (!ctxt-&gt;disableSAX))
 7048             ctxt-&gt;sax-&gt;reference(ctxt-&gt;userData, out);
 7049         }
 7050     } else {
 7051         /*
 7052          * Just encode the value in UTF-8
 7053          */
 7054         COPY_BUF(0 ,out, i, value);
 7055         out[i] = 0;
 7056         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;characters != NULL) &amp;&amp;
 7057         (!ctxt-&gt;disableSAX))
 7058         ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, out, i);
 7059     }
 7060     return;
 7061     }
 7062 
 7063     /*
 7064      * We are seeing an entity reference
 7065      */
 7066     ent = xmlParseEntityRef(ctxt);
 7067     if (ent == NULL) return;
 7068     if (!ctxt-&gt;wellFormed)
 7069     return;
 7070     was_checked = ent-&gt;checked;
 7071 
 7072     /* special case of predefined entities */
 7073     if ((ent-&gt;name == NULL) ||
 7074         (ent-&gt;etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
 7075     val = ent-&gt;content;
 7076     if (val == NULL) return;
 7077     /*
 7078      * inline the entity.
 7079      */
 7080     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;characters != NULL) &amp;&amp;
 7081         (!ctxt-&gt;disableSAX))
 7082         ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, val, xmlStrlen(val));
 7083     return;
 7084     }
 7085 
 7086     /*
 7087      * The first reference to the entity trigger a parsing phase
 7088      * where the ent-&gt;children is filled with the result from
 7089      * the parsing.
 7090      * Note: external parsed entities will not be loaded, it is not
 7091      * required for a non-validating parser, unless the parsing option
 7092      * of validating, or substituting entities were given. Doing so is
 7093      * far more secure as the parser will only process data coming from
 7094      * the document entity by default.
 7095      */
 7096     if (((ent-&gt;checked == 0) ||
 7097          ((ent-&gt;children == NULL) &amp;&amp; (ctxt-&gt;options &amp; XML_PARSE_NOENT))) &amp;&amp;
 7098         ((ent-&gt;etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
 7099          (ctxt-&gt;options &amp; (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {
<a name="61" id="anc61"></a><span class="line-modified"> 7100     unsigned long oldnbent = ctxt-&gt;nbentities, diff;</span>
 7101 
 7102     /*
 7103      * This is a bit hackish but this seems the best
 7104      * way to make sure both SAX and DOM entity support
 7105      * behaves okay.
 7106      */
 7107     void *user_data;
 7108     if (ctxt-&gt;userData == ctxt)
 7109         user_data = NULL;
 7110     else
 7111         user_data = ctxt-&gt;userData;
 7112 
 7113     /*
 7114      * Check that this entity is well formed
 7115      * 4.3.2: An internal general parsed entity is well-formed
 7116      * if its replacement text matches the production labeled
 7117      * content.
 7118      */
 7119     if (ent-&gt;etype == XML_INTERNAL_GENERAL_ENTITY) {
 7120         ctxt-&gt;depth++;
 7121         ret = xmlParseBalancedChunkMemoryInternal(ctxt, ent-&gt;content,
 7122                                                   user_data, &amp;list);
 7123         ctxt-&gt;depth--;
 7124 
 7125     } else if (ent-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
 7126         ctxt-&gt;depth++;
 7127         ret = xmlParseExternalEntityPrivate(ctxt-&gt;myDoc, ctxt, ctxt-&gt;sax,
 7128                                        user_data, ctxt-&gt;depth, ent-&gt;URI,
 7129                        ent-&gt;ExternalID, &amp;list);
 7130         ctxt-&gt;depth--;
 7131     } else {
 7132         ret = XML_ERR_ENTITY_PE_INTERNAL;
 7133         xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,
 7134              &quot;invalid entity type found\n&quot;, NULL);
 7135     }
 7136 
 7137     /*
 7138      * Store the number of entities needing parsing for this entity
 7139      * content and do checkings
 7140      */
<a name="62" id="anc62"></a><span class="line-modified"> 7141         diff = ctxt-&gt;nbentities - oldnbent + 1;</span>
<span class="line-added"> 7142         if (diff &gt; INT_MAX / 2)</span>
<span class="line-added"> 7143             diff = INT_MAX / 2;</span>
<span class="line-added"> 7144         ent-&gt;checked = diff * 2;</span>
 7145     if ((ent-&gt;content != NULL) &amp;&amp; (xmlStrchr(ent-&gt;content, &#39;&lt;&#39;)))
 7146         ent-&gt;checked |= 1;
 7147     if (ret == XML_ERR_ENTITY_LOOP) {
 7148         xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 7149         xmlFreeNodeList(list);
 7150         return;
 7151     }
 7152     if (xmlParserEntityCheck(ctxt, 0, ent, 0)) {
 7153         xmlFreeNodeList(list);
 7154         return;
 7155     }
 7156 
 7157     if ((ret == XML_ERR_OK) &amp;&amp; (list != NULL)) {
 7158         if (((ent-&gt;etype == XML_INTERNAL_GENERAL_ENTITY) ||
 7159          (ent-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY))&amp;&amp;
 7160         (ent-&gt;children == NULL)) {
 7161         ent-&gt;children = list;
 7162         if (ctxt-&gt;replaceEntities) {
 7163             /*
 7164              * Prune it directly in the generated document
 7165              * except for single text nodes.
 7166              */
 7167             if (((list-&gt;type == XML_TEXT_NODE) &amp;&amp;
 7168              (list-&gt;next == NULL)) ||
 7169             (ctxt-&gt;parseMode == XML_PARSE_READER)) {
 7170             list-&gt;parent = (xmlNodePtr) ent;
 7171             list = NULL;
 7172             ent-&gt;owner = 1;
 7173             } else {
 7174             ent-&gt;owner = 0;
 7175             while (list != NULL) {
 7176                 list-&gt;parent = (xmlNodePtr) ctxt-&gt;node;
 7177                 list-&gt;doc = ctxt-&gt;myDoc;
 7178                 if (list-&gt;next == NULL)
 7179                 ent-&gt;last = list;
 7180                 list = list-&gt;next;
 7181             }
 7182             list = ent-&gt;children;
 7183 #ifdef LIBXML_LEGACY_ENABLED
 7184             if (ent-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
 7185               xmlAddEntityReference(ent, list, NULL);
 7186 #endif /* LIBXML_LEGACY_ENABLED */
 7187             }
 7188         } else {
 7189             ent-&gt;owner = 1;
 7190             while (list != NULL) {
 7191             list-&gt;parent = (xmlNodePtr) ent;
 7192             xmlSetTreeDoc(list, ent-&gt;doc);
 7193             if (list-&gt;next == NULL)
 7194                 ent-&gt;last = list;
 7195             list = list-&gt;next;
 7196             }
 7197         }
 7198         } else {
 7199         xmlFreeNodeList(list);
 7200         list = NULL;
 7201         }
 7202     } else if ((ret != XML_ERR_OK) &amp;&amp;
 7203            (ret != XML_WAR_UNDECLARED_ENTITY)) {
 7204         xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 7205              &quot;Entity &#39;%s&#39; failed to parse\n&quot;, ent-&gt;name);
 7206             if (ent-&gt;content != NULL)
 7207                 ent-&gt;content[0] = 0;
 7208         xmlParserEntityCheck(ctxt, 0, ent, 0);
 7209     } else if (list != NULL) {
 7210         xmlFreeNodeList(list);
 7211         list = NULL;
 7212     }
 7213     if (ent-&gt;checked == 0)
 7214         ent-&gt;checked = 2;
 7215 
 7216         /* Prevent entity from being parsed and expanded twice (Bug 760367). */
 7217         was_checked = 0;
 7218     } else if (ent-&gt;checked != 1) {
 7219     ctxt-&gt;nbentities += ent-&gt;checked / 2;
 7220     }
 7221 
 7222     /*
 7223      * Now that the entity content has been gathered
 7224      * provide it to the application, this can take different forms based
 7225      * on the parsing modes.
 7226      */
 7227     if (ent-&gt;children == NULL) {
 7228     /*
 7229      * Probably running in SAX mode and the callbacks don&#39;t
 7230      * build the entity content. So unless we already went
 7231      * though parsing for first checking go though the entity
 7232      * content to generate callbacks associated to the entity
 7233      */
 7234     if (was_checked != 0) {
 7235         void *user_data;
 7236         /*
 7237          * This is a bit hackish but this seems the best
 7238          * way to make sure both SAX and DOM entity support
 7239          * behaves okay.
 7240          */
 7241         if (ctxt-&gt;userData == ctxt)
 7242         user_data = NULL;
 7243         else
 7244         user_data = ctxt-&gt;userData;
 7245 
 7246         if (ent-&gt;etype == XML_INTERNAL_GENERAL_ENTITY) {
 7247         ctxt-&gt;depth++;
 7248         ret = xmlParseBalancedChunkMemoryInternal(ctxt,
 7249                    ent-&gt;content, user_data, NULL);
 7250         ctxt-&gt;depth--;
 7251         } else if (ent-&gt;etype ==
 7252                XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
 7253         ctxt-&gt;depth++;
 7254         ret = xmlParseExternalEntityPrivate(ctxt-&gt;myDoc, ctxt,
 7255                ctxt-&gt;sax, user_data, ctxt-&gt;depth,
 7256                ent-&gt;URI, ent-&gt;ExternalID, NULL);
 7257         ctxt-&gt;depth--;
 7258         } else {
 7259         ret = XML_ERR_ENTITY_PE_INTERNAL;
 7260         xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,
 7261                  &quot;invalid entity type found\n&quot;, NULL);
 7262         }
 7263         if (ret == XML_ERR_ENTITY_LOOP) {
 7264         xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 7265         return;
 7266         }
 7267     }
 7268     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;reference != NULL) &amp;&amp;
 7269         (ctxt-&gt;replaceEntities == 0) &amp;&amp; (!ctxt-&gt;disableSAX)) {
 7270         /*
 7271          * Entity reference callback comes second, it&#39;s somewhat
 7272          * superfluous but a compatibility to historical behaviour
 7273          */
 7274         ctxt-&gt;sax-&gt;reference(ctxt-&gt;userData, ent-&gt;name);
 7275     }
 7276     return;
 7277     }
 7278 
 7279     /*
 7280      * If we didn&#39;t get any children for the entity being built
 7281      */
 7282     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;reference != NULL) &amp;&amp;
 7283     (ctxt-&gt;replaceEntities == 0) &amp;&amp; (!ctxt-&gt;disableSAX)) {
 7284     /*
 7285      * Create a node.
 7286      */
 7287     ctxt-&gt;sax-&gt;reference(ctxt-&gt;userData, ent-&gt;name);
 7288     return;
 7289     }
 7290 
 7291     if ((ctxt-&gt;replaceEntities) || (ent-&gt;children == NULL))  {
 7292     /*
 7293      * There is a problem on the handling of _private for entities
 7294      * (bug 155816): Should we copy the content of the field from
 7295      * the entity (possibly overwriting some value set by the user
 7296      * when a copy is created), should we leave it alone, or should
 7297      * we try to take care of different situations?  The problem
 7298      * is exacerbated by the usage of this field by the xmlReader.
 7299      * To fix this bug, we look at _private on the created node
 7300      * and, if it&#39;s NULL, we copy in whatever was in the entity.
 7301      * If it&#39;s not NULL we leave it alone.  This is somewhat of a
 7302      * hack - maybe we should have further tests to determine
 7303      * what to do.
 7304      */
 7305     if ((ctxt-&gt;node != NULL) &amp;&amp; (ent-&gt;children != NULL)) {
 7306         /*
 7307          * Seems we are generating the DOM content, do
 7308          * a simple tree copy for all references except the first
 7309          * In the first occurrence list contains the replacement.
 7310          */
 7311         if (((list == NULL) &amp;&amp; (ent-&gt;owner == 0)) ||
 7312         (ctxt-&gt;parseMode == XML_PARSE_READER)) {
 7313         xmlNodePtr nw = NULL, cur, firstChild = NULL;
 7314 
 7315         /*
 7316          * We are copying here, make sure there is no abuse
 7317          */
 7318         ctxt-&gt;sizeentcopy += ent-&gt;length + 5;
 7319         if (xmlParserEntityCheck(ctxt, 0, ent, ctxt-&gt;sizeentcopy))
 7320             return;
 7321 
 7322         /*
 7323          * when operating on a reader, the entities definitions
 7324          * are always owning the entities subtree.
 7325         if (ctxt-&gt;parseMode == XML_PARSE_READER)
 7326             ent-&gt;owner = 1;
 7327          */
 7328 
 7329         cur = ent-&gt;children;
 7330         while (cur != NULL) {
 7331             nw = xmlDocCopyNode(cur, ctxt-&gt;myDoc, 1);
 7332             if (nw != NULL) {
 7333             if (nw-&gt;_private == NULL)
 7334                 nw-&gt;_private = cur-&gt;_private;
 7335             if (firstChild == NULL){
 7336                 firstChild = nw;
 7337             }
 7338             nw = xmlAddChild(ctxt-&gt;node, nw);
 7339             }
 7340             if (cur == ent-&gt;last) {
 7341             /*
 7342              * needed to detect some strange empty
 7343              * node cases in the reader tests
 7344              */
 7345             if ((ctxt-&gt;parseMode == XML_PARSE_READER) &amp;&amp;
 7346                 (nw != NULL) &amp;&amp;
 7347                 (nw-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
 7348                 (nw-&gt;children == NULL))
 7349                 nw-&gt;extra = 1;
 7350 
 7351             break;
 7352             }
 7353             cur = cur-&gt;next;
 7354         }
 7355 #ifdef LIBXML_LEGACY_ENABLED
 7356         if (ent-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
 7357           xmlAddEntityReference(ent, firstChild, nw);
 7358 #endif /* LIBXML_LEGACY_ENABLED */
 7359         } else if ((list == NULL) || (ctxt-&gt;inputNr &gt; 0)) {
 7360         xmlNodePtr nw = NULL, cur, next, last,
 7361                firstChild = NULL;
 7362 
 7363         /*
 7364          * We are copying here, make sure there is no abuse
 7365          */
 7366         ctxt-&gt;sizeentcopy += ent-&gt;length + 5;
 7367         if (xmlParserEntityCheck(ctxt, 0, ent, ctxt-&gt;sizeentcopy))
 7368             return;
 7369 
 7370         /*
 7371          * Copy the entity child list and make it the new
 7372          * entity child list. The goal is to make sure any
 7373          * ID or REF referenced will be the one from the
 7374          * document content and not the entity copy.
 7375          */
 7376         cur = ent-&gt;children;
 7377         ent-&gt;children = NULL;
 7378         last = ent-&gt;last;
 7379         ent-&gt;last = NULL;
 7380         while (cur != NULL) {
 7381             next = cur-&gt;next;
 7382             cur-&gt;next = NULL;
 7383             cur-&gt;parent = NULL;
 7384             nw = xmlDocCopyNode(cur, ctxt-&gt;myDoc, 1);
 7385             if (nw != NULL) {
 7386             if (nw-&gt;_private == NULL)
 7387                 nw-&gt;_private = cur-&gt;_private;
 7388             if (firstChild == NULL){
 7389                 firstChild = cur;
 7390             }
 7391             xmlAddChild((xmlNodePtr) ent, nw);
 7392             xmlAddChild(ctxt-&gt;node, cur);
 7393             }
 7394             if (cur == last)
 7395             break;
 7396             cur = next;
 7397         }
 7398         if (ent-&gt;owner == 0)
 7399             ent-&gt;owner = 1;
 7400 #ifdef LIBXML_LEGACY_ENABLED
 7401         if (ent-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
 7402           xmlAddEntityReference(ent, firstChild, nw);
 7403 #endif /* LIBXML_LEGACY_ENABLED */
 7404         } else {
 7405         const xmlChar *nbktext;
 7406 
 7407         /*
 7408          * the name change is to avoid coalescing of the
 7409          * node with a possible previous text one which
 7410          * would make ent-&gt;children a dangling pointer
 7411          */
 7412         nbktext = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;nbktext&quot;,
 7413                     -1);
 7414         if (ent-&gt;children-&gt;type == XML_TEXT_NODE)
 7415             ent-&gt;children-&gt;name = nbktext;
 7416         if ((ent-&gt;last != ent-&gt;children) &amp;&amp;
 7417             (ent-&gt;last-&gt;type == XML_TEXT_NODE))
 7418             ent-&gt;last-&gt;name = nbktext;
 7419         xmlAddChildList(ctxt-&gt;node, ent-&gt;children);
 7420         }
 7421 
 7422         /*
 7423          * This is to avoid a nasty side effect, see
 7424          * characters() in SAX.c
 7425          */
 7426         ctxt-&gt;nodemem = 0;
 7427         ctxt-&gt;nodelen = 0;
 7428         return;
 7429     }
 7430     }
 7431 }
 7432 
 7433 /**
 7434  * xmlParseEntityRef:
 7435  * @ctxt:  an XML parser context
 7436  *
 7437  * parse ENTITY references declarations
 7438  *
 7439  * [68] EntityRef ::= &#39;&amp;&#39; Name &#39;;&#39;
 7440  *
 7441  * [ WFC: Entity Declared ]
 7442  * In a document without any DTD, a document with only an internal DTD
 7443  * subset which contains no parameter entity references, or a document
 7444  * with &quot;standalone=&#39;yes&#39;&quot;, the Name given in the entity reference
 7445  * must match that in an entity declaration, except that well-formed
 7446  * documents need not declare any of the following entities: amp, lt,
 7447  * gt, apos, quot.  The declaration of a parameter entity must precede
 7448  * any reference to it.  Similarly, the declaration of a general entity
 7449  * must precede any reference to it which appears in a default value in an
 7450  * attribute-list declaration. Note that if entities are declared in the
 7451  * external subset or in external parameter entities, a non-validating
 7452  * processor is not obligated to read and process their declarations;
 7453  * for such documents, the rule that an entity must be declared is a
 7454  * well-formedness constraint only if standalone=&#39;yes&#39;.
 7455  *
 7456  * [ WFC: Parsed Entity ]
 7457  * An entity reference must not contain the name of an unparsed entity
 7458  *
 7459  * Returns the xmlEntityPtr if found, or NULL otherwise.
 7460  */
 7461 xmlEntityPtr
 7462 xmlParseEntityRef(xmlParserCtxtPtr ctxt) {
 7463     const xmlChar *name;
 7464     xmlEntityPtr ent = NULL;
 7465 
 7466     GROW;
 7467     if (ctxt-&gt;instate == XML_PARSER_EOF)
 7468         return(NULL);
 7469 
 7470     if (RAW != &#39;&amp;&#39;)
 7471         return(NULL);
 7472     NEXT;
 7473     name = xmlParseName(ctxt);
 7474     if (name == NULL) {
 7475     xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 7476                &quot;xmlParseEntityRef: no name\n&quot;);
 7477         return(NULL);
 7478     }
 7479     if (RAW != &#39;;&#39;) {
 7480     xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
 7481     return(NULL);
 7482     }
 7483     NEXT;
 7484 
 7485     /*
 7486      * Predefined entities override any extra definition
 7487      */
 7488     if ((ctxt-&gt;options &amp; XML_PARSE_OLDSAX) == 0) {
 7489         ent = xmlGetPredefinedEntity(name);
 7490         if (ent != NULL)
 7491             return(ent);
 7492     }
 7493 
 7494     /*
 7495      * Increase the number of entity references parsed
 7496      */
 7497     ctxt-&gt;nbentities++;
 7498 
 7499     /*
 7500      * Ask first SAX for entity resolution, otherwise try the
 7501      * entities which may have stored in the parser context.
 7502      */
 7503     if (ctxt-&gt;sax != NULL) {
 7504     if (ctxt-&gt;sax-&gt;getEntity != NULL)
 7505         ent = ctxt-&gt;sax-&gt;getEntity(ctxt-&gt;userData, name);
 7506     if ((ctxt-&gt;wellFormed == 1 ) &amp;&amp; (ent == NULL) &amp;&amp;
 7507         (ctxt-&gt;options &amp; XML_PARSE_OLDSAX))
 7508         ent = xmlGetPredefinedEntity(name);
 7509     if ((ctxt-&gt;wellFormed == 1 ) &amp;&amp; (ent == NULL) &amp;&amp;
 7510         (ctxt-&gt;userData==ctxt)) {
 7511         ent = xmlSAX2GetEntity(ctxt, name);
 7512     }
 7513     }
 7514     if (ctxt-&gt;instate == XML_PARSER_EOF)
 7515     return(NULL);
 7516     /*
 7517      * [ WFC: Entity Declared ]
 7518      * In a document without any DTD, a document with only an
 7519      * internal DTD subset which contains no parameter entity
 7520      * references, or a document with &quot;standalone=&#39;yes&#39;&quot;, the
 7521      * Name given in the entity reference must match that in an
 7522      * entity declaration, except that well-formed documents
 7523      * need not declare any of the following entities: amp, lt,
 7524      * gt, apos, quot.
 7525      * The declaration of a parameter entity must precede any
 7526      * reference to it.
 7527      * Similarly, the declaration of a general entity must
 7528      * precede any reference to it which appears in a default
 7529      * value in an attribute-list declaration. Note that if
 7530      * entities are declared in the external subset or in
 7531      * external parameter entities, a non-validating processor
 7532      * is not obligated to read and process their declarations;
 7533      * for such documents, the rule that an entity must be
 7534      * declared is a well-formedness constraint only if
 7535      * standalone=&#39;yes&#39;.
 7536      */
 7537     if (ent == NULL) {
 7538     if ((ctxt-&gt;standalone == 1) ||
 7539         ((ctxt-&gt;hasExternalSubset == 0) &amp;&amp;
 7540          (ctxt-&gt;hasPErefs == 0))) {
 7541         xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 7542              &quot;Entity &#39;%s&#39; not defined\n&quot;, name);
 7543     } else {
 7544         xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,
 7545              &quot;Entity &#39;%s&#39; not defined\n&quot;, name);
 7546         if ((ctxt-&gt;inSubset == 0) &amp;&amp;
 7547         (ctxt-&gt;sax != NULL) &amp;&amp;
 7548         (ctxt-&gt;sax-&gt;reference != NULL)) {
 7549         ctxt-&gt;sax-&gt;reference(ctxt-&gt;userData, name);
 7550         }
 7551     }
 7552     xmlParserEntityCheck(ctxt, 0, ent, 0);
 7553     ctxt-&gt;valid = 0;
 7554     }
 7555 
 7556     /*
 7557      * [ WFC: Parsed Entity ]
 7558      * An entity reference must not contain the name of an
 7559      * unparsed entity
 7560      */
 7561     else if (ent-&gt;etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {
 7562     xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,
 7563          &quot;Entity reference to unparsed entity %s\n&quot;, name);
 7564     }
 7565 
 7566     /*
 7567      * [ WFC: No External Entity References ]
 7568      * Attribute values cannot contain direct or indirect
 7569      * entity references to external entities.
 7570      */
 7571     else if ((ctxt-&gt;instate == XML_PARSER_ATTRIBUTE_VALUE) &amp;&amp;
 7572          (ent-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {
 7573     xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,
 7574          &quot;Attribute references external entity &#39;%s&#39;\n&quot;, name);
 7575     }
 7576     /*
 7577      * [ WFC: No &lt; in Attribute Values ]
 7578      * The replacement text of any entity referred to directly or
 7579      * indirectly in an attribute value (other than &quot;&amp;lt;&quot;) must
 7580      * not contain a &lt;.
 7581      */
 7582     else if ((ctxt-&gt;instate == XML_PARSER_ATTRIBUTE_VALUE) &amp;&amp;
 7583          (ent != NULL) &amp;&amp;
 7584          (ent-&gt;etype != XML_INTERNAL_PREDEFINED_ENTITY)) {
 7585     if (((ent-&gt;checked &amp; 1) || (ent-&gt;checked == 0)) &amp;&amp;
 7586          (ent-&gt;content != NULL) &amp;&amp; (xmlStrchr(ent-&gt;content, &#39;&lt;&#39;))) {
 7587         xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,
 7588     &quot;&#39;&lt;&#39; in entity &#39;%s&#39; is not allowed in attributes values\n&quot;, name);
 7589         }
 7590     }
 7591 
 7592     /*
 7593      * Internal check, no parameter entities here ...
 7594      */
 7595     else {
 7596     switch (ent-&gt;etype) {
 7597         case XML_INTERNAL_PARAMETER_ENTITY:
 7598         case XML_EXTERNAL_PARAMETER_ENTITY:
 7599         xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,
 7600          &quot;Attempt to reference the parameter entity &#39;%s&#39;\n&quot;,
 7601                   name);
 7602         break;
 7603         default:
 7604         break;
 7605     }
 7606     }
 7607 
 7608     /*
 7609      * [ WFC: No Recursion ]
 7610      * A parsed entity must not contain a recursive reference
 7611      * to itself, either directly or indirectly.
 7612      * Done somewhere else
 7613      */
 7614     return(ent);
 7615 }
 7616 
 7617 /**
 7618  * xmlParseStringEntityRef:
 7619  * @ctxt:  an XML parser context
 7620  * @str:  a pointer to an index in the string
 7621  *
 7622  * parse ENTITY references declarations, but this version parses it from
 7623  * a string value.
 7624  *
 7625  * [68] EntityRef ::= &#39;&amp;&#39; Name &#39;;&#39;
 7626  *
 7627  * [ WFC: Entity Declared ]
 7628  * In a document without any DTD, a document with only an internal DTD
 7629  * subset which contains no parameter entity references, or a document
 7630  * with &quot;standalone=&#39;yes&#39;&quot;, the Name given in the entity reference
 7631  * must match that in an entity declaration, except that well-formed
 7632  * documents need not declare any of the following entities: amp, lt,
 7633  * gt, apos, quot.  The declaration of a parameter entity must precede
 7634  * any reference to it.  Similarly, the declaration of a general entity
 7635  * must precede any reference to it which appears in a default value in an
 7636  * attribute-list declaration. Note that if entities are declared in the
 7637  * external subset or in external parameter entities, a non-validating
 7638  * processor is not obligated to read and process their declarations;
 7639  * for such documents, the rule that an entity must be declared is a
 7640  * well-formedness constraint only if standalone=&#39;yes&#39;.
 7641  *
 7642  * [ WFC: Parsed Entity ]
 7643  * An entity reference must not contain the name of an unparsed entity
 7644  *
 7645  * Returns the xmlEntityPtr if found, or NULL otherwise. The str pointer
 7646  * is updated to the current location in the string.
 7647  */
 7648 static xmlEntityPtr
 7649 xmlParseStringEntityRef(xmlParserCtxtPtr ctxt, const xmlChar ** str) {
 7650     xmlChar *name;
 7651     const xmlChar *ptr;
 7652     xmlChar cur;
 7653     xmlEntityPtr ent = NULL;
 7654 
 7655     if ((str == NULL) || (*str == NULL))
 7656         return(NULL);
 7657     ptr = *str;
 7658     cur = *ptr;
 7659     if (cur != &#39;&amp;&#39;)
 7660     return(NULL);
 7661 
 7662     ptr++;
 7663     name = xmlParseStringName(ctxt, &amp;ptr);
 7664     if (name == NULL) {
 7665     xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 7666                &quot;xmlParseStringEntityRef: no name\n&quot;);
 7667     *str = ptr;
 7668     return(NULL);
 7669     }
 7670     if (*ptr != &#39;;&#39;) {
 7671     xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
 7672         xmlFree(name);
 7673     *str = ptr;
 7674     return(NULL);
 7675     }
 7676     ptr++;
 7677 
 7678 
 7679     /*
 7680      * Predefined entities override any extra definition
 7681      */
 7682     if ((ctxt-&gt;options &amp; XML_PARSE_OLDSAX) == 0) {
 7683         ent = xmlGetPredefinedEntity(name);
 7684         if (ent != NULL) {
 7685             xmlFree(name);
 7686             *str = ptr;
 7687             return(ent);
 7688         }
 7689     }
 7690 
 7691     /*
<a name="63" id="anc63"></a><span class="line-modified"> 7692      * Increase the number of entity references parsed</span>
 7693      */
 7694     ctxt-&gt;nbentities++;
 7695 
 7696     /*
 7697      * Ask first SAX for entity resolution, otherwise try the
 7698      * entities which may have stored in the parser context.
 7699      */
 7700     if (ctxt-&gt;sax != NULL) {
 7701     if (ctxt-&gt;sax-&gt;getEntity != NULL)
 7702         ent = ctxt-&gt;sax-&gt;getEntity(ctxt-&gt;userData, name);
 7703     if ((ent == NULL) &amp;&amp; (ctxt-&gt;options &amp; XML_PARSE_OLDSAX))
 7704         ent = xmlGetPredefinedEntity(name);
 7705     if ((ent == NULL) &amp;&amp; (ctxt-&gt;userData==ctxt)) {
 7706         ent = xmlSAX2GetEntity(ctxt, name);
 7707     }
 7708     }
 7709     if (ctxt-&gt;instate == XML_PARSER_EOF) {
 7710     xmlFree(name);
 7711     return(NULL);
 7712     }
 7713 
 7714     /*
 7715      * [ WFC: Entity Declared ]
 7716      * In a document without any DTD, a document with only an
 7717      * internal DTD subset which contains no parameter entity
 7718      * references, or a document with &quot;standalone=&#39;yes&#39;&quot;, the
 7719      * Name given in the entity reference must match that in an
 7720      * entity declaration, except that well-formed documents
 7721      * need not declare any of the following entities: amp, lt,
 7722      * gt, apos, quot.
 7723      * The declaration of a parameter entity must precede any
 7724      * reference to it.
 7725      * Similarly, the declaration of a general entity must
 7726      * precede any reference to it which appears in a default
 7727      * value in an attribute-list declaration. Note that if
 7728      * entities are declared in the external subset or in
 7729      * external parameter entities, a non-validating processor
 7730      * is not obligated to read and process their declarations;
 7731      * for such documents, the rule that an entity must be
 7732      * declared is a well-formedness constraint only if
 7733      * standalone=&#39;yes&#39;.
 7734      */
 7735     if (ent == NULL) {
 7736     if ((ctxt-&gt;standalone == 1) ||
 7737         ((ctxt-&gt;hasExternalSubset == 0) &amp;&amp;
 7738          (ctxt-&gt;hasPErefs == 0))) {
 7739         xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 7740              &quot;Entity &#39;%s&#39; not defined\n&quot;, name);
 7741     } else {
 7742         xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,
 7743               &quot;Entity &#39;%s&#39; not defined\n&quot;,
 7744               name);
 7745     }
 7746     xmlParserEntityCheck(ctxt, 0, ent, 0);
 7747     /* TODO ? check regressions ctxt-&gt;valid = 0; */
 7748     }
 7749 
 7750     /*
 7751      * [ WFC: Parsed Entity ]
 7752      * An entity reference must not contain the name of an
 7753      * unparsed entity
 7754      */
 7755     else if (ent-&gt;etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {
 7756     xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,
 7757          &quot;Entity reference to unparsed entity %s\n&quot;, name);
 7758     }
 7759 
 7760     /*
 7761      * [ WFC: No External Entity References ]
 7762      * Attribute values cannot contain direct or indirect
 7763      * entity references to external entities.
 7764      */
 7765     else if ((ctxt-&gt;instate == XML_PARSER_ATTRIBUTE_VALUE) &amp;&amp;
 7766          (ent-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {
 7767     xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,
 7768      &quot;Attribute references external entity &#39;%s&#39;\n&quot;, name);
 7769     }
 7770     /*
 7771      * [ WFC: No &lt; in Attribute Values ]
 7772      * The replacement text of any entity referred to directly or
 7773      * indirectly in an attribute value (other than &quot;&amp;lt;&quot;) must
 7774      * not contain a &lt;.
 7775      */
 7776     else if ((ctxt-&gt;instate == XML_PARSER_ATTRIBUTE_VALUE) &amp;&amp;
 7777          (ent != NULL) &amp;&amp; (ent-&gt;content != NULL) &amp;&amp;
 7778          (ent-&gt;etype != XML_INTERNAL_PREDEFINED_ENTITY) &amp;&amp;
 7779          (xmlStrchr(ent-&gt;content, &#39;&lt;&#39;))) {
 7780     xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,
 7781      &quot;&#39;&lt;&#39; in entity &#39;%s&#39; is not allowed in attributes values\n&quot;,
 7782               name);
 7783     }
 7784 
 7785     /*
 7786      * Internal check, no parameter entities here ...
 7787      */
 7788     else {
 7789     switch (ent-&gt;etype) {
 7790         case XML_INTERNAL_PARAMETER_ENTITY:
 7791         case XML_EXTERNAL_PARAMETER_ENTITY:
 7792         xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,
 7793          &quot;Attempt to reference the parameter entity &#39;%s&#39;\n&quot;,
 7794                   name);
 7795         break;
 7796         default:
 7797         break;
 7798     }
 7799     }
 7800 
 7801     /*
 7802      * [ WFC: No Recursion ]
 7803      * A parsed entity must not contain a recursive reference
 7804      * to itself, either directly or indirectly.
 7805      * Done somewhere else
 7806      */
 7807 
 7808     xmlFree(name);
 7809     *str = ptr;
 7810     return(ent);
 7811 }
 7812 
 7813 /**
 7814  * xmlParsePEReference:
 7815  * @ctxt:  an XML parser context
 7816  *
 7817  * parse PEReference declarations
 7818  * The entity content is handled directly by pushing it&#39;s content as
 7819  * a new input stream.
 7820  *
 7821  * [69] PEReference ::= &#39;%&#39; Name &#39;;&#39;
 7822  *
 7823  * [ WFC: No Recursion ]
 7824  * A parsed entity must not contain a recursive
 7825  * reference to itself, either directly or indirectly.
 7826  *
 7827  * [ WFC: Entity Declared ]
 7828  * In a document without any DTD, a document with only an internal DTD
 7829  * subset which contains no parameter entity references, or a document
 7830  * with &quot;standalone=&#39;yes&#39;&quot;, ...  ... The declaration of a parameter
 7831  * entity must precede any reference to it...
 7832  *
 7833  * [ VC: Entity Declared ]
 7834  * In a document with an external subset or external parameter entities
 7835  * with &quot;standalone=&#39;no&#39;&quot;, ...  ... The declaration of a parameter entity
 7836  * must precede any reference to it...
 7837  *
 7838  * [ WFC: In DTD ]
 7839  * Parameter-entity references may only appear in the DTD.
 7840  * NOTE: misleading but this is handled.
 7841  */
 7842 void
 7843 xmlParsePEReference(xmlParserCtxtPtr ctxt)
 7844 {
 7845     const xmlChar *name;
 7846     xmlEntityPtr entity = NULL;
 7847     xmlParserInputPtr input;
 7848 
 7849     if (RAW != &#39;%&#39;)
 7850         return;
 7851     NEXT;
 7852     name = xmlParseName(ctxt);
 7853     if (name == NULL) {
 7854     xmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, &quot;PEReference: no name\n&quot;);
 7855     return;
 7856     }
 7857     if (xmlParserDebugEntities)
 7858     xmlGenericError(xmlGenericErrorContext,
 7859         &quot;PEReference: %s\n&quot;, name);
 7860     if (RAW != &#39;;&#39;) {
 7861     xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);
 7862         return;
 7863     }
 7864 
 7865     NEXT;
 7866 
 7867     /*
<a name="64" id="anc64"></a><span class="line-modified"> 7868      * Increase the number of entity references parsed</span>
 7869      */
 7870     ctxt-&gt;nbentities++;
 7871 
 7872     /*
 7873      * Request the entity from SAX
 7874      */
 7875     if ((ctxt-&gt;sax != NULL) &amp;&amp;
 7876     (ctxt-&gt;sax-&gt;getParameterEntity != NULL))
 7877     entity = ctxt-&gt;sax-&gt;getParameterEntity(ctxt-&gt;userData, name);
 7878     if (ctxt-&gt;instate == XML_PARSER_EOF)
 7879     return;
 7880     if (entity == NULL) {
 7881     /*
 7882      * [ WFC: Entity Declared ]
 7883      * In a document without any DTD, a document with only an
 7884      * internal DTD subset which contains no parameter entity
 7885      * references, or a document with &quot;standalone=&#39;yes&#39;&quot;, ...
 7886      * ... The declaration of a parameter entity must precede
 7887      * any reference to it...
 7888      */
 7889     if ((ctxt-&gt;standalone == 1) ||
 7890         ((ctxt-&gt;hasExternalSubset == 0) &amp;&amp;
 7891          (ctxt-&gt;hasPErefs == 0))) {
 7892         xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 7893                   &quot;PEReference: %%%s; not found\n&quot;,
 7894                   name);
 7895     } else {
 7896         /*
 7897          * [ VC: Entity Declared ]
 7898          * In a document with an external subset or external
 7899          * parameter entities with &quot;standalone=&#39;no&#39;&quot;, ...
 7900          * ... The declaration of a parameter entity must
 7901          * precede any reference to it...
 7902          */
 7903             if ((ctxt-&gt;validate) &amp;&amp; (ctxt-&gt;vctxt.error != NULL)) {
 7904                 xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY,
 7905                                  &quot;PEReference: %%%s; not found\n&quot;,
 7906                                  name, NULL);
 7907             } else
 7908                 xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
 7909                               &quot;PEReference: %%%s; not found\n&quot;,
 7910                               name, NULL);
 7911             ctxt-&gt;valid = 0;
 7912     }
 7913     xmlParserEntityCheck(ctxt, 0, NULL, 0);
 7914     } else {
 7915     /*
 7916      * Internal checking in case the entity quest barfed
 7917      */
 7918     if ((entity-&gt;etype != XML_INTERNAL_PARAMETER_ENTITY) &amp;&amp;
 7919         (entity-&gt;etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
 7920         xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
 7921           &quot;Internal: %%%s; is not a parameter entity\n&quot;,
 7922               name, NULL);
 7923     } else {
 7924             xmlChar start[4];
 7925             xmlCharEncoding enc;
 7926 
 7927         if ((entity-&gt;etype == XML_EXTERNAL_PARAMETER_ENTITY) &amp;&amp;
 7928             ((ctxt-&gt;options &amp; XML_PARSE_NOENT) == 0) &amp;&amp;
 7929         ((ctxt-&gt;options &amp; XML_PARSE_DTDVALID) == 0) &amp;&amp;
 7930         ((ctxt-&gt;options &amp; XML_PARSE_DTDLOAD) == 0) &amp;&amp;
 7931         ((ctxt-&gt;options &amp; XML_PARSE_DTDATTR) == 0) &amp;&amp;
 7932         (ctxt-&gt;replaceEntities == 0) &amp;&amp;
 7933         (ctxt-&gt;validate == 0))
 7934         return;
 7935 
 7936         input = xmlNewEntityInputStream(ctxt, entity);
 7937         if (xmlPushInput(ctxt, input) &lt; 0) {
 7938                 xmlFreeInputStream(input);
 7939         return;
 7940             }
 7941 
 7942         if (entity-&gt;etype == XML_EXTERNAL_PARAMETER_ENTITY) {
 7943                 /*
 7944                  * Get the 4 first bytes and decode the charset
 7945                  * if enc != XML_CHAR_ENCODING_NONE
 7946                  * plug some encoding conversion routines.
 7947                  * Note that, since we may have some non-UTF8
 7948                  * encoding (like UTF16, bug 135229), the &#39;length&#39;
 7949                  * is not known, but we can calculate based upon
 7950                  * the amount of data in the buffer.
 7951                  */
 7952                 GROW
 7953                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 7954                     return;
 7955                 if ((ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur)&gt;=4) {
 7956                     start[0] = RAW;
 7957                     start[1] = NXT(1);
 7958                     start[2] = NXT(2);
 7959                     start[3] = NXT(3);
 7960                     enc = xmlDetectCharEncoding(start, 4);
 7961                     if (enc != XML_CHAR_ENCODING_NONE) {
 7962                         xmlSwitchEncoding(ctxt, enc);
 7963                     }
 7964                 }
 7965 
 7966                 if ((CMP5(CUR_PTR, &#39;&lt;&#39;, &#39;?&#39;, &#39;x&#39;, &#39;m&#39;, &#39;l&#39;)) &amp;&amp;
 7967                     (IS_BLANK_CH(NXT(5)))) {
 7968                     xmlParseTextDecl(ctxt);
 7969                 }
 7970             }
 7971     }
 7972     }
 7973     ctxt-&gt;hasPErefs = 1;
 7974 }
 7975 
 7976 /**
 7977  * xmlLoadEntityContent:
 7978  * @ctxt:  an XML parser context
 7979  * @entity: an unloaded system entity
 7980  *
 7981  * Load the original content of the given system entity from the
 7982  * ExternalID/SystemID given. This is to be used for Included in Literal
 7983  * http://www.w3.org/TR/REC-xml/#inliteral processing of entities references
 7984  *
 7985  * Returns 0 in case of success and -1 in case of failure
 7986  */
 7987 static int
 7988 xmlLoadEntityContent(xmlParserCtxtPtr ctxt, xmlEntityPtr entity) {
 7989     xmlParserInputPtr input;
 7990     xmlBufferPtr buf;
 7991     int l, c;
 7992     int count = 0;
 7993 
 7994     if ((ctxt == NULL) || (entity == NULL) ||
 7995         ((entity-&gt;etype != XML_EXTERNAL_PARAMETER_ENTITY) &amp;&amp;
 7996      (entity-&gt;etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY)) ||
 7997     (entity-&gt;content != NULL)) {
 7998     xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 7999                 &quot;xmlLoadEntityContent parameter error&quot;);
 8000         return(-1);
 8001     }
 8002 
 8003     if (xmlParserDebugEntities)
 8004     xmlGenericError(xmlGenericErrorContext,
 8005         &quot;Reading %s entity content input\n&quot;, entity-&gt;name);
 8006 
 8007     buf = xmlBufferCreate();
 8008     if (buf == NULL) {
 8009     xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 8010                 &quot;xmlLoadEntityContent parameter error&quot;);
 8011         return(-1);
 8012     }
 8013 
 8014     input = xmlNewEntityInputStream(ctxt, entity);
 8015     if (input == NULL) {
 8016     xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 8017                 &quot;xmlLoadEntityContent input error&quot;);
 8018     xmlBufferFree(buf);
 8019         return(-1);
 8020     }
 8021 
 8022     /*
 8023      * Push the entity as the current input, read char by char
 8024      * saving to the buffer until the end of the entity or an error
 8025      */
 8026     if (xmlPushInput(ctxt, input) &lt; 0) {
 8027         xmlBufferFree(buf);
 8028     return(-1);
 8029     }
 8030 
 8031     GROW;
 8032     c = CUR_CHAR(l);
 8033     while ((ctxt-&gt;input == input) &amp;&amp; (ctxt-&gt;input-&gt;cur &lt; ctxt-&gt;input-&gt;end) &amp;&amp;
 8034            (IS_CHAR(c))) {
 8035         xmlBufferAdd(buf, ctxt-&gt;input-&gt;cur, l);
 8036     if (count++ &gt; XML_PARSER_CHUNK_SIZE) {
 8037         count = 0;
 8038         GROW;
 8039             if (ctxt-&gt;instate == XML_PARSER_EOF) {
 8040                 xmlBufferFree(buf);
 8041                 return(-1);
 8042             }
 8043     }
 8044     NEXTL(l);
 8045     c = CUR_CHAR(l);
 8046     if (c == 0) {
 8047         count = 0;
 8048         GROW;
 8049             if (ctxt-&gt;instate == XML_PARSER_EOF) {
 8050                 xmlBufferFree(buf);
 8051                 return(-1);
 8052             }
 8053         c = CUR_CHAR(l);
 8054     }
 8055     }
 8056 
 8057     if ((ctxt-&gt;input == input) &amp;&amp; (ctxt-&gt;input-&gt;cur &gt;= ctxt-&gt;input-&gt;end)) {
 8058         xmlPopInput(ctxt);
 8059     } else if (!IS_CHAR(c)) {
 8060         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 8061                           &quot;xmlLoadEntityContent: invalid char value %d\n&quot;,
 8062                       c);
 8063     xmlBufferFree(buf);
 8064     return(-1);
 8065     }
 8066     entity-&gt;content = buf-&gt;content;
 8067     buf-&gt;content = NULL;
 8068     xmlBufferFree(buf);
 8069 
 8070     return(0);
 8071 }
 8072 
 8073 /**
 8074  * xmlParseStringPEReference:
 8075  * @ctxt:  an XML parser context
 8076  * @str:  a pointer to an index in the string
 8077  *
 8078  * parse PEReference declarations
 8079  *
 8080  * [69] PEReference ::= &#39;%&#39; Name &#39;;&#39;
 8081  *
 8082  * [ WFC: No Recursion ]
 8083  * A parsed entity must not contain a recursive
 8084  * reference to itself, either directly or indirectly.
 8085  *
 8086  * [ WFC: Entity Declared ]
 8087  * In a document without any DTD, a document with only an internal DTD
 8088  * subset which contains no parameter entity references, or a document
 8089  * with &quot;standalone=&#39;yes&#39;&quot;, ...  ... The declaration of a parameter
 8090  * entity must precede any reference to it...
 8091  *
 8092  * [ VC: Entity Declared ]
 8093  * In a document with an external subset or external parameter entities
 8094  * with &quot;standalone=&#39;no&#39;&quot;, ...  ... The declaration of a parameter entity
 8095  * must precede any reference to it...
 8096  *
 8097  * [ WFC: In DTD ]
 8098  * Parameter-entity references may only appear in the DTD.
 8099  * NOTE: misleading but this is handled.
 8100  *
 8101  * Returns the string of the entity content.
 8102  *         str is updated to the current value of the index
 8103  */
 8104 static xmlEntityPtr
 8105 xmlParseStringPEReference(xmlParserCtxtPtr ctxt, const xmlChar **str) {
 8106     const xmlChar *ptr;
 8107     xmlChar cur;
 8108     xmlChar *name;
 8109     xmlEntityPtr entity = NULL;
 8110 
 8111     if ((str == NULL) || (*str == NULL)) return(NULL);
 8112     ptr = *str;
 8113     cur = *ptr;
 8114     if (cur != &#39;%&#39;)
 8115         return(NULL);
 8116     ptr++;
 8117     name = xmlParseStringName(ctxt, &amp;ptr);
 8118     if (name == NULL) {
 8119     xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 8120                &quot;xmlParseStringPEReference: no name\n&quot;);
 8121     *str = ptr;
 8122     return(NULL);
 8123     }
 8124     cur = *ptr;
 8125     if (cur != &#39;;&#39;) {
 8126     xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
 8127     xmlFree(name);
 8128     *str = ptr;
 8129     return(NULL);
 8130     }
 8131     ptr++;
 8132 
 8133     /*
<a name="65" id="anc65"></a><span class="line-modified"> 8134      * Increase the number of entity references parsed</span>
 8135      */
 8136     ctxt-&gt;nbentities++;
 8137 
 8138     /*
 8139      * Request the entity from SAX
 8140      */
 8141     if ((ctxt-&gt;sax != NULL) &amp;&amp;
 8142     (ctxt-&gt;sax-&gt;getParameterEntity != NULL))
 8143     entity = ctxt-&gt;sax-&gt;getParameterEntity(ctxt-&gt;userData, name);
 8144     if (ctxt-&gt;instate == XML_PARSER_EOF) {
 8145     xmlFree(name);
 8146     *str = ptr;
 8147     return(NULL);
 8148     }
 8149     if (entity == NULL) {
 8150     /*
 8151      * [ WFC: Entity Declared ]
 8152      * In a document without any DTD, a document with only an
 8153      * internal DTD subset which contains no parameter entity
 8154      * references, or a document with &quot;standalone=&#39;yes&#39;&quot;, ...
 8155      * ... The declaration of a parameter entity must precede
 8156      * any reference to it...
 8157      */
 8158     if ((ctxt-&gt;standalone == 1) ||
 8159         ((ctxt-&gt;hasExternalSubset == 0) &amp;&amp; (ctxt-&gt;hasPErefs == 0))) {
 8160         xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 8161          &quot;PEReference: %%%s; not found\n&quot;, name);
 8162     } else {
 8163         /*
 8164          * [ VC: Entity Declared ]
 8165          * In a document with an external subset or external
 8166          * parameter entities with &quot;standalone=&#39;no&#39;&quot;, ...
 8167          * ... The declaration of a parameter entity must
 8168          * precede any reference to it...
 8169          */
 8170         xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
 8171               &quot;PEReference: %%%s; not found\n&quot;,
 8172               name, NULL);
 8173         ctxt-&gt;valid = 0;
 8174     }
 8175     xmlParserEntityCheck(ctxt, 0, NULL, 0);
 8176     } else {
 8177     /*
 8178      * Internal checking in case the entity quest barfed
 8179      */
 8180     if ((entity-&gt;etype != XML_INTERNAL_PARAMETER_ENTITY) &amp;&amp;
 8181         (entity-&gt;etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
 8182         xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
 8183               &quot;%%%s; is not a parameter entity\n&quot;,
 8184               name, NULL);
 8185     }
 8186     }
 8187     ctxt-&gt;hasPErefs = 1;
 8188     xmlFree(name);
 8189     *str = ptr;
 8190     return(entity);
 8191 }
 8192 
 8193 /**
 8194  * xmlParseDocTypeDecl:
 8195  * @ctxt:  an XML parser context
 8196  *
 8197  * parse a DOCTYPE declaration
 8198  *
 8199  * [28] doctypedecl ::= &#39;&lt;!DOCTYPE&#39; S Name (S ExternalID)? S?
 8200  *                      (&#39;[&#39; (markupdecl | PEReference | S)* &#39;]&#39; S?)? &#39;&gt;&#39;
 8201  *
 8202  * [ VC: Root Element Type ]
 8203  * The Name in the document type declaration must match the element
 8204  * type of the root element.
 8205  */
 8206 
 8207 void
 8208 xmlParseDocTypeDecl(xmlParserCtxtPtr ctxt) {
 8209     const xmlChar *name = NULL;
 8210     xmlChar *ExternalID = NULL;
 8211     xmlChar *URI = NULL;
 8212 
 8213     /*
 8214      * We know that &#39;&lt;!DOCTYPE&#39; has been detected.
 8215      */
 8216     SKIP(9);
 8217 
 8218     SKIP_BLANKS;
 8219 
 8220     /*
 8221      * Parse the DOCTYPE name.
 8222      */
 8223     name = xmlParseName(ctxt);
 8224     if (name == NULL) {
 8225     xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 8226                &quot;xmlParseDocTypeDecl : no DOCTYPE name !\n&quot;);
 8227     }
 8228     ctxt-&gt;intSubName = name;
 8229 
 8230     SKIP_BLANKS;
 8231 
 8232     /*
 8233      * Check for SystemID and ExternalID
 8234      */
 8235     URI = xmlParseExternalID(ctxt, &amp;ExternalID, 1);
 8236 
 8237     if ((URI != NULL) || (ExternalID != NULL)) {
 8238         ctxt-&gt;hasExternalSubset = 1;
 8239     }
 8240     ctxt-&gt;extSubURI = URI;
 8241     ctxt-&gt;extSubSystem = ExternalID;
 8242 
 8243     SKIP_BLANKS;
 8244 
 8245     /*
 8246      * Create and update the internal subset.
 8247      */
 8248     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;internalSubset != NULL) &amp;&amp;
 8249     (!ctxt-&gt;disableSAX))
 8250     ctxt-&gt;sax-&gt;internalSubset(ctxt-&gt;userData, name, ExternalID, URI);
 8251     if (ctxt-&gt;instate == XML_PARSER_EOF)
 8252     return;
 8253 
 8254     /*
 8255      * Is there any internal subset declarations ?
 8256      * they are handled separately in xmlParseInternalSubset()
 8257      */
 8258     if (RAW == &#39;[&#39;)
 8259     return;
 8260 
 8261     /*
 8262      * We should be at the end of the DOCTYPE declaration.
 8263      */
 8264     if (RAW != &#39;&gt;&#39;) {
 8265     xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);
 8266     }
 8267     NEXT;
 8268 }
 8269 
 8270 /**
 8271  * xmlParseInternalSubset:
 8272  * @ctxt:  an XML parser context
 8273  *
 8274  * parse the internal subset declaration
 8275  *
 8276  * [28 end] (&#39;[&#39; (markupdecl | PEReference | S)* &#39;]&#39; S?)? &#39;&gt;&#39;
 8277  */
 8278 
 8279 static void
 8280 xmlParseInternalSubset(xmlParserCtxtPtr ctxt) {
 8281     /*
 8282      * Is there any DTD definition ?
 8283      */
 8284     if (RAW == &#39;[&#39;) {
 8285         int baseInputNr = ctxt-&gt;inputNr;
 8286         ctxt-&gt;instate = XML_PARSER_DTD;
 8287         NEXT;
 8288     /*
 8289      * Parse the succession of Markup declarations and
 8290      * PEReferences.
 8291      * Subsequence (markupdecl | PEReference | S)*
 8292      */
 8293     while (((RAW != &#39;]&#39;) || (ctxt-&gt;inputNr &gt; baseInputNr)) &amp;&amp;
 8294                (ctxt-&gt;instate != XML_PARSER_EOF)) {
 8295         const xmlChar *check = CUR_PTR;
 8296         unsigned int cons = ctxt-&gt;input-&gt;consumed;
 8297 
 8298         SKIP_BLANKS;
 8299         xmlParseMarkupDecl(ctxt);
 8300         xmlParsePEReference(ctxt);
 8301 
<a name="66" id="anc66"></a><span class="line-added"> 8302             /*</span>
<span class="line-added"> 8303              * Conditional sections are allowed from external entities included</span>
<span class="line-added"> 8304              * by PE References in the internal subset.</span>
<span class="line-added"> 8305              */</span>
<span class="line-added"> 8306             if ((ctxt-&gt;inputNr &gt; 1) &amp;&amp; (ctxt-&gt;input-&gt;filename != NULL) &amp;&amp;</span>
<span class="line-added"> 8307                 (RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {</span>
<span class="line-added"> 8308                 xmlParseConditionalSections(ctxt);</span>
<span class="line-added"> 8309             }</span>
<span class="line-added"> 8310 </span>
 8311         if ((CUR_PTR == check) &amp;&amp; (cons == ctxt-&gt;input-&gt;consumed)) {
 8312         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 8313          &quot;xmlParseInternalSubset: error detected in Markup declaration\n&quot;);
 8314                 if (ctxt-&gt;inputNr &gt; baseInputNr)
 8315                     xmlPopInput(ctxt);
 8316                 else
 8317             break;
 8318         }
 8319     }
 8320     if (RAW == &#39;]&#39;) {
 8321         NEXT;
 8322         SKIP_BLANKS;
 8323     }
 8324     }
 8325 
 8326     /*
 8327      * We should be at the end of the DOCTYPE declaration.
 8328      */
 8329     if (RAW != &#39;&gt;&#39;) {
 8330     xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);
 8331     return;
 8332     }
 8333     NEXT;
 8334 }
 8335 
 8336 #ifdef LIBXML_SAX1_ENABLED
 8337 /**
 8338  * xmlParseAttribute:
 8339  * @ctxt:  an XML parser context
 8340  * @value:  a xmlChar ** used to store the value of the attribute
 8341  *
 8342  * parse an attribute
 8343  *
 8344  * [41] Attribute ::= Name Eq AttValue
 8345  *
 8346  * [ WFC: No External Entity References ]
 8347  * Attribute values cannot contain direct or indirect entity references
 8348  * to external entities.
 8349  *
 8350  * [ WFC: No &lt; in Attribute Values ]
 8351  * The replacement text of any entity referred to directly or indirectly in
 8352  * an attribute value (other than &quot;&amp;lt;&quot;) must not contain a &lt;.
 8353  *
 8354  * [ VC: Attribute Value Type ]
 8355  * The attribute must have been declared; the value must be of the type
 8356  * declared for it.
 8357  *
 8358  * [25] Eq ::= S? &#39;=&#39; S?
 8359  *
 8360  * With namespace:
 8361  *
 8362  * [NS 11] Attribute ::= QName Eq AttValue
 8363  *
 8364  * Also the case QName == xmlns:??? is handled independently as a namespace
 8365  * definition.
 8366  *
 8367  * Returns the attribute name, and the value in *value.
 8368  */
 8369 
 8370 const xmlChar *
 8371 xmlParseAttribute(xmlParserCtxtPtr ctxt, xmlChar **value) {
 8372     const xmlChar *name;
 8373     xmlChar *val;
 8374 
 8375     *value = NULL;
 8376     GROW;
 8377     name = xmlParseName(ctxt);
 8378     if (name == NULL) {
 8379     xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 8380                    &quot;error parsing attribute name\n&quot;);
 8381         return(NULL);
 8382     }
 8383 
 8384     /*
 8385      * read the value
 8386      */
 8387     SKIP_BLANKS;
 8388     if (RAW == &#39;=&#39;) {
 8389         NEXT;
 8390     SKIP_BLANKS;
 8391     val = xmlParseAttValue(ctxt);
 8392     ctxt-&gt;instate = XML_PARSER_CONTENT;
 8393     } else {
 8394     xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,
 8395            &quot;Specification mandates value for attribute %s\n&quot;, name);
 8396     return(NULL);
 8397     }
 8398 
 8399     /*
 8400      * Check that xml:lang conforms to the specification
 8401      * No more registered as an error, just generate a warning now
 8402      * since this was deprecated in XML second edition
 8403      */
 8404     if ((ctxt-&gt;pedantic) &amp;&amp; (xmlStrEqual(name, BAD_CAST &quot;xml:lang&quot;))) {
 8405     if (!xmlCheckLanguageID(val)) {
 8406         xmlWarningMsg(ctxt, XML_WAR_LANG_VALUE,
 8407                   &quot;Malformed value for xml:lang : %s\n&quot;,
 8408               val, NULL);
 8409     }
 8410     }
 8411 
 8412     /*
 8413      * Check that xml:space conforms to the specification
 8414      */
 8415     if (xmlStrEqual(name, BAD_CAST &quot;xml:space&quot;)) {
 8416     if (xmlStrEqual(val, BAD_CAST &quot;default&quot;))
 8417         *(ctxt-&gt;space) = 0;
 8418     else if (xmlStrEqual(val, BAD_CAST &quot;preserve&quot;))
 8419         *(ctxt-&gt;space) = 1;
 8420     else {
 8421         xmlWarningMsg(ctxt, XML_WAR_SPACE_VALUE,
 8422 &quot;Invalid value \&quot;%s\&quot; for xml:space : \&quot;default\&quot; or \&quot;preserve\&quot; expected\n&quot;,
 8423                                  val, NULL);
 8424     }
 8425     }
 8426 
 8427     *value = val;
 8428     return(name);
 8429 }
 8430 
 8431 /**
 8432  * xmlParseStartTag:
 8433  * @ctxt:  an XML parser context
 8434  *
 8435  * parse a start of tag either for rule element or
 8436  * EmptyElement. In both case we don&#39;t parse the tag closing chars.
 8437  *
 8438  * [40] STag ::= &#39;&lt;&#39; Name (S Attribute)* S? &#39;&gt;&#39;
 8439  *
 8440  * [ WFC: Unique Att Spec ]
 8441  * No attribute name may appear more than once in the same start-tag or
 8442  * empty-element tag.
 8443  *
 8444  * [44] EmptyElemTag ::= &#39;&lt;&#39; Name (S Attribute)* S? &#39;/&gt;&#39;
 8445  *
 8446  * [ WFC: Unique Att Spec ]
 8447  * No attribute name may appear more than once in the same start-tag or
 8448  * empty-element tag.
 8449  *
 8450  * With namespace:
 8451  *
 8452  * [NS 8] STag ::= &#39;&lt;&#39; QName (S Attribute)* S? &#39;&gt;&#39;
 8453  *
 8454  * [NS 10] EmptyElement ::= &#39;&lt;&#39; QName (S Attribute)* S? &#39;/&gt;&#39;
 8455  *
 8456  * Returns the element name parsed
 8457  */
 8458 
 8459 const xmlChar *
 8460 xmlParseStartTag(xmlParserCtxtPtr ctxt) {
 8461     const xmlChar *name;
 8462     const xmlChar *attname;
 8463     xmlChar *attvalue;
 8464     const xmlChar **atts = ctxt-&gt;atts;
 8465     int nbatts = 0;
 8466     int maxatts = ctxt-&gt;maxatts;
 8467     int i;
 8468 
 8469     if (RAW != &#39;&lt;&#39;) return(NULL);
 8470     NEXT1;
 8471 
 8472     name = xmlParseName(ctxt);
 8473     if (name == NULL) {
 8474     xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 8475          &quot;xmlParseStartTag: invalid element name\n&quot;);
 8476         return(NULL);
 8477     }
 8478 
 8479     /*
 8480      * Now parse the attributes, it ends up with the ending
 8481      *
 8482      * (S Attribute)* S?
 8483      */
 8484     SKIP_BLANKS;
 8485     GROW;
 8486 
 8487     while (((RAW != &#39;&gt;&#39;) &amp;&amp;
 8488        ((RAW != &#39;/&#39;) || (NXT(1) != &#39;&gt;&#39;)) &amp;&amp;
 8489        (IS_BYTE_CHAR(RAW))) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF)) {
 8490     const xmlChar *q = CUR_PTR;
 8491     unsigned int cons = ctxt-&gt;input-&gt;consumed;
 8492 
 8493     attname = xmlParseAttribute(ctxt, &amp;attvalue);
 8494         if ((attname != NULL) &amp;&amp; (attvalue != NULL)) {
 8495         /*
 8496          * [ WFC: Unique Att Spec ]
 8497          * No attribute name may appear more than once in the same
 8498          * start-tag or empty-element tag.
 8499          */
 8500         for (i = 0; i &lt; nbatts;i += 2) {
 8501             if (xmlStrEqual(atts[i], attname)) {
 8502             xmlErrAttributeDup(ctxt, NULL, attname);
 8503             xmlFree(attvalue);
 8504             goto failed;
 8505         }
 8506         }
 8507         /*
 8508          * Add the pair to atts
 8509          */
 8510         if (atts == NULL) {
 8511             maxatts = 22; /* allow for 10 attrs by default */
 8512             atts = (const xmlChar **)
 8513                xmlMalloc(maxatts * sizeof(xmlChar *));
 8514         if (atts == NULL) {
 8515             xmlErrMemory(ctxt, NULL);
 8516             if (attvalue != NULL)
 8517             xmlFree(attvalue);
 8518             goto failed;
 8519         }
 8520         ctxt-&gt;atts = atts;
 8521         ctxt-&gt;maxatts = maxatts;
 8522         } else if (nbatts + 4 &gt; maxatts) {
 8523             const xmlChar **n;
 8524 
 8525             maxatts *= 2;
 8526             n = (const xmlChar **) xmlRealloc((void *) atts,
 8527                          maxatts * sizeof(const xmlChar *));
 8528         if (n == NULL) {
 8529             xmlErrMemory(ctxt, NULL);
 8530             if (attvalue != NULL)
 8531             xmlFree(attvalue);
 8532             goto failed;
 8533         }
 8534         atts = n;
 8535         ctxt-&gt;atts = atts;
 8536         ctxt-&gt;maxatts = maxatts;
 8537         }
 8538         atts[nbatts++] = attname;
 8539         atts[nbatts++] = attvalue;
 8540         atts[nbatts] = NULL;
 8541         atts[nbatts + 1] = NULL;
 8542     } else {
 8543         if (attvalue != NULL)
 8544         xmlFree(attvalue);
 8545     }
 8546 
 8547 failed:
 8548 
 8549     GROW
 8550     if ((RAW == &#39;&gt;&#39;) || (((RAW == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;))))
 8551         break;
 8552     if (SKIP_BLANKS == 0) {
 8553         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 8554                &quot;attributes construct error\n&quot;);
 8555     }
 8556         if ((cons == ctxt-&gt;input-&gt;consumed) &amp;&amp; (q == CUR_PTR) &amp;&amp;
 8557             (attname == NULL) &amp;&amp; (attvalue == NULL)) {
 8558         xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
 8559                &quot;xmlParseStartTag: problem parsing attributes\n&quot;);
 8560         break;
 8561     }
 8562     SHRINK;
 8563         GROW;
 8564     }
 8565 
 8566     /*
 8567      * SAX: Start of Element !
 8568      */
 8569     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;startElement != NULL) &amp;&amp;
 8570     (!ctxt-&gt;disableSAX)) {
 8571     if (nbatts &gt; 0)
 8572         ctxt-&gt;sax-&gt;startElement(ctxt-&gt;userData, name, atts);
 8573     else
 8574         ctxt-&gt;sax-&gt;startElement(ctxt-&gt;userData, name, NULL);
 8575     }
 8576 
 8577     if (atts != NULL) {
 8578         /* Free only the content strings */
 8579         for (i = 1;i &lt; nbatts;i+=2)
 8580         if (atts[i] != NULL)
 8581            xmlFree((xmlChar *) atts[i]);
 8582     }
 8583     return(name);
 8584 }
 8585 
 8586 /**
 8587  * xmlParseEndTag1:
 8588  * @ctxt:  an XML parser context
 8589  * @line:  line of the start tag
 8590  * @nsNr:  number of namespaces on the start tag
 8591  *
 8592  * parse an end of tag
 8593  *
 8594  * [42] ETag ::= &#39;&lt;/&#39; Name S? &#39;&gt;&#39;
 8595  *
 8596  * With namespace
 8597  *
 8598  * [NS 9] ETag ::= &#39;&lt;/&#39; QName S? &#39;&gt;&#39;
 8599  */
 8600 
 8601 static void
 8602 xmlParseEndTag1(xmlParserCtxtPtr ctxt, int line) {
 8603     const xmlChar *name;
 8604 
 8605     GROW;
 8606     if ((RAW != &#39;&lt;&#39;) || (NXT(1) != &#39;/&#39;)) {
 8607     xmlFatalErrMsg(ctxt, XML_ERR_LTSLASH_REQUIRED,
 8608                &quot;xmlParseEndTag: &#39;&lt;/&#39; not found\n&quot;);
 8609     return;
 8610     }
 8611     SKIP(2);
 8612 
 8613     name = xmlParseNameAndCompare(ctxt,ctxt-&gt;name);
 8614 
 8615     /*
 8616      * We should definitely be at the ending &quot;S? &#39;&gt;&#39;&quot; part
 8617      */
 8618     GROW;
 8619     SKIP_BLANKS;
 8620     if ((!IS_BYTE_CHAR(RAW)) || (RAW != &#39;&gt;&#39;)) {
 8621     xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
 8622     } else
 8623     NEXT1;
 8624 
 8625     /*
 8626      * [ WFC: Element Type Match ]
 8627      * The Name in an element&#39;s end-tag must match the element type in the
 8628      * start-tag.
 8629      *
 8630      */
 8631     if (name != (xmlChar*)1) {
 8632         if (name == NULL) name = BAD_CAST &quot;unparseable&quot;;
 8633         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
 8634              &quot;Opening and ending tag mismatch: %s line %d and %s\n&quot;,
 8635                         ctxt-&gt;name, line, name);
 8636     }
 8637 
 8638     /*
 8639      * SAX: End of Tag
 8640      */
 8641     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElement != NULL) &amp;&amp;
 8642     (!ctxt-&gt;disableSAX))
 8643         ctxt-&gt;sax-&gt;endElement(ctxt-&gt;userData, ctxt-&gt;name);
 8644 
 8645     namePop(ctxt);
 8646     spacePop(ctxt);
 8647     return;
 8648 }
 8649 
 8650 /**
 8651  * xmlParseEndTag:
 8652  * @ctxt:  an XML parser context
 8653  *
 8654  * parse an end of tag
 8655  *
 8656  * [42] ETag ::= &#39;&lt;/&#39; Name S? &#39;&gt;&#39;
 8657  *
 8658  * With namespace
 8659  *
 8660  * [NS 9] ETag ::= &#39;&lt;/&#39; QName S? &#39;&gt;&#39;
 8661  */
 8662 
 8663 void
 8664 xmlParseEndTag(xmlParserCtxtPtr ctxt) {
 8665     xmlParseEndTag1(ctxt, 0);
 8666 }
 8667 #endif /* LIBXML_SAX1_ENABLED */
 8668 
 8669 /************************************************************************
 8670  *                                  *
 8671  *            SAX 2 specific operations             *
 8672  *                                  *
 8673  ************************************************************************/
 8674 
 8675 /*
 8676  * xmlGetNamespace:
 8677  * @ctxt:  an XML parser context
 8678  * @prefix:  the prefix to lookup
 8679  *
 8680  * Lookup the namespace name for the @prefix (which ca be NULL)
 8681  * The prefix must come from the @ctxt-&gt;dict dictionary
 8682  *
 8683  * Returns the namespace name or NULL if not bound
 8684  */
 8685 static const xmlChar *
 8686 xmlGetNamespace(xmlParserCtxtPtr ctxt, const xmlChar *prefix) {
 8687     int i;
 8688 
 8689     if (prefix == ctxt-&gt;str_xml) return(ctxt-&gt;str_xml_ns);
 8690     for (i = ctxt-&gt;nsNr - 2;i &gt;= 0;i-=2)
 8691         if (ctxt-&gt;nsTab[i] == prefix) {
 8692         if ((prefix == NULL) &amp;&amp; (*ctxt-&gt;nsTab[i + 1] == 0))
 8693             return(NULL);
 8694         return(ctxt-&gt;nsTab[i + 1]);
 8695     }
 8696     return(NULL);
 8697 }
 8698 
 8699 /**
 8700  * xmlParseQName:
 8701  * @ctxt:  an XML parser context
 8702  * @prefix:  pointer to store the prefix part
 8703  *
 8704  * parse an XML Namespace QName
 8705  *
 8706  * [6]  QName  ::= (Prefix &#39;:&#39;)? LocalPart
 8707  * [7]  Prefix  ::= NCName
 8708  * [8]  LocalPart  ::= NCName
 8709  *
 8710  * Returns the Name parsed or NULL
 8711  */
 8712 
 8713 static const xmlChar *
 8714 xmlParseQName(xmlParserCtxtPtr ctxt, const xmlChar **prefix) {
 8715     const xmlChar *l, *p;
 8716 
 8717     GROW;
 8718 
 8719     l = xmlParseNCName(ctxt);
 8720     if (l == NULL) {
 8721         if (CUR == &#39;:&#39;) {
 8722         l = xmlParseName(ctxt);
 8723         if (l != NULL) {
 8724             xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8725                  &quot;Failed to parse QName &#39;%s&#39;\n&quot;, l, NULL, NULL);
 8726         *prefix = NULL;
 8727         return(l);
 8728         }
 8729     }
 8730         return(NULL);
 8731     }
 8732     if (CUR == &#39;:&#39;) {
 8733         NEXT;
 8734     p = l;
 8735     l = xmlParseNCName(ctxt);
 8736     if (l == NULL) {
 8737         xmlChar *tmp;
 8738 
<a name="67" id="anc67"></a><span class="line-added"> 8739             if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-added"> 8740                 return(NULL);</span>
 8741             xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8742                  &quot;Failed to parse QName &#39;%s:&#39;\n&quot;, p, NULL, NULL);
 8743         l = xmlParseNmtoken(ctxt);
<a name="68" id="anc68"></a><span class="line-modified"> 8744         if (l == NULL) {</span>
<span class="line-added"> 8745                 if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-added"> 8746                     return(NULL);</span>
 8747         tmp = xmlBuildQName(BAD_CAST &quot;&quot;, p, NULL, 0);
<a name="69" id="anc69"></a><span class="line-modified"> 8748             } else {</span>
 8749         tmp = xmlBuildQName(l, p, NULL, 0);
 8750         xmlFree((char *)l);
 8751         }
 8752         p = xmlDictLookup(ctxt-&gt;dict, tmp, -1);
 8753         if (tmp != NULL) xmlFree(tmp);
 8754         *prefix = NULL;
 8755         return(p);
 8756     }
 8757     if (CUR == &#39;:&#39;) {
 8758         xmlChar *tmp;
 8759 
 8760             xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8761                  &quot;Failed to parse QName &#39;%s:%s:&#39;\n&quot;, p, l, NULL);
 8762         NEXT;
 8763         tmp = (xmlChar *) xmlParseName(ctxt);
 8764         if (tmp != NULL) {
 8765             tmp = xmlBuildQName(tmp, l, NULL, 0);
 8766         l = xmlDictLookup(ctxt-&gt;dict, tmp, -1);
 8767         if (tmp != NULL) xmlFree(tmp);
 8768         *prefix = p;
 8769         return(l);
 8770         }
<a name="70" id="anc70"></a><span class="line-added"> 8771             if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-added"> 8772                 return(NULL);</span>
 8773         tmp = xmlBuildQName(BAD_CAST &quot;&quot;, l, NULL, 0);
 8774         l = xmlDictLookup(ctxt-&gt;dict, tmp, -1);
 8775         if (tmp != NULL) xmlFree(tmp);
 8776         *prefix = p;
 8777         return(l);
 8778     }
 8779     *prefix = p;
 8780     } else
 8781         *prefix = NULL;
 8782     return(l);
 8783 }
 8784 
 8785 /**
 8786  * xmlParseQNameAndCompare:
 8787  * @ctxt:  an XML parser context
 8788  * @name:  the localname
 8789  * @prefix:  the prefix, if any.
 8790  *
 8791  * parse an XML name and compares for match
 8792  * (specialized for endtag parsing)
 8793  *
 8794  * Returns NULL for an illegal name, (xmlChar*) 1 for success
 8795  * and the name for mismatch
 8796  */
 8797 
 8798 static const xmlChar *
 8799 xmlParseQNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *name,
 8800                         xmlChar const *prefix) {
 8801     const xmlChar *cmp;
 8802     const xmlChar *in;
 8803     const xmlChar *ret;
 8804     const xmlChar *prefix2;
 8805 
 8806     if (prefix == NULL) return(xmlParseNameAndCompare(ctxt, name));
 8807 
 8808     GROW;
 8809     in = ctxt-&gt;input-&gt;cur;
 8810 
 8811     cmp = prefix;
 8812     while (*in != 0 &amp;&amp; *in == *cmp) {
 8813     ++in;
 8814     ++cmp;
 8815     }
 8816     if ((*cmp == 0) &amp;&amp; (*in == &#39;:&#39;)) {
 8817         in++;
 8818     cmp = name;
 8819     while (*in != 0 &amp;&amp; *in == *cmp) {
 8820         ++in;
 8821         ++cmp;
 8822     }
 8823     if (*cmp == 0 &amp;&amp; (*in == &#39;&gt;&#39; || IS_BLANK_CH (*in))) {
 8824         /* success */
 8825         ctxt-&gt;input-&gt;cur = in;
 8826         return((const xmlChar*) 1);
 8827     }
 8828     }
 8829     /*
 8830      * all strings coms from the dictionary, equality can be done directly
 8831      */
 8832     ret = xmlParseQName (ctxt, &amp;prefix2);
 8833     if ((ret == name) &amp;&amp; (prefix == prefix2))
 8834     return((const xmlChar*) 1);
 8835     return ret;
 8836 }
 8837 
 8838 /**
 8839  * xmlParseAttValueInternal:
 8840  * @ctxt:  an XML parser context
 8841  * @len:  attribute len result
 8842  * @alloc:  whether the attribute was reallocated as a new string
 8843  * @normalize:  if 1 then further non-CDATA normalization must be done
 8844  *
 8845  * parse a value for an attribute.
 8846  * NOTE: if no normalization is needed, the routine will return pointers
 8847  *       directly from the data buffer.
 8848  *
 8849  * 3.3.3 Attribute-Value Normalization:
 8850  * Before the value of an attribute is passed to the application or
 8851  * checked for validity, the XML processor must normalize it as follows:
 8852  * - a character reference is processed by appending the referenced
 8853  *   character to the attribute value
 8854  * - an entity reference is processed by recursively processing the
 8855  *   replacement text of the entity
 8856  * - a whitespace character (#x20, #xD, #xA, #x9) is processed by
 8857  *   appending #x20 to the normalized value, except that only a single
 8858  *   #x20 is appended for a &quot;#xD#xA&quot; sequence that is part of an external
 8859  *   parsed entity or the literal entity value of an internal parsed entity
 8860  * - other characters are processed by appending them to the normalized value
 8861  * If the declared value is not CDATA, then the XML processor must further
 8862  * process the normalized attribute value by discarding any leading and
 8863  * trailing space (#x20) characters, and by replacing sequences of space
 8864  * (#x20) characters by a single space (#x20) character.
 8865  * All attributes for which no declaration has been read should be treated
 8866  * by a non-validating parser as if declared CDATA.
 8867  *
 8868  * Returns the AttValue parsed or NULL. The value has to be freed by the
 8869  *     caller if it was copied, this can be detected by val[*len] == 0.
 8870  */
 8871 
<a name="71" id="anc71"></a><span class="line-added"> 8872 #define GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end) \</span>
<span class="line-added"> 8873     const xmlChar *oldbase = ctxt-&gt;input-&gt;base;\</span>
<span class="line-added"> 8874     GROW;\</span>
<span class="line-added"> 8875     if (ctxt-&gt;instate == XML_PARSER_EOF)\</span>
<span class="line-added"> 8876         return(NULL);\</span>
<span class="line-added"> 8877     if (oldbase != ctxt-&gt;input-&gt;base) {\</span>
<span class="line-added"> 8878         ptrdiff_t delta = ctxt-&gt;input-&gt;base - oldbase;\</span>
<span class="line-added"> 8879         start = start + delta;\</span>
<span class="line-added"> 8880         in = in + delta;\</span>
<span class="line-added"> 8881     }\</span>
<span class="line-added"> 8882     end = ctxt-&gt;input-&gt;end;</span>
<span class="line-added"> 8883 </span>
 8884 static xmlChar *
 8885 xmlParseAttValueInternal(xmlParserCtxtPtr ctxt, int *len, int *alloc,
 8886                          int normalize)
 8887 {
 8888     xmlChar limit = 0;
 8889     const xmlChar *in = NULL, *start, *end, *last;
 8890     xmlChar *ret = NULL;
 8891     int line, col;
 8892 
 8893     GROW;
 8894     in = (xmlChar *) CUR_PTR;
 8895     line = ctxt-&gt;input-&gt;line;
 8896     col = ctxt-&gt;input-&gt;col;
 8897     if (*in != &#39;&quot;&#39; &amp;&amp; *in != &#39;\&#39;&#39;) {
 8898         xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
 8899         return (NULL);
 8900     }
 8901     ctxt-&gt;instate = XML_PARSER_ATTRIBUTE_VALUE;
 8902 
 8903     /*
 8904      * try to handle in this routine the most common case where no
 8905      * allocation of a new string is required and where content is
 8906      * pure ASCII.
 8907      */
 8908     limit = *in++;
 8909     col++;
 8910     end = ctxt-&gt;input-&gt;end;
 8911     start = in;
 8912     if (in &gt;= end) {
<a name="72" id="anc72"></a><span class="line-modified"> 8913         GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)</span>







 8914     }
 8915     if (normalize) {
 8916         /*
 8917      * Skip any leading spaces
 8918      */
 8919     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp;
 8920            ((*in == 0x20) || (*in == 0x9) ||
 8921             (*in == 0xA) || (*in == 0xD))) {
 8922         if (*in == 0xA) {
 8923             line++; col = 1;
 8924         } else {
 8925             col++;
 8926         }
 8927         in++;
 8928         start = in;
 8929         if (in &gt;= end) {
<a name="73" id="anc73"></a><span class="line-modified"> 8930                 GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)</span>









 8931                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8932                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8933                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8934                                    &quot;AttValue length too long\n&quot;);
 8935                     return(NULL);
 8936                 }
 8937         }
 8938     }
 8939     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp; (*in &gt;= 0x20) &amp;&amp;
 8940            (*in &lt;= 0x7f) &amp;&amp; (*in != &#39;&amp;&#39;) &amp;&amp; (*in != &#39;&lt;&#39;)) {
 8941         col++;
 8942         if ((*in++ == 0x20) &amp;&amp; (*in == 0x20)) break;
 8943         if (in &gt;= end) {
<a name="74" id="anc74"></a><span class="line-modified"> 8944                 GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)</span>









 8945                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8946                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8947                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8948                                    &quot;AttValue length too long\n&quot;);
 8949                     return(NULL);
 8950                 }
 8951         }
 8952     }
 8953     last = in;
 8954     /*
 8955      * skip the trailing blanks
 8956      */
 8957     while ((last[-1] == 0x20) &amp;&amp; (last &gt; start)) last--;
 8958     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp;
 8959            ((*in == 0x20) || (*in == 0x9) ||
 8960             (*in == 0xA) || (*in == 0xD))) {
 8961         if (*in == 0xA) {
 8962             line++, col = 1;
 8963         } else {
 8964             col++;
 8965         }
 8966         in++;
 8967         if (in &gt;= end) {
 8968         const xmlChar *oldbase = ctxt-&gt;input-&gt;base;
 8969         GROW;
 8970                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 8971                     return(NULL);
 8972         if (oldbase != ctxt-&gt;input-&gt;base) {
<a name="75" id="anc75"></a><span class="line-modified"> 8973             ptrdiff_t delta = ctxt-&gt;input-&gt;base - oldbase;</span>
 8974             start = start + delta;
 8975             in = in + delta;
 8976             last = last + delta;
 8977         }
 8978         end = ctxt-&gt;input-&gt;end;
 8979                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8980                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8981                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8982                                    &quot;AttValue length too long\n&quot;);
 8983                     return(NULL);
 8984                 }
 8985         }
 8986     }
 8987         if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8988             ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8989             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8990                            &quot;AttValue length too long\n&quot;);
 8991             return(NULL);
 8992         }
 8993     if (*in != limit) goto need_complex;
 8994     } else {
 8995     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp; (*in &gt;= 0x20) &amp;&amp;
 8996            (*in &lt;= 0x7f) &amp;&amp; (*in != &#39;&amp;&#39;) &amp;&amp; (*in != &#39;&lt;&#39;)) {
 8997         in++;
 8998         col++;
 8999         if (in &gt;= end) {
<a name="76" id="anc76"></a><span class="line-modified"> 9000                 GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)</span>









 9001                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 9002                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 9003                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9004                                    &quot;AttValue length too long\n&quot;);
 9005                     return(NULL);
 9006                 }
 9007         }
 9008     }
 9009     last = in;
 9010         if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 9011             ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 9012             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9013                            &quot;AttValue length too long\n&quot;);
 9014             return(NULL);
 9015         }
 9016     if (*in != limit) goto need_complex;
 9017     }
 9018     in++;
 9019     col++;
 9020     if (len != NULL) {
 9021         *len = last - start;
 9022         ret = (xmlChar *) start;
 9023     } else {
 9024         if (alloc) *alloc = 1;
 9025         ret = xmlStrndup(start, last - start);
 9026     }
 9027     CUR_PTR = in;
 9028     ctxt-&gt;input-&gt;line = line;
 9029     ctxt-&gt;input-&gt;col = col;
 9030     if (alloc) *alloc = 0;
 9031     return ret;
 9032 need_complex:
 9033     if (alloc) *alloc = 1;
 9034     return xmlParseAttValueComplex(ctxt, len, normalize);
 9035 }
 9036 
 9037 /**
 9038  * xmlParseAttribute2:
 9039  * @ctxt:  an XML parser context
 9040  * @pref:  the element prefix
 9041  * @elem:  the element name
 9042  * @prefix:  a xmlChar ** used to store the value of the attribute prefix
 9043  * @value:  a xmlChar ** used to store the value of the attribute
 9044  * @len:  an int * to save the length of the attribute
 9045  * @alloc:  an int * to indicate if the attribute was allocated
 9046  *
 9047  * parse an attribute in the new SAX2 framework.
 9048  *
 9049  * Returns the attribute name, and the value in *value, .
 9050  */
 9051 
 9052 static const xmlChar *
 9053 xmlParseAttribute2(xmlParserCtxtPtr ctxt,
 9054                    const xmlChar * pref, const xmlChar * elem,
 9055                    const xmlChar ** prefix, xmlChar ** value,
 9056                    int *len, int *alloc)
 9057 {
 9058     const xmlChar *name;
 9059     xmlChar *val, *internal_val = NULL;
 9060     int normalize = 0;
 9061 
 9062     *value = NULL;
 9063     GROW;
 9064     name = xmlParseQName(ctxt, prefix);
 9065     if (name == NULL) {
 9066         xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 9067                        &quot;error parsing attribute name\n&quot;);
 9068         return (NULL);
 9069     }
 9070 
 9071     /*
 9072      * get the type if needed
 9073      */
 9074     if (ctxt-&gt;attsSpecial != NULL) {
 9075         int type;
 9076 
 9077         type = (int) (ptrdiff_t) xmlHashQLookup2(ctxt-&gt;attsSpecial,
 9078                                                  pref, elem, *prefix, name);
 9079         if (type != 0)
 9080             normalize = 1;
 9081     }
 9082 
 9083     /*
 9084      * read the value
 9085      */
 9086     SKIP_BLANKS;
 9087     if (RAW == &#39;=&#39;) {
 9088         NEXT;
 9089         SKIP_BLANKS;
 9090         val = xmlParseAttValueInternal(ctxt, len, alloc, normalize);
 9091     if (normalize) {
 9092         /*
 9093          * Sometimes a second normalisation pass for spaces is needed
<a name="77" id="anc77"></a><span class="line-modified"> 9094          * but that only happens if charrefs or entities references</span>
 9095          * have been used in the attribute value, i.e. the attribute
 9096          * value have been extracted in an allocated string already.
 9097          */
 9098         if (*alloc) {
 9099             const xmlChar *val2;
 9100 
 9101             val2 = xmlAttrNormalizeSpace2(ctxt, val, len);
 9102         if ((val2 != NULL) &amp;&amp; (val2 != val)) {
 9103             xmlFree(val);
 9104             val = (xmlChar *) val2;
 9105         }
 9106         }
 9107     }
 9108         ctxt-&gt;instate = XML_PARSER_CONTENT;
 9109     } else {
 9110         xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,
 9111                           &quot;Specification mandates value for attribute %s\n&quot;,
 9112                           name);
 9113         return (NULL);
 9114     }
 9115 
 9116     if (*prefix == ctxt-&gt;str_xml) {
 9117         /*
 9118          * Check that xml:lang conforms to the specification
 9119          * No more registered as an error, just generate a warning now
 9120          * since this was deprecated in XML second edition
 9121          */
 9122         if ((ctxt-&gt;pedantic) &amp;&amp; (xmlStrEqual(name, BAD_CAST &quot;lang&quot;))) {
 9123             internal_val = xmlStrndup(val, *len);
 9124             if (!xmlCheckLanguageID(internal_val)) {
 9125                 xmlWarningMsg(ctxt, XML_WAR_LANG_VALUE,
 9126                               &quot;Malformed value for xml:lang : %s\n&quot;,
 9127                               internal_val, NULL);
 9128             }
 9129         }
 9130 
 9131         /*
 9132          * Check that xml:space conforms to the specification
 9133          */
 9134         if (xmlStrEqual(name, BAD_CAST &quot;space&quot;)) {
 9135             internal_val = xmlStrndup(val, *len);
 9136             if (xmlStrEqual(internal_val, BAD_CAST &quot;default&quot;))
 9137                 *(ctxt-&gt;space) = 0;
 9138             else if (xmlStrEqual(internal_val, BAD_CAST &quot;preserve&quot;))
 9139                 *(ctxt-&gt;space) = 1;
 9140             else {
 9141                 xmlWarningMsg(ctxt, XML_WAR_SPACE_VALUE,
 9142                               &quot;Invalid value \&quot;%s\&quot; for xml:space : \&quot;default\&quot; or \&quot;preserve\&quot; expected\n&quot;,
 9143                               internal_val, NULL);
 9144             }
 9145         }
 9146         if (internal_val) {
 9147             xmlFree(internal_val);
 9148         }
 9149     }
 9150 
 9151     *value = val;
 9152     return (name);
 9153 }
 9154 /**
 9155  * xmlParseStartTag2:
 9156  * @ctxt:  an XML parser context
 9157  *
 9158  * parse a start of tag either for rule element or
 9159  * EmptyElement. In both case we don&#39;t parse the tag closing chars.
 9160  * This routine is called when running SAX2 parsing
 9161  *
 9162  * [40] STag ::= &#39;&lt;&#39; Name (S Attribute)* S? &#39;&gt;&#39;
 9163  *
 9164  * [ WFC: Unique Att Spec ]
 9165  * No attribute name may appear more than once in the same start-tag or
 9166  * empty-element tag.
 9167  *
 9168  * [44] EmptyElemTag ::= &#39;&lt;&#39; Name (S Attribute)* S? &#39;/&gt;&#39;
 9169  *
 9170  * [ WFC: Unique Att Spec ]
 9171  * No attribute name may appear more than once in the same start-tag or
 9172  * empty-element tag.
 9173  *
 9174  * With namespace:
 9175  *
 9176  * [NS 8] STag ::= &#39;&lt;&#39; QName (S Attribute)* S? &#39;&gt;&#39;
 9177  *
 9178  * [NS 10] EmptyElement ::= &#39;&lt;&#39; QName (S Attribute)* S? &#39;/&gt;&#39;
 9179  *
 9180  * Returns the element name parsed
 9181  */
 9182 
 9183 static const xmlChar *
 9184 xmlParseStartTag2(xmlParserCtxtPtr ctxt, const xmlChar **pref,
 9185                   const xmlChar **URI, int *tlen) {
 9186     const xmlChar *localname;
 9187     const xmlChar *prefix;
 9188     const xmlChar *attname;
 9189     const xmlChar *aprefix;
 9190     const xmlChar *nsname;
 9191     xmlChar *attvalue;
 9192     const xmlChar **atts = ctxt-&gt;atts;
 9193     int maxatts = ctxt-&gt;maxatts;
 9194     int nratts, nbatts, nbdef, inputid;
 9195     int i, j, nbNs, attval;
 9196     unsigned long cur;
 9197     int nsNr = ctxt-&gt;nsNr;
 9198 
 9199     if (RAW != &#39;&lt;&#39;) return(NULL);
 9200     NEXT1;
 9201 
 9202     /*
 9203      * NOTE: it is crucial with the SAX2 API to never call SHRINK beyond that
 9204      *       point since the attribute values may be stored as pointers to
 9205      *       the buffer and calling SHRINK would destroy them !
 9206      *       The Shrinking is only possible once the full set of attribute
 9207      *       callbacks have been done.
 9208      */
 9209     SHRINK;
 9210     cur = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
 9211     inputid = ctxt-&gt;input-&gt;id;
 9212     nbatts = 0;
 9213     nratts = 0;
 9214     nbdef = 0;
 9215     nbNs = 0;
 9216     attval = 0;
 9217     /* Forget any namespaces added during an earlier parse of this element. */
 9218     ctxt-&gt;nsNr = nsNr;
 9219 
 9220     localname = xmlParseQName(ctxt, &amp;prefix);
 9221     if (localname == NULL) {
 9222     xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 9223                &quot;StartTag: invalid element name\n&quot;);
 9224         return(NULL);
 9225     }
 9226     *tlen = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base - cur;
 9227 
 9228     /*
 9229      * Now parse the attributes, it ends up with the ending
 9230      *
 9231      * (S Attribute)* S?
 9232      */
 9233     SKIP_BLANKS;
 9234     GROW;
 9235 
 9236     while (((RAW != &#39;&gt;&#39;) &amp;&amp;
 9237        ((RAW != &#39;/&#39;) || (NXT(1) != &#39;&gt;&#39;)) &amp;&amp;
 9238        (IS_BYTE_CHAR(RAW))) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF)) {
 9239     const xmlChar *q = CUR_PTR;
 9240     unsigned int cons = ctxt-&gt;input-&gt;consumed;
 9241     int len = -1, alloc = 0;
 9242 
 9243     attname = xmlParseAttribute2(ctxt, prefix, localname,
 9244                                  &amp;aprefix, &amp;attvalue, &amp;len, &amp;alloc);
 9245         if ((attname == NULL) || (attvalue == NULL))
 9246             goto next_attr;
 9247     if (len &lt; 0) len = xmlStrlen(attvalue);
 9248 
 9249         if ((attname == ctxt-&gt;str_xmlns) &amp;&amp; (aprefix == NULL)) {
 9250             const xmlChar *URL = xmlDictLookup(ctxt-&gt;dict, attvalue, len);
 9251             xmlURIPtr uri;
 9252 
 9253             if (URL == NULL) {
 9254                 xmlErrMemory(ctxt, &quot;dictionary allocation failure&quot;);
 9255                 if ((attvalue != NULL) &amp;&amp; (alloc != 0))
 9256                     xmlFree(attvalue);
<a name="78" id="anc78"></a><span class="line-modified"> 9257                 localname = NULL;</span>
<span class="line-added"> 9258                 goto done;</span>
 9259             }
 9260             if (*URL != 0) {
 9261                 uri = xmlParseURI((const char *) URL);
 9262                 if (uri == NULL) {
 9263                     xmlNsErr(ctxt, XML_WAR_NS_URI,
 9264                              &quot;xmlns: &#39;%s&#39; is not a valid URI\n&quot;,
 9265                                        URL, NULL, NULL);
 9266                 } else {
 9267                     if (uri-&gt;scheme == NULL) {
 9268                         xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
 9269                                   &quot;xmlns: URI %s is not absolute\n&quot;,
 9270                                   URL, NULL, NULL);
 9271                     }
 9272                     xmlFreeURI(uri);
 9273                 }
 9274                 if (URL == ctxt-&gt;str_xml_ns) {
 9275                     if (attname != ctxt-&gt;str_xml) {
 9276                         xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9277                      &quot;xml namespace URI cannot be the default namespace\n&quot;,
 9278                                  NULL, NULL, NULL);
 9279                     }
 9280                     goto next_attr;
 9281                 }
 9282                 if ((len == 29) &amp;&amp;
 9283                     (xmlStrEqual(URL,
 9284                              BAD_CAST &quot;http://www.w3.org/2000/xmlns/&quot;))) {
 9285                     xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9286                          &quot;reuse of the xmlns namespace name is forbidden\n&quot;,
 9287                              NULL, NULL, NULL);
 9288                     goto next_attr;
 9289                 }
 9290             }
 9291             /*
 9292              * check that it&#39;s not a defined namespace
 9293              */
 9294             for (j = 1;j &lt;= nbNs;j++)
 9295                 if (ctxt-&gt;nsTab[ctxt-&gt;nsNr - 2 * j] == NULL)
 9296                     break;
 9297             if (j &lt;= nbNs)
 9298                 xmlErrAttributeDup(ctxt, NULL, attname);
 9299             else
 9300                 if (nsPush(ctxt, NULL, URL) &gt; 0) nbNs++;
 9301 
 9302         } else if (aprefix == ctxt-&gt;str_xmlns) {
 9303             const xmlChar *URL = xmlDictLookup(ctxt-&gt;dict, attvalue, len);
 9304             xmlURIPtr uri;
 9305 
 9306             if (attname == ctxt-&gt;str_xml) {
 9307                 if (URL != ctxt-&gt;str_xml_ns) {
 9308                     xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9309                              &quot;xml namespace prefix mapped to wrong URI\n&quot;,
 9310                              NULL, NULL, NULL);
 9311                 }
 9312                 /*
 9313                  * Do not keep a namespace definition node
 9314                  */
 9315                 goto next_attr;
 9316             }
 9317             if (URL == ctxt-&gt;str_xml_ns) {
 9318                 if (attname != ctxt-&gt;str_xml) {
 9319                     xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9320                              &quot;xml namespace URI mapped to wrong prefix\n&quot;,
 9321                              NULL, NULL, NULL);
 9322                 }
 9323                 goto next_attr;
 9324             }
 9325             if (attname == ctxt-&gt;str_xmlns) {
 9326                 xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9327                          &quot;redefinition of the xmlns prefix is forbidden\n&quot;,
 9328                          NULL, NULL, NULL);
 9329                 goto next_attr;
 9330             }
 9331             if ((len == 29) &amp;&amp;
 9332                 (xmlStrEqual(URL,
 9333                              BAD_CAST &quot;http://www.w3.org/2000/xmlns/&quot;))) {
 9334                 xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9335                          &quot;reuse of the xmlns namespace name is forbidden\n&quot;,
 9336                          NULL, NULL, NULL);
 9337                 goto next_attr;
 9338             }
 9339             if ((URL == NULL) || (URL[0] == 0)) {
 9340                 xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9341                          &quot;xmlns:%s: Empty XML namespace is not allowed\n&quot;,
 9342                               attname, NULL, NULL);
 9343                 goto next_attr;
 9344             } else {
 9345                 uri = xmlParseURI((const char *) URL);
 9346                 if (uri == NULL) {
 9347                     xmlNsErr(ctxt, XML_WAR_NS_URI,
 9348                          &quot;xmlns:%s: &#39;%s&#39; is not a valid URI\n&quot;,
 9349                                        attname, URL, NULL);
 9350                 } else {
 9351                     if ((ctxt-&gt;pedantic) &amp;&amp; (uri-&gt;scheme == NULL)) {
 9352                         xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
 9353                                   &quot;xmlns:%s: URI %s is not absolute\n&quot;,
 9354                                   attname, URL, NULL);
 9355                     }
 9356                     xmlFreeURI(uri);
 9357                 }
 9358             }
 9359 
 9360             /*
 9361              * check that it&#39;s not a defined namespace
 9362              */
 9363             for (j = 1;j &lt;= nbNs;j++)
 9364                 if (ctxt-&gt;nsTab[ctxt-&gt;nsNr - 2 * j] == attname)
 9365                     break;
 9366             if (j &lt;= nbNs)
 9367                 xmlErrAttributeDup(ctxt, aprefix, attname);
 9368             else
 9369                 if (nsPush(ctxt, attname, URL) &gt; 0) nbNs++;
 9370 
 9371         } else {
 9372             /*
 9373              * Add the pair to atts
 9374              */
 9375             if ((atts == NULL) || (nbatts + 5 &gt; maxatts)) {
 9376                 if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) &lt; 0) {
 9377                     goto next_attr;
 9378                 }
 9379                 maxatts = ctxt-&gt;maxatts;
 9380                 atts = ctxt-&gt;atts;
 9381             }
 9382             ctxt-&gt;attallocs[nratts++] = alloc;
 9383             atts[nbatts++] = attname;
 9384             atts[nbatts++] = aprefix;
 9385             /*
 9386              * The namespace URI field is used temporarily to point at the
 9387              * base of the current input buffer for non-alloced attributes.
 9388              * When the input buffer is reallocated, all the pointers become
 9389              * invalid, but they can be reconstructed later.
 9390              */
 9391             if (alloc)
 9392                 atts[nbatts++] = NULL;
 9393             else
 9394                 atts[nbatts++] = ctxt-&gt;input-&gt;base;
 9395             atts[nbatts++] = attvalue;
 9396             attvalue += len;
 9397             atts[nbatts++] = attvalue;
 9398             /*
 9399              * tag if some deallocation is needed
 9400              */
 9401             if (alloc != 0) attval = 1;
 9402             attvalue = NULL; /* moved into atts */
 9403         }
 9404 
 9405 next_attr:
 9406         if ((attvalue != NULL) &amp;&amp; (alloc != 0)) {
 9407             xmlFree(attvalue);
 9408             attvalue = NULL;
 9409         }
 9410 
 9411     GROW
 9412         if (ctxt-&gt;instate == XML_PARSER_EOF)
 9413             break;
 9414     if ((RAW == &#39;&gt;&#39;) || (((RAW == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;))))
 9415         break;
 9416     if (SKIP_BLANKS == 0) {
 9417         xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 9418                &quot;attributes construct error\n&quot;);
 9419         break;
 9420     }
 9421         if ((cons == ctxt-&gt;input-&gt;consumed) &amp;&amp; (q == CUR_PTR) &amp;&amp;
 9422             (attname == NULL) &amp;&amp; (attvalue == NULL)) {
 9423         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 9424              &quot;xmlParseStartTag: problem parsing attributes\n&quot;);
 9425         break;
 9426     }
 9427         GROW;
 9428     }
 9429 
 9430     if (ctxt-&gt;input-&gt;id != inputid) {
 9431         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 9432                     &quot;Unexpected change of input\n&quot;);
 9433         localname = NULL;
 9434         goto done;
 9435     }
 9436 
 9437     /* Reconstruct attribute value pointers. */
 9438     for (i = 0, j = 0; j &lt; nratts; i += 5, j++) {
 9439         if (atts[i+2] != NULL) {
 9440             /*
 9441              * Arithmetic on dangling pointers is technically undefined
 9442              * behavior, but well...
 9443              */
 9444             ptrdiff_t offset = ctxt-&gt;input-&gt;base - atts[i+2];
 9445             atts[i+2]  = NULL;    /* Reset repurposed namespace URI */
 9446             atts[i+3] += offset;  /* value */
 9447             atts[i+4] += offset;  /* valuend */
 9448         }
 9449     }
 9450 
 9451     /*
 9452      * The attributes defaulting
 9453      */
 9454     if (ctxt-&gt;attsDefault != NULL) {
 9455         xmlDefAttrsPtr defaults;
 9456 
 9457     defaults = xmlHashLookup2(ctxt-&gt;attsDefault, localname, prefix);
 9458     if (defaults != NULL) {
 9459         for (i = 0;i &lt; defaults-&gt;nbAttrs;i++) {
 9460             attname = defaults-&gt;values[5 * i];
 9461         aprefix = defaults-&gt;values[5 * i + 1];
 9462 
 9463                 /*
 9464          * special work for namespaces defaulted defs
 9465          */
 9466         if ((attname == ctxt-&gt;str_xmlns) &amp;&amp; (aprefix == NULL)) {
 9467             /*
 9468              * check that it&#39;s not a defined namespace
 9469              */
 9470             for (j = 1;j &lt;= nbNs;j++)
 9471                 if (ctxt-&gt;nsTab[ctxt-&gt;nsNr - 2 * j] == NULL)
 9472                 break;
 9473                 if (j &lt;= nbNs) continue;
 9474 
 9475             nsname = xmlGetNamespace(ctxt, NULL);
 9476             if (nsname != defaults-&gt;values[5 * i + 2]) {
 9477             if (nsPush(ctxt, NULL,
 9478                        defaults-&gt;values[5 * i + 2]) &gt; 0)
 9479                 nbNs++;
 9480             }
 9481         } else if (aprefix == ctxt-&gt;str_xmlns) {
 9482             /*
 9483              * check that it&#39;s not a defined namespace
 9484              */
 9485             for (j = 1;j &lt;= nbNs;j++)
 9486                 if (ctxt-&gt;nsTab[ctxt-&gt;nsNr - 2 * j] == attname)
 9487                 break;
 9488                 if (j &lt;= nbNs) continue;
 9489 
 9490             nsname = xmlGetNamespace(ctxt, attname);
 9491             if (nsname != defaults-&gt;values[2]) {
 9492             if (nsPush(ctxt, attname,
 9493                        defaults-&gt;values[5 * i + 2]) &gt; 0)
 9494                 nbNs++;
 9495             }
 9496         } else {
 9497             /*
 9498              * check that it&#39;s not a defined attribute
 9499              */
 9500             for (j = 0;j &lt; nbatts;j+=5) {
 9501             if ((attname == atts[j]) &amp;&amp; (aprefix == atts[j+1]))
 9502                 break;
 9503             }
 9504             if (j &lt; nbatts) continue;
 9505 
 9506             if ((atts == NULL) || (nbatts + 5 &gt; maxatts)) {
 9507             if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) &lt; 0) {
<a name="79" id="anc79"></a><span class="line-modified"> 9508                             localname = NULL;</span>
<span class="line-added"> 9509                             goto done;</span>
 9510             }
 9511             maxatts = ctxt-&gt;maxatts;
 9512             atts = ctxt-&gt;atts;
 9513             }
 9514             atts[nbatts++] = attname;
 9515             atts[nbatts++] = aprefix;
 9516             if (aprefix == NULL)
 9517             atts[nbatts++] = NULL;
 9518             else
 9519                 atts[nbatts++] = xmlGetNamespace(ctxt, aprefix);
 9520             atts[nbatts++] = defaults-&gt;values[5 * i + 2];
 9521             atts[nbatts++] = defaults-&gt;values[5 * i + 3];
 9522             if ((ctxt-&gt;standalone == 1) &amp;&amp;
 9523                 (defaults-&gt;values[5 * i + 4] != NULL)) {
 9524             xmlValidityError(ctxt, XML_DTD_STANDALONE_DEFAULTED,
 9525       &quot;standalone: attribute %s on %s defaulted from external subset\n&quot;,
 9526                                      attname, localname);
 9527             }
 9528             nbdef++;
 9529         }
 9530         }
 9531     }
 9532     }
 9533 
 9534     /*
 9535      * The attributes checkings
 9536      */
 9537     for (i = 0; i &lt; nbatts;i += 5) {
 9538         /*
 9539     * The default namespace does not apply to attribute names.
 9540     */
 9541     if (atts[i + 1] != NULL) {
 9542         nsname = xmlGetNamespace(ctxt, atts[i + 1]);
 9543         if (nsname == NULL) {
 9544         xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 9545             &quot;Namespace prefix %s for %s on %s is not defined\n&quot;,
 9546             atts[i + 1], atts[i], localname);
 9547         }
 9548         atts[i + 2] = nsname;
 9549     } else
 9550         nsname = NULL;
 9551     /*
 9552      * [ WFC: Unique Att Spec ]
 9553      * No attribute name may appear more than once in the same
 9554      * start-tag or empty-element tag.
 9555      * As extended by the Namespace in XML REC.
 9556      */
 9557         for (j = 0; j &lt; i;j += 5) {
 9558         if (atts[i] == atts[j]) {
 9559             if (atts[i+1] == atts[j+1]) {
 9560             xmlErrAttributeDup(ctxt, atts[i+1], atts[i]);
 9561             break;
 9562         }
 9563         if ((nsname != NULL) &amp;&amp; (atts[j + 2] == nsname)) {
 9564             xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED,
 9565                  &quot;Namespaced Attribute %s in &#39;%s&#39; redefined\n&quot;,
 9566                  atts[i], nsname, NULL);
 9567             break;
 9568         }
 9569         }
 9570     }
 9571     }
 9572 
 9573     nsname = xmlGetNamespace(ctxt, prefix);
 9574     if ((prefix != NULL) &amp;&amp; (nsname == NULL)) {
 9575     xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 9576              &quot;Namespace prefix %s on %s is not defined\n&quot;,
 9577          prefix, localname, NULL);
 9578     }
 9579     *pref = prefix;
 9580     *URI = nsname;
 9581 
 9582     /*
 9583      * SAX: Start of Element !
 9584      */
 9585     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;startElementNs != NULL) &amp;&amp;
 9586     (!ctxt-&gt;disableSAX)) {
 9587     if (nbNs &gt; 0)
 9588         ctxt-&gt;sax-&gt;startElementNs(ctxt-&gt;userData, localname, prefix,
 9589               nsname, nbNs, &amp;ctxt-&gt;nsTab[ctxt-&gt;nsNr - 2 * nbNs],
 9590               nbatts / 5, nbdef, atts);
 9591     else
 9592         ctxt-&gt;sax-&gt;startElementNs(ctxt-&gt;userData, localname, prefix,
 9593                       nsname, 0, NULL, nbatts / 5, nbdef, atts);
 9594     }
 9595 
 9596 done:
 9597     /*
 9598      * Free up attribute allocated strings if needed
 9599      */
 9600     if (attval != 0) {
 9601     for (i = 3,j = 0; j &lt; nratts;i += 5,j++)
 9602         if ((ctxt-&gt;attallocs[j] != 0) &amp;&amp; (atts[i] != NULL))
 9603             xmlFree((xmlChar *) atts[i]);
 9604     }
 9605 
 9606     return(localname);
 9607 }
 9608 
 9609 /**
 9610  * xmlParseEndTag2:
 9611  * @ctxt:  an XML parser context
 9612  * @line:  line of the start tag
 9613  * @nsNr:  number of namespaces on the start tag
 9614  *
 9615  * parse an end of tag
 9616  *
 9617  * [42] ETag ::= &#39;&lt;/&#39; Name S? &#39;&gt;&#39;
 9618  *
 9619  * With namespace
 9620  *
 9621  * [NS 9] ETag ::= &#39;&lt;/&#39; QName S? &#39;&gt;&#39;
 9622  */
 9623 
 9624 static void
 9625 xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,
 9626                 const xmlChar *URI, int line, int nsNr, int tlen) {
 9627     const xmlChar *name;
 9628     size_t curLength;
 9629 
 9630     GROW;
 9631     if ((RAW != &#39;&lt;&#39;) || (NXT(1) != &#39;/&#39;)) {
 9632     xmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, NULL);
 9633     return;
 9634     }
 9635     SKIP(2);
 9636 
 9637     curLength = ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur;
 9638     if ((tlen &gt; 0) &amp;&amp; (curLength &gt;= (size_t)tlen) &amp;&amp;
 9639         (xmlStrncmp(ctxt-&gt;input-&gt;cur, ctxt-&gt;name, tlen) == 0)) {
 9640         if ((curLength &gt;= (size_t)(tlen + 1)) &amp;&amp;
 9641         (ctxt-&gt;input-&gt;cur[tlen] == &#39;&gt;&#39;)) {
 9642         ctxt-&gt;input-&gt;cur += tlen + 1;
 9643         ctxt-&gt;input-&gt;col += tlen + 1;
 9644         goto done;
 9645     }
 9646     ctxt-&gt;input-&gt;cur += tlen;
 9647     ctxt-&gt;input-&gt;col += tlen;
 9648     name = (xmlChar*)1;
 9649     } else {
 9650     if (prefix == NULL)
 9651         name = xmlParseNameAndCompare(ctxt, ctxt-&gt;name);
 9652     else
 9653         name = xmlParseQNameAndCompare(ctxt, ctxt-&gt;name, prefix);
 9654     }
 9655 
 9656     /*
 9657      * We should definitely be at the ending &quot;S? &#39;&gt;&#39;&quot; part
 9658      */
 9659     GROW;
 9660     if (ctxt-&gt;instate == XML_PARSER_EOF)
 9661         return;
 9662     SKIP_BLANKS;
 9663     if ((!IS_BYTE_CHAR(RAW)) || (RAW != &#39;&gt;&#39;)) {
 9664     xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
 9665     } else
 9666     NEXT1;
 9667 
 9668     /*
 9669      * [ WFC: Element Type Match ]
 9670      * The Name in an element&#39;s end-tag must match the element type in the
 9671      * start-tag.
 9672      *
 9673      */
 9674     if (name != (xmlChar*)1) {
 9675         if (name == NULL) name = BAD_CAST &quot;unparseable&quot;;
 9676         if ((line == 0) &amp;&amp; (ctxt-&gt;node != NULL))
 9677             line = ctxt-&gt;node-&gt;line;
 9678         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
 9679              &quot;Opening and ending tag mismatch: %s line %d and %s\n&quot;,
 9680                         ctxt-&gt;name, line, name);
 9681     }
 9682 
 9683     /*
 9684      * SAX: End of Tag
 9685      */
 9686 done:
 9687     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElementNs != NULL) &amp;&amp;
 9688     (!ctxt-&gt;disableSAX))
 9689     ctxt-&gt;sax-&gt;endElementNs(ctxt-&gt;userData, ctxt-&gt;name, prefix, URI);
 9690 
 9691     spacePop(ctxt);
 9692     if (nsNr != 0)
 9693     nsPop(ctxt, nsNr);
 9694     return;
 9695 }
 9696 
 9697 /**
 9698  * xmlParseCDSect:
 9699  * @ctxt:  an XML parser context
 9700  *
 9701  * Parse escaped pure raw content.
 9702  *
 9703  * [18] CDSect ::= CDStart CData CDEnd
 9704  *
 9705  * [19] CDStart ::= &#39;&lt;![CDATA[&#39;
 9706  *
 9707  * [20] Data ::= (Char* - (Char* &#39;]]&gt;&#39; Char*))
 9708  *
 9709  * [21] CDEnd ::= &#39;]]&gt;&#39;
 9710  */
 9711 void
 9712 xmlParseCDSect(xmlParserCtxtPtr ctxt) {
 9713     xmlChar *buf = NULL;
 9714     int len = 0;
 9715     int size = XML_PARSER_BUFFER_SIZE;
 9716     int r, rl;
 9717     int s, sl;
 9718     int cur, l;
 9719     int count = 0;
 9720 
 9721     /* Check 2.6.0 was NXT(0) not RAW */
 9722     if (CMP9(CUR_PTR, &#39;&lt;&#39;, &#39;!&#39;, &#39;[&#39;, &#39;C&#39;, &#39;D&#39;, &#39;A&#39;, &#39;T&#39;, &#39;A&#39;, &#39;[&#39;)) {
 9723     SKIP(9);
 9724     } else
 9725         return;
 9726 
 9727     ctxt-&gt;instate = XML_PARSER_CDATA_SECTION;
 9728     r = CUR_CHAR(rl);
 9729     if (!IS_CHAR(r)) {
 9730     xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);
 9731     ctxt-&gt;instate = XML_PARSER_CONTENT;
 9732         return;
 9733     }
 9734     NEXTL(rl);
 9735     s = CUR_CHAR(sl);
 9736     if (!IS_CHAR(s)) {
 9737     xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);
 9738     ctxt-&gt;instate = XML_PARSER_CONTENT;
 9739         return;
 9740     }
 9741     NEXTL(sl);
 9742     cur = CUR_CHAR(l);
 9743     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));
 9744     if (buf == NULL) {
 9745     xmlErrMemory(ctxt, NULL);
 9746     return;
 9747     }
 9748     while (IS_CHAR(cur) &amp;&amp;
 9749            ((r != &#39;]&#39;) || (s != &#39;]&#39;) || (cur != &#39;&gt;&#39;))) {
 9750     if (len + 5 &gt;= size) {
 9751         xmlChar *tmp;
 9752 
 9753             if ((size &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 9754                 ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 9755                 xmlFatalErrMsgStr(ctxt, XML_ERR_CDATA_NOT_FINISHED,
 9756                              &quot;CData section too big found&quot;, NULL);
 9757                 xmlFree (buf);
 9758                 return;
 9759             }
 9760         tmp = (xmlChar *) xmlRealloc(buf, size * 2 * sizeof(xmlChar));
 9761         if (tmp == NULL) {
 9762             xmlFree(buf);
 9763         xmlErrMemory(ctxt, NULL);
 9764         return;
 9765         }
 9766         buf = tmp;
 9767         size *= 2;
 9768     }
 9769     COPY_BUF(rl,buf,len,r);
 9770     r = s;
 9771     rl = sl;
 9772     s = cur;
 9773     sl = l;
 9774     count++;
 9775     if (count &gt; 50) {
 9776         GROW;
 9777             if (ctxt-&gt;instate == XML_PARSER_EOF) {
 9778         xmlFree(buf);
 9779         return;
 9780             }
 9781         count = 0;
 9782     }
 9783     NEXTL(l);
 9784     cur = CUR_CHAR(l);
 9785     }
 9786     buf[len] = 0;
 9787     ctxt-&gt;instate = XML_PARSER_CONTENT;
 9788     if (cur != &#39;&gt;&#39;) {
 9789     xmlFatalErrMsgStr(ctxt, XML_ERR_CDATA_NOT_FINISHED,
 9790                          &quot;CData section not finished\n%.50s\n&quot;, buf);
 9791     xmlFree(buf);
 9792         return;
 9793     }
 9794     NEXTL(l);
 9795 
 9796     /*
 9797      * OK the buffer is to be consumed as cdata.
 9798      */
 9799     if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX)) {
 9800     if (ctxt-&gt;sax-&gt;cdataBlock != NULL)
 9801         ctxt-&gt;sax-&gt;cdataBlock(ctxt-&gt;userData, buf, len);
 9802     else if (ctxt-&gt;sax-&gt;characters != NULL)
 9803         ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, buf, len);
 9804     }
 9805     xmlFree(buf);
 9806 }
 9807 
 9808 /**
 9809  * xmlParseContent:
 9810  * @ctxt:  an XML parser context
 9811  *
 9812  * Parse a content:
 9813  *
 9814  * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
 9815  */
 9816 
 9817 void
 9818 xmlParseContent(xmlParserCtxtPtr ctxt) {
<a name="80" id="anc80"></a><span class="line-added"> 9819     int nameNr = ctxt-&gt;nameNr;</span>
<span class="line-added"> 9820 </span>
 9821     GROW;
 9822     while ((RAW != 0) &amp;&amp;
<a name="81" id="anc81"></a>
 9823        (ctxt-&gt;instate != XML_PARSER_EOF)) {
 9824     const xmlChar *test = CUR_PTR;
 9825     unsigned int cons = ctxt-&gt;input-&gt;consumed;
 9826     const xmlChar *cur = ctxt-&gt;input-&gt;cur;
 9827 
 9828     /*
 9829      * First case : a Processing Instruction.
 9830      */
 9831     if ((*cur == &#39;&lt;&#39;) &amp;&amp; (cur[1] == &#39;?&#39;)) {
 9832         xmlParsePI(ctxt);
 9833     }
 9834 
 9835     /*
 9836      * Second case : a CDSection
 9837      */
 9838     /* 2.6.0 test was *cur not RAW */
 9839     else if (CMP9(CUR_PTR, &#39;&lt;&#39;, &#39;!&#39;, &#39;[&#39;, &#39;C&#39;, &#39;D&#39;, &#39;A&#39;, &#39;T&#39;, &#39;A&#39;, &#39;[&#39;)) {
 9840         xmlParseCDSect(ctxt);
 9841     }
 9842 
 9843     /*
 9844      * Third case :  a comment
 9845      */
 9846     else if ((*cur == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp;
 9847          (NXT(2) == &#39;-&#39;) &amp;&amp; (NXT(3) == &#39;-&#39;)) {
 9848         xmlParseComment(ctxt);
 9849         ctxt-&gt;instate = XML_PARSER_CONTENT;
 9850     }
 9851 
 9852     /*
 9853      * Fourth case :  a sub-element.
 9854      */
 9855     else if (*cur == &#39;&lt;&#39;) {
<a name="82" id="anc82"></a><span class="line-modified"> 9856             if (NXT(1) == &#39;/&#39;) {</span>
<span class="line-added"> 9857                 if (ctxt-&gt;nameNr &lt;= nameNr)</span>
<span class="line-added"> 9858                     break;</span>
<span class="line-added"> 9859             xmlParseElementEnd(ctxt);</span>
<span class="line-added"> 9860             } else {</span>
<span class="line-added"> 9861             xmlParseElementStart(ctxt);</span>
<span class="line-added"> 9862             }</span>
 9863     }
 9864 
 9865     /*
 9866      * Fifth case : a reference. If if has not been resolved,
 9867      *    parsing returns it&#39;s Name, create the node
 9868      */
 9869 
 9870     else if (*cur == &#39;&amp;&#39;) {
 9871         xmlParseReference(ctxt);
 9872     }
 9873 
 9874     /*
 9875      * Last case, text. Note that References are handled directly.
 9876      */
 9877     else {
 9878         xmlParseCharData(ctxt, 0);
 9879     }
 9880 
 9881     GROW;
 9882     SHRINK;
 9883 
 9884     if ((cons == ctxt-&gt;input-&gt;consumed) &amp;&amp; (test == CUR_PTR)) {
 9885         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 9886                     &quot;detected an error in element content\n&quot;);
 9887         xmlHaltParser(ctxt);
 9888             break;
 9889     }
 9890     }
 9891 }
 9892 
 9893 /**
 9894  * xmlParseElement:
 9895  * @ctxt:  an XML parser context
 9896  *
<a name="83" id="anc83"></a><span class="line-modified"> 9897  * parse an XML element</span>
 9898  *
 9899  * [39] element ::= EmptyElemTag | STag content ETag
 9900  *
 9901  * [ WFC: Element Type Match ]
 9902  * The Name in an element&#39;s end-tag must match the element type in the
 9903  * start-tag.
 9904  *
 9905  */
 9906 
 9907 void
 9908 xmlParseElement(xmlParserCtxtPtr ctxt) {
<a name="84" id="anc84"></a><span class="line-added"> 9909     if (xmlParseElementStart(ctxt) != 0)</span>
<span class="line-added"> 9910         return;</span>
<span class="line-added"> 9911     xmlParseContent(ctxt);</span>
<span class="line-added"> 9912     if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-added"> 9913     return;</span>
<span class="line-added"> 9914     xmlParseElementEnd(ctxt);</span>
<span class="line-added"> 9915 }</span>
<span class="line-added"> 9916 </span>
<span class="line-added"> 9917 /**</span>
<span class="line-added"> 9918  * xmlParseElementStart:</span>
<span class="line-added"> 9919  * @ctxt:  an XML parser context</span>
<span class="line-added"> 9920  *</span>
<span class="line-added"> 9921  * Parse the start of an XML element. Returns -1 in case of error, 0 if an</span>
<span class="line-added"> 9922  * opening tag was parsed, 1 if an empty element was parsed.</span>
<span class="line-added"> 9923  */</span>
<span class="line-added"> 9924 static int</span>
<span class="line-added"> 9925 xmlParseElementStart(xmlParserCtxtPtr ctxt) {</span>
 9926     const xmlChar *name;
 9927     const xmlChar *prefix = NULL;
 9928     const xmlChar *URI = NULL;
 9929     xmlParserNodeInfo node_info;
 9930     int line, tlen = 0;
 9931     xmlNodePtr ret;
 9932     int nsNr = ctxt-&gt;nsNr;
 9933 
 9934     if (((unsigned int) ctxt-&gt;nameNr &gt; xmlParserMaxDepth) &amp;&amp;
 9935         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 9936     xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
 9937          &quot;Excessive depth in document: %d use XML_PARSE_HUGE option\n&quot;,
 9938               xmlParserMaxDepth);
 9939     xmlHaltParser(ctxt);
<a name="85" id="anc85"></a><span class="line-modified"> 9940     return(-1);</span>
 9941     }
 9942 
 9943     /* Capture start position */
 9944     if (ctxt-&gt;record_info) {
 9945         node_info.begin_pos = ctxt-&gt;input-&gt;consumed +
 9946                           (CUR_PTR - ctxt-&gt;input-&gt;base);
 9947     node_info.begin_line = ctxt-&gt;input-&gt;line;
 9948     }
 9949 
 9950     if (ctxt-&gt;spaceNr == 0)
 9951     spacePush(ctxt, -1);
 9952     else if (*ctxt-&gt;space == -2)
 9953     spacePush(ctxt, -1);
 9954     else
 9955     spacePush(ctxt, *ctxt-&gt;space);
 9956 
 9957     line = ctxt-&gt;input-&gt;line;
 9958 #ifdef LIBXML_SAX1_ENABLED
 9959     if (ctxt-&gt;sax2)
 9960 #endif /* LIBXML_SAX1_ENABLED */
 9961         name = xmlParseStartTag2(ctxt, &amp;prefix, &amp;URI, &amp;tlen);
 9962 #ifdef LIBXML_SAX1_ENABLED
 9963     else
 9964     name = xmlParseStartTag(ctxt);
 9965 #endif /* LIBXML_SAX1_ENABLED */
 9966     if (ctxt-&gt;instate == XML_PARSER_EOF)
<a name="86" id="anc86"></a><span class="line-modified"> 9967     return(-1);</span>
 9968     if (name == NULL) {
 9969     spacePop(ctxt);
<a name="87" id="anc87"></a><span class="line-modified"> 9970         return(-1);</span>
 9971     }
<a name="88" id="anc88"></a><span class="line-added"> 9972     if (ctxt-&gt;sax2)</span>
<span class="line-added"> 9973         nameNsPush(ctxt, name, prefix, URI, ctxt-&gt;nsNr - nsNr);</span>
<span class="line-added"> 9974 #ifdef LIBXML_SAX1_ENABLED</span>
<span class="line-added"> 9975     else</span>
 9976     namePush(ctxt, name);
<a name="89" id="anc89"></a><span class="line-added"> 9977 #endif /* LIBXML_SAX1_ENABLED */</span>
 9978     ret = ctxt-&gt;node;
 9979 
 9980 #ifdef LIBXML_VALID_ENABLED
 9981     /*
 9982      * [ VC: Root Element Type ]
 9983      * The Name in the document type declaration must match the element
 9984      * type of the root element.
 9985      */
 9986     if (ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp; ctxt-&gt;myDoc &amp;&amp;
 9987         ctxt-&gt;node &amp;&amp; (ctxt-&gt;node == ctxt-&gt;myDoc-&gt;children))
 9988         ctxt-&gt;valid &amp;= xmlValidateRoot(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc);
 9989 #endif /* LIBXML_VALID_ENABLED */
 9990 
 9991     /*
 9992      * Check for an Empty Element.
 9993      */
 9994     if ((RAW == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;)) {
 9995         SKIP(2);
 9996     if (ctxt-&gt;sax2) {
 9997         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElementNs != NULL) &amp;&amp;
 9998         (!ctxt-&gt;disableSAX))
 9999         ctxt-&gt;sax-&gt;endElementNs(ctxt-&gt;userData, name, prefix, URI);
10000 #ifdef LIBXML_SAX1_ENABLED
10001     } else {
10002         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElement != NULL) &amp;&amp;
10003         (!ctxt-&gt;disableSAX))
10004         ctxt-&gt;sax-&gt;endElement(ctxt-&gt;userData, name);
10005 #endif /* LIBXML_SAX1_ENABLED */
10006     }
10007     namePop(ctxt);
10008     spacePop(ctxt);
10009     if (nsNr != ctxt-&gt;nsNr)
10010         nsPop(ctxt, ctxt-&gt;nsNr - nsNr);
10011     if ( ret != NULL &amp;&amp; ctxt-&gt;record_info ) {
10012        node_info.end_pos = ctxt-&gt;input-&gt;consumed +
10013                   (CUR_PTR - ctxt-&gt;input-&gt;base);
10014        node_info.end_line = ctxt-&gt;input-&gt;line;
10015        node_info.node = ret;
10016        xmlParserAddNodeInfo(ctxt, &amp;node_info);
10017     }
<a name="90" id="anc90"></a><span class="line-modified">10018     return(1);</span>
10019     }
10020     if (RAW == &#39;&gt;&#39;) {
10021         NEXT1;
10022     } else {
10023         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_GT_REQUIRED,
10024              &quot;Couldn&#39;t find end of Start Tag %s line %d\n&quot;,
10025                         name, line, NULL);
10026 
10027     /*
10028      * end of parsing of this node.
10029      */
10030     nodePop(ctxt);
10031     namePop(ctxt);
10032     spacePop(ctxt);
10033     if (nsNr != ctxt-&gt;nsNr)
10034         nsPop(ctxt, ctxt-&gt;nsNr - nsNr);
10035 
10036     /*
10037      * Capture end position and add node
10038      */
10039     if ( ret != NULL &amp;&amp; ctxt-&gt;record_info ) {
10040        node_info.end_pos = ctxt-&gt;input-&gt;consumed +
10041                   (CUR_PTR - ctxt-&gt;input-&gt;base);
10042        node_info.end_line = ctxt-&gt;input-&gt;line;
10043        node_info.node = ret;
10044        xmlParserAddNodeInfo(ctxt, &amp;node_info);
10045     }
<a name="91" id="anc91"></a><span class="line-modified">10046     return(-1);</span>
10047     }
10048 
<a name="92" id="anc92"></a><span class="line-modified">10049     return(0);</span>
<span class="line-modified">10050 }</span>








10051 
<a name="93" id="anc93"></a><span class="line-modified">10052 /**</span>
<span class="line-modified">10053  * xmlParseElementEnd:</span>
<span class="line-added">10054  * @ctxt:  an XML parser context</span>
<span class="line-added">10055  *</span>
<span class="line-added">10056  * Parse the end of an XML element.</span>
10057      */
<a name="94" id="anc94"></a><span class="line-modified">10058 static void</span>
<span class="line-modified">10059 xmlParseElementEnd(xmlParserCtxtPtr ctxt) {</span>
<span class="line-modified">10060     xmlParserNodeInfo node_info;</span>
<span class="line-modified">10061     xmlNodePtr ret = ctxt-&gt;node;</span>
<span class="line-modified">10062 </span>
<span class="line-added">10063     if (ctxt-&gt;nameNr &lt;= 0)</span>
10064     return;
<a name="95" id="anc95"></a>
10065 
10066     /*
10067      * parse the end of tag: &#39;&lt;/&#39; should be here.
10068      */
10069     if (ctxt-&gt;sax2) {
<a name="96" id="anc96"></a><span class="line-modified">10070         const xmlChar *prefix = ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 - 3];</span>
<span class="line-added">10071         const xmlChar *URI = ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 - 2];</span>
<span class="line-added">10072         int nsNr = (ptrdiff_t) ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 - 1];</span>
<span class="line-added">10073     xmlParseEndTag2(ctxt, prefix, URI, 0, nsNr, 0);</span>
10074     namePop(ctxt);
10075     }
10076 #ifdef LIBXML_SAX1_ENABLED
10077       else
<a name="97" id="anc97"></a><span class="line-modified">10078     xmlParseEndTag1(ctxt, 0);</span>
10079 #endif /* LIBXML_SAX1_ENABLED */
10080 
10081     /*
10082      * Capture end position and add node
10083      */
10084     if ( ret != NULL &amp;&amp; ctxt-&gt;record_info ) {
10085        node_info.end_pos = ctxt-&gt;input-&gt;consumed +
10086                           (CUR_PTR - ctxt-&gt;input-&gt;base);
10087        node_info.end_line = ctxt-&gt;input-&gt;line;
10088        node_info.node = ret;
10089        xmlParserAddNodeInfo(ctxt, &amp;node_info);
10090     }
10091 }
10092 
10093 /**
10094  * xmlParseVersionNum:
10095  * @ctxt:  an XML parser context
10096  *
10097  * parse the XML version value.
10098  *
10099  * [26] VersionNum ::= &#39;1.&#39; [0-9]+
10100  *
10101  * In practice allow [0-9].[0-9]+ at that level
10102  *
10103  * Returns the string giving the XML version number, or NULL
10104  */
10105 xmlChar *
10106 xmlParseVersionNum(xmlParserCtxtPtr ctxt) {
10107     xmlChar *buf = NULL;
10108     int len = 0;
10109     int size = 10;
10110     xmlChar cur;
10111 
10112     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));
10113     if (buf == NULL) {
10114     xmlErrMemory(ctxt, NULL);
10115     return(NULL);
10116     }
10117     cur = CUR;
10118     if (!((cur &gt;= &#39;0&#39;) &amp;&amp; (cur &lt;= &#39;9&#39;))) {
10119     xmlFree(buf);
10120     return(NULL);
10121     }
10122     buf[len++] = cur;
10123     NEXT;
10124     cur=CUR;
10125     if (cur != &#39;.&#39;) {
10126     xmlFree(buf);
10127     return(NULL);
10128     }
10129     buf[len++] = cur;
10130     NEXT;
10131     cur=CUR;
10132     while ((cur &gt;= &#39;0&#39;) &amp;&amp; (cur &lt;= &#39;9&#39;)) {
10133     if (len + 1 &gt;= size) {
10134         xmlChar *tmp;
10135 
10136         size *= 2;
10137         tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));
10138         if (tmp == NULL) {
10139             xmlFree(buf);
10140         xmlErrMemory(ctxt, NULL);
10141         return(NULL);
10142         }
10143         buf = tmp;
10144     }
10145     buf[len++] = cur;
10146     NEXT;
10147     cur=CUR;
10148     }
10149     buf[len] = 0;
10150     return(buf);
10151 }
10152 
10153 /**
10154  * xmlParseVersionInfo:
10155  * @ctxt:  an XML parser context
10156  *
10157  * parse the XML version.
10158  *
10159  * [24] VersionInfo ::= S &#39;version&#39; Eq (&#39; VersionNum &#39; | &quot; VersionNum &quot;)
10160  *
10161  * [25] Eq ::= S? &#39;=&#39; S?
10162  *
10163  * Returns the version string, e.g. &quot;1.0&quot;
10164  */
10165 
10166 xmlChar *
10167 xmlParseVersionInfo(xmlParserCtxtPtr ctxt) {
10168     xmlChar *version = NULL;
10169 
10170     if (CMP7(CUR_PTR, &#39;v&#39;, &#39;e&#39;, &#39;r&#39;, &#39;s&#39;, &#39;i&#39;, &#39;o&#39;, &#39;n&#39;)) {
10171     SKIP(7);
10172     SKIP_BLANKS;
10173     if (RAW != &#39;=&#39;) {
10174         xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
10175         return(NULL);
10176         }
10177     NEXT;
10178     SKIP_BLANKS;
10179     if (RAW == &#39;&quot;&#39;) {
10180         NEXT;
10181         version = xmlParseVersionNum(ctxt);
10182         if (RAW != &#39;&quot;&#39;) {
10183         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10184         } else
10185             NEXT;
10186     } else if (RAW == &#39;\&#39;&#39;){
10187         NEXT;
10188         version = xmlParseVersionNum(ctxt);
10189         if (RAW != &#39;\&#39;&#39;) {
10190         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10191         } else
10192             NEXT;
10193     } else {
10194         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10195     }
10196     }
10197     return(version);
10198 }
10199 
10200 /**
10201  * xmlParseEncName:
10202  * @ctxt:  an XML parser context
10203  *
10204  * parse the XML encoding name
10205  *
10206  * [81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | &#39;-&#39;)*
10207  *
10208  * Returns the encoding name value or NULL
10209  */
10210 xmlChar *
10211 xmlParseEncName(xmlParserCtxtPtr ctxt) {
10212     xmlChar *buf = NULL;
10213     int len = 0;
10214     int size = 10;
10215     xmlChar cur;
10216 
10217     cur = CUR;
10218     if (((cur &gt;= &#39;a&#39;) &amp;&amp; (cur &lt;= &#39;z&#39;)) ||
10219         ((cur &gt;= &#39;A&#39;) &amp;&amp; (cur &lt;= &#39;Z&#39;))) {
10220     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));
10221     if (buf == NULL) {
10222         xmlErrMemory(ctxt, NULL);
10223         return(NULL);
10224     }
10225 
10226     buf[len++] = cur;
10227     NEXT;
10228     cur = CUR;
10229     while (((cur &gt;= &#39;a&#39;) &amp;&amp; (cur &lt;= &#39;z&#39;)) ||
10230            ((cur &gt;= &#39;A&#39;) &amp;&amp; (cur &lt;= &#39;Z&#39;)) ||
10231            ((cur &gt;= &#39;0&#39;) &amp;&amp; (cur &lt;= &#39;9&#39;)) ||
10232            (cur == &#39;.&#39;) || (cur == &#39;_&#39;) ||
10233            (cur == &#39;-&#39;)) {
10234         if (len + 1 &gt;= size) {
10235             xmlChar *tmp;
10236 
10237         size *= 2;
10238         tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));
10239         if (tmp == NULL) {
10240             xmlErrMemory(ctxt, NULL);
10241             xmlFree(buf);
10242             return(NULL);
10243         }
10244         buf = tmp;
10245         }
10246         buf[len++] = cur;
10247         NEXT;
10248         cur = CUR;
10249         if (cur == 0) {
10250             SHRINK;
10251         GROW;
10252         cur = CUR;
10253         }
10254         }
10255     buf[len] = 0;
10256     } else {
10257     xmlFatalErr(ctxt, XML_ERR_ENCODING_NAME, NULL);
10258     }
10259     return(buf);
10260 }
10261 
10262 /**
10263  * xmlParseEncodingDecl:
10264  * @ctxt:  an XML parser context
10265  *
10266  * parse the XML encoding declaration
10267  *
10268  * [80] EncodingDecl ::= S &#39;encoding&#39; Eq (&#39;&quot;&#39; EncName &#39;&quot;&#39; |  &quot;&#39;&quot; EncName &quot;&#39;&quot;)
10269  *
10270  * this setups the conversion filters.
10271  *
10272  * Returns the encoding value or NULL
10273  */
10274 
10275 const xmlChar *
10276 xmlParseEncodingDecl(xmlParserCtxtPtr ctxt) {
10277     xmlChar *encoding = NULL;
10278 
10279     SKIP_BLANKS;
10280     if (CMP8(CUR_PTR, &#39;e&#39;, &#39;n&#39;, &#39;c&#39;, &#39;o&#39;, &#39;d&#39;, &#39;i&#39;, &#39;n&#39;, &#39;g&#39;)) {
10281     SKIP(8);
10282     SKIP_BLANKS;
10283     if (RAW != &#39;=&#39;) {
10284         xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
10285         return(NULL);
10286         }
10287     NEXT;
10288     SKIP_BLANKS;
10289     if (RAW == &#39;&quot;&#39;) {
10290         NEXT;
10291         encoding = xmlParseEncName(ctxt);
10292         if (RAW != &#39;&quot;&#39;) {
10293         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10294         xmlFree((xmlChar *) encoding);
10295         return(NULL);
10296         } else
10297             NEXT;
10298     } else if (RAW == &#39;\&#39;&#39;){
10299         NEXT;
10300         encoding = xmlParseEncName(ctxt);
10301         if (RAW != &#39;\&#39;&#39;) {
10302         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10303         xmlFree((xmlChar *) encoding);
10304         return(NULL);
10305         } else
10306             NEXT;
10307     } else {
10308         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10309     }
10310 
10311         /*
10312          * Non standard parsing, allowing the user to ignore encoding
10313          */
10314         if (ctxt-&gt;options &amp; XML_PARSE_IGNORE_ENC) {
10315         xmlFree((xmlChar *) encoding);
10316             return(NULL);
10317     }
10318 
10319     /*
<a name="98" id="anc98"></a><span class="line-modified">10320      * UTF-16 encoding switch has already taken place at this stage,</span>
10321      * more over the little-endian/big-endian selection is already done
10322      */
10323         if ((encoding != NULL) &amp;&amp;
10324         ((!xmlStrcasecmp(encoding, BAD_CAST &quot;UTF-16&quot;)) ||
10325          (!xmlStrcasecmp(encoding, BAD_CAST &quot;UTF16&quot;)))) {
10326         /*
10327          * If no encoding was passed to the parser, that we are
10328          * using UTF-16 and no decoder is present i.e. the
10329          * document is apparently UTF-8 compatible, then raise an
10330          * encoding mismatch fatal error
10331          */
10332         if ((ctxt-&gt;encoding == NULL) &amp;&amp;
10333             (ctxt-&gt;input-&gt;buf != NULL) &amp;&amp;
10334             (ctxt-&gt;input-&gt;buf-&gt;encoder == NULL)) {
10335         xmlFatalErrMsg(ctxt, XML_ERR_INVALID_ENCODING,
10336           &quot;Document labelled UTF-16 but has UTF-8 content\n&quot;);
10337         }
10338         if (ctxt-&gt;encoding != NULL)
10339         xmlFree((xmlChar *) ctxt-&gt;encoding);
10340         ctxt-&gt;encoding = encoding;
10341     }
10342     /*
10343      * UTF-8 encoding is handled natively
10344      */
10345         else if ((encoding != NULL) &amp;&amp;
10346         ((!xmlStrcasecmp(encoding, BAD_CAST &quot;UTF-8&quot;)) ||
10347          (!xmlStrcasecmp(encoding, BAD_CAST &quot;UTF8&quot;)))) {
10348         if (ctxt-&gt;encoding != NULL)
10349         xmlFree((xmlChar *) ctxt-&gt;encoding);
10350         ctxt-&gt;encoding = encoding;
10351     }
10352     else if (encoding != NULL) {
10353         xmlCharEncodingHandlerPtr handler;
10354 
10355         if (ctxt-&gt;input-&gt;encoding != NULL)
10356         xmlFree((xmlChar *) ctxt-&gt;input-&gt;encoding);
10357         ctxt-&gt;input-&gt;encoding = encoding;
10358 
10359             handler = xmlFindCharEncodingHandler((const char *) encoding);
10360         if (handler != NULL) {
10361         if (xmlSwitchToEncoding(ctxt, handler) &lt; 0) {
10362             /* failed to convert */
10363             ctxt-&gt;errNo = XML_ERR_UNSUPPORTED_ENCODING;
10364             return(NULL);
10365         }
10366         } else {
10367         xmlFatalErrMsgStr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
10368             &quot;Unsupported encoding %s\n&quot;, encoding);
10369         return(NULL);
10370         }
10371     }
10372     }
10373     return(encoding);
10374 }
10375 
10376 /**
10377  * xmlParseSDDecl:
10378  * @ctxt:  an XML parser context
10379  *
10380  * parse the XML standalone declaration
10381  *
10382  * [32] SDDecl ::= S &#39;standalone&#39; Eq
10383  *                 ((&quot;&#39;&quot; (&#39;yes&#39; | &#39;no&#39;) &quot;&#39;&quot;) | (&#39;&quot;&#39; (&#39;yes&#39; | &#39;no&#39;)&#39;&quot;&#39;))
10384  *
10385  * [ VC: Standalone Document Declaration ]
10386  * TODO The standalone document declaration must have the value &quot;no&quot;
10387  * if any external markup declarations contain declarations of:
10388  *  - attributes with default values, if elements to which these
10389  *    attributes apply appear in the document without specifications
10390  *    of values for these attributes, or
10391  *  - entities (other than amp, lt, gt, apos, quot), if references
10392  *    to those entities appear in the document, or
10393  *  - attributes with values subject to normalization, where the
10394  *    attribute appears in the document with a value which will change
10395  *    as a result of normalization, or
10396  *  - element types with element content, if white space occurs directly
10397  *    within any instance of those types.
10398  *
10399  * Returns:
10400  *   1 if standalone=&quot;yes&quot;
10401  *   0 if standalone=&quot;no&quot;
10402  *  -2 if standalone attribute is missing or invalid
10403  *    (A standalone value of -2 means that the XML declaration was found,
10404  *     but no value was specified for the standalone attribute).
10405  */
10406 
10407 int
10408 xmlParseSDDecl(xmlParserCtxtPtr ctxt) {
10409     int standalone = -2;
10410 
10411     SKIP_BLANKS;
10412     if (CMP10(CUR_PTR, &#39;s&#39;, &#39;t&#39;, &#39;a&#39;, &#39;n&#39;, &#39;d&#39;, &#39;a&#39;, &#39;l&#39;, &#39;o&#39;, &#39;n&#39;, &#39;e&#39;)) {
10413     SKIP(10);
10414         SKIP_BLANKS;
10415     if (RAW != &#39;=&#39;) {
10416         xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
10417         return(standalone);
10418         }
10419     NEXT;
10420     SKIP_BLANKS;
10421         if (RAW == &#39;\&#39;&#39;){
10422         NEXT;
10423         if ((RAW == &#39;n&#39;) &amp;&amp; (NXT(1) == &#39;o&#39;)) {
10424             standalone = 0;
10425                 SKIP(2);
10426         } else if ((RAW == &#39;y&#39;) &amp;&amp; (NXT(1) == &#39;e&#39;) &amp;&amp;
10427                    (NXT(2) == &#39;s&#39;)) {
10428             standalone = 1;
10429         SKIP(3);
10430             } else {
10431         xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);
10432         }
10433         if (RAW != &#39;\&#39;&#39;) {
10434         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10435         } else
10436             NEXT;
10437     } else if (RAW == &#39;&quot;&#39;){
10438         NEXT;
10439         if ((RAW == &#39;n&#39;) &amp;&amp; (NXT(1) == &#39;o&#39;)) {
10440             standalone = 0;
10441         SKIP(2);
10442         } else if ((RAW == &#39;y&#39;) &amp;&amp; (NXT(1) == &#39;e&#39;) &amp;&amp;
10443                    (NXT(2) == &#39;s&#39;)) {
10444             standalone = 1;
10445                 SKIP(3);
10446             } else {
10447         xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);
10448         }
10449         if (RAW != &#39;&quot;&#39;) {
10450         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10451         } else
10452             NEXT;
10453     } else {
10454         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10455         }
10456     }
10457     return(standalone);
10458 }
10459 
10460 /**
10461  * xmlParseXMLDecl:
10462  * @ctxt:  an XML parser context
10463  *
10464  * parse an XML declaration header
10465  *
10466  * [23] XMLDecl ::= &#39;&lt;?xml&#39; VersionInfo EncodingDecl? SDDecl? S? &#39;?&gt;&#39;
10467  */
10468 
10469 void
10470 xmlParseXMLDecl(xmlParserCtxtPtr ctxt) {
10471     xmlChar *version;
10472 
10473     /*
10474      * This value for standalone indicates that the document has an
10475      * XML declaration but it does not have a standalone attribute.
10476      * It will be overwritten later if a standalone attribute is found.
10477      */
10478     ctxt-&gt;input-&gt;standalone = -2;
10479 
10480     /*
10481      * We know that &#39;&lt;?xml&#39; is here.
10482      */
10483     SKIP(5);
10484 
10485     if (!IS_BLANK_CH(RAW)) {
10486     xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
10487                    &quot;Blank needed after &#39;&lt;?xml&#39;\n&quot;);
10488     }
10489     SKIP_BLANKS;
10490 
10491     /*
10492      * We must have the VersionInfo here.
10493      */
10494     version = xmlParseVersionInfo(ctxt);
10495     if (version == NULL) {
10496     xmlFatalErr(ctxt, XML_ERR_VERSION_MISSING, NULL);
10497     } else {
10498     if (!xmlStrEqual(version, (const xmlChar *) XML_DEFAULT_VERSION)) {
10499         /*
10500          * Changed here for XML-1.0 5th edition
10501          */
10502         if (ctxt-&gt;options &amp; XML_PARSE_OLD10) {
10503         xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,
10504                       &quot;Unsupported version &#39;%s&#39;\n&quot;,
10505                       version);
10506         } else {
10507             if ((version[0] == &#39;1&#39;) &amp;&amp; ((version[1] == &#39;.&#39;))) {
10508             xmlWarningMsg(ctxt, XML_WAR_UNKNOWN_VERSION,
10509                           &quot;Unsupported version &#39;%s&#39;\n&quot;,
10510                   version, NULL);
10511         } else {
10512             xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,
10513                       &quot;Unsupported version &#39;%s&#39;\n&quot;,
10514                       version);
10515         }
10516         }
10517     }
10518     if (ctxt-&gt;version != NULL)
10519         xmlFree((void *) ctxt-&gt;version);
10520     ctxt-&gt;version = version;
10521     }
10522 
10523     /*
10524      * We may have the encoding declaration
10525      */
10526     if (!IS_BLANK_CH(RAW)) {
10527         if ((RAW == &#39;?&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;)) {
10528         SKIP(2);
10529         return;
10530     }
10531     xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, &quot;Blank needed here\n&quot;);
10532     }
10533     xmlParseEncodingDecl(ctxt);
10534     if ((ctxt-&gt;errNo == XML_ERR_UNSUPPORTED_ENCODING) ||
10535          (ctxt-&gt;instate == XML_PARSER_EOF)) {
10536     /*
10537      * The XML REC instructs us to stop parsing right here
10538      */
10539         return;
10540     }
10541 
10542     /*
10543      * We may have the standalone status.
10544      */
10545     if ((ctxt-&gt;input-&gt;encoding != NULL) &amp;&amp; (!IS_BLANK_CH(RAW))) {
10546         if ((RAW == &#39;?&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;)) {
10547         SKIP(2);
10548         return;
10549     }
10550     xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, &quot;Blank needed here\n&quot;);
10551     }
10552 
10553     /*
10554      * We can grow the input buffer freely at that point
10555      */
10556     GROW;
10557 
10558     SKIP_BLANKS;
10559     ctxt-&gt;input-&gt;standalone = xmlParseSDDecl(ctxt);
10560 
10561     SKIP_BLANKS;
10562     if ((RAW == &#39;?&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;)) {
10563         SKIP(2);
10564     } else if (RAW == &#39;&gt;&#39;) {
10565         /* Deprecated old WD ... */
10566     xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
10567     NEXT;
10568     } else {
10569     xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
10570     MOVETO_ENDTAG(CUR_PTR);
10571     NEXT;
10572     }
10573 }
10574 
10575 /**
10576  * xmlParseMisc:
10577  * @ctxt:  an XML parser context
10578  *
10579  * parse an XML Misc* optional field.
10580  *
10581  * [27] Misc ::= Comment | PI |  S
10582  */
10583 
10584 void
10585 xmlParseMisc(xmlParserCtxtPtr ctxt) {
10586     while ((ctxt-&gt;instate != XML_PARSER_EOF) &amp;&amp;
10587            (((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;?&#39;)) ||
10588             (CMP4(CUR_PTR, &#39;&lt;&#39;, &#39;!&#39;, &#39;-&#39;, &#39;-&#39;)) ||
10589             IS_BLANK_CH(CUR))) {
10590         if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;?&#39;)) {
10591         xmlParsePI(ctxt);
10592     } else if (IS_BLANK_CH(CUR)) {
10593         NEXT;
10594     } else
10595         xmlParseComment(ctxt);
10596     }
10597 }
10598 
10599 /**
10600  * xmlParseDocument:
10601  * @ctxt:  an XML parser context
10602  *
10603  * parse an XML document (and build a tree if using the standard SAX
10604  * interface).
10605  *
10606  * [1] document ::= prolog element Misc*
10607  *
10608  * [22] prolog ::= XMLDecl? Misc* (doctypedecl Misc*)?
10609  *
10610  * Returns 0, -1 in case of error. the parser context is augmented
10611  *                as a result of the parsing.
10612  */
10613 
10614 int
10615 xmlParseDocument(xmlParserCtxtPtr ctxt) {
10616     xmlChar start[4];
10617     xmlCharEncoding enc;
10618 
10619     xmlInitParser();
10620 
10621     if ((ctxt == NULL) || (ctxt-&gt;input == NULL))
10622         return(-1);
10623 
10624     GROW;
10625 
10626     /*
10627      * SAX: detecting the level.
10628      */
10629     xmlDetectSAX2(ctxt);
10630 
10631     /*
10632      * SAX: beginning of the document processing.
10633      */
10634     if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;setDocumentLocator))
10635         ctxt-&gt;sax-&gt;setDocumentLocator(ctxt-&gt;userData, &amp;xmlDefaultSAXLocator);
10636     if (ctxt-&gt;instate == XML_PARSER_EOF)
10637     return(-1);
10638 
10639     if ((ctxt-&gt;encoding == NULL) &amp;&amp;
10640         ((ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur) &gt;= 4)) {
10641     /*
10642      * Get the 4 first bytes and decode the charset
10643      * if enc != XML_CHAR_ENCODING_NONE
10644      * plug some encoding conversion routines.
10645      */
10646     start[0] = RAW;
10647     start[1] = NXT(1);
10648     start[2] = NXT(2);
10649     start[3] = NXT(3);
10650     enc = xmlDetectCharEncoding(&amp;start[0], 4);
10651     if (enc != XML_CHAR_ENCODING_NONE) {
10652         xmlSwitchEncoding(ctxt, enc);
10653     }
10654     }
10655 
10656 
10657     if (CUR == 0) {
10658     xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
10659     return(-1);
10660     }
10661 
10662     /*
10663      * Check for the XMLDecl in the Prolog.
10664      * do not GROW here to avoid the detected encoder to decode more
10665      * than just the first line, unless the amount of data is really
10666      * too small to hold &quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;foo&quot;
10667      */
10668     if ((ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur) &lt; 35) {
10669        GROW;
10670     }
10671     if ((CMP5(CUR_PTR, &#39;&lt;&#39;, &#39;?&#39;, &#39;x&#39;, &#39;m&#39;, &#39;l&#39;)) &amp;&amp; (IS_BLANK_CH(NXT(5)))) {
10672 
10673     /*
10674      * Note that we will switch encoding on the fly.
10675      */
10676     xmlParseXMLDecl(ctxt);
10677     if ((ctxt-&gt;errNo == XML_ERR_UNSUPPORTED_ENCODING) ||
10678         (ctxt-&gt;instate == XML_PARSER_EOF)) {
10679         /*
10680          * The XML REC instructs us to stop parsing right here
10681          */
10682         return(-1);
10683     }
10684     ctxt-&gt;standalone = ctxt-&gt;input-&gt;standalone;
10685     SKIP_BLANKS;
10686     } else {
10687     ctxt-&gt;version = xmlCharStrdup(XML_DEFAULT_VERSION);
10688     }
10689     if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;startDocument) &amp;&amp; (!ctxt-&gt;disableSAX))
10690         ctxt-&gt;sax-&gt;startDocument(ctxt-&gt;userData);
10691     if (ctxt-&gt;instate == XML_PARSER_EOF)
10692     return(-1);
10693     if ((ctxt-&gt;myDoc != NULL) &amp;&amp; (ctxt-&gt;input != NULL) &amp;&amp;
10694         (ctxt-&gt;input-&gt;buf != NULL) &amp;&amp; (ctxt-&gt;input-&gt;buf-&gt;compressed &gt;= 0)) {
10695     ctxt-&gt;myDoc-&gt;compression = ctxt-&gt;input-&gt;buf-&gt;compressed;
10696     }
10697 
10698     /*
10699      * The Misc part of the Prolog
10700      */
10701     GROW;
10702     xmlParseMisc(ctxt);
10703 
10704     /*
10705      * Then possibly doc type declaration(s) and more Misc
10706      * (doctypedecl Misc*)?
10707      */
10708     GROW;
10709     if (CMP9(CUR_PTR, &#39;&lt;&#39;, &#39;!&#39;, &#39;D&#39;, &#39;O&#39;, &#39;C&#39;, &#39;T&#39;, &#39;Y&#39;, &#39;P&#39;, &#39;E&#39;)) {
10710 
10711     ctxt-&gt;inSubset = 1;
10712     xmlParseDocTypeDecl(ctxt);
10713     if (RAW == &#39;[&#39;) {
10714         ctxt-&gt;instate = XML_PARSER_DTD;
10715         xmlParseInternalSubset(ctxt);
10716         if (ctxt-&gt;instate == XML_PARSER_EOF)
10717         return(-1);
10718     }
10719 
10720     /*
10721      * Create and update the external subset.
10722      */
10723     ctxt-&gt;inSubset = 2;
10724     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;externalSubset != NULL) &amp;&amp;
10725         (!ctxt-&gt;disableSAX))
10726         ctxt-&gt;sax-&gt;externalSubset(ctxt-&gt;userData, ctxt-&gt;intSubName,
10727                                   ctxt-&gt;extSubSystem, ctxt-&gt;extSubURI);
10728     if (ctxt-&gt;instate == XML_PARSER_EOF)
10729         return(-1);
10730     ctxt-&gt;inSubset = 0;
10731 
10732         xmlCleanSpecialAttr(ctxt);
10733 
10734     ctxt-&gt;instate = XML_PARSER_PROLOG;
10735     xmlParseMisc(ctxt);
10736     }
10737 
10738     /*
10739      * Time to start parsing the tree itself
10740      */
10741     GROW;
10742     if (RAW != &#39;&lt;&#39;) {
10743     xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,
10744                &quot;Start tag expected, &#39;&lt;&#39; not found\n&quot;);
10745     } else {
10746     ctxt-&gt;instate = XML_PARSER_CONTENT;
10747     xmlParseElement(ctxt);
10748     ctxt-&gt;instate = XML_PARSER_EPILOG;
10749 
10750 
10751     /*
10752      * The Misc part at the end
10753      */
10754     xmlParseMisc(ctxt);
10755 
10756     if (RAW != 0) {
10757         xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);
10758     }
10759     ctxt-&gt;instate = XML_PARSER_EOF;
10760     }
10761 
10762     /*
10763      * SAX: end of the document processing.
10764      */
10765     if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;endDocument != NULL))
10766         ctxt-&gt;sax-&gt;endDocument(ctxt-&gt;userData);
10767 
10768     /*
10769      * Remove locally kept entity definitions if the tree was not built
10770      */
10771     if ((ctxt-&gt;myDoc != NULL) &amp;&amp;
10772     (xmlStrEqual(ctxt-&gt;myDoc-&gt;version, SAX_COMPAT_MODE))) {
10773     xmlFreeDoc(ctxt-&gt;myDoc);
10774     ctxt-&gt;myDoc = NULL;
10775     }
10776 
10777     if ((ctxt-&gt;wellFormed) &amp;&amp; (ctxt-&gt;myDoc != NULL)) {
10778         ctxt-&gt;myDoc-&gt;properties |= XML_DOC_WELLFORMED;
10779     if (ctxt-&gt;valid)
10780         ctxt-&gt;myDoc-&gt;properties |= XML_DOC_DTDVALID;
10781     if (ctxt-&gt;nsWellFormed)
10782         ctxt-&gt;myDoc-&gt;properties |= XML_DOC_NSVALID;
10783     if (ctxt-&gt;options &amp; XML_PARSE_OLD10)
10784         ctxt-&gt;myDoc-&gt;properties |= XML_DOC_OLD10;
10785     }
10786     if (! ctxt-&gt;wellFormed) {
10787     ctxt-&gt;valid = 0;
10788     return(-1);
10789     }
10790     return(0);
10791 }
10792 
10793 /**
10794  * xmlParseExtParsedEnt:
10795  * @ctxt:  an XML parser context
10796  *
10797  * parse a general parsed entity
10798  * An external general parsed entity is well-formed if it matches the
10799  * production labeled extParsedEnt.
10800  *
10801  * [78] extParsedEnt ::= TextDecl? content
10802  *
10803  * Returns 0, -1 in case of error. the parser context is augmented
10804  *                as a result of the parsing.
10805  */
10806 
10807 int
10808 xmlParseExtParsedEnt(xmlParserCtxtPtr ctxt) {
10809     xmlChar start[4];
10810     xmlCharEncoding enc;
10811 
10812     if ((ctxt == NULL) || (ctxt-&gt;input == NULL))
10813         return(-1);
10814 
10815     xmlDefaultSAXHandlerInit();
10816 
10817     xmlDetectSAX2(ctxt);
10818 
10819     GROW;
10820 
10821     /*
10822      * SAX: beginning of the document processing.
10823      */
10824     if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;setDocumentLocator))
10825         ctxt-&gt;sax-&gt;setDocumentLocator(ctxt-&gt;userData, &amp;xmlDefaultSAXLocator);
10826 
10827     /*
10828      * Get the 4 first bytes and decode the charset
10829      * if enc != XML_CHAR_ENCODING_NONE
10830      * plug some encoding conversion routines.
10831      */
10832     if ((ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur) &gt;= 4) {
10833     start[0] = RAW;
10834     start[1] = NXT(1);
10835     start[2] = NXT(2);
10836     start[3] = NXT(3);
10837     enc = xmlDetectCharEncoding(start, 4);
10838     if (enc != XML_CHAR_ENCODING_NONE) {
10839         xmlSwitchEncoding(ctxt, enc);
10840     }
10841     }
10842 
10843 
10844     if (CUR == 0) {
10845     xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
10846     }
10847 
10848     /*
10849      * Check for the XMLDecl in the Prolog.
10850      */
10851     GROW;
10852     if ((CMP5(CUR_PTR, &#39;&lt;&#39;, &#39;?&#39;, &#39;x&#39;, &#39;m&#39;, &#39;l&#39;)) &amp;&amp; (IS_BLANK_CH(NXT(5)))) {
10853 
10854     /*
10855      * Note that we will switch encoding on the fly.
10856      */
10857     xmlParseXMLDecl(ctxt);
10858     if (ctxt-&gt;errNo == XML_ERR_UNSUPPORTED_ENCODING) {
10859         /*
10860          * The XML REC instructs us to stop parsing right here
10861          */
10862         return(-1);
10863     }
10864     SKIP_BLANKS;
10865     } else {
10866     ctxt-&gt;version = xmlCharStrdup(XML_DEFAULT_VERSION);
10867     }
10868     if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;startDocument) &amp;&amp; (!ctxt-&gt;disableSAX))
10869         ctxt-&gt;sax-&gt;startDocument(ctxt-&gt;userData);
10870     if (ctxt-&gt;instate == XML_PARSER_EOF)
10871     return(-1);
10872 
10873     /*
10874      * Doing validity checking on chunk doesn&#39;t make sense
10875      */
10876     ctxt-&gt;instate = XML_PARSER_CONTENT;
10877     ctxt-&gt;validate = 0;
10878     ctxt-&gt;loadsubset = 0;
10879     ctxt-&gt;depth = 0;
10880 
10881     xmlParseContent(ctxt);
10882     if (ctxt-&gt;instate == XML_PARSER_EOF)
10883     return(-1);
10884 
10885     if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
10886     xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
10887     } else if (RAW != 0) {
10888     xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
10889     }
10890 
10891     /*
10892      * SAX: end of the document processing.
10893      */
10894     if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;endDocument != NULL))
10895         ctxt-&gt;sax-&gt;endDocument(ctxt-&gt;userData);
10896 
10897     if (! ctxt-&gt;wellFormed) return(-1);
10898     return(0);
10899 }
10900 
10901 #ifdef LIBXML_PUSH_ENABLED
10902 /************************************************************************
10903  *                                  *
10904  *      Progressive parsing interfaces              *
10905  *                                  *
10906  ************************************************************************/
10907 
10908 /**
10909  * xmlParseLookupSequence:
10910  * @ctxt:  an XML parser context
10911  * @first:  the first char to lookup
10912  * @next:  the next char to lookup or zero
10913  * @third:  the next char to lookup or zero
10914  *
10915  * Try to find if a sequence (first, next, third) or  just (first next) or
10916  * (first) is available in the input stream.
10917  * This function has a side effect of (possibly) incrementing ctxt-&gt;checkIndex
10918  * to avoid rescanning sequences of bytes, it DOES change the state of the
10919  * parser, do not use liberally.
10920  *
10921  * Returns the index to the current parsing point if the full sequence
10922  *      is available, -1 otherwise.
10923  */
10924 static int
10925 xmlParseLookupSequence(xmlParserCtxtPtr ctxt, xmlChar first,
10926                        xmlChar next, xmlChar third) {
10927     int base, len;
10928     xmlParserInputPtr in;
10929     const xmlChar *buf;
10930 
10931     in = ctxt-&gt;input;
10932     if (in == NULL) return(-1);
10933     base = in-&gt;cur - in-&gt;base;
10934     if (base &lt; 0) return(-1);
10935     if (ctxt-&gt;checkIndex &gt; base)
10936         base = ctxt-&gt;checkIndex;
10937     if (in-&gt;buf == NULL) {
10938     buf = in-&gt;base;
10939     len = in-&gt;length;
10940     } else {
10941     buf = xmlBufContent(in-&gt;buf-&gt;buffer);
10942     len = xmlBufUse(in-&gt;buf-&gt;buffer);
10943     }
10944     /* take into account the sequence length */
10945     if (third) len -= 2;
10946     else if (next) len --;
10947     for (;base &lt; len;base++) {
10948         if (buf[base] == first) {
10949         if (third != 0) {
10950         if ((buf[base + 1] != next) ||
10951             (buf[base + 2] != third)) continue;
10952         } else if (next != 0) {
10953         if (buf[base + 1] != next) continue;
10954         }
10955         ctxt-&gt;checkIndex = 0;
10956 #ifdef DEBUG_PUSH
10957         if (next == 0)
10958         xmlGenericError(xmlGenericErrorContext,
10959             &quot;PP: lookup &#39;%c&#39; found at %d\n&quot;,
10960             first, base);
10961         else if (third == 0)
10962         xmlGenericError(xmlGenericErrorContext,
10963             &quot;PP: lookup &#39;%c%c&#39; found at %d\n&quot;,
10964             first, next, base);
10965         else
10966         xmlGenericError(xmlGenericErrorContext,
10967             &quot;PP: lookup &#39;%c%c%c&#39; found at %d\n&quot;,
10968             first, next, third, base);
10969 #endif
10970         return(base - (in-&gt;cur - in-&gt;base));
10971     }
10972     }
10973     ctxt-&gt;checkIndex = base;
10974 #ifdef DEBUG_PUSH
10975     if (next == 0)
10976     xmlGenericError(xmlGenericErrorContext,
10977         &quot;PP: lookup &#39;%c&#39; failed\n&quot;, first);
10978     else if (third == 0)
10979     xmlGenericError(xmlGenericErrorContext,
10980         &quot;PP: lookup &#39;%c%c&#39; failed\n&quot;, first, next);
10981     else
10982     xmlGenericError(xmlGenericErrorContext,
10983         &quot;PP: lookup &#39;%c%c%c&#39; failed\n&quot;, first, next, third);
10984 #endif
10985     return(-1);
10986 }
10987 
10988 /**
10989  * xmlParseGetLasts:
10990  * @ctxt:  an XML parser context
10991  * @lastlt:  pointer to store the last &#39;&lt;&#39; from the input
10992  * @lastgt:  pointer to store the last &#39;&gt;&#39; from the input
10993  *
10994  * Lookup the last &lt; and &gt; in the current chunk
10995  */
10996 static void
10997 xmlParseGetLasts(xmlParserCtxtPtr ctxt, const xmlChar **lastlt,
10998                  const xmlChar **lastgt) {
10999     const xmlChar *tmp;
11000 
11001     if ((ctxt == NULL) || (lastlt == NULL) || (lastgt == NULL)) {
11002     xmlGenericError(xmlGenericErrorContext,
11003             &quot;Internal error: xmlParseGetLasts\n&quot;);
11004     return;
11005     }
11006     if ((ctxt-&gt;progressive != 0) &amp;&amp; (ctxt-&gt;inputNr == 1)) {
11007         tmp = ctxt-&gt;input-&gt;end;
11008     tmp--;
11009     while ((tmp &gt;= ctxt-&gt;input-&gt;base) &amp;&amp; (*tmp != &#39;&lt;&#39;)) tmp--;
11010     if (tmp &lt; ctxt-&gt;input-&gt;base) {
11011         *lastlt = NULL;
11012         *lastgt = NULL;
11013     } else {
11014         *lastlt = tmp;
11015         tmp++;
11016         while ((tmp &lt; ctxt-&gt;input-&gt;end) &amp;&amp; (*tmp != &#39;&gt;&#39;)) {
11017             if (*tmp == &#39;\&#39;&#39;) {
11018             tmp++;
11019             while ((tmp &lt; ctxt-&gt;input-&gt;end) &amp;&amp; (*tmp != &#39;\&#39;&#39;)) tmp++;
11020             if (tmp &lt; ctxt-&gt;input-&gt;end) tmp++;
11021         } else if (*tmp == &#39;&quot;&#39;) {
11022             tmp++;
11023             while ((tmp &lt; ctxt-&gt;input-&gt;end) &amp;&amp; (*tmp != &#39;&quot;&#39;)) tmp++;
11024             if (tmp &lt; ctxt-&gt;input-&gt;end) tmp++;
11025         } else
11026             tmp++;
11027         }
11028         if (tmp &lt; ctxt-&gt;input-&gt;end)
11029             *lastgt = tmp;
11030         else {
11031             tmp = *lastlt;
11032         tmp--;
11033         while ((tmp &gt;= ctxt-&gt;input-&gt;base) &amp;&amp; (*tmp != &#39;&gt;&#39;)) tmp--;
11034         if (tmp &gt;= ctxt-&gt;input-&gt;base)
11035             *lastgt = tmp;
11036         else
11037             *lastgt = NULL;
11038         }
11039     }
11040     } else {
11041         *lastlt = NULL;
11042     *lastgt = NULL;
11043     }
11044 }
11045 /**
11046  * xmlCheckCdataPush:
11047  * @cur: pointer to the block of characters
11048  * @len: length of the block in bytes
11049  * @complete: 1 if complete CDATA block is passed in, 0 if partial block
11050  *
11051  * Check that the block of characters is okay as SCdata content [20]
11052  *
11053  * Returns the number of bytes to pass if okay, a negative index where an
11054  *         UTF-8 error occurred otherwise
11055  */
11056 static int
11057 xmlCheckCdataPush(const xmlChar *utf, int len, int complete) {
11058     int ix;
11059     unsigned char c;
11060     int codepoint;
11061 
11062     if ((utf == NULL) || (len &lt;= 0))
11063         return(0);
11064 
11065     for (ix = 0; ix &lt; len;) {      /* string is 0-terminated */
11066         c = utf[ix];
11067         if ((c &amp; 0x80) == 0x00) {   /* 1-byte code, starts with 10 */
11068         if (c &gt;= 0x20)
11069         ix++;
11070         else if ((c == 0xA) || (c == 0xD) || (c == 0x9))
11071             ix++;
11072         else
11073             return(-ix);
11074     } else if ((c &amp; 0xe0) == 0xc0) {/* 2-byte code, starts with 110 */
11075         if (ix + 2 &gt; len) return(complete ? -ix : ix);
11076         if ((utf[ix+1] &amp; 0xc0 ) != 0x80)
11077             return(-ix);
11078         codepoint = (utf[ix] &amp; 0x1f) &lt;&lt; 6;
11079         codepoint |= utf[ix+1] &amp; 0x3f;
11080         if (!xmlIsCharQ(codepoint))
11081             return(-ix);
11082         ix += 2;
11083     } else if ((c &amp; 0xf0) == 0xe0) {/* 3-byte code, starts with 1110 */
11084         if (ix + 3 &gt; len) return(complete ? -ix : ix);
11085         if (((utf[ix+1] &amp; 0xc0) != 0x80) ||
11086             ((utf[ix+2] &amp; 0xc0) != 0x80))
11087             return(-ix);
11088         codepoint = (utf[ix] &amp; 0xf) &lt;&lt; 12;
11089         codepoint |= (utf[ix+1] &amp; 0x3f) &lt;&lt; 6;
11090         codepoint |= utf[ix+2] &amp; 0x3f;
11091         if (!xmlIsCharQ(codepoint))
11092             return(-ix);
11093         ix += 3;
11094     } else if ((c &amp; 0xf8) == 0xf0) {/* 4-byte code, starts with 11110 */
11095         if (ix + 4 &gt; len) return(complete ? -ix : ix);
11096         if (((utf[ix+1] &amp; 0xc0) != 0x80) ||
11097             ((utf[ix+2] &amp; 0xc0) != 0x80) ||
11098         ((utf[ix+3] &amp; 0xc0) != 0x80))
11099             return(-ix);
11100         codepoint = (utf[ix] &amp; 0x7) &lt;&lt; 18;
11101         codepoint |= (utf[ix+1] &amp; 0x3f) &lt;&lt; 12;
11102         codepoint |= (utf[ix+2] &amp; 0x3f) &lt;&lt; 6;
11103         codepoint |= utf[ix+3] &amp; 0x3f;
11104         if (!xmlIsCharQ(codepoint))
11105             return(-ix);
11106         ix += 4;
11107     } else              /* unknown encoding */
11108         return(-ix);
11109       }
11110       return(ix);
11111 }
11112 
11113 /**
11114  * xmlParseTryOrFinish:
11115  * @ctxt:  an XML parser context
11116  * @terminate:  last chunk indicator
11117  *
11118  * Try to progress on parsing
11119  *
11120  * Returns zero if no parsing was possible
11121  */
11122 static int
11123 xmlParseTryOrFinish(xmlParserCtxtPtr ctxt, int terminate) {
11124     int ret = 0;
11125     int avail, tlen;
11126     xmlChar cur, next;
11127     const xmlChar *lastlt, *lastgt;
11128 
11129     if (ctxt-&gt;input == NULL)
11130         return(0);
11131 
11132 #ifdef DEBUG_PUSH
11133     switch (ctxt-&gt;instate) {
11134     case XML_PARSER_EOF:
11135         xmlGenericError(xmlGenericErrorContext,
11136             &quot;PP: try EOF\n&quot;); break;
11137     case XML_PARSER_START:
11138         xmlGenericError(xmlGenericErrorContext,
11139             &quot;PP: try START\n&quot;); break;
11140     case XML_PARSER_MISC:
11141         xmlGenericError(xmlGenericErrorContext,
11142             &quot;PP: try MISC\n&quot;);break;
11143     case XML_PARSER_COMMENT:
11144         xmlGenericError(xmlGenericErrorContext,
11145             &quot;PP: try COMMENT\n&quot;);break;
11146     case XML_PARSER_PROLOG:
11147         xmlGenericError(xmlGenericErrorContext,
11148             &quot;PP: try PROLOG\n&quot;);break;
11149     case XML_PARSER_START_TAG:
11150         xmlGenericError(xmlGenericErrorContext,
11151             &quot;PP: try START_TAG\n&quot;);break;
11152     case XML_PARSER_CONTENT:
11153         xmlGenericError(xmlGenericErrorContext,
11154             &quot;PP: try CONTENT\n&quot;);break;
11155     case XML_PARSER_CDATA_SECTION:
11156         xmlGenericError(xmlGenericErrorContext,
11157             &quot;PP: try CDATA_SECTION\n&quot;);break;
11158     case XML_PARSER_END_TAG:
11159         xmlGenericError(xmlGenericErrorContext,
11160             &quot;PP: try END_TAG\n&quot;);break;
11161     case XML_PARSER_ENTITY_DECL:
11162         xmlGenericError(xmlGenericErrorContext,
11163             &quot;PP: try ENTITY_DECL\n&quot;);break;
11164     case XML_PARSER_ENTITY_VALUE:
11165         xmlGenericError(xmlGenericErrorContext,
11166             &quot;PP: try ENTITY_VALUE\n&quot;);break;
11167     case XML_PARSER_ATTRIBUTE_VALUE:
11168         xmlGenericError(xmlGenericErrorContext,
11169             &quot;PP: try ATTRIBUTE_VALUE\n&quot;);break;
11170     case XML_PARSER_DTD:
11171         xmlGenericError(xmlGenericErrorContext,
11172             &quot;PP: try DTD\n&quot;);break;
11173     case XML_PARSER_EPILOG:
11174         xmlGenericError(xmlGenericErrorContext,
11175             &quot;PP: try EPILOG\n&quot;);break;
11176     case XML_PARSER_PI:
11177         xmlGenericError(xmlGenericErrorContext,
11178             &quot;PP: try PI\n&quot;);break;
11179         case XML_PARSER_IGNORE:
11180             xmlGenericError(xmlGenericErrorContext,
11181             &quot;PP: try IGNORE\n&quot;);break;
11182     }
11183 #endif
11184 
11185     if ((ctxt-&gt;input != NULL) &amp;&amp;
11186         (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base &gt; 4096)) {
11187     xmlSHRINK(ctxt);
11188     ctxt-&gt;checkIndex = 0;
11189     }
11190     xmlParseGetLasts(ctxt, &amp;lastlt, &amp;lastgt);
11191 
11192     while (ctxt-&gt;instate != XML_PARSER_EOF) {
11193     if ((ctxt-&gt;errNo != XML_ERR_OK) &amp;&amp; (ctxt-&gt;disableSAX == 1))
11194         return(0);
11195 
11196     if (ctxt-&gt;input == NULL) break;
11197     if (ctxt-&gt;input-&gt;buf == NULL)
11198         avail = ctxt-&gt;input-&gt;length -
11199                 (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11200     else {
11201         /*
11202          * If we are operating on converted input, try to flush
<a name="99" id="anc99"></a><span class="line-modified">11203          * remaining chars to avoid them stalling in the non-converted</span>
11204          * buffer. But do not do this in document start where
11205          * encoding=&quot;...&quot; may not have been read and we work on a
11206          * guessed encoding.
11207          */
11208         if ((ctxt-&gt;instate != XML_PARSER_START) &amp;&amp;
11209             (ctxt-&gt;input-&gt;buf-&gt;raw != NULL) &amp;&amp;
11210         (xmlBufIsEmpty(ctxt-&gt;input-&gt;buf-&gt;raw) == 0)) {
11211                 size_t base = xmlBufGetInputBase(ctxt-&gt;input-&gt;buf-&gt;buffer,
11212                                                  ctxt-&gt;input);
11213         size_t current = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
11214 
11215         xmlParserInputBufferPush(ctxt-&gt;input-&gt;buf, 0, &quot;&quot;);
11216                 xmlBufSetInputBaseCur(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input,
11217                                       base, current);
11218         }
11219         avail = xmlBufUse(ctxt-&gt;input-&gt;buf-&gt;buffer) -
11220             (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11221     }
11222         if (avail &lt; 1)
11223         goto done;
11224         switch (ctxt-&gt;instate) {
11225             case XML_PARSER_EOF:
11226             /*
11227          * Document parsing is done !
11228          */
11229             goto done;
11230             case XML_PARSER_START:
11231         if (ctxt-&gt;charset == XML_CHAR_ENCODING_NONE) {
11232             xmlChar start[4];
11233             xmlCharEncoding enc;
11234 
11235             /*
11236              * Very first chars read from the document flow.
11237              */
11238             if (avail &lt; 4)
11239             goto done;
11240 
11241             /*
11242              * Get the 4 first bytes and decode the charset
11243              * if enc != XML_CHAR_ENCODING_NONE
11244              * plug some encoding conversion routines,
11245              * else xmlSwitchEncoding will set to (default)
11246              * UTF8.
11247              */
11248             start[0] = RAW;
11249             start[1] = NXT(1);
11250             start[2] = NXT(2);
11251             start[3] = NXT(3);
11252             enc = xmlDetectCharEncoding(start, 4);
11253             xmlSwitchEncoding(ctxt, enc);
11254             break;
11255         }
11256 
11257         if (avail &lt; 2)
11258             goto done;
11259         cur = ctxt-&gt;input-&gt;cur[0];
11260         next = ctxt-&gt;input-&gt;cur[1];
11261         if (cur == 0) {
11262             if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;setDocumentLocator))
11263             ctxt-&gt;sax-&gt;setDocumentLocator(ctxt-&gt;userData,
11264                               &amp;xmlDefaultSAXLocator);
11265             xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
11266             xmlHaltParser(ctxt);
11267 #ifdef DEBUG_PUSH
11268             xmlGenericError(xmlGenericErrorContext,
11269                 &quot;PP: entering EOF\n&quot;);
11270 #endif
11271             if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;endDocument != NULL))
11272             ctxt-&gt;sax-&gt;endDocument(ctxt-&gt;userData);
11273             goto done;
11274         }
11275             if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;?&#39;)) {
11276             /* PI or XML decl */
11277             if (avail &lt; 5) return(ret);
11278             if ((!terminate) &amp;&amp;
11279                 (xmlParseLookupSequence(ctxt, &#39;?&#39;, &#39;&gt;&#39;, 0) &lt; 0))
11280             return(ret);
11281             if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;setDocumentLocator))
11282             ctxt-&gt;sax-&gt;setDocumentLocator(ctxt-&gt;userData,
11283                               &amp;xmlDefaultSAXLocator);
11284             if ((ctxt-&gt;input-&gt;cur[2] == &#39;x&#39;) &amp;&amp;
11285             (ctxt-&gt;input-&gt;cur[3] == &#39;m&#39;) &amp;&amp;
11286             (ctxt-&gt;input-&gt;cur[4] == &#39;l&#39;) &amp;&amp;
11287             (IS_BLANK_CH(ctxt-&gt;input-&gt;cur[5]))) {
11288             ret += 5;
11289 #ifdef DEBUG_PUSH
11290             xmlGenericError(xmlGenericErrorContext,
11291                 &quot;PP: Parsing XML Decl\n&quot;);
11292 #endif
11293             xmlParseXMLDecl(ctxt);
11294             if (ctxt-&gt;errNo == XML_ERR_UNSUPPORTED_ENCODING) {
11295                 /*
11296                  * The XML REC instructs us to stop parsing right
11297                  * here
11298                  */
11299                 xmlHaltParser(ctxt);
11300                 return(0);
11301             }
11302             ctxt-&gt;standalone = ctxt-&gt;input-&gt;standalone;
11303             if ((ctxt-&gt;encoding == NULL) &amp;&amp;
11304                 (ctxt-&gt;input-&gt;encoding != NULL))
11305                 ctxt-&gt;encoding = xmlStrdup(ctxt-&gt;input-&gt;encoding);
11306             if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;startDocument) &amp;&amp;
11307                 (!ctxt-&gt;disableSAX))
11308                 ctxt-&gt;sax-&gt;startDocument(ctxt-&gt;userData);
11309             ctxt-&gt;instate = XML_PARSER_MISC;
11310 #ifdef DEBUG_PUSH
11311             xmlGenericError(xmlGenericErrorContext,
11312                 &quot;PP: entering MISC\n&quot;);
11313 #endif
11314             } else {
11315             ctxt-&gt;version = xmlCharStrdup(XML_DEFAULT_VERSION);
11316             if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;startDocument) &amp;&amp;
11317                 (!ctxt-&gt;disableSAX))
11318                 ctxt-&gt;sax-&gt;startDocument(ctxt-&gt;userData);
11319             ctxt-&gt;instate = XML_PARSER_MISC;
11320 #ifdef DEBUG_PUSH
11321             xmlGenericError(xmlGenericErrorContext,
11322                 &quot;PP: entering MISC\n&quot;);
11323 #endif
11324             }
11325         } else {
11326             if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;setDocumentLocator))
11327             ctxt-&gt;sax-&gt;setDocumentLocator(ctxt-&gt;userData,
11328                               &amp;xmlDefaultSAXLocator);
11329             ctxt-&gt;version = xmlCharStrdup(XML_DEFAULT_VERSION);
11330             if (ctxt-&gt;version == NULL) {
11331                 xmlErrMemory(ctxt, NULL);
11332             break;
11333             }
11334             if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;startDocument) &amp;&amp;
11335                 (!ctxt-&gt;disableSAX))
11336             ctxt-&gt;sax-&gt;startDocument(ctxt-&gt;userData);
11337             ctxt-&gt;instate = XML_PARSER_MISC;
11338 #ifdef DEBUG_PUSH
11339             xmlGenericError(xmlGenericErrorContext,
11340                 &quot;PP: entering MISC\n&quot;);
11341 #endif
11342         }
11343         break;
11344             case XML_PARSER_START_TAG: {
11345             const xmlChar *name;
11346         const xmlChar *prefix = NULL;
11347         const xmlChar *URI = NULL;
11348         int nsNr = ctxt-&gt;nsNr;
11349 
11350         if ((avail &lt; 2) &amp;&amp; (ctxt-&gt;inputNr == 1))
11351             goto done;
11352         cur = ctxt-&gt;input-&gt;cur[0];
11353             if (cur != &#39;&lt;&#39;) {
11354             xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
11355             xmlHaltParser(ctxt);
11356             if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;endDocument != NULL))
11357             ctxt-&gt;sax-&gt;endDocument(ctxt-&gt;userData);
11358             goto done;
11359         }
11360         if (!terminate) {
11361             if (ctxt-&gt;progressive) {
11362                 /* &gt; can be found unescaped in attribute values */
11363                 if ((lastgt == NULL) || (ctxt-&gt;input-&gt;cur &gt;= lastgt))
11364                 goto done;
11365             } else if (xmlParseLookupSequence(ctxt, &#39;&gt;&#39;, 0, 0) &lt; 0) {
11366             goto done;
11367             }
11368         }
11369         if (ctxt-&gt;spaceNr == 0)
11370             spacePush(ctxt, -1);
11371         else if (*ctxt-&gt;space == -2)
11372             spacePush(ctxt, -1);
11373         else
11374             spacePush(ctxt, *ctxt-&gt;space);
11375 #ifdef LIBXML_SAX1_ENABLED
11376         if (ctxt-&gt;sax2)
11377 #endif /* LIBXML_SAX1_ENABLED */
11378             name = xmlParseStartTag2(ctxt, &amp;prefix, &amp;URI, &amp;tlen);
11379 #ifdef LIBXML_SAX1_ENABLED
11380         else
11381             name = xmlParseStartTag(ctxt);
11382 #endif /* LIBXML_SAX1_ENABLED */
11383         if (ctxt-&gt;instate == XML_PARSER_EOF)
11384             goto done;
11385         if (name == NULL) {
11386             spacePop(ctxt);
11387             xmlHaltParser(ctxt);
11388             if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;endDocument != NULL))
11389             ctxt-&gt;sax-&gt;endDocument(ctxt-&gt;userData);
11390             goto done;
11391         }
11392 #ifdef LIBXML_VALID_ENABLED
11393         /*
11394          * [ VC: Root Element Type ]
11395          * The Name in the document type declaration must match
11396          * the element type of the root element.
11397          */
11398         if (ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp; ctxt-&gt;myDoc &amp;&amp;
11399             ctxt-&gt;node &amp;&amp; (ctxt-&gt;node == ctxt-&gt;myDoc-&gt;children))
11400             ctxt-&gt;valid &amp;= xmlValidateRoot(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc);
11401 #endif /* LIBXML_VALID_ENABLED */
11402 
11403         /*
11404          * Check for an Empty Element.
11405          */
11406         if ((RAW == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;)) {
11407             SKIP(2);
11408 
11409             if (ctxt-&gt;sax2) {
11410             if ((ctxt-&gt;sax != NULL) &amp;&amp;
11411                 (ctxt-&gt;sax-&gt;endElementNs != NULL) &amp;&amp;
11412                 (!ctxt-&gt;disableSAX))
11413                 ctxt-&gt;sax-&gt;endElementNs(ctxt-&gt;userData, name,
11414                                         prefix, URI);
11415             if (ctxt-&gt;nsNr - nsNr &gt; 0)
11416                 nsPop(ctxt, ctxt-&gt;nsNr - nsNr);
11417 #ifdef LIBXML_SAX1_ENABLED
11418             } else {
11419             if ((ctxt-&gt;sax != NULL) &amp;&amp;
11420                 (ctxt-&gt;sax-&gt;endElement != NULL) &amp;&amp;
11421                 (!ctxt-&gt;disableSAX))
11422                 ctxt-&gt;sax-&gt;endElement(ctxt-&gt;userData, name);
11423 #endif /* LIBXML_SAX1_ENABLED */
11424             }
11425             if (ctxt-&gt;instate == XML_PARSER_EOF)
11426             goto done;
11427             spacePop(ctxt);
11428             if (ctxt-&gt;nameNr == 0) {
11429             ctxt-&gt;instate = XML_PARSER_EPILOG;
11430             } else {
11431             ctxt-&gt;instate = XML_PARSER_CONTENT;
11432             }
11433                     ctxt-&gt;progressive = 1;
11434             break;
11435         }
11436         if (RAW == &#39;&gt;&#39;) {
11437             NEXT;
11438         } else {
11439             xmlFatalErrMsgStr(ctxt, XML_ERR_GT_REQUIRED,
11440                      &quot;Couldn&#39;t find end of Start Tag %s\n&quot;,
11441                      name);
11442             nodePop(ctxt);
11443             spacePop(ctxt);
11444         }
11445         if (ctxt-&gt;sax2)
11446             nameNsPush(ctxt, name, prefix, URI, ctxt-&gt;nsNr - nsNr);
11447 #ifdef LIBXML_SAX1_ENABLED
11448         else
11449             namePush(ctxt, name);
11450 #endif /* LIBXML_SAX1_ENABLED */
11451 
11452         ctxt-&gt;instate = XML_PARSER_CONTENT;
11453                 ctxt-&gt;progressive = 1;
11454                 break;
11455         }
11456             case XML_PARSER_CONTENT: {
11457         const xmlChar *test;
11458         unsigned int cons;
11459         if ((avail &lt; 2) &amp;&amp; (ctxt-&gt;inputNr == 1))
11460             goto done;
11461         cur = ctxt-&gt;input-&gt;cur[0];
11462         next = ctxt-&gt;input-&gt;cur[1];
11463 
11464         test = CUR_PTR;
11465             cons = ctxt-&gt;input-&gt;consumed;
11466         if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;/&#39;)) {
11467             ctxt-&gt;instate = XML_PARSER_END_TAG;
11468             break;
11469             } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;?&#39;)) {
11470             if ((!terminate) &amp;&amp;
11471                 (xmlParseLookupSequence(ctxt, &#39;?&#39;, &#39;&gt;&#39;, 0) &lt; 0)) {
11472                         ctxt-&gt;progressive = XML_PARSER_PI;
11473             goto done;
11474                     }
11475             xmlParsePI(ctxt);
11476             ctxt-&gt;instate = XML_PARSER_CONTENT;
11477                     ctxt-&gt;progressive = 1;
11478         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next != &#39;!&#39;)) {
11479             ctxt-&gt;instate = XML_PARSER_START_TAG;
11480             break;
11481         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
11482                    (ctxt-&gt;input-&gt;cur[2] == &#39;-&#39;) &amp;&amp;
11483                (ctxt-&gt;input-&gt;cur[3] == &#39;-&#39;)) {
11484             int term;
11485 
11486                 if (avail &lt; 4)
11487                 goto done;
11488             ctxt-&gt;input-&gt;cur += 4;
11489             term = xmlParseLookupSequence(ctxt, &#39;-&#39;, &#39;-&#39;, &#39;&gt;&#39;);
11490             ctxt-&gt;input-&gt;cur -= 4;
11491             if ((!terminate) &amp;&amp; (term &lt; 0)) {
11492                         ctxt-&gt;progressive = XML_PARSER_COMMENT;
11493             goto done;
11494                     }
11495             xmlParseComment(ctxt);
11496             ctxt-&gt;instate = XML_PARSER_CONTENT;
11497                     ctxt-&gt;progressive = 1;
11498         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (ctxt-&gt;input-&gt;cur[1] == &#39;!&#39;) &amp;&amp;
11499             (ctxt-&gt;input-&gt;cur[2] == &#39;[&#39;) &amp;&amp;
11500             (ctxt-&gt;input-&gt;cur[3] == &#39;C&#39;) &amp;&amp;
11501             (ctxt-&gt;input-&gt;cur[4] == &#39;D&#39;) &amp;&amp;
11502             (ctxt-&gt;input-&gt;cur[5] == &#39;A&#39;) &amp;&amp;
11503             (ctxt-&gt;input-&gt;cur[6] == &#39;T&#39;) &amp;&amp;
11504             (ctxt-&gt;input-&gt;cur[7] == &#39;A&#39;) &amp;&amp;
11505             (ctxt-&gt;input-&gt;cur[8] == &#39;[&#39;)) {
11506             SKIP(9);
11507             ctxt-&gt;instate = XML_PARSER_CDATA_SECTION;
11508             break;
11509         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
11510                    (avail &lt; 9)) {
11511             goto done;
11512         } else if (cur == &#39;&amp;&#39;) {
11513             if ((!terminate) &amp;&amp;
11514                 (xmlParseLookupSequence(ctxt, &#39;;&#39;, 0, 0) &lt; 0))
11515             goto done;
11516             xmlParseReference(ctxt);
11517         } else {
11518             /* TODO Avoid the extra copy, handle directly !!! */
11519             /*
11520              * Goal of the following test is:
11521              *  - minimize calls to the SAX &#39;character&#39; callback
11522              *    when they are mergeable
11523              *  - handle an problem for isBlank when we only parse
11524              *    a sequence of blank chars and the next one is
11525              *    not available to check against &#39;&lt;&#39; presence.
11526              *  - tries to homogenize the differences in SAX
11527              *    callbacks between the push and pull versions
11528              *    of the parser.
11529              */
11530             if ((ctxt-&gt;inputNr == 1) &amp;&amp;
11531                 (avail &lt; XML_PARSER_BIG_BUFFER_SIZE)) {
11532             if (!terminate) {
11533                 if (ctxt-&gt;progressive) {
11534                 if ((lastlt == NULL) ||
11535                     (ctxt-&gt;input-&gt;cur &gt; lastlt))
11536                     goto done;
11537                 } else if (xmlParseLookupSequence(ctxt,
11538                                                   &#39;&lt;&#39;, 0, 0) &lt; 0) {
11539                 goto done;
11540                 }
11541             }
11542                     }
11543             ctxt-&gt;checkIndex = 0;
11544             xmlParseCharData(ctxt, 0);
11545         }
11546         if ((cons == ctxt-&gt;input-&gt;consumed) &amp;&amp; (test == CUR_PTR)) {
11547             xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
11548                         &quot;detected an error in element content\n&quot;);
11549             xmlHaltParser(ctxt);
11550             break;
11551         }
11552         break;
11553         }
11554             case XML_PARSER_END_TAG:
11555         if (avail &lt; 2)
11556             goto done;
11557         if (!terminate) {
11558             if (ctxt-&gt;progressive) {
11559                 /* &gt; can be found unescaped in attribute values */
11560                 if ((lastgt == NULL) || (ctxt-&gt;input-&gt;cur &gt;= lastgt))
11561                 goto done;
11562             } else if (xmlParseLookupSequence(ctxt, &#39;&gt;&#39;, 0, 0) &lt; 0) {
11563             goto done;
11564             }
11565         }
11566         if (ctxt-&gt;sax2) {
11567             xmlParseEndTag2(ctxt,
11568                     (void *) ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 - 3],
11569                     (void *) ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 - 2], 0,
11570                     (int) (ptrdiff_t)
11571                                 ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 - 1], 0);
11572             nameNsPop(ctxt);
11573         }
11574 #ifdef LIBXML_SAX1_ENABLED
11575           else
11576             xmlParseEndTag1(ctxt, 0);
11577 #endif /* LIBXML_SAX1_ENABLED */
11578         if (ctxt-&gt;instate == XML_PARSER_EOF) {
11579             /* Nothing */
11580         } else if (ctxt-&gt;nameNr == 0) {
11581             ctxt-&gt;instate = XML_PARSER_EPILOG;
11582         } else {
11583             ctxt-&gt;instate = XML_PARSER_CONTENT;
11584         }
11585         break;
11586             case XML_PARSER_CDATA_SECTION: {
11587             /*
11588          * The Push mode need to have the SAX callback for
11589          * cdataBlock merge back contiguous callbacks.
11590          */
11591         int base;
11592 
11593         base = xmlParseLookupSequence(ctxt, &#39;]&#39;, &#39;]&#39;, &#39;&gt;&#39;);
11594         if (base &lt; 0) {
11595             if (avail &gt;= XML_PARSER_BIG_BUFFER_SIZE + 2) {
11596                 int tmp;
11597 
11598             tmp = xmlCheckCdataPush(ctxt-&gt;input-&gt;cur,
11599                                     XML_PARSER_BIG_BUFFER_SIZE, 0);
11600             if (tmp &lt; 0) {
11601                 tmp = -tmp;
11602                 ctxt-&gt;input-&gt;cur += tmp;
11603                 goto encoding_error;
11604             }
11605             if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX)) {
11606                 if (ctxt-&gt;sax-&gt;cdataBlock != NULL)
11607                 ctxt-&gt;sax-&gt;cdataBlock(ctxt-&gt;userData,
11608                                       ctxt-&gt;input-&gt;cur, tmp);
11609                 else if (ctxt-&gt;sax-&gt;characters != NULL)
11610                 ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData,
11611                                       ctxt-&gt;input-&gt;cur, tmp);
11612             }
11613             if (ctxt-&gt;instate == XML_PARSER_EOF)
11614                 goto done;
11615             SKIPL(tmp);
11616             ctxt-&gt;checkIndex = 0;
11617             }
11618             goto done;
11619         } else {
11620             int tmp;
11621 
11622             tmp = xmlCheckCdataPush(ctxt-&gt;input-&gt;cur, base, 1);
11623             if ((tmp &lt; 0) || (tmp != base)) {
11624             tmp = -tmp;
11625             ctxt-&gt;input-&gt;cur += tmp;
11626             goto encoding_error;
11627             }
11628             if ((ctxt-&gt;sax != NULL) &amp;&amp; (base == 0) &amp;&amp;
11629                 (ctxt-&gt;sax-&gt;cdataBlock != NULL) &amp;&amp;
11630                 (!ctxt-&gt;disableSAX)) {
11631             /*
11632              * Special case to provide identical behaviour
11633              * between pull and push parsers on enpty CDATA
11634              * sections
11635              */
11636              if ((ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base &gt;= 9) &amp;&amp;
11637                  (!strncmp((const char *)&amp;ctxt-&gt;input-&gt;cur[-9],
11638                            &quot;&lt;![CDATA[&quot;, 9)))
11639                  ctxt-&gt;sax-&gt;cdataBlock(ctxt-&gt;userData,
11640                                        BAD_CAST &quot;&quot;, 0);
11641             } else if ((ctxt-&gt;sax != NULL) &amp;&amp; (base &gt; 0) &amp;&amp;
11642             (!ctxt-&gt;disableSAX)) {
11643             if (ctxt-&gt;sax-&gt;cdataBlock != NULL)
11644                 ctxt-&gt;sax-&gt;cdataBlock(ctxt-&gt;userData,
11645                           ctxt-&gt;input-&gt;cur, base);
11646             else if (ctxt-&gt;sax-&gt;characters != NULL)
11647                 ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData,
11648                           ctxt-&gt;input-&gt;cur, base);
11649             }
11650             if (ctxt-&gt;instate == XML_PARSER_EOF)
11651             goto done;
11652             SKIPL(base + 3);
11653             ctxt-&gt;checkIndex = 0;
11654             ctxt-&gt;instate = XML_PARSER_CONTENT;
11655 #ifdef DEBUG_PUSH
11656             xmlGenericError(xmlGenericErrorContext,
11657                 &quot;PP: entering CONTENT\n&quot;);
11658 #endif
11659         }
11660         break;
11661         }
11662             case XML_PARSER_MISC:
11663         SKIP_BLANKS;
11664         if (ctxt-&gt;input-&gt;buf == NULL)
11665             avail = ctxt-&gt;input-&gt;length -
11666                     (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11667         else
11668             avail = xmlBufUse(ctxt-&gt;input-&gt;buf-&gt;buffer) -
11669                     (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11670         if (avail &lt; 2)
11671             goto done;
11672         cur = ctxt-&gt;input-&gt;cur[0];
11673         next = ctxt-&gt;input-&gt;cur[1];
11674             if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;?&#39;)) {
11675             if ((!terminate) &amp;&amp;
11676                 (xmlParseLookupSequence(ctxt, &#39;?&#39;, &#39;&gt;&#39;, 0) &lt; 0)) {
11677                         ctxt-&gt;progressive = XML_PARSER_PI;
11678             goto done;
11679                     }
11680 #ifdef DEBUG_PUSH
11681             xmlGenericError(xmlGenericErrorContext,
11682                 &quot;PP: Parsing PI\n&quot;);
11683 #endif
11684             xmlParsePI(ctxt);
11685             if (ctxt-&gt;instate == XML_PARSER_EOF)
11686             goto done;
11687             ctxt-&gt;instate = XML_PARSER_MISC;
11688                     ctxt-&gt;progressive = 1;
11689             ctxt-&gt;checkIndex = 0;
11690         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
11691             (ctxt-&gt;input-&gt;cur[2] == &#39;-&#39;) &amp;&amp;
11692             (ctxt-&gt;input-&gt;cur[3] == &#39;-&#39;)) {
11693             if ((!terminate) &amp;&amp;
11694                 (xmlParseLookupSequence(ctxt, &#39;-&#39;, &#39;-&#39;, &#39;&gt;&#39;) &lt; 0)) {
11695                         ctxt-&gt;progressive = XML_PARSER_COMMENT;
11696             goto done;
11697                     }
11698 #ifdef DEBUG_PUSH
11699             xmlGenericError(xmlGenericErrorContext,
11700                 &quot;PP: Parsing Comment\n&quot;);
11701 #endif
11702             xmlParseComment(ctxt);
11703             if (ctxt-&gt;instate == XML_PARSER_EOF)
11704             goto done;
11705             ctxt-&gt;instate = XML_PARSER_MISC;
11706                     ctxt-&gt;progressive = 1;
11707             ctxt-&gt;checkIndex = 0;
11708         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
11709             (ctxt-&gt;input-&gt;cur[2] == &#39;D&#39;) &amp;&amp;
11710             (ctxt-&gt;input-&gt;cur[3] == &#39;O&#39;) &amp;&amp;
11711             (ctxt-&gt;input-&gt;cur[4] == &#39;C&#39;) &amp;&amp;
11712             (ctxt-&gt;input-&gt;cur[5] == &#39;T&#39;) &amp;&amp;
11713             (ctxt-&gt;input-&gt;cur[6] == &#39;Y&#39;) &amp;&amp;
11714             (ctxt-&gt;input-&gt;cur[7] == &#39;P&#39;) &amp;&amp;
11715             (ctxt-&gt;input-&gt;cur[8] == &#39;E&#39;)) {
11716             if ((!terminate) &amp;&amp;
11717                 (xmlParseLookupSequence(ctxt, &#39;&gt;&#39;, 0, 0) &lt; 0)) {
11718                         ctxt-&gt;progressive = XML_PARSER_DTD;
11719             goto done;
11720                     }
11721 #ifdef DEBUG_PUSH
11722             xmlGenericError(xmlGenericErrorContext,
11723                 &quot;PP: Parsing internal subset\n&quot;);
11724 #endif
11725             ctxt-&gt;inSubset = 1;
11726                     ctxt-&gt;progressive = 0;
11727             ctxt-&gt;checkIndex = 0;
11728             xmlParseDocTypeDecl(ctxt);
11729             if (ctxt-&gt;instate == XML_PARSER_EOF)
11730             goto done;
11731             if (RAW == &#39;[&#39;) {
11732             ctxt-&gt;instate = XML_PARSER_DTD;
11733 #ifdef DEBUG_PUSH
11734             xmlGenericError(xmlGenericErrorContext,
11735                 &quot;PP: entering DTD\n&quot;);
11736 #endif
11737             } else {
11738             /*
11739              * Create and update the external subset.
11740              */
11741             ctxt-&gt;inSubset = 2;
11742             if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX) &amp;&amp;
11743                 (ctxt-&gt;sax-&gt;externalSubset != NULL))
11744                 ctxt-&gt;sax-&gt;externalSubset(ctxt-&gt;userData,
11745                     ctxt-&gt;intSubName, ctxt-&gt;extSubSystem,
11746                     ctxt-&gt;extSubURI);
11747             ctxt-&gt;inSubset = 0;
11748             xmlCleanSpecialAttr(ctxt);
11749             ctxt-&gt;instate = XML_PARSER_PROLOG;
11750 #ifdef DEBUG_PUSH
11751             xmlGenericError(xmlGenericErrorContext,
11752                 &quot;PP: entering PROLOG\n&quot;);
11753 #endif
11754             }
11755         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
11756                    (avail &lt; 9)) {
11757             goto done;
11758         } else {
11759             ctxt-&gt;instate = XML_PARSER_START_TAG;
11760             ctxt-&gt;progressive = XML_PARSER_START_TAG;
11761             xmlParseGetLasts(ctxt, &amp;lastlt, &amp;lastgt);
11762 #ifdef DEBUG_PUSH
11763             xmlGenericError(xmlGenericErrorContext,
11764                 &quot;PP: entering START_TAG\n&quot;);
11765 #endif
11766         }
11767         break;
11768             case XML_PARSER_PROLOG:
11769         SKIP_BLANKS;
11770         if (ctxt-&gt;input-&gt;buf == NULL)
11771             avail = ctxt-&gt;input-&gt;length - (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11772         else
11773             avail = xmlBufUse(ctxt-&gt;input-&gt;buf-&gt;buffer) -
11774                             (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11775         if (avail &lt; 2)
11776             goto done;
11777         cur = ctxt-&gt;input-&gt;cur[0];
11778         next = ctxt-&gt;input-&gt;cur[1];
11779             if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;?&#39;)) {
11780             if ((!terminate) &amp;&amp;
11781                 (xmlParseLookupSequence(ctxt, &#39;?&#39;, &#39;&gt;&#39;, 0) &lt; 0)) {
11782                         ctxt-&gt;progressive = XML_PARSER_PI;
11783             goto done;
11784                     }
11785 #ifdef DEBUG_PUSH
11786             xmlGenericError(xmlGenericErrorContext,
11787                 &quot;PP: Parsing PI\n&quot;);
11788 #endif
11789             xmlParsePI(ctxt);
11790             if (ctxt-&gt;instate == XML_PARSER_EOF)
11791             goto done;
11792             ctxt-&gt;instate = XML_PARSER_PROLOG;
11793                     ctxt-&gt;progressive = 1;
11794         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
11795             (ctxt-&gt;input-&gt;cur[2] == &#39;-&#39;) &amp;&amp; (ctxt-&gt;input-&gt;cur[3] == &#39;-&#39;)) {
11796             if ((!terminate) &amp;&amp;
11797                 (xmlParseLookupSequence(ctxt, &#39;-&#39;, &#39;-&#39;, &#39;&gt;&#39;) &lt; 0)) {
11798                         ctxt-&gt;progressive = XML_PARSER_COMMENT;
11799             goto done;
11800                     }
11801 #ifdef DEBUG_PUSH
11802             xmlGenericError(xmlGenericErrorContext,
11803                 &quot;PP: Parsing Comment\n&quot;);
11804 #endif
11805             xmlParseComment(ctxt);
11806             if (ctxt-&gt;instate == XML_PARSER_EOF)
11807             goto done;
11808             ctxt-&gt;instate = XML_PARSER_PROLOG;
11809                     ctxt-&gt;progressive = 1;
11810         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
11811                    (avail &lt; 4)) {
11812             goto done;
11813         } else {
11814             ctxt-&gt;instate = XML_PARSER_START_TAG;
11815             if (ctxt-&gt;progressive == 0)
11816             ctxt-&gt;progressive = XML_PARSER_START_TAG;
11817             xmlParseGetLasts(ctxt, &amp;lastlt, &amp;lastgt);
11818 #ifdef DEBUG_PUSH
11819             xmlGenericError(xmlGenericErrorContext,
11820                 &quot;PP: entering START_TAG\n&quot;);
11821 #endif
11822         }
11823         break;
11824             case XML_PARSER_EPILOG:
11825         SKIP_BLANKS;
11826         if (ctxt-&gt;input-&gt;buf == NULL)
11827             avail = ctxt-&gt;input-&gt;length - (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11828         else
11829             avail = xmlBufUse(ctxt-&gt;input-&gt;buf-&gt;buffer) -
11830                             (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11831         if (avail &lt; 2)
11832             goto done;
11833         cur = ctxt-&gt;input-&gt;cur[0];
11834         next = ctxt-&gt;input-&gt;cur[1];
11835             if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;?&#39;)) {
11836             if ((!terminate) &amp;&amp;
11837                 (xmlParseLookupSequence(ctxt, &#39;?&#39;, &#39;&gt;&#39;, 0) &lt; 0)) {
11838                         ctxt-&gt;progressive = XML_PARSER_PI;
11839             goto done;
11840                     }
11841 #ifdef DEBUG_PUSH
11842             xmlGenericError(xmlGenericErrorContext,
11843                 &quot;PP: Parsing PI\n&quot;);
11844 #endif
11845             xmlParsePI(ctxt);
11846             if (ctxt-&gt;instate == XML_PARSER_EOF)
11847             goto done;
11848             ctxt-&gt;instate = XML_PARSER_EPILOG;
11849                     ctxt-&gt;progressive = 1;
11850         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
11851             (ctxt-&gt;input-&gt;cur[2] == &#39;-&#39;) &amp;&amp; (ctxt-&gt;input-&gt;cur[3] == &#39;-&#39;)) {
11852             if ((!terminate) &amp;&amp;
11853                 (xmlParseLookupSequence(ctxt, &#39;-&#39;, &#39;-&#39;, &#39;&gt;&#39;) &lt; 0)) {
11854                         ctxt-&gt;progressive = XML_PARSER_COMMENT;
11855             goto done;
11856                     }
11857 #ifdef DEBUG_PUSH
11858             xmlGenericError(xmlGenericErrorContext,
11859                 &quot;PP: Parsing Comment\n&quot;);
11860 #endif
11861             xmlParseComment(ctxt);
11862             if (ctxt-&gt;instate == XML_PARSER_EOF)
11863             goto done;
11864             ctxt-&gt;instate = XML_PARSER_EPILOG;
11865                     ctxt-&gt;progressive = 1;
11866         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
11867                    (avail &lt; 4)) {
11868             goto done;
11869         } else {
11870             xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);
11871             xmlHaltParser(ctxt);
11872 #ifdef DEBUG_PUSH
11873             xmlGenericError(xmlGenericErrorContext,
11874                 &quot;PP: entering EOF\n&quot;);
11875 #endif
11876             if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;endDocument != NULL))
11877             ctxt-&gt;sax-&gt;endDocument(ctxt-&gt;userData);
11878             goto done;
11879         }
11880         break;
11881             case XML_PARSER_DTD: {
11882             /*
11883          * Sorry but progressive parsing of the internal subset
11884          * is not expected to be supported. We first check that
11885          * the full content of the internal subset is available and
11886          * the parsing is launched only at that point.
11887          * Internal subset ends up with &quot;&#39;]&#39; S? &#39;&gt;&#39;&quot; in an unescaped
11888          * section and not in a &#39;]]&gt;&#39; sequence which are conditional
11889          * sections (whoever argued to keep that crap in XML deserve
11890          * a place in hell !).
11891          */
11892         int base, i;
11893         xmlChar *buf;
11894             xmlChar quote = 0;
11895                 size_t use;
11896 
11897         base = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
11898         if (base &lt; 0) return(0);
11899         if (ctxt-&gt;checkIndex &gt; base)
11900             base = ctxt-&gt;checkIndex;
11901         buf = xmlBufContent(ctxt-&gt;input-&gt;buf-&gt;buffer);
11902                 use = xmlBufUse(ctxt-&gt;input-&gt;buf-&gt;buffer);
11903         for (;(unsigned int) base &lt; use; base++) {
11904             if (quote != 0) {
11905                 if (buf[base] == quote)
11906                 quote = 0;
11907             continue;
11908             }
11909             if ((quote == 0) &amp;&amp; (buf[base] == &#39;&lt;&#39;)) {
11910                 int found  = 0;
11911             /* special handling of comments */
11912                 if (((unsigned int) base + 4 &lt; use) &amp;&amp;
11913                 (buf[base + 1] == &#39;!&#39;) &amp;&amp;
11914                 (buf[base + 2] == &#39;-&#39;) &amp;&amp;
11915                 (buf[base + 3] == &#39;-&#39;)) {
11916                 for (;(unsigned int) base + 3 &lt; use; base++) {
11917                 if ((buf[base] == &#39;-&#39;) &amp;&amp;
11918                     (buf[base + 1] == &#39;-&#39;) &amp;&amp;
11919                     (buf[base + 2] == &#39;&gt;&#39;)) {
11920                     found = 1;
11921                     base += 2;
11922                     break;
11923                 }
11924                     }
11925                 if (!found) {
11926 #if 0
11927                     fprintf(stderr, &quot;unfinished comment\n&quot;);
11928 #endif
11929                     break; /* for */
11930                     }
11931                     continue;
11932             }
11933             }
11934             if (buf[base] == &#39;&quot;&#39;) {
11935                 quote = &#39;&quot;&#39;;
11936             continue;
11937             }
11938             if (buf[base] == &#39;\&#39;&#39;) {
11939                 quote = &#39;\&#39;&#39;;
11940             continue;
11941             }
11942             if (buf[base] == &#39;]&#39;) {
11943 #if 0
11944                 fprintf(stderr, &quot;%c%c%c%c: &quot;, buf[base],
11945                     buf[base + 1], buf[base + 2], buf[base + 3]);
11946 #endif
11947                 if ((unsigned int) base +1 &gt;= use)
11948                 break;
11949             if (buf[base + 1] == &#39;]&#39;) {
11950                 /* conditional crap, skip both &#39;]&#39; ! */
11951                 base++;
11952                 continue;
11953             }
11954                 for (i = 1; (unsigned int) base + i &lt; use; i++) {
11955                 if (buf[base + i] == &#39;&gt;&#39;) {
11956 #if 0
11957                     fprintf(stderr, &quot;found\n&quot;);
11958 #endif
11959                     goto found_end_int_subset;
11960                 }
11961                 if (!IS_BLANK_CH(buf[base + i])) {
11962 #if 0
11963                     fprintf(stderr, &quot;not found\n&quot;);
11964 #endif
11965                     goto not_end_of_int_subset;
11966                 }
11967             }
11968 #if 0
11969             fprintf(stderr, &quot;end of stream\n&quot;);
11970 #endif
11971                 break;
11972 
11973             }
11974 not_end_of_int_subset:
11975                     continue; /* for */
11976         }
11977         /*
11978          * We didn&#39;t found the end of the Internal subset
11979          */
11980                 if (quote == 0)
11981                     ctxt-&gt;checkIndex = base;
11982                 else
11983                     ctxt-&gt;checkIndex = 0;
11984 #ifdef DEBUG_PUSH
11985         if (next == 0)
11986             xmlGenericError(xmlGenericErrorContext,
11987                 &quot;PP: lookup of int subset end filed\n&quot;);
11988 #endif
11989             goto done;
11990 
11991 found_end_int_subset:
11992                 ctxt-&gt;checkIndex = 0;
11993         xmlParseInternalSubset(ctxt);
11994         if (ctxt-&gt;instate == XML_PARSER_EOF)
11995             goto done;
11996         ctxt-&gt;inSubset = 2;
11997         if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX) &amp;&amp;
11998             (ctxt-&gt;sax-&gt;externalSubset != NULL))
11999             ctxt-&gt;sax-&gt;externalSubset(ctxt-&gt;userData, ctxt-&gt;intSubName,
12000                 ctxt-&gt;extSubSystem, ctxt-&gt;extSubURI);
12001         ctxt-&gt;inSubset = 0;
12002         xmlCleanSpecialAttr(ctxt);
12003         if (ctxt-&gt;instate == XML_PARSER_EOF)
12004             goto done;
12005         ctxt-&gt;instate = XML_PARSER_PROLOG;
12006         ctxt-&gt;checkIndex = 0;
12007 #ifdef DEBUG_PUSH
12008         xmlGenericError(xmlGenericErrorContext,
12009             &quot;PP: entering PROLOG\n&quot;);
12010 #endif
12011                 break;
12012         }
12013             case XML_PARSER_COMMENT:
12014         xmlGenericError(xmlGenericErrorContext,
12015             &quot;PP: internal error, state == COMMENT\n&quot;);
12016         ctxt-&gt;instate = XML_PARSER_CONTENT;
12017 #ifdef DEBUG_PUSH
12018         xmlGenericError(xmlGenericErrorContext,
12019             &quot;PP: entering CONTENT\n&quot;);
12020 #endif
12021         break;
12022             case XML_PARSER_IGNORE:
12023         xmlGenericError(xmlGenericErrorContext,
12024             &quot;PP: internal error, state == IGNORE&quot;);
12025             ctxt-&gt;instate = XML_PARSER_DTD;
12026 #ifdef DEBUG_PUSH
12027         xmlGenericError(xmlGenericErrorContext,
12028             &quot;PP: entering DTD\n&quot;);
12029 #endif
12030             break;
12031             case XML_PARSER_PI:
12032         xmlGenericError(xmlGenericErrorContext,
12033             &quot;PP: internal error, state == PI\n&quot;);
12034         ctxt-&gt;instate = XML_PARSER_CONTENT;
12035 #ifdef DEBUG_PUSH
12036         xmlGenericError(xmlGenericErrorContext,
12037             &quot;PP: entering CONTENT\n&quot;);
12038 #endif
12039         break;
12040             case XML_PARSER_ENTITY_DECL:
12041         xmlGenericError(xmlGenericErrorContext,
12042             &quot;PP: internal error, state == ENTITY_DECL\n&quot;);
12043         ctxt-&gt;instate = XML_PARSER_DTD;
12044 #ifdef DEBUG_PUSH
12045         xmlGenericError(xmlGenericErrorContext,
12046             &quot;PP: entering DTD\n&quot;);
12047 #endif
12048         break;
12049             case XML_PARSER_ENTITY_VALUE:
12050         xmlGenericError(xmlGenericErrorContext,
12051             &quot;PP: internal error, state == ENTITY_VALUE\n&quot;);
12052         ctxt-&gt;instate = XML_PARSER_CONTENT;
12053 #ifdef DEBUG_PUSH
12054         xmlGenericError(xmlGenericErrorContext,
12055             &quot;PP: entering DTD\n&quot;);
12056 #endif
12057         break;
12058             case XML_PARSER_ATTRIBUTE_VALUE:
12059         xmlGenericError(xmlGenericErrorContext,
12060             &quot;PP: internal error, state == ATTRIBUTE_VALUE\n&quot;);
12061         ctxt-&gt;instate = XML_PARSER_START_TAG;
12062 #ifdef DEBUG_PUSH
12063         xmlGenericError(xmlGenericErrorContext,
12064             &quot;PP: entering START_TAG\n&quot;);
12065 #endif
12066         break;
12067             case XML_PARSER_SYSTEM_LITERAL:
12068         xmlGenericError(xmlGenericErrorContext,
12069             &quot;PP: internal error, state == SYSTEM_LITERAL\n&quot;);
12070         ctxt-&gt;instate = XML_PARSER_START_TAG;
12071 #ifdef DEBUG_PUSH
12072         xmlGenericError(xmlGenericErrorContext,
12073             &quot;PP: entering START_TAG\n&quot;);
12074 #endif
12075         break;
12076             case XML_PARSER_PUBLIC_LITERAL:
12077         xmlGenericError(xmlGenericErrorContext,
12078             &quot;PP: internal error, state == PUBLIC_LITERAL\n&quot;);
12079         ctxt-&gt;instate = XML_PARSER_START_TAG;
12080 #ifdef DEBUG_PUSH
12081         xmlGenericError(xmlGenericErrorContext,
12082             &quot;PP: entering START_TAG\n&quot;);
12083 #endif
12084         break;
12085     }
12086     }
12087 done:
12088 #ifdef DEBUG_PUSH
12089     xmlGenericError(xmlGenericErrorContext, &quot;PP: done %d\n&quot;, ret);
12090 #endif
12091     return(ret);
12092 encoding_error:
12093     {
12094         char buffer[150];
12095 
12096     snprintf(buffer, 149, &quot;Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n&quot;,
12097             ctxt-&gt;input-&gt;cur[0], ctxt-&gt;input-&gt;cur[1],
12098             ctxt-&gt;input-&gt;cur[2], ctxt-&gt;input-&gt;cur[3]);
12099     __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
12100              &quot;Input is not proper UTF-8, indicate encoding !\n%s&quot;,
12101              BAD_CAST buffer, NULL);
12102     }
12103     return(0);
12104 }
12105 
12106 /**
12107  * xmlParseCheckTransition:
12108  * @ctxt:  an XML parser context
12109  * @chunk:  a char array
12110  * @size:  the size in byte of the chunk
12111  *
12112  * Check depending on the current parser state if the chunk given must be
12113  * processed immediately or one need more data to advance on parsing.
12114  *
12115  * Returns -1 in case of error, 0 if the push is not needed and 1 if needed
12116  */
12117 static int
12118 xmlParseCheckTransition(xmlParserCtxtPtr ctxt, const char *chunk, int size) {
12119     if ((ctxt == NULL) || (chunk == NULL) || (size &lt; 0))
12120         return(-1);
12121     if (ctxt-&gt;instate == XML_PARSER_START_TAG) {
12122         if (memchr(chunk, &#39;&gt;&#39;, size) != NULL)
12123             return(1);
12124         return(0);
12125     }
12126     if (ctxt-&gt;progressive == XML_PARSER_COMMENT) {
12127         if (memchr(chunk, &#39;&gt;&#39;, size) != NULL)
12128             return(1);
12129         return(0);
12130     }
12131     if (ctxt-&gt;instate == XML_PARSER_CDATA_SECTION) {
12132         if (memchr(chunk, &#39;&gt;&#39;, size) != NULL)
12133             return(1);
12134         return(0);
12135     }
12136     if (ctxt-&gt;progressive == XML_PARSER_PI) {
12137         if (memchr(chunk, &#39;&gt;&#39;, size) != NULL)
12138             return(1);
12139         return(0);
12140     }
12141     if (ctxt-&gt;instate == XML_PARSER_END_TAG) {
12142         if (memchr(chunk, &#39;&gt;&#39;, size) != NULL)
12143             return(1);
12144         return(0);
12145     }
12146     if ((ctxt-&gt;progressive == XML_PARSER_DTD) ||
12147         (ctxt-&gt;instate == XML_PARSER_DTD)) {
12148         if (memchr(chunk, &#39;&gt;&#39;, size) != NULL)
12149             return(1);
12150         return(0);
12151     }
12152     return(1);
12153 }
12154 
12155 /**
12156  * xmlParseChunk:
12157  * @ctxt:  an XML parser context
12158  * @chunk:  an char array
12159  * @size:  the size in byte of the chunk
12160  * @terminate:  last chunk indicator
12161  *
12162  * Parse a Chunk of memory
12163  *
12164  * Returns zero if no error, the xmlParserErrors otherwise.
12165  */
12166 int
12167 xmlParseChunk(xmlParserCtxtPtr ctxt, const char *chunk, int size,
12168               int terminate) {
12169     int end_in_lf = 0;
12170     int remain = 0;
12171     size_t old_avail = 0;
12172     size_t avail = 0;
12173 
12174     if (ctxt == NULL)
12175         return(XML_ERR_INTERNAL_ERROR);
12176     if ((ctxt-&gt;errNo != XML_ERR_OK) &amp;&amp; (ctxt-&gt;disableSAX == 1))
12177         return(ctxt-&gt;errNo);
12178     if (ctxt-&gt;instate == XML_PARSER_EOF)
12179         return(-1);
12180     if (ctxt-&gt;instate == XML_PARSER_START)
12181         xmlDetectSAX2(ctxt);
12182     if ((size &gt; 0) &amp;&amp; (chunk != NULL) &amp;&amp; (!terminate) &amp;&amp;
12183         (chunk[size - 1] == &#39;\r&#39;)) {
12184     end_in_lf = 1;
12185     size--;
12186     }
12187 
12188 xmldecl_done:
12189 
12190     if ((size &gt; 0) &amp;&amp; (chunk != NULL) &amp;&amp; (ctxt-&gt;input != NULL) &amp;&amp;
12191         (ctxt-&gt;input-&gt;buf != NULL) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF))  {
12192     size_t base = xmlBufGetInputBase(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input);
12193     size_t cur = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
12194     int res;
12195 
12196         old_avail = xmlBufUse(ctxt-&gt;input-&gt;buf-&gt;buffer);
12197         /*
12198          * Specific handling if we autodetected an encoding, we should not
12199          * push more than the first line ... which depend on the encoding
12200          * And only push the rest once the final encoding was detected
12201          */
12202         if ((ctxt-&gt;instate == XML_PARSER_START) &amp;&amp; (ctxt-&gt;input != NULL) &amp;&amp;
12203             (ctxt-&gt;input-&gt;buf != NULL) &amp;&amp; (ctxt-&gt;input-&gt;buf-&gt;encoder != NULL)) {
12204             unsigned int len = 45;
12205 
12206             if ((xmlStrcasestr(BAD_CAST ctxt-&gt;input-&gt;buf-&gt;encoder-&gt;name,
12207                                BAD_CAST &quot;UTF-16&quot;)) ||
12208                 (xmlStrcasestr(BAD_CAST ctxt-&gt;input-&gt;buf-&gt;encoder-&gt;name,
12209                                BAD_CAST &quot;UTF16&quot;)))
12210                 len = 90;
12211             else if ((xmlStrcasestr(BAD_CAST ctxt-&gt;input-&gt;buf-&gt;encoder-&gt;name,
12212                                     BAD_CAST &quot;UCS-4&quot;)) ||
12213                      (xmlStrcasestr(BAD_CAST ctxt-&gt;input-&gt;buf-&gt;encoder-&gt;name,
12214                                     BAD_CAST &quot;UCS4&quot;)))
12215                 len = 180;
12216 
12217             if (ctxt-&gt;input-&gt;buf-&gt;rawconsumed &lt; len)
12218                 len -= ctxt-&gt;input-&gt;buf-&gt;rawconsumed;
12219 
12220             /*
12221              * Change size for reading the initial declaration only
12222              * if size is greater than len. Otherwise, memmove in xmlBufferAdd
12223              * will blindly copy extra bytes from memory.
12224              */
12225             if ((unsigned int) size &gt; len) {
12226                 remain = size - len;
12227                 size = len;
12228             } else {
12229                 remain = 0;
12230             }
12231         }
12232     res = xmlParserInputBufferPush(ctxt-&gt;input-&gt;buf, size, chunk);
12233     if (res &lt; 0) {
12234         ctxt-&gt;errNo = XML_PARSER_EOF;
12235         xmlHaltParser(ctxt);
12236         return (XML_PARSER_EOF);
12237     }
12238         xmlBufSetInputBaseCur(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input, base, cur);
12239 #ifdef DEBUG_PUSH
12240     xmlGenericError(xmlGenericErrorContext, &quot;PP: pushed %d\n&quot;, size);
12241 #endif
12242 
12243     } else if (ctxt-&gt;instate != XML_PARSER_EOF) {
12244     if ((ctxt-&gt;input != NULL) &amp;&amp; ctxt-&gt;input-&gt;buf != NULL) {
12245         xmlParserInputBufferPtr in = ctxt-&gt;input-&gt;buf;
12246         if ((in-&gt;encoder != NULL) &amp;&amp; (in-&gt;buffer != NULL) &amp;&amp;
12247             (in-&gt;raw != NULL)) {
12248         int nbchars;
12249         size_t base = xmlBufGetInputBase(in-&gt;buffer, ctxt-&gt;input);
12250         size_t current = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
12251 
12252         nbchars = xmlCharEncInput(in, terminate);
12253         if (nbchars &lt; 0) {
12254             /* TODO 2.6.0 */
12255             xmlGenericError(xmlGenericErrorContext,
12256                     &quot;xmlParseChunk: encoder error\n&quot;);
12257                     xmlHaltParser(ctxt);
12258             return(XML_ERR_INVALID_ENCODING);
12259         }
12260         xmlBufSetInputBaseCur(in-&gt;buffer, ctxt-&gt;input, base, current);
12261         }
12262     }
12263     }
12264     if (remain != 0) {
12265         xmlParseTryOrFinish(ctxt, 0);
12266     } else {
12267         if ((ctxt-&gt;input != NULL) &amp;&amp; (ctxt-&gt;input-&gt;buf != NULL))
12268             avail = xmlBufUse(ctxt-&gt;input-&gt;buf-&gt;buffer);
12269         /*
12270          * Depending on the current state it may not be such
12271          * a good idea to try parsing if there is nothing in the chunk
12272          * which would be worth doing a parser state transition and we
12273          * need to wait for more data
12274          */
12275         if ((terminate) || (avail &gt; XML_MAX_TEXT_LENGTH) ||
12276             (old_avail == 0) || (avail == 0) ||
12277             (xmlParseCheckTransition(ctxt,
12278                        (const char *)&amp;ctxt-&gt;input-&gt;base[old_avail],
12279                                      avail - old_avail)))
12280             xmlParseTryOrFinish(ctxt, terminate);
12281     }
12282     if (ctxt-&gt;instate == XML_PARSER_EOF)
12283         return(ctxt-&gt;errNo);
12284 
12285     if ((ctxt-&gt;input != NULL) &amp;&amp;
12286          (((ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur) &gt; XML_MAX_LOOKUP_LIMIT) ||
12287          ((ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base) &gt; XML_MAX_LOOKUP_LIMIT)) &amp;&amp;
12288         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
12289         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, &quot;Huge input lookup&quot;);
12290         xmlHaltParser(ctxt);
12291     }
12292     if ((ctxt-&gt;errNo != XML_ERR_OK) &amp;&amp; (ctxt-&gt;disableSAX == 1))
12293         return(ctxt-&gt;errNo);
12294 
12295     if (remain != 0) {
12296         chunk += size;
12297         size = remain;
12298         remain = 0;
12299         goto xmldecl_done;
12300     }
12301     if ((end_in_lf == 1) &amp;&amp; (ctxt-&gt;input != NULL) &amp;&amp;
12302         (ctxt-&gt;input-&gt;buf != NULL)) {
12303     size_t base = xmlBufGetInputBase(ctxt-&gt;input-&gt;buf-&gt;buffer,
12304                      ctxt-&gt;input);
12305     size_t current = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
12306 
12307     xmlParserInputBufferPush(ctxt-&gt;input-&gt;buf, 1, &quot;\r&quot;);
12308 
12309     xmlBufSetInputBaseCur(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input,
12310                   base, current);
12311     }
12312     if (terminate) {
12313     /*
12314      * Check for termination
12315      */
12316     int cur_avail = 0;
12317 
12318     if (ctxt-&gt;input != NULL) {
12319         if (ctxt-&gt;input-&gt;buf == NULL)
12320         cur_avail = ctxt-&gt;input-&gt;length -
12321                 (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
12322         else
12323         cur_avail = xmlBufUse(ctxt-&gt;input-&gt;buf-&gt;buffer) -
12324                           (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
12325     }
12326 
12327     if ((ctxt-&gt;instate != XML_PARSER_EOF) &amp;&amp;
12328         (ctxt-&gt;instate != XML_PARSER_EPILOG)) {
12329         xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);
12330     }
12331     if ((ctxt-&gt;instate == XML_PARSER_EPILOG) &amp;&amp; (cur_avail &gt; 0)) {
12332         xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);
12333     }
12334     if (ctxt-&gt;instate != XML_PARSER_EOF) {
12335         if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;endDocument != NULL))
12336         ctxt-&gt;sax-&gt;endDocument(ctxt-&gt;userData);
12337     }
12338     ctxt-&gt;instate = XML_PARSER_EOF;
12339     }
12340     if (ctxt-&gt;wellFormed == 0)
12341     return((xmlParserErrors) ctxt-&gt;errNo);
12342     else
12343         return(0);
12344 }
12345 
12346 /************************************************************************
12347  *                                  *
12348  *      I/O front end functions to the parser           *
12349  *                                  *
12350  ************************************************************************/
12351 
12352 /**
12353  * xmlCreatePushParserCtxt:
12354  * @sax:  a SAX handler
12355  * @user_data:  The user data returned on SAX callbacks
12356  * @chunk:  a pointer to an array of chars
12357  * @size:  number of chars in the array
12358  * @filename:  an optional file name or URI
12359  *
12360  * Create a parser context for using the XML parser in push mode.
12361  * If @buffer and @size are non-NULL, the data is used to detect
12362  * the encoding.  The remaining characters will be parsed so they
12363  * don&#39;t need to be fed in again through xmlParseChunk.
12364  * To allow content encoding detection, @size should be &gt;= 4
12365  * The value of @filename is used for fetching external entities
12366  * and error/warning reports.
12367  *
12368  * Returns the new parser context or NULL
12369  */
12370 
12371 xmlParserCtxtPtr
12372 xmlCreatePushParserCtxt(xmlSAXHandlerPtr sax, void *user_data,
12373                         const char *chunk, int size, const char *filename) {
12374     xmlParserCtxtPtr ctxt;
12375     xmlParserInputPtr inputStream;
12376     xmlParserInputBufferPtr buf;
12377     xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;
12378 
12379     /*
12380      * plug some encoding conversion routines
12381      */
12382     if ((chunk != NULL) &amp;&amp; (size &gt;= 4))
12383     enc = xmlDetectCharEncoding((const xmlChar *) chunk, size);
12384 
12385     buf = xmlAllocParserInputBuffer(enc);
12386     if (buf == NULL) return(NULL);
12387 
12388     ctxt = xmlNewParserCtxt();
12389     if (ctxt == NULL) {
12390         xmlErrMemory(NULL, &quot;creating parser: out of memory\n&quot;);
12391     xmlFreeParserInputBuffer(buf);
12392     return(NULL);
12393     }
12394     ctxt-&gt;dictNames = 1;
<a name="100" id="anc100"></a>






12395     if (sax != NULL) {
12396 #ifdef LIBXML_SAX1_ENABLED
12397     if (ctxt-&gt;sax != (xmlSAXHandlerPtr) &amp;xmlDefaultSAXHandler)
12398 #endif /* LIBXML_SAX1_ENABLED */
12399         xmlFree(ctxt-&gt;sax);
12400     ctxt-&gt;sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(xmlSAXHandler));
12401     if (ctxt-&gt;sax == NULL) {
12402         xmlErrMemory(ctxt, NULL);
12403         xmlFreeParserInputBuffer(buf);
12404         xmlFreeParserCtxt(ctxt);
12405         return(NULL);
12406     }
12407     memset(ctxt-&gt;sax, 0, sizeof(xmlSAXHandler));
12408     if (sax-&gt;initialized == XML_SAX2_MAGIC)
12409         memcpy(ctxt-&gt;sax, sax, sizeof(xmlSAXHandler));
12410     else
12411         memcpy(ctxt-&gt;sax, sax, sizeof(xmlSAXHandlerV1));
12412     if (user_data != NULL)
12413         ctxt-&gt;userData = user_data;
12414     }
12415     if (filename == NULL) {
12416     ctxt-&gt;directory = NULL;
12417     } else {
12418         ctxt-&gt;directory = xmlParserGetDirectory(filename);
12419     }
12420 
12421     inputStream = xmlNewInputStream(ctxt);
12422     if (inputStream == NULL) {
12423     xmlFreeParserCtxt(ctxt);
12424     xmlFreeParserInputBuffer(buf);
12425     return(NULL);
12426     }
12427 
12428     if (filename == NULL)
12429     inputStream-&gt;filename = NULL;
12430     else {
12431     inputStream-&gt;filename = (char *)
12432         xmlCanonicPath((const xmlChar *) filename);
12433     if (inputStream-&gt;filename == NULL) {
12434         xmlFreeParserCtxt(ctxt);
12435         xmlFreeParserInputBuffer(buf);
12436         return(NULL);
12437     }
12438     }
12439     inputStream-&gt;buf = buf;
12440     xmlBufResetInput(inputStream-&gt;buf-&gt;buffer, inputStream);
12441     inputPush(ctxt, inputStream);
12442 
12443     /*
12444      * If the caller didn&#39;t provide an initial &#39;chunk&#39; for determining
12445      * the encoding, we set the context to XML_CHAR_ENCODING_NONE so
12446      * that it can be automatically determined later
12447      */
12448     if ((size == 0) || (chunk == NULL)) {
12449     ctxt-&gt;charset = XML_CHAR_ENCODING_NONE;
12450     } else if ((ctxt-&gt;input != NULL) &amp;&amp; (ctxt-&gt;input-&gt;buf != NULL)) {
12451     size_t base = xmlBufGetInputBase(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input);
12452     size_t cur = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
12453 
12454     xmlParserInputBufferPush(ctxt-&gt;input-&gt;buf, size, chunk);
12455 
12456         xmlBufSetInputBaseCur(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input, base, cur);
12457 #ifdef DEBUG_PUSH
12458     xmlGenericError(xmlGenericErrorContext, &quot;PP: pushed %d\n&quot;, size);
12459 #endif
12460     }
12461 
12462     if (enc != XML_CHAR_ENCODING_NONE) {
12463         xmlSwitchEncoding(ctxt, enc);
12464     }
12465 
12466     return(ctxt);
12467 }
12468 #endif /* LIBXML_PUSH_ENABLED */
12469 
12470 /**
12471  * xmlHaltParser:
12472  * @ctxt:  an XML parser context
12473  *
12474  * Blocks further parser processing don&#39;t override error
12475  * for internal use
12476  */
12477 static void
12478 xmlHaltParser(xmlParserCtxtPtr ctxt) {
12479     if (ctxt == NULL)
12480         return;
12481     ctxt-&gt;instate = XML_PARSER_EOF;
12482     ctxt-&gt;disableSAX = 1;
12483     while (ctxt-&gt;inputNr &gt; 1)
12484         xmlFreeInputStream(inputPop(ctxt));
12485     if (ctxt-&gt;input != NULL) {
12486         /*
12487      * in case there was a specific allocation deallocate before
12488      * overriding base
12489      */
12490         if (ctxt-&gt;input-&gt;free != NULL) {
12491         ctxt-&gt;input-&gt;free((xmlChar *) ctxt-&gt;input-&gt;base);
12492         ctxt-&gt;input-&gt;free = NULL;
12493     }
12494         if (ctxt-&gt;input-&gt;buf != NULL) {
12495             xmlFreeParserInputBuffer(ctxt-&gt;input-&gt;buf);
12496             ctxt-&gt;input-&gt;buf = NULL;
12497         }
12498     ctxt-&gt;input-&gt;cur = BAD_CAST&quot;&quot;;
12499         ctxt-&gt;input-&gt;length = 0;
12500     ctxt-&gt;input-&gt;base = ctxt-&gt;input-&gt;cur;
12501         ctxt-&gt;input-&gt;end = ctxt-&gt;input-&gt;cur;
12502     }
12503 }
12504 
12505 /**
12506  * xmlStopParser:
12507  * @ctxt:  an XML parser context
12508  *
12509  * Blocks further parser processing
12510  */
12511 void
12512 xmlStopParser(xmlParserCtxtPtr ctxt) {
12513     if (ctxt == NULL)
12514         return;
12515     xmlHaltParser(ctxt);
12516     ctxt-&gt;errNo = XML_ERR_USER_STOP;
12517 }
12518 
12519 /**
12520  * xmlCreateIOParserCtxt:
12521  * @sax:  a SAX handler
12522  * @user_data:  The user data returned on SAX callbacks
12523  * @ioread:  an I/O read function
12524  * @ioclose:  an I/O close function
12525  * @ioctx:  an I/O handler
12526  * @enc:  the charset encoding if known
12527  *
12528  * Create a parser context for using the XML parser with an existing
12529  * I/O stream
12530  *
12531  * Returns the new parser context or NULL
12532  */
12533 xmlParserCtxtPtr
12534 xmlCreateIOParserCtxt(xmlSAXHandlerPtr sax, void *user_data,
12535     xmlInputReadCallback   ioread, xmlInputCloseCallback  ioclose,
12536     void *ioctx, xmlCharEncoding enc) {
12537     xmlParserCtxtPtr ctxt;
12538     xmlParserInputPtr inputStream;
12539     xmlParserInputBufferPtr buf;
12540 
12541     if (ioread == NULL) return(NULL);
12542 
12543     buf = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx, enc);
12544     if (buf == NULL) {
12545         if (ioclose != NULL)
12546             ioclose(ioctx);
12547         return (NULL);
12548     }
12549 
12550     ctxt = xmlNewParserCtxt();
12551     if (ctxt == NULL) {
12552     xmlFreeParserInputBuffer(buf);
12553     return(NULL);
12554     }
12555     if (sax != NULL) {
12556 #ifdef LIBXML_SAX1_ENABLED
12557     if (ctxt-&gt;sax != (xmlSAXHandlerPtr) &amp;xmlDefaultSAXHandler)
12558 #endif /* LIBXML_SAX1_ENABLED */
12559         xmlFree(ctxt-&gt;sax);
12560     ctxt-&gt;sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(xmlSAXHandler));
12561     if (ctxt-&gt;sax == NULL) {
12562         xmlErrMemory(ctxt, NULL);
12563         xmlFreeParserCtxt(ctxt);
12564         return(NULL);
12565     }
12566     memset(ctxt-&gt;sax, 0, sizeof(xmlSAXHandler));
12567     if (sax-&gt;initialized == XML_SAX2_MAGIC)
12568         memcpy(ctxt-&gt;sax, sax, sizeof(xmlSAXHandler));
12569     else
12570         memcpy(ctxt-&gt;sax, sax, sizeof(xmlSAXHandlerV1));
12571     if (user_data != NULL)
12572         ctxt-&gt;userData = user_data;
12573     }
12574 
12575     inputStream = xmlNewIOInputStream(ctxt, buf, enc);
12576     if (inputStream == NULL) {
12577     xmlFreeParserCtxt(ctxt);
12578     return(NULL);
12579     }
12580     inputPush(ctxt, inputStream);
12581 
12582     return(ctxt);
12583 }
12584 
12585 #ifdef LIBXML_VALID_ENABLED
12586 /************************************************************************
12587  *                                  *
12588  *      Front ends when parsing a DTD               *
12589  *                                  *
12590  ************************************************************************/
12591 
12592 /**
12593  * xmlIOParseDTD:
12594  * @sax:  the SAX handler block or NULL
12595  * @input:  an Input Buffer
12596  * @enc:  the charset encoding if known
12597  *
12598  * Load and parse a DTD
12599  *
12600  * Returns the resulting xmlDtdPtr or NULL in case of error.
12601  * @input will be freed by the function in any case.
12602  */
12603 
12604 xmlDtdPtr
12605 xmlIOParseDTD(xmlSAXHandlerPtr sax, xmlParserInputBufferPtr input,
12606           xmlCharEncoding enc) {
12607     xmlDtdPtr ret = NULL;
12608     xmlParserCtxtPtr ctxt;
12609     xmlParserInputPtr pinput = NULL;
12610     xmlChar start[4];
12611 
12612     if (input == NULL)
12613     return(NULL);
12614 
12615     ctxt = xmlNewParserCtxt();
12616     if (ctxt == NULL) {
12617         xmlFreeParserInputBuffer(input);
12618     return(NULL);
12619     }
12620 
12621     /* We are loading a DTD */
12622     ctxt-&gt;options |= XML_PARSE_DTDLOAD;
12623 
12624     /*
12625      * Set-up the SAX context
12626      */
12627     if (sax != NULL) {
12628     if (ctxt-&gt;sax != NULL)
12629         xmlFree(ctxt-&gt;sax);
12630         ctxt-&gt;sax = sax;
12631         ctxt-&gt;userData = ctxt;
12632     }
12633     xmlDetectSAX2(ctxt);
12634 
12635     /*
12636      * generate a parser input from the I/O handler
12637      */
12638 
12639     pinput = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
12640     if (pinput == NULL) {
12641         if (sax != NULL) ctxt-&gt;sax = NULL;
12642         xmlFreeParserInputBuffer(input);
12643     xmlFreeParserCtxt(ctxt);
12644     return(NULL);
12645     }
12646 
12647     /*
12648      * plug some encoding conversion routines here.
12649      */
12650     if (xmlPushInput(ctxt, pinput) &lt; 0) {
12651         if (sax != NULL) ctxt-&gt;sax = NULL;
12652     xmlFreeParserCtxt(ctxt);
12653     return(NULL);
12654     }
12655     if (enc != XML_CHAR_ENCODING_NONE) {
12656         xmlSwitchEncoding(ctxt, enc);
12657     }
12658 
12659     pinput-&gt;filename = NULL;
12660     pinput-&gt;line = 1;
12661     pinput-&gt;col = 1;
12662     pinput-&gt;base = ctxt-&gt;input-&gt;cur;
12663     pinput-&gt;cur = ctxt-&gt;input-&gt;cur;
12664     pinput-&gt;free = NULL;
12665 
12666     /*
12667      * let&#39;s parse that entity knowing it&#39;s an external subset.
12668      */
12669     ctxt-&gt;inSubset = 2;
12670     ctxt-&gt;myDoc = xmlNewDoc(BAD_CAST &quot;1.0&quot;);
12671     if (ctxt-&gt;myDoc == NULL) {
12672     xmlErrMemory(ctxt, &quot;New Doc failed&quot;);
12673     return(NULL);
12674     }
12675     ctxt-&gt;myDoc-&gt;properties = XML_DOC_INTERNAL;
12676     ctxt-&gt;myDoc-&gt;extSubset = xmlNewDtd(ctxt-&gt;myDoc, BAD_CAST &quot;none&quot;,
12677                                    BAD_CAST &quot;none&quot;, BAD_CAST &quot;none&quot;);
12678 
12679     if ((enc == XML_CHAR_ENCODING_NONE) &amp;&amp;
12680         ((ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur) &gt;= 4)) {
12681     /*
12682      * Get the 4 first bytes and decode the charset
12683      * if enc != XML_CHAR_ENCODING_NONE
12684      * plug some encoding conversion routines.
12685      */
12686     start[0] = RAW;
12687     start[1] = NXT(1);
12688     start[2] = NXT(2);
12689     start[3] = NXT(3);
12690     enc = xmlDetectCharEncoding(start, 4);
12691     if (enc != XML_CHAR_ENCODING_NONE) {
12692         xmlSwitchEncoding(ctxt, enc);
12693     }
12694     }
12695 
12696     xmlParseExternalSubset(ctxt, BAD_CAST &quot;none&quot;, BAD_CAST &quot;none&quot;);
12697 
12698     if (ctxt-&gt;myDoc != NULL) {
12699     if (ctxt-&gt;wellFormed) {
12700         ret = ctxt-&gt;myDoc-&gt;extSubset;
12701         ctxt-&gt;myDoc-&gt;extSubset = NULL;
12702         if (ret != NULL) {
12703         xmlNodePtr tmp;
12704 
12705         ret-&gt;doc = NULL;
12706         tmp = ret-&gt;children;
12707         while (tmp != NULL) {
12708             tmp-&gt;doc = NULL;
12709             tmp = tmp-&gt;next;
12710         }
12711         }
12712     } else {
12713         ret = NULL;
12714     }
12715         xmlFreeDoc(ctxt-&gt;myDoc);
12716         ctxt-&gt;myDoc = NULL;
12717     }
12718     if (sax != NULL) ctxt-&gt;sax = NULL;
12719     xmlFreeParserCtxt(ctxt);
12720 
12721     return(ret);
12722 }
12723 
12724 /**
12725  * xmlSAXParseDTD:
12726  * @sax:  the SAX handler block
12727  * @ExternalID:  a NAME* containing the External ID of the DTD
12728  * @SystemID:  a NAME* containing the URL to the DTD
12729  *
12730  * Load and parse an external subset.
12731  *
12732  * Returns the resulting xmlDtdPtr or NULL in case of error.
12733  */
12734 
12735 xmlDtdPtr
12736 xmlSAXParseDTD(xmlSAXHandlerPtr sax, const xmlChar *ExternalID,
12737                           const xmlChar *SystemID) {
12738     xmlDtdPtr ret = NULL;
12739     xmlParserCtxtPtr ctxt;
12740     xmlParserInputPtr input = NULL;
12741     xmlCharEncoding enc;
12742     xmlChar* systemIdCanonic;
12743 
12744     if ((ExternalID == NULL) &amp;&amp; (SystemID == NULL)) return(NULL);
12745 
12746     ctxt = xmlNewParserCtxt();
12747     if (ctxt == NULL) {
12748     return(NULL);
12749     }
12750 
12751     /* We are loading a DTD */
12752     ctxt-&gt;options |= XML_PARSE_DTDLOAD;
12753 
12754     /*
12755      * Set-up the SAX context
12756      */
12757     if (sax != NULL) {
12758     if (ctxt-&gt;sax != NULL)
12759         xmlFree(ctxt-&gt;sax);
12760         ctxt-&gt;sax = sax;
12761         ctxt-&gt;userData = ctxt;
12762     }
12763 
12764     /*
12765      * Canonicalise the system ID
12766      */
12767     systemIdCanonic = xmlCanonicPath(SystemID);
12768     if ((SystemID != NULL) &amp;&amp; (systemIdCanonic == NULL)) {
12769     xmlFreeParserCtxt(ctxt);
12770     return(NULL);
12771     }
12772 
12773     /*
12774      * Ask the Entity resolver to load the damn thing
12775      */
12776 
12777     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;resolveEntity != NULL))
12778     input = ctxt-&gt;sax-&gt;resolveEntity(ctxt-&gt;userData, ExternalID,
12779                                      systemIdCanonic);
12780     if (input == NULL) {
12781         if (sax != NULL) ctxt-&gt;sax = NULL;
12782     xmlFreeParserCtxt(ctxt);
12783     if (systemIdCanonic != NULL)
12784         xmlFree(systemIdCanonic);
12785     return(NULL);
12786     }
12787 
12788     /*
12789      * plug some encoding conversion routines here.
12790      */
12791     if (xmlPushInput(ctxt, input) &lt; 0) {
12792         if (sax != NULL) ctxt-&gt;sax = NULL;
12793     xmlFreeParserCtxt(ctxt);
12794     if (systemIdCanonic != NULL)
12795         xmlFree(systemIdCanonic);
12796     return(NULL);
12797     }
12798     if ((ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur) &gt;= 4) {
12799     enc = xmlDetectCharEncoding(ctxt-&gt;input-&gt;cur, 4);
12800     xmlSwitchEncoding(ctxt, enc);
12801     }
12802 
12803     if (input-&gt;filename == NULL)
12804     input-&gt;filename = (char *) systemIdCanonic;
12805     else
12806     xmlFree(systemIdCanonic);
12807     input-&gt;line = 1;
12808     input-&gt;col = 1;
12809     input-&gt;base = ctxt-&gt;input-&gt;cur;
12810     input-&gt;cur = ctxt-&gt;input-&gt;cur;
12811     input-&gt;free = NULL;
12812 
12813     /*
12814      * let&#39;s parse that entity knowing it&#39;s an external subset.
12815      */
12816     ctxt-&gt;inSubset = 2;
12817     ctxt-&gt;myDoc = xmlNewDoc(BAD_CAST &quot;1.0&quot;);
12818     if (ctxt-&gt;myDoc == NULL) {
12819     xmlErrMemory(ctxt, &quot;New Doc failed&quot;);
12820         if (sax != NULL) ctxt-&gt;sax = NULL;
12821     xmlFreeParserCtxt(ctxt);
12822     return(NULL);
12823     }
12824     ctxt-&gt;myDoc-&gt;properties = XML_DOC_INTERNAL;
12825     ctxt-&gt;myDoc-&gt;extSubset = xmlNewDtd(ctxt-&gt;myDoc, BAD_CAST &quot;none&quot;,
12826                                    ExternalID, SystemID);
12827     xmlParseExternalSubset(ctxt, ExternalID, SystemID);
12828 
12829     if (ctxt-&gt;myDoc != NULL) {
12830     if (ctxt-&gt;wellFormed) {
12831         ret = ctxt-&gt;myDoc-&gt;extSubset;
12832         ctxt-&gt;myDoc-&gt;extSubset = NULL;
12833         if (ret != NULL) {
12834         xmlNodePtr tmp;
12835 
12836         ret-&gt;doc = NULL;
12837         tmp = ret-&gt;children;
12838         while (tmp != NULL) {
12839             tmp-&gt;doc = NULL;
12840             tmp = tmp-&gt;next;
12841         }
12842         }
12843     } else {
12844         ret = NULL;
12845     }
12846         xmlFreeDoc(ctxt-&gt;myDoc);
12847         ctxt-&gt;myDoc = NULL;
12848     }
12849     if (sax != NULL) ctxt-&gt;sax = NULL;
12850     xmlFreeParserCtxt(ctxt);
12851 
12852     return(ret);
12853 }
12854 
12855 
12856 /**
12857  * xmlParseDTD:
12858  * @ExternalID:  a NAME* containing the External ID of the DTD
12859  * @SystemID:  a NAME* containing the URL to the DTD
12860  *
12861  * Load and parse an external subset.
12862  *
12863  * Returns the resulting xmlDtdPtr or NULL in case of error.
12864  */
12865 
12866 xmlDtdPtr
12867 xmlParseDTD(const xmlChar *ExternalID, const xmlChar *SystemID) {
12868     return(xmlSAXParseDTD(NULL, ExternalID, SystemID));
12869 }
12870 #endif /* LIBXML_VALID_ENABLED */
12871 
12872 /************************************************************************
12873  *                                  *
12874  *      Front ends when parsing an Entity           *
12875  *                                  *
12876  ************************************************************************/
12877 
12878 /**
12879  * xmlParseCtxtExternalEntity:
12880  * @ctx:  the existing parsing context
12881  * @URL:  the URL for the entity to load
12882  * @ID:  the System ID for the entity to load
12883  * @lst:  the return value for the set of parsed nodes
12884  *
12885  * Parse an external general entity within an existing parsing context
12886  * An external general parsed entity is well-formed if it matches the
12887  * production labeled extParsedEnt.
12888  *
12889  * [78] extParsedEnt ::= TextDecl? content
12890  *
12891  * Returns 0 if the entity is well formed, -1 in case of args problem and
12892  *    the parser error code otherwise
12893  */
12894 
12895 int
12896 xmlParseCtxtExternalEntity(xmlParserCtxtPtr ctx, const xmlChar *URL,
12897                    const xmlChar *ID, xmlNodePtr *lst) {
12898     xmlParserCtxtPtr ctxt;
12899     xmlDocPtr newDoc;
12900     xmlNodePtr newRoot;
12901     xmlSAXHandlerPtr oldsax = NULL;
12902     int ret = 0;
12903     xmlChar start[4];
12904     xmlCharEncoding enc;
12905 
12906     if (ctx == NULL) return(-1);
12907 
12908     if (((ctx-&gt;depth &gt; 40) &amp;&amp; ((ctx-&gt;options &amp; XML_PARSE_HUGE) == 0)) ||
12909         (ctx-&gt;depth &gt; 1024)) {
12910     return(XML_ERR_ENTITY_LOOP);
12911     }
12912 
12913     if (lst != NULL)
12914         *lst = NULL;
12915     if ((URL == NULL) &amp;&amp; (ID == NULL))
12916     return(-1);
12917     if (ctx-&gt;myDoc == NULL) /* @@ relax but check for dereferences */
12918     return(-1);
12919 
12920     ctxt = xmlCreateEntityParserCtxtInternal(URL, ID, NULL, ctx);
12921     if (ctxt == NULL) {
12922     return(-1);
12923     }
12924 
12925     oldsax = ctxt-&gt;sax;
12926     ctxt-&gt;sax = ctx-&gt;sax;
12927     xmlDetectSAX2(ctxt);
12928     newDoc = xmlNewDoc(BAD_CAST &quot;1.0&quot;);
12929     if (newDoc == NULL) {
12930     xmlFreeParserCtxt(ctxt);
12931     return(-1);
12932     }
12933     newDoc-&gt;properties = XML_DOC_INTERNAL;
12934     if (ctx-&gt;myDoc-&gt;dict) {
12935     newDoc-&gt;dict = ctx-&gt;myDoc-&gt;dict;
12936     xmlDictReference(newDoc-&gt;dict);
12937     }
12938     if (ctx-&gt;myDoc != NULL) {
12939     newDoc-&gt;intSubset = ctx-&gt;myDoc-&gt;intSubset;
12940     newDoc-&gt;extSubset = ctx-&gt;myDoc-&gt;extSubset;
12941     }
12942     if (ctx-&gt;myDoc-&gt;URL != NULL) {
12943     newDoc-&gt;URL = xmlStrdup(ctx-&gt;myDoc-&gt;URL);
12944     }
12945     newRoot = xmlNewDocNode(newDoc, NULL, BAD_CAST &quot;pseudoroot&quot;, NULL);
12946     if (newRoot == NULL) {
12947     ctxt-&gt;sax = oldsax;
12948     xmlFreeParserCtxt(ctxt);
12949     newDoc-&gt;intSubset = NULL;
12950     newDoc-&gt;extSubset = NULL;
12951         xmlFreeDoc(newDoc);
12952     return(-1);
12953     }
12954     xmlAddChild((xmlNodePtr) newDoc, newRoot);
12955     nodePush(ctxt, newDoc-&gt;children);
12956     if (ctx-&gt;myDoc == NULL) {
12957     ctxt-&gt;myDoc = newDoc;
12958     } else {
12959     ctxt-&gt;myDoc = ctx-&gt;myDoc;
12960     newDoc-&gt;children-&gt;doc = ctx-&gt;myDoc;
12961     }
12962 
12963     /*
12964      * Get the 4 first bytes and decode the charset
12965      * if enc != XML_CHAR_ENCODING_NONE
12966      * plug some encoding conversion routines.
12967      */
12968     GROW
12969     if ((ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur) &gt;= 4) {
12970     start[0] = RAW;
12971     start[1] = NXT(1);
12972     start[2] = NXT(2);
12973     start[3] = NXT(3);
12974     enc = xmlDetectCharEncoding(start, 4);
12975     if (enc != XML_CHAR_ENCODING_NONE) {
12976         xmlSwitchEncoding(ctxt, enc);
12977     }
12978     }
12979 
12980     /*
12981      * Parse a possible text declaration first
12982      */
12983     if ((CMP5(CUR_PTR, &#39;&lt;&#39;, &#39;?&#39;, &#39;x&#39;, &#39;m&#39;, &#39;l&#39;)) &amp;&amp; (IS_BLANK_CH(NXT(5)))) {
12984     xmlParseTextDecl(ctxt);
12985     /*
12986      * An XML-1.0 document can&#39;t reference an entity not XML-1.0
12987      */
12988     if ((xmlStrEqual(ctx-&gt;version, BAD_CAST &quot;1.0&quot;)) &amp;&amp;
12989         (!xmlStrEqual(ctxt-&gt;input-&gt;version, BAD_CAST &quot;1.0&quot;))) {
12990         xmlFatalErrMsg(ctxt, XML_ERR_VERSION_MISMATCH,
12991                        &quot;Version mismatch between document and entity\n&quot;);
12992     }
12993     }
12994 
12995     /*
12996      * If the user provided its own SAX callbacks then reuse the
12997      * useData callback field, otherwise the expected setup in a
12998      * DOM builder is to have userData == ctxt
12999      */
13000     if (ctx-&gt;userData == ctx)
13001         ctxt-&gt;userData = ctxt;
13002     else
13003         ctxt-&gt;userData = ctx-&gt;userData;
13004 
13005     /*
13006      * Doing validity checking on chunk doesn&#39;t make sense
13007      */
13008     ctxt-&gt;instate = XML_PARSER_CONTENT;
13009     ctxt-&gt;validate = ctx-&gt;validate;
13010     ctxt-&gt;valid = ctx-&gt;valid;
13011     ctxt-&gt;loadsubset = ctx-&gt;loadsubset;
13012     ctxt-&gt;depth = ctx-&gt;depth + 1;
13013     ctxt-&gt;replaceEntities = ctx-&gt;replaceEntities;
13014     if (ctxt-&gt;validate) {
13015     ctxt-&gt;vctxt.error = ctx-&gt;vctxt.error;
13016     ctxt-&gt;vctxt.warning = ctx-&gt;vctxt.warning;
13017     } else {
13018     ctxt-&gt;vctxt.error = NULL;
13019     ctxt-&gt;vctxt.warning = NULL;
13020     }
13021     ctxt-&gt;vctxt.nodeTab = NULL;
13022     ctxt-&gt;vctxt.nodeNr = 0;
13023     ctxt-&gt;vctxt.nodeMax = 0;
13024     ctxt-&gt;vctxt.node = NULL;
13025     if (ctxt-&gt;dict != NULL) xmlDictFree(ctxt-&gt;dict);
13026     ctxt-&gt;dict = ctx-&gt;dict;
13027     ctxt-&gt;str_xml = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xml&quot;, 3);
13028     ctxt-&gt;str_xmlns = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xmlns&quot;, 5);
13029     ctxt-&gt;str_xml_ns = xmlDictLookup(ctxt-&gt;dict, XML_XML_NAMESPACE, 36);
13030     ctxt-&gt;dictNames = ctx-&gt;dictNames;
13031     ctxt-&gt;attsDefault = ctx-&gt;attsDefault;
13032     ctxt-&gt;attsSpecial = ctx-&gt;attsSpecial;
13033     ctxt-&gt;linenumbers = ctx-&gt;linenumbers;
13034 
13035     xmlParseContent(ctxt);
13036 
13037     ctx-&gt;validate = ctxt-&gt;validate;
13038     ctx-&gt;valid = ctxt-&gt;valid;
13039     if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
13040     xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13041     } else if (RAW != 0) {
13042     xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
13043     }
13044     if (ctxt-&gt;node != newDoc-&gt;children) {
13045     xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13046     }
13047 
13048     if (!ctxt-&gt;wellFormed) {
13049         if (ctxt-&gt;errNo == 0)
13050         ret = 1;
13051     else
13052         ret = ctxt-&gt;errNo;
13053     } else {
13054     if (lst != NULL) {
13055         xmlNodePtr cur;
13056 
13057         /*
13058          * Return the newly created nodeset after unlinking it from
13059          * they pseudo parent.
13060          */
13061         cur = newDoc-&gt;children-&gt;children;
13062         *lst = cur;
13063         while (cur != NULL) {
13064         cur-&gt;parent = NULL;
13065         cur = cur-&gt;next;
13066         }
13067             newDoc-&gt;children-&gt;children = NULL;
13068     }
13069     ret = 0;
13070     }
13071     ctxt-&gt;sax = oldsax;
13072     ctxt-&gt;dict = NULL;
13073     ctxt-&gt;attsDefault = NULL;
13074     ctxt-&gt;attsSpecial = NULL;
13075     xmlFreeParserCtxt(ctxt);
13076     newDoc-&gt;intSubset = NULL;
13077     newDoc-&gt;extSubset = NULL;
13078     xmlFreeDoc(newDoc);
13079 
13080     return(ret);
13081 }
13082 
13083 /**
13084  * xmlParseExternalEntityPrivate:
13085  * @doc:  the document the chunk pertains to
13086  * @oldctxt:  the previous parser context if available
13087  * @sax:  the SAX handler bloc (possibly NULL)
13088  * @user_data:  The user data returned on SAX callbacks (possibly NULL)
13089  * @depth:  Used for loop detection, use 0
13090  * @URL:  the URL for the entity to load
13091  * @ID:  the System ID for the entity to load
13092  * @list:  the return value for the set of parsed nodes
13093  *
13094  * Private version of xmlParseExternalEntity()
13095  *
13096  * Returns 0 if the entity is well formed, -1 in case of args problem and
13097  *    the parser error code otherwise
13098  */
13099 
13100 static xmlParserErrors
13101 xmlParseExternalEntityPrivate(xmlDocPtr doc, xmlParserCtxtPtr oldctxt,
13102                   xmlSAXHandlerPtr sax,
13103               void *user_data, int depth, const xmlChar *URL,
13104               const xmlChar *ID, xmlNodePtr *list) {
13105     xmlParserCtxtPtr ctxt;
13106     xmlDocPtr newDoc;
13107     xmlNodePtr newRoot;
13108     xmlSAXHandlerPtr oldsax = NULL;
13109     xmlParserErrors ret = XML_ERR_OK;
13110     xmlChar start[4];
13111     xmlCharEncoding enc;
13112 
13113     if (((depth &gt; 40) &amp;&amp;
13114     ((oldctxt == NULL) || (oldctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) ||
13115     (depth &gt; 1024)) {
13116     return(XML_ERR_ENTITY_LOOP);
13117     }
13118 
13119     if (list != NULL)
13120         *list = NULL;
13121     if ((URL == NULL) &amp;&amp; (ID == NULL))
13122     return(XML_ERR_INTERNAL_ERROR);
13123     if (doc == NULL)
13124     return(XML_ERR_INTERNAL_ERROR);
13125 
13126 
13127     ctxt = xmlCreateEntityParserCtxtInternal(URL, ID, NULL, oldctxt);
13128     if (ctxt == NULL) return(XML_WAR_UNDECLARED_ENTITY);
13129     ctxt-&gt;userData = ctxt;
13130     if (oldctxt != NULL) {
13131     ctxt-&gt;_private = oldctxt-&gt;_private;
13132     ctxt-&gt;loadsubset = oldctxt-&gt;loadsubset;
13133     ctxt-&gt;validate = oldctxt-&gt;validate;
13134     ctxt-&gt;external = oldctxt-&gt;external;
13135     ctxt-&gt;record_info = oldctxt-&gt;record_info;
13136     ctxt-&gt;node_seq.maximum = oldctxt-&gt;node_seq.maximum;
13137     ctxt-&gt;node_seq.length = oldctxt-&gt;node_seq.length;
13138     ctxt-&gt;node_seq.buffer = oldctxt-&gt;node_seq.buffer;
13139     } else {
13140     /*
13141      * Doing validity checking on chunk without context
13142      * doesn&#39;t make sense
13143      */
13144     ctxt-&gt;_private = NULL;
13145     ctxt-&gt;validate = 0;
13146     ctxt-&gt;external = 2;
13147     ctxt-&gt;loadsubset = 0;
13148     }
13149     if (sax != NULL) {
13150     oldsax = ctxt-&gt;sax;
13151         ctxt-&gt;sax = sax;
13152     if (user_data != NULL)
13153         ctxt-&gt;userData = user_data;
13154     }
13155     xmlDetectSAX2(ctxt);
13156     newDoc = xmlNewDoc(BAD_CAST &quot;1.0&quot;);
13157     if (newDoc == NULL) {
13158     ctxt-&gt;node_seq.maximum = 0;
13159     ctxt-&gt;node_seq.length = 0;
13160     ctxt-&gt;node_seq.buffer = NULL;
13161     xmlFreeParserCtxt(ctxt);
13162     return(XML_ERR_INTERNAL_ERROR);
13163     }
13164     newDoc-&gt;properties = XML_DOC_INTERNAL;
13165     newDoc-&gt;intSubset = doc-&gt;intSubset;
13166     newDoc-&gt;extSubset = doc-&gt;extSubset;
13167     newDoc-&gt;dict = doc-&gt;dict;
13168     xmlDictReference(newDoc-&gt;dict);
13169 
13170     if (doc-&gt;URL != NULL) {
13171     newDoc-&gt;URL = xmlStrdup(doc-&gt;URL);
13172     }
13173     newRoot = xmlNewDocNode(newDoc, NULL, BAD_CAST &quot;pseudoroot&quot;, NULL);
13174     if (newRoot == NULL) {
13175     if (sax != NULL)
13176         ctxt-&gt;sax = oldsax;
13177     ctxt-&gt;node_seq.maximum = 0;
13178     ctxt-&gt;node_seq.length = 0;
13179     ctxt-&gt;node_seq.buffer = NULL;
13180     xmlFreeParserCtxt(ctxt);
13181     newDoc-&gt;intSubset = NULL;
13182     newDoc-&gt;extSubset = NULL;
13183         xmlFreeDoc(newDoc);
13184     return(XML_ERR_INTERNAL_ERROR);
13185     }
13186     xmlAddChild((xmlNodePtr) newDoc, newRoot);
13187     nodePush(ctxt, newDoc-&gt;children);
13188     ctxt-&gt;myDoc = doc;
13189     newRoot-&gt;doc = doc;
13190 
13191     /*
13192      * Get the 4 first bytes and decode the charset
13193      * if enc != XML_CHAR_ENCODING_NONE
13194      * plug some encoding conversion routines.
13195      */
13196     GROW;
13197     if ((ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur) &gt;= 4) {
13198     start[0] = RAW;
13199     start[1] = NXT(1);
13200     start[2] = NXT(2);
13201     start[3] = NXT(3);
13202     enc = xmlDetectCharEncoding(start, 4);
13203     if (enc != XML_CHAR_ENCODING_NONE) {
13204         xmlSwitchEncoding(ctxt, enc);
13205     }
13206     }
13207 
13208     /*
13209      * Parse a possible text declaration first
13210      */
13211     if ((CMP5(CUR_PTR, &#39;&lt;&#39;, &#39;?&#39;, &#39;x&#39;, &#39;m&#39;, &#39;l&#39;)) &amp;&amp; (IS_BLANK_CH(NXT(5)))) {
13212     xmlParseTextDecl(ctxt);
13213     }
13214 
13215     ctxt-&gt;instate = XML_PARSER_CONTENT;
13216     ctxt-&gt;depth = depth;
13217 
13218     xmlParseContent(ctxt);
13219 
13220     if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
13221     xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13222     } else if (RAW != 0) {
13223     xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
13224     }
13225     if (ctxt-&gt;node != newDoc-&gt;children) {
13226     xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13227     }
13228 
13229     if (!ctxt-&gt;wellFormed) {
13230         if (ctxt-&gt;errNo == 0)
13231         ret = XML_ERR_INTERNAL_ERROR;
13232     else
13233         ret = (xmlParserErrors)ctxt-&gt;errNo;
13234     } else {
13235     if (list != NULL) {
13236         xmlNodePtr cur;
13237 
13238         /*
13239          * Return the newly created nodeset after unlinking it from
13240          * they pseudo parent.
13241          */
13242         cur = newDoc-&gt;children-&gt;children;
13243         *list = cur;
13244         while (cur != NULL) {
13245         cur-&gt;parent = NULL;
13246         cur = cur-&gt;next;
13247         }
13248             newDoc-&gt;children-&gt;children = NULL;
13249     }
13250     ret = XML_ERR_OK;
13251     }
13252 
13253     /*
13254      * Record in the parent context the number of entities replacement
13255      * done when parsing that reference.
13256      */
13257     if (oldctxt != NULL)
13258         oldctxt-&gt;nbentities += ctxt-&gt;nbentities;
13259 
13260     /*
13261      * Also record the size of the entity parsed
13262      */
13263     if (ctxt-&gt;input != NULL &amp;&amp; oldctxt != NULL) {
13264     oldctxt-&gt;sizeentities += ctxt-&gt;input-&gt;consumed;
13265     oldctxt-&gt;sizeentities += (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
13266     }
13267     /*
13268      * And record the last error if any
13269      */
13270     if ((oldctxt != NULL) &amp;&amp; (ctxt-&gt;lastError.code != XML_ERR_OK))
13271         xmlCopyError(&amp;ctxt-&gt;lastError, &amp;oldctxt-&gt;lastError);
13272 
13273     if (sax != NULL)
13274     ctxt-&gt;sax = oldsax;
13275     if (oldctxt != NULL) {
13276         oldctxt-&gt;node_seq.maximum = ctxt-&gt;node_seq.maximum;
13277         oldctxt-&gt;node_seq.length = ctxt-&gt;node_seq.length;
13278         oldctxt-&gt;node_seq.buffer = ctxt-&gt;node_seq.buffer;
13279     }
13280     ctxt-&gt;node_seq.maximum = 0;
13281     ctxt-&gt;node_seq.length = 0;
13282     ctxt-&gt;node_seq.buffer = NULL;
13283     xmlFreeParserCtxt(ctxt);
13284     newDoc-&gt;intSubset = NULL;
13285     newDoc-&gt;extSubset = NULL;
13286     xmlFreeDoc(newDoc);
13287 
13288     return(ret);
13289 }
13290 
13291 #ifdef LIBXML_SAX1_ENABLED
13292 /**
13293  * xmlParseExternalEntity:
13294  * @doc:  the document the chunk pertains to
13295  * @sax:  the SAX handler bloc (possibly NULL)
13296  * @user_data:  The user data returned on SAX callbacks (possibly NULL)
13297  * @depth:  Used for loop detection, use 0
13298  * @URL:  the URL for the entity to load
13299  * @ID:  the System ID for the entity to load
13300  * @lst:  the return value for the set of parsed nodes
13301  *
13302  * Parse an external general entity
13303  * An external general parsed entity is well-formed if it matches the
13304  * production labeled extParsedEnt.
13305  *
13306  * [78] extParsedEnt ::= TextDecl? content
13307  *
13308  * Returns 0 if the entity is well formed, -1 in case of args problem and
13309  *    the parser error code otherwise
13310  */
13311 
13312 int
13313 xmlParseExternalEntity(xmlDocPtr doc, xmlSAXHandlerPtr sax, void *user_data,
13314       int depth, const xmlChar *URL, const xmlChar *ID, xmlNodePtr *lst) {
13315     return(xmlParseExternalEntityPrivate(doc, NULL, sax, user_data, depth, URL,
13316                                ID, lst));
13317 }
13318 
13319 /**
13320  * xmlParseBalancedChunkMemory:
13321  * @doc:  the document the chunk pertains to
13322  * @sax:  the SAX handler bloc (possibly NULL)
13323  * @user_data:  The user data returned on SAX callbacks (possibly NULL)
13324  * @depth:  Used for loop detection, use 0
13325  * @string:  the input string in UTF8 or ISO-Latin (zero terminated)
13326  * @lst:  the return value for the set of parsed nodes
13327  *
13328  * Parse a well-balanced chunk of an XML document
13329  * called by the parser
13330  * The allowed sequence for the Well Balanced Chunk is the one defined by
13331  * the content production in the XML grammar:
13332  *
13333  * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
13334  *
13335  * Returns 0 if the chunk is well balanced, -1 in case of args problem and
13336  *    the parser error code otherwise
13337  */
13338 
13339 int
13340 xmlParseBalancedChunkMemory(xmlDocPtr doc, xmlSAXHandlerPtr sax,
13341      void *user_data, int depth, const xmlChar *string, xmlNodePtr *lst) {
13342     return xmlParseBalancedChunkMemoryRecover( doc, sax, user_data,
13343                                                 depth, string, lst, 0 );
13344 }
13345 #endif /* LIBXML_SAX1_ENABLED */
13346 
13347 /**
13348  * xmlParseBalancedChunkMemoryInternal:
13349  * @oldctxt:  the existing parsing context
13350  * @string:  the input string in UTF8 or ISO-Latin (zero terminated)
13351  * @user_data:  the user data field for the parser context
13352  * @lst:  the return value for the set of parsed nodes
13353  *
13354  *
13355  * Parse a well-balanced chunk of an XML document
13356  * called by the parser
13357  * The allowed sequence for the Well Balanced Chunk is the one defined by
13358  * the content production in the XML grammar:
13359  *
13360  * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
13361  *
13362  * Returns XML_ERR_OK if the chunk is well balanced, and the parser
13363  * error code otherwise
13364  *
13365  * In case recover is set to 1, the nodelist will not be empty even if
13366  * the parsed chunk is not well balanced.
13367  */
13368 static xmlParserErrors
13369 xmlParseBalancedChunkMemoryInternal(xmlParserCtxtPtr oldctxt,
13370     const xmlChar *string, void *user_data, xmlNodePtr *lst) {
13371     xmlParserCtxtPtr ctxt;
13372     xmlDocPtr newDoc = NULL;
13373     xmlNodePtr newRoot;
13374     xmlSAXHandlerPtr oldsax = NULL;
13375     xmlNodePtr content = NULL;
13376     xmlNodePtr last = NULL;
13377     int size;
13378     xmlParserErrors ret = XML_ERR_OK;
13379 #ifdef SAX2
13380     int i;
13381 #endif
13382 
13383     if (((oldctxt-&gt;depth &gt; 40) &amp;&amp; ((oldctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) ||
13384         (oldctxt-&gt;depth &gt;  1024)) {
13385     return(XML_ERR_ENTITY_LOOP);
13386     }
13387 
13388 
13389     if (lst != NULL)
13390         *lst = NULL;
13391     if (string == NULL)
13392         return(XML_ERR_INTERNAL_ERROR);
13393 
13394     size = xmlStrlen(string);
13395 
13396     ctxt = xmlCreateMemoryParserCtxt((char *) string, size);
13397     if (ctxt == NULL) return(XML_WAR_UNDECLARED_ENTITY);
13398     if (user_data != NULL)
13399     ctxt-&gt;userData = user_data;
13400     else
13401     ctxt-&gt;userData = ctxt;
13402     if (ctxt-&gt;dict != NULL) xmlDictFree(ctxt-&gt;dict);
13403     ctxt-&gt;dict = oldctxt-&gt;dict;
13404     ctxt-&gt;input_id = oldctxt-&gt;input_id + 1;
13405     ctxt-&gt;str_xml = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xml&quot;, 3);
13406     ctxt-&gt;str_xmlns = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xmlns&quot;, 5);
13407     ctxt-&gt;str_xml_ns = xmlDictLookup(ctxt-&gt;dict, XML_XML_NAMESPACE, 36);
13408 
13409 #ifdef SAX2
13410     /* propagate namespaces down the entity */
13411     for (i = 0;i &lt; oldctxt-&gt;nsNr;i += 2) {
13412         nsPush(ctxt, oldctxt-&gt;nsTab[i], oldctxt-&gt;nsTab[i+1]);
13413     }
13414 #endif
13415 
13416     oldsax = ctxt-&gt;sax;
13417     ctxt-&gt;sax = oldctxt-&gt;sax;
13418     xmlDetectSAX2(ctxt);
13419     ctxt-&gt;replaceEntities = oldctxt-&gt;replaceEntities;
13420     ctxt-&gt;options = oldctxt-&gt;options;
13421 
13422     ctxt-&gt;_private = oldctxt-&gt;_private;
13423     if (oldctxt-&gt;myDoc == NULL) {
13424     newDoc = xmlNewDoc(BAD_CAST &quot;1.0&quot;);
13425     if (newDoc == NULL) {
13426         ctxt-&gt;sax = oldsax;
13427         ctxt-&gt;dict = NULL;
13428         xmlFreeParserCtxt(ctxt);
13429         return(XML_ERR_INTERNAL_ERROR);
13430     }
13431     newDoc-&gt;properties = XML_DOC_INTERNAL;
13432     newDoc-&gt;dict = ctxt-&gt;dict;
13433     xmlDictReference(newDoc-&gt;dict);
13434     ctxt-&gt;myDoc = newDoc;
13435     } else {
13436     ctxt-&gt;myDoc = oldctxt-&gt;myDoc;
13437         content = ctxt-&gt;myDoc-&gt;children;
13438     last = ctxt-&gt;myDoc-&gt;last;
13439     }
13440     newRoot = xmlNewDocNode(ctxt-&gt;myDoc, NULL, BAD_CAST &quot;pseudoroot&quot;, NULL);
13441     if (newRoot == NULL) {
13442     ctxt-&gt;sax = oldsax;
13443     ctxt-&gt;dict = NULL;
13444     xmlFreeParserCtxt(ctxt);
13445     if (newDoc != NULL) {
13446         xmlFreeDoc(newDoc);
13447     }
13448     return(XML_ERR_INTERNAL_ERROR);
13449     }
13450     ctxt-&gt;myDoc-&gt;children = NULL;
13451     ctxt-&gt;myDoc-&gt;last = NULL;
13452     xmlAddChild((xmlNodePtr) ctxt-&gt;myDoc, newRoot);
13453     nodePush(ctxt, ctxt-&gt;myDoc-&gt;children);
13454     ctxt-&gt;instate = XML_PARSER_CONTENT;
13455     ctxt-&gt;depth = oldctxt-&gt;depth + 1;
13456 
13457     ctxt-&gt;validate = 0;
13458     ctxt-&gt;loadsubset = oldctxt-&gt;loadsubset;
13459     if ((oldctxt-&gt;validate) || (oldctxt-&gt;replaceEntities != 0)) {
13460     /*
13461      * ID/IDREF registration will be done in xmlValidateElement below
13462      */
13463     ctxt-&gt;loadsubset |= XML_SKIP_IDS;
13464     }
13465     ctxt-&gt;dictNames = oldctxt-&gt;dictNames;
13466     ctxt-&gt;attsDefault = oldctxt-&gt;attsDefault;
13467     ctxt-&gt;attsSpecial = oldctxt-&gt;attsSpecial;
13468 
13469     xmlParseContent(ctxt);
13470     if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
13471     xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13472     } else if (RAW != 0) {
13473     xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
13474     }
13475     if (ctxt-&gt;node != ctxt-&gt;myDoc-&gt;children) {
13476     xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13477     }
13478 
13479     if (!ctxt-&gt;wellFormed) {
13480         if (ctxt-&gt;errNo == 0)
13481         ret = XML_ERR_INTERNAL_ERROR;
13482     else
13483         ret = (xmlParserErrors)ctxt-&gt;errNo;
13484     } else {
13485       ret = XML_ERR_OK;
13486     }
13487 
13488     if ((lst != NULL) &amp;&amp; (ret == XML_ERR_OK)) {
13489     xmlNodePtr cur;
13490 
13491     /*
13492      * Return the newly created nodeset after unlinking it from
13493      * they pseudo parent.
13494      */
13495     cur = ctxt-&gt;myDoc-&gt;children-&gt;children;
13496     *lst = cur;
13497     while (cur != NULL) {
13498 #ifdef LIBXML_VALID_ENABLED
13499         if ((oldctxt-&gt;validate) &amp;&amp; (oldctxt-&gt;wellFormed) &amp;&amp;
13500         (oldctxt-&gt;myDoc) &amp;&amp; (oldctxt-&gt;myDoc-&gt;intSubset) &amp;&amp;
13501         (cur-&gt;type == XML_ELEMENT_NODE)) {
13502         oldctxt-&gt;valid &amp;= xmlValidateElement(&amp;oldctxt-&gt;vctxt,
13503             oldctxt-&gt;myDoc, cur);
13504         }
13505 #endif /* LIBXML_VALID_ENABLED */
13506         cur-&gt;parent = NULL;
13507         cur = cur-&gt;next;
13508     }
13509     ctxt-&gt;myDoc-&gt;children-&gt;children = NULL;
13510     }
13511     if (ctxt-&gt;myDoc != NULL) {
13512     xmlFreeNode(ctxt-&gt;myDoc-&gt;children);
13513         ctxt-&gt;myDoc-&gt;children = content;
13514         ctxt-&gt;myDoc-&gt;last = last;
13515     }
13516 
13517     /*
13518      * Record in the parent context the number of entities replacement
13519      * done when parsing that reference.
13520      */
13521     if (oldctxt != NULL)
13522         oldctxt-&gt;nbentities += ctxt-&gt;nbentities;
13523 
13524     /*
13525      * Also record the last error if any
13526      */
13527     if (ctxt-&gt;lastError.code != XML_ERR_OK)
13528         xmlCopyError(&amp;ctxt-&gt;lastError, &amp;oldctxt-&gt;lastError);
13529 
13530     ctxt-&gt;sax = oldsax;
13531     ctxt-&gt;dict = NULL;
13532     ctxt-&gt;attsDefault = NULL;
13533     ctxt-&gt;attsSpecial = NULL;
13534     xmlFreeParserCtxt(ctxt);
13535     if (newDoc != NULL) {
13536     xmlFreeDoc(newDoc);
13537     }
13538 
13539     return(ret);
13540 }
13541 
13542 /**
13543  * xmlParseInNodeContext:
13544  * @node:  the context node
13545  * @data:  the input string
13546  * @datalen:  the input string length in bytes
13547  * @options:  a combination of xmlParserOption
13548  * @lst:  the return value for the set of parsed nodes
13549  *
13550  * Parse a well-balanced chunk of an XML document
13551  * within the context (DTD, namespaces, etc ...) of the given node.
13552  *
13553  * The allowed sequence for the data is a Well Balanced Chunk defined by
13554  * the content production in the XML grammar:
13555  *
13556  * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
13557  *
13558  * Returns XML_ERR_OK if the chunk is well balanced, and the parser
13559  * error code otherwise
13560  */
13561 xmlParserErrors
13562 xmlParseInNodeContext(xmlNodePtr node, const char *data, int datalen,
13563                       int options, xmlNodePtr *lst) {
13564 #ifdef SAX2
13565     xmlParserCtxtPtr ctxt;
13566     xmlDocPtr doc = NULL;
13567     xmlNodePtr fake, cur;
13568     int nsnr = 0;
13569 
13570     xmlParserErrors ret = XML_ERR_OK;
13571 
13572     /*
13573      * check all input parameters, grab the document
13574      */
13575     if ((lst == NULL) || (node == NULL) || (data == NULL) || (datalen &lt; 0))
13576         return(XML_ERR_INTERNAL_ERROR);
13577     switch (node-&gt;type) {
13578         case XML_ELEMENT_NODE:
13579         case XML_ATTRIBUTE_NODE:
13580         case XML_TEXT_NODE:
13581         case XML_CDATA_SECTION_NODE:
13582         case XML_ENTITY_REF_NODE:
13583         case XML_PI_NODE:
13584         case XML_COMMENT_NODE:
13585         case XML_DOCUMENT_NODE:
13586         case XML_HTML_DOCUMENT_NODE:
13587         break;
13588     default:
13589         return(XML_ERR_INTERNAL_ERROR);
13590 
13591     }
13592     while ((node != NULL) &amp;&amp; (node-&gt;type != XML_ELEMENT_NODE) &amp;&amp;
13593            (node-&gt;type != XML_DOCUMENT_NODE) &amp;&amp;
13594        (node-&gt;type != XML_HTML_DOCUMENT_NODE))
13595     node = node-&gt;parent;
13596     if (node == NULL)
13597     return(XML_ERR_INTERNAL_ERROR);
13598     if (node-&gt;type == XML_ELEMENT_NODE)
13599     doc = node-&gt;doc;
13600     else
13601         doc = (xmlDocPtr) node;
13602     if (doc == NULL)
13603     return(XML_ERR_INTERNAL_ERROR);
13604 
13605     /*
13606      * allocate a context and set-up everything not related to the
13607      * node position in the tree
13608      */
13609     if (doc-&gt;type == XML_DOCUMENT_NODE)
13610     ctxt = xmlCreateMemoryParserCtxt((char *) data, datalen);
13611 #ifdef LIBXML_HTML_ENABLED
13612     else if (doc-&gt;type == XML_HTML_DOCUMENT_NODE) {
13613     ctxt = htmlCreateMemoryParserCtxt((char *) data, datalen);
13614         /*
13615          * When parsing in context, it makes no sense to add implied
13616          * elements like html/body/etc...
13617          */
13618         options |= HTML_PARSE_NOIMPLIED;
13619     }
13620 #endif
13621     else
13622         return(XML_ERR_INTERNAL_ERROR);
13623 
13624     if (ctxt == NULL)
13625         return(XML_ERR_NO_MEMORY);
13626 
13627     /*
13628      * Use input doc&#39;s dict if present, else assure XML_PARSE_NODICT is set.
13629      * We need a dictionary for xmlDetectSAX2, so if there&#39;s no doc dict
13630      * we must wait until the last moment to free the original one.
13631      */
13632     if (doc-&gt;dict != NULL) {
13633         if (ctxt-&gt;dict != NULL)
13634         xmlDictFree(ctxt-&gt;dict);
13635     ctxt-&gt;dict = doc-&gt;dict;
13636     } else
13637         options |= XML_PARSE_NODICT;
13638 
13639     if (doc-&gt;encoding != NULL) {
13640         xmlCharEncodingHandlerPtr hdlr;
13641 
13642         if (ctxt-&gt;encoding != NULL)
13643         xmlFree((xmlChar *) ctxt-&gt;encoding);
13644         ctxt-&gt;encoding = xmlStrdup((const xmlChar *) doc-&gt;encoding);
13645 
13646         hdlr = xmlFindCharEncodingHandler((const char *) doc-&gt;encoding);
13647         if (hdlr != NULL) {
13648             xmlSwitchToEncoding(ctxt, hdlr);
13649     } else {
13650             return(XML_ERR_UNSUPPORTED_ENCODING);
13651         }
13652     }
13653 
13654     xmlCtxtUseOptionsInternal(ctxt, options, NULL);
13655     xmlDetectSAX2(ctxt);
13656     ctxt-&gt;myDoc = doc;
13657     /* parsing in context, i.e. as within existing content */
13658     ctxt-&gt;input_id = 2;
13659     ctxt-&gt;instate = XML_PARSER_CONTENT;
13660 
13661     fake = xmlNewComment(NULL);
13662     if (fake == NULL) {
13663         xmlFreeParserCtxt(ctxt);
13664     return(XML_ERR_NO_MEMORY);
13665     }
13666     xmlAddChild(node, fake);
13667 
13668     if (node-&gt;type == XML_ELEMENT_NODE) {
13669     nodePush(ctxt, node);
13670     /*
13671      * initialize the SAX2 namespaces stack
13672      */
13673     cur = node;
13674     while ((cur != NULL) &amp;&amp; (cur-&gt;type == XML_ELEMENT_NODE)) {
13675         xmlNsPtr ns = cur-&gt;nsDef;
13676         const xmlChar *iprefix, *ihref;
13677 
13678         while (ns != NULL) {
13679         if (ctxt-&gt;dict) {
13680             iprefix = xmlDictLookup(ctxt-&gt;dict, ns-&gt;prefix, -1);
13681             ihref = xmlDictLookup(ctxt-&gt;dict, ns-&gt;href, -1);
13682         } else {
13683             iprefix = ns-&gt;prefix;
13684             ihref = ns-&gt;href;
13685         }
13686 
13687             if (xmlGetNamespace(ctxt, iprefix) == NULL) {
13688             nsPush(ctxt, iprefix, ihref);
13689             nsnr++;
13690         }
13691         ns = ns-&gt;next;
13692         }
13693         cur = cur-&gt;parent;
13694     }
13695     }
13696 
13697     if ((ctxt-&gt;validate) || (ctxt-&gt;replaceEntities != 0)) {
13698     /*
13699      * ID/IDREF registration will be done in xmlValidateElement below
13700      */
13701     ctxt-&gt;loadsubset |= XML_SKIP_IDS;
13702     }
13703 
13704 #ifdef LIBXML_HTML_ENABLED
13705     if (doc-&gt;type == XML_HTML_DOCUMENT_NODE)
13706         __htmlParseContent(ctxt);
13707     else
13708 #endif
13709     xmlParseContent(ctxt);
13710 
13711     nsPop(ctxt, nsnr);
13712     if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
13713     xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13714     } else if (RAW != 0) {
13715     xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
13716     }
13717     if ((ctxt-&gt;node != NULL) &amp;&amp; (ctxt-&gt;node != node)) {
13718     xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13719     ctxt-&gt;wellFormed = 0;
13720     }
13721 
13722     if (!ctxt-&gt;wellFormed) {
13723         if (ctxt-&gt;errNo == 0)
13724         ret = XML_ERR_INTERNAL_ERROR;
13725     else
13726         ret = (xmlParserErrors)ctxt-&gt;errNo;
13727     } else {
13728         ret = XML_ERR_OK;
13729     }
13730 
13731     /*
13732      * Return the newly created nodeset after unlinking it from
13733      * the pseudo sibling.
13734      */
13735 
13736     cur = fake-&gt;next;
13737     fake-&gt;next = NULL;
13738     node-&gt;last = fake;
13739 
13740     if (cur != NULL) {
13741     cur-&gt;prev = NULL;
13742     }
13743 
13744     *lst = cur;
13745 
13746     while (cur != NULL) {
13747     cur-&gt;parent = NULL;
13748     cur = cur-&gt;next;
13749     }
13750 
13751     xmlUnlinkNode(fake);
13752     xmlFreeNode(fake);
13753 
13754 
13755     if (ret != XML_ERR_OK) {
13756         xmlFreeNodeList(*lst);
13757     *lst = NULL;
13758     }
13759 
13760     if (doc-&gt;dict != NULL)
13761         ctxt-&gt;dict = NULL;
13762     xmlFreeParserCtxt(ctxt);
13763 
13764     return(ret);
13765 #else /* !SAX2 */
13766     return(XML_ERR_INTERNAL_ERROR);
13767 #endif
13768 }
13769 
13770 #ifdef LIBXML_SAX1_ENABLED
13771 /**
13772  * xmlParseBalancedChunkMemoryRecover:
13773  * @doc:  the document the chunk pertains to
13774  * @sax:  the SAX handler bloc (possibly NULL)
13775  * @user_data:  The user data returned on SAX callbacks (possibly NULL)
13776  * @depth:  Used for loop detection, use 0
13777  * @string:  the input string in UTF8 or ISO-Latin (zero terminated)
13778  * @lst:  the return value for the set of parsed nodes
13779  * @recover: return nodes even if the data is broken (use 0)
13780  *
13781  *
13782  * Parse a well-balanced chunk of an XML document
13783  * called by the parser
13784  * The allowed sequence for the Well Balanced Chunk is the one defined by
13785  * the content production in the XML grammar:
13786  *
13787  * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
13788  *
13789  * Returns 0 if the chunk is well balanced, -1 in case of args problem and
13790  *    the parser error code otherwise
13791  *
13792  * In case recover is set to 1, the nodelist will not be empty even if
13793  * the parsed chunk is not well balanced, assuming the parsing succeeded to
13794  * some extent.
13795  */
13796 int
13797 xmlParseBalancedChunkMemoryRecover(xmlDocPtr doc, xmlSAXHandlerPtr sax,
13798      void *user_data, int depth, const xmlChar *string, xmlNodePtr *lst,
13799      int recover) {
13800     xmlParserCtxtPtr ctxt;
13801     xmlDocPtr newDoc;
13802     xmlSAXHandlerPtr oldsax = NULL;
13803     xmlNodePtr content, newRoot;
13804     int size;
13805     int ret = 0;
13806 
13807     if (depth &gt; 40) {
13808     return(XML_ERR_ENTITY_LOOP);
13809     }
13810 
13811 
13812     if (lst != NULL)
13813         *lst = NULL;
13814     if (string == NULL)
13815         return(-1);
13816 
13817     size = xmlStrlen(string);
13818 
13819     ctxt = xmlCreateMemoryParserCtxt((char *) string, size);
13820     if (ctxt == NULL) return(-1);
13821     ctxt-&gt;userData = ctxt;
13822     if (sax != NULL) {
13823     oldsax = ctxt-&gt;sax;
13824         ctxt-&gt;sax = sax;
13825     if (user_data != NULL)
13826         ctxt-&gt;userData = user_data;
13827     }
13828     newDoc = xmlNewDoc(BAD_CAST &quot;1.0&quot;);
13829     if (newDoc == NULL) {
13830     xmlFreeParserCtxt(ctxt);
13831     return(-1);
13832     }
13833     newDoc-&gt;properties = XML_DOC_INTERNAL;
13834     if ((doc != NULL) &amp;&amp; (doc-&gt;dict != NULL)) {
13835         xmlDictFree(ctxt-&gt;dict);
13836     ctxt-&gt;dict = doc-&gt;dict;
13837     xmlDictReference(ctxt-&gt;dict);
13838     ctxt-&gt;str_xml = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xml&quot;, 3);
13839     ctxt-&gt;str_xmlns = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xmlns&quot;, 5);
13840     ctxt-&gt;str_xml_ns = xmlDictLookup(ctxt-&gt;dict, XML_XML_NAMESPACE, 36);
13841     ctxt-&gt;dictNames = 1;
13842     } else {
13843     xmlCtxtUseOptionsInternal(ctxt, XML_PARSE_NODICT, NULL);
13844     }
13845     if (doc != NULL) {
13846     newDoc-&gt;intSubset = doc-&gt;intSubset;
13847     newDoc-&gt;extSubset = doc-&gt;extSubset;
13848     }
13849     newRoot = xmlNewDocNode(newDoc, NULL, BAD_CAST &quot;pseudoroot&quot;, NULL);
13850     if (newRoot == NULL) {
13851     if (sax != NULL)
13852         ctxt-&gt;sax = oldsax;
13853     xmlFreeParserCtxt(ctxt);
13854     newDoc-&gt;intSubset = NULL;
13855     newDoc-&gt;extSubset = NULL;
13856         xmlFreeDoc(newDoc);
13857     return(-1);
13858     }
13859     xmlAddChild((xmlNodePtr) newDoc, newRoot);
13860     nodePush(ctxt, newRoot);
13861     if (doc == NULL) {
13862     ctxt-&gt;myDoc = newDoc;
13863     } else {
13864     ctxt-&gt;myDoc = newDoc;
13865     newDoc-&gt;children-&gt;doc = doc;
13866     /* Ensure that doc has XML spec namespace */
13867     xmlSearchNsByHref(doc, (xmlNodePtr)doc, XML_XML_NAMESPACE);
13868     newDoc-&gt;oldNs = doc-&gt;oldNs;
13869     }
13870     ctxt-&gt;instate = XML_PARSER_CONTENT;
13871     ctxt-&gt;input_id = 2;
13872     ctxt-&gt;depth = depth;
13873 
13874     /*
13875      * Doing validity checking on chunk doesn&#39;t make sense
13876      */
13877     ctxt-&gt;validate = 0;
13878     ctxt-&gt;loadsubset = 0;
13879     xmlDetectSAX2(ctxt);
13880 
13881     if ( doc != NULL ){
13882         content = doc-&gt;children;
13883         doc-&gt;children = NULL;
13884         xmlParseContent(ctxt);
13885         doc-&gt;children = content;
13886     }
13887     else {
13888         xmlParseContent(ctxt);
13889     }
13890     if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
13891     xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13892     } else if (RAW != 0) {
13893     xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
13894     }
13895     if (ctxt-&gt;node != newDoc-&gt;children) {
13896     xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13897     }
13898 
13899     if (!ctxt-&gt;wellFormed) {
13900         if (ctxt-&gt;errNo == 0)
13901         ret = 1;
13902     else
13903         ret = ctxt-&gt;errNo;
13904     } else {
13905       ret = 0;
13906     }
13907 
13908     if ((lst != NULL) &amp;&amp; ((ret == 0) || (recover == 1))) {
13909     xmlNodePtr cur;
13910 
13911     /*
13912      * Return the newly created nodeset after unlinking it from
13913      * they pseudo parent.
13914      */
13915     cur = newDoc-&gt;children-&gt;children;
13916     *lst = cur;
13917     while (cur != NULL) {
13918         xmlSetTreeDoc(cur, doc);
13919         cur-&gt;parent = NULL;
13920         cur = cur-&gt;next;
13921     }
13922     newDoc-&gt;children-&gt;children = NULL;
13923     }
13924 
13925     if (sax != NULL)
13926     ctxt-&gt;sax = oldsax;
13927     xmlFreeParserCtxt(ctxt);
13928     newDoc-&gt;intSubset = NULL;
13929     newDoc-&gt;extSubset = NULL;
<a name="101" id="anc101"></a><span class="line-added">13930     if(doc != NULL)</span>
13931     newDoc-&gt;oldNs = NULL;
13932     xmlFreeDoc(newDoc);
13933 
13934     return(ret);
13935 }
13936 
13937 /**
13938  * xmlSAXParseEntity:
13939  * @sax:  the SAX handler block
13940  * @filename:  the filename
13941  *
13942  * parse an XML external entity out of context and build a tree.
13943  * It use the given SAX function block to handle the parsing callback.
13944  * If sax is NULL, fallback to the default DOM tree building routines.
13945  *
13946  * [78] extParsedEnt ::= TextDecl? content
13947  *
13948  * This correspond to a &quot;Well Balanced&quot; chunk
13949  *
13950  * Returns the resulting document tree
13951  */
13952 
13953 xmlDocPtr
13954 xmlSAXParseEntity(xmlSAXHandlerPtr sax, const char *filename) {
13955     xmlDocPtr ret;
13956     xmlParserCtxtPtr ctxt;
13957 
13958     ctxt = xmlCreateFileParserCtxt(filename);
13959     if (ctxt == NULL) {
13960     return(NULL);
13961     }
13962     if (sax != NULL) {
13963     if (ctxt-&gt;sax != NULL)
13964         xmlFree(ctxt-&gt;sax);
13965         ctxt-&gt;sax = sax;
13966         ctxt-&gt;userData = NULL;
13967     }
13968 
13969     xmlParseExtParsedEnt(ctxt);
13970 
13971     if (ctxt-&gt;wellFormed)
13972     ret = ctxt-&gt;myDoc;
13973     else {
13974         ret = NULL;
13975         xmlFreeDoc(ctxt-&gt;myDoc);
13976         ctxt-&gt;myDoc = NULL;
13977     }
13978     if (sax != NULL)
13979         ctxt-&gt;sax = NULL;
13980     xmlFreeParserCtxt(ctxt);
13981 
13982     return(ret);
13983 }
13984 
13985 /**
13986  * xmlParseEntity:
13987  * @filename:  the filename
13988  *
13989  * parse an XML external entity out of context and build a tree.
13990  *
13991  * [78] extParsedEnt ::= TextDecl? content
13992  *
13993  * This correspond to a &quot;Well Balanced&quot; chunk
13994  *
13995  * Returns the resulting document tree
13996  */
13997 
13998 xmlDocPtr
13999 xmlParseEntity(const char *filename) {
14000     return(xmlSAXParseEntity(NULL, filename));
14001 }
14002 #endif /* LIBXML_SAX1_ENABLED */
14003 
14004 /**
14005  * xmlCreateEntityParserCtxtInternal:
14006  * @URL:  the entity URL
14007  * @ID:  the entity PUBLIC ID
14008  * @base:  a possible base for the target URI
14009  * @pctx:  parser context used to set options on new context
14010  *
14011  * Create a parser context for an external entity
14012  * Automatic support for ZLIB/Compress compressed document is provided
14013  * by default if found at compile-time.
14014  *
14015  * Returns the new parser context or NULL
14016  */
14017 static xmlParserCtxtPtr
14018 xmlCreateEntityParserCtxtInternal(const xmlChar *URL, const xmlChar *ID,
14019                       const xmlChar *base, xmlParserCtxtPtr pctx) {
14020     xmlParserCtxtPtr ctxt;
14021     xmlParserInputPtr inputStream;
14022     char *directory = NULL;
14023     xmlChar *uri;
14024 
14025     ctxt = xmlNewParserCtxt();
14026     if (ctxt == NULL) {
14027     return(NULL);
14028     }
14029 
14030     if (pctx != NULL) {
14031         ctxt-&gt;options = pctx-&gt;options;
14032         ctxt-&gt;_private = pctx-&gt;_private;
14033     /*
14034      * this is a subparser of pctx, so the input_id should be
14035      * incremented to distinguish from main entity
14036      */
14037     ctxt-&gt;input_id = pctx-&gt;input_id + 1;
14038     }
14039 
<a name="102" id="anc102"></a><span class="line-added">14040     /* Don&#39;t read from stdin. */</span>
<span class="line-added">14041     if (xmlStrcmp(URL, BAD_CAST &quot;-&quot;) == 0)</span>
<span class="line-added">14042         URL = BAD_CAST &quot;./-&quot;;</span>
<span class="line-added">14043 </span>
14044     uri = xmlBuildURI(URL, base);
14045 
14046     if (uri == NULL) {
14047     inputStream = xmlLoadExternalEntity((char *)URL, (char *)ID, ctxt);
14048     if (inputStream == NULL) {
14049         xmlFreeParserCtxt(ctxt);
14050         return(NULL);
14051     }
14052 
14053     inputPush(ctxt, inputStream);
14054 
14055     if ((ctxt-&gt;directory == NULL) &amp;&amp; (directory == NULL))
14056         directory = xmlParserGetDirectory((char *)URL);
14057     if ((ctxt-&gt;directory == NULL) &amp;&amp; (directory != NULL))
14058         ctxt-&gt;directory = directory;
14059     } else {
14060     inputStream = xmlLoadExternalEntity((char *)uri, (char *)ID, ctxt);
14061     if (inputStream == NULL) {
14062         xmlFree(uri);
14063         xmlFreeParserCtxt(ctxt);
14064         return(NULL);
14065     }
14066 
14067     inputPush(ctxt, inputStream);
14068 
14069     if ((ctxt-&gt;directory == NULL) &amp;&amp; (directory == NULL))
14070         directory = xmlParserGetDirectory((char *)uri);
14071     if ((ctxt-&gt;directory == NULL) &amp;&amp; (directory != NULL))
14072         ctxt-&gt;directory = directory;
14073     xmlFree(uri);
14074     }
14075     return(ctxt);
14076 }
14077 
14078 /**
14079  * xmlCreateEntityParserCtxt:
14080  * @URL:  the entity URL
14081  * @ID:  the entity PUBLIC ID
14082  * @base:  a possible base for the target URI
14083  *
14084  * Create a parser context for an external entity
14085  * Automatic support for ZLIB/Compress compressed document is provided
14086  * by default if found at compile-time.
14087  *
14088  * Returns the new parser context or NULL
14089  */
14090 xmlParserCtxtPtr
14091 xmlCreateEntityParserCtxt(const xmlChar *URL, const xmlChar *ID,
14092                       const xmlChar *base) {
14093     return xmlCreateEntityParserCtxtInternal(URL, ID, base, NULL);
14094 
14095 }
14096 
14097 /************************************************************************
14098  *                                  *
14099  *      Front ends when parsing from a file         *
14100  *                                  *
14101  ************************************************************************/
14102 
14103 /**
14104  * xmlCreateURLParserCtxt:
14105  * @filename:  the filename or URL
14106  * @options:  a combination of xmlParserOption
14107  *
14108  * Create a parser context for a file or URL content.
14109  * Automatic support for ZLIB/Compress compressed document is provided
14110  * by default if found at compile-time and for file accesses
14111  *
14112  * Returns the new parser context or NULL
14113  */
14114 xmlParserCtxtPtr
14115 xmlCreateURLParserCtxt(const char *filename, int options)
14116 {
14117     xmlParserCtxtPtr ctxt;
14118     xmlParserInputPtr inputStream;
14119     char *directory = NULL;
14120 
14121     ctxt = xmlNewParserCtxt();
14122     if (ctxt == NULL) {
14123     xmlErrMemory(NULL, &quot;cannot allocate parser context&quot;);
14124     return(NULL);
14125     }
14126 
14127     if (options)
14128     xmlCtxtUseOptionsInternal(ctxt, options, NULL);
14129     ctxt-&gt;linenumbers = 1;
14130 
14131     inputStream = xmlLoadExternalEntity(filename, NULL, ctxt);
14132     if (inputStream == NULL) {
14133     xmlFreeParserCtxt(ctxt);
14134     return(NULL);
14135     }
14136 
14137     inputPush(ctxt, inputStream);
14138     if ((ctxt-&gt;directory == NULL) &amp;&amp; (directory == NULL))
14139         directory = xmlParserGetDirectory(filename);
14140     if ((ctxt-&gt;directory == NULL) &amp;&amp; (directory != NULL))
14141         ctxt-&gt;directory = directory;
14142 
14143     return(ctxt);
14144 }
14145 
14146 /**
14147  * xmlCreateFileParserCtxt:
14148  * @filename:  the filename
14149  *
14150  * Create a parser context for a file content.
14151  * Automatic support for ZLIB/Compress compressed document is provided
14152  * by default if found at compile-time.
14153  *
14154  * Returns the new parser context or NULL
14155  */
14156 xmlParserCtxtPtr
14157 xmlCreateFileParserCtxt(const char *filename)
14158 {
14159     return(xmlCreateURLParserCtxt(filename, 0));
14160 }
14161 
14162 #ifdef LIBXML_SAX1_ENABLED
14163 /**
14164  * xmlSAXParseFileWithData:
14165  * @sax:  the SAX handler block
14166  * @filename:  the filename
14167  * @recovery:  work in recovery mode, i.e. tries to read no Well Formed
14168  *             documents
14169  * @data:  the userdata
14170  *
14171  * parse an XML file and build a tree. Automatic support for ZLIB/Compress
14172  * compressed document is provided by default if found at compile-time.
14173  * It use the given SAX function block to handle the parsing callback.
14174  * If sax is NULL, fallback to the default DOM tree building routines.
14175  *
14176  * User data (void *) is stored within the parser context in the
14177  * context&#39;s _private member, so it is available nearly everywhere in libxml
14178  *
14179  * Returns the resulting document tree
14180  */
14181 
14182 xmlDocPtr
14183 xmlSAXParseFileWithData(xmlSAXHandlerPtr sax, const char *filename,
14184                         int recovery, void *data) {
14185     xmlDocPtr ret;
14186     xmlParserCtxtPtr ctxt;
14187 
14188     xmlInitParser();
14189 
14190     ctxt = xmlCreateFileParserCtxt(filename);
14191     if (ctxt == NULL) {
14192     return(NULL);
14193     }
14194     if (sax != NULL) {
14195     if (ctxt-&gt;sax != NULL)
14196         xmlFree(ctxt-&gt;sax);
14197         ctxt-&gt;sax = sax;
14198     }
14199     xmlDetectSAX2(ctxt);
14200     if (data!=NULL) {
14201     ctxt-&gt;_private = data;
14202     }
14203 
14204     if (ctxt-&gt;directory == NULL)
14205         ctxt-&gt;directory = xmlParserGetDirectory(filename);
14206 
14207     ctxt-&gt;recovery = recovery;
14208 
14209     xmlParseDocument(ctxt);
14210 
14211     if ((ctxt-&gt;wellFormed) || recovery) {
14212         ret = ctxt-&gt;myDoc;
14213     if (ret != NULL) {
14214         if (ctxt-&gt;input-&gt;buf-&gt;compressed &gt; 0)
14215         ret-&gt;compression = 9;
14216         else
14217         ret-&gt;compression = ctxt-&gt;input-&gt;buf-&gt;compressed;
14218     }
14219     }
14220     else {
14221        ret = NULL;
14222        xmlFreeDoc(ctxt-&gt;myDoc);
14223        ctxt-&gt;myDoc = NULL;
14224     }
14225     if (sax != NULL)
14226         ctxt-&gt;sax = NULL;
14227     xmlFreeParserCtxt(ctxt);
14228 
14229     return(ret);
14230 }
14231 
14232 /**
14233  * xmlSAXParseFile:
14234  * @sax:  the SAX handler block
14235  * @filename:  the filename
14236  * @recovery:  work in recovery mode, i.e. tries to read no Well Formed
14237  *             documents
14238  *
14239  * parse an XML file and build a tree. Automatic support for ZLIB/Compress
14240  * compressed document is provided by default if found at compile-time.
14241  * It use the given SAX function block to handle the parsing callback.
14242  * If sax is NULL, fallback to the default DOM tree building routines.
14243  *
14244  * Returns the resulting document tree
14245  */
14246 
14247 xmlDocPtr
14248 xmlSAXParseFile(xmlSAXHandlerPtr sax, const char *filename,
14249                           int recovery) {
14250     return(xmlSAXParseFileWithData(sax,filename,recovery,NULL));
14251 }
14252 
14253 /**
14254  * xmlRecoverDoc:
14255  * @cur:  a pointer to an array of xmlChar
14256  *
14257  * parse an XML in-memory document and build a tree.
14258  * In the case the document is not Well Formed, a attempt to build a
14259  * tree is tried anyway
14260  *
14261  * Returns the resulting document tree or NULL in case of failure
14262  */
14263 
14264 xmlDocPtr
14265 xmlRecoverDoc(const xmlChar *cur) {
14266     return(xmlSAXParseDoc(NULL, cur, 1));
14267 }
14268 
14269 /**
14270  * xmlParseFile:
14271  * @filename:  the filename
14272  *
14273  * parse an XML file and build a tree. Automatic support for ZLIB/Compress
14274  * compressed document is provided by default if found at compile-time.
14275  *
14276  * Returns the resulting document tree if the file was wellformed,
14277  * NULL otherwise.
14278  */
14279 
14280 xmlDocPtr
14281 xmlParseFile(const char *filename) {
14282     return(xmlSAXParseFile(NULL, filename, 0));
14283 }
14284 
14285 /**
14286  * xmlRecoverFile:
14287  * @filename:  the filename
14288  *
14289  * parse an XML file and build a tree. Automatic support for ZLIB/Compress
14290  * compressed document is provided by default if found at compile-time.
14291  * In the case the document is not Well Formed, it attempts to build
14292  * a tree anyway
14293  *
14294  * Returns the resulting document tree or NULL in case of failure
14295  */
14296 
14297 xmlDocPtr
14298 xmlRecoverFile(const char *filename) {
14299     return(xmlSAXParseFile(NULL, filename, 1));
14300 }
14301 
14302 
14303 /**
14304  * xmlSetupParserForBuffer:
14305  * @ctxt:  an XML parser context
14306  * @buffer:  a xmlChar * buffer
14307  * @filename:  a file name
14308  *
14309  * Setup the parser context to parse a new buffer; Clears any prior
14310  * contents from the parser context. The buffer parameter must not be
14311  * NULL, but the filename parameter can be
14312  */
14313 void
14314 xmlSetupParserForBuffer(xmlParserCtxtPtr ctxt, const xmlChar* buffer,
14315                              const char* filename)
14316 {
14317     xmlParserInputPtr input;
14318 
14319     if ((ctxt == NULL) || (buffer == NULL))
14320         return;
14321 
14322     input = xmlNewInputStream(ctxt);
14323     if (input == NULL) {
14324         xmlErrMemory(NULL, &quot;parsing new buffer: out of memory\n&quot;);
14325         xmlClearParserCtxt(ctxt);
14326         return;
14327     }
14328 
14329     xmlClearParserCtxt(ctxt);
14330     if (filename != NULL)
14331         input-&gt;filename = (char *) xmlCanonicPath((const xmlChar *)filename);
14332     input-&gt;base = buffer;
14333     input-&gt;cur = buffer;
14334     input-&gt;end = &amp;buffer[xmlStrlen(buffer)];
14335     inputPush(ctxt, input);
14336 }
14337 
14338 /**
14339  * xmlSAXUserParseFile:
14340  * @sax:  a SAX handler
14341  * @user_data:  The user data returned on SAX callbacks
14342  * @filename:  a file name
14343  *
14344  * parse an XML file and call the given SAX handler routines.
14345  * Automatic support for ZLIB/Compress compressed document is provided
14346  *
14347  * Returns 0 in case of success or a error number otherwise
14348  */
14349 int
14350 xmlSAXUserParseFile(xmlSAXHandlerPtr sax, void *user_data,
14351                     const char *filename) {
14352     int ret = 0;
14353     xmlParserCtxtPtr ctxt;
14354 
14355     ctxt = xmlCreateFileParserCtxt(filename);
14356     if (ctxt == NULL) return -1;
14357     if (ctxt-&gt;sax != (xmlSAXHandlerPtr) &amp;xmlDefaultSAXHandler)
14358     xmlFree(ctxt-&gt;sax);
14359     ctxt-&gt;sax = sax;
14360     xmlDetectSAX2(ctxt);
14361 
14362     if (user_data != NULL)
14363     ctxt-&gt;userData = user_data;
14364 
14365     xmlParseDocument(ctxt);
14366 
14367     if (ctxt-&gt;wellFormed)
14368     ret = 0;
14369     else {
14370         if (ctxt-&gt;errNo != 0)
14371         ret = ctxt-&gt;errNo;
14372     else
14373         ret = -1;
14374     }
14375     if (sax != NULL)
14376     ctxt-&gt;sax = NULL;
14377     if (ctxt-&gt;myDoc != NULL) {
14378         xmlFreeDoc(ctxt-&gt;myDoc);
14379     ctxt-&gt;myDoc = NULL;
14380     }
14381     xmlFreeParserCtxt(ctxt);
14382 
14383     return ret;
14384 }
14385 #endif /* LIBXML_SAX1_ENABLED */
14386 
14387 /************************************************************************
14388  *                                  *
14389  *      Front ends when parsing from memory         *
14390  *                                  *
14391  ************************************************************************/
14392 
14393 /**
14394  * xmlCreateMemoryParserCtxt:
14395  * @buffer:  a pointer to a char array
14396  * @size:  the size of the array
14397  *
14398  * Create a parser context for an XML in-memory document.
14399  *
14400  * Returns the new parser context or NULL
14401  */
14402 xmlParserCtxtPtr
14403 xmlCreateMemoryParserCtxt(const char *buffer, int size) {
14404     xmlParserCtxtPtr ctxt;
14405     xmlParserInputPtr input;
14406     xmlParserInputBufferPtr buf;
14407 
14408     if (buffer == NULL)
14409     return(NULL);
14410     if (size &lt;= 0)
14411     return(NULL);
14412 
14413     ctxt = xmlNewParserCtxt();
14414     if (ctxt == NULL)
14415     return(NULL);
14416 
14417     /* TODO: xmlParserInputBufferCreateStatic, requires some serious changes */
14418     buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
14419     if (buf == NULL) {
14420     xmlFreeParserCtxt(ctxt);
14421     return(NULL);
14422     }
14423 
14424     input = xmlNewInputStream(ctxt);
14425     if (input == NULL) {
14426     xmlFreeParserInputBuffer(buf);
14427     xmlFreeParserCtxt(ctxt);
14428     return(NULL);
14429     }
14430 
14431     input-&gt;filename = NULL;
14432     input-&gt;buf = buf;
14433     xmlBufResetInput(input-&gt;buf-&gt;buffer, input);
14434 
14435     inputPush(ctxt, input);
14436     return(ctxt);
14437 }
14438 
14439 #ifdef LIBXML_SAX1_ENABLED
14440 /**
14441  * xmlSAXParseMemoryWithData:
14442  * @sax:  the SAX handler block
14443  * @buffer:  an pointer to a char array
14444  * @size:  the size of the array
14445  * @recovery:  work in recovery mode, i.e. tries to read no Well Formed
14446  *             documents
14447  * @data:  the userdata
14448  *
14449  * parse an XML in-memory block and use the given SAX function block
14450  * to handle the parsing callback. If sax is NULL, fallback to the default
14451  * DOM tree building routines.
14452  *
14453  * User data (void *) is stored within the parser context in the
14454  * context&#39;s _private member, so it is available nearly everywhere in libxml
14455  *
14456  * Returns the resulting document tree
14457  */
14458 
14459 xmlDocPtr
14460 xmlSAXParseMemoryWithData(xmlSAXHandlerPtr sax, const char *buffer,
14461               int size, int recovery, void *data) {
14462     xmlDocPtr ret;
14463     xmlParserCtxtPtr ctxt;
14464 
14465     xmlInitParser();
14466 
14467     ctxt = xmlCreateMemoryParserCtxt(buffer, size);
14468     if (ctxt == NULL) return(NULL);
14469     if (sax != NULL) {
14470     if (ctxt-&gt;sax != NULL)
14471         xmlFree(ctxt-&gt;sax);
14472         ctxt-&gt;sax = sax;
14473     }
14474     xmlDetectSAX2(ctxt);
14475     if (data!=NULL) {
14476     ctxt-&gt;_private=data;
14477     }
14478 
14479     ctxt-&gt;recovery = recovery;
14480 
14481     xmlParseDocument(ctxt);
14482 
14483     if ((ctxt-&gt;wellFormed) || recovery) ret = ctxt-&gt;myDoc;
14484     else {
14485        ret = NULL;
14486        xmlFreeDoc(ctxt-&gt;myDoc);
14487        ctxt-&gt;myDoc = NULL;
14488     }
14489     if (sax != NULL)
14490     ctxt-&gt;sax = NULL;
14491     xmlFreeParserCtxt(ctxt);
14492 
14493     return(ret);
14494 }
14495 
14496 /**
14497  * xmlSAXParseMemory:
14498  * @sax:  the SAX handler block
14499  * @buffer:  an pointer to a char array
14500  * @size:  the size of the array
14501  * @recovery:  work in recovery mode, i.e. tries to read not Well Formed
14502  *             documents
14503  *
14504  * parse an XML in-memory block and use the given SAX function block
14505  * to handle the parsing callback. If sax is NULL, fallback to the default
14506  * DOM tree building routines.
14507  *
14508  * Returns the resulting document tree
14509  */
14510 xmlDocPtr
14511 xmlSAXParseMemory(xmlSAXHandlerPtr sax, const char *buffer,
14512               int size, int recovery) {
14513     return xmlSAXParseMemoryWithData(sax, buffer, size, recovery, NULL);
14514 }
14515 
14516 /**
14517  * xmlParseMemory:
14518  * @buffer:  an pointer to a char array
14519  * @size:  the size of the array
14520  *
14521  * parse an XML in-memory block and build a tree.
14522  *
14523  * Returns the resulting document tree
14524  */
14525 
14526 xmlDocPtr xmlParseMemory(const char *buffer, int size) {
14527    return(xmlSAXParseMemory(NULL, buffer, size, 0));
14528 }
14529 
14530 /**
14531  * xmlRecoverMemory:
14532  * @buffer:  an pointer to a char array
14533  * @size:  the size of the array
14534  *
14535  * parse an XML in-memory block and build a tree.
14536  * In the case the document is not Well Formed, an attempt to
14537  * build a tree is tried anyway
14538  *
14539  * Returns the resulting document tree or NULL in case of error
14540  */
14541 
14542 xmlDocPtr xmlRecoverMemory(const char *buffer, int size) {
14543    return(xmlSAXParseMemory(NULL, buffer, size, 1));
14544 }
14545 
14546 /**
14547  * xmlSAXUserParseMemory:
14548  * @sax:  a SAX handler
14549  * @user_data:  The user data returned on SAX callbacks
14550  * @buffer:  an in-memory XML document input
14551  * @size:  the length of the XML document in bytes
14552  *
14553  * A better SAX parsing routine.
14554  * parse an XML in-memory buffer and call the given SAX handler routines.
14555  *
14556  * Returns 0 in case of success or a error number otherwise
14557  */
14558 int xmlSAXUserParseMemory(xmlSAXHandlerPtr sax, void *user_data,
14559               const char *buffer, int size) {
14560     int ret = 0;
14561     xmlParserCtxtPtr ctxt;
14562 
14563     xmlInitParser();
14564 
14565     ctxt = xmlCreateMemoryParserCtxt(buffer, size);
14566     if (ctxt == NULL) return -1;
14567     if (ctxt-&gt;sax != (xmlSAXHandlerPtr) &amp;xmlDefaultSAXHandler)
14568         xmlFree(ctxt-&gt;sax);
14569     ctxt-&gt;sax = sax;
14570     xmlDetectSAX2(ctxt);
14571 
14572     if (user_data != NULL)
14573     ctxt-&gt;userData = user_data;
14574 
14575     xmlParseDocument(ctxt);
14576 
14577     if (ctxt-&gt;wellFormed)
14578     ret = 0;
14579     else {
14580         if (ctxt-&gt;errNo != 0)
14581         ret = ctxt-&gt;errNo;
14582     else
14583         ret = -1;
14584     }
14585     if (sax != NULL)
14586         ctxt-&gt;sax = NULL;
14587     if (ctxt-&gt;myDoc != NULL) {
14588         xmlFreeDoc(ctxt-&gt;myDoc);
14589     ctxt-&gt;myDoc = NULL;
14590     }
14591     xmlFreeParserCtxt(ctxt);
14592 
14593     return ret;
14594 }
14595 #endif /* LIBXML_SAX1_ENABLED */
14596 
14597 /**
14598  * xmlCreateDocParserCtxt:
14599  * @cur:  a pointer to an array of xmlChar
14600  *
14601  * Creates a parser context for an XML in-memory document.
14602  *
14603  * Returns the new parser context or NULL
14604  */
14605 xmlParserCtxtPtr
14606 xmlCreateDocParserCtxt(const xmlChar *cur) {
14607     int len;
14608 
14609     if (cur == NULL)
14610     return(NULL);
14611     len = xmlStrlen(cur);
14612     return(xmlCreateMemoryParserCtxt((const char *)cur, len));
14613 }
14614 
14615 #ifdef LIBXML_SAX1_ENABLED
14616 /**
14617  * xmlSAXParseDoc:
14618  * @sax:  the SAX handler block
14619  * @cur:  a pointer to an array of xmlChar
14620  * @recovery:  work in recovery mode, i.e. tries to read no Well Formed
14621  *             documents
14622  *
14623  * parse an XML in-memory document and build a tree.
14624  * It use the given SAX function block to handle the parsing callback.
14625  * If sax is NULL, fallback to the default DOM tree building routines.
14626  *
14627  * Returns the resulting document tree
14628  */
14629 
14630 xmlDocPtr
14631 xmlSAXParseDoc(xmlSAXHandlerPtr sax, const xmlChar *cur, int recovery) {
14632     xmlDocPtr ret;
14633     xmlParserCtxtPtr ctxt;
14634     xmlSAXHandlerPtr oldsax = NULL;
14635 
14636     if (cur == NULL) return(NULL);
14637 
14638 
14639     ctxt = xmlCreateDocParserCtxt(cur);
14640     if (ctxt == NULL) return(NULL);
14641     if (sax != NULL) {
14642         oldsax = ctxt-&gt;sax;
14643         ctxt-&gt;sax = sax;
14644         ctxt-&gt;userData = NULL;
14645     }
14646     xmlDetectSAX2(ctxt);
14647 
14648     xmlParseDocument(ctxt);
14649     if ((ctxt-&gt;wellFormed) || recovery) ret = ctxt-&gt;myDoc;
14650     else {
14651        ret = NULL;
14652        xmlFreeDoc(ctxt-&gt;myDoc);
14653        ctxt-&gt;myDoc = NULL;
14654     }
14655     if (sax != NULL)
14656     ctxt-&gt;sax = oldsax;
14657     xmlFreeParserCtxt(ctxt);
14658 
14659     return(ret);
14660 }
14661 
14662 /**
14663  * xmlParseDoc:
14664  * @cur:  a pointer to an array of xmlChar
14665  *
14666  * parse an XML in-memory document and build a tree.
14667  *
14668  * Returns the resulting document tree
14669  */
14670 
14671 xmlDocPtr
14672 xmlParseDoc(const xmlChar *cur) {
14673     return(xmlSAXParseDoc(NULL, cur, 0));
14674 }
14675 #endif /* LIBXML_SAX1_ENABLED */
14676 
14677 #ifdef LIBXML_LEGACY_ENABLED
14678 /************************************************************************
14679  *                                  *
14680  *  Specific function to keep track of entities references      *
14681  *  and used by the XSLT debugger                   *
14682  *                                  *
14683  ************************************************************************/
14684 
14685 static xmlEntityReferenceFunc xmlEntityRefFunc = NULL;
14686 
14687 /**
14688  * xmlAddEntityReference:
14689  * @ent : A valid entity
14690  * @firstNode : A valid first node for children of entity
14691  * @lastNode : A valid last node of children entity
14692  *
14693  * Notify of a reference to an entity of type XML_EXTERNAL_GENERAL_PARSED_ENTITY
14694  */
14695 static void
14696 xmlAddEntityReference(xmlEntityPtr ent, xmlNodePtr firstNode,
14697                       xmlNodePtr lastNode)
14698 {
14699     if (xmlEntityRefFunc != NULL) {
14700         (*xmlEntityRefFunc) (ent, firstNode, lastNode);
14701     }
14702 }
14703 
14704 
14705 /**
14706  * xmlSetEntityReferenceFunc:
14707  * @func: A valid function
14708  *
14709  * Set the function to call call back when a xml reference has been made
14710  */
14711 void
14712 xmlSetEntityReferenceFunc(xmlEntityReferenceFunc func)
14713 {
14714     xmlEntityRefFunc = func;
14715 }
14716 #endif /* LIBXML_LEGACY_ENABLED */
14717 
14718 /************************************************************************
14719  *                                  *
14720  *              Miscellaneous               *
14721  *                                  *
14722  ************************************************************************/
14723 
14724 #ifdef LIBXML_XPATH_ENABLED
14725 #include &lt;libxml/xpath.h&gt;
14726 #endif
14727 
14728 extern void XMLCDECL xmlGenericErrorDefaultFunc(void *ctx, const char *msg, ...);
14729 static int xmlParserInitialized = 0;
14730 
14731 /**
14732  * xmlInitParser:
14733  *
14734  * Initialization function for the XML parser.
14735  * This is not reentrant. Call once before processing in case of
14736  * use in multithreaded programs.
14737  */
14738 
14739 void
14740 xmlInitParser(void) {
14741     if (xmlParserInitialized != 0)
14742     return;
14743 
14744 #ifdef LIBXML_THREAD_ENABLED
14745     __xmlGlobalInitMutexLock();
14746     if (xmlParserInitialized == 0) {
14747 #endif
14748     xmlInitThreads();
14749     xmlInitGlobals();
14750     if ((xmlGenericError == xmlGenericErrorDefaultFunc) ||
14751         (xmlGenericError == NULL))
14752         initGenericErrorDefaultFunc(NULL);
14753     xmlInitMemory();
14754         xmlInitializeDict();
14755     xmlInitCharEncodingHandlers();
14756     xmlDefaultSAXHandlerInit();
14757     xmlRegisterDefaultInputCallbacks();
14758 #ifdef LIBXML_OUTPUT_ENABLED
14759     xmlRegisterDefaultOutputCallbacks();
14760 #endif /* LIBXML_OUTPUT_ENABLED */
14761 #ifdef LIBXML_HTML_ENABLED
14762     htmlInitAutoClose();
14763     htmlDefaultSAXHandlerInit();
14764 #endif
14765 #ifdef LIBXML_XPATH_ENABLED
14766     xmlXPathInit();
14767 #endif
14768     xmlParserInitialized = 1;
14769 #ifdef LIBXML_THREAD_ENABLED
14770     }
14771     __xmlGlobalInitMutexUnlock();
14772 #endif
14773 }
14774 
14775 /**
14776  * xmlCleanupParser:
14777  *
14778  * This function name is somewhat misleading. It does not clean up
14779  * parser state, it cleans up memory allocated by the library itself.
14780  * It is a cleanup function for the XML library. It tries to reclaim all
14781  * related global memory allocated for the library processing.
14782  * It doesn&#39;t deallocate any document related memory. One should
14783  * call xmlCleanupParser() only when the process has finished using
14784  * the library and all XML/HTML documents built with it.
14785  * See also xmlInitParser() which has the opposite function of preparing
14786  * the library for operations.
14787  *
14788  * WARNING: if your application is multithreaded or has plugin support
14789  *          calling this may crash the application if another thread or
14790  *          a plugin is still using libxml2. It&#39;s sometimes very hard to
14791  *          guess if libxml2 is in use in the application, some libraries
14792  *          or plugins may use it without notice. In case of doubt abstain
14793  *          from calling this function or do it just before calling exit()
14794  *          to avoid leak reports from valgrind !
14795  */
14796 
14797 void
14798 xmlCleanupParser(void) {
14799     if (!xmlParserInitialized)
14800     return;
14801 
14802     xmlCleanupCharEncodingHandlers();
14803 #ifdef LIBXML_CATALOG_ENABLED
14804     xmlCatalogCleanup();
14805 #endif
14806     xmlDictCleanup();
14807     xmlCleanupInputCallbacks();
14808 #ifdef LIBXML_OUTPUT_ENABLED
14809     xmlCleanupOutputCallbacks();
14810 #endif
14811 #ifdef LIBXML_SCHEMAS_ENABLED
14812     xmlSchemaCleanupTypes();
14813     xmlRelaxNGCleanupTypes();
14814 #endif
14815     xmlResetLastError();
14816     xmlCleanupGlobals();
14817     xmlCleanupThreads(); /* must be last if called not from the main thread */
14818     xmlCleanupMemory();
14819     xmlParserInitialized = 0;
14820 }
14821 
14822 /************************************************************************
14823  *                                  *
14824  *  New set (2.6.0) of simpler and more flexible APIs       *
14825  *                                  *
14826  ************************************************************************/
14827 
14828 /**
14829  * DICT_FREE:
14830  * @str:  a string
14831  *
14832  * Free a string if it is not owned by the &quot;dict&quot; dictionary in the
14833  * current scope
14834  */
14835 #define DICT_FREE(str)                      \
14836     if ((str) &amp;&amp; ((!dict) ||                \
14837         (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))  \
14838         xmlFree((char *)(str));
14839 
14840 /**
14841  * xmlCtxtReset:
14842  * @ctxt: an XML parser context
14843  *
14844  * Reset a parser context
14845  */
14846 void
14847 xmlCtxtReset(xmlParserCtxtPtr ctxt)
14848 {
14849     xmlParserInputPtr input;
14850     xmlDictPtr dict;
14851 
14852     if (ctxt == NULL)
14853         return;
14854 
14855     dict = ctxt-&gt;dict;
14856 
14857     while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */
14858         xmlFreeInputStream(input);
14859     }
14860     ctxt-&gt;inputNr = 0;
14861     ctxt-&gt;input = NULL;
14862 
14863     ctxt-&gt;spaceNr = 0;
14864     if (ctxt-&gt;spaceTab != NULL) {
14865     ctxt-&gt;spaceTab[0] = -1;
14866     ctxt-&gt;space = &amp;ctxt-&gt;spaceTab[0];
14867     } else {
14868         ctxt-&gt;space = NULL;
14869     }
14870 
14871 
14872     ctxt-&gt;nodeNr = 0;
14873     ctxt-&gt;node = NULL;
14874 
14875     ctxt-&gt;nameNr = 0;
14876     ctxt-&gt;name = NULL;
14877 
14878     DICT_FREE(ctxt-&gt;version);
14879     ctxt-&gt;version = NULL;
14880     DICT_FREE(ctxt-&gt;encoding);
14881     ctxt-&gt;encoding = NULL;
14882     DICT_FREE(ctxt-&gt;directory);
14883     ctxt-&gt;directory = NULL;
14884     DICT_FREE(ctxt-&gt;extSubURI);
14885     ctxt-&gt;extSubURI = NULL;
14886     DICT_FREE(ctxt-&gt;extSubSystem);
14887     ctxt-&gt;extSubSystem = NULL;
14888     if (ctxt-&gt;myDoc != NULL)
14889         xmlFreeDoc(ctxt-&gt;myDoc);
14890     ctxt-&gt;myDoc = NULL;
14891 
14892     ctxt-&gt;standalone = -1;
14893     ctxt-&gt;hasExternalSubset = 0;
14894     ctxt-&gt;hasPErefs = 0;
14895     ctxt-&gt;html = 0;
14896     ctxt-&gt;external = 0;
14897     ctxt-&gt;instate = XML_PARSER_START;
14898     ctxt-&gt;token = 0;
14899 
14900     ctxt-&gt;wellFormed = 1;
14901     ctxt-&gt;nsWellFormed = 1;
14902     ctxt-&gt;disableSAX = 0;
14903     ctxt-&gt;valid = 1;
14904 #if 0
14905     ctxt-&gt;vctxt.userData = ctxt;
14906     ctxt-&gt;vctxt.error = xmlParserValidityError;
14907     ctxt-&gt;vctxt.warning = xmlParserValidityWarning;
14908 #endif
14909     ctxt-&gt;record_info = 0;
14910     ctxt-&gt;nbChars = 0;
14911     ctxt-&gt;checkIndex = 0;
14912     ctxt-&gt;inSubset = 0;
14913     ctxt-&gt;errNo = XML_ERR_OK;
14914     ctxt-&gt;depth = 0;
14915     ctxt-&gt;charset = XML_CHAR_ENCODING_UTF8;
14916     ctxt-&gt;catalogs = NULL;
14917     ctxt-&gt;nbentities = 0;
14918     ctxt-&gt;sizeentities = 0;
14919     ctxt-&gt;sizeentcopy = 0;
14920     xmlInitNodeInfoSeq(&amp;ctxt-&gt;node_seq);
14921 
14922     if (ctxt-&gt;attsDefault != NULL) {
14923         xmlHashFree(ctxt-&gt;attsDefault, xmlHashDefaultDeallocator);
14924         ctxt-&gt;attsDefault = NULL;
14925     }
14926     if (ctxt-&gt;attsSpecial != NULL) {
14927         xmlHashFree(ctxt-&gt;attsSpecial, NULL);
14928         ctxt-&gt;attsSpecial = NULL;
14929     }
14930 
14931 #ifdef LIBXML_CATALOG_ENABLED
14932     if (ctxt-&gt;catalogs != NULL)
14933     xmlCatalogFreeLocal(ctxt-&gt;catalogs);
14934 #endif
14935     if (ctxt-&gt;lastError.code != XML_ERR_OK)
14936         xmlResetError(&amp;ctxt-&gt;lastError);
14937 }
14938 
14939 /**
14940  * xmlCtxtResetPush:
14941  * @ctxt: an XML parser context
14942  * @chunk:  a pointer to an array of chars
14943  * @size:  number of chars in the array
14944  * @filename:  an optional file name or URI
14945  * @encoding:  the document encoding, or NULL
14946  *
14947  * Reset a push parser context
14948  *
14949  * Returns 0 in case of success and 1 in case of error
14950  */
14951 int
14952 xmlCtxtResetPush(xmlParserCtxtPtr ctxt, const char *chunk,
14953                  int size, const char *filename, const char *encoding)
14954 {
14955     xmlParserInputPtr inputStream;
14956     xmlParserInputBufferPtr buf;
14957     xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;
14958 
14959     if (ctxt == NULL)
14960         return(1);
14961 
14962     if ((encoding == NULL) &amp;&amp; (chunk != NULL) &amp;&amp; (size &gt;= 4))
14963         enc = xmlDetectCharEncoding((const xmlChar *) chunk, size);
14964 
14965     buf = xmlAllocParserInputBuffer(enc);
14966     if (buf == NULL)
14967         return(1);
14968 
14969     if (ctxt == NULL) {
14970         xmlFreeParserInputBuffer(buf);
14971         return(1);
14972     }
14973 
14974     xmlCtxtReset(ctxt);
14975 
<a name="103" id="anc103"></a>









14976     if (filename == NULL) {
14977         ctxt-&gt;directory = NULL;
14978     } else {
14979         ctxt-&gt;directory = xmlParserGetDirectory(filename);
14980     }
14981 
14982     inputStream = xmlNewInputStream(ctxt);
14983     if (inputStream == NULL) {
14984         xmlFreeParserInputBuffer(buf);
14985         return(1);
14986     }
14987 
14988     if (filename == NULL)
14989         inputStream-&gt;filename = NULL;
14990     else
14991         inputStream-&gt;filename = (char *)
14992             xmlCanonicPath((const xmlChar *) filename);
14993     inputStream-&gt;buf = buf;
14994     xmlBufResetInput(buf-&gt;buffer, inputStream);
14995 
14996     inputPush(ctxt, inputStream);
14997 
14998     if ((size &gt; 0) &amp;&amp; (chunk != NULL) &amp;&amp; (ctxt-&gt;input != NULL) &amp;&amp;
14999         (ctxt-&gt;input-&gt;buf != NULL)) {
15000     size_t base = xmlBufGetInputBase(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input);
15001         size_t cur = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
15002 
15003         xmlParserInputBufferPush(ctxt-&gt;input-&gt;buf, size, chunk);
15004 
15005         xmlBufSetInputBaseCur(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input, base, cur);
15006 #ifdef DEBUG_PUSH
15007         xmlGenericError(xmlGenericErrorContext, &quot;PP: pushed %d\n&quot;, size);
15008 #endif
15009     }
15010 
15011     if (encoding != NULL) {
15012         xmlCharEncodingHandlerPtr hdlr;
15013 
15014         if (ctxt-&gt;encoding != NULL)
15015         xmlFree((xmlChar *) ctxt-&gt;encoding);
15016         ctxt-&gt;encoding = xmlStrdup((const xmlChar *) encoding);
15017 
15018         hdlr = xmlFindCharEncodingHandler(encoding);
15019         if (hdlr != NULL) {
15020             xmlSwitchToEncoding(ctxt, hdlr);
15021     } else {
15022         xmlFatalErrMsgStr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
15023                   &quot;Unsupported encoding %s\n&quot;, BAD_CAST encoding);
15024         }
15025     } else if (enc != XML_CHAR_ENCODING_NONE) {
15026         xmlSwitchEncoding(ctxt, enc);
15027     }
15028 
15029     return(0);
15030 }
15031 
15032 
15033 /**
15034  * xmlCtxtUseOptionsInternal:
15035  * @ctxt: an XML parser context
15036  * @options:  a combination of xmlParserOption
15037  * @encoding:  the user provided encoding to use
15038  *
15039  * Applies the options to the parser context
15040  *
15041  * Returns 0 in case of success, the set of unknown or unimplemented options
15042  *         in case of error.
15043  */
15044 static int
15045 xmlCtxtUseOptionsInternal(xmlParserCtxtPtr ctxt, int options, const char *encoding)
15046 {
15047     if (ctxt == NULL)
15048         return(-1);
15049     if (encoding != NULL) {
15050         if (ctxt-&gt;encoding != NULL)
15051         xmlFree((xmlChar *) ctxt-&gt;encoding);
15052         ctxt-&gt;encoding = xmlStrdup((const xmlChar *) encoding);
15053     }
15054     if (options &amp; XML_PARSE_RECOVER) {
15055         ctxt-&gt;recovery = 1;
15056         options -= XML_PARSE_RECOVER;
15057     ctxt-&gt;options |= XML_PARSE_RECOVER;
15058     } else
15059         ctxt-&gt;recovery = 0;
15060     if (options &amp; XML_PARSE_DTDLOAD) {
15061         ctxt-&gt;loadsubset = XML_DETECT_IDS;
15062         options -= XML_PARSE_DTDLOAD;
15063     ctxt-&gt;options |= XML_PARSE_DTDLOAD;
15064     } else
15065         ctxt-&gt;loadsubset = 0;
15066     if (options &amp; XML_PARSE_DTDATTR) {
15067         ctxt-&gt;loadsubset |= XML_COMPLETE_ATTRS;
15068         options -= XML_PARSE_DTDATTR;
15069     ctxt-&gt;options |= XML_PARSE_DTDATTR;
15070     }
15071     if (options &amp; XML_PARSE_NOENT) {
15072         ctxt-&gt;replaceEntities = 1;
15073         /* ctxt-&gt;loadsubset |= XML_DETECT_IDS; */
15074         options -= XML_PARSE_NOENT;
15075     ctxt-&gt;options |= XML_PARSE_NOENT;
15076     } else
15077         ctxt-&gt;replaceEntities = 0;
15078     if (options &amp; XML_PARSE_PEDANTIC) {
15079         ctxt-&gt;pedantic = 1;
15080         options -= XML_PARSE_PEDANTIC;
15081     ctxt-&gt;options |= XML_PARSE_PEDANTIC;
15082     } else
15083         ctxt-&gt;pedantic = 0;
15084     if (options &amp; XML_PARSE_NOBLANKS) {
15085         ctxt-&gt;keepBlanks = 0;
15086         ctxt-&gt;sax-&gt;ignorableWhitespace = xmlSAX2IgnorableWhitespace;
15087         options -= XML_PARSE_NOBLANKS;
15088     ctxt-&gt;options |= XML_PARSE_NOBLANKS;
15089     } else
15090         ctxt-&gt;keepBlanks = 1;
15091     if (options &amp; XML_PARSE_DTDVALID) {
15092         ctxt-&gt;validate = 1;
15093         if (options &amp; XML_PARSE_NOWARNING)
15094             ctxt-&gt;vctxt.warning = NULL;
15095         if (options &amp; XML_PARSE_NOERROR)
15096             ctxt-&gt;vctxt.error = NULL;
15097         options -= XML_PARSE_DTDVALID;
15098     ctxt-&gt;options |= XML_PARSE_DTDVALID;
15099     } else
15100         ctxt-&gt;validate = 0;
15101     if (options &amp; XML_PARSE_NOWARNING) {
15102         ctxt-&gt;sax-&gt;warning = NULL;
15103         options -= XML_PARSE_NOWARNING;
15104     }
15105     if (options &amp; XML_PARSE_NOERROR) {
15106         ctxt-&gt;sax-&gt;error = NULL;
15107         ctxt-&gt;sax-&gt;fatalError = NULL;
15108         options -= XML_PARSE_NOERROR;
15109     }
15110 #ifdef LIBXML_SAX1_ENABLED
15111     if (options &amp; XML_PARSE_SAX1) {
15112         ctxt-&gt;sax-&gt;startElement = xmlSAX2StartElement;
15113         ctxt-&gt;sax-&gt;endElement = xmlSAX2EndElement;
15114         ctxt-&gt;sax-&gt;startElementNs = NULL;
15115         ctxt-&gt;sax-&gt;endElementNs = NULL;
15116         ctxt-&gt;sax-&gt;initialized = 1;
15117         options -= XML_PARSE_SAX1;
15118     ctxt-&gt;options |= XML_PARSE_SAX1;
15119     }
15120 #endif /* LIBXML_SAX1_ENABLED */
15121     if (options &amp; XML_PARSE_NODICT) {
15122         ctxt-&gt;dictNames = 0;
15123         options -= XML_PARSE_NODICT;
15124     ctxt-&gt;options |= XML_PARSE_NODICT;
15125     } else {
15126         ctxt-&gt;dictNames = 1;
15127     }
15128     if (options &amp; XML_PARSE_NOCDATA) {
15129         ctxt-&gt;sax-&gt;cdataBlock = NULL;
15130         options -= XML_PARSE_NOCDATA;
15131     ctxt-&gt;options |= XML_PARSE_NOCDATA;
15132     }
15133     if (options &amp; XML_PARSE_NSCLEAN) {
15134     ctxt-&gt;options |= XML_PARSE_NSCLEAN;
15135         options -= XML_PARSE_NSCLEAN;
15136     }
15137     if (options &amp; XML_PARSE_NONET) {
15138     ctxt-&gt;options |= XML_PARSE_NONET;
15139         options -= XML_PARSE_NONET;
15140     }
15141     if (options &amp; XML_PARSE_COMPACT) {
15142     ctxt-&gt;options |= XML_PARSE_COMPACT;
15143         options -= XML_PARSE_COMPACT;
15144     }
15145     if (options &amp; XML_PARSE_OLD10) {
15146     ctxt-&gt;options |= XML_PARSE_OLD10;
15147         options -= XML_PARSE_OLD10;
15148     }
15149     if (options &amp; XML_PARSE_NOBASEFIX) {
15150     ctxt-&gt;options |= XML_PARSE_NOBASEFIX;
15151         options -= XML_PARSE_NOBASEFIX;
15152     }
15153     if (options &amp; XML_PARSE_HUGE) {
15154     ctxt-&gt;options |= XML_PARSE_HUGE;
15155         options -= XML_PARSE_HUGE;
15156         if (ctxt-&gt;dict != NULL)
15157             xmlDictSetLimit(ctxt-&gt;dict, 0);
15158     }
15159     if (options &amp; XML_PARSE_OLDSAX) {
15160     ctxt-&gt;options |= XML_PARSE_OLDSAX;
15161         options -= XML_PARSE_OLDSAX;
15162     }
15163     if (options &amp; XML_PARSE_IGNORE_ENC) {
15164     ctxt-&gt;options |= XML_PARSE_IGNORE_ENC;
15165         options -= XML_PARSE_IGNORE_ENC;
15166     }
15167     if (options &amp; XML_PARSE_BIG_LINES) {
15168     ctxt-&gt;options |= XML_PARSE_BIG_LINES;
15169         options -= XML_PARSE_BIG_LINES;
15170     }
15171     ctxt-&gt;linenumbers = 1;
15172     return (options);
15173 }
15174 
15175 /**
15176  * xmlCtxtUseOptions:
15177  * @ctxt: an XML parser context
15178  * @options:  a combination of xmlParserOption
15179  *
15180  * Applies the options to the parser context
15181  *
15182  * Returns 0 in case of success, the set of unknown or unimplemented options
15183  *         in case of error.
15184  */
15185 int
15186 xmlCtxtUseOptions(xmlParserCtxtPtr ctxt, int options)
15187 {
15188    return(xmlCtxtUseOptionsInternal(ctxt, options, NULL));
15189 }
15190 
15191 /**
15192  * xmlDoRead:
15193  * @ctxt:  an XML parser context
15194  * @URL:  the base URL to use for the document
15195  * @encoding:  the document encoding, or NULL
15196  * @options:  a combination of xmlParserOption
15197  * @reuse:  keep the context for reuse
15198  *
15199  * Common front-end for the xmlRead functions
15200  *
15201  * Returns the resulting document tree or NULL
15202  */
15203 static xmlDocPtr
15204 xmlDoRead(xmlParserCtxtPtr ctxt, const char *URL, const char *encoding,
15205           int options, int reuse)
15206 {
15207     xmlDocPtr ret;
15208 
15209     xmlCtxtUseOptionsInternal(ctxt, options, encoding);
15210     if (encoding != NULL) {
15211         xmlCharEncodingHandlerPtr hdlr;
15212 
15213     hdlr = xmlFindCharEncodingHandler(encoding);
15214     if (hdlr != NULL)
15215         xmlSwitchToEncoding(ctxt, hdlr);
15216     }
15217     if ((URL != NULL) &amp;&amp; (ctxt-&gt;input != NULL) &amp;&amp;
15218         (ctxt-&gt;input-&gt;filename == NULL))
15219         ctxt-&gt;input-&gt;filename = (char *) xmlStrdup((const xmlChar *) URL);
15220     xmlParseDocument(ctxt);
15221     if ((ctxt-&gt;wellFormed) || ctxt-&gt;recovery)
15222         ret = ctxt-&gt;myDoc;
15223     else {
15224         ret = NULL;
15225     if (ctxt-&gt;myDoc != NULL) {
15226         xmlFreeDoc(ctxt-&gt;myDoc);
15227     }
15228     }
15229     ctxt-&gt;myDoc = NULL;
15230     if (!reuse) {
15231     xmlFreeParserCtxt(ctxt);
15232     }
15233 
15234     return (ret);
15235 }
15236 
15237 /**
15238  * xmlReadDoc:
15239  * @cur:  a pointer to a zero terminated string
15240  * @URL:  the base URL to use for the document
15241  * @encoding:  the document encoding, or NULL
15242  * @options:  a combination of xmlParserOption
15243  *
15244  * parse an XML in-memory document and build a tree.
15245  *
15246  * Returns the resulting document tree
15247  */
15248 xmlDocPtr
15249 xmlReadDoc(const xmlChar * cur, const char *URL, const char *encoding, int options)
15250 {
15251     xmlParserCtxtPtr ctxt;
15252 
15253     if (cur == NULL)
15254         return (NULL);
15255     xmlInitParser();
15256 
15257     ctxt = xmlCreateDocParserCtxt(cur);
15258     if (ctxt == NULL)
15259         return (NULL);
15260     return (xmlDoRead(ctxt, URL, encoding, options, 0));
15261 }
15262 
15263 /**
15264  * xmlReadFile:
15265  * @filename:  a file or URL
15266  * @encoding:  the document encoding, or NULL
15267  * @options:  a combination of xmlParserOption
15268  *
15269  * parse an XML file from the filesystem or the network.
15270  *
15271  * Returns the resulting document tree
15272  */
15273 xmlDocPtr
15274 xmlReadFile(const char *filename, const char *encoding, int options)
15275 {
15276     xmlParserCtxtPtr ctxt;
15277 
15278     xmlInitParser();
15279     ctxt = xmlCreateURLParserCtxt(filename, options);
15280     if (ctxt == NULL)
15281         return (NULL);
15282     return (xmlDoRead(ctxt, NULL, encoding, options, 0));
15283 }
15284 
15285 /**
15286  * xmlReadMemory:
15287  * @buffer:  a pointer to a char array
15288  * @size:  the size of the array
15289  * @URL:  the base URL to use for the document
15290  * @encoding:  the document encoding, or NULL
15291  * @options:  a combination of xmlParserOption
15292  *
15293  * parse an XML in-memory document and build a tree.
15294  *
15295  * Returns the resulting document tree
15296  */
15297 xmlDocPtr
15298 xmlReadMemory(const char *buffer, int size, const char *URL, const char *encoding, int options)
15299 {
15300     xmlParserCtxtPtr ctxt;
15301 
15302     xmlInitParser();
15303     ctxt = xmlCreateMemoryParserCtxt(buffer, size);
15304     if (ctxt == NULL)
15305         return (NULL);
15306     return (xmlDoRead(ctxt, URL, encoding, options, 0));
15307 }
15308 
15309 /**
15310  * xmlReadFd:
15311  * @fd:  an open file descriptor
15312  * @URL:  the base URL to use for the document
15313  * @encoding:  the document encoding, or NULL
15314  * @options:  a combination of xmlParserOption
15315  *
15316  * parse an XML from a file descriptor and build a tree.
15317  * NOTE that the file descriptor will not be closed when the
15318  *      reader is closed or reset.
15319  *
15320  * Returns the resulting document tree
15321  */
15322 xmlDocPtr
15323 xmlReadFd(int fd, const char *URL, const char *encoding, int options)
15324 {
15325     xmlParserCtxtPtr ctxt;
15326     xmlParserInputBufferPtr input;
15327     xmlParserInputPtr stream;
15328 
15329     if (fd &lt; 0)
15330         return (NULL);
15331     xmlInitParser();
15332 
15333     input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
15334     if (input == NULL)
15335         return (NULL);
15336     input-&gt;closecallback = NULL;
15337     ctxt = xmlNewParserCtxt();
15338     if (ctxt == NULL) {
15339         xmlFreeParserInputBuffer(input);
15340         return (NULL);
15341     }
15342     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
15343     if (stream == NULL) {
15344         xmlFreeParserInputBuffer(input);
15345     xmlFreeParserCtxt(ctxt);
15346         return (NULL);
15347     }
15348     inputPush(ctxt, stream);
15349     return (xmlDoRead(ctxt, URL, encoding, options, 0));
15350 }
15351 
15352 /**
15353  * xmlReadIO:
15354  * @ioread:  an I/O read function
15355  * @ioclose:  an I/O close function
15356  * @ioctx:  an I/O handler
15357  * @URL:  the base URL to use for the document
15358  * @encoding:  the document encoding, or NULL
15359  * @options:  a combination of xmlParserOption
15360  *
15361  * parse an XML document from I/O functions and source and build a tree.
15362  *
15363  * Returns the resulting document tree
15364  */
15365 xmlDocPtr
15366 xmlReadIO(xmlInputReadCallback ioread, xmlInputCloseCallback ioclose,
15367           void *ioctx, const char *URL, const char *encoding, int options)
15368 {
15369     xmlParserCtxtPtr ctxt;
15370     xmlParserInputBufferPtr input;
15371     xmlParserInputPtr stream;
15372 
15373     if (ioread == NULL)
15374         return (NULL);
15375     xmlInitParser();
15376 
15377     input = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx,
15378                                          XML_CHAR_ENCODING_NONE);
15379     if (input == NULL) {
15380         if (ioclose != NULL)
15381             ioclose(ioctx);
15382         return (NULL);
15383     }
15384     ctxt = xmlNewParserCtxt();
15385     if (ctxt == NULL) {
15386         xmlFreeParserInputBuffer(input);
15387         return (NULL);
15388     }
15389     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
15390     if (stream == NULL) {
15391         xmlFreeParserInputBuffer(input);
15392     xmlFreeParserCtxt(ctxt);
15393         return (NULL);
15394     }
15395     inputPush(ctxt, stream);
15396     return (xmlDoRead(ctxt, URL, encoding, options, 0));
15397 }
15398 
15399 /**
15400  * xmlCtxtReadDoc:
15401  * @ctxt:  an XML parser context
15402  * @cur:  a pointer to a zero terminated string
15403  * @URL:  the base URL to use for the document
15404  * @encoding:  the document encoding, or NULL
15405  * @options:  a combination of xmlParserOption
15406  *
15407  * parse an XML in-memory document and build a tree.
15408  * This reuses the existing @ctxt parser context
15409  *
15410  * Returns the resulting document tree
15411  */
15412 xmlDocPtr
15413 xmlCtxtReadDoc(xmlParserCtxtPtr ctxt, const xmlChar * cur,
15414                const char *URL, const char *encoding, int options)
15415 {
15416     xmlParserInputPtr stream;
15417 
15418     if (cur == NULL)
15419         return (NULL);
15420     if (ctxt == NULL)
15421         return (NULL);
15422     xmlInitParser();
15423 
15424     xmlCtxtReset(ctxt);
15425 
15426     stream = xmlNewStringInputStream(ctxt, cur);
15427     if (stream == NULL) {
15428         return (NULL);
15429     }
15430     inputPush(ctxt, stream);
15431     return (xmlDoRead(ctxt, URL, encoding, options, 1));
15432 }
15433 
15434 /**
15435  * xmlCtxtReadFile:
15436  * @ctxt:  an XML parser context
15437  * @filename:  a file or URL
15438  * @encoding:  the document encoding, or NULL
15439  * @options:  a combination of xmlParserOption
15440  *
15441  * parse an XML file from the filesystem or the network.
15442  * This reuses the existing @ctxt parser context
15443  *
15444  * Returns the resulting document tree
15445  */
15446 xmlDocPtr
15447 xmlCtxtReadFile(xmlParserCtxtPtr ctxt, const char *filename,
15448                 const char *encoding, int options)
15449 {
15450     xmlParserInputPtr stream;
15451 
15452     if (filename == NULL)
15453         return (NULL);
15454     if (ctxt == NULL)
15455         return (NULL);
15456     xmlInitParser();
15457 
15458     xmlCtxtReset(ctxt);
15459 
15460     stream = xmlLoadExternalEntity(filename, NULL, ctxt);
15461     if (stream == NULL) {
15462         return (NULL);
15463     }
15464     inputPush(ctxt, stream);
15465     return (xmlDoRead(ctxt, NULL, encoding, options, 1));
15466 }
15467 
15468 /**
15469  * xmlCtxtReadMemory:
15470  * @ctxt:  an XML parser context
15471  * @buffer:  a pointer to a char array
15472  * @size:  the size of the array
15473  * @URL:  the base URL to use for the document
15474  * @encoding:  the document encoding, or NULL
15475  * @options:  a combination of xmlParserOption
15476  *
15477  * parse an XML in-memory document and build a tree.
15478  * This reuses the existing @ctxt parser context
15479  *
15480  * Returns the resulting document tree
15481  */
15482 xmlDocPtr
15483 xmlCtxtReadMemory(xmlParserCtxtPtr ctxt, const char *buffer, int size,
15484                   const char *URL, const char *encoding, int options)
15485 {
15486     xmlParserInputBufferPtr input;
15487     xmlParserInputPtr stream;
15488 
15489     if (ctxt == NULL)
15490         return (NULL);
15491     if (buffer == NULL)
15492         return (NULL);
15493     xmlInitParser();
15494 
15495     xmlCtxtReset(ctxt);
15496 
15497     input = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
15498     if (input == NULL) {
15499     return(NULL);
15500     }
15501 
15502     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
15503     if (stream == NULL) {
15504     xmlFreeParserInputBuffer(input);
15505     return(NULL);
15506     }
15507 
15508     inputPush(ctxt, stream);
15509     return (xmlDoRead(ctxt, URL, encoding, options, 1));
15510 }
15511 
15512 /**
15513  * xmlCtxtReadFd:
15514  * @ctxt:  an XML parser context
15515  * @fd:  an open file descriptor
15516  * @URL:  the base URL to use for the document
15517  * @encoding:  the document encoding, or NULL
15518  * @options:  a combination of xmlParserOption
15519  *
15520  * parse an XML from a file descriptor and build a tree.
15521  * This reuses the existing @ctxt parser context
15522  * NOTE that the file descriptor will not be closed when the
15523  *      reader is closed or reset.
15524  *
15525  * Returns the resulting document tree
15526  */
15527 xmlDocPtr
15528 xmlCtxtReadFd(xmlParserCtxtPtr ctxt, int fd,
15529               const char *URL, const char *encoding, int options)
15530 {
15531     xmlParserInputBufferPtr input;
15532     xmlParserInputPtr stream;
15533 
15534     if (fd &lt; 0)
15535         return (NULL);
15536     if (ctxt == NULL)
15537         return (NULL);
15538     xmlInitParser();
15539 
15540     xmlCtxtReset(ctxt);
15541 
15542 
15543     input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
15544     if (input == NULL)
15545         return (NULL);
15546     input-&gt;closecallback = NULL;
15547     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
15548     if (stream == NULL) {
15549         xmlFreeParserInputBuffer(input);
15550         return (NULL);
15551     }
15552     inputPush(ctxt, stream);
15553     return (xmlDoRead(ctxt, URL, encoding, options, 1));
15554 }
15555 
15556 /**
15557  * xmlCtxtReadIO:
15558  * @ctxt:  an XML parser context
15559  * @ioread:  an I/O read function
15560  * @ioclose:  an I/O close function
15561  * @ioctx:  an I/O handler
15562  * @URL:  the base URL to use for the document
15563  * @encoding:  the document encoding, or NULL
15564  * @options:  a combination of xmlParserOption
15565  *
15566  * parse an XML document from I/O functions and source and build a tree.
15567  * This reuses the existing @ctxt parser context
15568  *
15569  * Returns the resulting document tree
15570  */
15571 xmlDocPtr
15572 xmlCtxtReadIO(xmlParserCtxtPtr ctxt, xmlInputReadCallback ioread,
15573               xmlInputCloseCallback ioclose, void *ioctx,
15574           const char *URL,
15575               const char *encoding, int options)
15576 {
15577     xmlParserInputBufferPtr input;
15578     xmlParserInputPtr stream;
15579 
15580     if (ioread == NULL)
15581         return (NULL);
15582     if (ctxt == NULL)
15583         return (NULL);
15584     xmlInitParser();
15585 
15586     xmlCtxtReset(ctxt);
15587 
15588     input = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx,
15589                                          XML_CHAR_ENCODING_NONE);
15590     if (input == NULL) {
15591         if (ioclose != NULL)
15592             ioclose(ioctx);
15593         return (NULL);
15594     }
15595     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
15596     if (stream == NULL) {
15597         xmlFreeParserInputBuffer(input);
15598         return (NULL);
15599     }
15600     inputPush(ctxt, stream);
15601     return (xmlDoRead(ctxt, URL, encoding, options, 1));
15602 }
15603 
15604 #define bottom_parser
15605 #include &quot;elfgcchack.h&quot;
<a name="104" id="anc104"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="104" type="hidden" />
</body>
</html>
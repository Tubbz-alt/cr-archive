<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/parserInternals.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="parser.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="pattern.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/parserInternals.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 686     }
 687     }
 688     /*
 689      * Assume it&#39;s a fixed length encoding (1) with
 690      * a compatible encoding for the ASCII set, since
 691      * XML constructs only use &lt; 128 chars
 692      */
 693     *len = 1;
 694     if (*ctxt-&gt;input-&gt;cur == 0xD) {
 695     if (ctxt-&gt;input-&gt;cur[1] == 0xA) {
 696         ctxt-&gt;nbChars++;
 697         ctxt-&gt;input-&gt;cur++;
 698     }
 699     return(0xA);
 700     }
 701     return((int) *ctxt-&gt;input-&gt;cur);
 702 encoding_error:
 703     /*
 704      * An encoding problem may arise from a truncated input buffer
 705      * splitting a character in the middle. In that case do not raise
<span class="line-modified"> 706      * an error but return 0 to endicate an end of stream problem</span>
 707      */
 708     if (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; 4) {
 709     *len = 0;
 710     return(0);
 711     }
 712 
 713     /*
 714      * If we detect an UTF8 error that probably mean that the
 715      * input encoding didn&#39;t get properly advertised in the
 716      * declaration header. Report the error and switch the encoding
 717      * to ISO-Latin-1 (if you don&#39;t like this policy, just declare the
 718      * encoding !)
 719      */
 720     {
 721         char buffer[150];
 722 
 723     snprintf(&amp;buffer[0], 149, &quot;Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n&quot;,
 724             ctxt-&gt;input-&gt;cur[0], ctxt-&gt;input-&gt;cur[1],
 725             ctxt-&gt;input-&gt;cur[2], ctxt-&gt;input-&gt;cur[3]);
 726     __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
</pre>
<hr />
<pre>
 799             }
 800             return (val);
 801         } else {
 802             /* 1-byte code */
 803             *len = 1;
 804             return ((int) *cur);
 805         }
 806     }
 807     /*
 808      * Assume it&#39;s a fixed length encoding (1) with
 809      * a compatible encoding for the ASCII set, since
 810      * XML constructs only use &lt; 128 chars
 811      */
 812     *len = 1;
 813     return ((int) *cur);
 814 encoding_error:
 815 
 816     /*
 817      * An encoding problem may arise from a truncated input buffer
 818      * splitting a character in the middle. In that case do not raise
<span class="line-modified"> 819      * an error but return 0 to endicate an end of stream problem</span>
 820      */
 821     if ((ctxt == NULL) || (ctxt-&gt;input == NULL) ||
 822         (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; 4)) {
 823     *len = 0;
 824     return(0);
 825     }
 826     /*
 827      * If we detect an UTF8 error that probably mean that the
 828      * input encoding didn&#39;t get properly advertised in the
 829      * declaration header. Report the error and switch the encoding
 830      * to ISO-Latin-1 (if you don&#39;t like this policy, just declare the
 831      * encoding !)
 832      */
 833     {
 834         char buffer[150];
 835 
 836     snprintf(buffer, 149, &quot;Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n&quot;,
 837             ctxt-&gt;input-&gt;cur[0], ctxt-&gt;input-&gt;cur[1],
 838             ctxt-&gt;input-&gt;cur[2], ctxt-&gt;input-&gt;cur[3]);
 839     __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
</pre>
<hr />
<pre>
1076         case XML_CHAR_ENCODING_2022_JP:
1077         __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
1078                    &quot;encoding not supported %s\n&quot;,
1079                    BAD_CAST &quot;ISO-2022-JP&quot;, NULL);
1080         break;
1081         case XML_CHAR_ENCODING_SHIFT_JIS:
1082         __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
1083                    &quot;encoding not supported %s\n&quot;,
1084                    BAD_CAST &quot;Shift_JIS&quot;, NULL);
1085         break;
1086         case XML_CHAR_ENCODING_EUC_JP:
1087         __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
1088                    &quot;encoding not supported %s\n&quot;,
1089                    BAD_CAST &quot;EUC-JP&quot;, NULL);
1090         break;
1091         default:
1092             break;
1093     }
1094     }
1095     /*
<span class="line-modified">1096      * TODO: We could recover from errors in external entites if we</span>
1097      * didn&#39;t stop the parser. But most callers of this function don&#39;t
1098      * check the return value.
1099      */
1100     if (handler == NULL) {
1101         xmlStopParser(ctxt);
1102     return(-1);
1103     }
1104     ctxt-&gt;charset = XML_CHAR_ENCODING_UTF8;
1105     ret = xmlSwitchToEncodingInt(ctxt, handler, len);
1106     if ((ret &lt; 0) || (ctxt-&gt;errNo == XML_I18N_CONV_FAILED)) {
1107         /*
1108      * on encoding conversion errors, stop the parser
1109      */
1110         xmlStopParser(ctxt);
1111     ctxt-&gt;errNo = XML_I18N_CONV_FAILED;
1112     }
1113     return(ret);
1114 }
1115 
1116 /**
</pre>
<hr />
<pre>
1121  * @len:  the number of bytes to convert for the first line or -1
1122  *
1123  * change the input functions when discovering the character encoding
1124  * of a given entity.
1125  *
1126  * Returns 0 in case of success, -1 otherwise
1127  */
1128 static int
1129 xmlSwitchInputEncodingInt(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,
1130                           xmlCharEncodingHandlerPtr handler, int len)
1131 {
1132     int nbchars;
1133 
1134     if (handler == NULL)
1135         return (-1);
1136     if (input == NULL)
1137         return (-1);
1138     if (input-&gt;buf != NULL) {
1139         if (input-&gt;buf-&gt;encoder != NULL) {
1140             /*
<span class="line-modified">1141              * Check in case the auto encoding detetection triggered</span>
1142              * in already.
1143              */
1144             if (input-&gt;buf-&gt;encoder == handler)
1145                 return (0);
1146 
1147             /*
1148              * &quot;UTF-16&quot; can be used for both LE and BE
1149              if ((!xmlStrncmp(BAD_CAST input-&gt;buf-&gt;encoder-&gt;name,
1150              BAD_CAST &quot;UTF-16&quot;, 6)) &amp;&amp;
1151              (!xmlStrncmp(BAD_CAST handler-&gt;name,
1152              BAD_CAST &quot;UTF-16&quot;, 6))) {
1153              return(0);
1154              }
1155              */
1156 
1157             /*
1158              * Note: this is a bit dangerous, but that&#39;s what it
1159              * takes to use nearly compatible signature for different
1160              * encodings.
1161              */
</pre>
</td>
<td>
<hr />
<pre>
 686     }
 687     }
 688     /*
 689      * Assume it&#39;s a fixed length encoding (1) with
 690      * a compatible encoding for the ASCII set, since
 691      * XML constructs only use &lt; 128 chars
 692      */
 693     *len = 1;
 694     if (*ctxt-&gt;input-&gt;cur == 0xD) {
 695     if (ctxt-&gt;input-&gt;cur[1] == 0xA) {
 696         ctxt-&gt;nbChars++;
 697         ctxt-&gt;input-&gt;cur++;
 698     }
 699     return(0xA);
 700     }
 701     return((int) *ctxt-&gt;input-&gt;cur);
 702 encoding_error:
 703     /*
 704      * An encoding problem may arise from a truncated input buffer
 705      * splitting a character in the middle. In that case do not raise
<span class="line-modified"> 706      * an error but return 0 to indicate an end of stream problem</span>
 707      */
 708     if (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; 4) {
 709     *len = 0;
 710     return(0);
 711     }
 712 
 713     /*
 714      * If we detect an UTF8 error that probably mean that the
 715      * input encoding didn&#39;t get properly advertised in the
 716      * declaration header. Report the error and switch the encoding
 717      * to ISO-Latin-1 (if you don&#39;t like this policy, just declare the
 718      * encoding !)
 719      */
 720     {
 721         char buffer[150];
 722 
 723     snprintf(&amp;buffer[0], 149, &quot;Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n&quot;,
 724             ctxt-&gt;input-&gt;cur[0], ctxt-&gt;input-&gt;cur[1],
 725             ctxt-&gt;input-&gt;cur[2], ctxt-&gt;input-&gt;cur[3]);
 726     __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
</pre>
<hr />
<pre>
 799             }
 800             return (val);
 801         } else {
 802             /* 1-byte code */
 803             *len = 1;
 804             return ((int) *cur);
 805         }
 806     }
 807     /*
 808      * Assume it&#39;s a fixed length encoding (1) with
 809      * a compatible encoding for the ASCII set, since
 810      * XML constructs only use &lt; 128 chars
 811      */
 812     *len = 1;
 813     return ((int) *cur);
 814 encoding_error:
 815 
 816     /*
 817      * An encoding problem may arise from a truncated input buffer
 818      * splitting a character in the middle. In that case do not raise
<span class="line-modified"> 819      * an error but return 0 to indicate an end of stream problem</span>
 820      */
 821     if ((ctxt == NULL) || (ctxt-&gt;input == NULL) ||
 822         (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; 4)) {
 823     *len = 0;
 824     return(0);
 825     }
 826     /*
 827      * If we detect an UTF8 error that probably mean that the
 828      * input encoding didn&#39;t get properly advertised in the
 829      * declaration header. Report the error and switch the encoding
 830      * to ISO-Latin-1 (if you don&#39;t like this policy, just declare the
 831      * encoding !)
 832      */
 833     {
 834         char buffer[150];
 835 
 836     snprintf(buffer, 149, &quot;Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n&quot;,
 837             ctxt-&gt;input-&gt;cur[0], ctxt-&gt;input-&gt;cur[1],
 838             ctxt-&gt;input-&gt;cur[2], ctxt-&gt;input-&gt;cur[3]);
 839     __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
</pre>
<hr />
<pre>
1076         case XML_CHAR_ENCODING_2022_JP:
1077         __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
1078                    &quot;encoding not supported %s\n&quot;,
1079                    BAD_CAST &quot;ISO-2022-JP&quot;, NULL);
1080         break;
1081         case XML_CHAR_ENCODING_SHIFT_JIS:
1082         __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
1083                    &quot;encoding not supported %s\n&quot;,
1084                    BAD_CAST &quot;Shift_JIS&quot;, NULL);
1085         break;
1086         case XML_CHAR_ENCODING_EUC_JP:
1087         __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
1088                    &quot;encoding not supported %s\n&quot;,
1089                    BAD_CAST &quot;EUC-JP&quot;, NULL);
1090         break;
1091         default:
1092             break;
1093     }
1094     }
1095     /*
<span class="line-modified">1096      * TODO: We could recover from errors in external entities if we</span>
1097      * didn&#39;t stop the parser. But most callers of this function don&#39;t
1098      * check the return value.
1099      */
1100     if (handler == NULL) {
1101         xmlStopParser(ctxt);
1102     return(-1);
1103     }
1104     ctxt-&gt;charset = XML_CHAR_ENCODING_UTF8;
1105     ret = xmlSwitchToEncodingInt(ctxt, handler, len);
1106     if ((ret &lt; 0) || (ctxt-&gt;errNo == XML_I18N_CONV_FAILED)) {
1107         /*
1108      * on encoding conversion errors, stop the parser
1109      */
1110         xmlStopParser(ctxt);
1111     ctxt-&gt;errNo = XML_I18N_CONV_FAILED;
1112     }
1113     return(ret);
1114 }
1115 
1116 /**
</pre>
<hr />
<pre>
1121  * @len:  the number of bytes to convert for the first line or -1
1122  *
1123  * change the input functions when discovering the character encoding
1124  * of a given entity.
1125  *
1126  * Returns 0 in case of success, -1 otherwise
1127  */
1128 static int
1129 xmlSwitchInputEncodingInt(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,
1130                           xmlCharEncodingHandlerPtr handler, int len)
1131 {
1132     int nbchars;
1133 
1134     if (handler == NULL)
1135         return (-1);
1136     if (input == NULL)
1137         return (-1);
1138     if (input-&gt;buf != NULL) {
1139         if (input-&gt;buf-&gt;encoder != NULL) {
1140             /*
<span class="line-modified">1141              * Check in case the auto encoding detection triggered</span>
1142              * in already.
1143              */
1144             if (input-&gt;buf-&gt;encoder == handler)
1145                 return (0);
1146 
1147             /*
1148              * &quot;UTF-16&quot; can be used for both LE and BE
1149              if ((!xmlStrncmp(BAD_CAST input-&gt;buf-&gt;encoder-&gt;name,
1150              BAD_CAST &quot;UTF-16&quot;, 6)) &amp;&amp;
1151              (!xmlStrncmp(BAD_CAST handler-&gt;name,
1152              BAD_CAST &quot;UTF-16&quot;, 6))) {
1153              return(0);
1154              }
1155              */
1156 
1157             /*
1158              * Note: this is a bit dangerous, but that&#39;s what it
1159              * takes to use nearly compatible signature for different
1160              * encodings.
1161              */
</pre>
</td>
</tr>
</table>
<center><a href="parser.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="pattern.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
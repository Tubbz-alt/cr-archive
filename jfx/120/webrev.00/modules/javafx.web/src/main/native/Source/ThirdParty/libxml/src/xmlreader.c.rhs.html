<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/xmlreader.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * xmlreader.c: implements the xmlTextReader streaming node API
   3  *
   4  * NOTE:
   5  *   XmlTextReader.Normalization Property won&#39;t be supported, since
   6  *     it makes the parser non compliant to the XML recommendation
   7  *
   8  * See Copyright for the status of this software.
   9  *
  10  * daniel@veillard.com
  11  */
  12 
  13 /*
  14  * TODOs:
  15  *   - XML Schemas validation
  16  */
  17 #define IN_LIBXML
  18 #include &quot;libxml.h&quot;
  19 
  20 #ifdef LIBXML_READER_ENABLED
  21 #include &lt;string.h&gt; /* for memset() only ! */
  22 #include &lt;stdarg.h&gt;
  23 
  24 #ifdef HAVE_CTYPE_H
  25 #include &lt;ctype.h&gt;
  26 #endif
  27 #ifdef HAVE_STDLIB_H
  28 #include &lt;stdlib.h&gt;
  29 #endif
  30 
  31 #include &lt;libxml/xmlmemory.h&gt;
  32 #include &lt;libxml/xmlIO.h&gt;
  33 #include &lt;libxml/xmlreader.h&gt;
  34 #include &lt;libxml/parserInternals.h&gt;
  35 #ifdef LIBXML_SCHEMAS_ENABLED
  36 #include &lt;libxml/relaxng.h&gt;
  37 #include &lt;libxml/xmlschemas.h&gt;
  38 #endif
  39 #include &lt;libxml/uri.h&gt;
  40 #ifdef LIBXML_XINCLUDE_ENABLED
  41 #include &lt;libxml/xinclude.h&gt;
  42 #endif
  43 #ifdef LIBXML_PATTERN_ENABLED
  44 #include &lt;libxml/pattern.h&gt;
  45 #endif
  46 
  47 #include &quot;buf.h&quot;
  48 
  49 #define MAX_ERR_MSG_SIZE 64000
  50 
  51 /*
  52  * The following VA_COPY was coded following an example in
  53  * the Samba project.  It may not be sufficient for some
  54  * esoteric implementations of va_list but (hopefully) will
  55  * be sufficient for libxml2.
  56  */
  57 #ifndef VA_COPY
  58   #ifdef HAVE_VA_COPY
  59     #define VA_COPY(dest, src) va_copy(dest, src)
  60   #else
  61     #ifdef HAVE___VA_COPY
  62       #define VA_COPY(dest,src) __va_copy(dest, src)
  63     #else
  64       #ifndef VA_LIST_IS_ARRAY
  65         #define VA_COPY(dest,src) (dest) = (src)
  66       #else
  67         #include &lt;string.h&gt;
  68         #define VA_COPY(dest,src) memcpy((char *)(dest),(char *)(src),sizeof(va_list))
  69       #endif
  70     #endif
  71   #endif
  72 #endif
  73 
  74 /* #define DEBUG_CALLBACKS */
  75 /* #define DEBUG_READER */
  76 
  77 /**
  78  * TODO:
  79  *
  80  * macro to flag unimplemented blocks
  81  */
  82 #define TODO                                \
  83     xmlGenericError(xmlGenericErrorContext,             \
  84         &quot;Unimplemented block at %s:%d\n&quot;,               \
  85             __FILE__, __LINE__);
  86 
  87 #ifdef DEBUG_READER
  88 #define DUMP_READER xmlTextReaderDebug(reader);
  89 #else
  90 #define DUMP_READER
  91 #endif
  92 
  93 #define CHUNK_SIZE 512
  94 /************************************************************************
  95  *                                  *
  96  *  The parser: maps the Text Reader API on top of the existing *
  97  *      parsing routines building a tree            *
  98  *                                  *
  99  ************************************************************************/
 100 
 101 #define XML_TEXTREADER_INPUT    1
 102 #define XML_TEXTREADER_CTXT 2
 103 
 104 typedef enum {
 105     XML_TEXTREADER_NONE = -1,
 106     XML_TEXTREADER_START= 0,
 107     XML_TEXTREADER_ELEMENT= 1,
 108     XML_TEXTREADER_END= 2,
 109     XML_TEXTREADER_EMPTY= 3,
 110     XML_TEXTREADER_BACKTRACK= 4,
 111     XML_TEXTREADER_DONE= 5,
 112     XML_TEXTREADER_ERROR= 6
 113 } xmlTextReaderState;
 114 
 115 typedef enum {
 116     XML_TEXTREADER_NOT_VALIDATE = 0,
 117     XML_TEXTREADER_VALIDATE_DTD = 1,
 118     XML_TEXTREADER_VALIDATE_RNG = 2,
 119     XML_TEXTREADER_VALIDATE_XSD = 4
 120 } xmlTextReaderValidate;
 121 
 122 struct _xmlTextReader {
 123     int             mode;   /* the parsing mode */
 124     xmlDocPtr           doc;    /* when walking an existing doc */
 125     xmlTextReaderValidate       validate;/* is there any validation */
 126     int             allocs; /* what structure were deallocated */
 127     xmlTextReaderState      state;
 128     xmlParserCtxtPtr        ctxt;   /* the parser context */
 129     xmlSAXHandlerPtr        sax;    /* the parser SAX callbacks */
 130     xmlParserInputBufferPtr input;  /* the input */
 131     startElementSAXFunc     startElement;/* initial SAX callbacks */
 132     endElementSAXFunc       endElement;  /* idem */
 133     startElementNsSAX2Func  startElementNs;/* idem */
 134     endElementNsSAX2Func    endElementNs;  /* idem */
 135     charactersSAXFunc       characters;
 136     cdataBlockSAXFunc       cdataBlock;
 137     unsigned int        base;   /* base of the segment in the input */
 138     unsigned int        cur;    /* current position in the input */
 139     xmlNodePtr          node;   /* current node */
 140     xmlNodePtr          curnode;/* current attribute node */
 141     int             depth;  /* depth of the current node */
 142     xmlNodePtr          faketext;/* fake xmlNs chld */
 143     int             preserve;/* preserve the resulting document */
 144     xmlBufPtr               buffer; /* used to return const xmlChar * */
 145     xmlDictPtr          dict;   /* the context dictionary */
 146 
 147     /* entity stack when traversing entities content */
 148     xmlNodePtr         ent;          /* Current Entity Ref Node */
 149     int                entNr;        /* Depth of the entities stack */
 150     int                entMax;       /* Max depth of the entities stack */
 151     xmlNodePtr        *entTab;       /* array of entities */
 152 
 153     /* error handling */
 154     xmlTextReaderErrorFunc errorFunc;    /* callback function */
 155     void                  *errorFuncArg; /* callback function user argument */
 156 
 157 #ifdef LIBXML_SCHEMAS_ENABLED
 158     /* Handling of RelaxNG validation */
 159     xmlRelaxNGPtr          rngSchemas;  /* The Relax NG schemas */
 160     xmlRelaxNGValidCtxtPtr rngValidCtxt;/* The Relax NG validation context */
 161     int                    rngPreserveCtxt; /* 1 if the context was provided by the user */
 162     int                    rngValidErrors;/* The number of errors detected */
 163     xmlNodePtr             rngFullNode; /* the node if RNG not progressive */
 164     /* Handling of Schemas validation */
 165     xmlSchemaPtr          xsdSchemas;   /* The Schemas schemas */
 166     xmlSchemaValidCtxtPtr xsdValidCtxt;/* The Schemas validation context */
 167     int                   xsdPreserveCtxt; /* 1 if the context was provided by the user */
 168     int                   xsdValidErrors;/* The number of errors detected */
 169     xmlSchemaSAXPlugPtr   xsdPlug;  /* the schemas plug in SAX pipeline */
 170 #endif
 171 #ifdef LIBXML_XINCLUDE_ENABLED
 172     /* Handling of XInclude processing */
 173     int                xinclude;    /* is xinclude asked for */
 174     const xmlChar *    xinclude_name;   /* the xinclude name from dict */
 175     xmlXIncludeCtxtPtr xincctxt;    /* the xinclude context */
 176     int                in_xinclude; /* counts for xinclude */
 177 #endif
 178 #ifdef LIBXML_PATTERN_ENABLED
 179     int                patternNr;       /* number of preserve patterns */
 180     int                patternMax;      /* max preserve patterns */
 181     xmlPatternPtr     *patternTab;      /* array of preserve patterns */
 182 #endif
 183     int                preserves;   /* level of preserves */
 184     int                parserFlags; /* the set of options set */
 185     /* Structured error handling */
 186     xmlStructuredErrorFunc sErrorFunc;  /* callback function */
 187 };
 188 
 189 #define NODE_IS_EMPTY       0x1
 190 #define NODE_IS_PRESERVED   0x2
 191 #define NODE_IS_SPRESERVED  0x4
 192 
 193 /**
 194  * CONSTSTR:
 195  *
 196  * Macro used to return an interned string
 197  */
 198 #define CONSTSTR(str) xmlDictLookup(reader-&gt;dict, (str), -1)
 199 #define CONSTQSTR(p, str) xmlDictQLookup(reader-&gt;dict, (p), (str))
 200 
 201 static int xmlTextReaderReadTree(xmlTextReaderPtr reader);
 202 static int xmlTextReaderNextTree(xmlTextReaderPtr reader);
 203 
 204 /************************************************************************
 205  *                                  *
 206  *  Our own version of the freeing routines as we recycle nodes *
 207  *                                  *
 208  ************************************************************************/
 209 /**
 210  * DICT_FREE:
 211  * @str:  a string
 212  *
 213  * Free a string if it is not owned by the &quot;dict&quot; dictionary in the
 214  * current scope
 215  */
 216 #define DICT_FREE(str)                      \
 217     if ((str) &amp;&amp; ((!dict) ||                \
 218         (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))  \
 219         xmlFree((char *)(str));
 220 
 221 static void xmlTextReaderFreeNode(xmlTextReaderPtr reader, xmlNodePtr cur);
 222 static void xmlTextReaderFreeNodeList(xmlTextReaderPtr reader, xmlNodePtr cur);
 223 
 224 /**
 225  * xmlFreeID:
 226  * @not:  A id
 227  *
 228  * Deallocate the memory used by an id definition
 229  */
 230 static void
 231 xmlFreeID(xmlIDPtr id) {
 232     xmlDictPtr dict = NULL;
 233 
 234     if (id == NULL) return;
 235 
 236     if (id-&gt;doc != NULL)
 237         dict = id-&gt;doc-&gt;dict;
 238 
 239     if (id-&gt;value != NULL)
 240     DICT_FREE(id-&gt;value)
<a name="1" id="anc1"></a><span class="line-added"> 241     if (id-&gt;name != NULL)</span>
<span class="line-added"> 242     DICT_FREE(id-&gt;name)</span>
 243     xmlFree(id);
 244 }
 245 
 246 /**
 247  * xmlTextReaderRemoveID:
 248  * @doc:  the document
 249  * @attr:  the attribute
 250  *
 251  * Remove the given attribute from the ID table maintained internally.
 252  *
 253  * Returns -1 if the lookup failed and 0 otherwise
 254  */
 255 static int
 256 xmlTextReaderRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {
 257     xmlIDTablePtr table;
 258     xmlIDPtr id;
 259     xmlChar *ID;
 260 
 261     if (doc == NULL) return(-1);
 262     if (attr == NULL) return(-1);
 263     table = (xmlIDTablePtr) doc-&gt;ids;
 264     if (table == NULL)
 265         return(-1);
 266 
 267     ID = xmlNodeListGetString(doc, attr-&gt;children, 1);
 268     if (ID == NULL)
 269     return(-1);
 270     id = xmlHashLookup(table, ID);
 271     xmlFree(ID);
 272     if (id == NULL || id-&gt;attr != attr) {
 273     return(-1);
 274     }
 275     id-&gt;name = attr-&gt;name;
<a name="2" id="anc2"></a><span class="line-added"> 276     attr-&gt;name = NULL;</span>
 277     id-&gt;attr = NULL;
 278     return(0);
 279 }
 280 
 281 /**
 282  * xmlTextReaderFreeProp:
 283  * @reader:  the xmlTextReaderPtr used
 284  * @cur:  the node
 285  *
 286  * Free a node.
 287  */
 288 static void
 289 xmlTextReaderFreeProp(xmlTextReaderPtr reader, xmlAttrPtr cur) {
 290     xmlDictPtr dict;
 291 
 292     if ((reader != NULL) &amp;&amp; (reader-&gt;ctxt != NULL))
 293     dict = reader-&gt;ctxt-&gt;dict;
 294     else
 295         dict = NULL;
 296     if (cur == NULL) return;
 297 
 298     if ((__xmlRegisterCallbacks) &amp;&amp; (xmlDeregisterNodeDefaultValue))
 299     xmlDeregisterNodeDefaultValue((xmlNodePtr) cur);
 300 
 301     /* Check for ID removal -&gt; leading to invalid references ! */
 302     if ((cur-&gt;parent != NULL) &amp;&amp; (cur-&gt;parent-&gt;doc != NULL) &amp;&amp;
 303     ((cur-&gt;parent-&gt;doc-&gt;intSubset != NULL) ||
 304      (cur-&gt;parent-&gt;doc-&gt;extSubset != NULL))) {
 305         if (xmlIsID(cur-&gt;parent-&gt;doc, cur-&gt;parent, cur))
 306         xmlTextReaderRemoveID(cur-&gt;parent-&gt;doc, cur);
 307     }
 308     if (cur-&gt;children != NULL)
 309         xmlTextReaderFreeNodeList(reader, cur-&gt;children);
 310 
 311     DICT_FREE(cur-&gt;name);
 312     if ((reader != NULL) &amp;&amp; (reader-&gt;ctxt != NULL) &amp;&amp;
 313         (reader-&gt;ctxt-&gt;freeAttrsNr &lt; 100)) {
 314         cur-&gt;next = reader-&gt;ctxt-&gt;freeAttrs;
 315     reader-&gt;ctxt-&gt;freeAttrs = cur;
 316     reader-&gt;ctxt-&gt;freeAttrsNr++;
 317     } else {
 318     xmlFree(cur);
 319     }
 320 }
 321 
 322 /**
 323  * xmlTextReaderFreePropList:
 324  * @reader:  the xmlTextReaderPtr used
 325  * @cur:  the first property in the list
 326  *
 327  * Free a property and all its siblings, all the children are freed too.
 328  */
 329 static void
 330 xmlTextReaderFreePropList(xmlTextReaderPtr reader, xmlAttrPtr cur) {
 331     xmlAttrPtr next;
 332 
 333     while (cur != NULL) {
 334         next = cur-&gt;next;
 335         xmlTextReaderFreeProp(reader, cur);
 336     cur = next;
 337     }
 338 }
 339 
 340 /**
 341  * xmlTextReaderFreeNodeList:
 342  * @reader:  the xmlTextReaderPtr used
 343  * @cur:  the first node in the list
 344  *
 345  * Free a node and all its siblings, this is a recursive behaviour, all
 346  * the children are freed too.
 347  */
 348 static void
 349 xmlTextReaderFreeNodeList(xmlTextReaderPtr reader, xmlNodePtr cur) {
 350     xmlNodePtr next;
<a name="3" id="anc3"></a><span class="line-added"> 351     xmlNodePtr parent;</span>
 352     xmlDictPtr dict;
<a name="4" id="anc4"></a><span class="line-added"> 353     size_t depth = 0;</span>
 354 
 355     if ((reader != NULL) &amp;&amp; (reader-&gt;ctxt != NULL))
 356     dict = reader-&gt;ctxt-&gt;dict;
 357     else
 358         dict = NULL;
 359     if (cur == NULL) return;
 360     if (cur-&gt;type == XML_NAMESPACE_DECL) {
 361     xmlFreeNsList((xmlNsPtr) cur);
 362     return;
 363     }
 364     if ((cur-&gt;type == XML_DOCUMENT_NODE) ||
 365     (cur-&gt;type == XML_HTML_DOCUMENT_NODE)) {
 366     xmlFreeDoc((xmlDocPtr) cur);
 367     return;
 368     }
<a name="5" id="anc5"></a><span class="line-modified"> 369     while (1) {</span>
<span class="line-added"> 370         while ((cur-&gt;type != XML_DTD_NODE) &amp;&amp;</span>
<span class="line-added"> 371                (cur-&gt;type != XML_ENTITY_REF_NODE) &amp;&amp;</span>
<span class="line-added"> 372                (cur-&gt;children != NULL) &amp;&amp;</span>
<span class="line-added"> 373                (cur-&gt;children-&gt;parent == cur)) {</span>
<span class="line-added"> 374             cur = cur-&gt;children;</span>
<span class="line-added"> 375             depth += 1;</span>
<span class="line-added"> 376         }</span>
<span class="line-added"> 377 </span>
 378         next = cur-&gt;next;
<a name="6" id="anc6"></a><span class="line-added"> 379         parent = cur-&gt;parent;</span>
<span class="line-added"> 380 </span>
 381     /* unroll to speed up freeing the document */
 382     if (cur-&gt;type != XML_DTD_NODE) {
 383 
<a name="7" id="anc7"></a>






 384         if ((__xmlRegisterCallbacks) &amp;&amp; (xmlDeregisterNodeDefaultValue))
 385         xmlDeregisterNodeDefaultValue(cur);
 386 
 387         if (((cur-&gt;type == XML_ELEMENT_NODE) ||
 388          (cur-&gt;type == XML_XINCLUDE_START) ||
 389          (cur-&gt;type == XML_XINCLUDE_END)) &amp;&amp;
 390         (cur-&gt;properties != NULL))
 391         xmlTextReaderFreePropList(reader, cur-&gt;properties);
 392         if ((cur-&gt;content != (xmlChar *) &amp;(cur-&gt;properties)) &amp;&amp;
 393             (cur-&gt;type != XML_ELEMENT_NODE) &amp;&amp;
 394         (cur-&gt;type != XML_XINCLUDE_START) &amp;&amp;
 395         (cur-&gt;type != XML_XINCLUDE_END) &amp;&amp;
 396         (cur-&gt;type != XML_ENTITY_REF_NODE)) {
 397         DICT_FREE(cur-&gt;content);
 398         }
 399         if (((cur-&gt;type == XML_ELEMENT_NODE) ||
 400              (cur-&gt;type == XML_XINCLUDE_START) ||
 401          (cur-&gt;type == XML_XINCLUDE_END)) &amp;&amp;
 402         (cur-&gt;nsDef != NULL))
 403         xmlFreeNsList(cur-&gt;nsDef);
 404 
 405         /*
 406          * we don&#39;t free element names here they are interned now
 407          */
 408         if ((cur-&gt;type != XML_TEXT_NODE) &amp;&amp;
 409         (cur-&gt;type != XML_COMMENT_NODE))
 410         DICT_FREE(cur-&gt;name);
 411         if (((cur-&gt;type == XML_ELEMENT_NODE) ||
 412          (cur-&gt;type == XML_TEXT_NODE)) &amp;&amp;
 413             (reader != NULL) &amp;&amp; (reader-&gt;ctxt != NULL) &amp;&amp;
 414         (reader-&gt;ctxt-&gt;freeElemsNr &lt; 100)) {
 415             cur-&gt;next = reader-&gt;ctxt-&gt;freeElems;
 416         reader-&gt;ctxt-&gt;freeElems = cur;
 417         reader-&gt;ctxt-&gt;freeElemsNr++;
 418         } else {
 419         xmlFree(cur);
 420         }
 421     }
<a name="8" id="anc8"></a><span class="line-added"> 422 </span>
<span class="line-added"> 423         if (next != NULL) {</span>
 424     cur = next;
<a name="9" id="anc9"></a><span class="line-added"> 425         } else {</span>
<span class="line-added"> 426             if ((depth == 0) || (parent == NULL))</span>
<span class="line-added"> 427                 break;</span>
<span class="line-added"> 428             depth -= 1;</span>
<span class="line-added"> 429             cur = parent;</span>
<span class="line-added"> 430             cur-&gt;children = NULL;</span>
<span class="line-added"> 431         }</span>
 432     }
 433 }
 434 
 435 /**
 436  * xmlTextReaderFreeNode:
 437  * @reader:  the xmlTextReaderPtr used
 438  * @cur:  the node
 439  *
 440  * Free a node, this is a recursive behaviour, all the children are freed too.
 441  * This doesn&#39;t unlink the child from the list, use xmlUnlinkNode() first.
 442  */
 443 static void
 444 xmlTextReaderFreeNode(xmlTextReaderPtr reader, xmlNodePtr cur) {
 445     xmlDictPtr dict;
 446 
 447     if ((reader != NULL) &amp;&amp; (reader-&gt;ctxt != NULL))
 448     dict = reader-&gt;ctxt-&gt;dict;
 449     else
 450         dict = NULL;
 451     if (cur-&gt;type == XML_DTD_NODE) {
 452     xmlFreeDtd((xmlDtdPtr) cur);
 453     return;
 454     }
 455     if (cur-&gt;type == XML_NAMESPACE_DECL) {
 456     xmlFreeNs((xmlNsPtr) cur);
 457         return;
 458     }
 459     if (cur-&gt;type == XML_ATTRIBUTE_NODE) {
 460     xmlTextReaderFreeProp(reader, (xmlAttrPtr) cur);
 461     return;
 462     }
 463 
 464     if ((cur-&gt;children != NULL) &amp;&amp;
 465     (cur-&gt;type != XML_ENTITY_REF_NODE)) {
 466     if (cur-&gt;children-&gt;parent == cur)
 467         xmlTextReaderFreeNodeList(reader, cur-&gt;children);
 468     cur-&gt;children = NULL;
 469     }
 470 
 471     if ((__xmlRegisterCallbacks) &amp;&amp; (xmlDeregisterNodeDefaultValue))
 472     xmlDeregisterNodeDefaultValue(cur);
 473 
 474     if (((cur-&gt;type == XML_ELEMENT_NODE) ||
 475      (cur-&gt;type == XML_XINCLUDE_START) ||
 476      (cur-&gt;type == XML_XINCLUDE_END)) &amp;&amp;
 477     (cur-&gt;properties != NULL))
 478     xmlTextReaderFreePropList(reader, cur-&gt;properties);
 479     if ((cur-&gt;content != (xmlChar *) &amp;(cur-&gt;properties)) &amp;&amp;
 480         (cur-&gt;type != XML_ELEMENT_NODE) &amp;&amp;
 481     (cur-&gt;type != XML_XINCLUDE_START) &amp;&amp;
 482     (cur-&gt;type != XML_XINCLUDE_END) &amp;&amp;
 483     (cur-&gt;type != XML_ENTITY_REF_NODE)) {
 484     DICT_FREE(cur-&gt;content);
 485     }
 486     if (((cur-&gt;type == XML_ELEMENT_NODE) ||
 487      (cur-&gt;type == XML_XINCLUDE_START) ||
 488      (cur-&gt;type == XML_XINCLUDE_END)) &amp;&amp;
 489     (cur-&gt;nsDef != NULL))
 490     xmlFreeNsList(cur-&gt;nsDef);
 491 
 492     /*
 493      * we don&#39;t free names here they are interned now
 494      */
 495     if ((cur-&gt;type != XML_TEXT_NODE) &amp;&amp;
 496         (cur-&gt;type != XML_COMMENT_NODE))
 497     DICT_FREE(cur-&gt;name);
 498 
 499     if (((cur-&gt;type == XML_ELEMENT_NODE) ||
 500      (cur-&gt;type == XML_TEXT_NODE)) &amp;&amp;
 501     (reader != NULL) &amp;&amp; (reader-&gt;ctxt != NULL) &amp;&amp;
 502     (reader-&gt;ctxt-&gt;freeElemsNr &lt; 100)) {
 503     cur-&gt;next = reader-&gt;ctxt-&gt;freeElems;
 504     reader-&gt;ctxt-&gt;freeElems = cur;
 505     reader-&gt;ctxt-&gt;freeElemsNr++;
 506     } else {
 507     xmlFree(cur);
 508     }
 509 }
 510 
 511 static void
 512 xmlTextReaderFreeIDTableEntry(void *id, const xmlChar *name ATTRIBUTE_UNUSED) {
 513     xmlFreeID((xmlIDPtr) id);
 514 }
 515 
 516 /**
 517  * xmlTextReaderFreeIDTable:
 518  * @table:  An id table
 519  *
 520  * Deallocate the memory used by an ID hash table.
 521  */
 522 static void
 523 xmlTextReaderFreeIDTable(xmlIDTablePtr table) {
 524     xmlHashFree(table, xmlTextReaderFreeIDTableEntry);
 525 }
 526 
 527 /**
 528  * xmlTextReaderFreeDoc:
 529  * @reader:  the xmlTextReaderPtr used
 530  * @cur:  pointer to the document
 531  *
 532  * Free up all the structures used by a document, tree included.
 533  */
 534 static void
 535 xmlTextReaderFreeDoc(xmlTextReaderPtr reader, xmlDocPtr cur) {
 536     xmlDtdPtr extSubset, intSubset;
 537 
 538     if (cur == NULL) return;
 539 
 540     if ((__xmlRegisterCallbacks) &amp;&amp; (xmlDeregisterNodeDefaultValue))
 541     xmlDeregisterNodeDefaultValue((xmlNodePtr) cur);
 542 
 543     /*
 544      * Do this before freeing the children list to avoid ID lookups
 545      */
 546     if (cur-&gt;ids != NULL) xmlTextReaderFreeIDTable((xmlIDTablePtr) cur-&gt;ids);
 547     cur-&gt;ids = NULL;
 548     if (cur-&gt;refs != NULL) xmlFreeRefTable((xmlRefTablePtr) cur-&gt;refs);
 549     cur-&gt;refs = NULL;
 550     extSubset = cur-&gt;extSubset;
 551     intSubset = cur-&gt;intSubset;
 552     if (intSubset == extSubset)
 553     extSubset = NULL;
 554     if (extSubset != NULL) {
 555     xmlUnlinkNode((xmlNodePtr) cur-&gt;extSubset);
 556     cur-&gt;extSubset = NULL;
 557     xmlFreeDtd(extSubset);
 558     }
 559     if (intSubset != NULL) {
 560     xmlUnlinkNode((xmlNodePtr) cur-&gt;intSubset);
 561     cur-&gt;intSubset = NULL;
 562     xmlFreeDtd(intSubset);
 563     }
 564 
 565     if (cur-&gt;children != NULL) xmlTextReaderFreeNodeList(reader, cur-&gt;children);
 566 
 567     if (cur-&gt;version != NULL) xmlFree((char *) cur-&gt;version);
 568     if (cur-&gt;name != NULL) xmlFree((char *) cur-&gt;name);
 569     if (cur-&gt;encoding != NULL) xmlFree((char *) cur-&gt;encoding);
 570     if (cur-&gt;oldNs != NULL) xmlFreeNsList(cur-&gt;oldNs);
 571     if (cur-&gt;URL != NULL) xmlFree((char *) cur-&gt;URL);
 572     if (cur-&gt;dict != NULL) xmlDictFree(cur-&gt;dict);
 573 
 574     xmlFree(cur);
 575 }
 576 
 577 /************************************************************************
 578  *                                  *
 579  *          The reader core parser              *
 580  *                                  *
 581  ************************************************************************/
 582 #ifdef DEBUG_READER
 583 static void
 584 xmlTextReaderDebug(xmlTextReaderPtr reader) {
 585     if ((reader == NULL) || (reader-&gt;ctxt == NULL)) {
 586     fprintf(stderr, &quot;xmlTextReader NULL\n&quot;);
 587     return;
 588     }
 589     fprintf(stderr, &quot;xmlTextReader: state %d depth %d &quot;,
 590         reader-&gt;state, reader-&gt;depth);
 591     if (reader-&gt;node == NULL) {
 592     fprintf(stderr, &quot;node = NULL\n&quot;);
 593     } else {
 594     fprintf(stderr, &quot;node %s\n&quot;, reader-&gt;node-&gt;name);
 595     }
 596     fprintf(stderr, &quot;  input: base %d, cur %d, depth %d: &quot;,
 597         reader-&gt;base, reader-&gt;cur, reader-&gt;ctxt-&gt;nodeNr);
 598     if (reader-&gt;input-&gt;buffer == NULL) {
 599     fprintf(stderr, &quot;buffer is NULL\n&quot;);
 600     } else {
 601 #ifdef LIBXML_DEBUG_ENABLED
 602     xmlDebugDumpString(stderr,
 603         &amp;reader-&gt;input-&gt;buffer-&gt;content[reader-&gt;cur]);
 604 #endif
 605     fprintf(stderr, &quot;\n&quot;);
 606     }
 607 }
 608 #endif
 609 
 610 /**
 611  * xmlTextReaderEntPush:
 612  * @reader:  the xmlTextReaderPtr used
 613  * @value:  the entity reference node
 614  *
 615  * Pushes a new entity reference node on top of the entities stack
 616  *
 617  * Returns 0 in case of error, the index in the stack otherwise
 618  */
 619 static int
 620 xmlTextReaderEntPush(xmlTextReaderPtr reader, xmlNodePtr value)
 621 {
 622     if (reader-&gt;entMax &lt;= 0) {
 623     reader-&gt;entMax = 10;
 624     reader-&gt;entTab = (xmlNodePtr *) xmlMalloc(reader-&gt;entMax *
 625                                           sizeof(reader-&gt;entTab[0]));
 626         if (reader-&gt;entTab == NULL) {
 627             xmlGenericError(xmlGenericErrorContext, &quot;xmlMalloc failed !\n&quot;);
 628             return (0);
 629         }
 630     }
 631     if (reader-&gt;entNr &gt;= reader-&gt;entMax) {
 632         reader-&gt;entMax *= 2;
 633         reader-&gt;entTab =
 634             (xmlNodePtr *) xmlRealloc(reader-&gt;entTab,
 635                                       reader-&gt;entMax *
 636                                       sizeof(reader-&gt;entTab[0]));
 637         if (reader-&gt;entTab == NULL) {
 638             xmlGenericError(xmlGenericErrorContext, &quot;xmlRealloc failed !\n&quot;);
 639             return (0);
 640         }
 641     }
 642     reader-&gt;entTab[reader-&gt;entNr] = value;
 643     reader-&gt;ent = value;
 644     return (reader-&gt;entNr++);
 645 }
 646 
 647 /**
 648  * xmlTextReaderEntPop:
 649  * @reader:  the xmlTextReaderPtr used
 650  *
 651  * Pops the top element entity from the entities stack
 652  *
 653  * Returns the entity just removed
 654  */
 655 static xmlNodePtr
 656 xmlTextReaderEntPop(xmlTextReaderPtr reader)
 657 {
 658     xmlNodePtr ret;
 659 
 660     if (reader-&gt;entNr &lt;= 0)
 661         return (NULL);
 662     reader-&gt;entNr--;
 663     if (reader-&gt;entNr &gt; 0)
 664         reader-&gt;ent = reader-&gt;entTab[reader-&gt;entNr - 1];
 665     else
 666         reader-&gt;ent = NULL;
 667     ret = reader-&gt;entTab[reader-&gt;entNr];
 668     reader-&gt;entTab[reader-&gt;entNr] = NULL;
 669     return (ret);
 670 }
 671 
 672 /**
 673  * xmlTextReaderStartElement:
 674  * @ctx: the user data (XML parser context)
 675  * @fullname:  The element name, including namespace prefix
 676  * @atts:  An array of name/value attributes pairs, NULL terminated
 677  *
 678  * called when an opening tag has been processed.
 679  */
 680 static void
 681 xmlTextReaderStartElement(void *ctx, const xmlChar *fullname,
 682                       const xmlChar **atts) {
 683     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 684     xmlTextReaderPtr reader = ctxt-&gt;_private;
 685 
 686 #ifdef DEBUG_CALLBACKS
 687     printf(&quot;xmlTextReaderStartElement(%s)\n&quot;, fullname);
 688 #endif
 689     if ((reader != NULL) &amp;&amp; (reader-&gt;startElement != NULL)) {
 690     reader-&gt;startElement(ctx, fullname, atts);
 691     if ((ctxt-&gt;node != NULL) &amp;&amp; (ctxt-&gt;input != NULL) &amp;&amp;
 692         (ctxt-&gt;input-&gt;cur != NULL) &amp;&amp; (ctxt-&gt;input-&gt;cur[0] == &#39;/&#39;) &amp;&amp;
 693         (ctxt-&gt;input-&gt;cur[1] == &#39;&gt;&#39;))
 694         ctxt-&gt;node-&gt;extra = NODE_IS_EMPTY;
 695     }
 696     if (reader != NULL)
 697     reader-&gt;state = XML_TEXTREADER_ELEMENT;
 698 }
 699 
 700 /**
 701  * xmlTextReaderEndElement:
 702  * @ctx: the user data (XML parser context)
 703  * @fullname:  The element name, including namespace prefix
 704  *
 705  * called when an ending tag has been processed.
 706  */
 707 static void
 708 xmlTextReaderEndElement(void *ctx, const xmlChar *fullname) {
 709     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 710     xmlTextReaderPtr reader = ctxt-&gt;_private;
 711 
 712 #ifdef DEBUG_CALLBACKS
 713     printf(&quot;xmlTextReaderEndElement(%s)\n&quot;, fullname);
 714 #endif
 715     if ((reader != NULL) &amp;&amp; (reader-&gt;endElement != NULL)) {
 716     reader-&gt;endElement(ctx, fullname);
 717     }
 718 }
 719 
 720 /**
 721  * xmlTextReaderStartElementNs:
 722  * @ctx: the user data (XML parser context)
 723  * @localname:  the local name of the element
 724  * @prefix:  the element namespace prefix if available
 725  * @URI:  the element namespace name if available
 726  * @nb_namespaces:  number of namespace definitions on that node
 727  * @namespaces:  pointer to the array of prefix/URI pairs namespace definitions
 728  * @nb_attributes:  the number of attributes on that node
 729  * nb_defaulted:  the number of defaulted attributes.
 730  * @attributes:  pointer to the array of (localname/prefix/URI/value/end)
 731  *               attribute values.
 732  *
 733  * called when an opening tag has been processed.
 734  */
 735 static void
 736 xmlTextReaderStartElementNs(void *ctx,
 737                       const xmlChar *localname,
 738               const xmlChar *prefix,
 739               const xmlChar *URI,
 740               int nb_namespaces,
 741               const xmlChar **namespaces,
 742               int nb_attributes,
 743               int nb_defaulted,
 744               const xmlChar **attributes)
 745 {
 746     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 747     xmlTextReaderPtr reader = ctxt-&gt;_private;
 748 
 749 #ifdef DEBUG_CALLBACKS
 750     printf(&quot;xmlTextReaderStartElementNs(%s)\n&quot;, localname);
 751 #endif
 752     if ((reader != NULL) &amp;&amp; (reader-&gt;startElementNs != NULL)) {
 753     reader-&gt;startElementNs(ctx, localname, prefix, URI, nb_namespaces,
 754                            namespaces, nb_attributes, nb_defaulted,
 755                    attributes);
 756     if ((ctxt-&gt;node != NULL) &amp;&amp; (ctxt-&gt;input != NULL) &amp;&amp;
 757         (ctxt-&gt;input-&gt;cur != NULL) &amp;&amp; (ctxt-&gt;input-&gt;cur[0] == &#39;/&#39;) &amp;&amp;
 758         (ctxt-&gt;input-&gt;cur[1] == &#39;&gt;&#39;))
 759         ctxt-&gt;node-&gt;extra = NODE_IS_EMPTY;
 760     }
 761     if (reader != NULL)
 762     reader-&gt;state = XML_TEXTREADER_ELEMENT;
 763 }
 764 
 765 /**
 766  * xmlTextReaderEndElementNs:
 767  * @ctx: the user data (XML parser context)
 768  * @localname:  the local name of the element
 769  * @prefix:  the element namespace prefix if available
 770  * @URI:  the element namespace name if available
 771  *
 772  * called when an ending tag has been processed.
 773  */
 774 static void
 775 xmlTextReaderEndElementNs(void *ctx,
 776                           const xmlChar * localname,
 777                           const xmlChar * prefix,
 778                   const xmlChar * URI)
 779 {
 780     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 781     xmlTextReaderPtr reader = ctxt-&gt;_private;
 782 
 783 #ifdef DEBUG_CALLBACKS
 784     printf(&quot;xmlTextReaderEndElementNs(%s)\n&quot;, localname);
 785 #endif
 786     if ((reader != NULL) &amp;&amp; (reader-&gt;endElementNs != NULL)) {
 787     reader-&gt;endElementNs(ctx, localname, prefix, URI);
 788     }
 789 }
 790 
 791 
 792 /**
 793  * xmlTextReaderCharacters:
 794  * @ctx: the user data (XML parser context)
 795  * @ch:  a xmlChar string
 796  * @len: the number of xmlChar
 797  *
 798  * receiving some chars from the parser.
 799  */
 800 static void
 801 xmlTextReaderCharacters(void *ctx, const xmlChar *ch, int len)
 802 {
 803     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 804     xmlTextReaderPtr reader = ctxt-&gt;_private;
 805 
 806 #ifdef DEBUG_CALLBACKS
 807     printf(&quot;xmlTextReaderCharacters()\n&quot;);
 808 #endif
 809     if ((reader != NULL) &amp;&amp; (reader-&gt;characters != NULL)) {
 810     reader-&gt;characters(ctx, ch, len);
 811     }
 812 }
 813 
 814 /**
 815  * xmlTextReaderCDataBlock:
 816  * @ctx: the user data (XML parser context)
 817  * @value:  The pcdata content
 818  * @len:  the block length
 819  *
 820  * called when a pcdata block has been parsed
 821  */
 822 static void
 823 xmlTextReaderCDataBlock(void *ctx, const xmlChar *ch, int len)
 824 {
 825     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 826     xmlTextReaderPtr reader = ctxt-&gt;_private;
 827 
 828 #ifdef DEBUG_CALLBACKS
 829     printf(&quot;xmlTextReaderCDataBlock()\n&quot;);
 830 #endif
 831     if ((reader != NULL) &amp;&amp; (reader-&gt;cdataBlock != NULL)) {
 832     reader-&gt;cdataBlock(ctx, ch, len);
 833     }
 834 }
 835 
 836 /**
 837  * xmlTextReaderPushData:
 838  * @reader:  the xmlTextReaderPtr used
 839  *
 840  * Push data down the progressive parser until a significant callback
 841  * got raised.
 842  *
 843  * Returns -1 in case of failure, 0 otherwise
 844  */
 845 static int
 846 xmlTextReaderPushData(xmlTextReaderPtr reader) {
 847     xmlBufPtr inbuf;
 848     int val, s;
 849     xmlTextReaderState oldstate;
 850     int alloc;
 851 
 852     if ((reader-&gt;input == NULL) || (reader-&gt;input-&gt;buffer == NULL))
 853     return(-1);
 854 
 855     oldstate = reader-&gt;state;
 856     reader-&gt;state = XML_TEXTREADER_NONE;
 857     inbuf = reader-&gt;input-&gt;buffer;
 858     alloc = xmlBufGetAllocationScheme(inbuf);
 859 
 860     while (reader-&gt;state == XML_TEXTREADER_NONE) {
 861     if (xmlBufUse(inbuf) &lt; reader-&gt;cur + CHUNK_SIZE) {
 862         /*
 863          * Refill the buffer unless we are at the end of the stream
 864          */
 865         if (reader-&gt;mode != XML_TEXTREADER_MODE_EOF) {
 866         val = xmlParserInputBufferRead(reader-&gt;input, 4096);
 867         if ((val == 0) &amp;&amp;
 868             (alloc == XML_BUFFER_ALLOC_IMMUTABLE)) {
 869             if (xmlBufUse(inbuf) == reader-&gt;cur) {
 870             reader-&gt;mode = XML_TEXTREADER_MODE_EOF;
 871             reader-&gt;state = oldstate;
 872             }
 873         } else if (val &lt; 0) {
 874             reader-&gt;mode = XML_TEXTREADER_MODE_EOF;
 875             reader-&gt;state = oldstate;
 876             if ((oldstate != XML_TEXTREADER_START) ||
 877             (reader-&gt;ctxt-&gt;myDoc != NULL))
 878             return(val);
 879         } else if (val == 0) {
 880             /* mark the end of the stream and process the remains */
 881             reader-&gt;mode = XML_TEXTREADER_MODE_EOF;
 882             break;
 883         }
 884 
 885         } else
 886         break;
 887     }
 888     /*
 889      * parse by block of CHUNK_SIZE bytes, various tests show that
 890      * it&#39;s the best tradeoff at least on a 1.2GH Duron
 891      */
 892     if (xmlBufUse(inbuf) &gt;= reader-&gt;cur + CHUNK_SIZE) {
 893         val = xmlParseChunk(reader-&gt;ctxt,
 894                  (const char *) xmlBufContent(inbuf) + reader-&gt;cur,
 895                                 CHUNK_SIZE, 0);
 896         reader-&gt;cur += CHUNK_SIZE;
 897         if (val != 0)
 898         reader-&gt;ctxt-&gt;wellFormed = 0;
 899         if (reader-&gt;ctxt-&gt;wellFormed == 0)
 900         break;
 901     } else {
 902         s = xmlBufUse(inbuf) - reader-&gt;cur;
 903         val = xmlParseChunk(reader-&gt;ctxt,
 904          (const char *) xmlBufContent(inbuf) + reader-&gt;cur,
 905                     s, 0);
 906         reader-&gt;cur += s;
 907         if (val != 0)
 908         reader-&gt;ctxt-&gt;wellFormed = 0;
 909         break;
 910     }
 911     }
 912 
 913     /*
 914      * Discard the consumed input when needed and possible
 915      */
 916     if (reader-&gt;mode == XML_TEXTREADER_MODE_INTERACTIVE) {
 917         if (alloc != XML_BUFFER_ALLOC_IMMUTABLE) {
 918         if ((reader-&gt;cur &gt;= 4096) &amp;&amp;
 919         (xmlBufUse(inbuf) - reader-&gt;cur &lt;= CHUNK_SIZE)) {
 920         val = xmlBufShrink(inbuf, reader-&gt;cur);
 921         if (val &gt;= 0) {
 922             reader-&gt;cur -= val;
 923         }
 924         }
 925     }
 926     }
 927 
 928     /*
 929      * At the end of the stream signal that the work is done to the Push
 930      * parser.
 931      */
 932     else if (reader-&gt;mode == XML_TEXTREADER_MODE_EOF) {
 933     if (reader-&gt;state != XML_TEXTREADER_DONE) {
 934         s = xmlBufUse(inbuf) - reader-&gt;cur;
 935         val = xmlParseChunk(reader-&gt;ctxt,
 936          (const char *) xmlBufContent(inbuf) + reader-&gt;cur,
 937                     s, 1);
 938         reader-&gt;cur = xmlBufUse(inbuf);
 939         reader-&gt;state  = XML_TEXTREADER_DONE;
 940         if (val != 0) {
 941             if (reader-&gt;ctxt-&gt;wellFormed)
 942             reader-&gt;ctxt-&gt;wellFormed = 0;
 943         else
 944             return(-1);
 945         }
 946     }
 947     }
 948     reader-&gt;state = oldstate;
 949     if (reader-&gt;ctxt-&gt;wellFormed == 0) {
 950     reader-&gt;mode = XML_TEXTREADER_MODE_EOF;
 951         return(-1);
 952     }
 953 
 954     return(0);
 955 }
 956 
 957 #ifdef LIBXML_REGEXP_ENABLED
 958 /**
 959  * xmlTextReaderValidatePush:
 960  * @reader:  the xmlTextReaderPtr used
 961  *
 962  * Push the current node for validation
 963  */
 964 static void
 965 xmlTextReaderValidatePush(xmlTextReaderPtr reader ATTRIBUTE_UNUSED) {
 966     xmlNodePtr node = reader-&gt;node;
 967 
 968 #ifdef LIBXML_VALID_ENABLED
 969     if ((reader-&gt;validate == XML_TEXTREADER_VALIDATE_DTD) &amp;&amp;
 970         (reader-&gt;ctxt != NULL) &amp;&amp; (reader-&gt;ctxt-&gt;validate == 1)) {
 971     if ((node-&gt;ns == NULL) || (node-&gt;ns-&gt;prefix == NULL)) {
 972         reader-&gt;ctxt-&gt;valid &amp;= xmlValidatePushElement(&amp;reader-&gt;ctxt-&gt;vctxt,
 973                     reader-&gt;ctxt-&gt;myDoc, node, node-&gt;name);
 974     } else {
 975         /* TODO use the BuildQName interface */
 976         xmlChar *qname;
 977 
 978         qname = xmlStrdup(node-&gt;ns-&gt;prefix);
 979         qname = xmlStrcat(qname, BAD_CAST &quot;:&quot;);
 980         qname = xmlStrcat(qname, node-&gt;name);
 981         reader-&gt;ctxt-&gt;valid &amp;= xmlValidatePushElement(&amp;reader-&gt;ctxt-&gt;vctxt,
 982                     reader-&gt;ctxt-&gt;myDoc, node, qname);
 983         if (qname != NULL)
 984         xmlFree(qname);
 985     }
 986     }
 987 #endif /* LIBXML_VALID_ENABLED */
 988 #ifdef LIBXML_SCHEMAS_ENABLED
 989     if ((reader-&gt;validate == XML_TEXTREADER_VALIDATE_RNG) &amp;&amp;
 990                (reader-&gt;rngValidCtxt != NULL)) {
 991     int ret;
 992 
 993     if (reader-&gt;rngFullNode != NULL) return;
 994     ret = xmlRelaxNGValidatePushElement(reader-&gt;rngValidCtxt,
 995                                         reader-&gt;ctxt-&gt;myDoc,
 996                         node);
 997     if (ret == 0) {
 998         /*
 999          * this element requires a full tree
1000          */
1001         node = xmlTextReaderExpand(reader);
1002         if (node == NULL) {
<a name="10" id="anc10"></a>
1003             ret = -1;
1004         } else {
1005         ret = xmlRelaxNGValidateFullElement(reader-&gt;rngValidCtxt,
1006                             reader-&gt;ctxt-&gt;myDoc,
1007                             node);
1008         reader-&gt;rngFullNode = node;
1009         }
1010     }
1011     if (ret != 1)
1012         reader-&gt;rngValidErrors++;
1013     }
1014 #endif
1015 }
1016 
1017 /**
1018  * xmlTextReaderValidateCData:
1019  * @reader:  the xmlTextReaderPtr used
1020  * @data:  pointer to the CData
1021  * @len:  length of the CData block in bytes.
1022  *
1023  * Push some CData for validation
1024  */
1025 static void
1026 xmlTextReaderValidateCData(xmlTextReaderPtr reader,
1027                            const xmlChar *data, int len) {
1028 #ifdef LIBXML_VALID_ENABLED
1029     if ((reader-&gt;validate == XML_TEXTREADER_VALIDATE_DTD) &amp;&amp;
1030         (reader-&gt;ctxt != NULL) &amp;&amp; (reader-&gt;ctxt-&gt;validate == 1)) {
1031     reader-&gt;ctxt-&gt;valid &amp;= xmlValidatePushCData(&amp;reader-&gt;ctxt-&gt;vctxt,
1032                                                 data, len);
1033     }
1034 #endif /* LIBXML_VALID_ENABLED */
1035 #ifdef LIBXML_SCHEMAS_ENABLED
1036     if ((reader-&gt;validate == XML_TEXTREADER_VALIDATE_RNG) &amp;&amp;
1037                (reader-&gt;rngValidCtxt != NULL)) {
1038     int ret;
1039 
1040     if (reader-&gt;rngFullNode != NULL) return;
1041     ret = xmlRelaxNGValidatePushCData(reader-&gt;rngValidCtxt, data, len);
1042     if (ret != 1)
1043         reader-&gt;rngValidErrors++;
1044     }
1045 #endif
1046 }
1047 
1048 /**
1049  * xmlTextReaderValidatePop:
1050  * @reader:  the xmlTextReaderPtr used
1051  *
1052  * Pop the current node from validation
1053  */
1054 static void
1055 xmlTextReaderValidatePop(xmlTextReaderPtr reader) {
1056     xmlNodePtr node = reader-&gt;node;
1057 
1058 #ifdef LIBXML_VALID_ENABLED
1059     if ((reader-&gt;validate == XML_TEXTREADER_VALIDATE_DTD) &amp;&amp;
1060         (reader-&gt;ctxt != NULL) &amp;&amp; (reader-&gt;ctxt-&gt;validate == 1)) {
1061     if ((node-&gt;ns == NULL) || (node-&gt;ns-&gt;prefix == NULL)) {
1062         reader-&gt;ctxt-&gt;valid &amp;= xmlValidatePopElement(&amp;reader-&gt;ctxt-&gt;vctxt,
1063                     reader-&gt;ctxt-&gt;myDoc, node, node-&gt;name);
1064     } else {
1065         /* TODO use the BuildQName interface */
1066         xmlChar *qname;
1067 
1068         qname = xmlStrdup(node-&gt;ns-&gt;prefix);
1069         qname = xmlStrcat(qname, BAD_CAST &quot;:&quot;);
1070         qname = xmlStrcat(qname, node-&gt;name);
1071         reader-&gt;ctxt-&gt;valid &amp;= xmlValidatePopElement(&amp;reader-&gt;ctxt-&gt;vctxt,
1072                     reader-&gt;ctxt-&gt;myDoc, node, qname);
1073         if (qname != NULL)
1074         xmlFree(qname);
1075     }
1076     }
1077 #endif /* LIBXML_VALID_ENABLED */
1078 #ifdef LIBXML_SCHEMAS_ENABLED
1079     if ((reader-&gt;validate == XML_TEXTREADER_VALIDATE_RNG) &amp;&amp;
1080                (reader-&gt;rngValidCtxt != NULL)) {
1081     int ret;
1082 
1083     if (reader-&gt;rngFullNode != NULL) {
1084         if (node == reader-&gt;rngFullNode)
1085             reader-&gt;rngFullNode = NULL;
1086         return;
1087     }
1088     ret = xmlRelaxNGValidatePopElement(reader-&gt;rngValidCtxt,
1089                                        reader-&gt;ctxt-&gt;myDoc,
1090                        node);
1091     if (ret != 1)
1092         reader-&gt;rngValidErrors++;
1093     }
1094 #endif
1095 }
1096 
1097 /**
1098  * xmlTextReaderValidateEntity:
1099  * @reader:  the xmlTextReaderPtr used
1100  *
1101  * Handle the validation when an entity reference is encountered and
1102  * entity substitution is not activated. As a result the parser interface
1103  * must walk through the entity and do the validation calls
1104  */
1105 static void
1106 xmlTextReaderValidateEntity(xmlTextReaderPtr reader) {
1107     xmlNodePtr oldnode = reader-&gt;node;
1108     xmlNodePtr node = reader-&gt;node;
1109     xmlParserCtxtPtr ctxt = reader-&gt;ctxt;
1110 
1111     do {
1112     if (node-&gt;type == XML_ENTITY_REF_NODE) {
1113         /*
<a name="11" id="anc11"></a><span class="line-modified">1114          * Case where the underlying tree is not available, lookup the entity</span>
1115          * and walk it.
1116          */
1117         if ((node-&gt;children == NULL) &amp;&amp; (ctxt-&gt;sax != NULL) &amp;&amp;
1118         (ctxt-&gt;sax-&gt;getEntity != NULL)) {
1119         node-&gt;children = (xmlNodePtr)
1120             ctxt-&gt;sax-&gt;getEntity(ctxt, node-&gt;name);
1121         }
1122 
1123         if ((node-&gt;children != NULL) &amp;&amp;
1124         (node-&gt;children-&gt;type == XML_ENTITY_DECL) &amp;&amp;
1125         (node-&gt;children-&gt;children != NULL)) {
1126         xmlTextReaderEntPush(reader, node);
1127         node = node-&gt;children-&gt;children;
1128         continue;
1129         } else {
1130         /*
<a name="12" id="anc12"></a><span class="line-modified">1131          * The error has probably been raised already.</span>
1132          */
1133         if (node == oldnode)
1134             break;
<a name="13" id="anc13"></a><span class="line-modified">1135                 goto skip_children;</span>
1136         }
1137 #ifdef LIBXML_REGEXP_ENABLED
1138     } else if (node-&gt;type == XML_ELEMENT_NODE) {
1139         reader-&gt;node = node;
1140         xmlTextReaderValidatePush(reader);
1141     } else if ((node-&gt;type == XML_TEXT_NODE) ||
1142            (node-&gt;type == XML_CDATA_SECTION_NODE)) {
1143             xmlTextReaderValidateCData(reader, node-&gt;content,
1144                                    xmlStrlen(node-&gt;content));
1145 #endif
1146     }
1147 
1148     /*
1149      * go to next node
1150      */
1151     if (node-&gt;children != NULL) {
1152         node = node-&gt;children;
1153         continue;
1154     } else if (node-&gt;type == XML_ELEMENT_NODE) {
1155         xmlTextReaderValidatePop(reader);
1156     }
<a name="14" id="anc14"></a><span class="line-added">1157 skip_children:</span>
1158     if (node-&gt;next != NULL) {
1159         node = node-&gt;next;
1160         continue;
1161     }
1162     do {
1163         node = node-&gt;parent;
1164         if (node-&gt;type == XML_ELEMENT_NODE) {
1165             xmlNodePtr tmp;
1166         if (reader-&gt;entNr == 0) {
1167             while ((tmp = node-&gt;last) != NULL) {
1168             if ((tmp-&gt;extra &amp; NODE_IS_PRESERVED) == 0) {
1169                 xmlUnlinkNode(tmp);
1170                 xmlTextReaderFreeNode(reader, tmp);
1171             } else
1172                 break;
1173             }
1174         }
1175         reader-&gt;node = node;
1176         xmlTextReaderValidatePop(reader);
1177         }
1178         if ((node-&gt;type == XML_ENTITY_DECL) &amp;&amp;
1179         (reader-&gt;ent != NULL) &amp;&amp; (reader-&gt;ent-&gt;children == node)) {
1180         node = xmlTextReaderEntPop(reader);
1181         }
1182         if (node == oldnode)
1183         break;
1184         if (node-&gt;next != NULL) {
1185         node = node-&gt;next;
1186         break;
1187         }
1188     } while ((node != NULL) &amp;&amp; (node != oldnode));
1189     } while ((node != NULL) &amp;&amp; (node != oldnode));
1190     reader-&gt;node = oldnode;
1191 }
1192 #endif /* LIBXML_REGEXP_ENABLED */
1193 
1194 
1195 /**
1196  * xmlTextReaderGetSuccessor:
1197  * @cur:  the current node
1198  *
1199  * Get the successor of a node if available.
1200  *
1201  * Returns the successor node or NULL
1202  */
1203 static xmlNodePtr
1204 xmlTextReaderGetSuccessor(xmlNodePtr cur) {
1205     if (cur == NULL) return(NULL) ; /* ERROR */
1206     if (cur-&gt;next != NULL) return(cur-&gt;next) ;
1207     do {
1208         cur = cur-&gt;parent;
1209         if (cur == NULL) break;
1210         if (cur-&gt;next != NULL) return(cur-&gt;next);
1211     } while (cur != NULL);
1212     return(cur);
1213 }
1214 
1215 /**
1216  * xmlTextReaderDoExpand:
1217  * @reader:  the xmlTextReaderPtr used
1218  *
1219  * Makes sure that the current node is fully read as well as all its
1220  * descendant. It means the full DOM subtree must be available at the
1221  * end of the call.
1222  *
1223  * Returns 1 if the node was expanded successfully, 0 if there is no more
1224  *          nodes to read, or -1 in case of error
1225  */
1226 static int
1227 xmlTextReaderDoExpand(xmlTextReaderPtr reader) {
1228     int val;
1229 
1230     if ((reader == NULL) || (reader-&gt;node == NULL) || (reader-&gt;ctxt == NULL))
1231         return(-1);
1232     do {
1233     if (reader-&gt;ctxt-&gt;instate == XML_PARSER_EOF) return(1);
1234 
1235         if (xmlTextReaderGetSuccessor(reader-&gt;node) != NULL)
1236         return(1);
1237     if (reader-&gt;ctxt-&gt;nodeNr &lt; reader-&gt;depth)
1238         return(1);
1239     if (reader-&gt;mode == XML_TEXTREADER_MODE_EOF)
1240         return(1);
1241     val = xmlTextReaderPushData(reader);
1242     if (val &lt; 0){
1243         reader-&gt;mode = XML_TEXTREADER_MODE_ERROR;
1244         return(-1);
1245     }
1246     } while(reader-&gt;mode != XML_TEXTREADER_MODE_EOF);
1247     return(1);
1248 }
1249 
1250 /**
1251  * xmlTextReaderCollectSiblings:
1252  * @node:    the first child
1253  *
1254  *  Traverse depth-first through all sibling nodes and their children
1255  *  nodes and concatenate their content. This is an auxiliary function
1256  *  to xmlTextReaderReadString.
1257  *
1258  *  Returns a string containing the content, or NULL in case of error.
1259  */
1260 static xmlChar *
1261 xmlTextReaderCollectSiblings(xmlNodePtr node)
1262 {
1263     xmlBufferPtr buffer;
1264     xmlChar *ret;
1265 
1266     if ((node == NULL) || (node-&gt;type == XML_NAMESPACE_DECL))
1267         return(NULL);
1268 
1269     buffer = xmlBufferCreate();
1270     if (buffer == NULL)
1271        return NULL;
1272 
1273     for ( ; node != NULL; node = node-&gt;next) {
1274        switch (node-&gt;type) {
1275        case XML_TEXT_NODE:
1276        case XML_CDATA_SECTION_NODE:
1277            xmlBufferCat(buffer, node-&gt;content);
1278            break;
1279        case XML_ELEMENT_NODE: {
1280            xmlChar *tmp;
1281 
1282        tmp = xmlTextReaderCollectSiblings(node-&gt;children);
1283            xmlBufferCat(buffer, tmp);
1284        xmlFree(tmp);
1285        break;
1286        }
1287        default:
1288            break;
1289        }
1290     }
1291     ret = buffer-&gt;content;
1292     buffer-&gt;content = NULL;
1293     xmlBufferFree(buffer);
1294     return(ret);
1295 }
1296 
1297 /**
1298  * xmlTextReaderRead:
1299  * @reader:  the xmlTextReaderPtr used
1300  *
1301  *  Moves the position of the current instance to the next node in
1302  *  the stream, exposing its properties.
1303  *
1304  *  Returns 1 if the node was read successfully, 0 if there is no more
1305  *          nodes to read, or -1 in case of error
1306  */
1307 int
1308 xmlTextReaderRead(xmlTextReaderPtr reader) {
1309     int val, olddepth = 0;
1310     xmlTextReaderState oldstate = XML_TEXTREADER_START;
1311     xmlNodePtr oldnode = NULL;
1312 
1313 
1314     if (reader == NULL)
1315     return(-1);
1316     reader-&gt;curnode = NULL;
1317     if (reader-&gt;doc != NULL)
1318         return(xmlTextReaderReadTree(reader));
1319     if (reader-&gt;ctxt == NULL)
1320     return(-1);
1321 
1322 #ifdef DEBUG_READER
1323     fprintf(stderr, &quot;\nREAD &quot;);
1324     DUMP_READER
1325 #endif
1326     if (reader-&gt;mode == XML_TEXTREADER_MODE_INITIAL) {
1327     reader-&gt;mode = XML_TEXTREADER_MODE_INTERACTIVE;
1328     /*
1329      * Initial state
1330      */
1331     do {
1332         val = xmlTextReaderPushData(reader);
1333         if (val &lt; 0){
1334             reader-&gt;mode = XML_TEXTREADER_MODE_ERROR;
1335             reader-&gt;state = XML_TEXTREADER_ERROR;
1336         return(-1);
1337         }
1338     } while ((reader-&gt;ctxt-&gt;node == NULL) &amp;&amp;
1339          ((reader-&gt;mode != XML_TEXTREADER_MODE_EOF) &amp;&amp;
1340           (reader-&gt;state != XML_TEXTREADER_DONE)));
1341     if (reader-&gt;ctxt-&gt;node == NULL) {
1342         if (reader-&gt;ctxt-&gt;myDoc != NULL) {
1343         reader-&gt;node = reader-&gt;ctxt-&gt;myDoc-&gt;children;
1344         }
1345         if (reader-&gt;node == NULL){
1346             reader-&gt;mode = XML_TEXTREADER_MODE_ERROR;
1347             reader-&gt;state = XML_TEXTREADER_ERROR;
1348         return(-1);
1349         }
1350         reader-&gt;state = XML_TEXTREADER_ELEMENT;
1351     } else {
1352         if (reader-&gt;ctxt-&gt;myDoc != NULL) {
1353         reader-&gt;node = reader-&gt;ctxt-&gt;myDoc-&gt;children;
1354         }
1355         if (reader-&gt;node == NULL)
1356         reader-&gt;node = reader-&gt;ctxt-&gt;nodeTab[0];
1357         reader-&gt;state = XML_TEXTREADER_ELEMENT;
1358     }
1359     reader-&gt;depth = 0;
1360     reader-&gt;ctxt-&gt;parseMode = XML_PARSE_READER;
1361     goto node_found;
1362     }
1363     oldstate = reader-&gt;state;
1364     olddepth = reader-&gt;ctxt-&gt;nodeNr;
1365     oldnode = reader-&gt;node;
1366 
1367 get_next_node:
1368     if (reader-&gt;node == NULL) {
1369     if (reader-&gt;mode == XML_TEXTREADER_MODE_EOF)
1370         return(0);
1371     else
1372         return(-1);
1373     }
1374 
1375     /*
1376      * If we are not backtracking on ancestors or examined nodes,
<a name="15" id="anc15"></a><span class="line-modified">1377      * that the parser didn&#39;t finished or that we aren&#39;t at the end</span>
1378      * of stream, continue processing.
1379      */
1380     while ((reader-&gt;node != NULL) &amp;&amp; (reader-&gt;node-&gt;next == NULL) &amp;&amp;
1381        (reader-&gt;ctxt-&gt;nodeNr == olddepth) &amp;&amp;
1382            ((oldstate == XML_TEXTREADER_BACKTRACK) ||
1383             (reader-&gt;node-&gt;children == NULL) ||
1384         (reader-&gt;node-&gt;type == XML_ENTITY_REF_NODE) ||
1385         ((reader-&gt;node-&gt;children != NULL) &amp;&amp;
1386          (reader-&gt;node-&gt;children-&gt;type == XML_TEXT_NODE) &amp;&amp;
1387          (reader-&gt;node-&gt;children-&gt;next == NULL)) ||
1388         (reader-&gt;node-&gt;type == XML_DTD_NODE) ||
1389         (reader-&gt;node-&gt;type == XML_DOCUMENT_NODE) ||
1390         (reader-&gt;node-&gt;type == XML_HTML_DOCUMENT_NODE)) &amp;&amp;
1391        ((reader-&gt;ctxt-&gt;node == NULL) ||
1392         (reader-&gt;ctxt-&gt;node == reader-&gt;node) ||
1393         (reader-&gt;ctxt-&gt;node == reader-&gt;node-&gt;parent)) &amp;&amp;
1394        (reader-&gt;ctxt-&gt;instate != XML_PARSER_EOF)) {
1395     val = xmlTextReaderPushData(reader);
1396     if (val &lt; 0){
1397         reader-&gt;mode = XML_TEXTREADER_MODE_ERROR;
1398         reader-&gt;state = XML_TEXTREADER_ERROR;
1399         return(-1);
1400     }
1401     if (reader-&gt;node == NULL)
1402         goto node_end;
1403     }
1404     if (oldstate != XML_TEXTREADER_BACKTRACK) {
1405     if ((reader-&gt;node-&gt;children != NULL) &amp;&amp;
1406         (reader-&gt;node-&gt;type != XML_ENTITY_REF_NODE) &amp;&amp;
1407         (reader-&gt;node-&gt;type != XML_XINCLUDE_START) &amp;&amp;
1408         (reader-&gt;node-&gt;type != XML_DTD_NODE)) {
1409         reader-&gt;node = reader-&gt;node-&gt;children;
1410         reader-&gt;depth++;
1411         reader-&gt;state = XML_TEXTREADER_ELEMENT;
1412         goto node_found;
1413     }
1414     }
1415     if (reader-&gt;node-&gt;next != NULL) {
1416     if ((oldstate == XML_TEXTREADER_ELEMENT) &amp;&amp;
1417             (reader-&gt;node-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
1418         (reader-&gt;node-&gt;children == NULL) &amp;&amp;
1419         ((reader-&gt;node-&gt;extra &amp; NODE_IS_EMPTY) == 0)
1420 #ifdef LIBXML_XINCLUDE_ENABLED
1421         &amp;&amp; (reader-&gt;in_xinclude &lt;= 0)
1422 #endif
1423         ) {
1424         reader-&gt;state = XML_TEXTREADER_END;
1425         goto node_found;
1426     }
1427 #ifdef LIBXML_REGEXP_ENABLED
1428     if ((reader-&gt;validate) &amp;&amp;
1429         (reader-&gt;node-&gt;type == XML_ELEMENT_NODE))
1430         xmlTextReaderValidatePop(reader);
1431 #endif /* LIBXML_REGEXP_ENABLED */
1432         if ((reader-&gt;preserves &gt; 0) &amp;&amp;
1433         (reader-&gt;node-&gt;extra &amp; NODE_IS_SPRESERVED))
1434         reader-&gt;preserves--;
1435     reader-&gt;node = reader-&gt;node-&gt;next;
1436     reader-&gt;state = XML_TEXTREADER_ELEMENT;
1437 
1438     /*
1439      * Cleanup of the old node
1440      */
1441     if ((reader-&gt;preserves == 0) &amp;&amp;
1442 #ifdef LIBXML_XINCLUDE_ENABLED
1443         (reader-&gt;in_xinclude == 0) &amp;&amp;
1444 #endif
1445         (reader-&gt;entNr == 0) &amp;&amp;
1446         (reader-&gt;node-&gt;prev != NULL) &amp;&amp;
1447             (reader-&gt;node-&gt;prev-&gt;type != XML_DTD_NODE)) {
1448         xmlNodePtr tmp = reader-&gt;node-&gt;prev;
1449         if ((tmp-&gt;extra &amp; NODE_IS_PRESERVED) == 0) {
1450         xmlUnlinkNode(tmp);
1451         xmlTextReaderFreeNode(reader, tmp);
1452         }
1453     }
1454 
1455     goto node_found;
1456     }
1457     if ((oldstate == XML_TEXTREADER_ELEMENT) &amp;&amp;
1458     (reader-&gt;node-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
1459     (reader-&gt;node-&gt;children == NULL) &amp;&amp;
1460     ((reader-&gt;node-&gt;extra &amp; NODE_IS_EMPTY) == 0)) {;
1461     reader-&gt;state = XML_TEXTREADER_END;
1462     goto node_found;
1463     }
1464 #ifdef LIBXML_REGEXP_ENABLED
1465     if ((reader-&gt;validate != XML_TEXTREADER_NOT_VALIDATE) &amp;&amp; (reader-&gt;node-&gt;type == XML_ELEMENT_NODE))
1466     xmlTextReaderValidatePop(reader);
1467 #endif /* LIBXML_REGEXP_ENABLED */
1468     if ((reader-&gt;preserves &gt; 0) &amp;&amp;
1469     (reader-&gt;node-&gt;extra &amp; NODE_IS_SPRESERVED))
1470     reader-&gt;preserves--;
1471     reader-&gt;node = reader-&gt;node-&gt;parent;
1472     if ((reader-&gt;node == NULL) ||
1473     (reader-&gt;node-&gt;type == XML_DOCUMENT_NODE) ||
1474 #ifdef LIBXML_DOCB_ENABLED
1475     (reader-&gt;node-&gt;type == XML_DOCB_DOCUMENT_NODE) ||
1476 #endif
1477     (reader-&gt;node-&gt;type == XML_HTML_DOCUMENT_NODE)) {
1478     if (reader-&gt;mode != XML_TEXTREADER_MODE_EOF) {
1479         val = xmlParseChunk(reader-&gt;ctxt, &quot;&quot;, 0, 1);
1480         reader-&gt;state = XML_TEXTREADER_DONE;
1481         if (val != 0)
1482             return(-1);
1483     }
1484     reader-&gt;node = NULL;
1485     reader-&gt;depth = -1;
1486 
1487     /*
1488      * Cleanup of the old node
1489      */
1490     if ((oldnode != NULL) &amp;&amp; (reader-&gt;preserves == 0) &amp;&amp;
1491 #ifdef LIBXML_XINCLUDE_ENABLED
1492         (reader-&gt;in_xinclude == 0) &amp;&amp;
1493 #endif
1494         (reader-&gt;entNr == 0) &amp;&amp;
1495         (oldnode-&gt;type != XML_DTD_NODE) &amp;&amp;
1496         ((oldnode-&gt;extra &amp; NODE_IS_PRESERVED) == 0)) {
1497         xmlUnlinkNode(oldnode);
1498         xmlTextReaderFreeNode(reader, oldnode);
1499     }
1500 
1501     goto node_end;
1502     }
1503     if ((reader-&gt;preserves == 0) &amp;&amp;
1504 #ifdef LIBXML_XINCLUDE_ENABLED
1505         (reader-&gt;in_xinclude == 0) &amp;&amp;
1506 #endif
1507     (reader-&gt;entNr == 0) &amp;&amp;
1508         (reader-&gt;node-&gt;last != NULL) &amp;&amp;
1509         ((reader-&gt;node-&gt;last-&gt;extra &amp; NODE_IS_PRESERVED) == 0)) {
1510     xmlNodePtr tmp = reader-&gt;node-&gt;last;
1511     xmlUnlinkNode(tmp);
1512     xmlTextReaderFreeNode(reader, tmp);
1513     }
1514     reader-&gt;depth--;
1515     reader-&gt;state = XML_TEXTREADER_BACKTRACK;
1516 
1517 node_found:
1518     DUMP_READER
1519 
1520     /*
1521      * If we are in the middle of a piece of CDATA make sure it&#39;s finished
1522      */
1523     if ((reader-&gt;node != NULL) &amp;&amp;
1524         (reader-&gt;node-&gt;next == NULL) &amp;&amp;
1525         ((reader-&gt;node-&gt;type == XML_TEXT_NODE) ||
1526      (reader-&gt;node-&gt;type == XML_CDATA_SECTION_NODE))) {
1527             if (xmlTextReaderExpand(reader) == NULL)
1528             return -1;
1529     }
1530 
1531 #ifdef LIBXML_XINCLUDE_ENABLED
1532     /*
1533      * Handle XInclude if asked for
1534      */
1535     if ((reader-&gt;xinclude) &amp;&amp; (reader-&gt;node != NULL) &amp;&amp;
1536     (reader-&gt;node-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
1537     (reader-&gt;node-&gt;ns != NULL) &amp;&amp;
1538     ((xmlStrEqual(reader-&gt;node-&gt;ns-&gt;href, XINCLUDE_NS)) ||
1539      (xmlStrEqual(reader-&gt;node-&gt;ns-&gt;href, XINCLUDE_OLD_NS)))) {
1540     if (reader-&gt;xincctxt == NULL) {
1541         reader-&gt;xincctxt = xmlXIncludeNewContext(reader-&gt;ctxt-&gt;myDoc);
1542         xmlXIncludeSetFlags(reader-&gt;xincctxt,
1543                             reader-&gt;parserFlags &amp; (~XML_PARSE_NOXINCNODE));
1544     }
1545     /*
1546      * expand that node and process it
1547      */
1548     if (xmlTextReaderExpand(reader) == NULL)
1549         return -1;
1550     xmlXIncludeProcessNode(reader-&gt;xincctxt, reader-&gt;node);
1551     }
1552     if ((reader-&gt;node != NULL) &amp;&amp; (reader-&gt;node-&gt;type == XML_XINCLUDE_START)) {
1553         reader-&gt;in_xinclude++;
1554     goto get_next_node;
1555     }
1556     if ((reader-&gt;node != NULL) &amp;&amp; (reader-&gt;node-&gt;type == XML_XINCLUDE_END)) {
1557         reader-&gt;in_xinclude--;
1558     goto get_next_node;
1559     }
1560 #endif
1561     /*
1562      * Handle entities enter and exit when in entity replacement mode
1563      */
1564     if ((reader-&gt;node != NULL) &amp;&amp;
1565     (reader-&gt;node-&gt;type == XML_ENTITY_REF_NODE) &amp;&amp;
1566     (reader-&gt;ctxt != NULL) &amp;&amp; (reader-&gt;ctxt-&gt;replaceEntities == 1)) {
1567     /*
<a name="16" id="anc16"></a><span class="line-modified">1568      * Case where the underlying tree is not available, lookup the entity</span>
1569      * and walk it.
1570      */
1571     if ((reader-&gt;node-&gt;children == NULL) &amp;&amp; (reader-&gt;ctxt-&gt;sax != NULL) &amp;&amp;
1572         (reader-&gt;ctxt-&gt;sax-&gt;getEntity != NULL)) {
1573         reader-&gt;node-&gt;children = (xmlNodePtr)
1574         reader-&gt;ctxt-&gt;sax-&gt;getEntity(reader-&gt;ctxt, reader-&gt;node-&gt;name);
1575     }
1576 
1577     if ((reader-&gt;node-&gt;children != NULL) &amp;&amp;
1578         (reader-&gt;node-&gt;children-&gt;type == XML_ENTITY_DECL) &amp;&amp;
1579         (reader-&gt;node-&gt;children-&gt;children != NULL)) {
1580         xmlTextReaderEntPush(reader, reader-&gt;node);
1581         reader-&gt;node = reader-&gt;node-&gt;children-&gt;children;
1582     }
1583 #ifdef LIBXML_REGEXP_ENABLED
1584     } else if ((reader-&gt;node != NULL) &amp;&amp;
1585            (reader-&gt;node-&gt;type == XML_ENTITY_REF_NODE) &amp;&amp;
1586            (reader-&gt;ctxt != NULL) &amp;&amp; (reader-&gt;validate)) {
1587     xmlTextReaderValidateEntity(reader);
1588 #endif /* LIBXML_REGEXP_ENABLED */
1589     }
1590     if ((reader-&gt;node != NULL) &amp;&amp;
1591     (reader-&gt;node-&gt;type == XML_ENTITY_DECL) &amp;&amp;
1592     (reader-&gt;ent != NULL) &amp;&amp; (reader-&gt;ent-&gt;children == reader-&gt;node)) {
1593     reader-&gt;node = xmlTextReaderEntPop(reader);
1594     reader-&gt;depth++;
1595         goto get_next_node;
1596     }
1597 #ifdef LIBXML_REGEXP_ENABLED
1598     if ((reader-&gt;validate != XML_TEXTREADER_NOT_VALIDATE) &amp;&amp; (reader-&gt;node != NULL)) {
1599     xmlNodePtr node = reader-&gt;node;
1600 
1601     if ((node-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
1602             ((reader-&gt;state != XML_TEXTREADER_END) &amp;&amp;
1603          (reader-&gt;state != XML_TEXTREADER_BACKTRACK))) {
1604         xmlTextReaderValidatePush(reader);
1605     } else if ((node-&gt;type == XML_TEXT_NODE) ||
1606            (node-&gt;type == XML_CDATA_SECTION_NODE)) {
1607             xmlTextReaderValidateCData(reader, node-&gt;content,
1608                                    xmlStrlen(node-&gt;content));
1609     }
1610     }
1611 #endif /* LIBXML_REGEXP_ENABLED */
1612 #ifdef LIBXML_PATTERN_ENABLED
1613     if ((reader-&gt;patternNr &gt; 0) &amp;&amp; (reader-&gt;state != XML_TEXTREADER_END) &amp;&amp;
1614         (reader-&gt;state != XML_TEXTREADER_BACKTRACK)) {
1615         int i;
1616     for (i = 0;i &lt; reader-&gt;patternNr;i++) {
1617          if (xmlPatternMatch(reader-&gt;patternTab[i], reader-&gt;node) == 1) {
1618              xmlTextReaderPreserve(reader);
1619          break;
1620              }
1621     }
1622     }
1623 #endif /* LIBXML_PATTERN_ENABLED */
1624 #ifdef LIBXML_SCHEMAS_ENABLED
1625     if ((reader-&gt;validate == XML_TEXTREADER_VALIDATE_XSD) &amp;&amp;
1626         (reader-&gt;xsdValidErrors == 0) &amp;&amp;
1627     (reader-&gt;xsdValidCtxt != NULL)) {
1628     reader-&gt;xsdValidErrors = !xmlSchemaIsValid(reader-&gt;xsdValidCtxt);
1629     }
1630 #endif /* LIBXML_PATTERN_ENABLED */
1631     return(1);
1632 node_end:
1633     reader-&gt;state = XML_TEXTREADER_DONE;
1634     return(0);
1635 }
1636 
1637 /**
1638  * xmlTextReaderReadState:
1639  * @reader:  the xmlTextReaderPtr used
1640  *
1641  * Gets the read state of the reader.
1642  *
1643  * Returns the state value, or -1 in case of error
1644  */
1645 int
1646 xmlTextReaderReadState(xmlTextReaderPtr reader) {
1647     if (reader == NULL)
1648     return(-1);
1649     return(reader-&gt;mode);
1650 }
1651 
1652 /**
1653  * xmlTextReaderExpand:
1654  * @reader:  the xmlTextReaderPtr used
1655  *
1656  * Reads the contents of the current node and the full subtree. It then makes
1657  * the subtree available until the next xmlTextReaderRead() call
1658  *
1659  * Returns a node pointer valid until the next xmlTextReaderRead() call
1660  *         or NULL in case of error.
1661  */
1662 xmlNodePtr
1663 xmlTextReaderExpand(xmlTextReaderPtr reader) {
1664     if ((reader == NULL) || (reader-&gt;node == NULL))
1665         return(NULL);
1666     if (reader-&gt;doc != NULL)
1667         return(reader-&gt;node);
1668     if (reader-&gt;ctxt == NULL)
1669         return(NULL);
1670     if (xmlTextReaderDoExpand(reader) &lt; 0)
1671         return(NULL);
1672     return(reader-&gt;node);
1673 }
1674 
1675 /**
1676  * xmlTextReaderNext:
1677  * @reader:  the xmlTextReaderPtr used
1678  *
1679  * Skip to the node following the current one in document order while
1680  * avoiding the subtree if any.
1681  *
1682  * Returns 1 if the node was read successfully, 0 if there is no more
1683  *          nodes to read, or -1 in case of error
1684  */
1685 int
1686 xmlTextReaderNext(xmlTextReaderPtr reader) {
1687     int ret;
1688     xmlNodePtr cur;
1689 
1690     if (reader == NULL)
1691     return(-1);
1692     if (reader-&gt;doc != NULL)
1693         return(xmlTextReaderNextTree(reader));
1694     cur = reader-&gt;node;
1695     if ((cur == NULL) || (cur-&gt;type != XML_ELEMENT_NODE))
1696         return(xmlTextReaderRead(reader));
1697     if (reader-&gt;state == XML_TEXTREADER_END || reader-&gt;state == XML_TEXTREADER_BACKTRACK)
1698         return(xmlTextReaderRead(reader));
1699     if (cur-&gt;extra &amp; NODE_IS_EMPTY)
1700         return(xmlTextReaderRead(reader));
1701     do {
1702         ret = xmlTextReaderRead(reader);
1703     if (ret != 1)
1704         return(ret);
1705     } while (reader-&gt;node != cur);
1706     return(xmlTextReaderRead(reader));
1707 }
1708 
1709 #ifdef LIBXML_WRITER_ENABLED
1710 /**
1711  * xmlTextReaderReadInnerXml:
1712  * @reader:  the xmlTextReaderPtr used
1713  *
1714  * Reads the contents of the current node, including child nodes and markup.
1715  *
1716  * Returns a string containing the XML content, or NULL if the current node
1717  *         is neither an element nor attribute, or has no child nodes. The
1718  *         string must be deallocated by the caller.
1719  */
1720 xmlChar *
1721 xmlTextReaderReadInnerXml(xmlTextReaderPtr reader ATTRIBUTE_UNUSED)
1722 {
1723     xmlChar *resbuf;
1724     xmlNodePtr node, cur_node;
1725     xmlBufferPtr buff, buff2;
1726     xmlDocPtr doc;
1727 
1728     if (xmlTextReaderExpand(reader) == NULL) {
1729         return NULL;
1730     }
1731     doc = reader-&gt;node-&gt;doc;
1732     buff = xmlBufferCreate();
<a name="17" id="anc17"></a><span class="line-added">1733     if (buff == NULL)</span>
<span class="line-added">1734         return NULL;</span>
1735     for (cur_node = reader-&gt;node-&gt;children; cur_node != NULL;
1736          cur_node = cur_node-&gt;next) {
1737         /* XXX: Why is the node copied? */
1738         node = xmlDocCopyNode(cur_node, doc, 1);
1739         buff2 = xmlBufferCreate();
1740         if (xmlNodeDump(buff2, doc, node, 0, 0) == -1) {
1741             xmlFreeNode(node);
1742             xmlBufferFree(buff2);
1743             xmlBufferFree(buff);
1744             return NULL;
1745         }
1746         xmlBufferCat(buff, buff2-&gt;content);
1747         xmlFreeNode(node);
1748         xmlBufferFree(buff2);
1749     }
1750     resbuf = buff-&gt;content;
1751     buff-&gt;content = NULL;
1752 
1753     xmlBufferFree(buff);
1754     return resbuf;
1755 }
1756 #endif
1757 
1758 #ifdef LIBXML_WRITER_ENABLED
1759 /**
1760  * xmlTextReaderReadOuterXml:
1761  * @reader:  the xmlTextReaderPtr used
1762  *
1763  * Reads the contents of the current node, including child nodes and markup.
1764  *
1765  * Returns a string containing the node and any XML content, or NULL if the
1766  *         current node cannot be serialized. The string must be deallocated
1767  *         by the caller.
1768  */
1769 xmlChar *
1770 xmlTextReaderReadOuterXml(xmlTextReaderPtr reader ATTRIBUTE_UNUSED)
1771 {
1772     xmlChar *resbuf;
1773     xmlNodePtr node;
1774     xmlBufferPtr buff;
1775     xmlDocPtr doc;
1776 
<a name="18" id="anc18"></a>

1777     if (xmlTextReaderExpand(reader) == NULL) {
1778         return NULL;
1779     }
<a name="19" id="anc19"></a><span class="line-added">1780     node = reader-&gt;node;</span>
<span class="line-added">1781     doc = node-&gt;doc;</span>
1782     /* XXX: Why is the node copied? */
1783     if (node-&gt;type == XML_DTD_NODE) {
1784         node = (xmlNodePtr) xmlCopyDtd((xmlDtdPtr) node);
1785     } else {
1786         node = xmlDocCopyNode(node, doc, 1);
1787     }
1788     buff = xmlBufferCreate();
1789     if (xmlNodeDump(buff, doc, node, 0, 0) == -1) {
1790         xmlFreeNode(node);
1791         xmlBufferFree(buff);
1792         return NULL;
1793     }
1794 
1795     resbuf = buff-&gt;content;
1796     buff-&gt;content = NULL;
1797 
1798     xmlFreeNode(node);
1799     xmlBufferFree(buff);
1800     return resbuf;
1801 }
1802 #endif
1803 
1804 /**
1805  * xmlTextReaderReadString:
1806  * @reader:  the xmlTextReaderPtr used
1807  *
1808  * Reads the contents of an element or a text node as a string.
1809  *
1810  * Returns a string containing the contents of the Element or Text node,
1811  *         or NULL if the reader is positioned on any other type of node.
1812  *         The string must be deallocated by the caller.
1813  */
1814 xmlChar *
1815 xmlTextReaderReadString(xmlTextReaderPtr reader)
1816 {
1817     xmlNodePtr node;
1818 
1819     if ((reader == NULL) || (reader-&gt;node == NULL))
1820        return(NULL);
1821 
1822     node = (reader-&gt;curnode != NULL) ? reader-&gt;curnode : reader-&gt;node;
1823     switch (node-&gt;type) {
1824     case XML_TEXT_NODE:
1825        if (node-&gt;content != NULL)
1826            return(xmlStrdup(node-&gt;content));
1827        break;
1828     case XML_ELEMENT_NODE:
1829     if (xmlTextReaderDoExpand(reader) != -1) {
1830         return xmlTextReaderCollectSiblings(node-&gt;children);
1831     }
1832     break;
1833     case XML_ATTRIBUTE_NODE:
1834     TODO
1835     break;
1836     default:
1837        break;
1838     }
1839     return(NULL);
1840 }
1841 
1842 #if 0
1843 /**
1844  * xmlTextReaderReadBase64:
1845  * @reader:  the xmlTextReaderPtr used
1846  * @array:  a byte array to store the content.
1847  * @offset:  the zero-based index into array where the method should
1848  *           begin to write.
1849  * @len:  the number of bytes to write.
1850  *
1851  * Reads and decodes the Base64 encoded contents of an element and
1852  * stores the result in a byte buffer.
1853  *
1854  * Returns the number of bytes written to array, or zero if the current
1855  *         instance is not positioned on an element or -1 in case of error.
1856  */
1857 int
1858 xmlTextReaderReadBase64(xmlTextReaderPtr reader,
1859                         unsigned char *array ATTRIBUTE_UNUSED,
1860                     int offset ATTRIBUTE_UNUSED,
1861             int len ATTRIBUTE_UNUSED) {
1862     if ((reader == NULL) || (reader-&gt;ctxt == NULL))
1863     return(-1);
1864     if (reader-&gt;ctxt-&gt;wellFormed != 1)
1865     return(-1);
1866 
1867     if ((reader-&gt;node == NULL) || (reader-&gt;node-&gt;type == XML_ELEMENT_NODE))
1868     return(0);
1869     TODO
1870     return(0);
1871 }
1872 
1873 /**
1874  * xmlTextReaderReadBinHex:
1875  * @reader:  the xmlTextReaderPtr used
1876  * @array:  a byte array to store the content.
1877  * @offset:  the zero-based index into array where the method should
1878  *           begin to write.
1879  * @len:  the number of bytes to write.
1880  *
1881  * Reads and decodes the BinHex encoded contents of an element and
1882  * stores the result in a byte buffer.
1883  *
1884  * Returns the number of bytes written to array, or zero if the current
1885  *         instance is not positioned on an element or -1 in case of error.
1886  */
1887 int
1888 xmlTextReaderReadBinHex(xmlTextReaderPtr reader,
1889                         unsigned char *array ATTRIBUTE_UNUSED,
1890                     int offset ATTRIBUTE_UNUSED,
1891             int len ATTRIBUTE_UNUSED) {
1892     if ((reader == NULL) || (reader-&gt;ctxt == NULL))
1893     return(-1);
1894     if (reader-&gt;ctxt-&gt;wellFormed != 1)
1895     return(-1);
1896 
1897     if ((reader-&gt;node == NULL) || (reader-&gt;node-&gt;type == XML_ELEMENT_NODE))
1898     return(0);
1899     TODO
1900     return(0);
1901 }
1902 #endif
1903 
1904 /************************************************************************
1905  *                                  *
1906  *          Operating on a preparsed tree           *
1907  *                                  *
1908  ************************************************************************/
1909 static int
1910 xmlTextReaderNextTree(xmlTextReaderPtr reader)
1911 {
1912     if (reader == NULL)
1913         return(-1);
1914 
1915     if (reader-&gt;state == XML_TEXTREADER_END)
1916         return(0);
1917 
1918     if (reader-&gt;node == NULL) {
1919         if (reader-&gt;doc-&gt;children == NULL) {
1920             reader-&gt;state = XML_TEXTREADER_END;
1921             return(0);
1922         }
1923 
1924         reader-&gt;node = reader-&gt;doc-&gt;children;
1925         reader-&gt;state = XML_TEXTREADER_START;
1926         return(1);
1927     }
1928 
1929     if (reader-&gt;state != XML_TEXTREADER_BACKTRACK) {
1930     /* Here removed traversal to child, because we want to skip the subtree,
1931     replace with traversal to sibling to skip subtree */
1932         if (reader-&gt;node-&gt;next != 0) {
1933         /* Move to sibling if present,skipping sub-tree */
1934             reader-&gt;node = reader-&gt;node-&gt;next;
1935             reader-&gt;state = XML_TEXTREADER_START;
1936             return(1);
1937         }
1938 
1939     /* if reader-&gt;node-&gt;next is NULL mean no subtree for current node,
1940     so need to move to sibling of parent node if present */
1941     reader-&gt;state = XML_TEXTREADER_BACKTRACK;
1942     /* This will move to parent if present */
1943     xmlTextReaderRead(reader);
1944     }
1945 
1946     if (reader-&gt;node-&gt;next != 0) {
1947         reader-&gt;node = reader-&gt;node-&gt;next;
1948         reader-&gt;state = XML_TEXTREADER_START;
1949         return(1);
1950     }
1951 
1952     if (reader-&gt;node-&gt;parent != 0) {
1953         if (reader-&gt;node-&gt;parent-&gt;type == XML_DOCUMENT_NODE) {
1954             reader-&gt;state = XML_TEXTREADER_END;
1955             return(0);
1956         }
1957 
1958         reader-&gt;node = reader-&gt;node-&gt;parent;
1959         reader-&gt;depth--;
1960         reader-&gt;state = XML_TEXTREADER_BACKTRACK;
1961     /* Repeat process to move to sibling of parent node if present */
1962         xmlTextReaderNextTree(reader);
1963     }
1964 
1965     reader-&gt;state = XML_TEXTREADER_END;
1966 
1967     return(1);
1968 }
1969 
1970 /**
1971  * xmlTextReaderReadTree:
1972  * @reader:  the xmlTextReaderPtr used
1973  *
1974  *  Moves the position of the current instance to the next node in
1975  *  the stream, exposing its properties.
1976  *
1977  *  Returns 1 if the node was read successfully, 0 if there is no more
1978  *          nodes to read, or -1 in case of error
1979  */
1980 static int
1981 xmlTextReaderReadTree(xmlTextReaderPtr reader) {
1982     if (reader-&gt;state == XML_TEXTREADER_END)
1983         return(0);
1984 
1985 next_node:
1986     if (reader-&gt;node == NULL) {
1987         if (reader-&gt;doc-&gt;children == NULL) {
1988             reader-&gt;state = XML_TEXTREADER_END;
1989             return(0);
1990         }
1991 
1992         reader-&gt;node = reader-&gt;doc-&gt;children;
1993         reader-&gt;state = XML_TEXTREADER_START;
1994         goto found_node;
1995     }
1996 
1997     if ((reader-&gt;state != XML_TEXTREADER_BACKTRACK) &amp;&amp;
1998         (reader-&gt;node-&gt;type != XML_DTD_NODE) &amp;&amp;
1999         (reader-&gt;node-&gt;type != XML_XINCLUDE_START) &amp;&amp;
2000     (reader-&gt;node-&gt;type != XML_ENTITY_REF_NODE)) {
2001         if (reader-&gt;node-&gt;children != NULL) {
2002             reader-&gt;node = reader-&gt;node-&gt;children;
2003             reader-&gt;depth++;
2004             reader-&gt;state = XML_TEXTREADER_START;
2005             goto found_node;
2006         }
2007 
2008         if (reader-&gt;node-&gt;type == XML_ATTRIBUTE_NODE) {
2009             reader-&gt;state = XML_TEXTREADER_BACKTRACK;
2010             goto found_node;
2011         }
2012     }
2013 
2014     if (reader-&gt;node-&gt;next != NULL) {
2015         reader-&gt;node = reader-&gt;node-&gt;next;
2016         reader-&gt;state = XML_TEXTREADER_START;
2017         goto found_node;
2018     }
2019 
2020     if (reader-&gt;node-&gt;parent != NULL) {
2021         if ((reader-&gt;node-&gt;parent-&gt;type == XML_DOCUMENT_NODE) ||
2022         (reader-&gt;node-&gt;parent-&gt;type == XML_HTML_DOCUMENT_NODE)) {
2023             reader-&gt;state = XML_TEXTREADER_END;
2024             return(0);
2025         }
2026 
2027         reader-&gt;node = reader-&gt;node-&gt;parent;
2028         reader-&gt;depth--;
2029         reader-&gt;state = XML_TEXTREADER_BACKTRACK;
2030         goto found_node;
2031     }
2032 
2033     reader-&gt;state = XML_TEXTREADER_END;
2034 
2035 found_node:
2036     if ((reader-&gt;node-&gt;type == XML_XINCLUDE_START) ||
2037         (reader-&gt;node-&gt;type == XML_XINCLUDE_END))
2038     goto next_node;
2039 
2040     return(1);
2041 }
2042 
2043 /**
2044  * xmlTextReaderNextSibling:
2045  * @reader:  the xmlTextReaderPtr used
2046  *
2047  * Skip to the node following the current one in document order while
2048  * avoiding the subtree if any.
2049  * Currently implemented only for Readers built on a document
2050  *
2051  * Returns 1 if the node was read successfully, 0 if there is no more
2052  *          nodes to read, or -1 in case of error
2053  */
2054 int
2055 xmlTextReaderNextSibling(xmlTextReaderPtr reader) {
2056     if (reader == NULL)
2057         return(-1);
2058     if (reader-&gt;doc == NULL) {
2059         /* TODO */
2060     return(-1);
2061     }
2062 
2063     if (reader-&gt;state == XML_TEXTREADER_END)
2064         return(0);
2065 
2066     if (reader-&gt;node == NULL)
2067         return(xmlTextReaderNextTree(reader));
2068 
2069     if (reader-&gt;node-&gt;next != NULL) {
2070         reader-&gt;node = reader-&gt;node-&gt;next;
2071         reader-&gt;state = XML_TEXTREADER_START;
2072         return(1);
2073     }
2074 
2075     return(0);
2076 }
2077 
2078 /************************************************************************
2079  *                                  *
2080  *          Constructor and destructors         *
2081  *                                  *
2082  ************************************************************************/
2083 /**
2084  * xmlNewTextReader:
2085  * @input: the xmlParserInputBufferPtr used to read data
2086  * @URI: the URI information for the source if available
2087  *
2088  * Create an xmlTextReader structure fed with @input
2089  *
2090  * Returns the new xmlTextReaderPtr or NULL in case of error
2091  */
2092 xmlTextReaderPtr
2093 xmlNewTextReader(xmlParserInputBufferPtr input, const char *URI) {
2094     xmlTextReaderPtr ret;
2095 
2096     if (input == NULL)
2097     return(NULL);
2098     ret = xmlMalloc(sizeof(xmlTextReader));
2099     if (ret == NULL) {
2100         xmlGenericError(xmlGenericErrorContext,
2101         &quot;xmlNewTextReader : malloc failed\n&quot;);
2102     return(NULL);
2103     }
2104     memset(ret, 0, sizeof(xmlTextReader));
2105     ret-&gt;doc = NULL;
2106     ret-&gt;entTab = NULL;
2107     ret-&gt;entMax = 0;
2108     ret-&gt;entNr = 0;
2109     ret-&gt;input = input;
2110     ret-&gt;buffer = xmlBufCreateSize(100);
2111     if (ret-&gt;buffer == NULL) {
2112         xmlFree(ret);
2113         xmlGenericError(xmlGenericErrorContext,
2114         &quot;xmlNewTextReader : malloc failed\n&quot;);
2115     return(NULL);
2116     }
2117     /* no operation on a reader should require a huge buffer */
2118     xmlBufSetAllocationScheme(ret-&gt;buffer,
2119                   XML_BUFFER_ALLOC_BOUNDED);
2120     ret-&gt;sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));
2121     if (ret-&gt;sax == NULL) {
2122     xmlBufFree(ret-&gt;buffer);
2123     xmlFree(ret);
2124         xmlGenericError(xmlGenericErrorContext,
2125         &quot;xmlNewTextReader : malloc failed\n&quot;);
2126     return(NULL);
2127     }
2128     xmlSAXVersion(ret-&gt;sax, 2);
2129     ret-&gt;startElement = ret-&gt;sax-&gt;startElement;
2130     ret-&gt;sax-&gt;startElement = xmlTextReaderStartElement;
2131     ret-&gt;endElement = ret-&gt;sax-&gt;endElement;
2132     ret-&gt;sax-&gt;endElement = xmlTextReaderEndElement;
2133 #ifdef LIBXML_SAX1_ENABLED
2134     if (ret-&gt;sax-&gt;initialized == XML_SAX2_MAGIC) {
2135 #endif /* LIBXML_SAX1_ENABLED */
2136     ret-&gt;startElementNs = ret-&gt;sax-&gt;startElementNs;
2137     ret-&gt;sax-&gt;startElementNs = xmlTextReaderStartElementNs;
2138     ret-&gt;endElementNs = ret-&gt;sax-&gt;endElementNs;
2139     ret-&gt;sax-&gt;endElementNs = xmlTextReaderEndElementNs;
2140 #ifdef LIBXML_SAX1_ENABLED
2141     } else {
2142     ret-&gt;startElementNs = NULL;
2143     ret-&gt;endElementNs = NULL;
2144     }
2145 #endif /* LIBXML_SAX1_ENABLED */
2146     ret-&gt;characters = ret-&gt;sax-&gt;characters;
2147     ret-&gt;sax-&gt;characters = xmlTextReaderCharacters;
2148     ret-&gt;sax-&gt;ignorableWhitespace = xmlTextReaderCharacters;
2149     ret-&gt;cdataBlock = ret-&gt;sax-&gt;cdataBlock;
2150     ret-&gt;sax-&gt;cdataBlock = xmlTextReaderCDataBlock;
2151 
2152     ret-&gt;mode = XML_TEXTREADER_MODE_INITIAL;
2153     ret-&gt;node = NULL;
2154     ret-&gt;curnode = NULL;
2155     if (xmlBufUse(ret-&gt;input-&gt;buffer) &lt; 4) {
2156     xmlParserInputBufferRead(input, 4);
2157     }
2158     if (xmlBufUse(ret-&gt;input-&gt;buffer) &gt;= 4) {
2159     ret-&gt;ctxt = xmlCreatePushParserCtxt(ret-&gt;sax, NULL,
2160                  (const char *) xmlBufContent(ret-&gt;input-&gt;buffer),
2161                                             4, URI);
2162     ret-&gt;base = 0;
2163     ret-&gt;cur = 4;
2164     } else {
2165     ret-&gt;ctxt = xmlCreatePushParserCtxt(ret-&gt;sax, NULL, NULL, 0, URI);
2166     ret-&gt;base = 0;
2167     ret-&gt;cur = 0;
2168     }
2169 
2170     if (ret-&gt;ctxt == NULL) {
2171         xmlGenericError(xmlGenericErrorContext,
2172         &quot;xmlNewTextReader : malloc failed\n&quot;);
2173     xmlBufFree(ret-&gt;buffer);
2174     xmlFree(ret-&gt;sax);
2175     xmlFree(ret);
2176     return(NULL);
2177     }
2178     ret-&gt;ctxt-&gt;parseMode = XML_PARSE_READER;
2179     ret-&gt;ctxt-&gt;_private = ret;
2180     ret-&gt;ctxt-&gt;linenumbers = 1;
2181     ret-&gt;ctxt-&gt;dictNames = 1;
2182     ret-&gt;allocs = XML_TEXTREADER_CTXT;
2183     /*
2184      * use the parser dictionary to allocate all elements and attributes names
2185      */
2186     ret-&gt;ctxt-&gt;docdict = 1;
2187     ret-&gt;dict = ret-&gt;ctxt-&gt;dict;
2188 #ifdef LIBXML_XINCLUDE_ENABLED
2189     ret-&gt;xinclude = 0;
2190 #endif
2191 #ifdef LIBXML_PATTERN_ENABLED
2192     ret-&gt;patternMax = 0;
2193     ret-&gt;patternTab = NULL;
2194 #endif
2195     return(ret);
2196 }
2197 
2198 /**
2199  * xmlNewTextReaderFilename:
2200  * @URI: the URI of the resource to process
2201  *
2202  * Create an xmlTextReader structure fed with the resource at @URI
2203  *
2204  * Returns the new xmlTextReaderPtr or NULL in case of error
2205  */
2206 xmlTextReaderPtr
2207 xmlNewTextReaderFilename(const char *URI) {
2208     xmlParserInputBufferPtr input;
2209     xmlTextReaderPtr ret;
2210     char *directory = NULL;
2211 
2212     input = xmlParserInputBufferCreateFilename(URI, XML_CHAR_ENCODING_NONE);
2213     if (input == NULL)
2214     return(NULL);
2215     ret = xmlNewTextReader(input, URI);
2216     if (ret == NULL) {
2217     xmlFreeParserInputBuffer(input);
2218     return(NULL);
2219     }
2220     ret-&gt;allocs |= XML_TEXTREADER_INPUT;
2221     if (ret-&gt;ctxt-&gt;directory == NULL)
2222         directory = xmlParserGetDirectory(URI);
2223     if ((ret-&gt;ctxt-&gt;directory == NULL) &amp;&amp; (directory != NULL))
2224         ret-&gt;ctxt-&gt;directory = (char *) xmlStrdup((xmlChar *) directory);
2225     if (directory != NULL)
2226     xmlFree(directory);
2227     return(ret);
2228 }
2229 
2230 /**
2231  * xmlFreeTextReader:
2232  * @reader:  the xmlTextReaderPtr
2233  *
2234  * Deallocate all the resources associated to the reader
2235  */
2236 void
2237 xmlFreeTextReader(xmlTextReaderPtr reader) {
2238     if (reader == NULL)
2239     return;
2240 #ifdef LIBXML_SCHEMAS_ENABLED
2241     if (reader-&gt;rngSchemas != NULL) {
2242     xmlRelaxNGFree(reader-&gt;rngSchemas);
2243     reader-&gt;rngSchemas = NULL;
2244     }
2245     if (reader-&gt;rngValidCtxt != NULL) {
2246     if (! reader-&gt;rngPreserveCtxt)
2247         xmlRelaxNGFreeValidCtxt(reader-&gt;rngValidCtxt);
2248     reader-&gt;rngValidCtxt = NULL;
2249     }
2250     if (reader-&gt;xsdPlug != NULL) {
2251     xmlSchemaSAXUnplug(reader-&gt;xsdPlug);
2252     reader-&gt;xsdPlug = NULL;
2253     }
2254     if (reader-&gt;xsdValidCtxt != NULL) {
2255     if (! reader-&gt;xsdPreserveCtxt)
2256         xmlSchemaFreeValidCtxt(reader-&gt;xsdValidCtxt);
2257     reader-&gt;xsdValidCtxt = NULL;
2258     }
2259     if (reader-&gt;xsdSchemas != NULL) {
2260     xmlSchemaFree(reader-&gt;xsdSchemas);
2261     reader-&gt;xsdSchemas = NULL;
2262     }
2263 #endif
2264 #ifdef LIBXML_XINCLUDE_ENABLED
2265     if (reader-&gt;xincctxt != NULL)
2266     xmlXIncludeFreeContext(reader-&gt;xincctxt);
2267 #endif
2268 #ifdef LIBXML_PATTERN_ENABLED
2269     if (reader-&gt;patternTab != NULL) {
2270         int i;
2271     for (i = 0;i &lt; reader-&gt;patternNr;i++) {
2272         if (reader-&gt;patternTab[i] != NULL)
2273             xmlFreePattern(reader-&gt;patternTab[i]);
2274     }
2275     xmlFree(reader-&gt;patternTab);
2276     }
2277 #endif
2278     if (reader-&gt;faketext != NULL) {
2279     xmlFreeNode(reader-&gt;faketext);
2280     }
2281     if (reader-&gt;ctxt != NULL) {
2282         if (reader-&gt;dict == reader-&gt;ctxt-&gt;dict)
2283         reader-&gt;dict = NULL;
<a name="20" id="anc20"></a>




2284     if ((reader-&gt;ctxt-&gt;vctxt.vstateTab != NULL) &amp;&amp;
2285         (reader-&gt;ctxt-&gt;vctxt.vstateMax &gt; 0)){
<a name="21" id="anc21"></a><span class="line-added">2286 #ifdef LIBXML_REGEXP_ENABLED</span>
<span class="line-added">2287             while (reader-&gt;ctxt-&gt;vctxt.vstateNr &gt; 0)</span>
<span class="line-added">2288                 xmlValidatePopElement(&amp;reader-&gt;ctxt-&gt;vctxt, NULL, NULL, NULL);</span>
<span class="line-added">2289 #endif</span>
2290         xmlFree(reader-&gt;ctxt-&gt;vctxt.vstateTab);
2291         reader-&gt;ctxt-&gt;vctxt.vstateTab = NULL;
2292         reader-&gt;ctxt-&gt;vctxt.vstateMax = 0;
2293     }
<a name="22" id="anc22"></a><span class="line-added">2294     if (reader-&gt;ctxt-&gt;myDoc != NULL) {</span>
<span class="line-added">2295         if (reader-&gt;preserve == 0)</span>
<span class="line-added">2296         xmlTextReaderFreeDoc(reader, reader-&gt;ctxt-&gt;myDoc);</span>
<span class="line-added">2297         reader-&gt;ctxt-&gt;myDoc = NULL;</span>
<span class="line-added">2298     }</span>
2299     if (reader-&gt;allocs &amp; XML_TEXTREADER_CTXT)
2300         xmlFreeParserCtxt(reader-&gt;ctxt);
2301     }
2302     if (reader-&gt;sax != NULL)
2303     xmlFree(reader-&gt;sax);
2304     if ((reader-&gt;input != NULL)  &amp;&amp; (reader-&gt;allocs &amp; XML_TEXTREADER_INPUT))
2305     xmlFreeParserInputBuffer(reader-&gt;input);
2306     if (reader-&gt;buffer != NULL)
2307         xmlBufFree(reader-&gt;buffer);
2308     if (reader-&gt;entTab != NULL)
2309     xmlFree(reader-&gt;entTab);
2310     if (reader-&gt;dict != NULL)
2311         xmlDictFree(reader-&gt;dict);
2312     xmlFree(reader);
2313 }
2314 
2315 /************************************************************************
2316  *                                  *
2317  *          Methods for XmlTextReader           *
2318  *                                  *
2319  ************************************************************************/
2320 /**
2321  * xmlTextReaderClose:
2322  * @reader:  the xmlTextReaderPtr used
2323  *
2324  * This method releases any resources allocated by the current instance
2325  * changes the state to Closed and close any underlying input.
2326  *
2327  * Returns 0 or -1 in case of error
2328  */
2329 int
2330 xmlTextReaderClose(xmlTextReaderPtr reader) {
2331     if (reader == NULL)
2332     return(-1);
2333     reader-&gt;node = NULL;
2334     reader-&gt;curnode = NULL;
2335     reader-&gt;mode = XML_TEXTREADER_MODE_CLOSED;
2336     if (reader-&gt;ctxt != NULL) {
2337     xmlStopParser(reader-&gt;ctxt);
2338     if (reader-&gt;ctxt-&gt;myDoc != NULL) {
2339         if (reader-&gt;preserve == 0)
2340         xmlTextReaderFreeDoc(reader, reader-&gt;ctxt-&gt;myDoc);
2341         reader-&gt;ctxt-&gt;myDoc = NULL;
2342     }
2343     }
2344     if ((reader-&gt;input != NULL)  &amp;&amp; (reader-&gt;allocs &amp; XML_TEXTREADER_INPUT)) {
2345     xmlFreeParserInputBuffer(reader-&gt;input);
2346     reader-&gt;allocs -= XML_TEXTREADER_INPUT;
2347     }
2348     return(0);
2349 }
2350 
2351 /**
2352  * xmlTextReaderGetAttributeNo:
2353  * @reader:  the xmlTextReaderPtr used
2354  * @no: the zero-based index of the attribute relative to the containing element
2355  *
2356  * Provides the value of the attribute with the specified index relative
2357  * to the containing element.
2358  *
2359  * Returns a string containing the value of the specified attribute, or NULL
2360  *    in case of error. The string must be deallocated by the caller.
2361  */
2362 xmlChar *
2363 xmlTextReaderGetAttributeNo(xmlTextReaderPtr reader, int no) {
2364     xmlChar *ret;
2365     int i;
2366     xmlAttrPtr cur;
2367     xmlNsPtr ns;
2368 
2369     if (reader == NULL)
2370     return(NULL);
2371     if (reader-&gt;node == NULL)
2372     return(NULL);
2373     if (reader-&gt;curnode != NULL)
2374     return(NULL);
2375     /* TODO: handle the xmlDecl */
2376     if (reader-&gt;node-&gt;type != XML_ELEMENT_NODE)
2377     return(NULL);
2378 
2379     ns = reader-&gt;node-&gt;nsDef;
2380     for (i = 0;(i &lt; no) &amp;&amp; (ns != NULL);i++) {
2381     ns = ns-&gt;next;
2382     }
2383     if (ns != NULL)
2384     return(xmlStrdup(ns-&gt;href));
2385 
2386     cur = reader-&gt;node-&gt;properties;
2387     if (cur == NULL)
2388     return(NULL);
2389     for (;i &lt; no;i++) {
2390     cur = cur-&gt;next;
2391     if (cur == NULL)
2392         return(NULL);
2393     }
2394     /* TODO walk the DTD if present */
2395 
2396     ret = xmlNodeListGetString(reader-&gt;node-&gt;doc, cur-&gt;children, 1);
2397     if (ret == NULL) return(xmlStrdup((xmlChar *)&quot;&quot;));
2398     return(ret);
2399 }
2400 
2401 /**
2402  * xmlTextReaderGetAttribute:
2403  * @reader:  the xmlTextReaderPtr used
2404  * @name: the qualified name of the attribute.
2405  *
2406  * Provides the value of the attribute with the specified qualified name.
2407  *
2408  * Returns a string containing the value of the specified attribute, or NULL
2409  *    in case of error. The string must be deallocated by the caller.
2410  */
2411 xmlChar *
2412 xmlTextReaderGetAttribute(xmlTextReaderPtr reader, const xmlChar *name) {
2413     xmlChar *prefix = NULL;
2414     xmlChar *localname;
2415     xmlNsPtr ns;
2416     xmlChar *ret = NULL;
2417 
2418     if ((reader == NULL) || (name == NULL))
2419     return(NULL);
2420     if (reader-&gt;node == NULL)
2421     return(NULL);
2422     if (reader-&gt;curnode != NULL)
2423     return(NULL);
2424 
2425     /* TODO: handle the xmlDecl */
2426     if (reader-&gt;node-&gt;type != XML_ELEMENT_NODE)
2427     return(NULL);
2428 
2429     localname = xmlSplitQName2(name, &amp;prefix);
2430     if (localname == NULL) {
2431         /*
2432          * Namespace default decl
2433          */
2434         if (xmlStrEqual(name, BAD_CAST &quot;xmlns&quot;)) {
2435             ns = reader-&gt;node-&gt;nsDef;
2436             while (ns != NULL) {
2437                 if (ns-&gt;prefix == NULL) {
2438                     return(xmlStrdup(ns-&gt;href));
2439                 }
2440                 ns = ns-&gt;next;
2441             }
2442             return NULL;
2443         }
2444         return(xmlGetNoNsProp(reader-&gt;node, name));
2445     }
2446 
2447     /*
2448      * Namespace default decl
2449      */
2450     if (xmlStrEqual(prefix, BAD_CAST &quot;xmlns&quot;)) {
2451         ns = reader-&gt;node-&gt;nsDef;
2452         while (ns != NULL) {
2453             if ((ns-&gt;prefix != NULL) &amp;&amp; (xmlStrEqual(ns-&gt;prefix, localname))) {
2454                 ret = xmlStrdup(ns-&gt;href);
2455                 break;
2456             }
2457             ns = ns-&gt;next;
2458         }
2459     } else {
2460         ns = xmlSearchNs(reader-&gt;node-&gt;doc, reader-&gt;node, prefix);
2461         if (ns != NULL)
2462             ret = xmlGetNsProp(reader-&gt;node, localname, ns-&gt;href);
2463     }
2464 
2465     xmlFree(localname);
2466     if (prefix != NULL)
2467         xmlFree(prefix);
2468     return(ret);
2469 }
2470 
2471 
2472 /**
2473  * xmlTextReaderGetAttributeNs:
2474  * @reader:  the xmlTextReaderPtr used
2475  * @localName: the local name of the attribute.
2476  * @namespaceURI: the namespace URI of the attribute.
2477  *
2478  * Provides the value of the specified attribute
2479  *
2480  * Returns a string containing the value of the specified attribute, or NULL
2481  *    in case of error. The string must be deallocated by the caller.
2482  */
2483 xmlChar *
2484 xmlTextReaderGetAttributeNs(xmlTextReaderPtr reader, const xmlChar *localName,
2485                 const xmlChar *namespaceURI) {
2486     xmlChar *prefix = NULL;
2487     xmlNsPtr ns;
2488 
2489     if ((reader == NULL) || (localName == NULL))
2490     return(NULL);
2491     if (reader-&gt;node == NULL)
2492     return(NULL);
2493     if (reader-&gt;curnode != NULL)
2494     return(NULL);
2495 
2496     /* TODO: handle the xmlDecl */
2497     if (reader-&gt;node-&gt;type != XML_ELEMENT_NODE)
2498     return(NULL);
2499 
2500     if (xmlStrEqual(namespaceURI, BAD_CAST &quot;http://www.w3.org/2000/xmlns/&quot;)) {
2501         if (! xmlStrEqual(localName, BAD_CAST &quot;xmlns&quot;)) {
2502             prefix = BAD_CAST localName;
2503         }
2504         ns = reader-&gt;node-&gt;nsDef;
2505         while (ns != NULL) {
2506             if ((prefix == NULL &amp;&amp; ns-&gt;prefix == NULL) ||
2507                 ((ns-&gt;prefix != NULL) &amp;&amp; (xmlStrEqual(ns-&gt;prefix, localName)))) {
2508                 return xmlStrdup(ns-&gt;href);
2509             }
2510             ns = ns-&gt;next;
2511         }
2512         return NULL;
2513     }
2514 
2515     return(xmlGetNsProp(reader-&gt;node, localName, namespaceURI));
2516 }
2517 
2518 /**
2519  * xmlTextReaderGetRemainder:
2520  * @reader:  the xmlTextReaderPtr used
2521  *
2522  * Method to get the remainder of the buffered XML. this method stops the
2523  * parser, set its state to End Of File and return the input stream with
2524  * what is left that the parser did not use.
2525  *
<a name="23" id="anc23"></a><span class="line-modified">2526  * The implementation is not good, the parser certainly progressed past</span>
2527  * what&#39;s left in reader-&gt;input, and there is an allocation problem. Best
2528  * would be to rewrite it differently.
2529  *
2530  * Returns the xmlParserInputBufferPtr attached to the XML or NULL
2531  *    in case of error.
2532  */
2533 xmlParserInputBufferPtr
2534 xmlTextReaderGetRemainder(xmlTextReaderPtr reader) {
2535     xmlParserInputBufferPtr ret = NULL;
2536 
2537     if (reader == NULL)
2538     return(NULL);
2539     if (reader-&gt;node == NULL)
2540     return(NULL);
2541 
2542     reader-&gt;node = NULL;
2543     reader-&gt;curnode = NULL;
2544     reader-&gt;mode = XML_TEXTREADER_MODE_EOF;
2545     if (reader-&gt;ctxt != NULL) {
2546     xmlStopParser(reader-&gt;ctxt);
2547     if (reader-&gt;ctxt-&gt;myDoc != NULL) {
2548         if (reader-&gt;preserve == 0)
2549         xmlTextReaderFreeDoc(reader, reader-&gt;ctxt-&gt;myDoc);
2550         reader-&gt;ctxt-&gt;myDoc = NULL;
2551     }
2552     }
2553     if (reader-&gt;allocs &amp; XML_TEXTREADER_INPUT) {
2554     ret = reader-&gt;input;
2555     reader-&gt;input = NULL;
2556     reader-&gt;allocs -= XML_TEXTREADER_INPUT;
2557     } else {
2558     /*
2559      * Hum, one may need to duplicate the data structure because
2560      * without reference counting the input may be freed twice:
2561      *   - by the layer which allocated it.
2562      *   - by the layer to which would have been returned to.
2563      */
2564     TODO
2565     return(NULL);
2566     }
2567     return(ret);
2568 }
2569 
2570 /**
2571  * xmlTextReaderLookupNamespace:
2572  * @reader:  the xmlTextReaderPtr used
2573  * @prefix: the prefix whose namespace URI is to be resolved. To return
2574  *          the default namespace, specify NULL
2575  *
2576  * Resolves a namespace prefix in the scope of the current element.
2577  *
2578  * Returns a string containing the namespace URI to which the prefix maps
2579  *    or NULL in case of error. The string must be deallocated by the caller.
2580  */
2581 xmlChar *
2582 xmlTextReaderLookupNamespace(xmlTextReaderPtr reader, const xmlChar *prefix) {
2583     xmlNsPtr ns;
2584 
2585     if (reader == NULL)
2586     return(NULL);
2587     if (reader-&gt;node == NULL)
2588     return(NULL);
2589 
2590     ns = xmlSearchNs(reader-&gt;node-&gt;doc, reader-&gt;node, prefix);
2591     if (ns == NULL)
2592     return(NULL);
2593     return(xmlStrdup(ns-&gt;href));
2594 }
2595 
2596 /**
2597  * xmlTextReaderMoveToAttributeNo:
2598  * @reader:  the xmlTextReaderPtr used
2599  * @no: the zero-based index of the attribute relative to the containing
2600  *      element.
2601  *
2602  * Moves the position of the current instance to the attribute with
2603  * the specified index relative to the containing element.
2604  *
2605  * Returns 1 in case of success, -1 in case of error, 0 if not found
2606  */
2607 int
2608 xmlTextReaderMoveToAttributeNo(xmlTextReaderPtr reader, int no) {
2609     int i;
2610     xmlAttrPtr cur;
2611     xmlNsPtr ns;
2612 
2613     if (reader == NULL)
2614     return(-1);
2615     if (reader-&gt;node == NULL)
2616     return(-1);
2617     /* TODO: handle the xmlDecl */
2618     if (reader-&gt;node-&gt;type != XML_ELEMENT_NODE)
2619     return(-1);
2620 
2621     reader-&gt;curnode = NULL;
2622 
2623     ns = reader-&gt;node-&gt;nsDef;
2624     for (i = 0;(i &lt; no) &amp;&amp; (ns != NULL);i++) {
2625     ns = ns-&gt;next;
2626     }
2627     if (ns != NULL) {
2628     reader-&gt;curnode = (xmlNodePtr) ns;
2629     return(1);
2630     }
2631 
2632     cur = reader-&gt;node-&gt;properties;
2633     if (cur == NULL)
2634     return(0);
2635     for (;i &lt; no;i++) {
2636     cur = cur-&gt;next;
2637     if (cur == NULL)
2638         return(0);
2639     }
2640     /* TODO walk the DTD if present */
2641 
2642     reader-&gt;curnode = (xmlNodePtr) cur;
2643     return(1);
2644 }
2645 
2646 /**
2647  * xmlTextReaderMoveToAttribute:
2648  * @reader:  the xmlTextReaderPtr used
2649  * @name: the qualified name of the attribute.
2650  *
2651  * Moves the position of the current instance to the attribute with
2652  * the specified qualified name.
2653  *
2654  * Returns 1 in case of success, -1 in case of error, 0 if not found
2655  */
2656 int
2657 xmlTextReaderMoveToAttribute(xmlTextReaderPtr reader, const xmlChar *name) {
2658     xmlChar *prefix = NULL;
2659     xmlChar *localname;
2660     xmlNsPtr ns;
2661     xmlAttrPtr prop;
2662 
2663     if ((reader == NULL) || (name == NULL))
2664     return(-1);
2665     if (reader-&gt;node == NULL)
2666     return(-1);
2667 
2668     /* TODO: handle the xmlDecl */
2669     if (reader-&gt;node-&gt;type != XML_ELEMENT_NODE)
2670     return(0);
2671 
2672     localname = xmlSplitQName2(name, &amp;prefix);
2673     if (localname == NULL) {
2674     /*
2675      * Namespace default decl
2676      */
2677     if (xmlStrEqual(name, BAD_CAST &quot;xmlns&quot;)) {
2678         ns = reader-&gt;node-&gt;nsDef;
2679         while (ns != NULL) {
2680         if (ns-&gt;prefix == NULL) {
2681             reader-&gt;curnode = (xmlNodePtr) ns;
2682             return(1);
2683         }
2684         ns = ns-&gt;next;
2685         }
2686         return(0);
2687     }
2688 
2689     prop = reader-&gt;node-&gt;properties;
2690     while (prop != NULL) {
2691         /*
2692          * One need to have
2693          *   - same attribute names
2694          *   - and the attribute carrying that namespace
2695          */
2696         if ((xmlStrEqual(prop-&gt;name, name)) &amp;&amp;
2697         ((prop-&gt;ns == NULL) || (prop-&gt;ns-&gt;prefix == NULL))) {
2698         reader-&gt;curnode = (xmlNodePtr) prop;
2699         return(1);
2700         }
2701         prop = prop-&gt;next;
2702     }
2703     return(0);
2704     }
2705 
2706     /*
2707      * Namespace default decl
2708      */
2709     if (xmlStrEqual(prefix, BAD_CAST &quot;xmlns&quot;)) {
2710     ns = reader-&gt;node-&gt;nsDef;
2711     while (ns != NULL) {
2712         if ((ns-&gt;prefix != NULL) &amp;&amp; (xmlStrEqual(ns-&gt;prefix, localname))) {
2713         reader-&gt;curnode = (xmlNodePtr) ns;
2714         goto found;
2715         }
2716         ns = ns-&gt;next;
2717     }
2718     goto not_found;
2719     }
2720     prop = reader-&gt;node-&gt;properties;
2721     while (prop != NULL) {
2722     /*
2723      * One need to have
2724      *   - same attribute names
2725      *   - and the attribute carrying that namespace
2726      */
2727     if ((xmlStrEqual(prop-&gt;name, localname)) &amp;&amp;
2728         (prop-&gt;ns != NULL) &amp;&amp; (xmlStrEqual(prop-&gt;ns-&gt;prefix, prefix))) {
2729         reader-&gt;curnode = (xmlNodePtr) prop;
2730         goto found;
2731     }
2732     prop = prop-&gt;next;
2733     }
2734 not_found:
2735     if (localname != NULL)
2736         xmlFree(localname);
2737     if (prefix != NULL)
2738         xmlFree(prefix);
2739     return(0);
2740 
2741 found:
2742     if (localname != NULL)
2743         xmlFree(localname);
2744     if (prefix != NULL)
2745         xmlFree(prefix);
2746     return(1);
2747 }
2748 
2749 /**
2750  * xmlTextReaderMoveToAttributeNs:
2751  * @reader:  the xmlTextReaderPtr used
2752  * @localName:  the local name of the attribute.
2753  * @namespaceURI:  the namespace URI of the attribute.
2754  *
2755  * Moves the position of the current instance to the attribute with the
2756  * specified local name and namespace URI.
2757  *
2758  * Returns 1 in case of success, -1 in case of error, 0 if not found
2759  */
2760 int
2761 xmlTextReaderMoveToAttributeNs(xmlTextReaderPtr reader,
2762     const xmlChar *localName, const xmlChar *namespaceURI) {
2763     xmlAttrPtr prop;
2764     xmlNodePtr node;
2765     xmlNsPtr ns;
2766     xmlChar *prefix = NULL;
2767 
2768     if ((reader == NULL) || (localName == NULL) || (namespaceURI == NULL))
2769     return(-1);
2770     if (reader-&gt;node == NULL)
2771     return(-1);
2772     if (reader-&gt;node-&gt;type != XML_ELEMENT_NODE)
2773     return(0);
2774     node = reader-&gt;node;
2775 
2776     if (xmlStrEqual(namespaceURI, BAD_CAST &quot;http://www.w3.org/2000/xmlns/&quot;)) {
2777         if (! xmlStrEqual(localName, BAD_CAST &quot;xmlns&quot;)) {
2778             prefix = BAD_CAST localName;
2779         }
2780         ns = reader-&gt;node-&gt;nsDef;
2781         while (ns != NULL) {
2782             if ((prefix == NULL &amp;&amp; ns-&gt;prefix == NULL) ||
2783                 ((ns-&gt;prefix != NULL) &amp;&amp; (xmlStrEqual(ns-&gt;prefix, localName)))) {
2784                 reader-&gt;curnode = (xmlNodePtr) ns;
2785                 return(1);
2786             }
2787             ns = ns-&gt;next;
2788         }
2789         return(0);
2790     }
2791 
2792     prop = node-&gt;properties;
2793     while (prop != NULL) {
2794     /*
2795      * One need to have
2796      *   - same attribute names
2797      *   - and the attribute carrying that namespace
2798      */
2799         if (xmlStrEqual(prop-&gt;name, localName) &amp;&amp;
2800         ((prop-&gt;ns != NULL) &amp;&amp;
2801          (xmlStrEqual(prop-&gt;ns-&gt;href, namespaceURI)))) {
2802         reader-&gt;curnode = (xmlNodePtr) prop;
2803         return(1);
2804         }
2805     prop = prop-&gt;next;
2806     }
2807     return(0);
2808 }
2809 
2810 /**
2811  * xmlTextReaderMoveToFirstAttribute:
2812  * @reader:  the xmlTextReaderPtr used
2813  *
2814  * Moves the position of the current instance to the first attribute
2815  * associated with the current node.
2816  *
2817  * Returns 1 in case of success, -1 in case of error, 0 if not found
2818  */
2819 int
2820 xmlTextReaderMoveToFirstAttribute(xmlTextReaderPtr reader) {
2821     if (reader == NULL)
2822     return(-1);
2823     if (reader-&gt;node == NULL)
2824     return(-1);
2825     if (reader-&gt;node-&gt;type != XML_ELEMENT_NODE)
2826     return(0);
2827 
2828     if (reader-&gt;node-&gt;nsDef != NULL) {
2829     reader-&gt;curnode = (xmlNodePtr) reader-&gt;node-&gt;nsDef;
2830     return(1);
2831     }
2832     if (reader-&gt;node-&gt;properties != NULL) {
2833     reader-&gt;curnode = (xmlNodePtr) reader-&gt;node-&gt;properties;
2834     return(1);
2835     }
2836     return(0);
2837 }
2838 
2839 /**
2840  * xmlTextReaderMoveToNextAttribute:
2841  * @reader:  the xmlTextReaderPtr used
2842  *
2843  * Moves the position of the current instance to the next attribute
2844  * associated with the current node.
2845  *
2846  * Returns 1 in case of success, -1 in case of error, 0 if not found
2847  */
2848 int
2849 xmlTextReaderMoveToNextAttribute(xmlTextReaderPtr reader) {
2850     if (reader == NULL)
2851     return(-1);
2852     if (reader-&gt;node == NULL)
2853     return(-1);
2854     if (reader-&gt;node-&gt;type != XML_ELEMENT_NODE)
2855     return(0);
2856     if (reader-&gt;curnode == NULL)
2857     return(xmlTextReaderMoveToFirstAttribute(reader));
2858 
2859     if (reader-&gt;curnode-&gt;type == XML_NAMESPACE_DECL) {
2860     xmlNsPtr ns = (xmlNsPtr) reader-&gt;curnode;
2861     if (ns-&gt;next != NULL) {
2862         reader-&gt;curnode = (xmlNodePtr) ns-&gt;next;
2863         return(1);
2864     }
2865     if (reader-&gt;node-&gt;properties != NULL) {
2866         reader-&gt;curnode = (xmlNodePtr) reader-&gt;node-&gt;properties;
2867         return(1);
2868     }
2869     return(0);
2870     } else if ((reader-&gt;curnode-&gt;type == XML_ATTRIBUTE_NODE) &amp;&amp;
2871            (reader-&gt;curnode-&gt;next != NULL)) {
2872     reader-&gt;curnode = reader-&gt;curnode-&gt;next;
2873     return(1);
2874     }
2875     return(0);
2876 }
2877 
2878 /**
2879  * xmlTextReaderMoveToElement:
2880  * @reader:  the xmlTextReaderPtr used
2881  *
2882  * Moves the position of the current instance to the node that
2883  * contains the current Attribute  node.
2884  *
2885  * Returns 1 in case of success, -1 in case of error, 0 if not moved
2886  */
2887 int
2888 xmlTextReaderMoveToElement(xmlTextReaderPtr reader) {
2889     if (reader == NULL)
2890     return(-1);
2891     if (reader-&gt;node == NULL)
2892     return(-1);
2893     if (reader-&gt;node-&gt;type != XML_ELEMENT_NODE)
2894     return(0);
2895     if (reader-&gt;curnode != NULL) {
2896     reader-&gt;curnode = NULL;
2897     return(1);
2898     }
2899     return(0);
2900 }
2901 
2902 /**
2903  * xmlTextReaderReadAttributeValue:
2904  * @reader:  the xmlTextReaderPtr used
2905  *
2906  * Parses an attribute value into one or more Text and EntityReference nodes.
2907  *
<a name="24" id="anc24"></a><span class="line-modified">2908  * Returns 1 in case of success, 0 if the reader was not positioned on an</span>
<span class="line-modified">2909  *         attribute node or all the attribute values have been read, or -1</span>
2910  *         in case of error.
2911  */
2912 int
2913 xmlTextReaderReadAttributeValue(xmlTextReaderPtr reader) {
2914     if (reader == NULL)
2915     return(-1);
2916     if (reader-&gt;node == NULL)
2917     return(-1);
2918     if (reader-&gt;curnode == NULL)
2919     return(0);
2920     if (reader-&gt;curnode-&gt;type == XML_ATTRIBUTE_NODE) {
2921     if (reader-&gt;curnode-&gt;children == NULL)
2922         return(0);
2923     reader-&gt;curnode = reader-&gt;curnode-&gt;children;
2924     } else if (reader-&gt;curnode-&gt;type == XML_NAMESPACE_DECL) {
2925     xmlNsPtr ns = (xmlNsPtr) reader-&gt;curnode;
2926 
2927     if (reader-&gt;faketext == NULL) {
2928         reader-&gt;faketext = xmlNewDocText(reader-&gt;node-&gt;doc,
2929                                      ns-&gt;href);
2930     } else {
2931             if ((reader-&gt;faketext-&gt;content != NULL) &amp;&amp;
2932             (reader-&gt;faketext-&gt;content !=
2933          (xmlChar *) &amp;(reader-&gt;faketext-&gt;properties)))
2934         xmlFree(reader-&gt;faketext-&gt;content);
2935         reader-&gt;faketext-&gt;content = xmlStrdup(ns-&gt;href);
2936     }
2937     reader-&gt;curnode = reader-&gt;faketext;
2938     } else {
2939     if (reader-&gt;curnode-&gt;next == NULL)
2940         return(0);
2941     reader-&gt;curnode = reader-&gt;curnode-&gt;next;
2942     }
2943     return(1);
2944 }
2945 
2946 /**
2947  * xmlTextReaderConstEncoding:
2948  * @reader:  the xmlTextReaderPtr used
2949  *
2950  * Determine the encoding of the document being read.
2951  *
2952  * Returns a string containing the encoding of the document or NULL in
2953  * case of error.  The string is deallocated with the reader.
2954  */
2955 const xmlChar *
2956 xmlTextReaderConstEncoding(xmlTextReaderPtr reader) {
2957     xmlDocPtr doc = NULL;
2958     if (reader == NULL)
2959     return(NULL);
2960     if (reader-&gt;doc != NULL)
2961         doc = reader-&gt;doc;
2962     else if (reader-&gt;ctxt != NULL)
2963     doc = reader-&gt;ctxt-&gt;myDoc;
2964     if (doc == NULL)
2965     return(NULL);
2966 
2967     if (doc-&gt;encoding == NULL)
2968     return(NULL);
2969     else
2970       return(CONSTSTR(doc-&gt;encoding));
2971 }
2972 
2973 
2974 /************************************************************************
2975  *                                  *
2976  *          Acces API to the current node           *
2977  *                                  *
2978  ************************************************************************/
2979 /**
2980  * xmlTextReaderAttributeCount:
2981  * @reader:  the xmlTextReaderPtr used
2982  *
2983  * Provides the number of attributes of the current node
2984  *
2985  * Returns 0 i no attributes, -1 in case of error or the attribute count
2986  */
2987 int
2988 xmlTextReaderAttributeCount(xmlTextReaderPtr reader) {
2989     int ret;
2990     xmlAttrPtr attr;
2991     xmlNsPtr ns;
2992     xmlNodePtr node;
2993 
2994     if (reader == NULL)
2995     return(-1);
2996     if (reader-&gt;node == NULL)
2997     return(0);
2998 
2999     if (reader-&gt;curnode != NULL)
3000     node = reader-&gt;curnode;
3001     else
3002     node = reader-&gt;node;
3003 
3004     if (node-&gt;type != XML_ELEMENT_NODE)
3005     return(0);
3006     if ((reader-&gt;state == XML_TEXTREADER_END) ||
3007     (reader-&gt;state == XML_TEXTREADER_BACKTRACK))
3008     return(0);
3009     ret = 0;
3010     attr = node-&gt;properties;
3011     while (attr != NULL) {
3012     ret++;
3013     attr = attr-&gt;next;
3014     }
3015     ns = node-&gt;nsDef;
3016     while (ns != NULL) {
3017     ret++;
3018     ns = ns-&gt;next;
3019     }
3020     return(ret);
3021 }
3022 
3023 /**
3024  * xmlTextReaderNodeType:
3025  * @reader:  the xmlTextReaderPtr used
3026  *
3027  * Get the node type of the current node
3028  * Reference:
3029  * http://www.gnu.org/software/dotgnu/pnetlib-doc/System/Xml/XmlNodeType.html
3030  *
3031  * Returns the xmlReaderTypes of the current node or -1 in case of error
3032  */
3033 int
3034 xmlTextReaderNodeType(xmlTextReaderPtr reader) {
3035     xmlNodePtr node;
3036 
3037     if (reader == NULL)
3038     return(-1);
3039     if (reader-&gt;node == NULL)
3040     return(XML_READER_TYPE_NONE);
3041     if (reader-&gt;curnode != NULL)
3042     node = reader-&gt;curnode;
3043     else
3044     node = reader-&gt;node;
3045     switch (node-&gt;type) {
3046         case XML_ELEMENT_NODE:
3047         if ((reader-&gt;state == XML_TEXTREADER_END) ||
3048         (reader-&gt;state == XML_TEXTREADER_BACKTRACK))
3049         return(XML_READER_TYPE_END_ELEMENT);
3050         return(XML_READER_TYPE_ELEMENT);
3051         case XML_NAMESPACE_DECL:
3052         case XML_ATTRIBUTE_NODE:
3053         return(XML_READER_TYPE_ATTRIBUTE);
3054         case XML_TEXT_NODE:
3055         if (xmlIsBlankNode(reader-&gt;node)) {
3056         if (xmlNodeGetSpacePreserve(reader-&gt;node))
3057             return(XML_READER_TYPE_SIGNIFICANT_WHITESPACE);
3058         else
3059             return(XML_READER_TYPE_WHITESPACE);
3060         } else {
3061         return(XML_READER_TYPE_TEXT);
3062         }
3063         case XML_CDATA_SECTION_NODE:
3064         return(XML_READER_TYPE_CDATA);
3065         case XML_ENTITY_REF_NODE:
3066         return(XML_READER_TYPE_ENTITY_REFERENCE);
3067         case XML_ENTITY_NODE:
3068         return(XML_READER_TYPE_ENTITY);
3069         case XML_PI_NODE:
3070         return(XML_READER_TYPE_PROCESSING_INSTRUCTION);
3071         case XML_COMMENT_NODE:
3072         return(XML_READER_TYPE_COMMENT);
3073         case XML_DOCUMENT_NODE:
3074         case XML_HTML_DOCUMENT_NODE:
3075 #ifdef LIBXML_DOCB_ENABLED
3076         case XML_DOCB_DOCUMENT_NODE:
3077 #endif
3078         return(XML_READER_TYPE_DOCUMENT);
3079         case XML_DOCUMENT_FRAG_NODE:
3080         return(XML_READER_TYPE_DOCUMENT_FRAGMENT);
3081         case XML_NOTATION_NODE:
3082         return(XML_READER_TYPE_NOTATION);
3083         case XML_DOCUMENT_TYPE_NODE:
3084         case XML_DTD_NODE:
3085         return(XML_READER_TYPE_DOCUMENT_TYPE);
3086 
3087         case XML_ELEMENT_DECL:
3088         case XML_ATTRIBUTE_DECL:
3089         case XML_ENTITY_DECL:
3090         case XML_XINCLUDE_START:
3091         case XML_XINCLUDE_END:
3092         return(XML_READER_TYPE_NONE);
3093     }
3094     return(-1);
3095 }
3096 
3097 /**
3098  * xmlTextReaderIsEmptyElement:
3099  * @reader:  the xmlTextReaderPtr used
3100  *
3101  * Check if the current node is empty
3102  *
3103  * Returns 1 if empty, 0 if not and -1 in case of error
3104  */
3105 int
3106 xmlTextReaderIsEmptyElement(xmlTextReaderPtr reader) {
3107     if ((reader == NULL) || (reader-&gt;node == NULL))
3108     return(-1);
3109     if (reader-&gt;node-&gt;type != XML_ELEMENT_NODE)
3110     return(0);
3111     if (reader-&gt;curnode != NULL)
3112     return(0);
3113     if (reader-&gt;node-&gt;children != NULL)
3114     return(0);
3115     if (reader-&gt;state == XML_TEXTREADER_END)
3116     return(0);
3117     if (reader-&gt;doc != NULL)
3118         return(1);
3119 #ifdef LIBXML_XINCLUDE_ENABLED
3120     if (reader-&gt;in_xinclude &gt; 0)
3121         return(1);
3122 #endif
3123     return((reader-&gt;node-&gt;extra &amp; NODE_IS_EMPTY) != 0);
3124 }
3125 
3126 /**
3127  * xmlTextReaderLocalName:
3128  * @reader:  the xmlTextReaderPtr used
3129  *
3130  * The local name of the node.
3131  *
3132  * Returns the local name or NULL if not available,
3133  *   if non NULL it need to be freed by the caller.
3134  */
3135 xmlChar *
3136 xmlTextReaderLocalName(xmlTextReaderPtr reader) {
3137     xmlNodePtr node;
3138     if ((reader == NULL) || (reader-&gt;node == NULL))
3139     return(NULL);
3140     if (reader-&gt;curnode != NULL)
3141     node = reader-&gt;curnode;
3142     else
3143     node = reader-&gt;node;
3144     if (node-&gt;type == XML_NAMESPACE_DECL) {
3145     xmlNsPtr ns = (xmlNsPtr) node;
3146     if (ns-&gt;prefix == NULL)
3147         return(xmlStrdup(BAD_CAST &quot;xmlns&quot;));
3148     else
3149         return(xmlStrdup(ns-&gt;prefix));
3150     }
3151     if ((node-&gt;type != XML_ELEMENT_NODE) &amp;&amp;
3152     (node-&gt;type != XML_ATTRIBUTE_NODE))
3153     return(xmlTextReaderName(reader));
3154     return(xmlStrdup(node-&gt;name));
3155 }
3156 
3157 /**
3158  * xmlTextReaderConstLocalName:
3159  * @reader:  the xmlTextReaderPtr used
3160  *
3161  * The local name of the node.
3162  *
3163  * Returns the local name or NULL if not available, the
3164  *         string will be deallocated with the reader.
3165  */
3166 const xmlChar *
3167 xmlTextReaderConstLocalName(xmlTextReaderPtr reader) {
3168     xmlNodePtr node;
3169     if ((reader == NULL) || (reader-&gt;node == NULL))
3170     return(NULL);
3171     if (reader-&gt;curnode != NULL)
3172     node = reader-&gt;curnode;
3173     else
3174     node = reader-&gt;node;
3175     if (node-&gt;type == XML_NAMESPACE_DECL) {
3176     xmlNsPtr ns = (xmlNsPtr) node;
3177     if (ns-&gt;prefix == NULL)
3178         return(CONSTSTR(BAD_CAST &quot;xmlns&quot;));
3179     else
3180         return(ns-&gt;prefix);
3181     }
3182     if ((node-&gt;type != XML_ELEMENT_NODE) &amp;&amp;
3183     (node-&gt;type != XML_ATTRIBUTE_NODE))
3184     return(xmlTextReaderConstName(reader));
3185     return(node-&gt;name);
3186 }
3187 
3188 /**
3189  * xmlTextReaderName:
3190  * @reader:  the xmlTextReaderPtr used
3191  *
3192  * The qualified name of the node, equal to Prefix :LocalName.
3193  *
3194  * Returns the local name or NULL if not available,
3195  *   if non NULL it need to be freed by the caller.
3196  */
3197 xmlChar *
3198 xmlTextReaderName(xmlTextReaderPtr reader) {
3199     xmlNodePtr node;
3200     xmlChar *ret;
3201 
3202     if ((reader == NULL) || (reader-&gt;node == NULL))
3203     return(NULL);
3204     if (reader-&gt;curnode != NULL)
3205     node = reader-&gt;curnode;
3206     else
3207     node = reader-&gt;node;
3208     switch (node-&gt;type) {
3209         case XML_ELEMENT_NODE:
3210         case XML_ATTRIBUTE_NODE:
3211         if ((node-&gt;ns == NULL) ||
3212         (node-&gt;ns-&gt;prefix == NULL))
3213         return(xmlStrdup(node-&gt;name));
3214 
3215         ret = xmlStrdup(node-&gt;ns-&gt;prefix);
3216         ret = xmlStrcat(ret, BAD_CAST &quot;:&quot;);
3217         ret = xmlStrcat(ret, node-&gt;name);
3218         return(ret);
3219         case XML_TEXT_NODE:
3220         return(xmlStrdup(BAD_CAST &quot;#text&quot;));
3221         case XML_CDATA_SECTION_NODE:
3222         return(xmlStrdup(BAD_CAST &quot;#cdata-section&quot;));
3223         case XML_ENTITY_NODE:
3224         case XML_ENTITY_REF_NODE:
3225         return(xmlStrdup(node-&gt;name));
3226         case XML_PI_NODE:
3227         return(xmlStrdup(node-&gt;name));
3228         case XML_COMMENT_NODE:
3229         return(xmlStrdup(BAD_CAST &quot;#comment&quot;));
3230         case XML_DOCUMENT_NODE:
3231         case XML_HTML_DOCUMENT_NODE:
3232 #ifdef LIBXML_DOCB_ENABLED
3233         case XML_DOCB_DOCUMENT_NODE:
3234 #endif
3235         return(xmlStrdup(BAD_CAST &quot;#document&quot;));
3236         case XML_DOCUMENT_FRAG_NODE:
3237         return(xmlStrdup(BAD_CAST &quot;#document-fragment&quot;));
3238         case XML_NOTATION_NODE:
3239         return(xmlStrdup(node-&gt;name));
3240         case XML_DOCUMENT_TYPE_NODE:
3241         case XML_DTD_NODE:
3242         return(xmlStrdup(node-&gt;name));
3243         case XML_NAMESPACE_DECL: {
3244         xmlNsPtr ns = (xmlNsPtr) node;
3245 
3246         ret = xmlStrdup(BAD_CAST &quot;xmlns&quot;);
3247         if (ns-&gt;prefix == NULL)
3248         return(ret);
3249         ret = xmlStrcat(ret, BAD_CAST &quot;:&quot;);
3250         ret = xmlStrcat(ret, ns-&gt;prefix);
3251         return(ret);
3252     }
3253 
3254         case XML_ELEMENT_DECL:
3255         case XML_ATTRIBUTE_DECL:
3256         case XML_ENTITY_DECL:
3257         case XML_XINCLUDE_START:
3258         case XML_XINCLUDE_END:
3259         return(NULL);
3260     }
3261     return(NULL);
3262 }
3263 
3264 /**
3265  * xmlTextReaderConstName:
3266  * @reader:  the xmlTextReaderPtr used
3267  *
3268  * The qualified name of the node, equal to Prefix :LocalName.
3269  *
3270  * Returns the local name or NULL if not available, the string is
3271  *         deallocated with the reader.
3272  */
3273 const xmlChar *
3274 xmlTextReaderConstName(xmlTextReaderPtr reader) {
3275     xmlNodePtr node;
3276 
3277     if ((reader == NULL) || (reader-&gt;node == NULL))
3278     return(NULL);
3279     if (reader-&gt;curnode != NULL)
3280     node = reader-&gt;curnode;
3281     else
3282     node = reader-&gt;node;
3283     switch (node-&gt;type) {
3284         case XML_ELEMENT_NODE:
3285         case XML_ATTRIBUTE_NODE:
3286         if ((node-&gt;ns == NULL) ||
3287         (node-&gt;ns-&gt;prefix == NULL))
3288         return(node-&gt;name);
3289         return(CONSTQSTR(node-&gt;ns-&gt;prefix, node-&gt;name));
3290         case XML_TEXT_NODE:
3291         return(CONSTSTR(BAD_CAST &quot;#text&quot;));
3292         case XML_CDATA_SECTION_NODE:
3293         return(CONSTSTR(BAD_CAST &quot;#cdata-section&quot;));
3294         case XML_ENTITY_NODE:
3295         case XML_ENTITY_REF_NODE:
3296         return(CONSTSTR(node-&gt;name));
3297         case XML_PI_NODE:
3298         return(CONSTSTR(node-&gt;name));
3299         case XML_COMMENT_NODE:
3300         return(CONSTSTR(BAD_CAST &quot;#comment&quot;));
3301         case XML_DOCUMENT_NODE:
3302         case XML_HTML_DOCUMENT_NODE:
3303 #ifdef LIBXML_DOCB_ENABLED
3304         case XML_DOCB_DOCUMENT_NODE:
3305 #endif
3306         return(CONSTSTR(BAD_CAST &quot;#document&quot;));
3307         case XML_DOCUMENT_FRAG_NODE:
3308         return(CONSTSTR(BAD_CAST &quot;#document-fragment&quot;));
3309         case XML_NOTATION_NODE:
3310         return(CONSTSTR(node-&gt;name));
3311         case XML_DOCUMENT_TYPE_NODE:
3312         case XML_DTD_NODE:
3313         return(CONSTSTR(node-&gt;name));
3314         case XML_NAMESPACE_DECL: {
3315         xmlNsPtr ns = (xmlNsPtr) node;
3316 
3317         if (ns-&gt;prefix == NULL)
3318         return(CONSTSTR(BAD_CAST &quot;xmlns&quot;));
3319         return(CONSTQSTR(BAD_CAST &quot;xmlns&quot;, ns-&gt;prefix));
3320     }
3321 
3322         case XML_ELEMENT_DECL:
3323         case XML_ATTRIBUTE_DECL:
3324         case XML_ENTITY_DECL:
3325         case XML_XINCLUDE_START:
3326         case XML_XINCLUDE_END:
3327         return(NULL);
3328     }
3329     return(NULL);
3330 }
3331 
3332 /**
3333  * xmlTextReaderPrefix:
3334  * @reader:  the xmlTextReaderPtr used
3335  *
3336  * A shorthand reference to the namespace associated with the node.
3337  *
3338  * Returns the prefix or NULL if not available,
3339  *    if non NULL it need to be freed by the caller.
3340  */
3341 xmlChar *
3342 xmlTextReaderPrefix(xmlTextReaderPtr reader) {
3343     xmlNodePtr node;
3344     if ((reader == NULL) || (reader-&gt;node == NULL))
3345     return(NULL);
3346     if (reader-&gt;curnode != NULL)
3347     node = reader-&gt;curnode;
3348     else
3349     node = reader-&gt;node;
3350     if (node-&gt;type == XML_NAMESPACE_DECL) {
3351     xmlNsPtr ns = (xmlNsPtr) node;
3352     if (ns-&gt;prefix == NULL)
3353         return(NULL);
3354     return(xmlStrdup(BAD_CAST &quot;xmlns&quot;));
3355     }
3356     if ((node-&gt;type != XML_ELEMENT_NODE) &amp;&amp;
3357     (node-&gt;type != XML_ATTRIBUTE_NODE))
3358     return(NULL);
3359     if ((node-&gt;ns != NULL) &amp;&amp; (node-&gt;ns-&gt;prefix != NULL))
3360     return(xmlStrdup(node-&gt;ns-&gt;prefix));
3361     return(NULL);
3362 }
3363 
3364 /**
3365  * xmlTextReaderConstPrefix:
3366  * @reader:  the xmlTextReaderPtr used
3367  *
3368  * A shorthand reference to the namespace associated with the node.
3369  *
3370  * Returns the prefix or NULL if not available, the string is deallocated
3371  *         with the reader.
3372  */
3373 const xmlChar *
3374 xmlTextReaderConstPrefix(xmlTextReaderPtr reader) {
3375     xmlNodePtr node;
3376     if ((reader == NULL) || (reader-&gt;node == NULL))
3377     return(NULL);
3378     if (reader-&gt;curnode != NULL)
3379     node = reader-&gt;curnode;
3380     else
3381     node = reader-&gt;node;
3382     if (node-&gt;type == XML_NAMESPACE_DECL) {
3383     xmlNsPtr ns = (xmlNsPtr) node;
3384     if (ns-&gt;prefix == NULL)
3385         return(NULL);
3386     return(CONSTSTR(BAD_CAST &quot;xmlns&quot;));
3387     }
3388     if ((node-&gt;type != XML_ELEMENT_NODE) &amp;&amp;
3389     (node-&gt;type != XML_ATTRIBUTE_NODE))
3390     return(NULL);
3391     if ((node-&gt;ns != NULL) &amp;&amp; (node-&gt;ns-&gt;prefix != NULL))
3392     return(CONSTSTR(node-&gt;ns-&gt;prefix));
3393     return(NULL);
3394 }
3395 
3396 /**
3397  * xmlTextReaderNamespaceUri:
3398  * @reader:  the xmlTextReaderPtr used
3399  *
3400  * The URI defining the namespace associated with the node.
3401  *
3402  * Returns the namespace URI or NULL if not available,
3403  *    if non NULL it need to be freed by the caller.
3404  */
3405 xmlChar *
3406 xmlTextReaderNamespaceUri(xmlTextReaderPtr reader) {
3407     xmlNodePtr node;
3408     if ((reader == NULL) || (reader-&gt;node == NULL))
3409     return(NULL);
3410     if (reader-&gt;curnode != NULL)
3411     node = reader-&gt;curnode;
3412     else
3413     node = reader-&gt;node;
3414     if (node-&gt;type == XML_NAMESPACE_DECL)
3415     return(xmlStrdup(BAD_CAST &quot;http://www.w3.org/2000/xmlns/&quot;));
3416     if ((node-&gt;type != XML_ELEMENT_NODE) &amp;&amp;
3417     (node-&gt;type != XML_ATTRIBUTE_NODE))
3418     return(NULL);
3419     if (node-&gt;ns != NULL)
3420     return(xmlStrdup(node-&gt;ns-&gt;href));
3421     return(NULL);
3422 }
3423 
3424 /**
3425  * xmlTextReaderConstNamespaceUri:
3426  * @reader:  the xmlTextReaderPtr used
3427  *
3428  * The URI defining the namespace associated with the node.
3429  *
3430  * Returns the namespace URI or NULL if not available, the string
3431  *         will be deallocated with the reader
3432  */
3433 const xmlChar *
3434 xmlTextReaderConstNamespaceUri(xmlTextReaderPtr reader) {
3435     xmlNodePtr node;
3436     if ((reader == NULL) || (reader-&gt;node == NULL))
3437     return(NULL);
3438     if (reader-&gt;curnode != NULL)
3439     node = reader-&gt;curnode;
3440     else
3441     node = reader-&gt;node;
3442     if (node-&gt;type == XML_NAMESPACE_DECL)
3443     return(CONSTSTR(BAD_CAST &quot;http://www.w3.org/2000/xmlns/&quot;));
3444     if ((node-&gt;type != XML_ELEMENT_NODE) &amp;&amp;
3445     (node-&gt;type != XML_ATTRIBUTE_NODE))
3446     return(NULL);
3447     if (node-&gt;ns != NULL)
3448     return(CONSTSTR(node-&gt;ns-&gt;href));
3449     return(NULL);
3450 }
3451 
3452 /**
3453  * xmlTextReaderBaseUri:
3454  * @reader:  the xmlTextReaderPtr used
3455  *
3456  * The base URI of the node.
3457  *
3458  * Returns the base URI or NULL if not available,
3459  *    if non NULL it need to be freed by the caller.
3460  */
3461 xmlChar *
3462 xmlTextReaderBaseUri(xmlTextReaderPtr reader) {
3463     if ((reader == NULL) || (reader-&gt;node == NULL))
3464     return(NULL);
3465     return(xmlNodeGetBase(NULL, reader-&gt;node));
3466 }
3467 
3468 /**
3469  * xmlTextReaderConstBaseUri:
3470  * @reader:  the xmlTextReaderPtr used
3471  *
3472  * The base URI of the node.
3473  *
3474  * Returns the base URI or NULL if not available, the string
3475  *         will be deallocated with the reader
3476  */
3477 const xmlChar *
3478 xmlTextReaderConstBaseUri(xmlTextReaderPtr reader) {
3479     xmlChar *tmp;
3480     const xmlChar *ret;
3481 
3482     if ((reader == NULL) || (reader-&gt;node == NULL))
3483     return(NULL);
3484     tmp = xmlNodeGetBase(NULL, reader-&gt;node);
3485     if (tmp == NULL)
3486         return(NULL);
3487     ret = CONSTSTR(tmp);
3488     xmlFree(tmp);
3489     return(ret);
3490 }
3491 
3492 /**
3493  * xmlTextReaderDepth:
3494  * @reader:  the xmlTextReaderPtr used
3495  *
3496  * The depth of the node in the tree.
3497  *
3498  * Returns the depth or -1 in case of error
3499  */
3500 int
3501 xmlTextReaderDepth(xmlTextReaderPtr reader) {
3502     if (reader == NULL)
3503     return(-1);
3504     if (reader-&gt;node == NULL)
3505     return(0);
3506 
3507     if (reader-&gt;curnode != NULL) {
3508     if ((reader-&gt;curnode-&gt;type == XML_ATTRIBUTE_NODE) ||
3509         (reader-&gt;curnode-&gt;type == XML_NAMESPACE_DECL))
3510         return(reader-&gt;depth + 1);
3511     return(reader-&gt;depth + 2);
3512     }
3513     return(reader-&gt;depth);
3514 }
3515 
3516 /**
3517  * xmlTextReaderHasAttributes:
3518  * @reader:  the xmlTextReaderPtr used
3519  *
3520  * Whether the node has attributes.
3521  *
3522  * Returns 1 if true, 0 if false, and -1 in case or error
3523  */
3524 int
3525 xmlTextReaderHasAttributes(xmlTextReaderPtr reader) {
3526     xmlNodePtr node;
3527     if (reader == NULL)
3528     return(-1);
3529     if (reader-&gt;node == NULL)
3530     return(0);
3531     if (reader-&gt;curnode != NULL)
3532     node = reader-&gt;curnode;
3533     else
3534     node = reader-&gt;node;
3535 
3536     if ((node-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
3537     ((node-&gt;properties != NULL) || (node-&gt;nsDef != NULL)))
3538     return(1);
3539     /* TODO: handle the xmlDecl */
3540     return(0);
3541 }
3542 
3543 /**
3544  * xmlTextReaderHasValue:
3545  * @reader:  the xmlTextReaderPtr used
3546  *
3547  * Whether the node can have a text value.
3548  *
3549  * Returns 1 if true, 0 if false, and -1 in case or error
3550  */
3551 int
3552 xmlTextReaderHasValue(xmlTextReaderPtr reader) {
3553     xmlNodePtr node;
3554     if (reader == NULL)
3555     return(-1);
3556     if (reader-&gt;node == NULL)
3557     return(0);
3558     if (reader-&gt;curnode != NULL)
3559     node = reader-&gt;curnode;
3560     else
3561     node = reader-&gt;node;
3562 
3563     switch (node-&gt;type) {
3564         case XML_ATTRIBUTE_NODE:
3565         case XML_TEXT_NODE:
3566         case XML_CDATA_SECTION_NODE:
3567         case XML_PI_NODE:
3568         case XML_COMMENT_NODE:
3569         case XML_NAMESPACE_DECL:
3570         return(1);
3571     default:
3572         break;
3573     }
3574     return(0);
3575 }
3576 
3577 /**
3578  * xmlTextReaderValue:
3579  * @reader:  the xmlTextReaderPtr used
3580  *
3581  * Provides the text value of the node if present
3582  *
3583  * Returns the string or NULL if not available. The result must be deallocated
3584  *     with xmlFree()
3585  */
3586 xmlChar *
3587 xmlTextReaderValue(xmlTextReaderPtr reader) {
3588     xmlNodePtr node;
3589     if (reader == NULL)
3590     return(NULL);
3591     if (reader-&gt;node == NULL)
3592     return(NULL);
3593     if (reader-&gt;curnode != NULL)
3594     node = reader-&gt;curnode;
3595     else
3596     node = reader-&gt;node;
3597 
3598     switch (node-&gt;type) {
3599         case XML_NAMESPACE_DECL:
3600         return(xmlStrdup(((xmlNsPtr) node)-&gt;href));
3601         case XML_ATTRIBUTE_NODE:{
3602         xmlAttrPtr attr = (xmlAttrPtr) node;
3603 
3604         if (attr-&gt;parent != NULL)
3605         return (xmlNodeListGetString
3606             (attr-&gt;parent-&gt;doc, attr-&gt;children, 1));
3607         else
3608         return (xmlNodeListGetString(NULL, attr-&gt;children, 1));
3609         break;
3610     }
3611         case XML_TEXT_NODE:
3612         case XML_CDATA_SECTION_NODE:
3613         case XML_PI_NODE:
3614         case XML_COMMENT_NODE:
3615             if (node-&gt;content != NULL)
3616                 return (xmlStrdup(node-&gt;content));
3617     default:
3618         break;
3619     }
3620     return(NULL);
3621 }
3622 
3623 /**
3624  * xmlTextReaderConstValue:
3625  * @reader:  the xmlTextReaderPtr used
3626  *
3627  * Provides the text value of the node if present
3628  *
3629  * Returns the string or NULL if not available. The result will be
3630  *     deallocated on the next Read() operation.
3631  */
3632 const xmlChar *
3633 xmlTextReaderConstValue(xmlTextReaderPtr reader) {
3634     xmlNodePtr node;
3635     if (reader == NULL)
3636     return(NULL);
3637     if (reader-&gt;node == NULL)
3638     return(NULL);
3639     if (reader-&gt;curnode != NULL)
3640     node = reader-&gt;curnode;
3641     else
3642     node = reader-&gt;node;
3643 
3644     switch (node-&gt;type) {
3645         case XML_NAMESPACE_DECL:
3646         return(((xmlNsPtr) node)-&gt;href);
3647         case XML_ATTRIBUTE_NODE:{
3648         xmlAttrPtr attr = (xmlAttrPtr) node;
3649         const xmlChar *ret;
3650 
3651         if ((attr-&gt;children != NULL) &amp;&amp;
3652             (attr-&gt;children-&gt;type == XML_TEXT_NODE) &amp;&amp;
3653         (attr-&gt;children-&gt;next == NULL))
3654         return(attr-&gt;children-&gt;content);
3655         else {
3656         if (reader-&gt;buffer == NULL) {
3657             reader-&gt;buffer = xmlBufCreateSize(100);
3658                     if (reader-&gt;buffer == NULL) {
3659                         xmlGenericError(xmlGenericErrorContext,
3660                                         &quot;xmlTextReaderSetup : malloc failed\n&quot;);
3661                         return (NULL);
3662                     }
3663             xmlBufSetAllocationScheme(reader-&gt;buffer,
3664                                       XML_BUFFER_ALLOC_BOUNDED);
3665                 } else
3666                     xmlBufEmpty(reader-&gt;buffer);
3667             xmlBufGetNodeContent(reader-&gt;buffer, node);
3668         ret = xmlBufContent(reader-&gt;buffer);
3669         if (ret == NULL) {
3670             /* error on the buffer best to reallocate */
3671             xmlBufFree(reader-&gt;buffer);
3672             reader-&gt;buffer = xmlBufCreateSize(100);
3673             xmlBufSetAllocationScheme(reader-&gt;buffer,
3674                                       XML_BUFFER_ALLOC_BOUNDED);
3675             ret = BAD_CAST &quot;&quot;;
3676         }
3677         return(ret);
3678         }
3679         break;
3680     }
3681         case XML_TEXT_NODE:
3682         case XML_CDATA_SECTION_NODE:
3683         case XML_PI_NODE:
3684         case XML_COMMENT_NODE:
3685         return(node-&gt;content);
3686     default:
3687         break;
3688     }
3689     return(NULL);
3690 }
3691 
3692 /**
3693  * xmlTextReaderIsDefault:
3694  * @reader:  the xmlTextReaderPtr used
3695  *
3696  * Whether an Attribute  node was generated from the default value
3697  * defined in the DTD or schema.
3698  *
3699  * Returns 0 if not defaulted, 1 if defaulted, and -1 in case of error
3700  */
3701 int
3702 xmlTextReaderIsDefault(xmlTextReaderPtr reader) {
3703     if (reader == NULL)
3704     return(-1);
3705     return(0);
3706 }
3707 
3708 /**
3709  * xmlTextReaderQuoteChar:
3710  * @reader:  the xmlTextReaderPtr used
3711  *
3712  * The quotation mark character used to enclose the value of an attribute.
3713  *
3714  * Returns &quot; or &#39; and -1 in case of error
3715  */
3716 int
3717 xmlTextReaderQuoteChar(xmlTextReaderPtr reader) {
3718     if (reader == NULL)
3719     return(-1);
3720     /* TODO maybe lookup the attribute value for &quot; first */
3721     return((int) &#39;&quot;&#39;);
3722 }
3723 
3724 /**
3725  * xmlTextReaderXmlLang:
3726  * @reader:  the xmlTextReaderPtr used
3727  *
3728  * The xml:lang scope within which the node resides.
3729  *
3730  * Returns the xml:lang value or NULL if none exists.,
3731  *    if non NULL it need to be freed by the caller.
3732  */
3733 xmlChar *
3734 xmlTextReaderXmlLang(xmlTextReaderPtr reader) {
3735     if (reader == NULL)
3736     return(NULL);
3737     if (reader-&gt;node == NULL)
3738     return(NULL);
3739     return(xmlNodeGetLang(reader-&gt;node));
3740 }
3741 
3742 /**
3743  * xmlTextReaderConstXmlLang:
3744  * @reader:  the xmlTextReaderPtr used
3745  *
3746  * The xml:lang scope within which the node resides.
3747  *
3748  * Returns the xml:lang value or NULL if none exists.
3749  */
3750 const xmlChar *
3751 xmlTextReaderConstXmlLang(xmlTextReaderPtr reader) {
3752     xmlChar *tmp;
3753     const xmlChar *ret;
3754 
3755     if (reader == NULL)
3756     return(NULL);
3757     if (reader-&gt;node == NULL)
3758     return(NULL);
3759     tmp = xmlNodeGetLang(reader-&gt;node);
3760     if (tmp == NULL)
3761         return(NULL);
3762     ret = CONSTSTR(tmp);
3763     xmlFree(tmp);
3764     return(ret);
3765 }
3766 
3767 /**
3768  * xmlTextReaderConstString:
3769  * @reader:  the xmlTextReaderPtr used
3770  * @str:  the string to intern.
3771  *
3772  * Get an interned string from the reader, allows for example to
3773  * speedup string name comparisons
3774  *
3775  * Returns an interned copy of the string or NULL in case of error. The
3776  *         string will be deallocated with the reader.
3777  */
3778 const xmlChar *
3779 xmlTextReaderConstString(xmlTextReaderPtr reader, const xmlChar *str) {
3780     if (reader == NULL)
3781     return(NULL);
3782     return(CONSTSTR(str));
3783 }
3784 
3785 /**
3786  * xmlTextReaderNormalization:
3787  * @reader:  the xmlTextReaderPtr used
3788  *
3789  * The value indicating whether to normalize white space and attribute values.
3790  * Since attribute value and end of line normalizations are a MUST in the XML
3791  * specification only the value true is accepted. The broken bahaviour of
3792  * accepting out of range character entities like &amp;#0; is of course not
3793  * supported either.
3794  *
3795  * Returns 1 or -1 in case of error.
3796  */
3797 int
3798 xmlTextReaderNormalization(xmlTextReaderPtr reader) {
3799     if (reader == NULL)
3800     return(-1);
3801     return(1);
3802 }
3803 
3804 /************************************************************************
3805  *                                  *
3806  *          Extensions to the base APIs         *
3807  *                                  *
3808  ************************************************************************/
3809 
3810 /**
3811  * xmlTextReaderSetParserProp:
3812  * @reader:  the xmlTextReaderPtr used
3813  * @prop:  the xmlParserProperties to set
3814  * @value:  usually 0 or 1 to (de)activate it
3815  *
3816  * Change the parser processing behaviour by changing some of its internal
3817  * properties. Note that some properties can only be changed before any
3818  * read has been done.
3819  *
3820  * Returns 0 if the call was successful, or -1 in case of error
3821  */
3822 int
3823 xmlTextReaderSetParserProp(xmlTextReaderPtr reader, int prop, int value) {
3824     xmlParserProperties p = (xmlParserProperties) prop;
3825     xmlParserCtxtPtr ctxt;
3826 
3827     if ((reader == NULL) || (reader-&gt;ctxt == NULL))
3828     return(-1);
3829     ctxt = reader-&gt;ctxt;
3830 
3831     switch (p) {
3832         case XML_PARSER_LOADDTD:
3833         if (value != 0) {
3834         if (ctxt-&gt;loadsubset == 0) {
3835             if (reader-&gt;mode != XML_TEXTREADER_MODE_INITIAL)
3836             return(-1);
3837             ctxt-&gt;loadsubset = XML_DETECT_IDS;
3838         }
3839         } else {
3840         ctxt-&gt;loadsubset = 0;
3841         }
3842         return(0);
3843         case XML_PARSER_DEFAULTATTRS:
3844         if (value != 0) {
3845         ctxt-&gt;loadsubset |= XML_COMPLETE_ATTRS;
3846         } else {
3847         if (ctxt-&gt;loadsubset &amp; XML_COMPLETE_ATTRS)
3848             ctxt-&gt;loadsubset -= XML_COMPLETE_ATTRS;
3849         }
3850         return(0);
3851         case XML_PARSER_VALIDATE:
3852         if (value != 0) {
3853         ctxt-&gt;validate = 1;
3854         reader-&gt;validate = XML_TEXTREADER_VALIDATE_DTD;
3855         } else {
3856         ctxt-&gt;validate = 0;
3857         }
3858         return(0);
3859         case XML_PARSER_SUBST_ENTITIES:
3860         if (value != 0) {
3861         ctxt-&gt;replaceEntities = 1;
3862         } else {
3863         ctxt-&gt;replaceEntities = 0;
3864         }
3865         return(0);
3866     }
3867     return(-1);
3868 }
3869 
3870 /**
3871  * xmlTextReaderGetParserProp:
3872  * @reader:  the xmlTextReaderPtr used
3873  * @prop:  the xmlParserProperties to get
3874  *
3875  * Read the parser internal property.
3876  *
3877  * Returns the value, usually 0 or 1, or -1 in case of error.
3878  */
3879 int
3880 xmlTextReaderGetParserProp(xmlTextReaderPtr reader, int prop) {
3881     xmlParserProperties p = (xmlParserProperties) prop;
3882     xmlParserCtxtPtr ctxt;
3883 
3884     if ((reader == NULL) || (reader-&gt;ctxt == NULL))
3885     return(-1);
3886     ctxt = reader-&gt;ctxt;
3887 
3888     switch (p) {
3889         case XML_PARSER_LOADDTD:
3890         if ((ctxt-&gt;loadsubset != 0) || (ctxt-&gt;validate != 0))
3891         return(1);
3892         return(0);
3893         case XML_PARSER_DEFAULTATTRS:
3894         if (ctxt-&gt;loadsubset &amp; XML_COMPLETE_ATTRS)
3895         return(1);
3896         return(0);
3897         case XML_PARSER_VALIDATE:
3898         return(reader-&gt;validate);
3899     case XML_PARSER_SUBST_ENTITIES:
3900         return(ctxt-&gt;replaceEntities);
3901     }
3902     return(-1);
3903 }
3904 
3905 
3906 /**
3907  * xmlTextReaderGetParserLineNumber:
3908  * @reader: the user data (XML reader context)
3909  *
3910  * Provide the line number of the current parsing point.
3911  *
3912  * Returns an int or 0 if not available
3913  */
3914 int
3915 xmlTextReaderGetParserLineNumber(xmlTextReaderPtr reader)
3916 {
3917     if ((reader == NULL) || (reader-&gt;ctxt == NULL) ||
3918         (reader-&gt;ctxt-&gt;input == NULL)) {
3919         return (0);
3920     }
3921     return (reader-&gt;ctxt-&gt;input-&gt;line);
3922 }
3923 
3924 /**
3925  * xmlTextReaderGetParserColumnNumber:
3926  * @reader: the user data (XML reader context)
3927  *
3928  * Provide the column number of the current parsing point.
3929  *
3930  * Returns an int or 0 if not available
3931  */
3932 int
3933 xmlTextReaderGetParserColumnNumber(xmlTextReaderPtr reader)
3934 {
3935     if ((reader == NULL) || (reader-&gt;ctxt == NULL) ||
3936         (reader-&gt;ctxt-&gt;input == NULL)) {
3937         return (0);
3938     }
3939     return (reader-&gt;ctxt-&gt;input-&gt;col);
3940 }
3941 
3942 /**
3943  * xmlTextReaderCurrentNode:
3944  * @reader:  the xmlTextReaderPtr used
3945  *
<a name="25" id="anc25"></a><span class="line-modified">3946  * Hacking interface allowing to get the xmlNodePtr corresponding to the</span>
3947  * current node being accessed by the xmlTextReader. This is dangerous
3948  * because the underlying node may be destroyed on the next Reads.
3949  *
3950  * Returns the xmlNodePtr or NULL in case of error.
3951  */
3952 xmlNodePtr
3953 xmlTextReaderCurrentNode(xmlTextReaderPtr reader) {
3954     if (reader == NULL)
3955     return(NULL);
3956 
3957     if (reader-&gt;curnode != NULL)
3958     return(reader-&gt;curnode);
3959     return(reader-&gt;node);
3960 }
3961 
3962 /**
3963  * xmlTextReaderPreserve:
3964  * @reader:  the xmlTextReaderPtr used
3965  *
3966  * This tells the XML Reader to preserve the current node.
3967  * The caller must also use xmlTextReaderCurrentDoc() to
3968  * keep an handle on the resulting document once parsing has finished
3969  *
3970  * Returns the xmlNodePtr or NULL in case of error.
3971  */
3972 xmlNodePtr
3973 xmlTextReaderPreserve(xmlTextReaderPtr reader) {
3974     xmlNodePtr cur, parent;
3975 
3976     if (reader == NULL)
3977     return(NULL);
3978 
3979     if (reader-&gt;curnode != NULL)
3980         cur = reader-&gt;curnode;
3981     else
3982         cur = reader-&gt;node;
3983     if (cur == NULL)
3984         return(NULL);
3985 
3986     if ((cur-&gt;type != XML_DOCUMENT_NODE) &amp;&amp; (cur-&gt;type != XML_DTD_NODE)) {
3987     cur-&gt;extra |= NODE_IS_PRESERVED;
3988     cur-&gt;extra |= NODE_IS_SPRESERVED;
3989     }
3990     reader-&gt;preserves++;
3991 
3992     parent = cur-&gt;parent;;
3993     while (parent != NULL) {
3994         if (parent-&gt;type == XML_ELEMENT_NODE)
3995         parent-&gt;extra |= NODE_IS_PRESERVED;
3996     parent = parent-&gt;parent;
3997     }
3998     return(cur);
3999 }
4000 
4001 #ifdef LIBXML_PATTERN_ENABLED
4002 /**
4003  * xmlTextReaderPreservePattern:
4004  * @reader:  the xmlTextReaderPtr used
4005  * @pattern:  an XPath subset pattern
4006  * @namespaces: the prefix definitions, array of [URI, prefix] or NULL
4007  *
4008  * This tells the XML Reader to preserve all nodes matched by the
4009  * pattern. The caller must also use xmlTextReaderCurrentDoc() to
4010  * keep an handle on the resulting document once parsing has finished
4011  *
4012  * Returns a non-negative number in case of success and -1 in case of error
4013  */
4014 int
4015 xmlTextReaderPreservePattern(xmlTextReaderPtr reader, const xmlChar *pattern,
4016                              const xmlChar **namespaces)
4017 {
4018     xmlPatternPtr comp;
4019 
4020     if ((reader == NULL) || (pattern == NULL))
4021     return(-1);
4022 
4023     comp = xmlPatterncompile(pattern, reader-&gt;dict, 0, namespaces);
4024     if (comp == NULL)
4025         return(-1);
4026 
4027     if (reader-&gt;patternMax &lt;= 0) {
4028     reader-&gt;patternMax = 4;
4029     reader-&gt;patternTab = (xmlPatternPtr *) xmlMalloc(reader-&gt;patternMax *
4030                           sizeof(reader-&gt;patternTab[0]));
4031         if (reader-&gt;patternTab == NULL) {
4032             xmlGenericError(xmlGenericErrorContext, &quot;xmlMalloc failed !\n&quot;);
4033             return (-1);
4034         }
4035     }
4036     if (reader-&gt;patternNr &gt;= reader-&gt;patternMax) {
4037         xmlPatternPtr *tmp;
4038         reader-&gt;patternMax *= 2;
4039     tmp = (xmlPatternPtr *) xmlRealloc(reader-&gt;patternTab,
4040                                       reader-&gt;patternMax *
4041                                       sizeof(reader-&gt;patternTab[0]));
4042         if (tmp == NULL) {
4043             xmlGenericError(xmlGenericErrorContext, &quot;xmlRealloc failed !\n&quot;);
4044         reader-&gt;patternMax /= 2;
4045             return (-1);
4046         }
4047     reader-&gt;patternTab = tmp;
4048     }
4049     reader-&gt;patternTab[reader-&gt;patternNr] = comp;
4050     return(reader-&gt;patternNr++);
4051 }
4052 #endif
4053 
4054 /**
4055  * xmlTextReaderCurrentDoc:
4056  * @reader:  the xmlTextReaderPtr used
4057  *
<a name="26" id="anc26"></a><span class="line-modified">4058  * Hacking interface allowing to get the xmlDocPtr corresponding to the</span>
4059  * current document being accessed by the xmlTextReader.
4060  * NOTE: as a result of this call, the reader will not destroy the
4061  *       associated XML document and calling xmlFreeDoc() on the result
4062  *       is needed once the reader parsing has finished.
4063  *
4064  * Returns the xmlDocPtr or NULL in case of error.
4065  */
4066 xmlDocPtr
4067 xmlTextReaderCurrentDoc(xmlTextReaderPtr reader) {
4068     if (reader == NULL)
4069     return(NULL);
4070     if (reader-&gt;doc != NULL)
4071         return(reader-&gt;doc);
4072     if ((reader-&gt;ctxt == NULL) || (reader-&gt;ctxt-&gt;myDoc == NULL))
4073     return(NULL);
4074 
4075     reader-&gt;preserve = 1;
4076     return(reader-&gt;ctxt-&gt;myDoc);
4077 }
4078 
4079 #ifdef LIBXML_SCHEMAS_ENABLED
4080 static char *xmlTextReaderBuildMessage(const char *msg, va_list ap) LIBXML_ATTR_FORMAT(1,0);
4081 
4082 static void XMLCDECL
4083 xmlTextReaderValidityError(void *ctxt, const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);
4084 
4085 static void XMLCDECL
4086 xmlTextReaderValidityWarning(void *ctxt, const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);
4087 
4088 static void XMLCDECL
4089 xmlTextReaderValidityErrorRelay(void *ctx, const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);
4090 
4091 static void XMLCDECL
4092 xmlTextReaderValidityWarningRelay(void *ctx, const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);
4093 
4094 static void XMLCDECL
4095 xmlTextReaderValidityErrorRelay(void *ctx, const char *msg, ...)
4096 {
4097     xmlTextReaderPtr reader = (xmlTextReaderPtr) ctx;
4098 
4099     char *str;
4100 
4101     va_list ap;
4102 
4103     va_start(ap, msg);
4104     str = xmlTextReaderBuildMessage(msg, ap);
4105     if (!reader-&gt;errorFunc) {
4106         xmlTextReaderValidityError(ctx, &quot;%s&quot;, str);
4107     } else {
4108         reader-&gt;errorFunc(reader-&gt;errorFuncArg, str,
4109                           XML_PARSER_SEVERITY_VALIDITY_ERROR,
4110                           NULL /* locator */ );
4111     }
4112     if (str != NULL)
4113         xmlFree(str);
4114     va_end(ap);
4115 }
4116 
4117 static void XMLCDECL
4118 xmlTextReaderValidityWarningRelay(void *ctx, const char *msg, ...)
4119 {
4120     xmlTextReaderPtr reader = (xmlTextReaderPtr) ctx;
4121 
4122     char *str;
4123 
4124     va_list ap;
4125 
4126     va_start(ap, msg);
4127     str = xmlTextReaderBuildMessage(msg, ap);
4128     if (!reader-&gt;errorFunc) {
4129         xmlTextReaderValidityWarning(ctx, &quot;%s&quot;, str);
4130     } else {
4131         reader-&gt;errorFunc(reader-&gt;errorFuncArg, str,
4132                           XML_PARSER_SEVERITY_VALIDITY_WARNING,
4133                           NULL /* locator */ );
4134     }
4135     if (str != NULL)
4136         xmlFree(str);
4137     va_end(ap);
4138 }
4139 
4140 static void
4141   xmlTextReaderStructuredError(void *ctxt, xmlErrorPtr error);
4142 
4143 static void
4144 xmlTextReaderValidityStructuredRelay(void *userData, xmlErrorPtr error)
4145 {
4146     xmlTextReaderPtr reader = (xmlTextReaderPtr) userData;
4147 
4148     if (reader-&gt;sErrorFunc) {
4149         reader-&gt;sErrorFunc(reader-&gt;errorFuncArg, error);
4150     } else {
4151         xmlTextReaderStructuredError(reader, error);
4152     }
4153 }
4154 /**
4155  * xmlTextReaderRelaxNGSetSchema:
4156  * @reader:  the xmlTextReaderPtr used
4157  * @schema:  a precompiled RelaxNG schema
4158  *
4159  * Use RelaxNG to validate the document as it is processed.
4160  * Activation is only possible before the first Read().
<a name="27" id="anc27"></a><span class="line-modified">4161  * if @schema is NULL, then RelaxNG validation is deactivated.</span>
4162  @ The @schema should not be freed until the reader is deallocated
4163  * or its use has been deactivated.
4164  *
<a name="28" id="anc28"></a><span class="line-modified">4165  * Returns 0 in case the RelaxNG validation could be (de)activated and</span>
4166  *         -1 in case of error.
4167  */
4168 int
4169 xmlTextReaderRelaxNGSetSchema(xmlTextReaderPtr reader, xmlRelaxNGPtr schema) {
4170     if (reader == NULL)
4171         return(-1);
4172     if (schema == NULL) {
4173         if (reader-&gt;rngSchemas != NULL) {
4174         xmlRelaxNGFree(reader-&gt;rngSchemas);
4175         reader-&gt;rngSchemas = NULL;
4176     }
4177         if (reader-&gt;rngValidCtxt != NULL) {
4178         if (! reader-&gt;rngPreserveCtxt)
4179         xmlRelaxNGFreeValidCtxt(reader-&gt;rngValidCtxt);
4180         reader-&gt;rngValidCtxt = NULL;
4181         }
4182     reader-&gt;rngPreserveCtxt = 0;
4183     return(0);
4184     }
4185     if (reader-&gt;mode != XML_TEXTREADER_MODE_INITIAL)
4186     return(-1);
4187     if (reader-&gt;rngSchemas != NULL) {
4188     xmlRelaxNGFree(reader-&gt;rngSchemas);
4189     reader-&gt;rngSchemas = NULL;
4190     }
4191     if (reader-&gt;rngValidCtxt != NULL) {
4192     if (! reader-&gt;rngPreserveCtxt)
4193         xmlRelaxNGFreeValidCtxt(reader-&gt;rngValidCtxt);
4194     reader-&gt;rngValidCtxt = NULL;
4195     }
4196     reader-&gt;rngPreserveCtxt = 0;
4197     reader-&gt;rngValidCtxt = xmlRelaxNGNewValidCtxt(schema);
4198     if (reader-&gt;rngValidCtxt == NULL)
4199         return(-1);
4200     if (reader-&gt;errorFunc != NULL) {
4201     xmlRelaxNGSetValidErrors(reader-&gt;rngValidCtxt,
4202             xmlTextReaderValidityErrorRelay,
4203             xmlTextReaderValidityWarningRelay,
4204             reader);
4205     }
4206     if (reader-&gt;sErrorFunc != NULL) {
4207         xmlRelaxNGSetValidStructuredErrors(reader-&gt;rngValidCtxt,
4208             xmlTextReaderValidityStructuredRelay,
4209             reader);
4210     }
4211     reader-&gt;rngValidErrors = 0;
4212     reader-&gt;rngFullNode = NULL;
4213     reader-&gt;validate = XML_TEXTREADER_VALIDATE_RNG;
4214     return(0);
4215 }
4216 
4217 /**
4218  * xmlTextReaderLocator:
4219  * @ctx: the xmlTextReaderPtr used
4220  * @file: returned file information
4221  * @line: returned line information
4222  *
4223  * Internal locator function for the readers
4224  *
<a name="29" id="anc29"></a><span class="line-modified">4225  * Returns 0 in case the Schema validation could be (de)activated and</span>
4226  *         -1 in case of error.
4227  */
4228 static int
4229 xmlTextReaderLocator(void *ctx, const char **file, unsigned long *line) {
4230     xmlTextReaderPtr reader;
4231 
4232     if ((ctx == NULL) || ((file == NULL) &amp;&amp; (line == NULL)))
4233         return(-1);
4234 
4235     if (file != NULL)
4236         *file = NULL;
4237     if (line != NULL)
4238         *line = 0;
4239 
4240     reader = (xmlTextReaderPtr) ctx;
4241     if ((reader-&gt;ctxt != NULL) &amp;&amp; (reader-&gt;ctxt-&gt;input != NULL)) {
4242     if (file != NULL)
4243         *file = reader-&gt;ctxt-&gt;input-&gt;filename;
4244     if (line != NULL)
4245         *line = reader-&gt;ctxt-&gt;input-&gt;line;
4246     return(0);
4247     }
4248     if (reader-&gt;node != NULL) {
4249         long res;
4250     int ret = 0;
4251 
4252     if (line != NULL) {
4253         res = xmlGetLineNo(reader-&gt;node);
4254         if (res &gt; 0)
4255             *line = (unsigned long) res;
4256         else
4257                 ret = -1;
4258     }
4259         if (file != NULL) {
4260         xmlDocPtr doc = reader-&gt;node-&gt;doc;
4261         if ((doc != NULL) &amp;&amp; (doc-&gt;URL != NULL))
4262             *file = (const char *) doc-&gt;URL;
4263         else
4264                 ret = -1;
4265     }
4266     return(ret);
4267     }
4268     return(-1);
4269 }
4270 
4271 /**
4272  * xmlTextReaderSetSchema:
4273  * @reader:  the xmlTextReaderPtr used
4274  * @schema:  a precompiled Schema schema
4275  *
4276  * Use XSD Schema to validate the document as it is processed.
4277  * Activation is only possible before the first Read().
<a name="30" id="anc30"></a><span class="line-modified">4278  * if @schema is NULL, then Schema validation is deactivated.</span>
<span class="line-modified">4279  * The @schema should not be freed until the reader is deallocated</span>
4280  * or its use has been deactivated.
4281  *
<a name="31" id="anc31"></a><span class="line-modified">4282  * Returns 0 in case the Schema validation could be (de)activated and</span>
4283  *         -1 in case of error.
4284  */
4285 int
4286 xmlTextReaderSetSchema(xmlTextReaderPtr reader, xmlSchemaPtr schema) {
4287     if (reader == NULL)
4288         return(-1);
4289     if (schema == NULL) {
4290     if (reader-&gt;xsdPlug != NULL) {
4291         xmlSchemaSAXUnplug(reader-&gt;xsdPlug);
4292         reader-&gt;xsdPlug = NULL;
4293     }
4294         if (reader-&gt;xsdValidCtxt != NULL) {
4295         if (! reader-&gt;xsdPreserveCtxt)
4296         xmlSchemaFreeValidCtxt(reader-&gt;xsdValidCtxt);
4297         reader-&gt;xsdValidCtxt = NULL;
4298         }
4299     reader-&gt;xsdPreserveCtxt = 0;
4300         if (reader-&gt;xsdSchemas != NULL) {
4301         xmlSchemaFree(reader-&gt;xsdSchemas);
4302         reader-&gt;xsdSchemas = NULL;
4303     }
4304     return(0);
4305     }
4306     if (reader-&gt;mode != XML_TEXTREADER_MODE_INITIAL)
4307     return(-1);
4308     if (reader-&gt;xsdPlug != NULL) {
4309     xmlSchemaSAXUnplug(reader-&gt;xsdPlug);
4310     reader-&gt;xsdPlug = NULL;
4311     }
4312     if (reader-&gt;xsdValidCtxt != NULL) {
4313     if (! reader-&gt;xsdPreserveCtxt)
4314         xmlSchemaFreeValidCtxt(reader-&gt;xsdValidCtxt);
4315     reader-&gt;xsdValidCtxt = NULL;
4316     }
4317     reader-&gt;xsdPreserveCtxt = 0;
4318     if (reader-&gt;xsdSchemas != NULL) {
4319     xmlSchemaFree(reader-&gt;xsdSchemas);
4320     reader-&gt;xsdSchemas = NULL;
4321     }
4322     reader-&gt;xsdValidCtxt = xmlSchemaNewValidCtxt(schema);
4323     if (reader-&gt;xsdValidCtxt == NULL) {
4324     xmlSchemaFree(reader-&gt;xsdSchemas);
4325     reader-&gt;xsdSchemas = NULL;
4326         return(-1);
4327     }
4328     reader-&gt;xsdPlug = xmlSchemaSAXPlug(reader-&gt;xsdValidCtxt,
4329                                        &amp;(reader-&gt;ctxt-&gt;sax),
4330                        &amp;(reader-&gt;ctxt-&gt;userData));
4331     if (reader-&gt;xsdPlug == NULL) {
4332     xmlSchemaFree(reader-&gt;xsdSchemas);
4333     reader-&gt;xsdSchemas = NULL;
4334     xmlSchemaFreeValidCtxt(reader-&gt;xsdValidCtxt);
4335     reader-&gt;xsdValidCtxt = NULL;
4336     return(-1);
4337     }
4338     xmlSchemaValidateSetLocator(reader-&gt;xsdValidCtxt,
4339                                 xmlTextReaderLocator,
4340                 (void *) reader);
4341 
4342     if (reader-&gt;errorFunc != NULL) {
4343     xmlSchemaSetValidErrors(reader-&gt;xsdValidCtxt,
4344             xmlTextReaderValidityErrorRelay,
4345             xmlTextReaderValidityWarningRelay,
4346             reader);
4347     }
4348     if (reader-&gt;sErrorFunc != NULL) {
4349         xmlSchemaSetValidStructuredErrors(reader-&gt;xsdValidCtxt,
4350             xmlTextReaderValidityStructuredRelay,
4351             reader);
4352     }
4353     reader-&gt;xsdValidErrors = 0;
4354     reader-&gt;validate = XML_TEXTREADER_VALIDATE_XSD;
4355     return(0);
4356 }
4357 
4358 /**
4359  * xmlTextReaderRelaxNGValidateInternal:
4360  * @reader:  the xmlTextReaderPtr used
4361  * @rng:  the path to a RelaxNG schema or NULL
4362  * @ctxt: the RelaxNG schema validation context or NULL
4363  * @options: options (not yet used)
4364  *
4365  * Use RelaxNG to validate the document as it is processed.
4366  * Activation is only possible before the first Read().
4367  * If both @rng and @ctxt are NULL, then RelaxNG validation is deactivated.
4368  *
4369  * Returns 0 in case the RelaxNG validation could be (de)activated and
4370  *     -1 in case of error.
4371  */
4372 static int
4373 xmlTextReaderRelaxNGValidateInternal(xmlTextReaderPtr reader,
4374                      const char *rng,
4375                      xmlRelaxNGValidCtxtPtr ctxt,
4376                      int options ATTRIBUTE_UNUSED)
4377 {
4378     if (reader == NULL)
4379     return(-1);
4380 
4381     if ((rng != NULL) &amp;&amp; (ctxt != NULL))
4382     return (-1);
4383 
4384     if (((rng != NULL) || (ctxt != NULL)) &amp;&amp;
4385     ((reader-&gt;mode != XML_TEXTREADER_MODE_INITIAL) ||
4386      (reader-&gt;ctxt == NULL)))
4387     return(-1);
4388 
4389     /* Cleanup previous validation stuff. */
4390     if (reader-&gt;rngValidCtxt != NULL) {
4391     if ( !reader-&gt;rngPreserveCtxt)
4392         xmlRelaxNGFreeValidCtxt(reader-&gt;rngValidCtxt);
4393     reader-&gt;rngValidCtxt = NULL;
4394     }
4395     reader-&gt;rngPreserveCtxt = 0;
4396     if (reader-&gt;rngSchemas != NULL) {
4397     xmlRelaxNGFree(reader-&gt;rngSchemas);
4398     reader-&gt;rngSchemas = NULL;
4399     }
4400 
4401     if ((rng == NULL) &amp;&amp; (ctxt == NULL)) {
4402     /* We just want to deactivate the validation, so get out. */
4403     return(0);
4404     }
4405 
4406 
4407     if (rng != NULL) {
4408     xmlRelaxNGParserCtxtPtr pctxt;
4409     /* Parse the schema and create validation environment. */
4410 
4411     pctxt = xmlRelaxNGNewParserCtxt(rng);
4412     if (reader-&gt;errorFunc != NULL) {
4413         xmlRelaxNGSetParserErrors(pctxt,
4414         xmlTextReaderValidityErrorRelay,
4415         xmlTextReaderValidityWarningRelay,
4416         reader);
4417     }
4418     if (reader-&gt;sErrorFunc != NULL) {
4419         xmlRelaxNGSetValidStructuredErrors(reader-&gt;rngValidCtxt,
4420         xmlTextReaderValidityStructuredRelay,
4421         reader);
4422     }
4423     reader-&gt;rngSchemas = xmlRelaxNGParse(pctxt);
4424     xmlRelaxNGFreeParserCtxt(pctxt);
4425     if (reader-&gt;rngSchemas == NULL)
4426         return(-1);
4427     reader-&gt;rngValidCtxt = xmlRelaxNGNewValidCtxt(reader-&gt;rngSchemas);
4428     if (reader-&gt;rngValidCtxt == NULL) {
4429         xmlRelaxNGFree(reader-&gt;rngSchemas);
4430         reader-&gt;rngSchemas = NULL;
4431         return(-1);
4432     }
4433     } else {
4434     /* Use the given validation context. */
4435     reader-&gt;rngValidCtxt = ctxt;
4436     reader-&gt;rngPreserveCtxt = 1;
4437     }
4438     /*
4439     * Redirect the validation context&#39;s error channels to use
4440     * the reader channels.
4441     * TODO: In case the user provides the validation context we
4442     *   could make this redirection optional.
4443     */
4444     if (reader-&gt;errorFunc != NULL) {
4445     xmlRelaxNGSetValidErrors(reader-&gt;rngValidCtxt,
4446              xmlTextReaderValidityErrorRelay,
4447              xmlTextReaderValidityWarningRelay,
4448              reader);
4449     }
4450     if (reader-&gt;sErrorFunc != NULL) {
4451         xmlRelaxNGSetValidStructuredErrors(reader-&gt;rngValidCtxt,
4452             xmlTextReaderValidityStructuredRelay,
4453             reader);
4454     }
4455     reader-&gt;rngValidErrors = 0;
4456     reader-&gt;rngFullNode = NULL;
4457     reader-&gt;validate = XML_TEXTREADER_VALIDATE_RNG;
4458     return(0);
4459 }
4460 
4461 /**
4462  * xmlTextReaderSchemaValidateInternal:
4463  * @reader:  the xmlTextReaderPtr used
4464  * @xsd:  the path to a W3C XSD schema or NULL
4465  * @ctxt: the XML Schema validation context or NULL
4466  * @options: options (not used yet)
4467  *
4468  * Validate the document as it is processed using XML Schema.
4469  * Activation is only possible before the first Read().
4470  * If both @xsd and @ctxt are NULL then XML Schema validation is deactivated.
4471  *
4472  * Returns 0 in case the schemas validation could be (de)activated and
4473  *         -1 in case of error.
4474  */
4475 static int
4476 xmlTextReaderSchemaValidateInternal(xmlTextReaderPtr reader,
4477                     const char *xsd,
4478                     xmlSchemaValidCtxtPtr ctxt,
4479                     int options ATTRIBUTE_UNUSED)
4480 {
4481     if (reader == NULL)
4482         return(-1);
4483 
4484     if ((xsd != NULL) &amp;&amp; (ctxt != NULL))
4485     return(-1);
4486 
4487     if (((xsd != NULL) || (ctxt != NULL)) &amp;&amp;
4488     ((reader-&gt;mode != XML_TEXTREADER_MODE_INITIAL) ||
4489         (reader-&gt;ctxt == NULL)))
4490     return(-1);
4491 
4492     /* Cleanup previous validation stuff. */
4493     if (reader-&gt;xsdPlug != NULL) {
4494     xmlSchemaSAXUnplug(reader-&gt;xsdPlug);
4495     reader-&gt;xsdPlug = NULL;
4496     }
4497     if (reader-&gt;xsdValidCtxt != NULL) {
4498     if (! reader-&gt;xsdPreserveCtxt)
4499         xmlSchemaFreeValidCtxt(reader-&gt;xsdValidCtxt);
4500     reader-&gt;xsdValidCtxt = NULL;
4501     }
4502     reader-&gt;xsdPreserveCtxt = 0;
4503     if (reader-&gt;xsdSchemas != NULL) {
4504     xmlSchemaFree(reader-&gt;xsdSchemas);
4505     reader-&gt;xsdSchemas = NULL;
4506     }
4507 
4508     if ((xsd == NULL) &amp;&amp; (ctxt == NULL)) {
4509     /* We just want to deactivate the validation, so get out. */
4510     return(0);
4511     }
4512 
4513     if (xsd != NULL) {
4514     xmlSchemaParserCtxtPtr pctxt;
4515     /* Parse the schema and create validation environment. */
4516     pctxt = xmlSchemaNewParserCtxt(xsd);
4517     if (reader-&gt;errorFunc != NULL) {
4518         xmlSchemaSetParserErrors(pctxt,
4519         xmlTextReaderValidityErrorRelay,
4520         xmlTextReaderValidityWarningRelay,
4521         reader);
4522     }
4523     reader-&gt;xsdSchemas = xmlSchemaParse(pctxt);
4524     xmlSchemaFreeParserCtxt(pctxt);
4525     if (reader-&gt;xsdSchemas == NULL)
4526         return(-1);
4527     reader-&gt;xsdValidCtxt = xmlSchemaNewValidCtxt(reader-&gt;xsdSchemas);
4528     if (reader-&gt;xsdValidCtxt == NULL) {
4529         xmlSchemaFree(reader-&gt;xsdSchemas);
4530         reader-&gt;xsdSchemas = NULL;
4531         return(-1);
4532     }
4533     reader-&gt;xsdPlug = xmlSchemaSAXPlug(reader-&gt;xsdValidCtxt,
4534         &amp;(reader-&gt;ctxt-&gt;sax),
4535         &amp;(reader-&gt;ctxt-&gt;userData));
4536     if (reader-&gt;xsdPlug == NULL) {
4537         xmlSchemaFree(reader-&gt;xsdSchemas);
4538         reader-&gt;xsdSchemas = NULL;
4539         xmlSchemaFreeValidCtxt(reader-&gt;xsdValidCtxt);
4540         reader-&gt;xsdValidCtxt = NULL;
4541         return(-1);
4542     }
4543     } else {
4544     /* Use the given validation context. */
4545     reader-&gt;xsdValidCtxt = ctxt;
4546     reader-&gt;xsdPreserveCtxt = 1;
4547     reader-&gt;xsdPlug = xmlSchemaSAXPlug(reader-&gt;xsdValidCtxt,
4548         &amp;(reader-&gt;ctxt-&gt;sax),
4549         &amp;(reader-&gt;ctxt-&gt;userData));
4550     if (reader-&gt;xsdPlug == NULL) {
4551         reader-&gt;xsdValidCtxt = NULL;
4552         reader-&gt;xsdPreserveCtxt = 0;
4553         return(-1);
4554     }
4555     }
4556     xmlSchemaValidateSetLocator(reader-&gt;xsdValidCtxt,
4557                                 xmlTextReaderLocator,
4558                 (void *) reader);
4559     /*
4560     * Redirect the validation context&#39;s error channels to use
4561     * the reader channels.
4562     * TODO: In case the user provides the validation context we
4563     *   could make this redirection optional.
4564     */
4565     if (reader-&gt;errorFunc != NULL) {
4566     xmlSchemaSetValidErrors(reader-&gt;xsdValidCtxt,
4567              xmlTextReaderValidityErrorRelay,
4568              xmlTextReaderValidityWarningRelay,
4569              reader);
4570     }
4571     if (reader-&gt;sErrorFunc != NULL) {
4572         xmlSchemaSetValidStructuredErrors(reader-&gt;xsdValidCtxt,
4573             xmlTextReaderValidityStructuredRelay,
4574             reader);
4575     }
4576     reader-&gt;xsdValidErrors = 0;
4577     reader-&gt;validate = XML_TEXTREADER_VALIDATE_XSD;
4578     return(0);
4579 }
4580 
4581 /**
4582  * xmlTextReaderSchemaValidateCtxt:
4583  * @reader:  the xmlTextReaderPtr used
4584  * @ctxt: the XML Schema validation context or NULL
4585  * @options: options (not used yet)
4586  *
4587  * Use W3C XSD schema context to validate the document as it is processed.
4588  * Activation is only possible before the first Read().
4589  * If @ctxt is NULL, then XML Schema validation is deactivated.
4590  *
4591  * Returns 0 in case the schemas validation could be (de)activated and
4592  *         -1 in case of error.
4593  */
4594 int
4595 xmlTextReaderSchemaValidateCtxt(xmlTextReaderPtr reader,
4596                     xmlSchemaValidCtxtPtr ctxt,
4597                     int options)
4598 {
4599     return(xmlTextReaderSchemaValidateInternal(reader, NULL, ctxt, options));
4600 }
4601 
4602 /**
4603  * xmlTextReaderSchemaValidate:
4604  * @reader:  the xmlTextReaderPtr used
4605  * @xsd:  the path to a W3C XSD schema or NULL
4606  *
4607  * Use W3C XSD schema to validate the document as it is processed.
4608  * Activation is only possible before the first Read().
4609  * If @xsd is NULL, then XML Schema validation is deactivated.
4610  *
4611  * Returns 0 in case the schemas validation could be (de)activated and
4612  *         -1 in case of error.
4613  */
4614 int
4615 xmlTextReaderSchemaValidate(xmlTextReaderPtr reader, const char *xsd)
4616 {
4617     return(xmlTextReaderSchemaValidateInternal(reader, xsd, NULL, 0));
4618 }
4619 
4620 /**
4621  * xmlTextReaderRelaxNGValidateCtxt:
4622  * @reader:  the xmlTextReaderPtr used
4623  * @ctxt: the RelaxNG schema validation context or NULL
4624  * @options: options (not used yet)
4625  *
4626  * Use RelaxNG schema context to validate the document as it is processed.
4627  * Activation is only possible before the first Read().
4628  * If @ctxt is NULL, then RelaxNG schema validation is deactivated.
4629  *
4630  * Returns 0 in case the schemas validation could be (de)activated and
4631  *         -1 in case of error.
4632  */
4633 int
4634 xmlTextReaderRelaxNGValidateCtxt(xmlTextReaderPtr reader,
4635                  xmlRelaxNGValidCtxtPtr ctxt,
4636                  int options)
4637 {
4638     return(xmlTextReaderRelaxNGValidateInternal(reader, NULL, ctxt, options));
4639 }
4640 
4641 /**
4642  * xmlTextReaderRelaxNGValidate:
4643  * @reader:  the xmlTextReaderPtr used
4644  * @rng:  the path to a RelaxNG schema or NULL
4645  *
4646  * Use RelaxNG schema to validate the document as it is processed.
4647  * Activation is only possible before the first Read().
4648  * If @rng is NULL, then RelaxNG schema validation is deactivated.
4649  *
4650  * Returns 0 in case the schemas validation could be (de)activated and
4651  *         -1 in case of error.
4652  */
4653 int
4654 xmlTextReaderRelaxNGValidate(xmlTextReaderPtr reader, const char *rng)
4655 {
4656     return(xmlTextReaderRelaxNGValidateInternal(reader, rng, NULL, 0));
4657 }
4658 
4659 #endif
4660 
4661 /**
4662  * xmlTextReaderIsNamespaceDecl:
4663  * @reader: the xmlTextReaderPtr used
4664  *
4665  * Determine whether the current node is a namespace declaration
4666  * rather than a regular attribute.
4667  *
4668  * Returns 1 if the current node is a namespace declaration, 0 if it
4669  * is a regular attribute or other type of node, or -1 in case of
4670  * error.
4671  */
4672 int
4673 xmlTextReaderIsNamespaceDecl(xmlTextReaderPtr reader) {
4674     xmlNodePtr node;
4675     if (reader == NULL)
4676     return(-1);
4677     if (reader-&gt;node == NULL)
4678     return(-1);
4679     if (reader-&gt;curnode != NULL)
4680     node = reader-&gt;curnode;
4681     else
4682     node = reader-&gt;node;
4683 
4684     if (XML_NAMESPACE_DECL == node-&gt;type)
4685     return(1);
4686     else
4687     return(0);
4688 }
4689 
4690 /**
4691  * xmlTextReaderConstXmlVersion:
4692  * @reader:  the xmlTextReaderPtr used
4693  *
4694  * Determine the XML version of the document being read.
4695  *
4696  * Returns a string containing the XML version of the document or NULL
4697  * in case of error.  The string is deallocated with the reader.
4698  */
4699 const xmlChar *
4700 xmlTextReaderConstXmlVersion(xmlTextReaderPtr reader) {
4701     xmlDocPtr doc = NULL;
4702     if (reader == NULL)
4703     return(NULL);
4704     if (reader-&gt;doc != NULL)
4705         doc = reader-&gt;doc;
4706     else if (reader-&gt;ctxt != NULL)
4707     doc = reader-&gt;ctxt-&gt;myDoc;
4708     if (doc == NULL)
4709     return(NULL);
4710 
4711     if (doc-&gt;version == NULL)
4712     return(NULL);
4713     else
4714       return(CONSTSTR(doc-&gt;version));
4715 }
4716 
4717 /**
4718  * xmlTextReaderStandalone:
4719  * @reader:  the xmlTextReaderPtr used
4720  *
4721  * Determine the standalone status of the document being read.
4722  *
4723  * Returns 1 if the document was declared to be standalone, 0 if it
4724  * was declared to be not standalone, or -1 if the document did not
4725  * specify its standalone status or in case of error.
4726  */
4727 int
4728 xmlTextReaderStandalone(xmlTextReaderPtr reader) {
4729     xmlDocPtr doc = NULL;
4730     if (reader == NULL)
4731     return(-1);
4732     if (reader-&gt;doc != NULL)
4733         doc = reader-&gt;doc;
4734     else if (reader-&gt;ctxt != NULL)
4735     doc = reader-&gt;ctxt-&gt;myDoc;
4736     if (doc == NULL)
4737     return(-1);
4738 
4739     return(doc-&gt;standalone);
4740 }
4741 
4742 /************************************************************************
4743  *                                  *
4744  *          Error Handling Extensions                       *
4745  *                                  *
4746  ************************************************************************/
4747 
4748 /* helper to build a xmlMalloc&#39;ed string from a format and va_list */
4749 static char *
4750 xmlTextReaderBuildMessage(const char *msg, va_list ap) {
4751     int size = 0;
4752     int chars;
4753     char *larger;
4754     char *str = NULL;
4755     va_list aq;
4756 
4757     while (1) {
4758         VA_COPY(aq, ap);
4759         chars = vsnprintf(str, size, msg, aq);
4760         va_end(aq);
4761         if (chars &lt; 0) {
4762         xmlGenericError(xmlGenericErrorContext, &quot;vsnprintf failed !\n&quot;);
4763         if (str)
4764         xmlFree(str);
4765         return NULL;
4766     }
4767     if ((chars &lt; size) || (size == MAX_ERR_MSG_SIZE))
4768             break;
4769         if (chars &lt; MAX_ERR_MSG_SIZE)
4770     size = chars + 1;
4771     else
4772         size = MAX_ERR_MSG_SIZE;
4773         if ((larger = (char *) xmlRealloc(str, size)) == NULL) {
4774         xmlGenericError(xmlGenericErrorContext, &quot;xmlRealloc failed !\n&quot;);
4775         if (str)
4776                 xmlFree(str);
4777             return NULL;
4778         }
4779         str = larger;
4780     }
4781 
4782     return str;
4783 }
4784 
4785 /**
4786  * xmlTextReaderLocatorLineNumber:
4787  * @locator: the xmlTextReaderLocatorPtr used
4788  *
4789  * Obtain the line number for the given locator.
4790  *
4791  * Returns the line number or -1 in case of error.
4792  */
4793 int
4794 xmlTextReaderLocatorLineNumber(xmlTextReaderLocatorPtr locator) {
4795     /* we know that locator is a xmlParserCtxtPtr */
4796     xmlParserCtxtPtr ctx = (xmlParserCtxtPtr)locator;
4797     int ret = -1;
4798 
4799     if (locator == NULL)
4800         return(-1);
4801     if (ctx-&gt;node != NULL) {
4802     ret = xmlGetLineNo(ctx-&gt;node);
4803     }
4804     else {
4805     /* inspired from error.c */
4806     xmlParserInputPtr input;
4807     input = ctx-&gt;input;
4808     if ((input-&gt;filename == NULL) &amp;&amp; (ctx-&gt;inputNr &gt; 1))
4809         input = ctx-&gt;inputTab[ctx-&gt;inputNr - 2];
4810     if (input != NULL) {
4811         ret = input-&gt;line;
4812     }
4813     else {
4814         ret = -1;
4815     }
4816     }
4817 
4818     return ret;
4819 }
4820 
4821 /**
4822  * xmlTextReaderLocatorBaseURI:
4823  * @locator: the xmlTextReaderLocatorPtr used
4824  *
4825  * Obtain the base URI for the given locator.
4826  *
4827  * Returns the base URI or NULL in case of error,
4828  *    if non NULL it need to be freed by the caller.
4829  */
4830 xmlChar *
4831 xmlTextReaderLocatorBaseURI(xmlTextReaderLocatorPtr locator) {
4832     /* we know that locator is a xmlParserCtxtPtr */
4833     xmlParserCtxtPtr ctx = (xmlParserCtxtPtr)locator;
4834     xmlChar *ret = NULL;
4835 
4836     if (locator == NULL)
4837         return(NULL);
4838     if (ctx-&gt;node != NULL) {
4839     ret = xmlNodeGetBase(NULL,ctx-&gt;node);
4840     }
4841     else {
4842     /* inspired from error.c */
4843     xmlParserInputPtr input;
4844     input = ctx-&gt;input;
4845     if ((input-&gt;filename == NULL) &amp;&amp; (ctx-&gt;inputNr &gt; 1))
4846         input = ctx-&gt;inputTab[ctx-&gt;inputNr - 2];
4847     if (input != NULL) {
4848         ret = xmlStrdup(BAD_CAST input-&gt;filename);
4849     }
4850     else {
4851         ret = NULL;
4852     }
4853     }
4854 
4855     return ret;
4856 }
4857 
4858 static void
4859 xmlTextReaderGenericError(void *ctxt, xmlParserSeverities severity,
4860                           char *str)
4861 {
4862     xmlParserCtxtPtr ctx = (xmlParserCtxtPtr) ctxt;
4863 
4864     xmlTextReaderPtr reader = (xmlTextReaderPtr) ctx-&gt;_private;
4865 
4866     if (str != NULL) {
4867         if (reader-&gt;errorFunc)
4868             reader-&gt;errorFunc(reader-&gt;errorFuncArg, str, severity,
4869                               (xmlTextReaderLocatorPtr) ctx);
4870         xmlFree(str);
4871     }
4872 }
4873 
4874 static void
4875 xmlTextReaderStructuredError(void *ctxt, xmlErrorPtr error)
4876 {
4877     xmlParserCtxtPtr ctx = (xmlParserCtxtPtr) ctxt;
4878 
4879     xmlTextReaderPtr reader = (xmlTextReaderPtr) ctx-&gt;_private;
4880 
4881     if (error &amp;&amp; reader-&gt;sErrorFunc) {
4882         reader-&gt;sErrorFunc(reader-&gt;errorFuncArg, (xmlErrorPtr) error);
4883     }
4884 }
4885 
4886 static void XMLCDECL LIBXML_ATTR_FORMAT(2,3)
4887 xmlTextReaderError(void *ctxt, const char *msg, ...)
4888 {
4889     va_list ap;
4890 
4891     va_start(ap, msg);
4892     xmlTextReaderGenericError(ctxt,
4893                               XML_PARSER_SEVERITY_ERROR,
4894                               xmlTextReaderBuildMessage(msg, ap));
4895     va_end(ap);
4896 
4897 }
4898 
4899 static void XMLCDECL LIBXML_ATTR_FORMAT(2,3)
4900 xmlTextReaderWarning(void *ctxt, const char *msg, ...)
4901 {
4902     va_list ap;
4903 
4904     va_start(ap, msg);
4905     xmlTextReaderGenericError(ctxt,
4906                               XML_PARSER_SEVERITY_WARNING,
4907                               xmlTextReaderBuildMessage(msg, ap));
4908     va_end(ap);
4909 }
4910 
4911 static void XMLCDECL
4912 xmlTextReaderValidityError(void *ctxt, const char *msg, ...)
4913 {
4914     va_list ap;
4915 
4916     int len = xmlStrlen((const xmlChar *) msg);
4917 
4918     if ((len &gt; 1) &amp;&amp; (msg[len - 2] != &#39;:&#39;)) {
4919         /*
4920          * some callbacks only report locator information:
4921          * skip them (mimicking behaviour in error.c)
4922          */
4923         va_start(ap, msg);
4924         xmlTextReaderGenericError(ctxt,
4925                                   XML_PARSER_SEVERITY_VALIDITY_ERROR,
4926                                   xmlTextReaderBuildMessage(msg, ap));
4927         va_end(ap);
4928     }
4929 }
4930 
4931 static void XMLCDECL
4932 xmlTextReaderValidityWarning(void *ctxt, const char *msg, ...)
4933 {
4934     va_list ap;
4935 
4936     int len = xmlStrlen((const xmlChar *) msg);
4937 
4938     if ((len != 0) &amp;&amp; (msg[len - 1] != &#39;:&#39;)) {
4939         /*
4940          * some callbacks only report locator information:
4941          * skip them (mimicking behaviour in error.c)
4942          */
4943         va_start(ap, msg);
4944         xmlTextReaderGenericError(ctxt,
4945                                   XML_PARSER_SEVERITY_VALIDITY_WARNING,
4946                                   xmlTextReaderBuildMessage(msg, ap));
4947         va_end(ap);
4948     }
4949 }
4950 
4951 /**
4952  * xmlTextReaderSetErrorHandler:
4953  * @reader:  the xmlTextReaderPtr used
4954  * @f:  the callback function to call on error and warnings
4955  * @arg:    a user argument to pass to the callback function
4956  *
4957  * Register a callback function that will be called on error and warnings.
4958  *
4959  * If @f is NULL, the default error and warning handlers are restored.
4960  */
4961 void
4962 xmlTextReaderSetErrorHandler(xmlTextReaderPtr reader,
4963                              xmlTextReaderErrorFunc f, void *arg)
4964 {
4965     if (f != NULL) {
4966         reader-&gt;ctxt-&gt;sax-&gt;error = xmlTextReaderError;
4967         reader-&gt;ctxt-&gt;sax-&gt;serror = NULL;
4968         reader-&gt;ctxt-&gt;vctxt.error = xmlTextReaderValidityError;
4969         reader-&gt;ctxt-&gt;sax-&gt;warning = xmlTextReaderWarning;
4970         reader-&gt;ctxt-&gt;vctxt.warning = xmlTextReaderValidityWarning;
4971         reader-&gt;errorFunc = f;
4972         reader-&gt;sErrorFunc = NULL;
4973         reader-&gt;errorFuncArg = arg;
4974 #ifdef LIBXML_SCHEMAS_ENABLED
4975         if (reader-&gt;rngValidCtxt) {
4976             xmlRelaxNGSetValidErrors(reader-&gt;rngValidCtxt,
4977                                      xmlTextReaderValidityErrorRelay,
4978                                      xmlTextReaderValidityWarningRelay,
4979                                      reader);
4980             xmlRelaxNGSetValidStructuredErrors(reader-&gt;rngValidCtxt, NULL,
4981                                                reader);
4982         }
4983         if (reader-&gt;xsdValidCtxt) {
4984             xmlSchemaSetValidErrors(reader-&gt;xsdValidCtxt,
4985                                     xmlTextReaderValidityErrorRelay,
4986                                     xmlTextReaderValidityWarningRelay,
4987                                     reader);
4988             xmlSchemaSetValidStructuredErrors(reader-&gt;xsdValidCtxt, NULL,
4989                                               reader);
4990         }
4991 #endif
4992     } else {
4993         /* restore defaults */
4994         reader-&gt;ctxt-&gt;sax-&gt;error = xmlParserError;
4995         reader-&gt;ctxt-&gt;vctxt.error = xmlParserValidityError;
4996         reader-&gt;ctxt-&gt;sax-&gt;warning = xmlParserWarning;
4997         reader-&gt;ctxt-&gt;vctxt.warning = xmlParserValidityWarning;
4998         reader-&gt;errorFunc = NULL;
4999         reader-&gt;sErrorFunc = NULL;
5000         reader-&gt;errorFuncArg = NULL;
5001 #ifdef LIBXML_SCHEMAS_ENABLED
5002         if (reader-&gt;rngValidCtxt) {
5003             xmlRelaxNGSetValidErrors(reader-&gt;rngValidCtxt, NULL, NULL,
5004                                      reader);
5005             xmlRelaxNGSetValidStructuredErrors(reader-&gt;rngValidCtxt, NULL,
5006                                                reader);
5007         }
5008         if (reader-&gt;xsdValidCtxt) {
5009             xmlSchemaSetValidErrors(reader-&gt;xsdValidCtxt, NULL, NULL,
5010                                     reader);
5011             xmlSchemaSetValidStructuredErrors(reader-&gt;xsdValidCtxt, NULL,
5012                                               reader);
5013         }
5014 #endif
5015     }
5016 }
5017 
5018 /**
5019 * xmlTextReaderSetStructuredErrorHandler:
5020  * @reader:  the xmlTextReaderPtr used
5021  * @f:  the callback function to call on error and warnings
5022  * @arg:    a user argument to pass to the callback function
5023  *
5024  * Register a callback function that will be called on error and warnings.
5025  *
5026  * If @f is NULL, the default error and warning handlers are restored.
5027  */
5028 void
5029 xmlTextReaderSetStructuredErrorHandler(xmlTextReaderPtr reader,
5030                                        xmlStructuredErrorFunc f, void *arg)
5031 {
5032     if (f != NULL) {
5033         reader-&gt;ctxt-&gt;sax-&gt;error = NULL;
5034         reader-&gt;ctxt-&gt;sax-&gt;serror = xmlTextReaderStructuredError;
5035         reader-&gt;ctxt-&gt;vctxt.error = xmlTextReaderValidityError;
5036         reader-&gt;ctxt-&gt;sax-&gt;warning = xmlTextReaderWarning;
5037         reader-&gt;ctxt-&gt;vctxt.warning = xmlTextReaderValidityWarning;
5038         reader-&gt;sErrorFunc = f;
5039         reader-&gt;errorFunc = NULL;
5040         reader-&gt;errorFuncArg = arg;
5041 #ifdef LIBXML_SCHEMAS_ENABLED
5042         if (reader-&gt;rngValidCtxt) {
5043             xmlRelaxNGSetValidErrors(reader-&gt;rngValidCtxt, NULL, NULL,
5044                                      reader);
5045             xmlRelaxNGSetValidStructuredErrors(reader-&gt;rngValidCtxt,
5046                                         xmlTextReaderValidityStructuredRelay,
5047                                                reader);
5048         }
5049         if (reader-&gt;xsdValidCtxt) {
5050             xmlSchemaSetValidErrors(reader-&gt;xsdValidCtxt, NULL, NULL,
5051                                     reader);
5052             xmlSchemaSetValidStructuredErrors(reader-&gt;xsdValidCtxt,
5053                                        xmlTextReaderValidityStructuredRelay,
5054                                               reader);
5055         }
5056 #endif
5057     } else {
5058         /* restore defaults */
5059         reader-&gt;ctxt-&gt;sax-&gt;error = xmlParserError;
5060         reader-&gt;ctxt-&gt;sax-&gt;serror = NULL;
5061         reader-&gt;ctxt-&gt;vctxt.error = xmlParserValidityError;
5062         reader-&gt;ctxt-&gt;sax-&gt;warning = xmlParserWarning;
5063         reader-&gt;ctxt-&gt;vctxt.warning = xmlParserValidityWarning;
5064         reader-&gt;errorFunc = NULL;
5065         reader-&gt;sErrorFunc = NULL;
5066         reader-&gt;errorFuncArg = NULL;
5067 #ifdef LIBXML_SCHEMAS_ENABLED
5068         if (reader-&gt;rngValidCtxt) {
5069             xmlRelaxNGSetValidErrors(reader-&gt;rngValidCtxt, NULL, NULL,
5070                                      reader);
5071             xmlRelaxNGSetValidStructuredErrors(reader-&gt;rngValidCtxt, NULL,
5072                                                reader);
5073         }
5074         if (reader-&gt;xsdValidCtxt) {
5075             xmlSchemaSetValidErrors(reader-&gt;xsdValidCtxt, NULL, NULL,
5076                                     reader);
5077             xmlSchemaSetValidStructuredErrors(reader-&gt;xsdValidCtxt, NULL,
5078                                               reader);
5079         }
5080 #endif
5081     }
5082 }
5083 
5084 /**
5085  * xmlTextReaderIsValid:
5086  * @reader:  the xmlTextReaderPtr used
5087  *
5088  * Retrieve the validity status from the parser context
5089  *
5090  * Returns the flag value 1 if valid, 0 if no, and -1 in case of error
5091  */
5092 int
5093 xmlTextReaderIsValid(xmlTextReaderPtr reader)
5094 {
5095     if (reader == NULL)
5096         return (-1);
5097 #ifdef LIBXML_SCHEMAS_ENABLED
5098     if (reader-&gt;validate == XML_TEXTREADER_VALIDATE_RNG)
5099         return (reader-&gt;rngValidErrors == 0);
5100     if (reader-&gt;validate == XML_TEXTREADER_VALIDATE_XSD)
5101         return (reader-&gt;xsdValidErrors == 0);
5102 #endif
5103     if ((reader-&gt;ctxt != NULL) &amp;&amp; (reader-&gt;ctxt-&gt;validate == 1))
5104         return (reader-&gt;ctxt-&gt;valid);
5105     return (0);
5106 }
5107 
5108 /**
5109  * xmlTextReaderGetErrorHandler:
5110  * @reader:  the xmlTextReaderPtr used
5111  * @f:  the callback function or NULL is no callback has been registered
5112  * @arg:    a user argument
5113  *
5114  * Retrieve the error callback function and user argument.
5115  */
5116 void
5117 xmlTextReaderGetErrorHandler(xmlTextReaderPtr reader,
5118                              xmlTextReaderErrorFunc * f, void **arg)
5119 {
5120     if (f != NULL)
5121         *f = reader-&gt;errorFunc;
5122     if (arg != NULL)
5123         *arg = reader-&gt;errorFuncArg;
5124 }
5125 /************************************************************************
5126  *                                  *
5127  *  New set (2.6.0) of simpler and more flexible APIs       *
5128  *                                  *
5129  ************************************************************************/
5130 
5131 /**
5132  * xmlTextReaderSetup:
5133  * @reader:  an XML reader
5134  * @input: xmlParserInputBufferPtr used to feed the reader, will
5135  *         be destroyed with it.
5136  * @URL:  the base URL to use for the document
5137  * @encoding:  the document encoding, or NULL
5138  * @options:  a combination of xmlParserOption
5139  *
5140  * Setup an XML reader with new options
5141  *
5142  * Returns 0 in case of success and -1 in case of error.
5143  */
5144 int
5145 xmlTextReaderSetup(xmlTextReaderPtr reader,
5146                    xmlParserInputBufferPtr input, const char *URL,
5147                    const char *encoding, int options)
5148 {
5149     if (reader == NULL) {
5150         if (input != NULL)
5151         xmlFreeParserInputBuffer(input);
5152         return (-1);
5153     }
5154 
5155     /*
5156      * we force the generation of compact text nodes on the reader
5157      * since usr applications should never modify the tree
5158      */
5159     options |= XML_PARSE_COMPACT;
5160 
5161     reader-&gt;doc = NULL;
5162     reader-&gt;entNr = 0;
5163     reader-&gt;parserFlags = options;
5164     reader-&gt;validate = XML_TEXTREADER_NOT_VALIDATE;
5165     if ((input != NULL) &amp;&amp; (reader-&gt;input != NULL) &amp;&amp;
5166         (reader-&gt;allocs &amp; XML_TEXTREADER_INPUT)) {
5167     xmlFreeParserInputBuffer(reader-&gt;input);
5168     reader-&gt;input = NULL;
5169     reader-&gt;allocs -= XML_TEXTREADER_INPUT;
5170     }
5171     if (input != NULL) {
5172     reader-&gt;input = input;
5173     reader-&gt;allocs |= XML_TEXTREADER_INPUT;
5174     }
5175     if (reader-&gt;buffer == NULL)
5176         reader-&gt;buffer = xmlBufCreateSize(100);
5177     if (reader-&gt;buffer == NULL) {
5178         xmlGenericError(xmlGenericErrorContext,
5179                         &quot;xmlTextReaderSetup : malloc failed\n&quot;);
5180         return (-1);
5181     }
5182     /* no operation on a reader should require a huge buffer */
5183     xmlBufSetAllocationScheme(reader-&gt;buffer,
5184                   XML_BUFFER_ALLOC_BOUNDED);
5185     if (reader-&gt;sax == NULL)
5186     reader-&gt;sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));
5187     if (reader-&gt;sax == NULL) {
5188         xmlGenericError(xmlGenericErrorContext,
5189                         &quot;xmlTextReaderSetup : malloc failed\n&quot;);
5190         return (-1);
5191     }
5192     xmlSAXVersion(reader-&gt;sax, 2);
5193     reader-&gt;startElement = reader-&gt;sax-&gt;startElement;
5194     reader-&gt;sax-&gt;startElement = xmlTextReaderStartElement;
5195     reader-&gt;endElement = reader-&gt;sax-&gt;endElement;
5196     reader-&gt;sax-&gt;endElement = xmlTextReaderEndElement;
5197 #ifdef LIBXML_SAX1_ENABLED
5198     if (reader-&gt;sax-&gt;initialized == XML_SAX2_MAGIC) {
5199 #endif /* LIBXML_SAX1_ENABLED */
5200         reader-&gt;startElementNs = reader-&gt;sax-&gt;startElementNs;
5201         reader-&gt;sax-&gt;startElementNs = xmlTextReaderStartElementNs;
5202         reader-&gt;endElementNs = reader-&gt;sax-&gt;endElementNs;
5203         reader-&gt;sax-&gt;endElementNs = xmlTextReaderEndElementNs;
5204 #ifdef LIBXML_SAX1_ENABLED
5205     } else {
5206         reader-&gt;startElementNs = NULL;
5207         reader-&gt;endElementNs = NULL;
5208     }
5209 #endif /* LIBXML_SAX1_ENABLED */
5210     reader-&gt;characters = reader-&gt;sax-&gt;characters;
5211     reader-&gt;sax-&gt;characters = xmlTextReaderCharacters;
5212     reader-&gt;sax-&gt;ignorableWhitespace = xmlTextReaderCharacters;
5213     reader-&gt;cdataBlock = reader-&gt;sax-&gt;cdataBlock;
5214     reader-&gt;sax-&gt;cdataBlock = xmlTextReaderCDataBlock;
5215 
5216     reader-&gt;mode = XML_TEXTREADER_MODE_INITIAL;
5217     reader-&gt;node = NULL;
5218     reader-&gt;curnode = NULL;
5219     if (input != NULL) {
5220         if (xmlBufUse(reader-&gt;input-&gt;buffer) &lt; 4) {
5221             xmlParserInputBufferRead(input, 4);
5222         }
5223         if (reader-&gt;ctxt == NULL) {
5224             if (xmlBufUse(reader-&gt;input-&gt;buffer) &gt;= 4) {
5225                 reader-&gt;ctxt = xmlCreatePushParserCtxt(reader-&gt;sax, NULL,
5226                (const char *) xmlBufContent(reader-&gt;input-&gt;buffer),
5227                                       4, URL);
5228                 reader-&gt;base = 0;
5229                 reader-&gt;cur = 4;
5230             } else {
5231                 reader-&gt;ctxt =
5232                     xmlCreatePushParserCtxt(reader-&gt;sax, NULL, NULL, 0, URL);
5233                 reader-&gt;base = 0;
5234                 reader-&gt;cur = 0;
5235             }
5236         } else {
5237         xmlParserInputPtr inputStream;
5238         xmlParserInputBufferPtr buf;
5239         xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;
5240 
5241         xmlCtxtReset(reader-&gt;ctxt);
5242         buf = xmlAllocParserInputBuffer(enc);
5243         if (buf == NULL) return(-1);
5244         inputStream = xmlNewInputStream(reader-&gt;ctxt);
5245         if (inputStream == NULL) {
5246         xmlFreeParserInputBuffer(buf);
5247         return(-1);
5248         }
5249 
5250         if (URL == NULL)
5251         inputStream-&gt;filename = NULL;
5252         else
5253         inputStream-&gt;filename = (char *)
5254             xmlCanonicPath((const xmlChar *) URL);
5255         inputStream-&gt;buf = buf;
5256             xmlBufResetInput(buf-&gt;buffer, inputStream);
5257 
5258         inputPush(reader-&gt;ctxt, inputStream);
5259         reader-&gt;cur = 0;
5260     }
5261         if (reader-&gt;ctxt == NULL) {
5262             xmlGenericError(xmlGenericErrorContext,
5263                             &quot;xmlTextReaderSetup : malloc failed\n&quot;);
5264             return (-1);
5265         }
5266     }
5267     if (reader-&gt;dict != NULL) {
5268         if (reader-&gt;ctxt-&gt;dict != NULL) {
5269         if (reader-&gt;dict != reader-&gt;ctxt-&gt;dict) {
5270         xmlDictFree(reader-&gt;dict);
5271         reader-&gt;dict = reader-&gt;ctxt-&gt;dict;
5272         }
5273     } else {
5274         reader-&gt;ctxt-&gt;dict = reader-&gt;dict;
5275     }
5276     } else {
5277     if (reader-&gt;ctxt-&gt;dict == NULL)
5278         reader-&gt;ctxt-&gt;dict = xmlDictCreate();
5279         reader-&gt;dict = reader-&gt;ctxt-&gt;dict;
5280     }
5281     reader-&gt;ctxt-&gt;_private = reader;
5282     reader-&gt;ctxt-&gt;linenumbers = 1;
5283     reader-&gt;ctxt-&gt;dictNames = 1;
5284     /*
5285      * use the parser dictionary to allocate all elements and attributes names
5286      */
5287     reader-&gt;ctxt-&gt;docdict = 1;
5288     reader-&gt;ctxt-&gt;parseMode = XML_PARSE_READER;
5289 
5290 #ifdef LIBXML_XINCLUDE_ENABLED
5291     if (reader-&gt;xincctxt != NULL) {
5292     xmlXIncludeFreeContext(reader-&gt;xincctxt);
5293     reader-&gt;xincctxt = NULL;
5294     }
5295     if (options &amp; XML_PARSE_XINCLUDE) {
5296         reader-&gt;xinclude = 1;
5297     reader-&gt;xinclude_name = xmlDictLookup(reader-&gt;dict, XINCLUDE_NODE, -1);
5298     options -= XML_PARSE_XINCLUDE;
5299     } else
5300         reader-&gt;xinclude = 0;
5301     reader-&gt;in_xinclude = 0;
5302 #endif
5303 #ifdef LIBXML_PATTERN_ENABLED
5304     if (reader-&gt;patternTab == NULL) {
5305         reader-&gt;patternNr = 0;
5306     reader-&gt;patternMax = 0;
5307     }
5308     while (reader-&gt;patternNr &gt; 0) {
5309         reader-&gt;patternNr--;
5310     if (reader-&gt;patternTab[reader-&gt;patternNr] != NULL) {
5311         xmlFreePattern(reader-&gt;patternTab[reader-&gt;patternNr]);
5312             reader-&gt;patternTab[reader-&gt;patternNr] = NULL;
5313     }
5314     }
5315 #endif
5316 
5317     if (options &amp; XML_PARSE_DTDVALID)
5318         reader-&gt;validate = XML_TEXTREADER_VALIDATE_DTD;
5319 
5320     xmlCtxtUseOptions(reader-&gt;ctxt, options);
5321     if (encoding != NULL) {
5322         xmlCharEncodingHandlerPtr hdlr;
5323 
5324         hdlr = xmlFindCharEncodingHandler(encoding);
5325         if (hdlr != NULL)
5326             xmlSwitchToEncoding(reader-&gt;ctxt, hdlr);
5327     }
5328     if ((URL != NULL) &amp;&amp; (reader-&gt;ctxt-&gt;input != NULL) &amp;&amp;
5329         (reader-&gt;ctxt-&gt;input-&gt;filename == NULL))
5330         reader-&gt;ctxt-&gt;input-&gt;filename = (char *)
5331             xmlStrdup((const xmlChar *) URL);
5332 
5333     reader-&gt;doc = NULL;
5334 
5335     return (0);
5336 }
5337 
5338 /**
5339  * xmlTextReaderByteConsumed:
5340  * @reader: an XML reader
5341  *
5342  * This function provides the current index of the parser used
5343  * by the reader, relative to the start of the current entity.
5344  * This function actually just wraps a call to xmlBytesConsumed()
5345  * for the parser context associated with the reader.
5346  * See xmlBytesConsumed() for more information.
5347  *
5348  * Returns the index in bytes from the beginning of the entity or -1
5349  *         in case the index could not be computed.
5350  */
5351 long
5352 xmlTextReaderByteConsumed(xmlTextReaderPtr reader) {
5353     if ((reader == NULL) || (reader-&gt;ctxt == NULL))
5354         return(-1);
5355     return(xmlByteConsumed(reader-&gt;ctxt));
5356 }
5357 
5358 
5359 /**
5360  * xmlReaderWalker:
5361  * @doc:  a preparsed document
5362  *
5363  * Create an xmltextReader for a preparsed document.
5364  *
5365  * Returns the new reader or NULL in case of error.
5366  */
5367 xmlTextReaderPtr
5368 xmlReaderWalker(xmlDocPtr doc)
5369 {
5370     xmlTextReaderPtr ret;
5371 
5372     if (doc == NULL)
5373         return(NULL);
5374 
5375     ret = xmlMalloc(sizeof(xmlTextReader));
5376     if (ret == NULL) {
5377         xmlGenericError(xmlGenericErrorContext,
5378         &quot;xmlNewTextReader : malloc failed\n&quot;);
5379     return(NULL);
5380     }
5381     memset(ret, 0, sizeof(xmlTextReader));
5382     ret-&gt;entNr = 0;
5383     ret-&gt;input = NULL;
5384     ret-&gt;mode = XML_TEXTREADER_MODE_INITIAL;
5385     ret-&gt;node = NULL;
5386     ret-&gt;curnode = NULL;
5387     ret-&gt;base = 0;
5388     ret-&gt;cur = 0;
5389     ret-&gt;allocs = XML_TEXTREADER_CTXT;
5390     ret-&gt;doc = doc;
5391     ret-&gt;state = XML_TEXTREADER_START;
5392     ret-&gt;dict = xmlDictCreate();
5393     return(ret);
5394 }
5395 
5396 /**
5397  * xmlReaderForDoc:
5398  * @cur:  a pointer to a zero terminated string
5399  * @URL:  the base URL to use for the document
5400  * @encoding:  the document encoding, or NULL
5401  * @options:  a combination of xmlParserOption
5402  *
5403  * Create an xmltextReader for an XML in-memory document.
5404  * The parsing flags @options are a combination of xmlParserOption.
5405  *
5406  * Returns the new reader or NULL in case of error.
5407  */
5408 xmlTextReaderPtr
5409 xmlReaderForDoc(const xmlChar * cur, const char *URL, const char *encoding,
5410                 int options)
5411 {
5412     int len;
5413 
5414     if (cur == NULL)
5415         return (NULL);
5416     len = xmlStrlen(cur);
5417 
5418     return (xmlReaderForMemory
5419             ((const char *) cur, len, URL, encoding, options));
5420 }
5421 
5422 /**
5423  * xmlReaderForFile:
5424  * @filename:  a file or URL
5425  * @encoding:  the document encoding, or NULL
5426  * @options:  a combination of xmlParserOption
5427  *
5428  * parse an XML file from the filesystem or the network.
5429  * The parsing flags @options are a combination of xmlParserOption.
5430  *
5431  * Returns the new reader or NULL in case of error.
5432  */
5433 xmlTextReaderPtr
5434 xmlReaderForFile(const char *filename, const char *encoding, int options)
5435 {
5436     xmlTextReaderPtr reader;
5437 
5438     reader = xmlNewTextReaderFilename(filename);
5439     if (reader == NULL)
5440         return (NULL);
5441     xmlTextReaderSetup(reader, NULL, NULL, encoding, options);
5442     return (reader);
5443 }
5444 
5445 /**
5446  * xmlReaderForMemory:
5447  * @buffer:  a pointer to a char array
5448  * @size:  the size of the array
5449  * @URL:  the base URL to use for the document
5450  * @encoding:  the document encoding, or NULL
5451  * @options:  a combination of xmlParserOption
5452  *
5453  * Create an xmltextReader for an XML in-memory document.
5454  * The parsing flags @options are a combination of xmlParserOption.
5455  *
5456  * Returns the new reader or NULL in case of error.
5457  */
5458 xmlTextReaderPtr
5459 xmlReaderForMemory(const char *buffer, int size, const char *URL,
5460                    const char *encoding, int options)
5461 {
5462     xmlTextReaderPtr reader;
5463     xmlParserInputBufferPtr buf;
5464 
5465     buf = xmlParserInputBufferCreateStatic(buffer, size,
5466                                       XML_CHAR_ENCODING_NONE);
5467     if (buf == NULL) {
5468         return (NULL);
5469     }
5470     reader = xmlNewTextReader(buf, URL);
5471     if (reader == NULL) {
5472         xmlFreeParserInputBuffer(buf);
5473         return (NULL);
5474     }
5475     reader-&gt;allocs |= XML_TEXTREADER_INPUT;
5476     xmlTextReaderSetup(reader, NULL, URL, encoding, options);
5477     return (reader);
5478 }
5479 
5480 /**
5481  * xmlReaderForFd:
5482  * @fd:  an open file descriptor
5483  * @URL:  the base URL to use for the document
5484  * @encoding:  the document encoding, or NULL
5485  * @options:  a combination of xmlParserOption
5486  *
5487  * Create an xmltextReader for an XML from a file descriptor.
5488  * The parsing flags @options are a combination of xmlParserOption.
5489  * NOTE that the file descriptor will not be closed when the
5490  *      reader is closed or reset.
5491  *
5492  * Returns the new reader or NULL in case of error.
5493  */
5494 xmlTextReaderPtr
5495 xmlReaderForFd(int fd, const char *URL, const char *encoding, int options)
5496 {
5497     xmlTextReaderPtr reader;
5498     xmlParserInputBufferPtr input;
5499 
5500     if (fd &lt; 0)
5501         return (NULL);
5502 
5503     input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
5504     if (input == NULL)
5505         return (NULL);
5506     input-&gt;closecallback = NULL;
5507     reader = xmlNewTextReader(input, URL);
5508     if (reader == NULL) {
5509         xmlFreeParserInputBuffer(input);
5510         return (NULL);
5511     }
5512     reader-&gt;allocs |= XML_TEXTREADER_INPUT;
5513     xmlTextReaderSetup(reader, NULL, URL, encoding, options);
5514     return (reader);
5515 }
5516 
5517 /**
5518  * xmlReaderForIO:
5519  * @ioread:  an I/O read function
5520  * @ioclose:  an I/O close function
5521  * @ioctx:  an I/O handler
5522  * @URL:  the base URL to use for the document
5523  * @encoding:  the document encoding, or NULL
5524  * @options:  a combination of xmlParserOption
5525  *
5526  * Create an xmltextReader for an XML document from I/O functions and source.
5527  * The parsing flags @options are a combination of xmlParserOption.
5528  *
5529  * Returns the new reader or NULL in case of error.
5530  */
5531 xmlTextReaderPtr
5532 xmlReaderForIO(xmlInputReadCallback ioread, xmlInputCloseCallback ioclose,
5533                void *ioctx, const char *URL, const char *encoding,
5534                int options)
5535 {
5536     xmlTextReaderPtr reader;
5537     xmlParserInputBufferPtr input;
5538 
5539     if (ioread == NULL)
5540         return (NULL);
5541 
5542     input = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx,
5543                                          XML_CHAR_ENCODING_NONE);
5544     if (input == NULL) {
5545         if (ioclose != NULL)
5546             ioclose(ioctx);
5547         return (NULL);
5548     }
5549     reader = xmlNewTextReader(input, URL);
5550     if (reader == NULL) {
5551         xmlFreeParserInputBuffer(input);
5552         return (NULL);
5553     }
5554     reader-&gt;allocs |= XML_TEXTREADER_INPUT;
5555     xmlTextReaderSetup(reader, NULL, URL, encoding, options);
5556     return (reader);
5557 }
5558 
5559 /**
5560  * xmlReaderNewWalker:
5561  * @reader:  an XML reader
5562  * @doc:  a preparsed document
5563  *
5564  * Setup an xmltextReader to parse a preparsed XML document.
5565  * This reuses the existing @reader xmlTextReader.
5566  *
5567  * Returns 0 in case of success and -1 in case of error
5568  */
5569 int
5570 xmlReaderNewWalker(xmlTextReaderPtr reader, xmlDocPtr doc)
5571 {
5572     if (doc == NULL)
5573         return (-1);
5574     if (reader == NULL)
5575         return (-1);
5576 
5577     if (reader-&gt;input != NULL) {
5578         xmlFreeParserInputBuffer(reader-&gt;input);
5579     }
5580     if (reader-&gt;ctxt != NULL) {
5581     xmlCtxtReset(reader-&gt;ctxt);
5582     }
5583 
5584     reader-&gt;entNr = 0;
5585     reader-&gt;input = NULL;
5586     reader-&gt;mode = XML_TEXTREADER_MODE_INITIAL;
5587     reader-&gt;node = NULL;
5588     reader-&gt;curnode = NULL;
5589     reader-&gt;base = 0;
5590     reader-&gt;cur = 0;
5591     reader-&gt;allocs = XML_TEXTREADER_CTXT;
5592     reader-&gt;doc = doc;
5593     reader-&gt;state = XML_TEXTREADER_START;
5594     if (reader-&gt;dict == NULL) {
5595         if ((reader-&gt;ctxt != NULL) &amp;&amp; (reader-&gt;ctxt-&gt;dict != NULL))
5596         reader-&gt;dict = reader-&gt;ctxt-&gt;dict;
5597     else
5598         reader-&gt;dict = xmlDictCreate();
5599     }
5600     return(0);
5601 }
5602 
5603 /**
5604  * xmlReaderNewDoc:
5605  * @reader:  an XML reader
5606  * @cur:  a pointer to a zero terminated string
5607  * @URL:  the base URL to use for the document
5608  * @encoding:  the document encoding, or NULL
5609  * @options:  a combination of xmlParserOption
5610  *
5611  * Setup an xmltextReader to parse an XML in-memory document.
5612  * The parsing flags @options are a combination of xmlParserOption.
5613  * This reuses the existing @reader xmlTextReader.
5614  *
5615  * Returns 0 in case of success and -1 in case of error
5616  */
5617 int
5618 xmlReaderNewDoc(xmlTextReaderPtr reader, const xmlChar * cur,
5619                 const char *URL, const char *encoding, int options)
5620 {
5621 
5622     int len;
5623 
5624     if (cur == NULL)
5625         return (-1);
5626     if (reader == NULL)
5627         return (-1);
5628 
5629     len = xmlStrlen(cur);
5630     return (xmlReaderNewMemory(reader, (const char *)cur, len,
5631                                URL, encoding, options));
5632 }
5633 
5634 /**
5635  * xmlReaderNewFile:
5636  * @reader:  an XML reader
5637  * @filename:  a file or URL
5638  * @encoding:  the document encoding, or NULL
5639  * @options:  a combination of xmlParserOption
5640  *
5641  * parse an XML file from the filesystem or the network.
5642  * The parsing flags @options are a combination of xmlParserOption.
5643  * This reuses the existing @reader xmlTextReader.
5644  *
5645  * Returns 0 in case of success and -1 in case of error
5646  */
5647 int
5648 xmlReaderNewFile(xmlTextReaderPtr reader, const char *filename,
5649                  const char *encoding, int options)
5650 {
5651     xmlParserInputBufferPtr input;
5652 
5653     if (filename == NULL)
5654         return (-1);
5655     if (reader == NULL)
5656         return (-1);
5657 
5658     input =
5659         xmlParserInputBufferCreateFilename(filename,
5660                                            XML_CHAR_ENCODING_NONE);
5661     if (input == NULL)
5662         return (-1);
5663     return (xmlTextReaderSetup(reader, input, filename, encoding, options));
5664 }
5665 
5666 /**
5667  * xmlReaderNewMemory:
5668  * @reader:  an XML reader
5669  * @buffer:  a pointer to a char array
5670  * @size:  the size of the array
5671  * @URL:  the base URL to use for the document
5672  * @encoding:  the document encoding, or NULL
5673  * @options:  a combination of xmlParserOption
5674  *
5675  * Setup an xmltextReader to parse an XML in-memory document.
5676  * The parsing flags @options are a combination of xmlParserOption.
5677  * This reuses the existing @reader xmlTextReader.
5678  *
5679  * Returns 0 in case of success and -1 in case of error
5680  */
5681 int
5682 xmlReaderNewMemory(xmlTextReaderPtr reader, const char *buffer, int size,
5683                    const char *URL, const char *encoding, int options)
5684 {
5685     xmlParserInputBufferPtr input;
5686 
5687     if (reader == NULL)
5688         return (-1);
5689     if (buffer == NULL)
5690         return (-1);
5691 
5692     input = xmlParserInputBufferCreateStatic(buffer, size,
5693                                       XML_CHAR_ENCODING_NONE);
5694     if (input == NULL) {
5695         return (-1);
5696     }
5697     return (xmlTextReaderSetup(reader, input, URL, encoding, options));
5698 }
5699 
5700 /**
5701  * xmlReaderNewFd:
5702  * @reader:  an XML reader
5703  * @fd:  an open file descriptor
5704  * @URL:  the base URL to use for the document
5705  * @encoding:  the document encoding, or NULL
5706  * @options:  a combination of xmlParserOption
5707  *
5708  * Setup an xmltextReader to parse an XML from a file descriptor.
5709  * NOTE that the file descriptor will not be closed when the
5710  *      reader is closed or reset.
5711  * The parsing flags @options are a combination of xmlParserOption.
5712  * This reuses the existing @reader xmlTextReader.
5713  *
5714  * Returns 0 in case of success and -1 in case of error
5715  */
5716 int
5717 xmlReaderNewFd(xmlTextReaderPtr reader, int fd,
5718                const char *URL, const char *encoding, int options)
5719 {
5720     xmlParserInputBufferPtr input;
5721 
5722     if (fd &lt; 0)
5723         return (-1);
5724     if (reader == NULL)
5725         return (-1);
5726 
5727     input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
5728     if (input == NULL)
5729         return (-1);
5730     input-&gt;closecallback = NULL;
5731     return (xmlTextReaderSetup(reader, input, URL, encoding, options));
5732 }
5733 
5734 /**
5735  * xmlReaderNewIO:
5736  * @reader:  an XML reader
5737  * @ioread:  an I/O read function
5738  * @ioclose:  an I/O close function
5739  * @ioctx:  an I/O handler
5740  * @URL:  the base URL to use for the document
5741  * @encoding:  the document encoding, or NULL
5742  * @options:  a combination of xmlParserOption
5743  *
5744  * Setup an xmltextReader to parse an XML document from I/O functions
5745  * and source.
5746  * The parsing flags @options are a combination of xmlParserOption.
5747  * This reuses the existing @reader xmlTextReader.
5748  *
5749  * Returns 0 in case of success and -1 in case of error
5750  */
5751 int
5752 xmlReaderNewIO(xmlTextReaderPtr reader, xmlInputReadCallback ioread,
5753                xmlInputCloseCallback ioclose, void *ioctx,
5754                const char *URL, const char *encoding, int options)
5755 {
5756     xmlParserInputBufferPtr input;
5757 
5758     if (ioread == NULL)
5759         return (-1);
5760     if (reader == NULL)
5761         return (-1);
5762 
5763     input = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx,
5764                                          XML_CHAR_ENCODING_NONE);
5765     if (input == NULL) {
5766         if (ioclose != NULL)
5767             ioclose(ioctx);
5768         return (-1);
5769     }
5770     return (xmlTextReaderSetup(reader, input, URL, encoding, options));
5771 }
5772 
5773 /************************************************************************
5774  *                                  *
5775  *          Utilities                   *
5776  *                                  *
5777  ************************************************************************/
5778 #ifdef NOT_USED_YET
5779 
5780 /**
5781  * xmlBase64Decode:
5782  * @in:  the input buffer
5783  * @inlen:  the size of the input (in), the size read from it (out)
5784  * @to:  the output buffer
5785  * @tolen:  the size of the output (in), the size written to (out)
5786  *
5787  * Base64 decoder, reads from @in and save in @to
5788  * TODO: tell jody when this is actually exported
5789  *
5790  * Returns 0 if all the input was consumer, 1 if the Base64 end was reached,
5791  *         2 if there wasn&#39;t enough space on the output or -1 in case of error.
5792  */
5793 static int
5794 xmlBase64Decode(const unsigned char *in, unsigned long *inlen,
5795                 unsigned char *to, unsigned long *tolen)
5796 {
5797     unsigned long incur;        /* current index in in[] */
5798 
5799     unsigned long inblk;        /* last block index in in[] */
5800 
5801     unsigned long outcur;       /* current index in out[] */
5802 
5803     unsigned long inmax;        /* size of in[] */
5804 
5805     unsigned long outmax;       /* size of out[] */
5806 
5807     unsigned char cur;          /* the current value read from in[] */
5808 
5809     unsigned char intmp[4], outtmp[4];  /* temporary buffers for the convert */
5810 
5811     int nbintmp;                /* number of byte in intmp[] */
5812 
5813     int is_ignore;              /* cur should be ignored */
5814 
5815     int is_end = 0;             /* the end of the base64 was found */
5816 
5817     int retval = 1;
5818 
5819     int i;
5820 
5821     if ((in == NULL) || (inlen == NULL) || (to == NULL) || (tolen == NULL))
5822         return (-1);
5823 
5824     incur = 0;
5825     inblk = 0;
5826     outcur = 0;
5827     inmax = *inlen;
5828     outmax = *tolen;
5829     nbintmp = 0;
5830 
5831     while (1) {
5832         if (incur &gt;= inmax)
5833             break;
5834         cur = in[incur++];
5835         is_ignore = 0;
5836         if ((cur &gt;= &#39;A&#39;) &amp;&amp; (cur &lt;= &#39;Z&#39;))
5837             cur = cur - &#39;A&#39;;
5838         else if ((cur &gt;= &#39;a&#39;) &amp;&amp; (cur &lt;= &#39;z&#39;))
5839             cur = cur - &#39;a&#39; + 26;
5840         else if ((cur &gt;= &#39;0&#39;) &amp;&amp; (cur &lt;= &#39;9&#39;))
5841             cur = cur - &#39;0&#39; + 52;
5842         else if (cur == &#39;+&#39;)
5843             cur = 62;
5844         else if (cur == &#39;/&#39;)
5845             cur = 63;
5846         else if (cur == &#39;.&#39;)
5847             cur = 0;
5848         else if (cur == &#39;=&#39;)    /*no op , end of the base64 stream */
5849             is_end = 1;
5850         else {
5851             is_ignore = 1;
5852             if (nbintmp == 0)
5853                 inblk = incur;
5854         }
5855 
5856         if (!is_ignore) {
5857             int nbouttmp = 3;
5858 
5859             int is_break = 0;
5860 
5861             if (is_end) {
5862                 if (nbintmp == 0)
5863                     break;
5864                 if ((nbintmp == 1) || (nbintmp == 2))
5865                     nbouttmp = 1;
5866                 else
5867                     nbouttmp = 2;
5868                 nbintmp = 3;
5869                 is_break = 1;
5870             }
5871             intmp[nbintmp++] = cur;
5872             /*
5873              * if intmp is full, push the 4byte sequence as a 3 byte
5874              * sequence out
5875              */
5876             if (nbintmp == 4) {
5877                 nbintmp = 0;
5878                 outtmp[0] = (intmp[0] &lt;&lt; 2) | ((intmp[1] &amp; 0x30) &gt;&gt; 4);
5879                 outtmp[1] =
5880                     ((intmp[1] &amp; 0x0F) &lt;&lt; 4) | ((intmp[2] &amp; 0x3C) &gt;&gt; 2);
5881                 outtmp[2] = ((intmp[2] &amp; 0x03) &lt;&lt; 6) | (intmp[3] &amp; 0x3F);
5882                 if (outcur + 3 &gt;= outmax) {
5883                     retval = 2;
5884                     break;
5885                 }
5886 
5887                 for (i = 0; i &lt; nbouttmp; i++)
5888                     to[outcur++] = outtmp[i];
5889                 inblk = incur;
5890             }
5891 
5892             if (is_break) {
5893                 retval = 0;
5894                 break;
5895             }
5896         }
5897     }
5898 
5899     *tolen = outcur;
5900     *inlen = inblk;
5901     return (retval);
5902 }
5903 
5904 /*
5905  * Test routine for the xmlBase64Decode function
5906  */
5907 #if 0
5908 int
5909 main(int argc, char **argv)
5910 {
5911     char *input = &quot;  VW4 gcGV0        \n      aXQgdGVzdCAuCg== &quot;;
5912 
5913     char output[100];
5914 
5915     char output2[100];
5916 
5917     char output3[100];
5918 
5919     unsigned long inlen = strlen(input);
5920 
5921     unsigned long outlen = 100;
5922 
5923     int ret;
5924 
5925     unsigned long cons, tmp, tmp2, prod;
5926 
5927     /*
5928      * Direct
5929      */
5930     ret = xmlBase64Decode(input, &amp;inlen, output, &amp;outlen);
5931 
5932     output[outlen] = 0;
5933     printf(&quot;ret: %d, inlen: %ld , outlen: %ld, output: &#39;%s&#39;\n&quot;, ret, inlen,
5934            outlen, output)indent: Standard input:179: Error:Unmatched #endif
5935 ;
5936 
5937     /*
5938      * output chunking
5939      */
5940     cons = 0;
5941     prod = 0;
5942     while (cons &lt; inlen) {
5943         tmp = 5;
5944         tmp2 = inlen - cons;
5945 
5946         printf(&quot;%ld %ld\n&quot;, cons, prod);
5947         ret = xmlBase64Decode(&amp;input[cons], &amp;tmp2, &amp;output2[prod], &amp;tmp);
5948         cons += tmp2;
5949         prod += tmp;
5950         printf(&quot;%ld %ld\n&quot;, cons, prod);
5951     }
5952     output2[outlen] = 0;
5953     printf(&quot;ret: %d, cons: %ld , prod: %ld, output: &#39;%s&#39;\n&quot;, ret, cons,
5954            prod, output2);
5955 
5956     /*
5957      * input chunking
5958      */
5959     cons = 0;
5960     prod = 0;
5961     while (cons &lt; inlen) {
5962         tmp = 100 - prod;
5963         tmp2 = inlen - cons;
5964         if (tmp2 &gt; 5)
5965             tmp2 = 5;
5966 
5967         printf(&quot;%ld %ld\n&quot;, cons, prod);
5968         ret = xmlBase64Decode(&amp;input[cons], &amp;tmp2, &amp;output3[prod], &amp;tmp);
5969         cons += tmp2;
5970         prod += tmp;
5971         printf(&quot;%ld %ld\n&quot;, cons, prod);
5972     }
5973     output3[outlen] = 0;
5974     printf(&quot;ret: %d, cons: %ld , prod: %ld, output: &#39;%s&#39;\n&quot;, ret, cons,
5975            prod, output3);
5976     return (0);
5977 
5978 }
5979 #endif
5980 #endif /* NOT_USED_YET */
5981 #define bottom_xmlreader
5982 #include &quot;elfgcchack.h&quot;
5983 #endif /* LIBXML_READER_ENABLED */
<a name="32" id="anc32"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="32" type="hidden" />
</body>
</html>
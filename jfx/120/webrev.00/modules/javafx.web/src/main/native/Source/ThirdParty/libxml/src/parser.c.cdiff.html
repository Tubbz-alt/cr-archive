<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/parser.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="nanohttp.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="parserInternals.c.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/parser.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 94,10 ***</span>
<span class="line-new-header">--- 94,16 ---</span>
  xmlCreateEntityParserCtxtInternal(const xmlChar *URL, const xmlChar *ID,
                        const xmlChar *base, xmlParserCtxtPtr pctx);
  
  static void xmlHaltParser(xmlParserCtxtPtr ctxt);
  
<span class="line-added">+ static int</span>
<span class="line-added">+ xmlParseElementStart(xmlParserCtxtPtr ctxt);</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void</span>
<span class="line-added">+ xmlParseElementEnd(xmlParserCtxtPtr ctxt);</span>
<span class="line-added">+ </span>
  /************************************************************************
   *                                  *
   *  Arbitrary limits set in the parser. See XML_PARSE_HUGE      *
   *                                  *
   ************************************************************************/
</pre>
<hr />
<pre>
<span class="line-old-header">*** 106,11 ***</span>
  #define XML_PARSER_LOT_ENTITY 5000
  
  /*
   * XML_PARSER_NON_LINEAR is the threshold where the ratio of parsed entity
   *    replacement over the size in byte of the input indicates that you have
<span class="line-modified">!  *    and eponential behaviour. A value of 10 correspond to at least 3 entity</span>
   *    replacement per byte of input.
   */
  #define XML_PARSER_NON_LINEAR 10
  
  /*
<span class="line-new-header">--- 112,11 ---</span>
  #define XML_PARSER_LOT_ENTITY 5000
  
  /*
   * XML_PARSER_NON_LINEAR is the threshold where the ratio of parsed entity
   *    replacement over the size in byte of the input indicates that you have
<span class="line-modified">!  *    and exponential behaviour. A value of 10 correspond to at least 3 entity</span>
   *    replacement per byte of input.
   */
  #define XML_PARSER_NON_LINEAR 10
  
  /*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 138,11 ***</span>
       * entities problems
       */
      if ((ent != NULL) &amp;&amp; (ent-&gt;etype != XML_INTERNAL_PREDEFINED_ENTITY) &amp;&amp;
      (ent-&gt;content != NULL) &amp;&amp; (ent-&gt;checked == 0) &amp;&amp;
      (ctxt-&gt;errNo != XML_ERR_ENTITY_LOOP)) {
<span class="line-modified">!     unsigned long oldnbent = ctxt-&gt;nbentities;</span>
      xmlChar *rep;
  
      ent-&gt;checked = 1;
  
          ++ctxt-&gt;depth;
<span class="line-new-header">--- 144,11 ---</span>
       * entities problems
       */
      if ((ent != NULL) &amp;&amp; (ent-&gt;etype != XML_INTERNAL_PREDEFINED_ENTITY) &amp;&amp;
      (ent-&gt;content != NULL) &amp;&amp; (ent-&gt;checked == 0) &amp;&amp;
      (ctxt-&gt;errNo != XML_ERR_ENTITY_LOOP)) {
<span class="line-modified">!     unsigned long oldnbent = ctxt-&gt;nbentities, diff;</span>
      xmlChar *rep;
  
      ent-&gt;checked = 1;
  
          ++ctxt-&gt;depth;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 151,11 ***</span>
          --ctxt-&gt;depth;
      if ((rep == NULL) || (ctxt-&gt;errNo == XML_ERR_ENTITY_LOOP)) {
          ent-&gt;content[0] = 0;
      }
  
<span class="line-modified">!     ent-&gt;checked = (ctxt-&gt;nbentities - oldnbent + 1) * 2;</span>
      if (rep != NULL) {
          if (xmlStrchr(rep, &#39;&lt;&#39;))
          ent-&gt;checked |= 1;
          xmlFree(rep);
          rep = NULL;
<span class="line-new-header">--- 157,14 ---</span>
          --ctxt-&gt;depth;
      if ((rep == NULL) || (ctxt-&gt;errNo == XML_ERR_ENTITY_LOOP)) {
          ent-&gt;content[0] = 0;
      }
  
<span class="line-modified">!         diff = ctxt-&gt;nbentities - oldnbent + 1;</span>
<span class="line-added">+         if (diff &gt; INT_MAX / 2)</span>
<span class="line-added">+             diff = INT_MAX / 2;</span>
<span class="line-added">+     ent-&gt;checked = diff * 2;</span>
      if (rep != NULL) {
          if (xmlStrchr(rep, &#39;&lt;&#39;))
          ent-&gt;checked |= 1;
          xmlFree(rep);
          rep = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1058,11 ***</span>
  
  /**
   * xmlDetectSAX2:
   * @ctxt:  an XML parser context
   *
<span class="line-modified">!  * Do the SAX2 detection and specific intialization</span>
   */
  static void
  xmlDetectSAX2(xmlParserCtxtPtr ctxt) {
      if (ctxt == NULL) return;
  #ifdef LIBXML_SAX1_ENABLED
<span class="line-new-header">--- 1067,11 ---</span>
  
  /**
   * xmlDetectSAX2:
   * @ctxt:  an XML parser context
   *
<span class="line-modified">!  * Do the SAX2 detection and specific initialization</span>
   */
  static void
  xmlDetectSAX2(xmlParserCtxtPtr ctxt) {
      if (ctxt == NULL) return;
  #ifdef LIBXML_SAX1_ENABLED
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1390,11 ***</span>
   * [35] ISO639Code ::= ([a-z] | [A-Z]) ([a-z] | [A-Z])
   * [36] IanaCode ::= (&#39;i&#39; | &#39;I&#39;) &#39;-&#39; ([a-z] | [A-Z])+
   * [37] UserCode ::= (&#39;x&#39; | &#39;X&#39;) &#39;-&#39; ([a-z] | [A-Z])+
   * [38] Subcode ::= ([a-z] | [A-Z])+
   *
<span class="line-modified">!  * The current REC reference the sucessors of RFC 1766, currently 5646</span>
   *
   * http://www.rfc-editor.org/rfc/rfc5646.txt
   * langtag       = language
   *                 [&quot;-&quot; script]
   *                 [&quot;-&quot; region]
<span class="line-new-header">--- 1399,11 ---</span>
   * [35] ISO639Code ::= ([a-z] | [A-Z]) ([a-z] | [A-Z])
   * [36] IanaCode ::= (&#39;i&#39; | &#39;I&#39;) &#39;-&#39; ([a-z] | [A-Z])+
   * [37] UserCode ::= (&#39;x&#39; | &#39;X&#39;) &#39;-&#39; ([a-z] | [A-Z])+
   * [38] Subcode ::= ([a-z] | [A-Z])+
   *
<span class="line-modified">!  * The current REC reference the successors of RFC 1766, currently 5646</span>
   *
   * http://www.rfc-editor.org/rfc/rfc5646.txt
   * langtag       = language
   *                 [&quot;-&quot; script]
   *                 [&quot;-&quot; region]
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1817,11 ***</span>
      ret = ctxt-&gt;nodeTab[ctxt-&gt;nodeNr];
      ctxt-&gt;nodeTab[ctxt-&gt;nodeNr] = NULL;
      return (ret);
  }
  
<span class="line-removed">- #ifdef LIBXML_PUSH_ENABLED</span>
  /**
   * nameNsPush:
   * @ctxt:  an XML parser context
   * @value:  the element name
   * @prefix:  the element prefix
<span class="line-new-header">--- 1826,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1853,10 ***</span>
<span class="line-new-header">--- 1861,15 ---</span>
          if (tmp2 == NULL) {
          ctxt-&gt;nameMax /= 2;
          goto mem_error;
          }
      ctxt-&gt;pushTab = tmp2;
<span class="line-added">+     } else if (ctxt-&gt;pushTab == NULL) {</span>
<span class="line-added">+         ctxt-&gt;pushTab = (void **) xmlMalloc(ctxt-&gt;nameMax * 3 *</span>
<span class="line-added">+                                             sizeof(ctxt-&gt;pushTab[0]));</span>
<span class="line-added">+         if (ctxt-&gt;pushTab == NULL)</span>
<span class="line-added">+             goto mem_error;</span>
      }
      ctxt-&gt;nameTab[ctxt-&gt;nameNr] = value;
      ctxt-&gt;name = value;
      ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3] = (void *) prefix;
      ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 + 1] = (void *) URI;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1864,10 ***</span>
<span class="line-new-header">--- 1877,11 ---</span>
      return (ctxt-&gt;nameNr++);
  mem_error:
      xmlErrMemory(ctxt, NULL);
      return (-1);
  }
<span class="line-added">+ #ifdef LIBXML_PUSH_ENABLED</span>
  /**
   * nameNsPop:
   * @ctxt: an XML parser context
   *
   * Pops the top element/prefix/URI name from the name stack
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2073,15 ***</span>
  #define GROW if ((ctxt-&gt;progressive == 0) &amp;&amp;                \
           (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; INPUT_CHUNK))   \
      xmlGROW (ctxt);
  
  static void xmlGROW (xmlParserCtxtPtr ctxt) {
<span class="line-modified">!     unsigned long curEnd = ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur;</span>
<span class="line-modified">!     unsigned long curBase = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;</span>
  
<span class="line-modified">!     if (((curEnd &gt; (unsigned long) XML_MAX_LOOKUP_LIMIT) ||</span>
<span class="line-modified">!          (curBase &gt; (unsigned long) XML_MAX_LOOKUP_LIMIT)) &amp;&amp;</span>
           ((ctxt-&gt;input-&gt;buf) &amp;&amp;
            (ctxt-&gt;input-&gt;buf-&gt;readcallback != xmlInputReadCallbackNop)) &amp;&amp;
          ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
          xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, &quot;Huge input lookup&quot;);
          xmlHaltParser(ctxt);
<span class="line-new-header">--- 2087,15 ---</span>
  #define GROW if ((ctxt-&gt;progressive == 0) &amp;&amp;                \
           (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; INPUT_CHUNK))   \
      xmlGROW (ctxt);
  
  static void xmlGROW (xmlParserCtxtPtr ctxt) {
<span class="line-modified">!     ptrdiff_t curEnd = ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur;</span>
<span class="line-modified">!     ptrdiff_t curBase = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;</span>
  
<span class="line-modified">!     if (((curEnd &gt; XML_MAX_LOOKUP_LIMIT) ||</span>
<span class="line-modified">!          (curBase &gt; XML_MAX_LOOKUP_LIMIT)) &amp;&amp;</span>
           ((ctxt-&gt;input-&gt;buf) &amp;&amp;
            (ctxt-&gt;input-&gt;buf-&gt;readcallback != xmlInputReadCallbackNop)) &amp;&amp;
          ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
          xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, &quot;Huge input lookup&quot;);
          xmlHaltParser(ctxt);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2279,13 ***</span>
   *
   * Returns the value parsed (as an int), 0 in case of error
   */
  int
  xmlParseCharRef(xmlParserCtxtPtr ctxt) {
<span class="line-modified">!     unsigned int val = 0;</span>
      int count = 0;
<span class="line-removed">-     unsigned int outofrange = 0;</span>
  
      /*
       * Using RAW/CUR/NEXT is okay since we are working on ASCII range here
       */
      if ((RAW == &#39;&amp;&#39;) &amp;&amp; (NXT(1) == &#39;#&#39;) &amp;&amp;
<span class="line-new-header">--- 2293,12 ---</span>
   *
   * Returns the value parsed (as an int), 0 in case of error
   */
  int
  xmlParseCharRef(xmlParserCtxtPtr ctxt) {
<span class="line-modified">!     int val = 0;</span>
      int count = 0;
  
      /*
       * Using RAW/CUR/NEXT is okay since we are working on ASCII range here
       */
      if ((RAW == &#39;&amp;&#39;) &amp;&amp; (NXT(1) == &#39;#&#39;) &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2308,12 ***</span>
          else {
          xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);
          val = 0;
          break;
          }
<span class="line-modified">!         if (val &gt; 0x10FFFF)</span>
<span class="line-modified">!             outofrange = val;</span>
  
          NEXT;
          count++;
      }
      if (RAW == &#39;;&#39;) {
<span class="line-new-header">--- 2321,12 ---</span>
          else {
          xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);
          val = 0;
          break;
          }
<span class="line-modified">!         if (val &gt; 0x110000)</span>
<span class="line-modified">!             val = 0x110000;</span>
  
          NEXT;
          count++;
      }
      if (RAW == &#39;;&#39;) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2337,12 ***</span>
          else {
          xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);
          val = 0;
          break;
          }
<span class="line-modified">!         if (val &gt; 0x10FFFF)</span>
<span class="line-modified">!             outofrange = val;</span>
  
          NEXT;
          count++;
      }
      if (RAW == &#39;;&#39;) {
<span class="line-new-header">--- 2350,12 ---</span>
          else {
          xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);
          val = 0;
          break;
          }
<span class="line-modified">!         if (val &gt; 0x110000)</span>
<span class="line-modified">!             val = 0x110000;</span>
  
          NEXT;
          count++;
      }
      if (RAW == &#39;;&#39;) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2358,11 ***</span>
      /*
       * [ WFC: Legal Character ]
       * Characters referred to using character references must match the
       * production for Char.
       */
<span class="line-modified">!     if ((IS_CHAR(val) &amp;&amp; (outofrange == 0))) {</span>
          return(val);
      } else {
          xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
                            &quot;xmlParseCharRef: invalid xmlChar value %d\n&quot;,
                        val);
<span class="line-new-header">--- 2371,15 ---</span>
      /*
       * [ WFC: Legal Character ]
       * Characters referred to using character references must match the
       * production for Char.
       */
<span class="line-modified">!     if (val &gt;= 0x110000) {</span>
<span class="line-added">+         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,</span>
<span class="line-added">+                 &quot;xmlParseCharRef: character reference out of bounds\n&quot;,</span>
<span class="line-added">+             val);</span>
<span class="line-added">+     } else if (IS_CHAR(val)) {</span>
          return(val);
      } else {
          xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
                            &quot;xmlParseCharRef: invalid xmlChar value %d\n&quot;,
                        val);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2390,12 ***</span>
   */
  static int
  xmlParseStringCharRef(xmlParserCtxtPtr ctxt, const xmlChar **str) {
      const xmlChar *ptr;
      xmlChar cur;
<span class="line-modified">!     unsigned int val = 0;</span>
<span class="line-removed">-     unsigned int outofrange = 0;</span>
  
      if ((str == NULL) || (*str == NULL)) return(0);
      ptr = *str;
      cur = *ptr;
      if ((cur == &#39;&amp;&#39;) &amp;&amp; (ptr[1] == &#39;#&#39;) &amp;&amp; (ptr[2] == &#39;x&#39;)) {
<span class="line-new-header">--- 2407,11 ---</span>
   */
  static int
  xmlParseStringCharRef(xmlParserCtxtPtr ctxt, const xmlChar **str) {
      const xmlChar *ptr;
      xmlChar cur;
<span class="line-modified">!     int val = 0;</span>
  
      if ((str == NULL) || (*str == NULL)) return(0);
      ptr = *str;
      cur = *ptr;
      if ((cur == &#39;&amp;&#39;) &amp;&amp; (ptr[1] == &#39;#&#39;) &amp;&amp; (ptr[2] == &#39;x&#39;)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2411,12 ***</span>
          else {
          xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);
          val = 0;
          break;
          }
<span class="line-modified">!         if (val &gt; 0x10FFFF)</span>
<span class="line-modified">!             outofrange = val;</span>
  
          ptr++;
          cur = *ptr;
      }
      if (cur == &#39;;&#39;)
<span class="line-new-header">--- 2427,12 ---</span>
          else {
          xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);
          val = 0;
          break;
          }
<span class="line-modified">!         if (val &gt; 0x110000)</span>
<span class="line-modified">!             val = 0x110000;</span>
  
          ptr++;
          cur = *ptr;
      }
      if (cur == &#39;;&#39;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2430,12 ***</span>
          else {
          xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);
          val = 0;
          break;
          }
<span class="line-modified">!         if (val &gt; 0x10FFFF)</span>
<span class="line-modified">!             outofrange = val;</span>
  
          ptr++;
          cur = *ptr;
      }
      if (cur == &#39;;&#39;)
<span class="line-new-header">--- 2446,12 ---</span>
          else {
          xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);
          val = 0;
          break;
          }
<span class="line-modified">!         if (val &gt; 0x110000)</span>
<span class="line-modified">!             val = 0x110000;</span>
  
          ptr++;
          cur = *ptr;
      }
      if (cur == &#39;;&#39;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2449,11 ***</span>
      /*
       * [ WFC: Legal Character ]
       * Characters referred to using character references must match the
       * production for Char.
       */
<span class="line-modified">!     if ((IS_CHAR(val) &amp;&amp; (outofrange == 0))) {</span>
          return(val);
      } else {
          xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
                &quot;xmlParseStringCharRef: invalid xmlChar value %d\n&quot;,
                val);
<span class="line-new-header">--- 2465,15 ---</span>
      /*
       * [ WFC: Legal Character ]
       * Characters referred to using character references must match the
       * production for Char.
       */
<span class="line-modified">!     if (val &gt;= 0x110000) {</span>
<span class="line-added">+         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,</span>
<span class="line-added">+                 &quot;xmlParseStringCharRef: character reference out of bounds\n&quot;,</span>
<span class="line-added">+                 val);</span>
<span class="line-added">+     } else if (IS_CHAR(val)) {</span>
          return(val);
      } else {
          xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
                &quot;xmlParseStringCharRef: invalid xmlChar value %d\n&quot;,
                val);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2700,11 ***</span>
          if (ent != NULL) {
                  if (ent-&gt;content == NULL) {
              /*
               * Note: external parsed entities will not be loaded,
               * it is not required for a non-validating parser to
<span class="line-modified">!              * complete external PEreferences coming from the</span>
               * internal subset
               */
              if (((ctxt-&gt;options &amp; XML_PARSE_NOENT) != 0) ||
              ((ctxt-&gt;options &amp; XML_PARSE_DTDVALID) != 0) ||
              (ctxt-&gt;validate != 0)) {
<span class="line-new-header">--- 2720,11 ---</span>
          if (ent != NULL) {
                  if (ent-&gt;content == NULL) {
              /*
               * Note: external parsed entities will not be loaded,
               * it is not required for a non-validating parser to
<span class="line-modified">!              * complete external PEReferences coming from the</span>
               * internal subset
               */
              if (((ctxt-&gt;options &amp; XML_PARSE_NOENT) != 0) ||
              ((ctxt-&gt;options &amp; XML_PARSE_DTDVALID) != 0) ||
              (ctxt-&gt;validate != 0)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3364,11 ***</span>
      if (c == 0) {
          count = 0;
          /*
           * when shrinking to extend the buffer we really need to preserve
           * the part of the name we already parsed. Hence rolling back
<span class="line-modified">!          * by current lenght.</span>
           */
          ctxt-&gt;input-&gt;cur -= l;
          GROW;
              if (ctxt-&gt;instate == XML_PARSER_EOF)
                  return(NULL);
<span class="line-new-header">--- 3384,11 ---</span>
      if (c == 0) {
          count = 0;
          /*
           * when shrinking to extend the buffer we really need to preserve
           * the part of the name we already parsed. Hence rolling back
<span class="line-modified">!          * by current length.</span>
           */
          ctxt-&gt;input-&gt;cur -= l;
          GROW;
              if (ctxt-&gt;instate == XML_PARSER_EOF)
                  return(NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3833,11 ***</span>
  
  /**
   * xmlParseAttValueComplex:
   * @ctxt:  an XML parser context
   * @len:   the resulting attribute len
<span class="line-modified">!  * @normalize:  wether to apply the inner normalization</span>
   *
   * parse a value for an attribute, this is the fallback function
   * of xmlParseAttValue() when the attribute parsing requires handling
   * of non-ASCII characters, or normalization compaction.
   *
<span class="line-new-header">--- 3853,11 ---</span>
  
  /**
   * xmlParseAttValueComplex:
   * @ctxt:  an XML parser context
   * @len:   the resulting attribute len
<span class="line-modified">!  * @normalize:  whether to apply the inner normalization</span>
   *
   * parse a value for an attribute, this is the fallback function
   * of xmlParseAttValue() when the attribute parsing requires handling
   * of non-ASCII characters, or normalization compaction.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3982,18 ***</span>
               * This may look absurd but is needed to detect
               * entities problems
               */
              if ((ent-&gt;etype != XML_INTERNAL_PREDEFINED_ENTITY) &amp;&amp;
              (ent-&gt;content != NULL) &amp;&amp; (ent-&gt;checked == 0)) {
<span class="line-modified">!             unsigned long oldnbent = ctxt-&gt;nbentities;</span>
  
              ++ctxt-&gt;depth;
              rep = xmlStringDecodeEntities(ctxt, ent-&gt;content,
                            XML_SUBSTITUTE_REF, 0, 0, 0);
              --ctxt-&gt;depth;
  
<span class="line-modified">!             ent-&gt;checked = (ctxt-&gt;nbentities - oldnbent + 1) * 2;</span>
              if (rep != NULL) {
                  if (xmlStrchr(rep, &#39;&lt;&#39;))
                      ent-&gt;checked |= 1;
                  xmlFree(rep);
                  rep = NULL;
<span class="line-new-header">--- 4002,21 ---</span>
               * This may look absurd but is needed to detect
               * entities problems
               */
              if ((ent-&gt;etype != XML_INTERNAL_PREDEFINED_ENTITY) &amp;&amp;
              (ent-&gt;content != NULL) &amp;&amp; (ent-&gt;checked == 0)) {
<span class="line-modified">!             unsigned long oldnbent = ctxt-&gt;nbentities, diff;</span>
  
              ++ctxt-&gt;depth;
              rep = xmlStringDecodeEntities(ctxt, ent-&gt;content,
                            XML_SUBSTITUTE_REF, 0, 0, 0);
              --ctxt-&gt;depth;
  
<span class="line-modified">!                         diff = ctxt-&gt;nbentities - oldnbent + 1;</span>
<span class="line-added">+                         if (diff &gt; INT_MAX / 2)</span>
<span class="line-added">+                             diff = INT_MAX / 2;</span>
<span class="line-added">+                         ent-&gt;checked = diff * 2;</span>
              if (rep != NULL) {
                  if (xmlStrchr(rep, &#39;&lt;&#39;))
                      ent-&gt;checked |= 1;
                  xmlFree(rep);
                  rep = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4057,11 ***</span>
      } else
      NEXT;
  
      /*
       * There we potentially risk an overflow, don&#39;t allow attribute value of
<span class="line-modified">!      * length more than INT_MAX it is a very reasonnable assumption !</span>
       */
      if (len &gt;= INT_MAX) {
          xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
                         &quot;AttValue length too long\n&quot;);
          goto mem_error;
<span class="line-new-header">--- 4080,11 ---</span>
      } else
      NEXT;
  
      /*
       * There we potentially risk an overflow, don&#39;t allow attribute value of
<span class="line-modified">!      * length more than INT_MAX it is a very reasonable assumption !</span>
       */
      if (len &gt;= INT_MAX) {
          xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
                         &quot;AttValue length too long\n&quot;);
          goto mem_error;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4662,11 ***</span>
  
  /**
   * xmlParseCommentComplex:
   * @ctxt:  an XML parser context
   * @buf:  the already parsed part of the buffer
<span class="line-modified">!  * @len:  number of bytes filles in the buffer</span>
   * @size:  allocated size of the buffer
   *
   * Skip an XML (SGML) comment &lt;!-- .... --&gt;
   *  The spec says that &quot;For compatibility, the string &quot;--&quot; (double-hyphen)
   *  must not occur within comments. &quot;
<span class="line-new-header">--- 4685,11 ---</span>
  
  /**
   * xmlParseCommentComplex:
   * @ctxt:  an XML parser context
   * @buf:  the already parsed part of the buffer
<span class="line-modified">!  * @len:  number of bytes in the buffer</span>
   * @size:  allocated size of the buffer
   *
   * Skip an XML (SGML) comment &lt;!-- .... --&gt;
   *  The spec says that &quot;For compatibility, the string &quot;--&quot; (double-hyphen)
   *  must not occur within comments. &quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4953,10 ***</span>
<span class="line-new-header">--- 4976,14 ---</span>
                                        &quot;&lt;!--%.50s\n&quot;,
                        buf);
          } else
              xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
                                &quot;Double hyphen within comment\n&quot;, NULL);
<span class="line-added">+                 if (ctxt-&gt;instate == XML_PARSER_EOF) {</span>
<span class="line-added">+                     xmlFree(buf);</span>
<span class="line-added">+                     return;</span>
<span class="line-added">+                 }</span>
          in++;
          ctxt-&gt;input-&gt;col++;
          }
          in++;
          ctxt-&gt;input-&gt;col++;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5083,11 ***</span>
   *
   * parse an XML Processing Instruction.
   *
   * [16] PI ::= &#39;&lt;?&#39; PITarget (S (Char* - (Char* &#39;?&gt;&#39; Char*)))? &#39;?&gt;&#39;
   *
<span class="line-modified">!  * The processing is transfered to SAX once parsed.</span>
   */
  
  void
  xmlParsePI(xmlParserCtxtPtr ctxt) {
      xmlChar *buf = NULL;
<span class="line-new-header">--- 5110,11 ---</span>
   *
   * parse an XML Processing Instruction.
   *
   * [16] PI ::= &#39;&lt;?&#39; PITarget (S (Char* - (Char* &#39;?&gt;&#39; Char*)))? &#39;?&gt;&#39;
   *
<span class="line-modified">!  * The processing is transferred to SAX once parsed.</span>
   */
  
  void
  xmlParsePI(xmlParserCtxtPtr ctxt) {
      xmlChar *buf = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5499,11 ***</span>
              ctxt-&gt;sax-&gt;entityDecl(ctxt-&gt;userData, name,
                      XML_EXTERNAL_GENERAL_PARSED_ENTITY,
                      literal, URI, NULL);
              /*
               * For expat compatibility in SAX mode.
<span class="line-modified">!              * assuming the entity repalcement was asked for</span>
               */
              if ((ctxt-&gt;replaceEntities != 0) &amp;&amp;
              ((ctxt-&gt;myDoc == NULL) ||
              (xmlStrEqual(ctxt-&gt;myDoc-&gt;version, SAX_COMPAT_MODE)))) {
              if (ctxt-&gt;myDoc == NULL) {
<span class="line-new-header">--- 5526,11 ---</span>
              ctxt-&gt;sax-&gt;entityDecl(ctxt-&gt;userData, name,
                      XML_EXTERNAL_GENERAL_PARSED_ENTITY,
                      literal, URI, NULL);
              /*
               * For expat compatibility in SAX mode.
<span class="line-modified">!              * assuming the entity replacement was asked for</span>
               */
              if ((ctxt-&gt;replaceEntities != 0) &amp;&amp;
              ((ctxt-&gt;myDoc == NULL) ||
              (xmlStrEqual(ctxt-&gt;myDoc-&gt;version, SAX_COMPAT_MODE)))) {
              if (ctxt-&gt;myDoc == NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6609,153 ***</span>
   * [65] Ignore ::= Char* - (Char* (&#39;&lt;![&#39; | &#39;]]&gt;&#39;) Char*)
   */
  
  static void
  xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
      int id = ctxt-&gt;input-&gt;id;
  
      SKIP(3);
      SKIP_BLANKS;
      if (CMP7(CUR_PTR, &#39;I&#39;, &#39;N&#39;, &#39;C&#39;, &#39;L&#39;, &#39;U&#39;, &#39;D&#39;, &#39;E&#39;)) {
      SKIP(7);
      SKIP_BLANKS;
      if (RAW != &#39;[&#39;) {
          xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
          xmlHaltParser(ctxt);
<span class="line-modified">!         return;</span>
<span class="line-modified">!     } else {</span>
          if (ctxt-&gt;input-&gt;id != id) {
          xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
<span class="line-modified">!                            &quot;All markup of the conditional section is not&quot;</span>
<span class="line-modified">!                                &quot; in the same entity\n&quot;);</span>
          }
          NEXT;
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (xmlParserDebugEntities) {</span>
<span class="line-removed">-         if ((ctxt-&gt;input != NULL) &amp;&amp; (ctxt-&gt;input-&gt;filename))</span>
<span class="line-removed">-         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed">-             &quot;%s(%d): &quot;, ctxt-&gt;input-&gt;filename,</span>
<span class="line-removed">-             ctxt-&gt;input-&gt;line);</span>
<span class="line-removed">-         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed">-             &quot;Entering INCLUDE Conditional Section\n&quot;);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!         SKIP_BLANKS;</span>
<span class="line-modified">!         GROW;</span>
<span class="line-removed">-     while (((RAW != 0) &amp;&amp; ((RAW != &#39;]&#39;) || (NXT(1) != &#39;]&#39;) ||</span>
<span class="line-removed">-             (NXT(2) != &#39;&gt;&#39;))) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF)) {</span>
<span class="line-removed">-         const xmlChar *check = CUR_PTR;</span>
<span class="line-removed">-         unsigned int cons = ctxt-&gt;input-&gt;consumed;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {</span>
<span class="line-removed">-         xmlParseConditionalSections(ctxt);</span>
<span class="line-removed">-         } else</span>
<span class="line-removed">-         xmlParseMarkupDecl(ctxt);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             SKIP_BLANKS;</span>
<span class="line-removed">-             GROW;</span>
  
<span class="line-modified">!         if ((CUR_PTR == check) &amp;&amp; (cons == ctxt-&gt;input-&gt;consumed)) {</span>
<span class="line-modified">!         xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);</span>
<span class="line-modified">!         xmlHaltParser(ctxt);</span>
<span class="line-modified">!         break;</span>
          }
      }
<span class="line-modified">!     if (xmlParserDebugEntities) {</span>
<span class="line-modified">!         if ((ctxt-&gt;input != NULL) &amp;&amp; (ctxt-&gt;input-&gt;filename))</span>
<span class="line-removed">-         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed">-             &quot;%s(%d): &quot;, ctxt-&gt;input-&gt;filename,</span>
<span class="line-removed">-             ctxt-&gt;input-&gt;line);</span>
<span class="line-removed">-         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed">-             &quot;Leaving INCLUDE Conditional Section\n&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      } else if (CMP6(CUR_PTR, &#39;I&#39;, &#39;G&#39;, &#39;N&#39;, &#39;O&#39;, &#39;R&#39;, &#39;E&#39;)) {
      int state;
      xmlParserInputState instate;
<span class="line-modified">!     int depth = 0;</span>
  
      SKIP(6);
      SKIP_BLANKS;
      if (RAW != &#39;[&#39;) {
          xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
          xmlHaltParser(ctxt);
<span class="line-modified">!         return;</span>
<span class="line-modified">!     } else {</span>
          if (ctxt-&gt;input-&gt;id != id) {
          xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
<span class="line-modified">!                            &quot;All markup of the conditional section is not&quot;</span>
<span class="line-modified">!                                &quot; in the same entity\n&quot;);</span>
          }
          NEXT;
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (xmlParserDebugEntities) {</span>
<span class="line-removed">-         if ((ctxt-&gt;input != NULL) &amp;&amp; (ctxt-&gt;input-&gt;filename))</span>
<span class="line-removed">-         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed">-             &quot;%s(%d): &quot;, ctxt-&gt;input-&gt;filename,</span>
<span class="line-removed">-             ctxt-&gt;input-&gt;line);</span>
<span class="line-removed">-         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed">-             &quot;Entering IGNORE Conditional Section\n&quot;);</span>
<span class="line-removed">-     }</span>
  
      /*
<span class="line-modified">!      * Parse up to the end of the conditional section</span>
<span class="line-modified">!      * But disable SAX event generating DTD building in the meantime</span>
       */
      state = ctxt-&gt;disableSAX;
      instate = ctxt-&gt;instate;
      if (ctxt-&gt;recovery == 0) ctxt-&gt;disableSAX = 1;
      ctxt-&gt;instate = XML_PARSER_IGNORE;
  
<span class="line-modified">!     while (((depth &gt;= 0) &amp;&amp; (RAW != 0)) &amp;&amp;</span>
<span class="line-removed">-                (ctxt-&gt;instate != XML_PARSER_EOF)) {</span>
        if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {
<span class="line-removed">-         depth++;</span>
          SKIP(3);
<span class="line-modified">!         continue;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!       if ((RAW == &#39;]&#39;) &amp;&amp; (NXT(1) == &#39;]&#39;) &amp;&amp; (NXT(2) == &#39;&gt;&#39;)) {</span>
<span class="line-modified">!         if (--depth &gt;= 0) SKIP(3);</span>
<span class="line-modified">!         continue;</span>
        }
        NEXT;
<span class="line-modified">!       continue;</span>
      }
  
      ctxt-&gt;disableSAX = state;
      ctxt-&gt;instate = instate;
  
<span class="line-modified">!     if (xmlParserDebugEntities) {</span>
<span class="line-modified">!         if ((ctxt-&gt;input != NULL) &amp;&amp; (ctxt-&gt;input-&gt;filename))</span>
<span class="line-modified">!         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed">-             &quot;%s(%d): &quot;, ctxt-&gt;input-&gt;filename,</span>
<span class="line-removed">-             ctxt-&gt;input-&gt;line);</span>
<span class="line-removed">-         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed">-             &quot;Leaving IGNORE Conditional Section\n&quot;);</span>
      }
<span class="line-modified">! </span>
      } else {
      xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID_KEYWORD, NULL);
      xmlHaltParser(ctxt);
<span class="line-modified">!     return;</span>
      }
<span class="line-modified">! </span>
<span class="line-modified">!     if (RAW == 0)</span>
<span class="line-modified">!         SHRINK;</span>
<span class="line-modified">! </span>
<span class="line-removed">-     if (RAW == 0) {</span>
<span class="line-removed">-     xmlFatalErr(ctxt, XML_ERR_CONDSEC_NOT_FINISHED, NULL);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-     if (ctxt-&gt;input-&gt;id != id) {</span>
          xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
<span class="line-modified">!                        &quot;All markup of the conditional section is not in&quot;</span>
<span class="line-modified">!                            &quot; the same entity\n&quot;);</span>
      }
<span class="line-removed">-     if ((ctxt-&gt; instate != XML_PARSER_EOF) &amp;&amp;</span>
<span class="line-removed">-         ((ctxt-&gt;input-&gt;cur + 3) &lt;= ctxt-&gt;input-&gt;end))</span>
          SKIP(3);
      }
  }
  
  /**
   * xmlParseMarkupDecl:
   * @ctxt:  an XML parser context
<span class="line-new-header">--- 6636,147 ---</span>
   * [65] Ignore ::= Char* - (Char* (&#39;&lt;![&#39; | &#39;]]&gt;&#39;) Char*)
   */
  
  static void
  xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
<span class="line-added">+     int *inputIds = NULL;</span>
<span class="line-added">+     size_t inputIdsSize = 0;</span>
<span class="line-added">+     size_t depth = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+     while (ctxt-&gt;instate != XML_PARSER_EOF) {</span>
<span class="line-added">+         if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {</span>
      int id = ctxt-&gt;input-&gt;id;
  
      SKIP(3);
      SKIP_BLANKS;
<span class="line-added">+ </span>
      if (CMP7(CUR_PTR, &#39;I&#39;, &#39;N&#39;, &#39;C&#39;, &#39;L&#39;, &#39;U&#39;, &#39;D&#39;, &#39;E&#39;)) {
      SKIP(7);
      SKIP_BLANKS;
      if (RAW != &#39;[&#39;) {
          xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
          xmlHaltParser(ctxt);
<span class="line-modified">!                     goto error;</span>
<span class="line-modified">!                 }</span>
          if (ctxt-&gt;input-&gt;id != id) {
          xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
<span class="line-modified">!                                    &quot;All markup of the conditional section is&quot;</span>
<span class="line-modified">!                                    &quot; not in the same entity\n&quot;);</span>
          }
          NEXT;
  
<span class="line-modified">!                 if (inputIdsSize &lt;= depth) {</span>
<span class="line-modified">!                     int *tmp;</span>
  
<span class="line-modified">!                     inputIdsSize = (inputIdsSize == 0 ? 4 : inputIdsSize * 2);</span>
<span class="line-modified">!                     tmp = (int *) xmlRealloc(inputIds,</span>
<span class="line-modified">!                             inputIdsSize * sizeof(int));</span>
<span class="line-modified">!                     if (tmp == NULL) {</span>
<span class="line-added">+                         xmlErrMemory(ctxt, NULL);</span>
<span class="line-added">+                         goto error;</span>
          }
<span class="line-added">+                     inputIds = tmp;</span>
      }
<span class="line-modified">!                 inputIds[depth] = id;</span>
<span class="line-modified">!                 depth++;</span>
      } else if (CMP6(CUR_PTR, &#39;I&#39;, &#39;G&#39;, &#39;N&#39;, &#39;O&#39;, &#39;R&#39;, &#39;E&#39;)) {
      int state;
      xmlParserInputState instate;
<span class="line-modified">!                 size_t ignoreDepth = 0;</span>
  
      SKIP(6);
      SKIP_BLANKS;
      if (RAW != &#39;[&#39;) {
          xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
          xmlHaltParser(ctxt);
<span class="line-modified">!                     goto error;</span>
<span class="line-modified">!                 }</span>
          if (ctxt-&gt;input-&gt;id != id) {
          xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
<span class="line-modified">!                                    &quot;All markup of the conditional section is&quot;</span>
<span class="line-modified">!                                    &quot; not in the same entity\n&quot;);</span>
          }
          NEXT;
  
      /*
<span class="line-modified">!                  * Parse up to the end of the conditional section but disable</span>
<span class="line-modified">!                  * SAX event generating DTD building in the meantime</span>
       */
      state = ctxt-&gt;disableSAX;
      instate = ctxt-&gt;instate;
      if (ctxt-&gt;recovery == 0) ctxt-&gt;disableSAX = 1;
      ctxt-&gt;instate = XML_PARSER_IGNORE;
  
<span class="line-modified">!                 while (RAW != 0) {</span>
        if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {
          SKIP(3);
<span class="line-modified">!                         ignoreDepth++;</span>
<span class="line-modified">!                         /* Check for integer overflow */</span>
<span class="line-modified">!                         if (ignoreDepth == 0) {</span>
<span class="line-modified">!                             xmlErrMemory(ctxt, NULL);</span>
<span class="line-modified">!                             goto error;</span>
        }
<span class="line-added">+                     } else if ((RAW == &#39;]&#39;) &amp;&amp; (NXT(1) == &#39;]&#39;) &amp;&amp;</span>
<span class="line-added">+                                (NXT(2) == &#39;&gt;&#39;)) {</span>
<span class="line-added">+                         if (ignoreDepth == 0)</span>
<span class="line-added">+                             break;</span>
<span class="line-added">+                         SKIP(3);</span>
<span class="line-added">+                         ignoreDepth--;</span>
<span class="line-added">+                     } else {</span>
        NEXT;
<span class="line-modified">!                     }</span>
      }
  
      ctxt-&gt;disableSAX = state;
      ctxt-&gt;instate = instate;
  
<span class="line-modified">!         if (RAW == 0) {</span>
<span class="line-modified">!             xmlFatalErr(ctxt, XML_ERR_CONDSEC_NOT_FINISHED, NULL);</span>
<span class="line-modified">!                     goto error;</span>
      }
<span class="line-modified">!                 if (ctxt-&gt;input-&gt;id != id) {</span>
<span class="line-added">+                     xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,</span>
<span class="line-added">+                                    &quot;All markup of the conditional section is&quot;</span>
<span class="line-added">+                                    &quot; not in the same entity\n&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 SKIP(3);</span>
      } else {
      xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID_KEYWORD, NULL);
      xmlHaltParser(ctxt);
<span class="line-modified">!                 goto error;</span>
      }
<span class="line-modified">!         } else if ((depth &gt; 0) &amp;&amp;</span>
<span class="line-modified">!                    (RAW == &#39;]&#39;) &amp;&amp; (NXT(1) == &#39;]&#39;) &amp;&amp; (NXT(2) == &#39;&gt;&#39;)) {</span>
<span class="line-modified">!             depth--;</span>
<span class="line-modified">!             if (ctxt-&gt;input-&gt;id != inputIds[depth]) {</span>
          xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
<span class="line-modified">!                                &quot;All markup of the conditional section is not&quot;</span>
<span class="line-modified">!                                &quot; in the same entity\n&quot;);</span>
      }
          SKIP(3);
<span class="line-added">+         } else {</span>
<span class="line-added">+             const xmlChar *check = CUR_PTR;</span>
<span class="line-added">+             unsigned int cons = ctxt-&gt;input-&gt;consumed;</span>
<span class="line-added">+ </span>
<span class="line-added">+             xmlParseMarkupDecl(ctxt);</span>
<span class="line-added">+ </span>
<span class="line-added">+             if ((CUR_PTR == check) &amp;&amp; (cons == ctxt-&gt;input-&gt;consumed)) {</span>
<span class="line-added">+                 xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);</span>
<span class="line-added">+                 xmlHaltParser(ctxt);</span>
<span class="line-added">+                 goto error;</span>
<span class="line-added">+             }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (depth == 0)</span>
<span class="line-added">+             break;</span>
<span class="line-added">+ </span>
<span class="line-added">+         SKIP_BLANKS;</span>
<span class="line-added">+         GROW;</span>
      }
<span class="line-added">+ </span>
<span class="line-added">+ error:</span>
<span class="line-added">+     xmlFree(inputIds);</span>
  }
  
  /**
   * xmlParseMarkupDecl:
   * @ctxt:  an XML parser context
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6808,25 ***</span>
      }
      }
  
      /*
       * detect requirement to exit there and act accordingly
<span class="line-modified">!      * and avoid having instate overriden later on</span>
       */
      if (ctxt-&gt;instate == XML_PARSER_EOF)
          return;
  
<span class="line-removed">-     /*</span>
<span class="line-removed">-      * Conditional sections are allowed from entities included</span>
<span class="line-removed">-      * by PE References in the internal subset.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     if ((ctxt-&gt;external == 0) &amp;&amp; (ctxt-&gt;inputNr &gt; 1)) {</span>
<span class="line-removed">-         if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {</span>
<span class="line-removed">-         xmlParseConditionalSections(ctxt);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      ctxt-&gt;instate = XML_PARSER_DTD;
  }
  
  /**
   * xmlParseTextDecl:
<span class="line-new-header">--- 6829,15 ---</span>
      }
      }
  
      /*
       * detect requirement to exit there and act accordingly
<span class="line-modified">!      * and avoid having instate overridden later on</span>
       */
      if (ctxt-&gt;instate == XML_PARSER_EOF)
          return;
  
      ctxt-&gt;instate = XML_PARSER_DTD;
  }
  
  /**
   * xmlParseTextDecl:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7007,11 ***</span>
      /*
       * Simple case of a CharRef
       */
      if (NXT(1) == &#39;#&#39;) {
      int i = 0;
<span class="line-modified">!     xmlChar out[10];</span>
      int hex = NXT(2);
      int value = xmlParseCharRef(ctxt);
  
      if (value == 0)
          return;
<span class="line-new-header">--- 7018,11 ---</span>
      /*
       * Simple case of a CharRef
       */
      if (NXT(1) == &#39;#&#39;) {
      int i = 0;
<span class="line-modified">!     xmlChar out[16];</span>
      int hex = NXT(2);
      int value = xmlParseCharRef(ctxt);
  
      if (value == 0)
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7084,11 ***</span>
       */
      if (((ent-&gt;checked == 0) ||
           ((ent-&gt;children == NULL) &amp;&amp; (ctxt-&gt;options &amp; XML_PARSE_NOENT))) &amp;&amp;
          ((ent-&gt;etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
           (ctxt-&gt;options &amp; (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {
<span class="line-modified">!     unsigned long oldnbent = ctxt-&gt;nbentities;</span>
  
      /*
       * This is a bit hackish but this seems the best
       * way to make sure both SAX and DOM entity support
       * behaves okay.
<span class="line-new-header">--- 7095,11 ---</span>
       */
      if (((ent-&gt;checked == 0) ||
           ((ent-&gt;children == NULL) &amp;&amp; (ctxt-&gt;options &amp; XML_PARSE_NOENT))) &amp;&amp;
          ((ent-&gt;etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
           (ctxt-&gt;options &amp; (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {
<span class="line-modified">!     unsigned long oldnbent = ctxt-&gt;nbentities, diff;</span>
  
      /*
       * This is a bit hackish but this seems the best
       * way to make sure both SAX and DOM entity support
       * behaves okay.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7125,11 ***</span>
  
      /*
       * Store the number of entities needing parsing for this entity
       * content and do checkings
       */
<span class="line-modified">!     ent-&gt;checked = (ctxt-&gt;nbentities - oldnbent + 1) * 2;</span>
      if ((ent-&gt;content != NULL) &amp;&amp; (xmlStrchr(ent-&gt;content, &#39;&lt;&#39;)))
          ent-&gt;checked |= 1;
      if (ret == XML_ERR_ENTITY_LOOP) {
          xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
          xmlFreeNodeList(list);
<span class="line-new-header">--- 7136,14 ---</span>
  
      /*
       * Store the number of entities needing parsing for this entity
       * content and do checkings
       */
<span class="line-modified">!         diff = ctxt-&gt;nbentities - oldnbent + 1;</span>
<span class="line-added">+         if (diff &gt; INT_MAX / 2)</span>
<span class="line-added">+             diff = INT_MAX / 2;</span>
<span class="line-added">+         ent-&gt;checked = diff * 2;</span>
      if ((ent-&gt;content != NULL) &amp;&amp; (xmlStrchr(ent-&gt;content, &#39;&lt;&#39;)))
          ent-&gt;checked |= 1;
      if (ret == XML_ERR_ENTITY_LOOP) {
          xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
          xmlFreeNodeList(list);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7673,11 ***</span>
              return(ent);
          }
      }
  
      /*
<span class="line-modified">!      * Increate the number of entity references parsed</span>
       */
      ctxt-&gt;nbentities++;
  
      /*
       * Ask first SAX for entity resolution, otherwise try the
<span class="line-new-header">--- 7687,11 ---</span>
              return(ent);
          }
      }
  
      /*
<span class="line-modified">!      * Increase the number of entity references parsed</span>
       */
      ctxt-&gt;nbentities++;
  
      /*
       * Ask first SAX for entity resolution, otherwise try the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7849,11 ***</span>
      }
  
      NEXT;
  
      /*
<span class="line-modified">!      * Increate the number of entity references parsed</span>
       */
      ctxt-&gt;nbentities++;
  
      /*
       * Request the entity from SAX
<span class="line-new-header">--- 7863,11 ---</span>
      }
  
      NEXT;
  
      /*
<span class="line-modified">!      * Increase the number of entity references parsed</span>
       */
      ctxt-&gt;nbentities++;
  
      /*
       * Request the entity from SAX
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8115,11 ***</span>
      return(NULL);
      }
      ptr++;
  
      /*
<span class="line-modified">!      * Increate the number of entity references parsed</span>
       */
      ctxt-&gt;nbentities++;
  
      /*
       * Request the entity from SAX
<span class="line-new-header">--- 8129,11 ---</span>
      return(NULL);
      }
      ptr++;
  
      /*
<span class="line-modified">!      * Increase the number of entity references parsed</span>
       */
      ctxt-&gt;nbentities++;
  
      /*
       * Request the entity from SAX
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8283,10 ***</span>
<span class="line-new-header">--- 8297,19 ---</span>
  
          SKIP_BLANKS;
          xmlParseMarkupDecl(ctxt);
          xmlParsePEReference(ctxt);
  
<span class="line-added">+             /*</span>
<span class="line-added">+              * Conditional sections are allowed from external entities included</span>
<span class="line-added">+              * by PE References in the internal subset.</span>
<span class="line-added">+              */</span>
<span class="line-added">+             if ((ctxt-&gt;inputNr &gt; 1) &amp;&amp; (ctxt-&gt;input-&gt;filename != NULL) &amp;&amp;</span>
<span class="line-added">+                 (RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {</span>
<span class="line-added">+                 xmlParseConditionalSections(ctxt);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
          if ((CUR_PTR == check) &amp;&amp; (cons == ctxt-&gt;input-&gt;consumed)) {
          xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
           &quot;xmlParseInternalSubset: error detected in Markup declaration\n&quot;);
                  if (ctxt-&gt;inputNr &gt; baseInputNr)
                      xmlPopInput(ctxt);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8711,16 ***</span>
      p = l;
      l = xmlParseNCName(ctxt);
      if (l == NULL) {
          xmlChar *tmp;
  
              xmlNsErr(ctxt, XML_NS_ERR_QNAME,
                   &quot;Failed to parse QName &#39;%s:&#39;\n&quot;, p, NULL, NULL);
          l = xmlParseNmtoken(ctxt);
<span class="line-modified">!         if (l == NULL)</span>
          tmp = xmlBuildQName(BAD_CAST &quot;&quot;, p, NULL, 0);
<span class="line-modified">!         else {</span>
          tmp = xmlBuildQName(l, p, NULL, 0);
          xmlFree((char *)l);
          }
          p = xmlDictLookup(ctxt-&gt;dict, tmp, -1);
          if (tmp != NULL) xmlFree(tmp);
<span class="line-new-header">--- 8734,20 ---</span>
      p = l;
      l = xmlParseNCName(ctxt);
      if (l == NULL) {
          xmlChar *tmp;
  
<span class="line-added">+             if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-added">+                 return(NULL);</span>
              xmlNsErr(ctxt, XML_NS_ERR_QNAME,
                   &quot;Failed to parse QName &#39;%s:&#39;\n&quot;, p, NULL, NULL);
          l = xmlParseNmtoken(ctxt);
<span class="line-modified">!         if (l == NULL) {</span>
<span class="line-added">+                 if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-added">+                     return(NULL);</span>
          tmp = xmlBuildQName(BAD_CAST &quot;&quot;, p, NULL, 0);
<span class="line-modified">!             } else {</span>
          tmp = xmlBuildQName(l, p, NULL, 0);
          xmlFree((char *)l);
          }
          p = xmlDictLookup(ctxt-&gt;dict, tmp, -1);
          if (tmp != NULL) xmlFree(tmp);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8739,10 ***</span>
<span class="line-new-header">--- 8766,12 ---</span>
          l = xmlDictLookup(ctxt-&gt;dict, tmp, -1);
          if (tmp != NULL) xmlFree(tmp);
          *prefix = p;
          return(l);
          }
<span class="line-added">+             if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-added">+                 return(NULL);</span>
          tmp = xmlBuildQName(BAD_CAST &quot;&quot;, l, NULL, 0);
          l = xmlDictLookup(ctxt-&gt;dict, tmp, -1);
          if (tmp != NULL) xmlFree(tmp);
          *prefix = p;
          return(l);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8838,10 ***</span>
<span class="line-new-header">--- 8867,22 ---</span>
   *
   * Returns the AttValue parsed or NULL. The value has to be freed by the
   *     caller if it was copied, this can be detected by val[*len] == 0.
   */
  
<span class="line-added">+ #define GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end) \</span>
<span class="line-added">+     const xmlChar *oldbase = ctxt-&gt;input-&gt;base;\</span>
<span class="line-added">+     GROW;\</span>
<span class="line-added">+     if (ctxt-&gt;instate == XML_PARSER_EOF)\</span>
<span class="line-added">+         return(NULL);\</span>
<span class="line-added">+     if (oldbase != ctxt-&gt;input-&gt;base) {\</span>
<span class="line-added">+         ptrdiff_t delta = ctxt-&gt;input-&gt;base - oldbase;\</span>
<span class="line-added">+         start = start + delta;\</span>
<span class="line-added">+         in = in + delta;\</span>
<span class="line-added">+     }\</span>
<span class="line-added">+     end = ctxt-&gt;input-&gt;end;</span>
<span class="line-added">+ </span>
  static xmlChar *
  xmlParseAttValueInternal(xmlParserCtxtPtr ctxt, int *len, int *alloc,
                           int normalize)
  {
      xmlChar limit = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8867,18 ***</span>
      limit = *in++;
      col++;
      end = ctxt-&gt;input-&gt;end;
      start = in;
      if (in &gt;= end) {
<span class="line-modified">!         const xmlChar *oldbase = ctxt-&gt;input-&gt;base;</span>
<span class="line-removed">-     GROW;</span>
<span class="line-removed">-     if (oldbase != ctxt-&gt;input-&gt;base) {</span>
<span class="line-removed">-         long delta = ctxt-&gt;input-&gt;base - oldbase;</span>
<span class="line-removed">-         start = start + delta;</span>
<span class="line-removed">-         in = in + delta;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     end = ctxt-&gt;input-&gt;end;</span>
      }
      if (normalize) {
          /*
       * Skip any leading spaces
       */
<span class="line-new-header">--- 8908,11 ---</span>
      limit = *in++;
      col++;
      end = ctxt-&gt;input-&gt;end;
      start = in;
      if (in &gt;= end) {
<span class="line-modified">!         GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)</span>
      }
      if (normalize) {
          /*
       * Skip any leading spaces
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8891,20 ***</span>
              col++;
          }
          in++;
          start = in;
          if (in &gt;= end) {
<span class="line-modified">!         const xmlChar *oldbase = ctxt-&gt;input-&gt;base;</span>
<span class="line-removed">-         GROW;</span>
<span class="line-removed">-                 if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-removed">-                     return(NULL);</span>
<span class="line-removed">-         if (oldbase != ctxt-&gt;input-&gt;base) {</span>
<span class="line-removed">-             long delta = ctxt-&gt;input-&gt;base - oldbase;</span>
<span class="line-removed">-             start = start + delta;</span>
<span class="line-removed">-             in = in + delta;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         end = ctxt-&gt;input-&gt;end;</span>
                  if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
                      ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
                      xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
                                     &quot;AttValue length too long\n&quot;);
                      return(NULL);
<span class="line-new-header">--- 8925,11 ---</span>
              col++;
          }
          in++;
          start = in;
          if (in &gt;= end) {
<span class="line-modified">!                 GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)</span>
                  if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
                      ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
                      xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
                                     &quot;AttValue length too long\n&quot;);
                      return(NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8914,20 ***</span>
      while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp; (*in &gt;= 0x20) &amp;&amp;
             (*in &lt;= 0x7f) &amp;&amp; (*in != &#39;&amp;&#39;) &amp;&amp; (*in != &#39;&lt;&#39;)) {
          col++;
          if ((*in++ == 0x20) &amp;&amp; (*in == 0x20)) break;
          if (in &gt;= end) {
<span class="line-modified">!         const xmlChar *oldbase = ctxt-&gt;input-&gt;base;</span>
<span class="line-removed">-         GROW;</span>
<span class="line-removed">-                 if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-removed">-                     return(NULL);</span>
<span class="line-removed">-         if (oldbase != ctxt-&gt;input-&gt;base) {</span>
<span class="line-removed">-             long delta = ctxt-&gt;input-&gt;base - oldbase;</span>
<span class="line-removed">-             start = start + delta;</span>
<span class="line-removed">-             in = in + delta;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         end = ctxt-&gt;input-&gt;end;</span>
                  if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
                      ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
                      xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
                                     &quot;AttValue length too long\n&quot;);
                      return(NULL);
<span class="line-new-header">--- 8939,11 ---</span>
      while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp; (*in &gt;= 0x20) &amp;&amp;
             (*in &lt;= 0x7f) &amp;&amp; (*in != &#39;&amp;&#39;) &amp;&amp; (*in != &#39;&lt;&#39;)) {
          col++;
          if ((*in++ == 0x20) &amp;&amp; (*in == 0x20)) break;
          if (in &gt;= end) {
<span class="line-modified">!                 GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)</span>
                  if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
                      ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
                      xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
                                     &quot;AttValue length too long\n&quot;);
                      return(NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8952,11 ***</span>
          const xmlChar *oldbase = ctxt-&gt;input-&gt;base;
          GROW;
                  if (ctxt-&gt;instate == XML_PARSER_EOF)
                      return(NULL);
          if (oldbase != ctxt-&gt;input-&gt;base) {
<span class="line-modified">!             long delta = ctxt-&gt;input-&gt;base - oldbase;</span>
              start = start + delta;
              in = in + delta;
              last = last + delta;
          }
          end = ctxt-&gt;input-&gt;end;
<span class="line-new-header">--- 8968,11 ---</span>
          const xmlChar *oldbase = ctxt-&gt;input-&gt;base;
          GROW;
                  if (ctxt-&gt;instate == XML_PARSER_EOF)
                      return(NULL);
          if (oldbase != ctxt-&gt;input-&gt;base) {
<span class="line-modified">!             ptrdiff_t delta = ctxt-&gt;input-&gt;base - oldbase;</span>
              start = start + delta;
              in = in + delta;
              last = last + delta;
          }
          end = ctxt-&gt;input-&gt;end;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8979,20 ***</span>
      while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp; (*in &gt;= 0x20) &amp;&amp;
             (*in &lt;= 0x7f) &amp;&amp; (*in != &#39;&amp;&#39;) &amp;&amp; (*in != &#39;&lt;&#39;)) {
          in++;
          col++;
          if (in &gt;= end) {
<span class="line-modified">!         const xmlChar *oldbase = ctxt-&gt;input-&gt;base;</span>
<span class="line-removed">-         GROW;</span>
<span class="line-removed">-                 if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-removed">-                     return(NULL);</span>
<span class="line-removed">-         if (oldbase != ctxt-&gt;input-&gt;base) {</span>
<span class="line-removed">-             long delta = ctxt-&gt;input-&gt;base - oldbase;</span>
<span class="line-removed">-             start = start + delta;</span>
<span class="line-removed">-             in = in + delta;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         end = ctxt-&gt;input-&gt;end;</span>
                  if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
                      ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
                      xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
                                     &quot;AttValue length too long\n&quot;);
                      return(NULL);
<span class="line-new-header">--- 8995,11 ---</span>
      while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp; (*in &gt;= 0x20) &amp;&amp;
             (*in &lt;= 0x7f) &amp;&amp; (*in != &#39;&amp;&#39;) &amp;&amp; (*in != &#39;&lt;&#39;)) {
          in++;
          col++;
          if (in &gt;= end) {
<span class="line-modified">!                 GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)</span>
                  if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
                      ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
                      xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
                                     &quot;AttValue length too long\n&quot;);
                      return(NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9082,11 ***</span>
          SKIP_BLANKS;
          val = xmlParseAttValueInternal(ctxt, len, alloc, normalize);
      if (normalize) {
          /*
           * Sometimes a second normalisation pass for spaces is needed
<span class="line-modified">!          * but that only happens if charrefs or entities refernces</span>
           * have been used in the attribute value, i.e. the attribute
           * value have been extracted in an allocated string already.
           */
          if (*alloc) {
              const xmlChar *val2;
<span class="line-new-header">--- 9089,11 ---</span>
          SKIP_BLANKS;
          val = xmlParseAttValueInternal(ctxt, len, alloc, normalize);
      if (normalize) {
          /*
           * Sometimes a second normalisation pass for spaces is needed
<span class="line-modified">!          * but that only happens if charrefs or entities references</span>
           * have been used in the attribute value, i.e. the attribute
           * value have been extracted in an allocated string already.
           */
          if (*alloc) {
              const xmlChar *val2;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9245,11 ***</span>
  
              if (URL == NULL) {
                  xmlErrMemory(ctxt, &quot;dictionary allocation failure&quot;);
                  if ((attvalue != NULL) &amp;&amp; (alloc != 0))
                      xmlFree(attvalue);
<span class="line-modified">!                 return(NULL);</span>
              }
              if (*URL != 0) {
                  uri = xmlParseURI((const char *) URL);
                  if (uri == NULL) {
                      xmlNsErr(ctxt, XML_WAR_NS_URI,
<span class="line-new-header">--- 9252,12 ---</span>
  
              if (URL == NULL) {
                  xmlErrMemory(ctxt, &quot;dictionary allocation failure&quot;);
                  if ((attvalue != NULL) &amp;&amp; (alloc != 0))
                      xmlFree(attvalue);
<span class="line-modified">!                 localname = NULL;</span>
<span class="line-added">+                 goto done;</span>
              }
              if (*URL != 0) {
                  uri = xmlParseURI((const char *) URL);
                  if (uri == NULL) {
                      xmlNsErr(ctxt, XML_WAR_NS_URI,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9495,11 ***</span>
              }
              if (j &lt; nbatts) continue;
  
              if ((atts == NULL) || (nbatts + 5 &gt; maxatts)) {
              if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) &lt; 0) {
<span class="line-modified">!                 return(NULL);</span>
              }
              maxatts = ctxt-&gt;maxatts;
              atts = ctxt-&gt;atts;
              }
              atts[nbatts++] = attname;
<span class="line-new-header">--- 9503,12 ---</span>
              }
              if (j &lt; nbatts) continue;
  
              if ((atts == NULL) || (nbatts + 5 &gt; maxatts)) {
              if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) &lt; 0) {
<span class="line-modified">!                             localname = NULL;</span>
<span class="line-added">+                             goto done;</span>
              }
              maxatts = ctxt-&gt;maxatts;
              atts = ctxt-&gt;atts;
              }
              atts[nbatts++] = attname;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9805,13 ***</span>
   * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
   */
  
  void
  xmlParseContent(xmlParserCtxtPtr ctxt) {
      GROW;
      while ((RAW != 0) &amp;&amp;
<span class="line-removed">-        ((RAW != &#39;&lt;&#39;) || (NXT(1) != &#39;/&#39;)) &amp;&amp;</span>
         (ctxt-&gt;instate != XML_PARSER_EOF)) {
      const xmlChar *test = CUR_PTR;
      unsigned int cons = ctxt-&gt;input-&gt;consumed;
      const xmlChar *cur = ctxt-&gt;input-&gt;cur;
  
<span class="line-new-header">--- 9814,14 ---</span>
   * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
   */
  
  void
  xmlParseContent(xmlParserCtxtPtr ctxt) {
<span class="line-added">+     int nameNr = ctxt-&gt;nameNr;</span>
<span class="line-added">+ </span>
      GROW;
      while ((RAW != 0) &amp;&amp;
         (ctxt-&gt;instate != XML_PARSER_EOF)) {
      const xmlChar *test = CUR_PTR;
      unsigned int cons = ctxt-&gt;input-&gt;consumed;
      const xmlChar *cur = ctxt-&gt;input-&gt;cur;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9841,11 ***</span>
  
      /*
       * Fourth case :  a sub-element.
       */
      else if (*cur == &#39;&lt;&#39;) {
<span class="line-modified">!         xmlParseElement(ctxt);</span>
      }
  
      /*
       * Fifth case : a reference. If if has not been resolved,
       *    parsing returns it&#39;s Name, create the node
<span class="line-new-header">--- 9851,17 ---</span>
  
      /*
       * Fourth case :  a sub-element.
       */
      else if (*cur == &#39;&lt;&#39;) {
<span class="line-modified">!             if (NXT(1) == &#39;/&#39;) {</span>
<span class="line-added">+                 if (ctxt-&gt;nameNr &lt;= nameNr)</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+             xmlParseElementEnd(ctxt);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+             xmlParseElementStart(ctxt);</span>
<span class="line-added">+             }</span>
      }
  
      /*
       * Fifth case : a reference. If if has not been resolved,
       *    parsing returns it&#39;s Name, create the node
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9876,11 ***</span>
  
  /**
   * xmlParseElement:
   * @ctxt:  an XML parser context
   *
<span class="line-modified">!  * parse an XML element, this is highly recursive</span>
   *
   * [39] element ::= EmptyElemTag | STag content ETag
   *
   * [ WFC: Element Type Match ]
   * The Name in an element&#39;s end-tag must match the element type in the
<span class="line-new-header">--- 9892,11 ---</span>
  
  /**
   * xmlParseElement:
   * @ctxt:  an XML parser context
   *
<span class="line-modified">!  * parse an XML element</span>
   *
   * [39] element ::= EmptyElemTag | STag content ETag
   *
   * [ WFC: Element Type Match ]
   * The Name in an element&#39;s end-tag must match the element type in the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9888,10 ***</span>
<span class="line-new-header">--- 9904,27 ---</span>
   *
   */
  
  void
  xmlParseElement(xmlParserCtxtPtr ctxt) {
<span class="line-added">+     if (xmlParseElementStart(ctxt) != 0)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     xmlParseContent(ctxt);</span>
<span class="line-added">+     if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-added">+     return;</span>
<span class="line-added">+     xmlParseElementEnd(ctxt);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /**</span>
<span class="line-added">+  * xmlParseElementStart:</span>
<span class="line-added">+  * @ctxt:  an XML parser context</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Parse the start of an XML element. Returns -1 in case of error, 0 if an</span>
<span class="line-added">+  * opening tag was parsed, 1 if an empty element was parsed.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ static int</span>
<span class="line-added">+ xmlParseElementStart(xmlParserCtxtPtr ctxt) {</span>
      const xmlChar *name;
      const xmlChar *prefix = NULL;
      const xmlChar *URI = NULL;
      xmlParserNodeInfo node_info;
      int line, tlen = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9902,11 ***</span>
          ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
      xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
           &quot;Excessive depth in document: %d use XML_PARSE_HUGE option\n&quot;,
                xmlParserMaxDepth);
      xmlHaltParser(ctxt);
<span class="line-modified">!     return;</span>
      }
  
      /* Capture start position */
      if (ctxt-&gt;record_info) {
          node_info.begin_pos = ctxt-&gt;input-&gt;consumed +
<span class="line-new-header">--- 9935,11 ---</span>
          ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
      xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
           &quot;Excessive depth in document: %d use XML_PARSE_HUGE option\n&quot;,
                xmlParserMaxDepth);
      xmlHaltParser(ctxt);
<span class="line-modified">!     return(-1);</span>
      }
  
      /* Capture start position */
      if (ctxt-&gt;record_info) {
          node_info.begin_pos = ctxt-&gt;input-&gt;consumed +
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9929,16 ***</span>
  #ifdef LIBXML_SAX1_ENABLED
      else
      name = xmlParseStartTag(ctxt);
  #endif /* LIBXML_SAX1_ENABLED */
      if (ctxt-&gt;instate == XML_PARSER_EOF)
<span class="line-modified">!     return;</span>
      if (name == NULL) {
      spacePop(ctxt);
<span class="line-modified">!         return;</span>
      }
      namePush(ctxt, name);
      ret = ctxt-&gt;node;
  
  #ifdef LIBXML_VALID_ENABLED
      /*
       * [ VC: Root Element Type ]
<span class="line-new-header">--- 9962,21 ---</span>
  #ifdef LIBXML_SAX1_ENABLED
      else
      name = xmlParseStartTag(ctxt);
  #endif /* LIBXML_SAX1_ENABLED */
      if (ctxt-&gt;instate == XML_PARSER_EOF)
<span class="line-modified">!     return(-1);</span>
      if (name == NULL) {
      spacePop(ctxt);
<span class="line-modified">!         return(-1);</span>
      }
<span class="line-added">+     if (ctxt-&gt;sax2)</span>
<span class="line-added">+         nameNsPush(ctxt, name, prefix, URI, ctxt-&gt;nsNr - nsNr);</span>
<span class="line-added">+ #ifdef LIBXML_SAX1_ENABLED</span>
<span class="line-added">+     else</span>
      namePush(ctxt, name);
<span class="line-added">+ #endif /* LIBXML_SAX1_ENABLED */</span>
      ret = ctxt-&gt;node;
  
  #ifdef LIBXML_VALID_ENABLED
      /*
       * [ VC: Root Element Type ]
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9975,11 ***</span>
                    (CUR_PTR - ctxt-&gt;input-&gt;base);
         node_info.end_line = ctxt-&gt;input-&gt;line;
         node_info.node = ret;
         xmlParserAddNodeInfo(ctxt, &amp;node_info);
      }
<span class="line-modified">!     return;</span>
      }
      if (RAW == &#39;&gt;&#39;) {
          NEXT1;
      } else {
          xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_GT_REQUIRED,
<span class="line-new-header">--- 10013,11 ---</span>
                    (CUR_PTR - ctxt-&gt;input-&gt;base);
         node_info.end_line = ctxt-&gt;input-&gt;line;
         node_info.node = ret;
         xmlParserAddNodeInfo(ctxt, &amp;node_info);
      }
<span class="line-modified">!     return(1);</span>
      }
      if (RAW == &#39;&gt;&#39;) {
          NEXT1;
      } else {
          xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_GT_REQUIRED,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10003,45 ***</span>
                    (CUR_PTR - ctxt-&gt;input-&gt;base);
         node_info.end_line = ctxt-&gt;input-&gt;line;
         node_info.node = ret;
         xmlParserAddNodeInfo(ctxt, &amp;node_info);
      }
<span class="line-modified">!     return;</span>
      }
  
<span class="line-modified">!     /*</span>
<span class="line-modified">!      * Parse the content of the element:</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     xmlParseContent(ctxt);</span>
<span class="line-removed">-     if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-removed">-     return;</span>
<span class="line-removed">-     if (!IS_BYTE_CHAR(RAW)) {</span>
<span class="line-removed">-         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,</span>
<span class="line-removed">-      &quot;Premature end of data in tag %s line %d\n&quot;,</span>
<span class="line-removed">-                         name, line, NULL);</span>
  
<span class="line-modified">!     /*</span>
<span class="line-modified">!      * end of parsing of this node.</span>
       */
<span class="line-modified">!     nodePop(ctxt);</span>
<span class="line-modified">!     namePop(ctxt);</span>
<span class="line-modified">!     spacePop(ctxt);</span>
<span class="line-modified">!     if (nsNr != ctxt-&gt;nsNr)</span>
<span class="line-modified">!         nsPop(ctxt, ctxt-&gt;nsNr - nsNr);</span>
      return;
<span class="line-removed">-     }</span>
  
      /*
       * parse the end of tag: &#39;&lt;/&#39; should be here.
       */
      if (ctxt-&gt;sax2) {
<span class="line-modified">!     xmlParseEndTag2(ctxt, prefix, URI, line, ctxt-&gt;nsNr - nsNr, tlen);</span>
      namePop(ctxt);
      }
  #ifdef LIBXML_SAX1_ENABLED
        else
<span class="line-modified">!     xmlParseEndTag1(ctxt, line);</span>
  #endif /* LIBXML_SAX1_ENABLED */
  
      /*
       * Capture end position and add node
       */
<span class="line-new-header">--- 10041,43 ---</span>
                    (CUR_PTR - ctxt-&gt;input-&gt;base);
         node_info.end_line = ctxt-&gt;input-&gt;line;
         node_info.node = ret;
         xmlParserAddNodeInfo(ctxt, &amp;node_info);
      }
<span class="line-modified">!     return(-1);</span>
      }
  
<span class="line-modified">!     return(0);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! /**</span>
<span class="line-modified">!  * xmlParseElementEnd:</span>
<span class="line-added">+  * @ctxt:  an XML parser context</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Parse the end of an XML element.</span>
       */
<span class="line-modified">! static void</span>
<span class="line-modified">! xmlParseElementEnd(xmlParserCtxtPtr ctxt) {</span>
<span class="line-modified">!     xmlParserNodeInfo node_info;</span>
<span class="line-modified">!     xmlNodePtr ret = ctxt-&gt;node;</span>
<span class="line-modified">! </span>
<span class="line-added">+     if (ctxt-&gt;nameNr &lt;= 0)</span>
      return;
  
      /*
       * parse the end of tag: &#39;&lt;/&#39; should be here.
       */
      if (ctxt-&gt;sax2) {
<span class="line-modified">!         const xmlChar *prefix = ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 - 3];</span>
<span class="line-added">+         const xmlChar *URI = ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 - 2];</span>
<span class="line-added">+         int nsNr = (ptrdiff_t) ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 - 1];</span>
<span class="line-added">+     xmlParseEndTag2(ctxt, prefix, URI, 0, nsNr, 0);</span>
      namePop(ctxt);
      }
  #ifdef LIBXML_SAX1_ENABLED
        else
<span class="line-modified">!     xmlParseEndTag1(ctxt, 0);</span>
  #endif /* LIBXML_SAX1_ENABLED */
  
      /*
       * Capture end position and add node
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10279,11 ***</span>
          xmlFree((xmlChar *) encoding);
              return(NULL);
      }
  
      /*
<span class="line-modified">!      * UTF-16 encoding stwich has already taken place at this stage,</span>
       * more over the little-endian/big-endian selection is already done
       */
          if ((encoding != NULL) &amp;&amp;
          ((!xmlStrcasecmp(encoding, BAD_CAST &quot;UTF-16&quot;)) ||
           (!xmlStrcasecmp(encoding, BAD_CAST &quot;UTF16&quot;)))) {
<span class="line-new-header">--- 10315,11 ---</span>
          xmlFree((xmlChar *) encoding);
              return(NULL);
      }
  
      /*
<span class="line-modified">!      * UTF-16 encoding switch has already taken place at this stage,</span>
       * more over the little-endian/big-endian selection is already done
       */
          if ((encoding != NULL) &amp;&amp;
          ((!xmlStrcasecmp(encoding, BAD_CAST &quot;UTF-16&quot;)) ||
           (!xmlStrcasecmp(encoding, BAD_CAST &quot;UTF16&quot;)))) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11162,11 ***</span>
          avail = ctxt-&gt;input-&gt;length -
                  (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
      else {
          /*
           * If we are operating on converted input, try to flush
<span class="line-modified">!          * remainng chars to avoid them stalling in the non-converted</span>
           * buffer. But do not do this in document start where
           * encoding=&quot;...&quot; may not have been read and we work on a
           * guessed encoding.
           */
          if ((ctxt-&gt;instate != XML_PARSER_START) &amp;&amp;
<span class="line-new-header">--- 11198,11 ---</span>
          avail = ctxt-&gt;input-&gt;length -
                  (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
      else {
          /*
           * If we are operating on converted input, try to flush
<span class="line-modified">!          * remaining chars to avoid them stalling in the non-converted</span>
           * buffer. But do not do this in document start where
           * encoding=&quot;...&quot; may not have been read and we work on a
           * guessed encoding.
           */
          if ((ctxt-&gt;instate != XML_PARSER_START) &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12354,17 ***</span>
          xmlErrMemory(NULL, &quot;creating parser: out of memory\n&quot;);
      xmlFreeParserInputBuffer(buf);
      return(NULL);
      }
      ctxt-&gt;dictNames = 1;
<span class="line-removed">-     ctxt-&gt;pushTab = (void **) xmlMalloc(ctxt-&gt;nameMax * 3 * sizeof(xmlChar *));</span>
<span class="line-removed">-     if (ctxt-&gt;pushTab == NULL) {</span>
<span class="line-removed">-         xmlErrMemory(ctxt, NULL);</span>
<span class="line-removed">-     xmlFreeParserInputBuffer(buf);</span>
<span class="line-removed">-     xmlFreeParserCtxt(ctxt);</span>
<span class="line-removed">-     return(NULL);</span>
<span class="line-removed">-     }</span>
      if (sax != NULL) {
  #ifdef LIBXML_SAX1_ENABLED
      if (ctxt-&gt;sax != (xmlSAXHandlerPtr) &amp;xmlDefaultSAXHandler)
  #endif /* LIBXML_SAX1_ENABLED */
          xmlFree(ctxt-&gt;sax);
<span class="line-new-header">--- 12390,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13896,10 ***</span>
<span class="line-new-header">--- 13925,11 ---</span>
      if (sax != NULL)
      ctxt-&gt;sax = oldsax;
      xmlFreeParserCtxt(ctxt);
      newDoc-&gt;intSubset = NULL;
      newDoc-&gt;extSubset = NULL;
<span class="line-added">+     if(doc != NULL)</span>
      newDoc-&gt;oldNs = NULL;
      xmlFreeDoc(newDoc);
  
      return(ret);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14005,10 ***</span>
<span class="line-new-header">--- 14035,14 ---</span>
       * incremented to distinguish from main entity
       */
      ctxt-&gt;input_id = pctx-&gt;input_id + 1;
      }
  
<span class="line-added">+     /* Don&#39;t read from stdin. */</span>
<span class="line-added">+     if (xmlStrcmp(URL, BAD_CAST &quot;-&quot;) == 0)</span>
<span class="line-added">+         URL = BAD_CAST &quot;./-&quot;;</span>
<span class="line-added">+ </span>
      uri = xmlBuildURI(URL, base);
  
      if (uri == NULL) {
      inputStream = xmlLoadExternalEntity((char *)URL, (char *)ID, ctxt);
      if (inputStream == NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14937,20 ***</span>
          return(1);
      }
  
      xmlCtxtReset(ctxt);
  
<span class="line-removed">-     if (ctxt-&gt;pushTab == NULL) {</span>
<span class="line-removed">-         ctxt-&gt;pushTab = (void **) xmlMalloc(ctxt-&gt;nameMax * 3 *</span>
<span class="line-removed">-                                         sizeof(xmlChar *));</span>
<span class="line-removed">-         if (ctxt-&gt;pushTab == NULL) {</span>
<span class="line-removed">-         xmlErrMemory(ctxt, NULL);</span>
<span class="line-removed">-             xmlFreeParserInputBuffer(buf);</span>
<span class="line-removed">-             return(1);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      if (filename == NULL) {
          ctxt-&gt;directory = NULL;
      } else {
          ctxt-&gt;directory = xmlParserGetDirectory(filename);
      }
<span class="line-new-header">--- 14971,10 ---</span>
</pre>
<center><a href="nanohttp.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="parserInternals.c.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
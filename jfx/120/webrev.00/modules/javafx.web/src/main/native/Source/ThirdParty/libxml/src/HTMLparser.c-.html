<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/HTMLparser.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * HTMLparser.c : an HTML 4.0 non-verifying parser
   3  *
   4  * See Copyright for the status of this software.
   5  *
   6  * daniel@veillard.com
   7  */
   8 
   9 #define IN_LIBXML
  10 #include &quot;libxml.h&quot;
  11 #ifdef LIBXML_HTML_ENABLED
  12 
  13 #include &lt;string.h&gt;
  14 #ifdef HAVE_CTYPE_H
  15 #include &lt;ctype.h&gt;
  16 #endif
  17 #ifdef HAVE_STDLIB_H
  18 #include &lt;stdlib.h&gt;
  19 #endif
  20 #ifdef HAVE_SYS_STAT_H
  21 #include &lt;sys/stat.h&gt;
  22 #endif
  23 #ifdef HAVE_FCNTL_H
  24 #include &lt;fcntl.h&gt;
  25 #endif
  26 #ifdef HAVE_UNISTD_H
  27 #include &lt;unistd.h&gt;
  28 #endif
  29 #ifdef LIBXML_ZLIB_ENABLED
  30 #include &lt;zlib.h&gt;
  31 #endif
  32 
  33 #include &lt;libxml/xmlmemory.h&gt;
  34 #include &lt;libxml/tree.h&gt;
  35 #include &lt;libxml/parser.h&gt;
  36 #include &lt;libxml/parserInternals.h&gt;
  37 #include &lt;libxml/xmlerror.h&gt;
  38 #include &lt;libxml/HTMLparser.h&gt;
  39 #include &lt;libxml/HTMLtree.h&gt;
  40 #include &lt;libxml/entities.h&gt;
  41 #include &lt;libxml/encoding.h&gt;
  42 #include &lt;libxml/valid.h&gt;
  43 #include &lt;libxml/xmlIO.h&gt;
  44 #include &lt;libxml/globals.h&gt;
  45 #include &lt;libxml/uri.h&gt;
  46 
  47 #include &quot;buf.h&quot;
  48 #include &quot;enc.h&quot;
  49 
  50 #define HTML_MAX_NAMELEN 1000
  51 #define HTML_PARSER_BIG_BUFFER_SIZE 1000
  52 #define HTML_PARSER_BUFFER_SIZE 100
  53 
  54 /* #define DEBUG */
  55 /* #define DEBUG_PUSH */
  56 
  57 static int htmlOmittedDefaultValue = 1;
  58 
  59 xmlChar * htmlDecodeEntities(htmlParserCtxtPtr ctxt, int len,
  60                  xmlChar end, xmlChar  end2, xmlChar end3);
  61 static void htmlParseComment(htmlParserCtxtPtr ctxt);
  62 
  63 /************************************************************************
  64  *                                  *
  65  *      Some factorized error routines              *
  66  *                                  *
  67  ************************************************************************/
  68 
  69 /**
  70  * htmlErrMemory:
  71  * @ctxt:  an HTML parser context
  72  * @extra:  extra informations
  73  *
  74  * Handle a redefinition of attribute error
  75  */
  76 static void
  77 htmlErrMemory(xmlParserCtxtPtr ctxt, const char *extra)
  78 {
  79     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
  80         (ctxt-&gt;instate == XML_PARSER_EOF))
  81     return;
  82     if (ctxt != NULL) {
  83         ctxt-&gt;errNo = XML_ERR_NO_MEMORY;
  84         ctxt-&gt;instate = XML_PARSER_EOF;
  85         ctxt-&gt;disableSAX = 1;
  86     }
  87     if (extra)
  88         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,
  89                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, extra,
  90                         NULL, NULL, 0, 0,
  91                         &quot;Memory allocation failed : %s\n&quot;, extra);
  92     else
  93         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,
  94                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, NULL,
  95                         NULL, NULL, 0, 0, &quot;Memory allocation failed\n&quot;);
  96 }
  97 
  98 /**
  99  * htmlParseErr:
 100  * @ctxt:  an HTML parser context
 101  * @error:  the error number
 102  * @msg:  the error message
 103  * @str1:  string infor
 104  * @str2:  string infor
 105  *
 106  * Handle a fatal parser error, i.e. violating Well-Formedness constraints
 107  */
 108 static void LIBXML_ATTR_FORMAT(3,0)
 109 htmlParseErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 110              const char *msg, const xmlChar *str1, const xmlChar *str2)
 111 {
 112     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
 113         (ctxt-&gt;instate == XML_PARSER_EOF))
 114     return;
 115     if (ctxt != NULL)
 116     ctxt-&gt;errNo = error;
 117     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_HTML, error,
 118                     XML_ERR_ERROR, NULL, 0,
 119             (const char *) str1, (const char *) str2,
 120             NULL, 0, 0,
 121             msg, str1, str2);
 122     if (ctxt != NULL)
 123     ctxt-&gt;wellFormed = 0;
 124 }
 125 
 126 /**
 127  * htmlParseErrInt:
 128  * @ctxt:  an HTML parser context
 129  * @error:  the error number
 130  * @msg:  the error message
 131  * @val:  integer info
 132  *
 133  * Handle a fatal parser error, i.e. violating Well-Formedness constraints
 134  */
 135 static void LIBXML_ATTR_FORMAT(3,0)
 136 htmlParseErrInt(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 137              const char *msg, int val)
 138 {
 139     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
 140         (ctxt-&gt;instate == XML_PARSER_EOF))
 141     return;
 142     if (ctxt != NULL)
 143     ctxt-&gt;errNo = error;
 144     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_HTML, error,
 145                     XML_ERR_ERROR, NULL, 0, NULL, NULL,
 146             NULL, val, 0, msg, val);
 147     if (ctxt != NULL)
 148     ctxt-&gt;wellFormed = 0;
 149 }
 150 
 151 /************************************************************************
 152  *                                  *
 153  *  Parser stacks related functions and macros      *
 154  *                                  *
 155  ************************************************************************/
 156 
 157 /**
 158  * htmlnamePush:
 159  * @ctxt:  an HTML parser context
 160  * @value:  the element name
 161  *
 162  * Pushes a new element name on top of the name stack
 163  *
 164  * Returns 0 in case of error, the index in the stack otherwise
 165  */
 166 static int
 167 htmlnamePush(htmlParserCtxtPtr ctxt, const xmlChar * value)
 168 {
 169     if ((ctxt-&gt;html &lt; 3) &amp;&amp; (xmlStrEqual(value, BAD_CAST &quot;head&quot;)))
 170         ctxt-&gt;html = 3;
 171     if ((ctxt-&gt;html &lt; 10) &amp;&amp; (xmlStrEqual(value, BAD_CAST &quot;body&quot;)))
 172         ctxt-&gt;html = 10;
 173     if (ctxt-&gt;nameNr &gt;= ctxt-&gt;nameMax) {
 174         ctxt-&gt;nameMax *= 2;
 175         ctxt-&gt;nameTab = (const xmlChar * *)
 176                          xmlRealloc((xmlChar * *)ctxt-&gt;nameTab,
 177                                     ctxt-&gt;nameMax *
 178                                     sizeof(ctxt-&gt;nameTab[0]));
 179         if (ctxt-&gt;nameTab == NULL) {
 180             htmlErrMemory(ctxt, NULL);
 181             return (0);
 182         }
 183     }
 184     ctxt-&gt;nameTab[ctxt-&gt;nameNr] = value;
 185     ctxt-&gt;name = value;
 186     return (ctxt-&gt;nameNr++);
 187 }
 188 /**
 189  * htmlnamePop:
 190  * @ctxt: an HTML parser context
 191  *
 192  * Pops the top element name from the name stack
 193  *
 194  * Returns the name just removed
 195  */
 196 static const xmlChar *
 197 htmlnamePop(htmlParserCtxtPtr ctxt)
 198 {
 199     const xmlChar *ret;
 200 
 201     if (ctxt-&gt;nameNr &lt;= 0)
 202         return (NULL);
 203     ctxt-&gt;nameNr--;
 204     if (ctxt-&gt;nameNr &lt; 0)
 205         return (NULL);
 206     if (ctxt-&gt;nameNr &gt; 0)
 207         ctxt-&gt;name = ctxt-&gt;nameTab[ctxt-&gt;nameNr - 1];
 208     else
 209         ctxt-&gt;name = NULL;
 210     ret = ctxt-&gt;nameTab[ctxt-&gt;nameNr];
 211     ctxt-&gt;nameTab[ctxt-&gt;nameNr] = NULL;
 212     return (ret);
 213 }
 214 
 215 /**
 216  * htmlNodeInfoPush:
 217  * @ctxt:  an HTML parser context
 218  * @value:  the node info
 219  *
 220  * Pushes a new element name on top of the node info stack
 221  *
 222  * Returns 0 in case of error, the index in the stack otherwise
 223  */
 224 static int
 225 htmlNodeInfoPush(htmlParserCtxtPtr ctxt, htmlParserNodeInfo *value)
 226 {
 227     if (ctxt-&gt;nodeInfoNr &gt;= ctxt-&gt;nodeInfoMax) {
 228         if (ctxt-&gt;nodeInfoMax == 0)
 229                 ctxt-&gt;nodeInfoMax = 5;
 230         ctxt-&gt;nodeInfoMax *= 2;
 231         ctxt-&gt;nodeInfoTab = (htmlParserNodeInfo *)
 232                          xmlRealloc((htmlParserNodeInfo *)ctxt-&gt;nodeInfoTab,
 233                                     ctxt-&gt;nodeInfoMax *
 234                                     sizeof(ctxt-&gt;nodeInfoTab[0]));
 235         if (ctxt-&gt;nodeInfoTab == NULL) {
 236             htmlErrMemory(ctxt, NULL);
 237             return (0);
 238         }
 239     }
 240     ctxt-&gt;nodeInfoTab[ctxt-&gt;nodeInfoNr] = *value;
 241     ctxt-&gt;nodeInfo = &amp;ctxt-&gt;nodeInfoTab[ctxt-&gt;nodeInfoNr];
 242     return (ctxt-&gt;nodeInfoNr++);
 243 }
 244 
 245 /**
 246  * htmlNodeInfoPop:
 247  * @ctxt:  an HTML parser context
 248  *
 249  * Pops the top element name from the node info stack
 250  *
 251  * Returns 0 in case of error, the pointer to NodeInfo otherwise
 252  */
 253 static htmlParserNodeInfo *
 254 htmlNodeInfoPop(htmlParserCtxtPtr ctxt)
 255 {
 256     if (ctxt-&gt;nodeInfoNr &lt;= 0)
 257         return (NULL);
 258     ctxt-&gt;nodeInfoNr--;
 259     if (ctxt-&gt;nodeInfoNr &lt; 0)
 260         return (NULL);
 261     if (ctxt-&gt;nodeInfoNr &gt; 0)
 262         ctxt-&gt;nodeInfo = &amp;ctxt-&gt;nodeInfoTab[ctxt-&gt;nodeInfoNr - 1];
 263     else
 264         ctxt-&gt;nodeInfo = NULL;
 265     return &amp;ctxt-&gt;nodeInfoTab[ctxt-&gt;nodeInfoNr];
 266 }
 267 
 268 /*
 269  * Macros for accessing the content. Those should be used only by the parser,
 270  * and not exported.
 271  *
 272  * Dirty macros, i.e. one need to make assumption on the context to use them
 273  *
 274  *   CUR_PTR return the current pointer to the xmlChar to be parsed.
 275  *   CUR     returns the current xmlChar value, i.e. a 8 bit value if compiled
 276  *           in ISO-Latin or UTF-8, and the current 16 bit value if compiled
 277  *           in UNICODE mode. This should be used internally by the parser
 278  *           only to compare to ASCII values otherwise it would break when
 279  *           running with UTF-8 encoding.
 280  *   NXT(n)  returns the n&#39;th next xmlChar. Same as CUR is should be used only
 281  *           to compare on ASCII based substring.
 282  *   UPP(n)  returns the n&#39;th next xmlChar converted to uppercase. Same as CUR
 283  *           it should be used only to compare on ASCII based substring.
 284  *   SKIP(n) Skip n xmlChar, and must also be used only to skip ASCII defined
 285  *           strings without newlines within the parser.
 286  *
 287  * Clean macros, not dependent of an ASCII context, expect UTF-8 encoding
 288  *
 289  *   CURRENT Returns the current char value, with the full decoding of
 290  *           UTF-8 if we are using this mode. It returns an int.
 291  *   NEXT    Skip to the next character, this does the proper decoding
 292  *           in UTF-8 mode. It also pop-up unfinished entities on the fly.
 293  *   NEXTL(l) Skip the current unicode character of l xmlChars long.
 294  *   COPY(to) copy one char to *to, increment CUR_PTR and to accordingly
 295  */
 296 
 297 #define UPPER (toupper(*ctxt-&gt;input-&gt;cur))
 298 
 299 #define SKIP(val) ctxt-&gt;nbChars += (val),ctxt-&gt;input-&gt;cur += (val),ctxt-&gt;input-&gt;col+=(val)
 300 
 301 #define NXT(val) ctxt-&gt;input-&gt;cur[(val)]
 302 
 303 #define UPP(val) (toupper(ctxt-&gt;input-&gt;cur[(val)]))
 304 
 305 #define CUR_PTR ctxt-&gt;input-&gt;cur
 306 #define BASE_PTR ctxt-&gt;input-&gt;base
 307 
 308 #define SHRINK if ((ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base &gt; 2 * INPUT_CHUNK) &amp;&amp; \
 309            (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; 2 * INPUT_CHUNK)) \
 310     xmlParserInputShrink(ctxt-&gt;input)
 311 
 312 #define GROW if ((ctxt-&gt;progressive == 0) &amp;&amp;                \
 313          (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; INPUT_CHUNK))   \
 314     xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK)
 315 
 316 #define CURRENT ((int) (*ctxt-&gt;input-&gt;cur))
 317 
 318 #define SKIP_BLANKS htmlSkipBlankChars(ctxt)
 319 
 320 /* Inported from XML */
 321 
 322 /* #define CUR (ctxt-&gt;token ? ctxt-&gt;token : (int) (*ctxt-&gt;input-&gt;cur)) */
 323 #define CUR ((int) (*ctxt-&gt;input-&gt;cur))
 324 #define NEXT xmlNextChar(ctxt)
 325 
 326 #define RAW (ctxt-&gt;token ? -1 : (*ctxt-&gt;input-&gt;cur))
 327 
 328 
 329 #define NEXTL(l) do {                           \
 330     if (*(ctxt-&gt;input-&gt;cur) == &#39;\n&#39;) {                  \
 331     ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;          \
 332     } else ctxt-&gt;input-&gt;col++;                      \
 333     ctxt-&gt;token = 0; ctxt-&gt;input-&gt;cur += l; ctxt-&gt;nbChars++;        \
 334   } while (0)
 335 
 336 /************
 337     \
 338     if (*ctxt-&gt;input-&gt;cur == &#39;%&#39;) xmlParserHandlePEReference(ctxt); \
 339     if (*ctxt-&gt;input-&gt;cur == &#39;&amp;&#39;) xmlParserHandleReference(ctxt);
 340  ************/
 341 
 342 #define CUR_CHAR(l) htmlCurrentChar(ctxt, &amp;l)
 343 #define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &amp;l)
 344 
 345 #define COPY_BUF(l,b,i,v)                       \
 346     if (l == 1) b[i++] = (xmlChar) v;                   \
 347     else i += xmlCopyChar(l,&amp;b[i],v)
 348 
 349 /**
 350  * htmlFindEncoding:
 351  * @the HTML parser context
 352  *
 353  * Ty to find and encoding in the current data available in the input
 354  * buffer this is needed to try to switch to the proper encoding when
 355  * one face a character error.
 356  * That&#39;s an heuristic, since it&#39;s operating outside of parsing it could
 357  * try to use a meta which had been commented out, that&#39;s the reason it
 358  * should only be used in case of error, not as a default.
 359  *
 360  * Returns an encoding string or NULL if not found, the string need to
 361  *   be freed
 362  */
 363 static xmlChar *
 364 htmlFindEncoding(xmlParserCtxtPtr ctxt) {
 365     const xmlChar *start, *cur, *end;
 366 
 367     if ((ctxt == NULL) || (ctxt-&gt;input == NULL) ||
 368         (ctxt-&gt;input-&gt;encoding != NULL) || (ctxt-&gt;input-&gt;buf == NULL) ||
 369         (ctxt-&gt;input-&gt;buf-&gt;encoder != NULL))
 370         return(NULL);
 371     if ((ctxt-&gt;input-&gt;cur == NULL) || (ctxt-&gt;input-&gt;end == NULL))
 372         return(NULL);
 373 
 374     start = ctxt-&gt;input-&gt;cur;
 375     end = ctxt-&gt;input-&gt;end;
 376     /* we also expect the input buffer to be zero terminated */
 377     if (*end != 0)
 378         return(NULL);
 379 
 380     cur = xmlStrcasestr(start, BAD_CAST &quot;HTTP-EQUIV&quot;);
 381     if (cur == NULL)
 382         return(NULL);
 383     cur = xmlStrcasestr(cur, BAD_CAST  &quot;CONTENT&quot;);
 384     if (cur == NULL)
 385         return(NULL);
 386     cur = xmlStrcasestr(cur, BAD_CAST  &quot;CHARSET=&quot;);
 387     if (cur == NULL)
 388         return(NULL);
 389     cur += 8;
 390     start = cur;
 391     while (((*cur &gt;= &#39;A&#39;) &amp;&amp; (*cur &lt;= &#39;Z&#39;)) ||
 392            ((*cur &gt;= &#39;a&#39;) &amp;&amp; (*cur &lt;= &#39;z&#39;)) ||
 393            ((*cur &gt;= &#39;0&#39;) &amp;&amp; (*cur &lt;= &#39;9&#39;)) ||
 394            (*cur == &#39;-&#39;) || (*cur == &#39;_&#39;) || (*cur == &#39;:&#39;) || (*cur == &#39;/&#39;))
 395            cur++;
 396     if (cur == start)
 397         return(NULL);
 398     return(xmlStrndup(start, cur - start));
 399 }
 400 
 401 /**
 402  * htmlCurrentChar:
 403  * @ctxt:  the HTML parser context
 404  * @len:  pointer to the length of the char read
 405  *
 406  * The current char value, if using UTF-8 this may actually span multiple
 407  * bytes in the input buffer. Implement the end of line normalization:
 408  * 2.11 End-of-Line Handling
 409  * If the encoding is unspecified, in the case we find an ISO-Latin-1
 410  * char, then the encoding converter is plugged in automatically.
 411  *
 412  * Returns the current char value and its length
 413  */
 414 
 415 static int
 416 htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {
 417     if (ctxt-&gt;instate == XML_PARSER_EOF)
 418     return(0);
 419 
 420     if (ctxt-&gt;token != 0) {
 421     *len = 0;
 422     return(ctxt-&gt;token);
 423     }
 424     if (ctxt-&gt;charset == XML_CHAR_ENCODING_UTF8) {
 425     /*
 426      * We are supposed to handle UTF8, check it&#39;s valid
 427      * From rfc2044: encoding of the Unicode values on UTF-8:
 428      *
 429      * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
 430      * 0000 0000-0000 007F   0xxxxxxx
 431      * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
 432      * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
 433      *
 434      * Check for the 0x110000 limit too
 435      */
 436     const unsigned char *cur = ctxt-&gt;input-&gt;cur;
 437     unsigned char c;
 438     unsigned int val;
 439 
 440     c = *cur;
 441     if (c &amp; 0x80) {
 442         if (cur[1] == 0) {
 443         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 444                 cur = ctxt-&gt;input-&gt;cur;
 445             }
 446         if ((cur[1] &amp; 0xc0) != 0x80)
 447         goto encoding_error;
 448         if ((c &amp; 0xe0) == 0xe0) {
 449 
 450         if (cur[2] == 0) {
 451             xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 452                     cur = ctxt-&gt;input-&gt;cur;
 453                 }
 454         if ((cur[2] &amp; 0xc0) != 0x80)
 455             goto encoding_error;
 456         if ((c &amp; 0xf0) == 0xf0) {
 457             if (cur[3] == 0) {
 458             xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 459                         cur = ctxt-&gt;input-&gt;cur;
 460                     }
 461             if (((c &amp; 0xf8) != 0xf0) ||
 462             ((cur[3] &amp; 0xc0) != 0x80))
 463             goto encoding_error;
 464             /* 4-byte code */
 465             *len = 4;
 466             val = (cur[0] &amp; 0x7) &lt;&lt; 18;
 467             val |= (cur[1] &amp; 0x3f) &lt;&lt; 12;
 468             val |= (cur[2] &amp; 0x3f) &lt;&lt; 6;
 469             val |= cur[3] &amp; 0x3f;
 470         } else {
 471           /* 3-byte code */
 472             *len = 3;
 473             val = (cur[0] &amp; 0xf) &lt;&lt; 12;
 474             val |= (cur[1] &amp; 0x3f) &lt;&lt; 6;
 475             val |= cur[2] &amp; 0x3f;
 476         }
 477         } else {
 478           /* 2-byte code */
 479         *len = 2;
 480         val = (cur[0] &amp; 0x1f) &lt;&lt; 6;
 481         val |= cur[1] &amp; 0x3f;
 482         }
 483         if (!IS_CHAR(val)) {
 484             htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
 485                 &quot;Char 0x%X out of allowed range\n&quot;, val);
 486         }
 487         return(val);
 488     } else {
 489             if ((*ctxt-&gt;input-&gt;cur == 0) &amp;&amp;
 490                 (ctxt-&gt;input-&gt;cur &lt; ctxt-&gt;input-&gt;end)) {
 491                     htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
 492                 &quot;Char 0x%X out of allowed range\n&quot;, 0);
 493                 *len = 1;
 494                 return(&#39; &#39;);
 495             }
 496         /* 1-byte code */
 497         *len = 1;
 498         return((int) *ctxt-&gt;input-&gt;cur);
 499     }
 500     }
 501     /*
 502      * Assume it&#39;s a fixed length encoding (1) with
 503      * a compatible encoding for the ASCII set, since
 504      * XML constructs only use &lt; 128 chars
 505      */
 506     *len = 1;
 507     if ((int) *ctxt-&gt;input-&gt;cur &lt; 0x80)
 508     return((int) *ctxt-&gt;input-&gt;cur);
 509 
 510     /*
 511      * Humm this is bad, do an automatic flow conversion
 512      */
 513     {
 514         xmlChar * guess;
 515         xmlCharEncodingHandlerPtr handler;
 516 
 517         guess = htmlFindEncoding(ctxt);
 518         if (guess == NULL) {
 519             xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1);
 520         } else {
 521             if (ctxt-&gt;input-&gt;encoding != NULL)
 522                 xmlFree((xmlChar *) ctxt-&gt;input-&gt;encoding);
 523             ctxt-&gt;input-&gt;encoding = guess;
 524             handler = xmlFindCharEncodingHandler((const char *) guess);
 525             if (handler != NULL) {
 526                 xmlSwitchToEncoding(ctxt, handler);
 527             } else {
 528                 htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,
 529                              &quot;Unsupported encoding %s&quot;, guess, NULL);
 530             }
 531         }
 532         ctxt-&gt;charset = XML_CHAR_ENCODING_UTF8;
 533     }
 534 
 535     return(xmlCurrentChar(ctxt, len));
 536 
 537 encoding_error:
 538     /*
 539      * If we detect an UTF8 error that probably mean that the
 540      * input encoding didn&#39;t get properly advertized in the
 541      * declaration header. Report the error and switch the encoding
 542      * to ISO-Latin-1 (if you don&#39;t like this policy, just declare the
 543      * encoding !)
 544      */
 545     {
 546         char buffer[150];
 547 
 548     if (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &gt;= 4) {
 549         snprintf(buffer, 149, &quot;Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n&quot;,
 550                 ctxt-&gt;input-&gt;cur[0], ctxt-&gt;input-&gt;cur[1],
 551                 ctxt-&gt;input-&gt;cur[2], ctxt-&gt;input-&gt;cur[3]);
 552     } else {
 553         snprintf(buffer, 149, &quot;Bytes: 0x%02X\n&quot;, ctxt-&gt;input-&gt;cur[0]);
 554     }
 555     htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,
 556              &quot;Input is not proper UTF-8, indicate encoding !\n&quot;,
 557              BAD_CAST buffer, NULL);
 558     }
 559 
 560     ctxt-&gt;charset = XML_CHAR_ENCODING_8859_1;
 561     *len = 1;
 562     return((int) *ctxt-&gt;input-&gt;cur);
 563 }
 564 
 565 /**
 566  * htmlSkipBlankChars:
 567  * @ctxt:  the HTML parser context
 568  *
 569  * skip all blanks character found at that point in the input streams.
 570  *
 571  * Returns the number of space chars skipped
 572  */
 573 
 574 static int
 575 htmlSkipBlankChars(xmlParserCtxtPtr ctxt) {
 576     int res = 0;
 577 
 578     while (IS_BLANK_CH(*(ctxt-&gt;input-&gt;cur))) {
 579     if ((*ctxt-&gt;input-&gt;cur == 0) &amp;&amp;
 580         (xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK) &lt;= 0)) {
 581         xmlPopInput(ctxt);
 582     } else {
 583         if (*(ctxt-&gt;input-&gt;cur) == &#39;\n&#39;) {
 584         ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;
 585         } else ctxt-&gt;input-&gt;col++;
 586         ctxt-&gt;input-&gt;cur++;
 587         ctxt-&gt;nbChars++;
 588         if (*ctxt-&gt;input-&gt;cur == 0)
 589         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 590     }
 591     res++;
 592     }
 593     return(res);
 594 }
 595 
 596 
 597 
 598 /************************************************************************
 599  *                                  *
 600  *  The list of HTML elements and their properties      *
 601  *                                  *
 602  ************************************************************************/
 603 
 604 /*
 605  *  Start Tag: 1 means the start tag can be ommited
 606  *  End Tag:   1 means the end tag can be ommited
 607  *             2 means it&#39;s forbidden (empty elements)
 608  *             3 means the tag is stylistic and should be closed easily
 609  *  Depr:      this element is deprecated
 610  *  DTD:       1 means that this element is valid only in the Loose DTD
 611  *             2 means that this element is valid only in the Frameset DTD
 612  *
 613  * Name,Start Tag,End Tag,Save End,Empty,Deprecated,DTD,inline,Description
 614     , subElements , impliedsubelt , Attributes, userdata
 615  */
 616 
 617 /* Definitions and a couple of vars for HTML Elements */
 618 
 619 #define FONTSTYLE &quot;tt&quot;, &quot;i&quot;, &quot;b&quot;, &quot;u&quot;, &quot;s&quot;, &quot;strike&quot;, &quot;big&quot;, &quot;small&quot;
 620 #define NB_FONTSTYLE 8
 621 #define PHRASE &quot;em&quot;, &quot;strong&quot;, &quot;dfn&quot;, &quot;code&quot;, &quot;samp&quot;, &quot;kbd&quot;, &quot;var&quot;, &quot;cite&quot;, &quot;abbr&quot;, &quot;acronym&quot;
 622 #define NB_PHRASE 10
 623 #define SPECIAL &quot;a&quot;, &quot;img&quot;, &quot;applet&quot;, &quot;embed&quot;, &quot;object&quot;, &quot;font&quot;, &quot;basefont&quot;, &quot;br&quot;, &quot;script&quot;, &quot;map&quot;, &quot;q&quot;, &quot;sub&quot;, &quot;sup&quot;, &quot;span&quot;, &quot;bdo&quot;, &quot;iframe&quot;
 624 #define NB_SPECIAL 16
 625 #define INLINE FONTSTYLE, PHRASE, SPECIAL, FORMCTRL
 626 #define NB_INLINE NB_PCDATA + NB_FONTSTYLE + NB_PHRASE + NB_SPECIAL + NB_FORMCTRL
 627 #define BLOCK HEADING, LIST, &quot;pre&quot;, &quot;p&quot;, &quot;dl&quot;, &quot;div&quot;, &quot;center&quot;, &quot;noscript&quot;, &quot;noframes&quot;, &quot;blockquote&quot;, &quot;form&quot;, &quot;isindex&quot;, &quot;hr&quot;, &quot;table&quot;, &quot;fieldset&quot;, &quot;address&quot;
 628 #define NB_BLOCK NB_HEADING + NB_LIST + 14
 629 #define FORMCTRL &quot;input&quot;, &quot;select&quot;, &quot;textarea&quot;, &quot;label&quot;, &quot;button&quot;
 630 #define NB_FORMCTRL 5
 631 #define PCDATA
 632 #define NB_PCDATA 0
 633 #define HEADING &quot;h1&quot;, &quot;h2&quot;, &quot;h3&quot;, &quot;h4&quot;, &quot;h5&quot;, &quot;h6&quot;
 634 #define NB_HEADING 6
 635 #define LIST &quot;ul&quot;, &quot;ol&quot;, &quot;dir&quot;, &quot;menu&quot;
 636 #define NB_LIST 4
 637 #define MODIFIER
 638 #define NB_MODIFIER 0
 639 #define FLOW BLOCK,INLINE
 640 #define NB_FLOW NB_BLOCK + NB_INLINE
 641 #define EMPTY NULL
 642 
 643 
 644 static const char* const html_flow[] = { FLOW, NULL } ;
 645 static const char* const html_inline[] = { INLINE, NULL } ;
 646 
 647 /* placeholders: elts with content but no subelements */
 648 static const char* const html_pcdata[] = { NULL } ;
 649 #define html_cdata html_pcdata
 650 
 651 
 652 /* ... and for HTML Attributes */
 653 
 654 #define COREATTRS &quot;id&quot;, &quot;class&quot;, &quot;style&quot;, &quot;title&quot;
 655 #define NB_COREATTRS 4
 656 #define I18N &quot;lang&quot;, &quot;dir&quot;
 657 #define NB_I18N 2
 658 #define EVENTS &quot;onclick&quot;, &quot;ondblclick&quot;, &quot;onmousedown&quot;, &quot;onmouseup&quot;, &quot;onmouseover&quot;, &quot;onmouseout&quot;, &quot;onkeypress&quot;, &quot;onkeydown&quot;, &quot;onkeyup&quot;
 659 #define NB_EVENTS 9
 660 #define ATTRS COREATTRS,I18N,EVENTS
 661 #define NB_ATTRS NB_NB_COREATTRS + NB_I18N + NB_EVENTS
 662 #define CELLHALIGN &quot;align&quot;, &quot;char&quot;, &quot;charoff&quot;
 663 #define NB_CELLHALIGN 3
 664 #define CELLVALIGN &quot;valign&quot;
 665 #define NB_CELLVALIGN 1
 666 
 667 static const char* const html_attrs[] = { ATTRS, NULL } ;
 668 static const char* const core_i18n_attrs[] = { COREATTRS, I18N, NULL } ;
 669 static const char* const core_attrs[] = { COREATTRS, NULL } ;
 670 static const char* const i18n_attrs[] = { I18N, NULL } ;
 671 
 672 
 673 /* Other declarations that should go inline ... */
 674 static const char* const a_attrs[] = { ATTRS, &quot;charset&quot;, &quot;type&quot;, &quot;name&quot;,
 675     &quot;href&quot;, &quot;hreflang&quot;, &quot;rel&quot;, &quot;rev&quot;, &quot;accesskey&quot;, &quot;shape&quot;, &quot;coords&quot;,
 676     &quot;tabindex&quot;, &quot;onfocus&quot;, &quot;onblur&quot;, NULL } ;
 677 static const char* const target_attr[] = { &quot;target&quot;, NULL } ;
 678 static const char* const rows_cols_attr[] = { &quot;rows&quot;, &quot;cols&quot;, NULL } ;
 679 static const char* const alt_attr[] = { &quot;alt&quot;, NULL } ;
 680 static const char* const src_alt_attrs[] = { &quot;src&quot;, &quot;alt&quot;, NULL } ;
 681 static const char* const href_attrs[] = { &quot;href&quot;, NULL } ;
 682 static const char* const clear_attrs[] = { &quot;clear&quot;, NULL } ;
 683 static const char* const inline_p[] = { INLINE, &quot;p&quot;, NULL } ;
 684 
 685 static const char* const flow_param[] = { FLOW, &quot;param&quot;, NULL } ;
 686 static const char* const applet_attrs[] = { COREATTRS , &quot;codebase&quot;,
 687         &quot;archive&quot;, &quot;alt&quot;, &quot;name&quot;, &quot;height&quot;, &quot;width&quot;, &quot;align&quot;,
 688         &quot;hspace&quot;, &quot;vspace&quot;, NULL } ;
 689 static const char* const area_attrs[] = { &quot;shape&quot;, &quot;coords&quot;, &quot;href&quot;, &quot;nohref&quot;,
 690     &quot;tabindex&quot;, &quot;accesskey&quot;, &quot;onfocus&quot;, &quot;onblur&quot;, NULL } ;
 691 static const char* const basefont_attrs[] =
 692     { &quot;id&quot;, &quot;size&quot;, &quot;color&quot;, &quot;face&quot;, NULL } ;
 693 static const char* const quote_attrs[] = { ATTRS, &quot;cite&quot;, NULL } ;
 694 static const char* const body_contents[] = { FLOW, &quot;ins&quot;, &quot;del&quot;, NULL } ;
 695 static const char* const body_attrs[] = { ATTRS, &quot;onload&quot;, &quot;onunload&quot;, NULL } ;
 696 static const char* const body_depr[] = { &quot;background&quot;, &quot;bgcolor&quot;, &quot;text&quot;,
 697     &quot;link&quot;, &quot;vlink&quot;, &quot;alink&quot;, NULL } ;
 698 static const char* const button_attrs[] = { ATTRS, &quot;name&quot;, &quot;value&quot;, &quot;type&quot;,
 699     &quot;disabled&quot;, &quot;tabindex&quot;, &quot;accesskey&quot;, &quot;onfocus&quot;, &quot;onblur&quot;, NULL } ;
 700 
 701 
 702 static const char* const col_attrs[] = { ATTRS, &quot;span&quot;, &quot;width&quot;, CELLHALIGN, CELLVALIGN, NULL } ;
 703 static const char* const col_elt[] = { &quot;col&quot;, NULL } ;
 704 static const char* const edit_attrs[] = { ATTRS, &quot;datetime&quot;, &quot;cite&quot;, NULL } ;
 705 static const char* const compact_attrs[] = { ATTRS, &quot;compact&quot;, NULL } ;
 706 static const char* const dl_contents[] = { &quot;dt&quot;, &quot;dd&quot;, NULL } ;
 707 static const char* const compact_attr[] = { &quot;compact&quot;, NULL } ;
 708 static const char* const label_attr[] = { &quot;label&quot;, NULL } ;
 709 static const char* const fieldset_contents[] = { FLOW, &quot;legend&quot; } ;
 710 static const char* const font_attrs[] = { COREATTRS, I18N, &quot;size&quot;, &quot;color&quot;, &quot;face&quot; , NULL } ;
 711 static const char* const form_contents[] = { HEADING, LIST, INLINE, &quot;pre&quot;, &quot;p&quot;, &quot;div&quot;, &quot;center&quot;, &quot;noscript&quot;, &quot;noframes&quot;, &quot;blockquote&quot;, &quot;isindex&quot;, &quot;hr&quot;, &quot;table&quot;, &quot;fieldset&quot;, &quot;address&quot;, NULL } ;
 712 static const char* const form_attrs[] = { ATTRS, &quot;method&quot;, &quot;enctype&quot;, &quot;accept&quot;, &quot;name&quot;, &quot;onsubmit&quot;, &quot;onreset&quot;, &quot;accept-charset&quot;, NULL } ;
 713 static const char* const frame_attrs[] = { COREATTRS, &quot;longdesc&quot;, &quot;name&quot;, &quot;src&quot;, &quot;frameborder&quot;, &quot;marginwidth&quot;, &quot;marginheight&quot;, &quot;noresize&quot;, &quot;scrolling&quot; , NULL } ;
 714 static const char* const frameset_attrs[] = { COREATTRS, &quot;rows&quot;, &quot;cols&quot;, &quot;onload&quot;, &quot;onunload&quot;, NULL } ;
 715 static const char* const frameset_contents[] = { &quot;frameset&quot;, &quot;frame&quot;, &quot;noframes&quot;, NULL } ;
 716 static const char* const head_attrs[] = { I18N, &quot;profile&quot;, NULL } ;
 717 static const char* const head_contents[] = { &quot;title&quot;, &quot;isindex&quot;, &quot;base&quot;, &quot;script&quot;, &quot;style&quot;, &quot;meta&quot;, &quot;link&quot;, &quot;object&quot;, NULL } ;
 718 static const char* const hr_depr[] = { &quot;align&quot;, &quot;noshade&quot;, &quot;size&quot;, &quot;width&quot;, NULL } ;
 719 static const char* const version_attr[] = { &quot;version&quot;, NULL } ;
 720 static const char* const html_content[] = { &quot;head&quot;, &quot;body&quot;, &quot;frameset&quot;, NULL } ;
 721 static const char* const iframe_attrs[] = { COREATTRS, &quot;longdesc&quot;, &quot;name&quot;, &quot;src&quot;, &quot;frameborder&quot;, &quot;marginwidth&quot;, &quot;marginheight&quot;, &quot;scrolling&quot;, &quot;align&quot;, &quot;height&quot;, &quot;width&quot;, NULL } ;
 722 static const char* const img_attrs[] = { ATTRS, &quot;longdesc&quot;, &quot;name&quot;, &quot;height&quot;, &quot;width&quot;, &quot;usemap&quot;, &quot;ismap&quot;, NULL } ;
 723 static const char* const embed_attrs[] = { COREATTRS, &quot;align&quot;, &quot;alt&quot;, &quot;border&quot;, &quot;code&quot;, &quot;codebase&quot;, &quot;frameborder&quot;, &quot;height&quot;, &quot;hidden&quot;, &quot;hspace&quot;, &quot;name&quot;, &quot;palette&quot;, &quot;pluginspace&quot;, &quot;pluginurl&quot;, &quot;src&quot;, &quot;type&quot;, &quot;units&quot;, &quot;vspace&quot;, &quot;width&quot;, NULL } ;
 724 static const char* const input_attrs[] = { ATTRS, &quot;type&quot;, &quot;name&quot;, &quot;value&quot;, &quot;checked&quot;, &quot;disabled&quot;, &quot;readonly&quot;, &quot;size&quot;, &quot;maxlength&quot;, &quot;src&quot;, &quot;alt&quot;, &quot;usemap&quot;, &quot;ismap&quot;, &quot;tabindex&quot;, &quot;accesskey&quot;, &quot;onfocus&quot;, &quot;onblur&quot;, &quot;onselect&quot;, &quot;onchange&quot;, &quot;accept&quot;, NULL } ;
 725 static const char* const prompt_attrs[] = { COREATTRS, I18N, &quot;prompt&quot;, NULL } ;
 726 static const char* const label_attrs[] = { ATTRS, &quot;for&quot;, &quot;accesskey&quot;, &quot;onfocus&quot;, &quot;onblur&quot;, NULL } ;
 727 static const char* const legend_attrs[] = { ATTRS, &quot;accesskey&quot;, NULL } ;
 728 static const char* const align_attr[] = { &quot;align&quot;, NULL } ;
 729 static const char* const link_attrs[] = { ATTRS, &quot;charset&quot;, &quot;href&quot;, &quot;hreflang&quot;, &quot;type&quot;, &quot;rel&quot;, &quot;rev&quot;, &quot;media&quot;, NULL } ;
 730 static const char* const map_contents[] = { BLOCK, &quot;area&quot;, NULL } ;
 731 static const char* const name_attr[] = { &quot;name&quot;, NULL } ;
 732 static const char* const action_attr[] = { &quot;action&quot;, NULL } ;
 733 static const char* const blockli_elt[] = { BLOCK, &quot;li&quot;, NULL } ;
 734 static const char* const meta_attrs[] = { I18N, &quot;http-equiv&quot;, &quot;name&quot;, &quot;scheme&quot;, &quot;charset&quot;, NULL } ;
 735 static const char* const content_attr[] = { &quot;content&quot;, NULL } ;
 736 static const char* const type_attr[] = { &quot;type&quot;, NULL } ;
 737 static const char* const noframes_content[] = { &quot;body&quot;, FLOW MODIFIER, NULL } ;
 738 static const char* const object_contents[] = { FLOW, &quot;param&quot;, NULL } ;
 739 static const char* const object_attrs[] = { ATTRS, &quot;declare&quot;, &quot;classid&quot;, &quot;codebase&quot;, &quot;data&quot;, &quot;type&quot;, &quot;codetype&quot;, &quot;archive&quot;, &quot;standby&quot;, &quot;height&quot;, &quot;width&quot;, &quot;usemap&quot;, &quot;name&quot;, &quot;tabindex&quot;, NULL } ;
 740 static const char* const object_depr[] = { &quot;align&quot;, &quot;border&quot;, &quot;hspace&quot;, &quot;vspace&quot;, NULL } ;
 741 static const char* const ol_attrs[] = { &quot;type&quot;, &quot;compact&quot;, &quot;start&quot;, NULL} ;
 742 static const char* const option_elt[] = { &quot;option&quot;, NULL } ;
 743 static const char* const optgroup_attrs[] = { ATTRS, &quot;disabled&quot;, NULL } ;
 744 static const char* const option_attrs[] = { ATTRS, &quot;disabled&quot;, &quot;label&quot;, &quot;selected&quot;, &quot;value&quot;, NULL } ;
 745 static const char* const param_attrs[] = { &quot;id&quot;, &quot;value&quot;, &quot;valuetype&quot;, &quot;type&quot;, NULL } ;
 746 static const char* const width_attr[] = { &quot;width&quot;, NULL } ;
 747 static const char* const pre_content[] = { PHRASE, &quot;tt&quot;, &quot;i&quot;, &quot;b&quot;, &quot;u&quot;, &quot;s&quot;, &quot;strike&quot;, &quot;a&quot;, &quot;br&quot;, &quot;script&quot;, &quot;map&quot;, &quot;q&quot;, &quot;span&quot;, &quot;bdo&quot;, &quot;iframe&quot;, NULL } ;
 748 static const char* const script_attrs[] = { &quot;charset&quot;, &quot;src&quot;, &quot;defer&quot;, &quot;event&quot;, &quot;for&quot;, NULL } ;
 749 static const char* const language_attr[] = { &quot;language&quot;, NULL } ;
 750 static const char* const select_content[] = { &quot;optgroup&quot;, &quot;option&quot;, NULL } ;
 751 static const char* const select_attrs[] = { ATTRS, &quot;name&quot;, &quot;size&quot;, &quot;multiple&quot;, &quot;disabled&quot;, &quot;tabindex&quot;, &quot;onfocus&quot;, &quot;onblur&quot;, &quot;onchange&quot;, NULL } ;
 752 static const char* const style_attrs[] = { I18N, &quot;media&quot;, &quot;title&quot;, NULL } ;
 753 static const char* const table_attrs[] = { ATTRS, &quot;summary&quot;, &quot;width&quot;, &quot;border&quot;, &quot;frame&quot;, &quot;rules&quot;, &quot;cellspacing&quot;, &quot;cellpadding&quot;, &quot;datapagesize&quot;, NULL } ;
 754 static const char* const table_depr[] = { &quot;align&quot;, &quot;bgcolor&quot;, NULL } ;
 755 static const char* const table_contents[] = { &quot;caption&quot;, &quot;col&quot;, &quot;colgroup&quot;, &quot;thead&quot;, &quot;tfoot&quot;, &quot;tbody&quot;, &quot;tr&quot;, NULL} ;
 756 static const char* const tr_elt[] = { &quot;tr&quot;, NULL } ;
 757 static const char* const talign_attrs[] = { ATTRS, CELLHALIGN, CELLVALIGN, NULL} ;
 758 static const char* const th_td_depr[] = { &quot;nowrap&quot;, &quot;bgcolor&quot;, &quot;width&quot;, &quot;height&quot;, NULL } ;
 759 static const char* const th_td_attr[] = { ATTRS, &quot;abbr&quot;, &quot;axis&quot;, &quot;headers&quot;, &quot;scope&quot;, &quot;rowspan&quot;, &quot;colspan&quot;, CELLHALIGN, CELLVALIGN, NULL } ;
 760 static const char* const textarea_attrs[] = { ATTRS, &quot;name&quot;, &quot;disabled&quot;, &quot;readonly&quot;, &quot;tabindex&quot;, &quot;accesskey&quot;, &quot;onfocus&quot;, &quot;onblur&quot;, &quot;onselect&quot;, &quot;onchange&quot;, NULL } ;
 761 static const char* const tr_contents[] = { &quot;th&quot;, &quot;td&quot;, NULL } ;
 762 static const char* const bgcolor_attr[] = { &quot;bgcolor&quot;, NULL } ;
 763 static const char* const li_elt[] = { &quot;li&quot;, NULL } ;
 764 static const char* const ul_depr[] = { &quot;type&quot;, &quot;compact&quot;, NULL} ;
 765 static const char* const dir_attr[] = { &quot;dir&quot;, NULL} ;
 766 
 767 #define DECL (const char**)
 768 
 769 static const htmlElemDesc
 770 html40ElementTable[] = {
 771 { &quot;a&quot;,      0, 0, 0, 0, 0, 0, 1, &quot;anchor &quot;,
 772     DECL html_inline , NULL , DECL a_attrs , DECL target_attr, NULL
 773 },
 774 { &quot;abbr&quot;,   0, 0, 0, 0, 0, 0, 1, &quot;abbreviated form&quot;,
 775     DECL html_inline , NULL , DECL html_attrs, NULL, NULL
 776 },
 777 { &quot;acronym&quot;,    0, 0, 0, 0, 0, 0, 1, &quot;&quot;,
 778     DECL html_inline , NULL , DECL html_attrs, NULL, NULL
 779 },
 780 { &quot;address&quot;,    0, 0, 0, 0, 0, 0, 0, &quot;information on author &quot;,
 781     DECL inline_p  , NULL , DECL html_attrs, NULL, NULL
 782 },
 783 { &quot;applet&quot;, 0, 0, 0, 0, 1, 1, 2, &quot;java applet &quot;,
 784     DECL flow_param , NULL , NULL , DECL applet_attrs, NULL
 785 },
 786 { &quot;area&quot;,   0, 2, 2, 1, 0, 0, 0, &quot;client-side image map area &quot;,
 787     EMPTY ,  NULL , DECL area_attrs , DECL target_attr, DECL alt_attr
 788 },
 789 { &quot;b&quot;,      0, 3, 0, 0, 0, 0, 1, &quot;bold text style&quot;,
 790     DECL html_inline , NULL , DECL html_attrs, NULL, NULL
 791 },
 792 { &quot;base&quot;,   0, 2, 2, 1, 0, 0, 0, &quot;document base uri &quot;,
 793     EMPTY , NULL , NULL , DECL target_attr, DECL href_attrs
 794 },
 795 { &quot;basefont&quot;,   0, 2, 2, 1, 1, 1, 1, &quot;base font size &quot; ,
 796     EMPTY , NULL , NULL, DECL basefont_attrs, NULL
 797 },
 798 { &quot;bdo&quot;,    0, 0, 0, 0, 0, 0, 1, &quot;i18n bidi over-ride &quot;,
 799     DECL html_inline , NULL , DECL core_i18n_attrs, NULL, DECL dir_attr
 800 },
 801 { &quot;big&quot;,    0, 3, 0, 0, 0, 0, 1, &quot;large text style&quot;,
 802     DECL html_inline , NULL , DECL html_attrs, NULL, NULL
 803 },
 804 { &quot;blockquote&quot;, 0, 0, 0, 0, 0, 0, 0, &quot;long quotation &quot;,
 805     DECL html_flow , NULL , DECL quote_attrs , NULL, NULL
 806 },
 807 { &quot;body&quot;,   1, 1, 0, 0, 0, 0, 0, &quot;document body &quot;,
 808     DECL body_contents , &quot;div&quot; , DECL body_attrs, DECL body_depr, NULL
 809 },
 810 { &quot;br&quot;,     0, 2, 2, 1, 0, 0, 1, &quot;forced line break &quot;,
 811     EMPTY , NULL , DECL core_attrs, DECL clear_attrs , NULL
 812 },
 813 { &quot;button&quot;, 0, 0, 0, 0, 0, 0, 2, &quot;push button &quot;,
 814     DECL html_flow MODIFIER , NULL , DECL button_attrs, NULL, NULL
 815 },
 816 { &quot;caption&quot;,    0, 0, 0, 0, 0, 0, 0, &quot;table caption &quot;,
 817     DECL html_inline , NULL , DECL html_attrs, NULL, NULL
 818 },
 819 { &quot;center&quot;, 0, 3, 0, 0, 1, 1, 0, &quot;shorthand for div align=center &quot;,
 820     DECL html_flow , NULL , NULL, DECL html_attrs, NULL
 821 },
 822 { &quot;cite&quot;,   0, 0, 0, 0, 0, 0, 1, &quot;citation&quot;,
 823     DECL html_inline , NULL , DECL html_attrs, NULL, NULL
 824 },
 825 { &quot;code&quot;,   0, 0, 0, 0, 0, 0, 1, &quot;computer code fragment&quot;,
 826     DECL html_inline , NULL , DECL html_attrs, NULL, NULL
 827 },
 828 { &quot;col&quot;,    0, 2, 2, 1, 0, 0, 0, &quot;table column &quot;,
 829     EMPTY , NULL , DECL col_attrs , NULL, NULL
 830 },
 831 { &quot;colgroup&quot;,   0, 1, 0, 0, 0, 0, 0, &quot;table column group &quot;,
 832     DECL col_elt , &quot;col&quot; , DECL col_attrs , NULL, NULL
 833 },
 834 { &quot;dd&quot;,     0, 1, 0, 0, 0, 0, 0, &quot;definition description &quot;,
 835     DECL html_flow , NULL , DECL html_attrs, NULL, NULL
 836 },
 837 { &quot;del&quot;,    0, 0, 0, 0, 0, 0, 2, &quot;deleted text &quot;,
 838     DECL html_flow , NULL , DECL edit_attrs , NULL, NULL
 839 },
 840 { &quot;dfn&quot;,    0, 0, 0, 0, 0, 0, 1, &quot;instance definition&quot;,
 841     DECL html_inline , NULL , DECL html_attrs, NULL, NULL
 842 },
 843 { &quot;dir&quot;,    0, 0, 0, 0, 1, 1, 0, &quot;directory list&quot;,
 844     DECL blockli_elt, &quot;li&quot; , NULL, DECL compact_attrs, NULL
 845 },
 846 { &quot;div&quot;,    0, 0, 0, 0, 0, 0, 0, &quot;generic language/style container&quot;,
 847     DECL html_flow, NULL, DECL html_attrs, DECL align_attr, NULL
 848 },
 849 { &quot;dl&quot;,     0, 0, 0, 0, 0, 0, 0, &quot;definition list &quot;,
 850     DECL dl_contents , &quot;dd&quot; , DECL html_attrs, DECL compact_attr, NULL
 851 },
 852 { &quot;dt&quot;,     0, 1, 0, 0, 0, 0, 0, &quot;definition term &quot;,
 853     DECL html_inline, NULL, DECL html_attrs, NULL, NULL
 854 },
 855 { &quot;em&quot;,     0, 3, 0, 0, 0, 0, 1, &quot;emphasis&quot;,
 856     DECL html_inline, NULL, DECL html_attrs, NULL, NULL
 857 },
 858 { &quot;embed&quot;,  0, 1, 0, 0, 1, 1, 1, &quot;generic embedded object &quot;,
 859     EMPTY, NULL, DECL embed_attrs, NULL, NULL
 860 },
 861 { &quot;fieldset&quot;,   0, 0, 0, 0, 0, 0, 0, &quot;form control group &quot;,
 862     DECL fieldset_contents , NULL, DECL html_attrs, NULL, NULL
 863 },
 864 { &quot;font&quot;,   0, 3, 0, 0, 1, 1, 1, &quot;local change to font &quot;,
 865     DECL html_inline, NULL, NULL, DECL font_attrs, NULL
 866 },
 867 { &quot;form&quot;,   0, 0, 0, 0, 0, 0, 0, &quot;interactive form &quot;,
 868     DECL form_contents, &quot;fieldset&quot;, DECL form_attrs , DECL target_attr, DECL action_attr
 869 },
 870 { &quot;frame&quot;,  0, 2, 2, 1, 0, 2, 0, &quot;subwindow &quot; ,
 871     EMPTY, NULL, NULL, DECL frame_attrs, NULL
 872 },
 873 { &quot;frameset&quot;,   0, 0, 0, 0, 0, 2, 0, &quot;window subdivision&quot; ,
 874     DECL frameset_contents, &quot;noframes&quot; , NULL , DECL frameset_attrs, NULL
 875 },
 876 { &quot;h1&quot;,     0, 0, 0, 0, 0, 0, 0, &quot;heading &quot;,
 877     DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL
 878 },
 879 { &quot;h2&quot;,     0, 0, 0, 0, 0, 0, 0, &quot;heading &quot;,
 880     DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL
 881 },
 882 { &quot;h3&quot;,     0, 0, 0, 0, 0, 0, 0, &quot;heading &quot;,
 883     DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL
 884 },
 885 { &quot;h4&quot;,     0, 0, 0, 0, 0, 0, 0, &quot;heading &quot;,
 886     DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL
 887 },
 888 { &quot;h5&quot;,     0, 0, 0, 0, 0, 0, 0, &quot;heading &quot;,
 889     DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL
 890 },
 891 { &quot;h6&quot;,     0, 0, 0, 0, 0, 0, 0, &quot;heading &quot;,
 892     DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL
 893 },
 894 { &quot;head&quot;,   1, 1, 0, 0, 0, 0, 0, &quot;document head &quot;,
 895     DECL head_contents, NULL, DECL head_attrs, NULL, NULL
 896 },
 897 { &quot;hr&quot;,     0, 2, 2, 1, 0, 0, 0, &quot;horizontal rule &quot; ,
 898     EMPTY, NULL, DECL html_attrs, DECL hr_depr, NULL
 899 },
 900 { &quot;html&quot;,   1, 1, 0, 0, 0, 0, 0, &quot;document root element &quot;,
 901     DECL html_content , NULL , DECL i18n_attrs, DECL version_attr, NULL
 902 },
 903 { &quot;i&quot;,      0, 3, 0, 0, 0, 0, 1, &quot;italic text style&quot;,
 904     DECL html_inline, NULL, DECL html_attrs, NULL, NULL
 905 },
 906 { &quot;iframe&quot;, 0, 0, 0, 0, 0, 1, 2, &quot;inline subwindow &quot;,
 907     DECL html_flow, NULL, NULL, DECL iframe_attrs, NULL
 908 },
 909 { &quot;img&quot;,    0, 2, 2, 1, 0, 0, 1, &quot;embedded image &quot;,
 910     EMPTY, NULL, DECL img_attrs, DECL align_attr, DECL src_alt_attrs
 911 },
 912 { &quot;input&quot;,  0, 2, 2, 1, 0, 0, 1, &quot;form control &quot;,
 913     EMPTY, NULL, DECL input_attrs , DECL align_attr, NULL
 914 },
 915 { &quot;ins&quot;,    0, 0, 0, 0, 0, 0, 2, &quot;inserted text&quot;,
 916     DECL html_flow, NULL, DECL edit_attrs, NULL, NULL
 917 },
 918 { &quot;isindex&quot;,    0, 2, 2, 1, 1, 1, 0, &quot;single line prompt &quot;,
 919     EMPTY, NULL, NULL, DECL prompt_attrs, NULL
 920 },
 921 { &quot;kbd&quot;,    0, 0, 0, 0, 0, 0, 1, &quot;text to be entered by the user&quot;,
 922     DECL html_inline, NULL, DECL html_attrs, NULL, NULL
 923 },
 924 { &quot;label&quot;,  0, 0, 0, 0, 0, 0, 1, &quot;form field label text &quot;,
 925     DECL html_inline MODIFIER, NULL, DECL label_attrs , NULL, NULL
 926 },
 927 { &quot;legend&quot;, 0, 0, 0, 0, 0, 0, 0, &quot;fieldset legend &quot;,
 928     DECL html_inline, NULL, DECL legend_attrs , DECL align_attr, NULL
 929 },
 930 { &quot;li&quot;,     0, 1, 1, 0, 0, 0, 0, &quot;list item &quot;,
 931     DECL html_flow, NULL, DECL html_attrs, NULL, NULL
 932 },
 933 { &quot;link&quot;,   0, 2, 2, 1, 0, 0, 0, &quot;a media-independent link &quot;,
 934     EMPTY, NULL, DECL link_attrs, DECL target_attr, NULL
 935 },
 936 { &quot;map&quot;,    0, 0, 0, 0, 0, 0, 2, &quot;client-side image map &quot;,
 937     DECL map_contents , NULL, DECL html_attrs , NULL, DECL name_attr
 938 },
 939 { &quot;menu&quot;,   0, 0, 0, 0, 1, 1, 0, &quot;menu list &quot;,
 940     DECL blockli_elt , NULL, NULL, DECL compact_attrs, NULL
 941 },
 942 { &quot;meta&quot;,   0, 2, 2, 1, 0, 0, 0, &quot;generic metainformation &quot;,
 943     EMPTY, NULL, DECL meta_attrs , NULL , DECL content_attr
 944 },
 945 { &quot;noframes&quot;,   0, 0, 0, 0, 0, 2, 0, &quot;alternate content container for non frame-based rendering &quot;,
 946     DECL noframes_content, &quot;body&quot; , DECL html_attrs, NULL, NULL
 947 },
 948 { &quot;noscript&quot;,   0, 0, 0, 0, 0, 0, 0, &quot;alternate content container for non script-based rendering &quot;,
 949     DECL html_flow, &quot;div&quot;, DECL html_attrs, NULL, NULL
 950 },
 951 { &quot;object&quot;, 0, 0, 0, 0, 0, 0, 2, &quot;generic embedded object &quot;,
 952     DECL object_contents , &quot;div&quot; , DECL object_attrs, DECL object_depr, NULL
 953 },
 954 { &quot;ol&quot;,     0, 0, 0, 0, 0, 0, 0, &quot;ordered list &quot;,
 955     DECL li_elt , &quot;li&quot; , DECL html_attrs, DECL ol_attrs, NULL
 956 },
 957 { &quot;optgroup&quot;,   0, 0, 0, 0, 0, 0, 0, &quot;option group &quot;,
 958     DECL option_elt , &quot;option&quot;, DECL optgroup_attrs, NULL, DECL label_attr
 959 },
 960 { &quot;option&quot;, 0, 1, 0, 0, 0, 0, 0, &quot;selectable choice &quot; ,
 961     DECL html_pcdata, NULL, DECL option_attrs, NULL, NULL
 962 },
 963 { &quot;p&quot;,      0, 1, 0, 0, 0, 0, 0, &quot;paragraph &quot;,
 964     DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL
 965 },
 966 { &quot;param&quot;,  0, 2, 2, 1, 0, 0, 0, &quot;named property value &quot;,
 967     EMPTY, NULL, DECL param_attrs, NULL, DECL name_attr
 968 },
 969 { &quot;pre&quot;,    0, 0, 0, 0, 0, 0, 0, &quot;preformatted text &quot;,
 970     DECL pre_content, NULL, DECL html_attrs, DECL width_attr, NULL
 971 },
 972 { &quot;q&quot;,      0, 0, 0, 0, 0, 0, 1, &quot;short inline quotation &quot;,
 973     DECL html_inline, NULL, DECL quote_attrs, NULL, NULL
 974 },
 975 { &quot;s&quot;,      0, 3, 0, 0, 1, 1, 1, &quot;strike-through text style&quot;,
 976     DECL html_inline, NULL, NULL, DECL html_attrs, NULL
 977 },
 978 { &quot;samp&quot;,   0, 0, 0, 0, 0, 0, 1, &quot;sample program output, scripts, etc.&quot;,
 979     DECL html_inline, NULL, DECL html_attrs, NULL, NULL
 980 },
 981 { &quot;script&quot;, 0, 0, 0, 0, 0, 0, 2, &quot;script statements &quot;,
 982     DECL html_cdata, NULL, DECL script_attrs, DECL language_attr, DECL type_attr
 983 },
 984 { &quot;select&quot;, 0, 0, 0, 0, 0, 0, 1, &quot;option selector &quot;,
 985     DECL select_content, NULL, DECL select_attrs, NULL, NULL
 986 },
 987 { &quot;small&quot;,  0, 3, 0, 0, 0, 0, 1, &quot;small text style&quot;,
 988     DECL html_inline, NULL, DECL html_attrs, NULL, NULL
 989 },
 990 { &quot;span&quot;,   0, 0, 0, 0, 0, 0, 1, &quot;generic language/style container &quot;,
 991     DECL html_inline, NULL, DECL html_attrs, NULL, NULL
 992 },
 993 { &quot;strike&quot;, 0, 3, 0, 0, 1, 1, 1, &quot;strike-through text&quot;,
 994     DECL html_inline, NULL, NULL, DECL html_attrs, NULL
 995 },
 996 { &quot;strong&quot;, 0, 3, 0, 0, 0, 0, 1, &quot;strong emphasis&quot;,
 997     DECL html_inline, NULL, DECL html_attrs, NULL, NULL
 998 },
 999 { &quot;style&quot;,  0, 0, 0, 0, 0, 0, 0, &quot;style info &quot;,
1000     DECL html_cdata, NULL, DECL style_attrs, NULL, DECL type_attr
1001 },
1002 { &quot;sub&quot;,    0, 3, 0, 0, 0, 0, 1, &quot;subscript&quot;,
1003     DECL html_inline, NULL, DECL html_attrs, NULL, NULL
1004 },
1005 { &quot;sup&quot;,    0, 3, 0, 0, 0, 0, 1, &quot;superscript &quot;,
1006     DECL html_inline, NULL, DECL html_attrs, NULL, NULL
1007 },
1008 { &quot;table&quot;,  0, 0, 0, 0, 0, 0, 0, &quot;&quot;,
1009     DECL table_contents , &quot;tr&quot; , DECL table_attrs , DECL table_depr, NULL
1010 },
1011 { &quot;tbody&quot;,  1, 0, 0, 0, 0, 0, 0, &quot;table body &quot;,
1012     DECL tr_elt , &quot;tr&quot; , DECL talign_attrs, NULL, NULL
1013 },
1014 { &quot;td&quot;,     0, 0, 0, 0, 0, 0, 0, &quot;table data cell&quot;,
1015     DECL html_flow, NULL, DECL th_td_attr, DECL th_td_depr, NULL
1016 },
1017 { &quot;textarea&quot;,   0, 0, 0, 0, 0, 0, 1, &quot;multi-line text field &quot;,
1018     DECL html_pcdata, NULL, DECL textarea_attrs, NULL, DECL rows_cols_attr
1019 },
1020 { &quot;tfoot&quot;,  0, 1, 0, 0, 0, 0, 0, &quot;table footer &quot;,
1021     DECL tr_elt , &quot;tr&quot; , DECL talign_attrs, NULL, NULL
1022 },
1023 { &quot;th&quot;,     0, 1, 0, 0, 0, 0, 0, &quot;table header cell&quot;,
1024     DECL html_flow, NULL, DECL th_td_attr, DECL th_td_depr, NULL
1025 },
1026 { &quot;thead&quot;,  0, 1, 0, 0, 0, 0, 0, &quot;table header &quot;,
1027     DECL tr_elt , &quot;tr&quot; , DECL talign_attrs, NULL, NULL
1028 },
1029 { &quot;title&quot;,  0, 0, 0, 0, 0, 0, 0, &quot;document title &quot;,
1030     DECL html_pcdata, NULL, DECL i18n_attrs, NULL, NULL
1031 },
1032 { &quot;tr&quot;,     0, 0, 0, 0, 0, 0, 0, &quot;table row &quot;,
1033     DECL tr_contents , &quot;td&quot; , DECL talign_attrs, DECL bgcolor_attr, NULL
1034 },
1035 { &quot;tt&quot;,     0, 3, 0, 0, 0, 0, 1, &quot;teletype or monospaced text style&quot;,
1036     DECL html_inline, NULL, DECL html_attrs, NULL, NULL
1037 },
1038 { &quot;u&quot;,      0, 3, 0, 0, 1, 1, 1, &quot;underlined text style&quot;,
1039     DECL html_inline, NULL, NULL, DECL html_attrs, NULL
1040 },
1041 { &quot;ul&quot;,     0, 0, 0, 0, 0, 0, 0, &quot;unordered list &quot;,
1042     DECL li_elt , &quot;li&quot; , DECL html_attrs, DECL ul_depr, NULL
1043 },
1044 { &quot;var&quot;,    0, 0, 0, 0, 0, 0, 1, &quot;instance of a variable or program argument&quot;,
1045     DECL html_inline, NULL, DECL html_attrs, NULL, NULL
1046 }
1047 };
1048 
1049 /*
1050  * start tags that imply the end of current element
1051  */
1052 static const char * const htmlStartClose[] = {
1053 &quot;form&quot;,     &quot;form&quot;, &quot;p&quot;, &quot;hr&quot;, &quot;h1&quot;, &quot;h2&quot;, &quot;h3&quot;, &quot;h4&quot;, &quot;h5&quot;, &quot;h6&quot;,
1054         &quot;dl&quot;, &quot;ul&quot;, &quot;ol&quot;, &quot;menu&quot;, &quot;dir&quot;, &quot;address&quot;, &quot;pre&quot;,
1055         &quot;listing&quot;, &quot;xmp&quot;, &quot;head&quot;, NULL,
1056 &quot;head&quot;,     &quot;p&quot;, NULL,
1057 &quot;title&quot;,    &quot;p&quot;, NULL,
1058 &quot;body&quot;,     &quot;head&quot;, &quot;style&quot;, &quot;link&quot;, &quot;title&quot;, &quot;p&quot;, NULL,
1059 &quot;frameset&quot;, &quot;head&quot;, &quot;style&quot;, &quot;link&quot;, &quot;title&quot;, &quot;p&quot;, NULL,
1060 &quot;li&quot;,       &quot;p&quot;, &quot;h1&quot;, &quot;h2&quot;, &quot;h3&quot;, &quot;h4&quot;, &quot;h5&quot;, &quot;h6&quot;, &quot;dl&quot;, &quot;address&quot;,
1061         &quot;pre&quot;, &quot;listing&quot;, &quot;xmp&quot;, &quot;head&quot;, &quot;li&quot;, NULL,
1062 &quot;hr&quot;,       &quot;p&quot;, &quot;head&quot;, NULL,
1063 &quot;h1&quot;,       &quot;p&quot;, &quot;head&quot;, NULL,
1064 &quot;h2&quot;,       &quot;p&quot;, &quot;head&quot;, NULL,
1065 &quot;h3&quot;,       &quot;p&quot;, &quot;head&quot;, NULL,
1066 &quot;h4&quot;,       &quot;p&quot;, &quot;head&quot;, NULL,
1067 &quot;h5&quot;,       &quot;p&quot;, &quot;head&quot;, NULL,
1068 &quot;h6&quot;,       &quot;p&quot;, &quot;head&quot;, NULL,
1069 &quot;dir&quot;,      &quot;p&quot;, &quot;head&quot;, NULL,
1070 &quot;address&quot;,  &quot;p&quot;, &quot;head&quot;, &quot;ul&quot;, NULL,
1071 &quot;pre&quot;,      &quot;p&quot;, &quot;head&quot;, &quot;ul&quot;, NULL,
1072 &quot;listing&quot;,  &quot;p&quot;, &quot;head&quot;, NULL,
1073 &quot;xmp&quot;,      &quot;p&quot;, &quot;head&quot;, NULL,
1074 &quot;blockquote&quot;,   &quot;p&quot;, &quot;head&quot;, NULL,
1075 &quot;dl&quot;,       &quot;p&quot;, &quot;dt&quot;, &quot;menu&quot;, &quot;dir&quot;, &quot;address&quot;, &quot;pre&quot;, &quot;listing&quot;,
1076         &quot;xmp&quot;, &quot;head&quot;, NULL,
1077 &quot;dt&quot;,       &quot;p&quot;, &quot;menu&quot;, &quot;dir&quot;, &quot;address&quot;, &quot;pre&quot;, &quot;listing&quot;, &quot;xmp&quot;,
1078                 &quot;head&quot;, &quot;dd&quot;, NULL,
1079 &quot;dd&quot;,       &quot;p&quot;, &quot;menu&quot;, &quot;dir&quot;, &quot;address&quot;, &quot;pre&quot;, &quot;listing&quot;, &quot;xmp&quot;,
1080                 &quot;head&quot;, &quot;dt&quot;, NULL,
1081 &quot;ul&quot;,       &quot;p&quot;, &quot;head&quot;, &quot;ol&quot;, &quot;menu&quot;, &quot;dir&quot;, &quot;address&quot;, &quot;pre&quot;,
1082         &quot;listing&quot;, &quot;xmp&quot;, NULL,
1083 &quot;ol&quot;,       &quot;p&quot;, &quot;head&quot;, &quot;ul&quot;, NULL,
1084 &quot;menu&quot;,     &quot;p&quot;, &quot;head&quot;, &quot;ul&quot;, NULL,
1085 &quot;p&quot;,        &quot;p&quot;, &quot;head&quot;, &quot;h1&quot;, &quot;h2&quot;, &quot;h3&quot;, &quot;h4&quot;, &quot;h5&quot;, &quot;h6&quot;, FONTSTYLE, NULL,
1086 &quot;div&quot;,      &quot;p&quot;, &quot;head&quot;, NULL,
1087 &quot;noscript&quot;, &quot;script&quot;, NULL,
1088 &quot;center&quot;,   &quot;font&quot;, &quot;b&quot;, &quot;i&quot;, &quot;p&quot;, &quot;head&quot;, NULL,
1089 &quot;a&quot;,        &quot;a&quot;, &quot;head&quot;, NULL,
1090 &quot;caption&quot;,  &quot;p&quot;, NULL,
1091 &quot;colgroup&quot;, &quot;caption&quot;, &quot;colgroup&quot;, &quot;col&quot;, &quot;p&quot;, NULL,
1092 &quot;col&quot;,      &quot;caption&quot;, &quot;col&quot;, &quot;p&quot;, NULL,
1093 &quot;table&quot;,    &quot;p&quot;, &quot;head&quot;, &quot;h1&quot;, &quot;h2&quot;, &quot;h3&quot;, &quot;h4&quot;, &quot;h5&quot;, &quot;h6&quot;, &quot;pre&quot;,
1094         &quot;listing&quot;, &quot;xmp&quot;, &quot;a&quot;, NULL,
1095 &quot;th&quot;,       &quot;th&quot;, &quot;td&quot;, &quot;p&quot;, &quot;span&quot;, &quot;font&quot;, &quot;a&quot;, &quot;b&quot;, &quot;i&quot;, &quot;u&quot;, NULL,
1096 &quot;td&quot;,       &quot;th&quot;, &quot;td&quot;, &quot;p&quot;, &quot;span&quot;, &quot;font&quot;, &quot;a&quot;, &quot;b&quot;, &quot;i&quot;, &quot;u&quot;, NULL,
1097 &quot;tr&quot;,       &quot;th&quot;, &quot;td&quot;, &quot;tr&quot;, &quot;caption&quot;, &quot;col&quot;, &quot;colgroup&quot;, &quot;p&quot;, NULL,
1098 &quot;thead&quot;,    &quot;caption&quot;, &quot;col&quot;, &quot;colgroup&quot;, NULL,
1099 &quot;tfoot&quot;,    &quot;th&quot;, &quot;td&quot;, &quot;tr&quot;, &quot;caption&quot;, &quot;col&quot;, &quot;colgroup&quot;, &quot;thead&quot;,
1100         &quot;tbody&quot;, &quot;p&quot;, NULL,
1101 &quot;tbody&quot;,    &quot;th&quot;, &quot;td&quot;, &quot;tr&quot;, &quot;caption&quot;, &quot;col&quot;, &quot;colgroup&quot;, &quot;thead&quot;,
1102         &quot;tfoot&quot;, &quot;tbody&quot;, &quot;p&quot;, NULL,
1103 &quot;optgroup&quot;, &quot;option&quot;, NULL,
1104 &quot;option&quot;,   &quot;option&quot;, NULL,
1105 &quot;fieldset&quot;, &quot;legend&quot;, &quot;p&quot;, &quot;head&quot;, &quot;h1&quot;, &quot;h2&quot;, &quot;h3&quot;, &quot;h4&quot;, &quot;h5&quot;, &quot;h6&quot;,
1106         &quot;pre&quot;, &quot;listing&quot;, &quot;xmp&quot;, &quot;a&quot;, NULL,
1107 /* most tags in in FONTSTYLE, PHRASE and SPECIAL should close &lt;head&gt; */
1108 &quot;tt&quot;,       &quot;head&quot;, NULL,
1109 &quot;i&quot;,        &quot;head&quot;, NULL,
1110 &quot;b&quot;,        &quot;head&quot;, NULL,
1111 &quot;u&quot;,        &quot;head&quot;, NULL,
1112 &quot;s&quot;,        &quot;head&quot;, NULL,
1113 &quot;strike&quot;,   &quot;head&quot;, NULL,
1114 &quot;big&quot;,      &quot;head&quot;, NULL,
1115 &quot;small&quot;,    &quot;head&quot;, NULL,
1116 
1117 &quot;em&quot;,       &quot;head&quot;, NULL,
1118 &quot;strong&quot;,   &quot;head&quot;, NULL,
1119 &quot;dfn&quot;,      &quot;head&quot;, NULL,
1120 &quot;code&quot;,     &quot;head&quot;, NULL,
1121 &quot;samp&quot;,     &quot;head&quot;, NULL,
1122 &quot;kbd&quot;,      &quot;head&quot;, NULL,
1123 &quot;var&quot;,      &quot;head&quot;, NULL,
1124 &quot;cite&quot;,     &quot;head&quot;, NULL,
1125 &quot;abbr&quot;,     &quot;head&quot;, NULL,
1126 &quot;acronym&quot;,  &quot;head&quot;, NULL,
1127 
1128 /* &quot;a&quot; */
1129 &quot;img&quot;,      &quot;head&quot;, NULL,
1130 /* &quot;applet&quot; */
1131 /* &quot;embed&quot; */
1132 /* &quot;object&quot; */
1133 &quot;font&quot;,     &quot;head&quot;, NULL,
1134 /* &quot;basefont&quot; */
1135 &quot;br&quot;,       &quot;head&quot;, NULL,
1136 /* &quot;script&quot; */
1137 &quot;map&quot;,      &quot;head&quot;, NULL,
1138 &quot;q&quot;,        &quot;head&quot;, NULL,
1139 &quot;sub&quot;,      &quot;head&quot;, NULL,
1140 &quot;sup&quot;,      &quot;head&quot;, NULL,
1141 &quot;span&quot;,     &quot;head&quot;, NULL,
1142 &quot;bdo&quot;,      &quot;head&quot;, NULL,
1143 &quot;iframe&quot;,   &quot;head&quot;, NULL,
1144 NULL
1145 };
1146 
1147 /*
1148  * The list of HTML elements which are supposed not to have
1149  * CDATA content and where a p element will be implied
1150  *
1151  * TODO: extend that list by reading the HTML SGML DTD on
1152  *       implied paragraph
1153  */
1154 static const char *const htmlNoContentElements[] = {
1155     &quot;html&quot;,
1156     &quot;head&quot;,
1157     NULL
1158 };
1159 
1160 /*
1161  * The list of HTML attributes which are of content %Script;
1162  * NOTE: when adding ones, check htmlIsScriptAttribute() since
1163  *       it assumes the name starts with &#39;on&#39;
1164  */
1165 static const char *const htmlScriptAttributes[] = {
1166     &quot;onclick&quot;,
1167     &quot;ondblclick&quot;,
1168     &quot;onmousedown&quot;,
1169     &quot;onmouseup&quot;,
1170     &quot;onmouseover&quot;,
1171     &quot;onmousemove&quot;,
1172     &quot;onmouseout&quot;,
1173     &quot;onkeypress&quot;,
1174     &quot;onkeydown&quot;,
1175     &quot;onkeyup&quot;,
1176     &quot;onload&quot;,
1177     &quot;onunload&quot;,
1178     &quot;onfocus&quot;,
1179     &quot;onblur&quot;,
1180     &quot;onsubmit&quot;,
1181     &quot;onreset&quot;,
1182     &quot;onchange&quot;,
1183     &quot;onselect&quot;
1184 };
1185 
1186 /*
1187  * This table is used by the htmlparser to know what to do with
1188  * broken html pages. By assigning different priorities to different
1189  * elements the parser can decide how to handle extra endtags.
1190  * Endtags are only allowed to close elements with lower or equal
1191  * priority.
1192  */
1193 
1194 typedef struct {
1195     const char *name;
1196     int priority;
1197 } elementPriority;
1198 
1199 static const elementPriority htmlEndPriority[] = {
1200     {&quot;div&quot;,   150},
1201     {&quot;td&quot;,    160},
1202     {&quot;th&quot;,    160},
1203     {&quot;tr&quot;,    170},
1204     {&quot;thead&quot;, 180},
1205     {&quot;tbody&quot;, 180},
1206     {&quot;tfoot&quot;, 180},
1207     {&quot;table&quot;, 190},
1208     {&quot;head&quot;,  200},
1209     {&quot;body&quot;,  200},
1210     {&quot;html&quot;,  220},
1211     {NULL,    100} /* Default priority */
1212 };
1213 
1214 static const char** htmlStartCloseIndex[100];
1215 static int htmlStartCloseIndexinitialized = 0;
1216 
1217 /************************************************************************
1218  *                                  *
1219  *  functions to handle HTML specific data          *
1220  *                                  *
1221  ************************************************************************/
1222 
1223 /**
1224  * htmlInitAutoClose:
1225  *
1226  * Initialize the htmlStartCloseIndex for fast lookup of closing tags names.
1227  * This is not reentrant. Call xmlInitParser() once before processing in
1228  * case of use in multithreaded programs.
1229  */
1230 void
1231 htmlInitAutoClose(void) {
1232     int indx, i = 0;
1233 
1234     if (htmlStartCloseIndexinitialized) return;
1235 
1236     for (indx = 0;indx &lt; 100;indx ++) htmlStartCloseIndex[indx] = NULL;
1237     indx = 0;
1238     while ((htmlStartClose[i] != NULL) &amp;&amp; (indx &lt; 100 - 1)) {
1239         htmlStartCloseIndex[indx++] = (const char**) &amp;htmlStartClose[i];
1240     while (htmlStartClose[i] != NULL) i++;
1241     i++;
1242     }
1243     htmlStartCloseIndexinitialized = 1;
1244 }
1245 
1246 /**
1247  * htmlTagLookup:
1248  * @tag:  The tag name in lowercase
1249  *
1250  * Lookup the HTML tag in the ElementTable
1251  *
1252  * Returns the related htmlElemDescPtr or NULL if not found.
1253  */
1254 const htmlElemDesc *
1255 htmlTagLookup(const xmlChar *tag) {
1256     unsigned int i;
1257 
1258     for (i = 0; i &lt; (sizeof(html40ElementTable) /
1259                      sizeof(html40ElementTable[0]));i++) {
1260         if (!xmlStrcasecmp(tag, BAD_CAST html40ElementTable[i].name))
1261         return((htmlElemDescPtr) &amp;html40ElementTable[i]);
1262     }
1263     return(NULL);
1264 }
1265 
1266 /**
1267  * htmlGetEndPriority:
1268  * @name: The name of the element to look up the priority for.
1269  *
1270  * Return value: The &quot;endtag&quot; priority.
1271  **/
1272 static int
1273 htmlGetEndPriority (const xmlChar *name) {
1274     int i = 0;
1275 
1276     while ((htmlEndPriority[i].name != NULL) &amp;&amp;
1277        (!xmlStrEqual((const xmlChar *)htmlEndPriority[i].name, name)))
1278     i++;
1279 
1280     return(htmlEndPriority[i].priority);
1281 }
1282 
1283 
1284 /**
1285  * htmlCheckAutoClose:
1286  * @newtag:  The new tag name
1287  * @oldtag:  The old tag name
1288  *
1289  * Checks whether the new tag is one of the registered valid tags for
1290  * closing old.
1291  * Initialize the htmlStartCloseIndex for fast lookup of closing tags names.
1292  *
1293  * Returns 0 if no, 1 if yes.
1294  */
1295 static int
1296 htmlCheckAutoClose(const xmlChar * newtag, const xmlChar * oldtag)
1297 {
1298     int i, indx;
1299     const char **closed = NULL;
1300 
1301     if (htmlStartCloseIndexinitialized == 0)
1302         htmlInitAutoClose();
1303 
1304     /* inefficient, but not a big deal */
1305     for (indx = 0; indx &lt; 100; indx++) {
1306         closed = htmlStartCloseIndex[indx];
1307         if (closed == NULL)
1308             return (0);
1309         if (xmlStrEqual(BAD_CAST * closed, newtag))
1310             break;
1311     }
1312 
1313     i = closed - htmlStartClose;
1314     i++;
1315     while (htmlStartClose[i] != NULL) {
1316         if (xmlStrEqual(BAD_CAST htmlStartClose[i], oldtag)) {
1317             return (1);
1318         }
1319         i++;
1320     }
1321     return (0);
1322 }
1323 
1324 /**
1325  * htmlAutoCloseOnClose:
1326  * @ctxt:  an HTML parser context
1327  * @newtag:  The new tag name
1328  * @force:  force the tag closure
1329  *
1330  * The HTML DTD allows an ending tag to implicitly close other tags.
1331  */
1332 static void
1333 htmlAutoCloseOnClose(htmlParserCtxtPtr ctxt, const xmlChar * newtag)
1334 {
1335     const htmlElemDesc *info;
1336     int i, priority;
1337 
1338     priority = htmlGetEndPriority(newtag);
1339 
1340     for (i = (ctxt-&gt;nameNr - 1); i &gt;= 0; i--) {
1341 
1342         if (xmlStrEqual(newtag, ctxt-&gt;nameTab[i]))
1343             break;
1344         /*
1345          * A missplaced endtag can only close elements with lower
1346          * or equal priority, so if we find an element with higher
1347          * priority before we find an element with
1348          * matching name, we just ignore this endtag
1349          */
1350         if (htmlGetEndPriority(ctxt-&gt;nameTab[i]) &gt; priority)
1351             return;
1352     }
1353     if (i &lt; 0)
1354         return;
1355 
1356     while (!xmlStrEqual(newtag, ctxt-&gt;name)) {
1357         info = htmlTagLookup(ctxt-&gt;name);
1358         if ((info != NULL) &amp;&amp; (info-&gt;endTag == 3)) {
1359             htmlParseErr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
1360                      &quot;Opening and ending tag mismatch: %s and %s\n&quot;,
1361              newtag, ctxt-&gt;name);
1362         }
1363         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElement != NULL))
1364             ctxt-&gt;sax-&gt;endElement(ctxt-&gt;userData, ctxt-&gt;name);
1365     htmlnamePop(ctxt);
1366     }
1367 }
1368 
1369 /**
1370  * htmlAutoCloseOnEnd:
1371  * @ctxt:  an HTML parser context
1372  *
1373  * Close all remaining tags at the end of the stream
1374  */
1375 static void
1376 htmlAutoCloseOnEnd(htmlParserCtxtPtr ctxt)
1377 {
1378     int i;
1379 
1380     if (ctxt-&gt;nameNr == 0)
1381         return;
1382     for (i = (ctxt-&gt;nameNr - 1); i &gt;= 0; i--) {
1383         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElement != NULL))
1384             ctxt-&gt;sax-&gt;endElement(ctxt-&gt;userData, ctxt-&gt;name);
1385     htmlnamePop(ctxt);
1386     }
1387 }
1388 
1389 /**
1390  * htmlAutoClose:
1391  * @ctxt:  an HTML parser context
1392  * @newtag:  The new tag name or NULL
1393  *
1394  * The HTML DTD allows a tag to implicitly close other tags.
1395  * The list is kept in htmlStartClose array. This function is
1396  * called when a new tag has been detected and generates the
1397  * appropriates closes if possible/needed.
1398  * If newtag is NULL this mean we are at the end of the resource
1399  * and we should check
1400  */
1401 static void
1402 htmlAutoClose(htmlParserCtxtPtr ctxt, const xmlChar * newtag)
1403 {
1404     while ((newtag != NULL) &amp;&amp; (ctxt-&gt;name != NULL) &amp;&amp;
1405            (htmlCheckAutoClose(newtag, ctxt-&gt;name))) {
1406         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElement != NULL))
1407             ctxt-&gt;sax-&gt;endElement(ctxt-&gt;userData, ctxt-&gt;name);
1408     htmlnamePop(ctxt);
1409     }
1410     if (newtag == NULL) {
1411         htmlAutoCloseOnEnd(ctxt);
1412         return;
1413     }
1414     while ((newtag == NULL) &amp;&amp; (ctxt-&gt;name != NULL) &amp;&amp;
1415            ((xmlStrEqual(ctxt-&gt;name, BAD_CAST &quot;head&quot;)) ||
1416             (xmlStrEqual(ctxt-&gt;name, BAD_CAST &quot;body&quot;)) ||
1417             (xmlStrEqual(ctxt-&gt;name, BAD_CAST &quot;html&quot;)))) {
1418         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElement != NULL))
1419             ctxt-&gt;sax-&gt;endElement(ctxt-&gt;userData, ctxt-&gt;name);
1420     htmlnamePop(ctxt);
1421     }
1422 }
1423 
1424 /**
1425  * htmlAutoCloseTag:
1426  * @doc:  the HTML document
1427  * @name:  The tag name
1428  * @elem:  the HTML element
1429  *
1430  * The HTML DTD allows a tag to implicitly close other tags.
1431  * The list is kept in htmlStartClose array. This function checks
1432  * if the element or one of it&#39;s children would autoclose the
1433  * given tag.
1434  *
1435  * Returns 1 if autoclose, 0 otherwise
1436  */
1437 int
1438 htmlAutoCloseTag(htmlDocPtr doc, const xmlChar *name, htmlNodePtr elem) {
1439     htmlNodePtr child;
1440 
1441     if (elem == NULL) return(1);
1442     if (xmlStrEqual(name, elem-&gt;name)) return(0);
1443     if (htmlCheckAutoClose(elem-&gt;name, name)) return(1);
1444     child = elem-&gt;children;
1445     while (child != NULL) {
1446         if (htmlAutoCloseTag(doc, name, child)) return(1);
1447     child = child-&gt;next;
1448     }
1449     return(0);
1450 }
1451 
1452 /**
1453  * htmlIsAutoClosed:
1454  * @doc:  the HTML document
1455  * @elem:  the HTML element
1456  *
1457  * The HTML DTD allows a tag to implicitly close other tags.
1458  * The list is kept in htmlStartClose array. This function checks
1459  * if a tag is autoclosed by one of it&#39;s child
1460  *
1461  * Returns 1 if autoclosed, 0 otherwise
1462  */
1463 int
1464 htmlIsAutoClosed(htmlDocPtr doc, htmlNodePtr elem) {
1465     htmlNodePtr child;
1466 
1467     if (elem == NULL) return(1);
1468     child = elem-&gt;children;
1469     while (child != NULL) {
1470     if (htmlAutoCloseTag(doc, elem-&gt;name, child)) return(1);
1471     child = child-&gt;next;
1472     }
1473     return(0);
1474 }
1475 
1476 /**
1477  * htmlCheckImplied:
1478  * @ctxt:  an HTML parser context
1479  * @newtag:  The new tag name
1480  *
1481  * The HTML DTD allows a tag to exists only implicitly
1482  * called when a new tag has been detected and generates the
1483  * appropriates implicit tags if missing
1484  */
1485 static void
1486 htmlCheckImplied(htmlParserCtxtPtr ctxt, const xmlChar *newtag) {
1487     int i;
1488 
1489     if (ctxt-&gt;options &amp; HTML_PARSE_NOIMPLIED)
1490         return;
1491     if (!htmlOmittedDefaultValue)
1492     return;
1493     if (xmlStrEqual(newtag, BAD_CAST&quot;html&quot;))
1494     return;
1495     if (ctxt-&gt;nameNr &lt;= 0) {
1496     htmlnamePush(ctxt, BAD_CAST&quot;html&quot;);
1497     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;startElement != NULL))
1498         ctxt-&gt;sax-&gt;startElement(ctxt-&gt;userData, BAD_CAST&quot;html&quot;, NULL);
1499     }
1500     if ((xmlStrEqual(newtag, BAD_CAST&quot;body&quot;)) || (xmlStrEqual(newtag, BAD_CAST&quot;head&quot;)))
1501         return;
1502     if ((ctxt-&gt;nameNr &lt;= 1) &amp;&amp;
1503         ((xmlStrEqual(newtag, BAD_CAST&quot;script&quot;)) ||
1504      (xmlStrEqual(newtag, BAD_CAST&quot;style&quot;)) ||
1505      (xmlStrEqual(newtag, BAD_CAST&quot;meta&quot;)) ||
1506      (xmlStrEqual(newtag, BAD_CAST&quot;link&quot;)) ||
1507      (xmlStrEqual(newtag, BAD_CAST&quot;title&quot;)) ||
1508      (xmlStrEqual(newtag, BAD_CAST&quot;base&quot;)))) {
1509         if (ctxt-&gt;html &gt;= 3) {
1510             /* we already saw or generated an &lt;head&gt; before */
1511             return;
1512         }
1513         /*
1514          * dropped OBJECT ... i you put it first BODY will be
1515          * assumed !
1516          */
1517         htmlnamePush(ctxt, BAD_CAST&quot;head&quot;);
1518         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;startElement != NULL))
1519             ctxt-&gt;sax-&gt;startElement(ctxt-&gt;userData, BAD_CAST&quot;head&quot;, NULL);
1520     } else if ((!xmlStrEqual(newtag, BAD_CAST&quot;noframes&quot;)) &amp;&amp;
1521            (!xmlStrEqual(newtag, BAD_CAST&quot;frame&quot;)) &amp;&amp;
1522            (!xmlStrEqual(newtag, BAD_CAST&quot;frameset&quot;))) {
1523         if (ctxt-&gt;html &gt;= 10) {
1524             /* we already saw or generated a &lt;body&gt; before */
1525             return;
1526         }
1527     for (i = 0;i &lt; ctxt-&gt;nameNr;i++) {
1528         if (xmlStrEqual(ctxt-&gt;nameTab[i], BAD_CAST&quot;body&quot;)) {
1529         return;
1530         }
1531         if (xmlStrEqual(ctxt-&gt;nameTab[i], BAD_CAST&quot;head&quot;)) {
1532         return;
1533         }
1534     }
1535 
1536     htmlnamePush(ctxt, BAD_CAST&quot;body&quot;);
1537     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;startElement != NULL))
1538         ctxt-&gt;sax-&gt;startElement(ctxt-&gt;userData, BAD_CAST&quot;body&quot;, NULL);
1539     }
1540 }
1541 
1542 /**
1543  * htmlCheckParagraph
1544  * @ctxt:  an HTML parser context
1545  *
1546  * Check whether a p element need to be implied before inserting
1547  * characters in the current element.
1548  *
1549  * Returns 1 if a paragraph has been inserted, 0 if not and -1
1550  *         in case of error.
1551  */
1552 
1553 static int
1554 htmlCheckParagraph(htmlParserCtxtPtr ctxt) {
1555     const xmlChar *tag;
1556     int i;
1557 
1558     if (ctxt == NULL)
1559     return(-1);
1560     tag = ctxt-&gt;name;
1561     if (tag == NULL) {
1562     htmlAutoClose(ctxt, BAD_CAST&quot;p&quot;);
1563     htmlCheckImplied(ctxt, BAD_CAST&quot;p&quot;);
1564     htmlnamePush(ctxt, BAD_CAST&quot;p&quot;);
1565     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;startElement != NULL))
1566         ctxt-&gt;sax-&gt;startElement(ctxt-&gt;userData, BAD_CAST&quot;p&quot;, NULL);
1567     return(1);
1568     }
1569     if (!htmlOmittedDefaultValue)
1570     return(0);
1571     for (i = 0; htmlNoContentElements[i] != NULL; i++) {
1572     if (xmlStrEqual(tag, BAD_CAST htmlNoContentElements[i])) {
1573         htmlAutoClose(ctxt, BAD_CAST&quot;p&quot;);
1574         htmlCheckImplied(ctxt, BAD_CAST&quot;p&quot;);
1575         htmlnamePush(ctxt, BAD_CAST&quot;p&quot;);
1576         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;startElement != NULL))
1577         ctxt-&gt;sax-&gt;startElement(ctxt-&gt;userData, BAD_CAST&quot;p&quot;, NULL);
1578         return(1);
1579     }
1580     }
1581     return(0);
1582 }
1583 
1584 /**
1585  * htmlIsScriptAttribute:
1586  * @name:  an attribute name
1587  *
1588  * Check if an attribute is of content type Script
1589  *
1590  * Returns 1 is the attribute is a script 0 otherwise
1591  */
1592 int
1593 htmlIsScriptAttribute(const xmlChar *name) {
1594     unsigned int i;
1595 
1596     if (name == NULL)
1597       return(0);
1598     /*
1599      * all script attributes start with &#39;on&#39;
1600      */
1601     if ((name[0] != &#39;o&#39;) || (name[1] != &#39;n&#39;))
1602       return(0);
1603     for (i = 0;
1604      i &lt; sizeof(htmlScriptAttributes)/sizeof(htmlScriptAttributes[0]);
1605      i++) {
1606     if (xmlStrEqual(name, (const xmlChar *) htmlScriptAttributes[i]))
1607         return(1);
1608     }
1609     return(0);
1610 }
1611 
1612 /************************************************************************
1613  *                                  *
1614  *  The list of HTML predefined entities            *
1615  *                                  *
1616  ************************************************************************/
1617 
1618 
1619 static const htmlEntityDesc  html40EntitiesTable[] = {
1620 /*
1621  * the 4 absolute ones, plus apostrophe.
1622  */
1623 { 34,   &quot;quot&quot;, &quot;quotation mark = APL quote, U+0022 ISOnum&quot; },
1624 { 38,   &quot;amp&quot;,  &quot;ampersand, U+0026 ISOnum&quot; },
1625 { 39,   &quot;apos&quot;, &quot;single quote&quot; },
1626 { 60,   &quot;lt&quot;,   &quot;less-than sign, U+003C ISOnum&quot; },
1627 { 62,   &quot;gt&quot;,   &quot;greater-than sign, U+003E ISOnum&quot; },
1628 
1629 /*
1630  * A bunch still in the 128-255 range
1631  * Replacing them depend really on the charset used.
1632  */
1633 { 160,  &quot;nbsp&quot;, &quot;no-break space = non-breaking space, U+00A0 ISOnum&quot; },
1634 { 161,  &quot;iexcl&quot;,&quot;inverted exclamation mark, U+00A1 ISOnum&quot; },
1635 { 162,  &quot;cent&quot;, &quot;cent sign, U+00A2 ISOnum&quot; },
1636 { 163,  &quot;pound&quot;,&quot;pound sign, U+00A3 ISOnum&quot; },
1637 { 164,  &quot;curren&quot;,&quot;currency sign, U+00A4 ISOnum&quot; },
1638 { 165,  &quot;yen&quot;,  &quot;yen sign = yuan sign, U+00A5 ISOnum&quot; },
1639 { 166,  &quot;brvbar&quot;,&quot;broken bar = broken vertical bar, U+00A6 ISOnum&quot; },
1640 { 167,  &quot;sect&quot;, &quot;section sign, U+00A7 ISOnum&quot; },
1641 { 168,  &quot;uml&quot;,  &quot;diaeresis = spacing diaeresis, U+00A8 ISOdia&quot; },
1642 { 169,  &quot;copy&quot;, &quot;copyright sign, U+00A9 ISOnum&quot; },
1643 { 170,  &quot;ordf&quot;, &quot;feminine ordinal indicator, U+00AA ISOnum&quot; },
1644 { 171,  &quot;laquo&quot;,&quot;left-pointing double angle quotation mark = left pointing guillemet, U+00AB ISOnum&quot; },
1645 { 172,  &quot;not&quot;,  &quot;not sign, U+00AC ISOnum&quot; },
1646 { 173,  &quot;shy&quot;,  &quot;soft hyphen = discretionary hyphen, U+00AD ISOnum&quot; },
1647 { 174,  &quot;reg&quot;,  &quot;registered sign = registered trade mark sign, U+00AE ISOnum&quot; },
1648 { 175,  &quot;macr&quot;, &quot;macron = spacing macron = overline = APL overbar, U+00AF ISOdia&quot; },
1649 { 176,  &quot;deg&quot;,  &quot;degree sign, U+00B0 ISOnum&quot; },
1650 { 177,  &quot;plusmn&quot;,&quot;plus-minus sign = plus-or-minus sign, U+00B1 ISOnum&quot; },
1651 { 178,  &quot;sup2&quot;, &quot;superscript two = superscript digit two = squared, U+00B2 ISOnum&quot; },
1652 { 179,  &quot;sup3&quot;, &quot;superscript three = superscript digit three = cubed, U+00B3 ISOnum&quot; },
1653 { 180,  &quot;acute&quot;,&quot;acute accent = spacing acute, U+00B4 ISOdia&quot; },
1654 { 181,  &quot;micro&quot;,&quot;micro sign, U+00B5 ISOnum&quot; },
1655 { 182,  &quot;para&quot;, &quot;pilcrow sign = paragraph sign, U+00B6 ISOnum&quot; },
1656 { 183,  &quot;middot&quot;,&quot;middle dot = Georgian comma Greek middle dot, U+00B7 ISOnum&quot; },
1657 { 184,  &quot;cedil&quot;,&quot;cedilla = spacing cedilla, U+00B8 ISOdia&quot; },
1658 { 185,  &quot;sup1&quot;, &quot;superscript one = superscript digit one, U+00B9 ISOnum&quot; },
1659 { 186,  &quot;ordm&quot;, &quot;masculine ordinal indicator, U+00BA ISOnum&quot; },
1660 { 187,  &quot;raquo&quot;,&quot;right-pointing double angle quotation mark right pointing guillemet, U+00BB ISOnum&quot; },
1661 { 188,  &quot;frac14&quot;,&quot;vulgar fraction one quarter = fraction one quarter, U+00BC ISOnum&quot; },
1662 { 189,  &quot;frac12&quot;,&quot;vulgar fraction one half = fraction one half, U+00BD ISOnum&quot; },
1663 { 190,  &quot;frac34&quot;,&quot;vulgar fraction three quarters = fraction three quarters, U+00BE ISOnum&quot; },
1664 { 191,  &quot;iquest&quot;,&quot;inverted question mark = turned question mark, U+00BF ISOnum&quot; },
1665 { 192,  &quot;Agrave&quot;,&quot;latin capital letter A with grave = latin capital letter A grave, U+00C0 ISOlat1&quot; },
1666 { 193,  &quot;Aacute&quot;,&quot;latin capital letter A with acute, U+00C1 ISOlat1&quot; },
1667 { 194,  &quot;Acirc&quot;,&quot;latin capital letter A with circumflex, U+00C2 ISOlat1&quot; },
1668 { 195,  &quot;Atilde&quot;,&quot;latin capital letter A with tilde, U+00C3 ISOlat1&quot; },
1669 { 196,  &quot;Auml&quot;, &quot;latin capital letter A with diaeresis, U+00C4 ISOlat1&quot; },
1670 { 197,  &quot;Aring&quot;,&quot;latin capital letter A with ring above = latin capital letter A ring, U+00C5 ISOlat1&quot; },
1671 { 198,  &quot;AElig&quot;,&quot;latin capital letter AE = latin capital ligature AE, U+00C6 ISOlat1&quot; },
1672 { 199,  &quot;Ccedil&quot;,&quot;latin capital letter C with cedilla, U+00C7 ISOlat1&quot; },
1673 { 200,  &quot;Egrave&quot;,&quot;latin capital letter E with grave, U+00C8 ISOlat1&quot; },
1674 { 201,  &quot;Eacute&quot;,&quot;latin capital letter E with acute, U+00C9 ISOlat1&quot; },
1675 { 202,  &quot;Ecirc&quot;,&quot;latin capital letter E with circumflex, U+00CA ISOlat1&quot; },
1676 { 203,  &quot;Euml&quot;, &quot;latin capital letter E with diaeresis, U+00CB ISOlat1&quot; },
1677 { 204,  &quot;Igrave&quot;,&quot;latin capital letter I with grave, U+00CC ISOlat1&quot; },
1678 { 205,  &quot;Iacute&quot;,&quot;latin capital letter I with acute, U+00CD ISOlat1&quot; },
1679 { 206,  &quot;Icirc&quot;,&quot;latin capital letter I with circumflex, U+00CE ISOlat1&quot; },
1680 { 207,  &quot;Iuml&quot;, &quot;latin capital letter I with diaeresis, U+00CF ISOlat1&quot; },
1681 { 208,  &quot;ETH&quot;,  &quot;latin capital letter ETH, U+00D0 ISOlat1&quot; },
1682 { 209,  &quot;Ntilde&quot;,&quot;latin capital letter N with tilde, U+00D1 ISOlat1&quot; },
1683 { 210,  &quot;Ograve&quot;,&quot;latin capital letter O with grave, U+00D2 ISOlat1&quot; },
1684 { 211,  &quot;Oacute&quot;,&quot;latin capital letter O with acute, U+00D3 ISOlat1&quot; },
1685 { 212,  &quot;Ocirc&quot;,&quot;latin capital letter O with circumflex, U+00D4 ISOlat1&quot; },
1686 { 213,  &quot;Otilde&quot;,&quot;latin capital letter O with tilde, U+00D5 ISOlat1&quot; },
1687 { 214,  &quot;Ouml&quot;, &quot;latin capital letter O with diaeresis, U+00D6 ISOlat1&quot; },
1688 { 215,  &quot;times&quot;,&quot;multiplication sign, U+00D7 ISOnum&quot; },
1689 { 216,  &quot;Oslash&quot;,&quot;latin capital letter O with stroke latin capital letter O slash, U+00D8 ISOlat1&quot; },
1690 { 217,  &quot;Ugrave&quot;,&quot;latin capital letter U with grave, U+00D9 ISOlat1&quot; },
1691 { 218,  &quot;Uacute&quot;,&quot;latin capital letter U with acute, U+00DA ISOlat1&quot; },
1692 { 219,  &quot;Ucirc&quot;,&quot;latin capital letter U with circumflex, U+00DB ISOlat1&quot; },
1693 { 220,  &quot;Uuml&quot;, &quot;latin capital letter U with diaeresis, U+00DC ISOlat1&quot; },
1694 { 221,  &quot;Yacute&quot;,&quot;latin capital letter Y with acute, U+00DD ISOlat1&quot; },
1695 { 222,  &quot;THORN&quot;,&quot;latin capital letter THORN, U+00DE ISOlat1&quot; },
1696 { 223,  &quot;szlig&quot;,&quot;latin small letter sharp s = ess-zed, U+00DF ISOlat1&quot; },
1697 { 224,  &quot;agrave&quot;,&quot;latin small letter a with grave = latin small letter a grave, U+00E0 ISOlat1&quot; },
1698 { 225,  &quot;aacute&quot;,&quot;latin small letter a with acute, U+00E1 ISOlat1&quot; },
1699 { 226,  &quot;acirc&quot;,&quot;latin small letter a with circumflex, U+00E2 ISOlat1&quot; },
1700 { 227,  &quot;atilde&quot;,&quot;latin small letter a with tilde, U+00E3 ISOlat1&quot; },
1701 { 228,  &quot;auml&quot;, &quot;latin small letter a with diaeresis, U+00E4 ISOlat1&quot; },
1702 { 229,  &quot;aring&quot;,&quot;latin small letter a with ring above = latin small letter a ring, U+00E5 ISOlat1&quot; },
1703 { 230,  &quot;aelig&quot;,&quot;latin small letter ae = latin small ligature ae, U+00E6 ISOlat1&quot; },
1704 { 231,  &quot;ccedil&quot;,&quot;latin small letter c with cedilla, U+00E7 ISOlat1&quot; },
1705 { 232,  &quot;egrave&quot;,&quot;latin small letter e with grave, U+00E8 ISOlat1&quot; },
1706 { 233,  &quot;eacute&quot;,&quot;latin small letter e with acute, U+00E9 ISOlat1&quot; },
1707 { 234,  &quot;ecirc&quot;,&quot;latin small letter e with circumflex, U+00EA ISOlat1&quot; },
1708 { 235,  &quot;euml&quot;, &quot;latin small letter e with diaeresis, U+00EB ISOlat1&quot; },
1709 { 236,  &quot;igrave&quot;,&quot;latin small letter i with grave, U+00EC ISOlat1&quot; },
1710 { 237,  &quot;iacute&quot;,&quot;latin small letter i with acute, U+00ED ISOlat1&quot; },
1711 { 238,  &quot;icirc&quot;,&quot;latin small letter i with circumflex, U+00EE ISOlat1&quot; },
1712 { 239,  &quot;iuml&quot;, &quot;latin small letter i with diaeresis, U+00EF ISOlat1&quot; },
1713 { 240,  &quot;eth&quot;,  &quot;latin small letter eth, U+00F0 ISOlat1&quot; },
1714 { 241,  &quot;ntilde&quot;,&quot;latin small letter n with tilde, U+00F1 ISOlat1&quot; },
1715 { 242,  &quot;ograve&quot;,&quot;latin small letter o with grave, U+00F2 ISOlat1&quot; },
1716 { 243,  &quot;oacute&quot;,&quot;latin small letter o with acute, U+00F3 ISOlat1&quot; },
1717 { 244,  &quot;ocirc&quot;,&quot;latin small letter o with circumflex, U+00F4 ISOlat1&quot; },
1718 { 245,  &quot;otilde&quot;,&quot;latin small letter o with tilde, U+00F5 ISOlat1&quot; },
1719 { 246,  &quot;ouml&quot;, &quot;latin small letter o with diaeresis, U+00F6 ISOlat1&quot; },
1720 { 247,  &quot;divide&quot;,&quot;division sign, U+00F7 ISOnum&quot; },
1721 { 248,  &quot;oslash&quot;,&quot;latin small letter o with stroke, = latin small letter o slash, U+00F8 ISOlat1&quot; },
1722 { 249,  &quot;ugrave&quot;,&quot;latin small letter u with grave, U+00F9 ISOlat1&quot; },
1723 { 250,  &quot;uacute&quot;,&quot;latin small letter u with acute, U+00FA ISOlat1&quot; },
1724 { 251,  &quot;ucirc&quot;,&quot;latin small letter u with circumflex, U+00FB ISOlat1&quot; },
1725 { 252,  &quot;uuml&quot;, &quot;latin small letter u with diaeresis, U+00FC ISOlat1&quot; },
1726 { 253,  &quot;yacute&quot;,&quot;latin small letter y with acute, U+00FD ISOlat1&quot; },
1727 { 254,  &quot;thorn&quot;,&quot;latin small letter thorn with, U+00FE ISOlat1&quot; },
1728 { 255,  &quot;yuml&quot;, &quot;latin small letter y with diaeresis, U+00FF ISOlat1&quot; },
1729 
1730 { 338,  &quot;OElig&quot;,&quot;latin capital ligature OE, U+0152 ISOlat2&quot; },
1731 { 339,  &quot;oelig&quot;,&quot;latin small ligature oe, U+0153 ISOlat2&quot; },
1732 { 352,  &quot;Scaron&quot;,&quot;latin capital letter S with caron, U+0160 ISOlat2&quot; },
1733 { 353,  &quot;scaron&quot;,&quot;latin small letter s with caron, U+0161 ISOlat2&quot; },
1734 { 376,  &quot;Yuml&quot;, &quot;latin capital letter Y with diaeresis, U+0178 ISOlat2&quot; },
1735 
1736 /*
1737  * Anything below should really be kept as entities references
1738  */
1739 { 402,  &quot;fnof&quot;, &quot;latin small f with hook = function = florin, U+0192 ISOtech&quot; },
1740 
1741 { 710,  &quot;circ&quot;, &quot;modifier letter circumflex accent, U+02C6 ISOpub&quot; },
1742 { 732,  &quot;tilde&quot;,&quot;small tilde, U+02DC ISOdia&quot; },
1743 
1744 { 913,  &quot;Alpha&quot;,&quot;greek capital letter alpha, U+0391&quot; },
1745 { 914,  &quot;Beta&quot;, &quot;greek capital letter beta, U+0392&quot; },
1746 { 915,  &quot;Gamma&quot;,&quot;greek capital letter gamma, U+0393 ISOgrk3&quot; },
1747 { 916,  &quot;Delta&quot;,&quot;greek capital letter delta, U+0394 ISOgrk3&quot; },
1748 { 917,  &quot;Epsilon&quot;,&quot;greek capital letter epsilon, U+0395&quot; },
1749 { 918,  &quot;Zeta&quot;, &quot;greek capital letter zeta, U+0396&quot; },
1750 { 919,  &quot;Eta&quot;,  &quot;greek capital letter eta, U+0397&quot; },
1751 { 920,  &quot;Theta&quot;,&quot;greek capital letter theta, U+0398 ISOgrk3&quot; },
1752 { 921,  &quot;Iota&quot;, &quot;greek capital letter iota, U+0399&quot; },
1753 { 922,  &quot;Kappa&quot;,&quot;greek capital letter kappa, U+039A&quot; },
1754 { 923,  &quot;Lambda&quot;, &quot;greek capital letter lambda, U+039B ISOgrk3&quot; },
1755 { 924,  &quot;Mu&quot;,   &quot;greek capital letter mu, U+039C&quot; },
1756 { 925,  &quot;Nu&quot;,   &quot;greek capital letter nu, U+039D&quot; },
1757 { 926,  &quot;Xi&quot;,   &quot;greek capital letter xi, U+039E ISOgrk3&quot; },
1758 { 927,  &quot;Omicron&quot;,&quot;greek capital letter omicron, U+039F&quot; },
1759 { 928,  &quot;Pi&quot;,   &quot;greek capital letter pi, U+03A0 ISOgrk3&quot; },
1760 { 929,  &quot;Rho&quot;,  &quot;greek capital letter rho, U+03A1&quot; },
1761 { 931,  &quot;Sigma&quot;,&quot;greek capital letter sigma, U+03A3 ISOgrk3&quot; },
1762 { 932,  &quot;Tau&quot;,  &quot;greek capital letter tau, U+03A4&quot; },
1763 { 933,  &quot;Upsilon&quot;,&quot;greek capital letter upsilon, U+03A5 ISOgrk3&quot; },
1764 { 934,  &quot;Phi&quot;,  &quot;greek capital letter phi, U+03A6 ISOgrk3&quot; },
1765 { 935,  &quot;Chi&quot;,  &quot;greek capital letter chi, U+03A7&quot; },
1766 { 936,  &quot;Psi&quot;,  &quot;greek capital letter psi, U+03A8 ISOgrk3&quot; },
1767 { 937,  &quot;Omega&quot;,&quot;greek capital letter omega, U+03A9 ISOgrk3&quot; },
1768 
1769 { 945,  &quot;alpha&quot;,&quot;greek small letter alpha, U+03B1 ISOgrk3&quot; },
1770 { 946,  &quot;beta&quot;, &quot;greek small letter beta, U+03B2 ISOgrk3&quot; },
1771 { 947,  &quot;gamma&quot;,&quot;greek small letter gamma, U+03B3 ISOgrk3&quot; },
1772 { 948,  &quot;delta&quot;,&quot;greek small letter delta, U+03B4 ISOgrk3&quot; },
1773 { 949,  &quot;epsilon&quot;,&quot;greek small letter epsilon, U+03B5 ISOgrk3&quot; },
1774 { 950,  &quot;zeta&quot;, &quot;greek small letter zeta, U+03B6 ISOgrk3&quot; },
1775 { 951,  &quot;eta&quot;,  &quot;greek small letter eta, U+03B7 ISOgrk3&quot; },
1776 { 952,  &quot;theta&quot;,&quot;greek small letter theta, U+03B8 ISOgrk3&quot; },
1777 { 953,  &quot;iota&quot;, &quot;greek small letter iota, U+03B9 ISOgrk3&quot; },
1778 { 954,  &quot;kappa&quot;,&quot;greek small letter kappa, U+03BA ISOgrk3&quot; },
1779 { 955,  &quot;lambda&quot;,&quot;greek small letter lambda, U+03BB ISOgrk3&quot; },
1780 { 956,  &quot;mu&quot;,   &quot;greek small letter mu, U+03BC ISOgrk3&quot; },
1781 { 957,  &quot;nu&quot;,   &quot;greek small letter nu, U+03BD ISOgrk3&quot; },
1782 { 958,  &quot;xi&quot;,   &quot;greek small letter xi, U+03BE ISOgrk3&quot; },
1783 { 959,  &quot;omicron&quot;,&quot;greek small letter omicron, U+03BF NEW&quot; },
1784 { 960,  &quot;pi&quot;,   &quot;greek small letter pi, U+03C0 ISOgrk3&quot; },
1785 { 961,  &quot;rho&quot;,  &quot;greek small letter rho, U+03C1 ISOgrk3&quot; },
1786 { 962,  &quot;sigmaf&quot;,&quot;greek small letter final sigma, U+03C2 ISOgrk3&quot; },
1787 { 963,  &quot;sigma&quot;,&quot;greek small letter sigma, U+03C3 ISOgrk3&quot; },
1788 { 964,  &quot;tau&quot;,  &quot;greek small letter tau, U+03C4 ISOgrk3&quot; },
1789 { 965,  &quot;upsilon&quot;,&quot;greek small letter upsilon, U+03C5 ISOgrk3&quot; },
1790 { 966,  &quot;phi&quot;,  &quot;greek small letter phi, U+03C6 ISOgrk3&quot; },
1791 { 967,  &quot;chi&quot;,  &quot;greek small letter chi, U+03C7 ISOgrk3&quot; },
1792 { 968,  &quot;psi&quot;,  &quot;greek small letter psi, U+03C8 ISOgrk3&quot; },
1793 { 969,  &quot;omega&quot;,&quot;greek small letter omega, U+03C9 ISOgrk3&quot; },
1794 { 977,  &quot;thetasym&quot;,&quot;greek small letter theta symbol, U+03D1 NEW&quot; },
1795 { 978,  &quot;upsih&quot;,&quot;greek upsilon with hook symbol, U+03D2 NEW&quot; },
1796 { 982,  &quot;piv&quot;,  &quot;greek pi symbol, U+03D6 ISOgrk3&quot; },
1797 
1798 { 8194, &quot;ensp&quot;, &quot;en space, U+2002 ISOpub&quot; },
1799 { 8195, &quot;emsp&quot;, &quot;em space, U+2003 ISOpub&quot; },
1800 { 8201, &quot;thinsp&quot;,&quot;thin space, U+2009 ISOpub&quot; },
1801 { 8204, &quot;zwnj&quot;, &quot;zero width non-joiner, U+200C NEW RFC 2070&quot; },
1802 { 8205, &quot;zwj&quot;,  &quot;zero width joiner, U+200D NEW RFC 2070&quot; },
1803 { 8206, &quot;lrm&quot;,  &quot;left-to-right mark, U+200E NEW RFC 2070&quot; },
1804 { 8207, &quot;rlm&quot;,  &quot;right-to-left mark, U+200F NEW RFC 2070&quot; },
1805 { 8211, &quot;ndash&quot;,&quot;en dash, U+2013 ISOpub&quot; },
1806 { 8212, &quot;mdash&quot;,&quot;em dash, U+2014 ISOpub&quot; },
1807 { 8216, &quot;lsquo&quot;,&quot;left single quotation mark, U+2018 ISOnum&quot; },
1808 { 8217, &quot;rsquo&quot;,&quot;right single quotation mark, U+2019 ISOnum&quot; },
1809 { 8218, &quot;sbquo&quot;,&quot;single low-9 quotation mark, U+201A NEW&quot; },
1810 { 8220, &quot;ldquo&quot;,&quot;left double quotation mark, U+201C ISOnum&quot; },
1811 { 8221, &quot;rdquo&quot;,&quot;right double quotation mark, U+201D ISOnum&quot; },
1812 { 8222, &quot;bdquo&quot;,&quot;double low-9 quotation mark, U+201E NEW&quot; },
1813 { 8224, &quot;dagger&quot;,&quot;dagger, U+2020 ISOpub&quot; },
1814 { 8225, &quot;Dagger&quot;,&quot;double dagger, U+2021 ISOpub&quot; },
1815 
1816 { 8226, &quot;bull&quot;, &quot;bullet = black small circle, U+2022 ISOpub&quot; },
1817 { 8230, &quot;hellip&quot;,&quot;horizontal ellipsis = three dot leader, U+2026 ISOpub&quot; },
1818 
1819 { 8240, &quot;permil&quot;,&quot;per mille sign, U+2030 ISOtech&quot; },
1820 
1821 { 8242, &quot;prime&quot;,&quot;prime = minutes = feet, U+2032 ISOtech&quot; },
1822 { 8243, &quot;Prime&quot;,&quot;double prime = seconds = inches, U+2033 ISOtech&quot; },
1823 
1824 { 8249, &quot;lsaquo&quot;,&quot;single left-pointing angle quotation mark, U+2039 ISO proposed&quot; },
1825 { 8250, &quot;rsaquo&quot;,&quot;single right-pointing angle quotation mark, U+203A ISO proposed&quot; },
1826 
1827 { 8254, &quot;oline&quot;,&quot;overline = spacing overscore, U+203E NEW&quot; },
1828 { 8260, &quot;frasl&quot;,&quot;fraction slash, U+2044 NEW&quot; },
1829 
1830 { 8364, &quot;euro&quot;, &quot;euro sign, U+20AC NEW&quot; },
1831 
1832 { 8465, &quot;image&quot;,&quot;blackletter capital I = imaginary part, U+2111 ISOamso&quot; },
1833 { 8472, &quot;weierp&quot;,&quot;script capital P = power set = Weierstrass p, U+2118 ISOamso&quot; },
1834 { 8476, &quot;real&quot;, &quot;blackletter capital R = real part symbol, U+211C ISOamso&quot; },
1835 { 8482, &quot;trade&quot;,&quot;trade mark sign, U+2122 ISOnum&quot; },
1836 { 8501, &quot;alefsym&quot;,&quot;alef symbol = first transfinite cardinal, U+2135 NEW&quot; },
1837 { 8592, &quot;larr&quot;, &quot;leftwards arrow, U+2190 ISOnum&quot; },
1838 { 8593, &quot;uarr&quot;, &quot;upwards arrow, U+2191 ISOnum&quot; },
1839 { 8594, &quot;rarr&quot;, &quot;rightwards arrow, U+2192 ISOnum&quot; },
1840 { 8595, &quot;darr&quot;, &quot;downwards arrow, U+2193 ISOnum&quot; },
1841 { 8596, &quot;harr&quot;, &quot;left right arrow, U+2194 ISOamsa&quot; },
1842 { 8629, &quot;crarr&quot;,&quot;downwards arrow with corner leftwards = carriage return, U+21B5 NEW&quot; },
1843 { 8656, &quot;lArr&quot;, &quot;leftwards double arrow, U+21D0 ISOtech&quot; },
1844 { 8657, &quot;uArr&quot;, &quot;upwards double arrow, U+21D1 ISOamsa&quot; },
1845 { 8658, &quot;rArr&quot;, &quot;rightwards double arrow, U+21D2 ISOtech&quot; },
1846 { 8659, &quot;dArr&quot;, &quot;downwards double arrow, U+21D3 ISOamsa&quot; },
1847 { 8660, &quot;hArr&quot;, &quot;left right double arrow, U+21D4 ISOamsa&quot; },
1848 
1849 { 8704, &quot;forall&quot;,&quot;for all, U+2200 ISOtech&quot; },
1850 { 8706, &quot;part&quot;, &quot;partial differential, U+2202 ISOtech&quot; },
1851 { 8707, &quot;exist&quot;,&quot;there exists, U+2203 ISOtech&quot; },
1852 { 8709, &quot;empty&quot;,&quot;empty set = null set = diameter, U+2205 ISOamso&quot; },
1853 { 8711, &quot;nabla&quot;,&quot;nabla = backward difference, U+2207 ISOtech&quot; },
1854 { 8712, &quot;isin&quot;, &quot;element of, U+2208 ISOtech&quot; },
1855 { 8713, &quot;notin&quot;,&quot;not an element of, U+2209 ISOtech&quot; },
1856 { 8715, &quot;ni&quot;,   &quot;contains as member, U+220B ISOtech&quot; },
1857 { 8719, &quot;prod&quot;, &quot;n-ary product = product sign, U+220F ISOamsb&quot; },
1858 { 8721, &quot;sum&quot;,  &quot;n-ary summation, U+2211 ISOamsb&quot; },
1859 { 8722, &quot;minus&quot;,&quot;minus sign, U+2212 ISOtech&quot; },
1860 { 8727, &quot;lowast&quot;,&quot;asterisk operator, U+2217 ISOtech&quot; },
1861 { 8730, &quot;radic&quot;,&quot;square root = radical sign, U+221A ISOtech&quot; },
1862 { 8733, &quot;prop&quot;, &quot;proportional to, U+221D ISOtech&quot; },
1863 { 8734, &quot;infin&quot;,&quot;infinity, U+221E ISOtech&quot; },
1864 { 8736, &quot;ang&quot;,  &quot;angle, U+2220 ISOamso&quot; },
1865 { 8743, &quot;and&quot;,  &quot;logical and = wedge, U+2227 ISOtech&quot; },
1866 { 8744, &quot;or&quot;,   &quot;logical or = vee, U+2228 ISOtech&quot; },
1867 { 8745, &quot;cap&quot;,  &quot;intersection = cap, U+2229 ISOtech&quot; },
1868 { 8746, &quot;cup&quot;,  &quot;union = cup, U+222A ISOtech&quot; },
1869 { 8747, &quot;int&quot;,  &quot;integral, U+222B ISOtech&quot; },
1870 { 8756, &quot;there4&quot;,&quot;therefore, U+2234 ISOtech&quot; },
1871 { 8764, &quot;sim&quot;,  &quot;tilde operator = varies with = similar to, U+223C ISOtech&quot; },
1872 { 8773, &quot;cong&quot;, &quot;approximately equal to, U+2245 ISOtech&quot; },
1873 { 8776, &quot;asymp&quot;,&quot;almost equal to = asymptotic to, U+2248 ISOamsr&quot; },
1874 { 8800, &quot;ne&quot;,   &quot;not equal to, U+2260 ISOtech&quot; },
1875 { 8801, &quot;equiv&quot;,&quot;identical to, U+2261 ISOtech&quot; },
1876 { 8804, &quot;le&quot;,   &quot;less-than or equal to, U+2264 ISOtech&quot; },
1877 { 8805, &quot;ge&quot;,   &quot;greater-than or equal to, U+2265 ISOtech&quot; },
1878 { 8834, &quot;sub&quot;,  &quot;subset of, U+2282 ISOtech&quot; },
1879 { 8835, &quot;sup&quot;,  &quot;superset of, U+2283 ISOtech&quot; },
1880 { 8836, &quot;nsub&quot;, &quot;not a subset of, U+2284 ISOamsn&quot; },
1881 { 8838, &quot;sube&quot;, &quot;subset of or equal to, U+2286 ISOtech&quot; },
1882 { 8839, &quot;supe&quot;, &quot;superset of or equal to, U+2287 ISOtech&quot; },
1883 { 8853, &quot;oplus&quot;,&quot;circled plus = direct sum, U+2295 ISOamsb&quot; },
1884 { 8855, &quot;otimes&quot;,&quot;circled times = vector product, U+2297 ISOamsb&quot; },
1885 { 8869, &quot;perp&quot;, &quot;up tack = orthogonal to = perpendicular, U+22A5 ISOtech&quot; },
1886 { 8901, &quot;sdot&quot;, &quot;dot operator, U+22C5 ISOamsb&quot; },
1887 { 8968, &quot;lceil&quot;,&quot;left ceiling = apl upstile, U+2308 ISOamsc&quot; },
1888 { 8969, &quot;rceil&quot;,&quot;right ceiling, U+2309 ISOamsc&quot; },
1889 { 8970, &quot;lfloor&quot;,&quot;left floor = apl downstile, U+230A ISOamsc&quot; },
1890 { 8971, &quot;rfloor&quot;,&quot;right floor, U+230B ISOamsc&quot; },
1891 { 9001, &quot;lang&quot;, &quot;left-pointing angle bracket = bra, U+2329 ISOtech&quot; },
1892 { 9002, &quot;rang&quot;, &quot;right-pointing angle bracket = ket, U+232A ISOtech&quot; },
1893 { 9674, &quot;loz&quot;,  &quot;lozenge, U+25CA ISOpub&quot; },
1894 
1895 { 9824, &quot;spades&quot;,&quot;black spade suit, U+2660 ISOpub&quot; },
1896 { 9827, &quot;clubs&quot;,&quot;black club suit = shamrock, U+2663 ISOpub&quot; },
1897 { 9829, &quot;hearts&quot;,&quot;black heart suit = valentine, U+2665 ISOpub&quot; },
1898 { 9830, &quot;diams&quot;,&quot;black diamond suit, U+2666 ISOpub&quot; },
1899 
1900 };
1901 
1902 /************************************************************************
1903  *                                  *
1904  *      Commodity functions to handle entities          *
1905  *                                  *
1906  ************************************************************************/
1907 
1908 /*
1909  * Macro used to grow the current buffer.
1910  */
1911 #define growBuffer(buffer) {                        \
1912     xmlChar *tmp;                           \
1913     buffer##_size *= 2;                         \
1914     tmp = (xmlChar *) xmlRealloc(buffer, buffer##_size * sizeof(xmlChar)); \
1915     if (tmp == NULL) {                      \
1916     htmlErrMemory(ctxt, &quot;growing buffer\n&quot;);            \
1917     xmlFree(buffer);                        \
1918     return(NULL);                           \
1919     }                                   \
1920     buffer = tmp;                           \
1921 }
1922 
1923 /**
1924  * htmlEntityLookup:
1925  * @name: the entity name
1926  *
1927  * Lookup the given entity in EntitiesTable
1928  *
1929  * TODO: the linear scan is really ugly, an hash table is really needed.
1930  *
1931  * Returns the associated htmlEntityDescPtr if found, NULL otherwise.
1932  */
1933 const htmlEntityDesc *
1934 htmlEntityLookup(const xmlChar *name) {
1935     unsigned int i;
1936 
1937     for (i = 0;i &lt; (sizeof(html40EntitiesTable)/
1938                     sizeof(html40EntitiesTable[0]));i++) {
1939         if (xmlStrEqual(name, BAD_CAST html40EntitiesTable[i].name)) {
1940             return((htmlEntityDescPtr) &amp;html40EntitiesTable[i]);
1941     }
1942     }
1943     return(NULL);
1944 }
1945 
1946 /**
1947  * htmlEntityValueLookup:
1948  * @value: the entity&#39;s unicode value
1949  *
1950  * Lookup the given entity in EntitiesTable
1951  *
1952  * TODO: the linear scan is really ugly, an hash table is really needed.
1953  *
1954  * Returns the associated htmlEntityDescPtr if found, NULL otherwise.
1955  */
1956 const htmlEntityDesc *
1957 htmlEntityValueLookup(unsigned int value) {
1958     unsigned int i;
1959 
1960     for (i = 0;i &lt; (sizeof(html40EntitiesTable)/
1961                     sizeof(html40EntitiesTable[0]));i++) {
1962         if (html40EntitiesTable[i].value &gt;= value) {
1963         if (html40EntitiesTable[i].value &gt; value)
1964         break;
1965             return((htmlEntityDescPtr) &amp;html40EntitiesTable[i]);
1966     }
1967     }
1968     return(NULL);
1969 }
1970 
1971 /**
1972  * UTF8ToHtml:
1973  * @out:  a pointer to an array of bytes to store the result
1974  * @outlen:  the length of @out
1975  * @in:  a pointer to an array of UTF-8 chars
1976  * @inlen:  the length of @in
1977  *
1978  * Take a block of UTF-8 chars in and try to convert it to an ASCII
1979  * plus HTML entities block of chars out.
1980  *
1981  * Returns 0 if success, -2 if the transcoding fails, or -1 otherwise
1982  * The value of @inlen after return is the number of octets consumed
1983  *     as the return value is positive, else unpredictable.
1984  * The value of @outlen after return is the number of octets consumed.
1985  */
1986 int
1987 UTF8ToHtml(unsigned char* out, int *outlen,
1988               const unsigned char* in, int *inlen) {
1989     const unsigned char* processed = in;
1990     const unsigned char* outend;
1991     const unsigned char* outstart = out;
1992     const unsigned char* instart = in;
1993     const unsigned char* inend;
1994     unsigned int c, d;
1995     int trailing;
1996 
1997     if ((out == NULL) || (outlen == NULL) || (inlen == NULL)) return(-1);
1998     if (in == NULL) {
1999         /*
2000      * initialization nothing to do
2001      */
2002     *outlen = 0;
2003     *inlen = 0;
2004     return(0);
2005     }
2006     inend = in + (*inlen);
2007     outend = out + (*outlen);
2008     while (in &lt; inend) {
2009     d = *in++;
2010     if      (d &lt; 0x80)  { c= d; trailing= 0; }
2011     else if (d &lt; 0xC0) {
2012         /* trailing byte in leading position */
2013         *outlen = out - outstart;
2014         *inlen = processed - instart;
2015         return(-2);
2016         } else if (d &lt; 0xE0)  { c= d &amp; 0x1F; trailing= 1; }
2017         else if (d &lt; 0xF0)  { c= d &amp; 0x0F; trailing= 2; }
2018         else if (d &lt; 0xF8)  { c= d &amp; 0x07; trailing= 3; }
2019     else {
2020         /* no chance for this in Ascii */
2021         *outlen = out - outstart;
2022         *inlen = processed - instart;
2023         return(-2);
2024     }
2025 
2026     if (inend - in &lt; trailing) {
2027         break;
2028     }
2029 
2030     for ( ; trailing; trailing--) {
2031         if ((in &gt;= inend) || (((d= *in++) &amp; 0xC0) != 0x80))
2032         break;
2033         c &lt;&lt;= 6;
2034         c |= d &amp; 0x3F;
2035     }
2036 
2037     /* assertion: c is a single UTF-4 value */
2038     if (c &lt; 0x80) {
2039         if (out + 1 &gt;= outend)
2040         break;
2041         *out++ = c;
2042     } else {
2043         int len;
2044         const htmlEntityDesc * ent;
2045         const char *cp;
2046         char nbuf[16];
2047 
2048         /*
2049          * Try to lookup a predefined HTML entity for it
2050          */
2051 
2052         ent = htmlEntityValueLookup(c);
2053         if (ent == NULL) {
2054           snprintf(nbuf, sizeof(nbuf), &quot;#%u&quot;, c);
2055           cp = nbuf;
2056         }
2057         else
2058           cp = ent-&gt;name;
2059         len = strlen(cp);
2060         if (out + 2 + len &gt;= outend)
2061         break;
2062         *out++ = &#39;&amp;&#39;;
2063         memcpy(out, cp, len);
2064         out += len;
2065         *out++ = &#39;;&#39;;
2066     }
2067     processed = in;
2068     }
2069     *outlen = out - outstart;
2070     *inlen = processed - instart;
2071     return(0);
2072 }
2073 
2074 /**
2075  * htmlEncodeEntities:
2076  * @out:  a pointer to an array of bytes to store the result
2077  * @outlen:  the length of @out
2078  * @in:  a pointer to an array of UTF-8 chars
2079  * @inlen:  the length of @in
2080  * @quoteChar: the quote character to escape (&#39; or &quot;) or zero.
2081  *
2082  * Take a block of UTF-8 chars in and try to convert it to an ASCII
2083  * plus HTML entities block of chars out.
2084  *
2085  * Returns 0 if success, -2 if the transcoding fails, or -1 otherwise
2086  * The value of @inlen after return is the number of octets consumed
2087  *     as the return value is positive, else unpredictable.
2088  * The value of @outlen after return is the number of octets consumed.
2089  */
2090 int
2091 htmlEncodeEntities(unsigned char* out, int *outlen,
2092            const unsigned char* in, int *inlen, int quoteChar) {
2093     const unsigned char* processed = in;
2094     const unsigned char* outend;
2095     const unsigned char* outstart = out;
2096     const unsigned char* instart = in;
2097     const unsigned char* inend;
2098     unsigned int c, d;
2099     int trailing;
2100 
2101     if ((out == NULL) || (outlen == NULL) || (inlen == NULL) || (in == NULL))
2102         return(-1);
2103     outend = out + (*outlen);
2104     inend = in + (*inlen);
2105     while (in &lt; inend) {
2106     d = *in++;
2107     if      (d &lt; 0x80)  { c= d; trailing= 0; }
2108     else if (d &lt; 0xC0) {
2109         /* trailing byte in leading position */
2110         *outlen = out - outstart;
2111         *inlen = processed - instart;
2112         return(-2);
2113         } else if (d &lt; 0xE0)  { c= d &amp; 0x1F; trailing= 1; }
2114         else if (d &lt; 0xF0)  { c= d &amp; 0x0F; trailing= 2; }
2115         else if (d &lt; 0xF8)  { c= d &amp; 0x07; trailing= 3; }
2116     else {
2117         /* no chance for this in Ascii */
2118         *outlen = out - outstart;
2119         *inlen = processed - instart;
2120         return(-2);
2121     }
2122 
2123     if (inend - in &lt; trailing)
2124         break;
2125 
2126     while (trailing--) {
2127         if (((d= *in++) &amp; 0xC0) != 0x80) {
2128         *outlen = out - outstart;
2129         *inlen = processed - instart;
2130         return(-2);
2131         }
2132         c &lt;&lt;= 6;
2133         c |= d &amp; 0x3F;
2134     }
2135 
2136     /* assertion: c is a single UTF-4 value */
2137     if ((c &lt; 0x80) &amp;&amp; (c != (unsigned int) quoteChar) &amp;&amp;
2138         (c != &#39;&amp;&#39;) &amp;&amp; (c != &#39;&lt;&#39;) &amp;&amp; (c != &#39;&gt;&#39;)) {
2139         if (out &gt;= outend)
2140         break;
2141         *out++ = c;
2142     } else {
2143         const htmlEntityDesc * ent;
2144         const char *cp;
2145         char nbuf[16];
2146         int len;
2147 
2148         /*
2149          * Try to lookup a predefined HTML entity for it
2150          */
2151         ent = htmlEntityValueLookup(c);
2152         if (ent == NULL) {
2153         snprintf(nbuf, sizeof(nbuf), &quot;#%u&quot;, c);
2154         cp = nbuf;
2155         }
2156         else
2157         cp = ent-&gt;name;
2158         len = strlen(cp);
2159         if (out + 2 + len &gt; outend)
2160         break;
2161         *out++ = &#39;&amp;&#39;;
2162         memcpy(out, cp, len);
2163         out += len;
2164         *out++ = &#39;;&#39;;
2165     }
2166     processed = in;
2167     }
2168     *outlen = out - outstart;
2169     *inlen = processed - instart;
2170     return(0);
2171 }
2172 
2173 /************************************************************************
2174  *                                  *
2175  *      Commodity functions to handle streams           *
2176  *                                  *
2177  ************************************************************************/
2178 
2179 /**
2180  * htmlNewInputStream:
2181  * @ctxt:  an HTML parser context
2182  *
2183  * Create a new input stream structure
2184  * Returns the new input stream or NULL
2185  */
2186 static htmlParserInputPtr
2187 htmlNewInputStream(htmlParserCtxtPtr ctxt) {
2188     htmlParserInputPtr input;
2189 
2190     input = (xmlParserInputPtr) xmlMalloc(sizeof(htmlParserInput));
2191     if (input == NULL) {
2192         htmlErrMemory(ctxt, &quot;couldn&#39;t allocate a new input stream\n&quot;);
2193     return(NULL);
2194     }
2195     memset(input, 0, sizeof(htmlParserInput));
2196     input-&gt;filename = NULL;
2197     input-&gt;directory = NULL;
2198     input-&gt;base = NULL;
2199     input-&gt;cur = NULL;
2200     input-&gt;buf = NULL;
2201     input-&gt;line = 1;
2202     input-&gt;col = 1;
2203     input-&gt;buf = NULL;
2204     input-&gt;free = NULL;
2205     input-&gt;version = NULL;
2206     input-&gt;consumed = 0;
2207     input-&gt;length = 0;
2208     return(input);
2209 }
2210 
2211 
2212 /************************************************************************
2213  *                                  *
2214  *      Commodity functions, cleanup needed ?           *
2215  *                                  *
2216  ************************************************************************/
2217 /*
2218  * all tags allowing pc data from the html 4.01 loose dtd
2219  * NOTE: it might be more apropriate to integrate this information
2220  * into the html40ElementTable array but I don&#39;t want to risk any
2221  * binary incomptibility
2222  */
2223 static const char *allowPCData[] = {
2224     &quot;a&quot;, &quot;abbr&quot;, &quot;acronym&quot;, &quot;address&quot;, &quot;applet&quot;, &quot;b&quot;, &quot;bdo&quot;, &quot;big&quot;,
2225     &quot;blockquote&quot;, &quot;body&quot;, &quot;button&quot;, &quot;caption&quot;, &quot;center&quot;, &quot;cite&quot;, &quot;code&quot;,
2226     &quot;dd&quot;, &quot;del&quot;, &quot;dfn&quot;, &quot;div&quot;, &quot;dt&quot;, &quot;em&quot;, &quot;font&quot;, &quot;form&quot;, &quot;h1&quot;, &quot;h2&quot;,
2227     &quot;h3&quot;, &quot;h4&quot;, &quot;h5&quot;, &quot;h6&quot;, &quot;i&quot;, &quot;iframe&quot;, &quot;ins&quot;, &quot;kbd&quot;, &quot;label&quot;, &quot;legend&quot;,
2228     &quot;li&quot;, &quot;noframes&quot;, &quot;noscript&quot;, &quot;object&quot;, &quot;p&quot;, &quot;pre&quot;, &quot;q&quot;, &quot;s&quot;, &quot;samp&quot;,
2229     &quot;small&quot;, &quot;span&quot;, &quot;strike&quot;, &quot;strong&quot;, &quot;td&quot;, &quot;th&quot;, &quot;tt&quot;, &quot;u&quot;, &quot;var&quot;
2230 };
2231 
2232 /**
2233  * areBlanks:
2234  * @ctxt:  an HTML parser context
2235  * @str:  a xmlChar *
2236  * @len:  the size of @str
2237  *
2238  * Is this a sequence of blank chars that one can ignore ?
2239  *
2240  * Returns 1 if ignorable 0 otherwise.
2241  */
2242 
2243 static int areBlanks(htmlParserCtxtPtr ctxt, const xmlChar *str, int len) {
2244     unsigned int i;
2245     int j;
2246     xmlNodePtr lastChild;
2247     xmlDtdPtr dtd;
2248 
2249     for (j = 0;j &lt; len;j++)
2250         if (!(IS_BLANK_CH(str[j]))) return(0);
2251 
2252     if (CUR == 0) return(1);
2253     if (CUR != &#39;&lt;&#39;) return(0);
2254     if (ctxt-&gt;name == NULL)
2255     return(1);
2256     if (xmlStrEqual(ctxt-&gt;name, BAD_CAST&quot;html&quot;))
2257     return(1);
2258     if (xmlStrEqual(ctxt-&gt;name, BAD_CAST&quot;head&quot;))
2259     return(1);
2260 
2261     /* Only strip CDATA children of the body tag for strict HTML DTDs */
2262     if (xmlStrEqual(ctxt-&gt;name, BAD_CAST &quot;body&quot;) &amp;&amp; ctxt-&gt;myDoc != NULL) {
2263         dtd = xmlGetIntSubset(ctxt-&gt;myDoc);
2264         if (dtd != NULL &amp;&amp; dtd-&gt;ExternalID != NULL) {
2265             if (!xmlStrcasecmp(dtd-&gt;ExternalID, BAD_CAST &quot;-//W3C//DTD HTML 4.01//EN&quot;) ||
2266                     !xmlStrcasecmp(dtd-&gt;ExternalID, BAD_CAST &quot;-//W3C//DTD HTML 4//EN&quot;))
2267                 return(1);
2268         }
2269     }
2270 
2271     if (ctxt-&gt;node == NULL) return(0);
2272     lastChild = xmlGetLastChild(ctxt-&gt;node);
2273     while ((lastChild) &amp;&amp; (lastChild-&gt;type == XML_COMMENT_NODE))
2274     lastChild = lastChild-&gt;prev;
2275     if (lastChild == NULL) {
2276         if ((ctxt-&gt;node-&gt;type != XML_ELEMENT_NODE) &amp;&amp;
2277             (ctxt-&gt;node-&gt;content != NULL)) return(0);
2278     /* keep ws in constructs like ...&lt;b&gt; &lt;/b&gt;...
2279        for all tags &quot;b&quot; allowing PCDATA */
2280     for ( i = 0; i &lt; sizeof(allowPCData)/sizeof(allowPCData[0]); i++ ) {
2281         if ( xmlStrEqual(ctxt-&gt;name, BAD_CAST allowPCData[i]) ) {
2282         return(0);
2283         }
2284     }
2285     } else if (xmlNodeIsText(lastChild)) {
2286         return(0);
2287     } else {
2288     /* keep ws in constructs like &lt;p&gt;&lt;b&gt;xy&lt;/b&gt; &lt;i&gt;z&lt;/i&gt;&lt;p&gt;
2289        for all tags &quot;p&quot; allowing PCDATA */
2290     for ( i = 0; i &lt; sizeof(allowPCData)/sizeof(allowPCData[0]); i++ ) {
2291         if ( xmlStrEqual(lastChild-&gt;name, BAD_CAST allowPCData[i]) ) {
2292         return(0);
2293         }
2294     }
2295     }
2296     return(1);
2297 }
2298 
2299 /**
2300  * htmlNewDocNoDtD:
2301  * @URI:  URI for the dtd, or NULL
2302  * @ExternalID:  the external ID of the DTD, or NULL
2303  *
2304  * Creates a new HTML document without a DTD node if @URI and @ExternalID
2305  * are NULL
2306  *
2307  * Returns a new document, do not initialize the DTD if not provided
2308  */
2309 htmlDocPtr
2310 htmlNewDocNoDtD(const xmlChar *URI, const xmlChar *ExternalID) {
2311     xmlDocPtr cur;
2312 
2313     /*
2314      * Allocate a new document and fill the fields.
2315      */
2316     cur = (xmlDocPtr) xmlMalloc(sizeof(xmlDoc));
2317     if (cur == NULL) {
2318     htmlErrMemory(NULL, &quot;HTML document creation failed\n&quot;);
2319     return(NULL);
2320     }
2321     memset(cur, 0, sizeof(xmlDoc));
2322 
2323     cur-&gt;type = XML_HTML_DOCUMENT_NODE;
2324     cur-&gt;version = NULL;
2325     cur-&gt;intSubset = NULL;
2326     cur-&gt;doc = cur;
2327     cur-&gt;name = NULL;
2328     cur-&gt;children = NULL;
2329     cur-&gt;extSubset = NULL;
2330     cur-&gt;oldNs = NULL;
2331     cur-&gt;encoding = NULL;
2332     cur-&gt;standalone = 1;
2333     cur-&gt;compression = 0;
2334     cur-&gt;ids = NULL;
2335     cur-&gt;refs = NULL;
2336     cur-&gt;_private = NULL;
2337     cur-&gt;charset = XML_CHAR_ENCODING_UTF8;
2338     cur-&gt;properties = XML_DOC_HTML | XML_DOC_USERBUILT;
2339     if ((ExternalID != NULL) ||
2340     (URI != NULL))
2341     xmlCreateIntSubset(cur, BAD_CAST &quot;html&quot;, ExternalID, URI);
2342     return(cur);
2343 }
2344 
2345 /**
2346  * htmlNewDoc:
2347  * @URI:  URI for the dtd, or NULL
2348  * @ExternalID:  the external ID of the DTD, or NULL
2349  *
2350  * Creates a new HTML document
2351  *
2352  * Returns a new document
2353  */
2354 htmlDocPtr
2355 htmlNewDoc(const xmlChar *URI, const xmlChar *ExternalID) {
2356     if ((URI == NULL) &amp;&amp; (ExternalID == NULL))
2357     return(htmlNewDocNoDtD(
2358             BAD_CAST &quot;http://www.w3.org/TR/REC-html40/loose.dtd&quot;,
2359             BAD_CAST &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;));
2360 
2361     return(htmlNewDocNoDtD(URI, ExternalID));
2362 }
2363 
2364 
2365 /************************************************************************
2366  *                                  *
2367  *          The parser itself               *
2368  *  Relates to http://www.w3.org/TR/html40              *
2369  *                                  *
2370  ************************************************************************/
2371 
2372 /************************************************************************
2373  *                                  *
2374  *          The parser itself               *
2375  *                                  *
2376  ************************************************************************/
2377 
2378 static const xmlChar * htmlParseNameComplex(xmlParserCtxtPtr ctxt);
2379 
2380 /**
2381  * htmlParseHTMLName:
2382  * @ctxt:  an HTML parser context
2383  *
2384  * parse an HTML tag or attribute name, note that we convert it to lowercase
2385  * since HTML names are not case-sensitive.
2386  *
2387  * Returns the Tag Name parsed or NULL
2388  */
2389 
2390 static const xmlChar *
2391 htmlParseHTMLName(htmlParserCtxtPtr ctxt) {
2392     int i = 0;
2393     xmlChar loc[HTML_PARSER_BUFFER_SIZE];
2394 
2395     if (!IS_ASCII_LETTER(CUR) &amp;&amp; (CUR != &#39;_&#39;) &amp;&amp;
2396         (CUR != &#39;:&#39;) &amp;&amp; (CUR != &#39;.&#39;)) return(NULL);
2397 
2398     while ((i &lt; HTML_PARSER_BUFFER_SIZE) &amp;&amp;
2399            ((IS_ASCII_LETTER(CUR)) || (IS_ASCII_DIGIT(CUR)) ||
2400        (CUR == &#39;:&#39;) || (CUR == &#39;-&#39;) || (CUR == &#39;_&#39;) ||
2401            (CUR == &#39;.&#39;))) {
2402     if ((CUR &gt;= &#39;A&#39;) &amp;&amp; (CUR &lt;= &#39;Z&#39;)) loc[i] = CUR + 0x20;
2403         else loc[i] = CUR;
2404     i++;
2405 
2406     NEXT;
2407     }
2408 
2409     return(xmlDictLookup(ctxt-&gt;dict, loc, i));
2410 }
2411 
2412 
2413 /**
2414  * htmlParseHTMLName_nonInvasive:
2415  * @ctxt:  an HTML parser context
2416  *
2417  * parse an HTML tag or attribute name, note that we convert it to lowercase
2418  * since HTML names are not case-sensitive, this doesn&#39;t consume the data
2419  * from the stream, it&#39;s a look-ahead
2420  *
2421  * Returns the Tag Name parsed or NULL
2422  */
2423 
2424 static const xmlChar *
2425 htmlParseHTMLName_nonInvasive(htmlParserCtxtPtr ctxt) {
2426     int i = 0;
2427     xmlChar loc[HTML_PARSER_BUFFER_SIZE];
2428 
2429     if (!IS_ASCII_LETTER(NXT(1)) &amp;&amp; (NXT(1) != &#39;_&#39;) &amp;&amp;
2430         (NXT(1) != &#39;:&#39;)) return(NULL);
2431 
2432     while ((i &lt; HTML_PARSER_BUFFER_SIZE) &amp;&amp;
2433            ((IS_ASCII_LETTER(NXT(1+i))) || (IS_ASCII_DIGIT(NXT(1+i))) ||
2434        (NXT(1+i) == &#39;:&#39;) || (NXT(1+i) == &#39;-&#39;) || (NXT(1+i) == &#39;_&#39;))) {
2435     if ((NXT(1+i) &gt;= &#39;A&#39;) &amp;&amp; (NXT(1+i) &lt;= &#39;Z&#39;)) loc[i] = NXT(1+i) + 0x20;
2436         else loc[i] = NXT(1+i);
2437     i++;
2438     }
2439 
2440     return(xmlDictLookup(ctxt-&gt;dict, loc, i));
2441 }
2442 
2443 
2444 /**
2445  * htmlParseName:
2446  * @ctxt:  an HTML parser context
2447  *
2448  * parse an HTML name, this routine is case sensitive.
2449  *
2450  * Returns the Name parsed or NULL
2451  */
2452 
2453 static const xmlChar *
2454 htmlParseName(htmlParserCtxtPtr ctxt) {
2455     const xmlChar *in;
2456     const xmlChar *ret;
2457     int count = 0;
2458 
2459     GROW;
2460 
2461     /*
2462      * Accelerator for simple ASCII names
2463      */
2464     in = ctxt-&gt;input-&gt;cur;
2465     if (((*in &gt;= 0x61) &amp;&amp; (*in &lt;= 0x7A)) ||
2466     ((*in &gt;= 0x41) &amp;&amp; (*in &lt;= 0x5A)) ||
2467     (*in == &#39;_&#39;) || (*in == &#39;:&#39;)) {
2468     in++;
2469     while (((*in &gt;= 0x61) &amp;&amp; (*in &lt;= 0x7A)) ||
2470            ((*in &gt;= 0x41) &amp;&amp; (*in &lt;= 0x5A)) ||
2471            ((*in &gt;= 0x30) &amp;&amp; (*in &lt;= 0x39)) ||
2472            (*in == &#39;_&#39;) || (*in == &#39;-&#39;) ||
2473            (*in == &#39;:&#39;) || (*in == &#39;.&#39;))
2474         in++;
2475 
2476     if (in == ctxt-&gt;input-&gt;end)
2477         return(NULL);
2478 
2479     if ((*in &gt; 0) &amp;&amp; (*in &lt; 0x80)) {
2480         count = in - ctxt-&gt;input-&gt;cur;
2481         ret = xmlDictLookup(ctxt-&gt;dict, ctxt-&gt;input-&gt;cur, count);
2482         ctxt-&gt;input-&gt;cur = in;
2483         ctxt-&gt;nbChars += count;
2484         ctxt-&gt;input-&gt;col += count;
2485         return(ret);
2486     }
2487     }
2488     return(htmlParseNameComplex(ctxt));
2489 }
2490 
2491 static const xmlChar *
2492 htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
2493     int len = 0, l;
2494     int c;
2495     int count = 0;
2496     const xmlChar *base = ctxt-&gt;input-&gt;base;
2497 
2498     /*
2499      * Handler for more complex cases
2500      */
2501     GROW;
2502     c = CUR_CHAR(l);
2503     if ((c == &#39; &#39;) || (c == &#39;&gt;&#39;) || (c == &#39;/&#39;) || /* accelerators */
2504     (!IS_LETTER(c) &amp;&amp; (c != &#39;_&#39;) &amp;&amp;
2505          (c != &#39;:&#39;))) {
2506     return(NULL);
2507     }
2508 
2509     while ((c != &#39; &#39;) &amp;&amp; (c != &#39;&gt;&#39;) &amp;&amp; (c != &#39;/&#39;) &amp;&amp; /* test bigname.xml */
2510        ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
2511             (c == &#39;.&#39;) || (c == &#39;-&#39;) ||
2512         (c == &#39;_&#39;) || (c == &#39;:&#39;) ||
2513         (IS_COMBINING(c)) ||
2514         (IS_EXTENDER(c)))) {
2515     if (count++ &gt; 100) {
2516         count = 0;
2517         GROW;
2518     }
2519     len += l;
2520     NEXTL(l);
2521     c = CUR_CHAR(l);
2522     if (ctxt-&gt;input-&gt;base != base) {
2523         /*
2524          * We changed encoding from an unknown encoding
2525          * Input buffer changed location, so we better start again
2526          */
2527         return(htmlParseNameComplex(ctxt));
2528     }
2529     }
2530 
2531     if (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base &lt; len) {
2532         /* Sanity check */
2533     htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
2534                      &quot;unexpected change of input buffer&quot;, NULL, NULL);
2535         return (NULL);
2536     }
2537 
2538     return(xmlDictLookup(ctxt-&gt;dict, ctxt-&gt;input-&gt;cur - len, len));
2539 }
2540 
2541 
2542 /**
2543  * htmlParseHTMLAttribute:
2544  * @ctxt:  an HTML parser context
2545  * @stop:  a char stop value
2546  *
2547  * parse an HTML attribute value till the stop (quote), if
2548  * stop is 0 then it stops at the first space
2549  *
2550  * Returns the attribute parsed or NULL
2551  */
2552 
2553 static xmlChar *
2554 htmlParseHTMLAttribute(htmlParserCtxtPtr ctxt, const xmlChar stop) {
2555     xmlChar *buffer = NULL;
2556     int buffer_size = 0;
2557     xmlChar *out = NULL;
2558     const xmlChar *name = NULL;
2559     const xmlChar *cur = NULL;
2560     const htmlEntityDesc * ent;
2561 
2562     /*
2563      * allocate a translation buffer.
2564      */
2565     buffer_size = HTML_PARSER_BUFFER_SIZE;
2566     buffer = (xmlChar *) xmlMallocAtomic(buffer_size * sizeof(xmlChar));
2567     if (buffer == NULL) {
2568     htmlErrMemory(ctxt, &quot;buffer allocation failed\n&quot;);
2569     return(NULL);
2570     }
2571     out = buffer;
2572 
2573     /*
2574      * Ok loop until we reach one of the ending chars
2575      */
2576     while ((CUR != 0) &amp;&amp; (CUR != stop)) {
2577     if ((stop == 0) &amp;&amp; (CUR == &#39;&gt;&#39;)) break;
2578     if ((stop == 0) &amp;&amp; (IS_BLANK_CH(CUR))) break;
2579         if (CUR == &#39;&amp;&#39;) {
2580         if (NXT(1) == &#39;#&#39;) {
2581         unsigned int c;
2582         int bits;
2583 
2584         c = htmlParseCharRef(ctxt);
2585         if      (c &lt;    0x80)
2586                 { *out++  = c;                bits= -6; }
2587         else if (c &lt;   0x800)
2588                 { *out++  =((c &gt;&gt;  6) &amp; 0x1F) | 0xC0;  bits=  0; }
2589         else if (c &lt; 0x10000)
2590                 { *out++  =((c &gt;&gt; 12) &amp; 0x0F) | 0xE0;  bits=  6; }
2591         else
2592                 { *out++  =((c &gt;&gt; 18) &amp; 0x07) | 0xF0;  bits= 12; }
2593 
2594         for ( ; bits &gt;= 0; bits-= 6) {
2595             *out++  = ((c &gt;&gt; bits) &amp; 0x3F) | 0x80;
2596         }
2597 
2598         if (out - buffer &gt; buffer_size - 100) {
2599             int indx = out - buffer;
2600 
2601             growBuffer(buffer);
2602             out = &amp;buffer[indx];
2603         }
2604         } else {
2605         ent = htmlParseEntityRef(ctxt, &amp;name);
2606         if (name == NULL) {
2607             *out++ = &#39;&amp;&#39;;
2608             if (out - buffer &gt; buffer_size - 100) {
2609             int indx = out - buffer;
2610 
2611             growBuffer(buffer);
2612             out = &amp;buffer[indx];
2613             }
2614         } else if (ent == NULL) {
2615             *out++ = &#39;&amp;&#39;;
2616             cur = name;
2617             while (*cur != 0) {
2618             if (out - buffer &gt; buffer_size - 100) {
2619                 int indx = out - buffer;
2620 
2621                 growBuffer(buffer);
2622                 out = &amp;buffer[indx];
2623             }
2624             *out++ = *cur++;
2625             }
2626         } else {
2627             unsigned int c;
2628             int bits;
2629 
2630             if (out - buffer &gt; buffer_size - 100) {
2631             int indx = out - buffer;
2632 
2633             growBuffer(buffer);
2634             out = &amp;buffer[indx];
2635             }
2636             c = ent-&gt;value;
2637             if      (c &lt;    0x80)
2638             { *out++  = c;                bits= -6; }
2639             else if (c &lt;   0x800)
2640             { *out++  =((c &gt;&gt;  6) &amp; 0x1F) | 0xC0;  bits=  0; }
2641             else if (c &lt; 0x10000)
2642             { *out++  =((c &gt;&gt; 12) &amp; 0x0F) | 0xE0;  bits=  6; }
2643             else
2644             { *out++  =((c &gt;&gt; 18) &amp; 0x07) | 0xF0;  bits= 12; }
2645 
2646             for ( ; bits &gt;= 0; bits-= 6) {
2647             *out++  = ((c &gt;&gt; bits) &amp; 0x3F) | 0x80;
2648             }
2649         }
2650         }
2651     } else {
2652         unsigned int c;
2653         int bits, l;
2654 
2655         if (out - buffer &gt; buffer_size - 100) {
2656         int indx = out - buffer;
2657 
2658         growBuffer(buffer);
2659         out = &amp;buffer[indx];
2660         }
2661         c = CUR_CHAR(l);
2662         if      (c &lt;    0x80)
2663             { *out++  = c;                bits= -6; }
2664         else if (c &lt;   0x800)
2665             { *out++  =((c &gt;&gt;  6) &amp; 0x1F) | 0xC0;  bits=  0; }
2666         else if (c &lt; 0x10000)
2667             { *out++  =((c &gt;&gt; 12) &amp; 0x0F) | 0xE0;  bits=  6; }
2668         else
2669             { *out++  =((c &gt;&gt; 18) &amp; 0x07) | 0xF0;  bits= 12; }
2670 
2671         for ( ; bits &gt;= 0; bits-= 6) {
2672         *out++  = ((c &gt;&gt; bits) &amp; 0x3F) | 0x80;
2673         }
2674         NEXT;
2675     }
2676     }
2677     *out = 0;
2678     return(buffer);
2679 }
2680 
2681 /**
2682  * htmlParseEntityRef:
2683  * @ctxt:  an HTML parser context
2684  * @str:  location to store the entity name
2685  *
2686  * parse an HTML ENTITY references
2687  *
2688  * [68] EntityRef ::= &#39;&amp;&#39; Name &#39;;&#39;
2689  *
2690  * Returns the associated htmlEntityDescPtr if found, or NULL otherwise,
2691  *         if non-NULL *str will have to be freed by the caller.
2692  */
2693 const htmlEntityDesc *
2694 htmlParseEntityRef(htmlParserCtxtPtr ctxt, const xmlChar **str) {
2695     const xmlChar *name;
2696     const htmlEntityDesc * ent = NULL;
2697 
2698     if (str != NULL) *str = NULL;
2699     if ((ctxt == NULL) || (ctxt-&gt;input == NULL)) return(NULL);
2700 
2701     if (CUR == &#39;&amp;&#39;) {
2702         NEXT;
2703         name = htmlParseName(ctxt);
2704     if (name == NULL) {
2705         htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,
2706                      &quot;htmlParseEntityRef: no name\n&quot;, NULL, NULL);
2707     } else {
2708         GROW;
2709         if (CUR == &#39;;&#39;) {
2710             if (str != NULL)
2711             *str = name;
2712 
2713         /*
2714          * Lookup the entity in the table.
2715          */
2716         ent = htmlEntityLookup(name);
2717         if (ent != NULL) /* OK that&#39;s ugly !!! */
2718             NEXT;
2719         } else {
2720         htmlParseErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING,
2721                      &quot;htmlParseEntityRef: expecting &#39;;&#39;\n&quot;,
2722                  NULL, NULL);
2723             if (str != NULL)
2724             *str = name;
2725         }
2726     }
2727     }
2728     return(ent);
2729 }
2730 
2731 /**
2732  * htmlParseAttValue:
2733  * @ctxt:  an HTML parser context
2734  *
2735  * parse a value for an attribute
2736  * Note: the parser won&#39;t do substitution of entities here, this
2737  * will be handled later in xmlStringGetNodeList, unless it was
2738  * asked for ctxt-&gt;replaceEntities != 0
2739  *
2740  * Returns the AttValue parsed or NULL.
2741  */
2742 
2743 static xmlChar *
2744 htmlParseAttValue(htmlParserCtxtPtr ctxt) {
2745     xmlChar *ret = NULL;
2746 
2747     if (CUR == &#39;&quot;&#39;) {
2748         NEXT;
2749     ret = htmlParseHTMLAttribute(ctxt, &#39;&quot;&#39;);
2750         if (CUR != &#39;&quot;&#39;) {
2751         htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
2752                      &quot;AttValue: \&quot; expected\n&quot;, NULL, NULL);
2753     } else
2754         NEXT;
2755     } else if (CUR == &#39;\&#39;&#39;) {
2756         NEXT;
2757     ret = htmlParseHTMLAttribute(ctxt, &#39;\&#39;&#39;);
2758         if (CUR != &#39;\&#39;&#39;) {
2759         htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
2760                      &quot;AttValue: &#39; expected\n&quot;, NULL, NULL);
2761     } else
2762         NEXT;
2763     } else {
2764         /*
2765      * That&#39;s an HTMLism, the attribute value may not be quoted
2766      */
2767     ret = htmlParseHTMLAttribute(ctxt, 0);
2768     if (ret == NULL) {
2769         htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,
2770                      &quot;AttValue: no value found\n&quot;, NULL, NULL);
2771     }
2772     }
2773     return(ret);
2774 }
2775 
2776 /**
2777  * htmlParseSystemLiteral:
2778  * @ctxt:  an HTML parser context
2779  *
2780  * parse an HTML Literal
2781  *
2782  * [11] SystemLiteral ::= (&#39;&quot;&#39; [^&quot;]* &#39;&quot;&#39;) | (&quot;&#39;&quot; [^&#39;]* &quot;&#39;&quot;)
2783  *
2784  * Returns the SystemLiteral parsed or NULL
2785  */
2786 
2787 static xmlChar *
2788 htmlParseSystemLiteral(htmlParserCtxtPtr ctxt) {
2789     size_t len = 0, startPosition = 0;
2790     xmlChar *ret = NULL;
2791 
2792     if (CUR == &#39;&quot;&#39;) {
2793         NEXT;
2794 
2795         if (CUR_PTR &lt; BASE_PTR)
2796             return(ret);
2797         startPosition = CUR_PTR - BASE_PTR;
2798 
2799     while ((IS_CHAR_CH(CUR)) &amp;&amp; (CUR != &#39;&quot;&#39;)) {
2800         NEXT;
2801         len++;
2802     }
2803     if (!IS_CHAR_CH(CUR)) {
2804         htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,
2805              &quot;Unfinished SystemLiteral\n&quot;, NULL, NULL);
2806     } else {
2807         ret = xmlStrndup((BASE_PTR+startPosition), len);
2808         NEXT;
2809         }
2810     } else if (CUR == &#39;\&#39;&#39;) {
2811         NEXT;
2812 
2813         if (CUR_PTR &lt; BASE_PTR)
2814             return(ret);
2815         startPosition = CUR_PTR - BASE_PTR;
2816 
2817     while ((IS_CHAR_CH(CUR)) &amp;&amp; (CUR != &#39;\&#39;&#39;)) {
2818         NEXT;
2819         len++;
2820     }
2821     if (!IS_CHAR_CH(CUR)) {
2822         htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,
2823              &quot;Unfinished SystemLiteral\n&quot;, NULL, NULL);
2824     } else {
2825         ret = xmlStrndup((BASE_PTR+startPosition), len);
2826         NEXT;
2827         }
2828     } else {
2829     htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,
2830                  &quot; or &#39; expected\n&quot;, NULL, NULL);
2831     }
2832 
2833     return(ret);
2834 }
2835 
2836 /**
2837  * htmlParsePubidLiteral:
2838  * @ctxt:  an HTML parser context
2839  *
2840  * parse an HTML public literal
2841  *
2842  * [12] PubidLiteral ::= &#39;&quot;&#39; PubidChar* &#39;&quot;&#39; | &quot;&#39;&quot; (PubidChar - &quot;&#39;&quot;)* &quot;&#39;&quot;
2843  *
2844  * Returns the PubidLiteral parsed or NULL.
2845  */
2846 
2847 static xmlChar *
2848 htmlParsePubidLiteral(htmlParserCtxtPtr ctxt) {
2849     size_t len = 0, startPosition = 0;
2850     xmlChar *ret = NULL;
2851     /*
2852      * Name ::= (Letter | &#39;_&#39;) (NameChar)*
2853      */
2854     if (CUR == &#39;&quot;&#39;) {
2855         NEXT;
2856 
2857         if (CUR_PTR &lt; BASE_PTR)
2858             return(ret);
2859         startPosition = CUR_PTR - BASE_PTR;
2860 
2861         while (IS_PUBIDCHAR_CH(CUR)) {
2862             len++;
2863             NEXT;
2864         }
2865 
2866     if (CUR != &#39;&quot;&#39;) {
2867         htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,
2868                      &quot;Unfinished PubidLiteral\n&quot;, NULL, NULL);
2869     } else {
2870         ret = xmlStrndup((BASE_PTR + startPosition), len);
2871         NEXT;
2872     }
2873     } else if (CUR == &#39;\&#39;&#39;) {
2874         NEXT;
2875 
2876         if (CUR_PTR &lt; BASE_PTR)
2877             return(ret);
2878         startPosition = CUR_PTR - BASE_PTR;
2879 
2880         while ((IS_PUBIDCHAR_CH(CUR)) &amp;&amp; (CUR != &#39;\&#39;&#39;)){
2881             len++;
2882             NEXT;
2883         }
2884 
2885     if (CUR != &#39;\&#39;&#39;) {
2886         htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,
2887                      &quot;Unfinished PubidLiteral\n&quot;, NULL, NULL);
2888     } else {
2889         ret = xmlStrndup((BASE_PTR + startPosition), len);
2890         NEXT;
2891     }
2892     } else {
2893     htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,
2894                  &quot;PubidLiteral \&quot; or &#39; expected\n&quot;, NULL, NULL);
2895     }
2896 
2897     return(ret);
2898 }
2899 
2900 /**
2901  * htmlParseScript:
2902  * @ctxt:  an HTML parser context
2903  *
2904  * parse the content of an HTML SCRIPT or STYLE element
2905  * http://www.w3.org/TR/html4/sgml/dtd.html#Script
2906  * http://www.w3.org/TR/html4/sgml/dtd.html#StyleSheet
2907  * http://www.w3.org/TR/html4/types.html#type-script
2908  * http://www.w3.org/TR/html4/types.html#h-6.15
2909  * http://www.w3.org/TR/html4/appendix/notes.html#h-B.3.2.1
2910  *
2911  * Script data ( %Script; in the DTD) can be the content of the SCRIPT
2912  * element and the value of intrinsic event attributes. User agents must
2913  * not evaluate script data as HTML markup but instead must pass it on as
2914  * data to a script engine.
2915  * NOTES:
2916  * - The content is passed like CDATA
2917  * - the attributes for style and scripting &quot;onXXX&quot; are also described
2918  *   as CDATA but SGML allows entities references in attributes so their
2919  *   processing is identical as other attributes
2920  */
2921 static void
2922 htmlParseScript(htmlParserCtxtPtr ctxt) {
2923     xmlChar buf[HTML_PARSER_BIG_BUFFER_SIZE + 5];
2924     int nbchar = 0;
2925     int cur,l;
2926 
2927     SHRINK;
2928     cur = CUR_CHAR(l);
2929     while (IS_CHAR_CH(cur)) {
2930     if ((cur == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
2931             /*
2932              * One should break here, the specification is clear:
2933              * Authors should therefore escape &quot;&lt;/&quot; within the content.
2934              * Escape mechanisms are specific to each scripting or
2935              * style sheet language.
2936              *
2937              * In recovery mode, only break if end tag match the
2938              * current tag, effectively ignoring all tags inside the
2939              * script/style block and treating the entire block as
2940              * CDATA.
2941              */
2942             if (ctxt-&gt;recovery) {
2943                 if (xmlStrncasecmp(ctxt-&gt;name, ctxt-&gt;input-&gt;cur+2,
2944                    xmlStrlen(ctxt-&gt;name)) == 0)
2945                 {
2946                     break; /* while */
2947                 } else {
2948             htmlParseErr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
2949                  &quot;Element %s embeds close tag\n&quot;,
2950                          ctxt-&gt;name, NULL);
2951         }
2952             } else {
2953                 if (((NXT(2) &gt;= &#39;A&#39;) &amp;&amp; (NXT(2) &lt;= &#39;Z&#39;)) ||
2954                     ((NXT(2) &gt;= &#39;a&#39;) &amp;&amp; (NXT(2) &lt;= &#39;z&#39;)))
2955                 {
2956                     break; /* while */
2957                 }
2958             }
2959     }
2960     COPY_BUF(l,buf,nbchar,cur);
2961     if (nbchar &gt;= HTML_PARSER_BIG_BUFFER_SIZE) {
2962         if (ctxt-&gt;sax-&gt;cdataBlock!= NULL) {
2963         /*
2964          * Insert as CDATA, which is the same as HTML_PRESERVE_NODE
2965          */
2966         ctxt-&gt;sax-&gt;cdataBlock(ctxt-&gt;userData, buf, nbchar);
2967         } else if (ctxt-&gt;sax-&gt;characters != NULL) {
2968         ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, buf, nbchar);
2969         }
2970         nbchar = 0;
2971     }
2972     GROW;
2973     NEXTL(l);
2974     cur = CUR_CHAR(l);
2975     }
2976 
2977     if ((!(IS_CHAR_CH(cur))) &amp;&amp; (!((cur == 0) &amp;&amp; (ctxt-&gt;progressive)))) {
2978         htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
2979                     &quot;Invalid char in CDATA 0x%X\n&quot;, cur);
2980         if (ctxt-&gt;input-&gt;cur &lt; ctxt-&gt;input-&gt;end) {
2981             NEXT;
2982         }
2983     }
2984 
2985     if ((nbchar != 0) &amp;&amp; (ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX)) {
2986     if (ctxt-&gt;sax-&gt;cdataBlock!= NULL) {
2987         /*
2988          * Insert as CDATA, which is the same as HTML_PRESERVE_NODE
2989          */
2990         ctxt-&gt;sax-&gt;cdataBlock(ctxt-&gt;userData, buf, nbchar);
2991     } else if (ctxt-&gt;sax-&gt;characters != NULL) {
2992         ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, buf, nbchar);
2993     }
2994     }
2995 }
2996 
2997 
2998 /**
2999  * htmlParseCharDataInternal:
3000  * @ctxt:  an HTML parser context
3001  * @readahead: optional read ahead character in ascii range
3002  *
3003  * parse a CharData section.
3004  * if we are within a CDATA section &#39;]]&gt;&#39; marks an end of section.
3005  *
3006  * [14] CharData ::= [^&lt;&amp;]* - ([^&lt;&amp;]* &#39;]]&gt;&#39; [^&lt;&amp;]*)
3007  */
3008 
3009 static void
3010 htmlParseCharDataInternal(htmlParserCtxtPtr ctxt, int readahead) {
3011     xmlChar buf[HTML_PARSER_BIG_BUFFER_SIZE + 6];
3012     int nbchar = 0;
3013     int cur, l;
3014     int chunk = 0;
3015 
3016     if (readahead)
3017         buf[nbchar++] = readahead;
3018 
3019     SHRINK;
3020     cur = CUR_CHAR(l);
3021     while (((cur != &#39;&lt;&#39;) || (ctxt-&gt;token == &#39;&lt;&#39;)) &amp;&amp;
3022            ((cur != &#39;&amp;&#39;) || (ctxt-&gt;token == &#39;&amp;&#39;)) &amp;&amp;
3023        (cur != 0)) {
3024     if (!(IS_CHAR(cur))) {
3025         htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
3026                     &quot;Invalid char in CDATA 0x%X\n&quot;, cur);
3027     } else {
3028         COPY_BUF(l,buf,nbchar,cur);
3029     }
3030     if (nbchar &gt;= HTML_PARSER_BIG_BUFFER_SIZE) {
3031         /*
3032          * Ok the segment is to be consumed as chars.
3033          */
3034         if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX)) {
3035         if (areBlanks(ctxt, buf, nbchar)) {
3036             if (ctxt-&gt;keepBlanks) {
3037             if (ctxt-&gt;sax-&gt;characters != NULL)
3038                 ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, buf, nbchar);
3039             } else {
3040             if (ctxt-&gt;sax-&gt;ignorableWhitespace != NULL)
3041                 ctxt-&gt;sax-&gt;ignorableWhitespace(ctxt-&gt;userData,
3042                                                buf, nbchar);
3043             }
3044         } else {
3045             htmlCheckParagraph(ctxt);
3046             if (ctxt-&gt;sax-&gt;characters != NULL)
3047             ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, buf, nbchar);
3048         }
3049         }
3050         nbchar = 0;
3051     }
3052     NEXTL(l);
3053         chunk++;
3054         if (chunk &gt; HTML_PARSER_BUFFER_SIZE) {
3055             chunk = 0;
3056             SHRINK;
3057             GROW;
3058         }
3059     cur = CUR_CHAR(l);
3060     if (cur == 0) {
3061         SHRINK;
3062         GROW;
3063         cur = CUR_CHAR(l);
3064     }
3065     }
3066     if (nbchar != 0) {
3067         buf[nbchar] = 0;
3068 
3069     /*
3070      * Ok the segment is to be consumed as chars.
3071      */
3072     if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX)) {
3073         if (areBlanks(ctxt, buf, nbchar)) {
3074         if (ctxt-&gt;keepBlanks) {
3075             if (ctxt-&gt;sax-&gt;characters != NULL)
3076             ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, buf, nbchar);
3077         } else {
3078             if (ctxt-&gt;sax-&gt;ignorableWhitespace != NULL)
3079             ctxt-&gt;sax-&gt;ignorableWhitespace(ctxt-&gt;userData,
3080                                            buf, nbchar);
3081         }
3082         } else {
3083         htmlCheckParagraph(ctxt);
3084         if (ctxt-&gt;sax-&gt;characters != NULL)
3085             ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, buf, nbchar);
3086         }
3087     }
3088     } else {
3089     /*
3090      * Loop detection
3091      */
3092     if (cur == 0)
3093         ctxt-&gt;instate = XML_PARSER_EOF;
3094     }
3095 }
3096 
3097 /**
3098  * htmlParseCharData:
3099  * @ctxt:  an HTML parser context
3100  *
3101  * parse a CharData section.
3102  * if we are within a CDATA section &#39;]]&gt;&#39; marks an end of section.
3103  *
3104  * [14] CharData ::= [^&lt;&amp;]* - ([^&lt;&amp;]* &#39;]]&gt;&#39; [^&lt;&amp;]*)
3105  */
3106 
3107 static void
3108 htmlParseCharData(htmlParserCtxtPtr ctxt) {
3109     htmlParseCharDataInternal(ctxt, 0);
3110 }
3111 
3112 /**
3113  * htmlParseExternalID:
3114  * @ctxt:  an HTML parser context
3115  * @publicID:  a xmlChar** receiving PubidLiteral
3116  *
3117  * Parse an External ID or a Public ID
3118  *
3119  * [75] ExternalID ::= &#39;SYSTEM&#39; S SystemLiteral
3120  *                   | &#39;PUBLIC&#39; S PubidLiteral S SystemLiteral
3121  *
3122  * [83] PublicID ::= &#39;PUBLIC&#39; S PubidLiteral
3123  *
3124  * Returns the function returns SystemLiteral and in the second
3125  *                case publicID receives PubidLiteral, is strict is off
3126  *                it is possible to return NULL and have publicID set.
3127  */
3128 
3129 static xmlChar *
3130 htmlParseExternalID(htmlParserCtxtPtr ctxt, xmlChar **publicID) {
3131     xmlChar *URI = NULL;
3132 
3133     if ((UPPER == &#39;S&#39;) &amp;&amp; (UPP(1) == &#39;Y&#39;) &amp;&amp;
3134          (UPP(2) == &#39;S&#39;) &amp;&amp; (UPP(3) == &#39;T&#39;) &amp;&amp;
3135      (UPP(4) == &#39;E&#39;) &amp;&amp; (UPP(5) == &#39;M&#39;)) {
3136         SKIP(6);
3137     if (!IS_BLANK_CH(CUR)) {
3138         htmlParseErr(ctxt, XML_ERR_SPACE_REQUIRED,
3139                      &quot;Space required after &#39;SYSTEM&#39;\n&quot;, NULL, NULL);
3140     }
3141         SKIP_BLANKS;
3142     URI = htmlParseSystemLiteral(ctxt);
3143     if (URI == NULL) {
3144         htmlParseErr(ctxt, XML_ERR_URI_REQUIRED,
3145                      &quot;htmlParseExternalID: SYSTEM, no URI\n&quot;, NULL, NULL);
3146         }
3147     } else if ((UPPER == &#39;P&#39;) &amp;&amp; (UPP(1) == &#39;U&#39;) &amp;&amp;
3148            (UPP(2) == &#39;B&#39;) &amp;&amp; (UPP(3) == &#39;L&#39;) &amp;&amp;
3149            (UPP(4) == &#39;I&#39;) &amp;&amp; (UPP(5) == &#39;C&#39;)) {
3150         SKIP(6);
3151     if (!IS_BLANK_CH(CUR)) {
3152         htmlParseErr(ctxt, XML_ERR_SPACE_REQUIRED,
3153                      &quot;Space required after &#39;PUBLIC&#39;\n&quot;, NULL, NULL);
3154     }
3155         SKIP_BLANKS;
3156     *publicID = htmlParsePubidLiteral(ctxt);
3157     if (*publicID == NULL) {
3158         htmlParseErr(ctxt, XML_ERR_PUBID_REQUIRED,
3159                      &quot;htmlParseExternalID: PUBLIC, no Public Identifier\n&quot;,
3160              NULL, NULL);
3161     }
3162         SKIP_BLANKS;
3163         if ((CUR == &#39;&quot;&#39;) || (CUR == &#39;\&#39;&#39;)) {
3164         URI = htmlParseSystemLiteral(ctxt);
3165     }
3166     }
3167     return(URI);
3168 }
3169 
3170 /**
3171  * xmlParsePI:
3172  * @ctxt:  an XML parser context
3173  *
3174  * parse an XML Processing Instruction.
3175  *
3176  * [16] PI ::= &#39;&lt;?&#39; PITarget (S (Char* - (Char* &#39;?&gt;&#39; Char*)))? &#39;?&gt;&#39;
3177  */
3178 static void
3179 htmlParsePI(htmlParserCtxtPtr ctxt) {
3180     xmlChar *buf = NULL;
3181     int len = 0;
3182     int size = HTML_PARSER_BUFFER_SIZE;
3183     int cur, l;
3184     const xmlChar *target;
3185     xmlParserInputState state;
3186     int count = 0;
3187 
3188     if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;?&#39;)) {
3189     state = ctxt-&gt;instate;
3190         ctxt-&gt;instate = XML_PARSER_PI;
3191     /*
3192      * this is a Processing Instruction.
3193      */
3194     SKIP(2);
3195     SHRINK;
3196 
3197     /*
3198      * Parse the target name and check for special support like
3199      * namespace.
3200      */
3201         target = htmlParseName(ctxt);
3202     if (target != NULL) {
3203         if (RAW == &#39;&gt;&#39;) {
3204         SKIP(1);
3205 
3206         /*
3207          * SAX: PI detected.
3208          */
3209         if ((ctxt-&gt;sax) &amp;&amp; (!ctxt-&gt;disableSAX) &amp;&amp;
3210             (ctxt-&gt;sax-&gt;processingInstruction != NULL))
3211             ctxt-&gt;sax-&gt;processingInstruction(ctxt-&gt;userData,
3212                                              target, NULL);
3213         ctxt-&gt;instate = state;
3214         return;
3215         }
3216         buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));
3217         if (buf == NULL) {
3218         htmlErrMemory(ctxt, NULL);
3219         ctxt-&gt;instate = state;
3220         return;
3221         }
3222         cur = CUR;
3223         if (!IS_BLANK(cur)) {
3224         htmlParseErr(ctxt, XML_ERR_SPACE_REQUIRED,
3225               &quot;ParsePI: PI %s space expected\n&quot;, target, NULL);
3226         }
3227             SKIP_BLANKS;
3228         cur = CUR_CHAR(l);
3229         while (IS_CHAR(cur) &amp;&amp; (cur != &#39;&gt;&#39;)) {
3230         if (len + 5 &gt;= size) {
3231             xmlChar *tmp;
3232 
3233             size *= 2;
3234             tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));
3235             if (tmp == NULL) {
3236             htmlErrMemory(ctxt, NULL);
3237             xmlFree(buf);
3238             ctxt-&gt;instate = state;
3239             return;
3240             }
3241             buf = tmp;
3242         }
3243         count++;
3244         if (count &gt; 50) {
3245             GROW;
3246             count = 0;
3247         }
3248         COPY_BUF(l,buf,len,cur);
3249         NEXTL(l);
3250         cur = CUR_CHAR(l);
3251         if (cur == 0) {
3252             SHRINK;
3253             GROW;
3254             cur = CUR_CHAR(l);
3255         }
3256         }
3257         buf[len] = 0;
3258         if (cur != &#39;&gt;&#39;) {
3259         htmlParseErr(ctxt, XML_ERR_PI_NOT_FINISHED,
3260               &quot;ParsePI: PI %s never end ...\n&quot;, target, NULL);
3261         } else {
3262         SKIP(1);
3263 
3264         /*
3265          * SAX: PI detected.
3266          */
3267         if ((ctxt-&gt;sax) &amp;&amp; (!ctxt-&gt;disableSAX) &amp;&amp;
3268             (ctxt-&gt;sax-&gt;processingInstruction != NULL))
3269             ctxt-&gt;sax-&gt;processingInstruction(ctxt-&gt;userData,
3270                                              target, buf);
3271         }
3272         xmlFree(buf);
3273     } else {
3274         htmlParseErr(ctxt, XML_ERR_PI_NOT_STARTED,
3275                          &quot;PI is not started correctly&quot;, NULL, NULL);
3276     }
3277     ctxt-&gt;instate = state;
3278     }
3279 }
3280 
3281 /**
3282  * htmlParseComment:
3283  * @ctxt:  an HTML parser context
3284  *
3285  * Parse an XML (SGML) comment &lt;!-- .... --&gt;
3286  *
3287  * [15] Comment ::= &#39;&lt;!--&#39; ((Char - &#39;-&#39;) | (&#39;-&#39; (Char - &#39;-&#39;)))* &#39;--&gt;&#39;
3288  */
3289 static void
3290 htmlParseComment(htmlParserCtxtPtr ctxt) {
3291     xmlChar *buf = NULL;
3292     int len;
3293     int size = HTML_PARSER_BUFFER_SIZE;
3294     int q, ql;
3295     int r, rl;
3296     int cur, l;
3297     xmlParserInputState state;
3298 
3299     /*
3300      * Check that there is a comment right here.
3301      */
3302     if ((RAW != &#39;&lt;&#39;) || (NXT(1) != &#39;!&#39;) ||
3303         (NXT(2) != &#39;-&#39;) || (NXT(3) != &#39;-&#39;)) return;
3304 
3305     state = ctxt-&gt;instate;
3306     ctxt-&gt;instate = XML_PARSER_COMMENT;
3307     SHRINK;
3308     SKIP(4);
3309     buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));
3310     if (buf == NULL) {
3311         htmlErrMemory(ctxt, &quot;buffer allocation failed\n&quot;);
3312     ctxt-&gt;instate = state;
3313     return;
3314     }
3315     len = 0;
3316     buf[len] = 0;
3317     q = CUR_CHAR(ql);
3318     if (!IS_CHAR(q))
3319         goto unfinished;
3320     NEXTL(ql);
3321     r = CUR_CHAR(rl);
3322     if (!IS_CHAR(r))
3323         goto unfinished;
3324     NEXTL(rl);
3325     cur = CUR_CHAR(l);
3326     while (IS_CHAR(cur) &amp;&amp;
3327            ((cur != &#39;&gt;&#39;) ||
3328         (r != &#39;-&#39;) || (q != &#39;-&#39;))) {
3329     if (len + 5 &gt;= size) {
3330         xmlChar *tmp;
3331 
3332         size *= 2;
3333         tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));
3334         if (tmp == NULL) {
3335             xmlFree(buf);
3336             htmlErrMemory(ctxt, &quot;growing buffer failed\n&quot;);
3337         ctxt-&gt;instate = state;
3338         return;
3339         }
3340         buf = tmp;
3341     }
3342     COPY_BUF(ql,buf,len,q);
3343     q = r;
3344     ql = rl;
3345     r = cur;
3346     rl = l;
3347     NEXTL(l);
3348     cur = CUR_CHAR(l);
3349     if (cur == 0) {
3350         SHRINK;
3351         GROW;
3352         cur = CUR_CHAR(l);
3353     }
3354     }
3355     buf[len] = 0;
3356     if (IS_CHAR(cur)) {
3357         NEXT;
3358     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;comment != NULL) &amp;&amp;
3359         (!ctxt-&gt;disableSAX))
3360         ctxt-&gt;sax-&gt;comment(ctxt-&gt;userData, buf);
3361     xmlFree(buf);
3362     ctxt-&gt;instate = state;
3363     return;
3364     }
3365 
3366 unfinished:
3367     htmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
3368          &quot;Comment not terminated \n&lt;!--%.50s\n&quot;, buf, NULL);
3369     xmlFree(buf);
3370 }
3371 
3372 /**
3373  * htmlParseCharRef:
3374  * @ctxt:  an HTML parser context
3375  *
3376  * parse Reference declarations
3377  *
3378  * [66] CharRef ::= &#39;&amp;#&#39; [0-9]+ &#39;;&#39; |
3379  *                  &#39;&amp;#x&#39; [0-9a-fA-F]+ &#39;;&#39;
3380  *
3381  * Returns the value parsed (as an int)
3382  */
3383 int
3384 htmlParseCharRef(htmlParserCtxtPtr ctxt) {
3385     int val = 0;
3386 
3387     if ((ctxt == NULL) || (ctxt-&gt;input == NULL)) {
3388     htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
3389              &quot;htmlParseCharRef: context error\n&quot;,
3390              NULL, NULL);
3391         return(0);
3392     }
3393     if ((CUR == &#39;&amp;&#39;) &amp;&amp; (NXT(1) == &#39;#&#39;) &amp;&amp;
3394         ((NXT(2) == &#39;x&#39;) || NXT(2) == &#39;X&#39;)) {
3395     SKIP(3);
3396     while (CUR != &#39;;&#39;) {
3397         if ((CUR &gt;= &#39;0&#39;) &amp;&amp; (CUR &lt;= &#39;9&#39;))
3398             val = val * 16 + (CUR - &#39;0&#39;);
3399         else if ((CUR &gt;= &#39;a&#39;) &amp;&amp; (CUR &lt;= &#39;f&#39;))
3400             val = val * 16 + (CUR - &#39;a&#39;) + 10;
3401         else if ((CUR &gt;= &#39;A&#39;) &amp;&amp; (CUR &lt;= &#39;F&#39;))
3402             val = val * 16 + (CUR - &#39;A&#39;) + 10;
3403         else {
3404             htmlParseErr(ctxt, XML_ERR_INVALID_HEX_CHARREF,
3405                      &quot;htmlParseCharRef: missing semicolon\n&quot;,
3406                  NULL, NULL);
3407         break;
3408         }
3409         NEXT;
3410     }
3411     if (CUR == &#39;;&#39;)
3412         NEXT;
3413     } else if  ((CUR == &#39;&amp;&#39;) &amp;&amp; (NXT(1) == &#39;#&#39;)) {
3414     SKIP(2);
3415     while (CUR != &#39;;&#39;) {
3416         if ((CUR &gt;= &#39;0&#39;) &amp;&amp; (CUR &lt;= &#39;9&#39;))
3417             val = val * 10 + (CUR - &#39;0&#39;);
3418         else {
3419             htmlParseErr(ctxt, XML_ERR_INVALID_DEC_CHARREF,
3420                      &quot;htmlParseCharRef: missing semicolon\n&quot;,
3421                  NULL, NULL);
3422         break;
3423         }
3424         NEXT;
3425     }
3426     if (CUR == &#39;;&#39;)
3427         NEXT;
3428     } else {
3429     htmlParseErr(ctxt, XML_ERR_INVALID_CHARREF,
3430                  &quot;htmlParseCharRef: invalid value\n&quot;, NULL, NULL);
3431     }
3432     /*
3433      * Check the value IS_CHAR ...
3434      */
3435     if (IS_CHAR(val)) {
3436         return(val);
3437     } else {
3438     htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
3439             &quot;htmlParseCharRef: invalid xmlChar value %d\n&quot;,
3440             val);
3441     }
3442     return(0);
3443 }
3444 
3445 
3446 /**
3447  * htmlParseDocTypeDecl:
3448  * @ctxt:  an HTML parser context
3449  *
3450  * parse a DOCTYPE declaration
3451  *
3452  * [28] doctypedecl ::= &#39;&lt;!DOCTYPE&#39; S Name (S ExternalID)? S?
3453  *                      (&#39;[&#39; (markupdecl | PEReference | S)* &#39;]&#39; S?)? &#39;&gt;&#39;
3454  */
3455 
3456 static void
3457 htmlParseDocTypeDecl(htmlParserCtxtPtr ctxt) {
3458     const xmlChar *name;
3459     xmlChar *ExternalID = NULL;
3460     xmlChar *URI = NULL;
3461 
3462     /*
3463      * We know that &#39;&lt;!DOCTYPE&#39; has been detected.
3464      */
3465     SKIP(9);
3466 
3467     SKIP_BLANKS;
3468 
3469     /*
3470      * Parse the DOCTYPE name.
3471      */
3472     name = htmlParseName(ctxt);
3473     if (name == NULL) {
3474     htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,
3475                  &quot;htmlParseDocTypeDecl : no DOCTYPE name !\n&quot;,
3476              NULL, NULL);
3477     }
3478     /*
3479      * Check that upper(name) == &quot;HTML&quot; !!!!!!!!!!!!!
3480      */
3481 
3482     SKIP_BLANKS;
3483 
3484     /*
3485      * Check for SystemID and ExternalID
3486      */
3487     URI = htmlParseExternalID(ctxt, &amp;ExternalID);
3488     SKIP_BLANKS;
3489 
3490     /*
3491      * We should be at the end of the DOCTYPE declaration.
3492      */
3493     if (CUR != &#39;&gt;&#39;) {
3494     htmlParseErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED,
3495                  &quot;DOCTYPE improperly terminated\n&quot;, NULL, NULL);
3496         /* We shouldn&#39;t try to resynchronize ... */
3497     }
3498     NEXT;
3499 
3500     /*
3501      * Create or update the document accordingly to the DOCTYPE
3502      */
3503     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;internalSubset != NULL) &amp;&amp;
3504     (!ctxt-&gt;disableSAX))
3505     ctxt-&gt;sax-&gt;internalSubset(ctxt-&gt;userData, name, ExternalID, URI);
3506 
3507     /*
3508      * Cleanup, since we don&#39;t use all those identifiers
3509      */
3510     if (URI != NULL) xmlFree(URI);
3511     if (ExternalID != NULL) xmlFree(ExternalID);
3512 }
3513 
3514 /**
3515  * htmlParseAttribute:
3516  * @ctxt:  an HTML parser context
3517  * @value:  a xmlChar ** used to store the value of the attribute
3518  *
3519  * parse an attribute
3520  *
3521  * [41] Attribute ::= Name Eq AttValue
3522  *
3523  * [25] Eq ::= S? &#39;=&#39; S?
3524  *
3525  * With namespace:
3526  *
3527  * [NS 11] Attribute ::= QName Eq AttValue
3528  *
3529  * Also the case QName == xmlns:??? is handled independently as a namespace
3530  * definition.
3531  *
3532  * Returns the attribute name, and the value in *value.
3533  */
3534 
3535 static const xmlChar *
3536 htmlParseAttribute(htmlParserCtxtPtr ctxt, xmlChar **value) {
3537     const xmlChar *name;
3538     xmlChar *val = NULL;
3539 
3540     *value = NULL;
3541     name = htmlParseHTMLName(ctxt);
3542     if (name == NULL) {
3543     htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,
3544                  &quot;error parsing attribute name\n&quot;, NULL, NULL);
3545         return(NULL);
3546     }
3547 
3548     /*
3549      * read the value
3550      */
3551     SKIP_BLANKS;
3552     if (CUR == &#39;=&#39;) {
3553         NEXT;
3554     SKIP_BLANKS;
3555     val = htmlParseAttValue(ctxt);
3556     }
3557 
3558     *value = val;
3559     return(name);
3560 }
3561 
3562 /**
3563  * htmlCheckEncodingDirect:
3564  * @ctxt:  an HTML parser context
3565  * @attvalue: the attribute value
3566  *
3567  * Checks an attribute value to detect
3568  * the encoding
3569  * If a new encoding is detected the parser is switched to decode
3570  * it and pass UTF8
3571  */
3572 static void
3573 htmlCheckEncodingDirect(htmlParserCtxtPtr ctxt, const xmlChar *encoding) {
3574 
3575     if ((ctxt == NULL) || (encoding == NULL) ||
3576         (ctxt-&gt;options &amp; HTML_PARSE_IGNORE_ENC))
3577     return;
3578 
3579     /* do not change encoding */
3580     if (ctxt-&gt;input-&gt;encoding != NULL)
3581         return;
3582 
3583     if (encoding != NULL) {
3584     xmlCharEncoding enc;
3585     xmlCharEncodingHandlerPtr handler;
3586 
3587     while ((*encoding == &#39; &#39;) || (*encoding == &#39;\t&#39;)) encoding++;
3588 
3589     if (ctxt-&gt;input-&gt;encoding != NULL)
3590         xmlFree((xmlChar *) ctxt-&gt;input-&gt;encoding);
3591     ctxt-&gt;input-&gt;encoding = xmlStrdup(encoding);
3592 
3593     enc = xmlParseCharEncoding((const char *) encoding);
3594     /*
3595      * registered set of known encodings
3596      */
3597     if (enc != XML_CHAR_ENCODING_ERROR) {
3598         if (((enc == XML_CHAR_ENCODING_UTF16LE) ||
3599              (enc == XML_CHAR_ENCODING_UTF16BE) ||
3600          (enc == XML_CHAR_ENCODING_UCS4LE) ||
3601          (enc == XML_CHAR_ENCODING_UCS4BE)) &amp;&amp;
3602         (ctxt-&gt;input-&gt;buf != NULL) &amp;&amp;
3603         (ctxt-&gt;input-&gt;buf-&gt;encoder == NULL)) {
3604         htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,
3605                      &quot;htmlCheckEncoding: wrong encoding meta\n&quot;,
3606                  NULL, NULL);
3607         } else {
3608         xmlSwitchEncoding(ctxt, enc);
3609         }
3610         ctxt-&gt;charset = XML_CHAR_ENCODING_UTF8;
3611     } else {
3612         /*
3613          * fallback for unknown encodings
3614          */
3615         handler = xmlFindCharEncodingHandler((const char *) encoding);
3616         if (handler != NULL) {
3617         xmlSwitchToEncoding(ctxt, handler);
3618         ctxt-&gt;charset = XML_CHAR_ENCODING_UTF8;
3619         } else {
3620         htmlParseErr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
3621                      &quot;htmlCheckEncoding: unknown encoding %s\n&quot;,
3622                  encoding, NULL);
3623         }
3624     }
3625 
3626     if ((ctxt-&gt;input-&gt;buf != NULL) &amp;&amp;
3627         (ctxt-&gt;input-&gt;buf-&gt;encoder != NULL) &amp;&amp;
3628         (ctxt-&gt;input-&gt;buf-&gt;raw != NULL) &amp;&amp;
3629         (ctxt-&gt;input-&gt;buf-&gt;buffer != NULL)) {
3630         int nbchars;
3631         int processed;
3632 
3633         /*
3634          * convert as much as possible to the parser reading buffer.
3635          */
3636         processed = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
3637         xmlBufShrink(ctxt-&gt;input-&gt;buf-&gt;buffer, processed);
3638         nbchars = xmlCharEncInput(ctxt-&gt;input-&gt;buf, 1);
3639             xmlBufResetInput(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input);
3640         if (nbchars &lt; 0) {
3641         htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,
3642                      &quot;htmlCheckEncoding: encoder error\n&quot;,
3643                  NULL, NULL);
3644         }
3645     }
3646     }
3647 }
3648 
3649 /**
3650  * htmlCheckEncoding:
3651  * @ctxt:  an HTML parser context
3652  * @attvalue: the attribute value
3653  *
3654  * Checks an http-equiv attribute from a Meta tag to detect
3655  * the encoding
3656  * If a new encoding is detected the parser is switched to decode
3657  * it and pass UTF8
3658  */
3659 static void
3660 htmlCheckEncoding(htmlParserCtxtPtr ctxt, const xmlChar *attvalue) {
3661     const xmlChar *encoding;
3662 
3663     if (!attvalue)
3664     return;
3665 
3666     encoding = xmlStrcasestr(attvalue, BAD_CAST&quot;charset&quot;);
3667     if (encoding != NULL) {
3668     encoding += 7;
3669     }
3670     /*
3671      * skip blank
3672      */
3673     if (encoding &amp;&amp; IS_BLANK_CH(*encoding))
3674     encoding = xmlStrcasestr(attvalue, BAD_CAST&quot;=&quot;);
3675     if (encoding &amp;&amp; *encoding == &#39;=&#39;) {
3676     encoding ++;
3677     htmlCheckEncodingDirect(ctxt, encoding);
3678     }
3679 }
3680 
3681 /**
3682  * htmlCheckMeta:
3683  * @ctxt:  an HTML parser context
3684  * @atts:  the attributes values
3685  *
3686  * Checks an attributes from a Meta tag
3687  */
3688 static void
3689 htmlCheckMeta(htmlParserCtxtPtr ctxt, const xmlChar **atts) {
3690     int i;
3691     const xmlChar *att, *value;
3692     int http = 0;
3693     const xmlChar *content = NULL;
3694 
3695     if ((ctxt == NULL) || (atts == NULL))
3696     return;
3697 
3698     i = 0;
3699     att = atts[i++];
3700     while (att != NULL) {
3701     value = atts[i++];
3702     if ((value != NULL) &amp;&amp; (!xmlStrcasecmp(att, BAD_CAST&quot;http-equiv&quot;))
3703      &amp;&amp; (!xmlStrcasecmp(value, BAD_CAST&quot;Content-Type&quot;)))
3704         http = 1;
3705     else if ((value != NULL) &amp;&amp; (!xmlStrcasecmp(att, BAD_CAST&quot;charset&quot;)))
3706         htmlCheckEncodingDirect(ctxt, value);
3707     else if ((value != NULL) &amp;&amp; (!xmlStrcasecmp(att, BAD_CAST&quot;content&quot;)))
3708         content = value;
3709     att = atts[i++];
3710     }
3711     if ((http) &amp;&amp; (content != NULL))
3712     htmlCheckEncoding(ctxt, content);
3713 
3714 }
3715 
3716 /**
3717  * htmlParseStartTag:
3718  * @ctxt:  an HTML parser context
3719  *
3720  * parse a start of tag either for rule element or
3721  * EmptyElement. In both case we don&#39;t parse the tag closing chars.
3722  *
3723  * [40] STag ::= &#39;&lt;&#39; Name (S Attribute)* S? &#39;&gt;&#39;
3724  *
3725  * [44] EmptyElemTag ::= &#39;&lt;&#39; Name (S Attribute)* S? &#39;/&gt;&#39;
3726  *
3727  * With namespace:
3728  *
3729  * [NS 8] STag ::= &#39;&lt;&#39; QName (S Attribute)* S? &#39;&gt;&#39;
3730  *
3731  * [NS 10] EmptyElement ::= &#39;&lt;&#39; QName (S Attribute)* S? &#39;/&gt;&#39;
3732  *
3733  * Returns 0 in case of success, -1 in case of error and 1 if discarded
3734  */
3735 
3736 static int
3737 htmlParseStartTag(htmlParserCtxtPtr ctxt) {
3738     const xmlChar *name;
3739     const xmlChar *attname;
3740     xmlChar *attvalue;
3741     const xmlChar **atts;
3742     int nbatts = 0;
3743     int maxatts;
3744     int meta = 0;
3745     int i;
3746     int discardtag = 0;
3747 
3748     if ((ctxt == NULL) || (ctxt-&gt;input == NULL)) {
3749     htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
3750              &quot;htmlParseStartTag: context error\n&quot;, NULL, NULL);
3751     return -1;
3752     }
3753     if (ctxt-&gt;instate == XML_PARSER_EOF)
3754         return(-1);
3755     if (CUR != &#39;&lt;&#39;) return -1;
3756     NEXT;
3757 
3758     atts = ctxt-&gt;atts;
3759     maxatts = ctxt-&gt;maxatts;
3760 
3761     GROW;
3762     name = htmlParseHTMLName(ctxt);
3763     if (name == NULL) {
3764     htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,
3765                  &quot;htmlParseStartTag: invalid element name\n&quot;,
3766              NULL, NULL);
3767     /* if recover preserve text on classic misconstructs */
3768     if ((ctxt-&gt;recovery) &amp;&amp; ((IS_BLANK_CH(CUR)) || (CUR == &#39;&lt;&#39;) ||
3769         (CUR == &#39;=&#39;) || (CUR == &#39;&gt;&#39;) || (((CUR &gt;= &#39;0&#39;) &amp;&amp; (CUR &lt;= &#39;9&#39;))))) {
3770         htmlParseCharDataInternal(ctxt, &#39;&lt;&#39;);
3771         return(-1);
3772     }
3773 
3774 
3775     /* Dump the bogus tag like browsers do */
3776     while ((IS_CHAR_CH(CUR)) &amp;&amp; (CUR != &#39;&gt;&#39;) &amp;&amp;
3777                (ctxt-&gt;instate != XML_PARSER_EOF))
3778         NEXT;
3779         return -1;
3780     }
3781     if (xmlStrEqual(name, BAD_CAST&quot;meta&quot;))
3782     meta = 1;
3783 
3784     /*
3785      * Check for auto-closure of HTML elements.
3786      */
3787     htmlAutoClose(ctxt, name);
3788 
3789     /*
3790      * Check for implied HTML elements.
3791      */
3792     htmlCheckImplied(ctxt, name);
3793 
3794     /*
3795      * Avoid html at any level &gt; 0, head at any level != 1
3796      * or any attempt to recurse body
3797      */
3798     if ((ctxt-&gt;nameNr &gt; 0) &amp;&amp; (xmlStrEqual(name, BAD_CAST&quot;html&quot;))) {
3799     htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,
3800                  &quot;htmlParseStartTag: misplaced &lt;html&gt; tag\n&quot;,
3801              name, NULL);
3802     discardtag = 1;
3803     ctxt-&gt;depth++;
3804     }
3805     if ((ctxt-&gt;nameNr != 1) &amp;&amp;
3806     (xmlStrEqual(name, BAD_CAST&quot;head&quot;))) {
3807     htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,
3808                  &quot;htmlParseStartTag: misplaced &lt;head&gt; tag\n&quot;,
3809              name, NULL);
3810     discardtag = 1;
3811     ctxt-&gt;depth++;
3812     }
3813     if (xmlStrEqual(name, BAD_CAST&quot;body&quot;)) {
3814     int indx;
3815     for (indx = 0;indx &lt; ctxt-&gt;nameNr;indx++) {
3816         if (xmlStrEqual(ctxt-&gt;nameTab[indx], BAD_CAST&quot;body&quot;)) {
3817         htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,
3818                      &quot;htmlParseStartTag: misplaced &lt;body&gt; tag\n&quot;,
3819                  name, NULL);
3820         discardtag = 1;
3821         ctxt-&gt;depth++;
3822         }
3823     }
3824     }
3825 
3826     /*
3827      * Now parse the attributes, it ends up with the ending
3828      *
3829      * (S Attribute)* S?
3830      */
3831     SKIP_BLANKS;
3832     while ((IS_CHAR_CH(CUR)) &amp;&amp;
3833            (CUR != &#39;&gt;&#39;) &amp;&amp;
3834        ((CUR != &#39;/&#39;) || (NXT(1) != &#39;&gt;&#39;))) {
3835     long cons = ctxt-&gt;nbChars;
3836 
3837     GROW;
3838     attname = htmlParseAttribute(ctxt, &amp;attvalue);
3839         if (attname != NULL) {
3840 
3841         /*
3842          * Well formedness requires at most one declaration of an attribute
3843          */
3844         for (i = 0; i &lt; nbatts;i += 2) {
3845             if (xmlStrEqual(atts[i], attname)) {
3846             htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_REDEFINED,
3847                          &quot;Attribute %s redefined\n&quot;, attname, NULL);
3848             if (attvalue != NULL)
3849             xmlFree(attvalue);
3850             goto failed;
3851         }
3852         }
3853 
3854         /*
3855          * Add the pair to atts
3856          */
3857         if (atts == NULL) {
3858             maxatts = 22; /* allow for 10 attrs by default */
3859             atts = (const xmlChar **)
3860                xmlMalloc(maxatts * sizeof(xmlChar *));
3861         if (atts == NULL) {
3862             htmlErrMemory(ctxt, NULL);
3863             if (attvalue != NULL)
3864             xmlFree(attvalue);
3865             goto failed;
3866         }
3867         ctxt-&gt;atts = atts;
3868         ctxt-&gt;maxatts = maxatts;
3869         } else if (nbatts + 4 &gt; maxatts) {
3870             const xmlChar **n;
3871 
3872             maxatts *= 2;
3873             n = (const xmlChar **) xmlRealloc((void *) atts,
3874                          maxatts * sizeof(const xmlChar *));
3875         if (n == NULL) {
3876             htmlErrMemory(ctxt, NULL);
3877             if (attvalue != NULL)
3878             xmlFree(attvalue);
3879             goto failed;
3880         }
3881         atts = n;
3882         ctxt-&gt;atts = atts;
3883         ctxt-&gt;maxatts = maxatts;
3884         }
3885         atts[nbatts++] = attname;
3886         atts[nbatts++] = attvalue;
3887         atts[nbatts] = NULL;
3888         atts[nbatts + 1] = NULL;
3889     }
3890     else {
3891         if (attvalue != NULL)
3892             xmlFree(attvalue);
3893         /* Dump the bogus attribute string up to the next blank or
3894          * the end of the tag. */
3895         while ((IS_CHAR_CH(CUR)) &amp;&amp;
3896                !(IS_BLANK_CH(CUR)) &amp;&amp; (CUR != &#39;&gt;&#39;) &amp;&amp;
3897            ((CUR != &#39;/&#39;) || (NXT(1) != &#39;&gt;&#39;)))
3898         NEXT;
3899     }
3900 
3901 failed:
3902     SKIP_BLANKS;
3903         if (cons == ctxt-&gt;nbChars) {
3904         htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
3905                      &quot;htmlParseStartTag: problem parsing attributes\n&quot;,
3906              NULL, NULL);
3907         break;
3908     }
3909     }
3910 
3911     /*
3912      * Handle specific association to the META tag
3913      */
3914     if (meta &amp;&amp; (nbatts != 0))
3915     htmlCheckMeta(ctxt, atts);
3916 
3917     /*
3918      * SAX: Start of Element !
3919      */
3920     if (!discardtag) {
3921     htmlnamePush(ctxt, name);
3922     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;startElement != NULL)) {
3923         if (nbatts != 0)
3924         ctxt-&gt;sax-&gt;startElement(ctxt-&gt;userData, name, atts);
3925         else
3926         ctxt-&gt;sax-&gt;startElement(ctxt-&gt;userData, name, NULL);
3927     }
3928     }
3929 
3930     if (atts != NULL) {
3931         for (i = 1;i &lt; nbatts;i += 2) {
3932         if (atts[i] != NULL)
3933         xmlFree((xmlChar *) atts[i]);
3934     }
3935     }
3936 
3937     return(discardtag);
3938 }
3939 
3940 /**
3941  * htmlParseEndTag:
3942  * @ctxt:  an HTML parser context
3943  *
3944  * parse an end of tag
3945  *
3946  * [42] ETag ::= &#39;&lt;/&#39; Name S? &#39;&gt;&#39;
3947  *
3948  * With namespace
3949  *
3950  * [NS 9] ETag ::= &#39;&lt;/&#39; QName S? &#39;&gt;&#39;
3951  *
3952  * Returns 1 if the current level should be closed.
3953  */
3954 
3955 static int
3956 htmlParseEndTag(htmlParserCtxtPtr ctxt)
3957 {
3958     const xmlChar *name;
3959     const xmlChar *oldname;
3960     int i, ret;
3961 
3962     if ((CUR != &#39;&lt;&#39;) || (NXT(1) != &#39;/&#39;)) {
3963         htmlParseErr(ctxt, XML_ERR_LTSLASH_REQUIRED,
3964                  &quot;htmlParseEndTag: &#39;&lt;/&#39; not found\n&quot;, NULL, NULL);
3965         return (0);
3966     }
3967     SKIP(2);
3968 
3969     name = htmlParseHTMLName(ctxt);
3970     if (name == NULL)
3971         return (0);
3972     /*
3973      * We should definitely be at the ending &quot;S? &#39;&gt;&#39;&quot; part
3974      */
3975     SKIP_BLANKS;
3976     if ((!IS_CHAR_CH(CUR)) || (CUR != &#39;&gt;&#39;)) {
3977         htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,
3978                  &quot;End tag : expected &#39;&gt;&#39;\n&quot;, NULL, NULL);
3979     if (ctxt-&gt;recovery) {
3980         /*
3981          * We&#39;re not at the ending &gt; !!
3982          * Error, unless in recover mode where we search forwards
3983          * until we find a &gt;
3984          */
3985         while (CUR != &#39;\0&#39; &amp;&amp; CUR != &#39;&gt;&#39;) NEXT;
3986         NEXT;
3987     }
3988     } else
3989         NEXT;
3990 
3991     /*
3992      * if we ignored misplaced tags in htmlParseStartTag don&#39;t pop them
3993      * out now.
3994      */
3995     if ((ctxt-&gt;depth &gt; 0) &amp;&amp;
3996         (xmlStrEqual(name, BAD_CAST &quot;html&quot;) ||
3997          xmlStrEqual(name, BAD_CAST &quot;body&quot;) ||
3998      xmlStrEqual(name, BAD_CAST &quot;head&quot;))) {
3999     ctxt-&gt;depth--;
4000     return (0);
4001     }
4002 
4003     /*
4004      * If the name read is not one of the element in the parsing stack
4005      * then return, it&#39;s just an error.
4006      */
4007     for (i = (ctxt-&gt;nameNr - 1); i &gt;= 0; i--) {
4008         if (xmlStrEqual(name, ctxt-&gt;nameTab[i]))
4009             break;
4010     }
4011     if (i &lt; 0) {
4012         htmlParseErr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
4013                  &quot;Unexpected end tag : %s\n&quot;, name, NULL);
4014         return (0);
4015     }
4016 
4017 
4018     /*
4019      * Check for auto-closure of HTML elements.
4020      */
4021 
4022     htmlAutoCloseOnClose(ctxt, name);
4023 
4024     /*
4025      * Well formedness constraints, opening and closing must match.
4026      * With the exception that the autoclose may have popped stuff out
4027      * of the stack.
4028      */
4029     if (!xmlStrEqual(name, ctxt-&gt;name)) {
4030         if ((ctxt-&gt;name != NULL) &amp;&amp; (!xmlStrEqual(ctxt-&gt;name, name))) {
4031             htmlParseErr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
4032                      &quot;Opening and ending tag mismatch: %s and %s\n&quot;,
4033              name, ctxt-&gt;name);
4034         }
4035     }
4036 
4037     /*
4038      * SAX: End of Tag
4039      */
4040     oldname = ctxt-&gt;name;
4041     if ((oldname != NULL) &amp;&amp; (xmlStrEqual(oldname, name))) {
4042         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElement != NULL))
4043             ctxt-&gt;sax-&gt;endElement(ctxt-&gt;userData, name);
4044     htmlNodeInfoPop(ctxt);
4045         htmlnamePop(ctxt);
4046         ret = 1;
4047     } else {
4048         ret = 0;
4049     }
4050 
4051     return (ret);
4052 }
4053 
4054 
4055 /**
4056  * htmlParseReference:
4057  * @ctxt:  an HTML parser context
4058  *
4059  * parse and handle entity references in content,
4060  * this will end-up in a call to character() since this is either a
4061  * CharRef, or a predefined entity.
4062  */
4063 static void
4064 htmlParseReference(htmlParserCtxtPtr ctxt) {
4065     const htmlEntityDesc * ent;
4066     xmlChar out[6];
4067     const xmlChar *name;
4068     if (CUR != &#39;&amp;&#39;) return;
4069 
4070     if (NXT(1) == &#39;#&#39;) {
4071     unsigned int c;
4072     int bits, i = 0;
4073 
4074     c = htmlParseCharRef(ctxt);
4075     if (c == 0)
4076         return;
4077 
4078         if      (c &lt;    0x80) { out[i++]= c;                bits= -6; }
4079         else if (c &lt;   0x800) { out[i++]=((c &gt;&gt;  6) &amp; 0x1F) | 0xC0;  bits=  0; }
4080         else if (c &lt; 0x10000) { out[i++]=((c &gt;&gt; 12) &amp; 0x0F) | 0xE0;  bits=  6; }
4081         else                  { out[i++]=((c &gt;&gt; 18) &amp; 0x07) | 0xF0;  bits= 12; }
4082 
4083         for ( ; bits &gt;= 0; bits-= 6) {
4084             out[i++]= ((c &gt;&gt; bits) &amp; 0x3F) | 0x80;
4085         }
4086     out[i] = 0;
4087 
4088     htmlCheckParagraph(ctxt);
4089     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;characters != NULL))
4090         ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, out, i);
4091     } else {
4092     ent = htmlParseEntityRef(ctxt, &amp;name);
4093     if (name == NULL) {
4094         htmlCheckParagraph(ctxt);
4095         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;characters != NULL))
4096             ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, BAD_CAST &quot;&amp;&quot;, 1);
4097         return;
4098     }
4099     if ((ent == NULL) || !(ent-&gt;value &gt; 0)) {
4100         htmlCheckParagraph(ctxt);
4101         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;characters != NULL)) {
4102         ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, BAD_CAST &quot;&amp;&quot;, 1);
4103         ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, name, xmlStrlen(name));
4104         /* ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, BAD_CAST &quot;;&quot;, 1); */
4105         }
4106     } else {
4107         unsigned int c;
4108         int bits, i = 0;
4109 
4110         c = ent-&gt;value;
4111         if      (c &lt;    0x80)
4112                 { out[i++]= c;                bits= -6; }
4113         else if (c &lt;   0x800)
4114                 { out[i++]=((c &gt;&gt;  6) &amp; 0x1F) | 0xC0;  bits=  0; }
4115         else if (c &lt; 0x10000)
4116                 { out[i++]=((c &gt;&gt; 12) &amp; 0x0F) | 0xE0;  bits=  6; }
4117         else
4118                 { out[i++]=((c &gt;&gt; 18) &amp; 0x07) | 0xF0;  bits= 12; }
4119 
4120         for ( ; bits &gt;= 0; bits-= 6) {
4121         out[i++]= ((c &gt;&gt; bits) &amp; 0x3F) | 0x80;
4122         }
4123         out[i] = 0;
4124 
4125         htmlCheckParagraph(ctxt);
4126         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;characters != NULL))
4127         ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, out, i);
4128     }
4129     }
4130 }
4131 
4132 /**
4133  * htmlParseContent:
4134  * @ctxt:  an HTML parser context
4135  *
4136  * Parse a content: comment, sub-element, reference or text.
4137  * Kept for compatibility with old code
4138  */
4139 
4140 static void
4141 htmlParseContent(htmlParserCtxtPtr ctxt) {
4142     xmlChar *currentNode;
4143     int depth;
4144     const xmlChar *name;
4145 
4146     currentNode = xmlStrdup(ctxt-&gt;name);
4147     depth = ctxt-&gt;nameNr;
4148     while (1) {
4149     long cons = ctxt-&gt;nbChars;
4150 
4151         GROW;
4152 
4153         if (ctxt-&gt;instate == XML_PARSER_EOF)
4154             break;
4155 
4156     /*
4157      * Our tag or one of it&#39;s parent or children is ending.
4158      */
4159         if ((CUR == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
4160         if (htmlParseEndTag(ctxt) &amp;&amp;
4161         ((currentNode != NULL) || (ctxt-&gt;nameNr == 0))) {
4162         if (currentNode != NULL)
4163             xmlFree(currentNode);
4164         return;
4165         }
4166         continue; /* while */
4167         }
4168 
4169     else if ((CUR == &#39;&lt;&#39;) &amp;&amp;
4170              ((IS_ASCII_LETTER(NXT(1))) ||
4171           (NXT(1) == &#39;_&#39;) || (NXT(1) == &#39;:&#39;))) {
4172         name = htmlParseHTMLName_nonInvasive(ctxt);
4173         if (name == NULL) {
4174             htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,
4175              &quot;htmlParseStartTag: invalid element name\n&quot;,
4176              NULL, NULL);
4177             /* Dump the bogus tag like browsers do */
4178         while ((IS_CHAR_CH(CUR)) &amp;&amp; (CUR != &#39;&gt;&#39;))
4179                 NEXT;
4180 
4181             if (currentNode != NULL)
4182                 xmlFree(currentNode);
4183             return;
4184         }
4185 
4186         if (ctxt-&gt;name != NULL) {
4187             if (htmlCheckAutoClose(name, ctxt-&gt;name) == 1) {
4188                 htmlAutoClose(ctxt, name);
4189                 continue;
4190             }
4191         }
4192     }
4193 
4194     /*
4195      * Has this node been popped out during parsing of
4196      * the next element
4197      */
4198         if ((ctxt-&gt;nameNr &gt; 0) &amp;&amp; (depth &gt;= ctxt-&gt;nameNr) &amp;&amp;
4199         (!xmlStrEqual(currentNode, ctxt-&gt;name)))
4200          {
4201         if (currentNode != NULL) xmlFree(currentNode);
4202         return;
4203     }
4204 
4205     if ((CUR != 0) &amp;&amp; ((xmlStrEqual(currentNode, BAD_CAST&quot;script&quot;)) ||
4206         (xmlStrEqual(currentNode, BAD_CAST&quot;style&quot;)))) {
4207         /*
4208          * Handle SCRIPT/STYLE separately
4209          */
4210         htmlParseScript(ctxt);
4211     } else {
4212         /*
4213          * Sometimes DOCTYPE arrives in the middle of the document
4214          */
4215         if ((CUR == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp;
4216         (UPP(2) == &#39;D&#39;) &amp;&amp; (UPP(3) == &#39;O&#39;) &amp;&amp;
4217         (UPP(4) == &#39;C&#39;) &amp;&amp; (UPP(5) == &#39;T&#39;) &amp;&amp;
4218         (UPP(6) == &#39;Y&#39;) &amp;&amp; (UPP(7) == &#39;P&#39;) &amp;&amp;
4219         (UPP(8) == &#39;E&#39;)) {
4220         htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,
4221                      &quot;Misplaced DOCTYPE declaration\n&quot;,
4222                  BAD_CAST &quot;DOCTYPE&quot; , NULL);
4223         htmlParseDocTypeDecl(ctxt);
4224         }
4225 
4226         /*
4227          * First case :  a comment
4228          */
4229         if ((CUR == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp;
4230         (NXT(2) == &#39;-&#39;) &amp;&amp; (NXT(3) == &#39;-&#39;)) {
4231         htmlParseComment(ctxt);
4232         }
4233 
4234         /*
4235          * Second case : a Processing Instruction.
4236          */
4237         else if ((CUR == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;?&#39;)) {
4238         htmlParsePI(ctxt);
4239         }
4240 
4241         /*
4242          * Third case :  a sub-element.
4243          */
4244         else if (CUR == &#39;&lt;&#39;) {
4245         htmlParseElement(ctxt);
4246         }
4247 
4248         /*
4249          * Fourth case : a reference. If if has not been resolved,
4250          *    parsing returns it&#39;s Name, create the node
4251          */
4252         else if (CUR == &#39;&amp;&#39;) {
4253         htmlParseReference(ctxt);
4254         }
4255 
4256         /*
4257          * Fifth case : end of the resource
4258          */
4259         else if (CUR == 0) {
4260         htmlAutoCloseOnEnd(ctxt);
4261         break;
4262         }
4263 
4264         /*
4265          * Last case, text. Note that References are handled directly.
4266          */
4267         else {
4268         htmlParseCharData(ctxt);
4269         }
4270 
4271         if (cons == ctxt-&gt;nbChars) {
4272         if (ctxt-&gt;node != NULL) {
4273             htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
4274                          &quot;detected an error in element content\n&quot;,
4275                  NULL, NULL);
4276         }
4277         break;
4278         }
4279     }
4280         GROW;
4281     }
4282     if (currentNode != NULL) xmlFree(currentNode);
4283 }
4284 
4285 /**
4286  * htmlParseElement:
4287  * @ctxt:  an HTML parser context
4288  *
4289  * parse an HTML element, this is highly recursive
4290  * this is kept for compatibility with previous code versions
4291  *
4292  * [39] element ::= EmptyElemTag | STag content ETag
4293  *
4294  * [41] Attribute ::= Name Eq AttValue
4295  */
4296 
4297 void
4298 htmlParseElement(htmlParserCtxtPtr ctxt) {
4299     const xmlChar *name;
4300     xmlChar *currentNode = NULL;
4301     const htmlElemDesc * info;
4302     htmlParserNodeInfo node_info;
4303     int failed;
4304     int depth;
4305     const xmlChar *oldptr;
4306 
4307     if ((ctxt == NULL) || (ctxt-&gt;input == NULL)) {
4308     htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
4309              &quot;htmlParseElement: context error\n&quot;, NULL, NULL);
4310     return;
4311     }
4312 
4313     if (ctxt-&gt;instate == XML_PARSER_EOF)
4314         return;
4315 
4316     /* Capture start position */
4317     if (ctxt-&gt;record_info) {
4318         node_info.begin_pos = ctxt-&gt;input-&gt;consumed +
4319                           (CUR_PTR - ctxt-&gt;input-&gt;base);
4320     node_info.begin_line = ctxt-&gt;input-&gt;line;
4321     }
4322 
4323     failed = htmlParseStartTag(ctxt);
4324     name = ctxt-&gt;name;
4325     if ((failed == -1) || (name == NULL)) {
4326     if (CUR == &#39;&gt;&#39;)
4327         NEXT;
4328         return;
4329     }
4330 
4331     /*
4332      * Lookup the info for that element.
4333      */
4334     info = htmlTagLookup(name);
4335     if (info == NULL) {
4336     htmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,
4337                  &quot;Tag %s invalid\n&quot;, name, NULL);
4338     }
4339 
4340     /*
4341      * Check for an Empty Element labeled the XML/SGML way
4342      */
4343     if ((CUR == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;)) {
4344         SKIP(2);
4345     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElement != NULL))
4346         ctxt-&gt;sax-&gt;endElement(ctxt-&gt;userData, name);
4347     htmlnamePop(ctxt);
4348     return;
4349     }
4350 
4351     if (CUR == &#39;&gt;&#39;) {
4352         NEXT;
4353     } else {
4354     htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,
4355                  &quot;Couldn&#39;t find end of Start Tag %s\n&quot;, name, NULL);
4356 
4357     /*
4358      * end of parsing of this node.
4359      */
4360     if (xmlStrEqual(name, ctxt-&gt;name)) {
4361         nodePop(ctxt);
4362         htmlnamePop(ctxt);
4363     }
4364 
4365     /*
4366      * Capture end position and add node
4367      */
4368     if (ctxt-&gt;record_info) {
4369        node_info.end_pos = ctxt-&gt;input-&gt;consumed +
4370                   (CUR_PTR - ctxt-&gt;input-&gt;base);
4371        node_info.end_line = ctxt-&gt;input-&gt;line;
4372        node_info.node = ctxt-&gt;node;
4373        xmlParserAddNodeInfo(ctxt, &amp;node_info);
4374     }
4375     return;
4376     }
4377 
4378     /*
4379      * Check for an Empty Element from DTD definition
4380      */
4381     if ((info != NULL) &amp;&amp; (info-&gt;empty)) {
4382     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElement != NULL))
4383         ctxt-&gt;sax-&gt;endElement(ctxt-&gt;userData, name);
4384     htmlnamePop(ctxt);
4385     return;
4386     }
4387 
4388     /*
4389      * Parse the content of the element:
4390      */
4391     currentNode = xmlStrdup(ctxt-&gt;name);
4392     depth = ctxt-&gt;nameNr;
4393     while (IS_CHAR_CH(CUR)) {
4394     oldptr = ctxt-&gt;input-&gt;cur;
4395     htmlParseContent(ctxt);
4396     if (oldptr==ctxt-&gt;input-&gt;cur) break;
4397     if (ctxt-&gt;nameNr &lt; depth) break;
4398     }
4399 
4400     /*
4401      * Capture end position and add node
4402      */
4403     if ( currentNode != NULL &amp;&amp; ctxt-&gt;record_info ) {
4404        node_info.end_pos = ctxt-&gt;input-&gt;consumed +
4405                           (CUR_PTR - ctxt-&gt;input-&gt;base);
4406        node_info.end_line = ctxt-&gt;input-&gt;line;
4407        node_info.node = ctxt-&gt;node;
4408        xmlParserAddNodeInfo(ctxt, &amp;node_info);
4409     }
4410     if (!IS_CHAR_CH(CUR)) {
4411     htmlAutoCloseOnEnd(ctxt);
4412     }
4413 
4414     if (currentNode != NULL)
4415     xmlFree(currentNode);
4416 }
4417 
4418 static void
4419 htmlParserFinishElementParsing(htmlParserCtxtPtr ctxt) {
4420     /*
4421      * Capture end position and add node
4422      */
4423     if ( ctxt-&gt;node != NULL &amp;&amp; ctxt-&gt;record_info ) {
4424        ctxt-&gt;nodeInfo-&gt;end_pos = ctxt-&gt;input-&gt;consumed +
4425                                 (CUR_PTR - ctxt-&gt;input-&gt;base);
4426        ctxt-&gt;nodeInfo-&gt;end_line = ctxt-&gt;input-&gt;line;
4427        ctxt-&gt;nodeInfo-&gt;node = ctxt-&gt;node;
4428        xmlParserAddNodeInfo(ctxt, ctxt-&gt;nodeInfo);
4429        htmlNodeInfoPop(ctxt);
4430     }
4431     if (!IS_CHAR_CH(CUR)) {
4432        htmlAutoCloseOnEnd(ctxt);
4433     }
4434 }
4435 
4436 /**
4437  * htmlParseElementInternal:
4438  * @ctxt:  an HTML parser context
4439  *
4440  * parse an HTML element, new version, non recursive
4441  *
4442  * [39] element ::= EmptyElemTag | STag content ETag
4443  *
4444  * [41] Attribute ::= Name Eq AttValue
4445  */
4446 
4447 static void
4448 htmlParseElementInternal(htmlParserCtxtPtr ctxt) {
4449     const xmlChar *name;
4450     const htmlElemDesc * info;
4451     htmlParserNodeInfo node_info = { NULL, 0, 0, 0, 0 };
4452     int failed;
4453 
4454     if ((ctxt == NULL) || (ctxt-&gt;input == NULL)) {
4455     htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
4456              &quot;htmlParseElementInternal: context error\n&quot;, NULL, NULL);
4457     return;
4458     }
4459 
4460     if (ctxt-&gt;instate == XML_PARSER_EOF)
4461         return;
4462 
4463     /* Capture start position */
4464     if (ctxt-&gt;record_info) {
4465         node_info.begin_pos = ctxt-&gt;input-&gt;consumed +
4466                           (CUR_PTR - ctxt-&gt;input-&gt;base);
4467     node_info.begin_line = ctxt-&gt;input-&gt;line;
4468     }
4469 
4470     failed = htmlParseStartTag(ctxt);
4471     name = ctxt-&gt;name;
4472     if ((failed == -1) || (name == NULL)) {
4473     if (CUR == &#39;&gt;&#39;)
4474         NEXT;
4475         return;
4476     }
4477 
4478     /*
4479      * Lookup the info for that element.
4480      */
4481     info = htmlTagLookup(name);
4482     if (info == NULL) {
4483     htmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,
4484                  &quot;Tag %s invalid\n&quot;, name, NULL);
4485     }
4486 
4487     /*
4488      * Check for an Empty Element labeled the XML/SGML way
4489      */
4490     if ((CUR == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;)) {
4491         SKIP(2);
4492     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElement != NULL))
4493         ctxt-&gt;sax-&gt;endElement(ctxt-&gt;userData, name);
4494     htmlnamePop(ctxt);
4495     return;
4496     }
4497 
4498     if (CUR == &#39;&gt;&#39;) {
4499         NEXT;
4500     } else {
4501     htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,
4502                  &quot;Couldn&#39;t find end of Start Tag %s\n&quot;, name, NULL);
4503 
4504     /*
4505      * end of parsing of this node.
4506      */
4507     if (xmlStrEqual(name, ctxt-&gt;name)) {
4508         nodePop(ctxt);
4509         htmlnamePop(ctxt);
4510     }
4511 
4512         if (ctxt-&gt;record_info)
4513             htmlNodeInfoPush(ctxt, &amp;node_info);
4514         htmlParserFinishElementParsing(ctxt);
4515     return;
4516     }
4517 
4518     /*
4519      * Check for an Empty Element from DTD definition
4520      */
4521     if ((info != NULL) &amp;&amp; (info-&gt;empty)) {
4522     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElement != NULL))
4523         ctxt-&gt;sax-&gt;endElement(ctxt-&gt;userData, name);
4524     htmlnamePop(ctxt);
4525     return;
4526     }
4527 
4528     if (ctxt-&gt;record_info)
4529         htmlNodeInfoPush(ctxt, &amp;node_info);
4530 }
4531 
4532 /**
4533  * htmlParseContentInternal:
4534  * @ctxt:  an HTML parser context
4535  *
4536  * Parse a content: comment, sub-element, reference or text.
4537  * New version for non recursive htmlParseElementInternal
4538  */
4539 
4540 static void
4541 htmlParseContentInternal(htmlParserCtxtPtr ctxt) {
4542     xmlChar *currentNode;
4543     int depth;
4544     const xmlChar *name;
4545 
4546     currentNode = xmlStrdup(ctxt-&gt;name);
4547     depth = ctxt-&gt;nameNr;
4548     while (1) {
4549     long cons = ctxt-&gt;nbChars;
4550 
4551         GROW;
4552 
4553         if (ctxt-&gt;instate == XML_PARSER_EOF)
4554             break;
4555 
4556     /*
4557      * Our tag or one of it&#39;s parent or children is ending.
4558      */
4559         if ((CUR == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
4560         if (htmlParseEndTag(ctxt) &amp;&amp;
4561         ((currentNode != NULL) || (ctxt-&gt;nameNr == 0))) {
4562         if (currentNode != NULL)
4563             xmlFree(currentNode);
4564 
4565             currentNode = xmlStrdup(ctxt-&gt;name);
4566             depth = ctxt-&gt;nameNr;
4567         }
4568         continue; /* while */
4569         }
4570 
4571     else if ((CUR == &#39;&lt;&#39;) &amp;&amp;
4572              ((IS_ASCII_LETTER(NXT(1))) ||
4573           (NXT(1) == &#39;_&#39;) || (NXT(1) == &#39;:&#39;))) {
4574         name = htmlParseHTMLName_nonInvasive(ctxt);
4575         if (name == NULL) {
4576             htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,
4577              &quot;htmlParseStartTag: invalid element name\n&quot;,
4578              NULL, NULL);
4579             /* Dump the bogus tag like browsers do */
4580             while ((IS_CHAR_CH(CUR)) &amp;&amp; (CUR != &#39;&gt;&#39;))
4581                 NEXT;
4582 
4583             htmlParserFinishElementParsing(ctxt);
4584             if (currentNode != NULL)
4585                 xmlFree(currentNode);
4586 
4587             currentNode = xmlStrdup(ctxt-&gt;name);
4588             depth = ctxt-&gt;nameNr;
4589             continue;
4590         }
4591 
4592         if (ctxt-&gt;name != NULL) {
4593             if (htmlCheckAutoClose(name, ctxt-&gt;name) == 1) {
4594                 htmlAutoClose(ctxt, name);
4595                 continue;
4596             }
4597         }
4598     }
4599 
4600     /*
4601      * Has this node been popped out during parsing of
4602      * the next element
4603      */
4604         if ((ctxt-&gt;nameNr &gt; 0) &amp;&amp; (depth &gt;= ctxt-&gt;nameNr) &amp;&amp;
4605         (!xmlStrEqual(currentNode, ctxt-&gt;name)))
4606          {
4607         htmlParserFinishElementParsing(ctxt);
4608         if (currentNode != NULL) xmlFree(currentNode);
4609 
4610         currentNode = xmlStrdup(ctxt-&gt;name);
4611         depth = ctxt-&gt;nameNr;
4612         continue;
4613     }
4614 
4615     if ((CUR != 0) &amp;&amp; ((xmlStrEqual(currentNode, BAD_CAST&quot;script&quot;)) ||
4616         (xmlStrEqual(currentNode, BAD_CAST&quot;style&quot;)))) {
4617         /*
4618          * Handle SCRIPT/STYLE separately
4619          */
4620         htmlParseScript(ctxt);
4621     } else {
4622         /*
4623          * Sometimes DOCTYPE arrives in the middle of the document
4624          */
4625         if ((CUR == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp;
4626         (UPP(2) == &#39;D&#39;) &amp;&amp; (UPP(3) == &#39;O&#39;) &amp;&amp;
4627         (UPP(4) == &#39;C&#39;) &amp;&amp; (UPP(5) == &#39;T&#39;) &amp;&amp;
4628         (UPP(6) == &#39;Y&#39;) &amp;&amp; (UPP(7) == &#39;P&#39;) &amp;&amp;
4629         (UPP(8) == &#39;E&#39;)) {
4630         htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,
4631                      &quot;Misplaced DOCTYPE declaration\n&quot;,
4632                  BAD_CAST &quot;DOCTYPE&quot; , NULL);
4633         htmlParseDocTypeDecl(ctxt);
4634         }
4635 
4636         /*
4637          * First case :  a comment
4638          */
4639         if ((CUR == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp;
4640         (NXT(2) == &#39;-&#39;) &amp;&amp; (NXT(3) == &#39;-&#39;)) {
4641         htmlParseComment(ctxt);
4642         }
4643 
4644         /*
4645          * Second case : a Processing Instruction.
4646          */
4647         else if ((CUR == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;?&#39;)) {
4648         htmlParsePI(ctxt);
4649         }
4650 
4651         /*
4652          * Third case :  a sub-element.
4653          */
4654         else if (CUR == &#39;&lt;&#39;) {
4655         htmlParseElementInternal(ctxt);
4656         if (currentNode != NULL) xmlFree(currentNode);
4657 
4658         currentNode = xmlStrdup(ctxt-&gt;name);
4659         depth = ctxt-&gt;nameNr;
4660         }
4661 
4662         /*
4663          * Fourth case : a reference. If if has not been resolved,
4664          *    parsing returns it&#39;s Name, create the node
4665          */
4666         else if (CUR == &#39;&amp;&#39;) {
4667         htmlParseReference(ctxt);
4668         }
4669 
4670         /*
4671          * Fifth case : end of the resource
4672          */
4673         else if (CUR == 0) {
4674         htmlAutoCloseOnEnd(ctxt);
4675         break;
4676         }
4677 
4678         /*
4679          * Last case, text. Note that References are handled directly.
4680          */
4681         else {
4682         htmlParseCharData(ctxt);
4683         }
4684 
4685         if (cons == ctxt-&gt;nbChars) {
4686         if (ctxt-&gt;node != NULL) {
4687             htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
4688                          &quot;detected an error in element content\n&quot;,
4689                  NULL, NULL);
4690         }
4691         break;
4692         }
4693     }
4694         GROW;
4695     }
4696     if (currentNode != NULL) xmlFree(currentNode);
4697 }
4698 
4699 /**
4700  * htmlParseContent:
4701  * @ctxt:  an HTML parser context
4702  *
4703  * Parse a content: comment, sub-element, reference or text.
4704  * This is the entry point when called from parser.c
4705  */
4706 
4707 void
4708 __htmlParseContent(void *ctxt) {
4709     if (ctxt != NULL)
4710     htmlParseContentInternal((htmlParserCtxtPtr) ctxt);
4711 }
4712 
4713 /**
4714  * htmlParseDocument:
4715  * @ctxt:  an HTML parser context
4716  *
4717  * parse an HTML document (and build a tree if using the standard SAX
4718  * interface).
4719  *
4720  * Returns 0, -1 in case of error. the parser context is augmented
4721  *                as a result of the parsing.
4722  */
4723 
4724 int
4725 htmlParseDocument(htmlParserCtxtPtr ctxt) {
4726     xmlChar start[4];
4727     xmlCharEncoding enc;
4728     xmlDtdPtr dtd;
4729 
4730     xmlInitParser();
4731 
4732     htmlDefaultSAXHandlerInit();
4733 
4734     if ((ctxt == NULL) || (ctxt-&gt;input == NULL)) {
4735     htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
4736              &quot;htmlParseDocument: context error\n&quot;, NULL, NULL);
4737     return(XML_ERR_INTERNAL_ERROR);
4738     }
4739     ctxt-&gt;html = 1;
4740     ctxt-&gt;linenumbers = 1;
4741     GROW;
4742     /*
4743      * SAX: beginning of the document processing.
4744      */
4745     if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;setDocumentLocator))
4746         ctxt-&gt;sax-&gt;setDocumentLocator(ctxt-&gt;userData, &amp;xmlDefaultSAXLocator);
4747 
4748     if ((ctxt-&gt;encoding == (const xmlChar *)XML_CHAR_ENCODING_NONE) &amp;&amp;
4749         ((ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur) &gt;= 4)) {
4750     /*
4751      * Get the 4 first bytes and decode the charset
4752      * if enc != XML_CHAR_ENCODING_NONE
4753      * plug some encoding conversion routines.
4754      */
4755     start[0] = RAW;
4756     start[1] = NXT(1);
4757     start[2] = NXT(2);
4758     start[3] = NXT(3);
4759     enc = xmlDetectCharEncoding(&amp;start[0], 4);
4760     if (enc != XML_CHAR_ENCODING_NONE) {
4761         xmlSwitchEncoding(ctxt, enc);
4762     }
4763     }
4764 
4765     /*
4766      * Wipe out everything which is before the first &#39;&lt;&#39;
4767      */
4768     SKIP_BLANKS;
4769     if (CUR == 0) {
4770     htmlParseErr(ctxt, XML_ERR_DOCUMENT_EMPTY,
4771                  &quot;Document is empty\n&quot;, NULL, NULL);
4772     }
4773 
4774     if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;startDocument) &amp;&amp; (!ctxt-&gt;disableSAX))
4775     ctxt-&gt;sax-&gt;startDocument(ctxt-&gt;userData);
4776 
4777 
4778     /*
4779      * Parse possible comments and PIs before any content
4780      */
4781     while (((CUR == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp;
4782             (NXT(2) == &#39;-&#39;) &amp;&amp; (NXT(3) == &#39;-&#39;)) ||
4783        ((CUR == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;?&#39;))) {
4784         htmlParseComment(ctxt);
4785         htmlParsePI(ctxt);
4786     SKIP_BLANKS;
4787     }
4788 
4789 
4790     /*
4791      * Then possibly doc type declaration(s) and more Misc
4792      * (doctypedecl Misc*)?
4793      */
4794     if ((CUR == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp;
4795     (UPP(2) == &#39;D&#39;) &amp;&amp; (UPP(3) == &#39;O&#39;) &amp;&amp;
4796     (UPP(4) == &#39;C&#39;) &amp;&amp; (UPP(5) == &#39;T&#39;) &amp;&amp;
4797     (UPP(6) == &#39;Y&#39;) &amp;&amp; (UPP(7) == &#39;P&#39;) &amp;&amp;
4798     (UPP(8) == &#39;E&#39;)) {
4799     htmlParseDocTypeDecl(ctxt);
4800     }
4801     SKIP_BLANKS;
4802 
4803     /*
4804      * Parse possible comments and PIs before any content
4805      */
4806     while (((CUR == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp;
4807             (NXT(2) == &#39;-&#39;) &amp;&amp; (NXT(3) == &#39;-&#39;)) ||
4808        ((CUR == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;?&#39;))) {
4809         htmlParseComment(ctxt);
4810         htmlParsePI(ctxt);
4811     SKIP_BLANKS;
4812     }
4813 
4814     /*
4815      * Time to start parsing the tree itself
4816      */
4817     htmlParseContentInternal(ctxt);
4818 
4819     /*
4820      * autoclose
4821      */
4822     if (CUR == 0)
4823     htmlAutoCloseOnEnd(ctxt);
4824 
4825 
4826     /*
4827      * SAX: end of the document processing.
4828      */
4829     if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;endDocument != NULL))
4830         ctxt-&gt;sax-&gt;endDocument(ctxt-&gt;userData);
4831 
4832     if ((!(ctxt-&gt;options &amp; HTML_PARSE_NODEFDTD)) &amp;&amp; (ctxt-&gt;myDoc != NULL)) {
4833     dtd = xmlGetIntSubset(ctxt-&gt;myDoc);
4834     if (dtd == NULL)
4835         ctxt-&gt;myDoc-&gt;intSubset =
4836         xmlCreateIntSubset(ctxt-&gt;myDoc, BAD_CAST &quot;html&quot;,
4837             BAD_CAST &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;,
4838             BAD_CAST &quot;http://www.w3.org/TR/REC-html40/loose.dtd&quot;);
4839     }
4840     if (! ctxt-&gt;wellFormed) return(-1);
4841     return(0);
4842 }
4843 
4844 
4845 /************************************************************************
4846  *                                  *
4847  *          Parser contexts handling            *
4848  *                                  *
4849  ************************************************************************/
4850 
4851 /**
4852  * htmlInitParserCtxt:
4853  * @ctxt:  an HTML parser context
4854  *
4855  * Initialize a parser context
4856  *
4857  * Returns 0 in case of success and -1 in case of error
4858  */
4859 
4860 static int
4861 htmlInitParserCtxt(htmlParserCtxtPtr ctxt)
4862 {
4863     htmlSAXHandler *sax;
4864 
4865     if (ctxt == NULL) return(-1);
4866     memset(ctxt, 0, sizeof(htmlParserCtxt));
4867 
4868     ctxt-&gt;dict = xmlDictCreate();
4869     if (ctxt-&gt;dict == NULL) {
4870         htmlErrMemory(NULL, &quot;htmlInitParserCtxt: out of memory\n&quot;);
4871     return(-1);
4872     }
4873     sax = (htmlSAXHandler *) xmlMalloc(sizeof(htmlSAXHandler));
4874     if (sax == NULL) {
4875         htmlErrMemory(NULL, &quot;htmlInitParserCtxt: out of memory\n&quot;);
4876     return(-1);
4877     }
4878     else
4879         memset(sax, 0, sizeof(htmlSAXHandler));
4880 
4881     /* Allocate the Input stack */
4882     ctxt-&gt;inputTab = (htmlParserInputPtr *)
4883                       xmlMalloc(5 * sizeof(htmlParserInputPtr));
4884     if (ctxt-&gt;inputTab == NULL) {
4885         htmlErrMemory(NULL, &quot;htmlInitParserCtxt: out of memory\n&quot;);
4886     ctxt-&gt;inputNr = 0;
4887     ctxt-&gt;inputMax = 0;
4888     ctxt-&gt;input = NULL;
4889     return(-1);
4890     }
4891     ctxt-&gt;inputNr = 0;
4892     ctxt-&gt;inputMax = 5;
4893     ctxt-&gt;input = NULL;
4894     ctxt-&gt;version = NULL;
4895     ctxt-&gt;encoding = NULL;
4896     ctxt-&gt;standalone = -1;
4897     ctxt-&gt;instate = XML_PARSER_START;
4898 
4899     /* Allocate the Node stack */
4900     ctxt-&gt;nodeTab = (htmlNodePtr *) xmlMalloc(10 * sizeof(htmlNodePtr));
4901     if (ctxt-&gt;nodeTab == NULL) {
4902         htmlErrMemory(NULL, &quot;htmlInitParserCtxt: out of memory\n&quot;);
4903     ctxt-&gt;nodeNr = 0;
4904     ctxt-&gt;nodeMax = 0;
4905     ctxt-&gt;node = NULL;
4906     ctxt-&gt;inputNr = 0;
4907     ctxt-&gt;inputMax = 0;
4908     ctxt-&gt;input = NULL;
4909     return(-1);
4910     }
4911     ctxt-&gt;nodeNr = 0;
4912     ctxt-&gt;nodeMax = 10;
4913     ctxt-&gt;node = NULL;
4914 
4915     /* Allocate the Name stack */
4916     ctxt-&gt;nameTab = (const xmlChar **) xmlMalloc(10 * sizeof(xmlChar *));
4917     if (ctxt-&gt;nameTab == NULL) {
4918         htmlErrMemory(NULL, &quot;htmlInitParserCtxt: out of memory\n&quot;);
4919     ctxt-&gt;nameNr = 0;
4920     ctxt-&gt;nameMax = 0;
4921     ctxt-&gt;name = NULL;
4922     ctxt-&gt;nodeNr = 0;
4923     ctxt-&gt;nodeMax = 0;
4924     ctxt-&gt;node = NULL;
4925     ctxt-&gt;inputNr = 0;
4926     ctxt-&gt;inputMax = 0;
4927     ctxt-&gt;input = NULL;
4928     return(-1);
4929     }
4930     ctxt-&gt;nameNr = 0;
4931     ctxt-&gt;nameMax = 10;
4932     ctxt-&gt;name = NULL;
4933 
4934     ctxt-&gt;nodeInfoTab = NULL;
4935     ctxt-&gt;nodeInfoNr  = 0;
4936     ctxt-&gt;nodeInfoMax = 0;
4937 
4938     if (sax == NULL) ctxt-&gt;sax = (xmlSAXHandlerPtr) &amp;htmlDefaultSAXHandler;
4939     else {
4940         ctxt-&gt;sax = sax;
4941     memcpy(sax, &amp;htmlDefaultSAXHandler, sizeof(xmlSAXHandlerV1));
4942     }
4943     ctxt-&gt;userData = ctxt;
4944     ctxt-&gt;myDoc = NULL;
4945     ctxt-&gt;wellFormed = 1;
4946     ctxt-&gt;replaceEntities = 0;
4947     ctxt-&gt;linenumbers = xmlLineNumbersDefaultValue;
4948     ctxt-&gt;keepBlanks = xmlKeepBlanksDefaultValue;
4949     ctxt-&gt;html = 1;
4950     ctxt-&gt;vctxt.finishDtd = XML_CTXT_FINISH_DTD_0;
4951     ctxt-&gt;vctxt.userData = ctxt;
4952     ctxt-&gt;vctxt.error = xmlParserValidityError;
4953     ctxt-&gt;vctxt.warning = xmlParserValidityWarning;
4954     ctxt-&gt;record_info = 0;
4955     ctxt-&gt;validate = 0;
4956     ctxt-&gt;nbChars = 0;
4957     ctxt-&gt;checkIndex = 0;
4958     ctxt-&gt;catalogs = NULL;
4959     xmlInitNodeInfoSeq(&amp;ctxt-&gt;node_seq);
4960     return(0);
4961 }
4962 
4963 /**
4964  * htmlFreeParserCtxt:
4965  * @ctxt:  an HTML parser context
4966  *
4967  * Free all the memory used by a parser context. However the parsed
4968  * document in ctxt-&gt;myDoc is not freed.
4969  */
4970 
4971 void
4972 htmlFreeParserCtxt(htmlParserCtxtPtr ctxt)
4973 {
4974     xmlFreeParserCtxt(ctxt);
4975 }
4976 
4977 /**
4978  * htmlNewParserCtxt:
4979  *
4980  * Allocate and initialize a new parser context.
4981  *
4982  * Returns the htmlParserCtxtPtr or NULL in case of allocation error
4983  */
4984 
4985 htmlParserCtxtPtr
4986 htmlNewParserCtxt(void)
4987 {
4988     xmlParserCtxtPtr ctxt;
4989 
4990     ctxt = (xmlParserCtxtPtr) xmlMalloc(sizeof(xmlParserCtxt));
4991     if (ctxt == NULL) {
4992         htmlErrMemory(NULL, &quot;NewParserCtxt: out of memory\n&quot;);
4993     return(NULL);
4994     }
4995     memset(ctxt, 0, sizeof(xmlParserCtxt));
4996     if (htmlInitParserCtxt(ctxt) &lt; 0) {
4997         htmlFreeParserCtxt(ctxt);
4998     return(NULL);
4999     }
5000     return(ctxt);
5001 }
5002 
5003 /**
5004  * htmlCreateMemoryParserCtxt:
5005  * @buffer:  a pointer to a char array
5006  * @size:  the size of the array
5007  *
5008  * Create a parser context for an HTML in-memory document.
5009  *
5010  * Returns the new parser context or NULL
5011  */
5012 htmlParserCtxtPtr
5013 htmlCreateMemoryParserCtxt(const char *buffer, int size) {
5014     xmlParserCtxtPtr ctxt;
5015     xmlParserInputPtr input;
5016     xmlParserInputBufferPtr buf;
5017 
5018     if (buffer == NULL)
5019     return(NULL);
5020     if (size &lt;= 0)
5021     return(NULL);
5022 
5023     ctxt = htmlNewParserCtxt();
5024     if (ctxt == NULL)
5025     return(NULL);
5026 
5027     buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
5028     if (buf == NULL) return(NULL);
5029 
5030     input = xmlNewInputStream(ctxt);
5031     if (input == NULL) {
5032     xmlFreeParserCtxt(ctxt);
5033     return(NULL);
5034     }
5035 
5036     input-&gt;filename = NULL;
5037     input-&gt;buf = buf;
5038     xmlBufResetInput(buf-&gt;buffer, input);
5039 
5040     inputPush(ctxt, input);
5041     return(ctxt);
5042 }
5043 
5044 /**
5045  * htmlCreateDocParserCtxt:
5046  * @cur:  a pointer to an array of xmlChar
5047  * @encoding:  a free form C string describing the HTML document encoding, or NULL
5048  *
5049  * Create a parser context for an HTML document.
5050  *
5051  * TODO: check the need to add encoding handling there
5052  *
5053  * Returns the new parser context or NULL
5054  */
5055 static htmlParserCtxtPtr
5056 htmlCreateDocParserCtxt(const xmlChar *cur, const char *encoding) {
5057     int len;
5058     htmlParserCtxtPtr ctxt;
5059 
5060     if (cur == NULL)
5061     return(NULL);
5062     len = xmlStrlen(cur);
5063     ctxt = htmlCreateMemoryParserCtxt((char *)cur, len);
5064     if (ctxt == NULL)
5065     return(NULL);
5066 
5067     if (encoding != NULL) {
5068     xmlCharEncoding enc;
5069     xmlCharEncodingHandlerPtr handler;
5070 
5071     if (ctxt-&gt;input-&gt;encoding != NULL)
5072         xmlFree((xmlChar *) ctxt-&gt;input-&gt;encoding);
5073     ctxt-&gt;input-&gt;encoding = xmlStrdup((const xmlChar *) encoding);
5074 
5075     enc = xmlParseCharEncoding(encoding);
5076     /*
5077      * registered set of known encodings
5078      */
5079     if (enc != XML_CHAR_ENCODING_ERROR) {
5080         xmlSwitchEncoding(ctxt, enc);
5081         if (ctxt-&gt;errNo == XML_ERR_UNSUPPORTED_ENCODING) {
5082         htmlParseErr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
5083                      &quot;Unsupported encoding %s\n&quot;,
5084                  (const xmlChar *) encoding, NULL);
5085         }
5086     } else {
5087         /*
5088          * fallback for unknown encodings
5089          */
5090         handler = xmlFindCharEncodingHandler((const char *) encoding);
5091         if (handler != NULL) {
5092         xmlSwitchToEncoding(ctxt, handler);
5093         } else {
5094         htmlParseErr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
5095                      &quot;Unsupported encoding %s\n&quot;,
5096                  (const xmlChar *) encoding, NULL);
5097         }
5098     }
5099     }
5100     return(ctxt);
5101 }
5102 
5103 #ifdef LIBXML_PUSH_ENABLED
5104 /************************************************************************
5105  *                                  *
5106  *  Progressive parsing interfaces              *
5107  *                                  *
5108  ************************************************************************/
5109 
5110 /**
5111  * htmlParseLookupSequence:
5112  * @ctxt:  an HTML parser context
5113  * @first:  the first char to lookup
5114  * @next:  the next char to lookup or zero
5115  * @third:  the next char to lookup or zero
5116  * @comment: flag to force checking inside comments
5117  *
5118  * Try to find if a sequence (first, next, third) or  just (first next) or
5119  * (first) is available in the input stream.
5120  * This function has a side effect of (possibly) incrementing ctxt-&gt;checkIndex
5121  * to avoid rescanning sequences of bytes, it DOES change the state of the
5122  * parser, do not use liberally.
5123  * This is basically similar to xmlParseLookupSequence()
5124  *
5125  * Returns the index to the current parsing point if the full sequence
5126  *      is available, -1 otherwise.
5127  */
5128 static int
5129 htmlParseLookupSequence(htmlParserCtxtPtr ctxt, xmlChar first,
5130                         xmlChar next, xmlChar third, int iscomment,
5131                         int ignoreattrval)
5132 {
5133     int base, len;
5134     htmlParserInputPtr in;
5135     const xmlChar *buf;
5136     int incomment = 0;
5137     int invalue = 0;
5138     char valdellim = 0x0;
5139 
5140     in = ctxt-&gt;input;
5141     if (in == NULL)
5142         return (-1);
5143 
5144     base = in-&gt;cur - in-&gt;base;
5145     if (base &lt; 0)
5146         return (-1);
5147 
5148     if (ctxt-&gt;checkIndex &gt; base)
5149         base = ctxt-&gt;checkIndex;
5150 
5151     if (in-&gt;buf == NULL) {
5152         buf = in-&gt;base;
5153         len = in-&gt;length;
5154     } else {
5155         buf = xmlBufContent(in-&gt;buf-&gt;buffer);
5156         len = xmlBufUse(in-&gt;buf-&gt;buffer);
5157     }
5158 
5159     /* take into account the sequence length */
5160     if (third)
5161         len -= 2;
5162     else if (next)
5163         len--;
5164     for (; base &lt; len; base++) {
5165         if ((!incomment) &amp;&amp; (base + 4 &lt; len) &amp;&amp; (!iscomment)) {
5166             if ((buf[base] == &#39;&lt;&#39;) &amp;&amp; (buf[base + 1] == &#39;!&#39;) &amp;&amp;
5167                 (buf[base + 2] == &#39;-&#39;) &amp;&amp; (buf[base + 3] == &#39;-&#39;)) {
5168                 incomment = 1;
5169                 /* do not increment past &lt;! - some people use &lt;!--&gt; */
5170                 base += 2;
5171             }
5172         }
5173         if (ignoreattrval) {
5174             if (buf[base] == &#39;&quot;&#39; || buf[base] == &#39;\&#39;&#39;) {
5175                 if (invalue) {
5176                     if (buf[base] == valdellim) {
5177                         invalue = 0;
5178                         continue;
5179                     }
5180                 } else {
5181                     valdellim = buf[base];
5182                     invalue = 1;
5183                     continue;
5184                 }
5185             } else if (invalue) {
5186                 continue;
5187             }
5188         }
5189         if (incomment) {
5190             if (base + 3 &gt; len)
5191                 return (-1);
5192             if ((buf[base] == &#39;-&#39;) &amp;&amp; (buf[base + 1] == &#39;-&#39;) &amp;&amp;
5193                 (buf[base + 2] == &#39;&gt;&#39;)) {
5194                 incomment = 0;
5195                 base += 2;
5196             }
5197             continue;
5198         }
5199         if (buf[base] == first) {
5200             if (third != 0) {
5201                 if ((buf[base + 1] != next) || (buf[base + 2] != third))
5202                     continue;
5203             } else if (next != 0) {
5204                 if (buf[base + 1] != next)
5205                     continue;
5206             }
5207             ctxt-&gt;checkIndex = 0;
5208 #ifdef DEBUG_PUSH
5209             if (next == 0)
5210                 xmlGenericError(xmlGenericErrorContext,
5211                                 &quot;HPP: lookup &#39;%c&#39; found at %d\n&quot;,
5212                                 first, base);
5213             else if (third == 0)
5214                 xmlGenericError(xmlGenericErrorContext,
5215                                 &quot;HPP: lookup &#39;%c%c&#39; found at %d\n&quot;,
5216                                 first, next, base);
5217             else
5218                 xmlGenericError(xmlGenericErrorContext,
5219                                 &quot;HPP: lookup &#39;%c%c%c&#39; found at %d\n&quot;,
5220                                 first, next, third, base);
5221 #endif
5222             return (base - (in-&gt;cur - in-&gt;base));
5223         }
5224     }
5225     if ((!incomment) &amp;&amp; (!invalue))
5226         ctxt-&gt;checkIndex = base;
5227 #ifdef DEBUG_PUSH
5228     if (next == 0)
5229         xmlGenericError(xmlGenericErrorContext,
5230                         &quot;HPP: lookup &#39;%c&#39; failed\n&quot;, first);
5231     else if (third == 0)
5232         xmlGenericError(xmlGenericErrorContext,
5233                         &quot;HPP: lookup &#39;%c%c&#39; failed\n&quot;, first, next);
5234     else
5235         xmlGenericError(xmlGenericErrorContext,
5236                         &quot;HPP: lookup &#39;%c%c%c&#39; failed\n&quot;, first, next,
5237                         third);
5238 #endif
5239     return (-1);
5240 }
5241 
5242 /**
5243  * htmlParseLookupChars:
5244  * @ctxt: an HTML parser context
5245  * @stop: Array of chars, which stop the lookup.
5246  * @stopLen: Length of stop-Array
5247  *
5248  * Try to find if any char of the stop-Array is available in the input
5249  * stream.
5250  * This function has a side effect of (possibly) incrementing ctxt-&gt;checkIndex
5251  * to avoid rescanning sequences of bytes, it DOES change the state of the
5252  * parser, do not use liberally.
5253  *
5254  * Returns the index to the current parsing point if a stopChar
5255  *      is available, -1 otherwise.
5256  */
5257 static int
5258 htmlParseLookupChars(htmlParserCtxtPtr ctxt, const xmlChar * stop,
5259                      int stopLen)
5260 {
5261     int base, len;
5262     htmlParserInputPtr in;
5263     const xmlChar *buf;
5264     int incomment = 0;
5265     int i;
5266 
5267     in = ctxt-&gt;input;
5268     if (in == NULL)
5269         return (-1);
5270 
5271     base = in-&gt;cur - in-&gt;base;
5272     if (base &lt; 0)
5273         return (-1);
5274 
5275     if (ctxt-&gt;checkIndex &gt; base)
5276         base = ctxt-&gt;checkIndex;
5277 
5278     if (in-&gt;buf == NULL) {
5279         buf = in-&gt;base;
5280         len = in-&gt;length;
5281     } else {
5282         buf = xmlBufContent(in-&gt;buf-&gt;buffer);
5283         len = xmlBufUse(in-&gt;buf-&gt;buffer);
5284     }
5285 
5286     for (; base &lt; len; base++) {
5287         if (!incomment &amp;&amp; (base + 4 &lt; len)) {
5288             if ((buf[base] == &#39;&lt;&#39;) &amp;&amp; (buf[base + 1] == &#39;!&#39;) &amp;&amp;
5289                 (buf[base + 2] == &#39;-&#39;) &amp;&amp; (buf[base + 3] == &#39;-&#39;)) {
5290                 incomment = 1;
5291                 /* do not increment past &lt;! - some people use &lt;!--&gt; */
5292                 base += 2;
5293             }
5294         }
5295         if (incomment) {
5296             if (base + 3 &gt; len)
5297                 return (-1);
5298             if ((buf[base] == &#39;-&#39;) &amp;&amp; (buf[base + 1] == &#39;-&#39;) &amp;&amp;
5299                 (buf[base + 2] == &#39;&gt;&#39;)) {
5300                 incomment = 0;
5301                 base += 2;
5302             }
5303             continue;
5304         }
5305         for (i = 0; i &lt; stopLen; ++i) {
5306             if (buf[base] == stop[i]) {
5307                 ctxt-&gt;checkIndex = 0;
5308                 return (base - (in-&gt;cur - in-&gt;base));
5309             }
5310         }
5311     }
5312     ctxt-&gt;checkIndex = base;
5313     return (-1);
5314 }
5315 
5316 /**
5317  * htmlParseTryOrFinish:
5318  * @ctxt:  an HTML parser context
5319  * @terminate:  last chunk indicator
5320  *
5321  * Try to progress on parsing
5322  *
5323  * Returns zero if no parsing was possible
5324  */
5325 static int
5326 htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
5327     int ret = 0;
5328     htmlParserInputPtr in;
5329     int avail = 0;
5330     xmlChar cur, next;
5331 
5332     htmlParserNodeInfo node_info;
5333 
5334 #ifdef DEBUG_PUSH
5335     switch (ctxt-&gt;instate) {
5336     case XML_PARSER_EOF:
5337         xmlGenericError(xmlGenericErrorContext,
5338             &quot;HPP: try EOF\n&quot;); break;
5339     case XML_PARSER_START:
5340         xmlGenericError(xmlGenericErrorContext,
5341             &quot;HPP: try START\n&quot;); break;
5342     case XML_PARSER_MISC:
5343         xmlGenericError(xmlGenericErrorContext,
5344             &quot;HPP: try MISC\n&quot;);break;
5345     case XML_PARSER_COMMENT:
5346         xmlGenericError(xmlGenericErrorContext,
5347             &quot;HPP: try COMMENT\n&quot;);break;
5348     case XML_PARSER_PROLOG:
5349         xmlGenericError(xmlGenericErrorContext,
5350             &quot;HPP: try PROLOG\n&quot;);break;
5351     case XML_PARSER_START_TAG:
5352         xmlGenericError(xmlGenericErrorContext,
5353             &quot;HPP: try START_TAG\n&quot;);break;
5354     case XML_PARSER_CONTENT:
5355         xmlGenericError(xmlGenericErrorContext,
5356             &quot;HPP: try CONTENT\n&quot;);break;
5357     case XML_PARSER_CDATA_SECTION:
5358         xmlGenericError(xmlGenericErrorContext,
5359             &quot;HPP: try CDATA_SECTION\n&quot;);break;
5360     case XML_PARSER_END_TAG:
5361         xmlGenericError(xmlGenericErrorContext,
5362             &quot;HPP: try END_TAG\n&quot;);break;
5363     case XML_PARSER_ENTITY_DECL:
5364         xmlGenericError(xmlGenericErrorContext,
5365             &quot;HPP: try ENTITY_DECL\n&quot;);break;
5366     case XML_PARSER_ENTITY_VALUE:
5367         xmlGenericError(xmlGenericErrorContext,
5368             &quot;HPP: try ENTITY_VALUE\n&quot;);break;
5369     case XML_PARSER_ATTRIBUTE_VALUE:
5370         xmlGenericError(xmlGenericErrorContext,
5371             &quot;HPP: try ATTRIBUTE_VALUE\n&quot;);break;
5372     case XML_PARSER_DTD:
5373         xmlGenericError(xmlGenericErrorContext,
5374             &quot;HPP: try DTD\n&quot;);break;
5375     case XML_PARSER_EPILOG:
5376         xmlGenericError(xmlGenericErrorContext,
5377             &quot;HPP: try EPILOG\n&quot;);break;
5378     case XML_PARSER_PI:
5379         xmlGenericError(xmlGenericErrorContext,
5380             &quot;HPP: try PI\n&quot;);break;
5381     case XML_PARSER_SYSTEM_LITERAL:
5382         xmlGenericError(xmlGenericErrorContext,
5383             &quot;HPP: try SYSTEM_LITERAL\n&quot;);break;
5384     }
5385 #endif
5386 
5387     while (1) {
5388 
5389     in = ctxt-&gt;input;
5390     if (in == NULL) break;
5391     if (in-&gt;buf == NULL)
5392         avail = in-&gt;length - (in-&gt;cur - in-&gt;base);
5393     else
5394         avail = xmlBufUse(in-&gt;buf-&gt;buffer) - (in-&gt;cur - in-&gt;base);
5395     if ((avail == 0) &amp;&amp; (terminate)) {
5396         htmlAutoCloseOnEnd(ctxt);
5397         if ((ctxt-&gt;nameNr == 0) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF)) {
5398         /*
5399          * SAX: end of the document processing.
5400          */
5401         ctxt-&gt;instate = XML_PARSER_EOF;
5402         if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;endDocument != NULL))
5403             ctxt-&gt;sax-&gt;endDocument(ctxt-&gt;userData);
5404         }
5405     }
5406         if (avail &lt; 1)
5407         goto done;
5408     cur = in-&gt;cur[0];
5409     if (cur == 0) {
5410         SKIP(1);
5411         continue;
5412     }
5413 
5414         switch (ctxt-&gt;instate) {
5415             case XML_PARSER_EOF:
5416             /*
5417          * Document parsing is done !
5418          */
5419             goto done;
5420             case XML_PARSER_START:
5421             /*
5422          * Very first chars read from the document flow.
5423          */
5424         cur = in-&gt;cur[0];
5425         if (IS_BLANK_CH(cur)) {
5426             SKIP_BLANKS;
5427             if (in-&gt;buf == NULL)
5428             avail = in-&gt;length - (in-&gt;cur - in-&gt;base);
5429             else
5430             avail = xmlBufUse(in-&gt;buf-&gt;buffer) - (in-&gt;cur - in-&gt;base);
5431         }
5432         if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;setDocumentLocator))
5433             ctxt-&gt;sax-&gt;setDocumentLocator(ctxt-&gt;userData,
5434                           &amp;xmlDefaultSAXLocator);
5435         if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;startDocument) &amp;&amp;
5436                 (!ctxt-&gt;disableSAX))
5437             ctxt-&gt;sax-&gt;startDocument(ctxt-&gt;userData);
5438 
5439         cur = in-&gt;cur[0];
5440         next = in-&gt;cur[1];
5441         if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
5442             (UPP(2) == &#39;D&#39;) &amp;&amp; (UPP(3) == &#39;O&#39;) &amp;&amp;
5443             (UPP(4) == &#39;C&#39;) &amp;&amp; (UPP(5) == &#39;T&#39;) &amp;&amp;
5444             (UPP(6) == &#39;Y&#39;) &amp;&amp; (UPP(7) == &#39;P&#39;) &amp;&amp;
5445             (UPP(8) == &#39;E&#39;)) {
5446             if ((!terminate) &amp;&amp;
5447                 (htmlParseLookupSequence(ctxt, &#39;&gt;&#39;, 0, 0, 0, 1) &lt; 0))
5448             goto done;
5449 #ifdef DEBUG_PUSH
5450             xmlGenericError(xmlGenericErrorContext,
5451                 &quot;HPP: Parsing internal subset\n&quot;);
5452 #endif
5453             htmlParseDocTypeDecl(ctxt);
5454             ctxt-&gt;instate = XML_PARSER_PROLOG;
5455 #ifdef DEBUG_PUSH
5456             xmlGenericError(xmlGenericErrorContext,
5457                 &quot;HPP: entering PROLOG\n&quot;);
5458 #endif
5459                 } else {
5460             ctxt-&gt;instate = XML_PARSER_MISC;
5461 #ifdef DEBUG_PUSH
5462             xmlGenericError(xmlGenericErrorContext,
5463                 &quot;HPP: entering MISC\n&quot;);
5464 #endif
5465         }
5466         break;
5467             case XML_PARSER_MISC:
5468         SKIP_BLANKS;
5469         if (in-&gt;buf == NULL)
5470             avail = in-&gt;length - (in-&gt;cur - in-&gt;base);
5471         else
5472             avail = xmlBufUse(in-&gt;buf-&gt;buffer) - (in-&gt;cur - in-&gt;base);
5473         /*
5474          * no chars in buffer
5475          */
5476         if (avail &lt; 1)
5477             goto done;
5478         /*
5479          * not enouth chars in buffer
5480          */
5481         if (avail &lt; 2) {
5482             if (!terminate)
5483             goto done;
5484             else
5485             next = &#39; &#39;;
5486         } else {
5487             next = in-&gt;cur[1];
5488         }
5489         cur = in-&gt;cur[0];
5490             if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
5491             (in-&gt;cur[2] == &#39;-&#39;) &amp;&amp; (in-&gt;cur[3] == &#39;-&#39;)) {
5492             if ((!terminate) &amp;&amp;
5493                 (htmlParseLookupSequence(ctxt, &#39;-&#39;, &#39;-&#39;, &#39;&gt;&#39;, 1, 1) &lt; 0))
5494             goto done;
5495 #ifdef DEBUG_PUSH
5496             xmlGenericError(xmlGenericErrorContext,
5497                 &quot;HPP: Parsing Comment\n&quot;);
5498 #endif
5499             htmlParseComment(ctxt);
5500             ctxt-&gt;instate = XML_PARSER_MISC;
5501             } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;?&#39;)) {
5502             if ((!terminate) &amp;&amp;
5503                 (htmlParseLookupSequence(ctxt, &#39;&gt;&#39;, 0, 0, 0, 1) &lt; 0))
5504             goto done;
5505 #ifdef DEBUG_PUSH
5506             xmlGenericError(xmlGenericErrorContext,
5507                 &quot;HPP: Parsing PI\n&quot;);
5508 #endif
5509             htmlParsePI(ctxt);
5510             ctxt-&gt;instate = XML_PARSER_MISC;
5511         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
5512             (UPP(2) == &#39;D&#39;) &amp;&amp; (UPP(3) == &#39;O&#39;) &amp;&amp;
5513             (UPP(4) == &#39;C&#39;) &amp;&amp; (UPP(5) == &#39;T&#39;) &amp;&amp;
5514             (UPP(6) == &#39;Y&#39;) &amp;&amp; (UPP(7) == &#39;P&#39;) &amp;&amp;
5515             (UPP(8) == &#39;E&#39;)) {
5516             if ((!terminate) &amp;&amp;
5517                 (htmlParseLookupSequence(ctxt, &#39;&gt;&#39;, 0, 0, 0, 1) &lt; 0))
5518             goto done;
5519 #ifdef DEBUG_PUSH
5520             xmlGenericError(xmlGenericErrorContext,
5521                 &quot;HPP: Parsing internal subset\n&quot;);
5522 #endif
5523             htmlParseDocTypeDecl(ctxt);
5524             ctxt-&gt;instate = XML_PARSER_PROLOG;
5525 #ifdef DEBUG_PUSH
5526             xmlGenericError(xmlGenericErrorContext,
5527                 &quot;HPP: entering PROLOG\n&quot;);
5528 #endif
5529         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
5530                    (avail &lt; 9)) {
5531             goto done;
5532         } else {
5533             ctxt-&gt;instate = XML_PARSER_START_TAG;
5534 #ifdef DEBUG_PUSH
5535             xmlGenericError(xmlGenericErrorContext,
5536                 &quot;HPP: entering START_TAG\n&quot;);
5537 #endif
5538         }
5539         break;
5540             case XML_PARSER_PROLOG:
5541         SKIP_BLANKS;
5542         if (in-&gt;buf == NULL)
5543             avail = in-&gt;length - (in-&gt;cur - in-&gt;base);
5544         else
5545             avail = xmlBufUse(in-&gt;buf-&gt;buffer) - (in-&gt;cur - in-&gt;base);
5546         if (avail &lt; 2)
5547             goto done;
5548         cur = in-&gt;cur[0];
5549         next = in-&gt;cur[1];
5550         if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
5551             (in-&gt;cur[2] == &#39;-&#39;) &amp;&amp; (in-&gt;cur[3] == &#39;-&#39;)) {
5552             if ((!terminate) &amp;&amp;
5553                 (htmlParseLookupSequence(ctxt, &#39;-&#39;, &#39;-&#39;, &#39;&gt;&#39;, 1, 1) &lt; 0))
5554             goto done;
5555 #ifdef DEBUG_PUSH
5556             xmlGenericError(xmlGenericErrorContext,
5557                 &quot;HPP: Parsing Comment\n&quot;);
5558 #endif
5559             htmlParseComment(ctxt);
5560             ctxt-&gt;instate = XML_PARSER_PROLOG;
5561             } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;?&#39;)) {
5562             if ((!terminate) &amp;&amp;
5563                 (htmlParseLookupSequence(ctxt, &#39;&gt;&#39;, 0, 0, 0, 1) &lt; 0))
5564             goto done;
5565 #ifdef DEBUG_PUSH
5566             xmlGenericError(xmlGenericErrorContext,
5567                 &quot;HPP: Parsing PI\n&quot;);
5568 #endif
5569             htmlParsePI(ctxt);
5570             ctxt-&gt;instate = XML_PARSER_PROLOG;
5571         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
5572                    (avail &lt; 4)) {
5573             goto done;
5574         } else {
5575             ctxt-&gt;instate = XML_PARSER_START_TAG;
5576 #ifdef DEBUG_PUSH
5577             xmlGenericError(xmlGenericErrorContext,
5578                 &quot;HPP: entering START_TAG\n&quot;);
5579 #endif
5580         }
5581         break;
5582             case XML_PARSER_EPILOG:
5583         if (in-&gt;buf == NULL)
5584             avail = in-&gt;length - (in-&gt;cur - in-&gt;base);
5585         else
5586             avail = xmlBufUse(in-&gt;buf-&gt;buffer) - (in-&gt;cur - in-&gt;base);
5587         if (avail &lt; 1)
5588             goto done;
5589         cur = in-&gt;cur[0];
5590         if (IS_BLANK_CH(cur)) {
5591             htmlParseCharData(ctxt);
5592             goto done;
5593         }
5594         if (avail &lt; 2)
5595             goto done;
5596         next = in-&gt;cur[1];
5597             if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
5598             (in-&gt;cur[2] == &#39;-&#39;) &amp;&amp; (in-&gt;cur[3] == &#39;-&#39;)) {
5599             if ((!terminate) &amp;&amp;
5600                 (htmlParseLookupSequence(ctxt, &#39;-&#39;, &#39;-&#39;, &#39;&gt;&#39;, 1, 1) &lt; 0))
5601             goto done;
5602 #ifdef DEBUG_PUSH
5603             xmlGenericError(xmlGenericErrorContext,
5604                 &quot;HPP: Parsing Comment\n&quot;);
5605 #endif
5606             htmlParseComment(ctxt);
5607             ctxt-&gt;instate = XML_PARSER_EPILOG;
5608             } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;?&#39;)) {
5609             if ((!terminate) &amp;&amp;
5610                 (htmlParseLookupSequence(ctxt, &#39;&gt;&#39;, 0, 0, 0, 1) &lt; 0))
5611             goto done;
5612 #ifdef DEBUG_PUSH
5613             xmlGenericError(xmlGenericErrorContext,
5614                 &quot;HPP: Parsing PI\n&quot;);
5615 #endif
5616             htmlParsePI(ctxt);
5617             ctxt-&gt;instate = XML_PARSER_EPILOG;
5618         } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
5619                    (avail &lt; 4)) {
5620             goto done;
5621         } else {
5622             ctxt-&gt;errNo = XML_ERR_DOCUMENT_END;
5623             ctxt-&gt;wellFormed = 0;
5624             ctxt-&gt;instate = XML_PARSER_EOF;
5625 #ifdef DEBUG_PUSH
5626             xmlGenericError(xmlGenericErrorContext,
5627                 &quot;HPP: entering EOF\n&quot;);
5628 #endif
5629             if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;endDocument != NULL))
5630             ctxt-&gt;sax-&gt;endDocument(ctxt-&gt;userData);
5631             goto done;
5632         }
5633         break;
5634             case XML_PARSER_START_TAG: {
5635             const xmlChar *name;
5636         int failed;
5637         const htmlElemDesc * info;
5638 
5639         /*
5640          * no chars in buffer
5641          */
5642         if (avail &lt; 1)
5643             goto done;
5644         /*
5645          * not enouth chars in buffer
5646          */
5647         if (avail &lt; 2) {
5648             if (!terminate)
5649             goto done;
5650             else
5651             next = &#39; &#39;;
5652         } else {
5653             next = in-&gt;cur[1];
5654         }
5655         cur = in-&gt;cur[0];
5656             if (cur != &#39;&lt;&#39;) {
5657             ctxt-&gt;instate = XML_PARSER_CONTENT;
5658 #ifdef DEBUG_PUSH
5659             xmlGenericError(xmlGenericErrorContext,
5660                 &quot;HPP: entering CONTENT\n&quot;);
5661 #endif
5662             break;
5663         }
5664         if (next == &#39;/&#39;) {
5665             ctxt-&gt;instate = XML_PARSER_END_TAG;
5666             ctxt-&gt;checkIndex = 0;
5667 #ifdef DEBUG_PUSH
5668             xmlGenericError(xmlGenericErrorContext,
5669                 &quot;HPP: entering END_TAG\n&quot;);
5670 #endif
5671             break;
5672         }
5673         if ((!terminate) &amp;&amp;
5674             (htmlParseLookupSequence(ctxt, &#39;&gt;&#39;, 0, 0, 0, 1) &lt; 0))
5675             goto done;
5676 
5677                 /* Capture start position */
5678             if (ctxt-&gt;record_info) {
5679                  node_info.begin_pos = ctxt-&gt;input-&gt;consumed +
5680                                     (CUR_PTR - ctxt-&gt;input-&gt;base);
5681                  node_info.begin_line = ctxt-&gt;input-&gt;line;
5682             }
5683 
5684 
5685         failed = htmlParseStartTag(ctxt);
5686         name = ctxt-&gt;name;
5687         if ((failed == -1) ||
5688             (name == NULL)) {
5689             if (CUR == &#39;&gt;&#39;)
5690             NEXT;
5691             break;
5692         }
5693 
5694         /*
5695          * Lookup the info for that element.
5696          */
5697         info = htmlTagLookup(name);
5698         if (info == NULL) {
5699             htmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,
5700                          &quot;Tag %s invalid\n&quot;, name, NULL);
5701         }
5702 
5703         /*
5704          * Check for an Empty Element labeled the XML/SGML way
5705          */
5706         if ((CUR == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;)) {
5707             SKIP(2);
5708             if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElement != NULL))
5709             ctxt-&gt;sax-&gt;endElement(ctxt-&gt;userData, name);
5710             htmlnamePop(ctxt);
5711             ctxt-&gt;instate = XML_PARSER_CONTENT;
5712 #ifdef DEBUG_PUSH
5713             xmlGenericError(xmlGenericErrorContext,
5714                 &quot;HPP: entering CONTENT\n&quot;);
5715 #endif
5716             break;
5717         }
5718 
5719         if (CUR == &#39;&gt;&#39;) {
5720             NEXT;
5721         } else {
5722             htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,
5723                          &quot;Couldn&#39;t find end of Start Tag %s\n&quot;,
5724                  name, NULL);
5725 
5726             /*
5727              * end of parsing of this node.
5728              */
5729             if (xmlStrEqual(name, ctxt-&gt;name)) {
5730             nodePop(ctxt);
5731             htmlnamePop(ctxt);
5732             }
5733 
5734             if (ctxt-&gt;record_info)
5735                 htmlNodeInfoPush(ctxt, &amp;node_info);
5736 
5737             ctxt-&gt;instate = XML_PARSER_CONTENT;
5738 #ifdef DEBUG_PUSH
5739             xmlGenericError(xmlGenericErrorContext,
5740                 &quot;HPP: entering CONTENT\n&quot;);
5741 #endif
5742             break;
5743         }
5744 
5745         /*
5746          * Check for an Empty Element from DTD definition
5747          */
5748         if ((info != NULL) &amp;&amp; (info-&gt;empty)) {
5749             if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElement != NULL))
5750             ctxt-&gt;sax-&gt;endElement(ctxt-&gt;userData, name);
5751             htmlnamePop(ctxt);
5752         }
5753 
5754                 if (ctxt-&gt;record_info)
5755                 htmlNodeInfoPush(ctxt, &amp;node_info);
5756 
5757         ctxt-&gt;instate = XML_PARSER_CONTENT;
5758 #ifdef DEBUG_PUSH
5759         xmlGenericError(xmlGenericErrorContext,
5760             &quot;HPP: entering CONTENT\n&quot;);
5761 #endif
5762                 break;
5763         }
5764             case XML_PARSER_CONTENT: {
5765         long cons;
5766                 /*
5767          * Handle preparsed entities and charRef
5768          */
5769         if (ctxt-&gt;token != 0) {
5770             xmlChar chr[2] = { 0 , 0 } ;
5771 
5772             chr[0] = (xmlChar) ctxt-&gt;token;
5773             htmlCheckParagraph(ctxt);
5774             if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;characters != NULL))
5775             ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, chr, 1);
5776             ctxt-&gt;token = 0;
5777             ctxt-&gt;checkIndex = 0;
5778         }
5779         if ((avail == 1) &amp;&amp; (terminate)) {
5780             cur = in-&gt;cur[0];
5781             if ((cur != &#39;&lt;&#39;) &amp;&amp; (cur != &#39;&amp;&#39;)) {
5782             if (ctxt-&gt;sax != NULL) {
5783                 if (IS_BLANK_CH(cur)) {
5784                 if (ctxt-&gt;keepBlanks) {
5785                     if (ctxt-&gt;sax-&gt;characters != NULL)
5786                     ctxt-&gt;sax-&gt;characters(
5787                         ctxt-&gt;userData, &amp;in-&gt;cur[0], 1);
5788                 } else {
5789                     if (ctxt-&gt;sax-&gt;ignorableWhitespace != NULL)
5790                     ctxt-&gt;sax-&gt;ignorableWhitespace(
5791                         ctxt-&gt;userData, &amp;in-&gt;cur[0], 1);
5792                 }
5793                 } else {
5794                 htmlCheckParagraph(ctxt);
5795                 if (ctxt-&gt;sax-&gt;characters != NULL)
5796                     ctxt-&gt;sax-&gt;characters(
5797                         ctxt-&gt;userData, &amp;in-&gt;cur[0], 1);
5798                 }
5799             }
5800             ctxt-&gt;token = 0;
5801             ctxt-&gt;checkIndex = 0;
5802             in-&gt;cur++;
5803             break;
5804             }
5805         }
5806         if (avail &lt; 2)
5807             goto done;
5808         cur = in-&gt;cur[0];
5809         next = in-&gt;cur[1];
5810         cons = ctxt-&gt;nbChars;
5811         if ((xmlStrEqual(ctxt-&gt;name, BAD_CAST&quot;script&quot;)) ||
5812             (xmlStrEqual(ctxt-&gt;name, BAD_CAST&quot;style&quot;))) {
5813             /*
5814              * Handle SCRIPT/STYLE separately
5815              */
5816             if (!terminate) {
5817                 int idx;
5818             xmlChar val;
5819 
5820             idx = htmlParseLookupSequence(ctxt, &#39;&lt;&#39;, &#39;/&#39;, 0, 0, 0);
5821             if (idx &lt; 0)
5822                 goto done;
5823                 val = in-&gt;cur[idx + 2];
5824             if (val == 0) /* bad cut of input */
5825                 goto done;
5826             }
5827             htmlParseScript(ctxt);
5828             if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;/&#39;)) {
5829             ctxt-&gt;instate = XML_PARSER_END_TAG;
5830             ctxt-&gt;checkIndex = 0;
5831 #ifdef DEBUG_PUSH
5832             xmlGenericError(xmlGenericErrorContext,
5833                 &quot;HPP: entering END_TAG\n&quot;);
5834 #endif
5835             break;
5836             }
5837         } else {
5838             /*
5839              * Sometimes DOCTYPE arrives in the middle of the document
5840              */
5841             if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
5842             (UPP(2) == &#39;D&#39;) &amp;&amp; (UPP(3) == &#39;O&#39;) &amp;&amp;
5843             (UPP(4) == &#39;C&#39;) &amp;&amp; (UPP(5) == &#39;T&#39;) &amp;&amp;
5844             (UPP(6) == &#39;Y&#39;) &amp;&amp; (UPP(7) == &#39;P&#39;) &amp;&amp;
5845             (UPP(8) == &#39;E&#39;)) {
5846             if ((!terminate) &amp;&amp;
5847                 (htmlParseLookupSequence(ctxt, &#39;&gt;&#39;, 0, 0, 0, 1) &lt; 0))
5848                 goto done;
5849             htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,
5850                          &quot;Misplaced DOCTYPE declaration\n&quot;,
5851                      BAD_CAST &quot;DOCTYPE&quot; , NULL);
5852             htmlParseDocTypeDecl(ctxt);
5853             } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp;
5854             (in-&gt;cur[2] == &#39;-&#39;) &amp;&amp; (in-&gt;cur[3] == &#39;-&#39;)) {
5855             if ((!terminate) &amp;&amp;
5856                 (htmlParseLookupSequence(
5857                 ctxt, &#39;-&#39;, &#39;-&#39;, &#39;&gt;&#39;, 1, 1) &lt; 0))
5858                 goto done;
5859 #ifdef DEBUG_PUSH
5860             xmlGenericError(xmlGenericErrorContext,
5861                 &quot;HPP: Parsing Comment\n&quot;);
5862 #endif
5863             htmlParseComment(ctxt);
5864             ctxt-&gt;instate = XML_PARSER_CONTENT;
5865             } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;?&#39;)) {
5866             if ((!terminate) &amp;&amp;
5867                 (htmlParseLookupSequence(ctxt, &#39;&gt;&#39;, 0, 0, 0, 1) &lt; 0))
5868                 goto done;
5869 #ifdef DEBUG_PUSH
5870             xmlGenericError(xmlGenericErrorContext,
5871                 &quot;HPP: Parsing PI\n&quot;);
5872 #endif
5873             htmlParsePI(ctxt);
5874             ctxt-&gt;instate = XML_PARSER_CONTENT;
5875             } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;!&#39;) &amp;&amp; (avail &lt; 4)) {
5876             goto done;
5877             } else if ((cur == &#39;&lt;&#39;) &amp;&amp; (next == &#39;/&#39;)) {
5878             ctxt-&gt;instate = XML_PARSER_END_TAG;
5879             ctxt-&gt;checkIndex = 0;
5880 #ifdef DEBUG_PUSH
5881             xmlGenericError(xmlGenericErrorContext,
5882                 &quot;HPP: entering END_TAG\n&quot;);
5883 #endif
5884             break;
5885             } else if (cur == &#39;&lt;&#39;) {
5886             ctxt-&gt;instate = XML_PARSER_START_TAG;
5887             ctxt-&gt;checkIndex = 0;
5888 #ifdef DEBUG_PUSH
5889             xmlGenericError(xmlGenericErrorContext,
5890                 &quot;HPP: entering START_TAG\n&quot;);
5891 #endif
5892             break;
5893             } else if (cur == &#39;&amp;&#39;) {
5894             if ((!terminate) &amp;&amp;
5895                 (htmlParseLookupChars(ctxt,
5896                                                   BAD_CAST &quot;; &gt;/&quot;, 4) &lt; 0))
5897                 goto done;
5898 #ifdef DEBUG_PUSH
5899             xmlGenericError(xmlGenericErrorContext,
5900                 &quot;HPP: Parsing Reference\n&quot;);
5901 #endif
5902             /* TODO: check generation of subtrees if noent !!! */
5903             htmlParseReference(ctxt);
5904             } else {
5905                 /*
5906              * check that the text sequence is complete
5907              * before handing out the data to the parser
5908              * to avoid problems with erroneous end of
5909              * data detection.
5910              */
5911             if ((!terminate) &amp;&amp;
5912                             (htmlParseLookupChars(ctxt, BAD_CAST &quot;&lt;&amp;&quot;, 2) &lt; 0))
5913                 goto done;
5914             ctxt-&gt;checkIndex = 0;
5915 #ifdef DEBUG_PUSH
5916             xmlGenericError(xmlGenericErrorContext,
5917                 &quot;HPP: Parsing char data\n&quot;);
5918 #endif
5919             htmlParseCharData(ctxt);
5920             }
5921         }
5922         if (cons == ctxt-&gt;nbChars) {
5923             if (ctxt-&gt;node != NULL) {
5924             htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
5925                          &quot;detected an error in element content\n&quot;,
5926                      NULL, NULL);
5927             }
5928             NEXT;
5929             break;
5930         }
5931 
5932         break;
5933         }
5934             case XML_PARSER_END_TAG:
5935         if (avail &lt; 2)
5936             goto done;
5937         if ((!terminate) &amp;&amp;
5938             (htmlParseLookupSequence(ctxt, &#39;&gt;&#39;, 0, 0, 0, 1) &lt; 0))
5939             goto done;
5940         htmlParseEndTag(ctxt);
5941         if (ctxt-&gt;nameNr == 0) {
5942             ctxt-&gt;instate = XML_PARSER_EPILOG;
5943         } else {
5944             ctxt-&gt;instate = XML_PARSER_CONTENT;
5945         }
5946         ctxt-&gt;checkIndex = 0;
5947 #ifdef DEBUG_PUSH
5948         xmlGenericError(xmlGenericErrorContext,
5949             &quot;HPP: entering CONTENT\n&quot;);
5950 #endif
5951             break;
5952             case XML_PARSER_CDATA_SECTION:
5953         htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
5954             &quot;HPP: internal error, state == CDATA\n&quot;,
5955                  NULL, NULL);
5956         ctxt-&gt;instate = XML_PARSER_CONTENT;
5957         ctxt-&gt;checkIndex = 0;
5958 #ifdef DEBUG_PUSH
5959         xmlGenericError(xmlGenericErrorContext,
5960             &quot;HPP: entering CONTENT\n&quot;);
5961 #endif
5962         break;
5963             case XML_PARSER_DTD:
5964         htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
5965             &quot;HPP: internal error, state == DTD\n&quot;,
5966                  NULL, NULL);
5967         ctxt-&gt;instate = XML_PARSER_CONTENT;
5968         ctxt-&gt;checkIndex = 0;
5969 #ifdef DEBUG_PUSH
5970         xmlGenericError(xmlGenericErrorContext,
5971             &quot;HPP: entering CONTENT\n&quot;);
5972 #endif
5973         break;
5974             case XML_PARSER_COMMENT:
5975         htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
5976             &quot;HPP: internal error, state == COMMENT\n&quot;,
5977                  NULL, NULL);
5978         ctxt-&gt;instate = XML_PARSER_CONTENT;
5979         ctxt-&gt;checkIndex = 0;
5980 #ifdef DEBUG_PUSH
5981         xmlGenericError(xmlGenericErrorContext,
5982             &quot;HPP: entering CONTENT\n&quot;);
5983 #endif
5984         break;
5985             case XML_PARSER_PI:
5986         htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
5987             &quot;HPP: internal error, state == PI\n&quot;,
5988                  NULL, NULL);
5989         ctxt-&gt;instate = XML_PARSER_CONTENT;
5990         ctxt-&gt;checkIndex = 0;
5991 #ifdef DEBUG_PUSH
5992         xmlGenericError(xmlGenericErrorContext,
5993             &quot;HPP: entering CONTENT\n&quot;);
5994 #endif
5995         break;
5996             case XML_PARSER_ENTITY_DECL:
5997         htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
5998             &quot;HPP: internal error, state == ENTITY_DECL\n&quot;,
5999                  NULL, NULL);
6000         ctxt-&gt;instate = XML_PARSER_CONTENT;
6001         ctxt-&gt;checkIndex = 0;
6002 #ifdef DEBUG_PUSH
6003         xmlGenericError(xmlGenericErrorContext,
6004             &quot;HPP: entering CONTENT\n&quot;);
6005 #endif
6006         break;
6007             case XML_PARSER_ENTITY_VALUE:
6008         htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
6009             &quot;HPP: internal error, state == ENTITY_VALUE\n&quot;,
6010                  NULL, NULL);
6011         ctxt-&gt;instate = XML_PARSER_CONTENT;
6012         ctxt-&gt;checkIndex = 0;
6013 #ifdef DEBUG_PUSH
6014         xmlGenericError(xmlGenericErrorContext,
6015             &quot;HPP: entering DTD\n&quot;);
6016 #endif
6017         break;
6018             case XML_PARSER_ATTRIBUTE_VALUE:
6019         htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
6020             &quot;HPP: internal error, state == ATTRIBUTE_VALUE\n&quot;,
6021                  NULL, NULL);
6022         ctxt-&gt;instate = XML_PARSER_START_TAG;
6023         ctxt-&gt;checkIndex = 0;
6024 #ifdef DEBUG_PUSH
6025         xmlGenericError(xmlGenericErrorContext,
6026             &quot;HPP: entering START_TAG\n&quot;);
6027 #endif
6028         break;
6029         case XML_PARSER_SYSTEM_LITERAL:
6030         htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
6031             &quot;HPP: internal error, state == XML_PARSER_SYSTEM_LITERAL\n&quot;,
6032                  NULL, NULL);
6033         ctxt-&gt;instate = XML_PARSER_CONTENT;
6034         ctxt-&gt;checkIndex = 0;
6035 #ifdef DEBUG_PUSH
6036         xmlGenericError(xmlGenericErrorContext,
6037             &quot;HPP: entering CONTENT\n&quot;);
6038 #endif
6039         break;
6040         case XML_PARSER_IGNORE:
6041         htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
6042             &quot;HPP: internal error, state == XML_PARSER_IGNORE\n&quot;,
6043                  NULL, NULL);
6044         ctxt-&gt;instate = XML_PARSER_CONTENT;
6045         ctxt-&gt;checkIndex = 0;
6046 #ifdef DEBUG_PUSH
6047         xmlGenericError(xmlGenericErrorContext,
6048             &quot;HPP: entering CONTENT\n&quot;);
6049 #endif
6050         break;
6051         case XML_PARSER_PUBLIC_LITERAL:
6052         htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
6053             &quot;HPP: internal error, state == XML_PARSER_LITERAL\n&quot;,
6054                  NULL, NULL);
6055         ctxt-&gt;instate = XML_PARSER_CONTENT;
6056         ctxt-&gt;checkIndex = 0;
6057 #ifdef DEBUG_PUSH
6058         xmlGenericError(xmlGenericErrorContext,
6059             &quot;HPP: entering CONTENT\n&quot;);
6060 #endif
6061         break;
6062 
6063     }
6064     }
6065 done:
6066     if ((avail == 0) &amp;&amp; (terminate)) {
6067     htmlAutoCloseOnEnd(ctxt);
6068     if ((ctxt-&gt;nameNr == 0) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF)) {
6069         /*
6070          * SAX: end of the document processing.
6071          */
6072         ctxt-&gt;instate = XML_PARSER_EOF;
6073         if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;endDocument != NULL))
6074         ctxt-&gt;sax-&gt;endDocument(ctxt-&gt;userData);
6075     }
6076     }
6077     if ((!(ctxt-&gt;options &amp; HTML_PARSE_NODEFDTD)) &amp;&amp; (ctxt-&gt;myDoc != NULL) &amp;&amp;
6078     ((terminate) || (ctxt-&gt;instate == XML_PARSER_EOF) ||
6079      (ctxt-&gt;instate == XML_PARSER_EPILOG))) {
6080     xmlDtdPtr dtd;
6081     dtd = xmlGetIntSubset(ctxt-&gt;myDoc);
6082     if (dtd == NULL)
6083         ctxt-&gt;myDoc-&gt;intSubset =
6084         xmlCreateIntSubset(ctxt-&gt;myDoc, BAD_CAST &quot;html&quot;,
6085             BAD_CAST &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;,
6086             BAD_CAST &quot;http://www.w3.org/TR/REC-html40/loose.dtd&quot;);
6087     }
6088 #ifdef DEBUG_PUSH
6089     xmlGenericError(xmlGenericErrorContext, &quot;HPP: done %d\n&quot;, ret);
6090 #endif
6091     return(ret);
6092 }
6093 
6094 /**
6095  * htmlParseChunk:
6096  * @ctxt:  an HTML parser context
6097  * @chunk:  an char array
6098  * @size:  the size in byte of the chunk
6099  * @terminate:  last chunk indicator
6100  *
6101  * Parse a Chunk of memory
6102  *
6103  * Returns zero if no error, the xmlParserErrors otherwise.
6104  */
6105 int
6106 htmlParseChunk(htmlParserCtxtPtr ctxt, const char *chunk, int size,
6107               int terminate) {
6108     if ((ctxt == NULL) || (ctxt-&gt;input == NULL)) {
6109     htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
6110              &quot;htmlParseChunk: context error\n&quot;, NULL, NULL);
6111     return(XML_ERR_INTERNAL_ERROR);
6112     }
6113     if ((size &gt; 0) &amp;&amp; (chunk != NULL) &amp;&amp; (ctxt-&gt;input != NULL) &amp;&amp;
6114         (ctxt-&gt;input-&gt;buf != NULL) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF))  {
6115     size_t base = xmlBufGetInputBase(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input);
6116     size_t cur = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
6117     int res;
6118 
6119     res = xmlParserInputBufferPush(ctxt-&gt;input-&gt;buf, size, chunk);
6120     if (res &lt; 0) {
6121         ctxt-&gt;errNo = XML_PARSER_EOF;
6122         ctxt-&gt;disableSAX = 1;
6123         return (XML_PARSER_EOF);
6124     }
6125         xmlBufSetInputBaseCur(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input, base, cur);
6126 #ifdef DEBUG_PUSH
6127     xmlGenericError(xmlGenericErrorContext, &quot;HPP: pushed %d\n&quot;, size);
6128 #endif
6129 
6130 #if 0
6131     if ((terminate) || (ctxt-&gt;input-&gt;buf-&gt;buffer-&gt;use &gt; 80))
6132         htmlParseTryOrFinish(ctxt, terminate);
6133 #endif
6134     } else if (ctxt-&gt;instate != XML_PARSER_EOF) {
6135     if ((ctxt-&gt;input != NULL) &amp;&amp; ctxt-&gt;input-&gt;buf != NULL) {
6136         xmlParserInputBufferPtr in = ctxt-&gt;input-&gt;buf;
6137         if ((in-&gt;encoder != NULL) &amp;&amp; (in-&gt;buffer != NULL) &amp;&amp;
6138             (in-&gt;raw != NULL)) {
6139         int nbchars;
6140         size_t base = xmlBufGetInputBase(in-&gt;buffer, ctxt-&gt;input);
6141         size_t current = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
6142 
6143         nbchars = xmlCharEncInput(in, terminate);
6144         if (nbchars &lt; 0) {
6145             htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,
6146                      &quot;encoder error\n&quot;, NULL, NULL);
6147             return(XML_ERR_INVALID_ENCODING);
6148         }
6149         xmlBufSetInputBaseCur(in-&gt;buffer, ctxt-&gt;input, base, current);
6150         }
6151     }
6152     }
6153     htmlParseTryOrFinish(ctxt, terminate);
6154     if (terminate) {
6155     if ((ctxt-&gt;instate != XML_PARSER_EOF) &amp;&amp;
6156         (ctxt-&gt;instate != XML_PARSER_EPILOG) &amp;&amp;
6157         (ctxt-&gt;instate != XML_PARSER_MISC)) {
6158         ctxt-&gt;errNo = XML_ERR_DOCUMENT_END;
6159         ctxt-&gt;wellFormed = 0;
6160     }
6161     if (ctxt-&gt;instate != XML_PARSER_EOF) {
6162         if ((ctxt-&gt;sax) &amp;&amp; (ctxt-&gt;sax-&gt;endDocument != NULL))
6163         ctxt-&gt;sax-&gt;endDocument(ctxt-&gt;userData);
6164     }
6165     ctxt-&gt;instate = XML_PARSER_EOF;
6166     }
6167     return((xmlParserErrors) ctxt-&gt;errNo);
6168 }
6169 
6170 /************************************************************************
6171  *                                  *
6172  *          User entry points               *
6173  *                                  *
6174  ************************************************************************/
6175 
6176 /**
6177  * htmlCreatePushParserCtxt:
6178  * @sax:  a SAX handler
6179  * @user_data:  The user data returned on SAX callbacks
6180  * @chunk:  a pointer to an array of chars
6181  * @size:  number of chars in the array
6182  * @filename:  an optional file name or URI
6183  * @enc:  an optional encoding
6184  *
6185  * Create a parser context for using the HTML parser in push mode
6186  * The value of @filename is used for fetching external entities
6187  * and error/warning reports.
6188  *
6189  * Returns the new parser context or NULL
6190  */
6191 htmlParserCtxtPtr
6192 htmlCreatePushParserCtxt(htmlSAXHandlerPtr sax, void *user_data,
6193                          const char *chunk, int size, const char *filename,
6194              xmlCharEncoding enc) {
6195     htmlParserCtxtPtr ctxt;
6196     htmlParserInputPtr inputStream;
6197     xmlParserInputBufferPtr buf;
6198 
6199     xmlInitParser();
6200 
6201     buf = xmlAllocParserInputBuffer(enc);
6202     if (buf == NULL) return(NULL);
6203 
6204     ctxt = htmlNewParserCtxt();
6205     if (ctxt == NULL) {
6206     xmlFreeParserInputBuffer(buf);
6207     return(NULL);
6208     }
6209     if(enc==XML_CHAR_ENCODING_UTF8 || buf-&gt;encoder)
6210     ctxt-&gt;charset=XML_CHAR_ENCODING_UTF8;
6211     if (sax != NULL) {
6212     if (ctxt-&gt;sax != (xmlSAXHandlerPtr) &amp;htmlDefaultSAXHandler)
6213         xmlFree(ctxt-&gt;sax);
6214     ctxt-&gt;sax = (htmlSAXHandlerPtr) xmlMalloc(sizeof(htmlSAXHandler));
6215     if (ctxt-&gt;sax == NULL) {
6216         xmlFree(buf);
6217         xmlFree(ctxt);
6218         return(NULL);
6219     }
6220     memcpy(ctxt-&gt;sax, sax, sizeof(htmlSAXHandler));
6221     if (user_data != NULL)
6222         ctxt-&gt;userData = user_data;
6223     }
6224     if (filename == NULL) {
6225     ctxt-&gt;directory = NULL;
6226     } else {
6227         ctxt-&gt;directory = xmlParserGetDirectory(filename);
6228     }
6229 
6230     inputStream = htmlNewInputStream(ctxt);
6231     if (inputStream == NULL) {
6232     xmlFreeParserCtxt(ctxt);
6233     xmlFree(buf);
6234     return(NULL);
6235     }
6236 
6237     if (filename == NULL)
6238     inputStream-&gt;filename = NULL;
6239     else
6240     inputStream-&gt;filename = (char *)
6241         xmlCanonicPath((const xmlChar *) filename);
6242     inputStream-&gt;buf = buf;
6243     xmlBufResetInput(buf-&gt;buffer, inputStream);
6244 
6245     inputPush(ctxt, inputStream);
6246 
6247     if ((size &gt; 0) &amp;&amp; (chunk != NULL) &amp;&amp; (ctxt-&gt;input != NULL) &amp;&amp;
6248         (ctxt-&gt;input-&gt;buf != NULL))  {
6249     size_t base = xmlBufGetInputBase(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input);
6250     size_t cur = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
6251 
6252     xmlParserInputBufferPush(ctxt-&gt;input-&gt;buf, size, chunk);
6253 
6254         xmlBufSetInputBaseCur(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input, base, cur);
6255 #ifdef DEBUG_PUSH
6256     xmlGenericError(xmlGenericErrorContext, &quot;HPP: pushed %d\n&quot;, size);
6257 #endif
6258     }
6259     ctxt-&gt;progressive = 1;
6260 
6261     return(ctxt);
6262 }
6263 #endif /* LIBXML_PUSH_ENABLED */
6264 
6265 /**
6266  * htmlSAXParseDoc:
6267  * @cur:  a pointer to an array of xmlChar
6268  * @encoding:  a free form C string describing the HTML document encoding, or NULL
6269  * @sax:  the SAX handler block
6270  * @userData: if using SAX, this pointer will be provided on callbacks.
6271  *
6272  * Parse an HTML in-memory document. If sax is not NULL, use the SAX callbacks
6273  * to handle parse events. If sax is NULL, fallback to the default DOM
6274  * behavior and return a tree.
6275  *
6276  * Returns the resulting document tree unless SAX is NULL or the document is
6277  *     not well formed.
6278  */
6279 
6280 htmlDocPtr
6281 htmlSAXParseDoc(const xmlChar *cur, const char *encoding,
6282                 htmlSAXHandlerPtr sax, void *userData) {
6283     htmlDocPtr ret;
6284     htmlParserCtxtPtr ctxt;
6285 
6286     xmlInitParser();
6287 
6288     if (cur == NULL) return(NULL);
6289 
6290 
6291     ctxt = htmlCreateDocParserCtxt(cur, encoding);
6292     if (ctxt == NULL) return(NULL);
6293     if (sax != NULL) {
6294         if (ctxt-&gt;sax != NULL) xmlFree (ctxt-&gt;sax);
6295         ctxt-&gt;sax = sax;
6296         ctxt-&gt;userData = userData;
6297     }
6298 
6299     htmlParseDocument(ctxt);
6300     ret = ctxt-&gt;myDoc;
6301     if (sax != NULL) {
6302     ctxt-&gt;sax = NULL;
6303     ctxt-&gt;userData = NULL;
6304     }
6305     htmlFreeParserCtxt(ctxt);
6306 
6307     return(ret);
6308 }
6309 
6310 /**
6311  * htmlParseDoc:
6312  * @cur:  a pointer to an array of xmlChar
6313  * @encoding:  a free form C string describing the HTML document encoding, or NULL
6314  *
6315  * parse an HTML in-memory document and build a tree.
6316  *
6317  * Returns the resulting document tree
6318  */
6319 
6320 htmlDocPtr
6321 htmlParseDoc(const xmlChar *cur, const char *encoding) {
6322     return(htmlSAXParseDoc(cur, encoding, NULL, NULL));
6323 }
6324 
6325 
6326 /**
6327  * htmlCreateFileParserCtxt:
6328  * @filename:  the filename
6329  * @encoding:  a free form C string describing the HTML document encoding, or NULL
6330  *
6331  * Create a parser context for a file content.
6332  * Automatic support for ZLIB/Compress compressed document is provided
6333  * by default if found at compile-time.
6334  *
6335  * Returns the new parser context or NULL
6336  */
6337 htmlParserCtxtPtr
6338 htmlCreateFileParserCtxt(const char *filename, const char *encoding)
6339 {
6340     htmlParserCtxtPtr ctxt;
6341     htmlParserInputPtr inputStream;
6342     char *canonicFilename;
6343     /* htmlCharEncoding enc; */
6344     xmlChar *content, *content_line = (xmlChar *) &quot;charset=&quot;;
6345 
6346     if (filename == NULL)
6347         return(NULL);
6348 
6349     ctxt = htmlNewParserCtxt();
6350     if (ctxt == NULL) {
6351     return(NULL);
6352     }
6353     canonicFilename = (char *) xmlCanonicPath((const xmlChar *) filename);
6354     if (canonicFilename == NULL) {
6355 #ifdef LIBXML_SAX1_ENABLED
6356     if (xmlDefaultSAXHandler.error != NULL) {
6357         xmlDefaultSAXHandler.error(NULL, &quot;out of memory\n&quot;);
6358     }
6359 #endif
6360     xmlFreeParserCtxt(ctxt);
6361     return(NULL);
6362     }
6363 
6364     inputStream = xmlLoadExternalEntity(canonicFilename, NULL, ctxt);
6365     xmlFree(canonicFilename);
6366     if (inputStream == NULL) {
6367     xmlFreeParserCtxt(ctxt);
6368     return(NULL);
6369     }
6370 
6371     inputPush(ctxt, inputStream);
6372 
6373     /* set encoding */
6374     if (encoding) {
6375         size_t l = strlen(encoding);
6376 
6377     if (l &lt; 1000) {
6378         content = xmlMallocAtomic (xmlStrlen(content_line) + l + 1);
6379         if (content) {
6380         strcpy ((char *)content, (char *)content_line);
6381         strcat ((char *)content, (char *)encoding);
6382         htmlCheckEncoding (ctxt, content);
6383         xmlFree (content);
6384         }
6385     }
6386     }
6387 
6388     return(ctxt);
6389 }
6390 
6391 /**
6392  * htmlSAXParseFile:
6393  * @filename:  the filename
6394  * @encoding:  a free form C string describing the HTML document encoding, or NULL
6395  * @sax:  the SAX handler block
6396  * @userData: if using SAX, this pointer will be provided on callbacks.
6397  *
6398  * parse an HTML file and build a tree. Automatic support for ZLIB/Compress
6399  * compressed document is provided by default if found at compile-time.
6400  * It use the given SAX function block to handle the parsing callback.
6401  * If sax is NULL, fallback to the default DOM tree building routines.
6402  *
6403  * Returns the resulting document tree unless SAX is NULL or the document is
6404  *     not well formed.
6405  */
6406 
6407 htmlDocPtr
6408 htmlSAXParseFile(const char *filename, const char *encoding, htmlSAXHandlerPtr sax,
6409                  void *userData) {
6410     htmlDocPtr ret;
6411     htmlParserCtxtPtr ctxt;
6412     htmlSAXHandlerPtr oldsax = NULL;
6413 
6414     xmlInitParser();
6415 
6416     ctxt = htmlCreateFileParserCtxt(filename, encoding);
6417     if (ctxt == NULL) return(NULL);
6418     if (sax != NULL) {
6419     oldsax = ctxt-&gt;sax;
6420         ctxt-&gt;sax = sax;
6421         ctxt-&gt;userData = userData;
6422     }
6423 
6424     htmlParseDocument(ctxt);
6425 
6426     ret = ctxt-&gt;myDoc;
6427     if (sax != NULL) {
6428         ctxt-&gt;sax = oldsax;
6429         ctxt-&gt;userData = NULL;
6430     }
6431     htmlFreeParserCtxt(ctxt);
6432 
6433     return(ret);
6434 }
6435 
6436 /**
6437  * htmlParseFile:
6438  * @filename:  the filename
6439  * @encoding:  a free form C string describing the HTML document encoding, or NULL
6440  *
6441  * parse an HTML file and build a tree. Automatic support for ZLIB/Compress
6442  * compressed document is provided by default if found at compile-time.
6443  *
6444  * Returns the resulting document tree
6445  */
6446 
6447 htmlDocPtr
6448 htmlParseFile(const char *filename, const char *encoding) {
6449     return(htmlSAXParseFile(filename, encoding, NULL, NULL));
6450 }
6451 
6452 /**
6453  * htmlHandleOmittedElem:
6454  * @val:  int 0 or 1
6455  *
6456  * Set and return the previous value for handling HTML omitted tags.
6457  *
6458  * Returns the last value for 0 for no handling, 1 for auto insertion.
6459  */
6460 
6461 int
6462 htmlHandleOmittedElem(int val) {
6463     int old = htmlOmittedDefaultValue;
6464 
6465     htmlOmittedDefaultValue = val;
6466     return(old);
6467 }
6468 
6469 /**
6470  * htmlElementAllowedHere:
6471  * @parent: HTML parent element
6472  * @elt: HTML element
6473  *
6474  * Checks whether an HTML element may be a direct child of a parent element.
6475  * Note - doesn&#39;t check for deprecated elements
6476  *
6477  * Returns 1 if allowed; 0 otherwise.
6478  */
6479 int
6480 htmlElementAllowedHere(const htmlElemDesc* parent, const xmlChar* elt) {
6481   const char** p ;
6482 
6483   if ( ! elt || ! parent || ! parent-&gt;subelts )
6484     return 0 ;
6485 
6486   for ( p = parent-&gt;subelts; *p; ++p )
6487     if ( !xmlStrcmp((const xmlChar *)*p, elt) )
6488       return 1 ;
6489 
6490   return 0 ;
6491 }
6492 /**
6493  * htmlElementStatusHere:
6494  * @parent: HTML parent element
6495  * @elt: HTML element
6496  *
6497  * Checks whether an HTML element may be a direct child of a parent element.
6498  * and if so whether it is valid or deprecated.
6499  *
6500  * Returns one of HTML_VALID, HTML_DEPRECATED, HTML_INVALID
6501  */
6502 htmlStatus
6503 htmlElementStatusHere(const htmlElemDesc* parent, const htmlElemDesc* elt) {
6504   if ( ! parent || ! elt )
6505     return HTML_INVALID ;
6506   if ( ! htmlElementAllowedHere(parent, (const xmlChar*) elt-&gt;name ) )
6507     return HTML_INVALID ;
6508 
6509   return ( elt-&gt;dtd == 0 ) ? HTML_VALID : HTML_DEPRECATED ;
6510 }
6511 /**
6512  * htmlAttrAllowed:
6513  * @elt: HTML element
6514  * @attr: HTML attribute
6515  * @legacy: whether to allow deprecated attributes
6516  *
6517  * Checks whether an attribute is valid for an element
6518  * Has full knowledge of Required and Deprecated attributes
6519  *
6520  * Returns one of HTML_REQUIRED, HTML_VALID, HTML_DEPRECATED, HTML_INVALID
6521  */
6522 htmlStatus
6523 htmlAttrAllowed(const htmlElemDesc* elt, const xmlChar* attr, int legacy) {
6524   const char** p ;
6525 
6526   if ( !elt || ! attr )
6527     return HTML_INVALID ;
6528 
6529   if ( elt-&gt;attrs_req )
6530     for ( p = elt-&gt;attrs_req; *p; ++p)
6531       if ( !xmlStrcmp((const xmlChar*)*p, attr) )
6532         return HTML_REQUIRED ;
6533 
6534   if ( elt-&gt;attrs_opt )
6535     for ( p = elt-&gt;attrs_opt; *p; ++p)
6536       if ( !xmlStrcmp((const xmlChar*)*p, attr) )
6537         return HTML_VALID ;
6538 
6539   if ( legacy &amp;&amp; elt-&gt;attrs_depr )
6540     for ( p = elt-&gt;attrs_depr; *p; ++p)
6541       if ( !xmlStrcmp((const xmlChar*)*p, attr) )
6542         return HTML_DEPRECATED ;
6543 
6544   return HTML_INVALID ;
6545 }
6546 /**
6547  * htmlNodeStatus:
6548  * @node: an htmlNodePtr in a tree
6549  * @legacy: whether to allow deprecated elements (YES is faster here
6550  *  for Element nodes)
6551  *
6552  * Checks whether the tree node is valid.  Experimental (the author
6553  *     only uses the HTML enhancements in a SAX parser)
6554  *
6555  * Return: for Element nodes, a return from htmlElementAllowedHere (if
6556  *  legacy allowed) or htmlElementStatusHere (otherwise).
6557  *  for Attribute nodes, a return from htmlAttrAllowed
6558  *  for other nodes, HTML_NA (no checks performed)
6559  */
6560 htmlStatus
6561 htmlNodeStatus(const htmlNodePtr node, int legacy) {
6562   if ( ! node )
6563     return HTML_INVALID ;
6564 
6565   switch ( node-&gt;type ) {
6566     case XML_ELEMENT_NODE:
6567       return legacy
6568     ? ( htmlElementAllowedHere (
6569         htmlTagLookup(node-&gt;parent-&gt;name) , node-&gt;name
6570         ) ? HTML_VALID : HTML_INVALID )
6571     : htmlElementStatusHere(
6572         htmlTagLookup(node-&gt;parent-&gt;name) ,
6573         htmlTagLookup(node-&gt;name) )
6574     ;
6575     case XML_ATTRIBUTE_NODE:
6576       return htmlAttrAllowed(
6577     htmlTagLookup(node-&gt;parent-&gt;name) , node-&gt;name, legacy) ;
6578     default: return HTML_NA ;
6579   }
6580 }
6581 /************************************************************************
6582  *                                  *
6583  *  New set (2.6.0) of simpler and more flexible APIs       *
6584  *                                  *
6585  ************************************************************************/
6586 /**
6587  * DICT_FREE:
6588  * @str:  a string
6589  *
6590  * Free a string if it is not owned by the &quot;dict&quot; dictionary in the
6591  * current scope
6592  */
6593 #define DICT_FREE(str)                      \
6594     if ((str) &amp;&amp; ((!dict) ||                \
6595         (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))  \
6596         xmlFree((char *)(str));
6597 
6598 /**
6599  * htmlCtxtReset:
6600  * @ctxt: an HTML parser context
6601  *
6602  * Reset a parser context
6603  */
6604 void
6605 htmlCtxtReset(htmlParserCtxtPtr ctxt)
6606 {
6607     xmlParserInputPtr input;
6608     xmlDictPtr dict;
6609 
6610     if (ctxt == NULL)
6611         return;
6612 
6613     xmlInitParser();
6614     dict = ctxt-&gt;dict;
6615 
6616     while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */
6617         xmlFreeInputStream(input);
6618     }
6619     ctxt-&gt;inputNr = 0;
6620     ctxt-&gt;input = NULL;
6621 
6622     ctxt-&gt;spaceNr = 0;
6623     if (ctxt-&gt;spaceTab != NULL) {
6624     ctxt-&gt;spaceTab[0] = -1;
6625     ctxt-&gt;space = &amp;ctxt-&gt;spaceTab[0];
6626     } else {
6627     ctxt-&gt;space = NULL;
6628     }
6629 
6630 
6631     ctxt-&gt;nodeNr = 0;
6632     ctxt-&gt;node = NULL;
6633 
6634     ctxt-&gt;nameNr = 0;
6635     ctxt-&gt;name = NULL;
6636 
6637     DICT_FREE(ctxt-&gt;version);
6638     ctxt-&gt;version = NULL;
6639     DICT_FREE(ctxt-&gt;encoding);
6640     ctxt-&gt;encoding = NULL;
6641     DICT_FREE(ctxt-&gt;directory);
6642     ctxt-&gt;directory = NULL;
6643     DICT_FREE(ctxt-&gt;extSubURI);
6644     ctxt-&gt;extSubURI = NULL;
6645     DICT_FREE(ctxt-&gt;extSubSystem);
6646     ctxt-&gt;extSubSystem = NULL;
6647     if (ctxt-&gt;myDoc != NULL)
6648         xmlFreeDoc(ctxt-&gt;myDoc);
6649     ctxt-&gt;myDoc = NULL;
6650 
6651     ctxt-&gt;standalone = -1;
6652     ctxt-&gt;hasExternalSubset = 0;
6653     ctxt-&gt;hasPErefs = 0;
6654     ctxt-&gt;html = 1;
6655     ctxt-&gt;external = 0;
6656     ctxt-&gt;instate = XML_PARSER_START;
6657     ctxt-&gt;token = 0;
6658 
6659     ctxt-&gt;wellFormed = 1;
6660     ctxt-&gt;nsWellFormed = 1;
6661     ctxt-&gt;disableSAX = 0;
6662     ctxt-&gt;valid = 1;
6663     ctxt-&gt;vctxt.userData = ctxt;
6664     ctxt-&gt;vctxt.error = xmlParserValidityError;
6665     ctxt-&gt;vctxt.warning = xmlParserValidityWarning;
6666     ctxt-&gt;record_info = 0;
6667     ctxt-&gt;nbChars = 0;
6668     ctxt-&gt;checkIndex = 0;
6669     ctxt-&gt;inSubset = 0;
6670     ctxt-&gt;errNo = XML_ERR_OK;
6671     ctxt-&gt;depth = 0;
6672     ctxt-&gt;charset = XML_CHAR_ENCODING_NONE;
6673     ctxt-&gt;catalogs = NULL;
6674     xmlInitNodeInfoSeq(&amp;ctxt-&gt;node_seq);
6675 
6676     if (ctxt-&gt;attsDefault != NULL) {
6677         xmlHashFree(ctxt-&gt;attsDefault, xmlHashDefaultDeallocator);
6678         ctxt-&gt;attsDefault = NULL;
6679     }
6680     if (ctxt-&gt;attsSpecial != NULL) {
6681         xmlHashFree(ctxt-&gt;attsSpecial, NULL);
6682         ctxt-&gt;attsSpecial = NULL;
6683     }
6684 }
6685 
6686 /**
6687  * htmlCtxtUseOptions:
6688  * @ctxt: an HTML parser context
6689  * @options:  a combination of htmlParserOption(s)
6690  *
6691  * Applies the options to the parser context
6692  *
6693  * Returns 0 in case of success, the set of unknown or unimplemented options
6694  *         in case of error.
6695  */
6696 int
6697 htmlCtxtUseOptions(htmlParserCtxtPtr ctxt, int options)
6698 {
6699     if (ctxt == NULL)
6700         return(-1);
6701 
6702     if (options &amp; HTML_PARSE_NOWARNING) {
6703         ctxt-&gt;sax-&gt;warning = NULL;
6704         ctxt-&gt;vctxt.warning = NULL;
6705         options -= XML_PARSE_NOWARNING;
6706     ctxt-&gt;options |= XML_PARSE_NOWARNING;
6707     }
6708     if (options &amp; HTML_PARSE_NOERROR) {
6709         ctxt-&gt;sax-&gt;error = NULL;
6710         ctxt-&gt;vctxt.error = NULL;
6711         ctxt-&gt;sax-&gt;fatalError = NULL;
6712         options -= XML_PARSE_NOERROR;
6713     ctxt-&gt;options |= XML_PARSE_NOERROR;
6714     }
6715     if (options &amp; HTML_PARSE_PEDANTIC) {
6716         ctxt-&gt;pedantic = 1;
6717         options -= XML_PARSE_PEDANTIC;
6718     ctxt-&gt;options |= XML_PARSE_PEDANTIC;
6719     } else
6720         ctxt-&gt;pedantic = 0;
6721     if (options &amp; XML_PARSE_NOBLANKS) {
6722         ctxt-&gt;keepBlanks = 0;
6723         ctxt-&gt;sax-&gt;ignorableWhitespace = xmlSAX2IgnorableWhitespace;
6724         options -= XML_PARSE_NOBLANKS;
6725     ctxt-&gt;options |= XML_PARSE_NOBLANKS;
6726     } else
6727         ctxt-&gt;keepBlanks = 1;
6728     if (options &amp; HTML_PARSE_RECOVER) {
6729         ctxt-&gt;recovery = 1;
6730     options -= HTML_PARSE_RECOVER;
6731     } else
6732         ctxt-&gt;recovery = 0;
6733     if (options &amp; HTML_PARSE_COMPACT) {
6734     ctxt-&gt;options |= HTML_PARSE_COMPACT;
6735         options -= HTML_PARSE_COMPACT;
6736     }
6737     if (options &amp; XML_PARSE_HUGE) {
6738     ctxt-&gt;options |= XML_PARSE_HUGE;
6739         options -= XML_PARSE_HUGE;
6740     }
6741     if (options &amp; HTML_PARSE_NODEFDTD) {
6742     ctxt-&gt;options |= HTML_PARSE_NODEFDTD;
6743         options -= HTML_PARSE_NODEFDTD;
6744     }
6745     if (options &amp; HTML_PARSE_IGNORE_ENC) {
6746     ctxt-&gt;options |= HTML_PARSE_IGNORE_ENC;
6747         options -= HTML_PARSE_IGNORE_ENC;
6748     }
6749     if (options &amp; HTML_PARSE_NOIMPLIED) {
6750         ctxt-&gt;options |= HTML_PARSE_NOIMPLIED;
6751         options -= HTML_PARSE_NOIMPLIED;
6752     }
6753     ctxt-&gt;dictNames = 0;
6754     return (options);
6755 }
6756 
6757 /**
6758  * htmlDoRead:
6759  * @ctxt:  an HTML parser context
6760  * @URL:  the base URL to use for the document
6761  * @encoding:  the document encoding, or NULL
6762  * @options:  a combination of htmlParserOption(s)
6763  * @reuse:  keep the context for reuse
6764  *
6765  * Common front-end for the htmlRead functions
6766  *
6767  * Returns the resulting document tree or NULL
6768  */
6769 static htmlDocPtr
6770 htmlDoRead(htmlParserCtxtPtr ctxt, const char *URL, const char *encoding,
6771           int options, int reuse)
6772 {
6773     htmlDocPtr ret;
6774 
6775     htmlCtxtUseOptions(ctxt, options);
6776     ctxt-&gt;html = 1;
6777     if (encoding != NULL) {
6778         xmlCharEncodingHandlerPtr hdlr;
6779 
6780     hdlr = xmlFindCharEncodingHandler(encoding);
6781     if (hdlr != NULL) {
6782         xmlSwitchToEncoding(ctxt, hdlr);
6783         if (ctxt-&gt;input-&gt;encoding != NULL)
6784           xmlFree((xmlChar *) ctxt-&gt;input-&gt;encoding);
6785             ctxt-&gt;input-&gt;encoding = xmlStrdup((xmlChar *)encoding);
6786         }
6787     }
6788     if ((URL != NULL) &amp;&amp; (ctxt-&gt;input != NULL) &amp;&amp;
6789         (ctxt-&gt;input-&gt;filename == NULL))
6790         ctxt-&gt;input-&gt;filename = (char *) xmlStrdup((const xmlChar *) URL);
6791     htmlParseDocument(ctxt);
6792     ret = ctxt-&gt;myDoc;
6793     ctxt-&gt;myDoc = NULL;
6794     if (!reuse) {
6795         if ((ctxt-&gt;dictNames) &amp;&amp;
6796         (ret != NULL) &amp;&amp;
6797         (ret-&gt;dict == ctxt-&gt;dict))
6798         ctxt-&gt;dict = NULL;
6799     xmlFreeParserCtxt(ctxt);
6800     }
6801     return (ret);
6802 }
6803 
6804 /**
6805  * htmlReadDoc:
6806  * @cur:  a pointer to a zero terminated string
6807  * @URL:  the base URL to use for the document
6808  * @encoding:  the document encoding, or NULL
6809  * @options:  a combination of htmlParserOption(s)
6810  *
6811  * parse an XML in-memory document and build a tree.
6812  *
6813  * Returns the resulting document tree
6814  */
6815 htmlDocPtr
6816 htmlReadDoc(const xmlChar * cur, const char *URL, const char *encoding, int options)
6817 {
6818     htmlParserCtxtPtr ctxt;
6819 
6820     if (cur == NULL)
6821         return (NULL);
6822 
6823     xmlInitParser();
6824     ctxt = htmlCreateDocParserCtxt(cur, NULL);
6825     if (ctxt == NULL)
6826         return (NULL);
6827     return (htmlDoRead(ctxt, URL, encoding, options, 0));
6828 }
6829 
6830 /**
6831  * htmlReadFile:
6832  * @filename:  a file or URL
6833  * @encoding:  the document encoding, or NULL
6834  * @options:  a combination of htmlParserOption(s)
6835  *
6836  * parse an XML file from the filesystem or the network.
6837  *
6838  * Returns the resulting document tree
6839  */
6840 htmlDocPtr
6841 htmlReadFile(const char *filename, const char *encoding, int options)
6842 {
6843     htmlParserCtxtPtr ctxt;
6844 
6845     xmlInitParser();
6846     ctxt = htmlCreateFileParserCtxt(filename, encoding);
6847     if (ctxt == NULL)
6848         return (NULL);
6849     return (htmlDoRead(ctxt, NULL, NULL, options, 0));
6850 }
6851 
6852 /**
6853  * htmlReadMemory:
6854  * @buffer:  a pointer to a char array
6855  * @size:  the size of the array
6856  * @URL:  the base URL to use for the document
6857  * @encoding:  the document encoding, or NULL
6858  * @options:  a combination of htmlParserOption(s)
6859  *
6860  * parse an XML in-memory document and build a tree.
6861  *
6862  * Returns the resulting document tree
6863  */
6864 htmlDocPtr
6865 htmlReadMemory(const char *buffer, int size, const char *URL, const char *encoding, int options)
6866 {
6867     htmlParserCtxtPtr ctxt;
6868 
6869     xmlInitParser();
6870     ctxt = xmlCreateMemoryParserCtxt(buffer, size);
6871     if (ctxt == NULL)
6872         return (NULL);
6873     htmlDefaultSAXHandlerInit();
6874     if (ctxt-&gt;sax != NULL)
6875         memcpy(ctxt-&gt;sax, &amp;htmlDefaultSAXHandler, sizeof(xmlSAXHandlerV1));
6876     return (htmlDoRead(ctxt, URL, encoding, options, 0));
6877 }
6878 
6879 /**
6880  * htmlReadFd:
6881  * @fd:  an open file descriptor
6882  * @URL:  the base URL to use for the document
6883  * @encoding:  the document encoding, or NULL
6884  * @options:  a combination of htmlParserOption(s)
6885  *
6886  * parse an XML from a file descriptor and build a tree.
6887  *
6888  * Returns the resulting document tree
6889  */
6890 htmlDocPtr
6891 htmlReadFd(int fd, const char *URL, const char *encoding, int options)
6892 {
6893     htmlParserCtxtPtr ctxt;
6894     xmlParserInputBufferPtr input;
6895     xmlParserInputPtr stream;
6896 
6897     if (fd &lt; 0)
6898         return (NULL);
6899     xmlInitParser();
6900 
6901     xmlInitParser();
6902     input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
6903     if (input == NULL)
6904         return (NULL);
6905     ctxt = xmlNewParserCtxt();
6906     if (ctxt == NULL) {
6907         xmlFreeParserInputBuffer(input);
6908         return (NULL);
6909     }
6910     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
6911     if (stream == NULL) {
6912         xmlFreeParserInputBuffer(input);
6913     xmlFreeParserCtxt(ctxt);
6914         return (NULL);
6915     }
6916     inputPush(ctxt, stream);
6917     return (htmlDoRead(ctxt, URL, encoding, options, 0));
6918 }
6919 
6920 /**
6921  * htmlReadIO:
6922  * @ioread:  an I/O read function
6923  * @ioclose:  an I/O close function
6924  * @ioctx:  an I/O handler
6925  * @URL:  the base URL to use for the document
6926  * @encoding:  the document encoding, or NULL
6927  * @options:  a combination of htmlParserOption(s)
6928  *
6929  * parse an HTML document from I/O functions and source and build a tree.
6930  *
6931  * Returns the resulting document tree
6932  */
6933 htmlDocPtr
6934 htmlReadIO(xmlInputReadCallback ioread, xmlInputCloseCallback ioclose,
6935           void *ioctx, const char *URL, const char *encoding, int options)
6936 {
6937     htmlParserCtxtPtr ctxt;
6938     xmlParserInputBufferPtr input;
6939     xmlParserInputPtr stream;
6940 
6941     if (ioread == NULL)
6942         return (NULL);
6943     xmlInitParser();
6944 
6945     input = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx,
6946                                          XML_CHAR_ENCODING_NONE);
6947     if (input == NULL) {
6948         if (ioclose != NULL)
6949             ioclose(ioctx);
6950         return (NULL);
6951     }
6952     ctxt = htmlNewParserCtxt();
6953     if (ctxt == NULL) {
6954         xmlFreeParserInputBuffer(input);
6955         return (NULL);
6956     }
6957     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
6958     if (stream == NULL) {
6959         xmlFreeParserInputBuffer(input);
6960     xmlFreeParserCtxt(ctxt);
6961         return (NULL);
6962     }
6963     inputPush(ctxt, stream);
6964     return (htmlDoRead(ctxt, URL, encoding, options, 0));
6965 }
6966 
6967 /**
6968  * htmlCtxtReadDoc:
6969  * @ctxt:  an HTML parser context
6970  * @cur:  a pointer to a zero terminated string
6971  * @URL:  the base URL to use for the document
6972  * @encoding:  the document encoding, or NULL
6973  * @options:  a combination of htmlParserOption(s)
6974  *
6975  * parse an XML in-memory document and build a tree.
6976  * This reuses the existing @ctxt parser context
6977  *
6978  * Returns the resulting document tree
6979  */
6980 htmlDocPtr
6981 htmlCtxtReadDoc(htmlParserCtxtPtr ctxt, const xmlChar * cur,
6982                const char *URL, const char *encoding, int options)
6983 {
6984     xmlParserInputPtr stream;
6985 
6986     if (cur == NULL)
6987         return (NULL);
6988     if (ctxt == NULL)
6989         return (NULL);
6990     xmlInitParser();
6991 
6992     htmlCtxtReset(ctxt);
6993 
6994     stream = xmlNewStringInputStream(ctxt, cur);
6995     if (stream == NULL) {
6996         return (NULL);
6997     }
6998     inputPush(ctxt, stream);
6999     return (htmlDoRead(ctxt, URL, encoding, options, 1));
7000 }
7001 
7002 /**
7003  * htmlCtxtReadFile:
7004  * @ctxt:  an HTML parser context
7005  * @filename:  a file or URL
7006  * @encoding:  the document encoding, or NULL
7007  * @options:  a combination of htmlParserOption(s)
7008  *
7009  * parse an XML file from the filesystem or the network.
7010  * This reuses the existing @ctxt parser context
7011  *
7012  * Returns the resulting document tree
7013  */
7014 htmlDocPtr
7015 htmlCtxtReadFile(htmlParserCtxtPtr ctxt, const char *filename,
7016                 const char *encoding, int options)
7017 {
7018     xmlParserInputPtr stream;
7019 
7020     if (filename == NULL)
7021         return (NULL);
7022     if (ctxt == NULL)
7023         return (NULL);
7024     xmlInitParser();
7025 
7026     htmlCtxtReset(ctxt);
7027 
7028     stream = xmlLoadExternalEntity(filename, NULL, ctxt);
7029     if (stream == NULL) {
7030         return (NULL);
7031     }
7032     inputPush(ctxt, stream);
7033     return (htmlDoRead(ctxt, NULL, encoding, options, 1));
7034 }
7035 
7036 /**
7037  * htmlCtxtReadMemory:
7038  * @ctxt:  an HTML parser context
7039  * @buffer:  a pointer to a char array
7040  * @size:  the size of the array
7041  * @URL:  the base URL to use for the document
7042  * @encoding:  the document encoding, or NULL
7043  * @options:  a combination of htmlParserOption(s)
7044  *
7045  * parse an XML in-memory document and build a tree.
7046  * This reuses the existing @ctxt parser context
7047  *
7048  * Returns the resulting document tree
7049  */
7050 htmlDocPtr
7051 htmlCtxtReadMemory(htmlParserCtxtPtr ctxt, const char *buffer, int size,
7052                   const char *URL, const char *encoding, int options)
7053 {
7054     xmlParserInputBufferPtr input;
7055     xmlParserInputPtr stream;
7056 
7057     if (ctxt == NULL)
7058         return (NULL);
7059     if (buffer == NULL)
7060         return (NULL);
7061     xmlInitParser();
7062 
7063     htmlCtxtReset(ctxt);
7064 
7065     input = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
7066     if (input == NULL) {
7067     return(NULL);
7068     }
7069 
7070     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
7071     if (stream == NULL) {
7072     xmlFreeParserInputBuffer(input);
7073     return(NULL);
7074     }
7075 
7076     inputPush(ctxt, stream);
7077     return (htmlDoRead(ctxt, URL, encoding, options, 1));
7078 }
7079 
7080 /**
7081  * htmlCtxtReadFd:
7082  * @ctxt:  an HTML parser context
7083  * @fd:  an open file descriptor
7084  * @URL:  the base URL to use for the document
7085  * @encoding:  the document encoding, or NULL
7086  * @options:  a combination of htmlParserOption(s)
7087  *
7088  * parse an XML from a file descriptor and build a tree.
7089  * This reuses the existing @ctxt parser context
7090  *
7091  * Returns the resulting document tree
7092  */
7093 htmlDocPtr
7094 htmlCtxtReadFd(htmlParserCtxtPtr ctxt, int fd,
7095               const char *URL, const char *encoding, int options)
7096 {
7097     xmlParserInputBufferPtr input;
7098     xmlParserInputPtr stream;
7099 
7100     if (fd &lt; 0)
7101         return (NULL);
7102     if (ctxt == NULL)
7103         return (NULL);
7104     xmlInitParser();
7105 
7106     htmlCtxtReset(ctxt);
7107 
7108 
7109     input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);
7110     if (input == NULL)
7111         return (NULL);
7112     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
7113     if (stream == NULL) {
7114         xmlFreeParserInputBuffer(input);
7115         return (NULL);
7116     }
7117     inputPush(ctxt, stream);
7118     return (htmlDoRead(ctxt, URL, encoding, options, 1));
7119 }
7120 
7121 /**
7122  * htmlCtxtReadIO:
7123  * @ctxt:  an HTML parser context
7124  * @ioread:  an I/O read function
7125  * @ioclose:  an I/O close function
7126  * @ioctx:  an I/O handler
7127  * @URL:  the base URL to use for the document
7128  * @encoding:  the document encoding, or NULL
7129  * @options:  a combination of htmlParserOption(s)
7130  *
7131  * parse an HTML document from I/O functions and source and build a tree.
7132  * This reuses the existing @ctxt parser context
7133  *
7134  * Returns the resulting document tree
7135  */
7136 htmlDocPtr
7137 htmlCtxtReadIO(htmlParserCtxtPtr ctxt, xmlInputReadCallback ioread,
7138               xmlInputCloseCallback ioclose, void *ioctx,
7139           const char *URL,
7140               const char *encoding, int options)
7141 {
7142     xmlParserInputBufferPtr input;
7143     xmlParserInputPtr stream;
7144 
7145     if (ioread == NULL)
7146         return (NULL);
7147     if (ctxt == NULL)
7148         return (NULL);
7149     xmlInitParser();
7150 
7151     htmlCtxtReset(ctxt);
7152 
7153     input = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx,
7154                                          XML_CHAR_ENCODING_NONE);
7155     if (input == NULL) {
7156         if (ioclose != NULL)
7157             ioclose(ioctx);
7158         return (NULL);
7159     }
7160     stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);
7161     if (stream == NULL) {
7162         xmlFreeParserInputBuffer(input);
7163         return (NULL);
7164     }
7165     inputPush(ctxt, stream);
7166     return (htmlDoRead(ctxt, URL, encoding, options, 1));
7167 }
7168 
7169 #define bottom_HTMLparser
7170 #include &quot;elfgcchack.h&quot;
7171 #endif /* LIBXML_HTML_ENABLED */
    </pre>
  </body>
</html>
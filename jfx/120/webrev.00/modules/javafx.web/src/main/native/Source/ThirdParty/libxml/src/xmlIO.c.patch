diff a/modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/xmlIO.c b/modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/xmlIO.c
--- a/modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/xmlIO.c
+++ b/modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/xmlIO.c
@@ -183,13 +183,13 @@
     "loading error",
     "not a socket",     /* ENOTSOCK */
     "already connected",    /* EISCONN */
     "connection refused",   /* ECONNREFUSED */
     "unreachable network",  /* ENETUNREACH */
-    "adddress in use",      /* EADDRINUSE */
+    "address in use",       /* EADDRINUSE */
     "already in use",       /* EALREADY */
-    "unknown address familly",  /* EAFNOSUPPORT */
+    "unknown address family",   /* EAFNOSUPPORT */
 };
 
 #if defined(_WIN32) || defined (__DJGPP__) && !defined (__CYGWIN__)
 /**
  * __xmlIOWin32UTF8ToWChar:
@@ -2381,10 +2381,11 @@
 
     ret->encoder = encoder;
     if (encoder != NULL) {
         ret->conv = xmlBufCreateSize(4000);
     if (ret->conv == NULL) {
+            xmlBufFree(ret->buffer);
         xmlFree(ret);
         return(NULL);
     }
 
     /*
@@ -2433,10 +2434,11 @@
 
     ret->encoder = encoder;
     if (encoder != NULL) {
         ret->conv = xmlBufCreateSize(4000);
     if (ret->conv == NULL) {
+            xmlBufFree(ret->buffer);
         xmlFree(ret);
         return(NULL);
     }
 
     /*
@@ -3333,11 +3335,11 @@
 int
 xmlOutputBufferWrite(xmlOutputBufferPtr out, int len, const char *buf) {
     int nbchars = 0; /* number of chars to output to I/O */
     int ret;         /* return from function call */
     int written = 0; /* number of char written to I/O so far */
-    int chunk;       /* number of byte curreent processed from buf */
+    int chunk;       /* number of byte current processed from buf */
 
     if ((out == NULL) || (out->error)) return(-1);
     if (len < 0) return(0);
     if (out->error) return(-1);
 
@@ -3370,24 +3372,30 @@
         if ((ret < 0) && (ret != -3)) {
         xmlIOErr(XML_IO_ENCODER, NULL);
         out->error = XML_IO_ENCODER;
         return(-1);
         }
+            if (out->writecallback)
         nbchars = xmlBufUse(out->conv);
+            else
+                nbchars = ret;
     } else {
         ret = xmlBufAdd(out->buffer, (const xmlChar *) buf, chunk);
         if (ret != 0)
             return(-1);
+            if (out->writecallback)
         nbchars = xmlBufUse(out->buffer);
+            else
+                nbchars = chunk;
     }
     buf += chunk;
     len -= chunk;
 
+    if (out->writecallback) {
     if ((nbchars < MINLEN) && (len <= 0))
         goto done;
 
-    if (out->writecallback) {
         /*
          * second write the stuff to the I/O channel
          */
         if (out->encoder != NULL) {
         ret = out->writecallback(out->context,
@@ -3403,10 +3411,13 @@
         if (ret < 0) {
         xmlIOErr(XML_IO_WRITE, NULL);
         out->error = XML_IO_WRITE;
         return(ret);
         }
+            if (out->written > INT_MAX - ret)
+                out->written = INT_MAX;
+            else
         out->written += ret;
     }
     written += nbchars;
     } while (len > 0);
 
@@ -3483,11 +3494,11 @@
  * @out:  a buffered parser output
  * @str:  a zero terminated UTF-8 string
  * @escaping:  an optional escaping function (or NULL)
  *
  * Write the content of the string in the output I/O buffer
- * This routine escapes the caracters and then handle the I18N
+ * This routine escapes the characters and then handle the I18N
  * transcoding from internal UTF-8
  * The buffer is lossless, i.e. will store in case of partial
  * or delayed writes.
  *
  * Returns the number of chars immediately written, or -1
@@ -3559,25 +3570,31 @@
         if ((ret < 0) && (ret != -3)) {
         xmlIOErr(XML_IO_ENCODER, NULL);
         out->error = XML_IO_ENCODER;
         return(-1);
         }
+            if (out->writecallback)
         nbchars = xmlBufUse(out->conv);
+            else
+                nbchars = ret;
     } else {
         ret = escaping(xmlBufEnd(out->buffer), &chunk, str, &cons);
         if ((ret < 0) || (chunk == 0)) /* chunk==0 => nothing done */
             return(-1);
             xmlBufAddLen(out->buffer, chunk);
+            if (out->writecallback)
         nbchars = xmlBufUse(out->buffer);
+            else
+                nbchars = chunk;
     }
     str += cons;
     len -= cons;
 
+    if (out->writecallback) {
     if ((nbchars < MINLEN) && (len <= 0))
         goto done;
 
-    if (out->writecallback) {
         /*
          * second write the stuff to the I/O channel
          */
         if (out->encoder != NULL) {
         ret = out->writecallback(out->context,
@@ -3593,10 +3610,13 @@
         if (ret < 0) {
         xmlIOErr(XML_IO_WRITE, NULL);
         out->error = XML_IO_WRITE;
         return(ret);
         }
+            if (out->written > INT_MAX - ret)
+                out->written = INT_MAX;
+            else
         out->written += ret;
     } else if (xmlBufAvail(out->buffer) < MINLEN) {
         xmlBufGrow(out->buffer, MINLEN);
     }
     written += nbchars;
@@ -3687,10 +3707,13 @@
     if (ret < 0) {
     xmlIOErr(XML_IO_FLUSH, NULL);
     out->error = XML_IO_FLUSH;
     return(ret);
     }
+    if (out->written > INT_MAX - ret)
+        out->written = INT_MAX;
+    else
     out->written += ret;
 
 #ifdef DEBUG_INPUT
     xmlGenericError(xmlGenericErrorContext,
         "I/O: flushed %d chars\n", ret);
@@ -3935,11 +3958,11 @@
  * xmlDefaultExternalEntityLoader:
  * @URL:  the URL for the entity to load
  * @ID:  the System ID for the entity to load
  * @ctxt:  the context in which the entity is called or NULL
  *
- * By default we don't load external entitites, yet.
+ * By default we don't load external entities, yet.
  *
  * Returns a new allocated xmlParserInputPtr, or NULL.
  */
 static xmlParserInputPtr
 xmlDefaultExternalEntityLoader(const char *URL, const char *ID,

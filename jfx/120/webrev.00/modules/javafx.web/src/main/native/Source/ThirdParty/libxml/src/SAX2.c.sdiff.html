<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/SAX2.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="README.zOS.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="aclocal.m4.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/SAX2.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  23 #include &lt;libxml/debugXML.h&gt;
  24 #include &lt;libxml/xmlIO.h&gt;
  25 #include &lt;libxml/SAX.h&gt;
  26 #include &lt;libxml/uri.h&gt;
  27 #include &lt;libxml/valid.h&gt;
  28 #include &lt;libxml/HTMLtree.h&gt;
  29 #include &lt;libxml/globals.h&gt;
  30 
  31 /* Define SIZE_T_MAX unless defined through &lt;limits.h&gt;. */
  32 #ifndef SIZE_T_MAX
  33 # define SIZE_T_MAX     ((size_t)-1)
  34 #endif /* !SIZE_T_MAX */
  35 
  36 /* #define DEBUG_SAX2 */
  37 /* #define DEBUG_SAX2_TREE */
  38 
  39 /**
  40  * TODO:
  41  *
  42  * macro to flag unimplemented blocks
<span class="line-modified">  43  * XML_CATALOG_PREFER user env to select between system/public prefered</span>
  44  * option. C.f. Richard Tobin &lt;richard@cogsci.ed.ac.uk&gt;
  45  *&gt; Just FYI, I am using an environment variable XML_CATALOG_PREFER with
  46  *&gt; values &quot;system&quot; and &quot;public&quot;.  I have made the default be &quot;system&quot; to
  47  *&gt; match yours.
  48  */
  49 #define TODO                                \
  50     xmlGenericError(xmlGenericErrorContext,             \
  51         &quot;Unimplemented block at %s:%d\n&quot;,               \
  52             __FILE__, __LINE__);
  53 
  54 /*
  55  * xmlSAX2ErrMemory:
  56  * @ctxt:  an XML validation parser context
  57  * @msg:   a string to accompany the error message
  58  */
  59 static void LIBXML_ATTR_FORMAT(2,0)
  60 xmlSAX2ErrMemory(xmlParserCtxtPtr ctxt, const char *msg) {
  61     xmlStructuredErrorFunc schannel = NULL;
  62     const char *str1 = &quot;out of memory\n&quot;;
  63 
</pre>
<hr />
<pre>
1495             }
1496             }
1497             if (att == NULL) {
1498                 xmlErrValid(ctxt, XML_DTD_STANDALONE_DEFAULTED,
1499       &quot;standalone: attribute %s on %s defaulted from external subset\n&quot;,
1500                     (const char *)fulln,
1501                     (const char *)attr-&gt;elem);
1502             }
1503                     xmlFree(fulln);
1504         }
1505         attr = attr-&gt;nexth;
1506         }
1507     }
1508 
1509     /*
1510      * Actually insert defaulted values when needed
1511      */
1512     attr = elemDecl-&gt;attributes;
1513     while (attr != NULL) {
1514         /*
<span class="line-modified">1515          * Make sure that attributes redefinition occuring in the</span>
<span class="line-modified">1516          * internal subset are not overriden by definitions in the</span>
1517          * external subset.
1518          */
1519         if (attr-&gt;defaultValue != NULL) {
1520         /*
1521          * the element should be instantiated in the tree if:
1522          *  - this is a namespace prefix
1523          *  - the user required for completion in the tree
1524          *    like XSLT
1525          *  - there isn&#39;t already an attribute definition
1526          *    in the internal subset overriding it.
1527          */
1528         if (((attr-&gt;prefix != NULL) &amp;&amp;
1529              (xmlStrEqual(attr-&gt;prefix, BAD_CAST &quot;xmlns&quot;))) ||
1530             ((attr-&gt;prefix == NULL) &amp;&amp;
1531              (xmlStrEqual(attr-&gt;name, BAD_CAST &quot;xmlns&quot;))) ||
1532             (ctxt-&gt;loadsubset &amp; XML_COMPLETE_ATTRS)) {
1533             xmlAttributePtr tst;
1534 
1535             tst = xmlGetDtdQAttrDesc(ctxt-&gt;myDoc-&gt;intSubset,
1536                          attr-&gt;elem, attr-&gt;name,
</pre>
<hr />
<pre>
1651     }
1652     ctxt-&gt;nodemem = -1;
1653     if (ctxt-&gt;linenumbers) {
1654     if (ctxt-&gt;input != NULL) {
1655         if (ctxt-&gt;input-&gt;line &lt; 65535)
1656         ret-&gt;line = (short) ctxt-&gt;input-&gt;line;
1657         else
1658             ret-&gt;line = 65535;
1659     }
1660     }
1661 
1662     /*
1663      * We are parsing a new node.
1664      */
1665 #ifdef DEBUG_SAX_TREE
1666     xmlGenericError(xmlGenericErrorContext, &quot;pushing(%s)\n&quot;, name);
1667 #endif
1668     if (nodePush(ctxt, ret) &lt; 0) {
1669         xmlUnlinkNode(ret);
1670         xmlFreeNode(ret);


1671         return;
1672     }
1673 
1674     /*
1675      * Link the child element
1676      */
1677     if (parent != NULL) {
1678         if (parent-&gt;type == XML_ELEMENT_NODE) {
1679 #ifdef DEBUG_SAX_TREE
1680         xmlGenericError(xmlGenericErrorContext,
1681             &quot;adding child %s to %s\n&quot;, name, parent-&gt;name);
1682 #endif
1683         xmlAddChild(parent, ret);
1684     } else {
1685 #ifdef DEBUG_SAX_TREE
1686         xmlGenericError(xmlGenericErrorContext,
1687             &quot;adding sibling %s to &quot;, name);
1688         xmlDebugDumpOneNode(stderr, parent, 0);
1689 #endif
1690         xmlAddSibling(parent, ret);
</pre>
<hr />
<pre>
1717         value = atts[i++];
1718         }
1719     }
1720     }
1721 
1722     /*
1723      * Search the namespace, note that since the attributes have been
1724      * processed, the local namespaces are available.
1725      */
1726     ns = xmlSearchNs(ctxt-&gt;myDoc, ret, prefix);
1727     if ((ns == NULL) &amp;&amp; (parent != NULL))
1728     ns = xmlSearchNs(ctxt-&gt;myDoc, parent, prefix);
1729     if ((prefix != NULL) &amp;&amp; (ns == NULL)) {
1730     ns = xmlNewNs(ret, NULL, prefix);
1731     xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
1732              &quot;Namespace prefix %s is not defined\n&quot;,
1733              prefix, NULL);
1734     }
1735 
1736     /*
<span class="line-modified">1737      * set the namespace node, making sure that if the default namspace</span>
<span class="line-modified">1738      * is unbound on a parent we simply kee it NULL</span>
1739      */
1740     if ((ns != NULL) &amp;&amp; (ns-&gt;href != NULL) &amp;&amp;
1741     ((ns-&gt;href[0] != 0) || (ns-&gt;prefix != NULL)))
1742     xmlSetNs(ret, ns);
1743 
1744     /*
1745      * process all the other attributes
1746      */
1747     if (atts != NULL) {
1748         i = 0;
1749     att = atts[i++];
1750     value = atts[i++];
1751     if (ctxt-&gt;html) {
1752         while (att != NULL) {
1753         xmlSAX2AttributeInternal(ctxt, att, value, NULL);
1754         att = atts[i++];
1755         value = atts[i++];
1756         }
1757     } else {
1758         while ((att != NULL) &amp;&amp; (value != NULL)) {
</pre>
<hr />
<pre>
1993 
1994     /*
1995      * allocate the node
1996      */
1997     if (ctxt-&gt;freeAttrs != NULL) {
1998         ret = ctxt-&gt;freeAttrs;
1999     ctxt-&gt;freeAttrs = ret-&gt;next;
2000     ctxt-&gt;freeAttrsNr--;
2001     memset(ret, 0, sizeof(xmlAttr));
2002     ret-&gt;type = XML_ATTRIBUTE_NODE;
2003 
2004     ret-&gt;parent = ctxt-&gt;node;
2005     ret-&gt;doc = ctxt-&gt;myDoc;
2006     ret-&gt;ns = namespace;
2007 
2008     if (ctxt-&gt;dictNames)
2009         ret-&gt;name = localname;
2010     else
2011         ret-&gt;name = xmlStrdup(localname);
2012 
<span class="line-modified">2013         /* link at the end to preserv order, TODO speed up with a last */</span>
2014     if (ctxt-&gt;node-&gt;properties == NULL) {
2015         ctxt-&gt;node-&gt;properties = ret;
2016     } else {
2017         xmlAttrPtr prev = ctxt-&gt;node-&gt;properties;
2018 
2019         while (prev-&gt;next != NULL) prev = prev-&gt;next;
2020         prev-&gt;next = ret;
2021         ret-&gt;prev = prev;
2022     }
2023 
2024     if ((__xmlRegisterCallbacks) &amp;&amp; (xmlRegisterNodeDefaultValue))
2025         xmlRegisterNodeDefaultValue((xmlNodePtr)ret);
2026     } else {
2027     if (ctxt-&gt;dictNames)
2028         ret = xmlNewNsPropEatName(ctxt-&gt;node, namespace,
2029                                   (xmlChar *) localname, NULL);
2030     else
2031         ret = xmlNewNsProp(ctxt-&gt;node, namespace, localname, NULL);
2032     if (ret == NULL) {
2033         xmlErrMemory(ctxt, &quot;xmlSAX2AttributeNs&quot;);
</pre>
<hr />
<pre>
2085         if (!ctxt-&gt;replaceEntities) {
2086         dup = xmlSAX2DecodeAttrEntities(ctxt, value, valueend);
2087         if (dup == NULL) {
2088             if (*valueend == 0) {
2089             ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
2090                     ctxt-&gt;myDoc, ctxt-&gt;node, ret, value);
2091         } else {
2092             /*
2093              * That should already be normalized.
2094              * cheaper to finally allocate here than duplicate
2095              * entry points in the full validation code
2096              */
2097             dup = xmlStrndup(value, valueend - value);
2098 
2099             ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
2100                     ctxt-&gt;myDoc, ctxt-&gt;node, ret, dup);
2101         }
2102         } else {
2103             /*
2104          * dup now contains a string of the flattened attribute
<span class="line-modified">2105          * content with entities substitued. Check if we need to</span>
2106          * apply an extra layer of normalization.
2107          * It need to be done twice ... it&#39;s an extra burden related
2108          * to the ability to keep references in attributes
2109          */
2110         if (ctxt-&gt;attsSpecial != NULL) {
2111             xmlChar *nvalnorm;
2112             xmlChar fn[50];
2113             xmlChar *fullname;
2114 
2115             fullname = xmlBuildQName(localname, prefix, fn, 50);
2116             if (fullname != NULL) {
2117             ctxt-&gt;vctxt.valid = 1;
2118                 nvalnorm = xmlValidCtxtNormalizeAttributeValue(
2119                              &amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc,
2120                      ctxt-&gt;node, fullname, dup);
2121             if (ctxt-&gt;vctxt.valid != 1)
2122                 ctxt-&gt;valid = 0;
2123 
2124             if ((fullname != fn) &amp;&amp; (fullname != localname))
2125                 xmlFree(fullname);
2126             if (nvalnorm != NULL) {
2127                 xmlFree(dup);
2128                 dup = nvalnorm;
2129             }
2130             }
2131         }
2132 
2133         ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
2134                     ctxt-&gt;myDoc, ctxt-&gt;node, ret, dup);
2135         }
2136     } else {
2137         /*
<span class="line-modified">2138          * if entities already have been substitued, then</span>
2139          * the attribute as passed is already normalized
2140          */
2141         dup = xmlStrndup(value, valueend - value);
2142 
2143         ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
2144                                  ctxt-&gt;myDoc, ctxt-&gt;node, ret, dup);
2145     }
2146     } else
2147 #endif /* LIBXML_VALID_ENABLED */
2148            if (((ctxt-&gt;loadsubset &amp; XML_SKIP_IDS) == 0) &amp;&amp;
2149            (((ctxt-&gt;replaceEntities == 0) &amp;&amp; (ctxt-&gt;external != 2)) ||
2150             ((ctxt-&gt;replaceEntities != 0) &amp;&amp; (ctxt-&gt;inSubset == 0)))) {
2151         /*
2152      * when validating, the ID registration is done at the attribute
2153      * validation level. Otherwise we have to do specific handling here.
2154      */
2155         if ((prefix == ctxt-&gt;str_xml) &amp;&amp;
2156                (localname[0] == &#39;i&#39;) &amp;&amp; (localname[1] == &#39;d&#39;) &amp;&amp;
2157            (localname[2] == 0)) {
2158         /*
</pre>
<hr />
<pre>
2381             xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartElementNs&quot;);
2382         return;
2383         }
2384             if (prefix != NULL)
2385                 xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
2386                              &quot;Namespace prefix %s was not found\n&quot;,
2387                              prefix, NULL);
2388             else
2389                 xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
2390                              &quot;Namespace default prefix was not found\n&quot;,
2391                              NULL, NULL);
2392     }
2393     }
2394 
2395     /*
2396      * process all the other attributes
2397      */
2398     if (nb_attributes &gt; 0) {
2399         for (j = 0,i = 0;i &lt; nb_attributes;i++,j+=5) {
2400         /*
<span class="line-modified">2401          * Handle the rare case of an undefined atribute prefix</span>
2402          */
2403         if ((attributes[j+1] != NULL) &amp;&amp; (attributes[j+2] == NULL)) {
2404         if (ctxt-&gt;dictNames) {
2405             const xmlChar *fullname;
2406 
2407             fullname = xmlDictQLookup(ctxt-&gt;dict, attributes[j+1],
2408                                       attributes[j]);
2409             if (fullname != NULL) {
2410             xmlSAX2AttributeNs(ctxt, fullname, NULL,
2411                                attributes[j+3], attributes[j+4]);
2412                 continue;
2413             }
2414         } else {
2415             lname = xmlBuildQName(attributes[j], attributes[j+1],
2416                                   NULL, 0);
2417             if (lname != NULL) {
2418             xmlSAX2AttributeNs(ctxt, lname, NULL,
2419                                attributes[j+3], attributes[j+4]);
2420             xmlFree(lname);
2421                 continue;
</pre>
<hr />
<pre>
2567     if (lastChild != NULL) {
2568         ctxt-&gt;node-&gt;children = lastChild;
2569         ctxt-&gt;node-&gt;last = lastChild;
2570         lastChild-&gt;parent = ctxt-&gt;node;
2571         lastChild-&gt;doc = ctxt-&gt;node-&gt;doc;
2572         ctxt-&gt;nodelen = len;
2573         ctxt-&gt;nodemem = len + 1;
2574     } else {
2575         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2Characters&quot;);
2576         return;
2577     }
2578     } else {
2579     int coalesceText = (lastChild != NULL) &amp;&amp;
2580         (lastChild-&gt;type == XML_TEXT_NODE) &amp;&amp;
2581         (lastChild-&gt;name == xmlStringText);
2582     if ((coalesceText) &amp;&amp; (ctxt-&gt;nodemem != 0)) {
2583         /*
2584          * The whole point of maintaining nodelen and nodemem,
2585          * xmlTextConcat is too costly, i.e. compute length,
2586          * reallocate a new buffer, move data, append ch. Here
<span class="line-modified">2587          * We try to minimaze realloc() uses and avoid copying</span>
2588          * and recomputing length over and over.
2589          */
2590         if (lastChild-&gt;content == (xmlChar *)&amp;(lastChild-&gt;properties)) {
2591         lastChild-&gt;content = xmlStrdup(lastChild-&gt;content);
2592         lastChild-&gt;properties = NULL;
2593         } else if ((ctxt-&gt;nodemem == ctxt-&gt;nodelen + 1) &amp;&amp;
2594                    (xmlDictOwns(ctxt-&gt;dict, lastChild-&gt;content))) {
2595         lastChild-&gt;content = xmlStrdup(lastChild-&gt;content);
2596         }
2597         if (lastChild-&gt;content == NULL) {
2598         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2Characters: xmlStrdup returned NULL&quot;);
2599         return;
2600         }
2601             if (((size_t)ctxt-&gt;nodelen + (size_t)len &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
2602                 ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
2603                 xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2Characters: huge text node&quot;);
2604                 return;
2605             }
2606         if ((size_t)ctxt-&gt;nodelen &gt; SIZE_T_MAX - (size_t)len ||
2607             (size_t)ctxt-&gt;nodemem + (size_t)len &gt; SIZE_T_MAX / 2) {
</pre>
</td>
<td>
<hr />
<pre>
  23 #include &lt;libxml/debugXML.h&gt;
  24 #include &lt;libxml/xmlIO.h&gt;
  25 #include &lt;libxml/SAX.h&gt;
  26 #include &lt;libxml/uri.h&gt;
  27 #include &lt;libxml/valid.h&gt;
  28 #include &lt;libxml/HTMLtree.h&gt;
  29 #include &lt;libxml/globals.h&gt;
  30 
  31 /* Define SIZE_T_MAX unless defined through &lt;limits.h&gt;. */
  32 #ifndef SIZE_T_MAX
  33 # define SIZE_T_MAX     ((size_t)-1)
  34 #endif /* !SIZE_T_MAX */
  35 
  36 /* #define DEBUG_SAX2 */
  37 /* #define DEBUG_SAX2_TREE */
  38 
  39 /**
  40  * TODO:
  41  *
  42  * macro to flag unimplemented blocks
<span class="line-modified">  43  * XML_CATALOG_PREFER user env to select between system/public preferred</span>
  44  * option. C.f. Richard Tobin &lt;richard@cogsci.ed.ac.uk&gt;
  45  *&gt; Just FYI, I am using an environment variable XML_CATALOG_PREFER with
  46  *&gt; values &quot;system&quot; and &quot;public&quot;.  I have made the default be &quot;system&quot; to
  47  *&gt; match yours.
  48  */
  49 #define TODO                                \
  50     xmlGenericError(xmlGenericErrorContext,             \
  51         &quot;Unimplemented block at %s:%d\n&quot;,               \
  52             __FILE__, __LINE__);
  53 
  54 /*
  55  * xmlSAX2ErrMemory:
  56  * @ctxt:  an XML validation parser context
  57  * @msg:   a string to accompany the error message
  58  */
  59 static void LIBXML_ATTR_FORMAT(2,0)
  60 xmlSAX2ErrMemory(xmlParserCtxtPtr ctxt, const char *msg) {
  61     xmlStructuredErrorFunc schannel = NULL;
  62     const char *str1 = &quot;out of memory\n&quot;;
  63 
</pre>
<hr />
<pre>
1495             }
1496             }
1497             if (att == NULL) {
1498                 xmlErrValid(ctxt, XML_DTD_STANDALONE_DEFAULTED,
1499       &quot;standalone: attribute %s on %s defaulted from external subset\n&quot;,
1500                     (const char *)fulln,
1501                     (const char *)attr-&gt;elem);
1502             }
1503                     xmlFree(fulln);
1504         }
1505         attr = attr-&gt;nexth;
1506         }
1507     }
1508 
1509     /*
1510      * Actually insert defaulted values when needed
1511      */
1512     attr = elemDecl-&gt;attributes;
1513     while (attr != NULL) {
1514         /*
<span class="line-modified">1515          * Make sure that attributes redefinition occurring in the</span>
<span class="line-modified">1516          * internal subset are not overridden by definitions in the</span>
1517          * external subset.
1518          */
1519         if (attr-&gt;defaultValue != NULL) {
1520         /*
1521          * the element should be instantiated in the tree if:
1522          *  - this is a namespace prefix
1523          *  - the user required for completion in the tree
1524          *    like XSLT
1525          *  - there isn&#39;t already an attribute definition
1526          *    in the internal subset overriding it.
1527          */
1528         if (((attr-&gt;prefix != NULL) &amp;&amp;
1529              (xmlStrEqual(attr-&gt;prefix, BAD_CAST &quot;xmlns&quot;))) ||
1530             ((attr-&gt;prefix == NULL) &amp;&amp;
1531              (xmlStrEqual(attr-&gt;name, BAD_CAST &quot;xmlns&quot;))) ||
1532             (ctxt-&gt;loadsubset &amp; XML_COMPLETE_ATTRS)) {
1533             xmlAttributePtr tst;
1534 
1535             tst = xmlGetDtdQAttrDesc(ctxt-&gt;myDoc-&gt;intSubset,
1536                          attr-&gt;elem, attr-&gt;name,
</pre>
<hr />
<pre>
1651     }
1652     ctxt-&gt;nodemem = -1;
1653     if (ctxt-&gt;linenumbers) {
1654     if (ctxt-&gt;input != NULL) {
1655         if (ctxt-&gt;input-&gt;line &lt; 65535)
1656         ret-&gt;line = (short) ctxt-&gt;input-&gt;line;
1657         else
1658             ret-&gt;line = 65535;
1659     }
1660     }
1661 
1662     /*
1663      * We are parsing a new node.
1664      */
1665 #ifdef DEBUG_SAX_TREE
1666     xmlGenericError(xmlGenericErrorContext, &quot;pushing(%s)\n&quot;, name);
1667 #endif
1668     if (nodePush(ctxt, ret) &lt; 0) {
1669         xmlUnlinkNode(ret);
1670         xmlFreeNode(ret);
<span class="line-added">1671         if (prefix != NULL)</span>
<span class="line-added">1672             xmlFree(prefix);</span>
1673         return;
1674     }
1675 
1676     /*
1677      * Link the child element
1678      */
1679     if (parent != NULL) {
1680         if (parent-&gt;type == XML_ELEMENT_NODE) {
1681 #ifdef DEBUG_SAX_TREE
1682         xmlGenericError(xmlGenericErrorContext,
1683             &quot;adding child %s to %s\n&quot;, name, parent-&gt;name);
1684 #endif
1685         xmlAddChild(parent, ret);
1686     } else {
1687 #ifdef DEBUG_SAX_TREE
1688         xmlGenericError(xmlGenericErrorContext,
1689             &quot;adding sibling %s to &quot;, name);
1690         xmlDebugDumpOneNode(stderr, parent, 0);
1691 #endif
1692         xmlAddSibling(parent, ret);
</pre>
<hr />
<pre>
1719         value = atts[i++];
1720         }
1721     }
1722     }
1723 
1724     /*
1725      * Search the namespace, note that since the attributes have been
1726      * processed, the local namespaces are available.
1727      */
1728     ns = xmlSearchNs(ctxt-&gt;myDoc, ret, prefix);
1729     if ((ns == NULL) &amp;&amp; (parent != NULL))
1730     ns = xmlSearchNs(ctxt-&gt;myDoc, parent, prefix);
1731     if ((prefix != NULL) &amp;&amp; (ns == NULL)) {
1732     ns = xmlNewNs(ret, NULL, prefix);
1733     xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
1734              &quot;Namespace prefix %s is not defined\n&quot;,
1735              prefix, NULL);
1736     }
1737 
1738     /*
<span class="line-modified">1739      * set the namespace node, making sure that if the default namespace</span>
<span class="line-modified">1740      * is unbound on a parent we simply keep it NULL</span>
1741      */
1742     if ((ns != NULL) &amp;&amp; (ns-&gt;href != NULL) &amp;&amp;
1743     ((ns-&gt;href[0] != 0) || (ns-&gt;prefix != NULL)))
1744     xmlSetNs(ret, ns);
1745 
1746     /*
1747      * process all the other attributes
1748      */
1749     if (atts != NULL) {
1750         i = 0;
1751     att = atts[i++];
1752     value = atts[i++];
1753     if (ctxt-&gt;html) {
1754         while (att != NULL) {
1755         xmlSAX2AttributeInternal(ctxt, att, value, NULL);
1756         att = atts[i++];
1757         value = atts[i++];
1758         }
1759     } else {
1760         while ((att != NULL) &amp;&amp; (value != NULL)) {
</pre>
<hr />
<pre>
1995 
1996     /*
1997      * allocate the node
1998      */
1999     if (ctxt-&gt;freeAttrs != NULL) {
2000         ret = ctxt-&gt;freeAttrs;
2001     ctxt-&gt;freeAttrs = ret-&gt;next;
2002     ctxt-&gt;freeAttrsNr--;
2003     memset(ret, 0, sizeof(xmlAttr));
2004     ret-&gt;type = XML_ATTRIBUTE_NODE;
2005 
2006     ret-&gt;parent = ctxt-&gt;node;
2007     ret-&gt;doc = ctxt-&gt;myDoc;
2008     ret-&gt;ns = namespace;
2009 
2010     if (ctxt-&gt;dictNames)
2011         ret-&gt;name = localname;
2012     else
2013         ret-&gt;name = xmlStrdup(localname);
2014 
<span class="line-modified">2015         /* link at the end to preserve order, TODO speed up with a last */</span>
2016     if (ctxt-&gt;node-&gt;properties == NULL) {
2017         ctxt-&gt;node-&gt;properties = ret;
2018     } else {
2019         xmlAttrPtr prev = ctxt-&gt;node-&gt;properties;
2020 
2021         while (prev-&gt;next != NULL) prev = prev-&gt;next;
2022         prev-&gt;next = ret;
2023         ret-&gt;prev = prev;
2024     }
2025 
2026     if ((__xmlRegisterCallbacks) &amp;&amp; (xmlRegisterNodeDefaultValue))
2027         xmlRegisterNodeDefaultValue((xmlNodePtr)ret);
2028     } else {
2029     if (ctxt-&gt;dictNames)
2030         ret = xmlNewNsPropEatName(ctxt-&gt;node, namespace,
2031                                   (xmlChar *) localname, NULL);
2032     else
2033         ret = xmlNewNsProp(ctxt-&gt;node, namespace, localname, NULL);
2034     if (ret == NULL) {
2035         xmlErrMemory(ctxt, &quot;xmlSAX2AttributeNs&quot;);
</pre>
<hr />
<pre>
2087         if (!ctxt-&gt;replaceEntities) {
2088         dup = xmlSAX2DecodeAttrEntities(ctxt, value, valueend);
2089         if (dup == NULL) {
2090             if (*valueend == 0) {
2091             ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
2092                     ctxt-&gt;myDoc, ctxt-&gt;node, ret, value);
2093         } else {
2094             /*
2095              * That should already be normalized.
2096              * cheaper to finally allocate here than duplicate
2097              * entry points in the full validation code
2098              */
2099             dup = xmlStrndup(value, valueend - value);
2100 
2101             ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
2102                     ctxt-&gt;myDoc, ctxt-&gt;node, ret, dup);
2103         }
2104         } else {
2105             /*
2106          * dup now contains a string of the flattened attribute
<span class="line-modified">2107          * content with entities substituted. Check if we need to</span>
2108          * apply an extra layer of normalization.
2109          * It need to be done twice ... it&#39;s an extra burden related
2110          * to the ability to keep references in attributes
2111          */
2112         if (ctxt-&gt;attsSpecial != NULL) {
2113             xmlChar *nvalnorm;
2114             xmlChar fn[50];
2115             xmlChar *fullname;
2116 
2117             fullname = xmlBuildQName(localname, prefix, fn, 50);
2118             if (fullname != NULL) {
2119             ctxt-&gt;vctxt.valid = 1;
2120                 nvalnorm = xmlValidCtxtNormalizeAttributeValue(
2121                              &amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc,
2122                      ctxt-&gt;node, fullname, dup);
2123             if (ctxt-&gt;vctxt.valid != 1)
2124                 ctxt-&gt;valid = 0;
2125 
2126             if ((fullname != fn) &amp;&amp; (fullname != localname))
2127                 xmlFree(fullname);
2128             if (nvalnorm != NULL) {
2129                 xmlFree(dup);
2130                 dup = nvalnorm;
2131             }
2132             }
2133         }
2134 
2135         ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
2136                     ctxt-&gt;myDoc, ctxt-&gt;node, ret, dup);
2137         }
2138     } else {
2139         /*
<span class="line-modified">2140          * if entities already have been substituted, then</span>
2141          * the attribute as passed is already normalized
2142          */
2143         dup = xmlStrndup(value, valueend - value);
2144 
2145         ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
2146                                  ctxt-&gt;myDoc, ctxt-&gt;node, ret, dup);
2147     }
2148     } else
2149 #endif /* LIBXML_VALID_ENABLED */
2150            if (((ctxt-&gt;loadsubset &amp; XML_SKIP_IDS) == 0) &amp;&amp;
2151            (((ctxt-&gt;replaceEntities == 0) &amp;&amp; (ctxt-&gt;external != 2)) ||
2152             ((ctxt-&gt;replaceEntities != 0) &amp;&amp; (ctxt-&gt;inSubset == 0)))) {
2153         /*
2154      * when validating, the ID registration is done at the attribute
2155      * validation level. Otherwise we have to do specific handling here.
2156      */
2157         if ((prefix == ctxt-&gt;str_xml) &amp;&amp;
2158                (localname[0] == &#39;i&#39;) &amp;&amp; (localname[1] == &#39;d&#39;) &amp;&amp;
2159            (localname[2] == 0)) {
2160         /*
</pre>
<hr />
<pre>
2383             xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartElementNs&quot;);
2384         return;
2385         }
2386             if (prefix != NULL)
2387                 xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
2388                              &quot;Namespace prefix %s was not found\n&quot;,
2389                              prefix, NULL);
2390             else
2391                 xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
2392                              &quot;Namespace default prefix was not found\n&quot;,
2393                              NULL, NULL);
2394     }
2395     }
2396 
2397     /*
2398      * process all the other attributes
2399      */
2400     if (nb_attributes &gt; 0) {
2401         for (j = 0,i = 0;i &lt; nb_attributes;i++,j+=5) {
2402         /*
<span class="line-modified">2403          * Handle the rare case of an undefined attribute prefix</span>
2404          */
2405         if ((attributes[j+1] != NULL) &amp;&amp; (attributes[j+2] == NULL)) {
2406         if (ctxt-&gt;dictNames) {
2407             const xmlChar *fullname;
2408 
2409             fullname = xmlDictQLookup(ctxt-&gt;dict, attributes[j+1],
2410                                       attributes[j]);
2411             if (fullname != NULL) {
2412             xmlSAX2AttributeNs(ctxt, fullname, NULL,
2413                                attributes[j+3], attributes[j+4]);
2414                 continue;
2415             }
2416         } else {
2417             lname = xmlBuildQName(attributes[j], attributes[j+1],
2418                                   NULL, 0);
2419             if (lname != NULL) {
2420             xmlSAX2AttributeNs(ctxt, lname, NULL,
2421                                attributes[j+3], attributes[j+4]);
2422             xmlFree(lname);
2423                 continue;
</pre>
<hr />
<pre>
2569     if (lastChild != NULL) {
2570         ctxt-&gt;node-&gt;children = lastChild;
2571         ctxt-&gt;node-&gt;last = lastChild;
2572         lastChild-&gt;parent = ctxt-&gt;node;
2573         lastChild-&gt;doc = ctxt-&gt;node-&gt;doc;
2574         ctxt-&gt;nodelen = len;
2575         ctxt-&gt;nodemem = len + 1;
2576     } else {
2577         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2Characters&quot;);
2578         return;
2579     }
2580     } else {
2581     int coalesceText = (lastChild != NULL) &amp;&amp;
2582         (lastChild-&gt;type == XML_TEXT_NODE) &amp;&amp;
2583         (lastChild-&gt;name == xmlStringText);
2584     if ((coalesceText) &amp;&amp; (ctxt-&gt;nodemem != 0)) {
2585         /*
2586          * The whole point of maintaining nodelen and nodemem,
2587          * xmlTextConcat is too costly, i.e. compute length,
2588          * reallocate a new buffer, move data, append ch. Here
<span class="line-modified">2589          * We try to minimize realloc() uses and avoid copying</span>
2590          * and recomputing length over and over.
2591          */
2592         if (lastChild-&gt;content == (xmlChar *)&amp;(lastChild-&gt;properties)) {
2593         lastChild-&gt;content = xmlStrdup(lastChild-&gt;content);
2594         lastChild-&gt;properties = NULL;
2595         } else if ((ctxt-&gt;nodemem == ctxt-&gt;nodelen + 1) &amp;&amp;
2596                    (xmlDictOwns(ctxt-&gt;dict, lastChild-&gt;content))) {
2597         lastChild-&gt;content = xmlStrdup(lastChild-&gt;content);
2598         }
2599         if (lastChild-&gt;content == NULL) {
2600         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2Characters: xmlStrdup returned NULL&quot;);
2601         return;
2602         }
2603             if (((size_t)ctxt-&gt;nodelen + (size_t)len &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
2604                 ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
2605                 xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2Characters: huge text node&quot;);
2606                 return;
2607             }
2608         if ((size_t)ctxt-&gt;nodelen &gt; SIZE_T_MAX - (size_t)len ||
2609             (size_t)ctxt-&gt;nodemem + (size_t)len &gt; SIZE_T_MAX / 2) {
</pre>
</td>
</tr>
</table>
<center><a href="README.zOS.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="aclocal.m4.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
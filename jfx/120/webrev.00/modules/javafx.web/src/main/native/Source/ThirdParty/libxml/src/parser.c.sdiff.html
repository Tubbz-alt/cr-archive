<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/parser.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="nanohttp.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="parserInternals.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/parser.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   79 #endif
   80 #ifdef HAVE_FCNTL_H
   81 #include &lt;fcntl.h&gt;
   82 #endif
   83 #ifdef HAVE_UNISTD_H
   84 #include &lt;unistd.h&gt;
   85 #endif
   86 
   87 #include &quot;buf.h&quot;
   88 #include &quot;enc.h&quot;
   89 
   90 static void
   91 xmlFatalErr(xmlParserCtxtPtr ctxt, xmlParserErrors error, const char *info);
   92 
   93 static xmlParserCtxtPtr
   94 xmlCreateEntityParserCtxtInternal(const xmlChar *URL, const xmlChar *ID,
   95                       const xmlChar *base, xmlParserCtxtPtr pctx);
   96 
   97 static void xmlHaltParser(xmlParserCtxtPtr ctxt);
   98 






   99 /************************************************************************
  100  *                                  *
  101  *  Arbitrary limits set in the parser. See XML_PARSE_HUGE      *
  102  *                                  *
  103  ************************************************************************/
  104 
  105 #define XML_PARSER_BIG_ENTITY 1000
  106 #define XML_PARSER_LOT_ENTITY 5000
  107 
  108 /*
  109  * XML_PARSER_NON_LINEAR is the threshold where the ratio of parsed entity
  110  *    replacement over the size in byte of the input indicates that you have
<span class="line-modified">  111  *    and eponential behaviour. A value of 10 correspond to at least 3 entity</span>
  112  *    replacement per byte of input.
  113  */
  114 #define XML_PARSER_NON_LINEAR 10
  115 
  116 /*
  117  * xmlParserEntityCheck
  118  *
  119  * Function to check non-linear entity expansion behaviour
  120  * This is here to detect and stop exponential linear entity expansion
  121  * This is not a limitation of the parser but a safety
  122  * boundary feature. It can be disabled with the XML_PARSE_HUGE
  123  * parser option.
  124  */
  125 static int
  126 xmlParserEntityCheck(xmlParserCtxtPtr ctxt, size_t size,
  127                      xmlEntityPtr ent, size_t replacement)
  128 {
  129     size_t consumed = 0;
  130 
  131     if ((ctxt == NULL) || (ctxt-&gt;options &amp; XML_PARSE_HUGE))
  132         return (0);
  133     if (ctxt-&gt;lastError.code == XML_ERR_ENTITY_LOOP)
  134         return (1);
  135 
  136     /*
  137      * This may look absurd but is needed to detect
  138      * entities problems
  139      */
  140     if ((ent != NULL) &amp;&amp; (ent-&gt;etype != XML_INTERNAL_PREDEFINED_ENTITY) &amp;&amp;
  141     (ent-&gt;content != NULL) &amp;&amp; (ent-&gt;checked == 0) &amp;&amp;
  142     (ctxt-&gt;errNo != XML_ERR_ENTITY_LOOP)) {
<span class="line-modified">  143     unsigned long oldnbent = ctxt-&gt;nbentities;</span>
  144     xmlChar *rep;
  145 
  146     ent-&gt;checked = 1;
  147 
  148         ++ctxt-&gt;depth;
  149     rep = xmlStringDecodeEntities(ctxt, ent-&gt;content,
  150                   XML_SUBSTITUTE_REF, 0, 0, 0);
  151         --ctxt-&gt;depth;
  152     if ((rep == NULL) || (ctxt-&gt;errNo == XML_ERR_ENTITY_LOOP)) {
  153         ent-&gt;content[0] = 0;
  154     }
  155 
<span class="line-modified">  156     ent-&gt;checked = (ctxt-&gt;nbentities - oldnbent + 1) * 2;</span>



  157     if (rep != NULL) {
  158         if (xmlStrchr(rep, &#39;&lt;&#39;))
  159         ent-&gt;checked |= 1;
  160         xmlFree(rep);
  161         rep = NULL;
  162     }
  163     }
  164     if (replacement != 0) {
  165     if (replacement &lt; XML_MAX_TEXT_LENGTH)
  166         return(0);
  167 
  168         /*
  169      * If the volume of entity copy reaches 10 times the
  170      * amount of parsed data and over the large text threshold
  171      * then that&#39;s very likely to be an abuse.
  172      */
  173         if (ctxt-&gt;input != NULL) {
  174         consumed = ctxt-&gt;input-&gt;consumed +
  175                    (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
  176     }
</pre>
<hr />
<pre>
 1043             return(1);
 1044 #else
 1045             return(0);
 1046 #endif
 1047         default:
 1048         break;
 1049      }
 1050      return(0);
 1051 }
 1052 
 1053 /************************************************************************
 1054  *                                  *
 1055  *      SAX2 defaulted attributes handling          *
 1056  *                                  *
 1057  ************************************************************************/
 1058 
 1059 /**
 1060  * xmlDetectSAX2:
 1061  * @ctxt:  an XML parser context
 1062  *
<span class="line-modified"> 1063  * Do the SAX2 detection and specific intialization</span>
 1064  */
 1065 static void
 1066 xmlDetectSAX2(xmlParserCtxtPtr ctxt) {
 1067     if (ctxt == NULL) return;
 1068 #ifdef LIBXML_SAX1_ENABLED
 1069     if ((ctxt-&gt;sax) &amp;&amp;  (ctxt-&gt;sax-&gt;initialized == XML_SAX2_MAGIC) &amp;&amp;
 1070         ((ctxt-&gt;sax-&gt;startElementNs != NULL) ||
 1071          (ctxt-&gt;sax-&gt;endElementNs != NULL))) ctxt-&gt;sax2 = 1;
 1072 #else
 1073     ctxt-&gt;sax2 = 1;
 1074 #endif /* LIBXML_SAX1_ENABLED */
 1075 
 1076     ctxt-&gt;str_xml = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xml&quot;, 3);
 1077     ctxt-&gt;str_xmlns = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xmlns&quot;, 5);
 1078     ctxt-&gt;str_xml_ns = xmlDictLookup(ctxt-&gt;dict, XML_XML_NAMESPACE, 36);
 1079     if ((ctxt-&gt;str_xml==NULL) || (ctxt-&gt;str_xmlns==NULL) ||
 1080         (ctxt-&gt;str_xml_ns == NULL)) {
 1081         xmlErrMemory(ctxt, NULL);
 1082     }
 1083 }
</pre>
<hr />
<pre>
 1375     }
 1376     return;
 1377 }
 1378 
 1379 /**
 1380  * xmlCheckLanguageID:
 1381  * @lang:  pointer to the string value
 1382  *
 1383  * Checks that the value conforms to the LanguageID production:
 1384  *
 1385  * NOTE: this is somewhat deprecated, those productions were removed from
 1386  *       the XML Second edition.
 1387  *
 1388  * [33] LanguageID ::= Langcode (&#39;-&#39; Subcode)*
 1389  * [34] Langcode ::= ISO639Code |  IanaCode |  UserCode
 1390  * [35] ISO639Code ::= ([a-z] | [A-Z]) ([a-z] | [A-Z])
 1391  * [36] IanaCode ::= (&#39;i&#39; | &#39;I&#39;) &#39;-&#39; ([a-z] | [A-Z])+
 1392  * [37] UserCode ::= (&#39;x&#39; | &#39;X&#39;) &#39;-&#39; ([a-z] | [A-Z])+
 1393  * [38] Subcode ::= ([a-z] | [A-Z])+
 1394  *
<span class="line-modified"> 1395  * The current REC reference the sucessors of RFC 1766, currently 5646</span>
 1396  *
 1397  * http://www.rfc-editor.org/rfc/rfc5646.txt
 1398  * langtag       = language
 1399  *                 [&quot;-&quot; script]
 1400  *                 [&quot;-&quot; region]
 1401  *                 *(&quot;-&quot; variant)
 1402  *                 *(&quot;-&quot; extension)
 1403  *                 [&quot;-&quot; privateuse]
 1404  * language      = 2*3ALPHA            ; shortest ISO 639 code
 1405  *                 [&quot;-&quot; extlang]       ; sometimes followed by
 1406  *                                     ; extended language subtags
 1407  *               / 4ALPHA              ; or reserved for future use
 1408  *               / 5*8ALPHA            ; or registered language subtag
 1409  *
 1410  * extlang       = 3ALPHA              ; selected ISO 639 codes
 1411  *                 *2(&quot;-&quot; 3ALPHA)      ; permanently reserved
 1412  *
 1413  * script        = 4ALPHA              ; ISO 15924 code
 1414  *
 1415  * region        = 2ALPHA              ; ISO 3166-1 code
</pre>
<hr />
<pre>
 1802  * Returns the node just removed
 1803  */
 1804 xmlNodePtr
 1805 nodePop(xmlParserCtxtPtr ctxt)
 1806 {
 1807     xmlNodePtr ret;
 1808 
 1809     if (ctxt == NULL) return(NULL);
 1810     if (ctxt-&gt;nodeNr &lt;= 0)
 1811         return (NULL);
 1812     ctxt-&gt;nodeNr--;
 1813     if (ctxt-&gt;nodeNr &gt; 0)
 1814         ctxt-&gt;node = ctxt-&gt;nodeTab[ctxt-&gt;nodeNr - 1];
 1815     else
 1816         ctxt-&gt;node = NULL;
 1817     ret = ctxt-&gt;nodeTab[ctxt-&gt;nodeNr];
 1818     ctxt-&gt;nodeTab[ctxt-&gt;nodeNr] = NULL;
 1819     return (ret);
 1820 }
 1821 
<span class="line-removed"> 1822 #ifdef LIBXML_PUSH_ENABLED</span>
 1823 /**
 1824  * nameNsPush:
 1825  * @ctxt:  an XML parser context
 1826  * @value:  the element name
 1827  * @prefix:  the element prefix
 1828  * @URI:  the element namespace name
 1829  *
 1830  * Pushes a new element name/prefix/URL on top of the name stack
 1831  *
 1832  * Returns -1 in case of error, the index in the stack otherwise
 1833  */
 1834 static int
 1835 nameNsPush(xmlParserCtxtPtr ctxt, const xmlChar * value,
 1836            const xmlChar *prefix, const xmlChar *URI, int nsNr)
 1837 {
 1838     if (ctxt-&gt;nameNr &gt;= ctxt-&gt;nameMax) {
 1839         const xmlChar * *tmp;
 1840         void **tmp2;
 1841         ctxt-&gt;nameMax *= 2;
 1842         tmp = (const xmlChar * *) xmlRealloc((xmlChar * *)ctxt-&gt;nameTab,
 1843                                     ctxt-&gt;nameMax *
 1844                                     sizeof(ctxt-&gt;nameTab[0]));
 1845         if (tmp == NULL) {
 1846         ctxt-&gt;nameMax /= 2;
 1847         goto mem_error;
 1848         }
 1849     ctxt-&gt;nameTab = tmp;
 1850         tmp2 = (void **) xmlRealloc((void * *)ctxt-&gt;pushTab,
 1851                                     ctxt-&gt;nameMax * 3 *
 1852                                     sizeof(ctxt-&gt;pushTab[0]));
 1853         if (tmp2 == NULL) {
 1854         ctxt-&gt;nameMax /= 2;
 1855         goto mem_error;
 1856         }
 1857     ctxt-&gt;pushTab = tmp2;





 1858     }
 1859     ctxt-&gt;nameTab[ctxt-&gt;nameNr] = value;
 1860     ctxt-&gt;name = value;
 1861     ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3] = (void *) prefix;
 1862     ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 + 1] = (void *) URI;
 1863     ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 + 2] = (void *) (ptrdiff_t) nsNr;
 1864     return (ctxt-&gt;nameNr++);
 1865 mem_error:
 1866     xmlErrMemory(ctxt, NULL);
 1867     return (-1);
 1868 }

 1869 /**
 1870  * nameNsPop:
 1871  * @ctxt: an XML parser context
 1872  *
 1873  * Pops the top element/prefix/URI name from the name stack
 1874  *
 1875  * Returns the name just removed
 1876  */
 1877 static const xmlChar *
 1878 nameNsPop(xmlParserCtxtPtr ctxt)
 1879 {
 1880     const xmlChar *ret;
 1881 
 1882     if (ctxt-&gt;nameNr &lt;= 0)
 1883         return (NULL);
 1884     ctxt-&gt;nameNr--;
 1885     if (ctxt-&gt;nameNr &gt; 0)
 1886         ctxt-&gt;name = ctxt-&gt;nameTab[ctxt-&gt;nameNr - 1];
 1887     else
 1888         ctxt-&gt;name = NULL;
</pre>
<hr />
<pre>
 2058     if (*ctxt-&gt;input-&gt;cur == 0)                     \
 2059         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);           \
 2060   } while (0)
 2061 
 2062 #define SHRINK if ((ctxt-&gt;progressive == 0) &amp;&amp;              \
 2063            (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base &gt; 2 * INPUT_CHUNK) &amp;&amp; \
 2064            (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; 2 * INPUT_CHUNK)) \
 2065     xmlSHRINK (ctxt);
 2066 
 2067 static void xmlSHRINK (xmlParserCtxtPtr ctxt) {
 2068     xmlParserInputShrink(ctxt-&gt;input);
 2069     if (*ctxt-&gt;input-&gt;cur == 0)
 2070         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 2071 }
 2072 
 2073 #define GROW if ((ctxt-&gt;progressive == 0) &amp;&amp;                \
 2074          (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; INPUT_CHUNK))   \
 2075     xmlGROW (ctxt);
 2076 
 2077 static void xmlGROW (xmlParserCtxtPtr ctxt) {
<span class="line-modified"> 2078     unsigned long curEnd = ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur;</span>
<span class="line-modified"> 2079     unsigned long curBase = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;</span>
 2080 
<span class="line-modified"> 2081     if (((curEnd &gt; (unsigned long) XML_MAX_LOOKUP_LIMIT) ||</span>
<span class="line-modified"> 2082          (curBase &gt; (unsigned long) XML_MAX_LOOKUP_LIMIT)) &amp;&amp;</span>
 2083          ((ctxt-&gt;input-&gt;buf) &amp;&amp;
 2084           (ctxt-&gt;input-&gt;buf-&gt;readcallback != xmlInputReadCallbackNop)) &amp;&amp;
 2085         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 2086         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, &quot;Huge input lookup&quot;);
 2087         xmlHaltParser(ctxt);
 2088     return;
 2089     }
 2090     xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 2091     if ((ctxt-&gt;input-&gt;cur &gt; ctxt-&gt;input-&gt;end) ||
 2092         (ctxt-&gt;input-&gt;cur &lt; ctxt-&gt;input-&gt;base)) {
 2093         xmlHaltParser(ctxt);
 2094         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, &quot;cur index out of bound&quot;);
 2095     return;
 2096     }
 2097     if ((ctxt-&gt;input-&gt;cur != NULL) &amp;&amp; (*ctxt-&gt;input-&gt;cur == 0))
 2098         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 2099 }
 2100 
 2101 #define SKIP_BLANKS xmlSkipBlankChars(ctxt)
 2102 
</pre>
<hr />
<pre>
 2264     return(ret);
 2265 }
 2266 
 2267 /**
 2268  * xmlParseCharRef:
 2269  * @ctxt:  an XML parser context
 2270  *
 2271  * parse Reference declarations
 2272  *
 2273  * [66] CharRef ::= &#39;&amp;#&#39; [0-9]+ &#39;;&#39; |
 2274  *                  &#39;&amp;#x&#39; [0-9a-fA-F]+ &#39;;&#39;
 2275  *
 2276  * [ WFC: Legal Character ]
 2277  * Characters referred to using character references must match the
 2278  * production for Char.
 2279  *
 2280  * Returns the value parsed (as an int), 0 in case of error
 2281  */
 2282 int
 2283 xmlParseCharRef(xmlParserCtxtPtr ctxt) {
<span class="line-modified"> 2284     unsigned int val = 0;</span>
 2285     int count = 0;
<span class="line-removed"> 2286     unsigned int outofrange = 0;</span>
 2287 
 2288     /*
 2289      * Using RAW/CUR/NEXT is okay since we are working on ASCII range here
 2290      */
 2291     if ((RAW == &#39;&amp;&#39;) &amp;&amp; (NXT(1) == &#39;#&#39;) &amp;&amp;
 2292         (NXT(2) == &#39;x&#39;)) {
 2293     SKIP(3);
 2294     GROW;
 2295     while (RAW != &#39;;&#39;) { /* loop blocked by count */
 2296         if (count++ &gt; 20) {
 2297         count = 0;
 2298         GROW;
 2299                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 2300                     return(0);
 2301         }
 2302         if ((RAW &gt;= &#39;0&#39;) &amp;&amp; (RAW &lt;= &#39;9&#39;))
 2303             val = val * 16 + (CUR - &#39;0&#39;);
 2304         else if ((RAW &gt;= &#39;a&#39;) &amp;&amp; (RAW &lt;= &#39;f&#39;) &amp;&amp; (count &lt; 20))
 2305             val = val * 16 + (CUR - &#39;a&#39;) + 10;
 2306         else if ((RAW &gt;= &#39;A&#39;) &amp;&amp; (RAW &lt;= &#39;F&#39;) &amp;&amp; (count &lt; 20))
 2307             val = val * 16 + (CUR - &#39;A&#39;) + 10;
 2308         else {
 2309         xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);
 2310         val = 0;
 2311         break;
 2312         }
<span class="line-modified"> 2313         if (val &gt; 0x10FFFF)</span>
<span class="line-modified"> 2314             outofrange = val;</span>
 2315 
 2316         NEXT;
 2317         count++;
 2318     }
 2319     if (RAW == &#39;;&#39;) {
 2320         /* on purpose to avoid reentrancy problems with NEXT and SKIP */
 2321         ctxt-&gt;input-&gt;col++;
 2322         ctxt-&gt;nbChars ++;
 2323         ctxt-&gt;input-&gt;cur++;
 2324     }
 2325     } else if  ((RAW == &#39;&amp;&#39;) &amp;&amp; (NXT(1) == &#39;#&#39;)) {
 2326     SKIP(2);
 2327     GROW;
 2328     while (RAW != &#39;;&#39;) { /* loop blocked by count */
 2329         if (count++ &gt; 20) {
 2330         count = 0;
 2331         GROW;
 2332                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 2333                     return(0);
 2334         }
 2335         if ((RAW &gt;= &#39;0&#39;) &amp;&amp; (RAW &lt;= &#39;9&#39;))
 2336             val = val * 10 + (CUR - &#39;0&#39;);
 2337         else {
 2338         xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);
 2339         val = 0;
 2340         break;
 2341         }
<span class="line-modified"> 2342         if (val &gt; 0x10FFFF)</span>
<span class="line-modified"> 2343             outofrange = val;</span>
 2344 
 2345         NEXT;
 2346         count++;
 2347     }
 2348     if (RAW == &#39;;&#39;) {
 2349         /* on purpose to avoid reentrancy problems with NEXT and SKIP */
 2350         ctxt-&gt;input-&gt;col++;
 2351         ctxt-&gt;nbChars ++;
 2352         ctxt-&gt;input-&gt;cur++;
 2353     }
 2354     } else {
 2355         xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);
 2356     }
 2357 
 2358     /*
 2359      * [ WFC: Legal Character ]
 2360      * Characters referred to using character references must match the
 2361      * production for Char.
 2362      */
<span class="line-modified"> 2363     if ((IS_CHAR(val) &amp;&amp; (outofrange == 0))) {</span>




 2364         return(val);
 2365     } else {
 2366         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 2367                           &quot;xmlParseCharRef: invalid xmlChar value %d\n&quot;,
 2368                       val);
 2369     }
 2370     return(0);
 2371 }
 2372 
 2373 /**
 2374  * xmlParseStringCharRef:
 2375  * @ctxt:  an XML parser context
 2376  * @str:  a pointer to an index in the string
 2377  *
 2378  * parse Reference declarations, variant parsing from a string rather
 2379  * than an an input flow.
 2380  *
 2381  * [66] CharRef ::= &#39;&amp;#&#39; [0-9]+ &#39;;&#39; |
 2382  *                  &#39;&amp;#x&#39; [0-9a-fA-F]+ &#39;;&#39;
 2383  *
 2384  * [ WFC: Legal Character ]
 2385  * Characters referred to using character references must match the
 2386  * production for Char.
 2387  *
 2388  * Returns the value parsed (as an int), 0 in case of error, str will be
 2389  *         updated to the current value of the index
 2390  */
 2391 static int
 2392 xmlParseStringCharRef(xmlParserCtxtPtr ctxt, const xmlChar **str) {
 2393     const xmlChar *ptr;
 2394     xmlChar cur;
<span class="line-modified"> 2395     unsigned int val = 0;</span>
<span class="line-removed"> 2396     unsigned int outofrange = 0;</span>
 2397 
 2398     if ((str == NULL) || (*str == NULL)) return(0);
 2399     ptr = *str;
 2400     cur = *ptr;
 2401     if ((cur == &#39;&amp;&#39;) &amp;&amp; (ptr[1] == &#39;#&#39;) &amp;&amp; (ptr[2] == &#39;x&#39;)) {
 2402     ptr += 3;
 2403     cur = *ptr;
 2404     while (cur != &#39;;&#39;) { /* Non input consuming loop */
 2405         if ((cur &gt;= &#39;0&#39;) &amp;&amp; (cur &lt;= &#39;9&#39;))
 2406             val = val * 16 + (cur - &#39;0&#39;);
 2407         else if ((cur &gt;= &#39;a&#39;) &amp;&amp; (cur &lt;= &#39;f&#39;))
 2408             val = val * 16 + (cur - &#39;a&#39;) + 10;
 2409         else if ((cur &gt;= &#39;A&#39;) &amp;&amp; (cur &lt;= &#39;F&#39;))
 2410             val = val * 16 + (cur - &#39;A&#39;) + 10;
 2411         else {
 2412         xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);
 2413         val = 0;
 2414         break;
 2415         }
<span class="line-modified"> 2416         if (val &gt; 0x10FFFF)</span>
<span class="line-modified"> 2417             outofrange = val;</span>
 2418 
 2419         ptr++;
 2420         cur = *ptr;
 2421     }
 2422     if (cur == &#39;;&#39;)
 2423         ptr++;
 2424     } else if  ((cur == &#39;&amp;&#39;) &amp;&amp; (ptr[1] == &#39;#&#39;)){
 2425     ptr += 2;
 2426     cur = *ptr;
 2427     while (cur != &#39;;&#39;) { /* Non input consuming loops */
 2428         if ((cur &gt;= &#39;0&#39;) &amp;&amp; (cur &lt;= &#39;9&#39;))
 2429             val = val * 10 + (cur - &#39;0&#39;);
 2430         else {
 2431         xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);
 2432         val = 0;
 2433         break;
 2434         }
<span class="line-modified"> 2435         if (val &gt; 0x10FFFF)</span>
<span class="line-modified"> 2436             outofrange = val;</span>
 2437 
 2438         ptr++;
 2439         cur = *ptr;
 2440     }
 2441     if (cur == &#39;;&#39;)
 2442         ptr++;
 2443     } else {
 2444     xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);
 2445     return(0);
 2446     }
 2447     *str = ptr;
 2448 
 2449     /*
 2450      * [ WFC: Legal Character ]
 2451      * Characters referred to using character references must match the
 2452      * production for Char.
 2453      */
<span class="line-modified"> 2454     if ((IS_CHAR(val) &amp;&amp; (outofrange == 0))) {</span>




 2455         return(val);
 2456     } else {
 2457         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 2458               &quot;xmlParseStringCharRef: invalid xmlChar value %d\n&quot;,
 2459               val);
 2460     }
 2461     return(0);
 2462 }
 2463 
 2464 /**
 2465  * xmlParserHandlePEReference:
 2466  * @ctxt:  the parser context
 2467  *
 2468  * [69] PEReference ::= &#39;%&#39; Name &#39;;&#39;
 2469  *
 2470  * [ WFC: No Recursion ]
 2471  * A parsed entity must not contain a recursive
 2472  * reference to itself, either directly or indirectly.
 2473  *
 2474  * [ WFC: Entity Declared ]
</pre>
<hr />
<pre>
 2685         if (nbchars + i + XML_PARSER_BUFFER_SIZE &gt; buffer_size) {
 2686             growBuffer(buffer, i + XML_PARSER_BUFFER_SIZE);
 2687         }
 2688         for (;i &gt; 0;i--)
 2689             buffer[nbchars++] = *cur++;
 2690         buffer[nbchars++] = &#39;;&#39;;
 2691         }
 2692     } else if (c == &#39;%&#39; &amp;&amp; (what &amp; XML_SUBSTITUTE_PEREF)) {
 2693         if (xmlParserDebugEntities)
 2694         xmlGenericError(xmlGenericErrorContext,
 2695             &quot;String decoding PE Reference: %.30s\n&quot;, str);
 2696         ent = xmlParseStringPEReference(ctxt, &amp;str);
 2697         xmlParserEntityCheck(ctxt, 0, ent, 0);
 2698         if (ent != NULL)
 2699             ctxt-&gt;nbentities += ent-&gt;checked / 2;
 2700         if (ent != NULL) {
 2701                 if (ent-&gt;content == NULL) {
 2702             /*
 2703              * Note: external parsed entities will not be loaded,
 2704              * it is not required for a non-validating parser to
<span class="line-modified"> 2705              * complete external PEreferences coming from the</span>
 2706              * internal subset
 2707              */
 2708             if (((ctxt-&gt;options &amp; XML_PARSE_NOENT) != 0) ||
 2709             ((ctxt-&gt;options &amp; XML_PARSE_DTDVALID) != 0) ||
 2710             (ctxt-&gt;validate != 0)) {
 2711             xmlLoadEntityContent(ctxt, ent);
 2712             } else {
 2713             xmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
 2714           &quot;not validating will not read content for PE entity %s\n&quot;,
 2715                               ent-&gt;name, NULL);
 2716             }
 2717         }
 2718         ctxt-&gt;depth++;
 2719         rep = xmlStringDecodeEntities(ctxt, ent-&gt;content, what,
 2720                                   0, 0, 0);
 2721         ctxt-&gt;depth--;
 2722         if (rep == NULL)
 2723                     goto int_error;
 2724                 current = rep;
 2725                 while (*current != 0) { /* non input consuming loop */
</pre>
<hr />
<pre>
 3349        (xmlIsNameChar(ctxt, c) &amp;&amp; (c != &#39;:&#39;))) {
 3350     if (count++ &gt; XML_PARSER_CHUNK_SIZE) {
 3351             if ((len &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3352                 ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3353                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;NCName&quot;);
 3354                 return(NULL);
 3355             }
 3356         count = 0;
 3357         GROW;
 3358             if (ctxt-&gt;instate == XML_PARSER_EOF)
 3359                 return(NULL);
 3360     }
 3361     len += l;
 3362     NEXTL(l);
 3363     c = CUR_CHAR(l);
 3364     if (c == 0) {
 3365         count = 0;
 3366         /*
 3367          * when shrinking to extend the buffer we really need to preserve
 3368          * the part of the name we already parsed. Hence rolling back
<span class="line-modified"> 3369          * by current lenght.</span>
 3370          */
 3371         ctxt-&gt;input-&gt;cur -= l;
 3372         GROW;
 3373             if (ctxt-&gt;instate == XML_PARSER_EOF)
 3374                 return(NULL);
 3375         ctxt-&gt;input-&gt;cur += l;
 3376         c = CUR_CHAR(l);
 3377     }
 3378     }
 3379     if ((len &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3380         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3381         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;NCName&quot;);
 3382         return(NULL);
 3383     }
 3384     return(xmlDictLookup(ctxt-&gt;dict, (BASE_PTR + startPosition), len));
 3385 }
 3386 
 3387 /**
 3388  * xmlParseNCName:
 3389  * @ctxt:  an XML parser context
</pre>
<hr />
<pre>
 3818      */
 3819     ++ctxt-&gt;depth;
 3820     ret = xmlStringDecodeEntities(ctxt, buf, XML_SUBSTITUTE_PEREF,
 3821                                   0, 0, 0);
 3822     --ctxt-&gt;depth;
 3823     if (orig != NULL) {
 3824         *orig = buf;
 3825         buf = NULL;
 3826     }
 3827 
 3828 error:
 3829     if (buf != NULL)
 3830         xmlFree(buf);
 3831     return(ret);
 3832 }
 3833 
 3834 /**
 3835  * xmlParseAttValueComplex:
 3836  * @ctxt:  an XML parser context
 3837  * @len:   the resulting attribute len
<span class="line-modified"> 3838  * @normalize:  wether to apply the inner normalization</span>
 3839  *
 3840  * parse a value for an attribute, this is the fallback function
 3841  * of xmlParseAttValue() when the attribute parsing requires handling
 3842  * of non-ASCII characters, or normalization compaction.
 3843  *
 3844  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.
 3845  */
 3846 static xmlChar *
 3847 xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
 3848     xmlChar limit = 0;
 3849     xmlChar *buf = NULL;
 3850     xmlChar *rep = NULL;
 3851     size_t len = 0;
 3852     size_t buf_size = 0;
 3853     int c, l, in_space = 0;
 3854     xmlChar *current = NULL;
 3855     xmlEntityPtr ent;
 3856 
 3857     if (NXT(0) == &#39;&quot;&#39;) {
 3858     ctxt-&gt;instate = XML_PARSER_ATTRIBUTE_VALUE;
</pre>
<hr />
<pre>
 3967                 xmlFree(rep);
 3968                 rep = NULL;
 3969             }
 3970             } else {
 3971             if (len + 10 &gt; buf_size) {
 3972                 growBuffer(buf, 10);
 3973             }
 3974             if (ent-&gt;content != NULL)
 3975                 buf[len++] = ent-&gt;content[0];
 3976             }
 3977         } else if (ent != NULL) {
 3978             int i = xmlStrlen(ent-&gt;name);
 3979             const xmlChar *cur = ent-&gt;name;
 3980 
 3981             /*
 3982              * This may look absurd but is needed to detect
 3983              * entities problems
 3984              */
 3985             if ((ent-&gt;etype != XML_INTERNAL_PREDEFINED_ENTITY) &amp;&amp;
 3986             (ent-&gt;content != NULL) &amp;&amp; (ent-&gt;checked == 0)) {
<span class="line-modified"> 3987             unsigned long oldnbent = ctxt-&gt;nbentities;</span>
 3988 
 3989             ++ctxt-&gt;depth;
 3990             rep = xmlStringDecodeEntities(ctxt, ent-&gt;content,
 3991                           XML_SUBSTITUTE_REF, 0, 0, 0);
 3992             --ctxt-&gt;depth;
 3993 
<span class="line-modified"> 3994             ent-&gt;checked = (ctxt-&gt;nbentities - oldnbent + 1) * 2;</span>



 3995             if (rep != NULL) {
 3996                 if (xmlStrchr(rep, &#39;&lt;&#39;))
 3997                     ent-&gt;checked |= 1;
 3998                 xmlFree(rep);
 3999                 rep = NULL;
 4000             } else {
 4001                             ent-&gt;content[0] = 0;
 4002                         }
 4003             }
 4004 
 4005             /*
 4006              * Just output the reference
 4007              */
 4008             buf[len++] = &#39;&amp;&#39;;
 4009             while (len + i + 10 &gt; buf_size) {
 4010             growBuffer(buf, i + 10);
 4011             }
 4012             for (;i &gt; 0;i--)
 4013             buf[len++] = *cur++;
 4014             buf[len++] = &#39;;&#39;;
</pre>
<hr />
<pre>
 4042 
 4043     if ((in_space) &amp;&amp; (normalize)) {
 4044         while ((len &gt; 0) &amp;&amp; (buf[len - 1] == 0x20)) len--;
 4045     }
 4046     buf[len] = 0;
 4047     if (RAW == &#39;&lt;&#39;) {
 4048     xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);
 4049     } else if (RAW != limit) {
 4050     if ((c != 0) &amp;&amp; (!IS_CHAR(c))) {
 4051         xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
 4052                &quot;invalid character in attribute value\n&quot;);
 4053     } else {
 4054         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 4055                &quot;AttValue: &#39; expected\n&quot;);
 4056         }
 4057     } else
 4058     NEXT;
 4059 
 4060     /*
 4061      * There we potentially risk an overflow, don&#39;t allow attribute value of
<span class="line-modified"> 4062      * length more than INT_MAX it is a very reasonnable assumption !</span>
 4063      */
 4064     if (len &gt;= INT_MAX) {
 4065         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 4066                        &quot;AttValue length too long\n&quot;);
 4067         goto mem_error;
 4068     }
 4069 
 4070     if (attlen != NULL) *attlen = (int) len;
 4071     return(buf);
 4072 
 4073 mem_error:
 4074     xmlErrMemory(ctxt, NULL);
 4075 error:
 4076     if (buf != NULL)
 4077         xmlFree(buf);
 4078     if (rep != NULL)
 4079         xmlFree(rep);
 4080     return(NULL);
 4081 }
 4082 
</pre>
<hr />
<pre>
 4647          * We handle [83] so we return immediately, if
 4648          * &quot;S SystemLiteral&quot; is not detected. We skip blanks if no
 4649              * system literal was found, but this is harmless since we must
 4650              * be at the end of a NotationDecl.
 4651          */
 4652         if (SKIP_BLANKS == 0) return(NULL);
 4653         if ((CUR != &#39;\&#39;&#39;) &amp;&amp; (CUR != &#39;&quot;&#39;)) return(NULL);
 4654     }
 4655     URI = xmlParseSystemLiteral(ctxt);
 4656     if (URI == NULL) {
 4657         xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);
 4658         }
 4659     }
 4660     return(URI);
 4661 }
 4662 
 4663 /**
 4664  * xmlParseCommentComplex:
 4665  * @ctxt:  an XML parser context
 4666  * @buf:  the already parsed part of the buffer
<span class="line-modified"> 4667  * @len:  number of bytes filles in the buffer</span>
 4668  * @size:  allocated size of the buffer
 4669  *
 4670  * Skip an XML (SGML) comment &lt;!-- .... --&gt;
 4671  *  The spec says that &quot;For compatibility, the string &quot;--&quot; (double-hyphen)
 4672  *  must not occur within comments. &quot;
 4673  * This is the slow routine in case the accelerator for ascii didn&#39;t work
 4674  *
 4675  * [15] Comment ::= &#39;&lt;!--&#39; ((Char - &#39;-&#39;) | (&#39;-&#39; (Char - &#39;-&#39;)))* &#39;--&gt;&#39;
 4676  */
 4677 static void
 4678 xmlParseCommentComplex(xmlParserCtxtPtr ctxt, xmlChar *buf,
 4679                        size_t len, size_t size) {
 4680     int q, ql;
 4681     int r, rl;
 4682     int cur, l;
 4683     size_t count = 0;
 4684     int inputid;
 4685 
 4686     inputid = ctxt-&gt;input-&gt;id;
 4687 
</pre>
<hr />
<pre>
 4938                 (!ctxt-&gt;disableSAX)) {
 4939             if (buf != NULL)
 4940                 ctxt-&gt;sax-&gt;comment(ctxt-&gt;userData, buf);
 4941             else
 4942                 ctxt-&gt;sax-&gt;comment(ctxt-&gt;userData, BAD_CAST &quot;&quot;);
 4943             }
 4944             if (buf != NULL)
 4945                 xmlFree(buf);
 4946             if (ctxt-&gt;instate != XML_PARSER_EOF)
 4947             ctxt-&gt;instate = state;
 4948             return;
 4949         }
 4950         if (buf != NULL) {
 4951             xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
 4952                               &quot;Double hyphen within comment: &quot;
 4953                                       &quot;&lt;!--%.50s\n&quot;,
 4954                       buf);
 4955         } else
 4956             xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
 4957                               &quot;Double hyphen within comment\n&quot;, NULL);




 4958         in++;
 4959         ctxt-&gt;input-&gt;col++;
 4960         }
 4961         in++;
 4962         ctxt-&gt;input-&gt;col++;
 4963         goto get_more;
 4964     }
 4965     } while (((*in &gt;= 0x20) &amp;&amp; (*in &lt;= 0x7F)) || (*in == 0x09));
 4966     xmlParseCommentComplex(ctxt, buf, len, size);
 4967     ctxt-&gt;instate = state;
 4968     return;
 4969 }
 4970 
 4971 
 4972 /**
 4973  * xmlParsePITarget:
 4974  * @ctxt:  an XML parser context
 4975  *
 4976  * parse the name of a PI
 4977  *
</pre>
<hr />
<pre>
 5068     }
 5069     return;
 5070 
 5071 error:
 5072     xmlWarningMsg(ctxt, XML_WAR_CATALOG_PI,
 5073               &quot;Catalog PI syntax error: %s\n&quot;,
 5074           catalog, NULL);
 5075     if (URL != NULL)
 5076     xmlFree(URL);
 5077 }
 5078 #endif
 5079 
 5080 /**
 5081  * xmlParsePI:
 5082  * @ctxt:  an XML parser context
 5083  *
 5084  * parse an XML Processing Instruction.
 5085  *
 5086  * [16] PI ::= &#39;&lt;?&#39; PITarget (S (Char* - (Char* &#39;?&gt;&#39; Char*)))? &#39;?&gt;&#39;
 5087  *
<span class="line-modified"> 5088  * The processing is transfered to SAX once parsed.</span>
 5089  */
 5090 
 5091 void
 5092 xmlParsePI(xmlParserCtxtPtr ctxt) {
 5093     xmlChar *buf = NULL;
 5094     size_t len = 0;
 5095     size_t size = XML_PARSER_BUFFER_SIZE;
 5096     int cur, l;
 5097     const xmlChar *target;
 5098     xmlParserInputState state;
 5099     int count = 0;
 5100 
 5101     if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;?&#39;)) {
 5102     int inputid = ctxt-&gt;input-&gt;id;
 5103     state = ctxt-&gt;instate;
 5104         ctxt-&gt;instate = XML_PARSER_PI;
 5105     /*
 5106      * this is a Processing Instruction.
 5107      */
 5108     SKIP(2);
</pre>
<hr />
<pre>
 5484         }
 5485         if (CMP5(CUR_PTR, &#39;N&#39;, &#39;D&#39;, &#39;A&#39;, &#39;T&#39;, &#39;A&#39;)) {
 5486             SKIP(5);
 5487             if (SKIP_BLANKS == 0) {
 5488             xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5489                        &quot;Space required after &#39;NDATA&#39;\n&quot;);
 5490             }
 5491             ndata = xmlParseName(ctxt);
 5492             if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX) &amp;&amp;
 5493                 (ctxt-&gt;sax-&gt;unparsedEntityDecl != NULL))
 5494             ctxt-&gt;sax-&gt;unparsedEntityDecl(ctxt-&gt;userData, name,
 5495                     literal, URI, ndata);
 5496         } else {
 5497             if ((ctxt-&gt;sax != NULL) &amp;&amp;
 5498                 (!ctxt-&gt;disableSAX) &amp;&amp; (ctxt-&gt;sax-&gt;entityDecl != NULL))
 5499             ctxt-&gt;sax-&gt;entityDecl(ctxt-&gt;userData, name,
 5500                     XML_EXTERNAL_GENERAL_PARSED_ENTITY,
 5501                     literal, URI, NULL);
 5502             /*
 5503              * For expat compatibility in SAX mode.
<span class="line-modified"> 5504              * assuming the entity repalcement was asked for</span>
 5505              */
 5506             if ((ctxt-&gt;replaceEntities != 0) &amp;&amp;
 5507             ((ctxt-&gt;myDoc == NULL) ||
 5508             (xmlStrEqual(ctxt-&gt;myDoc-&gt;version, SAX_COMPAT_MODE)))) {
 5509             if (ctxt-&gt;myDoc == NULL) {
 5510                 ctxt-&gt;myDoc = xmlNewDoc(SAX_COMPAT_MODE);
 5511                 if (ctxt-&gt;myDoc == NULL) {
 5512                     xmlErrMemory(ctxt, &quot;New Doc failed&quot;);
 5513                 return;
 5514                 }
 5515                 ctxt-&gt;myDoc-&gt;properties = XML_DOC_INTERNAL;
 5516             }
 5517 
 5518             if (ctxt-&gt;myDoc-&gt;intSubset == NULL)
 5519                 ctxt-&gt;myDoc-&gt;intSubset = xmlNewDtd(ctxt-&gt;myDoc,
 5520                         BAD_CAST &quot;fake&quot;, NULL, NULL);
 5521             xmlSAX2EntityDecl(ctxt, name,
 5522                           XML_EXTERNAL_GENERAL_PARSED_ENTITY,
 5523                           literal, URI, NULL);
 5524             }
</pre>
<hr />
<pre>
 6594         xmlFreeDocElementContent(ctxt-&gt;myDoc, content);
 6595         }
 6596     }
 6597     }
 6598     return(ret);
 6599 }
 6600 
 6601 /**
 6602  * xmlParseConditionalSections
 6603  * @ctxt:  an XML parser context
 6604  *
 6605  * [61] conditionalSect ::= includeSect | ignoreSect
 6606  * [62] includeSect ::= &#39;&lt;![&#39; S? &#39;INCLUDE&#39; S? &#39;[&#39; extSubsetDecl &#39;]]&gt;&#39;
 6607  * [63] ignoreSect ::= &#39;&lt;![&#39; S? &#39;IGNORE&#39; S? &#39;[&#39; ignoreSectContents* &#39;]]&gt;&#39;
 6608  * [64] ignoreSectContents ::= Ignore (&#39;&lt;![&#39; ignoreSectContents &#39;]]&gt;&#39; Ignore)*
 6609  * [65] Ignore ::= Char* - (Char* (&#39;&lt;![&#39; | &#39;]]&gt;&#39;) Char*)
 6610  */
 6611 
 6612 static void
 6613 xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {






 6614     int id = ctxt-&gt;input-&gt;id;
 6615 
 6616     SKIP(3);
 6617     SKIP_BLANKS;

 6618     if (CMP7(CUR_PTR, &#39;I&#39;, &#39;N&#39;, &#39;C&#39;, &#39;L&#39;, &#39;U&#39;, &#39;D&#39;, &#39;E&#39;)) {
 6619     SKIP(7);
 6620     SKIP_BLANKS;
 6621     if (RAW != &#39;[&#39;) {
 6622         xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
 6623         xmlHaltParser(ctxt);
<span class="line-modified"> 6624         return;</span>
<span class="line-modified"> 6625     } else {</span>
 6626         if (ctxt-&gt;input-&gt;id != id) {
 6627         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
<span class="line-modified"> 6628                            &quot;All markup of the conditional section is not&quot;</span>
<span class="line-modified"> 6629                                &quot; in the same entity\n&quot;);</span>
 6630         }
 6631         NEXT;
<span class="line-removed"> 6632     }</span>
<span class="line-removed"> 6633     if (xmlParserDebugEntities) {</span>
<span class="line-removed"> 6634         if ((ctxt-&gt;input != NULL) &amp;&amp; (ctxt-&gt;input-&gt;filename))</span>
<span class="line-removed"> 6635         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed"> 6636             &quot;%s(%d): &quot;, ctxt-&gt;input-&gt;filename,</span>
<span class="line-removed"> 6637             ctxt-&gt;input-&gt;line);</span>
<span class="line-removed"> 6638         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed"> 6639             &quot;Entering INCLUDE Conditional Section\n&quot;);</span>
<span class="line-removed"> 6640     }</span>
 6641 
<span class="line-modified"> 6642         SKIP_BLANKS;</span>
<span class="line-modified"> 6643         GROW;</span>
<span class="line-removed"> 6644     while (((RAW != 0) &amp;&amp; ((RAW != &#39;]&#39;) || (NXT(1) != &#39;]&#39;) ||</span>
<span class="line-removed"> 6645             (NXT(2) != &#39;&gt;&#39;))) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF)) {</span>
<span class="line-removed"> 6646         const xmlChar *check = CUR_PTR;</span>
<span class="line-removed"> 6647         unsigned int cons = ctxt-&gt;input-&gt;consumed;</span>
<span class="line-removed"> 6648 </span>
<span class="line-removed"> 6649         if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {</span>
<span class="line-removed"> 6650         xmlParseConditionalSections(ctxt);</span>
<span class="line-removed"> 6651         } else</span>
<span class="line-removed"> 6652         xmlParseMarkupDecl(ctxt);</span>
<span class="line-removed"> 6653 </span>
<span class="line-removed"> 6654             SKIP_BLANKS;</span>
<span class="line-removed"> 6655             GROW;</span>
 6656 
<span class="line-modified"> 6657         if ((CUR_PTR == check) &amp;&amp; (cons == ctxt-&gt;input-&gt;consumed)) {</span>
<span class="line-modified"> 6658         xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);</span>
<span class="line-modified"> 6659         xmlHaltParser(ctxt);</span>
<span class="line-modified"> 6660         break;</span>


 6661         }

 6662     }
<span class="line-modified"> 6663     if (xmlParserDebugEntities) {</span>
<span class="line-modified"> 6664         if ((ctxt-&gt;input != NULL) &amp;&amp; (ctxt-&gt;input-&gt;filename))</span>
<span class="line-removed"> 6665         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed"> 6666             &quot;%s(%d): &quot;, ctxt-&gt;input-&gt;filename,</span>
<span class="line-removed"> 6667             ctxt-&gt;input-&gt;line);</span>
<span class="line-removed"> 6668         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed"> 6669             &quot;Leaving INCLUDE Conditional Section\n&quot;);</span>
<span class="line-removed"> 6670     }</span>
<span class="line-removed"> 6671 </span>
 6672     } else if (CMP6(CUR_PTR, &#39;I&#39;, &#39;G&#39;, &#39;N&#39;, &#39;O&#39;, &#39;R&#39;, &#39;E&#39;)) {
 6673     int state;
 6674     xmlParserInputState instate;
<span class="line-modified"> 6675     int depth = 0;</span>
 6676 
 6677     SKIP(6);
 6678     SKIP_BLANKS;
 6679     if (RAW != &#39;[&#39;) {
 6680         xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
 6681         xmlHaltParser(ctxt);
<span class="line-modified"> 6682         return;</span>
<span class="line-modified"> 6683     } else {</span>
 6684         if (ctxt-&gt;input-&gt;id != id) {
 6685         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
<span class="line-modified"> 6686                            &quot;All markup of the conditional section is not&quot;</span>
<span class="line-modified"> 6687                                &quot; in the same entity\n&quot;);</span>
 6688         }
 6689         NEXT;
<span class="line-removed"> 6690     }</span>
<span class="line-removed"> 6691     if (xmlParserDebugEntities) {</span>
<span class="line-removed"> 6692         if ((ctxt-&gt;input != NULL) &amp;&amp; (ctxt-&gt;input-&gt;filename))</span>
<span class="line-removed"> 6693         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed"> 6694             &quot;%s(%d): &quot;, ctxt-&gt;input-&gt;filename,</span>
<span class="line-removed"> 6695             ctxt-&gt;input-&gt;line);</span>
<span class="line-removed"> 6696         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed"> 6697             &quot;Entering IGNORE Conditional Section\n&quot;);</span>
<span class="line-removed"> 6698     }</span>
 6699 
 6700     /*
<span class="line-modified"> 6701      * Parse up to the end of the conditional section</span>
<span class="line-modified"> 6702      * But disable SAX event generating DTD building in the meantime</span>
 6703      */
 6704     state = ctxt-&gt;disableSAX;
 6705     instate = ctxt-&gt;instate;
 6706     if (ctxt-&gt;recovery == 0) ctxt-&gt;disableSAX = 1;
 6707     ctxt-&gt;instate = XML_PARSER_IGNORE;
 6708 
<span class="line-modified"> 6709     while (((depth &gt;= 0) &amp;&amp; (RAW != 0)) &amp;&amp;</span>
<span class="line-removed"> 6710                (ctxt-&gt;instate != XML_PARSER_EOF)) {</span>
 6711       if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {
<span class="line-removed"> 6712         depth++;</span>
 6713         SKIP(3);
<span class="line-modified"> 6714         continue;</span>
<span class="line-modified"> 6715       }</span>
<span class="line-modified"> 6716       if ((RAW == &#39;]&#39;) &amp;&amp; (NXT(1) == &#39;]&#39;) &amp;&amp; (NXT(2) == &#39;&gt;&#39;)) {</span>
<span class="line-modified"> 6717         if (--depth &gt;= 0) SKIP(3);</span>
<span class="line-modified"> 6718         continue;</span>
 6719       }







 6720       NEXT;
<span class="line-modified"> 6721       continue;</span>
 6722     }
 6723 
 6724     ctxt-&gt;disableSAX = state;
 6725     ctxt-&gt;instate = instate;
 6726 
<span class="line-modified"> 6727     if (xmlParserDebugEntities) {</span>
<span class="line-modified"> 6728         if ((ctxt-&gt;input != NULL) &amp;&amp; (ctxt-&gt;input-&gt;filename))</span>
<span class="line-modified"> 6729         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed"> 6730             &quot;%s(%d): &quot;, ctxt-&gt;input-&gt;filename,</span>
<span class="line-removed"> 6731             ctxt-&gt;input-&gt;line);</span>
<span class="line-removed"> 6732         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed"> 6733             &quot;Leaving IGNORE Conditional Section\n&quot;);</span>
 6734     }
<span class="line-modified"> 6735 </span>





 6736     } else {
 6737     xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID_KEYWORD, NULL);
 6738     xmlHaltParser(ctxt);
<span class="line-modified"> 6739     return;</span>
 6740     }
<span class="line-modified"> 6741 </span>
<span class="line-modified"> 6742     if (RAW == 0)</span>
<span class="line-modified"> 6743         SHRINK;</span>
<span class="line-modified"> 6744 </span>
<span class="line-removed"> 6745     if (RAW == 0) {</span>
<span class="line-removed"> 6746     xmlFatalErr(ctxt, XML_ERR_CONDSEC_NOT_FINISHED, NULL);</span>
<span class="line-removed"> 6747     } else {</span>
<span class="line-removed"> 6748     if (ctxt-&gt;input-&gt;id != id) {</span>
 6749         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
<span class="line-modified"> 6750                        &quot;All markup of the conditional section is not in&quot;</span>
<span class="line-modified"> 6751                            &quot; the same entity\n&quot;);</span>
 6752     }
<span class="line-removed"> 6753     if ((ctxt-&gt; instate != XML_PARSER_EOF) &amp;&amp;</span>
<span class="line-removed"> 6754         ((ctxt-&gt;input-&gt;cur + 3) &lt;= ctxt-&gt;input-&gt;end))</span>
 6755         SKIP(3);


















 6756     }



 6757 }
 6758 
 6759 /**
 6760  * xmlParseMarkupDecl:
 6761  * @ctxt:  an XML parser context
 6762  *
 6763  * parse Markup declarations
 6764  *
 6765  * [29] markupdecl ::= elementdecl | AttlistDecl | EntityDecl |
 6766  *                     NotationDecl | PI | Comment
 6767  *
 6768  * [ VC: Proper Declaration/PE Nesting ]
 6769  * Parameter-entity replacement text must be properly nested with
 6770  * markup declarations. That is to say, if either the first character
 6771  * or the last character of a markup declaration (markupdecl above) is
 6772  * contained in the replacement text for a parameter-entity reference,
 6773  * both must be contained in the same replacement text.
 6774  *
 6775  * [ WFC: PEs in Internal Subset ]
 6776  * In the internal DTD subset, parameter-entity references can occur
</pre>
<hr />
<pre>
 6793             case &#39;A&#39;:
 6794             xmlParseAttributeListDecl(ctxt);
 6795             break;
 6796             case &#39;N&#39;:
 6797             xmlParseNotationDecl(ctxt);
 6798             break;
 6799             case &#39;-&#39;:
 6800             xmlParseComment(ctxt);
 6801             break;
 6802         default:
 6803             /* there is an error but it will be detected later */
 6804             break;
 6805         }
 6806     } else if (NXT(1) == &#39;?&#39;) {
 6807         xmlParsePI(ctxt);
 6808     }
 6809     }
 6810 
 6811     /*
 6812      * detect requirement to exit there and act accordingly
<span class="line-modified"> 6813      * and avoid having instate overriden later on</span>
 6814      */
 6815     if (ctxt-&gt;instate == XML_PARSER_EOF)
 6816         return;
 6817 
<span class="line-removed"> 6818     /*</span>
<span class="line-removed"> 6819      * Conditional sections are allowed from entities included</span>
<span class="line-removed"> 6820      * by PE References in the internal subset.</span>
<span class="line-removed"> 6821      */</span>
<span class="line-removed"> 6822     if ((ctxt-&gt;external == 0) &amp;&amp; (ctxt-&gt;inputNr &gt; 1)) {</span>
<span class="line-removed"> 6823         if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {</span>
<span class="line-removed"> 6824         xmlParseConditionalSections(ctxt);</span>
<span class="line-removed"> 6825     }</span>
<span class="line-removed"> 6826     }</span>
<span class="line-removed"> 6827 </span>
 6828     ctxt-&gt;instate = XML_PARSER_DTD;
 6829 }
 6830 
 6831 /**
 6832  * xmlParseTextDecl:
 6833  * @ctxt:  an XML parser context
 6834  *
 6835  * parse an XML declaration header for external entities
 6836  *
 6837  * [77] TextDecl ::= &#39;&lt;?xml&#39; VersionInfo? EncodingDecl S? &#39;?&gt;&#39;
 6838  */
 6839 
 6840 void
 6841 xmlParseTextDecl(xmlParserCtxtPtr ctxt) {
 6842     xmlChar *version;
 6843     const xmlChar *encoding;
 6844 
 6845     /*
 6846      * We know that &#39;&lt;?xml&#39; is here.
 6847      */
</pre>
<hr />
<pre>
 6992  *
 6993  * [67] Reference ::= EntityRef | CharRef
 6994  */
 6995 void
 6996 xmlParseReference(xmlParserCtxtPtr ctxt) {
 6997     xmlEntityPtr ent;
 6998     xmlChar *val;
 6999     int was_checked;
 7000     xmlNodePtr list = NULL;
 7001     xmlParserErrors ret = XML_ERR_OK;
 7002 
 7003 
 7004     if (RAW != &#39;&amp;&#39;)
 7005         return;
 7006 
 7007     /*
 7008      * Simple case of a CharRef
 7009      */
 7010     if (NXT(1) == &#39;#&#39;) {
 7011     int i = 0;
<span class="line-modified"> 7012     xmlChar out[10];</span>
 7013     int hex = NXT(2);
 7014     int value = xmlParseCharRef(ctxt);
 7015 
 7016     if (value == 0)
 7017         return;
 7018     if (ctxt-&gt;charset != XML_CHAR_ENCODING_UTF8) {
 7019         /*
 7020          * So we are using non-UTF-8 buffers
 7021          * Check that the char fit on 8bits, if not
 7022          * generate a CharRef.
 7023          */
 7024         if (value &lt;= 0xFF) {
 7025         out[0] = value;
 7026         out[1] = 0;
 7027         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;characters != NULL) &amp;&amp;
 7028             (!ctxt-&gt;disableSAX))
 7029             ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, out, 1);
 7030         } else {
 7031         if ((hex == &#39;x&#39;) || (hex == &#39;X&#39;))
 7032             snprintf((char *)out, sizeof(out), &quot;#x%X&quot;, value);
</pre>
<hr />
<pre>
 7069     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;characters != NULL) &amp;&amp;
 7070         (!ctxt-&gt;disableSAX))
 7071         ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, val, xmlStrlen(val));
 7072     return;
 7073     }
 7074 
 7075     /*
 7076      * The first reference to the entity trigger a parsing phase
 7077      * where the ent-&gt;children is filled with the result from
 7078      * the parsing.
 7079      * Note: external parsed entities will not be loaded, it is not
 7080      * required for a non-validating parser, unless the parsing option
 7081      * of validating, or substituting entities were given. Doing so is
 7082      * far more secure as the parser will only process data coming from
 7083      * the document entity by default.
 7084      */
 7085     if (((ent-&gt;checked == 0) ||
 7086          ((ent-&gt;children == NULL) &amp;&amp; (ctxt-&gt;options &amp; XML_PARSE_NOENT))) &amp;&amp;
 7087         ((ent-&gt;etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
 7088          (ctxt-&gt;options &amp; (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {
<span class="line-modified"> 7089     unsigned long oldnbent = ctxt-&gt;nbentities;</span>
 7090 
 7091     /*
 7092      * This is a bit hackish but this seems the best
 7093      * way to make sure both SAX and DOM entity support
 7094      * behaves okay.
 7095      */
 7096     void *user_data;
 7097     if (ctxt-&gt;userData == ctxt)
 7098         user_data = NULL;
 7099     else
 7100         user_data = ctxt-&gt;userData;
 7101 
 7102     /*
 7103      * Check that this entity is well formed
 7104      * 4.3.2: An internal general parsed entity is well-formed
 7105      * if its replacement text matches the production labeled
 7106      * content.
 7107      */
 7108     if (ent-&gt;etype == XML_INTERNAL_GENERAL_ENTITY) {
 7109         ctxt-&gt;depth++;
 7110         ret = xmlParseBalancedChunkMemoryInternal(ctxt, ent-&gt;content,
 7111                                                   user_data, &amp;list);
 7112         ctxt-&gt;depth--;
 7113 
 7114     } else if (ent-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
 7115         ctxt-&gt;depth++;
 7116         ret = xmlParseExternalEntityPrivate(ctxt-&gt;myDoc, ctxt, ctxt-&gt;sax,
 7117                                        user_data, ctxt-&gt;depth, ent-&gt;URI,
 7118                        ent-&gt;ExternalID, &amp;list);
 7119         ctxt-&gt;depth--;
 7120     } else {
 7121         ret = XML_ERR_ENTITY_PE_INTERNAL;
 7122         xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,
 7123              &quot;invalid entity type found\n&quot;, NULL);
 7124     }
 7125 
 7126     /*
 7127      * Store the number of entities needing parsing for this entity
 7128      * content and do checkings
 7129      */
<span class="line-modified"> 7130     ent-&gt;checked = (ctxt-&gt;nbentities - oldnbent + 1) * 2;</span>



 7131     if ((ent-&gt;content != NULL) &amp;&amp; (xmlStrchr(ent-&gt;content, &#39;&lt;&#39;)))
 7132         ent-&gt;checked |= 1;
 7133     if (ret == XML_ERR_ENTITY_LOOP) {
 7134         xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 7135         xmlFreeNodeList(list);
 7136         return;
 7137     }
 7138     if (xmlParserEntityCheck(ctxt, 0, ent, 0)) {
 7139         xmlFreeNodeList(list);
 7140         return;
 7141     }
 7142 
 7143     if ((ret == XML_ERR_OK) &amp;&amp; (list != NULL)) {
 7144         if (((ent-&gt;etype == XML_INTERNAL_GENERAL_ENTITY) ||
 7145          (ent-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY))&amp;&amp;
 7146         (ent-&gt;children == NULL)) {
 7147         ent-&gt;children = list;
 7148         if (ctxt-&gt;replaceEntities) {
 7149             /*
 7150              * Prune it directly in the generated document
</pre>
<hr />
<pre>
 7658         xmlFree(name);
 7659     *str = ptr;
 7660     return(NULL);
 7661     }
 7662     ptr++;
 7663 
 7664 
 7665     /*
 7666      * Predefined entities override any extra definition
 7667      */
 7668     if ((ctxt-&gt;options &amp; XML_PARSE_OLDSAX) == 0) {
 7669         ent = xmlGetPredefinedEntity(name);
 7670         if (ent != NULL) {
 7671             xmlFree(name);
 7672             *str = ptr;
 7673             return(ent);
 7674         }
 7675     }
 7676 
 7677     /*
<span class="line-modified"> 7678      * Increate the number of entity references parsed</span>
 7679      */
 7680     ctxt-&gt;nbentities++;
 7681 
 7682     /*
 7683      * Ask first SAX for entity resolution, otherwise try the
 7684      * entities which may have stored in the parser context.
 7685      */
 7686     if (ctxt-&gt;sax != NULL) {
 7687     if (ctxt-&gt;sax-&gt;getEntity != NULL)
 7688         ent = ctxt-&gt;sax-&gt;getEntity(ctxt-&gt;userData, name);
 7689     if ((ent == NULL) &amp;&amp; (ctxt-&gt;options &amp; XML_PARSE_OLDSAX))
 7690         ent = xmlGetPredefinedEntity(name);
 7691     if ((ent == NULL) &amp;&amp; (ctxt-&gt;userData==ctxt)) {
 7692         ent = xmlSAX2GetEntity(ctxt, name);
 7693     }
 7694     }
 7695     if (ctxt-&gt;instate == XML_PARSER_EOF) {
 7696     xmlFree(name);
 7697     return(NULL);
 7698     }
</pre>
<hr />
<pre>
 7834 
 7835     if (RAW != &#39;%&#39;)
 7836         return;
 7837     NEXT;
 7838     name = xmlParseName(ctxt);
 7839     if (name == NULL) {
 7840     xmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, &quot;PEReference: no name\n&quot;);
 7841     return;
 7842     }
 7843     if (xmlParserDebugEntities)
 7844     xmlGenericError(xmlGenericErrorContext,
 7845         &quot;PEReference: %s\n&quot;, name);
 7846     if (RAW != &#39;;&#39;) {
 7847     xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);
 7848         return;
 7849     }
 7850 
 7851     NEXT;
 7852 
 7853     /*
<span class="line-modified"> 7854      * Increate the number of entity references parsed</span>
 7855      */
 7856     ctxt-&gt;nbentities++;
 7857 
 7858     /*
 7859      * Request the entity from SAX
 7860      */
 7861     if ((ctxt-&gt;sax != NULL) &amp;&amp;
 7862     (ctxt-&gt;sax-&gt;getParameterEntity != NULL))
 7863     entity = ctxt-&gt;sax-&gt;getParameterEntity(ctxt-&gt;userData, name);
 7864     if (ctxt-&gt;instate == XML_PARSER_EOF)
 7865     return;
 7866     if (entity == NULL) {
 7867     /*
 7868      * [ WFC: Entity Declared ]
 7869      * In a document without any DTD, a document with only an
 7870      * internal DTD subset which contains no parameter entity
 7871      * references, or a document with &quot;standalone=&#39;yes&#39;&quot;, ...
 7872      * ... The declaration of a parameter entity must precede
 7873      * any reference to it...
 7874      */
</pre>
<hr />
<pre>
 8100     if (cur != &#39;%&#39;)
 8101         return(NULL);
 8102     ptr++;
 8103     name = xmlParseStringName(ctxt, &amp;ptr);
 8104     if (name == NULL) {
 8105     xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 8106                &quot;xmlParseStringPEReference: no name\n&quot;);
 8107     *str = ptr;
 8108     return(NULL);
 8109     }
 8110     cur = *ptr;
 8111     if (cur != &#39;;&#39;) {
 8112     xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
 8113     xmlFree(name);
 8114     *str = ptr;
 8115     return(NULL);
 8116     }
 8117     ptr++;
 8118 
 8119     /*
<span class="line-modified"> 8120      * Increate the number of entity references parsed</span>
 8121      */
 8122     ctxt-&gt;nbentities++;
 8123 
 8124     /*
 8125      * Request the entity from SAX
 8126      */
 8127     if ((ctxt-&gt;sax != NULL) &amp;&amp;
 8128     (ctxt-&gt;sax-&gt;getParameterEntity != NULL))
 8129     entity = ctxt-&gt;sax-&gt;getParameterEntity(ctxt-&gt;userData, name);
 8130     if (ctxt-&gt;instate == XML_PARSER_EOF) {
 8131     xmlFree(name);
 8132     *str = ptr;
 8133     return(NULL);
 8134     }
 8135     if (entity == NULL) {
 8136     /*
 8137      * [ WFC: Entity Declared ]
 8138      * In a document without any DTD, a document with only an
 8139      * internal DTD subset which contains no parameter entity
 8140      * references, or a document with &quot;standalone=&#39;yes&#39;&quot;, ...
</pre>
<hr />
<pre>
 8268      * Is there any DTD definition ?
 8269      */
 8270     if (RAW == &#39;[&#39;) {
 8271         int baseInputNr = ctxt-&gt;inputNr;
 8272         ctxt-&gt;instate = XML_PARSER_DTD;
 8273         NEXT;
 8274     /*
 8275      * Parse the succession of Markup declarations and
 8276      * PEReferences.
 8277      * Subsequence (markupdecl | PEReference | S)*
 8278      */
 8279     while (((RAW != &#39;]&#39;) || (ctxt-&gt;inputNr &gt; baseInputNr)) &amp;&amp;
 8280                (ctxt-&gt;instate != XML_PARSER_EOF)) {
 8281         const xmlChar *check = CUR_PTR;
 8282         unsigned int cons = ctxt-&gt;input-&gt;consumed;
 8283 
 8284         SKIP_BLANKS;
 8285         xmlParseMarkupDecl(ctxt);
 8286         xmlParsePEReference(ctxt);
 8287 









 8288         if ((CUR_PTR == check) &amp;&amp; (cons == ctxt-&gt;input-&gt;consumed)) {
 8289         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 8290          &quot;xmlParseInternalSubset: error detected in Markup declaration\n&quot;);
 8291                 if (ctxt-&gt;inputNr &gt; baseInputNr)
 8292                     xmlPopInput(ctxt);
 8293                 else
 8294             break;
 8295         }
 8296     }
 8297     if (RAW == &#39;]&#39;) {
 8298         NEXT;
 8299         SKIP_BLANKS;
 8300     }
 8301     }
 8302 
 8303     /*
 8304      * We should be at the end of the DOCTYPE declaration.
 8305      */
 8306     if (RAW != &#39;&gt;&#39;) {
 8307     xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);
</pre>
<hr />
<pre>
 8696     l = xmlParseNCName(ctxt);
 8697     if (l == NULL) {
 8698         if (CUR == &#39;:&#39;) {
 8699         l = xmlParseName(ctxt);
 8700         if (l != NULL) {
 8701             xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8702                  &quot;Failed to parse QName &#39;%s&#39;\n&quot;, l, NULL, NULL);
 8703         *prefix = NULL;
 8704         return(l);
 8705         }
 8706     }
 8707         return(NULL);
 8708     }
 8709     if (CUR == &#39;:&#39;) {
 8710         NEXT;
 8711     p = l;
 8712     l = xmlParseNCName(ctxt);
 8713     if (l == NULL) {
 8714         xmlChar *tmp;
 8715 


 8716             xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8717                  &quot;Failed to parse QName &#39;%s:&#39;\n&quot;, p, NULL, NULL);
 8718         l = xmlParseNmtoken(ctxt);
<span class="line-modified"> 8719         if (l == NULL)</span>


 8720         tmp = xmlBuildQName(BAD_CAST &quot;&quot;, p, NULL, 0);
<span class="line-modified"> 8721         else {</span>
 8722         tmp = xmlBuildQName(l, p, NULL, 0);
 8723         xmlFree((char *)l);
 8724         }
 8725         p = xmlDictLookup(ctxt-&gt;dict, tmp, -1);
 8726         if (tmp != NULL) xmlFree(tmp);
 8727         *prefix = NULL;
 8728         return(p);
 8729     }
 8730     if (CUR == &#39;:&#39;) {
 8731         xmlChar *tmp;
 8732 
 8733             xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8734                  &quot;Failed to parse QName &#39;%s:%s:&#39;\n&quot;, p, l, NULL);
 8735         NEXT;
 8736         tmp = (xmlChar *) xmlParseName(ctxt);
 8737         if (tmp != NULL) {
 8738             tmp = xmlBuildQName(tmp, l, NULL, 0);
 8739         l = xmlDictLookup(ctxt-&gt;dict, tmp, -1);
 8740         if (tmp != NULL) xmlFree(tmp);
 8741         *prefix = p;
 8742         return(l);
 8743         }


 8744         tmp = xmlBuildQName(BAD_CAST &quot;&quot;, l, NULL, 0);
 8745         l = xmlDictLookup(ctxt-&gt;dict, tmp, -1);
 8746         if (tmp != NULL) xmlFree(tmp);
 8747         *prefix = p;
 8748         return(l);
 8749     }
 8750     *prefix = p;
 8751     } else
 8752         *prefix = NULL;
 8753     return(l);
 8754 }
 8755 
 8756 /**
 8757  * xmlParseQNameAndCompare:
 8758  * @ctxt:  an XML parser context
 8759  * @name:  the localname
 8760  * @prefix:  the prefix, if any.
 8761  *
 8762  * parse an XML name and compares for match
 8763  * (specialized for endtag parsing)
</pre>
<hr />
<pre>
 8823  * - a character reference is processed by appending the referenced
 8824  *   character to the attribute value
 8825  * - an entity reference is processed by recursively processing the
 8826  *   replacement text of the entity
 8827  * - a whitespace character (#x20, #xD, #xA, #x9) is processed by
 8828  *   appending #x20 to the normalized value, except that only a single
 8829  *   #x20 is appended for a &quot;#xD#xA&quot; sequence that is part of an external
 8830  *   parsed entity or the literal entity value of an internal parsed entity
 8831  * - other characters are processed by appending them to the normalized value
 8832  * If the declared value is not CDATA, then the XML processor must further
 8833  * process the normalized attribute value by discarding any leading and
 8834  * trailing space (#x20) characters, and by replacing sequences of space
 8835  * (#x20) characters by a single space (#x20) character.
 8836  * All attributes for which no declaration has been read should be treated
 8837  * by a non-validating parser as if declared CDATA.
 8838  *
 8839  * Returns the AttValue parsed or NULL. The value has to be freed by the
 8840  *     caller if it was copied, this can be detected by val[*len] == 0.
 8841  */
 8842 












 8843 static xmlChar *
 8844 xmlParseAttValueInternal(xmlParserCtxtPtr ctxt, int *len, int *alloc,
 8845                          int normalize)
 8846 {
 8847     xmlChar limit = 0;
 8848     const xmlChar *in = NULL, *start, *end, *last;
 8849     xmlChar *ret = NULL;
 8850     int line, col;
 8851 
 8852     GROW;
 8853     in = (xmlChar *) CUR_PTR;
 8854     line = ctxt-&gt;input-&gt;line;
 8855     col = ctxt-&gt;input-&gt;col;
 8856     if (*in != &#39;&quot;&#39; &amp;&amp; *in != &#39;\&#39;&#39;) {
 8857         xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
 8858         return (NULL);
 8859     }
 8860     ctxt-&gt;instate = XML_PARSER_ATTRIBUTE_VALUE;
 8861 
 8862     /*
 8863      * try to handle in this routine the most common case where no
 8864      * allocation of a new string is required and where content is
 8865      * pure ASCII.
 8866      */
 8867     limit = *in++;
 8868     col++;
 8869     end = ctxt-&gt;input-&gt;end;
 8870     start = in;
 8871     if (in &gt;= end) {
<span class="line-modified"> 8872         const xmlChar *oldbase = ctxt-&gt;input-&gt;base;</span>
<span class="line-removed"> 8873     GROW;</span>
<span class="line-removed"> 8874     if (oldbase != ctxt-&gt;input-&gt;base) {</span>
<span class="line-removed"> 8875         long delta = ctxt-&gt;input-&gt;base - oldbase;</span>
<span class="line-removed"> 8876         start = start + delta;</span>
<span class="line-removed"> 8877         in = in + delta;</span>
<span class="line-removed"> 8878     }</span>
<span class="line-removed"> 8879     end = ctxt-&gt;input-&gt;end;</span>
 8880     }
 8881     if (normalize) {
 8882         /*
 8883      * Skip any leading spaces
 8884      */
 8885     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp;
 8886            ((*in == 0x20) || (*in == 0x9) ||
 8887             (*in == 0xA) || (*in == 0xD))) {
 8888         if (*in == 0xA) {
 8889             line++; col = 1;
 8890         } else {
 8891             col++;
 8892         }
 8893         in++;
 8894         start = in;
 8895         if (in &gt;= end) {
<span class="line-modified"> 8896         const xmlChar *oldbase = ctxt-&gt;input-&gt;base;</span>
<span class="line-removed"> 8897         GROW;</span>
<span class="line-removed"> 8898                 if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-removed"> 8899                     return(NULL);</span>
<span class="line-removed"> 8900         if (oldbase != ctxt-&gt;input-&gt;base) {</span>
<span class="line-removed"> 8901             long delta = ctxt-&gt;input-&gt;base - oldbase;</span>
<span class="line-removed"> 8902             start = start + delta;</span>
<span class="line-removed"> 8903             in = in + delta;</span>
<span class="line-removed"> 8904         }</span>
<span class="line-removed"> 8905         end = ctxt-&gt;input-&gt;end;</span>
 8906                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8907                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8908                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8909                                    &quot;AttValue length too long\n&quot;);
 8910                     return(NULL);
 8911                 }
 8912         }
 8913     }
 8914     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp; (*in &gt;= 0x20) &amp;&amp;
 8915            (*in &lt;= 0x7f) &amp;&amp; (*in != &#39;&amp;&#39;) &amp;&amp; (*in != &#39;&lt;&#39;)) {
 8916         col++;
 8917         if ((*in++ == 0x20) &amp;&amp; (*in == 0x20)) break;
 8918         if (in &gt;= end) {
<span class="line-modified"> 8919         const xmlChar *oldbase = ctxt-&gt;input-&gt;base;</span>
<span class="line-removed"> 8920         GROW;</span>
<span class="line-removed"> 8921                 if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-removed"> 8922                     return(NULL);</span>
<span class="line-removed"> 8923         if (oldbase != ctxt-&gt;input-&gt;base) {</span>
<span class="line-removed"> 8924             long delta = ctxt-&gt;input-&gt;base - oldbase;</span>
<span class="line-removed"> 8925             start = start + delta;</span>
<span class="line-removed"> 8926             in = in + delta;</span>
<span class="line-removed"> 8927         }</span>
<span class="line-removed"> 8928         end = ctxt-&gt;input-&gt;end;</span>
 8929                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8930                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8931                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8932                                    &quot;AttValue length too long\n&quot;);
 8933                     return(NULL);
 8934                 }
 8935         }
 8936     }
 8937     last = in;
 8938     /*
 8939      * skip the trailing blanks
 8940      */
 8941     while ((last[-1] == 0x20) &amp;&amp; (last &gt; start)) last--;
 8942     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp;
 8943            ((*in == 0x20) || (*in == 0x9) ||
 8944             (*in == 0xA) || (*in == 0xD))) {
 8945         if (*in == 0xA) {
 8946             line++, col = 1;
 8947         } else {
 8948             col++;
 8949         }
 8950         in++;
 8951         if (in &gt;= end) {
 8952         const xmlChar *oldbase = ctxt-&gt;input-&gt;base;
 8953         GROW;
 8954                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 8955                     return(NULL);
 8956         if (oldbase != ctxt-&gt;input-&gt;base) {
<span class="line-modified"> 8957             long delta = ctxt-&gt;input-&gt;base - oldbase;</span>
 8958             start = start + delta;
 8959             in = in + delta;
 8960             last = last + delta;
 8961         }
 8962         end = ctxt-&gt;input-&gt;end;
 8963                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8964                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8965                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8966                                    &quot;AttValue length too long\n&quot;);
 8967                     return(NULL);
 8968                 }
 8969         }
 8970     }
 8971         if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8972             ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8973             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8974                            &quot;AttValue length too long\n&quot;);
 8975             return(NULL);
 8976         }
 8977     if (*in != limit) goto need_complex;
 8978     } else {
 8979     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp; (*in &gt;= 0x20) &amp;&amp;
 8980            (*in &lt;= 0x7f) &amp;&amp; (*in != &#39;&amp;&#39;) &amp;&amp; (*in != &#39;&lt;&#39;)) {
 8981         in++;
 8982         col++;
 8983         if (in &gt;= end) {
<span class="line-modified"> 8984         const xmlChar *oldbase = ctxt-&gt;input-&gt;base;</span>
<span class="line-removed"> 8985         GROW;</span>
<span class="line-removed"> 8986                 if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-removed"> 8987                     return(NULL);</span>
<span class="line-removed"> 8988         if (oldbase != ctxt-&gt;input-&gt;base) {</span>
<span class="line-removed"> 8989             long delta = ctxt-&gt;input-&gt;base - oldbase;</span>
<span class="line-removed"> 8990             start = start + delta;</span>
<span class="line-removed"> 8991             in = in + delta;</span>
<span class="line-removed"> 8992         }</span>
<span class="line-removed"> 8993         end = ctxt-&gt;input-&gt;end;</span>
 8994                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8995                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8996                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8997                                    &quot;AttValue length too long\n&quot;);
 8998                     return(NULL);
 8999                 }
 9000         }
 9001     }
 9002     last = in;
 9003         if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 9004             ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 9005             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9006                            &quot;AttValue length too long\n&quot;);
 9007             return(NULL);
 9008         }
 9009     if (*in != limit) goto need_complex;
 9010     }
 9011     in++;
 9012     col++;
 9013     if (len != NULL) {
</pre>
<hr />
<pre>
 9067     if (ctxt-&gt;attsSpecial != NULL) {
 9068         int type;
 9069 
 9070         type = (int) (ptrdiff_t) xmlHashQLookup2(ctxt-&gt;attsSpecial,
 9071                                                  pref, elem, *prefix, name);
 9072         if (type != 0)
 9073             normalize = 1;
 9074     }
 9075 
 9076     /*
 9077      * read the value
 9078      */
 9079     SKIP_BLANKS;
 9080     if (RAW == &#39;=&#39;) {
 9081         NEXT;
 9082         SKIP_BLANKS;
 9083         val = xmlParseAttValueInternal(ctxt, len, alloc, normalize);
 9084     if (normalize) {
 9085         /*
 9086          * Sometimes a second normalisation pass for spaces is needed
<span class="line-modified"> 9087          * but that only happens if charrefs or entities refernces</span>
 9088          * have been used in the attribute value, i.e. the attribute
 9089          * value have been extracted in an allocated string already.
 9090          */
 9091         if (*alloc) {
 9092             const xmlChar *val2;
 9093 
 9094             val2 = xmlAttrNormalizeSpace2(ctxt, val, len);
 9095         if ((val2 != NULL) &amp;&amp; (val2 != val)) {
 9096             xmlFree(val);
 9097             val = (xmlChar *) val2;
 9098         }
 9099         }
 9100     }
 9101         ctxt-&gt;instate = XML_PARSER_CONTENT;
 9102     } else {
 9103         xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,
 9104                           &quot;Specification mandates value for attribute %s\n&quot;,
 9105                           name);
 9106         return (NULL);
 9107     }
</pre>
<hr />
<pre>
 9230        ((RAW != &#39;/&#39;) || (NXT(1) != &#39;&gt;&#39;)) &amp;&amp;
 9231        (IS_BYTE_CHAR(RAW))) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF)) {
 9232     const xmlChar *q = CUR_PTR;
 9233     unsigned int cons = ctxt-&gt;input-&gt;consumed;
 9234     int len = -1, alloc = 0;
 9235 
 9236     attname = xmlParseAttribute2(ctxt, prefix, localname,
 9237                                  &amp;aprefix, &amp;attvalue, &amp;len, &amp;alloc);
 9238         if ((attname == NULL) || (attvalue == NULL))
 9239             goto next_attr;
 9240     if (len &lt; 0) len = xmlStrlen(attvalue);
 9241 
 9242         if ((attname == ctxt-&gt;str_xmlns) &amp;&amp; (aprefix == NULL)) {
 9243             const xmlChar *URL = xmlDictLookup(ctxt-&gt;dict, attvalue, len);
 9244             xmlURIPtr uri;
 9245 
 9246             if (URL == NULL) {
 9247                 xmlErrMemory(ctxt, &quot;dictionary allocation failure&quot;);
 9248                 if ((attvalue != NULL) &amp;&amp; (alloc != 0))
 9249                     xmlFree(attvalue);
<span class="line-modified"> 9250                 return(NULL);</span>

 9251             }
 9252             if (*URL != 0) {
 9253                 uri = xmlParseURI((const char *) URL);
 9254                 if (uri == NULL) {
 9255                     xmlNsErr(ctxt, XML_WAR_NS_URI,
 9256                              &quot;xmlns: &#39;%s&#39; is not a valid URI\n&quot;,
 9257                                        URL, NULL, NULL);
 9258                 } else {
 9259                     if (uri-&gt;scheme == NULL) {
 9260                         xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
 9261                                   &quot;xmlns: URI %s is not absolute\n&quot;,
 9262                                   URL, NULL, NULL);
 9263                     }
 9264                     xmlFreeURI(uri);
 9265                 }
 9266                 if (URL == ctxt-&gt;str_xml_ns) {
 9267                     if (attname != ctxt-&gt;str_xml) {
 9268                         xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9269                      &quot;xml namespace URI cannot be the default namespace\n&quot;,
 9270                                  NULL, NULL, NULL);
</pre>
<hr />
<pre>
 9480                 if (j &lt;= nbNs) continue;
 9481 
 9482             nsname = xmlGetNamespace(ctxt, attname);
 9483             if (nsname != defaults-&gt;values[2]) {
 9484             if (nsPush(ctxt, attname,
 9485                        defaults-&gt;values[5 * i + 2]) &gt; 0)
 9486                 nbNs++;
 9487             }
 9488         } else {
 9489             /*
 9490              * check that it&#39;s not a defined attribute
 9491              */
 9492             for (j = 0;j &lt; nbatts;j+=5) {
 9493             if ((attname == atts[j]) &amp;&amp; (aprefix == atts[j+1]))
 9494                 break;
 9495             }
 9496             if (j &lt; nbatts) continue;
 9497 
 9498             if ((atts == NULL) || (nbatts + 5 &gt; maxatts)) {
 9499             if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) &lt; 0) {
<span class="line-modified"> 9500                 return(NULL);</span>

 9501             }
 9502             maxatts = ctxt-&gt;maxatts;
 9503             atts = ctxt-&gt;atts;
 9504             }
 9505             atts[nbatts++] = attname;
 9506             atts[nbatts++] = aprefix;
 9507             if (aprefix == NULL)
 9508             atts[nbatts++] = NULL;
 9509             else
 9510                 atts[nbatts++] = xmlGetNamespace(ctxt, aprefix);
 9511             atts[nbatts++] = defaults-&gt;values[5 * i + 2];
 9512             atts[nbatts++] = defaults-&gt;values[5 * i + 3];
 9513             if ((ctxt-&gt;standalone == 1) &amp;&amp;
 9514                 (defaults-&gt;values[5 * i + 4] != NULL)) {
 9515             xmlValidityError(ctxt, XML_DTD_STANDALONE_DEFAULTED,
 9516       &quot;standalone: attribute %s on %s defaulted from external subset\n&quot;,
 9517                                      attname, localname);
 9518             }
 9519             nbdef++;
 9520         }
</pre>
<hr />
<pre>
 9790     if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX)) {
 9791     if (ctxt-&gt;sax-&gt;cdataBlock != NULL)
 9792         ctxt-&gt;sax-&gt;cdataBlock(ctxt-&gt;userData, buf, len);
 9793     else if (ctxt-&gt;sax-&gt;characters != NULL)
 9794         ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, buf, len);
 9795     }
 9796     xmlFree(buf);
 9797 }
 9798 
 9799 /**
 9800  * xmlParseContent:
 9801  * @ctxt:  an XML parser context
 9802  *
 9803  * Parse a content:
 9804  *
 9805  * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
 9806  */
 9807 
 9808 void
 9809 xmlParseContent(xmlParserCtxtPtr ctxt) {


 9810     GROW;
 9811     while ((RAW != 0) &amp;&amp;
<span class="line-removed"> 9812        ((RAW != &#39;&lt;&#39;) || (NXT(1) != &#39;/&#39;)) &amp;&amp;</span>
 9813        (ctxt-&gt;instate != XML_PARSER_EOF)) {
 9814     const xmlChar *test = CUR_PTR;
 9815     unsigned int cons = ctxt-&gt;input-&gt;consumed;
 9816     const xmlChar *cur = ctxt-&gt;input-&gt;cur;
 9817 
 9818     /*
 9819      * First case : a Processing Instruction.
 9820      */
 9821     if ((*cur == &#39;&lt;&#39;) &amp;&amp; (cur[1] == &#39;?&#39;)) {
 9822         xmlParsePI(ctxt);
 9823     }
 9824 
 9825     /*
 9826      * Second case : a CDSection
 9827      */
 9828     /* 2.6.0 test was *cur not RAW */
 9829     else if (CMP9(CUR_PTR, &#39;&lt;&#39;, &#39;!&#39;, &#39;[&#39;, &#39;C&#39;, &#39;D&#39;, &#39;A&#39;, &#39;T&#39;, &#39;A&#39;, &#39;[&#39;)) {
 9830         xmlParseCDSect(ctxt);
 9831     }
 9832 
 9833     /*
 9834      * Third case :  a comment
 9835      */
 9836     else if ((*cur == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp;
 9837          (NXT(2) == &#39;-&#39;) &amp;&amp; (NXT(3) == &#39;-&#39;)) {
 9838         xmlParseComment(ctxt);
 9839         ctxt-&gt;instate = XML_PARSER_CONTENT;
 9840     }
 9841 
 9842     /*
 9843      * Fourth case :  a sub-element.
 9844      */
 9845     else if (*cur == &#39;&lt;&#39;) {
<span class="line-modified"> 9846         xmlParseElement(ctxt);</span>






 9847     }
 9848 
 9849     /*
 9850      * Fifth case : a reference. If if has not been resolved,
 9851      *    parsing returns it&#39;s Name, create the node
 9852      */
 9853 
 9854     else if (*cur == &#39;&amp;&#39;) {
 9855         xmlParseReference(ctxt);
 9856     }
 9857 
 9858     /*
 9859      * Last case, text. Note that References are handled directly.
 9860      */
 9861     else {
 9862         xmlParseCharData(ctxt, 0);
 9863     }
 9864 
 9865     GROW;
 9866     SHRINK;
 9867 
 9868     if ((cons == ctxt-&gt;input-&gt;consumed) &amp;&amp; (test == CUR_PTR)) {
 9869         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 9870                     &quot;detected an error in element content\n&quot;);
 9871         xmlHaltParser(ctxt);
 9872             break;
 9873     }
 9874     }
 9875 }
 9876 
 9877 /**
 9878  * xmlParseElement:
 9879  * @ctxt:  an XML parser context
 9880  *
<span class="line-modified"> 9881  * parse an XML element, this is highly recursive</span>
 9882  *
 9883  * [39] element ::= EmptyElemTag | STag content ETag
 9884  *
 9885  * [ WFC: Element Type Match ]
 9886  * The Name in an element&#39;s end-tag must match the element type in the
 9887  * start-tag.
 9888  *
 9889  */
 9890 
 9891 void
 9892 xmlParseElement(xmlParserCtxtPtr ctxt) {

















 9893     const xmlChar *name;
 9894     const xmlChar *prefix = NULL;
 9895     const xmlChar *URI = NULL;
 9896     xmlParserNodeInfo node_info;
 9897     int line, tlen = 0;
 9898     xmlNodePtr ret;
 9899     int nsNr = ctxt-&gt;nsNr;
 9900 
 9901     if (((unsigned int) ctxt-&gt;nameNr &gt; xmlParserMaxDepth) &amp;&amp;
 9902         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 9903     xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
 9904          &quot;Excessive depth in document: %d use XML_PARSE_HUGE option\n&quot;,
 9905               xmlParserMaxDepth);
 9906     xmlHaltParser(ctxt);
<span class="line-modified"> 9907     return;</span>
 9908     }
 9909 
 9910     /* Capture start position */
 9911     if (ctxt-&gt;record_info) {
 9912         node_info.begin_pos = ctxt-&gt;input-&gt;consumed +
 9913                           (CUR_PTR - ctxt-&gt;input-&gt;base);
 9914     node_info.begin_line = ctxt-&gt;input-&gt;line;
 9915     }
 9916 
 9917     if (ctxt-&gt;spaceNr == 0)
 9918     spacePush(ctxt, -1);
 9919     else if (*ctxt-&gt;space == -2)
 9920     spacePush(ctxt, -1);
 9921     else
 9922     spacePush(ctxt, *ctxt-&gt;space);
 9923 
 9924     line = ctxt-&gt;input-&gt;line;
 9925 #ifdef LIBXML_SAX1_ENABLED
 9926     if (ctxt-&gt;sax2)
 9927 #endif /* LIBXML_SAX1_ENABLED */
 9928         name = xmlParseStartTag2(ctxt, &amp;prefix, &amp;URI, &amp;tlen);
 9929 #ifdef LIBXML_SAX1_ENABLED
 9930     else
 9931     name = xmlParseStartTag(ctxt);
 9932 #endif /* LIBXML_SAX1_ENABLED */
 9933     if (ctxt-&gt;instate == XML_PARSER_EOF)
<span class="line-modified"> 9934     return;</span>
 9935     if (name == NULL) {
 9936     spacePop(ctxt);
<span class="line-modified"> 9937         return;</span>
 9938     }




 9939     namePush(ctxt, name);

 9940     ret = ctxt-&gt;node;
 9941 
 9942 #ifdef LIBXML_VALID_ENABLED
 9943     /*
 9944      * [ VC: Root Element Type ]
 9945      * The Name in the document type declaration must match the element
 9946      * type of the root element.
 9947      */
 9948     if (ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp; ctxt-&gt;myDoc &amp;&amp;
 9949         ctxt-&gt;node &amp;&amp; (ctxt-&gt;node == ctxt-&gt;myDoc-&gt;children))
 9950         ctxt-&gt;valid &amp;= xmlValidateRoot(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc);
 9951 #endif /* LIBXML_VALID_ENABLED */
 9952 
 9953     /*
 9954      * Check for an Empty Element.
 9955      */
 9956     if ((RAW == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;)) {
 9957         SKIP(2);
 9958     if (ctxt-&gt;sax2) {
 9959         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElementNs != NULL) &amp;&amp;
 9960         (!ctxt-&gt;disableSAX))
 9961         ctxt-&gt;sax-&gt;endElementNs(ctxt-&gt;userData, name, prefix, URI);
 9962 #ifdef LIBXML_SAX1_ENABLED
 9963     } else {
 9964         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElement != NULL) &amp;&amp;
 9965         (!ctxt-&gt;disableSAX))
 9966         ctxt-&gt;sax-&gt;endElement(ctxt-&gt;userData, name);
 9967 #endif /* LIBXML_SAX1_ENABLED */
 9968     }
 9969     namePop(ctxt);
 9970     spacePop(ctxt);
 9971     if (nsNr != ctxt-&gt;nsNr)
 9972         nsPop(ctxt, ctxt-&gt;nsNr - nsNr);
 9973     if ( ret != NULL &amp;&amp; ctxt-&gt;record_info ) {
 9974        node_info.end_pos = ctxt-&gt;input-&gt;consumed +
 9975                   (CUR_PTR - ctxt-&gt;input-&gt;base);
 9976        node_info.end_line = ctxt-&gt;input-&gt;line;
 9977        node_info.node = ret;
 9978        xmlParserAddNodeInfo(ctxt, &amp;node_info);
 9979     }
<span class="line-modified"> 9980     return;</span>
 9981     }
 9982     if (RAW == &#39;&gt;&#39;) {
 9983         NEXT1;
 9984     } else {
 9985         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_GT_REQUIRED,
 9986              &quot;Couldn&#39;t find end of Start Tag %s line %d\n&quot;,
 9987                         name, line, NULL);
 9988 
 9989     /*
 9990      * end of parsing of this node.
 9991      */
 9992     nodePop(ctxt);
 9993     namePop(ctxt);
 9994     spacePop(ctxt);
 9995     if (nsNr != ctxt-&gt;nsNr)
 9996         nsPop(ctxt, ctxt-&gt;nsNr - nsNr);
 9997 
 9998     /*
 9999      * Capture end position and add node
10000      */
10001     if ( ret != NULL &amp;&amp; ctxt-&gt;record_info ) {
10002        node_info.end_pos = ctxt-&gt;input-&gt;consumed +
10003                   (CUR_PTR - ctxt-&gt;input-&gt;base);
10004        node_info.end_line = ctxt-&gt;input-&gt;line;
10005        node_info.node = ret;
10006        xmlParserAddNodeInfo(ctxt, &amp;node_info);
10007     }
<span class="line-modified">10008     return;</span>
10009     }
10010 
<span class="line-modified">10011     /*</span>
<span class="line-modified">10012      * Parse the content of the element:</span>
<span class="line-removed">10013      */</span>
<span class="line-removed">10014     xmlParseContent(ctxt);</span>
<span class="line-removed">10015     if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-removed">10016     return;</span>
<span class="line-removed">10017     if (!IS_BYTE_CHAR(RAW)) {</span>
<span class="line-removed">10018         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,</span>
<span class="line-removed">10019      &quot;Premature end of data in tag %s line %d\n&quot;,</span>
<span class="line-removed">10020                         name, line, NULL);</span>
10021 
<span class="line-modified">10022     /*</span>
<span class="line-modified">10023      * end of parsing of this node.</span>



10024      */
<span class="line-modified">10025     nodePop(ctxt);</span>
<span class="line-modified">10026     namePop(ctxt);</span>
<span class="line-modified">10027     spacePop(ctxt);</span>
<span class="line-modified">10028     if (nsNr != ctxt-&gt;nsNr)</span>
<span class="line-modified">10029         nsPop(ctxt, ctxt-&gt;nsNr - nsNr);</span>

10030     return;
<span class="line-removed">10031     }</span>
10032 
10033     /*
10034      * parse the end of tag: &#39;&lt;/&#39; should be here.
10035      */
10036     if (ctxt-&gt;sax2) {
<span class="line-modified">10037     xmlParseEndTag2(ctxt, prefix, URI, line, ctxt-&gt;nsNr - nsNr, tlen);</span>



10038     namePop(ctxt);
10039     }
10040 #ifdef LIBXML_SAX1_ENABLED
10041       else
<span class="line-modified">10042     xmlParseEndTag1(ctxt, line);</span>
10043 #endif /* LIBXML_SAX1_ENABLED */
10044 
10045     /*
10046      * Capture end position and add node
10047      */
10048     if ( ret != NULL &amp;&amp; ctxt-&gt;record_info ) {
10049        node_info.end_pos = ctxt-&gt;input-&gt;consumed +
10050                           (CUR_PTR - ctxt-&gt;input-&gt;base);
10051        node_info.end_line = ctxt-&gt;input-&gt;line;
10052        node_info.node = ret;
10053        xmlParserAddNodeInfo(ctxt, &amp;node_info);
10054     }
10055 }
10056 
10057 /**
10058  * xmlParseVersionNum:
10059  * @ctxt:  an XML parser context
10060  *
10061  * parse the XML version value.
10062  *
</pre>
<hr />
<pre>
10264         encoding = xmlParseEncName(ctxt);
10265         if (RAW != &#39;\&#39;&#39;) {
10266         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10267         xmlFree((xmlChar *) encoding);
10268         return(NULL);
10269         } else
10270             NEXT;
10271     } else {
10272         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10273     }
10274 
10275         /*
10276          * Non standard parsing, allowing the user to ignore encoding
10277          */
10278         if (ctxt-&gt;options &amp; XML_PARSE_IGNORE_ENC) {
10279         xmlFree((xmlChar *) encoding);
10280             return(NULL);
10281     }
10282 
10283     /*
<span class="line-modified">10284      * UTF-16 encoding stwich has already taken place at this stage,</span>
10285      * more over the little-endian/big-endian selection is already done
10286      */
10287         if ((encoding != NULL) &amp;&amp;
10288         ((!xmlStrcasecmp(encoding, BAD_CAST &quot;UTF-16&quot;)) ||
10289          (!xmlStrcasecmp(encoding, BAD_CAST &quot;UTF16&quot;)))) {
10290         /*
10291          * If no encoding was passed to the parser, that we are
10292          * using UTF-16 and no decoder is present i.e. the
10293          * document is apparently UTF-8 compatible, then raise an
10294          * encoding mismatch fatal error
10295          */
10296         if ((ctxt-&gt;encoding == NULL) &amp;&amp;
10297             (ctxt-&gt;input-&gt;buf != NULL) &amp;&amp;
10298             (ctxt-&gt;input-&gt;buf-&gt;encoder == NULL)) {
10299         xmlFatalErrMsg(ctxt, XML_ERR_INVALID_ENCODING,
10300           &quot;Document labelled UTF-16 but has UTF-8 content\n&quot;);
10301         }
10302         if (ctxt-&gt;encoding != NULL)
10303         xmlFree((xmlChar *) ctxt-&gt;encoding);
10304         ctxt-&gt;encoding = encoding;
</pre>
<hr />
<pre>
11147 #endif
11148 
11149     if ((ctxt-&gt;input != NULL) &amp;&amp;
11150         (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base &gt; 4096)) {
11151     xmlSHRINK(ctxt);
11152     ctxt-&gt;checkIndex = 0;
11153     }
11154     xmlParseGetLasts(ctxt, &amp;lastlt, &amp;lastgt);
11155 
11156     while (ctxt-&gt;instate != XML_PARSER_EOF) {
11157     if ((ctxt-&gt;errNo != XML_ERR_OK) &amp;&amp; (ctxt-&gt;disableSAX == 1))
11158         return(0);
11159 
11160     if (ctxt-&gt;input == NULL) break;
11161     if (ctxt-&gt;input-&gt;buf == NULL)
11162         avail = ctxt-&gt;input-&gt;length -
11163                 (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11164     else {
11165         /*
11166          * If we are operating on converted input, try to flush
<span class="line-modified">11167          * remainng chars to avoid them stalling in the non-converted</span>
11168          * buffer. But do not do this in document start where
11169          * encoding=&quot;...&quot; may not have been read and we work on a
11170          * guessed encoding.
11171          */
11172         if ((ctxt-&gt;instate != XML_PARSER_START) &amp;&amp;
11173             (ctxt-&gt;input-&gt;buf-&gt;raw != NULL) &amp;&amp;
11174         (xmlBufIsEmpty(ctxt-&gt;input-&gt;buf-&gt;raw) == 0)) {
11175                 size_t base = xmlBufGetInputBase(ctxt-&gt;input-&gt;buf-&gt;buffer,
11176                                                  ctxt-&gt;input);
11177         size_t current = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
11178 
11179         xmlParserInputBufferPush(ctxt-&gt;input-&gt;buf, 0, &quot;&quot;);
11180                 xmlBufSetInputBaseCur(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input,
11181                                       base, current);
11182         }
11183         avail = xmlBufUse(ctxt-&gt;input-&gt;buf-&gt;buffer) -
11184             (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11185     }
11186         if (avail &lt; 1)
11187         goto done;
</pre>
<hr />
<pre>
12339     xmlParserInputPtr inputStream;
12340     xmlParserInputBufferPtr buf;
12341     xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;
12342 
12343     /*
12344      * plug some encoding conversion routines
12345      */
12346     if ((chunk != NULL) &amp;&amp; (size &gt;= 4))
12347     enc = xmlDetectCharEncoding((const xmlChar *) chunk, size);
12348 
12349     buf = xmlAllocParserInputBuffer(enc);
12350     if (buf == NULL) return(NULL);
12351 
12352     ctxt = xmlNewParserCtxt();
12353     if (ctxt == NULL) {
12354         xmlErrMemory(NULL, &quot;creating parser: out of memory\n&quot;);
12355     xmlFreeParserInputBuffer(buf);
12356     return(NULL);
12357     }
12358     ctxt-&gt;dictNames = 1;
<span class="line-removed">12359     ctxt-&gt;pushTab = (void **) xmlMalloc(ctxt-&gt;nameMax * 3 * sizeof(xmlChar *));</span>
<span class="line-removed">12360     if (ctxt-&gt;pushTab == NULL) {</span>
<span class="line-removed">12361         xmlErrMemory(ctxt, NULL);</span>
<span class="line-removed">12362     xmlFreeParserInputBuffer(buf);</span>
<span class="line-removed">12363     xmlFreeParserCtxt(ctxt);</span>
<span class="line-removed">12364     return(NULL);</span>
<span class="line-removed">12365     }</span>
12366     if (sax != NULL) {
12367 #ifdef LIBXML_SAX1_ENABLED
12368     if (ctxt-&gt;sax != (xmlSAXHandlerPtr) &amp;xmlDefaultSAXHandler)
12369 #endif /* LIBXML_SAX1_ENABLED */
12370         xmlFree(ctxt-&gt;sax);
12371     ctxt-&gt;sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(xmlSAXHandler));
12372     if (ctxt-&gt;sax == NULL) {
12373         xmlErrMemory(ctxt, NULL);
12374         xmlFreeParserInputBuffer(buf);
12375         xmlFreeParserCtxt(ctxt);
12376         return(NULL);
12377     }
12378     memset(ctxt-&gt;sax, 0, sizeof(xmlSAXHandler));
12379     if (sax-&gt;initialized == XML_SAX2_MAGIC)
12380         memcpy(ctxt-&gt;sax, sax, sizeof(xmlSAXHandler));
12381     else
12382         memcpy(ctxt-&gt;sax, sax, sizeof(xmlSAXHandlerV1));
12383     if (user_data != NULL)
12384         ctxt-&gt;userData = user_data;
12385     }
</pre>
<hr />
<pre>
13881 
13882     /*
13883      * Return the newly created nodeset after unlinking it from
13884      * they pseudo parent.
13885      */
13886     cur = newDoc-&gt;children-&gt;children;
13887     *lst = cur;
13888     while (cur != NULL) {
13889         xmlSetTreeDoc(cur, doc);
13890         cur-&gt;parent = NULL;
13891         cur = cur-&gt;next;
13892     }
13893     newDoc-&gt;children-&gt;children = NULL;
13894     }
13895 
13896     if (sax != NULL)
13897     ctxt-&gt;sax = oldsax;
13898     xmlFreeParserCtxt(ctxt);
13899     newDoc-&gt;intSubset = NULL;
13900     newDoc-&gt;extSubset = NULL;

13901     newDoc-&gt;oldNs = NULL;
13902     xmlFreeDoc(newDoc);
13903 
13904     return(ret);
13905 }
13906 
13907 /**
13908  * xmlSAXParseEntity:
13909  * @sax:  the SAX handler block
13910  * @filename:  the filename
13911  *
13912  * parse an XML external entity out of context and build a tree.
13913  * It use the given SAX function block to handle the parsing callback.
13914  * If sax is NULL, fallback to the default DOM tree building routines.
13915  *
13916  * [78] extParsedEnt ::= TextDecl? content
13917  *
13918  * This correspond to a &quot;Well Balanced&quot; chunk
13919  *
13920  * Returns the resulting document tree
</pre>
<hr />
<pre>
13990     xmlParserCtxtPtr ctxt;
13991     xmlParserInputPtr inputStream;
13992     char *directory = NULL;
13993     xmlChar *uri;
13994 
13995     ctxt = xmlNewParserCtxt();
13996     if (ctxt == NULL) {
13997     return(NULL);
13998     }
13999 
14000     if (pctx != NULL) {
14001         ctxt-&gt;options = pctx-&gt;options;
14002         ctxt-&gt;_private = pctx-&gt;_private;
14003     /*
14004      * this is a subparser of pctx, so the input_id should be
14005      * incremented to distinguish from main entity
14006      */
14007     ctxt-&gt;input_id = pctx-&gt;input_id + 1;
14008     }
14009 




14010     uri = xmlBuildURI(URL, base);
14011 
14012     if (uri == NULL) {
14013     inputStream = xmlLoadExternalEntity((char *)URL, (char *)ID, ctxt);
14014     if (inputStream == NULL) {
14015         xmlFreeParserCtxt(ctxt);
14016         return(NULL);
14017     }
14018 
14019     inputPush(ctxt, inputStream);
14020 
14021     if ((ctxt-&gt;directory == NULL) &amp;&amp; (directory == NULL))
14022         directory = xmlParserGetDirectory((char *)URL);
14023     if ((ctxt-&gt;directory == NULL) &amp;&amp; (directory != NULL))
14024         ctxt-&gt;directory = directory;
14025     } else {
14026     inputStream = xmlLoadExternalEntity((char *)uri, (char *)ID, ctxt);
14027     if (inputStream == NULL) {
14028         xmlFree(uri);
14029         xmlFreeParserCtxt(ctxt);
</pre>
<hr />
<pre>
14922     xmlParserInputBufferPtr buf;
14923     xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;
14924 
14925     if (ctxt == NULL)
14926         return(1);
14927 
14928     if ((encoding == NULL) &amp;&amp; (chunk != NULL) &amp;&amp; (size &gt;= 4))
14929         enc = xmlDetectCharEncoding((const xmlChar *) chunk, size);
14930 
14931     buf = xmlAllocParserInputBuffer(enc);
14932     if (buf == NULL)
14933         return(1);
14934 
14935     if (ctxt == NULL) {
14936         xmlFreeParserInputBuffer(buf);
14937         return(1);
14938     }
14939 
14940     xmlCtxtReset(ctxt);
14941 
<span class="line-removed">14942     if (ctxt-&gt;pushTab == NULL) {</span>
<span class="line-removed">14943         ctxt-&gt;pushTab = (void **) xmlMalloc(ctxt-&gt;nameMax * 3 *</span>
<span class="line-removed">14944                                         sizeof(xmlChar *));</span>
<span class="line-removed">14945         if (ctxt-&gt;pushTab == NULL) {</span>
<span class="line-removed">14946         xmlErrMemory(ctxt, NULL);</span>
<span class="line-removed">14947             xmlFreeParserInputBuffer(buf);</span>
<span class="line-removed">14948             return(1);</span>
<span class="line-removed">14949         }</span>
<span class="line-removed">14950     }</span>
<span class="line-removed">14951 </span>
14952     if (filename == NULL) {
14953         ctxt-&gt;directory = NULL;
14954     } else {
14955         ctxt-&gt;directory = xmlParserGetDirectory(filename);
14956     }
14957 
14958     inputStream = xmlNewInputStream(ctxt);
14959     if (inputStream == NULL) {
14960         xmlFreeParserInputBuffer(buf);
14961         return(1);
14962     }
14963 
14964     if (filename == NULL)
14965         inputStream-&gt;filename = NULL;
14966     else
14967         inputStream-&gt;filename = (char *)
14968             xmlCanonicPath((const xmlChar *) filename);
14969     inputStream-&gt;buf = buf;
14970     xmlBufResetInput(buf-&gt;buffer, inputStream);
14971 
</pre>
</td>
<td>
<hr />
<pre>
   79 #endif
   80 #ifdef HAVE_FCNTL_H
   81 #include &lt;fcntl.h&gt;
   82 #endif
   83 #ifdef HAVE_UNISTD_H
   84 #include &lt;unistd.h&gt;
   85 #endif
   86 
   87 #include &quot;buf.h&quot;
   88 #include &quot;enc.h&quot;
   89 
   90 static void
   91 xmlFatalErr(xmlParserCtxtPtr ctxt, xmlParserErrors error, const char *info);
   92 
   93 static xmlParserCtxtPtr
   94 xmlCreateEntityParserCtxtInternal(const xmlChar *URL, const xmlChar *ID,
   95                       const xmlChar *base, xmlParserCtxtPtr pctx);
   96 
   97 static void xmlHaltParser(xmlParserCtxtPtr ctxt);
   98 
<span class="line-added">   99 static int</span>
<span class="line-added">  100 xmlParseElementStart(xmlParserCtxtPtr ctxt);</span>
<span class="line-added">  101 </span>
<span class="line-added">  102 static void</span>
<span class="line-added">  103 xmlParseElementEnd(xmlParserCtxtPtr ctxt);</span>
<span class="line-added">  104 </span>
  105 /************************************************************************
  106  *                                  *
  107  *  Arbitrary limits set in the parser. See XML_PARSE_HUGE      *
  108  *                                  *
  109  ************************************************************************/
  110 
  111 #define XML_PARSER_BIG_ENTITY 1000
  112 #define XML_PARSER_LOT_ENTITY 5000
  113 
  114 /*
  115  * XML_PARSER_NON_LINEAR is the threshold where the ratio of parsed entity
  116  *    replacement over the size in byte of the input indicates that you have
<span class="line-modified">  117  *    and exponential behaviour. A value of 10 correspond to at least 3 entity</span>
  118  *    replacement per byte of input.
  119  */
  120 #define XML_PARSER_NON_LINEAR 10
  121 
  122 /*
  123  * xmlParserEntityCheck
  124  *
  125  * Function to check non-linear entity expansion behaviour
  126  * This is here to detect and stop exponential linear entity expansion
  127  * This is not a limitation of the parser but a safety
  128  * boundary feature. It can be disabled with the XML_PARSE_HUGE
  129  * parser option.
  130  */
  131 static int
  132 xmlParserEntityCheck(xmlParserCtxtPtr ctxt, size_t size,
  133                      xmlEntityPtr ent, size_t replacement)
  134 {
  135     size_t consumed = 0;
  136 
  137     if ((ctxt == NULL) || (ctxt-&gt;options &amp; XML_PARSE_HUGE))
  138         return (0);
  139     if (ctxt-&gt;lastError.code == XML_ERR_ENTITY_LOOP)
  140         return (1);
  141 
  142     /*
  143      * This may look absurd but is needed to detect
  144      * entities problems
  145      */
  146     if ((ent != NULL) &amp;&amp; (ent-&gt;etype != XML_INTERNAL_PREDEFINED_ENTITY) &amp;&amp;
  147     (ent-&gt;content != NULL) &amp;&amp; (ent-&gt;checked == 0) &amp;&amp;
  148     (ctxt-&gt;errNo != XML_ERR_ENTITY_LOOP)) {
<span class="line-modified">  149     unsigned long oldnbent = ctxt-&gt;nbentities, diff;</span>
  150     xmlChar *rep;
  151 
  152     ent-&gt;checked = 1;
  153 
  154         ++ctxt-&gt;depth;
  155     rep = xmlStringDecodeEntities(ctxt, ent-&gt;content,
  156                   XML_SUBSTITUTE_REF, 0, 0, 0);
  157         --ctxt-&gt;depth;
  158     if ((rep == NULL) || (ctxt-&gt;errNo == XML_ERR_ENTITY_LOOP)) {
  159         ent-&gt;content[0] = 0;
  160     }
  161 
<span class="line-modified">  162         diff = ctxt-&gt;nbentities - oldnbent + 1;</span>
<span class="line-added">  163         if (diff &gt; INT_MAX / 2)</span>
<span class="line-added">  164             diff = INT_MAX / 2;</span>
<span class="line-added">  165     ent-&gt;checked = diff * 2;</span>
  166     if (rep != NULL) {
  167         if (xmlStrchr(rep, &#39;&lt;&#39;))
  168         ent-&gt;checked |= 1;
  169         xmlFree(rep);
  170         rep = NULL;
  171     }
  172     }
  173     if (replacement != 0) {
  174     if (replacement &lt; XML_MAX_TEXT_LENGTH)
  175         return(0);
  176 
  177         /*
  178      * If the volume of entity copy reaches 10 times the
  179      * amount of parsed data and over the large text threshold
  180      * then that&#39;s very likely to be an abuse.
  181      */
  182         if (ctxt-&gt;input != NULL) {
  183         consumed = ctxt-&gt;input-&gt;consumed +
  184                    (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
  185     }
</pre>
<hr />
<pre>
 1052             return(1);
 1053 #else
 1054             return(0);
 1055 #endif
 1056         default:
 1057         break;
 1058      }
 1059      return(0);
 1060 }
 1061 
 1062 /************************************************************************
 1063  *                                  *
 1064  *      SAX2 defaulted attributes handling          *
 1065  *                                  *
 1066  ************************************************************************/
 1067 
 1068 /**
 1069  * xmlDetectSAX2:
 1070  * @ctxt:  an XML parser context
 1071  *
<span class="line-modified"> 1072  * Do the SAX2 detection and specific initialization</span>
 1073  */
 1074 static void
 1075 xmlDetectSAX2(xmlParserCtxtPtr ctxt) {
 1076     if (ctxt == NULL) return;
 1077 #ifdef LIBXML_SAX1_ENABLED
 1078     if ((ctxt-&gt;sax) &amp;&amp;  (ctxt-&gt;sax-&gt;initialized == XML_SAX2_MAGIC) &amp;&amp;
 1079         ((ctxt-&gt;sax-&gt;startElementNs != NULL) ||
 1080          (ctxt-&gt;sax-&gt;endElementNs != NULL))) ctxt-&gt;sax2 = 1;
 1081 #else
 1082     ctxt-&gt;sax2 = 1;
 1083 #endif /* LIBXML_SAX1_ENABLED */
 1084 
 1085     ctxt-&gt;str_xml = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xml&quot;, 3);
 1086     ctxt-&gt;str_xmlns = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xmlns&quot;, 5);
 1087     ctxt-&gt;str_xml_ns = xmlDictLookup(ctxt-&gt;dict, XML_XML_NAMESPACE, 36);
 1088     if ((ctxt-&gt;str_xml==NULL) || (ctxt-&gt;str_xmlns==NULL) ||
 1089         (ctxt-&gt;str_xml_ns == NULL)) {
 1090         xmlErrMemory(ctxt, NULL);
 1091     }
 1092 }
</pre>
<hr />
<pre>
 1384     }
 1385     return;
 1386 }
 1387 
 1388 /**
 1389  * xmlCheckLanguageID:
 1390  * @lang:  pointer to the string value
 1391  *
 1392  * Checks that the value conforms to the LanguageID production:
 1393  *
 1394  * NOTE: this is somewhat deprecated, those productions were removed from
 1395  *       the XML Second edition.
 1396  *
 1397  * [33] LanguageID ::= Langcode (&#39;-&#39; Subcode)*
 1398  * [34] Langcode ::= ISO639Code |  IanaCode |  UserCode
 1399  * [35] ISO639Code ::= ([a-z] | [A-Z]) ([a-z] | [A-Z])
 1400  * [36] IanaCode ::= (&#39;i&#39; | &#39;I&#39;) &#39;-&#39; ([a-z] | [A-Z])+
 1401  * [37] UserCode ::= (&#39;x&#39; | &#39;X&#39;) &#39;-&#39; ([a-z] | [A-Z])+
 1402  * [38] Subcode ::= ([a-z] | [A-Z])+
 1403  *
<span class="line-modified"> 1404  * The current REC reference the successors of RFC 1766, currently 5646</span>
 1405  *
 1406  * http://www.rfc-editor.org/rfc/rfc5646.txt
 1407  * langtag       = language
 1408  *                 [&quot;-&quot; script]
 1409  *                 [&quot;-&quot; region]
 1410  *                 *(&quot;-&quot; variant)
 1411  *                 *(&quot;-&quot; extension)
 1412  *                 [&quot;-&quot; privateuse]
 1413  * language      = 2*3ALPHA            ; shortest ISO 639 code
 1414  *                 [&quot;-&quot; extlang]       ; sometimes followed by
 1415  *                                     ; extended language subtags
 1416  *               / 4ALPHA              ; or reserved for future use
 1417  *               / 5*8ALPHA            ; or registered language subtag
 1418  *
 1419  * extlang       = 3ALPHA              ; selected ISO 639 codes
 1420  *                 *2(&quot;-&quot; 3ALPHA)      ; permanently reserved
 1421  *
 1422  * script        = 4ALPHA              ; ISO 15924 code
 1423  *
 1424  * region        = 2ALPHA              ; ISO 3166-1 code
</pre>
<hr />
<pre>
 1811  * Returns the node just removed
 1812  */
 1813 xmlNodePtr
 1814 nodePop(xmlParserCtxtPtr ctxt)
 1815 {
 1816     xmlNodePtr ret;
 1817 
 1818     if (ctxt == NULL) return(NULL);
 1819     if (ctxt-&gt;nodeNr &lt;= 0)
 1820         return (NULL);
 1821     ctxt-&gt;nodeNr--;
 1822     if (ctxt-&gt;nodeNr &gt; 0)
 1823         ctxt-&gt;node = ctxt-&gt;nodeTab[ctxt-&gt;nodeNr - 1];
 1824     else
 1825         ctxt-&gt;node = NULL;
 1826     ret = ctxt-&gt;nodeTab[ctxt-&gt;nodeNr];
 1827     ctxt-&gt;nodeTab[ctxt-&gt;nodeNr] = NULL;
 1828     return (ret);
 1829 }
 1830 

 1831 /**
 1832  * nameNsPush:
 1833  * @ctxt:  an XML parser context
 1834  * @value:  the element name
 1835  * @prefix:  the element prefix
 1836  * @URI:  the element namespace name
 1837  *
 1838  * Pushes a new element name/prefix/URL on top of the name stack
 1839  *
 1840  * Returns -1 in case of error, the index in the stack otherwise
 1841  */
 1842 static int
 1843 nameNsPush(xmlParserCtxtPtr ctxt, const xmlChar * value,
 1844            const xmlChar *prefix, const xmlChar *URI, int nsNr)
 1845 {
 1846     if (ctxt-&gt;nameNr &gt;= ctxt-&gt;nameMax) {
 1847         const xmlChar * *tmp;
 1848         void **tmp2;
 1849         ctxt-&gt;nameMax *= 2;
 1850         tmp = (const xmlChar * *) xmlRealloc((xmlChar * *)ctxt-&gt;nameTab,
 1851                                     ctxt-&gt;nameMax *
 1852                                     sizeof(ctxt-&gt;nameTab[0]));
 1853         if (tmp == NULL) {
 1854         ctxt-&gt;nameMax /= 2;
 1855         goto mem_error;
 1856         }
 1857     ctxt-&gt;nameTab = tmp;
 1858         tmp2 = (void **) xmlRealloc((void * *)ctxt-&gt;pushTab,
 1859                                     ctxt-&gt;nameMax * 3 *
 1860                                     sizeof(ctxt-&gt;pushTab[0]));
 1861         if (tmp2 == NULL) {
 1862         ctxt-&gt;nameMax /= 2;
 1863         goto mem_error;
 1864         }
 1865     ctxt-&gt;pushTab = tmp2;
<span class="line-added"> 1866     } else if (ctxt-&gt;pushTab == NULL) {</span>
<span class="line-added"> 1867         ctxt-&gt;pushTab = (void **) xmlMalloc(ctxt-&gt;nameMax * 3 *</span>
<span class="line-added"> 1868                                             sizeof(ctxt-&gt;pushTab[0]));</span>
<span class="line-added"> 1869         if (ctxt-&gt;pushTab == NULL)</span>
<span class="line-added"> 1870             goto mem_error;</span>
 1871     }
 1872     ctxt-&gt;nameTab[ctxt-&gt;nameNr] = value;
 1873     ctxt-&gt;name = value;
 1874     ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3] = (void *) prefix;
 1875     ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 + 1] = (void *) URI;
 1876     ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 + 2] = (void *) (ptrdiff_t) nsNr;
 1877     return (ctxt-&gt;nameNr++);
 1878 mem_error:
 1879     xmlErrMemory(ctxt, NULL);
 1880     return (-1);
 1881 }
<span class="line-added"> 1882 #ifdef LIBXML_PUSH_ENABLED</span>
 1883 /**
 1884  * nameNsPop:
 1885  * @ctxt: an XML parser context
 1886  *
 1887  * Pops the top element/prefix/URI name from the name stack
 1888  *
 1889  * Returns the name just removed
 1890  */
 1891 static const xmlChar *
 1892 nameNsPop(xmlParserCtxtPtr ctxt)
 1893 {
 1894     const xmlChar *ret;
 1895 
 1896     if (ctxt-&gt;nameNr &lt;= 0)
 1897         return (NULL);
 1898     ctxt-&gt;nameNr--;
 1899     if (ctxt-&gt;nameNr &gt; 0)
 1900         ctxt-&gt;name = ctxt-&gt;nameTab[ctxt-&gt;nameNr - 1];
 1901     else
 1902         ctxt-&gt;name = NULL;
</pre>
<hr />
<pre>
 2072     if (*ctxt-&gt;input-&gt;cur == 0)                     \
 2073         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);           \
 2074   } while (0)
 2075 
 2076 #define SHRINK if ((ctxt-&gt;progressive == 0) &amp;&amp;              \
 2077            (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base &gt; 2 * INPUT_CHUNK) &amp;&amp; \
 2078            (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; 2 * INPUT_CHUNK)) \
 2079     xmlSHRINK (ctxt);
 2080 
 2081 static void xmlSHRINK (xmlParserCtxtPtr ctxt) {
 2082     xmlParserInputShrink(ctxt-&gt;input);
 2083     if (*ctxt-&gt;input-&gt;cur == 0)
 2084         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 2085 }
 2086 
 2087 #define GROW if ((ctxt-&gt;progressive == 0) &amp;&amp;                \
 2088          (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; INPUT_CHUNK))   \
 2089     xmlGROW (ctxt);
 2090 
 2091 static void xmlGROW (xmlParserCtxtPtr ctxt) {
<span class="line-modified"> 2092     ptrdiff_t curEnd = ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur;</span>
<span class="line-modified"> 2093     ptrdiff_t curBase = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;</span>
 2094 
<span class="line-modified"> 2095     if (((curEnd &gt; XML_MAX_LOOKUP_LIMIT) ||</span>
<span class="line-modified"> 2096          (curBase &gt; XML_MAX_LOOKUP_LIMIT)) &amp;&amp;</span>
 2097          ((ctxt-&gt;input-&gt;buf) &amp;&amp;
 2098           (ctxt-&gt;input-&gt;buf-&gt;readcallback != xmlInputReadCallbackNop)) &amp;&amp;
 2099         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 2100         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, &quot;Huge input lookup&quot;);
 2101         xmlHaltParser(ctxt);
 2102     return;
 2103     }
 2104     xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 2105     if ((ctxt-&gt;input-&gt;cur &gt; ctxt-&gt;input-&gt;end) ||
 2106         (ctxt-&gt;input-&gt;cur &lt; ctxt-&gt;input-&gt;base)) {
 2107         xmlHaltParser(ctxt);
 2108         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, &quot;cur index out of bound&quot;);
 2109     return;
 2110     }
 2111     if ((ctxt-&gt;input-&gt;cur != NULL) &amp;&amp; (*ctxt-&gt;input-&gt;cur == 0))
 2112         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 2113 }
 2114 
 2115 #define SKIP_BLANKS xmlSkipBlankChars(ctxt)
 2116 
</pre>
<hr />
<pre>
 2278     return(ret);
 2279 }
 2280 
 2281 /**
 2282  * xmlParseCharRef:
 2283  * @ctxt:  an XML parser context
 2284  *
 2285  * parse Reference declarations
 2286  *
 2287  * [66] CharRef ::= &#39;&amp;#&#39; [0-9]+ &#39;;&#39; |
 2288  *                  &#39;&amp;#x&#39; [0-9a-fA-F]+ &#39;;&#39;
 2289  *
 2290  * [ WFC: Legal Character ]
 2291  * Characters referred to using character references must match the
 2292  * production for Char.
 2293  *
 2294  * Returns the value parsed (as an int), 0 in case of error
 2295  */
 2296 int
 2297 xmlParseCharRef(xmlParserCtxtPtr ctxt) {
<span class="line-modified"> 2298     int val = 0;</span>
 2299     int count = 0;

 2300 
 2301     /*
 2302      * Using RAW/CUR/NEXT is okay since we are working on ASCII range here
 2303      */
 2304     if ((RAW == &#39;&amp;&#39;) &amp;&amp; (NXT(1) == &#39;#&#39;) &amp;&amp;
 2305         (NXT(2) == &#39;x&#39;)) {
 2306     SKIP(3);
 2307     GROW;
 2308     while (RAW != &#39;;&#39;) { /* loop blocked by count */
 2309         if (count++ &gt; 20) {
 2310         count = 0;
 2311         GROW;
 2312                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 2313                     return(0);
 2314         }
 2315         if ((RAW &gt;= &#39;0&#39;) &amp;&amp; (RAW &lt;= &#39;9&#39;))
 2316             val = val * 16 + (CUR - &#39;0&#39;);
 2317         else if ((RAW &gt;= &#39;a&#39;) &amp;&amp; (RAW &lt;= &#39;f&#39;) &amp;&amp; (count &lt; 20))
 2318             val = val * 16 + (CUR - &#39;a&#39;) + 10;
 2319         else if ((RAW &gt;= &#39;A&#39;) &amp;&amp; (RAW &lt;= &#39;F&#39;) &amp;&amp; (count &lt; 20))
 2320             val = val * 16 + (CUR - &#39;A&#39;) + 10;
 2321         else {
 2322         xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);
 2323         val = 0;
 2324         break;
 2325         }
<span class="line-modified"> 2326         if (val &gt; 0x110000)</span>
<span class="line-modified"> 2327             val = 0x110000;</span>
 2328 
 2329         NEXT;
 2330         count++;
 2331     }
 2332     if (RAW == &#39;;&#39;) {
 2333         /* on purpose to avoid reentrancy problems with NEXT and SKIP */
 2334         ctxt-&gt;input-&gt;col++;
 2335         ctxt-&gt;nbChars ++;
 2336         ctxt-&gt;input-&gt;cur++;
 2337     }
 2338     } else if  ((RAW == &#39;&amp;&#39;) &amp;&amp; (NXT(1) == &#39;#&#39;)) {
 2339     SKIP(2);
 2340     GROW;
 2341     while (RAW != &#39;;&#39;) { /* loop blocked by count */
 2342         if (count++ &gt; 20) {
 2343         count = 0;
 2344         GROW;
 2345                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 2346                     return(0);
 2347         }
 2348         if ((RAW &gt;= &#39;0&#39;) &amp;&amp; (RAW &lt;= &#39;9&#39;))
 2349             val = val * 10 + (CUR - &#39;0&#39;);
 2350         else {
 2351         xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);
 2352         val = 0;
 2353         break;
 2354         }
<span class="line-modified"> 2355         if (val &gt; 0x110000)</span>
<span class="line-modified"> 2356             val = 0x110000;</span>
 2357 
 2358         NEXT;
 2359         count++;
 2360     }
 2361     if (RAW == &#39;;&#39;) {
 2362         /* on purpose to avoid reentrancy problems with NEXT and SKIP */
 2363         ctxt-&gt;input-&gt;col++;
 2364         ctxt-&gt;nbChars ++;
 2365         ctxt-&gt;input-&gt;cur++;
 2366     }
 2367     } else {
 2368         xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);
 2369     }
 2370 
 2371     /*
 2372      * [ WFC: Legal Character ]
 2373      * Characters referred to using character references must match the
 2374      * production for Char.
 2375      */
<span class="line-modified"> 2376     if (val &gt;= 0x110000) {</span>
<span class="line-added"> 2377         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,</span>
<span class="line-added"> 2378                 &quot;xmlParseCharRef: character reference out of bounds\n&quot;,</span>
<span class="line-added"> 2379             val);</span>
<span class="line-added"> 2380     } else if (IS_CHAR(val)) {</span>
 2381         return(val);
 2382     } else {
 2383         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 2384                           &quot;xmlParseCharRef: invalid xmlChar value %d\n&quot;,
 2385                       val);
 2386     }
 2387     return(0);
 2388 }
 2389 
 2390 /**
 2391  * xmlParseStringCharRef:
 2392  * @ctxt:  an XML parser context
 2393  * @str:  a pointer to an index in the string
 2394  *
 2395  * parse Reference declarations, variant parsing from a string rather
 2396  * than an an input flow.
 2397  *
 2398  * [66] CharRef ::= &#39;&amp;#&#39; [0-9]+ &#39;;&#39; |
 2399  *                  &#39;&amp;#x&#39; [0-9a-fA-F]+ &#39;;&#39;
 2400  *
 2401  * [ WFC: Legal Character ]
 2402  * Characters referred to using character references must match the
 2403  * production for Char.
 2404  *
 2405  * Returns the value parsed (as an int), 0 in case of error, str will be
 2406  *         updated to the current value of the index
 2407  */
 2408 static int
 2409 xmlParseStringCharRef(xmlParserCtxtPtr ctxt, const xmlChar **str) {
 2410     const xmlChar *ptr;
 2411     xmlChar cur;
<span class="line-modified"> 2412     int val = 0;</span>

 2413 
 2414     if ((str == NULL) || (*str == NULL)) return(0);
 2415     ptr = *str;
 2416     cur = *ptr;
 2417     if ((cur == &#39;&amp;&#39;) &amp;&amp; (ptr[1] == &#39;#&#39;) &amp;&amp; (ptr[2] == &#39;x&#39;)) {
 2418     ptr += 3;
 2419     cur = *ptr;
 2420     while (cur != &#39;;&#39;) { /* Non input consuming loop */
 2421         if ((cur &gt;= &#39;0&#39;) &amp;&amp; (cur &lt;= &#39;9&#39;))
 2422             val = val * 16 + (cur - &#39;0&#39;);
 2423         else if ((cur &gt;= &#39;a&#39;) &amp;&amp; (cur &lt;= &#39;f&#39;))
 2424             val = val * 16 + (cur - &#39;a&#39;) + 10;
 2425         else if ((cur &gt;= &#39;A&#39;) &amp;&amp; (cur &lt;= &#39;F&#39;))
 2426             val = val * 16 + (cur - &#39;A&#39;) + 10;
 2427         else {
 2428         xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);
 2429         val = 0;
 2430         break;
 2431         }
<span class="line-modified"> 2432         if (val &gt; 0x110000)</span>
<span class="line-modified"> 2433             val = 0x110000;</span>
 2434 
 2435         ptr++;
 2436         cur = *ptr;
 2437     }
 2438     if (cur == &#39;;&#39;)
 2439         ptr++;
 2440     } else if  ((cur == &#39;&amp;&#39;) &amp;&amp; (ptr[1] == &#39;#&#39;)){
 2441     ptr += 2;
 2442     cur = *ptr;
 2443     while (cur != &#39;;&#39;) { /* Non input consuming loops */
 2444         if ((cur &gt;= &#39;0&#39;) &amp;&amp; (cur &lt;= &#39;9&#39;))
 2445             val = val * 10 + (cur - &#39;0&#39;);
 2446         else {
 2447         xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);
 2448         val = 0;
 2449         break;
 2450         }
<span class="line-modified"> 2451         if (val &gt; 0x110000)</span>
<span class="line-modified"> 2452             val = 0x110000;</span>
 2453 
 2454         ptr++;
 2455         cur = *ptr;
 2456     }
 2457     if (cur == &#39;;&#39;)
 2458         ptr++;
 2459     } else {
 2460     xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);
 2461     return(0);
 2462     }
 2463     *str = ptr;
 2464 
 2465     /*
 2466      * [ WFC: Legal Character ]
 2467      * Characters referred to using character references must match the
 2468      * production for Char.
 2469      */
<span class="line-modified"> 2470     if (val &gt;= 0x110000) {</span>
<span class="line-added"> 2471         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,</span>
<span class="line-added"> 2472                 &quot;xmlParseStringCharRef: character reference out of bounds\n&quot;,</span>
<span class="line-added"> 2473                 val);</span>
<span class="line-added"> 2474     } else if (IS_CHAR(val)) {</span>
 2475         return(val);
 2476     } else {
 2477         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 2478               &quot;xmlParseStringCharRef: invalid xmlChar value %d\n&quot;,
 2479               val);
 2480     }
 2481     return(0);
 2482 }
 2483 
 2484 /**
 2485  * xmlParserHandlePEReference:
 2486  * @ctxt:  the parser context
 2487  *
 2488  * [69] PEReference ::= &#39;%&#39; Name &#39;;&#39;
 2489  *
 2490  * [ WFC: No Recursion ]
 2491  * A parsed entity must not contain a recursive
 2492  * reference to itself, either directly or indirectly.
 2493  *
 2494  * [ WFC: Entity Declared ]
</pre>
<hr />
<pre>
 2705         if (nbchars + i + XML_PARSER_BUFFER_SIZE &gt; buffer_size) {
 2706             growBuffer(buffer, i + XML_PARSER_BUFFER_SIZE);
 2707         }
 2708         for (;i &gt; 0;i--)
 2709             buffer[nbchars++] = *cur++;
 2710         buffer[nbchars++] = &#39;;&#39;;
 2711         }
 2712     } else if (c == &#39;%&#39; &amp;&amp; (what &amp; XML_SUBSTITUTE_PEREF)) {
 2713         if (xmlParserDebugEntities)
 2714         xmlGenericError(xmlGenericErrorContext,
 2715             &quot;String decoding PE Reference: %.30s\n&quot;, str);
 2716         ent = xmlParseStringPEReference(ctxt, &amp;str);
 2717         xmlParserEntityCheck(ctxt, 0, ent, 0);
 2718         if (ent != NULL)
 2719             ctxt-&gt;nbentities += ent-&gt;checked / 2;
 2720         if (ent != NULL) {
 2721                 if (ent-&gt;content == NULL) {
 2722             /*
 2723              * Note: external parsed entities will not be loaded,
 2724              * it is not required for a non-validating parser to
<span class="line-modified"> 2725              * complete external PEReferences coming from the</span>
 2726              * internal subset
 2727              */
 2728             if (((ctxt-&gt;options &amp; XML_PARSE_NOENT) != 0) ||
 2729             ((ctxt-&gt;options &amp; XML_PARSE_DTDVALID) != 0) ||
 2730             (ctxt-&gt;validate != 0)) {
 2731             xmlLoadEntityContent(ctxt, ent);
 2732             } else {
 2733             xmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
 2734           &quot;not validating will not read content for PE entity %s\n&quot;,
 2735                               ent-&gt;name, NULL);
 2736             }
 2737         }
 2738         ctxt-&gt;depth++;
 2739         rep = xmlStringDecodeEntities(ctxt, ent-&gt;content, what,
 2740                                   0, 0, 0);
 2741         ctxt-&gt;depth--;
 2742         if (rep == NULL)
 2743                     goto int_error;
 2744                 current = rep;
 2745                 while (*current != 0) { /* non input consuming loop */
</pre>
<hr />
<pre>
 3369        (xmlIsNameChar(ctxt, c) &amp;&amp; (c != &#39;:&#39;))) {
 3370     if (count++ &gt; XML_PARSER_CHUNK_SIZE) {
 3371             if ((len &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3372                 ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3373                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;NCName&quot;);
 3374                 return(NULL);
 3375             }
 3376         count = 0;
 3377         GROW;
 3378             if (ctxt-&gt;instate == XML_PARSER_EOF)
 3379                 return(NULL);
 3380     }
 3381     len += l;
 3382     NEXTL(l);
 3383     c = CUR_CHAR(l);
 3384     if (c == 0) {
 3385         count = 0;
 3386         /*
 3387          * when shrinking to extend the buffer we really need to preserve
 3388          * the part of the name we already parsed. Hence rolling back
<span class="line-modified"> 3389          * by current length.</span>
 3390          */
 3391         ctxt-&gt;input-&gt;cur -= l;
 3392         GROW;
 3393             if (ctxt-&gt;instate == XML_PARSER_EOF)
 3394                 return(NULL);
 3395         ctxt-&gt;input-&gt;cur += l;
 3396         c = CUR_CHAR(l);
 3397     }
 3398     }
 3399     if ((len &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3400         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3401         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;NCName&quot;);
 3402         return(NULL);
 3403     }
 3404     return(xmlDictLookup(ctxt-&gt;dict, (BASE_PTR + startPosition), len));
 3405 }
 3406 
 3407 /**
 3408  * xmlParseNCName:
 3409  * @ctxt:  an XML parser context
</pre>
<hr />
<pre>
 3838      */
 3839     ++ctxt-&gt;depth;
 3840     ret = xmlStringDecodeEntities(ctxt, buf, XML_SUBSTITUTE_PEREF,
 3841                                   0, 0, 0);
 3842     --ctxt-&gt;depth;
 3843     if (orig != NULL) {
 3844         *orig = buf;
 3845         buf = NULL;
 3846     }
 3847 
 3848 error:
 3849     if (buf != NULL)
 3850         xmlFree(buf);
 3851     return(ret);
 3852 }
 3853 
 3854 /**
 3855  * xmlParseAttValueComplex:
 3856  * @ctxt:  an XML parser context
 3857  * @len:   the resulting attribute len
<span class="line-modified"> 3858  * @normalize:  whether to apply the inner normalization</span>
 3859  *
 3860  * parse a value for an attribute, this is the fallback function
 3861  * of xmlParseAttValue() when the attribute parsing requires handling
 3862  * of non-ASCII characters, or normalization compaction.
 3863  *
 3864  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.
 3865  */
 3866 static xmlChar *
 3867 xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
 3868     xmlChar limit = 0;
 3869     xmlChar *buf = NULL;
 3870     xmlChar *rep = NULL;
 3871     size_t len = 0;
 3872     size_t buf_size = 0;
 3873     int c, l, in_space = 0;
 3874     xmlChar *current = NULL;
 3875     xmlEntityPtr ent;
 3876 
 3877     if (NXT(0) == &#39;&quot;&#39;) {
 3878     ctxt-&gt;instate = XML_PARSER_ATTRIBUTE_VALUE;
</pre>
<hr />
<pre>
 3987                 xmlFree(rep);
 3988                 rep = NULL;
 3989             }
 3990             } else {
 3991             if (len + 10 &gt; buf_size) {
 3992                 growBuffer(buf, 10);
 3993             }
 3994             if (ent-&gt;content != NULL)
 3995                 buf[len++] = ent-&gt;content[0];
 3996             }
 3997         } else if (ent != NULL) {
 3998             int i = xmlStrlen(ent-&gt;name);
 3999             const xmlChar *cur = ent-&gt;name;
 4000 
 4001             /*
 4002              * This may look absurd but is needed to detect
 4003              * entities problems
 4004              */
 4005             if ((ent-&gt;etype != XML_INTERNAL_PREDEFINED_ENTITY) &amp;&amp;
 4006             (ent-&gt;content != NULL) &amp;&amp; (ent-&gt;checked == 0)) {
<span class="line-modified"> 4007             unsigned long oldnbent = ctxt-&gt;nbentities, diff;</span>
 4008 
 4009             ++ctxt-&gt;depth;
 4010             rep = xmlStringDecodeEntities(ctxt, ent-&gt;content,
 4011                           XML_SUBSTITUTE_REF, 0, 0, 0);
 4012             --ctxt-&gt;depth;
 4013 
<span class="line-modified"> 4014                         diff = ctxt-&gt;nbentities - oldnbent + 1;</span>
<span class="line-added"> 4015                         if (diff &gt; INT_MAX / 2)</span>
<span class="line-added"> 4016                             diff = INT_MAX / 2;</span>
<span class="line-added"> 4017                         ent-&gt;checked = diff * 2;</span>
 4018             if (rep != NULL) {
 4019                 if (xmlStrchr(rep, &#39;&lt;&#39;))
 4020                     ent-&gt;checked |= 1;
 4021                 xmlFree(rep);
 4022                 rep = NULL;
 4023             } else {
 4024                             ent-&gt;content[0] = 0;
 4025                         }
 4026             }
 4027 
 4028             /*
 4029              * Just output the reference
 4030              */
 4031             buf[len++] = &#39;&amp;&#39;;
 4032             while (len + i + 10 &gt; buf_size) {
 4033             growBuffer(buf, i + 10);
 4034             }
 4035             for (;i &gt; 0;i--)
 4036             buf[len++] = *cur++;
 4037             buf[len++] = &#39;;&#39;;
</pre>
<hr />
<pre>
 4065 
 4066     if ((in_space) &amp;&amp; (normalize)) {
 4067         while ((len &gt; 0) &amp;&amp; (buf[len - 1] == 0x20)) len--;
 4068     }
 4069     buf[len] = 0;
 4070     if (RAW == &#39;&lt;&#39;) {
 4071     xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);
 4072     } else if (RAW != limit) {
 4073     if ((c != 0) &amp;&amp; (!IS_CHAR(c))) {
 4074         xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
 4075                &quot;invalid character in attribute value\n&quot;);
 4076     } else {
 4077         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 4078                &quot;AttValue: &#39; expected\n&quot;);
 4079         }
 4080     } else
 4081     NEXT;
 4082 
 4083     /*
 4084      * There we potentially risk an overflow, don&#39;t allow attribute value of
<span class="line-modified"> 4085      * length more than INT_MAX it is a very reasonable assumption !</span>
 4086      */
 4087     if (len &gt;= INT_MAX) {
 4088         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 4089                        &quot;AttValue length too long\n&quot;);
 4090         goto mem_error;
 4091     }
 4092 
 4093     if (attlen != NULL) *attlen = (int) len;
 4094     return(buf);
 4095 
 4096 mem_error:
 4097     xmlErrMemory(ctxt, NULL);
 4098 error:
 4099     if (buf != NULL)
 4100         xmlFree(buf);
 4101     if (rep != NULL)
 4102         xmlFree(rep);
 4103     return(NULL);
 4104 }
 4105 
</pre>
<hr />
<pre>
 4670          * We handle [83] so we return immediately, if
 4671          * &quot;S SystemLiteral&quot; is not detected. We skip blanks if no
 4672              * system literal was found, but this is harmless since we must
 4673              * be at the end of a NotationDecl.
 4674          */
 4675         if (SKIP_BLANKS == 0) return(NULL);
 4676         if ((CUR != &#39;\&#39;&#39;) &amp;&amp; (CUR != &#39;&quot;&#39;)) return(NULL);
 4677     }
 4678     URI = xmlParseSystemLiteral(ctxt);
 4679     if (URI == NULL) {
 4680         xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);
 4681         }
 4682     }
 4683     return(URI);
 4684 }
 4685 
 4686 /**
 4687  * xmlParseCommentComplex:
 4688  * @ctxt:  an XML parser context
 4689  * @buf:  the already parsed part of the buffer
<span class="line-modified"> 4690  * @len:  number of bytes in the buffer</span>
 4691  * @size:  allocated size of the buffer
 4692  *
 4693  * Skip an XML (SGML) comment &lt;!-- .... --&gt;
 4694  *  The spec says that &quot;For compatibility, the string &quot;--&quot; (double-hyphen)
 4695  *  must not occur within comments. &quot;
 4696  * This is the slow routine in case the accelerator for ascii didn&#39;t work
 4697  *
 4698  * [15] Comment ::= &#39;&lt;!--&#39; ((Char - &#39;-&#39;) | (&#39;-&#39; (Char - &#39;-&#39;)))* &#39;--&gt;&#39;
 4699  */
 4700 static void
 4701 xmlParseCommentComplex(xmlParserCtxtPtr ctxt, xmlChar *buf,
 4702                        size_t len, size_t size) {
 4703     int q, ql;
 4704     int r, rl;
 4705     int cur, l;
 4706     size_t count = 0;
 4707     int inputid;
 4708 
 4709     inputid = ctxt-&gt;input-&gt;id;
 4710 
</pre>
<hr />
<pre>
 4961                 (!ctxt-&gt;disableSAX)) {
 4962             if (buf != NULL)
 4963                 ctxt-&gt;sax-&gt;comment(ctxt-&gt;userData, buf);
 4964             else
 4965                 ctxt-&gt;sax-&gt;comment(ctxt-&gt;userData, BAD_CAST &quot;&quot;);
 4966             }
 4967             if (buf != NULL)
 4968                 xmlFree(buf);
 4969             if (ctxt-&gt;instate != XML_PARSER_EOF)
 4970             ctxt-&gt;instate = state;
 4971             return;
 4972         }
 4973         if (buf != NULL) {
 4974             xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
 4975                               &quot;Double hyphen within comment: &quot;
 4976                                       &quot;&lt;!--%.50s\n&quot;,
 4977                       buf);
 4978         } else
 4979             xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
 4980                               &quot;Double hyphen within comment\n&quot;, NULL);
<span class="line-added"> 4981                 if (ctxt-&gt;instate == XML_PARSER_EOF) {</span>
<span class="line-added"> 4982                     xmlFree(buf);</span>
<span class="line-added"> 4983                     return;</span>
<span class="line-added"> 4984                 }</span>
 4985         in++;
 4986         ctxt-&gt;input-&gt;col++;
 4987         }
 4988         in++;
 4989         ctxt-&gt;input-&gt;col++;
 4990         goto get_more;
 4991     }
 4992     } while (((*in &gt;= 0x20) &amp;&amp; (*in &lt;= 0x7F)) || (*in == 0x09));
 4993     xmlParseCommentComplex(ctxt, buf, len, size);
 4994     ctxt-&gt;instate = state;
 4995     return;
 4996 }
 4997 
 4998 
 4999 /**
 5000  * xmlParsePITarget:
 5001  * @ctxt:  an XML parser context
 5002  *
 5003  * parse the name of a PI
 5004  *
</pre>
<hr />
<pre>
 5095     }
 5096     return;
 5097 
 5098 error:
 5099     xmlWarningMsg(ctxt, XML_WAR_CATALOG_PI,
 5100               &quot;Catalog PI syntax error: %s\n&quot;,
 5101           catalog, NULL);
 5102     if (URL != NULL)
 5103     xmlFree(URL);
 5104 }
 5105 #endif
 5106 
 5107 /**
 5108  * xmlParsePI:
 5109  * @ctxt:  an XML parser context
 5110  *
 5111  * parse an XML Processing Instruction.
 5112  *
 5113  * [16] PI ::= &#39;&lt;?&#39; PITarget (S (Char* - (Char* &#39;?&gt;&#39; Char*)))? &#39;?&gt;&#39;
 5114  *
<span class="line-modified"> 5115  * The processing is transferred to SAX once parsed.</span>
 5116  */
 5117 
 5118 void
 5119 xmlParsePI(xmlParserCtxtPtr ctxt) {
 5120     xmlChar *buf = NULL;
 5121     size_t len = 0;
 5122     size_t size = XML_PARSER_BUFFER_SIZE;
 5123     int cur, l;
 5124     const xmlChar *target;
 5125     xmlParserInputState state;
 5126     int count = 0;
 5127 
 5128     if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;?&#39;)) {
 5129     int inputid = ctxt-&gt;input-&gt;id;
 5130     state = ctxt-&gt;instate;
 5131         ctxt-&gt;instate = XML_PARSER_PI;
 5132     /*
 5133      * this is a Processing Instruction.
 5134      */
 5135     SKIP(2);
</pre>
<hr />
<pre>
 5511         }
 5512         if (CMP5(CUR_PTR, &#39;N&#39;, &#39;D&#39;, &#39;A&#39;, &#39;T&#39;, &#39;A&#39;)) {
 5513             SKIP(5);
 5514             if (SKIP_BLANKS == 0) {
 5515             xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5516                        &quot;Space required after &#39;NDATA&#39;\n&quot;);
 5517             }
 5518             ndata = xmlParseName(ctxt);
 5519             if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX) &amp;&amp;
 5520                 (ctxt-&gt;sax-&gt;unparsedEntityDecl != NULL))
 5521             ctxt-&gt;sax-&gt;unparsedEntityDecl(ctxt-&gt;userData, name,
 5522                     literal, URI, ndata);
 5523         } else {
 5524             if ((ctxt-&gt;sax != NULL) &amp;&amp;
 5525                 (!ctxt-&gt;disableSAX) &amp;&amp; (ctxt-&gt;sax-&gt;entityDecl != NULL))
 5526             ctxt-&gt;sax-&gt;entityDecl(ctxt-&gt;userData, name,
 5527                     XML_EXTERNAL_GENERAL_PARSED_ENTITY,
 5528                     literal, URI, NULL);
 5529             /*
 5530              * For expat compatibility in SAX mode.
<span class="line-modified"> 5531              * assuming the entity replacement was asked for</span>
 5532              */
 5533             if ((ctxt-&gt;replaceEntities != 0) &amp;&amp;
 5534             ((ctxt-&gt;myDoc == NULL) ||
 5535             (xmlStrEqual(ctxt-&gt;myDoc-&gt;version, SAX_COMPAT_MODE)))) {
 5536             if (ctxt-&gt;myDoc == NULL) {
 5537                 ctxt-&gt;myDoc = xmlNewDoc(SAX_COMPAT_MODE);
 5538                 if (ctxt-&gt;myDoc == NULL) {
 5539                     xmlErrMemory(ctxt, &quot;New Doc failed&quot;);
 5540                 return;
 5541                 }
 5542                 ctxt-&gt;myDoc-&gt;properties = XML_DOC_INTERNAL;
 5543             }
 5544 
 5545             if (ctxt-&gt;myDoc-&gt;intSubset == NULL)
 5546                 ctxt-&gt;myDoc-&gt;intSubset = xmlNewDtd(ctxt-&gt;myDoc,
 5547                         BAD_CAST &quot;fake&quot;, NULL, NULL);
 5548             xmlSAX2EntityDecl(ctxt, name,
 5549                           XML_EXTERNAL_GENERAL_PARSED_ENTITY,
 5550                           literal, URI, NULL);
 5551             }
</pre>
<hr />
<pre>
 6621         xmlFreeDocElementContent(ctxt-&gt;myDoc, content);
 6622         }
 6623     }
 6624     }
 6625     return(ret);
 6626 }
 6627 
 6628 /**
 6629  * xmlParseConditionalSections
 6630  * @ctxt:  an XML parser context
 6631  *
 6632  * [61] conditionalSect ::= includeSect | ignoreSect
 6633  * [62] includeSect ::= &#39;&lt;![&#39; S? &#39;INCLUDE&#39; S? &#39;[&#39; extSubsetDecl &#39;]]&gt;&#39;
 6634  * [63] ignoreSect ::= &#39;&lt;![&#39; S? &#39;IGNORE&#39; S? &#39;[&#39; ignoreSectContents* &#39;]]&gt;&#39;
 6635  * [64] ignoreSectContents ::= Ignore (&#39;&lt;![&#39; ignoreSectContents &#39;]]&gt;&#39; Ignore)*
 6636  * [65] Ignore ::= Char* - (Char* (&#39;&lt;![&#39; | &#39;]]&gt;&#39;) Char*)
 6637  */
 6638 
 6639 static void
 6640 xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
<span class="line-added"> 6641     int *inputIds = NULL;</span>
<span class="line-added"> 6642     size_t inputIdsSize = 0;</span>
<span class="line-added"> 6643     size_t depth = 0;</span>
<span class="line-added"> 6644 </span>
<span class="line-added"> 6645     while (ctxt-&gt;instate != XML_PARSER_EOF) {</span>
<span class="line-added"> 6646         if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {</span>
 6647     int id = ctxt-&gt;input-&gt;id;
 6648 
 6649     SKIP(3);
 6650     SKIP_BLANKS;
<span class="line-added"> 6651 </span>
 6652     if (CMP7(CUR_PTR, &#39;I&#39;, &#39;N&#39;, &#39;C&#39;, &#39;L&#39;, &#39;U&#39;, &#39;D&#39;, &#39;E&#39;)) {
 6653     SKIP(7);
 6654     SKIP_BLANKS;
 6655     if (RAW != &#39;[&#39;) {
 6656         xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
 6657         xmlHaltParser(ctxt);
<span class="line-modified"> 6658                     goto error;</span>
<span class="line-modified"> 6659                 }</span>
 6660         if (ctxt-&gt;input-&gt;id != id) {
 6661         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
<span class="line-modified"> 6662                                    &quot;All markup of the conditional section is&quot;</span>
<span class="line-modified"> 6663                                    &quot; not in the same entity\n&quot;);</span>
 6664         }
 6665         NEXT;









 6666 
<span class="line-modified"> 6667                 if (inputIdsSize &lt;= depth) {</span>
<span class="line-modified"> 6668                     int *tmp;</span>












 6669 
<span class="line-modified"> 6670                     inputIdsSize = (inputIdsSize == 0 ? 4 : inputIdsSize * 2);</span>
<span class="line-modified"> 6671                     tmp = (int *) xmlRealloc(inputIds,</span>
<span class="line-modified"> 6672                             inputIdsSize * sizeof(int));</span>
<span class="line-modified"> 6673                     if (tmp == NULL) {</span>
<span class="line-added"> 6674                         xmlErrMemory(ctxt, NULL);</span>
<span class="line-added"> 6675                         goto error;</span>
 6676         }
<span class="line-added"> 6677                     inputIds = tmp;</span>
 6678     }
<span class="line-modified"> 6679                 inputIds[depth] = id;</span>
<span class="line-modified"> 6680                 depth++;</span>







 6681     } else if (CMP6(CUR_PTR, &#39;I&#39;, &#39;G&#39;, &#39;N&#39;, &#39;O&#39;, &#39;R&#39;, &#39;E&#39;)) {
 6682     int state;
 6683     xmlParserInputState instate;
<span class="line-modified"> 6684                 size_t ignoreDepth = 0;</span>
 6685 
 6686     SKIP(6);
 6687     SKIP_BLANKS;
 6688     if (RAW != &#39;[&#39;) {
 6689         xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
 6690         xmlHaltParser(ctxt);
<span class="line-modified"> 6691                     goto error;</span>
<span class="line-modified"> 6692                 }</span>
 6693         if (ctxt-&gt;input-&gt;id != id) {
 6694         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
<span class="line-modified"> 6695                                    &quot;All markup of the conditional section is&quot;</span>
<span class="line-modified"> 6696                                    &quot; not in the same entity\n&quot;);</span>
 6697         }
 6698         NEXT;









 6699 
 6700     /*
<span class="line-modified"> 6701                  * Parse up to the end of the conditional section but disable</span>
<span class="line-modified"> 6702                  * SAX event generating DTD building in the meantime</span>
 6703      */
 6704     state = ctxt-&gt;disableSAX;
 6705     instate = ctxt-&gt;instate;
 6706     if (ctxt-&gt;recovery == 0) ctxt-&gt;disableSAX = 1;
 6707     ctxt-&gt;instate = XML_PARSER_IGNORE;
 6708 
<span class="line-modified"> 6709                 while (RAW != 0) {</span>

 6710       if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {

 6711         SKIP(3);
<span class="line-modified"> 6712                         ignoreDepth++;</span>
<span class="line-modified"> 6713                         /* Check for integer overflow */</span>
<span class="line-modified"> 6714                         if (ignoreDepth == 0) {</span>
<span class="line-modified"> 6715                             xmlErrMemory(ctxt, NULL);</span>
<span class="line-modified"> 6716                             goto error;</span>
 6717       }
<span class="line-added"> 6718                     } else if ((RAW == &#39;]&#39;) &amp;&amp; (NXT(1) == &#39;]&#39;) &amp;&amp;</span>
<span class="line-added"> 6719                                (NXT(2) == &#39;&gt;&#39;)) {</span>
<span class="line-added"> 6720                         if (ignoreDepth == 0)</span>
<span class="line-added"> 6721                             break;</span>
<span class="line-added"> 6722                         SKIP(3);</span>
<span class="line-added"> 6723                         ignoreDepth--;</span>
<span class="line-added"> 6724                     } else {</span>
 6725       NEXT;
<span class="line-modified"> 6726                     }</span>
 6727     }
 6728 
 6729     ctxt-&gt;disableSAX = state;
 6730     ctxt-&gt;instate = instate;
 6731 
<span class="line-modified"> 6732         if (RAW == 0) {</span>
<span class="line-modified"> 6733             xmlFatalErr(ctxt, XML_ERR_CONDSEC_NOT_FINISHED, NULL);</span>
<span class="line-modified"> 6734                     goto error;</span>




 6735     }
<span class="line-modified"> 6736                 if (ctxt-&gt;input-&gt;id != id) {</span>
<span class="line-added"> 6737                     xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,</span>
<span class="line-added"> 6738                                    &quot;All markup of the conditional section is&quot;</span>
<span class="line-added"> 6739                                    &quot; not in the same entity\n&quot;);</span>
<span class="line-added"> 6740                 }</span>
<span class="line-added"> 6741                 SKIP(3);</span>
 6742     } else {
 6743     xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID_KEYWORD, NULL);
 6744     xmlHaltParser(ctxt);
<span class="line-modified"> 6745                 goto error;</span>
 6746     }
<span class="line-modified"> 6747         } else if ((depth &gt; 0) &amp;&amp;</span>
<span class="line-modified"> 6748                    (RAW == &#39;]&#39;) &amp;&amp; (NXT(1) == &#39;]&#39;) &amp;&amp; (NXT(2) == &#39;&gt;&#39;)) {</span>
<span class="line-modified"> 6749             depth--;</span>
<span class="line-modified"> 6750             if (ctxt-&gt;input-&gt;id != inputIds[depth]) {</span>




 6751         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
<span class="line-modified"> 6752                                &quot;All markup of the conditional section is not&quot;</span>
<span class="line-modified"> 6753                                &quot; in the same entity\n&quot;);</span>
 6754     }


 6755         SKIP(3);
<span class="line-added"> 6756         } else {</span>
<span class="line-added"> 6757             const xmlChar *check = CUR_PTR;</span>
<span class="line-added"> 6758             unsigned int cons = ctxt-&gt;input-&gt;consumed;</span>
<span class="line-added"> 6759 </span>
<span class="line-added"> 6760             xmlParseMarkupDecl(ctxt);</span>
<span class="line-added"> 6761 </span>
<span class="line-added"> 6762             if ((CUR_PTR == check) &amp;&amp; (cons == ctxt-&gt;input-&gt;consumed)) {</span>
<span class="line-added"> 6763                 xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);</span>
<span class="line-added"> 6764                 xmlHaltParser(ctxt);</span>
<span class="line-added"> 6765                 goto error;</span>
<span class="line-added"> 6766             }</span>
<span class="line-added"> 6767     }</span>
<span class="line-added"> 6768 </span>
<span class="line-added"> 6769         if (depth == 0)</span>
<span class="line-added"> 6770             break;</span>
<span class="line-added"> 6771 </span>
<span class="line-added"> 6772         SKIP_BLANKS;</span>
<span class="line-added"> 6773         GROW;</span>
 6774     }
<span class="line-added"> 6775 </span>
<span class="line-added"> 6776 error:</span>
<span class="line-added"> 6777     xmlFree(inputIds);</span>
 6778 }
 6779 
 6780 /**
 6781  * xmlParseMarkupDecl:
 6782  * @ctxt:  an XML parser context
 6783  *
 6784  * parse Markup declarations
 6785  *
 6786  * [29] markupdecl ::= elementdecl | AttlistDecl | EntityDecl |
 6787  *                     NotationDecl | PI | Comment
 6788  *
 6789  * [ VC: Proper Declaration/PE Nesting ]
 6790  * Parameter-entity replacement text must be properly nested with
 6791  * markup declarations. That is to say, if either the first character
 6792  * or the last character of a markup declaration (markupdecl above) is
 6793  * contained in the replacement text for a parameter-entity reference,
 6794  * both must be contained in the same replacement text.
 6795  *
 6796  * [ WFC: PEs in Internal Subset ]
 6797  * In the internal DTD subset, parameter-entity references can occur
</pre>
<hr />
<pre>
 6814             case &#39;A&#39;:
 6815             xmlParseAttributeListDecl(ctxt);
 6816             break;
 6817             case &#39;N&#39;:
 6818             xmlParseNotationDecl(ctxt);
 6819             break;
 6820             case &#39;-&#39;:
 6821             xmlParseComment(ctxt);
 6822             break;
 6823         default:
 6824             /* there is an error but it will be detected later */
 6825             break;
 6826         }
 6827     } else if (NXT(1) == &#39;?&#39;) {
 6828         xmlParsePI(ctxt);
 6829     }
 6830     }
 6831 
 6832     /*
 6833      * detect requirement to exit there and act accordingly
<span class="line-modified"> 6834      * and avoid having instate overridden later on</span>
 6835      */
 6836     if (ctxt-&gt;instate == XML_PARSER_EOF)
 6837         return;
 6838 










 6839     ctxt-&gt;instate = XML_PARSER_DTD;
 6840 }
 6841 
 6842 /**
 6843  * xmlParseTextDecl:
 6844  * @ctxt:  an XML parser context
 6845  *
 6846  * parse an XML declaration header for external entities
 6847  *
 6848  * [77] TextDecl ::= &#39;&lt;?xml&#39; VersionInfo? EncodingDecl S? &#39;?&gt;&#39;
 6849  */
 6850 
 6851 void
 6852 xmlParseTextDecl(xmlParserCtxtPtr ctxt) {
 6853     xmlChar *version;
 6854     const xmlChar *encoding;
 6855 
 6856     /*
 6857      * We know that &#39;&lt;?xml&#39; is here.
 6858      */
</pre>
<hr />
<pre>
 7003  *
 7004  * [67] Reference ::= EntityRef | CharRef
 7005  */
 7006 void
 7007 xmlParseReference(xmlParserCtxtPtr ctxt) {
 7008     xmlEntityPtr ent;
 7009     xmlChar *val;
 7010     int was_checked;
 7011     xmlNodePtr list = NULL;
 7012     xmlParserErrors ret = XML_ERR_OK;
 7013 
 7014 
 7015     if (RAW != &#39;&amp;&#39;)
 7016         return;
 7017 
 7018     /*
 7019      * Simple case of a CharRef
 7020      */
 7021     if (NXT(1) == &#39;#&#39;) {
 7022     int i = 0;
<span class="line-modified"> 7023     xmlChar out[16];</span>
 7024     int hex = NXT(2);
 7025     int value = xmlParseCharRef(ctxt);
 7026 
 7027     if (value == 0)
 7028         return;
 7029     if (ctxt-&gt;charset != XML_CHAR_ENCODING_UTF8) {
 7030         /*
 7031          * So we are using non-UTF-8 buffers
 7032          * Check that the char fit on 8bits, if not
 7033          * generate a CharRef.
 7034          */
 7035         if (value &lt;= 0xFF) {
 7036         out[0] = value;
 7037         out[1] = 0;
 7038         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;characters != NULL) &amp;&amp;
 7039             (!ctxt-&gt;disableSAX))
 7040             ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, out, 1);
 7041         } else {
 7042         if ((hex == &#39;x&#39;) || (hex == &#39;X&#39;))
 7043             snprintf((char *)out, sizeof(out), &quot;#x%X&quot;, value);
</pre>
<hr />
<pre>
 7080     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;characters != NULL) &amp;&amp;
 7081         (!ctxt-&gt;disableSAX))
 7082         ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, val, xmlStrlen(val));
 7083     return;
 7084     }
 7085 
 7086     /*
 7087      * The first reference to the entity trigger a parsing phase
 7088      * where the ent-&gt;children is filled with the result from
 7089      * the parsing.
 7090      * Note: external parsed entities will not be loaded, it is not
 7091      * required for a non-validating parser, unless the parsing option
 7092      * of validating, or substituting entities were given. Doing so is
 7093      * far more secure as the parser will only process data coming from
 7094      * the document entity by default.
 7095      */
 7096     if (((ent-&gt;checked == 0) ||
 7097          ((ent-&gt;children == NULL) &amp;&amp; (ctxt-&gt;options &amp; XML_PARSE_NOENT))) &amp;&amp;
 7098         ((ent-&gt;etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
 7099          (ctxt-&gt;options &amp; (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {
<span class="line-modified"> 7100     unsigned long oldnbent = ctxt-&gt;nbentities, diff;</span>
 7101 
 7102     /*
 7103      * This is a bit hackish but this seems the best
 7104      * way to make sure both SAX and DOM entity support
 7105      * behaves okay.
 7106      */
 7107     void *user_data;
 7108     if (ctxt-&gt;userData == ctxt)
 7109         user_data = NULL;
 7110     else
 7111         user_data = ctxt-&gt;userData;
 7112 
 7113     /*
 7114      * Check that this entity is well formed
 7115      * 4.3.2: An internal general parsed entity is well-formed
 7116      * if its replacement text matches the production labeled
 7117      * content.
 7118      */
 7119     if (ent-&gt;etype == XML_INTERNAL_GENERAL_ENTITY) {
 7120         ctxt-&gt;depth++;
 7121         ret = xmlParseBalancedChunkMemoryInternal(ctxt, ent-&gt;content,
 7122                                                   user_data, &amp;list);
 7123         ctxt-&gt;depth--;
 7124 
 7125     } else if (ent-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
 7126         ctxt-&gt;depth++;
 7127         ret = xmlParseExternalEntityPrivate(ctxt-&gt;myDoc, ctxt, ctxt-&gt;sax,
 7128                                        user_data, ctxt-&gt;depth, ent-&gt;URI,
 7129                        ent-&gt;ExternalID, &amp;list);
 7130         ctxt-&gt;depth--;
 7131     } else {
 7132         ret = XML_ERR_ENTITY_PE_INTERNAL;
 7133         xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,
 7134              &quot;invalid entity type found\n&quot;, NULL);
 7135     }
 7136 
 7137     /*
 7138      * Store the number of entities needing parsing for this entity
 7139      * content and do checkings
 7140      */
<span class="line-modified"> 7141         diff = ctxt-&gt;nbentities - oldnbent + 1;</span>
<span class="line-added"> 7142         if (diff &gt; INT_MAX / 2)</span>
<span class="line-added"> 7143             diff = INT_MAX / 2;</span>
<span class="line-added"> 7144         ent-&gt;checked = diff * 2;</span>
 7145     if ((ent-&gt;content != NULL) &amp;&amp; (xmlStrchr(ent-&gt;content, &#39;&lt;&#39;)))
 7146         ent-&gt;checked |= 1;
 7147     if (ret == XML_ERR_ENTITY_LOOP) {
 7148         xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 7149         xmlFreeNodeList(list);
 7150         return;
 7151     }
 7152     if (xmlParserEntityCheck(ctxt, 0, ent, 0)) {
 7153         xmlFreeNodeList(list);
 7154         return;
 7155     }
 7156 
 7157     if ((ret == XML_ERR_OK) &amp;&amp; (list != NULL)) {
 7158         if (((ent-&gt;etype == XML_INTERNAL_GENERAL_ENTITY) ||
 7159          (ent-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY))&amp;&amp;
 7160         (ent-&gt;children == NULL)) {
 7161         ent-&gt;children = list;
 7162         if (ctxt-&gt;replaceEntities) {
 7163             /*
 7164              * Prune it directly in the generated document
</pre>
<hr />
<pre>
 7672         xmlFree(name);
 7673     *str = ptr;
 7674     return(NULL);
 7675     }
 7676     ptr++;
 7677 
 7678 
 7679     /*
 7680      * Predefined entities override any extra definition
 7681      */
 7682     if ((ctxt-&gt;options &amp; XML_PARSE_OLDSAX) == 0) {
 7683         ent = xmlGetPredefinedEntity(name);
 7684         if (ent != NULL) {
 7685             xmlFree(name);
 7686             *str = ptr;
 7687             return(ent);
 7688         }
 7689     }
 7690 
 7691     /*
<span class="line-modified"> 7692      * Increase the number of entity references parsed</span>
 7693      */
 7694     ctxt-&gt;nbentities++;
 7695 
 7696     /*
 7697      * Ask first SAX for entity resolution, otherwise try the
 7698      * entities which may have stored in the parser context.
 7699      */
 7700     if (ctxt-&gt;sax != NULL) {
 7701     if (ctxt-&gt;sax-&gt;getEntity != NULL)
 7702         ent = ctxt-&gt;sax-&gt;getEntity(ctxt-&gt;userData, name);
 7703     if ((ent == NULL) &amp;&amp; (ctxt-&gt;options &amp; XML_PARSE_OLDSAX))
 7704         ent = xmlGetPredefinedEntity(name);
 7705     if ((ent == NULL) &amp;&amp; (ctxt-&gt;userData==ctxt)) {
 7706         ent = xmlSAX2GetEntity(ctxt, name);
 7707     }
 7708     }
 7709     if (ctxt-&gt;instate == XML_PARSER_EOF) {
 7710     xmlFree(name);
 7711     return(NULL);
 7712     }
</pre>
<hr />
<pre>
 7848 
 7849     if (RAW != &#39;%&#39;)
 7850         return;
 7851     NEXT;
 7852     name = xmlParseName(ctxt);
 7853     if (name == NULL) {
 7854     xmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, &quot;PEReference: no name\n&quot;);
 7855     return;
 7856     }
 7857     if (xmlParserDebugEntities)
 7858     xmlGenericError(xmlGenericErrorContext,
 7859         &quot;PEReference: %s\n&quot;, name);
 7860     if (RAW != &#39;;&#39;) {
 7861     xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);
 7862         return;
 7863     }
 7864 
 7865     NEXT;
 7866 
 7867     /*
<span class="line-modified"> 7868      * Increase the number of entity references parsed</span>
 7869      */
 7870     ctxt-&gt;nbentities++;
 7871 
 7872     /*
 7873      * Request the entity from SAX
 7874      */
 7875     if ((ctxt-&gt;sax != NULL) &amp;&amp;
 7876     (ctxt-&gt;sax-&gt;getParameterEntity != NULL))
 7877     entity = ctxt-&gt;sax-&gt;getParameterEntity(ctxt-&gt;userData, name);
 7878     if (ctxt-&gt;instate == XML_PARSER_EOF)
 7879     return;
 7880     if (entity == NULL) {
 7881     /*
 7882      * [ WFC: Entity Declared ]
 7883      * In a document without any DTD, a document with only an
 7884      * internal DTD subset which contains no parameter entity
 7885      * references, or a document with &quot;standalone=&#39;yes&#39;&quot;, ...
 7886      * ... The declaration of a parameter entity must precede
 7887      * any reference to it...
 7888      */
</pre>
<hr />
<pre>
 8114     if (cur != &#39;%&#39;)
 8115         return(NULL);
 8116     ptr++;
 8117     name = xmlParseStringName(ctxt, &amp;ptr);
 8118     if (name == NULL) {
 8119     xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 8120                &quot;xmlParseStringPEReference: no name\n&quot;);
 8121     *str = ptr;
 8122     return(NULL);
 8123     }
 8124     cur = *ptr;
 8125     if (cur != &#39;;&#39;) {
 8126     xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
 8127     xmlFree(name);
 8128     *str = ptr;
 8129     return(NULL);
 8130     }
 8131     ptr++;
 8132 
 8133     /*
<span class="line-modified"> 8134      * Increase the number of entity references parsed</span>
 8135      */
 8136     ctxt-&gt;nbentities++;
 8137 
 8138     /*
 8139      * Request the entity from SAX
 8140      */
 8141     if ((ctxt-&gt;sax != NULL) &amp;&amp;
 8142     (ctxt-&gt;sax-&gt;getParameterEntity != NULL))
 8143     entity = ctxt-&gt;sax-&gt;getParameterEntity(ctxt-&gt;userData, name);
 8144     if (ctxt-&gt;instate == XML_PARSER_EOF) {
 8145     xmlFree(name);
 8146     *str = ptr;
 8147     return(NULL);
 8148     }
 8149     if (entity == NULL) {
 8150     /*
 8151      * [ WFC: Entity Declared ]
 8152      * In a document without any DTD, a document with only an
 8153      * internal DTD subset which contains no parameter entity
 8154      * references, or a document with &quot;standalone=&#39;yes&#39;&quot;, ...
</pre>
<hr />
<pre>
 8282      * Is there any DTD definition ?
 8283      */
 8284     if (RAW == &#39;[&#39;) {
 8285         int baseInputNr = ctxt-&gt;inputNr;
 8286         ctxt-&gt;instate = XML_PARSER_DTD;
 8287         NEXT;
 8288     /*
 8289      * Parse the succession of Markup declarations and
 8290      * PEReferences.
 8291      * Subsequence (markupdecl | PEReference | S)*
 8292      */
 8293     while (((RAW != &#39;]&#39;) || (ctxt-&gt;inputNr &gt; baseInputNr)) &amp;&amp;
 8294                (ctxt-&gt;instate != XML_PARSER_EOF)) {
 8295         const xmlChar *check = CUR_PTR;
 8296         unsigned int cons = ctxt-&gt;input-&gt;consumed;
 8297 
 8298         SKIP_BLANKS;
 8299         xmlParseMarkupDecl(ctxt);
 8300         xmlParsePEReference(ctxt);
 8301 
<span class="line-added"> 8302             /*</span>
<span class="line-added"> 8303              * Conditional sections are allowed from external entities included</span>
<span class="line-added"> 8304              * by PE References in the internal subset.</span>
<span class="line-added"> 8305              */</span>
<span class="line-added"> 8306             if ((ctxt-&gt;inputNr &gt; 1) &amp;&amp; (ctxt-&gt;input-&gt;filename != NULL) &amp;&amp;</span>
<span class="line-added"> 8307                 (RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {</span>
<span class="line-added"> 8308                 xmlParseConditionalSections(ctxt);</span>
<span class="line-added"> 8309             }</span>
<span class="line-added"> 8310 </span>
 8311         if ((CUR_PTR == check) &amp;&amp; (cons == ctxt-&gt;input-&gt;consumed)) {
 8312         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 8313          &quot;xmlParseInternalSubset: error detected in Markup declaration\n&quot;);
 8314                 if (ctxt-&gt;inputNr &gt; baseInputNr)
 8315                     xmlPopInput(ctxt);
 8316                 else
 8317             break;
 8318         }
 8319     }
 8320     if (RAW == &#39;]&#39;) {
 8321         NEXT;
 8322         SKIP_BLANKS;
 8323     }
 8324     }
 8325 
 8326     /*
 8327      * We should be at the end of the DOCTYPE declaration.
 8328      */
 8329     if (RAW != &#39;&gt;&#39;) {
 8330     xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);
</pre>
<hr />
<pre>
 8719     l = xmlParseNCName(ctxt);
 8720     if (l == NULL) {
 8721         if (CUR == &#39;:&#39;) {
 8722         l = xmlParseName(ctxt);
 8723         if (l != NULL) {
 8724             xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8725                  &quot;Failed to parse QName &#39;%s&#39;\n&quot;, l, NULL, NULL);
 8726         *prefix = NULL;
 8727         return(l);
 8728         }
 8729     }
 8730         return(NULL);
 8731     }
 8732     if (CUR == &#39;:&#39;) {
 8733         NEXT;
 8734     p = l;
 8735     l = xmlParseNCName(ctxt);
 8736     if (l == NULL) {
 8737         xmlChar *tmp;
 8738 
<span class="line-added"> 8739             if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-added"> 8740                 return(NULL);</span>
 8741             xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8742                  &quot;Failed to parse QName &#39;%s:&#39;\n&quot;, p, NULL, NULL);
 8743         l = xmlParseNmtoken(ctxt);
<span class="line-modified"> 8744         if (l == NULL) {</span>
<span class="line-added"> 8745                 if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-added"> 8746                     return(NULL);</span>
 8747         tmp = xmlBuildQName(BAD_CAST &quot;&quot;, p, NULL, 0);
<span class="line-modified"> 8748             } else {</span>
 8749         tmp = xmlBuildQName(l, p, NULL, 0);
 8750         xmlFree((char *)l);
 8751         }
 8752         p = xmlDictLookup(ctxt-&gt;dict, tmp, -1);
 8753         if (tmp != NULL) xmlFree(tmp);
 8754         *prefix = NULL;
 8755         return(p);
 8756     }
 8757     if (CUR == &#39;:&#39;) {
 8758         xmlChar *tmp;
 8759 
 8760             xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8761                  &quot;Failed to parse QName &#39;%s:%s:&#39;\n&quot;, p, l, NULL);
 8762         NEXT;
 8763         tmp = (xmlChar *) xmlParseName(ctxt);
 8764         if (tmp != NULL) {
 8765             tmp = xmlBuildQName(tmp, l, NULL, 0);
 8766         l = xmlDictLookup(ctxt-&gt;dict, tmp, -1);
 8767         if (tmp != NULL) xmlFree(tmp);
 8768         *prefix = p;
 8769         return(l);
 8770         }
<span class="line-added"> 8771             if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-added"> 8772                 return(NULL);</span>
 8773         tmp = xmlBuildQName(BAD_CAST &quot;&quot;, l, NULL, 0);
 8774         l = xmlDictLookup(ctxt-&gt;dict, tmp, -1);
 8775         if (tmp != NULL) xmlFree(tmp);
 8776         *prefix = p;
 8777         return(l);
 8778     }
 8779     *prefix = p;
 8780     } else
 8781         *prefix = NULL;
 8782     return(l);
 8783 }
 8784 
 8785 /**
 8786  * xmlParseQNameAndCompare:
 8787  * @ctxt:  an XML parser context
 8788  * @name:  the localname
 8789  * @prefix:  the prefix, if any.
 8790  *
 8791  * parse an XML name and compares for match
 8792  * (specialized for endtag parsing)
</pre>
<hr />
<pre>
 8852  * - a character reference is processed by appending the referenced
 8853  *   character to the attribute value
 8854  * - an entity reference is processed by recursively processing the
 8855  *   replacement text of the entity
 8856  * - a whitespace character (#x20, #xD, #xA, #x9) is processed by
 8857  *   appending #x20 to the normalized value, except that only a single
 8858  *   #x20 is appended for a &quot;#xD#xA&quot; sequence that is part of an external
 8859  *   parsed entity or the literal entity value of an internal parsed entity
 8860  * - other characters are processed by appending them to the normalized value
 8861  * If the declared value is not CDATA, then the XML processor must further
 8862  * process the normalized attribute value by discarding any leading and
 8863  * trailing space (#x20) characters, and by replacing sequences of space
 8864  * (#x20) characters by a single space (#x20) character.
 8865  * All attributes for which no declaration has been read should be treated
 8866  * by a non-validating parser as if declared CDATA.
 8867  *
 8868  * Returns the AttValue parsed or NULL. The value has to be freed by the
 8869  *     caller if it was copied, this can be detected by val[*len] == 0.
 8870  */
 8871 
<span class="line-added"> 8872 #define GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end) \</span>
<span class="line-added"> 8873     const xmlChar *oldbase = ctxt-&gt;input-&gt;base;\</span>
<span class="line-added"> 8874     GROW;\</span>
<span class="line-added"> 8875     if (ctxt-&gt;instate == XML_PARSER_EOF)\</span>
<span class="line-added"> 8876         return(NULL);\</span>
<span class="line-added"> 8877     if (oldbase != ctxt-&gt;input-&gt;base) {\</span>
<span class="line-added"> 8878         ptrdiff_t delta = ctxt-&gt;input-&gt;base - oldbase;\</span>
<span class="line-added"> 8879         start = start + delta;\</span>
<span class="line-added"> 8880         in = in + delta;\</span>
<span class="line-added"> 8881     }\</span>
<span class="line-added"> 8882     end = ctxt-&gt;input-&gt;end;</span>
<span class="line-added"> 8883 </span>
 8884 static xmlChar *
 8885 xmlParseAttValueInternal(xmlParserCtxtPtr ctxt, int *len, int *alloc,
 8886                          int normalize)
 8887 {
 8888     xmlChar limit = 0;
 8889     const xmlChar *in = NULL, *start, *end, *last;
 8890     xmlChar *ret = NULL;
 8891     int line, col;
 8892 
 8893     GROW;
 8894     in = (xmlChar *) CUR_PTR;
 8895     line = ctxt-&gt;input-&gt;line;
 8896     col = ctxt-&gt;input-&gt;col;
 8897     if (*in != &#39;&quot;&#39; &amp;&amp; *in != &#39;\&#39;&#39;) {
 8898         xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
 8899         return (NULL);
 8900     }
 8901     ctxt-&gt;instate = XML_PARSER_ATTRIBUTE_VALUE;
 8902 
 8903     /*
 8904      * try to handle in this routine the most common case where no
 8905      * allocation of a new string is required and where content is
 8906      * pure ASCII.
 8907      */
 8908     limit = *in++;
 8909     col++;
 8910     end = ctxt-&gt;input-&gt;end;
 8911     start = in;
 8912     if (in &gt;= end) {
<span class="line-modified"> 8913         GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)</span>







 8914     }
 8915     if (normalize) {
 8916         /*
 8917      * Skip any leading spaces
 8918      */
 8919     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp;
 8920            ((*in == 0x20) || (*in == 0x9) ||
 8921             (*in == 0xA) || (*in == 0xD))) {
 8922         if (*in == 0xA) {
 8923             line++; col = 1;
 8924         } else {
 8925             col++;
 8926         }
 8927         in++;
 8928         start = in;
 8929         if (in &gt;= end) {
<span class="line-modified"> 8930                 GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)</span>









 8931                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8932                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8933                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8934                                    &quot;AttValue length too long\n&quot;);
 8935                     return(NULL);
 8936                 }
 8937         }
 8938     }
 8939     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp; (*in &gt;= 0x20) &amp;&amp;
 8940            (*in &lt;= 0x7f) &amp;&amp; (*in != &#39;&amp;&#39;) &amp;&amp; (*in != &#39;&lt;&#39;)) {
 8941         col++;
 8942         if ((*in++ == 0x20) &amp;&amp; (*in == 0x20)) break;
 8943         if (in &gt;= end) {
<span class="line-modified"> 8944                 GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)</span>









 8945                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8946                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8947                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8948                                    &quot;AttValue length too long\n&quot;);
 8949                     return(NULL);
 8950                 }
 8951         }
 8952     }
 8953     last = in;
 8954     /*
 8955      * skip the trailing blanks
 8956      */
 8957     while ((last[-1] == 0x20) &amp;&amp; (last &gt; start)) last--;
 8958     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp;
 8959            ((*in == 0x20) || (*in == 0x9) ||
 8960             (*in == 0xA) || (*in == 0xD))) {
 8961         if (*in == 0xA) {
 8962             line++, col = 1;
 8963         } else {
 8964             col++;
 8965         }
 8966         in++;
 8967         if (in &gt;= end) {
 8968         const xmlChar *oldbase = ctxt-&gt;input-&gt;base;
 8969         GROW;
 8970                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 8971                     return(NULL);
 8972         if (oldbase != ctxt-&gt;input-&gt;base) {
<span class="line-modified"> 8973             ptrdiff_t delta = ctxt-&gt;input-&gt;base - oldbase;</span>
 8974             start = start + delta;
 8975             in = in + delta;
 8976             last = last + delta;
 8977         }
 8978         end = ctxt-&gt;input-&gt;end;
 8979                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8980                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8981                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8982                                    &quot;AttValue length too long\n&quot;);
 8983                     return(NULL);
 8984                 }
 8985         }
 8986     }
 8987         if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8988             ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8989             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8990                            &quot;AttValue length too long\n&quot;);
 8991             return(NULL);
 8992         }
 8993     if (*in != limit) goto need_complex;
 8994     } else {
 8995     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp; (*in &gt;= 0x20) &amp;&amp;
 8996            (*in &lt;= 0x7f) &amp;&amp; (*in != &#39;&amp;&#39;) &amp;&amp; (*in != &#39;&lt;&#39;)) {
 8997         in++;
 8998         col++;
 8999         if (in &gt;= end) {
<span class="line-modified"> 9000                 GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)</span>









 9001                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 9002                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 9003                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9004                                    &quot;AttValue length too long\n&quot;);
 9005                     return(NULL);
 9006                 }
 9007         }
 9008     }
 9009     last = in;
 9010         if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 9011             ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 9012             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9013                            &quot;AttValue length too long\n&quot;);
 9014             return(NULL);
 9015         }
 9016     if (*in != limit) goto need_complex;
 9017     }
 9018     in++;
 9019     col++;
 9020     if (len != NULL) {
</pre>
<hr />
<pre>
 9074     if (ctxt-&gt;attsSpecial != NULL) {
 9075         int type;
 9076 
 9077         type = (int) (ptrdiff_t) xmlHashQLookup2(ctxt-&gt;attsSpecial,
 9078                                                  pref, elem, *prefix, name);
 9079         if (type != 0)
 9080             normalize = 1;
 9081     }
 9082 
 9083     /*
 9084      * read the value
 9085      */
 9086     SKIP_BLANKS;
 9087     if (RAW == &#39;=&#39;) {
 9088         NEXT;
 9089         SKIP_BLANKS;
 9090         val = xmlParseAttValueInternal(ctxt, len, alloc, normalize);
 9091     if (normalize) {
 9092         /*
 9093          * Sometimes a second normalisation pass for spaces is needed
<span class="line-modified"> 9094          * but that only happens if charrefs or entities references</span>
 9095          * have been used in the attribute value, i.e. the attribute
 9096          * value have been extracted in an allocated string already.
 9097          */
 9098         if (*alloc) {
 9099             const xmlChar *val2;
 9100 
 9101             val2 = xmlAttrNormalizeSpace2(ctxt, val, len);
 9102         if ((val2 != NULL) &amp;&amp; (val2 != val)) {
 9103             xmlFree(val);
 9104             val = (xmlChar *) val2;
 9105         }
 9106         }
 9107     }
 9108         ctxt-&gt;instate = XML_PARSER_CONTENT;
 9109     } else {
 9110         xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,
 9111                           &quot;Specification mandates value for attribute %s\n&quot;,
 9112                           name);
 9113         return (NULL);
 9114     }
</pre>
<hr />
<pre>
 9237        ((RAW != &#39;/&#39;) || (NXT(1) != &#39;&gt;&#39;)) &amp;&amp;
 9238        (IS_BYTE_CHAR(RAW))) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF)) {
 9239     const xmlChar *q = CUR_PTR;
 9240     unsigned int cons = ctxt-&gt;input-&gt;consumed;
 9241     int len = -1, alloc = 0;
 9242 
 9243     attname = xmlParseAttribute2(ctxt, prefix, localname,
 9244                                  &amp;aprefix, &amp;attvalue, &amp;len, &amp;alloc);
 9245         if ((attname == NULL) || (attvalue == NULL))
 9246             goto next_attr;
 9247     if (len &lt; 0) len = xmlStrlen(attvalue);
 9248 
 9249         if ((attname == ctxt-&gt;str_xmlns) &amp;&amp; (aprefix == NULL)) {
 9250             const xmlChar *URL = xmlDictLookup(ctxt-&gt;dict, attvalue, len);
 9251             xmlURIPtr uri;
 9252 
 9253             if (URL == NULL) {
 9254                 xmlErrMemory(ctxt, &quot;dictionary allocation failure&quot;);
 9255                 if ((attvalue != NULL) &amp;&amp; (alloc != 0))
 9256                     xmlFree(attvalue);
<span class="line-modified"> 9257                 localname = NULL;</span>
<span class="line-added"> 9258                 goto done;</span>
 9259             }
 9260             if (*URL != 0) {
 9261                 uri = xmlParseURI((const char *) URL);
 9262                 if (uri == NULL) {
 9263                     xmlNsErr(ctxt, XML_WAR_NS_URI,
 9264                              &quot;xmlns: &#39;%s&#39; is not a valid URI\n&quot;,
 9265                                        URL, NULL, NULL);
 9266                 } else {
 9267                     if (uri-&gt;scheme == NULL) {
 9268                         xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
 9269                                   &quot;xmlns: URI %s is not absolute\n&quot;,
 9270                                   URL, NULL, NULL);
 9271                     }
 9272                     xmlFreeURI(uri);
 9273                 }
 9274                 if (URL == ctxt-&gt;str_xml_ns) {
 9275                     if (attname != ctxt-&gt;str_xml) {
 9276                         xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9277                      &quot;xml namespace URI cannot be the default namespace\n&quot;,
 9278                                  NULL, NULL, NULL);
</pre>
<hr />
<pre>
 9488                 if (j &lt;= nbNs) continue;
 9489 
 9490             nsname = xmlGetNamespace(ctxt, attname);
 9491             if (nsname != defaults-&gt;values[2]) {
 9492             if (nsPush(ctxt, attname,
 9493                        defaults-&gt;values[5 * i + 2]) &gt; 0)
 9494                 nbNs++;
 9495             }
 9496         } else {
 9497             /*
 9498              * check that it&#39;s not a defined attribute
 9499              */
 9500             for (j = 0;j &lt; nbatts;j+=5) {
 9501             if ((attname == atts[j]) &amp;&amp; (aprefix == atts[j+1]))
 9502                 break;
 9503             }
 9504             if (j &lt; nbatts) continue;
 9505 
 9506             if ((atts == NULL) || (nbatts + 5 &gt; maxatts)) {
 9507             if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) &lt; 0) {
<span class="line-modified"> 9508                             localname = NULL;</span>
<span class="line-added"> 9509                             goto done;</span>
 9510             }
 9511             maxatts = ctxt-&gt;maxatts;
 9512             atts = ctxt-&gt;atts;
 9513             }
 9514             atts[nbatts++] = attname;
 9515             atts[nbatts++] = aprefix;
 9516             if (aprefix == NULL)
 9517             atts[nbatts++] = NULL;
 9518             else
 9519                 atts[nbatts++] = xmlGetNamespace(ctxt, aprefix);
 9520             atts[nbatts++] = defaults-&gt;values[5 * i + 2];
 9521             atts[nbatts++] = defaults-&gt;values[5 * i + 3];
 9522             if ((ctxt-&gt;standalone == 1) &amp;&amp;
 9523                 (defaults-&gt;values[5 * i + 4] != NULL)) {
 9524             xmlValidityError(ctxt, XML_DTD_STANDALONE_DEFAULTED,
 9525       &quot;standalone: attribute %s on %s defaulted from external subset\n&quot;,
 9526                                      attname, localname);
 9527             }
 9528             nbdef++;
 9529         }
</pre>
<hr />
<pre>
 9799     if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX)) {
 9800     if (ctxt-&gt;sax-&gt;cdataBlock != NULL)
 9801         ctxt-&gt;sax-&gt;cdataBlock(ctxt-&gt;userData, buf, len);
 9802     else if (ctxt-&gt;sax-&gt;characters != NULL)
 9803         ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, buf, len);
 9804     }
 9805     xmlFree(buf);
 9806 }
 9807 
 9808 /**
 9809  * xmlParseContent:
 9810  * @ctxt:  an XML parser context
 9811  *
 9812  * Parse a content:
 9813  *
 9814  * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
 9815  */
 9816 
 9817 void
 9818 xmlParseContent(xmlParserCtxtPtr ctxt) {
<span class="line-added"> 9819     int nameNr = ctxt-&gt;nameNr;</span>
<span class="line-added"> 9820 </span>
 9821     GROW;
 9822     while ((RAW != 0) &amp;&amp;

 9823        (ctxt-&gt;instate != XML_PARSER_EOF)) {
 9824     const xmlChar *test = CUR_PTR;
 9825     unsigned int cons = ctxt-&gt;input-&gt;consumed;
 9826     const xmlChar *cur = ctxt-&gt;input-&gt;cur;
 9827 
 9828     /*
 9829      * First case : a Processing Instruction.
 9830      */
 9831     if ((*cur == &#39;&lt;&#39;) &amp;&amp; (cur[1] == &#39;?&#39;)) {
 9832         xmlParsePI(ctxt);
 9833     }
 9834 
 9835     /*
 9836      * Second case : a CDSection
 9837      */
 9838     /* 2.6.0 test was *cur not RAW */
 9839     else if (CMP9(CUR_PTR, &#39;&lt;&#39;, &#39;!&#39;, &#39;[&#39;, &#39;C&#39;, &#39;D&#39;, &#39;A&#39;, &#39;T&#39;, &#39;A&#39;, &#39;[&#39;)) {
 9840         xmlParseCDSect(ctxt);
 9841     }
 9842 
 9843     /*
 9844      * Third case :  a comment
 9845      */
 9846     else if ((*cur == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp;
 9847          (NXT(2) == &#39;-&#39;) &amp;&amp; (NXT(3) == &#39;-&#39;)) {
 9848         xmlParseComment(ctxt);
 9849         ctxt-&gt;instate = XML_PARSER_CONTENT;
 9850     }
 9851 
 9852     /*
 9853      * Fourth case :  a sub-element.
 9854      */
 9855     else if (*cur == &#39;&lt;&#39;) {
<span class="line-modified"> 9856             if (NXT(1) == &#39;/&#39;) {</span>
<span class="line-added"> 9857                 if (ctxt-&gt;nameNr &lt;= nameNr)</span>
<span class="line-added"> 9858                     break;</span>
<span class="line-added"> 9859             xmlParseElementEnd(ctxt);</span>
<span class="line-added"> 9860             } else {</span>
<span class="line-added"> 9861             xmlParseElementStart(ctxt);</span>
<span class="line-added"> 9862             }</span>
 9863     }
 9864 
 9865     /*
 9866      * Fifth case : a reference. If if has not been resolved,
 9867      *    parsing returns it&#39;s Name, create the node
 9868      */
 9869 
 9870     else if (*cur == &#39;&amp;&#39;) {
 9871         xmlParseReference(ctxt);
 9872     }
 9873 
 9874     /*
 9875      * Last case, text. Note that References are handled directly.
 9876      */
 9877     else {
 9878         xmlParseCharData(ctxt, 0);
 9879     }
 9880 
 9881     GROW;
 9882     SHRINK;
 9883 
 9884     if ((cons == ctxt-&gt;input-&gt;consumed) &amp;&amp; (test == CUR_PTR)) {
 9885         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 9886                     &quot;detected an error in element content\n&quot;);
 9887         xmlHaltParser(ctxt);
 9888             break;
 9889     }
 9890     }
 9891 }
 9892 
 9893 /**
 9894  * xmlParseElement:
 9895  * @ctxt:  an XML parser context
 9896  *
<span class="line-modified"> 9897  * parse an XML element</span>
 9898  *
 9899  * [39] element ::= EmptyElemTag | STag content ETag
 9900  *
 9901  * [ WFC: Element Type Match ]
 9902  * The Name in an element&#39;s end-tag must match the element type in the
 9903  * start-tag.
 9904  *
 9905  */
 9906 
 9907 void
 9908 xmlParseElement(xmlParserCtxtPtr ctxt) {
<span class="line-added"> 9909     if (xmlParseElementStart(ctxt) != 0)</span>
<span class="line-added"> 9910         return;</span>
<span class="line-added"> 9911     xmlParseContent(ctxt);</span>
<span class="line-added"> 9912     if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-added"> 9913     return;</span>
<span class="line-added"> 9914     xmlParseElementEnd(ctxt);</span>
<span class="line-added"> 9915 }</span>
<span class="line-added"> 9916 </span>
<span class="line-added"> 9917 /**</span>
<span class="line-added"> 9918  * xmlParseElementStart:</span>
<span class="line-added"> 9919  * @ctxt:  an XML parser context</span>
<span class="line-added"> 9920  *</span>
<span class="line-added"> 9921  * Parse the start of an XML element. Returns -1 in case of error, 0 if an</span>
<span class="line-added"> 9922  * opening tag was parsed, 1 if an empty element was parsed.</span>
<span class="line-added"> 9923  */</span>
<span class="line-added"> 9924 static int</span>
<span class="line-added"> 9925 xmlParseElementStart(xmlParserCtxtPtr ctxt) {</span>
 9926     const xmlChar *name;
 9927     const xmlChar *prefix = NULL;
 9928     const xmlChar *URI = NULL;
 9929     xmlParserNodeInfo node_info;
 9930     int line, tlen = 0;
 9931     xmlNodePtr ret;
 9932     int nsNr = ctxt-&gt;nsNr;
 9933 
 9934     if (((unsigned int) ctxt-&gt;nameNr &gt; xmlParserMaxDepth) &amp;&amp;
 9935         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 9936     xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
 9937          &quot;Excessive depth in document: %d use XML_PARSE_HUGE option\n&quot;,
 9938               xmlParserMaxDepth);
 9939     xmlHaltParser(ctxt);
<span class="line-modified"> 9940     return(-1);</span>
 9941     }
 9942 
 9943     /* Capture start position */
 9944     if (ctxt-&gt;record_info) {
 9945         node_info.begin_pos = ctxt-&gt;input-&gt;consumed +
 9946                           (CUR_PTR - ctxt-&gt;input-&gt;base);
 9947     node_info.begin_line = ctxt-&gt;input-&gt;line;
 9948     }
 9949 
 9950     if (ctxt-&gt;spaceNr == 0)
 9951     spacePush(ctxt, -1);
 9952     else if (*ctxt-&gt;space == -2)
 9953     spacePush(ctxt, -1);
 9954     else
 9955     spacePush(ctxt, *ctxt-&gt;space);
 9956 
 9957     line = ctxt-&gt;input-&gt;line;
 9958 #ifdef LIBXML_SAX1_ENABLED
 9959     if (ctxt-&gt;sax2)
 9960 #endif /* LIBXML_SAX1_ENABLED */
 9961         name = xmlParseStartTag2(ctxt, &amp;prefix, &amp;URI, &amp;tlen);
 9962 #ifdef LIBXML_SAX1_ENABLED
 9963     else
 9964     name = xmlParseStartTag(ctxt);
 9965 #endif /* LIBXML_SAX1_ENABLED */
 9966     if (ctxt-&gt;instate == XML_PARSER_EOF)
<span class="line-modified"> 9967     return(-1);</span>
 9968     if (name == NULL) {
 9969     spacePop(ctxt);
<span class="line-modified"> 9970         return(-1);</span>
 9971     }
<span class="line-added"> 9972     if (ctxt-&gt;sax2)</span>
<span class="line-added"> 9973         nameNsPush(ctxt, name, prefix, URI, ctxt-&gt;nsNr - nsNr);</span>
<span class="line-added"> 9974 #ifdef LIBXML_SAX1_ENABLED</span>
<span class="line-added"> 9975     else</span>
 9976     namePush(ctxt, name);
<span class="line-added"> 9977 #endif /* LIBXML_SAX1_ENABLED */</span>
 9978     ret = ctxt-&gt;node;
 9979 
 9980 #ifdef LIBXML_VALID_ENABLED
 9981     /*
 9982      * [ VC: Root Element Type ]
 9983      * The Name in the document type declaration must match the element
 9984      * type of the root element.
 9985      */
 9986     if (ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp; ctxt-&gt;myDoc &amp;&amp;
 9987         ctxt-&gt;node &amp;&amp; (ctxt-&gt;node == ctxt-&gt;myDoc-&gt;children))
 9988         ctxt-&gt;valid &amp;= xmlValidateRoot(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc);
 9989 #endif /* LIBXML_VALID_ENABLED */
 9990 
 9991     /*
 9992      * Check for an Empty Element.
 9993      */
 9994     if ((RAW == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;)) {
 9995         SKIP(2);
 9996     if (ctxt-&gt;sax2) {
 9997         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElementNs != NULL) &amp;&amp;
 9998         (!ctxt-&gt;disableSAX))
 9999         ctxt-&gt;sax-&gt;endElementNs(ctxt-&gt;userData, name, prefix, URI);
10000 #ifdef LIBXML_SAX1_ENABLED
10001     } else {
10002         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElement != NULL) &amp;&amp;
10003         (!ctxt-&gt;disableSAX))
10004         ctxt-&gt;sax-&gt;endElement(ctxt-&gt;userData, name);
10005 #endif /* LIBXML_SAX1_ENABLED */
10006     }
10007     namePop(ctxt);
10008     spacePop(ctxt);
10009     if (nsNr != ctxt-&gt;nsNr)
10010         nsPop(ctxt, ctxt-&gt;nsNr - nsNr);
10011     if ( ret != NULL &amp;&amp; ctxt-&gt;record_info ) {
10012        node_info.end_pos = ctxt-&gt;input-&gt;consumed +
10013                   (CUR_PTR - ctxt-&gt;input-&gt;base);
10014        node_info.end_line = ctxt-&gt;input-&gt;line;
10015        node_info.node = ret;
10016        xmlParserAddNodeInfo(ctxt, &amp;node_info);
10017     }
<span class="line-modified">10018     return(1);</span>
10019     }
10020     if (RAW == &#39;&gt;&#39;) {
10021         NEXT1;
10022     } else {
10023         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_GT_REQUIRED,
10024              &quot;Couldn&#39;t find end of Start Tag %s line %d\n&quot;,
10025                         name, line, NULL);
10026 
10027     /*
10028      * end of parsing of this node.
10029      */
10030     nodePop(ctxt);
10031     namePop(ctxt);
10032     spacePop(ctxt);
10033     if (nsNr != ctxt-&gt;nsNr)
10034         nsPop(ctxt, ctxt-&gt;nsNr - nsNr);
10035 
10036     /*
10037      * Capture end position and add node
10038      */
10039     if ( ret != NULL &amp;&amp; ctxt-&gt;record_info ) {
10040        node_info.end_pos = ctxt-&gt;input-&gt;consumed +
10041                   (CUR_PTR - ctxt-&gt;input-&gt;base);
10042        node_info.end_line = ctxt-&gt;input-&gt;line;
10043        node_info.node = ret;
10044        xmlParserAddNodeInfo(ctxt, &amp;node_info);
10045     }
<span class="line-modified">10046     return(-1);</span>
10047     }
10048 
<span class="line-modified">10049     return(0);</span>
<span class="line-modified">10050 }</span>








10051 
<span class="line-modified">10052 /**</span>
<span class="line-modified">10053  * xmlParseElementEnd:</span>
<span class="line-added">10054  * @ctxt:  an XML parser context</span>
<span class="line-added">10055  *</span>
<span class="line-added">10056  * Parse the end of an XML element.</span>
10057      */
<span class="line-modified">10058 static void</span>
<span class="line-modified">10059 xmlParseElementEnd(xmlParserCtxtPtr ctxt) {</span>
<span class="line-modified">10060     xmlParserNodeInfo node_info;</span>
<span class="line-modified">10061     xmlNodePtr ret = ctxt-&gt;node;</span>
<span class="line-modified">10062 </span>
<span class="line-added">10063     if (ctxt-&gt;nameNr &lt;= 0)</span>
10064     return;

10065 
10066     /*
10067      * parse the end of tag: &#39;&lt;/&#39; should be here.
10068      */
10069     if (ctxt-&gt;sax2) {
<span class="line-modified">10070         const xmlChar *prefix = ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 - 3];</span>
<span class="line-added">10071         const xmlChar *URI = ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 - 2];</span>
<span class="line-added">10072         int nsNr = (ptrdiff_t) ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 - 1];</span>
<span class="line-added">10073     xmlParseEndTag2(ctxt, prefix, URI, 0, nsNr, 0);</span>
10074     namePop(ctxt);
10075     }
10076 #ifdef LIBXML_SAX1_ENABLED
10077       else
<span class="line-modified">10078     xmlParseEndTag1(ctxt, 0);</span>
10079 #endif /* LIBXML_SAX1_ENABLED */
10080 
10081     /*
10082      * Capture end position and add node
10083      */
10084     if ( ret != NULL &amp;&amp; ctxt-&gt;record_info ) {
10085        node_info.end_pos = ctxt-&gt;input-&gt;consumed +
10086                           (CUR_PTR - ctxt-&gt;input-&gt;base);
10087        node_info.end_line = ctxt-&gt;input-&gt;line;
10088        node_info.node = ret;
10089        xmlParserAddNodeInfo(ctxt, &amp;node_info);
10090     }
10091 }
10092 
10093 /**
10094  * xmlParseVersionNum:
10095  * @ctxt:  an XML parser context
10096  *
10097  * parse the XML version value.
10098  *
</pre>
<hr />
<pre>
10300         encoding = xmlParseEncName(ctxt);
10301         if (RAW != &#39;\&#39;&#39;) {
10302         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10303         xmlFree((xmlChar *) encoding);
10304         return(NULL);
10305         } else
10306             NEXT;
10307     } else {
10308         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10309     }
10310 
10311         /*
10312          * Non standard parsing, allowing the user to ignore encoding
10313          */
10314         if (ctxt-&gt;options &amp; XML_PARSE_IGNORE_ENC) {
10315         xmlFree((xmlChar *) encoding);
10316             return(NULL);
10317     }
10318 
10319     /*
<span class="line-modified">10320      * UTF-16 encoding switch has already taken place at this stage,</span>
10321      * more over the little-endian/big-endian selection is already done
10322      */
10323         if ((encoding != NULL) &amp;&amp;
10324         ((!xmlStrcasecmp(encoding, BAD_CAST &quot;UTF-16&quot;)) ||
10325          (!xmlStrcasecmp(encoding, BAD_CAST &quot;UTF16&quot;)))) {
10326         /*
10327          * If no encoding was passed to the parser, that we are
10328          * using UTF-16 and no decoder is present i.e. the
10329          * document is apparently UTF-8 compatible, then raise an
10330          * encoding mismatch fatal error
10331          */
10332         if ((ctxt-&gt;encoding == NULL) &amp;&amp;
10333             (ctxt-&gt;input-&gt;buf != NULL) &amp;&amp;
10334             (ctxt-&gt;input-&gt;buf-&gt;encoder == NULL)) {
10335         xmlFatalErrMsg(ctxt, XML_ERR_INVALID_ENCODING,
10336           &quot;Document labelled UTF-16 but has UTF-8 content\n&quot;);
10337         }
10338         if (ctxt-&gt;encoding != NULL)
10339         xmlFree((xmlChar *) ctxt-&gt;encoding);
10340         ctxt-&gt;encoding = encoding;
</pre>
<hr />
<pre>
11183 #endif
11184 
11185     if ((ctxt-&gt;input != NULL) &amp;&amp;
11186         (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base &gt; 4096)) {
11187     xmlSHRINK(ctxt);
11188     ctxt-&gt;checkIndex = 0;
11189     }
11190     xmlParseGetLasts(ctxt, &amp;lastlt, &amp;lastgt);
11191 
11192     while (ctxt-&gt;instate != XML_PARSER_EOF) {
11193     if ((ctxt-&gt;errNo != XML_ERR_OK) &amp;&amp; (ctxt-&gt;disableSAX == 1))
11194         return(0);
11195 
11196     if (ctxt-&gt;input == NULL) break;
11197     if (ctxt-&gt;input-&gt;buf == NULL)
11198         avail = ctxt-&gt;input-&gt;length -
11199                 (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11200     else {
11201         /*
11202          * If we are operating on converted input, try to flush
<span class="line-modified">11203          * remaining chars to avoid them stalling in the non-converted</span>
11204          * buffer. But do not do this in document start where
11205          * encoding=&quot;...&quot; may not have been read and we work on a
11206          * guessed encoding.
11207          */
11208         if ((ctxt-&gt;instate != XML_PARSER_START) &amp;&amp;
11209             (ctxt-&gt;input-&gt;buf-&gt;raw != NULL) &amp;&amp;
11210         (xmlBufIsEmpty(ctxt-&gt;input-&gt;buf-&gt;raw) == 0)) {
11211                 size_t base = xmlBufGetInputBase(ctxt-&gt;input-&gt;buf-&gt;buffer,
11212                                                  ctxt-&gt;input);
11213         size_t current = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
11214 
11215         xmlParserInputBufferPush(ctxt-&gt;input-&gt;buf, 0, &quot;&quot;);
11216                 xmlBufSetInputBaseCur(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input,
11217                                       base, current);
11218         }
11219         avail = xmlBufUse(ctxt-&gt;input-&gt;buf-&gt;buffer) -
11220             (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11221     }
11222         if (avail &lt; 1)
11223         goto done;
</pre>
<hr />
<pre>
12375     xmlParserInputPtr inputStream;
12376     xmlParserInputBufferPtr buf;
12377     xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;
12378 
12379     /*
12380      * plug some encoding conversion routines
12381      */
12382     if ((chunk != NULL) &amp;&amp; (size &gt;= 4))
12383     enc = xmlDetectCharEncoding((const xmlChar *) chunk, size);
12384 
12385     buf = xmlAllocParserInputBuffer(enc);
12386     if (buf == NULL) return(NULL);
12387 
12388     ctxt = xmlNewParserCtxt();
12389     if (ctxt == NULL) {
12390         xmlErrMemory(NULL, &quot;creating parser: out of memory\n&quot;);
12391     xmlFreeParserInputBuffer(buf);
12392     return(NULL);
12393     }
12394     ctxt-&gt;dictNames = 1;







12395     if (sax != NULL) {
12396 #ifdef LIBXML_SAX1_ENABLED
12397     if (ctxt-&gt;sax != (xmlSAXHandlerPtr) &amp;xmlDefaultSAXHandler)
12398 #endif /* LIBXML_SAX1_ENABLED */
12399         xmlFree(ctxt-&gt;sax);
12400     ctxt-&gt;sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(xmlSAXHandler));
12401     if (ctxt-&gt;sax == NULL) {
12402         xmlErrMemory(ctxt, NULL);
12403         xmlFreeParserInputBuffer(buf);
12404         xmlFreeParserCtxt(ctxt);
12405         return(NULL);
12406     }
12407     memset(ctxt-&gt;sax, 0, sizeof(xmlSAXHandler));
12408     if (sax-&gt;initialized == XML_SAX2_MAGIC)
12409         memcpy(ctxt-&gt;sax, sax, sizeof(xmlSAXHandler));
12410     else
12411         memcpy(ctxt-&gt;sax, sax, sizeof(xmlSAXHandlerV1));
12412     if (user_data != NULL)
12413         ctxt-&gt;userData = user_data;
12414     }
</pre>
<hr />
<pre>
13910 
13911     /*
13912      * Return the newly created nodeset after unlinking it from
13913      * they pseudo parent.
13914      */
13915     cur = newDoc-&gt;children-&gt;children;
13916     *lst = cur;
13917     while (cur != NULL) {
13918         xmlSetTreeDoc(cur, doc);
13919         cur-&gt;parent = NULL;
13920         cur = cur-&gt;next;
13921     }
13922     newDoc-&gt;children-&gt;children = NULL;
13923     }
13924 
13925     if (sax != NULL)
13926     ctxt-&gt;sax = oldsax;
13927     xmlFreeParserCtxt(ctxt);
13928     newDoc-&gt;intSubset = NULL;
13929     newDoc-&gt;extSubset = NULL;
<span class="line-added">13930     if(doc != NULL)</span>
13931     newDoc-&gt;oldNs = NULL;
13932     xmlFreeDoc(newDoc);
13933 
13934     return(ret);
13935 }
13936 
13937 /**
13938  * xmlSAXParseEntity:
13939  * @sax:  the SAX handler block
13940  * @filename:  the filename
13941  *
13942  * parse an XML external entity out of context and build a tree.
13943  * It use the given SAX function block to handle the parsing callback.
13944  * If sax is NULL, fallback to the default DOM tree building routines.
13945  *
13946  * [78] extParsedEnt ::= TextDecl? content
13947  *
13948  * This correspond to a &quot;Well Balanced&quot; chunk
13949  *
13950  * Returns the resulting document tree
</pre>
<hr />
<pre>
14020     xmlParserCtxtPtr ctxt;
14021     xmlParserInputPtr inputStream;
14022     char *directory = NULL;
14023     xmlChar *uri;
14024 
14025     ctxt = xmlNewParserCtxt();
14026     if (ctxt == NULL) {
14027     return(NULL);
14028     }
14029 
14030     if (pctx != NULL) {
14031         ctxt-&gt;options = pctx-&gt;options;
14032         ctxt-&gt;_private = pctx-&gt;_private;
14033     /*
14034      * this is a subparser of pctx, so the input_id should be
14035      * incremented to distinguish from main entity
14036      */
14037     ctxt-&gt;input_id = pctx-&gt;input_id + 1;
14038     }
14039 
<span class="line-added">14040     /* Don&#39;t read from stdin. */</span>
<span class="line-added">14041     if (xmlStrcmp(URL, BAD_CAST &quot;-&quot;) == 0)</span>
<span class="line-added">14042         URL = BAD_CAST &quot;./-&quot;;</span>
<span class="line-added">14043 </span>
14044     uri = xmlBuildURI(URL, base);
14045 
14046     if (uri == NULL) {
14047     inputStream = xmlLoadExternalEntity((char *)URL, (char *)ID, ctxt);
14048     if (inputStream == NULL) {
14049         xmlFreeParserCtxt(ctxt);
14050         return(NULL);
14051     }
14052 
14053     inputPush(ctxt, inputStream);
14054 
14055     if ((ctxt-&gt;directory == NULL) &amp;&amp; (directory == NULL))
14056         directory = xmlParserGetDirectory((char *)URL);
14057     if ((ctxt-&gt;directory == NULL) &amp;&amp; (directory != NULL))
14058         ctxt-&gt;directory = directory;
14059     } else {
14060     inputStream = xmlLoadExternalEntity((char *)uri, (char *)ID, ctxt);
14061     if (inputStream == NULL) {
14062         xmlFree(uri);
14063         xmlFreeParserCtxt(ctxt);
</pre>
<hr />
<pre>
14956     xmlParserInputBufferPtr buf;
14957     xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;
14958 
14959     if (ctxt == NULL)
14960         return(1);
14961 
14962     if ((encoding == NULL) &amp;&amp; (chunk != NULL) &amp;&amp; (size &gt;= 4))
14963         enc = xmlDetectCharEncoding((const xmlChar *) chunk, size);
14964 
14965     buf = xmlAllocParserInputBuffer(enc);
14966     if (buf == NULL)
14967         return(1);
14968 
14969     if (ctxt == NULL) {
14970         xmlFreeParserInputBuffer(buf);
14971         return(1);
14972     }
14973 
14974     xmlCtxtReset(ctxt);
14975 










14976     if (filename == NULL) {
14977         ctxt-&gt;directory = NULL;
14978     } else {
14979         ctxt-&gt;directory = xmlParserGetDirectory(filename);
14980     }
14981 
14982     inputStream = xmlNewInputStream(ctxt);
14983     if (inputStream == NULL) {
14984         xmlFreeParserInputBuffer(buf);
14985         return(1);
14986     }
14987 
14988     if (filename == NULL)
14989         inputStream-&gt;filename = NULL;
14990     else
14991         inputStream-&gt;filename = (char *)
14992             xmlCanonicPath((const xmlChar *) filename);
14993     inputStream-&gt;buf = buf;
14994     xmlBufResetInput(buf-&gt;buffer, inputStream);
14995 
</pre>
</td>
</tr>
</table>
<center><a href="nanohttp.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="parserInternals.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/SAX2.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * SAX2.c : Default SAX2 handler to build a tree.
   3  *
   4  * See Copyright for the status of this software.
   5  *
   6  * Daniel Veillard &lt;daniel@veillard.com&gt;
   7  */
   8 
   9 
  10 #define IN_LIBXML
  11 #include &quot;libxml.h&quot;
  12 #include &lt;stdlib.h&gt;
  13 #include &lt;string.h&gt;
  14 #include &lt;limits.h&gt;
  15 #include &lt;stddef.h&gt;
  16 #include &lt;libxml/xmlmemory.h&gt;
  17 #include &lt;libxml/tree.h&gt;
  18 #include &lt;libxml/parser.h&gt;
  19 #include &lt;libxml/parserInternals.h&gt;
  20 #include &lt;libxml/valid.h&gt;
  21 #include &lt;libxml/entities.h&gt;
  22 #include &lt;libxml/xmlerror.h&gt;
  23 #include &lt;libxml/debugXML.h&gt;
  24 #include &lt;libxml/xmlIO.h&gt;
  25 #include &lt;libxml/SAX.h&gt;
  26 #include &lt;libxml/uri.h&gt;
  27 #include &lt;libxml/valid.h&gt;
  28 #include &lt;libxml/HTMLtree.h&gt;
  29 #include &lt;libxml/globals.h&gt;
  30 
  31 /* Define SIZE_T_MAX unless defined through &lt;limits.h&gt;. */
  32 #ifndef SIZE_T_MAX
  33 # define SIZE_T_MAX     ((size_t)-1)
  34 #endif /* !SIZE_T_MAX */
  35 
  36 /* #define DEBUG_SAX2 */
  37 /* #define DEBUG_SAX2_TREE */
  38 
  39 /**
  40  * TODO:
  41  *
  42  * macro to flag unimplemented blocks
<a name="1" id="anc1"></a><span class="line-modified">  43  * XML_CATALOG_PREFER user env to select between system/public prefered</span>
  44  * option. C.f. Richard Tobin &lt;richard@cogsci.ed.ac.uk&gt;
  45  *&gt; Just FYI, I am using an environment variable XML_CATALOG_PREFER with
  46  *&gt; values &quot;system&quot; and &quot;public&quot;.  I have made the default be &quot;system&quot; to
  47  *&gt; match yours.
  48  */
  49 #define TODO                                \
  50     xmlGenericError(xmlGenericErrorContext,             \
  51         &quot;Unimplemented block at %s:%d\n&quot;,               \
  52             __FILE__, __LINE__);
  53 
  54 /*
  55  * xmlSAX2ErrMemory:
  56  * @ctxt:  an XML validation parser context
  57  * @msg:   a string to accompany the error message
  58  */
  59 static void LIBXML_ATTR_FORMAT(2,0)
  60 xmlSAX2ErrMemory(xmlParserCtxtPtr ctxt, const char *msg) {
  61     xmlStructuredErrorFunc schannel = NULL;
  62     const char *str1 = &quot;out of memory\n&quot;;
  63 
  64     if (ctxt != NULL) {
  65     ctxt-&gt;errNo = XML_ERR_NO_MEMORY;
  66     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;initialized == XML_SAX2_MAGIC))
  67         schannel = ctxt-&gt;sax-&gt;serror;
  68     __xmlRaiseError(schannel,
  69             ctxt-&gt;vctxt.error, ctxt-&gt;vctxt.userData,
  70             ctxt, NULL, XML_FROM_PARSER, XML_ERR_NO_MEMORY,
  71             XML_ERR_ERROR, NULL, 0, (const char *) str1,
  72             NULL, NULL, 0, 0,
  73             msg, (const char *) str1, NULL);
  74     ctxt-&gt;errNo = XML_ERR_NO_MEMORY;
  75     ctxt-&gt;instate = XML_PARSER_EOF;
  76     ctxt-&gt;disableSAX = 1;
  77     } else {
  78     __xmlRaiseError(schannel,
  79             NULL, NULL,
  80             ctxt, NULL, XML_FROM_PARSER, XML_ERR_NO_MEMORY,
  81             XML_ERR_ERROR, NULL, 0, (const char *) str1,
  82             NULL, NULL, 0, 0,
  83             msg, (const char *) str1, NULL);
  84     }
  85 }
  86 
  87 /**
  88  * xmlValidError:
  89  * @ctxt:  an XML validation parser context
  90  * @error:  the error number
  91  * @msg:  the error message
  92  * @str1:  extra data
  93  * @str2:  extra data
  94  *
  95  * Handle a validation error
  96  */
  97 static void LIBXML_ATTR_FORMAT(3,0)
  98 xmlErrValid(xmlParserCtxtPtr ctxt, xmlParserErrors error,
  99             const char *msg, const char *str1, const char *str2)
 100 {
 101     xmlStructuredErrorFunc schannel = NULL;
 102 
 103     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
 104         (ctxt-&gt;instate == XML_PARSER_EOF))
 105     return;
 106     if (ctxt != NULL) {
 107     ctxt-&gt;errNo = error;
 108     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;initialized == XML_SAX2_MAGIC))
 109         schannel = ctxt-&gt;sax-&gt;serror;
 110     __xmlRaiseError(schannel,
 111             ctxt-&gt;vctxt.error, ctxt-&gt;vctxt.userData,
 112             ctxt, NULL, XML_FROM_DTD, error,
 113             XML_ERR_ERROR, NULL, 0, (const char *) str1,
 114             (const char *) str2, NULL, 0, 0,
 115             msg, (const char *) str1, (const char *) str2);
 116     ctxt-&gt;valid = 0;
 117     } else {
 118     __xmlRaiseError(schannel,
 119             NULL, NULL,
 120             ctxt, NULL, XML_FROM_DTD, error,
 121             XML_ERR_ERROR, NULL, 0, (const char *) str1,
 122             (const char *) str2, NULL, 0, 0,
 123             msg, (const char *) str1, (const char *) str2);
 124     }
 125 }
 126 
 127 /**
 128  * xmlFatalErrMsg:
 129  * @ctxt:  an XML parser context
 130  * @error:  the error number
 131  * @msg:  the error message
 132  * @str1:  an error string
 133  * @str2:  an error string
 134  *
 135  * Handle a fatal parser error, i.e. violating Well-Formedness constraints
 136  */
 137 static void LIBXML_ATTR_FORMAT(3,0)
 138 xmlFatalErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 139                const char *msg, const xmlChar *str1, const xmlChar *str2)
 140 {
 141     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
 142         (ctxt-&gt;instate == XML_PARSER_EOF))
 143     return;
 144     if (ctxt != NULL)
 145     ctxt-&gt;errNo = error;
 146     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
 147                     XML_ERR_FATAL, NULL, 0,
 148             (const char *) str1, (const char *) str2,
 149             NULL, 0, 0, msg, str1, str2);
 150     if (ctxt != NULL) {
 151     ctxt-&gt;wellFormed = 0;
 152     ctxt-&gt;valid = 0;
 153     if (ctxt-&gt;recovery == 0)
 154         ctxt-&gt;disableSAX = 1;
 155     }
 156 }
 157 
 158 /**
 159  * xmlWarnMsg:
 160  * @ctxt:  an XML parser context
 161  * @error:  the error number
 162  * @msg:  the error message
 163  * @str1:  an error string
 164  * @str2:  an error string
 165  *
 166  * Handle a parser warning
 167  */
 168 static void LIBXML_ATTR_FORMAT(3,0)
 169 xmlWarnMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 170                const char *msg, const xmlChar *str1)
 171 {
 172     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
 173         (ctxt-&gt;instate == XML_PARSER_EOF))
 174     return;
 175     if (ctxt != NULL)
 176     ctxt-&gt;errNo = error;
 177     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
 178                     XML_ERR_WARNING, NULL, 0,
 179             (const char *) str1, NULL,
 180             NULL, 0, 0, msg, str1);
 181 }
 182 
 183 /**
 184  * xmlNsErrMsg:
 185  * @ctxt:  an XML parser context
 186  * @error:  the error number
 187  * @msg:  the error message
 188  * @str1:  an error string
 189  * @str2:  an error string
 190  *
 191  * Handle a namespace error
 192  */
 193 static void LIBXML_ATTR_FORMAT(3,0)
 194 xmlNsErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 195             const char *msg, const xmlChar *str1, const xmlChar *str2)
 196 {
 197     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
 198         (ctxt-&gt;instate == XML_PARSER_EOF))
 199     return;
 200     if (ctxt != NULL)
 201     ctxt-&gt;errNo = error;
 202     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
 203                     XML_ERR_ERROR, NULL, 0,
 204             (const char *) str1, (const char *) str2,
 205             NULL, 0, 0, msg, str1, str2);
 206 }
 207 
 208 /**
 209  * xmlNsWarnMsg:
 210  * @ctxt:  an XML parser context
 211  * @error:  the error number
 212  * @msg:  the error message
 213  * @str1:  an error string
 214  *
 215  * Handle a namespace warning
 216  */
 217 static void LIBXML_ATTR_FORMAT(3,0)
 218 xmlNsWarnMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 219              const char *msg, const xmlChar *str1, const xmlChar *str2)
 220 {
 221     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
 222         (ctxt-&gt;instate == XML_PARSER_EOF))
 223     return;
 224     if (ctxt != NULL)
 225     ctxt-&gt;errNo = error;
 226     __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
 227                     XML_ERR_WARNING, NULL, 0,
 228             (const char *) str1, (const char *) str2,
 229             NULL, 0, 0, msg, str1, str2);
 230 }
 231 
 232 /**
 233  * xmlSAX2GetPublicId:
 234  * @ctx: the user data (XML parser context)
 235  *
 236  * Provides the public ID e.g. &quot;-//SGMLSOURCE//DTD DEMO//EN&quot;
 237  *
 238  * Returns a xmlChar *
 239  */
 240 const xmlChar *
 241 xmlSAX2GetPublicId(void *ctx ATTRIBUTE_UNUSED)
 242 {
 243     /* xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx; */
 244     return(NULL);
 245 }
 246 
 247 /**
 248  * xmlSAX2GetSystemId:
 249  * @ctx: the user data (XML parser context)
 250  *
 251  * Provides the system ID, basically URL or filename e.g.
 252  * http://www.sgmlsource.com/dtds/memo.dtd
 253  *
 254  * Returns a xmlChar *
 255  */
 256 const xmlChar *
 257 xmlSAX2GetSystemId(void *ctx)
 258 {
 259     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 260     if ((ctx == NULL) || (ctxt-&gt;input == NULL)) return(NULL);
 261     return((const xmlChar *) ctxt-&gt;input-&gt;filename);
 262 }
 263 
 264 /**
 265  * xmlSAX2GetLineNumber:
 266  * @ctx: the user data (XML parser context)
 267  *
 268  * Provide the line number of the current parsing point.
 269  *
 270  * Returns an int
 271  */
 272 int
 273 xmlSAX2GetLineNumber(void *ctx)
 274 {
 275     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 276     if ((ctx == NULL) || (ctxt-&gt;input == NULL)) return(0);
 277     return(ctxt-&gt;input-&gt;line);
 278 }
 279 
 280 /**
 281  * xmlSAX2GetColumnNumber:
 282  * @ctx: the user data (XML parser context)
 283  *
 284  * Provide the column number of the current parsing point.
 285  *
 286  * Returns an int
 287  */
 288 int
 289 xmlSAX2GetColumnNumber(void *ctx)
 290 {
 291     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 292     if ((ctx == NULL) || (ctxt-&gt;input == NULL)) return(0);
 293     return(ctxt-&gt;input-&gt;col);
 294 }
 295 
 296 /**
 297  * xmlSAX2IsStandalone:
 298  * @ctx: the user data (XML parser context)
 299  *
 300  * Is this document tagged standalone ?
 301  *
 302  * Returns 1 if true
 303  */
 304 int
 305 xmlSAX2IsStandalone(void *ctx)
 306 {
 307     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 308     if ((ctx == NULL) || (ctxt-&gt;myDoc == NULL)) return(0);
 309     return(ctxt-&gt;myDoc-&gt;standalone == 1);
 310 }
 311 
 312 /**
 313  * xmlSAX2HasInternalSubset:
 314  * @ctx: the user data (XML parser context)
 315  *
 316  * Does this document has an internal subset
 317  *
 318  * Returns 1 if true
 319  */
 320 int
 321 xmlSAX2HasInternalSubset(void *ctx)
 322 {
 323     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 324     if ((ctxt == NULL) || (ctxt-&gt;myDoc == NULL)) return(0);
 325     return(ctxt-&gt;myDoc-&gt;intSubset != NULL);
 326 }
 327 
 328 /**
 329  * xmlSAX2HasExternalSubset:
 330  * @ctx: the user data (XML parser context)
 331  *
 332  * Does this document has an external subset
 333  *
 334  * Returns 1 if true
 335  */
 336 int
 337 xmlSAX2HasExternalSubset(void *ctx)
 338 {
 339     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 340     if ((ctxt == NULL) || (ctxt-&gt;myDoc == NULL)) return(0);
 341     return(ctxt-&gt;myDoc-&gt;extSubset != NULL);
 342 }
 343 
 344 /**
 345  * xmlSAX2InternalSubset:
 346  * @ctx:  the user data (XML parser context)
 347  * @name:  the root element name
 348  * @ExternalID:  the external ID
 349  * @SystemID:  the SYSTEM ID (e.g. filename or URL)
 350  *
 351  * Callback on internal subset declaration.
 352  */
 353 void
 354 xmlSAX2InternalSubset(void *ctx, const xmlChar *name,
 355            const xmlChar *ExternalID, const xmlChar *SystemID)
 356 {
 357     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 358     xmlDtdPtr dtd;
 359     if (ctx == NULL) return;
 360 #ifdef DEBUG_SAX
 361     xmlGenericError(xmlGenericErrorContext,
 362         &quot;SAX.xmlSAX2InternalSubset(%s, %s, %s)\n&quot;,
 363             name, ExternalID, SystemID);
 364 #endif
 365 
 366     if (ctxt-&gt;myDoc == NULL)
 367     return;
 368     dtd = xmlGetIntSubset(ctxt-&gt;myDoc);
 369     if (dtd != NULL) {
 370     if (ctxt-&gt;html)
 371         return;
 372     xmlUnlinkNode((xmlNodePtr) dtd);
 373     xmlFreeDtd(dtd);
 374     ctxt-&gt;myDoc-&gt;intSubset = NULL;
 375     }
 376     ctxt-&gt;myDoc-&gt;intSubset =
 377     xmlCreateIntSubset(ctxt-&gt;myDoc, name, ExternalID, SystemID);
 378     if (ctxt-&gt;myDoc-&gt;intSubset == NULL)
 379         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2InternalSubset&quot;);
 380 }
 381 
 382 /**
 383  * xmlSAX2ExternalSubset:
 384  * @ctx: the user data (XML parser context)
 385  * @name:  the root element name
 386  * @ExternalID:  the external ID
 387  * @SystemID:  the SYSTEM ID (e.g. filename or URL)
 388  *
 389  * Callback on external subset declaration.
 390  */
 391 void
 392 xmlSAX2ExternalSubset(void *ctx, const xmlChar *name,
 393            const xmlChar *ExternalID, const xmlChar *SystemID)
 394 {
 395     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 396     if (ctx == NULL) return;
 397 #ifdef DEBUG_SAX
 398     xmlGenericError(xmlGenericErrorContext,
 399         &quot;SAX.xmlSAX2ExternalSubset(%s, %s, %s)\n&quot;,
 400             name, ExternalID, SystemID);
 401 #endif
 402     if (((ExternalID != NULL) || (SystemID != NULL)) &amp;&amp;
 403         (((ctxt-&gt;validate) || (ctxt-&gt;loadsubset != 0)) &amp;&amp;
 404      (ctxt-&gt;wellFormed &amp;&amp; ctxt-&gt;myDoc))) {
 405     /*
 406      * Try to fetch and parse the external subset.
 407      */
 408     xmlParserInputPtr oldinput;
 409     int oldinputNr;
 410     int oldinputMax;
 411     xmlParserInputPtr *oldinputTab;
 412     xmlParserInputPtr input = NULL;
 413     xmlCharEncoding enc;
 414     int oldcharset;
 415     const xmlChar *oldencoding;
 416 
 417     /*
 418      * Ask the Entity resolver to load the damn thing
 419      */
 420     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;resolveEntity != NULL))
 421         input = ctxt-&gt;sax-&gt;resolveEntity(ctxt-&gt;userData, ExternalID,
 422                                             SystemID);
 423     if (input == NULL) {
 424         return;
 425     }
 426 
 427     xmlNewDtd(ctxt-&gt;myDoc, name, ExternalID, SystemID);
 428 
 429     /*
 430      * make sure we won&#39;t destroy the main document context
 431      */
 432     oldinput = ctxt-&gt;input;
 433     oldinputNr = ctxt-&gt;inputNr;
 434     oldinputMax = ctxt-&gt;inputMax;
 435     oldinputTab = ctxt-&gt;inputTab;
 436     oldcharset = ctxt-&gt;charset;
 437     oldencoding = ctxt-&gt;encoding;
 438     ctxt-&gt;encoding = NULL;
 439 
 440     ctxt-&gt;inputTab = (xmlParserInputPtr *)
 441                      xmlMalloc(5 * sizeof(xmlParserInputPtr));
 442     if (ctxt-&gt;inputTab == NULL) {
 443         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2ExternalSubset&quot;);
 444         ctxt-&gt;input = oldinput;
 445         ctxt-&gt;inputNr = oldinputNr;
 446         ctxt-&gt;inputMax = oldinputMax;
 447         ctxt-&gt;inputTab = oldinputTab;
 448         ctxt-&gt;charset = oldcharset;
 449         ctxt-&gt;encoding = oldencoding;
 450         return;
 451     }
 452     ctxt-&gt;inputNr = 0;
 453     ctxt-&gt;inputMax = 5;
 454     ctxt-&gt;input = NULL;
 455     xmlPushInput(ctxt, input);
 456 
 457     /*
 458      * On the fly encoding conversion if needed
 459      */
 460     if (ctxt-&gt;input-&gt;length &gt;= 4) {
 461         enc = xmlDetectCharEncoding(ctxt-&gt;input-&gt;cur, 4);
 462         xmlSwitchEncoding(ctxt, enc);
 463     }
 464 
 465     if (input-&gt;filename == NULL)
 466         input-&gt;filename = (char *) xmlCanonicPath(SystemID);
 467     input-&gt;line = 1;
 468     input-&gt;col = 1;
 469     input-&gt;base = ctxt-&gt;input-&gt;cur;
 470     input-&gt;cur = ctxt-&gt;input-&gt;cur;
 471     input-&gt;free = NULL;
 472 
 473     /*
 474      * let&#39;s parse that entity knowing it&#39;s an external subset.
 475      */
 476     xmlParseExternalSubset(ctxt, ExternalID, SystemID);
 477 
 478         /*
 479      * Free up the external entities
 480      */
 481 
 482     while (ctxt-&gt;inputNr &gt; 1)
 483         xmlPopInput(ctxt);
 484     xmlFreeInputStream(ctxt-&gt;input);
 485         xmlFree(ctxt-&gt;inputTab);
 486 
 487     /*
 488      * Restore the parsing context of the main entity
 489      */
 490     ctxt-&gt;input = oldinput;
 491     ctxt-&gt;inputNr = oldinputNr;
 492     ctxt-&gt;inputMax = oldinputMax;
 493     ctxt-&gt;inputTab = oldinputTab;
 494     ctxt-&gt;charset = oldcharset;
 495     if ((ctxt-&gt;encoding != NULL) &amp;&amp;
 496         ((ctxt-&gt;dict == NULL) ||
 497          (!xmlDictOwns(ctxt-&gt;dict, ctxt-&gt;encoding))))
 498         xmlFree((xmlChar *) ctxt-&gt;encoding);
 499     ctxt-&gt;encoding = oldencoding;
 500     /* ctxt-&gt;wellFormed = oldwellFormed; */
 501     }
 502 }
 503 
 504 /**
 505  * xmlSAX2ResolveEntity:
 506  * @ctx: the user data (XML parser context)
 507  * @publicId: The public ID of the entity
 508  * @systemId: The system ID of the entity
 509  *
 510  * The entity loader, to control the loading of external entities,
 511  * the application can either:
 512  *    - override this xmlSAX2ResolveEntity() callback in the SAX block
 513  *    - or better use the xmlSetExternalEntityLoader() function to
 514  *      set up it&#39;s own entity resolution routine
 515  *
 516  * Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.
 517  */
 518 xmlParserInputPtr
 519 xmlSAX2ResolveEntity(void *ctx, const xmlChar *publicId, const xmlChar *systemId)
 520 {
 521     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 522     xmlParserInputPtr ret;
 523     xmlChar *URI;
 524     const char *base = NULL;
 525 
 526     if (ctx == NULL) return(NULL);
 527     if (ctxt-&gt;input != NULL)
 528     base = ctxt-&gt;input-&gt;filename;
 529     if (base == NULL)
 530     base = ctxt-&gt;directory;
 531 
 532     URI = xmlBuildURI(systemId, (const xmlChar *) base);
 533 
 534 #ifdef DEBUG_SAX
 535     xmlGenericError(xmlGenericErrorContext,
 536         &quot;SAX.xmlSAX2ResolveEntity(%s, %s)\n&quot;, publicId, systemId);
 537 #endif
 538 
 539     ret = xmlLoadExternalEntity((const char *) URI,
 540                 (const char *) publicId, ctxt);
 541     if (URI != NULL)
 542     xmlFree(URI);
 543     return(ret);
 544 }
 545 
 546 /**
 547  * xmlSAX2GetEntity:
 548  * @ctx: the user data (XML parser context)
 549  * @name: The entity name
 550  *
 551  * Get an entity by name
 552  *
 553  * Returns the xmlEntityPtr if found.
 554  */
 555 xmlEntityPtr
 556 xmlSAX2GetEntity(void *ctx, const xmlChar *name)
 557 {
 558     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 559     xmlEntityPtr ret = NULL;
 560 
 561     if (ctx == NULL) return(NULL);
 562 #ifdef DEBUG_SAX
 563     xmlGenericError(xmlGenericErrorContext,
 564         &quot;SAX.xmlSAX2GetEntity(%s)\n&quot;, name);
 565 #endif
 566 
 567     if (ctxt-&gt;inSubset == 0) {
 568     ret = xmlGetPredefinedEntity(name);
 569     if (ret != NULL)
 570         return(ret);
 571     }
 572     if ((ctxt-&gt;myDoc != NULL) &amp;&amp; (ctxt-&gt;myDoc-&gt;standalone == 1)) {
 573     if (ctxt-&gt;inSubset == 2) {
 574         ctxt-&gt;myDoc-&gt;standalone = 0;
 575         ret = xmlGetDocEntity(ctxt-&gt;myDoc, name);
 576         ctxt-&gt;myDoc-&gt;standalone = 1;
 577     } else {
 578         ret = xmlGetDocEntity(ctxt-&gt;myDoc, name);
 579         if (ret == NULL) {
 580         ctxt-&gt;myDoc-&gt;standalone = 0;
 581         ret = xmlGetDocEntity(ctxt-&gt;myDoc, name);
 582         if (ret != NULL) {
 583             xmlFatalErrMsg(ctxt, XML_ERR_NOT_STANDALONE,
 584      &quot;Entity(%s) document marked standalone but requires external subset\n&quot;,
 585                    name, NULL);
 586         }
 587         ctxt-&gt;myDoc-&gt;standalone = 1;
 588         }
 589     }
 590     } else {
 591     ret = xmlGetDocEntity(ctxt-&gt;myDoc, name);
 592     }
 593     if ((ret != NULL) &amp;&amp;
 594     ((ctxt-&gt;validate) || (ctxt-&gt;replaceEntities)) &amp;&amp;
 595     (ret-&gt;children == NULL) &amp;&amp;
 596     (ret-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {
 597     int val;
 598 
 599     /*
 600      * for validation purposes we really need to fetch and
 601      * parse the external entity
 602      */
 603     xmlNodePtr children;
 604     unsigned long oldnbent = ctxt-&gt;nbentities;
 605 
 606         val = xmlParseCtxtExternalEntity(ctxt, ret-&gt;URI,
 607                                  ret-&gt;ExternalID, &amp;children);
 608     if (val == 0) {
 609         xmlAddChildList((xmlNodePtr) ret, children);
 610     } else {
 611         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
 612                    &quot;Failure to process entity %s\n&quot;, name, NULL);
 613         ctxt-&gt;validate = 0;
 614         return(NULL);
 615     }
 616     ret-&gt;owner = 1;
 617     if (ret-&gt;checked == 0) {
 618         ret-&gt;checked = (ctxt-&gt;nbentities - oldnbent + 1) * 2;
 619         if ((ret-&gt;content != NULL) &amp;&amp; (xmlStrchr(ret-&gt;content, &#39;&lt;&#39;)))
 620             ret-&gt;checked |= 1;
 621     }
 622     }
 623     return(ret);
 624 }
 625 
 626 /**
 627  * xmlSAX2GetParameterEntity:
 628  * @ctx: the user data (XML parser context)
 629  * @name: The entity name
 630  *
 631  * Get a parameter entity by name
 632  *
 633  * Returns the xmlEntityPtr if found.
 634  */
 635 xmlEntityPtr
 636 xmlSAX2GetParameterEntity(void *ctx, const xmlChar *name)
 637 {
 638     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 639     xmlEntityPtr ret;
 640 
 641     if (ctx == NULL) return(NULL);
 642 #ifdef DEBUG_SAX
 643     xmlGenericError(xmlGenericErrorContext,
 644         &quot;SAX.xmlSAX2GetParameterEntity(%s)\n&quot;, name);
 645 #endif
 646 
 647     ret = xmlGetParameterEntity(ctxt-&gt;myDoc, name);
 648     return(ret);
 649 }
 650 
 651 
 652 /**
 653  * xmlSAX2EntityDecl:
 654  * @ctx: the user data (XML parser context)
 655  * @name:  the entity name
 656  * @type:  the entity type
 657  * @publicId: The public ID of the entity
 658  * @systemId: The system ID of the entity
 659  * @content: the entity value (without processing).
 660  *
 661  * An entity definition has been parsed
 662  */
 663 void
 664 xmlSAX2EntityDecl(void *ctx, const xmlChar *name, int type,
 665           const xmlChar *publicId, const xmlChar *systemId, xmlChar *content)
 666 {
 667     xmlEntityPtr ent;
 668     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 669 
 670     if (ctx == NULL) return;
 671 #ifdef DEBUG_SAX
 672     xmlGenericError(xmlGenericErrorContext,
 673         &quot;SAX.xmlSAX2EntityDecl(%s, %d, %s, %s, %s)\n&quot;,
 674             name, type, publicId, systemId, content);
 675 #endif
 676     if (ctxt-&gt;inSubset == 1) {
 677     ent = xmlAddDocEntity(ctxt-&gt;myDoc, name, type, publicId,
 678                       systemId, content);
 679     if ((ent == NULL) &amp;&amp; (ctxt-&gt;pedantic))
 680         xmlWarnMsg(ctxt, XML_WAR_ENTITY_REDEFINED,
 681          &quot;Entity(%s) already defined in the internal subset\n&quot;,
 682                    name);
 683     if ((ent != NULL) &amp;&amp; (ent-&gt;URI == NULL) &amp;&amp; (systemId != NULL)) {
 684         xmlChar *URI;
 685         const char *base = NULL;
 686 
 687         if (ctxt-&gt;input != NULL)
 688         base = ctxt-&gt;input-&gt;filename;
 689         if (base == NULL)
 690         base = ctxt-&gt;directory;
 691 
 692         URI = xmlBuildURI(systemId, (const xmlChar *) base);
 693         ent-&gt;URI = URI;
 694     }
 695     } else if (ctxt-&gt;inSubset == 2) {
 696     ent = xmlAddDtdEntity(ctxt-&gt;myDoc, name, type, publicId,
 697                       systemId, content);
 698     if ((ent == NULL) &amp;&amp; (ctxt-&gt;pedantic) &amp;&amp;
 699         (ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;warning != NULL))
 700         ctxt-&gt;sax-&gt;warning(ctxt-&gt;userData,
 701          &quot;Entity(%s) already defined in the external subset\n&quot;, name);
 702     if ((ent != NULL) &amp;&amp; (ent-&gt;URI == NULL) &amp;&amp; (systemId != NULL)) {
 703         xmlChar *URI;
 704         const char *base = NULL;
 705 
 706         if (ctxt-&gt;input != NULL)
 707         base = ctxt-&gt;input-&gt;filename;
 708         if (base == NULL)
 709         base = ctxt-&gt;directory;
 710 
 711         URI = xmlBuildURI(systemId, (const xmlChar *) base);
 712         ent-&gt;URI = URI;
 713     }
 714     } else {
 715     xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
 716                    &quot;SAX.xmlSAX2EntityDecl(%s) called while not in subset\n&quot;,
 717                name, NULL);
 718     }
 719 }
 720 
 721 /**
 722  * xmlSAX2AttributeDecl:
 723  * @ctx: the user data (XML parser context)
 724  * @elem:  the name of the element
 725  * @fullname:  the attribute name
 726  * @type:  the attribute type
 727  * @def:  the type of default value
 728  * @defaultValue: the attribute default value
 729  * @tree:  the tree of enumerated value set
 730  *
 731  * An attribute definition has been parsed
 732  */
 733 void
 734 xmlSAX2AttributeDecl(void *ctx, const xmlChar *elem, const xmlChar *fullname,
 735               int type, int def, const xmlChar *defaultValue,
 736           xmlEnumerationPtr tree)
 737 {
 738     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 739     xmlAttributePtr attr;
 740     xmlChar *name = NULL, *prefix = NULL;
 741 
 742     if ((ctxt == NULL) || (ctxt-&gt;myDoc == NULL))
 743         return;
 744 
 745 #ifdef DEBUG_SAX
 746     xmlGenericError(xmlGenericErrorContext,
 747         &quot;SAX.xmlSAX2AttributeDecl(%s, %s, %d, %d, %s, ...)\n&quot;,
 748             elem, fullname, type, def, defaultValue);
 749 #endif
 750     if ((xmlStrEqual(fullname, BAD_CAST &quot;xml:id&quot;)) &amp;&amp;
 751         (type != XML_ATTRIBUTE_ID)) {
 752     /*
 753      * Raise the error but keep the validity flag
 754      */
 755     int tmp = ctxt-&gt;valid;
 756     xmlErrValid(ctxt, XML_DTD_XMLID_TYPE,
 757           &quot;xml:id : attribute type should be ID\n&quot;, NULL, NULL);
 758     ctxt-&gt;valid = tmp;
 759     }
 760     /* TODO: optimize name/prefix allocation */
 761     name = xmlSplitQName(ctxt, fullname, &amp;prefix);
 762     ctxt-&gt;vctxt.valid = 1;
 763     if (ctxt-&gt;inSubset == 1)
 764     attr = xmlAddAttributeDecl(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc-&gt;intSubset, elem,
 765            name, prefix, (xmlAttributeType) type,
 766            (xmlAttributeDefault) def, defaultValue, tree);
 767     else if (ctxt-&gt;inSubset == 2)
 768     attr = xmlAddAttributeDecl(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc-&gt;extSubset, elem,
 769        name, prefix, (xmlAttributeType) type,
 770        (xmlAttributeDefault) def, defaultValue, tree);
 771     else {
 772         xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
 773          &quot;SAX.xmlSAX2AttributeDecl(%s) called while not in subset\n&quot;,
 774                    name, NULL);
 775     xmlFreeEnumeration(tree);
 776     return;
 777     }
 778 #ifdef LIBXML_VALID_ENABLED
 779     if (ctxt-&gt;vctxt.valid == 0)
 780     ctxt-&gt;valid = 0;
 781     if ((attr != NULL) &amp;&amp; (ctxt-&gt;validate) &amp;&amp; (ctxt-&gt;wellFormed) &amp;&amp;
 782         (ctxt-&gt;myDoc-&gt;intSubset != NULL))
 783     ctxt-&gt;valid &amp;= xmlValidateAttributeDecl(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc,
 784                                             attr);
 785 #endif /* LIBXML_VALID_ENABLED */
 786     if (prefix != NULL)
 787     xmlFree(prefix);
 788     if (name != NULL)
 789     xmlFree(name);
 790 }
 791 
 792 /**
 793  * xmlSAX2ElementDecl:
 794  * @ctx: the user data (XML parser context)
 795  * @name:  the element name
 796  * @type:  the element type
 797  * @content: the element value tree
 798  *
 799  * An element definition has been parsed
 800  */
 801 void
 802 xmlSAX2ElementDecl(void *ctx, const xmlChar * name, int type,
 803             xmlElementContentPtr content)
 804 {
 805     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 806     xmlElementPtr elem = NULL;
 807 
 808     if ((ctxt == NULL) || (ctxt-&gt;myDoc == NULL))
 809         return;
 810 
 811 #ifdef DEBUG_SAX
 812     xmlGenericError(xmlGenericErrorContext,
 813                     &quot;SAX.xmlSAX2ElementDecl(%s, %d, ...)\n&quot;, name, type);
 814 #endif
 815 
 816     if (ctxt-&gt;inSubset == 1)
 817         elem = xmlAddElementDecl(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc-&gt;intSubset,
 818                                  name, (xmlElementTypeVal) type, content);
 819     else if (ctxt-&gt;inSubset == 2)
 820         elem = xmlAddElementDecl(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc-&gt;extSubset,
 821                                  name, (xmlElementTypeVal) type, content);
 822     else {
 823         xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
 824          &quot;SAX.xmlSAX2ElementDecl(%s) called while not in subset\n&quot;,
 825                    name, NULL);
 826         return;
 827     }
 828 #ifdef LIBXML_VALID_ENABLED
 829     if (elem == NULL)
 830         ctxt-&gt;valid = 0;
 831     if (ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp;
 832         ctxt-&gt;myDoc &amp;&amp; ctxt-&gt;myDoc-&gt;intSubset)
 833         ctxt-&gt;valid &amp;=
 834             xmlValidateElementDecl(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc, elem);
 835 #endif /* LIBXML_VALID_ENABLED */
 836 }
 837 
 838 /**
 839  * xmlSAX2NotationDecl:
 840  * @ctx: the user data (XML parser context)
 841  * @name: The name of the notation
 842  * @publicId: The public ID of the entity
 843  * @systemId: The system ID of the entity
 844  *
 845  * What to do when a notation declaration has been parsed.
 846  */
 847 void
 848 xmlSAX2NotationDecl(void *ctx, const xmlChar *name,
 849          const xmlChar *publicId, const xmlChar *systemId)
 850 {
 851     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 852     xmlNotationPtr nota = NULL;
 853 
 854     if ((ctxt == NULL) || (ctxt-&gt;myDoc == NULL))
 855         return;
 856 
 857 #ifdef DEBUG_SAX
 858     xmlGenericError(xmlGenericErrorContext,
 859         &quot;SAX.xmlSAX2NotationDecl(%s, %s, %s)\n&quot;, name, publicId, systemId);
 860 #endif
 861 
 862     if ((publicId == NULL) &amp;&amp; (systemId == NULL)) {
 863     xmlFatalErrMsg(ctxt, XML_ERR_NOTATION_PROCESSING,
 864          &quot;SAX.xmlSAX2NotationDecl(%s) externalID or PublicID missing\n&quot;,
 865                    name, NULL);
 866     return;
 867     } else if (ctxt-&gt;inSubset == 1)
 868     nota = xmlAddNotationDecl(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc-&gt;intSubset, name,
 869                               publicId, systemId);
 870     else if (ctxt-&gt;inSubset == 2)
 871     nota = xmlAddNotationDecl(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc-&gt;extSubset, name,
 872                               publicId, systemId);
 873     else {
 874     xmlFatalErrMsg(ctxt, XML_ERR_NOTATION_PROCESSING,
 875          &quot;SAX.xmlSAX2NotationDecl(%s) called while not in subset\n&quot;,
 876                    name, NULL);
 877     return;
 878     }
 879 #ifdef LIBXML_VALID_ENABLED
 880     if (nota == NULL) ctxt-&gt;valid = 0;
 881     if ((ctxt-&gt;validate) &amp;&amp; (ctxt-&gt;wellFormed) &amp;&amp;
 882         (ctxt-&gt;myDoc-&gt;intSubset != NULL))
 883     ctxt-&gt;valid &amp;= xmlValidateNotationDecl(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc,
 884                                            nota);
 885 #endif /* LIBXML_VALID_ENABLED */
 886 }
 887 
 888 /**
 889  * xmlSAX2UnparsedEntityDecl:
 890  * @ctx: the user data (XML parser context)
 891  * @name: The name of the entity
 892  * @publicId: The public ID of the entity
 893  * @systemId: The system ID of the entity
 894  * @notationName: the name of the notation
 895  *
 896  * What to do when an unparsed entity declaration is parsed
 897  */
 898 void
 899 xmlSAX2UnparsedEntityDecl(void *ctx, const xmlChar *name,
 900            const xmlChar *publicId, const xmlChar *systemId,
 901            const xmlChar *notationName)
 902 {
 903     xmlEntityPtr ent;
 904     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 905     if (ctx == NULL) return;
 906 #ifdef DEBUG_SAX
 907     xmlGenericError(xmlGenericErrorContext,
 908         &quot;SAX.xmlSAX2UnparsedEntityDecl(%s, %s, %s, %s)\n&quot;,
 909             name, publicId, systemId, notationName);
 910 #endif
 911     if (ctxt-&gt;inSubset == 1) {
 912     ent = xmlAddDocEntity(ctxt-&gt;myDoc, name,
 913             XML_EXTERNAL_GENERAL_UNPARSED_ENTITY,
 914             publicId, systemId, notationName);
 915     if ((ent == NULL) &amp;&amp; (ctxt-&gt;pedantic) &amp;&amp;
 916         (ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;warning != NULL))
 917         ctxt-&gt;sax-&gt;warning(ctxt-&gt;userData,
 918          &quot;Entity(%s) already defined in the internal subset\n&quot;, name);
 919     if ((ent != NULL) &amp;&amp; (ent-&gt;URI == NULL) &amp;&amp; (systemId != NULL)) {
 920         xmlChar *URI;
 921         const char *base = NULL;
 922 
 923         if (ctxt-&gt;input != NULL)
 924         base = ctxt-&gt;input-&gt;filename;
 925         if (base == NULL)
 926         base = ctxt-&gt;directory;
 927 
 928         URI = xmlBuildURI(systemId, (const xmlChar *) base);
 929         ent-&gt;URI = URI;
 930     }
 931     } else if (ctxt-&gt;inSubset == 2) {
 932     ent = xmlAddDtdEntity(ctxt-&gt;myDoc, name,
 933             XML_EXTERNAL_GENERAL_UNPARSED_ENTITY,
 934             publicId, systemId, notationName);
 935     if ((ent == NULL) &amp;&amp; (ctxt-&gt;pedantic) &amp;&amp;
 936         (ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;warning != NULL))
 937         ctxt-&gt;sax-&gt;warning(ctxt-&gt;userData,
 938          &quot;Entity(%s) already defined in the external subset\n&quot;, name);
 939     if ((ent != NULL) &amp;&amp; (ent-&gt;URI == NULL) &amp;&amp; (systemId != NULL)) {
 940         xmlChar *URI;
 941         const char *base = NULL;
 942 
 943         if (ctxt-&gt;input != NULL)
 944         base = ctxt-&gt;input-&gt;filename;
 945         if (base == NULL)
 946         base = ctxt-&gt;directory;
 947 
 948         URI = xmlBuildURI(systemId, (const xmlChar *) base);
 949         ent-&gt;URI = URI;
 950     }
 951     } else {
 952         xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
 953          &quot;SAX.xmlSAX2UnparsedEntityDecl(%s) called while not in subset\n&quot;,
 954                    name, NULL);
 955     }
 956 }
 957 
 958 /**
 959  * xmlSAX2SetDocumentLocator:
 960  * @ctx: the user data (XML parser context)
 961  * @loc: A SAX Locator
 962  *
 963  * Receive the document locator at startup, actually xmlDefaultSAXLocator
 964  * Everything is available on the context, so this is useless in our case.
 965  */
 966 void
 967 xmlSAX2SetDocumentLocator(void *ctx ATTRIBUTE_UNUSED, xmlSAXLocatorPtr loc ATTRIBUTE_UNUSED)
 968 {
 969     /* xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx; */
 970 #ifdef DEBUG_SAX
 971     xmlGenericError(xmlGenericErrorContext,
 972         &quot;SAX.xmlSAX2SetDocumentLocator()\n&quot;);
 973 #endif
 974 }
 975 
 976 /**
 977  * xmlSAX2StartDocument:
 978  * @ctx: the user data (XML parser context)
 979  *
 980  * called when the document start being processed.
 981  */
 982 void
 983 xmlSAX2StartDocument(void *ctx)
 984 {
 985     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 986     xmlDocPtr doc;
 987 
 988     if (ctx == NULL) return;
 989 
 990 #ifdef DEBUG_SAX
 991     xmlGenericError(xmlGenericErrorContext,
 992         &quot;SAX.xmlSAX2StartDocument()\n&quot;);
 993 #endif
 994     if (ctxt-&gt;html) {
 995 #ifdef LIBXML_HTML_ENABLED
 996     if (ctxt-&gt;myDoc == NULL)
 997         ctxt-&gt;myDoc = htmlNewDocNoDtD(NULL, NULL);
 998     if (ctxt-&gt;myDoc == NULL) {
 999         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartDocument&quot;);
1000         return;
1001     }
1002     ctxt-&gt;myDoc-&gt;properties = XML_DOC_HTML;
1003     ctxt-&gt;myDoc-&gt;parseFlags = ctxt-&gt;options;
1004 #else
1005         xmlGenericError(xmlGenericErrorContext,
1006         &quot;libxml2 built without HTML support\n&quot;);
1007     ctxt-&gt;errNo = XML_ERR_INTERNAL_ERROR;
1008     ctxt-&gt;instate = XML_PARSER_EOF;
1009     ctxt-&gt;disableSAX = 1;
1010     return;
1011 #endif
1012     } else {
1013     doc = ctxt-&gt;myDoc = xmlNewDoc(ctxt-&gt;version);
1014     if (doc != NULL) {
1015         doc-&gt;properties = 0;
1016         if (ctxt-&gt;options &amp; XML_PARSE_OLD10)
1017             doc-&gt;properties |= XML_DOC_OLD10;
1018         doc-&gt;parseFlags = ctxt-&gt;options;
1019         if (ctxt-&gt;encoding != NULL)
1020         doc-&gt;encoding = xmlStrdup(ctxt-&gt;encoding);
1021         else
1022         doc-&gt;encoding = NULL;
1023         doc-&gt;standalone = ctxt-&gt;standalone;
1024     } else {
1025         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartDocument&quot;);
1026         return;
1027     }
1028     if ((ctxt-&gt;dictNames) &amp;&amp; (doc != NULL)) {
1029         doc-&gt;dict = ctxt-&gt;dict;
1030         xmlDictReference(doc-&gt;dict);
1031     }
1032     }
1033     if ((ctxt-&gt;myDoc != NULL) &amp;&amp; (ctxt-&gt;myDoc-&gt;URL == NULL) &amp;&amp;
1034     (ctxt-&gt;input != NULL) &amp;&amp; (ctxt-&gt;input-&gt;filename != NULL)) {
1035     ctxt-&gt;myDoc-&gt;URL = xmlPathToURI((const xmlChar *)ctxt-&gt;input-&gt;filename);
1036     if (ctxt-&gt;myDoc-&gt;URL == NULL)
1037         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartDocument&quot;);
1038     }
1039 }
1040 
1041 /**
1042  * xmlSAX2EndDocument:
1043  * @ctx: the user data (XML parser context)
1044  *
1045  * called when the document end has been detected.
1046  */
1047 void
1048 xmlSAX2EndDocument(void *ctx)
1049 {
1050     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
1051 #ifdef DEBUG_SAX
1052     xmlGenericError(xmlGenericErrorContext,
1053         &quot;SAX.xmlSAX2EndDocument()\n&quot;);
1054 #endif
1055     if (ctx == NULL) return;
1056 #ifdef LIBXML_VALID_ENABLED
1057     if (ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp;
1058         ctxt-&gt;myDoc &amp;&amp; ctxt-&gt;myDoc-&gt;intSubset)
1059     ctxt-&gt;valid &amp;= xmlValidateDocumentFinal(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc);
1060 #endif /* LIBXML_VALID_ENABLED */
1061 
1062     /*
1063      * Grab the encoding if it was added on-the-fly
1064      */
1065     if ((ctxt-&gt;encoding != NULL) &amp;&amp; (ctxt-&gt;myDoc != NULL) &amp;&amp;
1066     (ctxt-&gt;myDoc-&gt;encoding == NULL)) {
1067     ctxt-&gt;myDoc-&gt;encoding = ctxt-&gt;encoding;
1068     ctxt-&gt;encoding = NULL;
1069     }
1070     if ((ctxt-&gt;inputTab != NULL) &amp;&amp;
1071         (ctxt-&gt;inputNr &gt; 0) &amp;&amp; (ctxt-&gt;inputTab[0] != NULL) &amp;&amp;
1072         (ctxt-&gt;inputTab[0]-&gt;encoding != NULL) &amp;&amp; (ctxt-&gt;myDoc != NULL) &amp;&amp;
1073     (ctxt-&gt;myDoc-&gt;encoding == NULL)) {
1074     ctxt-&gt;myDoc-&gt;encoding = xmlStrdup(ctxt-&gt;inputTab[0]-&gt;encoding);
1075     }
1076     if ((ctxt-&gt;charset != XML_CHAR_ENCODING_NONE) &amp;&amp; (ctxt-&gt;myDoc != NULL) &amp;&amp;
1077     (ctxt-&gt;myDoc-&gt;charset == XML_CHAR_ENCODING_NONE)) {
1078     ctxt-&gt;myDoc-&gt;charset = ctxt-&gt;charset;
1079     }
1080 }
1081 
1082 #if defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_DOCB_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
1083 /**
1084  * xmlSAX2AttributeInternal:
1085  * @ctx: the user data (XML parser context)
1086  * @fullname:  The attribute name, including namespace prefix
1087  * @value:  The attribute value
1088  * @prefix: the prefix on the element node
1089  *
1090  * Handle an attribute that has been read by the parser.
1091  * The default handling is to convert the attribute into an
1092  * DOM subtree and past it in a new xmlAttr element added to
1093  * the element.
1094  */
1095 static void
1096 xmlSAX2AttributeInternal(void *ctx, const xmlChar *fullname,
1097              const xmlChar *value, const xmlChar *prefix ATTRIBUTE_UNUSED)
1098 {
1099     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
1100     xmlAttrPtr ret;
1101     xmlChar *name;
1102     xmlChar *ns;
1103     xmlChar *nval;
1104     xmlNsPtr namespace;
1105 
1106     if (ctxt-&gt;html) {
1107     name = xmlStrdup(fullname);
1108     ns = NULL;
1109     namespace = NULL;
1110     } else {
1111     /*
1112      * Split the full name into a namespace prefix and the tag name
1113      */
1114     name = xmlSplitQName(ctxt, fullname, &amp;ns);
1115     if ((name != NULL) &amp;&amp; (name[0] == 0)) {
1116         if (xmlStrEqual(ns, BAD_CAST &quot;xmlns&quot;)) {
1117         xmlNsErrMsg(ctxt, XML_ERR_NS_DECL_ERROR,
1118                 &quot;invalid namespace declaration &#39;%s&#39;\n&quot;,
1119                 fullname, NULL);
1120         } else {
1121         xmlNsWarnMsg(ctxt, XML_WAR_NS_COLUMN,
1122                  &quot;Avoid attribute ending with &#39;:&#39; like &#39;%s&#39;\n&quot;,
1123                  fullname, NULL);
1124         }
1125         if (ns != NULL)
1126         xmlFree(ns);
1127         ns = NULL;
1128         xmlFree(name);
1129         name = xmlStrdup(fullname);
1130     }
1131     }
1132     if (name == NULL) {
1133         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartElement&quot;);
1134     if (ns != NULL)
1135         xmlFree(ns);
1136     return;
1137     }
1138 
1139 #ifdef LIBXML_HTML_ENABLED
1140     if ((ctxt-&gt;html) &amp;&amp;
1141         (value == NULL) &amp;&amp; (htmlIsBooleanAttr(fullname))) {
1142             nval = xmlStrdup(fullname);
1143             value = (const xmlChar *) nval;
1144     } else
1145 #endif
1146     {
1147 #ifdef LIBXML_VALID_ENABLED
1148         /*
1149          * Do the last stage of the attribute normalization
1150          * Needed for HTML too:
1151          *   http://www.w3.org/TR/html4/types.html#h-6.2
1152          */
1153         ctxt-&gt;vctxt.valid = 1;
1154         nval = xmlValidCtxtNormalizeAttributeValue(&amp;ctxt-&gt;vctxt,
1155                                                ctxt-&gt;myDoc, ctxt-&gt;node,
1156                                                fullname, value);
1157         if (ctxt-&gt;vctxt.valid != 1) {
1158             ctxt-&gt;valid = 0;
1159         }
1160         if (nval != NULL)
1161             value = nval;
1162 #else
1163         nval = NULL;
1164 #endif /* LIBXML_VALID_ENABLED */
1165     }
1166 
1167     /*
1168      * Check whether it&#39;s a namespace definition
1169      */
1170     if ((!ctxt-&gt;html) &amp;&amp; (ns == NULL) &amp;&amp;
1171         (name[0] == &#39;x&#39;) &amp;&amp; (name[1] == &#39;m&#39;) &amp;&amp; (name[2] == &#39;l&#39;) &amp;&amp;
1172         (name[3] == &#39;n&#39;) &amp;&amp; (name[4] == &#39;s&#39;) &amp;&amp; (name[5] == 0)) {
1173     xmlNsPtr nsret;
1174     xmlChar *val;
1175 
1176         if (!ctxt-&gt;replaceEntities) {
1177         ctxt-&gt;depth++;
1178         val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF,
1179                                   0,0,0);
1180         ctxt-&gt;depth--;
1181         if (val == NULL) {
1182             xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartElement&quot;);
1183         if (name != NULL)
1184             xmlFree(name);
1185                 if (nval != NULL)
1186                     xmlFree(nval);
1187         return;
1188         }
1189     } else {
1190         val = (xmlChar *) value;
1191     }
1192 
1193     if (val[0] != 0) {
1194         xmlURIPtr uri;
1195 
1196         uri = xmlParseURI((const char *)val);
1197         if (uri == NULL) {
1198         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;warning != NULL))
1199             ctxt-&gt;sax-&gt;warning(ctxt-&gt;userData,
1200              &quot;xmlns: %s not a valid URI\n&quot;, val);
1201         } else {
1202         if (uri-&gt;scheme == NULL) {
1203             if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;warning != NULL))
1204             ctxt-&gt;sax-&gt;warning(ctxt-&gt;userData,
1205                  &quot;xmlns: URI %s is not absolute\n&quot;, val);
1206         }
1207         xmlFreeURI(uri);
1208         }
1209     }
1210 
1211     /* a default namespace definition */
1212     nsret = xmlNewNs(ctxt-&gt;node, val, NULL);
1213 
1214 #ifdef LIBXML_VALID_ENABLED
1215     /*
1216      * Validate also for namespace decls, they are attributes from
1217      * an XML-1.0 perspective
1218      */
1219         if (nsret != NULL &amp;&amp; ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp;
1220         ctxt-&gt;myDoc &amp;&amp; ctxt-&gt;myDoc-&gt;intSubset)
1221         ctxt-&gt;valid &amp;= xmlValidateOneNamespace(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc,
1222                        ctxt-&gt;node, prefix, nsret, val);
1223 #endif /* LIBXML_VALID_ENABLED */
1224     if (name != NULL)
1225         xmlFree(name);
1226     if (nval != NULL)
1227         xmlFree(nval);
1228     if (val != value)
1229         xmlFree(val);
1230     return;
1231     }
1232     if ((!ctxt-&gt;html) &amp;&amp;
1233     (ns != NULL) &amp;&amp; (ns[0] == &#39;x&#39;) &amp;&amp; (ns[1] == &#39;m&#39;) &amp;&amp; (ns[2] == &#39;l&#39;) &amp;&amp;
1234         (ns[3] == &#39;n&#39;) &amp;&amp; (ns[4] == &#39;s&#39;) &amp;&amp; (ns[5] == 0)) {
1235     xmlNsPtr nsret;
1236     xmlChar *val;
1237 
1238         if (!ctxt-&gt;replaceEntities) {
1239         ctxt-&gt;depth++;
1240         val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF,
1241                                   0,0,0);
1242         ctxt-&gt;depth--;
1243         if (val == NULL) {
1244             xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartElement&quot;);
1245             xmlFree(ns);
1246         if (name != NULL)
1247             xmlFree(name);
1248                 if (nval != NULL)
1249                     xmlFree(nval);
1250         return;
1251         }
1252     } else {
1253         val = (xmlChar *) value;
1254     }
1255 
1256     if (val[0] == 0) {
1257         xmlNsErrMsg(ctxt, XML_NS_ERR_EMPTY,
1258                 &quot;Empty namespace name for prefix %s\n&quot;, name, NULL);
1259     }
1260     if ((ctxt-&gt;pedantic != 0) &amp;&amp; (val[0] != 0)) {
1261         xmlURIPtr uri;
1262 
1263         uri = xmlParseURI((const char *)val);
1264         if (uri == NULL) {
1265             xmlNsWarnMsg(ctxt, XML_WAR_NS_URI,
1266              &quot;xmlns:%s: %s not a valid URI\n&quot;, name, value);
1267         } else {
1268         if (uri-&gt;scheme == NULL) {
1269             xmlNsWarnMsg(ctxt, XML_WAR_NS_URI_RELATIVE,
1270                &quot;xmlns:%s: URI %s is not absolute\n&quot;, name, value);
1271         }
1272         xmlFreeURI(uri);
1273         }
1274     }
1275 
1276     /* a standard namespace definition */
1277     nsret = xmlNewNs(ctxt-&gt;node, val, name);
1278     xmlFree(ns);
1279 #ifdef LIBXML_VALID_ENABLED
1280     /*
1281      * Validate also for namespace decls, they are attributes from
1282      * an XML-1.0 perspective
1283      */
1284         if (nsret != NULL &amp;&amp; ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp;
1285         ctxt-&gt;myDoc &amp;&amp; ctxt-&gt;myDoc-&gt;intSubset)
1286         ctxt-&gt;valid &amp;= xmlValidateOneNamespace(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc,
1287                        ctxt-&gt;node, prefix, nsret, value);
1288 #endif /* LIBXML_VALID_ENABLED */
1289     if (name != NULL)
1290         xmlFree(name);
1291     if (nval != NULL)
1292         xmlFree(nval);
1293     if (val != value)
1294         xmlFree(val);
1295     return;
1296     }
1297 
1298     if (ns != NULL) {
1299     namespace = xmlSearchNs(ctxt-&gt;myDoc, ctxt-&gt;node, ns);
1300 
1301     if (namespace == NULL) {
1302         xmlNsErrMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
1303             &quot;Namespace prefix %s of attribute %s is not defined\n&quot;,
1304                      ns, name);
1305     } else {
1306             xmlAttrPtr prop;
1307 
1308             prop = ctxt-&gt;node-&gt;properties;
1309             while (prop != NULL) {
1310                 if (prop-&gt;ns != NULL) {
1311                     if ((xmlStrEqual(name, prop-&gt;name)) &amp;&amp;
1312                         ((namespace == prop-&gt;ns) ||
1313                          (xmlStrEqual(namespace-&gt;href, prop-&gt;ns-&gt;href)))) {
1314                             xmlNsErrMsg(ctxt, XML_ERR_ATTRIBUTE_REDEFINED,
1315                                     &quot;Attribute %s in %s redefined\n&quot;,
1316                                              name, namespace-&gt;href);
1317                         ctxt-&gt;wellFormed = 0;
1318                         if (ctxt-&gt;recovery == 0) ctxt-&gt;disableSAX = 1;
1319                         if (name != NULL)
1320                             xmlFree(name);
1321                         goto error;
1322                     }
1323                 }
1324                 prop = prop-&gt;next;
1325             }
1326         }
1327     } else {
1328     namespace = NULL;
1329     }
1330 
1331     /* !!!!!! &lt;a toto:arg=&quot;&quot; xmlns:toto=&quot;http://toto.com&quot;&gt; */
1332     ret = xmlNewNsPropEatName(ctxt-&gt;node, namespace, name, NULL);
1333 
1334     if (ret != NULL) {
1335         if ((ctxt-&gt;replaceEntities == 0) &amp;&amp; (!ctxt-&gt;html)) {
1336         xmlNodePtr tmp;
1337 
1338         ret-&gt;children = xmlStringGetNodeList(ctxt-&gt;myDoc, value);
1339         tmp = ret-&gt;children;
1340         while (tmp != NULL) {
1341         tmp-&gt;parent = (xmlNodePtr) ret;
1342         if (tmp-&gt;next == NULL)
1343             ret-&gt;last = tmp;
1344         tmp = tmp-&gt;next;
1345         }
1346     } else if (value != NULL) {
1347         ret-&gt;children = xmlNewDocText(ctxt-&gt;myDoc, value);
1348         ret-&gt;last = ret-&gt;children;
1349         if (ret-&gt;children != NULL)
1350         ret-&gt;children-&gt;parent = (xmlNodePtr) ret;
1351     }
1352     }
1353 
1354 #ifdef LIBXML_VALID_ENABLED
1355     if ((!ctxt-&gt;html) &amp;&amp; ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp;
1356         ctxt-&gt;myDoc &amp;&amp; ctxt-&gt;myDoc-&gt;intSubset) {
1357 
1358     /*
1359      * If we don&#39;t substitute entities, the validation should be
1360      * done on a value with replaced entities anyway.
1361      */
1362         if (!ctxt-&gt;replaceEntities) {
1363         xmlChar *val;
1364 
1365         ctxt-&gt;depth++;
1366         val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF,
1367                                   0,0,0);
1368         ctxt-&gt;depth--;
1369 
1370         if (val == NULL)
1371         ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
1372                 ctxt-&gt;myDoc, ctxt-&gt;node, ret, value);
1373         else {
1374         xmlChar *nvalnorm;
1375 
1376         /*
1377          * Do the last stage of the attribute normalization
1378          * It need to be done twice ... it&#39;s an extra burden related
1379          * to the ability to keep xmlSAX2References in attributes
1380          */
1381         nvalnorm = xmlValidNormalizeAttributeValue(ctxt-&gt;myDoc,
1382                         ctxt-&gt;node, fullname, val);
1383         if (nvalnorm != NULL) {
1384             xmlFree(val);
1385             val = nvalnorm;
1386         }
1387 
1388         ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
1389                     ctxt-&gt;myDoc, ctxt-&gt;node, ret, val);
1390                 xmlFree(val);
1391         }
1392     } else {
1393         ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc,
1394                            ctxt-&gt;node, ret, value);
1395     }
1396     } else
1397 #endif /* LIBXML_VALID_ENABLED */
1398            if (((ctxt-&gt;loadsubset &amp; XML_SKIP_IDS) == 0) &amp;&amp;
1399            (((ctxt-&gt;replaceEntities == 0) &amp;&amp; (ctxt-&gt;external != 2)) ||
1400             ((ctxt-&gt;replaceEntities != 0) &amp;&amp; (ctxt-&gt;inSubset == 0)))) {
1401         /*
1402      * when validating, the ID registration is done at the attribute
1403      * validation level. Otherwise we have to do specific handling here.
1404      */
1405     if (xmlStrEqual(fullname, BAD_CAST &quot;xml:id&quot;)) {
1406         /*
1407          * Add the xml:id value
1408          *
1409          * Open issue: normalization of the value.
1410          */
1411         if (xmlValidateNCName(value, 1) != 0) {
1412             xmlErrValid(ctxt, XML_DTD_XMLID_VALUE,
1413               &quot;xml:id : attribute value %s is not an NCName\n&quot;,
1414                 (const char *) value, NULL);
1415         }
1416         xmlAddID(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc, value, ret);
1417     } else if (xmlIsID(ctxt-&gt;myDoc, ctxt-&gt;node, ret))
1418         xmlAddID(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc, value, ret);
1419     else if (xmlIsRef(ctxt-&gt;myDoc, ctxt-&gt;node, ret))
1420         xmlAddRef(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc, value, ret);
1421     }
1422 
1423 error:
1424     if (nval != NULL)
1425     xmlFree(nval);
1426     if (ns != NULL)
1427     xmlFree(ns);
1428 }
1429 
1430 /*
1431  * xmlCheckDefaultedAttributes:
1432  *
1433  * Check defaulted attributes from the DTD
1434  */
1435 static void
1436 xmlCheckDefaultedAttributes(xmlParserCtxtPtr ctxt, const xmlChar *name,
1437     const xmlChar *prefix, const xmlChar **atts) {
1438     xmlElementPtr elemDecl;
1439     const xmlChar *att;
1440     int internal = 1;
1441     int i;
1442 
1443     elemDecl = xmlGetDtdQElementDesc(ctxt-&gt;myDoc-&gt;intSubset, name, prefix);
1444     if (elemDecl == NULL) {
1445     elemDecl = xmlGetDtdQElementDesc(ctxt-&gt;myDoc-&gt;extSubset, name, prefix);
1446     internal = 0;
1447     }
1448 
1449 process_external_subset:
1450 
1451     if (elemDecl != NULL) {
1452     xmlAttributePtr attr = elemDecl-&gt;attributes;
1453     /*
1454      * Check against defaulted attributes from the external subset
1455      * if the document is stamped as standalone
1456      */
1457     if ((ctxt-&gt;myDoc-&gt;standalone == 1) &amp;&amp;
1458         (ctxt-&gt;myDoc-&gt;extSubset != NULL) &amp;&amp;
1459         (ctxt-&gt;validate)) {
1460         while (attr != NULL) {
1461         if ((attr-&gt;defaultValue != NULL) &amp;&amp;
1462             (xmlGetDtdQAttrDesc(ctxt-&gt;myDoc-&gt;extSubset,
1463                     attr-&gt;elem, attr-&gt;name,
1464                     attr-&gt;prefix) == attr) &amp;&amp;
1465             (xmlGetDtdQAttrDesc(ctxt-&gt;myDoc-&gt;intSubset,
1466                     attr-&gt;elem, attr-&gt;name,
1467                     attr-&gt;prefix) == NULL)) {
1468             xmlChar *fulln;
1469 
1470             if (attr-&gt;prefix != NULL) {
1471             fulln = xmlStrdup(attr-&gt;prefix);
1472             fulln = xmlStrcat(fulln, BAD_CAST &quot;:&quot;);
1473             fulln = xmlStrcat(fulln, attr-&gt;name);
1474             } else {
1475             fulln = xmlStrdup(attr-&gt;name);
1476             }
1477                     if (fulln == NULL) {
1478                         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartElement&quot;);
1479                         break;
1480                     }
1481 
1482             /*
1483              * Check that the attribute is not declared in the
1484              * serialization
1485              */
1486             att = NULL;
1487             if (atts != NULL) {
1488             i = 0;
1489             att = atts[i];
1490             while (att != NULL) {
1491                 if (xmlStrEqual(att, fulln))
1492                 break;
1493                 i += 2;
1494                 att = atts[i];
1495             }
1496             }
1497             if (att == NULL) {
1498                 xmlErrValid(ctxt, XML_DTD_STANDALONE_DEFAULTED,
1499       &quot;standalone: attribute %s on %s defaulted from external subset\n&quot;,
1500                     (const char *)fulln,
1501                     (const char *)attr-&gt;elem);
1502             }
1503                     xmlFree(fulln);
1504         }
1505         attr = attr-&gt;nexth;
1506         }
1507     }
1508 
1509     /*
1510      * Actually insert defaulted values when needed
1511      */
1512     attr = elemDecl-&gt;attributes;
1513     while (attr != NULL) {
1514         /*
<a name="2" id="anc2"></a><span class="line-modified">1515          * Make sure that attributes redefinition occuring in the</span>
<span class="line-modified">1516          * internal subset are not overriden by definitions in the</span>
1517          * external subset.
1518          */
1519         if (attr-&gt;defaultValue != NULL) {
1520         /*
1521          * the element should be instantiated in the tree if:
1522          *  - this is a namespace prefix
1523          *  - the user required for completion in the tree
1524          *    like XSLT
1525          *  - there isn&#39;t already an attribute definition
1526          *    in the internal subset overriding it.
1527          */
1528         if (((attr-&gt;prefix != NULL) &amp;&amp;
1529              (xmlStrEqual(attr-&gt;prefix, BAD_CAST &quot;xmlns&quot;))) ||
1530             ((attr-&gt;prefix == NULL) &amp;&amp;
1531              (xmlStrEqual(attr-&gt;name, BAD_CAST &quot;xmlns&quot;))) ||
1532             (ctxt-&gt;loadsubset &amp; XML_COMPLETE_ATTRS)) {
1533             xmlAttributePtr tst;
1534 
1535             tst = xmlGetDtdQAttrDesc(ctxt-&gt;myDoc-&gt;intSubset,
1536                          attr-&gt;elem, attr-&gt;name,
1537                          attr-&gt;prefix);
1538             if ((tst == attr) || (tst == NULL)) {
1539                 xmlChar fn[50];
1540             xmlChar *fulln;
1541 
1542                         fulln = xmlBuildQName(attr-&gt;name, attr-&gt;prefix, fn, 50);
1543             if (fulln == NULL) {
1544                 xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartElement&quot;);
1545                 return;
1546             }
1547 
1548             /*
1549              * Check that the attribute is not declared in the
1550              * serialization
1551              */
1552             att = NULL;
1553             if (atts != NULL) {
1554                 i = 0;
1555                 att = atts[i];
1556                 while (att != NULL) {
1557                 if (xmlStrEqual(att, fulln))
1558                     break;
1559                 i += 2;
1560                 att = atts[i];
1561                 }
1562             }
1563             if (att == NULL) {
1564                 xmlSAX2AttributeInternal(ctxt, fulln,
1565                          attr-&gt;defaultValue, prefix);
1566             }
1567             if ((fulln != fn) &amp;&amp; (fulln != attr-&gt;name))
1568                 xmlFree(fulln);
1569             }
1570         }
1571         }
1572         attr = attr-&gt;nexth;
1573     }
1574     if (internal == 1) {
1575         elemDecl = xmlGetDtdQElementDesc(ctxt-&gt;myDoc-&gt;extSubset,
1576                                      name, prefix);
1577         internal = 0;
1578         goto process_external_subset;
1579     }
1580     }
1581 }
1582 
1583 /**
1584  * xmlSAX2StartElement:
1585  * @ctx: the user data (XML parser context)
1586  * @fullname:  The element name, including namespace prefix
1587  * @atts:  An array of name/value attributes pairs, NULL terminated
1588  *
1589  * called when an opening tag has been processed.
1590  */
1591 void
1592 xmlSAX2StartElement(void *ctx, const xmlChar *fullname, const xmlChar **atts)
1593 {
1594     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
1595     xmlNodePtr ret;
1596     xmlNodePtr parent;
1597     xmlNsPtr ns;
1598     xmlChar *name;
1599     xmlChar *prefix;
1600     const xmlChar *att;
1601     const xmlChar *value;
1602     int i;
1603 
1604     if ((ctx == NULL) || (fullname == NULL) || (ctxt-&gt;myDoc == NULL)) return;
1605     parent = ctxt-&gt;node;
1606 #ifdef DEBUG_SAX
1607     xmlGenericError(xmlGenericErrorContext,
1608         &quot;SAX.xmlSAX2StartElement(%s)\n&quot;, fullname);
1609 #endif
1610 
1611     /*
1612      * First check on validity:
1613      */
1614     if (ctxt-&gt;validate &amp;&amp; (ctxt-&gt;myDoc-&gt;extSubset == NULL) &amp;&amp;
1615         ((ctxt-&gt;myDoc-&gt;intSubset == NULL) ||
1616      ((ctxt-&gt;myDoc-&gt;intSubset-&gt;notations == NULL) &amp;&amp;
1617       (ctxt-&gt;myDoc-&gt;intSubset-&gt;elements == NULL) &amp;&amp;
1618       (ctxt-&gt;myDoc-&gt;intSubset-&gt;attributes == NULL) &amp;&amp;
1619       (ctxt-&gt;myDoc-&gt;intSubset-&gt;entities == NULL)))) {
1620     xmlErrValid(ctxt, XML_ERR_NO_DTD,
1621       &quot;Validation failed: no DTD found !&quot;, NULL, NULL);
1622     ctxt-&gt;validate = 0;
1623     }
1624 
1625 
1626     /*
1627      * Split the full name into a namespace prefix and the tag name
1628      */
1629     name = xmlSplitQName(ctxt, fullname, &amp;prefix);
1630 
1631 
1632     /*
1633      * Note : the namespace resolution is deferred until the end of the
1634      *        attributes parsing, since local namespace can be defined as
1635      *        an attribute at this level.
1636      */
1637     ret = xmlNewDocNodeEatName(ctxt-&gt;myDoc, NULL, name, NULL);
1638     if (ret == NULL) {
1639         if (prefix != NULL)
1640         xmlFree(prefix);
1641     xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartElement&quot;);
1642         return;
1643     }
1644     if (ctxt-&gt;myDoc-&gt;children == NULL) {
1645 #ifdef DEBUG_SAX_TREE
1646     xmlGenericError(xmlGenericErrorContext, &quot;Setting %s as root\n&quot;, name);
1647 #endif
1648         xmlAddChild((xmlNodePtr) ctxt-&gt;myDoc, (xmlNodePtr) ret);
1649     } else if (parent == NULL) {
1650         parent = ctxt-&gt;myDoc-&gt;children;
1651     }
1652     ctxt-&gt;nodemem = -1;
1653     if (ctxt-&gt;linenumbers) {
1654     if (ctxt-&gt;input != NULL) {
1655         if (ctxt-&gt;input-&gt;line &lt; 65535)
1656         ret-&gt;line = (short) ctxt-&gt;input-&gt;line;
1657         else
1658             ret-&gt;line = 65535;
1659     }
1660     }
1661 
1662     /*
1663      * We are parsing a new node.
1664      */
1665 #ifdef DEBUG_SAX_TREE
1666     xmlGenericError(xmlGenericErrorContext, &quot;pushing(%s)\n&quot;, name);
1667 #endif
1668     if (nodePush(ctxt, ret) &lt; 0) {
1669         xmlUnlinkNode(ret);
1670         xmlFreeNode(ret);
<a name="3" id="anc3"></a>

1671         return;
1672     }
1673 
1674     /*
1675      * Link the child element
1676      */
1677     if (parent != NULL) {
1678         if (parent-&gt;type == XML_ELEMENT_NODE) {
1679 #ifdef DEBUG_SAX_TREE
1680         xmlGenericError(xmlGenericErrorContext,
1681             &quot;adding child %s to %s\n&quot;, name, parent-&gt;name);
1682 #endif
1683         xmlAddChild(parent, ret);
1684     } else {
1685 #ifdef DEBUG_SAX_TREE
1686         xmlGenericError(xmlGenericErrorContext,
1687             &quot;adding sibling %s to &quot;, name);
1688         xmlDebugDumpOneNode(stderr, parent, 0);
1689 #endif
1690         xmlAddSibling(parent, ret);
1691     }
1692     }
1693 
1694     /*
1695      * Insert all the defaulted attributes from the DTD especially namespaces
1696      */
1697     if ((!ctxt-&gt;html) &amp;&amp;
1698     ((ctxt-&gt;myDoc-&gt;intSubset != NULL) ||
1699      (ctxt-&gt;myDoc-&gt;extSubset != NULL))) {
1700     xmlCheckDefaultedAttributes(ctxt, name, prefix, atts);
1701     }
1702 
1703     /*
1704      * process all the attributes whose name start with &quot;xmlns&quot;
1705      */
1706     if (atts != NULL) {
1707         i = 0;
1708     att = atts[i++];
1709     value = atts[i++];
1710     if (!ctxt-&gt;html) {
1711         while ((att != NULL) &amp;&amp; (value != NULL)) {
1712         if ((att[0] == &#39;x&#39;) &amp;&amp; (att[1] == &#39;m&#39;) &amp;&amp; (att[2] == &#39;l&#39;) &amp;&amp;
1713             (att[3] == &#39;n&#39;) &amp;&amp; (att[4] == &#39;s&#39;))
1714             xmlSAX2AttributeInternal(ctxt, att, value, prefix);
1715 
1716         att = atts[i++];
1717         value = atts[i++];
1718         }
1719     }
1720     }
1721 
1722     /*
1723      * Search the namespace, note that since the attributes have been
1724      * processed, the local namespaces are available.
1725      */
1726     ns = xmlSearchNs(ctxt-&gt;myDoc, ret, prefix);
1727     if ((ns == NULL) &amp;&amp; (parent != NULL))
1728     ns = xmlSearchNs(ctxt-&gt;myDoc, parent, prefix);
1729     if ((prefix != NULL) &amp;&amp; (ns == NULL)) {
1730     ns = xmlNewNs(ret, NULL, prefix);
1731     xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
1732              &quot;Namespace prefix %s is not defined\n&quot;,
1733              prefix, NULL);
1734     }
1735 
1736     /*
<a name="4" id="anc4"></a><span class="line-modified">1737      * set the namespace node, making sure that if the default namspace</span>
<span class="line-modified">1738      * is unbound on a parent we simply kee it NULL</span>
1739      */
1740     if ((ns != NULL) &amp;&amp; (ns-&gt;href != NULL) &amp;&amp;
1741     ((ns-&gt;href[0] != 0) || (ns-&gt;prefix != NULL)))
1742     xmlSetNs(ret, ns);
1743 
1744     /*
1745      * process all the other attributes
1746      */
1747     if (atts != NULL) {
1748         i = 0;
1749     att = atts[i++];
1750     value = atts[i++];
1751     if (ctxt-&gt;html) {
1752         while (att != NULL) {
1753         xmlSAX2AttributeInternal(ctxt, att, value, NULL);
1754         att = atts[i++];
1755         value = atts[i++];
1756         }
1757     } else {
1758         while ((att != NULL) &amp;&amp; (value != NULL)) {
1759         if ((att[0] != &#39;x&#39;) || (att[1] != &#39;m&#39;) || (att[2] != &#39;l&#39;) ||
1760             (att[3] != &#39;n&#39;) || (att[4] != &#39;s&#39;))
1761             xmlSAX2AttributeInternal(ctxt, att, value, NULL);
1762 
1763         /*
1764          * Next ones
1765          */
1766         att = atts[i++];
1767         value = atts[i++];
1768         }
1769     }
1770     }
1771 
1772 #ifdef LIBXML_VALID_ENABLED
1773     /*
1774      * If it&#39;s the Document root, finish the DTD validation and
1775      * check the document root element for validity
1776      */
1777     if ((ctxt-&gt;validate) &amp;&amp; (ctxt-&gt;vctxt.finishDtd == XML_CTXT_FINISH_DTD_0)) {
1778     int chk;
1779 
1780     chk = xmlValidateDtdFinal(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc);
1781     if (chk &lt;= 0)
1782         ctxt-&gt;valid = 0;
1783     if (chk &lt; 0)
1784         ctxt-&gt;wellFormed = 0;
1785     ctxt-&gt;valid &amp;= xmlValidateRoot(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc);
1786     ctxt-&gt;vctxt.finishDtd = XML_CTXT_FINISH_DTD_1;
1787     }
1788 #endif /* LIBXML_VALID_ENABLED */
1789 
1790     if (prefix != NULL)
1791     xmlFree(prefix);
1792 
1793 }
1794 
1795 /**
1796  * xmlSAX2EndElement:
1797  * @ctx: the user data (XML parser context)
1798  * @name:  The element name
1799  *
1800  * called when the end of an element has been detected.
1801  */
1802 void
1803 xmlSAX2EndElement(void *ctx, const xmlChar *name ATTRIBUTE_UNUSED)
1804 {
1805     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
1806     xmlNodePtr cur;
1807 
1808     if (ctx == NULL) return;
1809     cur = ctxt-&gt;node;
1810 #ifdef DEBUG_SAX
1811     if (name == NULL)
1812         xmlGenericError(xmlGenericErrorContext, &quot;SAX.xmlSAX2EndElement(NULL)\n&quot;);
1813     else
1814     xmlGenericError(xmlGenericErrorContext, &quot;SAX.xmlSAX2EndElement(%s)\n&quot;, name);
1815 #endif
1816 
1817     /* Capture end position and add node */
1818     if (cur != NULL &amp;&amp; ctxt-&gt;record_info) {
1819       ctxt-&gt;nodeInfo-&gt;end_pos = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
1820       ctxt-&gt;nodeInfo-&gt;end_line = ctxt-&gt;input-&gt;line;
1821       ctxt-&gt;nodeInfo-&gt;node = cur;
1822       xmlParserAddNodeInfo(ctxt, ctxt-&gt;nodeInfo);
1823     }
1824     ctxt-&gt;nodemem = -1;
1825 
1826 #ifdef LIBXML_VALID_ENABLED
1827     if (ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp;
1828         ctxt-&gt;myDoc &amp;&amp; ctxt-&gt;myDoc-&gt;intSubset)
1829         ctxt-&gt;valid &amp;= xmlValidateOneElement(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc,
1830                          cur);
1831 #endif /* LIBXML_VALID_ENABLED */
1832 
1833 
1834     /*
1835      * end of parsing of this node.
1836      */
1837 #ifdef DEBUG_SAX_TREE
1838     xmlGenericError(xmlGenericErrorContext, &quot;popping(%s)\n&quot;, cur-&gt;name);
1839 #endif
1840     nodePop(ctxt);
1841 }
1842 #endif /* LIBXML_SAX1_ENABLED || LIBXML_HTML_ENABLED || LIBXML_LEGACY_ENABLED */
1843 
1844 /*
1845  * xmlSAX2TextNode:
1846  * @ctxt:  the parser context
1847  * @str:  the input string
1848  * @len: the string length
1849  *
1850  * Callback for a text node
1851  *
1852  * Returns the newly allocated string or NULL if not needed or error
1853  */
1854 static xmlNodePtr
1855 xmlSAX2TextNode(xmlParserCtxtPtr ctxt, const xmlChar *str, int len) {
1856     xmlNodePtr ret;
1857     const xmlChar *intern = NULL;
1858 
1859     /*
1860      * Allocate
1861      */
1862     if (ctxt-&gt;freeElems != NULL) {
1863     ret = ctxt-&gt;freeElems;
1864     ctxt-&gt;freeElems = ret-&gt;next;
1865     ctxt-&gt;freeElemsNr--;
1866     } else {
1867     ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
1868     }
1869     if (ret == NULL) {
1870         xmlErrMemory(ctxt, &quot;xmlSAX2Characters&quot;);
1871     return(NULL);
1872     }
1873     memset(ret, 0, sizeof(xmlNode));
1874     /*
1875      * intern the formatting blanks found between tags, or the
1876      * very short strings
1877      */
1878     if (ctxt-&gt;dictNames) {
1879         xmlChar cur = str[len];
1880 
1881     if ((len &lt; (int) (2 * sizeof(void *))) &amp;&amp;
1882         (ctxt-&gt;options &amp; XML_PARSE_COMPACT)) {
1883         /* store the string in the node overriding properties and nsDef */
1884         xmlChar *tmp = (xmlChar *) &amp;(ret-&gt;properties);
1885         memcpy(tmp, str, len);
1886         tmp[len] = 0;
1887         intern = tmp;
1888     } else if ((len &lt;= 3) &amp;&amp; ((cur == &#39;&quot;&#39;) || (cur == &#39;\&#39;&#39;) ||
1889         ((cur == &#39;&lt;&#39;) &amp;&amp; (str[len + 1] != &#39;!&#39;)))) {
1890         intern = xmlDictLookup(ctxt-&gt;dict, str, len);
1891     } else if (IS_BLANK_CH(*str) &amp;&amp; (len &lt; 60) &amp;&amp; (cur == &#39;&lt;&#39;) &amp;&amp;
1892                (str[len + 1] != &#39;!&#39;)) {
1893         int i;
1894 
1895         for (i = 1;i &lt; len;i++) {
1896         if (!IS_BLANK_CH(str[i])) goto skip;
1897         }
1898         intern = xmlDictLookup(ctxt-&gt;dict, str, len);
1899     }
1900     }
1901 skip:
1902     ret-&gt;type = XML_TEXT_NODE;
1903 
1904     ret-&gt;name = xmlStringText;
1905     if (intern == NULL) {
1906     ret-&gt;content = xmlStrndup(str, len);
1907     if (ret-&gt;content == NULL) {
1908         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2TextNode&quot;);
1909         xmlFree(ret);
1910         return(NULL);
1911     }
1912     } else
1913     ret-&gt;content = (xmlChar *) intern;
1914 
1915     if (ctxt-&gt;linenumbers) {
1916     if (ctxt-&gt;input != NULL) {
1917         if (ctxt-&gt;input-&gt;line &lt; 65535)
1918         ret-&gt;line = (short) ctxt-&gt;input-&gt;line;
1919         else {
1920             ret-&gt;line = 65535;
1921         if (ctxt-&gt;options &amp; XML_PARSE_BIG_LINES)
1922             ret-&gt;psvi = (void *) (ptrdiff_t) ctxt-&gt;input-&gt;line;
1923         }
1924     }
1925     }
1926 
1927     if ((__xmlRegisterCallbacks) &amp;&amp; (xmlRegisterNodeDefaultValue))
1928     xmlRegisterNodeDefaultValue(ret);
1929     return(ret);
1930 }
1931 
1932 #ifdef LIBXML_VALID_ENABLED
1933 /*
1934  * xmlSAX2DecodeAttrEntities:
1935  * @ctxt:  the parser context
1936  * @str:  the input string
1937  * @len: the string length
1938  *
1939  * Remove the entities from an attribute value
1940  *
1941  * Returns the newly allocated string or NULL if not needed or error
1942  */
1943 static xmlChar *
1944 xmlSAX2DecodeAttrEntities(xmlParserCtxtPtr ctxt, const xmlChar *str,
1945                           const xmlChar *end) {
1946     const xmlChar *in;
1947     xmlChar *ret;
1948 
1949     in = str;
1950     while (in &lt; end)
1951         if (*in++ == &#39;&amp;&#39;)
1952         goto decode;
1953     return(NULL);
1954 decode:
1955     ctxt-&gt;depth++;
1956     ret = xmlStringLenDecodeEntities(ctxt, str, end - str,
1957                      XML_SUBSTITUTE_REF, 0,0,0);
1958     ctxt-&gt;depth--;
1959     return(ret);
1960 }
1961 #endif /* LIBXML_VALID_ENABLED */
1962 
1963 /**
1964  * xmlSAX2AttributeNs:
1965  * @ctx: the user data (XML parser context)
1966  * @localname:  the local name of the attribute
1967  * @prefix:  the attribute namespace prefix if available
1968  * @URI:  the attribute namespace name if available
1969  * @value:  Start of the attribute value
1970  * @valueend: end of the attribute value
1971  *
1972  * Handle an attribute that has been read by the parser.
1973  * The default handling is to convert the attribute into an
1974  * DOM subtree and past it in a new xmlAttr element added to
1975  * the element.
1976  */
1977 static void
1978 xmlSAX2AttributeNs(xmlParserCtxtPtr ctxt,
1979                    const xmlChar * localname,
1980                    const xmlChar * prefix,
1981            const xmlChar * value,
1982            const xmlChar * valueend)
1983 {
1984     xmlAttrPtr ret;
1985     xmlNsPtr namespace = NULL;
1986     xmlChar *dup = NULL;
1987 
1988     /*
1989      * Note: if prefix == NULL, the attribute is not in the default namespace
1990      */
1991     if (prefix != NULL)
1992     namespace = xmlSearchNs(ctxt-&gt;myDoc, ctxt-&gt;node, prefix);
1993 
1994     /*
1995      * allocate the node
1996      */
1997     if (ctxt-&gt;freeAttrs != NULL) {
1998         ret = ctxt-&gt;freeAttrs;
1999     ctxt-&gt;freeAttrs = ret-&gt;next;
2000     ctxt-&gt;freeAttrsNr--;
2001     memset(ret, 0, sizeof(xmlAttr));
2002     ret-&gt;type = XML_ATTRIBUTE_NODE;
2003 
2004     ret-&gt;parent = ctxt-&gt;node;
2005     ret-&gt;doc = ctxt-&gt;myDoc;
2006     ret-&gt;ns = namespace;
2007 
2008     if (ctxt-&gt;dictNames)
2009         ret-&gt;name = localname;
2010     else
2011         ret-&gt;name = xmlStrdup(localname);
2012 
<a name="5" id="anc5"></a><span class="line-modified">2013         /* link at the end to preserv order, TODO speed up with a last */</span>
2014     if (ctxt-&gt;node-&gt;properties == NULL) {
2015         ctxt-&gt;node-&gt;properties = ret;
2016     } else {
2017         xmlAttrPtr prev = ctxt-&gt;node-&gt;properties;
2018 
2019         while (prev-&gt;next != NULL) prev = prev-&gt;next;
2020         prev-&gt;next = ret;
2021         ret-&gt;prev = prev;
2022     }
2023 
2024     if ((__xmlRegisterCallbacks) &amp;&amp; (xmlRegisterNodeDefaultValue))
2025         xmlRegisterNodeDefaultValue((xmlNodePtr)ret);
2026     } else {
2027     if (ctxt-&gt;dictNames)
2028         ret = xmlNewNsPropEatName(ctxt-&gt;node, namespace,
2029                                   (xmlChar *) localname, NULL);
2030     else
2031         ret = xmlNewNsProp(ctxt-&gt;node, namespace, localname, NULL);
2032     if (ret == NULL) {
2033         xmlErrMemory(ctxt, &quot;xmlSAX2AttributeNs&quot;);
2034         return;
2035     }
2036     }
2037 
2038     if ((ctxt-&gt;replaceEntities == 0) &amp;&amp; (!ctxt-&gt;html)) {
2039     xmlNodePtr tmp;
2040 
2041     /*
2042      * We know that if there is an entity reference, then
2043      * the string has been dup&#39;ed and terminates with 0
2044      * otherwise with &#39; or &quot;
2045      */
2046     if (*valueend != 0) {
2047         tmp = xmlSAX2TextNode(ctxt, value, valueend - value);
2048         ret-&gt;children = tmp;
2049         ret-&gt;last = tmp;
2050         if (tmp != NULL) {
2051         tmp-&gt;doc = ret-&gt;doc;
2052         tmp-&gt;parent = (xmlNodePtr) ret;
2053         }
2054     } else {
2055         ret-&gt;children = xmlStringLenGetNodeList(ctxt-&gt;myDoc, value,
2056                             valueend - value);
2057         tmp = ret-&gt;children;
2058         while (tmp != NULL) {
2059             tmp-&gt;doc = ret-&gt;doc;
2060         tmp-&gt;parent = (xmlNodePtr) ret;
2061         if (tmp-&gt;next == NULL)
2062             ret-&gt;last = tmp;
2063         tmp = tmp-&gt;next;
2064         }
2065     }
2066     } else if (value != NULL) {
2067     xmlNodePtr tmp;
2068 
2069     tmp = xmlSAX2TextNode(ctxt, value, valueend - value);
2070     ret-&gt;children = tmp;
2071     ret-&gt;last = tmp;
2072     if (tmp != NULL) {
2073         tmp-&gt;doc = ret-&gt;doc;
2074         tmp-&gt;parent = (xmlNodePtr) ret;
2075     }
2076     }
2077 
2078 #ifdef LIBXML_VALID_ENABLED
2079     if ((!ctxt-&gt;html) &amp;&amp; ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp;
2080         ctxt-&gt;myDoc &amp;&amp; ctxt-&gt;myDoc-&gt;intSubset) {
2081     /*
2082      * If we don&#39;t substitute entities, the validation should be
2083      * done on a value with replaced entities anyway.
2084      */
2085         if (!ctxt-&gt;replaceEntities) {
2086         dup = xmlSAX2DecodeAttrEntities(ctxt, value, valueend);
2087         if (dup == NULL) {
2088             if (*valueend == 0) {
2089             ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
2090                     ctxt-&gt;myDoc, ctxt-&gt;node, ret, value);
2091         } else {
2092             /*
2093              * That should already be normalized.
2094              * cheaper to finally allocate here than duplicate
2095              * entry points in the full validation code
2096              */
2097             dup = xmlStrndup(value, valueend - value);
2098 
2099             ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
2100                     ctxt-&gt;myDoc, ctxt-&gt;node, ret, dup);
2101         }
2102         } else {
2103             /*
2104          * dup now contains a string of the flattened attribute
<a name="6" id="anc6"></a><span class="line-modified">2105          * content with entities substitued. Check if we need to</span>
2106          * apply an extra layer of normalization.
2107          * It need to be done twice ... it&#39;s an extra burden related
2108          * to the ability to keep references in attributes
2109          */
2110         if (ctxt-&gt;attsSpecial != NULL) {
2111             xmlChar *nvalnorm;
2112             xmlChar fn[50];
2113             xmlChar *fullname;
2114 
2115             fullname = xmlBuildQName(localname, prefix, fn, 50);
2116             if (fullname != NULL) {
2117             ctxt-&gt;vctxt.valid = 1;
2118                 nvalnorm = xmlValidCtxtNormalizeAttributeValue(
2119                              &amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc,
2120                      ctxt-&gt;node, fullname, dup);
2121             if (ctxt-&gt;vctxt.valid != 1)
2122                 ctxt-&gt;valid = 0;
2123 
2124             if ((fullname != fn) &amp;&amp; (fullname != localname))
2125                 xmlFree(fullname);
2126             if (nvalnorm != NULL) {
2127                 xmlFree(dup);
2128                 dup = nvalnorm;
2129             }
2130             }
2131         }
2132 
2133         ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
2134                     ctxt-&gt;myDoc, ctxt-&gt;node, ret, dup);
2135         }
2136     } else {
2137         /*
<a name="7" id="anc7"></a><span class="line-modified">2138          * if entities already have been substitued, then</span>
2139          * the attribute as passed is already normalized
2140          */
2141         dup = xmlStrndup(value, valueend - value);
2142 
2143         ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
2144                                  ctxt-&gt;myDoc, ctxt-&gt;node, ret, dup);
2145     }
2146     } else
2147 #endif /* LIBXML_VALID_ENABLED */
2148            if (((ctxt-&gt;loadsubset &amp; XML_SKIP_IDS) == 0) &amp;&amp;
2149            (((ctxt-&gt;replaceEntities == 0) &amp;&amp; (ctxt-&gt;external != 2)) ||
2150             ((ctxt-&gt;replaceEntities != 0) &amp;&amp; (ctxt-&gt;inSubset == 0)))) {
2151         /*
2152      * when validating, the ID registration is done at the attribute
2153      * validation level. Otherwise we have to do specific handling here.
2154      */
2155         if ((prefix == ctxt-&gt;str_xml) &amp;&amp;
2156                (localname[0] == &#39;i&#39;) &amp;&amp; (localname[1] == &#39;d&#39;) &amp;&amp;
2157            (localname[2] == 0)) {
2158         /*
2159          * Add the xml:id value
2160          *
2161          * Open issue: normalization of the value.
2162          */
2163         if (dup == NULL)
2164             dup = xmlStrndup(value, valueend - value);
2165 #if defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_DOCB_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
2166 #ifdef LIBXML_VALID_ENABLED
2167         if (xmlValidateNCName(dup, 1) != 0) {
2168             xmlErrValid(ctxt, XML_DTD_XMLID_VALUE,
2169               &quot;xml:id : attribute value %s is not an NCName\n&quot;,
2170                 (const char *) dup, NULL);
2171         }
2172 #endif
2173 #endif
2174         xmlAddID(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc, dup, ret);
2175     } else if (xmlIsID(ctxt-&gt;myDoc, ctxt-&gt;node, ret)) {
2176         /* might be worth duplicate entry points and not copy */
2177         if (dup == NULL)
2178             dup = xmlStrndup(value, valueend - value);
2179         xmlAddID(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc, dup, ret);
2180     } else if (xmlIsRef(ctxt-&gt;myDoc, ctxt-&gt;node, ret)) {
2181         if (dup == NULL)
2182             dup = xmlStrndup(value, valueend - value);
2183         xmlAddRef(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc, dup, ret);
2184     }
2185     }
2186     if (dup != NULL)
2187     xmlFree(dup);
2188 }
2189 
2190 /**
2191  * xmlSAX2StartElementNs:
2192  * @ctx:  the user data (XML parser context)
2193  * @localname:  the local name of the element
2194  * @prefix:  the element namespace prefix if available
2195  * @URI:  the element namespace name if available
2196  * @nb_namespaces:  number of namespace definitions on that node
2197  * @namespaces:  pointer to the array of prefix/URI pairs namespace definitions
2198  * @nb_attributes:  the number of attributes on that node
2199  * @nb_defaulted:  the number of defaulted attributes.
2200  * @attributes:  pointer to the array of (localname/prefix/URI/value/end)
2201  *               attribute values.
2202  *
2203  * SAX2 callback when an element start has been detected by the parser.
2204  * It provides the namespace informations for the element, as well as
2205  * the new namespace declarations on the element.
2206  */
2207 void
2208 xmlSAX2StartElementNs(void *ctx,
2209                       const xmlChar *localname,
2210               const xmlChar *prefix,
2211               const xmlChar *URI,
2212               int nb_namespaces,
2213               const xmlChar **namespaces,
2214               int nb_attributes,
2215               int nb_defaulted,
2216               const xmlChar **attributes)
2217 {
2218     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
2219     xmlNodePtr ret;
2220     xmlNodePtr parent;
2221     xmlNsPtr last = NULL, ns;
2222     const xmlChar *uri, *pref;
2223     xmlChar *lname = NULL;
2224     int i, j;
2225 
2226     if (ctx == NULL) return;
2227     parent = ctxt-&gt;node;
2228     /*
2229      * First check on validity:
2230      */
2231     if (ctxt-&gt;validate &amp;&amp; (ctxt-&gt;myDoc-&gt;extSubset == NULL) &amp;&amp;
2232         ((ctxt-&gt;myDoc-&gt;intSubset == NULL) ||
2233      ((ctxt-&gt;myDoc-&gt;intSubset-&gt;notations == NULL) &amp;&amp;
2234       (ctxt-&gt;myDoc-&gt;intSubset-&gt;elements == NULL) &amp;&amp;
2235       (ctxt-&gt;myDoc-&gt;intSubset-&gt;attributes == NULL) &amp;&amp;
2236       (ctxt-&gt;myDoc-&gt;intSubset-&gt;entities == NULL)))) {
2237     xmlErrValid(ctxt, XML_DTD_NO_DTD,
2238       &quot;Validation failed: no DTD found !&quot;, NULL, NULL);
2239     ctxt-&gt;validate = 0;
2240     }
2241 
2242     /*
2243      * Take care of the rare case of an undefined namespace prefix
2244      */
2245     if ((prefix != NULL) &amp;&amp; (URI == NULL)) {
2246         if (ctxt-&gt;dictNames) {
2247         const xmlChar *fullname;
2248 
2249         fullname = xmlDictQLookup(ctxt-&gt;dict, prefix, localname);
2250         if (fullname != NULL)
2251             localname = fullname;
2252     } else {
2253         lname = xmlBuildQName(localname, prefix, NULL, 0);
2254     }
2255     }
2256     /*
2257      * allocate the node
2258      */
2259     if (ctxt-&gt;freeElems != NULL) {
2260         ret = ctxt-&gt;freeElems;
2261     ctxt-&gt;freeElems = ret-&gt;next;
2262     ctxt-&gt;freeElemsNr--;
2263     memset(ret, 0, sizeof(xmlNode));
2264         ret-&gt;doc = ctxt-&gt;myDoc;
2265     ret-&gt;type = XML_ELEMENT_NODE;
2266 
2267     if (ctxt-&gt;dictNames)
2268         ret-&gt;name = localname;
2269     else {
2270         if (lname == NULL)
2271         ret-&gt;name = xmlStrdup(localname);
2272         else
2273             ret-&gt;name = lname;
2274         if (ret-&gt;name == NULL) {
2275             xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartElementNs&quot;);
2276         return;
2277         }
2278     }
2279     if ((__xmlRegisterCallbacks) &amp;&amp; (xmlRegisterNodeDefaultValue))
2280         xmlRegisterNodeDefaultValue(ret);
2281     } else {
2282     if (ctxt-&gt;dictNames)
2283         ret = xmlNewDocNodeEatName(ctxt-&gt;myDoc, NULL,
2284                                    (xmlChar *) localname, NULL);
2285     else if (lname == NULL)
2286         ret = xmlNewDocNode(ctxt-&gt;myDoc, NULL, localname, NULL);
2287     else
2288         ret = xmlNewDocNodeEatName(ctxt-&gt;myDoc, NULL,
2289                                    (xmlChar *) lname, NULL);
2290     if (ret == NULL) {
2291         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartElementNs&quot;);
2292         return;
2293     }
2294     }
2295     if (ctxt-&gt;linenumbers) {
2296     if (ctxt-&gt;input != NULL) {
2297         if (ctxt-&gt;input-&gt;line &lt; 65535)
2298         ret-&gt;line = (short) ctxt-&gt;input-&gt;line;
2299         else
2300             ret-&gt;line = 65535;
2301     }
2302     }
2303 
2304     if (parent == NULL) {
2305         xmlAddChild((xmlNodePtr) ctxt-&gt;myDoc, (xmlNodePtr) ret);
2306     }
2307     /*
2308      * Build the namespace list
2309      */
2310     for (i = 0,j = 0;j &lt; nb_namespaces;j++) {
2311         pref = namespaces[i++];
2312     uri = namespaces[i++];
2313     ns = xmlNewNs(NULL, uri, pref);
2314     if (ns != NULL) {
2315         if (last == NULL) {
2316             ret-&gt;nsDef = last = ns;
2317         } else {
2318             last-&gt;next = ns;
2319         last = ns;
2320         }
2321         if ((URI != NULL) &amp;&amp; (prefix == pref))
2322         ret-&gt;ns = ns;
2323     } else {
2324             /*
2325              * any out of memory error would already have been raised
2326              * but we can&#39;t be guaranteed it&#39;s the actual error due to the
2327              * API, best is to skip in this case
2328              */
2329         continue;
2330     }
2331 #ifdef LIBXML_VALID_ENABLED
2332     if ((!ctxt-&gt;html) &amp;&amp; ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp;
2333         ctxt-&gt;myDoc &amp;&amp; ctxt-&gt;myDoc-&gt;intSubset) {
2334         ctxt-&gt;valid &amp;= xmlValidateOneNamespace(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc,
2335                                                ret, prefix, ns, uri);
2336     }
2337 #endif /* LIBXML_VALID_ENABLED */
2338     }
2339     ctxt-&gt;nodemem = -1;
2340 
2341     /*
2342      * We are parsing a new node.
2343      */
2344     if (nodePush(ctxt, ret) &lt; 0) {
2345         xmlUnlinkNode(ret);
2346         xmlFreeNode(ret);
2347         return;
2348     }
2349 
2350     /*
2351      * Link the child element
2352      */
2353     if (parent != NULL) {
2354         if (parent-&gt;type == XML_ELEMENT_NODE) {
2355         xmlAddChild(parent, ret);
2356     } else {
2357         xmlAddSibling(parent, ret);
2358     }
2359     }
2360 
2361     /*
2362      * Insert the defaulted attributes from the DTD only if requested:
2363      */
2364     if ((nb_defaulted != 0) &amp;&amp;
2365         ((ctxt-&gt;loadsubset &amp; XML_COMPLETE_ATTRS) == 0))
2366     nb_attributes -= nb_defaulted;
2367 
2368     /*
2369      * Search the namespace if it wasn&#39;t already found
2370      * Note that, if prefix is NULL, this searches for the default Ns
2371      */
2372     if ((URI != NULL) &amp;&amp; (ret-&gt;ns == NULL)) {
2373         ret-&gt;ns = xmlSearchNs(ctxt-&gt;myDoc, parent, prefix);
2374     if ((ret-&gt;ns == NULL) &amp;&amp; (xmlStrEqual(prefix, BAD_CAST &quot;xml&quot;))) {
2375         ret-&gt;ns = xmlSearchNs(ctxt-&gt;myDoc, ret, prefix);
2376     }
2377     if (ret-&gt;ns == NULL) {
2378         ns = xmlNewNs(ret, NULL, prefix);
2379         if (ns == NULL) {
2380 
2381             xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2StartElementNs&quot;);
2382         return;
2383         }
2384             if (prefix != NULL)
2385                 xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
2386                              &quot;Namespace prefix %s was not found\n&quot;,
2387                              prefix, NULL);
2388             else
2389                 xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
2390                              &quot;Namespace default prefix was not found\n&quot;,
2391                              NULL, NULL);
2392     }
2393     }
2394 
2395     /*
2396      * process all the other attributes
2397      */
2398     if (nb_attributes &gt; 0) {
2399         for (j = 0,i = 0;i &lt; nb_attributes;i++,j+=5) {
2400         /*
<a name="8" id="anc8"></a><span class="line-modified">2401          * Handle the rare case of an undefined atribute prefix</span>
2402          */
2403         if ((attributes[j+1] != NULL) &amp;&amp; (attributes[j+2] == NULL)) {
2404         if (ctxt-&gt;dictNames) {
2405             const xmlChar *fullname;
2406 
2407             fullname = xmlDictQLookup(ctxt-&gt;dict, attributes[j+1],
2408                                       attributes[j]);
2409             if (fullname != NULL) {
2410             xmlSAX2AttributeNs(ctxt, fullname, NULL,
2411                                attributes[j+3], attributes[j+4]);
2412                 continue;
2413             }
2414         } else {
2415             lname = xmlBuildQName(attributes[j], attributes[j+1],
2416                                   NULL, 0);
2417             if (lname != NULL) {
2418             xmlSAX2AttributeNs(ctxt, lname, NULL,
2419                                attributes[j+3], attributes[j+4]);
2420             xmlFree(lname);
2421                 continue;
2422             }
2423         }
2424         }
2425         xmlSAX2AttributeNs(ctxt, attributes[j], attributes[j+1],
2426                    attributes[j+3], attributes[j+4]);
2427     }
2428     }
2429 
2430 #ifdef LIBXML_VALID_ENABLED
2431     /*
2432      * If it&#39;s the Document root, finish the DTD validation and
2433      * check the document root element for validity
2434      */
2435     if ((ctxt-&gt;validate) &amp;&amp; (ctxt-&gt;vctxt.finishDtd == XML_CTXT_FINISH_DTD_0)) {
2436     int chk;
2437 
2438     chk = xmlValidateDtdFinal(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc);
2439     if (chk &lt;= 0)
2440         ctxt-&gt;valid = 0;
2441     if (chk &lt; 0)
2442         ctxt-&gt;wellFormed = 0;
2443     ctxt-&gt;valid &amp;= xmlValidateRoot(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc);
2444     ctxt-&gt;vctxt.finishDtd = XML_CTXT_FINISH_DTD_1;
2445     }
2446 #endif /* LIBXML_VALID_ENABLED */
2447 }
2448 
2449 /**
2450  * xmlSAX2EndElementNs:
2451  * @ctx:  the user data (XML parser context)
2452  * @localname:  the local name of the element
2453  * @prefix:  the element namespace prefix if available
2454  * @URI:  the element namespace name if available
2455  *
2456  * SAX2 callback when an element end has been detected by the parser.
2457  * It provides the namespace informations for the element.
2458  */
2459 void
2460 xmlSAX2EndElementNs(void *ctx,
2461                     const xmlChar * localname ATTRIBUTE_UNUSED,
2462                     const xmlChar * prefix ATTRIBUTE_UNUSED,
2463             const xmlChar * URI ATTRIBUTE_UNUSED)
2464 {
2465     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
2466     xmlParserNodeInfo node_info;
2467     xmlNodePtr cur;
2468 
2469     if (ctx == NULL) return;
2470     cur = ctxt-&gt;node;
2471     /* Capture end position and add node */
2472     if ((ctxt-&gt;record_info) &amp;&amp; (cur != NULL)) {
2473         node_info.end_pos = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
2474         node_info.end_line = ctxt-&gt;input-&gt;line;
2475         node_info.node = cur;
2476         xmlParserAddNodeInfo(ctxt, &amp;node_info);
2477     }
2478     ctxt-&gt;nodemem = -1;
2479 
2480 #ifdef LIBXML_VALID_ENABLED
2481     if (ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp;
2482         ctxt-&gt;myDoc &amp;&amp; ctxt-&gt;myDoc-&gt;intSubset)
2483         ctxt-&gt;valid &amp;= xmlValidateOneElement(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc, cur);
2484 #endif /* LIBXML_VALID_ENABLED */
2485 
2486     /*
2487      * end of parsing of this node.
2488      */
2489     nodePop(ctxt);
2490 }
2491 
2492 /**
2493  * xmlSAX2Reference:
2494  * @ctx: the user data (XML parser context)
2495  * @name:  The entity name
2496  *
2497  * called when an entity xmlSAX2Reference is detected.
2498  */
2499 void
2500 xmlSAX2Reference(void *ctx, const xmlChar *name)
2501 {
2502     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
2503     xmlNodePtr ret;
2504 
2505     if (ctx == NULL) return;
2506 #ifdef DEBUG_SAX
2507     xmlGenericError(xmlGenericErrorContext,
2508         &quot;SAX.xmlSAX2Reference(%s)\n&quot;, name);
2509 #endif
2510     if (name[0] == &#39;#&#39;)
2511     ret = xmlNewCharRef(ctxt-&gt;myDoc, name);
2512     else
2513     ret = xmlNewReference(ctxt-&gt;myDoc, name);
2514 #ifdef DEBUG_SAX_TREE
2515     xmlGenericError(xmlGenericErrorContext,
2516         &quot;add xmlSAX2Reference %s to %s \n&quot;, name, ctxt-&gt;node-&gt;name);
2517 #endif
2518     if (xmlAddChild(ctxt-&gt;node, ret) == NULL) {
2519         xmlFreeNode(ret);
2520     }
2521 }
2522 
2523 /**
2524  * xmlSAX2Characters:
2525  * @ctx: the user data (XML parser context)
2526  * @ch:  a xmlChar string
2527  * @len: the number of xmlChar
2528  *
2529  * receiving some chars from the parser.
2530  */
2531 void
2532 xmlSAX2Characters(void *ctx, const xmlChar *ch, int len)
2533 {
2534     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
2535     xmlNodePtr lastChild;
2536 
2537     if (ctx == NULL) return;
2538 #ifdef DEBUG_SAX
2539     xmlGenericError(xmlGenericErrorContext,
2540         &quot;SAX.xmlSAX2Characters(%.30s, %d)\n&quot;, ch, len);
2541 #endif
2542     /*
2543      * Handle the data if any. If there is no child
2544      * add it as content, otherwise if the last child is text,
2545      * concatenate it, else create a new node of type text.
2546      */
2547 
2548     if (ctxt-&gt;node == NULL) {
2549 #ifdef DEBUG_SAX_TREE
2550     xmlGenericError(xmlGenericErrorContext,
2551         &quot;add chars: ctxt-&gt;node == NULL !\n&quot;);
2552 #endif
2553         return;
2554     }
2555     lastChild = ctxt-&gt;node-&gt;last;
2556 #ifdef DEBUG_SAX_TREE
2557     xmlGenericError(xmlGenericErrorContext,
2558         &quot;add chars to %s \n&quot;, ctxt-&gt;node-&gt;name);
2559 #endif
2560 
2561     /*
2562      * Here we needed an accelerator mechanism in case of very large
2563      * elements. Use an attribute in the structure !!!
2564      */
2565     if (lastChild == NULL) {
2566         lastChild = xmlSAX2TextNode(ctxt, ch, len);
2567     if (lastChild != NULL) {
2568         ctxt-&gt;node-&gt;children = lastChild;
2569         ctxt-&gt;node-&gt;last = lastChild;
2570         lastChild-&gt;parent = ctxt-&gt;node;
2571         lastChild-&gt;doc = ctxt-&gt;node-&gt;doc;
2572         ctxt-&gt;nodelen = len;
2573         ctxt-&gt;nodemem = len + 1;
2574     } else {
2575         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2Characters&quot;);
2576         return;
2577     }
2578     } else {
2579     int coalesceText = (lastChild != NULL) &amp;&amp;
2580         (lastChild-&gt;type == XML_TEXT_NODE) &amp;&amp;
2581         (lastChild-&gt;name == xmlStringText);
2582     if ((coalesceText) &amp;&amp; (ctxt-&gt;nodemem != 0)) {
2583         /*
2584          * The whole point of maintaining nodelen and nodemem,
2585          * xmlTextConcat is too costly, i.e. compute length,
2586          * reallocate a new buffer, move data, append ch. Here
<a name="9" id="anc9"></a><span class="line-modified">2587          * We try to minimaze realloc() uses and avoid copying</span>
2588          * and recomputing length over and over.
2589          */
2590         if (lastChild-&gt;content == (xmlChar *)&amp;(lastChild-&gt;properties)) {
2591         lastChild-&gt;content = xmlStrdup(lastChild-&gt;content);
2592         lastChild-&gt;properties = NULL;
2593         } else if ((ctxt-&gt;nodemem == ctxt-&gt;nodelen + 1) &amp;&amp;
2594                    (xmlDictOwns(ctxt-&gt;dict, lastChild-&gt;content))) {
2595         lastChild-&gt;content = xmlStrdup(lastChild-&gt;content);
2596         }
2597         if (lastChild-&gt;content == NULL) {
2598         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2Characters: xmlStrdup returned NULL&quot;);
2599         return;
2600         }
2601             if (((size_t)ctxt-&gt;nodelen + (size_t)len &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
2602                 ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
2603                 xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2Characters: huge text node&quot;);
2604                 return;
2605             }
2606         if ((size_t)ctxt-&gt;nodelen &gt; SIZE_T_MAX - (size_t)len ||
2607             (size_t)ctxt-&gt;nodemem + (size_t)len &gt; SIZE_T_MAX / 2) {
2608                 xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2Characters overflow prevented&quot;);
2609                 return;
2610         }
2611         if (ctxt-&gt;nodelen + len &gt;= ctxt-&gt;nodemem) {
2612         xmlChar *newbuf;
2613         size_t size;
2614 
2615         size = ctxt-&gt;nodemem + len;
2616         size *= 2;
2617                 newbuf = (xmlChar *) xmlRealloc(lastChild-&gt;content,size);
2618         if (newbuf == NULL) {
2619             xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2Characters&quot;);
2620             return;
2621         }
2622         ctxt-&gt;nodemem = size;
2623         lastChild-&gt;content = newbuf;
2624         }
2625         memcpy(&amp;lastChild-&gt;content[ctxt-&gt;nodelen], ch, len);
2626         ctxt-&gt;nodelen += len;
2627         lastChild-&gt;content[ctxt-&gt;nodelen] = 0;
2628     } else if (coalesceText) {
2629         if (xmlTextConcat(lastChild, ch, len)) {
2630         xmlSAX2ErrMemory(ctxt, &quot;xmlSAX2Characters&quot;);
2631         }
2632         if (ctxt-&gt;node-&gt;children != NULL) {
2633         ctxt-&gt;nodelen = xmlStrlen(lastChild-&gt;content);
2634         ctxt-&gt;nodemem = ctxt-&gt;nodelen + 1;
2635         }
2636     } else {
2637         /* Mixed content, first time */
2638         lastChild = xmlSAX2TextNode(ctxt, ch, len);
2639         if (lastChild != NULL) {
2640         xmlAddChild(ctxt-&gt;node, lastChild);
2641         if (ctxt-&gt;node-&gt;children != NULL) {
2642             ctxt-&gt;nodelen = len;
2643             ctxt-&gt;nodemem = len + 1;
2644         }
2645         }
2646     }
2647     }
2648 }
2649 
2650 /**
2651  * xmlSAX2IgnorableWhitespace:
2652  * @ctx: the user data (XML parser context)
2653  * @ch:  a xmlChar string
2654  * @len: the number of xmlChar
2655  *
2656  * receiving some ignorable whitespaces from the parser.
2657  * UNUSED: by default the DOM building will use xmlSAX2Characters
2658  */
2659 void
2660 xmlSAX2IgnorableWhitespace(void *ctx ATTRIBUTE_UNUSED, const xmlChar *ch ATTRIBUTE_UNUSED, int len ATTRIBUTE_UNUSED)
2661 {
2662     /* xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx; */
2663 #ifdef DEBUG_SAX
2664     xmlGenericError(xmlGenericErrorContext,
2665         &quot;SAX.xmlSAX2IgnorableWhitespace(%.30s, %d)\n&quot;, ch, len);
2666 #endif
2667 }
2668 
2669 /**
2670  * xmlSAX2ProcessingInstruction:
2671  * @ctx: the user data (XML parser context)
2672  * @target:  the target name
2673  * @data: the PI data&#39;s
2674  *
2675  * A processing instruction has been parsed.
2676  */
2677 void
2678 xmlSAX2ProcessingInstruction(void *ctx, const xmlChar *target,
2679                       const xmlChar *data)
2680 {
2681     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
2682     xmlNodePtr ret;
2683     xmlNodePtr parent;
2684 
2685     if (ctx == NULL) return;
2686     parent = ctxt-&gt;node;
2687 #ifdef DEBUG_SAX
2688     xmlGenericError(xmlGenericErrorContext,
2689         &quot;SAX.xmlSAX2ProcessingInstruction(%s, %s)\n&quot;, target, data);
2690 #endif
2691 
2692     ret = xmlNewDocPI(ctxt-&gt;myDoc, target, data);
2693     if (ret == NULL) return;
2694 
2695     if (ctxt-&gt;linenumbers) {
2696     if (ctxt-&gt;input != NULL) {
2697         if (ctxt-&gt;input-&gt;line &lt; 65535)
2698         ret-&gt;line = (short) ctxt-&gt;input-&gt;line;
2699         else
2700             ret-&gt;line = 65535;
2701     }
2702     }
2703     if (ctxt-&gt;inSubset == 1) {
2704     xmlAddChild((xmlNodePtr) ctxt-&gt;myDoc-&gt;intSubset, ret);
2705     return;
2706     } else if (ctxt-&gt;inSubset == 2) {
2707     xmlAddChild((xmlNodePtr) ctxt-&gt;myDoc-&gt;extSubset, ret);
2708     return;
2709     }
2710     if (parent == NULL) {
2711 #ifdef DEBUG_SAX_TREE
2712         xmlGenericError(xmlGenericErrorContext,
2713             &quot;Setting PI %s as root\n&quot;, target);
2714 #endif
2715         xmlAddChild((xmlNodePtr) ctxt-&gt;myDoc, (xmlNodePtr) ret);
2716     return;
2717     }
2718     if (parent-&gt;type == XML_ELEMENT_NODE) {
2719 #ifdef DEBUG_SAX_TREE
2720     xmlGenericError(xmlGenericErrorContext,
2721         &quot;adding PI %s child to %s\n&quot;, target, parent-&gt;name);
2722 #endif
2723     xmlAddChild(parent, ret);
2724     } else {
2725 #ifdef DEBUG_SAX_TREE
2726     xmlGenericError(xmlGenericErrorContext,
2727         &quot;adding PI %s sibling to &quot;, target);
2728     xmlDebugDumpOneNode(stderr, parent, 0);
2729 #endif
2730     xmlAddSibling(parent, ret);
2731     }
2732 }
2733 
2734 /**
2735  * xmlSAX2Comment:
2736  * @ctx: the user data (XML parser context)
2737  * @value:  the xmlSAX2Comment content
2738  *
2739  * A xmlSAX2Comment has been parsed.
2740  */
2741 void
2742 xmlSAX2Comment(void *ctx, const xmlChar *value)
2743 {
2744     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
2745     xmlNodePtr ret;
2746     xmlNodePtr parent;
2747 
2748     if (ctx == NULL) return;
2749     parent = ctxt-&gt;node;
2750 #ifdef DEBUG_SAX
2751     xmlGenericError(xmlGenericErrorContext, &quot;SAX.xmlSAX2Comment(%s)\n&quot;, value);
2752 #endif
2753     ret = xmlNewDocComment(ctxt-&gt;myDoc, value);
2754     if (ret == NULL) return;
2755     if (ctxt-&gt;linenumbers) {
2756     if (ctxt-&gt;input != NULL) {
2757         if (ctxt-&gt;input-&gt;line &lt; 65535)
2758         ret-&gt;line = (short) ctxt-&gt;input-&gt;line;
2759         else
2760             ret-&gt;line = 65535;
2761     }
2762     }
2763 
2764     if (ctxt-&gt;inSubset == 1) {
2765     xmlAddChild((xmlNodePtr) ctxt-&gt;myDoc-&gt;intSubset, ret);
2766     return;
2767     } else if (ctxt-&gt;inSubset == 2) {
2768     xmlAddChild((xmlNodePtr) ctxt-&gt;myDoc-&gt;extSubset, ret);
2769     return;
2770     }
2771     if (parent == NULL) {
2772 #ifdef DEBUG_SAX_TREE
2773         xmlGenericError(xmlGenericErrorContext,
2774             &quot;Setting xmlSAX2Comment as root\n&quot;);
2775 #endif
2776         xmlAddChild((xmlNodePtr) ctxt-&gt;myDoc, (xmlNodePtr) ret);
2777     return;
2778     }
2779     if (parent-&gt;type == XML_ELEMENT_NODE) {
2780 #ifdef DEBUG_SAX_TREE
2781     xmlGenericError(xmlGenericErrorContext,
2782         &quot;adding xmlSAX2Comment child to %s\n&quot;, parent-&gt;name);
2783 #endif
2784     xmlAddChild(parent, ret);
2785     } else {
2786 #ifdef DEBUG_SAX_TREE
2787     xmlGenericError(xmlGenericErrorContext,
2788         &quot;adding xmlSAX2Comment sibling to &quot;);
2789     xmlDebugDumpOneNode(stderr, parent, 0);
2790 #endif
2791     xmlAddSibling(parent, ret);
2792     }
2793 }
2794 
2795 /**
2796  * xmlSAX2CDataBlock:
2797  * @ctx: the user data (XML parser context)
2798  * @value:  The pcdata content
2799  * @len:  the block length
2800  *
2801  * called when a pcdata block has been parsed
2802  */
2803 void
2804 xmlSAX2CDataBlock(void *ctx, const xmlChar *value, int len)
2805 {
2806     xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
2807     xmlNodePtr ret, lastChild;
2808 
2809     if (ctx == NULL) return;
2810 #ifdef DEBUG_SAX
2811     xmlGenericError(xmlGenericErrorContext,
2812         &quot;SAX.pcdata(%.10s, %d)\n&quot;, value, len);
2813 #endif
2814     lastChild = xmlGetLastChild(ctxt-&gt;node);
2815 #ifdef DEBUG_SAX_TREE
2816     xmlGenericError(xmlGenericErrorContext,
2817         &quot;add chars to %s \n&quot;, ctxt-&gt;node-&gt;name);
2818 #endif
2819     if ((lastChild != NULL) &amp;&amp;
2820         (lastChild-&gt;type == XML_CDATA_SECTION_NODE)) {
2821     xmlTextConcat(lastChild, value, len);
2822     } else {
2823     ret = xmlNewCDataBlock(ctxt-&gt;myDoc, value, len);
2824     if (xmlAddChild(ctxt-&gt;node, ret) == NULL)
2825         xmlFreeNode(ret);
2826     }
2827 }
2828 
2829 static int xmlSAX2DefaultVersionValue = 2;
2830 
2831 #ifdef LIBXML_SAX1_ENABLED
2832 /**
2833  * xmlSAXDefaultVersion:
2834  * @version:  the version, 1 or 2
2835  *
2836  * Set the default version of SAX used globally by the library.
2837  * By default, during initialization the default is set to 2.
2838  * Note that it is generally a better coding style to use
2839  * xmlSAXVersion() to set up the version explicitly for a given
2840  * parsing context.
2841  *
2842  * Returns the previous value in case of success and -1 in case of error.
2843  */
2844 int
2845 xmlSAXDefaultVersion(int version)
2846 {
2847     int ret = xmlSAX2DefaultVersionValue;
2848 
2849     if ((version != 1) &amp;&amp; (version != 2))
2850         return(-1);
2851     xmlSAX2DefaultVersionValue = version;
2852     return(ret);
2853 }
2854 #endif /* LIBXML_SAX1_ENABLED */
2855 
2856 /**
2857  * xmlSAXVersion:
2858  * @hdlr:  the SAX handler
2859  * @version:  the version, 1 or 2
2860  *
2861  * Initialize the default XML SAX handler according to the version
2862  *
2863  * Returns 0 in case of success and -1 in case of error.
2864  */
2865 int
2866 xmlSAXVersion(xmlSAXHandler *hdlr, int version)
2867 {
2868     if (hdlr == NULL) return(-1);
2869     if (version == 2) {
2870     hdlr-&gt;startElement = NULL;
2871     hdlr-&gt;endElement = NULL;
2872     hdlr-&gt;startElementNs = xmlSAX2StartElementNs;
2873     hdlr-&gt;endElementNs = xmlSAX2EndElementNs;
2874     hdlr-&gt;serror = NULL;
2875     hdlr-&gt;initialized = XML_SAX2_MAGIC;
2876 #ifdef LIBXML_SAX1_ENABLED
2877     } else if (version == 1) {
2878     hdlr-&gt;startElement = xmlSAX2StartElement;
2879     hdlr-&gt;endElement = xmlSAX2EndElement;
2880     hdlr-&gt;initialized = 1;
2881 #endif /* LIBXML_SAX1_ENABLED */
2882     } else
2883         return(-1);
2884     hdlr-&gt;internalSubset = xmlSAX2InternalSubset;
2885     hdlr-&gt;externalSubset = xmlSAX2ExternalSubset;
2886     hdlr-&gt;isStandalone = xmlSAX2IsStandalone;
2887     hdlr-&gt;hasInternalSubset = xmlSAX2HasInternalSubset;
2888     hdlr-&gt;hasExternalSubset = xmlSAX2HasExternalSubset;
2889     hdlr-&gt;resolveEntity = xmlSAX2ResolveEntity;
2890     hdlr-&gt;getEntity = xmlSAX2GetEntity;
2891     hdlr-&gt;getParameterEntity = xmlSAX2GetParameterEntity;
2892     hdlr-&gt;entityDecl = xmlSAX2EntityDecl;
2893     hdlr-&gt;attributeDecl = xmlSAX2AttributeDecl;
2894     hdlr-&gt;elementDecl = xmlSAX2ElementDecl;
2895     hdlr-&gt;notationDecl = xmlSAX2NotationDecl;
2896     hdlr-&gt;unparsedEntityDecl = xmlSAX2UnparsedEntityDecl;
2897     hdlr-&gt;setDocumentLocator = xmlSAX2SetDocumentLocator;
2898     hdlr-&gt;startDocument = xmlSAX2StartDocument;
2899     hdlr-&gt;endDocument = xmlSAX2EndDocument;
2900     hdlr-&gt;reference = xmlSAX2Reference;
2901     hdlr-&gt;characters = xmlSAX2Characters;
2902     hdlr-&gt;cdataBlock = xmlSAX2CDataBlock;
2903     hdlr-&gt;ignorableWhitespace = xmlSAX2Characters;
2904     hdlr-&gt;processingInstruction = xmlSAX2ProcessingInstruction;
2905     hdlr-&gt;comment = xmlSAX2Comment;
2906     hdlr-&gt;warning = xmlParserWarning;
2907     hdlr-&gt;error = xmlParserError;
2908     hdlr-&gt;fatalError = xmlParserError;
2909 
2910     return(0);
2911 }
2912 
2913 /**
2914  * xmlSAX2InitDefaultSAXHandler:
2915  * @hdlr:  the SAX handler
2916  * @warning:  flag if non-zero sets the handler warning procedure
2917  *
2918  * Initialize the default XML SAX2 handler
2919  */
2920 void
2921 xmlSAX2InitDefaultSAXHandler(xmlSAXHandler *hdlr, int warning)
2922 {
2923     if ((hdlr == NULL) || (hdlr-&gt;initialized != 0))
2924     return;
2925 
2926     xmlSAXVersion(hdlr, xmlSAX2DefaultVersionValue);
2927     if (warning == 0)
2928     hdlr-&gt;warning = NULL;
2929     else
2930     hdlr-&gt;warning = xmlParserWarning;
2931 }
2932 
2933 /**
2934  * xmlDefaultSAXHandlerInit:
2935  *
2936  * Initialize the default SAX2 handler
2937  */
2938 void
2939 xmlDefaultSAXHandlerInit(void)
2940 {
2941 #ifdef LIBXML_SAX1_ENABLED
2942     xmlSAXVersion((xmlSAXHandlerPtr) &amp;xmlDefaultSAXHandler, 1);
2943 #endif /* LIBXML_SAX1_ENABLED */
2944 }
2945 
2946 #ifdef LIBXML_HTML_ENABLED
2947 
2948 /**
2949  * xmlSAX2InitHtmlDefaultSAXHandler:
2950  * @hdlr:  the SAX handler
2951  *
2952  * Initialize the default HTML SAX2 handler
2953  */
2954 void
2955 xmlSAX2InitHtmlDefaultSAXHandler(xmlSAXHandler *hdlr)
2956 {
2957     if ((hdlr == NULL) || (hdlr-&gt;initialized != 0))
2958     return;
2959 
2960     hdlr-&gt;internalSubset = xmlSAX2InternalSubset;
2961     hdlr-&gt;externalSubset = NULL;
2962     hdlr-&gt;isStandalone = NULL;
2963     hdlr-&gt;hasInternalSubset = NULL;
2964     hdlr-&gt;hasExternalSubset = NULL;
2965     hdlr-&gt;resolveEntity = NULL;
2966     hdlr-&gt;getEntity = xmlSAX2GetEntity;
2967     hdlr-&gt;getParameterEntity = NULL;
2968     hdlr-&gt;entityDecl = NULL;
2969     hdlr-&gt;attributeDecl = NULL;
2970     hdlr-&gt;elementDecl = NULL;
2971     hdlr-&gt;notationDecl = NULL;
2972     hdlr-&gt;unparsedEntityDecl = NULL;
2973     hdlr-&gt;setDocumentLocator = xmlSAX2SetDocumentLocator;
2974     hdlr-&gt;startDocument = xmlSAX2StartDocument;
2975     hdlr-&gt;endDocument = xmlSAX2EndDocument;
2976     hdlr-&gt;startElement = xmlSAX2StartElement;
2977     hdlr-&gt;endElement = xmlSAX2EndElement;
2978     hdlr-&gt;reference = NULL;
2979     hdlr-&gt;characters = xmlSAX2Characters;
2980     hdlr-&gt;cdataBlock = xmlSAX2CDataBlock;
2981     hdlr-&gt;ignorableWhitespace = xmlSAX2IgnorableWhitespace;
2982     hdlr-&gt;processingInstruction = xmlSAX2ProcessingInstruction;
2983     hdlr-&gt;comment = xmlSAX2Comment;
2984     hdlr-&gt;warning = xmlParserWarning;
2985     hdlr-&gt;error = xmlParserError;
2986     hdlr-&gt;fatalError = xmlParserError;
2987 
2988     hdlr-&gt;initialized = 1;
2989 }
2990 
2991 /**
2992  * htmlDefaultSAXHandlerInit:
2993  *
2994  * Initialize the default SAX handler
2995  */
2996 void
2997 htmlDefaultSAXHandlerInit(void)
2998 {
2999     xmlSAX2InitHtmlDefaultSAXHandler((xmlSAXHandlerPtr) &amp;htmlDefaultSAXHandler);
3000 }
3001 
3002 #endif /* LIBXML_HTML_ENABLED */
3003 
3004 #ifdef LIBXML_DOCB_ENABLED
3005 
3006 /**
3007  * xmlSAX2InitDocbDefaultSAXHandler:
3008  * @hdlr:  the SAX handler
3009  *
3010  * Initialize the default DocBook SAX2 handler
3011  */
3012 void
3013 xmlSAX2InitDocbDefaultSAXHandler(xmlSAXHandler *hdlr)
3014 {
3015     if ((hdlr == NULL) || (hdlr-&gt;initialized != 0))
3016     return;
3017 
3018     hdlr-&gt;internalSubset = xmlSAX2InternalSubset;
3019     hdlr-&gt;externalSubset = NULL;
3020     hdlr-&gt;isStandalone = xmlSAX2IsStandalone;
3021     hdlr-&gt;hasInternalSubset = xmlSAX2HasInternalSubset;
3022     hdlr-&gt;hasExternalSubset = xmlSAX2HasExternalSubset;
3023     hdlr-&gt;resolveEntity = xmlSAX2ResolveEntity;
3024     hdlr-&gt;getEntity = xmlSAX2GetEntity;
3025     hdlr-&gt;getParameterEntity = NULL;
3026     hdlr-&gt;entityDecl = xmlSAX2EntityDecl;
3027     hdlr-&gt;attributeDecl = NULL;
3028     hdlr-&gt;elementDecl = NULL;
3029     hdlr-&gt;notationDecl = NULL;
3030     hdlr-&gt;unparsedEntityDecl = NULL;
3031     hdlr-&gt;setDocumentLocator = xmlSAX2SetDocumentLocator;
3032     hdlr-&gt;startDocument = xmlSAX2StartDocument;
3033     hdlr-&gt;endDocument = xmlSAX2EndDocument;
3034     hdlr-&gt;startElement = xmlSAX2StartElement;
3035     hdlr-&gt;endElement = xmlSAX2EndElement;
3036     hdlr-&gt;reference = xmlSAX2Reference;
3037     hdlr-&gt;characters = xmlSAX2Characters;
3038     hdlr-&gt;cdataBlock = NULL;
3039     hdlr-&gt;ignorableWhitespace = xmlSAX2IgnorableWhitespace;
3040     hdlr-&gt;processingInstruction = NULL;
3041     hdlr-&gt;comment = xmlSAX2Comment;
3042     hdlr-&gt;warning = xmlParserWarning;
3043     hdlr-&gt;error = xmlParserError;
3044     hdlr-&gt;fatalError = xmlParserError;
3045 
3046     hdlr-&gt;initialized = 1;
3047 }
3048 
3049 /**
3050  * docbDefaultSAXHandlerInit:
3051  *
3052  * Initialize the default SAX handler
3053  */
3054 void
3055 docbDefaultSAXHandlerInit(void)
3056 {
3057     xmlSAX2InitDocbDefaultSAXHandler((xmlSAXHandlerPtr) &amp;docbDefaultSAXHandler);
3058 }
3059 
3060 #endif /* LIBXML_DOCB_ENABLED */
3061 #define bottom_SAX2
3062 #include &quot;elfgcchack.h&quot;
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/tree.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="timsort.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="trionan.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/tree.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   42 #include &lt;libxml/globals.h&gt;
   43 #ifdef LIBXML_HTML_ENABLED
   44 #include &lt;libxml/HTMLtree.h&gt;
   45 #endif
   46 #ifdef LIBXML_DEBUG_ENABLED
   47 #include &lt;libxml/debugXML.h&gt;
   48 #endif
   49 
   50 #include &quot;buf.h&quot;
   51 #include &quot;save.h&quot;
   52 
   53 int __xmlRegisterCallbacks = 0;
   54 
   55 /************************************************************************
   56  *                                  *
   57  *      Forward declarations                    *
   58  *                                  *
   59  ************************************************************************/
   60 
   61 static xmlNsPtr
<span class="line-modified">   62 xmlNewReconciliedNs(xmlDocPtr doc, xmlNodePtr tree, xmlNsPtr ns);</span>
   63 
   64 static xmlChar* xmlGetPropNodeValueInternal(const xmlAttr *prop);
   65 
   66 /************************************************************************
   67  *                                  *
   68  *      Tree memory error handler               *
   69  *                                  *
   70  ************************************************************************/
   71 /**
   72  * xmlTreeErrMemory:
   73  * @extra:  extra informations
   74  *
   75  * Handle an out of memory condition
   76  */
   77 static void
   78 xmlTreeErrMemory(const char *extra)
   79 {
   80     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);
   81 }
   82 
</pre>
<hr />
<pre>
  164  * return the corresponding entity, if found.
  165  *
  166  * Returns A pointer to the entity structure or NULL if not found.
  167  */
  168 static xmlEntityPtr
  169 xmlGetEntityFromDtd(const xmlDtd *dtd, const xmlChar *name) {
  170     xmlEntitiesTablePtr table;
  171 
  172     if((dtd != NULL) &amp;&amp; (dtd-&gt;entities != NULL)) {
  173     table = (xmlEntitiesTablePtr) dtd-&gt;entities;
  174     return((xmlEntityPtr) xmlHashLookup(table, name));
  175     /* return(xmlGetEntityFromTable(table, name)); */
  176     }
  177     return(NULL);
  178 }
  179 /**
  180  * xmlGetParameterEntityFromDtd:
  181  * @dtd:  A pointer to the DTD to search
  182  * @name:  The entity name
  183  *
<span class="line-modified">  184  * Do an entity lookup in the DTD pararmeter entity hash table and</span>
  185  * return the corresponding entity, if found.
  186  *
  187  * Returns A pointer to the entity structure or NULL if not found.
  188  */
  189 static xmlEntityPtr
  190 xmlGetParameterEntityFromDtd(const xmlDtd *dtd, const xmlChar *name) {
  191     xmlEntitiesTablePtr table;
  192 
  193     if ((dtd != NULL) &amp;&amp; (dtd-&gt;pentities != NULL)) {
  194     table = (xmlEntitiesTablePtr) dtd-&gt;pentities;
  195     return((xmlEntityPtr) xmlHashLookup(table, name));
  196     /* return(xmlGetEntityFromTable(table, name)); */
  197     }
  198     return(NULL);
  199 }
  200 #endif /* LIBXML_TREE_ENABLED */
  201 
  202 /************************************************************************
  203  *                                  *
  204  *          QName handling helper               *
</pre>
<hr />
<pre>
 2933     } else {
 2934         prev = parent-&gt;last;
 2935     prev-&gt;next = cur;
 2936     cur-&gt;prev = prev;
 2937     parent-&gt;last = cur;
 2938     }
 2939 
 2940     return(cur);
 2941 }
 2942 #endif /* LIBXML_TREE_ENABLED */
 2943 
 2944 /**
 2945  * xmlAddPropSibling:
 2946  * @prev:  the attribute to which @prop is added after
 2947  * @cur:   the base attribute passed to calling function
 2948  * @prop:  the new attribute
 2949  *
 2950  * Add a new attribute after @prev using @cur as base attribute.
 2951  * When inserting before @cur, @prev is passed as @cur-&gt;prev.
 2952  * When inserting after @cur, @prev is passed as @cur.
<span class="line-modified"> 2953  * If an existing attribute is found it is detroyed prior to adding @prop.</span>
 2954  *
 2955  * Returns the attribute being inserted or NULL in case of error.
 2956  */
 2957 static xmlNodePtr
 2958 xmlAddPropSibling(xmlNodePtr prev, xmlNodePtr cur, xmlNodePtr prop) {
 2959     xmlAttrPtr attr;
 2960 
 2961     if ((cur == NULL) || (cur-&gt;type != XML_ATTRIBUTE_NODE) ||
 2962         (prop == NULL) || (prop-&gt;type != XML_ATTRIBUTE_NODE) ||
 2963         ((prev != NULL) &amp;&amp; (prev-&gt;type != XML_ATTRIBUTE_NODE)))
 2964         return(NULL);
 2965 
 2966     /* check if an attribute with the same name exists */
 2967     if (prop-&gt;ns == NULL)
 2968         attr = xmlHasNsProp(cur-&gt;parent, prop-&gt;name, NULL);
 2969     else
 2970         attr = xmlHasNsProp(cur-&gt;parent, prop-&gt;name, prop-&gt;ns-&gt;href);
 2971 
 2972     if (prop-&gt;doc != cur-&gt;doc) {
 2973         xmlSetTreeDoc(prop, cur-&gt;doc);
</pre>
<hr />
<pre>
 3647     while (node != NULL) {
 3648         if (node-&gt;type == XML_ELEMENT_NODE)
 3649             return(node);
 3650         node = node-&gt;next;
 3651     }
 3652     return(NULL);
 3653 }
 3654 
 3655 #endif /* LIBXML_TREE_ENABLED */
 3656 
 3657 /**
 3658  * xmlFreeNodeList:
 3659  * @cur:  the first node in the list
 3660  *
 3661  * Free a node and all its siblings, this is a recursive behaviour, all
 3662  * the children are freed too.
 3663  */
 3664 void
 3665 xmlFreeNodeList(xmlNodePtr cur) {
 3666     xmlNodePtr next;

 3667     xmlDictPtr dict = NULL;

 3668 
 3669     if (cur == NULL) return;
 3670     if (cur-&gt;type == XML_NAMESPACE_DECL) {
 3671     xmlFreeNsList((xmlNsPtr) cur);
 3672     return;
 3673     }
 3674     if ((cur-&gt;type == XML_DOCUMENT_NODE) ||
 3675 #ifdef LIBXML_DOCB_ENABLED
 3676     (cur-&gt;type == XML_DOCB_DOCUMENT_NODE) ||
 3677 #endif
 3678     (cur-&gt;type == XML_HTML_DOCUMENT_NODE)) {
 3679     xmlFreeDoc((xmlDocPtr) cur);
 3680     return;
 3681     }
 3682     if (cur-&gt;doc != NULL) dict = cur-&gt;doc-&gt;dict;
<span class="line-modified"> 3683     while (cur != NULL) {</span>







 3684         next = cur-&gt;next;

 3685     if (cur-&gt;type != XML_DTD_NODE) {
 3686 
 3687         if ((__xmlRegisterCallbacks) &amp;&amp; (xmlDeregisterNodeDefaultValue))
 3688         xmlDeregisterNodeDefaultValue(cur);
 3689 
<span class="line-removed"> 3690         if ((cur-&gt;children != NULL) &amp;&amp;</span>
<span class="line-removed"> 3691         (cur-&gt;type != XML_ENTITY_REF_NODE))</span>
<span class="line-removed"> 3692         xmlFreeNodeList(cur-&gt;children);</span>
 3693         if (((cur-&gt;type == XML_ELEMENT_NODE) ||
 3694          (cur-&gt;type == XML_XINCLUDE_START) ||
 3695          (cur-&gt;type == XML_XINCLUDE_END)) &amp;&amp;
 3696         (cur-&gt;properties != NULL))
 3697         xmlFreePropList(cur-&gt;properties);
 3698         if ((cur-&gt;type != XML_ELEMENT_NODE) &amp;&amp;
 3699         (cur-&gt;type != XML_XINCLUDE_START) &amp;&amp;
 3700         (cur-&gt;type != XML_XINCLUDE_END) &amp;&amp;
 3701         (cur-&gt;type != XML_ENTITY_REF_NODE) &amp;&amp;
 3702         (cur-&gt;content != (xmlChar *) &amp;(cur-&gt;properties))) {
 3703         DICT_FREE(cur-&gt;content)
 3704         }
 3705         if (((cur-&gt;type == XML_ELEMENT_NODE) ||
 3706              (cur-&gt;type == XML_XINCLUDE_START) ||
 3707          (cur-&gt;type == XML_XINCLUDE_END)) &amp;&amp;
 3708         (cur-&gt;nsDef != NULL))
 3709         xmlFreeNsList(cur-&gt;nsDef);
 3710 
 3711         /*
 3712          * When a node is a text node or a comment, it uses a global static
 3713          * variable for the name of the node.
 3714          * Otherwise the node name might come from the document&#39;s
 3715          * dictionary
 3716          */
 3717         if ((cur-&gt;name != NULL) &amp;&amp;
 3718         (cur-&gt;type != XML_TEXT_NODE) &amp;&amp;
 3719         (cur-&gt;type != XML_COMMENT_NODE))
 3720         DICT_FREE(cur-&gt;name)
 3721         xmlFree(cur);
 3722     }


 3723     cur = next;







 3724     }
 3725 }
 3726 
 3727 /**
 3728  * xmlFreeNode:
 3729  * @cur:  the node
 3730  *
 3731  * Free a node, this is a recursive behaviour, all the children are freed too.
 3732  * This doesn&#39;t unlink the child from the list, use xmlUnlinkNode() first.
 3733  */
 3734 void
 3735 xmlFreeNode(xmlNodePtr cur) {
 3736     xmlDictPtr dict = NULL;
 3737 
 3738     if (cur == NULL) return;
 3739 
 3740     /* use xmlFreeDtd for DTD nodes */
 3741     if (cur-&gt;type == XML_DTD_NODE) {
 3742     xmlFreeDtd((xmlDtdPtr) cur);
 3743     return;
</pre>
<hr />
<pre>
 4033          * and add it at the top of the new tree
 4034          */
 4035         ns = xmlSearchNs(cur-&gt;doc, cur-&gt;parent, cur-&gt;ns-&gt;prefix);
 4036         if (ns != NULL) {
 4037           xmlNodePtr root = target;
 4038           xmlNodePtr pred = NULL;
 4039 
 4040           while (root-&gt;parent != NULL) {
 4041             pred = root;
 4042             root = root-&gt;parent;
 4043           }
 4044           if (root == (xmlNodePtr) target-&gt;doc) {
 4045             /* correct possibly cycling above the document elt */
 4046             root = pred;
 4047           }
 4048           ret-&gt;ns = xmlNewNs(root, ns-&gt;href, ns-&gt;prefix);
 4049         }
 4050       } else {
 4051         /*
 4052          * we have to find something appropriate here since
<span class="line-modified"> 4053          * we cant be sure, that the namespce we found is identified</span>
 4054          * by the prefix
 4055          */
 4056         if (xmlStrEqual(ns-&gt;href, cur-&gt;ns-&gt;href)) {
 4057           /* this is the nice case */
 4058           ret-&gt;ns = ns;
 4059         } else {
 4060           /*
<span class="line-modified"> 4061            * we are in trouble: we need a new reconcilied namespace.</span>
 4062            * This is expensive
 4063            */
<span class="line-modified"> 4064           ret-&gt;ns = xmlNewReconciliedNs(target-&gt;doc, target, cur-&gt;ns);</span>
 4065         }
 4066       }
 4067 
 4068     } else
 4069         ret-&gt;ns = NULL;
 4070 
 4071     if (cur-&gt;children != NULL) {
 4072     xmlNodePtr tmp;
 4073 
 4074     ret-&gt;children = xmlStaticCopyNodeList(cur-&gt;children, ret-&gt;doc, (xmlNodePtr) ret);
 4075     ret-&gt;last = NULL;
 4076     tmp = ret-&gt;children;
 4077     while (tmp != NULL) {
 4078         /* tmp-&gt;parent = (xmlNodePtr)ret; */
 4079         if (tmp-&gt;next == NULL)
 4080             ret-&gt;last = tmp;
 4081         tmp = tmp-&gt;next;
 4082     }
 4083     }
 4084     /*
</pre>
<hr />
<pre>
 4137     if (p == NULL) {
 4138         ret = p = q;
 4139     } else {
 4140         p-&gt;next = q;
 4141         q-&gt;prev = p;
 4142         p = q;
 4143     }
 4144     cur = cur-&gt;next;
 4145     }
 4146     return(ret);
 4147 }
 4148 
 4149 /*
 4150  * NOTE about the CopyNode operations !
 4151  *
 4152  * They are split into external and internal parts for one
 4153  * tricky reason: namespaces. Doing a direct copy of a node
 4154  * say RPM:Copyright without changing the namespace pointer to
 4155  * something else can produce stale links. One way to do it is
 4156  * to keep a reference counter but this doesn&#39;t work as soon
<span class="line-modified"> 4157  * as one move the element or the subtree out of the scope of</span>
<span class="line-modified"> 4158  * the existing namespace. The actual solution seems to add</span>
 4159  * a copy of the namespace at the top of the copied tree if
 4160  * not available in the subtree.
 4161  * Hence two functions, the public front-end call the inner ones
 4162  * The argument &quot;recursive&quot; normally indicates a recursive copy
 4163  * of the node with values 0 (no) and 1 (yes).  For XInclude,
 4164  * however, we allow a value of 2 to indicate copy properties and
 4165  * namespace info, but don&#39;t recurse on children.
 4166  */
 4167 
 4168 static xmlNodePtr
 4169 xmlStaticCopyNode(xmlNodePtr node, xmlDocPtr doc, xmlNodePtr parent,
 4170                   int extended) {
 4171     xmlNodePtr ret;
 4172 
 4173     if (node == NULL) return(NULL);
 4174     switch (node-&gt;type) {
 4175         case XML_TEXT_NODE:
 4176         case XML_CDATA_SECTION_NODE:
 4177         case XML_ELEMENT_NODE:
 4178         case XML_DOCUMENT_FRAG_NODE:
</pre>
<hr />
<pre>
 4263          (node-&gt;type == XML_XINCLUDE_START)) &amp;&amp; (node-&gt;nsDef != NULL))
 4264         ret-&gt;nsDef = xmlCopyNamespaceList(node-&gt;nsDef);
 4265 
 4266     if (node-&gt;ns != NULL) {
 4267         xmlNsPtr ns;
 4268 
 4269     ns = xmlSearchNs(doc, ret, node-&gt;ns-&gt;prefix);
 4270     if (ns == NULL) {
 4271         /*
 4272          * Humm, we are copying an element whose namespace is defined
 4273          * out of the new tree scope. Search it in the original tree
 4274          * and add it at the top of the new tree
 4275          */
 4276         ns = xmlSearchNs(node-&gt;doc, node, node-&gt;ns-&gt;prefix);
 4277         if (ns != NULL) {
 4278             xmlNodePtr root = ret;
 4279 
 4280         while (root-&gt;parent != NULL) root = root-&gt;parent;
 4281         ret-&gt;ns = xmlNewNs(root, ns-&gt;href, ns-&gt;prefix);
 4282         } else {
<span class="line-modified"> 4283             ret-&gt;ns = xmlNewReconciliedNs(doc, ret, node-&gt;ns);</span>
 4284         }
 4285     } else {
 4286         /*
 4287          * reference the existing namespace definition in our own tree.
 4288          */
 4289         ret-&gt;ns = ns;
 4290     }
 4291     }
 4292     if (((node-&gt;type == XML_ELEMENT_NODE) ||
 4293          (node-&gt;type == XML_XINCLUDE_START)) &amp;&amp; (node-&gt;properties != NULL))
 4294         ret-&gt;properties = xmlCopyPropList(ret, node-&gt;properties);
 4295     if (node-&gt;type == XML_ENTITY_REF_NODE) {
 4296     if ((doc == NULL) || (node-&gt;doc != doc)) {
 4297         /*
 4298          * The copied node will go into a separate document, so
 4299          * to avoid dangling references to the ENTITY_DECL node
 4300          * we cannot keep the reference. Try to find it in the
 4301          * target document.
 4302          */
 4303         ret-&gt;children = (xmlNodePtr) xmlGetDocEntity(doc, ret-&gt;name);
</pre>
<hr />
<pre>
 4702             name = (const char *) cur-&gt;name;
 4703             if (cur-&gt;ns) {
 4704         if (cur-&gt;ns-&gt;prefix != NULL) {
 4705                     snprintf(nametemp, sizeof(nametemp) - 1, &quot;%s:%s&quot;,
 4706             (char *)cur-&gt;ns-&gt;prefix, (char *)cur-&gt;name);
 4707             nametemp[sizeof(nametemp) - 1] = 0;
 4708             name = nametemp;
 4709         } else {
 4710             /*
 4711             * We cannot express named elements in the default
 4712             * namespace, so use &quot;*&quot;.
 4713             */
 4714             generic = 1;
 4715             name = &quot;*&quot;;
 4716         }
 4717             }
 4718             next = cur-&gt;parent;
 4719 
 4720             /*
 4721              * Thumbler index computation
<span class="line-modified"> 4722          * TODO: the ocurence test seems bogus for namespaced names</span>
 4723              */
 4724             tmp = cur-&gt;prev;
 4725             while (tmp != NULL) {
 4726                 if ((tmp-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
 4727             (generic ||
 4728              (xmlStrEqual(cur-&gt;name, tmp-&gt;name) &amp;&amp;
 4729              ((tmp-&gt;ns == cur-&gt;ns) ||
 4730               ((tmp-&gt;ns != NULL) &amp;&amp; (cur-&gt;ns != NULL) &amp;&amp;
 4731                (xmlStrEqual(cur-&gt;ns-&gt;prefix, tmp-&gt;ns-&gt;prefix)))))))
 4732                     occur++;
 4733                 tmp = tmp-&gt;prev;
 4734             }
 4735             if (occur == 0) {
 4736                 tmp = cur-&gt;next;
 4737                 while (tmp != NULL &amp;&amp; occur == 0) {
 4738                     if ((tmp-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
 4739             (generic ||
 4740              (xmlStrEqual(cur-&gt;name, tmp-&gt;name) &amp;&amp;
 4741              ((tmp-&gt;ns == cur-&gt;ns) ||
 4742               ((tmp-&gt;ns != NULL) &amp;&amp; (cur-&gt;ns != NULL) &amp;&amp;
</pre>
<hr />
<pre>
 6197                 cur = cur-&gt;next;
 6198             }
 6199             if (orig != node) {
 6200                 cur = node-&gt;ns;
 6201                 if (cur != NULL) {
 6202                     if ((cur-&gt;href != NULL) &amp;&amp; (href != NULL) &amp;&amp;
 6203                         (xmlStrEqual(cur-&gt;href, href))) {
 6204             if (((!is_attr) || (cur-&gt;prefix != NULL)) &amp;&amp;
 6205                     (xmlNsInScope(doc, orig, node, cur-&gt;prefix) == 1))
 6206                 return (cur);
 6207                     }
 6208                 }
 6209             }
 6210         }
 6211         node = node-&gt;parent;
 6212     }
 6213     return (NULL);
 6214 }
 6215 
 6216 /**
<span class="line-modified"> 6217  * xmlNewReconciliedNs:</span>
 6218  * @doc:  the document
 6219  * @tree:  a node expected to hold the new namespace
 6220  * @ns:  the original namespace
 6221  *
 6222  * This function tries to locate a namespace definition in a tree
 6223  * ancestors, or create a new namespace definition node similar to
 6224  * @ns trying to reuse the same prefix. However if the given prefix is
 6225  * null (default namespace) or reused within the subtree defined by
 6226  * @tree or on one of its ancestors then a new prefix is generated.
 6227  * Returns the (new) namespace definition or NULL in case of error
 6228  */
 6229 static xmlNsPtr
<span class="line-modified"> 6230 xmlNewReconciliedNs(xmlDocPtr doc, xmlNodePtr tree, xmlNsPtr ns) {</span>
 6231     xmlNsPtr def;
 6232     xmlChar prefix[50];
 6233     int counter = 1;
 6234 
 6235     if ((tree == NULL) || (tree-&gt;type != XML_ELEMENT_NODE)) {
 6236 #ifdef DEBUG_TREE
 6237         xmlGenericError(xmlGenericErrorContext,
<span class="line-modified"> 6238         &quot;xmlNewReconciliedNs : tree == NULL\n&quot;);</span>
 6239 #endif
 6240     return(NULL);
 6241     }
 6242     if ((ns == NULL) || (ns-&gt;type != XML_NAMESPACE_DECL)) {
 6243 #ifdef DEBUG_TREE
 6244         xmlGenericError(xmlGenericErrorContext,
<span class="line-modified"> 6245         &quot;xmlNewReconciliedNs : ns == NULL\n&quot;);</span>
 6246 #endif
 6247     return(NULL);
 6248     }
 6249     /*
 6250      * Search an existing namespace definition inherited.
 6251      */
 6252     def = xmlSearchNsByHref(doc, tree, ns-&gt;href);
 6253     if (def != NULL)
 6254         return(def);
 6255 
 6256     /*
 6257      * Find a close prefix which is not already in use.
 6258      * Let&#39;s strip namespace prefixes longer than 20 chars !
 6259      */
 6260     if (ns-&gt;prefix == NULL)
 6261     snprintf((char *) prefix, sizeof(prefix), &quot;default&quot;);
 6262     else
 6263     snprintf((char *) prefix, sizeof(prefix), &quot;%.20s&quot;, (char *)ns-&gt;prefix);
 6264 
 6265     def = xmlSearchNs(doc, tree, prefix);
</pre>
<hr />
<pre>
 6327             return(-1);
 6328         }
 6329         newNs = (xmlNsPtr *) xmlMalloc(sizeCache *
 6330                            sizeof(xmlNsPtr));
 6331         if (newNs == NULL) {
 6332             xmlTreeErrMemory(&quot;fixing namespaces&quot;);
 6333             xmlFree(oldNs);
 6334             return(-1);
 6335         }
 6336         }
 6337         for (i = 0;i &lt; nbCache;i++) {
 6338             if (oldNs[i] == node-&gt;ns) {
 6339             node-&gt;ns = newNs[i];
 6340             break;
 6341         }
 6342         }
 6343         if (i == nbCache) {
 6344             /*
 6345          * OK we need to recreate a new namespace definition
 6346          */
<span class="line-modified"> 6347         n = xmlNewReconciliedNs(doc, tree, node-&gt;ns);</span>
 6348         if (n != NULL) { /* :-( what if else ??? */
 6349             /*
 6350              * check if we need to grow the cache buffers.
 6351              */
 6352             if (sizeCache &lt;= nbCache) {
 6353                 sizeCache *= 2;
 6354             oldNs = (xmlNsPtr *) xmlRealloc(oldNs, sizeCache *
 6355                                            sizeof(xmlNsPtr));
 6356                 if (oldNs == NULL) {
 6357                 xmlTreeErrMemory(&quot;fixing namespaces&quot;);
 6358                 xmlFree(newNs);
 6359                 return(-1);
 6360             }
 6361             newNs = (xmlNsPtr *) xmlRealloc(newNs, sizeCache *
 6362                                            sizeof(xmlNsPtr));
 6363                 if (newNs == NULL) {
 6364                 xmlTreeErrMemory(&quot;fixing namespaces&quot;);
 6365                 xmlFree(oldNs);
 6366                 return(-1);
 6367             }
 6368             }
 6369             newNs[nbCache] = n;
 6370             oldNs[nbCache++] = node-&gt;ns;
 6371             node-&gt;ns = n;
 6372                 }
 6373         }
 6374     }
 6375     /*
<span class="line-modified"> 6376      * now check for namespace hold by attributes on the node.</span>
 6377      */
 6378     if (node-&gt;type == XML_ELEMENT_NODE) {
 6379         attr = node-&gt;properties;
 6380         while (attr != NULL) {
 6381         if (attr-&gt;ns != NULL) {
 6382             /*
 6383              * initialize the cache if needed
 6384              */
 6385             if (sizeCache == 0) {
 6386             sizeCache = 10;
 6387             oldNs = (xmlNsPtr *) xmlMalloc(sizeCache *
 6388                                sizeof(xmlNsPtr));
 6389             if (oldNs == NULL) {
 6390                 xmlTreeErrMemory(&quot;fixing namespaces&quot;);
 6391                 return(-1);
 6392             }
 6393             newNs = (xmlNsPtr *) xmlMalloc(sizeCache *
 6394                                sizeof(xmlNsPtr));
 6395             if (newNs == NULL) {
 6396                 xmlTreeErrMemory(&quot;fixing namespaces&quot;);
 6397                 xmlFree(oldNs);
 6398                 return(-1);
 6399             }
 6400             }
 6401             for (i = 0;i &lt; nbCache;i++) {
 6402             if (oldNs[i] == attr-&gt;ns) {
 6403                 attr-&gt;ns = newNs[i];
 6404                 break;
 6405             }
 6406             }
 6407             if (i == nbCache) {
 6408             /*
 6409              * OK we need to recreate a new namespace definition
 6410              */
<span class="line-modified"> 6411             n = xmlNewReconciliedNs(doc, tree, attr-&gt;ns);</span>
 6412             if (n != NULL) { /* :-( what if else ??? */
 6413                 /*
 6414                  * check if we need to grow the cache buffers.
 6415                  */
 6416                 if (sizeCache &lt;= nbCache) {
 6417                 sizeCache *= 2;
 6418                 oldNs = (xmlNsPtr *) xmlRealloc(oldNs,
 6419                            sizeCache * sizeof(xmlNsPtr));
 6420                 if (oldNs == NULL) {
 6421                     xmlTreeErrMemory(&quot;fixing namespaces&quot;);
 6422                     xmlFree(newNs);
 6423                     return(-1);
 6424                 }
 6425                 newNs = (xmlNsPtr *) xmlRealloc(newNs,
 6426                            sizeCache * sizeof(xmlNsPtr));
 6427                 if (newNs == NULL) {
 6428                     xmlTreeErrMemory(&quot;fixing namespaces&quot;);
 6429                     xmlFree(oldNs);
 6430                     return(-1);
 6431                 }
</pre>
<hr />
<pre>
 7944     ret-&gt;next = map-&gt;first;
 7945     map-&gt;first = ret;
 7946     }
 7947 
 7948     ret-&gt;oldNs = oldNs;
 7949     ret-&gt;newNs = newNs;
 7950     ret-&gt;shadowDepth = -1;
 7951     ret-&gt;depth = depth;
 7952     return (ret);
 7953 }
 7954 
 7955 /*
 7956 * xmlDOMWrapStoreNs:
 7957 * @doc: the doc
 7958 * @nsName: the namespace name
 7959 * @prefix: the prefix
 7960 *
 7961 * Creates or reuses an xmlNs struct on doc-&gt;oldNs with
 7962 * the given prefix and namespace name.
 7963 *
<span class="line-modified"> 7964 * Returns the aquired ns struct or NULL in case of an API</span>
 7965 *         or internal error.
 7966 */
 7967 static xmlNsPtr
 7968 xmlDOMWrapStoreNs(xmlDocPtr doc,
 7969            const xmlChar *nsName,
 7970            const xmlChar *prefix)
 7971 {
 7972     xmlNsPtr ns;
 7973 
 7974     if (doc == NULL)
 7975     return (NULL);
 7976     ns = xmlTreeEnsureXMLDecl(doc);
 7977     if (ns == NULL)
 7978     return (NULL);
 7979     if (ns-&gt;next != NULL) {
 7980     /* Reuse. */
 7981     ns = ns-&gt;next;
 7982     while (ns != NULL) {
 7983         if (((ns-&gt;prefix == prefix) ||
 7984         xmlStrEqual(ns-&gt;prefix, prefix)) &amp;&amp;
</pre>
<hr />
<pre>
 8558         while (ns2-&gt;next != NULL)
 8559         ns2 = ns2-&gt;next;
 8560         ns2-&gt;next = ret;
 8561     }
 8562     return (ret);
 8563 ns_next_prefix:
 8564     counter++;
 8565     if (counter &gt; 1000)
 8566         return (NULL);
 8567     if (prefix == NULL) {
 8568         snprintf((char *) buf, sizeof(buf),
 8569         &quot;ns_%d&quot;, counter);
 8570     } else
 8571         snprintf((char *) buf, sizeof(buf),
 8572         &quot;%.30s_%d&quot;, (char *)prefix, counter);
 8573     pref = BAD_CAST buf;
 8574     }
 8575 }
 8576 
 8577 /*
<span class="line-modified"> 8578 * xmlDOMWrapNSNormAquireNormalizedNs:</span>
 8579 * @doc: the doc
 8580 * @elem: the element-node to declare namespaces on
 8581 * @ns: the ns-struct to use for the search
 8582 * @retNs: the found/created ns-struct
 8583 * @nsMap: the ns-map
 8584 * @depth: the current tree depth
 8585 * @ancestorsOnly: search in ancestor ns-decls only
 8586 * @prefixed: if the searched ns-decl must have a prefix (for attributes)
 8587 *
 8588 * Searches for a matching ns-name in the ns-decls of @nsMap, if not
 8589 * found it will either declare it on @elem, or store it in doc-&gt;oldNs.
 8590 * If a new ns-decl needs to be declared on @elem, it tries to use the
 8591 * @ns-&gt;prefix for it, if this prefix is already in use on @elem, it will
 8592 * change the prefix or the new ns-decl.
 8593 *
 8594 * Returns 0 if succeeded, -1 otherwise and on API/internal errors.
 8595 */
 8596 static int
<span class="line-modified"> 8597 xmlDOMWrapNSNormAquireNormalizedNs(xmlDocPtr doc,</span>
 8598                    xmlNodePtr elem,
 8599                    xmlNsPtr ns,
 8600                    xmlNsPtr *retNs,
 8601                    xmlNsMapPtr *nsMap,
 8602 
 8603                    int depth,
 8604                    int ancestorsOnly,
 8605                    int prefixed)
 8606 {
 8607     xmlNsMapItemPtr mi;
 8608 
 8609     if ((doc == NULL) || (ns == NULL) || (retNs == NULL) ||
 8610     (nsMap == NULL))
 8611     return (-1);
 8612 
 8613     *retNs = NULL;
 8614     /*
 8615     * Handle XML namespace.
 8616     */
 8617     if (IS_STR_XML(ns-&gt;prefix)) {
</pre>
<hr />
<pre>
 8876                }
 8877            }
 8878         }
 8879         /*
 8880         * Adopt ns-references.
 8881         */
 8882         if (XML_NSMAP_NOTEMPTY(nsMap)) {
 8883             /*
 8884             * Search for a mapping.
 8885             */
 8886             XML_NSMAP_FOREACH(nsMap, mi) {
 8887             if ((mi-&gt;shadowDepth == -1) &amp;&amp;
 8888                 (cur-&gt;ns == mi-&gt;oldNs)) {
 8889 
 8890                 cur-&gt;ns = mi-&gt;newNs;
 8891                 goto ns_end;
 8892             }
 8893             }
 8894         }
 8895         /*
<span class="line-modified"> 8896         * Aquire a normalized ns-decl and add it to the map.</span>
 8897         */
<span class="line-modified"> 8898         if (xmlDOMWrapNSNormAquireNormalizedNs(doc, curElem,</span>
 8899             cur-&gt;ns, &amp;ns,
 8900             &amp;nsMap, depth,
 8901             ancestorsOnly,
 8902             (cur-&gt;type == XML_ATTRIBUTE_NODE) ? 1 : 0) == -1)
 8903             goto internal_error;
 8904         cur-&gt;ns = ns;
 8905 
 8906 ns_end:
 8907         if ((cur-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
 8908             (cur-&gt;properties != NULL)) {
 8909             /*
 8910             * Process attributes.
 8911             */
 8912             cur = (xmlNodePtr) cur-&gt;properties;
 8913             continue;
 8914         }
 8915         break;
 8916         default:
 8917         goto next_sibling;
 8918     }
</pre>
<hr />
<pre>
 9016     int parnsdone;
 9017     /* @ancestorsOnly should be set per option. */
 9018     int ancestorsOnly = 0;
 9019 
 9020     /*
 9021     * Optimize string adoption for equal or none dicts.
 9022     */
 9023     if ((sourceDoc != NULL) &amp;&amp;
 9024     (sourceDoc-&gt;dict == destDoc-&gt;dict))
 9025     adoptStr = 0;
 9026     else
 9027     adoptStr = 1;
 9028 
 9029     /*
 9030     * Get the ns-map from the context if available.
 9031     */
 9032     if (ctxt)
 9033     nsMap = (xmlNsMapPtr) ctxt-&gt;namespaceMap;
 9034     /*
 9035     * Disable search for ns-decls in the parent-axis of the
<span class="line-modified"> 9036     * desination element, if:</span>
 9037     * 1) there&#39;s no destination parent
 9038     * 2) custom ns-reference handling is used
 9039     */
 9040     if ((destParent == NULL) ||
 9041     (ctxt &amp;&amp; ctxt-&gt;getNsForNodeFunc))
 9042     {
 9043     parnsdone = 1;
 9044     } else
 9045     parnsdone = 0;
 9046 
 9047     cur = node;
 9048     if ((cur != NULL) &amp;&amp; (cur-&gt;type == XML_NAMESPACE_DECL))
 9049     goto internal_error;
 9050 
 9051     while (cur != NULL) {
 9052     /*
 9053     * Paranoid source-doc sanity check.
 9054     */
 9055     if (cur-&gt;doc != sourceDoc) {
 9056         /*
</pre>
<hr />
<pre>
 9161         }
 9162         /*
 9163         * No matching namespace in scope. We need a new one.
 9164         */
 9165         if ((ctxt) &amp;&amp; (ctxt-&gt;getNsForNodeFunc)) {
 9166             /*
 9167             * User-defined behaviour.
 9168             */
 9169             ns = ctxt-&gt;getNsForNodeFunc(ctxt, cur,
 9170             cur-&gt;ns-&gt;href, cur-&gt;ns-&gt;prefix);
 9171             /*
 9172             * Insert mapping if ns is available; it&#39;s the users fault
 9173             * if not.
 9174             */
 9175             if (xmlDOMWrapNsMapAddItem(&amp;nsMap, -1,
 9176                 cur-&gt;ns, ns, XML_TREE_NSMAP_CUSTOM) == NULL)
 9177             goto internal_error;
 9178             cur-&gt;ns = ns;
 9179         } else {
 9180             /*
<span class="line-modified"> 9181             * Aquire a normalized ns-decl and add it to the map.</span>
 9182             */
<span class="line-modified"> 9183             if (xmlDOMWrapNSNormAquireNormalizedNs(destDoc,</span>
 9184             /* ns-decls on curElem or on destDoc-&gt;oldNs */
 9185             destParent ? curElem : NULL,
 9186             cur-&gt;ns, &amp;ns,
 9187             &amp;nsMap, depth,
 9188             ancestorsOnly,
 9189             /* ns-decls must be prefixed for attributes. */
 9190             (cur-&gt;type == XML_ATTRIBUTE_NODE) ? 1 : 0) == -1)
 9191             goto internal_error;
 9192             cur-&gt;ns = ns;
 9193         }
 9194 ns_end:
 9195         /*
 9196         * Further node properties.
 9197         * TODO: Is this all?
 9198         */
 9199         XML_TREE_ADOPT_STR(cur-&gt;name)
 9200         if (cur-&gt;type == XML_ELEMENT_NODE) {
 9201             cur-&gt;psvi = NULL;
 9202             cur-&gt;line = 0;
 9203             cur-&gt;extra = 0;
</pre>
<hr />
<pre>
 9217             */
 9218             if ((sourceDoc != NULL) &amp;&amp;
 9219             (((xmlAttrPtr) cur)-&gt;atype == XML_ATTRIBUTE_ID))
 9220             {
 9221             xmlRemoveID(sourceDoc, (xmlAttrPtr) cur);
 9222             }
 9223             ((xmlAttrPtr) cur)-&gt;atype = 0;
 9224             ((xmlAttrPtr) cur)-&gt;psvi = NULL;
 9225         }
 9226         break;
 9227         case XML_TEXT_NODE:
 9228         case XML_CDATA_SECTION_NODE:
 9229         /*
 9230         * This puts the content in the dest dict, only if
 9231         * it was previously in the source dict.
 9232         */
 9233         XML_TREE_ADOPT_STR_2(cur-&gt;content)
 9234         goto leave_node;
 9235         case XML_ENTITY_REF_NODE:
 9236         /*
<span class="line-modified"> 9237         * Remove reference to the entitity-node.</span>
 9238         */
 9239         cur-&gt;content = NULL;
 9240         cur-&gt;children = NULL;
 9241         cur-&gt;last = NULL;
 9242         if ((destDoc-&gt;intSubset) || (destDoc-&gt;extSubset)) {
 9243             xmlEntityPtr ent;
 9244             /*
 9245             * Assign new entity-node if available.
 9246             */
 9247             ent = xmlGetDocEntity(destDoc, cur-&gt;name);
 9248             if (ent != NULL) {
 9249             cur-&gt;content = ent-&gt;content;
 9250             cur-&gt;children = (xmlNodePtr) ent;
 9251             cur-&gt;last = (xmlNodePtr) ent;
 9252             }
 9253         }
 9254         goto leave_node;
 9255         case XML_PI_NODE:
 9256         XML_TREE_ADOPT_STR(cur-&gt;name)
 9257         XML_TREE_ADOPT_STR_2(cur-&gt;content)
</pre>
<hr />
<pre>
 9451         goto internal_error;
 9452         break;
 9453         case XML_ELEMENT_NODE:
 9454         case XML_TEXT_NODE:
 9455         case XML_CDATA_SECTION_NODE:
 9456         case XML_COMMENT_NODE:
 9457         case XML_PI_NODE:
 9458         case XML_DOCUMENT_FRAG_NODE:
 9459         case XML_ENTITY_REF_NODE:
 9460         case XML_ENTITY_NODE:
 9461         /*
 9462         * Nodes of xmlNode structure.
 9463         */
 9464         clone = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 9465         if (clone == NULL) {
 9466             xmlTreeErrMemory(&quot;xmlDOMWrapCloneNode(): allocating a node&quot;);
 9467             goto internal_error;
 9468         }
 9469         memset(clone, 0, sizeof(xmlNode));
 9470         /*
<span class="line-modified"> 9471         * Set hierachical links.</span>
 9472         */
 9473         if (resultClone != NULL) {
 9474             clone-&gt;parent = parentClone;
 9475             if (prevClone) {
 9476             prevClone-&gt;next = clone;
 9477             clone-&gt;prev = prevClone;
 9478             } else
 9479             parentClone-&gt;children = clone;
 9480         } else
 9481             resultClone = clone;
 9482 
 9483         break;
 9484         case XML_ATTRIBUTE_NODE:
 9485         /*
 9486         * Attributes (xmlAttr).
 9487         */
 9488         clone = (xmlNodePtr) xmlMalloc(sizeof(xmlAttr));
 9489         if (clone == NULL) {
 9490             xmlTreeErrMemory(&quot;xmlDOMWrapCloneNode(): allocating an attr-node&quot;);
 9491             goto internal_error;
 9492         }
 9493         memset(clone, 0, sizeof(xmlAttr));
 9494         /*
<span class="line-modified"> 9495         * Set hierachical links.</span>
 9496         * TODO: Change this to add to the end of attributes.
 9497         */
 9498         if (resultClone != NULL) {
 9499             clone-&gt;parent = parentClone;
 9500             if (prevClone) {
 9501             prevClone-&gt;next = clone;
 9502             clone-&gt;prev = prevClone;
 9503             } else
 9504             parentClone-&gt;properties = (xmlAttrPtr) clone;
 9505         } else
 9506             resultClone = clone;
 9507         break;
 9508         default:
 9509         /*
 9510         * TODO QUESTION: Any other nodes expected?
 9511         */
 9512         goto internal_error;
 9513     }
 9514 
 9515     clone-&gt;type = cur-&gt;type;
</pre>
<hr />
<pre>
 9703         }
 9704     }
 9705     /*
 9706     * No matching namespace in scope. We need a new one.
 9707     */
 9708     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;getNsForNodeFunc != NULL)) {
 9709         /*
 9710         * User-defined behaviour.
 9711         */
 9712         ns = ctxt-&gt;getNsForNodeFunc(ctxt, cur,
 9713         cur-&gt;ns-&gt;href, cur-&gt;ns-&gt;prefix);
 9714         /*
 9715         * Add user&#39;s mapping.
 9716         */
 9717         if (xmlDOMWrapNsMapAddItem(&amp;nsMap, -1,
 9718         cur-&gt;ns, ns, XML_TREE_NSMAP_CUSTOM) == NULL)
 9719         goto internal_error;
 9720         clone-&gt;ns = ns;
 9721     } else {
 9722         /*
<span class="line-modified"> 9723         * Aquire a normalized ns-decl and add it to the map.</span>
 9724         */
<span class="line-modified"> 9725         if (xmlDOMWrapNSNormAquireNormalizedNs(destDoc,</span>
 9726         /* ns-decls on curElem or on destDoc-&gt;oldNs */
 9727         destParent ? curElem : NULL,
 9728         cur-&gt;ns, &amp;ns,
 9729         &amp;nsMap, depth,
 9730         /* if we need to search only in the ancestor-axis */
 9731         ancestorsOnly,
 9732         /* ns-decls must be prefixed for attributes. */
 9733         (cur-&gt;type == XML_ATTRIBUTE_NODE) ? 1 : 0) == -1)
 9734         goto internal_error;
 9735         clone-&gt;ns = ns;
 9736     }
 9737 
 9738 end_ns_reference:
 9739 
 9740     /*
 9741     * Some post-processing.
 9742     *
 9743     * Handle ID attributes.
 9744     */
 9745     if ((clone-&gt;type == XML_ATTRIBUTE_NODE) &amp;&amp;
</pre>
<hr />
<pre>
 9942     XML_TREE_ADOPT_STR(attr-&gt;name);
 9943     attr-&gt;atype = 0;
 9944     attr-&gt;psvi = NULL;
 9945     /*
 9946     * Walk content.
 9947     */
 9948     if (attr-&gt;children == NULL)
 9949     return (0);
 9950     cur = attr-&gt;children;
 9951     if ((cur != NULL) &amp;&amp; (cur-&gt;type == XML_NAMESPACE_DECL))
 9952         goto internal_error;
 9953     while (cur != NULL) {
 9954     cur-&gt;doc = destDoc;
 9955     switch (cur-&gt;type) {
 9956         case XML_TEXT_NODE:
 9957         case XML_CDATA_SECTION_NODE:
 9958         XML_TREE_ADOPT_STR_2(cur-&gt;content)
 9959         break;
 9960         case XML_ENTITY_REF_NODE:
 9961         /*
<span class="line-modified"> 9962         * Remove reference to the entitity-node.</span>
 9963         */
 9964         cur-&gt;content = NULL;
 9965         cur-&gt;children = NULL;
 9966         cur-&gt;last = NULL;
 9967         if ((destDoc-&gt;intSubset) || (destDoc-&gt;extSubset)) {
 9968             xmlEntityPtr ent;
 9969             /*
 9970             * Assign new entity-node if available.
 9971             */
 9972             ent = xmlGetDocEntity(destDoc, cur-&gt;name);
 9973             if (ent != NULL) {
 9974             cur-&gt;content = ent-&gt;content;
 9975             cur-&gt;children = (xmlNodePtr) ent;
 9976             cur-&gt;last = (xmlNodePtr) ent;
 9977             }
 9978         }
 9979         break;
 9980         default:
 9981         break;
 9982     }
</pre>
<hr />
<pre>
10080         return (xmlDOMWrapAdoptAttr(ctxt, sourceDoc,
10081         (xmlAttrPtr) node, destDoc, destParent, options));
10082     } else {
10083     xmlNodePtr cur = node;
10084     int adoptStr = 1;
10085 
10086     cur-&gt;doc = destDoc;
10087     /*
10088     * Optimize string adoption.
10089     */
10090     if ((sourceDoc != NULL) &amp;&amp;
10091         (sourceDoc-&gt;dict == destDoc-&gt;dict))
10092         adoptStr = 0;
10093     switch (node-&gt;type) {
10094         case XML_TEXT_NODE:
10095         case XML_CDATA_SECTION_NODE:
10096         XML_TREE_ADOPT_STR_2(node-&gt;content)
10097             break;
10098         case XML_ENTITY_REF_NODE:
10099         /*
<span class="line-modified">10100         * Remove reference to the entitity-node.</span>
10101         */
10102         node-&gt;content = NULL;
10103         node-&gt;children = NULL;
10104         node-&gt;last = NULL;
10105         if ((destDoc-&gt;intSubset) || (destDoc-&gt;extSubset)) {
10106             xmlEntityPtr ent;
10107             /*
10108             * Assign new entity-node if available.
10109             */
10110             ent = xmlGetDocEntity(destDoc, node-&gt;name);
10111             if (ent != NULL) {
10112             node-&gt;content = ent-&gt;content;
10113             node-&gt;children = (xmlNodePtr) ent;
10114             node-&gt;last = (xmlNodePtr) ent;
10115             }
10116         }
10117         XML_TREE_ADOPT_STR(node-&gt;name)
10118         break;
10119         case XML_PI_NODE: {
10120         XML_TREE_ADOPT_STR(node-&gt;name)
</pre>
</td>
<td>
<hr />
<pre>
   42 #include &lt;libxml/globals.h&gt;
   43 #ifdef LIBXML_HTML_ENABLED
   44 #include &lt;libxml/HTMLtree.h&gt;
   45 #endif
   46 #ifdef LIBXML_DEBUG_ENABLED
   47 #include &lt;libxml/debugXML.h&gt;
   48 #endif
   49 
   50 #include &quot;buf.h&quot;
   51 #include &quot;save.h&quot;
   52 
   53 int __xmlRegisterCallbacks = 0;
   54 
   55 /************************************************************************
   56  *                                  *
   57  *      Forward declarations                    *
   58  *                                  *
   59  ************************************************************************/
   60 
   61 static xmlNsPtr
<span class="line-modified">   62 xmlNewReconciledNs(xmlDocPtr doc, xmlNodePtr tree, xmlNsPtr ns);</span>
   63 
   64 static xmlChar* xmlGetPropNodeValueInternal(const xmlAttr *prop);
   65 
   66 /************************************************************************
   67  *                                  *
   68  *      Tree memory error handler               *
   69  *                                  *
   70  ************************************************************************/
   71 /**
   72  * xmlTreeErrMemory:
   73  * @extra:  extra informations
   74  *
   75  * Handle an out of memory condition
   76  */
   77 static void
   78 xmlTreeErrMemory(const char *extra)
   79 {
   80     __xmlSimpleError(XML_FROM_TREE, XML_ERR_NO_MEMORY, NULL, NULL, extra);
   81 }
   82 
</pre>
<hr />
<pre>
  164  * return the corresponding entity, if found.
  165  *
  166  * Returns A pointer to the entity structure or NULL if not found.
  167  */
  168 static xmlEntityPtr
  169 xmlGetEntityFromDtd(const xmlDtd *dtd, const xmlChar *name) {
  170     xmlEntitiesTablePtr table;
  171 
  172     if((dtd != NULL) &amp;&amp; (dtd-&gt;entities != NULL)) {
  173     table = (xmlEntitiesTablePtr) dtd-&gt;entities;
  174     return((xmlEntityPtr) xmlHashLookup(table, name));
  175     /* return(xmlGetEntityFromTable(table, name)); */
  176     }
  177     return(NULL);
  178 }
  179 /**
  180  * xmlGetParameterEntityFromDtd:
  181  * @dtd:  A pointer to the DTD to search
  182  * @name:  The entity name
  183  *
<span class="line-modified">  184  * Do an entity lookup in the DTD parameter entity hash table and</span>
  185  * return the corresponding entity, if found.
  186  *
  187  * Returns A pointer to the entity structure or NULL if not found.
  188  */
  189 static xmlEntityPtr
  190 xmlGetParameterEntityFromDtd(const xmlDtd *dtd, const xmlChar *name) {
  191     xmlEntitiesTablePtr table;
  192 
  193     if ((dtd != NULL) &amp;&amp; (dtd-&gt;pentities != NULL)) {
  194     table = (xmlEntitiesTablePtr) dtd-&gt;pentities;
  195     return((xmlEntityPtr) xmlHashLookup(table, name));
  196     /* return(xmlGetEntityFromTable(table, name)); */
  197     }
  198     return(NULL);
  199 }
  200 #endif /* LIBXML_TREE_ENABLED */
  201 
  202 /************************************************************************
  203  *                                  *
  204  *          QName handling helper               *
</pre>
<hr />
<pre>
 2933     } else {
 2934         prev = parent-&gt;last;
 2935     prev-&gt;next = cur;
 2936     cur-&gt;prev = prev;
 2937     parent-&gt;last = cur;
 2938     }
 2939 
 2940     return(cur);
 2941 }
 2942 #endif /* LIBXML_TREE_ENABLED */
 2943 
 2944 /**
 2945  * xmlAddPropSibling:
 2946  * @prev:  the attribute to which @prop is added after
 2947  * @cur:   the base attribute passed to calling function
 2948  * @prop:  the new attribute
 2949  *
 2950  * Add a new attribute after @prev using @cur as base attribute.
 2951  * When inserting before @cur, @prev is passed as @cur-&gt;prev.
 2952  * When inserting after @cur, @prev is passed as @cur.
<span class="line-modified"> 2953  * If an existing attribute is found it is destroyed prior to adding @prop.</span>
 2954  *
 2955  * Returns the attribute being inserted or NULL in case of error.
 2956  */
 2957 static xmlNodePtr
 2958 xmlAddPropSibling(xmlNodePtr prev, xmlNodePtr cur, xmlNodePtr prop) {
 2959     xmlAttrPtr attr;
 2960 
 2961     if ((cur == NULL) || (cur-&gt;type != XML_ATTRIBUTE_NODE) ||
 2962         (prop == NULL) || (prop-&gt;type != XML_ATTRIBUTE_NODE) ||
 2963         ((prev != NULL) &amp;&amp; (prev-&gt;type != XML_ATTRIBUTE_NODE)))
 2964         return(NULL);
 2965 
 2966     /* check if an attribute with the same name exists */
 2967     if (prop-&gt;ns == NULL)
 2968         attr = xmlHasNsProp(cur-&gt;parent, prop-&gt;name, NULL);
 2969     else
 2970         attr = xmlHasNsProp(cur-&gt;parent, prop-&gt;name, prop-&gt;ns-&gt;href);
 2971 
 2972     if (prop-&gt;doc != cur-&gt;doc) {
 2973         xmlSetTreeDoc(prop, cur-&gt;doc);
</pre>
<hr />
<pre>
 3647     while (node != NULL) {
 3648         if (node-&gt;type == XML_ELEMENT_NODE)
 3649             return(node);
 3650         node = node-&gt;next;
 3651     }
 3652     return(NULL);
 3653 }
 3654 
 3655 #endif /* LIBXML_TREE_ENABLED */
 3656 
 3657 /**
 3658  * xmlFreeNodeList:
 3659  * @cur:  the first node in the list
 3660  *
 3661  * Free a node and all its siblings, this is a recursive behaviour, all
 3662  * the children are freed too.
 3663  */
 3664 void
 3665 xmlFreeNodeList(xmlNodePtr cur) {
 3666     xmlNodePtr next;
<span class="line-added"> 3667     xmlNodePtr parent;</span>
 3668     xmlDictPtr dict = NULL;
<span class="line-added"> 3669     size_t depth = 0;</span>
 3670 
 3671     if (cur == NULL) return;
 3672     if (cur-&gt;type == XML_NAMESPACE_DECL) {
 3673     xmlFreeNsList((xmlNsPtr) cur);
 3674     return;
 3675     }
 3676     if ((cur-&gt;type == XML_DOCUMENT_NODE) ||
 3677 #ifdef LIBXML_DOCB_ENABLED
 3678     (cur-&gt;type == XML_DOCB_DOCUMENT_NODE) ||
 3679 #endif
 3680     (cur-&gt;type == XML_HTML_DOCUMENT_NODE)) {
 3681     xmlFreeDoc((xmlDocPtr) cur);
 3682     return;
 3683     }
 3684     if (cur-&gt;doc != NULL) dict = cur-&gt;doc-&gt;dict;
<span class="line-modified"> 3685     while (1) {</span>
<span class="line-added"> 3686         while ((cur-&gt;children != NULL) &amp;&amp;</span>
<span class="line-added"> 3687                (cur-&gt;type != XML_DTD_NODE) &amp;&amp;</span>
<span class="line-added"> 3688                (cur-&gt;type != XML_ENTITY_REF_NODE)) {</span>
<span class="line-added"> 3689             cur = cur-&gt;children;</span>
<span class="line-added"> 3690             depth += 1;</span>
<span class="line-added"> 3691         }</span>
<span class="line-added"> 3692 </span>
 3693         next = cur-&gt;next;
<span class="line-added"> 3694         parent = cur-&gt;parent;</span>
 3695     if (cur-&gt;type != XML_DTD_NODE) {
 3696 
 3697         if ((__xmlRegisterCallbacks) &amp;&amp; (xmlDeregisterNodeDefaultValue))
 3698         xmlDeregisterNodeDefaultValue(cur);
 3699 



 3700         if (((cur-&gt;type == XML_ELEMENT_NODE) ||
 3701          (cur-&gt;type == XML_XINCLUDE_START) ||
 3702          (cur-&gt;type == XML_XINCLUDE_END)) &amp;&amp;
 3703         (cur-&gt;properties != NULL))
 3704         xmlFreePropList(cur-&gt;properties);
 3705         if ((cur-&gt;type != XML_ELEMENT_NODE) &amp;&amp;
 3706         (cur-&gt;type != XML_XINCLUDE_START) &amp;&amp;
 3707         (cur-&gt;type != XML_XINCLUDE_END) &amp;&amp;
 3708         (cur-&gt;type != XML_ENTITY_REF_NODE) &amp;&amp;
 3709         (cur-&gt;content != (xmlChar *) &amp;(cur-&gt;properties))) {
 3710         DICT_FREE(cur-&gt;content)
 3711         }
 3712         if (((cur-&gt;type == XML_ELEMENT_NODE) ||
 3713              (cur-&gt;type == XML_XINCLUDE_START) ||
 3714          (cur-&gt;type == XML_XINCLUDE_END)) &amp;&amp;
 3715         (cur-&gt;nsDef != NULL))
 3716         xmlFreeNsList(cur-&gt;nsDef);
 3717 
 3718         /*
 3719          * When a node is a text node or a comment, it uses a global static
 3720          * variable for the name of the node.
 3721          * Otherwise the node name might come from the document&#39;s
 3722          * dictionary
 3723          */
 3724         if ((cur-&gt;name != NULL) &amp;&amp;
 3725         (cur-&gt;type != XML_TEXT_NODE) &amp;&amp;
 3726         (cur-&gt;type != XML_COMMENT_NODE))
 3727         DICT_FREE(cur-&gt;name)
 3728         xmlFree(cur);
 3729     }
<span class="line-added"> 3730 </span>
<span class="line-added"> 3731         if (next != NULL) {</span>
 3732     cur = next;
<span class="line-added"> 3733         } else {</span>
<span class="line-added"> 3734             if ((depth == 0) || (parent == NULL))</span>
<span class="line-added"> 3735                 break;</span>
<span class="line-added"> 3736             depth -= 1;</span>
<span class="line-added"> 3737             cur = parent;</span>
<span class="line-added"> 3738             cur-&gt;children = NULL;</span>
<span class="line-added"> 3739         }</span>
 3740     }
 3741 }
 3742 
 3743 /**
 3744  * xmlFreeNode:
 3745  * @cur:  the node
 3746  *
 3747  * Free a node, this is a recursive behaviour, all the children are freed too.
 3748  * This doesn&#39;t unlink the child from the list, use xmlUnlinkNode() first.
 3749  */
 3750 void
 3751 xmlFreeNode(xmlNodePtr cur) {
 3752     xmlDictPtr dict = NULL;
 3753 
 3754     if (cur == NULL) return;
 3755 
 3756     /* use xmlFreeDtd for DTD nodes */
 3757     if (cur-&gt;type == XML_DTD_NODE) {
 3758     xmlFreeDtd((xmlDtdPtr) cur);
 3759     return;
</pre>
<hr />
<pre>
 4049          * and add it at the top of the new tree
 4050          */
 4051         ns = xmlSearchNs(cur-&gt;doc, cur-&gt;parent, cur-&gt;ns-&gt;prefix);
 4052         if (ns != NULL) {
 4053           xmlNodePtr root = target;
 4054           xmlNodePtr pred = NULL;
 4055 
 4056           while (root-&gt;parent != NULL) {
 4057             pred = root;
 4058             root = root-&gt;parent;
 4059           }
 4060           if (root == (xmlNodePtr) target-&gt;doc) {
 4061             /* correct possibly cycling above the document elt */
 4062             root = pred;
 4063           }
 4064           ret-&gt;ns = xmlNewNs(root, ns-&gt;href, ns-&gt;prefix);
 4065         }
 4066       } else {
 4067         /*
 4068          * we have to find something appropriate here since
<span class="line-modified"> 4069          * we cant be sure, that the namespace we found is identified</span>
 4070          * by the prefix
 4071          */
 4072         if (xmlStrEqual(ns-&gt;href, cur-&gt;ns-&gt;href)) {
 4073           /* this is the nice case */
 4074           ret-&gt;ns = ns;
 4075         } else {
 4076           /*
<span class="line-modified"> 4077            * we are in trouble: we need a new reconciled namespace.</span>
 4078            * This is expensive
 4079            */
<span class="line-modified"> 4080           ret-&gt;ns = xmlNewReconciledNs(target-&gt;doc, target, cur-&gt;ns);</span>
 4081         }
 4082       }
 4083 
 4084     } else
 4085         ret-&gt;ns = NULL;
 4086 
 4087     if (cur-&gt;children != NULL) {
 4088     xmlNodePtr tmp;
 4089 
 4090     ret-&gt;children = xmlStaticCopyNodeList(cur-&gt;children, ret-&gt;doc, (xmlNodePtr) ret);
 4091     ret-&gt;last = NULL;
 4092     tmp = ret-&gt;children;
 4093     while (tmp != NULL) {
 4094         /* tmp-&gt;parent = (xmlNodePtr)ret; */
 4095         if (tmp-&gt;next == NULL)
 4096             ret-&gt;last = tmp;
 4097         tmp = tmp-&gt;next;
 4098     }
 4099     }
 4100     /*
</pre>
<hr />
<pre>
 4153     if (p == NULL) {
 4154         ret = p = q;
 4155     } else {
 4156         p-&gt;next = q;
 4157         q-&gt;prev = p;
 4158         p = q;
 4159     }
 4160     cur = cur-&gt;next;
 4161     }
 4162     return(ret);
 4163 }
 4164 
 4165 /*
 4166  * NOTE about the CopyNode operations !
 4167  *
 4168  * They are split into external and internal parts for one
 4169  * tricky reason: namespaces. Doing a direct copy of a node
 4170  * say RPM:Copyright without changing the namespace pointer to
 4171  * something else can produce stale links. One way to do it is
 4172  * to keep a reference counter but this doesn&#39;t work as soon
<span class="line-modified"> 4173  * as one moves the element or the subtree out of the scope of</span>
<span class="line-modified"> 4174  * the existing namespace. The actual solution seems to be to add</span>
 4175  * a copy of the namespace at the top of the copied tree if
 4176  * not available in the subtree.
 4177  * Hence two functions, the public front-end call the inner ones
 4178  * The argument &quot;recursive&quot; normally indicates a recursive copy
 4179  * of the node with values 0 (no) and 1 (yes).  For XInclude,
 4180  * however, we allow a value of 2 to indicate copy properties and
 4181  * namespace info, but don&#39;t recurse on children.
 4182  */
 4183 
 4184 static xmlNodePtr
 4185 xmlStaticCopyNode(xmlNodePtr node, xmlDocPtr doc, xmlNodePtr parent,
 4186                   int extended) {
 4187     xmlNodePtr ret;
 4188 
 4189     if (node == NULL) return(NULL);
 4190     switch (node-&gt;type) {
 4191         case XML_TEXT_NODE:
 4192         case XML_CDATA_SECTION_NODE:
 4193         case XML_ELEMENT_NODE:
 4194         case XML_DOCUMENT_FRAG_NODE:
</pre>
<hr />
<pre>
 4279          (node-&gt;type == XML_XINCLUDE_START)) &amp;&amp; (node-&gt;nsDef != NULL))
 4280         ret-&gt;nsDef = xmlCopyNamespaceList(node-&gt;nsDef);
 4281 
 4282     if (node-&gt;ns != NULL) {
 4283         xmlNsPtr ns;
 4284 
 4285     ns = xmlSearchNs(doc, ret, node-&gt;ns-&gt;prefix);
 4286     if (ns == NULL) {
 4287         /*
 4288          * Humm, we are copying an element whose namespace is defined
 4289          * out of the new tree scope. Search it in the original tree
 4290          * and add it at the top of the new tree
 4291          */
 4292         ns = xmlSearchNs(node-&gt;doc, node, node-&gt;ns-&gt;prefix);
 4293         if (ns != NULL) {
 4294             xmlNodePtr root = ret;
 4295 
 4296         while (root-&gt;parent != NULL) root = root-&gt;parent;
 4297         ret-&gt;ns = xmlNewNs(root, ns-&gt;href, ns-&gt;prefix);
 4298         } else {
<span class="line-modified"> 4299             ret-&gt;ns = xmlNewReconciledNs(doc, ret, node-&gt;ns);</span>
 4300         }
 4301     } else {
 4302         /*
 4303          * reference the existing namespace definition in our own tree.
 4304          */
 4305         ret-&gt;ns = ns;
 4306     }
 4307     }
 4308     if (((node-&gt;type == XML_ELEMENT_NODE) ||
 4309          (node-&gt;type == XML_XINCLUDE_START)) &amp;&amp; (node-&gt;properties != NULL))
 4310         ret-&gt;properties = xmlCopyPropList(ret, node-&gt;properties);
 4311     if (node-&gt;type == XML_ENTITY_REF_NODE) {
 4312     if ((doc == NULL) || (node-&gt;doc != doc)) {
 4313         /*
 4314          * The copied node will go into a separate document, so
 4315          * to avoid dangling references to the ENTITY_DECL node
 4316          * we cannot keep the reference. Try to find it in the
 4317          * target document.
 4318          */
 4319         ret-&gt;children = (xmlNodePtr) xmlGetDocEntity(doc, ret-&gt;name);
</pre>
<hr />
<pre>
 4718             name = (const char *) cur-&gt;name;
 4719             if (cur-&gt;ns) {
 4720         if (cur-&gt;ns-&gt;prefix != NULL) {
 4721                     snprintf(nametemp, sizeof(nametemp) - 1, &quot;%s:%s&quot;,
 4722             (char *)cur-&gt;ns-&gt;prefix, (char *)cur-&gt;name);
 4723             nametemp[sizeof(nametemp) - 1] = 0;
 4724             name = nametemp;
 4725         } else {
 4726             /*
 4727             * We cannot express named elements in the default
 4728             * namespace, so use &quot;*&quot;.
 4729             */
 4730             generic = 1;
 4731             name = &quot;*&quot;;
 4732         }
 4733             }
 4734             next = cur-&gt;parent;
 4735 
 4736             /*
 4737              * Thumbler index computation
<span class="line-modified"> 4738          * TODO: the occurrence test seems bogus for namespaced names</span>
 4739              */
 4740             tmp = cur-&gt;prev;
 4741             while (tmp != NULL) {
 4742                 if ((tmp-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
 4743             (generic ||
 4744              (xmlStrEqual(cur-&gt;name, tmp-&gt;name) &amp;&amp;
 4745              ((tmp-&gt;ns == cur-&gt;ns) ||
 4746               ((tmp-&gt;ns != NULL) &amp;&amp; (cur-&gt;ns != NULL) &amp;&amp;
 4747                (xmlStrEqual(cur-&gt;ns-&gt;prefix, tmp-&gt;ns-&gt;prefix)))))))
 4748                     occur++;
 4749                 tmp = tmp-&gt;prev;
 4750             }
 4751             if (occur == 0) {
 4752                 tmp = cur-&gt;next;
 4753                 while (tmp != NULL &amp;&amp; occur == 0) {
 4754                     if ((tmp-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
 4755             (generic ||
 4756              (xmlStrEqual(cur-&gt;name, tmp-&gt;name) &amp;&amp;
 4757              ((tmp-&gt;ns == cur-&gt;ns) ||
 4758               ((tmp-&gt;ns != NULL) &amp;&amp; (cur-&gt;ns != NULL) &amp;&amp;
</pre>
<hr />
<pre>
 6213                 cur = cur-&gt;next;
 6214             }
 6215             if (orig != node) {
 6216                 cur = node-&gt;ns;
 6217                 if (cur != NULL) {
 6218                     if ((cur-&gt;href != NULL) &amp;&amp; (href != NULL) &amp;&amp;
 6219                         (xmlStrEqual(cur-&gt;href, href))) {
 6220             if (((!is_attr) || (cur-&gt;prefix != NULL)) &amp;&amp;
 6221                     (xmlNsInScope(doc, orig, node, cur-&gt;prefix) == 1))
 6222                 return (cur);
 6223                     }
 6224                 }
 6225             }
 6226         }
 6227         node = node-&gt;parent;
 6228     }
 6229     return (NULL);
 6230 }
 6231 
 6232 /**
<span class="line-modified"> 6233  * xmlNewReconciledNs:</span>
 6234  * @doc:  the document
 6235  * @tree:  a node expected to hold the new namespace
 6236  * @ns:  the original namespace
 6237  *
 6238  * This function tries to locate a namespace definition in a tree
 6239  * ancestors, or create a new namespace definition node similar to
 6240  * @ns trying to reuse the same prefix. However if the given prefix is
 6241  * null (default namespace) or reused within the subtree defined by
 6242  * @tree or on one of its ancestors then a new prefix is generated.
 6243  * Returns the (new) namespace definition or NULL in case of error
 6244  */
 6245 static xmlNsPtr
<span class="line-modified"> 6246 xmlNewReconciledNs(xmlDocPtr doc, xmlNodePtr tree, xmlNsPtr ns) {</span>
 6247     xmlNsPtr def;
 6248     xmlChar prefix[50];
 6249     int counter = 1;
 6250 
 6251     if ((tree == NULL) || (tree-&gt;type != XML_ELEMENT_NODE)) {
 6252 #ifdef DEBUG_TREE
 6253         xmlGenericError(xmlGenericErrorContext,
<span class="line-modified"> 6254         &quot;xmlNewReconciledNs : tree == NULL\n&quot;);</span>
 6255 #endif
 6256     return(NULL);
 6257     }
 6258     if ((ns == NULL) || (ns-&gt;type != XML_NAMESPACE_DECL)) {
 6259 #ifdef DEBUG_TREE
 6260         xmlGenericError(xmlGenericErrorContext,
<span class="line-modified"> 6261         &quot;xmlNewReconciledNs : ns == NULL\n&quot;);</span>
 6262 #endif
 6263     return(NULL);
 6264     }
 6265     /*
 6266      * Search an existing namespace definition inherited.
 6267      */
 6268     def = xmlSearchNsByHref(doc, tree, ns-&gt;href);
 6269     if (def != NULL)
 6270         return(def);
 6271 
 6272     /*
 6273      * Find a close prefix which is not already in use.
 6274      * Let&#39;s strip namespace prefixes longer than 20 chars !
 6275      */
 6276     if (ns-&gt;prefix == NULL)
 6277     snprintf((char *) prefix, sizeof(prefix), &quot;default&quot;);
 6278     else
 6279     snprintf((char *) prefix, sizeof(prefix), &quot;%.20s&quot;, (char *)ns-&gt;prefix);
 6280 
 6281     def = xmlSearchNs(doc, tree, prefix);
</pre>
<hr />
<pre>
 6343             return(-1);
 6344         }
 6345         newNs = (xmlNsPtr *) xmlMalloc(sizeCache *
 6346                            sizeof(xmlNsPtr));
 6347         if (newNs == NULL) {
 6348             xmlTreeErrMemory(&quot;fixing namespaces&quot;);
 6349             xmlFree(oldNs);
 6350             return(-1);
 6351         }
 6352         }
 6353         for (i = 0;i &lt; nbCache;i++) {
 6354             if (oldNs[i] == node-&gt;ns) {
 6355             node-&gt;ns = newNs[i];
 6356             break;
 6357         }
 6358         }
 6359         if (i == nbCache) {
 6360             /*
 6361          * OK we need to recreate a new namespace definition
 6362          */
<span class="line-modified"> 6363         n = xmlNewReconciledNs(doc, tree, node-&gt;ns);</span>
 6364         if (n != NULL) { /* :-( what if else ??? */
 6365             /*
 6366              * check if we need to grow the cache buffers.
 6367              */
 6368             if (sizeCache &lt;= nbCache) {
 6369                 sizeCache *= 2;
 6370             oldNs = (xmlNsPtr *) xmlRealloc(oldNs, sizeCache *
 6371                                            sizeof(xmlNsPtr));
 6372                 if (oldNs == NULL) {
 6373                 xmlTreeErrMemory(&quot;fixing namespaces&quot;);
 6374                 xmlFree(newNs);
 6375                 return(-1);
 6376             }
 6377             newNs = (xmlNsPtr *) xmlRealloc(newNs, sizeCache *
 6378                                            sizeof(xmlNsPtr));
 6379                 if (newNs == NULL) {
 6380                 xmlTreeErrMemory(&quot;fixing namespaces&quot;);
 6381                 xmlFree(oldNs);
 6382                 return(-1);
 6383             }
 6384             }
 6385             newNs[nbCache] = n;
 6386             oldNs[nbCache++] = node-&gt;ns;
 6387             node-&gt;ns = n;
 6388                 }
 6389         }
 6390     }
 6391     /*
<span class="line-modified"> 6392      * now check for namespace held by attributes on the node.</span>
 6393      */
 6394     if (node-&gt;type == XML_ELEMENT_NODE) {
 6395         attr = node-&gt;properties;
 6396         while (attr != NULL) {
 6397         if (attr-&gt;ns != NULL) {
 6398             /*
 6399              * initialize the cache if needed
 6400              */
 6401             if (sizeCache == 0) {
 6402             sizeCache = 10;
 6403             oldNs = (xmlNsPtr *) xmlMalloc(sizeCache *
 6404                                sizeof(xmlNsPtr));
 6405             if (oldNs == NULL) {
 6406                 xmlTreeErrMemory(&quot;fixing namespaces&quot;);
 6407                 return(-1);
 6408             }
 6409             newNs = (xmlNsPtr *) xmlMalloc(sizeCache *
 6410                                sizeof(xmlNsPtr));
 6411             if (newNs == NULL) {
 6412                 xmlTreeErrMemory(&quot;fixing namespaces&quot;);
 6413                 xmlFree(oldNs);
 6414                 return(-1);
 6415             }
 6416             }
 6417             for (i = 0;i &lt; nbCache;i++) {
 6418             if (oldNs[i] == attr-&gt;ns) {
 6419                 attr-&gt;ns = newNs[i];
 6420                 break;
 6421             }
 6422             }
 6423             if (i == nbCache) {
 6424             /*
 6425              * OK we need to recreate a new namespace definition
 6426              */
<span class="line-modified"> 6427             n = xmlNewReconciledNs(doc, tree, attr-&gt;ns);</span>
 6428             if (n != NULL) { /* :-( what if else ??? */
 6429                 /*
 6430                  * check if we need to grow the cache buffers.
 6431                  */
 6432                 if (sizeCache &lt;= nbCache) {
 6433                 sizeCache *= 2;
 6434                 oldNs = (xmlNsPtr *) xmlRealloc(oldNs,
 6435                            sizeCache * sizeof(xmlNsPtr));
 6436                 if (oldNs == NULL) {
 6437                     xmlTreeErrMemory(&quot;fixing namespaces&quot;);
 6438                     xmlFree(newNs);
 6439                     return(-1);
 6440                 }
 6441                 newNs = (xmlNsPtr *) xmlRealloc(newNs,
 6442                            sizeCache * sizeof(xmlNsPtr));
 6443                 if (newNs == NULL) {
 6444                     xmlTreeErrMemory(&quot;fixing namespaces&quot;);
 6445                     xmlFree(oldNs);
 6446                     return(-1);
 6447                 }
</pre>
<hr />
<pre>
 7960     ret-&gt;next = map-&gt;first;
 7961     map-&gt;first = ret;
 7962     }
 7963 
 7964     ret-&gt;oldNs = oldNs;
 7965     ret-&gt;newNs = newNs;
 7966     ret-&gt;shadowDepth = -1;
 7967     ret-&gt;depth = depth;
 7968     return (ret);
 7969 }
 7970 
 7971 /*
 7972 * xmlDOMWrapStoreNs:
 7973 * @doc: the doc
 7974 * @nsName: the namespace name
 7975 * @prefix: the prefix
 7976 *
 7977 * Creates or reuses an xmlNs struct on doc-&gt;oldNs with
 7978 * the given prefix and namespace name.
 7979 *
<span class="line-modified"> 7980 * Returns the acquired ns struct or NULL in case of an API</span>
 7981 *         or internal error.
 7982 */
 7983 static xmlNsPtr
 7984 xmlDOMWrapStoreNs(xmlDocPtr doc,
 7985            const xmlChar *nsName,
 7986            const xmlChar *prefix)
 7987 {
 7988     xmlNsPtr ns;
 7989 
 7990     if (doc == NULL)
 7991     return (NULL);
 7992     ns = xmlTreeEnsureXMLDecl(doc);
 7993     if (ns == NULL)
 7994     return (NULL);
 7995     if (ns-&gt;next != NULL) {
 7996     /* Reuse. */
 7997     ns = ns-&gt;next;
 7998     while (ns != NULL) {
 7999         if (((ns-&gt;prefix == prefix) ||
 8000         xmlStrEqual(ns-&gt;prefix, prefix)) &amp;&amp;
</pre>
<hr />
<pre>
 8574         while (ns2-&gt;next != NULL)
 8575         ns2 = ns2-&gt;next;
 8576         ns2-&gt;next = ret;
 8577     }
 8578     return (ret);
 8579 ns_next_prefix:
 8580     counter++;
 8581     if (counter &gt; 1000)
 8582         return (NULL);
 8583     if (prefix == NULL) {
 8584         snprintf((char *) buf, sizeof(buf),
 8585         &quot;ns_%d&quot;, counter);
 8586     } else
 8587         snprintf((char *) buf, sizeof(buf),
 8588         &quot;%.30s_%d&quot;, (char *)prefix, counter);
 8589     pref = BAD_CAST buf;
 8590     }
 8591 }
 8592 
 8593 /*
<span class="line-modified"> 8594 * xmlDOMWrapNSNormAcquireNormalizedNs:</span>
 8595 * @doc: the doc
 8596 * @elem: the element-node to declare namespaces on
 8597 * @ns: the ns-struct to use for the search
 8598 * @retNs: the found/created ns-struct
 8599 * @nsMap: the ns-map
 8600 * @depth: the current tree depth
 8601 * @ancestorsOnly: search in ancestor ns-decls only
 8602 * @prefixed: if the searched ns-decl must have a prefix (for attributes)
 8603 *
 8604 * Searches for a matching ns-name in the ns-decls of @nsMap, if not
 8605 * found it will either declare it on @elem, or store it in doc-&gt;oldNs.
 8606 * If a new ns-decl needs to be declared on @elem, it tries to use the
 8607 * @ns-&gt;prefix for it, if this prefix is already in use on @elem, it will
 8608 * change the prefix or the new ns-decl.
 8609 *
 8610 * Returns 0 if succeeded, -1 otherwise and on API/internal errors.
 8611 */
 8612 static int
<span class="line-modified"> 8613 xmlDOMWrapNSNormAcquireNormalizedNs(xmlDocPtr doc,</span>
 8614                    xmlNodePtr elem,
 8615                    xmlNsPtr ns,
 8616                    xmlNsPtr *retNs,
 8617                    xmlNsMapPtr *nsMap,
 8618 
 8619                    int depth,
 8620                    int ancestorsOnly,
 8621                    int prefixed)
 8622 {
 8623     xmlNsMapItemPtr mi;
 8624 
 8625     if ((doc == NULL) || (ns == NULL) || (retNs == NULL) ||
 8626     (nsMap == NULL))
 8627     return (-1);
 8628 
 8629     *retNs = NULL;
 8630     /*
 8631     * Handle XML namespace.
 8632     */
 8633     if (IS_STR_XML(ns-&gt;prefix)) {
</pre>
<hr />
<pre>
 8892                }
 8893            }
 8894         }
 8895         /*
 8896         * Adopt ns-references.
 8897         */
 8898         if (XML_NSMAP_NOTEMPTY(nsMap)) {
 8899             /*
 8900             * Search for a mapping.
 8901             */
 8902             XML_NSMAP_FOREACH(nsMap, mi) {
 8903             if ((mi-&gt;shadowDepth == -1) &amp;&amp;
 8904                 (cur-&gt;ns == mi-&gt;oldNs)) {
 8905 
 8906                 cur-&gt;ns = mi-&gt;newNs;
 8907                 goto ns_end;
 8908             }
 8909             }
 8910         }
 8911         /*
<span class="line-modified"> 8912         * Acquire a normalized ns-decl and add it to the map.</span>
 8913         */
<span class="line-modified"> 8914         if (xmlDOMWrapNSNormAcquireNormalizedNs(doc, curElem,</span>
 8915             cur-&gt;ns, &amp;ns,
 8916             &amp;nsMap, depth,
 8917             ancestorsOnly,
 8918             (cur-&gt;type == XML_ATTRIBUTE_NODE) ? 1 : 0) == -1)
 8919             goto internal_error;
 8920         cur-&gt;ns = ns;
 8921 
 8922 ns_end:
 8923         if ((cur-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
 8924             (cur-&gt;properties != NULL)) {
 8925             /*
 8926             * Process attributes.
 8927             */
 8928             cur = (xmlNodePtr) cur-&gt;properties;
 8929             continue;
 8930         }
 8931         break;
 8932         default:
 8933         goto next_sibling;
 8934     }
</pre>
<hr />
<pre>
 9032     int parnsdone;
 9033     /* @ancestorsOnly should be set per option. */
 9034     int ancestorsOnly = 0;
 9035 
 9036     /*
 9037     * Optimize string adoption for equal or none dicts.
 9038     */
 9039     if ((sourceDoc != NULL) &amp;&amp;
 9040     (sourceDoc-&gt;dict == destDoc-&gt;dict))
 9041     adoptStr = 0;
 9042     else
 9043     adoptStr = 1;
 9044 
 9045     /*
 9046     * Get the ns-map from the context if available.
 9047     */
 9048     if (ctxt)
 9049     nsMap = (xmlNsMapPtr) ctxt-&gt;namespaceMap;
 9050     /*
 9051     * Disable search for ns-decls in the parent-axis of the
<span class="line-modified"> 9052     * destination element, if:</span>
 9053     * 1) there&#39;s no destination parent
 9054     * 2) custom ns-reference handling is used
 9055     */
 9056     if ((destParent == NULL) ||
 9057     (ctxt &amp;&amp; ctxt-&gt;getNsForNodeFunc))
 9058     {
 9059     parnsdone = 1;
 9060     } else
 9061     parnsdone = 0;
 9062 
 9063     cur = node;
 9064     if ((cur != NULL) &amp;&amp; (cur-&gt;type == XML_NAMESPACE_DECL))
 9065     goto internal_error;
 9066 
 9067     while (cur != NULL) {
 9068     /*
 9069     * Paranoid source-doc sanity check.
 9070     */
 9071     if (cur-&gt;doc != sourceDoc) {
 9072         /*
</pre>
<hr />
<pre>
 9177         }
 9178         /*
 9179         * No matching namespace in scope. We need a new one.
 9180         */
 9181         if ((ctxt) &amp;&amp; (ctxt-&gt;getNsForNodeFunc)) {
 9182             /*
 9183             * User-defined behaviour.
 9184             */
 9185             ns = ctxt-&gt;getNsForNodeFunc(ctxt, cur,
 9186             cur-&gt;ns-&gt;href, cur-&gt;ns-&gt;prefix);
 9187             /*
 9188             * Insert mapping if ns is available; it&#39;s the users fault
 9189             * if not.
 9190             */
 9191             if (xmlDOMWrapNsMapAddItem(&amp;nsMap, -1,
 9192                 cur-&gt;ns, ns, XML_TREE_NSMAP_CUSTOM) == NULL)
 9193             goto internal_error;
 9194             cur-&gt;ns = ns;
 9195         } else {
 9196             /*
<span class="line-modified"> 9197             * Acquire a normalized ns-decl and add it to the map.</span>
 9198             */
<span class="line-modified"> 9199             if (xmlDOMWrapNSNormAcquireNormalizedNs(destDoc,</span>
 9200             /* ns-decls on curElem or on destDoc-&gt;oldNs */
 9201             destParent ? curElem : NULL,
 9202             cur-&gt;ns, &amp;ns,
 9203             &amp;nsMap, depth,
 9204             ancestorsOnly,
 9205             /* ns-decls must be prefixed for attributes. */
 9206             (cur-&gt;type == XML_ATTRIBUTE_NODE) ? 1 : 0) == -1)
 9207             goto internal_error;
 9208             cur-&gt;ns = ns;
 9209         }
 9210 ns_end:
 9211         /*
 9212         * Further node properties.
 9213         * TODO: Is this all?
 9214         */
 9215         XML_TREE_ADOPT_STR(cur-&gt;name)
 9216         if (cur-&gt;type == XML_ELEMENT_NODE) {
 9217             cur-&gt;psvi = NULL;
 9218             cur-&gt;line = 0;
 9219             cur-&gt;extra = 0;
</pre>
<hr />
<pre>
 9233             */
 9234             if ((sourceDoc != NULL) &amp;&amp;
 9235             (((xmlAttrPtr) cur)-&gt;atype == XML_ATTRIBUTE_ID))
 9236             {
 9237             xmlRemoveID(sourceDoc, (xmlAttrPtr) cur);
 9238             }
 9239             ((xmlAttrPtr) cur)-&gt;atype = 0;
 9240             ((xmlAttrPtr) cur)-&gt;psvi = NULL;
 9241         }
 9242         break;
 9243         case XML_TEXT_NODE:
 9244         case XML_CDATA_SECTION_NODE:
 9245         /*
 9246         * This puts the content in the dest dict, only if
 9247         * it was previously in the source dict.
 9248         */
 9249         XML_TREE_ADOPT_STR_2(cur-&gt;content)
 9250         goto leave_node;
 9251         case XML_ENTITY_REF_NODE:
 9252         /*
<span class="line-modified"> 9253         * Remove reference to the entity-node.</span>
 9254         */
 9255         cur-&gt;content = NULL;
 9256         cur-&gt;children = NULL;
 9257         cur-&gt;last = NULL;
 9258         if ((destDoc-&gt;intSubset) || (destDoc-&gt;extSubset)) {
 9259             xmlEntityPtr ent;
 9260             /*
 9261             * Assign new entity-node if available.
 9262             */
 9263             ent = xmlGetDocEntity(destDoc, cur-&gt;name);
 9264             if (ent != NULL) {
 9265             cur-&gt;content = ent-&gt;content;
 9266             cur-&gt;children = (xmlNodePtr) ent;
 9267             cur-&gt;last = (xmlNodePtr) ent;
 9268             }
 9269         }
 9270         goto leave_node;
 9271         case XML_PI_NODE:
 9272         XML_TREE_ADOPT_STR(cur-&gt;name)
 9273         XML_TREE_ADOPT_STR_2(cur-&gt;content)
</pre>
<hr />
<pre>
 9467         goto internal_error;
 9468         break;
 9469         case XML_ELEMENT_NODE:
 9470         case XML_TEXT_NODE:
 9471         case XML_CDATA_SECTION_NODE:
 9472         case XML_COMMENT_NODE:
 9473         case XML_PI_NODE:
 9474         case XML_DOCUMENT_FRAG_NODE:
 9475         case XML_ENTITY_REF_NODE:
 9476         case XML_ENTITY_NODE:
 9477         /*
 9478         * Nodes of xmlNode structure.
 9479         */
 9480         clone = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 9481         if (clone == NULL) {
 9482             xmlTreeErrMemory(&quot;xmlDOMWrapCloneNode(): allocating a node&quot;);
 9483             goto internal_error;
 9484         }
 9485         memset(clone, 0, sizeof(xmlNode));
 9486         /*
<span class="line-modified"> 9487         * Set hierarchical links.</span>
 9488         */
 9489         if (resultClone != NULL) {
 9490             clone-&gt;parent = parentClone;
 9491             if (prevClone) {
 9492             prevClone-&gt;next = clone;
 9493             clone-&gt;prev = prevClone;
 9494             } else
 9495             parentClone-&gt;children = clone;
 9496         } else
 9497             resultClone = clone;
 9498 
 9499         break;
 9500         case XML_ATTRIBUTE_NODE:
 9501         /*
 9502         * Attributes (xmlAttr).
 9503         */
 9504         clone = (xmlNodePtr) xmlMalloc(sizeof(xmlAttr));
 9505         if (clone == NULL) {
 9506             xmlTreeErrMemory(&quot;xmlDOMWrapCloneNode(): allocating an attr-node&quot;);
 9507             goto internal_error;
 9508         }
 9509         memset(clone, 0, sizeof(xmlAttr));
 9510         /*
<span class="line-modified"> 9511         * Set hierarchical links.</span>
 9512         * TODO: Change this to add to the end of attributes.
 9513         */
 9514         if (resultClone != NULL) {
 9515             clone-&gt;parent = parentClone;
 9516             if (prevClone) {
 9517             prevClone-&gt;next = clone;
 9518             clone-&gt;prev = prevClone;
 9519             } else
 9520             parentClone-&gt;properties = (xmlAttrPtr) clone;
 9521         } else
 9522             resultClone = clone;
 9523         break;
 9524         default:
 9525         /*
 9526         * TODO QUESTION: Any other nodes expected?
 9527         */
 9528         goto internal_error;
 9529     }
 9530 
 9531     clone-&gt;type = cur-&gt;type;
</pre>
<hr />
<pre>
 9719         }
 9720     }
 9721     /*
 9722     * No matching namespace in scope. We need a new one.
 9723     */
 9724     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;getNsForNodeFunc != NULL)) {
 9725         /*
 9726         * User-defined behaviour.
 9727         */
 9728         ns = ctxt-&gt;getNsForNodeFunc(ctxt, cur,
 9729         cur-&gt;ns-&gt;href, cur-&gt;ns-&gt;prefix);
 9730         /*
 9731         * Add user&#39;s mapping.
 9732         */
 9733         if (xmlDOMWrapNsMapAddItem(&amp;nsMap, -1,
 9734         cur-&gt;ns, ns, XML_TREE_NSMAP_CUSTOM) == NULL)
 9735         goto internal_error;
 9736         clone-&gt;ns = ns;
 9737     } else {
 9738         /*
<span class="line-modified"> 9739         * Acquire a normalized ns-decl and add it to the map.</span>
 9740         */
<span class="line-modified"> 9741         if (xmlDOMWrapNSNormAcquireNormalizedNs(destDoc,</span>
 9742         /* ns-decls on curElem or on destDoc-&gt;oldNs */
 9743         destParent ? curElem : NULL,
 9744         cur-&gt;ns, &amp;ns,
 9745         &amp;nsMap, depth,
 9746         /* if we need to search only in the ancestor-axis */
 9747         ancestorsOnly,
 9748         /* ns-decls must be prefixed for attributes. */
 9749         (cur-&gt;type == XML_ATTRIBUTE_NODE) ? 1 : 0) == -1)
 9750         goto internal_error;
 9751         clone-&gt;ns = ns;
 9752     }
 9753 
 9754 end_ns_reference:
 9755 
 9756     /*
 9757     * Some post-processing.
 9758     *
 9759     * Handle ID attributes.
 9760     */
 9761     if ((clone-&gt;type == XML_ATTRIBUTE_NODE) &amp;&amp;
</pre>
<hr />
<pre>
 9958     XML_TREE_ADOPT_STR(attr-&gt;name);
 9959     attr-&gt;atype = 0;
 9960     attr-&gt;psvi = NULL;
 9961     /*
 9962     * Walk content.
 9963     */
 9964     if (attr-&gt;children == NULL)
 9965     return (0);
 9966     cur = attr-&gt;children;
 9967     if ((cur != NULL) &amp;&amp; (cur-&gt;type == XML_NAMESPACE_DECL))
 9968         goto internal_error;
 9969     while (cur != NULL) {
 9970     cur-&gt;doc = destDoc;
 9971     switch (cur-&gt;type) {
 9972         case XML_TEXT_NODE:
 9973         case XML_CDATA_SECTION_NODE:
 9974         XML_TREE_ADOPT_STR_2(cur-&gt;content)
 9975         break;
 9976         case XML_ENTITY_REF_NODE:
 9977         /*
<span class="line-modified"> 9978         * Remove reference to the entity-node.</span>
 9979         */
 9980         cur-&gt;content = NULL;
 9981         cur-&gt;children = NULL;
 9982         cur-&gt;last = NULL;
 9983         if ((destDoc-&gt;intSubset) || (destDoc-&gt;extSubset)) {
 9984             xmlEntityPtr ent;
 9985             /*
 9986             * Assign new entity-node if available.
 9987             */
 9988             ent = xmlGetDocEntity(destDoc, cur-&gt;name);
 9989             if (ent != NULL) {
 9990             cur-&gt;content = ent-&gt;content;
 9991             cur-&gt;children = (xmlNodePtr) ent;
 9992             cur-&gt;last = (xmlNodePtr) ent;
 9993             }
 9994         }
 9995         break;
 9996         default:
 9997         break;
 9998     }
</pre>
<hr />
<pre>
10096         return (xmlDOMWrapAdoptAttr(ctxt, sourceDoc,
10097         (xmlAttrPtr) node, destDoc, destParent, options));
10098     } else {
10099     xmlNodePtr cur = node;
10100     int adoptStr = 1;
10101 
10102     cur-&gt;doc = destDoc;
10103     /*
10104     * Optimize string adoption.
10105     */
10106     if ((sourceDoc != NULL) &amp;&amp;
10107         (sourceDoc-&gt;dict == destDoc-&gt;dict))
10108         adoptStr = 0;
10109     switch (node-&gt;type) {
10110         case XML_TEXT_NODE:
10111         case XML_CDATA_SECTION_NODE:
10112         XML_TREE_ADOPT_STR_2(node-&gt;content)
10113             break;
10114         case XML_ENTITY_REF_NODE:
10115         /*
<span class="line-modified">10116         * Remove reference to the entity-node.</span>
10117         */
10118         node-&gt;content = NULL;
10119         node-&gt;children = NULL;
10120         node-&gt;last = NULL;
10121         if ((destDoc-&gt;intSubset) || (destDoc-&gt;extSubset)) {
10122             xmlEntityPtr ent;
10123             /*
10124             * Assign new entity-node if available.
10125             */
10126             ent = xmlGetDocEntity(destDoc, node-&gt;name);
10127             if (ent != NULL) {
10128             node-&gt;content = ent-&gt;content;
10129             node-&gt;children = (xmlNodePtr) ent;
10130             node-&gt;last = (xmlNodePtr) ent;
10131             }
10132         }
10133         XML_TREE_ADOPT_STR(node-&gt;name)
10134         break;
10135         case XML_PI_NODE: {
10136         XML_TREE_ADOPT_STR(node-&gt;name)
</pre>
</td>
</tr>
</table>
<center><a href="timsort.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="trionan.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/pattern.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * pattern.c: Implemetation of selectors for nodes
   3  *
   4  * Reference:
   5  *   http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/
   6  *   to some extent
   7  *   http://www.w3.org/TR/1999/REC-xml-19991116
   8  *
   9  * See Copyright for the status of this software.
  10  *
  11  * daniel@veillard.com
  12  */
  13 
  14 /*
  15  * TODO:
  16  * - compilation flags to check for specific syntaxes
  17  *   using flags of xmlPatterncompile()
  18  * - making clear how pattern starting with / or . need to be handled,
  19  *   currently push(NULL, NULL) means a reset of the streaming context
  20  *   and indicating we are on / (the document node), probably need
  21  *   something similar for .
  22  * - get rid of the &quot;compile&quot; starting with lowercase
  23  * - DONE (2006-05-16): get rid of the Strdup/Strndup in case of dictionary
  24  */
  25 
  26 #define IN_LIBXML
  27 #include &quot;libxml.h&quot;
  28 
  29 #include &lt;string.h&gt;
  30 #include &lt;libxml/xmlmemory.h&gt;
  31 #include &lt;libxml/tree.h&gt;
  32 #include &lt;libxml/hash.h&gt;
  33 #include &lt;libxml/dict.h&gt;
  34 #include &lt;libxml/xmlerror.h&gt;
  35 #include &lt;libxml/parserInternals.h&gt;
  36 #include &lt;libxml/pattern.h&gt;
  37 
  38 #ifdef LIBXML_PATTERN_ENABLED
  39 
  40 /* #define DEBUG_STREAMING */
  41 
  42 #ifdef ERROR
  43 #undef ERROR
  44 #endif
  45 #define ERROR(a, b, c, d)
  46 #define ERROR5(a, b, c, d, e)
  47 
  48 #define XML_STREAM_STEP_DESC    1
  49 #define XML_STREAM_STEP_FINAL   2
  50 #define XML_STREAM_STEP_ROOT    4
  51 #define XML_STREAM_STEP_ATTR    8
  52 #define XML_STREAM_STEP_NODE    16
  53 #define XML_STREAM_STEP_IN_SET  32
  54 
  55 /*
  56 * NOTE: Those private flags (XML_STREAM_xxx) are used
  57 *   in _xmlStreamCtxt-&gt;flag. They extend the public
  58 *   xmlPatternFlags, so be carefull not to interfere with the
  59 *   reserved values for xmlPatternFlags.
  60 */
  61 #define XML_STREAM_FINAL_IS_ANY_NODE 1&lt;&lt;14
  62 #define XML_STREAM_FROM_ROOT 1&lt;&lt;15
  63 #define XML_STREAM_DESC 1&lt;&lt;16
  64 
  65 /*
  66 * XML_STREAM_ANY_NODE is used for comparison against
  67 * xmlElementType enums, to indicate a node of any type.
  68 */
  69 #define XML_STREAM_ANY_NODE 100
  70 
  71 #define XML_PATTERN_NOTPATTERN  (XML_PATTERN_XPATH | \
  72                  XML_PATTERN_XSSEL | \
  73                  XML_PATTERN_XSFIELD)
  74 
  75 #define XML_STREAM_XS_IDC(c) ((c)-&gt;flags &amp; \
  76     (XML_PATTERN_XSSEL | XML_PATTERN_XSFIELD))
  77 
  78 #define XML_STREAM_XS_IDC_SEL(c) ((c)-&gt;flags &amp; XML_PATTERN_XSSEL)
  79 
  80 #define XML_STREAM_XS_IDC_FIELD(c) ((c)-&gt;flags &amp; XML_PATTERN_XSFIELD)
  81 
  82 #define XML_PAT_COPY_NSNAME(c, r, nsname) \
  83     if ((c)-&gt;comp-&gt;dict) \
  84     r = (xmlChar *) xmlDictLookup((c)-&gt;comp-&gt;dict, BAD_CAST nsname, -1); \
  85     else r = xmlStrdup(BAD_CAST nsname);
  86 
  87 #define XML_PAT_FREE_STRING(c, r) if ((c)-&gt;comp-&gt;dict == NULL) xmlFree(r);
  88 
  89 typedef struct _xmlStreamStep xmlStreamStep;
  90 typedef xmlStreamStep *xmlStreamStepPtr;
  91 struct _xmlStreamStep {
  92     int flags;          /* properties of that step */
  93     const xmlChar *name;    /* first string value if NULL accept all */
  94     const xmlChar *ns;      /* second string value */
  95     int nodeType;       /* type of node */
  96 };
  97 
  98 typedef struct _xmlStreamComp xmlStreamComp;
  99 typedef xmlStreamComp *xmlStreamCompPtr;
 100 struct _xmlStreamComp {
 101     xmlDict *dict;      /* the dictionary if any */
 102     int nbStep;         /* number of steps in the automata */
 103     int maxStep;        /* allocated number of steps */
 104     xmlStreamStepPtr steps; /* the array of steps */
 105     int flags;
 106 };
 107 
 108 struct _xmlStreamCtxt {
 109     struct _xmlStreamCtxt *next;/* link to next sub pattern if | */
 110     xmlStreamCompPtr comp;  /* the compiled stream */
 111     int nbState;        /* number of states in the automata */
 112     int maxState;       /* allocated number of states */
 113     int level;          /* how deep are we ? */
 114     int *states;        /* the array of step indexes */
 115     int flags;          /* validation options */
 116     int blockLevel;
 117 };
 118 
 119 static void xmlFreeStreamComp(xmlStreamCompPtr comp);
 120 
 121 /*
 122  * Types are private:
 123  */
 124 
 125 typedef enum {
 126     XML_OP_END=0,
 127     XML_OP_ROOT,
 128     XML_OP_ELEM,
 129     XML_OP_CHILD,
 130     XML_OP_ATTR,
 131     XML_OP_PARENT,
 132     XML_OP_ANCESTOR,
 133     XML_OP_NS,
 134     XML_OP_ALL
 135 } xmlPatOp;
 136 
 137 
 138 typedef struct _xmlStepState xmlStepState;
 139 typedef xmlStepState *xmlStepStatePtr;
 140 struct _xmlStepState {
 141     int step;
 142     xmlNodePtr node;
 143 };
 144 
 145 typedef struct _xmlStepStates xmlStepStates;
 146 typedef xmlStepStates *xmlStepStatesPtr;
 147 struct _xmlStepStates {
 148     int nbstates;
 149     int maxstates;
 150     xmlStepStatePtr states;
 151 };
 152 
 153 typedef struct _xmlStepOp xmlStepOp;
 154 typedef xmlStepOp *xmlStepOpPtr;
 155 struct _xmlStepOp {
 156     xmlPatOp op;
 157     const xmlChar *value;
 158     const xmlChar *value2; /* The namespace name */
 159 };
 160 
 161 #define PAT_FROM_ROOT   (1&lt;&lt;8)
 162 #define PAT_FROM_CUR    (1&lt;&lt;9)
 163 
 164 struct _xmlPattern {
 165     void *data;     /* the associated template */
 166     xmlDictPtr dict;        /* the optional dictionary */
 167     struct _xmlPattern *next;   /* next pattern if | is used */
 168     const xmlChar *pattern; /* the pattern */
 169     int flags;          /* flags */
 170     int nbStep;
 171     int maxStep;
 172     xmlStepOpPtr steps;        /* ops for computation */
 173     xmlStreamCompPtr stream;    /* the streaming data if any */
 174 };
 175 
 176 typedef struct _xmlPatParserContext xmlPatParserContext;
 177 typedef xmlPatParserContext *xmlPatParserContextPtr;
 178 struct _xmlPatParserContext {
 179     const xmlChar *cur;         /* the current char being parsed */
 180     const xmlChar *base;        /* the full expression */
 181     int            error;       /* error code */
 182     xmlDictPtr     dict;        /* the dictionary if any */
 183     xmlPatternPtr  comp;        /* the result */
 184     xmlNodePtr     elem;        /* the current node if any */
 185     const xmlChar **namespaces;     /* the namespaces definitions */
 186     int   nb_namespaces;        /* the number of namespaces */
 187 };
 188 
 189 /************************************************************************
 190  *                                  *
 191  *          Type functions                  *
 192  *                                  *
 193  ************************************************************************/
 194 
 195 /**
 196  * xmlNewPattern:
 197  *
 198  * Create a new XSLT Pattern
 199  *
 200  * Returns the newly allocated xmlPatternPtr or NULL in case of error
 201  */
 202 static xmlPatternPtr
 203 xmlNewPattern(void) {
 204     xmlPatternPtr cur;
 205 
 206     cur = (xmlPatternPtr) xmlMalloc(sizeof(xmlPattern));
 207     if (cur == NULL) {
 208     ERROR(NULL, NULL, NULL,
 209         &quot;xmlNewPattern : malloc failed\n&quot;);
 210     return(NULL);
 211     }
 212     memset(cur, 0, sizeof(xmlPattern));
 213     cur-&gt;maxStep = 10;
 214     cur-&gt;steps = (xmlStepOpPtr) xmlMalloc(cur-&gt;maxStep * sizeof(xmlStepOp));
 215     if (cur-&gt;steps == NULL) {
 216         xmlFree(cur);
 217     ERROR(NULL, NULL, NULL,
 218         &quot;xmlNewPattern : malloc failed\n&quot;);
 219     return(NULL);
 220     }
 221     return(cur);
 222 }
 223 
 224 /**
 225  * xmlFreePattern:
 226  * @comp:  an XSLT comp
 227  *
 228  * Free up the memory allocated by @comp
 229  */
 230 void
 231 xmlFreePattern(xmlPatternPtr comp) {
 232     xmlStepOpPtr op;
 233     int i;
 234 
 235     if (comp == NULL)
 236     return;
 237     if (comp-&gt;next != NULL)
 238         xmlFreePattern(comp-&gt;next);
 239     if (comp-&gt;stream != NULL)
 240         xmlFreeStreamComp(comp-&gt;stream);
 241     if (comp-&gt;pattern != NULL)
 242     xmlFree((xmlChar *)comp-&gt;pattern);
 243     if (comp-&gt;steps != NULL) {
 244         if (comp-&gt;dict == NULL) {
 245         for (i = 0;i &lt; comp-&gt;nbStep;i++) {
 246         op = &amp;comp-&gt;steps[i];
 247         if (op-&gt;value != NULL)
 248             xmlFree((xmlChar *) op-&gt;value);
 249         if (op-&gt;value2 != NULL)
 250             xmlFree((xmlChar *) op-&gt;value2);
 251         }
 252     }
 253     xmlFree(comp-&gt;steps);
 254     }
 255     if (comp-&gt;dict != NULL)
 256         xmlDictFree(comp-&gt;dict);
 257 
 258     memset(comp, -1, sizeof(xmlPattern));
 259     xmlFree(comp);
 260 }
 261 
 262 /**
 263  * xmlFreePatternList:
 264  * @comp:  an XSLT comp list
 265  *
 266  * Free up the memory allocated by all the elements of @comp
 267  */
 268 void
 269 xmlFreePatternList(xmlPatternPtr comp) {
 270     xmlPatternPtr cur;
 271 
 272     while (comp != NULL) {
 273     cur = comp;
 274     comp = comp-&gt;next;
 275     cur-&gt;next = NULL;
 276     xmlFreePattern(cur);
 277     }
 278 }
 279 
 280 /**
 281  * xmlNewPatParserContext:
 282  * @pattern:  the pattern context
 283  * @dict:  the inherited dictionary or NULL
 284  * @namespaces: the prefix definitions, array of [URI, prefix] terminated
 285  *              with [NULL, NULL] or NULL if no namespace is used
 286  *
 287  * Create a new XML pattern parser context
 288  *
 289  * Returns the newly allocated xmlPatParserContextPtr or NULL in case of error
 290  */
 291 static xmlPatParserContextPtr
 292 xmlNewPatParserContext(const xmlChar *pattern, xmlDictPtr dict,
 293                        const xmlChar **namespaces) {
 294     xmlPatParserContextPtr cur;
 295 
 296     if (pattern == NULL)
 297         return(NULL);
 298 
 299     cur = (xmlPatParserContextPtr) xmlMalloc(sizeof(xmlPatParserContext));
 300     if (cur == NULL) {
 301     ERROR(NULL, NULL, NULL,
 302         &quot;xmlNewPatParserContext : malloc failed\n&quot;);
 303     return(NULL);
 304     }
 305     memset(cur, 0, sizeof(xmlPatParserContext));
 306     cur-&gt;dict = dict;
 307     cur-&gt;cur = pattern;
 308     cur-&gt;base = pattern;
 309     if (namespaces != NULL) {
 310         int i;
 311         for (i = 0;namespaces[2 * i] != NULL;i++)
 312             ;
 313         cur-&gt;nb_namespaces = i;
 314     } else {
 315         cur-&gt;nb_namespaces = 0;
 316     }
 317     cur-&gt;namespaces = namespaces;
 318     return(cur);
 319 }
 320 
 321 /**
 322  * xmlFreePatParserContext:
 323  * @ctxt:  an XSLT parser context
 324  *
 325  * Free up the memory allocated by @ctxt
 326  */
 327 static void
 328 xmlFreePatParserContext(xmlPatParserContextPtr ctxt) {
 329     if (ctxt == NULL)
 330     return;
 331     memset(ctxt, -1, sizeof(xmlPatParserContext));
 332     xmlFree(ctxt);
 333 }
 334 
 335 /**
 336  * xmlPatternAdd:
 337  * @comp:  the compiled match expression
 338  * @op:  an op
 339  * @value:  the first value
 340  * @value2:  the second value
 341  *
 342  * Add a step to an XSLT Compiled Match
 343  *
 344  * Returns -1 in case of failure, 0 otherwise.
 345  */
 346 static int
 347 xmlPatternAdd(xmlPatParserContextPtr ctxt ATTRIBUTE_UNUSED,
 348                 xmlPatternPtr comp,
 349                 xmlPatOp op, xmlChar * value, xmlChar * value2)
 350 {
 351     if (comp-&gt;nbStep &gt;= comp-&gt;maxStep) {
 352         xmlStepOpPtr temp;
 353     temp = (xmlStepOpPtr) xmlRealloc(comp-&gt;steps, comp-&gt;maxStep * 2 *
 354                                      sizeof(xmlStepOp));
 355         if (temp == NULL) {
 356         ERROR(ctxt, NULL, NULL,
 357                  &quot;xmlPatternAdd: realloc failed\n&quot;);
 358         return (-1);
 359     }
 360     comp-&gt;steps = temp;
 361     comp-&gt;maxStep *= 2;
 362     }
 363     comp-&gt;steps[comp-&gt;nbStep].op = op;
 364     comp-&gt;steps[comp-&gt;nbStep].value = value;
 365     comp-&gt;steps[comp-&gt;nbStep].value2 = value2;
 366     comp-&gt;nbStep++;
 367     return (0);
 368 }
 369 
 370 #if 0
 371 /**
 372  * xsltSwapTopPattern:
 373  * @comp:  the compiled match expression
 374  *
 375  * reverse the two top steps.
 376  */
 377 static void
 378 xsltSwapTopPattern(xmlPatternPtr comp) {
 379     int i;
 380     int j = comp-&gt;nbStep - 1;
 381 
 382     if (j &gt; 0) {
 383     register const xmlChar *tmp;
 384     register xmlPatOp op;
 385     i = j - 1;
 386     tmp = comp-&gt;steps[i].value;
 387     comp-&gt;steps[i].value = comp-&gt;steps[j].value;
 388     comp-&gt;steps[j].value = tmp;
 389     tmp = comp-&gt;steps[i].value2;
 390     comp-&gt;steps[i].value2 = comp-&gt;steps[j].value2;
 391     comp-&gt;steps[j].value2 = tmp;
 392     op = comp-&gt;steps[i].op;
 393     comp-&gt;steps[i].op = comp-&gt;steps[j].op;
 394     comp-&gt;steps[j].op = op;
 395     }
 396 }
 397 #endif
 398 
 399 /**
 400  * xmlReversePattern:
 401  * @comp:  the compiled match expression
 402  *
 403  * reverse all the stack of expressions
 404  *
 405  * returns 0 in case of success and -1 in case of error.
 406  */
 407 static int
 408 xmlReversePattern(xmlPatternPtr comp) {
 409     int i, j;
 410 
 411     /*
 412      * remove the leading // for //a or .//a
 413      */
 414     if ((comp-&gt;nbStep &gt; 0) &amp;&amp; (comp-&gt;steps[0].op == XML_OP_ANCESTOR)) {
 415         for (i = 0, j = 1;j &lt; comp-&gt;nbStep;i++,j++) {
 416         comp-&gt;steps[i].value = comp-&gt;steps[j].value;
 417         comp-&gt;steps[i].value2 = comp-&gt;steps[j].value2;
 418         comp-&gt;steps[i].op = comp-&gt;steps[j].op;
 419     }
 420     comp-&gt;nbStep--;
 421     }
 422     if (comp-&gt;nbStep &gt;= comp-&gt;maxStep) {
 423         xmlStepOpPtr temp;
 424     temp = (xmlStepOpPtr) xmlRealloc(comp-&gt;steps, comp-&gt;maxStep * 2 *
 425                                      sizeof(xmlStepOp));
 426         if (temp == NULL) {
 427         ERROR(ctxt, NULL, NULL,
 428                  &quot;xmlReversePattern: realloc failed\n&quot;);
 429         return (-1);
 430     }
 431     comp-&gt;steps = temp;
 432     comp-&gt;maxStep *= 2;
 433     }
 434     i = 0;
 435     j = comp-&gt;nbStep - 1;
 436     while (j &gt; i) {
 437     register const xmlChar *tmp;
 438     register xmlPatOp op;
 439     tmp = comp-&gt;steps[i].value;
 440     comp-&gt;steps[i].value = comp-&gt;steps[j].value;
 441     comp-&gt;steps[j].value = tmp;
 442     tmp = comp-&gt;steps[i].value2;
 443     comp-&gt;steps[i].value2 = comp-&gt;steps[j].value2;
 444     comp-&gt;steps[j].value2 = tmp;
 445     op = comp-&gt;steps[i].op;
 446     comp-&gt;steps[i].op = comp-&gt;steps[j].op;
 447     comp-&gt;steps[j].op = op;
 448     j--;
 449     i++;
 450     }
 451     comp-&gt;steps[comp-&gt;nbStep].value = NULL;
 452     comp-&gt;steps[comp-&gt;nbStep].value2 = NULL;
 453     comp-&gt;steps[comp-&gt;nbStep++].op = XML_OP_END;
 454     return(0);
 455 }
 456 
 457 /************************************************************************
 458  *                                  *
 459  *      The interpreter for the precompiled patterns        *
 460  *                                  *
 461  ************************************************************************/
 462 
 463 static int
 464 xmlPatPushState(xmlStepStates *states, int step, xmlNodePtr node) {
 465     if ((states-&gt;states == NULL) || (states-&gt;maxstates &lt;= 0)) {
 466         states-&gt;maxstates = 4;
 467     states-&gt;nbstates = 0;
 468     states-&gt;states = xmlMalloc(4 * sizeof(xmlStepState));
 469     }
 470     else if (states-&gt;maxstates &lt;= states-&gt;nbstates) {
 471         xmlStepState *tmp;
 472 
 473     tmp = (xmlStepStatePtr) xmlRealloc(states-&gt;states,
 474                    2 * states-&gt;maxstates * sizeof(xmlStepState));
 475     if (tmp == NULL)
 476         return(-1);
 477     states-&gt;states = tmp;
 478     states-&gt;maxstates *= 2;
 479     }
 480     states-&gt;states[states-&gt;nbstates].step = step;
 481     states-&gt;states[states-&gt;nbstates++].node = node;
 482 #if 0
 483     fprintf(stderr, &quot;Push: %d, %s\n&quot;, step, node-&gt;name);
 484 #endif
 485     return(0);
 486 }
 487 
 488 /**
 489  * xmlPatMatch:
 490  * @comp: the precompiled pattern
 491  * @node: a node
 492  *
 493  * Test whether the node matches the pattern
 494  *
 495  * Returns 1 if it matches, 0 if it doesn&#39;t and -1 in case of failure
 496  */
 497 static int
 498 xmlPatMatch(xmlPatternPtr comp, xmlNodePtr node) {
 499     int i;
 500     xmlStepOpPtr step;
 501     xmlStepStates states = {0, 0, NULL}; /* // may require backtrack */
 502 
 503     if ((comp == NULL) || (node == NULL)) return(-1);
 504     i = 0;
 505 restart:
 506     for (;i &lt; comp-&gt;nbStep;i++) {
 507     step = &amp;comp-&gt;steps[i];
 508     switch (step-&gt;op) {
 509             case XML_OP_END:
 510         goto found;
 511             case XML_OP_ROOT:
 512         if (node-&gt;type == XML_NAMESPACE_DECL)
 513             goto rollback;
 514         node = node-&gt;parent;
 515         if ((node-&gt;type == XML_DOCUMENT_NODE) ||
 516 #ifdef LIBXML_DOCB_ENABLED
 517             (node-&gt;type == XML_DOCB_DOCUMENT_NODE) ||
 518 #endif
 519             (node-&gt;type == XML_HTML_DOCUMENT_NODE))
 520             continue;
 521         goto rollback;
 522             case XML_OP_ELEM:
 523         if (node-&gt;type != XML_ELEMENT_NODE)
 524             goto rollback;
 525         if (step-&gt;value == NULL)
 526             continue;
 527         if (step-&gt;value[0] != node-&gt;name[0])
 528             goto rollback;
 529         if (!xmlStrEqual(step-&gt;value, node-&gt;name))
 530             goto rollback;
 531 
 532         /* Namespace test */
 533         if (node-&gt;ns == NULL) {
 534             if (step-&gt;value2 != NULL)
 535             goto rollback;
 536         } else if (node-&gt;ns-&gt;href != NULL) {
 537             if (step-&gt;value2 == NULL)
 538             goto rollback;
 539             if (!xmlStrEqual(step-&gt;value2, node-&gt;ns-&gt;href))
 540             goto rollback;
 541         }
 542         continue;
 543             case XML_OP_CHILD: {
 544         xmlNodePtr lst;
 545 
 546         if ((node-&gt;type != XML_ELEMENT_NODE) &amp;&amp;
 547             (node-&gt;type != XML_DOCUMENT_NODE) &amp;&amp;
 548 #ifdef LIBXML_DOCB_ENABLED
 549             (node-&gt;type != XML_DOCB_DOCUMENT_NODE) &amp;&amp;
 550 #endif
 551             (node-&gt;type != XML_HTML_DOCUMENT_NODE))
 552             goto rollback;
 553 
 554         lst = node-&gt;children;
 555 
 556         if (step-&gt;value != NULL) {
 557             while (lst != NULL) {
 558             if ((lst-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
 559                 (step-&gt;value[0] == lst-&gt;name[0]) &amp;&amp;
 560                 (xmlStrEqual(step-&gt;value, lst-&gt;name)))
 561                 break;
 562             lst = lst-&gt;next;
 563             }
 564             if (lst != NULL)
 565             continue;
 566         }
 567         goto rollback;
 568         }
 569             case XML_OP_ATTR:
 570         if (node-&gt;type != XML_ATTRIBUTE_NODE)
 571             goto rollback;
 572         if (step-&gt;value != NULL) {
 573             if (step-&gt;value[0] != node-&gt;name[0])
 574             goto rollback;
 575             if (!xmlStrEqual(step-&gt;value, node-&gt;name))
 576             goto rollback;
 577         }
 578         /* Namespace test */
 579         if (node-&gt;ns == NULL) {
 580             if (step-&gt;value2 != NULL)
 581             goto rollback;
 582         } else if (step-&gt;value2 != NULL) {
 583             if (!xmlStrEqual(step-&gt;value2, node-&gt;ns-&gt;href))
 584             goto rollback;
 585         }
 586         continue;
 587             case XML_OP_PARENT:
 588         if ((node-&gt;type == XML_DOCUMENT_NODE) ||
 589             (node-&gt;type == XML_HTML_DOCUMENT_NODE) ||
 590 #ifdef LIBXML_DOCB_ENABLED
 591             (node-&gt;type == XML_DOCB_DOCUMENT_NODE) ||
 592 #endif
 593             (node-&gt;type == XML_NAMESPACE_DECL))
 594             goto rollback;
 595         node = node-&gt;parent;
 596         if (node == NULL)
 597             goto rollback;
 598         if (step-&gt;value == NULL)
 599             continue;
 600         if (step-&gt;value[0] != node-&gt;name[0])
 601             goto rollback;
 602         if (!xmlStrEqual(step-&gt;value, node-&gt;name))
 603             goto rollback;
 604         /* Namespace test */
 605         if (node-&gt;ns == NULL) {
 606             if (step-&gt;value2 != NULL)
 607             goto rollback;
 608         } else if (node-&gt;ns-&gt;href != NULL) {
 609             if (step-&gt;value2 == NULL)
 610             goto rollback;
 611             if (!xmlStrEqual(step-&gt;value2, node-&gt;ns-&gt;href))
 612             goto rollback;
 613         }
 614         continue;
 615             case XML_OP_ANCESTOR:
 616         /* TODO: implement coalescing of ANCESTOR/NODE ops */
 617         if (step-&gt;value == NULL) {
 618             i++;
 619             step = &amp;comp-&gt;steps[i];
 620             if (step-&gt;op == XML_OP_ROOT)
 621             goto found;
 622             if (step-&gt;op != XML_OP_ELEM)
 623             goto rollback;
 624             if (step-&gt;value == NULL)
 625             return(-1);
 626         }
 627         if (node == NULL)
 628             goto rollback;
 629         if ((node-&gt;type == XML_DOCUMENT_NODE) ||
 630             (node-&gt;type == XML_HTML_DOCUMENT_NODE) ||
 631 #ifdef LIBXML_DOCB_ENABLED
 632             (node-&gt;type == XML_DOCB_DOCUMENT_NODE) ||
 633 #endif
 634             (node-&gt;type == XML_NAMESPACE_DECL))
 635             goto rollback;
 636         node = node-&gt;parent;
 637         while (node != NULL) {
 638             if ((node-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
 639             (step-&gt;value[0] == node-&gt;name[0]) &amp;&amp;
 640             (xmlStrEqual(step-&gt;value, node-&gt;name))) {
 641             /* Namespace test */
 642             if (node-&gt;ns == NULL) {
 643                 if (step-&gt;value2 == NULL)
 644                 break;
 645             } else if (node-&gt;ns-&gt;href != NULL) {
 646                 if ((step-&gt;value2 != NULL) &amp;&amp;
 647                     (xmlStrEqual(step-&gt;value2, node-&gt;ns-&gt;href)))
 648                 break;
 649             }
 650             }
 651             node = node-&gt;parent;
 652         }
 653         if (node == NULL)
 654             goto rollback;
 655         /*
 656          * prepare a potential rollback from here
 657          * for ancestors of that node.
 658          */
 659         if (step-&gt;op == XML_OP_ANCESTOR)
 660             xmlPatPushState(&amp;states, i, node);
 661         else
 662             xmlPatPushState(&amp;states, i - 1, node);
 663         continue;
 664             case XML_OP_NS:
 665         if (node-&gt;type != XML_ELEMENT_NODE)
 666             goto rollback;
 667         if (node-&gt;ns == NULL) {
 668             if (step-&gt;value != NULL)
 669             goto rollback;
 670         } else if (node-&gt;ns-&gt;href != NULL) {
 671             if (step-&gt;value == NULL)
 672             goto rollback;
 673             if (!xmlStrEqual(step-&gt;value, node-&gt;ns-&gt;href))
 674             goto rollback;
 675         }
 676         break;
 677             case XML_OP_ALL:
 678         if (node-&gt;type != XML_ELEMENT_NODE)
 679             goto rollback;
 680         break;
 681     }
 682     }
 683 found:
 684     if (states.states != NULL) {
 685         /* Free the rollback states */
 686     xmlFree(states.states);
 687     }
 688     return(1);
 689 rollback:
 690     /* got an error try to rollback */
 691     if (states.states == NULL)
 692     return(0);
 693     if (states.nbstates &lt;= 0) {
 694     xmlFree(states.states);
 695     return(0);
 696     }
 697     states.nbstates--;
 698     i = states.states[states.nbstates].step;
 699     node = states.states[states.nbstates].node;
 700 #if 0
 701     fprintf(stderr, &quot;Pop: %d, %s\n&quot;, i, node-&gt;name);
 702 #endif
 703     goto restart;
 704 }
 705 
 706 /************************************************************************
 707  *                                  *
 708  *          Dedicated parser for templates          *
 709  *                                  *
 710  ************************************************************************/
 711 
 712 #define TODO                                \
 713     xmlGenericError(xmlGenericErrorContext,             \
 714         &quot;Unimplemented block at %s:%d\n&quot;,               \
 715             __FILE__, __LINE__);
 716 #define CUR (*ctxt-&gt;cur)
 717 #define SKIP(val) ctxt-&gt;cur += (val)
 718 #define NXT(val) ctxt-&gt;cur[(val)]
 719 #define PEEKPREV(val) ctxt-&gt;cur[-(val)]
 720 #define CUR_PTR ctxt-&gt;cur
 721 
 722 #define SKIP_BLANKS                         \
 723     while (IS_BLANK_CH(CUR)) NEXT
 724 
 725 #define CURRENT (*ctxt-&gt;cur)
 726 #define NEXT ((*ctxt-&gt;cur) ?  ctxt-&gt;cur++: ctxt-&gt;cur)
 727 
 728 
 729 #define PUSH(op, val, val2)                     \
 730     if (xmlPatternAdd(ctxt, ctxt-&gt;comp, (op), (val), (val2))) goto error;
 731 
 732 #define XSLT_ERROR(X)                           \
 733     { xsltError(ctxt, __FILE__, __LINE__, X);               \
 734       ctxt-&gt;error = (X); return; }
 735 
 736 #define XSLT_ERROR0(X)                          \
 737     { xsltError(ctxt, __FILE__, __LINE__, X);               \
 738       ctxt-&gt;error = (X); return(0); }
 739 
 740 #if 0
 741 /**
 742  * xmlPatScanLiteral:
 743  * @ctxt:  the XPath Parser context
 744  *
 745  * Parse an XPath Litteral:
 746  *
 747  * [29] Literal ::= &#39;&quot;&#39; [^&quot;]* &#39;&quot;&#39;
 748  *                | &quot;&#39;&quot; [^&#39;]* &quot;&#39;&quot;
 749  *
 750  * Returns the Literal parsed or NULL
 751  */
 752 
 753 static xmlChar *
 754 xmlPatScanLiteral(xmlPatParserContextPtr ctxt) {
 755     const xmlChar *q, *cur;
 756     xmlChar *ret = NULL;
 757     int val, len;
 758 
 759     SKIP_BLANKS;
 760     if (CUR == &#39;&quot;&#39;) {
 761         NEXT;
 762     cur = q = CUR_PTR;
 763     val = xmlStringCurrentChar(NULL, cur, &amp;len);
 764     while ((IS_CHAR(val)) &amp;&amp; (val != &#39;&quot;&#39;)) {
 765         cur += len;
 766         val = xmlStringCurrentChar(NULL, cur, &amp;len);
 767     }
 768     if (!IS_CHAR(val)) {
 769         ctxt-&gt;error = 1;
 770         return(NULL);
 771     } else {
 772         if (ctxt-&gt;dict)
 773         ret = (xmlChar *) xmlDictLookup(ctxt-&gt;dict, q, cur - q);
 774         else
 775         ret = xmlStrndup(q, cur - q);
 776         }
 777     cur += len;
 778     CUR_PTR = cur;
 779     } else if (CUR == &#39;\&#39;&#39;) {
 780         NEXT;
 781     cur = q = CUR_PTR;
 782     val = xmlStringCurrentChar(NULL, cur, &amp;len);
 783     while ((IS_CHAR(val)) &amp;&amp; (val != &#39;\&#39;&#39;)) {
 784         cur += len;
 785         val = xmlStringCurrentChar(NULL, cur, &amp;len);
 786     }
 787     if (!IS_CHAR(val)) {
 788         ctxt-&gt;error = 1;
 789         return(NULL);
 790     } else {
 791         if (ctxt-&gt;dict)
 792         ret = (xmlChar *) xmlDictLookup(ctxt-&gt;dict, q, cur - q);
 793         else
 794         ret = xmlStrndup(q, cur - q);
 795         }
 796     cur += len;
 797     CUR_PTR = cur;
 798     } else {
 799     /* XP_ERROR(XPATH_START_LITERAL_ERROR); */
 800     ctxt-&gt;error = 1;
 801     return(NULL);
 802     }
 803     return(ret);
 804 }
 805 #endif
 806 
 807 /**
 808  * xmlPatScanName:
 809  * @ctxt:  the XPath Parser context
 810  *
 811  * [4] NameChar ::= Letter | Digit | &#39;.&#39; | &#39;-&#39; | &#39;_&#39; |
 812  *                  CombiningChar | Extender
 813  *
 814  * [5] Name ::= (Letter | &#39;_&#39; | &#39;:&#39;) (NameChar)*
 815  *
 816  * [6] Names ::= Name (S Name)*
 817  *
 818  * Returns the Name parsed or NULL
 819  */
 820 
 821 static xmlChar *
 822 xmlPatScanName(xmlPatParserContextPtr ctxt) {
 823     const xmlChar *q, *cur;
 824     xmlChar *ret = NULL;
 825     int val, len;
 826 
 827     SKIP_BLANKS;
 828 
 829     cur = q = CUR_PTR;
 830     val = xmlStringCurrentChar(NULL, cur, &amp;len);
 831     if (!IS_LETTER(val) &amp;&amp; (val != &#39;_&#39;) &amp;&amp; (val != &#39;:&#39;))
 832     return(NULL);
 833 
 834     while ((IS_LETTER(val)) || (IS_DIGIT(val)) ||
 835            (val == &#39;.&#39;) || (val == &#39;-&#39;) ||
 836        (val == &#39;_&#39;) ||
 837        (IS_COMBINING(val)) ||
 838        (IS_EXTENDER(val))) {
 839     cur += len;
 840     val = xmlStringCurrentChar(NULL, cur, &amp;len);
 841     }
 842     if (ctxt-&gt;dict)
 843     ret = (xmlChar *) xmlDictLookup(ctxt-&gt;dict, q, cur - q);
 844     else
 845     ret = xmlStrndup(q, cur - q);
 846     CUR_PTR = cur;
 847     return(ret);
 848 }
 849 
 850 /**
 851  * xmlPatScanNCName:
 852  * @ctxt:  the XPath Parser context
 853  *
 854  * Parses a non qualified name
 855  *
 856  * Returns the Name parsed or NULL
 857  */
 858 
 859 static xmlChar *
 860 xmlPatScanNCName(xmlPatParserContextPtr ctxt) {
 861     const xmlChar *q, *cur;
 862     xmlChar *ret = NULL;
 863     int val, len;
 864 
 865     SKIP_BLANKS;
 866 
 867     cur = q = CUR_PTR;
 868     val = xmlStringCurrentChar(NULL, cur, &amp;len);
 869     if (!IS_LETTER(val) &amp;&amp; (val != &#39;_&#39;))
 870     return(NULL);
 871 
 872     while ((IS_LETTER(val)) || (IS_DIGIT(val)) ||
 873            (val == &#39;.&#39;) || (val == &#39;-&#39;) ||
 874        (val == &#39;_&#39;) ||
 875        (IS_COMBINING(val)) ||
 876        (IS_EXTENDER(val))) {
 877     cur += len;
 878     val = xmlStringCurrentChar(NULL, cur, &amp;len);
 879     }
 880     if (ctxt-&gt;dict)
 881     ret = (xmlChar *) xmlDictLookup(ctxt-&gt;dict, q, cur - q);
 882     else
 883     ret = xmlStrndup(q, cur - q);
 884     CUR_PTR = cur;
 885     return(ret);
 886 }
 887 
 888 #if 0
 889 /**
 890  * xmlPatScanQName:
 891  * @ctxt:  the XPath Parser context
 892  * @prefix:  the place to store the prefix
 893  *
 894  * Parse a qualified name
 895  *
 896  * Returns the Name parsed or NULL
 897  */
 898 
 899 static xmlChar *
 900 xmlPatScanQName(xmlPatParserContextPtr ctxt, xmlChar **prefix) {
 901     xmlChar *ret = NULL;
 902 
 903     *prefix = NULL;
 904     ret = xmlPatScanNCName(ctxt);
 905     if (CUR == &#39;:&#39;) {
 906         *prefix = ret;
 907     NEXT;
 908     ret = xmlPatScanNCName(ctxt);
 909     }
 910     return(ret);
 911 }
 912 #endif
 913 
 914 /**
 915  * xmlCompileAttributeTest:
 916  * @ctxt:  the compilation context
 917  *
 918  * Compile an attribute test.
 919  */
 920 static void
 921 xmlCompileAttributeTest(xmlPatParserContextPtr ctxt) {
 922     xmlChar *token = NULL;
 923     xmlChar *name = NULL;
 924     xmlChar *URL = NULL;
 925 
 926     SKIP_BLANKS;
 927     name = xmlPatScanNCName(ctxt);
 928     if (name == NULL) {
 929     if (CUR == &#39;*&#39;) {
 930         PUSH(XML_OP_ATTR, NULL, NULL);
 931         NEXT;
 932     } else {
 933         ERROR(NULL, NULL, NULL,
 934         &quot;xmlCompileAttributeTest : Name expected\n&quot;);
 935         ctxt-&gt;error = 1;
 936     }
 937     return;
 938     }
 939     if (CUR == &#39;:&#39;) {
 940     int i;
 941     xmlChar *prefix = name;
 942 
 943     NEXT;
 944 
 945     if (IS_BLANK_CH(CUR)) {
 946         ERROR5(NULL, NULL, NULL, &quot;Invalid QName.\n&quot;, NULL);
 947         XML_PAT_FREE_STRING(ctxt, prefix);
 948         ctxt-&gt;error = 1;
 949         goto error;
 950     }
 951     /*
 952     * This is a namespace match
 953     */
 954     token = xmlPatScanName(ctxt);
 955     if ((prefix[0] == &#39;x&#39;) &amp;&amp;
 956         (prefix[1] == &#39;m&#39;) &amp;&amp;
 957         (prefix[2] == &#39;l&#39;) &amp;&amp;
 958         (prefix[3] == 0))
 959     {
 960         XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE);
 961     } else {
 962         for (i = 0;i &lt; ctxt-&gt;nb_namespaces;i++) {
 963         if (xmlStrEqual(ctxt-&gt;namespaces[2 * i + 1], prefix)) {
 964             XML_PAT_COPY_NSNAME(ctxt, URL, ctxt-&gt;namespaces[2 * i])
 965             break;
 966         }
 967         }
 968         if (i &gt;= ctxt-&gt;nb_namespaces) {
 969         ERROR5(NULL, NULL, NULL,
 970             &quot;xmlCompileAttributeTest : no namespace bound to prefix %s\n&quot;,
 971             prefix);
 972             XML_PAT_FREE_STRING(ctxt, prefix);
 973         ctxt-&gt;error = 1;
 974         goto error;
 975         }
 976     }
 977     XML_PAT_FREE_STRING(ctxt, prefix);
 978     if (token == NULL) {
 979         if (CUR == &#39;*&#39;) {
 980         NEXT;
 981         PUSH(XML_OP_ATTR, NULL, URL);
 982         } else {
 983         ERROR(NULL, NULL, NULL,
 984             &quot;xmlCompileAttributeTest : Name expected\n&quot;);
 985         ctxt-&gt;error = 1;
 986         goto error;
 987         }
 988     } else {
 989         PUSH(XML_OP_ATTR, token, URL);
 990     }
 991     } else {
 992     PUSH(XML_OP_ATTR, name, NULL);
 993     }
 994     return;
 995 error:
 996     if (URL != NULL)
 997     XML_PAT_FREE_STRING(ctxt, URL)
 998     if (token != NULL)
 999     XML_PAT_FREE_STRING(ctxt, token);
1000 }
1001 
1002 /**
1003  * xmlCompileStepPattern:
1004  * @ctxt:  the compilation context
1005  *
1006  * Compile the Step Pattern and generates a precompiled
1007  * form suitable for fast matching.
1008  *
1009  * [3]    Step    ::=    &#39;.&#39; | NameTest
1010  * [4]    NameTest    ::=    QName | &#39;*&#39; | NCName &#39;:&#39; &#39;*&#39;
1011  */
1012 
1013 static void
1014 xmlCompileStepPattern(xmlPatParserContextPtr ctxt) {
1015     xmlChar *token = NULL;
1016     xmlChar *name = NULL;
1017     xmlChar *URL = NULL;
1018     int hasBlanks = 0;
1019 
1020     SKIP_BLANKS;
1021     if (CUR == &#39;.&#39;) {
1022     /*
1023     * Context node.
1024     */
1025     NEXT;
1026     PUSH(XML_OP_ELEM, NULL, NULL);
1027     return;
1028     }
1029     if (CUR == &#39;@&#39;) {
1030     /*
1031     * Attribute test.
1032     */
1033     if (XML_STREAM_XS_IDC_SEL(ctxt-&gt;comp)) {
1034         ERROR5(NULL, NULL, NULL,
1035         &quot;Unexpected attribute axis in &#39;%s&#39;.\n&quot;, ctxt-&gt;base);
1036         ctxt-&gt;error = 1;
1037         return;
1038     }
1039     NEXT;
1040     xmlCompileAttributeTest(ctxt);
1041     if (ctxt-&gt;error != 0)
1042         goto error;
1043     return;
1044     }
1045     name = xmlPatScanNCName(ctxt);
1046     if (name == NULL) {
1047     if (CUR == &#39;*&#39;) {
1048         NEXT;
1049         PUSH(XML_OP_ALL, NULL, NULL);
1050         return;
1051     } else {
1052         ERROR(NULL, NULL, NULL,
1053             &quot;xmlCompileStepPattern : Name expected\n&quot;);
1054         ctxt-&gt;error = 1;
1055         return;
1056     }
1057     }
1058     if (IS_BLANK_CH(CUR)) {
1059     hasBlanks = 1;
1060     SKIP_BLANKS;
1061     }
1062     if (CUR == &#39;:&#39;) {
1063     NEXT;
1064     if (CUR != &#39;:&#39;) {
1065         xmlChar *prefix = name;
1066         int i;
1067 
1068         if (hasBlanks || IS_BLANK_CH(CUR)) {
1069         ERROR5(NULL, NULL, NULL, &quot;Invalid QName.\n&quot;, NULL);
1070         ctxt-&gt;error = 1;
1071         goto error;
1072         }
1073         /*
1074          * This is a namespace match
1075          */
1076         token = xmlPatScanName(ctxt);
1077         if ((prefix[0] == &#39;x&#39;) &amp;&amp;
1078         (prefix[1] == &#39;m&#39;) &amp;&amp;
1079         (prefix[2] == &#39;l&#39;) &amp;&amp;
1080         (prefix[3] == 0))
1081         {
1082         XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)
1083         } else {
1084         for (i = 0;i &lt; ctxt-&gt;nb_namespaces;i++) {
1085             if (xmlStrEqual(ctxt-&gt;namespaces[2 * i + 1], prefix)) {
1086             XML_PAT_COPY_NSNAME(ctxt, URL, ctxt-&gt;namespaces[2 * i])
1087             break;
1088             }
1089         }
1090         if (i &gt;= ctxt-&gt;nb_namespaces) {
1091             ERROR5(NULL, NULL, NULL,
1092             &quot;xmlCompileStepPattern : no namespace bound to prefix %s\n&quot;,
1093             prefix);
1094             ctxt-&gt;error = 1;
1095             goto error;
1096         }
1097         }
1098         XML_PAT_FREE_STRING(ctxt, prefix);
1099         name = NULL;
1100         if (token == NULL) {
1101         if (CUR == &#39;*&#39;) {
1102             NEXT;
1103             PUSH(XML_OP_NS, URL, NULL);
1104         } else {
1105             ERROR(NULL, NULL, NULL,
1106                 &quot;xmlCompileStepPattern : Name expected\n&quot;);
1107             ctxt-&gt;error = 1;
1108             goto error;
1109         }
1110         } else {
1111         PUSH(XML_OP_ELEM, token, URL);
1112         }
1113     } else {
1114         NEXT;
1115         if (xmlStrEqual(name, (const xmlChar *) &quot;child&quot;)) {
1116         XML_PAT_FREE_STRING(ctxt, name);
1117         name = xmlPatScanName(ctxt);
1118         if (name == NULL) {
1119             if (CUR == &#39;*&#39;) {
1120             NEXT;
1121             PUSH(XML_OP_ALL, NULL, NULL);
1122             return;
1123             } else {
1124             ERROR(NULL, NULL, NULL,
1125                 &quot;xmlCompileStepPattern : QName expected\n&quot;);
1126             ctxt-&gt;error = 1;
1127             goto error;
1128             }
1129         }
1130         if (CUR == &#39;:&#39;) {
1131             xmlChar *prefix = name;
1132             int i;
1133 
1134             NEXT;
1135             if (IS_BLANK_CH(CUR)) {
1136             ERROR5(NULL, NULL, NULL, &quot;Invalid QName.\n&quot;, NULL);
1137             ctxt-&gt;error = 1;
1138             goto error;
1139             }
1140             /*
1141             * This is a namespace match
1142             */
1143             token = xmlPatScanName(ctxt);
1144             if ((prefix[0] == &#39;x&#39;) &amp;&amp;
1145             (prefix[1] == &#39;m&#39;) &amp;&amp;
1146             (prefix[2] == &#39;l&#39;) &amp;&amp;
1147             (prefix[3] == 0))
1148             {
1149             XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)
1150             } else {
1151             for (i = 0;i &lt; ctxt-&gt;nb_namespaces;i++) {
1152                 if (xmlStrEqual(ctxt-&gt;namespaces[2 * i + 1], prefix)) {
1153                 XML_PAT_COPY_NSNAME(ctxt, URL, ctxt-&gt;namespaces[2 * i])
1154                 break;
1155                 }
1156             }
1157             if (i &gt;= ctxt-&gt;nb_namespaces) {
1158                 ERROR5(NULL, NULL, NULL,
1159                 &quot;xmlCompileStepPattern : no namespace bound &quot;
1160                 &quot;to prefix %s\n&quot;, prefix);
1161                 ctxt-&gt;error = 1;
1162                 goto error;
1163             }
1164             }
1165             XML_PAT_FREE_STRING(ctxt, prefix);
1166             name = NULL;
1167             if (token == NULL) {
1168             if (CUR == &#39;*&#39;) {
1169                 NEXT;
1170                 PUSH(XML_OP_NS, URL, NULL);
1171             } else {
1172                 ERROR(NULL, NULL, NULL,
1173                 &quot;xmlCompileStepPattern : Name expected\n&quot;);
1174                 ctxt-&gt;error = 1;
1175                 goto error;
1176             }
1177             } else {
1178             PUSH(XML_OP_CHILD, token, URL);
1179             }
1180         } else
1181             PUSH(XML_OP_CHILD, name, NULL);
1182         return;
1183         } else if (xmlStrEqual(name, (const xmlChar *) &quot;attribute&quot;)) {
1184         XML_PAT_FREE_STRING(ctxt, name)
1185         name = NULL;
1186         if (XML_STREAM_XS_IDC_SEL(ctxt-&gt;comp)) {
1187             ERROR5(NULL, NULL, NULL,
1188             &quot;Unexpected attribute axis in &#39;%s&#39;.\n&quot;, ctxt-&gt;base);
1189             ctxt-&gt;error = 1;
1190             goto error;
1191         }
1192         xmlCompileAttributeTest(ctxt);
1193         if (ctxt-&gt;error != 0)
1194             goto error;
1195         return;
1196         } else {
1197         ERROR5(NULL, NULL, NULL,
1198             &quot;The &#39;element&#39; or &#39;attribute&#39; axis is expected.\n&quot;, NULL);
1199         ctxt-&gt;error = 1;
1200         goto error;
1201         }
1202     }
1203     } else if (CUR == &#39;*&#39;) {
1204         if (name != NULL) {
1205         ctxt-&gt;error = 1;
1206         goto error;
1207     }
1208     NEXT;
1209     PUSH(XML_OP_ALL, token, NULL);
1210     } else {
1211     PUSH(XML_OP_ELEM, name, NULL);
1212     }
1213     return;
1214 error:
1215     if (URL != NULL)
1216     XML_PAT_FREE_STRING(ctxt, URL)
1217     if (token != NULL)
1218     XML_PAT_FREE_STRING(ctxt, token)
1219     if (name != NULL)
1220     XML_PAT_FREE_STRING(ctxt, name)
1221 }
1222 
1223 /**
1224  * xmlCompilePathPattern:
1225  * @ctxt:  the compilation context
1226  *
1227  * Compile the Path Pattern and generates a precompiled
1228  * form suitable for fast matching.
1229  *
1230  * [5]    Path    ::=    (&#39;.//&#39;)? ( Step &#39;/&#39; )* ( Step | &#39;@&#39; NameTest )
1231  */
1232 static void
1233 xmlCompilePathPattern(xmlPatParserContextPtr ctxt) {
1234     SKIP_BLANKS;
1235     if (CUR == &#39;/&#39;) {
1236         ctxt-&gt;comp-&gt;flags |= PAT_FROM_ROOT;
1237     } else if ((CUR == &#39;.&#39;) || (ctxt-&gt;comp-&gt;flags &amp; XML_PATTERN_NOTPATTERN)) {
1238         ctxt-&gt;comp-&gt;flags |= PAT_FROM_CUR;
1239     }
1240 
1241     if ((CUR == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;)) {
1242     PUSH(XML_OP_ANCESTOR, NULL, NULL);
1243     NEXT;
1244     NEXT;
1245     } else if ((CUR == &#39;.&#39;) &amp;&amp; (NXT(1) == &#39;/&#39;) &amp;&amp; (NXT(2) == &#39;/&#39;)) {
1246     PUSH(XML_OP_ANCESTOR, NULL, NULL);
1247     NEXT;
1248     NEXT;
1249     NEXT;
1250     /* Check for incompleteness. */
1251     SKIP_BLANKS;
1252     if (CUR == 0) {
1253         ERROR5(NULL, NULL, NULL,
1254            &quot;Incomplete expression &#39;%s&#39;.\n&quot;, ctxt-&gt;base);
1255         ctxt-&gt;error = 1;
1256         goto error;
1257     }
1258     }
1259     if (CUR == &#39;@&#39;) {
1260     NEXT;
1261     xmlCompileAttributeTest(ctxt);
1262     SKIP_BLANKS;
1263     /* TODO: check for incompleteness */
1264     if (CUR != 0) {
1265         xmlCompileStepPattern(ctxt);
1266         if (ctxt-&gt;error != 0)
1267         goto error;
1268     }
1269     } else {
1270         if (CUR == &#39;/&#39;) {
1271         PUSH(XML_OP_ROOT, NULL, NULL);
1272         NEXT;
1273         /* Check for incompleteness. */
1274         SKIP_BLANKS;
1275         if (CUR == 0) {
1276         ERROR5(NULL, NULL, NULL,
1277             &quot;Incomplete expression &#39;%s&#39;.\n&quot;, ctxt-&gt;base);
1278         ctxt-&gt;error = 1;
1279         goto error;
1280         }
1281     }
1282     xmlCompileStepPattern(ctxt);
1283     if (ctxt-&gt;error != 0)
1284         goto error;
1285     SKIP_BLANKS;
1286     while (CUR == &#39;/&#39;) {
1287         if (NXT(1) == &#39;/&#39;) {
1288             PUSH(XML_OP_ANCESTOR, NULL, NULL);
1289         NEXT;
1290         NEXT;
1291         SKIP_BLANKS;
1292         xmlCompileStepPattern(ctxt);
1293         if (ctxt-&gt;error != 0)
1294             goto error;
1295         } else {
1296             PUSH(XML_OP_PARENT, NULL, NULL);
1297         NEXT;
1298         SKIP_BLANKS;
1299         if (CUR == 0) {
1300             ERROR5(NULL, NULL, NULL,
1301             &quot;Incomplete expression &#39;%s&#39;.\n&quot;, ctxt-&gt;base);
1302             ctxt-&gt;error = 1;
1303             goto error;
1304         }
1305         xmlCompileStepPattern(ctxt);
1306         if (ctxt-&gt;error != 0)
1307             goto error;
1308         }
1309     }
1310     }
1311     if (CUR != 0) {
1312     ERROR5(NULL, NULL, NULL,
1313            &quot;Failed to compile pattern %s\n&quot;, ctxt-&gt;base);
1314     ctxt-&gt;error = 1;
1315     }
1316 error:
1317     return;
1318 }
1319 
1320 /**
1321  * xmlCompileIDCXPathPath:
1322  * @ctxt:  the compilation context
1323  *
1324  * Compile the Path Pattern and generates a precompiled
1325  * form suitable for fast matching.
1326  *
1327  * [5]    Path    ::=    (&#39;.//&#39;)? ( Step &#39;/&#39; )* ( Step | &#39;@&#39; NameTest )
1328  */
1329 static void
1330 xmlCompileIDCXPathPath(xmlPatParserContextPtr ctxt) {
1331     SKIP_BLANKS;
1332     if (CUR == &#39;/&#39;) {
1333     ERROR5(NULL, NULL, NULL,
1334         &quot;Unexpected selection of the document root in &#39;%s&#39;.\n&quot;,
1335         ctxt-&gt;base);
1336     goto error;
1337     }
1338     ctxt-&gt;comp-&gt;flags |= PAT_FROM_CUR;
1339 
1340     if (CUR == &#39;.&#39;) {
1341     /* &quot;.&quot; - &quot;self::node()&quot; */
1342     NEXT;
1343     SKIP_BLANKS;
1344     if (CUR == 0) {
1345         /*
1346         * Selection of the context node.
1347         */
1348         PUSH(XML_OP_ELEM, NULL, NULL);
1349         return;
1350     }
1351     if (CUR != &#39;/&#39;) {
1352         /* TODO: A more meaningful error message. */
1353         ERROR5(NULL, NULL, NULL,
1354         &quot;Unexpected token after &#39;.&#39; in &#39;%s&#39;.\n&quot;, ctxt-&gt;base);
1355         goto error;
1356     }
1357     /* &quot;./&quot; - &quot;self::node()/&quot; */
1358     NEXT;
1359     SKIP_BLANKS;
1360     if (CUR == &#39;/&#39;) {
1361         if (IS_BLANK_CH(PEEKPREV(1))) {
1362         /*
1363         * Disallow &quot;./ /&quot;
1364         */
1365         ERROR5(NULL, NULL, NULL,
1366             &quot;Unexpected &#39;/&#39; token in &#39;%s&#39;.\n&quot;, ctxt-&gt;base);
1367         goto error;
1368         }
1369         /* &quot;.//&quot; - &quot;self:node()/descendant-or-self::node()/&quot; */
1370         PUSH(XML_OP_ANCESTOR, NULL, NULL);
1371         NEXT;
1372         SKIP_BLANKS;
1373     }
1374     if (CUR == 0)
1375         goto error_unfinished;
1376     }
1377     /*
1378     * Process steps.
1379     */
1380     do {
1381     xmlCompileStepPattern(ctxt);
1382     if (ctxt-&gt;error != 0)
1383         goto error;
1384     SKIP_BLANKS;
1385     if (CUR != &#39;/&#39;)
1386         break;
1387     PUSH(XML_OP_PARENT, NULL, NULL);
1388     NEXT;
1389     SKIP_BLANKS;
1390     if (CUR == &#39;/&#39;) {
1391         /*
1392         * Disallow subsequent &#39;//&#39;.
1393         */
1394         ERROR5(NULL, NULL, NULL,
1395         &quot;Unexpected subsequent &#39;//&#39; in &#39;%s&#39;.\n&quot;,
1396         ctxt-&gt;base);
1397         goto error;
1398     }
1399     if (CUR == 0)
1400         goto error_unfinished;
1401 
1402     } while (CUR != 0);
1403 
1404     if (CUR != 0) {
1405     ERROR5(NULL, NULL, NULL,
1406         &quot;Failed to compile expression &#39;%s&#39;.\n&quot;, ctxt-&gt;base);
1407     ctxt-&gt;error = 1;
1408     }
1409     return;
1410 error:
1411     ctxt-&gt;error = 1;
1412     return;
1413 
1414 error_unfinished:
1415     ctxt-&gt;error = 1;
1416     ERROR5(NULL, NULL, NULL,
1417     &quot;Unfinished expression &#39;%s&#39;.\n&quot;, ctxt-&gt;base);
1418     return;
1419 }
1420 
1421 /************************************************************************
1422  *                                  *
1423  *          The streaming code              *
1424  *                                  *
1425  ************************************************************************/
1426 
1427 #ifdef DEBUG_STREAMING
1428 static void
1429 xmlDebugStreamComp(xmlStreamCompPtr stream) {
1430     int i;
1431 
1432     if (stream == NULL) {
1433         printf(&quot;Stream: NULL\n&quot;);
1434     return;
1435     }
1436     printf(&quot;Stream: %d steps\n&quot;, stream-&gt;nbStep);
1437     for (i = 0;i &lt; stream-&gt;nbStep;i++) {
1438     if (stream-&gt;steps[i].ns != NULL) {
1439         printf(&quot;{%s}&quot;, stream-&gt;steps[i].ns);
1440     }
1441         if (stream-&gt;steps[i].name == NULL) {
1442         printf(&quot;* &quot;);
1443     } else {
1444         printf(&quot;%s &quot;, stream-&gt;steps[i].name);
1445     }
1446     if (stream-&gt;steps[i].flags &amp; XML_STREAM_STEP_ROOT)
1447         printf(&quot;root &quot;);
1448     if (stream-&gt;steps[i].flags &amp; XML_STREAM_STEP_DESC)
1449         printf(&quot;// &quot;);
1450     if (stream-&gt;steps[i].flags &amp; XML_STREAM_STEP_FINAL)
1451         printf(&quot;final &quot;);
1452     printf(&quot;\n&quot;);
1453     }
1454 }
1455 static void
1456 xmlDebugStreamCtxt(xmlStreamCtxtPtr ctxt, int match) {
1457     int i;
1458 
1459     if (ctxt == NULL) {
1460         printf(&quot;Stream: NULL\n&quot;);
1461     return;
1462     }
1463     printf(&quot;Stream: level %d, %d states: &quot;, ctxt-&gt;level, ctxt-&gt;nbState);
1464     if (match)
1465         printf(&quot;matches\n&quot;);
1466     else
1467         printf(&quot;\n&quot;);
1468     for (i = 0;i &lt; ctxt-&gt;nbState;i++) {
1469         if (ctxt-&gt;states[2 * i] &lt; 0)
1470         printf(&quot; %d: free\n&quot;, i);
1471     else {
1472         printf(&quot; %d: step %d, level %d&quot;, i, ctxt-&gt;states[2 * i],
1473                ctxt-&gt;states[(2 * i) + 1]);
1474             if (ctxt-&gt;comp-&gt;steps[ctxt-&gt;states[2 * i]].flags &amp;
1475             XML_STREAM_STEP_DESC)
1476             printf(&quot; //\n&quot;);
1477         else
1478             printf(&quot;\n&quot;);
1479     }
1480     }
1481 }
1482 #endif
1483 /**
1484  * xmlNewStreamComp:
1485  * @size: the number of expected steps
1486  *
1487  * build a new compiled pattern for streaming
1488  *
1489  * Returns the new structure or NULL in case of error.
1490  */
1491 static xmlStreamCompPtr
1492 xmlNewStreamComp(int size) {
1493     xmlStreamCompPtr cur;
1494 
1495     if (size &lt; 4)
1496         size  = 4;
1497 
1498     cur = (xmlStreamCompPtr) xmlMalloc(sizeof(xmlStreamComp));
1499     if (cur == NULL) {
1500     ERROR(NULL, NULL, NULL,
1501         &quot;xmlNewStreamComp: malloc failed\n&quot;);
1502     return(NULL);
1503     }
1504     memset(cur, 0, sizeof(xmlStreamComp));
1505     cur-&gt;steps = (xmlStreamStepPtr) xmlMalloc(size * sizeof(xmlStreamStep));
1506     if (cur-&gt;steps == NULL) {
1507     xmlFree(cur);
1508     ERROR(NULL, NULL, NULL,
1509           &quot;xmlNewStreamComp: malloc failed\n&quot;);
1510     return(NULL);
1511     }
1512     cur-&gt;nbStep = 0;
1513     cur-&gt;maxStep = size;
1514     return(cur);
1515 }
1516 
1517 /**
1518  * xmlFreeStreamComp:
1519  * @comp: the compiled pattern for streaming
1520  *
1521  * Free the compiled pattern for streaming
1522  */
1523 static void
1524 xmlFreeStreamComp(xmlStreamCompPtr comp) {
1525     if (comp != NULL) {
1526         if (comp-&gt;steps != NULL)
1527         xmlFree(comp-&gt;steps);
1528     if (comp-&gt;dict != NULL)
1529         xmlDictFree(comp-&gt;dict);
1530         xmlFree(comp);
1531     }
1532 }
1533 
1534 /**
1535  * xmlStreamCompAddStep:
1536  * @comp: the compiled pattern for streaming
1537  * @name: the first string, the name, or NULL for *
1538  * @ns: the second step, the namespace name
1539  * @flags: the flags for that step
1540  *
1541  * Add a new step to the compiled pattern
1542  *
1543  * Returns -1 in case of error or the step index if successful
1544  */
1545 static int
1546 xmlStreamCompAddStep(xmlStreamCompPtr comp, const xmlChar *name,
1547                      const xmlChar *ns, int nodeType, int flags) {
1548     xmlStreamStepPtr cur;
1549 
1550     if (comp-&gt;nbStep &gt;= comp-&gt;maxStep) {
1551     cur = (xmlStreamStepPtr) xmlRealloc(comp-&gt;steps,
1552                  comp-&gt;maxStep * 2 * sizeof(xmlStreamStep));
1553     if (cur == NULL) {
1554         ERROR(NULL, NULL, NULL,
1555           &quot;xmlNewStreamComp: malloc failed\n&quot;);
1556         return(-1);
1557     }
1558     comp-&gt;steps = cur;
1559         comp-&gt;maxStep *= 2;
1560     }
1561     cur = &amp;comp-&gt;steps[comp-&gt;nbStep++];
1562     cur-&gt;flags = flags;
1563     cur-&gt;name = name;
1564     cur-&gt;ns = ns;
1565     cur-&gt;nodeType = nodeType;
1566     return(comp-&gt;nbStep - 1);
1567 }
1568 
1569 /**
1570  * xmlStreamCompile:
1571  * @comp: the precompiled pattern
1572  *
1573  * Tries to stream compile a pattern
1574  *
1575  * Returns -1 in case of failure and 0 in case of success.
1576  */
1577 static int
1578 xmlStreamCompile(xmlPatternPtr comp) {
1579     xmlStreamCompPtr stream;
1580     int i, s = 0, root = 0, flags = 0, prevs = -1;
1581     xmlStepOp step;
1582 
1583     if ((comp == NULL) || (comp-&gt;steps == NULL))
1584         return(-1);
1585     /*
1586      * special case for .
1587      */
1588     if ((comp-&gt;nbStep == 1) &amp;&amp;
1589         (comp-&gt;steps[0].op == XML_OP_ELEM) &amp;&amp;
1590     (comp-&gt;steps[0].value == NULL) &amp;&amp;
1591     (comp-&gt;steps[0].value2 == NULL)) {
1592     stream = xmlNewStreamComp(0);
1593     if (stream == NULL)
1594         return(-1);
1595     /* Note that the stream will have no steps in this case. */
1596     stream-&gt;flags |= XML_STREAM_FINAL_IS_ANY_NODE;
1597     comp-&gt;stream = stream;
1598     return(0);
1599     }
1600 
1601     stream = xmlNewStreamComp((comp-&gt;nbStep / 2) + 1);
1602     if (stream == NULL)
1603         return(-1);
1604     if (comp-&gt;dict != NULL) {
1605         stream-&gt;dict = comp-&gt;dict;
1606     xmlDictReference(stream-&gt;dict);
1607     }
1608 
1609     i = 0;
1610     if (comp-&gt;flags &amp; PAT_FROM_ROOT)
1611     stream-&gt;flags |= XML_STREAM_FROM_ROOT;
1612 
1613     for (;i &lt; comp-&gt;nbStep;i++) {
1614     step = comp-&gt;steps[i];
1615         switch (step.op) {
1616         case XML_OP_END:
1617             break;
1618         case XML_OP_ROOT:
1619             if (i != 0)
1620             goto error;
1621         root = 1;
1622         break;
1623         case XML_OP_NS:
1624         s = xmlStreamCompAddStep(stream, NULL, step.value,
1625             XML_ELEMENT_NODE, flags);
1626         if (s &lt; 0)
1627             goto error;
1628         prevs = s;
1629         flags = 0;
1630         break;
1631         case XML_OP_ATTR:
1632         flags |= XML_STREAM_STEP_ATTR;
1633         prevs = -1;
1634         s = xmlStreamCompAddStep(stream,
1635             step.value, step.value2, XML_ATTRIBUTE_NODE, flags);
1636         flags = 0;
1637         if (s &lt; 0)
1638             goto error;
1639         break;
1640         case XML_OP_ELEM:
1641             if ((step.value == NULL) &amp;&amp; (step.value2 == NULL)) {
1642             /*
1643             * We have a &quot;.&quot; or &quot;self::node()&quot; here.
1644             * Eliminate redundant self::node() tests like in &quot;/./.&quot;
1645             * or &quot;//./&quot;
1646             * The only case we won&#39;t eliminate is &quot;//.&quot;, i.e. if
1647             * self::node() is the last node test and we had
1648             * continuation somewhere beforehand.
1649             */
1650             if ((comp-&gt;nbStep == i + 1) &amp;&amp;
1651             (flags &amp; XML_STREAM_STEP_DESC)) {
1652             /*
1653             * Mark the special case where the expression resolves
1654             * to any type of node.
1655             */
1656             if (comp-&gt;nbStep == i + 1) {
1657                 stream-&gt;flags |= XML_STREAM_FINAL_IS_ANY_NODE;
1658             }
1659             flags |= XML_STREAM_STEP_NODE;
1660             s = xmlStreamCompAddStep(stream, NULL, NULL,
1661                 XML_STREAM_ANY_NODE, flags);
1662             if (s &lt; 0)
1663                 goto error;
1664             flags = 0;
1665             /*
1666             * If there was a previous step, mark it to be added to
1667             * the result node-set; this is needed since only
1668             * the last step will be marked as &quot;final&quot; and only
1669             * &quot;final&quot; nodes are added to the resulting set.
1670             */
1671             if (prevs != -1) {
1672                 stream-&gt;steps[prevs].flags |= XML_STREAM_STEP_IN_SET;
1673                 prevs = -1;
1674             }
1675             break;
1676 
1677             } else {
1678             /* Just skip this one. */
1679             continue;
1680             }
1681         }
1682         /* An element node. */
1683             s = xmlStreamCompAddStep(stream, step.value, step.value2,
1684             XML_ELEMENT_NODE, flags);
1685         if (s &lt; 0)
1686             goto error;
1687         prevs = s;
1688         flags = 0;
1689         break;
1690         case XML_OP_CHILD:
1691         /* An element node child. */
1692             s = xmlStreamCompAddStep(stream, step.value, step.value2,
1693             XML_ELEMENT_NODE, flags);
1694         if (s &lt; 0)
1695             goto error;
1696         prevs = s;
1697         flags = 0;
1698         break;
1699         case XML_OP_ALL:
1700             s = xmlStreamCompAddStep(stream, NULL, NULL,
1701             XML_ELEMENT_NODE, flags);
1702         if (s &lt; 0)
1703             goto error;
1704         prevs = s;
1705         flags = 0;
1706         break;
1707         case XML_OP_PARENT:
1708             break;
1709         case XML_OP_ANCESTOR:
1710         /* Skip redundant continuations. */
1711         if (flags &amp; XML_STREAM_STEP_DESC)
1712             break;
1713             flags |= XML_STREAM_STEP_DESC;
1714         /*
1715         * Mark the expression as having &quot;//&quot;.
1716         */
1717         if ((stream-&gt;flags &amp; XML_STREAM_DESC) == 0)
1718             stream-&gt;flags |= XML_STREAM_DESC;
1719         break;
1720     }
1721     }
1722     if ((! root) &amp;&amp; (comp-&gt;flags &amp; XML_PATTERN_NOTPATTERN) == 0) {
1723     /*
1724     * If this should behave like a real pattern, we will mark
1725     * the first step as having &quot;//&quot;, to be reentrant on every
1726     * tree level.
1727     */
1728     if ((stream-&gt;flags &amp; XML_STREAM_DESC) == 0)
1729         stream-&gt;flags |= XML_STREAM_DESC;
1730 
1731     if (stream-&gt;nbStep &gt; 0) {
1732         if ((stream-&gt;steps[0].flags &amp; XML_STREAM_STEP_DESC) == 0)
1733         stream-&gt;steps[0].flags |= XML_STREAM_STEP_DESC;
1734     }
1735     }
1736     if (stream-&gt;nbStep &lt;= s)
1737     goto error;
1738     stream-&gt;steps[s].flags |= XML_STREAM_STEP_FINAL;
1739     if (root)
1740     stream-&gt;steps[0].flags |= XML_STREAM_STEP_ROOT;
1741 #ifdef DEBUG_STREAMING
1742     xmlDebugStreamComp(stream);
1743 #endif
1744     comp-&gt;stream = stream;
1745     return(0);
1746 error:
1747     xmlFreeStreamComp(stream);
1748     return(0);
1749 }
1750 
1751 /**
1752  * xmlNewStreamCtxt:
1753  * @size: the number of expected states
1754  *
1755  * build a new stream context
1756  *
1757  * Returns the new structure or NULL in case of error.
1758  */
1759 static xmlStreamCtxtPtr
1760 xmlNewStreamCtxt(xmlStreamCompPtr stream) {
1761     xmlStreamCtxtPtr cur;
1762 
1763     cur = (xmlStreamCtxtPtr) xmlMalloc(sizeof(xmlStreamCtxt));
1764     if (cur == NULL) {
1765     ERROR(NULL, NULL, NULL,
1766         &quot;xmlNewStreamCtxt: malloc failed\n&quot;);
1767     return(NULL);
1768     }
1769     memset(cur, 0, sizeof(xmlStreamCtxt));
1770     cur-&gt;states = (int *) xmlMalloc(4 * 2 * sizeof(int));
1771     if (cur-&gt;states == NULL) {
1772     xmlFree(cur);
1773     ERROR(NULL, NULL, NULL,
1774           &quot;xmlNewStreamCtxt: malloc failed\n&quot;);
1775     return(NULL);
1776     }
1777     cur-&gt;nbState = 0;
1778     cur-&gt;maxState = 4;
1779     cur-&gt;level = 0;
1780     cur-&gt;comp = stream;
1781     cur-&gt;blockLevel = -1;
1782     return(cur);
1783 }
1784 
1785 /**
1786  * xmlFreeStreamCtxt:
1787  * @stream: the stream context
1788  *
1789  * Free the stream context
1790  */
1791 void
1792 xmlFreeStreamCtxt(xmlStreamCtxtPtr stream) {
1793     xmlStreamCtxtPtr next;
1794 
1795     while (stream != NULL) {
1796         next = stream-&gt;next;
1797         if (stream-&gt;states != NULL)
1798         xmlFree(stream-&gt;states);
1799         xmlFree(stream);
1800     stream = next;
1801     }
1802 }
1803 
1804 /**
1805  * xmlStreamCtxtAddState:
1806  * @comp: the stream context
1807  * @idx: the step index for that streaming state
1808  *
1809  * Add a new state to the stream context
1810  *
1811  * Returns -1 in case of error or the state index if successful
1812  */
1813 static int
1814 xmlStreamCtxtAddState(xmlStreamCtxtPtr comp, int idx, int level) {
1815     int i;
1816     for (i = 0;i &lt; comp-&gt;nbState;i++) {
1817         if (comp-&gt;states[2 * i] &lt; 0) {
1818         comp-&gt;states[2 * i] = idx;
1819         comp-&gt;states[2 * i + 1] = level;
1820         return(i);
1821     }
1822     }
1823     if (comp-&gt;nbState &gt;= comp-&gt;maxState) {
1824         int *cur;
1825 
1826     cur = (int *) xmlRealloc(comp-&gt;states,
1827                  comp-&gt;maxState * 4 * sizeof(int));
1828     if (cur == NULL) {
1829         ERROR(NULL, NULL, NULL,
1830           &quot;xmlNewStreamCtxt: malloc failed\n&quot;);
1831         return(-1);
1832     }
1833     comp-&gt;states = cur;
1834         comp-&gt;maxState *= 2;
1835     }
1836     comp-&gt;states[2 * comp-&gt;nbState] = idx;
1837     comp-&gt;states[2 * comp-&gt;nbState++ + 1] = level;
1838     return(comp-&gt;nbState - 1);
1839 }
1840 
1841 /**
1842  * xmlStreamPushInternal:
1843  * @stream: the stream context
1844  * @name: the current name
1845  * @ns: the namespace name
1846  * @nodeType: the type of the node
1847  *
1848  * Push new data onto the stream. NOTE: if the call xmlPatterncompile()
1849  * indicated a dictionary, then strings for name and ns will be expected
1850  * to come from the dictionary.
1851  * Both @name and @ns being NULL means the / i.e. the root of the document.
1852  * This can also act as a reset.
1853  *
1854  * Returns: -1 in case of error, 1 if the current state in the stream is a
1855  *    match and 0 otherwise.
1856  */
1857 static int
1858 xmlStreamPushInternal(xmlStreamCtxtPtr stream,
1859               const xmlChar *name, const xmlChar *ns,
1860               int nodeType) {
1861     int ret = 0, err = 0, final = 0, tmp, i, m, match, stepNr, desc;
1862     xmlStreamCompPtr comp;
1863     xmlStreamStep step;
1864 #ifdef DEBUG_STREAMING
1865     xmlStreamCtxtPtr orig = stream;
1866 #endif
1867 
1868     if ((stream == NULL) || (stream-&gt;nbState &lt; 0))
1869         return(-1);
1870 
1871     while (stream != NULL) {
1872     comp = stream-&gt;comp;
1873 
1874     if ((nodeType == XML_ELEMENT_NODE) &amp;&amp;
1875         (name == NULL) &amp;&amp; (ns == NULL)) {
1876         /* We have a document node here (or a reset). */
1877         stream-&gt;nbState = 0;
1878         stream-&gt;level = 0;
1879         stream-&gt;blockLevel = -1;
1880         if (comp-&gt;flags &amp; XML_STREAM_FROM_ROOT) {
1881         if (comp-&gt;nbStep == 0) {
1882             /* TODO: We have a &quot;/.&quot; here? */
1883             ret = 1;
1884         } else {
1885             if ((comp-&gt;nbStep == 1) &amp;&amp;
1886             (comp-&gt;steps[0].nodeType == XML_STREAM_ANY_NODE) &amp;&amp;
1887             (comp-&gt;steps[0].flags &amp; XML_STREAM_STEP_DESC))
1888             {
1889             /*
1890             * In the case of &quot;//.&quot; the document node will match
1891             * as well.
1892             */
1893             ret = 1;
1894             } else if (comp-&gt;steps[0].flags &amp; XML_STREAM_STEP_ROOT) {
1895             /* TODO: Do we need this ? */
1896             tmp = xmlStreamCtxtAddState(stream, 0, 0);
1897             if (tmp &lt; 0)
1898                 err++;
1899             }
1900         }
1901         }
1902         stream = stream-&gt;next;
1903         continue; /* while */
1904     }
1905 
1906     /*
1907     * Fast check for &quot;.&quot;.
1908     */
1909     if (comp-&gt;nbStep == 0) {
1910         /*
1911          * / and . are handled at the XPath node set creation
1912          * level by checking min depth
1913          */
1914         if (stream-&gt;flags &amp; XML_PATTERN_XPATH) {
1915         stream = stream-&gt;next;
1916         continue; /* while */
1917         }
1918         /*
1919         * For non-pattern like evaluation like XML Schema IDCs
1920         * or traditional XPath expressions, this will match if
1921         * we are at the first level only, otherwise on every level.
1922         */
1923         if ((nodeType != XML_ATTRIBUTE_NODE) &amp;&amp;
1924         (((stream-&gt;flags &amp; XML_PATTERN_NOTPATTERN) == 0) ||
1925         (stream-&gt;level == 0))) {
1926             ret = 1;
1927         }
1928         stream-&gt;level++;
1929         goto stream_next;
1930     }
1931     if (stream-&gt;blockLevel != -1) {
1932         /*
1933         * Skip blocked expressions.
1934         */
1935         stream-&gt;level++;
1936         goto stream_next;
1937     }
1938 
1939     if ((nodeType != XML_ELEMENT_NODE) &amp;&amp;
1940         (nodeType != XML_ATTRIBUTE_NODE) &amp;&amp;
1941         ((comp-&gt;flags &amp; XML_STREAM_FINAL_IS_ANY_NODE) == 0)) {
1942         /*
1943         * No need to process nodes of other types if we don&#39;t
1944         * resolve to those types.
1945         * TODO: Do we need to block the context here?
1946         */
1947         stream-&gt;level++;
1948         goto stream_next;
1949     }
1950 
1951     /*
1952      * Check evolution of existing states
1953      */
1954     i = 0;
1955     m = stream-&gt;nbState;
1956     while (i &lt; m) {
1957         if ((comp-&gt;flags &amp; XML_STREAM_DESC) == 0) {
1958         /*
1959         * If there is no &quot;//&quot;, then only the last
1960         * added state is of interest.
1961         */
1962         stepNr = stream-&gt;states[2 * (stream-&gt;nbState -1)];
1963         /*
1964         * TODO: Security check, should not happen, remove it.
1965         */
1966         if (stream-&gt;states[(2 * (stream-&gt;nbState -1)) + 1] &lt;
1967             stream-&gt;level) {
1968             return (-1);
1969         }
1970         desc = 0;
1971         /* loop-stopper */
1972         i = m;
1973         } else {
1974         /*
1975         * If there are &quot;//&quot;, then we need to process every &quot;//&quot;
1976         * occuring in the states, plus any other state for this
1977         * level.
1978         */
1979         stepNr = stream-&gt;states[2 * i];
1980 
1981         /* TODO: should not happen anymore: dead states */
1982         if (stepNr &lt; 0)
1983             goto next_state;
1984 
1985         tmp = stream-&gt;states[(2 * i) + 1];
1986 
1987         /* skip new states just added */
1988         if (tmp &gt; stream-&gt;level)
1989             goto next_state;
1990 
1991         /* skip states at ancestor levels, except if &quot;//&quot; */
1992         desc = comp-&gt;steps[stepNr].flags &amp; XML_STREAM_STEP_DESC;
1993         if ((tmp &lt; stream-&gt;level) &amp;&amp; (!desc))
1994             goto next_state;
1995         }
1996         /*
1997         * Check for correct node-type.
1998         */
1999         step = comp-&gt;steps[stepNr];
2000         if (step.nodeType != nodeType) {
2001         if (step.nodeType == XML_ATTRIBUTE_NODE) {
2002             /*
2003             * Block this expression for deeper evaluation.
2004             */
2005             if ((comp-&gt;flags &amp; XML_STREAM_DESC) == 0)
2006             stream-&gt;blockLevel = stream-&gt;level +1;
2007             goto next_state;
2008         } else if (step.nodeType != XML_STREAM_ANY_NODE)
2009             goto next_state;
2010         }
2011         /*
2012         * Compare local/namespace-name.
2013         */
2014         match = 0;
2015         if (step.nodeType == XML_STREAM_ANY_NODE) {
2016         match = 1;
2017         } else if (step.name == NULL) {
2018         if (step.ns == NULL) {
2019             /*
2020             * This lets through all elements/attributes.
2021             */
2022             match = 1;
2023         } else if (ns != NULL)
2024             match = xmlStrEqual(step.ns, ns);
2025         } else if (((step.ns != NULL) == (ns != NULL)) &amp;&amp;
2026         (name != NULL) &amp;&amp;
2027         (step.name[0] == name[0]) &amp;&amp;
2028         xmlStrEqual(step.name, name) &amp;&amp;
2029         ((step.ns == ns) || xmlStrEqual(step.ns, ns)))
2030         {
2031         match = 1;
2032         }
2033 #if 0
2034 /*
2035 * TODO: Pointer comparison won&#39;t work, since not guaranteed that the given
2036 *  values are in the same dict; especially if it&#39;s the namespace name,
2037 *  normally coming from ns-&gt;href. We need a namespace dict mechanism !
2038 */
2039         } else if (comp-&gt;dict) {
2040         if (step.name == NULL) {
2041             if (step.ns == NULL)
2042             match = 1;
2043             else
2044             match = (step.ns == ns);
2045         } else {
2046             match = ((step.name == name) &amp;&amp; (step.ns == ns));
2047         }
2048 #endif /* if 0 ------------------------------------------------------- */
2049         if (match) {
2050         final = step.flags &amp; XML_STREAM_STEP_FINAL;
2051         if (desc) {
2052             if (final) {
2053             ret = 1;
2054             } else {
2055             /* descending match create a new state */
2056             xmlStreamCtxtAddState(stream, stepNr + 1,
2057                                   stream-&gt;level + 1);
2058             }
2059         } else {
2060             if (final) {
2061             ret = 1;
2062             } else {
2063             xmlStreamCtxtAddState(stream, stepNr + 1,
2064                                   stream-&gt;level + 1);
2065             }
2066         }
2067         if ((ret != 1) &amp;&amp; (step.flags &amp; XML_STREAM_STEP_IN_SET)) {
2068             /*
2069             * Check if we have a special case like &quot;foo/bar//.&quot;, where
2070             * &quot;foo&quot; is selected as well.
2071             */
2072             ret = 1;
2073         }
2074         }
2075         if (((comp-&gt;flags &amp; XML_STREAM_DESC) == 0) &amp;&amp;
2076         ((! match) || final))  {
2077         /*
2078         * Mark this expression as blocked for any evaluation at
2079         * deeper levels. Note that this includes &quot;/foo&quot;
2080         * expressions if the *pattern* behaviour is used.
2081         */
2082         stream-&gt;blockLevel = stream-&gt;level +1;
2083         }
2084 next_state:
2085         i++;
2086     }
2087 
2088     stream-&gt;level++;
2089 
2090     /*
2091     * Re/enter the expression.
2092     * Don&#39;t reenter if it&#39;s an absolute expression like &quot;/foo&quot;,
2093     *   except &quot;//foo&quot;.
2094     */
2095     step = comp-&gt;steps[0];
2096     if (step.flags &amp; XML_STREAM_STEP_ROOT)
2097         goto stream_next;
2098 
2099     desc = step.flags &amp; XML_STREAM_STEP_DESC;
2100     if (stream-&gt;flags &amp; XML_PATTERN_NOTPATTERN) {
2101         /*
2102         * Re/enter the expression if it is a &quot;descendant&quot; one,
2103         * or if we are at the 1st level of evaluation.
2104         */
2105 
2106         if (stream-&gt;level == 1) {
2107         if (XML_STREAM_XS_IDC(stream)) {
2108             /*
2109             * XS-IDC: The missing &quot;self::node()&quot; will always
2110             * match the first given node.
2111             */
2112             goto stream_next;
2113         } else
2114             goto compare;
2115         }
2116         /*
2117         * A &quot;//&quot; is always reentrant.
2118         */
2119         if (desc)
2120         goto compare;
2121 
2122         /*
2123         * XS-IDC: Process the 2nd level, since the missing
2124         * &quot;self::node()&quot; is responsible for the 2nd level being
2125         * the real start level.
2126         */
2127         if ((stream-&gt;level == 2) &amp;&amp; XML_STREAM_XS_IDC(stream))
2128         goto compare;
2129 
2130         goto stream_next;
2131     }
2132 
2133 compare:
2134     /*
2135     * Check expected node-type.
2136     */
2137     if (step.nodeType != nodeType) {
2138         if (nodeType == XML_ATTRIBUTE_NODE)
2139         goto stream_next;
2140         else if (step.nodeType != XML_STREAM_ANY_NODE)
2141         goto stream_next;
2142     }
2143     /*
2144     * Compare local/namespace-name.
2145     */
2146     match = 0;
2147     if (step.nodeType == XML_STREAM_ANY_NODE) {
2148         match = 1;
2149     } else if (step.name == NULL) {
2150         if (step.ns == NULL) {
2151         /*
2152         * This lets through all elements/attributes.
2153         */
2154         match = 1;
2155         } else if (ns != NULL)
2156         match = xmlStrEqual(step.ns, ns);
2157     } else if (((step.ns != NULL) == (ns != NULL)) &amp;&amp;
2158         (name != NULL) &amp;&amp;
2159         (step.name[0] == name[0]) &amp;&amp;
2160         xmlStrEqual(step.name, name) &amp;&amp;
2161         ((step.ns == ns) || xmlStrEqual(step.ns, ns)))
2162     {
2163         match = 1;
2164     }
2165     final = step.flags &amp; XML_STREAM_STEP_FINAL;
2166     if (match) {
2167         if (final)
2168         ret = 1;
2169         else
2170         xmlStreamCtxtAddState(stream, 1, stream-&gt;level);
2171         if ((ret != 1) &amp;&amp; (step.flags &amp; XML_STREAM_STEP_IN_SET)) {
2172         /*
2173         * Check if we have a special case like &quot;foo//.&quot;, where
2174         * &quot;foo&quot; is selected as well.
2175         */
2176         ret = 1;
2177         }
2178     }
2179     if (((comp-&gt;flags &amp; XML_STREAM_DESC) == 0) &amp;&amp;
2180         ((! match) || final))  {
2181         /*
2182         * Mark this expression as blocked for any evaluation at
2183         * deeper levels.
2184         */
2185         stream-&gt;blockLevel = stream-&gt;level;
2186     }
2187 
2188 stream_next:
2189         stream = stream-&gt;next;
2190     } /* while stream != NULL */
2191 
2192     if (err &gt; 0)
2193         ret = -1;
2194 #ifdef DEBUG_STREAMING
2195     xmlDebugStreamCtxt(orig, ret);
2196 #endif
2197     return(ret);
2198 }
2199 
2200 /**
2201  * xmlStreamPush:
2202  * @stream: the stream context
2203  * @name: the current name
2204  * @ns: the namespace name
2205  *
2206  * Push new data onto the stream. NOTE: if the call xmlPatterncompile()
2207  * indicated a dictionary, then strings for name and ns will be expected
2208  * to come from the dictionary.
2209  * Both @name and @ns being NULL means the / i.e. the root of the document.
2210  * This can also act as a reset.
2211  * Otherwise the function will act as if it has been given an element-node.
2212  *
2213  * Returns: -1 in case of error, 1 if the current state in the stream is a
2214  *    match and 0 otherwise.
2215  */
2216 int
2217 xmlStreamPush(xmlStreamCtxtPtr stream,
2218               const xmlChar *name, const xmlChar *ns) {
2219     return (xmlStreamPushInternal(stream, name, ns, (int) XML_ELEMENT_NODE));
2220 }
2221 
2222 /**
2223  * xmlStreamPushNode:
2224  * @stream: the stream context
2225  * @name: the current name
2226  * @ns: the namespace name
2227  * @nodeType: the type of the node being pushed
2228  *
2229  * Push new data onto the stream. NOTE: if the call xmlPatterncompile()
2230  * indicated a dictionary, then strings for name and ns will be expected
2231  * to come from the dictionary.
2232  * Both @name and @ns being NULL means the / i.e. the root of the document.
2233  * This can also act as a reset.
2234  * Different from xmlStreamPush() this function can be fed with nodes of type:
2235  * element-, attribute-, text-, cdata-section-, comment- and
2236  * processing-instruction-node.
2237  *
2238  * Returns: -1 in case of error, 1 if the current state in the stream is a
2239  *    match and 0 otherwise.
2240  */
2241 int
2242 xmlStreamPushNode(xmlStreamCtxtPtr stream,
2243           const xmlChar *name, const xmlChar *ns,
2244           int nodeType)
2245 {
2246     return (xmlStreamPushInternal(stream, name, ns,
2247     nodeType));
2248 }
2249 
2250 /**
2251 * xmlStreamPushAttr:
2252 * @stream: the stream context
2253 * @name: the current name
2254 * @ns: the namespace name
2255 *
2256 * Push new attribute data onto the stream. NOTE: if the call xmlPatterncompile()
2257 * indicated a dictionary, then strings for name and ns will be expected
2258 * to come from the dictionary.
2259 * Both @name and @ns being NULL means the / i.e. the root of the document.
2260 * This can also act as a reset.
2261 * Otherwise the function will act as if it has been given an attribute-node.
2262 *
2263 * Returns: -1 in case of error, 1 if the current state in the stream is a
2264 *    match and 0 otherwise.
2265 */
2266 int
2267 xmlStreamPushAttr(xmlStreamCtxtPtr stream,
2268           const xmlChar *name, const xmlChar *ns) {
2269     return (xmlStreamPushInternal(stream, name, ns, (int) XML_ATTRIBUTE_NODE));
2270 }
2271 
2272 /**
2273  * xmlStreamPop:
2274  * @stream: the stream context
2275  *
2276  * push one level from the stream.
2277  *
2278  * Returns: -1 in case of error, 0 otherwise.
2279  */
2280 int
2281 xmlStreamPop(xmlStreamCtxtPtr stream) {
2282     int i, lev;
2283 
2284     if (stream == NULL)
2285         return(-1);
2286     while (stream != NULL) {
2287     /*
2288     * Reset block-level.
2289     */
2290     if (stream-&gt;blockLevel == stream-&gt;level)
2291         stream-&gt;blockLevel = -1;
2292 
2293     /*
2294      *  stream-&gt;level can be zero when XML_FINAL_IS_ANY_NODE is set
2295      *  (see the thread at
2296      *  http://mail.gnome.org/archives/xslt/2008-July/msg00027.html)
2297      */
2298     if (stream-&gt;level)
2299         stream-&gt;level--;
2300     /*
2301      * Check evolution of existing states
2302      */
2303     for (i = stream-&gt;nbState -1; i &gt;= 0; i--) {
2304         /* discard obsoleted states */
2305         lev = stream-&gt;states[(2 * i) + 1];
2306         if (lev &gt; stream-&gt;level)
2307         stream-&gt;nbState--;
2308         if (lev &lt;= stream-&gt;level)
2309         break;
2310     }
2311     stream = stream-&gt;next;
2312     }
2313     return(0);
2314 }
2315 
2316 /**
2317  * xmlStreamWantsAnyNode:
2318  * @streamCtxt: the stream context
2319  *
2320  * Query if the streaming pattern additionally needs to be fed with
2321  * text-, cdata-section-, comment- and processing-instruction-nodes.
2322  * If the result is 0 then only element-nodes and attribute-nodes
2323  * need to be pushed.
2324  *
2325  * Returns: 1 in case of need of nodes of the above described types,
2326  *          0 otherwise. -1 on API errors.
2327  */
2328 int
2329 xmlStreamWantsAnyNode(xmlStreamCtxtPtr streamCtxt)
2330 {
2331     if (streamCtxt == NULL)
2332     return(-1);
2333     while (streamCtxt != NULL) {
2334     if (streamCtxt-&gt;comp-&gt;flags &amp; XML_STREAM_FINAL_IS_ANY_NODE)
2335         return(1);
2336     streamCtxt = streamCtxt-&gt;next;
2337     }
2338     return(0);
2339 }
2340 
2341 /************************************************************************
2342  *                                  *
2343  *          The public interfaces               *
2344  *                                  *
2345  ************************************************************************/
2346 
2347 /**
2348  * xmlPatterncompile:
2349  * @pattern: the pattern to compile
2350  * @dict: an optional dictionary for interned strings
2351  * @flags: compilation flags, see xmlPatternFlags
2352  * @namespaces: the prefix definitions, array of [URI, prefix] or NULL
2353  *
2354  * Compile a pattern.
2355  *
2356  * Returns the compiled form of the pattern or NULL in case of error
2357  */
2358 xmlPatternPtr
2359 xmlPatterncompile(const xmlChar *pattern, xmlDict *dict, int flags,
2360                   const xmlChar **namespaces) {
2361     xmlPatternPtr ret = NULL, cur;
2362     xmlPatParserContextPtr ctxt = NULL;
2363     const xmlChar *or, *start;
2364     xmlChar *tmp = NULL;
2365     int type = 0;
2366     int streamable = 1;
2367 
2368     if (pattern == NULL)
2369         return(NULL);
2370 
2371     start = pattern;
2372     or = start;
2373     while (*or != 0) {
2374     tmp = NULL;
2375     while ((*or != 0) &amp;&amp; (*or != &#39;|&#39;)) or++;
2376         if (*or == 0)
2377         ctxt = xmlNewPatParserContext(start, dict, namespaces);
2378     else {
2379         tmp = xmlStrndup(start, or - start);
2380         if (tmp != NULL) {
2381         ctxt = xmlNewPatParserContext(tmp, dict, namespaces);
2382         }
2383         or++;
2384     }
2385     if (ctxt == NULL) goto error;
2386     cur = xmlNewPattern();
2387     if (cur == NULL) goto error;
2388     /*
2389     * Assign string dict.
2390     */
2391     if (dict) {
2392         cur-&gt;dict = dict;
2393         xmlDictReference(dict);
2394     }
2395     if (ret == NULL)
2396         ret = cur;
2397     else {
2398         cur-&gt;next = ret-&gt;next;
2399         ret-&gt;next = cur;
2400     }
2401     cur-&gt;flags = flags;
2402     ctxt-&gt;comp = cur;
2403 
2404     if (XML_STREAM_XS_IDC(cur))
2405         xmlCompileIDCXPathPath(ctxt);
2406     else
2407         xmlCompilePathPattern(ctxt);
2408     if (ctxt-&gt;error != 0)
2409         goto error;
2410     xmlFreePatParserContext(ctxt);
2411     ctxt = NULL;
2412 
2413 
2414         if (streamable) {
2415         if (type == 0) {
2416             type = cur-&gt;flags &amp; (PAT_FROM_ROOT | PAT_FROM_CUR);
2417         } else if (type == PAT_FROM_ROOT) {
2418             if (cur-&gt;flags &amp; PAT_FROM_CUR)
2419             streamable = 0;
2420         } else if (type == PAT_FROM_CUR) {
2421             if (cur-&gt;flags &amp; PAT_FROM_ROOT)
2422             streamable = 0;
2423         }
2424     }
2425     if (streamable)
2426         xmlStreamCompile(cur);
2427     if (xmlReversePattern(cur) &lt; 0)
2428         goto error;
2429     if (tmp != NULL) {
2430         xmlFree(tmp);
2431         tmp = NULL;
2432     }
2433     start = or;
2434     }
2435     if (streamable == 0) {
2436         cur = ret;
2437     while (cur != NULL) {
2438         if (cur-&gt;stream != NULL) {
2439         xmlFreeStreamComp(cur-&gt;stream);
2440         cur-&gt;stream = NULL;
2441         }
2442         cur = cur-&gt;next;
2443     }
2444     }
2445 
2446     return(ret);
2447 error:
2448     if (ctxt != NULL) xmlFreePatParserContext(ctxt);
2449     if (ret != NULL) xmlFreePattern(ret);
2450     if (tmp != NULL) xmlFree(tmp);
2451     return(NULL);
2452 }
2453 
2454 /**
2455  * xmlPatternMatch:
2456  * @comp: the precompiled pattern
2457  * @node: a node
2458  *
2459  * Test whether the node matches the pattern
2460  *
2461  * Returns 1 if it matches, 0 if it doesn&#39;t and -1 in case of failure
2462  */
2463 int
2464 xmlPatternMatch(xmlPatternPtr comp, xmlNodePtr node)
2465 {
2466     int ret = 0;
2467 
2468     if ((comp == NULL) || (node == NULL))
2469         return(-1);
2470 
2471     while (comp != NULL) {
2472         ret = xmlPatMatch(comp, node);
2473     if (ret != 0)
2474         return(ret);
2475     comp = comp-&gt;next;
2476     }
2477     return(ret);
2478 }
2479 
2480 /**
2481  * xmlPatternGetStreamCtxt:
2482  * @comp: the precompiled pattern
2483  *
2484  * Get a streaming context for that pattern
2485  * Use xmlFreeStreamCtxt to free the context.
2486  *
2487  * Returns a pointer to the context or NULL in case of failure
2488  */
2489 xmlStreamCtxtPtr
2490 xmlPatternGetStreamCtxt(xmlPatternPtr comp)
2491 {
2492     xmlStreamCtxtPtr ret = NULL, cur;
2493 
2494     if ((comp == NULL) || (comp-&gt;stream == NULL))
2495         return(NULL);
2496 
2497     while (comp != NULL) {
2498         if (comp-&gt;stream == NULL)
2499         goto failed;
2500     cur = xmlNewStreamCtxt(comp-&gt;stream);
2501     if (cur == NULL)
2502         goto failed;
2503     if (ret == NULL)
2504         ret = cur;
2505     else {
2506         cur-&gt;next = ret-&gt;next;
2507         ret-&gt;next = cur;
2508     }
2509     cur-&gt;flags = comp-&gt;flags;
2510     comp = comp-&gt;next;
2511     }
2512     return(ret);
2513 failed:
2514     xmlFreeStreamCtxt(ret);
2515     return(NULL);
2516 }
2517 
2518 /**
2519  * xmlPatternStreamable:
2520  * @comp: the precompiled pattern
2521  *
2522  * Check if the pattern is streamable i.e. xmlPatternGetStreamCtxt()
2523  * should work.
2524  *
2525  * Returns 1 if streamable, 0 if not and -1 in case of error.
2526  */
2527 int
2528 xmlPatternStreamable(xmlPatternPtr comp) {
2529     if (comp == NULL)
2530         return(-1);
2531     while (comp != NULL) {
2532         if (comp-&gt;stream == NULL)
2533         return(0);
2534     comp = comp-&gt;next;
2535     }
2536     return(1);
2537 }
2538 
2539 /**
2540  * xmlPatternMaxDepth:
2541  * @comp: the precompiled pattern
2542  *
2543  * Check the maximum depth reachable by a pattern
2544  *
2545  * Returns -2 if no limit (using //), otherwise the depth,
2546  *         and -1 in case of error
2547  */
2548 int
2549 xmlPatternMaxDepth(xmlPatternPtr comp) {
2550     int ret = 0, i;
2551     if (comp == NULL)
2552         return(-1);
2553     while (comp != NULL) {
2554         if (comp-&gt;stream == NULL)
2555         return(-1);
2556     for (i = 0;i &lt; comp-&gt;stream-&gt;nbStep;i++)
2557         if (comp-&gt;stream-&gt;steps[i].flags &amp; XML_STREAM_STEP_DESC)
2558             return(-2);
2559     if (comp-&gt;stream-&gt;nbStep &gt; ret)
2560         ret = comp-&gt;stream-&gt;nbStep;
2561     comp = comp-&gt;next;
2562     }
2563     return(ret);
2564 }
2565 
2566 /**
2567  * xmlPatternMinDepth:
2568  * @comp: the precompiled pattern
2569  *
2570  * Check the minimum depth reachable by a pattern, 0 mean the / or . are
2571  * part of the set.
2572  *
2573  * Returns -1 in case of error otherwise the depth,
2574  *
2575  */
2576 int
2577 xmlPatternMinDepth(xmlPatternPtr comp) {
2578     int ret = 12345678;
2579     if (comp == NULL)
2580         return(-1);
2581     while (comp != NULL) {
2582         if (comp-&gt;stream == NULL)
2583         return(-1);
2584     if (comp-&gt;stream-&gt;nbStep &lt; ret)
2585         ret = comp-&gt;stream-&gt;nbStep;
2586     if (ret == 0)
2587         return(0);
2588     comp = comp-&gt;next;
2589     }
2590     return(ret);
2591 }
2592 
2593 /**
2594  * xmlPatternFromRoot:
2595  * @comp: the precompiled pattern
2596  *
2597  * Check if the pattern must be looked at from the root.
2598  *
2599  * Returns 1 if true, 0 if false and -1 in case of error
2600  */
2601 int
2602 xmlPatternFromRoot(xmlPatternPtr comp) {
2603     if (comp == NULL)
2604         return(-1);
2605     while (comp != NULL) {
2606         if (comp-&gt;stream == NULL)
2607         return(-1);
2608     if (comp-&gt;flags &amp; PAT_FROM_ROOT)
2609         return(1);
2610     comp = comp-&gt;next;
2611     }
2612     return(0);
2613 
2614 }
2615 
2616 #define bottom_pattern
2617 #include &quot;elfgcchack.h&quot;
2618 #endif /* LIBXML_PATTERN_ENABLED */
    </pre>
  </body>
</html>
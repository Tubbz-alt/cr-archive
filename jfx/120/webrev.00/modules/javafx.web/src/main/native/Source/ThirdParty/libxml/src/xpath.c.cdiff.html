<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/xpath.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="xmlwriter.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="xzlib.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/xpath.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 341,11 ***</span>
          }
      }
      }
  
      /*
<span class="line-modified">!      * Speedup using document order if availble.</span>
       */
      if ((node1-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
      (node2-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
      (0 &gt; (ptrdiff_t) node1-&gt;content) &amp;&amp;
      (0 &gt; (ptrdiff_t) node2-&gt;content) &amp;&amp;
<span class="line-new-header">--- 341,11 ---</span>
          }
      }
      }
  
      /*
<span class="line-modified">!      * Speedup using document order if available.</span>
       */
      if ((node1-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
      (node2-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
      (0 &gt; (ptrdiff_t) node1-&gt;content) &amp;&amp;
      (0 &gt; (ptrdiff_t) node2-&gt;content) &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 409,11 ***</span>
      if (node1 == node2-&gt;prev)
      return(1);
      if (node1 == node2-&gt;next)
      return(-1);
      /*
<span class="line-modified">!      * Speedup using document order if availble.</span>
       */
      if ((node1-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
      (node2-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
      (0 &gt; (ptrdiff_t) node1-&gt;content) &amp;&amp;
      (0 &gt; (ptrdiff_t) node2-&gt;content) &amp;&amp;
<span class="line-new-header">--- 409,11 ---</span>
      if (node1 == node2-&gt;prev)
      return(1);
      if (node1 == node2-&gt;next)
      return(-1);
      /*
<span class="line-modified">!      * Speedup using document order if available.</span>
       */
      if ((node1-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
      (node2-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
      (0 &gt; (ptrdiff_t) node1-&gt;content) &amp;&amp;
      (0 &gt; (ptrdiff_t) node2-&gt;content) &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 433,11 ***</span>
      return(-1); /* assume there is no sibling list corruption */
  }
  #endif /* XP_OPTIMIZED_NON_ELEM_COMPARISON */
  
  /*
<span class="line-modified">!  * Wrapper for the Timsort argorithm from timsort.h</span>
   */
  #ifdef WITH_TIM_SORT
  #define SORT_NAME libxml_domnode
  #define SORT_TYPE xmlNodePtr
  /**
<span class="line-new-header">--- 433,11 ---</span>
      return(-1); /* assume there is no sibling list corruption */
  }
  #endif /* XP_OPTIMIZED_NON_ELEM_COMPARISON */
  
  /*
<span class="line-modified">!  * Wrapper for the Timsort algorithm from timsort.h</span>
   */
  #ifdef WITH_TIM_SORT
  #define SORT_NAME libxml_domnode
  #define SORT_TYPE xmlNodePtr
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 608,10 ***</span>
<span class="line-new-header">--- 608,12 ---</span>
      &quot;Encoding error\n&quot;,
      &quot;Char out of XML range\n&quot;,
      &quot;Invalid or incomplete context\n&quot;,
      &quot;Stack usage error\n&quot;,
      &quot;Forbidden variable\n&quot;,
<span class="line-added">+     &quot;Operation limit exceeded\n&quot;,</span>
<span class="line-added">+     &quot;Recursion limit exceeded\n&quot;,</span>
      &quot;?? Unknown error ??\n&quot; /* Must be last in the list! */
  };
  #define MAXERRNO ((int)(sizeof(xmlXPathErrorMessages) / \
             sizeof(xmlXPathErrorMessages[0])) - 1)
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 623,10 ***</span>
<span class="line-new-header">--- 625,11 ---</span>
   */
  static void
  xmlXPathErrMemory(xmlXPathContextPtr ctxt, const char *extra)
  {
      if (ctxt != NULL) {
<span class="line-added">+         xmlResetError(&amp;ctxt-&gt;lastError);</span>
          if (extra) {
              xmlChar buf[200];
  
              xmlStrPrintf(buf, 200,
                           &quot;Memory allocation failed : %s\n&quot;,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 745,10 ***</span>
<span class="line-new-header">--- 748,36 ---</span>
  xmlXPatherror(xmlXPathParserContextPtr ctxt, const char *file ATTRIBUTE_UNUSED,
                int line ATTRIBUTE_UNUSED, int no) {
      xmlXPathErr(ctxt, no);
  }
  
<span class="line-added">+ /**</span>
<span class="line-added">+  * xmlXPathCheckOpLimit:</span>
<span class="line-added">+  * @ctxt:  the XPath Parser context</span>
<span class="line-added">+  * @opCount:  the number of operations to be added</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Adds opCount to the running total of operations and returns -1 if the</span>
<span class="line-added">+  * operation limit is exceeded. Returns 0 otherwise.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ static int</span>
<span class="line-added">+ xmlXPathCheckOpLimit(xmlXPathParserContextPtr ctxt, unsigned long opCount) {</span>
<span class="line-added">+     xmlXPathContextPtr xpctxt = ctxt-&gt;context;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if ((opCount &gt; xpctxt-&gt;opLimit) ||</span>
<span class="line-added">+         (xpctxt-&gt;opCount &gt; xpctxt-&gt;opLimit - opCount)) {</span>
<span class="line-added">+         xpctxt-&gt;opCount = xpctxt-&gt;opLimit;</span>
<span class="line-added">+         xmlXPathErr(ctxt, XPATH_OP_LIMIT_EXCEEDED);</span>
<span class="line-added">+         return(-1);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     xpctxt-&gt;opCount += opCount;</span>
<span class="line-added">+     return(0);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define OP_LIMIT_EXCEEDED(ctxt, n) \</span>
<span class="line-added">+     ((ctxt-&gt;context-&gt;opLimit != 0) &amp;&amp; (xmlXPathCheckOpLimit(ctxt, n) &lt; 0))</span>
<span class="line-added">+ </span>
  /************************************************************************
   *                                  *
   *          Utilities                   *
   *                                  *
   ************************************************************************/
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1074,26 ***</span>
   * Add a step to an XPath Compiled Expression
   *
   * Returns -1 in case of failure, the index otherwise
   */
  static int
<span class="line-modified">! xmlXPathCompExprAdd(xmlXPathCompExprPtr comp, int ch1, int ch2,</span>
     xmlXPathOp op, int value,
     int value2, int value3, void *value4, void *value5) {
      if (comp-&gt;nbStep &gt;= comp-&gt;maxStep) {
      xmlXPathStepOp *real;
  
          if (comp-&gt;maxStep &gt;= XPATH_MAX_STEPS) {
<span class="line-modified">!         xmlXPathErrMemory(NULL, &quot;adding step\n&quot;);</span>
          return(-1);
          }
      comp-&gt;maxStep *= 2;
      real = (xmlXPathStepOp *) xmlRealloc(comp-&gt;steps,
                                comp-&gt;maxStep * sizeof(xmlXPathStepOp));
      if (real == NULL) {
          comp-&gt;maxStep /= 2;
<span class="line-modified">!         xmlXPathErrMemory(NULL, &quot;adding step\n&quot;);</span>
          return(-1);
      }
      comp-&gt;steps = real;
      }
      comp-&gt;last = comp-&gt;nbStep;
<span class="line-new-header">--- 1103,27 ---</span>
   * Add a step to an XPath Compiled Expression
   *
   * Returns -1 in case of failure, the index otherwise
   */
  static int
<span class="line-modified">! xmlXPathCompExprAdd(xmlXPathParserContextPtr ctxt, int ch1, int ch2,</span>
     xmlXPathOp op, int value,
     int value2, int value3, void *value4, void *value5) {
<span class="line-added">+     xmlXPathCompExprPtr comp = ctxt-&gt;comp;</span>
      if (comp-&gt;nbStep &gt;= comp-&gt;maxStep) {
      xmlXPathStepOp *real;
  
          if (comp-&gt;maxStep &gt;= XPATH_MAX_STEPS) {
<span class="line-modified">!         xmlXPathPErrMemory(ctxt, &quot;adding step\n&quot;);</span>
          return(-1);
          }
      comp-&gt;maxStep *= 2;
      real = (xmlXPathStepOp *) xmlRealloc(comp-&gt;steps,
                                comp-&gt;maxStep * sizeof(xmlXPathStepOp));
      if (real == NULL) {
          comp-&gt;maxStep /= 2;
<span class="line-modified">!         xmlXPathPErrMemory(ctxt, &quot;adding step\n&quot;);</span>
          return(-1);
      }
      comp-&gt;steps = real;
      }
      comp-&gt;last = comp-&gt;nbStep;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1151,24 ***</span>
      op-&gt;ch1 = op-&gt;ch2;
      op-&gt;ch2 = tmp;
  }
  
  #define PUSH_FULL_EXPR(op, op1, op2, val, val2, val3, val4, val5)   \
<span class="line-modified">!     xmlXPathCompExprAdd(ctxt-&gt;comp, (op1), (op2),           \</span>
                      (op), (val), (val2), (val3), (val4), (val5))
  #define PUSH_LONG_EXPR(op, val, val2, val3, val4, val5)         \
<span class="line-modified">!     xmlXPathCompExprAdd(ctxt-&gt;comp, ctxt-&gt;comp-&gt;last, -1,       \</span>
                      (op), (val), (val2), (val3), (val4), (val5))
  
  #define PUSH_LEAVE_EXPR(op, val, val2)                  \
<span class="line-modified">! xmlXPathCompExprAdd(ctxt-&gt;comp, -1, -1, (op), (val), (val2), 0 ,NULL ,NULL)</span>
  
  #define PUSH_UNARY_EXPR(op, ch, val, val2)              \
<span class="line-modified">! xmlXPathCompExprAdd(ctxt-&gt;comp, (ch), -1, (op), (val), (val2), 0 ,NULL ,NULL)</span>
  
  #define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)           \
<span class="line-modified">! xmlXPathCompExprAdd(ctxt-&gt;comp, (ch1), (ch2), (op),         \</span>
              (val), (val2), 0 ,NULL ,NULL)
  
  /************************************************************************
   *                                  *
   *      XPath object cache structures               *
<span class="line-new-header">--- 1181,24 ---</span>
      op-&gt;ch1 = op-&gt;ch2;
      op-&gt;ch2 = tmp;
  }
  
  #define PUSH_FULL_EXPR(op, op1, op2, val, val2, val3, val4, val5)   \
<span class="line-modified">!     xmlXPathCompExprAdd(ctxt, (op1), (op2),         \</span>
                      (op), (val), (val2), (val3), (val4), (val5))
  #define PUSH_LONG_EXPR(op, val, val2, val3, val4, val5)         \
<span class="line-modified">!     xmlXPathCompExprAdd(ctxt, ctxt-&gt;comp-&gt;last, -1,     \</span>
                      (op), (val), (val2), (val3), (val4), (val5))
  
  #define PUSH_LEAVE_EXPR(op, val, val2)                  \
<span class="line-modified">! xmlXPathCompExprAdd(ctxt, -1, -1, (op), (val), (val2), 0 ,NULL ,NULL)</span>
  
  #define PUSH_UNARY_EXPR(op, ch, val, val2)              \
<span class="line-modified">! xmlXPathCompExprAdd(ctxt, (ch), -1, (op), (val), (val2), 0 ,NULL ,NULL)</span>
  
  #define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)           \
<span class="line-modified">! xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),           \</span>
              (val), (val2), 0 ,NULL ,NULL)
  
  /************************************************************************
   *                                  *
   *      XPath object cache structures               *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2224,11 ***</span>
  /**
   * xmlXPathContextSetCache:
   *
   * @ctxt:  the XPath context
   * @active: enables/disables (creates/frees) the cache
<span class="line-modified">!  * @value: a value with semantics dependant on @options</span>
   * @options: options (currently only the value 0 is used)
   *
   * Creates/frees an object cache on the XPath context.
   * If activates XPath objects (xmlXPathObject) will be cached internally
   * to be reused.
<span class="line-new-header">--- 2254,11 ---</span>
  /**
   * xmlXPathContextSetCache:
   *
   * @ctxt:  the XPath context
   * @active: enables/disables (creates/frees) the cache
<span class="line-modified">!  * @value: a value with semantics dependent on @options</span>
   * @options: options (currently only the value 0 is used)
   *
   * Creates/frees an object cache on the XPath context.
   * If activates XPath objects (xmlXPathObject) will be cached internally
   * to be reused.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2384,20 ***</span>
      if ((cache-&gt;nodesetObjs != NULL) &amp;&amp;
          (cache-&gt;nodesetObjs-&gt;number != 0))
      {
          xmlXPathObjectPtr ret;
          /*
<span class="line-modified">!         * Use the nodset-cache.</span>
          */
          ret = (xmlXPathObjectPtr)
          cache-&gt;nodesetObjs-&gt;items[--cache-&gt;nodesetObjs-&gt;number];
          ret-&gt;type = XPATH_NODESET;
          ret-&gt;boolval = 0;
          if (val) {
          if ((ret-&gt;nodesetval-&gt;nodeMax == 0) ||
              (val-&gt;type == XML_NAMESPACE_DECL))
          {
              xmlXPathNodeSetAddUnique(ret-&gt;nodesetval, val);
          } else {
              ret-&gt;nodesetval-&gt;nodeTab[0] = val;
              ret-&gt;nodesetval-&gt;nodeNr = 1;
          }
<span class="line-new-header">--- 2414,21 ---</span>
      if ((cache-&gt;nodesetObjs != NULL) &amp;&amp;
          (cache-&gt;nodesetObjs-&gt;number != 0))
      {
          xmlXPathObjectPtr ret;
          /*
<span class="line-modified">!         * Use the nodeset-cache.</span>
          */
          ret = (xmlXPathObjectPtr)
          cache-&gt;nodesetObjs-&gt;items[--cache-&gt;nodesetObjs-&gt;number];
          ret-&gt;type = XPATH_NODESET;
          ret-&gt;boolval = 0;
          if (val) {
          if ((ret-&gt;nodesetval-&gt;nodeMax == 0) ||
              (val-&gt;type == XML_NAMESPACE_DECL))
          {
<span class="line-added">+                     /* TODO: Check memory error. */</span>
              xmlXPathNodeSetAddUnique(ret-&gt;nodesetval, val);
          } else {
              ret-&gt;nodesetval-&gt;nodeTab[0] = val;
              ret-&gt;nodesetval-&gt;nodeNr = 1;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2840,33 ***</span>
  /**
   * valuePush:
   * @ctxt:  an XPath evaluation context
   * @value:  the XPath object
   *
<span class="line-modified">!  * Pushes a new XPath object on top of the value stack</span>
   *
<span class="line-modified">!  * returns the number of items on the value stack</span>
   */
  int
  valuePush(xmlXPathParserContextPtr ctxt, xmlXPathObjectPtr value)
  {
<span class="line-modified">!     if ((ctxt == NULL) || (value == NULL)) return(-1);</span>
      if (ctxt-&gt;valueNr &gt;= ctxt-&gt;valueMax) {
          xmlXPathObjectPtr *tmp;
  
          if (ctxt-&gt;valueMax &gt;= XPATH_MAX_STACK_DEPTH) {
<span class="line-modified">!             xmlXPathErrMemory(NULL, &quot;XPath stack depth limit reached\n&quot;);</span>
<span class="line-modified">!             ctxt-&gt;error = XPATH_MEMORY_ERROR;</span>
<span class="line-removed">-             return (0);</span>
          }
          tmp = (xmlXPathObjectPtr *) xmlRealloc(ctxt-&gt;valueTab,
                                               2 * ctxt-&gt;valueMax *
                                               sizeof(ctxt-&gt;valueTab[0]));
          if (tmp == NULL) {
<span class="line-modified">!             xmlXPathErrMemory(NULL, &quot;pushing value\n&quot;);</span>
<span class="line-modified">!             ctxt-&gt;error = XPATH_MEMORY_ERROR;</span>
<span class="line-removed">-             return (0);</span>
          }
          ctxt-&gt;valueMax *= 2;
      ctxt-&gt;valueTab = tmp;
      }
      ctxt-&gt;valueTab[ctxt-&gt;valueNr] = value;
<span class="line-new-header">--- 2871,40 ---</span>
  /**
   * valuePush:
   * @ctxt:  an XPath evaluation context
   * @value:  the XPath object
   *
<span class="line-modified">!  * Pushes a new XPath object on top of the value stack. If value is NULL,</span>
<span class="line-added">+  * a memory error is recorded in the parser context.</span>
   *
<span class="line-modified">!  * Returns the number of items on the value stack, or -1 in case of error.</span>
   */
  int
  valuePush(xmlXPathParserContextPtr ctxt, xmlXPathObjectPtr value)
  {
<span class="line-modified">!     if (ctxt == NULL) return(-1);</span>
<span class="line-added">+     if (value == NULL) {</span>
<span class="line-added">+         /*</span>
<span class="line-added">+          * A NULL value typically indicates that a memory allocation failed,</span>
<span class="line-added">+          * so we set ctxt-&gt;error here to propagate the error.</span>
<span class="line-added">+          */</span>
<span class="line-added">+     ctxt-&gt;error = XPATH_MEMORY_ERROR;</span>
<span class="line-added">+         return(-1);</span>
<span class="line-added">+     }</span>
      if (ctxt-&gt;valueNr &gt;= ctxt-&gt;valueMax) {
          xmlXPathObjectPtr *tmp;
  
          if (ctxt-&gt;valueMax &gt;= XPATH_MAX_STACK_DEPTH) {
<span class="line-modified">!             xmlXPathPErrMemory(ctxt, &quot;XPath stack depth limit reached\n&quot;);</span>
<span class="line-modified">!             return (-1);</span>
          }
          tmp = (xmlXPathObjectPtr *) xmlRealloc(ctxt-&gt;valueTab,
                                               2 * ctxt-&gt;valueMax *
                                               sizeof(ctxt-&gt;valueTab[0]));
          if (tmp == NULL) {
<span class="line-modified">!             xmlXPathPErrMemory(ctxt, &quot;pushing value\n&quot;);</span>
<span class="line-modified">!             return (-1);</span>
          }
          ctxt-&gt;valueMax *= 2;
      ctxt-&gt;valueTab = tmp;
      }
      ctxt-&gt;valueTab[ctxt-&gt;valueNr] = value;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3318,11 ***</span>
      return(1);
      if (node1 == node2-&gt;next)
      return(-1);
  
      /*
<span class="line-modified">!      * Speedup using document order if availble.</span>
       */
      if ((node1-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
      (node2-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
      (0 &gt; (ptrdiff_t) node1-&gt;content) &amp;&amp;
      (0 &gt; (ptrdiff_t) node2-&gt;content) &amp;&amp;
<span class="line-new-header">--- 3356,11 ---</span>
      return(1);
      if (node1 == node2-&gt;next)
      return(-1);
  
      /*
<span class="line-modified">!      * Speedup using document order if available.</span>
       */
      if ((node1-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
      (node2-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
      (0 &gt; (ptrdiff_t) node1-&gt;content) &amp;&amp;
      (0 &gt; (ptrdiff_t) node2-&gt;content) &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3381,11 ***</span>
      if (node1 == node2-&gt;prev)
      return(1);
      if (node1 == node2-&gt;next)
      return(-1);
      /*
<span class="line-modified">!      * Speedup using document order if availble.</span>
       */
      if ((node1-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
      (node2-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
      (0 &gt; (ptrdiff_t) node1-&gt;content) &amp;&amp;
      (0 &gt; (ptrdiff_t) node2-&gt;content) &amp;&amp;
<span class="line-new-header">--- 3419,11 ---</span>
      if (node1 == node2-&gt;prev)
      return(1);
      if (node1 == node2-&gt;next)
      return(-1);
      /*
<span class="line-modified">!      * Speedup using document order if available.</span>
       */
      if ((node1-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
      (node2-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
      (0 &gt; (ptrdiff_t) node1-&gt;content) &amp;&amp;
      (0 &gt; (ptrdiff_t) node2-&gt;content) &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3545,49 ***</span>
             XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));
          ret-&gt;nodeMax = XML_NODESET_DEFAULT;
      if (val-&gt;type == XML_NAMESPACE_DECL) {
          xmlNsPtr ns = (xmlNsPtr) val;
  
          ret-&gt;nodeTab[ret-&gt;nodeNr++] =
          xmlXPathNodeSetDupNs((xmlNodePtr) ns-&gt;next, ns);
      } else
          ret-&gt;nodeTab[ret-&gt;nodeNr++] = val;
      }
      return(ret);
  }
  
<span class="line-removed">- /**</span>
<span class="line-removed">-  * xmlXPathNodeSetCreateSize:</span>
<span class="line-removed">-  * @size:  the initial size of the set</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * Create a new xmlNodeSetPtr of type double and of value @val</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * Returns the newly created object.</span>
<span class="line-removed">-  */</span>
<span class="line-removed">- static xmlNodeSetPtr</span>
<span class="line-removed">- xmlXPathNodeSetCreateSize(int size) {</span>
<span class="line-removed">-     xmlNodeSetPtr ret;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ret = (xmlNodeSetPtr) xmlMalloc(sizeof(xmlNodeSet));</span>
<span class="line-removed">-     if (ret == NULL) {</span>
<span class="line-removed">-         xmlXPathErrMemory(NULL, &quot;creating nodeset\n&quot;);</span>
<span class="line-removed">-     return(NULL);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     memset(ret, 0 , (size_t) sizeof(xmlNodeSet));</span>
<span class="line-removed">-     if (size &lt; XML_NODESET_DEFAULT)</span>
<span class="line-removed">-     size = XML_NODESET_DEFAULT;</span>
<span class="line-removed">-     ret-&gt;nodeTab = (xmlNodePtr *) xmlMalloc(size * sizeof(xmlNodePtr));</span>
<span class="line-removed">-     if (ret-&gt;nodeTab == NULL) {</span>
<span class="line-removed">-     xmlXPathErrMemory(NULL, &quot;creating nodeset\n&quot;);</span>
<span class="line-removed">-     xmlFree(ret);</span>
<span class="line-removed">-     return(NULL);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     memset(ret-&gt;nodeTab, 0 , size * (size_t) sizeof(xmlNodePtr));</span>
<span class="line-removed">-     ret-&gt;nodeMax = size;</span>
<span class="line-removed">-     return(ret);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  /**
   * xmlXPathNodeSetContains:
   * @cur:  the node-set
   * @val:  the node
   *
<span class="line-new-header">--- 3583,19 ---</span>
             XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));
          ret-&gt;nodeMax = XML_NODESET_DEFAULT;
      if (val-&gt;type == XML_NAMESPACE_DECL) {
          xmlNsPtr ns = (xmlNsPtr) val;
  
<span class="line-added">+             /* TODO: Check memory error. */</span>
          ret-&gt;nodeTab[ret-&gt;nodeNr++] =
          xmlXPathNodeSetDupNs((xmlNodePtr) ns-&gt;next, ns);
      } else
          ret-&gt;nodeTab[ret-&gt;nodeNr++] = val;
      }
      return(ret);
  }
  
  /**
   * xmlXPathNodeSetContains:
   * @cur:  the node-set
   * @val:  the node
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3682,10 ***</span>
<span class="line-new-header">--- 3690,11 ---</span>
          return(-1);
      }
          cur-&gt;nodeMax *= 2;
      cur-&gt;nodeTab = temp;
      }
<span class="line-added">+     /* TODO: Check memory error. */</span>
      cur-&gt;nodeTab[cur-&gt;nodeNr++] = xmlXPathNodeSetDupNs(node, ns);
      return(0);
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3740,10 ***</span>
<span class="line-new-header">--- 3749,11 ---</span>
      cur-&gt;nodeTab = temp;
      }
      if (val-&gt;type == XML_NAMESPACE_DECL) {
      xmlNsPtr ns = (xmlNsPtr) val;
  
<span class="line-added">+         /* TODO: Check memory error. */</span>
      cur-&gt;nodeTab[cur-&gt;nodeNr++] =
          xmlXPathNodeSetDupNs((xmlNodePtr) ns-&gt;next, ns);
      } else
      cur-&gt;nodeTab[cur-&gt;nodeNr++] = val;
      return(0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3794,10 ***</span>
<span class="line-new-header">--- 3804,11 ---</span>
          cur-&gt;nodeMax *= 2;
      }
      if (val-&gt;type == XML_NAMESPACE_DECL) {
      xmlNsPtr ns = (xmlNsPtr) val;
  
<span class="line-added">+         /* TODO: Check memory error. */</span>
      cur-&gt;nodeTab[cur-&gt;nodeNr++] =
          xmlXPathNodeSetDupNs((xmlNodePtr) ns-&gt;next, ns);
      } else
      cur-&gt;nodeTab[cur-&gt;nodeNr++] = val;
      return(0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3828,11 ***</span>
      * TODO: The optimization won&#39;t work in every case, since
      *  those nasty namespace nodes need to be added with
      *  xmlXPathNodeSetDupNs() to the set; thus a pure
      *  memcpy is not possible.
      *  If there was a flag on the nodesetval, indicating that
<span class="line-modified">!     *  some temporary nodes are in, that would be helpfull.</span>
      */
      /*
      * Optimization: Create an equally sized node-set
      * and memcpy the content.
      */
<span class="line-new-header">--- 3839,11 ---</span>
      * TODO: The optimization won&#39;t work in every case, since
      *  those nasty namespace nodes need to be added with
      *  xmlXPathNodeSetDupNs() to the set; thus a pure
      *  memcpy is not possible.
      *  If there was a flag on the nodesetval, indicating that
<span class="line-modified">!     *  some temporary nodes are in, that would be helpful.</span>
      */
      /*
      * Optimization: Create an equally sized node-set
      * and memcpy the content.
      */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3910,10 ***</span>
<span class="line-new-header">--- 3921,11 ---</span>
          val1-&gt;nodeMax *= 2;
      }
      if (n2-&gt;type == XML_NAMESPACE_DECL) {
          xmlNsPtr ns = (xmlNsPtr) n2;
  
<span class="line-added">+             /* TODO: Check memory error. */</span>
          val1-&gt;nodeTab[val1-&gt;nodeNr++] =
          xmlXPathNodeSetDupNs((xmlNodePtr) ns-&gt;next, ns);
      } else
          val1-&gt;nodeTab[val1-&gt;nodeNr++] = n2;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3924,53 ***</span>
  
  /**
   * xmlXPathNodeSetMergeAndClear:
   * @set1:  the first NodeSet or NULL
   * @set2:  the second NodeSet
<span class="line-removed">-  * @hasSet2NsNodes: 1 if set2 contains namespaces nodes</span>
   *
<span class="line-modified">!  * Merges two nodesets, all nodes from @set2 are added to @set1</span>
<span class="line-removed">-  * if @set1 is NULL, a new set is created and copied from @set2.</span>
   * Checks for duplicate nodes. Clears set2.
   *
   * Returns @set1 once extended or NULL in case of error.
   */
  static xmlNodeSetPtr
<span class="line-modified">! xmlXPathNodeSetMergeAndClear(xmlNodeSetPtr set1, xmlNodeSetPtr set2,</span>
<span class="line-modified">!                  int hasNullEntries)</span>
  {
<span class="line-removed">-     if ((set1 == NULL) &amp;&amp; (hasNullEntries == 0)) {</span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-     * Note that doing a memcpy of the list, namespace nodes are</span>
<span class="line-removed">-     * just assigned to set1, since set2 is cleared anyway.</span>
<span class="line-removed">-     */</span>
<span class="line-removed">-     set1 = xmlXPathNodeSetCreateSize(set2-&gt;nodeNr);</span>
<span class="line-removed">-     if (set1 == NULL)</span>
<span class="line-removed">-         return(NULL);</span>
<span class="line-removed">-     if (set2-&gt;nodeNr != 0) {</span>
<span class="line-removed">-         memcpy(set1-&gt;nodeTab, set2-&gt;nodeTab,</span>
<span class="line-removed">-         set2-&gt;nodeNr * sizeof(xmlNodePtr));</span>
<span class="line-removed">-         set1-&gt;nodeNr = set2-&gt;nodeNr;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     } else {</span>
      int i, j, initNbSet1;
      xmlNodePtr n1, n2;
  
<span class="line-removed">-     if (set1 == NULL)</span>
<span class="line-removed">-             set1 = xmlXPathNodeSetCreate(NULL);</span>
<span class="line-removed">-         if (set1 == NULL)</span>
<span class="line-removed">-             return (NULL);</span>
<span class="line-removed">- </span>
      initNbSet1 = set1-&gt;nodeNr;
      for (i = 0;i &lt; set2-&gt;nodeNr;i++) {
          n2 = set2-&gt;nodeTab[i];
          /*
<span class="line-removed">-         * Skip NULLed entries.</span>
<span class="line-removed">-         */</span>
<span class="line-removed">-         if (n2 == NULL)</span>
<span class="line-removed">-         continue;</span>
<span class="line-removed">-         /*</span>
          * Skip duplicates.
          */
          for (j = 0; j &lt; initNbSet1; j++) {
          n1 = set1-&gt;nodeTab[j];
          if (n1 == n2) {
<span class="line-new-header">--- 3936,27 ---</span>
  
  /**
   * xmlXPathNodeSetMergeAndClear:
   * @set1:  the first NodeSet or NULL
   * @set2:  the second NodeSet
   *
<span class="line-modified">!  * Merges two nodesets, all nodes from @set2 are added to @set1.</span>
   * Checks for duplicate nodes. Clears set2.
   *
   * Returns @set1 once extended or NULL in case of error.
   */
  static xmlNodeSetPtr
<span class="line-modified">! xmlXPathNodeSetMergeAndClear(xmlNodeSetPtr set1, xmlNodeSetPtr set2)</span>
<span class="line-modified">! {</span>
  {
      int i, j, initNbSet1;
      xmlNodePtr n1, n2;
  
      initNbSet1 = set1-&gt;nodeNr;
      for (i = 0;i &lt; set2-&gt;nodeNr;i++) {
          n2 = set2-&gt;nodeTab[i];
          /*
          * Skip duplicates.
          */
          for (j = 0; j &lt; initNbSet1; j++) {
          n1 = set1-&gt;nodeTab[j];
          if (n1 == n2) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4031,53 ***</span>
  
  /**
   * xmlXPathNodeSetMergeAndClearNoDupls:
   * @set1:  the first NodeSet or NULL
   * @set2:  the second NodeSet
<span class="line-removed">-  * @hasSet2NsNodes: 1 if set2 contains namespaces nodes</span>
   *
<span class="line-modified">!  * Merges two nodesets, all nodes from @set2 are added to @set1</span>
<span class="line-modified">!  * if @set1 is NULL, a new set is created and copied from @set2.</span>
<span class="line-removed">-  * Doesn&#39;t chack for duplicate nodes. Clears set2.</span>
   *
   * Returns @set1 once extended or NULL in case of error.
   */
  static xmlNodeSetPtr
<span class="line-modified">! xmlXPathNodeSetMergeAndClearNoDupls(xmlNodeSetPtr set1, xmlNodeSetPtr set2,</span>
<span class="line-modified">!                     int hasNullEntries)</span>
  {
<span class="line-removed">-     if (set2 == NULL)</span>
<span class="line-removed">-     return(set1);</span>
<span class="line-removed">-     if ((set1 == NULL) &amp;&amp; (hasNullEntries == 0)) {</span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-     * Note that doing a memcpy of the list, namespace nodes are</span>
<span class="line-removed">-     * just assigned to set1, since set2 is cleared anyway.</span>
<span class="line-removed">-     */</span>
<span class="line-removed">-     set1 = xmlXPathNodeSetCreateSize(set2-&gt;nodeNr);</span>
<span class="line-removed">-     if (set1 == NULL)</span>
<span class="line-removed">-         return(NULL);</span>
<span class="line-removed">-     if (set2-&gt;nodeNr != 0) {</span>
<span class="line-removed">-         memcpy(set1-&gt;nodeTab, set2-&gt;nodeTab,</span>
<span class="line-removed">-         set2-&gt;nodeNr * sizeof(xmlNodePtr));</span>
<span class="line-removed">-         set1-&gt;nodeNr = set2-&gt;nodeNr;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     } else {</span>
      int i;
      xmlNodePtr n2;
  
<span class="line-removed">-     if (set1 == NULL)</span>
<span class="line-removed">-         set1 = xmlXPathNodeSetCreate(NULL);</span>
<span class="line-removed">-         if (set1 == NULL)</span>
<span class="line-removed">-             return (NULL);</span>
<span class="line-removed">- </span>
      for (i = 0;i &lt; set2-&gt;nodeNr;i++) {
          n2 = set2-&gt;nodeTab[i];
<span class="line-removed">-         /*</span>
<span class="line-removed">-         * Skip NULLed entries.</span>
<span class="line-removed">-         */</span>
<span class="line-removed">-         if (n2 == NULL)</span>
<span class="line-removed">-         continue;</span>
          if (set1-&gt;nodeMax == 0) {
          set1-&gt;nodeTab = (xmlNodePtr *) xmlMalloc(
              XML_NODESET_DEFAULT * sizeof(xmlNodePtr));
          if (set1-&gt;nodeTab == NULL) {
              xmlXPathErrMemory(NULL, &quot;merging nodeset\n&quot;);
<span class="line-new-header">--- 4017,25 ---</span>
  
  /**
   * xmlXPathNodeSetMergeAndClearNoDupls:
   * @set1:  the first NodeSet or NULL
   * @set2:  the second NodeSet
   *
<span class="line-modified">!  * Merges two nodesets, all nodes from @set2 are added to @set1.</span>
<span class="line-modified">!  * Doesn&#39;t check for duplicate nodes. Clears set2.</span>
   *
   * Returns @set1 once extended or NULL in case of error.
   */
  static xmlNodeSetPtr
<span class="line-modified">! xmlXPathNodeSetMergeAndClearNoDupls(xmlNodeSetPtr set1, xmlNodeSetPtr set2)</span>
<span class="line-modified">! {</span>
  {
      int i;
      xmlNodePtr n2;
  
      for (i = 0;i &lt; set2-&gt;nodeNr;i++) {
          n2 = set2-&gt;nodeTab[i];
          if (set1-&gt;nodeMax == 0) {
          set1-&gt;nodeTab = (xmlNodePtr *) xmlMalloc(
              XML_NODESET_DEFAULT * sizeof(xmlNodePtr));
          if (set1-&gt;nodeTab == NULL) {
              xmlXPathErrMemory(NULL, &quot;merging nodeset\n&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4344,10 ***</span>
<span class="line-new-header">--- 4302,11 ---</span>
      return(NULL);
      }
      memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
      ret-&gt;type = XPATH_NODESET;
      ret-&gt;boolval = 0;
<span class="line-added">+     /* TODO: Check memory error. */</span>
      ret-&gt;nodesetval = xmlXPathNodeSetCreate(val);
      /* @@ with_ns to check whether namespace nodes should be looked at @@ */
  #ifdef XP_DEBUG_OBJ_USAGE
      xmlXPathDebugObjUsageRequested(NULL, XPATH_NODESET);
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4404,10 ***</span>
<span class="line-new-header">--- 4363,11 ---</span>
          ret = xmlXPathNewNodeSet(NULL);
      else {
          ret = xmlXPathNewNodeSet(val-&gt;nodeTab[0]);
          if (ret) {
              for (i = 1; i &lt; val-&gt;nodeNr; ++i) {
<span class="line-added">+                 /* TODO: Propagate memory error. */</span>
                  if (xmlXPathNodeSetAddUnique(ret-&gt;nodesetval, val-&gt;nodeTab[i])
              &lt; 0) break;
          }
      }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4475,19 ***</span>
<span class="line-new-header">--- 4435,21 ---</span>
      xmlNodePtr cur;
  
      if (xmlXPathNodeSetIsEmpty(nodes2))
      return(nodes1);
  
<span class="line-added">+     /* TODO: Check memory error. */</span>
      ret = xmlXPathNodeSetCreate(NULL);
      if (xmlXPathNodeSetIsEmpty(nodes1))
      return(ret);
  
      l1 = xmlXPathNodeSetGetLength(nodes1);
  
      for (i = 0; i &lt; l1; i++) {
      cur = xmlXPathNodeSetItem(nodes1, i);
      if (!xmlXPathNodeSetContains(nodes2, cur)) {
<span class="line-added">+             /* TODO: Propagate memory error. */</span>
          if (xmlXPathNodeSetAddUnique(ret, cur) &lt; 0)
              break;
      }
      }
      return(ret);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4520,10 ***</span>
<span class="line-new-header">--- 4482,11 ---</span>
      l1 = xmlXPathNodeSetGetLength(nodes1);
  
      for (i = 0; i &lt; l1; i++) {
      cur = xmlXPathNodeSetItem(nodes1, i);
      if (xmlXPathNodeSetContains(nodes2, cur)) {
<span class="line-added">+             /* TODO: Propagate memory error. */</span>
          if (xmlXPathNodeSetAddUnique(ret, cur) &lt; 0)
              break;
      }
      }
      return(ret);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4558,10 ***</span>
<span class="line-new-header">--- 4521,11 ---</span>
      for (i = 0; i &lt; l; i++) {
      cur = xmlXPathNodeSetItem(nodes, i);
      strval = xmlXPathCastNodeToString(cur);
      if (xmlHashLookup(hash, strval) == NULL) {
          xmlHashAddEntry(hash, strval, strval);
<span class="line-added">+             /* TODO: Propagate memory error. */</span>
          if (xmlXPathNodeSetAddUnique(ret, cur) &lt; 0)
              break;
      } else {
          xmlFree(strval);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4651,10 ***</span>
<span class="line-new-header">--- 4615,11 ---</span>
      l = xmlXPathNodeSetGetLength(nodes);
      for (i = 0; i &lt; l; i++) {
      cur = xmlXPathNodeSetItem(nodes, i);
      if (cur == node)
          break;
<span class="line-added">+         /* TODO: Propagate memory error. */</span>
      if (xmlXPathNodeSetAddUnique(ret, cur) &lt; 0)
          break;
      }
      return(ret);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4756,10 ***</span>
<span class="line-new-header">--- 4721,11 ---</span>
      l = xmlXPathNodeSetGetLength(nodes);
      for (i = l - 1; i &gt;= 0; i--) {
      cur = xmlXPathNodeSetItem(nodes, i);
      if (cur == node)
          break;
<span class="line-added">+         /* TODO: Propagate memory error. */</span>
      if (xmlXPathNodeSetAddUnique(ret, cur) &lt; 0)
          break;
      }
      xmlXPathNodeSetSort(ret);   /* bug 413451 */
      return(ret);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5455,10 ***</span>
<span class="line-new-header">--- 5421,11 ---</span>
          ret-&gt;nodesetval = xmlXPathNodeSetCreate(NULL);
          /* Deallocate the copied tree value */
          break;
  #endif
      case XPATH_NODESET:
<span class="line-added">+             /* TODO: Check memory error. */</span>
          ret-&gt;nodesetval = xmlXPathNodeSetMerge(NULL, val-&gt;nodesetval);
          /* Do not deallocate the copied tree value */
          ret-&gt;boolval = 0;
          break;
      case XPATH_LOCATIONSET:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5942,11 ***</span>
  
      if (val == NULL)
      return(NAN);
      switch (val-&gt;type) {
      case XPATH_UNDEFINED:
<span class="line-modified">! #ifdef DEGUB_EXPR</span>
      xmlGenericError(xmlGenericErrorContext, &quot;NUMBER: undefined\n&quot;);
  #endif
      ret = NAN;
      break;
      case XPATH_NODESET:
<span class="line-new-header">--- 5909,11 ---</span>
  
      if (val == NULL)
      return(NAN);
      switch (val-&gt;type) {
      case XPATH_UNDEFINED:
<span class="line-modified">! #ifdef DEBUG_EXPR</span>
      xmlGenericError(xmlGenericErrorContext, &quot;NUMBER: undefined\n&quot;);
  #endif
      ret = NAN;
      break;
      case XPATH_NODESET:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6151,10 ***</span>
<span class="line-new-header">--- 6118,13 ---</span>
      ret-&gt;user = NULL;
  
      ret-&gt;contextSize = -1;
      ret-&gt;proximityPosition = -1;
  
<span class="line-added">+     ret-&gt;maxDepth = INT_MAX;</span>
<span class="line-added">+     ret-&gt;maxParserDepth = INT_MAX;</span>
<span class="line-added">+ </span>
  #ifdef XP_DEFAULT_CACHE_ON
      if (xmlXPathContextSetCache(ret, 1, -1, 0) == -1) {
      xmlXPathFreeContext(ret);
      return(NULL);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6641,10 ***</span>
<span class="line-new-header">--- 6611,11 ---</span>
      return(0);
      }
  
      values2 = (double *) xmlMalloc(ns2-&gt;nodeNr * sizeof(double));
      if (values2 == NULL) {
<span class="line-added">+         /* TODO: Propagate memory error. */</span>
          xmlXPathErrMemory(NULL, &quot;comparing nodesets\n&quot;);
      xmlXPathFreeObject(arg1);
      xmlXPathFreeObject(arg2);
      return(0);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6901,29 ***</span>
<span class="line-new-header">--- 6872,33 ---</span>
          if (ns1-&gt;nodeTab[i] == ns2-&gt;nodeTab[j])
              return(1);
  
      values1 = (xmlChar **) xmlMalloc(ns1-&gt;nodeNr * sizeof(xmlChar *));
      if (values1 == NULL) {
<span class="line-added">+         /* TODO: Propagate memory error. */</span>
          xmlXPathErrMemory(NULL, &quot;comparing nodesets\n&quot;);
      return(0);
      }
      hashs1 = (unsigned int *) xmlMalloc(ns1-&gt;nodeNr * sizeof(unsigned int));
      if (hashs1 == NULL) {
<span class="line-added">+         /* TODO: Propagate memory error. */</span>
          xmlXPathErrMemory(NULL, &quot;comparing nodesets\n&quot;);
      xmlFree(values1);
      return(0);
      }
      memset(values1, 0, ns1-&gt;nodeNr * sizeof(xmlChar *));
      values2 = (xmlChar **) xmlMalloc(ns2-&gt;nodeNr * sizeof(xmlChar *));
      if (values2 == NULL) {
<span class="line-added">+         /* TODO: Propagate memory error. */</span>
          xmlXPathErrMemory(NULL, &quot;comparing nodesets\n&quot;);
      xmlFree(hashs1);
      xmlFree(values1);
      return(0);
      }
      hashs2 = (unsigned int *) xmlMalloc(ns2-&gt;nodeNr * sizeof(unsigned int));
      if (hashs2 == NULL) {
<span class="line-added">+         /* TODO: Propagate memory error. */</span>
          xmlXPathErrMemory(NULL, &quot;comparing nodesets\n&quot;);
      xmlFree(hashs1);
      xmlFree(values1);
      xmlFree(values2);
      return(0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7549,10 ***</span>
<span class="line-new-header">--- 7524,11 ---</span>
   *
   * Implement the div operation on XPath objects @arg1 / @arg2:
   * The numeric operators convert their operands to numbers as if
   * by calling the number function.
   */
<span class="line-added">+ ATTRIBUTE_NO_SANITIZE(&quot;float-divide-by-zero&quot;)</span>
  void
  xmlXPathDivValues(xmlXPathParserContextPtr ctxt) {
      xmlXPathObjectPtr arg;
      double val;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7621,11 ***</span>
  /*
   * xmlXPathNodeSetMergeFunction:
   * Used for merging node sets in xmlXPathCollectAndTest().
   */
  typedef xmlNodeSetPtr (*xmlXPathNodeSetMergeFunction)
<span class="line-modified">!             (xmlNodeSetPtr, xmlNodeSetPtr, int);</span>
  
  
  /**
   * xmlXPathNextSelf:
   * @ctxt:  the XPath Parser context
<span class="line-new-header">--- 7597,11 ---</span>
  /*
   * xmlXPathNodeSetMergeFunction:
   * Used for merging node sets in xmlXPathCollectAndTest().
   */
  typedef xmlNodeSetPtr (*xmlXPathNodeSetMergeFunction)
<span class="line-modified">!             (xmlNodeSetPtr, xmlNodeSetPtr);</span>
  
  
  /**
   * xmlXPathNextSelf:
   * @ctxt:  the XPath Parser context
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8560,32 ***</span>
      XP_ERROR(XPATH_INVALID_TYPE);
      cur = valuePop(ctxt);
  
      if ((cur == NULL) || (cur-&gt;nodesetval == NULL))
      valuePush(ctxt, xmlXPathCacheNewFloat(ctxt-&gt;context, (double) 0));
<span class="line-modified">!     else if ((cur-&gt;type == XPATH_NODESET) || (cur-&gt;type == XPATH_XSLT_TREE)) {</span>
      valuePush(ctxt, xmlXPathCacheNewFloat(ctxt-&gt;context,
          (double) cur-&gt;nodesetval-&gt;nodeNr));
<span class="line-removed">-     } else {</span>
<span class="line-removed">-     if ((cur-&gt;nodesetval-&gt;nodeNr != 1) ||</span>
<span class="line-removed">-         (cur-&gt;nodesetval-&gt;nodeTab == NULL)) {</span>
<span class="line-removed">-         valuePush(ctxt, xmlXPathCacheNewFloat(ctxt-&gt;context, (double) 0));</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-         xmlNodePtr tmp;</span>
<span class="line-removed">-         int i = 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         tmp = cur-&gt;nodesetval-&gt;nodeTab[0];</span>
<span class="line-removed">-         if ((tmp != NULL) &amp;&amp; (tmp-&gt;type != XML_NAMESPACE_DECL)) {</span>
<span class="line-removed">-         tmp = tmp-&gt;children;</span>
<span class="line-removed">-         while (tmp != NULL) {</span>
<span class="line-removed">-             tmp = tmp-&gt;next;</span>
<span class="line-removed">-             i++;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         valuePush(ctxt, xmlXPathCacheNewFloat(ctxt-&gt;context, (double) i));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     }</span>
      xmlXPathReleaseObject(ctxt-&gt;context, cur);
  }
  
  /**
   * xmlXPathGetElementsByIds:
<span class="line-new-header">--- 8536,13 ---</span>
      XP_ERROR(XPATH_INVALID_TYPE);
      cur = valuePop(ctxt);
  
      if ((cur == NULL) || (cur-&gt;nodesetval == NULL))
      valuePush(ctxt, xmlXPathCacheNewFloat(ctxt-&gt;context, (double) 0));
<span class="line-modified">!     else</span>
      valuePush(ctxt, xmlXPathCacheNewFloat(ctxt-&gt;context,
          (double) cur-&gt;nodesetval-&gt;nodeNr));
      xmlXPathReleaseObject(ctxt-&gt;context, cur);
  }
  
  /**
   * xmlXPathGetElementsByIds:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8619,21 ***</span>
      if (ID != NULL) {
          /*
           * We used to check the fact that the value passed
           * was an NCName, but this generated much troubles for
           * me and Aleksey Sanin, people blatantly violated that
<span class="line-modified">!          * constaint, like Visa3D spec.</span>
           * if (xmlValidateNCName(ID, 1) == 0)
           */
          attr = xmlGetID(doc, ID);
          if (attr != NULL) {
          if (attr-&gt;type == XML_ATTRIBUTE_NODE)
              elem = attr-&gt;parent;
          else if (attr-&gt;type == XML_ELEMENT_NODE)
              elem = (xmlNodePtr) attr;
          else
              elem = NULL;
          if (elem != NULL)
              xmlXPathNodeSetAdd(ret, elem);
          }
          xmlFree(ID);
      }
<span class="line-new-header">--- 8576,22 ---</span>
      if (ID != NULL) {
          /*
           * We used to check the fact that the value passed
           * was an NCName, but this generated much troubles for
           * me and Aleksey Sanin, people blatantly violated that
<span class="line-modified">!          * constraint, like Visa3D spec.</span>
           * if (xmlValidateNCName(ID, 1) == 0)
           */
          attr = xmlGetID(doc, ID);
          if (attr != NULL) {
          if (attr-&gt;type == XML_ATTRIBUTE_NODE)
              elem = attr-&gt;parent;
          else if (attr-&gt;type == XML_ELEMENT_NODE)
              elem = (xmlNodePtr) attr;
          else
              elem = NULL;
<span class="line-added">+                 /* TODO: Check memory error. */</span>
          if (elem != NULL)
              xmlXPathNodeSetAdd(ret, elem);
          }
          xmlFree(ID);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8673,22 ***</span>
      if (obj == NULL) XP_ERROR(XPATH_INVALID_OPERAND);
      if ((obj-&gt;type == XPATH_NODESET) || (obj-&gt;type == XPATH_XSLT_TREE)) {
      xmlNodeSetPtr ns;
      int i;
  
      ret = xmlXPathNodeSetCreate(NULL);
<span class="line-removed">-         /*</span>
<span class="line-removed">-          * FIXME -- in an out-of-memory condition this will behave badly.</span>
<span class="line-removed">-          * The solution is not clear -- we already popped an item from</span>
<span class="line-removed">-          * ctxt, so the object is in a corrupt state.</span>
<span class="line-removed">-          */</span>
  
      if (obj-&gt;nodesetval != NULL) {
          for (i = 0; i &lt; obj-&gt;nodesetval-&gt;nodeNr; i++) {
          tokens =
              xmlXPathCastNodeToString(obj-&gt;nodesetval-&gt;nodeTab[i]);
          ns = xmlXPathGetElementsByIds(ctxt-&gt;context-&gt;doc, tokens);
          ret = xmlXPathNodeSetMerge(ret, ns);
          xmlXPathFreeNodeSet(ns);
          if (tokens != NULL)
              xmlFree(tokens);
          }
<span class="line-new-header">--- 8631,19 ---</span>
      if (obj == NULL) XP_ERROR(XPATH_INVALID_OPERAND);
      if ((obj-&gt;type == XPATH_NODESET) || (obj-&gt;type == XPATH_XSLT_TREE)) {
      xmlNodeSetPtr ns;
      int i;
  
<span class="line-added">+         /* TODO: Check memory error. */</span>
      ret = xmlXPathNodeSetCreate(NULL);
  
      if (obj-&gt;nodesetval != NULL) {
          for (i = 0; i &lt; obj-&gt;nodesetval-&gt;nodeNr; i++) {
          tokens =
              xmlXPathCastNodeToString(obj-&gt;nodesetval-&gt;nodeTab[i]);
          ns = xmlXPathGetElementsByIds(ctxt-&gt;context-&gt;doc, tokens);
<span class="line-added">+                 /* TODO: Check memory error. */</span>
          ret = xmlXPathNodeSetMerge(ret, ns);
          xmlXPathFreeNodeSet(ns);
          if (tokens != NULL)
              xmlFree(tokens);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8696,10 ***</span>
<span class="line-new-header">--- 8651,11 ---</span>
      xmlXPathReleaseObject(ctxt-&gt;context, obj);
      valuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt-&gt;context, ret));
      return;
      }
      obj = xmlXPathCacheConvertString(ctxt-&gt;context, obj);
<span class="line-added">+     if (obj == NULL) return;</span>
      ret = xmlXPathGetElementsByIds(ctxt-&gt;context-&gt;doc, obj-&gt;stringval);
      valuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt-&gt;context, ret));
      xmlXPathReleaseObject(ctxt-&gt;context, obj);
      return;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9133,12 ***</span>
   */
  void
  xmlXPathSubstringFunction(xmlXPathParserContextPtr ctxt, int nargs) {
      xmlXPathObjectPtr str, start, len;
      double le=0, in;
<span class="line-modified">!     int i, l, m;</span>
<span class="line-removed">-     xmlChar *ret;</span>
  
      if (nargs &lt; 2) {
      CHECK_ARITY(2);
      }
      if (nargs &gt; 3) {
<span class="line-new-header">--- 9089,11 ---</span>
   */
  void
  xmlXPathSubstringFunction(xmlXPathParserContextPtr ctxt, int nargs) {
      xmlXPathObjectPtr str, start, len;
      double le=0, in;
<span class="line-modified">!     int i = 1, j = INT_MAX;</span>
  
      if (nargs &lt; 2) {
      CHECK_ARITY(2);
      }
      if (nargs &gt; 3) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9161,71 ***</span>
      in = start-&gt;floatval;
      xmlXPathReleaseObject(ctxt-&gt;context, start);
      CAST_TO_STRING;
      CHECK_TYPE(XPATH_STRING);
      str = valuePop(ctxt);
<span class="line-removed">-     m = xmlUTF8Strlen((const unsigned char *)str-&gt;stringval);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-      * If last pos not present, calculate last position</span>
<span class="line-removed">-     */</span>
<span class="line-removed">-     if (nargs != 3) {</span>
<span class="line-removed">-     le = (double)m;</span>
<span class="line-removed">-     if (in &lt; 1.0)</span>
<span class="line-removed">-         in = 1.0;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     /* Need to check for the special cases where either</span>
<span class="line-modified">!      * the index is NaN, the length is NaN, or both</span>
<span class="line-modified">!      * arguments are infinity (relying on Inf + -Inf = NaN)</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     if (!xmlXPathIsInf(in) &amp;&amp; !xmlXPathIsNaN(in + le)) {</span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-          * To meet the requirements of the spec, the arguments</span>
<span class="line-removed">-      * must be converted to integer format before</span>
<span class="line-removed">-      * initial index calculations are done</span>
<span class="line-removed">-          *</span>
<span class="line-removed">-          * First we go to integer form, rounding up</span>
<span class="line-removed">-      * and checking for special cases</span>
<span class="line-removed">-          */</span>
          i = (int) in;
<span class="line-modified">!         if (((double)i)+0.5 &lt;= in) i++;</span>
<span class="line-modified">! </span>
<span class="line-removed">-     if (xmlXPathIsInf(le) == 1) {</span>
<span class="line-removed">-         l = m;</span>
<span class="line-removed">-         if (i &lt; 1)</span>
<span class="line-removed">-         i = 1;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     else if (xmlXPathIsInf(le) == -1 || le &lt; 0.0)</span>
<span class="line-removed">-         l = 0;</span>
<span class="line-removed">-     else {</span>
<span class="line-removed">-         l = (int) le;</span>
<span class="line-removed">-         if (((double)l)+0.5 &lt;= le) l++;</span>
      }
  
<span class="line-modified">!     /* Now we normalize inidices */</span>
<span class="line-modified">!         i -= 1;</span>
<span class="line-modified">!         l += i;</span>
<span class="line-modified">!         if (i &lt; 0)</span>
<span class="line-modified">!             i = 0;</span>
<span class="line-modified">!         if (l &gt; m)</span>
<span class="line-removed">-             l = m;</span>
  
<span class="line-modified">!         /* number of chars to copy */</span>
<span class="line-modified">!         l -= i;</span>
  
<span class="line-modified">!         ret = xmlUTF8Strsub(str-&gt;stringval, i, l);</span>
      }
<span class="line-removed">-     else {</span>
<span class="line-removed">-         ret = NULL;</span>
      }
<span class="line-modified">!     if (ret == NULL)</span>
<span class="line-modified">!     valuePush(ctxt, xmlXPathCacheNewCString(ctxt-&gt;context, &quot;&quot;));</span>
<span class="line-modified">!     else {</span>
      valuePush(ctxt, xmlXPathCacheNewString(ctxt-&gt;context, ret));
      xmlFree(ret);
      }
      xmlXPathReleaseObject(ctxt-&gt;context, str);
  }
  
  /**
   * xmlXPathSubstringBeforeFunction:
<span class="line-new-header">--- 9116,46 ---</span>
      in = start-&gt;floatval;
      xmlXPathReleaseObject(ctxt-&gt;context, start);
      CAST_TO_STRING;
      CHECK_TYPE(XPATH_STRING);
      str = valuePop(ctxt);
  
<span class="line-modified">!     if (!(in &lt; INT_MAX)) { /* Logical NOT to handle NaNs */</span>
<span class="line-modified">!         i = INT_MAX;</span>
<span class="line-modified">!     } else if (in &gt;= 1.0) {</span>
          i = (int) in;
<span class="line-modified">!         if (in - floor(in) &gt;= 0.5)</span>
<span class="line-modified">!             i += 1;</span>
      }
  
<span class="line-modified">!     if (nargs == 3) {</span>
<span class="line-modified">!         double rin, rle, end;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         rin = floor(in);</span>
<span class="line-modified">!         if (in - rin &gt;= 0.5)</span>
<span class="line-modified">!             rin += 1.0;</span>
  
<span class="line-modified">!         rle = floor(le);</span>
<span class="line-modified">!         if (le - rle &gt;= 0.5)</span>
<span class="line-added">+             rle += 1.0;</span>
  
<span class="line-modified">!         end = rin + rle;</span>
<span class="line-added">+         if (!(end &gt;= 1.0)) { /* Logical NOT to handle NaNs */</span>
<span class="line-added">+             j = 1;</span>
<span class="line-added">+         } else if (end &lt; INT_MAX) {</span>
<span class="line-added">+             j = (int)end;</span>
      }
      }
<span class="line-modified">! </span>
<span class="line-modified">!     if (i &lt; j) {</span>
<span class="line-modified">!         xmlChar *ret = xmlUTF8Strsub(str-&gt;stringval, i - 1, j - i);</span>
      valuePush(ctxt, xmlXPathCacheNewString(ctxt-&gt;context, ret));
      xmlFree(ret);
<span class="line-added">+     } else {</span>
<span class="line-added">+     valuePush(ctxt, xmlXPathCacheNewCString(ctxt-&gt;context, &quot;&quot;));</span>
      }
<span class="line-added">+ </span>
      xmlXPathReleaseObject(ctxt-&gt;context, str);
  }
  
  /**
   * xmlXPathSubstringBeforeFunction:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9680,11 ***</span>
<span class="line-new-header">--- 9610,16 ---</span>
  xmlXPathCeilingFunction(xmlXPathParserContextPtr ctxt, int nargs) {
      CHECK_ARITY(1);
      CAST_TO_NUMBER;
      CHECK_TYPE(XPATH_NUMBER);
  
<span class="line-added">+ #ifdef _AIX</span>
<span class="line-added">+     /* Work around buggy ceil() function on AIX */</span>
<span class="line-added">+     ctxt-&gt;value-&gt;floatval = copysign(ceil(ctxt-&gt;value-&gt;floatval), ctxt-&gt;value-&gt;floatval);</span>
<span class="line-added">+ #else</span>
      ctxt-&gt;value-&gt;floatval = ceil(ctxt-&gt;value-&gt;floatval);
<span class="line-added">+ #endif</span>
  }
  
  /**
   * xmlXPathRoundFunction:
   * @ctxt:  the XPath Parser context
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9997,19 ***</span>
             (c == &#39;.&#39;) || (c == &#39;-&#39;) ||
             (c == &#39;_&#39;) || ((qualified) &amp;&amp; (c == &#39;:&#39;)) ||
             (IS_COMBINING(c)) ||
             (IS_EXTENDER(c))) {
          if (len + 10 &gt; max) {
                      if (max &gt; XML_MAX_NAME_LENGTH) {
                          XP_ERRORNULL(XPATH_EXPR_ERROR);
                      }
              max *= 2;
<span class="line-modified">!             buffer = (xmlChar *) xmlRealloc(buffer,</span>
                                          max * sizeof(xmlChar));
<span class="line-modified">!             if (buffer == NULL) {</span>
              XP_ERRORNULL(XPATH_MEMORY_ERROR);
              }
          }
          COPY_BUF(l,buffer,len,c);
          NEXTL(l);
          c = CUR_CHAR(l);
          }
<span class="line-new-header">--- 9932,23 ---</span>
             (c == &#39;.&#39;) || (c == &#39;-&#39;) ||
             (c == &#39;_&#39;) || ((qualified) &amp;&amp; (c == &#39;:&#39;)) ||
             (IS_COMBINING(c)) ||
             (IS_EXTENDER(c))) {
          if (len + 10 &gt; max) {
<span class="line-added">+                     xmlChar *tmp;</span>
                      if (max &gt; XML_MAX_NAME_LENGTH) {
<span class="line-added">+                         xmlFree(buffer);</span>
                          XP_ERRORNULL(XPATH_EXPR_ERROR);
                      }
              max *= 2;
<span class="line-modified">!             tmp = (xmlChar *) xmlRealloc(buffer,</span>
                                          max * sizeof(xmlChar));
<span class="line-modified">!             if (tmp == NULL) {</span>
<span class="line-added">+                         xmlFree(buffer);</span>
              XP_ERRORNULL(XPATH_MEMORY_ERROR);
              }
<span class="line-added">+                     buffer = tmp;</span>
          }
          COPY_BUF(l,buffer,len,c);
          NEXTL(l);
          c = CUR_CHAR(l);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10897,14 ***</span>
  static void
  xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {
      xmlXPathCompAdditiveExpr(ctxt);
      CHECK_ERROR;
      SKIP_BLANKS;
<span class="line-modified">!     while ((CUR == &#39;&lt;&#39;) ||</span>
<span class="line-removed">-            (CUR == &#39;&gt;&#39;) ||</span>
<span class="line-removed">-            ((CUR == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;=&#39;)) ||</span>
<span class="line-removed">-            ((CUR == &#39;&gt;&#39;) &amp;&amp; (NXT(1) == &#39;=&#39;))) {</span>
      int inf, strict;
      int op1 = ctxt-&gt;comp-&gt;last;
  
          if (CUR == &#39;&lt;&#39;) inf = 1;
      else inf = 0;
<span class="line-new-header">--- 10836,11 ---</span>
  static void
  xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {
      xmlXPathCompAdditiveExpr(ctxt);
      CHECK_ERROR;
      SKIP_BLANKS;
<span class="line-modified">!     while ((CUR == &#39;&lt;&#39;) || (CUR == &#39;&gt;&#39;)) {</span>
      int inf, strict;
      int op1 = ctxt-&gt;comp-&gt;last;
  
          if (CUR == &#39;&lt;&#39;) inf = 1;
      else inf = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10993,10 ***</span>
<span class="line-new-header">--- 10929,18 ---</span>
   *
   * Parse and compile an expression
   */
  static void
  xmlXPathCompileExpr(xmlXPathParserContextPtr ctxt, int sort) {
<span class="line-added">+     xmlXPathContextPtr xpctxt = ctxt-&gt;context;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (xpctxt != NULL) {</span>
<span class="line-added">+         if (xpctxt-&gt;depth &gt;= xpctxt-&gt;maxParserDepth)</span>
<span class="line-added">+             XP_ERROR(XPATH_RECURSION_LIMIT_EXCEEDED);</span>
<span class="line-added">+         xpctxt-&gt;depth += 1;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      xmlXPathCompAndExpr(ctxt);
      CHECK_ERROR;
      SKIP_BLANKS;
      while ((CUR == &#39;o&#39;) &amp;&amp; (NXT(1) == &#39;r&#39;)) {
      int op1 = ctxt-&gt;comp-&gt;last;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11014,10 ***</span>
<span class="line-new-header">--- 10958,13 ---</span>
      * operations which don&#39;t require a sorted node-set.
      * E.g. count().
      */
      PUSH_UNARY_EXPR(XPATH_OP_SORT, ctxt-&gt;comp-&gt;last , 0, 0);
      }
<span class="line-added">+ </span>
<span class="line-added">+     if (xpctxt != NULL)</span>
<span class="line-added">+         xpctxt-&gt;depth -= 1;</span>
  }
  
  /**
   * xmlXPathCompPredicate:
   * @ctxt:  the XPath Parser context
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11632,370 ***</span>
      }
      xmlGenericError(xmlGenericErrorContext, &quot;Testing : &quot;);
  }
  #endif /* DEBUG_STEP */
  
<span class="line-modified">! static int</span>
<span class="line-modified">! xmlXPathCompOpEvalPredicate(xmlXPathParserContextPtr ctxt,</span>
<span class="line-modified">!                 xmlXPathStepOpPtr op,</span>
                  xmlNodeSetPtr set,
<span class="line-modified">!                 int contextSize,</span>
                  int hasNsNodes)
  {
<span class="line-modified">!     if (op-&gt;ch1 != -1) {</span>
<span class="line-modified">!     xmlXPathCompExprPtr comp = ctxt-&gt;comp;</span>
      /*
<span class="line-modified">!     * Process inner predicates first.</span>
      */
<span class="line-modified">!     if (comp-&gt;steps[op-&gt;ch1].op != XPATH_OP_PREDICATE) {</span>
<span class="line-modified">!         /*</span>
<span class="line-modified">!         * TODO: raise an internal error.</span>
<span class="line-removed">-         */</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     contextSize = xmlXPathCompOpEvalPredicate(ctxt,</span>
<span class="line-removed">-         &amp;comp-&gt;steps[op-&gt;ch1], set, contextSize, hasNsNodes);</span>
<span class="line-removed">-     CHECK_ERROR0;</span>
<span class="line-removed">-     if (contextSize &lt;= 0)</span>
<span class="line-removed">-         return(0);</span>
      }
<span class="line-removed">-     if (op-&gt;ch2 != -1) {</span>
<span class="line-removed">-     xmlXPathContextPtr xpctxt = ctxt-&gt;context;</span>
<span class="line-removed">-     xmlNodePtr contextNode, oldContextNode;</span>
<span class="line-removed">-     xmlDocPtr oldContextDoc;</span>
<span class="line-removed">-         int oldcs, oldpp;</span>
<span class="line-removed">-     int i, res, contextPos = 0, newContextSize;</span>
<span class="line-removed">-     xmlXPathStepOpPtr exprOp;</span>
<span class="line-removed">-     xmlXPathObjectPtr contextObj = NULL, exprRes = NULL;</span>
  
<span class="line-modified">! #ifdef LIBXML_XPTR_ENABLED</span>
<span class="line-modified">!     /*</span>
<span class="line-modified">!     * URGENT TODO: Check the following:</span>
<span class="line-modified">!     *  We don&#39;t expect location sets if evaluating prediates, right?</span>
<span class="line-modified">!     *  Only filters should expect location sets, right?</span>
<span class="line-modified">!     */</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-     * SPEC XPath 1.0:</span>
<span class="line-removed">-     *  &quot;For each node in the node-set to be filtered, the</span>
<span class="line-removed">-     *  PredicateExpr is evaluated with that node as the</span>
<span class="line-removed">-     *  context node, with the number of nodes in the</span>
<span class="line-removed">-     *  node-set as the context size, and with the proximity</span>
<span class="line-removed">-     *  position of the node in the node-set with respect to</span>
<span class="line-removed">-     *  the axis as the context position;&quot;</span>
<span class="line-removed">-     * @oldset is the node-set&quot; to be filtered.</span>
<span class="line-removed">-     *</span>
<span class="line-removed">-     * SPEC XPath 1.0:</span>
<span class="line-removed">-     *  &quot;only predicates change the context position and</span>
<span class="line-removed">-     *  context size (see [2.4 Predicates]).&quot;</span>
<span class="line-removed">-     * Example:</span>
<span class="line-removed">-     *   node-set  context pos</span>
<span class="line-removed">-     *    nA         1</span>
<span class="line-removed">-     *    nB         2</span>
<span class="line-removed">-     *    nC         3</span>
<span class="line-removed">-     *   After applying predicate [position() &gt; 1] :</span>
<span class="line-removed">-     *   node-set  context pos</span>
<span class="line-removed">-     *    nB         1</span>
<span class="line-removed">-     *    nC         2</span>
<span class="line-removed">-     */</span>
<span class="line-removed">-     oldContextNode = xpctxt-&gt;node;</span>
<span class="line-removed">-     oldContextDoc = xpctxt-&gt;doc;</span>
<span class="line-removed">-         oldcs = xpctxt-&gt;contextSize;</span>
<span class="line-removed">-         oldpp = xpctxt-&gt;proximityPosition;</span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-     * Get the expression of this predicate.</span>
<span class="line-removed">-     */</span>
<span class="line-removed">-     exprOp = &amp;ctxt-&gt;comp-&gt;steps[op-&gt;ch2];</span>
<span class="line-removed">-     newContextSize = 0;</span>
<span class="line-removed">-     for (i = 0; i &lt; set-&gt;nodeNr; i++) {</span>
<span class="line-removed">-         if (set-&gt;nodeTab[i] == NULL)</span>
<span class="line-removed">-         continue;</span>
  
<span class="line-modified">!         contextNode = set-&gt;nodeTab[i];</span>
<span class="line-modified">!         xpctxt-&gt;node = contextNode;</span>
<span class="line-modified">!         xpctxt-&gt;contextSize = contextSize;</span>
<span class="line-modified">!         xpctxt-&gt;proximityPosition = ++contextPos;</span>
  
          /*
          * Also set the xpath document in case things like
          * key() are evaluated in the predicate.
          */
<span class="line-modified">!         if ((contextNode-&gt;type != XML_NAMESPACE_DECL) &amp;&amp;</span>
<span class="line-modified">!         (contextNode-&gt;doc != NULL))</span>
<span class="line-modified">!         xpctxt-&gt;doc = contextNode-&gt;doc;</span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-         * Evaluate the predicate expression with 1 context node</span>
<span class="line-removed">-         * at a time; this node is packaged into a node set; this</span>
<span class="line-removed">-         * node set is handed over to the evaluation mechanism.</span>
<span class="line-removed">-         */</span>
<span class="line-removed">-         if (contextObj == NULL)</span>
<span class="line-removed">-         contextObj = xmlXPathCacheNewNodeSet(xpctxt, contextNode);</span>
<span class="line-removed">-         else {</span>
<span class="line-removed">-         if (xmlXPathNodeSetAddUnique(contextObj-&gt;nodesetval,</span>
<span class="line-removed">-             contextNode) &lt; 0) {</span>
<span class="line-removed">-             ctxt-&gt;error = XPATH_MEMORY_ERROR;</span>
<span class="line-removed">-             goto evaluation_exit;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         valuePush(ctxt, contextObj);</span>
  
<span class="line-modified">!         res = xmlXPathCompOpEvalToBoolean(ctxt, exprOp, 1);</span>
  
<span class="line-modified">!         if ((ctxt-&gt;error != XPATH_EXPRESSION_OK) || (res == -1)) {</span>
<span class="line-modified">!         xmlXPathNodeSetClear(set, hasNsNodes);</span>
<span class="line-modified">!         newContextSize = 0;</span>
<span class="line-modified">!         goto evaluation_exit;</span>
          }
  
          if (res != 0) {
<span class="line-modified">!         newContextSize++;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!         /*</span>
<span class="line-modified">!         * Remove the entry from the initial node set.</span>
<span class="line-modified">!         */</span>
<span class="line-modified">!         set-&gt;nodeTab[i] = NULL;</span>
<span class="line-modified">!         if (contextNode-&gt;type == XML_NAMESPACE_DECL)</span>
<span class="line-modified">!             xmlXPathNodeSetFreeNs((xmlNsPtr) contextNode);</span>
          }
<span class="line-modified">!         if (ctxt-&gt;value == contextObj) {</span>
<span class="line-modified">!         /*</span>
<span class="line-modified">!         * Don&#39;t free the temporary XPath object holding the</span>
<span class="line-modified">!         * context node, in order to avoid massive recreation</span>
<span class="line-modified">!         * inside this loop.</span>
<span class="line-modified">!         */</span>
<span class="line-modified">!         valuePop(ctxt);</span>
<span class="line-modified">!         xmlXPathNodeSetClear(contextObj-&gt;nodesetval, hasNsNodes);</span>
          } else {
<span class="line-modified">!         /*</span>
<span class="line-modified">!         * TODO: The object was lost in the evaluation machinery.</span>
<span class="line-removed">-         *  Can this happen? Maybe in internal-error cases.</span>
<span class="line-removed">-         */</span>
<span class="line-removed">-         contextObj = NULL;</span>
          }
      }
  
<span class="line-modified">!     if (contextObj != NULL) {</span>
<span class="line-modified">!         if (ctxt-&gt;value == contextObj)</span>
<span class="line-modified">!         valuePop(ctxt);</span>
<span class="line-removed">-         xmlXPathReleaseObject(xpctxt, contextObj);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- evaluation_exit:</span>
<span class="line-removed">-     if (exprRes != NULL)</span>
<span class="line-removed">-         xmlXPathReleaseObject(ctxt-&gt;context, exprRes);</span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-     * Reset/invalidate the context.</span>
<span class="line-removed">-     */</span>
<span class="line-removed">-     xpctxt-&gt;node = oldContextNode;</span>
<span class="line-removed">-     xpctxt-&gt;doc = oldContextDoc;</span>
      xpctxt-&gt;contextSize = oldcs;
      xpctxt-&gt;proximityPosition = oldpp;
<span class="line-removed">-     return(newContextSize);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return(contextSize);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static int</span>
<span class="line-removed">- xmlXPathCompOpEvalPositionalPredicate(xmlXPathParserContextPtr ctxt,</span>
<span class="line-removed">-                       xmlXPathStepOpPtr op,</span>
<span class="line-removed">-                       xmlNodeSetPtr set,</span>
<span class="line-removed">-                       int contextSize,</span>
<span class="line-removed">-                       int minPos,</span>
<span class="line-removed">-                       int maxPos,</span>
<span class="line-removed">-                       int hasNsNodes)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (op-&gt;ch1 != -1) {</span>
<span class="line-removed">-     xmlXPathCompExprPtr comp = ctxt-&gt;comp;</span>
<span class="line-removed">-     if (comp-&gt;steps[op-&gt;ch1].op != XPATH_OP_PREDICATE) {</span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-         * TODO: raise an internal error.</span>
<span class="line-removed">-         */</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     contextSize = xmlXPathCompOpEvalPredicate(ctxt,</span>
<span class="line-removed">-         &amp;comp-&gt;steps[op-&gt;ch1], set, contextSize, hasNsNodes);</span>
<span class="line-removed">-     CHECK_ERROR0;</span>
<span class="line-removed">-     if (contextSize &lt;= 0)</span>
<span class="line-removed">-         return(0);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-     * Check if the node set contains a sufficient number of nodes for</span>
<span class="line-removed">-     * the requested range.</span>
<span class="line-removed">-     */</span>
<span class="line-removed">-     if (contextSize &lt; minPos) {</span>
<span class="line-removed">-     xmlXPathNodeSetClear(set, hasNsNodes);</span>
<span class="line-removed">-     return(0);</span>
      }
<span class="line-removed">-     if (op-&gt;ch2 == -1) {</span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-     * TODO: Can this ever happen?</span>
<span class="line-removed">-     */</span>
<span class="line-removed">-     return (contextSize);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-     xmlDocPtr oldContextDoc;</span>
<span class="line-removed">-         int oldcs, oldpp;</span>
<span class="line-removed">-     int i, pos = 0, newContextSize = 0, contextPos = 0, res;</span>
<span class="line-removed">-     xmlXPathStepOpPtr exprOp;</span>
<span class="line-removed">-     xmlXPathObjectPtr contextObj = NULL, exprRes = NULL;</span>
<span class="line-removed">-     xmlNodePtr oldContextNode, contextNode = NULL;</span>
<span class="line-removed">-     xmlXPathContextPtr xpctxt = ctxt-&gt;context;</span>
<span class="line-removed">-         int frame;</span>
  
  #ifdef LIBXML_XPTR_ENABLED
<span class="line-modified">!         /*</span>
<span class="line-modified">!         * URGENT TODO: Check the following:</span>
<span class="line-modified">!         *  We don&#39;t expect location sets if evaluating prediates, right?</span>
<span class="line-modified">!         *  Only filters should expect location sets, right?</span>
      */
<span class="line-modified">! #endif /* LIBXML_XPTR_ENABLED */</span>
  
<span class="line-modified">!     /*</span>
<span class="line-modified">!     * Save old context.</span>
<span class="line-modified">!     */</span>
<span class="line-modified">!     oldContextNode = xpctxt-&gt;node;</span>
<span class="line-modified">!     oldContextDoc = xpctxt-&gt;doc;</span>
          oldcs = xpctxt-&gt;contextSize;
          oldpp = xpctxt-&gt;proximityPosition;
<span class="line-modified">!     /*</span>
<span class="line-removed">-     * Get the expression of this predicate.</span>
<span class="line-removed">-     */</span>
<span class="line-removed">-     exprOp = &amp;ctxt-&gt;comp-&gt;steps[op-&gt;ch2];</span>
<span class="line-removed">-     for (i = 0; i &lt; set-&gt;nodeNr; i++) {</span>
<span class="line-removed">-             xmlXPathObjectPtr tmp;</span>
  
<span class="line-modified">!         if (set-&gt;nodeTab[i] == NULL)</span>
<span class="line-modified">!         continue;</span>
  
<span class="line-removed">-         contextNode = set-&gt;nodeTab[i];</span>
          xpctxt-&gt;node = contextNode;
<span class="line-modified">!         xpctxt-&gt;contextSize = contextSize;</span>
<span class="line-removed">-         xpctxt-&gt;proximityPosition = ++contextPos;</span>
  
          /*
<span class="line-removed">-         * Initialize the new set.</span>
          * Also set the xpath document in case things like
<span class="line-modified">!         * key() evaluation are attempted on the predicate</span>
          */
          if ((contextNode-&gt;type != XML_NAMESPACE_DECL) &amp;&amp;
          (contextNode-&gt;doc != NULL))
          xpctxt-&gt;doc = contextNode-&gt;doc;
<span class="line-modified">!         /*</span>
<span class="line-modified">!         * Evaluate the predicate expression with 1 context node</span>
<span class="line-modified">!         * at a time; this node is packaged into a node set; this</span>
<span class="line-modified">!         * node set is handed over to the evaluation mechanism.</span>
<span class="line-modified">!         */</span>
<span class="line-modified">!         if (contextObj == NULL)</span>
<span class="line-modified">!         contextObj = xmlXPathCacheNewNodeSet(xpctxt, contextNode);</span>
<span class="line-modified">!         else {</span>
<span class="line-modified">!         if (xmlXPathNodeSetAddUnique(contextObj-&gt;nodesetval,</span>
<span class="line-removed">-             contextNode) &lt; 0) {</span>
<span class="line-removed">-             ctxt-&gt;error = XPATH_MEMORY_ERROR;</span>
<span class="line-removed">-             goto evaluation_exit;</span>
          }
          }
  
<span class="line-modified">!         valuePush(ctxt, contextObj);</span>
<span class="line-modified">!             frame = xmlXPathSetFrame(ctxt);</span>
<span class="line-modified">!         res = xmlXPathCompOpEvalToBoolean(ctxt, exprOp, 1);</span>
<span class="line-modified">!             xmlXPathPopFrame(ctxt, frame);</span>
<span class="line-modified">!             tmp = valuePop(ctxt);</span>
  
<span class="line-modified">!         if ((ctxt-&gt;error != XPATH_EXPRESSION_OK) || (res == -1)) {</span>
<span class="line-modified">!                 while (tmp != contextObj) {</span>
<span class="line-modified">!                     /*</span>
<span class="line-modified">!                      * Free up the result</span>
<span class="line-modified">!                      * then pop off contextObj, which will be freed later</span>
<span class="line-removed">-                      */</span>
<span class="line-removed">-                     xmlXPathReleaseObject(xpctxt, tmp);</span>
<span class="line-removed">-                     tmp = valuePop(ctxt);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-         goto evaluation_error;</span>
          }
<span class="line-modified">!             /* push the result back onto the stack */</span>
<span class="line-modified">!             valuePush(ctxt, tmp);</span>
  
<span class="line-modified">!         if (res)</span>
<span class="line-modified">!         pos++;</span>
  
<span class="line-modified">!         if (res &amp;&amp; (pos &gt;= minPos) &amp;&amp; (pos &lt;= maxPos)) {</span>
<span class="line-modified">!         /*</span>
<span class="line-modified">!         * Fits in the requested range.</span>
<span class="line-modified">!         */</span>
<span class="line-modified">!         newContextSize++;</span>
<span class="line-modified">!         if (minPos == maxPos) {</span>
<span class="line-modified">!             /*</span>
<span class="line-modified">!             * Only 1 node was requested.</span>
<span class="line-modified">!             */</span>
<span class="line-modified">!             if (contextNode-&gt;type == XML_NAMESPACE_DECL) {</span>
<span class="line-modified">!             /*</span>
<span class="line-modified">!             * As always: take care of those nasty</span>
<span class="line-modified">!             * namespace nodes.</span>
<span class="line-modified">!             */</span>
<span class="line-removed">-             set-&gt;nodeTab[i] = NULL;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             xmlXPathNodeSetClear(set, hasNsNodes);</span>
<span class="line-removed">-             set-&gt;nodeNr = 1;</span>
<span class="line-removed">-             set-&gt;nodeTab[0] = contextNode;</span>
<span class="line-removed">-             goto evaluation_exit;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (pos == maxPos) {</span>
<span class="line-removed">-             /*</span>
<span class="line-removed">-             * We are done.</span>
<span class="line-removed">-             */</span>
<span class="line-removed">-             xmlXPathNodeSetClearFromPos(set, i +1, hasNsNodes);</span>
<span class="line-removed">-             goto evaluation_exit;</span>
<span class="line-removed">-         }</span>
          } else {
<span class="line-modified">!         /*</span>
<span class="line-modified">!         * Remove the entry from the initial node set.</span>
<span class="line-removed">-         */</span>
<span class="line-removed">-         set-&gt;nodeTab[i] = NULL;</span>
<span class="line-removed">-         if (contextNode-&gt;type == XML_NAMESPACE_DECL)</span>
<span class="line-removed">-             xmlXPathNodeSetFreeNs((xmlNsPtr) contextNode);</span>
          }
<span class="line-removed">-         if (exprRes != NULL) {</span>
<span class="line-removed">-         xmlXPathReleaseObject(ctxt-&gt;context, exprRes);</span>
<span class="line-removed">-         exprRes = NULL;</span>
          }
<span class="line-modified">!         if (ctxt-&gt;value == contextObj) {</span>
<span class="line-modified">!         /*</span>
<span class="line-modified">!         * Don&#39;t free the temporary XPath object holding the</span>
<span class="line-modified">!         * context node, in order to avoid massive recreation</span>
<span class="line-modified">!         * inside this loop.</span>
          */
<span class="line-modified">!         valuePop(ctxt);</span>
<span class="line-modified">!         xmlXPathNodeSetClear(contextObj-&gt;nodesetval, hasNsNodes);</span>
<span class="line-modified">!         } else {</span>
          /*
<span class="line-modified">!         * The object was lost in the evaluation machinery.</span>
<span class="line-removed">-         * Can this happen? Maybe in case of internal-errors.</span>
          */
<span class="line-modified">!         contextObj = NULL;</span>
<span class="line-modified">!         }</span>
      }
<span class="line-removed">-     goto evaluation_exit;</span>
  
<span class="line-modified">! evaluation_error:</span>
<span class="line-modified">!     xmlXPathNodeSetClear(set, hasNsNodes);</span>
<span class="line-removed">-     newContextSize = 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">- evaluation_exit:</span>
<span class="line-removed">-     if (contextObj != NULL) {</span>
<span class="line-removed">-         if (ctxt-&gt;value == contextObj)</span>
<span class="line-removed">-         valuePop(ctxt);</span>
<span class="line-removed">-         xmlXPathReleaseObject(xpctxt, contextObj);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (exprRes != NULL)</span>
<span class="line-removed">-         xmlXPathReleaseObject(ctxt-&gt;context, exprRes);</span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-     * Reset/invalidate the context.</span>
<span class="line-removed">-     */</span>
<span class="line-removed">-     xpctxt-&gt;node = oldContextNode;</span>
<span class="line-removed">-     xpctxt-&gt;doc = oldContextDoc;</span>
<span class="line-removed">-     xpctxt-&gt;contextSize = oldcs;</span>
<span class="line-removed">-     xpctxt-&gt;proximityPosition = oldpp;</span>
<span class="line-removed">-     return(newContextSize);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return(contextSize);</span>
  }
  
  static int
  xmlXPathIsPositionalPredicate(xmlXPathParserContextPtr ctxt,
                  xmlXPathStepOpPtr op,
<span class="line-new-header">--- 11579,304 ---</span>
      }
      xmlGenericError(xmlGenericErrorContext, &quot;Testing : &quot;);
  }
  #endif /* DEBUG_STEP */
  
<span class="line-modified">! /**</span>
<span class="line-modified">!  * xmlXPathNodeSetFilter:</span>
<span class="line-modified">!  * @ctxt:  the XPath Parser context</span>
<span class="line-added">+  * @set: the node set to filter</span>
<span class="line-added">+  * @filterOpIndex: the index of the predicate/filter op</span>
<span class="line-added">+  * @minPos: minimum position in the filtered set (1-based)</span>
<span class="line-added">+  * @maxPos: maximum position in the filtered set (1-based)</span>
<span class="line-added">+  * @hasNsNodes: true if the node set may contain namespace nodes</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Filter a node set, keeping only nodes for which the predicate expression</span>
<span class="line-added">+  * matches. Afterwards, keep only nodes between minPos and maxPos in the</span>
<span class="line-added">+  * filtered result.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ static void</span>
<span class="line-added">+ xmlXPathNodeSetFilter(xmlXPathParserContextPtr ctxt,</span>
                  xmlNodeSetPtr set,
<span class="line-modified">!               int filterOpIndex,</span>
<span class="line-added">+                       int minPos, int maxPos,</span>
                  int hasNsNodes)
  {
<span class="line-modified">!     xmlXPathContextPtr xpctxt;</span>
<span class="line-modified">!     xmlNodePtr oldnode;</span>
<span class="line-added">+     xmlDocPtr olddoc;</span>
<span class="line-added">+     xmlXPathStepOpPtr filterOp;</span>
<span class="line-added">+     int oldcs, oldpp;</span>
<span class="line-added">+     int i, j, pos;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if ((set == NULL) || (set-&gt;nodeNr == 0))</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
      /*
<span class="line-modified">!     * Check if the node set contains a sufficient number of nodes for</span>
<span class="line-added">+     * the requested range.</span>
      */
<span class="line-modified">!     if (set-&gt;nodeNr &lt; minPos) {</span>
<span class="line-modified">!         xmlXPathNodeSetClear(set, hasNsNodes);</span>
<span class="line-modified">!         return;</span>
      }
  
<span class="line-modified">!     xpctxt = ctxt-&gt;context;</span>
<span class="line-modified">!     oldnode = xpctxt-&gt;node;</span>
<span class="line-modified">!     olddoc = xpctxt-&gt;doc;</span>
<span class="line-modified">!     oldcs = xpctxt-&gt;contextSize;</span>
<span class="line-modified">!     oldpp = xpctxt-&gt;proximityPosition;</span>
<span class="line-modified">!     filterOp = &amp;ctxt-&gt;comp-&gt;steps[filterOpIndex];</span>
  
<span class="line-modified">!     xpctxt-&gt;contextSize = set-&gt;nodeNr;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     for (i = 0, j = 0, pos = 1; i &lt; set-&gt;nodeNr; i++) {</span>
<span class="line-modified">!         xmlNodePtr node = set-&gt;nodeTab[i];</span>
<span class="line-added">+         int res;</span>
<span class="line-added">+ </span>
<span class="line-added">+         xpctxt-&gt;node = node;</span>
<span class="line-added">+         xpctxt-&gt;proximityPosition = i + 1;</span>
  
          /*
          * Also set the xpath document in case things like
          * key() are evaluated in the predicate.
<span class="line-added">+         *</span>
<span class="line-added">+         * TODO: Get real doc for namespace nodes.</span>
          */
<span class="line-modified">!         if ((node-&gt;type != XML_NAMESPACE_DECL) &amp;&amp;</span>
<span class="line-modified">!             (node-&gt;doc != NULL))</span>
<span class="line-modified">!             xpctxt-&gt;doc = node-&gt;doc;</span>
  
<span class="line-modified">!         res = xmlXPathCompOpEvalToBoolean(ctxt, filterOp, 1);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (ctxt-&gt;error != XPATH_EXPRESSION_OK)</span>
<span class="line-added">+             goto exit;</span>
<span class="line-added">+         if (res &lt; 0) {</span>
<span class="line-added">+             /* Shouldn&#39;t happen */</span>
<span class="line-added">+             xmlXPathErr(ctxt, XPATH_EXPR_ERROR);</span>
<span class="line-added">+             goto exit;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!         if ((res != 0) &amp;&amp; ((pos &gt;= minPos) &amp;&amp; (pos &lt;= maxPos))) {</span>
<span class="line-added">+             if (i != j) {</span>
<span class="line-added">+                 set-&gt;nodeTab[j] = node;</span>
<span class="line-added">+                 set-&gt;nodeTab[i] = NULL;</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             j += 1;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             /* Remove the entry from the initial node set. */</span>
<span class="line-modified">!             set-&gt;nodeTab[i] = NULL;</span>
<span class="line-added">+             if (node-&gt;type == XML_NAMESPACE_DECL)</span>
<span class="line-added">+                 xmlXPathNodeSetFreeNs((xmlNsPtr) node);</span>
          }
  
          if (res != 0) {
<span class="line-modified">!             if (pos == maxPos) {</span>
<span class="line-modified">!                 /* Clear remaining nodes and exit loop. */</span>
<span class="line-modified">!                 if (hasNsNodes) {</span>
<span class="line-modified">!                     for (i++; i &lt; set-&gt;nodeNr; i++) {</span>
<span class="line-modified">!                         node = set-&gt;nodeTab[i];</span>
<span class="line-modified">!                         if ((node != NULL) &amp;&amp;</span>
<span class="line-modified">!                             (node-&gt;type == XML_NAMESPACE_DECL))</span>
<span class="line-modified">!                             xmlXPathNodeSetFreeNs((xmlNsPtr) node);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             pos += 1;</span>
          }
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     set-&gt;nodeNr = j;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     /* If too many elements were removed, shrink table to preserve memory. */</span>
<span class="line-modified">!     if ((set-&gt;nodeMax &gt; XML_NODESET_DEFAULT) &amp;&amp;</span>
<span class="line-modified">!         (set-&gt;nodeNr &lt; set-&gt;nodeMax / 2)) {</span>
<span class="line-modified">!         xmlNodePtr *tmp;</span>
<span class="line-added">+         int nodeMax = set-&gt;nodeNr;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (nodeMax &lt; XML_NODESET_DEFAULT)</span>
<span class="line-added">+             nodeMax = XML_NODESET_DEFAULT;</span>
<span class="line-added">+         tmp = (xmlNodePtr *) xmlRealloc(set-&gt;nodeTab,</span>
<span class="line-added">+                 nodeMax * sizeof(xmlNodePtr));</span>
<span class="line-added">+         if (tmp == NULL) {</span>
<span class="line-added">+             xmlXPathPErrMemory(ctxt, &quot;shrinking nodeset\n&quot;);</span>
          } else {
<span class="line-modified">!             set-&gt;nodeTab = tmp;</span>
<span class="line-modified">!             set-&gt;nodeMax = nodeMax;</span>
          }
      }
  
<span class="line-modified">! exit:</span>
<span class="line-modified">!     xpctxt-&gt;node = oldnode;</span>
<span class="line-modified">!     xpctxt-&gt;doc = olddoc;</span>
      xpctxt-&gt;contextSize = oldcs;
      xpctxt-&gt;proximityPosition = oldpp;
      }
  
  #ifdef LIBXML_XPTR_ENABLED
<span class="line-modified">! /**</span>
<span class="line-modified">!  * xmlXPathLocationSetFilter:</span>
<span class="line-modified">!  * @ctxt:  the XPath Parser context</span>
<span class="line-modified">!  * @locset: the location set to filter</span>
<span class="line-added">+  * @filterOpIndex: the index of the predicate/filter op</span>
<span class="line-added">+  * @minPos: minimum position in the filtered set (1-based)</span>
<span class="line-added">+  * @maxPos: maximum position in the filtered set (1-based)</span>
<span class="line-added">+     *</span>
<span class="line-added">+  * Filter a location set, keeping only nodes for which the predicate</span>
<span class="line-added">+  * expression matches. Afterwards, keep only nodes between minPos and maxPos</span>
<span class="line-added">+  * in the filtered result.</span>
      */
<span class="line-modified">! static void</span>
<span class="line-added">+ xmlXPathLocationSetFilter(xmlXPathParserContextPtr ctxt,</span>
<span class="line-added">+                   xmlLocationSetPtr locset,</span>
<span class="line-added">+                   int filterOpIndex,</span>
<span class="line-added">+                           int minPos, int maxPos)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     xmlXPathContextPtr xpctxt;</span>
<span class="line-added">+     xmlNodePtr oldnode;</span>
<span class="line-added">+     xmlDocPtr olddoc;</span>
<span class="line-added">+     xmlXPathStepOpPtr filterOp;</span>
<span class="line-added">+     int oldcs, oldpp;</span>
<span class="line-added">+     int i, j, pos;</span>
  
<span class="line-modified">!     if ((locset == NULL) || (locset-&gt;locNr == 0) || (filterOpIndex == -1))</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     xpctxt = ctxt-&gt;context;</span>
<span class="line-modified">!     oldnode = xpctxt-&gt;node;</span>
<span class="line-added">+     olddoc = xpctxt-&gt;doc;</span>
          oldcs = xpctxt-&gt;contextSize;
          oldpp = xpctxt-&gt;proximityPosition;
<span class="line-modified">!     filterOp = &amp;ctxt-&gt;comp-&gt;steps[filterOpIndex];</span>
  
<span class="line-modified">!     xpctxt-&gt;contextSize = locset-&gt;locNr;</span>
<span class="line-modified">! </span>
<span class="line-added">+     for (i = 0, j = 0, pos = 1; i &lt; locset-&gt;locNr; i++) {</span>
<span class="line-added">+         xmlNodePtr contextNode = locset-&gt;locTab[i]-&gt;user;</span>
<span class="line-added">+         int res;</span>
  
          xpctxt-&gt;node = contextNode;
<span class="line-modified">!         xpctxt-&gt;proximityPosition = i + 1;</span>
  
          /*
          * Also set the xpath document in case things like
<span class="line-modified">!         * key() are evaluated in the predicate.</span>
<span class="line-added">+         *</span>
<span class="line-added">+         * TODO: Get real doc for namespace nodes.</span>
          */
          if ((contextNode-&gt;type != XML_NAMESPACE_DECL) &amp;&amp;
          (contextNode-&gt;doc != NULL))
          xpctxt-&gt;doc = contextNode-&gt;doc;
<span class="line-modified">! </span>
<span class="line-modified">!         res = xmlXPathCompOpEvalToBoolean(ctxt, filterOp, 1);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (ctxt-&gt;error != XPATH_EXPRESSION_OK)</span>
<span class="line-modified">!             goto exit;</span>
<span class="line-modified">!         if (res &lt; 0) {</span>
<span class="line-modified">!             /* Shouldn&#39;t happen */</span>
<span class="line-modified">!             xmlXPathErr(ctxt, XPATH_EXPR_ERROR);</span>
<span class="line-modified">!             goto exit;</span>
          }
<span class="line-added">+ </span>
<span class="line-added">+         if ((res != 0) &amp;&amp; ((pos &gt;= minPos) &amp;&amp; (pos &lt;= maxPos))) {</span>
<span class="line-added">+             if (i != j) {</span>
<span class="line-added">+                 locset-&gt;locTab[j] = locset-&gt;locTab[i];</span>
<span class="line-added">+                 locset-&gt;locTab[i] = NULL;</span>
          }
  
<span class="line-modified">!             j += 1;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             /* Remove the entry from the initial location set. */</span>
<span class="line-modified">!             xmlXPathFreeObject(locset-&gt;locTab[i]);</span>
<span class="line-modified">!             locset-&gt;locTab[i] = NULL;</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         if (res != 0) {</span>
<span class="line-modified">!             if (pos == maxPos) {</span>
<span class="line-modified">!                 /* Clear remaining nodes and exit loop. */</span>
<span class="line-modified">!                 for (i++; i &lt; locset-&gt;locNr; i++) {</span>
<span class="line-modified">!                     xmlXPathFreeObject(locset-&gt;locTab[i]);</span>
          }
<span class="line-modified">!                 break;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!             pos += 1;</span>
<span class="line-modified">!     }</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">!     locset-&gt;locNr = j;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     /* If too many elements were removed, shrink table to preserve memory. */</span>
<span class="line-modified">!     if ((locset-&gt;locMax &gt; XML_NODESET_DEFAULT) &amp;&amp;</span>
<span class="line-modified">!         (locset-&gt;locNr &lt; locset-&gt;locMax / 2)) {</span>
<span class="line-modified">!         xmlXPathObjectPtr *tmp;</span>
<span class="line-modified">!         int locMax = locset-&gt;locNr;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (locMax &lt; XML_NODESET_DEFAULT)</span>
<span class="line-modified">!             locMax = XML_NODESET_DEFAULT;</span>
<span class="line-modified">!         tmp = (xmlXPathObjectPtr *) xmlRealloc(locset-&gt;locTab,</span>
<span class="line-modified">!                 locMax * sizeof(xmlXPathObjectPtr));</span>
<span class="line-modified">!         if (tmp == NULL) {</span>
<span class="line-modified">!             xmlXPathPErrMemory(ctxt, &quot;shrinking locset\n&quot;);</span>
          } else {
<span class="line-modified">!             locset-&gt;locTab = tmp;</span>
<span class="line-modified">!             locset-&gt;locMax = locMax;</span>
          }
          }
<span class="line-modified">! </span>
<span class="line-modified">! exit:</span>
<span class="line-modified">!     xpctxt-&gt;node = oldnode;</span>
<span class="line-modified">!     xpctxt-&gt;doc = olddoc;</span>
<span class="line-modified">!     xpctxt-&gt;contextSize = oldcs;</span>
<span class="line-added">+     xpctxt-&gt;proximityPosition = oldpp;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ #endif /* LIBXML_XPTR_ENABLED */</span>
<span class="line-added">+ </span>
<span class="line-added">+ /**</span>
<span class="line-added">+  * xmlXPathCompOpEvalPredicate:</span>
<span class="line-added">+  * @ctxt:  the XPath Parser context</span>
<span class="line-added">+  * @op: the predicate op</span>
<span class="line-added">+  * @set: the node set to filter</span>
<span class="line-added">+  * @minPos: minimum position in the filtered set (1-based)</span>
<span class="line-added">+  * @maxPos: maximum position in the filtered set (1-based)</span>
<span class="line-added">+  * @hasNsNodes: true if the node set may contain namespace nodes</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Filter a node set, keeping only nodes for which the sequence of predicate</span>
<span class="line-added">+  * expressions matches. Afterwards, keep only nodes between minPos and maxPos</span>
<span class="line-added">+  * in the filtered result.</span>
          */
<span class="line-modified">! static void</span>
<span class="line-modified">! xmlXPathCompOpEvalPredicate(xmlXPathParserContextPtr ctxt,</span>
<span class="line-modified">!                 xmlXPathStepOpPtr op,</span>
<span class="line-added">+                 xmlNodeSetPtr set,</span>
<span class="line-added">+                             int minPos, int maxPos,</span>
<span class="line-added">+                 int hasNsNodes)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (op-&gt;ch1 != -1) {</span>
<span class="line-added">+     xmlXPathCompExprPtr comp = ctxt-&gt;comp;</span>
          /*
<span class="line-modified">!     * Process inner predicates first.</span>
          */
<span class="line-modified">!     if (comp-&gt;steps[op-&gt;ch1].op != XPATH_OP_PREDICATE) {</span>
<span class="line-modified">!             xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-added">+                 &quot;xmlXPathCompOpEvalPredicate: Expected a predicate\n&quot;);</span>
<span class="line-added">+             XP_ERROR(XPATH_INVALID_OPERAND);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (ctxt-&gt;context-&gt;depth &gt;= ctxt-&gt;context-&gt;maxDepth)</span>
<span class="line-added">+             XP_ERROR(XPATH_RECURSION_LIMIT_EXCEEDED);</span>
<span class="line-added">+         ctxt-&gt;context-&gt;depth += 1;</span>
<span class="line-added">+     xmlXPathCompOpEvalPredicate(ctxt, &amp;comp-&gt;steps[op-&gt;ch1], set,</span>
<span class="line-added">+                                     1, set-&gt;nodeNr, hasNsNodes);</span>
<span class="line-added">+         ctxt-&gt;context-&gt;depth -= 1;</span>
<span class="line-added">+     CHECK_ERROR;</span>
      }
  
<span class="line-modified">!     if (op-&gt;ch2 != -1)</span>
<span class="line-modified">!         xmlXPathNodeSetFilter(ctxt, set, op-&gt;ch2, minPos, maxPos, hasNsNodes);</span>
  }
  
  static int
  xmlXPathIsPositionalPredicate(xmlXPathParserContextPtr ctxt,
                  xmlXPathStepOpPtr op,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12011,11 ***</span>
      /*
      * If not -1, then ch1 will point to:
      * 1) For predicates (XPATH_OP_PREDICATE):
      *    - an inner predicate operator
      * 2) For filters (XPATH_OP_FILTER):
<span class="line-modified">!     *    - an inner filter operater OR</span>
      *    - an expression selecting the node set.
      *      E.g. &quot;key(&#39;a&#39;, &#39;b&#39;)&quot; or &quot;(//foo | //bar)&quot;.
      */
      if ((op-&gt;op != XPATH_OP_PREDICATE) &amp;&amp; (op-&gt;op != XPATH_OP_FILTER))
      return(0);
<span class="line-new-header">--- 11892,11 ---</span>
      /*
      * If not -1, then ch1 will point to:
      * 1) For predicates (XPATH_OP_PREDICATE):
      *    - an inner predicate operator
      * 2) For filters (XPATH_OP_FILTER):
<span class="line-modified">!     *    - an inner filter operator OR</span>
      *    - an expression selecting the node set.
      *      E.g. &quot;key(&#39;a&#39;, &#39;b&#39;)&quot; or &quot;(//foo | //bar)&quot;.
      */
      if ((op-&gt;op != XPATH_OP_PREDICATE) &amp;&amp; (op-&gt;op != XPATH_OP_FILTER))
      return(0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12109,11 ***</span>
      xmlNodeSetPtr seq;
      xmlNodePtr cur;
      /* First predicate operator */
      xmlXPathStepOpPtr predOp;
      int maxPos; /* The requested position() (when a &quot;[n]&quot; predicate) */
<span class="line-modified">!     int hasPredicateRange, hasAxisRange, pos, size, newSize;</span>
      int breakOnFirstHit;
  
      xmlXPathTraversalFunction next = NULL;
      int (*addNode) (xmlNodeSetPtr, xmlNodePtr);
      xmlXPathNodeSetMergeFunction mergeAndClear;
<span class="line-new-header">--- 11990,11 ---</span>
      xmlNodeSetPtr seq;
      xmlNodePtr cur;
      /* First predicate operator */
      xmlXPathStepOpPtr predOp;
      int maxPos; /* The requested position() (when a &quot;[n]&quot; predicate) */
<span class="line-modified">!     int hasPredicateRange, hasAxisRange, pos;</span>
      int breakOnFirstHit;
  
      xmlXPathTraversalFunction next = NULL;
      int (*addNode) (xmlNodeSetPtr, xmlNodePtr);
      xmlXPathNodeSetMergeFunction mergeAndClear;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12302,10 ***</span>
<span class="line-new-header">--- 12183,11 ---</span>
      xpctxt-&gt;node = contextSeq-&gt;nodeTab[contextIdx++];
  
      if (seq == NULL) {
          seq = xmlXPathNodeSetCreate(NULL);
          if (seq == NULL) {
<span class="line-added">+                 /* TODO: Propagate memory error. */</span>
          total = 0;
          goto error;
          }
      }
      /*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12313,10 ***</span>
<span class="line-new-header">--- 12195,13 ---</span>
      */
      pos = 0;
      cur = NULL;
      hasNsNodes = 0;
          do {
<span class="line-added">+             if (OP_LIMIT_EXCEEDED(ctxt, 1))</span>
<span class="line-added">+                 goto error;</span>
<span class="line-added">+ </span>
              cur = next(ctxt, cur);
              if (cur == NULL)
                  break;
  
          /*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12520,11 ***</span>
      */
      if (outSeq == NULL) {
          outSeq = seq;
          seq = NULL;
      } else
<span class="line-modified">!         outSeq = mergeAndClear(outSeq, seq, 0);</span>
      /*
      * Break if only a true/false result was requested.
      */
      if (toBool)
          break;
<span class="line-new-header">--- 12405,12 ---</span>
      */
      if (outSeq == NULL) {
          outSeq = seq;
          seq = NULL;
      } else
<span class="line-modified">!             /* TODO: Check memory error. */</span>
<span class="line-added">+         outSeq = mergeAndClear(outSeq, seq);</span>
      /*
      * Break if only a true/false result was requested.
      */
      if (toBool)
          break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12537,11 ***</span>
      */
      if (outSeq == NULL) {
          outSeq = seq;
          seq = NULL;
      } else
<span class="line-modified">!         outSeq = mergeAndClear(outSeq, seq, 0);</span>
      break;
  
  #ifdef DEBUG_STEP
      if (seq != NULL)
          nbMatches += seq-&gt;nodeNr;
<span class="line-new-header">--- 12423,12 ---</span>
      */
      if (outSeq == NULL) {
          outSeq = seq;
          seq = NULL;
      } else
<span class="line-modified">!             /* TODO: Check memory error. */</span>
<span class="line-added">+         outSeq = mergeAndClear(outSeq, seq);</span>
      break;
  
  #ifdef DEBUG_STEP
      if (seq != NULL)
          nbMatches += seq-&gt;nodeNr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12581,64 ***</span>
          *     &quot;parent&quot; field on xmlXPathStepOp
          *
          * For the moment, I&#39;ll try to solve this with a recursive
          * function: xmlXPathCompOpEvalPredicate().
          */
<span class="line-removed">-         size = seq-&gt;nodeNr;</span>
          if (hasPredicateRange != 0)
<span class="line-modified">!         newSize = xmlXPathCompOpEvalPositionalPredicate(ctxt,</span>
<span class="line-modified">!             predOp, seq, size, maxPos, maxPos, hasNsNodes);</span>
          else
<span class="line-modified">!         newSize = xmlXPathCompOpEvalPredicate(ctxt,</span>
<span class="line-modified">!             predOp, seq, size, hasNsNodes);</span>
  
          if (ctxt-&gt;error != XPATH_EXPRESSION_OK) {
          total = 0;
          goto error;
          }
<span class="line-removed">-         /*</span>
<span class="line-removed">-         * Add the filtered set of nodes to the result node set.</span>
<span class="line-removed">-         */</span>
<span class="line-removed">-         if (newSize == 0) {</span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-         * The predicates filtered all nodes out.</span>
<span class="line-removed">-         */</span>
<span class="line-removed">-         xmlXPathNodeSetClear(seq, hasNsNodes);</span>
<span class="line-removed">-         } else if (seq-&gt;nodeNr &gt; 0) {</span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-         * Add to result set.</span>
<span class="line-removed">-         */</span>
<span class="line-removed">-         if (outSeq == NULL) {</span>
<span class="line-removed">-             if (size != newSize) {</span>
<span class="line-removed">-             /*</span>
<span class="line-removed">-             * We need to merge and clear here, since</span>
<span class="line-removed">-             * the sequence will contained NULLed entries.</span>
<span class="line-removed">-             */</span>
<span class="line-removed">-             outSeq = mergeAndClear(NULL, seq, 1);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-             outSeq = seq;</span>
<span class="line-removed">-             seq = NULL;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } else</span>
<span class="line-removed">-             outSeq = mergeAndClear(outSeq, seq,</span>
<span class="line-removed">-             (size != newSize) ? 1: 0);</span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-         * Break if only a true/false result was requested.</span>
<span class="line-removed">-         */</span>
<span class="line-removed">-         if (toBool)</span>
<span class="line-removed">-             break;</span>
          }
<span class="line-modified">!         } else if (seq-&gt;nodeNr &gt; 0) {</span>
          /*
          * Add to result set.
          */
          if (outSeq == NULL) {
          outSeq = seq;
          seq = NULL;
          } else {
<span class="line-modified">!         outSeq = mergeAndClear(outSeq, seq, 0);</span>
          }
      }
      }
  
  error:
      if ((obj-&gt;boolval) &amp;&amp; (obj-&gt;user != NULL)) {
<span class="line-new-header">--- 12468,37 ---</span>
          *     &quot;parent&quot; field on xmlXPathStepOp
          *
          * For the moment, I&#39;ll try to solve this with a recursive
          * function: xmlXPathCompOpEvalPredicate().
          */
          if (hasPredicateRange != 0)
<span class="line-modified">!         xmlXPathCompOpEvalPredicate(ctxt, predOp, seq, maxPos, maxPos,</span>
<span class="line-modified">!                         hasNsNodes);</span>
          else
<span class="line-modified">!         xmlXPathCompOpEvalPredicate(ctxt, predOp, seq, 1, seq-&gt;nodeNr,</span>
<span class="line-modified">!                         hasNsNodes);</span>
  
          if (ctxt-&gt;error != XPATH_EXPRESSION_OK) {
          total = 0;
          goto error;
          }
          }
<span class="line-modified">! </span>
<span class="line-added">+         if (seq-&gt;nodeNr &gt; 0) {</span>
          /*
          * Add to result set.
          */
          if (outSeq == NULL) {
          outSeq = seq;
          seq = NULL;
          } else {
<span class="line-modified">!                 /* TODO: Check memory error. */</span>
<span class="line-added">+         outSeq = mergeAndClear(outSeq, seq);</span>
          }
<span class="line-added">+ </span>
<span class="line-added">+             if (toBool)</span>
<span class="line-added">+                 break;</span>
      }
      }
  
  error:
      if ((obj-&gt;boolval) &amp;&amp; (obj-&gt;user != NULL)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12653,18 ***</span>
      obj-&gt;boolval = 0;
      }
      xmlXPathReleaseObject(xpctxt, obj);
  
      /*
<span class="line-modified">!     * Ensure we return at least an emtpy set.</span>
      */
      if (outSeq == NULL) {
      if ((seq != NULL) &amp;&amp; (seq-&gt;nodeNr == 0))
          outSeq = seq;
      else
          outSeq = xmlXPathNodeSetCreate(NULL);
<span class="line-removed">-         /* XXX what if xmlXPathNodeSetCreate returned NULL here? */</span>
      }
      if ((seq != NULL) &amp;&amp; (seq != outSeq)) {
       xmlXPathFreeNodeSet(seq);
      }
      /*
<span class="line-new-header">--- 12513,18 ---</span>
      obj-&gt;boolval = 0;
      }
      xmlXPathReleaseObject(xpctxt, obj);
  
      /*
<span class="line-modified">!     * Ensure we return at least an empty set.</span>
      */
      if (outSeq == NULL) {
      if ((seq != NULL) &amp;&amp; (seq-&gt;nodeNr == 0))
          outSeq = seq;
      else
<span class="line-added">+             /* TODO: Check memory error. */</span>
          outSeq = xmlXPathNodeSetCreate(NULL);
      }
      if ((seq != NULL) &amp;&amp; (seq != outSeq)) {
       xmlXPathFreeNodeSet(seq);
      }
      /*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12716,14 ***</span>
      int total = 0, cur;
      xmlXPathCompExprPtr comp;
      xmlXPathObjectPtr arg1, arg2;
  
      CHECK_ERROR0;
      comp = ctxt-&gt;comp;
      switch (op-&gt;op) {
          case XPATH_OP_END:
<span class="line-modified">!             return (0);</span>
          case XPATH_OP_UNION:
              total =
                  xmlXPathCompOpEvalFirst(ctxt, &amp;comp-&gt;steps[op-&gt;ch1],
                                          first);
          CHECK_ERROR0;
<span class="line-new-header">--- 12576,19 ---</span>
      int total = 0, cur;
      xmlXPathCompExprPtr comp;
      xmlXPathObjectPtr arg1, arg2;
  
      CHECK_ERROR0;
<span class="line-added">+     if (OP_LIMIT_EXCEEDED(ctxt, 1))</span>
<span class="line-added">+         return(0);</span>
<span class="line-added">+     if (ctxt-&gt;context-&gt;depth &gt;= ctxt-&gt;context-&gt;maxDepth)</span>
<span class="line-added">+         XP_ERROR0(XPATH_RECURSION_LIMIT_EXCEEDED);</span>
<span class="line-added">+     ctxt-&gt;context-&gt;depth += 1;</span>
      comp = ctxt-&gt;comp;
      switch (op-&gt;op) {
          case XPATH_OP_END:
<span class="line-modified">!             break;</span>
          case XPATH_OP_UNION:
              total =
                  xmlXPathCompOpEvalFirst(ctxt, &amp;comp-&gt;steps[op-&gt;ch1],
                                          first);
          CHECK_ERROR0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12733,15 ***</span>
                  &amp;&amp; (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt;= 1)) {
                  /*
                   * limit tree traversing to first node in the result
                   */
          /*
<span class="line-modified">!         * OPTIMIZE TODO: This implicitely sorts</span>
          *  the result, even if not needed. E.g. if the argument
          *  of the count() function, no sorting is needed.
          * OPTIMIZE TODO: How do we know if the node-list wasn&#39;t
<span class="line-modified">!         *  aready sorted?</span>
          */
          if (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1)
              xmlXPathNodeSetSort(ctxt-&gt;value-&gt;nodesetval);
                  *first = ctxt-&gt;value-&gt;nodesetval-&gt;nodeTab[0];
              }
<span class="line-new-header">--- 12598,15 ---</span>
                  &amp;&amp; (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt;= 1)) {
                  /*
                   * limit tree traversing to first node in the result
                   */
          /*
<span class="line-modified">!         * OPTIMIZE TODO: This implicitly sorts</span>
          *  the result, even if not needed. E.g. if the argument
          *  of the count() function, no sorting is needed.
          * OPTIMIZE TODO: How do we know if the node-list wasn&#39;t
<span class="line-modified">!         *  already sorted?</span>
          */
          if (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1)
              xmlXPathNodeSetSort(ctxt-&gt;value-&gt;nodesetval);
                  *first = ctxt-&gt;value-&gt;nodesetval-&gt;nodeTab[0];
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12756,47 ***</span>
                  (arg2 == NULL) || (arg2-&gt;type != XPATH_NODESET)) {
              xmlXPathReleaseObject(ctxt-&gt;context, arg1);
              xmlXPathReleaseObject(ctxt-&gt;context, arg2);
                  XP_ERROR0(XPATH_INVALID_TYPE);
              }
  
              arg1-&gt;nodesetval = xmlXPathNodeSetMerge(arg1-&gt;nodesetval,
                                                      arg2-&gt;nodesetval);
              valuePush(ctxt, arg1);
          xmlXPathReleaseObject(ctxt-&gt;context, arg2);
              /* optimizer */
          if (total &gt; cur)
          xmlXPathCompSwap(op);
<span class="line-modified">!             return (total + cur);</span>
          case XPATH_OP_ROOT:
              xmlXPathRoot(ctxt);
<span class="line-modified">!             return (0);</span>
          case XPATH_OP_NODE:
              if (op-&gt;ch1 != -1)
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
              if (op-&gt;ch2 != -1)
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
          CHECK_ERROR0;
          valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt-&gt;context,
          ctxt-&gt;context-&gt;node));
<span class="line-modified">!             return (total);</span>
          case XPATH_OP_COLLECT:{
                  if (op-&gt;ch1 == -1)
<span class="line-modified">!                     return (total);</span>
  
                  total = xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
  
                  total += xmlXPathNodeCollectAndTest(ctxt, op, first, NULL, 0);
<span class="line-modified">!                 return (total);</span>
              }
          case XPATH_OP_VALUE:
              valuePush(ctxt,
                        xmlXPathCacheObjectCopy(ctxt-&gt;context,
              (xmlXPathObjectPtr) op-&gt;value4));
<span class="line-modified">!             return (0);</span>
          case XPATH_OP_SORT:
              if (op-&gt;ch1 != -1)
                  total +=
                      xmlXPathCompOpEvalFirst(ctxt, &amp;comp-&gt;steps[op-&gt;ch1],
                                              first);
<span class="line-new-header">--- 12621,60 ---</span>
                  (arg2 == NULL) || (arg2-&gt;type != XPATH_NODESET)) {
              xmlXPathReleaseObject(ctxt-&gt;context, arg1);
              xmlXPathReleaseObject(ctxt-&gt;context, arg2);
                  XP_ERROR0(XPATH_INVALID_TYPE);
              }
<span class="line-added">+             if ((ctxt-&gt;context-&gt;opLimit != 0) &amp;&amp;</span>
<span class="line-added">+                 (((arg1-&gt;nodesetval != NULL) &amp;&amp;</span>
<span class="line-added">+                   (xmlXPathCheckOpLimit(ctxt,</span>
<span class="line-added">+                                         arg1-&gt;nodesetval-&gt;nodeNr) &lt; 0)) ||</span>
<span class="line-added">+                  ((arg2-&gt;nodesetval != NULL) &amp;&amp;</span>
<span class="line-added">+                   (xmlXPathCheckOpLimit(ctxt,</span>
<span class="line-added">+                                         arg2-&gt;nodesetval-&gt;nodeNr) &lt; 0)))) {</span>
<span class="line-added">+             xmlXPathReleaseObject(ctxt-&gt;context, arg1);</span>
<span class="line-added">+             xmlXPathReleaseObject(ctxt-&gt;context, arg2);</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
  
<span class="line-added">+             /* TODO: Check memory error. */</span>
              arg1-&gt;nodesetval = xmlXPathNodeSetMerge(arg1-&gt;nodesetval,
                                                      arg2-&gt;nodesetval);
              valuePush(ctxt, arg1);
          xmlXPathReleaseObject(ctxt-&gt;context, arg2);
              /* optimizer */
          if (total &gt; cur)
          xmlXPathCompSwap(op);
<span class="line-modified">!             total += cur;</span>
<span class="line-added">+             break;</span>
          case XPATH_OP_ROOT:
              xmlXPathRoot(ctxt);
<span class="line-modified">!             break;</span>
          case XPATH_OP_NODE:
              if (op-&gt;ch1 != -1)
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
              if (op-&gt;ch2 != -1)
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
          CHECK_ERROR0;
          valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt-&gt;context,
          ctxt-&gt;context-&gt;node));
<span class="line-modified">!             break;</span>
          case XPATH_OP_COLLECT:{
                  if (op-&gt;ch1 == -1)
<span class="line-modified">!                     break;</span>
  
                  total = xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
  
                  total += xmlXPathNodeCollectAndTest(ctxt, op, first, NULL, 0);
<span class="line-modified">!                 break;</span>
              }
          case XPATH_OP_VALUE:
              valuePush(ctxt,
                        xmlXPathCacheObjectCopy(ctxt-&gt;context,
              (xmlXPathObjectPtr) op-&gt;value4));
<span class="line-modified">!             break;</span>
          case XPATH_OP_SORT:
              if (op-&gt;ch1 != -1)
                  total +=
                      xmlXPathCompOpEvalFirst(ctxt, &amp;comp-&gt;steps[op-&gt;ch1],
                                              first);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12804,19 ***</span>
              if ((ctxt-&gt;value != NULL)
                  &amp;&amp; (ctxt-&gt;value-&gt;type == XPATH_NODESET)
                  &amp;&amp; (ctxt-&gt;value-&gt;nodesetval != NULL)
          &amp;&amp; (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1))
                  xmlXPathNodeSetSort(ctxt-&gt;value-&gt;nodesetval);
<span class="line-modified">!             return (total);</span>
  #ifdef XP_OPTIMIZED_FILTER_FIRST
      case XPATH_OP_FILTER:
                  total += xmlXPathCompOpEvalFilterFirst(ctxt, op, first);
<span class="line-modified">!             return (total);</span>
  #endif
          default:
<span class="line-modified">!             return (xmlXPathCompOpEval(ctxt, op));</span>
      }
  }
  
  /**
   * xmlXPathCompOpEvalLast:
   * @ctxt:  the XPath parser context with the compiled expression
<span class="line-new-header">--- 12682,23 ---</span>
              if ((ctxt-&gt;value != NULL)
                  &amp;&amp; (ctxt-&gt;value-&gt;type == XPATH_NODESET)
                  &amp;&amp; (ctxt-&gt;value-&gt;nodesetval != NULL)
          &amp;&amp; (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1))
                  xmlXPathNodeSetSort(ctxt-&gt;value-&gt;nodesetval);
<span class="line-modified">!             break;</span>
  #ifdef XP_OPTIMIZED_FILTER_FIRST
      case XPATH_OP_FILTER:
                  total += xmlXPathCompOpEvalFilterFirst(ctxt, op, first);
<span class="line-modified">!             break;</span>
  #endif
          default:
<span class="line-modified">!             total += xmlXPathCompOpEval(ctxt, op);</span>
<span class="line-added">+             break;</span>
      }
<span class="line-added">+ </span>
<span class="line-added">+     ctxt-&gt;context-&gt;depth -= 1;</span>
<span class="line-added">+     return(total);</span>
  }
  
  /**
   * xmlXPathCompOpEvalLast:
   * @ctxt:  the XPath parser context with the compiled expression
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12835,14 ***</span>
      int total = 0, cur;
      xmlXPathCompExprPtr comp;
      xmlXPathObjectPtr arg1, arg2;
  
      CHECK_ERROR0;
      comp = ctxt-&gt;comp;
      switch (op-&gt;op) {
          case XPATH_OP_END:
<span class="line-modified">!             return (0);</span>
          case XPATH_OP_UNION:
              total =
                  xmlXPathCompOpEvalLast(ctxt, &amp;comp-&gt;steps[op-&gt;ch1], last);
          CHECK_ERROR0;
              if ((ctxt-&gt;value != NULL)
<span class="line-new-header">--- 12717,19 ---</span>
      int total = 0, cur;
      xmlXPathCompExprPtr comp;
      xmlXPathObjectPtr arg1, arg2;
  
      CHECK_ERROR0;
<span class="line-added">+     if (OP_LIMIT_EXCEEDED(ctxt, 1))</span>
<span class="line-added">+         return(0);</span>
<span class="line-added">+     if (ctxt-&gt;context-&gt;depth &gt;= ctxt-&gt;context-&gt;maxDepth)</span>
<span class="line-added">+         XP_ERROR0(XPATH_RECURSION_LIMIT_EXCEEDED);</span>
<span class="line-added">+     ctxt-&gt;context-&gt;depth += 1;</span>
      comp = ctxt-&gt;comp;
      switch (op-&gt;op) {
          case XPATH_OP_END:
<span class="line-modified">!             break;</span>
          case XPATH_OP_UNION:
              total =
                  xmlXPathCompOpEvalLast(ctxt, &amp;comp-&gt;steps[op-&gt;ch1], last);
          CHECK_ERROR0;
              if ((ctxt-&gt;value != NULL)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12874,47 ***</span>
                  (arg2 == NULL) || (arg2-&gt;type != XPATH_NODESET)) {
              xmlXPathReleaseObject(ctxt-&gt;context, arg1);
              xmlXPathReleaseObject(ctxt-&gt;context, arg2);
                  XP_ERROR0(XPATH_INVALID_TYPE);
              }
  
              arg1-&gt;nodesetval = xmlXPathNodeSetMerge(arg1-&gt;nodesetval,
                                                      arg2-&gt;nodesetval);
              valuePush(ctxt, arg1);
          xmlXPathReleaseObject(ctxt-&gt;context, arg2);
              /* optimizer */
          if (total &gt; cur)
          xmlXPathCompSwap(op);
<span class="line-modified">!             return (total + cur);</span>
          case XPATH_OP_ROOT:
              xmlXPathRoot(ctxt);
<span class="line-modified">!             return (0);</span>
          case XPATH_OP_NODE:
              if (op-&gt;ch1 != -1)
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
              if (op-&gt;ch2 != -1)
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
          CHECK_ERROR0;
          valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt-&gt;context,
          ctxt-&gt;context-&gt;node));
<span class="line-modified">!             return (total);</span>
          case XPATH_OP_COLLECT:{
                  if (op-&gt;ch1 == -1)
<span class="line-modified">!                     return (0);</span>
  
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
  
                  total += xmlXPathNodeCollectAndTest(ctxt, op, NULL, last, 0);
<span class="line-modified">!                 return (total);</span>
              }
          case XPATH_OP_VALUE:
              valuePush(ctxt,
                        xmlXPathCacheObjectCopy(ctxt-&gt;context,
              (xmlXPathObjectPtr) op-&gt;value4));
<span class="line-modified">!             return (0);</span>
          case XPATH_OP_SORT:
              if (op-&gt;ch1 != -1)
                  total +=
                      xmlXPathCompOpEvalLast(ctxt, &amp;comp-&gt;steps[op-&gt;ch1],
                                             last);
<span class="line-new-header">--- 12761,60 ---</span>
                  (arg2 == NULL) || (arg2-&gt;type != XPATH_NODESET)) {
              xmlXPathReleaseObject(ctxt-&gt;context, arg1);
              xmlXPathReleaseObject(ctxt-&gt;context, arg2);
                  XP_ERROR0(XPATH_INVALID_TYPE);
              }
<span class="line-added">+             if ((ctxt-&gt;context-&gt;opLimit != 0) &amp;&amp;</span>
<span class="line-added">+                 (((arg1-&gt;nodesetval != NULL) &amp;&amp;</span>
<span class="line-added">+                   (xmlXPathCheckOpLimit(ctxt,</span>
<span class="line-added">+                                         arg1-&gt;nodesetval-&gt;nodeNr) &lt; 0)) ||</span>
<span class="line-added">+                  ((arg2-&gt;nodesetval != NULL) &amp;&amp;</span>
<span class="line-added">+                   (xmlXPathCheckOpLimit(ctxt,</span>
<span class="line-added">+                                         arg2-&gt;nodesetval-&gt;nodeNr) &lt; 0)))) {</span>
<span class="line-added">+             xmlXPathReleaseObject(ctxt-&gt;context, arg1);</span>
<span class="line-added">+             xmlXPathReleaseObject(ctxt-&gt;context, arg2);</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
  
<span class="line-added">+             /* TODO: Check memory error. */</span>
              arg1-&gt;nodesetval = xmlXPathNodeSetMerge(arg1-&gt;nodesetval,
                                                      arg2-&gt;nodesetval);
              valuePush(ctxt, arg1);
          xmlXPathReleaseObject(ctxt-&gt;context, arg2);
              /* optimizer */
          if (total &gt; cur)
          xmlXPathCompSwap(op);
<span class="line-modified">!             total += cur;</span>
<span class="line-added">+             break;</span>
          case XPATH_OP_ROOT:
              xmlXPathRoot(ctxt);
<span class="line-modified">!             break;</span>
          case XPATH_OP_NODE:
              if (op-&gt;ch1 != -1)
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
              if (op-&gt;ch2 != -1)
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
          CHECK_ERROR0;
          valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt-&gt;context,
          ctxt-&gt;context-&gt;node));
<span class="line-modified">!             break;</span>
          case XPATH_OP_COLLECT:{
                  if (op-&gt;ch1 == -1)
<span class="line-modified">!                     break;</span>
  
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
  
                  total += xmlXPathNodeCollectAndTest(ctxt, op, NULL, last, 0);
<span class="line-modified">!                 break;</span>
              }
          case XPATH_OP_VALUE:
              valuePush(ctxt,
                        xmlXPathCacheObjectCopy(ctxt-&gt;context,
              (xmlXPathObjectPtr) op-&gt;value4));
<span class="line-modified">!             break;</span>
          case XPATH_OP_SORT:
              if (op-&gt;ch1 != -1)
                  total +=
                      xmlXPathCompOpEvalLast(ctxt, &amp;comp-&gt;steps[op-&gt;ch1],
                                             last);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12922,30 ***</span>
              if ((ctxt-&gt;value != NULL)
                  &amp;&amp; (ctxt-&gt;value-&gt;type == XPATH_NODESET)
                  &amp;&amp; (ctxt-&gt;value-&gt;nodesetval != NULL)
          &amp;&amp; (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1))
                  xmlXPathNodeSetSort(ctxt-&gt;value-&gt;nodesetval);
<span class="line-modified">!             return (total);</span>
          default:
<span class="line-modified">!             return (xmlXPathCompOpEval(ctxt, op));</span>
      }
  }
  
  #ifdef XP_OPTIMIZED_FILTER_FIRST
  static int
  xmlXPathCompOpEvalFilterFirst(xmlXPathParserContextPtr ctxt,
                    xmlXPathStepOpPtr op, xmlNodePtr * first)
  {
      int total = 0;
      xmlXPathCompExprPtr comp;
<span class="line-modified">!     xmlXPathObjectPtr res;</span>
<span class="line-removed">-     xmlXPathObjectPtr obj;</span>
<span class="line-removed">-     xmlNodeSetPtr oldset;</span>
<span class="line-removed">-     xmlNodePtr oldnode;</span>
<span class="line-removed">-     xmlDocPtr oldDoc;</span>
<span class="line-removed">-     int oldcs, oldpp;</span>
<span class="line-removed">-     int i;</span>
  
      CHECK_ERROR0;
      comp = ctxt-&gt;comp;
      /*
      * Optimization for ()[last()] selection i.e. the last elem
<span class="line-new-header">--- 12822,28 ---</span>
              if ((ctxt-&gt;value != NULL)
                  &amp;&amp; (ctxt-&gt;value-&gt;type == XPATH_NODESET)
                  &amp;&amp; (ctxt-&gt;value-&gt;nodesetval != NULL)
          &amp;&amp; (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1))
                  xmlXPathNodeSetSort(ctxt-&gt;value-&gt;nodesetval);
<span class="line-modified">!             break;</span>
          default:
<span class="line-modified">!             total += xmlXPathCompOpEval(ctxt, op);</span>
<span class="line-added">+             break;</span>
      }
<span class="line-added">+ </span>
<span class="line-added">+     ctxt-&gt;context-&gt;depth -= 1;</span>
<span class="line-added">+     return (total);</span>
  }
  
  #ifdef XP_OPTIMIZED_FILTER_FIRST
  static int
  xmlXPathCompOpEvalFilterFirst(xmlXPathParserContextPtr ctxt,
                    xmlXPathStepOpPtr op, xmlNodePtr * first)
  {
      int total = 0;
      xmlXPathCompExprPtr comp;
<span class="line-modified">!     xmlNodeSetPtr set;</span>
  
      CHECK_ERROR0;
      comp = ctxt-&gt;comp;
      /*
      * Optimization for ()[last()] selection i.e. the last elem
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12992,212 ***</span>
      return (total);
      if (ctxt-&gt;value == NULL)
      return (total);
  
  #ifdef LIBXML_XPTR_ENABLED
<span class="line-modified">!     /*</span>
      * Hum are we filtering the result of an XPointer expression
<span class="line-modified">!     */</span>
      if (ctxt-&gt;value-&gt;type == XPATH_LOCATIONSET) {
<span class="line-modified">!     xmlXPathObjectPtr tmp = NULL;</span>
<span class="line-removed">-     xmlLocationSetPtr newlocset = NULL;</span>
<span class="line-removed">-     xmlLocationSetPtr oldlocset;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-     * Extract the old locset, and then evaluate the result of the</span>
<span class="line-removed">-     * expression for all the element in the locset. use it to grow</span>
<span class="line-removed">-     * up a new locset.</span>
<span class="line-removed">-     */</span>
<span class="line-removed">-     CHECK_TYPE0(XPATH_LOCATIONSET);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if ((ctxt-&gt;value-&gt;user == NULL) ||</span>
<span class="line-removed">-             (((xmlLocationSetPtr) ctxt-&gt;value-&gt;user)-&gt;locNr == 0))</span>
<span class="line-removed">-         return (total);</span>
  
<span class="line-modified">!     obj = valuePop(ctxt);</span>
<span class="line-modified">!     oldlocset = obj-&gt;user;</span>
<span class="line-modified">!         oldnode = ctxt-&gt;context-&gt;node;</span>
<span class="line-modified">!         oldcs = ctxt-&gt;context-&gt;contextSize;</span>
<span class="line-removed">-         oldpp = ctxt-&gt;context-&gt;proximityPosition;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     newlocset = xmlXPtrLocationSetCreate(NULL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     for (i = 0; i &lt; oldlocset-&gt;locNr; i++) {</span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-         * Run the evaluation with a node list made of a</span>
<span class="line-removed">-         * single item in the nodelocset.</span>
<span class="line-removed">-         */</span>
<span class="line-removed">-         ctxt-&gt;context-&gt;node = oldlocset-&gt;locTab[i]-&gt;user;</span>
<span class="line-removed">-         ctxt-&gt;context-&gt;contextSize = oldlocset-&gt;locNr;</span>
<span class="line-removed">-         ctxt-&gt;context-&gt;proximityPosition = i + 1;</span>
<span class="line-removed">-         if (tmp == NULL) {</span>
<span class="line-removed">-         tmp = xmlXPathCacheNewNodeSet(ctxt-&gt;context,</span>
<span class="line-removed">-             ctxt-&gt;context-&gt;node);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-         if (xmlXPathNodeSetAddUnique(tmp-&gt;nodesetval,</span>
<span class="line-removed">-                                      ctxt-&gt;context-&gt;node) &lt; 0) {</span>
<span class="line-removed">-             ctxt-&gt;error = XPATH_MEMORY_ERROR;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         valuePush(ctxt, tmp);</span>
<span class="line-removed">-         if (op-&gt;ch2 != -1)</span>
<span class="line-removed">-         total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);</span>
<span class="line-removed">-         if (ctxt-&gt;error != XPATH_EXPRESSION_OK) {</span>
<span class="line-removed">-                 xmlXPtrFreeLocationSet(newlocset);</span>
<span class="line-removed">-                 goto xptr_error;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-         * The result of the evaluation need to be tested to</span>
<span class="line-removed">-         * decided whether the filter succeeded or not</span>
<span class="line-removed">-         */</span>
<span class="line-removed">-         res = valuePop(ctxt);</span>
<span class="line-removed">-         if (xmlXPathEvaluatePredicateResult(ctxt, res)) {</span>
<span class="line-removed">-         xmlXPtrLocationSetAdd(newlocset,</span>
<span class="line-removed">-             xmlXPathCacheObjectCopy(ctxt-&gt;context,</span>
<span class="line-removed">-             oldlocset-&gt;locTab[i]));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-         * Cleanup</span>
<span class="line-removed">-         */</span>
<span class="line-removed">-         if (res != NULL) {</span>
<span class="line-removed">-         xmlXPathReleaseObject(ctxt-&gt;context, res);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (ctxt-&gt;value == tmp) {</span>
<span class="line-removed">-         valuePop(ctxt);</span>
<span class="line-removed">-         xmlXPathNodeSetClear(tmp-&gt;nodesetval, 1);</span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-         * REVISIT TODO: Don&#39;t create a temporary nodeset</span>
<span class="line-removed">-         * for everly iteration.</span>
<span class="line-removed">-         */</span>
<span class="line-removed">-         /* OLD: xmlXPathFreeObject(res); */</span>
<span class="line-removed">-         } else</span>
<span class="line-removed">-         tmp = NULL;</span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-         * Only put the first node in the result, then leave.</span>
<span class="line-removed">-         */</span>
<span class="line-removed">-         if (newlocset-&gt;locNr &gt; 0) {</span>
<span class="line-removed">-         *first = (xmlNodePtr) oldlocset-&gt;locTab[i]-&gt;user;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (tmp != NULL) {</span>
<span class="line-removed">-         xmlXPathReleaseObject(ctxt-&gt;context, tmp);</span>
      }
<span class="line-modified">!     /*</span>
<span class="line-removed">-     * The result is used as the new evaluation locset.</span>
<span class="line-removed">-     */</span>
<span class="line-removed">-     valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));</span>
<span class="line-removed">- xptr_error:</span>
<span class="line-removed">-     xmlXPathReleaseObject(ctxt-&gt;context, obj);</span>
<span class="line-removed">-     ctxt-&gt;context-&gt;node = oldnode;</span>
<span class="line-removed">-     ctxt-&gt;context-&gt;contextSize = oldcs;</span>
<span class="line-removed">-     ctxt-&gt;context-&gt;proximityPosition = oldpp;</span>
      return (total);
      }
  #endif /* LIBXML_XPTR_ENABLED */
  
<span class="line-removed">-     /*</span>
<span class="line-removed">-     * Extract the old set, and then evaluate the result of the</span>
<span class="line-removed">-     * expression for all the element in the set. use it to grow</span>
<span class="line-removed">-     * up a new set.</span>
<span class="line-removed">-     */</span>
      CHECK_TYPE0(XPATH_NODESET);
<span class="line-modified">! </span>
<span class="line-modified">!     if ((ctxt-&gt;value-&gt;nodesetval != NULL) &amp;&amp;</span>
<span class="line-modified">!         (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr != 0)) {</span>
<span class="line-modified">!     xmlNodeSetPtr newset;</span>
<span class="line-modified">!     xmlXPathObjectPtr tmp = NULL;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         obj = valuePop(ctxt);</span>
<span class="line-removed">-         oldset = obj-&gt;nodesetval;</span>
<span class="line-removed">-         oldnode = ctxt-&gt;context-&gt;node;</span>
<span class="line-removed">-         oldDoc = ctxt-&gt;context-&gt;doc;</span>
<span class="line-removed">-         oldcs = ctxt-&gt;context-&gt;contextSize;</span>
<span class="line-removed">-         oldpp = ctxt-&gt;context-&gt;proximityPosition;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-     * Initialize the new set.</span>
<span class="line-removed">-     * Also set the xpath document in case things like</span>
<span class="line-removed">-     * key() evaluation are attempted on the predicate</span>
<span class="line-removed">-     */</span>
<span class="line-removed">-     newset = xmlXPathNodeSetCreate(NULL);</span>
<span class="line-removed">-         /* XXX what if xmlXPathNodeSetCreate returned NULL? */</span>
<span class="line-removed">- </span>
<span class="line-removed">-     for (i = 0; i &lt; oldset-&gt;nodeNr; i++) {</span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-         * Run the evaluation with a node list made of</span>
<span class="line-removed">-         * a single item in the nodeset.</span>
<span class="line-removed">-         */</span>
<span class="line-removed">-         ctxt-&gt;context-&gt;node = oldset-&gt;nodeTab[i];</span>
<span class="line-removed">-         if ((oldset-&gt;nodeTab[i]-&gt;type != XML_NAMESPACE_DECL) &amp;&amp;</span>
<span class="line-removed">-         (oldset-&gt;nodeTab[i]-&gt;doc != NULL))</span>
<span class="line-removed">-         ctxt-&gt;context-&gt;doc = oldset-&gt;nodeTab[i]-&gt;doc;</span>
<span class="line-removed">-         if (tmp == NULL) {</span>
<span class="line-removed">-         tmp = xmlXPathCacheNewNodeSet(ctxt-&gt;context,</span>
<span class="line-removed">-             ctxt-&gt;context-&gt;node);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-         if (xmlXPathNodeSetAddUnique(tmp-&gt;nodesetval,</span>
<span class="line-removed">-                                      ctxt-&gt;context-&gt;node) &lt; 0) {</span>
<span class="line-removed">-             ctxt-&gt;error = XPATH_MEMORY_ERROR;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         valuePush(ctxt, tmp);</span>
<span class="line-removed">-         ctxt-&gt;context-&gt;contextSize = oldset-&gt;nodeNr;</span>
<span class="line-removed">-         ctxt-&gt;context-&gt;proximityPosition = i + 1;</span>
<span class="line-removed">-         if (op-&gt;ch2 != -1)</span>
<span class="line-removed">-         total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);</span>
<span class="line-removed">-         if (ctxt-&gt;error != XPATH_EXPRESSION_OK) {</span>
<span class="line-removed">-         xmlXPathFreeNodeSet(newset);</span>
<span class="line-removed">-                 goto error;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-         * The result of the evaluation needs to be tested to</span>
<span class="line-removed">-         * decide whether the filter succeeded or not</span>
<span class="line-removed">-         */</span>
<span class="line-removed">-         res = valuePop(ctxt);</span>
<span class="line-removed">-         if (xmlXPathEvaluatePredicateResult(ctxt, res)) {</span>
<span class="line-removed">-         if (xmlXPathNodeSetAdd(newset, oldset-&gt;nodeTab[i]) &lt; 0)</span>
<span class="line-removed">-             ctxt-&gt;error = XPATH_MEMORY_ERROR;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-         * Cleanup</span>
<span class="line-removed">-         */</span>
<span class="line-removed">-         if (res != NULL) {</span>
<span class="line-removed">-         xmlXPathReleaseObject(ctxt-&gt;context, res);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (ctxt-&gt;value == tmp) {</span>
<span class="line-removed">-         valuePop(ctxt);</span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-         * Don&#39;t free the temporary nodeset</span>
<span class="line-removed">-         * in order to avoid massive recreation inside this</span>
<span class="line-removed">-         * loop.</span>
<span class="line-removed">-         */</span>
<span class="line-removed">-         xmlXPathNodeSetClear(tmp-&gt;nodesetval, 1);</span>
<span class="line-removed">-         } else</span>
<span class="line-removed">-         tmp = NULL;</span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-         * Only put the first node in the result, then leave.</span>
<span class="line-removed">-         */</span>
<span class="line-removed">-         if (newset-&gt;nodeNr &gt; 0) {</span>
<span class="line-removed">-         *first = *(newset-&gt;nodeTab);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (tmp != NULL) {</span>
<span class="line-removed">-         xmlXPathReleaseObject(ctxt-&gt;context, tmp);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-     * The result is used as the new evaluation set.</span>
<span class="line-removed">-     */</span>
<span class="line-removed">-     valuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt-&gt;context, newset));</span>
<span class="line-removed">- error:</span>
<span class="line-removed">-     xmlXPathReleaseObject(ctxt-&gt;context, obj);</span>
<span class="line-removed">-     ctxt-&gt;context-&gt;node = oldnode;</span>
<span class="line-removed">-     ctxt-&gt;context-&gt;doc = oldDoc;</span>
<span class="line-removed">-     ctxt-&gt;context-&gt;contextSize = oldcs;</span>
<span class="line-removed">-     ctxt-&gt;context-&gt;proximityPosition = oldpp;</span>
      }
      return(total);
  }
  #endif /* XP_OPTIMIZED_FILTER_FIRST */
  
  /**
<span class="line-new-header">--- 12890,34 ---</span>
      return (total);
      if (ctxt-&gt;value == NULL)
      return (total);
  
  #ifdef LIBXML_XPTR_ENABLED
<span class="line-modified">!         /*</span>
      * Hum are we filtering the result of an XPointer expression
<span class="line-modified">!         */</span>
      if (ctxt-&gt;value-&gt;type == XPATH_LOCATIONSET) {
<span class="line-modified">!         xmlLocationSetPtr locset = ctxt-&gt;value-&gt;user;</span>
  
<span class="line-modified">!         if (locset != NULL) {</span>
<span class="line-modified">!             xmlXPathLocationSetFilter(ctxt, locset, op-&gt;ch2, 1, 1);</span>
<span class="line-modified">!             if (locset-&gt;locNr &gt; 0)</span>
<span class="line-modified">!                 *first = (xmlNodePtr) locset-&gt;locTab[0]-&gt;user;</span>
      }
<span class="line-modified">! </span>
      return (total);
      }
  #endif /* LIBXML_XPTR_ENABLED */
  
      CHECK_TYPE0(XPATH_NODESET);
<span class="line-modified">!     set = ctxt-&gt;value-&gt;nodesetval;</span>
<span class="line-modified">!     if (set != NULL) {</span>
<span class="line-modified">!         xmlXPathNodeSetFilter(ctxt, set, op-&gt;ch2, 1, 1, 1);</span>
<span class="line-modified">!         if (set-&gt;nodeNr &gt; 0)</span>
<span class="line-modified">!             *first = set-&gt;nodeTab[0];</span>
      }
<span class="line-added">+ </span>
      return(total);
  }
  #endif /* XP_OPTIMIZED_FILTER_FIRST */
  
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13215,67 ***</span>
      int equal, ret;
      xmlXPathCompExprPtr comp;
      xmlXPathObjectPtr arg1, arg2;
  
      CHECK_ERROR0;
      comp = ctxt-&gt;comp;
      switch (op-&gt;op) {
          case XPATH_OP_END:
<span class="line-modified">!             return (0);</span>
          case XPATH_OP_AND:
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
              xmlXPathBooleanFunction(ctxt, 1);
              if ((ctxt-&gt;value == NULL) || (ctxt-&gt;value-&gt;boolval == 0))
<span class="line-modified">!                 return (total);</span>
              arg2 = valuePop(ctxt);
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
          if (ctxt-&gt;error) {
          xmlXPathFreeObject(arg2);
<span class="line-modified">!         return(0);</span>
          }
              xmlXPathBooleanFunction(ctxt, 1);
              if (ctxt-&gt;value != NULL)
                  ctxt-&gt;value-&gt;boolval &amp;= arg2-&gt;boolval;
          xmlXPathReleaseObject(ctxt-&gt;context, arg2);
<span class="line-modified">!             return (total);</span>
          case XPATH_OP_OR:
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
              xmlXPathBooleanFunction(ctxt, 1);
              if ((ctxt-&gt;value == NULL) || (ctxt-&gt;value-&gt;boolval == 1))
<span class="line-modified">!                 return (total);</span>
              arg2 = valuePop(ctxt);
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
          if (ctxt-&gt;error) {
          xmlXPathFreeObject(arg2);
<span class="line-modified">!         return(0);</span>
          }
              xmlXPathBooleanFunction(ctxt, 1);
              if (ctxt-&gt;value != NULL)
                  ctxt-&gt;value-&gt;boolval |= arg2-&gt;boolval;
          xmlXPathReleaseObject(ctxt-&gt;context, arg2);
<span class="line-modified">!             return (total);</span>
          case XPATH_OP_EQUAL:
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
          CHECK_ERROR0;
          if (op-&gt;value)
          equal = xmlXPathEqualValues(ctxt);
          else
          equal = xmlXPathNotEqualValues(ctxt);
          valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt-&gt;context, equal));
<span class="line-modified">!             return (total);</span>
          case XPATH_OP_CMP:
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
          CHECK_ERROR0;
              ret = xmlXPathCompareValues(ctxt, op-&gt;value, op-&gt;value2);
          valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt-&gt;context, ret));
<span class="line-modified">!             return (total);</span>
          case XPATH_OP_PLUS:
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
              if (op-&gt;ch2 != -1) {
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
<span class="line-new-header">--- 12935,72 ---</span>
      int equal, ret;
      xmlXPathCompExprPtr comp;
      xmlXPathObjectPtr arg1, arg2;
  
      CHECK_ERROR0;
<span class="line-added">+     if (OP_LIMIT_EXCEEDED(ctxt, 1))</span>
<span class="line-added">+         return(0);</span>
<span class="line-added">+     if (ctxt-&gt;context-&gt;depth &gt;= ctxt-&gt;context-&gt;maxDepth)</span>
<span class="line-added">+         XP_ERROR0(XPATH_RECURSION_LIMIT_EXCEEDED);</span>
<span class="line-added">+     ctxt-&gt;context-&gt;depth += 1;</span>
      comp = ctxt-&gt;comp;
      switch (op-&gt;op) {
          case XPATH_OP_END:
<span class="line-modified">!             break;</span>
          case XPATH_OP_AND:
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
              xmlXPathBooleanFunction(ctxt, 1);
              if ((ctxt-&gt;value == NULL) || (ctxt-&gt;value-&gt;boolval == 0))
<span class="line-modified">!                 break;</span>
              arg2 = valuePop(ctxt);
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
          if (ctxt-&gt;error) {
          xmlXPathFreeObject(arg2);
<span class="line-modified">!         break;</span>
          }
              xmlXPathBooleanFunction(ctxt, 1);
              if (ctxt-&gt;value != NULL)
                  ctxt-&gt;value-&gt;boolval &amp;= arg2-&gt;boolval;
          xmlXPathReleaseObject(ctxt-&gt;context, arg2);
<span class="line-modified">!             break;</span>
          case XPATH_OP_OR:
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
              xmlXPathBooleanFunction(ctxt, 1);
              if ((ctxt-&gt;value == NULL) || (ctxt-&gt;value-&gt;boolval == 1))
<span class="line-modified">!                 break;</span>
              arg2 = valuePop(ctxt);
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
          if (ctxt-&gt;error) {
          xmlXPathFreeObject(arg2);
<span class="line-modified">!         break;</span>
          }
              xmlXPathBooleanFunction(ctxt, 1);
              if (ctxt-&gt;value != NULL)
                  ctxt-&gt;value-&gt;boolval |= arg2-&gt;boolval;
          xmlXPathReleaseObject(ctxt-&gt;context, arg2);
<span class="line-modified">!             break;</span>
          case XPATH_OP_EQUAL:
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
          CHECK_ERROR0;
          if (op-&gt;value)
          equal = xmlXPathEqualValues(ctxt);
          else
          equal = xmlXPathNotEqualValues(ctxt);
          valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt-&gt;context, equal));
<span class="line-modified">!             break;</span>
          case XPATH_OP_CMP:
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
          CHECK_ERROR0;
              ret = xmlXPathCompareValues(ctxt, op-&gt;value, op-&gt;value2);
          valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt-&gt;context, ret));
<span class="line-modified">!             break;</span>
          case XPATH_OP_PLUS:
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
              if (op-&gt;ch2 != -1) {
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13289,11 ***</span>
                  xmlXPathValueFlipSign(ctxt);
              else if (op-&gt;value == 3) {
                  CAST_TO_NUMBER;
                  CHECK_TYPE0(XPATH_NUMBER);
              }
<span class="line-modified">!             return (total);</span>
          case XPATH_OP_MULT:
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
          CHECK_ERROR0;
<span class="line-new-header">--- 13014,11 ---</span>
                  xmlXPathValueFlipSign(ctxt);
              else if (op-&gt;value == 3) {
                  CAST_TO_NUMBER;
                  CHECK_TYPE0(XPATH_NUMBER);
              }
<span class="line-modified">!             break;</span>
          case XPATH_OP_MULT:
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
          CHECK_ERROR0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13301,11 ***</span>
                  xmlXPathMultValues(ctxt);
              else if (op-&gt;value == 1)
                  xmlXPathDivValues(ctxt);
              else if (op-&gt;value == 2)
                  xmlXPathModValues(ctxt);
<span class="line-modified">!             return (total);</span>
          case XPATH_OP_UNION:
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
          CHECK_ERROR0;
<span class="line-new-header">--- 13026,11 ---</span>
                  xmlXPathMultValues(ctxt);
              else if (op-&gt;value == 1)
                  xmlXPathDivValues(ctxt);
              else if (op-&gt;value == 2)
                  xmlXPathModValues(ctxt);
<span class="line-modified">!             break;</span>
          case XPATH_OP_UNION:
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
              total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
          CHECK_ERROR0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13316,50 ***</span>
                  (arg2 == NULL) || (arg2-&gt;type != XPATH_NODESET)) {
              xmlXPathReleaseObject(ctxt-&gt;context, arg1);
              xmlXPathReleaseObject(ctxt-&gt;context, arg2);
                  XP_ERROR0(XPATH_INVALID_TYPE);
              }
  
          if ((arg1-&gt;nodesetval == NULL) ||
          ((arg2-&gt;nodesetval != NULL) &amp;&amp;
           (arg2-&gt;nodesetval-&gt;nodeNr != 0)))
          {
          arg1-&gt;nodesetval = xmlXPathNodeSetMerge(arg1-&gt;nodesetval,
                              arg2-&gt;nodesetval);
          }
  
              valuePush(ctxt, arg1);
          xmlXPathReleaseObject(ctxt-&gt;context, arg2);
<span class="line-modified">!             return (total);</span>
          case XPATH_OP_ROOT:
              xmlXPathRoot(ctxt);
<span class="line-modified">!             return (total);</span>
          case XPATH_OP_NODE:
              if (op-&gt;ch1 != -1)
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
              if (op-&gt;ch2 != -1)
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
          CHECK_ERROR0;
          valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt-&gt;context,
          ctxt-&gt;context-&gt;node));
<span class="line-modified">!             return (total);</span>
          case XPATH_OP_COLLECT:{
                  if (op-&gt;ch1 == -1)
<span class="line-modified">!                     return (total);</span>
  
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
  
                  total += xmlXPathNodeCollectAndTest(ctxt, op, NULL, NULL, 0);
<span class="line-modified">!                 return (total);</span>
              }
          case XPATH_OP_VALUE:
              valuePush(ctxt,
                        xmlXPathCacheObjectCopy(ctxt-&gt;context,
              (xmlXPathObjectPtr) op-&gt;value4));
<span class="line-modified">!             return (total);</span>
          case XPATH_OP_VARIABLE:{
          xmlXPathObjectPtr val;
  
                  if (op-&gt;ch1 != -1)
                      total +=
<span class="line-new-header">--- 13041,62 ---</span>
                  (arg2 == NULL) || (arg2-&gt;type != XPATH_NODESET)) {
              xmlXPathReleaseObject(ctxt-&gt;context, arg1);
              xmlXPathReleaseObject(ctxt-&gt;context, arg2);
                  XP_ERROR0(XPATH_INVALID_TYPE);
              }
<span class="line-added">+             if ((ctxt-&gt;context-&gt;opLimit != 0) &amp;&amp;</span>
<span class="line-added">+                 (((arg1-&gt;nodesetval != NULL) &amp;&amp;</span>
<span class="line-added">+                   (xmlXPathCheckOpLimit(ctxt,</span>
<span class="line-added">+                                         arg1-&gt;nodesetval-&gt;nodeNr) &lt; 0)) ||</span>
<span class="line-added">+                  ((arg2-&gt;nodesetval != NULL) &amp;&amp;</span>
<span class="line-added">+                   (xmlXPathCheckOpLimit(ctxt,</span>
<span class="line-added">+                                         arg2-&gt;nodesetval-&gt;nodeNr) &lt; 0)))) {</span>
<span class="line-added">+             xmlXPathReleaseObject(ctxt-&gt;context, arg1);</span>
<span class="line-added">+             xmlXPathReleaseObject(ctxt-&gt;context, arg2);</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
  
          if ((arg1-&gt;nodesetval == NULL) ||
          ((arg2-&gt;nodesetval != NULL) &amp;&amp;
           (arg2-&gt;nodesetval-&gt;nodeNr != 0)))
          {
<span class="line-added">+                 /* TODO: Check memory error. */</span>
          arg1-&gt;nodesetval = xmlXPathNodeSetMerge(arg1-&gt;nodesetval,
                              arg2-&gt;nodesetval);
          }
  
              valuePush(ctxt, arg1);
          xmlXPathReleaseObject(ctxt-&gt;context, arg2);
<span class="line-modified">!             break;</span>
          case XPATH_OP_ROOT:
              xmlXPathRoot(ctxt);
<span class="line-modified">!             break;</span>
          case XPATH_OP_NODE:
              if (op-&gt;ch1 != -1)
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
              if (op-&gt;ch2 != -1)
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
          CHECK_ERROR0;
          valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt-&gt;context,
          ctxt-&gt;context-&gt;node));
<span class="line-modified">!             break;</span>
          case XPATH_OP_COLLECT:{
                  if (op-&gt;ch1 == -1)
<span class="line-modified">!                     break;</span>
  
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
  
                  total += xmlXPathNodeCollectAndTest(ctxt, op, NULL, NULL, 0);
<span class="line-modified">!                 break;</span>
              }
          case XPATH_OP_VALUE:
              valuePush(ctxt,
                        xmlXPathCacheObjectCopy(ctxt-&gt;context,
              (xmlXPathObjectPtr) op-&gt;value4));
<span class="line-modified">!             break;</span>
          case XPATH_OP_VARIABLE:{
          xmlXPathObjectPtr val;
  
                  if (op-&gt;ch1 != -1)
                      total +=
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13376,19 ***</span>
                      if (URI == NULL) {
                          xmlGenericError(xmlGenericErrorContext,
              &quot;xmlXPathCompOpEval: variable %s bound to undefined prefix %s\n&quot;,
                                      (char *) op-&gt;value4, (char *)op-&gt;value5);
                          ctxt-&gt;error = XPATH_UNDEF_PREFIX_ERROR;
<span class="line-modified">!                         return (total);</span>
                      }
              val = xmlXPathVariableLookupNS(ctxt-&gt;context,
                                                         op-&gt;value4, URI);
              if (val == NULL)
              XP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);
                      valuePush(ctxt, val);
                  }
<span class="line-modified">!                 return (total);</span>
              }
          case XPATH_OP_FUNCTION:{
                  xmlXPathFunction func;
                  const xmlChar *oldFunc, *oldFuncURI;
          int i;
<span class="line-new-header">--- 13113,19 ---</span>
                      if (URI == NULL) {
                          xmlGenericError(xmlGenericErrorContext,
              &quot;xmlXPathCompOpEval: variable %s bound to undefined prefix %s\n&quot;,
                                      (char *) op-&gt;value4, (char *)op-&gt;value5);
                          ctxt-&gt;error = XPATH_UNDEF_PREFIX_ERROR;
<span class="line-modified">!                         break;</span>
                      }
              val = xmlXPathVariableLookupNS(ctxt-&gt;context,
                                                         op-&gt;value4, URI);
              if (val == NULL)
              XP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);
                      valuePush(ctxt, val);
                  }
<span class="line-modified">!                 break;</span>
              }
          case XPATH_OP_FUNCTION:{
                  xmlXPathFunction func;
                  const xmlChar *oldFunc, *oldFuncURI;
          int i;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13398,27 ***</span>
                  if (op-&gt;ch1 != -1) {
                      total +=
                          xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
                      if (ctxt-&gt;error != XPATH_EXPRESSION_OK) {
                          xmlXPathPopFrame(ctxt, frame);
<span class="line-modified">!                         return (total);</span>
                      }
                  }
          if (ctxt-&gt;valueNr &lt; ctxt-&gt;valueFrame + op-&gt;value) {
              xmlGenericError(xmlGenericErrorContext,
                  &quot;xmlXPathCompOpEval: parameter error\n&quot;);
              ctxt-&gt;error = XPATH_INVALID_OPERAND;
                      xmlXPathPopFrame(ctxt, frame);
<span class="line-modified">!             return (total);</span>
          }
          for (i = 0; i &lt; op-&gt;value; i++) {
              if (ctxt-&gt;valueTab[(ctxt-&gt;valueNr - 1) - i] == NULL) {
              xmlGenericError(xmlGenericErrorContext,
                  &quot;xmlXPathCompOpEval: parameter error\n&quot;);
              ctxt-&gt;error = XPATH_INVALID_OPERAND;
                          xmlXPathPopFrame(ctxt, frame);
<span class="line-modified">!             return (total);</span>
              }
                  }
                  if (op-&gt;cache != NULL)
                      func = op-&gt;cache;
                  else {
<span class="line-new-header">--- 13135,27 ---</span>
                  if (op-&gt;ch1 != -1) {
                      total +=
                          xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
                      if (ctxt-&gt;error != XPATH_EXPRESSION_OK) {
                          xmlXPathPopFrame(ctxt, frame);
<span class="line-modified">!                         break;</span>
                      }
                  }
          if (ctxt-&gt;valueNr &lt; ctxt-&gt;valueFrame + op-&gt;value) {
              xmlGenericError(xmlGenericErrorContext,
                  &quot;xmlXPathCompOpEval: parameter error\n&quot;);
              ctxt-&gt;error = XPATH_INVALID_OPERAND;
                      xmlXPathPopFrame(ctxt, frame);
<span class="line-modified">!             break;</span>
          }
          for (i = 0; i &lt; op-&gt;value; i++) {
              if (ctxt-&gt;valueTab[(ctxt-&gt;valueNr - 1) - i] == NULL) {
              xmlGenericError(xmlGenericErrorContext,
                  &quot;xmlXPathCompOpEval: parameter error\n&quot;);
              ctxt-&gt;error = XPATH_INVALID_OPERAND;
                          xmlXPathPopFrame(ctxt, frame);
<span class="line-modified">!             break;</span>
              }
                  }
                  if (op-&gt;cache != NULL)
                      func = op-&gt;cache;
                  else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13434,11 ***</span>
                              xmlGenericError(xmlGenericErrorContext,
              &quot;xmlXPathCompOpEval: function %s bound to undefined prefix %s\n&quot;,
                                      (char *)op-&gt;value4, (char *)op-&gt;value5);
                              xmlXPathPopFrame(ctxt, frame);
                              ctxt-&gt;error = XPATH_UNDEF_PREFIX_ERROR;
<span class="line-modified">!                             return (total);</span>
                          }
                          func = xmlXPathFunctionLookupNS(ctxt-&gt;context,
                                                          op-&gt;value4, URI);
                      }
                      if (func == NULL) {
<span class="line-new-header">--- 13171,11 ---</span>
                              xmlGenericError(xmlGenericErrorContext,
              &quot;xmlXPathCompOpEval: function %s bound to undefined prefix %s\n&quot;,
                                      (char *)op-&gt;value4, (char *)op-&gt;value5);
                              xmlXPathPopFrame(ctxt, frame);
                              ctxt-&gt;error = XPATH_UNDEF_PREFIX_ERROR;
<span class="line-modified">!                             break;</span>
                          }
                          func = xmlXPathFunctionLookupNS(ctxt-&gt;context,
                                                          op-&gt;value4, URI);
                      }
                      if (func == NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13455,33 ***</span>
                  ctxt-&gt;context-&gt;function = op-&gt;value4;
                  ctxt-&gt;context-&gt;functionURI = op-&gt;cacheURI;
                  func(ctxt, op-&gt;value);
                  ctxt-&gt;context-&gt;function = oldFunc;
                  ctxt-&gt;context-&gt;functionURI = oldFuncURI;
                  xmlXPathPopFrame(ctxt, frame);
<span class="line-modified">!                 return (total);</span>
              }
          case XPATH_OP_ARG:
              if (op-&gt;ch1 != -1) {
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
              CHECK_ERROR0;
              }
              if (op-&gt;ch2 != -1) {
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
              CHECK_ERROR0;
          }
<span class="line-modified">!             return (total);</span>
          case XPATH_OP_PREDICATE:
          case XPATH_OP_FILTER:{
<span class="line-modified">!                 xmlXPathObjectPtr res;</span>
<span class="line-removed">-                 xmlXPathObjectPtr obj, tmp;</span>
<span class="line-removed">-                 xmlNodeSetPtr newset = NULL;</span>
<span class="line-removed">-                 xmlNodeSetPtr oldset;</span>
<span class="line-removed">-                 xmlNodePtr oldnode;</span>
<span class="line-removed">-         xmlDocPtr oldDoc;</span>
<span class="line-removed">-                 int oldcs, oldpp;</span>
<span class="line-removed">-                 int i;</span>
  
                  /*
                   * Optimization for ()[1] selection i.e. the first elem
                   */
                  if ((op-&gt;ch1 != -1) &amp;&amp; (op-&gt;ch2 != -1) &amp;&amp;
<span class="line-new-header">--- 13192,29 ---</span>
                  ctxt-&gt;context-&gt;function = op-&gt;value4;
                  ctxt-&gt;context-&gt;functionURI = op-&gt;cacheURI;
                  func(ctxt, op-&gt;value);
                  ctxt-&gt;context-&gt;function = oldFunc;
                  ctxt-&gt;context-&gt;functionURI = oldFuncURI;
<span class="line-added">+                 if ((ctxt-&gt;error == XPATH_EXPRESSION_OK) &amp;&amp;</span>
<span class="line-added">+                     (ctxt-&gt;valueNr != ctxt-&gt;valueFrame + 1))</span>
<span class="line-added">+                     XP_ERROR0(XPATH_STACK_ERROR);</span>
                  xmlXPathPopFrame(ctxt, frame);
<span class="line-modified">!                 break;</span>
              }
          case XPATH_OP_ARG:
              if (op-&gt;ch1 != -1) {
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
              CHECK_ERROR0;
              }
              if (op-&gt;ch2 != -1) {
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
              CHECK_ERROR0;
          }
<span class="line-modified">!             break;</span>
          case XPATH_OP_PREDICATE:
          case XPATH_OP_FILTER:{
<span class="line-modified">!                 xmlNodeSetPtr set;</span>
  
                  /*
                   * Optimization for ()[1] selection i.e. the first elem
                   */
                  if ((op-&gt;ch1 != -1) &amp;&amp; (op-&gt;ch2 != -1) &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13489,11 ***</span>
              /*
              * FILTER TODO: Can we assume that the inner processing
              *  will result in an ordered list if we have an
              *  XPATH_OP_FILTER?
              *  What about an additional field or flag on
<span class="line-modified">!             *  xmlXPathObject like @sorted ? This way we wouln&#39;d need</span>
              *  to assume anything, so it would be more robust and
              *  easier to optimize.
              */
                      ((comp-&gt;steps[op-&gt;ch1].op == XPATH_OP_SORT) || /* 18 */
               (comp-&gt;steps[op-&gt;ch1].op == XPATH_OP_FILTER)) &amp;&amp; /* 17 */
<span class="line-new-header">--- 13222,11 ---</span>
              /*
              * FILTER TODO: Can we assume that the inner processing
              *  will result in an ordered list if we have an
              *  XPATH_OP_FILTER?
              *  What about an additional field or flag on
<span class="line-modified">!             *  xmlXPathObject like @sorted ? This way we wouldn&#39;t need</span>
              *  to assume anything, so it would be more robust and
              *  easier to optimize.
              */
                      ((comp-&gt;steps[op-&gt;ch1].op == XPATH_OP_SORT) || /* 18 */
               (comp-&gt;steps[op-&gt;ch1].op == XPATH_OP_FILTER)) &amp;&amp; /* 17 */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13521,11 ***</span>
                              (ctxt-&gt;value-&gt;type == XPATH_NODESET) &amp;&amp;
                              (ctxt-&gt;value-&gt;nodesetval != NULL) &amp;&amp;
                              (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1))
                              xmlXPathNodeSetClearFromPos(ctxt-&gt;value-&gt;nodesetval,
                                                          1, 1);
<span class="line-modified">!                         return (total);</span>
                      }
                  }
                  /*
                   * Optimization for ()[last()] selection i.e. the last elem
                   */
<span class="line-new-header">--- 13254,11 ---</span>
                              (ctxt-&gt;value-&gt;type == XPATH_NODESET) &amp;&amp;
                              (ctxt-&gt;value-&gt;nodesetval != NULL) &amp;&amp;
                              (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1))
                              xmlXPathNodeSetClearFromPos(ctxt-&gt;value-&gt;nodesetval,
                                                          1, 1);
<span class="line-modified">!                         break;</span>
                      }
                  }
                  /*
                   * Optimization for ()[last()] selection i.e. the last elem
                   */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13556,11 ***</span>
                              (ctxt-&gt;value-&gt;type == XPATH_NODESET) &amp;&amp;
                              (ctxt-&gt;value-&gt;nodesetval != NULL) &amp;&amp;
                              (ctxt-&gt;value-&gt;nodesetval-&gt;nodeTab != NULL) &amp;&amp;
                              (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1))
                              xmlXPathNodeSetKeepLast(ctxt-&gt;value-&gt;nodesetval);
<span class="line-modified">!                         return (total);</span>
                      }
                  }
          /*
          * Process inner predicates first.
          * Example &quot;index[parent::book][1]&quot;:
<span class="line-new-header">--- 13289,11 ---</span>
                              (ctxt-&gt;value-&gt;type == XPATH_NODESET) &amp;&amp;
                              (ctxt-&gt;value-&gt;nodesetval != NULL) &amp;&amp;
                              (ctxt-&gt;value-&gt;nodesetval-&gt;nodeTab != NULL) &amp;&amp;
                              (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1))
                              xmlXPathNodeSetKeepLast(ctxt-&gt;value-&gt;nodesetval);
<span class="line-modified">!                         break;</span>
                      }
                  }
          /*
          * Process inner predicates first.
          * Example &quot;index[parent::book][1]&quot;:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13575,228 ***</span>
                  if (op-&gt;ch1 != -1)
                      total +=
                          xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
                  if (op-&gt;ch2 == -1)
<span class="line-modified">!                     return (total);</span>
                  if (ctxt-&gt;value == NULL)
<span class="line-modified">!                     return (total);</span>
  
  #ifdef LIBXML_XPTR_ENABLED
                  /*
                   * Hum are we filtering the result of an XPointer expression
                   */
                  if (ctxt-&gt;value-&gt;type == XPATH_LOCATIONSET) {
<span class="line-modified">!                     xmlLocationSetPtr newlocset = NULL;</span>
<span class="line-modified">!                     xmlLocationSetPtr oldlocset;</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     /*</span>
<span class="line-removed">-                      * Extract the old locset, and then evaluate the result of the</span>
<span class="line-removed">-                      * expression for all the element in the locset. use it to grow</span>
<span class="line-removed">-                      * up a new locset.</span>
<span class="line-removed">-                      */</span>
<span class="line-removed">-                     CHECK_TYPE0(XPATH_LOCATIONSET);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     if ((ctxt-&gt;value-&gt;user == NULL) ||</span>
<span class="line-removed">-                         (((xmlLocationSetPtr) ctxt-&gt;value-&gt;user)-&gt;locNr == 0))</span>
<span class="line-removed">-                         return (total);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     obj = valuePop(ctxt);</span>
<span class="line-removed">-                     oldlocset = obj-&gt;user;</span>
<span class="line-removed">-                     oldnode = ctxt-&gt;context-&gt;node;</span>
<span class="line-removed">-                     oldcs = ctxt-&gt;context-&gt;contextSize;</span>
<span class="line-removed">-                     oldpp = ctxt-&gt;context-&gt;proximityPosition;</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     newlocset = xmlXPtrLocationSetCreate(NULL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     for (i = 0; i &lt; oldlocset-&gt;locNr; i++) {</span>
<span class="line-removed">-                         /*</span>
<span class="line-removed">-                          * Run the evaluation with a node list made of a</span>
<span class="line-removed">-                          * single item in the nodelocset.</span>
<span class="line-removed">-                          */</span>
<span class="line-removed">-                         ctxt-&gt;context-&gt;node = oldlocset-&gt;locTab[i]-&gt;user;</span>
<span class="line-removed">-                         ctxt-&gt;context-&gt;contextSize = oldlocset-&gt;locNr;</span>
<span class="line-removed">-                         ctxt-&gt;context-&gt;proximityPosition = i + 1;</span>
<span class="line-removed">-             tmp = xmlXPathCacheNewNodeSet(ctxt-&gt;context,</span>
<span class="line-removed">-                 ctxt-&gt;context-&gt;node);</span>
<span class="line-removed">-                         valuePush(ctxt, tmp);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                         if (op-&gt;ch2 != -1)</span>
<span class="line-removed">-                             total +=</span>
<span class="line-removed">-                                 xmlXPathCompOpEval(ctxt,</span>
<span class="line-removed">-                                                    &amp;comp-&gt;steps[op-&gt;ch2]);</span>
<span class="line-removed">-             if (ctxt-&gt;error != XPATH_EXPRESSION_OK) {</span>
<span class="line-removed">-                             xmlXPtrFreeLocationSet(newlocset);</span>
<span class="line-removed">-                             goto filter_xptr_error;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                         /*</span>
<span class="line-removed">-                          * The result of the evaluation need to be tested to</span>
<span class="line-removed">-                          * decided whether the filter succeeded or not</span>
<span class="line-removed">-                          */</span>
<span class="line-removed">-                         res = valuePop(ctxt);</span>
<span class="line-removed">-                         if (xmlXPathEvaluatePredicateResult(ctxt, res)) {</span>
<span class="line-removed">-                             xmlXPtrLocationSetAdd(newlocset,</span>
<span class="line-removed">-                                                   xmlXPathObjectCopy</span>
<span class="line-removed">-                                                   (oldlocset-&gt;locTab[i]));</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                         /*</span>
<span class="line-removed">-                          * Cleanup</span>
<span class="line-removed">-                          */</span>
<span class="line-removed">-                         if (res != NULL) {</span>
<span class="line-removed">-                 xmlXPathReleaseObject(ctxt-&gt;context, res);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-                         if (ctxt-&gt;value == tmp) {</span>
<span class="line-removed">-                             res = valuePop(ctxt);</span>
<span class="line-removed">-                 xmlXPathReleaseObject(ctxt-&gt;context, res);</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     /*</span>
<span class="line-removed">-                      * The result is used as the new evaluation locset.</span>
<span class="line-removed">-                      */</span>
<span class="line-removed">-                     valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));</span>
<span class="line-removed">- filter_xptr_error:</span>
<span class="line-removed">-             xmlXPathReleaseObject(ctxt-&gt;context, obj);</span>
<span class="line-removed">-                     ctxt-&gt;context-&gt;node = oldnode;</span>
<span class="line-removed">-                     ctxt-&gt;context-&gt;contextSize = oldcs;</span>
<span class="line-removed">-                     ctxt-&gt;context-&gt;proximityPosition = oldpp;</span>
<span class="line-removed">-                     return (total);</span>
                  }
  #endif /* LIBXML_XPTR_ENABLED */
  
<span class="line-removed">-                 /*</span>
<span class="line-removed">-                  * Extract the old set, and then evaluate the result of the</span>
<span class="line-removed">-                  * expression for all the element in the set. use it to grow</span>
<span class="line-removed">-                  * up a new set.</span>
<span class="line-removed">-                  */</span>
                  CHECK_TYPE0(XPATH_NODESET);
<span class="line-modified">! </span>
<span class="line-modified">!                 if ((ctxt-&gt;value-&gt;nodesetval != NULL) &amp;&amp;</span>
<span class="line-modified">!                     (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr != 0)) {</span>
<span class="line-modified">!                     obj = valuePop(ctxt);</span>
<span class="line-modified">!                     oldset = obj-&gt;nodesetval;</span>
<span class="line-removed">-                     oldnode = ctxt-&gt;context-&gt;node;</span>
<span class="line-removed">-                     oldDoc = ctxt-&gt;context-&gt;doc;</span>
<span class="line-removed">-                     oldcs = ctxt-&gt;context-&gt;contextSize;</span>
<span class="line-removed">-                     oldpp = ctxt-&gt;context-&gt;proximityPosition;</span>
<span class="line-removed">-             tmp = NULL;</span>
<span class="line-removed">-                     /*</span>
<span class="line-removed">-                      * Initialize the new set.</span>
<span class="line-removed">-              * Also set the xpath document in case things like</span>
<span class="line-removed">-              * key() evaluation are attempted on the predicate</span>
<span class="line-removed">-                      */</span>
<span class="line-removed">-                     newset = xmlXPathNodeSetCreate(NULL);</span>
<span class="line-removed">-             /*</span>
<span class="line-removed">-             * SPEC XPath 1.0:</span>
<span class="line-removed">-             *  &quot;For each node in the node-set to be filtered, the</span>
<span class="line-removed">-             *  PredicateExpr is evaluated with that node as the</span>
<span class="line-removed">-             *  context node, with the number of nodes in the</span>
<span class="line-removed">-             *  node-set as the context size, and with the proximity</span>
<span class="line-removed">-             *  position of the node in the node-set with respect to</span>
<span class="line-removed">-             *  the axis as the context position;&quot;</span>
<span class="line-removed">-             * @oldset is the node-set&quot; to be filtered.</span>
<span class="line-removed">-             *</span>
<span class="line-removed">-             * SPEC XPath 1.0:</span>
<span class="line-removed">-             *  &quot;only predicates change the context position and</span>
<span class="line-removed">-             *  context size (see [2.4 Predicates]).&quot;</span>
<span class="line-removed">-             * Example:</span>
<span class="line-removed">-             *   node-set  context pos</span>
<span class="line-removed">-             *    nA         1</span>
<span class="line-removed">-             *    nB         2</span>
<span class="line-removed">-             *    nC         3</span>
<span class="line-removed">-             *   After applying predicate [position() &gt; 1] :</span>
<span class="line-removed">-             *   node-set  context pos</span>
<span class="line-removed">-             *    nB         1</span>
<span class="line-removed">-             *    nC         2</span>
<span class="line-removed">-             *</span>
<span class="line-removed">-             * removed the first node in the node-set, then</span>
<span class="line-removed">-             * the context position of the</span>
<span class="line-removed">-             */</span>
<span class="line-removed">-                     for (i = 0; i &lt; oldset-&gt;nodeNr; i++) {</span>
<span class="line-removed">-                         /*</span>
<span class="line-removed">-                          * Run the evaluation with a node list made of</span>
<span class="line-removed">-                          * a single item in the nodeset.</span>
<span class="line-removed">-                          */</span>
<span class="line-removed">-                         ctxt-&gt;context-&gt;node = oldset-&gt;nodeTab[i];</span>
<span class="line-removed">-             if ((oldset-&gt;nodeTab[i]-&gt;type != XML_NAMESPACE_DECL) &amp;&amp;</span>
<span class="line-removed">-                 (oldset-&gt;nodeTab[i]-&gt;doc != NULL))</span>
<span class="line-removed">-                     ctxt-&gt;context-&gt;doc = oldset-&gt;nodeTab[i]-&gt;doc;</span>
<span class="line-removed">-             if (tmp == NULL) {</span>
<span class="line-removed">-                 tmp = xmlXPathCacheNewNodeSet(ctxt-&gt;context,</span>
<span class="line-removed">-                 ctxt-&gt;context-&gt;node);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 if (xmlXPathNodeSetAddUnique(tmp-&gt;nodesetval,</span>
<span class="line-removed">-                                ctxt-&gt;context-&gt;node) &lt; 0) {</span>
<span class="line-removed">-                 ctxt-&gt;error = XPATH_MEMORY_ERROR;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-                         valuePush(ctxt, tmp);</span>
<span class="line-removed">-                         ctxt-&gt;context-&gt;contextSize = oldset-&gt;nodeNr;</span>
<span class="line-removed">-                         ctxt-&gt;context-&gt;proximityPosition = i + 1;</span>
<span class="line-removed">-             /*</span>
<span class="line-removed">-             * Evaluate the predicate against the context node.</span>
<span class="line-removed">-             * Can/should we optimize position() predicates</span>
<span class="line-removed">-             * here (e.g. &quot;[1]&quot;)?</span>
<span class="line-removed">-             */</span>
<span class="line-removed">-                         if (op-&gt;ch2 != -1)</span>
<span class="line-removed">-                             total +=</span>
<span class="line-removed">-                                 xmlXPathCompOpEval(ctxt,</span>
<span class="line-removed">-                                                    &amp;comp-&gt;steps[op-&gt;ch2]);</span>
<span class="line-removed">-             if (ctxt-&gt;error != XPATH_EXPRESSION_OK) {</span>
<span class="line-removed">-                 xmlXPathFreeNodeSet(newset);</span>
<span class="line-removed">-                             goto filter_error;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                         /*</span>
<span class="line-removed">-                          * The result of the evaluation needs to be tested to</span>
<span class="line-removed">-                          * decide whether the filter succeeded or not</span>
<span class="line-removed">-                          */</span>
<span class="line-removed">-             /*</span>
<span class="line-removed">-             * OPTIMIZE TODO: Can we use</span>
<span class="line-removed">-             * xmlXPathNodeSetAdd*Unique()* instead?</span>
<span class="line-removed">-             */</span>
<span class="line-removed">-                         res = valuePop(ctxt);</span>
<span class="line-removed">-                         if (xmlXPathEvaluatePredicateResult(ctxt, res)) {</span>
<span class="line-removed">-                             if (xmlXPathNodeSetAdd(newset, oldset-&gt;nodeTab[i])</span>
<span class="line-removed">-                     &lt; 0)</span>
<span class="line-removed">-                 ctxt-&gt;error = XPATH_MEMORY_ERROR;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                         /*</span>
<span class="line-removed">-                          * Cleanup</span>
<span class="line-removed">-                          */</span>
<span class="line-removed">-                         if (res != NULL) {</span>
<span class="line-removed">-                 xmlXPathReleaseObject(ctxt-&gt;context, res);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-                         if (ctxt-&gt;value == tmp) {</span>
<span class="line-removed">-                             valuePop(ctxt);</span>
<span class="line-removed">-                 xmlXPathNodeSetClear(tmp-&gt;nodesetval, 1);</span>
<span class="line-removed">-                 /*</span>
<span class="line-removed">-                 * Don&#39;t free the temporary nodeset</span>
<span class="line-removed">-                 * in order to avoid massive recreation inside this</span>
<span class="line-removed">-                 * loop.</span>
<span class="line-removed">-                 */</span>
<span class="line-removed">-                         } else</span>
<span class="line-removed">-                 tmp = NULL;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-             if (tmp != NULL)</span>
<span class="line-removed">-             xmlXPathReleaseObject(ctxt-&gt;context, tmp);</span>
<span class="line-removed">-                     /*</span>
<span class="line-removed">-                      * The result is used as the new evaluation set.</span>
<span class="line-removed">-                      */</span>
<span class="line-removed">-             valuePush(ctxt,</span>
<span class="line-removed">-             xmlXPathCacheWrapNodeSet(ctxt-&gt;context, newset));</span>
<span class="line-removed">- filter_error:</span>
<span class="line-removed">-             xmlXPathReleaseObject(ctxt-&gt;context, obj);</span>
<span class="line-removed">-             ctxt-&gt;context-&gt;node = oldnode;</span>
<span class="line-removed">-             ctxt-&gt;context-&gt;doc = oldDoc;</span>
<span class="line-removed">-                     ctxt-&gt;context-&gt;contextSize = oldcs;</span>
<span class="line-removed">-                     ctxt-&gt;context-&gt;proximityPosition = oldpp;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 return (total);</span>
              }
          case XPATH_OP_SORT:
              if (op-&gt;ch1 != -1)
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
<span class="line-new-header">--- 13308,32 ---</span>
                  if (op-&gt;ch1 != -1)
                      total +=
                          xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
                  if (op-&gt;ch2 == -1)
<span class="line-modified">!                     break;</span>
                  if (ctxt-&gt;value == NULL)
<span class="line-modified">!                     break;</span>
  
  #ifdef LIBXML_XPTR_ENABLED
                  /*
                   * Hum are we filtering the result of an XPointer expression
                   */
                  if (ctxt-&gt;value-&gt;type == XPATH_LOCATIONSET) {
<span class="line-modified">!                     xmlLocationSetPtr locset = ctxt-&gt;value-&gt;user;</span>
<span class="line-modified">!                     xmlXPathLocationSetFilter(ctxt, locset, op-&gt;ch2,</span>
<span class="line-modified">!                                               1, locset-&gt;locNr);</span>
<span class="line-modified">!                     break;</span>
                  }
  #endif /* LIBXML_XPTR_ENABLED */
  
                  CHECK_TYPE0(XPATH_NODESET);
<span class="line-modified">!                 set = ctxt-&gt;value-&gt;nodesetval;</span>
<span class="line-modified">!                 if (set != NULL)</span>
<span class="line-modified">!                     xmlXPathNodeSetFilter(ctxt, set, op-&gt;ch2,</span>
<span class="line-modified">!                                           1, set-&gt;nodeNr, 1);</span>
<span class="line-modified">!                 break;</span>
              }
          case XPATH_OP_SORT:
              if (op-&gt;ch1 != -1)
                  total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
          CHECK_ERROR0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13805,11 ***</span>
                  (ctxt-&gt;value-&gt;nodesetval != NULL) &amp;&amp;
          (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1))
          {
                  xmlXPathNodeSetSort(ctxt-&gt;value-&gt;nodesetval);
          }
<span class="line-modified">!             return (total);</span>
  #ifdef LIBXML_XPTR_ENABLED
          case XPATH_OP_RANGETO:{
                  xmlXPathObjectPtr range;
                  xmlXPathObjectPtr res, obj;
                  xmlXPathObjectPtr tmp;
<span class="line-new-header">--- 13342,11 ---</span>
                  (ctxt-&gt;value-&gt;nodesetval != NULL) &amp;&amp;
          (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1))
          {
                  xmlXPathNodeSetSort(ctxt-&gt;value-&gt;nodesetval);
          }
<span class="line-modified">!             break;</span>
  #ifdef LIBXML_XPTR_ENABLED
          case XPATH_OP_RANGETO:{
                  xmlXPathObjectPtr range;
                  xmlXPathObjectPtr res, obj;
                  xmlXPathObjectPtr tmp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13828,11 ***</span>
                  }
                  if (ctxt-&gt;value == NULL) {
                      XP_ERROR0(XPATH_INVALID_OPERAND);
                  }
                  if (op-&gt;ch2 == -1)
<span class="line-modified">!                     return (total);</span>
  
                  if (ctxt-&gt;value-&gt;type == XPATH_LOCATIONSET) {
                      /*
                       * Extract the old locset, and then evaluate the result of the
                       * expression for all the element in the locset. use it to grow
<span class="line-new-header">--- 13365,11 ---</span>
                  }
                  if (ctxt-&gt;value == NULL) {
                      XP_ERROR0(XPATH_INVALID_OPERAND);
                  }
                  if (op-&gt;ch2 == -1)
<span class="line-modified">!                     break;</span>
  
                  if (ctxt-&gt;value-&gt;type == XPATH_LOCATIONSET) {
                      /*
                       * Extract the old locset, and then evaluate the result of the
                       * expression for all the element in the locset. use it to grow
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13840,11 ***</span>
                       */
                      CHECK_TYPE0(XPATH_LOCATIONSET);
  
                      if ((ctxt-&gt;value-&gt;user == NULL) ||
                          (((xmlLocationSetPtr) ctxt-&gt;value-&gt;user)-&gt;locNr == 0))
<span class="line-modified">!                         return (total);</span>
  
                      obj = valuePop(ctxt);
                      oldlocset = obj-&gt;user;
  
                      newlocset = xmlXPtrLocationSetCreate(NULL);
<span class="line-new-header">--- 13377,11 ---</span>
                       */
                      CHECK_TYPE0(XPATH_LOCATIONSET);
  
                      if ((ctxt-&gt;value-&gt;user == NULL) ||
                          (((xmlLocationSetPtr) ctxt-&gt;value-&gt;user)-&gt;locNr == 0))
<span class="line-modified">!                         break;</span>
  
                      obj = valuePop(ctxt);
                      oldlocset = obj-&gt;user;
  
                      newlocset = xmlXPtrLocationSetCreate(NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13962,17 ***</span>
  rangeto_error:
          xmlXPathReleaseObject(ctxt-&gt;context, obj);
                  ctxt-&gt;context-&gt;node = oldnode;
                  ctxt-&gt;context-&gt;contextSize = oldcs;
                  ctxt-&gt;context-&gt;proximityPosition = oldpp;
<span class="line-modified">!                 return (total);</span>
              }
  #endif /* LIBXML_XPTR_ENABLED */
<span class="line-modified">!     }</span>
      xmlGenericError(xmlGenericErrorContext,
                      &quot;XPath: unknown precompiled operation %d\n&quot;, op-&gt;op);
      ctxt-&gt;error = XPATH_INVALID_OPERAND;
      return (total);
  }
  
  /**
   * xmlXPathCompOpEvalToBoolean:
<span class="line-new-header">--- 13499,21 ---</span>
  rangeto_error:
          xmlXPathReleaseObject(ctxt-&gt;context, obj);
                  ctxt-&gt;context-&gt;node = oldnode;
                  ctxt-&gt;context-&gt;contextSize = oldcs;
                  ctxt-&gt;context-&gt;proximityPosition = oldpp;
<span class="line-modified">!                 break;</span>
              }
  #endif /* LIBXML_XPTR_ENABLED */
<span class="line-modified">!         default:</span>
      xmlGenericError(xmlGenericErrorContext,
                      &quot;XPath: unknown precompiled operation %d\n&quot;, op-&gt;op);
      ctxt-&gt;error = XPATH_INVALID_OPERAND;
<span class="line-added">+             break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     ctxt-&gt;context-&gt;depth -= 1;</span>
      return (total);
  }
  
  /**
   * xmlXPathCompOpEvalToBoolean:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13988,10 ***</span>
<span class="line-new-header">--- 13529,12 ---</span>
                  int isPredicate)
  {
      xmlXPathObjectPtr resObj = NULL;
  
  start:
<span class="line-added">+     if (OP_LIMIT_EXCEEDED(ctxt, 1))</span>
<span class="line-added">+         return(0);</span>
      /* comp = ctxt-&gt;comp; */
      switch (op-&gt;op) {
          case XPATH_OP_END:
              return (0);
      case XPATH_OP_VALUE:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14114,16 ***</span>
<span class="line-new-header">--- 13657,18 ---</span>
      if (min_depth == 0) {
      if (from_root) {
          /* Select &quot;/&quot; */
          if (toBool)
          return(1);
<span class="line-added">+             /* TODO: Check memory error. */</span>
          xmlXPathNodeSetAddUnique((*resultSeq)-&gt;nodesetval,
                               (xmlNodePtr) ctxt-&gt;doc);
      } else {
          /* Select &quot;self::node()&quot; */
          if (toBool)
          return(1);
<span class="line-added">+             /* TODO: Check memory error. */</span>
          xmlXPathNodeSetAddUnique((*resultSeq)-&gt;nodesetval, ctxt-&gt;node);
      }
      }
      if (max_depth == 0) {
      return(0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14180,17 ***</span>
<span class="line-new-header">--- 13725,28 ---</span>
      ret = xmlStreamPush(patstream, NULL, NULL);
      if (ret &lt; 0) {
      } else if (ret == 1) {
          if (toBool)
          goto return_1;
<span class="line-added">+             /* TODO: Check memory error. */</span>
          xmlXPathNodeSetAddUnique((*resultSeq)-&gt;nodesetval, cur);
      }
      }
      depth = 0;
      goto scan_children;
  next_node:
      do {
<span class="line-added">+         if (ctxt-&gt;opLimit != 0) {</span>
<span class="line-added">+             if (ctxt-&gt;opCount &gt;= ctxt-&gt;opLimit) {</span>
<span class="line-added">+                 xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-added">+                         &quot;XPath operation limit exceeded\n&quot;);</span>
<span class="line-added">+                 xmlFreeStreamCtxt(patstream);</span>
<span class="line-added">+                 return(-1);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             ctxt-&gt;opCount++;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          nb_nodes++;
  
      switch (cur-&gt;type) {
          case XML_ELEMENT_NODE:
          case XML_TEXT_NODE:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14310,10 ***</span>
<span class="line-new-header">--- 13866,12 ---</span>
      xmlXPathCompExprPtr comp;
  
      if ((ctxt == NULL) || (ctxt-&gt;comp == NULL))
      return(-1);
  
<span class="line-added">+     ctxt-&gt;context-&gt;depth = 0;</span>
<span class="line-added">+ </span>
      if (ctxt-&gt;valueTab == NULL) {
      /* Allocate the value stack */
      ctxt-&gt;valueTab = (xmlXPathObjectPtr *)
               xmlMalloc(10 * sizeof(xmlXPathObjectPtr));
      if (ctxt-&gt;valueTab == NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14496,11 ***</span>
          (!xmlStrchr(str, &#39;@&#39;))) {
      const xmlChar *tmp;
  
      /*
       * We don&#39;t try to handle expressions using the verbose axis
<span class="line-modified">!      * specifiers (&quot;::&quot;), just the simplied form at this point.</span>
       * Additionally, if there is no list of namespaces available and
       *  there&#39;s a &quot;:&quot; in the expression, indicating a prefixed QName,
       *  then we won&#39;t try to compile either. xmlPatterncompile() needs
       *  to have a list of namespaces at compilation time in order to
       *  compile prefixed name tests.
<span class="line-new-header">--- 14054,11 ---</span>
          (!xmlStrchr(str, &#39;@&#39;))) {
      const xmlChar *tmp;
  
      /*
       * We don&#39;t try to handle expressions using the verbose axis
<span class="line-modified">!      * specifiers (&quot;::&quot;), just the simplified form at this point.</span>
       * Additionally, if there is no list of namespaces available and
       *  there&#39;s a &quot;:&quot; in the expression, indicating a prefixed QName,
       *  then we won&#39;t try to compile either. xmlPatterncompile() needs
       *  to have a list of namespaces at compilation time in order to
       *  compile prefixed name tests.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14550,12 ***</span>
      return(NULL);
  }
  #endif /* XPATH_STREAMING */
  
  static void
<span class="line-modified">! xmlXPathOptimizeExpression(xmlXPathCompExprPtr comp, xmlXPathStepOpPtr op)</span>
  {
      /*
      * Try to rewrite &quot;descendant-or-self::node()/foo&quot; to an optimized
      * internal representation.
      */
  
<span class="line-new-header">--- 14108,16 ---</span>
      return(NULL);
  }
  #endif /* XPATH_STREAMING */
  
  static void
<span class="line-modified">! xmlXPathOptimizeExpression(xmlXPathParserContextPtr pctxt,</span>
<span class="line-added">+                            xmlXPathStepOpPtr op)</span>
  {
<span class="line-added">+     xmlXPathCompExprPtr comp = pctxt-&gt;comp;</span>
<span class="line-added">+     xmlXPathContextPtr ctxt;</span>
<span class="line-added">+ </span>
      /*
      * Try to rewrite &quot;descendant-or-self::node()/foo&quot; to an optimized
      * internal representation.
      */
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14607,14 ***</span>
      /* OP_VALUE has invalid ch1. */
      if (op-&gt;op == XPATH_OP_VALUE)
          return;
  
      /* Recurse */
      if (op-&gt;ch1 != -1)
<span class="line-modified">!         xmlXPathOptimizeExpression(comp, &amp;comp-&gt;steps[op-&gt;ch1]);</span>
      if (op-&gt;ch2 != -1)
<span class="line-modified">!     xmlXPathOptimizeExpression(comp, &amp;comp-&gt;steps[op-&gt;ch2]);</span>
  }
  
  /**
   * xmlXPathCtxtCompile:
   * @ctxt: an XPath context
<span class="line-new-header">--- 14169,22 ---</span>
      /* OP_VALUE has invalid ch1. */
      if (op-&gt;op == XPATH_OP_VALUE)
          return;
  
      /* Recurse */
<span class="line-added">+     ctxt = pctxt-&gt;context;</span>
<span class="line-added">+     if (ctxt != NULL) {</span>
<span class="line-added">+         if (ctxt-&gt;depth &gt;= ctxt-&gt;maxDepth)</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         ctxt-&gt;depth += 1;</span>
<span class="line-added">+     }</span>
      if (op-&gt;ch1 != -1)
<span class="line-modified">!         xmlXPathOptimizeExpression(pctxt, &amp;comp-&gt;steps[op-&gt;ch1]);</span>
      if (op-&gt;ch2 != -1)
<span class="line-modified">!     xmlXPathOptimizeExpression(pctxt, &amp;comp-&gt;steps[op-&gt;ch2]);</span>
<span class="line-added">+     if (ctxt != NULL)</span>
<span class="line-added">+         ctxt-&gt;depth -= 1;</span>
  }
  
  /**
   * xmlXPathCtxtCompile:
   * @ctxt: an XPath context
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14639,10 ***</span>
<span class="line-new-header">--- 14209,12 ---</span>
      xmlXPathInit();
  
      pctxt = xmlXPathNewParserContext(str, ctxt);
      if (pctxt == NULL)
          return NULL;
<span class="line-added">+     if (ctxt != NULL)</span>
<span class="line-added">+         ctxt-&gt;depth = 0;</span>
      xmlXPathCompileExpr(pctxt, 1);
  
      if( pctxt-&gt;error != XPATH_EXPRESSION_OK )
      {
          xmlXPathFreeParserContext(pctxt);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14658,23 ***</span>
       */
      xmlXPatherror(pctxt, __FILE__, __LINE__, XPATH_EXPR_ERROR);
      comp = NULL;
      } else {
      comp = pctxt-&gt;comp;
      pctxt-&gt;comp = NULL;
      }
      xmlXPathFreeParserContext(pctxt);
  
      if (comp != NULL) {
      comp-&gt;expr = xmlStrdup(str);
  #ifdef DEBUG_EVAL_COUNTS
      comp-&gt;string = xmlStrdup(str);
      comp-&gt;nb = 0;
  #endif
<span class="line-removed">-     if ((comp-&gt;nbStep &gt; 1) &amp;&amp; (comp-&gt;last &gt;= 0)) {</span>
<span class="line-removed">-         xmlXPathOptimizeExpression(comp, &amp;comp-&gt;steps[comp-&gt;last]);</span>
<span class="line-removed">-     }</span>
      }
      return(comp);
  }
  
  /**
<span class="line-new-header">--- 14230,25 ---</span>
       */
      xmlXPatherror(pctxt, __FILE__, __LINE__, XPATH_EXPR_ERROR);
      comp = NULL;
      } else {
      comp = pctxt-&gt;comp;
<span class="line-added">+     if ((comp-&gt;nbStep &gt; 1) &amp;&amp; (comp-&gt;last &gt;= 0)) {</span>
<span class="line-added">+             if (ctxt != NULL)</span>
<span class="line-added">+                 ctxt-&gt;depth = 0;</span>
<span class="line-added">+         xmlXPathOptimizeExpression(pctxt, &amp;comp-&gt;steps[comp-&gt;last]);</span>
<span class="line-added">+     }</span>
      pctxt-&gt;comp = NULL;
      }
      xmlXPathFreeParserContext(pctxt);
  
      if (comp != NULL) {
      comp-&gt;expr = xmlStrdup(str);
  #ifdef DEBUG_EVAL_COUNTS
      comp-&gt;string = xmlStrdup(str);
      comp-&gt;nb = 0;
  #endif
      }
      return(comp);
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14827,21 ***</span>
          xmlXPathFreeCompExpr(ctxt-&gt;comp);
          ctxt-&gt;comp = comp;
      } else
  #endif
      {
      xmlXPathCompileExpr(ctxt, 1);
          CHECK_ERROR;
  
          /* Check for trailing characters. */
          if (*ctxt-&gt;cur != 0)
              XP_ERROR(XPATH_EXPR_ERROR);
  
<span class="line-modified">!     if ((ctxt-&gt;comp-&gt;nbStep &gt; 1) &amp;&amp; (ctxt-&gt;comp-&gt;last &gt;= 0))</span>
<span class="line-modified">!         xmlXPathOptimizeExpression(ctxt-&gt;comp,</span>
          &amp;ctxt-&gt;comp-&gt;steps[ctxt-&gt;comp-&gt;last]);
      }
  
      xmlXPathRunEval(ctxt, 0);
  }
  
  /**
<span class="line-new-header">--- 14401,26 ---</span>
          xmlXPathFreeCompExpr(ctxt-&gt;comp);
          ctxt-&gt;comp = comp;
      } else
  #endif
      {
<span class="line-added">+         if (ctxt-&gt;context != NULL)</span>
<span class="line-added">+             ctxt-&gt;context-&gt;depth = 0;</span>
      xmlXPathCompileExpr(ctxt, 1);
          CHECK_ERROR;
  
          /* Check for trailing characters. */
          if (*ctxt-&gt;cur != 0)
              XP_ERROR(XPATH_EXPR_ERROR);
  
<span class="line-modified">!     if ((ctxt-&gt;comp-&gt;nbStep &gt; 1) &amp;&amp; (ctxt-&gt;comp-&gt;last &gt;= 0)) {</span>
<span class="line-modified">!             if (ctxt-&gt;context != NULL)</span>
<span class="line-added">+                 ctxt-&gt;context-&gt;depth = 0;</span>
<span class="line-added">+         xmlXPathOptimizeExpression(ctxt,</span>
          &amp;ctxt-&gt;comp-&gt;steps[ctxt-&gt;comp-&gt;last]);
      }
<span class="line-added">+     }</span>
  
      xmlXPathRunEval(ctxt, 0);
  }
  
  /**
</pre>
<center><a href="xmlwriter.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="xzlib.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
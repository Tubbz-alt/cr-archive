<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/xmlIO.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="xml2Conf.sh.in.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="xmlreader.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/xmlIO.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 168     &quot;No such device or address&quot;,/* ENXIO */
 169     &quot;Operation not permitted&quot;,  /* EPERM */
 170     &quot;Broken pipe&quot;,      /* EPIPE */
 171     &quot;Result too large&quot;,     /* ERANGE */
 172     &quot;Read-only file system&quot;,    /* EROFS */
 173     &quot;Invalid seek&quot;,     /* ESPIPE */
 174     &quot;No such process&quot;,      /* ESRCH */
 175     &quot;Operation timed out&quot;,  /* ETIMEDOUT */
 176     &quot;Improper link&quot;,        /* EXDEV */
 177     &quot;Attempt to load network entity %s&quot;, /* XML_IO_NETWORK_ATTEMPT */
 178     &quot;encoder error&quot;,        /* XML_IO_ENCODER */
 179     &quot;flush error&quot;,
 180     &quot;write error&quot;,
 181     &quot;no input&quot;,
 182     &quot;buffer full&quot;,
 183     &quot;loading error&quot;,
 184     &quot;not a socket&quot;,     /* ENOTSOCK */
 185     &quot;already connected&quot;,    /* EISCONN */
 186     &quot;connection refused&quot;,   /* ECONNREFUSED */
 187     &quot;unreachable network&quot;,  /* ENETUNREACH */
<span class="line-modified"> 188     &quot;adddress in use&quot;,      /* EADDRINUSE */</span>
 189     &quot;already in use&quot;,       /* EALREADY */
<span class="line-modified"> 190     &quot;unknown address familly&quot;,  /* EAFNOSUPPORT */</span>
 191 };
 192 
 193 #if defined(_WIN32) || defined (__DJGPP__) &amp;&amp; !defined (__CYGWIN__)
 194 /**
 195  * __xmlIOWin32UTF8ToWChar:
 196  * @u8String:  uft-8 string
 197  *
 198  * Convert a string from utf-8 to wchar (WINDOWS ONLY!)
 199  */
 200 static wchar_t *
 201 __xmlIOWin32UTF8ToWChar(const char *u8String)
 202 {
 203     wchar_t *wString = NULL;
 204 
 205     if (u8String) {
 206         int wLen =
 207             MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, u8String,
 208                                 -1, NULL, 0);
 209         if (wLen) {
 210             wString = xmlMalloc(wLen * sizeof(wchar_t));
</pre>
<hr />
<pre>
2366     ret = (xmlOutputBufferPtr) xmlMalloc(sizeof(xmlOutputBuffer));
2367     if (ret == NULL) {
2368     xmlIOErrMemory(&quot;creating output buffer&quot;);
2369     return(NULL);
2370     }
2371     memset(ret, 0, (size_t) sizeof(xmlOutputBuffer));
2372     ret-&gt;buffer = xmlBufCreate();
2373     if (ret-&gt;buffer == NULL) {
2374         xmlFree(ret);
2375     return(NULL);
2376     }
2377 
2378     /* try to avoid a performance problem with Windows realloc() */
2379     if (xmlBufGetAllocationScheme(ret-&gt;buffer) == XML_BUFFER_ALLOC_EXACT)
2380         xmlBufSetAllocationScheme(ret-&gt;buffer, XML_BUFFER_ALLOC_DOUBLEIT);
2381 
2382     ret-&gt;encoder = encoder;
2383     if (encoder != NULL) {
2384         ret-&gt;conv = xmlBufCreateSize(4000);
2385     if (ret-&gt;conv == NULL) {

2386         xmlFree(ret);
2387         return(NULL);
2388     }
2389 
2390     /*
2391      * This call is designed to initiate the encoder state
2392      */
2393     xmlCharEncOutput(ret, 1);
2394     } else
2395         ret-&gt;conv = NULL;
2396     ret-&gt;writecallback = NULL;
2397     ret-&gt;closecallback = NULL;
2398     ret-&gt;context = NULL;
2399     ret-&gt;written = 0;
2400 
2401     return(ret);
2402 }
2403 
2404 /**
2405  * xmlAllocOutputBufferInternal:
</pre>
<hr />
<pre>
2418     xmlIOErrMemory(&quot;creating output buffer&quot;);
2419     return(NULL);
2420     }
2421     memset(ret, 0, (size_t) sizeof(xmlOutputBuffer));
2422     ret-&gt;buffer = xmlBufCreate();
2423     if (ret-&gt;buffer == NULL) {
2424         xmlFree(ret);
2425     return(NULL);
2426     }
2427 
2428 
2429     /*
2430      * For conversion buffers we use the special IO handling
2431      */
2432     xmlBufSetAllocationScheme(ret-&gt;buffer, XML_BUFFER_ALLOC_IO);
2433 
2434     ret-&gt;encoder = encoder;
2435     if (encoder != NULL) {
2436         ret-&gt;conv = xmlBufCreateSize(4000);
2437     if (ret-&gt;conv == NULL) {

2438         xmlFree(ret);
2439         return(NULL);
2440     }
2441 
2442     /*
2443      * This call is designed to initiate the encoder state
2444      */
2445         xmlCharEncOutput(ret, 1);
2446     } else
2447         ret-&gt;conv = NULL;
2448     ret-&gt;writecallback = NULL;
2449     ret-&gt;closecallback = NULL;
2450     ret-&gt;context = NULL;
2451     ret-&gt;written = 0;
2452 
2453     return(ret);
2454 }
2455 
2456 #endif /* LIBXML_OUTPUT_ENABLED */
2457 
</pre>
<hr />
<pre>
3318 #ifdef LIBXML_OUTPUT_ENABLED
3319 /**
3320  * xmlOutputBufferWrite:
3321  * @out:  a buffered parser output
3322  * @len:  the size in bytes of the array.
3323  * @buf:  an char array
3324  *
3325  * Write the content of the array in the output I/O buffer
3326  * This routine handle the I18N transcoding from internal UTF-8
3327  * The buffer is lossless, i.e. will store in case of partial
3328  * or delayed writes.
3329  *
3330  * Returns the number of chars immediately written, or -1
3331  *         in case of error.
3332  */
3333 int
3334 xmlOutputBufferWrite(xmlOutputBufferPtr out, int len, const char *buf) {
3335     int nbchars = 0; /* number of chars to output to I/O */
3336     int ret;         /* return from function call */
3337     int written = 0; /* number of char written to I/O so far */
<span class="line-modified">3338     int chunk;       /* number of byte curreent processed from buf */</span>
3339 
3340     if ((out == NULL) || (out-&gt;error)) return(-1);
3341     if (len &lt; 0) return(0);
3342     if (out-&gt;error) return(-1);
3343 
3344     do {
3345     chunk = len;
3346     if (chunk &gt; 4 * MINLEN)
3347         chunk = 4 * MINLEN;
3348 
3349     /*
3350      * first handle encoding stuff.
3351      */
3352     if (out-&gt;encoder != NULL) {
3353         /*
3354          * Store the data in the incoming raw buffer
3355          */
3356         if (out-&gt;conv == NULL) {
3357         out-&gt;conv = xmlBufCreate();
3358         }
3359         ret = xmlBufAdd(out-&gt;buffer, (const xmlChar *) buf, chunk);
3360         if (ret != 0)
3361             return(-1);
3362 
3363         if ((xmlBufUse(out-&gt;buffer) &lt; MINLEN) &amp;&amp; (chunk == len))
3364         goto done;
3365 
3366         /*
3367          * convert as much as possible to the parser reading buffer.
3368          */
3369         ret = xmlCharEncOutput(out, 0);
3370         if ((ret &lt; 0) &amp;&amp; (ret != -3)) {
3371         xmlIOErr(XML_IO_ENCODER, NULL);
3372         out-&gt;error = XML_IO_ENCODER;
3373         return(-1);
3374         }

3375         nbchars = xmlBufUse(out-&gt;conv);


3376     } else {
3377         ret = xmlBufAdd(out-&gt;buffer, (const xmlChar *) buf, chunk);
3378         if (ret != 0)
3379             return(-1);

3380         nbchars = xmlBufUse(out-&gt;buffer);


3381     }
3382     buf += chunk;
3383     len -= chunk;
3384 

3385     if ((nbchars &lt; MINLEN) &amp;&amp; (len &lt;= 0))
3386         goto done;
3387 
<span class="line-removed">3388     if (out-&gt;writecallback) {</span>
3389         /*
3390          * second write the stuff to the I/O channel
3391          */
3392         if (out-&gt;encoder != NULL) {
3393         ret = out-&gt;writecallback(out-&gt;context,
3394                            (const char *)xmlBufContent(out-&gt;conv), nbchars);
3395         if (ret &gt;= 0)
3396             xmlBufShrink(out-&gt;conv, ret);
3397         } else {
3398         ret = out-&gt;writecallback(out-&gt;context,
3399                            (const char *)xmlBufContent(out-&gt;buffer), nbchars);
3400         if (ret &gt;= 0)
3401             xmlBufShrink(out-&gt;buffer, ret);
3402         }
3403         if (ret &lt; 0) {
3404         xmlIOErr(XML_IO_WRITE, NULL);
3405         out-&gt;error = XML_IO_WRITE;
3406         return(ret);
3407         }



3408         out-&gt;written += ret;
3409     }
3410     written += nbchars;
3411     } while (len &gt; 0);
3412 
3413 done:
3414 #ifdef DEBUG_INPUT
3415     xmlGenericError(xmlGenericErrorContext,
3416         &quot;I/O: wrote %d chars\n&quot;, written);
3417 #endif
3418     return(written);
3419 }
3420 
3421 /**
3422  * xmlEscapeContent:
3423  * @out:  a pointer to an array of bytes to store the result
3424  * @outlen:  the length of @out
3425  * @in:  a pointer to an array of unescaped UTF-8 bytes
3426  * @inlen:  the length of @in
3427  *
</pre>
<hr />
<pre>
3468         *out++ = &#39;1&#39;;
3469         *out++ = &#39;3&#39;;
3470         *out++ = &#39;;&#39;;
3471     } else {
3472         *out++ = (unsigned char) *in;
3473     }
3474     ++in;
3475     }
3476     *outlen = out - outstart;
3477     *inlen = in - base;
3478     return(0);
3479 }
3480 
3481 /**
3482  * xmlOutputBufferWriteEscape:
3483  * @out:  a buffered parser output
3484  * @str:  a zero terminated UTF-8 string
3485  * @escaping:  an optional escaping function (or NULL)
3486  *
3487  * Write the content of the string in the output I/O buffer
<span class="line-modified">3488  * This routine escapes the caracters and then handle the I18N</span>
3489  * transcoding from internal UTF-8
3490  * The buffer is lossless, i.e. will store in case of partial
3491  * or delayed writes.
3492  *
3493  * Returns the number of chars immediately written, or -1
3494  *         in case of error.
3495  */
3496 int
3497 xmlOutputBufferWriteEscape(xmlOutputBufferPtr out, const xmlChar *str,
3498                            xmlCharEncodingOutputFunc escaping) {
3499     int nbchars = 0; /* number of chars to output to I/O */
3500     int ret;         /* return from function call */
3501     int written = 0; /* number of char written to I/O so far */
3502     int oldwritten=0;/* loop guard */
3503     int chunk;       /* number of byte currently processed from str */
3504     int len;         /* number of bytes in str */
3505     int cons;        /* byte from str consumed */
3506 
3507     if ((out == NULL) || (out-&gt;error) || (str == NULL) ||
3508         (out-&gt;buffer == NULL) ||
</pre>
<hr />
<pre>
3544         out-&gt;conv = xmlBufCreate();
3545         }
3546         ret = escaping(xmlBufEnd(out-&gt;buffer) ,
3547                        &amp;chunk, str, &amp;cons);
3548         if ((ret &lt; 0) || (chunk == 0)) /* chunk==0 =&gt; nothing done */
3549             return(-1);
3550             xmlBufAddLen(out-&gt;buffer, chunk);
3551 
3552         if ((xmlBufUse(out-&gt;buffer) &lt; MINLEN) &amp;&amp; (cons == len))
3553         goto done;
3554 
3555         /*
3556          * convert as much as possible to the output buffer.
3557          */
3558         ret = xmlCharEncOutput(out, 0);
3559         if ((ret &lt; 0) &amp;&amp; (ret != -3)) {
3560         xmlIOErr(XML_IO_ENCODER, NULL);
3561         out-&gt;error = XML_IO_ENCODER;
3562         return(-1);
3563         }

3564         nbchars = xmlBufUse(out-&gt;conv);


3565     } else {
3566         ret = escaping(xmlBufEnd(out-&gt;buffer), &amp;chunk, str, &amp;cons);
3567         if ((ret &lt; 0) || (chunk == 0)) /* chunk==0 =&gt; nothing done */
3568             return(-1);
3569             xmlBufAddLen(out-&gt;buffer, chunk);

3570         nbchars = xmlBufUse(out-&gt;buffer);


3571     }
3572     str += cons;
3573     len -= cons;
3574 

3575     if ((nbchars &lt; MINLEN) &amp;&amp; (len &lt;= 0))
3576         goto done;
3577 
<span class="line-removed">3578     if (out-&gt;writecallback) {</span>
3579         /*
3580          * second write the stuff to the I/O channel
3581          */
3582         if (out-&gt;encoder != NULL) {
3583         ret = out-&gt;writecallback(out-&gt;context,
3584                            (const char *)xmlBufContent(out-&gt;conv), nbchars);
3585         if (ret &gt;= 0)
3586             xmlBufShrink(out-&gt;conv, ret);
3587         } else {
3588         ret = out-&gt;writecallback(out-&gt;context,
3589                            (const char *)xmlBufContent(out-&gt;buffer), nbchars);
3590         if (ret &gt;= 0)
3591             xmlBufShrink(out-&gt;buffer, ret);
3592         }
3593         if (ret &lt; 0) {
3594         xmlIOErr(XML_IO_WRITE, NULL);
3595         out-&gt;error = XML_IO_WRITE;
3596         return(ret);
3597         }



3598         out-&gt;written += ret;
3599     } else if (xmlBufAvail(out-&gt;buffer) &lt; MINLEN) {
3600         xmlBufGrow(out-&gt;buffer, MINLEN);
3601     }
3602     written += nbchars;
3603     } while ((len &gt; 0) &amp;&amp; (oldwritten != written));
3604 
3605 done:
3606 #ifdef DEBUG_INPUT
3607     xmlGenericError(xmlGenericErrorContext,
3608         &quot;I/O: wrote %d chars\n&quot;, written);
3609 #endif
3610     return(written);
3611 }
3612 
3613 /**
3614  * xmlOutputBufferWriteString:
3615  * @out:  a buffered parser output
3616  * @str:  a zero terminated C string
3617  *
</pre>
<hr />
<pre>
3672      */
3673     if ((out-&gt;conv != NULL) &amp;&amp; (out-&gt;encoder != NULL) &amp;&amp;
3674     (out-&gt;writecallback != NULL)) {
3675     ret = out-&gt;writecallback(out-&gt;context,
3676                                  (const char *)xmlBufContent(out-&gt;conv),
3677                                  xmlBufUse(out-&gt;conv));
3678     if (ret &gt;= 0)
3679         xmlBufShrink(out-&gt;conv, ret);
3680     } else if (out-&gt;writecallback != NULL) {
3681     ret = out-&gt;writecallback(out-&gt;context,
3682                                  (const char *)xmlBufContent(out-&gt;buffer),
3683                                  xmlBufUse(out-&gt;buffer));
3684     if (ret &gt;= 0)
3685         xmlBufShrink(out-&gt;buffer, ret);
3686     }
3687     if (ret &lt; 0) {
3688     xmlIOErr(XML_IO_FLUSH, NULL);
3689     out-&gt;error = XML_IO_FLUSH;
3690     return(ret);
3691     }



3692     out-&gt;written += ret;
3693 
3694 #ifdef DEBUG_INPUT
3695     xmlGenericError(xmlGenericErrorContext,
3696         &quot;I/O: flushed %d chars\n&quot;, ret);
3697 #endif
3698     return(ret);
3699 }
3700 #endif /* LIBXML_OUTPUT_ENABLED */
3701 
3702 /**
3703  * xmlParserGetDirectory:
3704  * @filename:  the path to a file
3705  *
3706  * lookup the directory for that file
3707  *
3708  * Returns a new allocated string containing the directory, or NULL.
3709  */
3710 char *
3711 xmlParserGetDirectory(const char *filename) {
</pre>
<hr />
<pre>
3920         }
3921 
3922         if (tmp != NULL) {
3923         xmlFree(resource);
3924         resource = tmp;
3925         }
3926     }
3927     }
3928 
3929     return resource;
3930 }
3931 
3932 #endif
3933 
3934 /**
3935  * xmlDefaultExternalEntityLoader:
3936  * @URL:  the URL for the entity to load
3937  * @ID:  the System ID for the entity to load
3938  * @ctxt:  the context in which the entity is called or NULL
3939  *
<span class="line-modified">3940  * By default we don&#39;t load external entitites, yet.</span>
3941  *
3942  * Returns a new allocated xmlParserInputPtr, or NULL.
3943  */
3944 static xmlParserInputPtr
3945 xmlDefaultExternalEntityLoader(const char *URL, const char *ID,
3946                                xmlParserCtxtPtr ctxt)
3947 {
3948     xmlParserInputPtr ret = NULL;
3949     xmlChar *resource = NULL;
3950 
3951 #ifdef DEBUG_EXTERNAL_ENTITIES
3952     xmlGenericError(xmlGenericErrorContext,
3953                     &quot;xmlDefaultExternalEntityLoader(%s, xxx)\n&quot;, URL);
3954 #endif
3955     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;options &amp; XML_PARSE_NONET)) {
3956         int options = ctxt-&gt;options;
3957 
3958     ctxt-&gt;options -= XML_PARSE_NONET;
3959         ret = xmlNoNetExternalEntityLoader(URL, ID, ctxt);
3960     ctxt-&gt;options = options;
</pre>
</td>
<td>
<hr />
<pre>
 168     &quot;No such device or address&quot;,/* ENXIO */
 169     &quot;Operation not permitted&quot;,  /* EPERM */
 170     &quot;Broken pipe&quot;,      /* EPIPE */
 171     &quot;Result too large&quot;,     /* ERANGE */
 172     &quot;Read-only file system&quot;,    /* EROFS */
 173     &quot;Invalid seek&quot;,     /* ESPIPE */
 174     &quot;No such process&quot;,      /* ESRCH */
 175     &quot;Operation timed out&quot;,  /* ETIMEDOUT */
 176     &quot;Improper link&quot;,        /* EXDEV */
 177     &quot;Attempt to load network entity %s&quot;, /* XML_IO_NETWORK_ATTEMPT */
 178     &quot;encoder error&quot;,        /* XML_IO_ENCODER */
 179     &quot;flush error&quot;,
 180     &quot;write error&quot;,
 181     &quot;no input&quot;,
 182     &quot;buffer full&quot;,
 183     &quot;loading error&quot;,
 184     &quot;not a socket&quot;,     /* ENOTSOCK */
 185     &quot;already connected&quot;,    /* EISCONN */
 186     &quot;connection refused&quot;,   /* ECONNREFUSED */
 187     &quot;unreachable network&quot;,  /* ENETUNREACH */
<span class="line-modified"> 188     &quot;address in use&quot;,       /* EADDRINUSE */</span>
 189     &quot;already in use&quot;,       /* EALREADY */
<span class="line-modified"> 190     &quot;unknown address family&quot;,   /* EAFNOSUPPORT */</span>
 191 };
 192 
 193 #if defined(_WIN32) || defined (__DJGPP__) &amp;&amp; !defined (__CYGWIN__)
 194 /**
 195  * __xmlIOWin32UTF8ToWChar:
 196  * @u8String:  uft-8 string
 197  *
 198  * Convert a string from utf-8 to wchar (WINDOWS ONLY!)
 199  */
 200 static wchar_t *
 201 __xmlIOWin32UTF8ToWChar(const char *u8String)
 202 {
 203     wchar_t *wString = NULL;
 204 
 205     if (u8String) {
 206         int wLen =
 207             MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, u8String,
 208                                 -1, NULL, 0);
 209         if (wLen) {
 210             wString = xmlMalloc(wLen * sizeof(wchar_t));
</pre>
<hr />
<pre>
2366     ret = (xmlOutputBufferPtr) xmlMalloc(sizeof(xmlOutputBuffer));
2367     if (ret == NULL) {
2368     xmlIOErrMemory(&quot;creating output buffer&quot;);
2369     return(NULL);
2370     }
2371     memset(ret, 0, (size_t) sizeof(xmlOutputBuffer));
2372     ret-&gt;buffer = xmlBufCreate();
2373     if (ret-&gt;buffer == NULL) {
2374         xmlFree(ret);
2375     return(NULL);
2376     }
2377 
2378     /* try to avoid a performance problem with Windows realloc() */
2379     if (xmlBufGetAllocationScheme(ret-&gt;buffer) == XML_BUFFER_ALLOC_EXACT)
2380         xmlBufSetAllocationScheme(ret-&gt;buffer, XML_BUFFER_ALLOC_DOUBLEIT);
2381 
2382     ret-&gt;encoder = encoder;
2383     if (encoder != NULL) {
2384         ret-&gt;conv = xmlBufCreateSize(4000);
2385     if (ret-&gt;conv == NULL) {
<span class="line-added">2386             xmlBufFree(ret-&gt;buffer);</span>
2387         xmlFree(ret);
2388         return(NULL);
2389     }
2390 
2391     /*
2392      * This call is designed to initiate the encoder state
2393      */
2394     xmlCharEncOutput(ret, 1);
2395     } else
2396         ret-&gt;conv = NULL;
2397     ret-&gt;writecallback = NULL;
2398     ret-&gt;closecallback = NULL;
2399     ret-&gt;context = NULL;
2400     ret-&gt;written = 0;
2401 
2402     return(ret);
2403 }
2404 
2405 /**
2406  * xmlAllocOutputBufferInternal:
</pre>
<hr />
<pre>
2419     xmlIOErrMemory(&quot;creating output buffer&quot;);
2420     return(NULL);
2421     }
2422     memset(ret, 0, (size_t) sizeof(xmlOutputBuffer));
2423     ret-&gt;buffer = xmlBufCreate();
2424     if (ret-&gt;buffer == NULL) {
2425         xmlFree(ret);
2426     return(NULL);
2427     }
2428 
2429 
2430     /*
2431      * For conversion buffers we use the special IO handling
2432      */
2433     xmlBufSetAllocationScheme(ret-&gt;buffer, XML_BUFFER_ALLOC_IO);
2434 
2435     ret-&gt;encoder = encoder;
2436     if (encoder != NULL) {
2437         ret-&gt;conv = xmlBufCreateSize(4000);
2438     if (ret-&gt;conv == NULL) {
<span class="line-added">2439             xmlBufFree(ret-&gt;buffer);</span>
2440         xmlFree(ret);
2441         return(NULL);
2442     }
2443 
2444     /*
2445      * This call is designed to initiate the encoder state
2446      */
2447         xmlCharEncOutput(ret, 1);
2448     } else
2449         ret-&gt;conv = NULL;
2450     ret-&gt;writecallback = NULL;
2451     ret-&gt;closecallback = NULL;
2452     ret-&gt;context = NULL;
2453     ret-&gt;written = 0;
2454 
2455     return(ret);
2456 }
2457 
2458 #endif /* LIBXML_OUTPUT_ENABLED */
2459 
</pre>
<hr />
<pre>
3320 #ifdef LIBXML_OUTPUT_ENABLED
3321 /**
3322  * xmlOutputBufferWrite:
3323  * @out:  a buffered parser output
3324  * @len:  the size in bytes of the array.
3325  * @buf:  an char array
3326  *
3327  * Write the content of the array in the output I/O buffer
3328  * This routine handle the I18N transcoding from internal UTF-8
3329  * The buffer is lossless, i.e. will store in case of partial
3330  * or delayed writes.
3331  *
3332  * Returns the number of chars immediately written, or -1
3333  *         in case of error.
3334  */
3335 int
3336 xmlOutputBufferWrite(xmlOutputBufferPtr out, int len, const char *buf) {
3337     int nbchars = 0; /* number of chars to output to I/O */
3338     int ret;         /* return from function call */
3339     int written = 0; /* number of char written to I/O so far */
<span class="line-modified">3340     int chunk;       /* number of byte current processed from buf */</span>
3341 
3342     if ((out == NULL) || (out-&gt;error)) return(-1);
3343     if (len &lt; 0) return(0);
3344     if (out-&gt;error) return(-1);
3345 
3346     do {
3347     chunk = len;
3348     if (chunk &gt; 4 * MINLEN)
3349         chunk = 4 * MINLEN;
3350 
3351     /*
3352      * first handle encoding stuff.
3353      */
3354     if (out-&gt;encoder != NULL) {
3355         /*
3356          * Store the data in the incoming raw buffer
3357          */
3358         if (out-&gt;conv == NULL) {
3359         out-&gt;conv = xmlBufCreate();
3360         }
3361         ret = xmlBufAdd(out-&gt;buffer, (const xmlChar *) buf, chunk);
3362         if (ret != 0)
3363             return(-1);
3364 
3365         if ((xmlBufUse(out-&gt;buffer) &lt; MINLEN) &amp;&amp; (chunk == len))
3366         goto done;
3367 
3368         /*
3369          * convert as much as possible to the parser reading buffer.
3370          */
3371         ret = xmlCharEncOutput(out, 0);
3372         if ((ret &lt; 0) &amp;&amp; (ret != -3)) {
3373         xmlIOErr(XML_IO_ENCODER, NULL);
3374         out-&gt;error = XML_IO_ENCODER;
3375         return(-1);
3376         }
<span class="line-added">3377             if (out-&gt;writecallback)</span>
3378         nbchars = xmlBufUse(out-&gt;conv);
<span class="line-added">3379             else</span>
<span class="line-added">3380                 nbchars = ret;</span>
3381     } else {
3382         ret = xmlBufAdd(out-&gt;buffer, (const xmlChar *) buf, chunk);
3383         if (ret != 0)
3384             return(-1);
<span class="line-added">3385             if (out-&gt;writecallback)</span>
3386         nbchars = xmlBufUse(out-&gt;buffer);
<span class="line-added">3387             else</span>
<span class="line-added">3388                 nbchars = chunk;</span>
3389     }
3390     buf += chunk;
3391     len -= chunk;
3392 
<span class="line-added">3393     if (out-&gt;writecallback) {</span>
3394     if ((nbchars &lt; MINLEN) &amp;&amp; (len &lt;= 0))
3395         goto done;
3396 

3397         /*
3398          * second write the stuff to the I/O channel
3399          */
3400         if (out-&gt;encoder != NULL) {
3401         ret = out-&gt;writecallback(out-&gt;context,
3402                            (const char *)xmlBufContent(out-&gt;conv), nbchars);
3403         if (ret &gt;= 0)
3404             xmlBufShrink(out-&gt;conv, ret);
3405         } else {
3406         ret = out-&gt;writecallback(out-&gt;context,
3407                            (const char *)xmlBufContent(out-&gt;buffer), nbchars);
3408         if (ret &gt;= 0)
3409             xmlBufShrink(out-&gt;buffer, ret);
3410         }
3411         if (ret &lt; 0) {
3412         xmlIOErr(XML_IO_WRITE, NULL);
3413         out-&gt;error = XML_IO_WRITE;
3414         return(ret);
3415         }
<span class="line-added">3416             if (out-&gt;written &gt; INT_MAX - ret)</span>
<span class="line-added">3417                 out-&gt;written = INT_MAX;</span>
<span class="line-added">3418             else</span>
3419         out-&gt;written += ret;
3420     }
3421     written += nbchars;
3422     } while (len &gt; 0);
3423 
3424 done:
3425 #ifdef DEBUG_INPUT
3426     xmlGenericError(xmlGenericErrorContext,
3427         &quot;I/O: wrote %d chars\n&quot;, written);
3428 #endif
3429     return(written);
3430 }
3431 
3432 /**
3433  * xmlEscapeContent:
3434  * @out:  a pointer to an array of bytes to store the result
3435  * @outlen:  the length of @out
3436  * @in:  a pointer to an array of unescaped UTF-8 bytes
3437  * @inlen:  the length of @in
3438  *
</pre>
<hr />
<pre>
3479         *out++ = &#39;1&#39;;
3480         *out++ = &#39;3&#39;;
3481         *out++ = &#39;;&#39;;
3482     } else {
3483         *out++ = (unsigned char) *in;
3484     }
3485     ++in;
3486     }
3487     *outlen = out - outstart;
3488     *inlen = in - base;
3489     return(0);
3490 }
3491 
3492 /**
3493  * xmlOutputBufferWriteEscape:
3494  * @out:  a buffered parser output
3495  * @str:  a zero terminated UTF-8 string
3496  * @escaping:  an optional escaping function (or NULL)
3497  *
3498  * Write the content of the string in the output I/O buffer
<span class="line-modified">3499  * This routine escapes the characters and then handle the I18N</span>
3500  * transcoding from internal UTF-8
3501  * The buffer is lossless, i.e. will store in case of partial
3502  * or delayed writes.
3503  *
3504  * Returns the number of chars immediately written, or -1
3505  *         in case of error.
3506  */
3507 int
3508 xmlOutputBufferWriteEscape(xmlOutputBufferPtr out, const xmlChar *str,
3509                            xmlCharEncodingOutputFunc escaping) {
3510     int nbchars = 0; /* number of chars to output to I/O */
3511     int ret;         /* return from function call */
3512     int written = 0; /* number of char written to I/O so far */
3513     int oldwritten=0;/* loop guard */
3514     int chunk;       /* number of byte currently processed from str */
3515     int len;         /* number of bytes in str */
3516     int cons;        /* byte from str consumed */
3517 
3518     if ((out == NULL) || (out-&gt;error) || (str == NULL) ||
3519         (out-&gt;buffer == NULL) ||
</pre>
<hr />
<pre>
3555         out-&gt;conv = xmlBufCreate();
3556         }
3557         ret = escaping(xmlBufEnd(out-&gt;buffer) ,
3558                        &amp;chunk, str, &amp;cons);
3559         if ((ret &lt; 0) || (chunk == 0)) /* chunk==0 =&gt; nothing done */
3560             return(-1);
3561             xmlBufAddLen(out-&gt;buffer, chunk);
3562 
3563         if ((xmlBufUse(out-&gt;buffer) &lt; MINLEN) &amp;&amp; (cons == len))
3564         goto done;
3565 
3566         /*
3567          * convert as much as possible to the output buffer.
3568          */
3569         ret = xmlCharEncOutput(out, 0);
3570         if ((ret &lt; 0) &amp;&amp; (ret != -3)) {
3571         xmlIOErr(XML_IO_ENCODER, NULL);
3572         out-&gt;error = XML_IO_ENCODER;
3573         return(-1);
3574         }
<span class="line-added">3575             if (out-&gt;writecallback)</span>
3576         nbchars = xmlBufUse(out-&gt;conv);
<span class="line-added">3577             else</span>
<span class="line-added">3578                 nbchars = ret;</span>
3579     } else {
3580         ret = escaping(xmlBufEnd(out-&gt;buffer), &amp;chunk, str, &amp;cons);
3581         if ((ret &lt; 0) || (chunk == 0)) /* chunk==0 =&gt; nothing done */
3582             return(-1);
3583             xmlBufAddLen(out-&gt;buffer, chunk);
<span class="line-added">3584             if (out-&gt;writecallback)</span>
3585         nbchars = xmlBufUse(out-&gt;buffer);
<span class="line-added">3586             else</span>
<span class="line-added">3587                 nbchars = chunk;</span>
3588     }
3589     str += cons;
3590     len -= cons;
3591 
<span class="line-added">3592     if (out-&gt;writecallback) {</span>
3593     if ((nbchars &lt; MINLEN) &amp;&amp; (len &lt;= 0))
3594         goto done;
3595 

3596         /*
3597          * second write the stuff to the I/O channel
3598          */
3599         if (out-&gt;encoder != NULL) {
3600         ret = out-&gt;writecallback(out-&gt;context,
3601                            (const char *)xmlBufContent(out-&gt;conv), nbchars);
3602         if (ret &gt;= 0)
3603             xmlBufShrink(out-&gt;conv, ret);
3604         } else {
3605         ret = out-&gt;writecallback(out-&gt;context,
3606                            (const char *)xmlBufContent(out-&gt;buffer), nbchars);
3607         if (ret &gt;= 0)
3608             xmlBufShrink(out-&gt;buffer, ret);
3609         }
3610         if (ret &lt; 0) {
3611         xmlIOErr(XML_IO_WRITE, NULL);
3612         out-&gt;error = XML_IO_WRITE;
3613         return(ret);
3614         }
<span class="line-added">3615             if (out-&gt;written &gt; INT_MAX - ret)</span>
<span class="line-added">3616                 out-&gt;written = INT_MAX;</span>
<span class="line-added">3617             else</span>
3618         out-&gt;written += ret;
3619     } else if (xmlBufAvail(out-&gt;buffer) &lt; MINLEN) {
3620         xmlBufGrow(out-&gt;buffer, MINLEN);
3621     }
3622     written += nbchars;
3623     } while ((len &gt; 0) &amp;&amp; (oldwritten != written));
3624 
3625 done:
3626 #ifdef DEBUG_INPUT
3627     xmlGenericError(xmlGenericErrorContext,
3628         &quot;I/O: wrote %d chars\n&quot;, written);
3629 #endif
3630     return(written);
3631 }
3632 
3633 /**
3634  * xmlOutputBufferWriteString:
3635  * @out:  a buffered parser output
3636  * @str:  a zero terminated C string
3637  *
</pre>
<hr />
<pre>
3692      */
3693     if ((out-&gt;conv != NULL) &amp;&amp; (out-&gt;encoder != NULL) &amp;&amp;
3694     (out-&gt;writecallback != NULL)) {
3695     ret = out-&gt;writecallback(out-&gt;context,
3696                                  (const char *)xmlBufContent(out-&gt;conv),
3697                                  xmlBufUse(out-&gt;conv));
3698     if (ret &gt;= 0)
3699         xmlBufShrink(out-&gt;conv, ret);
3700     } else if (out-&gt;writecallback != NULL) {
3701     ret = out-&gt;writecallback(out-&gt;context,
3702                                  (const char *)xmlBufContent(out-&gt;buffer),
3703                                  xmlBufUse(out-&gt;buffer));
3704     if (ret &gt;= 0)
3705         xmlBufShrink(out-&gt;buffer, ret);
3706     }
3707     if (ret &lt; 0) {
3708     xmlIOErr(XML_IO_FLUSH, NULL);
3709     out-&gt;error = XML_IO_FLUSH;
3710     return(ret);
3711     }
<span class="line-added">3712     if (out-&gt;written &gt; INT_MAX - ret)</span>
<span class="line-added">3713         out-&gt;written = INT_MAX;</span>
<span class="line-added">3714     else</span>
3715     out-&gt;written += ret;
3716 
3717 #ifdef DEBUG_INPUT
3718     xmlGenericError(xmlGenericErrorContext,
3719         &quot;I/O: flushed %d chars\n&quot;, ret);
3720 #endif
3721     return(ret);
3722 }
3723 #endif /* LIBXML_OUTPUT_ENABLED */
3724 
3725 /**
3726  * xmlParserGetDirectory:
3727  * @filename:  the path to a file
3728  *
3729  * lookup the directory for that file
3730  *
3731  * Returns a new allocated string containing the directory, or NULL.
3732  */
3733 char *
3734 xmlParserGetDirectory(const char *filename) {
</pre>
<hr />
<pre>
3943         }
3944 
3945         if (tmp != NULL) {
3946         xmlFree(resource);
3947         resource = tmp;
3948         }
3949     }
3950     }
3951 
3952     return resource;
3953 }
3954 
3955 #endif
3956 
3957 /**
3958  * xmlDefaultExternalEntityLoader:
3959  * @URL:  the URL for the entity to load
3960  * @ID:  the System ID for the entity to load
3961  * @ctxt:  the context in which the entity is called or NULL
3962  *
<span class="line-modified">3963  * By default we don&#39;t load external entities, yet.</span>
3964  *
3965  * Returns a new allocated xmlParserInputPtr, or NULL.
3966  */
3967 static xmlParserInputPtr
3968 xmlDefaultExternalEntityLoader(const char *URL, const char *ID,
3969                                xmlParserCtxtPtr ctxt)
3970 {
3971     xmlParserInputPtr ret = NULL;
3972     xmlChar *resource = NULL;
3973 
3974 #ifdef DEBUG_EXTERNAL_ENTITIES
3975     xmlGenericError(xmlGenericErrorContext,
3976                     &quot;xmlDefaultExternalEntityLoader(%s, xxx)\n&quot;, URL);
3977 #endif
3978     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;options &amp; XML_PARSE_NONET)) {
3979         int options = ctxt-&gt;options;
3980 
3981     ctxt-&gt;options -= XML_PARSE_NONET;
3982         ret = xmlNoNetExternalEntityLoader(URL, ID, ctxt);
3983     ctxt-&gt;options = options;
</pre>
</td>
</tr>
</table>
<center><a href="xml2Conf.sh.in.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="xmlreader.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
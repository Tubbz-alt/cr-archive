<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/parser.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="nanohttp.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="parserInternals.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/parser.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   79 #endif
   80 #ifdef HAVE_FCNTL_H
   81 #include &lt;fcntl.h&gt;
   82 #endif
   83 #ifdef HAVE_UNISTD_H
   84 #include &lt;unistd.h&gt;
   85 #endif
   86 
   87 #include &quot;buf.h&quot;
   88 #include &quot;enc.h&quot;
   89 
   90 static void
   91 xmlFatalErr(xmlParserCtxtPtr ctxt, xmlParserErrors error, const char *info);
   92 
   93 static xmlParserCtxtPtr
   94 xmlCreateEntityParserCtxtInternal(const xmlChar *URL, const xmlChar *ID,
   95                       const xmlChar *base, xmlParserCtxtPtr pctx);
   96 
   97 static void xmlHaltParser(xmlParserCtxtPtr ctxt);
   98 






   99 /************************************************************************
  100  *                                  *
  101  *  Arbitrary limits set in the parser. See XML_PARSE_HUGE      *
  102  *                                  *
  103  ************************************************************************/
  104 
  105 #define XML_PARSER_BIG_ENTITY 1000
  106 #define XML_PARSER_LOT_ENTITY 5000
  107 
  108 /*
  109  * XML_PARSER_NON_LINEAR is the threshold where the ratio of parsed entity
  110  *    replacement over the size in byte of the input indicates that you have
<span class="line-modified">  111  *    and eponential behaviour. A value of 10 correspond to at least 3 entity</span>
  112  *    replacement per byte of input.
  113  */
  114 #define XML_PARSER_NON_LINEAR 10
  115 
  116 /*
  117  * xmlParserEntityCheck
  118  *
  119  * Function to check non-linear entity expansion behaviour
  120  * This is here to detect and stop exponential linear entity expansion
  121  * This is not a limitation of the parser but a safety
  122  * boundary feature. It can be disabled with the XML_PARSE_HUGE
  123  * parser option.
  124  */
  125 static int
  126 xmlParserEntityCheck(xmlParserCtxtPtr ctxt, size_t size,
  127                      xmlEntityPtr ent, size_t replacement)
  128 {
  129     size_t consumed = 0;
  130 
  131     if ((ctxt == NULL) || (ctxt-&gt;options &amp; XML_PARSE_HUGE))
  132         return (0);
  133     if (ctxt-&gt;lastError.code == XML_ERR_ENTITY_LOOP)
  134         return (1);
  135 
  136     /*
  137      * This may look absurd but is needed to detect
  138      * entities problems
  139      */
  140     if ((ent != NULL) &amp;&amp; (ent-&gt;etype != XML_INTERNAL_PREDEFINED_ENTITY) &amp;&amp;
  141     (ent-&gt;content != NULL) &amp;&amp; (ent-&gt;checked == 0) &amp;&amp;
  142     (ctxt-&gt;errNo != XML_ERR_ENTITY_LOOP)) {
<span class="line-modified">  143     unsigned long oldnbent = ctxt-&gt;nbentities;</span>
  144     xmlChar *rep;
  145 
  146     ent-&gt;checked = 1;
  147 
  148         ++ctxt-&gt;depth;
  149     rep = xmlStringDecodeEntities(ctxt, ent-&gt;content,
  150                   XML_SUBSTITUTE_REF, 0, 0, 0);
  151         --ctxt-&gt;depth;
  152     if ((rep == NULL) || (ctxt-&gt;errNo == XML_ERR_ENTITY_LOOP)) {
  153         ent-&gt;content[0] = 0;
  154     }
  155 
<span class="line-modified">  156     ent-&gt;checked = (ctxt-&gt;nbentities - oldnbent + 1) * 2;</span>



  157     if (rep != NULL) {
  158         if (xmlStrchr(rep, &#39;&lt;&#39;))
  159         ent-&gt;checked |= 1;
  160         xmlFree(rep);
  161         rep = NULL;
  162     }
  163     }
  164     if (replacement != 0) {
  165     if (replacement &lt; XML_MAX_TEXT_LENGTH)
  166         return(0);
  167 
  168         /*
  169      * If the volume of entity copy reaches 10 times the
  170      * amount of parsed data and over the large text threshold
  171      * then that&#39;s very likely to be an abuse.
  172      */
  173         if (ctxt-&gt;input != NULL) {
  174         consumed = ctxt-&gt;input-&gt;consumed +
  175                    (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
  176     }
</pre>
<hr />
<pre>
 1043             return(1);
 1044 #else
 1045             return(0);
 1046 #endif
 1047         default:
 1048         break;
 1049      }
 1050      return(0);
 1051 }
 1052 
 1053 /************************************************************************
 1054  *                                  *
 1055  *      SAX2 defaulted attributes handling          *
 1056  *                                  *
 1057  ************************************************************************/
 1058 
 1059 /**
 1060  * xmlDetectSAX2:
 1061  * @ctxt:  an XML parser context
 1062  *
<span class="line-modified"> 1063  * Do the SAX2 detection and specific intialization</span>
 1064  */
 1065 static void
 1066 xmlDetectSAX2(xmlParserCtxtPtr ctxt) {
 1067     if (ctxt == NULL) return;
 1068 #ifdef LIBXML_SAX1_ENABLED
 1069     if ((ctxt-&gt;sax) &amp;&amp;  (ctxt-&gt;sax-&gt;initialized == XML_SAX2_MAGIC) &amp;&amp;
 1070         ((ctxt-&gt;sax-&gt;startElementNs != NULL) ||
 1071          (ctxt-&gt;sax-&gt;endElementNs != NULL))) ctxt-&gt;sax2 = 1;
 1072 #else
 1073     ctxt-&gt;sax2 = 1;
 1074 #endif /* LIBXML_SAX1_ENABLED */
 1075 
 1076     ctxt-&gt;str_xml = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xml&quot;, 3);
 1077     ctxt-&gt;str_xmlns = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xmlns&quot;, 5);
 1078     ctxt-&gt;str_xml_ns = xmlDictLookup(ctxt-&gt;dict, XML_XML_NAMESPACE, 36);
 1079     if ((ctxt-&gt;str_xml==NULL) || (ctxt-&gt;str_xmlns==NULL) ||
 1080         (ctxt-&gt;str_xml_ns == NULL)) {
 1081         xmlErrMemory(ctxt, NULL);
 1082     }
 1083 }
</pre>
<hr />
<pre>
 1375     }
 1376     return;
 1377 }
 1378 
 1379 /**
 1380  * xmlCheckLanguageID:
 1381  * @lang:  pointer to the string value
 1382  *
 1383  * Checks that the value conforms to the LanguageID production:
 1384  *
 1385  * NOTE: this is somewhat deprecated, those productions were removed from
 1386  *       the XML Second edition.
 1387  *
 1388  * [33] LanguageID ::= Langcode (&#39;-&#39; Subcode)*
 1389  * [34] Langcode ::= ISO639Code |  IanaCode |  UserCode
 1390  * [35] ISO639Code ::= ([a-z] | [A-Z]) ([a-z] | [A-Z])
 1391  * [36] IanaCode ::= (&#39;i&#39; | &#39;I&#39;) &#39;-&#39; ([a-z] | [A-Z])+
 1392  * [37] UserCode ::= (&#39;x&#39; | &#39;X&#39;) &#39;-&#39; ([a-z] | [A-Z])+
 1393  * [38] Subcode ::= ([a-z] | [A-Z])+
 1394  *
<span class="line-modified"> 1395  * The current REC reference the sucessors of RFC 1766, currently 5646</span>
 1396  *
 1397  * http://www.rfc-editor.org/rfc/rfc5646.txt
 1398  * langtag       = language
 1399  *                 [&quot;-&quot; script]
 1400  *                 [&quot;-&quot; region]
 1401  *                 *(&quot;-&quot; variant)
 1402  *                 *(&quot;-&quot; extension)
 1403  *                 [&quot;-&quot; privateuse]
 1404  * language      = 2*3ALPHA            ; shortest ISO 639 code
 1405  *                 [&quot;-&quot; extlang]       ; sometimes followed by
 1406  *                                     ; extended language subtags
 1407  *               / 4ALPHA              ; or reserved for future use
 1408  *               / 5*8ALPHA            ; or registered language subtag
 1409  *
 1410  * extlang       = 3ALPHA              ; selected ISO 639 codes
 1411  *                 *2(&quot;-&quot; 3ALPHA)      ; permanently reserved
 1412  *
 1413  * script        = 4ALPHA              ; ISO 15924 code
 1414  *
 1415  * region        = 2ALPHA              ; ISO 3166-1 code
</pre>
<hr />
<pre>
 1802  * Returns the node just removed
 1803  */
 1804 xmlNodePtr
 1805 nodePop(xmlParserCtxtPtr ctxt)
 1806 {
 1807     xmlNodePtr ret;
 1808 
 1809     if (ctxt == NULL) return(NULL);
 1810     if (ctxt-&gt;nodeNr &lt;= 0)
 1811         return (NULL);
 1812     ctxt-&gt;nodeNr--;
 1813     if (ctxt-&gt;nodeNr &gt; 0)
 1814         ctxt-&gt;node = ctxt-&gt;nodeTab[ctxt-&gt;nodeNr - 1];
 1815     else
 1816         ctxt-&gt;node = NULL;
 1817     ret = ctxt-&gt;nodeTab[ctxt-&gt;nodeNr];
 1818     ctxt-&gt;nodeTab[ctxt-&gt;nodeNr] = NULL;
 1819     return (ret);
 1820 }
 1821 
<span class="line-removed"> 1822 #ifdef LIBXML_PUSH_ENABLED</span>
 1823 /**
 1824  * nameNsPush:
 1825  * @ctxt:  an XML parser context
 1826  * @value:  the element name
 1827  * @prefix:  the element prefix
 1828  * @URI:  the element namespace name
 1829  *
 1830  * Pushes a new element name/prefix/URL on top of the name stack
 1831  *
 1832  * Returns -1 in case of error, the index in the stack otherwise
 1833  */
 1834 static int
 1835 nameNsPush(xmlParserCtxtPtr ctxt, const xmlChar * value,
 1836            const xmlChar *prefix, const xmlChar *URI, int nsNr)
 1837 {
 1838     if (ctxt-&gt;nameNr &gt;= ctxt-&gt;nameMax) {
 1839         const xmlChar * *tmp;
 1840         void **tmp2;
 1841         ctxt-&gt;nameMax *= 2;
 1842         tmp = (const xmlChar * *) xmlRealloc((xmlChar * *)ctxt-&gt;nameTab,
 1843                                     ctxt-&gt;nameMax *
 1844                                     sizeof(ctxt-&gt;nameTab[0]));
 1845         if (tmp == NULL) {
 1846         ctxt-&gt;nameMax /= 2;
 1847         goto mem_error;
 1848         }
 1849     ctxt-&gt;nameTab = tmp;
 1850         tmp2 = (void **) xmlRealloc((void * *)ctxt-&gt;pushTab,
 1851                                     ctxt-&gt;nameMax * 3 *
 1852                                     sizeof(ctxt-&gt;pushTab[0]));
 1853         if (tmp2 == NULL) {
 1854         ctxt-&gt;nameMax /= 2;
 1855         goto mem_error;
 1856         }
 1857     ctxt-&gt;pushTab = tmp2;





 1858     }
 1859     ctxt-&gt;nameTab[ctxt-&gt;nameNr] = value;
 1860     ctxt-&gt;name = value;
 1861     ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3] = (void *) prefix;
 1862     ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 + 1] = (void *) URI;
 1863     ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 + 2] = (void *) (ptrdiff_t) nsNr;
 1864     return (ctxt-&gt;nameNr++);
 1865 mem_error:
 1866     xmlErrMemory(ctxt, NULL);
 1867     return (-1);
 1868 }

 1869 /**
 1870  * nameNsPop:
 1871  * @ctxt: an XML parser context
 1872  *
 1873  * Pops the top element/prefix/URI name from the name stack
 1874  *
 1875  * Returns the name just removed
 1876  */
 1877 static const xmlChar *
 1878 nameNsPop(xmlParserCtxtPtr ctxt)
 1879 {
 1880     const xmlChar *ret;
 1881 
 1882     if (ctxt-&gt;nameNr &lt;= 0)
 1883         return (NULL);
 1884     ctxt-&gt;nameNr--;
 1885     if (ctxt-&gt;nameNr &gt; 0)
 1886         ctxt-&gt;name = ctxt-&gt;nameTab[ctxt-&gt;nameNr - 1];
 1887     else
 1888         ctxt-&gt;name = NULL;
</pre>
<hr />
<pre>
 2058     if (*ctxt-&gt;input-&gt;cur == 0)                     \
 2059         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);           \
 2060   } while (0)
 2061 
 2062 #define SHRINK if ((ctxt-&gt;progressive == 0) &amp;&amp;              \
 2063            (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base &gt; 2 * INPUT_CHUNK) &amp;&amp; \
 2064            (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; 2 * INPUT_CHUNK)) \
 2065     xmlSHRINK (ctxt);
 2066 
 2067 static void xmlSHRINK (xmlParserCtxtPtr ctxt) {
 2068     xmlParserInputShrink(ctxt-&gt;input);
 2069     if (*ctxt-&gt;input-&gt;cur == 0)
 2070         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 2071 }
 2072 
 2073 #define GROW if ((ctxt-&gt;progressive == 0) &amp;&amp;                \
 2074          (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; INPUT_CHUNK))   \
 2075     xmlGROW (ctxt);
 2076 
 2077 static void xmlGROW (xmlParserCtxtPtr ctxt) {
<span class="line-modified"> 2078     unsigned long curEnd = ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur;</span>
<span class="line-modified"> 2079     unsigned long curBase = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;</span>
 2080 
<span class="line-modified"> 2081     if (((curEnd &gt; (unsigned long) XML_MAX_LOOKUP_LIMIT) ||</span>
<span class="line-modified"> 2082          (curBase &gt; (unsigned long) XML_MAX_LOOKUP_LIMIT)) &amp;&amp;</span>
 2083          ((ctxt-&gt;input-&gt;buf) &amp;&amp;
 2084           (ctxt-&gt;input-&gt;buf-&gt;readcallback != xmlInputReadCallbackNop)) &amp;&amp;
 2085         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 2086         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, &quot;Huge input lookup&quot;);
 2087         xmlHaltParser(ctxt);
 2088     return;
 2089     }
 2090     xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 2091     if ((ctxt-&gt;input-&gt;cur &gt; ctxt-&gt;input-&gt;end) ||
 2092         (ctxt-&gt;input-&gt;cur &lt; ctxt-&gt;input-&gt;base)) {
 2093         xmlHaltParser(ctxt);
 2094         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, &quot;cur index out of bound&quot;);
 2095     return;
 2096     }
 2097     if ((ctxt-&gt;input-&gt;cur != NULL) &amp;&amp; (*ctxt-&gt;input-&gt;cur == 0))
 2098         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 2099 }
 2100 
 2101 #define SKIP_BLANKS xmlSkipBlankChars(ctxt)
 2102 
</pre>
<hr />
<pre>
 2264     return(ret);
 2265 }
 2266 
 2267 /**
 2268  * xmlParseCharRef:
 2269  * @ctxt:  an XML parser context
 2270  *
 2271  * parse Reference declarations
 2272  *
 2273  * [66] CharRef ::= &#39;&amp;#&#39; [0-9]+ &#39;;&#39; |
 2274  *                  &#39;&amp;#x&#39; [0-9a-fA-F]+ &#39;;&#39;
 2275  *
 2276  * [ WFC: Legal Character ]
 2277  * Characters referred to using character references must match the
 2278  * production for Char.
 2279  *
 2280  * Returns the value parsed (as an int), 0 in case of error
 2281  */
 2282 int
 2283 xmlParseCharRef(xmlParserCtxtPtr ctxt) {
<span class="line-modified"> 2284     unsigned int val = 0;</span>
 2285     int count = 0;
<span class="line-removed"> 2286     unsigned int outofrange = 0;</span>
 2287 
 2288     /*
 2289      * Using RAW/CUR/NEXT is okay since we are working on ASCII range here
 2290      */
 2291     if ((RAW == &#39;&amp;&#39;) &amp;&amp; (NXT(1) == &#39;#&#39;) &amp;&amp;
 2292         (NXT(2) == &#39;x&#39;)) {
 2293     SKIP(3);
 2294     GROW;
 2295     while (RAW != &#39;;&#39;) { /* loop blocked by count */
 2296         if (count++ &gt; 20) {
 2297         count = 0;
 2298         GROW;
 2299                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 2300                     return(0);
 2301         }
 2302         if ((RAW &gt;= &#39;0&#39;) &amp;&amp; (RAW &lt;= &#39;9&#39;))
 2303             val = val * 16 + (CUR - &#39;0&#39;);
 2304         else if ((RAW &gt;= &#39;a&#39;) &amp;&amp; (RAW &lt;= &#39;f&#39;) &amp;&amp; (count &lt; 20))
 2305             val = val * 16 + (CUR - &#39;a&#39;) + 10;
 2306         else if ((RAW &gt;= &#39;A&#39;) &amp;&amp; (RAW &lt;= &#39;F&#39;) &amp;&amp; (count &lt; 20))
 2307             val = val * 16 + (CUR - &#39;A&#39;) + 10;
 2308         else {
 2309         xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);
 2310         val = 0;
 2311         break;
 2312         }
<span class="line-modified"> 2313         if (val &gt; 0x10FFFF)</span>
<span class="line-modified"> 2314             outofrange = val;</span>
 2315 
 2316         NEXT;
 2317         count++;
 2318     }
 2319     if (RAW == &#39;;&#39;) {
 2320         /* on purpose to avoid reentrancy problems with NEXT and SKIP */
 2321         ctxt-&gt;input-&gt;col++;
 2322         ctxt-&gt;nbChars ++;
 2323         ctxt-&gt;input-&gt;cur++;
 2324     }
 2325     } else if  ((RAW == &#39;&amp;&#39;) &amp;&amp; (NXT(1) == &#39;#&#39;)) {
 2326     SKIP(2);
 2327     GROW;
 2328     while (RAW != &#39;;&#39;) { /* loop blocked by count */
 2329         if (count++ &gt; 20) {
 2330         count = 0;
 2331         GROW;
 2332                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 2333                     return(0);
 2334         }
 2335         if ((RAW &gt;= &#39;0&#39;) &amp;&amp; (RAW &lt;= &#39;9&#39;))
 2336             val = val * 10 + (CUR - &#39;0&#39;);
 2337         else {
 2338         xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);
 2339         val = 0;
 2340         break;
 2341         }
<span class="line-modified"> 2342         if (val &gt; 0x10FFFF)</span>
<span class="line-modified"> 2343             outofrange = val;</span>
 2344 
 2345         NEXT;
 2346         count++;
 2347     }
 2348     if (RAW == &#39;;&#39;) {
 2349         /* on purpose to avoid reentrancy problems with NEXT and SKIP */
 2350         ctxt-&gt;input-&gt;col++;
 2351         ctxt-&gt;nbChars ++;
 2352         ctxt-&gt;input-&gt;cur++;
 2353     }
 2354     } else {
 2355         xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);
 2356     }
 2357 
 2358     /*
 2359      * [ WFC: Legal Character ]
 2360      * Characters referred to using character references must match the
 2361      * production for Char.
 2362      */
<span class="line-modified"> 2363     if ((IS_CHAR(val) &amp;&amp; (outofrange == 0))) {</span>




 2364         return(val);
 2365     } else {
 2366         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 2367                           &quot;xmlParseCharRef: invalid xmlChar value %d\n&quot;,
 2368                       val);
 2369     }
 2370     return(0);
 2371 }
 2372 
 2373 /**
 2374  * xmlParseStringCharRef:
 2375  * @ctxt:  an XML parser context
 2376  * @str:  a pointer to an index in the string
 2377  *
 2378  * parse Reference declarations, variant parsing from a string rather
 2379  * than an an input flow.
 2380  *
 2381  * [66] CharRef ::= &#39;&amp;#&#39; [0-9]+ &#39;;&#39; |
 2382  *                  &#39;&amp;#x&#39; [0-9a-fA-F]+ &#39;;&#39;
 2383  *
 2384  * [ WFC: Legal Character ]
 2385  * Characters referred to using character references must match the
 2386  * production for Char.
 2387  *
 2388  * Returns the value parsed (as an int), 0 in case of error, str will be
 2389  *         updated to the current value of the index
 2390  */
 2391 static int
 2392 xmlParseStringCharRef(xmlParserCtxtPtr ctxt, const xmlChar **str) {
 2393     const xmlChar *ptr;
 2394     xmlChar cur;
<span class="line-modified"> 2395     unsigned int val = 0;</span>
<span class="line-removed"> 2396     unsigned int outofrange = 0;</span>
 2397 
 2398     if ((str == NULL) || (*str == NULL)) return(0);
 2399     ptr = *str;
 2400     cur = *ptr;
 2401     if ((cur == &#39;&amp;&#39;) &amp;&amp; (ptr[1] == &#39;#&#39;) &amp;&amp; (ptr[2] == &#39;x&#39;)) {
 2402     ptr += 3;
 2403     cur = *ptr;
 2404     while (cur != &#39;;&#39;) { /* Non input consuming loop */
 2405         if ((cur &gt;= &#39;0&#39;) &amp;&amp; (cur &lt;= &#39;9&#39;))
 2406             val = val * 16 + (cur - &#39;0&#39;);
 2407         else if ((cur &gt;= &#39;a&#39;) &amp;&amp; (cur &lt;= &#39;f&#39;))
 2408             val = val * 16 + (cur - &#39;a&#39;) + 10;
 2409         else if ((cur &gt;= &#39;A&#39;) &amp;&amp; (cur &lt;= &#39;F&#39;))
 2410             val = val * 16 + (cur - &#39;A&#39;) + 10;
 2411         else {
 2412         xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);
 2413         val = 0;
 2414         break;
 2415         }
<span class="line-modified"> 2416         if (val &gt; 0x10FFFF)</span>
<span class="line-modified"> 2417             outofrange = val;</span>
 2418 
 2419         ptr++;
 2420         cur = *ptr;
 2421     }
 2422     if (cur == &#39;;&#39;)
 2423         ptr++;
 2424     } else if  ((cur == &#39;&amp;&#39;) &amp;&amp; (ptr[1] == &#39;#&#39;)){
 2425     ptr += 2;
 2426     cur = *ptr;
 2427     while (cur != &#39;;&#39;) { /* Non input consuming loops */
 2428         if ((cur &gt;= &#39;0&#39;) &amp;&amp; (cur &lt;= &#39;9&#39;))
 2429             val = val * 10 + (cur - &#39;0&#39;);
 2430         else {
 2431         xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);
 2432         val = 0;
 2433         break;
 2434         }
<span class="line-modified"> 2435         if (val &gt; 0x10FFFF)</span>
<span class="line-modified"> 2436             outofrange = val;</span>
 2437 
 2438         ptr++;
 2439         cur = *ptr;
 2440     }
 2441     if (cur == &#39;;&#39;)
 2442         ptr++;
 2443     } else {
 2444     xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);
 2445     return(0);
 2446     }
 2447     *str = ptr;
 2448 
 2449     /*
 2450      * [ WFC: Legal Character ]
 2451      * Characters referred to using character references must match the
 2452      * production for Char.
 2453      */
<span class="line-modified"> 2454     if ((IS_CHAR(val) &amp;&amp; (outofrange == 0))) {</span>




 2455         return(val);
 2456     } else {
 2457         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 2458               &quot;xmlParseStringCharRef: invalid xmlChar value %d\n&quot;,
 2459               val);
 2460     }
 2461     return(0);
 2462 }
 2463 
 2464 /**
 2465  * xmlParserHandlePEReference:
 2466  * @ctxt:  the parser context
 2467  *
 2468  * [69] PEReference ::= &#39;%&#39; Name &#39;;&#39;
 2469  *
 2470  * [ WFC: No Recursion ]
 2471  * A parsed entity must not contain a recursive
 2472  * reference to itself, either directly or indirectly.
 2473  *
 2474  * [ WFC: Entity Declared ]
</pre>
<hr />
<pre>
 2609     xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 2610     return(NULL);
 2611     }
 2612 
 2613     /*
 2614      * allocate a translation buffer.
 2615      */
 2616     buffer_size = XML_PARSER_BIG_BUFFER_SIZE;
 2617     buffer = (xmlChar *) xmlMallocAtomic(buffer_size);
 2618     if (buffer == NULL) goto mem_error;
 2619 
 2620     /*
 2621      * OK loop until we reach one of the ending char or a size limit.
 2622      * we are operating on already parsed values.
 2623      */
 2624     if (str &lt; last)
 2625     c = CUR_SCHAR(str, l);
 2626     else
 2627         c = 0;
 2628     while ((c != 0) &amp;&amp; (c != end) &amp;&amp; /* non input consuming loop */
<span class="line-modified"> 2629        (c != end2) &amp;&amp; (c != end3)) {</span>

 2630 
 2631     if (c == 0) break;
 2632         if ((c == &#39;&amp;&#39;) &amp;&amp; (str[1] == &#39;#&#39;)) {
 2633         int val = xmlParseStringCharRef(ctxt, &amp;str);
 2634         if (val == 0)
 2635                 goto int_error;
 2636         COPY_BUF(0,buffer,nbchars,val);
 2637         if (nbchars + XML_PARSER_BUFFER_SIZE &gt; buffer_size) {
 2638             growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
 2639         }
 2640     } else if ((c == &#39;&amp;&#39;) &amp;&amp; (what &amp; XML_SUBSTITUTE_REF)) {
 2641         if (xmlParserDebugEntities)
 2642         xmlGenericError(xmlGenericErrorContext,
 2643             &quot;String decoding Entity Reference: %.30s\n&quot;,
 2644             str);
 2645         ent = xmlParseStringEntityRef(ctxt, &amp;str);
 2646         xmlParserEntityCheck(ctxt, 0, ent, 0);
 2647         if (ent != NULL)
 2648             ctxt-&gt;nbentities += ent-&gt;checked / 2;
 2649         if ((ent != NULL) &amp;&amp;
</pre>
<hr />
<pre>
 2685         if (nbchars + i + XML_PARSER_BUFFER_SIZE &gt; buffer_size) {
 2686             growBuffer(buffer, i + XML_PARSER_BUFFER_SIZE);
 2687         }
 2688         for (;i &gt; 0;i--)
 2689             buffer[nbchars++] = *cur++;
 2690         buffer[nbchars++] = &#39;;&#39;;
 2691         }
 2692     } else if (c == &#39;%&#39; &amp;&amp; (what &amp; XML_SUBSTITUTE_PEREF)) {
 2693         if (xmlParserDebugEntities)
 2694         xmlGenericError(xmlGenericErrorContext,
 2695             &quot;String decoding PE Reference: %.30s\n&quot;, str);
 2696         ent = xmlParseStringPEReference(ctxt, &amp;str);
 2697         xmlParserEntityCheck(ctxt, 0, ent, 0);
 2698         if (ent != NULL)
 2699             ctxt-&gt;nbentities += ent-&gt;checked / 2;
 2700         if (ent != NULL) {
 2701                 if (ent-&gt;content == NULL) {
 2702             /*
 2703              * Note: external parsed entities will not be loaded,
 2704              * it is not required for a non-validating parser to
<span class="line-modified"> 2705              * complete external PEreferences coming from the</span>
 2706              * internal subset
 2707              */
 2708             if (((ctxt-&gt;options &amp; XML_PARSE_NOENT) != 0) ||
 2709             ((ctxt-&gt;options &amp; XML_PARSE_DTDVALID) != 0) ||
 2710             (ctxt-&gt;validate != 0)) {
 2711             xmlLoadEntityContent(ctxt, ent);
 2712             } else {
 2713             xmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
 2714           &quot;not validating will not read content for PE entity %s\n&quot;,
 2715                               ent-&gt;name, NULL);
 2716             }
 2717         }
 2718         ctxt-&gt;depth++;
 2719         rep = xmlStringDecodeEntities(ctxt, ent-&gt;content, what,
 2720                                   0, 0, 0);
 2721         ctxt-&gt;depth--;
 2722         if (rep == NULL)
 2723                     goto int_error;
 2724                 current = rep;
 2725                 while (*current != 0) { /* non input consuming loop */
</pre>
<hr />
<pre>
 3349        (xmlIsNameChar(ctxt, c) &amp;&amp; (c != &#39;:&#39;))) {
 3350     if (count++ &gt; XML_PARSER_CHUNK_SIZE) {
 3351             if ((len &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3352                 ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3353                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;NCName&quot;);
 3354                 return(NULL);
 3355             }
 3356         count = 0;
 3357         GROW;
 3358             if (ctxt-&gt;instate == XML_PARSER_EOF)
 3359                 return(NULL);
 3360     }
 3361     len += l;
 3362     NEXTL(l);
 3363     c = CUR_CHAR(l);
 3364     if (c == 0) {
 3365         count = 0;
 3366         /*
 3367          * when shrinking to extend the buffer we really need to preserve
 3368          * the part of the name we already parsed. Hence rolling back
<span class="line-modified"> 3369          * by current lenght.</span>
 3370          */
 3371         ctxt-&gt;input-&gt;cur -= l;
 3372         GROW;
 3373             if (ctxt-&gt;instate == XML_PARSER_EOF)
 3374                 return(NULL);
 3375         ctxt-&gt;input-&gt;cur += l;
 3376         c = CUR_CHAR(l);
 3377     }
 3378     }
 3379     if ((len &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3380         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3381         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;NCName&quot;);
 3382         return(NULL);
 3383     }
 3384     return(xmlDictLookup(ctxt-&gt;dict, (BASE_PTR + startPosition), len));
 3385 }
 3386 
 3387 /**
 3388  * xmlParseNCName:
 3389  * @ctxt:  an XML parser context
</pre>
<hr />
<pre>
 3818      */
 3819     ++ctxt-&gt;depth;
 3820     ret = xmlStringDecodeEntities(ctxt, buf, XML_SUBSTITUTE_PEREF,
 3821                                   0, 0, 0);
 3822     --ctxt-&gt;depth;
 3823     if (orig != NULL) {
 3824         *orig = buf;
 3825         buf = NULL;
 3826     }
 3827 
 3828 error:
 3829     if (buf != NULL)
 3830         xmlFree(buf);
 3831     return(ret);
 3832 }
 3833 
 3834 /**
 3835  * xmlParseAttValueComplex:
 3836  * @ctxt:  an XML parser context
 3837  * @len:   the resulting attribute len
<span class="line-modified"> 3838  * @normalize:  wether to apply the inner normalization</span>
 3839  *
 3840  * parse a value for an attribute, this is the fallback function
 3841  * of xmlParseAttValue() when the attribute parsing requires handling
 3842  * of non-ASCII characters, or normalization compaction.
 3843  *
 3844  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.
 3845  */
 3846 static xmlChar *
 3847 xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
 3848     xmlChar limit = 0;
 3849     xmlChar *buf = NULL;
 3850     xmlChar *rep = NULL;
 3851     size_t len = 0;
 3852     size_t buf_size = 0;
 3853     int c, l, in_space = 0;
 3854     xmlChar *current = NULL;
 3855     xmlEntityPtr ent;
 3856 
 3857     if (NXT(0) == &#39;&quot;&#39;) {
 3858     ctxt-&gt;instate = XML_PARSER_ATTRIBUTE_VALUE;
</pre>
<hr />
<pre>
 3967                 xmlFree(rep);
 3968                 rep = NULL;
 3969             }
 3970             } else {
 3971             if (len + 10 &gt; buf_size) {
 3972                 growBuffer(buf, 10);
 3973             }
 3974             if (ent-&gt;content != NULL)
 3975                 buf[len++] = ent-&gt;content[0];
 3976             }
 3977         } else if (ent != NULL) {
 3978             int i = xmlStrlen(ent-&gt;name);
 3979             const xmlChar *cur = ent-&gt;name;
 3980 
 3981             /*
 3982              * This may look absurd but is needed to detect
 3983              * entities problems
 3984              */
 3985             if ((ent-&gt;etype != XML_INTERNAL_PREDEFINED_ENTITY) &amp;&amp;
 3986             (ent-&gt;content != NULL) &amp;&amp; (ent-&gt;checked == 0)) {
<span class="line-modified"> 3987             unsigned long oldnbent = ctxt-&gt;nbentities;</span>
 3988 
 3989             ++ctxt-&gt;depth;
 3990             rep = xmlStringDecodeEntities(ctxt, ent-&gt;content,
 3991                           XML_SUBSTITUTE_REF, 0, 0, 0);
 3992             --ctxt-&gt;depth;
 3993 
<span class="line-modified"> 3994             ent-&gt;checked = (ctxt-&gt;nbentities - oldnbent + 1) * 2;</span>



 3995             if (rep != NULL) {
 3996                 if (xmlStrchr(rep, &#39;&lt;&#39;))
 3997                     ent-&gt;checked |= 1;
 3998                 xmlFree(rep);
 3999                 rep = NULL;
 4000             } else {
 4001                             ent-&gt;content[0] = 0;
 4002                         }
 4003             }
 4004 
 4005             /*
 4006              * Just output the reference
 4007              */
 4008             buf[len++] = &#39;&amp;&#39;;
 4009             while (len + i + 10 &gt; buf_size) {
 4010             growBuffer(buf, i + 10);
 4011             }
 4012             for (;i &gt; 0;i--)
 4013             buf[len++] = *cur++;
 4014             buf[len++] = &#39;;&#39;;
</pre>
<hr />
<pre>
 4042 
 4043     if ((in_space) &amp;&amp; (normalize)) {
 4044         while ((len &gt; 0) &amp;&amp; (buf[len - 1] == 0x20)) len--;
 4045     }
 4046     buf[len] = 0;
 4047     if (RAW == &#39;&lt;&#39;) {
 4048     xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);
 4049     } else if (RAW != limit) {
 4050     if ((c != 0) &amp;&amp; (!IS_CHAR(c))) {
 4051         xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
 4052                &quot;invalid character in attribute value\n&quot;);
 4053     } else {
 4054         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 4055                &quot;AttValue: &#39; expected\n&quot;);
 4056         }
 4057     } else
 4058     NEXT;
 4059 
 4060     /*
 4061      * There we potentially risk an overflow, don&#39;t allow attribute value of
<span class="line-modified"> 4062      * length more than INT_MAX it is a very reasonnable assumption !</span>
 4063      */
 4064     if (len &gt;= INT_MAX) {
 4065         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 4066                        &quot;AttValue length too long\n&quot;);
 4067         goto mem_error;
 4068     }
 4069 
 4070     if (attlen != NULL) *attlen = (int) len;
 4071     return(buf);
 4072 
 4073 mem_error:
 4074     xmlErrMemory(ctxt, NULL);
 4075 error:
 4076     if (buf != NULL)
 4077         xmlFree(buf);
 4078     if (rep != NULL)
 4079         xmlFree(rep);
 4080     return(NULL);
 4081 }
 4082 
</pre>
<hr />
<pre>
 4647          * We handle [83] so we return immediately, if
 4648          * &quot;S SystemLiteral&quot; is not detected. We skip blanks if no
 4649              * system literal was found, but this is harmless since we must
 4650              * be at the end of a NotationDecl.
 4651          */
 4652         if (SKIP_BLANKS == 0) return(NULL);
 4653         if ((CUR != &#39;\&#39;&#39;) &amp;&amp; (CUR != &#39;&quot;&#39;)) return(NULL);
 4654     }
 4655     URI = xmlParseSystemLiteral(ctxt);
 4656     if (URI == NULL) {
 4657         xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);
 4658         }
 4659     }
 4660     return(URI);
 4661 }
 4662 
 4663 /**
 4664  * xmlParseCommentComplex:
 4665  * @ctxt:  an XML parser context
 4666  * @buf:  the already parsed part of the buffer
<span class="line-modified"> 4667  * @len:  number of bytes filles in the buffer</span>
 4668  * @size:  allocated size of the buffer
 4669  *
 4670  * Skip an XML (SGML) comment &lt;!-- .... --&gt;
 4671  *  The spec says that &quot;For compatibility, the string &quot;--&quot; (double-hyphen)
 4672  *  must not occur within comments. &quot;
 4673  * This is the slow routine in case the accelerator for ascii didn&#39;t work
 4674  *
 4675  * [15] Comment ::= &#39;&lt;!--&#39; ((Char - &#39;-&#39;) | (&#39;-&#39; (Char - &#39;-&#39;)))* &#39;--&gt;&#39;
 4676  */
 4677 static void
 4678 xmlParseCommentComplex(xmlParserCtxtPtr ctxt, xmlChar *buf,
 4679                        size_t len, size_t size) {
 4680     int q, ql;
 4681     int r, rl;
 4682     int cur, l;
 4683     size_t count = 0;
 4684     int inputid;
 4685 
 4686     inputid = ctxt-&gt;input-&gt;id;
 4687 
</pre>
<hr />
<pre>
 4938                 (!ctxt-&gt;disableSAX)) {
 4939             if (buf != NULL)
 4940                 ctxt-&gt;sax-&gt;comment(ctxt-&gt;userData, buf);
 4941             else
 4942                 ctxt-&gt;sax-&gt;comment(ctxt-&gt;userData, BAD_CAST &quot;&quot;);
 4943             }
 4944             if (buf != NULL)
 4945                 xmlFree(buf);
 4946             if (ctxt-&gt;instate != XML_PARSER_EOF)
 4947             ctxt-&gt;instate = state;
 4948             return;
 4949         }
 4950         if (buf != NULL) {
 4951             xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
 4952                               &quot;Double hyphen within comment: &quot;
 4953                                       &quot;&lt;!--%.50s\n&quot;,
 4954                       buf);
 4955         } else
 4956             xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
 4957                               &quot;Double hyphen within comment\n&quot;, NULL);




 4958         in++;
 4959         ctxt-&gt;input-&gt;col++;
 4960         }
 4961         in++;
 4962         ctxt-&gt;input-&gt;col++;
 4963         goto get_more;
 4964     }
 4965     } while (((*in &gt;= 0x20) &amp;&amp; (*in &lt;= 0x7F)) || (*in == 0x09));
 4966     xmlParseCommentComplex(ctxt, buf, len, size);
 4967     ctxt-&gt;instate = state;
 4968     return;
 4969 }
 4970 
 4971 
 4972 /**
 4973  * xmlParsePITarget:
 4974  * @ctxt:  an XML parser context
 4975  *
 4976  * parse the name of a PI
 4977  *
</pre>
<hr />
<pre>
 5068     }
 5069     return;
 5070 
 5071 error:
 5072     xmlWarningMsg(ctxt, XML_WAR_CATALOG_PI,
 5073               &quot;Catalog PI syntax error: %s\n&quot;,
 5074           catalog, NULL);
 5075     if (URL != NULL)
 5076     xmlFree(URL);
 5077 }
 5078 #endif
 5079 
 5080 /**
 5081  * xmlParsePI:
 5082  * @ctxt:  an XML parser context
 5083  *
 5084  * parse an XML Processing Instruction.
 5085  *
 5086  * [16] PI ::= &#39;&lt;?&#39; PITarget (S (Char* - (Char* &#39;?&gt;&#39; Char*)))? &#39;?&gt;&#39;
 5087  *
<span class="line-modified"> 5088  * The processing is transfered to SAX once parsed.</span>
 5089  */
 5090 
 5091 void
 5092 xmlParsePI(xmlParserCtxtPtr ctxt) {
 5093     xmlChar *buf = NULL;
 5094     size_t len = 0;
 5095     size_t size = XML_PARSER_BUFFER_SIZE;
 5096     int cur, l;
 5097     const xmlChar *target;
 5098     xmlParserInputState state;
 5099     int count = 0;
 5100 
 5101     if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;?&#39;)) {
 5102     int inputid = ctxt-&gt;input-&gt;id;
 5103     state = ctxt-&gt;instate;
 5104         ctxt-&gt;instate = XML_PARSER_PI;
 5105     /*
 5106      * this is a Processing Instruction.
 5107      */
 5108     SKIP(2);
</pre>
<hr />
<pre>
 5484         }
 5485         if (CMP5(CUR_PTR, &#39;N&#39;, &#39;D&#39;, &#39;A&#39;, &#39;T&#39;, &#39;A&#39;)) {
 5486             SKIP(5);
 5487             if (SKIP_BLANKS == 0) {
 5488             xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5489                        &quot;Space required after &#39;NDATA&#39;\n&quot;);
 5490             }
 5491             ndata = xmlParseName(ctxt);
 5492             if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX) &amp;&amp;
 5493                 (ctxt-&gt;sax-&gt;unparsedEntityDecl != NULL))
 5494             ctxt-&gt;sax-&gt;unparsedEntityDecl(ctxt-&gt;userData, name,
 5495                     literal, URI, ndata);
 5496         } else {
 5497             if ((ctxt-&gt;sax != NULL) &amp;&amp;
 5498                 (!ctxt-&gt;disableSAX) &amp;&amp; (ctxt-&gt;sax-&gt;entityDecl != NULL))
 5499             ctxt-&gt;sax-&gt;entityDecl(ctxt-&gt;userData, name,
 5500                     XML_EXTERNAL_GENERAL_PARSED_ENTITY,
 5501                     literal, URI, NULL);
 5502             /*
 5503              * For expat compatibility in SAX mode.
<span class="line-modified"> 5504              * assuming the entity repalcement was asked for</span>
 5505              */
 5506             if ((ctxt-&gt;replaceEntities != 0) &amp;&amp;
 5507             ((ctxt-&gt;myDoc == NULL) ||
 5508             (xmlStrEqual(ctxt-&gt;myDoc-&gt;version, SAX_COMPAT_MODE)))) {
 5509             if (ctxt-&gt;myDoc == NULL) {
 5510                 ctxt-&gt;myDoc = xmlNewDoc(SAX_COMPAT_MODE);
 5511                 if (ctxt-&gt;myDoc == NULL) {
 5512                     xmlErrMemory(ctxt, &quot;New Doc failed&quot;);
 5513                 return;
 5514                 }
 5515                 ctxt-&gt;myDoc-&gt;properties = XML_DOC_INTERNAL;
 5516             }
 5517 
 5518             if (ctxt-&gt;myDoc-&gt;intSubset == NULL)
 5519                 ctxt-&gt;myDoc-&gt;intSubset = xmlNewDtd(ctxt-&gt;myDoc,
 5520                         BAD_CAST &quot;fake&quot;, NULL, NULL);
 5521             xmlSAX2EntityDecl(ctxt, name,
 5522                           XML_EXTERNAL_GENERAL_PARSED_ENTITY,
 5523                           literal, URI, NULL);
 5524             }
</pre>
<hr />
<pre>
 6594         xmlFreeDocElementContent(ctxt-&gt;myDoc, content);
 6595         }
 6596     }
 6597     }
 6598     return(ret);
 6599 }
 6600 
 6601 /**
 6602  * xmlParseConditionalSections
 6603  * @ctxt:  an XML parser context
 6604  *
 6605  * [61] conditionalSect ::= includeSect | ignoreSect
 6606  * [62] includeSect ::= &#39;&lt;![&#39; S? &#39;INCLUDE&#39; S? &#39;[&#39; extSubsetDecl &#39;]]&gt;&#39;
 6607  * [63] ignoreSect ::= &#39;&lt;![&#39; S? &#39;IGNORE&#39; S? &#39;[&#39; ignoreSectContents* &#39;]]&gt;&#39;
 6608  * [64] ignoreSectContents ::= Ignore (&#39;&lt;![&#39; ignoreSectContents &#39;]]&gt;&#39; Ignore)*
 6609  * [65] Ignore ::= Char* - (Char* (&#39;&lt;![&#39; | &#39;]]&gt;&#39;) Char*)
 6610  */
 6611 
 6612 static void
 6613 xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {






 6614     int id = ctxt-&gt;input-&gt;id;
 6615 
 6616     SKIP(3);
 6617     SKIP_BLANKS;

 6618     if (CMP7(CUR_PTR, &#39;I&#39;, &#39;N&#39;, &#39;C&#39;, &#39;L&#39;, &#39;U&#39;, &#39;D&#39;, &#39;E&#39;)) {
 6619     SKIP(7);
 6620     SKIP_BLANKS;
 6621     if (RAW != &#39;[&#39;) {
 6622         xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
 6623         xmlHaltParser(ctxt);
<span class="line-modified"> 6624         return;</span>
<span class="line-modified"> 6625     } else {</span>
 6626         if (ctxt-&gt;input-&gt;id != id) {
 6627         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
<span class="line-modified"> 6628                            &quot;All markup of the conditional section is not&quot;</span>
<span class="line-modified"> 6629                                &quot; in the same entity\n&quot;);</span>
 6630         }
 6631         NEXT;
<span class="line-removed"> 6632     }</span>
<span class="line-removed"> 6633     if (xmlParserDebugEntities) {</span>
<span class="line-removed"> 6634         if ((ctxt-&gt;input != NULL) &amp;&amp; (ctxt-&gt;input-&gt;filename))</span>
<span class="line-removed"> 6635         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed"> 6636             &quot;%s(%d): &quot;, ctxt-&gt;input-&gt;filename,</span>
<span class="line-removed"> 6637             ctxt-&gt;input-&gt;line);</span>
<span class="line-removed"> 6638         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed"> 6639             &quot;Entering INCLUDE Conditional Section\n&quot;);</span>
<span class="line-removed"> 6640     }</span>
 6641 
<span class="line-modified"> 6642         SKIP_BLANKS;</span>
<span class="line-modified"> 6643         GROW;</span>
<span class="line-removed"> 6644     while (((RAW != 0) &amp;&amp; ((RAW != &#39;]&#39;) || (NXT(1) != &#39;]&#39;) ||</span>
<span class="line-removed"> 6645             (NXT(2) != &#39;&gt;&#39;))) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF)) {</span>
<span class="line-removed"> 6646         const xmlChar *check = CUR_PTR;</span>
<span class="line-removed"> 6647         unsigned int cons = ctxt-&gt;input-&gt;consumed;</span>
<span class="line-removed"> 6648 </span>
<span class="line-removed"> 6649         if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {</span>
<span class="line-removed"> 6650         xmlParseConditionalSections(ctxt);</span>
<span class="line-removed"> 6651         } else</span>
<span class="line-removed"> 6652         xmlParseMarkupDecl(ctxt);</span>
<span class="line-removed"> 6653 </span>
<span class="line-removed"> 6654             SKIP_BLANKS;</span>
<span class="line-removed"> 6655             GROW;</span>
 6656 
<span class="line-modified"> 6657         if ((CUR_PTR == check) &amp;&amp; (cons == ctxt-&gt;input-&gt;consumed)) {</span>
<span class="line-modified"> 6658         xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);</span>
<span class="line-modified"> 6659         xmlHaltParser(ctxt);</span>
<span class="line-modified"> 6660         break;</span>


 6661         }

 6662     }
<span class="line-modified"> 6663     if (xmlParserDebugEntities) {</span>
<span class="line-modified"> 6664         if ((ctxt-&gt;input != NULL) &amp;&amp; (ctxt-&gt;input-&gt;filename))</span>
<span class="line-removed"> 6665         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed"> 6666             &quot;%s(%d): &quot;, ctxt-&gt;input-&gt;filename,</span>
<span class="line-removed"> 6667             ctxt-&gt;input-&gt;line);</span>
<span class="line-removed"> 6668         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed"> 6669             &quot;Leaving INCLUDE Conditional Section\n&quot;);</span>
<span class="line-removed"> 6670     }</span>
<span class="line-removed"> 6671 </span>
 6672     } else if (CMP6(CUR_PTR, &#39;I&#39;, &#39;G&#39;, &#39;N&#39;, &#39;O&#39;, &#39;R&#39;, &#39;E&#39;)) {
 6673     int state;
 6674     xmlParserInputState instate;
<span class="line-modified"> 6675     int depth = 0;</span>
 6676 
 6677     SKIP(6);
 6678     SKIP_BLANKS;
 6679     if (RAW != &#39;[&#39;) {
 6680         xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
 6681         xmlHaltParser(ctxt);
<span class="line-modified"> 6682         return;</span>
<span class="line-modified"> 6683     } else {</span>
 6684         if (ctxt-&gt;input-&gt;id != id) {
 6685         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
<span class="line-modified"> 6686                            &quot;All markup of the conditional section is not&quot;</span>
<span class="line-modified"> 6687                                &quot; in the same entity\n&quot;);</span>
 6688         }
 6689         NEXT;
<span class="line-removed"> 6690     }</span>
<span class="line-removed"> 6691     if (xmlParserDebugEntities) {</span>
<span class="line-removed"> 6692         if ((ctxt-&gt;input != NULL) &amp;&amp; (ctxt-&gt;input-&gt;filename))</span>
<span class="line-removed"> 6693         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed"> 6694             &quot;%s(%d): &quot;, ctxt-&gt;input-&gt;filename,</span>
<span class="line-removed"> 6695             ctxt-&gt;input-&gt;line);</span>
<span class="line-removed"> 6696         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed"> 6697             &quot;Entering IGNORE Conditional Section\n&quot;);</span>
<span class="line-removed"> 6698     }</span>
 6699 
 6700     /*
<span class="line-modified"> 6701      * Parse up to the end of the conditional section</span>
<span class="line-modified"> 6702      * But disable SAX event generating DTD building in the meantime</span>
 6703      */
 6704     state = ctxt-&gt;disableSAX;
 6705     instate = ctxt-&gt;instate;
 6706     if (ctxt-&gt;recovery == 0) ctxt-&gt;disableSAX = 1;
 6707     ctxt-&gt;instate = XML_PARSER_IGNORE;
 6708 
<span class="line-modified"> 6709     while (((depth &gt;= 0) &amp;&amp; (RAW != 0)) &amp;&amp;</span>
<span class="line-removed"> 6710                (ctxt-&gt;instate != XML_PARSER_EOF)) {</span>
 6711       if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {
<span class="line-removed"> 6712         depth++;</span>
 6713         SKIP(3);
<span class="line-modified"> 6714         continue;</span>
<span class="line-modified"> 6715       }</span>
<span class="line-modified"> 6716       if ((RAW == &#39;]&#39;) &amp;&amp; (NXT(1) == &#39;]&#39;) &amp;&amp; (NXT(2) == &#39;&gt;&#39;)) {</span>
<span class="line-modified"> 6717         if (--depth &gt;= 0) SKIP(3);</span>
<span class="line-modified"> 6718         continue;</span>
 6719       }







 6720       NEXT;
<span class="line-modified"> 6721       continue;</span>
 6722     }
 6723 
 6724     ctxt-&gt;disableSAX = state;
 6725     ctxt-&gt;instate = instate;
 6726 
<span class="line-modified"> 6727     if (xmlParserDebugEntities) {</span>
<span class="line-modified"> 6728         if ((ctxt-&gt;input != NULL) &amp;&amp; (ctxt-&gt;input-&gt;filename))</span>
<span class="line-modified"> 6729         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed"> 6730             &quot;%s(%d): &quot;, ctxt-&gt;input-&gt;filename,</span>
<span class="line-removed"> 6731             ctxt-&gt;input-&gt;line);</span>
<span class="line-removed"> 6732         xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-removed"> 6733             &quot;Leaving IGNORE Conditional Section\n&quot;);</span>
 6734     }
<span class="line-modified"> 6735 </span>





 6736     } else {
 6737     xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID_KEYWORD, NULL);
 6738     xmlHaltParser(ctxt);
<span class="line-modified"> 6739     return;</span>
 6740     }
<span class="line-modified"> 6741 </span>
<span class="line-modified"> 6742     if (RAW == 0)</span>
<span class="line-modified"> 6743         SHRINK;</span>
<span class="line-modified"> 6744 </span>
<span class="line-removed"> 6745     if (RAW == 0) {</span>
<span class="line-removed"> 6746     xmlFatalErr(ctxt, XML_ERR_CONDSEC_NOT_FINISHED, NULL);</span>
<span class="line-removed"> 6747     } else {</span>
<span class="line-removed"> 6748     if (ctxt-&gt;input-&gt;id != id) {</span>
 6749         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
<span class="line-modified"> 6750                        &quot;All markup of the conditional section is not in&quot;</span>
<span class="line-modified"> 6751                            &quot; the same entity\n&quot;);</span>
 6752     }
<span class="line-removed"> 6753     if ((ctxt-&gt; instate != XML_PARSER_EOF) &amp;&amp;</span>
<span class="line-removed"> 6754         ((ctxt-&gt;input-&gt;cur + 3) &lt;= ctxt-&gt;input-&gt;end))</span>
 6755         SKIP(3);


















 6756     }



 6757 }
 6758 
 6759 /**
 6760  * xmlParseMarkupDecl:
 6761  * @ctxt:  an XML parser context
 6762  *
 6763  * parse Markup declarations
 6764  *
 6765  * [29] markupdecl ::= elementdecl | AttlistDecl | EntityDecl |
 6766  *                     NotationDecl | PI | Comment
 6767  *
 6768  * [ VC: Proper Declaration/PE Nesting ]
 6769  * Parameter-entity replacement text must be properly nested with
 6770  * markup declarations. That is to say, if either the first character
 6771  * or the last character of a markup declaration (markupdecl above) is
 6772  * contained in the replacement text for a parameter-entity reference,
 6773  * both must be contained in the same replacement text.
 6774  *
 6775  * [ WFC: PEs in Internal Subset ]
 6776  * In the internal DTD subset, parameter-entity references can occur
</pre>
<hr />
<pre>
 6793             case &#39;A&#39;:
 6794             xmlParseAttributeListDecl(ctxt);
 6795             break;
 6796             case &#39;N&#39;:
 6797             xmlParseNotationDecl(ctxt);
 6798             break;
 6799             case &#39;-&#39;:
 6800             xmlParseComment(ctxt);
 6801             break;
 6802         default:
 6803             /* there is an error but it will be detected later */
 6804             break;
 6805         }
 6806     } else if (NXT(1) == &#39;?&#39;) {
 6807         xmlParsePI(ctxt);
 6808     }
 6809     }
 6810 
 6811     /*
 6812      * detect requirement to exit there and act accordingly
<span class="line-modified"> 6813      * and avoid having instate overriden later on</span>
 6814      */
 6815     if (ctxt-&gt;instate == XML_PARSER_EOF)
 6816         return;
 6817 
<span class="line-removed"> 6818     /*</span>
<span class="line-removed"> 6819      * Conditional sections are allowed from entities included</span>
<span class="line-removed"> 6820      * by PE References in the internal subset.</span>
<span class="line-removed"> 6821      */</span>
<span class="line-removed"> 6822     if ((ctxt-&gt;external == 0) &amp;&amp; (ctxt-&gt;inputNr &gt; 1)) {</span>
<span class="line-removed"> 6823         if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {</span>
<span class="line-removed"> 6824         xmlParseConditionalSections(ctxt);</span>
<span class="line-removed"> 6825     }</span>
<span class="line-removed"> 6826     }</span>
<span class="line-removed"> 6827 </span>
 6828     ctxt-&gt;instate = XML_PARSER_DTD;
 6829 }
 6830 
 6831 /**
 6832  * xmlParseTextDecl:
 6833  * @ctxt:  an XML parser context
 6834  *
 6835  * parse an XML declaration header for external entities
 6836  *
 6837  * [77] TextDecl ::= &#39;&lt;?xml&#39; VersionInfo? EncodingDecl S? &#39;?&gt;&#39;
 6838  */
 6839 
 6840 void
 6841 xmlParseTextDecl(xmlParserCtxtPtr ctxt) {
 6842     xmlChar *version;
 6843     const xmlChar *encoding;
 6844 
 6845     /*
 6846      * We know that &#39;&lt;?xml&#39; is here.
 6847      */
</pre>
<hr />
<pre>
 6992  *
 6993  * [67] Reference ::= EntityRef | CharRef
 6994  */
 6995 void
 6996 xmlParseReference(xmlParserCtxtPtr ctxt) {
 6997     xmlEntityPtr ent;
 6998     xmlChar *val;
 6999     int was_checked;
 7000     xmlNodePtr list = NULL;
 7001     xmlParserErrors ret = XML_ERR_OK;
 7002 
 7003 
 7004     if (RAW != &#39;&amp;&#39;)
 7005         return;
 7006 
 7007     /*
 7008      * Simple case of a CharRef
 7009      */
 7010     if (NXT(1) == &#39;#&#39;) {
 7011     int i = 0;
<span class="line-modified"> 7012     xmlChar out[10];</span>
 7013     int hex = NXT(2);
 7014     int value = xmlParseCharRef(ctxt);
 7015 
 7016     if (value == 0)
 7017         return;
 7018     if (ctxt-&gt;charset != XML_CHAR_ENCODING_UTF8) {
 7019         /*
 7020          * So we are using non-UTF-8 buffers
 7021          * Check that the char fit on 8bits, if not
 7022          * generate a CharRef.
 7023          */
 7024         if (value &lt;= 0xFF) {
 7025         out[0] = value;
 7026         out[1] = 0;
 7027         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;characters != NULL) &amp;&amp;
 7028             (!ctxt-&gt;disableSAX))
 7029             ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, out, 1);
 7030         } else {
 7031         if ((hex == &#39;x&#39;) || (hex == &#39;X&#39;))
 7032             snprintf((char *)out, sizeof(out), &quot;#x%X&quot;, value);
</pre>
<hr />
<pre>
 7069     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;characters != NULL) &amp;&amp;
 7070         (!ctxt-&gt;disableSAX))
 7071         ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, val, xmlStrlen(val));
 7072     return;
 7073     }
 7074 
 7075     /*
 7076      * The first reference to the entity trigger a parsing phase
 7077      * where the ent-&gt;children is filled with the result from
 7078      * the parsing.
 7079      * Note: external parsed entities will not be loaded, it is not
 7080      * required for a non-validating parser, unless the parsing option
 7081      * of validating, or substituting entities were given. Doing so is
 7082      * far more secure as the parser will only process data coming from
 7083      * the document entity by default.
 7084      */
 7085     if (((ent-&gt;checked == 0) ||
 7086          ((ent-&gt;children == NULL) &amp;&amp; (ctxt-&gt;options &amp; XML_PARSE_NOENT))) &amp;&amp;
 7087         ((ent-&gt;etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
 7088          (ctxt-&gt;options &amp; (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {
<span class="line-modified"> 7089     unsigned long oldnbent = ctxt-&gt;nbentities;</span>
 7090 
 7091     /*
 7092      * This is a bit hackish but this seems the best
 7093      * way to make sure both SAX and DOM entity support
 7094      * behaves okay.
 7095      */
 7096     void *user_data;
 7097     if (ctxt-&gt;userData == ctxt)
 7098         user_data = NULL;
 7099     else
 7100         user_data = ctxt-&gt;userData;
 7101 
 7102     /*
 7103      * Check that this entity is well formed
 7104      * 4.3.2: An internal general parsed entity is well-formed
 7105      * if its replacement text matches the production labeled
 7106      * content.
 7107      */
 7108     if (ent-&gt;etype == XML_INTERNAL_GENERAL_ENTITY) {
 7109         ctxt-&gt;depth++;
 7110         ret = xmlParseBalancedChunkMemoryInternal(ctxt, ent-&gt;content,
 7111                                                   user_data, &amp;list);
 7112         ctxt-&gt;depth--;
 7113 
 7114     } else if (ent-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
 7115         ctxt-&gt;depth++;
 7116         ret = xmlParseExternalEntityPrivate(ctxt-&gt;myDoc, ctxt, ctxt-&gt;sax,
 7117                                        user_data, ctxt-&gt;depth, ent-&gt;URI,
 7118                        ent-&gt;ExternalID, &amp;list);
 7119         ctxt-&gt;depth--;
 7120     } else {
 7121         ret = XML_ERR_ENTITY_PE_INTERNAL;
 7122         xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,
 7123              &quot;invalid entity type found\n&quot;, NULL);
 7124     }
 7125 
 7126     /*
 7127      * Store the number of entities needing parsing for this entity
 7128      * content and do checkings
 7129      */
<span class="line-modified"> 7130     ent-&gt;checked = (ctxt-&gt;nbentities - oldnbent + 1) * 2;</span>



 7131     if ((ent-&gt;content != NULL) &amp;&amp; (xmlStrchr(ent-&gt;content, &#39;&lt;&#39;)))
 7132         ent-&gt;checked |= 1;
 7133     if (ret == XML_ERR_ENTITY_LOOP) {
 7134         xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 7135         xmlFreeNodeList(list);
 7136         return;
 7137     }
 7138     if (xmlParserEntityCheck(ctxt, 0, ent, 0)) {
 7139         xmlFreeNodeList(list);
 7140         return;
 7141     }
 7142 
 7143     if ((ret == XML_ERR_OK) &amp;&amp; (list != NULL)) {
 7144         if (((ent-&gt;etype == XML_INTERNAL_GENERAL_ENTITY) ||
 7145          (ent-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY))&amp;&amp;
 7146         (ent-&gt;children == NULL)) {
 7147         ent-&gt;children = list;
 7148         if (ctxt-&gt;replaceEntities) {
 7149             /*
 7150              * Prune it directly in the generated document
</pre>
<hr />
<pre>
 7658         xmlFree(name);
 7659     *str = ptr;
 7660     return(NULL);
 7661     }
 7662     ptr++;
 7663 
 7664 
 7665     /*
 7666      * Predefined entities override any extra definition
 7667      */
 7668     if ((ctxt-&gt;options &amp; XML_PARSE_OLDSAX) == 0) {
 7669         ent = xmlGetPredefinedEntity(name);
 7670         if (ent != NULL) {
 7671             xmlFree(name);
 7672             *str = ptr;
 7673             return(ent);
 7674         }
 7675     }
 7676 
 7677     /*
<span class="line-modified"> 7678      * Increate the number of entity references parsed</span>
 7679      */
 7680     ctxt-&gt;nbentities++;
 7681 
 7682     /*
 7683      * Ask first SAX for entity resolution, otherwise try the
 7684      * entities which may have stored in the parser context.
 7685      */
 7686     if (ctxt-&gt;sax != NULL) {
 7687     if (ctxt-&gt;sax-&gt;getEntity != NULL)
 7688         ent = ctxt-&gt;sax-&gt;getEntity(ctxt-&gt;userData, name);
 7689     if ((ent == NULL) &amp;&amp; (ctxt-&gt;options &amp; XML_PARSE_OLDSAX))
 7690         ent = xmlGetPredefinedEntity(name);
 7691     if ((ent == NULL) &amp;&amp; (ctxt-&gt;userData==ctxt)) {
 7692         ent = xmlSAX2GetEntity(ctxt, name);
 7693     }
 7694     }
 7695     if (ctxt-&gt;instate == XML_PARSER_EOF) {
 7696     xmlFree(name);
 7697     return(NULL);
 7698     }
</pre>
<hr />
<pre>
 7834 
 7835     if (RAW != &#39;%&#39;)
 7836         return;
 7837     NEXT;
 7838     name = xmlParseName(ctxt);
 7839     if (name == NULL) {
 7840     xmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, &quot;PEReference: no name\n&quot;);
 7841     return;
 7842     }
 7843     if (xmlParserDebugEntities)
 7844     xmlGenericError(xmlGenericErrorContext,
 7845         &quot;PEReference: %s\n&quot;, name);
 7846     if (RAW != &#39;;&#39;) {
 7847     xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);
 7848         return;
 7849     }
 7850 
 7851     NEXT;
 7852 
 7853     /*
<span class="line-modified"> 7854      * Increate the number of entity references parsed</span>
 7855      */
 7856     ctxt-&gt;nbentities++;
 7857 
 7858     /*
 7859      * Request the entity from SAX
 7860      */
 7861     if ((ctxt-&gt;sax != NULL) &amp;&amp;
 7862     (ctxt-&gt;sax-&gt;getParameterEntity != NULL))
 7863     entity = ctxt-&gt;sax-&gt;getParameterEntity(ctxt-&gt;userData, name);
 7864     if (ctxt-&gt;instate == XML_PARSER_EOF)
 7865     return;
 7866     if (entity == NULL) {
 7867     /*
 7868      * [ WFC: Entity Declared ]
 7869      * In a document without any DTD, a document with only an
 7870      * internal DTD subset which contains no parameter entity
 7871      * references, or a document with &quot;standalone=&#39;yes&#39;&quot;, ...
 7872      * ... The declaration of a parameter entity must precede
 7873      * any reference to it...
 7874      */
</pre>
<hr />
<pre>
 8100     if (cur != &#39;%&#39;)
 8101         return(NULL);
 8102     ptr++;
 8103     name = xmlParseStringName(ctxt, &amp;ptr);
 8104     if (name == NULL) {
 8105     xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 8106                &quot;xmlParseStringPEReference: no name\n&quot;);
 8107     *str = ptr;
 8108     return(NULL);
 8109     }
 8110     cur = *ptr;
 8111     if (cur != &#39;;&#39;) {
 8112     xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
 8113     xmlFree(name);
 8114     *str = ptr;
 8115     return(NULL);
 8116     }
 8117     ptr++;
 8118 
 8119     /*
<span class="line-modified"> 8120      * Increate the number of entity references parsed</span>
 8121      */
 8122     ctxt-&gt;nbentities++;
 8123 
 8124     /*
 8125      * Request the entity from SAX
 8126      */
 8127     if ((ctxt-&gt;sax != NULL) &amp;&amp;
 8128     (ctxt-&gt;sax-&gt;getParameterEntity != NULL))
 8129     entity = ctxt-&gt;sax-&gt;getParameterEntity(ctxt-&gt;userData, name);
 8130     if (ctxt-&gt;instate == XML_PARSER_EOF) {
 8131     xmlFree(name);
 8132     *str = ptr;
 8133     return(NULL);
 8134     }
 8135     if (entity == NULL) {
 8136     /*
 8137      * [ WFC: Entity Declared ]
 8138      * In a document without any DTD, a document with only an
 8139      * internal DTD subset which contains no parameter entity
 8140      * references, or a document with &quot;standalone=&#39;yes&#39;&quot;, ...
</pre>
<hr />
<pre>
 8268      * Is there any DTD definition ?
 8269      */
 8270     if (RAW == &#39;[&#39;) {
 8271         int baseInputNr = ctxt-&gt;inputNr;
 8272         ctxt-&gt;instate = XML_PARSER_DTD;
 8273         NEXT;
 8274     /*
 8275      * Parse the succession of Markup declarations and
 8276      * PEReferences.
 8277      * Subsequence (markupdecl | PEReference | S)*
 8278      */
 8279     while (((RAW != &#39;]&#39;) || (ctxt-&gt;inputNr &gt; baseInputNr)) &amp;&amp;
 8280                (ctxt-&gt;instate != XML_PARSER_EOF)) {
 8281         const xmlChar *check = CUR_PTR;
 8282         unsigned int cons = ctxt-&gt;input-&gt;consumed;
 8283 
 8284         SKIP_BLANKS;
 8285         xmlParseMarkupDecl(ctxt);
 8286         xmlParsePEReference(ctxt);
 8287 









 8288         if ((CUR_PTR == check) &amp;&amp; (cons == ctxt-&gt;input-&gt;consumed)) {
 8289         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 8290          &quot;xmlParseInternalSubset: error detected in Markup declaration\n&quot;);
 8291                 if (ctxt-&gt;inputNr &gt; baseInputNr)
 8292                     xmlPopInput(ctxt);
 8293                 else
 8294             break;
 8295         }
 8296     }
 8297     if (RAW == &#39;]&#39;) {
 8298         NEXT;
 8299         SKIP_BLANKS;
 8300     }
 8301     }
 8302 
 8303     /*
 8304      * We should be at the end of the DOCTYPE declaration.
 8305      */
 8306     if (RAW != &#39;&gt;&#39;) {
 8307     xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);
</pre>
<hr />
<pre>
 8696     l = xmlParseNCName(ctxt);
 8697     if (l == NULL) {
 8698         if (CUR == &#39;:&#39;) {
 8699         l = xmlParseName(ctxt);
 8700         if (l != NULL) {
 8701             xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8702                  &quot;Failed to parse QName &#39;%s&#39;\n&quot;, l, NULL, NULL);
 8703         *prefix = NULL;
 8704         return(l);
 8705         }
 8706     }
 8707         return(NULL);
 8708     }
 8709     if (CUR == &#39;:&#39;) {
 8710         NEXT;
 8711     p = l;
 8712     l = xmlParseNCName(ctxt);
 8713     if (l == NULL) {
 8714         xmlChar *tmp;
 8715 


 8716             xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8717                  &quot;Failed to parse QName &#39;%s:&#39;\n&quot;, p, NULL, NULL);
 8718         l = xmlParseNmtoken(ctxt);
<span class="line-modified"> 8719         if (l == NULL)</span>


 8720         tmp = xmlBuildQName(BAD_CAST &quot;&quot;, p, NULL, 0);
<span class="line-modified"> 8721         else {</span>
 8722         tmp = xmlBuildQName(l, p, NULL, 0);
 8723         xmlFree((char *)l);
 8724         }
 8725         p = xmlDictLookup(ctxt-&gt;dict, tmp, -1);
 8726         if (tmp != NULL) xmlFree(tmp);
 8727         *prefix = NULL;
 8728         return(p);
 8729     }
 8730     if (CUR == &#39;:&#39;) {
 8731         xmlChar *tmp;
 8732 
 8733             xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8734                  &quot;Failed to parse QName &#39;%s:%s:&#39;\n&quot;, p, l, NULL);
 8735         NEXT;
 8736         tmp = (xmlChar *) xmlParseName(ctxt);
 8737         if (tmp != NULL) {
 8738             tmp = xmlBuildQName(tmp, l, NULL, 0);
 8739         l = xmlDictLookup(ctxt-&gt;dict, tmp, -1);
 8740         if (tmp != NULL) xmlFree(tmp);
 8741         *prefix = p;
 8742         return(l);
 8743         }


 8744         tmp = xmlBuildQName(BAD_CAST &quot;&quot;, l, NULL, 0);
 8745         l = xmlDictLookup(ctxt-&gt;dict, tmp, -1);
 8746         if (tmp != NULL) xmlFree(tmp);
 8747         *prefix = p;
 8748         return(l);
 8749     }
 8750     *prefix = p;
 8751     } else
 8752         *prefix = NULL;
 8753     return(l);
 8754 }
 8755 
 8756 /**
 8757  * xmlParseQNameAndCompare:
 8758  * @ctxt:  an XML parser context
 8759  * @name:  the localname
 8760  * @prefix:  the prefix, if any.
 8761  *
 8762  * parse an XML name and compares for match
 8763  * (specialized for endtag parsing)
</pre>
<hr />
<pre>
 8823  * - a character reference is processed by appending the referenced
 8824  *   character to the attribute value
 8825  * - an entity reference is processed by recursively processing the
 8826  *   replacement text of the entity
 8827  * - a whitespace character (#x20, #xD, #xA, #x9) is processed by
 8828  *   appending #x20 to the normalized value, except that only a single
 8829  *   #x20 is appended for a &quot;#xD#xA&quot; sequence that is part of an external
 8830  *   parsed entity or the literal entity value of an internal parsed entity
 8831  * - other characters are processed by appending them to the normalized value
 8832  * If the declared value is not CDATA, then the XML processor must further
 8833  * process the normalized attribute value by discarding any leading and
 8834  * trailing space (#x20) characters, and by replacing sequences of space
 8835  * (#x20) characters by a single space (#x20) character.
 8836  * All attributes for which no declaration has been read should be treated
 8837  * by a non-validating parser as if declared CDATA.
 8838  *
 8839  * Returns the AttValue parsed or NULL. The value has to be freed by the
 8840  *     caller if it was copied, this can be detected by val[*len] == 0.
 8841  */
 8842 












 8843 static xmlChar *
 8844 xmlParseAttValueInternal(xmlParserCtxtPtr ctxt, int *len, int *alloc,
 8845                          int normalize)
 8846 {
 8847     xmlChar limit = 0;
 8848     const xmlChar *in = NULL, *start, *end, *last;
 8849     xmlChar *ret = NULL;
 8850     int line, col;
 8851 
 8852     GROW;
 8853     in = (xmlChar *) CUR_PTR;
 8854     line = ctxt-&gt;input-&gt;line;
 8855     col = ctxt-&gt;input-&gt;col;
 8856     if (*in != &#39;&quot;&#39; &amp;&amp; *in != &#39;\&#39;&#39;) {
 8857         xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
 8858         return (NULL);
 8859     }
 8860     ctxt-&gt;instate = XML_PARSER_ATTRIBUTE_VALUE;
 8861 
 8862     /*
 8863      * try to handle in this routine the most common case where no
 8864      * allocation of a new string is required and where content is
 8865      * pure ASCII.
 8866      */
 8867     limit = *in++;
 8868     col++;
 8869     end = ctxt-&gt;input-&gt;end;
 8870     start = in;
 8871     if (in &gt;= end) {
<span class="line-modified"> 8872         const xmlChar *oldbase = ctxt-&gt;input-&gt;base;</span>
<span class="line-removed"> 8873     GROW;</span>
<span class="line-removed"> 8874     if (oldbase != ctxt-&gt;input-&gt;base) {</span>
<span class="line-removed"> 8875         long delta = ctxt-&gt;input-&gt;base - oldbase;</span>
<span class="line-removed"> 8876         start = start + delta;</span>
<span class="line-removed"> 8877         in = in + delta;</span>
<span class="line-removed"> 8878     }</span>
<span class="line-removed"> 8879     end = ctxt-&gt;input-&gt;end;</span>
 8880     }
 8881     if (normalize) {
 8882         /*
 8883      * Skip any leading spaces
 8884      */
 8885     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp;
 8886            ((*in == 0x20) || (*in == 0x9) ||
 8887             (*in == 0xA) || (*in == 0xD))) {
 8888         if (*in == 0xA) {
 8889             line++; col = 1;
 8890         } else {
 8891             col++;
 8892         }
 8893         in++;
 8894         start = in;
 8895         if (in &gt;= end) {
<span class="line-modified"> 8896         const xmlChar *oldbase = ctxt-&gt;input-&gt;base;</span>
<span class="line-removed"> 8897         GROW;</span>
<span class="line-removed"> 8898                 if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-removed"> 8899                     return(NULL);</span>
<span class="line-removed"> 8900         if (oldbase != ctxt-&gt;input-&gt;base) {</span>
<span class="line-removed"> 8901             long delta = ctxt-&gt;input-&gt;base - oldbase;</span>
<span class="line-removed"> 8902             start = start + delta;</span>
<span class="line-removed"> 8903             in = in + delta;</span>
<span class="line-removed"> 8904         }</span>
<span class="line-removed"> 8905         end = ctxt-&gt;input-&gt;end;</span>
 8906                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8907                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8908                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8909                                    &quot;AttValue length too long\n&quot;);
 8910                     return(NULL);
 8911                 }
 8912         }
 8913     }
 8914     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp; (*in &gt;= 0x20) &amp;&amp;
 8915            (*in &lt;= 0x7f) &amp;&amp; (*in != &#39;&amp;&#39;) &amp;&amp; (*in != &#39;&lt;&#39;)) {
 8916         col++;
 8917         if ((*in++ == 0x20) &amp;&amp; (*in == 0x20)) break;
 8918         if (in &gt;= end) {
<span class="line-modified"> 8919         const xmlChar *oldbase = ctxt-&gt;input-&gt;base;</span>
<span class="line-removed"> 8920         GROW;</span>
<span class="line-removed"> 8921                 if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-removed"> 8922                     return(NULL);</span>
<span class="line-removed"> 8923         if (oldbase != ctxt-&gt;input-&gt;base) {</span>
<span class="line-removed"> 8924             long delta = ctxt-&gt;input-&gt;base - oldbase;</span>
<span class="line-removed"> 8925             start = start + delta;</span>
<span class="line-removed"> 8926             in = in + delta;</span>
<span class="line-removed"> 8927         }</span>
<span class="line-removed"> 8928         end = ctxt-&gt;input-&gt;end;</span>
 8929                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8930                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8931                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8932                                    &quot;AttValue length too long\n&quot;);
 8933                     return(NULL);
 8934                 }
 8935         }
 8936     }
 8937     last = in;
 8938     /*
 8939      * skip the trailing blanks
 8940      */
 8941     while ((last[-1] == 0x20) &amp;&amp; (last &gt; start)) last--;
 8942     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp;
 8943            ((*in == 0x20) || (*in == 0x9) ||
 8944             (*in == 0xA) || (*in == 0xD))) {
 8945         if (*in == 0xA) {
 8946             line++, col = 1;
 8947         } else {
 8948             col++;
 8949         }
 8950         in++;
 8951         if (in &gt;= end) {
 8952         const xmlChar *oldbase = ctxt-&gt;input-&gt;base;
 8953         GROW;
 8954                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 8955                     return(NULL);
 8956         if (oldbase != ctxt-&gt;input-&gt;base) {
<span class="line-modified"> 8957             long delta = ctxt-&gt;input-&gt;base - oldbase;</span>
 8958             start = start + delta;
 8959             in = in + delta;
 8960             last = last + delta;
 8961         }
 8962         end = ctxt-&gt;input-&gt;end;
 8963                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8964                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8965                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8966                                    &quot;AttValue length too long\n&quot;);
 8967                     return(NULL);
 8968                 }
 8969         }
 8970     }
 8971         if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8972             ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8973             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8974                            &quot;AttValue length too long\n&quot;);
 8975             return(NULL);
 8976         }
 8977     if (*in != limit) goto need_complex;
 8978     } else {
 8979     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp; (*in &gt;= 0x20) &amp;&amp;
 8980            (*in &lt;= 0x7f) &amp;&amp; (*in != &#39;&amp;&#39;) &amp;&amp; (*in != &#39;&lt;&#39;)) {
 8981         in++;
 8982         col++;
 8983         if (in &gt;= end) {
<span class="line-modified"> 8984         const xmlChar *oldbase = ctxt-&gt;input-&gt;base;</span>
<span class="line-removed"> 8985         GROW;</span>
<span class="line-removed"> 8986                 if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-removed"> 8987                     return(NULL);</span>
<span class="line-removed"> 8988         if (oldbase != ctxt-&gt;input-&gt;base) {</span>
<span class="line-removed"> 8989             long delta = ctxt-&gt;input-&gt;base - oldbase;</span>
<span class="line-removed"> 8990             start = start + delta;</span>
<span class="line-removed"> 8991             in = in + delta;</span>
<span class="line-removed"> 8992         }</span>
<span class="line-removed"> 8993         end = ctxt-&gt;input-&gt;end;</span>
 8994                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8995                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8996                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8997                                    &quot;AttValue length too long\n&quot;);
 8998                     return(NULL);
 8999                 }
 9000         }
 9001     }
 9002     last = in;
 9003         if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 9004             ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 9005             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9006                            &quot;AttValue length too long\n&quot;);
 9007             return(NULL);
 9008         }
 9009     if (*in != limit) goto need_complex;
 9010     }
 9011     in++;
 9012     col++;
 9013     if (len != NULL) {
</pre>
<hr />
<pre>
 9067     if (ctxt-&gt;attsSpecial != NULL) {
 9068         int type;
 9069 
 9070         type = (int) (ptrdiff_t) xmlHashQLookup2(ctxt-&gt;attsSpecial,
 9071                                                  pref, elem, *prefix, name);
 9072         if (type != 0)
 9073             normalize = 1;
 9074     }
 9075 
 9076     /*
 9077      * read the value
 9078      */
 9079     SKIP_BLANKS;
 9080     if (RAW == &#39;=&#39;) {
 9081         NEXT;
 9082         SKIP_BLANKS;
 9083         val = xmlParseAttValueInternal(ctxt, len, alloc, normalize);
 9084     if (normalize) {
 9085         /*
 9086          * Sometimes a second normalisation pass for spaces is needed
<span class="line-modified"> 9087          * but that only happens if charrefs or entities refernces</span>
 9088          * have been used in the attribute value, i.e. the attribute
 9089          * value have been extracted in an allocated string already.
 9090          */
 9091         if (*alloc) {
 9092             const xmlChar *val2;
 9093 
 9094             val2 = xmlAttrNormalizeSpace2(ctxt, val, len);
 9095         if ((val2 != NULL) &amp;&amp; (val2 != val)) {
 9096             xmlFree(val);
 9097             val = (xmlChar *) val2;
 9098         }
 9099         }
 9100     }
 9101         ctxt-&gt;instate = XML_PARSER_CONTENT;
 9102     } else {
 9103         xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,
 9104                           &quot;Specification mandates value for attribute %s\n&quot;,
 9105                           name);
 9106         return (NULL);
 9107     }
</pre>
<hr />
<pre>
 9230        ((RAW != &#39;/&#39;) || (NXT(1) != &#39;&gt;&#39;)) &amp;&amp;
 9231        (IS_BYTE_CHAR(RAW))) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF)) {
 9232     const xmlChar *q = CUR_PTR;
 9233     unsigned int cons = ctxt-&gt;input-&gt;consumed;
 9234     int len = -1, alloc = 0;
 9235 
 9236     attname = xmlParseAttribute2(ctxt, prefix, localname,
 9237                                  &amp;aprefix, &amp;attvalue, &amp;len, &amp;alloc);
 9238         if ((attname == NULL) || (attvalue == NULL))
 9239             goto next_attr;
 9240     if (len &lt; 0) len = xmlStrlen(attvalue);
 9241 
 9242         if ((attname == ctxt-&gt;str_xmlns) &amp;&amp; (aprefix == NULL)) {
 9243             const xmlChar *URL = xmlDictLookup(ctxt-&gt;dict, attvalue, len);
 9244             xmlURIPtr uri;
 9245 
 9246             if (URL == NULL) {
 9247                 xmlErrMemory(ctxt, &quot;dictionary allocation failure&quot;);
 9248                 if ((attvalue != NULL) &amp;&amp; (alloc != 0))
 9249                     xmlFree(attvalue);
<span class="line-modified"> 9250                 return(NULL);</span>

 9251             }
 9252             if (*URL != 0) {
 9253                 uri = xmlParseURI((const char *) URL);
 9254                 if (uri == NULL) {
 9255                     xmlNsErr(ctxt, XML_WAR_NS_URI,
 9256                              &quot;xmlns: &#39;%s&#39; is not a valid URI\n&quot;,
 9257                                        URL, NULL, NULL);
 9258                 } else {
 9259                     if (uri-&gt;scheme == NULL) {
 9260                         xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
 9261                                   &quot;xmlns: URI %s is not absolute\n&quot;,
 9262                                   URL, NULL, NULL);
 9263                     }
 9264                     xmlFreeURI(uri);
 9265                 }
 9266                 if (URL == ctxt-&gt;str_xml_ns) {
 9267                     if (attname != ctxt-&gt;str_xml) {
 9268                         xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9269                      &quot;xml namespace URI cannot be the default namespace\n&quot;,
 9270                                  NULL, NULL, NULL);
</pre>
<hr />
<pre>
 9480                 if (j &lt;= nbNs) continue;
 9481 
 9482             nsname = xmlGetNamespace(ctxt, attname);
 9483             if (nsname != defaults-&gt;values[2]) {
 9484             if (nsPush(ctxt, attname,
 9485                        defaults-&gt;values[5 * i + 2]) &gt; 0)
 9486                 nbNs++;
 9487             }
 9488         } else {
 9489             /*
 9490              * check that it&#39;s not a defined attribute
 9491              */
 9492             for (j = 0;j &lt; nbatts;j+=5) {
 9493             if ((attname == atts[j]) &amp;&amp; (aprefix == atts[j+1]))
 9494                 break;
 9495             }
 9496             if (j &lt; nbatts) continue;
 9497 
 9498             if ((atts == NULL) || (nbatts + 5 &gt; maxatts)) {
 9499             if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) &lt; 0) {
<span class="line-modified"> 9500                 return(NULL);</span>

 9501             }
 9502             maxatts = ctxt-&gt;maxatts;
 9503             atts = ctxt-&gt;atts;
 9504             }
 9505             atts[nbatts++] = attname;
 9506             atts[nbatts++] = aprefix;
 9507             if (aprefix == NULL)
 9508             atts[nbatts++] = NULL;
 9509             else
 9510                 atts[nbatts++] = xmlGetNamespace(ctxt, aprefix);
 9511             atts[nbatts++] = defaults-&gt;values[5 * i + 2];
 9512             atts[nbatts++] = defaults-&gt;values[5 * i + 3];
 9513             if ((ctxt-&gt;standalone == 1) &amp;&amp;
 9514                 (defaults-&gt;values[5 * i + 4] != NULL)) {
 9515             xmlValidityError(ctxt, XML_DTD_STANDALONE_DEFAULTED,
 9516       &quot;standalone: attribute %s on %s defaulted from external subset\n&quot;,
 9517                                      attname, localname);
 9518             }
 9519             nbdef++;
 9520         }
</pre>
<hr />
<pre>
 9790     if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX)) {
 9791     if (ctxt-&gt;sax-&gt;cdataBlock != NULL)
 9792         ctxt-&gt;sax-&gt;cdataBlock(ctxt-&gt;userData, buf, len);
 9793     else if (ctxt-&gt;sax-&gt;characters != NULL)
 9794         ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, buf, len);
 9795     }
 9796     xmlFree(buf);
 9797 }
 9798 
 9799 /**
 9800  * xmlParseContent:
 9801  * @ctxt:  an XML parser context
 9802  *
 9803  * Parse a content:
 9804  *
 9805  * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
 9806  */
 9807 
 9808 void
 9809 xmlParseContent(xmlParserCtxtPtr ctxt) {


 9810     GROW;
 9811     while ((RAW != 0) &amp;&amp;
<span class="line-removed"> 9812        ((RAW != &#39;&lt;&#39;) || (NXT(1) != &#39;/&#39;)) &amp;&amp;</span>
 9813        (ctxt-&gt;instate != XML_PARSER_EOF)) {
 9814     const xmlChar *test = CUR_PTR;
 9815     unsigned int cons = ctxt-&gt;input-&gt;consumed;
 9816     const xmlChar *cur = ctxt-&gt;input-&gt;cur;
 9817 
 9818     /*
 9819      * First case : a Processing Instruction.
 9820      */
 9821     if ((*cur == &#39;&lt;&#39;) &amp;&amp; (cur[1] == &#39;?&#39;)) {
 9822         xmlParsePI(ctxt);
 9823     }
 9824 
 9825     /*
 9826      * Second case : a CDSection
 9827      */
 9828     /* 2.6.0 test was *cur not RAW */
 9829     else if (CMP9(CUR_PTR, &#39;&lt;&#39;, &#39;!&#39;, &#39;[&#39;, &#39;C&#39;, &#39;D&#39;, &#39;A&#39;, &#39;T&#39;, &#39;A&#39;, &#39;[&#39;)) {
 9830         xmlParseCDSect(ctxt);
 9831     }
 9832 
 9833     /*
 9834      * Third case :  a comment
 9835      */
 9836     else if ((*cur == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp;
 9837          (NXT(2) == &#39;-&#39;) &amp;&amp; (NXT(3) == &#39;-&#39;)) {
 9838         xmlParseComment(ctxt);
 9839         ctxt-&gt;instate = XML_PARSER_CONTENT;
 9840     }
 9841 
 9842     /*
 9843      * Fourth case :  a sub-element.
 9844      */
 9845     else if (*cur == &#39;&lt;&#39;) {
<span class="line-modified"> 9846         xmlParseElement(ctxt);</span>






 9847     }
 9848 
 9849     /*
 9850      * Fifth case : a reference. If if has not been resolved,
 9851      *    parsing returns it&#39;s Name, create the node
 9852      */
 9853 
 9854     else if (*cur == &#39;&amp;&#39;) {
 9855         xmlParseReference(ctxt);
 9856     }
 9857 
 9858     /*
 9859      * Last case, text. Note that References are handled directly.
 9860      */
 9861     else {
 9862         xmlParseCharData(ctxt, 0);
 9863     }
 9864 
 9865     GROW;
 9866     SHRINK;
 9867 
 9868     if ((cons == ctxt-&gt;input-&gt;consumed) &amp;&amp; (test == CUR_PTR)) {
 9869         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 9870                     &quot;detected an error in element content\n&quot;);
 9871         xmlHaltParser(ctxt);
 9872             break;
 9873     }
 9874     }
 9875 }
 9876 
 9877 /**
 9878  * xmlParseElement:
 9879  * @ctxt:  an XML parser context
 9880  *
<span class="line-modified"> 9881  * parse an XML element, this is highly recursive</span>
 9882  *
 9883  * [39] element ::= EmptyElemTag | STag content ETag
 9884  *
 9885  * [ WFC: Element Type Match ]
 9886  * The Name in an element&#39;s end-tag must match the element type in the
 9887  * start-tag.
 9888  *
 9889  */
 9890 
 9891 void
 9892 xmlParseElement(xmlParserCtxtPtr ctxt) {

















 9893     const xmlChar *name;
 9894     const xmlChar *prefix = NULL;
 9895     const xmlChar *URI = NULL;
 9896     xmlParserNodeInfo node_info;
 9897     int line, tlen = 0;
 9898     xmlNodePtr ret;
 9899     int nsNr = ctxt-&gt;nsNr;
 9900 
 9901     if (((unsigned int) ctxt-&gt;nameNr &gt; xmlParserMaxDepth) &amp;&amp;
 9902         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 9903     xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
 9904          &quot;Excessive depth in document: %d use XML_PARSE_HUGE option\n&quot;,
 9905               xmlParserMaxDepth);
 9906     xmlHaltParser(ctxt);
<span class="line-modified"> 9907     return;</span>
 9908     }
 9909 
 9910     /* Capture start position */
 9911     if (ctxt-&gt;record_info) {
 9912         node_info.begin_pos = ctxt-&gt;input-&gt;consumed +
 9913                           (CUR_PTR - ctxt-&gt;input-&gt;base);
 9914     node_info.begin_line = ctxt-&gt;input-&gt;line;
 9915     }
 9916 
 9917     if (ctxt-&gt;spaceNr == 0)
 9918     spacePush(ctxt, -1);
 9919     else if (*ctxt-&gt;space == -2)
 9920     spacePush(ctxt, -1);
 9921     else
 9922     spacePush(ctxt, *ctxt-&gt;space);
 9923 
 9924     line = ctxt-&gt;input-&gt;line;
 9925 #ifdef LIBXML_SAX1_ENABLED
 9926     if (ctxt-&gt;sax2)
 9927 #endif /* LIBXML_SAX1_ENABLED */
 9928         name = xmlParseStartTag2(ctxt, &amp;prefix, &amp;URI, &amp;tlen);
 9929 #ifdef LIBXML_SAX1_ENABLED
 9930     else
 9931     name = xmlParseStartTag(ctxt);
 9932 #endif /* LIBXML_SAX1_ENABLED */
 9933     if (ctxt-&gt;instate == XML_PARSER_EOF)
<span class="line-modified"> 9934     return;</span>
 9935     if (name == NULL) {
 9936     spacePop(ctxt);
<span class="line-modified"> 9937         return;</span>
 9938     }




 9939     namePush(ctxt, name);

 9940     ret = ctxt-&gt;node;
 9941 
 9942 #ifdef LIBXML_VALID_ENABLED
 9943     /*
 9944      * [ VC: Root Element Type ]
 9945      * The Name in the document type declaration must match the element
 9946      * type of the root element.
 9947      */
 9948     if (ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp; ctxt-&gt;myDoc &amp;&amp;
 9949         ctxt-&gt;node &amp;&amp; (ctxt-&gt;node == ctxt-&gt;myDoc-&gt;children))
 9950         ctxt-&gt;valid &amp;= xmlValidateRoot(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc);
 9951 #endif /* LIBXML_VALID_ENABLED */
 9952 
 9953     /*
 9954      * Check for an Empty Element.
 9955      */
 9956     if ((RAW == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;)) {
 9957         SKIP(2);
 9958     if (ctxt-&gt;sax2) {
 9959         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElementNs != NULL) &amp;&amp;
 9960         (!ctxt-&gt;disableSAX))
 9961         ctxt-&gt;sax-&gt;endElementNs(ctxt-&gt;userData, name, prefix, URI);
 9962 #ifdef LIBXML_SAX1_ENABLED
 9963     } else {
 9964         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElement != NULL) &amp;&amp;
 9965         (!ctxt-&gt;disableSAX))
 9966         ctxt-&gt;sax-&gt;endElement(ctxt-&gt;userData, name);
 9967 #endif /* LIBXML_SAX1_ENABLED */
 9968     }
 9969     namePop(ctxt);
 9970     spacePop(ctxt);
 9971     if (nsNr != ctxt-&gt;nsNr)
 9972         nsPop(ctxt, ctxt-&gt;nsNr - nsNr);
 9973     if ( ret != NULL &amp;&amp; ctxt-&gt;record_info ) {
 9974        node_info.end_pos = ctxt-&gt;input-&gt;consumed +
 9975                   (CUR_PTR - ctxt-&gt;input-&gt;base);
 9976        node_info.end_line = ctxt-&gt;input-&gt;line;
 9977        node_info.node = ret;
 9978        xmlParserAddNodeInfo(ctxt, &amp;node_info);
 9979     }
<span class="line-modified"> 9980     return;</span>
 9981     }
 9982     if (RAW == &#39;&gt;&#39;) {
 9983         NEXT1;
 9984     } else {
 9985         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_GT_REQUIRED,
 9986              &quot;Couldn&#39;t find end of Start Tag %s line %d\n&quot;,
 9987                         name, line, NULL);
 9988 
 9989     /*
 9990      * end of parsing of this node.
 9991      */
 9992     nodePop(ctxt);
 9993     namePop(ctxt);
 9994     spacePop(ctxt);
 9995     if (nsNr != ctxt-&gt;nsNr)
 9996         nsPop(ctxt, ctxt-&gt;nsNr - nsNr);
 9997 
 9998     /*
 9999      * Capture end position and add node
10000      */
10001     if ( ret != NULL &amp;&amp; ctxt-&gt;record_info ) {
10002        node_info.end_pos = ctxt-&gt;input-&gt;consumed +
10003                   (CUR_PTR - ctxt-&gt;input-&gt;base);
10004        node_info.end_line = ctxt-&gt;input-&gt;line;
10005        node_info.node = ret;
10006        xmlParserAddNodeInfo(ctxt, &amp;node_info);
10007     }
<span class="line-modified">10008     return;</span>
10009     }
10010 
<span class="line-modified">10011     /*</span>
<span class="line-modified">10012      * Parse the content of the element:</span>
<span class="line-removed">10013      */</span>
<span class="line-removed">10014     xmlParseContent(ctxt);</span>
<span class="line-removed">10015     if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-removed">10016     return;</span>
<span class="line-removed">10017     if (!IS_BYTE_CHAR(RAW)) {</span>
<span class="line-removed">10018         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,</span>
<span class="line-removed">10019      &quot;Premature end of data in tag %s line %d\n&quot;,</span>
<span class="line-removed">10020                         name, line, NULL);</span>
10021 
<span class="line-modified">10022     /*</span>
<span class="line-modified">10023      * end of parsing of this node.</span>



10024      */
<span class="line-modified">10025     nodePop(ctxt);</span>
<span class="line-modified">10026     namePop(ctxt);</span>
<span class="line-modified">10027     spacePop(ctxt);</span>
<span class="line-modified">10028     if (nsNr != ctxt-&gt;nsNr)</span>
<span class="line-modified">10029         nsPop(ctxt, ctxt-&gt;nsNr - nsNr);</span>

10030     return;
<span class="line-removed">10031     }</span>
10032 
10033     /*
10034      * parse the end of tag: &#39;&lt;/&#39; should be here.
10035      */
10036     if (ctxt-&gt;sax2) {
<span class="line-modified">10037     xmlParseEndTag2(ctxt, prefix, URI, line, ctxt-&gt;nsNr - nsNr, tlen);</span>



10038     namePop(ctxt);
10039     }
10040 #ifdef LIBXML_SAX1_ENABLED
10041       else
<span class="line-modified">10042     xmlParseEndTag1(ctxt, line);</span>
10043 #endif /* LIBXML_SAX1_ENABLED */
10044 
10045     /*
10046      * Capture end position and add node
10047      */
10048     if ( ret != NULL &amp;&amp; ctxt-&gt;record_info ) {
10049        node_info.end_pos = ctxt-&gt;input-&gt;consumed +
10050                           (CUR_PTR - ctxt-&gt;input-&gt;base);
10051        node_info.end_line = ctxt-&gt;input-&gt;line;
10052        node_info.node = ret;
10053        xmlParserAddNodeInfo(ctxt, &amp;node_info);
10054     }
10055 }
10056 
10057 /**
10058  * xmlParseVersionNum:
10059  * @ctxt:  an XML parser context
10060  *
10061  * parse the XML version value.
10062  *
</pre>
<hr />
<pre>
10264         encoding = xmlParseEncName(ctxt);
10265         if (RAW != &#39;\&#39;&#39;) {
10266         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10267         xmlFree((xmlChar *) encoding);
10268         return(NULL);
10269         } else
10270             NEXT;
10271     } else {
10272         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10273     }
10274 
10275         /*
10276          * Non standard parsing, allowing the user to ignore encoding
10277          */
10278         if (ctxt-&gt;options &amp; XML_PARSE_IGNORE_ENC) {
10279         xmlFree((xmlChar *) encoding);
10280             return(NULL);
10281     }
10282 
10283     /*
<span class="line-modified">10284      * UTF-16 encoding stwich has already taken place at this stage,</span>
10285      * more over the little-endian/big-endian selection is already done
10286      */
10287         if ((encoding != NULL) &amp;&amp;
10288         ((!xmlStrcasecmp(encoding, BAD_CAST &quot;UTF-16&quot;)) ||
10289          (!xmlStrcasecmp(encoding, BAD_CAST &quot;UTF16&quot;)))) {
10290         /*
10291          * If no encoding was passed to the parser, that we are
10292          * using UTF-16 and no decoder is present i.e. the
10293          * document is apparently UTF-8 compatible, then raise an
10294          * encoding mismatch fatal error
10295          */
10296         if ((ctxt-&gt;encoding == NULL) &amp;&amp;
10297             (ctxt-&gt;input-&gt;buf != NULL) &amp;&amp;
10298             (ctxt-&gt;input-&gt;buf-&gt;encoder == NULL)) {
10299         xmlFatalErrMsg(ctxt, XML_ERR_INVALID_ENCODING,
10300           &quot;Document labelled UTF-16 but has UTF-8 content\n&quot;);
10301         }
10302         if (ctxt-&gt;encoding != NULL)
10303         xmlFree((xmlChar *) ctxt-&gt;encoding);
10304         ctxt-&gt;encoding = encoding;
</pre>
<hr />
<pre>
11147 #endif
11148 
11149     if ((ctxt-&gt;input != NULL) &amp;&amp;
11150         (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base &gt; 4096)) {
11151     xmlSHRINK(ctxt);
11152     ctxt-&gt;checkIndex = 0;
11153     }
11154     xmlParseGetLasts(ctxt, &amp;lastlt, &amp;lastgt);
11155 
11156     while (ctxt-&gt;instate != XML_PARSER_EOF) {
11157     if ((ctxt-&gt;errNo != XML_ERR_OK) &amp;&amp; (ctxt-&gt;disableSAX == 1))
11158         return(0);
11159 
11160     if (ctxt-&gt;input == NULL) break;
11161     if (ctxt-&gt;input-&gt;buf == NULL)
11162         avail = ctxt-&gt;input-&gt;length -
11163                 (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11164     else {
11165         /*
11166          * If we are operating on converted input, try to flush
<span class="line-modified">11167          * remainng chars to avoid them stalling in the non-converted</span>
11168          * buffer. But do not do this in document start where
11169          * encoding=&quot;...&quot; may not have been read and we work on a
11170          * guessed encoding.
11171          */
11172         if ((ctxt-&gt;instate != XML_PARSER_START) &amp;&amp;
11173             (ctxt-&gt;input-&gt;buf-&gt;raw != NULL) &amp;&amp;
11174         (xmlBufIsEmpty(ctxt-&gt;input-&gt;buf-&gt;raw) == 0)) {
11175                 size_t base = xmlBufGetInputBase(ctxt-&gt;input-&gt;buf-&gt;buffer,
11176                                                  ctxt-&gt;input);
11177         size_t current = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
11178 
11179         xmlParserInputBufferPush(ctxt-&gt;input-&gt;buf, 0, &quot;&quot;);
11180                 xmlBufSetInputBaseCur(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input,
11181                                       base, current);
11182         }
11183         avail = xmlBufUse(ctxt-&gt;input-&gt;buf-&gt;buffer) -
11184             (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11185     }
11186         if (avail &lt; 1)
11187         goto done;
</pre>
<hr />
<pre>
12339     xmlParserInputPtr inputStream;
12340     xmlParserInputBufferPtr buf;
12341     xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;
12342 
12343     /*
12344      * plug some encoding conversion routines
12345      */
12346     if ((chunk != NULL) &amp;&amp; (size &gt;= 4))
12347     enc = xmlDetectCharEncoding((const xmlChar *) chunk, size);
12348 
12349     buf = xmlAllocParserInputBuffer(enc);
12350     if (buf == NULL) return(NULL);
12351 
12352     ctxt = xmlNewParserCtxt();
12353     if (ctxt == NULL) {
12354         xmlErrMemory(NULL, &quot;creating parser: out of memory\n&quot;);
12355     xmlFreeParserInputBuffer(buf);
12356     return(NULL);
12357     }
12358     ctxt-&gt;dictNames = 1;
<span class="line-removed">12359     ctxt-&gt;pushTab = (void **) xmlMalloc(ctxt-&gt;nameMax * 3 * sizeof(xmlChar *));</span>
<span class="line-removed">12360     if (ctxt-&gt;pushTab == NULL) {</span>
<span class="line-removed">12361         xmlErrMemory(ctxt, NULL);</span>
<span class="line-removed">12362     xmlFreeParserInputBuffer(buf);</span>
<span class="line-removed">12363     xmlFreeParserCtxt(ctxt);</span>
<span class="line-removed">12364     return(NULL);</span>
<span class="line-removed">12365     }</span>
12366     if (sax != NULL) {
12367 #ifdef LIBXML_SAX1_ENABLED
12368     if (ctxt-&gt;sax != (xmlSAXHandlerPtr) &amp;xmlDefaultSAXHandler)
12369 #endif /* LIBXML_SAX1_ENABLED */
12370         xmlFree(ctxt-&gt;sax);
12371     ctxt-&gt;sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(xmlSAXHandler));
12372     if (ctxt-&gt;sax == NULL) {
12373         xmlErrMemory(ctxt, NULL);
12374         xmlFreeParserInputBuffer(buf);
12375         xmlFreeParserCtxt(ctxt);
12376         return(NULL);
12377     }
12378     memset(ctxt-&gt;sax, 0, sizeof(xmlSAXHandler));
12379     if (sax-&gt;initialized == XML_SAX2_MAGIC)
12380         memcpy(ctxt-&gt;sax, sax, sizeof(xmlSAXHandler));
12381     else
12382         memcpy(ctxt-&gt;sax, sax, sizeof(xmlSAXHandlerV1));
12383     if (user_data != NULL)
12384         ctxt-&gt;userData = user_data;
12385     }
</pre>
<hr />
<pre>
13881 
13882     /*
13883      * Return the newly created nodeset after unlinking it from
13884      * they pseudo parent.
13885      */
13886     cur = newDoc-&gt;children-&gt;children;
13887     *lst = cur;
13888     while (cur != NULL) {
13889         xmlSetTreeDoc(cur, doc);
13890         cur-&gt;parent = NULL;
13891         cur = cur-&gt;next;
13892     }
13893     newDoc-&gt;children-&gt;children = NULL;
13894     }
13895 
13896     if (sax != NULL)
13897     ctxt-&gt;sax = oldsax;
13898     xmlFreeParserCtxt(ctxt);
13899     newDoc-&gt;intSubset = NULL;
13900     newDoc-&gt;extSubset = NULL;

13901     newDoc-&gt;oldNs = NULL;
13902     xmlFreeDoc(newDoc);
13903 
13904     return(ret);
13905 }
13906 
13907 /**
13908  * xmlSAXParseEntity:
13909  * @sax:  the SAX handler block
13910  * @filename:  the filename
13911  *
13912  * parse an XML external entity out of context and build a tree.
13913  * It use the given SAX function block to handle the parsing callback.
13914  * If sax is NULL, fallback to the default DOM tree building routines.
13915  *
13916  * [78] extParsedEnt ::= TextDecl? content
13917  *
13918  * This correspond to a &quot;Well Balanced&quot; chunk
13919  *
13920  * Returns the resulting document tree
</pre>
<hr />
<pre>
13990     xmlParserCtxtPtr ctxt;
13991     xmlParserInputPtr inputStream;
13992     char *directory = NULL;
13993     xmlChar *uri;
13994 
13995     ctxt = xmlNewParserCtxt();
13996     if (ctxt == NULL) {
13997     return(NULL);
13998     }
13999 
14000     if (pctx != NULL) {
14001         ctxt-&gt;options = pctx-&gt;options;
14002         ctxt-&gt;_private = pctx-&gt;_private;
14003     /*
14004      * this is a subparser of pctx, so the input_id should be
14005      * incremented to distinguish from main entity
14006      */
14007     ctxt-&gt;input_id = pctx-&gt;input_id + 1;
14008     }
14009 




14010     uri = xmlBuildURI(URL, base);
14011 
14012     if (uri == NULL) {
14013     inputStream = xmlLoadExternalEntity((char *)URL, (char *)ID, ctxt);
14014     if (inputStream == NULL) {
14015         xmlFreeParserCtxt(ctxt);
14016         return(NULL);
14017     }
14018 
14019     inputPush(ctxt, inputStream);
14020 
14021     if ((ctxt-&gt;directory == NULL) &amp;&amp; (directory == NULL))
14022         directory = xmlParserGetDirectory((char *)URL);
14023     if ((ctxt-&gt;directory == NULL) &amp;&amp; (directory != NULL))
14024         ctxt-&gt;directory = directory;
14025     } else {
14026     inputStream = xmlLoadExternalEntity((char *)uri, (char *)ID, ctxt);
14027     if (inputStream == NULL) {
14028         xmlFree(uri);
14029         xmlFreeParserCtxt(ctxt);
</pre>
<hr />
<pre>
14922     xmlParserInputBufferPtr buf;
14923     xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;
14924 
14925     if (ctxt == NULL)
14926         return(1);
14927 
14928     if ((encoding == NULL) &amp;&amp; (chunk != NULL) &amp;&amp; (size &gt;= 4))
14929         enc = xmlDetectCharEncoding((const xmlChar *) chunk, size);
14930 
14931     buf = xmlAllocParserInputBuffer(enc);
14932     if (buf == NULL)
14933         return(1);
14934 
14935     if (ctxt == NULL) {
14936         xmlFreeParserInputBuffer(buf);
14937         return(1);
14938     }
14939 
14940     xmlCtxtReset(ctxt);
14941 
<span class="line-removed">14942     if (ctxt-&gt;pushTab == NULL) {</span>
<span class="line-removed">14943         ctxt-&gt;pushTab = (void **) xmlMalloc(ctxt-&gt;nameMax * 3 *</span>
<span class="line-removed">14944                                         sizeof(xmlChar *));</span>
<span class="line-removed">14945         if (ctxt-&gt;pushTab == NULL) {</span>
<span class="line-removed">14946         xmlErrMemory(ctxt, NULL);</span>
<span class="line-removed">14947             xmlFreeParserInputBuffer(buf);</span>
<span class="line-removed">14948             return(1);</span>
<span class="line-removed">14949         }</span>
<span class="line-removed">14950     }</span>
<span class="line-removed">14951 </span>
14952     if (filename == NULL) {
14953         ctxt-&gt;directory = NULL;
14954     } else {
14955         ctxt-&gt;directory = xmlParserGetDirectory(filename);
14956     }
14957 
14958     inputStream = xmlNewInputStream(ctxt);
14959     if (inputStream == NULL) {
14960         xmlFreeParserInputBuffer(buf);
14961         return(1);
14962     }
14963 
14964     if (filename == NULL)
14965         inputStream-&gt;filename = NULL;
14966     else
14967         inputStream-&gt;filename = (char *)
14968             xmlCanonicPath((const xmlChar *) filename);
14969     inputStream-&gt;buf = buf;
14970     xmlBufResetInput(buf-&gt;buffer, inputStream);
14971 
</pre>
</td>
<td>
<hr />
<pre>
   79 #endif
   80 #ifdef HAVE_FCNTL_H
   81 #include &lt;fcntl.h&gt;
   82 #endif
   83 #ifdef HAVE_UNISTD_H
   84 #include &lt;unistd.h&gt;
   85 #endif
   86 
   87 #include &quot;buf.h&quot;
   88 #include &quot;enc.h&quot;
   89 
   90 static void
   91 xmlFatalErr(xmlParserCtxtPtr ctxt, xmlParserErrors error, const char *info);
   92 
   93 static xmlParserCtxtPtr
   94 xmlCreateEntityParserCtxtInternal(const xmlChar *URL, const xmlChar *ID,
   95                       const xmlChar *base, xmlParserCtxtPtr pctx);
   96 
   97 static void xmlHaltParser(xmlParserCtxtPtr ctxt);
   98 
<span class="line-added">   99 static int</span>
<span class="line-added">  100 xmlParseElementStart(xmlParserCtxtPtr ctxt);</span>
<span class="line-added">  101 </span>
<span class="line-added">  102 static void</span>
<span class="line-added">  103 xmlParseElementEnd(xmlParserCtxtPtr ctxt);</span>
<span class="line-added">  104 </span>
  105 /************************************************************************
  106  *                                  *
  107  *  Arbitrary limits set in the parser. See XML_PARSE_HUGE      *
  108  *                                  *
  109  ************************************************************************/
  110 
  111 #define XML_PARSER_BIG_ENTITY 1000
  112 #define XML_PARSER_LOT_ENTITY 5000
  113 
  114 /*
  115  * XML_PARSER_NON_LINEAR is the threshold where the ratio of parsed entity
  116  *    replacement over the size in byte of the input indicates that you have
<span class="line-modified">  117  *    and exponential behaviour. A value of 10 correspond to at least 3 entity</span>
  118  *    replacement per byte of input.
  119  */
  120 #define XML_PARSER_NON_LINEAR 10
  121 
  122 /*
  123  * xmlParserEntityCheck
  124  *
  125  * Function to check non-linear entity expansion behaviour
  126  * This is here to detect and stop exponential linear entity expansion
  127  * This is not a limitation of the parser but a safety
  128  * boundary feature. It can be disabled with the XML_PARSE_HUGE
  129  * parser option.
  130  */
  131 static int
  132 xmlParserEntityCheck(xmlParserCtxtPtr ctxt, size_t size,
  133                      xmlEntityPtr ent, size_t replacement)
  134 {
  135     size_t consumed = 0;
  136 
  137     if ((ctxt == NULL) || (ctxt-&gt;options &amp; XML_PARSE_HUGE))
  138         return (0);
  139     if (ctxt-&gt;lastError.code == XML_ERR_ENTITY_LOOP)
  140         return (1);
  141 
  142     /*
  143      * This may look absurd but is needed to detect
  144      * entities problems
  145      */
  146     if ((ent != NULL) &amp;&amp; (ent-&gt;etype != XML_INTERNAL_PREDEFINED_ENTITY) &amp;&amp;
  147     (ent-&gt;content != NULL) &amp;&amp; (ent-&gt;checked == 0) &amp;&amp;
  148     (ctxt-&gt;errNo != XML_ERR_ENTITY_LOOP)) {
<span class="line-modified">  149     unsigned long oldnbent = ctxt-&gt;nbentities, diff;</span>
  150     xmlChar *rep;
  151 
  152     ent-&gt;checked = 1;
  153 
  154         ++ctxt-&gt;depth;
  155     rep = xmlStringDecodeEntities(ctxt, ent-&gt;content,
  156                   XML_SUBSTITUTE_REF, 0, 0, 0);
  157         --ctxt-&gt;depth;
  158     if ((rep == NULL) || (ctxt-&gt;errNo == XML_ERR_ENTITY_LOOP)) {
  159         ent-&gt;content[0] = 0;
  160     }
  161 
<span class="line-modified">  162         diff = ctxt-&gt;nbentities - oldnbent + 1;</span>
<span class="line-added">  163         if (diff &gt; INT_MAX / 2)</span>
<span class="line-added">  164             diff = INT_MAX / 2;</span>
<span class="line-added">  165     ent-&gt;checked = diff * 2;</span>
  166     if (rep != NULL) {
  167         if (xmlStrchr(rep, &#39;&lt;&#39;))
  168         ent-&gt;checked |= 1;
  169         xmlFree(rep);
  170         rep = NULL;
  171     }
  172     }
  173     if (replacement != 0) {
  174     if (replacement &lt; XML_MAX_TEXT_LENGTH)
  175         return(0);
  176 
  177         /*
  178      * If the volume of entity copy reaches 10 times the
  179      * amount of parsed data and over the large text threshold
  180      * then that&#39;s very likely to be an abuse.
  181      */
  182         if (ctxt-&gt;input != NULL) {
  183         consumed = ctxt-&gt;input-&gt;consumed +
  184                    (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
  185     }
</pre>
<hr />
<pre>
 1052             return(1);
 1053 #else
 1054             return(0);
 1055 #endif
 1056         default:
 1057         break;
 1058      }
 1059      return(0);
 1060 }
 1061 
 1062 /************************************************************************
 1063  *                                  *
 1064  *      SAX2 defaulted attributes handling          *
 1065  *                                  *
 1066  ************************************************************************/
 1067 
 1068 /**
 1069  * xmlDetectSAX2:
 1070  * @ctxt:  an XML parser context
 1071  *
<span class="line-modified"> 1072  * Do the SAX2 detection and specific initialization</span>
 1073  */
 1074 static void
 1075 xmlDetectSAX2(xmlParserCtxtPtr ctxt) {
 1076     if (ctxt == NULL) return;
 1077 #ifdef LIBXML_SAX1_ENABLED
 1078     if ((ctxt-&gt;sax) &amp;&amp;  (ctxt-&gt;sax-&gt;initialized == XML_SAX2_MAGIC) &amp;&amp;
 1079         ((ctxt-&gt;sax-&gt;startElementNs != NULL) ||
 1080          (ctxt-&gt;sax-&gt;endElementNs != NULL))) ctxt-&gt;sax2 = 1;
 1081 #else
 1082     ctxt-&gt;sax2 = 1;
 1083 #endif /* LIBXML_SAX1_ENABLED */
 1084 
 1085     ctxt-&gt;str_xml = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xml&quot;, 3);
 1086     ctxt-&gt;str_xmlns = xmlDictLookup(ctxt-&gt;dict, BAD_CAST &quot;xmlns&quot;, 5);
 1087     ctxt-&gt;str_xml_ns = xmlDictLookup(ctxt-&gt;dict, XML_XML_NAMESPACE, 36);
 1088     if ((ctxt-&gt;str_xml==NULL) || (ctxt-&gt;str_xmlns==NULL) ||
 1089         (ctxt-&gt;str_xml_ns == NULL)) {
 1090         xmlErrMemory(ctxt, NULL);
 1091     }
 1092 }
</pre>
<hr />
<pre>
 1384     }
 1385     return;
 1386 }
 1387 
 1388 /**
 1389  * xmlCheckLanguageID:
 1390  * @lang:  pointer to the string value
 1391  *
 1392  * Checks that the value conforms to the LanguageID production:
 1393  *
 1394  * NOTE: this is somewhat deprecated, those productions were removed from
 1395  *       the XML Second edition.
 1396  *
 1397  * [33] LanguageID ::= Langcode (&#39;-&#39; Subcode)*
 1398  * [34] Langcode ::= ISO639Code |  IanaCode |  UserCode
 1399  * [35] ISO639Code ::= ([a-z] | [A-Z]) ([a-z] | [A-Z])
 1400  * [36] IanaCode ::= (&#39;i&#39; | &#39;I&#39;) &#39;-&#39; ([a-z] | [A-Z])+
 1401  * [37] UserCode ::= (&#39;x&#39; | &#39;X&#39;) &#39;-&#39; ([a-z] | [A-Z])+
 1402  * [38] Subcode ::= ([a-z] | [A-Z])+
 1403  *
<span class="line-modified"> 1404  * The current REC reference the successors of RFC 1766, currently 5646</span>
 1405  *
 1406  * http://www.rfc-editor.org/rfc/rfc5646.txt
 1407  * langtag       = language
 1408  *                 [&quot;-&quot; script]
 1409  *                 [&quot;-&quot; region]
 1410  *                 *(&quot;-&quot; variant)
 1411  *                 *(&quot;-&quot; extension)
 1412  *                 [&quot;-&quot; privateuse]
 1413  * language      = 2*3ALPHA            ; shortest ISO 639 code
 1414  *                 [&quot;-&quot; extlang]       ; sometimes followed by
 1415  *                                     ; extended language subtags
 1416  *               / 4ALPHA              ; or reserved for future use
 1417  *               / 5*8ALPHA            ; or registered language subtag
 1418  *
 1419  * extlang       = 3ALPHA              ; selected ISO 639 codes
 1420  *                 *2(&quot;-&quot; 3ALPHA)      ; permanently reserved
 1421  *
 1422  * script        = 4ALPHA              ; ISO 15924 code
 1423  *
 1424  * region        = 2ALPHA              ; ISO 3166-1 code
</pre>
<hr />
<pre>
 1811  * Returns the node just removed
 1812  */
 1813 xmlNodePtr
 1814 nodePop(xmlParserCtxtPtr ctxt)
 1815 {
 1816     xmlNodePtr ret;
 1817 
 1818     if (ctxt == NULL) return(NULL);
 1819     if (ctxt-&gt;nodeNr &lt;= 0)
 1820         return (NULL);
 1821     ctxt-&gt;nodeNr--;
 1822     if (ctxt-&gt;nodeNr &gt; 0)
 1823         ctxt-&gt;node = ctxt-&gt;nodeTab[ctxt-&gt;nodeNr - 1];
 1824     else
 1825         ctxt-&gt;node = NULL;
 1826     ret = ctxt-&gt;nodeTab[ctxt-&gt;nodeNr];
 1827     ctxt-&gt;nodeTab[ctxt-&gt;nodeNr] = NULL;
 1828     return (ret);
 1829 }
 1830 

 1831 /**
 1832  * nameNsPush:
 1833  * @ctxt:  an XML parser context
 1834  * @value:  the element name
 1835  * @prefix:  the element prefix
 1836  * @URI:  the element namespace name
 1837  *
 1838  * Pushes a new element name/prefix/URL on top of the name stack
 1839  *
 1840  * Returns -1 in case of error, the index in the stack otherwise
 1841  */
 1842 static int
 1843 nameNsPush(xmlParserCtxtPtr ctxt, const xmlChar * value,
 1844            const xmlChar *prefix, const xmlChar *URI, int nsNr)
 1845 {
 1846     if (ctxt-&gt;nameNr &gt;= ctxt-&gt;nameMax) {
 1847         const xmlChar * *tmp;
 1848         void **tmp2;
 1849         ctxt-&gt;nameMax *= 2;
 1850         tmp = (const xmlChar * *) xmlRealloc((xmlChar * *)ctxt-&gt;nameTab,
 1851                                     ctxt-&gt;nameMax *
 1852                                     sizeof(ctxt-&gt;nameTab[0]));
 1853         if (tmp == NULL) {
 1854         ctxt-&gt;nameMax /= 2;
 1855         goto mem_error;
 1856         }
 1857     ctxt-&gt;nameTab = tmp;
 1858         tmp2 = (void **) xmlRealloc((void * *)ctxt-&gt;pushTab,
 1859                                     ctxt-&gt;nameMax * 3 *
 1860                                     sizeof(ctxt-&gt;pushTab[0]));
 1861         if (tmp2 == NULL) {
 1862         ctxt-&gt;nameMax /= 2;
 1863         goto mem_error;
 1864         }
 1865     ctxt-&gt;pushTab = tmp2;
<span class="line-added"> 1866     } else if (ctxt-&gt;pushTab == NULL) {</span>
<span class="line-added"> 1867         ctxt-&gt;pushTab = (void **) xmlMalloc(ctxt-&gt;nameMax * 3 *</span>
<span class="line-added"> 1868                                             sizeof(ctxt-&gt;pushTab[0]));</span>
<span class="line-added"> 1869         if (ctxt-&gt;pushTab == NULL)</span>
<span class="line-added"> 1870             goto mem_error;</span>
 1871     }
 1872     ctxt-&gt;nameTab[ctxt-&gt;nameNr] = value;
 1873     ctxt-&gt;name = value;
 1874     ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3] = (void *) prefix;
 1875     ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 + 1] = (void *) URI;
 1876     ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 + 2] = (void *) (ptrdiff_t) nsNr;
 1877     return (ctxt-&gt;nameNr++);
 1878 mem_error:
 1879     xmlErrMemory(ctxt, NULL);
 1880     return (-1);
 1881 }
<span class="line-added"> 1882 #ifdef LIBXML_PUSH_ENABLED</span>
 1883 /**
 1884  * nameNsPop:
 1885  * @ctxt: an XML parser context
 1886  *
 1887  * Pops the top element/prefix/URI name from the name stack
 1888  *
 1889  * Returns the name just removed
 1890  */
 1891 static const xmlChar *
 1892 nameNsPop(xmlParserCtxtPtr ctxt)
 1893 {
 1894     const xmlChar *ret;
 1895 
 1896     if (ctxt-&gt;nameNr &lt;= 0)
 1897         return (NULL);
 1898     ctxt-&gt;nameNr--;
 1899     if (ctxt-&gt;nameNr &gt; 0)
 1900         ctxt-&gt;name = ctxt-&gt;nameTab[ctxt-&gt;nameNr - 1];
 1901     else
 1902         ctxt-&gt;name = NULL;
</pre>
<hr />
<pre>
 2072     if (*ctxt-&gt;input-&gt;cur == 0)                     \
 2073         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);           \
 2074   } while (0)
 2075 
 2076 #define SHRINK if ((ctxt-&gt;progressive == 0) &amp;&amp;              \
 2077            (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base &gt; 2 * INPUT_CHUNK) &amp;&amp; \
 2078            (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; 2 * INPUT_CHUNK)) \
 2079     xmlSHRINK (ctxt);
 2080 
 2081 static void xmlSHRINK (xmlParserCtxtPtr ctxt) {
 2082     xmlParserInputShrink(ctxt-&gt;input);
 2083     if (*ctxt-&gt;input-&gt;cur == 0)
 2084         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 2085 }
 2086 
 2087 #define GROW if ((ctxt-&gt;progressive == 0) &amp;&amp;                \
 2088          (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; INPUT_CHUNK))   \
 2089     xmlGROW (ctxt);
 2090 
 2091 static void xmlGROW (xmlParserCtxtPtr ctxt) {
<span class="line-modified"> 2092     ptrdiff_t curEnd = ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur;</span>
<span class="line-modified"> 2093     ptrdiff_t curBase = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;</span>
 2094 
<span class="line-modified"> 2095     if (((curEnd &gt; XML_MAX_LOOKUP_LIMIT) ||</span>
<span class="line-modified"> 2096          (curBase &gt; XML_MAX_LOOKUP_LIMIT)) &amp;&amp;</span>
 2097          ((ctxt-&gt;input-&gt;buf) &amp;&amp;
 2098           (ctxt-&gt;input-&gt;buf-&gt;readcallback != xmlInputReadCallbackNop)) &amp;&amp;
 2099         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 2100         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, &quot;Huge input lookup&quot;);
 2101         xmlHaltParser(ctxt);
 2102     return;
 2103     }
 2104     xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 2105     if ((ctxt-&gt;input-&gt;cur &gt; ctxt-&gt;input-&gt;end) ||
 2106         (ctxt-&gt;input-&gt;cur &lt; ctxt-&gt;input-&gt;base)) {
 2107         xmlHaltParser(ctxt);
 2108         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, &quot;cur index out of bound&quot;);
 2109     return;
 2110     }
 2111     if ((ctxt-&gt;input-&gt;cur != NULL) &amp;&amp; (*ctxt-&gt;input-&gt;cur == 0))
 2112         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 2113 }
 2114 
 2115 #define SKIP_BLANKS xmlSkipBlankChars(ctxt)
 2116 
</pre>
<hr />
<pre>
 2278     return(ret);
 2279 }
 2280 
 2281 /**
 2282  * xmlParseCharRef:
 2283  * @ctxt:  an XML parser context
 2284  *
 2285  * parse Reference declarations
 2286  *
 2287  * [66] CharRef ::= &#39;&amp;#&#39; [0-9]+ &#39;;&#39; |
 2288  *                  &#39;&amp;#x&#39; [0-9a-fA-F]+ &#39;;&#39;
 2289  *
 2290  * [ WFC: Legal Character ]
 2291  * Characters referred to using character references must match the
 2292  * production for Char.
 2293  *
 2294  * Returns the value parsed (as an int), 0 in case of error
 2295  */
 2296 int
 2297 xmlParseCharRef(xmlParserCtxtPtr ctxt) {
<span class="line-modified"> 2298     int val = 0;</span>
 2299     int count = 0;

 2300 
 2301     /*
 2302      * Using RAW/CUR/NEXT is okay since we are working on ASCII range here
 2303      */
 2304     if ((RAW == &#39;&amp;&#39;) &amp;&amp; (NXT(1) == &#39;#&#39;) &amp;&amp;
 2305         (NXT(2) == &#39;x&#39;)) {
 2306     SKIP(3);
 2307     GROW;
 2308     while (RAW != &#39;;&#39;) { /* loop blocked by count */
 2309         if (count++ &gt; 20) {
 2310         count = 0;
 2311         GROW;
 2312                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 2313                     return(0);
 2314         }
 2315         if ((RAW &gt;= &#39;0&#39;) &amp;&amp; (RAW &lt;= &#39;9&#39;))
 2316             val = val * 16 + (CUR - &#39;0&#39;);
 2317         else if ((RAW &gt;= &#39;a&#39;) &amp;&amp; (RAW &lt;= &#39;f&#39;) &amp;&amp; (count &lt; 20))
 2318             val = val * 16 + (CUR - &#39;a&#39;) + 10;
 2319         else if ((RAW &gt;= &#39;A&#39;) &amp;&amp; (RAW &lt;= &#39;F&#39;) &amp;&amp; (count &lt; 20))
 2320             val = val * 16 + (CUR - &#39;A&#39;) + 10;
 2321         else {
 2322         xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);
 2323         val = 0;
 2324         break;
 2325         }
<span class="line-modified"> 2326         if (val &gt; 0x110000)</span>
<span class="line-modified"> 2327             val = 0x110000;</span>
 2328 
 2329         NEXT;
 2330         count++;
 2331     }
 2332     if (RAW == &#39;;&#39;) {
 2333         /* on purpose to avoid reentrancy problems with NEXT and SKIP */
 2334         ctxt-&gt;input-&gt;col++;
 2335         ctxt-&gt;nbChars ++;
 2336         ctxt-&gt;input-&gt;cur++;
 2337     }
 2338     } else if  ((RAW == &#39;&amp;&#39;) &amp;&amp; (NXT(1) == &#39;#&#39;)) {
 2339     SKIP(2);
 2340     GROW;
 2341     while (RAW != &#39;;&#39;) { /* loop blocked by count */
 2342         if (count++ &gt; 20) {
 2343         count = 0;
 2344         GROW;
 2345                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 2346                     return(0);
 2347         }
 2348         if ((RAW &gt;= &#39;0&#39;) &amp;&amp; (RAW &lt;= &#39;9&#39;))
 2349             val = val * 10 + (CUR - &#39;0&#39;);
 2350         else {
 2351         xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);
 2352         val = 0;
 2353         break;
 2354         }
<span class="line-modified"> 2355         if (val &gt; 0x110000)</span>
<span class="line-modified"> 2356             val = 0x110000;</span>
 2357 
 2358         NEXT;
 2359         count++;
 2360     }
 2361     if (RAW == &#39;;&#39;) {
 2362         /* on purpose to avoid reentrancy problems with NEXT and SKIP */
 2363         ctxt-&gt;input-&gt;col++;
 2364         ctxt-&gt;nbChars ++;
 2365         ctxt-&gt;input-&gt;cur++;
 2366     }
 2367     } else {
 2368         xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);
 2369     }
 2370 
 2371     /*
 2372      * [ WFC: Legal Character ]
 2373      * Characters referred to using character references must match the
 2374      * production for Char.
 2375      */
<span class="line-modified"> 2376     if (val &gt;= 0x110000) {</span>
<span class="line-added"> 2377         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,</span>
<span class="line-added"> 2378                 &quot;xmlParseCharRef: character reference out of bounds\n&quot;,</span>
<span class="line-added"> 2379             val);</span>
<span class="line-added"> 2380     } else if (IS_CHAR(val)) {</span>
 2381         return(val);
 2382     } else {
 2383         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 2384                           &quot;xmlParseCharRef: invalid xmlChar value %d\n&quot;,
 2385                       val);
 2386     }
 2387     return(0);
 2388 }
 2389 
 2390 /**
 2391  * xmlParseStringCharRef:
 2392  * @ctxt:  an XML parser context
 2393  * @str:  a pointer to an index in the string
 2394  *
 2395  * parse Reference declarations, variant parsing from a string rather
 2396  * than an an input flow.
 2397  *
 2398  * [66] CharRef ::= &#39;&amp;#&#39; [0-9]+ &#39;;&#39; |
 2399  *                  &#39;&amp;#x&#39; [0-9a-fA-F]+ &#39;;&#39;
 2400  *
 2401  * [ WFC: Legal Character ]
 2402  * Characters referred to using character references must match the
 2403  * production for Char.
 2404  *
 2405  * Returns the value parsed (as an int), 0 in case of error, str will be
 2406  *         updated to the current value of the index
 2407  */
 2408 static int
 2409 xmlParseStringCharRef(xmlParserCtxtPtr ctxt, const xmlChar **str) {
 2410     const xmlChar *ptr;
 2411     xmlChar cur;
<span class="line-modified"> 2412     int val = 0;</span>

 2413 
 2414     if ((str == NULL) || (*str == NULL)) return(0);
 2415     ptr = *str;
 2416     cur = *ptr;
 2417     if ((cur == &#39;&amp;&#39;) &amp;&amp; (ptr[1] == &#39;#&#39;) &amp;&amp; (ptr[2] == &#39;x&#39;)) {
 2418     ptr += 3;
 2419     cur = *ptr;
 2420     while (cur != &#39;;&#39;) { /* Non input consuming loop */
 2421         if ((cur &gt;= &#39;0&#39;) &amp;&amp; (cur &lt;= &#39;9&#39;))
 2422             val = val * 16 + (cur - &#39;0&#39;);
 2423         else if ((cur &gt;= &#39;a&#39;) &amp;&amp; (cur &lt;= &#39;f&#39;))
 2424             val = val * 16 + (cur - &#39;a&#39;) + 10;
 2425         else if ((cur &gt;= &#39;A&#39;) &amp;&amp; (cur &lt;= &#39;F&#39;))
 2426             val = val * 16 + (cur - &#39;A&#39;) + 10;
 2427         else {
 2428         xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);
 2429         val = 0;
 2430         break;
 2431         }
<span class="line-modified"> 2432         if (val &gt; 0x110000)</span>
<span class="line-modified"> 2433             val = 0x110000;</span>
 2434 
 2435         ptr++;
 2436         cur = *ptr;
 2437     }
 2438     if (cur == &#39;;&#39;)
 2439         ptr++;
 2440     } else if  ((cur == &#39;&amp;&#39;) &amp;&amp; (ptr[1] == &#39;#&#39;)){
 2441     ptr += 2;
 2442     cur = *ptr;
 2443     while (cur != &#39;;&#39;) { /* Non input consuming loops */
 2444         if ((cur &gt;= &#39;0&#39;) &amp;&amp; (cur &lt;= &#39;9&#39;))
 2445             val = val * 10 + (cur - &#39;0&#39;);
 2446         else {
 2447         xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);
 2448         val = 0;
 2449         break;
 2450         }
<span class="line-modified"> 2451         if (val &gt; 0x110000)</span>
<span class="line-modified"> 2452             val = 0x110000;</span>
 2453 
 2454         ptr++;
 2455         cur = *ptr;
 2456     }
 2457     if (cur == &#39;;&#39;)
 2458         ptr++;
 2459     } else {
 2460     xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);
 2461     return(0);
 2462     }
 2463     *str = ptr;
 2464 
 2465     /*
 2466      * [ WFC: Legal Character ]
 2467      * Characters referred to using character references must match the
 2468      * production for Char.
 2469      */
<span class="line-modified"> 2470     if (val &gt;= 0x110000) {</span>
<span class="line-added"> 2471         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,</span>
<span class="line-added"> 2472                 &quot;xmlParseStringCharRef: character reference out of bounds\n&quot;,</span>
<span class="line-added"> 2473                 val);</span>
<span class="line-added"> 2474     } else if (IS_CHAR(val)) {</span>
 2475         return(val);
 2476     } else {
 2477         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 2478               &quot;xmlParseStringCharRef: invalid xmlChar value %d\n&quot;,
 2479               val);
 2480     }
 2481     return(0);
 2482 }
 2483 
 2484 /**
 2485  * xmlParserHandlePEReference:
 2486  * @ctxt:  the parser context
 2487  *
 2488  * [69] PEReference ::= &#39;%&#39; Name &#39;;&#39;
 2489  *
 2490  * [ WFC: No Recursion ]
 2491  * A parsed entity must not contain a recursive
 2492  * reference to itself, either directly or indirectly.
 2493  *
 2494  * [ WFC: Entity Declared ]
</pre>
<hr />
<pre>
 2629     xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 2630     return(NULL);
 2631     }
 2632 
 2633     /*
 2634      * allocate a translation buffer.
 2635      */
 2636     buffer_size = XML_PARSER_BIG_BUFFER_SIZE;
 2637     buffer = (xmlChar *) xmlMallocAtomic(buffer_size);
 2638     if (buffer == NULL) goto mem_error;
 2639 
 2640     /*
 2641      * OK loop until we reach one of the ending char or a size limit.
 2642      * we are operating on already parsed values.
 2643      */
 2644     if (str &lt; last)
 2645     c = CUR_SCHAR(str, l);
 2646     else
 2647         c = 0;
 2648     while ((c != 0) &amp;&amp; (c != end) &amp;&amp; /* non input consuming loop */
<span class="line-modified"> 2649            (c != end2) &amp;&amp; (c != end3) &amp;&amp;</span>
<span class="line-added"> 2650            (ctxt-&gt;instate != XML_PARSER_EOF)) {</span>
 2651 
 2652     if (c == 0) break;
 2653         if ((c == &#39;&amp;&#39;) &amp;&amp; (str[1] == &#39;#&#39;)) {
 2654         int val = xmlParseStringCharRef(ctxt, &amp;str);
 2655         if (val == 0)
 2656                 goto int_error;
 2657         COPY_BUF(0,buffer,nbchars,val);
 2658         if (nbchars + XML_PARSER_BUFFER_SIZE &gt; buffer_size) {
 2659             growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
 2660         }
 2661     } else if ((c == &#39;&amp;&#39;) &amp;&amp; (what &amp; XML_SUBSTITUTE_REF)) {
 2662         if (xmlParserDebugEntities)
 2663         xmlGenericError(xmlGenericErrorContext,
 2664             &quot;String decoding Entity Reference: %.30s\n&quot;,
 2665             str);
 2666         ent = xmlParseStringEntityRef(ctxt, &amp;str);
 2667         xmlParserEntityCheck(ctxt, 0, ent, 0);
 2668         if (ent != NULL)
 2669             ctxt-&gt;nbentities += ent-&gt;checked / 2;
 2670         if ((ent != NULL) &amp;&amp;
</pre>
<hr />
<pre>
 2706         if (nbchars + i + XML_PARSER_BUFFER_SIZE &gt; buffer_size) {
 2707             growBuffer(buffer, i + XML_PARSER_BUFFER_SIZE);
 2708         }
 2709         for (;i &gt; 0;i--)
 2710             buffer[nbchars++] = *cur++;
 2711         buffer[nbchars++] = &#39;;&#39;;
 2712         }
 2713     } else if (c == &#39;%&#39; &amp;&amp; (what &amp; XML_SUBSTITUTE_PEREF)) {
 2714         if (xmlParserDebugEntities)
 2715         xmlGenericError(xmlGenericErrorContext,
 2716             &quot;String decoding PE Reference: %.30s\n&quot;, str);
 2717         ent = xmlParseStringPEReference(ctxt, &amp;str);
 2718         xmlParserEntityCheck(ctxt, 0, ent, 0);
 2719         if (ent != NULL)
 2720             ctxt-&gt;nbentities += ent-&gt;checked / 2;
 2721         if (ent != NULL) {
 2722                 if (ent-&gt;content == NULL) {
 2723             /*
 2724              * Note: external parsed entities will not be loaded,
 2725              * it is not required for a non-validating parser to
<span class="line-modified"> 2726              * complete external PEReferences coming from the</span>
 2727              * internal subset
 2728              */
 2729             if (((ctxt-&gt;options &amp; XML_PARSE_NOENT) != 0) ||
 2730             ((ctxt-&gt;options &amp; XML_PARSE_DTDVALID) != 0) ||
 2731             (ctxt-&gt;validate != 0)) {
 2732             xmlLoadEntityContent(ctxt, ent);
 2733             } else {
 2734             xmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
 2735           &quot;not validating will not read content for PE entity %s\n&quot;,
 2736                               ent-&gt;name, NULL);
 2737             }
 2738         }
 2739         ctxt-&gt;depth++;
 2740         rep = xmlStringDecodeEntities(ctxt, ent-&gt;content, what,
 2741                                   0, 0, 0);
 2742         ctxt-&gt;depth--;
 2743         if (rep == NULL)
 2744                     goto int_error;
 2745                 current = rep;
 2746                 while (*current != 0) { /* non input consuming loop */
</pre>
<hr />
<pre>
 3370        (xmlIsNameChar(ctxt, c) &amp;&amp; (c != &#39;:&#39;))) {
 3371     if (count++ &gt; XML_PARSER_CHUNK_SIZE) {
 3372             if ((len &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3373                 ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3374                 xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;NCName&quot;);
 3375                 return(NULL);
 3376             }
 3377         count = 0;
 3378         GROW;
 3379             if (ctxt-&gt;instate == XML_PARSER_EOF)
 3380                 return(NULL);
 3381     }
 3382     len += l;
 3383     NEXTL(l);
 3384     c = CUR_CHAR(l);
 3385     if (c == 0) {
 3386         count = 0;
 3387         /*
 3388          * when shrinking to extend the buffer we really need to preserve
 3389          * the part of the name we already parsed. Hence rolling back
<span class="line-modified"> 3390          * by current length.</span>
 3391          */
 3392         ctxt-&gt;input-&gt;cur -= l;
 3393         GROW;
 3394             if (ctxt-&gt;instate == XML_PARSER_EOF)
 3395                 return(NULL);
 3396         ctxt-&gt;input-&gt;cur += l;
 3397         c = CUR_CHAR(l);
 3398     }
 3399     }
 3400     if ((len &gt; XML_MAX_NAME_LENGTH) &amp;&amp;
 3401         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 3402         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, &quot;NCName&quot;);
 3403         return(NULL);
 3404     }
 3405     return(xmlDictLookup(ctxt-&gt;dict, (BASE_PTR + startPosition), len));
 3406 }
 3407 
 3408 /**
 3409  * xmlParseNCName:
 3410  * @ctxt:  an XML parser context
</pre>
<hr />
<pre>
 3839      */
 3840     ++ctxt-&gt;depth;
 3841     ret = xmlStringDecodeEntities(ctxt, buf, XML_SUBSTITUTE_PEREF,
 3842                                   0, 0, 0);
 3843     --ctxt-&gt;depth;
 3844     if (orig != NULL) {
 3845         *orig = buf;
 3846         buf = NULL;
 3847     }
 3848 
 3849 error:
 3850     if (buf != NULL)
 3851         xmlFree(buf);
 3852     return(ret);
 3853 }
 3854 
 3855 /**
 3856  * xmlParseAttValueComplex:
 3857  * @ctxt:  an XML parser context
 3858  * @len:   the resulting attribute len
<span class="line-modified"> 3859  * @normalize:  whether to apply the inner normalization</span>
 3860  *
 3861  * parse a value for an attribute, this is the fallback function
 3862  * of xmlParseAttValue() when the attribute parsing requires handling
 3863  * of non-ASCII characters, or normalization compaction.
 3864  *
 3865  * Returns the AttValue parsed or NULL. The value has to be freed by the caller.
 3866  */
 3867 static xmlChar *
 3868 xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
 3869     xmlChar limit = 0;
 3870     xmlChar *buf = NULL;
 3871     xmlChar *rep = NULL;
 3872     size_t len = 0;
 3873     size_t buf_size = 0;
 3874     int c, l, in_space = 0;
 3875     xmlChar *current = NULL;
 3876     xmlEntityPtr ent;
 3877 
 3878     if (NXT(0) == &#39;&quot;&#39;) {
 3879     ctxt-&gt;instate = XML_PARSER_ATTRIBUTE_VALUE;
</pre>
<hr />
<pre>
 3988                 xmlFree(rep);
 3989                 rep = NULL;
 3990             }
 3991             } else {
 3992             if (len + 10 &gt; buf_size) {
 3993                 growBuffer(buf, 10);
 3994             }
 3995             if (ent-&gt;content != NULL)
 3996                 buf[len++] = ent-&gt;content[0];
 3997             }
 3998         } else if (ent != NULL) {
 3999             int i = xmlStrlen(ent-&gt;name);
 4000             const xmlChar *cur = ent-&gt;name;
 4001 
 4002             /*
 4003              * This may look absurd but is needed to detect
 4004              * entities problems
 4005              */
 4006             if ((ent-&gt;etype != XML_INTERNAL_PREDEFINED_ENTITY) &amp;&amp;
 4007             (ent-&gt;content != NULL) &amp;&amp; (ent-&gt;checked == 0)) {
<span class="line-modified"> 4008             unsigned long oldnbent = ctxt-&gt;nbentities, diff;</span>
 4009 
 4010             ++ctxt-&gt;depth;
 4011             rep = xmlStringDecodeEntities(ctxt, ent-&gt;content,
 4012                           XML_SUBSTITUTE_REF, 0, 0, 0);
 4013             --ctxt-&gt;depth;
 4014 
<span class="line-modified"> 4015                         diff = ctxt-&gt;nbentities - oldnbent + 1;</span>
<span class="line-added"> 4016                         if (diff &gt; INT_MAX / 2)</span>
<span class="line-added"> 4017                             diff = INT_MAX / 2;</span>
<span class="line-added"> 4018                         ent-&gt;checked = diff * 2;</span>
 4019             if (rep != NULL) {
 4020                 if (xmlStrchr(rep, &#39;&lt;&#39;))
 4021                     ent-&gt;checked |= 1;
 4022                 xmlFree(rep);
 4023                 rep = NULL;
 4024             } else {
 4025                             ent-&gt;content[0] = 0;
 4026                         }
 4027             }
 4028 
 4029             /*
 4030              * Just output the reference
 4031              */
 4032             buf[len++] = &#39;&amp;&#39;;
 4033             while (len + i + 10 &gt; buf_size) {
 4034             growBuffer(buf, i + 10);
 4035             }
 4036             for (;i &gt; 0;i--)
 4037             buf[len++] = *cur++;
 4038             buf[len++] = &#39;;&#39;;
</pre>
<hr />
<pre>
 4066 
 4067     if ((in_space) &amp;&amp; (normalize)) {
 4068         while ((len &gt; 0) &amp;&amp; (buf[len - 1] == 0x20)) len--;
 4069     }
 4070     buf[len] = 0;
 4071     if (RAW == &#39;&lt;&#39;) {
 4072     xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);
 4073     } else if (RAW != limit) {
 4074     if ((c != 0) &amp;&amp; (!IS_CHAR(c))) {
 4075         xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
 4076                &quot;invalid character in attribute value\n&quot;);
 4077     } else {
 4078         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 4079                &quot;AttValue: &#39; expected\n&quot;);
 4080         }
 4081     } else
 4082     NEXT;
 4083 
 4084     /*
 4085      * There we potentially risk an overflow, don&#39;t allow attribute value of
<span class="line-modified"> 4086      * length more than INT_MAX it is a very reasonable assumption !</span>
 4087      */
 4088     if (len &gt;= INT_MAX) {
 4089         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 4090                        &quot;AttValue length too long\n&quot;);
 4091         goto mem_error;
 4092     }
 4093 
 4094     if (attlen != NULL) *attlen = (int) len;
 4095     return(buf);
 4096 
 4097 mem_error:
 4098     xmlErrMemory(ctxt, NULL);
 4099 error:
 4100     if (buf != NULL)
 4101         xmlFree(buf);
 4102     if (rep != NULL)
 4103         xmlFree(rep);
 4104     return(NULL);
 4105 }
 4106 
</pre>
<hr />
<pre>
 4671          * We handle [83] so we return immediately, if
 4672          * &quot;S SystemLiteral&quot; is not detected. We skip blanks if no
 4673              * system literal was found, but this is harmless since we must
 4674              * be at the end of a NotationDecl.
 4675          */
 4676         if (SKIP_BLANKS == 0) return(NULL);
 4677         if ((CUR != &#39;\&#39;&#39;) &amp;&amp; (CUR != &#39;&quot;&#39;)) return(NULL);
 4678     }
 4679     URI = xmlParseSystemLiteral(ctxt);
 4680     if (URI == NULL) {
 4681         xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);
 4682         }
 4683     }
 4684     return(URI);
 4685 }
 4686 
 4687 /**
 4688  * xmlParseCommentComplex:
 4689  * @ctxt:  an XML parser context
 4690  * @buf:  the already parsed part of the buffer
<span class="line-modified"> 4691  * @len:  number of bytes in the buffer</span>
 4692  * @size:  allocated size of the buffer
 4693  *
 4694  * Skip an XML (SGML) comment &lt;!-- .... --&gt;
 4695  *  The spec says that &quot;For compatibility, the string &quot;--&quot; (double-hyphen)
 4696  *  must not occur within comments. &quot;
 4697  * This is the slow routine in case the accelerator for ascii didn&#39;t work
 4698  *
 4699  * [15] Comment ::= &#39;&lt;!--&#39; ((Char - &#39;-&#39;) | (&#39;-&#39; (Char - &#39;-&#39;)))* &#39;--&gt;&#39;
 4700  */
 4701 static void
 4702 xmlParseCommentComplex(xmlParserCtxtPtr ctxt, xmlChar *buf,
 4703                        size_t len, size_t size) {
 4704     int q, ql;
 4705     int r, rl;
 4706     int cur, l;
 4707     size_t count = 0;
 4708     int inputid;
 4709 
 4710     inputid = ctxt-&gt;input-&gt;id;
 4711 
</pre>
<hr />
<pre>
 4962                 (!ctxt-&gt;disableSAX)) {
 4963             if (buf != NULL)
 4964                 ctxt-&gt;sax-&gt;comment(ctxt-&gt;userData, buf);
 4965             else
 4966                 ctxt-&gt;sax-&gt;comment(ctxt-&gt;userData, BAD_CAST &quot;&quot;);
 4967             }
 4968             if (buf != NULL)
 4969                 xmlFree(buf);
 4970             if (ctxt-&gt;instate != XML_PARSER_EOF)
 4971             ctxt-&gt;instate = state;
 4972             return;
 4973         }
 4974         if (buf != NULL) {
 4975             xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
 4976                               &quot;Double hyphen within comment: &quot;
 4977                                       &quot;&lt;!--%.50s\n&quot;,
 4978                       buf);
 4979         } else
 4980             xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
 4981                               &quot;Double hyphen within comment\n&quot;, NULL);
<span class="line-added"> 4982                 if (ctxt-&gt;instate == XML_PARSER_EOF) {</span>
<span class="line-added"> 4983                     xmlFree(buf);</span>
<span class="line-added"> 4984                     return;</span>
<span class="line-added"> 4985                 }</span>
 4986         in++;
 4987         ctxt-&gt;input-&gt;col++;
 4988         }
 4989         in++;
 4990         ctxt-&gt;input-&gt;col++;
 4991         goto get_more;
 4992     }
 4993     } while (((*in &gt;= 0x20) &amp;&amp; (*in &lt;= 0x7F)) || (*in == 0x09));
 4994     xmlParseCommentComplex(ctxt, buf, len, size);
 4995     ctxt-&gt;instate = state;
 4996     return;
 4997 }
 4998 
 4999 
 5000 /**
 5001  * xmlParsePITarget:
 5002  * @ctxt:  an XML parser context
 5003  *
 5004  * parse the name of a PI
 5005  *
</pre>
<hr />
<pre>
 5096     }
 5097     return;
 5098 
 5099 error:
 5100     xmlWarningMsg(ctxt, XML_WAR_CATALOG_PI,
 5101               &quot;Catalog PI syntax error: %s\n&quot;,
 5102           catalog, NULL);
 5103     if (URL != NULL)
 5104     xmlFree(URL);
 5105 }
 5106 #endif
 5107 
 5108 /**
 5109  * xmlParsePI:
 5110  * @ctxt:  an XML parser context
 5111  *
 5112  * parse an XML Processing Instruction.
 5113  *
 5114  * [16] PI ::= &#39;&lt;?&#39; PITarget (S (Char* - (Char* &#39;?&gt;&#39; Char*)))? &#39;?&gt;&#39;
 5115  *
<span class="line-modified"> 5116  * The processing is transferred to SAX once parsed.</span>
 5117  */
 5118 
 5119 void
 5120 xmlParsePI(xmlParserCtxtPtr ctxt) {
 5121     xmlChar *buf = NULL;
 5122     size_t len = 0;
 5123     size_t size = XML_PARSER_BUFFER_SIZE;
 5124     int cur, l;
 5125     const xmlChar *target;
 5126     xmlParserInputState state;
 5127     int count = 0;
 5128 
 5129     if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;?&#39;)) {
 5130     int inputid = ctxt-&gt;input-&gt;id;
 5131     state = ctxt-&gt;instate;
 5132         ctxt-&gt;instate = XML_PARSER_PI;
 5133     /*
 5134      * this is a Processing Instruction.
 5135      */
 5136     SKIP(2);
</pre>
<hr />
<pre>
 5512         }
 5513         if (CMP5(CUR_PTR, &#39;N&#39;, &#39;D&#39;, &#39;A&#39;, &#39;T&#39;, &#39;A&#39;)) {
 5514             SKIP(5);
 5515             if (SKIP_BLANKS == 0) {
 5516             xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5517                        &quot;Space required after &#39;NDATA&#39;\n&quot;);
 5518             }
 5519             ndata = xmlParseName(ctxt);
 5520             if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX) &amp;&amp;
 5521                 (ctxt-&gt;sax-&gt;unparsedEntityDecl != NULL))
 5522             ctxt-&gt;sax-&gt;unparsedEntityDecl(ctxt-&gt;userData, name,
 5523                     literal, URI, ndata);
 5524         } else {
 5525             if ((ctxt-&gt;sax != NULL) &amp;&amp;
 5526                 (!ctxt-&gt;disableSAX) &amp;&amp; (ctxt-&gt;sax-&gt;entityDecl != NULL))
 5527             ctxt-&gt;sax-&gt;entityDecl(ctxt-&gt;userData, name,
 5528                     XML_EXTERNAL_GENERAL_PARSED_ENTITY,
 5529                     literal, URI, NULL);
 5530             /*
 5531              * For expat compatibility in SAX mode.
<span class="line-modified"> 5532              * assuming the entity replacement was asked for</span>
 5533              */
 5534             if ((ctxt-&gt;replaceEntities != 0) &amp;&amp;
 5535             ((ctxt-&gt;myDoc == NULL) ||
 5536             (xmlStrEqual(ctxt-&gt;myDoc-&gt;version, SAX_COMPAT_MODE)))) {
 5537             if (ctxt-&gt;myDoc == NULL) {
 5538                 ctxt-&gt;myDoc = xmlNewDoc(SAX_COMPAT_MODE);
 5539                 if (ctxt-&gt;myDoc == NULL) {
 5540                     xmlErrMemory(ctxt, &quot;New Doc failed&quot;);
 5541                 return;
 5542                 }
 5543                 ctxt-&gt;myDoc-&gt;properties = XML_DOC_INTERNAL;
 5544             }
 5545 
 5546             if (ctxt-&gt;myDoc-&gt;intSubset == NULL)
 5547                 ctxt-&gt;myDoc-&gt;intSubset = xmlNewDtd(ctxt-&gt;myDoc,
 5548                         BAD_CAST &quot;fake&quot;, NULL, NULL);
 5549             xmlSAX2EntityDecl(ctxt, name,
 5550                           XML_EXTERNAL_GENERAL_PARSED_ENTITY,
 5551                           literal, URI, NULL);
 5552             }
</pre>
<hr />
<pre>
 6622         xmlFreeDocElementContent(ctxt-&gt;myDoc, content);
 6623         }
 6624     }
 6625     }
 6626     return(ret);
 6627 }
 6628 
 6629 /**
 6630  * xmlParseConditionalSections
 6631  * @ctxt:  an XML parser context
 6632  *
 6633  * [61] conditionalSect ::= includeSect | ignoreSect
 6634  * [62] includeSect ::= &#39;&lt;![&#39; S? &#39;INCLUDE&#39; S? &#39;[&#39; extSubsetDecl &#39;]]&gt;&#39;
 6635  * [63] ignoreSect ::= &#39;&lt;![&#39; S? &#39;IGNORE&#39; S? &#39;[&#39; ignoreSectContents* &#39;]]&gt;&#39;
 6636  * [64] ignoreSectContents ::= Ignore (&#39;&lt;![&#39; ignoreSectContents &#39;]]&gt;&#39; Ignore)*
 6637  * [65] Ignore ::= Char* - (Char* (&#39;&lt;![&#39; | &#39;]]&gt;&#39;) Char*)
 6638  */
 6639 
 6640 static void
 6641 xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
<span class="line-added"> 6642     int *inputIds = NULL;</span>
<span class="line-added"> 6643     size_t inputIdsSize = 0;</span>
<span class="line-added"> 6644     size_t depth = 0;</span>
<span class="line-added"> 6645 </span>
<span class="line-added"> 6646     while (ctxt-&gt;instate != XML_PARSER_EOF) {</span>
<span class="line-added"> 6647         if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {</span>
 6648     int id = ctxt-&gt;input-&gt;id;
 6649 
 6650     SKIP(3);
 6651     SKIP_BLANKS;
<span class="line-added"> 6652 </span>
 6653     if (CMP7(CUR_PTR, &#39;I&#39;, &#39;N&#39;, &#39;C&#39;, &#39;L&#39;, &#39;U&#39;, &#39;D&#39;, &#39;E&#39;)) {
 6654     SKIP(7);
 6655     SKIP_BLANKS;
 6656     if (RAW != &#39;[&#39;) {
 6657         xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
 6658         xmlHaltParser(ctxt);
<span class="line-modified"> 6659                     goto error;</span>
<span class="line-modified"> 6660                 }</span>
 6661         if (ctxt-&gt;input-&gt;id != id) {
 6662         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
<span class="line-modified"> 6663                                    &quot;All markup of the conditional section is&quot;</span>
<span class="line-modified"> 6664                                    &quot; not in the same entity\n&quot;);</span>
 6665         }
 6666         NEXT;









 6667 
<span class="line-modified"> 6668                 if (inputIdsSize &lt;= depth) {</span>
<span class="line-modified"> 6669                     int *tmp;</span>












 6670 
<span class="line-modified"> 6671                     inputIdsSize = (inputIdsSize == 0 ? 4 : inputIdsSize * 2);</span>
<span class="line-modified"> 6672                     tmp = (int *) xmlRealloc(inputIds,</span>
<span class="line-modified"> 6673                             inputIdsSize * sizeof(int));</span>
<span class="line-modified"> 6674                     if (tmp == NULL) {</span>
<span class="line-added"> 6675                         xmlErrMemory(ctxt, NULL);</span>
<span class="line-added"> 6676                         goto error;</span>
 6677         }
<span class="line-added"> 6678                     inputIds = tmp;</span>
 6679     }
<span class="line-modified"> 6680                 inputIds[depth] = id;</span>
<span class="line-modified"> 6681                 depth++;</span>







 6682     } else if (CMP6(CUR_PTR, &#39;I&#39;, &#39;G&#39;, &#39;N&#39;, &#39;O&#39;, &#39;R&#39;, &#39;E&#39;)) {
 6683     int state;
 6684     xmlParserInputState instate;
<span class="line-modified"> 6685                 size_t ignoreDepth = 0;</span>
 6686 
 6687     SKIP(6);
 6688     SKIP_BLANKS;
 6689     if (RAW != &#39;[&#39;) {
 6690         xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
 6691         xmlHaltParser(ctxt);
<span class="line-modified"> 6692                     goto error;</span>
<span class="line-modified"> 6693                 }</span>
 6694         if (ctxt-&gt;input-&gt;id != id) {
 6695         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
<span class="line-modified"> 6696                                    &quot;All markup of the conditional section is&quot;</span>
<span class="line-modified"> 6697                                    &quot; not in the same entity\n&quot;);</span>
 6698         }
 6699         NEXT;









 6700 
 6701     /*
<span class="line-modified"> 6702                  * Parse up to the end of the conditional section but disable</span>
<span class="line-modified"> 6703                  * SAX event generating DTD building in the meantime</span>
 6704      */
 6705     state = ctxt-&gt;disableSAX;
 6706     instate = ctxt-&gt;instate;
 6707     if (ctxt-&gt;recovery == 0) ctxt-&gt;disableSAX = 1;
 6708     ctxt-&gt;instate = XML_PARSER_IGNORE;
 6709 
<span class="line-modified"> 6710                 while (RAW != 0) {</span>

 6711       if ((RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {

 6712         SKIP(3);
<span class="line-modified"> 6713                         ignoreDepth++;</span>
<span class="line-modified"> 6714                         /* Check for integer overflow */</span>
<span class="line-modified"> 6715                         if (ignoreDepth == 0) {</span>
<span class="line-modified"> 6716                             xmlErrMemory(ctxt, NULL);</span>
<span class="line-modified"> 6717                             goto error;</span>
 6718       }
<span class="line-added"> 6719                     } else if ((RAW == &#39;]&#39;) &amp;&amp; (NXT(1) == &#39;]&#39;) &amp;&amp;</span>
<span class="line-added"> 6720                                (NXT(2) == &#39;&gt;&#39;)) {</span>
<span class="line-added"> 6721                         if (ignoreDepth == 0)</span>
<span class="line-added"> 6722                             break;</span>
<span class="line-added"> 6723                         SKIP(3);</span>
<span class="line-added"> 6724                         ignoreDepth--;</span>
<span class="line-added"> 6725                     } else {</span>
 6726       NEXT;
<span class="line-modified"> 6727                     }</span>
 6728     }
 6729 
 6730     ctxt-&gt;disableSAX = state;
 6731     ctxt-&gt;instate = instate;
 6732 
<span class="line-modified"> 6733         if (RAW == 0) {</span>
<span class="line-modified"> 6734             xmlFatalErr(ctxt, XML_ERR_CONDSEC_NOT_FINISHED, NULL);</span>
<span class="line-modified"> 6735                     goto error;</span>




 6736     }
<span class="line-modified"> 6737                 if (ctxt-&gt;input-&gt;id != id) {</span>
<span class="line-added"> 6738                     xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,</span>
<span class="line-added"> 6739                                    &quot;All markup of the conditional section is&quot;</span>
<span class="line-added"> 6740                                    &quot; not in the same entity\n&quot;);</span>
<span class="line-added"> 6741                 }</span>
<span class="line-added"> 6742                 SKIP(3);</span>
 6743     } else {
 6744     xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID_KEYWORD, NULL);
 6745     xmlHaltParser(ctxt);
<span class="line-modified"> 6746                 goto error;</span>
 6747     }
<span class="line-modified"> 6748         } else if ((depth &gt; 0) &amp;&amp;</span>
<span class="line-modified"> 6749                    (RAW == &#39;]&#39;) &amp;&amp; (NXT(1) == &#39;]&#39;) &amp;&amp; (NXT(2) == &#39;&gt;&#39;)) {</span>
<span class="line-modified"> 6750             depth--;</span>
<span class="line-modified"> 6751             if (ctxt-&gt;input-&gt;id != inputIds[depth]) {</span>




 6752         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
<span class="line-modified"> 6753                                &quot;All markup of the conditional section is not&quot;</span>
<span class="line-modified"> 6754                                &quot; in the same entity\n&quot;);</span>
 6755     }


 6756         SKIP(3);
<span class="line-added"> 6757         } else {</span>
<span class="line-added"> 6758             const xmlChar *check = CUR_PTR;</span>
<span class="line-added"> 6759             unsigned int cons = ctxt-&gt;input-&gt;consumed;</span>
<span class="line-added"> 6760 </span>
<span class="line-added"> 6761             xmlParseMarkupDecl(ctxt);</span>
<span class="line-added"> 6762 </span>
<span class="line-added"> 6763             if ((CUR_PTR == check) &amp;&amp; (cons == ctxt-&gt;input-&gt;consumed)) {</span>
<span class="line-added"> 6764                 xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);</span>
<span class="line-added"> 6765                 xmlHaltParser(ctxt);</span>
<span class="line-added"> 6766                 goto error;</span>
<span class="line-added"> 6767             }</span>
<span class="line-added"> 6768     }</span>
<span class="line-added"> 6769 </span>
<span class="line-added"> 6770         if (depth == 0)</span>
<span class="line-added"> 6771             break;</span>
<span class="line-added"> 6772 </span>
<span class="line-added"> 6773         SKIP_BLANKS;</span>
<span class="line-added"> 6774         GROW;</span>
 6775     }
<span class="line-added"> 6776 </span>
<span class="line-added"> 6777 error:</span>
<span class="line-added"> 6778     xmlFree(inputIds);</span>
 6779 }
 6780 
 6781 /**
 6782  * xmlParseMarkupDecl:
 6783  * @ctxt:  an XML parser context
 6784  *
 6785  * parse Markup declarations
 6786  *
 6787  * [29] markupdecl ::= elementdecl | AttlistDecl | EntityDecl |
 6788  *                     NotationDecl | PI | Comment
 6789  *
 6790  * [ VC: Proper Declaration/PE Nesting ]
 6791  * Parameter-entity replacement text must be properly nested with
 6792  * markup declarations. That is to say, if either the first character
 6793  * or the last character of a markup declaration (markupdecl above) is
 6794  * contained in the replacement text for a parameter-entity reference,
 6795  * both must be contained in the same replacement text.
 6796  *
 6797  * [ WFC: PEs in Internal Subset ]
 6798  * In the internal DTD subset, parameter-entity references can occur
</pre>
<hr />
<pre>
 6815             case &#39;A&#39;:
 6816             xmlParseAttributeListDecl(ctxt);
 6817             break;
 6818             case &#39;N&#39;:
 6819             xmlParseNotationDecl(ctxt);
 6820             break;
 6821             case &#39;-&#39;:
 6822             xmlParseComment(ctxt);
 6823             break;
 6824         default:
 6825             /* there is an error but it will be detected later */
 6826             break;
 6827         }
 6828     } else if (NXT(1) == &#39;?&#39;) {
 6829         xmlParsePI(ctxt);
 6830     }
 6831     }
 6832 
 6833     /*
 6834      * detect requirement to exit there and act accordingly
<span class="line-modified"> 6835      * and avoid having instate overridden later on</span>
 6836      */
 6837     if (ctxt-&gt;instate == XML_PARSER_EOF)
 6838         return;
 6839 










 6840     ctxt-&gt;instate = XML_PARSER_DTD;
 6841 }
 6842 
 6843 /**
 6844  * xmlParseTextDecl:
 6845  * @ctxt:  an XML parser context
 6846  *
 6847  * parse an XML declaration header for external entities
 6848  *
 6849  * [77] TextDecl ::= &#39;&lt;?xml&#39; VersionInfo? EncodingDecl S? &#39;?&gt;&#39;
 6850  */
 6851 
 6852 void
 6853 xmlParseTextDecl(xmlParserCtxtPtr ctxt) {
 6854     xmlChar *version;
 6855     const xmlChar *encoding;
 6856 
 6857     /*
 6858      * We know that &#39;&lt;?xml&#39; is here.
 6859      */
</pre>
<hr />
<pre>
 7004  *
 7005  * [67] Reference ::= EntityRef | CharRef
 7006  */
 7007 void
 7008 xmlParseReference(xmlParserCtxtPtr ctxt) {
 7009     xmlEntityPtr ent;
 7010     xmlChar *val;
 7011     int was_checked;
 7012     xmlNodePtr list = NULL;
 7013     xmlParserErrors ret = XML_ERR_OK;
 7014 
 7015 
 7016     if (RAW != &#39;&amp;&#39;)
 7017         return;
 7018 
 7019     /*
 7020      * Simple case of a CharRef
 7021      */
 7022     if (NXT(1) == &#39;#&#39;) {
 7023     int i = 0;
<span class="line-modified"> 7024     xmlChar out[16];</span>
 7025     int hex = NXT(2);
 7026     int value = xmlParseCharRef(ctxt);
 7027 
 7028     if (value == 0)
 7029         return;
 7030     if (ctxt-&gt;charset != XML_CHAR_ENCODING_UTF8) {
 7031         /*
 7032          * So we are using non-UTF-8 buffers
 7033          * Check that the char fit on 8bits, if not
 7034          * generate a CharRef.
 7035          */
 7036         if (value &lt;= 0xFF) {
 7037         out[0] = value;
 7038         out[1] = 0;
 7039         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;characters != NULL) &amp;&amp;
 7040             (!ctxt-&gt;disableSAX))
 7041             ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, out, 1);
 7042         } else {
 7043         if ((hex == &#39;x&#39;) || (hex == &#39;X&#39;))
 7044             snprintf((char *)out, sizeof(out), &quot;#x%X&quot;, value);
</pre>
<hr />
<pre>
 7081     if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;characters != NULL) &amp;&amp;
 7082         (!ctxt-&gt;disableSAX))
 7083         ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, val, xmlStrlen(val));
 7084     return;
 7085     }
 7086 
 7087     /*
 7088      * The first reference to the entity trigger a parsing phase
 7089      * where the ent-&gt;children is filled with the result from
 7090      * the parsing.
 7091      * Note: external parsed entities will not be loaded, it is not
 7092      * required for a non-validating parser, unless the parsing option
 7093      * of validating, or substituting entities were given. Doing so is
 7094      * far more secure as the parser will only process data coming from
 7095      * the document entity by default.
 7096      */
 7097     if (((ent-&gt;checked == 0) ||
 7098          ((ent-&gt;children == NULL) &amp;&amp; (ctxt-&gt;options &amp; XML_PARSE_NOENT))) &amp;&amp;
 7099         ((ent-&gt;etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
 7100          (ctxt-&gt;options &amp; (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {
<span class="line-modified"> 7101     unsigned long oldnbent = ctxt-&gt;nbentities, diff;</span>
 7102 
 7103     /*
 7104      * This is a bit hackish but this seems the best
 7105      * way to make sure both SAX and DOM entity support
 7106      * behaves okay.
 7107      */
 7108     void *user_data;
 7109     if (ctxt-&gt;userData == ctxt)
 7110         user_data = NULL;
 7111     else
 7112         user_data = ctxt-&gt;userData;
 7113 
 7114     /*
 7115      * Check that this entity is well formed
 7116      * 4.3.2: An internal general parsed entity is well-formed
 7117      * if its replacement text matches the production labeled
 7118      * content.
 7119      */
 7120     if (ent-&gt;etype == XML_INTERNAL_GENERAL_ENTITY) {
 7121         ctxt-&gt;depth++;
 7122         ret = xmlParseBalancedChunkMemoryInternal(ctxt, ent-&gt;content,
 7123                                                   user_data, &amp;list);
 7124         ctxt-&gt;depth--;
 7125 
 7126     } else if (ent-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
 7127         ctxt-&gt;depth++;
 7128         ret = xmlParseExternalEntityPrivate(ctxt-&gt;myDoc, ctxt, ctxt-&gt;sax,
 7129                                        user_data, ctxt-&gt;depth, ent-&gt;URI,
 7130                        ent-&gt;ExternalID, &amp;list);
 7131         ctxt-&gt;depth--;
 7132     } else {
 7133         ret = XML_ERR_ENTITY_PE_INTERNAL;
 7134         xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,
 7135              &quot;invalid entity type found\n&quot;, NULL);
 7136     }
 7137 
 7138     /*
 7139      * Store the number of entities needing parsing for this entity
 7140      * content and do checkings
 7141      */
<span class="line-modified"> 7142         diff = ctxt-&gt;nbentities - oldnbent + 1;</span>
<span class="line-added"> 7143         if (diff &gt; INT_MAX / 2)</span>
<span class="line-added"> 7144             diff = INT_MAX / 2;</span>
<span class="line-added"> 7145         ent-&gt;checked = diff * 2;</span>
 7146     if ((ent-&gt;content != NULL) &amp;&amp; (xmlStrchr(ent-&gt;content, &#39;&lt;&#39;)))
 7147         ent-&gt;checked |= 1;
 7148     if (ret == XML_ERR_ENTITY_LOOP) {
 7149         xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 7150         xmlFreeNodeList(list);
 7151         return;
 7152     }
 7153     if (xmlParserEntityCheck(ctxt, 0, ent, 0)) {
 7154         xmlFreeNodeList(list);
 7155         return;
 7156     }
 7157 
 7158     if ((ret == XML_ERR_OK) &amp;&amp; (list != NULL)) {
 7159         if (((ent-&gt;etype == XML_INTERNAL_GENERAL_ENTITY) ||
 7160          (ent-&gt;etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY))&amp;&amp;
 7161         (ent-&gt;children == NULL)) {
 7162         ent-&gt;children = list;
 7163         if (ctxt-&gt;replaceEntities) {
 7164             /*
 7165              * Prune it directly in the generated document
</pre>
<hr />
<pre>
 7673         xmlFree(name);
 7674     *str = ptr;
 7675     return(NULL);
 7676     }
 7677     ptr++;
 7678 
 7679 
 7680     /*
 7681      * Predefined entities override any extra definition
 7682      */
 7683     if ((ctxt-&gt;options &amp; XML_PARSE_OLDSAX) == 0) {
 7684         ent = xmlGetPredefinedEntity(name);
 7685         if (ent != NULL) {
 7686             xmlFree(name);
 7687             *str = ptr;
 7688             return(ent);
 7689         }
 7690     }
 7691 
 7692     /*
<span class="line-modified"> 7693      * Increase the number of entity references parsed</span>
 7694      */
 7695     ctxt-&gt;nbentities++;
 7696 
 7697     /*
 7698      * Ask first SAX for entity resolution, otherwise try the
 7699      * entities which may have stored in the parser context.
 7700      */
 7701     if (ctxt-&gt;sax != NULL) {
 7702     if (ctxt-&gt;sax-&gt;getEntity != NULL)
 7703         ent = ctxt-&gt;sax-&gt;getEntity(ctxt-&gt;userData, name);
 7704     if ((ent == NULL) &amp;&amp; (ctxt-&gt;options &amp; XML_PARSE_OLDSAX))
 7705         ent = xmlGetPredefinedEntity(name);
 7706     if ((ent == NULL) &amp;&amp; (ctxt-&gt;userData==ctxt)) {
 7707         ent = xmlSAX2GetEntity(ctxt, name);
 7708     }
 7709     }
 7710     if (ctxt-&gt;instate == XML_PARSER_EOF) {
 7711     xmlFree(name);
 7712     return(NULL);
 7713     }
</pre>
<hr />
<pre>
 7849 
 7850     if (RAW != &#39;%&#39;)
 7851         return;
 7852     NEXT;
 7853     name = xmlParseName(ctxt);
 7854     if (name == NULL) {
 7855     xmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, &quot;PEReference: no name\n&quot;);
 7856     return;
 7857     }
 7858     if (xmlParserDebugEntities)
 7859     xmlGenericError(xmlGenericErrorContext,
 7860         &quot;PEReference: %s\n&quot;, name);
 7861     if (RAW != &#39;;&#39;) {
 7862     xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);
 7863         return;
 7864     }
 7865 
 7866     NEXT;
 7867 
 7868     /*
<span class="line-modified"> 7869      * Increase the number of entity references parsed</span>
 7870      */
 7871     ctxt-&gt;nbentities++;
 7872 
 7873     /*
 7874      * Request the entity from SAX
 7875      */
 7876     if ((ctxt-&gt;sax != NULL) &amp;&amp;
 7877     (ctxt-&gt;sax-&gt;getParameterEntity != NULL))
 7878     entity = ctxt-&gt;sax-&gt;getParameterEntity(ctxt-&gt;userData, name);
 7879     if (ctxt-&gt;instate == XML_PARSER_EOF)
 7880     return;
 7881     if (entity == NULL) {
 7882     /*
 7883      * [ WFC: Entity Declared ]
 7884      * In a document without any DTD, a document with only an
 7885      * internal DTD subset which contains no parameter entity
 7886      * references, or a document with &quot;standalone=&#39;yes&#39;&quot;, ...
 7887      * ... The declaration of a parameter entity must precede
 7888      * any reference to it...
 7889      */
</pre>
<hr />
<pre>
 8115     if (cur != &#39;%&#39;)
 8116         return(NULL);
 8117     ptr++;
 8118     name = xmlParseStringName(ctxt, &amp;ptr);
 8119     if (name == NULL) {
 8120     xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 8121                &quot;xmlParseStringPEReference: no name\n&quot;);
 8122     *str = ptr;
 8123     return(NULL);
 8124     }
 8125     cur = *ptr;
 8126     if (cur != &#39;;&#39;) {
 8127     xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
 8128     xmlFree(name);
 8129     *str = ptr;
 8130     return(NULL);
 8131     }
 8132     ptr++;
 8133 
 8134     /*
<span class="line-modified"> 8135      * Increase the number of entity references parsed</span>
 8136      */
 8137     ctxt-&gt;nbentities++;
 8138 
 8139     /*
 8140      * Request the entity from SAX
 8141      */
 8142     if ((ctxt-&gt;sax != NULL) &amp;&amp;
 8143     (ctxt-&gt;sax-&gt;getParameterEntity != NULL))
 8144     entity = ctxt-&gt;sax-&gt;getParameterEntity(ctxt-&gt;userData, name);
 8145     if (ctxt-&gt;instate == XML_PARSER_EOF) {
 8146     xmlFree(name);
 8147     *str = ptr;
 8148     return(NULL);
 8149     }
 8150     if (entity == NULL) {
 8151     /*
 8152      * [ WFC: Entity Declared ]
 8153      * In a document without any DTD, a document with only an
 8154      * internal DTD subset which contains no parameter entity
 8155      * references, or a document with &quot;standalone=&#39;yes&#39;&quot;, ...
</pre>
<hr />
<pre>
 8283      * Is there any DTD definition ?
 8284      */
 8285     if (RAW == &#39;[&#39;) {
 8286         int baseInputNr = ctxt-&gt;inputNr;
 8287         ctxt-&gt;instate = XML_PARSER_DTD;
 8288         NEXT;
 8289     /*
 8290      * Parse the succession of Markup declarations and
 8291      * PEReferences.
 8292      * Subsequence (markupdecl | PEReference | S)*
 8293      */
 8294     while (((RAW != &#39;]&#39;) || (ctxt-&gt;inputNr &gt; baseInputNr)) &amp;&amp;
 8295                (ctxt-&gt;instate != XML_PARSER_EOF)) {
 8296         const xmlChar *check = CUR_PTR;
 8297         unsigned int cons = ctxt-&gt;input-&gt;consumed;
 8298 
 8299         SKIP_BLANKS;
 8300         xmlParseMarkupDecl(ctxt);
 8301         xmlParsePEReference(ctxt);
 8302 
<span class="line-added"> 8303             /*</span>
<span class="line-added"> 8304              * Conditional sections are allowed from external entities included</span>
<span class="line-added"> 8305              * by PE References in the internal subset.</span>
<span class="line-added"> 8306              */</span>
<span class="line-added"> 8307             if ((ctxt-&gt;inputNr &gt; 1) &amp;&amp; (ctxt-&gt;input-&gt;filename != NULL) &amp;&amp;</span>
<span class="line-added"> 8308                 (RAW == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp; (NXT(2) == &#39;[&#39;)) {</span>
<span class="line-added"> 8309                 xmlParseConditionalSections(ctxt);</span>
<span class="line-added"> 8310             }</span>
<span class="line-added"> 8311 </span>
 8312         if ((CUR_PTR == check) &amp;&amp; (cons == ctxt-&gt;input-&gt;consumed)) {
 8313         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 8314          &quot;xmlParseInternalSubset: error detected in Markup declaration\n&quot;);
 8315                 if (ctxt-&gt;inputNr &gt; baseInputNr)
 8316                     xmlPopInput(ctxt);
 8317                 else
 8318             break;
 8319         }
 8320     }
 8321     if (RAW == &#39;]&#39;) {
 8322         NEXT;
 8323         SKIP_BLANKS;
 8324     }
 8325     }
 8326 
 8327     /*
 8328      * We should be at the end of the DOCTYPE declaration.
 8329      */
 8330     if (RAW != &#39;&gt;&#39;) {
 8331     xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);
</pre>
<hr />
<pre>
 8720     l = xmlParseNCName(ctxt);
 8721     if (l == NULL) {
 8722         if (CUR == &#39;:&#39;) {
 8723         l = xmlParseName(ctxt);
 8724         if (l != NULL) {
 8725             xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8726                  &quot;Failed to parse QName &#39;%s&#39;\n&quot;, l, NULL, NULL);
 8727         *prefix = NULL;
 8728         return(l);
 8729         }
 8730     }
 8731         return(NULL);
 8732     }
 8733     if (CUR == &#39;:&#39;) {
 8734         NEXT;
 8735     p = l;
 8736     l = xmlParseNCName(ctxt);
 8737     if (l == NULL) {
 8738         xmlChar *tmp;
 8739 
<span class="line-added"> 8740             if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-added"> 8741                 return(NULL);</span>
 8742             xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8743                  &quot;Failed to parse QName &#39;%s:&#39;\n&quot;, p, NULL, NULL);
 8744         l = xmlParseNmtoken(ctxt);
<span class="line-modified"> 8745         if (l == NULL) {</span>
<span class="line-added"> 8746                 if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-added"> 8747                     return(NULL);</span>
 8748         tmp = xmlBuildQName(BAD_CAST &quot;&quot;, p, NULL, 0);
<span class="line-modified"> 8749             } else {</span>
 8750         tmp = xmlBuildQName(l, p, NULL, 0);
 8751         xmlFree((char *)l);
 8752         }
 8753         p = xmlDictLookup(ctxt-&gt;dict, tmp, -1);
 8754         if (tmp != NULL) xmlFree(tmp);
 8755         *prefix = NULL;
 8756         return(p);
 8757     }
 8758     if (CUR == &#39;:&#39;) {
 8759         xmlChar *tmp;
 8760 
 8761             xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8762                  &quot;Failed to parse QName &#39;%s:%s:&#39;\n&quot;, p, l, NULL);
 8763         NEXT;
 8764         tmp = (xmlChar *) xmlParseName(ctxt);
 8765         if (tmp != NULL) {
 8766             tmp = xmlBuildQName(tmp, l, NULL, 0);
 8767         l = xmlDictLookup(ctxt-&gt;dict, tmp, -1);
 8768         if (tmp != NULL) xmlFree(tmp);
 8769         *prefix = p;
 8770         return(l);
 8771         }
<span class="line-added"> 8772             if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-added"> 8773                 return(NULL);</span>
 8774         tmp = xmlBuildQName(BAD_CAST &quot;&quot;, l, NULL, 0);
 8775         l = xmlDictLookup(ctxt-&gt;dict, tmp, -1);
 8776         if (tmp != NULL) xmlFree(tmp);
 8777         *prefix = p;
 8778         return(l);
 8779     }
 8780     *prefix = p;
 8781     } else
 8782         *prefix = NULL;
 8783     return(l);
 8784 }
 8785 
 8786 /**
 8787  * xmlParseQNameAndCompare:
 8788  * @ctxt:  an XML parser context
 8789  * @name:  the localname
 8790  * @prefix:  the prefix, if any.
 8791  *
 8792  * parse an XML name and compares for match
 8793  * (specialized for endtag parsing)
</pre>
<hr />
<pre>
 8853  * - a character reference is processed by appending the referenced
 8854  *   character to the attribute value
 8855  * - an entity reference is processed by recursively processing the
 8856  *   replacement text of the entity
 8857  * - a whitespace character (#x20, #xD, #xA, #x9) is processed by
 8858  *   appending #x20 to the normalized value, except that only a single
 8859  *   #x20 is appended for a &quot;#xD#xA&quot; sequence that is part of an external
 8860  *   parsed entity or the literal entity value of an internal parsed entity
 8861  * - other characters are processed by appending them to the normalized value
 8862  * If the declared value is not CDATA, then the XML processor must further
 8863  * process the normalized attribute value by discarding any leading and
 8864  * trailing space (#x20) characters, and by replacing sequences of space
 8865  * (#x20) characters by a single space (#x20) character.
 8866  * All attributes for which no declaration has been read should be treated
 8867  * by a non-validating parser as if declared CDATA.
 8868  *
 8869  * Returns the AttValue parsed or NULL. The value has to be freed by the
 8870  *     caller if it was copied, this can be detected by val[*len] == 0.
 8871  */
 8872 
<span class="line-added"> 8873 #define GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end) \</span>
<span class="line-added"> 8874     const xmlChar *oldbase = ctxt-&gt;input-&gt;base;\</span>
<span class="line-added"> 8875     GROW;\</span>
<span class="line-added"> 8876     if (ctxt-&gt;instate == XML_PARSER_EOF)\</span>
<span class="line-added"> 8877         return(NULL);\</span>
<span class="line-added"> 8878     if (oldbase != ctxt-&gt;input-&gt;base) {\</span>
<span class="line-added"> 8879         ptrdiff_t delta = ctxt-&gt;input-&gt;base - oldbase;\</span>
<span class="line-added"> 8880         start = start + delta;\</span>
<span class="line-added"> 8881         in = in + delta;\</span>
<span class="line-added"> 8882     }\</span>
<span class="line-added"> 8883     end = ctxt-&gt;input-&gt;end;</span>
<span class="line-added"> 8884 </span>
 8885 static xmlChar *
 8886 xmlParseAttValueInternal(xmlParserCtxtPtr ctxt, int *len, int *alloc,
 8887                          int normalize)
 8888 {
 8889     xmlChar limit = 0;
 8890     const xmlChar *in = NULL, *start, *end, *last;
 8891     xmlChar *ret = NULL;
 8892     int line, col;
 8893 
 8894     GROW;
 8895     in = (xmlChar *) CUR_PTR;
 8896     line = ctxt-&gt;input-&gt;line;
 8897     col = ctxt-&gt;input-&gt;col;
 8898     if (*in != &#39;&quot;&#39; &amp;&amp; *in != &#39;\&#39;&#39;) {
 8899         xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
 8900         return (NULL);
 8901     }
 8902     ctxt-&gt;instate = XML_PARSER_ATTRIBUTE_VALUE;
 8903 
 8904     /*
 8905      * try to handle in this routine the most common case where no
 8906      * allocation of a new string is required and where content is
 8907      * pure ASCII.
 8908      */
 8909     limit = *in++;
 8910     col++;
 8911     end = ctxt-&gt;input-&gt;end;
 8912     start = in;
 8913     if (in &gt;= end) {
<span class="line-modified"> 8914         GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)</span>







 8915     }
 8916     if (normalize) {
 8917         /*
 8918      * Skip any leading spaces
 8919      */
 8920     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp;
 8921            ((*in == 0x20) || (*in == 0x9) ||
 8922             (*in == 0xA) || (*in == 0xD))) {
 8923         if (*in == 0xA) {
 8924             line++; col = 1;
 8925         } else {
 8926             col++;
 8927         }
 8928         in++;
 8929         start = in;
 8930         if (in &gt;= end) {
<span class="line-modified"> 8931                 GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)</span>









 8932                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8933                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8934                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8935                                    &quot;AttValue length too long\n&quot;);
 8936                     return(NULL);
 8937                 }
 8938         }
 8939     }
 8940     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp; (*in &gt;= 0x20) &amp;&amp;
 8941            (*in &lt;= 0x7f) &amp;&amp; (*in != &#39;&amp;&#39;) &amp;&amp; (*in != &#39;&lt;&#39;)) {
 8942         col++;
 8943         if ((*in++ == 0x20) &amp;&amp; (*in == 0x20)) break;
 8944         if (in &gt;= end) {
<span class="line-modified"> 8945                 GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)</span>









 8946                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8947                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8948                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8949                                    &quot;AttValue length too long\n&quot;);
 8950                     return(NULL);
 8951                 }
 8952         }
 8953     }
 8954     last = in;
 8955     /*
 8956      * skip the trailing blanks
 8957      */
 8958     while ((last[-1] == 0x20) &amp;&amp; (last &gt; start)) last--;
 8959     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp;
 8960            ((*in == 0x20) || (*in == 0x9) ||
 8961             (*in == 0xA) || (*in == 0xD))) {
 8962         if (*in == 0xA) {
 8963             line++, col = 1;
 8964         } else {
 8965             col++;
 8966         }
 8967         in++;
 8968         if (in &gt;= end) {
 8969         const xmlChar *oldbase = ctxt-&gt;input-&gt;base;
 8970         GROW;
 8971                 if (ctxt-&gt;instate == XML_PARSER_EOF)
 8972                     return(NULL);
 8973         if (oldbase != ctxt-&gt;input-&gt;base) {
<span class="line-modified"> 8974             ptrdiff_t delta = ctxt-&gt;input-&gt;base - oldbase;</span>
 8975             start = start + delta;
 8976             in = in + delta;
 8977             last = last + delta;
 8978         }
 8979         end = ctxt-&gt;input-&gt;end;
 8980                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8981                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8982                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8983                                    &quot;AttValue length too long\n&quot;);
 8984                     return(NULL);
 8985                 }
 8986         }
 8987     }
 8988         if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 8989             ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 8990             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 8991                            &quot;AttValue length too long\n&quot;);
 8992             return(NULL);
 8993         }
 8994     if (*in != limit) goto need_complex;
 8995     } else {
 8996     while ((in &lt; end) &amp;&amp; (*in != limit) &amp;&amp; (*in &gt;= 0x20) &amp;&amp;
 8997            (*in &lt;= 0x7f) &amp;&amp; (*in != &#39;&amp;&#39;) &amp;&amp; (*in != &#39;&lt;&#39;)) {
 8998         in++;
 8999         col++;
 9000         if (in &gt;= end) {
<span class="line-modified"> 9001                 GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)</span>









 9002                 if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 9003                     ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 9004                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9005                                    &quot;AttValue length too long\n&quot;);
 9006                     return(NULL);
 9007                 }
 9008         }
 9009     }
 9010     last = in;
 9011         if (((in - start) &gt; XML_MAX_TEXT_LENGTH) &amp;&amp;
 9012             ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 9013             xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9014                            &quot;AttValue length too long\n&quot;);
 9015             return(NULL);
 9016         }
 9017     if (*in != limit) goto need_complex;
 9018     }
 9019     in++;
 9020     col++;
 9021     if (len != NULL) {
</pre>
<hr />
<pre>
 9075     if (ctxt-&gt;attsSpecial != NULL) {
 9076         int type;
 9077 
 9078         type = (int) (ptrdiff_t) xmlHashQLookup2(ctxt-&gt;attsSpecial,
 9079                                                  pref, elem, *prefix, name);
 9080         if (type != 0)
 9081             normalize = 1;
 9082     }
 9083 
 9084     /*
 9085      * read the value
 9086      */
 9087     SKIP_BLANKS;
 9088     if (RAW == &#39;=&#39;) {
 9089         NEXT;
 9090         SKIP_BLANKS;
 9091         val = xmlParseAttValueInternal(ctxt, len, alloc, normalize);
 9092     if (normalize) {
 9093         /*
 9094          * Sometimes a second normalisation pass for spaces is needed
<span class="line-modified"> 9095          * but that only happens if charrefs or entities references</span>
 9096          * have been used in the attribute value, i.e. the attribute
 9097          * value have been extracted in an allocated string already.
 9098          */
 9099         if (*alloc) {
 9100             const xmlChar *val2;
 9101 
 9102             val2 = xmlAttrNormalizeSpace2(ctxt, val, len);
 9103         if ((val2 != NULL) &amp;&amp; (val2 != val)) {
 9104             xmlFree(val);
 9105             val = (xmlChar *) val2;
 9106         }
 9107         }
 9108     }
 9109         ctxt-&gt;instate = XML_PARSER_CONTENT;
 9110     } else {
 9111         xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,
 9112                           &quot;Specification mandates value for attribute %s\n&quot;,
 9113                           name);
 9114         return (NULL);
 9115     }
</pre>
<hr />
<pre>
 9238        ((RAW != &#39;/&#39;) || (NXT(1) != &#39;&gt;&#39;)) &amp;&amp;
 9239        (IS_BYTE_CHAR(RAW))) &amp;&amp; (ctxt-&gt;instate != XML_PARSER_EOF)) {
 9240     const xmlChar *q = CUR_PTR;
 9241     unsigned int cons = ctxt-&gt;input-&gt;consumed;
 9242     int len = -1, alloc = 0;
 9243 
 9244     attname = xmlParseAttribute2(ctxt, prefix, localname,
 9245                                  &amp;aprefix, &amp;attvalue, &amp;len, &amp;alloc);
 9246         if ((attname == NULL) || (attvalue == NULL))
 9247             goto next_attr;
 9248     if (len &lt; 0) len = xmlStrlen(attvalue);
 9249 
 9250         if ((attname == ctxt-&gt;str_xmlns) &amp;&amp; (aprefix == NULL)) {
 9251             const xmlChar *URL = xmlDictLookup(ctxt-&gt;dict, attvalue, len);
 9252             xmlURIPtr uri;
 9253 
 9254             if (URL == NULL) {
 9255                 xmlErrMemory(ctxt, &quot;dictionary allocation failure&quot;);
 9256                 if ((attvalue != NULL) &amp;&amp; (alloc != 0))
 9257                     xmlFree(attvalue);
<span class="line-modified"> 9258                 localname = NULL;</span>
<span class="line-added"> 9259                 goto done;</span>
 9260             }
 9261             if (*URL != 0) {
 9262                 uri = xmlParseURI((const char *) URL);
 9263                 if (uri == NULL) {
 9264                     xmlNsErr(ctxt, XML_WAR_NS_URI,
 9265                              &quot;xmlns: &#39;%s&#39; is not a valid URI\n&quot;,
 9266                                        URL, NULL, NULL);
 9267                 } else {
 9268                     if (uri-&gt;scheme == NULL) {
 9269                         xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
 9270                                   &quot;xmlns: URI %s is not absolute\n&quot;,
 9271                                   URL, NULL, NULL);
 9272                     }
 9273                     xmlFreeURI(uri);
 9274                 }
 9275                 if (URL == ctxt-&gt;str_xml_ns) {
 9276                     if (attname != ctxt-&gt;str_xml) {
 9277                         xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9278                      &quot;xml namespace URI cannot be the default namespace\n&quot;,
 9279                                  NULL, NULL, NULL);
</pre>
<hr />
<pre>
 9489                 if (j &lt;= nbNs) continue;
 9490 
 9491             nsname = xmlGetNamespace(ctxt, attname);
 9492             if (nsname != defaults-&gt;values[2]) {
 9493             if (nsPush(ctxt, attname,
 9494                        defaults-&gt;values[5 * i + 2]) &gt; 0)
 9495                 nbNs++;
 9496             }
 9497         } else {
 9498             /*
 9499              * check that it&#39;s not a defined attribute
 9500              */
 9501             for (j = 0;j &lt; nbatts;j+=5) {
 9502             if ((attname == atts[j]) &amp;&amp; (aprefix == atts[j+1]))
 9503                 break;
 9504             }
 9505             if (j &lt; nbatts) continue;
 9506 
 9507             if ((atts == NULL) || (nbatts + 5 &gt; maxatts)) {
 9508             if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) &lt; 0) {
<span class="line-modified"> 9509                             localname = NULL;</span>
<span class="line-added"> 9510                             goto done;</span>
 9511             }
 9512             maxatts = ctxt-&gt;maxatts;
 9513             atts = ctxt-&gt;atts;
 9514             }
 9515             atts[nbatts++] = attname;
 9516             atts[nbatts++] = aprefix;
 9517             if (aprefix == NULL)
 9518             atts[nbatts++] = NULL;
 9519             else
 9520                 atts[nbatts++] = xmlGetNamespace(ctxt, aprefix);
 9521             atts[nbatts++] = defaults-&gt;values[5 * i + 2];
 9522             atts[nbatts++] = defaults-&gt;values[5 * i + 3];
 9523             if ((ctxt-&gt;standalone == 1) &amp;&amp;
 9524                 (defaults-&gt;values[5 * i + 4] != NULL)) {
 9525             xmlValidityError(ctxt, XML_DTD_STANDALONE_DEFAULTED,
 9526       &quot;standalone: attribute %s on %s defaulted from external subset\n&quot;,
 9527                                      attname, localname);
 9528             }
 9529             nbdef++;
 9530         }
</pre>
<hr />
<pre>
 9800     if ((ctxt-&gt;sax != NULL) &amp;&amp; (!ctxt-&gt;disableSAX)) {
 9801     if (ctxt-&gt;sax-&gt;cdataBlock != NULL)
 9802         ctxt-&gt;sax-&gt;cdataBlock(ctxt-&gt;userData, buf, len);
 9803     else if (ctxt-&gt;sax-&gt;characters != NULL)
 9804         ctxt-&gt;sax-&gt;characters(ctxt-&gt;userData, buf, len);
 9805     }
 9806     xmlFree(buf);
 9807 }
 9808 
 9809 /**
 9810  * xmlParseContent:
 9811  * @ctxt:  an XML parser context
 9812  *
 9813  * Parse a content:
 9814  *
 9815  * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
 9816  */
 9817 
 9818 void
 9819 xmlParseContent(xmlParserCtxtPtr ctxt) {
<span class="line-added"> 9820     int nameNr = ctxt-&gt;nameNr;</span>
<span class="line-added"> 9821 </span>
 9822     GROW;
 9823     while ((RAW != 0) &amp;&amp;

 9824        (ctxt-&gt;instate != XML_PARSER_EOF)) {
 9825     const xmlChar *test = CUR_PTR;
 9826     unsigned int cons = ctxt-&gt;input-&gt;consumed;
 9827     const xmlChar *cur = ctxt-&gt;input-&gt;cur;
 9828 
 9829     /*
 9830      * First case : a Processing Instruction.
 9831      */
 9832     if ((*cur == &#39;&lt;&#39;) &amp;&amp; (cur[1] == &#39;?&#39;)) {
 9833         xmlParsePI(ctxt);
 9834     }
 9835 
 9836     /*
 9837      * Second case : a CDSection
 9838      */
 9839     /* 2.6.0 test was *cur not RAW */
 9840     else if (CMP9(CUR_PTR, &#39;&lt;&#39;, &#39;!&#39;, &#39;[&#39;, &#39;C&#39;, &#39;D&#39;, &#39;A&#39;, &#39;T&#39;, &#39;A&#39;, &#39;[&#39;)) {
 9841         xmlParseCDSect(ctxt);
 9842     }
 9843 
 9844     /*
 9845      * Third case :  a comment
 9846      */
 9847     else if ((*cur == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;!&#39;) &amp;&amp;
 9848          (NXT(2) == &#39;-&#39;) &amp;&amp; (NXT(3) == &#39;-&#39;)) {
 9849         xmlParseComment(ctxt);
 9850         ctxt-&gt;instate = XML_PARSER_CONTENT;
 9851     }
 9852 
 9853     /*
 9854      * Fourth case :  a sub-element.
 9855      */
 9856     else if (*cur == &#39;&lt;&#39;) {
<span class="line-modified"> 9857             if (NXT(1) == &#39;/&#39;) {</span>
<span class="line-added"> 9858                 if (ctxt-&gt;nameNr &lt;= nameNr)</span>
<span class="line-added"> 9859                     break;</span>
<span class="line-added"> 9860             xmlParseElementEnd(ctxt);</span>
<span class="line-added"> 9861             } else {</span>
<span class="line-added"> 9862             xmlParseElementStart(ctxt);</span>
<span class="line-added"> 9863             }</span>
 9864     }
 9865 
 9866     /*
 9867      * Fifth case : a reference. If if has not been resolved,
 9868      *    parsing returns it&#39;s Name, create the node
 9869      */
 9870 
 9871     else if (*cur == &#39;&amp;&#39;) {
 9872         xmlParseReference(ctxt);
 9873     }
 9874 
 9875     /*
 9876      * Last case, text. Note that References are handled directly.
 9877      */
 9878     else {
 9879         xmlParseCharData(ctxt, 0);
 9880     }
 9881 
 9882     GROW;
 9883     SHRINK;
 9884 
 9885     if ((cons == ctxt-&gt;input-&gt;consumed) &amp;&amp; (test == CUR_PTR)) {
 9886         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 9887                     &quot;detected an error in element content\n&quot;);
 9888         xmlHaltParser(ctxt);
 9889             break;
 9890     }
 9891     }
 9892 }
 9893 
 9894 /**
 9895  * xmlParseElement:
 9896  * @ctxt:  an XML parser context
 9897  *
<span class="line-modified"> 9898  * parse an XML element</span>
 9899  *
 9900  * [39] element ::= EmptyElemTag | STag content ETag
 9901  *
 9902  * [ WFC: Element Type Match ]
 9903  * The Name in an element&#39;s end-tag must match the element type in the
 9904  * start-tag.
 9905  *
 9906  */
 9907 
 9908 void
 9909 xmlParseElement(xmlParserCtxtPtr ctxt) {
<span class="line-added"> 9910     if (xmlParseElementStart(ctxt) != 0)</span>
<span class="line-added"> 9911         return;</span>
<span class="line-added"> 9912     xmlParseContent(ctxt);</span>
<span class="line-added"> 9913     if (ctxt-&gt;instate == XML_PARSER_EOF)</span>
<span class="line-added"> 9914     return;</span>
<span class="line-added"> 9915     xmlParseElementEnd(ctxt);</span>
<span class="line-added"> 9916 }</span>
<span class="line-added"> 9917 </span>
<span class="line-added"> 9918 /**</span>
<span class="line-added"> 9919  * xmlParseElementStart:</span>
<span class="line-added"> 9920  * @ctxt:  an XML parser context</span>
<span class="line-added"> 9921  *</span>
<span class="line-added"> 9922  * Parse the start of an XML element. Returns -1 in case of error, 0 if an</span>
<span class="line-added"> 9923  * opening tag was parsed, 1 if an empty element was parsed.</span>
<span class="line-added"> 9924  */</span>
<span class="line-added"> 9925 static int</span>
<span class="line-added"> 9926 xmlParseElementStart(xmlParserCtxtPtr ctxt) {</span>
 9927     const xmlChar *name;
 9928     const xmlChar *prefix = NULL;
 9929     const xmlChar *URI = NULL;
 9930     xmlParserNodeInfo node_info;
 9931     int line, tlen = 0;
 9932     xmlNodePtr ret;
 9933     int nsNr = ctxt-&gt;nsNr;
 9934 
 9935     if (((unsigned int) ctxt-&gt;nameNr &gt; xmlParserMaxDepth) &amp;&amp;
 9936         ((ctxt-&gt;options &amp; XML_PARSE_HUGE) == 0)) {
 9937     xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
 9938          &quot;Excessive depth in document: %d use XML_PARSE_HUGE option\n&quot;,
 9939               xmlParserMaxDepth);
 9940     xmlHaltParser(ctxt);
<span class="line-modified"> 9941     return(-1);</span>
 9942     }
 9943 
 9944     /* Capture start position */
 9945     if (ctxt-&gt;record_info) {
 9946         node_info.begin_pos = ctxt-&gt;input-&gt;consumed +
 9947                           (CUR_PTR - ctxt-&gt;input-&gt;base);
 9948     node_info.begin_line = ctxt-&gt;input-&gt;line;
 9949     }
 9950 
 9951     if (ctxt-&gt;spaceNr == 0)
 9952     spacePush(ctxt, -1);
 9953     else if (*ctxt-&gt;space == -2)
 9954     spacePush(ctxt, -1);
 9955     else
 9956     spacePush(ctxt, *ctxt-&gt;space);
 9957 
 9958     line = ctxt-&gt;input-&gt;line;
 9959 #ifdef LIBXML_SAX1_ENABLED
 9960     if (ctxt-&gt;sax2)
 9961 #endif /* LIBXML_SAX1_ENABLED */
 9962         name = xmlParseStartTag2(ctxt, &amp;prefix, &amp;URI, &amp;tlen);
 9963 #ifdef LIBXML_SAX1_ENABLED
 9964     else
 9965     name = xmlParseStartTag(ctxt);
 9966 #endif /* LIBXML_SAX1_ENABLED */
 9967     if (ctxt-&gt;instate == XML_PARSER_EOF)
<span class="line-modified"> 9968     return(-1);</span>
 9969     if (name == NULL) {
 9970     spacePop(ctxt);
<span class="line-modified"> 9971         return(-1);</span>
 9972     }
<span class="line-added"> 9973     if (ctxt-&gt;sax2)</span>
<span class="line-added"> 9974         nameNsPush(ctxt, name, prefix, URI, ctxt-&gt;nsNr - nsNr);</span>
<span class="line-added"> 9975 #ifdef LIBXML_SAX1_ENABLED</span>
<span class="line-added"> 9976     else</span>
 9977     namePush(ctxt, name);
<span class="line-added"> 9978 #endif /* LIBXML_SAX1_ENABLED */</span>
 9979     ret = ctxt-&gt;node;
 9980 
 9981 #ifdef LIBXML_VALID_ENABLED
 9982     /*
 9983      * [ VC: Root Element Type ]
 9984      * The Name in the document type declaration must match the element
 9985      * type of the root element.
 9986      */
 9987     if (ctxt-&gt;validate &amp;&amp; ctxt-&gt;wellFormed &amp;&amp; ctxt-&gt;myDoc &amp;&amp;
 9988         ctxt-&gt;node &amp;&amp; (ctxt-&gt;node == ctxt-&gt;myDoc-&gt;children))
 9989         ctxt-&gt;valid &amp;= xmlValidateRoot(&amp;ctxt-&gt;vctxt, ctxt-&gt;myDoc);
 9990 #endif /* LIBXML_VALID_ENABLED */
 9991 
 9992     /*
 9993      * Check for an Empty Element.
 9994      */
 9995     if ((RAW == &#39;/&#39;) &amp;&amp; (NXT(1) == &#39;&gt;&#39;)) {
 9996         SKIP(2);
 9997     if (ctxt-&gt;sax2) {
 9998         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElementNs != NULL) &amp;&amp;
 9999         (!ctxt-&gt;disableSAX))
10000         ctxt-&gt;sax-&gt;endElementNs(ctxt-&gt;userData, name, prefix, URI);
10001 #ifdef LIBXML_SAX1_ENABLED
10002     } else {
10003         if ((ctxt-&gt;sax != NULL) &amp;&amp; (ctxt-&gt;sax-&gt;endElement != NULL) &amp;&amp;
10004         (!ctxt-&gt;disableSAX))
10005         ctxt-&gt;sax-&gt;endElement(ctxt-&gt;userData, name);
10006 #endif /* LIBXML_SAX1_ENABLED */
10007     }
10008     namePop(ctxt);
10009     spacePop(ctxt);
10010     if (nsNr != ctxt-&gt;nsNr)
10011         nsPop(ctxt, ctxt-&gt;nsNr - nsNr);
10012     if ( ret != NULL &amp;&amp; ctxt-&gt;record_info ) {
10013        node_info.end_pos = ctxt-&gt;input-&gt;consumed +
10014                   (CUR_PTR - ctxt-&gt;input-&gt;base);
10015        node_info.end_line = ctxt-&gt;input-&gt;line;
10016        node_info.node = ret;
10017        xmlParserAddNodeInfo(ctxt, &amp;node_info);
10018     }
<span class="line-modified">10019     return(1);</span>
10020     }
10021     if (RAW == &#39;&gt;&#39;) {
10022         NEXT1;
10023     } else {
10024         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_GT_REQUIRED,
10025              &quot;Couldn&#39;t find end of Start Tag %s line %d\n&quot;,
10026                         name, line, NULL);
10027 
10028     /*
10029      * end of parsing of this node.
10030      */
10031     nodePop(ctxt);
10032     namePop(ctxt);
10033     spacePop(ctxt);
10034     if (nsNr != ctxt-&gt;nsNr)
10035         nsPop(ctxt, ctxt-&gt;nsNr - nsNr);
10036 
10037     /*
10038      * Capture end position and add node
10039      */
10040     if ( ret != NULL &amp;&amp; ctxt-&gt;record_info ) {
10041        node_info.end_pos = ctxt-&gt;input-&gt;consumed +
10042                   (CUR_PTR - ctxt-&gt;input-&gt;base);
10043        node_info.end_line = ctxt-&gt;input-&gt;line;
10044        node_info.node = ret;
10045        xmlParserAddNodeInfo(ctxt, &amp;node_info);
10046     }
<span class="line-modified">10047     return(-1);</span>
10048     }
10049 
<span class="line-modified">10050     return(0);</span>
<span class="line-modified">10051 }</span>








10052 
<span class="line-modified">10053 /**</span>
<span class="line-modified">10054  * xmlParseElementEnd:</span>
<span class="line-added">10055  * @ctxt:  an XML parser context</span>
<span class="line-added">10056  *</span>
<span class="line-added">10057  * Parse the end of an XML element.</span>
10058      */
<span class="line-modified">10059 static void</span>
<span class="line-modified">10060 xmlParseElementEnd(xmlParserCtxtPtr ctxt) {</span>
<span class="line-modified">10061     xmlParserNodeInfo node_info;</span>
<span class="line-modified">10062     xmlNodePtr ret = ctxt-&gt;node;</span>
<span class="line-modified">10063 </span>
<span class="line-added">10064     if (ctxt-&gt;nameNr &lt;= 0)</span>
10065     return;

10066 
10067     /*
10068      * parse the end of tag: &#39;&lt;/&#39; should be here.
10069      */
10070     if (ctxt-&gt;sax2) {
<span class="line-modified">10071         const xmlChar *prefix = ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 - 3];</span>
<span class="line-added">10072         const xmlChar *URI = ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 - 2];</span>
<span class="line-added">10073         int nsNr = (ptrdiff_t) ctxt-&gt;pushTab[ctxt-&gt;nameNr * 3 - 1];</span>
<span class="line-added">10074     xmlParseEndTag2(ctxt, prefix, URI, 0, nsNr, 0);</span>
10075     namePop(ctxt);
10076     }
10077 #ifdef LIBXML_SAX1_ENABLED
10078       else
<span class="line-modified">10079     xmlParseEndTag1(ctxt, 0);</span>
10080 #endif /* LIBXML_SAX1_ENABLED */
10081 
10082     /*
10083      * Capture end position and add node
10084      */
10085     if ( ret != NULL &amp;&amp; ctxt-&gt;record_info ) {
10086        node_info.end_pos = ctxt-&gt;input-&gt;consumed +
10087                           (CUR_PTR - ctxt-&gt;input-&gt;base);
10088        node_info.end_line = ctxt-&gt;input-&gt;line;
10089        node_info.node = ret;
10090        xmlParserAddNodeInfo(ctxt, &amp;node_info);
10091     }
10092 }
10093 
10094 /**
10095  * xmlParseVersionNum:
10096  * @ctxt:  an XML parser context
10097  *
10098  * parse the XML version value.
10099  *
</pre>
<hr />
<pre>
10301         encoding = xmlParseEncName(ctxt);
10302         if (RAW != &#39;\&#39;&#39;) {
10303         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10304         xmlFree((xmlChar *) encoding);
10305         return(NULL);
10306         } else
10307             NEXT;
10308     } else {
10309         xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10310     }
10311 
10312         /*
10313          * Non standard parsing, allowing the user to ignore encoding
10314          */
10315         if (ctxt-&gt;options &amp; XML_PARSE_IGNORE_ENC) {
10316         xmlFree((xmlChar *) encoding);
10317             return(NULL);
10318     }
10319 
10320     /*
<span class="line-modified">10321      * UTF-16 encoding switch has already taken place at this stage,</span>
10322      * more over the little-endian/big-endian selection is already done
10323      */
10324         if ((encoding != NULL) &amp;&amp;
10325         ((!xmlStrcasecmp(encoding, BAD_CAST &quot;UTF-16&quot;)) ||
10326          (!xmlStrcasecmp(encoding, BAD_CAST &quot;UTF16&quot;)))) {
10327         /*
10328          * If no encoding was passed to the parser, that we are
10329          * using UTF-16 and no decoder is present i.e. the
10330          * document is apparently UTF-8 compatible, then raise an
10331          * encoding mismatch fatal error
10332          */
10333         if ((ctxt-&gt;encoding == NULL) &amp;&amp;
10334             (ctxt-&gt;input-&gt;buf != NULL) &amp;&amp;
10335             (ctxt-&gt;input-&gt;buf-&gt;encoder == NULL)) {
10336         xmlFatalErrMsg(ctxt, XML_ERR_INVALID_ENCODING,
10337           &quot;Document labelled UTF-16 but has UTF-8 content\n&quot;);
10338         }
10339         if (ctxt-&gt;encoding != NULL)
10340         xmlFree((xmlChar *) ctxt-&gt;encoding);
10341         ctxt-&gt;encoding = encoding;
</pre>
<hr />
<pre>
11184 #endif
11185 
11186     if ((ctxt-&gt;input != NULL) &amp;&amp;
11187         (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base &gt; 4096)) {
11188     xmlSHRINK(ctxt);
11189     ctxt-&gt;checkIndex = 0;
11190     }
11191     xmlParseGetLasts(ctxt, &amp;lastlt, &amp;lastgt);
11192 
11193     while (ctxt-&gt;instate != XML_PARSER_EOF) {
11194     if ((ctxt-&gt;errNo != XML_ERR_OK) &amp;&amp; (ctxt-&gt;disableSAX == 1))
11195         return(0);
11196 
11197     if (ctxt-&gt;input == NULL) break;
11198     if (ctxt-&gt;input-&gt;buf == NULL)
11199         avail = ctxt-&gt;input-&gt;length -
11200                 (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11201     else {
11202         /*
11203          * If we are operating on converted input, try to flush
<span class="line-modified">11204          * remaining chars to avoid them stalling in the non-converted</span>
11205          * buffer. But do not do this in document start where
11206          * encoding=&quot;...&quot; may not have been read and we work on a
11207          * guessed encoding.
11208          */
11209         if ((ctxt-&gt;instate != XML_PARSER_START) &amp;&amp;
11210             (ctxt-&gt;input-&gt;buf-&gt;raw != NULL) &amp;&amp;
11211         (xmlBufIsEmpty(ctxt-&gt;input-&gt;buf-&gt;raw) == 0)) {
11212                 size_t base = xmlBufGetInputBase(ctxt-&gt;input-&gt;buf-&gt;buffer,
11213                                                  ctxt-&gt;input);
11214         size_t current = ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base;
11215 
11216         xmlParserInputBufferPush(ctxt-&gt;input-&gt;buf, 0, &quot;&quot;);
11217                 xmlBufSetInputBaseCur(ctxt-&gt;input-&gt;buf-&gt;buffer, ctxt-&gt;input,
11218                                       base, current);
11219         }
11220         avail = xmlBufUse(ctxt-&gt;input-&gt;buf-&gt;buffer) -
11221             (ctxt-&gt;input-&gt;cur - ctxt-&gt;input-&gt;base);
11222     }
11223         if (avail &lt; 1)
11224         goto done;
</pre>
<hr />
<pre>
12376     xmlParserInputPtr inputStream;
12377     xmlParserInputBufferPtr buf;
12378     xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;
12379 
12380     /*
12381      * plug some encoding conversion routines
12382      */
12383     if ((chunk != NULL) &amp;&amp; (size &gt;= 4))
12384     enc = xmlDetectCharEncoding((const xmlChar *) chunk, size);
12385 
12386     buf = xmlAllocParserInputBuffer(enc);
12387     if (buf == NULL) return(NULL);
12388 
12389     ctxt = xmlNewParserCtxt();
12390     if (ctxt == NULL) {
12391         xmlErrMemory(NULL, &quot;creating parser: out of memory\n&quot;);
12392     xmlFreeParserInputBuffer(buf);
12393     return(NULL);
12394     }
12395     ctxt-&gt;dictNames = 1;







12396     if (sax != NULL) {
12397 #ifdef LIBXML_SAX1_ENABLED
12398     if (ctxt-&gt;sax != (xmlSAXHandlerPtr) &amp;xmlDefaultSAXHandler)
12399 #endif /* LIBXML_SAX1_ENABLED */
12400         xmlFree(ctxt-&gt;sax);
12401     ctxt-&gt;sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(xmlSAXHandler));
12402     if (ctxt-&gt;sax == NULL) {
12403         xmlErrMemory(ctxt, NULL);
12404         xmlFreeParserInputBuffer(buf);
12405         xmlFreeParserCtxt(ctxt);
12406         return(NULL);
12407     }
12408     memset(ctxt-&gt;sax, 0, sizeof(xmlSAXHandler));
12409     if (sax-&gt;initialized == XML_SAX2_MAGIC)
12410         memcpy(ctxt-&gt;sax, sax, sizeof(xmlSAXHandler));
12411     else
12412         memcpy(ctxt-&gt;sax, sax, sizeof(xmlSAXHandlerV1));
12413     if (user_data != NULL)
12414         ctxt-&gt;userData = user_data;
12415     }
</pre>
<hr />
<pre>
13911 
13912     /*
13913      * Return the newly created nodeset after unlinking it from
13914      * they pseudo parent.
13915      */
13916     cur = newDoc-&gt;children-&gt;children;
13917     *lst = cur;
13918     while (cur != NULL) {
13919         xmlSetTreeDoc(cur, doc);
13920         cur-&gt;parent = NULL;
13921         cur = cur-&gt;next;
13922     }
13923     newDoc-&gt;children-&gt;children = NULL;
13924     }
13925 
13926     if (sax != NULL)
13927     ctxt-&gt;sax = oldsax;
13928     xmlFreeParserCtxt(ctxt);
13929     newDoc-&gt;intSubset = NULL;
13930     newDoc-&gt;extSubset = NULL;
<span class="line-added">13931     if(doc != NULL)</span>
13932     newDoc-&gt;oldNs = NULL;
13933     xmlFreeDoc(newDoc);
13934 
13935     return(ret);
13936 }
13937 
13938 /**
13939  * xmlSAXParseEntity:
13940  * @sax:  the SAX handler block
13941  * @filename:  the filename
13942  *
13943  * parse an XML external entity out of context and build a tree.
13944  * It use the given SAX function block to handle the parsing callback.
13945  * If sax is NULL, fallback to the default DOM tree building routines.
13946  *
13947  * [78] extParsedEnt ::= TextDecl? content
13948  *
13949  * This correspond to a &quot;Well Balanced&quot; chunk
13950  *
13951  * Returns the resulting document tree
</pre>
<hr />
<pre>
14021     xmlParserCtxtPtr ctxt;
14022     xmlParserInputPtr inputStream;
14023     char *directory = NULL;
14024     xmlChar *uri;
14025 
14026     ctxt = xmlNewParserCtxt();
14027     if (ctxt == NULL) {
14028     return(NULL);
14029     }
14030 
14031     if (pctx != NULL) {
14032         ctxt-&gt;options = pctx-&gt;options;
14033         ctxt-&gt;_private = pctx-&gt;_private;
14034     /*
14035      * this is a subparser of pctx, so the input_id should be
14036      * incremented to distinguish from main entity
14037      */
14038     ctxt-&gt;input_id = pctx-&gt;input_id + 1;
14039     }
14040 
<span class="line-added">14041     /* Don&#39;t read from stdin. */</span>
<span class="line-added">14042     if (xmlStrcmp(URL, BAD_CAST &quot;-&quot;) == 0)</span>
<span class="line-added">14043         URL = BAD_CAST &quot;./-&quot;;</span>
<span class="line-added">14044 </span>
14045     uri = xmlBuildURI(URL, base);
14046 
14047     if (uri == NULL) {
14048     inputStream = xmlLoadExternalEntity((char *)URL, (char *)ID, ctxt);
14049     if (inputStream == NULL) {
14050         xmlFreeParserCtxt(ctxt);
14051         return(NULL);
14052     }
14053 
14054     inputPush(ctxt, inputStream);
14055 
14056     if ((ctxt-&gt;directory == NULL) &amp;&amp; (directory == NULL))
14057         directory = xmlParserGetDirectory((char *)URL);
14058     if ((ctxt-&gt;directory == NULL) &amp;&amp; (directory != NULL))
14059         ctxt-&gt;directory = directory;
14060     } else {
14061     inputStream = xmlLoadExternalEntity((char *)uri, (char *)ID, ctxt);
14062     if (inputStream == NULL) {
14063         xmlFree(uri);
14064         xmlFreeParserCtxt(ctxt);
</pre>
<hr />
<pre>
14957     xmlParserInputBufferPtr buf;
14958     xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;
14959 
14960     if (ctxt == NULL)
14961         return(1);
14962 
14963     if ((encoding == NULL) &amp;&amp; (chunk != NULL) &amp;&amp; (size &gt;= 4))
14964         enc = xmlDetectCharEncoding((const xmlChar *) chunk, size);
14965 
14966     buf = xmlAllocParserInputBuffer(enc);
14967     if (buf == NULL)
14968         return(1);
14969 
14970     if (ctxt == NULL) {
14971         xmlFreeParserInputBuffer(buf);
14972         return(1);
14973     }
14974 
14975     xmlCtxtReset(ctxt);
14976 










14977     if (filename == NULL) {
14978         ctxt-&gt;directory = NULL;
14979     } else {
14980         ctxt-&gt;directory = xmlParserGetDirectory(filename);
14981     }
14982 
14983     inputStream = xmlNewInputStream(ctxt);
14984     if (inputStream == NULL) {
14985         xmlFreeParserInputBuffer(buf);
14986         return(1);
14987     }
14988 
14989     if (filename == NULL)
14990         inputStream-&gt;filename = NULL;
14991     else
14992         inputStream-&gt;filename = (char *)
14993             xmlCanonicPath((const xmlChar *) filename);
14994     inputStream-&gt;buf = buf;
14995     xmlBufResetInput(buf-&gt;buffer, inputStream);
14996 
</pre>
</td>
</tr>
</table>
<center><a href="nanohttp.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="parserInternals.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
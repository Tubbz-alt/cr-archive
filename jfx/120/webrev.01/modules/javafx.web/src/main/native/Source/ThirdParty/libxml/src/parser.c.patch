diff a/modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/parser.c b/modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/parser.c
--- a/modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/parser.c
+++ b/modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/parser.c
@@ -94,10 +94,16 @@
 xmlCreateEntityParserCtxtInternal(const xmlChar *URL, const xmlChar *ID,
                       const xmlChar *base, xmlParserCtxtPtr pctx);
 
 static void xmlHaltParser(xmlParserCtxtPtr ctxt);
 
+static int
+xmlParseElementStart(xmlParserCtxtPtr ctxt);
+
+static void
+xmlParseElementEnd(xmlParserCtxtPtr ctxt);
+
 /************************************************************************
  *                                  *
  *  Arbitrary limits set in the parser. See XML_PARSE_HUGE      *
  *                                  *
  ************************************************************************/
@@ -106,11 +112,11 @@
 #define XML_PARSER_LOT_ENTITY 5000
 
 /*
  * XML_PARSER_NON_LINEAR is the threshold where the ratio of parsed entity
  *    replacement over the size in byte of the input indicates that you have
- *    and eponential behaviour. A value of 10 correspond to at least 3 entity
+ *    and exponential behaviour. A value of 10 correspond to at least 3 entity
  *    replacement per byte of input.
  */
 #define XML_PARSER_NON_LINEAR 10
 
 /*
@@ -138,11 +144,11 @@
      * entities problems
      */
     if ((ent != NULL) && (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&
     (ent->content != NULL) && (ent->checked == 0) &&
     (ctxt->errNo != XML_ERR_ENTITY_LOOP)) {
-    unsigned long oldnbent = ctxt->nbentities;
+    unsigned long oldnbent = ctxt->nbentities, diff;
     xmlChar *rep;
 
     ent->checked = 1;
 
         ++ctxt->depth;
@@ -151,11 +157,14 @@
         --ctxt->depth;
     if ((rep == NULL) || (ctxt->errNo == XML_ERR_ENTITY_LOOP)) {
         ent->content[0] = 0;
     }
 
-    ent->checked = (ctxt->nbentities - oldnbent + 1) * 2;
+        diff = ctxt->nbentities - oldnbent + 1;
+        if (diff > INT_MAX / 2)
+            diff = INT_MAX / 2;
+    ent->checked = diff * 2;
     if (rep != NULL) {
         if (xmlStrchr(rep, '<'))
         ent->checked |= 1;
         xmlFree(rep);
         rep = NULL;
@@ -1058,11 +1067,11 @@
 
 /**
  * xmlDetectSAX2:
  * @ctxt:  an XML parser context
  *
- * Do the SAX2 detection and specific intialization
+ * Do the SAX2 detection and specific initialization
  */
 static void
 xmlDetectSAX2(xmlParserCtxtPtr ctxt) {
     if (ctxt == NULL) return;
 #ifdef LIBXML_SAX1_ENABLED
@@ -1390,11 +1399,11 @@
  * [35] ISO639Code ::= ([a-z] | [A-Z]) ([a-z] | [A-Z])
  * [36] IanaCode ::= ('i' | 'I') '-' ([a-z] | [A-Z])+
  * [37] UserCode ::= ('x' | 'X') '-' ([a-z] | [A-Z])+
  * [38] Subcode ::= ([a-z] | [A-Z])+
  *
- * The current REC reference the sucessors of RFC 1766, currently 5646
+ * The current REC reference the successors of RFC 1766, currently 5646
  *
  * http://www.rfc-editor.org/rfc/rfc5646.txt
  * langtag       = language
  *                 ["-" script]
  *                 ["-" region]
@@ -1817,11 +1826,10 @@
     ret = ctxt->nodeTab[ctxt->nodeNr];
     ctxt->nodeTab[ctxt->nodeNr] = NULL;
     return (ret);
 }
 
-#ifdef LIBXML_PUSH_ENABLED
 /**
  * nameNsPush:
  * @ctxt:  an XML parser context
  * @value:  the element name
  * @prefix:  the element prefix
@@ -1853,10 +1861,15 @@
         if (tmp2 == NULL) {
         ctxt->nameMax /= 2;
         goto mem_error;
         }
     ctxt->pushTab = tmp2;
+    } else if (ctxt->pushTab == NULL) {
+        ctxt->pushTab = (void **) xmlMalloc(ctxt->nameMax * 3 *
+                                            sizeof(ctxt->pushTab[0]));
+        if (ctxt->pushTab == NULL)
+            goto mem_error;
     }
     ctxt->nameTab[ctxt->nameNr] = value;
     ctxt->name = value;
     ctxt->pushTab[ctxt->nameNr * 3] = (void *) prefix;
     ctxt->pushTab[ctxt->nameNr * 3 + 1] = (void *) URI;
@@ -1864,10 +1877,11 @@
     return (ctxt->nameNr++);
 mem_error:
     xmlErrMemory(ctxt, NULL);
     return (-1);
 }
+#ifdef LIBXML_PUSH_ENABLED
 /**
  * nameNsPop:
  * @ctxt: an XML parser context
  *
  * Pops the top element/prefix/URI name from the name stack
@@ -2073,15 +2087,15 @@
 #define GROW if ((ctxt->progressive == 0) &&                \
          (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK))   \
     xmlGROW (ctxt);
 
 static void xmlGROW (xmlParserCtxtPtr ctxt) {
-    unsigned long curEnd = ctxt->input->end - ctxt->input->cur;
-    unsigned long curBase = ctxt->input->cur - ctxt->input->base;
+    ptrdiff_t curEnd = ctxt->input->end - ctxt->input->cur;
+    ptrdiff_t curBase = ctxt->input->cur - ctxt->input->base;
 
-    if (((curEnd > (unsigned long) XML_MAX_LOOKUP_LIMIT) ||
-         (curBase > (unsigned long) XML_MAX_LOOKUP_LIMIT)) &&
+    if (((curEnd > XML_MAX_LOOKUP_LIMIT) ||
+         (curBase > XML_MAX_LOOKUP_LIMIT)) &&
          ((ctxt->input->buf) &&
           (ctxt->input->buf->readcallback != xmlInputReadCallbackNop)) &&
         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, "Huge input lookup");
         xmlHaltParser(ctxt);
@@ -2279,13 +2293,12 @@
  *
  * Returns the value parsed (as an int), 0 in case of error
  */
 int
 xmlParseCharRef(xmlParserCtxtPtr ctxt) {
-    unsigned int val = 0;
+    int val = 0;
     int count = 0;
-    unsigned int outofrange = 0;
 
     /*
      * Using RAW/CUR/NEXT is okay since we are working on ASCII range here
      */
     if ((RAW == '&') && (NXT(1) == '#') &&
@@ -2308,12 +2321,12 @@
         else {
         xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);
         val = 0;
         break;
         }
-        if (val > 0x10FFFF)
-            outofrange = val;
+        if (val > 0x110000)
+            val = 0x110000;
 
         NEXT;
         count++;
     }
     if (RAW == ';') {
@@ -2337,12 +2350,12 @@
         else {
         xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);
         val = 0;
         break;
         }
-        if (val > 0x10FFFF)
-            outofrange = val;
+        if (val > 0x110000)
+            val = 0x110000;
 
         NEXT;
         count++;
     }
     if (RAW == ';') {
@@ -2358,11 +2371,15 @@
     /*
      * [ WFC: Legal Character ]
      * Characters referred to using character references must match the
      * production for Char.
      */
-    if ((IS_CHAR(val) && (outofrange == 0))) {
+    if (val >= 0x110000) {
+        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
+                "xmlParseCharRef: character reference out of bounds\n",
+            val);
+    } else if (IS_CHAR(val)) {
         return(val);
     } else {
         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
                           "xmlParseCharRef: invalid xmlChar value %d\n",
                       val);
@@ -2390,12 +2407,11 @@
  */
 static int
 xmlParseStringCharRef(xmlParserCtxtPtr ctxt, const xmlChar **str) {
     const xmlChar *ptr;
     xmlChar cur;
-    unsigned int val = 0;
-    unsigned int outofrange = 0;
+    int val = 0;
 
     if ((str == NULL) || (*str == NULL)) return(0);
     ptr = *str;
     cur = *ptr;
     if ((cur == '&') && (ptr[1] == '#') && (ptr[2] == 'x')) {
@@ -2411,12 +2427,12 @@
         else {
         xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);
         val = 0;
         break;
         }
-        if (val > 0x10FFFF)
-            outofrange = val;
+        if (val > 0x110000)
+            val = 0x110000;
 
         ptr++;
         cur = *ptr;
     }
     if (cur == ';')
@@ -2430,12 +2446,12 @@
         else {
         xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);
         val = 0;
         break;
         }
-        if (val > 0x10FFFF)
-            outofrange = val;
+        if (val > 0x110000)
+            val = 0x110000;
 
         ptr++;
         cur = *ptr;
     }
     if (cur == ';')
@@ -2449,11 +2465,15 @@
     /*
      * [ WFC: Legal Character ]
      * Characters referred to using character references must match the
      * production for Char.
      */
-    if ((IS_CHAR(val) && (outofrange == 0))) {
+    if (val >= 0x110000) {
+        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
+                "xmlParseStringCharRef: character reference out of bounds\n",
+                val);
+    } else if (IS_CHAR(val)) {
         return(val);
     } else {
         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
               "xmlParseStringCharRef: invalid xmlChar value %d\n",
               val);
@@ -2624,11 +2644,12 @@
     if (str < last)
     c = CUR_SCHAR(str, l);
     else
         c = 0;
     while ((c != 0) && (c != end) && /* non input consuming loop */
-       (c != end2) && (c != end3)) {
+           (c != end2) && (c != end3) &&
+           (ctxt->instate != XML_PARSER_EOF)) {
 
     if (c == 0) break;
         if ((c == '&') && (str[1] == '#')) {
         int val = xmlParseStringCharRef(ctxt, &str);
         if (val == 0)
@@ -2700,11 +2721,11 @@
         if (ent != NULL) {
                 if (ent->content == NULL) {
             /*
              * Note: external parsed entities will not be loaded,
              * it is not required for a non-validating parser to
-             * complete external PEreferences coming from the
+             * complete external PEReferences coming from the
              * internal subset
              */
             if (((ctxt->options & XML_PARSE_NOENT) != 0) ||
             ((ctxt->options & XML_PARSE_DTDVALID) != 0) ||
             (ctxt->validate != 0)) {
@@ -3364,11 +3385,11 @@
     if (c == 0) {
         count = 0;
         /*
          * when shrinking to extend the buffer we really need to preserve
          * the part of the name we already parsed. Hence rolling back
-         * by current lenght.
+         * by current length.
          */
         ctxt->input->cur -= l;
         GROW;
             if (ctxt->instate == XML_PARSER_EOF)
                 return(NULL);
@@ -3833,11 +3854,11 @@
 
 /**
  * xmlParseAttValueComplex:
  * @ctxt:  an XML parser context
  * @len:   the resulting attribute len
- * @normalize:  wether to apply the inner normalization
+ * @normalize:  whether to apply the inner normalization
  *
  * parse a value for an attribute, this is the fallback function
  * of xmlParseAttValue() when the attribute parsing requires handling
  * of non-ASCII characters, or normalization compaction.
  *
@@ -3982,18 +4003,21 @@
              * This may look absurd but is needed to detect
              * entities problems
              */
             if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&
             (ent->content != NULL) && (ent->checked == 0)) {
-            unsigned long oldnbent = ctxt->nbentities;
+            unsigned long oldnbent = ctxt->nbentities, diff;
 
             ++ctxt->depth;
             rep = xmlStringDecodeEntities(ctxt, ent->content,
                           XML_SUBSTITUTE_REF, 0, 0, 0);
             --ctxt->depth;
 
-            ent->checked = (ctxt->nbentities - oldnbent + 1) * 2;
+                        diff = ctxt->nbentities - oldnbent + 1;
+                        if (diff > INT_MAX / 2)
+                            diff = INT_MAX / 2;
+                        ent->checked = diff * 2;
             if (rep != NULL) {
                 if (xmlStrchr(rep, '<'))
                     ent->checked |= 1;
                 xmlFree(rep);
                 rep = NULL;
@@ -4057,11 +4081,11 @@
     } else
     NEXT;
 
     /*
      * There we potentially risk an overflow, don't allow attribute value of
-     * length more than INT_MAX it is a very reasonnable assumption !
+     * length more than INT_MAX it is a very reasonable assumption !
      */
     if (len >= INT_MAX) {
         xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
                        "AttValue length too long\n");
         goto mem_error;
@@ -4662,11 +4686,11 @@
 
 /**
  * xmlParseCommentComplex:
  * @ctxt:  an XML parser context
  * @buf:  the already parsed part of the buffer
- * @len:  number of bytes filles in the buffer
+ * @len:  number of bytes in the buffer
  * @size:  allocated size of the buffer
  *
  * Skip an XML (SGML) comment <!-- .... -->
  *  The spec says that "For compatibility, the string "--" (double-hyphen)
  *  must not occur within comments. "
@@ -4953,10 +4977,14 @@
                                       "<!--%.50s\n",
                       buf);
         } else
             xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
                               "Double hyphen within comment\n", NULL);
+                if (ctxt->instate == XML_PARSER_EOF) {
+                    xmlFree(buf);
+                    return;
+                }
         in++;
         ctxt->input->col++;
         }
         in++;
         ctxt->input->col++;
@@ -5083,11 +5111,11 @@
  *
  * parse an XML Processing Instruction.
  *
  * [16] PI ::= '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'
  *
- * The processing is transfered to SAX once parsed.
+ * The processing is transferred to SAX once parsed.
  */
 
 void
 xmlParsePI(xmlParserCtxtPtr ctxt) {
     xmlChar *buf = NULL;
@@ -5499,11 +5527,11 @@
             ctxt->sax->entityDecl(ctxt->userData, name,
                     XML_EXTERNAL_GENERAL_PARSED_ENTITY,
                     literal, URI, NULL);
             /*
              * For expat compatibility in SAX mode.
-             * assuming the entity repalcement was asked for
+             * assuming the entity replacement was asked for
              */
             if ((ctxt->replaceEntities != 0) &&
             ((ctxt->myDoc == NULL) ||
             (xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE)))) {
             if (ctxt->myDoc == NULL) {
@@ -6609,153 +6637,147 @@
  * [65] Ignore ::= Char* - (Char* ('<![' | ']]>') Char*)
  */
 
 static void
 xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
+    int *inputIds = NULL;
+    size_t inputIdsSize = 0;
+    size_t depth = 0;
+
+    while (ctxt->instate != XML_PARSER_EOF) {
+        if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
     int id = ctxt->input->id;
 
     SKIP(3);
     SKIP_BLANKS;
+
     if (CMP7(CUR_PTR, 'I', 'N', 'C', 'L', 'U', 'D', 'E')) {
     SKIP(7);
     SKIP_BLANKS;
     if (RAW != '[') {
         xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
         xmlHaltParser(ctxt);
-        return;
-    } else {
+                    goto error;
+                }
         if (ctxt->input->id != id) {
         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
-                           "All markup of the conditional section is not"
-                               " in the same entity\n");
+                                   "All markup of the conditional section is"
+                                   " not in the same entity\n");
         }
         NEXT;
-    }
-    if (xmlParserDebugEntities) {
-        if ((ctxt->input != NULL) && (ctxt->input->filename))
-        xmlGenericError(xmlGenericErrorContext,
-            "%s(%d): ", ctxt->input->filename,
-            ctxt->input->line);
-        xmlGenericError(xmlGenericErrorContext,
-            "Entering INCLUDE Conditional Section\n");
-    }
 
-        SKIP_BLANKS;
-        GROW;
-    while (((RAW != 0) && ((RAW != ']') || (NXT(1) != ']') ||
-            (NXT(2) != '>'))) && (ctxt->instate != XML_PARSER_EOF)) {
-        const xmlChar *check = CUR_PTR;
-        unsigned int cons = ctxt->input->consumed;
-
-        if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
-        xmlParseConditionalSections(ctxt);
-        } else
-        xmlParseMarkupDecl(ctxt);
-
-            SKIP_BLANKS;
-            GROW;
+                if (inputIdsSize <= depth) {
+                    int *tmp;
 
-        if ((CUR_PTR == check) && (cons == ctxt->input->consumed)) {
-        xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
-        xmlHaltParser(ctxt);
-        break;
+                    inputIdsSize = (inputIdsSize == 0 ? 4 : inputIdsSize * 2);
+                    tmp = (int *) xmlRealloc(inputIds,
+                            inputIdsSize * sizeof(int));
+                    if (tmp == NULL) {
+                        xmlErrMemory(ctxt, NULL);
+                        goto error;
         }
+                    inputIds = tmp;
     }
-    if (xmlParserDebugEntities) {
-        if ((ctxt->input != NULL) && (ctxt->input->filename))
-        xmlGenericError(xmlGenericErrorContext,
-            "%s(%d): ", ctxt->input->filename,
-            ctxt->input->line);
-        xmlGenericError(xmlGenericErrorContext,
-            "Leaving INCLUDE Conditional Section\n");
-    }
-
+                inputIds[depth] = id;
+                depth++;
     } else if (CMP6(CUR_PTR, 'I', 'G', 'N', 'O', 'R', 'E')) {
     int state;
     xmlParserInputState instate;
-    int depth = 0;
+                size_t ignoreDepth = 0;
 
     SKIP(6);
     SKIP_BLANKS;
     if (RAW != '[') {
         xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
         xmlHaltParser(ctxt);
-        return;
-    } else {
+                    goto error;
+                }
         if (ctxt->input->id != id) {
         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
-                           "All markup of the conditional section is not"
-                               " in the same entity\n");
+                                   "All markup of the conditional section is"
+                                   " not in the same entity\n");
         }
         NEXT;
-    }
-    if (xmlParserDebugEntities) {
-        if ((ctxt->input != NULL) && (ctxt->input->filename))
-        xmlGenericError(xmlGenericErrorContext,
-            "%s(%d): ", ctxt->input->filename,
-            ctxt->input->line);
-        xmlGenericError(xmlGenericErrorContext,
-            "Entering IGNORE Conditional Section\n");
-    }
 
     /*
-     * Parse up to the end of the conditional section
-     * But disable SAX event generating DTD building in the meantime
+                 * Parse up to the end of the conditional section but disable
+                 * SAX event generating DTD building in the meantime
      */
     state = ctxt->disableSAX;
     instate = ctxt->instate;
     if (ctxt->recovery == 0) ctxt->disableSAX = 1;
     ctxt->instate = XML_PARSER_IGNORE;
 
-    while (((depth >= 0) && (RAW != 0)) &&
-               (ctxt->instate != XML_PARSER_EOF)) {
+                while (RAW != 0) {
       if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
-        depth++;
         SKIP(3);
-        continue;
-      }
-      if ((RAW == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {
-        if (--depth >= 0) SKIP(3);
-        continue;
+                        ignoreDepth++;
+                        /* Check for integer overflow */
+                        if (ignoreDepth == 0) {
+                            xmlErrMemory(ctxt, NULL);
+                            goto error;
       }
+                    } else if ((RAW == ']') && (NXT(1) == ']') &&
+                               (NXT(2) == '>')) {
+                        if (ignoreDepth == 0)
+                            break;
+                        SKIP(3);
+                        ignoreDepth--;
+                    } else {
       NEXT;
-      continue;
+                    }
     }
 
     ctxt->disableSAX = state;
     ctxt->instate = instate;
 
-    if (xmlParserDebugEntities) {
-        if ((ctxt->input != NULL) && (ctxt->input->filename))
-        xmlGenericError(xmlGenericErrorContext,
-            "%s(%d): ", ctxt->input->filename,
-            ctxt->input->line);
-        xmlGenericError(xmlGenericErrorContext,
-            "Leaving IGNORE Conditional Section\n");
+        if (RAW == 0) {
+            xmlFatalErr(ctxt, XML_ERR_CONDSEC_NOT_FINISHED, NULL);
+                    goto error;
     }
-
+                if (ctxt->input->id != id) {
+                    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
+                                   "All markup of the conditional section is"
+                                   " not in the same entity\n");
+                }
+                SKIP(3);
     } else {
     xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID_KEYWORD, NULL);
     xmlHaltParser(ctxt);
-    return;
+                goto error;
     }
-
-    if (RAW == 0)
-        SHRINK;
-
-    if (RAW == 0) {
-    xmlFatalErr(ctxt, XML_ERR_CONDSEC_NOT_FINISHED, NULL);
-    } else {
-    if (ctxt->input->id != id) {
+        } else if ((depth > 0) &&
+                   (RAW == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {
+            depth--;
+            if (ctxt->input->id != inputIds[depth]) {
         xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
-                       "All markup of the conditional section is not in"
-                           " the same entity\n");
+                               "All markup of the conditional section is not"
+                               " in the same entity\n");
     }
-    if ((ctxt-> instate != XML_PARSER_EOF) &&
-        ((ctxt->input->cur + 3) <= ctxt->input->end))
         SKIP(3);
+        } else {
+            const xmlChar *check = CUR_PTR;
+            unsigned int cons = ctxt->input->consumed;
+
+            xmlParseMarkupDecl(ctxt);
+
+            if ((CUR_PTR == check) && (cons == ctxt->input->consumed)) {
+                xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
+                xmlHaltParser(ctxt);
+                goto error;
+            }
+    }
+
+        if (depth == 0)
+            break;
+
+        SKIP_BLANKS;
+        GROW;
     }
+
+error:
+    xmlFree(inputIds);
 }
 
 /**
  * xmlParseMarkupDecl:
  * @ctxt:  an XML parser context
@@ -6808,25 +6830,15 @@
     }
     }
 
     /*
      * detect requirement to exit there and act accordingly
-     * and avoid having instate overriden later on
+     * and avoid having instate overridden later on
      */
     if (ctxt->instate == XML_PARSER_EOF)
         return;
 
-    /*
-     * Conditional sections are allowed from entities included
-     * by PE References in the internal subset.
-     */
-    if ((ctxt->external == 0) && (ctxt->inputNr > 1)) {
-        if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
-        xmlParseConditionalSections(ctxt);
-    }
-    }
-
     ctxt->instate = XML_PARSER_DTD;
 }
 
 /**
  * xmlParseTextDecl:
@@ -7007,11 +7019,11 @@
     /*
      * Simple case of a CharRef
      */
     if (NXT(1) == '#') {
     int i = 0;
-    xmlChar out[10];
+    xmlChar out[16];
     int hex = NXT(2);
     int value = xmlParseCharRef(ctxt);
 
     if (value == 0)
         return;
@@ -7084,11 +7096,11 @@
      */
     if (((ent->checked == 0) ||
          ((ent->children == NULL) && (ctxt->options & XML_PARSE_NOENT))) &&
         ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
          (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {
-    unsigned long oldnbent = ctxt->nbentities;
+    unsigned long oldnbent = ctxt->nbentities, diff;
 
     /*
      * This is a bit hackish but this seems the best
      * way to make sure both SAX and DOM entity support
      * behaves okay.
@@ -7125,11 +7137,14 @@
 
     /*
      * Store the number of entities needing parsing for this entity
      * content and do checkings
      */
-    ent->checked = (ctxt->nbentities - oldnbent + 1) * 2;
+        diff = ctxt->nbentities - oldnbent + 1;
+        if (diff > INT_MAX / 2)
+            diff = INT_MAX / 2;
+        ent->checked = diff * 2;
     if ((ent->content != NULL) && (xmlStrchr(ent->content, '<')))
         ent->checked |= 1;
     if (ret == XML_ERR_ENTITY_LOOP) {
         xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
         xmlFreeNodeList(list);
@@ -7673,11 +7688,11 @@
             return(ent);
         }
     }
 
     /*
-     * Increate the number of entity references parsed
+     * Increase the number of entity references parsed
      */
     ctxt->nbentities++;
 
     /*
      * Ask first SAX for entity resolution, otherwise try the
@@ -7849,11 +7864,11 @@
     }
 
     NEXT;
 
     /*
-     * Increate the number of entity references parsed
+     * Increase the number of entity references parsed
      */
     ctxt->nbentities++;
 
     /*
      * Request the entity from SAX
@@ -8115,11 +8130,11 @@
     return(NULL);
     }
     ptr++;
 
     /*
-     * Increate the number of entity references parsed
+     * Increase the number of entity references parsed
      */
     ctxt->nbentities++;
 
     /*
      * Request the entity from SAX
@@ -8283,10 +8298,19 @@
 
         SKIP_BLANKS;
         xmlParseMarkupDecl(ctxt);
         xmlParsePEReference(ctxt);
 
+            /*
+             * Conditional sections are allowed from external entities included
+             * by PE References in the internal subset.
+             */
+            if ((ctxt->inputNr > 1) && (ctxt->input->filename != NULL) &&
+                (RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
+                xmlParseConditionalSections(ctxt);
+            }
+
         if ((CUR_PTR == check) && (cons == ctxt->input->consumed)) {
         xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
          "xmlParseInternalSubset: error detected in Markup declaration\n");
                 if (ctxt->inputNr > baseInputNr)
                     xmlPopInput(ctxt);
@@ -8711,16 +8735,20 @@
     p = l;
     l = xmlParseNCName(ctxt);
     if (l == NULL) {
         xmlChar *tmp;
 
+            if (ctxt->instate == XML_PARSER_EOF)
+                return(NULL);
             xmlNsErr(ctxt, XML_NS_ERR_QNAME,
                  "Failed to parse QName '%s:'\n", p, NULL, NULL);
         l = xmlParseNmtoken(ctxt);
-        if (l == NULL)
+        if (l == NULL) {
+                if (ctxt->instate == XML_PARSER_EOF)
+                    return(NULL);
         tmp = xmlBuildQName(BAD_CAST "", p, NULL, 0);
-        else {
+            } else {
         tmp = xmlBuildQName(l, p, NULL, 0);
         xmlFree((char *)l);
         }
         p = xmlDictLookup(ctxt->dict, tmp, -1);
         if (tmp != NULL) xmlFree(tmp);
@@ -8739,10 +8767,12 @@
         l = xmlDictLookup(ctxt->dict, tmp, -1);
         if (tmp != NULL) xmlFree(tmp);
         *prefix = p;
         return(l);
         }
+            if (ctxt->instate == XML_PARSER_EOF)
+                return(NULL);
         tmp = xmlBuildQName(BAD_CAST "", l, NULL, 0);
         l = xmlDictLookup(ctxt->dict, tmp, -1);
         if (tmp != NULL) xmlFree(tmp);
         *prefix = p;
         return(l);
@@ -8838,10 +8868,22 @@
  *
  * Returns the AttValue parsed or NULL. The value has to be freed by the
  *     caller if it was copied, this can be detected by val[*len] == 0.
  */
 
+#define GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end) \
+    const xmlChar *oldbase = ctxt->input->base;\
+    GROW;\
+    if (ctxt->instate == XML_PARSER_EOF)\
+        return(NULL);\
+    if (oldbase != ctxt->input->base) {\
+        ptrdiff_t delta = ctxt->input->base - oldbase;\
+        start = start + delta;\
+        in = in + delta;\
+    }\
+    end = ctxt->input->end;
+
 static xmlChar *
 xmlParseAttValueInternal(xmlParserCtxtPtr ctxt, int *len, int *alloc,
                          int normalize)
 {
     xmlChar limit = 0;
@@ -8867,18 +8909,11 @@
     limit = *in++;
     col++;
     end = ctxt->input->end;
     start = in;
     if (in >= end) {
-        const xmlChar *oldbase = ctxt->input->base;
-    GROW;
-    if (oldbase != ctxt->input->base) {
-        long delta = ctxt->input->base - oldbase;
-        start = start + delta;
-        in = in + delta;
-    }
-    end = ctxt->input->end;
+        GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
     }
     if (normalize) {
         /*
      * Skip any leading spaces
      */
@@ -8891,20 +8926,11 @@
             col++;
         }
         in++;
         start = in;
         if (in >= end) {
-        const xmlChar *oldbase = ctxt->input->base;
-        GROW;
-                if (ctxt->instate == XML_PARSER_EOF)
-                    return(NULL);
-        if (oldbase != ctxt->input->base) {
-            long delta = ctxt->input->base - oldbase;
-            start = start + delta;
-            in = in + delta;
-        }
-        end = ctxt->input->end;
+                GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
                 if (((in - start) > XML_MAX_TEXT_LENGTH) &&
                     ((ctxt->options & XML_PARSE_HUGE) == 0)) {
                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
                                    "AttValue length too long\n");
                     return(NULL);
@@ -8914,20 +8940,11 @@
     while ((in < end) && (*in != limit) && (*in >= 0x20) &&
            (*in <= 0x7f) && (*in != '&') && (*in != '<')) {
         col++;
         if ((*in++ == 0x20) && (*in == 0x20)) break;
         if (in >= end) {
-        const xmlChar *oldbase = ctxt->input->base;
-        GROW;
-                if (ctxt->instate == XML_PARSER_EOF)
-                    return(NULL);
-        if (oldbase != ctxt->input->base) {
-            long delta = ctxt->input->base - oldbase;
-            start = start + delta;
-            in = in + delta;
-        }
-        end = ctxt->input->end;
+                GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
                 if (((in - start) > XML_MAX_TEXT_LENGTH) &&
                     ((ctxt->options & XML_PARSE_HUGE) == 0)) {
                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
                                    "AttValue length too long\n");
                     return(NULL);
@@ -8952,11 +8969,11 @@
         const xmlChar *oldbase = ctxt->input->base;
         GROW;
                 if (ctxt->instate == XML_PARSER_EOF)
                     return(NULL);
         if (oldbase != ctxt->input->base) {
-            long delta = ctxt->input->base - oldbase;
+            ptrdiff_t delta = ctxt->input->base - oldbase;
             start = start + delta;
             in = in + delta;
             last = last + delta;
         }
         end = ctxt->input->end;
@@ -8979,20 +8996,11 @@
     while ((in < end) && (*in != limit) && (*in >= 0x20) &&
            (*in <= 0x7f) && (*in != '&') && (*in != '<')) {
         in++;
         col++;
         if (in >= end) {
-        const xmlChar *oldbase = ctxt->input->base;
-        GROW;
-                if (ctxt->instate == XML_PARSER_EOF)
-                    return(NULL);
-        if (oldbase != ctxt->input->base) {
-            long delta = ctxt->input->base - oldbase;
-            start = start + delta;
-            in = in + delta;
-        }
-        end = ctxt->input->end;
+                GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
                 if (((in - start) > XML_MAX_TEXT_LENGTH) &&
                     ((ctxt->options & XML_PARSE_HUGE) == 0)) {
                     xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
                                    "AttValue length too long\n");
                     return(NULL);
@@ -9082,11 +9090,11 @@
         SKIP_BLANKS;
         val = xmlParseAttValueInternal(ctxt, len, alloc, normalize);
     if (normalize) {
         /*
          * Sometimes a second normalisation pass for spaces is needed
-         * but that only happens if charrefs or entities refernces
+         * but that only happens if charrefs or entities references
          * have been used in the attribute value, i.e. the attribute
          * value have been extracted in an allocated string already.
          */
         if (*alloc) {
             const xmlChar *val2;
@@ -9245,11 +9253,12 @@
 
             if (URL == NULL) {
                 xmlErrMemory(ctxt, "dictionary allocation failure");
                 if ((attvalue != NULL) && (alloc != 0))
                     xmlFree(attvalue);
-                return(NULL);
+                localname = NULL;
+                goto done;
             }
             if (*URL != 0) {
                 uri = xmlParseURI((const char *) URL);
                 if (uri == NULL) {
                     xmlNsErr(ctxt, XML_WAR_NS_URI,
@@ -9495,11 +9504,12 @@
             }
             if (j < nbatts) continue;
 
             if ((atts == NULL) || (nbatts + 5 > maxatts)) {
             if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {
-                return(NULL);
+                            localname = NULL;
+                            goto done;
             }
             maxatts = ctxt->maxatts;
             atts = ctxt->atts;
             }
             atts[nbatts++] = attname;
@@ -9805,13 +9815,14 @@
  * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
  */
 
 void
 xmlParseContent(xmlParserCtxtPtr ctxt) {
+    int nameNr = ctxt->nameNr;
+
     GROW;
     while ((RAW != 0) &&
-       ((RAW != '<') || (NXT(1) != '/')) &&
        (ctxt->instate != XML_PARSER_EOF)) {
     const xmlChar *test = CUR_PTR;
     unsigned int cons = ctxt->input->consumed;
     const xmlChar *cur = ctxt->input->cur;
 
@@ -9841,11 +9852,17 @@
 
     /*
      * Fourth case :  a sub-element.
      */
     else if (*cur == '<') {
-        xmlParseElement(ctxt);
+            if (NXT(1) == '/') {
+                if (ctxt->nameNr <= nameNr)
+                    break;
+            xmlParseElementEnd(ctxt);
+            } else {
+            xmlParseElementStart(ctxt);
+            }
     }
 
     /*
      * Fifth case : a reference. If if has not been resolved,
      *    parsing returns it's Name, create the node
@@ -9876,11 +9893,11 @@
 
 /**
  * xmlParseElement:
  * @ctxt:  an XML parser context
  *
- * parse an XML element, this is highly recursive
+ * parse an XML element
  *
  * [39] element ::= EmptyElemTag | STag content ETag
  *
  * [ WFC: Element Type Match ]
  * The Name in an element's end-tag must match the element type in the
@@ -9888,10 +9905,27 @@
  *
  */
 
 void
 xmlParseElement(xmlParserCtxtPtr ctxt) {
+    if (xmlParseElementStart(ctxt) != 0)
+        return;
+    xmlParseContent(ctxt);
+    if (ctxt->instate == XML_PARSER_EOF)
+    return;
+    xmlParseElementEnd(ctxt);
+}
+
+/**
+ * xmlParseElementStart:
+ * @ctxt:  an XML parser context
+ *
+ * Parse the start of an XML element. Returns -1 in case of error, 0 if an
+ * opening tag was parsed, 1 if an empty element was parsed.
+ */
+static int
+xmlParseElementStart(xmlParserCtxtPtr ctxt) {
     const xmlChar *name;
     const xmlChar *prefix = NULL;
     const xmlChar *URI = NULL;
     xmlParserNodeInfo node_info;
     int line, tlen = 0;
@@ -9902,11 +9936,11 @@
         ((ctxt->options & XML_PARSE_HUGE) == 0)) {
     xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
          "Excessive depth in document: %d use XML_PARSE_HUGE option\n",
               xmlParserMaxDepth);
     xmlHaltParser(ctxt);
-    return;
+    return(-1);
     }
 
     /* Capture start position */
     if (ctxt->record_info) {
         node_info.begin_pos = ctxt->input->consumed +
@@ -9929,16 +9963,21 @@
 #ifdef LIBXML_SAX1_ENABLED
     else
     name = xmlParseStartTag(ctxt);
 #endif /* LIBXML_SAX1_ENABLED */
     if (ctxt->instate == XML_PARSER_EOF)
-    return;
+    return(-1);
     if (name == NULL) {
     spacePop(ctxt);
-        return;
+        return(-1);
     }
+    if (ctxt->sax2)
+        nameNsPush(ctxt, name, prefix, URI, ctxt->nsNr - nsNr);
+#ifdef LIBXML_SAX1_ENABLED
+    else
     namePush(ctxt, name);
+#endif /* LIBXML_SAX1_ENABLED */
     ret = ctxt->node;
 
 #ifdef LIBXML_VALID_ENABLED
     /*
      * [ VC: Root Element Type ]
@@ -9975,11 +10014,11 @@
                   (CUR_PTR - ctxt->input->base);
        node_info.end_line = ctxt->input->line;
        node_info.node = ret;
        xmlParserAddNodeInfo(ctxt, &node_info);
     }
-    return;
+    return(1);
     }
     if (RAW == '>') {
         NEXT1;
     } else {
         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_GT_REQUIRED,
@@ -10003,45 +10042,43 @@
                   (CUR_PTR - ctxt->input->base);
        node_info.end_line = ctxt->input->line;
        node_info.node = ret;
        xmlParserAddNodeInfo(ctxt, &node_info);
     }
-    return;
+    return(-1);
     }
 
-    /*
-     * Parse the content of the element:
-     */
-    xmlParseContent(ctxt);
-    if (ctxt->instate == XML_PARSER_EOF)
-    return;
-    if (!IS_BYTE_CHAR(RAW)) {
-        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,
-     "Premature end of data in tag %s line %d\n",
-                        name, line, NULL);
+    return(0);
+}
 
-    /*
-     * end of parsing of this node.
+/**
+ * xmlParseElementEnd:
+ * @ctxt:  an XML parser context
+ *
+ * Parse the end of an XML element.
      */
-    nodePop(ctxt);
-    namePop(ctxt);
-    spacePop(ctxt);
-    if (nsNr != ctxt->nsNr)
-        nsPop(ctxt, ctxt->nsNr - nsNr);
+static void
+xmlParseElementEnd(xmlParserCtxtPtr ctxt) {
+    xmlParserNodeInfo node_info;
+    xmlNodePtr ret = ctxt->node;
+
+    if (ctxt->nameNr <= 0)
     return;
-    }
 
     /*
      * parse the end of tag: '</' should be here.
      */
     if (ctxt->sax2) {
-    xmlParseEndTag2(ctxt, prefix, URI, line, ctxt->nsNr - nsNr, tlen);
+        const xmlChar *prefix = ctxt->pushTab[ctxt->nameNr * 3 - 3];
+        const xmlChar *URI = ctxt->pushTab[ctxt->nameNr * 3 - 2];
+        int nsNr = (ptrdiff_t) ctxt->pushTab[ctxt->nameNr * 3 - 1];
+    xmlParseEndTag2(ctxt, prefix, URI, 0, nsNr, 0);
     namePop(ctxt);
     }
 #ifdef LIBXML_SAX1_ENABLED
       else
-    xmlParseEndTag1(ctxt, line);
+    xmlParseEndTag1(ctxt, 0);
 #endif /* LIBXML_SAX1_ENABLED */
 
     /*
      * Capture end position and add node
      */
@@ -10279,11 +10316,11 @@
         xmlFree((xmlChar *) encoding);
             return(NULL);
     }
 
     /*
-     * UTF-16 encoding stwich has already taken place at this stage,
+     * UTF-16 encoding switch has already taken place at this stage,
      * more over the little-endian/big-endian selection is already done
      */
         if ((encoding != NULL) &&
         ((!xmlStrcasecmp(encoding, BAD_CAST "UTF-16")) ||
          (!xmlStrcasecmp(encoding, BAD_CAST "UTF16")))) {
@@ -11162,11 +11199,11 @@
         avail = ctxt->input->length -
                 (ctxt->input->cur - ctxt->input->base);
     else {
         /*
          * If we are operating on converted input, try to flush
-         * remainng chars to avoid them stalling in the non-converted
+         * remaining chars to avoid them stalling in the non-converted
          * buffer. But do not do this in document start where
          * encoding="..." may not have been read and we work on a
          * guessed encoding.
          */
         if ((ctxt->instate != XML_PARSER_START) &&
@@ -12354,17 +12391,10 @@
         xmlErrMemory(NULL, "creating parser: out of memory\n");
     xmlFreeParserInputBuffer(buf);
     return(NULL);
     }
     ctxt->dictNames = 1;
-    ctxt->pushTab = (void **) xmlMalloc(ctxt->nameMax * 3 * sizeof(xmlChar *));
-    if (ctxt->pushTab == NULL) {
-        xmlErrMemory(ctxt, NULL);
-    xmlFreeParserInputBuffer(buf);
-    xmlFreeParserCtxt(ctxt);
-    return(NULL);
-    }
     if (sax != NULL) {
 #ifdef LIBXML_SAX1_ENABLED
     if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler)
 #endif /* LIBXML_SAX1_ENABLED */
         xmlFree(ctxt->sax);
@@ -13896,10 +13926,11 @@
     if (sax != NULL)
     ctxt->sax = oldsax;
     xmlFreeParserCtxt(ctxt);
     newDoc->intSubset = NULL;
     newDoc->extSubset = NULL;
+    if(doc != NULL)
     newDoc->oldNs = NULL;
     xmlFreeDoc(newDoc);
 
     return(ret);
 }
@@ -14005,10 +14036,14 @@
      * incremented to distinguish from main entity
      */
     ctxt->input_id = pctx->input_id + 1;
     }
 
+    /* Don't read from stdin. */
+    if (xmlStrcmp(URL, BAD_CAST "-") == 0)
+        URL = BAD_CAST "./-";
+
     uri = xmlBuildURI(URL, base);
 
     if (uri == NULL) {
     inputStream = xmlLoadExternalEntity((char *)URL, (char *)ID, ctxt);
     if (inputStream == NULL) {
@@ -14937,20 +14972,10 @@
         return(1);
     }
 
     xmlCtxtReset(ctxt);
 
-    if (ctxt->pushTab == NULL) {
-        ctxt->pushTab = (void **) xmlMalloc(ctxt->nameMax * 3 *
-                                        sizeof(xmlChar *));
-        if (ctxt->pushTab == NULL) {
-        xmlErrMemory(ctxt, NULL);
-            xmlFreeParserInputBuffer(buf);
-            return(1);
-        }
-    }
-
     if (filename == NULL) {
         ctxt->directory = NULL;
     } else {
         ctxt->directory = xmlParserGetDirectory(filename);
     }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/xpath.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="xmlwriter.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="xzlib.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/xpath.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  326     */
  327     if ((precedence2 == 3) &amp;&amp; (precedence1 &gt; 1)) {
  328         cur = node1-&gt;parent;
  329         while (cur) {
  330         if (cur == node2)
  331             return(1);
  332         cur = cur-&gt;parent;
  333         }
  334     }
  335     if ((precedence1 == 3) &amp;&amp; (precedence2 &gt; 1)) {
  336         cur = node2-&gt;parent;
  337         while (cur) {
  338         if (cur == node1)
  339             return(-1);
  340         cur = cur-&gt;parent;
  341         }
  342     }
  343     }
  344 
  345     /*
<span class="line-modified">  346      * Speedup using document order if availble.</span>
  347      */
  348     if ((node1-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
  349     (node2-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
  350     (0 &gt; (ptrdiff_t) node1-&gt;content) &amp;&amp;
  351     (0 &gt; (ptrdiff_t) node2-&gt;content) &amp;&amp;
  352     (node1-&gt;doc == node2-&gt;doc)) {
  353 
  354     l1 = -((ptrdiff_t) node1-&gt;content);
  355     l2 = -((ptrdiff_t) node2-&gt;content);
  356     if (l1 &lt; l2)
  357         return(1);
  358     if (l1 &gt; l2)
  359         return(-1);
  360     }
  361 
  362 turtle_comparison:
  363 
  364     if (node1 == node2-&gt;prev)
  365     return(1);
  366     if (node1 == node2-&gt;next)
</pre>
<hr />
<pre>
  394     }
  395     while (depth2 &gt; depth1) {
  396     depth2--;
  397     node2 = node2-&gt;parent;
  398     }
  399     while (node1-&gt;parent != node2-&gt;parent) {
  400     node1 = node1-&gt;parent;
  401     node2 = node2-&gt;parent;
  402     /* should not happen but just in case ... */
  403     if ((node1 == NULL) || (node2 == NULL))
  404         return(-2);
  405     }
  406     /*
  407      * Find who&#39;s first.
  408      */
  409     if (node1 == node2-&gt;prev)
  410     return(1);
  411     if (node1 == node2-&gt;next)
  412     return(-1);
  413     /*
<span class="line-modified">  414      * Speedup using document order if availble.</span>
  415      */
  416     if ((node1-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
  417     (node2-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
  418     (0 &gt; (ptrdiff_t) node1-&gt;content) &amp;&amp;
  419     (0 &gt; (ptrdiff_t) node2-&gt;content) &amp;&amp;
  420     (node1-&gt;doc == node2-&gt;doc)) {
  421 
  422     l1 = -((ptrdiff_t) node1-&gt;content);
  423     l2 = -((ptrdiff_t) node2-&gt;content);
  424     if (l1 &lt; l2)
  425         return(1);
  426     if (l1 &gt; l2)
  427         return(-1);
  428     }
  429 
  430     for (cur = node1-&gt;next;cur != NULL;cur = cur-&gt;next)
  431     if (cur == node2)
  432         return(1);
  433     return(-1); /* assume there is no sibling list corruption */
  434 }
  435 #endif /* XP_OPTIMIZED_NON_ELEM_COMPARISON */
  436 
  437 /*
<span class="line-modified">  438  * Wrapper for the Timsort argorithm from timsort.h</span>
  439  */
  440 #ifdef WITH_TIM_SORT
  441 #define SORT_NAME libxml_domnode
  442 #define SORT_TYPE xmlNodePtr
  443 /**
  444  * wrap_cmp:
  445  * @x: a node
  446  * @y: another node
  447  *
  448  * Comparison function for the Timsort implementation
  449  *
  450  * Returns -2 in case of error -1 if first point &lt; second point, 0 if
  451  *         it&#39;s the same node, +1 otherwise
  452  */
  453 static
  454 int wrap_cmp( xmlNodePtr x, xmlNodePtr y );
  455 #ifdef XP_OPTIMIZED_NON_ELEM_COMPARISON
  456     static int wrap_cmp( xmlNodePtr x, xmlNodePtr y )
  457     {
  458         int res = xmlXPathCmpNodesExt(x, y);
</pre>
<hr />
<pre>
  593     &quot;Undefined variable\n&quot;,
  594     &quot;Invalid predicate\n&quot;,
  595     &quot;Invalid expression\n&quot;,
  596     &quot;Missing closing curly brace\n&quot;,
  597     &quot;Unregistered function\n&quot;,
  598     &quot;Invalid operand\n&quot;,
  599     &quot;Invalid type\n&quot;,
  600     &quot;Invalid number of arguments\n&quot;,
  601     &quot;Invalid context size\n&quot;,
  602     &quot;Invalid context position\n&quot;,
  603     &quot;Memory allocation error\n&quot;,
  604     &quot;Syntax error\n&quot;,
  605     &quot;Resource error\n&quot;,
  606     &quot;Sub resource error\n&quot;,
  607     &quot;Undefined namespace prefix\n&quot;,
  608     &quot;Encoding error\n&quot;,
  609     &quot;Char out of XML range\n&quot;,
  610     &quot;Invalid or incomplete context\n&quot;,
  611     &quot;Stack usage error\n&quot;,
  612     &quot;Forbidden variable\n&quot;,


  613     &quot;?? Unknown error ??\n&quot; /* Must be last in the list! */
  614 };
  615 #define MAXERRNO ((int)(sizeof(xmlXPathErrorMessages) / \
  616            sizeof(xmlXPathErrorMessages[0])) - 1)
  617 /**
  618  * xmlXPathErrMemory:
  619  * @ctxt:  an XPath context
  620  * @extra:  extra informations
  621  *
  622  * Handle a redefinition of attribute error
  623  */
  624 static void
  625 xmlXPathErrMemory(xmlXPathContextPtr ctxt, const char *extra)
  626 {
  627     if (ctxt != NULL) {

  628         if (extra) {
  629             xmlChar buf[200];
  630 
  631             xmlStrPrintf(buf, 200,
  632                          &quot;Memory allocation failed : %s\n&quot;,
  633                          extra);
  634             ctxt-&gt;lastError.message = (char *) xmlStrdup(buf);
  635         } else {
  636             ctxt-&gt;lastError.message = (char *)
  637            xmlStrdup(BAD_CAST &quot;Memory allocation failed\n&quot;);
  638         }
  639         ctxt-&gt;lastError.domain = XML_FROM_XPATH;
  640         ctxt-&gt;lastError.code = XML_ERR_NO_MEMORY;
  641     if (ctxt-&gt;error != NULL)
  642         ctxt-&gt;error(ctxt-&gt;userData, &amp;ctxt-&gt;lastError);
  643     } else {
  644         if (extra)
  645             __xmlRaiseError(NULL, NULL, NULL,
  646                             NULL, NULL, XML_FROM_XPATH,
  647                             XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0,
</pre>
<hr />
<pre>
  730             &quot;%s&quot;, xmlXPathErrorMessages[error]);
  731     }
  732 
  733 }
  734 
  735 /**
  736  * xmlXPatherror:
  737  * @ctxt:  the XPath Parser context
  738  * @file:  the file name
  739  * @line:  the line number
  740  * @no:  the error number
  741  *
  742  * Formats an error message.
  743  */
  744 void
  745 xmlXPatherror(xmlXPathParserContextPtr ctxt, const char *file ATTRIBUTE_UNUSED,
  746               int line ATTRIBUTE_UNUSED, int no) {
  747     xmlXPathErr(ctxt, no);
  748 }
  749 


























  750 /************************************************************************
  751  *                                  *
  752  *          Utilities                   *
  753  *                                  *
  754  ************************************************************************/
  755 
  756 /**
  757  * xsltPointerList:
  758  *
  759  * Pointer-list for various purposes.
  760  */
  761 typedef struct _xmlPointerList xmlPointerList;
  762 typedef xmlPointerList *xmlPointerListPtr;
  763 struct _xmlPointerList {
  764     void **items;
  765     int number;
  766     int size;
  767 };
  768 /*
  769 * TODO: Since such a list-handling is used in xmlschemas.c and libxslt
</pre>
<hr />
<pre>
 1059     xmlFree(comp);
 1060 }
 1061 
 1062 /**
 1063  * xmlXPathCompExprAdd:
 1064  * @comp:  the compiled expression
 1065  * @ch1: first child index
 1066  * @ch2: second child index
 1067  * @op:  an op
 1068  * @value:  the first int value
 1069  * @value2:  the second int value
 1070  * @value3:  the third int value
 1071  * @value4:  the first string value
 1072  * @value5:  the second string value
 1073  *
 1074  * Add a step to an XPath Compiled Expression
 1075  *
 1076  * Returns -1 in case of failure, the index otherwise
 1077  */
 1078 static int
<span class="line-modified"> 1079 xmlXPathCompExprAdd(xmlXPathCompExprPtr comp, int ch1, int ch2,</span>
 1080    xmlXPathOp op, int value,
 1081    int value2, int value3, void *value4, void *value5) {

 1082     if (comp-&gt;nbStep &gt;= comp-&gt;maxStep) {
 1083     xmlXPathStepOp *real;
 1084 
 1085         if (comp-&gt;maxStep &gt;= XPATH_MAX_STEPS) {
<span class="line-modified"> 1086         xmlXPathErrMemory(NULL, &quot;adding step\n&quot;);</span>
 1087         return(-1);
 1088         }
 1089     comp-&gt;maxStep *= 2;
 1090     real = (xmlXPathStepOp *) xmlRealloc(comp-&gt;steps,
 1091                               comp-&gt;maxStep * sizeof(xmlXPathStepOp));
 1092     if (real == NULL) {
 1093         comp-&gt;maxStep /= 2;
<span class="line-modified"> 1094         xmlXPathErrMemory(NULL, &quot;adding step\n&quot;);</span>
 1095         return(-1);
 1096     }
 1097     comp-&gt;steps = real;
 1098     }
 1099     comp-&gt;last = comp-&gt;nbStep;
 1100     comp-&gt;steps[comp-&gt;nbStep].ch1 = ch1;
 1101     comp-&gt;steps[comp-&gt;nbStep].ch2 = ch2;
 1102     comp-&gt;steps[comp-&gt;nbStep].op = op;
 1103     comp-&gt;steps[comp-&gt;nbStep].value = value;
 1104     comp-&gt;steps[comp-&gt;nbStep].value2 = value2;
 1105     comp-&gt;steps[comp-&gt;nbStep].value3 = value3;
 1106     if ((comp-&gt;dict != NULL) &amp;&amp;
 1107         ((op == XPATH_OP_FUNCTION) || (op == XPATH_OP_VARIABLE) ||
 1108      (op == XPATH_OP_COLLECT))) {
 1109         if (value4 != NULL) {
 1110         comp-&gt;steps[comp-&gt;nbStep].value4 = (xmlChar *)
 1111             (void *)xmlDictLookup(comp-&gt;dict, value4, -1);
 1112         xmlFree(value4);
 1113     } else
 1114         comp-&gt;steps[comp-&gt;nbStep].value4 = NULL;
</pre>
<hr />
<pre>
 1136 static void
 1137 xmlXPathCompSwap(xmlXPathStepOpPtr op) {
 1138     int tmp;
 1139 
 1140 #ifndef LIBXML_THREAD_ENABLED
 1141     /*
 1142      * Since this manipulates possibly shared variables, this is
 1143      * disabled if one detects that the library is used in a multithreaded
 1144      * application
 1145      */
 1146     if (xmlXPathDisableOptimizer)
 1147     return;
 1148 #endif
 1149 
 1150     tmp = op-&gt;ch1;
 1151     op-&gt;ch1 = op-&gt;ch2;
 1152     op-&gt;ch2 = tmp;
 1153 }
 1154 
 1155 #define PUSH_FULL_EXPR(op, op1, op2, val, val2, val3, val4, val5)   \
<span class="line-modified"> 1156     xmlXPathCompExprAdd(ctxt-&gt;comp, (op1), (op2),           \</span>
 1157                     (op), (val), (val2), (val3), (val4), (val5))
 1158 #define PUSH_LONG_EXPR(op, val, val2, val3, val4, val5)         \
<span class="line-modified"> 1159     xmlXPathCompExprAdd(ctxt-&gt;comp, ctxt-&gt;comp-&gt;last, -1,       \</span>
 1160                     (op), (val), (val2), (val3), (val4), (val5))
 1161 
 1162 #define PUSH_LEAVE_EXPR(op, val, val2)                  \
<span class="line-modified"> 1163 xmlXPathCompExprAdd(ctxt-&gt;comp, -1, -1, (op), (val), (val2), 0 ,NULL ,NULL)</span>
 1164 
 1165 #define PUSH_UNARY_EXPR(op, ch, val, val2)              \
<span class="line-modified"> 1166 xmlXPathCompExprAdd(ctxt-&gt;comp, (ch), -1, (op), (val), (val2), 0 ,NULL ,NULL)</span>
 1167 
 1168 #define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)           \
<span class="line-modified"> 1169 xmlXPathCompExprAdd(ctxt-&gt;comp, (ch1), (ch2), (op),         \</span>
 1170             (val), (val2), 0 ,NULL ,NULL)
 1171 
 1172 /************************************************************************
 1173  *                                  *
 1174  *      XPath object cache structures               *
 1175  *                                  *
 1176  ************************************************************************/
 1177 
 1178 /* #define XP_DEFAULT_CACHE_ON */
 1179 
 1180 #define XP_HAS_CACHE(c) ((c != NULL) &amp;&amp; ((c)-&gt;cache != NULL))
 1181 
 1182 typedef struct _xmlXPathContextCache xmlXPathContextCache;
 1183 typedef xmlXPathContextCache *xmlXPathContextCachePtr;
 1184 struct _xmlXPathContextCache {
 1185     xmlPointerListPtr nodesetObjs;  /* contains xmlXPathObjectPtr */
 1186     xmlPointerListPtr stringObjs;   /* contains xmlXPathObjectPtr */
 1187     xmlPointerListPtr booleanObjs;  /* contains xmlXPathObjectPtr */
 1188     xmlPointerListPtr numberObjs;   /* contains xmlXPathObjectPtr */
 1189     xmlPointerListPtr miscObjs;     /* contains xmlXPathObjectPtr */
</pre>
<hr />
<pre>
 2209     if (cache == NULL)
 2210     return;
 2211     if (cache-&gt;nodesetObjs)
 2212     xmlXPathCacheFreeObjectList(cache-&gt;nodesetObjs);
 2213     if (cache-&gt;stringObjs)
 2214     xmlXPathCacheFreeObjectList(cache-&gt;stringObjs);
 2215     if (cache-&gt;booleanObjs)
 2216     xmlXPathCacheFreeObjectList(cache-&gt;booleanObjs);
 2217     if (cache-&gt;numberObjs)
 2218     xmlXPathCacheFreeObjectList(cache-&gt;numberObjs);
 2219     if (cache-&gt;miscObjs)
 2220     xmlXPathCacheFreeObjectList(cache-&gt;miscObjs);
 2221     xmlFree(cache);
 2222 }
 2223 
 2224 /**
 2225  * xmlXPathContextSetCache:
 2226  *
 2227  * @ctxt:  the XPath context
 2228  * @active: enables/disables (creates/frees) the cache
<span class="line-modified"> 2229  * @value: a value with semantics dependant on @options</span>
 2230  * @options: options (currently only the value 0 is used)
 2231  *
 2232  * Creates/frees an object cache on the XPath context.
 2233  * If activates XPath objects (xmlXPathObject) will be cached internally
 2234  * to be reused.
 2235  * @options:
 2236  *   0: This will set the XPath object caching:
 2237  *      @value:
 2238  *        This will set the maximum number of XPath objects
 2239  *        to be cached per slot
 2240  *        There are 5 slots for: node-set, string, number, boolean, and
 2241  *        misc objects. Use &lt;0 for the default number (100).
 2242  *   Other values for @options have currently no effect.
 2243  *
 2244  * Returns 0 if the setting succeeded, and -1 on API or internal errors.
 2245  */
 2246 int
 2247 xmlXPathContextSetCache(xmlXPathContextPtr ctxt,
 2248             int active,
 2249             int value,
</pre>
<hr />
<pre>
 2369  * @ctxt: the XPath context
 2370  * @val:  the NodePtr value
 2371  *
 2372  * This is the cached version of xmlXPathNewNodeSet().
 2373  * Acquire an xmlXPathObjectPtr of type NodeSet and initialize
 2374  * it with the single Node @val
 2375  *
 2376  * Returns the created or reused object.
 2377  */
 2378 static xmlXPathObjectPtr
 2379 xmlXPathCacheNewNodeSet(xmlXPathContextPtr ctxt, xmlNodePtr val)
 2380 {
 2381     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;cache)) {
 2382     xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt-&gt;cache;
 2383 
 2384     if ((cache-&gt;nodesetObjs != NULL) &amp;&amp;
 2385         (cache-&gt;nodesetObjs-&gt;number != 0))
 2386     {
 2387         xmlXPathObjectPtr ret;
 2388         /*
<span class="line-modified"> 2389         * Use the nodset-cache.</span>
 2390         */
 2391         ret = (xmlXPathObjectPtr)
 2392         cache-&gt;nodesetObjs-&gt;items[--cache-&gt;nodesetObjs-&gt;number];
 2393         ret-&gt;type = XPATH_NODESET;
 2394         ret-&gt;boolval = 0;
 2395         if (val) {
 2396         if ((ret-&gt;nodesetval-&gt;nodeMax == 0) ||
 2397             (val-&gt;type == XML_NAMESPACE_DECL))
 2398         {

 2399             xmlXPathNodeSetAddUnique(ret-&gt;nodesetval, val);
 2400         } else {
 2401             ret-&gt;nodesetval-&gt;nodeTab[0] = val;
 2402             ret-&gt;nodesetval-&gt;nodeNr = 1;
 2403         }
 2404         }
 2405 #ifdef XP_DEBUG_OBJ_USAGE
 2406         xmlXPathDebugObjUsageRequested(ctxt, XPATH_NODESET);
 2407 #endif
 2408         return(ret);
 2409     } else if ((cache-&gt;miscObjs != NULL) &amp;&amp;
 2410         (cache-&gt;miscObjs-&gt;number != 0))
 2411     {
 2412         xmlXPathObjectPtr ret;
 2413         /*
 2414         * Fallback to misc-cache.
 2415         */
 2416 
 2417         ret = (xmlXPathObjectPtr)
 2418         cache-&gt;miscObjs-&gt;items[--cache-&gt;miscObjs-&gt;number];
</pre>
<hr />
<pre>
 2825 
 2826     if (ctxt-&gt;valueNr &lt;= ctxt-&gt;valueFrame) {
 2827         xmlXPatherror(ctxt, __FILE__, __LINE__, XPATH_STACK_ERROR);
 2828         return (NULL);
 2829     }
 2830 
 2831     ctxt-&gt;valueNr--;
 2832     if (ctxt-&gt;valueNr &gt; 0)
 2833         ctxt-&gt;value = ctxt-&gt;valueTab[ctxt-&gt;valueNr - 1];
 2834     else
 2835         ctxt-&gt;value = NULL;
 2836     ret = ctxt-&gt;valueTab[ctxt-&gt;valueNr];
 2837     ctxt-&gt;valueTab[ctxt-&gt;valueNr] = NULL;
 2838     return (ret);
 2839 }
 2840 /**
 2841  * valuePush:
 2842  * @ctxt:  an XPath evaluation context
 2843  * @value:  the XPath object
 2844  *
<span class="line-modified"> 2845  * Pushes a new XPath object on top of the value stack</span>

 2846  *
<span class="line-modified"> 2847  * returns the number of items on the value stack</span>
 2848  */
 2849 int
 2850 valuePush(xmlXPathParserContextPtr ctxt, xmlXPathObjectPtr value)
 2851 {
<span class="line-modified"> 2852     if ((ctxt == NULL) || (value == NULL)) return(-1);</span>








 2853     if (ctxt-&gt;valueNr &gt;= ctxt-&gt;valueMax) {
 2854         xmlXPathObjectPtr *tmp;
 2855 
 2856         if (ctxt-&gt;valueMax &gt;= XPATH_MAX_STACK_DEPTH) {
<span class="line-modified"> 2857             xmlXPathErrMemory(NULL, &quot;XPath stack depth limit reached\n&quot;);</span>
<span class="line-modified"> 2858             ctxt-&gt;error = XPATH_MEMORY_ERROR;</span>
<span class="line-removed"> 2859             return (0);</span>
 2860         }
 2861         tmp = (xmlXPathObjectPtr *) xmlRealloc(ctxt-&gt;valueTab,
 2862                                              2 * ctxt-&gt;valueMax *
 2863                                              sizeof(ctxt-&gt;valueTab[0]));
 2864         if (tmp == NULL) {
<span class="line-modified"> 2865             xmlXPathErrMemory(NULL, &quot;pushing value\n&quot;);</span>
<span class="line-modified"> 2866             ctxt-&gt;error = XPATH_MEMORY_ERROR;</span>
<span class="line-removed"> 2867             return (0);</span>
 2868         }
 2869         ctxt-&gt;valueMax *= 2;
 2870     ctxt-&gt;valueTab = tmp;
 2871     }
 2872     ctxt-&gt;valueTab[ctxt-&gt;valueNr] = value;
 2873     ctxt-&gt;value = value;
 2874     return (ctxt-&gt;valueNr++);
 2875 }
 2876 
 2877 /**
 2878  * xmlXPathPopBoolean:
 2879  * @ctxt:  an XPath parser context
 2880  *
 2881  * Pops a boolean from the stack, handling conversion if needed.
 2882  * Check error with #xmlXPathCheckError.
 2883  *
 2884  * Returns the boolean
 2885  */
 2886 int
 2887 xmlXPathPopBoolean (xmlXPathParserContextPtr ctxt) {
</pre>
<hr />
<pre>
 3303                 return (1);
 3304             cur = cur-&gt;prev;
 3305         }
 3306         return (-1);
 3307         }
 3308         return(0);
 3309     }
 3310     if (attr2 == 1)
 3311         return(1);
 3312     return(-1);
 3313     }
 3314     if ((node1-&gt;type == XML_NAMESPACE_DECL) ||
 3315         (node2-&gt;type == XML_NAMESPACE_DECL))
 3316     return(1);
 3317     if (node1 == node2-&gt;prev)
 3318     return(1);
 3319     if (node1 == node2-&gt;next)
 3320     return(-1);
 3321 
 3322     /*
<span class="line-modified"> 3323      * Speedup using document order if availble.</span>
 3324      */
 3325     if ((node1-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
 3326     (node2-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
 3327     (0 &gt; (ptrdiff_t) node1-&gt;content) &amp;&amp;
 3328     (0 &gt; (ptrdiff_t) node2-&gt;content) &amp;&amp;
 3329     (node1-&gt;doc == node2-&gt;doc)) {
 3330     ptrdiff_t l1, l2;
 3331 
 3332     l1 = -((ptrdiff_t) node1-&gt;content);
 3333     l2 = -((ptrdiff_t) node2-&gt;content);
 3334     if (l1 &lt; l2)
 3335         return(1);
 3336     if (l1 &gt; l2)
 3337         return(-1);
 3338     }
 3339 
 3340     /*
 3341      * compute depth to root
 3342      */
 3343     for (depth2 = 0, cur = node2;cur-&gt;parent != NULL;cur = cur-&gt;parent) {
</pre>
<hr />
<pre>
 3366     }
 3367     while (depth2 &gt; depth1) {
 3368     depth2--;
 3369     node2 = node2-&gt;parent;
 3370     }
 3371     while (node1-&gt;parent != node2-&gt;parent) {
 3372     node1 = node1-&gt;parent;
 3373     node2 = node2-&gt;parent;
 3374     /* should not happen but just in case ... */
 3375     if ((node1 == NULL) || (node2 == NULL))
 3376         return(-2);
 3377     }
 3378     /*
 3379      * Find who&#39;s first.
 3380      */
 3381     if (node1 == node2-&gt;prev)
 3382     return(1);
 3383     if (node1 == node2-&gt;next)
 3384     return(-1);
 3385     /*
<span class="line-modified"> 3386      * Speedup using document order if availble.</span>
 3387      */
 3388     if ((node1-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
 3389     (node2-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
 3390     (0 &gt; (ptrdiff_t) node1-&gt;content) &amp;&amp;
 3391     (0 &gt; (ptrdiff_t) node2-&gt;content) &amp;&amp;
 3392     (node1-&gt;doc == node2-&gt;doc)) {
 3393     ptrdiff_t l1, l2;
 3394 
 3395     l1 = -((ptrdiff_t) node1-&gt;content);
 3396     l2 = -((ptrdiff_t) node2-&gt;content);
 3397     if (l1 &lt; l2)
 3398         return(1);
 3399     if (l1 &gt; l2)
 3400         return(-1);
 3401     }
 3402 
 3403     for (cur = node1-&gt;next;cur != NULL;cur = cur-&gt;next)
 3404     if (cur == node2)
 3405         return(1);
 3406     return(-1); /* assume there is no sibling list corruption */
</pre>
<hr />
<pre>
 3530     ret = (xmlNodeSetPtr) xmlMalloc(sizeof(xmlNodeSet));
 3531     if (ret == NULL) {
 3532         xmlXPathErrMemory(NULL, &quot;creating nodeset\n&quot;);
 3533     return(NULL);
 3534     }
 3535     memset(ret, 0 , (size_t) sizeof(xmlNodeSet));
 3536     if (val != NULL) {
 3537         ret-&gt;nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *
 3538                          sizeof(xmlNodePtr));
 3539     if (ret-&gt;nodeTab == NULL) {
 3540         xmlXPathErrMemory(NULL, &quot;creating nodeset\n&quot;);
 3541         xmlFree(ret);
 3542         return(NULL);
 3543     }
 3544     memset(ret-&gt;nodeTab, 0 ,
 3545            XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));
 3546         ret-&gt;nodeMax = XML_NODESET_DEFAULT;
 3547     if (val-&gt;type == XML_NAMESPACE_DECL) {
 3548         xmlNsPtr ns = (xmlNsPtr) val;
 3549 

 3550         ret-&gt;nodeTab[ret-&gt;nodeNr++] =
 3551         xmlXPathNodeSetDupNs((xmlNodePtr) ns-&gt;next, ns);
 3552     } else
 3553         ret-&gt;nodeTab[ret-&gt;nodeNr++] = val;
 3554     }
 3555     return(ret);
 3556 }
 3557 
<span class="line-removed"> 3558 /**</span>
<span class="line-removed"> 3559  * xmlXPathNodeSetCreateSize:</span>
<span class="line-removed"> 3560  * @size:  the initial size of the set</span>
<span class="line-removed"> 3561  *</span>
<span class="line-removed"> 3562  * Create a new xmlNodeSetPtr of type double and of value @val</span>
<span class="line-removed"> 3563  *</span>
<span class="line-removed"> 3564  * Returns the newly created object.</span>
<span class="line-removed"> 3565  */</span>
<span class="line-removed"> 3566 static xmlNodeSetPtr</span>
<span class="line-removed"> 3567 xmlXPathNodeSetCreateSize(int size) {</span>
<span class="line-removed"> 3568     xmlNodeSetPtr ret;</span>
<span class="line-removed"> 3569 </span>
<span class="line-removed"> 3570     ret = (xmlNodeSetPtr) xmlMalloc(sizeof(xmlNodeSet));</span>
<span class="line-removed"> 3571     if (ret == NULL) {</span>
<span class="line-removed"> 3572         xmlXPathErrMemory(NULL, &quot;creating nodeset\n&quot;);</span>
<span class="line-removed"> 3573     return(NULL);</span>
<span class="line-removed"> 3574     }</span>
<span class="line-removed"> 3575     memset(ret, 0 , (size_t) sizeof(xmlNodeSet));</span>
<span class="line-removed"> 3576     if (size &lt; XML_NODESET_DEFAULT)</span>
<span class="line-removed"> 3577     size = XML_NODESET_DEFAULT;</span>
<span class="line-removed"> 3578     ret-&gt;nodeTab = (xmlNodePtr *) xmlMalloc(size * sizeof(xmlNodePtr));</span>
<span class="line-removed"> 3579     if (ret-&gt;nodeTab == NULL) {</span>
<span class="line-removed"> 3580     xmlXPathErrMemory(NULL, &quot;creating nodeset\n&quot;);</span>
<span class="line-removed"> 3581     xmlFree(ret);</span>
<span class="line-removed"> 3582     return(NULL);</span>
<span class="line-removed"> 3583     }</span>
<span class="line-removed"> 3584     memset(ret-&gt;nodeTab, 0 , size * (size_t) sizeof(xmlNodePtr));</span>
<span class="line-removed"> 3585     ret-&gt;nodeMax = size;</span>
<span class="line-removed"> 3586     return(ret);</span>
<span class="line-removed"> 3587 }</span>
<span class="line-removed"> 3588 </span>
 3589 /**
 3590  * xmlXPathNodeSetContains:
 3591  * @cur:  the node-set
 3592  * @val:  the node
 3593  *
 3594  * checks whether @cur contains @val
 3595  *
 3596  * Returns true (1) if @cur contains @val, false (0) otherwise
 3597  */
 3598 int
 3599 xmlXPathNodeSetContains (xmlNodeSetPtr cur, xmlNodePtr val) {
 3600     int i;
 3601 
 3602     if ((cur == NULL) || (val == NULL)) return(0);
 3603     if (val-&gt;type == XML_NAMESPACE_DECL) {
 3604     for (i = 0; i &lt; cur-&gt;nodeNr; i++) {
 3605         if (cur-&gt;nodeTab[i]-&gt;type == XML_NAMESPACE_DECL) {
 3606         xmlNsPtr ns1, ns2;
 3607 
 3608         ns1 = (xmlNsPtr) val;
</pre>
<hr />
<pre>
 3667     }
 3668     memset(cur-&gt;nodeTab, 0 ,
 3669            XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));
 3670         cur-&gt;nodeMax = XML_NODESET_DEFAULT;
 3671     } else if (cur-&gt;nodeNr == cur-&gt;nodeMax) {
 3672         xmlNodePtr *temp;
 3673 
 3674         if (cur-&gt;nodeMax &gt;= XPATH_MAX_NODESET_LENGTH) {
 3675             xmlXPathErrMemory(NULL, &quot;growing nodeset hit limit\n&quot;);
 3676             return(-1);
 3677         }
 3678     temp = (xmlNodePtr *) xmlRealloc(cur-&gt;nodeTab, cur-&gt;nodeMax * 2 *
 3679                       sizeof(xmlNodePtr));
 3680     if (temp == NULL) {
 3681         xmlXPathErrMemory(NULL, &quot;growing nodeset\n&quot;);
 3682         return(-1);
 3683     }
 3684         cur-&gt;nodeMax *= 2;
 3685     cur-&gt;nodeTab = temp;
 3686     }

 3687     cur-&gt;nodeTab[cur-&gt;nodeNr++] = xmlXPathNodeSetDupNs(node, ns);
 3688     return(0);
 3689 }
 3690 
 3691 /**
 3692  * xmlXPathNodeSetAdd:
 3693  * @cur:  the initial node set
 3694  * @val:  a new xmlNodePtr
 3695  *
 3696  * add a new xmlNodePtr to an existing NodeSet
 3697  *
 3698  * Returns 0 in case of success, and -1 in case of error
 3699  */
 3700 int
 3701 xmlXPathNodeSetAdd(xmlNodeSetPtr cur, xmlNodePtr val) {
 3702     int i;
 3703 
 3704     if ((cur == NULL) || (val == NULL)) return(-1);
 3705 
 3706     /* @@ with_ns to check whether namespace nodes should be looked at @@ */
</pre>
<hr />
<pre>
 3725         cur-&gt;nodeMax = XML_NODESET_DEFAULT;
 3726     } else if (cur-&gt;nodeNr == cur-&gt;nodeMax) {
 3727         xmlNodePtr *temp;
 3728 
 3729         if (cur-&gt;nodeMax &gt;= XPATH_MAX_NODESET_LENGTH) {
 3730             xmlXPathErrMemory(NULL, &quot;growing nodeset hit limit\n&quot;);
 3731             return(-1);
 3732         }
 3733     temp = (xmlNodePtr *) xmlRealloc(cur-&gt;nodeTab, cur-&gt;nodeMax * 2 *
 3734                       sizeof(xmlNodePtr));
 3735     if (temp == NULL) {
 3736         xmlXPathErrMemory(NULL, &quot;growing nodeset\n&quot;);
 3737         return(-1);
 3738     }
 3739         cur-&gt;nodeMax *= 2;
 3740     cur-&gt;nodeTab = temp;
 3741     }
 3742     if (val-&gt;type == XML_NAMESPACE_DECL) {
 3743     xmlNsPtr ns = (xmlNsPtr) val;
 3744 

 3745     cur-&gt;nodeTab[cur-&gt;nodeNr++] =
 3746         xmlXPathNodeSetDupNs((xmlNodePtr) ns-&gt;next, ns);
 3747     } else
 3748     cur-&gt;nodeTab[cur-&gt;nodeNr++] = val;
 3749     return(0);
 3750 }
 3751 
 3752 /**
 3753  * xmlXPathNodeSetAddUnique:
 3754  * @cur:  the initial node set
 3755  * @val:  a new xmlNodePtr
 3756  *
 3757  * add a new xmlNodePtr to an existing NodeSet, optimized version
 3758  * when we are sure the node is not already in the set.
 3759  *
 3760  * Returns 0 in case of success and -1 in case of failure
 3761  */
 3762 int
 3763 xmlXPathNodeSetAddUnique(xmlNodeSetPtr cur, xmlNodePtr val) {
 3764     if ((cur == NULL) || (val == NULL)) return(-1);
</pre>
<hr />
<pre>
 3779         cur-&gt;nodeMax = XML_NODESET_DEFAULT;
 3780     } else if (cur-&gt;nodeNr == cur-&gt;nodeMax) {
 3781         xmlNodePtr *temp;
 3782 
 3783         if (cur-&gt;nodeMax &gt;= XPATH_MAX_NODESET_LENGTH) {
 3784             xmlXPathErrMemory(NULL, &quot;growing nodeset hit limit\n&quot;);
 3785             return(-1);
 3786         }
 3787     temp = (xmlNodePtr *) xmlRealloc(cur-&gt;nodeTab, cur-&gt;nodeMax * 2 *
 3788                       sizeof(xmlNodePtr));
 3789     if (temp == NULL) {
 3790         xmlXPathErrMemory(NULL, &quot;growing nodeset\n&quot;);
 3791         return(-1);
 3792     }
 3793     cur-&gt;nodeTab = temp;
 3794         cur-&gt;nodeMax *= 2;
 3795     }
 3796     if (val-&gt;type == XML_NAMESPACE_DECL) {
 3797     xmlNsPtr ns = (xmlNsPtr) val;
 3798 

 3799     cur-&gt;nodeTab[cur-&gt;nodeNr++] =
 3800         xmlXPathNodeSetDupNs((xmlNodePtr) ns-&gt;next, ns);
 3801     } else
 3802     cur-&gt;nodeTab[cur-&gt;nodeNr++] = val;
 3803     return(0);
 3804 }
 3805 
 3806 /**
 3807  * xmlXPathNodeSetMerge:
 3808  * @val1:  the first NodeSet or NULL
 3809  * @val2:  the second NodeSet
 3810  *
 3811  * Merges two nodesets, all nodes from @val2 are added to @val1
 3812  * if @val1 is NULL, a new set is created and copied from @val2
 3813  *
 3814  * Returns @val1 once extended or NULL in case of error.
 3815  */
 3816 xmlNodeSetPtr
 3817 xmlXPathNodeSetMerge(xmlNodeSetPtr val1, xmlNodeSetPtr val2) {
 3818     int i, j, initNr, skip;
 3819     xmlNodePtr n1, n2;
 3820 
 3821     if (val2 == NULL) return(val1);
 3822     if (val1 == NULL) {
 3823     val1 = xmlXPathNodeSetCreate(NULL);
 3824     if (val1 == NULL)
 3825         return (NULL);
 3826 #if 0
 3827     /*
 3828     * TODO: The optimization won&#39;t work in every case, since
 3829     *  those nasty namespace nodes need to be added with
 3830     *  xmlXPathNodeSetDupNs() to the set; thus a pure
 3831     *  memcpy is not possible.
 3832     *  If there was a flag on the nodesetval, indicating that
<span class="line-modified"> 3833     *  some temporary nodes are in, that would be helpfull.</span>
 3834     */
 3835     /*
 3836     * Optimization: Create an equally sized node-set
 3837     * and memcpy the content.
 3838     */
 3839     val1 = xmlXPathNodeSetCreateSize(val2-&gt;nodeNr);
 3840     if (val1 == NULL)
 3841         return(NULL);
 3842     if (val2-&gt;nodeNr != 0) {
 3843         if (val2-&gt;nodeNr == 1)
 3844         *(val1-&gt;nodeTab) = *(val2-&gt;nodeTab);
 3845         else {
 3846         memcpy(val1-&gt;nodeTab, val2-&gt;nodeTab,
 3847             val2-&gt;nodeNr * sizeof(xmlNodePtr));
 3848         }
 3849         val1-&gt;nodeNr = val2-&gt;nodeNr;
 3850     }
 3851     return(val1);
 3852 #endif
 3853     }
</pre>
<hr />
<pre>
 3895         val1-&gt;nodeMax = XML_NODESET_DEFAULT;
 3896     } else if (val1-&gt;nodeNr == val1-&gt;nodeMax) {
 3897         xmlNodePtr *temp;
 3898 
 3899             if (val1-&gt;nodeMax &gt;= XPATH_MAX_NODESET_LENGTH) {
 3900                 xmlXPathErrMemory(NULL, &quot;merging nodeset hit limit\n&quot;);
 3901                 return(NULL);
 3902             }
 3903         temp = (xmlNodePtr *) xmlRealloc(val1-&gt;nodeTab, val1-&gt;nodeMax * 2 *
 3904                          sizeof(xmlNodePtr));
 3905         if (temp == NULL) {
 3906             xmlXPathErrMemory(NULL, &quot;merging nodeset\n&quot;);
 3907         return(NULL);
 3908         }
 3909         val1-&gt;nodeTab = temp;
 3910         val1-&gt;nodeMax *= 2;
 3911     }
 3912     if (n2-&gt;type == XML_NAMESPACE_DECL) {
 3913         xmlNsPtr ns = (xmlNsPtr) n2;
 3914 

 3915         val1-&gt;nodeTab[val1-&gt;nodeNr++] =
 3916         xmlXPathNodeSetDupNs((xmlNodePtr) ns-&gt;next, ns);
 3917     } else
 3918         val1-&gt;nodeTab[val1-&gt;nodeNr++] = n2;
 3919     }
 3920 
 3921     return(val1);
 3922 }
 3923 
 3924 
 3925 /**
 3926  * xmlXPathNodeSetMergeAndClear:
 3927  * @set1:  the first NodeSet or NULL
 3928  * @set2:  the second NodeSet
<span class="line-removed"> 3929  * @hasSet2NsNodes: 1 if set2 contains namespaces nodes</span>
 3930  *
<span class="line-modified"> 3931  * Merges two nodesets, all nodes from @set2 are added to @set1</span>
<span class="line-removed"> 3932  * if @set1 is NULL, a new set is created and copied from @set2.</span>
 3933  * Checks for duplicate nodes. Clears set2.
 3934  *
 3935  * Returns @set1 once extended or NULL in case of error.
 3936  */
 3937 static xmlNodeSetPtr
<span class="line-modified"> 3938 xmlXPathNodeSetMergeAndClear(xmlNodeSetPtr set1, xmlNodeSetPtr set2,</span>
<span class="line-modified"> 3939                  int hasNullEntries)</span>
 3940 {
<span class="line-removed"> 3941     if ((set1 == NULL) &amp;&amp; (hasNullEntries == 0)) {</span>
<span class="line-removed"> 3942     /*</span>
<span class="line-removed"> 3943     * Note that doing a memcpy of the list, namespace nodes are</span>
<span class="line-removed"> 3944     * just assigned to set1, since set2 is cleared anyway.</span>
<span class="line-removed"> 3945     */</span>
<span class="line-removed"> 3946     set1 = xmlXPathNodeSetCreateSize(set2-&gt;nodeNr);</span>
<span class="line-removed"> 3947     if (set1 == NULL)</span>
<span class="line-removed"> 3948         return(NULL);</span>
<span class="line-removed"> 3949     if (set2-&gt;nodeNr != 0) {</span>
<span class="line-removed"> 3950         memcpy(set1-&gt;nodeTab, set2-&gt;nodeTab,</span>
<span class="line-removed"> 3951         set2-&gt;nodeNr * sizeof(xmlNodePtr));</span>
<span class="line-removed"> 3952         set1-&gt;nodeNr = set2-&gt;nodeNr;</span>
<span class="line-removed"> 3953     }</span>
<span class="line-removed"> 3954     } else {</span>
 3955     int i, j, initNbSet1;
 3956     xmlNodePtr n1, n2;
 3957 
<span class="line-removed"> 3958     if (set1 == NULL)</span>
<span class="line-removed"> 3959             set1 = xmlXPathNodeSetCreate(NULL);</span>
<span class="line-removed"> 3960         if (set1 == NULL)</span>
<span class="line-removed"> 3961             return (NULL);</span>
<span class="line-removed"> 3962 </span>
 3963     initNbSet1 = set1-&gt;nodeNr;
 3964     for (i = 0;i &lt; set2-&gt;nodeNr;i++) {
 3965         n2 = set2-&gt;nodeTab[i];
 3966         /*
<span class="line-removed"> 3967         * Skip NULLed entries.</span>
<span class="line-removed"> 3968         */</span>
<span class="line-removed"> 3969         if (n2 == NULL)</span>
<span class="line-removed"> 3970         continue;</span>
<span class="line-removed"> 3971         /*</span>
 3972         * Skip duplicates.
 3973         */
 3974         for (j = 0; j &lt; initNbSet1; j++) {
 3975         n1 = set1-&gt;nodeTab[j];
 3976         if (n1 == n2) {
 3977             goto skip_node;
 3978         } else if ((n1-&gt;type == XML_NAMESPACE_DECL) &amp;&amp;
 3979             (n2-&gt;type == XML_NAMESPACE_DECL))
 3980         {
 3981             if ((((xmlNsPtr) n1)-&gt;next == ((xmlNsPtr) n2)-&gt;next) &amp;&amp;
 3982             (xmlStrEqual(((xmlNsPtr) n1)-&gt;prefix,
 3983             ((xmlNsPtr) n2)-&gt;prefix)))
 3984             {
 3985             /*
 3986             * Free the namespace node.
 3987             */
 3988             set2-&gt;nodeTab[i] = NULL;
 3989             xmlXPathNodeSetFreeNs((xmlNsPtr) n2);
 3990             goto skip_node;
 3991             }
</pre>
<hr />
<pre>
 4016         if (temp == NULL) {
 4017             xmlXPathErrMemory(NULL, &quot;merging nodeset\n&quot;);
 4018             return(NULL);
 4019         }
 4020         set1-&gt;nodeTab = temp;
 4021         set1-&gt;nodeMax *= 2;
 4022         }
 4023         set1-&gt;nodeTab[set1-&gt;nodeNr++] = n2;
 4024 skip_node:
 4025         {}
 4026     }
 4027     }
 4028     set2-&gt;nodeNr = 0;
 4029     return(set1);
 4030 }
 4031 
 4032 /**
 4033  * xmlXPathNodeSetMergeAndClearNoDupls:
 4034  * @set1:  the first NodeSet or NULL
 4035  * @set2:  the second NodeSet
<span class="line-removed"> 4036  * @hasSet2NsNodes: 1 if set2 contains namespaces nodes</span>
 4037  *
<span class="line-modified"> 4038  * Merges two nodesets, all nodes from @set2 are added to @set1</span>
<span class="line-modified"> 4039  * if @set1 is NULL, a new set is created and copied from @set2.</span>
<span class="line-removed"> 4040  * Doesn&#39;t chack for duplicate nodes. Clears set2.</span>
 4041  *
 4042  * Returns @set1 once extended or NULL in case of error.
 4043  */
 4044 static xmlNodeSetPtr
<span class="line-modified"> 4045 xmlXPathNodeSetMergeAndClearNoDupls(xmlNodeSetPtr set1, xmlNodeSetPtr set2,</span>
<span class="line-modified"> 4046                     int hasNullEntries)</span>
 4047 {
<span class="line-removed"> 4048     if (set2 == NULL)</span>
<span class="line-removed"> 4049     return(set1);</span>
<span class="line-removed"> 4050     if ((set1 == NULL) &amp;&amp; (hasNullEntries == 0)) {</span>
<span class="line-removed"> 4051     /*</span>
<span class="line-removed"> 4052     * Note that doing a memcpy of the list, namespace nodes are</span>
<span class="line-removed"> 4053     * just assigned to set1, since set2 is cleared anyway.</span>
<span class="line-removed"> 4054     */</span>
<span class="line-removed"> 4055     set1 = xmlXPathNodeSetCreateSize(set2-&gt;nodeNr);</span>
<span class="line-removed"> 4056     if (set1 == NULL)</span>
<span class="line-removed"> 4057         return(NULL);</span>
<span class="line-removed"> 4058     if (set2-&gt;nodeNr != 0) {</span>
<span class="line-removed"> 4059         memcpy(set1-&gt;nodeTab, set2-&gt;nodeTab,</span>
<span class="line-removed"> 4060         set2-&gt;nodeNr * sizeof(xmlNodePtr));</span>
<span class="line-removed"> 4061         set1-&gt;nodeNr = set2-&gt;nodeNr;</span>
<span class="line-removed"> 4062     }</span>
<span class="line-removed"> 4063     } else {</span>
 4064     int i;
 4065     xmlNodePtr n2;
 4066 
<span class="line-removed"> 4067     if (set1 == NULL)</span>
<span class="line-removed"> 4068         set1 = xmlXPathNodeSetCreate(NULL);</span>
<span class="line-removed"> 4069         if (set1 == NULL)</span>
<span class="line-removed"> 4070             return (NULL);</span>
<span class="line-removed"> 4071 </span>
 4072     for (i = 0;i &lt; set2-&gt;nodeNr;i++) {
 4073         n2 = set2-&gt;nodeTab[i];
<span class="line-removed"> 4074         /*</span>
<span class="line-removed"> 4075         * Skip NULLed entries.</span>
<span class="line-removed"> 4076         */</span>
<span class="line-removed"> 4077         if (n2 == NULL)</span>
<span class="line-removed"> 4078         continue;</span>
 4079         if (set1-&gt;nodeMax == 0) {
 4080         set1-&gt;nodeTab = (xmlNodePtr *) xmlMalloc(
 4081             XML_NODESET_DEFAULT * sizeof(xmlNodePtr));
 4082         if (set1-&gt;nodeTab == NULL) {
 4083             xmlXPathErrMemory(NULL, &quot;merging nodeset\n&quot;);
 4084             return(NULL);
 4085         }
 4086         memset(set1-&gt;nodeTab, 0,
 4087             XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));
 4088         set1-&gt;nodeMax = XML_NODESET_DEFAULT;
 4089         } else if (set1-&gt;nodeNr &gt;= set1-&gt;nodeMax) {
 4090         xmlNodePtr *temp;
 4091 
 4092                 if (set1-&gt;nodeMax &gt;= XPATH_MAX_NODESET_LENGTH) {
 4093                     xmlXPathErrMemory(NULL, &quot;merging nodeset hit limit\n&quot;);
 4094                     return(NULL);
 4095                 }
 4096         temp = (xmlNodePtr *) xmlRealloc(
 4097             set1-&gt;nodeTab, set1-&gt;nodeMax * 2 * sizeof(xmlNodePtr));
 4098         if (temp == NULL) {
</pre>
<hr />
<pre>
 4329  * xmlXPathNewNodeSet:
 4330  * @val:  the NodePtr value
 4331  *
 4332  * Create a new xmlXPathObjectPtr of type NodeSet and initialize
 4333  * it with the single Node @val
 4334  *
 4335  * Returns the newly created object.
 4336  */
 4337 xmlXPathObjectPtr
 4338 xmlXPathNewNodeSet(xmlNodePtr val) {
 4339     xmlXPathObjectPtr ret;
 4340 
 4341     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
 4342     if (ret == NULL) {
 4343         xmlXPathErrMemory(NULL, &quot;creating nodeset\n&quot;);
 4344     return(NULL);
 4345     }
 4346     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
 4347     ret-&gt;type = XPATH_NODESET;
 4348     ret-&gt;boolval = 0;

 4349     ret-&gt;nodesetval = xmlXPathNodeSetCreate(val);
 4350     /* @@ with_ns to check whether namespace nodes should be looked at @@ */
 4351 #ifdef XP_DEBUG_OBJ_USAGE
 4352     xmlXPathDebugObjUsageRequested(NULL, XPATH_NODESET);
 4353 #endif
 4354     return(ret);
 4355 }
 4356 
 4357 /**
 4358  * xmlXPathNewValueTree:
 4359  * @val:  the NodePtr value
 4360  *
 4361  * Create a new xmlXPathObjectPtr of type Value Tree (XSLT) and initialize
 4362  * it with the tree root @val
 4363  *
 4364  * Returns the newly created object.
 4365  */
 4366 xmlXPathObjectPtr
 4367 xmlXPathNewValueTree(xmlNodePtr val) {
 4368     xmlXPathObjectPtr ret;
</pre>
<hr />
<pre>
 4389  *
 4390  * Create a new xmlXPathObjectPtr of type NodeSet and initialize
 4391  * it with the Nodeset @val
 4392  *
 4393  * Returns the newly created object.
 4394  */
 4395 xmlXPathObjectPtr
 4396 xmlXPathNewNodeSetList(xmlNodeSetPtr val)
 4397 {
 4398     xmlXPathObjectPtr ret;
 4399     int i;
 4400 
 4401     if (val == NULL)
 4402         ret = NULL;
 4403     else if (val-&gt;nodeTab == NULL)
 4404         ret = xmlXPathNewNodeSet(NULL);
 4405     else {
 4406         ret = xmlXPathNewNodeSet(val-&gt;nodeTab[0]);
 4407         if (ret) {
 4408             for (i = 1; i &lt; val-&gt;nodeNr; ++i) {

 4409                 if (xmlXPathNodeSetAddUnique(ret-&gt;nodesetval, val-&gt;nodeTab[i])
 4410             &lt; 0) break;
 4411         }
 4412     }
 4413     }
 4414 
 4415     return (ret);
 4416 }
 4417 
 4418 /**
 4419  * xmlXPathWrapNodeSet:
 4420  * @val:  the NodePtr value
 4421  *
 4422  * Wrap the Nodeset @val in a new xmlXPathObjectPtr
 4423  *
 4424  * Returns the newly created object.
 4425  */
 4426 xmlXPathObjectPtr
 4427 xmlXPathWrapNodeSet(xmlNodeSetPtr val) {
 4428     xmlXPathObjectPtr ret;
</pre>
<hr />
<pre>
 4460 /**
 4461  * xmlXPathDifference:
 4462  * @nodes1:  a node-set
 4463  * @nodes2:  a node-set
 4464  *
 4465  * Implements the EXSLT - Sets difference() function:
 4466  *    node-set set:difference (node-set, node-set)
 4467  *
 4468  * Returns the difference between the two node sets, or nodes1 if
 4469  *         nodes2 is empty
 4470  */
 4471 xmlNodeSetPtr
 4472 xmlXPathDifference (xmlNodeSetPtr nodes1, xmlNodeSetPtr nodes2) {
 4473     xmlNodeSetPtr ret;
 4474     int i, l1;
 4475     xmlNodePtr cur;
 4476 
 4477     if (xmlXPathNodeSetIsEmpty(nodes2))
 4478     return(nodes1);
 4479 

 4480     ret = xmlXPathNodeSetCreate(NULL);
 4481     if (xmlXPathNodeSetIsEmpty(nodes1))
 4482     return(ret);
 4483 
 4484     l1 = xmlXPathNodeSetGetLength(nodes1);
 4485 
 4486     for (i = 0; i &lt; l1; i++) {
 4487     cur = xmlXPathNodeSetItem(nodes1, i);
 4488     if (!xmlXPathNodeSetContains(nodes2, cur)) {

 4489         if (xmlXPathNodeSetAddUnique(ret, cur) &lt; 0)
 4490             break;
 4491     }
 4492     }
 4493     return(ret);
 4494 }
 4495 
 4496 /**
 4497  * xmlXPathIntersection:
 4498  * @nodes1:  a node-set
 4499  * @nodes2:  a node-set
 4500  *
 4501  * Implements the EXSLT - Sets intersection() function:
 4502  *    node-set set:intersection (node-set, node-set)
 4503  *
 4504  * Returns a node set comprising the nodes that are within both the
 4505  *         node sets passed as arguments
 4506  */
 4507 xmlNodeSetPtr
 4508 xmlXPathIntersection (xmlNodeSetPtr nodes1, xmlNodeSetPtr nodes2) {
 4509     xmlNodeSetPtr ret = xmlXPathNodeSetCreate(NULL);
 4510     int i, l1;
 4511     xmlNodePtr cur;
 4512 
 4513     if (ret == NULL)
 4514         return(ret);
 4515     if (xmlXPathNodeSetIsEmpty(nodes1))
 4516     return(ret);
 4517     if (xmlXPathNodeSetIsEmpty(nodes2))
 4518     return(ret);
 4519 
 4520     l1 = xmlXPathNodeSetGetLength(nodes1);
 4521 
 4522     for (i = 0; i &lt; l1; i++) {
 4523     cur = xmlXPathNodeSetItem(nodes1, i);
 4524     if (xmlXPathNodeSetContains(nodes2, cur)) {

 4525         if (xmlXPathNodeSetAddUnique(ret, cur) &lt; 0)
 4526             break;
 4527     }
 4528     }
 4529     return(ret);
 4530 }
 4531 
 4532 /**
 4533  * xmlXPathDistinctSorted:
 4534  * @nodes:  a node-set, sorted by document order
 4535  *
 4536  * Implements the EXSLT - Sets distinct() function:
 4537  *    node-set set:distinct (node-set)
 4538  *
 4539  * Returns a subset of the nodes contained in @nodes, or @nodes if
 4540  *         it is empty
 4541  */
 4542 xmlNodeSetPtr
 4543 xmlXPathDistinctSorted (xmlNodeSetPtr nodes) {
 4544     xmlNodeSetPtr ret;
 4545     xmlHashTablePtr hash;
 4546     int i, l;
 4547     xmlChar * strval;
 4548     xmlNodePtr cur;
 4549 
 4550     if (xmlXPathNodeSetIsEmpty(nodes))
 4551     return(nodes);
 4552 
 4553     ret = xmlXPathNodeSetCreate(NULL);
 4554     if (ret == NULL)
 4555         return(ret);
 4556     l = xmlXPathNodeSetGetLength(nodes);
 4557     hash = xmlHashCreate (l);
 4558     for (i = 0; i &lt; l; i++) {
 4559     cur = xmlXPathNodeSetItem(nodes, i);
 4560     strval = xmlXPathCastNodeToString(cur);
 4561     if (xmlHashLookup(hash, strval) == NULL) {
 4562         xmlHashAddEntry(hash, strval, strval);

 4563         if (xmlXPathNodeSetAddUnique(ret, cur) &lt; 0)
 4564             break;
 4565     } else {
 4566         xmlFree(strval);
 4567     }
 4568     }
 4569     xmlHashFree(hash, xmlHashDefaultDeallocator);
 4570     return(ret);
 4571 }
 4572 
 4573 /**
 4574  * xmlXPathDistinct:
 4575  * @nodes:  a node-set
 4576  *
 4577  * Implements the EXSLT - Sets distinct() function:
 4578  *    node-set set:distinct (node-set)
 4579  * @nodes is sorted by document order, then #exslSetsDistinctSorted
 4580  * is called with the sorted node-set
 4581  *
 4582  * Returns a subset of the nodes contained in @nodes, or @nodes if
</pre>
<hr />
<pre>
 4636 xmlXPathNodeLeadingSorted (xmlNodeSetPtr nodes, xmlNodePtr node) {
 4637     int i, l;
 4638     xmlNodePtr cur;
 4639     xmlNodeSetPtr ret;
 4640 
 4641     if (node == NULL)
 4642     return(nodes);
 4643 
 4644     ret = xmlXPathNodeSetCreate(NULL);
 4645     if (ret == NULL)
 4646         return(ret);
 4647     if (xmlXPathNodeSetIsEmpty(nodes) ||
 4648     (!xmlXPathNodeSetContains(nodes, node)))
 4649     return(ret);
 4650 
 4651     l = xmlXPathNodeSetGetLength(nodes);
 4652     for (i = 0; i &lt; l; i++) {
 4653     cur = xmlXPathNodeSetItem(nodes, i);
 4654     if (cur == node)
 4655         break;

 4656     if (xmlXPathNodeSetAddUnique(ret, cur) &lt; 0)
 4657         break;
 4658     }
 4659     return(ret);
 4660 }
 4661 
 4662 /**
 4663  * xmlXPathNodeLeading:
 4664  * @nodes:  a node-set
 4665  * @node:  a node
 4666  *
 4667  * Implements the EXSLT - Sets leading() function:
 4668  *    node-set set:leading (node-set, node-set)
 4669  * @nodes is sorted by document order, then #exslSetsNodeLeadingSorted
 4670  * is called.
 4671  *
 4672  * Returns the nodes in @nodes that precede @node in document order,
 4673  *         @nodes if @node is NULL or an empty node-set if @nodes
 4674  *         doesn&#39;t contain @node
 4675  */
</pre>
<hr />
<pre>
 4741 xmlXPathNodeTrailingSorted (xmlNodeSetPtr nodes, xmlNodePtr node) {
 4742     int i, l;
 4743     xmlNodePtr cur;
 4744     xmlNodeSetPtr ret;
 4745 
 4746     if (node == NULL)
 4747     return(nodes);
 4748 
 4749     ret = xmlXPathNodeSetCreate(NULL);
 4750     if (ret == NULL)
 4751         return(ret);
 4752     if (xmlXPathNodeSetIsEmpty(nodes) ||
 4753     (!xmlXPathNodeSetContains(nodes, node)))
 4754     return(ret);
 4755 
 4756     l = xmlXPathNodeSetGetLength(nodes);
 4757     for (i = l - 1; i &gt;= 0; i--) {
 4758     cur = xmlXPathNodeSetItem(nodes, i);
 4759     if (cur == node)
 4760         break;

 4761     if (xmlXPathNodeSetAddUnique(ret, cur) &lt; 0)
 4762         break;
 4763     }
 4764     xmlXPathNodeSetSort(ret);   /* bug 413451 */
 4765     return(ret);
 4766 }
 4767 
 4768 /**
 4769  * xmlXPathNodeTrailing:
 4770  * @nodes:  a node-set
 4771  * @node:  a node
 4772  *
 4773  * Implements the EXSLT - Sets trailing() function:
 4774  *    node-set set:trailing (node-set, node-set)
 4775  * @nodes is sorted by document order, then #xmlXPathNodeTrailingSorted
 4776  * is called.
 4777  *
 4778  * Returns the nodes in @nodes that follow @node in document order,
 4779  *         @nodes if @node is NULL or an empty node-set if @nodes
 4780  *         doesn&#39;t contain @node
</pre>
<hr />
<pre>
 5440         top-&gt;name = (char *)
 5441             xmlStrdup(val-&gt;nodesetval-&gt;nodeTab[0]-&gt;name);
 5442         ret-&gt;user = top;
 5443         if (top != NULL) {
 5444             top-&gt;doc = top;
 5445             cur = val-&gt;nodesetval-&gt;nodeTab[0]-&gt;children;
 5446             while (cur != NULL) {
 5447             tmp = xmlDocCopyNode(cur, top, 1);
 5448             xmlAddChild((xmlNodePtr) top, tmp);
 5449             cur = cur-&gt;next;
 5450             }
 5451         }
 5452 
 5453         ret-&gt;nodesetval = xmlXPathNodeSetCreate((xmlNodePtr) top);
 5454         } else
 5455         ret-&gt;nodesetval = xmlXPathNodeSetCreate(NULL);
 5456         /* Deallocate the copied tree value */
 5457         break;
 5458 #endif
 5459     case XPATH_NODESET:

 5460         ret-&gt;nodesetval = xmlXPathNodeSetMerge(NULL, val-&gt;nodesetval);
 5461         /* Do not deallocate the copied tree value */
 5462         ret-&gt;boolval = 0;
 5463         break;
 5464     case XPATH_LOCATIONSET:
 5465 #ifdef LIBXML_XPTR_ENABLED
 5466     {
 5467         xmlLocationSetPtr loc = val-&gt;user;
 5468         ret-&gt;user = (void *) xmlXPtrLocationSetMerge(NULL, loc);
 5469         break;
 5470     }
 5471 #endif
 5472         case XPATH_USERS:
 5473         ret-&gt;user = val-&gt;user;
 5474         break;
 5475         case XPATH_UNDEFINED:
 5476         xmlGenericError(xmlGenericErrorContext,
 5477             &quot;xmlXPathObjectCopy: unsupported type %d\n&quot;,
 5478             val-&gt;type);
 5479         break;
</pre>
<hr />
<pre>
 5927     xmlFree(str);
 5928     return(ret);
 5929 }
 5930 
 5931 /**
 5932  * xmlXPathCastToNumber:
 5933  * @val:  an XPath object
 5934  *
 5935  * Converts an XPath object to its number value
 5936  *
 5937  * Returns the number value
 5938  */
 5939 double
 5940 xmlXPathCastToNumber(xmlXPathObjectPtr val) {
 5941     double ret = 0.0;
 5942 
 5943     if (val == NULL)
 5944     return(NAN);
 5945     switch (val-&gt;type) {
 5946     case XPATH_UNDEFINED:
<span class="line-modified"> 5947 #ifdef DEGUB_EXPR</span>
 5948     xmlGenericError(xmlGenericErrorContext, &quot;NUMBER: undefined\n&quot;);
 5949 #endif
 5950     ret = NAN;
 5951     break;
 5952     case XPATH_NODESET:
 5953     case XPATH_XSLT_TREE:
 5954     ret = xmlXPathCastNodeSetToNumber(val-&gt;nodesetval);
 5955     break;
 5956     case XPATH_STRING:
 5957     ret = xmlXPathCastStringToNumber(val-&gt;stringval);
 5958     break;
 5959     case XPATH_NUMBER:
 5960     ret = val-&gt;floatval;
 5961     break;
 5962     case XPATH_BOOLEAN:
 5963     ret = xmlXPathCastBooleanToNumber(val-&gt;boolval);
 5964     break;
 5965     case XPATH_USERS:
 5966     case XPATH_POINT:
 5967     case XPATH_RANGE:
</pre>
<hr />
<pre>
 6136     ret-&gt;node = NULL;
 6137 
 6138     ret-&gt;varHash = NULL;
 6139 
 6140     ret-&gt;nb_types = 0;
 6141     ret-&gt;max_types = 0;
 6142     ret-&gt;types = NULL;
 6143 
 6144     ret-&gt;funcHash = xmlHashCreate(0);
 6145 
 6146     ret-&gt;nb_axis = 0;
 6147     ret-&gt;max_axis = 0;
 6148     ret-&gt;axis = NULL;
 6149 
 6150     ret-&gt;nsHash = NULL;
 6151     ret-&gt;user = NULL;
 6152 
 6153     ret-&gt;contextSize = -1;
 6154     ret-&gt;proximityPosition = -1;
 6155 



 6156 #ifdef XP_DEFAULT_CACHE_ON
 6157     if (xmlXPathContextSetCache(ret, 1, -1, 0) == -1) {
 6158     xmlXPathFreeContext(ret);
 6159     return(NULL);
 6160     }
 6161 #endif
 6162 
 6163     xmlXPathRegisterAllFunctions(ret);
 6164 
 6165     return(ret);
 6166 }
 6167 
 6168 /**
 6169  * xmlXPathFreeContext:
 6170  * @ctxt:  the context to free
 6171  *
 6172  * Free up an xmlXPathContext
 6173  */
 6174 void
 6175 xmlXPathFreeContext(xmlXPathContextPtr ctxt) {
</pre>
<hr />
<pre>
 6626     xmlXPathFreeObject(arg2);
 6627         return(0);
 6628     }
 6629 
 6630     ns1 = arg1-&gt;nodesetval;
 6631     ns2 = arg2-&gt;nodesetval;
 6632 
 6633     if ((ns1 == NULL) || (ns1-&gt;nodeNr &lt;= 0)) {
 6634     xmlXPathFreeObject(arg1);
 6635     xmlXPathFreeObject(arg2);
 6636     return(0);
 6637     }
 6638     if ((ns2 == NULL) || (ns2-&gt;nodeNr &lt;= 0)) {
 6639     xmlXPathFreeObject(arg1);
 6640     xmlXPathFreeObject(arg2);
 6641     return(0);
 6642     }
 6643 
 6644     values2 = (double *) xmlMalloc(ns2-&gt;nodeNr * sizeof(double));
 6645     if (values2 == NULL) {

 6646         xmlXPathErrMemory(NULL, &quot;comparing nodesets\n&quot;);
 6647     xmlXPathFreeObject(arg1);
 6648     xmlXPathFreeObject(arg2);
 6649     return(0);
 6650     }
 6651     for (i = 0;i &lt; ns1-&gt;nodeNr;i++) {
 6652     val1 = xmlXPathCastNodeToNumber(ns1-&gt;nodeTab[i]);
 6653     if (xmlXPathIsNaN(val1))
 6654         continue;
 6655     for (j = 0;j &lt; ns2-&gt;nodeNr;j++) {
 6656         if (init == 0) {
 6657         values2[j] = xmlXPathCastNodeToNumber(ns2-&gt;nodeTab[j]);
 6658         }
 6659         if (xmlXPathIsNaN(values2[j]))
 6660         continue;
 6661         if (inf &amp;&amp; strict)
 6662         ret = (val1 &lt; values2[j]);
 6663         else if (inf &amp;&amp; !strict)
 6664         ret = (val1 &lt;= values2[j]);
 6665         else if (!inf &amp;&amp; strict)
</pre>
<hr />
<pre>
 6886 
 6887     ns1 = arg1-&gt;nodesetval;
 6888     ns2 = arg2-&gt;nodesetval;
 6889 
 6890     if ((ns1 == NULL) || (ns1-&gt;nodeNr &lt;= 0))
 6891     return(0);
 6892     if ((ns2 == NULL) || (ns2-&gt;nodeNr &lt;= 0))
 6893     return(0);
 6894 
 6895     /*
 6896      * for equal, check if there is a node pertaining to both sets
 6897      */
 6898     if (neq == 0)
 6899     for (i = 0;i &lt; ns1-&gt;nodeNr;i++)
 6900         for (j = 0;j &lt; ns2-&gt;nodeNr;j++)
 6901         if (ns1-&gt;nodeTab[i] == ns2-&gt;nodeTab[j])
 6902             return(1);
 6903 
 6904     values1 = (xmlChar **) xmlMalloc(ns1-&gt;nodeNr * sizeof(xmlChar *));
 6905     if (values1 == NULL) {

 6906         xmlXPathErrMemory(NULL, &quot;comparing nodesets\n&quot;);
 6907     return(0);
 6908     }
 6909     hashs1 = (unsigned int *) xmlMalloc(ns1-&gt;nodeNr * sizeof(unsigned int));
 6910     if (hashs1 == NULL) {

 6911         xmlXPathErrMemory(NULL, &quot;comparing nodesets\n&quot;);
 6912     xmlFree(values1);
 6913     return(0);
 6914     }
 6915     memset(values1, 0, ns1-&gt;nodeNr * sizeof(xmlChar *));
 6916     values2 = (xmlChar **) xmlMalloc(ns2-&gt;nodeNr * sizeof(xmlChar *));
 6917     if (values2 == NULL) {

 6918         xmlXPathErrMemory(NULL, &quot;comparing nodesets\n&quot;);
 6919     xmlFree(hashs1);
 6920     xmlFree(values1);
 6921     return(0);
 6922     }
 6923     hashs2 = (unsigned int *) xmlMalloc(ns2-&gt;nodeNr * sizeof(unsigned int));
 6924     if (hashs2 == NULL) {

 6925         xmlXPathErrMemory(NULL, &quot;comparing nodesets\n&quot;);
 6926     xmlFree(hashs1);
 6927     xmlFree(values1);
 6928     xmlFree(values2);
 6929     return(0);
 6930     }
 6931     memset(values2, 0, ns2-&gt;nodeNr * sizeof(xmlChar *));
 6932     for (i = 0;i &lt; ns1-&gt;nodeNr;i++) {
 6933     hashs1[i] = xmlXPathNodeValHash(ns1-&gt;nodeTab[i]);
 6934     for (j = 0;j &lt; ns2-&gt;nodeNr;j++) {
 6935         if (i == 0)
 6936         hashs2[j] = xmlXPathNodeValHash(ns2-&gt;nodeTab[j]);
 6937         if (hashs1[i] != hashs2[j]) {
 6938         if (neq) {
 6939             ret = 1;
 6940             break;
 6941         }
 6942         }
 6943         else {
 6944         if (values1[i] == NULL)
</pre>
<hr />
<pre>
 7534     double val;
 7535 
 7536     arg = valuePop(ctxt);
 7537     if (arg == NULL)
 7538     XP_ERROR(XPATH_INVALID_OPERAND);
 7539     val = xmlXPathCastToNumber(arg);
 7540     xmlXPathReleaseObject(ctxt-&gt;context, arg);
 7541     CAST_TO_NUMBER;
 7542     CHECK_TYPE(XPATH_NUMBER);
 7543     ctxt-&gt;value-&gt;floatval *= val;
 7544 }
 7545 
 7546 /**
 7547  * xmlXPathDivValues:
 7548  * @ctxt:  the XPath Parser context
 7549  *
 7550  * Implement the div operation on XPath objects @arg1 / @arg2:
 7551  * The numeric operators convert their operands to numbers as if
 7552  * by calling the number function.
 7553  */

 7554 void
 7555 xmlXPathDivValues(xmlXPathParserContextPtr ctxt) {
 7556     xmlXPathObjectPtr arg;
 7557     double val;
 7558 
 7559     arg = valuePop(ctxt);
 7560     if (arg == NULL)
 7561     XP_ERROR(XPATH_INVALID_OPERAND);
 7562     val = xmlXPathCastToNumber(arg);
 7563     xmlXPathReleaseObject(ctxt-&gt;context, arg);
 7564     CAST_TO_NUMBER;
 7565     CHECK_TYPE(XPATH_NUMBER);
 7566     ctxt-&gt;value-&gt;floatval /= val;
 7567 }
 7568 
 7569 /**
 7570  * xmlXPathModValues:
 7571  * @ctxt:  the XPath Parser context
 7572  *
 7573  * Implement the mod operation on XPath objects: @arg1 / @arg2
</pre>
<hr />
<pre>
 7606  * termination on the axis by returning NULL.
 7607  */
 7608 typedef xmlNodePtr (*xmlXPathTraversalFunction)
 7609                     (xmlXPathParserContextPtr ctxt, xmlNodePtr cur);
 7610 
 7611 /*
 7612  * xmlXPathTraversalFunctionExt:
 7613  * A traversal function enumerates nodes along an axis.
 7614  * Initially it must be called with NULL, and it indicates
 7615  * termination on the axis by returning NULL.
 7616  * The context node of the traversal is specified via @contextNode.
 7617  */
 7618 typedef xmlNodePtr (*xmlXPathTraversalFunctionExt)
 7619                     (xmlNodePtr cur, xmlNodePtr contextNode);
 7620 
 7621 /*
 7622  * xmlXPathNodeSetMergeFunction:
 7623  * Used for merging node sets in xmlXPathCollectAndTest().
 7624  */
 7625 typedef xmlNodeSetPtr (*xmlXPathNodeSetMergeFunction)
<span class="line-modified"> 7626             (xmlNodeSetPtr, xmlNodeSetPtr, int);</span>
 7627 
 7628 
 7629 /**
 7630  * xmlXPathNextSelf:
 7631  * @ctxt:  the XPath Parser context
 7632  * @cur:  the current node in the traversal
 7633  *
 7634  * Traversal function for the &quot;self&quot; direction
 7635  * The self axis contains just the context node itself
 7636  *
 7637  * Returns the next element following that axis
 7638  */
 7639 xmlNodePtr
 7640 xmlXPathNextSelf(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
 7641     if ((ctxt == NULL) || (ctxt-&gt;context == NULL)) return(NULL);
 7642     if (cur == NULL)
 7643         return(ctxt-&gt;context-&gt;node);
 7644     return(NULL);
 7645 }
 7646 
</pre>
<hr />
<pre>
 8545  * xmlXPathCountFunction:
 8546  * @ctxt:  the XPath Parser context
 8547  * @nargs:  the number of arguments
 8548  *
 8549  * Implement the count() XPath function
 8550  *    number count(node-set)
 8551  */
 8552 void
 8553 xmlXPathCountFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 8554     xmlXPathObjectPtr cur;
 8555 
 8556     CHECK_ARITY(1);
 8557     if ((ctxt-&gt;value == NULL) ||
 8558     ((ctxt-&gt;value-&gt;type != XPATH_NODESET) &amp;&amp;
 8559      (ctxt-&gt;value-&gt;type != XPATH_XSLT_TREE)))
 8560     XP_ERROR(XPATH_INVALID_TYPE);
 8561     cur = valuePop(ctxt);
 8562 
 8563     if ((cur == NULL) || (cur-&gt;nodesetval == NULL))
 8564     valuePush(ctxt, xmlXPathCacheNewFloat(ctxt-&gt;context, (double) 0));
<span class="line-modified"> 8565     else if ((cur-&gt;type == XPATH_NODESET) || (cur-&gt;type == XPATH_XSLT_TREE)) {</span>
 8566     valuePush(ctxt, xmlXPathCacheNewFloat(ctxt-&gt;context,
 8567         (double) cur-&gt;nodesetval-&gt;nodeNr));
<span class="line-removed"> 8568     } else {</span>
<span class="line-removed"> 8569     if ((cur-&gt;nodesetval-&gt;nodeNr != 1) ||</span>
<span class="line-removed"> 8570         (cur-&gt;nodesetval-&gt;nodeTab == NULL)) {</span>
<span class="line-removed"> 8571         valuePush(ctxt, xmlXPathCacheNewFloat(ctxt-&gt;context, (double) 0));</span>
<span class="line-removed"> 8572     } else {</span>
<span class="line-removed"> 8573         xmlNodePtr tmp;</span>
<span class="line-removed"> 8574         int i = 0;</span>
<span class="line-removed"> 8575 </span>
<span class="line-removed"> 8576         tmp = cur-&gt;nodesetval-&gt;nodeTab[0];</span>
<span class="line-removed"> 8577         if ((tmp != NULL) &amp;&amp; (tmp-&gt;type != XML_NAMESPACE_DECL)) {</span>
<span class="line-removed"> 8578         tmp = tmp-&gt;children;</span>
<span class="line-removed"> 8579         while (tmp != NULL) {</span>
<span class="line-removed"> 8580             tmp = tmp-&gt;next;</span>
<span class="line-removed"> 8581             i++;</span>
<span class="line-removed"> 8582         }</span>
<span class="line-removed"> 8583         }</span>
<span class="line-removed"> 8584         valuePush(ctxt, xmlXPathCacheNewFloat(ctxt-&gt;context, (double) i));</span>
<span class="line-removed"> 8585     }</span>
<span class="line-removed"> 8586     }</span>
 8587     xmlXPathReleaseObject(ctxt-&gt;context, cur);
 8588 }
 8589 
 8590 /**
 8591  * xmlXPathGetElementsByIds:
 8592  * @doc:  the document
 8593  * @ids:  a whitespace separated list of IDs
 8594  *
 8595  * Selects elements by their unique ID.
 8596  *
 8597  * Returns a node-set of selected elements.
 8598  */
 8599 static xmlNodeSetPtr
 8600 xmlXPathGetElementsByIds (xmlDocPtr doc, const xmlChar *ids) {
 8601     xmlNodeSetPtr ret;
 8602     const xmlChar *cur = ids;
 8603     xmlChar *ID;
 8604     xmlAttrPtr attr;
 8605     xmlNodePtr elem = NULL;
 8606 
 8607     if (ids == NULL) return(NULL);
 8608 
 8609     ret = xmlXPathNodeSetCreate(NULL);
 8610     if (ret == NULL)
 8611         return(ret);
 8612 
 8613     while (IS_BLANK_CH(*cur)) cur++;
 8614     while (*cur != 0) {
 8615     while ((!IS_BLANK_CH(*cur)) &amp;&amp; (*cur != 0))
 8616         cur++;
 8617 
 8618         ID = xmlStrndup(ids, cur - ids);
 8619     if (ID != NULL) {
 8620         /*
 8621          * We used to check the fact that the value passed
 8622          * was an NCName, but this generated much troubles for
 8623          * me and Aleksey Sanin, people blatantly violated that
<span class="line-modified"> 8624          * constaint, like Visa3D spec.</span>
 8625          * if (xmlValidateNCName(ID, 1) == 0)
 8626          */
 8627         attr = xmlGetID(doc, ID);
 8628         if (attr != NULL) {
 8629         if (attr-&gt;type == XML_ATTRIBUTE_NODE)
 8630             elem = attr-&gt;parent;
 8631         else if (attr-&gt;type == XML_ELEMENT_NODE)
 8632             elem = (xmlNodePtr) attr;
 8633         else
 8634             elem = NULL;

 8635         if (elem != NULL)
 8636             xmlXPathNodeSetAdd(ret, elem);
 8637         }
 8638         xmlFree(ID);
 8639     }
 8640 
 8641     while (IS_BLANK_CH(*cur)) cur++;
 8642     ids = cur;
 8643     }
 8644     return(ret);
 8645 }
 8646 
 8647 /**
 8648  * xmlXPathIdFunction:
 8649  * @ctxt:  the XPath Parser context
 8650  * @nargs:  the number of arguments
 8651  *
 8652  * Implement the id() XPath function
 8653  *    node-set id(object)
 8654  * The id function selects elements by their unique ID
</pre>
<hr />
<pre>
 8658  * argument to id is of any other type, the argument is converted to a
 8659  * string as if by a call to the string function; the string is split
 8660  * into a whitespace-separated list of tokens (whitespace is any sequence
 8661  * of characters matching the production S); the result is a node-set
 8662  * containing the elements in the same document as the context node that
 8663  * have a unique ID equal to any of the tokens in the list.
 8664  */
 8665 void
 8666 xmlXPathIdFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 8667     xmlChar *tokens;
 8668     xmlNodeSetPtr ret;
 8669     xmlXPathObjectPtr obj;
 8670 
 8671     CHECK_ARITY(1);
 8672     obj = valuePop(ctxt);
 8673     if (obj == NULL) XP_ERROR(XPATH_INVALID_OPERAND);
 8674     if ((obj-&gt;type == XPATH_NODESET) || (obj-&gt;type == XPATH_XSLT_TREE)) {
 8675     xmlNodeSetPtr ns;
 8676     int i;
 8677 

 8678     ret = xmlXPathNodeSetCreate(NULL);
<span class="line-removed"> 8679         /*</span>
<span class="line-removed"> 8680          * FIXME -- in an out-of-memory condition this will behave badly.</span>
<span class="line-removed"> 8681          * The solution is not clear -- we already popped an item from</span>
<span class="line-removed"> 8682          * ctxt, so the object is in a corrupt state.</span>
<span class="line-removed"> 8683          */</span>
 8684 
 8685     if (obj-&gt;nodesetval != NULL) {
 8686         for (i = 0; i &lt; obj-&gt;nodesetval-&gt;nodeNr; i++) {
 8687         tokens =
 8688             xmlXPathCastNodeToString(obj-&gt;nodesetval-&gt;nodeTab[i]);
 8689         ns = xmlXPathGetElementsByIds(ctxt-&gt;context-&gt;doc, tokens);

 8690         ret = xmlXPathNodeSetMerge(ret, ns);
 8691         xmlXPathFreeNodeSet(ns);
 8692         if (tokens != NULL)
 8693             xmlFree(tokens);
 8694         }
 8695     }
 8696     xmlXPathReleaseObject(ctxt-&gt;context, obj);
 8697     valuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt-&gt;context, ret));
 8698     return;
 8699     }
 8700     obj = xmlXPathCacheConvertString(ctxt-&gt;context, obj);

 8701     ret = xmlXPathGetElementsByIds(ctxt-&gt;context-&gt;doc, obj-&gt;stringval);
 8702     valuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt-&gt;context, ret));
 8703     xmlXPathReleaseObject(ctxt-&gt;context, obj);
 8704     return;
 8705 }
 8706 
 8707 /**
 8708  * xmlXPathLocalNameFunction:
 8709  * @ctxt:  the XPath Parser context
 8710  * @nargs:  the number of arguments
 8711  *
 8712  * Implement the local-name() XPath function
 8713  *    string local-name(node-set?)
 8714  * The local-name function returns a string containing the local part
 8715  * of the name of the node in the argument node-set that is first in
 8716  * document order. If the node-set is empty or the first node has no
 8717  * name, an empty string is returned. If the argument is omitted it
 8718  * defaults to the context node.
 8719  */
 8720 void
</pre>
<hr />
<pre>
 9118  * in the second argument and continuing to the end of the string. For
 9119  * example, substring(&quot;12345&quot;,2) returns &quot;2345&quot;.  More precisely, each
 9120  * character in the string (see [3.6 Strings]) is considered to have a
 9121  * numeric position: the position of the first character is 1, the position
 9122  * of the second character is 2 and so on. The returned substring contains
 9123  * those characters for which the position of the character is greater than
 9124  * or equal to the second argument and, if the third argument is specified,
 9125  * less than the sum of the second and third arguments; the comparisons
 9126  * and addition used for the above follow the standard IEEE 754 rules. Thus:
 9127  *  - substring(&quot;12345&quot;, 1.5, 2.6) returns &quot;234&quot;
 9128  *  - substring(&quot;12345&quot;, 0, 3) returns &quot;12&quot;
 9129  *  - substring(&quot;12345&quot;, 0 div 0, 3) returns &quot;&quot;
 9130  *  - substring(&quot;12345&quot;, 1, 0 div 0) returns &quot;&quot;
 9131  *  - substring(&quot;12345&quot;, -42, 1 div 0) returns &quot;12345&quot;
 9132  *  - substring(&quot;12345&quot;, -1 div 0, 1 div 0) returns &quot;&quot;
 9133  */
 9134 void
 9135 xmlXPathSubstringFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 9136     xmlXPathObjectPtr str, start, len;
 9137     double le=0, in;
<span class="line-modified"> 9138     int i, l, m;</span>
<span class="line-removed"> 9139     xmlChar *ret;</span>
 9140 
 9141     if (nargs &lt; 2) {
 9142     CHECK_ARITY(2);
 9143     }
 9144     if (nargs &gt; 3) {
 9145     CHECK_ARITY(3);
 9146     }
 9147     /*
 9148      * take care of possible last (position) argument
 9149     */
 9150     if (nargs == 3) {
 9151     CAST_TO_NUMBER;
 9152     CHECK_TYPE(XPATH_NUMBER);
 9153     len = valuePop(ctxt);
 9154     le = len-&gt;floatval;
 9155     xmlXPathReleaseObject(ctxt-&gt;context, len);
 9156     }
 9157 
 9158     CAST_TO_NUMBER;
 9159     CHECK_TYPE(XPATH_NUMBER);
 9160     start = valuePop(ctxt);
 9161     in = start-&gt;floatval;
 9162     xmlXPathReleaseObject(ctxt-&gt;context, start);
 9163     CAST_TO_STRING;
 9164     CHECK_TYPE(XPATH_STRING);
 9165     str = valuePop(ctxt);
<span class="line-removed"> 9166     m = xmlUTF8Strlen((const unsigned char *)str-&gt;stringval);</span>
<span class="line-removed"> 9167 </span>
<span class="line-removed"> 9168     /*</span>
<span class="line-removed"> 9169      * If last pos not present, calculate last position</span>
<span class="line-removed"> 9170     */</span>
<span class="line-removed"> 9171     if (nargs != 3) {</span>
<span class="line-removed"> 9172     le = (double)m;</span>
<span class="line-removed"> 9173     if (in &lt; 1.0)</span>
<span class="line-removed"> 9174         in = 1.0;</span>
<span class="line-removed"> 9175     }</span>
 9176 
<span class="line-modified"> 9177     /* Need to check for the special cases where either</span>
<span class="line-modified"> 9178      * the index is NaN, the length is NaN, or both</span>
<span class="line-modified"> 9179      * arguments are infinity (relying on Inf + -Inf = NaN)</span>
<span class="line-removed"> 9180      */</span>
<span class="line-removed"> 9181     if (!xmlXPathIsInf(in) &amp;&amp; !xmlXPathIsNaN(in + le)) {</span>
<span class="line-removed"> 9182         /*</span>
<span class="line-removed"> 9183          * To meet the requirements of the spec, the arguments</span>
<span class="line-removed"> 9184      * must be converted to integer format before</span>
<span class="line-removed"> 9185      * initial index calculations are done</span>
<span class="line-removed"> 9186          *</span>
<span class="line-removed"> 9187          * First we go to integer form, rounding up</span>
<span class="line-removed"> 9188      * and checking for special cases</span>
<span class="line-removed"> 9189          */</span>
 9190         i = (int) in;
<span class="line-modified"> 9191         if (((double)i)+0.5 &lt;= in) i++;</span>
<span class="line-modified"> 9192 </span>
<span class="line-removed"> 9193     if (xmlXPathIsInf(le) == 1) {</span>
<span class="line-removed"> 9194         l = m;</span>
<span class="line-removed"> 9195         if (i &lt; 1)</span>
<span class="line-removed"> 9196         i = 1;</span>
<span class="line-removed"> 9197     }</span>
<span class="line-removed"> 9198     else if (xmlXPathIsInf(le) == -1 || le &lt; 0.0)</span>
<span class="line-removed"> 9199         l = 0;</span>
<span class="line-removed"> 9200     else {</span>
<span class="line-removed"> 9201         l = (int) le;</span>
<span class="line-removed"> 9202         if (((double)l)+0.5 &lt;= le) l++;</span>
 9203     }
 9204 
<span class="line-modified"> 9205     /* Now we normalize inidices */</span>
<span class="line-modified"> 9206         i -= 1;</span>
<span class="line-modified"> 9207         l += i;</span>
<span class="line-modified"> 9208         if (i &lt; 0)</span>
<span class="line-modified"> 9209             i = 0;</span>
<span class="line-modified"> 9210         if (l &gt; m)</span>
<span class="line-removed"> 9211             l = m;</span>
 9212 
<span class="line-modified"> 9213         /* number of chars to copy */</span>
<span class="line-modified"> 9214         l -= i;</span>

 9215 
<span class="line-modified"> 9216         ret = xmlUTF8Strsub(str-&gt;stringval, i, l);</span>




 9217     }
<span class="line-removed"> 9218     else {</span>
<span class="line-removed"> 9219         ret = NULL;</span>
 9220     }
<span class="line-modified"> 9221     if (ret == NULL)</span>
<span class="line-modified"> 9222     valuePush(ctxt, xmlXPathCacheNewCString(ctxt-&gt;context, &quot;&quot;));</span>
<span class="line-modified"> 9223     else {</span>
 9224     valuePush(ctxt, xmlXPathCacheNewString(ctxt-&gt;context, ret));
 9225     xmlFree(ret);


 9226     }

 9227     xmlXPathReleaseObject(ctxt-&gt;context, str);
 9228 }
 9229 
 9230 /**
 9231  * xmlXPathSubstringBeforeFunction:
 9232  * @ctxt:  the XPath Parser context
 9233  * @nargs:  the number of arguments
 9234  *
 9235  * Implement the substring-before() XPath function
 9236  *    string substring-before(string, string)
 9237  * The substring-before function returns the substring of the first
 9238  * argument string that precedes the first occurrence of the second
 9239  * argument string in the first argument string, or the empty string
 9240  * if the first argument string does not contain the second argument
 9241  * string. For example, substring-before(&quot;1999/04/01&quot;,&quot;/&quot;) returns 1999.
 9242  */
 9243 void
 9244 xmlXPathSubstringBeforeFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 9245   xmlXPathObjectPtr str;
 9246   xmlXPathObjectPtr find;
</pre>
<hr />
<pre>
 9665 
 9666     ctxt-&gt;value-&gt;floatval = floor(ctxt-&gt;value-&gt;floatval);
 9667 }
 9668 
 9669 /**
 9670  * xmlXPathCeilingFunction:
 9671  * @ctxt:  the XPath Parser context
 9672  * @nargs:  the number of arguments
 9673  *
 9674  * Implement the ceiling() XPath function
 9675  *    number ceiling(number)
 9676  * The ceiling function returns the smallest (closest to negative infinity)
 9677  * number that is not less than the argument and that is an integer.
 9678  */
 9679 void
 9680 xmlXPathCeilingFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 9681     CHECK_ARITY(1);
 9682     CAST_TO_NUMBER;
 9683     CHECK_TYPE(XPATH_NUMBER);
 9684 




 9685     ctxt-&gt;value-&gt;floatval = ceil(ctxt-&gt;value-&gt;floatval);

 9686 }
 9687 
 9688 /**
 9689  * xmlXPathRoundFunction:
 9690  * @ctxt:  the XPath Parser context
 9691  * @nargs:  the number of arguments
 9692  *
 9693  * Implement the round() XPath function
 9694  *    number round(number)
 9695  * The round function returns the number that is closest to the
 9696  * argument and that is an integer. If there are two such numbers,
 9697  * then the one that is closest to positive infinity is returned.
 9698  */
 9699 void
 9700 xmlXPathRoundFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 9701     double f;
 9702 
 9703     CHECK_ARITY(1);
 9704     CAST_TO_NUMBER;
 9705     CHECK_TYPE(XPATH_NUMBER);
</pre>
<hr />
<pre>
 9982          * Okay someone managed to make a huge name, so he&#39;s ready to pay
 9983          * for the processing speed.
 9984          */
 9985         xmlChar *buffer;
 9986         int max = len * 2;
 9987 
 9988             if (len &gt; XML_MAX_NAME_LENGTH) {
 9989                 XP_ERRORNULL(XPATH_EXPR_ERROR);
 9990             }
 9991         buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));
 9992         if (buffer == NULL) {
 9993         XP_ERRORNULL(XPATH_MEMORY_ERROR);
 9994         }
 9995         memcpy(buffer, buf, len);
 9996         while ((IS_LETTER(c)) || (IS_DIGIT(c)) || /* test bigname.xml */
 9997            (c == &#39;.&#39;) || (c == &#39;-&#39;) ||
 9998            (c == &#39;_&#39;) || ((qualified) &amp;&amp; (c == &#39;:&#39;)) ||
 9999            (IS_COMBINING(c)) ||
10000            (IS_EXTENDER(c))) {
10001         if (len + 10 &gt; max) {

10002                     if (max &gt; XML_MAX_NAME_LENGTH) {

10003                         XP_ERRORNULL(XPATH_EXPR_ERROR);
10004                     }
10005             max *= 2;
<span class="line-modified">10006             buffer = (xmlChar *) xmlRealloc(buffer,</span>
10007                                         max * sizeof(xmlChar));
<span class="line-modified">10008             if (buffer == NULL) {</span>

10009             XP_ERRORNULL(XPATH_MEMORY_ERROR);
10010             }

10011         }
10012         COPY_BUF(l,buffer,len,c);
10013         NEXTL(l);
10014         c = CUR_CHAR(l);
10015         }
10016         buffer[len] = 0;
10017         return(buffer);
10018     }
10019     }
10020     if (len == 0)
10021     return(NULL);
10022     return(xmlStrndup(buf, len));
10023 }
10024 
10025 #define MAX_FRAC 20
10026 
10027 /**
10028  * xmlXPathStringEvalNumber:
10029  * @str:  A string to scan
10030  *
</pre>
<hr />
<pre>
10882  *
10883  *  [24]   RelationalExpr ::=   AdditiveExpr
10884  *                 | RelationalExpr &#39;&lt;&#39; AdditiveExpr
10885  *                 | RelationalExpr &#39;&gt;&#39; AdditiveExpr
10886  *                 | RelationalExpr &#39;&lt;=&#39; AdditiveExpr
10887  *                 | RelationalExpr &#39;&gt;=&#39; AdditiveExpr
10888  *
10889  *  A &lt;= B &gt; C is allowed ? Answer from James, yes with
10890  *  (AdditiveExpr &lt;= AdditiveExpr) &gt; AdditiveExpr
10891  *  which is basically what got implemented.
10892  *
10893  * Compile a Relational expression, then push the result
10894  * on the stack
10895  */
10896 
10897 static void
10898 xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {
10899     xmlXPathCompAdditiveExpr(ctxt);
10900     CHECK_ERROR;
10901     SKIP_BLANKS;
<span class="line-modified">10902     while ((CUR == &#39;&lt;&#39;) ||</span>
<span class="line-removed">10903            (CUR == &#39;&gt;&#39;) ||</span>
<span class="line-removed">10904            ((CUR == &#39;&lt;&#39;) &amp;&amp; (NXT(1) == &#39;=&#39;)) ||</span>
<span class="line-removed">10905            ((CUR == &#39;&gt;&#39;) &amp;&amp; (NXT(1) == &#39;=&#39;))) {</span>
10906     int inf, strict;
10907     int op1 = ctxt-&gt;comp-&gt;last;
10908 
10909         if (CUR == &#39;&lt;&#39;) inf = 1;
10910     else inf = 0;
10911     if (NXT(1) == &#39;=&#39;) strict = 0;
10912     else strict = 1;
10913     NEXT;
10914     if (!strict) NEXT;
10915     SKIP_BLANKS;
10916         xmlXPathCompAdditiveExpr(ctxt);
10917     CHECK_ERROR;
10918     PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt-&gt;comp-&gt;last, inf, strict);
10919     SKIP_BLANKS;
10920     }
10921 }
10922 
10923 /**
10924  * xmlXPathCompEqualityExpr:
10925  * @ctxt:  the XPath Parser context
</pre>
<hr />
<pre>
10978     SKIP_BLANKS;
10979         xmlXPathCompEqualityExpr(ctxt);
10980     CHECK_ERROR;
10981     PUSH_BINARY_EXPR(XPATH_OP_AND, op1, ctxt-&gt;comp-&gt;last, 0, 0);
10982     SKIP_BLANKS;
10983     }
10984 }
10985 
10986 /**
10987  * xmlXPathCompileExpr:
10988  * @ctxt:  the XPath Parser context
10989  *
10990  *  [14]   Expr ::=   OrExpr
10991  *  [21]   OrExpr ::=   AndExpr
10992  *                 | OrExpr &#39;or&#39; AndExpr
10993  *
10994  * Parse and compile an expression
10995  */
10996 static void
10997 xmlXPathCompileExpr(xmlXPathParserContextPtr ctxt, int sort) {








10998     xmlXPathCompAndExpr(ctxt);
10999     CHECK_ERROR;
11000     SKIP_BLANKS;
11001     while ((CUR == &#39;o&#39;) &amp;&amp; (NXT(1) == &#39;r&#39;)) {
11002     int op1 = ctxt-&gt;comp-&gt;last;
11003         SKIP(2);
11004     SKIP_BLANKS;
11005         xmlXPathCompAndExpr(ctxt);
11006     CHECK_ERROR;
11007     PUSH_BINARY_EXPR(XPATH_OP_OR, op1, ctxt-&gt;comp-&gt;last, 0, 0);
11008     SKIP_BLANKS;
11009     }
11010     if ((sort) &amp;&amp; (ctxt-&gt;comp-&gt;steps[ctxt-&gt;comp-&gt;last].op != XPATH_OP_VALUE)) {
11011     /* more ops could be optimized too */
11012     /*
11013     * This is the main place to eliminate sorting for
11014     * operations which don&#39;t require a sorted node-set.
11015     * E.g. count().
11016     */
11017     PUSH_UNARY_EXPR(XPATH_OP_SORT, ctxt-&gt;comp-&gt;last , 0, 0);
11018     }



11019 }
11020 
11021 /**
11022  * xmlXPathCompPredicate:
11023  * @ctxt:  the XPath Parser context
11024  * @filter:  act as a filter
11025  *
11026  *  [8]   Predicate ::=   &#39;[&#39; PredicateExpr &#39;]&#39;
11027  *  [9]   PredicateExpr ::=   Expr
11028  *
11029  * Compile a predicate expression
11030  */
11031 static void
11032 xmlXPathCompPredicate(xmlXPathParserContextPtr ctxt, int filter) {
11033     int op1 = ctxt-&gt;comp-&gt;last;
11034 
11035     SKIP_BLANKS;
11036     if (CUR != &#39;[&#39;) {
11037     XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);
11038     }
</pre>
<hr />
<pre>
11617             xmlGenericError(xmlGenericErrorContext,
11618                             &quot;           searching for *\n&quot;);
11619             break;
11620         case NODE_TEST_NS:
11621             xmlGenericError(xmlGenericErrorContext,
11622                             &quot;           searching for namespace %s\n&quot;,
11623                             op-&gt;value5);
11624             break;
11625         case NODE_TEST_NAME:
11626             xmlGenericError(xmlGenericErrorContext,
11627                             &quot;           searching for name %s\n&quot;, op-&gt;value5);
11628             if (op-&gt;value4)
11629                 xmlGenericError(xmlGenericErrorContext,
11630                                 &quot;           with namespace %s\n&quot;, op-&gt;value4);
11631             break;
11632     }
11633     xmlGenericError(xmlGenericErrorContext, &quot;Testing : &quot;);
11634 }
11635 #endif /* DEBUG_STEP */
11636 
<span class="line-modified">11637 static int</span>
<span class="line-modified">11638 xmlXPathCompOpEvalPredicate(xmlXPathParserContextPtr ctxt,</span>
<span class="line-modified">11639                 xmlXPathStepOpPtr op,</span>












11640                 xmlNodeSetPtr set,
<span class="line-modified">11641                 int contextSize,</span>

11642                 int hasNsNodes)
11643 {
<span class="line-modified">11644     if (op-&gt;ch1 != -1) {</span>
<span class="line-modified">11645     xmlXPathCompExprPtr comp = ctxt-&gt;comp;</span>








11646     /*
<span class="line-modified">11647     * Process inner predicates first.</span>

11648     */
<span class="line-modified">11649     if (comp-&gt;steps[op-&gt;ch1].op != XPATH_OP_PREDICATE) {</span>
<span class="line-modified">11650         /*</span>
<span class="line-modified">11651         * TODO: raise an internal error.</span>
<span class="line-removed">11652         */</span>
<span class="line-removed">11653     }</span>
<span class="line-removed">11654     contextSize = xmlXPathCompOpEvalPredicate(ctxt,</span>
<span class="line-removed">11655         &amp;comp-&gt;steps[op-&gt;ch1], set, contextSize, hasNsNodes);</span>
<span class="line-removed">11656     CHECK_ERROR0;</span>
<span class="line-removed">11657     if (contextSize &lt;= 0)</span>
<span class="line-removed">11658         return(0);</span>
11659     }
<span class="line-removed">11660     if (op-&gt;ch2 != -1) {</span>
<span class="line-removed">11661     xmlXPathContextPtr xpctxt = ctxt-&gt;context;</span>
<span class="line-removed">11662     xmlNodePtr contextNode, oldContextNode;</span>
<span class="line-removed">11663     xmlDocPtr oldContextDoc;</span>
<span class="line-removed">11664         int oldcs, oldpp;</span>
<span class="line-removed">11665     int i, res, contextPos = 0, newContextSize;</span>
<span class="line-removed">11666     xmlXPathStepOpPtr exprOp;</span>
<span class="line-removed">11667     xmlXPathObjectPtr contextObj = NULL, exprRes = NULL;</span>
11668 
<span class="line-modified">11669 #ifdef LIBXML_XPTR_ENABLED</span>
<span class="line-modified">11670     /*</span>
<span class="line-modified">11671     * URGENT TODO: Check the following:</span>
<span class="line-modified">11672     *  We don&#39;t expect location sets if evaluating prediates, right?</span>
<span class="line-modified">11673     *  Only filters should expect location sets, right?</span>
<span class="line-modified">11674     */</span>
<span class="line-removed">11675 #endif</span>
<span class="line-removed">11676     /*</span>
<span class="line-removed">11677     * SPEC XPath 1.0:</span>
<span class="line-removed">11678     *  &quot;For each node in the node-set to be filtered, the</span>
<span class="line-removed">11679     *  PredicateExpr is evaluated with that node as the</span>
<span class="line-removed">11680     *  context node, with the number of nodes in the</span>
<span class="line-removed">11681     *  node-set as the context size, and with the proximity</span>
<span class="line-removed">11682     *  position of the node in the node-set with respect to</span>
<span class="line-removed">11683     *  the axis as the context position;&quot;</span>
<span class="line-removed">11684     * @oldset is the node-set&quot; to be filtered.</span>
<span class="line-removed">11685     *</span>
<span class="line-removed">11686     * SPEC XPath 1.0:</span>
<span class="line-removed">11687     *  &quot;only predicates change the context position and</span>
<span class="line-removed">11688     *  context size (see [2.4 Predicates]).&quot;</span>
<span class="line-removed">11689     * Example:</span>
<span class="line-removed">11690     *   node-set  context pos</span>
<span class="line-removed">11691     *    nA         1</span>
<span class="line-removed">11692     *    nB         2</span>
<span class="line-removed">11693     *    nC         3</span>
<span class="line-removed">11694     *   After applying predicate [position() &gt; 1] :</span>
<span class="line-removed">11695     *   node-set  context pos</span>
<span class="line-removed">11696     *    nB         1</span>
<span class="line-removed">11697     *    nC         2</span>
<span class="line-removed">11698     */</span>
<span class="line-removed">11699     oldContextNode = xpctxt-&gt;node;</span>
<span class="line-removed">11700     oldContextDoc = xpctxt-&gt;doc;</span>
<span class="line-removed">11701         oldcs = xpctxt-&gt;contextSize;</span>
<span class="line-removed">11702         oldpp = xpctxt-&gt;proximityPosition;</span>
<span class="line-removed">11703     /*</span>
<span class="line-removed">11704     * Get the expression of this predicate.</span>
<span class="line-removed">11705     */</span>
<span class="line-removed">11706     exprOp = &amp;ctxt-&gt;comp-&gt;steps[op-&gt;ch2];</span>
<span class="line-removed">11707     newContextSize = 0;</span>
<span class="line-removed">11708     for (i = 0; i &lt; set-&gt;nodeNr; i++) {</span>
<span class="line-removed">11709         if (set-&gt;nodeTab[i] == NULL)</span>
<span class="line-removed">11710         continue;</span>
11711 
<span class="line-modified">11712         contextNode = set-&gt;nodeTab[i];</span>
<span class="line-modified">11713         xpctxt-&gt;node = contextNode;</span>
<span class="line-modified">11714         xpctxt-&gt;contextSize = contextSize;</span>
<span class="line-modified">11715         xpctxt-&gt;proximityPosition = ++contextPos;</span>




11716 
11717         /*
11718         * Also set the xpath document in case things like
11719         * key() are evaluated in the predicate.


11720         */
<span class="line-modified">11721         if ((contextNode-&gt;type != XML_NAMESPACE_DECL) &amp;&amp;</span>
<span class="line-modified">11722         (contextNode-&gt;doc != NULL))</span>
<span class="line-modified">11723         xpctxt-&gt;doc = contextNode-&gt;doc;</span>
<span class="line-removed">11724         /*</span>
<span class="line-removed">11725         * Evaluate the predicate expression with 1 context node</span>
<span class="line-removed">11726         * at a time; this node is packaged into a node set; this</span>
<span class="line-removed">11727         * node set is handed over to the evaluation mechanism.</span>
<span class="line-removed">11728         */</span>
<span class="line-removed">11729         if (contextObj == NULL)</span>
<span class="line-removed">11730         contextObj = xmlXPathCacheNewNodeSet(xpctxt, contextNode);</span>
<span class="line-removed">11731         else {</span>
<span class="line-removed">11732         if (xmlXPathNodeSetAddUnique(contextObj-&gt;nodesetval,</span>
<span class="line-removed">11733             contextNode) &lt; 0) {</span>
<span class="line-removed">11734             ctxt-&gt;error = XPATH_MEMORY_ERROR;</span>
<span class="line-removed">11735             goto evaluation_exit;</span>
<span class="line-removed">11736         }</span>
<span class="line-removed">11737         }</span>
11738 
<span class="line-modified">11739         valuePush(ctxt, contextObj);</span>








11740 
<span class="line-modified">11741         res = xmlXPathCompOpEvalToBoolean(ctxt, exprOp, 1);</span>




11742 
<span class="line-modified">11743         if ((ctxt-&gt;error != XPATH_EXPRESSION_OK) || (res == -1)) {</span>
<span class="line-modified">11744         xmlXPathNodeSetClear(set, hasNsNodes);</span>
<span class="line-modified">11745         newContextSize = 0;</span>
<span class="line-modified">11746         goto evaluation_exit;</span>


11747         }
11748 
11749         if (res != 0) {
<span class="line-modified">11750         newContextSize++;</span>
<span class="line-modified">11751         } else {</span>
<span class="line-modified">11752         /*</span>
<span class="line-modified">11753         * Remove the entry from the initial node set.</span>
<span class="line-modified">11754         */</span>
<span class="line-modified">11755         set-&gt;nodeTab[i] = NULL;</span>
<span class="line-modified">11756         if (contextNode-&gt;type == XML_NAMESPACE_DECL)</span>
<span class="line-modified">11757             xmlXPathNodeSetFreeNs((xmlNsPtr) contextNode);</span>






11758         }
<span class="line-modified">11759         if (ctxt-&gt;value == contextObj) {</span>
<span class="line-modified">11760         /*</span>
<span class="line-modified">11761         * Don&#39;t free the temporary XPath object holding the</span>
<span class="line-modified">11762         * context node, in order to avoid massive recreation</span>
<span class="line-modified">11763         * inside this loop.</span>
<span class="line-modified">11764         */</span>
<span class="line-modified">11765         valuePop(ctxt);</span>
<span class="line-modified">11766         xmlXPathNodeSetClear(contextObj-&gt;nodesetval, hasNsNodes);</span>








11767         } else {
<span class="line-modified">11768         /*</span>
<span class="line-modified">11769         * TODO: The object was lost in the evaluation machinery.</span>
<span class="line-removed">11770         *  Can this happen? Maybe in internal-error cases.</span>
<span class="line-removed">11771         */</span>
<span class="line-removed">11772         contextObj = NULL;</span>
11773         }
11774     }
11775 
<span class="line-modified">11776     if (contextObj != NULL) {</span>
<span class="line-modified">11777         if (ctxt-&gt;value == contextObj)</span>
<span class="line-modified">11778         valuePop(ctxt);</span>
<span class="line-removed">11779         xmlXPathReleaseObject(xpctxt, contextObj);</span>
<span class="line-removed">11780     }</span>
<span class="line-removed">11781 evaluation_exit:</span>
<span class="line-removed">11782     if (exprRes != NULL)</span>
<span class="line-removed">11783         xmlXPathReleaseObject(ctxt-&gt;context, exprRes);</span>
<span class="line-removed">11784     /*</span>
<span class="line-removed">11785     * Reset/invalidate the context.</span>
<span class="line-removed">11786     */</span>
<span class="line-removed">11787     xpctxt-&gt;node = oldContextNode;</span>
<span class="line-removed">11788     xpctxt-&gt;doc = oldContextDoc;</span>
11789     xpctxt-&gt;contextSize = oldcs;
11790     xpctxt-&gt;proximityPosition = oldpp;
<span class="line-removed">11791     return(newContextSize);</span>
<span class="line-removed">11792     }</span>
<span class="line-removed">11793     return(contextSize);</span>
<span class="line-removed">11794 }</span>
<span class="line-removed">11795 </span>
<span class="line-removed">11796 static int</span>
<span class="line-removed">11797 xmlXPathCompOpEvalPositionalPredicate(xmlXPathParserContextPtr ctxt,</span>
<span class="line-removed">11798                       xmlXPathStepOpPtr op,</span>
<span class="line-removed">11799                       xmlNodeSetPtr set,</span>
<span class="line-removed">11800                       int contextSize,</span>
<span class="line-removed">11801                       int minPos,</span>
<span class="line-removed">11802                       int maxPos,</span>
<span class="line-removed">11803                       int hasNsNodes)</span>
<span class="line-removed">11804 {</span>
<span class="line-removed">11805     if (op-&gt;ch1 != -1) {</span>
<span class="line-removed">11806     xmlXPathCompExprPtr comp = ctxt-&gt;comp;</span>
<span class="line-removed">11807     if (comp-&gt;steps[op-&gt;ch1].op != XPATH_OP_PREDICATE) {</span>
<span class="line-removed">11808         /*</span>
<span class="line-removed">11809         * TODO: raise an internal error.</span>
<span class="line-removed">11810         */</span>
<span class="line-removed">11811     }</span>
<span class="line-removed">11812     contextSize = xmlXPathCompOpEvalPredicate(ctxt,</span>
<span class="line-removed">11813         &amp;comp-&gt;steps[op-&gt;ch1], set, contextSize, hasNsNodes);</span>
<span class="line-removed">11814     CHECK_ERROR0;</span>
<span class="line-removed">11815     if (contextSize &lt;= 0)</span>
<span class="line-removed">11816         return(0);</span>
<span class="line-removed">11817     }</span>
<span class="line-removed">11818     /*</span>
<span class="line-removed">11819     * Check if the node set contains a sufficient number of nodes for</span>
<span class="line-removed">11820     * the requested range.</span>
<span class="line-removed">11821     */</span>
<span class="line-removed">11822     if (contextSize &lt; minPos) {</span>
<span class="line-removed">11823     xmlXPathNodeSetClear(set, hasNsNodes);</span>
<span class="line-removed">11824     return(0);</span>
11825     }
<span class="line-removed">11826     if (op-&gt;ch2 == -1) {</span>
<span class="line-removed">11827     /*</span>
<span class="line-removed">11828     * TODO: Can this ever happen?</span>
<span class="line-removed">11829     */</span>
<span class="line-removed">11830     return (contextSize);</span>
<span class="line-removed">11831     } else {</span>
<span class="line-removed">11832     xmlDocPtr oldContextDoc;</span>
<span class="line-removed">11833         int oldcs, oldpp;</span>
<span class="line-removed">11834     int i, pos = 0, newContextSize = 0, contextPos = 0, res;</span>
<span class="line-removed">11835     xmlXPathStepOpPtr exprOp;</span>
<span class="line-removed">11836     xmlXPathObjectPtr contextObj = NULL, exprRes = NULL;</span>
<span class="line-removed">11837     xmlNodePtr oldContextNode, contextNode = NULL;</span>
<span class="line-removed">11838     xmlXPathContextPtr xpctxt = ctxt-&gt;context;</span>
<span class="line-removed">11839         int frame;</span>
11840 
11841 #ifdef LIBXML_XPTR_ENABLED
<span class="line-modified">11842         /*</span>
<span class="line-modified">11843         * URGENT TODO: Check the following:</span>
<span class="line-modified">11844         *  We don&#39;t expect location sets if evaluating prediates, right?</span>
<span class="line-modified">11845         *  Only filters should expect location sets, right?</span>







11846     */
<span class="line-modified">11847 #endif /* LIBXML_XPTR_ENABLED */</span>











11848 
<span class="line-modified">11849     /*</span>
<span class="line-modified">11850     * Save old context.</span>
<span class="line-modified">11851     */</span>
<span class="line-modified">11852     oldContextNode = xpctxt-&gt;node;</span>
<span class="line-modified">11853     oldContextDoc = xpctxt-&gt;doc;</span>

11854         oldcs = xpctxt-&gt;contextSize;
11855         oldpp = xpctxt-&gt;proximityPosition;
<span class="line-modified">11856     /*</span>
<span class="line-removed">11857     * Get the expression of this predicate.</span>
<span class="line-removed">11858     */</span>
<span class="line-removed">11859     exprOp = &amp;ctxt-&gt;comp-&gt;steps[op-&gt;ch2];</span>
<span class="line-removed">11860     for (i = 0; i &lt; set-&gt;nodeNr; i++) {</span>
<span class="line-removed">11861             xmlXPathObjectPtr tmp;</span>
11862 
<span class="line-modified">11863         if (set-&gt;nodeTab[i] == NULL)</span>
<span class="line-modified">11864         continue;</span>



11865 
<span class="line-removed">11866         contextNode = set-&gt;nodeTab[i];</span>
11867         xpctxt-&gt;node = contextNode;
<span class="line-modified">11868         xpctxt-&gt;contextSize = contextSize;</span>
<span class="line-removed">11869         xpctxt-&gt;proximityPosition = ++contextPos;</span>
11870 
11871         /*
<span class="line-removed">11872         * Initialize the new set.</span>
11873         * Also set the xpath document in case things like
<span class="line-modified">11874         * key() evaluation are attempted on the predicate</span>


11875         */
11876         if ((contextNode-&gt;type != XML_NAMESPACE_DECL) &amp;&amp;
11877         (contextNode-&gt;doc != NULL))
11878         xpctxt-&gt;doc = contextNode-&gt;doc;
<span class="line-modified">11879         /*</span>
<span class="line-modified">11880         * Evaluate the predicate expression with 1 context node</span>
<span class="line-modified">11881         * at a time; this node is packaged into a node set; this</span>
<span class="line-modified">11882         * node set is handed over to the evaluation mechanism.</span>
<span class="line-modified">11883         */</span>
<span class="line-modified">11884         if (contextObj == NULL)</span>
<span class="line-modified">11885         contextObj = xmlXPathCacheNewNodeSet(xpctxt, contextNode);</span>
<span class="line-modified">11886         else {</span>
<span class="line-modified">11887         if (xmlXPathNodeSetAddUnique(contextObj-&gt;nodesetval,</span>
<span class="line-removed">11888             contextNode) &lt; 0) {</span>
<span class="line-removed">11889             ctxt-&gt;error = XPATH_MEMORY_ERROR;</span>
<span class="line-removed">11890             goto evaluation_exit;</span>
11891         }





11892         }
11893 
<span class="line-modified">11894         valuePush(ctxt, contextObj);</span>
<span class="line-modified">11895             frame = xmlXPathSetFrame(ctxt);</span>
<span class="line-modified">11896         res = xmlXPathCompOpEvalToBoolean(ctxt, exprOp, 1);</span>
<span class="line-modified">11897             xmlXPathPopFrame(ctxt, frame);</span>
<span class="line-modified">11898             tmp = valuePop(ctxt);</span>

11899 
<span class="line-modified">11900         if ((ctxt-&gt;error != XPATH_EXPRESSION_OK) || (res == -1)) {</span>
<span class="line-modified">11901                 while (tmp != contextObj) {</span>
<span class="line-modified">11902                     /*</span>
<span class="line-modified">11903                      * Free up the result</span>
<span class="line-modified">11904                      * then pop off contextObj, which will be freed later</span>
<span class="line-removed">11905                      */</span>
<span class="line-removed">11906                     xmlXPathReleaseObject(xpctxt, tmp);</span>
<span class="line-removed">11907                     tmp = valuePop(ctxt);</span>
<span class="line-removed">11908                 }</span>
<span class="line-removed">11909         goto evaluation_error;</span>
11910         }
<span class="line-modified">11911             /* push the result back onto the stack */</span>
<span class="line-modified">11912             valuePush(ctxt, tmp);</span>
11913 
<span class="line-modified">11914         if (res)</span>
<span class="line-modified">11915         pos++;</span>

11916 
<span class="line-modified">11917         if (res &amp;&amp; (pos &gt;= minPos) &amp;&amp; (pos &lt;= maxPos)) {</span>
<span class="line-modified">11918         /*</span>
<span class="line-modified">11919         * Fits in the requested range.</span>
<span class="line-modified">11920         */</span>
<span class="line-modified">11921         newContextSize++;</span>
<span class="line-modified">11922         if (minPos == maxPos) {</span>
<span class="line-modified">11923             /*</span>
<span class="line-modified">11924             * Only 1 node was requested.</span>
<span class="line-modified">11925             */</span>
<span class="line-modified">11926             if (contextNode-&gt;type == XML_NAMESPACE_DECL) {</span>
<span class="line-modified">11927             /*</span>
<span class="line-modified">11928             * As always: take care of those nasty</span>
<span class="line-modified">11929             * namespace nodes.</span>
<span class="line-modified">11930             */</span>
<span class="line-removed">11931             set-&gt;nodeTab[i] = NULL;</span>
<span class="line-removed">11932             }</span>
<span class="line-removed">11933             xmlXPathNodeSetClear(set, hasNsNodes);</span>
<span class="line-removed">11934             set-&gt;nodeNr = 1;</span>
<span class="line-removed">11935             set-&gt;nodeTab[0] = contextNode;</span>
<span class="line-removed">11936             goto evaluation_exit;</span>
<span class="line-removed">11937         }</span>
<span class="line-removed">11938         if (pos == maxPos) {</span>
<span class="line-removed">11939             /*</span>
<span class="line-removed">11940             * We are done.</span>
<span class="line-removed">11941             */</span>
<span class="line-removed">11942             xmlXPathNodeSetClearFromPos(set, i +1, hasNsNodes);</span>
<span class="line-removed">11943             goto evaluation_exit;</span>
<span class="line-removed">11944         }</span>
11945         } else {
<span class="line-modified">11946         /*</span>
<span class="line-modified">11947         * Remove the entry from the initial node set.</span>
<span class="line-removed">11948         */</span>
<span class="line-removed">11949         set-&gt;nodeTab[i] = NULL;</span>
<span class="line-removed">11950         if (contextNode-&gt;type == XML_NAMESPACE_DECL)</span>
<span class="line-removed">11951             xmlXPathNodeSetFreeNs((xmlNsPtr) contextNode);</span>
11952         }
<span class="line-removed">11953         if (exprRes != NULL) {</span>
<span class="line-removed">11954         xmlXPathReleaseObject(ctxt-&gt;context, exprRes);</span>
<span class="line-removed">11955         exprRes = NULL;</span>
11956         }
<span class="line-modified">11957         if (ctxt-&gt;value == contextObj) {</span>
<span class="line-modified">11958         /*</span>
<span class="line-modified">11959         * Don&#39;t free the temporary XPath object holding the</span>
<span class="line-modified">11960         * context node, in order to avoid massive recreation</span>
<span class="line-modified">11961         * inside this loop.</span>
















11962         */
<span class="line-modified">11963         valuePop(ctxt);</span>
<span class="line-modified">11964         xmlXPathNodeSetClear(contextObj-&gt;nodesetval, hasNsNodes);</span>
<span class="line-modified">11965         } else {</span>






11966         /*
<span class="line-modified">11967         * The object was lost in the evaluation machinery.</span>
<span class="line-removed">11968         * Can this happen? Maybe in case of internal-errors.</span>
11969         */
<span class="line-modified">11970         contextObj = NULL;</span>
<span class="line-modified">11971         }</span>










11972     }
<span class="line-removed">11973     goto evaluation_exit;</span>
11974 
<span class="line-modified">11975 evaluation_error:</span>
<span class="line-modified">11976     xmlXPathNodeSetClear(set, hasNsNodes);</span>
<span class="line-removed">11977     newContextSize = 0;</span>
<span class="line-removed">11978 </span>
<span class="line-removed">11979 evaluation_exit:</span>
<span class="line-removed">11980     if (contextObj != NULL) {</span>
<span class="line-removed">11981         if (ctxt-&gt;value == contextObj)</span>
<span class="line-removed">11982         valuePop(ctxt);</span>
<span class="line-removed">11983         xmlXPathReleaseObject(xpctxt, contextObj);</span>
<span class="line-removed">11984     }</span>
<span class="line-removed">11985     if (exprRes != NULL)</span>
<span class="line-removed">11986         xmlXPathReleaseObject(ctxt-&gt;context, exprRes);</span>
<span class="line-removed">11987     /*</span>
<span class="line-removed">11988     * Reset/invalidate the context.</span>
<span class="line-removed">11989     */</span>
<span class="line-removed">11990     xpctxt-&gt;node = oldContextNode;</span>
<span class="line-removed">11991     xpctxt-&gt;doc = oldContextDoc;</span>
<span class="line-removed">11992     xpctxt-&gt;contextSize = oldcs;</span>
<span class="line-removed">11993     xpctxt-&gt;proximityPosition = oldpp;</span>
<span class="line-removed">11994     return(newContextSize);</span>
<span class="line-removed">11995     }</span>
<span class="line-removed">11996     return(contextSize);</span>
11997 }
11998 
11999 static int
12000 xmlXPathIsPositionalPredicate(xmlXPathParserContextPtr ctxt,
12001                 xmlXPathStepOpPtr op,
12002                 int *maxPos)
12003 {
12004 
12005     xmlXPathStepOpPtr exprOp;
12006 
12007     /*
12008     * BIG NOTE: This is not intended for XPATH_OP_FILTER yet!
12009     */
12010 
12011     /*
12012     * If not -1, then ch1 will point to:
12013     * 1) For predicates (XPATH_OP_PREDICATE):
12014     *    - an inner predicate operator
12015     * 2) For filters (XPATH_OP_FILTER):
<span class="line-modified">12016     *    - an inner filter operater OR</span>
12017     *    - an expression selecting the node set.
12018     *      E.g. &quot;key(&#39;a&#39;, &#39;b&#39;)&quot; or &quot;(//foo | //bar)&quot;.
12019     */
12020     if ((op-&gt;op != XPATH_OP_PREDICATE) &amp;&amp; (op-&gt;op != XPATH_OP_FILTER))
12021     return(0);
12022 
12023     if (op-&gt;ch2 != -1) {
12024     exprOp = &amp;ctxt-&gt;comp-&gt;steps[op-&gt;ch2];
12025     } else
12026     return(0);
12027 
12028     if ((exprOp != NULL) &amp;&amp;
12029     (exprOp-&gt;op == XPATH_OP_VALUE) &amp;&amp;
12030     (exprOp-&gt;value4 != NULL) &amp;&amp;
12031     (((xmlXPathObjectPtr) exprOp-&gt;value4)-&gt;type == XPATH_NUMBER))
12032     {
12033         double floatval = ((xmlXPathObjectPtr) exprOp-&gt;value4)-&gt;floatval;
12034 
12035     /*
12036     * We have a &quot;[n]&quot; predicate here.
</pre>
<hr />
<pre>
12094     int nbMatches = 0, prevMatches = 0;
12095 #endif
12096     int total = 0, hasNsNodes = 0;
12097     /* The popped object holding the context nodes */
12098     xmlXPathObjectPtr obj;
12099     /* The set of context nodes for the node tests */
12100     xmlNodeSetPtr contextSeq;
12101     int contextIdx;
12102     xmlNodePtr contextNode;
12103     /* The final resulting node set wrt to all context nodes */
12104     xmlNodeSetPtr outSeq;
12105     /*
12106     * The temporary resulting node set wrt 1 context node.
12107     * Used to feed predicate evaluation.
12108     */
12109     xmlNodeSetPtr seq;
12110     xmlNodePtr cur;
12111     /* First predicate operator */
12112     xmlXPathStepOpPtr predOp;
12113     int maxPos; /* The requested position() (when a &quot;[n]&quot; predicate) */
<span class="line-modified">12114     int hasPredicateRange, hasAxisRange, pos, size, newSize;</span>
12115     int breakOnFirstHit;
12116 
12117     xmlXPathTraversalFunction next = NULL;
12118     int (*addNode) (xmlNodeSetPtr, xmlNodePtr);
12119     xmlXPathNodeSetMergeFunction mergeAndClear;
12120     xmlNodePtr oldContextNode;
12121     xmlXPathContextPtr xpctxt = ctxt-&gt;context;
12122 
12123 
12124     CHECK_TYPE0(XPATH_NODESET);
12125     obj = valuePop(ctxt);
12126     /*
12127     * Setup namespaces.
12128     */
12129     if (prefix != NULL) {
12130         URI = xmlXPathNsLookup(xpctxt, prefix);
12131         if (URI == NULL) {
12132         xmlXPathReleaseObject(xpctxt, obj);
12133             XP_ERROR0(XPATH_UNDEF_PREFIX_ERROR);
12134     }
</pre>
<hr />
<pre>
12287      *
12288      * A node test * is true for any node of the
12289      * principal node type. For example, child::* will
12290      * select all element children of the context node
12291      */
12292     oldContextNode = xpctxt-&gt;node;
12293     addNode = xmlXPathNodeSetAddUnique;
12294     outSeq = NULL;
12295     seq = NULL;
12296     contextNode = NULL;
12297     contextIdx = 0;
12298 
12299 
12300     while (((contextIdx &lt; contextSeq-&gt;nodeNr) || (contextNode != NULL)) &amp;&amp;
12301            (ctxt-&gt;error == XPATH_EXPRESSION_OK)) {
12302     xpctxt-&gt;node = contextSeq-&gt;nodeTab[contextIdx++];
12303 
12304     if (seq == NULL) {
12305         seq = xmlXPathNodeSetCreate(NULL);
12306         if (seq == NULL) {

12307         total = 0;
12308         goto error;
12309         }
12310     }
12311     /*
12312     * Traverse the axis and test the nodes.
12313     */
12314     pos = 0;
12315     cur = NULL;
12316     hasNsNodes = 0;
12317         do {



12318             cur = next(ctxt, cur);
12319             if (cur == NULL)
12320                 break;
12321 
12322         /*
12323         * QUESTION TODO: What does the &quot;first&quot; and &quot;last&quot; stuff do?
12324         */
12325             if ((first != NULL) &amp;&amp; (*first != NULL)) {
12326         if (*first == cur)
12327             break;
12328         if (((total % 256) == 0) &amp;&amp;
12329 #ifdef XP_OPTIMIZED_NON_ELEM_COMPARISON
12330             (xmlXPathCmpNodesExt(*first, cur) &gt;= 0))
12331 #else
12332             (xmlXPathCmpNodes(*first, cur) &gt;= 0))
12333 #endif
12334         {
12335             break;
12336         }
12337         }
</pre>
<hr />
<pre>
12505                         default:
12506                             break;
12507                     }
12508                     break;
12509         } /* switch(test) */
12510         } while ((cur != NULL) &amp;&amp; (ctxt-&gt;error == XPATH_EXPRESSION_OK));
12511 
12512     goto apply_predicates;
12513 
12514 axis_range_end: /* ----------------------------------------------------- */
12515     /*
12516     * We have a &quot;/foo[n]&quot;, and position() = n was reached.
12517     * Note that we can have as well &quot;/foo/::parent::foo[1]&quot;, so
12518     * a duplicate-aware merge is still needed.
12519     * Merge with the result.
12520     */
12521     if (outSeq == NULL) {
12522         outSeq = seq;
12523         seq = NULL;
12524     } else
<span class="line-modified">12525         outSeq = mergeAndClear(outSeq, seq, 0);</span>

12526     /*
12527     * Break if only a true/false result was requested.
12528     */
12529     if (toBool)
12530         break;
12531     continue;
12532 
12533 first_hit: /* ---------------------------------------------------------- */
12534     /*
12535     * Break if only a true/false result was requested and
12536     * no predicates existed and a node test succeeded.
12537     */
12538     if (outSeq == NULL) {
12539         outSeq = seq;
12540         seq = NULL;
12541     } else
<span class="line-modified">12542         outSeq = mergeAndClear(outSeq, seq, 0);</span>

12543     break;
12544 
12545 #ifdef DEBUG_STEP
12546     if (seq != NULL)
12547         nbMatches += seq-&gt;nodeNr;
12548 #endif
12549 
12550 apply_predicates: /* --------------------------------------------------- */
12551         if (ctxt-&gt;error != XPATH_EXPRESSION_OK)
12552         goto error;
12553 
12554         /*
12555     * Apply predicates.
12556     */
12557         if ((predOp != NULL) &amp;&amp; (seq-&gt;nodeNr &gt; 0)) {
12558         /*
12559         * E.g. when we have a &quot;/foo[some expression][n]&quot;.
12560         */
12561         /*
12562         * QUESTION TODO: The old predicate evaluation took into
</pre>
<hr />
<pre>
12566         *  All what I learned now from the evaluation semantics
12567         *  does not indicate that a location-set will be processed
12568         *  here, so this looks OK.
12569         */
12570         /*
12571         * Iterate over all predicates, starting with the outermost
12572         * predicate.
12573         * TODO: Problem: we cannot execute the inner predicates first
12574         *  since we cannot go back *up* the operator tree!
12575         *  Options we have:
12576         *  1) Use of recursive functions (like is it currently done
12577         *     via xmlXPathCompOpEval())
12578         *  2) Add a predicate evaluation information stack to the
12579         *     context struct
12580         *  3) Change the way the operators are linked; we need a
12581         *     &quot;parent&quot; field on xmlXPathStepOp
12582         *
12583         * For the moment, I&#39;ll try to solve this with a recursive
12584         * function: xmlXPathCompOpEvalPredicate().
12585         */
<span class="line-removed">12586         size = seq-&gt;nodeNr;</span>
12587         if (hasPredicateRange != 0)
<span class="line-modified">12588         newSize = xmlXPathCompOpEvalPositionalPredicate(ctxt,</span>
<span class="line-modified">12589             predOp, seq, size, maxPos, maxPos, hasNsNodes);</span>
12590         else
<span class="line-modified">12591         newSize = xmlXPathCompOpEvalPredicate(ctxt,</span>
<span class="line-modified">12592             predOp, seq, size, hasNsNodes);</span>
12593 
12594         if (ctxt-&gt;error != XPATH_EXPRESSION_OK) {
12595         total = 0;
12596         goto error;
12597         }
<span class="line-removed">12598         /*</span>
<span class="line-removed">12599         * Add the filtered set of nodes to the result node set.</span>
<span class="line-removed">12600         */</span>
<span class="line-removed">12601         if (newSize == 0) {</span>
<span class="line-removed">12602         /*</span>
<span class="line-removed">12603         * The predicates filtered all nodes out.</span>
<span class="line-removed">12604         */</span>
<span class="line-removed">12605         xmlXPathNodeSetClear(seq, hasNsNodes);</span>
<span class="line-removed">12606         } else if (seq-&gt;nodeNr &gt; 0) {</span>
<span class="line-removed">12607         /*</span>
<span class="line-removed">12608         * Add to result set.</span>
<span class="line-removed">12609         */</span>
<span class="line-removed">12610         if (outSeq == NULL) {</span>
<span class="line-removed">12611             if (size != newSize) {</span>
<span class="line-removed">12612             /*</span>
<span class="line-removed">12613             * We need to merge and clear here, since</span>
<span class="line-removed">12614             * the sequence will contained NULLed entries.</span>
<span class="line-removed">12615             */</span>
<span class="line-removed">12616             outSeq = mergeAndClear(NULL, seq, 1);</span>
<span class="line-removed">12617             } else {</span>
<span class="line-removed">12618             outSeq = seq;</span>
<span class="line-removed">12619             seq = NULL;</span>
<span class="line-removed">12620             }</span>
<span class="line-removed">12621         } else</span>
<span class="line-removed">12622             outSeq = mergeAndClear(outSeq, seq,</span>
<span class="line-removed">12623             (size != newSize) ? 1: 0);</span>
<span class="line-removed">12624         /*</span>
<span class="line-removed">12625         * Break if only a true/false result was requested.</span>
<span class="line-removed">12626         */</span>
<span class="line-removed">12627         if (toBool)</span>
<span class="line-removed">12628             break;</span>
12629         }
<span class="line-modified">12630         } else if (seq-&gt;nodeNr &gt; 0) {</span>

12631         /*
12632         * Add to result set.
12633         */
12634         if (outSeq == NULL) {
12635         outSeq = seq;
12636         seq = NULL;
12637         } else {
<span class="line-modified">12638         outSeq = mergeAndClear(outSeq, seq, 0);</span>

12639         }



12640     }
12641     }
12642 
12643 error:
12644     if ((obj-&gt;boolval) &amp;&amp; (obj-&gt;user != NULL)) {
12645     /*
12646     * QUESTION TODO: What does this do and why?
12647     * TODO: Do we have to do this also for the &quot;error&quot;
12648     * cleanup further down?
12649     */
12650     ctxt-&gt;value-&gt;boolval = 1;
12651     ctxt-&gt;value-&gt;user = obj-&gt;user;
12652     obj-&gt;user = NULL;
12653     obj-&gt;boolval = 0;
12654     }
12655     xmlXPathReleaseObject(xpctxt, obj);
12656 
12657     /*
<span class="line-modified">12658     * Ensure we return at least an emtpy set.</span>
12659     */
12660     if (outSeq == NULL) {
12661     if ((seq != NULL) &amp;&amp; (seq-&gt;nodeNr == 0))
12662         outSeq = seq;
12663     else

12664         outSeq = xmlXPathNodeSetCreate(NULL);
<span class="line-removed">12665         /* XXX what if xmlXPathNodeSetCreate returned NULL here? */</span>
12666     }
12667     if ((seq != NULL) &amp;&amp; (seq != outSeq)) {
12668      xmlXPathFreeNodeSet(seq);
12669     }
12670     /*
12671     * Hand over the result. Better to push the set also in
12672     * case of errors.
12673     */
12674     valuePush(ctxt, xmlXPathCacheWrapNodeSet(xpctxt, outSeq));
12675     /*
12676     * Reset the context node.
12677     */
12678     xpctxt-&gt;node = oldContextNode;
12679     /*
12680     * When traversing the namespace axis in &quot;toBool&quot; mode, it&#39;s
12681     * possible that tmpNsList wasn&#39;t freed.
12682     */
12683     if (xpctxt-&gt;tmpNsList != NULL) {
12684         xmlFree(xpctxt-&gt;tmpNsList);
12685         xpctxt-&gt;tmpNsList = NULL;
</pre>
<hr />
<pre>
12701 /**
12702  * xmlXPathCompOpEvalFirst:
12703  * @ctxt:  the XPath parser context with the compiled expression
12704  * @op:  an XPath compiled operation
12705  * @first:  the first elem found so far
12706  *
12707  * Evaluate the Precompiled XPath operation searching only the first
12708  * element in document order
12709  *
12710  * Returns the number of examined objects.
12711  */
12712 static int
12713 xmlXPathCompOpEvalFirst(xmlXPathParserContextPtr ctxt,
12714                         xmlXPathStepOpPtr op, xmlNodePtr * first)
12715 {
12716     int total = 0, cur;
12717     xmlXPathCompExprPtr comp;
12718     xmlXPathObjectPtr arg1, arg2;
12719 
12720     CHECK_ERROR0;





12721     comp = ctxt-&gt;comp;
12722     switch (op-&gt;op) {
12723         case XPATH_OP_END:
<span class="line-modified">12724             return (0);</span>
12725         case XPATH_OP_UNION:
12726             total =
12727                 xmlXPathCompOpEvalFirst(ctxt, &amp;comp-&gt;steps[op-&gt;ch1],
12728                                         first);
12729         CHECK_ERROR0;
12730             if ((ctxt-&gt;value != NULL)
12731                 &amp;&amp; (ctxt-&gt;value-&gt;type == XPATH_NODESET)
12732                 &amp;&amp; (ctxt-&gt;value-&gt;nodesetval != NULL)
12733                 &amp;&amp; (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt;= 1)) {
12734                 /*
12735                  * limit tree traversing to first node in the result
12736                  */
12737         /*
<span class="line-modified">12738         * OPTIMIZE TODO: This implicitely sorts</span>
12739         *  the result, even if not needed. E.g. if the argument
12740         *  of the count() function, no sorting is needed.
12741         * OPTIMIZE TODO: How do we know if the node-list wasn&#39;t
<span class="line-modified">12742         *  aready sorted?</span>
12743         */
12744         if (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1)
12745             xmlXPathNodeSetSort(ctxt-&gt;value-&gt;nodesetval);
12746                 *first = ctxt-&gt;value-&gt;nodesetval-&gt;nodeTab[0];
12747             }
12748             cur =
12749                 xmlXPathCompOpEvalFirst(ctxt, &amp;comp-&gt;steps[op-&gt;ch2],
12750                                         first);
12751         CHECK_ERROR0;
12752 
12753             arg2 = valuePop(ctxt);
12754             arg1 = valuePop(ctxt);
12755             if ((arg1 == NULL) || (arg1-&gt;type != XPATH_NODESET) ||
12756                 (arg2 == NULL) || (arg2-&gt;type != XPATH_NODESET)) {
12757             xmlXPathReleaseObject(ctxt-&gt;context, arg1);
12758             xmlXPathReleaseObject(ctxt-&gt;context, arg2);
12759                 XP_ERROR0(XPATH_INVALID_TYPE);
12760             }











12761 

12762             arg1-&gt;nodesetval = xmlXPathNodeSetMerge(arg1-&gt;nodesetval,
12763                                                     arg2-&gt;nodesetval);
12764             valuePush(ctxt, arg1);
12765         xmlXPathReleaseObject(ctxt-&gt;context, arg2);
12766             /* optimizer */
12767         if (total &gt; cur)
12768         xmlXPathCompSwap(op);
<span class="line-modified">12769             return (total + cur);</span>

12770         case XPATH_OP_ROOT:
12771             xmlXPathRoot(ctxt);
<span class="line-modified">12772             return (0);</span>
12773         case XPATH_OP_NODE:
12774             if (op-&gt;ch1 != -1)
12775                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
12776         CHECK_ERROR0;
12777             if (op-&gt;ch2 != -1)
12778                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
12779         CHECK_ERROR0;
12780         valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt-&gt;context,
12781         ctxt-&gt;context-&gt;node));
<span class="line-modified">12782             return (total);</span>
12783         case XPATH_OP_COLLECT:{
12784                 if (op-&gt;ch1 == -1)
<span class="line-modified">12785                     return (total);</span>
12786 
12787                 total = xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
12788         CHECK_ERROR0;
12789 
12790                 total += xmlXPathNodeCollectAndTest(ctxt, op, first, NULL, 0);
<span class="line-modified">12791                 return (total);</span>
12792             }
12793         case XPATH_OP_VALUE:
12794             valuePush(ctxt,
12795                       xmlXPathCacheObjectCopy(ctxt-&gt;context,
12796             (xmlXPathObjectPtr) op-&gt;value4));
<span class="line-modified">12797             return (0);</span>
12798         case XPATH_OP_SORT:
12799             if (op-&gt;ch1 != -1)
12800                 total +=
12801                     xmlXPathCompOpEvalFirst(ctxt, &amp;comp-&gt;steps[op-&gt;ch1],
12802                                             first);
12803         CHECK_ERROR0;
12804             if ((ctxt-&gt;value != NULL)
12805                 &amp;&amp; (ctxt-&gt;value-&gt;type == XPATH_NODESET)
12806                 &amp;&amp; (ctxt-&gt;value-&gt;nodesetval != NULL)
12807         &amp;&amp; (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1))
12808                 xmlXPathNodeSetSort(ctxt-&gt;value-&gt;nodesetval);
<span class="line-modified">12809             return (total);</span>
12810 #ifdef XP_OPTIMIZED_FILTER_FIRST
12811     case XPATH_OP_FILTER:
12812                 total += xmlXPathCompOpEvalFilterFirst(ctxt, op, first);
<span class="line-modified">12813             return (total);</span>
12814 #endif
12815         default:
<span class="line-modified">12816             return (xmlXPathCompOpEval(ctxt, op));</span>

12817     }



12818 }
12819 
12820 /**
12821  * xmlXPathCompOpEvalLast:
12822  * @ctxt:  the XPath parser context with the compiled expression
12823  * @op:  an XPath compiled operation
12824  * @last:  the last elem found so far
12825  *
12826  * Evaluate the Precompiled XPath operation searching only the last
12827  * element in document order
12828  *
12829  * Returns the number of nodes traversed
12830  */
12831 static int
12832 xmlXPathCompOpEvalLast(xmlXPathParserContextPtr ctxt, xmlXPathStepOpPtr op,
12833                        xmlNodePtr * last)
12834 {
12835     int total = 0, cur;
12836     xmlXPathCompExprPtr comp;
12837     xmlXPathObjectPtr arg1, arg2;
12838 
12839     CHECK_ERROR0;





12840     comp = ctxt-&gt;comp;
12841     switch (op-&gt;op) {
12842         case XPATH_OP_END:
<span class="line-modified">12843             return (0);</span>
12844         case XPATH_OP_UNION:
12845             total =
12846                 xmlXPathCompOpEvalLast(ctxt, &amp;comp-&gt;steps[op-&gt;ch1], last);
12847         CHECK_ERROR0;
12848             if ((ctxt-&gt;value != NULL)
12849                 &amp;&amp; (ctxt-&gt;value-&gt;type == XPATH_NODESET)
12850                 &amp;&amp; (ctxt-&gt;value-&gt;nodesetval != NULL)
12851                 &amp;&amp; (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt;= 1)) {
12852                 /*
12853                  * limit tree traversing to first node in the result
12854                  */
12855         if (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1)
12856             xmlXPathNodeSetSort(ctxt-&gt;value-&gt;nodesetval);
12857                 *last =
12858                     ctxt-&gt;value-&gt;nodesetval-&gt;nodeTab[ctxt-&gt;value-&gt;
12859                                                      nodesetval-&gt;nodeNr -
12860                                                      1];
12861             }
12862             cur =
12863                 xmlXPathCompOpEvalLast(ctxt, &amp;comp-&gt;steps[op-&gt;ch2], last);
12864         CHECK_ERROR0;
12865             if ((ctxt-&gt;value != NULL)
12866                 &amp;&amp; (ctxt-&gt;value-&gt;type == XPATH_NODESET)
12867                 &amp;&amp; (ctxt-&gt;value-&gt;nodesetval != NULL)
12868                 &amp;&amp; (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt;= 1)) { /* TODO: NOP ? */
12869             }
12870 
12871             arg2 = valuePop(ctxt);
12872             arg1 = valuePop(ctxt);
12873             if ((arg1 == NULL) || (arg1-&gt;type != XPATH_NODESET) ||
12874                 (arg2 == NULL) || (arg2-&gt;type != XPATH_NODESET)) {
12875             xmlXPathReleaseObject(ctxt-&gt;context, arg1);
12876             xmlXPathReleaseObject(ctxt-&gt;context, arg2);
12877                 XP_ERROR0(XPATH_INVALID_TYPE);
12878             }











12879 

12880             arg1-&gt;nodesetval = xmlXPathNodeSetMerge(arg1-&gt;nodesetval,
12881                                                     arg2-&gt;nodesetval);
12882             valuePush(ctxt, arg1);
12883         xmlXPathReleaseObject(ctxt-&gt;context, arg2);
12884             /* optimizer */
12885         if (total &gt; cur)
12886         xmlXPathCompSwap(op);
<span class="line-modified">12887             return (total + cur);</span>

12888         case XPATH_OP_ROOT:
12889             xmlXPathRoot(ctxt);
<span class="line-modified">12890             return (0);</span>
12891         case XPATH_OP_NODE:
12892             if (op-&gt;ch1 != -1)
12893                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
12894         CHECK_ERROR0;
12895             if (op-&gt;ch2 != -1)
12896                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
12897         CHECK_ERROR0;
12898         valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt-&gt;context,
12899         ctxt-&gt;context-&gt;node));
<span class="line-modified">12900             return (total);</span>
12901         case XPATH_OP_COLLECT:{
12902                 if (op-&gt;ch1 == -1)
<span class="line-modified">12903                     return (0);</span>
12904 
12905                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
12906         CHECK_ERROR0;
12907 
12908                 total += xmlXPathNodeCollectAndTest(ctxt, op, NULL, last, 0);
<span class="line-modified">12909                 return (total);</span>
12910             }
12911         case XPATH_OP_VALUE:
12912             valuePush(ctxt,
12913                       xmlXPathCacheObjectCopy(ctxt-&gt;context,
12914             (xmlXPathObjectPtr) op-&gt;value4));
<span class="line-modified">12915             return (0);</span>
12916         case XPATH_OP_SORT:
12917             if (op-&gt;ch1 != -1)
12918                 total +=
12919                     xmlXPathCompOpEvalLast(ctxt, &amp;comp-&gt;steps[op-&gt;ch1],
12920                                            last);
12921         CHECK_ERROR0;
12922             if ((ctxt-&gt;value != NULL)
12923                 &amp;&amp; (ctxt-&gt;value-&gt;type == XPATH_NODESET)
12924                 &amp;&amp; (ctxt-&gt;value-&gt;nodesetval != NULL)
12925         &amp;&amp; (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1))
12926                 xmlXPathNodeSetSort(ctxt-&gt;value-&gt;nodesetval);
<span class="line-modified">12927             return (total);</span>
12928         default:
<span class="line-modified">12929             return (xmlXPathCompOpEval(ctxt, op));</span>

12930     }



12931 }
12932 
12933 #ifdef XP_OPTIMIZED_FILTER_FIRST
12934 static int
12935 xmlXPathCompOpEvalFilterFirst(xmlXPathParserContextPtr ctxt,
12936                   xmlXPathStepOpPtr op, xmlNodePtr * first)
12937 {
12938     int total = 0;
12939     xmlXPathCompExprPtr comp;
<span class="line-modified">12940     xmlXPathObjectPtr res;</span>
<span class="line-removed">12941     xmlXPathObjectPtr obj;</span>
<span class="line-removed">12942     xmlNodeSetPtr oldset;</span>
<span class="line-removed">12943     xmlNodePtr oldnode;</span>
<span class="line-removed">12944     xmlDocPtr oldDoc;</span>
<span class="line-removed">12945     int oldcs, oldpp;</span>
<span class="line-removed">12946     int i;</span>
12947 
12948     CHECK_ERROR0;
12949     comp = ctxt-&gt;comp;
12950     /*
12951     * Optimization for ()[last()] selection i.e. the last elem
12952     */
12953     if ((op-&gt;ch1 != -1) &amp;&amp; (op-&gt;ch2 != -1) &amp;&amp;
12954     (comp-&gt;steps[op-&gt;ch1].op == XPATH_OP_SORT) &amp;&amp;
12955     (comp-&gt;steps[op-&gt;ch2].op == XPATH_OP_SORT)) {
12956     int f = comp-&gt;steps[op-&gt;ch2].ch1;
12957 
12958     if ((f != -1) &amp;&amp;
12959         (comp-&gt;steps[f].op == XPATH_OP_FUNCTION) &amp;&amp;
12960         (comp-&gt;steps[f].value5 == NULL) &amp;&amp;
12961         (comp-&gt;steps[f].value == 0) &amp;&amp;
12962         (comp-&gt;steps[f].value4 != NULL) &amp;&amp;
12963         (xmlStrEqual
12964         (comp-&gt;steps[f].value4, BAD_CAST &quot;last&quot;))) {
12965         xmlNodePtr last = NULL;
12966 
</pre>
<hr />
<pre>
12977         (ctxt-&gt;value-&gt;type == XPATH_NODESET) &amp;&amp;
12978         (ctxt-&gt;value-&gt;nodesetval != NULL) &amp;&amp;
12979         (ctxt-&gt;value-&gt;nodesetval-&gt;nodeTab != NULL) &amp;&amp;
12980         (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1)) {
12981                 xmlXPathNodeSetKeepLast(ctxt-&gt;value-&gt;nodesetval);
12982         *first = *(ctxt-&gt;value-&gt;nodesetval-&gt;nodeTab);
12983         }
12984         return (total);
12985     }
12986     }
12987 
12988     if (op-&gt;ch1 != -1)
12989     total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
12990     CHECK_ERROR0;
12991     if (op-&gt;ch2 == -1)
12992     return (total);
12993     if (ctxt-&gt;value == NULL)
12994     return (total);
12995 
12996 #ifdef LIBXML_XPTR_ENABLED
<span class="line-modified">12997     /*</span>
12998     * Hum are we filtering the result of an XPointer expression
<span class="line-modified">12999     */</span>
13000     if (ctxt-&gt;value-&gt;type == XPATH_LOCATIONSET) {
<span class="line-modified">13001     xmlXPathObjectPtr tmp = NULL;</span>
<span class="line-removed">13002     xmlLocationSetPtr newlocset = NULL;</span>
<span class="line-removed">13003     xmlLocationSetPtr oldlocset;</span>
<span class="line-removed">13004 </span>
<span class="line-removed">13005     /*</span>
<span class="line-removed">13006     * Extract the old locset, and then evaluate the result of the</span>
<span class="line-removed">13007     * expression for all the element in the locset. use it to grow</span>
<span class="line-removed">13008     * up a new locset.</span>
<span class="line-removed">13009     */</span>
<span class="line-removed">13010     CHECK_TYPE0(XPATH_LOCATIONSET);</span>
<span class="line-removed">13011 </span>
<span class="line-removed">13012     if ((ctxt-&gt;value-&gt;user == NULL) ||</span>
<span class="line-removed">13013             (((xmlLocationSetPtr) ctxt-&gt;value-&gt;user)-&gt;locNr == 0))</span>
<span class="line-removed">13014         return (total);</span>
13015 
<span class="line-modified">13016     obj = valuePop(ctxt);</span>
<span class="line-modified">13017     oldlocset = obj-&gt;user;</span>
<span class="line-modified">13018         oldnode = ctxt-&gt;context-&gt;node;</span>
<span class="line-modified">13019         oldcs = ctxt-&gt;context-&gt;contextSize;</span>
<span class="line-removed">13020         oldpp = ctxt-&gt;context-&gt;proximityPosition;</span>
<span class="line-removed">13021 </span>
<span class="line-removed">13022     newlocset = xmlXPtrLocationSetCreate(NULL);</span>
<span class="line-removed">13023 </span>
<span class="line-removed">13024     for (i = 0; i &lt; oldlocset-&gt;locNr; i++) {</span>
<span class="line-removed">13025         /*</span>
<span class="line-removed">13026         * Run the evaluation with a node list made of a</span>
<span class="line-removed">13027         * single item in the nodelocset.</span>
<span class="line-removed">13028         */</span>
<span class="line-removed">13029         ctxt-&gt;context-&gt;node = oldlocset-&gt;locTab[i]-&gt;user;</span>
<span class="line-removed">13030         ctxt-&gt;context-&gt;contextSize = oldlocset-&gt;locNr;</span>
<span class="line-removed">13031         ctxt-&gt;context-&gt;proximityPosition = i + 1;</span>
<span class="line-removed">13032         if (tmp == NULL) {</span>
<span class="line-removed">13033         tmp = xmlXPathCacheNewNodeSet(ctxt-&gt;context,</span>
<span class="line-removed">13034             ctxt-&gt;context-&gt;node);</span>
<span class="line-removed">13035         } else {</span>
<span class="line-removed">13036         if (xmlXPathNodeSetAddUnique(tmp-&gt;nodesetval,</span>
<span class="line-removed">13037                                      ctxt-&gt;context-&gt;node) &lt; 0) {</span>
<span class="line-removed">13038             ctxt-&gt;error = XPATH_MEMORY_ERROR;</span>
<span class="line-removed">13039         }</span>
<span class="line-removed">13040         }</span>
<span class="line-removed">13041         valuePush(ctxt, tmp);</span>
<span class="line-removed">13042         if (op-&gt;ch2 != -1)</span>
<span class="line-removed">13043         total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);</span>
<span class="line-removed">13044         if (ctxt-&gt;error != XPATH_EXPRESSION_OK) {</span>
<span class="line-removed">13045                 xmlXPtrFreeLocationSet(newlocset);</span>
<span class="line-removed">13046                 goto xptr_error;</span>
<span class="line-removed">13047         }</span>
<span class="line-removed">13048         /*</span>
<span class="line-removed">13049         * The result of the evaluation need to be tested to</span>
<span class="line-removed">13050         * decided whether the filter succeeded or not</span>
<span class="line-removed">13051         */</span>
<span class="line-removed">13052         res = valuePop(ctxt);</span>
<span class="line-removed">13053         if (xmlXPathEvaluatePredicateResult(ctxt, res)) {</span>
<span class="line-removed">13054         xmlXPtrLocationSetAdd(newlocset,</span>
<span class="line-removed">13055             xmlXPathCacheObjectCopy(ctxt-&gt;context,</span>
<span class="line-removed">13056             oldlocset-&gt;locTab[i]));</span>
<span class="line-removed">13057         }</span>
<span class="line-removed">13058         /*</span>
<span class="line-removed">13059         * Cleanup</span>
<span class="line-removed">13060         */</span>
<span class="line-removed">13061         if (res != NULL) {</span>
<span class="line-removed">13062         xmlXPathReleaseObject(ctxt-&gt;context, res);</span>
<span class="line-removed">13063         }</span>
<span class="line-removed">13064         if (ctxt-&gt;value == tmp) {</span>
<span class="line-removed">13065         valuePop(ctxt);</span>
<span class="line-removed">13066         xmlXPathNodeSetClear(tmp-&gt;nodesetval, 1);</span>
<span class="line-removed">13067         /*</span>
<span class="line-removed">13068         * REVISIT TODO: Don&#39;t create a temporary nodeset</span>
<span class="line-removed">13069         * for everly iteration.</span>
<span class="line-removed">13070         */</span>
<span class="line-removed">13071         /* OLD: xmlXPathFreeObject(res); */</span>
<span class="line-removed">13072         } else</span>
<span class="line-removed">13073         tmp = NULL;</span>
<span class="line-removed">13074         /*</span>
<span class="line-removed">13075         * Only put the first node in the result, then leave.</span>
<span class="line-removed">13076         */</span>
<span class="line-removed">13077         if (newlocset-&gt;locNr &gt; 0) {</span>
<span class="line-removed">13078         *first = (xmlNodePtr) oldlocset-&gt;locTab[i]-&gt;user;</span>
<span class="line-removed">13079         break;</span>
<span class="line-removed">13080         }</span>
<span class="line-removed">13081     }</span>
<span class="line-removed">13082     if (tmp != NULL) {</span>
<span class="line-removed">13083         xmlXPathReleaseObject(ctxt-&gt;context, tmp);</span>
13084     }
<span class="line-modified">13085     /*</span>
<span class="line-removed">13086     * The result is used as the new evaluation locset.</span>
<span class="line-removed">13087     */</span>
<span class="line-removed">13088     valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));</span>
<span class="line-removed">13089 xptr_error:</span>
<span class="line-removed">13090     xmlXPathReleaseObject(ctxt-&gt;context, obj);</span>
<span class="line-removed">13091     ctxt-&gt;context-&gt;node = oldnode;</span>
<span class="line-removed">13092     ctxt-&gt;context-&gt;contextSize = oldcs;</span>
<span class="line-removed">13093     ctxt-&gt;context-&gt;proximityPosition = oldpp;</span>
13094     return (total);
13095     }
13096 #endif /* LIBXML_XPTR_ENABLED */
13097 
<span class="line-removed">13098     /*</span>
<span class="line-removed">13099     * Extract the old set, and then evaluate the result of the</span>
<span class="line-removed">13100     * expression for all the element in the set. use it to grow</span>
<span class="line-removed">13101     * up a new set.</span>
<span class="line-removed">13102     */</span>
13103     CHECK_TYPE0(XPATH_NODESET);
<span class="line-modified">13104 </span>
<span class="line-modified">13105     if ((ctxt-&gt;value-&gt;nodesetval != NULL) &amp;&amp;</span>
<span class="line-modified">13106         (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr != 0)) {</span>
<span class="line-modified">13107     xmlNodeSetPtr newset;</span>
<span class="line-modified">13108     xmlXPathObjectPtr tmp = NULL;</span>
<span class="line-removed">13109 </span>
<span class="line-removed">13110         obj = valuePop(ctxt);</span>
<span class="line-removed">13111         oldset = obj-&gt;nodesetval;</span>
<span class="line-removed">13112         oldnode = ctxt-&gt;context-&gt;node;</span>
<span class="line-removed">13113         oldDoc = ctxt-&gt;context-&gt;doc;</span>
<span class="line-removed">13114         oldcs = ctxt-&gt;context-&gt;contextSize;</span>
<span class="line-removed">13115         oldpp = ctxt-&gt;context-&gt;proximityPosition;</span>
<span class="line-removed">13116 </span>
<span class="line-removed">13117     /*</span>
<span class="line-removed">13118     * Initialize the new set.</span>
<span class="line-removed">13119     * Also set the xpath document in case things like</span>
<span class="line-removed">13120     * key() evaluation are attempted on the predicate</span>
<span class="line-removed">13121     */</span>
<span class="line-removed">13122     newset = xmlXPathNodeSetCreate(NULL);</span>
<span class="line-removed">13123         /* XXX what if xmlXPathNodeSetCreate returned NULL? */</span>
<span class="line-removed">13124 </span>
<span class="line-removed">13125     for (i = 0; i &lt; oldset-&gt;nodeNr; i++) {</span>
<span class="line-removed">13126         /*</span>
<span class="line-removed">13127         * Run the evaluation with a node list made of</span>
<span class="line-removed">13128         * a single item in the nodeset.</span>
<span class="line-removed">13129         */</span>
<span class="line-removed">13130         ctxt-&gt;context-&gt;node = oldset-&gt;nodeTab[i];</span>
<span class="line-removed">13131         if ((oldset-&gt;nodeTab[i]-&gt;type != XML_NAMESPACE_DECL) &amp;&amp;</span>
<span class="line-removed">13132         (oldset-&gt;nodeTab[i]-&gt;doc != NULL))</span>
<span class="line-removed">13133         ctxt-&gt;context-&gt;doc = oldset-&gt;nodeTab[i]-&gt;doc;</span>
<span class="line-removed">13134         if (tmp == NULL) {</span>
<span class="line-removed">13135         tmp = xmlXPathCacheNewNodeSet(ctxt-&gt;context,</span>
<span class="line-removed">13136             ctxt-&gt;context-&gt;node);</span>
<span class="line-removed">13137         } else {</span>
<span class="line-removed">13138         if (xmlXPathNodeSetAddUnique(tmp-&gt;nodesetval,</span>
<span class="line-removed">13139                                      ctxt-&gt;context-&gt;node) &lt; 0) {</span>
<span class="line-removed">13140             ctxt-&gt;error = XPATH_MEMORY_ERROR;</span>
<span class="line-removed">13141         }</span>
<span class="line-removed">13142         }</span>
<span class="line-removed">13143         valuePush(ctxt, tmp);</span>
<span class="line-removed">13144         ctxt-&gt;context-&gt;contextSize = oldset-&gt;nodeNr;</span>
<span class="line-removed">13145         ctxt-&gt;context-&gt;proximityPosition = i + 1;</span>
<span class="line-removed">13146         if (op-&gt;ch2 != -1)</span>
<span class="line-removed">13147         total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);</span>
<span class="line-removed">13148         if (ctxt-&gt;error != XPATH_EXPRESSION_OK) {</span>
<span class="line-removed">13149         xmlXPathFreeNodeSet(newset);</span>
<span class="line-removed">13150                 goto error;</span>
<span class="line-removed">13151         }</span>
<span class="line-removed">13152         /*</span>
<span class="line-removed">13153         * The result of the evaluation needs to be tested to</span>
<span class="line-removed">13154         * decide whether the filter succeeded or not</span>
<span class="line-removed">13155         */</span>
<span class="line-removed">13156         res = valuePop(ctxt);</span>
<span class="line-removed">13157         if (xmlXPathEvaluatePredicateResult(ctxt, res)) {</span>
<span class="line-removed">13158         if (xmlXPathNodeSetAdd(newset, oldset-&gt;nodeTab[i]) &lt; 0)</span>
<span class="line-removed">13159             ctxt-&gt;error = XPATH_MEMORY_ERROR;</span>
<span class="line-removed">13160         }</span>
<span class="line-removed">13161         /*</span>
<span class="line-removed">13162         * Cleanup</span>
<span class="line-removed">13163         */</span>
<span class="line-removed">13164         if (res != NULL) {</span>
<span class="line-removed">13165         xmlXPathReleaseObject(ctxt-&gt;context, res);</span>
<span class="line-removed">13166         }</span>
<span class="line-removed">13167         if (ctxt-&gt;value == tmp) {</span>
<span class="line-removed">13168         valuePop(ctxt);</span>
<span class="line-removed">13169         /*</span>
<span class="line-removed">13170         * Don&#39;t free the temporary nodeset</span>
<span class="line-removed">13171         * in order to avoid massive recreation inside this</span>
<span class="line-removed">13172         * loop.</span>
<span class="line-removed">13173         */</span>
<span class="line-removed">13174         xmlXPathNodeSetClear(tmp-&gt;nodesetval, 1);</span>
<span class="line-removed">13175         } else</span>
<span class="line-removed">13176         tmp = NULL;</span>
<span class="line-removed">13177         /*</span>
<span class="line-removed">13178         * Only put the first node in the result, then leave.</span>
<span class="line-removed">13179         */</span>
<span class="line-removed">13180         if (newset-&gt;nodeNr &gt; 0) {</span>
<span class="line-removed">13181         *first = *(newset-&gt;nodeTab);</span>
<span class="line-removed">13182         break;</span>
<span class="line-removed">13183         }</span>
<span class="line-removed">13184     }</span>
<span class="line-removed">13185     if (tmp != NULL) {</span>
<span class="line-removed">13186         xmlXPathReleaseObject(ctxt-&gt;context, tmp);</span>
<span class="line-removed">13187     }</span>
<span class="line-removed">13188     /*</span>
<span class="line-removed">13189     * The result is used as the new evaluation set.</span>
<span class="line-removed">13190     */</span>
<span class="line-removed">13191     valuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt-&gt;context, newset));</span>
<span class="line-removed">13192 error:</span>
<span class="line-removed">13193     xmlXPathReleaseObject(ctxt-&gt;context, obj);</span>
<span class="line-removed">13194     ctxt-&gt;context-&gt;node = oldnode;</span>
<span class="line-removed">13195     ctxt-&gt;context-&gt;doc = oldDoc;</span>
<span class="line-removed">13196     ctxt-&gt;context-&gt;contextSize = oldcs;</span>
<span class="line-removed">13197     ctxt-&gt;context-&gt;proximityPosition = oldpp;</span>
13198     }

13199     return(total);
13200 }
13201 #endif /* XP_OPTIMIZED_FILTER_FIRST */
13202 
13203 /**
13204  * xmlXPathCompOpEval:
13205  * @ctxt:  the XPath parser context with the compiled expression
13206  * @op:  an XPath compiled operation
13207  *
13208  * Evaluate the Precompiled XPath operation
13209  * Returns the number of nodes traversed
13210  */
13211 static int
13212 xmlXPathCompOpEval(xmlXPathParserContextPtr ctxt, xmlXPathStepOpPtr op)
13213 {
13214     int total = 0;
13215     int equal, ret;
13216     xmlXPathCompExprPtr comp;
13217     xmlXPathObjectPtr arg1, arg2;
13218 
13219     CHECK_ERROR0;





13220     comp = ctxt-&gt;comp;
13221     switch (op-&gt;op) {
13222         case XPATH_OP_END:
<span class="line-modified">13223             return (0);</span>
13224         case XPATH_OP_AND:
13225             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13226         CHECK_ERROR0;
13227             xmlXPathBooleanFunction(ctxt, 1);
13228             if ((ctxt-&gt;value == NULL) || (ctxt-&gt;value-&gt;boolval == 0))
<span class="line-modified">13229                 return (total);</span>
13230             arg2 = valuePop(ctxt);
13231             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
13232         if (ctxt-&gt;error) {
13233         xmlXPathFreeObject(arg2);
<span class="line-modified">13234         return(0);</span>
13235         }
13236             xmlXPathBooleanFunction(ctxt, 1);
13237             if (ctxt-&gt;value != NULL)
13238                 ctxt-&gt;value-&gt;boolval &amp;= arg2-&gt;boolval;
13239         xmlXPathReleaseObject(ctxt-&gt;context, arg2);
<span class="line-modified">13240             return (total);</span>
13241         case XPATH_OP_OR:
13242             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13243         CHECK_ERROR0;
13244             xmlXPathBooleanFunction(ctxt, 1);
13245             if ((ctxt-&gt;value == NULL) || (ctxt-&gt;value-&gt;boolval == 1))
<span class="line-modified">13246                 return (total);</span>
13247             arg2 = valuePop(ctxt);
13248             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
13249         if (ctxt-&gt;error) {
13250         xmlXPathFreeObject(arg2);
<span class="line-modified">13251         return(0);</span>
13252         }
13253             xmlXPathBooleanFunction(ctxt, 1);
13254             if (ctxt-&gt;value != NULL)
13255                 ctxt-&gt;value-&gt;boolval |= arg2-&gt;boolval;
13256         xmlXPathReleaseObject(ctxt-&gt;context, arg2);
<span class="line-modified">13257             return (total);</span>
13258         case XPATH_OP_EQUAL:
13259             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13260         CHECK_ERROR0;
13261             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
13262         CHECK_ERROR0;
13263         if (op-&gt;value)
13264         equal = xmlXPathEqualValues(ctxt);
13265         else
13266         equal = xmlXPathNotEqualValues(ctxt);
13267         valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt-&gt;context, equal));
<span class="line-modified">13268             return (total);</span>
13269         case XPATH_OP_CMP:
13270             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13271         CHECK_ERROR0;
13272             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
13273         CHECK_ERROR0;
13274             ret = xmlXPathCompareValues(ctxt, op-&gt;value, op-&gt;value2);
13275         valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt-&gt;context, ret));
<span class="line-modified">13276             return (total);</span>
13277         case XPATH_OP_PLUS:
13278             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13279         CHECK_ERROR0;
13280             if (op-&gt;ch2 != -1) {
13281                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
13282         }
13283         CHECK_ERROR0;
13284             if (op-&gt;value == 0)
13285                 xmlXPathSubValues(ctxt);
13286             else if (op-&gt;value == 1)
13287                 xmlXPathAddValues(ctxt);
13288             else if (op-&gt;value == 2)
13289                 xmlXPathValueFlipSign(ctxt);
13290             else if (op-&gt;value == 3) {
13291                 CAST_TO_NUMBER;
13292                 CHECK_TYPE0(XPATH_NUMBER);
13293             }
<span class="line-modified">13294             return (total);</span>
13295         case XPATH_OP_MULT:
13296             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13297         CHECK_ERROR0;
13298             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
13299         CHECK_ERROR0;
13300             if (op-&gt;value == 0)
13301                 xmlXPathMultValues(ctxt);
13302             else if (op-&gt;value == 1)
13303                 xmlXPathDivValues(ctxt);
13304             else if (op-&gt;value == 2)
13305                 xmlXPathModValues(ctxt);
<span class="line-modified">13306             return (total);</span>
13307         case XPATH_OP_UNION:
13308             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13309         CHECK_ERROR0;
13310             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
13311         CHECK_ERROR0;
13312 
13313             arg2 = valuePop(ctxt);
13314             arg1 = valuePop(ctxt);
13315             if ((arg1 == NULL) || (arg1-&gt;type != XPATH_NODESET) ||
13316                 (arg2 == NULL) || (arg2-&gt;type != XPATH_NODESET)) {
13317             xmlXPathReleaseObject(ctxt-&gt;context, arg1);
13318             xmlXPathReleaseObject(ctxt-&gt;context, arg2);
13319                 XP_ERROR0(XPATH_INVALID_TYPE);
13320             }











13321 
13322         if ((arg1-&gt;nodesetval == NULL) ||
13323         ((arg2-&gt;nodesetval != NULL) &amp;&amp;
13324          (arg2-&gt;nodesetval-&gt;nodeNr != 0)))
13325         {

13326         arg1-&gt;nodesetval = xmlXPathNodeSetMerge(arg1-&gt;nodesetval,
13327                             arg2-&gt;nodesetval);
13328         }
13329 
13330             valuePush(ctxt, arg1);
13331         xmlXPathReleaseObject(ctxt-&gt;context, arg2);
<span class="line-modified">13332             return (total);</span>
13333         case XPATH_OP_ROOT:
13334             xmlXPathRoot(ctxt);
<span class="line-modified">13335             return (total);</span>
13336         case XPATH_OP_NODE:
13337             if (op-&gt;ch1 != -1)
13338                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13339         CHECK_ERROR0;
13340             if (op-&gt;ch2 != -1)
13341                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
13342         CHECK_ERROR0;
13343         valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt-&gt;context,
13344         ctxt-&gt;context-&gt;node));
<span class="line-modified">13345             return (total);</span>
13346         case XPATH_OP_COLLECT:{
13347                 if (op-&gt;ch1 == -1)
<span class="line-modified">13348                     return (total);</span>
13349 
13350                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13351         CHECK_ERROR0;
13352 
13353                 total += xmlXPathNodeCollectAndTest(ctxt, op, NULL, NULL, 0);
<span class="line-modified">13354                 return (total);</span>
13355             }
13356         case XPATH_OP_VALUE:
13357             valuePush(ctxt,
13358                       xmlXPathCacheObjectCopy(ctxt-&gt;context,
13359             (xmlXPathObjectPtr) op-&gt;value4));
<span class="line-modified">13360             return (total);</span>
13361         case XPATH_OP_VARIABLE:{
13362         xmlXPathObjectPtr val;
13363 
13364                 if (op-&gt;ch1 != -1)
13365                     total +=
13366                         xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13367                 if (op-&gt;value5 == NULL) {
13368             val = xmlXPathVariableLookup(ctxt-&gt;context, op-&gt;value4);
13369             if (val == NULL)
13370             XP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);
13371                     valuePush(ctxt, val);
13372         } else {
13373                     const xmlChar *URI;
13374 
13375                     URI = xmlXPathNsLookup(ctxt-&gt;context, op-&gt;value5);
13376                     if (URI == NULL) {
13377                         xmlGenericError(xmlGenericErrorContext,
13378             &quot;xmlXPathCompOpEval: variable %s bound to undefined prefix %s\n&quot;,
13379                                     (char *) op-&gt;value4, (char *)op-&gt;value5);
13380                         ctxt-&gt;error = XPATH_UNDEF_PREFIX_ERROR;
<span class="line-modified">13381                         return (total);</span>
13382                     }
13383             val = xmlXPathVariableLookupNS(ctxt-&gt;context,
13384                                                        op-&gt;value4, URI);
13385             if (val == NULL)
13386             XP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);
13387                     valuePush(ctxt, val);
13388                 }
<span class="line-modified">13389                 return (total);</span>
13390             }
13391         case XPATH_OP_FUNCTION:{
13392                 xmlXPathFunction func;
13393                 const xmlChar *oldFunc, *oldFuncURI;
13394         int i;
13395                 int frame;
13396 
13397                 frame = xmlXPathSetFrame(ctxt);
13398                 if (op-&gt;ch1 != -1) {
13399                     total +=
13400                         xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13401                     if (ctxt-&gt;error != XPATH_EXPRESSION_OK) {
13402                         xmlXPathPopFrame(ctxt, frame);
<span class="line-modified">13403                         return (total);</span>
13404                     }
13405                 }
13406         if (ctxt-&gt;valueNr &lt; ctxt-&gt;valueFrame + op-&gt;value) {
13407             xmlGenericError(xmlGenericErrorContext,
13408                 &quot;xmlXPathCompOpEval: parameter error\n&quot;);
13409             ctxt-&gt;error = XPATH_INVALID_OPERAND;
13410                     xmlXPathPopFrame(ctxt, frame);
<span class="line-modified">13411             return (total);</span>
13412         }
13413         for (i = 0; i &lt; op-&gt;value; i++) {
13414             if (ctxt-&gt;valueTab[(ctxt-&gt;valueNr - 1) - i] == NULL) {
13415             xmlGenericError(xmlGenericErrorContext,
13416                 &quot;xmlXPathCompOpEval: parameter error\n&quot;);
13417             ctxt-&gt;error = XPATH_INVALID_OPERAND;
13418                         xmlXPathPopFrame(ctxt, frame);
<span class="line-modified">13419             return (total);</span>
13420             }
13421                 }
13422                 if (op-&gt;cache != NULL)
13423                     func = op-&gt;cache;
13424                 else {
13425                     const xmlChar *URI = NULL;
13426 
13427                     if (op-&gt;value5 == NULL)
13428                         func =
13429                             xmlXPathFunctionLookup(ctxt-&gt;context,
13430                                                    op-&gt;value4);
13431                     else {
13432                         URI = xmlXPathNsLookup(ctxt-&gt;context, op-&gt;value5);
13433                         if (URI == NULL) {
13434                             xmlGenericError(xmlGenericErrorContext,
13435             &quot;xmlXPathCompOpEval: function %s bound to undefined prefix %s\n&quot;,
13436                                     (char *)op-&gt;value4, (char *)op-&gt;value5);
13437                             xmlXPathPopFrame(ctxt, frame);
13438                             ctxt-&gt;error = XPATH_UNDEF_PREFIX_ERROR;
<span class="line-modified">13439                             return (total);</span>
13440                         }
13441                         func = xmlXPathFunctionLookupNS(ctxt-&gt;context,
13442                                                         op-&gt;value4, URI);
13443                     }
13444                     if (func == NULL) {
13445                         xmlGenericError(xmlGenericErrorContext,
13446                                 &quot;xmlXPathCompOpEval: function %s not found\n&quot;,
13447                                         (char *)op-&gt;value4);
13448                         XP_ERROR0(XPATH_UNKNOWN_FUNC_ERROR);
13449                     }
13450                     op-&gt;cache = func;
13451                     op-&gt;cacheURI = (void *) URI;
13452                 }
13453                 oldFunc = ctxt-&gt;context-&gt;function;
13454                 oldFuncURI = ctxt-&gt;context-&gt;functionURI;
13455                 ctxt-&gt;context-&gt;function = op-&gt;value4;
13456                 ctxt-&gt;context-&gt;functionURI = op-&gt;cacheURI;
13457                 func(ctxt, op-&gt;value);
13458                 ctxt-&gt;context-&gt;function = oldFunc;
13459                 ctxt-&gt;context-&gt;functionURI = oldFuncURI;



13460                 xmlXPathPopFrame(ctxt, frame);
<span class="line-modified">13461                 return (total);</span>
13462             }
13463         case XPATH_OP_ARG:
13464             if (op-&gt;ch1 != -1) {
13465                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13466             CHECK_ERROR0;
13467             }
13468             if (op-&gt;ch2 != -1) {
13469                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
13470             CHECK_ERROR0;
13471         }
<span class="line-modified">13472             return (total);</span>
13473         case XPATH_OP_PREDICATE:
13474         case XPATH_OP_FILTER:{
<span class="line-modified">13475                 xmlXPathObjectPtr res;</span>
<span class="line-removed">13476                 xmlXPathObjectPtr obj, tmp;</span>
<span class="line-removed">13477                 xmlNodeSetPtr newset = NULL;</span>
<span class="line-removed">13478                 xmlNodeSetPtr oldset;</span>
<span class="line-removed">13479                 xmlNodePtr oldnode;</span>
<span class="line-removed">13480         xmlDocPtr oldDoc;</span>
<span class="line-removed">13481                 int oldcs, oldpp;</span>
<span class="line-removed">13482                 int i;</span>
13483 
13484                 /*
13485                  * Optimization for ()[1] selection i.e. the first elem
13486                  */
13487                 if ((op-&gt;ch1 != -1) &amp;&amp; (op-&gt;ch2 != -1) &amp;&amp;
13488 #ifdef XP_OPTIMIZED_FILTER_FIRST
13489             /*
13490             * FILTER TODO: Can we assume that the inner processing
13491             *  will result in an ordered list if we have an
13492             *  XPATH_OP_FILTER?
13493             *  What about an additional field or flag on
<span class="line-modified">13494             *  xmlXPathObject like @sorted ? This way we wouln&#39;d need</span>
13495             *  to assume anything, so it would be more robust and
13496             *  easier to optimize.
13497             */
13498                     ((comp-&gt;steps[op-&gt;ch1].op == XPATH_OP_SORT) || /* 18 */
13499              (comp-&gt;steps[op-&gt;ch1].op == XPATH_OP_FILTER)) &amp;&amp; /* 17 */
13500 #else
13501             (comp-&gt;steps[op-&gt;ch1].op == XPATH_OP_SORT) &amp;&amp;
13502 #endif
13503                     (comp-&gt;steps[op-&gt;ch2].op == XPATH_OP_VALUE)) { /* 12 */
13504                     xmlXPathObjectPtr val;
13505 
13506                     val = comp-&gt;steps[op-&gt;ch2].value4;
13507                     if ((val != NULL) &amp;&amp; (val-&gt;type == XPATH_NUMBER) &amp;&amp;
13508                         (val-&gt;floatval == 1.0)) {
13509                         xmlNodePtr first = NULL;
13510 
13511                         total +=
13512                             xmlXPathCompOpEvalFirst(ctxt,
13513                                                     &amp;comp-&gt;steps[op-&gt;ch1],
13514                                                     &amp;first);
13515             CHECK_ERROR0;
13516                         /*
13517                          * The nodeset should be in document order,
13518                          * Keep only the first value
13519                          */
13520                         if ((ctxt-&gt;value != NULL) &amp;&amp;
13521                             (ctxt-&gt;value-&gt;type == XPATH_NODESET) &amp;&amp;
13522                             (ctxt-&gt;value-&gt;nodesetval != NULL) &amp;&amp;
13523                             (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1))
13524                             xmlXPathNodeSetClearFromPos(ctxt-&gt;value-&gt;nodesetval,
13525                                                         1, 1);
<span class="line-modified">13526                         return (total);</span>
13527                     }
13528                 }
13529                 /*
13530                  * Optimization for ()[last()] selection i.e. the last elem
13531                  */
13532                 if ((op-&gt;ch1 != -1) &amp;&amp; (op-&gt;ch2 != -1) &amp;&amp;
13533                     (comp-&gt;steps[op-&gt;ch1].op == XPATH_OP_SORT) &amp;&amp;
13534                     (comp-&gt;steps[op-&gt;ch2].op == XPATH_OP_SORT)) {
13535                     int f = comp-&gt;steps[op-&gt;ch2].ch1;
13536 
13537                     if ((f != -1) &amp;&amp;
13538                         (comp-&gt;steps[f].op == XPATH_OP_FUNCTION) &amp;&amp;
13539                         (comp-&gt;steps[f].value5 == NULL) &amp;&amp;
13540                         (comp-&gt;steps[f].value == 0) &amp;&amp;
13541                         (comp-&gt;steps[f].value4 != NULL) &amp;&amp;
13542                         (xmlStrEqual
13543                          (comp-&gt;steps[f].value4, BAD_CAST &quot;last&quot;))) {
13544                         xmlNodePtr last = NULL;
13545 
13546                         total +=
13547                             xmlXPathCompOpEvalLast(ctxt,
13548                                                    &amp;comp-&gt;steps[op-&gt;ch1],
13549                                                    &amp;last);
13550             CHECK_ERROR0;
13551                         /*
13552                          * The nodeset should be in document order,
13553                          * Keep only the last value
13554                          */
13555                         if ((ctxt-&gt;value != NULL) &amp;&amp;
13556                             (ctxt-&gt;value-&gt;type == XPATH_NODESET) &amp;&amp;
13557                             (ctxt-&gt;value-&gt;nodesetval != NULL) &amp;&amp;
13558                             (ctxt-&gt;value-&gt;nodesetval-&gt;nodeTab != NULL) &amp;&amp;
13559                             (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1))
13560                             xmlXPathNodeSetKeepLast(ctxt-&gt;value-&gt;nodesetval);
<span class="line-modified">13561                         return (total);</span>
13562                     }
13563                 }
13564         /*
13565         * Process inner predicates first.
13566         * Example &quot;index[parent::book][1]&quot;:
13567         * ...
13568         *   PREDICATE   &lt;-- we are here &quot;[1]&quot;
13569         *     PREDICATE &lt;-- process &quot;[parent::book]&quot; first
13570         *       SORT
13571         *         COLLECT  &#39;parent&#39; &#39;name&#39; &#39;node&#39; book
13572         *           NODE
13573         *     ELEM Object is a number : 1
13574         */
13575                 if (op-&gt;ch1 != -1)
13576                     total +=
13577                         xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13578         CHECK_ERROR0;
13579                 if (op-&gt;ch2 == -1)
<span class="line-modified">13580                     return (total);</span>
13581                 if (ctxt-&gt;value == NULL)
<span class="line-modified">13582                     return (total);</span>
13583 
13584 #ifdef LIBXML_XPTR_ENABLED
13585                 /*
13586                  * Hum are we filtering the result of an XPointer expression
13587                  */
13588                 if (ctxt-&gt;value-&gt;type == XPATH_LOCATIONSET) {
<span class="line-modified">13589                     xmlLocationSetPtr newlocset = NULL;</span>
<span class="line-modified">13590                     xmlLocationSetPtr oldlocset;</span>
<span class="line-modified">13591 </span>
<span class="line-modified">13592                     /*</span>
<span class="line-removed">13593                      * Extract the old locset, and then evaluate the result of the</span>
<span class="line-removed">13594                      * expression for all the element in the locset. use it to grow</span>
<span class="line-removed">13595                      * up a new locset.</span>
<span class="line-removed">13596                      */</span>
<span class="line-removed">13597                     CHECK_TYPE0(XPATH_LOCATIONSET);</span>
<span class="line-removed">13598 </span>
<span class="line-removed">13599                     if ((ctxt-&gt;value-&gt;user == NULL) ||</span>
<span class="line-removed">13600                         (((xmlLocationSetPtr) ctxt-&gt;value-&gt;user)-&gt;locNr == 0))</span>
<span class="line-removed">13601                         return (total);</span>
<span class="line-removed">13602 </span>
<span class="line-removed">13603                     obj = valuePop(ctxt);</span>
<span class="line-removed">13604                     oldlocset = obj-&gt;user;</span>
<span class="line-removed">13605                     oldnode = ctxt-&gt;context-&gt;node;</span>
<span class="line-removed">13606                     oldcs = ctxt-&gt;context-&gt;contextSize;</span>
<span class="line-removed">13607                     oldpp = ctxt-&gt;context-&gt;proximityPosition;</span>
<span class="line-removed">13608 </span>
<span class="line-removed">13609                     newlocset = xmlXPtrLocationSetCreate(NULL);</span>
<span class="line-removed">13610 </span>
<span class="line-removed">13611                     for (i = 0; i &lt; oldlocset-&gt;locNr; i++) {</span>
<span class="line-removed">13612                         /*</span>
<span class="line-removed">13613                          * Run the evaluation with a node list made of a</span>
<span class="line-removed">13614                          * single item in the nodelocset.</span>
<span class="line-removed">13615                          */</span>
<span class="line-removed">13616                         ctxt-&gt;context-&gt;node = oldlocset-&gt;locTab[i]-&gt;user;</span>
<span class="line-removed">13617                         ctxt-&gt;context-&gt;contextSize = oldlocset-&gt;locNr;</span>
<span class="line-removed">13618                         ctxt-&gt;context-&gt;proximityPosition = i + 1;</span>
<span class="line-removed">13619             tmp = xmlXPathCacheNewNodeSet(ctxt-&gt;context,</span>
<span class="line-removed">13620                 ctxt-&gt;context-&gt;node);</span>
<span class="line-removed">13621                         valuePush(ctxt, tmp);</span>
<span class="line-removed">13622 </span>
<span class="line-removed">13623                         if (op-&gt;ch2 != -1)</span>
<span class="line-removed">13624                             total +=</span>
<span class="line-removed">13625                                 xmlXPathCompOpEval(ctxt,</span>
<span class="line-removed">13626                                                    &amp;comp-&gt;steps[op-&gt;ch2]);</span>
<span class="line-removed">13627             if (ctxt-&gt;error != XPATH_EXPRESSION_OK) {</span>
<span class="line-removed">13628                             xmlXPtrFreeLocationSet(newlocset);</span>
<span class="line-removed">13629                             goto filter_xptr_error;</span>
<span class="line-removed">13630             }</span>
<span class="line-removed">13631 </span>
<span class="line-removed">13632                         /*</span>
<span class="line-removed">13633                          * The result of the evaluation need to be tested to</span>
<span class="line-removed">13634                          * decided whether the filter succeeded or not</span>
<span class="line-removed">13635                          */</span>
<span class="line-removed">13636                         res = valuePop(ctxt);</span>
<span class="line-removed">13637                         if (xmlXPathEvaluatePredicateResult(ctxt, res)) {</span>
<span class="line-removed">13638                             xmlXPtrLocationSetAdd(newlocset,</span>
<span class="line-removed">13639                                                   xmlXPathObjectCopy</span>
<span class="line-removed">13640                                                   (oldlocset-&gt;locTab[i]));</span>
<span class="line-removed">13641                         }</span>
<span class="line-removed">13642 </span>
<span class="line-removed">13643                         /*</span>
<span class="line-removed">13644                          * Cleanup</span>
<span class="line-removed">13645                          */</span>
<span class="line-removed">13646                         if (res != NULL) {</span>
<span class="line-removed">13647                 xmlXPathReleaseObject(ctxt-&gt;context, res);</span>
<span class="line-removed">13648             }</span>
<span class="line-removed">13649                         if (ctxt-&gt;value == tmp) {</span>
<span class="line-removed">13650                             res = valuePop(ctxt);</span>
<span class="line-removed">13651                 xmlXPathReleaseObject(ctxt-&gt;context, res);</span>
<span class="line-removed">13652                         }</span>
<span class="line-removed">13653                     }</span>
<span class="line-removed">13654 </span>
<span class="line-removed">13655                     /*</span>
<span class="line-removed">13656                      * The result is used as the new evaluation locset.</span>
<span class="line-removed">13657                      */</span>
<span class="line-removed">13658                     valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));</span>
<span class="line-removed">13659 filter_xptr_error:</span>
<span class="line-removed">13660             xmlXPathReleaseObject(ctxt-&gt;context, obj);</span>
<span class="line-removed">13661                     ctxt-&gt;context-&gt;node = oldnode;</span>
<span class="line-removed">13662                     ctxt-&gt;context-&gt;contextSize = oldcs;</span>
<span class="line-removed">13663                     ctxt-&gt;context-&gt;proximityPosition = oldpp;</span>
<span class="line-removed">13664                     return (total);</span>
13665                 }
13666 #endif /* LIBXML_XPTR_ENABLED */
13667 
<span class="line-removed">13668                 /*</span>
<span class="line-removed">13669                  * Extract the old set, and then evaluate the result of the</span>
<span class="line-removed">13670                  * expression for all the element in the set. use it to grow</span>
<span class="line-removed">13671                  * up a new set.</span>
<span class="line-removed">13672                  */</span>
13673                 CHECK_TYPE0(XPATH_NODESET);
<span class="line-modified">13674 </span>
<span class="line-modified">13675                 if ((ctxt-&gt;value-&gt;nodesetval != NULL) &amp;&amp;</span>
<span class="line-modified">13676                     (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr != 0)) {</span>
<span class="line-modified">13677                     obj = valuePop(ctxt);</span>
<span class="line-modified">13678                     oldset = obj-&gt;nodesetval;</span>
<span class="line-removed">13679                     oldnode = ctxt-&gt;context-&gt;node;</span>
<span class="line-removed">13680                     oldDoc = ctxt-&gt;context-&gt;doc;</span>
<span class="line-removed">13681                     oldcs = ctxt-&gt;context-&gt;contextSize;</span>
<span class="line-removed">13682                     oldpp = ctxt-&gt;context-&gt;proximityPosition;</span>
<span class="line-removed">13683             tmp = NULL;</span>
<span class="line-removed">13684                     /*</span>
<span class="line-removed">13685                      * Initialize the new set.</span>
<span class="line-removed">13686              * Also set the xpath document in case things like</span>
<span class="line-removed">13687              * key() evaluation are attempted on the predicate</span>
<span class="line-removed">13688                      */</span>
<span class="line-removed">13689                     newset = xmlXPathNodeSetCreate(NULL);</span>
<span class="line-removed">13690             /*</span>
<span class="line-removed">13691             * SPEC XPath 1.0:</span>
<span class="line-removed">13692             *  &quot;For each node in the node-set to be filtered, the</span>
<span class="line-removed">13693             *  PredicateExpr is evaluated with that node as the</span>
<span class="line-removed">13694             *  context node, with the number of nodes in the</span>
<span class="line-removed">13695             *  node-set as the context size, and with the proximity</span>
<span class="line-removed">13696             *  position of the node in the node-set with respect to</span>
<span class="line-removed">13697             *  the axis as the context position;&quot;</span>
<span class="line-removed">13698             * @oldset is the node-set&quot; to be filtered.</span>
<span class="line-removed">13699             *</span>
<span class="line-removed">13700             * SPEC XPath 1.0:</span>
<span class="line-removed">13701             *  &quot;only predicates change the context position and</span>
<span class="line-removed">13702             *  context size (see [2.4 Predicates]).&quot;</span>
<span class="line-removed">13703             * Example:</span>
<span class="line-removed">13704             *   node-set  context pos</span>
<span class="line-removed">13705             *    nA         1</span>
<span class="line-removed">13706             *    nB         2</span>
<span class="line-removed">13707             *    nC         3</span>
<span class="line-removed">13708             *   After applying predicate [position() &gt; 1] :</span>
<span class="line-removed">13709             *   node-set  context pos</span>
<span class="line-removed">13710             *    nB         1</span>
<span class="line-removed">13711             *    nC         2</span>
<span class="line-removed">13712             *</span>
<span class="line-removed">13713             * removed the first node in the node-set, then</span>
<span class="line-removed">13714             * the context position of the</span>
<span class="line-removed">13715             */</span>
<span class="line-removed">13716                     for (i = 0; i &lt; oldset-&gt;nodeNr; i++) {</span>
<span class="line-removed">13717                         /*</span>
<span class="line-removed">13718                          * Run the evaluation with a node list made of</span>
<span class="line-removed">13719                          * a single item in the nodeset.</span>
<span class="line-removed">13720                          */</span>
<span class="line-removed">13721                         ctxt-&gt;context-&gt;node = oldset-&gt;nodeTab[i];</span>
<span class="line-removed">13722             if ((oldset-&gt;nodeTab[i]-&gt;type != XML_NAMESPACE_DECL) &amp;&amp;</span>
<span class="line-removed">13723                 (oldset-&gt;nodeTab[i]-&gt;doc != NULL))</span>
<span class="line-removed">13724                     ctxt-&gt;context-&gt;doc = oldset-&gt;nodeTab[i]-&gt;doc;</span>
<span class="line-removed">13725             if (tmp == NULL) {</span>
<span class="line-removed">13726                 tmp = xmlXPathCacheNewNodeSet(ctxt-&gt;context,</span>
<span class="line-removed">13727                 ctxt-&gt;context-&gt;node);</span>
<span class="line-removed">13728             } else {</span>
<span class="line-removed">13729                 if (xmlXPathNodeSetAddUnique(tmp-&gt;nodesetval,</span>
<span class="line-removed">13730                                ctxt-&gt;context-&gt;node) &lt; 0) {</span>
<span class="line-removed">13731                 ctxt-&gt;error = XPATH_MEMORY_ERROR;</span>
<span class="line-removed">13732                 }</span>
<span class="line-removed">13733             }</span>
<span class="line-removed">13734                         valuePush(ctxt, tmp);</span>
<span class="line-removed">13735                         ctxt-&gt;context-&gt;contextSize = oldset-&gt;nodeNr;</span>
<span class="line-removed">13736                         ctxt-&gt;context-&gt;proximityPosition = i + 1;</span>
<span class="line-removed">13737             /*</span>
<span class="line-removed">13738             * Evaluate the predicate against the context node.</span>
<span class="line-removed">13739             * Can/should we optimize position() predicates</span>
<span class="line-removed">13740             * here (e.g. &quot;[1]&quot;)?</span>
<span class="line-removed">13741             */</span>
<span class="line-removed">13742                         if (op-&gt;ch2 != -1)</span>
<span class="line-removed">13743                             total +=</span>
<span class="line-removed">13744                                 xmlXPathCompOpEval(ctxt,</span>
<span class="line-removed">13745                                                    &amp;comp-&gt;steps[op-&gt;ch2]);</span>
<span class="line-removed">13746             if (ctxt-&gt;error != XPATH_EXPRESSION_OK) {</span>
<span class="line-removed">13747                 xmlXPathFreeNodeSet(newset);</span>
<span class="line-removed">13748                             goto filter_error;</span>
<span class="line-removed">13749             }</span>
<span class="line-removed">13750 </span>
<span class="line-removed">13751                         /*</span>
<span class="line-removed">13752                          * The result of the evaluation needs to be tested to</span>
<span class="line-removed">13753                          * decide whether the filter succeeded or not</span>
<span class="line-removed">13754                          */</span>
<span class="line-removed">13755             /*</span>
<span class="line-removed">13756             * OPTIMIZE TODO: Can we use</span>
<span class="line-removed">13757             * xmlXPathNodeSetAdd*Unique()* instead?</span>
<span class="line-removed">13758             */</span>
<span class="line-removed">13759                         res = valuePop(ctxt);</span>
<span class="line-removed">13760                         if (xmlXPathEvaluatePredicateResult(ctxt, res)) {</span>
<span class="line-removed">13761                             if (xmlXPathNodeSetAdd(newset, oldset-&gt;nodeTab[i])</span>
<span class="line-removed">13762                     &lt; 0)</span>
<span class="line-removed">13763                 ctxt-&gt;error = XPATH_MEMORY_ERROR;</span>
<span class="line-removed">13764                         }</span>
<span class="line-removed">13765 </span>
<span class="line-removed">13766                         /*</span>
<span class="line-removed">13767                          * Cleanup</span>
<span class="line-removed">13768                          */</span>
<span class="line-removed">13769                         if (res != NULL) {</span>
<span class="line-removed">13770                 xmlXPathReleaseObject(ctxt-&gt;context, res);</span>
<span class="line-removed">13771             }</span>
<span class="line-removed">13772                         if (ctxt-&gt;value == tmp) {</span>
<span class="line-removed">13773                             valuePop(ctxt);</span>
<span class="line-removed">13774                 xmlXPathNodeSetClear(tmp-&gt;nodesetval, 1);</span>
<span class="line-removed">13775                 /*</span>
<span class="line-removed">13776                 * Don&#39;t free the temporary nodeset</span>
<span class="line-removed">13777                 * in order to avoid massive recreation inside this</span>
<span class="line-removed">13778                 * loop.</span>
<span class="line-removed">13779                 */</span>
<span class="line-removed">13780                         } else</span>
<span class="line-removed">13781                 tmp = NULL;</span>
<span class="line-removed">13782                     }</span>
<span class="line-removed">13783             if (tmp != NULL)</span>
<span class="line-removed">13784             xmlXPathReleaseObject(ctxt-&gt;context, tmp);</span>
<span class="line-removed">13785                     /*</span>
<span class="line-removed">13786                      * The result is used as the new evaluation set.</span>
<span class="line-removed">13787                      */</span>
<span class="line-removed">13788             valuePush(ctxt,</span>
<span class="line-removed">13789             xmlXPathCacheWrapNodeSet(ctxt-&gt;context, newset));</span>
<span class="line-removed">13790 filter_error:</span>
<span class="line-removed">13791             xmlXPathReleaseObject(ctxt-&gt;context, obj);</span>
<span class="line-removed">13792             ctxt-&gt;context-&gt;node = oldnode;</span>
<span class="line-removed">13793             ctxt-&gt;context-&gt;doc = oldDoc;</span>
<span class="line-removed">13794                     ctxt-&gt;context-&gt;contextSize = oldcs;</span>
<span class="line-removed">13795                     ctxt-&gt;context-&gt;proximityPosition = oldpp;</span>
<span class="line-removed">13796                 }</span>
<span class="line-removed">13797                 return (total);</span>
13798             }
13799         case XPATH_OP_SORT:
13800             if (op-&gt;ch1 != -1)
13801                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13802         CHECK_ERROR0;
13803             if ((ctxt-&gt;value != NULL) &amp;&amp;
13804                 (ctxt-&gt;value-&gt;type == XPATH_NODESET) &amp;&amp;
13805                 (ctxt-&gt;value-&gt;nodesetval != NULL) &amp;&amp;
13806         (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1))
13807         {
13808                 xmlXPathNodeSetSort(ctxt-&gt;value-&gt;nodesetval);
13809         }
<span class="line-modified">13810             return (total);</span>
13811 #ifdef LIBXML_XPTR_ENABLED
13812         case XPATH_OP_RANGETO:{
13813                 xmlXPathObjectPtr range;
13814                 xmlXPathObjectPtr res, obj;
13815                 xmlXPathObjectPtr tmp;
13816                 xmlLocationSetPtr newlocset = NULL;
13817             xmlLocationSetPtr oldlocset;
13818                 xmlNodeSetPtr oldset;
13819                 xmlNodePtr oldnode = ctxt-&gt;context-&gt;node;
13820                 int oldcs = ctxt-&gt;context-&gt;contextSize;
13821                 int oldpp = ctxt-&gt;context-&gt;proximityPosition;
13822                 int i, j;
13823 
13824                 if (op-&gt;ch1 != -1) {
13825                     total +=
13826                         xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13827                     CHECK_ERROR0;
13828                 }
13829                 if (ctxt-&gt;value == NULL) {
13830                     XP_ERROR0(XPATH_INVALID_OPERAND);
13831                 }
13832                 if (op-&gt;ch2 == -1)
<span class="line-modified">13833                     return (total);</span>
13834 
13835                 if (ctxt-&gt;value-&gt;type == XPATH_LOCATIONSET) {
13836                     /*
13837                      * Extract the old locset, and then evaluate the result of the
13838                      * expression for all the element in the locset. use it to grow
13839                      * up a new locset.
13840                      */
13841                     CHECK_TYPE0(XPATH_LOCATIONSET);
13842 
13843                     if ((ctxt-&gt;value-&gt;user == NULL) ||
13844                         (((xmlLocationSetPtr) ctxt-&gt;value-&gt;user)-&gt;locNr == 0))
<span class="line-modified">13845                         return (total);</span>
13846 
13847                     obj = valuePop(ctxt);
13848                     oldlocset = obj-&gt;user;
13849 
13850                     newlocset = xmlXPtrLocationSetCreate(NULL);
13851 
13852                     for (i = 0; i &lt; oldlocset-&gt;locNr; i++) {
13853                         /*
13854                          * Run the evaluation with a node list made of a
13855                          * single item in the nodelocset.
13856                          */
13857                         ctxt-&gt;context-&gt;node = oldlocset-&gt;locTab[i]-&gt;user;
13858                         ctxt-&gt;context-&gt;contextSize = oldlocset-&gt;locNr;
13859                         ctxt-&gt;context-&gt;proximityPosition = i + 1;
13860             tmp = xmlXPathCacheNewNodeSet(ctxt-&gt;context,
13861                 ctxt-&gt;context-&gt;node);
13862                         valuePush(ctxt, tmp);
13863 
13864                         if (op-&gt;ch2 != -1)
13865                             total +=
</pre>
<hr />
<pre>
13947                             if (res != NULL) {
13948                 xmlXPathReleaseObject(ctxt-&gt;context, res);
13949                 }
13950                             if (ctxt-&gt;value == tmp) {
13951                                 res = valuePop(ctxt);
13952                 xmlXPathReleaseObject(ctxt-&gt;context, res);
13953                             }
13954                         }
13955                     }
13956                 }
13957 
13958                 /*
13959                  * The result is used as the new evaluation set.
13960                  */
13961                 valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));
13962 rangeto_error:
13963         xmlXPathReleaseObject(ctxt-&gt;context, obj);
13964                 ctxt-&gt;context-&gt;node = oldnode;
13965                 ctxt-&gt;context-&gt;contextSize = oldcs;
13966                 ctxt-&gt;context-&gt;proximityPosition = oldpp;
<span class="line-modified">13967                 return (total);</span>
13968             }
13969 #endif /* LIBXML_XPTR_ENABLED */
<span class="line-modified">13970     }</span>
13971     xmlGenericError(xmlGenericErrorContext,
13972                     &quot;XPath: unknown precompiled operation %d\n&quot;, op-&gt;op);
13973     ctxt-&gt;error = XPATH_INVALID_OPERAND;




13974     return (total);
13975 }
13976 
13977 /**
13978  * xmlXPathCompOpEvalToBoolean:
13979  * @ctxt:  the XPath parser context
13980  *
13981  * Evaluates if the expression evaluates to true.
13982  *
13983  * Returns 1 if true, 0 if false and -1 on API or internal errors.
13984  */
13985 static int
13986 xmlXPathCompOpEvalToBoolean(xmlXPathParserContextPtr ctxt,
13987                 xmlXPathStepOpPtr op,
13988                 int isPredicate)
13989 {
13990     xmlXPathObjectPtr resObj = NULL;
13991 
13992 start:


13993     /* comp = ctxt-&gt;comp; */
13994     switch (op-&gt;op) {
13995         case XPATH_OP_END:
13996             return (0);
13997     case XPATH_OP_VALUE:
13998         resObj = (xmlXPathObjectPtr) op-&gt;value4;
13999         if (isPredicate)
14000         return(xmlXPathEvaluatePredicateResult(ctxt, resObj));
14001         return(xmlXPathCastToBoolean(resObj));
14002     case XPATH_OP_SORT:
14003         /*
14004         * We don&#39;t need sorting for boolean results. Skip this one.
14005         */
14006             if (op-&gt;ch1 != -1) {
14007         op = &amp;ctxt-&gt;comp-&gt;steps[op-&gt;ch1];
14008         goto start;
14009         }
14010         return(0);
14011     case XPATH_OP_COLLECT:
14012         if (op-&gt;ch1 == -1)
</pre>
<hr />
<pre>
14099 #if 0
14100     printf(&quot;stream eval: depth %d from root %d\n&quot;, max_depth, from_root);
14101 #endif
14102 
14103     if (! toBool) {
14104     if (resultSeq == NULL)
14105         return(-1);
14106     *resultSeq = xmlXPathCacheNewNodeSet(ctxt, NULL);
14107     if (*resultSeq == NULL)
14108         return(-1);
14109     }
14110 
14111     /*
14112      * handle the special cases of &quot;/&quot; amd &quot;.&quot; being matched
14113      */
14114     if (min_depth == 0) {
14115     if (from_root) {
14116         /* Select &quot;/&quot; */
14117         if (toBool)
14118         return(1);

14119         xmlXPathNodeSetAddUnique((*resultSeq)-&gt;nodesetval,
14120                              (xmlNodePtr) ctxt-&gt;doc);
14121     } else {
14122         /* Select &quot;self::node()&quot; */
14123         if (toBool)
14124         return(1);

14125         xmlXPathNodeSetAddUnique((*resultSeq)-&gt;nodesetval, ctxt-&gt;node);
14126     }
14127     }
14128     if (max_depth == 0) {
14129     return(0);
14130     }
14131 
14132     if (from_root) {
14133         cur = (xmlNodePtr)ctxt-&gt;doc;
14134     } else if (ctxt-&gt;node != NULL) {
14135         switch (ctxt-&gt;node-&gt;type) {
14136             case XML_ELEMENT_NODE:
14137             case XML_DOCUMENT_NODE:
14138             case XML_DOCUMENT_FRAG_NODE:
14139             case XML_HTML_DOCUMENT_NODE:
14140 #ifdef LIBXML_DOCB_ENABLED
14141             case XML_DOCB_DOCUMENT_NODE:
14142 #endif
14143             cur = ctxt-&gt;node;
14144         break;
</pre>
<hr />
<pre>
14165     if (cur == NULL) {
14166         return(0);
14167     }
14168 
14169     patstream = xmlPatternGetStreamCtxt(comp);
14170     if (patstream == NULL) {
14171     /*
14172     * QUESTION TODO: Is this an error?
14173     */
14174     return(0);
14175     }
14176 
14177     eval_all_nodes = xmlStreamWantsAnyNode(patstream);
14178 
14179     if (from_root) {
14180     ret = xmlStreamPush(patstream, NULL, NULL);
14181     if (ret &lt; 0) {
14182     } else if (ret == 1) {
14183         if (toBool)
14184         goto return_1;

14185         xmlXPathNodeSetAddUnique((*resultSeq)-&gt;nodesetval, cur);
14186     }
14187     }
14188     depth = 0;
14189     goto scan_children;
14190 next_node:
14191     do {










14192         nb_nodes++;
14193 
14194     switch (cur-&gt;type) {
14195         case XML_ELEMENT_NODE:
14196         case XML_TEXT_NODE:
14197         case XML_CDATA_SECTION_NODE:
14198         case XML_COMMENT_NODE:
14199         case XML_PI_NODE:
14200         if (cur-&gt;type == XML_ELEMENT_NODE) {
14201             ret = xmlStreamPush(patstream, cur-&gt;name,
14202                 (cur-&gt;ns ? cur-&gt;ns-&gt;href : NULL));
14203         } else if (eval_all_nodes)
14204             ret = xmlStreamPushNode(patstream, NULL, NULL, cur-&gt;type);
14205         else
14206             break;
14207 
14208         if (ret &lt; 0) {
14209             /* NOP. */
14210         } else if (ret == 1) {
14211             if (toBool)
</pre>
<hr />
<pre>
14295     xmlFreeStreamCtxt(patstream);
14296     return(1);
14297 }
14298 #endif /* XPATH_STREAMING */
14299 
14300 /**
14301  * xmlXPathRunEval:
14302  * @ctxt:  the XPath parser context with the compiled expression
14303  * @toBool:  evaluate to a boolean result
14304  *
14305  * Evaluate the Precompiled XPath expression in the given context.
14306  */
14307 static int
14308 xmlXPathRunEval(xmlXPathParserContextPtr ctxt, int toBool)
14309 {
14310     xmlXPathCompExprPtr comp;
14311 
14312     if ((ctxt == NULL) || (ctxt-&gt;comp == NULL))
14313     return(-1);
14314 


14315     if (ctxt-&gt;valueTab == NULL) {
14316     /* Allocate the value stack */
14317     ctxt-&gt;valueTab = (xmlXPathObjectPtr *)
14318              xmlMalloc(10 * sizeof(xmlXPathObjectPtr));
14319     if (ctxt-&gt;valueTab == NULL) {
14320         xmlXPathPErrMemory(ctxt, &quot;creating evaluation context\n&quot;);
14321         xmlFree(ctxt);
14322     }
14323     ctxt-&gt;valueNr = 0;
14324     ctxt-&gt;valueMax = 10;
14325     ctxt-&gt;value = NULL;
14326         ctxt-&gt;valueFrame = 0;
14327     }
14328 #ifdef XPATH_STREAMING
14329     if (ctxt-&gt;comp-&gt;stream) {
14330     int res;
14331 
14332     if (toBool) {
14333         /*
14334         * Evaluation to boolean result.
</pre>
<hr />
<pre>
14481  */
14482 static xmlXPathCompExprPtr
14483 xmlXPathTryStreamCompile(xmlXPathContextPtr ctxt, const xmlChar *str) {
14484     /*
14485      * Optimization: use streaming patterns when the XPath expression can
14486      * be compiled to a stream lookup
14487      */
14488     xmlPatternPtr stream;
14489     xmlXPathCompExprPtr comp;
14490     xmlDictPtr dict = NULL;
14491     const xmlChar **namespaces = NULL;
14492     xmlNsPtr ns;
14493     int i, j;
14494 
14495     if ((!xmlStrchr(str, &#39;[&#39;)) &amp;&amp; (!xmlStrchr(str, &#39;(&#39;)) &amp;&amp;
14496         (!xmlStrchr(str, &#39;@&#39;))) {
14497     const xmlChar *tmp;
14498 
14499     /*
14500      * We don&#39;t try to handle expressions using the verbose axis
<span class="line-modified">14501      * specifiers (&quot;::&quot;), just the simplied form at this point.</span>
14502      * Additionally, if there is no list of namespaces available and
14503      *  there&#39;s a &quot;:&quot; in the expression, indicating a prefixed QName,
14504      *  then we won&#39;t try to compile either. xmlPatterncompile() needs
14505      *  to have a list of namespaces at compilation time in order to
14506      *  compile prefixed name tests.
14507      */
14508     tmp = xmlStrchr(str, &#39;:&#39;);
14509     if ((tmp != NULL) &amp;&amp;
14510         ((ctxt == NULL) || (ctxt-&gt;nsNr == 0) || (tmp[1] == &#39;:&#39;)))
14511         return(NULL);
14512 
14513     if (ctxt != NULL) {
14514         dict = ctxt-&gt;dict;
14515         if (ctxt-&gt;nsNr &gt; 0) {
14516         namespaces = xmlMalloc(2 * (ctxt-&gt;nsNr + 1) * sizeof(xmlChar*));
14517         if (namespaces == NULL) {
14518             xmlXPathErrMemory(ctxt, &quot;allocating namespaces array\n&quot;);
14519             return(NULL);
14520         }
14521         for (i = 0, j = 0; (j &lt; ctxt-&gt;nsNr); j++) {
</pre>
<hr />
<pre>
14535     }
14536     if ((stream != NULL) &amp;&amp; (xmlPatternStreamable(stream) == 1)) {
14537         comp = xmlXPathNewCompExpr();
14538         if (comp == NULL) {
14539         xmlXPathErrMemory(ctxt, &quot;allocating streamable expression\n&quot;);
14540         return(NULL);
14541         }
14542         comp-&gt;stream = stream;
14543         comp-&gt;dict = dict;
14544         if (comp-&gt;dict)
14545         xmlDictReference(comp-&gt;dict);
14546         return(comp);
14547     }
14548     xmlFreePattern(stream);
14549     }
14550     return(NULL);
14551 }
14552 #endif /* XPATH_STREAMING */
14553 
14554 static void
<span class="line-modified">14555 xmlXPathOptimizeExpression(xmlXPathCompExprPtr comp, xmlXPathStepOpPtr op)</span>

14556 {



14557     /*
14558     * Try to rewrite &quot;descendant-or-self::node()/foo&quot; to an optimized
14559     * internal representation.
14560     */
14561 
14562     if ((op-&gt;op == XPATH_OP_COLLECT /* 11 */) &amp;&amp;
14563         (op-&gt;ch1 != -1) &amp;&amp;
14564         (op-&gt;ch2 == -1 /* no predicate */))
14565     {
14566         xmlXPathStepOpPtr prevop = &amp;comp-&gt;steps[op-&gt;ch1];
14567 
14568         if ((prevop-&gt;op == XPATH_OP_COLLECT /* 11 */) &amp;&amp;
14569             ((xmlXPathAxisVal) prevop-&gt;value ==
14570                 AXIS_DESCENDANT_OR_SELF) &amp;&amp;
14571             (prevop-&gt;ch2 == -1) &amp;&amp;
14572             ((xmlXPathTestVal) prevop-&gt;value2 == NODE_TEST_TYPE) &amp;&amp;
14573             ((xmlXPathTypeVal) prevop-&gt;value3 == NODE_TYPE_NODE))
14574         {
14575             /*
14576             * This is a &quot;descendant-or-self::node()&quot; without predicates.
</pre>
<hr />
<pre>
14592                 case AXIS_DESCENDANT_OR_SELF:
14593                     /*
14594                     * Convert &quot;descendant-or-self::node()/self::&quot; or
14595                     * &quot;descendant-or-self::node()/descendant-or-self::&quot; to
14596                     * to &quot;descendant-or-self::&quot;
14597                     */
14598                     op-&gt;ch1   = prevop-&gt;ch1;
14599                     op-&gt;value = AXIS_DESCENDANT_OR_SELF;
14600                     break;
14601                 default:
14602                     break;
14603             }
14604     }
14605     }
14606 
14607     /* OP_VALUE has invalid ch1. */
14608     if (op-&gt;op == XPATH_OP_VALUE)
14609         return;
14610 
14611     /* Recurse */






14612     if (op-&gt;ch1 != -1)
<span class="line-modified">14613         xmlXPathOptimizeExpression(comp, &amp;comp-&gt;steps[op-&gt;ch1]);</span>
14614     if (op-&gt;ch2 != -1)
<span class="line-modified">14615     xmlXPathOptimizeExpression(comp, &amp;comp-&gt;steps[op-&gt;ch2]);</span>


14616 }
14617 
14618 /**
14619  * xmlXPathCtxtCompile:
14620  * @ctxt: an XPath context
14621  * @str:  the XPath expression
14622  *
14623  * Compile an XPath expression
14624  *
14625  * Returns the xmlXPathCompExprPtr resulting from the compilation or NULL.
14626  *         the caller has to free the object.
14627  */
14628 xmlXPathCompExprPtr
14629 xmlXPathCtxtCompile(xmlXPathContextPtr ctxt, const xmlChar *str) {
14630     xmlXPathParserContextPtr pctxt;
14631     xmlXPathCompExprPtr comp;
14632 
14633 #ifdef XPATH_STREAMING
14634     comp = xmlXPathTryStreamCompile(ctxt, str);
14635     if (comp != NULL)
14636         return(comp);
14637 #endif
14638 
14639     xmlXPathInit();
14640 
14641     pctxt = xmlXPathNewParserContext(str, ctxt);
14642     if (pctxt == NULL)
14643         return NULL;


14644     xmlXPathCompileExpr(pctxt, 1);
14645 
14646     if( pctxt-&gt;error != XPATH_EXPRESSION_OK )
14647     {
14648         xmlXPathFreeParserContext(pctxt);
14649         return(NULL);
14650     }
14651 
14652     if (*pctxt-&gt;cur != 0) {
14653     /*
14654      * aleksey: in some cases this line prints *second* error message
14655      * (see bug #78858) and probably this should be fixed.
14656      * However, we are not sure that all error messages are printed
14657      * out in other places. It&#39;s not critical so we leave it as-is for now
14658      */
14659     xmlXPatherror(pctxt, __FILE__, __LINE__, XPATH_EXPR_ERROR);
14660     comp = NULL;
14661     } else {
14662     comp = pctxt-&gt;comp;





14663     pctxt-&gt;comp = NULL;
14664     }
14665     xmlXPathFreeParserContext(pctxt);
14666 
14667     if (comp != NULL) {
14668     comp-&gt;expr = xmlStrdup(str);
14669 #ifdef DEBUG_EVAL_COUNTS
14670     comp-&gt;string = xmlStrdup(str);
14671     comp-&gt;nb = 0;
14672 #endif
<span class="line-removed">14673     if ((comp-&gt;nbStep &gt; 1) &amp;&amp; (comp-&gt;last &gt;= 0)) {</span>
<span class="line-removed">14674         xmlXPathOptimizeExpression(comp, &amp;comp-&gt;steps[comp-&gt;last]);</span>
<span class="line-removed">14675     }</span>
14676     }
14677     return(comp);
14678 }
14679 
14680 /**
14681  * xmlXPathCompile:
14682  * @str:  the XPath expression
14683  *
14684  * Compile an XPath expression
14685  *
14686  * Returns the xmlXPathCompExprPtr resulting from the compilation or NULL.
14687  *         the caller has to free the object.
14688  */
14689 xmlXPathCompExprPtr
14690 xmlXPathCompile(const xmlChar *str) {
14691     return(xmlXPathCtxtCompile(NULL, str));
14692 }
14693 
14694 /**
14695  * xmlXPathCompiledEvalInternal:
</pre>
<hr />
<pre>
14812  * Parse and evaluate an XPath expression in the given context,
14813  * then push the result on the context stack
14814  */
14815 void
14816 xmlXPathEvalExpr(xmlXPathParserContextPtr ctxt) {
14817 #ifdef XPATH_STREAMING
14818     xmlXPathCompExprPtr comp;
14819 #endif
14820 
14821     if (ctxt == NULL) return;
14822 
14823 #ifdef XPATH_STREAMING
14824     comp = xmlXPathTryStreamCompile(ctxt-&gt;context, ctxt-&gt;base);
14825     if (comp != NULL) {
14826         if (ctxt-&gt;comp != NULL)
14827         xmlXPathFreeCompExpr(ctxt-&gt;comp);
14828         ctxt-&gt;comp = comp;
14829     } else
14830 #endif
14831     {


14832     xmlXPathCompileExpr(ctxt, 1);
14833         CHECK_ERROR;
14834 
14835         /* Check for trailing characters. */
14836         if (*ctxt-&gt;cur != 0)
14837             XP_ERROR(XPATH_EXPR_ERROR);
14838 
<span class="line-modified">14839     if ((ctxt-&gt;comp-&gt;nbStep &gt; 1) &amp;&amp; (ctxt-&gt;comp-&gt;last &gt;= 0))</span>
<span class="line-modified">14840         xmlXPathOptimizeExpression(ctxt-&gt;comp,</span>


14841         &amp;ctxt-&gt;comp-&gt;steps[ctxt-&gt;comp-&gt;last]);
14842     }

14843 
14844     xmlXPathRunEval(ctxt, 0);
14845 }
14846 
14847 /**
14848  * xmlXPathEval:
14849  * @str:  the XPath expression
14850  * @ctx:  the XPath context
14851  *
14852  * Evaluate the XPath Location Path in the given context.
14853  *
14854  * Returns the xmlXPathObjectPtr resulting from the evaluation or NULL.
14855  *         the caller has to free the object.
14856  */
14857 xmlXPathObjectPtr
14858 xmlXPathEval(const xmlChar *str, xmlXPathContextPtr ctx) {
14859     xmlXPathParserContextPtr ctxt;
14860     xmlXPathObjectPtr res;
14861 
14862     CHECK_CTXT(ctx)
</pre>
</td>
<td>
<hr />
<pre>
  326     */
  327     if ((precedence2 == 3) &amp;&amp; (precedence1 &gt; 1)) {
  328         cur = node1-&gt;parent;
  329         while (cur) {
  330         if (cur == node2)
  331             return(1);
  332         cur = cur-&gt;parent;
  333         }
  334     }
  335     if ((precedence1 == 3) &amp;&amp; (precedence2 &gt; 1)) {
  336         cur = node2-&gt;parent;
  337         while (cur) {
  338         if (cur == node1)
  339             return(-1);
  340         cur = cur-&gt;parent;
  341         }
  342     }
  343     }
  344 
  345     /*
<span class="line-modified">  346      * Speedup using document order if available.</span>
  347      */
  348     if ((node1-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
  349     (node2-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
  350     (0 &gt; (ptrdiff_t) node1-&gt;content) &amp;&amp;
  351     (0 &gt; (ptrdiff_t) node2-&gt;content) &amp;&amp;
  352     (node1-&gt;doc == node2-&gt;doc)) {
  353 
  354     l1 = -((ptrdiff_t) node1-&gt;content);
  355     l2 = -((ptrdiff_t) node2-&gt;content);
  356     if (l1 &lt; l2)
  357         return(1);
  358     if (l1 &gt; l2)
  359         return(-1);
  360     }
  361 
  362 turtle_comparison:
  363 
  364     if (node1 == node2-&gt;prev)
  365     return(1);
  366     if (node1 == node2-&gt;next)
</pre>
<hr />
<pre>
  394     }
  395     while (depth2 &gt; depth1) {
  396     depth2--;
  397     node2 = node2-&gt;parent;
  398     }
  399     while (node1-&gt;parent != node2-&gt;parent) {
  400     node1 = node1-&gt;parent;
  401     node2 = node2-&gt;parent;
  402     /* should not happen but just in case ... */
  403     if ((node1 == NULL) || (node2 == NULL))
  404         return(-2);
  405     }
  406     /*
  407      * Find who&#39;s first.
  408      */
  409     if (node1 == node2-&gt;prev)
  410     return(1);
  411     if (node1 == node2-&gt;next)
  412     return(-1);
  413     /*
<span class="line-modified">  414      * Speedup using document order if available.</span>
  415      */
  416     if ((node1-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
  417     (node2-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
  418     (0 &gt; (ptrdiff_t) node1-&gt;content) &amp;&amp;
  419     (0 &gt; (ptrdiff_t) node2-&gt;content) &amp;&amp;
  420     (node1-&gt;doc == node2-&gt;doc)) {
  421 
  422     l1 = -((ptrdiff_t) node1-&gt;content);
  423     l2 = -((ptrdiff_t) node2-&gt;content);
  424     if (l1 &lt; l2)
  425         return(1);
  426     if (l1 &gt; l2)
  427         return(-1);
  428     }
  429 
  430     for (cur = node1-&gt;next;cur != NULL;cur = cur-&gt;next)
  431     if (cur == node2)
  432         return(1);
  433     return(-1); /* assume there is no sibling list corruption */
  434 }
  435 #endif /* XP_OPTIMIZED_NON_ELEM_COMPARISON */
  436 
  437 /*
<span class="line-modified">  438  * Wrapper for the Timsort algorithm from timsort.h</span>
  439  */
  440 #ifdef WITH_TIM_SORT
  441 #define SORT_NAME libxml_domnode
  442 #define SORT_TYPE xmlNodePtr
  443 /**
  444  * wrap_cmp:
  445  * @x: a node
  446  * @y: another node
  447  *
  448  * Comparison function for the Timsort implementation
  449  *
  450  * Returns -2 in case of error -1 if first point &lt; second point, 0 if
  451  *         it&#39;s the same node, +1 otherwise
  452  */
  453 static
  454 int wrap_cmp( xmlNodePtr x, xmlNodePtr y );
  455 #ifdef XP_OPTIMIZED_NON_ELEM_COMPARISON
  456     static int wrap_cmp( xmlNodePtr x, xmlNodePtr y )
  457     {
  458         int res = xmlXPathCmpNodesExt(x, y);
</pre>
<hr />
<pre>
  593     &quot;Undefined variable\n&quot;,
  594     &quot;Invalid predicate\n&quot;,
  595     &quot;Invalid expression\n&quot;,
  596     &quot;Missing closing curly brace\n&quot;,
  597     &quot;Unregistered function\n&quot;,
  598     &quot;Invalid operand\n&quot;,
  599     &quot;Invalid type\n&quot;,
  600     &quot;Invalid number of arguments\n&quot;,
  601     &quot;Invalid context size\n&quot;,
  602     &quot;Invalid context position\n&quot;,
  603     &quot;Memory allocation error\n&quot;,
  604     &quot;Syntax error\n&quot;,
  605     &quot;Resource error\n&quot;,
  606     &quot;Sub resource error\n&quot;,
  607     &quot;Undefined namespace prefix\n&quot;,
  608     &quot;Encoding error\n&quot;,
  609     &quot;Char out of XML range\n&quot;,
  610     &quot;Invalid or incomplete context\n&quot;,
  611     &quot;Stack usage error\n&quot;,
  612     &quot;Forbidden variable\n&quot;,
<span class="line-added">  613     &quot;Operation limit exceeded\n&quot;,</span>
<span class="line-added">  614     &quot;Recursion limit exceeded\n&quot;,</span>
  615     &quot;?? Unknown error ??\n&quot; /* Must be last in the list! */
  616 };
  617 #define MAXERRNO ((int)(sizeof(xmlXPathErrorMessages) / \
  618            sizeof(xmlXPathErrorMessages[0])) - 1)
  619 /**
  620  * xmlXPathErrMemory:
  621  * @ctxt:  an XPath context
  622  * @extra:  extra informations
  623  *
  624  * Handle a redefinition of attribute error
  625  */
  626 static void
  627 xmlXPathErrMemory(xmlXPathContextPtr ctxt, const char *extra)
  628 {
  629     if (ctxt != NULL) {
<span class="line-added">  630         xmlResetError(&amp;ctxt-&gt;lastError);</span>
  631         if (extra) {
  632             xmlChar buf[200];
  633 
  634             xmlStrPrintf(buf, 200,
  635                          &quot;Memory allocation failed : %s\n&quot;,
  636                          extra);
  637             ctxt-&gt;lastError.message = (char *) xmlStrdup(buf);
  638         } else {
  639             ctxt-&gt;lastError.message = (char *)
  640            xmlStrdup(BAD_CAST &quot;Memory allocation failed\n&quot;);
  641         }
  642         ctxt-&gt;lastError.domain = XML_FROM_XPATH;
  643         ctxt-&gt;lastError.code = XML_ERR_NO_MEMORY;
  644     if (ctxt-&gt;error != NULL)
  645         ctxt-&gt;error(ctxt-&gt;userData, &amp;ctxt-&gt;lastError);
  646     } else {
  647         if (extra)
  648             __xmlRaiseError(NULL, NULL, NULL,
  649                             NULL, NULL, XML_FROM_XPATH,
  650                             XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0,
</pre>
<hr />
<pre>
  733             &quot;%s&quot;, xmlXPathErrorMessages[error]);
  734     }
  735 
  736 }
  737 
  738 /**
  739  * xmlXPatherror:
  740  * @ctxt:  the XPath Parser context
  741  * @file:  the file name
  742  * @line:  the line number
  743  * @no:  the error number
  744  *
  745  * Formats an error message.
  746  */
  747 void
  748 xmlXPatherror(xmlXPathParserContextPtr ctxt, const char *file ATTRIBUTE_UNUSED,
  749               int line ATTRIBUTE_UNUSED, int no) {
  750     xmlXPathErr(ctxt, no);
  751 }
  752 
<span class="line-added">  753 /**</span>
<span class="line-added">  754  * xmlXPathCheckOpLimit:</span>
<span class="line-added">  755  * @ctxt:  the XPath Parser context</span>
<span class="line-added">  756  * @opCount:  the number of operations to be added</span>
<span class="line-added">  757  *</span>
<span class="line-added">  758  * Adds opCount to the running total of operations and returns -1 if the</span>
<span class="line-added">  759  * operation limit is exceeded. Returns 0 otherwise.</span>
<span class="line-added">  760  */</span>
<span class="line-added">  761 static int</span>
<span class="line-added">  762 xmlXPathCheckOpLimit(xmlXPathParserContextPtr ctxt, unsigned long opCount) {</span>
<span class="line-added">  763     xmlXPathContextPtr xpctxt = ctxt-&gt;context;</span>
<span class="line-added">  764 </span>
<span class="line-added">  765     if ((opCount &gt; xpctxt-&gt;opLimit) ||</span>
<span class="line-added">  766         (xpctxt-&gt;opCount &gt; xpctxt-&gt;opLimit - opCount)) {</span>
<span class="line-added">  767         xpctxt-&gt;opCount = xpctxt-&gt;opLimit;</span>
<span class="line-added">  768         xmlXPathErr(ctxt, XPATH_OP_LIMIT_EXCEEDED);</span>
<span class="line-added">  769         return(-1);</span>
<span class="line-added">  770     }</span>
<span class="line-added">  771 </span>
<span class="line-added">  772     xpctxt-&gt;opCount += opCount;</span>
<span class="line-added">  773     return(0);</span>
<span class="line-added">  774 }</span>
<span class="line-added">  775 </span>
<span class="line-added">  776 #define OP_LIMIT_EXCEEDED(ctxt, n) \</span>
<span class="line-added">  777     ((ctxt-&gt;context-&gt;opLimit != 0) &amp;&amp; (xmlXPathCheckOpLimit(ctxt, n) &lt; 0))</span>
<span class="line-added">  778 </span>
  779 /************************************************************************
  780  *                                  *
  781  *          Utilities                   *
  782  *                                  *
  783  ************************************************************************/
  784 
  785 /**
  786  * xsltPointerList:
  787  *
  788  * Pointer-list for various purposes.
  789  */
  790 typedef struct _xmlPointerList xmlPointerList;
  791 typedef xmlPointerList *xmlPointerListPtr;
  792 struct _xmlPointerList {
  793     void **items;
  794     int number;
  795     int size;
  796 };
  797 /*
  798 * TODO: Since such a list-handling is used in xmlschemas.c and libxslt
</pre>
<hr />
<pre>
 1088     xmlFree(comp);
 1089 }
 1090 
 1091 /**
 1092  * xmlXPathCompExprAdd:
 1093  * @comp:  the compiled expression
 1094  * @ch1: first child index
 1095  * @ch2: second child index
 1096  * @op:  an op
 1097  * @value:  the first int value
 1098  * @value2:  the second int value
 1099  * @value3:  the third int value
 1100  * @value4:  the first string value
 1101  * @value5:  the second string value
 1102  *
 1103  * Add a step to an XPath Compiled Expression
 1104  *
 1105  * Returns -1 in case of failure, the index otherwise
 1106  */
 1107 static int
<span class="line-modified"> 1108 xmlXPathCompExprAdd(xmlXPathParserContextPtr ctxt, int ch1, int ch2,</span>
 1109    xmlXPathOp op, int value,
 1110    int value2, int value3, void *value4, void *value5) {
<span class="line-added"> 1111     xmlXPathCompExprPtr comp = ctxt-&gt;comp;</span>
 1112     if (comp-&gt;nbStep &gt;= comp-&gt;maxStep) {
 1113     xmlXPathStepOp *real;
 1114 
 1115         if (comp-&gt;maxStep &gt;= XPATH_MAX_STEPS) {
<span class="line-modified"> 1116         xmlXPathPErrMemory(ctxt, &quot;adding step\n&quot;);</span>
 1117         return(-1);
 1118         }
 1119     comp-&gt;maxStep *= 2;
 1120     real = (xmlXPathStepOp *) xmlRealloc(comp-&gt;steps,
 1121                               comp-&gt;maxStep * sizeof(xmlXPathStepOp));
 1122     if (real == NULL) {
 1123         comp-&gt;maxStep /= 2;
<span class="line-modified"> 1124         xmlXPathPErrMemory(ctxt, &quot;adding step\n&quot;);</span>
 1125         return(-1);
 1126     }
 1127     comp-&gt;steps = real;
 1128     }
 1129     comp-&gt;last = comp-&gt;nbStep;
 1130     comp-&gt;steps[comp-&gt;nbStep].ch1 = ch1;
 1131     comp-&gt;steps[comp-&gt;nbStep].ch2 = ch2;
 1132     comp-&gt;steps[comp-&gt;nbStep].op = op;
 1133     comp-&gt;steps[comp-&gt;nbStep].value = value;
 1134     comp-&gt;steps[comp-&gt;nbStep].value2 = value2;
 1135     comp-&gt;steps[comp-&gt;nbStep].value3 = value3;
 1136     if ((comp-&gt;dict != NULL) &amp;&amp;
 1137         ((op == XPATH_OP_FUNCTION) || (op == XPATH_OP_VARIABLE) ||
 1138      (op == XPATH_OP_COLLECT))) {
 1139         if (value4 != NULL) {
 1140         comp-&gt;steps[comp-&gt;nbStep].value4 = (xmlChar *)
 1141             (void *)xmlDictLookup(comp-&gt;dict, value4, -1);
 1142         xmlFree(value4);
 1143     } else
 1144         comp-&gt;steps[comp-&gt;nbStep].value4 = NULL;
</pre>
<hr />
<pre>
 1166 static void
 1167 xmlXPathCompSwap(xmlXPathStepOpPtr op) {
 1168     int tmp;
 1169 
 1170 #ifndef LIBXML_THREAD_ENABLED
 1171     /*
 1172      * Since this manipulates possibly shared variables, this is
 1173      * disabled if one detects that the library is used in a multithreaded
 1174      * application
 1175      */
 1176     if (xmlXPathDisableOptimizer)
 1177     return;
 1178 #endif
 1179 
 1180     tmp = op-&gt;ch1;
 1181     op-&gt;ch1 = op-&gt;ch2;
 1182     op-&gt;ch2 = tmp;
 1183 }
 1184 
 1185 #define PUSH_FULL_EXPR(op, op1, op2, val, val2, val3, val4, val5)   \
<span class="line-modified"> 1186     xmlXPathCompExprAdd(ctxt, (op1), (op2),         \</span>
 1187                     (op), (val), (val2), (val3), (val4), (val5))
 1188 #define PUSH_LONG_EXPR(op, val, val2, val3, val4, val5)         \
<span class="line-modified"> 1189     xmlXPathCompExprAdd(ctxt, ctxt-&gt;comp-&gt;last, -1,     \</span>
 1190                     (op), (val), (val2), (val3), (val4), (val5))
 1191 
 1192 #define PUSH_LEAVE_EXPR(op, val, val2)                  \
<span class="line-modified"> 1193 xmlXPathCompExprAdd(ctxt, -1, -1, (op), (val), (val2), 0 ,NULL ,NULL)</span>
 1194 
 1195 #define PUSH_UNARY_EXPR(op, ch, val, val2)              \
<span class="line-modified"> 1196 xmlXPathCompExprAdd(ctxt, (ch), -1, (op), (val), (val2), 0 ,NULL ,NULL)</span>
 1197 
 1198 #define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)           \
<span class="line-modified"> 1199 xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),           \</span>
 1200             (val), (val2), 0 ,NULL ,NULL)
 1201 
 1202 /************************************************************************
 1203  *                                  *
 1204  *      XPath object cache structures               *
 1205  *                                  *
 1206  ************************************************************************/
 1207 
 1208 /* #define XP_DEFAULT_CACHE_ON */
 1209 
 1210 #define XP_HAS_CACHE(c) ((c != NULL) &amp;&amp; ((c)-&gt;cache != NULL))
 1211 
 1212 typedef struct _xmlXPathContextCache xmlXPathContextCache;
 1213 typedef xmlXPathContextCache *xmlXPathContextCachePtr;
 1214 struct _xmlXPathContextCache {
 1215     xmlPointerListPtr nodesetObjs;  /* contains xmlXPathObjectPtr */
 1216     xmlPointerListPtr stringObjs;   /* contains xmlXPathObjectPtr */
 1217     xmlPointerListPtr booleanObjs;  /* contains xmlXPathObjectPtr */
 1218     xmlPointerListPtr numberObjs;   /* contains xmlXPathObjectPtr */
 1219     xmlPointerListPtr miscObjs;     /* contains xmlXPathObjectPtr */
</pre>
<hr />
<pre>
 2239     if (cache == NULL)
 2240     return;
 2241     if (cache-&gt;nodesetObjs)
 2242     xmlXPathCacheFreeObjectList(cache-&gt;nodesetObjs);
 2243     if (cache-&gt;stringObjs)
 2244     xmlXPathCacheFreeObjectList(cache-&gt;stringObjs);
 2245     if (cache-&gt;booleanObjs)
 2246     xmlXPathCacheFreeObjectList(cache-&gt;booleanObjs);
 2247     if (cache-&gt;numberObjs)
 2248     xmlXPathCacheFreeObjectList(cache-&gt;numberObjs);
 2249     if (cache-&gt;miscObjs)
 2250     xmlXPathCacheFreeObjectList(cache-&gt;miscObjs);
 2251     xmlFree(cache);
 2252 }
 2253 
 2254 /**
 2255  * xmlXPathContextSetCache:
 2256  *
 2257  * @ctxt:  the XPath context
 2258  * @active: enables/disables (creates/frees) the cache
<span class="line-modified"> 2259  * @value: a value with semantics dependent on @options</span>
 2260  * @options: options (currently only the value 0 is used)
 2261  *
 2262  * Creates/frees an object cache on the XPath context.
 2263  * If activates XPath objects (xmlXPathObject) will be cached internally
 2264  * to be reused.
 2265  * @options:
 2266  *   0: This will set the XPath object caching:
 2267  *      @value:
 2268  *        This will set the maximum number of XPath objects
 2269  *        to be cached per slot
 2270  *        There are 5 slots for: node-set, string, number, boolean, and
 2271  *        misc objects. Use &lt;0 for the default number (100).
 2272  *   Other values for @options have currently no effect.
 2273  *
 2274  * Returns 0 if the setting succeeded, and -1 on API or internal errors.
 2275  */
 2276 int
 2277 xmlXPathContextSetCache(xmlXPathContextPtr ctxt,
 2278             int active,
 2279             int value,
</pre>
<hr />
<pre>
 2399  * @ctxt: the XPath context
 2400  * @val:  the NodePtr value
 2401  *
 2402  * This is the cached version of xmlXPathNewNodeSet().
 2403  * Acquire an xmlXPathObjectPtr of type NodeSet and initialize
 2404  * it with the single Node @val
 2405  *
 2406  * Returns the created or reused object.
 2407  */
 2408 static xmlXPathObjectPtr
 2409 xmlXPathCacheNewNodeSet(xmlXPathContextPtr ctxt, xmlNodePtr val)
 2410 {
 2411     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;cache)) {
 2412     xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt-&gt;cache;
 2413 
 2414     if ((cache-&gt;nodesetObjs != NULL) &amp;&amp;
 2415         (cache-&gt;nodesetObjs-&gt;number != 0))
 2416     {
 2417         xmlXPathObjectPtr ret;
 2418         /*
<span class="line-modified"> 2419         * Use the nodeset-cache.</span>
 2420         */
 2421         ret = (xmlXPathObjectPtr)
 2422         cache-&gt;nodesetObjs-&gt;items[--cache-&gt;nodesetObjs-&gt;number];
 2423         ret-&gt;type = XPATH_NODESET;
 2424         ret-&gt;boolval = 0;
 2425         if (val) {
 2426         if ((ret-&gt;nodesetval-&gt;nodeMax == 0) ||
 2427             (val-&gt;type == XML_NAMESPACE_DECL))
 2428         {
<span class="line-added"> 2429                     /* TODO: Check memory error. */</span>
 2430             xmlXPathNodeSetAddUnique(ret-&gt;nodesetval, val);
 2431         } else {
 2432             ret-&gt;nodesetval-&gt;nodeTab[0] = val;
 2433             ret-&gt;nodesetval-&gt;nodeNr = 1;
 2434         }
 2435         }
 2436 #ifdef XP_DEBUG_OBJ_USAGE
 2437         xmlXPathDebugObjUsageRequested(ctxt, XPATH_NODESET);
 2438 #endif
 2439         return(ret);
 2440     } else if ((cache-&gt;miscObjs != NULL) &amp;&amp;
 2441         (cache-&gt;miscObjs-&gt;number != 0))
 2442     {
 2443         xmlXPathObjectPtr ret;
 2444         /*
 2445         * Fallback to misc-cache.
 2446         */
 2447 
 2448         ret = (xmlXPathObjectPtr)
 2449         cache-&gt;miscObjs-&gt;items[--cache-&gt;miscObjs-&gt;number];
</pre>
<hr />
<pre>
 2856 
 2857     if (ctxt-&gt;valueNr &lt;= ctxt-&gt;valueFrame) {
 2858         xmlXPatherror(ctxt, __FILE__, __LINE__, XPATH_STACK_ERROR);
 2859         return (NULL);
 2860     }
 2861 
 2862     ctxt-&gt;valueNr--;
 2863     if (ctxt-&gt;valueNr &gt; 0)
 2864         ctxt-&gt;value = ctxt-&gt;valueTab[ctxt-&gt;valueNr - 1];
 2865     else
 2866         ctxt-&gt;value = NULL;
 2867     ret = ctxt-&gt;valueTab[ctxt-&gt;valueNr];
 2868     ctxt-&gt;valueTab[ctxt-&gt;valueNr] = NULL;
 2869     return (ret);
 2870 }
 2871 /**
 2872  * valuePush:
 2873  * @ctxt:  an XPath evaluation context
 2874  * @value:  the XPath object
 2875  *
<span class="line-modified"> 2876  * Pushes a new XPath object on top of the value stack. If value is NULL,</span>
<span class="line-added"> 2877  * a memory error is recorded in the parser context.</span>
 2878  *
<span class="line-modified"> 2879  * Returns the number of items on the value stack, or -1 in case of error.</span>
 2880  */
 2881 int
 2882 valuePush(xmlXPathParserContextPtr ctxt, xmlXPathObjectPtr value)
 2883 {
<span class="line-modified"> 2884     if (ctxt == NULL) return(-1);</span>
<span class="line-added"> 2885     if (value == NULL) {</span>
<span class="line-added"> 2886         /*</span>
<span class="line-added"> 2887          * A NULL value typically indicates that a memory allocation failed,</span>
<span class="line-added"> 2888          * so we set ctxt-&gt;error here to propagate the error.</span>
<span class="line-added"> 2889          */</span>
<span class="line-added"> 2890     ctxt-&gt;error = XPATH_MEMORY_ERROR;</span>
<span class="line-added"> 2891         return(-1);</span>
<span class="line-added"> 2892     }</span>
 2893     if (ctxt-&gt;valueNr &gt;= ctxt-&gt;valueMax) {
 2894         xmlXPathObjectPtr *tmp;
 2895 
 2896         if (ctxt-&gt;valueMax &gt;= XPATH_MAX_STACK_DEPTH) {
<span class="line-modified"> 2897             xmlXPathPErrMemory(ctxt, &quot;XPath stack depth limit reached\n&quot;);</span>
<span class="line-modified"> 2898             return (-1);</span>

 2899         }
 2900         tmp = (xmlXPathObjectPtr *) xmlRealloc(ctxt-&gt;valueTab,
 2901                                              2 * ctxt-&gt;valueMax *
 2902                                              sizeof(ctxt-&gt;valueTab[0]));
 2903         if (tmp == NULL) {
<span class="line-modified"> 2904             xmlXPathPErrMemory(ctxt, &quot;pushing value\n&quot;);</span>
<span class="line-modified"> 2905             return (-1);</span>

 2906         }
 2907         ctxt-&gt;valueMax *= 2;
 2908     ctxt-&gt;valueTab = tmp;
 2909     }
 2910     ctxt-&gt;valueTab[ctxt-&gt;valueNr] = value;
 2911     ctxt-&gt;value = value;
 2912     return (ctxt-&gt;valueNr++);
 2913 }
 2914 
 2915 /**
 2916  * xmlXPathPopBoolean:
 2917  * @ctxt:  an XPath parser context
 2918  *
 2919  * Pops a boolean from the stack, handling conversion if needed.
 2920  * Check error with #xmlXPathCheckError.
 2921  *
 2922  * Returns the boolean
 2923  */
 2924 int
 2925 xmlXPathPopBoolean (xmlXPathParserContextPtr ctxt) {
</pre>
<hr />
<pre>
 3341                 return (1);
 3342             cur = cur-&gt;prev;
 3343         }
 3344         return (-1);
 3345         }
 3346         return(0);
 3347     }
 3348     if (attr2 == 1)
 3349         return(1);
 3350     return(-1);
 3351     }
 3352     if ((node1-&gt;type == XML_NAMESPACE_DECL) ||
 3353         (node2-&gt;type == XML_NAMESPACE_DECL))
 3354     return(1);
 3355     if (node1 == node2-&gt;prev)
 3356     return(1);
 3357     if (node1 == node2-&gt;next)
 3358     return(-1);
 3359 
 3360     /*
<span class="line-modified"> 3361      * Speedup using document order if available.</span>
 3362      */
 3363     if ((node1-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
 3364     (node2-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
 3365     (0 &gt; (ptrdiff_t) node1-&gt;content) &amp;&amp;
 3366     (0 &gt; (ptrdiff_t) node2-&gt;content) &amp;&amp;
 3367     (node1-&gt;doc == node2-&gt;doc)) {
 3368     ptrdiff_t l1, l2;
 3369 
 3370     l1 = -((ptrdiff_t) node1-&gt;content);
 3371     l2 = -((ptrdiff_t) node2-&gt;content);
 3372     if (l1 &lt; l2)
 3373         return(1);
 3374     if (l1 &gt; l2)
 3375         return(-1);
 3376     }
 3377 
 3378     /*
 3379      * compute depth to root
 3380      */
 3381     for (depth2 = 0, cur = node2;cur-&gt;parent != NULL;cur = cur-&gt;parent) {
</pre>
<hr />
<pre>
 3404     }
 3405     while (depth2 &gt; depth1) {
 3406     depth2--;
 3407     node2 = node2-&gt;parent;
 3408     }
 3409     while (node1-&gt;parent != node2-&gt;parent) {
 3410     node1 = node1-&gt;parent;
 3411     node2 = node2-&gt;parent;
 3412     /* should not happen but just in case ... */
 3413     if ((node1 == NULL) || (node2 == NULL))
 3414         return(-2);
 3415     }
 3416     /*
 3417      * Find who&#39;s first.
 3418      */
 3419     if (node1 == node2-&gt;prev)
 3420     return(1);
 3421     if (node1 == node2-&gt;next)
 3422     return(-1);
 3423     /*
<span class="line-modified"> 3424      * Speedup using document order if available.</span>
 3425      */
 3426     if ((node1-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
 3427     (node2-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
 3428     (0 &gt; (ptrdiff_t) node1-&gt;content) &amp;&amp;
 3429     (0 &gt; (ptrdiff_t) node2-&gt;content) &amp;&amp;
 3430     (node1-&gt;doc == node2-&gt;doc)) {
 3431     ptrdiff_t l1, l2;
 3432 
 3433     l1 = -((ptrdiff_t) node1-&gt;content);
 3434     l2 = -((ptrdiff_t) node2-&gt;content);
 3435     if (l1 &lt; l2)
 3436         return(1);
 3437     if (l1 &gt; l2)
 3438         return(-1);
 3439     }
 3440 
 3441     for (cur = node1-&gt;next;cur != NULL;cur = cur-&gt;next)
 3442     if (cur == node2)
 3443         return(1);
 3444     return(-1); /* assume there is no sibling list corruption */
</pre>
<hr />
<pre>
 3568     ret = (xmlNodeSetPtr) xmlMalloc(sizeof(xmlNodeSet));
 3569     if (ret == NULL) {
 3570         xmlXPathErrMemory(NULL, &quot;creating nodeset\n&quot;);
 3571     return(NULL);
 3572     }
 3573     memset(ret, 0 , (size_t) sizeof(xmlNodeSet));
 3574     if (val != NULL) {
 3575         ret-&gt;nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *
 3576                          sizeof(xmlNodePtr));
 3577     if (ret-&gt;nodeTab == NULL) {
 3578         xmlXPathErrMemory(NULL, &quot;creating nodeset\n&quot;);
 3579         xmlFree(ret);
 3580         return(NULL);
 3581     }
 3582     memset(ret-&gt;nodeTab, 0 ,
 3583            XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));
 3584         ret-&gt;nodeMax = XML_NODESET_DEFAULT;
 3585     if (val-&gt;type == XML_NAMESPACE_DECL) {
 3586         xmlNsPtr ns = (xmlNsPtr) val;
 3587 
<span class="line-added"> 3588             /* TODO: Check memory error. */</span>
 3589         ret-&gt;nodeTab[ret-&gt;nodeNr++] =
 3590         xmlXPathNodeSetDupNs((xmlNodePtr) ns-&gt;next, ns);
 3591     } else
 3592         ret-&gt;nodeTab[ret-&gt;nodeNr++] = val;
 3593     }
 3594     return(ret);
 3595 }
 3596 































 3597 /**
 3598  * xmlXPathNodeSetContains:
 3599  * @cur:  the node-set
 3600  * @val:  the node
 3601  *
 3602  * checks whether @cur contains @val
 3603  *
 3604  * Returns true (1) if @cur contains @val, false (0) otherwise
 3605  */
 3606 int
 3607 xmlXPathNodeSetContains (xmlNodeSetPtr cur, xmlNodePtr val) {
 3608     int i;
 3609 
 3610     if ((cur == NULL) || (val == NULL)) return(0);
 3611     if (val-&gt;type == XML_NAMESPACE_DECL) {
 3612     for (i = 0; i &lt; cur-&gt;nodeNr; i++) {
 3613         if (cur-&gt;nodeTab[i]-&gt;type == XML_NAMESPACE_DECL) {
 3614         xmlNsPtr ns1, ns2;
 3615 
 3616         ns1 = (xmlNsPtr) val;
</pre>
<hr />
<pre>
 3675     }
 3676     memset(cur-&gt;nodeTab, 0 ,
 3677            XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));
 3678         cur-&gt;nodeMax = XML_NODESET_DEFAULT;
 3679     } else if (cur-&gt;nodeNr == cur-&gt;nodeMax) {
 3680         xmlNodePtr *temp;
 3681 
 3682         if (cur-&gt;nodeMax &gt;= XPATH_MAX_NODESET_LENGTH) {
 3683             xmlXPathErrMemory(NULL, &quot;growing nodeset hit limit\n&quot;);
 3684             return(-1);
 3685         }
 3686     temp = (xmlNodePtr *) xmlRealloc(cur-&gt;nodeTab, cur-&gt;nodeMax * 2 *
 3687                       sizeof(xmlNodePtr));
 3688     if (temp == NULL) {
 3689         xmlXPathErrMemory(NULL, &quot;growing nodeset\n&quot;);
 3690         return(-1);
 3691     }
 3692         cur-&gt;nodeMax *= 2;
 3693     cur-&gt;nodeTab = temp;
 3694     }
<span class="line-added"> 3695     /* TODO: Check memory error. */</span>
 3696     cur-&gt;nodeTab[cur-&gt;nodeNr++] = xmlXPathNodeSetDupNs(node, ns);
 3697     return(0);
 3698 }
 3699 
 3700 /**
 3701  * xmlXPathNodeSetAdd:
 3702  * @cur:  the initial node set
 3703  * @val:  a new xmlNodePtr
 3704  *
 3705  * add a new xmlNodePtr to an existing NodeSet
 3706  *
 3707  * Returns 0 in case of success, and -1 in case of error
 3708  */
 3709 int
 3710 xmlXPathNodeSetAdd(xmlNodeSetPtr cur, xmlNodePtr val) {
 3711     int i;
 3712 
 3713     if ((cur == NULL) || (val == NULL)) return(-1);
 3714 
 3715     /* @@ with_ns to check whether namespace nodes should be looked at @@ */
</pre>
<hr />
<pre>
 3734         cur-&gt;nodeMax = XML_NODESET_DEFAULT;
 3735     } else if (cur-&gt;nodeNr == cur-&gt;nodeMax) {
 3736         xmlNodePtr *temp;
 3737 
 3738         if (cur-&gt;nodeMax &gt;= XPATH_MAX_NODESET_LENGTH) {
 3739             xmlXPathErrMemory(NULL, &quot;growing nodeset hit limit\n&quot;);
 3740             return(-1);
 3741         }
 3742     temp = (xmlNodePtr *) xmlRealloc(cur-&gt;nodeTab, cur-&gt;nodeMax * 2 *
 3743                       sizeof(xmlNodePtr));
 3744     if (temp == NULL) {
 3745         xmlXPathErrMemory(NULL, &quot;growing nodeset\n&quot;);
 3746         return(-1);
 3747     }
 3748         cur-&gt;nodeMax *= 2;
 3749     cur-&gt;nodeTab = temp;
 3750     }
 3751     if (val-&gt;type == XML_NAMESPACE_DECL) {
 3752     xmlNsPtr ns = (xmlNsPtr) val;
 3753 
<span class="line-added"> 3754         /* TODO: Check memory error. */</span>
 3755     cur-&gt;nodeTab[cur-&gt;nodeNr++] =
 3756         xmlXPathNodeSetDupNs((xmlNodePtr) ns-&gt;next, ns);
 3757     } else
 3758     cur-&gt;nodeTab[cur-&gt;nodeNr++] = val;
 3759     return(0);
 3760 }
 3761 
 3762 /**
 3763  * xmlXPathNodeSetAddUnique:
 3764  * @cur:  the initial node set
 3765  * @val:  a new xmlNodePtr
 3766  *
 3767  * add a new xmlNodePtr to an existing NodeSet, optimized version
 3768  * when we are sure the node is not already in the set.
 3769  *
 3770  * Returns 0 in case of success and -1 in case of failure
 3771  */
 3772 int
 3773 xmlXPathNodeSetAddUnique(xmlNodeSetPtr cur, xmlNodePtr val) {
 3774     if ((cur == NULL) || (val == NULL)) return(-1);
</pre>
<hr />
<pre>
 3789         cur-&gt;nodeMax = XML_NODESET_DEFAULT;
 3790     } else if (cur-&gt;nodeNr == cur-&gt;nodeMax) {
 3791         xmlNodePtr *temp;
 3792 
 3793         if (cur-&gt;nodeMax &gt;= XPATH_MAX_NODESET_LENGTH) {
 3794             xmlXPathErrMemory(NULL, &quot;growing nodeset hit limit\n&quot;);
 3795             return(-1);
 3796         }
 3797     temp = (xmlNodePtr *) xmlRealloc(cur-&gt;nodeTab, cur-&gt;nodeMax * 2 *
 3798                       sizeof(xmlNodePtr));
 3799     if (temp == NULL) {
 3800         xmlXPathErrMemory(NULL, &quot;growing nodeset\n&quot;);
 3801         return(-1);
 3802     }
 3803     cur-&gt;nodeTab = temp;
 3804         cur-&gt;nodeMax *= 2;
 3805     }
 3806     if (val-&gt;type == XML_NAMESPACE_DECL) {
 3807     xmlNsPtr ns = (xmlNsPtr) val;
 3808 
<span class="line-added"> 3809         /* TODO: Check memory error. */</span>
 3810     cur-&gt;nodeTab[cur-&gt;nodeNr++] =
 3811         xmlXPathNodeSetDupNs((xmlNodePtr) ns-&gt;next, ns);
 3812     } else
 3813     cur-&gt;nodeTab[cur-&gt;nodeNr++] = val;
 3814     return(0);
 3815 }
 3816 
 3817 /**
 3818  * xmlXPathNodeSetMerge:
 3819  * @val1:  the first NodeSet or NULL
 3820  * @val2:  the second NodeSet
 3821  *
 3822  * Merges two nodesets, all nodes from @val2 are added to @val1
 3823  * if @val1 is NULL, a new set is created and copied from @val2
 3824  *
 3825  * Returns @val1 once extended or NULL in case of error.
 3826  */
 3827 xmlNodeSetPtr
 3828 xmlXPathNodeSetMerge(xmlNodeSetPtr val1, xmlNodeSetPtr val2) {
 3829     int i, j, initNr, skip;
 3830     xmlNodePtr n1, n2;
 3831 
 3832     if (val2 == NULL) return(val1);
 3833     if (val1 == NULL) {
 3834     val1 = xmlXPathNodeSetCreate(NULL);
 3835     if (val1 == NULL)
 3836         return (NULL);
 3837 #if 0
 3838     /*
 3839     * TODO: The optimization won&#39;t work in every case, since
 3840     *  those nasty namespace nodes need to be added with
 3841     *  xmlXPathNodeSetDupNs() to the set; thus a pure
 3842     *  memcpy is not possible.
 3843     *  If there was a flag on the nodesetval, indicating that
<span class="line-modified"> 3844     *  some temporary nodes are in, that would be helpful.</span>
 3845     */
 3846     /*
 3847     * Optimization: Create an equally sized node-set
 3848     * and memcpy the content.
 3849     */
 3850     val1 = xmlXPathNodeSetCreateSize(val2-&gt;nodeNr);
 3851     if (val1 == NULL)
 3852         return(NULL);
 3853     if (val2-&gt;nodeNr != 0) {
 3854         if (val2-&gt;nodeNr == 1)
 3855         *(val1-&gt;nodeTab) = *(val2-&gt;nodeTab);
 3856         else {
 3857         memcpy(val1-&gt;nodeTab, val2-&gt;nodeTab,
 3858             val2-&gt;nodeNr * sizeof(xmlNodePtr));
 3859         }
 3860         val1-&gt;nodeNr = val2-&gt;nodeNr;
 3861     }
 3862     return(val1);
 3863 #endif
 3864     }
</pre>
<hr />
<pre>
 3906         val1-&gt;nodeMax = XML_NODESET_DEFAULT;
 3907     } else if (val1-&gt;nodeNr == val1-&gt;nodeMax) {
 3908         xmlNodePtr *temp;
 3909 
 3910             if (val1-&gt;nodeMax &gt;= XPATH_MAX_NODESET_LENGTH) {
 3911                 xmlXPathErrMemory(NULL, &quot;merging nodeset hit limit\n&quot;);
 3912                 return(NULL);
 3913             }
 3914         temp = (xmlNodePtr *) xmlRealloc(val1-&gt;nodeTab, val1-&gt;nodeMax * 2 *
 3915                          sizeof(xmlNodePtr));
 3916         if (temp == NULL) {
 3917             xmlXPathErrMemory(NULL, &quot;merging nodeset\n&quot;);
 3918         return(NULL);
 3919         }
 3920         val1-&gt;nodeTab = temp;
 3921         val1-&gt;nodeMax *= 2;
 3922     }
 3923     if (n2-&gt;type == XML_NAMESPACE_DECL) {
 3924         xmlNsPtr ns = (xmlNsPtr) n2;
 3925 
<span class="line-added"> 3926             /* TODO: Check memory error. */</span>
 3927         val1-&gt;nodeTab[val1-&gt;nodeNr++] =
 3928         xmlXPathNodeSetDupNs((xmlNodePtr) ns-&gt;next, ns);
 3929     } else
 3930         val1-&gt;nodeTab[val1-&gt;nodeNr++] = n2;
 3931     }
 3932 
 3933     return(val1);
 3934 }
 3935 
 3936 
 3937 /**
 3938  * xmlXPathNodeSetMergeAndClear:
 3939  * @set1:  the first NodeSet or NULL
 3940  * @set2:  the second NodeSet

 3941  *
<span class="line-modified"> 3942  * Merges two nodesets, all nodes from @set2 are added to @set1.</span>

 3943  * Checks for duplicate nodes. Clears set2.
 3944  *
 3945  * Returns @set1 once extended or NULL in case of error.
 3946  */
 3947 static xmlNodeSetPtr
<span class="line-modified"> 3948 xmlXPathNodeSetMergeAndClear(xmlNodeSetPtr set1, xmlNodeSetPtr set2)</span>
<span class="line-modified"> 3949 {</span>
 3950 {














 3951     int i, j, initNbSet1;
 3952     xmlNodePtr n1, n2;
 3953 





 3954     initNbSet1 = set1-&gt;nodeNr;
 3955     for (i = 0;i &lt; set2-&gt;nodeNr;i++) {
 3956         n2 = set2-&gt;nodeTab[i];
 3957         /*





 3958         * Skip duplicates.
 3959         */
 3960         for (j = 0; j &lt; initNbSet1; j++) {
 3961         n1 = set1-&gt;nodeTab[j];
 3962         if (n1 == n2) {
 3963             goto skip_node;
 3964         } else if ((n1-&gt;type == XML_NAMESPACE_DECL) &amp;&amp;
 3965             (n2-&gt;type == XML_NAMESPACE_DECL))
 3966         {
 3967             if ((((xmlNsPtr) n1)-&gt;next == ((xmlNsPtr) n2)-&gt;next) &amp;&amp;
 3968             (xmlStrEqual(((xmlNsPtr) n1)-&gt;prefix,
 3969             ((xmlNsPtr) n2)-&gt;prefix)))
 3970             {
 3971             /*
 3972             * Free the namespace node.
 3973             */
 3974             set2-&gt;nodeTab[i] = NULL;
 3975             xmlXPathNodeSetFreeNs((xmlNsPtr) n2);
 3976             goto skip_node;
 3977             }
</pre>
<hr />
<pre>
 4002         if (temp == NULL) {
 4003             xmlXPathErrMemory(NULL, &quot;merging nodeset\n&quot;);
 4004             return(NULL);
 4005         }
 4006         set1-&gt;nodeTab = temp;
 4007         set1-&gt;nodeMax *= 2;
 4008         }
 4009         set1-&gt;nodeTab[set1-&gt;nodeNr++] = n2;
 4010 skip_node:
 4011         {}
 4012     }
 4013     }
 4014     set2-&gt;nodeNr = 0;
 4015     return(set1);
 4016 }
 4017 
 4018 /**
 4019  * xmlXPathNodeSetMergeAndClearNoDupls:
 4020  * @set1:  the first NodeSet or NULL
 4021  * @set2:  the second NodeSet

 4022  *
<span class="line-modified"> 4023  * Merges two nodesets, all nodes from @set2 are added to @set1.</span>
<span class="line-modified"> 4024  * Doesn&#39;t check for duplicate nodes. Clears set2.</span>

 4025  *
 4026  * Returns @set1 once extended or NULL in case of error.
 4027  */
 4028 static xmlNodeSetPtr
<span class="line-modified"> 4029 xmlXPathNodeSetMergeAndClearNoDupls(xmlNodeSetPtr set1, xmlNodeSetPtr set2)</span>
<span class="line-modified"> 4030 {</span>
 4031 {
















 4032     int i;
 4033     xmlNodePtr n2;
 4034 





 4035     for (i = 0;i &lt; set2-&gt;nodeNr;i++) {
 4036         n2 = set2-&gt;nodeTab[i];





 4037         if (set1-&gt;nodeMax == 0) {
 4038         set1-&gt;nodeTab = (xmlNodePtr *) xmlMalloc(
 4039             XML_NODESET_DEFAULT * sizeof(xmlNodePtr));
 4040         if (set1-&gt;nodeTab == NULL) {
 4041             xmlXPathErrMemory(NULL, &quot;merging nodeset\n&quot;);
 4042             return(NULL);
 4043         }
 4044         memset(set1-&gt;nodeTab, 0,
 4045             XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));
 4046         set1-&gt;nodeMax = XML_NODESET_DEFAULT;
 4047         } else if (set1-&gt;nodeNr &gt;= set1-&gt;nodeMax) {
 4048         xmlNodePtr *temp;
 4049 
 4050                 if (set1-&gt;nodeMax &gt;= XPATH_MAX_NODESET_LENGTH) {
 4051                     xmlXPathErrMemory(NULL, &quot;merging nodeset hit limit\n&quot;);
 4052                     return(NULL);
 4053                 }
 4054         temp = (xmlNodePtr *) xmlRealloc(
 4055             set1-&gt;nodeTab, set1-&gt;nodeMax * 2 * sizeof(xmlNodePtr));
 4056         if (temp == NULL) {
</pre>
<hr />
<pre>
 4287  * xmlXPathNewNodeSet:
 4288  * @val:  the NodePtr value
 4289  *
 4290  * Create a new xmlXPathObjectPtr of type NodeSet and initialize
 4291  * it with the single Node @val
 4292  *
 4293  * Returns the newly created object.
 4294  */
 4295 xmlXPathObjectPtr
 4296 xmlXPathNewNodeSet(xmlNodePtr val) {
 4297     xmlXPathObjectPtr ret;
 4298 
 4299     ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
 4300     if (ret == NULL) {
 4301         xmlXPathErrMemory(NULL, &quot;creating nodeset\n&quot;);
 4302     return(NULL);
 4303     }
 4304     memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
 4305     ret-&gt;type = XPATH_NODESET;
 4306     ret-&gt;boolval = 0;
<span class="line-added"> 4307     /* TODO: Check memory error. */</span>
 4308     ret-&gt;nodesetval = xmlXPathNodeSetCreate(val);
 4309     /* @@ with_ns to check whether namespace nodes should be looked at @@ */
 4310 #ifdef XP_DEBUG_OBJ_USAGE
 4311     xmlXPathDebugObjUsageRequested(NULL, XPATH_NODESET);
 4312 #endif
 4313     return(ret);
 4314 }
 4315 
 4316 /**
 4317  * xmlXPathNewValueTree:
 4318  * @val:  the NodePtr value
 4319  *
 4320  * Create a new xmlXPathObjectPtr of type Value Tree (XSLT) and initialize
 4321  * it with the tree root @val
 4322  *
 4323  * Returns the newly created object.
 4324  */
 4325 xmlXPathObjectPtr
 4326 xmlXPathNewValueTree(xmlNodePtr val) {
 4327     xmlXPathObjectPtr ret;
</pre>
<hr />
<pre>
 4348  *
 4349  * Create a new xmlXPathObjectPtr of type NodeSet and initialize
 4350  * it with the Nodeset @val
 4351  *
 4352  * Returns the newly created object.
 4353  */
 4354 xmlXPathObjectPtr
 4355 xmlXPathNewNodeSetList(xmlNodeSetPtr val)
 4356 {
 4357     xmlXPathObjectPtr ret;
 4358     int i;
 4359 
 4360     if (val == NULL)
 4361         ret = NULL;
 4362     else if (val-&gt;nodeTab == NULL)
 4363         ret = xmlXPathNewNodeSet(NULL);
 4364     else {
 4365         ret = xmlXPathNewNodeSet(val-&gt;nodeTab[0]);
 4366         if (ret) {
 4367             for (i = 1; i &lt; val-&gt;nodeNr; ++i) {
<span class="line-added"> 4368                 /* TODO: Propagate memory error. */</span>
 4369                 if (xmlXPathNodeSetAddUnique(ret-&gt;nodesetval, val-&gt;nodeTab[i])
 4370             &lt; 0) break;
 4371         }
 4372     }
 4373     }
 4374 
 4375     return (ret);
 4376 }
 4377 
 4378 /**
 4379  * xmlXPathWrapNodeSet:
 4380  * @val:  the NodePtr value
 4381  *
 4382  * Wrap the Nodeset @val in a new xmlXPathObjectPtr
 4383  *
 4384  * Returns the newly created object.
 4385  */
 4386 xmlXPathObjectPtr
 4387 xmlXPathWrapNodeSet(xmlNodeSetPtr val) {
 4388     xmlXPathObjectPtr ret;
</pre>
<hr />
<pre>
 4420 /**
 4421  * xmlXPathDifference:
 4422  * @nodes1:  a node-set
 4423  * @nodes2:  a node-set
 4424  *
 4425  * Implements the EXSLT - Sets difference() function:
 4426  *    node-set set:difference (node-set, node-set)
 4427  *
 4428  * Returns the difference between the two node sets, or nodes1 if
 4429  *         nodes2 is empty
 4430  */
 4431 xmlNodeSetPtr
 4432 xmlXPathDifference (xmlNodeSetPtr nodes1, xmlNodeSetPtr nodes2) {
 4433     xmlNodeSetPtr ret;
 4434     int i, l1;
 4435     xmlNodePtr cur;
 4436 
 4437     if (xmlXPathNodeSetIsEmpty(nodes2))
 4438     return(nodes1);
 4439 
<span class="line-added"> 4440     /* TODO: Check memory error. */</span>
 4441     ret = xmlXPathNodeSetCreate(NULL);
 4442     if (xmlXPathNodeSetIsEmpty(nodes1))
 4443     return(ret);
 4444 
 4445     l1 = xmlXPathNodeSetGetLength(nodes1);
 4446 
 4447     for (i = 0; i &lt; l1; i++) {
 4448     cur = xmlXPathNodeSetItem(nodes1, i);
 4449     if (!xmlXPathNodeSetContains(nodes2, cur)) {
<span class="line-added"> 4450             /* TODO: Propagate memory error. */</span>
 4451         if (xmlXPathNodeSetAddUnique(ret, cur) &lt; 0)
 4452             break;
 4453     }
 4454     }
 4455     return(ret);
 4456 }
 4457 
 4458 /**
 4459  * xmlXPathIntersection:
 4460  * @nodes1:  a node-set
 4461  * @nodes2:  a node-set
 4462  *
 4463  * Implements the EXSLT - Sets intersection() function:
 4464  *    node-set set:intersection (node-set, node-set)
 4465  *
 4466  * Returns a node set comprising the nodes that are within both the
 4467  *         node sets passed as arguments
 4468  */
 4469 xmlNodeSetPtr
 4470 xmlXPathIntersection (xmlNodeSetPtr nodes1, xmlNodeSetPtr nodes2) {
 4471     xmlNodeSetPtr ret = xmlXPathNodeSetCreate(NULL);
 4472     int i, l1;
 4473     xmlNodePtr cur;
 4474 
 4475     if (ret == NULL)
 4476         return(ret);
 4477     if (xmlXPathNodeSetIsEmpty(nodes1))
 4478     return(ret);
 4479     if (xmlXPathNodeSetIsEmpty(nodes2))
 4480     return(ret);
 4481 
 4482     l1 = xmlXPathNodeSetGetLength(nodes1);
 4483 
 4484     for (i = 0; i &lt; l1; i++) {
 4485     cur = xmlXPathNodeSetItem(nodes1, i);
 4486     if (xmlXPathNodeSetContains(nodes2, cur)) {
<span class="line-added"> 4487             /* TODO: Propagate memory error. */</span>
 4488         if (xmlXPathNodeSetAddUnique(ret, cur) &lt; 0)
 4489             break;
 4490     }
 4491     }
 4492     return(ret);
 4493 }
 4494 
 4495 /**
 4496  * xmlXPathDistinctSorted:
 4497  * @nodes:  a node-set, sorted by document order
 4498  *
 4499  * Implements the EXSLT - Sets distinct() function:
 4500  *    node-set set:distinct (node-set)
 4501  *
 4502  * Returns a subset of the nodes contained in @nodes, or @nodes if
 4503  *         it is empty
 4504  */
 4505 xmlNodeSetPtr
 4506 xmlXPathDistinctSorted (xmlNodeSetPtr nodes) {
 4507     xmlNodeSetPtr ret;
 4508     xmlHashTablePtr hash;
 4509     int i, l;
 4510     xmlChar * strval;
 4511     xmlNodePtr cur;
 4512 
 4513     if (xmlXPathNodeSetIsEmpty(nodes))
 4514     return(nodes);
 4515 
 4516     ret = xmlXPathNodeSetCreate(NULL);
 4517     if (ret == NULL)
 4518         return(ret);
 4519     l = xmlXPathNodeSetGetLength(nodes);
 4520     hash = xmlHashCreate (l);
 4521     for (i = 0; i &lt; l; i++) {
 4522     cur = xmlXPathNodeSetItem(nodes, i);
 4523     strval = xmlXPathCastNodeToString(cur);
 4524     if (xmlHashLookup(hash, strval) == NULL) {
 4525         xmlHashAddEntry(hash, strval, strval);
<span class="line-added"> 4526             /* TODO: Propagate memory error. */</span>
 4527         if (xmlXPathNodeSetAddUnique(ret, cur) &lt; 0)
 4528             break;
 4529     } else {
 4530         xmlFree(strval);
 4531     }
 4532     }
 4533     xmlHashFree(hash, xmlHashDefaultDeallocator);
 4534     return(ret);
 4535 }
 4536 
 4537 /**
 4538  * xmlXPathDistinct:
 4539  * @nodes:  a node-set
 4540  *
 4541  * Implements the EXSLT - Sets distinct() function:
 4542  *    node-set set:distinct (node-set)
 4543  * @nodes is sorted by document order, then #exslSetsDistinctSorted
 4544  * is called with the sorted node-set
 4545  *
 4546  * Returns a subset of the nodes contained in @nodes, or @nodes if
</pre>
<hr />
<pre>
 4600 xmlXPathNodeLeadingSorted (xmlNodeSetPtr nodes, xmlNodePtr node) {
 4601     int i, l;
 4602     xmlNodePtr cur;
 4603     xmlNodeSetPtr ret;
 4604 
 4605     if (node == NULL)
 4606     return(nodes);
 4607 
 4608     ret = xmlXPathNodeSetCreate(NULL);
 4609     if (ret == NULL)
 4610         return(ret);
 4611     if (xmlXPathNodeSetIsEmpty(nodes) ||
 4612     (!xmlXPathNodeSetContains(nodes, node)))
 4613     return(ret);
 4614 
 4615     l = xmlXPathNodeSetGetLength(nodes);
 4616     for (i = 0; i &lt; l; i++) {
 4617     cur = xmlXPathNodeSetItem(nodes, i);
 4618     if (cur == node)
 4619         break;
<span class="line-added"> 4620         /* TODO: Propagate memory error. */</span>
 4621     if (xmlXPathNodeSetAddUnique(ret, cur) &lt; 0)
 4622         break;
 4623     }
 4624     return(ret);
 4625 }
 4626 
 4627 /**
 4628  * xmlXPathNodeLeading:
 4629  * @nodes:  a node-set
 4630  * @node:  a node
 4631  *
 4632  * Implements the EXSLT - Sets leading() function:
 4633  *    node-set set:leading (node-set, node-set)
 4634  * @nodes is sorted by document order, then #exslSetsNodeLeadingSorted
 4635  * is called.
 4636  *
 4637  * Returns the nodes in @nodes that precede @node in document order,
 4638  *         @nodes if @node is NULL or an empty node-set if @nodes
 4639  *         doesn&#39;t contain @node
 4640  */
</pre>
<hr />
<pre>
 4706 xmlXPathNodeTrailingSorted (xmlNodeSetPtr nodes, xmlNodePtr node) {
 4707     int i, l;
 4708     xmlNodePtr cur;
 4709     xmlNodeSetPtr ret;
 4710 
 4711     if (node == NULL)
 4712     return(nodes);
 4713 
 4714     ret = xmlXPathNodeSetCreate(NULL);
 4715     if (ret == NULL)
 4716         return(ret);
 4717     if (xmlXPathNodeSetIsEmpty(nodes) ||
 4718     (!xmlXPathNodeSetContains(nodes, node)))
 4719     return(ret);
 4720 
 4721     l = xmlXPathNodeSetGetLength(nodes);
 4722     for (i = l - 1; i &gt;= 0; i--) {
 4723     cur = xmlXPathNodeSetItem(nodes, i);
 4724     if (cur == node)
 4725         break;
<span class="line-added"> 4726         /* TODO: Propagate memory error. */</span>
 4727     if (xmlXPathNodeSetAddUnique(ret, cur) &lt; 0)
 4728         break;
 4729     }
 4730     xmlXPathNodeSetSort(ret);   /* bug 413451 */
 4731     return(ret);
 4732 }
 4733 
 4734 /**
 4735  * xmlXPathNodeTrailing:
 4736  * @nodes:  a node-set
 4737  * @node:  a node
 4738  *
 4739  * Implements the EXSLT - Sets trailing() function:
 4740  *    node-set set:trailing (node-set, node-set)
 4741  * @nodes is sorted by document order, then #xmlXPathNodeTrailingSorted
 4742  * is called.
 4743  *
 4744  * Returns the nodes in @nodes that follow @node in document order,
 4745  *         @nodes if @node is NULL or an empty node-set if @nodes
 4746  *         doesn&#39;t contain @node
</pre>
<hr />
<pre>
 5406         top-&gt;name = (char *)
 5407             xmlStrdup(val-&gt;nodesetval-&gt;nodeTab[0]-&gt;name);
 5408         ret-&gt;user = top;
 5409         if (top != NULL) {
 5410             top-&gt;doc = top;
 5411             cur = val-&gt;nodesetval-&gt;nodeTab[0]-&gt;children;
 5412             while (cur != NULL) {
 5413             tmp = xmlDocCopyNode(cur, top, 1);
 5414             xmlAddChild((xmlNodePtr) top, tmp);
 5415             cur = cur-&gt;next;
 5416             }
 5417         }
 5418 
 5419         ret-&gt;nodesetval = xmlXPathNodeSetCreate((xmlNodePtr) top);
 5420         } else
 5421         ret-&gt;nodesetval = xmlXPathNodeSetCreate(NULL);
 5422         /* Deallocate the copied tree value */
 5423         break;
 5424 #endif
 5425     case XPATH_NODESET:
<span class="line-added"> 5426             /* TODO: Check memory error. */</span>
 5427         ret-&gt;nodesetval = xmlXPathNodeSetMerge(NULL, val-&gt;nodesetval);
 5428         /* Do not deallocate the copied tree value */
 5429         ret-&gt;boolval = 0;
 5430         break;
 5431     case XPATH_LOCATIONSET:
 5432 #ifdef LIBXML_XPTR_ENABLED
 5433     {
 5434         xmlLocationSetPtr loc = val-&gt;user;
 5435         ret-&gt;user = (void *) xmlXPtrLocationSetMerge(NULL, loc);
 5436         break;
 5437     }
 5438 #endif
 5439         case XPATH_USERS:
 5440         ret-&gt;user = val-&gt;user;
 5441         break;
 5442         case XPATH_UNDEFINED:
 5443         xmlGenericError(xmlGenericErrorContext,
 5444             &quot;xmlXPathObjectCopy: unsupported type %d\n&quot;,
 5445             val-&gt;type);
 5446         break;
</pre>
<hr />
<pre>
 5894     xmlFree(str);
 5895     return(ret);
 5896 }
 5897 
 5898 /**
 5899  * xmlXPathCastToNumber:
 5900  * @val:  an XPath object
 5901  *
 5902  * Converts an XPath object to its number value
 5903  *
 5904  * Returns the number value
 5905  */
 5906 double
 5907 xmlXPathCastToNumber(xmlXPathObjectPtr val) {
 5908     double ret = 0.0;
 5909 
 5910     if (val == NULL)
 5911     return(NAN);
 5912     switch (val-&gt;type) {
 5913     case XPATH_UNDEFINED:
<span class="line-modified"> 5914 #ifdef DEBUG_EXPR</span>
 5915     xmlGenericError(xmlGenericErrorContext, &quot;NUMBER: undefined\n&quot;);
 5916 #endif
 5917     ret = NAN;
 5918     break;
 5919     case XPATH_NODESET:
 5920     case XPATH_XSLT_TREE:
 5921     ret = xmlXPathCastNodeSetToNumber(val-&gt;nodesetval);
 5922     break;
 5923     case XPATH_STRING:
 5924     ret = xmlXPathCastStringToNumber(val-&gt;stringval);
 5925     break;
 5926     case XPATH_NUMBER:
 5927     ret = val-&gt;floatval;
 5928     break;
 5929     case XPATH_BOOLEAN:
 5930     ret = xmlXPathCastBooleanToNumber(val-&gt;boolval);
 5931     break;
 5932     case XPATH_USERS:
 5933     case XPATH_POINT:
 5934     case XPATH_RANGE:
</pre>
<hr />
<pre>
 6103     ret-&gt;node = NULL;
 6104 
 6105     ret-&gt;varHash = NULL;
 6106 
 6107     ret-&gt;nb_types = 0;
 6108     ret-&gt;max_types = 0;
 6109     ret-&gt;types = NULL;
 6110 
 6111     ret-&gt;funcHash = xmlHashCreate(0);
 6112 
 6113     ret-&gt;nb_axis = 0;
 6114     ret-&gt;max_axis = 0;
 6115     ret-&gt;axis = NULL;
 6116 
 6117     ret-&gt;nsHash = NULL;
 6118     ret-&gt;user = NULL;
 6119 
 6120     ret-&gt;contextSize = -1;
 6121     ret-&gt;proximityPosition = -1;
 6122 
<span class="line-added"> 6123     ret-&gt;maxDepth = INT_MAX;</span>
<span class="line-added"> 6124     ret-&gt;maxParserDepth = INT_MAX;</span>
<span class="line-added"> 6125 </span>
 6126 #ifdef XP_DEFAULT_CACHE_ON
 6127     if (xmlXPathContextSetCache(ret, 1, -1, 0) == -1) {
 6128     xmlXPathFreeContext(ret);
 6129     return(NULL);
 6130     }
 6131 #endif
 6132 
 6133     xmlXPathRegisterAllFunctions(ret);
 6134 
 6135     return(ret);
 6136 }
 6137 
 6138 /**
 6139  * xmlXPathFreeContext:
 6140  * @ctxt:  the context to free
 6141  *
 6142  * Free up an xmlXPathContext
 6143  */
 6144 void
 6145 xmlXPathFreeContext(xmlXPathContextPtr ctxt) {
</pre>
<hr />
<pre>
 6596     xmlXPathFreeObject(arg2);
 6597         return(0);
 6598     }
 6599 
 6600     ns1 = arg1-&gt;nodesetval;
 6601     ns2 = arg2-&gt;nodesetval;
 6602 
 6603     if ((ns1 == NULL) || (ns1-&gt;nodeNr &lt;= 0)) {
 6604     xmlXPathFreeObject(arg1);
 6605     xmlXPathFreeObject(arg2);
 6606     return(0);
 6607     }
 6608     if ((ns2 == NULL) || (ns2-&gt;nodeNr &lt;= 0)) {
 6609     xmlXPathFreeObject(arg1);
 6610     xmlXPathFreeObject(arg2);
 6611     return(0);
 6612     }
 6613 
 6614     values2 = (double *) xmlMalloc(ns2-&gt;nodeNr * sizeof(double));
 6615     if (values2 == NULL) {
<span class="line-added"> 6616         /* TODO: Propagate memory error. */</span>
 6617         xmlXPathErrMemory(NULL, &quot;comparing nodesets\n&quot;);
 6618     xmlXPathFreeObject(arg1);
 6619     xmlXPathFreeObject(arg2);
 6620     return(0);
 6621     }
 6622     for (i = 0;i &lt; ns1-&gt;nodeNr;i++) {
 6623     val1 = xmlXPathCastNodeToNumber(ns1-&gt;nodeTab[i]);
 6624     if (xmlXPathIsNaN(val1))
 6625         continue;
 6626     for (j = 0;j &lt; ns2-&gt;nodeNr;j++) {
 6627         if (init == 0) {
 6628         values2[j] = xmlXPathCastNodeToNumber(ns2-&gt;nodeTab[j]);
 6629         }
 6630         if (xmlXPathIsNaN(values2[j]))
 6631         continue;
 6632         if (inf &amp;&amp; strict)
 6633         ret = (val1 &lt; values2[j]);
 6634         else if (inf &amp;&amp; !strict)
 6635         ret = (val1 &lt;= values2[j]);
 6636         else if (!inf &amp;&amp; strict)
</pre>
<hr />
<pre>
 6857 
 6858     ns1 = arg1-&gt;nodesetval;
 6859     ns2 = arg2-&gt;nodesetval;
 6860 
 6861     if ((ns1 == NULL) || (ns1-&gt;nodeNr &lt;= 0))
 6862     return(0);
 6863     if ((ns2 == NULL) || (ns2-&gt;nodeNr &lt;= 0))
 6864     return(0);
 6865 
 6866     /*
 6867      * for equal, check if there is a node pertaining to both sets
 6868      */
 6869     if (neq == 0)
 6870     for (i = 0;i &lt; ns1-&gt;nodeNr;i++)
 6871         for (j = 0;j &lt; ns2-&gt;nodeNr;j++)
 6872         if (ns1-&gt;nodeTab[i] == ns2-&gt;nodeTab[j])
 6873             return(1);
 6874 
 6875     values1 = (xmlChar **) xmlMalloc(ns1-&gt;nodeNr * sizeof(xmlChar *));
 6876     if (values1 == NULL) {
<span class="line-added"> 6877         /* TODO: Propagate memory error. */</span>
 6878         xmlXPathErrMemory(NULL, &quot;comparing nodesets\n&quot;);
 6879     return(0);
 6880     }
 6881     hashs1 = (unsigned int *) xmlMalloc(ns1-&gt;nodeNr * sizeof(unsigned int));
 6882     if (hashs1 == NULL) {
<span class="line-added"> 6883         /* TODO: Propagate memory error. */</span>
 6884         xmlXPathErrMemory(NULL, &quot;comparing nodesets\n&quot;);
 6885     xmlFree(values1);
 6886     return(0);
 6887     }
 6888     memset(values1, 0, ns1-&gt;nodeNr * sizeof(xmlChar *));
 6889     values2 = (xmlChar **) xmlMalloc(ns2-&gt;nodeNr * sizeof(xmlChar *));
 6890     if (values2 == NULL) {
<span class="line-added"> 6891         /* TODO: Propagate memory error. */</span>
 6892         xmlXPathErrMemory(NULL, &quot;comparing nodesets\n&quot;);
 6893     xmlFree(hashs1);
 6894     xmlFree(values1);
 6895     return(0);
 6896     }
 6897     hashs2 = (unsigned int *) xmlMalloc(ns2-&gt;nodeNr * sizeof(unsigned int));
 6898     if (hashs2 == NULL) {
<span class="line-added"> 6899         /* TODO: Propagate memory error. */</span>
 6900         xmlXPathErrMemory(NULL, &quot;comparing nodesets\n&quot;);
 6901     xmlFree(hashs1);
 6902     xmlFree(values1);
 6903     xmlFree(values2);
 6904     return(0);
 6905     }
 6906     memset(values2, 0, ns2-&gt;nodeNr * sizeof(xmlChar *));
 6907     for (i = 0;i &lt; ns1-&gt;nodeNr;i++) {
 6908     hashs1[i] = xmlXPathNodeValHash(ns1-&gt;nodeTab[i]);
 6909     for (j = 0;j &lt; ns2-&gt;nodeNr;j++) {
 6910         if (i == 0)
 6911         hashs2[j] = xmlXPathNodeValHash(ns2-&gt;nodeTab[j]);
 6912         if (hashs1[i] != hashs2[j]) {
 6913         if (neq) {
 6914             ret = 1;
 6915             break;
 6916         }
 6917         }
 6918         else {
 6919         if (values1[i] == NULL)
</pre>
<hr />
<pre>
 7509     double val;
 7510 
 7511     arg = valuePop(ctxt);
 7512     if (arg == NULL)
 7513     XP_ERROR(XPATH_INVALID_OPERAND);
 7514     val = xmlXPathCastToNumber(arg);
 7515     xmlXPathReleaseObject(ctxt-&gt;context, arg);
 7516     CAST_TO_NUMBER;
 7517     CHECK_TYPE(XPATH_NUMBER);
 7518     ctxt-&gt;value-&gt;floatval *= val;
 7519 }
 7520 
 7521 /**
 7522  * xmlXPathDivValues:
 7523  * @ctxt:  the XPath Parser context
 7524  *
 7525  * Implement the div operation on XPath objects @arg1 / @arg2:
 7526  * The numeric operators convert their operands to numbers as if
 7527  * by calling the number function.
 7528  */
<span class="line-added"> 7529 ATTRIBUTE_NO_SANITIZE(&quot;float-divide-by-zero&quot;)</span>
 7530 void
 7531 xmlXPathDivValues(xmlXPathParserContextPtr ctxt) {
 7532     xmlXPathObjectPtr arg;
 7533     double val;
 7534 
 7535     arg = valuePop(ctxt);
 7536     if (arg == NULL)
 7537     XP_ERROR(XPATH_INVALID_OPERAND);
 7538     val = xmlXPathCastToNumber(arg);
 7539     xmlXPathReleaseObject(ctxt-&gt;context, arg);
 7540     CAST_TO_NUMBER;
 7541     CHECK_TYPE(XPATH_NUMBER);
 7542     ctxt-&gt;value-&gt;floatval /= val;
 7543 }
 7544 
 7545 /**
 7546  * xmlXPathModValues:
 7547  * @ctxt:  the XPath Parser context
 7548  *
 7549  * Implement the mod operation on XPath objects: @arg1 / @arg2
</pre>
<hr />
<pre>
 7582  * termination on the axis by returning NULL.
 7583  */
 7584 typedef xmlNodePtr (*xmlXPathTraversalFunction)
 7585                     (xmlXPathParserContextPtr ctxt, xmlNodePtr cur);
 7586 
 7587 /*
 7588  * xmlXPathTraversalFunctionExt:
 7589  * A traversal function enumerates nodes along an axis.
 7590  * Initially it must be called with NULL, and it indicates
 7591  * termination on the axis by returning NULL.
 7592  * The context node of the traversal is specified via @contextNode.
 7593  */
 7594 typedef xmlNodePtr (*xmlXPathTraversalFunctionExt)
 7595                     (xmlNodePtr cur, xmlNodePtr contextNode);
 7596 
 7597 /*
 7598  * xmlXPathNodeSetMergeFunction:
 7599  * Used for merging node sets in xmlXPathCollectAndTest().
 7600  */
 7601 typedef xmlNodeSetPtr (*xmlXPathNodeSetMergeFunction)
<span class="line-modified"> 7602             (xmlNodeSetPtr, xmlNodeSetPtr);</span>
 7603 
 7604 
 7605 /**
 7606  * xmlXPathNextSelf:
 7607  * @ctxt:  the XPath Parser context
 7608  * @cur:  the current node in the traversal
 7609  *
 7610  * Traversal function for the &quot;self&quot; direction
 7611  * The self axis contains just the context node itself
 7612  *
 7613  * Returns the next element following that axis
 7614  */
 7615 xmlNodePtr
 7616 xmlXPathNextSelf(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
 7617     if ((ctxt == NULL) || (ctxt-&gt;context == NULL)) return(NULL);
 7618     if (cur == NULL)
 7619         return(ctxt-&gt;context-&gt;node);
 7620     return(NULL);
 7621 }
 7622 
</pre>
<hr />
<pre>
 8521  * xmlXPathCountFunction:
 8522  * @ctxt:  the XPath Parser context
 8523  * @nargs:  the number of arguments
 8524  *
 8525  * Implement the count() XPath function
 8526  *    number count(node-set)
 8527  */
 8528 void
 8529 xmlXPathCountFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 8530     xmlXPathObjectPtr cur;
 8531 
 8532     CHECK_ARITY(1);
 8533     if ((ctxt-&gt;value == NULL) ||
 8534     ((ctxt-&gt;value-&gt;type != XPATH_NODESET) &amp;&amp;
 8535      (ctxt-&gt;value-&gt;type != XPATH_XSLT_TREE)))
 8536     XP_ERROR(XPATH_INVALID_TYPE);
 8537     cur = valuePop(ctxt);
 8538 
 8539     if ((cur == NULL) || (cur-&gt;nodesetval == NULL))
 8540     valuePush(ctxt, xmlXPathCacheNewFloat(ctxt-&gt;context, (double) 0));
<span class="line-modified"> 8541     else</span>
 8542     valuePush(ctxt, xmlXPathCacheNewFloat(ctxt-&gt;context,
 8543         (double) cur-&gt;nodesetval-&gt;nodeNr));



















 8544     xmlXPathReleaseObject(ctxt-&gt;context, cur);
 8545 }
 8546 
 8547 /**
 8548  * xmlXPathGetElementsByIds:
 8549  * @doc:  the document
 8550  * @ids:  a whitespace separated list of IDs
 8551  *
 8552  * Selects elements by their unique ID.
 8553  *
 8554  * Returns a node-set of selected elements.
 8555  */
 8556 static xmlNodeSetPtr
 8557 xmlXPathGetElementsByIds (xmlDocPtr doc, const xmlChar *ids) {
 8558     xmlNodeSetPtr ret;
 8559     const xmlChar *cur = ids;
 8560     xmlChar *ID;
 8561     xmlAttrPtr attr;
 8562     xmlNodePtr elem = NULL;
 8563 
 8564     if (ids == NULL) return(NULL);
 8565 
 8566     ret = xmlXPathNodeSetCreate(NULL);
 8567     if (ret == NULL)
 8568         return(ret);
 8569 
 8570     while (IS_BLANK_CH(*cur)) cur++;
 8571     while (*cur != 0) {
 8572     while ((!IS_BLANK_CH(*cur)) &amp;&amp; (*cur != 0))
 8573         cur++;
 8574 
 8575         ID = xmlStrndup(ids, cur - ids);
 8576     if (ID != NULL) {
 8577         /*
 8578          * We used to check the fact that the value passed
 8579          * was an NCName, but this generated much troubles for
 8580          * me and Aleksey Sanin, people blatantly violated that
<span class="line-modified"> 8581          * constraint, like Visa3D spec.</span>
 8582          * if (xmlValidateNCName(ID, 1) == 0)
 8583          */
 8584         attr = xmlGetID(doc, ID);
 8585         if (attr != NULL) {
 8586         if (attr-&gt;type == XML_ATTRIBUTE_NODE)
 8587             elem = attr-&gt;parent;
 8588         else if (attr-&gt;type == XML_ELEMENT_NODE)
 8589             elem = (xmlNodePtr) attr;
 8590         else
 8591             elem = NULL;
<span class="line-added"> 8592                 /* TODO: Check memory error. */</span>
 8593         if (elem != NULL)
 8594             xmlXPathNodeSetAdd(ret, elem);
 8595         }
 8596         xmlFree(ID);
 8597     }
 8598 
 8599     while (IS_BLANK_CH(*cur)) cur++;
 8600     ids = cur;
 8601     }
 8602     return(ret);
 8603 }
 8604 
 8605 /**
 8606  * xmlXPathIdFunction:
 8607  * @ctxt:  the XPath Parser context
 8608  * @nargs:  the number of arguments
 8609  *
 8610  * Implement the id() XPath function
 8611  *    node-set id(object)
 8612  * The id function selects elements by their unique ID
</pre>
<hr />
<pre>
 8616  * argument to id is of any other type, the argument is converted to a
 8617  * string as if by a call to the string function; the string is split
 8618  * into a whitespace-separated list of tokens (whitespace is any sequence
 8619  * of characters matching the production S); the result is a node-set
 8620  * containing the elements in the same document as the context node that
 8621  * have a unique ID equal to any of the tokens in the list.
 8622  */
 8623 void
 8624 xmlXPathIdFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 8625     xmlChar *tokens;
 8626     xmlNodeSetPtr ret;
 8627     xmlXPathObjectPtr obj;
 8628 
 8629     CHECK_ARITY(1);
 8630     obj = valuePop(ctxt);
 8631     if (obj == NULL) XP_ERROR(XPATH_INVALID_OPERAND);
 8632     if ((obj-&gt;type == XPATH_NODESET) || (obj-&gt;type == XPATH_XSLT_TREE)) {
 8633     xmlNodeSetPtr ns;
 8634     int i;
 8635 
<span class="line-added"> 8636         /* TODO: Check memory error. */</span>
 8637     ret = xmlXPathNodeSetCreate(NULL);





 8638 
 8639     if (obj-&gt;nodesetval != NULL) {
 8640         for (i = 0; i &lt; obj-&gt;nodesetval-&gt;nodeNr; i++) {
 8641         tokens =
 8642             xmlXPathCastNodeToString(obj-&gt;nodesetval-&gt;nodeTab[i]);
 8643         ns = xmlXPathGetElementsByIds(ctxt-&gt;context-&gt;doc, tokens);
<span class="line-added"> 8644                 /* TODO: Check memory error. */</span>
 8645         ret = xmlXPathNodeSetMerge(ret, ns);
 8646         xmlXPathFreeNodeSet(ns);
 8647         if (tokens != NULL)
 8648             xmlFree(tokens);
 8649         }
 8650     }
 8651     xmlXPathReleaseObject(ctxt-&gt;context, obj);
 8652     valuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt-&gt;context, ret));
 8653     return;
 8654     }
 8655     obj = xmlXPathCacheConvertString(ctxt-&gt;context, obj);
<span class="line-added"> 8656     if (obj == NULL) return;</span>
 8657     ret = xmlXPathGetElementsByIds(ctxt-&gt;context-&gt;doc, obj-&gt;stringval);
 8658     valuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt-&gt;context, ret));
 8659     xmlXPathReleaseObject(ctxt-&gt;context, obj);
 8660     return;
 8661 }
 8662 
 8663 /**
 8664  * xmlXPathLocalNameFunction:
 8665  * @ctxt:  the XPath Parser context
 8666  * @nargs:  the number of arguments
 8667  *
 8668  * Implement the local-name() XPath function
 8669  *    string local-name(node-set?)
 8670  * The local-name function returns a string containing the local part
 8671  * of the name of the node in the argument node-set that is first in
 8672  * document order. If the node-set is empty or the first node has no
 8673  * name, an empty string is returned. If the argument is omitted it
 8674  * defaults to the context node.
 8675  */
 8676 void
</pre>
<hr />
<pre>
 9074  * in the second argument and continuing to the end of the string. For
 9075  * example, substring(&quot;12345&quot;,2) returns &quot;2345&quot;.  More precisely, each
 9076  * character in the string (see [3.6 Strings]) is considered to have a
 9077  * numeric position: the position of the first character is 1, the position
 9078  * of the second character is 2 and so on. The returned substring contains
 9079  * those characters for which the position of the character is greater than
 9080  * or equal to the second argument and, if the third argument is specified,
 9081  * less than the sum of the second and third arguments; the comparisons
 9082  * and addition used for the above follow the standard IEEE 754 rules. Thus:
 9083  *  - substring(&quot;12345&quot;, 1.5, 2.6) returns &quot;234&quot;
 9084  *  - substring(&quot;12345&quot;, 0, 3) returns &quot;12&quot;
 9085  *  - substring(&quot;12345&quot;, 0 div 0, 3) returns &quot;&quot;
 9086  *  - substring(&quot;12345&quot;, 1, 0 div 0) returns &quot;&quot;
 9087  *  - substring(&quot;12345&quot;, -42, 1 div 0) returns &quot;12345&quot;
 9088  *  - substring(&quot;12345&quot;, -1 div 0, 1 div 0) returns &quot;&quot;
 9089  */
 9090 void
 9091 xmlXPathSubstringFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 9092     xmlXPathObjectPtr str, start, len;
 9093     double le=0, in;
<span class="line-modified"> 9094     int i = 1, j = INT_MAX;</span>

 9095 
 9096     if (nargs &lt; 2) {
 9097     CHECK_ARITY(2);
 9098     }
 9099     if (nargs &gt; 3) {
 9100     CHECK_ARITY(3);
 9101     }
 9102     /*
 9103      * take care of possible last (position) argument
 9104     */
 9105     if (nargs == 3) {
 9106     CAST_TO_NUMBER;
 9107     CHECK_TYPE(XPATH_NUMBER);
 9108     len = valuePop(ctxt);
 9109     le = len-&gt;floatval;
 9110     xmlXPathReleaseObject(ctxt-&gt;context, len);
 9111     }
 9112 
 9113     CAST_TO_NUMBER;
 9114     CHECK_TYPE(XPATH_NUMBER);
 9115     start = valuePop(ctxt);
 9116     in = start-&gt;floatval;
 9117     xmlXPathReleaseObject(ctxt-&gt;context, start);
 9118     CAST_TO_STRING;
 9119     CHECK_TYPE(XPATH_STRING);
 9120     str = valuePop(ctxt);










 9121 
<span class="line-modified"> 9122     if (!(in &lt; INT_MAX)) { /* Logical NOT to handle NaNs */</span>
<span class="line-modified"> 9123         i = INT_MAX;</span>
<span class="line-modified"> 9124     } else if (in &gt;= 1.0) {</span>










 9125         i = (int) in;
<span class="line-modified"> 9126         if (in - floor(in) &gt;= 0.5)</span>
<span class="line-modified"> 9127             i += 1;</span>










 9128     }
 9129 
<span class="line-modified"> 9130     if (nargs == 3) {</span>
<span class="line-modified"> 9131         double rin, rle, end;</span>
<span class="line-modified"> 9132 </span>
<span class="line-modified"> 9133         rin = floor(in);</span>
<span class="line-modified"> 9134         if (in - rin &gt;= 0.5)</span>
<span class="line-modified"> 9135             rin += 1.0;</span>

 9136 
<span class="line-modified"> 9137         rle = floor(le);</span>
<span class="line-modified"> 9138         if (le - rle &gt;= 0.5)</span>
<span class="line-added"> 9139             rle += 1.0;</span>
 9140 
<span class="line-modified"> 9141         end = rin + rle;</span>
<span class="line-added"> 9142         if (!(end &gt;= 1.0)) { /* Logical NOT to handle NaNs */</span>
<span class="line-added"> 9143             j = 1;</span>
<span class="line-added"> 9144         } else if (end &lt; INT_MAX) {</span>
<span class="line-added"> 9145             j = (int)end;</span>
 9146     }


 9147     }
<span class="line-modified"> 9148 </span>
<span class="line-modified"> 9149     if (i &lt; j) {</span>
<span class="line-modified"> 9150         xmlChar *ret = xmlUTF8Strsub(str-&gt;stringval, i - 1, j - i);</span>
 9151     valuePush(ctxt, xmlXPathCacheNewString(ctxt-&gt;context, ret));
 9152     xmlFree(ret);
<span class="line-added"> 9153     } else {</span>
<span class="line-added"> 9154     valuePush(ctxt, xmlXPathCacheNewCString(ctxt-&gt;context, &quot;&quot;));</span>
 9155     }
<span class="line-added"> 9156 </span>
 9157     xmlXPathReleaseObject(ctxt-&gt;context, str);
 9158 }
 9159 
 9160 /**
 9161  * xmlXPathSubstringBeforeFunction:
 9162  * @ctxt:  the XPath Parser context
 9163  * @nargs:  the number of arguments
 9164  *
 9165  * Implement the substring-before() XPath function
 9166  *    string substring-before(string, string)
 9167  * The substring-before function returns the substring of the first
 9168  * argument string that precedes the first occurrence of the second
 9169  * argument string in the first argument string, or the empty string
 9170  * if the first argument string does not contain the second argument
 9171  * string. For example, substring-before(&quot;1999/04/01&quot;,&quot;/&quot;) returns 1999.
 9172  */
 9173 void
 9174 xmlXPathSubstringBeforeFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 9175   xmlXPathObjectPtr str;
 9176   xmlXPathObjectPtr find;
</pre>
<hr />
<pre>
 9595 
 9596     ctxt-&gt;value-&gt;floatval = floor(ctxt-&gt;value-&gt;floatval);
 9597 }
 9598 
 9599 /**
 9600  * xmlXPathCeilingFunction:
 9601  * @ctxt:  the XPath Parser context
 9602  * @nargs:  the number of arguments
 9603  *
 9604  * Implement the ceiling() XPath function
 9605  *    number ceiling(number)
 9606  * The ceiling function returns the smallest (closest to negative infinity)
 9607  * number that is not less than the argument and that is an integer.
 9608  */
 9609 void
 9610 xmlXPathCeilingFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 9611     CHECK_ARITY(1);
 9612     CAST_TO_NUMBER;
 9613     CHECK_TYPE(XPATH_NUMBER);
 9614 
<span class="line-added"> 9615 #ifdef _AIX</span>
<span class="line-added"> 9616     /* Work around buggy ceil() function on AIX */</span>
<span class="line-added"> 9617     ctxt-&gt;value-&gt;floatval = copysign(ceil(ctxt-&gt;value-&gt;floatval), ctxt-&gt;value-&gt;floatval);</span>
<span class="line-added"> 9618 #else</span>
 9619     ctxt-&gt;value-&gt;floatval = ceil(ctxt-&gt;value-&gt;floatval);
<span class="line-added"> 9620 #endif</span>
 9621 }
 9622 
 9623 /**
 9624  * xmlXPathRoundFunction:
 9625  * @ctxt:  the XPath Parser context
 9626  * @nargs:  the number of arguments
 9627  *
 9628  * Implement the round() XPath function
 9629  *    number round(number)
 9630  * The round function returns the number that is closest to the
 9631  * argument and that is an integer. If there are two such numbers,
 9632  * then the one that is closest to positive infinity is returned.
 9633  */
 9634 void
 9635 xmlXPathRoundFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 9636     double f;
 9637 
 9638     CHECK_ARITY(1);
 9639     CAST_TO_NUMBER;
 9640     CHECK_TYPE(XPATH_NUMBER);
</pre>
<hr />
<pre>
 9917          * Okay someone managed to make a huge name, so he&#39;s ready to pay
 9918          * for the processing speed.
 9919          */
 9920         xmlChar *buffer;
 9921         int max = len * 2;
 9922 
 9923             if (len &gt; XML_MAX_NAME_LENGTH) {
 9924                 XP_ERRORNULL(XPATH_EXPR_ERROR);
 9925             }
 9926         buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));
 9927         if (buffer == NULL) {
 9928         XP_ERRORNULL(XPATH_MEMORY_ERROR);
 9929         }
 9930         memcpy(buffer, buf, len);
 9931         while ((IS_LETTER(c)) || (IS_DIGIT(c)) || /* test bigname.xml */
 9932            (c == &#39;.&#39;) || (c == &#39;-&#39;) ||
 9933            (c == &#39;_&#39;) || ((qualified) &amp;&amp; (c == &#39;:&#39;)) ||
 9934            (IS_COMBINING(c)) ||
 9935            (IS_EXTENDER(c))) {
 9936         if (len + 10 &gt; max) {
<span class="line-added"> 9937                     xmlChar *tmp;</span>
 9938                     if (max &gt; XML_MAX_NAME_LENGTH) {
<span class="line-added"> 9939                         xmlFree(buffer);</span>
 9940                         XP_ERRORNULL(XPATH_EXPR_ERROR);
 9941                     }
 9942             max *= 2;
<span class="line-modified"> 9943             tmp = (xmlChar *) xmlRealloc(buffer,</span>
 9944                                         max * sizeof(xmlChar));
<span class="line-modified"> 9945             if (tmp == NULL) {</span>
<span class="line-added"> 9946                         xmlFree(buffer);</span>
 9947             XP_ERRORNULL(XPATH_MEMORY_ERROR);
 9948             }
<span class="line-added"> 9949                     buffer = tmp;</span>
 9950         }
 9951         COPY_BUF(l,buffer,len,c);
 9952         NEXTL(l);
 9953         c = CUR_CHAR(l);
 9954         }
 9955         buffer[len] = 0;
 9956         return(buffer);
 9957     }
 9958     }
 9959     if (len == 0)
 9960     return(NULL);
 9961     return(xmlStrndup(buf, len));
 9962 }
 9963 
 9964 #define MAX_FRAC 20
 9965 
 9966 /**
 9967  * xmlXPathStringEvalNumber:
 9968  * @str:  A string to scan
 9969  *
</pre>
<hr />
<pre>
10821  *
10822  *  [24]   RelationalExpr ::=   AdditiveExpr
10823  *                 | RelationalExpr &#39;&lt;&#39; AdditiveExpr
10824  *                 | RelationalExpr &#39;&gt;&#39; AdditiveExpr
10825  *                 | RelationalExpr &#39;&lt;=&#39; AdditiveExpr
10826  *                 | RelationalExpr &#39;&gt;=&#39; AdditiveExpr
10827  *
10828  *  A &lt;= B &gt; C is allowed ? Answer from James, yes with
10829  *  (AdditiveExpr &lt;= AdditiveExpr) &gt; AdditiveExpr
10830  *  which is basically what got implemented.
10831  *
10832  * Compile a Relational expression, then push the result
10833  * on the stack
10834  */
10835 
10836 static void
10837 xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {
10838     xmlXPathCompAdditiveExpr(ctxt);
10839     CHECK_ERROR;
10840     SKIP_BLANKS;
<span class="line-modified">10841     while ((CUR == &#39;&lt;&#39;) || (CUR == &#39;&gt;&#39;)) {</span>



10842     int inf, strict;
10843     int op1 = ctxt-&gt;comp-&gt;last;
10844 
10845         if (CUR == &#39;&lt;&#39;) inf = 1;
10846     else inf = 0;
10847     if (NXT(1) == &#39;=&#39;) strict = 0;
10848     else strict = 1;
10849     NEXT;
10850     if (!strict) NEXT;
10851     SKIP_BLANKS;
10852         xmlXPathCompAdditiveExpr(ctxt);
10853     CHECK_ERROR;
10854     PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt-&gt;comp-&gt;last, inf, strict);
10855     SKIP_BLANKS;
10856     }
10857 }
10858 
10859 /**
10860  * xmlXPathCompEqualityExpr:
10861  * @ctxt:  the XPath Parser context
</pre>
<hr />
<pre>
10914     SKIP_BLANKS;
10915         xmlXPathCompEqualityExpr(ctxt);
10916     CHECK_ERROR;
10917     PUSH_BINARY_EXPR(XPATH_OP_AND, op1, ctxt-&gt;comp-&gt;last, 0, 0);
10918     SKIP_BLANKS;
10919     }
10920 }
10921 
10922 /**
10923  * xmlXPathCompileExpr:
10924  * @ctxt:  the XPath Parser context
10925  *
10926  *  [14]   Expr ::=   OrExpr
10927  *  [21]   OrExpr ::=   AndExpr
10928  *                 | OrExpr &#39;or&#39; AndExpr
10929  *
10930  * Parse and compile an expression
10931  */
10932 static void
10933 xmlXPathCompileExpr(xmlXPathParserContextPtr ctxt, int sort) {
<span class="line-added">10934     xmlXPathContextPtr xpctxt = ctxt-&gt;context;</span>
<span class="line-added">10935 </span>
<span class="line-added">10936     if (xpctxt != NULL) {</span>
<span class="line-added">10937         if (xpctxt-&gt;depth &gt;= xpctxt-&gt;maxParserDepth)</span>
<span class="line-added">10938             XP_ERROR(XPATH_RECURSION_LIMIT_EXCEEDED);</span>
<span class="line-added">10939         xpctxt-&gt;depth += 1;</span>
<span class="line-added">10940     }</span>
<span class="line-added">10941 </span>
10942     xmlXPathCompAndExpr(ctxt);
10943     CHECK_ERROR;
10944     SKIP_BLANKS;
10945     while ((CUR == &#39;o&#39;) &amp;&amp; (NXT(1) == &#39;r&#39;)) {
10946     int op1 = ctxt-&gt;comp-&gt;last;
10947         SKIP(2);
10948     SKIP_BLANKS;
10949         xmlXPathCompAndExpr(ctxt);
10950     CHECK_ERROR;
10951     PUSH_BINARY_EXPR(XPATH_OP_OR, op1, ctxt-&gt;comp-&gt;last, 0, 0);
10952     SKIP_BLANKS;
10953     }
10954     if ((sort) &amp;&amp; (ctxt-&gt;comp-&gt;steps[ctxt-&gt;comp-&gt;last].op != XPATH_OP_VALUE)) {
10955     /* more ops could be optimized too */
10956     /*
10957     * This is the main place to eliminate sorting for
10958     * operations which don&#39;t require a sorted node-set.
10959     * E.g. count().
10960     */
10961     PUSH_UNARY_EXPR(XPATH_OP_SORT, ctxt-&gt;comp-&gt;last , 0, 0);
10962     }
<span class="line-added">10963 </span>
<span class="line-added">10964     if (xpctxt != NULL)</span>
<span class="line-added">10965         xpctxt-&gt;depth -= 1;</span>
10966 }
10967 
10968 /**
10969  * xmlXPathCompPredicate:
10970  * @ctxt:  the XPath Parser context
10971  * @filter:  act as a filter
10972  *
10973  *  [8]   Predicate ::=   &#39;[&#39; PredicateExpr &#39;]&#39;
10974  *  [9]   PredicateExpr ::=   Expr
10975  *
10976  * Compile a predicate expression
10977  */
10978 static void
10979 xmlXPathCompPredicate(xmlXPathParserContextPtr ctxt, int filter) {
10980     int op1 = ctxt-&gt;comp-&gt;last;
10981 
10982     SKIP_BLANKS;
10983     if (CUR != &#39;[&#39;) {
10984     XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);
10985     }
</pre>
<hr />
<pre>
11564             xmlGenericError(xmlGenericErrorContext,
11565                             &quot;           searching for *\n&quot;);
11566             break;
11567         case NODE_TEST_NS:
11568             xmlGenericError(xmlGenericErrorContext,
11569                             &quot;           searching for namespace %s\n&quot;,
11570                             op-&gt;value5);
11571             break;
11572         case NODE_TEST_NAME:
11573             xmlGenericError(xmlGenericErrorContext,
11574                             &quot;           searching for name %s\n&quot;, op-&gt;value5);
11575             if (op-&gt;value4)
11576                 xmlGenericError(xmlGenericErrorContext,
11577                                 &quot;           with namespace %s\n&quot;, op-&gt;value4);
11578             break;
11579     }
11580     xmlGenericError(xmlGenericErrorContext, &quot;Testing : &quot;);
11581 }
11582 #endif /* DEBUG_STEP */
11583 
<span class="line-modified">11584 /**</span>
<span class="line-modified">11585  * xmlXPathNodeSetFilter:</span>
<span class="line-modified">11586  * @ctxt:  the XPath Parser context</span>
<span class="line-added">11587  * @set: the node set to filter</span>
<span class="line-added">11588  * @filterOpIndex: the index of the predicate/filter op</span>
<span class="line-added">11589  * @minPos: minimum position in the filtered set (1-based)</span>
<span class="line-added">11590  * @maxPos: maximum position in the filtered set (1-based)</span>
<span class="line-added">11591  * @hasNsNodes: true if the node set may contain namespace nodes</span>
<span class="line-added">11592  *</span>
<span class="line-added">11593  * Filter a node set, keeping only nodes for which the predicate expression</span>
<span class="line-added">11594  * matches. Afterwards, keep only nodes between minPos and maxPos in the</span>
<span class="line-added">11595  * filtered result.</span>
<span class="line-added">11596  */</span>
<span class="line-added">11597 static void</span>
<span class="line-added">11598 xmlXPathNodeSetFilter(xmlXPathParserContextPtr ctxt,</span>
11599                 xmlNodeSetPtr set,
<span class="line-modified">11600               int filterOpIndex,</span>
<span class="line-added">11601                       int minPos, int maxPos,</span>
11602                 int hasNsNodes)
11603 {
<span class="line-modified">11604     xmlXPathContextPtr xpctxt;</span>
<span class="line-modified">11605     xmlNodePtr oldnode;</span>
<span class="line-added">11606     xmlDocPtr olddoc;</span>
<span class="line-added">11607     xmlXPathStepOpPtr filterOp;</span>
<span class="line-added">11608     int oldcs, oldpp;</span>
<span class="line-added">11609     int i, j, pos;</span>
<span class="line-added">11610 </span>
<span class="line-added">11611     if ((set == NULL) || (set-&gt;nodeNr == 0))</span>
<span class="line-added">11612         return;</span>
<span class="line-added">11613 </span>
11614     /*
<span class="line-modified">11615     * Check if the node set contains a sufficient number of nodes for</span>
<span class="line-added">11616     * the requested range.</span>
11617     */
<span class="line-modified">11618     if (set-&gt;nodeNr &lt; minPos) {</span>
<span class="line-modified">11619         xmlXPathNodeSetClear(set, hasNsNodes);</span>
<span class="line-modified">11620         return;</span>







11621     }








11622 
<span class="line-modified">11623     xpctxt = ctxt-&gt;context;</span>
<span class="line-modified">11624     oldnode = xpctxt-&gt;node;</span>
<span class="line-modified">11625     olddoc = xpctxt-&gt;doc;</span>
<span class="line-modified">11626     oldcs = xpctxt-&gt;contextSize;</span>
<span class="line-modified">11627     oldpp = xpctxt-&gt;proximityPosition;</span>
<span class="line-modified">11628     filterOp = &amp;ctxt-&gt;comp-&gt;steps[filterOpIndex];</span>




































11629 
<span class="line-modified">11630     xpctxt-&gt;contextSize = set-&gt;nodeNr;</span>
<span class="line-modified">11631 </span>
<span class="line-modified">11632     for (i = 0, j = 0, pos = 1; i &lt; set-&gt;nodeNr; i++) {</span>
<span class="line-modified">11633         xmlNodePtr node = set-&gt;nodeTab[i];</span>
<span class="line-added">11634         int res;</span>
<span class="line-added">11635 </span>
<span class="line-added">11636         xpctxt-&gt;node = node;</span>
<span class="line-added">11637         xpctxt-&gt;proximityPosition = i + 1;</span>
11638 
11639         /*
11640         * Also set the xpath document in case things like
11641         * key() are evaluated in the predicate.
<span class="line-added">11642         *</span>
<span class="line-added">11643         * TODO: Get real doc for namespace nodes.</span>
11644         */
<span class="line-modified">11645         if ((node-&gt;type != XML_NAMESPACE_DECL) &amp;&amp;</span>
<span class="line-modified">11646             (node-&gt;doc != NULL))</span>
<span class="line-modified">11647             xpctxt-&gt;doc = node-&gt;doc;</span>














11648 
<span class="line-modified">11649         res = xmlXPathCompOpEvalToBoolean(ctxt, filterOp, 1);</span>
<span class="line-added">11650 </span>
<span class="line-added">11651         if (ctxt-&gt;error != XPATH_EXPRESSION_OK)</span>
<span class="line-added">11652             goto exit;</span>
<span class="line-added">11653         if (res &lt; 0) {</span>
<span class="line-added">11654             /* Shouldn&#39;t happen */</span>
<span class="line-added">11655             xmlXPathErr(ctxt, XPATH_EXPR_ERROR);</span>
<span class="line-added">11656             goto exit;</span>
<span class="line-added">11657     }</span>
11658 
<span class="line-modified">11659         if ((res != 0) &amp;&amp; ((pos &gt;= minPos) &amp;&amp; (pos &lt;= maxPos))) {</span>
<span class="line-added">11660             if (i != j) {</span>
<span class="line-added">11661                 set-&gt;nodeTab[j] = node;</span>
<span class="line-added">11662                 set-&gt;nodeTab[i] = NULL;</span>
<span class="line-added">11663             }</span>
11664 
<span class="line-modified">11665             j += 1;</span>
<span class="line-modified">11666         } else {</span>
<span class="line-modified">11667             /* Remove the entry from the initial node set. */</span>
<span class="line-modified">11668             set-&gt;nodeTab[i] = NULL;</span>
<span class="line-added">11669             if (node-&gt;type == XML_NAMESPACE_DECL)</span>
<span class="line-added">11670                 xmlXPathNodeSetFreeNs((xmlNsPtr) node);</span>
11671         }
11672 
11673         if (res != 0) {
<span class="line-modified">11674             if (pos == maxPos) {</span>
<span class="line-modified">11675                 /* Clear remaining nodes and exit loop. */</span>
<span class="line-modified">11676                 if (hasNsNodes) {</span>
<span class="line-modified">11677                     for (i++; i &lt; set-&gt;nodeNr; i++) {</span>
<span class="line-modified">11678                         node = set-&gt;nodeTab[i];</span>
<span class="line-modified">11679                         if ((node != NULL) &amp;&amp;</span>
<span class="line-modified">11680                             (node-&gt;type == XML_NAMESPACE_DECL))</span>
<span class="line-modified">11681                             xmlXPathNodeSetFreeNs((xmlNsPtr) node);</span>
<span class="line-added">11682                     }</span>
<span class="line-added">11683                 }</span>
<span class="line-added">11684                 break;</span>
<span class="line-added">11685             }</span>
<span class="line-added">11686 </span>
<span class="line-added">11687             pos += 1;</span>
11688         }
<span class="line-modified">11689     }</span>
<span class="line-modified">11690 </span>
<span class="line-modified">11691     set-&gt;nodeNr = j;</span>
<span class="line-modified">11692 </span>
<span class="line-modified">11693     /* If too many elements were removed, shrink table to preserve memory. */</span>
<span class="line-modified">11694     if ((set-&gt;nodeMax &gt; XML_NODESET_DEFAULT) &amp;&amp;</span>
<span class="line-modified">11695         (set-&gt;nodeNr &lt; set-&gt;nodeMax / 2)) {</span>
<span class="line-modified">11696         xmlNodePtr *tmp;</span>
<span class="line-added">11697         int nodeMax = set-&gt;nodeNr;</span>
<span class="line-added">11698 </span>
<span class="line-added">11699         if (nodeMax &lt; XML_NODESET_DEFAULT)</span>
<span class="line-added">11700             nodeMax = XML_NODESET_DEFAULT;</span>
<span class="line-added">11701         tmp = (xmlNodePtr *) xmlRealloc(set-&gt;nodeTab,</span>
<span class="line-added">11702                 nodeMax * sizeof(xmlNodePtr));</span>
<span class="line-added">11703         if (tmp == NULL) {</span>
<span class="line-added">11704             xmlXPathPErrMemory(ctxt, &quot;shrinking nodeset\n&quot;);</span>
11705         } else {
<span class="line-modified">11706             set-&gt;nodeTab = tmp;</span>
<span class="line-modified">11707             set-&gt;nodeMax = nodeMax;</span>



11708         }
11709     }
11710 
<span class="line-modified">11711 exit:</span>
<span class="line-modified">11712     xpctxt-&gt;node = oldnode;</span>
<span class="line-modified">11713     xpctxt-&gt;doc = olddoc;</span>










11714     xpctxt-&gt;contextSize = oldcs;
11715     xpctxt-&gt;proximityPosition = oldpp;


































11716     }














11717 
11718 #ifdef LIBXML_XPTR_ENABLED
<span class="line-modified">11719 /**</span>
<span class="line-modified">11720  * xmlXPathLocationSetFilter:</span>
<span class="line-modified">11721  * @ctxt:  the XPath Parser context</span>
<span class="line-modified">11722  * @locset: the location set to filter</span>
<span class="line-added">11723  * @filterOpIndex: the index of the predicate/filter op</span>
<span class="line-added">11724  * @minPos: minimum position in the filtered set (1-based)</span>
<span class="line-added">11725  * @maxPos: maximum position in the filtered set (1-based)</span>
<span class="line-added">11726     *</span>
<span class="line-added">11727  * Filter a location set, keeping only nodes for which the predicate</span>
<span class="line-added">11728  * expression matches. Afterwards, keep only nodes between minPos and maxPos</span>
<span class="line-added">11729  * in the filtered result.</span>
11730     */
<span class="line-modified">11731 static void</span>
<span class="line-added">11732 xmlXPathLocationSetFilter(xmlXPathParserContextPtr ctxt,</span>
<span class="line-added">11733                   xmlLocationSetPtr locset,</span>
<span class="line-added">11734                   int filterOpIndex,</span>
<span class="line-added">11735                           int minPos, int maxPos)</span>
<span class="line-added">11736 {</span>
<span class="line-added">11737     xmlXPathContextPtr xpctxt;</span>
<span class="line-added">11738     xmlNodePtr oldnode;</span>
<span class="line-added">11739     xmlDocPtr olddoc;</span>
<span class="line-added">11740     xmlXPathStepOpPtr filterOp;</span>
<span class="line-added">11741     int oldcs, oldpp;</span>
<span class="line-added">11742     int i, j, pos;</span>
11743 
<span class="line-modified">11744     if ((locset == NULL) || (locset-&gt;locNr == 0) || (filterOpIndex == -1))</span>
<span class="line-modified">11745         return;</span>
<span class="line-modified">11746 </span>
<span class="line-modified">11747     xpctxt = ctxt-&gt;context;</span>
<span class="line-modified">11748     oldnode = xpctxt-&gt;node;</span>
<span class="line-added">11749     olddoc = xpctxt-&gt;doc;</span>
11750         oldcs = xpctxt-&gt;contextSize;
11751         oldpp = xpctxt-&gt;proximityPosition;
<span class="line-modified">11752     filterOp = &amp;ctxt-&gt;comp-&gt;steps[filterOpIndex];</span>





11753 
<span class="line-modified">11754     xpctxt-&gt;contextSize = locset-&gt;locNr;</span>
<span class="line-modified">11755 </span>
<span class="line-added">11756     for (i = 0, j = 0, pos = 1; i &lt; locset-&gt;locNr; i++) {</span>
<span class="line-added">11757         xmlNodePtr contextNode = locset-&gt;locTab[i]-&gt;user;</span>
<span class="line-added">11758         int res;</span>
11759 

11760         xpctxt-&gt;node = contextNode;
<span class="line-modified">11761         xpctxt-&gt;proximityPosition = i + 1;</span>

11762 
11763         /*

11764         * Also set the xpath document in case things like
<span class="line-modified">11765         * key() are evaluated in the predicate.</span>
<span class="line-added">11766         *</span>
<span class="line-added">11767         * TODO: Get real doc for namespace nodes.</span>
11768         */
11769         if ((contextNode-&gt;type != XML_NAMESPACE_DECL) &amp;&amp;
11770         (contextNode-&gt;doc != NULL))
11771         xpctxt-&gt;doc = contextNode-&gt;doc;
<span class="line-modified">11772 </span>
<span class="line-modified">11773         res = xmlXPathCompOpEvalToBoolean(ctxt, filterOp, 1);</span>
<span class="line-modified">11774 </span>
<span class="line-modified">11775         if (ctxt-&gt;error != XPATH_EXPRESSION_OK)</span>
<span class="line-modified">11776             goto exit;</span>
<span class="line-modified">11777         if (res &lt; 0) {</span>
<span class="line-modified">11778             /* Shouldn&#39;t happen */</span>
<span class="line-modified">11779             xmlXPathErr(ctxt, XPATH_EXPR_ERROR);</span>
<span class="line-modified">11780             goto exit;</span>



11781         }
<span class="line-added">11782 </span>
<span class="line-added">11783         if ((res != 0) &amp;&amp; ((pos &gt;= minPos) &amp;&amp; (pos &lt;= maxPos))) {</span>
<span class="line-added">11784             if (i != j) {</span>
<span class="line-added">11785                 locset-&gt;locTab[j] = locset-&gt;locTab[i];</span>
<span class="line-added">11786                 locset-&gt;locTab[i] = NULL;</span>
11787         }
11788 
<span class="line-modified">11789             j += 1;</span>
<span class="line-modified">11790         } else {</span>
<span class="line-modified">11791             /* Remove the entry from the initial location set. */</span>
<span class="line-modified">11792             xmlXPathFreeObject(locset-&gt;locTab[i]);</span>
<span class="line-modified">11793             locset-&gt;locTab[i] = NULL;</span>
<span class="line-added">11794         }</span>
11795 
<span class="line-modified">11796         if (res != 0) {</span>
<span class="line-modified">11797             if (pos == maxPos) {</span>
<span class="line-modified">11798                 /* Clear remaining nodes and exit loop. */</span>
<span class="line-modified">11799                 for (i++; i &lt; locset-&gt;locNr; i++) {</span>
<span class="line-modified">11800                     xmlXPathFreeObject(locset-&gt;locTab[i]);</span>





11801         }
<span class="line-modified">11802                 break;</span>
<span class="line-modified">11803     }</span>
11804 
<span class="line-modified">11805             pos += 1;</span>
<span class="line-modified">11806     }</span>
<span class="line-added">11807 }</span>
11808 
<span class="line-modified">11809     locset-&gt;locNr = j;</span>
<span class="line-modified">11810 </span>
<span class="line-modified">11811     /* If too many elements were removed, shrink table to preserve memory. */</span>
<span class="line-modified">11812     if ((locset-&gt;locMax &gt; XML_NODESET_DEFAULT) &amp;&amp;</span>
<span class="line-modified">11813         (locset-&gt;locNr &lt; locset-&gt;locMax / 2)) {</span>
<span class="line-modified">11814         xmlXPathObjectPtr *tmp;</span>
<span class="line-modified">11815         int locMax = locset-&gt;locNr;</span>
<span class="line-modified">11816 </span>
<span class="line-modified">11817         if (locMax &lt; XML_NODESET_DEFAULT)</span>
<span class="line-modified">11818             locMax = XML_NODESET_DEFAULT;</span>
<span class="line-modified">11819         tmp = (xmlXPathObjectPtr *) xmlRealloc(locset-&gt;locTab,</span>
<span class="line-modified">11820                 locMax * sizeof(xmlXPathObjectPtr));</span>
<span class="line-modified">11821         if (tmp == NULL) {</span>
<span class="line-modified">11822             xmlXPathPErrMemory(ctxt, &quot;shrinking locset\n&quot;);</span>














11823         } else {
<span class="line-modified">11824             locset-&gt;locTab = tmp;</span>
<span class="line-modified">11825             locset-&gt;locMax = locMax;</span>




11826         }



11827         }
<span class="line-modified">11828 </span>
<span class="line-modified">11829 exit:</span>
<span class="line-modified">11830     xpctxt-&gt;node = oldnode;</span>
<span class="line-modified">11831     xpctxt-&gt;doc = olddoc;</span>
<span class="line-modified">11832     xpctxt-&gt;contextSize = oldcs;</span>
<span class="line-added">11833     xpctxt-&gt;proximityPosition = oldpp;</span>
<span class="line-added">11834         }</span>
<span class="line-added">11835 #endif /* LIBXML_XPTR_ENABLED */</span>
<span class="line-added">11836 </span>
<span class="line-added">11837 /**</span>
<span class="line-added">11838  * xmlXPathCompOpEvalPredicate:</span>
<span class="line-added">11839  * @ctxt:  the XPath Parser context</span>
<span class="line-added">11840  * @op: the predicate op</span>
<span class="line-added">11841  * @set: the node set to filter</span>
<span class="line-added">11842  * @minPos: minimum position in the filtered set (1-based)</span>
<span class="line-added">11843  * @maxPos: maximum position in the filtered set (1-based)</span>
<span class="line-added">11844  * @hasNsNodes: true if the node set may contain namespace nodes</span>
<span class="line-added">11845  *</span>
<span class="line-added">11846  * Filter a node set, keeping only nodes for which the sequence of predicate</span>
<span class="line-added">11847  * expressions matches. Afterwards, keep only nodes between minPos and maxPos</span>
<span class="line-added">11848  * in the filtered result.</span>
11849         */
<span class="line-modified">11850 static void</span>
<span class="line-modified">11851 xmlXPathCompOpEvalPredicate(xmlXPathParserContextPtr ctxt,</span>
<span class="line-modified">11852                 xmlXPathStepOpPtr op,</span>
<span class="line-added">11853                 xmlNodeSetPtr set,</span>
<span class="line-added">11854                             int minPos, int maxPos,</span>
<span class="line-added">11855                 int hasNsNodes)</span>
<span class="line-added">11856 {</span>
<span class="line-added">11857     if (op-&gt;ch1 != -1) {</span>
<span class="line-added">11858     xmlXPathCompExprPtr comp = ctxt-&gt;comp;</span>
11859         /*
<span class="line-modified">11860     * Process inner predicates first.</span>

11861         */
<span class="line-modified">11862     if (comp-&gt;steps[op-&gt;ch1].op != XPATH_OP_PREDICATE) {</span>
<span class="line-modified">11863             xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-added">11864                 &quot;xmlXPathCompOpEvalPredicate: Expected a predicate\n&quot;);</span>
<span class="line-added">11865             XP_ERROR(XPATH_INVALID_OPERAND);</span>
<span class="line-added">11866         }</span>
<span class="line-added">11867         if (ctxt-&gt;context-&gt;depth &gt;= ctxt-&gt;context-&gt;maxDepth)</span>
<span class="line-added">11868             XP_ERROR(XPATH_RECURSION_LIMIT_EXCEEDED);</span>
<span class="line-added">11869         ctxt-&gt;context-&gt;depth += 1;</span>
<span class="line-added">11870     xmlXPathCompOpEvalPredicate(ctxt, &amp;comp-&gt;steps[op-&gt;ch1], set,</span>
<span class="line-added">11871                                     1, set-&gt;nodeNr, hasNsNodes);</span>
<span class="line-added">11872         ctxt-&gt;context-&gt;depth -= 1;</span>
<span class="line-added">11873     CHECK_ERROR;</span>
11874     }

11875 
<span class="line-modified">11876     if (op-&gt;ch2 != -1)</span>
<span class="line-modified">11877         xmlXPathNodeSetFilter(ctxt, set, op-&gt;ch2, minPos, maxPos, hasNsNodes);</span>




















11878 }
11879 
11880 static int
11881 xmlXPathIsPositionalPredicate(xmlXPathParserContextPtr ctxt,
11882                 xmlXPathStepOpPtr op,
11883                 int *maxPos)
11884 {
11885 
11886     xmlXPathStepOpPtr exprOp;
11887 
11888     /*
11889     * BIG NOTE: This is not intended for XPATH_OP_FILTER yet!
11890     */
11891 
11892     /*
11893     * If not -1, then ch1 will point to:
11894     * 1) For predicates (XPATH_OP_PREDICATE):
11895     *    - an inner predicate operator
11896     * 2) For filters (XPATH_OP_FILTER):
<span class="line-modified">11897     *    - an inner filter operator OR</span>
11898     *    - an expression selecting the node set.
11899     *      E.g. &quot;key(&#39;a&#39;, &#39;b&#39;)&quot; or &quot;(//foo | //bar)&quot;.
11900     */
11901     if ((op-&gt;op != XPATH_OP_PREDICATE) &amp;&amp; (op-&gt;op != XPATH_OP_FILTER))
11902     return(0);
11903 
11904     if (op-&gt;ch2 != -1) {
11905     exprOp = &amp;ctxt-&gt;comp-&gt;steps[op-&gt;ch2];
11906     } else
11907     return(0);
11908 
11909     if ((exprOp != NULL) &amp;&amp;
11910     (exprOp-&gt;op == XPATH_OP_VALUE) &amp;&amp;
11911     (exprOp-&gt;value4 != NULL) &amp;&amp;
11912     (((xmlXPathObjectPtr) exprOp-&gt;value4)-&gt;type == XPATH_NUMBER))
11913     {
11914         double floatval = ((xmlXPathObjectPtr) exprOp-&gt;value4)-&gt;floatval;
11915 
11916     /*
11917     * We have a &quot;[n]&quot; predicate here.
</pre>
<hr />
<pre>
11975     int nbMatches = 0, prevMatches = 0;
11976 #endif
11977     int total = 0, hasNsNodes = 0;
11978     /* The popped object holding the context nodes */
11979     xmlXPathObjectPtr obj;
11980     /* The set of context nodes for the node tests */
11981     xmlNodeSetPtr contextSeq;
11982     int contextIdx;
11983     xmlNodePtr contextNode;
11984     /* The final resulting node set wrt to all context nodes */
11985     xmlNodeSetPtr outSeq;
11986     /*
11987     * The temporary resulting node set wrt 1 context node.
11988     * Used to feed predicate evaluation.
11989     */
11990     xmlNodeSetPtr seq;
11991     xmlNodePtr cur;
11992     /* First predicate operator */
11993     xmlXPathStepOpPtr predOp;
11994     int maxPos; /* The requested position() (when a &quot;[n]&quot; predicate) */
<span class="line-modified">11995     int hasPredicateRange, hasAxisRange, pos;</span>
11996     int breakOnFirstHit;
11997 
11998     xmlXPathTraversalFunction next = NULL;
11999     int (*addNode) (xmlNodeSetPtr, xmlNodePtr);
12000     xmlXPathNodeSetMergeFunction mergeAndClear;
12001     xmlNodePtr oldContextNode;
12002     xmlXPathContextPtr xpctxt = ctxt-&gt;context;
12003 
12004 
12005     CHECK_TYPE0(XPATH_NODESET);
12006     obj = valuePop(ctxt);
12007     /*
12008     * Setup namespaces.
12009     */
12010     if (prefix != NULL) {
12011         URI = xmlXPathNsLookup(xpctxt, prefix);
12012         if (URI == NULL) {
12013         xmlXPathReleaseObject(xpctxt, obj);
12014             XP_ERROR0(XPATH_UNDEF_PREFIX_ERROR);
12015     }
</pre>
<hr />
<pre>
12168      *
12169      * A node test * is true for any node of the
12170      * principal node type. For example, child::* will
12171      * select all element children of the context node
12172      */
12173     oldContextNode = xpctxt-&gt;node;
12174     addNode = xmlXPathNodeSetAddUnique;
12175     outSeq = NULL;
12176     seq = NULL;
12177     contextNode = NULL;
12178     contextIdx = 0;
12179 
12180 
12181     while (((contextIdx &lt; contextSeq-&gt;nodeNr) || (contextNode != NULL)) &amp;&amp;
12182            (ctxt-&gt;error == XPATH_EXPRESSION_OK)) {
12183     xpctxt-&gt;node = contextSeq-&gt;nodeTab[contextIdx++];
12184 
12185     if (seq == NULL) {
12186         seq = xmlXPathNodeSetCreate(NULL);
12187         if (seq == NULL) {
<span class="line-added">12188                 /* TODO: Propagate memory error. */</span>
12189         total = 0;
12190         goto error;
12191         }
12192     }
12193     /*
12194     * Traverse the axis and test the nodes.
12195     */
12196     pos = 0;
12197     cur = NULL;
12198     hasNsNodes = 0;
12199         do {
<span class="line-added">12200             if (OP_LIMIT_EXCEEDED(ctxt, 1))</span>
<span class="line-added">12201                 goto error;</span>
<span class="line-added">12202 </span>
12203             cur = next(ctxt, cur);
12204             if (cur == NULL)
12205                 break;
12206 
12207         /*
12208         * QUESTION TODO: What does the &quot;first&quot; and &quot;last&quot; stuff do?
12209         */
12210             if ((first != NULL) &amp;&amp; (*first != NULL)) {
12211         if (*first == cur)
12212             break;
12213         if (((total % 256) == 0) &amp;&amp;
12214 #ifdef XP_OPTIMIZED_NON_ELEM_COMPARISON
12215             (xmlXPathCmpNodesExt(*first, cur) &gt;= 0))
12216 #else
12217             (xmlXPathCmpNodes(*first, cur) &gt;= 0))
12218 #endif
12219         {
12220             break;
12221         }
12222         }
</pre>
<hr />
<pre>
12390                         default:
12391                             break;
12392                     }
12393                     break;
12394         } /* switch(test) */
12395         } while ((cur != NULL) &amp;&amp; (ctxt-&gt;error == XPATH_EXPRESSION_OK));
12396 
12397     goto apply_predicates;
12398 
12399 axis_range_end: /* ----------------------------------------------------- */
12400     /*
12401     * We have a &quot;/foo[n]&quot;, and position() = n was reached.
12402     * Note that we can have as well &quot;/foo/::parent::foo[1]&quot;, so
12403     * a duplicate-aware merge is still needed.
12404     * Merge with the result.
12405     */
12406     if (outSeq == NULL) {
12407         outSeq = seq;
12408         seq = NULL;
12409     } else
<span class="line-modified">12410             /* TODO: Check memory error. */</span>
<span class="line-added">12411         outSeq = mergeAndClear(outSeq, seq);</span>
12412     /*
12413     * Break if only a true/false result was requested.
12414     */
12415     if (toBool)
12416         break;
12417     continue;
12418 
12419 first_hit: /* ---------------------------------------------------------- */
12420     /*
12421     * Break if only a true/false result was requested and
12422     * no predicates existed and a node test succeeded.
12423     */
12424     if (outSeq == NULL) {
12425         outSeq = seq;
12426         seq = NULL;
12427     } else
<span class="line-modified">12428             /* TODO: Check memory error. */</span>
<span class="line-added">12429         outSeq = mergeAndClear(outSeq, seq);</span>
12430     break;
12431 
12432 #ifdef DEBUG_STEP
12433     if (seq != NULL)
12434         nbMatches += seq-&gt;nodeNr;
12435 #endif
12436 
12437 apply_predicates: /* --------------------------------------------------- */
12438         if (ctxt-&gt;error != XPATH_EXPRESSION_OK)
12439         goto error;
12440 
12441         /*
12442     * Apply predicates.
12443     */
12444         if ((predOp != NULL) &amp;&amp; (seq-&gt;nodeNr &gt; 0)) {
12445         /*
12446         * E.g. when we have a &quot;/foo[some expression][n]&quot;.
12447         */
12448         /*
12449         * QUESTION TODO: The old predicate evaluation took into
</pre>
<hr />
<pre>
12453         *  All what I learned now from the evaluation semantics
12454         *  does not indicate that a location-set will be processed
12455         *  here, so this looks OK.
12456         */
12457         /*
12458         * Iterate over all predicates, starting with the outermost
12459         * predicate.
12460         * TODO: Problem: we cannot execute the inner predicates first
12461         *  since we cannot go back *up* the operator tree!
12462         *  Options we have:
12463         *  1) Use of recursive functions (like is it currently done
12464         *     via xmlXPathCompOpEval())
12465         *  2) Add a predicate evaluation information stack to the
12466         *     context struct
12467         *  3) Change the way the operators are linked; we need a
12468         *     &quot;parent&quot; field on xmlXPathStepOp
12469         *
12470         * For the moment, I&#39;ll try to solve this with a recursive
12471         * function: xmlXPathCompOpEvalPredicate().
12472         */

12473         if (hasPredicateRange != 0)
<span class="line-modified">12474         xmlXPathCompOpEvalPredicate(ctxt, predOp, seq, maxPos, maxPos,</span>
<span class="line-modified">12475                         hasNsNodes);</span>
12476         else
<span class="line-modified">12477         xmlXPathCompOpEvalPredicate(ctxt, predOp, seq, 1, seq-&gt;nodeNr,</span>
<span class="line-modified">12478                         hasNsNodes);</span>
12479 
12480         if (ctxt-&gt;error != XPATH_EXPRESSION_OK) {
12481         total = 0;
12482         goto error;
12483         }































12484         }
<span class="line-modified">12485 </span>
<span class="line-added">12486         if (seq-&gt;nodeNr &gt; 0) {</span>
12487         /*
12488         * Add to result set.
12489         */
12490         if (outSeq == NULL) {
12491         outSeq = seq;
12492         seq = NULL;
12493         } else {
<span class="line-modified">12494                 /* TODO: Check memory error. */</span>
<span class="line-added">12495         outSeq = mergeAndClear(outSeq, seq);</span>
12496         }
<span class="line-added">12497 </span>
<span class="line-added">12498             if (toBool)</span>
<span class="line-added">12499                 break;</span>
12500     }
12501     }
12502 
12503 error:
12504     if ((obj-&gt;boolval) &amp;&amp; (obj-&gt;user != NULL)) {
12505     /*
12506     * QUESTION TODO: What does this do and why?
12507     * TODO: Do we have to do this also for the &quot;error&quot;
12508     * cleanup further down?
12509     */
12510     ctxt-&gt;value-&gt;boolval = 1;
12511     ctxt-&gt;value-&gt;user = obj-&gt;user;
12512     obj-&gt;user = NULL;
12513     obj-&gt;boolval = 0;
12514     }
12515     xmlXPathReleaseObject(xpctxt, obj);
12516 
12517     /*
<span class="line-modified">12518     * Ensure we return at least an empty set.</span>
12519     */
12520     if (outSeq == NULL) {
12521     if ((seq != NULL) &amp;&amp; (seq-&gt;nodeNr == 0))
12522         outSeq = seq;
12523     else
<span class="line-added">12524             /* TODO: Check memory error. */</span>
12525         outSeq = xmlXPathNodeSetCreate(NULL);

12526     }
12527     if ((seq != NULL) &amp;&amp; (seq != outSeq)) {
12528      xmlXPathFreeNodeSet(seq);
12529     }
12530     /*
12531     * Hand over the result. Better to push the set also in
12532     * case of errors.
12533     */
12534     valuePush(ctxt, xmlXPathCacheWrapNodeSet(xpctxt, outSeq));
12535     /*
12536     * Reset the context node.
12537     */
12538     xpctxt-&gt;node = oldContextNode;
12539     /*
12540     * When traversing the namespace axis in &quot;toBool&quot; mode, it&#39;s
12541     * possible that tmpNsList wasn&#39;t freed.
12542     */
12543     if (xpctxt-&gt;tmpNsList != NULL) {
12544         xmlFree(xpctxt-&gt;tmpNsList);
12545         xpctxt-&gt;tmpNsList = NULL;
</pre>
<hr />
<pre>
12561 /**
12562  * xmlXPathCompOpEvalFirst:
12563  * @ctxt:  the XPath parser context with the compiled expression
12564  * @op:  an XPath compiled operation
12565  * @first:  the first elem found so far
12566  *
12567  * Evaluate the Precompiled XPath operation searching only the first
12568  * element in document order
12569  *
12570  * Returns the number of examined objects.
12571  */
12572 static int
12573 xmlXPathCompOpEvalFirst(xmlXPathParserContextPtr ctxt,
12574                         xmlXPathStepOpPtr op, xmlNodePtr * first)
12575 {
12576     int total = 0, cur;
12577     xmlXPathCompExprPtr comp;
12578     xmlXPathObjectPtr arg1, arg2;
12579 
12580     CHECK_ERROR0;
<span class="line-added">12581     if (OP_LIMIT_EXCEEDED(ctxt, 1))</span>
<span class="line-added">12582         return(0);</span>
<span class="line-added">12583     if (ctxt-&gt;context-&gt;depth &gt;= ctxt-&gt;context-&gt;maxDepth)</span>
<span class="line-added">12584         XP_ERROR0(XPATH_RECURSION_LIMIT_EXCEEDED);</span>
<span class="line-added">12585     ctxt-&gt;context-&gt;depth += 1;</span>
12586     comp = ctxt-&gt;comp;
12587     switch (op-&gt;op) {
12588         case XPATH_OP_END:
<span class="line-modified">12589             break;</span>
12590         case XPATH_OP_UNION:
12591             total =
12592                 xmlXPathCompOpEvalFirst(ctxt, &amp;comp-&gt;steps[op-&gt;ch1],
12593                                         first);
12594         CHECK_ERROR0;
12595             if ((ctxt-&gt;value != NULL)
12596                 &amp;&amp; (ctxt-&gt;value-&gt;type == XPATH_NODESET)
12597                 &amp;&amp; (ctxt-&gt;value-&gt;nodesetval != NULL)
12598                 &amp;&amp; (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt;= 1)) {
12599                 /*
12600                  * limit tree traversing to first node in the result
12601                  */
12602         /*
<span class="line-modified">12603         * OPTIMIZE TODO: This implicitly sorts</span>
12604         *  the result, even if not needed. E.g. if the argument
12605         *  of the count() function, no sorting is needed.
12606         * OPTIMIZE TODO: How do we know if the node-list wasn&#39;t
<span class="line-modified">12607         *  already sorted?</span>
12608         */
12609         if (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1)
12610             xmlXPathNodeSetSort(ctxt-&gt;value-&gt;nodesetval);
12611                 *first = ctxt-&gt;value-&gt;nodesetval-&gt;nodeTab[0];
12612             }
12613             cur =
12614                 xmlXPathCompOpEvalFirst(ctxt, &amp;comp-&gt;steps[op-&gt;ch2],
12615                                         first);
12616         CHECK_ERROR0;
12617 
12618             arg2 = valuePop(ctxt);
12619             arg1 = valuePop(ctxt);
12620             if ((arg1 == NULL) || (arg1-&gt;type != XPATH_NODESET) ||
12621                 (arg2 == NULL) || (arg2-&gt;type != XPATH_NODESET)) {
12622             xmlXPathReleaseObject(ctxt-&gt;context, arg1);
12623             xmlXPathReleaseObject(ctxt-&gt;context, arg2);
12624                 XP_ERROR0(XPATH_INVALID_TYPE);
12625             }
<span class="line-added">12626             if ((ctxt-&gt;context-&gt;opLimit != 0) &amp;&amp;</span>
<span class="line-added">12627                 (((arg1-&gt;nodesetval != NULL) &amp;&amp;</span>
<span class="line-added">12628                   (xmlXPathCheckOpLimit(ctxt,</span>
<span class="line-added">12629                                         arg1-&gt;nodesetval-&gt;nodeNr) &lt; 0)) ||</span>
<span class="line-added">12630                  ((arg2-&gt;nodesetval != NULL) &amp;&amp;</span>
<span class="line-added">12631                   (xmlXPathCheckOpLimit(ctxt,</span>
<span class="line-added">12632                                         arg2-&gt;nodesetval-&gt;nodeNr) &lt; 0)))) {</span>
<span class="line-added">12633             xmlXPathReleaseObject(ctxt-&gt;context, arg1);</span>
<span class="line-added">12634             xmlXPathReleaseObject(ctxt-&gt;context, arg2);</span>
<span class="line-added">12635                 break;</span>
<span class="line-added">12636             }</span>
12637 
<span class="line-added">12638             /* TODO: Check memory error. */</span>
12639             arg1-&gt;nodesetval = xmlXPathNodeSetMerge(arg1-&gt;nodesetval,
12640                                                     arg2-&gt;nodesetval);
12641             valuePush(ctxt, arg1);
12642         xmlXPathReleaseObject(ctxt-&gt;context, arg2);
12643             /* optimizer */
12644         if (total &gt; cur)
12645         xmlXPathCompSwap(op);
<span class="line-modified">12646             total += cur;</span>
<span class="line-added">12647             break;</span>
12648         case XPATH_OP_ROOT:
12649             xmlXPathRoot(ctxt);
<span class="line-modified">12650             break;</span>
12651         case XPATH_OP_NODE:
12652             if (op-&gt;ch1 != -1)
12653                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
12654         CHECK_ERROR0;
12655             if (op-&gt;ch2 != -1)
12656                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
12657         CHECK_ERROR0;
12658         valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt-&gt;context,
12659         ctxt-&gt;context-&gt;node));
<span class="line-modified">12660             break;</span>
12661         case XPATH_OP_COLLECT:{
12662                 if (op-&gt;ch1 == -1)
<span class="line-modified">12663                     break;</span>
12664 
12665                 total = xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
12666         CHECK_ERROR0;
12667 
12668                 total += xmlXPathNodeCollectAndTest(ctxt, op, first, NULL, 0);
<span class="line-modified">12669                 break;</span>
12670             }
12671         case XPATH_OP_VALUE:
12672             valuePush(ctxt,
12673                       xmlXPathCacheObjectCopy(ctxt-&gt;context,
12674             (xmlXPathObjectPtr) op-&gt;value4));
<span class="line-modified">12675             break;</span>
12676         case XPATH_OP_SORT:
12677             if (op-&gt;ch1 != -1)
12678                 total +=
12679                     xmlXPathCompOpEvalFirst(ctxt, &amp;comp-&gt;steps[op-&gt;ch1],
12680                                             first);
12681         CHECK_ERROR0;
12682             if ((ctxt-&gt;value != NULL)
12683                 &amp;&amp; (ctxt-&gt;value-&gt;type == XPATH_NODESET)
12684                 &amp;&amp; (ctxt-&gt;value-&gt;nodesetval != NULL)
12685         &amp;&amp; (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1))
12686                 xmlXPathNodeSetSort(ctxt-&gt;value-&gt;nodesetval);
<span class="line-modified">12687             break;</span>
12688 #ifdef XP_OPTIMIZED_FILTER_FIRST
12689     case XPATH_OP_FILTER:
12690                 total += xmlXPathCompOpEvalFilterFirst(ctxt, op, first);
<span class="line-modified">12691             break;</span>
12692 #endif
12693         default:
<span class="line-modified">12694             total += xmlXPathCompOpEval(ctxt, op);</span>
<span class="line-added">12695             break;</span>
12696     }
<span class="line-added">12697 </span>
<span class="line-added">12698     ctxt-&gt;context-&gt;depth -= 1;</span>
<span class="line-added">12699     return(total);</span>
12700 }
12701 
12702 /**
12703  * xmlXPathCompOpEvalLast:
12704  * @ctxt:  the XPath parser context with the compiled expression
12705  * @op:  an XPath compiled operation
12706  * @last:  the last elem found so far
12707  *
12708  * Evaluate the Precompiled XPath operation searching only the last
12709  * element in document order
12710  *
12711  * Returns the number of nodes traversed
12712  */
12713 static int
12714 xmlXPathCompOpEvalLast(xmlXPathParserContextPtr ctxt, xmlXPathStepOpPtr op,
12715                        xmlNodePtr * last)
12716 {
12717     int total = 0, cur;
12718     xmlXPathCompExprPtr comp;
12719     xmlXPathObjectPtr arg1, arg2;
12720 
12721     CHECK_ERROR0;
<span class="line-added">12722     if (OP_LIMIT_EXCEEDED(ctxt, 1))</span>
<span class="line-added">12723         return(0);</span>
<span class="line-added">12724     if (ctxt-&gt;context-&gt;depth &gt;= ctxt-&gt;context-&gt;maxDepth)</span>
<span class="line-added">12725         XP_ERROR0(XPATH_RECURSION_LIMIT_EXCEEDED);</span>
<span class="line-added">12726     ctxt-&gt;context-&gt;depth += 1;</span>
12727     comp = ctxt-&gt;comp;
12728     switch (op-&gt;op) {
12729         case XPATH_OP_END:
<span class="line-modified">12730             break;</span>
12731         case XPATH_OP_UNION:
12732             total =
12733                 xmlXPathCompOpEvalLast(ctxt, &amp;comp-&gt;steps[op-&gt;ch1], last);
12734         CHECK_ERROR0;
12735             if ((ctxt-&gt;value != NULL)
12736                 &amp;&amp; (ctxt-&gt;value-&gt;type == XPATH_NODESET)
12737                 &amp;&amp; (ctxt-&gt;value-&gt;nodesetval != NULL)
12738                 &amp;&amp; (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt;= 1)) {
12739                 /*
12740                  * limit tree traversing to first node in the result
12741                  */
12742         if (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1)
12743             xmlXPathNodeSetSort(ctxt-&gt;value-&gt;nodesetval);
12744                 *last =
12745                     ctxt-&gt;value-&gt;nodesetval-&gt;nodeTab[ctxt-&gt;value-&gt;
12746                                                      nodesetval-&gt;nodeNr -
12747                                                      1];
12748             }
12749             cur =
12750                 xmlXPathCompOpEvalLast(ctxt, &amp;comp-&gt;steps[op-&gt;ch2], last);
12751         CHECK_ERROR0;
12752             if ((ctxt-&gt;value != NULL)
12753                 &amp;&amp; (ctxt-&gt;value-&gt;type == XPATH_NODESET)
12754                 &amp;&amp; (ctxt-&gt;value-&gt;nodesetval != NULL)
12755                 &amp;&amp; (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt;= 1)) { /* TODO: NOP ? */
12756             }
12757 
12758             arg2 = valuePop(ctxt);
12759             arg1 = valuePop(ctxt);
12760             if ((arg1 == NULL) || (arg1-&gt;type != XPATH_NODESET) ||
12761                 (arg2 == NULL) || (arg2-&gt;type != XPATH_NODESET)) {
12762             xmlXPathReleaseObject(ctxt-&gt;context, arg1);
12763             xmlXPathReleaseObject(ctxt-&gt;context, arg2);
12764                 XP_ERROR0(XPATH_INVALID_TYPE);
12765             }
<span class="line-added">12766             if ((ctxt-&gt;context-&gt;opLimit != 0) &amp;&amp;</span>
<span class="line-added">12767                 (((arg1-&gt;nodesetval != NULL) &amp;&amp;</span>
<span class="line-added">12768                   (xmlXPathCheckOpLimit(ctxt,</span>
<span class="line-added">12769                                         arg1-&gt;nodesetval-&gt;nodeNr) &lt; 0)) ||</span>
<span class="line-added">12770                  ((arg2-&gt;nodesetval != NULL) &amp;&amp;</span>
<span class="line-added">12771                   (xmlXPathCheckOpLimit(ctxt,</span>
<span class="line-added">12772                                         arg2-&gt;nodesetval-&gt;nodeNr) &lt; 0)))) {</span>
<span class="line-added">12773             xmlXPathReleaseObject(ctxt-&gt;context, arg1);</span>
<span class="line-added">12774             xmlXPathReleaseObject(ctxt-&gt;context, arg2);</span>
<span class="line-added">12775                 break;</span>
<span class="line-added">12776             }</span>
12777 
<span class="line-added">12778             /* TODO: Check memory error. */</span>
12779             arg1-&gt;nodesetval = xmlXPathNodeSetMerge(arg1-&gt;nodesetval,
12780                                                     arg2-&gt;nodesetval);
12781             valuePush(ctxt, arg1);
12782         xmlXPathReleaseObject(ctxt-&gt;context, arg2);
12783             /* optimizer */
12784         if (total &gt; cur)
12785         xmlXPathCompSwap(op);
<span class="line-modified">12786             total += cur;</span>
<span class="line-added">12787             break;</span>
12788         case XPATH_OP_ROOT:
12789             xmlXPathRoot(ctxt);
<span class="line-modified">12790             break;</span>
12791         case XPATH_OP_NODE:
12792             if (op-&gt;ch1 != -1)
12793                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
12794         CHECK_ERROR0;
12795             if (op-&gt;ch2 != -1)
12796                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
12797         CHECK_ERROR0;
12798         valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt-&gt;context,
12799         ctxt-&gt;context-&gt;node));
<span class="line-modified">12800             break;</span>
12801         case XPATH_OP_COLLECT:{
12802                 if (op-&gt;ch1 == -1)
<span class="line-modified">12803                     break;</span>
12804 
12805                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
12806         CHECK_ERROR0;
12807 
12808                 total += xmlXPathNodeCollectAndTest(ctxt, op, NULL, last, 0);
<span class="line-modified">12809                 break;</span>
12810             }
12811         case XPATH_OP_VALUE:
12812             valuePush(ctxt,
12813                       xmlXPathCacheObjectCopy(ctxt-&gt;context,
12814             (xmlXPathObjectPtr) op-&gt;value4));
<span class="line-modified">12815             break;</span>
12816         case XPATH_OP_SORT:
12817             if (op-&gt;ch1 != -1)
12818                 total +=
12819                     xmlXPathCompOpEvalLast(ctxt, &amp;comp-&gt;steps[op-&gt;ch1],
12820                                            last);
12821         CHECK_ERROR0;
12822             if ((ctxt-&gt;value != NULL)
12823                 &amp;&amp; (ctxt-&gt;value-&gt;type == XPATH_NODESET)
12824                 &amp;&amp; (ctxt-&gt;value-&gt;nodesetval != NULL)
12825         &amp;&amp; (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1))
12826                 xmlXPathNodeSetSort(ctxt-&gt;value-&gt;nodesetval);
<span class="line-modified">12827             break;</span>
12828         default:
<span class="line-modified">12829             total += xmlXPathCompOpEval(ctxt, op);</span>
<span class="line-added">12830             break;</span>
12831     }
<span class="line-added">12832 </span>
<span class="line-added">12833     ctxt-&gt;context-&gt;depth -= 1;</span>
<span class="line-added">12834     return (total);</span>
12835 }
12836 
12837 #ifdef XP_OPTIMIZED_FILTER_FIRST
12838 static int
12839 xmlXPathCompOpEvalFilterFirst(xmlXPathParserContextPtr ctxt,
12840                   xmlXPathStepOpPtr op, xmlNodePtr * first)
12841 {
12842     int total = 0;
12843     xmlXPathCompExprPtr comp;
<span class="line-modified">12844     xmlNodeSetPtr set;</span>






12845 
12846     CHECK_ERROR0;
12847     comp = ctxt-&gt;comp;
12848     /*
12849     * Optimization for ()[last()] selection i.e. the last elem
12850     */
12851     if ((op-&gt;ch1 != -1) &amp;&amp; (op-&gt;ch2 != -1) &amp;&amp;
12852     (comp-&gt;steps[op-&gt;ch1].op == XPATH_OP_SORT) &amp;&amp;
12853     (comp-&gt;steps[op-&gt;ch2].op == XPATH_OP_SORT)) {
12854     int f = comp-&gt;steps[op-&gt;ch2].ch1;
12855 
12856     if ((f != -1) &amp;&amp;
12857         (comp-&gt;steps[f].op == XPATH_OP_FUNCTION) &amp;&amp;
12858         (comp-&gt;steps[f].value5 == NULL) &amp;&amp;
12859         (comp-&gt;steps[f].value == 0) &amp;&amp;
12860         (comp-&gt;steps[f].value4 != NULL) &amp;&amp;
12861         (xmlStrEqual
12862         (comp-&gt;steps[f].value4, BAD_CAST &quot;last&quot;))) {
12863         xmlNodePtr last = NULL;
12864 
</pre>
<hr />
<pre>
12875         (ctxt-&gt;value-&gt;type == XPATH_NODESET) &amp;&amp;
12876         (ctxt-&gt;value-&gt;nodesetval != NULL) &amp;&amp;
12877         (ctxt-&gt;value-&gt;nodesetval-&gt;nodeTab != NULL) &amp;&amp;
12878         (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1)) {
12879                 xmlXPathNodeSetKeepLast(ctxt-&gt;value-&gt;nodesetval);
12880         *first = *(ctxt-&gt;value-&gt;nodesetval-&gt;nodeTab);
12881         }
12882         return (total);
12883     }
12884     }
12885 
12886     if (op-&gt;ch1 != -1)
12887     total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
12888     CHECK_ERROR0;
12889     if (op-&gt;ch2 == -1)
12890     return (total);
12891     if (ctxt-&gt;value == NULL)
12892     return (total);
12893 
12894 #ifdef LIBXML_XPTR_ENABLED
<span class="line-modified">12895         /*</span>
12896     * Hum are we filtering the result of an XPointer expression
<span class="line-modified">12897         */</span>
12898     if (ctxt-&gt;value-&gt;type == XPATH_LOCATIONSET) {
<span class="line-modified">12899         xmlLocationSetPtr locset = ctxt-&gt;value-&gt;user;</span>













12900 
<span class="line-modified">12901         if (locset != NULL) {</span>
<span class="line-modified">12902             xmlXPathLocationSetFilter(ctxt, locset, op-&gt;ch2, 1, 1);</span>
<span class="line-modified">12903             if (locset-&gt;locNr &gt; 0)</span>
<span class="line-modified">12904                 *first = (xmlNodePtr) locset-&gt;locTab[0]-&gt;user;</span>
































































12905     }
<span class="line-modified">12906 </span>








12907     return (total);
12908     }
12909 #endif /* LIBXML_XPTR_ENABLED */
12910 





12911     CHECK_TYPE0(XPATH_NODESET);
<span class="line-modified">12912     set = ctxt-&gt;value-&gt;nodesetval;</span>
<span class="line-modified">12913     if (set != NULL) {</span>
<span class="line-modified">12914         xmlXPathNodeSetFilter(ctxt, set, op-&gt;ch2, 1, 1, 1);</span>
<span class="line-modified">12915         if (set-&gt;nodeNr &gt; 0)</span>
<span class="line-modified">12916             *first = set-&gt;nodeTab[0];</span>

























































































12917     }
<span class="line-added">12918 </span>
12919     return(total);
12920 }
12921 #endif /* XP_OPTIMIZED_FILTER_FIRST */
12922 
12923 /**
12924  * xmlXPathCompOpEval:
12925  * @ctxt:  the XPath parser context with the compiled expression
12926  * @op:  an XPath compiled operation
12927  *
12928  * Evaluate the Precompiled XPath operation
12929  * Returns the number of nodes traversed
12930  */
12931 static int
12932 xmlXPathCompOpEval(xmlXPathParserContextPtr ctxt, xmlXPathStepOpPtr op)
12933 {
12934     int total = 0;
12935     int equal, ret;
12936     xmlXPathCompExprPtr comp;
12937     xmlXPathObjectPtr arg1, arg2;
12938 
12939     CHECK_ERROR0;
<span class="line-added">12940     if (OP_LIMIT_EXCEEDED(ctxt, 1))</span>
<span class="line-added">12941         return(0);</span>
<span class="line-added">12942     if (ctxt-&gt;context-&gt;depth &gt;= ctxt-&gt;context-&gt;maxDepth)</span>
<span class="line-added">12943         XP_ERROR0(XPATH_RECURSION_LIMIT_EXCEEDED);</span>
<span class="line-added">12944     ctxt-&gt;context-&gt;depth += 1;</span>
12945     comp = ctxt-&gt;comp;
12946     switch (op-&gt;op) {
12947         case XPATH_OP_END:
<span class="line-modified">12948             break;</span>
12949         case XPATH_OP_AND:
12950             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
12951         CHECK_ERROR0;
12952             xmlXPathBooleanFunction(ctxt, 1);
12953             if ((ctxt-&gt;value == NULL) || (ctxt-&gt;value-&gt;boolval == 0))
<span class="line-modified">12954                 break;</span>
12955             arg2 = valuePop(ctxt);
12956             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
12957         if (ctxt-&gt;error) {
12958         xmlXPathFreeObject(arg2);
<span class="line-modified">12959         break;</span>
12960         }
12961             xmlXPathBooleanFunction(ctxt, 1);
12962             if (ctxt-&gt;value != NULL)
12963                 ctxt-&gt;value-&gt;boolval &amp;= arg2-&gt;boolval;
12964         xmlXPathReleaseObject(ctxt-&gt;context, arg2);
<span class="line-modified">12965             break;</span>
12966         case XPATH_OP_OR:
12967             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
12968         CHECK_ERROR0;
12969             xmlXPathBooleanFunction(ctxt, 1);
12970             if ((ctxt-&gt;value == NULL) || (ctxt-&gt;value-&gt;boolval == 1))
<span class="line-modified">12971                 break;</span>
12972             arg2 = valuePop(ctxt);
12973             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
12974         if (ctxt-&gt;error) {
12975         xmlXPathFreeObject(arg2);
<span class="line-modified">12976         break;</span>
12977         }
12978             xmlXPathBooleanFunction(ctxt, 1);
12979             if (ctxt-&gt;value != NULL)
12980                 ctxt-&gt;value-&gt;boolval |= arg2-&gt;boolval;
12981         xmlXPathReleaseObject(ctxt-&gt;context, arg2);
<span class="line-modified">12982             break;</span>
12983         case XPATH_OP_EQUAL:
12984             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
12985         CHECK_ERROR0;
12986             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
12987         CHECK_ERROR0;
12988         if (op-&gt;value)
12989         equal = xmlXPathEqualValues(ctxt);
12990         else
12991         equal = xmlXPathNotEqualValues(ctxt);
12992         valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt-&gt;context, equal));
<span class="line-modified">12993             break;</span>
12994         case XPATH_OP_CMP:
12995             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
12996         CHECK_ERROR0;
12997             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
12998         CHECK_ERROR0;
12999             ret = xmlXPathCompareValues(ctxt, op-&gt;value, op-&gt;value2);
13000         valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt-&gt;context, ret));
<span class="line-modified">13001             break;</span>
13002         case XPATH_OP_PLUS:
13003             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13004         CHECK_ERROR0;
13005             if (op-&gt;ch2 != -1) {
13006                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
13007         }
13008         CHECK_ERROR0;
13009             if (op-&gt;value == 0)
13010                 xmlXPathSubValues(ctxt);
13011             else if (op-&gt;value == 1)
13012                 xmlXPathAddValues(ctxt);
13013             else if (op-&gt;value == 2)
13014                 xmlXPathValueFlipSign(ctxt);
13015             else if (op-&gt;value == 3) {
13016                 CAST_TO_NUMBER;
13017                 CHECK_TYPE0(XPATH_NUMBER);
13018             }
<span class="line-modified">13019             break;</span>
13020         case XPATH_OP_MULT:
13021             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13022         CHECK_ERROR0;
13023             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
13024         CHECK_ERROR0;
13025             if (op-&gt;value == 0)
13026                 xmlXPathMultValues(ctxt);
13027             else if (op-&gt;value == 1)
13028                 xmlXPathDivValues(ctxt);
13029             else if (op-&gt;value == 2)
13030                 xmlXPathModValues(ctxt);
<span class="line-modified">13031             break;</span>
13032         case XPATH_OP_UNION:
13033             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13034         CHECK_ERROR0;
13035             total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
13036         CHECK_ERROR0;
13037 
13038             arg2 = valuePop(ctxt);
13039             arg1 = valuePop(ctxt);
13040             if ((arg1 == NULL) || (arg1-&gt;type != XPATH_NODESET) ||
13041                 (arg2 == NULL) || (arg2-&gt;type != XPATH_NODESET)) {
13042             xmlXPathReleaseObject(ctxt-&gt;context, arg1);
13043             xmlXPathReleaseObject(ctxt-&gt;context, arg2);
13044                 XP_ERROR0(XPATH_INVALID_TYPE);
13045             }
<span class="line-added">13046             if ((ctxt-&gt;context-&gt;opLimit != 0) &amp;&amp;</span>
<span class="line-added">13047                 (((arg1-&gt;nodesetval != NULL) &amp;&amp;</span>
<span class="line-added">13048                   (xmlXPathCheckOpLimit(ctxt,</span>
<span class="line-added">13049                                         arg1-&gt;nodesetval-&gt;nodeNr) &lt; 0)) ||</span>
<span class="line-added">13050                  ((arg2-&gt;nodesetval != NULL) &amp;&amp;</span>
<span class="line-added">13051                   (xmlXPathCheckOpLimit(ctxt,</span>
<span class="line-added">13052                                         arg2-&gt;nodesetval-&gt;nodeNr) &lt; 0)))) {</span>
<span class="line-added">13053             xmlXPathReleaseObject(ctxt-&gt;context, arg1);</span>
<span class="line-added">13054             xmlXPathReleaseObject(ctxt-&gt;context, arg2);</span>
<span class="line-added">13055                 break;</span>
<span class="line-added">13056             }</span>
13057 
13058         if ((arg1-&gt;nodesetval == NULL) ||
13059         ((arg2-&gt;nodesetval != NULL) &amp;&amp;
13060          (arg2-&gt;nodesetval-&gt;nodeNr != 0)))
13061         {
<span class="line-added">13062                 /* TODO: Check memory error. */</span>
13063         arg1-&gt;nodesetval = xmlXPathNodeSetMerge(arg1-&gt;nodesetval,
13064                             arg2-&gt;nodesetval);
13065         }
13066 
13067             valuePush(ctxt, arg1);
13068         xmlXPathReleaseObject(ctxt-&gt;context, arg2);
<span class="line-modified">13069             break;</span>
13070         case XPATH_OP_ROOT:
13071             xmlXPathRoot(ctxt);
<span class="line-modified">13072             break;</span>
13073         case XPATH_OP_NODE:
13074             if (op-&gt;ch1 != -1)
13075                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13076         CHECK_ERROR0;
13077             if (op-&gt;ch2 != -1)
13078                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
13079         CHECK_ERROR0;
13080         valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt-&gt;context,
13081         ctxt-&gt;context-&gt;node));
<span class="line-modified">13082             break;</span>
13083         case XPATH_OP_COLLECT:{
13084                 if (op-&gt;ch1 == -1)
<span class="line-modified">13085                     break;</span>
13086 
13087                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13088         CHECK_ERROR0;
13089 
13090                 total += xmlXPathNodeCollectAndTest(ctxt, op, NULL, NULL, 0);
<span class="line-modified">13091                 break;</span>
13092             }
13093         case XPATH_OP_VALUE:
13094             valuePush(ctxt,
13095                       xmlXPathCacheObjectCopy(ctxt-&gt;context,
13096             (xmlXPathObjectPtr) op-&gt;value4));
<span class="line-modified">13097             break;</span>
13098         case XPATH_OP_VARIABLE:{
13099         xmlXPathObjectPtr val;
13100 
13101                 if (op-&gt;ch1 != -1)
13102                     total +=
13103                         xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13104                 if (op-&gt;value5 == NULL) {
13105             val = xmlXPathVariableLookup(ctxt-&gt;context, op-&gt;value4);
13106             if (val == NULL)
13107             XP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);
13108                     valuePush(ctxt, val);
13109         } else {
13110                     const xmlChar *URI;
13111 
13112                     URI = xmlXPathNsLookup(ctxt-&gt;context, op-&gt;value5);
13113                     if (URI == NULL) {
13114                         xmlGenericError(xmlGenericErrorContext,
13115             &quot;xmlXPathCompOpEval: variable %s bound to undefined prefix %s\n&quot;,
13116                                     (char *) op-&gt;value4, (char *)op-&gt;value5);
13117                         ctxt-&gt;error = XPATH_UNDEF_PREFIX_ERROR;
<span class="line-modified">13118                         break;</span>
13119                     }
13120             val = xmlXPathVariableLookupNS(ctxt-&gt;context,
13121                                                        op-&gt;value4, URI);
13122             if (val == NULL)
13123             XP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);
13124                     valuePush(ctxt, val);
13125                 }
<span class="line-modified">13126                 break;</span>
13127             }
13128         case XPATH_OP_FUNCTION:{
13129                 xmlXPathFunction func;
13130                 const xmlChar *oldFunc, *oldFuncURI;
13131         int i;
13132                 int frame;
13133 
13134                 frame = xmlXPathSetFrame(ctxt);
13135                 if (op-&gt;ch1 != -1) {
13136                     total +=
13137                         xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13138                     if (ctxt-&gt;error != XPATH_EXPRESSION_OK) {
13139                         xmlXPathPopFrame(ctxt, frame);
<span class="line-modified">13140                         break;</span>
13141                     }
13142                 }
13143         if (ctxt-&gt;valueNr &lt; ctxt-&gt;valueFrame + op-&gt;value) {
13144             xmlGenericError(xmlGenericErrorContext,
13145                 &quot;xmlXPathCompOpEval: parameter error\n&quot;);
13146             ctxt-&gt;error = XPATH_INVALID_OPERAND;
13147                     xmlXPathPopFrame(ctxt, frame);
<span class="line-modified">13148             break;</span>
13149         }
13150         for (i = 0; i &lt; op-&gt;value; i++) {
13151             if (ctxt-&gt;valueTab[(ctxt-&gt;valueNr - 1) - i] == NULL) {
13152             xmlGenericError(xmlGenericErrorContext,
13153                 &quot;xmlXPathCompOpEval: parameter error\n&quot;);
13154             ctxt-&gt;error = XPATH_INVALID_OPERAND;
13155                         xmlXPathPopFrame(ctxt, frame);
<span class="line-modified">13156             break;</span>
13157             }
13158                 }
13159                 if (op-&gt;cache != NULL)
13160                     func = op-&gt;cache;
13161                 else {
13162                     const xmlChar *URI = NULL;
13163 
13164                     if (op-&gt;value5 == NULL)
13165                         func =
13166                             xmlXPathFunctionLookup(ctxt-&gt;context,
13167                                                    op-&gt;value4);
13168                     else {
13169                         URI = xmlXPathNsLookup(ctxt-&gt;context, op-&gt;value5);
13170                         if (URI == NULL) {
13171                             xmlGenericError(xmlGenericErrorContext,
13172             &quot;xmlXPathCompOpEval: function %s bound to undefined prefix %s\n&quot;,
13173                                     (char *)op-&gt;value4, (char *)op-&gt;value5);
13174                             xmlXPathPopFrame(ctxt, frame);
13175                             ctxt-&gt;error = XPATH_UNDEF_PREFIX_ERROR;
<span class="line-modified">13176                             break;</span>
13177                         }
13178                         func = xmlXPathFunctionLookupNS(ctxt-&gt;context,
13179                                                         op-&gt;value4, URI);
13180                     }
13181                     if (func == NULL) {
13182                         xmlGenericError(xmlGenericErrorContext,
13183                                 &quot;xmlXPathCompOpEval: function %s not found\n&quot;,
13184                                         (char *)op-&gt;value4);
13185                         XP_ERROR0(XPATH_UNKNOWN_FUNC_ERROR);
13186                     }
13187                     op-&gt;cache = func;
13188                     op-&gt;cacheURI = (void *) URI;
13189                 }
13190                 oldFunc = ctxt-&gt;context-&gt;function;
13191                 oldFuncURI = ctxt-&gt;context-&gt;functionURI;
13192                 ctxt-&gt;context-&gt;function = op-&gt;value4;
13193                 ctxt-&gt;context-&gt;functionURI = op-&gt;cacheURI;
13194                 func(ctxt, op-&gt;value);
13195                 ctxt-&gt;context-&gt;function = oldFunc;
13196                 ctxt-&gt;context-&gt;functionURI = oldFuncURI;
<span class="line-added">13197                 if ((ctxt-&gt;error == XPATH_EXPRESSION_OK) &amp;&amp;</span>
<span class="line-added">13198                     (ctxt-&gt;valueNr != ctxt-&gt;valueFrame + 1))</span>
<span class="line-added">13199                     XP_ERROR0(XPATH_STACK_ERROR);</span>
13200                 xmlXPathPopFrame(ctxt, frame);
<span class="line-modified">13201                 break;</span>
13202             }
13203         case XPATH_OP_ARG:
13204             if (op-&gt;ch1 != -1) {
13205                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13206             CHECK_ERROR0;
13207             }
13208             if (op-&gt;ch2 != -1) {
13209                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch2]);
13210             CHECK_ERROR0;
13211         }
<span class="line-modified">13212             break;</span>
13213         case XPATH_OP_PREDICATE:
13214         case XPATH_OP_FILTER:{
<span class="line-modified">13215                 xmlNodeSetPtr set;</span>







13216 
13217                 /*
13218                  * Optimization for ()[1] selection i.e. the first elem
13219                  */
13220                 if ((op-&gt;ch1 != -1) &amp;&amp; (op-&gt;ch2 != -1) &amp;&amp;
13221 #ifdef XP_OPTIMIZED_FILTER_FIRST
13222             /*
13223             * FILTER TODO: Can we assume that the inner processing
13224             *  will result in an ordered list if we have an
13225             *  XPATH_OP_FILTER?
13226             *  What about an additional field or flag on
<span class="line-modified">13227             *  xmlXPathObject like @sorted ? This way we wouldn&#39;t need</span>
13228             *  to assume anything, so it would be more robust and
13229             *  easier to optimize.
13230             */
13231                     ((comp-&gt;steps[op-&gt;ch1].op == XPATH_OP_SORT) || /* 18 */
13232              (comp-&gt;steps[op-&gt;ch1].op == XPATH_OP_FILTER)) &amp;&amp; /* 17 */
13233 #else
13234             (comp-&gt;steps[op-&gt;ch1].op == XPATH_OP_SORT) &amp;&amp;
13235 #endif
13236                     (comp-&gt;steps[op-&gt;ch2].op == XPATH_OP_VALUE)) { /* 12 */
13237                     xmlXPathObjectPtr val;
13238 
13239                     val = comp-&gt;steps[op-&gt;ch2].value4;
13240                     if ((val != NULL) &amp;&amp; (val-&gt;type == XPATH_NUMBER) &amp;&amp;
13241                         (val-&gt;floatval == 1.0)) {
13242                         xmlNodePtr first = NULL;
13243 
13244                         total +=
13245                             xmlXPathCompOpEvalFirst(ctxt,
13246                                                     &amp;comp-&gt;steps[op-&gt;ch1],
13247                                                     &amp;first);
13248             CHECK_ERROR0;
13249                         /*
13250                          * The nodeset should be in document order,
13251                          * Keep only the first value
13252                          */
13253                         if ((ctxt-&gt;value != NULL) &amp;&amp;
13254                             (ctxt-&gt;value-&gt;type == XPATH_NODESET) &amp;&amp;
13255                             (ctxt-&gt;value-&gt;nodesetval != NULL) &amp;&amp;
13256                             (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1))
13257                             xmlXPathNodeSetClearFromPos(ctxt-&gt;value-&gt;nodesetval,
13258                                                         1, 1);
<span class="line-modified">13259                         break;</span>
13260                     }
13261                 }
13262                 /*
13263                  * Optimization for ()[last()] selection i.e. the last elem
13264                  */
13265                 if ((op-&gt;ch1 != -1) &amp;&amp; (op-&gt;ch2 != -1) &amp;&amp;
13266                     (comp-&gt;steps[op-&gt;ch1].op == XPATH_OP_SORT) &amp;&amp;
13267                     (comp-&gt;steps[op-&gt;ch2].op == XPATH_OP_SORT)) {
13268                     int f = comp-&gt;steps[op-&gt;ch2].ch1;
13269 
13270                     if ((f != -1) &amp;&amp;
13271                         (comp-&gt;steps[f].op == XPATH_OP_FUNCTION) &amp;&amp;
13272                         (comp-&gt;steps[f].value5 == NULL) &amp;&amp;
13273                         (comp-&gt;steps[f].value == 0) &amp;&amp;
13274                         (comp-&gt;steps[f].value4 != NULL) &amp;&amp;
13275                         (xmlStrEqual
13276                          (comp-&gt;steps[f].value4, BAD_CAST &quot;last&quot;))) {
13277                         xmlNodePtr last = NULL;
13278 
13279                         total +=
13280                             xmlXPathCompOpEvalLast(ctxt,
13281                                                    &amp;comp-&gt;steps[op-&gt;ch1],
13282                                                    &amp;last);
13283             CHECK_ERROR0;
13284                         /*
13285                          * The nodeset should be in document order,
13286                          * Keep only the last value
13287                          */
13288                         if ((ctxt-&gt;value != NULL) &amp;&amp;
13289                             (ctxt-&gt;value-&gt;type == XPATH_NODESET) &amp;&amp;
13290                             (ctxt-&gt;value-&gt;nodesetval != NULL) &amp;&amp;
13291                             (ctxt-&gt;value-&gt;nodesetval-&gt;nodeTab != NULL) &amp;&amp;
13292                             (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1))
13293                             xmlXPathNodeSetKeepLast(ctxt-&gt;value-&gt;nodesetval);
<span class="line-modified">13294                         break;</span>
13295                     }
13296                 }
13297         /*
13298         * Process inner predicates first.
13299         * Example &quot;index[parent::book][1]&quot;:
13300         * ...
13301         *   PREDICATE   &lt;-- we are here &quot;[1]&quot;
13302         *     PREDICATE &lt;-- process &quot;[parent::book]&quot; first
13303         *       SORT
13304         *         COLLECT  &#39;parent&#39; &#39;name&#39; &#39;node&#39; book
13305         *           NODE
13306         *     ELEM Object is a number : 1
13307         */
13308                 if (op-&gt;ch1 != -1)
13309                     total +=
13310                         xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13311         CHECK_ERROR0;
13312                 if (op-&gt;ch2 == -1)
<span class="line-modified">13313                     break;</span>
13314                 if (ctxt-&gt;value == NULL)
<span class="line-modified">13315                     break;</span>
13316 
13317 #ifdef LIBXML_XPTR_ENABLED
13318                 /*
13319                  * Hum are we filtering the result of an XPointer expression
13320                  */
13321                 if (ctxt-&gt;value-&gt;type == XPATH_LOCATIONSET) {
<span class="line-modified">13322                     xmlLocationSetPtr locset = ctxt-&gt;value-&gt;user;</span>
<span class="line-modified">13323                     xmlXPathLocationSetFilter(ctxt, locset, op-&gt;ch2,</span>
<span class="line-modified">13324                                               1, locset-&gt;locNr);</span>
<span class="line-modified">13325                     break;</span>








































































13326                 }
13327 #endif /* LIBXML_XPTR_ENABLED */
13328 





13329                 CHECK_TYPE0(XPATH_NODESET);
<span class="line-modified">13330                 set = ctxt-&gt;value-&gt;nodesetval;</span>
<span class="line-modified">13331                 if (set != NULL)</span>
<span class="line-modified">13332                     xmlXPathNodeSetFilter(ctxt, set, op-&gt;ch2,</span>
<span class="line-modified">13333                                           1, set-&gt;nodeNr, 1);</span>
<span class="line-modified">13334                 break;</span>























































































































13335             }
13336         case XPATH_OP_SORT:
13337             if (op-&gt;ch1 != -1)
13338                 total += xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13339         CHECK_ERROR0;
13340             if ((ctxt-&gt;value != NULL) &amp;&amp;
13341                 (ctxt-&gt;value-&gt;type == XPATH_NODESET) &amp;&amp;
13342                 (ctxt-&gt;value-&gt;nodesetval != NULL) &amp;&amp;
13343         (ctxt-&gt;value-&gt;nodesetval-&gt;nodeNr &gt; 1))
13344         {
13345                 xmlXPathNodeSetSort(ctxt-&gt;value-&gt;nodesetval);
13346         }
<span class="line-modified">13347             break;</span>
13348 #ifdef LIBXML_XPTR_ENABLED
13349         case XPATH_OP_RANGETO:{
13350                 xmlXPathObjectPtr range;
13351                 xmlXPathObjectPtr res, obj;
13352                 xmlXPathObjectPtr tmp;
13353                 xmlLocationSetPtr newlocset = NULL;
13354             xmlLocationSetPtr oldlocset;
13355                 xmlNodeSetPtr oldset;
13356                 xmlNodePtr oldnode = ctxt-&gt;context-&gt;node;
13357                 int oldcs = ctxt-&gt;context-&gt;contextSize;
13358                 int oldpp = ctxt-&gt;context-&gt;proximityPosition;
13359                 int i, j;
13360 
13361                 if (op-&gt;ch1 != -1) {
13362                     total +=
13363                         xmlXPathCompOpEval(ctxt, &amp;comp-&gt;steps[op-&gt;ch1]);
13364                     CHECK_ERROR0;
13365                 }
13366                 if (ctxt-&gt;value == NULL) {
13367                     XP_ERROR0(XPATH_INVALID_OPERAND);
13368                 }
13369                 if (op-&gt;ch2 == -1)
<span class="line-modified">13370                     break;</span>
13371 
13372                 if (ctxt-&gt;value-&gt;type == XPATH_LOCATIONSET) {
13373                     /*
13374                      * Extract the old locset, and then evaluate the result of the
13375                      * expression for all the element in the locset. use it to grow
13376                      * up a new locset.
13377                      */
13378                     CHECK_TYPE0(XPATH_LOCATIONSET);
13379 
13380                     if ((ctxt-&gt;value-&gt;user == NULL) ||
13381                         (((xmlLocationSetPtr) ctxt-&gt;value-&gt;user)-&gt;locNr == 0))
<span class="line-modified">13382                         break;</span>
13383 
13384                     obj = valuePop(ctxt);
13385                     oldlocset = obj-&gt;user;
13386 
13387                     newlocset = xmlXPtrLocationSetCreate(NULL);
13388 
13389                     for (i = 0; i &lt; oldlocset-&gt;locNr; i++) {
13390                         /*
13391                          * Run the evaluation with a node list made of a
13392                          * single item in the nodelocset.
13393                          */
13394                         ctxt-&gt;context-&gt;node = oldlocset-&gt;locTab[i]-&gt;user;
13395                         ctxt-&gt;context-&gt;contextSize = oldlocset-&gt;locNr;
13396                         ctxt-&gt;context-&gt;proximityPosition = i + 1;
13397             tmp = xmlXPathCacheNewNodeSet(ctxt-&gt;context,
13398                 ctxt-&gt;context-&gt;node);
13399                         valuePush(ctxt, tmp);
13400 
13401                         if (op-&gt;ch2 != -1)
13402                             total +=
</pre>
<hr />
<pre>
13484                             if (res != NULL) {
13485                 xmlXPathReleaseObject(ctxt-&gt;context, res);
13486                 }
13487                             if (ctxt-&gt;value == tmp) {
13488                                 res = valuePop(ctxt);
13489                 xmlXPathReleaseObject(ctxt-&gt;context, res);
13490                             }
13491                         }
13492                     }
13493                 }
13494 
13495                 /*
13496                  * The result is used as the new evaluation set.
13497                  */
13498                 valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));
13499 rangeto_error:
13500         xmlXPathReleaseObject(ctxt-&gt;context, obj);
13501                 ctxt-&gt;context-&gt;node = oldnode;
13502                 ctxt-&gt;context-&gt;contextSize = oldcs;
13503                 ctxt-&gt;context-&gt;proximityPosition = oldpp;
<span class="line-modified">13504                 break;</span>
13505             }
13506 #endif /* LIBXML_XPTR_ENABLED */
<span class="line-modified">13507         default:</span>
13508     xmlGenericError(xmlGenericErrorContext,
13509                     &quot;XPath: unknown precompiled operation %d\n&quot;, op-&gt;op);
13510     ctxt-&gt;error = XPATH_INVALID_OPERAND;
<span class="line-added">13511             break;</span>
<span class="line-added">13512     }</span>
<span class="line-added">13513 </span>
<span class="line-added">13514     ctxt-&gt;context-&gt;depth -= 1;</span>
13515     return (total);
13516 }
13517 
13518 /**
13519  * xmlXPathCompOpEvalToBoolean:
13520  * @ctxt:  the XPath parser context
13521  *
13522  * Evaluates if the expression evaluates to true.
13523  *
13524  * Returns 1 if true, 0 if false and -1 on API or internal errors.
13525  */
13526 static int
13527 xmlXPathCompOpEvalToBoolean(xmlXPathParserContextPtr ctxt,
13528                 xmlXPathStepOpPtr op,
13529                 int isPredicate)
13530 {
13531     xmlXPathObjectPtr resObj = NULL;
13532 
13533 start:
<span class="line-added">13534     if (OP_LIMIT_EXCEEDED(ctxt, 1))</span>
<span class="line-added">13535         return(0);</span>
13536     /* comp = ctxt-&gt;comp; */
13537     switch (op-&gt;op) {
13538         case XPATH_OP_END:
13539             return (0);
13540     case XPATH_OP_VALUE:
13541         resObj = (xmlXPathObjectPtr) op-&gt;value4;
13542         if (isPredicate)
13543         return(xmlXPathEvaluatePredicateResult(ctxt, resObj));
13544         return(xmlXPathCastToBoolean(resObj));
13545     case XPATH_OP_SORT:
13546         /*
13547         * We don&#39;t need sorting for boolean results. Skip this one.
13548         */
13549             if (op-&gt;ch1 != -1) {
13550         op = &amp;ctxt-&gt;comp-&gt;steps[op-&gt;ch1];
13551         goto start;
13552         }
13553         return(0);
13554     case XPATH_OP_COLLECT:
13555         if (op-&gt;ch1 == -1)
</pre>
<hr />
<pre>
13642 #if 0
13643     printf(&quot;stream eval: depth %d from root %d\n&quot;, max_depth, from_root);
13644 #endif
13645 
13646     if (! toBool) {
13647     if (resultSeq == NULL)
13648         return(-1);
13649     *resultSeq = xmlXPathCacheNewNodeSet(ctxt, NULL);
13650     if (*resultSeq == NULL)
13651         return(-1);
13652     }
13653 
13654     /*
13655      * handle the special cases of &quot;/&quot; amd &quot;.&quot; being matched
13656      */
13657     if (min_depth == 0) {
13658     if (from_root) {
13659         /* Select &quot;/&quot; */
13660         if (toBool)
13661         return(1);
<span class="line-added">13662             /* TODO: Check memory error. */</span>
13663         xmlXPathNodeSetAddUnique((*resultSeq)-&gt;nodesetval,
13664                              (xmlNodePtr) ctxt-&gt;doc);
13665     } else {
13666         /* Select &quot;self::node()&quot; */
13667         if (toBool)
13668         return(1);
<span class="line-added">13669             /* TODO: Check memory error. */</span>
13670         xmlXPathNodeSetAddUnique((*resultSeq)-&gt;nodesetval, ctxt-&gt;node);
13671     }
13672     }
13673     if (max_depth == 0) {
13674     return(0);
13675     }
13676 
13677     if (from_root) {
13678         cur = (xmlNodePtr)ctxt-&gt;doc;
13679     } else if (ctxt-&gt;node != NULL) {
13680         switch (ctxt-&gt;node-&gt;type) {
13681             case XML_ELEMENT_NODE:
13682             case XML_DOCUMENT_NODE:
13683             case XML_DOCUMENT_FRAG_NODE:
13684             case XML_HTML_DOCUMENT_NODE:
13685 #ifdef LIBXML_DOCB_ENABLED
13686             case XML_DOCB_DOCUMENT_NODE:
13687 #endif
13688             cur = ctxt-&gt;node;
13689         break;
</pre>
<hr />
<pre>
13710     if (cur == NULL) {
13711         return(0);
13712     }
13713 
13714     patstream = xmlPatternGetStreamCtxt(comp);
13715     if (patstream == NULL) {
13716     /*
13717     * QUESTION TODO: Is this an error?
13718     */
13719     return(0);
13720     }
13721 
13722     eval_all_nodes = xmlStreamWantsAnyNode(patstream);
13723 
13724     if (from_root) {
13725     ret = xmlStreamPush(patstream, NULL, NULL);
13726     if (ret &lt; 0) {
13727     } else if (ret == 1) {
13728         if (toBool)
13729         goto return_1;
<span class="line-added">13730             /* TODO: Check memory error. */</span>
13731         xmlXPathNodeSetAddUnique((*resultSeq)-&gt;nodesetval, cur);
13732     }
13733     }
13734     depth = 0;
13735     goto scan_children;
13736 next_node:
13737     do {
<span class="line-added">13738         if (ctxt-&gt;opLimit != 0) {</span>
<span class="line-added">13739             if (ctxt-&gt;opCount &gt;= ctxt-&gt;opLimit) {</span>
<span class="line-added">13740                 xmlGenericError(xmlGenericErrorContext,</span>
<span class="line-added">13741                         &quot;XPath operation limit exceeded\n&quot;);</span>
<span class="line-added">13742                 xmlFreeStreamCtxt(patstream);</span>
<span class="line-added">13743                 return(-1);</span>
<span class="line-added">13744             }</span>
<span class="line-added">13745             ctxt-&gt;opCount++;</span>
<span class="line-added">13746         }</span>
<span class="line-added">13747 </span>
13748         nb_nodes++;
13749 
13750     switch (cur-&gt;type) {
13751         case XML_ELEMENT_NODE:
13752         case XML_TEXT_NODE:
13753         case XML_CDATA_SECTION_NODE:
13754         case XML_COMMENT_NODE:
13755         case XML_PI_NODE:
13756         if (cur-&gt;type == XML_ELEMENT_NODE) {
13757             ret = xmlStreamPush(patstream, cur-&gt;name,
13758                 (cur-&gt;ns ? cur-&gt;ns-&gt;href : NULL));
13759         } else if (eval_all_nodes)
13760             ret = xmlStreamPushNode(patstream, NULL, NULL, cur-&gt;type);
13761         else
13762             break;
13763 
13764         if (ret &lt; 0) {
13765             /* NOP. */
13766         } else if (ret == 1) {
13767             if (toBool)
</pre>
<hr />
<pre>
13851     xmlFreeStreamCtxt(patstream);
13852     return(1);
13853 }
13854 #endif /* XPATH_STREAMING */
13855 
13856 /**
13857  * xmlXPathRunEval:
13858  * @ctxt:  the XPath parser context with the compiled expression
13859  * @toBool:  evaluate to a boolean result
13860  *
13861  * Evaluate the Precompiled XPath expression in the given context.
13862  */
13863 static int
13864 xmlXPathRunEval(xmlXPathParserContextPtr ctxt, int toBool)
13865 {
13866     xmlXPathCompExprPtr comp;
13867 
13868     if ((ctxt == NULL) || (ctxt-&gt;comp == NULL))
13869     return(-1);
13870 
<span class="line-added">13871     ctxt-&gt;context-&gt;depth = 0;</span>
<span class="line-added">13872 </span>
13873     if (ctxt-&gt;valueTab == NULL) {
13874     /* Allocate the value stack */
13875     ctxt-&gt;valueTab = (xmlXPathObjectPtr *)
13876              xmlMalloc(10 * sizeof(xmlXPathObjectPtr));
13877     if (ctxt-&gt;valueTab == NULL) {
13878         xmlXPathPErrMemory(ctxt, &quot;creating evaluation context\n&quot;);
13879         xmlFree(ctxt);
13880     }
13881     ctxt-&gt;valueNr = 0;
13882     ctxt-&gt;valueMax = 10;
13883     ctxt-&gt;value = NULL;
13884         ctxt-&gt;valueFrame = 0;
13885     }
13886 #ifdef XPATH_STREAMING
13887     if (ctxt-&gt;comp-&gt;stream) {
13888     int res;
13889 
13890     if (toBool) {
13891         /*
13892         * Evaluation to boolean result.
</pre>
<hr />
<pre>
14039  */
14040 static xmlXPathCompExprPtr
14041 xmlXPathTryStreamCompile(xmlXPathContextPtr ctxt, const xmlChar *str) {
14042     /*
14043      * Optimization: use streaming patterns when the XPath expression can
14044      * be compiled to a stream lookup
14045      */
14046     xmlPatternPtr stream;
14047     xmlXPathCompExprPtr comp;
14048     xmlDictPtr dict = NULL;
14049     const xmlChar **namespaces = NULL;
14050     xmlNsPtr ns;
14051     int i, j;
14052 
14053     if ((!xmlStrchr(str, &#39;[&#39;)) &amp;&amp; (!xmlStrchr(str, &#39;(&#39;)) &amp;&amp;
14054         (!xmlStrchr(str, &#39;@&#39;))) {
14055     const xmlChar *tmp;
14056 
14057     /*
14058      * We don&#39;t try to handle expressions using the verbose axis
<span class="line-modified">14059      * specifiers (&quot;::&quot;), just the simplified form at this point.</span>
14060      * Additionally, if there is no list of namespaces available and
14061      *  there&#39;s a &quot;:&quot; in the expression, indicating a prefixed QName,
14062      *  then we won&#39;t try to compile either. xmlPatterncompile() needs
14063      *  to have a list of namespaces at compilation time in order to
14064      *  compile prefixed name tests.
14065      */
14066     tmp = xmlStrchr(str, &#39;:&#39;);
14067     if ((tmp != NULL) &amp;&amp;
14068         ((ctxt == NULL) || (ctxt-&gt;nsNr == 0) || (tmp[1] == &#39;:&#39;)))
14069         return(NULL);
14070 
14071     if (ctxt != NULL) {
14072         dict = ctxt-&gt;dict;
14073         if (ctxt-&gt;nsNr &gt; 0) {
14074         namespaces = xmlMalloc(2 * (ctxt-&gt;nsNr + 1) * sizeof(xmlChar*));
14075         if (namespaces == NULL) {
14076             xmlXPathErrMemory(ctxt, &quot;allocating namespaces array\n&quot;);
14077             return(NULL);
14078         }
14079         for (i = 0, j = 0; (j &lt; ctxt-&gt;nsNr); j++) {
</pre>
<hr />
<pre>
14093     }
14094     if ((stream != NULL) &amp;&amp; (xmlPatternStreamable(stream) == 1)) {
14095         comp = xmlXPathNewCompExpr();
14096         if (comp == NULL) {
14097         xmlXPathErrMemory(ctxt, &quot;allocating streamable expression\n&quot;);
14098         return(NULL);
14099         }
14100         comp-&gt;stream = stream;
14101         comp-&gt;dict = dict;
14102         if (comp-&gt;dict)
14103         xmlDictReference(comp-&gt;dict);
14104         return(comp);
14105     }
14106     xmlFreePattern(stream);
14107     }
14108     return(NULL);
14109 }
14110 #endif /* XPATH_STREAMING */
14111 
14112 static void
<span class="line-modified">14113 xmlXPathOptimizeExpression(xmlXPathParserContextPtr pctxt,</span>
<span class="line-added">14114                            xmlXPathStepOpPtr op)</span>
14115 {
<span class="line-added">14116     xmlXPathCompExprPtr comp = pctxt-&gt;comp;</span>
<span class="line-added">14117     xmlXPathContextPtr ctxt;</span>
<span class="line-added">14118 </span>
14119     /*
14120     * Try to rewrite &quot;descendant-or-self::node()/foo&quot; to an optimized
14121     * internal representation.
14122     */
14123 
14124     if ((op-&gt;op == XPATH_OP_COLLECT /* 11 */) &amp;&amp;
14125         (op-&gt;ch1 != -1) &amp;&amp;
14126         (op-&gt;ch2 == -1 /* no predicate */))
14127     {
14128         xmlXPathStepOpPtr prevop = &amp;comp-&gt;steps[op-&gt;ch1];
14129 
14130         if ((prevop-&gt;op == XPATH_OP_COLLECT /* 11 */) &amp;&amp;
14131             ((xmlXPathAxisVal) prevop-&gt;value ==
14132                 AXIS_DESCENDANT_OR_SELF) &amp;&amp;
14133             (prevop-&gt;ch2 == -1) &amp;&amp;
14134             ((xmlXPathTestVal) prevop-&gt;value2 == NODE_TEST_TYPE) &amp;&amp;
14135             ((xmlXPathTypeVal) prevop-&gt;value3 == NODE_TYPE_NODE))
14136         {
14137             /*
14138             * This is a &quot;descendant-or-self::node()&quot; without predicates.
</pre>
<hr />
<pre>
14154                 case AXIS_DESCENDANT_OR_SELF:
14155                     /*
14156                     * Convert &quot;descendant-or-self::node()/self::&quot; or
14157                     * &quot;descendant-or-self::node()/descendant-or-self::&quot; to
14158                     * to &quot;descendant-or-self::&quot;
14159                     */
14160                     op-&gt;ch1   = prevop-&gt;ch1;
14161                     op-&gt;value = AXIS_DESCENDANT_OR_SELF;
14162                     break;
14163                 default:
14164                     break;
14165             }
14166     }
14167     }
14168 
14169     /* OP_VALUE has invalid ch1. */
14170     if (op-&gt;op == XPATH_OP_VALUE)
14171         return;
14172 
14173     /* Recurse */
<span class="line-added">14174     ctxt = pctxt-&gt;context;</span>
<span class="line-added">14175     if (ctxt != NULL) {</span>
<span class="line-added">14176         if (ctxt-&gt;depth &gt;= ctxt-&gt;maxDepth)</span>
<span class="line-added">14177             return;</span>
<span class="line-added">14178         ctxt-&gt;depth += 1;</span>
<span class="line-added">14179     }</span>
14180     if (op-&gt;ch1 != -1)
<span class="line-modified">14181         xmlXPathOptimizeExpression(pctxt, &amp;comp-&gt;steps[op-&gt;ch1]);</span>
14182     if (op-&gt;ch2 != -1)
<span class="line-modified">14183     xmlXPathOptimizeExpression(pctxt, &amp;comp-&gt;steps[op-&gt;ch2]);</span>
<span class="line-added">14184     if (ctxt != NULL)</span>
<span class="line-added">14185         ctxt-&gt;depth -= 1;</span>
14186 }
14187 
14188 /**
14189  * xmlXPathCtxtCompile:
14190  * @ctxt: an XPath context
14191  * @str:  the XPath expression
14192  *
14193  * Compile an XPath expression
14194  *
14195  * Returns the xmlXPathCompExprPtr resulting from the compilation or NULL.
14196  *         the caller has to free the object.
14197  */
14198 xmlXPathCompExprPtr
14199 xmlXPathCtxtCompile(xmlXPathContextPtr ctxt, const xmlChar *str) {
14200     xmlXPathParserContextPtr pctxt;
14201     xmlXPathCompExprPtr comp;
14202 
14203 #ifdef XPATH_STREAMING
14204     comp = xmlXPathTryStreamCompile(ctxt, str);
14205     if (comp != NULL)
14206         return(comp);
14207 #endif
14208 
14209     xmlXPathInit();
14210 
14211     pctxt = xmlXPathNewParserContext(str, ctxt);
14212     if (pctxt == NULL)
14213         return NULL;
<span class="line-added">14214     if (ctxt != NULL)</span>
<span class="line-added">14215         ctxt-&gt;depth = 0;</span>
14216     xmlXPathCompileExpr(pctxt, 1);
14217 
14218     if( pctxt-&gt;error != XPATH_EXPRESSION_OK )
14219     {
14220         xmlXPathFreeParserContext(pctxt);
14221         return(NULL);
14222     }
14223 
14224     if (*pctxt-&gt;cur != 0) {
14225     /*
14226      * aleksey: in some cases this line prints *second* error message
14227      * (see bug #78858) and probably this should be fixed.
14228      * However, we are not sure that all error messages are printed
14229      * out in other places. It&#39;s not critical so we leave it as-is for now
14230      */
14231     xmlXPatherror(pctxt, __FILE__, __LINE__, XPATH_EXPR_ERROR);
14232     comp = NULL;
14233     } else {
14234     comp = pctxt-&gt;comp;
<span class="line-added">14235     if ((comp-&gt;nbStep &gt; 1) &amp;&amp; (comp-&gt;last &gt;= 0)) {</span>
<span class="line-added">14236             if (ctxt != NULL)</span>
<span class="line-added">14237                 ctxt-&gt;depth = 0;</span>
<span class="line-added">14238         xmlXPathOptimizeExpression(pctxt, &amp;comp-&gt;steps[comp-&gt;last]);</span>
<span class="line-added">14239     }</span>
14240     pctxt-&gt;comp = NULL;
14241     }
14242     xmlXPathFreeParserContext(pctxt);
14243 
14244     if (comp != NULL) {
14245     comp-&gt;expr = xmlStrdup(str);
14246 #ifdef DEBUG_EVAL_COUNTS
14247     comp-&gt;string = xmlStrdup(str);
14248     comp-&gt;nb = 0;
14249 #endif



14250     }
14251     return(comp);
14252 }
14253 
14254 /**
14255  * xmlXPathCompile:
14256  * @str:  the XPath expression
14257  *
14258  * Compile an XPath expression
14259  *
14260  * Returns the xmlXPathCompExprPtr resulting from the compilation or NULL.
14261  *         the caller has to free the object.
14262  */
14263 xmlXPathCompExprPtr
14264 xmlXPathCompile(const xmlChar *str) {
14265     return(xmlXPathCtxtCompile(NULL, str));
14266 }
14267 
14268 /**
14269  * xmlXPathCompiledEvalInternal:
</pre>
<hr />
<pre>
14386  * Parse and evaluate an XPath expression in the given context,
14387  * then push the result on the context stack
14388  */
14389 void
14390 xmlXPathEvalExpr(xmlXPathParserContextPtr ctxt) {
14391 #ifdef XPATH_STREAMING
14392     xmlXPathCompExprPtr comp;
14393 #endif
14394 
14395     if (ctxt == NULL) return;
14396 
14397 #ifdef XPATH_STREAMING
14398     comp = xmlXPathTryStreamCompile(ctxt-&gt;context, ctxt-&gt;base);
14399     if (comp != NULL) {
14400         if (ctxt-&gt;comp != NULL)
14401         xmlXPathFreeCompExpr(ctxt-&gt;comp);
14402         ctxt-&gt;comp = comp;
14403     } else
14404 #endif
14405     {
<span class="line-added">14406         if (ctxt-&gt;context != NULL)</span>
<span class="line-added">14407             ctxt-&gt;context-&gt;depth = 0;</span>
14408     xmlXPathCompileExpr(ctxt, 1);
14409         CHECK_ERROR;
14410 
14411         /* Check for trailing characters. */
14412         if (*ctxt-&gt;cur != 0)
14413             XP_ERROR(XPATH_EXPR_ERROR);
14414 
<span class="line-modified">14415     if ((ctxt-&gt;comp-&gt;nbStep &gt; 1) &amp;&amp; (ctxt-&gt;comp-&gt;last &gt;= 0)) {</span>
<span class="line-modified">14416             if (ctxt-&gt;context != NULL)</span>
<span class="line-added">14417                 ctxt-&gt;context-&gt;depth = 0;</span>
<span class="line-added">14418         xmlXPathOptimizeExpression(ctxt,</span>
14419         &amp;ctxt-&gt;comp-&gt;steps[ctxt-&gt;comp-&gt;last]);
14420     }
<span class="line-added">14421     }</span>
14422 
14423     xmlXPathRunEval(ctxt, 0);
14424 }
14425 
14426 /**
14427  * xmlXPathEval:
14428  * @str:  the XPath expression
14429  * @ctx:  the XPath context
14430  *
14431  * Evaluate the XPath Location Path in the given context.
14432  *
14433  * Returns the xmlXPathObjectPtr resulting from the evaluation or NULL.
14434  *         the caller has to free the object.
14435  */
14436 xmlXPathObjectPtr
14437 xmlXPathEval(const xmlChar *str, xmlXPathContextPtr ctx) {
14438     xmlXPathParserContextPtr ctxt;
14439     xmlXPathObjectPtr res;
14440 
14441     CHECK_CTXT(ctx)
</pre>
</td>
</tr>
</table>
<center><a href="xmlwriter.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="xzlib.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
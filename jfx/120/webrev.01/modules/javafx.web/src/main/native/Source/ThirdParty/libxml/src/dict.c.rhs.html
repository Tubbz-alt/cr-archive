<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/dict.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * dict.c: dictionary of reusable strings, just used to avoid allocation
   3  *         and freeing operations.
   4  *
   5  * Copyright (C) 2003-2012 Daniel Veillard.
   6  *
   7  * Permission to use, copy, modify, and distribute this software for any
   8  * purpose with or without fee is hereby granted, provided that the above
   9  * copyright notice and this permission notice appear in all copies.
  10  *
  11  * THIS SOFTWARE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR IMPLIED
  12  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  13  * MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
  14  * CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER.
  15  *
  16  * Author: daniel@veillard.com
  17  */
  18 
  19 #define IN_LIBXML
  20 #include &quot;libxml.h&quot;
  21 
  22 #include &lt;limits.h&gt;
  23 #ifdef HAVE_STDLIB_H
  24 #include &lt;stdlib.h&gt;
  25 #endif
  26 #ifdef HAVE_TIME_H
  27 #include &lt;time.h&gt;
  28 #endif
  29 
  30 /*
  31  * Following http://www.ocert.org/advisories/ocert-2011-003.html
  32  * it seems that having hash randomization might be a good idea
  33  * when using XML with untrusted data
  34  * Note1: that it works correctly only if compiled with WITH_BIG_KEY
  35  *  which is the default.
  36  * Note2: the fast function used for a small dict won&#39;t protect very
  37  *  well but since the attack is based on growing a very big hash
  38  *  list we will use the BigKey algo as soon as the hash size grows
  39  *  over MIN_DICT_SIZE so this actually works
  40  */
<a name="1" id="anc1"></a><span class="line-modified">  41 #if defined(HAVE_RAND) &amp;&amp; defined(HAVE_SRAND) &amp;&amp; defined(HAVE_TIME) &amp;&amp; \</span>
<span class="line-added">  42     !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)</span>
  43 #define DICT_RANDOMIZATION
  44 #endif
  45 
  46 #include &lt;string.h&gt;
  47 #ifdef HAVE_STDINT_H
  48 #include &lt;stdint.h&gt;
  49 #else
  50 #ifdef HAVE_INTTYPES_H
  51 #include &lt;inttypes.h&gt;
  52 #elif defined(_WIN32)
  53 typedef unsigned __int32 uint32_t;
  54 #endif
  55 #endif
  56 #include &lt;libxml/tree.h&gt;
  57 #include &lt;libxml/dict.h&gt;
  58 #include &lt;libxml/xmlmemory.h&gt;
  59 #include &lt;libxml/xmlerror.h&gt;
  60 #include &lt;libxml/globals.h&gt;
  61 
  62 /* #define DEBUG_GROW */
  63 /* #define DICT_DEBUG_PATTERNS */
  64 
  65 #define MAX_HASH_LEN 3
  66 #define MIN_DICT_SIZE 128
  67 #define MAX_DICT_HASH 8 * 2048
  68 #define WITH_BIG_KEY
  69 
  70 #ifdef WITH_BIG_KEY
  71 #define xmlDictComputeKey(dict, name, len)                              \
  72     (((dict)-&gt;size == MIN_DICT_SIZE) ?                                  \
  73      xmlDictComputeFastKey(name, len, (dict)-&gt;seed) :                   \
  74      xmlDictComputeBigKey(name, len, (dict)-&gt;seed))
  75 
  76 #define xmlDictComputeQKey(dict, prefix, plen, name, len)               \
  77     (((prefix) == NULL) ?                                               \
  78       (xmlDictComputeKey(dict, name, len)) :                             \
  79       (((dict)-&gt;size == MIN_DICT_SIZE) ?                                \
  80        xmlDictComputeFastQKey(prefix, plen, name, len, (dict)-&gt;seed) :  \
  81        xmlDictComputeBigQKey(prefix, plen, name, len, (dict)-&gt;seed)))
  82 
  83 #else /* !WITH_BIG_KEY */
  84 #define xmlDictComputeKey(dict, name, len)                              \
  85         xmlDictComputeFastKey(name, len, (dict)-&gt;seed)
  86 #define xmlDictComputeQKey(dict, prefix, plen, name, len)               \
  87         xmlDictComputeFastQKey(prefix, plen, name, len, (dict)-&gt;seed)
  88 #endif /* WITH_BIG_KEY */
  89 
  90 /*
  91  * An entry in the dictionary
  92  */
  93 typedef struct _xmlDictEntry xmlDictEntry;
  94 typedef xmlDictEntry *xmlDictEntryPtr;
  95 struct _xmlDictEntry {
  96     struct _xmlDictEntry *next;
  97     const xmlChar *name;
  98     unsigned int len;
  99     int valid;
 100     unsigned long okey;
 101 };
 102 
 103 typedef struct _xmlDictStrings xmlDictStrings;
 104 typedef xmlDictStrings *xmlDictStringsPtr;
 105 struct _xmlDictStrings {
 106     xmlDictStringsPtr next;
 107     xmlChar *free;
 108     xmlChar *end;
 109     size_t size;
 110     size_t nbStrings;
 111     xmlChar array[1];
 112 };
 113 /*
 114  * The entire dictionary
 115  */
 116 struct _xmlDict {
 117     int ref_counter;
 118 
 119     struct _xmlDictEntry *dict;
 120     size_t size;
 121     unsigned int nbElems;
 122     xmlDictStringsPtr strings;
 123 
 124     struct _xmlDict *subdict;
 125     /* used for randomization */
 126     int seed;
 127     /* used to impose a limit on size */
 128     size_t limit;
 129 };
 130 
 131 /*
 132  * A mutex for modifying the reference counter for shared
 133  * dictionaries.
 134  */
 135 static xmlRMutexPtr xmlDictMutex = NULL;
 136 
 137 /*
 138  * Whether the dictionary mutex was initialized.
 139  */
 140 static int xmlDictInitialized = 0;
 141 
 142 #ifdef DICT_RANDOMIZATION
 143 #ifdef HAVE_RAND_R
 144 /*
 145  * Internal data for random function, protected by xmlDictMutex
 146  */
 147 static unsigned int rand_seed = 0;
 148 #endif
 149 #endif
 150 
 151 /**
 152  * xmlInitializeDict:
 153  *
 154  * Do the dictionary mutex initialization.
 155  * this function is deprecated
 156  *
 157  * Returns 0 if initialization was already done, and 1 if that
 158  * call led to the initialization
 159  */
 160 int xmlInitializeDict(void) {
 161     return(0);
 162 }
 163 
 164 /**
 165  * __xmlInitializeDict:
 166  *
 167  * This function is not public
 168  * Do the dictionary mutex initialization.
 169  * this function is not thread safe, initialization should
 170  * normally be done once at setup when called from xmlOnceInit()
 171  * we may also land in this code if thread support is not compiled in
 172  *
 173  * Returns 0 if initialization was already done, and 1 if that
 174  * call led to the initialization
 175  */
 176 int __xmlInitializeDict(void) {
 177     if (xmlDictInitialized)
 178         return(1);
 179 
 180     if ((xmlDictMutex = xmlNewRMutex()) == NULL)
 181         return(0);
 182     xmlRMutexLock(xmlDictMutex);
 183 
 184 #ifdef DICT_RANDOMIZATION
 185 #ifdef HAVE_RAND_R
 186     rand_seed = time(NULL);
 187     rand_r(&amp; rand_seed);
 188 #else
 189     srand(time(NULL));
 190 #endif
 191 #endif
 192     xmlDictInitialized = 1;
 193     xmlRMutexUnlock(xmlDictMutex);
 194     return(1);
 195 }
 196 
 197 #ifdef DICT_RANDOMIZATION
 198 int __xmlRandom(void) {
 199     int ret;
 200 
 201     if (xmlDictInitialized == 0)
 202         __xmlInitializeDict();
 203 
 204     xmlRMutexLock(xmlDictMutex);
 205 #ifdef HAVE_RAND_R
 206     ret = rand_r(&amp; rand_seed);
 207 #else
 208     ret = rand();
 209 #endif
 210     xmlRMutexUnlock(xmlDictMutex);
 211     return(ret);
 212 }
 213 #endif
 214 
 215 /**
 216  * xmlDictCleanup:
 217  *
 218  * Free the dictionary mutex. Do not call unless sure the library
 219  * is not in use anymore !
 220  */
 221 void
 222 xmlDictCleanup(void) {
 223     if (!xmlDictInitialized)
 224         return;
 225 
 226     xmlFreeRMutex(xmlDictMutex);
 227 
 228     xmlDictInitialized = 0;
 229 }
 230 
 231 /*
 232  * xmlDictAddString:
 233  * @dict: the dictionary
 234  * @name: the name of the userdata
 235  * @len: the length of the name
 236  *
 237  * Add the string to the array[s]
 238  *
 239  * Returns the pointer of the local string, or NULL in case of error.
 240  */
 241 static const xmlChar *
 242 xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) {
 243     xmlDictStringsPtr pool;
 244     const xmlChar *ret;
 245     size_t size = 0; /* + sizeof(_xmlDictStrings) == 1024 */
 246     size_t limit = 0;
 247 
 248 #ifdef DICT_DEBUG_PATTERNS
 249     fprintf(stderr, &quot;-&quot;);
 250 #endif
 251     pool = dict-&gt;strings;
 252     while (pool != NULL) {
 253     if ((size_t)(pool-&gt;end - pool-&gt;free) &gt; namelen)
 254         goto found_pool;
 255     if (pool-&gt;size &gt; size) size = pool-&gt;size;
 256         limit += pool-&gt;size;
 257     pool = pool-&gt;next;
 258     }
 259     /*
 260      * Not found, need to allocate
 261      */
 262     if (pool == NULL) {
 263         if ((dict-&gt;limit &gt; 0) &amp;&amp; (limit &gt; dict-&gt;limit)) {
 264             return(NULL);
 265         }
 266 
 267         if (size == 0) size = 1000;
 268     else size *= 4; /* exponential growth */
 269         if (size &lt; 4 * namelen)
 270         size = 4 * namelen; /* just in case ! */
 271     pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);
 272     if (pool == NULL)
 273         return(NULL);
 274     pool-&gt;size = size;
 275     pool-&gt;nbStrings = 0;
 276     pool-&gt;free = &amp;pool-&gt;array[0];
 277     pool-&gt;end = &amp;pool-&gt;array[size];
 278     pool-&gt;next = dict-&gt;strings;
 279     dict-&gt;strings = pool;
 280 #ifdef DICT_DEBUG_PATTERNS
 281         fprintf(stderr, &quot;+&quot;);
 282 #endif
 283     }
 284 found_pool:
 285     ret = pool-&gt;free;
 286     memcpy(pool-&gt;free, name, namelen);
 287     pool-&gt;free += namelen;
 288     *(pool-&gt;free++) = 0;
 289     pool-&gt;nbStrings++;
 290     return(ret);
 291 }
 292 
 293 /*
 294  * xmlDictAddQString:
 295  * @dict: the dictionary
 296  * @prefix: the prefix of the userdata
 297  * @plen: the prefix length
 298  * @name: the name of the userdata
 299  * @len: the length of the name
 300  *
 301  * Add the QName to the array[s]
 302  *
 303  * Returns the pointer of the local string, or NULL in case of error.
 304  */
 305 static const xmlChar *
 306 xmlDictAddQString(xmlDictPtr dict, const xmlChar *prefix, unsigned int plen,
 307                  const xmlChar *name, unsigned int namelen)
 308 {
 309     xmlDictStringsPtr pool;
 310     const xmlChar *ret;
 311     size_t size = 0; /* + sizeof(_xmlDictStrings) == 1024 */
 312     size_t limit = 0;
 313 
 314     if (prefix == NULL) return(xmlDictAddString(dict, name, namelen));
 315 
 316 #ifdef DICT_DEBUG_PATTERNS
 317     fprintf(stderr, &quot;=&quot;);
 318 #endif
 319     pool = dict-&gt;strings;
 320     while (pool != NULL) {
 321     if ((size_t)(pool-&gt;end - pool-&gt;free) &gt; namelen + plen + 1)
 322         goto found_pool;
 323     if (pool-&gt;size &gt; size) size = pool-&gt;size;
 324         limit += pool-&gt;size;
 325     pool = pool-&gt;next;
 326     }
 327     /*
 328      * Not found, need to allocate
 329      */
 330     if (pool == NULL) {
 331         if ((dict-&gt;limit &gt; 0) &amp;&amp; (limit &gt; dict-&gt;limit)) {
 332             return(NULL);
 333         }
 334 
 335         if (size == 0) size = 1000;
 336     else size *= 4; /* exponential growth */
 337         if (size &lt; 4 * (namelen + plen + 1))
 338         size = 4 * (namelen + plen + 1); /* just in case ! */
 339     pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);
 340     if (pool == NULL)
 341         return(NULL);
 342     pool-&gt;size = size;
 343     pool-&gt;nbStrings = 0;
 344     pool-&gt;free = &amp;pool-&gt;array[0];
 345     pool-&gt;end = &amp;pool-&gt;array[size];
 346     pool-&gt;next = dict-&gt;strings;
 347     dict-&gt;strings = pool;
 348 #ifdef DICT_DEBUG_PATTERNS
 349         fprintf(stderr, &quot;+&quot;);
 350 #endif
 351     }
 352 found_pool:
 353     ret = pool-&gt;free;
 354     memcpy(pool-&gt;free, prefix, plen);
 355     pool-&gt;free += plen;
 356     *(pool-&gt;free++) = &#39;:&#39;;
 357     memcpy(pool-&gt;free, name, namelen);
 358     pool-&gt;free += namelen;
 359     *(pool-&gt;free++) = 0;
 360     pool-&gt;nbStrings++;
 361     return(ret);
 362 }
 363 
 364 #ifdef WITH_BIG_KEY
 365 /*
 366  * xmlDictComputeBigKey:
 367  *
 368  * Calculate a hash key using a good hash function that works well for
 369  * larger hash table sizes.
 370  *
 371  * Hash function by &quot;One-at-a-Time Hash&quot; see
 372  * http://burtleburtle.net/bob/hash/doobs.html
 373  */
 374 
<a name="2" id="anc2"></a><span class="line-added"> 375 #ifdef __clang__</span>
<span class="line-added"> 376 ATTRIBUTE_NO_SANITIZE(&quot;unsigned-integer-overflow&quot;)</span>
<span class="line-added"> 377 #endif</span>
 378 static uint32_t
 379 xmlDictComputeBigKey(const xmlChar* data, int namelen, int seed) {
 380     uint32_t hash;
 381     int i;
 382 
 383     if (namelen &lt;= 0 || data == NULL) return(0);
 384 
 385     hash = seed;
 386 
 387     for (i = 0;i &lt; namelen; i++) {
 388         hash += data[i];
 389     hash += (hash &lt;&lt; 10);
 390     hash ^= (hash &gt;&gt; 6);
 391     }
 392     hash += (hash &lt;&lt; 3);
 393     hash ^= (hash &gt;&gt; 11);
 394     hash += (hash &lt;&lt; 15);
 395 
 396     return hash;
 397 }
 398 
 399 /*
 400  * xmlDictComputeBigQKey:
 401  *
 402  * Calculate a hash key for two strings using a good hash function
 403  * that works well for larger hash table sizes.
 404  *
 405  * Hash function by &quot;One-at-a-Time Hash&quot; see
 406  * http://burtleburtle.net/bob/hash/doobs.html
 407  *
 408  * Neither of the two strings must be NULL.
 409  */
<a name="3" id="anc3"></a><span class="line-added"> 410 #ifdef __clang__</span>
<span class="line-added"> 411 ATTRIBUTE_NO_SANITIZE(&quot;unsigned-integer-overflow&quot;)</span>
<span class="line-added"> 412 #endif</span>
 413 static unsigned long
 414 xmlDictComputeBigQKey(const xmlChar *prefix, int plen,
 415                       const xmlChar *name, int len, int seed)
 416 {
 417     uint32_t hash;
 418     int i;
 419 
 420     hash = seed;
 421 
 422     for (i = 0;i &lt; plen; i++) {
 423         hash += prefix[i];
 424     hash += (hash &lt;&lt; 10);
 425     hash ^= (hash &gt;&gt; 6);
 426     }
 427     hash += &#39;:&#39;;
 428     hash += (hash &lt;&lt; 10);
 429     hash ^= (hash &gt;&gt; 6);
 430 
 431     for (i = 0;i &lt; len; i++) {
 432         hash += name[i];
 433     hash += (hash &lt;&lt; 10);
 434     hash ^= (hash &gt;&gt; 6);
 435     }
 436     hash += (hash &lt;&lt; 3);
 437     hash ^= (hash &gt;&gt; 11);
 438     hash += (hash &lt;&lt; 15);
 439 
 440     return hash;
 441 }
 442 #endif /* WITH_BIG_KEY */
 443 
 444 /*
 445  * xmlDictComputeFastKey:
 446  *
 447  * Calculate a hash key using a fast hash function that works well
 448  * for low hash table fill.
 449  */
 450 static unsigned long
 451 xmlDictComputeFastKey(const xmlChar *name, int namelen, int seed) {
 452     unsigned long value = seed;
 453 
 454     if (name == NULL) return(0);
 455     value = *name;
 456     value &lt;&lt;= 5;
 457     if (namelen &gt; 10) {
 458         value += name[namelen - 1];
 459         namelen = 10;
 460     }
 461     switch (namelen) {
 462         case 10: value += name[9];
 463         /* Falls through. */
 464         case 9: value += name[8];
 465         /* Falls through. */
 466         case 8: value += name[7];
 467         /* Falls through. */
 468         case 7: value += name[6];
 469         /* Falls through. */
 470         case 6: value += name[5];
 471         /* Falls through. */
 472         case 5: value += name[4];
 473         /* Falls through. */
 474         case 4: value += name[3];
 475         /* Falls through. */
 476         case 3: value += name[2];
 477         /* Falls through. */
 478         case 2: value += name[1];
 479         /* Falls through. */
 480         default: break;
 481     }
 482     return(value);
 483 }
 484 
 485 /*
 486  * xmlDictComputeFastQKey:
 487  *
 488  * Calculate a hash key for two strings using a fast hash function
 489  * that works well for low hash table fill.
 490  *
 491  * Neither of the two strings must be NULL.
 492  */
 493 static unsigned long
 494 xmlDictComputeFastQKey(const xmlChar *prefix, int plen,
 495                        const xmlChar *name, int len, int seed)
 496 {
 497     unsigned long value = (unsigned long) seed;
 498 
 499     if (plen == 0)
 500     value += 30 * (unsigned long) &#39;:&#39;;
 501     else
 502     value += 30 * (*prefix);
 503 
 504     if (len &gt; 10) {
 505         int offset = len - (plen + 1 + 1);
 506     if (offset &lt; 0)
 507         offset = len - (10 + 1);
 508     value += name[offset];
 509         len = 10;
 510     if (plen &gt; 10)
 511         plen = 10;
 512     }
 513     switch (plen) {
 514         case 10: value += prefix[9];
 515         /* Falls through. */
 516         case 9: value += prefix[8];
 517         /* Falls through. */
 518         case 8: value += prefix[7];
 519         /* Falls through. */
 520         case 7: value += prefix[6];
 521         /* Falls through. */
 522         case 6: value += prefix[5];
 523         /* Falls through. */
 524         case 5: value += prefix[4];
 525         /* Falls through. */
 526         case 4: value += prefix[3];
 527         /* Falls through. */
 528         case 3: value += prefix[2];
 529         /* Falls through. */
 530         case 2: value += prefix[1];
 531         /* Falls through. */
 532         case 1: value += prefix[0];
 533         /* Falls through. */
 534         default: break;
 535     }
 536     len -= plen;
 537     if (len &gt; 0) {
 538         value += (unsigned long) &#39;:&#39;;
 539     len--;
 540     }
 541     switch (len) {
 542         case 10: value += name[9];
 543         /* Falls through. */
 544         case 9: value += name[8];
 545         /* Falls through. */
 546         case 8: value += name[7];
 547         /* Falls through. */
 548         case 7: value += name[6];
 549         /* Falls through. */
 550         case 6: value += name[5];
 551         /* Falls through. */
 552         case 5: value += name[4];
 553         /* Falls through. */
 554         case 4: value += name[3];
 555         /* Falls through. */
 556         case 3: value += name[2];
 557         /* Falls through. */
 558         case 2: value += name[1];
 559         /* Falls through. */
 560         case 1: value += name[0];
 561         /* Falls through. */
 562         default: break;
 563     }
 564     return(value);
 565 }
 566 
 567 /**
 568  * xmlDictCreate:
 569  *
 570  * Create a new dictionary
 571  *
 572  * Returns the newly created dictionary, or NULL if an error occurred.
 573  */
 574 xmlDictPtr
 575 xmlDictCreate(void) {
 576     xmlDictPtr dict;
 577 
 578     if (!xmlDictInitialized)
 579         if (!__xmlInitializeDict())
 580             return(NULL);
 581 
 582 #ifdef DICT_DEBUG_PATTERNS
 583     fprintf(stderr, &quot;C&quot;);
 584 #endif
 585 
 586     dict = xmlMalloc(sizeof(xmlDict));
 587     if (dict) {
 588         dict-&gt;ref_counter = 1;
 589         dict-&gt;limit = 0;
 590 
 591         dict-&gt;size = MIN_DICT_SIZE;
 592     dict-&gt;nbElems = 0;
 593         dict-&gt;dict = xmlMalloc(MIN_DICT_SIZE * sizeof(xmlDictEntry));
 594     dict-&gt;strings = NULL;
 595     dict-&gt;subdict = NULL;
 596         if (dict-&gt;dict) {
 597         memset(dict-&gt;dict, 0, MIN_DICT_SIZE * sizeof(xmlDictEntry));
 598 #ifdef DICT_RANDOMIZATION
 599             dict-&gt;seed = __xmlRandom();
 600 #else
 601             dict-&gt;seed = 0;
 602 #endif
 603         return(dict);
 604         }
 605         xmlFree(dict);
 606     }
 607     return(NULL);
 608 }
 609 
 610 /**
 611  * xmlDictCreateSub:
 612  * @sub: an existing dictionary
 613  *
 614  * Create a new dictionary, inheriting strings from the read-only
 615  * dictionary @sub. On lookup, strings are first searched in the
 616  * new dictionary, then in @sub, and if not found are created in the
 617  * new dictionary.
 618  *
 619  * Returns the newly created dictionary, or NULL if an error occurred.
 620  */
 621 xmlDictPtr
 622 xmlDictCreateSub(xmlDictPtr sub) {
 623     xmlDictPtr dict = xmlDictCreate();
 624 
 625     if ((dict != NULL) &amp;&amp; (sub != NULL)) {
 626 #ifdef DICT_DEBUG_PATTERNS
 627         fprintf(stderr, &quot;R&quot;);
 628 #endif
 629         dict-&gt;seed = sub-&gt;seed;
 630         dict-&gt;subdict = sub;
 631     xmlDictReference(dict-&gt;subdict);
 632     }
 633     return(dict);
 634 }
 635 
 636 /**
 637  * xmlDictReference:
 638  * @dict: the dictionary
 639  *
 640  * Increment the reference counter of a dictionary
 641  *
 642  * Returns 0 in case of success and -1 in case of error
 643  */
 644 int
 645 xmlDictReference(xmlDictPtr dict) {
 646     if (!xmlDictInitialized)
 647         if (!__xmlInitializeDict())
 648             return(-1);
 649 
 650     if (dict == NULL) return -1;
 651     xmlRMutexLock(xmlDictMutex);
 652     dict-&gt;ref_counter++;
 653     xmlRMutexUnlock(xmlDictMutex);
 654     return(0);
 655 }
 656 
 657 /**
 658  * xmlDictGrow:
 659  * @dict: the dictionary
 660  * @size: the new size of the dictionary
 661  *
 662  * resize the dictionary
 663  *
 664  * Returns 0 in case of success, -1 in case of failure
 665  */
 666 static int
 667 xmlDictGrow(xmlDictPtr dict, size_t size) {
 668     unsigned long key, okey;
 669     size_t oldsize, i;
 670     xmlDictEntryPtr iter, next;
 671     struct _xmlDictEntry *olddict;
 672 #ifdef DEBUG_GROW
 673     unsigned long nbElem = 0;
 674 #endif
 675     int ret = 0;
 676     int keep_keys = 1;
 677 
 678     if (dict == NULL)
 679     return(-1);
 680     if (size &lt; 8)
 681         return(-1);
 682     if (size &gt; 8 * 2048)
 683     return(-1);
 684 
 685 #ifdef DICT_DEBUG_PATTERNS
 686     fprintf(stderr, &quot;*&quot;);
 687 #endif
 688 
 689     oldsize = dict-&gt;size;
 690     olddict = dict-&gt;dict;
 691     if (olddict == NULL)
 692         return(-1);
 693     if (oldsize == MIN_DICT_SIZE)
 694         keep_keys = 0;
 695 
 696     dict-&gt;dict = xmlMalloc(size * sizeof(xmlDictEntry));
 697     if (dict-&gt;dict == NULL) {
 698     dict-&gt;dict = olddict;
 699     return(-1);
 700     }
 701     memset(dict-&gt;dict, 0, size * sizeof(xmlDictEntry));
 702     dict-&gt;size = size;
 703 
 704     /*  If the two loops are merged, there would be situations where
 705     a new entry needs to allocated and data copied into it from
 706     the main dict. It is nicer to run through the array twice, first
 707     copying all the elements in the main array (less probability of
 708     allocate) and then the rest, so we only free in the second loop.
 709     */
 710     for (i = 0; i &lt; oldsize; i++) {
 711     if (olddict[i].valid == 0)
 712         continue;
 713 
 714     if (keep_keys)
 715         okey = olddict[i].okey;
 716     else
 717         okey = xmlDictComputeKey(dict, olddict[i].name, olddict[i].len);
 718     key = okey % dict-&gt;size;
 719 
 720     if (dict-&gt;dict[key].valid == 0) {
 721         memcpy(&amp;(dict-&gt;dict[key]), &amp;(olddict[i]), sizeof(xmlDictEntry));
 722         dict-&gt;dict[key].next = NULL;
 723         dict-&gt;dict[key].okey = okey;
 724     } else {
 725         xmlDictEntryPtr entry;
 726 
 727         entry = xmlMalloc(sizeof(xmlDictEntry));
 728         if (entry != NULL) {
 729         entry-&gt;name = olddict[i].name;
 730         entry-&gt;len = olddict[i].len;
 731         entry-&gt;okey = okey;
 732         entry-&gt;next = dict-&gt;dict[key].next;
 733         entry-&gt;valid = 1;
 734         dict-&gt;dict[key].next = entry;
 735         } else {
 736             /*
<a name="4" id="anc4"></a><span class="line-modified"> 737          * we don&#39;t have much ways to alert from here</span>
 738          * result is losing an entry and unicity guarantee
 739          */
 740             ret = -1;
 741         }
 742     }
 743 #ifdef DEBUG_GROW
 744     nbElem++;
 745 #endif
 746     }
 747 
 748     for (i = 0; i &lt; oldsize; i++) {
 749     iter = olddict[i].next;
 750     while (iter) {
 751         next = iter-&gt;next;
 752 
 753         /*
 754          * put back the entry in the new dict
 755          */
 756 
 757         if (keep_keys)
 758         okey = iter-&gt;okey;
 759         else
 760         okey = xmlDictComputeKey(dict, iter-&gt;name, iter-&gt;len);
 761         key = okey % dict-&gt;size;
 762         if (dict-&gt;dict[key].valid == 0) {
 763         memcpy(&amp;(dict-&gt;dict[key]), iter, sizeof(xmlDictEntry));
 764         dict-&gt;dict[key].next = NULL;
 765         dict-&gt;dict[key].valid = 1;
 766         dict-&gt;dict[key].okey = okey;
 767         xmlFree(iter);
 768         } else {
 769         iter-&gt;next = dict-&gt;dict[key].next;
 770         iter-&gt;okey = okey;
 771         dict-&gt;dict[key].next = iter;
 772         }
 773 
 774 #ifdef DEBUG_GROW
 775         nbElem++;
 776 #endif
 777 
 778         iter = next;
 779     }
 780     }
 781 
 782     xmlFree(olddict);
 783 
 784 #ifdef DEBUG_GROW
 785     xmlGenericError(xmlGenericErrorContext,
 786         &quot;xmlDictGrow : from %lu to %lu, %u elems\n&quot;, oldsize, size, nbElem);
 787 #endif
 788 
 789     return(ret);
 790 }
 791 
 792 /**
 793  * xmlDictFree:
 794  * @dict: the dictionary
 795  *
 796  * Free the hash @dict and its contents. The userdata is
 797  * deallocated with @f if provided.
 798  */
 799 void
 800 xmlDictFree(xmlDictPtr dict) {
 801     size_t i;
 802     xmlDictEntryPtr iter;
 803     xmlDictEntryPtr next;
 804     int inside_dict = 0;
 805     xmlDictStringsPtr pool, nextp;
 806 
 807     if (dict == NULL)
 808     return;
 809 
 810     if (!xmlDictInitialized)
 811         if (!__xmlInitializeDict())
 812             return;
 813 
 814     /* decrement the counter, it may be shared by a parser and docs */
 815     xmlRMutexLock(xmlDictMutex);
 816     dict-&gt;ref_counter--;
 817     if (dict-&gt;ref_counter &gt; 0) {
 818         xmlRMutexUnlock(xmlDictMutex);
 819         return;
 820     }
 821 
 822     xmlRMutexUnlock(xmlDictMutex);
 823 
 824     if (dict-&gt;subdict != NULL) {
 825         xmlDictFree(dict-&gt;subdict);
 826     }
 827 
 828     if (dict-&gt;dict) {
 829     for(i = 0; ((i &lt; dict-&gt;size) &amp;&amp; (dict-&gt;nbElems &gt; 0)); i++) {
 830         iter = &amp;(dict-&gt;dict[i]);
 831         if (iter-&gt;valid == 0)
 832         continue;
 833         inside_dict = 1;
 834         while (iter) {
 835         next = iter-&gt;next;
 836         if (!inside_dict)
 837             xmlFree(iter);
 838         dict-&gt;nbElems--;
 839         inside_dict = 0;
 840         iter = next;
 841         }
 842     }
 843     xmlFree(dict-&gt;dict);
 844     }
 845     pool = dict-&gt;strings;
 846     while (pool != NULL) {
 847         nextp = pool-&gt;next;
 848     xmlFree(pool);
 849     pool = nextp;
 850     }
 851     xmlFree(dict);
 852 }
 853 
 854 /**
 855  * xmlDictLookup:
 856  * @dict: the dictionary
 857  * @name: the name of the userdata
 858  * @len: the length of the name, if -1 it is recomputed
 859  *
 860  * Add the @name to the dictionary @dict if not present.
 861  *
 862  * Returns the internal copy of the name or NULL in case of internal error
 863  */
 864 const xmlChar *
 865 xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) {
 866     unsigned long key, okey, nbi = 0;
 867     xmlDictEntryPtr entry;
 868     xmlDictEntryPtr insert;
 869     const xmlChar *ret;
 870     unsigned int l;
 871 
 872     if ((dict == NULL) || (name == NULL))
 873     return(NULL);
 874 
 875     if (len &lt; 0)
 876         l = strlen((const char *) name);
 877     else
 878         l = len;
 879 
 880     if (((dict-&gt;limit &gt; 0) &amp;&amp; (l &gt;= dict-&gt;limit)) ||
 881         (l &gt; INT_MAX / 2))
 882         return(NULL);
 883 
 884     /*
 885      * Check for duplicate and insertion location.
 886      */
 887     okey = xmlDictComputeKey(dict, name, l);
 888     key = okey % dict-&gt;size;
 889     if (dict-&gt;dict[key].valid == 0) {
 890     insert = NULL;
 891     } else {
 892     for (insert = &amp;(dict-&gt;dict[key]); insert-&gt;next != NULL;
 893          insert = insert-&gt;next) {
 894 #ifdef __GNUC__
 895         if ((insert-&gt;okey == okey) &amp;&amp; (insert-&gt;len == l)) {
 896         if (!memcmp(insert-&gt;name, name, l))
 897             return(insert-&gt;name);
 898         }
 899 #else
 900         if ((insert-&gt;okey == okey) &amp;&amp; (insert-&gt;len == l) &amp;&amp;
 901             (!xmlStrncmp(insert-&gt;name, name, l)))
 902         return(insert-&gt;name);
 903 #endif
 904         nbi++;
 905     }
 906 #ifdef __GNUC__
 907     if ((insert-&gt;okey == okey) &amp;&amp; (insert-&gt;len == l)) {
 908         if (!memcmp(insert-&gt;name, name, l))
 909         return(insert-&gt;name);
 910     }
 911 #else
 912     if ((insert-&gt;okey == okey) &amp;&amp; (insert-&gt;len == l) &amp;&amp;
 913         (!xmlStrncmp(insert-&gt;name, name, l)))
 914         return(insert-&gt;name);
 915 #endif
 916     }
 917 
 918     if (dict-&gt;subdict) {
 919         unsigned long skey;
 920 
 921         /* we cannot always reuse the same okey for the subdict */
 922         if (((dict-&gt;size == MIN_DICT_SIZE) &amp;&amp;
 923          (dict-&gt;subdict-&gt;size != MIN_DICT_SIZE)) ||
 924             ((dict-&gt;size != MIN_DICT_SIZE) &amp;&amp;
 925          (dict-&gt;subdict-&gt;size == MIN_DICT_SIZE)))
 926         skey = xmlDictComputeKey(dict-&gt;subdict, name, l);
 927     else
 928         skey = okey;
 929 
 930     key = skey % dict-&gt;subdict-&gt;size;
 931     if (dict-&gt;subdict-&gt;dict[key].valid != 0) {
 932         xmlDictEntryPtr tmp;
 933 
 934         for (tmp = &amp;(dict-&gt;subdict-&gt;dict[key]); tmp-&gt;next != NULL;
 935          tmp = tmp-&gt;next) {
 936 #ifdef __GNUC__
 937         if ((tmp-&gt;okey == skey) &amp;&amp; (tmp-&gt;len == l)) {
 938             if (!memcmp(tmp-&gt;name, name, l))
 939             return(tmp-&gt;name);
 940         }
 941 #else
 942         if ((tmp-&gt;okey == skey) &amp;&amp; (tmp-&gt;len == l) &amp;&amp;
 943             (!xmlStrncmp(tmp-&gt;name, name, l)))
 944             return(tmp-&gt;name);
 945 #endif
 946         nbi++;
 947         }
 948 #ifdef __GNUC__
 949         if ((tmp-&gt;okey == skey) &amp;&amp; (tmp-&gt;len == l)) {
 950         if (!memcmp(tmp-&gt;name, name, l))
 951             return(tmp-&gt;name);
 952         }
 953 #else
 954         if ((tmp-&gt;okey == skey) &amp;&amp; (tmp-&gt;len == l) &amp;&amp;
 955         (!xmlStrncmp(tmp-&gt;name, name, l)))
 956         return(tmp-&gt;name);
 957 #endif
 958     }
 959     key = okey % dict-&gt;size;
 960     }
 961 
 962     ret = xmlDictAddString(dict, name, l);
 963     if (ret == NULL)
 964         return(NULL);
 965     if (insert == NULL) {
 966     entry = &amp;(dict-&gt;dict[key]);
 967     } else {
 968     entry = xmlMalloc(sizeof(xmlDictEntry));
 969     if (entry == NULL)
 970          return(NULL);
 971     }
 972     entry-&gt;name = ret;
 973     entry-&gt;len = l;
 974     entry-&gt;next = NULL;
 975     entry-&gt;valid = 1;
 976     entry-&gt;okey = okey;
 977 
 978 
 979     if (insert != NULL)
 980     insert-&gt;next = entry;
 981 
 982     dict-&gt;nbElems++;
 983 
 984     if ((nbi &gt; MAX_HASH_LEN) &amp;&amp;
 985         (dict-&gt;size &lt;= ((MAX_DICT_HASH / 2) / MAX_HASH_LEN))) {
 986     if (xmlDictGrow(dict, MAX_HASH_LEN * 2 * dict-&gt;size) != 0)
 987         return(NULL);
 988     }
 989     /* Note that entry may have been freed at this point by xmlDictGrow */
 990 
 991     return(ret);
 992 }
 993 
 994 /**
 995  * xmlDictExists:
 996  * @dict: the dictionary
 997  * @name: the name of the userdata
 998  * @len: the length of the name, if -1 it is recomputed
 999  *
1000  * Check if the @name exists in the dictionary @dict.
1001  *
1002  * Returns the internal copy of the name or NULL if not found.
1003  */
1004 const xmlChar *
1005 xmlDictExists(xmlDictPtr dict, const xmlChar *name, int len) {
1006     unsigned long key, okey, nbi = 0;
1007     xmlDictEntryPtr insert;
1008     unsigned int l;
1009 
1010     if ((dict == NULL) || (name == NULL))
1011     return(NULL);
1012 
1013     if (len &lt; 0)
1014         l = strlen((const char *) name);
1015     else
1016         l = len;
1017     if (((dict-&gt;limit &gt; 0) &amp;&amp; (l &gt;= dict-&gt;limit)) ||
1018         (l &gt; INT_MAX / 2))
1019         return(NULL);
1020 
1021     /*
1022      * Check for duplicate and insertion location.
1023      */
1024     okey = xmlDictComputeKey(dict, name, l);
1025     key = okey % dict-&gt;size;
1026     if (dict-&gt;dict[key].valid == 0) {
1027     insert = NULL;
1028     } else {
1029     for (insert = &amp;(dict-&gt;dict[key]); insert-&gt;next != NULL;
1030          insert = insert-&gt;next) {
1031 #ifdef __GNUC__
1032         if ((insert-&gt;okey == okey) &amp;&amp; (insert-&gt;len == l)) {
1033         if (!memcmp(insert-&gt;name, name, l))
1034             return(insert-&gt;name);
1035         }
1036 #else
1037         if ((insert-&gt;okey == okey) &amp;&amp; (insert-&gt;len == l) &amp;&amp;
1038             (!xmlStrncmp(insert-&gt;name, name, l)))
1039         return(insert-&gt;name);
1040 #endif
1041         nbi++;
1042     }
1043 #ifdef __GNUC__
1044     if ((insert-&gt;okey == okey) &amp;&amp; (insert-&gt;len == l)) {
1045         if (!memcmp(insert-&gt;name, name, l))
1046         return(insert-&gt;name);
1047     }
1048 #else
1049     if ((insert-&gt;okey == okey) &amp;&amp; (insert-&gt;len == l) &amp;&amp;
1050         (!xmlStrncmp(insert-&gt;name, name, l)))
1051         return(insert-&gt;name);
1052 #endif
1053     }
1054 
1055     if (dict-&gt;subdict) {
1056         unsigned long skey;
1057 
1058         /* we cannot always reuse the same okey for the subdict */
1059         if (((dict-&gt;size == MIN_DICT_SIZE) &amp;&amp;
1060          (dict-&gt;subdict-&gt;size != MIN_DICT_SIZE)) ||
1061             ((dict-&gt;size != MIN_DICT_SIZE) &amp;&amp;
1062          (dict-&gt;subdict-&gt;size == MIN_DICT_SIZE)))
1063         skey = xmlDictComputeKey(dict-&gt;subdict, name, l);
1064     else
1065         skey = okey;
1066 
1067     key = skey % dict-&gt;subdict-&gt;size;
1068     if (dict-&gt;subdict-&gt;dict[key].valid != 0) {
1069         xmlDictEntryPtr tmp;
1070 
1071         for (tmp = &amp;(dict-&gt;subdict-&gt;dict[key]); tmp-&gt;next != NULL;
1072          tmp = tmp-&gt;next) {
1073 #ifdef __GNUC__
1074         if ((tmp-&gt;okey == skey) &amp;&amp; (tmp-&gt;len == l)) {
1075             if (!memcmp(tmp-&gt;name, name, l))
1076             return(tmp-&gt;name);
1077         }
1078 #else
1079         if ((tmp-&gt;okey == skey) &amp;&amp; (tmp-&gt;len == l) &amp;&amp;
1080             (!xmlStrncmp(tmp-&gt;name, name, l)))
1081             return(tmp-&gt;name);
1082 #endif
1083         nbi++;
1084         }
1085 #ifdef __GNUC__
1086         if ((tmp-&gt;okey == skey) &amp;&amp; (tmp-&gt;len == l)) {
1087         if (!memcmp(tmp-&gt;name, name, l))
1088             return(tmp-&gt;name);
1089         }
1090 #else
1091         if ((tmp-&gt;okey == skey) &amp;&amp; (tmp-&gt;len == l) &amp;&amp;
1092         (!xmlStrncmp(tmp-&gt;name, name, l)))
1093         return(tmp-&gt;name);
1094 #endif
1095     }
1096     }
1097 
1098     /* not found */
1099     return(NULL);
1100 }
1101 
1102 /**
1103  * xmlDictQLookup:
1104  * @dict: the dictionary
1105  * @prefix: the prefix
1106  * @name: the name
1107  *
1108  * Add the QName @prefix:@name to the hash @dict if not present.
1109  *
1110  * Returns the internal copy of the QName or NULL in case of internal error
1111  */
1112 const xmlChar *
1113 xmlDictQLookup(xmlDictPtr dict, const xmlChar *prefix, const xmlChar *name) {
1114     unsigned long okey, key, nbi = 0;
1115     xmlDictEntryPtr entry;
1116     xmlDictEntryPtr insert;
1117     const xmlChar *ret;
1118     unsigned int len, plen, l;
1119 
1120     if ((dict == NULL) || (name == NULL))
1121     return(NULL);
1122     if (prefix == NULL)
1123         return(xmlDictLookup(dict, name, -1));
1124 
1125     l = len = strlen((const char *) name);
1126     plen = strlen((const char *) prefix);
1127     len += 1 + plen;
1128 
1129     /*
1130      * Check for duplicate and insertion location.
1131      */
1132     okey = xmlDictComputeQKey(dict, prefix, plen, name, l);
1133     key = okey % dict-&gt;size;
1134     if (dict-&gt;dict[key].valid == 0) {
1135     insert = NULL;
1136     } else {
1137     for (insert = &amp;(dict-&gt;dict[key]); insert-&gt;next != NULL;
1138          insert = insert-&gt;next) {
1139         if ((insert-&gt;okey == okey) &amp;&amp; (insert-&gt;len == len) &amp;&amp;
1140             (xmlStrQEqual(prefix, name, insert-&gt;name)))
1141         return(insert-&gt;name);
1142         nbi++;
1143     }
1144     if ((insert-&gt;okey == okey) &amp;&amp; (insert-&gt;len == len) &amp;&amp;
1145         (xmlStrQEqual(prefix, name, insert-&gt;name)))
1146         return(insert-&gt;name);
1147     }
1148 
1149     if (dict-&gt;subdict) {
1150         unsigned long skey;
1151 
1152         /* we cannot always reuse the same okey for the subdict */
1153         if (((dict-&gt;size == MIN_DICT_SIZE) &amp;&amp;
1154          (dict-&gt;subdict-&gt;size != MIN_DICT_SIZE)) ||
1155             ((dict-&gt;size != MIN_DICT_SIZE) &amp;&amp;
1156          (dict-&gt;subdict-&gt;size == MIN_DICT_SIZE)))
1157         skey = xmlDictComputeQKey(dict-&gt;subdict, prefix, plen, name, l);
1158     else
1159         skey = okey;
1160 
1161     key = skey % dict-&gt;subdict-&gt;size;
1162     if (dict-&gt;subdict-&gt;dict[key].valid != 0) {
1163         xmlDictEntryPtr tmp;
1164         for (tmp = &amp;(dict-&gt;subdict-&gt;dict[key]); tmp-&gt;next != NULL;
1165          tmp = tmp-&gt;next) {
1166         if ((tmp-&gt;okey == skey) &amp;&amp; (tmp-&gt;len == len) &amp;&amp;
1167             (xmlStrQEqual(prefix, name, tmp-&gt;name)))
1168             return(tmp-&gt;name);
1169         nbi++;
1170         }
1171         if ((tmp-&gt;okey == skey) &amp;&amp; (tmp-&gt;len == len) &amp;&amp;
1172         (xmlStrQEqual(prefix, name, tmp-&gt;name)))
1173         return(tmp-&gt;name);
1174     }
1175     key = okey % dict-&gt;size;
1176     }
1177 
1178     ret = xmlDictAddQString(dict, prefix, plen, name, l);
1179     if (ret == NULL)
1180         return(NULL);
1181     if (insert == NULL) {
1182     entry = &amp;(dict-&gt;dict[key]);
1183     } else {
1184     entry = xmlMalloc(sizeof(xmlDictEntry));
1185     if (entry == NULL)
1186          return(NULL);
1187     }
1188     entry-&gt;name = ret;
1189     entry-&gt;len = len;
1190     entry-&gt;next = NULL;
1191     entry-&gt;valid = 1;
1192     entry-&gt;okey = okey;
1193 
1194     if (insert != NULL)
1195     insert-&gt;next = entry;
1196 
1197     dict-&gt;nbElems++;
1198 
1199     if ((nbi &gt; MAX_HASH_LEN) &amp;&amp;
1200         (dict-&gt;size &lt;= ((MAX_DICT_HASH / 2) / MAX_HASH_LEN)))
1201     xmlDictGrow(dict, MAX_HASH_LEN * 2 * dict-&gt;size);
1202     /* Note that entry may have been freed at this point by xmlDictGrow */
1203 
1204     return(ret);
1205 }
1206 
1207 /**
1208  * xmlDictOwns:
1209  * @dict: the dictionary
1210  * @str: the string
1211  *
<a name="5" id="anc5"></a><span class="line-modified">1212  * check if a string is owned by the dictionary</span>
1213  *
1214  * Returns 1 if true, 0 if false and -1 in case of error
1215  * -1 in case of error
1216  */
1217 int
1218 xmlDictOwns(xmlDictPtr dict, const xmlChar *str) {
1219     xmlDictStringsPtr pool;
1220 
1221     if ((dict == NULL) || (str == NULL))
1222     return(-1);
1223     pool = dict-&gt;strings;
1224     while (pool != NULL) {
1225         if ((str &gt;= &amp;pool-&gt;array[0]) &amp;&amp; (str &lt;= pool-&gt;free))
1226         return(1);
1227     pool = pool-&gt;next;
1228     }
1229     if (dict-&gt;subdict)
1230         return(xmlDictOwns(dict-&gt;subdict, str));
1231     return(0);
1232 }
1233 
1234 /**
1235  * xmlDictSize:
1236  * @dict: the dictionary
1237  *
1238  * Query the number of elements installed in the hash @dict.
1239  *
1240  * Returns the number of elements in the dictionary or
1241  * -1 in case of error
1242  */
1243 int
1244 xmlDictSize(xmlDictPtr dict) {
1245     if (dict == NULL)
1246     return(-1);
1247     if (dict-&gt;subdict)
1248         return(dict-&gt;nbElems + dict-&gt;subdict-&gt;nbElems);
1249     return(dict-&gt;nbElems);
1250 }
1251 
1252 /**
1253  * xmlDictSetLimit:
1254  * @dict: the dictionary
1255  * @limit: the limit in bytes
1256  *
1257  * Set a size limit for the dictionary
1258  * Added in 2.9.0
1259  *
1260  * Returns the previous limit of the dictionary or 0
1261  */
1262 size_t
1263 xmlDictSetLimit(xmlDictPtr dict, size_t limit) {
1264     size_t ret;
1265 
1266     if (dict == NULL)
1267     return(0);
1268     ret = dict-&gt;limit;
1269     dict-&gt;limit = limit;
1270     return(ret);
1271 }
1272 
1273 /**
1274  * xmlDictGetUsage:
1275  * @dict: the dictionary
1276  *
1277  * Get how much memory is used by a dictionary for strings
1278  * Added in 2.9.0
1279  *
1280  * Returns the amount of strings allocated
1281  */
1282 size_t
1283 xmlDictGetUsage(xmlDictPtr dict) {
1284     xmlDictStringsPtr pool;
1285     size_t limit = 0;
1286 
1287     if (dict == NULL)
1288     return(0);
1289     pool = dict-&gt;strings;
1290     while (pool != NULL) {
1291         limit += pool-&gt;size;
1292     pool = pool-&gt;next;
1293     }
1294     return(limit);
1295 }
1296 
1297 #define bottom_dict
1298 #include &quot;elfgcchack.h&quot;
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/entities.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="encoding.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="error.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/entities.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 131     } else {
 132         if (entity-&gt;name != NULL)
 133             xmlFree((char *) entity-&gt;name);
 134         if (entity-&gt;ExternalID != NULL)
 135             xmlFree((char *) entity-&gt;ExternalID);
 136         if (entity-&gt;SystemID != NULL)
 137             xmlFree((char *) entity-&gt;SystemID);
 138         if (entity-&gt;URI != NULL)
 139             xmlFree((char *) entity-&gt;URI);
 140         if (entity-&gt;content != NULL)
 141             xmlFree((char *) entity-&gt;content);
 142         if (entity-&gt;orig != NULL)
 143             xmlFree((char *) entity-&gt;orig);
 144     }
 145     xmlFree(entity);
 146 }
 147 
 148 /*
 149  * xmlCreateEntity:
 150  *
<span class="line-modified"> 151  * internal routine doing the entity node strutures allocations</span>
 152  */
 153 static xmlEntityPtr
 154 xmlCreateEntity(xmlDictPtr dict, const xmlChar *name, int type,
 155             const xmlChar *ExternalID, const xmlChar *SystemID,
 156             const xmlChar *content) {
 157     xmlEntityPtr ret;
 158 
 159     ret = (xmlEntityPtr) xmlMalloc(sizeof(xmlEntity));
 160     if (ret == NULL) {
 161         xmlEntitiesErrMemory(&quot;xmlCreateEntity: malloc failed&quot;);
 162     return(NULL);
 163     }
 164     memset(ret, 0, sizeof(xmlEntity));
 165     ret-&gt;type = XML_ENTITY_DECL;
 166     ret-&gt;checked = 0;
 167 
 168     /*
 169      * fill the structure.
 170      */
 171     ret-&gt;etype = (xmlEntityType) type;
</pre>
<hr />
<pre>
 381     dtd-&gt;children = dtd-&gt;last = (xmlNodePtr) ret;
 382     } else {
 383     dtd-&gt;last-&gt;next = (xmlNodePtr) ret;
 384     ret-&gt;prev = dtd-&gt;last;
 385     dtd-&gt;last = (xmlNodePtr) ret;
 386     }
 387     return(ret);
 388 }
 389 
 390 /**
 391  * xmlNewEntity:
 392  * @doc:  the document
 393  * @name:  the entity name
 394  * @type:  the entity type XML_xxx_yyy_ENTITY
 395  * @ExternalID:  the entity external ID if available
 396  * @SystemID:  the entity system ID if available
 397  * @content:  the entity content
 398  *
 399  * Create a new entity, this differs from xmlAddDocEntity() that if
 400  * the document is NULL or has no internal subset defined, then an
<span class="line-modified"> 401  * unlinked entity structure will be returned, it is then the responsability</span>
 402  * of the caller to link it to the document later or free it when not needed
 403  * anymore.
 404  *
 405  * Returns a pointer to the entity or NULL in case of error
 406  */
 407 xmlEntityPtr
 408 xmlNewEntity(xmlDocPtr doc, const xmlChar *name, int type,
 409          const xmlChar *ExternalID, const xmlChar *SystemID,
 410          const xmlChar *content) {
 411     xmlEntityPtr ret;
 412     xmlDictPtr dict;
 413 
 414     if ((doc != NULL) &amp;&amp; (doc-&gt;intSubset != NULL)) {
 415     return(xmlAddDocEntity(doc, name, type, ExternalID, SystemID, content));
 416     }
 417     if (doc != NULL)
 418         dict = doc-&gt;dict;
 419     else
 420         dict = NULL;
 421     ret = xmlCreateEntity(dict, name, type, ExternalID, SystemID, content);
</pre>
<hr />
<pre>
 531     return(xmlGetPredefinedEntity(name));
 532 }
 533 
 534 /*
 535  * Macro used to grow the current buffer.
 536  */
 537 #define growBufferReentrant() {                     \
 538     xmlChar *tmp;                                                       \
 539     size_t new_size = buffer_size * 2;                                  \
 540     if (new_size &lt; buffer_size) goto mem_error;                         \
 541     tmp = (xmlChar *) xmlRealloc(buffer, new_size);                 \
 542     if (tmp == NULL) goto mem_error;                                    \
 543     buffer = tmp;                           \
 544     buffer_size = new_size;                     \
 545 }
 546 
 547 /**
 548  * xmlEncodeEntitiesInternal:
 549  * @doc:  the document containing the string
 550  * @input:  A string to convert to XML.
<span class="line-modified"> 551  * @attr: are we handling an atrbute value</span>
 552  *
 553  * Do a global encoding of a string, replacing the predefined entities
 554  * and non ASCII values with their entities and CharRef counterparts.
 555  * Contrary to xmlEncodeEntities, this routine is reentrant, and result
 556  * must be deallocated.
 557  *
 558  * Returns A newly allocated string with the substitution done.
 559  */
 560 static xmlChar *
 561 xmlEncodeEntitiesInternal(xmlDocPtr doc, const xmlChar *input, int attr) {
 562     const xmlChar *cur = input;
 563     xmlChar *buffer = NULL;
 564     xmlChar *out = NULL;
 565     size_t buffer_size = 0;
 566     int html = 0;
 567 
 568     if (input == NULL) return(NULL);
 569     if (doc != NULL)
 570         html = (doc-&gt;type == XML_HTML_DOCUMENT_NODE);
 571 
</pre>
</td>
<td>
<hr />
<pre>
 131     } else {
 132         if (entity-&gt;name != NULL)
 133             xmlFree((char *) entity-&gt;name);
 134         if (entity-&gt;ExternalID != NULL)
 135             xmlFree((char *) entity-&gt;ExternalID);
 136         if (entity-&gt;SystemID != NULL)
 137             xmlFree((char *) entity-&gt;SystemID);
 138         if (entity-&gt;URI != NULL)
 139             xmlFree((char *) entity-&gt;URI);
 140         if (entity-&gt;content != NULL)
 141             xmlFree((char *) entity-&gt;content);
 142         if (entity-&gt;orig != NULL)
 143             xmlFree((char *) entity-&gt;orig);
 144     }
 145     xmlFree(entity);
 146 }
 147 
 148 /*
 149  * xmlCreateEntity:
 150  *
<span class="line-modified"> 151  * internal routine doing the entity node structures allocations</span>
 152  */
 153 static xmlEntityPtr
 154 xmlCreateEntity(xmlDictPtr dict, const xmlChar *name, int type,
 155             const xmlChar *ExternalID, const xmlChar *SystemID,
 156             const xmlChar *content) {
 157     xmlEntityPtr ret;
 158 
 159     ret = (xmlEntityPtr) xmlMalloc(sizeof(xmlEntity));
 160     if (ret == NULL) {
 161         xmlEntitiesErrMemory(&quot;xmlCreateEntity: malloc failed&quot;);
 162     return(NULL);
 163     }
 164     memset(ret, 0, sizeof(xmlEntity));
 165     ret-&gt;type = XML_ENTITY_DECL;
 166     ret-&gt;checked = 0;
 167 
 168     /*
 169      * fill the structure.
 170      */
 171     ret-&gt;etype = (xmlEntityType) type;
</pre>
<hr />
<pre>
 381     dtd-&gt;children = dtd-&gt;last = (xmlNodePtr) ret;
 382     } else {
 383     dtd-&gt;last-&gt;next = (xmlNodePtr) ret;
 384     ret-&gt;prev = dtd-&gt;last;
 385     dtd-&gt;last = (xmlNodePtr) ret;
 386     }
 387     return(ret);
 388 }
 389 
 390 /**
 391  * xmlNewEntity:
 392  * @doc:  the document
 393  * @name:  the entity name
 394  * @type:  the entity type XML_xxx_yyy_ENTITY
 395  * @ExternalID:  the entity external ID if available
 396  * @SystemID:  the entity system ID if available
 397  * @content:  the entity content
 398  *
 399  * Create a new entity, this differs from xmlAddDocEntity() that if
 400  * the document is NULL or has no internal subset defined, then an
<span class="line-modified"> 401  * unlinked entity structure will be returned, it is then the responsibility</span>
 402  * of the caller to link it to the document later or free it when not needed
 403  * anymore.
 404  *
 405  * Returns a pointer to the entity or NULL in case of error
 406  */
 407 xmlEntityPtr
 408 xmlNewEntity(xmlDocPtr doc, const xmlChar *name, int type,
 409          const xmlChar *ExternalID, const xmlChar *SystemID,
 410          const xmlChar *content) {
 411     xmlEntityPtr ret;
 412     xmlDictPtr dict;
 413 
 414     if ((doc != NULL) &amp;&amp; (doc-&gt;intSubset != NULL)) {
 415     return(xmlAddDocEntity(doc, name, type, ExternalID, SystemID, content));
 416     }
 417     if (doc != NULL)
 418         dict = doc-&gt;dict;
 419     else
 420         dict = NULL;
 421     ret = xmlCreateEntity(dict, name, type, ExternalID, SystemID, content);
</pre>
<hr />
<pre>
 531     return(xmlGetPredefinedEntity(name));
 532 }
 533 
 534 /*
 535  * Macro used to grow the current buffer.
 536  */
 537 #define growBufferReentrant() {                     \
 538     xmlChar *tmp;                                                       \
 539     size_t new_size = buffer_size * 2;                                  \
 540     if (new_size &lt; buffer_size) goto mem_error;                         \
 541     tmp = (xmlChar *) xmlRealloc(buffer, new_size);                 \
 542     if (tmp == NULL) goto mem_error;                                    \
 543     buffer = tmp;                           \
 544     buffer_size = new_size;                     \
 545 }
 546 
 547 /**
 548  * xmlEncodeEntitiesInternal:
 549  * @doc:  the document containing the string
 550  * @input:  A string to convert to XML.
<span class="line-modified"> 551  * @attr: are we handling an attribute value</span>
 552  *
 553  * Do a global encoding of a string, replacing the predefined entities
 554  * and non ASCII values with their entities and CharRef counterparts.
 555  * Contrary to xmlEncodeEntities, this routine is reentrant, and result
 556  * must be deallocated.
 557  *
 558  * Returns A newly allocated string with the substitution done.
 559  */
 560 static xmlChar *
 561 xmlEncodeEntitiesInternal(xmlDocPtr doc, const xmlChar *input, int attr) {
 562     const xmlChar *cur = input;
 563     xmlChar *buffer = NULL;
 564     xmlChar *out = NULL;
 565     size_t buffer_size = 0;
 566     int html = 0;
 567 
 568     if (input == NULL) return(NULL);
 569     if (doc != NULL)
 570         html = (doc-&gt;type == XML_HTML_DOCUMENT_NODE);
 571 
</pre>
</td>
</tr>
</table>
<center><a href="encoding.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="error.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
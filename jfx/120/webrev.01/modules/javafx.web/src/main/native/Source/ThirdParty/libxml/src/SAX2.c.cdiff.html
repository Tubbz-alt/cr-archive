<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/SAX2.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="README.zOS.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="aclocal.m4.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/SAX2.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 38,11 ***</span>
  
  /**
   * TODO:
   *
   * macro to flag unimplemented blocks
<span class="line-modified">!  * XML_CATALOG_PREFER user env to select between system/public prefered</span>
   * option. C.f. Richard Tobin &lt;richard@cogsci.ed.ac.uk&gt;
   *&gt; Just FYI, I am using an environment variable XML_CATALOG_PREFER with
   *&gt; values &quot;system&quot; and &quot;public&quot;.  I have made the default be &quot;system&quot; to
   *&gt; match yours.
   */
<span class="line-new-header">--- 38,11 ---</span>
  
  /**
   * TODO:
   *
   * macro to flag unimplemented blocks
<span class="line-modified">!  * XML_CATALOG_PREFER user env to select between system/public preferred</span>
   * option. C.f. Richard Tobin &lt;richard@cogsci.ed.ac.uk&gt;
   *&gt; Just FYI, I am using an environment variable XML_CATALOG_PREFER with
   *&gt; values &quot;system&quot; and &quot;public&quot;.  I have made the default be &quot;system&quot; to
   *&gt; match yours.
   */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1510,12 ***</span>
       * Actually insert defaulted values when needed
       */
      attr = elemDecl-&gt;attributes;
      while (attr != NULL) {
          /*
<span class="line-modified">!          * Make sure that attributes redefinition occuring in the</span>
<span class="line-modified">!          * internal subset are not overriden by definitions in the</span>
           * external subset.
           */
          if (attr-&gt;defaultValue != NULL) {
          /*
           * the element should be instantiated in the tree if:
<span class="line-new-header">--- 1510,12 ---</span>
       * Actually insert defaulted values when needed
       */
      attr = elemDecl-&gt;attributes;
      while (attr != NULL) {
          /*
<span class="line-modified">!          * Make sure that attributes redefinition occurring in the</span>
<span class="line-modified">!          * internal subset are not overridden by definitions in the</span>
           * external subset.
           */
          if (attr-&gt;defaultValue != NULL) {
          /*
           * the element should be instantiated in the tree if:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1666,10 ***</span>
<span class="line-new-header">--- 1666,12 ---</span>
      xmlGenericError(xmlGenericErrorContext, &quot;pushing(%s)\n&quot;, name);
  #endif
      if (nodePush(ctxt, ret) &lt; 0) {
          xmlUnlinkNode(ret);
          xmlFreeNode(ret);
<span class="line-added">+         if (prefix != NULL)</span>
<span class="line-added">+             xmlFree(prefix);</span>
          return;
      }
  
      /*
       * Link the child element
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1732,12 ***</span>
               &quot;Namespace prefix %s is not defined\n&quot;,
               prefix, NULL);
      }
  
      /*
<span class="line-modified">!      * set the namespace node, making sure that if the default namspace</span>
<span class="line-modified">!      * is unbound on a parent we simply kee it NULL</span>
       */
      if ((ns != NULL) &amp;&amp; (ns-&gt;href != NULL) &amp;&amp;
      ((ns-&gt;href[0] != 0) || (ns-&gt;prefix != NULL)))
      xmlSetNs(ret, ns);
  
<span class="line-new-header">--- 1734,12 ---</span>
               &quot;Namespace prefix %s is not defined\n&quot;,
               prefix, NULL);
      }
  
      /*
<span class="line-modified">!      * set the namespace node, making sure that if the default namespace</span>
<span class="line-modified">!      * is unbound on a parent we simply keep it NULL</span>
       */
      if ((ns != NULL) &amp;&amp; (ns-&gt;href != NULL) &amp;&amp;
      ((ns-&gt;href[0] != 0) || (ns-&gt;prefix != NULL)))
      xmlSetNs(ret, ns);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2008,11 ***</span>
      if (ctxt-&gt;dictNames)
          ret-&gt;name = localname;
      else
          ret-&gt;name = xmlStrdup(localname);
  
<span class="line-modified">!         /* link at the end to preserv order, TODO speed up with a last */</span>
      if (ctxt-&gt;node-&gt;properties == NULL) {
          ctxt-&gt;node-&gt;properties = ret;
      } else {
          xmlAttrPtr prev = ctxt-&gt;node-&gt;properties;
  
<span class="line-new-header">--- 2010,11 ---</span>
      if (ctxt-&gt;dictNames)
          ret-&gt;name = localname;
      else
          ret-&gt;name = xmlStrdup(localname);
  
<span class="line-modified">!         /* link at the end to preserve order, TODO speed up with a last */</span>
      if (ctxt-&gt;node-&gt;properties == NULL) {
          ctxt-&gt;node-&gt;properties = ret;
      } else {
          xmlAttrPtr prev = ctxt-&gt;node-&gt;properties;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2100,11 ***</span>
                      ctxt-&gt;myDoc, ctxt-&gt;node, ret, dup);
          }
          } else {
              /*
           * dup now contains a string of the flattened attribute
<span class="line-modified">!          * content with entities substitued. Check if we need to</span>
           * apply an extra layer of normalization.
           * It need to be done twice ... it&#39;s an extra burden related
           * to the ability to keep references in attributes
           */
          if (ctxt-&gt;attsSpecial != NULL) {
<span class="line-new-header">--- 2102,11 ---</span>
                      ctxt-&gt;myDoc, ctxt-&gt;node, ret, dup);
          }
          } else {
              /*
           * dup now contains a string of the flattened attribute
<span class="line-modified">!          * content with entities substituted. Check if we need to</span>
           * apply an extra layer of normalization.
           * It need to be done twice ... it&#39;s an extra burden related
           * to the ability to keep references in attributes
           */
          if (ctxt-&gt;attsSpecial != NULL) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2133,11 ***</span>
          ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
                      ctxt-&gt;myDoc, ctxt-&gt;node, ret, dup);
          }
      } else {
          /*
<span class="line-modified">!          * if entities already have been substitued, then</span>
           * the attribute as passed is already normalized
           */
          dup = xmlStrndup(value, valueend - value);
  
          ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
<span class="line-new-header">--- 2135,11 ---</span>
          ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
                      ctxt-&gt;myDoc, ctxt-&gt;node, ret, dup);
          }
      } else {
          /*
<span class="line-modified">!          * if entities already have been substituted, then</span>
           * the attribute as passed is already normalized
           */
          dup = xmlStrndup(value, valueend - value);
  
          ctxt-&gt;valid &amp;= xmlValidateOneAttribute(&amp;ctxt-&gt;vctxt,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2396,11 ***</span>
       * process all the other attributes
       */
      if (nb_attributes &gt; 0) {
          for (j = 0,i = 0;i &lt; nb_attributes;i++,j+=5) {
          /*
<span class="line-modified">!          * Handle the rare case of an undefined atribute prefix</span>
           */
          if ((attributes[j+1] != NULL) &amp;&amp; (attributes[j+2] == NULL)) {
          if (ctxt-&gt;dictNames) {
              const xmlChar *fullname;
  
<span class="line-new-header">--- 2398,11 ---</span>
       * process all the other attributes
       */
      if (nb_attributes &gt; 0) {
          for (j = 0,i = 0;i &lt; nb_attributes;i++,j+=5) {
          /*
<span class="line-modified">!          * Handle the rare case of an undefined attribute prefix</span>
           */
          if ((attributes[j+1] != NULL) &amp;&amp; (attributes[j+2] == NULL)) {
          if (ctxt-&gt;dictNames) {
              const xmlChar *fullname;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2582,11 ***</span>
      if ((coalesceText) &amp;&amp; (ctxt-&gt;nodemem != 0)) {
          /*
           * The whole point of maintaining nodelen and nodemem,
           * xmlTextConcat is too costly, i.e. compute length,
           * reallocate a new buffer, move data, append ch. Here
<span class="line-modified">!          * We try to minimaze realloc() uses and avoid copying</span>
           * and recomputing length over and over.
           */
          if (lastChild-&gt;content == (xmlChar *)&amp;(lastChild-&gt;properties)) {
          lastChild-&gt;content = xmlStrdup(lastChild-&gt;content);
          lastChild-&gt;properties = NULL;
<span class="line-new-header">--- 2584,11 ---</span>
      if ((coalesceText) &amp;&amp; (ctxt-&gt;nodemem != 0)) {
          /*
           * The whole point of maintaining nodelen and nodemem,
           * xmlTextConcat is too costly, i.e. compute length,
           * reallocate a new buffer, move data, append ch. Here
<span class="line-modified">!          * We try to minimize realloc() uses and avoid copying</span>
           * and recomputing length over and over.
           */
          if (lastChild-&gt;content == (xmlChar *)&amp;(lastChild-&gt;properties)) {
          lastChild-&gt;content = xmlStrdup(lastChild-&gt;content);
          lastChild-&gt;properties = NULL;
</pre>
<center><a href="README.zOS.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="aclocal.m4.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
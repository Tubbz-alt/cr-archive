<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/xmlreader.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="xmlIO.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="xmlsave.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/xmlreader.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 221 static void xmlTextReaderFreeNode(xmlTextReaderPtr reader, xmlNodePtr cur);
 222 static void xmlTextReaderFreeNodeList(xmlTextReaderPtr reader, xmlNodePtr cur);
 223 
 224 /**
 225  * xmlFreeID:
 226  * @not:  A id
 227  *
 228  * Deallocate the memory used by an id definition
 229  */
 230 static void
 231 xmlFreeID(xmlIDPtr id) {
 232     xmlDictPtr dict = NULL;
 233 
 234     if (id == NULL) return;
 235 
 236     if (id-&gt;doc != NULL)
 237         dict = id-&gt;doc-&gt;dict;
 238 
 239     if (id-&gt;value != NULL)
 240     DICT_FREE(id-&gt;value)


 241     xmlFree(id);
 242 }
 243 
 244 /**
 245  * xmlTextReaderRemoveID:
 246  * @doc:  the document
 247  * @attr:  the attribute
 248  *
 249  * Remove the given attribute from the ID table maintained internally.
 250  *
 251  * Returns -1 if the lookup failed and 0 otherwise
 252  */
 253 static int
 254 xmlTextReaderRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {
 255     xmlIDTablePtr table;
 256     xmlIDPtr id;
 257     xmlChar *ID;
 258 
 259     if (doc == NULL) return(-1);
 260     if (attr == NULL) return(-1);
 261     table = (xmlIDTablePtr) doc-&gt;ids;
 262     if (table == NULL)
 263         return(-1);
 264 
 265     ID = xmlNodeListGetString(doc, attr-&gt;children, 1);
 266     if (ID == NULL)
 267     return(-1);
 268     id = xmlHashLookup(table, ID);
 269     xmlFree(ID);
 270     if (id == NULL || id-&gt;attr != attr) {
 271     return(-1);
 272     }
 273     id-&gt;name = attr-&gt;name;

 274     id-&gt;attr = NULL;
 275     return(0);
 276 }
 277 
 278 /**
 279  * xmlTextReaderFreeProp:
 280  * @reader:  the xmlTextReaderPtr used
 281  * @cur:  the node
 282  *
 283  * Free a node.
 284  */
 285 static void
 286 xmlTextReaderFreeProp(xmlTextReaderPtr reader, xmlAttrPtr cur) {
 287     xmlDictPtr dict;
 288 
 289     if ((reader != NULL) &amp;&amp; (reader-&gt;ctxt != NULL))
 290     dict = reader-&gt;ctxt-&gt;dict;
 291     else
 292         dict = NULL;
 293     if (cur == NULL) return;
</pre>
<hr />
<pre>
 328     xmlAttrPtr next;
 329 
 330     while (cur != NULL) {
 331         next = cur-&gt;next;
 332         xmlTextReaderFreeProp(reader, cur);
 333     cur = next;
 334     }
 335 }
 336 
 337 /**
 338  * xmlTextReaderFreeNodeList:
 339  * @reader:  the xmlTextReaderPtr used
 340  * @cur:  the first node in the list
 341  *
 342  * Free a node and all its siblings, this is a recursive behaviour, all
 343  * the children are freed too.
 344  */
 345 static void
 346 xmlTextReaderFreeNodeList(xmlTextReaderPtr reader, xmlNodePtr cur) {
 347     xmlNodePtr next;

 348     xmlDictPtr dict;

 349 
 350     if ((reader != NULL) &amp;&amp; (reader-&gt;ctxt != NULL))
 351     dict = reader-&gt;ctxt-&gt;dict;
 352     else
 353         dict = NULL;
 354     if (cur == NULL) return;
 355     if (cur-&gt;type == XML_NAMESPACE_DECL) {
 356     xmlFreeNsList((xmlNsPtr) cur);
 357     return;
 358     }
 359     if ((cur-&gt;type == XML_DOCUMENT_NODE) ||
 360     (cur-&gt;type == XML_HTML_DOCUMENT_NODE)) {
 361     xmlFreeDoc((xmlDocPtr) cur);
 362     return;
 363     }
<span class="line-modified"> 364     while (cur != NULL) {</span>








 365         next = cur-&gt;next;


 366     /* unroll to speed up freeing the document */
 367     if (cur-&gt;type != XML_DTD_NODE) {
 368 
<span class="line-removed"> 369         if ((cur-&gt;children != NULL) &amp;&amp;</span>
<span class="line-removed"> 370         (cur-&gt;type != XML_ENTITY_REF_NODE)) {</span>
<span class="line-removed"> 371         if (cur-&gt;children-&gt;parent == cur)</span>
<span class="line-removed"> 372             xmlTextReaderFreeNodeList(reader, cur-&gt;children);</span>
<span class="line-removed"> 373         cur-&gt;children = NULL;</span>
<span class="line-removed"> 374         }</span>
<span class="line-removed"> 375 </span>
 376         if ((__xmlRegisterCallbacks) &amp;&amp; (xmlDeregisterNodeDefaultValue))
 377         xmlDeregisterNodeDefaultValue(cur);
 378 
 379         if (((cur-&gt;type == XML_ELEMENT_NODE) ||
 380          (cur-&gt;type == XML_XINCLUDE_START) ||
 381          (cur-&gt;type == XML_XINCLUDE_END)) &amp;&amp;
 382         (cur-&gt;properties != NULL))
 383         xmlTextReaderFreePropList(reader, cur-&gt;properties);
 384         if ((cur-&gt;content != (xmlChar *) &amp;(cur-&gt;properties)) &amp;&amp;
 385             (cur-&gt;type != XML_ELEMENT_NODE) &amp;&amp;
 386         (cur-&gt;type != XML_XINCLUDE_START) &amp;&amp;
 387         (cur-&gt;type != XML_XINCLUDE_END) &amp;&amp;
 388         (cur-&gt;type != XML_ENTITY_REF_NODE)) {
 389         DICT_FREE(cur-&gt;content);
 390         }
 391         if (((cur-&gt;type == XML_ELEMENT_NODE) ||
 392              (cur-&gt;type == XML_XINCLUDE_START) ||
 393          (cur-&gt;type == XML_XINCLUDE_END)) &amp;&amp;
 394         (cur-&gt;nsDef != NULL))
 395         xmlFreeNsList(cur-&gt;nsDef);
 396 
 397         /*
 398          * we don&#39;t free element names here they are interned now
 399          */
 400         if ((cur-&gt;type != XML_TEXT_NODE) &amp;&amp;
 401         (cur-&gt;type != XML_COMMENT_NODE))
 402         DICT_FREE(cur-&gt;name);
 403         if (((cur-&gt;type == XML_ELEMENT_NODE) ||
 404          (cur-&gt;type == XML_TEXT_NODE)) &amp;&amp;
 405             (reader != NULL) &amp;&amp; (reader-&gt;ctxt != NULL) &amp;&amp;
 406         (reader-&gt;ctxt-&gt;freeElemsNr &lt; 100)) {
 407             cur-&gt;next = reader-&gt;ctxt-&gt;freeElems;
 408         reader-&gt;ctxt-&gt;freeElems = cur;
 409         reader-&gt;ctxt-&gt;freeElemsNr++;
 410         } else {
 411         xmlFree(cur);
 412         }
 413     }


 414     cur = next;







 415     }
 416 }
 417 
 418 /**
 419  * xmlTextReaderFreeNode:
 420  * @reader:  the xmlTextReaderPtr used
 421  * @cur:  the node
 422  *
 423  * Free a node, this is a recursive behaviour, all the children are freed too.
 424  * This doesn&#39;t unlink the child from the list, use xmlUnlinkNode() first.
 425  */
 426 static void
 427 xmlTextReaderFreeNode(xmlTextReaderPtr reader, xmlNodePtr cur) {
 428     xmlDictPtr dict;
 429 
 430     if ((reader != NULL) &amp;&amp; (reader-&gt;ctxt != NULL))
 431     dict = reader-&gt;ctxt-&gt;dict;
 432     else
 433         dict = NULL;
 434     if (cur-&gt;type == XML_DTD_NODE) {
</pre>
<hr />
<pre>
 966         if (qname != NULL)
 967         xmlFree(qname);
 968     }
 969     }
 970 #endif /* LIBXML_VALID_ENABLED */
 971 #ifdef LIBXML_SCHEMAS_ENABLED
 972     if ((reader-&gt;validate == XML_TEXTREADER_VALIDATE_RNG) &amp;&amp;
 973                (reader-&gt;rngValidCtxt != NULL)) {
 974     int ret;
 975 
 976     if (reader-&gt;rngFullNode != NULL) return;
 977     ret = xmlRelaxNGValidatePushElement(reader-&gt;rngValidCtxt,
 978                                         reader-&gt;ctxt-&gt;myDoc,
 979                         node);
 980     if (ret == 0) {
 981         /*
 982          * this element requires a full tree
 983          */
 984         node = xmlTextReaderExpand(reader);
 985         if (node == NULL) {
<span class="line-removed"> 986 printf(&quot;Expand failed !\n&quot;);</span>
 987             ret = -1;
 988         } else {
 989         ret = xmlRelaxNGValidateFullElement(reader-&gt;rngValidCtxt,
 990                             reader-&gt;ctxt-&gt;myDoc,
 991                             node);
 992         reader-&gt;rngFullNode = node;
 993         }
 994     }
 995     if (ret != 1)
 996         reader-&gt;rngValidErrors++;
 997     }
 998 #endif
 999 }
1000 
1001 /**
1002  * xmlTextReaderValidateCData:
1003  * @reader:  the xmlTextReaderPtr used
1004  * @data:  pointer to the CData
1005  * @len:  length of the CData block in bytes.
1006  *
</pre>
<hr />
<pre>
1078 #endif
1079 }
1080 
1081 /**
1082  * xmlTextReaderValidateEntity:
1083  * @reader:  the xmlTextReaderPtr used
1084  *
1085  * Handle the validation when an entity reference is encountered and
1086  * entity substitution is not activated. As a result the parser interface
1087  * must walk through the entity and do the validation calls
1088  */
1089 static void
1090 xmlTextReaderValidateEntity(xmlTextReaderPtr reader) {
1091     xmlNodePtr oldnode = reader-&gt;node;
1092     xmlNodePtr node = reader-&gt;node;
1093     xmlParserCtxtPtr ctxt = reader-&gt;ctxt;
1094 
1095     do {
1096     if (node-&gt;type == XML_ENTITY_REF_NODE) {
1097         /*
<span class="line-modified">1098          * Case where the underlying tree is not availble, lookup the entity</span>
1099          * and walk it.
1100          */
1101         if ((node-&gt;children == NULL) &amp;&amp; (ctxt-&gt;sax != NULL) &amp;&amp;
1102         (ctxt-&gt;sax-&gt;getEntity != NULL)) {
1103         node-&gt;children = (xmlNodePtr)
1104             ctxt-&gt;sax-&gt;getEntity(ctxt, node-&gt;name);
1105         }
1106 
1107         if ((node-&gt;children != NULL) &amp;&amp;
1108         (node-&gt;children-&gt;type == XML_ENTITY_DECL) &amp;&amp;
1109         (node-&gt;children-&gt;children != NULL)) {
1110         xmlTextReaderEntPush(reader, node);
1111         node = node-&gt;children-&gt;children;
1112         continue;
1113         } else {
1114         /*
<span class="line-modified">1115          * The error has probably be raised already.</span>
1116          */
1117         if (node == oldnode)
1118             break;
<span class="line-modified">1119         node = node-&gt;next;</span>
1120         }
1121 #ifdef LIBXML_REGEXP_ENABLED
1122     } else if (node-&gt;type == XML_ELEMENT_NODE) {
1123         reader-&gt;node = node;
1124         xmlTextReaderValidatePush(reader);
1125     } else if ((node-&gt;type == XML_TEXT_NODE) ||
1126            (node-&gt;type == XML_CDATA_SECTION_NODE)) {
1127             xmlTextReaderValidateCData(reader, node-&gt;content,
1128                                    xmlStrlen(node-&gt;content));
1129 #endif
1130     }
1131 
1132     /*
1133      * go to next node
1134      */
1135     if (node-&gt;children != NULL) {
1136         node = node-&gt;children;
1137         continue;
1138     } else if (node-&gt;type == XML_ELEMENT_NODE) {
1139         xmlTextReaderValidatePop(reader);
1140     }

1141     if (node-&gt;next != NULL) {
1142         node = node-&gt;next;
1143         continue;
1144     }
1145     do {
1146         node = node-&gt;parent;
1147         if (node-&gt;type == XML_ELEMENT_NODE) {
1148             xmlNodePtr tmp;
1149         if (reader-&gt;entNr == 0) {
1150             while ((tmp = node-&gt;last) != NULL) {
1151             if ((tmp-&gt;extra &amp; NODE_IS_PRESERVED) == 0) {
1152                 xmlUnlinkNode(tmp);
1153                 xmlTextReaderFreeNode(reader, tmp);
1154             } else
1155                 break;
1156             }
1157         }
1158         reader-&gt;node = node;
1159         xmlTextReaderValidatePop(reader);
1160         }
</pre>
<hr />
<pre>
1340         reader-&gt;state = XML_TEXTREADER_ELEMENT;
1341     }
1342     reader-&gt;depth = 0;
1343     reader-&gt;ctxt-&gt;parseMode = XML_PARSE_READER;
1344     goto node_found;
1345     }
1346     oldstate = reader-&gt;state;
1347     olddepth = reader-&gt;ctxt-&gt;nodeNr;
1348     oldnode = reader-&gt;node;
1349 
1350 get_next_node:
1351     if (reader-&gt;node == NULL) {
1352     if (reader-&gt;mode == XML_TEXTREADER_MODE_EOF)
1353         return(0);
1354     else
1355         return(-1);
1356     }
1357 
1358     /*
1359      * If we are not backtracking on ancestors or examined nodes,
<span class="line-modified">1360      * that the parser didn&#39;t finished or that we arent at the end</span>
1361      * of stream, continue processing.
1362      */
1363     while ((reader-&gt;node != NULL) &amp;&amp; (reader-&gt;node-&gt;next == NULL) &amp;&amp;
1364        (reader-&gt;ctxt-&gt;nodeNr == olddepth) &amp;&amp;
1365            ((oldstate == XML_TEXTREADER_BACKTRACK) ||
1366             (reader-&gt;node-&gt;children == NULL) ||
1367         (reader-&gt;node-&gt;type == XML_ENTITY_REF_NODE) ||
1368         ((reader-&gt;node-&gt;children != NULL) &amp;&amp;
1369          (reader-&gt;node-&gt;children-&gt;type == XML_TEXT_NODE) &amp;&amp;
1370          (reader-&gt;node-&gt;children-&gt;next == NULL)) ||
1371         (reader-&gt;node-&gt;type == XML_DTD_NODE) ||
1372         (reader-&gt;node-&gt;type == XML_DOCUMENT_NODE) ||
1373         (reader-&gt;node-&gt;type == XML_HTML_DOCUMENT_NODE)) &amp;&amp;
1374        ((reader-&gt;ctxt-&gt;node == NULL) ||
1375         (reader-&gt;ctxt-&gt;node == reader-&gt;node) ||
1376         (reader-&gt;ctxt-&gt;node == reader-&gt;node-&gt;parent)) &amp;&amp;
1377        (reader-&gt;ctxt-&gt;instate != XML_PARSER_EOF)) {
1378     val = xmlTextReaderPushData(reader);
1379     if (val &lt; 0){
1380         reader-&gt;mode = XML_TEXTREADER_MODE_ERROR;
</pre>
<hr />
<pre>
1531     if (xmlTextReaderExpand(reader) == NULL)
1532         return -1;
1533     xmlXIncludeProcessNode(reader-&gt;xincctxt, reader-&gt;node);
1534     }
1535     if ((reader-&gt;node != NULL) &amp;&amp; (reader-&gt;node-&gt;type == XML_XINCLUDE_START)) {
1536         reader-&gt;in_xinclude++;
1537     goto get_next_node;
1538     }
1539     if ((reader-&gt;node != NULL) &amp;&amp; (reader-&gt;node-&gt;type == XML_XINCLUDE_END)) {
1540         reader-&gt;in_xinclude--;
1541     goto get_next_node;
1542     }
1543 #endif
1544     /*
1545      * Handle entities enter and exit when in entity replacement mode
1546      */
1547     if ((reader-&gt;node != NULL) &amp;&amp;
1548     (reader-&gt;node-&gt;type == XML_ENTITY_REF_NODE) &amp;&amp;
1549     (reader-&gt;ctxt != NULL) &amp;&amp; (reader-&gt;ctxt-&gt;replaceEntities == 1)) {
1550     /*
<span class="line-modified">1551      * Case where the underlying tree is not availble, lookup the entity</span>
1552      * and walk it.
1553      */
1554     if ((reader-&gt;node-&gt;children == NULL) &amp;&amp; (reader-&gt;ctxt-&gt;sax != NULL) &amp;&amp;
1555         (reader-&gt;ctxt-&gt;sax-&gt;getEntity != NULL)) {
1556         reader-&gt;node-&gt;children = (xmlNodePtr)
1557         reader-&gt;ctxt-&gt;sax-&gt;getEntity(reader-&gt;ctxt, reader-&gt;node-&gt;name);
1558     }
1559 
1560     if ((reader-&gt;node-&gt;children != NULL) &amp;&amp;
1561         (reader-&gt;node-&gt;children-&gt;type == XML_ENTITY_DECL) &amp;&amp;
1562         (reader-&gt;node-&gt;children-&gt;children != NULL)) {
1563         xmlTextReaderEntPush(reader, reader-&gt;node);
1564         reader-&gt;node = reader-&gt;node-&gt;children-&gt;children;
1565     }
1566 #ifdef LIBXML_REGEXP_ENABLED
1567     } else if ((reader-&gt;node != NULL) &amp;&amp;
1568            (reader-&gt;node-&gt;type == XML_ENTITY_REF_NODE) &amp;&amp;
1569            (reader-&gt;ctxt != NULL) &amp;&amp; (reader-&gt;validate)) {
1570     xmlTextReaderValidateEntity(reader);
1571 #endif /* LIBXML_REGEXP_ENABLED */
</pre>
<hr />
<pre>
1696  *
1697  * Reads the contents of the current node, including child nodes and markup.
1698  *
1699  * Returns a string containing the XML content, or NULL if the current node
1700  *         is neither an element nor attribute, or has no child nodes. The
1701  *         string must be deallocated by the caller.
1702  */
1703 xmlChar *
1704 xmlTextReaderReadInnerXml(xmlTextReaderPtr reader ATTRIBUTE_UNUSED)
1705 {
1706     xmlChar *resbuf;
1707     xmlNodePtr node, cur_node;
1708     xmlBufferPtr buff, buff2;
1709     xmlDocPtr doc;
1710 
1711     if (xmlTextReaderExpand(reader) == NULL) {
1712         return NULL;
1713     }
1714     doc = reader-&gt;node-&gt;doc;
1715     buff = xmlBufferCreate();


1716     for (cur_node = reader-&gt;node-&gt;children; cur_node != NULL;
1717          cur_node = cur_node-&gt;next) {
1718         /* XXX: Why is the node copied? */
1719         node = xmlDocCopyNode(cur_node, doc, 1);
1720         buff2 = xmlBufferCreate();
1721         if (xmlNodeDump(buff2, doc, node, 0, 0) == -1) {
1722             xmlFreeNode(node);
1723             xmlBufferFree(buff2);
1724             xmlBufferFree(buff);
1725             return NULL;
1726         }
1727         xmlBufferCat(buff, buff2-&gt;content);
1728         xmlFreeNode(node);
1729         xmlBufferFree(buff2);
1730     }
1731     resbuf = buff-&gt;content;
1732     buff-&gt;content = NULL;
1733 
1734     xmlBufferFree(buff);
1735     return resbuf;
</pre>
<hr />
<pre>
1738 
1739 #ifdef LIBXML_WRITER_ENABLED
1740 /**
1741  * xmlTextReaderReadOuterXml:
1742  * @reader:  the xmlTextReaderPtr used
1743  *
1744  * Reads the contents of the current node, including child nodes and markup.
1745  *
1746  * Returns a string containing the node and any XML content, or NULL if the
1747  *         current node cannot be serialized. The string must be deallocated
1748  *         by the caller.
1749  */
1750 xmlChar *
1751 xmlTextReaderReadOuterXml(xmlTextReaderPtr reader ATTRIBUTE_UNUSED)
1752 {
1753     xmlChar *resbuf;
1754     xmlNodePtr node;
1755     xmlBufferPtr buff;
1756     xmlDocPtr doc;
1757 
<span class="line-removed">1758     node = reader-&gt;node;</span>
<span class="line-removed">1759     doc = node-&gt;doc;</span>
1760     if (xmlTextReaderExpand(reader) == NULL) {
1761         return NULL;
1762     }


1763     /* XXX: Why is the node copied? */
1764     if (node-&gt;type == XML_DTD_NODE) {
1765         node = (xmlNodePtr) xmlCopyDtd((xmlDtdPtr) node);
1766     } else {
1767         node = xmlDocCopyNode(node, doc, 1);
1768     }
1769     buff = xmlBufferCreate();
1770     if (xmlNodeDump(buff, doc, node, 0, 0) == -1) {
1771         xmlFreeNode(node);
1772         xmlBufferFree(buff);
1773         return NULL;
1774     }
1775 
1776     resbuf = buff-&gt;content;
1777     buff-&gt;content = NULL;
1778 
1779     xmlFreeNode(node);
1780     xmlBufferFree(buff);
1781     return resbuf;
1782 }
</pre>
<hr />
<pre>
2245 #ifdef LIBXML_XINCLUDE_ENABLED
2246     if (reader-&gt;xincctxt != NULL)
2247     xmlXIncludeFreeContext(reader-&gt;xincctxt);
2248 #endif
2249 #ifdef LIBXML_PATTERN_ENABLED
2250     if (reader-&gt;patternTab != NULL) {
2251         int i;
2252     for (i = 0;i &lt; reader-&gt;patternNr;i++) {
2253         if (reader-&gt;patternTab[i] != NULL)
2254             xmlFreePattern(reader-&gt;patternTab[i]);
2255     }
2256     xmlFree(reader-&gt;patternTab);
2257     }
2258 #endif
2259     if (reader-&gt;faketext != NULL) {
2260     xmlFreeNode(reader-&gt;faketext);
2261     }
2262     if (reader-&gt;ctxt != NULL) {
2263         if (reader-&gt;dict == reader-&gt;ctxt-&gt;dict)
2264         reader-&gt;dict = NULL;
<span class="line-removed">2265     if (reader-&gt;ctxt-&gt;myDoc != NULL) {</span>
<span class="line-removed">2266         if (reader-&gt;preserve == 0)</span>
<span class="line-removed">2267         xmlTextReaderFreeDoc(reader, reader-&gt;ctxt-&gt;myDoc);</span>
<span class="line-removed">2268         reader-&gt;ctxt-&gt;myDoc = NULL;</span>
<span class="line-removed">2269     }</span>
2270     if ((reader-&gt;ctxt-&gt;vctxt.vstateTab != NULL) &amp;&amp;
2271         (reader-&gt;ctxt-&gt;vctxt.vstateMax &gt; 0)){




2272         xmlFree(reader-&gt;ctxt-&gt;vctxt.vstateTab);
2273         reader-&gt;ctxt-&gt;vctxt.vstateTab = NULL;
2274         reader-&gt;ctxt-&gt;vctxt.vstateMax = 0;
2275     }





2276     if (reader-&gt;allocs &amp; XML_TEXTREADER_CTXT)
2277         xmlFreeParserCtxt(reader-&gt;ctxt);
2278     }
2279     if (reader-&gt;sax != NULL)
2280     xmlFree(reader-&gt;sax);
2281     if ((reader-&gt;input != NULL)  &amp;&amp; (reader-&gt;allocs &amp; XML_TEXTREADER_INPUT))
2282     xmlFreeParserInputBuffer(reader-&gt;input);
2283     if (reader-&gt;buffer != NULL)
2284         xmlBufFree(reader-&gt;buffer);
2285     if (reader-&gt;entTab != NULL)
2286     xmlFree(reader-&gt;entTab);
2287     if (reader-&gt;dict != NULL)
2288         xmlDictFree(reader-&gt;dict);
2289     xmlFree(reader);
2290 }
2291 
2292 /************************************************************************
2293  *                                  *
2294  *          Methods for XmlTextReader           *
2295  *                                  *
</pre>
<hr />
<pre>
2483             if ((prefix == NULL &amp;&amp; ns-&gt;prefix == NULL) ||
2484                 ((ns-&gt;prefix != NULL) &amp;&amp; (xmlStrEqual(ns-&gt;prefix, localName)))) {
2485                 return xmlStrdup(ns-&gt;href);
2486             }
2487             ns = ns-&gt;next;
2488         }
2489         return NULL;
2490     }
2491 
2492     return(xmlGetNsProp(reader-&gt;node, localName, namespaceURI));
2493 }
2494 
2495 /**
2496  * xmlTextReaderGetRemainder:
2497  * @reader:  the xmlTextReaderPtr used
2498  *
2499  * Method to get the remainder of the buffered XML. this method stops the
2500  * parser, set its state to End Of File and return the input stream with
2501  * what is left that the parser did not use.
2502  *
<span class="line-modified">2503  * The implementation is not good, the parser certainly procgressed past</span>
2504  * what&#39;s left in reader-&gt;input, and there is an allocation problem. Best
2505  * would be to rewrite it differently.
2506  *
2507  * Returns the xmlParserInputBufferPtr attached to the XML or NULL
2508  *    in case of error.
2509  */
2510 xmlParserInputBufferPtr
2511 xmlTextReaderGetRemainder(xmlTextReaderPtr reader) {
2512     xmlParserInputBufferPtr ret = NULL;
2513 
2514     if (reader == NULL)
2515     return(NULL);
2516     if (reader-&gt;node == NULL)
2517     return(NULL);
2518 
2519     reader-&gt;node = NULL;
2520     reader-&gt;curnode = NULL;
2521     reader-&gt;mode = XML_TEXTREADER_MODE_EOF;
2522     if (reader-&gt;ctxt != NULL) {
2523     xmlStopParser(reader-&gt;ctxt);
</pre>
<hr />
<pre>
2865 xmlTextReaderMoveToElement(xmlTextReaderPtr reader) {
2866     if (reader == NULL)
2867     return(-1);
2868     if (reader-&gt;node == NULL)
2869     return(-1);
2870     if (reader-&gt;node-&gt;type != XML_ELEMENT_NODE)
2871     return(0);
2872     if (reader-&gt;curnode != NULL) {
2873     reader-&gt;curnode = NULL;
2874     return(1);
2875     }
2876     return(0);
2877 }
2878 
2879 /**
2880  * xmlTextReaderReadAttributeValue:
2881  * @reader:  the xmlTextReaderPtr used
2882  *
2883  * Parses an attribute value into one or more Text and EntityReference nodes.
2884  *
<span class="line-modified">2885  * Returns 1 in case of success, 0 if the reader was not positionned on an</span>
<span class="line-modified">2886  *         ttribute node or all the attribute values have been read, or -1</span>
2887  *         in case of error.
2888  */
2889 int
2890 xmlTextReaderReadAttributeValue(xmlTextReaderPtr reader) {
2891     if (reader == NULL)
2892     return(-1);
2893     if (reader-&gt;node == NULL)
2894     return(-1);
2895     if (reader-&gt;curnode == NULL)
2896     return(0);
2897     if (reader-&gt;curnode-&gt;type == XML_ATTRIBUTE_NODE) {
2898     if (reader-&gt;curnode-&gt;children == NULL)
2899         return(0);
2900     reader-&gt;curnode = reader-&gt;curnode-&gt;children;
2901     } else if (reader-&gt;curnode-&gt;type == XML_NAMESPACE_DECL) {
2902     xmlNsPtr ns = (xmlNsPtr) reader-&gt;curnode;
2903 
2904     if (reader-&gt;faketext == NULL) {
2905         reader-&gt;faketext = xmlNewDocText(reader-&gt;node-&gt;doc,
2906                                      ns-&gt;href);
</pre>
<hr />
<pre>
3903  * @reader: the user data (XML reader context)
3904  *
3905  * Provide the column number of the current parsing point.
3906  *
3907  * Returns an int or 0 if not available
3908  */
3909 int
3910 xmlTextReaderGetParserColumnNumber(xmlTextReaderPtr reader)
3911 {
3912     if ((reader == NULL) || (reader-&gt;ctxt == NULL) ||
3913         (reader-&gt;ctxt-&gt;input == NULL)) {
3914         return (0);
3915     }
3916     return (reader-&gt;ctxt-&gt;input-&gt;col);
3917 }
3918 
3919 /**
3920  * xmlTextReaderCurrentNode:
3921  * @reader:  the xmlTextReaderPtr used
3922  *
<span class="line-modified">3923  * Hacking interface allowing to get the xmlNodePtr correponding to the</span>
3924  * current node being accessed by the xmlTextReader. This is dangerous
3925  * because the underlying node may be destroyed on the next Reads.
3926  *
3927  * Returns the xmlNodePtr or NULL in case of error.
3928  */
3929 xmlNodePtr
3930 xmlTextReaderCurrentNode(xmlTextReaderPtr reader) {
3931     if (reader == NULL)
3932     return(NULL);
3933 
3934     if (reader-&gt;curnode != NULL)
3935     return(reader-&gt;curnode);
3936     return(reader-&gt;node);
3937 }
3938 
3939 /**
3940  * xmlTextReaderPreserve:
3941  * @reader:  the xmlTextReaderPtr used
3942  *
3943  * This tells the XML Reader to preserve the current node.
</pre>
<hr />
<pre>
4015         reader-&gt;patternMax *= 2;
4016     tmp = (xmlPatternPtr *) xmlRealloc(reader-&gt;patternTab,
4017                                       reader-&gt;patternMax *
4018                                       sizeof(reader-&gt;patternTab[0]));
4019         if (tmp == NULL) {
4020             xmlGenericError(xmlGenericErrorContext, &quot;xmlRealloc failed !\n&quot;);
4021         reader-&gt;patternMax /= 2;
4022             return (-1);
4023         }
4024     reader-&gt;patternTab = tmp;
4025     }
4026     reader-&gt;patternTab[reader-&gt;patternNr] = comp;
4027     return(reader-&gt;patternNr++);
4028 }
4029 #endif
4030 
4031 /**
4032  * xmlTextReaderCurrentDoc:
4033  * @reader:  the xmlTextReaderPtr used
4034  *
<span class="line-modified">4035  * Hacking interface allowing to get the xmlDocPtr correponding to the</span>
4036  * current document being accessed by the xmlTextReader.
4037  * NOTE: as a result of this call, the reader will not destroy the
4038  *       associated XML document and calling xmlFreeDoc() on the result
4039  *       is needed once the reader parsing has finished.
4040  *
4041  * Returns the xmlDocPtr or NULL in case of error.
4042  */
4043 xmlDocPtr
4044 xmlTextReaderCurrentDoc(xmlTextReaderPtr reader) {
4045     if (reader == NULL)
4046     return(NULL);
4047     if (reader-&gt;doc != NULL)
4048         return(reader-&gt;doc);
4049     if ((reader-&gt;ctxt == NULL) || (reader-&gt;ctxt-&gt;myDoc == NULL))
4050     return(NULL);
4051 
4052     reader-&gt;preserve = 1;
4053     return(reader-&gt;ctxt-&gt;myDoc);
4054 }
4055 
</pre>
<hr />
<pre>
4118   xmlTextReaderStructuredError(void *ctxt, xmlErrorPtr error);
4119 
4120 static void
4121 xmlTextReaderValidityStructuredRelay(void *userData, xmlErrorPtr error)
4122 {
4123     xmlTextReaderPtr reader = (xmlTextReaderPtr) userData;
4124 
4125     if (reader-&gt;sErrorFunc) {
4126         reader-&gt;sErrorFunc(reader-&gt;errorFuncArg, error);
4127     } else {
4128         xmlTextReaderStructuredError(reader, error);
4129     }
4130 }
4131 /**
4132  * xmlTextReaderRelaxNGSetSchema:
4133  * @reader:  the xmlTextReaderPtr used
4134  * @schema:  a precompiled RelaxNG schema
4135  *
4136  * Use RelaxNG to validate the document as it is processed.
4137  * Activation is only possible before the first Read().
<span class="line-modified">4138  * if @schema is NULL, then RelaxNG validation is desactivated.</span>
4139  @ The @schema should not be freed until the reader is deallocated
4140  * or its use has been deactivated.
4141  *
<span class="line-modified">4142  * Returns 0 in case the RelaxNG validation could be (des)activated and</span>
4143  *         -1 in case of error.
4144  */
4145 int
4146 xmlTextReaderRelaxNGSetSchema(xmlTextReaderPtr reader, xmlRelaxNGPtr schema) {
4147     if (reader == NULL)
4148         return(-1);
4149     if (schema == NULL) {
4150         if (reader-&gt;rngSchemas != NULL) {
4151         xmlRelaxNGFree(reader-&gt;rngSchemas);
4152         reader-&gt;rngSchemas = NULL;
4153     }
4154         if (reader-&gt;rngValidCtxt != NULL) {
4155         if (! reader-&gt;rngPreserveCtxt)
4156         xmlRelaxNGFreeValidCtxt(reader-&gt;rngValidCtxt);
4157         reader-&gt;rngValidCtxt = NULL;
4158         }
4159     reader-&gt;rngPreserveCtxt = 0;
4160     return(0);
4161     }
4162     if (reader-&gt;mode != XML_TEXTREADER_MODE_INITIAL)
</pre>
<hr />
<pre>
4182     }
4183     if (reader-&gt;sErrorFunc != NULL) {
4184         xmlRelaxNGSetValidStructuredErrors(reader-&gt;rngValidCtxt,
4185             xmlTextReaderValidityStructuredRelay,
4186             reader);
4187     }
4188     reader-&gt;rngValidErrors = 0;
4189     reader-&gt;rngFullNode = NULL;
4190     reader-&gt;validate = XML_TEXTREADER_VALIDATE_RNG;
4191     return(0);
4192 }
4193 
4194 /**
4195  * xmlTextReaderLocator:
4196  * @ctx: the xmlTextReaderPtr used
4197  * @file: returned file information
4198  * @line: returned line information
4199  *
4200  * Internal locator function for the readers
4201  *
<span class="line-modified">4202  * Returns 0 in case the Schema validation could be (des)activated and</span>
4203  *         -1 in case of error.
4204  */
4205 static int
4206 xmlTextReaderLocator(void *ctx, const char **file, unsigned long *line) {
4207     xmlTextReaderPtr reader;
4208 
4209     if ((ctx == NULL) || ((file == NULL) &amp;&amp; (line == NULL)))
4210         return(-1);
4211 
4212     if (file != NULL)
4213         *file = NULL;
4214     if (line != NULL)
4215         *line = 0;
4216 
4217     reader = (xmlTextReaderPtr) ctx;
4218     if ((reader-&gt;ctxt != NULL) &amp;&amp; (reader-&gt;ctxt-&gt;input != NULL)) {
4219     if (file != NULL)
4220         *file = reader-&gt;ctxt-&gt;input-&gt;filename;
4221     if (line != NULL)
4222         *line = reader-&gt;ctxt-&gt;input-&gt;line;
</pre>
<hr />
<pre>
4235     }
4236         if (file != NULL) {
4237         xmlDocPtr doc = reader-&gt;node-&gt;doc;
4238         if ((doc != NULL) &amp;&amp; (doc-&gt;URL != NULL))
4239             *file = (const char *) doc-&gt;URL;
4240         else
4241                 ret = -1;
4242     }
4243     return(ret);
4244     }
4245     return(-1);
4246 }
4247 
4248 /**
4249  * xmlTextReaderSetSchema:
4250  * @reader:  the xmlTextReaderPtr used
4251  * @schema:  a precompiled Schema schema
4252  *
4253  * Use XSD Schema to validate the document as it is processed.
4254  * Activation is only possible before the first Read().
<span class="line-modified">4255  * if @schema is NULL, then Schema validation is desactivated.</span>
<span class="line-modified">4256  @ The @schema should not be freed until the reader is deallocated</span>
4257  * or its use has been deactivated.
4258  *
<span class="line-modified">4259  * Returns 0 in case the Schema validation could be (des)activated and</span>
4260  *         -1 in case of error.
4261  */
4262 int
4263 xmlTextReaderSetSchema(xmlTextReaderPtr reader, xmlSchemaPtr schema) {
4264     if (reader == NULL)
4265         return(-1);
4266     if (schema == NULL) {
4267     if (reader-&gt;xsdPlug != NULL) {
4268         xmlSchemaSAXUnplug(reader-&gt;xsdPlug);
4269         reader-&gt;xsdPlug = NULL;
4270     }
4271         if (reader-&gt;xsdValidCtxt != NULL) {
4272         if (! reader-&gt;xsdPreserveCtxt)
4273         xmlSchemaFreeValidCtxt(reader-&gt;xsdValidCtxt);
4274         reader-&gt;xsdValidCtxt = NULL;
4275         }
4276     reader-&gt;xsdPreserveCtxt = 0;
4277         if (reader-&gt;xsdSchemas != NULL) {
4278         xmlSchemaFree(reader-&gt;xsdSchemas);
4279         reader-&gt;xsdSchemas = NULL;
</pre>
</td>
<td>
<hr />
<pre>
 221 static void xmlTextReaderFreeNode(xmlTextReaderPtr reader, xmlNodePtr cur);
 222 static void xmlTextReaderFreeNodeList(xmlTextReaderPtr reader, xmlNodePtr cur);
 223 
 224 /**
 225  * xmlFreeID:
 226  * @not:  A id
 227  *
 228  * Deallocate the memory used by an id definition
 229  */
 230 static void
 231 xmlFreeID(xmlIDPtr id) {
 232     xmlDictPtr dict = NULL;
 233 
 234     if (id == NULL) return;
 235 
 236     if (id-&gt;doc != NULL)
 237         dict = id-&gt;doc-&gt;dict;
 238 
 239     if (id-&gt;value != NULL)
 240     DICT_FREE(id-&gt;value)
<span class="line-added"> 241     if (id-&gt;name != NULL)</span>
<span class="line-added"> 242     DICT_FREE(id-&gt;name)</span>
 243     xmlFree(id);
 244 }
 245 
 246 /**
 247  * xmlTextReaderRemoveID:
 248  * @doc:  the document
 249  * @attr:  the attribute
 250  *
 251  * Remove the given attribute from the ID table maintained internally.
 252  *
 253  * Returns -1 if the lookup failed and 0 otherwise
 254  */
 255 static int
 256 xmlTextReaderRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {
 257     xmlIDTablePtr table;
 258     xmlIDPtr id;
 259     xmlChar *ID;
 260 
 261     if (doc == NULL) return(-1);
 262     if (attr == NULL) return(-1);
 263     table = (xmlIDTablePtr) doc-&gt;ids;
 264     if (table == NULL)
 265         return(-1);
 266 
 267     ID = xmlNodeListGetString(doc, attr-&gt;children, 1);
 268     if (ID == NULL)
 269     return(-1);
 270     id = xmlHashLookup(table, ID);
 271     xmlFree(ID);
 272     if (id == NULL || id-&gt;attr != attr) {
 273     return(-1);
 274     }
 275     id-&gt;name = attr-&gt;name;
<span class="line-added"> 276     attr-&gt;name = NULL;</span>
 277     id-&gt;attr = NULL;
 278     return(0);
 279 }
 280 
 281 /**
 282  * xmlTextReaderFreeProp:
 283  * @reader:  the xmlTextReaderPtr used
 284  * @cur:  the node
 285  *
 286  * Free a node.
 287  */
 288 static void
 289 xmlTextReaderFreeProp(xmlTextReaderPtr reader, xmlAttrPtr cur) {
 290     xmlDictPtr dict;
 291 
 292     if ((reader != NULL) &amp;&amp; (reader-&gt;ctxt != NULL))
 293     dict = reader-&gt;ctxt-&gt;dict;
 294     else
 295         dict = NULL;
 296     if (cur == NULL) return;
</pre>
<hr />
<pre>
 331     xmlAttrPtr next;
 332 
 333     while (cur != NULL) {
 334         next = cur-&gt;next;
 335         xmlTextReaderFreeProp(reader, cur);
 336     cur = next;
 337     }
 338 }
 339 
 340 /**
 341  * xmlTextReaderFreeNodeList:
 342  * @reader:  the xmlTextReaderPtr used
 343  * @cur:  the first node in the list
 344  *
 345  * Free a node and all its siblings, this is a recursive behaviour, all
 346  * the children are freed too.
 347  */
 348 static void
 349 xmlTextReaderFreeNodeList(xmlTextReaderPtr reader, xmlNodePtr cur) {
 350     xmlNodePtr next;
<span class="line-added"> 351     xmlNodePtr parent;</span>
 352     xmlDictPtr dict;
<span class="line-added"> 353     size_t depth = 0;</span>
 354 
 355     if ((reader != NULL) &amp;&amp; (reader-&gt;ctxt != NULL))
 356     dict = reader-&gt;ctxt-&gt;dict;
 357     else
 358         dict = NULL;
 359     if (cur == NULL) return;
 360     if (cur-&gt;type == XML_NAMESPACE_DECL) {
 361     xmlFreeNsList((xmlNsPtr) cur);
 362     return;
 363     }
 364     if ((cur-&gt;type == XML_DOCUMENT_NODE) ||
 365     (cur-&gt;type == XML_HTML_DOCUMENT_NODE)) {
 366     xmlFreeDoc((xmlDocPtr) cur);
 367     return;
 368     }
<span class="line-modified"> 369     while (1) {</span>
<span class="line-added"> 370         while ((cur-&gt;type != XML_DTD_NODE) &amp;&amp;</span>
<span class="line-added"> 371                (cur-&gt;type != XML_ENTITY_REF_NODE) &amp;&amp;</span>
<span class="line-added"> 372                (cur-&gt;children != NULL) &amp;&amp;</span>
<span class="line-added"> 373                (cur-&gt;children-&gt;parent == cur)) {</span>
<span class="line-added"> 374             cur = cur-&gt;children;</span>
<span class="line-added"> 375             depth += 1;</span>
<span class="line-added"> 376         }</span>
<span class="line-added"> 377 </span>
 378         next = cur-&gt;next;
<span class="line-added"> 379         parent = cur-&gt;parent;</span>
<span class="line-added"> 380 </span>
 381     /* unroll to speed up freeing the document */
 382     if (cur-&gt;type != XML_DTD_NODE) {
 383 







 384         if ((__xmlRegisterCallbacks) &amp;&amp; (xmlDeregisterNodeDefaultValue))
 385         xmlDeregisterNodeDefaultValue(cur);
 386 
 387         if (((cur-&gt;type == XML_ELEMENT_NODE) ||
 388          (cur-&gt;type == XML_XINCLUDE_START) ||
 389          (cur-&gt;type == XML_XINCLUDE_END)) &amp;&amp;
 390         (cur-&gt;properties != NULL))
 391         xmlTextReaderFreePropList(reader, cur-&gt;properties);
 392         if ((cur-&gt;content != (xmlChar *) &amp;(cur-&gt;properties)) &amp;&amp;
 393             (cur-&gt;type != XML_ELEMENT_NODE) &amp;&amp;
 394         (cur-&gt;type != XML_XINCLUDE_START) &amp;&amp;
 395         (cur-&gt;type != XML_XINCLUDE_END) &amp;&amp;
 396         (cur-&gt;type != XML_ENTITY_REF_NODE)) {
 397         DICT_FREE(cur-&gt;content);
 398         }
 399         if (((cur-&gt;type == XML_ELEMENT_NODE) ||
 400              (cur-&gt;type == XML_XINCLUDE_START) ||
 401          (cur-&gt;type == XML_XINCLUDE_END)) &amp;&amp;
 402         (cur-&gt;nsDef != NULL))
 403         xmlFreeNsList(cur-&gt;nsDef);
 404 
 405         /*
 406          * we don&#39;t free element names here they are interned now
 407          */
 408         if ((cur-&gt;type != XML_TEXT_NODE) &amp;&amp;
 409         (cur-&gt;type != XML_COMMENT_NODE))
 410         DICT_FREE(cur-&gt;name);
 411         if (((cur-&gt;type == XML_ELEMENT_NODE) ||
 412          (cur-&gt;type == XML_TEXT_NODE)) &amp;&amp;
 413             (reader != NULL) &amp;&amp; (reader-&gt;ctxt != NULL) &amp;&amp;
 414         (reader-&gt;ctxt-&gt;freeElemsNr &lt; 100)) {
 415             cur-&gt;next = reader-&gt;ctxt-&gt;freeElems;
 416         reader-&gt;ctxt-&gt;freeElems = cur;
 417         reader-&gt;ctxt-&gt;freeElemsNr++;
 418         } else {
 419         xmlFree(cur);
 420         }
 421     }
<span class="line-added"> 422 </span>
<span class="line-added"> 423         if (next != NULL) {</span>
 424     cur = next;
<span class="line-added"> 425         } else {</span>
<span class="line-added"> 426             if ((depth == 0) || (parent == NULL))</span>
<span class="line-added"> 427                 break;</span>
<span class="line-added"> 428             depth -= 1;</span>
<span class="line-added"> 429             cur = parent;</span>
<span class="line-added"> 430             cur-&gt;children = NULL;</span>
<span class="line-added"> 431         }</span>
 432     }
 433 }
 434 
 435 /**
 436  * xmlTextReaderFreeNode:
 437  * @reader:  the xmlTextReaderPtr used
 438  * @cur:  the node
 439  *
 440  * Free a node, this is a recursive behaviour, all the children are freed too.
 441  * This doesn&#39;t unlink the child from the list, use xmlUnlinkNode() first.
 442  */
 443 static void
 444 xmlTextReaderFreeNode(xmlTextReaderPtr reader, xmlNodePtr cur) {
 445     xmlDictPtr dict;
 446 
 447     if ((reader != NULL) &amp;&amp; (reader-&gt;ctxt != NULL))
 448     dict = reader-&gt;ctxt-&gt;dict;
 449     else
 450         dict = NULL;
 451     if (cur-&gt;type == XML_DTD_NODE) {
</pre>
<hr />
<pre>
 983         if (qname != NULL)
 984         xmlFree(qname);
 985     }
 986     }
 987 #endif /* LIBXML_VALID_ENABLED */
 988 #ifdef LIBXML_SCHEMAS_ENABLED
 989     if ((reader-&gt;validate == XML_TEXTREADER_VALIDATE_RNG) &amp;&amp;
 990                (reader-&gt;rngValidCtxt != NULL)) {
 991     int ret;
 992 
 993     if (reader-&gt;rngFullNode != NULL) return;
 994     ret = xmlRelaxNGValidatePushElement(reader-&gt;rngValidCtxt,
 995                                         reader-&gt;ctxt-&gt;myDoc,
 996                         node);
 997     if (ret == 0) {
 998         /*
 999          * this element requires a full tree
1000          */
1001         node = xmlTextReaderExpand(reader);
1002         if (node == NULL) {

1003             ret = -1;
1004         } else {
1005         ret = xmlRelaxNGValidateFullElement(reader-&gt;rngValidCtxt,
1006                             reader-&gt;ctxt-&gt;myDoc,
1007                             node);
1008         reader-&gt;rngFullNode = node;
1009         }
1010     }
1011     if (ret != 1)
1012         reader-&gt;rngValidErrors++;
1013     }
1014 #endif
1015 }
1016 
1017 /**
1018  * xmlTextReaderValidateCData:
1019  * @reader:  the xmlTextReaderPtr used
1020  * @data:  pointer to the CData
1021  * @len:  length of the CData block in bytes.
1022  *
</pre>
<hr />
<pre>
1094 #endif
1095 }
1096 
1097 /**
1098  * xmlTextReaderValidateEntity:
1099  * @reader:  the xmlTextReaderPtr used
1100  *
1101  * Handle the validation when an entity reference is encountered and
1102  * entity substitution is not activated. As a result the parser interface
1103  * must walk through the entity and do the validation calls
1104  */
1105 static void
1106 xmlTextReaderValidateEntity(xmlTextReaderPtr reader) {
1107     xmlNodePtr oldnode = reader-&gt;node;
1108     xmlNodePtr node = reader-&gt;node;
1109     xmlParserCtxtPtr ctxt = reader-&gt;ctxt;
1110 
1111     do {
1112     if (node-&gt;type == XML_ENTITY_REF_NODE) {
1113         /*
<span class="line-modified">1114          * Case where the underlying tree is not available, lookup the entity</span>
1115          * and walk it.
1116          */
1117         if ((node-&gt;children == NULL) &amp;&amp; (ctxt-&gt;sax != NULL) &amp;&amp;
1118         (ctxt-&gt;sax-&gt;getEntity != NULL)) {
1119         node-&gt;children = (xmlNodePtr)
1120             ctxt-&gt;sax-&gt;getEntity(ctxt, node-&gt;name);
1121         }
1122 
1123         if ((node-&gt;children != NULL) &amp;&amp;
1124         (node-&gt;children-&gt;type == XML_ENTITY_DECL) &amp;&amp;
1125         (node-&gt;children-&gt;children != NULL)) {
1126         xmlTextReaderEntPush(reader, node);
1127         node = node-&gt;children-&gt;children;
1128         continue;
1129         } else {
1130         /*
<span class="line-modified">1131          * The error has probably been raised already.</span>
1132          */
1133         if (node == oldnode)
1134             break;
<span class="line-modified">1135                 goto skip_children;</span>
1136         }
1137 #ifdef LIBXML_REGEXP_ENABLED
1138     } else if (node-&gt;type == XML_ELEMENT_NODE) {
1139         reader-&gt;node = node;
1140         xmlTextReaderValidatePush(reader);
1141     } else if ((node-&gt;type == XML_TEXT_NODE) ||
1142            (node-&gt;type == XML_CDATA_SECTION_NODE)) {
1143             xmlTextReaderValidateCData(reader, node-&gt;content,
1144                                    xmlStrlen(node-&gt;content));
1145 #endif
1146     }
1147 
1148     /*
1149      * go to next node
1150      */
1151     if (node-&gt;children != NULL) {
1152         node = node-&gt;children;
1153         continue;
1154     } else if (node-&gt;type == XML_ELEMENT_NODE) {
1155         xmlTextReaderValidatePop(reader);
1156     }
<span class="line-added">1157 skip_children:</span>
1158     if (node-&gt;next != NULL) {
1159         node = node-&gt;next;
1160         continue;
1161     }
1162     do {
1163         node = node-&gt;parent;
1164         if (node-&gt;type == XML_ELEMENT_NODE) {
1165             xmlNodePtr tmp;
1166         if (reader-&gt;entNr == 0) {
1167             while ((tmp = node-&gt;last) != NULL) {
1168             if ((tmp-&gt;extra &amp; NODE_IS_PRESERVED) == 0) {
1169                 xmlUnlinkNode(tmp);
1170                 xmlTextReaderFreeNode(reader, tmp);
1171             } else
1172                 break;
1173             }
1174         }
1175         reader-&gt;node = node;
1176         xmlTextReaderValidatePop(reader);
1177         }
</pre>
<hr />
<pre>
1357         reader-&gt;state = XML_TEXTREADER_ELEMENT;
1358     }
1359     reader-&gt;depth = 0;
1360     reader-&gt;ctxt-&gt;parseMode = XML_PARSE_READER;
1361     goto node_found;
1362     }
1363     oldstate = reader-&gt;state;
1364     olddepth = reader-&gt;ctxt-&gt;nodeNr;
1365     oldnode = reader-&gt;node;
1366 
1367 get_next_node:
1368     if (reader-&gt;node == NULL) {
1369     if (reader-&gt;mode == XML_TEXTREADER_MODE_EOF)
1370         return(0);
1371     else
1372         return(-1);
1373     }
1374 
1375     /*
1376      * If we are not backtracking on ancestors or examined nodes,
<span class="line-modified">1377      * that the parser didn&#39;t finished or that we aren&#39;t at the end</span>
1378      * of stream, continue processing.
1379      */
1380     while ((reader-&gt;node != NULL) &amp;&amp; (reader-&gt;node-&gt;next == NULL) &amp;&amp;
1381        (reader-&gt;ctxt-&gt;nodeNr == olddepth) &amp;&amp;
1382            ((oldstate == XML_TEXTREADER_BACKTRACK) ||
1383             (reader-&gt;node-&gt;children == NULL) ||
1384         (reader-&gt;node-&gt;type == XML_ENTITY_REF_NODE) ||
1385         ((reader-&gt;node-&gt;children != NULL) &amp;&amp;
1386          (reader-&gt;node-&gt;children-&gt;type == XML_TEXT_NODE) &amp;&amp;
1387          (reader-&gt;node-&gt;children-&gt;next == NULL)) ||
1388         (reader-&gt;node-&gt;type == XML_DTD_NODE) ||
1389         (reader-&gt;node-&gt;type == XML_DOCUMENT_NODE) ||
1390         (reader-&gt;node-&gt;type == XML_HTML_DOCUMENT_NODE)) &amp;&amp;
1391        ((reader-&gt;ctxt-&gt;node == NULL) ||
1392         (reader-&gt;ctxt-&gt;node == reader-&gt;node) ||
1393         (reader-&gt;ctxt-&gt;node == reader-&gt;node-&gt;parent)) &amp;&amp;
1394        (reader-&gt;ctxt-&gt;instate != XML_PARSER_EOF)) {
1395     val = xmlTextReaderPushData(reader);
1396     if (val &lt; 0){
1397         reader-&gt;mode = XML_TEXTREADER_MODE_ERROR;
</pre>
<hr />
<pre>
1548     if (xmlTextReaderExpand(reader) == NULL)
1549         return -1;
1550     xmlXIncludeProcessNode(reader-&gt;xincctxt, reader-&gt;node);
1551     }
1552     if ((reader-&gt;node != NULL) &amp;&amp; (reader-&gt;node-&gt;type == XML_XINCLUDE_START)) {
1553         reader-&gt;in_xinclude++;
1554     goto get_next_node;
1555     }
1556     if ((reader-&gt;node != NULL) &amp;&amp; (reader-&gt;node-&gt;type == XML_XINCLUDE_END)) {
1557         reader-&gt;in_xinclude--;
1558     goto get_next_node;
1559     }
1560 #endif
1561     /*
1562      * Handle entities enter and exit when in entity replacement mode
1563      */
1564     if ((reader-&gt;node != NULL) &amp;&amp;
1565     (reader-&gt;node-&gt;type == XML_ENTITY_REF_NODE) &amp;&amp;
1566     (reader-&gt;ctxt != NULL) &amp;&amp; (reader-&gt;ctxt-&gt;replaceEntities == 1)) {
1567     /*
<span class="line-modified">1568      * Case where the underlying tree is not available, lookup the entity</span>
1569      * and walk it.
1570      */
1571     if ((reader-&gt;node-&gt;children == NULL) &amp;&amp; (reader-&gt;ctxt-&gt;sax != NULL) &amp;&amp;
1572         (reader-&gt;ctxt-&gt;sax-&gt;getEntity != NULL)) {
1573         reader-&gt;node-&gt;children = (xmlNodePtr)
1574         reader-&gt;ctxt-&gt;sax-&gt;getEntity(reader-&gt;ctxt, reader-&gt;node-&gt;name);
1575     }
1576 
1577     if ((reader-&gt;node-&gt;children != NULL) &amp;&amp;
1578         (reader-&gt;node-&gt;children-&gt;type == XML_ENTITY_DECL) &amp;&amp;
1579         (reader-&gt;node-&gt;children-&gt;children != NULL)) {
1580         xmlTextReaderEntPush(reader, reader-&gt;node);
1581         reader-&gt;node = reader-&gt;node-&gt;children-&gt;children;
1582     }
1583 #ifdef LIBXML_REGEXP_ENABLED
1584     } else if ((reader-&gt;node != NULL) &amp;&amp;
1585            (reader-&gt;node-&gt;type == XML_ENTITY_REF_NODE) &amp;&amp;
1586            (reader-&gt;ctxt != NULL) &amp;&amp; (reader-&gt;validate)) {
1587     xmlTextReaderValidateEntity(reader);
1588 #endif /* LIBXML_REGEXP_ENABLED */
</pre>
<hr />
<pre>
1713  *
1714  * Reads the contents of the current node, including child nodes and markup.
1715  *
1716  * Returns a string containing the XML content, or NULL if the current node
1717  *         is neither an element nor attribute, or has no child nodes. The
1718  *         string must be deallocated by the caller.
1719  */
1720 xmlChar *
1721 xmlTextReaderReadInnerXml(xmlTextReaderPtr reader ATTRIBUTE_UNUSED)
1722 {
1723     xmlChar *resbuf;
1724     xmlNodePtr node, cur_node;
1725     xmlBufferPtr buff, buff2;
1726     xmlDocPtr doc;
1727 
1728     if (xmlTextReaderExpand(reader) == NULL) {
1729         return NULL;
1730     }
1731     doc = reader-&gt;node-&gt;doc;
1732     buff = xmlBufferCreate();
<span class="line-added">1733     if (buff == NULL)</span>
<span class="line-added">1734         return NULL;</span>
1735     for (cur_node = reader-&gt;node-&gt;children; cur_node != NULL;
1736          cur_node = cur_node-&gt;next) {
1737         /* XXX: Why is the node copied? */
1738         node = xmlDocCopyNode(cur_node, doc, 1);
1739         buff2 = xmlBufferCreate();
1740         if (xmlNodeDump(buff2, doc, node, 0, 0) == -1) {
1741             xmlFreeNode(node);
1742             xmlBufferFree(buff2);
1743             xmlBufferFree(buff);
1744             return NULL;
1745         }
1746         xmlBufferCat(buff, buff2-&gt;content);
1747         xmlFreeNode(node);
1748         xmlBufferFree(buff2);
1749     }
1750     resbuf = buff-&gt;content;
1751     buff-&gt;content = NULL;
1752 
1753     xmlBufferFree(buff);
1754     return resbuf;
</pre>
<hr />
<pre>
1757 
1758 #ifdef LIBXML_WRITER_ENABLED
1759 /**
1760  * xmlTextReaderReadOuterXml:
1761  * @reader:  the xmlTextReaderPtr used
1762  *
1763  * Reads the contents of the current node, including child nodes and markup.
1764  *
1765  * Returns a string containing the node and any XML content, or NULL if the
1766  *         current node cannot be serialized. The string must be deallocated
1767  *         by the caller.
1768  */
1769 xmlChar *
1770 xmlTextReaderReadOuterXml(xmlTextReaderPtr reader ATTRIBUTE_UNUSED)
1771 {
1772     xmlChar *resbuf;
1773     xmlNodePtr node;
1774     xmlBufferPtr buff;
1775     xmlDocPtr doc;
1776 


1777     if (xmlTextReaderExpand(reader) == NULL) {
1778         return NULL;
1779     }
<span class="line-added">1780     node = reader-&gt;node;</span>
<span class="line-added">1781     doc = node-&gt;doc;</span>
1782     /* XXX: Why is the node copied? */
1783     if (node-&gt;type == XML_DTD_NODE) {
1784         node = (xmlNodePtr) xmlCopyDtd((xmlDtdPtr) node);
1785     } else {
1786         node = xmlDocCopyNode(node, doc, 1);
1787     }
1788     buff = xmlBufferCreate();
1789     if (xmlNodeDump(buff, doc, node, 0, 0) == -1) {
1790         xmlFreeNode(node);
1791         xmlBufferFree(buff);
1792         return NULL;
1793     }
1794 
1795     resbuf = buff-&gt;content;
1796     buff-&gt;content = NULL;
1797 
1798     xmlFreeNode(node);
1799     xmlBufferFree(buff);
1800     return resbuf;
1801 }
</pre>
<hr />
<pre>
2264 #ifdef LIBXML_XINCLUDE_ENABLED
2265     if (reader-&gt;xincctxt != NULL)
2266     xmlXIncludeFreeContext(reader-&gt;xincctxt);
2267 #endif
2268 #ifdef LIBXML_PATTERN_ENABLED
2269     if (reader-&gt;patternTab != NULL) {
2270         int i;
2271     for (i = 0;i &lt; reader-&gt;patternNr;i++) {
2272         if (reader-&gt;patternTab[i] != NULL)
2273             xmlFreePattern(reader-&gt;patternTab[i]);
2274     }
2275     xmlFree(reader-&gt;patternTab);
2276     }
2277 #endif
2278     if (reader-&gt;faketext != NULL) {
2279     xmlFreeNode(reader-&gt;faketext);
2280     }
2281     if (reader-&gt;ctxt != NULL) {
2282         if (reader-&gt;dict == reader-&gt;ctxt-&gt;dict)
2283         reader-&gt;dict = NULL;





2284     if ((reader-&gt;ctxt-&gt;vctxt.vstateTab != NULL) &amp;&amp;
2285         (reader-&gt;ctxt-&gt;vctxt.vstateMax &gt; 0)){
<span class="line-added">2286 #ifdef LIBXML_REGEXP_ENABLED</span>
<span class="line-added">2287             while (reader-&gt;ctxt-&gt;vctxt.vstateNr &gt; 0)</span>
<span class="line-added">2288                 xmlValidatePopElement(&amp;reader-&gt;ctxt-&gt;vctxt, NULL, NULL, NULL);</span>
<span class="line-added">2289 #endif</span>
2290         xmlFree(reader-&gt;ctxt-&gt;vctxt.vstateTab);
2291         reader-&gt;ctxt-&gt;vctxt.vstateTab = NULL;
2292         reader-&gt;ctxt-&gt;vctxt.vstateMax = 0;
2293     }
<span class="line-added">2294     if (reader-&gt;ctxt-&gt;myDoc != NULL) {</span>
<span class="line-added">2295         if (reader-&gt;preserve == 0)</span>
<span class="line-added">2296         xmlTextReaderFreeDoc(reader, reader-&gt;ctxt-&gt;myDoc);</span>
<span class="line-added">2297         reader-&gt;ctxt-&gt;myDoc = NULL;</span>
<span class="line-added">2298     }</span>
2299     if (reader-&gt;allocs &amp; XML_TEXTREADER_CTXT)
2300         xmlFreeParserCtxt(reader-&gt;ctxt);
2301     }
2302     if (reader-&gt;sax != NULL)
2303     xmlFree(reader-&gt;sax);
2304     if ((reader-&gt;input != NULL)  &amp;&amp; (reader-&gt;allocs &amp; XML_TEXTREADER_INPUT))
2305     xmlFreeParserInputBuffer(reader-&gt;input);
2306     if (reader-&gt;buffer != NULL)
2307         xmlBufFree(reader-&gt;buffer);
2308     if (reader-&gt;entTab != NULL)
2309     xmlFree(reader-&gt;entTab);
2310     if (reader-&gt;dict != NULL)
2311         xmlDictFree(reader-&gt;dict);
2312     xmlFree(reader);
2313 }
2314 
2315 /************************************************************************
2316  *                                  *
2317  *          Methods for XmlTextReader           *
2318  *                                  *
</pre>
<hr />
<pre>
2506             if ((prefix == NULL &amp;&amp; ns-&gt;prefix == NULL) ||
2507                 ((ns-&gt;prefix != NULL) &amp;&amp; (xmlStrEqual(ns-&gt;prefix, localName)))) {
2508                 return xmlStrdup(ns-&gt;href);
2509             }
2510             ns = ns-&gt;next;
2511         }
2512         return NULL;
2513     }
2514 
2515     return(xmlGetNsProp(reader-&gt;node, localName, namespaceURI));
2516 }
2517 
2518 /**
2519  * xmlTextReaderGetRemainder:
2520  * @reader:  the xmlTextReaderPtr used
2521  *
2522  * Method to get the remainder of the buffered XML. this method stops the
2523  * parser, set its state to End Of File and return the input stream with
2524  * what is left that the parser did not use.
2525  *
<span class="line-modified">2526  * The implementation is not good, the parser certainly progressed past</span>
2527  * what&#39;s left in reader-&gt;input, and there is an allocation problem. Best
2528  * would be to rewrite it differently.
2529  *
2530  * Returns the xmlParserInputBufferPtr attached to the XML or NULL
2531  *    in case of error.
2532  */
2533 xmlParserInputBufferPtr
2534 xmlTextReaderGetRemainder(xmlTextReaderPtr reader) {
2535     xmlParserInputBufferPtr ret = NULL;
2536 
2537     if (reader == NULL)
2538     return(NULL);
2539     if (reader-&gt;node == NULL)
2540     return(NULL);
2541 
2542     reader-&gt;node = NULL;
2543     reader-&gt;curnode = NULL;
2544     reader-&gt;mode = XML_TEXTREADER_MODE_EOF;
2545     if (reader-&gt;ctxt != NULL) {
2546     xmlStopParser(reader-&gt;ctxt);
</pre>
<hr />
<pre>
2888 xmlTextReaderMoveToElement(xmlTextReaderPtr reader) {
2889     if (reader == NULL)
2890     return(-1);
2891     if (reader-&gt;node == NULL)
2892     return(-1);
2893     if (reader-&gt;node-&gt;type != XML_ELEMENT_NODE)
2894     return(0);
2895     if (reader-&gt;curnode != NULL) {
2896     reader-&gt;curnode = NULL;
2897     return(1);
2898     }
2899     return(0);
2900 }
2901 
2902 /**
2903  * xmlTextReaderReadAttributeValue:
2904  * @reader:  the xmlTextReaderPtr used
2905  *
2906  * Parses an attribute value into one or more Text and EntityReference nodes.
2907  *
<span class="line-modified">2908  * Returns 1 in case of success, 0 if the reader was not positioned on an</span>
<span class="line-modified">2909  *         attribute node or all the attribute values have been read, or -1</span>
2910  *         in case of error.
2911  */
2912 int
2913 xmlTextReaderReadAttributeValue(xmlTextReaderPtr reader) {
2914     if (reader == NULL)
2915     return(-1);
2916     if (reader-&gt;node == NULL)
2917     return(-1);
2918     if (reader-&gt;curnode == NULL)
2919     return(0);
2920     if (reader-&gt;curnode-&gt;type == XML_ATTRIBUTE_NODE) {
2921     if (reader-&gt;curnode-&gt;children == NULL)
2922         return(0);
2923     reader-&gt;curnode = reader-&gt;curnode-&gt;children;
2924     } else if (reader-&gt;curnode-&gt;type == XML_NAMESPACE_DECL) {
2925     xmlNsPtr ns = (xmlNsPtr) reader-&gt;curnode;
2926 
2927     if (reader-&gt;faketext == NULL) {
2928         reader-&gt;faketext = xmlNewDocText(reader-&gt;node-&gt;doc,
2929                                      ns-&gt;href);
</pre>
<hr />
<pre>
3926  * @reader: the user data (XML reader context)
3927  *
3928  * Provide the column number of the current parsing point.
3929  *
3930  * Returns an int or 0 if not available
3931  */
3932 int
3933 xmlTextReaderGetParserColumnNumber(xmlTextReaderPtr reader)
3934 {
3935     if ((reader == NULL) || (reader-&gt;ctxt == NULL) ||
3936         (reader-&gt;ctxt-&gt;input == NULL)) {
3937         return (0);
3938     }
3939     return (reader-&gt;ctxt-&gt;input-&gt;col);
3940 }
3941 
3942 /**
3943  * xmlTextReaderCurrentNode:
3944  * @reader:  the xmlTextReaderPtr used
3945  *
<span class="line-modified">3946  * Hacking interface allowing to get the xmlNodePtr corresponding to the</span>
3947  * current node being accessed by the xmlTextReader. This is dangerous
3948  * because the underlying node may be destroyed on the next Reads.
3949  *
3950  * Returns the xmlNodePtr or NULL in case of error.
3951  */
3952 xmlNodePtr
3953 xmlTextReaderCurrentNode(xmlTextReaderPtr reader) {
3954     if (reader == NULL)
3955     return(NULL);
3956 
3957     if (reader-&gt;curnode != NULL)
3958     return(reader-&gt;curnode);
3959     return(reader-&gt;node);
3960 }
3961 
3962 /**
3963  * xmlTextReaderPreserve:
3964  * @reader:  the xmlTextReaderPtr used
3965  *
3966  * This tells the XML Reader to preserve the current node.
</pre>
<hr />
<pre>
4038         reader-&gt;patternMax *= 2;
4039     tmp = (xmlPatternPtr *) xmlRealloc(reader-&gt;patternTab,
4040                                       reader-&gt;patternMax *
4041                                       sizeof(reader-&gt;patternTab[0]));
4042         if (tmp == NULL) {
4043             xmlGenericError(xmlGenericErrorContext, &quot;xmlRealloc failed !\n&quot;);
4044         reader-&gt;patternMax /= 2;
4045             return (-1);
4046         }
4047     reader-&gt;patternTab = tmp;
4048     }
4049     reader-&gt;patternTab[reader-&gt;patternNr] = comp;
4050     return(reader-&gt;patternNr++);
4051 }
4052 #endif
4053 
4054 /**
4055  * xmlTextReaderCurrentDoc:
4056  * @reader:  the xmlTextReaderPtr used
4057  *
<span class="line-modified">4058  * Hacking interface allowing to get the xmlDocPtr corresponding to the</span>
4059  * current document being accessed by the xmlTextReader.
4060  * NOTE: as a result of this call, the reader will not destroy the
4061  *       associated XML document and calling xmlFreeDoc() on the result
4062  *       is needed once the reader parsing has finished.
4063  *
4064  * Returns the xmlDocPtr or NULL in case of error.
4065  */
4066 xmlDocPtr
4067 xmlTextReaderCurrentDoc(xmlTextReaderPtr reader) {
4068     if (reader == NULL)
4069     return(NULL);
4070     if (reader-&gt;doc != NULL)
4071         return(reader-&gt;doc);
4072     if ((reader-&gt;ctxt == NULL) || (reader-&gt;ctxt-&gt;myDoc == NULL))
4073     return(NULL);
4074 
4075     reader-&gt;preserve = 1;
4076     return(reader-&gt;ctxt-&gt;myDoc);
4077 }
4078 
</pre>
<hr />
<pre>
4141   xmlTextReaderStructuredError(void *ctxt, xmlErrorPtr error);
4142 
4143 static void
4144 xmlTextReaderValidityStructuredRelay(void *userData, xmlErrorPtr error)
4145 {
4146     xmlTextReaderPtr reader = (xmlTextReaderPtr) userData;
4147 
4148     if (reader-&gt;sErrorFunc) {
4149         reader-&gt;sErrorFunc(reader-&gt;errorFuncArg, error);
4150     } else {
4151         xmlTextReaderStructuredError(reader, error);
4152     }
4153 }
4154 /**
4155  * xmlTextReaderRelaxNGSetSchema:
4156  * @reader:  the xmlTextReaderPtr used
4157  * @schema:  a precompiled RelaxNG schema
4158  *
4159  * Use RelaxNG to validate the document as it is processed.
4160  * Activation is only possible before the first Read().
<span class="line-modified">4161  * if @schema is NULL, then RelaxNG validation is deactivated.</span>
4162  @ The @schema should not be freed until the reader is deallocated
4163  * or its use has been deactivated.
4164  *
<span class="line-modified">4165  * Returns 0 in case the RelaxNG validation could be (de)activated and</span>
4166  *         -1 in case of error.
4167  */
4168 int
4169 xmlTextReaderRelaxNGSetSchema(xmlTextReaderPtr reader, xmlRelaxNGPtr schema) {
4170     if (reader == NULL)
4171         return(-1);
4172     if (schema == NULL) {
4173         if (reader-&gt;rngSchemas != NULL) {
4174         xmlRelaxNGFree(reader-&gt;rngSchemas);
4175         reader-&gt;rngSchemas = NULL;
4176     }
4177         if (reader-&gt;rngValidCtxt != NULL) {
4178         if (! reader-&gt;rngPreserveCtxt)
4179         xmlRelaxNGFreeValidCtxt(reader-&gt;rngValidCtxt);
4180         reader-&gt;rngValidCtxt = NULL;
4181         }
4182     reader-&gt;rngPreserveCtxt = 0;
4183     return(0);
4184     }
4185     if (reader-&gt;mode != XML_TEXTREADER_MODE_INITIAL)
</pre>
<hr />
<pre>
4205     }
4206     if (reader-&gt;sErrorFunc != NULL) {
4207         xmlRelaxNGSetValidStructuredErrors(reader-&gt;rngValidCtxt,
4208             xmlTextReaderValidityStructuredRelay,
4209             reader);
4210     }
4211     reader-&gt;rngValidErrors = 0;
4212     reader-&gt;rngFullNode = NULL;
4213     reader-&gt;validate = XML_TEXTREADER_VALIDATE_RNG;
4214     return(0);
4215 }
4216 
4217 /**
4218  * xmlTextReaderLocator:
4219  * @ctx: the xmlTextReaderPtr used
4220  * @file: returned file information
4221  * @line: returned line information
4222  *
4223  * Internal locator function for the readers
4224  *
<span class="line-modified">4225  * Returns 0 in case the Schema validation could be (de)activated and</span>
4226  *         -1 in case of error.
4227  */
4228 static int
4229 xmlTextReaderLocator(void *ctx, const char **file, unsigned long *line) {
4230     xmlTextReaderPtr reader;
4231 
4232     if ((ctx == NULL) || ((file == NULL) &amp;&amp; (line == NULL)))
4233         return(-1);
4234 
4235     if (file != NULL)
4236         *file = NULL;
4237     if (line != NULL)
4238         *line = 0;
4239 
4240     reader = (xmlTextReaderPtr) ctx;
4241     if ((reader-&gt;ctxt != NULL) &amp;&amp; (reader-&gt;ctxt-&gt;input != NULL)) {
4242     if (file != NULL)
4243         *file = reader-&gt;ctxt-&gt;input-&gt;filename;
4244     if (line != NULL)
4245         *line = reader-&gt;ctxt-&gt;input-&gt;line;
</pre>
<hr />
<pre>
4258     }
4259         if (file != NULL) {
4260         xmlDocPtr doc = reader-&gt;node-&gt;doc;
4261         if ((doc != NULL) &amp;&amp; (doc-&gt;URL != NULL))
4262             *file = (const char *) doc-&gt;URL;
4263         else
4264                 ret = -1;
4265     }
4266     return(ret);
4267     }
4268     return(-1);
4269 }
4270 
4271 /**
4272  * xmlTextReaderSetSchema:
4273  * @reader:  the xmlTextReaderPtr used
4274  * @schema:  a precompiled Schema schema
4275  *
4276  * Use XSD Schema to validate the document as it is processed.
4277  * Activation is only possible before the first Read().
<span class="line-modified">4278  * if @schema is NULL, then Schema validation is deactivated.</span>
<span class="line-modified">4279  * The @schema should not be freed until the reader is deallocated</span>
4280  * or its use has been deactivated.
4281  *
<span class="line-modified">4282  * Returns 0 in case the Schema validation could be (de)activated and</span>
4283  *         -1 in case of error.
4284  */
4285 int
4286 xmlTextReaderSetSchema(xmlTextReaderPtr reader, xmlSchemaPtr schema) {
4287     if (reader == NULL)
4288         return(-1);
4289     if (schema == NULL) {
4290     if (reader-&gt;xsdPlug != NULL) {
4291         xmlSchemaSAXUnplug(reader-&gt;xsdPlug);
4292         reader-&gt;xsdPlug = NULL;
4293     }
4294         if (reader-&gt;xsdValidCtxt != NULL) {
4295         if (! reader-&gt;xsdPreserveCtxt)
4296         xmlSchemaFreeValidCtxt(reader-&gt;xsdValidCtxt);
4297         reader-&gt;xsdValidCtxt = NULL;
4298         }
4299     reader-&gt;xsdPreserveCtxt = 0;
4300         if (reader-&gt;xsdSchemas != NULL) {
4301         xmlSchemaFree(reader-&gt;xsdSchemas);
4302         reader-&gt;xsdSchemas = NULL;
</pre>
</td>
</tr>
</table>
<center><a href="xmlIO.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="xmlsave.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
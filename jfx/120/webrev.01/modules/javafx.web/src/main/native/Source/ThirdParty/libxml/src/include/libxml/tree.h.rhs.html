<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/include/libxml/tree.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Summary: interfaces for tree manipulation
   3  * Description: this module describes the structures found in an tree resulting
   4  *              from an XML or HTML parsing, as well as the API provided for
   5  *              various processing on that tree
   6  *
   7  * Copy: See Copyright for the status of this software.
   8  *
   9  * Author: Daniel Veillard
  10  */
  11 
  12 #ifndef __XML_TREE_H__
  13 #define __XML_TREE_H__
  14 
  15 #include &lt;stdio.h&gt;
  16 #include &lt;limits.h&gt;
  17 #include &lt;libxml/xmlversion.h&gt;
  18 #include &lt;libxml/xmlstring.h&gt;
  19 
  20 #ifdef __cplusplus
  21 extern &quot;C&quot; {
  22 #endif
  23 
  24 /*
  25  * Some of the basic types pointer to structures:
  26  */
  27 /* xmlIO.h */
  28 typedef struct _xmlParserInputBuffer xmlParserInputBuffer;
  29 typedef xmlParserInputBuffer *xmlParserInputBufferPtr;
  30 
  31 typedef struct _xmlOutputBuffer xmlOutputBuffer;
  32 typedef xmlOutputBuffer *xmlOutputBufferPtr;
  33 
  34 /* parser.h */
  35 typedef struct _xmlParserInput xmlParserInput;
  36 typedef xmlParserInput *xmlParserInputPtr;
  37 
  38 typedef struct _xmlParserCtxt xmlParserCtxt;
  39 typedef xmlParserCtxt *xmlParserCtxtPtr;
  40 
  41 typedef struct _xmlSAXLocator xmlSAXLocator;
  42 typedef xmlSAXLocator *xmlSAXLocatorPtr;
  43 
  44 typedef struct _xmlSAXHandler xmlSAXHandler;
  45 typedef xmlSAXHandler *xmlSAXHandlerPtr;
  46 
  47 /* entities.h */
  48 typedef struct _xmlEntity xmlEntity;
  49 typedef xmlEntity *xmlEntityPtr;
  50 
  51 /**
  52  * BASE_BUFFER_SIZE:
  53  *
  54  * default buffer size 4000.
  55  */
  56 #define BASE_BUFFER_SIZE 4096
  57 
  58 /**
  59  * LIBXML_NAMESPACE_DICT:
  60  *
  61  * Defines experimental behaviour:
  62  * 1) xmlNs gets an additional field @context (a xmlDoc)
  63  * 2) when creating a tree, xmlNs-&gt;href is stored in the dict of xmlDoc.
  64  */
  65 /* #define LIBXML_NAMESPACE_DICT */
  66 
  67 /**
  68  * xmlBufferAllocationScheme:
  69  *
  70  * A buffer allocation scheme can be defined to either match exactly the
  71  * need or double it&#39;s allocated size each time it is found too small.
  72  */
  73 
  74 typedef enum {
  75     XML_BUFFER_ALLOC_DOUBLEIT,  /* double each time one need to grow */
  76     XML_BUFFER_ALLOC_EXACT, /* grow only to the minimal size */
  77     XML_BUFFER_ALLOC_IMMUTABLE, /* immutable buffer */
  78     XML_BUFFER_ALLOC_IO,    /* special allocation scheme used for I/O */
  79     XML_BUFFER_ALLOC_HYBRID,    /* exact up to a threshold, and doubleit thereafter */
  80     XML_BUFFER_ALLOC_BOUNDED    /* limit the upper size of the buffer */
  81 } xmlBufferAllocationScheme;
  82 
  83 /**
  84  * xmlBuffer:
  85  *
  86  * A buffer structure, this old construct is limited to 2GB and
  87  * is being deprecated, use API with xmlBuf instead
  88  */
  89 typedef struct _xmlBuffer xmlBuffer;
  90 typedef xmlBuffer *xmlBufferPtr;
  91 struct _xmlBuffer {
  92     xmlChar *content;       /* The buffer content UTF8 */
  93     unsigned int use;       /* The buffer size used */
  94     unsigned int size;      /* The buffer size */
  95     xmlBufferAllocationScheme alloc; /* The realloc method */
  96     xmlChar *contentIO;     /* in IO mode we may have a different base */
  97 };
  98 
  99 /**
 100  * xmlBuf:
 101  *
 102  * A buffer structure, new one, the actual structure internals are not public
 103  */
 104 
 105 typedef struct _xmlBuf xmlBuf;
 106 
 107 /**
 108  * xmlBufPtr:
 109  *
 110  * A pointer to a buffer structure, the actual structure internals are not
 111  * public
 112  */
 113 
 114 typedef xmlBuf *xmlBufPtr;
 115 
 116 /*
 117  * A few public routines for xmlBuf. As those are expected to be used
 118  * mostly internally the bulk of the routines are internal in buf.h
 119  */
 120 XMLPUBFUN xmlChar* XMLCALL       xmlBufContent  (const xmlBuf* buf);
 121 XMLPUBFUN xmlChar* XMLCALL       xmlBufEnd      (xmlBufPtr buf);
 122 XMLPUBFUN size_t XMLCALL         xmlBufUse      (const xmlBufPtr buf);
 123 XMLPUBFUN size_t XMLCALL         xmlBufShrink   (xmlBufPtr buf, size_t len);
 124 
 125 /*
 126  * LIBXML2_NEW_BUFFER:
 127  *
 128  * Macro used to express that the API use the new buffers for
 129  * xmlParserInputBuffer and xmlOutputBuffer. The change was
 130  * introduced in 2.9.0.
 131  */
 132 #define LIBXML2_NEW_BUFFER
 133 
 134 /**
 135  * XML_XML_NAMESPACE:
 136  *
 137  * This is the namespace for the special xml: prefix predefined in the
 138  * XML Namespace specification.
 139  */
 140 #define XML_XML_NAMESPACE \
 141     (const xmlChar *) &quot;http://www.w3.org/XML/1998/namespace&quot;
 142 
 143 /**
 144  * XML_XML_ID:
 145  *
 146  * This is the name for the special xml:id attribute
 147  */
 148 #define XML_XML_ID (const xmlChar *) &quot;xml:id&quot;
 149 
 150 /*
 151  * The different element types carried by an XML tree.
 152  *
 153  * NOTE: This is synchronized with DOM Level1 values
 154  *       See http://www.w3.org/TR/REC-DOM-Level-1/
 155  *
 156  * Actually this had diverged a bit, and now XML_DOCUMENT_TYPE_NODE should
 157  * be deprecated to use an XML_DTD_NODE.
 158  */
 159 typedef enum {
 160     XML_ELEMENT_NODE=       1,
 161     XML_ATTRIBUTE_NODE=     2,
 162     XML_TEXT_NODE=      3,
 163     XML_CDATA_SECTION_NODE= 4,
 164     XML_ENTITY_REF_NODE=    5,
 165     XML_ENTITY_NODE=        6,
 166     XML_PI_NODE=        7,
 167     XML_COMMENT_NODE=       8,
 168     XML_DOCUMENT_NODE=      9,
 169     XML_DOCUMENT_TYPE_NODE= 10,
 170     XML_DOCUMENT_FRAG_NODE= 11,
 171     XML_NOTATION_NODE=      12,
 172     XML_HTML_DOCUMENT_NODE= 13,
 173     XML_DTD_NODE=       14,
 174     XML_ELEMENT_DECL=       15,
 175     XML_ATTRIBUTE_DECL=     16,
 176     XML_ENTITY_DECL=        17,
 177     XML_NAMESPACE_DECL=     18,
 178     XML_XINCLUDE_START=     19,
 179     XML_XINCLUDE_END=       20
 180 #ifdef LIBXML_DOCB_ENABLED
 181    ,XML_DOCB_DOCUMENT_NODE= 21
 182 #endif
 183 } xmlElementType;
 184 
 185 
 186 /**
 187  * xmlNotation:
 188  *
 189  * A DTD Notation definition.
 190  */
 191 
 192 typedef struct _xmlNotation xmlNotation;
 193 typedef xmlNotation *xmlNotationPtr;
 194 struct _xmlNotation {
 195     const xmlChar               *name;          /* Notation name */
 196     const xmlChar               *PublicID;  /* Public identifier, if any */
 197     const xmlChar               *SystemID;  /* System identifier, if any */
 198 };
 199 
 200 /**
 201  * xmlAttributeType:
 202  *
 203  * A DTD Attribute type definition.
 204  */
 205 
 206 typedef enum {
 207     XML_ATTRIBUTE_CDATA = 1,
 208     XML_ATTRIBUTE_ID,
 209     XML_ATTRIBUTE_IDREF ,
 210     XML_ATTRIBUTE_IDREFS,
 211     XML_ATTRIBUTE_ENTITY,
 212     XML_ATTRIBUTE_ENTITIES,
 213     XML_ATTRIBUTE_NMTOKEN,
 214     XML_ATTRIBUTE_NMTOKENS,
 215     XML_ATTRIBUTE_ENUMERATION,
 216     XML_ATTRIBUTE_NOTATION
 217 } xmlAttributeType;
 218 
 219 /**
 220  * xmlAttributeDefault:
 221  *
 222  * A DTD Attribute default definition.
 223  */
 224 
 225 typedef enum {
 226     XML_ATTRIBUTE_NONE = 1,
 227     XML_ATTRIBUTE_REQUIRED,
 228     XML_ATTRIBUTE_IMPLIED,
 229     XML_ATTRIBUTE_FIXED
 230 } xmlAttributeDefault;
 231 
 232 /**
 233  * xmlEnumeration:
 234  *
 235  * List structure used when there is an enumeration in DTDs.
 236  */
 237 
 238 typedef struct _xmlEnumeration xmlEnumeration;
 239 typedef xmlEnumeration *xmlEnumerationPtr;
 240 struct _xmlEnumeration {
 241     struct _xmlEnumeration    *next;    /* next one */
 242     const xmlChar            *name; /* Enumeration name */
 243 };
 244 
 245 /**
 246  * xmlAttribute:
 247  *
 248  * An Attribute declaration in a DTD.
 249  */
 250 
 251 typedef struct _xmlAttribute xmlAttribute;
 252 typedef xmlAttribute *xmlAttributePtr;
 253 struct _xmlAttribute {
 254     void           *_private;           /* application data */
 255     xmlElementType          type;       /* XML_ATTRIBUTE_DECL, must be second ! */
 256     const xmlChar          *name;   /* Attribute name */
 257     struct _xmlNode    *children;   /* NULL */
 258     struct _xmlNode        *last;   /* NULL */
 259     struct _xmlDtd       *parent;   /* -&gt; DTD */
 260     struct _xmlNode        *next;   /* next sibling link  */
 261     struct _xmlNode        *prev;   /* previous sibling link  */
 262     struct _xmlDoc          *doc;       /* the containing document */
 263 
 264     struct _xmlAttribute  *nexth;   /* next in hash table */
 265     xmlAttributeType       atype;   /* The attribute type */
 266     xmlAttributeDefault      def;   /* the default */
 267     const xmlChar  *defaultValue;   /* or the default value */
 268     xmlEnumerationPtr       tree;       /* or the enumeration tree if any */
 269     const xmlChar        *prefix;   /* the namespace prefix if any */
 270     const xmlChar          *elem;   /* Element holding the attribute */
 271 };
 272 
 273 /**
 274  * xmlElementContentType:
 275  *
 276  * Possible definitions of element content types.
 277  */
 278 typedef enum {
 279     XML_ELEMENT_CONTENT_PCDATA = 1,
 280     XML_ELEMENT_CONTENT_ELEMENT,
 281     XML_ELEMENT_CONTENT_SEQ,
 282     XML_ELEMENT_CONTENT_OR
 283 } xmlElementContentType;
 284 
 285 /**
 286  * xmlElementContentOccur:
 287  *
 288  * Possible definitions of element content occurrences.
 289  */
 290 typedef enum {
 291     XML_ELEMENT_CONTENT_ONCE = 1,
 292     XML_ELEMENT_CONTENT_OPT,
 293     XML_ELEMENT_CONTENT_MULT,
 294     XML_ELEMENT_CONTENT_PLUS
 295 } xmlElementContentOccur;
 296 
 297 /**
 298  * xmlElementContent:
 299  *
 300  * An XML Element content as stored after parsing an element definition
 301  * in a DTD.
 302  */
 303 
 304 typedef struct _xmlElementContent xmlElementContent;
 305 typedef xmlElementContent *xmlElementContentPtr;
 306 struct _xmlElementContent {
 307     xmlElementContentType     type; /* PCDATA, ELEMENT, SEQ or OR */
 308     xmlElementContentOccur    ocur; /* ONCE, OPT, MULT or PLUS */
 309     const xmlChar             *name;    /* Element name */
 310     struct _xmlElementContent *c1;  /* first child */
 311     struct _xmlElementContent *c2;  /* second child */
 312     struct _xmlElementContent *parent;  /* parent */
 313     const xmlChar             *prefix;  /* Namespace prefix */
 314 };
 315 
 316 /**
 317  * xmlElementTypeVal:
 318  *
 319  * The different possibilities for an element content type.
 320  */
 321 
 322 typedef enum {
 323     XML_ELEMENT_TYPE_UNDEFINED = 0,
 324     XML_ELEMENT_TYPE_EMPTY = 1,
 325     XML_ELEMENT_TYPE_ANY,
 326     XML_ELEMENT_TYPE_MIXED,
 327     XML_ELEMENT_TYPE_ELEMENT
 328 } xmlElementTypeVal;
 329 
 330 #ifdef __cplusplus
 331 }
 332 #endif
 333 #include &lt;libxml/xmlregexp.h&gt;
 334 #ifdef __cplusplus
 335 extern &quot;C&quot; {
 336 #endif
 337 
 338 /**
 339  * xmlElement:
 340  *
 341  * An XML Element declaration from a DTD.
 342  */
 343 
 344 typedef struct _xmlElement xmlElement;
 345 typedef xmlElement *xmlElementPtr;
 346 struct _xmlElement {
 347     void           *_private;           /* application data */
 348     xmlElementType          type;       /* XML_ELEMENT_DECL, must be second ! */
 349     const xmlChar          *name;   /* Element name */
 350     struct _xmlNode    *children;   /* NULL */
 351     struct _xmlNode        *last;   /* NULL */
 352     struct _xmlDtd       *parent;   /* -&gt; DTD */
 353     struct _xmlNode        *next;   /* next sibling link  */
 354     struct _xmlNode        *prev;   /* previous sibling link  */
 355     struct _xmlDoc          *doc;       /* the containing document */
 356 
 357     xmlElementTypeVal      etype;   /* The type */
 358     xmlElementContentPtr content;   /* the allowed element content */
 359     xmlAttributePtr   attributes;   /* List of the declared attributes */
 360     const xmlChar        *prefix;   /* the namespace prefix if any */
 361 #ifdef LIBXML_REGEXP_ENABLED
 362     xmlRegexpPtr       contModel;   /* the validating regexp */
 363 #else
 364     void          *contModel;
 365 #endif
 366 };
 367 
 368 
 369 /**
 370  * XML_LOCAL_NAMESPACE:
 371  *
 372  * A namespace declaration node.
 373  */
 374 #define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
 375 typedef xmlElementType xmlNsType;
 376 
 377 /**
 378  * xmlNs:
 379  *
 380  * An XML namespace.
 381  * Note that prefix == NULL is valid, it defines the default namespace
 382  * within the subtree (until overridden).
 383  *
 384  * xmlNsType is unified with xmlElementType.
 385  */
 386 
 387 typedef struct _xmlNs xmlNs;
 388 typedef xmlNs *xmlNsPtr;
 389 struct _xmlNs {
 390     struct _xmlNs  *next;   /* next Ns link for this node  */
 391     xmlNsType      type;    /* global or local */
 392     const xmlChar *href;    /* URL for the namespace */
 393     const xmlChar *prefix;  /* prefix for the namespace */
 394     void           *_private;   /* application data */
 395     struct _xmlDoc *context;        /* normally an xmlDoc */
 396 };
 397 
 398 /**
 399  * xmlDtd:
 400  *
 401  * An XML DTD, as defined by &lt;!DOCTYPE ... There is actually one for
 402  * the internal subset and for the external subset.
 403  */
 404 typedef struct _xmlDtd xmlDtd;
 405 typedef xmlDtd *xmlDtdPtr;
 406 struct _xmlDtd {
 407     void           *_private;   /* application data */
 408     xmlElementType  type;       /* XML_DTD_NODE, must be second ! */
 409     const xmlChar *name;    /* Name of the DTD */
 410     struct _xmlNode *children;  /* the value of the property link */
 411     struct _xmlNode *last;  /* last child link */
 412     struct _xmlDoc  *parent;    /* child-&gt;parent link */
 413     struct _xmlNode *next;  /* next sibling link  */
 414     struct _xmlNode *prev;  /* previous sibling link  */
 415     struct _xmlDoc  *doc;   /* the containing document */
 416 
 417     /* End of common part */
 418     void          *notations;   /* Hash table for notations if any */
 419     void          *elements;    /* Hash table for elements if any */
 420     void          *attributes;  /* Hash table for attributes if any */
 421     void          *entities;    /* Hash table for entities if any */
 422     const xmlChar *ExternalID;  /* External identifier for PUBLIC DTD */
 423     const xmlChar *SystemID;    /* URI for a SYSTEM or PUBLIC DTD */
 424     void          *pentities;   /* Hash table for param entities if any */
 425 };
 426 
 427 /**
 428  * xmlAttr:
 429  *
 430  * An attribute on an XML node.
 431  */
 432 typedef struct _xmlAttr xmlAttr;
 433 typedef xmlAttr *xmlAttrPtr;
 434 struct _xmlAttr {
 435     void           *_private;   /* application data */
 436     xmlElementType   type;      /* XML_ATTRIBUTE_NODE, must be second ! */
 437     const xmlChar   *name;      /* the name of the property */
 438     struct _xmlNode *children;  /* the value of the property */
 439     struct _xmlNode *last;  /* NULL */
 440     struct _xmlNode *parent;    /* child-&gt;parent link */
 441     struct _xmlAttr *next;  /* next sibling link  */
 442     struct _xmlAttr *prev;  /* previous sibling link  */
 443     struct _xmlDoc  *doc;   /* the containing document */
 444     xmlNs           *ns;        /* pointer to the associated namespace */
 445     xmlAttributeType atype;     /* the attribute type if validating */
 446     void            *psvi;  /* for type/PSVI informations */
 447 };
 448 
 449 /**
 450  * xmlID:
 451  *
 452  * An XML ID instance.
 453  */
 454 
 455 typedef struct _xmlID xmlID;
 456 typedef xmlID *xmlIDPtr;
 457 struct _xmlID {
 458     struct _xmlID    *next; /* next ID */
 459     const xmlChar    *value;    /* The ID name */
 460     xmlAttrPtr        attr; /* The attribute holding it */
 461     const xmlChar    *name; /* The attribute if attr is not available */
 462     int               lineno;   /* The line number if attr is not available */
 463     struct _xmlDoc   *doc;  /* The document holding the ID */
 464 };
 465 
 466 /**
 467  * xmlRef:
 468  *
 469  * An XML IDREF instance.
 470  */
 471 
 472 typedef struct _xmlRef xmlRef;
 473 typedef xmlRef *xmlRefPtr;
 474 struct _xmlRef {
 475     struct _xmlRef    *next;    /* next Ref */
 476     const xmlChar     *value;   /* The Ref name */
 477     xmlAttrPtr        attr; /* The attribute holding it */
 478     const xmlChar    *name; /* The attribute if attr is not available */
 479     int               lineno;   /* The line number if attr is not available */
 480 };
 481 
 482 /**
 483  * xmlNode:
 484  *
 485  * A node in an XML tree.
 486  */
 487 typedef struct _xmlNode xmlNode;
 488 typedef xmlNode *xmlNodePtr;
 489 struct _xmlNode {
 490     void           *_private;   /* application data */
 491     xmlElementType   type;  /* type number, must be second ! */
 492     const xmlChar   *name;      /* the name of the node, or the entity */
 493     struct _xmlNode *children;  /* parent-&gt;childs link */
 494     struct _xmlNode *last;  /* last child link */
 495     struct _xmlNode *parent;    /* child-&gt;parent link */
 496     struct _xmlNode *next;  /* next sibling link  */
 497     struct _xmlNode *prev;  /* previous sibling link  */
 498     struct _xmlDoc  *doc;   /* the containing document */
 499 
 500     /* End of common part */
 501     xmlNs           *ns;        /* pointer to the associated namespace */
 502     xmlChar         *content;   /* the content */
 503     struct _xmlAttr *properties;/* properties list */
 504     xmlNs           *nsDef;     /* namespace definitions on this node */
 505     void            *psvi;  /* for type/PSVI informations */
 506     unsigned short   line;  /* line number */
 507     unsigned short   extra; /* extra data for XPath/XSLT */
 508 };
 509 
 510 /**
 511  * XML_GET_CONTENT:
 512  *
 513  * Macro to extract the content pointer of a node.
 514  */
 515 #define XML_GET_CONTENT(n)                  \
 516     ((n)-&gt;type == XML_ELEMENT_NODE ? NULL : (n)-&gt;content)
 517 
 518 /**
 519  * XML_GET_LINE:
 520  *
 521  * Macro to extract the line number of an element node.
 522  */
 523 #define XML_GET_LINE(n)                     \
 524     (xmlGetLineNo(n))
 525 
 526 /**
 527  * xmlDocProperty
 528  *
 529  * Set of properties of the document as found by the parser
<a name="1" id="anc1"></a><span class="line-modified"> 530  * Some of them are linked to similarly named xmlParserOption</span>
 531  */
 532 typedef enum {
 533     XML_DOC_WELLFORMED      = 1&lt;&lt;0, /* document is XML well formed */
 534     XML_DOC_NSVALID     = 1&lt;&lt;1, /* document is Namespace valid */
 535     XML_DOC_OLD10       = 1&lt;&lt;2, /* parsed with old XML-1.0 parser */
 536     XML_DOC_DTDVALID        = 1&lt;&lt;3, /* DTD validation was successful */
 537     XML_DOC_XINCLUDE        = 1&lt;&lt;4, /* XInclude substitution was done */
 538     XML_DOC_USERBUILT       = 1&lt;&lt;5, /* Document was built using the API
 539                                            and not by parsing an instance */
 540     XML_DOC_INTERNAL        = 1&lt;&lt;6, /* built for internal processing */
 541     XML_DOC_HTML        = 1&lt;&lt;7  /* parsed or built HTML document */
 542 } xmlDocProperties;
 543 
 544 /**
 545  * xmlDoc:
 546  *
 547  * An XML document.
 548  */
 549 typedef struct _xmlDoc xmlDoc;
 550 typedef xmlDoc *xmlDocPtr;
 551 struct _xmlDoc {
 552     void           *_private;   /* application data */
 553     xmlElementType  type;       /* XML_DOCUMENT_NODE, must be second ! */
 554     char           *name;   /* name/filename/URI of the document */
 555     struct _xmlNode *children;  /* the document tree */
 556     struct _xmlNode *last;  /* last child link */
 557     struct _xmlNode *parent;    /* child-&gt;parent link */
 558     struct _xmlNode *next;  /* next sibling link  */
 559     struct _xmlNode *prev;  /* previous sibling link  */
 560     struct _xmlDoc  *doc;   /* autoreference to itself */
 561 
 562     /* End of common part */
 563     int             compression;/* level of zlib compression */
 564     int             standalone; /* standalone document (no external refs)
 565                      1 if standalone=&quot;yes&quot;
 566                      0 if standalone=&quot;no&quot;
 567                     -1 if there is no XML declaration
 568                     -2 if there is an XML declaration, but no
 569                     standalone attribute was specified */
 570     struct _xmlDtd  *intSubset; /* the document internal subset */
 571     struct _xmlDtd  *extSubset; /* the document external subset */
 572     struct _xmlNs   *oldNs; /* Global namespace, the old way */
 573     const xmlChar  *version;    /* the XML version string */
 574     const xmlChar  *encoding;   /* external initial encoding, if any */
 575     void           *ids;        /* Hash table for ID attributes if any */
 576     void           *refs;       /* Hash table for IDREFs attributes if any */
 577     const xmlChar  *URL;    /* The URI for that document */
 578     int             charset;    /* Internal flag for charset handling,
 579                    actually an xmlCharEncoding */
 580     struct _xmlDict *dict;      /* dict used to allocate names or NULL */
 581     void           *psvi;   /* for type/PSVI informations */
 582     int             parseFlags; /* set of xmlParserOption used to parse the
 583                    document */
 584     int             properties; /* set of xmlDocProperties for this document
 585                    set at the end of parsing */
 586 };
 587 
 588 
 589 typedef struct _xmlDOMWrapCtxt xmlDOMWrapCtxt;
 590 typedef xmlDOMWrapCtxt *xmlDOMWrapCtxtPtr;
 591 
 592 /**
 593  * xmlDOMWrapAcquireNsFunction:
 594  * @ctxt:  a DOM wrapper context
 595  * @node:  the context node (element or attribute)
 596  * @nsName:  the requested namespace name
 597  * @nsPrefix:  the requested namespace prefix
 598  *
 599  * A function called to acquire namespaces (xmlNs) from the wrapper.
 600  *
 601  * Returns an xmlNsPtr or NULL in case of an error.
 602  */
 603 typedef xmlNsPtr (*xmlDOMWrapAcquireNsFunction) (xmlDOMWrapCtxtPtr ctxt,
 604                          xmlNodePtr node,
 605                          const xmlChar *nsName,
 606                          const xmlChar *nsPrefix);
 607 
 608 /**
 609  * xmlDOMWrapCtxt:
 610  *
 611  * Context for DOM wrapper-operations.
 612  */
 613 struct _xmlDOMWrapCtxt {
 614     void * _private;
 615     /*
 616     * The type of this context, just in case we need specialized
 617     * contexts in the future.
 618     */
 619     int type;
 620     /*
 621     * Internal namespace map used for various operations.
 622     */
 623     void * namespaceMap;
 624     /*
 625     * Use this one to acquire an xmlNsPtr intended for node-&gt;ns.
 626     * (Note that this is not intended for elem-&gt;nsDef).
 627     */
 628     xmlDOMWrapAcquireNsFunction getNsForNodeFunc;
 629 };
 630 
 631 /**
 632  * xmlChildrenNode:
 633  *
 634  * Macro for compatibility naming layer with libxml1. Maps
 635  * to &quot;children.&quot;
 636  */
 637 #ifndef xmlChildrenNode
 638 #define xmlChildrenNode children
 639 #endif
 640 
 641 /**
 642  * xmlRootNode:
 643  *
 644  * Macro for compatibility naming layer with libxml1. Maps
 645  * to &quot;children&quot;.
 646  */
 647 #ifndef xmlRootNode
 648 #define xmlRootNode children
 649 #endif
 650 
 651 /*
 652  * Variables.
 653  */
 654 
 655 /*
 656  * Some helper functions
 657  */
 658 #if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) || \
 659     defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_DEBUG_ENABLED) || \
 660     defined (LIBXML_HTML_ENABLED) || defined(LIBXML_SAX1_ENABLED) || \
 661     defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || \
 662     defined(LIBXML_DOCB_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
 663 XMLPUBFUN int XMLCALL
 664         xmlValidateNCName   (const xmlChar *value,
 665                      int space);
 666 #endif
 667 
 668 #if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
 669 XMLPUBFUN int XMLCALL
 670         xmlValidateQName    (const xmlChar *value,
 671                      int space);
 672 XMLPUBFUN int XMLCALL
 673         xmlValidateName     (const xmlChar *value,
 674                      int space);
 675 XMLPUBFUN int XMLCALL
 676         xmlValidateNMToken  (const xmlChar *value,
 677                      int space);
 678 #endif
 679 
 680 XMLPUBFUN xmlChar * XMLCALL
 681         xmlBuildQName       (const xmlChar *ncname,
 682                      const xmlChar *prefix,
 683                      xmlChar *memory,
 684                      int len);
 685 XMLPUBFUN xmlChar * XMLCALL
 686         xmlSplitQName2      (const xmlChar *name,
 687                      xmlChar **prefix);
 688 XMLPUBFUN const xmlChar * XMLCALL
 689         xmlSplitQName3      (const xmlChar *name,
 690                      int *len);
 691 
 692 /*
 693  * Handling Buffers, the old ones see @xmlBuf for the new ones.
 694  */
 695 
 696 XMLPUBFUN void XMLCALL
 697         xmlSetBufferAllocationScheme(xmlBufferAllocationScheme scheme);
 698 XMLPUBFUN xmlBufferAllocationScheme XMLCALL
 699         xmlGetBufferAllocationScheme(void);
 700 
 701 XMLPUBFUN xmlBufferPtr XMLCALL
 702         xmlBufferCreate     (void);
 703 XMLPUBFUN xmlBufferPtr XMLCALL
 704         xmlBufferCreateSize (size_t size);
 705 XMLPUBFUN xmlBufferPtr XMLCALL
 706         xmlBufferCreateStatic   (void *mem,
 707                      size_t size);
 708 XMLPUBFUN int XMLCALL
 709         xmlBufferResize     (xmlBufferPtr buf,
 710                      unsigned int size);
 711 XMLPUBFUN void XMLCALL
 712         xmlBufferFree       (xmlBufferPtr buf);
 713 XMLPUBFUN int XMLCALL
 714         xmlBufferDump       (FILE *file,
 715                      xmlBufferPtr buf);
 716 XMLPUBFUN int XMLCALL
 717         xmlBufferAdd        (xmlBufferPtr buf,
 718                      const xmlChar *str,
 719                      int len);
 720 XMLPUBFUN int XMLCALL
 721         xmlBufferAddHead    (xmlBufferPtr buf,
 722                      const xmlChar *str,
 723                      int len);
 724 XMLPUBFUN int XMLCALL
 725         xmlBufferCat        (xmlBufferPtr buf,
 726                      const xmlChar *str);
 727 XMLPUBFUN int XMLCALL
 728         xmlBufferCCat       (xmlBufferPtr buf,
 729                      const char *str);
 730 XMLPUBFUN int XMLCALL
 731         xmlBufferShrink     (xmlBufferPtr buf,
 732                      unsigned int len);
 733 XMLPUBFUN int XMLCALL
 734         xmlBufferGrow       (xmlBufferPtr buf,
 735                      unsigned int len);
 736 XMLPUBFUN void XMLCALL
 737         xmlBufferEmpty      (xmlBufferPtr buf);
 738 XMLPUBFUN const xmlChar* XMLCALL
 739         xmlBufferContent    (const xmlBuffer *buf);
 740 XMLPUBFUN xmlChar* XMLCALL
 741         xmlBufferDetach         (xmlBufferPtr buf);
 742 XMLPUBFUN void XMLCALL
 743         xmlBufferSetAllocationScheme(xmlBufferPtr buf,
 744                      xmlBufferAllocationScheme scheme);
 745 XMLPUBFUN int XMLCALL
 746         xmlBufferLength     (const xmlBuffer *buf);
 747 
 748 /*
 749  * Creating/freeing new structures.
 750  */
 751 XMLPUBFUN xmlDtdPtr XMLCALL
 752         xmlCreateIntSubset  (xmlDocPtr doc,
 753                      const xmlChar *name,
 754                      const xmlChar *ExternalID,
 755                      const xmlChar *SystemID);
 756 XMLPUBFUN xmlDtdPtr XMLCALL
 757         xmlNewDtd       (xmlDocPtr doc,
 758                      const xmlChar *name,
 759                      const xmlChar *ExternalID,
 760                      const xmlChar *SystemID);
 761 XMLPUBFUN xmlDtdPtr XMLCALL
 762         xmlGetIntSubset     (const xmlDoc *doc);
 763 XMLPUBFUN void XMLCALL
 764         xmlFreeDtd      (xmlDtdPtr cur);
 765 #ifdef LIBXML_LEGACY_ENABLED
 766 XMLPUBFUN xmlNsPtr XMLCALL
 767         xmlNewGlobalNs      (xmlDocPtr doc,
 768                      const xmlChar *href,
 769                      const xmlChar *prefix);
 770 #endif /* LIBXML_LEGACY_ENABLED */
 771 XMLPUBFUN xmlNsPtr XMLCALL
 772         xmlNewNs        (xmlNodePtr node,
 773                      const xmlChar *href,
 774                      const xmlChar *prefix);
 775 XMLPUBFUN void XMLCALL
 776         xmlFreeNs       (xmlNsPtr cur);
 777 XMLPUBFUN void XMLCALL
 778         xmlFreeNsList       (xmlNsPtr cur);
 779 XMLPUBFUN xmlDocPtr XMLCALL
 780         xmlNewDoc       (const xmlChar *version);
 781 XMLPUBFUN void XMLCALL
 782         xmlFreeDoc      (xmlDocPtr cur);
 783 XMLPUBFUN xmlAttrPtr XMLCALL
 784         xmlNewDocProp       (xmlDocPtr doc,
 785                      const xmlChar *name,
 786                      const xmlChar *value);
 787 #if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || \
 788     defined(LIBXML_SCHEMAS_ENABLED)
 789 XMLPUBFUN xmlAttrPtr XMLCALL
 790         xmlNewProp      (xmlNodePtr node,
 791                      const xmlChar *name,
 792                      const xmlChar *value);
 793 #endif
 794 XMLPUBFUN xmlAttrPtr XMLCALL
 795         xmlNewNsProp        (xmlNodePtr node,
 796                      xmlNsPtr ns,
 797                      const xmlChar *name,
 798                      const xmlChar *value);
 799 XMLPUBFUN xmlAttrPtr XMLCALL
 800         xmlNewNsPropEatName (xmlNodePtr node,
 801                      xmlNsPtr ns,
 802                      xmlChar *name,
 803                      const xmlChar *value);
 804 XMLPUBFUN void XMLCALL
 805         xmlFreePropList     (xmlAttrPtr cur);
 806 XMLPUBFUN void XMLCALL
 807         xmlFreeProp     (xmlAttrPtr cur);
 808 XMLPUBFUN xmlAttrPtr XMLCALL
 809         xmlCopyProp     (xmlNodePtr target,
 810                      xmlAttrPtr cur);
 811 XMLPUBFUN xmlAttrPtr XMLCALL
 812         xmlCopyPropList     (xmlNodePtr target,
 813                      xmlAttrPtr cur);
 814 #ifdef LIBXML_TREE_ENABLED
 815 XMLPUBFUN xmlDtdPtr XMLCALL
 816         xmlCopyDtd      (xmlDtdPtr dtd);
 817 #endif /* LIBXML_TREE_ENABLED */
 818 #if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
 819 XMLPUBFUN xmlDocPtr XMLCALL
 820         xmlCopyDoc      (xmlDocPtr doc,
 821                      int recursive);
 822 #endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
 823 /*
 824  * Creating new nodes.
 825  */
 826 XMLPUBFUN xmlNodePtr XMLCALL
 827         xmlNewDocNode       (xmlDocPtr doc,
 828                      xmlNsPtr ns,
 829                      const xmlChar *name,
 830                      const xmlChar *content);
 831 XMLPUBFUN xmlNodePtr XMLCALL
 832         xmlNewDocNodeEatName    (xmlDocPtr doc,
 833                      xmlNsPtr ns,
 834                      xmlChar *name,
 835                      const xmlChar *content);
 836 XMLPUBFUN xmlNodePtr XMLCALL
 837         xmlNewNode      (xmlNsPtr ns,
 838                      const xmlChar *name);
 839 XMLPUBFUN xmlNodePtr XMLCALL
 840         xmlNewNodeEatName   (xmlNsPtr ns,
 841                      xmlChar *name);
 842 #if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
 843 XMLPUBFUN xmlNodePtr XMLCALL
 844         xmlNewChild     (xmlNodePtr parent,
 845                      xmlNsPtr ns,
 846                      const xmlChar *name,
 847                      const xmlChar *content);
 848 #endif
 849 XMLPUBFUN xmlNodePtr XMLCALL
 850         xmlNewDocText       (const xmlDoc *doc,
 851                      const xmlChar *content);
 852 XMLPUBFUN xmlNodePtr XMLCALL
 853         xmlNewText      (const xmlChar *content);
 854 XMLPUBFUN xmlNodePtr XMLCALL
 855         xmlNewDocPI     (xmlDocPtr doc,
 856                      const xmlChar *name,
 857                      const xmlChar *content);
 858 XMLPUBFUN xmlNodePtr XMLCALL
 859         xmlNewPI        (const xmlChar *name,
 860                      const xmlChar *content);
 861 XMLPUBFUN xmlNodePtr XMLCALL
 862         xmlNewDocTextLen    (xmlDocPtr doc,
 863                      const xmlChar *content,
 864                      int len);
 865 XMLPUBFUN xmlNodePtr XMLCALL
 866         xmlNewTextLen       (const xmlChar *content,
 867                      int len);
 868 XMLPUBFUN xmlNodePtr XMLCALL
 869         xmlNewDocComment    (xmlDocPtr doc,
 870                      const xmlChar *content);
 871 XMLPUBFUN xmlNodePtr XMLCALL
 872         xmlNewComment       (const xmlChar *content);
 873 XMLPUBFUN xmlNodePtr XMLCALL
 874         xmlNewCDataBlock    (xmlDocPtr doc,
 875                      const xmlChar *content,
 876                      int len);
 877 XMLPUBFUN xmlNodePtr XMLCALL
 878         xmlNewCharRef       (xmlDocPtr doc,
 879                      const xmlChar *name);
 880 XMLPUBFUN xmlNodePtr XMLCALL
 881         xmlNewReference     (const xmlDoc *doc,
 882                      const xmlChar *name);
 883 XMLPUBFUN xmlNodePtr XMLCALL
 884         xmlCopyNode     (xmlNodePtr node,
 885                      int recursive);
 886 XMLPUBFUN xmlNodePtr XMLCALL
 887         xmlDocCopyNode      (xmlNodePtr node,
 888                      xmlDocPtr doc,
 889                      int recursive);
 890 XMLPUBFUN xmlNodePtr XMLCALL
 891         xmlDocCopyNodeList  (xmlDocPtr doc,
 892                      xmlNodePtr node);
 893 XMLPUBFUN xmlNodePtr XMLCALL
 894         xmlCopyNodeList     (xmlNodePtr node);
 895 #ifdef LIBXML_TREE_ENABLED
 896 XMLPUBFUN xmlNodePtr XMLCALL
 897         xmlNewTextChild     (xmlNodePtr parent,
 898                      xmlNsPtr ns,
 899                      const xmlChar *name,
 900                      const xmlChar *content);
 901 XMLPUBFUN xmlNodePtr XMLCALL
 902         xmlNewDocRawNode    (xmlDocPtr doc,
 903                      xmlNsPtr ns,
 904                      const xmlChar *name,
 905                      const xmlChar *content);
 906 XMLPUBFUN xmlNodePtr XMLCALL
 907         xmlNewDocFragment   (xmlDocPtr doc);
 908 #endif /* LIBXML_TREE_ENABLED */
 909 
 910 /*
 911  * Navigating.
 912  */
 913 XMLPUBFUN long XMLCALL
 914         xmlGetLineNo        (const xmlNode *node);
 915 #if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED)
 916 XMLPUBFUN xmlChar * XMLCALL
 917         xmlGetNodePath      (const xmlNode *node);
 918 #endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED) */
 919 XMLPUBFUN xmlNodePtr XMLCALL
 920         xmlDocGetRootElement    (const xmlDoc *doc);
 921 XMLPUBFUN xmlNodePtr XMLCALL
 922         xmlGetLastChild     (const xmlNode *parent);
 923 XMLPUBFUN int XMLCALL
 924         xmlNodeIsText       (const xmlNode *node);
 925 XMLPUBFUN int XMLCALL
 926         xmlIsBlankNode      (const xmlNode *node);
 927 
 928 /*
 929  * Changing the structure.
 930  */
 931 #if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)
 932 XMLPUBFUN xmlNodePtr XMLCALL
 933         xmlDocSetRootElement    (xmlDocPtr doc,
 934                      xmlNodePtr root);
 935 #endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED) */
 936 #ifdef LIBXML_TREE_ENABLED
 937 XMLPUBFUN void XMLCALL
 938         xmlNodeSetName      (xmlNodePtr cur,
 939                      const xmlChar *name);
 940 #endif /* LIBXML_TREE_ENABLED */
 941 XMLPUBFUN xmlNodePtr XMLCALL
 942         xmlAddChild     (xmlNodePtr parent,
 943                      xmlNodePtr cur);
 944 XMLPUBFUN xmlNodePtr XMLCALL
 945         xmlAddChildList     (xmlNodePtr parent,
 946                      xmlNodePtr cur);
 947 #if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)
 948 XMLPUBFUN xmlNodePtr XMLCALL
 949         xmlReplaceNode      (xmlNodePtr old,
 950                      xmlNodePtr cur);
 951 #endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED) */
 952 #if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || \
 953     defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED)
 954 XMLPUBFUN xmlNodePtr XMLCALL
 955         xmlAddPrevSibling   (xmlNodePtr cur,
 956                      xmlNodePtr elem);
 957 #endif /* LIBXML_TREE_ENABLED || LIBXML_HTML_ENABLED || LIBXML_SCHEMAS_ENABLED */
 958 XMLPUBFUN xmlNodePtr XMLCALL
 959         xmlAddSibling       (xmlNodePtr cur,
 960                      xmlNodePtr elem);
 961 XMLPUBFUN xmlNodePtr XMLCALL
 962         xmlAddNextSibling   (xmlNodePtr cur,
 963                      xmlNodePtr elem);
 964 XMLPUBFUN void XMLCALL
 965         xmlUnlinkNode       (xmlNodePtr cur);
 966 XMLPUBFUN xmlNodePtr XMLCALL
 967         xmlTextMerge        (xmlNodePtr first,
 968                      xmlNodePtr second);
 969 XMLPUBFUN int XMLCALL
 970         xmlTextConcat       (xmlNodePtr node,
 971                      const xmlChar *content,
 972                      int len);
 973 XMLPUBFUN void XMLCALL
 974         xmlFreeNodeList     (xmlNodePtr cur);
 975 XMLPUBFUN void XMLCALL
 976         xmlFreeNode     (xmlNodePtr cur);
 977 XMLPUBFUN void XMLCALL
 978         xmlSetTreeDoc       (xmlNodePtr tree,
 979                      xmlDocPtr doc);
 980 XMLPUBFUN void XMLCALL
 981         xmlSetListDoc       (xmlNodePtr list,
 982                      xmlDocPtr doc);
 983 /*
 984  * Namespaces.
 985  */
 986 XMLPUBFUN xmlNsPtr XMLCALL
 987         xmlSearchNs     (xmlDocPtr doc,
 988                      xmlNodePtr node,
 989                      const xmlChar *nameSpace);
 990 XMLPUBFUN xmlNsPtr XMLCALL
 991         xmlSearchNsByHref   (xmlDocPtr doc,
 992                      xmlNodePtr node,
 993                      const xmlChar *href);
 994 #if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) || \
 995     defined(LIBXML_SCHEMAS_ENABLED)
 996 XMLPUBFUN xmlNsPtr * XMLCALL
 997         xmlGetNsList        (const xmlDoc *doc,
 998                      const xmlNode *node);
 999 #endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) */
1000 
1001 XMLPUBFUN void XMLCALL
1002         xmlSetNs        (xmlNodePtr node,
1003                      xmlNsPtr ns);
1004 XMLPUBFUN xmlNsPtr XMLCALL
1005         xmlCopyNamespace    (xmlNsPtr cur);
1006 XMLPUBFUN xmlNsPtr XMLCALL
1007         xmlCopyNamespaceList    (xmlNsPtr cur);
1008 
1009 /*
1010  * Changing the content.
1011  */
1012 #if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || \
1013     defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED)
1014 XMLPUBFUN xmlAttrPtr XMLCALL
1015         xmlSetProp      (xmlNodePtr node,
1016                      const xmlChar *name,
1017                      const xmlChar *value);
1018 XMLPUBFUN xmlAttrPtr XMLCALL
1019         xmlSetNsProp        (xmlNodePtr node,
1020                      xmlNsPtr ns,
1021                      const xmlChar *name,
1022                      const xmlChar *value);
1023 #endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || \
1024       defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED) */
1025 XMLPUBFUN xmlChar * XMLCALL
1026         xmlGetNoNsProp      (const xmlNode *node,
1027                      const xmlChar *name);
1028 XMLPUBFUN xmlChar * XMLCALL
1029         xmlGetProp      (const xmlNode *node,
1030                      const xmlChar *name);
1031 XMLPUBFUN xmlAttrPtr XMLCALL
1032         xmlHasProp      (const xmlNode *node,
1033                      const xmlChar *name);
1034 XMLPUBFUN xmlAttrPtr XMLCALL
1035         xmlHasNsProp        (const xmlNode *node,
1036                      const xmlChar *name,
1037                      const xmlChar *nameSpace);
1038 XMLPUBFUN xmlChar * XMLCALL
1039         xmlGetNsProp        (const xmlNode *node,
1040                      const xmlChar *name,
1041                      const xmlChar *nameSpace);
1042 XMLPUBFUN xmlNodePtr XMLCALL
1043         xmlStringGetNodeList    (const xmlDoc *doc,
1044                      const xmlChar *value);
1045 XMLPUBFUN xmlNodePtr XMLCALL
1046         xmlStringLenGetNodeList (const xmlDoc *doc,
1047                      const xmlChar *value,
1048                      int len);
1049 XMLPUBFUN xmlChar * XMLCALL
1050         xmlNodeListGetString    (xmlDocPtr doc,
1051                      const xmlNode *list,
1052                      int inLine);
1053 #ifdef LIBXML_TREE_ENABLED
1054 XMLPUBFUN xmlChar * XMLCALL
1055         xmlNodeListGetRawString (const xmlDoc *doc,
1056                      const xmlNode *list,
1057                      int inLine);
1058 #endif /* LIBXML_TREE_ENABLED */
1059 XMLPUBFUN void XMLCALL
1060         xmlNodeSetContent   (xmlNodePtr cur,
1061                      const xmlChar *content);
1062 #ifdef LIBXML_TREE_ENABLED
1063 XMLPUBFUN void XMLCALL
1064         xmlNodeSetContentLen    (xmlNodePtr cur,
1065                      const xmlChar *content,
1066                      int len);
1067 #endif /* LIBXML_TREE_ENABLED */
1068 XMLPUBFUN void XMLCALL
1069         xmlNodeAddContent   (xmlNodePtr cur,
1070                      const xmlChar *content);
1071 XMLPUBFUN void XMLCALL
1072         xmlNodeAddContentLen    (xmlNodePtr cur,
1073                      const xmlChar *content,
1074                      int len);
1075 XMLPUBFUN xmlChar * XMLCALL
1076         xmlNodeGetContent   (const xmlNode *cur);
1077 
1078 XMLPUBFUN int XMLCALL
1079         xmlNodeBufGetContent    (xmlBufferPtr buffer,
1080                      const xmlNode *cur);
1081 XMLPUBFUN int XMLCALL
1082         xmlBufGetNodeContent    (xmlBufPtr buf,
1083                      const xmlNode *cur);
1084 
1085 XMLPUBFUN xmlChar * XMLCALL
1086         xmlNodeGetLang      (const xmlNode *cur);
1087 XMLPUBFUN int XMLCALL
1088         xmlNodeGetSpacePreserve (const xmlNode *cur);
1089 #ifdef LIBXML_TREE_ENABLED
1090 XMLPUBFUN void XMLCALL
1091         xmlNodeSetLang      (xmlNodePtr cur,
1092                      const xmlChar *lang);
1093 XMLPUBFUN void XMLCALL
1094         xmlNodeSetSpacePreserve (xmlNodePtr cur,
1095                      int val);
1096 #endif /* LIBXML_TREE_ENABLED */
1097 XMLPUBFUN xmlChar * XMLCALL
1098         xmlNodeGetBase      (const xmlDoc *doc,
1099                      const xmlNode *cur);
1100 #if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED)
1101 XMLPUBFUN void XMLCALL
1102         xmlNodeSetBase      (xmlNodePtr cur,
1103                      const xmlChar *uri);
1104 #endif
1105 
1106 /*
1107  * Removing content.
1108  */
1109 XMLPUBFUN int XMLCALL
1110         xmlRemoveProp       (xmlAttrPtr cur);
1111 #if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
1112 XMLPUBFUN int XMLCALL
1113         xmlUnsetNsProp      (xmlNodePtr node,
1114                      xmlNsPtr ns,
1115                      const xmlChar *name);
1116 XMLPUBFUN int XMLCALL
1117         xmlUnsetProp        (xmlNodePtr node,
1118                      const xmlChar *name);
1119 #endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
1120 
1121 /*
1122  * Internal, don&#39;t use.
1123  */
1124 XMLPUBFUN void XMLCALL
1125         xmlBufferWriteCHAR  (xmlBufferPtr buf,
1126                      const xmlChar *string);
1127 XMLPUBFUN void XMLCALL
1128         xmlBufferWriteChar  (xmlBufferPtr buf,
1129                      const char *string);
1130 XMLPUBFUN void XMLCALL
1131         xmlBufferWriteQuotedString(xmlBufferPtr buf,
1132                      const xmlChar *string);
1133 
1134 #ifdef LIBXML_OUTPUT_ENABLED
1135 XMLPUBFUN void xmlAttrSerializeTxtContent(xmlBufferPtr buf,
1136                      xmlDocPtr doc,
1137                      xmlAttrPtr attr,
1138                      const xmlChar *string);
1139 #endif /* LIBXML_OUTPUT_ENABLED */
1140 
1141 #ifdef LIBXML_TREE_ENABLED
1142 /*
1143  * Namespace handling.
1144  */
1145 XMLPUBFUN int XMLCALL
1146         xmlReconciliateNs   (xmlDocPtr doc,
1147                      xmlNodePtr tree);
1148 #endif
1149 
1150 #ifdef LIBXML_OUTPUT_ENABLED
1151 /*
1152  * Saving.
1153  */
1154 XMLPUBFUN void XMLCALL
1155         xmlDocDumpFormatMemory  (xmlDocPtr cur,
1156                      xmlChar **mem,
1157                      int *size,
1158                      int format);
1159 XMLPUBFUN void XMLCALL
1160         xmlDocDumpMemory    (xmlDocPtr cur,
1161                      xmlChar **mem,
1162                      int *size);
1163 XMLPUBFUN void XMLCALL
1164         xmlDocDumpMemoryEnc (xmlDocPtr out_doc,
1165                      xmlChar **doc_txt_ptr,
1166                      int * doc_txt_len,
1167                      const char *txt_encoding);
1168 XMLPUBFUN void XMLCALL
1169         xmlDocDumpFormatMemoryEnc(xmlDocPtr out_doc,
1170                      xmlChar **doc_txt_ptr,
1171                      int * doc_txt_len,
1172                      const char *txt_encoding,
1173                      int format);
1174 XMLPUBFUN int XMLCALL
1175         xmlDocFormatDump    (FILE *f,
1176                      xmlDocPtr cur,
1177                      int format);
1178 XMLPUBFUN int XMLCALL
1179         xmlDocDump      (FILE *f,
1180                      xmlDocPtr cur);
1181 XMLPUBFUN void XMLCALL
1182         xmlElemDump     (FILE *f,
1183                      xmlDocPtr doc,
1184                      xmlNodePtr cur);
1185 XMLPUBFUN int XMLCALL
1186         xmlSaveFile     (const char *filename,
1187                      xmlDocPtr cur);
1188 XMLPUBFUN int XMLCALL
1189         xmlSaveFormatFile   (const char *filename,
1190                      xmlDocPtr cur,
1191                      int format);
1192 XMLPUBFUN size_t XMLCALL
1193         xmlBufNodeDump      (xmlBufPtr buf,
1194                      xmlDocPtr doc,
1195                      xmlNodePtr cur,
1196                      int level,
1197                      int format);
1198 XMLPUBFUN int XMLCALL
1199         xmlNodeDump     (xmlBufferPtr buf,
1200                      xmlDocPtr doc,
1201                      xmlNodePtr cur,
1202                      int level,
1203                      int format);
1204 
1205 XMLPUBFUN int XMLCALL
1206         xmlSaveFileTo       (xmlOutputBufferPtr buf,
1207                      xmlDocPtr cur,
1208                      const char *encoding);
1209 XMLPUBFUN int XMLCALL
1210         xmlSaveFormatFileTo     (xmlOutputBufferPtr buf,
1211                      xmlDocPtr cur,
1212                          const char *encoding,
1213                          int format);
1214 XMLPUBFUN void XMLCALL
1215         xmlNodeDumpOutput   (xmlOutputBufferPtr buf,
1216                      xmlDocPtr doc,
1217                      xmlNodePtr cur,
1218                      int level,
1219                      int format,
1220                      const char *encoding);
1221 
1222 XMLPUBFUN int XMLCALL
1223         xmlSaveFormatFileEnc    (const char *filename,
1224                      xmlDocPtr cur,
1225                      const char *encoding,
1226                      int format);
1227 
1228 XMLPUBFUN int XMLCALL
1229         xmlSaveFileEnc      (const char *filename,
1230                      xmlDocPtr cur,
1231                      const char *encoding);
1232 
1233 #endif /* LIBXML_OUTPUT_ENABLED */
1234 /*
1235  * XHTML
1236  */
1237 XMLPUBFUN int XMLCALL
1238         xmlIsXHTML      (const xmlChar *systemID,
1239                      const xmlChar *publicID);
1240 
1241 /*
1242  * Compression.
1243  */
1244 XMLPUBFUN int XMLCALL
1245         xmlGetDocCompressMode   (const xmlDoc *doc);
1246 XMLPUBFUN void XMLCALL
1247         xmlSetDocCompressMode   (xmlDocPtr doc,
1248                      int mode);
1249 XMLPUBFUN int XMLCALL
1250         xmlGetCompressMode  (void);
1251 XMLPUBFUN void XMLCALL
1252         xmlSetCompressMode  (int mode);
1253 
1254 /*
1255 * DOM-wrapper helper functions.
1256 */
1257 XMLPUBFUN xmlDOMWrapCtxtPtr XMLCALL
1258         xmlDOMWrapNewCtxt   (void);
1259 XMLPUBFUN void XMLCALL
1260         xmlDOMWrapFreeCtxt  (xmlDOMWrapCtxtPtr ctxt);
1261 XMLPUBFUN int XMLCALL
1262         xmlDOMWrapReconcileNamespaces(xmlDOMWrapCtxtPtr ctxt,
1263                      xmlNodePtr elem,
1264                      int options);
1265 XMLPUBFUN int XMLCALL
1266         xmlDOMWrapAdoptNode     (xmlDOMWrapCtxtPtr ctxt,
1267                      xmlDocPtr sourceDoc,
1268                      xmlNodePtr node,
1269                      xmlDocPtr destDoc,
1270                      xmlNodePtr destParent,
1271                      int options);
1272 XMLPUBFUN int XMLCALL
1273         xmlDOMWrapRemoveNode    (xmlDOMWrapCtxtPtr ctxt,
1274                      xmlDocPtr doc,
1275                      xmlNodePtr node,
1276                      int options);
1277 XMLPUBFUN int XMLCALL
1278         xmlDOMWrapCloneNode     (xmlDOMWrapCtxtPtr ctxt,
1279                      xmlDocPtr sourceDoc,
1280                      xmlNodePtr node,
1281                      xmlNodePtr *clonedNode,
1282                      xmlDocPtr destDoc,
1283                      xmlNodePtr destParent,
1284                      int deep,
1285                      int options);
1286 
1287 #ifdef LIBXML_TREE_ENABLED
1288 /*
1289  * 5 interfaces from DOM ElementTraversal, but different in entities
1290  * traversal.
1291  */
1292 XMLPUBFUN unsigned long XMLCALL
1293             xmlChildElementCount        (xmlNodePtr parent);
1294 XMLPUBFUN xmlNodePtr XMLCALL
1295             xmlNextElementSibling       (xmlNodePtr node);
1296 XMLPUBFUN xmlNodePtr XMLCALL
1297             xmlFirstElementChild        (xmlNodePtr parent);
1298 XMLPUBFUN xmlNodePtr XMLCALL
1299             xmlLastElementChild         (xmlNodePtr parent);
1300 XMLPUBFUN xmlNodePtr XMLCALL
1301             xmlPreviousElementSibling   (xmlNodePtr node);
1302 #endif
1303 #ifdef __cplusplus
1304 }
1305 #endif
1306 #ifndef __XML_PARSER_H__
1307 #include &lt;libxml/xmlmemory.h&gt;
1308 #endif
1309 
1310 #endif /* __XML_TREE_H__ */
1311 
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
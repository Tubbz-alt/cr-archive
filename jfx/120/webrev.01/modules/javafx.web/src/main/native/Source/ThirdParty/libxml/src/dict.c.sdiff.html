<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/dict.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="configure.ac.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="elfgcchack.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/dict.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  21 
  22 #include &lt;limits.h&gt;
  23 #ifdef HAVE_STDLIB_H
  24 #include &lt;stdlib.h&gt;
  25 #endif
  26 #ifdef HAVE_TIME_H
  27 #include &lt;time.h&gt;
  28 #endif
  29 
  30 /*
  31  * Following http://www.ocert.org/advisories/ocert-2011-003.html
  32  * it seems that having hash randomization might be a good idea
  33  * when using XML with untrusted data
  34  * Note1: that it works correctly only if compiled with WITH_BIG_KEY
  35  *  which is the default.
  36  * Note2: the fast function used for a small dict won&#39;t protect very
  37  *  well but since the attack is based on growing a very big hash
  38  *  list we will use the BigKey algo as soon as the hash size grows
  39  *  over MIN_DICT_SIZE so this actually works
  40  */
<span class="line-modified">  41 #if defined(HAVE_RAND) &amp;&amp; defined(HAVE_SRAND) &amp;&amp; defined(HAVE_TIME)</span>

  42 #define DICT_RANDOMIZATION
  43 #endif
  44 
  45 #include &lt;string.h&gt;
  46 #ifdef HAVE_STDINT_H
  47 #include &lt;stdint.h&gt;
  48 #else
  49 #ifdef HAVE_INTTYPES_H
  50 #include &lt;inttypes.h&gt;
  51 #elif defined(_WIN32)
  52 typedef unsigned __int32 uint32_t;
  53 #endif
  54 #endif
  55 #include &lt;libxml/tree.h&gt;
  56 #include &lt;libxml/dict.h&gt;
  57 #include &lt;libxml/xmlmemory.h&gt;
  58 #include &lt;libxml/xmlerror.h&gt;
  59 #include &lt;libxml/globals.h&gt;
  60 
  61 /* #define DEBUG_GROW */
</pre>
<hr />
<pre>
 354     pool-&gt;free += plen;
 355     *(pool-&gt;free++) = &#39;:&#39;;
 356     memcpy(pool-&gt;free, name, namelen);
 357     pool-&gt;free += namelen;
 358     *(pool-&gt;free++) = 0;
 359     pool-&gt;nbStrings++;
 360     return(ret);
 361 }
 362 
 363 #ifdef WITH_BIG_KEY
 364 /*
 365  * xmlDictComputeBigKey:
 366  *
 367  * Calculate a hash key using a good hash function that works well for
 368  * larger hash table sizes.
 369  *
 370  * Hash function by &quot;One-at-a-Time Hash&quot; see
 371  * http://burtleburtle.net/bob/hash/doobs.html
 372  */
 373 



 374 static uint32_t
 375 xmlDictComputeBigKey(const xmlChar* data, int namelen, int seed) {
 376     uint32_t hash;
 377     int i;
 378 
 379     if (namelen &lt;= 0 || data == NULL) return(0);
 380 
 381     hash = seed;
 382 
 383     for (i = 0;i &lt; namelen; i++) {
 384         hash += data[i];
 385     hash += (hash &lt;&lt; 10);
 386     hash ^= (hash &gt;&gt; 6);
 387     }
 388     hash += (hash &lt;&lt; 3);
 389     hash ^= (hash &gt;&gt; 11);
 390     hash += (hash &lt;&lt; 15);
 391 
 392     return hash;
 393 }
 394 
 395 /*
 396  * xmlDictComputeBigQKey:
 397  *
 398  * Calculate a hash key for two strings using a good hash function
 399  * that works well for larger hash table sizes.
 400  *
 401  * Hash function by &quot;One-at-a-Time Hash&quot; see
 402  * http://burtleburtle.net/bob/hash/doobs.html
 403  *
 404  * Neither of the two strings must be NULL.
 405  */



 406 static unsigned long
 407 xmlDictComputeBigQKey(const xmlChar *prefix, int plen,
 408                       const xmlChar *name, int len, int seed)
 409 {
 410     uint32_t hash;
 411     int i;
 412 
 413     hash = seed;
 414 
 415     for (i = 0;i &lt; plen; i++) {
 416         hash += prefix[i];
 417     hash += (hash &lt;&lt; 10);
 418     hash ^= (hash &gt;&gt; 6);
 419     }
 420     hash += &#39;:&#39;;
 421     hash += (hash &lt;&lt; 10);
 422     hash ^= (hash &gt;&gt; 6);
 423 
 424     for (i = 0;i &lt; len; i++) {
 425         hash += name[i];
</pre>
<hr />
<pre>
 710         okey = xmlDictComputeKey(dict, olddict[i].name, olddict[i].len);
 711     key = okey % dict-&gt;size;
 712 
 713     if (dict-&gt;dict[key].valid == 0) {
 714         memcpy(&amp;(dict-&gt;dict[key]), &amp;(olddict[i]), sizeof(xmlDictEntry));
 715         dict-&gt;dict[key].next = NULL;
 716         dict-&gt;dict[key].okey = okey;
 717     } else {
 718         xmlDictEntryPtr entry;
 719 
 720         entry = xmlMalloc(sizeof(xmlDictEntry));
 721         if (entry != NULL) {
 722         entry-&gt;name = olddict[i].name;
 723         entry-&gt;len = olddict[i].len;
 724         entry-&gt;okey = okey;
 725         entry-&gt;next = dict-&gt;dict[key].next;
 726         entry-&gt;valid = 1;
 727         dict-&gt;dict[key].next = entry;
 728         } else {
 729             /*
<span class="line-modified"> 730          * we don&#39;t have much ways to alert from herei</span>
 731          * result is losing an entry and unicity guarantee
 732          */
 733             ret = -1;
 734         }
 735     }
 736 #ifdef DEBUG_GROW
 737     nbElem++;
 738 #endif
 739     }
 740 
 741     for (i = 0; i &lt; oldsize; i++) {
 742     iter = olddict[i].next;
 743     while (iter) {
 744         next = iter-&gt;next;
 745 
 746         /*
 747          * put back the entry in the new dict
 748          */
 749 
 750         if (keep_keys)
</pre>
<hr />
<pre>
1185     entry-&gt;okey = okey;
1186 
1187     if (insert != NULL)
1188     insert-&gt;next = entry;
1189 
1190     dict-&gt;nbElems++;
1191 
1192     if ((nbi &gt; MAX_HASH_LEN) &amp;&amp;
1193         (dict-&gt;size &lt;= ((MAX_DICT_HASH / 2) / MAX_HASH_LEN)))
1194     xmlDictGrow(dict, MAX_HASH_LEN * 2 * dict-&gt;size);
1195     /* Note that entry may have been freed at this point by xmlDictGrow */
1196 
1197     return(ret);
1198 }
1199 
1200 /**
1201  * xmlDictOwns:
1202  * @dict: the dictionary
1203  * @str: the string
1204  *
<span class="line-modified">1205  * check if a string is owned by the disctionary</span>
1206  *
1207  * Returns 1 if true, 0 if false and -1 in case of error
1208  * -1 in case of error
1209  */
1210 int
1211 xmlDictOwns(xmlDictPtr dict, const xmlChar *str) {
1212     xmlDictStringsPtr pool;
1213 
1214     if ((dict == NULL) || (str == NULL))
1215     return(-1);
1216     pool = dict-&gt;strings;
1217     while (pool != NULL) {
1218         if ((str &gt;= &amp;pool-&gt;array[0]) &amp;&amp; (str &lt;= pool-&gt;free))
1219         return(1);
1220     pool = pool-&gt;next;
1221     }
1222     if (dict-&gt;subdict)
1223         return(xmlDictOwns(dict-&gt;subdict, str));
1224     return(0);
1225 }
</pre>
</td>
<td>
<hr />
<pre>
  21 
  22 #include &lt;limits.h&gt;
  23 #ifdef HAVE_STDLIB_H
  24 #include &lt;stdlib.h&gt;
  25 #endif
  26 #ifdef HAVE_TIME_H
  27 #include &lt;time.h&gt;
  28 #endif
  29 
  30 /*
  31  * Following http://www.ocert.org/advisories/ocert-2011-003.html
  32  * it seems that having hash randomization might be a good idea
  33  * when using XML with untrusted data
  34  * Note1: that it works correctly only if compiled with WITH_BIG_KEY
  35  *  which is the default.
  36  * Note2: the fast function used for a small dict won&#39;t protect very
  37  *  well but since the attack is based on growing a very big hash
  38  *  list we will use the BigKey algo as soon as the hash size grows
  39  *  over MIN_DICT_SIZE so this actually works
  40  */
<span class="line-modified">  41 #if defined(HAVE_RAND) &amp;&amp; defined(HAVE_SRAND) &amp;&amp; defined(HAVE_TIME) &amp;&amp; \</span>
<span class="line-added">  42     !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)</span>
  43 #define DICT_RANDOMIZATION
  44 #endif
  45 
  46 #include &lt;string.h&gt;
  47 #ifdef HAVE_STDINT_H
  48 #include &lt;stdint.h&gt;
  49 #else
  50 #ifdef HAVE_INTTYPES_H
  51 #include &lt;inttypes.h&gt;
  52 #elif defined(_WIN32)
  53 typedef unsigned __int32 uint32_t;
  54 #endif
  55 #endif
  56 #include &lt;libxml/tree.h&gt;
  57 #include &lt;libxml/dict.h&gt;
  58 #include &lt;libxml/xmlmemory.h&gt;
  59 #include &lt;libxml/xmlerror.h&gt;
  60 #include &lt;libxml/globals.h&gt;
  61 
  62 /* #define DEBUG_GROW */
</pre>
<hr />
<pre>
 355     pool-&gt;free += plen;
 356     *(pool-&gt;free++) = &#39;:&#39;;
 357     memcpy(pool-&gt;free, name, namelen);
 358     pool-&gt;free += namelen;
 359     *(pool-&gt;free++) = 0;
 360     pool-&gt;nbStrings++;
 361     return(ret);
 362 }
 363 
 364 #ifdef WITH_BIG_KEY
 365 /*
 366  * xmlDictComputeBigKey:
 367  *
 368  * Calculate a hash key using a good hash function that works well for
 369  * larger hash table sizes.
 370  *
 371  * Hash function by &quot;One-at-a-Time Hash&quot; see
 372  * http://burtleburtle.net/bob/hash/doobs.html
 373  */
 374 
<span class="line-added"> 375 #ifdef __clang__</span>
<span class="line-added"> 376 ATTRIBUTE_NO_SANITIZE(&quot;unsigned-integer-overflow&quot;)</span>
<span class="line-added"> 377 #endif</span>
 378 static uint32_t
 379 xmlDictComputeBigKey(const xmlChar* data, int namelen, int seed) {
 380     uint32_t hash;
 381     int i;
 382 
 383     if (namelen &lt;= 0 || data == NULL) return(0);
 384 
 385     hash = seed;
 386 
 387     for (i = 0;i &lt; namelen; i++) {
 388         hash += data[i];
 389     hash += (hash &lt;&lt; 10);
 390     hash ^= (hash &gt;&gt; 6);
 391     }
 392     hash += (hash &lt;&lt; 3);
 393     hash ^= (hash &gt;&gt; 11);
 394     hash += (hash &lt;&lt; 15);
 395 
 396     return hash;
 397 }
 398 
 399 /*
 400  * xmlDictComputeBigQKey:
 401  *
 402  * Calculate a hash key for two strings using a good hash function
 403  * that works well for larger hash table sizes.
 404  *
 405  * Hash function by &quot;One-at-a-Time Hash&quot; see
 406  * http://burtleburtle.net/bob/hash/doobs.html
 407  *
 408  * Neither of the two strings must be NULL.
 409  */
<span class="line-added"> 410 #ifdef __clang__</span>
<span class="line-added"> 411 ATTRIBUTE_NO_SANITIZE(&quot;unsigned-integer-overflow&quot;)</span>
<span class="line-added"> 412 #endif</span>
 413 static unsigned long
 414 xmlDictComputeBigQKey(const xmlChar *prefix, int plen,
 415                       const xmlChar *name, int len, int seed)
 416 {
 417     uint32_t hash;
 418     int i;
 419 
 420     hash = seed;
 421 
 422     for (i = 0;i &lt; plen; i++) {
 423         hash += prefix[i];
 424     hash += (hash &lt;&lt; 10);
 425     hash ^= (hash &gt;&gt; 6);
 426     }
 427     hash += &#39;:&#39;;
 428     hash += (hash &lt;&lt; 10);
 429     hash ^= (hash &gt;&gt; 6);
 430 
 431     for (i = 0;i &lt; len; i++) {
 432         hash += name[i];
</pre>
<hr />
<pre>
 717         okey = xmlDictComputeKey(dict, olddict[i].name, olddict[i].len);
 718     key = okey % dict-&gt;size;
 719 
 720     if (dict-&gt;dict[key].valid == 0) {
 721         memcpy(&amp;(dict-&gt;dict[key]), &amp;(olddict[i]), sizeof(xmlDictEntry));
 722         dict-&gt;dict[key].next = NULL;
 723         dict-&gt;dict[key].okey = okey;
 724     } else {
 725         xmlDictEntryPtr entry;
 726 
 727         entry = xmlMalloc(sizeof(xmlDictEntry));
 728         if (entry != NULL) {
 729         entry-&gt;name = olddict[i].name;
 730         entry-&gt;len = olddict[i].len;
 731         entry-&gt;okey = okey;
 732         entry-&gt;next = dict-&gt;dict[key].next;
 733         entry-&gt;valid = 1;
 734         dict-&gt;dict[key].next = entry;
 735         } else {
 736             /*
<span class="line-modified"> 737          * we don&#39;t have much ways to alert from here</span>
 738          * result is losing an entry and unicity guarantee
 739          */
 740             ret = -1;
 741         }
 742     }
 743 #ifdef DEBUG_GROW
 744     nbElem++;
 745 #endif
 746     }
 747 
 748     for (i = 0; i &lt; oldsize; i++) {
 749     iter = olddict[i].next;
 750     while (iter) {
 751         next = iter-&gt;next;
 752 
 753         /*
 754          * put back the entry in the new dict
 755          */
 756 
 757         if (keep_keys)
</pre>
<hr />
<pre>
1192     entry-&gt;okey = okey;
1193 
1194     if (insert != NULL)
1195     insert-&gt;next = entry;
1196 
1197     dict-&gt;nbElems++;
1198 
1199     if ((nbi &gt; MAX_HASH_LEN) &amp;&amp;
1200         (dict-&gt;size &lt;= ((MAX_DICT_HASH / 2) / MAX_HASH_LEN)))
1201     xmlDictGrow(dict, MAX_HASH_LEN * 2 * dict-&gt;size);
1202     /* Note that entry may have been freed at this point by xmlDictGrow */
1203 
1204     return(ret);
1205 }
1206 
1207 /**
1208  * xmlDictOwns:
1209  * @dict: the dictionary
1210  * @str: the string
1211  *
<span class="line-modified">1212  * check if a string is owned by the dictionary</span>
1213  *
1214  * Returns 1 if true, 0 if false and -1 in case of error
1215  * -1 in case of error
1216  */
1217 int
1218 xmlDictOwns(xmlDictPtr dict, const xmlChar *str) {
1219     xmlDictStringsPtr pool;
1220 
1221     if ((dict == NULL) || (str == NULL))
1222     return(-1);
1223     pool = dict-&gt;strings;
1224     while (pool != NULL) {
1225         if ((str &gt;= &amp;pool-&gt;array[0]) &amp;&amp; (str &lt;= pool-&gt;free))
1226         return(1);
1227     pool = pool-&gt;next;
1228     }
1229     if (dict-&gt;subdict)
1230         return(xmlDictOwns(dict-&gt;subdict, str));
1231     return(0);
1232 }
</pre>
</td>
</tr>
</table>
<center><a href="configure.ac.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="elfgcchack.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
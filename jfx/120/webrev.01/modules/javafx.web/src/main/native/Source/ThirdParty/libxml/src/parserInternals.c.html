<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/ThirdParty/libxml/src/parserInternals.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * parserInternals.c : Internal routines (and obsolete ones) needed for the
   3  *                     XML and HTML parsers.
   4  *
   5  * See Copyright for the status of this software.
   6  *
   7  * daniel@veillard.com
   8  */
   9 
  10 #define IN_LIBXML
  11 #include &quot;libxml.h&quot;
  12 
  13 #if defined(_WIN32) &amp;&amp; !defined (__CYGWIN__)
  14 #define XML_DIR_SEP &#39;\\&#39;
  15 #else
  16 #define XML_DIR_SEP &#39;/&#39;
  17 #endif
  18 
  19 #include &lt;string.h&gt;
  20 #ifdef HAVE_CTYPE_H
  21 #include &lt;ctype.h&gt;
  22 #endif
  23 #ifdef HAVE_STDLIB_H
  24 #include &lt;stdlib.h&gt;
  25 #endif
  26 #ifdef HAVE_SYS_STAT_H
  27 #include &lt;sys/stat.h&gt;
  28 #endif
  29 #ifdef HAVE_FCNTL_H
  30 #include &lt;fcntl.h&gt;
  31 #endif
  32 #ifdef HAVE_UNISTD_H
  33 #include &lt;unistd.h&gt;
  34 #endif
  35 #ifdef LIBXML_ZLIB_ENABLED
  36 #include &lt;zlib.h&gt;
  37 #endif
  38 
  39 #include &lt;libxml/xmlmemory.h&gt;
  40 #include &lt;libxml/tree.h&gt;
  41 #include &lt;libxml/parser.h&gt;
  42 #include &lt;libxml/parserInternals.h&gt;
  43 #include &lt;libxml/valid.h&gt;
  44 #include &lt;libxml/entities.h&gt;
  45 #include &lt;libxml/xmlerror.h&gt;
  46 #include &lt;libxml/encoding.h&gt;
  47 #include &lt;libxml/valid.h&gt;
  48 #include &lt;libxml/xmlIO.h&gt;
  49 #include &lt;libxml/uri.h&gt;
  50 #include &lt;libxml/dict.h&gt;
  51 #include &lt;libxml/SAX.h&gt;
  52 #ifdef LIBXML_CATALOG_ENABLED
  53 #include &lt;libxml/catalog.h&gt;
  54 #endif
  55 #include &lt;libxml/globals.h&gt;
  56 #include &lt;libxml/chvalid.h&gt;
  57 
  58 #define CUR(ctxt) ctxt-&gt;input-&gt;cur
  59 #define END(ctxt) ctxt-&gt;input-&gt;end
  60 #define VALID_CTXT(ctxt) (CUR(ctxt) &lt;= END(ctxt))
  61 
  62 #include &quot;buf.h&quot;
  63 #include &quot;enc.h&quot;
  64 
  65 /*
  66  * Various global defaults for parsing
  67  */
  68 
  69 /**
  70  * xmlCheckVersion:
  71  * @version: the include version number
  72  *
  73  * check the compiled lib version against the include one.
  74  * This can warn or immediately kill the application
  75  */
  76 void
  77 xmlCheckVersion(int version) {
  78     int myversion = (int) LIBXML_VERSION;
  79 
  80     xmlInitParser();
  81 
  82     if ((myversion / 10000) != (version / 10000)) {
  83     xmlGenericError(xmlGenericErrorContext,
  84         &quot;Fatal: program compiled against libxml %d using libxml %d\n&quot;,
  85         (version / 10000), (myversion / 10000));
  86     fprintf(stderr,
  87         &quot;Fatal: program compiled against libxml %d using libxml %d\n&quot;,
  88         (version / 10000), (myversion / 10000));
  89     }
  90     if ((myversion / 100) &lt; (version / 100)) {
  91     xmlGenericError(xmlGenericErrorContext,
  92         &quot;Warning: program compiled against libxml %d using older %d\n&quot;,
  93         (version / 100), (myversion / 100));
  94     }
  95 }
  96 
  97 
  98 /************************************************************************
  99  *                                  *
 100  *      Some factorized error routines              *
 101  *                                  *
 102  ************************************************************************/
 103 
 104 
 105 /**
 106  * xmlErrMemory:
 107  * @ctxt:  an XML parser context
 108  * @extra:  extra informations
 109  *
 110  * Handle a redefinition of attribute error
 111  */
 112 void
 113 xmlErrMemory(xmlParserCtxtPtr ctxt, const char *extra)
 114 {
 115     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
 116         (ctxt-&gt;instate == XML_PARSER_EOF))
 117     return;
 118     if (ctxt != NULL) {
 119         ctxt-&gt;errNo = XML_ERR_NO_MEMORY;
 120         ctxt-&gt;instate = XML_PARSER_EOF;
 121         ctxt-&gt;disableSAX = 1;
 122     }
 123     if (extra)
 124         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,
 125                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, extra,
 126                         NULL, NULL, 0, 0,
 127                         &quot;Memory allocation failed : %s\n&quot;, extra);
 128     else
 129         __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,
 130                         XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, NULL,
 131                         NULL, NULL, 0, 0, &quot;Memory allocation failed\n&quot;);
 132 }
 133 
 134 /**
 135  * __xmlErrEncoding:
 136  * @ctxt:  an XML parser context
 137  * @xmlerr:  the error number
 138  * @msg:  the error message
 139  * @str1:  an string info
 140  * @str2:  an string info
 141  *
 142  * Handle an encoding error
 143  */
 144 void
 145 __xmlErrEncoding(xmlParserCtxtPtr ctxt, xmlParserErrors xmlerr,
 146                  const char *msg, const xmlChar * str1, const xmlChar * str2)
 147 {
 148     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
 149         (ctxt-&gt;instate == XML_PARSER_EOF))
 150     return;
 151     if (ctxt != NULL)
 152         ctxt-&gt;errNo = xmlerr;
 153     __xmlRaiseError(NULL, NULL, NULL,
 154                     ctxt, NULL, XML_FROM_PARSER, xmlerr, XML_ERR_FATAL,
 155                     NULL, 0, (const char *) str1, (const char *) str2,
 156                     NULL, 0, 0, msg, str1, str2);
 157     if (ctxt != NULL) {
 158         ctxt-&gt;wellFormed = 0;
 159         if (ctxt-&gt;recovery == 0)
 160             ctxt-&gt;disableSAX = 1;
 161     }
 162 }
 163 
 164 /**
 165  * xmlErrInternal:
 166  * @ctxt:  an XML parser context
 167  * @msg:  the error message
 168  * @str:  error informations
 169  *
 170  * Handle an internal error
 171  */
 172 static void LIBXML_ATTR_FORMAT(2,0)
 173 xmlErrInternal(xmlParserCtxtPtr ctxt, const char *msg, const xmlChar * str)
 174 {
 175     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
 176         (ctxt-&gt;instate == XML_PARSER_EOF))
 177     return;
 178     if (ctxt != NULL)
 179         ctxt-&gt;errNo = XML_ERR_INTERNAL_ERROR;
 180     __xmlRaiseError(NULL, NULL, NULL,
 181                     ctxt, NULL, XML_FROM_PARSER, XML_ERR_INTERNAL_ERROR,
 182                     XML_ERR_FATAL, NULL, 0, (const char *) str, NULL, NULL,
 183                     0, 0, msg, str);
 184     if (ctxt != NULL) {
 185         ctxt-&gt;wellFormed = 0;
 186         if (ctxt-&gt;recovery == 0)
 187             ctxt-&gt;disableSAX = 1;
 188     }
 189 }
 190 
 191 /**
 192  * xmlErrEncodingInt:
 193  * @ctxt:  an XML parser context
 194  * @error:  the error number
 195  * @msg:  the error message
 196  * @val:  an integer value
 197  *
 198  * n encoding error
 199  */
 200 static void LIBXML_ATTR_FORMAT(3,0)
 201 xmlErrEncodingInt(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 202                   const char *msg, int val)
 203 {
 204     if ((ctxt != NULL) &amp;&amp; (ctxt-&gt;disableSAX != 0) &amp;&amp;
 205         (ctxt-&gt;instate == XML_PARSER_EOF))
 206     return;
 207     if (ctxt != NULL)
 208         ctxt-&gt;errNo = error;
 209     __xmlRaiseError(NULL, NULL, NULL,
 210                     ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
 211                     NULL, 0, NULL, NULL, NULL, val, 0, msg, val);
 212     if (ctxt != NULL) {
 213         ctxt-&gt;wellFormed = 0;
 214         if (ctxt-&gt;recovery == 0)
 215             ctxt-&gt;disableSAX = 1;
 216     }
 217 }
 218 
 219 /**
 220  * xmlIsLetter:
 221  * @c:  an unicode character (int)
 222  *
 223  * Check whether the character is allowed by the production
 224  * [84] Letter ::= BaseChar | Ideographic
 225  *
 226  * Returns 0 if not, non-zero otherwise
 227  */
 228 int
 229 xmlIsLetter(int c) {
 230     return(IS_BASECHAR(c) || IS_IDEOGRAPHIC(c));
 231 }
 232 
 233 /************************************************************************
 234  *                                  *
 235  *      Input handling functions for progressive parsing    *
 236  *                                  *
 237  ************************************************************************/
 238 
 239 /* #define DEBUG_INPUT */
 240 /* #define DEBUG_STACK */
 241 /* #define DEBUG_PUSH */
 242 
 243 
 244 /* we need to keep enough input to show errors in context */
 245 #define LINE_LEN        80
 246 
 247 #ifdef DEBUG_INPUT
 248 #define CHECK_BUFFER(in) check_buffer(in)
 249 
 250 static
 251 void check_buffer(xmlParserInputPtr in) {
 252     if (in-&gt;base != xmlBufContent(in-&gt;buf-&gt;buffer)) {
 253         xmlGenericError(xmlGenericErrorContext,
 254         &quot;xmlParserInput: base mismatch problem\n&quot;);
 255     }
 256     if (in-&gt;cur &lt; in-&gt;base) {
 257         xmlGenericError(xmlGenericErrorContext,
 258         &quot;xmlParserInput: cur &lt; base problem\n&quot;);
 259     }
 260     if (in-&gt;cur &gt; in-&gt;base + xmlBufUse(in-&gt;buf-&gt;buffer)) {
 261         xmlGenericError(xmlGenericErrorContext,
 262         &quot;xmlParserInput: cur &gt; base + use problem\n&quot;);
 263     }
 264     xmlGenericError(xmlGenericErrorContext,&quot;buffer %x : content %x, cur %d, use %d\n&quot;,
 265             (int) in, (int) xmlBufContent(in-&gt;buf-&gt;buffer), in-&gt;cur - in-&gt;base,
 266         xmlBufUse(in-&gt;buf-&gt;buffer));
 267 }
 268 
 269 #else
 270 #define CHECK_BUFFER(in)
 271 #endif
 272 
 273 
 274 /**
 275  * xmlParserInputRead:
 276  * @in:  an XML parser input
 277  * @len:  an indicative size for the lookahead
 278  *
 279  * This function was internal and is deprecated.
 280  *
 281  * Returns -1 as this is an error to use it.
 282  */
 283 int
 284 xmlParserInputRead(xmlParserInputPtr in ATTRIBUTE_UNUSED, int len ATTRIBUTE_UNUSED) {
 285     return(-1);
 286 }
 287 
 288 /**
 289  * xmlParserInputGrow:
 290  * @in:  an XML parser input
 291  * @len:  an indicative size for the lookahead
 292  *
 293  * This function increase the input for the parser. It tries to
 294  * preserve pointers to the input buffer, and keep already read data
 295  *
 296  * Returns the amount of char read, or -1 in case of error, 0 indicate the
 297  * end of this entity
 298  */
 299 int
 300 xmlParserInputGrow(xmlParserInputPtr in, int len) {
 301     int ret;
 302     size_t indx;
 303     const xmlChar *content;
 304 
 305     if ((in == NULL) || (len &lt; 0)) return(-1);
 306 #ifdef DEBUG_INPUT
 307     xmlGenericError(xmlGenericErrorContext, &quot;Grow\n&quot;);
 308 #endif
 309     if (in-&gt;buf == NULL) return(-1);
 310     if (in-&gt;base == NULL) return(-1);
 311     if (in-&gt;cur == NULL) return(-1);
 312     if (in-&gt;buf-&gt;buffer == NULL) return(-1);
 313 
 314     CHECK_BUFFER(in);
 315 
 316     indx = in-&gt;cur - in-&gt;base;
 317     if (xmlBufUse(in-&gt;buf-&gt;buffer) &gt; (unsigned int) indx + INPUT_CHUNK) {
 318 
 319     CHECK_BUFFER(in);
 320 
 321         return(0);
 322     }
 323     if (in-&gt;buf-&gt;readcallback != NULL) {
 324     ret = xmlParserInputBufferGrow(in-&gt;buf, len);
 325     } else
 326         return(0);
 327 
 328     /*
 329      * NOTE : in-&gt;base may be a &quot;dangling&quot; i.e. freed pointer in this
 330      *        block, but we use it really as an integer to do some
 331      *        pointer arithmetic. Insure will raise it as a bug but in
 332      *        that specific case, that&#39;s not !
 333      */
 334 
 335     content = xmlBufContent(in-&gt;buf-&gt;buffer);
 336     if (in-&gt;base != content) {
 337         /*
 338      * the buffer has been reallocated
 339      */
 340     indx = in-&gt;cur - in-&gt;base;
 341     in-&gt;base = content;
 342     in-&gt;cur = &amp;content[indx];
 343     }
 344     in-&gt;end = xmlBufEnd(in-&gt;buf-&gt;buffer);
 345 
 346     CHECK_BUFFER(in);
 347 
 348     return(ret);
 349 }
 350 
 351 /**
 352  * xmlParserInputShrink:
 353  * @in:  an XML parser input
 354  *
 355  * This function removes used input for the parser.
 356  */
 357 void
 358 xmlParserInputShrink(xmlParserInputPtr in) {
 359     size_t used;
 360     size_t ret;
 361     size_t indx;
 362     const xmlChar *content;
 363 
 364 #ifdef DEBUG_INPUT
 365     xmlGenericError(xmlGenericErrorContext, &quot;Shrink\n&quot;);
 366 #endif
 367     if (in == NULL) return;
 368     if (in-&gt;buf == NULL) return;
 369     if (in-&gt;base == NULL) return;
 370     if (in-&gt;cur == NULL) return;
 371     if (in-&gt;buf-&gt;buffer == NULL) return;
 372 
 373     CHECK_BUFFER(in);
 374 
 375     used = in-&gt;cur - xmlBufContent(in-&gt;buf-&gt;buffer);
 376     /*
 377      * Do not shrink on large buffers whose only a tiny fraction
 378      * was consumed
 379      */
 380     if (used &gt; INPUT_CHUNK) {
 381     ret = xmlBufShrink(in-&gt;buf-&gt;buffer, used - LINE_LEN);
 382     if (ret &gt; 0) {
 383         in-&gt;cur -= ret;
 384         in-&gt;consumed += ret;
 385     }
 386     in-&gt;end = xmlBufEnd(in-&gt;buf-&gt;buffer);
 387     }
 388 
 389     CHECK_BUFFER(in);
 390 
 391     if (xmlBufUse(in-&gt;buf-&gt;buffer) &gt; INPUT_CHUNK) {
 392         return;
 393     }
 394     xmlParserInputBufferRead(in-&gt;buf, 2 * INPUT_CHUNK);
 395     content = xmlBufContent(in-&gt;buf-&gt;buffer);
 396     if (in-&gt;base != content) {
 397         /*
 398      * the buffer has been reallocated
 399      */
 400     indx = in-&gt;cur - in-&gt;base;
 401     in-&gt;base = content;
 402     in-&gt;cur = &amp;content[indx];
 403     }
 404     in-&gt;end = xmlBufEnd(in-&gt;buf-&gt;buffer);
 405 
 406     CHECK_BUFFER(in);
 407 }
 408 
 409 /************************************************************************
 410  *                                  *
 411  *      UTF8 character input and related functions      *
 412  *                                  *
 413  ************************************************************************/
 414 
 415 /**
 416  * xmlNextChar:
 417  * @ctxt:  the XML parser context
 418  *
 419  * Skip to the next char input char.
 420  */
 421 
 422 void
 423 xmlNextChar(xmlParserCtxtPtr ctxt)
 424 {
 425     if ((ctxt == NULL) || (ctxt-&gt;instate == XML_PARSER_EOF) ||
 426         (ctxt-&gt;input == NULL))
 427         return;
 428 
 429     if (!(VALID_CTXT(ctxt))) {
 430         xmlErrInternal(ctxt, &quot;Parser input data memory error\n&quot;, NULL);
 431     ctxt-&gt;errNo = XML_ERR_INTERNAL_ERROR;
 432         xmlStopParser(ctxt);
 433     return;
 434     }
 435 
 436     if ((*ctxt-&gt;input-&gt;cur == 0) &amp;&amp;
 437         (xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK) &lt;= 0)) {
 438         return;
 439     }
 440 
 441     if (ctxt-&gt;charset == XML_CHAR_ENCODING_UTF8) {
 442         const unsigned char *cur;
 443         unsigned char c;
 444 
 445         /*
 446          *   2.11 End-of-Line Handling
 447          *   the literal two-character sequence &quot;#xD#xA&quot; or a standalone
 448          *   literal #xD, an XML processor must pass to the application
 449          *   the single character #xA.
 450          */
 451         if (*(ctxt-&gt;input-&gt;cur) == &#39;\n&#39;) {
 452             ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;
 453         } else
 454             ctxt-&gt;input-&gt;col++;
 455 
 456         /*
 457          * We are supposed to handle UTF8, check it&#39;s valid
 458          * From rfc2044: encoding of the Unicode values on UTF-8:
 459          *
 460          * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
 461          * 0000 0000-0000 007F   0xxxxxxx
 462          * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
 463          * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
 464          *
 465          * Check for the 0x110000 limit too
 466          */
 467         cur = ctxt-&gt;input-&gt;cur;
 468 
 469         c = *cur;
 470         if (c &amp; 0x80) {
 471             if (c == 0xC0)
 472             goto encoding_error;
 473             if (cur[1] == 0) {
 474                 xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 475                 cur = ctxt-&gt;input-&gt;cur;
 476             }
 477             if ((cur[1] &amp; 0xc0) != 0x80)
 478                 goto encoding_error;
 479             if ((c &amp; 0xe0) == 0xe0) {
 480                 unsigned int val;
 481 
 482                 if (cur[2] == 0) {
 483                     xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 484                     cur = ctxt-&gt;input-&gt;cur;
 485                 }
 486                 if ((cur[2] &amp; 0xc0) != 0x80)
 487                     goto encoding_error;
 488                 if ((c &amp; 0xf0) == 0xf0) {
 489                     if (cur[3] == 0) {
 490                         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 491                         cur = ctxt-&gt;input-&gt;cur;
 492                     }
 493                     if (((c &amp; 0xf8) != 0xf0) ||
 494                         ((cur[3] &amp; 0xc0) != 0x80))
 495                         goto encoding_error;
 496                     /* 4-byte code */
 497                     ctxt-&gt;input-&gt;cur += 4;
 498                     val = (cur[0] &amp; 0x7) &lt;&lt; 18;
 499                     val |= (cur[1] &amp; 0x3f) &lt;&lt; 12;
 500                     val |= (cur[2] &amp; 0x3f) &lt;&lt; 6;
 501                     val |= cur[3] &amp; 0x3f;
 502                 } else {
 503                     /* 3-byte code */
 504                     ctxt-&gt;input-&gt;cur += 3;
 505                     val = (cur[0] &amp; 0xf) &lt;&lt; 12;
 506                     val |= (cur[1] &amp; 0x3f) &lt;&lt; 6;
 507                     val |= cur[2] &amp; 0x3f;
 508                 }
 509                 if (((val &gt; 0xd7ff) &amp;&amp; (val &lt; 0xe000)) ||
 510                     ((val &gt; 0xfffd) &amp;&amp; (val &lt; 0x10000)) ||
 511                     (val &gt;= 0x110000)) {
 512         xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,
 513                   &quot;Char 0x%X out of allowed range\n&quot;,
 514                   val);
 515                 }
 516             } else
 517                 /* 2-byte code */
 518                 ctxt-&gt;input-&gt;cur += 2;
 519         } else
 520             /* 1-byte code */
 521             ctxt-&gt;input-&gt;cur++;
 522 
 523         ctxt-&gt;nbChars++;
 524     } else {
 525         /*
 526          * Assume it&#39;s a fixed length encoding (1) with
 527          * a compatible encoding for the ASCII set, since
 528          * XML constructs only use &lt; 128 chars
 529          */
 530 
 531         if (*(ctxt-&gt;input-&gt;cur) == &#39;\n&#39;) {
 532             ctxt-&gt;input-&gt;line++; ctxt-&gt;input-&gt;col = 1;
 533         } else
 534             ctxt-&gt;input-&gt;col++;
 535         ctxt-&gt;input-&gt;cur++;
 536         ctxt-&gt;nbChars++;
 537     }
 538     if (*ctxt-&gt;input-&gt;cur == 0)
 539         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 540     return;
 541 encoding_error:
 542     /*
 543      * If we detect an UTF8 error that probably mean that the
 544      * input encoding didn&#39;t get properly advertised in the
 545      * declaration header. Report the error and switch the encoding
 546      * to ISO-Latin-1 (if you don&#39;t like this policy, just declare the
 547      * encoding !)
 548      */
 549     if ((ctxt == NULL) || (ctxt-&gt;input == NULL) ||
 550         (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; 4)) {
 551     __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
 552              &quot;Input is not proper UTF-8, indicate encoding !\n&quot;,
 553              NULL, NULL);
 554     } else {
 555         char buffer[150];
 556 
 557     snprintf(buffer, 149, &quot;Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n&quot;,
 558             ctxt-&gt;input-&gt;cur[0], ctxt-&gt;input-&gt;cur[1],
 559             ctxt-&gt;input-&gt;cur[2], ctxt-&gt;input-&gt;cur[3]);
 560     __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
 561              &quot;Input is not proper UTF-8, indicate encoding !\n%s&quot;,
 562              BAD_CAST buffer, NULL);
 563     }
 564     ctxt-&gt;charset = XML_CHAR_ENCODING_8859_1;
 565     ctxt-&gt;input-&gt;cur++;
 566     return;
 567 }
 568 
 569 /**
 570  * xmlCurrentChar:
 571  * @ctxt:  the XML parser context
 572  * @len:  pointer to the length of the char read
 573  *
 574  * The current char value, if using UTF-8 this may actually span multiple
 575  * bytes in the input buffer. Implement the end of line normalization:
 576  * 2.11 End-of-Line Handling
 577  * Wherever an external parsed entity or the literal entity value
 578  * of an internal parsed entity contains either the literal two-character
 579  * sequence &quot;#xD#xA&quot; or a standalone literal #xD, an XML processor
 580  * must pass to the application the single character #xA.
 581  * This behavior can conveniently be produced by normalizing all
 582  * line breaks to #xA on input, before parsing.)
 583  *
 584  * Returns the current char value and its length
 585  */
 586 
 587 int
 588 xmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {
 589     if ((ctxt == NULL) || (len == NULL) || (ctxt-&gt;input == NULL)) return(0);
 590     if (ctxt-&gt;instate == XML_PARSER_EOF)
 591     return(0);
 592 
 593     if ((*ctxt-&gt;input-&gt;cur &gt;= 0x20) &amp;&amp; (*ctxt-&gt;input-&gt;cur &lt;= 0x7F)) {
 594         *len = 1;
 595         return((int) *ctxt-&gt;input-&gt;cur);
 596     }
 597     if (ctxt-&gt;charset == XML_CHAR_ENCODING_UTF8) {
 598     /*
 599      * We are supposed to handle UTF8, check it&#39;s valid
 600      * From rfc2044: encoding of the Unicode values on UTF-8:
 601      *
 602      * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
 603      * 0000 0000-0000 007F   0xxxxxxx
 604      * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
 605      * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
 606      *
 607      * Check for the 0x110000 limit too
 608      */
 609     const unsigned char *cur = ctxt-&gt;input-&gt;cur;
 610     unsigned char c;
 611     unsigned int val;
 612 
 613     c = *cur;
 614     if (c &amp; 0x80) {
 615         if (((c &amp; 0x40) == 0) || (c == 0xC0))
 616         goto encoding_error;
 617         if (cur[1] == 0) {
 618         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 619                 cur = ctxt-&gt;input-&gt;cur;
 620             }
 621         if ((cur[1] &amp; 0xc0) != 0x80)
 622         goto encoding_error;
 623         if ((c &amp; 0xe0) == 0xe0) {
 624         if (cur[2] == 0) {
 625             xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 626                     cur = ctxt-&gt;input-&gt;cur;
 627                 }
 628         if ((cur[2] &amp; 0xc0) != 0x80)
 629             goto encoding_error;
 630         if ((c &amp; 0xf0) == 0xf0) {
 631             if (cur[3] == 0) {
 632             xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 633                         cur = ctxt-&gt;input-&gt;cur;
 634                     }
 635             if (((c &amp; 0xf8) != 0xf0) ||
 636             ((cur[3] &amp; 0xc0) != 0x80))
 637             goto encoding_error;
 638             /* 4-byte code */
 639             *len = 4;
 640             val = (cur[0] &amp; 0x7) &lt;&lt; 18;
 641             val |= (cur[1] &amp; 0x3f) &lt;&lt; 12;
 642             val |= (cur[2] &amp; 0x3f) &lt;&lt; 6;
 643             val |= cur[3] &amp; 0x3f;
 644             if (val &lt; 0x10000)
 645             goto encoding_error;
 646         } else {
 647           /* 3-byte code */
 648             *len = 3;
 649             val = (cur[0] &amp; 0xf) &lt;&lt; 12;
 650             val |= (cur[1] &amp; 0x3f) &lt;&lt; 6;
 651             val |= cur[2] &amp; 0x3f;
 652             if (val &lt; 0x800)
 653             goto encoding_error;
 654         }
 655         } else {
 656           /* 2-byte code */
 657         *len = 2;
 658         val = (cur[0] &amp; 0x1f) &lt;&lt; 6;
 659         val |= cur[1] &amp; 0x3f;
 660         if (val &lt; 0x80)
 661             goto encoding_error;
 662         }
 663         if (!IS_CHAR(val)) {
 664             xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,
 665                   &quot;Char 0x%X out of allowed range\n&quot;, val);
 666         }
 667         return(val);
 668     } else {
 669         /* 1-byte code */
 670         *len = 1;
 671         if (*ctxt-&gt;input-&gt;cur == 0)
 672         xmlParserInputGrow(ctxt-&gt;input, INPUT_CHUNK);
 673         if ((*ctxt-&gt;input-&gt;cur == 0) &amp;&amp;
 674             (ctxt-&gt;input-&gt;end &gt; ctxt-&gt;input-&gt;cur)) {
 675             xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,
 676                   &quot;Char 0x0 out of allowed range\n&quot;, 0);
 677         }
 678         if (*ctxt-&gt;input-&gt;cur == 0xD) {
 679         if (ctxt-&gt;input-&gt;cur[1] == 0xA) {
 680             ctxt-&gt;nbChars++;
 681             ctxt-&gt;input-&gt;cur++;
 682         }
 683         return(0xA);
 684         }
 685         return((int) *ctxt-&gt;input-&gt;cur);
 686     }
 687     }
 688     /*
 689      * Assume it&#39;s a fixed length encoding (1) with
 690      * a compatible encoding for the ASCII set, since
 691      * XML constructs only use &lt; 128 chars
 692      */
 693     *len = 1;
 694     if (*ctxt-&gt;input-&gt;cur == 0xD) {
 695     if (ctxt-&gt;input-&gt;cur[1] == 0xA) {
 696         ctxt-&gt;nbChars++;
 697         ctxt-&gt;input-&gt;cur++;
 698     }
 699     return(0xA);
 700     }
 701     return((int) *ctxt-&gt;input-&gt;cur);
 702 encoding_error:
 703     /*
 704      * An encoding problem may arise from a truncated input buffer
 705      * splitting a character in the middle. In that case do not raise
 706      * an error but return 0 to indicate an end of stream problem
 707      */
 708     if (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; 4) {
 709     *len = 0;
 710     return(0);
 711     }
 712 
 713     /*
 714      * If we detect an UTF8 error that probably mean that the
 715      * input encoding didn&#39;t get properly advertised in the
 716      * declaration header. Report the error and switch the encoding
 717      * to ISO-Latin-1 (if you don&#39;t like this policy, just declare the
 718      * encoding !)
 719      */
 720     {
 721         char buffer[150];
 722 
 723     snprintf(&amp;buffer[0], 149, &quot;Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n&quot;,
 724             ctxt-&gt;input-&gt;cur[0], ctxt-&gt;input-&gt;cur[1],
 725             ctxt-&gt;input-&gt;cur[2], ctxt-&gt;input-&gt;cur[3]);
 726     __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
 727              &quot;Input is not proper UTF-8, indicate encoding !\n%s&quot;,
 728              BAD_CAST buffer, NULL);
 729     }
 730     ctxt-&gt;charset = XML_CHAR_ENCODING_8859_1;
 731     *len = 1;
 732     return((int) *ctxt-&gt;input-&gt;cur);
 733 }
 734 
 735 /**
 736  * xmlStringCurrentChar:
 737  * @ctxt:  the XML parser context
 738  * @cur:  pointer to the beginning of the char
 739  * @len:  pointer to the length of the char read
 740  *
 741  * The current char value, if using UTF-8 this may actually span multiple
 742  * bytes in the input buffer.
 743  *
 744  * Returns the current char value and its length
 745  */
 746 
 747 int
 748 xmlStringCurrentChar(xmlParserCtxtPtr ctxt, const xmlChar * cur, int *len)
 749 {
 750     if ((len == NULL) || (cur == NULL)) return(0);
 751     if ((ctxt == NULL) || (ctxt-&gt;charset == XML_CHAR_ENCODING_UTF8)) {
 752         /*
 753          * We are supposed to handle UTF8, check it&#39;s valid
 754          * From rfc2044: encoding of the Unicode values on UTF-8:
 755          *
 756          * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
 757          * 0000 0000-0000 007F   0xxxxxxx
 758          * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
 759          * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
 760          *
 761          * Check for the 0x110000 limit too
 762          */
 763         unsigned char c;
 764         unsigned int val;
 765 
 766         c = *cur;
 767         if (c &amp; 0x80) {
 768             if ((cur[1] &amp; 0xc0) != 0x80)
 769                 goto encoding_error;
 770             if ((c &amp; 0xe0) == 0xe0) {
 771 
 772                 if ((cur[2] &amp; 0xc0) != 0x80)
 773                     goto encoding_error;
 774                 if ((c &amp; 0xf0) == 0xf0) {
 775                     if (((c &amp; 0xf8) != 0xf0) || ((cur[3] &amp; 0xc0) != 0x80))
 776                         goto encoding_error;
 777                     /* 4-byte code */
 778                     *len = 4;
 779                     val = (cur[0] &amp; 0x7) &lt;&lt; 18;
 780                     val |= (cur[1] &amp; 0x3f) &lt;&lt; 12;
 781                     val |= (cur[2] &amp; 0x3f) &lt;&lt; 6;
 782                     val |= cur[3] &amp; 0x3f;
 783                 } else {
 784                     /* 3-byte code */
 785                     *len = 3;
 786                     val = (cur[0] &amp; 0xf) &lt;&lt; 12;
 787                     val |= (cur[1] &amp; 0x3f) &lt;&lt; 6;
 788                     val |= cur[2] &amp; 0x3f;
 789                 }
 790             } else {
 791                 /* 2-byte code */
 792                 *len = 2;
 793                 val = (cur[0] &amp; 0x1f) &lt;&lt; 6;
 794                 val |= cur[1] &amp; 0x3f;
 795             }
 796             if (!IS_CHAR(val)) {
 797             xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,
 798                   &quot;Char 0x%X out of allowed range\n&quot;, val);
 799             }
 800             return (val);
 801         } else {
 802             /* 1-byte code */
 803             *len = 1;
 804             return ((int) *cur);
 805         }
 806     }
 807     /*
 808      * Assume it&#39;s a fixed length encoding (1) with
 809      * a compatible encoding for the ASCII set, since
 810      * XML constructs only use &lt; 128 chars
 811      */
 812     *len = 1;
 813     return ((int) *cur);
 814 encoding_error:
 815 
 816     /*
 817      * An encoding problem may arise from a truncated input buffer
 818      * splitting a character in the middle. In that case do not raise
 819      * an error but return 0 to indicate an end of stream problem
 820      */
 821     if ((ctxt == NULL) || (ctxt-&gt;input == NULL) ||
 822         (ctxt-&gt;input-&gt;end - ctxt-&gt;input-&gt;cur &lt; 4)) {
 823     *len = 0;
 824     return(0);
 825     }
 826     /*
 827      * If we detect an UTF8 error that probably mean that the
 828      * input encoding didn&#39;t get properly advertised in the
 829      * declaration header. Report the error and switch the encoding
 830      * to ISO-Latin-1 (if you don&#39;t like this policy, just declare the
 831      * encoding !)
 832      */
 833     {
 834         char buffer[150];
 835 
 836     snprintf(buffer, 149, &quot;Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n&quot;,
 837             ctxt-&gt;input-&gt;cur[0], ctxt-&gt;input-&gt;cur[1],
 838             ctxt-&gt;input-&gt;cur[2], ctxt-&gt;input-&gt;cur[3]);
 839     __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
 840              &quot;Input is not proper UTF-8, indicate encoding !\n%s&quot;,
 841              BAD_CAST buffer, NULL);
 842     }
 843     *len = 1;
 844     return ((int) *cur);
 845 }
 846 
 847 /**
 848  * xmlCopyCharMultiByte:
 849  * @out:  pointer to an array of xmlChar
 850  * @val:  the char value
 851  *
 852  * append the char value in the array
 853  *
 854  * Returns the number of xmlChar written
 855  */
 856 int
 857 xmlCopyCharMultiByte(xmlChar *out, int val) {
 858     if (out == NULL) return(0);
 859     /*
 860      * We are supposed to handle UTF8, check it&#39;s valid
 861      * From rfc2044: encoding of the Unicode values on UTF-8:
 862      *
 863      * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
 864      * 0000 0000-0000 007F   0xxxxxxx
 865      * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
 866      * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
 867      */
 868     if  (val &gt;= 0x80) {
 869     xmlChar *savedout = out;
 870     int bits;
 871     if (val &lt;   0x800) { *out++= (val &gt;&gt;  6) | 0xC0;  bits=  0; }
 872     else if (val &lt; 0x10000) { *out++= (val &gt;&gt; 12) | 0xE0;  bits=  6;}
 873     else if (val &lt; 0x110000)  { *out++= (val &gt;&gt; 18) | 0xF0;  bits=  12; }
 874     else {
 875         xmlErrEncodingInt(NULL, XML_ERR_INVALID_CHAR,
 876             &quot;Internal error, xmlCopyCharMultiByte 0x%X out of bound\n&quot;,
 877                   val);
 878         return(0);
 879     }
 880     for ( ; bits &gt;= 0; bits-= 6)
 881         *out++= ((val &gt;&gt; bits) &amp; 0x3F) | 0x80 ;
 882     return (out - savedout);
 883     }
 884     *out = (xmlChar) val;
 885     return 1;
 886 }
 887 
 888 /**
 889  * xmlCopyChar:
 890  * @len:  Ignored, compatibility
 891  * @out:  pointer to an array of xmlChar
 892  * @val:  the char value
 893  *
 894  * append the char value in the array
 895  *
 896  * Returns the number of xmlChar written
 897  */
 898 
 899 int
 900 xmlCopyChar(int len ATTRIBUTE_UNUSED, xmlChar *out, int val) {
 901     if (out == NULL) return(0);
 902     /* the len parameter is ignored */
 903     if  (val &gt;= 0x80) {
 904     return(xmlCopyCharMultiByte (out, val));
 905     }
 906     *out = (xmlChar) val;
 907     return 1;
 908 }
 909 
 910 /************************************************************************
 911  *                                  *
 912  *      Commodity functions to switch encodings         *
 913  *                                  *
 914  ************************************************************************/
 915 
 916 static int
 917 xmlSwitchToEncodingInt(xmlParserCtxtPtr ctxt,
 918                        xmlCharEncodingHandlerPtr handler, int len);
 919 static int
 920 xmlSwitchInputEncodingInt(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,
 921                           xmlCharEncodingHandlerPtr handler, int len);
 922 /**
 923  * xmlSwitchEncoding:
 924  * @ctxt:  the parser context
 925  * @enc:  the encoding value (number)
 926  *
 927  * change the input functions when discovering the character encoding
 928  * of a given entity.
 929  *
 930  * Returns 0 in case of success, -1 otherwise
 931  */
 932 int
 933 xmlSwitchEncoding(xmlParserCtxtPtr ctxt, xmlCharEncoding enc)
 934 {
 935     xmlCharEncodingHandlerPtr handler;
 936     int len = -1;
 937     int ret;
 938 
 939     if (ctxt == NULL) return(-1);
 940     switch (enc) {
 941     case XML_CHAR_ENCODING_ERROR:
 942         __xmlErrEncoding(ctxt, XML_ERR_UNKNOWN_ENCODING,
 943                        &quot;encoding unknown\n&quot;, NULL, NULL);
 944         return(-1);
 945     case XML_CHAR_ENCODING_NONE:
 946         /* let&#39;s assume it&#39;s UTF-8 without the XML decl */
 947         ctxt-&gt;charset = XML_CHAR_ENCODING_UTF8;
 948         return(0);
 949     case XML_CHAR_ENCODING_UTF8:
 950         /* default encoding, no conversion should be needed */
 951         ctxt-&gt;charset = XML_CHAR_ENCODING_UTF8;
 952 
 953         /*
 954          * Errata on XML-1.0 June 20 2001
 955          * Specific handling of the Byte Order Mark for
 956          * UTF-8
 957          */
 958         if ((ctxt-&gt;input != NULL) &amp;&amp;
 959         (ctxt-&gt;input-&gt;cur[0] == 0xEF) &amp;&amp;
 960         (ctxt-&gt;input-&gt;cur[1] == 0xBB) &amp;&amp;
 961         (ctxt-&gt;input-&gt;cur[2] == 0xBF)) {
 962         ctxt-&gt;input-&gt;cur += 3;
 963         }
 964         return(0);
 965     case XML_CHAR_ENCODING_UTF16LE:
 966     case XML_CHAR_ENCODING_UTF16BE:
 967         /*The raw input characters are encoded
 968          *in UTF-16. As we expect this function
 969          *to be called after xmlCharEncInFunc, we expect
 970          *ctxt-&gt;input-&gt;cur to contain UTF-8 encoded characters.
 971          *So the raw UTF16 Byte Order Mark
 972          *has also been converted into
 973          *an UTF-8 BOM. Let&#39;s skip that BOM.
 974          */
 975         if ((ctxt-&gt;input != NULL) &amp;&amp; (ctxt-&gt;input-&gt;cur != NULL) &amp;&amp;
 976             (ctxt-&gt;input-&gt;cur[0] == 0xEF) &amp;&amp;
 977             (ctxt-&gt;input-&gt;cur[1] == 0xBB) &amp;&amp;
 978             (ctxt-&gt;input-&gt;cur[2] == 0xBF)) {
 979             ctxt-&gt;input-&gt;cur += 3;
 980         }
 981         len = 90;
 982     break;
 983     case XML_CHAR_ENCODING_UCS2:
 984         len = 90;
 985     break;
 986     case XML_CHAR_ENCODING_UCS4BE:
 987     case XML_CHAR_ENCODING_UCS4LE:
 988     case XML_CHAR_ENCODING_UCS4_2143:
 989     case XML_CHAR_ENCODING_UCS4_3412:
 990         len = 180;
 991     break;
 992     case XML_CHAR_ENCODING_EBCDIC:
 993     case XML_CHAR_ENCODING_8859_1:
 994     case XML_CHAR_ENCODING_8859_2:
 995     case XML_CHAR_ENCODING_8859_3:
 996     case XML_CHAR_ENCODING_8859_4:
 997     case XML_CHAR_ENCODING_8859_5:
 998     case XML_CHAR_ENCODING_8859_6:
 999     case XML_CHAR_ENCODING_8859_7:
1000     case XML_CHAR_ENCODING_8859_8:
1001     case XML_CHAR_ENCODING_8859_9:
1002     case XML_CHAR_ENCODING_ASCII:
1003     case XML_CHAR_ENCODING_2022_JP:
1004     case XML_CHAR_ENCODING_SHIFT_JIS:
1005     case XML_CHAR_ENCODING_EUC_JP:
1006         len = 45;
1007     break;
1008     }
1009     handler = xmlGetCharEncodingHandler(enc);
1010     if (handler == NULL) {
1011     /*
1012      * Default handlers.
1013      */
1014     switch (enc) {
1015         case XML_CHAR_ENCODING_ASCII:
1016         /* default encoding, no conversion should be needed */
1017         ctxt-&gt;charset = XML_CHAR_ENCODING_UTF8;
1018         return(0);
1019         case XML_CHAR_ENCODING_UTF16LE:
1020         break;
1021         case XML_CHAR_ENCODING_UTF16BE:
1022         break;
1023         case XML_CHAR_ENCODING_UCS4LE:
1024         __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
1025                    &quot;encoding not supported %s\n&quot;,
1026                    BAD_CAST &quot;USC4 little endian&quot;, NULL);
1027         break;
1028         case XML_CHAR_ENCODING_UCS4BE:
1029         __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
1030                    &quot;encoding not supported %s\n&quot;,
1031                    BAD_CAST &quot;USC4 big endian&quot;, NULL);
1032         break;
1033         case XML_CHAR_ENCODING_EBCDIC:
1034         __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
1035                    &quot;encoding not supported %s\n&quot;,
1036                    BAD_CAST &quot;EBCDIC&quot;, NULL);
1037         break;
1038         case XML_CHAR_ENCODING_UCS4_2143:
1039         __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
1040                    &quot;encoding not supported %s\n&quot;,
1041                    BAD_CAST &quot;UCS4 2143&quot;, NULL);
1042         break;
1043         case XML_CHAR_ENCODING_UCS4_3412:
1044         __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
1045                    &quot;encoding not supported %s\n&quot;,
1046                    BAD_CAST &quot;UCS4 3412&quot;, NULL);
1047         break;
1048         case XML_CHAR_ENCODING_UCS2:
1049         __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
1050                    &quot;encoding not supported %s\n&quot;,
1051                    BAD_CAST &quot;UCS2&quot;, NULL);
1052         break;
1053         case XML_CHAR_ENCODING_8859_1:
1054         case XML_CHAR_ENCODING_8859_2:
1055         case XML_CHAR_ENCODING_8859_3:
1056         case XML_CHAR_ENCODING_8859_4:
1057         case XML_CHAR_ENCODING_8859_5:
1058         case XML_CHAR_ENCODING_8859_6:
1059         case XML_CHAR_ENCODING_8859_7:
1060         case XML_CHAR_ENCODING_8859_8:
1061         case XML_CHAR_ENCODING_8859_9:
1062         /*
1063          * We used to keep the internal content in the
1064          * document encoding however this turns being unmaintainable
1065          * So xmlGetCharEncodingHandler() will return non-null
1066          * values for this now.
1067          */
1068         if ((ctxt-&gt;inputNr == 1) &amp;&amp;
1069             (ctxt-&gt;encoding == NULL) &amp;&amp;
1070             (ctxt-&gt;input != NULL) &amp;&amp;
1071             (ctxt-&gt;input-&gt;encoding != NULL)) {
1072             ctxt-&gt;encoding = xmlStrdup(ctxt-&gt;input-&gt;encoding);
1073         }
1074         ctxt-&gt;charset = enc;
1075         return(0);
1076         case XML_CHAR_ENCODING_2022_JP:
1077         __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
1078                    &quot;encoding not supported %s\n&quot;,
1079                    BAD_CAST &quot;ISO-2022-JP&quot;, NULL);
1080         break;
1081         case XML_CHAR_ENCODING_SHIFT_JIS:
1082         __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
1083                    &quot;encoding not supported %s\n&quot;,
1084                    BAD_CAST &quot;Shift_JIS&quot;, NULL);
1085         break;
1086         case XML_CHAR_ENCODING_EUC_JP:
1087         __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
1088                    &quot;encoding not supported %s\n&quot;,
1089                    BAD_CAST &quot;EUC-JP&quot;, NULL);
1090         break;
1091         default:
1092             break;
1093     }
1094     }
1095     /*
1096      * TODO: We could recover from errors in external entities if we
1097      * didn&#39;t stop the parser. But most callers of this function don&#39;t
1098      * check the return value.
1099      */
1100     if (handler == NULL) {
1101         xmlStopParser(ctxt);
1102     return(-1);
1103     }
1104     ctxt-&gt;charset = XML_CHAR_ENCODING_UTF8;
1105     ret = xmlSwitchToEncodingInt(ctxt, handler, len);
1106     if ((ret &lt; 0) || (ctxt-&gt;errNo == XML_I18N_CONV_FAILED)) {
1107         /*
1108      * on encoding conversion errors, stop the parser
1109      */
1110         xmlStopParser(ctxt);
1111     ctxt-&gt;errNo = XML_I18N_CONV_FAILED;
1112     }
1113     return(ret);
1114 }
1115 
1116 /**
1117  * xmlSwitchInputEncoding:
1118  * @ctxt:  the parser context
1119  * @input:  the input stream
1120  * @handler:  the encoding handler
1121  * @len:  the number of bytes to convert for the first line or -1
1122  *
1123  * change the input functions when discovering the character encoding
1124  * of a given entity.
1125  *
1126  * Returns 0 in case of success, -1 otherwise
1127  */
1128 static int
1129 xmlSwitchInputEncodingInt(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,
1130                           xmlCharEncodingHandlerPtr handler, int len)
1131 {
1132     int nbchars;
1133 
1134     if (handler == NULL)
1135         return (-1);
1136     if (input == NULL)
1137         return (-1);
1138     if (input-&gt;buf != NULL) {
1139         if (input-&gt;buf-&gt;encoder != NULL) {
1140             /*
1141              * Check in case the auto encoding detection triggered
1142              * in already.
1143              */
1144             if (input-&gt;buf-&gt;encoder == handler)
1145                 return (0);
1146 
1147             /*
1148              * &quot;UTF-16&quot; can be used for both LE and BE
1149              if ((!xmlStrncmp(BAD_CAST input-&gt;buf-&gt;encoder-&gt;name,
1150              BAD_CAST &quot;UTF-16&quot;, 6)) &amp;&amp;
1151              (!xmlStrncmp(BAD_CAST handler-&gt;name,
1152              BAD_CAST &quot;UTF-16&quot;, 6))) {
1153              return(0);
1154              }
1155              */
1156 
1157             /*
1158              * Note: this is a bit dangerous, but that&#39;s what it
1159              * takes to use nearly compatible signature for different
1160              * encodings.
1161              */
1162             xmlCharEncCloseFunc(input-&gt;buf-&gt;encoder);
1163             input-&gt;buf-&gt;encoder = handler;
1164             return (0);
1165         }
1166         input-&gt;buf-&gt;encoder = handler;
1167 
1168         /*
1169          * Is there already some content down the pipe to convert ?
1170          */
1171         if (xmlBufIsEmpty(input-&gt;buf-&gt;buffer) == 0) {
1172             int processed;
1173         unsigned int use;
1174 
1175             /*
1176              * Specific handling of the Byte Order Mark for
1177              * UTF-16
1178              */
1179             if ((handler-&gt;name != NULL) &amp;&amp;
1180                 (!strcmp(handler-&gt;name, &quot;UTF-16LE&quot;) ||
1181                  !strcmp(handler-&gt;name, &quot;UTF-16&quot;)) &amp;&amp;
1182                 (input-&gt;cur[0] == 0xFF) &amp;&amp; (input-&gt;cur[1] == 0xFE)) {
1183                 input-&gt;cur += 2;
1184             }
1185             if ((handler-&gt;name != NULL) &amp;&amp;
1186                 (!strcmp(handler-&gt;name, &quot;UTF-16BE&quot;)) &amp;&amp;
1187                 (input-&gt;cur[0] == 0xFE) &amp;&amp; (input-&gt;cur[1] == 0xFF)) {
1188                 input-&gt;cur += 2;
1189             }
1190             /*
1191              * Errata on XML-1.0 June 20 2001
1192              * Specific handling of the Byte Order Mark for
1193              * UTF-8
1194              */
1195             if ((handler-&gt;name != NULL) &amp;&amp;
1196                 (!strcmp(handler-&gt;name, &quot;UTF-8&quot;)) &amp;&amp;
1197                 (input-&gt;cur[0] == 0xEF) &amp;&amp;
1198                 (input-&gt;cur[1] == 0xBB) &amp;&amp; (input-&gt;cur[2] == 0xBF)) {
1199                 input-&gt;cur += 3;
1200             }
1201 
1202             /*
1203              * Shrink the current input buffer.
1204              * Move it as the raw buffer and create a new input buffer
1205              */
1206             processed = input-&gt;cur - input-&gt;base;
1207             xmlBufShrink(input-&gt;buf-&gt;buffer, processed);
1208             input-&gt;buf-&gt;raw = input-&gt;buf-&gt;buffer;
1209             input-&gt;buf-&gt;buffer = xmlBufCreate();
1210         input-&gt;buf-&gt;rawconsumed = processed;
1211         use = xmlBufUse(input-&gt;buf-&gt;raw);
1212 
1213             if (ctxt-&gt;html) {
1214                 /*
1215                  * convert as much as possible of the buffer
1216                  */
1217                 nbchars = xmlCharEncInput(input-&gt;buf, 1);
1218             } else {
1219                 /*
1220                  * convert just enough to get
1221                  * &#39;&lt;?xml version=&quot;1.0&quot; encoding=&quot;xxx&quot;?&gt;&#39;
1222                  * parsed with the autodetected encoding
1223                  * into the parser reading buffer.
1224                  */
1225                 nbchars = xmlCharEncFirstLineInput(input-&gt;buf, len);
1226             }
1227             xmlBufResetInput(input-&gt;buf-&gt;buffer, input);
1228             if (nbchars &lt; 0) {
1229                 xmlErrInternal(ctxt,
1230                                &quot;switching encoding: encoder error\n&quot;,
1231                                NULL);
1232                 return (-1);
1233             }
1234         input-&gt;buf-&gt;rawconsumed += use - xmlBufUse(input-&gt;buf-&gt;raw);
1235         }
1236         return (0);
1237     } else if (input-&gt;length == 0) {
1238     /*
1239      * When parsing a static memory array one must know the
1240      * size to be able to convert the buffer.
1241      */
1242     xmlErrInternal(ctxt, &quot;switching encoding : no input\n&quot;, NULL);
1243         /*
1244          * Callers assume that the input buffer takes ownership of the
1245          * encoding handler. xmlCharEncCloseFunc frees unregistered
1246          * handlers and avoids a memory leak.
1247          */
1248         xmlCharEncCloseFunc(handler);
1249     return (-1);
1250     }
1251     /*
1252      * We should actually raise an error here, see issue #34.
1253      */
1254     xmlCharEncCloseFunc(handler);
1255     return (0);
1256 }
1257 
1258 /**
1259  * xmlSwitchInputEncoding:
1260  * @ctxt:  the parser context
1261  * @input:  the input stream
1262  * @handler:  the encoding handler
1263  *
1264  * change the input functions when discovering the character encoding
1265  * of a given entity.
1266  *
1267  * Returns 0 in case of success, -1 otherwise
1268  */
1269 int
1270 xmlSwitchInputEncoding(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,
1271                           xmlCharEncodingHandlerPtr handler) {
1272     return(xmlSwitchInputEncodingInt(ctxt, input, handler, -1));
1273 }
1274 
1275 /**
1276  * xmlSwitchToEncodingInt:
1277  * @ctxt:  the parser context
1278  * @handler:  the encoding handler
1279  * @len: the length to convert or -1
1280  *
1281  * change the input functions when discovering the character encoding
1282  * of a given entity, and convert only @len bytes of the output, this
1283  * is needed on auto detect to allows any declared encoding later to
1284  * convert the actual content after the xmlDecl
1285  *
1286  * Returns 0 in case of success, -1 otherwise
1287  */
1288 static int
1289 xmlSwitchToEncodingInt(xmlParserCtxtPtr ctxt,
1290                        xmlCharEncodingHandlerPtr handler, int len) {
1291     int ret = 0;
1292 
1293     if (handler != NULL) {
1294         if (ctxt-&gt;input != NULL) {
1295         ret = xmlSwitchInputEncodingInt(ctxt, ctxt-&gt;input, handler, len);
1296     } else {
1297         xmlErrInternal(ctxt, &quot;xmlSwitchToEncoding : no input\n&quot;,
1298                        NULL);
1299         return(-1);
1300     }
1301     /*
1302      * The parsing is now done in UTF8 natively
1303      */
1304     ctxt-&gt;charset = XML_CHAR_ENCODING_UTF8;
1305     } else
1306     return(-1);
1307     return(ret);
1308 }
1309 
1310 /**
1311  * xmlSwitchToEncoding:
1312  * @ctxt:  the parser context
1313  * @handler:  the encoding handler
1314  *
1315  * change the input functions when discovering the character encoding
1316  * of a given entity.
1317  *
1318  * Returns 0 in case of success, -1 otherwise
1319  */
1320 int
1321 xmlSwitchToEncoding(xmlParserCtxtPtr ctxt, xmlCharEncodingHandlerPtr handler)
1322 {
1323     return (xmlSwitchToEncodingInt(ctxt, handler, -1));
1324 }
1325 
1326 /************************************************************************
1327  *                                  *
1328  *  Commodity functions to handle entities processing       *
1329  *                                  *
1330  ************************************************************************/
1331 
1332 /**
1333  * xmlFreeInputStream:
1334  * @input:  an xmlParserInputPtr
1335  *
1336  * Free up an input stream.
1337  */
1338 void
1339 xmlFreeInputStream(xmlParserInputPtr input) {
1340     if (input == NULL) return;
1341 
1342     if (input-&gt;filename != NULL) xmlFree((char *) input-&gt;filename);
1343     if (input-&gt;directory != NULL) xmlFree((char *) input-&gt;directory);
1344     if (input-&gt;encoding != NULL) xmlFree((char *) input-&gt;encoding);
1345     if (input-&gt;version != NULL) xmlFree((char *) input-&gt;version);
1346     if ((input-&gt;free != NULL) &amp;&amp; (input-&gt;base != NULL))
1347         input-&gt;free((xmlChar *) input-&gt;base);
1348     if (input-&gt;buf != NULL)
1349         xmlFreeParserInputBuffer(input-&gt;buf);
1350     xmlFree(input);
1351 }
1352 
1353 /**
1354  * xmlNewInputStream:
1355  * @ctxt:  an XML parser context
1356  *
1357  * Create a new input stream structure.
1358  *
1359  * Returns the new input stream or NULL
1360  */
1361 xmlParserInputPtr
1362 xmlNewInputStream(xmlParserCtxtPtr ctxt) {
1363     xmlParserInputPtr input;
1364 
1365     input = (xmlParserInputPtr) xmlMalloc(sizeof(xmlParserInput));
1366     if (input == NULL) {
1367         xmlErrMemory(ctxt,  &quot;couldn&#39;t allocate a new input stream\n&quot;);
1368     return(NULL);
1369     }
1370     memset(input, 0, sizeof(xmlParserInput));
1371     input-&gt;line = 1;
1372     input-&gt;col = 1;
1373     input-&gt;standalone = -1;
1374 
1375     /*
1376      * If the context is NULL the id cannot be initialized, but that
1377      * should not happen while parsing which is the situation where
1378      * the id is actually needed.
1379      */
1380     if (ctxt != NULL)
1381         input-&gt;id = ctxt-&gt;input_id++;
1382 
1383     return(input);
1384 }
1385 
1386 /**
1387  * xmlNewIOInputStream:
1388  * @ctxt:  an XML parser context
1389  * @input:  an I/O Input
1390  * @enc:  the charset encoding if known
1391  *
1392  * Create a new input stream structure encapsulating the @input into
1393  * a stream suitable for the parser.
1394  *
1395  * Returns the new input stream or NULL
1396  */
1397 xmlParserInputPtr
1398 xmlNewIOInputStream(xmlParserCtxtPtr ctxt, xmlParserInputBufferPtr input,
1399                 xmlCharEncoding enc) {
1400     xmlParserInputPtr inputStream;
1401 
1402     if (input == NULL) return(NULL);
1403     if (xmlParserDebugEntities)
1404     xmlGenericError(xmlGenericErrorContext, &quot;new input from I/O\n&quot;);
1405     inputStream = xmlNewInputStream(ctxt);
1406     if (inputStream == NULL) {
1407     return(NULL);
1408     }
1409     inputStream-&gt;filename = NULL;
1410     inputStream-&gt;buf = input;
1411     xmlBufResetInput(inputStream-&gt;buf-&gt;buffer, inputStream);
1412 
1413     if (enc != XML_CHAR_ENCODING_NONE) {
1414         xmlSwitchEncoding(ctxt, enc);
1415     }
1416 
1417     return(inputStream);
1418 }
1419 
1420 /**
1421  * xmlNewEntityInputStream:
1422  * @ctxt:  an XML parser context
1423  * @entity:  an Entity pointer
1424  *
1425  * Create a new input stream based on an xmlEntityPtr
1426  *
1427  * Returns the new input stream or NULL
1428  */
1429 xmlParserInputPtr
1430 xmlNewEntityInputStream(xmlParserCtxtPtr ctxt, xmlEntityPtr entity) {
1431     xmlParserInputPtr input;
1432 
1433     if (entity == NULL) {
1434         xmlErrInternal(ctxt, &quot;xmlNewEntityInputStream entity = NULL\n&quot;,
1435                    NULL);
1436     return(NULL);
1437     }
1438     if (xmlParserDebugEntities)
1439     xmlGenericError(xmlGenericErrorContext,
1440         &quot;new input from entity: %s\n&quot;, entity-&gt;name);
1441     if (entity-&gt;content == NULL) {
1442     switch (entity-&gt;etype) {
1443             case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
1444             xmlErrInternal(ctxt, &quot;Cannot parse entity %s\n&quot;,
1445                        entity-&gt;name);
1446                 break;
1447             case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
1448             case XML_EXTERNAL_PARAMETER_ENTITY:
1449         return(xmlLoadExternalEntity((char *) entity-&gt;URI,
1450                (char *) entity-&gt;ExternalID, ctxt));
1451             case XML_INTERNAL_GENERAL_ENTITY:
1452             xmlErrInternal(ctxt,
1453               &quot;Internal entity %s without content !\n&quot;,
1454                        entity-&gt;name);
1455                 break;
1456             case XML_INTERNAL_PARAMETER_ENTITY:
1457             xmlErrInternal(ctxt,
1458               &quot;Internal parameter entity %s without content !\n&quot;,
1459                        entity-&gt;name);
1460                 break;
1461             case XML_INTERNAL_PREDEFINED_ENTITY:
1462             xmlErrInternal(ctxt,
1463               &quot;Predefined entity %s without content !\n&quot;,
1464                        entity-&gt;name);
1465                 break;
1466     }
1467     return(NULL);
1468     }
1469     input = xmlNewInputStream(ctxt);
1470     if (input == NULL) {
1471     return(NULL);
1472     }
1473     if (entity-&gt;URI != NULL)
1474     input-&gt;filename = (char *) xmlStrdup((xmlChar *) entity-&gt;URI);
1475     input-&gt;base = entity-&gt;content;
1476     if (entity-&gt;length == 0)
1477         entity-&gt;length = xmlStrlen(entity-&gt;content);
1478     input-&gt;cur = entity-&gt;content;
1479     input-&gt;length = entity-&gt;length;
1480     input-&gt;end = &amp;entity-&gt;content[input-&gt;length];
1481     return(input);
1482 }
1483 
1484 /**
1485  * xmlNewStringInputStream:
1486  * @ctxt:  an XML parser context
1487  * @buffer:  an memory buffer
1488  *
1489  * Create a new input stream based on a memory buffer.
1490  * Returns the new input stream
1491  */
1492 xmlParserInputPtr
1493 xmlNewStringInputStream(xmlParserCtxtPtr ctxt, const xmlChar *buffer) {
1494     xmlParserInputPtr input;
1495 
1496     if (buffer == NULL) {
1497         xmlErrInternal(ctxt, &quot;xmlNewStringInputStream string = NULL\n&quot;,
1498                    NULL);
1499     return(NULL);
1500     }
1501     if (xmlParserDebugEntities)
1502     xmlGenericError(xmlGenericErrorContext,
1503         &quot;new fixed input: %.30s\n&quot;, buffer);
1504     input = xmlNewInputStream(ctxt);
1505     if (input == NULL) {
1506         xmlErrMemory(ctxt,  &quot;couldn&#39;t allocate a new input stream\n&quot;);
1507     return(NULL);
1508     }
1509     input-&gt;base = buffer;
1510     input-&gt;cur = buffer;
1511     input-&gt;length = xmlStrlen(buffer);
1512     input-&gt;end = &amp;buffer[input-&gt;length];
1513     return(input);
1514 }
1515 
1516 /**
1517  * xmlNewInputFromFile:
1518  * @ctxt:  an XML parser context
1519  * @filename:  the filename to use as entity
1520  *
1521  * Create a new input stream based on a file or an URL.
1522  *
1523  * Returns the new input stream or NULL in case of error
1524  */
1525 xmlParserInputPtr
1526 xmlNewInputFromFile(xmlParserCtxtPtr ctxt, const char *filename) {
1527     xmlParserInputBufferPtr buf;
1528     xmlParserInputPtr inputStream;
1529     char *directory = NULL;
1530     xmlChar *URI = NULL;
1531 
1532     if (xmlParserDebugEntities)
1533     xmlGenericError(xmlGenericErrorContext,
1534         &quot;new input from file: %s\n&quot;, filename);
1535     if (ctxt == NULL) return(NULL);
1536     buf = xmlParserInputBufferCreateFilename(filename, XML_CHAR_ENCODING_NONE);
1537     if (buf == NULL) {
1538     if (filename == NULL)
1539         __xmlLoaderErr(ctxt,
1540                        &quot;failed to load external entity: NULL filename \n&quot;,
1541                NULL);
1542     else
1543         __xmlLoaderErr(ctxt, &quot;failed to load external entity \&quot;%s\&quot;\n&quot;,
1544                (const char *) filename);
1545     return(NULL);
1546     }
1547 
1548     inputStream = xmlNewInputStream(ctxt);
1549     if (inputStream == NULL)
1550     return(NULL);
1551 
1552     inputStream-&gt;buf = buf;
1553     inputStream = xmlCheckHTTPInput(ctxt, inputStream);
1554     if (inputStream == NULL)
1555         return(NULL);
1556 
1557     if (inputStream-&gt;filename == NULL)
1558     URI = xmlStrdup((xmlChar *) filename);
1559     else
1560     URI = xmlStrdup((xmlChar *) inputStream-&gt;filename);
1561     directory = xmlParserGetDirectory((const char *) URI);
1562     if (inputStream-&gt;filename != NULL) xmlFree((char *)inputStream-&gt;filename);
1563     inputStream-&gt;filename = (char *) xmlCanonicPath((const xmlChar *) URI);
1564     if (URI != NULL) xmlFree((char *) URI);
1565     inputStream-&gt;directory = directory;
1566 
1567     xmlBufResetInput(inputStream-&gt;buf-&gt;buffer, inputStream);
1568     if ((ctxt-&gt;directory == NULL) &amp;&amp; (directory != NULL))
1569         ctxt-&gt;directory = (char *) xmlStrdup((const xmlChar *) directory);
1570     return(inputStream);
1571 }
1572 
1573 /************************************************************************
1574  *                                  *
1575  *      Commodity functions to handle parser contexts       *
1576  *                                  *
1577  ************************************************************************/
1578 
1579 /**
1580  * xmlInitParserCtxt:
1581  * @ctxt:  an XML parser context
1582  *
1583  * Initialize a parser context
1584  *
1585  * Returns 0 in case of success and -1 in case of error
1586  */
1587 
1588 int
1589 xmlInitParserCtxt(xmlParserCtxtPtr ctxt)
1590 {
1591     xmlParserInputPtr input;
1592 
1593     if(ctxt==NULL) {
1594         xmlErrInternal(NULL, &quot;Got NULL parser context\n&quot;, NULL);
1595         return(-1);
1596     }
1597 
1598     xmlDefaultSAXHandlerInit();
1599 
1600     if (ctxt-&gt;dict == NULL)
1601     ctxt-&gt;dict = xmlDictCreate();
1602     if (ctxt-&gt;dict == NULL) {
1603         xmlErrMemory(NULL, &quot;cannot initialize parser context\n&quot;);
1604     return(-1);
1605     }
1606     xmlDictSetLimit(ctxt-&gt;dict, XML_MAX_DICTIONARY_LIMIT);
1607 
1608     if (ctxt-&gt;sax == NULL)
1609     ctxt-&gt;sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));
1610     if (ctxt-&gt;sax == NULL) {
1611         xmlErrMemory(NULL, &quot;cannot initialize parser context\n&quot;);
1612     return(-1);
1613     }
1614     else
1615         xmlSAXVersion(ctxt-&gt;sax, 2);
1616 
1617     ctxt-&gt;maxatts = 0;
1618     ctxt-&gt;atts = NULL;
1619     /* Allocate the Input stack */
1620     if (ctxt-&gt;inputTab == NULL) {
1621     ctxt-&gt;inputTab = (xmlParserInputPtr *)
1622             xmlMalloc(5 * sizeof(xmlParserInputPtr));
1623     ctxt-&gt;inputMax = 5;
1624     }
1625     if (ctxt-&gt;inputTab == NULL) {
1626         xmlErrMemory(NULL, &quot;cannot initialize parser context\n&quot;);
1627     ctxt-&gt;inputNr = 0;
1628     ctxt-&gt;inputMax = 0;
1629     ctxt-&gt;input = NULL;
1630     return(-1);
1631     }
1632     while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */
1633         xmlFreeInputStream(input);
1634     }
1635     ctxt-&gt;inputNr = 0;
1636     ctxt-&gt;input = NULL;
1637 
1638     ctxt-&gt;version = NULL;
1639     ctxt-&gt;encoding = NULL;
1640     ctxt-&gt;standalone = -1;
1641     ctxt-&gt;hasExternalSubset = 0;
1642     ctxt-&gt;hasPErefs = 0;
1643     ctxt-&gt;html = 0;
1644     ctxt-&gt;external = 0;
1645     ctxt-&gt;instate = XML_PARSER_START;
1646     ctxt-&gt;token = 0;
1647     ctxt-&gt;directory = NULL;
1648 
1649     /* Allocate the Node stack */
1650     if (ctxt-&gt;nodeTab == NULL) {
1651     ctxt-&gt;nodeTab = (xmlNodePtr *) xmlMalloc(10 * sizeof(xmlNodePtr));
1652     ctxt-&gt;nodeMax = 10;
1653     }
1654     if (ctxt-&gt;nodeTab == NULL) {
1655         xmlErrMemory(NULL, &quot;cannot initialize parser context\n&quot;);
1656     ctxt-&gt;nodeNr = 0;
1657     ctxt-&gt;nodeMax = 0;
1658     ctxt-&gt;node = NULL;
1659     ctxt-&gt;inputNr = 0;
1660     ctxt-&gt;inputMax = 0;
1661     ctxt-&gt;input = NULL;
1662     return(-1);
1663     }
1664     ctxt-&gt;nodeNr = 0;
1665     ctxt-&gt;node = NULL;
1666 
1667     /* Allocate the Name stack */
1668     if (ctxt-&gt;nameTab == NULL) {
1669     ctxt-&gt;nameTab = (const xmlChar **) xmlMalloc(10 * sizeof(xmlChar *));
1670     ctxt-&gt;nameMax = 10;
1671     }
1672     if (ctxt-&gt;nameTab == NULL) {
1673         xmlErrMemory(NULL, &quot;cannot initialize parser context\n&quot;);
1674     ctxt-&gt;nodeNr = 0;
1675     ctxt-&gt;nodeMax = 0;
1676     ctxt-&gt;node = NULL;
1677     ctxt-&gt;inputNr = 0;
1678     ctxt-&gt;inputMax = 0;
1679     ctxt-&gt;input = NULL;
1680     ctxt-&gt;nameNr = 0;
1681     ctxt-&gt;nameMax = 0;
1682     ctxt-&gt;name = NULL;
1683     return(-1);
1684     }
1685     ctxt-&gt;nameNr = 0;
1686     ctxt-&gt;name = NULL;
1687 
1688     /* Allocate the space stack */
1689     if (ctxt-&gt;spaceTab == NULL) {
1690     ctxt-&gt;spaceTab = (int *) xmlMalloc(10 * sizeof(int));
1691     ctxt-&gt;spaceMax = 10;
1692     }
1693     if (ctxt-&gt;spaceTab == NULL) {
1694         xmlErrMemory(NULL, &quot;cannot initialize parser context\n&quot;);
1695     ctxt-&gt;nodeNr = 0;
1696     ctxt-&gt;nodeMax = 0;
1697     ctxt-&gt;node = NULL;
1698     ctxt-&gt;inputNr = 0;
1699     ctxt-&gt;inputMax = 0;
1700     ctxt-&gt;input = NULL;
1701     ctxt-&gt;nameNr = 0;
1702     ctxt-&gt;nameMax = 0;
1703     ctxt-&gt;name = NULL;
1704     ctxt-&gt;spaceNr = 0;
1705     ctxt-&gt;spaceMax = 0;
1706     ctxt-&gt;space = NULL;
1707     return(-1);
1708     }
1709     ctxt-&gt;spaceNr = 1;
1710     ctxt-&gt;spaceMax = 10;
1711     ctxt-&gt;spaceTab[0] = -1;
1712     ctxt-&gt;space = &amp;ctxt-&gt;spaceTab[0];
1713     ctxt-&gt;userData = ctxt;
1714     ctxt-&gt;myDoc = NULL;
1715     ctxt-&gt;wellFormed = 1;
1716     ctxt-&gt;nsWellFormed = 1;
1717     ctxt-&gt;valid = 1;
1718     ctxt-&gt;loadsubset = xmlLoadExtDtdDefaultValue;
1719     if (ctxt-&gt;loadsubset) {
1720         ctxt-&gt;options |= XML_PARSE_DTDLOAD;
1721     }
1722     ctxt-&gt;validate = xmlDoValidityCheckingDefaultValue;
1723     ctxt-&gt;pedantic = xmlPedanticParserDefaultValue;
1724     if (ctxt-&gt;pedantic) {
1725         ctxt-&gt;options |= XML_PARSE_PEDANTIC;
1726     }
1727     ctxt-&gt;linenumbers = xmlLineNumbersDefaultValue;
1728     ctxt-&gt;keepBlanks = xmlKeepBlanksDefaultValue;
1729     if (ctxt-&gt;keepBlanks == 0) {
1730     ctxt-&gt;sax-&gt;ignorableWhitespace = xmlSAX2IgnorableWhitespace;
1731     ctxt-&gt;options |= XML_PARSE_NOBLANKS;
1732     }
1733 
1734     ctxt-&gt;vctxt.finishDtd = XML_CTXT_FINISH_DTD_0;
1735     ctxt-&gt;vctxt.userData = ctxt;
1736     ctxt-&gt;vctxt.error = xmlParserValidityError;
1737     ctxt-&gt;vctxt.warning = xmlParserValidityWarning;
1738     if (ctxt-&gt;validate) {
1739     if (xmlGetWarningsDefaultValue == 0)
1740         ctxt-&gt;vctxt.warning = NULL;
1741     else
1742         ctxt-&gt;vctxt.warning = xmlParserValidityWarning;
1743     ctxt-&gt;vctxt.nodeMax = 0;
1744         ctxt-&gt;options |= XML_PARSE_DTDVALID;
1745     }
1746     ctxt-&gt;replaceEntities = xmlSubstituteEntitiesDefaultValue;
1747     if (ctxt-&gt;replaceEntities) {
1748         ctxt-&gt;options |= XML_PARSE_NOENT;
1749     }
1750     ctxt-&gt;record_info = 0;
1751     ctxt-&gt;nbChars = 0;
1752     ctxt-&gt;checkIndex = 0;
1753     ctxt-&gt;inSubset = 0;
1754     ctxt-&gt;errNo = XML_ERR_OK;
1755     ctxt-&gt;depth = 0;
1756     ctxt-&gt;charset = XML_CHAR_ENCODING_UTF8;
1757     ctxt-&gt;catalogs = NULL;
1758     ctxt-&gt;nbentities = 0;
1759     ctxt-&gt;sizeentities = 0;
1760     ctxt-&gt;sizeentcopy = 0;
1761     ctxt-&gt;input_id = 1;
1762     xmlInitNodeInfoSeq(&amp;ctxt-&gt;node_seq);
1763     return(0);
1764 }
1765 
1766 /**
1767  * xmlFreeParserCtxt:
1768  * @ctxt:  an XML parser context
1769  *
1770  * Free all the memory used by a parser context. However the parsed
1771  * document in ctxt-&gt;myDoc is not freed.
1772  */
1773 
1774 void
1775 xmlFreeParserCtxt(xmlParserCtxtPtr ctxt)
1776 {
1777     xmlParserInputPtr input;
1778 
1779     if (ctxt == NULL) return;
1780 
1781     while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */
1782         xmlFreeInputStream(input);
1783     }
1784     if (ctxt-&gt;spaceTab != NULL) xmlFree(ctxt-&gt;spaceTab);
1785     if (ctxt-&gt;nameTab != NULL) xmlFree((xmlChar * *)ctxt-&gt;nameTab);
1786     if (ctxt-&gt;nodeTab != NULL) xmlFree(ctxt-&gt;nodeTab);
1787     if (ctxt-&gt;nodeInfoTab != NULL) xmlFree(ctxt-&gt;nodeInfoTab);
1788     if (ctxt-&gt;inputTab != NULL) xmlFree(ctxt-&gt;inputTab);
1789     if (ctxt-&gt;version != NULL) xmlFree((char *) ctxt-&gt;version);
1790     if (ctxt-&gt;encoding != NULL) xmlFree((char *) ctxt-&gt;encoding);
1791     if (ctxt-&gt;extSubURI != NULL) xmlFree((char *) ctxt-&gt;extSubURI);
1792     if (ctxt-&gt;extSubSystem != NULL) xmlFree((char *) ctxt-&gt;extSubSystem);
1793 #ifdef LIBXML_SAX1_ENABLED
1794     if ((ctxt-&gt;sax != NULL) &amp;&amp;
1795         (ctxt-&gt;sax != (xmlSAXHandlerPtr) &amp;xmlDefaultSAXHandler))
1796 #else
1797     if (ctxt-&gt;sax != NULL)
1798 #endif /* LIBXML_SAX1_ENABLED */
1799         xmlFree(ctxt-&gt;sax);
1800     if (ctxt-&gt;directory != NULL) xmlFree((char *) ctxt-&gt;directory);
1801     if (ctxt-&gt;vctxt.nodeTab != NULL) xmlFree(ctxt-&gt;vctxt.nodeTab);
1802     if (ctxt-&gt;atts != NULL) xmlFree((xmlChar * *)ctxt-&gt;atts);
1803     if (ctxt-&gt;dict != NULL) xmlDictFree(ctxt-&gt;dict);
1804     if (ctxt-&gt;nsTab != NULL) xmlFree((char *) ctxt-&gt;nsTab);
1805     if (ctxt-&gt;pushTab != NULL) xmlFree(ctxt-&gt;pushTab);
1806     if (ctxt-&gt;attallocs != NULL) xmlFree(ctxt-&gt;attallocs);
1807     if (ctxt-&gt;attsDefault != NULL)
1808         xmlHashFree(ctxt-&gt;attsDefault, xmlHashDefaultDeallocator);
1809     if (ctxt-&gt;attsSpecial != NULL)
1810         xmlHashFree(ctxt-&gt;attsSpecial, NULL);
1811     if (ctxt-&gt;freeElems != NULL) {
1812         xmlNodePtr cur, next;
1813 
1814     cur = ctxt-&gt;freeElems;
1815     while (cur != NULL) {
1816         next = cur-&gt;next;
1817         xmlFree(cur);
1818         cur = next;
1819     }
1820     }
1821     if (ctxt-&gt;freeAttrs != NULL) {
1822         xmlAttrPtr cur, next;
1823 
1824     cur = ctxt-&gt;freeAttrs;
1825     while (cur != NULL) {
1826         next = cur-&gt;next;
1827         xmlFree(cur);
1828         cur = next;
1829     }
1830     }
1831     /*
1832      * cleanup the error strings
1833      */
1834     if (ctxt-&gt;lastError.message != NULL)
1835         xmlFree(ctxt-&gt;lastError.message);
1836     if (ctxt-&gt;lastError.file != NULL)
1837         xmlFree(ctxt-&gt;lastError.file);
1838     if (ctxt-&gt;lastError.str1 != NULL)
1839         xmlFree(ctxt-&gt;lastError.str1);
1840     if (ctxt-&gt;lastError.str2 != NULL)
1841         xmlFree(ctxt-&gt;lastError.str2);
1842     if (ctxt-&gt;lastError.str3 != NULL)
1843         xmlFree(ctxt-&gt;lastError.str3);
1844 
1845 #ifdef LIBXML_CATALOG_ENABLED
1846     if (ctxt-&gt;catalogs != NULL)
1847     xmlCatalogFreeLocal(ctxt-&gt;catalogs);
1848 #endif
1849     xmlFree(ctxt);
1850 }
1851 
1852 /**
1853  * xmlNewParserCtxt:
1854  *
1855  * Allocate and initialize a new parser context.
1856  *
1857  * Returns the xmlParserCtxtPtr or NULL
1858  */
1859 
1860 xmlParserCtxtPtr
1861 xmlNewParserCtxt(void)
1862 {
1863     xmlParserCtxtPtr ctxt;
1864 
1865     ctxt = (xmlParserCtxtPtr) xmlMalloc(sizeof(xmlParserCtxt));
1866     if (ctxt == NULL) {
1867     xmlErrMemory(NULL, &quot;cannot allocate parser context\n&quot;);
1868     return(NULL);
1869     }
1870     memset(ctxt, 0, sizeof(xmlParserCtxt));
1871     if (xmlInitParserCtxt(ctxt) &lt; 0) {
1872         xmlFreeParserCtxt(ctxt);
1873     return(NULL);
1874     }
1875     return(ctxt);
1876 }
1877 
1878 /************************************************************************
1879  *                                  *
1880  *      Handling of node informations               *
1881  *                                  *
1882  ************************************************************************/
1883 
1884 /**
1885  * xmlClearParserCtxt:
1886  * @ctxt:  an XML parser context
1887  *
1888  * Clear (release owned resources) and reinitialize a parser context
1889  */
1890 
1891 void
1892 xmlClearParserCtxt(xmlParserCtxtPtr ctxt)
1893 {
1894   if (ctxt==NULL)
1895     return;
1896   xmlClearNodeInfoSeq(&amp;ctxt-&gt;node_seq);
1897   xmlCtxtReset(ctxt);
1898 }
1899 
1900 
1901 /**
1902  * xmlParserFindNodeInfo:
1903  * @ctx:  an XML parser context
1904  * @node:  an XML node within the tree
1905  *
1906  * Find the parser node info struct for a given node
1907  *
1908  * Returns an xmlParserNodeInfo block pointer or NULL
1909  */
1910 const xmlParserNodeInfo *
1911 xmlParserFindNodeInfo(const xmlParserCtxtPtr ctx, const xmlNodePtr node)
1912 {
1913     unsigned long pos;
1914 
1915     if ((ctx == NULL) || (node == NULL))
1916         return (NULL);
1917     /* Find position where node should be at */
1918     pos = xmlParserFindNodeInfoIndex(&amp;ctx-&gt;node_seq, node);
1919     if (pos &lt; ctx-&gt;node_seq.length
1920         &amp;&amp; ctx-&gt;node_seq.buffer[pos].node == node)
1921         return &amp;ctx-&gt;node_seq.buffer[pos];
1922     else
1923         return NULL;
1924 }
1925 
1926 
1927 /**
1928  * xmlInitNodeInfoSeq:
1929  * @seq:  a node info sequence pointer
1930  *
1931  * -- Initialize (set to initial state) node info sequence
1932  */
1933 void
1934 xmlInitNodeInfoSeq(xmlParserNodeInfoSeqPtr seq)
1935 {
1936     if (seq == NULL)
1937         return;
1938     seq-&gt;length = 0;
1939     seq-&gt;maximum = 0;
1940     seq-&gt;buffer = NULL;
1941 }
1942 
1943 /**
1944  * xmlClearNodeInfoSeq:
1945  * @seq:  a node info sequence pointer
1946  *
1947  * -- Clear (release memory and reinitialize) node
1948  *   info sequence
1949  */
1950 void
1951 xmlClearNodeInfoSeq(xmlParserNodeInfoSeqPtr seq)
1952 {
1953     if (seq == NULL)
1954         return;
1955     if (seq-&gt;buffer != NULL)
1956         xmlFree(seq-&gt;buffer);
1957     xmlInitNodeInfoSeq(seq);
1958 }
1959 
1960 /**
1961  * xmlParserFindNodeInfoIndex:
1962  * @seq:  a node info sequence pointer
1963  * @node:  an XML node pointer
1964  *
1965  *
1966  * xmlParserFindNodeInfoIndex : Find the index that the info record for
1967  *   the given node is or should be at in a sorted sequence
1968  *
1969  * Returns a long indicating the position of the record
1970  */
1971 unsigned long
1972 xmlParserFindNodeInfoIndex(const xmlParserNodeInfoSeqPtr seq,
1973                            const xmlNodePtr node)
1974 {
1975     unsigned long upper, lower, middle;
1976     int found = 0;
1977 
1978     if ((seq == NULL) || (node == NULL))
1979         return ((unsigned long) -1);
1980 
1981     /* Do a binary search for the key */
1982     lower = 1;
1983     upper = seq-&gt;length;
1984     middle = 0;
1985     while (lower &lt;= upper &amp;&amp; !found) {
1986         middle = lower + (upper - lower) / 2;
1987         if (node == seq-&gt;buffer[middle - 1].node)
1988             found = 1;
1989         else if (node &lt; seq-&gt;buffer[middle - 1].node)
1990             upper = middle - 1;
1991         else
1992             lower = middle + 1;
1993     }
1994 
1995     /* Return position */
1996     if (middle == 0 || seq-&gt;buffer[middle - 1].node &lt; node)
1997         return middle;
1998     else
1999         return middle - 1;
2000 }
2001 
2002 
2003 /**
2004  * xmlParserAddNodeInfo:
2005  * @ctxt:  an XML parser context
2006  * @info:  a node info sequence pointer
2007  *
2008  * Insert node info record into the sorted sequence
2009  */
2010 void
2011 xmlParserAddNodeInfo(xmlParserCtxtPtr ctxt,
2012                      const xmlParserNodeInfoPtr info)
2013 {
2014     unsigned long pos;
2015 
2016     if ((ctxt == NULL) || (info == NULL)) return;
2017 
2018     /* Find pos and check to see if node is already in the sequence */
2019     pos = xmlParserFindNodeInfoIndex(&amp;ctxt-&gt;node_seq, (xmlNodePtr)
2020                                      info-&gt;node);
2021 
2022     if ((pos &lt; ctxt-&gt;node_seq.length) &amp;&amp;
2023         (ctxt-&gt;node_seq.buffer != NULL) &amp;&amp;
2024         (ctxt-&gt;node_seq.buffer[pos].node == info-&gt;node)) {
2025         ctxt-&gt;node_seq.buffer[pos] = *info;
2026     }
2027 
2028     /* Otherwise, we need to add new node to buffer */
2029     else {
2030         if ((ctxt-&gt;node_seq.length + 1 &gt; ctxt-&gt;node_seq.maximum) ||
2031         (ctxt-&gt;node_seq.buffer == NULL)) {
2032             xmlParserNodeInfo *tmp_buffer;
2033             unsigned int byte_size;
2034 
2035             if (ctxt-&gt;node_seq.maximum == 0)
2036                 ctxt-&gt;node_seq.maximum = 2;
2037             byte_size = (sizeof(*ctxt-&gt;node_seq.buffer) *
2038             (2 * ctxt-&gt;node_seq.maximum));
2039 
2040             if (ctxt-&gt;node_seq.buffer == NULL)
2041                 tmp_buffer = (xmlParserNodeInfo *) xmlMalloc(byte_size);
2042             else
2043                 tmp_buffer =
2044                     (xmlParserNodeInfo *) xmlRealloc(ctxt-&gt;node_seq.buffer,
2045                                                      byte_size);
2046 
2047             if (tmp_buffer == NULL) {
2048         xmlErrMemory(ctxt, &quot;failed to allocate buffer\n&quot;);
2049                 return;
2050             }
2051             ctxt-&gt;node_seq.buffer = tmp_buffer;
2052             ctxt-&gt;node_seq.maximum *= 2;
2053         }
2054 
2055         /* If position is not at end, move elements out of the way */
2056         if (pos != ctxt-&gt;node_seq.length) {
2057             unsigned long i;
2058 
2059             for (i = ctxt-&gt;node_seq.length; i &gt; pos; i--)
2060                 ctxt-&gt;node_seq.buffer[i] = ctxt-&gt;node_seq.buffer[i - 1];
2061         }
2062 
2063         /* Copy element and increase length */
2064         ctxt-&gt;node_seq.buffer[pos] = *info;
2065         ctxt-&gt;node_seq.length++;
2066     }
2067 }
2068 
2069 /************************************************************************
2070  *                                  *
2071  *      Defaults settings                   *
2072  *                                  *
2073  ************************************************************************/
2074 /**
2075  * xmlPedanticParserDefault:
2076  * @val:  int 0 or 1
2077  *
2078  * Set and return the previous value for enabling pedantic warnings.
2079  *
2080  * Returns the last value for 0 for no substitution, 1 for substitution.
2081  */
2082 
2083 int
2084 xmlPedanticParserDefault(int val) {
2085     int old = xmlPedanticParserDefaultValue;
2086 
2087     xmlPedanticParserDefaultValue = val;
2088     return(old);
2089 }
2090 
2091 /**
2092  * xmlLineNumbersDefault:
2093  * @val:  int 0 or 1
2094  *
2095  * Set and return the previous value for enabling line numbers in elements
2096  * contents. This may break on old application and is turned off by default.
2097  *
2098  * Returns the last value for 0 for no substitution, 1 for substitution.
2099  */
2100 
2101 int
2102 xmlLineNumbersDefault(int val) {
2103     int old = xmlLineNumbersDefaultValue;
2104 
2105     xmlLineNumbersDefaultValue = val;
2106     return(old);
2107 }
2108 
2109 /**
2110  * xmlSubstituteEntitiesDefault:
2111  * @val:  int 0 or 1
2112  *
2113  * Set and return the previous value for default entity support.
2114  * Initially the parser always keep entity references instead of substituting
2115  * entity values in the output. This function has to be used to change the
2116  * default parser behavior
2117  * SAX::substituteEntities() has to be used for changing that on a file by
2118  * file basis.
2119  *
2120  * Returns the last value for 0 for no substitution, 1 for substitution.
2121  */
2122 
2123 int
2124 xmlSubstituteEntitiesDefault(int val) {
2125     int old = xmlSubstituteEntitiesDefaultValue;
2126 
2127     xmlSubstituteEntitiesDefaultValue = val;
2128     return(old);
2129 }
2130 
2131 /**
2132  * xmlKeepBlanksDefault:
2133  * @val:  int 0 or 1
2134  *
2135  * Set and return the previous value for default blanks text nodes support.
2136  * The 1.x version of the parser used an heuristic to try to detect
2137  * ignorable white spaces. As a result the SAX callback was generating
2138  * xmlSAX2IgnorableWhitespace() callbacks instead of characters() one, and when
2139  * using the DOM output text nodes containing those blanks were not generated.
2140  * The 2.x and later version will switch to the XML standard way and
2141  * ignorableWhitespace() are only generated when running the parser in
2142  * validating mode and when the current element doesn&#39;t allow CDATA or
2143  * mixed content.
2144  * This function is provided as a way to force the standard behavior
2145  * on 1.X libs and to switch back to the old mode for compatibility when
2146  * running 1.X client code on 2.X . Upgrade of 1.X code should be done
2147  * by using xmlIsBlankNode() commodity function to detect the &quot;empty&quot;
2148  * nodes generated.
2149  * This value also affect autogeneration of indentation when saving code
2150  * if blanks sections are kept, indentation is not generated.
2151  *
2152  * Returns the last value for 0 for no substitution, 1 for substitution.
2153  */
2154 
2155 int
2156 xmlKeepBlanksDefault(int val) {
2157     int old = xmlKeepBlanksDefaultValue;
2158 
2159     xmlKeepBlanksDefaultValue = val;
2160     if (!val) xmlIndentTreeOutput = 1;
2161     return(old);
2162 }
2163 
2164 #define bottom_parserInternals
2165 #include &quot;elfgcchack.h&quot;
    </pre>
  </body>
</html>
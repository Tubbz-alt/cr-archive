<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/java/com/sun/javafx/webkit/prism/WCGraphicsPrismContext.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.javafx.webkit.prism;
  27 
  28 import com.sun.glass.ui.Screen;
  29 import com.sun.javafx.font.FontStrike;
  30 import com.sun.javafx.font.Metrics;
  31 import com.sun.javafx.font.PGFont;
  32 import com.sun.javafx.geom.*;
  33 import com.sun.javafx.geom.transform.Affine2D;
  34 import com.sun.javafx.geom.transform.Affine3D;
  35 import com.sun.javafx.geom.transform.BaseTransform;
  36 import com.sun.javafx.geom.transform.GeneralTransform3D;
  37 import com.sun.javafx.logging.PlatformLogger;
  38 import com.sun.javafx.logging.PlatformLogger.Level;
  39 import com.sun.javafx.scene.text.GlyphList;
  40 import com.sun.javafx.scene.text.TextLayout;
  41 import com.sun.javafx.sg.prism.*;
  42 import com.sun.javafx.text.TextRun;
  43 import com.sun.prism.*;
  44 import com.sun.prism.paint.Color;
  45 import com.sun.prism.paint.Gradient;
  46 import com.sun.prism.paint.ImagePattern;
  47 import com.sun.prism.paint.Paint;
  48 import com.sun.scenario.effect.*;
  49 import com.sun.scenario.effect.impl.prism.PrDrawable;
  50 import com.sun.scenario.effect.impl.prism.PrEffectHelper;
  51 import com.sun.scenario.effect.impl.prism.PrFilterContext;
  52 import com.sun.webkit.graphics.*;
  53 
  54 import java.nio.ByteBuffer;
  55 import java.nio.ByteOrder;
  56 import java.security.AccessController;
  57 import java.security.PrivilegedAction;
  58 import java.util.ArrayList;
  59 import java.util.List;
  60 
  61 import static com.sun.scenario.effect.Blend.Mode.*;
  62 import com.sun.scenario.effect.impl.Renderer;
  63 import com.sun.scenario.effect.impl.prism.PrRenderer;
  64 
  65 class WCGraphicsPrismContext extends WCGraphicsContext {
  66 
  67     public enum Type {
  68         /**
  69          * Base context associated with the topmost page buffer.
  70          * Created and disposed during a single render pass.
  71          */
  72         PRIMARY,
  73 
  74         /**
  75          * A context associated with a dedicated buffer representing
  76          * a separate render target like canvas, buffered image etc.
  77          * Its life cycle is not limited to a single render pass.
  78          */
  79         DEDICATED
  80     }
  81 
  82     private final static PlatformLogger log =
  83             PlatformLogger.getLogger(WCGraphicsPrismContext.class.getName());
  84     private final static boolean DEBUG_DRAW_CLIP_SHAPE = Boolean.valueOf(
  85             AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) () -&gt;
  86             System.getProperty(&quot;com.sun.webkit.debugDrawClipShape&quot;, &quot;false&quot;)));
  87 
  88     Graphics baseGraphics;
  89     private BaseTransform baseTransform;
  90 
  91     private final List&lt;ContextState&gt; states = new ArrayList&lt;ContextState&gt;();
  92 
  93     private ContextState state = new ContextState();
  94 
  95     // Cache for getPlatformGraphics
  96     private Graphics cachedGraphics = null;
  97 
  98     private int fontSmoothingType;
  99     private boolean isRootLayerValid = false;
 100 
 101     WCGraphicsPrismContext(Graphics g) {
 102         state.setClip(g.getClipRect());
 103         state.setAlpha(g.getExtraAlpha());
 104         baseGraphics = g;
 105         initBaseTransform(g.getTransformNoClone());
 106     }
 107 
 108     WCGraphicsPrismContext() {
 109     }
 110 
 111     public Type type() {
 112         return Type.PRIMARY;
 113     }
 114 
 115     final void initBaseTransform(BaseTransform t) {
 116         baseTransform = new Affine3D(t);
 117         state.setTransform((Affine3D)baseTransform);
 118     }
 119 
 120     private void resetCachedGraphics() {
 121         cachedGraphics = null;
 122     }
 123 
 124     @Override
 125     public Object getPlatformGraphics() {
 126         return getGraphics(false);
 127     }
 128 
 129     Graphics getGraphics(boolean checkClip) {
 130         if (cachedGraphics == null) {
 131             Layer l = state.getLayerNoClone();
 132             cachedGraphics = (l != null)
 133                     ? l.getGraphics()
 134                     : baseGraphics;
 135 
 136             state.apply(cachedGraphics);
 137 
 138             if (log.isLoggable(Level.FINE)) {
 139                 log.fine(&quot;getPlatformGraphics for &quot; + this + &quot; : &quot; +
 140                          cachedGraphics);
 141             }
 142         }
 143 
 144         Rectangle clip = cachedGraphics.getClipRectNoClone();
 145         return (checkClip &amp;&amp; clip!=null &amp;&amp; clip.isEmpty())
 146             ? null
 147             : cachedGraphics;
 148     }
 149 
 150     public void saveState()
 151     {
 152         state.markAsRestorePoint();
 153         saveStateInternal();
 154     }
 155 
 156     private void saveStateInternal()
 157     {
 158         states.add(state);
 159         state = state.clone();
 160     }
 161 
 162     private void startNewLayer(Layer layer) {
 163         saveStateInternal();
 164 
 165         // layer has the same bounds as clip, so we have to translate
 166         Rectangle clip = state.getClipNoClone();
 167 
 168         //left-side (post-) translate.
 169         //NB! an order of transforms is essential!
 170         Affine3D newTr = new Affine3D(BaseTransform.getTranslateInstance(
 171                 -clip.x,
 172                 -clip.y));
 173         newTr.concatenate(state.getTransformNoClone());
 174 
 175         //move clip to (0, 0) - start of texture
 176         clip.x = 0;
 177         clip.y = 0;
 178         //no-clone - no-set!
 179 
 180         Graphics g = getGraphics(true);
 181         if (g != null &amp;&amp; g != baseGraphics) {
 182             layer.init(g);
 183         }
 184 
 185         state.setTransform(newTr);
 186         state.setLayer(layer);
 187 
 188         resetCachedGraphics();
 189     }
 190 
 191     private void renderLayer(final Layer layer) {
 192         WCTransform cur = getTransform();
 193 
 194         //translate to (layer.getX(), layer.getY())
 195         setTransform(new WCTransform(
 196             1.0, 0.0,
 197             0.0, 1.0,
 198             layer.getX(), layer.getY()));
 199 
 200         // composite drawing delegated to the layer rendering
 201         Graphics g = getGraphics(true);
 202         if (g != null) {
 203             layer.render(g);
 204         }
 205 
 206         //restore transform
 207         setTransform(cur);
 208     }
 209 
 210     private void restoreStateInternal() {
 211         int size = states.size();
 212         if (size == 0) {
 213             assert false: &quot;Unbalanced restoreState&quot;;
 214             return;
 215         }
 216 
 217         Layer layer = state.getLayerNoClone();
 218         state = states.remove(size - 1);
 219         if (layer != state.getLayerNoClone()) {
 220             renderLayer(layer);
 221             layer.dispose();
 222             if (log.isLoggable(Level.FINE)) {
 223                 log.fine(&quot;Popped layer &quot; + layer);
 224             }
 225         } else {
 226             resetCachedGraphics();
 227         }
 228     }
 229 
 230     public void restoreState()
 231     {
 232         log.fine(&quot;restoring state&quot;);
 233         do {
 234             restoreStateInternal();
 235         } while ( !state.isRestorePoint() );
 236     }
 237 
 238     /**
 239      *  Renders all layers to the underlaying Graphics, but preserves the
 240      *  current state and the states stack
 241      */
 242     private void flushAllLayers() {
 243         if (state == null) {
 244             // context disposed
 245             return;
 246         }
 247 
 248         if (isRootLayerValid) {
 249             log.fine(&quot;FlushAllLayers: root layer is valid, skipping&quot;);
 250             return;
 251         }
 252 
 253         if (log.isLoggable(Level.FINE)) {
 254             log.fine(&quot;FlushAllLayers&quot;);
 255         }
 256 
 257         ContextState currentState = state;
 258 
 259         for (int i = states.size() - 1; i &gt;=0; i--) {
 260             Layer layer = state.getLayerNoClone();
 261             state = states.get(i);
 262             if (layer != state.getLayerNoClone()) {
 263                 renderLayer(layer);
 264             } else {
 265                 resetCachedGraphics();
 266             }
 267         }
 268 
 269         Layer layer = state.getLayerNoClone();
 270         if (layer != null) {
 271             renderLayer(layer);
 272         }
 273 
 274         state = currentState;
 275         isRootLayerValid = true;
 276     }
 277 
 278 
 279     public void dispose() {
 280         if (!states.isEmpty()) {
 281             log.fine(&quot;Unbalanced saveState/restoreState&quot;);
 282         }
 283         for (ContextState state: states) {
 284             if (state.getLayerNoClone() != null) {
 285                 state.getLayerNoClone().dispose();
 286             }
 287         }
 288         states.clear();
 289 
 290         if (state != null &amp;&amp; state.getLayerNoClone() != null) {
 291             state.getLayerNoClone().dispose();
 292         }
 293         state = null;
 294     }
 295 
 296 
 297     public void setClip(WCPath path, boolean isOut) {
 298         Affine3D tr = new Affine3D(state.getTransformNoClone());
 299         path.transform(
 300                 tr.getMxx(), tr.getMyx(),
 301                 tr.getMxy(), tr.getMyy(),
 302                 tr.getMxt(), tr.getMyt());
 303         //path now is in node coordinates, as well as clip
 304 
 305         if (!isOut) {
 306             WCRectangle pathBounds = path.getBounds();
 307 
 308             // path bounds could be fractional so &#39;inclusive&#39; rounding
 309             // is used for determining clip rectangle
 310             int pixelX = (int) Math.floor(pathBounds.getX());
 311             int pixelY = (int) Math.floor(pathBounds.getY());
 312             int pixelW = (int) Math.ceil(pathBounds.getMaxX()) - pixelX;
 313             int pixelH = (int) Math.ceil(pathBounds.getMaxY()) - pixelY;
 314 
 315             state.clip(new Rectangle(pixelX, pixelY, pixelW, pixelH));
 316         }
 317 
 318         Rectangle clip = state.getClipNoClone();
 319 
 320         if (isOut) {
 321             path.addRect(clip.x, clip.y, clip.width, clip.height);
 322             //Out clip path is always EVENODD.
 323         }
 324 
 325         path.translate(-clip.x, -clip.y);
 326 
 327         Layer layer = new ClipLayer(
 328             getGraphics(false), clip, path, type() == Type.DEDICATED);
 329 
 330         startNewLayer(layer);
 331 
 332         if (log.isLoggable(Level.FINE)) {
 333             log.fine(&quot;setClip(WCPath &quot; + path.getID() + &quot;)&quot;);
 334             log.fine(&quot;Pushed layer &quot; + layer);
 335         }
 336     }
 337 
 338     private Rectangle transformClip(Rectangle localClip) {
 339         if (localClip==null) {
 340             return null;
 341         }
 342 
 343         float[] points = new float[] {
 344             localClip.x, localClip.y,
 345             localClip.x + localClip.width, localClip.y,
 346             localClip.x, localClip.y + localClip.height,
 347             localClip.x  + localClip.width, localClip.y + localClip.height};
 348         state.getTransformNoClone().transform(points, 0, points, 0, 4);
 349         float minX = Math.min(
 350                points[0], Math.min(
 351                points[2], Math.min(
 352                points[4], points[6])));
 353         float maxX = Math.max(
 354                points[0], Math.max(
 355                points[2], Math.max(
 356                points[4], points[6])));
 357         float minY = Math.min(
 358                points[1], Math.min(
 359                points[3], Math.min(
 360                points[5], points[7])));
 361         float maxY = Math.max(
 362                points[1], Math.max(
 363                points[3], Math.max(
 364                points[5], points[7])));
 365         return new Rectangle(new RectBounds(minX, minY, maxX, maxY));
 366 
 367 /* #1 loose rotate
 368         state.getTransformNoClone().transform(localClip, localClip);
 369 */
 370 /* #2 problem with negative coordinates
 371         RectBounds rb = TransformedShape.transformedShape(
 372             new RoundRectangle2D(localClip.x, localClip.y, localClip.width, localClip.height, 0, 0),
 373             state.getTransformNoClone()).getBounds();
 374         return rb.isEmpty()
 375             ? null
 376             : new Rectangle(rb);
 377  */
 378     }
 379 
 380     private void setClip(Rectangle shape) {
 381         Affine3D tr = state.getTransformNoClone();
 382         if (tr.getMxy() == 0 &amp;&amp; tr.getMxz() == 0
 383          &amp;&amp; tr.getMyx() == 0 &amp;&amp; tr.getMyz() == 0
 384          &amp;&amp; tr.getMzx() == 0 &amp;&amp; tr.getMzy() == 0) {
 385             //There is no rotation here: scale + translation.
 386             //Fast &amp; easy!
 387             state.clip(transformClip(shape));
 388             if (log.isLoggable(Level.FINE)) {
 389                 log.fine(&quot;setClip({0})&quot;, shape);
 390             }
 391             if (DEBUG_DRAW_CLIP_SHAPE) {
 392                 //Draw clip shape
 393                 Rectangle rc = state.getClipNoClone();
 394                 if (rc != null &amp;&amp; rc.width &gt;= 2 &amp;&amp; rc.height &gt;= 2) {
 395                     WCTransform cur = getTransform();
 396                     //translate to (layer.getX(), layer.getY())
 397                     setTransform(new WCTransform(
 398                         1.0, 0.0,
 399                         0.0, 1.0,
 400                         0.0, 0.0));
 401 
 402                     Graphics g2d = getGraphics(true);
 403                     if (g2d != null) {
 404                         float fbase = (float)Math.random();
 405                         g2d.setPaint(new Color(
 406                                 fbase,
 407                                 1f - fbase,
 408                                 0.5f,
 409                                 0.1f));
 410                         g2d.setStroke(new BasicStroke());
 411                         g2d.fillRect(rc.x, rc.y, rc.width, rc.height);
 412 
 413                         g2d.setPaint(new Color(
 414                                 1f - fbase,
 415                                 fbase,
 416                                 0.5f,
 417                                 1f));
 418                         g2d.drawRect(rc.x, rc.y, rc.width, rc.height);
 419                     }
 420                     //restore transform
 421                     setTransform(cur);
 422                     state.clip(new Rectangle(rc.x+1, rc.y+1, rc.width-2, rc.height-2));
 423                 }
 424             }
 425             if (cachedGraphics != null) {
 426                 cachedGraphics.setClipRect(state.getClipNoClone());
 427             }
 428         } else {
 429             //twisted axis set
 430             WCPath path = new WCPathImpl();
 431             path.addRect(shape.x, shape.y, shape.width, shape.height);
 432             setClip(path, false);
 433         }
 434     }
 435 
 436     public void setClip(int cx, int cy, int cw, int ch) {
 437         setClip(new Rectangle(cx, cy, cw, ch));
 438     }
 439 
 440     public void setClip(WCRectangle c) {
 441         setClip(new Rectangle((int)c.getX(), (int)c.getY(),
 442                               (int)c.getWidth(), (int)c.getHeight()));
 443     }
 444 
 445     public void setClip(int cx, int cy, int cw, int ch, WCImage maskImage) {
 446         setClip(new Rectangle(cx, cy, cw, ch));
 447         state.setClipMaskImage(maskImage);
 448     }
 449 
 450     public WCRectangle getClip() {
 451         Rectangle r = state.getClipNoClone();
 452         return r == null ? null : new WCRectangle(r.x, r.y, r.width, r.height);
 453     }
 454 
 455     protected Rectangle getClipRectNoClone() {
 456         return state.getClipNoClone();
 457     }
 458 
 459     protected Affine3D getTransformNoClone() {
 460         return state.getTransformNoClone();
 461     }
 462 
 463     public void translate(float x, float y) {
 464         if (log.isLoggable(Level.FINE)) {
 465             log.fine(&quot;translate({0},{1})&quot;, new Object[] {x, y});
 466         }
 467         state.translate(x, y);
 468         if (cachedGraphics != null) {
 469             cachedGraphics.translate(x, y);
 470         }
 471     }
 472 
 473     public void scale(float sx, float sy) {
 474         if (log.isLoggable(Level.FINE)) {
 475             log.fine(&quot;scale(&quot; + sx + &quot; &quot; + sy + &quot;)&quot;);
 476         }
 477         state.scale(sx, sy);
 478         if (cachedGraphics != null) {
 479             cachedGraphics.scale(sx, sy);
 480         }
 481     }
 482 
 483     public void rotate(float radians) {
 484         if (log.isLoggable(Level.FINE)) {
 485             log.fine(&quot;rotate(&quot; + radians + &quot;)&quot;);
 486         }
 487         state.rotate(radians);
 488         if (cachedGraphics != null) {
 489             cachedGraphics.setTransform(state.getTransformNoClone());
 490         }
 491     }
 492 
 493     // overriden in WCBufferedContext
 494     protected boolean shouldRenderRect(float x, float y, float w, float h,
 495                                        DropShadow shadow, BasicStroke stroke)
 496     {
 497         return true;
 498     }
 499 
 500     // overriden in WCBufferedContext
 501     protected boolean shouldRenderShape(Shape shape, DropShadow shadow, BasicStroke stroke) {
 502         return true;
 503     }
 504 
 505     // overriden in WCBufferedContext
 506     protected boolean shouldCalculateIntersection() {
 507         return false;
 508     }
 509 
 510     @Override
 511     public void fillRect(final float x, final float y, final float w, final float h, final Integer rgba) {
 512         if (log.isLoggable(Level.FINE)) {
 513             String format = (rgba != null)
 514                     ? &quot;fillRect(%f, %f, %f, %f, 0x%x)&quot;
 515                     : &quot;fillRect(%f, %f, %f, %f, null)&quot;;
 516             log.fine(String.format(format, x, y, w, h, rgba));
 517         }
 518         if (!shouldRenderRect(x, y, w, h, state.getShadowNoClone(), null)) {
 519             return;
 520         }
 521         new Composite() {
 522             @Override void doPaint(Graphics g) {
 523                 Paint paint = (rgba != null) ? createColor(rgba) : state.getPaintNoClone();
 524                 DropShadow shadow = state.getShadowNoClone();
 525                 // TextureMapperJava::drawSolidColor calls fillRect with perspective
 526                 // projection.
 527                 if (shadow != null || !state.getPerspectiveTransformNoClone().isIdentity()) {
 528                     final NGRectangle node = new NGRectangle();
 529                     node.updateRectangle(x, y, w, h, 0, 0);
 530                     render(g, shadow, paint, null, node);
 531                 } else if(state.getClipMaskImageNoClone() != null) {
 532                     Rectangle rect = new Rectangle((int) x, (int) y, (int) w, (int) h);
 533                     Rectangle transformedRect = new Rectangle();
 534                     state.getTransformNoClone().transform(rect, transformedRect);
 535                     RTTexture paintRtTexture = g.getResourceFactory().createRTTexture(
 536                             (int) Math.ceil(transformedRect.width),
 537                             (int) Math.ceil(transformedRect.height),
 538                             Texture.WrapMode.CLAMP_NOT_NEEDED);
 539                     Graphics g1 = paintRtTexture.createGraphics();
 540                     g1.setPaint(paint);
 541                     g1.setTransform(PrismGraphicsManager.getPixelScaleTransform());
 542                     g1.fillRect(0, 0, paintRtTexture.getContentWidth(), paintRtTexture.getContentHeight());
 543 
 544                     RTImage maskImage = (RTImage) (state.getClipMaskImageNoClone());
 545                     Image nativeMaskImage = Image.fromByteBgraPreData(maskImage.getPixelBuffer(), maskImage.getWidth(),
 546                             maskImage.getHeight(), 0, maskImage.getPixelScale());
 547                     Texture maskTexture = g.getResourceFactory().createTexture(nativeMaskImage, Texture.Usage.STATIC,
 548                             Texture.WrapMode.CLAMP_NOT_NEEDED);
 549                     RTTexture maskRtTexture = g.getResourceFactory().createRTTexture(nativeMaskImage.getWidth(),
 550                             nativeMaskImage.getHeight(), Texture.WrapMode.CLAMP_NOT_NEEDED);
 551                     Graphics g2 = maskRtTexture.createGraphics();
 552                     g2.setTransform(PrismGraphicsManager.getPixelScaleTransform());
 553                     g2.drawTexture(maskTexture, 0, 0, nativeMaskImage.getWidth(), nativeMaskImage.getHeight());
 554                     if(g instanceof MaskTextureGraphics) {
 555                         MaskTextureGraphics mg = (MaskTextureGraphics) (g);
 556                         mg.drawPixelsMasked(paintRtTexture, maskRtTexture, transformedRect.x, transformedRect.y,
 557                                 transformedRect.width, transformedRect.height, 0, 0, 0, 0);
 558                     } else {
 559                         Screen screen = g.getAssociatedScreen();
 560                         FilterContext filterContext;
 561                         if (screen == null) {
 562                             ResourceFactory factory = g.getResourceFactory();
 563                             filterContext = PrFilterContext.getPrinterContext(factory);
 564                         } else {
 565                             filterContext = PrFilterContext.getInstance(screen);
 566                         }
 567                         PrDrawable imagePrDrawable = PrDrawable.create(filterContext, paintRtTexture);
 568                         PrDrawable maskPrDrawable = PrDrawable.create(filterContext, maskRtTexture);
 569                         Blend blend = new Blend(Blend.Mode.SRC_IN,
 570                                 new PassThrough(maskPrDrawable, transformedRect.width, transformedRect.height),
 571                                 new PassThrough(imagePrDrawable, transformedRect.width, transformedRect.height));
 572                         Affine3D tx = new Affine3D(g.getTransformNoClone());
 573                         g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
 574                         PrEffectHelper.render(blend, g, transformedRect.x, transformedRect.y, null);
 575                         g.setTransform(tx);
 576                     }
 577                 } else {
 578                     g.setPaint(paint);
 579                     g.fillRect(x, y, w, h);
 580                 }
 581             }
 582         }.paint();
 583     }
 584 
 585     @Override
 586     public void fillRoundedRect(final float x, final float y, final float w, final float h,
 587         final float topLeftW, final float topLeftH, final float topRightW, final float topRightH,
 588         final float bottomLeftW, final float bottomLeftH, final float bottomRightW, final float bottomRightH,
 589         final int rgba)
 590     {
 591         if (log.isLoggable(Level.FINE)) {
 592             log.fine(String.format(&quot;fillRoundedRect(%f, %f, %f, %f, &quot;
 593                     + &quot;%f, %f, %f, %f, %f, %f, %f, %f, 0x%x)&quot;,
 594                     x, y, w, h, topLeftW, topLeftH, topRightW, topRightH,
 595                     bottomLeftW, bottomLeftH, bottomRightW, bottomRightH, rgba));
 596         }
 597         if (!shouldRenderRect(x, y, w, h, state.getShadowNoClone(), null)) {
 598             return;
 599         }
 600         new Composite() {
 601             @Override void doPaint(Graphics g) {
 602                 // Prism only supports single arcWidth/Height.
 603                 // We work around by calculating average width and height here
 604 
 605                 float arcW = (topLeftW + topRightW + bottomLeftW + bottomRightW) / 2;
 606                 float arcH = (topLeftH + topRightH + bottomLeftH + bottomRightH) / 2;
 607 
 608                 Paint paint = createColor(rgba);
 609                 DropShadow shadow = state.getShadowNoClone();
 610                 if (shadow != null) {
 611                     final NGRectangle node = new NGRectangle();
 612                     node.updateRectangle(x, y, w, h, arcW, arcH);
 613                     render(g, shadow, paint, null, node);
 614                 } else {
 615                     g.setPaint(paint);
 616                     g.fillRoundRect(x, y, w, h, arcW, arcH);
 617                 }
 618             }
 619         }.paint();
 620     }
 621 
 622     @Override
 623     public void clearRect(final float x, final float y, final float w, final float h) {
 624         if (log.isLoggable(Level.FINE)) {
 625             log.fine(String.format(&quot;clearRect(%f, %f, %f, %f)&quot;, x, y, w, h));
 626         }
 627         if (shouldCalculateIntersection()) {
 628             // No intersection is applicable for clearRect.
 629             return;
 630         }
 631         new Composite() {
 632             @Override void doPaint(Graphics g) {
 633                 g.clearQuad(x, y, x + w, y + h);
 634             }
 635         }.paint();
 636     }
 637 
 638     @Override
 639     public void setFillColor(int rgba) {
 640         if (log.isLoggable(Level.FINE)) {
 641             log.fine(String.format(&quot;setFillColor(0x%x)&quot;, rgba));
 642         }
 643         state.setPaint(createColor(rgba));
 644     }
 645 
 646     @Override
 647     public void setFillGradient(WCGradient gradient) {
 648         if (log.isLoggable(Level.FINE)) {
 649             log.fine(&quot;setFillGradient(&quot; + gradient + &quot;)&quot;);
 650         }
 651         state.setPaint((Gradient) gradient.getPlatformGradient());
 652     }
 653 
 654     @Override
 655     public void setTextMode(boolean fill, boolean stroke, boolean clip) {
 656         if (log.isLoggable(Level.FINE)) {
 657             log.fine(&quot;setTextMode(fill:&quot; + fill + &quot;,stroke:&quot; + stroke + &quot;,clip:&quot; + clip + &quot;)&quot;);
 658         }
 659         state.setTextMode(fill, stroke, clip);
 660     }
 661 
 662     @Override
 663     public void setFontSmoothingType(int fontSmoothingType) {
 664         this.fontSmoothingType = fontSmoothingType;
 665     }
 666 
 667     @Override
 668     public int getFontSmoothingType() {
 669         return fontSmoothingType;
 670     }
 671 
 672     @Override
 673     public void setStrokeStyle(int style) {
 674         if (log.isLoggable(Level.FINE)) {
 675             log.fine(&quot;setStrokeStyle({0})&quot;, style);
 676         }
 677         state.getStrokeNoClone().setStyle(style);
 678     }
 679 
 680     @Override
 681     public void setStrokeColor(int rgba) {
 682         if (log.isLoggable(Level.FINE)) {
 683             log.fine(String.format(&quot;setStrokeColor(0x%x)&quot;, rgba));
 684         }
 685         state.getStrokeNoClone().setPaint(createColor(rgba));
 686     }
 687 
 688     @Override
 689     public void setStrokeWidth(float width) {
 690         if (log.isLoggable(Level.FINE)) {
 691             log.fine(&quot;setStrokeWidth({0})&quot;, new Object[] { width });
 692         }
 693         state.getStrokeNoClone().setThickness(width);
 694     }
 695 
 696     @Override
 697     public void setStrokeGradient(WCGradient gradient) {
 698         if (log.isLoggable(Level.FINE)) {
 699             log.fine(&quot;setStrokeGradient(&quot; + gradient + &quot;)&quot;);
 700         }
 701         state.getStrokeNoClone().setPaint((Gradient) gradient.getPlatformGradient());
 702     }
 703 
 704     @Override
 705     public void setLineDash(float offset, float... sizes) {
 706         if (log.isLoggable(Level.FINE)) {
 707             StringBuilder s = new StringBuilder(&quot;[&quot;);
 708             for (int i=0; i &lt; sizes.length; i++) {
 709                 s.append(sizes[i]).append(&#39;,&#39;);
 710             }
 711             s.append(&#39;]&#39;);
 712             log.fine(&quot;setLineDash({0},{1}&quot;, new Object[] {offset, s});
 713         }
 714         state.getStrokeNoClone().setDashOffset(offset);
 715         if (sizes != null) {
 716             boolean allZero = true;
 717             for (int i = 0; i &lt; sizes.length; i++) {
 718                 if (sizes[i] != 0) {
 719                     allZero = false;
 720                     break;
 721                 }
 722             }
 723             if (allZero) {
 724                 sizes = null;
 725             }
 726         }
 727         state.getStrokeNoClone().setDashSizes(sizes);
 728     }
 729 
 730     @Override
 731     public void setLineCap(int lineCap) {
 732         if (log.isLoggable(Level.FINE)) {
 733             log.fine(&quot;setLineCap(&quot; + lineCap + &quot;)&quot;);
 734         }
 735         state.getStrokeNoClone().setLineCap(lineCap);
 736     }
 737 
 738     @Override
 739     public void setLineJoin(int lineJoin) {
 740         if (log.isLoggable(Level.FINE)) {
 741             log.fine(&quot;setLineJoin(&quot; + lineJoin + &quot;)&quot;);
 742         }
 743         state.getStrokeNoClone().setLineJoin(lineJoin);
 744     }
 745 
 746     @Override
 747     public void setMiterLimit(float miterLimit) {
 748         if (log.isLoggable(Level.FINE)) {
 749             log.fine(&quot;setMiterLimit(&quot; + miterLimit + &quot;)&quot;);
 750         }
 751         state.getStrokeNoClone().setMiterLimit(miterLimit);
 752     }
 753 
 754     @Override
 755     public void setShadow(float dx, float dy, float blur, int rgba) {
 756         if (log.isLoggable(Level.FINE)) {
 757             String format = &quot;setShadow(%f, %f, %f, 0x%x)&quot;;
 758             log.fine(String.format(format, dx, dy, blur, rgba));
 759         }
 760         state.setShadow(createShadow(dx, dy, blur, rgba));
 761     }
 762 
 763     @Override
 764     public void drawPolygon(final WCPath path, final boolean shouldAntialias) {
 765         if (log.isLoggable(Level.FINE)) {
 766             log.fine(&quot;drawPolygon({0})&quot;,
 767                     new Object[] {shouldAntialias});
 768         }
 769         if (!shouldRenderShape(((WCPathImpl)path).getPlatformPath(), null,
 770                                 state.getStrokeNoClone().getPlatformStroke()))
 771         {
 772             return;
 773         }
 774         new Composite() {
 775             @Override void doPaint(Graphics g) {
 776                 Path2D p2d = (Path2D) path.getPlatformPath();
 777                 g.setPaint(state.getPaintNoClone());
 778                 g.fill(p2d);
 779                 if (state.getStrokeNoClone().apply(g)) {
 780                     g.draw(p2d);
 781                 }
 782             }
 783         }.paint();
 784     }
 785 
 786     @Override
 787     public void drawLine(final int x0, final int y0, final int x1, final int y1) {
 788         if (log.isLoggable(Level.FINE)) {
 789             log.fine(&quot;drawLine({0}, {1}, {2}, {3})&quot;,
 790                     new Object[] {x0, y0, x1, y1});
 791         }
 792         Line2D line = new Line2D(x0, y0, x1, y1);
 793         if (!shouldRenderShape(line, null, state.getStrokeNoClone().getPlatformStroke())) {
 794             return;
 795         }
 796         new Composite() {
 797             @Override void doPaint(Graphics g) {
 798                 if (state.getStrokeNoClone().apply(g)) {
 799                     g.drawLine(x0, y0, x1, y1);
 800                 }
 801             }
 802         }.paint();
 803     }
 804 
 805     @Override
 806     public void drawPattern(
 807         final WCImage texture,
 808         final WCRectangle srcRect,
 809         final WCTransform patternTransform,
 810         final WCPoint phase,
 811         final WCRectangle destRect)
 812     {
 813         if (log.isLoggable(Level.FINE)) {
 814             log.fine(&quot;drawPattern({0}, {1}, {2}, {3})&quot;,
 815                     new Object[] {destRect.getIntX(), destRect.getIntY(),
 816                                   destRect.getIntWidth(),
 817                                   destRect.getIntHeight()});
 818         }
 819         if (!shouldRenderRect(destRect.getX(), destRect.getY(),
 820                               destRect.getWidth(), destRect.getHeight(), null, null))
 821         {
 822             return;
 823         }
 824         if (texture != null) {
 825             new Composite() {
 826                 @Override void doPaint(Graphics g) {
 827                     // The handling of pattern transform is modeled after the WebKit
 828                     // ImageCG.cpp&#39;s Image::drawPattern()
 829                     float adjustedX = phase.getX()
 830                             + srcRect.getX() * (float) patternTransform.getMatrix()[0];
 831                     float adjustedY = phase.getY()
 832                             + srcRect.getY() * (float) patternTransform.getMatrix()[3];
 833                     float scaledTileWidth =
 834                             srcRect.getWidth() * (float) patternTransform.getMatrix()[0];
 835                     float scaledTileHeight =
 836                             srcRect.getHeight() * (float) patternTransform.getMatrix()[3];
 837 
 838                     Image img = ((PrismImage)texture).getImage();
 839 
 840                     // Create subImage only if srcRect doesn&#39;t fit the texture bounds. See RT-20193.
 841                     if (!srcRect.contains(new WCRectangle(0, 0, texture.getWidth(), texture.getHeight()))) {
 842 
 843                         img = img.createSubImage(srcRect.getIntX(),
 844                                                  srcRect.getIntY(),
 845                                                  (int)Math.ceil(srcRect.getWidth()),
 846                                                  (int)Math.ceil(srcRect.getHeight()));
 847                     }
 848                     g.setPaint(new ImagePattern(
 849                                img,
 850                                adjustedX, adjustedY,
 851                                scaledTileWidth, scaledTileHeight,
 852                                false, false));
 853 
 854                     g.fillRect(destRect.getX(), destRect.getY(),
 855                                destRect.getWidth(), destRect.getHeight());
 856                 }
 857             }.paint();
 858         }
 859     }
 860 
 861     @Override
 862     public void drawImage(final WCImage img,
 863                           final float dstx, final float dsty, final float dstw, final float dsth,
 864                           final float srcx, final float srcy, final float srcw, final float srch)
 865     {
 866         if (log.isLoggable(Level.FINE)){
 867             log.fine(&quot;drawImage(img, dst({0},{1},{2},{3}), &quot; +
 868                     &quot;src({4},{5},{6},{7}))&quot;,
 869                     new Object[] {dstx, dsty, dstw, dsth,
 870                                   srcx, srcy, srcw, srch});
 871         }
 872         if (!shouldRenderRect(dstx, dsty, dstw, dsth, state.getShadowNoClone(), null)) {
 873             return;
 874         }
 875         if (img instanceof PrismImage) {
 876             new Composite() {
 877                 @Override void doPaint(Graphics g) {
 878                     PrismImage pi = (PrismImage) img;
 879                     DropShadow shadow = state.getShadowNoClone();
 880                     if (shadow != null) {
 881                         NGImageView node = new NGImageView();
 882                         node.setImage(pi.getImage());
 883                         node.setX(dstx);
 884                         node.setY(dsty);
 885                         node.setViewport(srcx, srcy, srcw, srch, dstw, dsth);
 886                         node.setContentBounds(new RectBounds(dstx, dsty, dstx + dstw, dsty + dsth));
 887                         render(g, shadow, null, null, node);
 888                     } else {
 889                         pi.draw(g,
 890                                 (int) dstx, (int) dsty,
 891                                 (int) (dstx + dstw), (int) (dsty + dsth),
 892                                 (int) srcx, (int) srcy,
 893                                 (int) (srcx + srcw), (int) (srcy + srch));
 894                     }
 895                 }
 896             }.paint();
 897         }
 898     }
 899 
 900     @Override
 901     public void drawBitmapImage(final ByteBuffer image, final int x, final int y, final int w, final int h) {
 902         if (!shouldRenderRect(x, y, w, h, null, null)) {
 903             return;
 904         }
 905         new Composite() {
 906             @Override void doPaint(Graphics g) {
 907                 image.order(ByteOrder.nativeOrder());
 908                 Image img = Image.fromByteBgraPreData(image, w, h);
 909                 ResourceFactory rf = g.getResourceFactory();
 910                 Texture txt = rf.createTexture(img, Texture.Usage.STATIC, Texture.WrapMode.REPEAT);
 911                 g.drawTexture(txt, x, y, x + w, y + h, 0, 0, w, h);
 912                 txt.dispose();
 913             }
 914         }.paint();
 915     }
 916 
 917     @Override
 918     public void drawIcon(WCIcon icon, int x, int y) {
 919         if (log.isLoggable(Level.FINE)) {
 920             log.fine(&quot;UNIMPLEMENTED drawIcon ({0}, {1})&quot;,
 921                     new Object[] {x, y});
 922         }
 923     }
 924 
 925     @Override
 926     public void drawRect(final int x, final int y, final int w, final int h) {
 927         if (log.isLoggable(Level.FINE)) {
 928             log.fine(&quot;drawRect({0}, {1}, {2}, {3})&quot;,
 929                     new Object[]{x, y, w, h});
 930         }
 931         if (!shouldRenderRect(x, y, w, h,
 932                               null, state.getStrokeNoClone().getPlatformStroke()))
 933         {
 934             return;
 935         }
 936         new Composite() {
 937             @Override void doPaint(Graphics g) {
 938                 Paint c = state.getPaintNoClone();
 939                 if (c != null &amp;&amp; c.isOpaque()) {
 940                     g.setPaint(c);
 941                     g.fillRect(x, y, w, h);
 942                 }
 943 
 944                 if (state.getStrokeNoClone().apply(g)) {
 945                     g.drawRect(x, y, w, h);
 946                 }
 947             }
 948         }.paint();
 949     }
 950 
 951     @Override
 952     public void drawString(final WCFont f, final int[] glyphs,
 953                            final float[] advances, final float x, final float y)
 954     {
 955         if (log.isLoggable(Level.FINE)) {
 956             log.fine(String.format(
 957                     &quot;Drawing %d glyphs @(%.1f, %.1f)&quot;,
 958                     glyphs.length, x, y));
 959         }
 960         PGFont font = (PGFont)f.getPlatformFont();
 961         TextRun gl = TextUtilities.createGlyphList(glyphs, advances, x, y);
 962 
 963         DropShadow shadow = state.getShadowNoClone();
 964         BasicStroke stroke = state.isTextStroke()
 965                 ? state.getStrokeNoClone().getPlatformStroke()
 966                 : null;
 967 
 968         final FontStrike strike = font.getStrike(getTransformNoClone(), getFontSmoothingType());
 969         if (shouldCalculateIntersection()) {
 970             Metrics m = strike.getMetrics();
 971             gl.setMetrics(m.getAscent(), m.getDescent(), m.getLineGap());
 972             if (!shouldRenderRect(x, y, gl.getWidth(), gl.getHeight(), shadow, stroke)) {
 973                 return;
 974             }
 975         }
 976         new Composite() {
 977             @Override void doPaint(Graphics g) {
 978                 Paint paint = state.isTextFill()
 979                         ? state.getPaintNoClone()
 980                         : null;
 981                 if (shadow != null) {
 982                     final NGText span = new NGText();
 983                     span.setGlyphs(new GlyphList[] {gl});
 984                     span.setFont(font);
 985                     span.setFontSmoothingType(fontSmoothingType);
 986                     render(g, shadow, paint, stroke, span);
 987                 } else {
 988                     if (paint != null) {
 989                         g.setPaint(paint);
 990                         g.drawString(gl, strike, x, y, null, 0, 0);
 991                     }
 992                     if (stroke != null) {
 993                         paint = state.getStrokeNoClone().getPaint();
 994                         if (paint != null) {
 995                             g.setPaint(paint);
 996                             g.setStroke(stroke);
 997                             g.draw(strike.getOutline(gl, BaseTransform.getTranslateInstance(x, y)));
 998                         }
 999                     }
1000                 }
1001             }
1002         }.paint();
1003     }
1004 
1005     @Override public void drawString(WCFont f, String str, boolean rtl,
1006             int from, int to, float x, float y)
1007     {
1008         if (log.isLoggable(Level.FINE)) {
1009             log.fine(String.format(
1010                     &quot;str=&#39;%s&#39; (length=%d), from=%d, to=%d, rtl=%b, @(%.1f, %.1f)&quot;,
1011                     str, str.length(), from, to, rtl, x, y));
1012         }
1013         TextLayout layout = TextUtilities.createLayout(
1014                 str.substring(from, to), f.getPlatformFont());
1015         int count = 0;
1016         GlyphList[] runs = layout.getRuns();
1017         for (GlyphList run: runs) {
1018             count += run.getGlyphCount();
1019         }
1020 
1021         int[] glyphs = new int[count];
1022         float[] adv = new float[count];
1023         count = 0;
1024         for (GlyphList run: layout.getRuns()) {
1025             int gc = run.getGlyphCount();
1026             for (int i = 0; i &lt; gc; i++) {
1027                 glyphs[count] = run.getGlyphCode(i);
1028                 adv[count] = run.getPosX(i + 1) - run.getPosX(i);
1029                 count++;
1030             }
1031         }
1032 
1033         // adjust x coordinate (see RT-29908)
1034         if (rtl) {
1035             x += (TextUtilities.getLayoutWidth(str.substring(from), f.getPlatformFont()) -
1036                   layout.getBounds().getWidth());
1037         } else {
1038             x += TextUtilities.getLayoutWidth(str.substring(0, from), f.getPlatformFont());
1039         }
1040         drawString(f, glyphs, adv, x, y);
1041     }
1042 
1043     @Override
1044     public void setComposite(int composite) {
1045         log.fine(&quot;setComposite({0})&quot;, composite);
1046         state.setCompositeOperation(composite);
1047     }
1048 
1049     @Override
1050     public void drawEllipse(final int x, final int y, final int w, final int h) {
1051         if (log.isLoggable(Level.FINE)) {
1052             log.fine(&quot;drawEllipse({0}, {1}, {2}, {3})&quot;,
1053                     new Object[] { x, y, w, h});
1054         }
1055         if (!shouldRenderRect(x, y, w, h,
1056                               null, state.getStrokeNoClone().getPlatformStroke()))
1057         {
1058             return;
1059         }
1060         new Composite() {
1061             @Override void doPaint(Graphics g) {
1062                 g.setPaint(state.getPaintNoClone());
1063                 g.fillEllipse(x, y, w, h);
1064                 if (state.getStrokeNoClone().apply(g)) {
1065                     g.drawEllipse(x, y, w, h);
1066                 }
1067             }
1068         }.paint();
1069     }
1070 
1071     private final static BasicStroke focusRingStroke =
1072         new BasicStroke(1.1f, BasicStroke.CAP_BUTT,
1073                          BasicStroke.JOIN_ROUND, 0.0f,
1074                          new float[] {1.0f}, 0.0f);
1075 
1076     @Override
1077     public void drawFocusRing(final int x, final int y, final int w, final int h, final int rgba) {
1078         if (log.isLoggable(Level.FINE)) {
1079             log.fine(String.format(&quot;drawFocusRing: %d, %d, %d, %d, 0x%x&quot;, x, y, w, h, rgba));
1080         }
1081         if (!shouldRenderRect(x, y, w, h, null, focusRingStroke)) {
1082             return;
1083         }
1084         new Composite() {
1085             @Override void doPaint(Graphics g) {
1086                 g.setPaint(createColor(rgba));
1087                 BasicStroke stroke = g.getStroke();
1088                 g.setStroke(focusRingStroke);
1089                 g.drawRoundRect(x, y, w, h, 4, 4);
1090                 g.setStroke(stroke);
1091             }
1092         }.paint();
1093     }
1094 
1095     public void setAlpha(float alpha) {
1096         log.fine(&quot;setAlpha({0})&quot;, alpha);
1097 
1098         state.setAlpha(alpha);
1099 
1100         if (null != cachedGraphics) {
1101             cachedGraphics.setExtraAlpha(state.getAlpha());
1102         }
1103     }
1104 
1105     public float getAlpha() {
1106         return state.getAlpha();
1107     }
1108 
1109     @Override public void beginTransparencyLayer(float opacity) {
1110         TransparencyLayer layer = new TransparencyLayer(
1111                 getGraphics(false), state.getClipNoClone(), opacity);
1112 
1113         if (log.isLoggable(Level.FINE)) {
1114             log.fine(String.format(&quot;beginTransparencyLayer(%s)&quot;, layer));
1115         }
1116 
1117         //[saveStateIntertal] will work as [saveState]
1118         state.markAsRestorePoint();
1119 
1120         startNewLayer(layer);
1121     }
1122 
1123     @Override public void endTransparencyLayer() {
1124         if (log.isLoggable(Level.FINE)) {
1125             log.fine(String.format(&quot;endTransparencyLayer(%s)&quot;, state.getLayerNoClone()));
1126         }
1127 
1128         //pair to [startNewLayer] that works as [saveState] call
1129         restoreState();
1130     }
1131 
1132     @Override
1133     public void drawWidget(final RenderTheme theme, final Ref widget, final int x, final int y) {
1134         WCSize s = theme.getWidgetSize(widget);
1135         if (!shouldRenderRect(x, y, s.getWidth(), s.getHeight(), null, null)) {
1136             return;
1137         }
1138         new Composite() {
1139             @Override void doPaint(Graphics g) {
1140                 theme.drawWidget(WCGraphicsPrismContext.this, widget, x, y);
1141             }
1142         }.paint();
1143     }
1144 
1145     @Override
1146     public void drawScrollbar(final ScrollBarTheme theme, final Ref widget, int x, int y,
1147                               int pressedPart, int hoveredPart)
1148     {
1149         if (log.isLoggable(Level.FINE)) {
1150             log.fine(String.format(&quot;drawScrollbar(%s, %s, x = %d, y = %d)&quot;, theme, widget, x, y));
1151         }
1152 
1153         WCSize s = theme.getWidgetSize(widget);
1154         if (!shouldRenderRect(x, y, s.getWidth(), s.getHeight(), null, null)) {
1155             return;
1156         }
1157         new Composite() {
1158             @Override void doPaint(Graphics g) {
1159                 theme.paint(WCGraphicsPrismContext.this, widget, x, y, pressedPart, hoveredPart);
1160             }
1161         }.paint();
1162     }
1163 
1164     private static Rectangle intersect(Rectangle what, Rectangle with) {
1165         if (what == null) {
1166             return with;
1167         }
1168         RectBounds b = what.toRectBounds();
1169         b.intersectWith(with);
1170         what.setBounds(b);
1171         return what;
1172     }
1173 
1174     static Color createColor(int rgba) {
1175         float a = (0xFF &amp; (rgba &gt;&gt; 24)) / 255.0f;
1176         float r = (0xFF &amp; (rgba &gt;&gt; 16)) / 255.0f;
1177         float g = (0xFF &amp; (rgba &gt;&gt; 8)) / 255.0f;
1178         float b = (0xFF &amp; (rgba)) / 255.0f;
1179         return new Color(r, g, b, a);
1180     }
1181 
1182     private static Color4f createColor4f(int rgba) {
1183         float a = (0xFF &amp; (rgba &gt;&gt; 24)) / 255.0f;
1184         float r = (0xFF &amp; (rgba &gt;&gt; 16)) / 255.0f;
1185         float g = (0xFF &amp; (rgba &gt;&gt; 8)) / 255.0f;
1186         float b = (0xFF &amp; (rgba)) / 255.0f;
1187         return new Color4f(r, g, b, a);
1188     }
1189 
1190     private DropShadow createShadow(float dx, float dy, float blur, int rgba) {
1191         if (dx == 0f &amp;&amp; dy == 0f &amp;&amp; blur == 0f) {
1192             return null;
1193         }
1194         DropShadow shadow = new DropShadow();
1195         shadow.setOffsetX((int) dx);
1196         shadow.setOffsetY((int) dy);
1197         shadow.setRadius((blur &lt; 0f) ? 0f : (blur &gt; 127f) ? 127f : blur);
1198         shadow.setColor(createColor4f(rgba));
1199         return shadow;
1200     }
1201 
1202     private void render(Graphics g, Effect effect, Paint paint, BasicStroke stroke, NGNode node) {
1203         if (node instanceof NGShape) {
1204             NGShape shape = (NGShape) node;
1205             Shape realShape = shape.getShape();
1206             Paint strokePaint = state.getStrokeNoClone().getPaint();
1207             if ((stroke != null) &amp;&amp; (strokePaint != null)) {
1208                 realShape = stroke.createStrokedShape(realShape);
1209                 shape.setDrawStroke(stroke);
1210                 shape.setDrawPaint(strokePaint);
1211                 shape.setMode((paint == null) ? NGShape.Mode.STROKE : NGShape.Mode.STROKE_FILL);
1212             } else {
1213                 shape.setMode((paint == null) ? NGShape.Mode.EMPTY : NGShape.Mode.FILL);
1214             }
1215             shape.setFillPaint(paint);
1216             shape.setContentBounds(realShape.getBounds());
1217         }
1218         boolean culling = g.hasPreCullingBits();
1219         g.setHasPreCullingBits(false);
1220         node.setEffect(effect);
1221         node.render(g);
1222         g.setHasPreCullingBits(culling);
1223     }
1224 
1225     private static final class ContextState {
1226         private final WCStrokeImpl stroke = new WCStrokeImpl();
1227         private Rectangle clip;
1228         private Paint paint;
1229         private float alpha;
1230 
1231         private boolean textFill = true;
1232         private boolean textStroke = false;
1233         private boolean textClip = false;
1234         private boolean restorePoint = false;
1235 
1236         private DropShadow shadow;
1237         private Affine3D xform;
1238         private GeneralTransform3D perspectiveTransform;
1239         private Layer layer;
1240         private int compositeOperation;
1241         private WCImage clipMaskImage;
1242 
1243         private ContextState() {
1244             clip = null;
1245             paint = Color.BLACK;
1246             stroke.setPaint(Color.BLACK);
1247             alpha = 1.0f;
1248             xform = new Affine3D();
1249             perspectiveTransform = new GeneralTransform3D();
1250             compositeOperation = COMPOSITE_SOURCE_OVER;
1251         }
1252 
1253         private ContextState(ContextState state) {
1254             stroke.copyFrom(state.getStrokeNoClone());
1255             setPaint(state.getPaintNoClone());
1256             clip = state.getClipNoClone();
1257             if (clip != null) {
1258                 clip = new Rectangle(clip);
1259             }
1260             xform = new Affine3D(state.getTransformNoClone());
1261             perspectiveTransform = new GeneralTransform3D().set(state.getPerspectiveTransformNoClone());
1262             setShadow(state.getShadowNoClone());
1263             setLayer(state.getLayerNoClone());
1264             setAlpha(state.getAlpha());
1265             setTextMode(state.isTextFill(), state.isTextStroke(), state.isTextClip());
1266             setCompositeOperation(state.getCompositeOperation());
1267             setClipMaskImage(state.getClipMaskImageNoClone());
1268         }
1269 
1270         @Override
1271         protected ContextState clone() {
1272             return new ContextState(this);
1273         }
1274 
1275         private void apply(Graphics g) {
1276             g.setTransform(getTransformNoClone());
1277             g.setPerspectiveTransform(getPerspectiveTransformNoClone());
1278             g.setClipRect(getClipNoClone());
1279             g.setExtraAlpha(getAlpha());
1280         }
1281 
1282         private int getCompositeOperation() {
1283             return compositeOperation;
1284         }
1285 
1286         private void setCompositeOperation(int compositeOperation) {
1287             this.compositeOperation = compositeOperation;
1288         }
1289 
1290         private WCStrokeImpl getStrokeNoClone() {
1291             return stroke;
1292         }
1293 
1294         private Paint getPaintNoClone() {
1295             return paint;
1296         }
1297 
1298         private void setPaint(Paint paint) {
1299             this.paint = paint;
1300         }
1301 
1302         private void setClipMaskImage(WCImage image) {
1303             this.clipMaskImage = image;
1304         }
1305 
1306         private WCImage getClipMaskImageNoClone() {
1307             return clipMaskImage;
1308         }
1309 
1310         private Rectangle getClipNoClone() {
1311             return clip;
1312         }
1313 
1314         private Layer getLayerNoClone() {
1315             return layer;
1316         }
1317 
1318         private void setLayer(Layer layer) {
1319             this.layer = layer;
1320         }
1321 
1322         private void setClip(Rectangle area) {
1323             clip = area;
1324         }
1325 
1326         private void clip(Rectangle area) {
1327             if (null == clip) {
1328                 clip = area;
1329             } else {
1330                 clip.intersectWith(area);
1331             }
1332         }
1333 
1334         private void setAlpha(float alpha) {
1335             this.alpha = alpha;
1336         }
1337 
1338         private float getAlpha() {
1339             return alpha;
1340         }
1341 
1342         private void setTextMode(boolean fill, boolean stroke, boolean clip) {
1343             textFill = fill;
1344             textStroke = stroke;
1345             textClip = clip;
1346         }
1347 
1348         private boolean isTextFill() {
1349             return textFill;
1350         }
1351 
1352         private boolean isTextStroke() {
1353             return textStroke;
1354         }
1355 
1356         private boolean isTextClip() {
1357             return textClip;
1358         }
1359 
1360         private void markAsRestorePoint() {
1361             restorePoint = true;
1362         }
1363 
1364         private boolean isRestorePoint() {
1365             return restorePoint;
1366         }
1367 
1368         private void setShadow(DropShadow shadow) {
1369             this.shadow = shadow;
1370         }
1371 
1372         private DropShadow getShadowNoClone() {
1373             return shadow;
1374         }
1375 
1376         private Affine3D getTransformNoClone() {
1377             return xform;
1378         }
1379 
1380         private GeneralTransform3D getPerspectiveTransformNoClone() {
1381             return perspectiveTransform;
1382         }
1383 
1384         private void setTransform(final Affine3D at) {
1385             this.xform.setTransform(at);
1386         }
1387 
1388         private void setPerspectiveTransform(final GeneralTransform3D gt) {
1389             this.perspectiveTransform.set(gt);
1390         }
1391 
1392         private void concatTransform(Affine3D at) {
1393             xform.concatenate(at);
1394         }
1395 
1396         private void translate(double dx, double dy) {
1397             xform.translate(dx, dy);
1398         }
1399 
1400         private void scale(double sx, double sy) {
1401             xform.scale(sx,sy);
1402         }
1403 
1404         private void rotate(double radians) {
1405             xform.rotate(radians);
1406         }
1407     }
1408 
1409     private abstract static class Layer {
1410         FilterContext fctx;
1411         PrDrawable buffer;
1412         Graphics graphics;
1413         final Rectangle bounds;
1414         boolean permanent;
1415 
1416         Layer(Graphics g, Rectangle bounds, boolean permanent) {
1417             this.bounds = new Rectangle(bounds);
1418             this.permanent = permanent;
1419 
1420             // avoid creating zero-size drawable, see also RT-21410
1421             int w = Math.max(bounds.width, 1);
1422             int h = Math.max(bounds.height, 1);
1423             fctx = getFilterContext(g);
1424             if (permanent) {
1425                 ResourceFactory f = GraphicsPipeline.getDefaultResourceFactory();
1426                 RTTexture rtt = f.createRTTexture(w, h, Texture.WrapMode.CLAMP_NOT_NEEDED);
1427                 rtt.makePermanent();
1428                 buffer = ((PrRenderer)Renderer.getRenderer(fctx)).createDrawable(rtt);
1429             } else {
1430                 buffer = (PrDrawable) Effect.getCompatibleImage(fctx, w, h);
1431             }
1432         }
1433 
1434         Graphics getGraphics() {
1435             if (graphics == null) {
1436                 graphics = buffer.createGraphics();
1437             }
1438             return graphics;
1439         }
1440 
1441         abstract void init(Graphics g);
1442 
1443         abstract void render(Graphics g);
1444 
1445         private void dispose() {
1446             if (buffer != null) {
1447                 if (permanent) {
1448                     buffer.flush(); // releases the resource
1449                 } else {
1450                     Effect.releaseCompatibleImage(fctx, buffer);
1451                 }
1452                 fctx = null;
1453                 buffer = null;
1454             }
1455         }
1456 
1457         private double getX() { return (double) bounds.x; }
1458         private double getY() { return (double) bounds.y; }
1459     }
1460 
1461     private final class TransparencyLayer extends Layer {
1462         private final float opacity;
1463 
1464         private TransparencyLayer(Graphics g, Rectangle bounds, float opacity) {
1465             super(g, bounds, false);
1466             this.opacity = opacity;
1467         }
1468 
1469         @Override void init(Graphics g) {
1470             state.setCompositeOperation(COMPOSITE_SOURCE_OVER);
1471         }
1472 
1473         @Override void render(Graphics g) {
1474             new Composite() {
1475                 @Override void doPaint(Graphics g) {
1476                     float op = g.getExtraAlpha();
1477                     g.setExtraAlpha(opacity);
1478                     Affine3D tx = new Affine3D(g.getTransformNoClone());
1479                     g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
1480                     g.drawTexture(buffer.getTextureObject(),
1481                             bounds.x, bounds.y, bounds.width, bounds.height);
1482                     g.setTransform(tx);
1483                     g.setExtraAlpha(op);
1484                 }
1485             }.paint(g);
1486         }
1487 
1488         @Override public String toString() {
1489             return String.format(&quot;TransparencyLayer[%d,%d + %dx%d, opacity %.2f]&quot;,
1490                 bounds.x, bounds.y, bounds.width, bounds.height, opacity);
1491         }
1492     }
1493 
1494     private static final class ClipLayer extends Layer {
1495         private final WCPath normalizedToClipPath;
1496         private boolean srcover;
1497 
1498         private ClipLayer(Graphics g, Rectangle bounds, WCPath normalizedToClipPath,
1499                           boolean permanent)
1500         {
1501             super(g, bounds, permanent);
1502             this.normalizedToClipPath = normalizedToClipPath;
1503             srcover = true;
1504         }
1505 
1506         @Override void init(Graphics g) {
1507             RTTexture texture = null;
1508             ReadbackGraphics readbackGraphics = null;
1509             try {
1510                 readbackGraphics = (ReadbackGraphics) g;
1511                 texture = readbackGraphics.readBack(bounds);
1512                 getGraphics().drawTexture(texture, 0, 0, bounds.width, bounds.height);
1513             } finally {
1514                 if (readbackGraphics != null &amp;&amp; texture != null) {
1515                     readbackGraphics.releaseReadBackBuffer(texture);
1516                 }
1517             }
1518             srcover = false;
1519         }
1520 
1521         @Override void render(Graphics g) {
1522             Path2D p2d = ((WCPathImpl)normalizedToClipPath).getPlatformPath();
1523 
1524             // render normalizedToClipPath to a drawable
1525             PrDrawable bufferImg = (PrDrawable) Effect.getCompatibleImage(
1526                     fctx, bounds.width, bounds.height);
1527             Graphics bufferGraphics = bufferImg.createGraphics();
1528 
1529             bufferGraphics.setPaint(Color.BLACK);
1530             bufferGraphics.fill(p2d);
1531 
1532             // blend buffer and clipImg onto |g|
1533             if (g instanceof MaskTextureGraphics &amp;&amp; ! (g instanceof PrinterGraphics)) {
1534                 MaskTextureGraphics mg = (MaskTextureGraphics) g;
1535                 if (srcover) {
1536                     mg.drawPixelsMasked(buffer.getTextureObject(),
1537                                         bufferImg.getTextureObject(),
1538                                         bounds.x, bounds.y, bounds.width, bounds.height,
1539                                         0, 0, 0, 0);
1540                 } else {
1541                     mg.maskInterpolatePixels(buffer.getTextureObject(),
1542                                              bufferImg.getTextureObject(),
1543                                              bounds.x, bounds.y, bounds.width, bounds.height,
1544                                              0, 0, 0, 0);
1545                 }
1546             } else {
1547                 Blend blend = new Blend(Blend.Mode.SRC_IN,
1548                         new PassThrough(bufferImg, bounds.width, bounds.height),
1549                         new PassThrough(buffer, bounds.width, bounds.height));
1550                 Affine3D tx = new Affine3D(g.getTransformNoClone());
1551                 g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
1552                 PrEffectHelper.render(blend, g, bounds.x, bounds.y, null);
1553                 g.setTransform(tx);
1554             }
1555 
1556             Effect.releaseCompatibleImage(fctx, bufferImg);
1557         }
1558 
1559         @Override public String toString() {
1560             return String.format(&quot;ClipLayer[%d,%d + %dx%d, path %s]&quot;,
1561                     bounds.x, bounds.y, bounds.width, bounds.height,
1562                     normalizedToClipPath);
1563         }
1564     }
1565 
1566     private abstract class Composite {
1567         abstract void doPaint(Graphics g);
1568 
1569         void paint() {
1570             paint(getGraphics(true));
1571         }
1572 
1573         void paint(Graphics g) {
1574             if (g != null) {
1575                 CompositeMode oldCompositeMode = g.getCompositeMode();
1576                 switch (state.getCompositeOperation()) {
1577                     // decode operations that don&#39;t require Blend first
1578                     case COMPOSITE_COPY:
1579                         g.setCompositeMode(CompositeMode.SRC);
1580                         doPaint(g);
1581                         g.setCompositeMode(oldCompositeMode);
1582                         break;
1583                     case COMPOSITE_SOURCE_OVER:
1584                         g.setCompositeMode(CompositeMode.SRC_OVER);
1585                         doPaint(g);
1586                         g.setCompositeMode(oldCompositeMode);
1587                         break;
1588                     default:
1589                         // other operations require usage of Blend
1590                         blend(g);
1591                         break;
1592                 }
1593                 isRootLayerValid = false;
1594             }
1595         }
1596 
1597         private void blend(Graphics g) {
1598             FilterContext fctx = getFilterContext(g);
1599             PrDrawable dstImg = null;
1600             PrDrawable srcImg = null;
1601             ReadbackGraphics readBackGraphics = null;
1602             RTTexture texture = null;
1603             Rectangle clip = state.getClipNoClone();
1604             WCImage image = getImage();
1605             try {
1606                 if (image != null &amp;&amp; image instanceof PrismImage) {
1607                     // blending on canvas
1608                     dstImg = (PrDrawable) Effect.getCompatibleImage(fctx, clip.width, clip.height);
1609                     Graphics dstG = dstImg.createGraphics();
1610                     ((PrismImage) image).draw(dstG,
1611                             0, 0, clip.width, clip.height,
1612                             clip.x, clip.y, clip.width, clip.height);
1613                 } else {
1614                     // blending on page
1615                     readBackGraphics = (ReadbackGraphics) g;
1616                     texture = readBackGraphics.readBack(clip);
1617                     dstImg = PrDrawable.create(fctx, texture);
1618                 }
1619 
1620                 srcImg = (PrDrawable) Effect.getCompatibleImage(fctx, clip.width, clip.height);
1621                 Graphics srcG = srcImg.createGraphics();
1622                 state.apply(srcG);
1623                 doPaint(srcG);
1624 
1625                 g.clear();
1626                 PrEffectHelper.render(createEffect(dstImg, srcImg, clip.width, clip.height), g, 0, 0, null);
1627 
1628             } finally {
1629                 if (srcImg != null) {
1630                     Effect.releaseCompatibleImage(fctx, srcImg);
1631                 }
1632                 if (dstImg != null) {
1633                     if (readBackGraphics != null &amp;&amp; texture != null) {
1634                         readBackGraphics.releaseReadBackBuffer(texture);
1635                     } else {
1636                         Effect.releaseCompatibleImage(fctx, dstImg);
1637                     }
1638                 }
1639             }
1640         }
1641 
1642         // provides some syntax sugar for createEffect()
1643         private Effect createBlend(Blend.Mode mode,
1644                                    PrDrawable dstImg,
1645                                    PrDrawable srcImg,
1646                                    int width,
1647                                    int height)
1648         {
1649             return new Blend(
1650                     mode,
1651                     new PassThrough(dstImg, width, height),
1652                     new PassThrough(srcImg, width, height));
1653         }
1654 
1655         private Effect createEffect(PrDrawable dstImg,
1656                                     PrDrawable srcImg,
1657                                     int width,
1658                                     int height)
1659         {
1660             switch (state.getCompositeOperation()) {
1661                 case COMPOSITE_CLEAR: // same as xor
1662                 case COMPOSITE_XOR:
1663                     return new Blend(
1664                             SRC_OVER,
1665                             createBlend(SRC_OUT, dstImg, srcImg, width, height),
1666                             createBlend(SRC_OUT, srcImg, dstImg, width, height)
1667                     );
1668                 case COMPOSITE_SOURCE_IN:
1669                     return createBlend(SRC_IN, dstImg, srcImg, width, height);
1670                 case COMPOSITE_SOURCE_OUT:
1671                     return createBlend(SRC_OUT, dstImg, srcImg, width, height);
1672                 case COMPOSITE_SOURCE_ATOP:
1673                     return createBlend(SRC_ATOP, dstImg, srcImg, width, height);
1674                 case COMPOSITE_DESTINATION_OVER:
1675                     return createBlend(SRC_OVER, srcImg, dstImg, width, height);
1676                 case COMPOSITE_DESTINATION_IN:
1677                     return createBlend(SRC_IN, srcImg, dstImg, width, height);
1678                 case COMPOSITE_DESTINATION_OUT:
1679                     return createBlend(SRC_OUT, srcImg, dstImg, width, height);
1680                 case COMPOSITE_DESTINATION_ATOP:
1681                     return createBlend(SRC_ATOP, srcImg, dstImg, width, height);
1682                 case COMPOSITE_HIGHLIGHT:
1683                     return createBlend(ADD, dstImg, srcImg, width, height);
1684                 default:
1685                     return createBlend(SRC_OVER, dstImg, srcImg, width, height);
1686             }
1687         }
1688     }
1689 
1690     private static final class PassThrough extends Effect {
1691         private final PrDrawable img;
1692         private final int width;
1693         private final int height;
1694 
1695         private PassThrough(PrDrawable img, int width, int height) {
1696             this.img = img;
1697             this.width = width;
1698             this.height = height;
1699         }
1700 
1701         @Override public ImageData filter(
1702                 FilterContext fctx,
1703                 BaseTransform transform,
1704                 Rectangle outputClip,
1705                 Object renderHelper,
1706                 Effect defaultInput) {
1707             // We have an unpaired lock() here, because unlocking is done
1708             // internally by ImageData. See RT-33625 for details.
1709             img.lock();
1710             ImageData imgData = new ImageData(fctx, img, new Rectangle(
1711                                               (int) transform.getMxt(),
1712                                               (int) transform.getMyt(),
1713                                               width, height));
1714             imgData.setReusable(true);
1715             return imgData;
1716         }
1717 
1718         @Override public RectBounds getBounds(
1719                 BaseTransform transform,
1720                 Effect defaultInput) {
1721             return null;
1722         }
1723 
1724         @Override public AccelType getAccelType(FilterContext fctx) {
1725             return AccelType.INTRINSIC;
1726         }
1727 
1728         @Override
1729         public boolean reducesOpaquePixels() {
1730             return false;
1731         }
1732 
1733         @Override
1734         public DirtyRegionContainer getDirtyRegions(Effect defaultInput, DirtyRegionPool regionPool) {
1735             return null;
1736         }
1737     }
1738 
1739     private static FilterContext getFilterContext(Graphics g) {
1740         Screen screen = g.getAssociatedScreen();
1741         if (screen == null) {
1742             ResourceFactory factory = g.getResourceFactory();
1743             return PrFilterContext.getPrinterContext(factory);
1744         } else {
1745             return PrFilterContext.getInstance(screen);
1746         }
1747     }
1748 
1749     @Override
1750     public void strokeArc(final int x, final int y, final int w, final int h,
1751                           final int startAngle, final int angleSpan)
1752     {
1753         if (log.isLoggable(Level.FINE)) {
1754             log.fine(String.format(&quot;strokeArc(%d, %d, %d, %d, %d, %d)&quot;,
1755                                    x, y, w, h, startAngle, angleSpan));
1756         }
1757         Arc2D arc = new Arc2D(x, y, w, h, startAngle, angleSpan, Arc2D.OPEN);
1758         if (state.getStrokeNoClone().isApplicable() &amp;&amp;
1759             !shouldRenderShape(arc, null, state.getStrokeNoClone().getPlatformStroke()))
1760         {
1761             return;
1762         }
1763         new Composite() {
1764             @Override void doPaint(Graphics g) {
1765                 if (state.getStrokeNoClone().apply(g)) {
1766                     g.draw(arc);
1767                 }
1768             }
1769         }.paint();
1770     }
1771 
1772     @Override
1773     public WCImage getImage() {
1774         return null;
1775     }
1776 
1777     @Override
1778     public void strokeRect(final float x, final float y, final float w, final float h,
1779                            final float lineWidth) {
1780         if (log.isLoggable(Level.FINE)) {
1781             log.fine(String.format(&quot;strokeRect_FFFFF(%f, %f, %f, %f, %f)&quot;,
1782                                    x, y, w, h, lineWidth));
1783         }
1784         BasicStroke stroke = new BasicStroke(
1785             lineWidth,
1786             BasicStroke.CAP_BUTT,
1787             BasicStroke.JOIN_MITER,
1788             Math.max(1.0f, lineWidth),
1789             state.getStrokeNoClone().getDashSizes(),
1790             state.getStrokeNoClone().getDashOffset());
1791 
1792         if (!shouldRenderRect(x, y, w, h, null, stroke)) {
1793             return;
1794         }
1795         new Composite() {
1796             @Override void doPaint(Graphics g) {
1797                 g.setStroke(stroke);
1798                 Paint paint = state.getStrokeNoClone().getPaint();
1799                 if (paint == null) {
1800                     paint = state.getPaintNoClone();
1801                 }
1802                 g.setPaint(paint);
1803                 g.drawRect(x, y, w, h);
1804             }
1805         }.paint();
1806     }
1807 
1808     @Override
1809     public void strokePath(final WCPath path) {
1810         log.fine(&quot;strokePath&quot;);
1811         if (path != null) {
1812             final BasicStroke stroke = state.getStrokeNoClone().getPlatformStroke();
1813             final DropShadow shadow = state.getShadowNoClone();
1814             final Path2D p2d = (Path2D)path.getPlatformPath();
1815 
1816             if ((stroke == null &amp;&amp; shadow == null) ||
1817                 !shouldRenderShape(p2d, shadow, stroke))
1818             {
1819                 return;
1820             }
1821             new Composite() {
1822                 @Override void doPaint(Graphics g) {
1823                     if (shadow != null) {
1824                         final NGPath node = new NGPath();
1825                         node.updateWithPath2d(p2d);
1826                         render(g, shadow, null, stroke, node);
1827                     } else if (stroke != null) {
1828                         Paint paint = state.getStrokeNoClone().getPaint();
1829                         if (paint == null) {
1830                             paint = state.getPaintNoClone();
1831                         }
1832                         g.setPaint(paint);
1833                         g.setStroke(stroke);
1834                         g.draw(p2d);
1835                     }
1836                 }
1837             }.paint();
1838         }
1839     }
1840 
1841     @Override
1842     public void fillPath(final WCPath path) {
1843         log.fine(&quot;fillPath&quot;);
1844         if (path != null) {
1845             if (!shouldRenderShape(((WCPathImpl)path).getPlatformPath(),
1846                                    state.getShadowNoClone(), null))
1847             {
1848                 return;
1849             }
1850             new Composite() {
1851                 @Override void doPaint(Graphics g) {
1852                     Path2D p2d = (Path2D) path.getPlatformPath();
1853                     Paint paint = state.getPaintNoClone();
1854                     DropShadow shadow = state.getShadowNoClone();
1855                     if (shadow != null) {
1856                         final NGPath node = new NGPath();
1857                         node.updateWithPath2d(p2d);
1858                         render(g, shadow, paint, null, node);
1859                     } else {
1860                         g.setPaint(paint);
1861                         g.fill(p2d);
1862                     }
1863                 }
1864             }.paint();
1865         }
1866     }
1867 
1868     public void setPerspectiveTransform(WCTransform tm) {
1869         final GeneralTransform3D at = new GeneralTransform3D().set(tm.getMatrix());
1870         state.setPerspectiveTransform(at);
1871         resetCachedGraphics();
1872     }
1873 
1874     public void setTransform(WCTransform tm) {
1875         final double m[] = tm.getMatrix();
1876         final Affine3D at = new Affine3D(new Affine2D(m[0], m[1], m[2], m[3], m[4], m[5]));
1877         if (state.getLayerNoClone() == null) {
1878             at.preConcatenate(baseTransform);
1879         }
1880         state.setTransform(at);
1881         resetCachedGraphics();
1882     }
1883 
1884     public WCTransform getTransform() {
1885         Affine3D xf = state.getTransformNoClone();
1886         return new WCTransform(xf.getMxx(), xf.getMyx(),
1887                                xf.getMxy(), xf.getMyy(),
1888                                xf.getMxt(), xf.getMyt());
1889     }
1890 
1891     public void concatTransform(WCTransform tm) {
1892         double m[] = tm.getMatrix();
1893         Affine3D at = new Affine3D(new Affine2D(m[0], m[1], m[2], m[3], m[4], m[5]));
1894         state.concatTransform(at);
1895         resetCachedGraphics();
1896     }
1897 
1898     @Override
1899     public void flush() {
1900         flushAllLayers();
1901     }
1902 
1903     @Override
1904     public WCGradient createLinearGradient(WCPoint p1, WCPoint p2) {
1905         return new WCLinearGradient(p1, p2);
1906     }
1907 
1908     @Override
1909     public WCGradient createRadialGradient(WCPoint p1, float r1, WCPoint p2, float r2) {
1910         return new WCRadialGradient(p1, r1, p2, r2);
1911     }
1912 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/java/com/sun/javafx/webkit/prism/WCGraphicsPrismContext.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.javafx.webkit.prism;
  27 
  28 import com.sun.glass.ui.Screen;
  29 import com.sun.javafx.font.FontStrike;
  30 import com.sun.javafx.font.Metrics;
  31 import com.sun.javafx.font.PGFont;
  32 import com.sun.javafx.geom.*;
  33 import com.sun.javafx.geom.transform.Affine2D;
  34 import com.sun.javafx.geom.transform.Affine3D;
  35 import com.sun.javafx.geom.transform.BaseTransform;
  36 import com.sun.javafx.geom.transform.GeneralTransform3D;
  37 import com.sun.javafx.logging.PlatformLogger;
  38 import com.sun.javafx.logging.PlatformLogger.Level;
  39 import com.sun.javafx.scene.text.GlyphList;
  40 import com.sun.javafx.scene.text.TextLayout;
  41 import com.sun.javafx.sg.prism.*;
  42 import com.sun.javafx.text.TextRun;
  43 import com.sun.prism.*;
  44 import com.sun.prism.paint.Color;
  45 import com.sun.prism.paint.Gradient;
  46 import com.sun.prism.paint.ImagePattern;
  47 import com.sun.prism.paint.Paint;
  48 import com.sun.scenario.effect.*;
  49 import com.sun.scenario.effect.impl.prism.PrDrawable;
  50 import com.sun.scenario.effect.impl.prism.PrEffectHelper;
  51 import com.sun.scenario.effect.impl.prism.PrFilterContext;
  52 import com.sun.webkit.graphics.*;
  53 
  54 import java.nio.ByteBuffer;
  55 import java.nio.ByteOrder;
  56 import java.security.AccessController;
  57 import java.security.PrivilegedAction;
  58 import java.util.ArrayList;
  59 import java.util.List;
  60 
  61 import static com.sun.scenario.effect.Blend.Mode.*;
  62 import com.sun.scenario.effect.impl.Renderer;
  63 import com.sun.scenario.effect.impl.prism.PrRenderer;
  64 
  65 class WCGraphicsPrismContext extends WCGraphicsContext {
  66 
  67     public enum Type {
  68         /**
  69          * Base context associated with the topmost page buffer.
  70          * Created and disposed during a single render pass.
  71          */
  72         PRIMARY,
  73 
  74         /**
  75          * A context associated with a dedicated buffer representing
  76          * a separate render target like canvas, buffered image etc.
  77          * Its life cycle is not limited to a single render pass.
  78          */
  79         DEDICATED
  80     }
  81 
  82     private final static PlatformLogger log =
  83             PlatformLogger.getLogger(WCGraphicsPrismContext.class.getName());
  84     private final static boolean DEBUG_DRAW_CLIP_SHAPE = Boolean.valueOf(
  85             AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) () -&gt;
  86             System.getProperty(&quot;com.sun.webkit.debugDrawClipShape&quot;, &quot;false&quot;)));
  87 
  88     Graphics baseGraphics;
  89     private BaseTransform baseTransform;
  90 
  91     private final List&lt;ContextState&gt; states = new ArrayList&lt;ContextState&gt;();
  92 
  93     private ContextState state = new ContextState();
  94 
  95     // Cache for getPlatformGraphics
  96     private Graphics cachedGraphics = null;
  97 
  98     private int fontSmoothingType;
  99     private boolean isRootLayerValid = false;
 100 
 101     WCGraphicsPrismContext(Graphics g) {
 102         state.setClip(g.getClipRect());
 103         state.setAlpha(g.getExtraAlpha());
 104         baseGraphics = g;
 105         initBaseTransform(g.getTransformNoClone());
 106     }
 107 
 108     WCGraphicsPrismContext() {
 109     }
 110 
 111     public Type type() {
 112         return Type.PRIMARY;
 113     }
 114 
 115     final void initBaseTransform(BaseTransform t) {
 116         baseTransform = new Affine3D(t);
 117         state.setTransform((Affine3D)baseTransform);
 118     }
 119 
 120     private void resetCachedGraphics() {
 121         cachedGraphics = null;
 122     }
 123 
 124     @Override
 125     public Object getPlatformGraphics() {
 126         return getGraphics(false);
 127     }
 128 
 129     Graphics getGraphics(boolean checkClip) {
 130         if (cachedGraphics == null) {
 131             Layer l = state.getLayerNoClone();
 132             cachedGraphics = (l != null)
 133                     ? l.getGraphics()
 134                     : baseGraphics;
 135 
 136             state.apply(cachedGraphics);
 137 
 138             if (log.isLoggable(Level.FINE)) {
 139                 log.fine(&quot;getPlatformGraphics for &quot; + this + &quot; : &quot; +
 140                          cachedGraphics);
 141             }
 142         }
 143 
 144         Rectangle clip = cachedGraphics.getClipRectNoClone();
 145         return (checkClip &amp;&amp; clip!=null &amp;&amp; clip.isEmpty())
 146             ? null
 147             : cachedGraphics;
 148     }
 149 
 150     public void saveState()
 151     {
 152         state.markAsRestorePoint();
 153         saveStateInternal();
 154     }
 155 
 156     private void saveStateInternal()
 157     {
 158         states.add(state);
 159         state = state.clone();
 160     }
 161 
 162     private void startNewLayer(Layer layer) {
 163         saveStateInternal();
 164 
 165         // layer has the same bounds as clip, so we have to translate
 166         Rectangle clip = state.getClipNoClone();
 167 
 168         //left-side (post-) translate.
 169         //NB! an order of transforms is essential!
 170         Affine3D newTr = new Affine3D(BaseTransform.getTranslateInstance(
 171                 -clip.x,
 172                 -clip.y));
 173         newTr.concatenate(state.getTransformNoClone());
 174 
 175         //move clip to (0, 0) - start of texture
 176         clip.x = 0;
 177         clip.y = 0;
 178         //no-clone - no-set!
 179 
 180         Graphics g = getGraphics(true);
 181         if (g != null &amp;&amp; g != baseGraphics) {
 182             layer.init(g);
 183         }
 184 
 185         state.setTransform(newTr);
 186         state.setLayer(layer);
 187 
 188         resetCachedGraphics();
 189     }
 190 
 191     private void renderLayer(final Layer layer) {
 192         WCTransform cur = getTransform();
 193 
 194         //translate to (layer.getX(), layer.getY())
 195         setTransform(new WCTransform(
 196             1.0, 0.0,
 197             0.0, 1.0,
 198             layer.getX(), layer.getY()));
 199 
 200         // composite drawing delegated to the layer rendering
 201         Graphics g = getGraphics(true);
 202         if (g != null) {
 203             layer.render(g);
 204         }
 205 
 206         //restore transform
 207         setTransform(cur);
 208     }
 209 
 210     private void restoreStateInternal() {
 211         int size = states.size();
 212         if (size == 0) {
 213             assert false: &quot;Unbalanced restoreState&quot;;
 214             return;
 215         }
 216 
 217         Layer layer = state.getLayerNoClone();
 218         state = states.remove(size - 1);
 219         if (layer != state.getLayerNoClone()) {
 220             renderLayer(layer);
 221             layer.dispose();
 222             if (log.isLoggable(Level.FINE)) {
 223                 log.fine(&quot;Popped layer &quot; + layer);
 224             }
 225         } else {
 226             resetCachedGraphics();
 227         }
 228     }
 229 
 230     public void restoreState()
 231     {
 232         log.fine(&quot;restoring state&quot;);
 233         do {
 234             restoreStateInternal();
 235         } while ( !state.isRestorePoint() );
 236     }
 237 
 238     /**
 239      *  Renders all layers to the underlaying Graphics, but preserves the
 240      *  current state and the states stack
 241      */
 242     private void flushAllLayers() {
 243         if (state == null) {
 244             // context disposed
 245             return;
 246         }
 247 
 248         if (isRootLayerValid) {
 249             log.fine(&quot;FlushAllLayers: root layer is valid, skipping&quot;);
 250             return;
 251         }
 252 
 253         if (log.isLoggable(Level.FINE)) {
 254             log.fine(&quot;FlushAllLayers&quot;);
 255         }
 256 
 257         ContextState currentState = state;
 258 
 259         for (int i = states.size() - 1; i &gt;=0; i--) {
 260             Layer layer = state.getLayerNoClone();
 261             state = states.get(i);
 262             if (layer != state.getLayerNoClone()) {
 263                 renderLayer(layer);
 264             } else {
 265                 resetCachedGraphics();
 266             }
 267         }
 268 
 269         Layer layer = state.getLayerNoClone();
 270         if (layer != null) {
 271             renderLayer(layer);
 272         }
 273 
 274         state = currentState;
 275         isRootLayerValid = true;
 276     }
 277 
 278 
 279     public void dispose() {
 280         if (!states.isEmpty()) {
 281             log.fine(&quot;Unbalanced saveState/restoreState&quot;);
 282         }
 283         for (ContextState state: states) {
 284             if (state.getLayerNoClone() != null) {
 285                 state.getLayerNoClone().dispose();
 286             }
 287         }
 288         states.clear();
 289 
 290         if (state != null &amp;&amp; state.getLayerNoClone() != null) {
 291             state.getLayerNoClone().dispose();
 292         }
 293         state = null;
 294     }
 295 
 296 
 297     public void setClip(WCPath path, boolean isOut) {
 298         Affine3D tr = new Affine3D(state.getTransformNoClone());
 299         path.transform(
 300                 tr.getMxx(), tr.getMyx(),
 301                 tr.getMxy(), tr.getMyy(),
 302                 tr.getMxt(), tr.getMyt());
 303         //path now is in node coordinates, as well as clip
 304 
 305         if (!isOut) {
 306             WCRectangle pathBounds = path.getBounds();
 307 
 308             // path bounds could be fractional so &#39;inclusive&#39; rounding
 309             // is used for determining clip rectangle
 310             int pixelX = (int) Math.floor(pathBounds.getX());
 311             int pixelY = (int) Math.floor(pathBounds.getY());
 312             int pixelW = (int) Math.ceil(pathBounds.getMaxX()) - pixelX;
 313             int pixelH = (int) Math.ceil(pathBounds.getMaxY()) - pixelY;
 314 
 315             state.clip(new Rectangle(pixelX, pixelY, pixelW, pixelH));
 316         }
 317 
 318         Rectangle clip = state.getClipNoClone();
 319 
 320         if (isOut) {
 321             path.addRect(clip.x, clip.y, clip.width, clip.height);
 322             //Out clip path is always EVENODD.
 323         }
 324 
 325         path.translate(-clip.x, -clip.y);
 326 
 327         Layer layer = new ClipLayer(
 328             getGraphics(false), clip, path, type() == Type.DEDICATED);
 329 
 330         startNewLayer(layer);
 331 
 332         if (log.isLoggable(Level.FINE)) {
 333             log.fine(&quot;setClip(WCPath &quot; + path.getID() + &quot;)&quot;);
 334             log.fine(&quot;Pushed layer &quot; + layer);
 335         }
 336     }
 337 
 338     private Rectangle transformClip(Rectangle localClip) {
 339         if (localClip==null) {
 340             return null;
 341         }
 342 
 343         float[] points = new float[] {
 344             localClip.x, localClip.y,
 345             localClip.x + localClip.width, localClip.y,
 346             localClip.x, localClip.y + localClip.height,
 347             localClip.x  + localClip.width, localClip.y + localClip.height};
 348         state.getTransformNoClone().transform(points, 0, points, 0, 4);
 349         float minX = Math.min(
 350                points[0], Math.min(
 351                points[2], Math.min(
 352                points[4], points[6])));
 353         float maxX = Math.max(
 354                points[0], Math.max(
 355                points[2], Math.max(
 356                points[4], points[6])));
 357         float minY = Math.min(
 358                points[1], Math.min(
 359                points[3], Math.min(
 360                points[5], points[7])));
 361         float maxY = Math.max(
 362                points[1], Math.max(
 363                points[3], Math.max(
 364                points[5], points[7])));
 365         return new Rectangle(new RectBounds(minX, minY, maxX, maxY));
 366 
 367 /* #1 loose rotate
 368         state.getTransformNoClone().transform(localClip, localClip);
 369 */
 370 /* #2 problem with negative coordinates
 371         RectBounds rb = TransformedShape.transformedShape(
 372             new RoundRectangle2D(localClip.x, localClip.y, localClip.width, localClip.height, 0, 0),
 373             state.getTransformNoClone()).getBounds();
 374         return rb.isEmpty()
 375             ? null
 376             : new Rectangle(rb);
 377  */
 378     }
 379 
 380     private void setClip(Rectangle shape) {
 381         Affine3D tr = state.getTransformNoClone();
 382         if (tr.getMxy() == 0 &amp;&amp; tr.getMxz() == 0
 383          &amp;&amp; tr.getMyx() == 0 &amp;&amp; tr.getMyz() == 0
 384          &amp;&amp; tr.getMzx() == 0 &amp;&amp; tr.getMzy() == 0) {
 385             //There is no rotation here: scale + translation.
 386             //Fast &amp; easy!
 387             state.clip(transformClip(shape));
 388             if (log.isLoggable(Level.FINE)) {
 389                 log.fine(&quot;setClip({0})&quot;, shape);
 390             }
 391             if (DEBUG_DRAW_CLIP_SHAPE) {
 392                 //Draw clip shape
 393                 Rectangle rc = state.getClipNoClone();
 394                 if (rc != null &amp;&amp; rc.width &gt;= 2 &amp;&amp; rc.height &gt;= 2) {
 395                     WCTransform cur = getTransform();
 396                     //translate to (layer.getX(), layer.getY())
 397                     setTransform(new WCTransform(
 398                         1.0, 0.0,
 399                         0.0, 1.0,
 400                         0.0, 0.0));
 401 
 402                     Graphics g2d = getGraphics(true);
 403                     if (g2d != null) {
 404                         float fbase = (float)Math.random();
 405                         g2d.setPaint(new Color(
 406                                 fbase,
 407                                 1f - fbase,
 408                                 0.5f,
 409                                 0.1f));
 410                         g2d.setStroke(new BasicStroke());
 411                         g2d.fillRect(rc.x, rc.y, rc.width, rc.height);
 412 
 413                         g2d.setPaint(new Color(
 414                                 1f - fbase,
 415                                 fbase,
 416                                 0.5f,
 417                                 1f));
 418                         g2d.drawRect(rc.x, rc.y, rc.width, rc.height);
 419                     }
 420                     //restore transform
 421                     setTransform(cur);
 422                     state.clip(new Rectangle(rc.x+1, rc.y+1, rc.width-2, rc.height-2));
 423                 }
 424             }
 425             if (cachedGraphics != null) {
 426                 cachedGraphics.setClipRect(state.getClipNoClone());
 427             }
 428         } else {
 429             //twisted axis set
 430             WCPath path = new WCPathImpl();
 431             path.addRect(shape.x, shape.y, shape.width, shape.height);
 432             setClip(path, false);
 433         }
 434     }
 435 
 436     public void setClip(int cx, int cy, int cw, int ch) {
 437         setClip(new Rectangle(cx, cy, cw, ch));
 438     }
 439 
 440     public void setClip(WCRectangle c) {
 441         setClip(new Rectangle((int)c.getX(), (int)c.getY(),
 442                               (int)c.getWidth(), (int)c.getHeight()));
 443     }
 444 
 445     public void setClip(int cx, int cy, int cw, int ch, WCImage maskImage) {
 446         setClip(new Rectangle(cx, cy, cw, ch));
 447         state.setClipMaskImage(maskImage);
 448     }
 449 
 450     public WCRectangle getClip() {
 451         Rectangle r = state.getClipNoClone();
 452         return r == null ? null : new WCRectangle(r.x, r.y, r.width, r.height);
 453     }
 454 
 455     protected Rectangle getClipRectNoClone() {
 456         return state.getClipNoClone();
 457     }
 458 
 459     protected Affine3D getTransformNoClone() {
 460         return state.getTransformNoClone();
 461     }
 462 
 463     public void translate(float x, float y) {
 464         if (log.isLoggable(Level.FINE)) {
 465             log.fine(&quot;translate({0},{1})&quot;, new Object[] {x, y});
 466         }
 467         state.translate(x, y);
 468         if (cachedGraphics != null) {
 469             cachedGraphics.translate(x, y);
 470         }
 471     }
 472 
 473     public void scale(float sx, float sy) {
 474         if (log.isLoggable(Level.FINE)) {
 475             log.fine(&quot;scale(&quot; + sx + &quot; &quot; + sy + &quot;)&quot;);
 476         }
 477         state.scale(sx, sy);
 478         if (cachedGraphics != null) {
 479             cachedGraphics.scale(sx, sy);
 480         }
 481     }
 482 
 483     public void rotate(float radians) {
 484         if (log.isLoggable(Level.FINE)) {
 485             log.fine(&quot;rotate(&quot; + radians + &quot;)&quot;);
 486         }
 487         state.rotate(radians);
 488         if (cachedGraphics != null) {
 489             cachedGraphics.setTransform(state.getTransformNoClone());
 490         }
 491     }
 492 
 493     // overriden in WCBufferedContext
 494     protected boolean shouldRenderRect(float x, float y, float w, float h,
 495                                        DropShadow shadow, BasicStroke stroke)
 496     {
 497         return true;
 498     }
 499 
 500     // overriden in WCBufferedContext
 501     protected boolean shouldRenderShape(Shape shape, DropShadow shadow, BasicStroke stroke) {
 502         return true;
 503     }
 504 
 505     // overriden in WCBufferedContext
 506     protected boolean shouldCalculateIntersection() {
 507         return false;
 508     }
 509 
 510     @Override
 511     public void fillRect(final float x, final float y, final float w, final float h, final Integer rgba) {
 512         if (log.isLoggable(Level.FINE)) {
 513             String format = (rgba != null)
 514                     ? &quot;fillRect(%f, %f, %f, %f, 0x%x)&quot;
 515                     : &quot;fillRect(%f, %f, %f, %f, null)&quot;;
 516             log.fine(String.format(format, x, y, w, h, rgba));
 517         }
 518         if (!shouldRenderRect(x, y, w, h, state.getShadowNoClone(), null)) {
 519             return;
 520         }
 521         new Composite() {
 522             @Override void doPaint(Graphics g) {
 523                 Paint paint = (rgba != null) ? createColor(rgba) : state.getPaintNoClone();
 524                 DropShadow shadow = state.getShadowNoClone();
 525                 // TextureMapperJava::drawSolidColor calls fillRect with perspective
 526                 // projection.
 527                 if (shadow != null || !state.getPerspectiveTransformNoClone().isIdentity()) {
 528                     final NGRectangle node = new NGRectangle();
 529                     node.updateRectangle(x, y, w, h, 0, 0);
 530                     render(g, shadow, paint, null, node);
 531                 } else if(state.getClipMaskImageNoClone() != null) {
 532                     Rectangle rect = new Rectangle((int) x, (int) y, (int) w, (int) h);
 533                     Rectangle transformedRect = new Rectangle();
 534                     state.getTransformNoClone().transform(rect, transformedRect);
 535                     RTTexture paintRtTexture = g.getResourceFactory().createRTTexture(
 536                             (int) Math.ceil(transformedRect.width),
 537                             (int) Math.ceil(transformedRect.height),
 538                             Texture.WrapMode.CLAMP_NOT_NEEDED);
 539                     Graphics g1 = paintRtTexture.createGraphics();
 540                     g1.setPaint(paint);
 541                     g1.setTransform(PrismGraphicsManager.getPixelScaleTransform());
 542                     g1.fillRect(0, 0, paintRtTexture.getContentWidth(), paintRtTexture.getContentHeight());
 543 
 544                     RTImage maskImage = (RTImage) (state.getClipMaskImageNoClone());
 545                     Image nativeMaskImage = Image.fromByteBgraPreData(maskImage.getPixelBuffer(), maskImage.getWidth(),
 546                             maskImage.getHeight(), 0, maskImage.getPixelScale());
 547                     Texture maskTexture = g.getResourceFactory().createTexture(nativeMaskImage, Texture.Usage.STATIC,
 548                             Texture.WrapMode.CLAMP_NOT_NEEDED);
 549                     RTTexture maskRtTexture = g.getResourceFactory().createRTTexture(nativeMaskImage.getWidth(),
 550                             nativeMaskImage.getHeight(), Texture.WrapMode.CLAMP_NOT_NEEDED);
 551                     Graphics g2 = maskRtTexture.createGraphics();
 552                     g2.setTransform(PrismGraphicsManager.getPixelScaleTransform());
 553                     g2.drawTexture(maskTexture, 0, 0, nativeMaskImage.getWidth(), nativeMaskImage.getHeight());
 554                     maskTexture.dispose();
 555                     if(g instanceof MaskTextureGraphics &amp;&amp; !(g instanceof PrinterGraphics)) {
 556                         MaskTextureGraphics mg = (MaskTextureGraphics) (g);
 557                         mg.drawPixelsMasked(paintRtTexture, maskRtTexture, transformedRect.x, transformedRect.y,
 558                                 transformedRect.width, transformedRect.height, 0, 0, 0, 0);
 559                     } else {
 560                         Screen screen = g.getAssociatedScreen();
 561                         FilterContext filterContext;
 562                         if (screen == null) {
 563                             ResourceFactory factory = g.getResourceFactory();
 564                             filterContext = PrFilterContext.getPrinterContext(factory);
 565                         } else {
 566                             filterContext = PrFilterContext.getInstance(screen);
 567                         }
 568                         PrDrawable imagePrDrawable = PrDrawable.create(filterContext, paintRtTexture);
 569                         PrDrawable maskPrDrawable = PrDrawable.create(filterContext, maskRtTexture);
 570                         Blend blend = new Blend(Blend.Mode.SRC_IN,
 571                                 new PassThrough(maskPrDrawable, transformedRect.width, transformedRect.height),
 572                                 new PassThrough(imagePrDrawable, transformedRect.width, transformedRect.height));
 573                         Affine3D tx = new Affine3D(g.getTransformNoClone());
 574                         g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
 575                         PrEffectHelper.render(blend, g, transformedRect.x, transformedRect.y, null);
 576                         g.setTransform(tx);
 577                     }
 578                     paintRtTexture.dispose();
 579                     maskRtTexture.dispose();
 580                 } else {
 581                     g.setPaint(paint);
 582                     g.fillRect(x, y, w, h);
 583                 }
 584             }
 585         }.paint();
 586     }
 587 
 588     @Override
 589     public void fillRoundedRect(final float x, final float y, final float w, final float h,
 590         final float topLeftW, final float topLeftH, final float topRightW, final float topRightH,
 591         final float bottomLeftW, final float bottomLeftH, final float bottomRightW, final float bottomRightH,
 592         final int rgba)
 593     {
 594         if (log.isLoggable(Level.FINE)) {
 595             log.fine(String.format(&quot;fillRoundedRect(%f, %f, %f, %f, &quot;
 596                     + &quot;%f, %f, %f, %f, %f, %f, %f, %f, 0x%x)&quot;,
 597                     x, y, w, h, topLeftW, topLeftH, topRightW, topRightH,
 598                     bottomLeftW, bottomLeftH, bottomRightW, bottomRightH, rgba));
 599         }
 600         if (!shouldRenderRect(x, y, w, h, state.getShadowNoClone(), null)) {
 601             return;
 602         }
 603         new Composite() {
 604             @Override void doPaint(Graphics g) {
 605                 // Prism only supports single arcWidth/Height.
 606                 // We work around by calculating average width and height here
 607 
 608                 float arcW = (topLeftW + topRightW + bottomLeftW + bottomRightW) / 2;
 609                 float arcH = (topLeftH + topRightH + bottomLeftH + bottomRightH) / 2;
 610 
 611                 Paint paint = createColor(rgba);
 612                 DropShadow shadow = state.getShadowNoClone();
 613                 if (shadow != null) {
 614                     final NGRectangle node = new NGRectangle();
 615                     node.updateRectangle(x, y, w, h, arcW, arcH);
 616                     render(g, shadow, paint, null, node);
 617                 } else {
 618                     g.setPaint(paint);
 619                     g.fillRoundRect(x, y, w, h, arcW, arcH);
 620                 }
 621             }
 622         }.paint();
 623     }
 624 
 625     @Override
 626     public void clearRect(final float x, final float y, final float w, final float h) {
 627         if (log.isLoggable(Level.FINE)) {
 628             log.fine(String.format(&quot;clearRect(%f, %f, %f, %f)&quot;, x, y, w, h));
 629         }
 630         if (shouldCalculateIntersection()) {
 631             // No intersection is applicable for clearRect.
 632             return;
 633         }
 634         new Composite() {
 635             @Override void doPaint(Graphics g) {
 636                 g.clearQuad(x, y, x + w, y + h);
 637             }
 638         }.paint();
 639     }
 640 
 641     @Override
 642     public void setFillColor(int rgba) {
 643         if (log.isLoggable(Level.FINE)) {
 644             log.fine(String.format(&quot;setFillColor(0x%x)&quot;, rgba));
 645         }
 646         state.setPaint(createColor(rgba));
 647     }
 648 
 649     @Override
 650     public void setFillGradient(WCGradient gradient) {
 651         if (log.isLoggable(Level.FINE)) {
 652             log.fine(&quot;setFillGradient(&quot; + gradient + &quot;)&quot;);
 653         }
 654         state.setPaint((Gradient) gradient.getPlatformGradient());
 655     }
 656 
 657     @Override
 658     public void setTextMode(boolean fill, boolean stroke, boolean clip) {
 659         if (log.isLoggable(Level.FINE)) {
 660             log.fine(&quot;setTextMode(fill:&quot; + fill + &quot;,stroke:&quot; + stroke + &quot;,clip:&quot; + clip + &quot;)&quot;);
 661         }
 662         state.setTextMode(fill, stroke, clip);
 663     }
 664 
 665     @Override
 666     public void setFontSmoothingType(int fontSmoothingType) {
 667         this.fontSmoothingType = fontSmoothingType;
 668     }
 669 
 670     @Override
 671     public int getFontSmoothingType() {
 672         return fontSmoothingType;
 673     }
 674 
 675     @Override
 676     public void setStrokeStyle(int style) {
 677         if (log.isLoggable(Level.FINE)) {
 678             log.fine(&quot;setStrokeStyle({0})&quot;, style);
 679         }
 680         state.getStrokeNoClone().setStyle(style);
 681     }
 682 
 683     @Override
 684     public void setStrokeColor(int rgba) {
 685         if (log.isLoggable(Level.FINE)) {
 686             log.fine(String.format(&quot;setStrokeColor(0x%x)&quot;, rgba));
 687         }
 688         state.getStrokeNoClone().setPaint(createColor(rgba));
 689     }
 690 
 691     @Override
 692     public void setStrokeWidth(float width) {
 693         if (log.isLoggable(Level.FINE)) {
 694             log.fine(&quot;setStrokeWidth({0})&quot;, new Object[] { width });
 695         }
 696         state.getStrokeNoClone().setThickness(width);
 697     }
 698 
 699     @Override
 700     public void setStrokeGradient(WCGradient gradient) {
 701         if (log.isLoggable(Level.FINE)) {
 702             log.fine(&quot;setStrokeGradient(&quot; + gradient + &quot;)&quot;);
 703         }
 704         state.getStrokeNoClone().setPaint((Gradient) gradient.getPlatformGradient());
 705     }
 706 
 707     @Override
 708     public void setLineDash(float offset, float... sizes) {
 709         if (log.isLoggable(Level.FINE)) {
 710             StringBuilder s = new StringBuilder(&quot;[&quot;);
 711             for (int i=0; i &lt; sizes.length; i++) {
 712                 s.append(sizes[i]).append(&#39;,&#39;);
 713             }
 714             s.append(&#39;]&#39;);
 715             log.fine(&quot;setLineDash({0},{1}&quot;, new Object[] {offset, s});
 716         }
 717         state.getStrokeNoClone().setDashOffset(offset);
 718         if (sizes != null) {
 719             boolean allZero = true;
 720             for (int i = 0; i &lt; sizes.length; i++) {
 721                 if (sizes[i] != 0) {
 722                     allZero = false;
 723                     break;
 724                 }
 725             }
 726             if (allZero) {
 727                 sizes = null;
 728             }
 729         }
 730         state.getStrokeNoClone().setDashSizes(sizes);
 731     }
 732 
 733     @Override
 734     public void setLineCap(int lineCap) {
 735         if (log.isLoggable(Level.FINE)) {
 736             log.fine(&quot;setLineCap(&quot; + lineCap + &quot;)&quot;);
 737         }
 738         state.getStrokeNoClone().setLineCap(lineCap);
 739     }
 740 
 741     @Override
 742     public void setLineJoin(int lineJoin) {
 743         if (log.isLoggable(Level.FINE)) {
 744             log.fine(&quot;setLineJoin(&quot; + lineJoin + &quot;)&quot;);
 745         }
 746         state.getStrokeNoClone().setLineJoin(lineJoin);
 747     }
 748 
 749     @Override
 750     public void setMiterLimit(float miterLimit) {
 751         if (log.isLoggable(Level.FINE)) {
 752             log.fine(&quot;setMiterLimit(&quot; + miterLimit + &quot;)&quot;);
 753         }
 754         state.getStrokeNoClone().setMiterLimit(miterLimit);
 755     }
 756 
 757     @Override
 758     public void setShadow(float dx, float dy, float blur, int rgba) {
 759         if (log.isLoggable(Level.FINE)) {
 760             String format = &quot;setShadow(%f, %f, %f, 0x%x)&quot;;
 761             log.fine(String.format(format, dx, dy, blur, rgba));
 762         }
 763         state.setShadow(createShadow(dx, dy, blur, rgba));
 764     }
 765 
 766     @Override
 767     public void drawPolygon(final WCPath path, final boolean shouldAntialias) {
 768         if (log.isLoggable(Level.FINE)) {
 769             log.fine(&quot;drawPolygon({0})&quot;,
 770                     new Object[] {shouldAntialias});
 771         }
 772         if (!shouldRenderShape(((WCPathImpl)path).getPlatformPath(), null,
 773                                 state.getStrokeNoClone().getPlatformStroke()))
 774         {
 775             return;
 776         }
 777         new Composite() {
 778             @Override void doPaint(Graphics g) {
 779                 Path2D p2d = (Path2D) path.getPlatformPath();
 780                 g.setPaint(state.getPaintNoClone());
 781                 g.fill(p2d);
 782                 if (state.getStrokeNoClone().apply(g)) {
 783                     g.draw(p2d);
 784                 }
 785             }
 786         }.paint();
 787     }
 788 
 789     @Override
 790     public void drawLine(final int x0, final int y0, final int x1, final int y1) {
 791         if (log.isLoggable(Level.FINE)) {
 792             log.fine(&quot;drawLine({0}, {1}, {2}, {3})&quot;,
 793                     new Object[] {x0, y0, x1, y1});
 794         }
 795         Line2D line = new Line2D(x0, y0, x1, y1);
 796         if (!shouldRenderShape(line, null, state.getStrokeNoClone().getPlatformStroke())) {
 797             return;
 798         }
 799         new Composite() {
 800             @Override void doPaint(Graphics g) {
 801                 if (state.getStrokeNoClone().apply(g)) {
 802                     g.drawLine(x0, y0, x1, y1);
 803                 }
 804             }
 805         }.paint();
 806     }
 807 
 808     @Override
 809     public void drawPattern(
 810         final WCImage texture,
 811         final WCRectangle srcRect,
 812         final WCTransform patternTransform,
 813         final WCPoint phase,
 814         final WCRectangle destRect)
 815     {
 816         if (log.isLoggable(Level.FINE)) {
 817             log.fine(&quot;drawPattern({0}, {1}, {2}, {3})&quot;,
 818                     new Object[] {destRect.getIntX(), destRect.getIntY(),
 819                                   destRect.getIntWidth(),
 820                                   destRect.getIntHeight()});
 821         }
 822         if (!shouldRenderRect(destRect.getX(), destRect.getY(),
 823                               destRect.getWidth(), destRect.getHeight(), null, null))
 824         {
 825             return;
 826         }
 827         if (texture != null) {
 828             new Composite() {
 829                 @Override void doPaint(Graphics g) {
 830                     // The handling of pattern transform is modeled after the WebKit
 831                     // ImageCG.cpp&#39;s Image::drawPattern()
 832                     float adjustedX = phase.getX()
 833                             + srcRect.getX() * (float) patternTransform.getMatrix()[0];
 834                     float adjustedY = phase.getY()
 835                             + srcRect.getY() * (float) patternTransform.getMatrix()[3];
 836                     float scaledTileWidth =
 837                             srcRect.getWidth() * (float) patternTransform.getMatrix()[0];
 838                     float scaledTileHeight =
 839                             srcRect.getHeight() * (float) patternTransform.getMatrix()[3];
 840 
 841                     Image img = ((PrismImage)texture).getImage();
 842 
 843                     // Create subImage only if srcRect doesn&#39;t fit the texture bounds. See RT-20193.
 844                     if (!srcRect.contains(new WCRectangle(0, 0, texture.getWidth(), texture.getHeight()))) {
 845 
 846                         img = img.createSubImage(srcRect.getIntX(),
 847                                                  srcRect.getIntY(),
 848                                                  (int)Math.ceil(srcRect.getWidth()),
 849                                                  (int)Math.ceil(srcRect.getHeight()));
 850                     }
 851                     g.setPaint(new ImagePattern(
 852                                img,
 853                                adjustedX, adjustedY,
 854                                scaledTileWidth, scaledTileHeight,
 855                                false, false));
 856 
 857                     g.fillRect(destRect.getX(), destRect.getY(),
 858                                destRect.getWidth(), destRect.getHeight());
 859                 }
 860             }.paint();
 861         }
 862     }
 863 
 864     @Override
 865     public void drawImage(final WCImage img,
 866                           final float dstx, final float dsty, final float dstw, final float dsth,
 867                           final float srcx, final float srcy, final float srcw, final float srch)
 868     {
 869         if (log.isLoggable(Level.FINE)){
 870             log.fine(&quot;drawImage(img, dst({0},{1},{2},{3}), &quot; +
 871                     &quot;src({4},{5},{6},{7}))&quot;,
 872                     new Object[] {dstx, dsty, dstw, dsth,
 873                                   srcx, srcy, srcw, srch});
 874         }
 875         if (!shouldRenderRect(dstx, dsty, dstw, dsth, state.getShadowNoClone(), null)) {
 876             return;
 877         }
 878         if (img instanceof PrismImage) {
 879             new Composite() {
 880                 @Override void doPaint(Graphics g) {
 881                     PrismImage pi = (PrismImage) img;
 882                     DropShadow shadow = state.getShadowNoClone();
 883                     if (shadow != null) {
 884                         NGImageView node = new NGImageView();
 885                         node.setImage(pi.getImage());
 886                         node.setX(dstx);
 887                         node.setY(dsty);
 888                         node.setViewport(srcx, srcy, srcw, srch, dstw, dsth);
 889                         node.setContentBounds(new RectBounds(dstx, dsty, dstx + dstw, dsty + dsth));
 890                         render(g, shadow, null, null, node);
 891                     } else {
 892                         pi.draw(g,
 893                                 (int) dstx, (int) dsty,
 894                                 (int) (dstx + dstw), (int) (dsty + dsth),
 895                                 (int) srcx, (int) srcy,
 896                                 (int) (srcx + srcw), (int) (srcy + srch));
 897                     }
 898                 }
 899             }.paint();
 900         }
 901     }
 902 
 903     @Override
 904     public void drawBitmapImage(final ByteBuffer image, final int x, final int y, final int w, final int h) {
 905         if (!shouldRenderRect(x, y, w, h, null, null)) {
 906             return;
 907         }
 908         new Composite() {
 909             @Override void doPaint(Graphics g) {
 910                 image.order(ByteOrder.nativeOrder());
 911                 Image img = Image.fromByteBgraPreData(image, w, h);
 912                 ResourceFactory rf = g.getResourceFactory();
 913                 Texture txt = rf.createTexture(img, Texture.Usage.STATIC, Texture.WrapMode.REPEAT);
 914                 g.drawTexture(txt, x, y, x + w, y + h, 0, 0, w, h);
 915                 txt.dispose();
 916             }
 917         }.paint();
 918     }
 919 
 920     @Override
 921     public void drawIcon(WCIcon icon, int x, int y) {
 922         if (log.isLoggable(Level.FINE)) {
 923             log.fine(&quot;UNIMPLEMENTED drawIcon ({0}, {1})&quot;,
 924                     new Object[] {x, y});
 925         }
 926     }
 927 
 928     @Override
 929     public void drawRect(final int x, final int y, final int w, final int h) {
 930         if (log.isLoggable(Level.FINE)) {
 931             log.fine(&quot;drawRect({0}, {1}, {2}, {3})&quot;,
 932                     new Object[]{x, y, w, h});
 933         }
 934         if (!shouldRenderRect(x, y, w, h,
 935                               null, state.getStrokeNoClone().getPlatformStroke()))
 936         {
 937             return;
 938         }
 939         new Composite() {
 940             @Override void doPaint(Graphics g) {
 941                 Paint c = state.getPaintNoClone();
 942                 if (c != null &amp;&amp; c.isOpaque()) {
 943                     g.setPaint(c);
 944                     g.fillRect(x, y, w, h);
 945                 }
 946 
 947                 if (state.getStrokeNoClone().apply(g)) {
 948                     g.drawRect(x, y, w, h);
 949                 }
 950             }
 951         }.paint();
 952     }
 953 
 954     @Override
 955     public void drawString(final WCFont f, final int[] glyphs,
 956                            final float[] advances, final float x, final float y)
 957     {
 958         if (log.isLoggable(Level.FINE)) {
 959             log.fine(String.format(
 960                     &quot;Drawing %d glyphs @(%.1f, %.1f)&quot;,
 961                     glyphs.length, x, y));
 962         }
 963         PGFont font = (PGFont)f.getPlatformFont();
 964         TextRun gl = TextUtilities.createGlyphList(glyphs, advances, x, y);
 965 
 966         DropShadow shadow = state.getShadowNoClone();
 967         BasicStroke stroke = state.isTextStroke()
 968                 ? state.getStrokeNoClone().getPlatformStroke()
 969                 : null;
 970 
 971         final FontStrike strike = font.getStrike(getTransformNoClone(), getFontSmoothingType());
 972         if (shouldCalculateIntersection()) {
 973             Metrics m = strike.getMetrics();
 974             gl.setMetrics(m.getAscent(), m.getDescent(), m.getLineGap());
 975             if (!shouldRenderRect(x, y, gl.getWidth(), gl.getHeight(), shadow, stroke)) {
 976                 return;
 977             }
 978         }
 979         new Composite() {
 980             @Override void doPaint(Graphics g) {
 981                 Paint paint = state.isTextFill()
 982                         ? state.getPaintNoClone()
 983                         : null;
 984                 if (shadow != null) {
 985                     final NGText span = new NGText();
 986                     span.setGlyphs(new GlyphList[] {gl});
 987                     span.setFont(font);
 988                     span.setFontSmoothingType(fontSmoothingType);
 989                     render(g, shadow, paint, stroke, span);
 990                 } else {
 991                     if (paint != null) {
 992                         g.setPaint(paint);
 993                         g.drawString(gl, strike, x, y, null, 0, 0);
 994                     }
 995                     if (stroke != null) {
 996                         paint = state.getStrokeNoClone().getPaint();
 997                         if (paint != null) {
 998                             g.setPaint(paint);
 999                             g.setStroke(stroke);
1000                             g.draw(strike.getOutline(gl, BaseTransform.getTranslateInstance(x, y)));
1001                         }
1002                     }
1003                 }
1004             }
1005         }.paint();
1006     }
1007 
1008     @Override public void drawString(WCFont f, String str, boolean rtl,
1009             int from, int to, float x, float y)
1010     {
1011         if (log.isLoggable(Level.FINE)) {
1012             log.fine(String.format(
1013                     &quot;str=&#39;%s&#39; (length=%d), from=%d, to=%d, rtl=%b, @(%.1f, %.1f)&quot;,
1014                     str, str.length(), from, to, rtl, x, y));
1015         }
1016         TextLayout layout = TextUtilities.createLayout(
1017                 str.substring(from, to), f.getPlatformFont());
1018         int count = 0;
1019         GlyphList[] runs = layout.getRuns();
1020         for (GlyphList run: runs) {
1021             count += run.getGlyphCount();
1022         }
1023 
1024         int[] glyphs = new int[count];
1025         float[] adv = new float[count];
1026         count = 0;
1027         for (GlyphList run: layout.getRuns()) {
1028             int gc = run.getGlyphCount();
1029             for (int i = 0; i &lt; gc; i++) {
1030                 glyphs[count] = run.getGlyphCode(i);
1031                 adv[count] = run.getPosX(i + 1) - run.getPosX(i);
1032                 count++;
1033             }
1034         }
1035 
1036         // adjust x coordinate (see RT-29908)
1037         if (rtl) {
1038             x += (TextUtilities.getLayoutWidth(str.substring(from), f.getPlatformFont()) -
1039                   layout.getBounds().getWidth());
1040         } else {
1041             x += TextUtilities.getLayoutWidth(str.substring(0, from), f.getPlatformFont());
1042         }
1043         drawString(f, glyphs, adv, x, y);
1044     }
1045 
1046     @Override
1047     public void setComposite(int composite) {
1048         log.fine(&quot;setComposite({0})&quot;, composite);
1049         state.setCompositeOperation(composite);
1050     }
1051 
1052     @Override
1053     public void drawEllipse(final int x, final int y, final int w, final int h) {
1054         if (log.isLoggable(Level.FINE)) {
1055             log.fine(&quot;drawEllipse({0}, {1}, {2}, {3})&quot;,
1056                     new Object[] { x, y, w, h});
1057         }
1058         if (!shouldRenderRect(x, y, w, h,
1059                               null, state.getStrokeNoClone().getPlatformStroke()))
1060         {
1061             return;
1062         }
1063         new Composite() {
1064             @Override void doPaint(Graphics g) {
1065                 g.setPaint(state.getPaintNoClone());
1066                 g.fillEllipse(x, y, w, h);
1067                 if (state.getStrokeNoClone().apply(g)) {
1068                     g.drawEllipse(x, y, w, h);
1069                 }
1070             }
1071         }.paint();
1072     }
1073 
1074     private final static BasicStroke focusRingStroke =
1075         new BasicStroke(1.1f, BasicStroke.CAP_BUTT,
1076                          BasicStroke.JOIN_ROUND, 0.0f,
1077                          new float[] {1.0f}, 0.0f);
1078 
1079     @Override
1080     public void drawFocusRing(final int x, final int y, final int w, final int h, final int rgba) {
1081         if (log.isLoggable(Level.FINE)) {
1082             log.fine(String.format(&quot;drawFocusRing: %d, %d, %d, %d, 0x%x&quot;, x, y, w, h, rgba));
1083         }
1084         if (!shouldRenderRect(x, y, w, h, null, focusRingStroke)) {
1085             return;
1086         }
1087         new Composite() {
1088             @Override void doPaint(Graphics g) {
1089                 g.setPaint(createColor(rgba));
1090                 BasicStroke stroke = g.getStroke();
1091                 g.setStroke(focusRingStroke);
1092                 g.drawRoundRect(x, y, w, h, 4, 4);
1093                 g.setStroke(stroke);
1094             }
1095         }.paint();
1096     }
1097 
1098     public void setAlpha(float alpha) {
1099         log.fine(&quot;setAlpha({0})&quot;, alpha);
1100 
1101         state.setAlpha(alpha);
1102 
1103         if (null != cachedGraphics) {
1104             cachedGraphics.setExtraAlpha(state.getAlpha());
1105         }
1106     }
1107 
1108     public float getAlpha() {
1109         return state.getAlpha();
1110     }
1111 
1112     @Override public void beginTransparencyLayer(float opacity) {
1113         TransparencyLayer layer = new TransparencyLayer(
1114                 getGraphics(false), state.getClipNoClone(), opacity);
1115 
1116         if (log.isLoggable(Level.FINE)) {
1117             log.fine(String.format(&quot;beginTransparencyLayer(%s)&quot;, layer));
1118         }
1119 
1120         //[saveStateIntertal] will work as [saveState]
1121         state.markAsRestorePoint();
1122 
1123         startNewLayer(layer);
1124     }
1125 
1126     @Override public void endTransparencyLayer() {
1127         if (log.isLoggable(Level.FINE)) {
1128             log.fine(String.format(&quot;endTransparencyLayer(%s)&quot;, state.getLayerNoClone()));
1129         }
1130 
1131         //pair to [startNewLayer] that works as [saveState] call
1132         restoreState();
1133     }
1134 
1135     @Override
1136     public void drawWidget(final RenderTheme theme, final Ref widget, final int x, final int y) {
1137         WCSize s = theme.getWidgetSize(widget);
1138         if (!shouldRenderRect(x, y, s.getWidth(), s.getHeight(), null, null)) {
1139             return;
1140         }
1141         new Composite() {
1142             @Override void doPaint(Graphics g) {
1143                 theme.drawWidget(WCGraphicsPrismContext.this, widget, x, y);
1144             }
1145         }.paint();
1146     }
1147 
1148     @Override
1149     public void drawScrollbar(final ScrollBarTheme theme, final Ref widget, int x, int y,
1150                               int pressedPart, int hoveredPart)
1151     {
1152         if (log.isLoggable(Level.FINE)) {
1153             log.fine(String.format(&quot;drawScrollbar(%s, %s, x = %d, y = %d)&quot;, theme, widget, x, y));
1154         }
1155 
1156         WCSize s = theme.getWidgetSize(widget);
1157         if (!shouldRenderRect(x, y, s.getWidth(), s.getHeight(), null, null)) {
1158             return;
1159         }
1160         new Composite() {
1161             @Override void doPaint(Graphics g) {
1162                 theme.paint(WCGraphicsPrismContext.this, widget, x, y, pressedPart, hoveredPart);
1163             }
1164         }.paint();
1165     }
1166 
1167     private static Rectangle intersect(Rectangle what, Rectangle with) {
1168         if (what == null) {
1169             return with;
1170         }
1171         RectBounds b = what.toRectBounds();
1172         b.intersectWith(with);
1173         what.setBounds(b);
1174         return what;
1175     }
1176 
1177     static Color createColor(int rgba) {
1178         float a = (0xFF &amp; (rgba &gt;&gt; 24)) / 255.0f;
1179         float r = (0xFF &amp; (rgba &gt;&gt; 16)) / 255.0f;
1180         float g = (0xFF &amp; (rgba &gt;&gt; 8)) / 255.0f;
1181         float b = (0xFF &amp; (rgba)) / 255.0f;
1182         return new Color(r, g, b, a);
1183     }
1184 
1185     private static Color4f createColor4f(int rgba) {
1186         float a = (0xFF &amp; (rgba &gt;&gt; 24)) / 255.0f;
1187         float r = (0xFF &amp; (rgba &gt;&gt; 16)) / 255.0f;
1188         float g = (0xFF &amp; (rgba &gt;&gt; 8)) / 255.0f;
1189         float b = (0xFF &amp; (rgba)) / 255.0f;
1190         return new Color4f(r, g, b, a);
1191     }
1192 
1193     private DropShadow createShadow(float dx, float dy, float blur, int rgba) {
1194         if (dx == 0f &amp;&amp; dy == 0f &amp;&amp; blur == 0f) {
1195             return null;
1196         }
1197         DropShadow shadow = new DropShadow();
1198         shadow.setOffsetX((int) dx);
1199         shadow.setOffsetY((int) dy);
1200         shadow.setRadius((blur &lt; 0f) ? 0f : (blur &gt; 127f) ? 127f : blur);
1201         shadow.setColor(createColor4f(rgba));
1202         return shadow;
1203     }
1204 
1205     private void render(Graphics g, Effect effect, Paint paint, BasicStroke stroke, NGNode node) {
1206         if (node instanceof NGShape) {
1207             NGShape shape = (NGShape) node;
1208             Shape realShape = shape.getShape();
1209             Paint strokePaint = state.getStrokeNoClone().getPaint();
1210             if ((stroke != null) &amp;&amp; (strokePaint != null)) {
1211                 realShape = stroke.createStrokedShape(realShape);
1212                 shape.setDrawStroke(stroke);
1213                 shape.setDrawPaint(strokePaint);
1214                 shape.setMode((paint == null) ? NGShape.Mode.STROKE : NGShape.Mode.STROKE_FILL);
1215             } else {
1216                 shape.setMode((paint == null) ? NGShape.Mode.EMPTY : NGShape.Mode.FILL);
1217             }
1218             shape.setFillPaint(paint);
1219             shape.setContentBounds(realShape.getBounds());
1220         }
1221         boolean culling = g.hasPreCullingBits();
1222         g.setHasPreCullingBits(false);
1223         node.setEffect(effect);
1224         node.render(g);
1225         g.setHasPreCullingBits(culling);
1226     }
1227 
1228     private static final class ContextState {
1229         private final WCStrokeImpl stroke = new WCStrokeImpl();
1230         private Rectangle clip;
1231         private Paint paint;
1232         private float alpha;
1233 
1234         private boolean textFill = true;
1235         private boolean textStroke = false;
1236         private boolean textClip = false;
1237         private boolean restorePoint = false;
1238 
1239         private DropShadow shadow;
1240         private Affine3D xform;
1241         private GeneralTransform3D perspectiveTransform;
1242         private Layer layer;
1243         private int compositeOperation;
1244         private WCImage clipMaskImage;
1245 
1246         private ContextState() {
1247             clip = null;
1248             paint = Color.BLACK;
1249             stroke.setPaint(Color.BLACK);
1250             alpha = 1.0f;
1251             xform = new Affine3D();
1252             perspectiveTransform = new GeneralTransform3D();
1253             compositeOperation = COMPOSITE_SOURCE_OVER;
1254         }
1255 
1256         private ContextState(ContextState state) {
1257             stroke.copyFrom(state.getStrokeNoClone());
1258             setPaint(state.getPaintNoClone());
1259             clip = state.getClipNoClone();
1260             if (clip != null) {
1261                 clip = new Rectangle(clip);
1262             }
1263             xform = new Affine3D(state.getTransformNoClone());
1264             perspectiveTransform = new GeneralTransform3D().set(state.getPerspectiveTransformNoClone());
1265             setShadow(state.getShadowNoClone());
1266             setLayer(state.getLayerNoClone());
1267             setAlpha(state.getAlpha());
1268             setTextMode(state.isTextFill(), state.isTextStroke(), state.isTextClip());
1269             setCompositeOperation(state.getCompositeOperation());
1270             setClipMaskImage(state.getClipMaskImageNoClone());
1271         }
1272 
1273         @Override
1274         protected ContextState clone() {
1275             return new ContextState(this);
1276         }
1277 
1278         private void apply(Graphics g) {
1279             g.setTransform(getTransformNoClone());
1280             g.setPerspectiveTransform(getPerspectiveTransformNoClone());
1281             g.setClipRect(getClipNoClone());
1282             g.setExtraAlpha(getAlpha());
1283         }
1284 
1285         private int getCompositeOperation() {
1286             return compositeOperation;
1287         }
1288 
1289         private void setCompositeOperation(int compositeOperation) {
1290             this.compositeOperation = compositeOperation;
1291         }
1292 
1293         private WCStrokeImpl getStrokeNoClone() {
1294             return stroke;
1295         }
1296 
1297         private Paint getPaintNoClone() {
1298             return paint;
1299         }
1300 
1301         private void setPaint(Paint paint) {
1302             this.paint = paint;
1303         }
1304 
1305         private void setClipMaskImage(WCImage image) {
1306             this.clipMaskImage = image;
1307         }
1308 
1309         private WCImage getClipMaskImageNoClone() {
1310             return clipMaskImage;
1311         }
1312 
1313         private Rectangle getClipNoClone() {
1314             return clip;
1315         }
1316 
1317         private Layer getLayerNoClone() {
1318             return layer;
1319         }
1320 
1321         private void setLayer(Layer layer) {
1322             this.layer = layer;
1323         }
1324 
1325         private void setClip(Rectangle area) {
1326             clip = area;
1327         }
1328 
1329         private void clip(Rectangle area) {
1330             if (null == clip) {
1331                 clip = area;
1332             } else {
1333                 clip.intersectWith(area);
1334             }
1335         }
1336 
1337         private void setAlpha(float alpha) {
1338             this.alpha = alpha;
1339         }
1340 
1341         private float getAlpha() {
1342             return alpha;
1343         }
1344 
1345         private void setTextMode(boolean fill, boolean stroke, boolean clip) {
1346             textFill = fill;
1347             textStroke = stroke;
1348             textClip = clip;
1349         }
1350 
1351         private boolean isTextFill() {
1352             return textFill;
1353         }
1354 
1355         private boolean isTextStroke() {
1356             return textStroke;
1357         }
1358 
1359         private boolean isTextClip() {
1360             return textClip;
1361         }
1362 
1363         private void markAsRestorePoint() {
1364             restorePoint = true;
1365         }
1366 
1367         private boolean isRestorePoint() {
1368             return restorePoint;
1369         }
1370 
1371         private void setShadow(DropShadow shadow) {
1372             this.shadow = shadow;
1373         }
1374 
1375         private DropShadow getShadowNoClone() {
1376             return shadow;
1377         }
1378 
1379         private Affine3D getTransformNoClone() {
1380             return xform;
1381         }
1382 
1383         private GeneralTransform3D getPerspectiveTransformNoClone() {
1384             return perspectiveTransform;
1385         }
1386 
1387         private void setTransform(final Affine3D at) {
1388             this.xform.setTransform(at);
1389         }
1390 
1391         private void setPerspectiveTransform(final GeneralTransform3D gt) {
1392             this.perspectiveTransform.set(gt);
1393         }
1394 
1395         private void concatTransform(Affine3D at) {
1396             xform.concatenate(at);
1397         }
1398 
1399         private void translate(double dx, double dy) {
1400             xform.translate(dx, dy);
1401         }
1402 
1403         private void scale(double sx, double sy) {
1404             xform.scale(sx,sy);
1405         }
1406 
1407         private void rotate(double radians) {
1408             xform.rotate(radians);
1409         }
1410     }
1411 
1412     private abstract static class Layer {
1413         FilterContext fctx;
1414         PrDrawable buffer;
1415         Graphics graphics;
1416         final Rectangle bounds;
1417         boolean permanent;
1418 
1419         Layer(Graphics g, Rectangle bounds, boolean permanent) {
1420             this.bounds = new Rectangle(bounds);
1421             this.permanent = permanent;
1422 
1423             // avoid creating zero-size drawable, see also RT-21410
1424             int w = Math.max(bounds.width, 1);
1425             int h = Math.max(bounds.height, 1);
1426             fctx = getFilterContext(g);
1427             if (permanent) {
1428                 ResourceFactory f = GraphicsPipeline.getDefaultResourceFactory();
1429                 RTTexture rtt = f.createRTTexture(w, h, Texture.WrapMode.CLAMP_NOT_NEEDED);
1430                 rtt.makePermanent();
1431                 buffer = ((PrRenderer)Renderer.getRenderer(fctx)).createDrawable(rtt);
1432             } else {
1433                 buffer = (PrDrawable) Effect.getCompatibleImage(fctx, w, h);
1434             }
1435         }
1436 
1437         Graphics getGraphics() {
1438             if (graphics == null) {
1439                 graphics = buffer.createGraphics();
1440             }
1441             return graphics;
1442         }
1443 
1444         abstract void init(Graphics g);
1445 
1446         abstract void render(Graphics g);
1447 
1448         private void dispose() {
1449             if (buffer != null) {
1450                 if (permanent) {
1451                     buffer.flush(); // releases the resource
1452                 } else {
1453                     Effect.releaseCompatibleImage(fctx, buffer);
1454                 }
1455                 fctx = null;
1456                 buffer = null;
1457             }
1458         }
1459 
1460         private double getX() { return (double) bounds.x; }
1461         private double getY() { return (double) bounds.y; }
1462     }
1463 
1464     private final class TransparencyLayer extends Layer {
1465         private final float opacity;
1466 
1467         private TransparencyLayer(Graphics g, Rectangle bounds, float opacity) {
1468             super(g, bounds, false);
1469             this.opacity = opacity;
1470         }
1471 
1472         @Override void init(Graphics g) {
1473             state.setCompositeOperation(COMPOSITE_SOURCE_OVER);
1474         }
1475 
1476         @Override void render(Graphics g) {
1477             new Composite() {
1478                 @Override void doPaint(Graphics g) {
1479                     float op = g.getExtraAlpha();
1480                     g.setExtraAlpha(opacity);
1481                     Affine3D tx = new Affine3D(g.getTransformNoClone());
1482                     g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
1483                     g.drawTexture(buffer.getTextureObject(),
1484                             bounds.x, bounds.y, bounds.width, bounds.height);
1485                     g.setTransform(tx);
1486                     g.setExtraAlpha(op);
1487                 }
1488             }.paint(g);
1489         }
1490 
1491         @Override public String toString() {
1492             return String.format(&quot;TransparencyLayer[%d,%d + %dx%d, opacity %.2f]&quot;,
1493                 bounds.x, bounds.y, bounds.width, bounds.height, opacity);
1494         }
1495     }
1496 
1497     private static final class ClipLayer extends Layer {
1498         private final WCPath normalizedToClipPath;
1499         private boolean srcover;
1500 
1501         private ClipLayer(Graphics g, Rectangle bounds, WCPath normalizedToClipPath,
1502                           boolean permanent)
1503         {
1504             super(g, bounds, permanent);
1505             this.normalizedToClipPath = normalizedToClipPath;
1506             srcover = true;
1507         }
1508 
1509         @Override void init(Graphics g) {
1510             RTTexture texture = null;
1511             ReadbackGraphics readbackGraphics = null;
1512             try {
1513                 readbackGraphics = (ReadbackGraphics) g;
1514                 texture = readbackGraphics.readBack(bounds);
1515                 getGraphics().drawTexture(texture, 0, 0, bounds.width, bounds.height);
1516             } finally {
1517                 if (readbackGraphics != null &amp;&amp; texture != null) {
1518                     readbackGraphics.releaseReadBackBuffer(texture);
1519                 }
1520             }
1521             srcover = false;
1522         }
1523 
1524         @Override void render(Graphics g) {
1525             Path2D p2d = ((WCPathImpl)normalizedToClipPath).getPlatformPath();
1526 
1527             // render normalizedToClipPath to a drawable
1528             PrDrawable bufferImg = (PrDrawable) Effect.getCompatibleImage(
1529                     fctx, bounds.width, bounds.height);
1530             Graphics bufferGraphics = bufferImg.createGraphics();
1531 
1532             bufferGraphics.setPaint(Color.BLACK);
1533             bufferGraphics.fill(p2d);
1534 
1535             // blend buffer and clipImg onto |g|
1536             if (g instanceof MaskTextureGraphics &amp;&amp; ! (g instanceof PrinterGraphics)) {
1537                 MaskTextureGraphics mg = (MaskTextureGraphics) g;
1538                 if (srcover) {
1539                     mg.drawPixelsMasked(buffer.getTextureObject(),
1540                                         bufferImg.getTextureObject(),
1541                                         bounds.x, bounds.y, bounds.width, bounds.height,
1542                                         0, 0, 0, 0);
1543                 } else {
1544                     mg.maskInterpolatePixels(buffer.getTextureObject(),
1545                                              bufferImg.getTextureObject(),
1546                                              bounds.x, bounds.y, bounds.width, bounds.height,
1547                                              0, 0, 0, 0);
1548                 }
1549             } else {
1550                 Blend blend = new Blend(Blend.Mode.SRC_IN,
1551                         new PassThrough(bufferImg, bounds.width, bounds.height),
1552                         new PassThrough(buffer, bounds.width, bounds.height));
1553                 Affine3D tx = new Affine3D(g.getTransformNoClone());
1554                 g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
1555                 PrEffectHelper.render(blend, g, bounds.x, bounds.y, null);
1556                 g.setTransform(tx);
1557             }
1558 
1559             Effect.releaseCompatibleImage(fctx, bufferImg);
1560         }
1561 
1562         @Override public String toString() {
1563             return String.format(&quot;ClipLayer[%d,%d + %dx%d, path %s]&quot;,
1564                     bounds.x, bounds.y, bounds.width, bounds.height,
1565                     normalizedToClipPath);
1566         }
1567     }
1568 
1569     private abstract class Composite {
1570         abstract void doPaint(Graphics g);
1571 
1572         void paint() {
1573             paint(getGraphics(true));
1574         }
1575 
1576         void paint(Graphics g) {
1577             if (g != null) {
1578                 CompositeMode oldCompositeMode = g.getCompositeMode();
1579                 switch (state.getCompositeOperation()) {
1580                     // decode operations that don&#39;t require Blend first
1581                     case COMPOSITE_COPY:
1582                         g.setCompositeMode(CompositeMode.SRC);
1583                         doPaint(g);
1584                         g.setCompositeMode(oldCompositeMode);
1585                         break;
1586                     case COMPOSITE_SOURCE_OVER:
1587                         g.setCompositeMode(CompositeMode.SRC_OVER);
1588                         doPaint(g);
1589                         g.setCompositeMode(oldCompositeMode);
1590                         break;
1591                     default:
1592                         // other operations require usage of Blend
1593                         blend(g);
1594                         break;
1595                 }
1596                 isRootLayerValid = false;
1597             }
1598         }
1599 
1600         private void blend(Graphics g) {
1601             FilterContext fctx = getFilterContext(g);
1602             PrDrawable dstImg = null;
1603             PrDrawable srcImg = null;
1604             ReadbackGraphics readBackGraphics = null;
1605             RTTexture texture = null;
1606             Rectangle clip = state.getClipNoClone();
1607             WCImage image = getImage();
1608             try {
1609                 if (image != null &amp;&amp; image instanceof PrismImage) {
1610                     // blending on canvas
1611                     dstImg = (PrDrawable) Effect.getCompatibleImage(fctx, clip.width, clip.height);
1612                     Graphics dstG = dstImg.createGraphics();
1613                     ((PrismImage) image).draw(dstG,
1614                             0, 0, clip.width, clip.height,
1615                             clip.x, clip.y, clip.width, clip.height);
1616                 } else {
1617                     // blending on page
1618                     readBackGraphics = (ReadbackGraphics) g;
1619                     texture = readBackGraphics.readBack(clip);
1620                     dstImg = PrDrawable.create(fctx, texture);
1621                 }
1622 
1623                 srcImg = (PrDrawable) Effect.getCompatibleImage(fctx, clip.width, clip.height);
1624                 Graphics srcG = srcImg.createGraphics();
1625                 state.apply(srcG);
1626                 doPaint(srcG);
1627 
1628                 g.clear();
1629                 PrEffectHelper.render(createEffect(dstImg, srcImg, clip.width, clip.height), g, 0, 0, null);
1630 
1631             } finally {
1632                 if (srcImg != null) {
1633                     Effect.releaseCompatibleImage(fctx, srcImg);
1634                 }
1635                 if (dstImg != null) {
1636                     if (readBackGraphics != null &amp;&amp; texture != null) {
1637                         readBackGraphics.releaseReadBackBuffer(texture);
1638                     } else {
1639                         Effect.releaseCompatibleImage(fctx, dstImg);
1640                     }
1641                 }
1642             }
1643         }
1644 
1645         // provides some syntax sugar for createEffect()
1646         private Effect createBlend(Blend.Mode mode,
1647                                    PrDrawable dstImg,
1648                                    PrDrawable srcImg,
1649                                    int width,
1650                                    int height)
1651         {
1652             return new Blend(
1653                     mode,
1654                     new PassThrough(dstImg, width, height),
1655                     new PassThrough(srcImg, width, height));
1656         }
1657 
1658         private Effect createEffect(PrDrawable dstImg,
1659                                     PrDrawable srcImg,
1660                                     int width,
1661                                     int height)
1662         {
1663             switch (state.getCompositeOperation()) {
1664                 case COMPOSITE_CLEAR: // same as xor
1665                 case COMPOSITE_XOR:
1666                     return new Blend(
1667                             SRC_OVER,
1668                             createBlend(SRC_OUT, dstImg, srcImg, width, height),
1669                             createBlend(SRC_OUT, srcImg, dstImg, width, height)
1670                     );
1671                 case COMPOSITE_SOURCE_IN:
1672                     return createBlend(SRC_IN, dstImg, srcImg, width, height);
1673                 case COMPOSITE_SOURCE_OUT:
1674                     return createBlend(SRC_OUT, dstImg, srcImg, width, height);
1675                 case COMPOSITE_SOURCE_ATOP:
1676                     return createBlend(SRC_ATOP, dstImg, srcImg, width, height);
1677                 case COMPOSITE_DESTINATION_OVER:
1678                     return createBlend(SRC_OVER, srcImg, dstImg, width, height);
1679                 case COMPOSITE_DESTINATION_IN:
1680                     return createBlend(SRC_IN, srcImg, dstImg, width, height);
1681                 case COMPOSITE_DESTINATION_OUT:
1682                     return createBlend(SRC_OUT, srcImg, dstImg, width, height);
1683                 case COMPOSITE_DESTINATION_ATOP:
1684                     return createBlend(SRC_ATOP, srcImg, dstImg, width, height);
1685                 case COMPOSITE_HIGHLIGHT:
1686                     return createBlend(ADD, dstImg, srcImg, width, height);
1687                 default:
1688                     return createBlend(SRC_OVER, dstImg, srcImg, width, height);
1689             }
1690         }
1691     }
1692 
1693     private static final class PassThrough extends Effect {
1694         private final PrDrawable img;
1695         private final int width;
1696         private final int height;
1697 
1698         private PassThrough(PrDrawable img, int width, int height) {
1699             this.img = img;
1700             this.width = width;
1701             this.height = height;
1702         }
1703 
1704         @Override public ImageData filter(
1705                 FilterContext fctx,
1706                 BaseTransform transform,
1707                 Rectangle outputClip,
1708                 Object renderHelper,
1709                 Effect defaultInput) {
1710             // We have an unpaired lock() here, because unlocking is done
1711             // internally by ImageData. See RT-33625 for details.
1712             img.lock();
1713             ImageData imgData = new ImageData(fctx, img, new Rectangle(
1714                                               (int) transform.getMxt(),
1715                                               (int) transform.getMyt(),
1716                                               width, height));
1717             imgData.setReusable(true);
1718             return imgData;
1719         }
1720 
1721         @Override public RectBounds getBounds(
1722                 BaseTransform transform,
1723                 Effect defaultInput) {
1724             return null;
1725         }
1726 
1727         @Override public AccelType getAccelType(FilterContext fctx) {
1728             return AccelType.INTRINSIC;
1729         }
1730 
1731         @Override
1732         public boolean reducesOpaquePixels() {
1733             return false;
1734         }
1735 
1736         @Override
1737         public DirtyRegionContainer getDirtyRegions(Effect defaultInput, DirtyRegionPool regionPool) {
1738             return null;
1739         }
1740     }
1741 
1742     private static FilterContext getFilterContext(Graphics g) {
1743         Screen screen = g.getAssociatedScreen();
1744         if (screen == null) {
1745             ResourceFactory factory = g.getResourceFactory();
1746             return PrFilterContext.getPrinterContext(factory);
1747         } else {
1748             return PrFilterContext.getInstance(screen);
1749         }
1750     }
1751 
1752     @Override
1753     public void strokeArc(final int x, final int y, final int w, final int h,
1754                           final int startAngle, final int angleSpan)
1755     {
1756         if (log.isLoggable(Level.FINE)) {
1757             log.fine(String.format(&quot;strokeArc(%d, %d, %d, %d, %d, %d)&quot;,
1758                                    x, y, w, h, startAngle, angleSpan));
1759         }
1760         Arc2D arc = new Arc2D(x, y, w, h, startAngle, angleSpan, Arc2D.OPEN);
1761         if (state.getStrokeNoClone().isApplicable() &amp;&amp;
1762             !shouldRenderShape(arc, null, state.getStrokeNoClone().getPlatformStroke()))
1763         {
1764             return;
1765         }
1766         new Composite() {
1767             @Override void doPaint(Graphics g) {
1768                 if (state.getStrokeNoClone().apply(g)) {
1769                     g.draw(arc);
1770                 }
1771             }
1772         }.paint();
1773     }
1774 
1775     @Override
1776     public WCImage getImage() {
1777         return null;
1778     }
1779 
1780     @Override
1781     public void strokeRect(final float x, final float y, final float w, final float h,
1782                            final float lineWidth) {
1783         if (log.isLoggable(Level.FINE)) {
1784             log.fine(String.format(&quot;strokeRect_FFFFF(%f, %f, %f, %f, %f)&quot;,
1785                                    x, y, w, h, lineWidth));
1786         }
1787         BasicStroke stroke = new BasicStroke(
1788             lineWidth,
1789             BasicStroke.CAP_BUTT,
1790             BasicStroke.JOIN_MITER,
1791             Math.max(1.0f, lineWidth),
1792             state.getStrokeNoClone().getDashSizes(),
1793             state.getStrokeNoClone().getDashOffset());
1794 
1795         if (!shouldRenderRect(x, y, w, h, null, stroke)) {
1796             return;
1797         }
1798         new Composite() {
1799             @Override void doPaint(Graphics g) {
1800                 g.setStroke(stroke);
1801                 Paint paint = state.getStrokeNoClone().getPaint();
1802                 if (paint == null) {
1803                     paint = state.getPaintNoClone();
1804                 }
1805                 g.setPaint(paint);
1806                 g.drawRect(x, y, w, h);
1807             }
1808         }.paint();
1809     }
1810 
1811     @Override
1812     public void strokePath(final WCPath path) {
1813         log.fine(&quot;strokePath&quot;);
1814         if (path != null) {
1815             final BasicStroke stroke = state.getStrokeNoClone().getPlatformStroke();
1816             final DropShadow shadow = state.getShadowNoClone();
1817             final Path2D p2d = (Path2D)path.getPlatformPath();
1818 
1819             if ((stroke == null &amp;&amp; shadow == null) ||
1820                 !shouldRenderShape(p2d, shadow, stroke))
1821             {
1822                 return;
1823             }
1824             new Composite() {
1825                 @Override void doPaint(Graphics g) {
1826                     if (shadow != null) {
1827                         final NGPath node = new NGPath();
1828                         node.updateWithPath2d(p2d);
1829                         render(g, shadow, null, stroke, node);
1830                     } else if (stroke != null) {
1831                         Paint paint = state.getStrokeNoClone().getPaint();
1832                         if (paint == null) {
1833                             paint = state.getPaintNoClone();
1834                         }
1835                         g.setPaint(paint);
1836                         g.setStroke(stroke);
1837                         g.draw(p2d);
1838                     }
1839                 }
1840             }.paint();
1841         }
1842     }
1843 
1844     @Override
1845     public void fillPath(final WCPath path) {
1846         log.fine(&quot;fillPath&quot;);
1847         if (path != null) {
1848             if (!shouldRenderShape(((WCPathImpl)path).getPlatformPath(),
1849                                    state.getShadowNoClone(), null))
1850             {
1851                 return;
1852             }
1853             new Composite() {
1854                 @Override void doPaint(Graphics g) {
1855                     Path2D p2d = (Path2D) path.getPlatformPath();
1856                     Paint paint = state.getPaintNoClone();
1857                     DropShadow shadow = state.getShadowNoClone();
1858                     if (shadow != null) {
1859                         final NGPath node = new NGPath();
1860                         node.updateWithPath2d(p2d);
1861                         render(g, shadow, paint, null, node);
1862                     } else {
1863                         g.setPaint(paint);
1864                         g.fill(p2d);
1865                     }
1866                 }
1867             }.paint();
1868         }
1869     }
1870 
1871     public void setPerspectiveTransform(WCTransform tm) {
1872         final GeneralTransform3D at = new GeneralTransform3D().set(tm.getMatrix());
1873         state.setPerspectiveTransform(at);
1874         resetCachedGraphics();
1875     }
1876 
1877     public void setTransform(WCTransform tm) {
1878         final double m[] = tm.getMatrix();
1879         final Affine3D at = new Affine3D(new Affine2D(m[0], m[1], m[2], m[3], m[4], m[5]));
1880         if (state.getLayerNoClone() == null) {
1881             at.preConcatenate(baseTransform);
1882         }
1883         state.setTransform(at);
1884         resetCachedGraphics();
1885     }
1886 
1887     public WCTransform getTransform() {
1888         Affine3D xf = state.getTransformNoClone();
1889         return new WCTransform(xf.getMxx(), xf.getMyx(),
1890                                xf.getMxy(), xf.getMyy(),
1891                                xf.getMxt(), xf.getMyt());
1892     }
1893 
1894     public void concatTransform(WCTransform tm) {
1895         double m[] = tm.getMatrix();
1896         Affine3D at = new Affine3D(new Affine2D(m[0], m[1], m[2], m[3], m[4], m[5]));
1897         state.concatTransform(at);
1898         resetCachedGraphics();
1899     }
1900 
1901     @Override
1902     public void flush() {
1903         flushAllLayers();
1904     }
1905 
1906     @Override
1907     public WCGradient createLinearGradient(WCPoint p1, WCPoint p2) {
1908         return new WCLinearGradient(p1, p2);
1909     }
1910 
1911     @Override
1912     public WCGradient createRadialGradient(WCPoint p1, float r1, WCPoint p2, float r2) {
1913         return new WCRadialGradient(p1, r1, p2, r2);
1914     }
1915 }
    </pre>
  </body>
</html>
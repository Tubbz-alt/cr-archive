<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/java/com/sun/javafx/webkit/prism/WCGraphicsPrismContext.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.javafx.webkit.prism;
  27 
  28 import com.sun.glass.ui.Screen;
  29 import com.sun.javafx.font.FontStrike;
  30 import com.sun.javafx.font.Metrics;
  31 import com.sun.javafx.font.PGFont;
  32 import com.sun.javafx.geom.*;
  33 import com.sun.javafx.geom.transform.Affine2D;
  34 import com.sun.javafx.geom.transform.Affine3D;
  35 import com.sun.javafx.geom.transform.BaseTransform;
  36 import com.sun.javafx.geom.transform.GeneralTransform3D;
  37 import com.sun.javafx.logging.PlatformLogger;
  38 import com.sun.javafx.logging.PlatformLogger.Level;
  39 import com.sun.javafx.scene.text.GlyphList;
  40 import com.sun.javafx.scene.text.TextLayout;
  41 import com.sun.javafx.sg.prism.*;
  42 import com.sun.javafx.text.TextRun;
  43 import com.sun.prism.*;
  44 import com.sun.prism.paint.Color;
  45 import com.sun.prism.paint.Gradient;
  46 import com.sun.prism.paint.ImagePattern;
  47 import com.sun.prism.paint.Paint;
  48 import com.sun.scenario.effect.*;
  49 import com.sun.scenario.effect.impl.prism.PrDrawable;
  50 import com.sun.scenario.effect.impl.prism.PrEffectHelper;
  51 import com.sun.scenario.effect.impl.prism.PrFilterContext;
  52 import com.sun.webkit.graphics.*;
  53 
  54 import java.nio.ByteBuffer;
  55 import java.nio.ByteOrder;
  56 import java.security.AccessController;
  57 import java.security.PrivilegedAction;
  58 import java.util.ArrayList;
  59 import java.util.List;
  60 
  61 import static com.sun.scenario.effect.Blend.Mode.*;
  62 import com.sun.scenario.effect.impl.Renderer;
  63 import com.sun.scenario.effect.impl.prism.PrRenderer;
  64 
  65 class WCGraphicsPrismContext extends WCGraphicsContext {
  66 
  67     public enum Type {
  68         /**
  69          * Base context associated with the topmost page buffer.
  70          * Created and disposed during a single render pass.
  71          */
  72         PRIMARY,
  73 
  74         /**
  75          * A context associated with a dedicated buffer representing
  76          * a separate render target like canvas, buffered image etc.
  77          * Its life cycle is not limited to a single render pass.
  78          */
  79         DEDICATED
  80     }
  81 
  82     private final static PlatformLogger log =
  83             PlatformLogger.getLogger(WCGraphicsPrismContext.class.getName());
  84     private final static boolean DEBUG_DRAW_CLIP_SHAPE = Boolean.valueOf(
  85             AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) () -&gt;
  86             System.getProperty(&quot;com.sun.webkit.debugDrawClipShape&quot;, &quot;false&quot;)));
  87 
  88     Graphics baseGraphics;
  89     private BaseTransform baseTransform;
  90 
  91     private final List&lt;ContextState&gt; states = new ArrayList&lt;ContextState&gt;();
  92 
  93     private ContextState state = new ContextState();
  94 
  95     // Cache for getPlatformGraphics
  96     private Graphics cachedGraphics = null;
  97 
  98     private int fontSmoothingType;
  99     private boolean isRootLayerValid = false;
 100 
 101     WCGraphicsPrismContext(Graphics g) {
 102         state.setClip(g.getClipRect());
 103         state.setAlpha(g.getExtraAlpha());
 104         baseGraphics = g;
 105         initBaseTransform(g.getTransformNoClone());
 106     }
 107 
 108     WCGraphicsPrismContext() {
 109     }
 110 
 111     public Type type() {
 112         return Type.PRIMARY;
 113     }
 114 
 115     final void initBaseTransform(BaseTransform t) {
 116         baseTransform = new Affine3D(t);
 117         state.setTransform((Affine3D)baseTransform);
 118     }
 119 
 120     private void resetCachedGraphics() {
 121         cachedGraphics = null;
 122     }
 123 
 124     @Override
 125     public Object getPlatformGraphics() {
 126         return getGraphics(false);
 127     }
 128 
 129     Graphics getGraphics(boolean checkClip) {
 130         if (cachedGraphics == null) {
 131             Layer l = state.getLayerNoClone();
 132             cachedGraphics = (l != null)
 133                     ? l.getGraphics()
 134                     : baseGraphics;
 135 
 136             state.apply(cachedGraphics);
 137 
 138             if (log.isLoggable(Level.FINE)) {
 139                 log.fine(&quot;getPlatformGraphics for &quot; + this + &quot; : &quot; +
 140                          cachedGraphics);
 141             }
 142         }
 143 
 144         Rectangle clip = cachedGraphics.getClipRectNoClone();
 145         return (checkClip &amp;&amp; clip!=null &amp;&amp; clip.isEmpty())
 146             ? null
 147             : cachedGraphics;
 148     }
 149 
 150     public void saveState()
 151     {
 152         state.markAsRestorePoint();
 153         saveStateInternal();
 154     }
 155 
 156     private void saveStateInternal()
 157     {
 158         states.add(state);
 159         state = state.clone();
 160     }
 161 
 162     private void startNewLayer(Layer layer) {
 163         saveStateInternal();
 164 
 165         // layer has the same bounds as clip, so we have to translate
 166         Rectangle clip = state.getClipNoClone();
 167 
 168         //left-side (post-) translate.
 169         //NB! an order of transforms is essential!
 170         Affine3D newTr = new Affine3D(BaseTransform.getTranslateInstance(
 171                 -clip.x,
 172                 -clip.y));
 173         newTr.concatenate(state.getTransformNoClone());
 174 
 175         //move clip to (0, 0) - start of texture
 176         clip.x = 0;
 177         clip.y = 0;
 178         //no-clone - no-set!
 179 
 180         Graphics g = getGraphics(true);
 181         if (g != null &amp;&amp; g != baseGraphics) {
 182             layer.init(g);
 183         }
 184 
 185         state.setTransform(newTr);
 186         state.setLayer(layer);
 187 
 188         resetCachedGraphics();
 189     }
 190 
 191     private void renderLayer(final Layer layer) {
 192         WCTransform cur = getTransform();
 193 
 194         //translate to (layer.getX(), layer.getY())
 195         setTransform(new WCTransform(
 196             1.0, 0.0,
 197             0.0, 1.0,
 198             layer.getX(), layer.getY()));
 199 
 200         // composite drawing delegated to the layer rendering
 201         Graphics g = getGraphics(true);
 202         if (g != null) {
 203             layer.render(g);
 204         }
 205 
 206         //restore transform
 207         setTransform(cur);
 208     }
 209 
 210     private void restoreStateInternal() {
 211         int size = states.size();
 212         if (size == 0) {
 213             assert false: &quot;Unbalanced restoreState&quot;;
 214             return;
 215         }
 216 
 217         Layer layer = state.getLayerNoClone();
 218         state = states.remove(size - 1);
 219         if (layer != state.getLayerNoClone()) {
 220             renderLayer(layer);
 221             layer.dispose();
 222             if (log.isLoggable(Level.FINE)) {
 223                 log.fine(&quot;Popped layer &quot; + layer);
 224             }
 225         } else {
 226             resetCachedGraphics();
 227         }
 228     }
 229 
 230     public void restoreState()
 231     {
 232         log.fine(&quot;restoring state&quot;);
 233         do {
 234             restoreStateInternal();
 235         } while ( !state.isRestorePoint() );
 236     }
 237 
 238     /**
 239      *  Renders all layers to the underlaying Graphics, but preserves the
 240      *  current state and the states stack
 241      */
 242     private void flushAllLayers() {
 243         if (state == null) {
 244             // context disposed
 245             return;
 246         }
 247 
 248         if (isRootLayerValid) {
 249             log.fine(&quot;FlushAllLayers: root layer is valid, skipping&quot;);
 250             return;
 251         }
 252 
 253         if (log.isLoggable(Level.FINE)) {
 254             log.fine(&quot;FlushAllLayers&quot;);
 255         }
 256 
 257         ContextState currentState = state;
 258 
 259         for (int i = states.size() - 1; i &gt;=0; i--) {
 260             Layer layer = state.getLayerNoClone();
 261             state = states.get(i);
 262             if (layer != state.getLayerNoClone()) {
 263                 renderLayer(layer);
 264             } else {
 265                 resetCachedGraphics();
 266             }
 267         }
 268 
 269         Layer layer = state.getLayerNoClone();
 270         if (layer != null) {
 271             renderLayer(layer);
 272         }
 273 
 274         state = currentState;
 275         isRootLayerValid = true;
 276     }
 277 
 278 
 279     public void dispose() {
 280         if (!states.isEmpty()) {
 281             log.fine(&quot;Unbalanced saveState/restoreState&quot;);
 282         }
 283         for (ContextState state: states) {
 284             if (state.getLayerNoClone() != null) {
 285                 state.getLayerNoClone().dispose();
 286             }
 287         }
 288         states.clear();
 289 
 290         if (state != null &amp;&amp; state.getLayerNoClone() != null) {
 291             state.getLayerNoClone().dispose();
 292         }
 293         state = null;
 294     }
 295 
 296 
 297     public void setClip(WCPath path, boolean isOut) {
 298         Affine3D tr = new Affine3D(state.getTransformNoClone());
 299         path.transform(
 300                 tr.getMxx(), tr.getMyx(),
 301                 tr.getMxy(), tr.getMyy(),
 302                 tr.getMxt(), tr.getMyt());
 303         //path now is in node coordinates, as well as clip
 304 
 305         if (!isOut) {
 306             WCRectangle pathBounds = path.getBounds();
 307 
 308             // path bounds could be fractional so &#39;inclusive&#39; rounding
 309             // is used for determining clip rectangle
 310             int pixelX = (int) Math.floor(pathBounds.getX());
 311             int pixelY = (int) Math.floor(pathBounds.getY());
 312             int pixelW = (int) Math.ceil(pathBounds.getMaxX()) - pixelX;
 313             int pixelH = (int) Math.ceil(pathBounds.getMaxY()) - pixelY;
 314 
 315             state.clip(new Rectangle(pixelX, pixelY, pixelW, pixelH));
 316         }
 317 
 318         Rectangle clip = state.getClipNoClone();
 319 
 320         if (isOut) {
 321             path.addRect(clip.x, clip.y, clip.width, clip.height);
 322             //Out clip path is always EVENODD.
 323         }
 324 
 325         path.translate(-clip.x, -clip.y);
 326 
 327         Layer layer = new ClipLayer(
 328             getGraphics(false), clip, path, type() == Type.DEDICATED);
 329 
 330         startNewLayer(layer);
 331 
 332         if (log.isLoggable(Level.FINE)) {
 333             log.fine(&quot;setClip(WCPath &quot; + path.getID() + &quot;)&quot;);
 334             log.fine(&quot;Pushed layer &quot; + layer);
 335         }
 336     }
 337 
 338     private Rectangle transformClip(Rectangle localClip) {
 339         if (localClip==null) {
 340             return null;
 341         }
 342 
 343         float[] points = new float[] {
 344             localClip.x, localClip.y,
 345             localClip.x + localClip.width, localClip.y,
 346             localClip.x, localClip.y + localClip.height,
 347             localClip.x  + localClip.width, localClip.y + localClip.height};
 348         state.getTransformNoClone().transform(points, 0, points, 0, 4);
 349         float minX = Math.min(
 350                points[0], Math.min(
 351                points[2], Math.min(
 352                points[4], points[6])));
 353         float maxX = Math.max(
 354                points[0], Math.max(
 355                points[2], Math.max(
 356                points[4], points[6])));
 357         float minY = Math.min(
 358                points[1], Math.min(
 359                points[3], Math.min(
 360                points[5], points[7])));
 361         float maxY = Math.max(
 362                points[1], Math.max(
 363                points[3], Math.max(
 364                points[5], points[7])));
 365         return new Rectangle(new RectBounds(minX, minY, maxX, maxY));
 366 
 367 /* #1 loose rotate
 368         state.getTransformNoClone().transform(localClip, localClip);
 369 */
 370 /* #2 problem with negative coordinates
 371         RectBounds rb = TransformedShape.transformedShape(
 372             new RoundRectangle2D(localClip.x, localClip.y, localClip.width, localClip.height, 0, 0),
 373             state.getTransformNoClone()).getBounds();
 374         return rb.isEmpty()
 375             ? null
 376             : new Rectangle(rb);
 377  */
 378     }
 379 
 380     private void setClip(Rectangle shape) {
 381         Affine3D tr = state.getTransformNoClone();
 382         if (tr.getMxy() == 0 &amp;&amp; tr.getMxz() == 0
 383          &amp;&amp; tr.getMyx() == 0 &amp;&amp; tr.getMyz() == 0
 384          &amp;&amp; tr.getMzx() == 0 &amp;&amp; tr.getMzy() == 0) {
 385             //There is no rotation here: scale + translation.
 386             //Fast &amp; easy!
 387             state.clip(transformClip(shape));
 388             if (log.isLoggable(Level.FINE)) {
 389                 log.fine(&quot;setClip({0})&quot;, shape);
 390             }
 391             if (DEBUG_DRAW_CLIP_SHAPE) {
 392                 //Draw clip shape
 393                 Rectangle rc = state.getClipNoClone();
 394                 if (rc != null &amp;&amp; rc.width &gt;= 2 &amp;&amp; rc.height &gt;= 2) {
 395                     WCTransform cur = getTransform();
 396                     //translate to (layer.getX(), layer.getY())
 397                     setTransform(new WCTransform(
 398                         1.0, 0.0,
 399                         0.0, 1.0,
 400                         0.0, 0.0));
 401 
 402                     Graphics g2d = getGraphics(true);
 403                     if (g2d != null) {
 404                         float fbase = (float)Math.random();
 405                         g2d.setPaint(new Color(
 406                                 fbase,
 407                                 1f - fbase,
 408                                 0.5f,
 409                                 0.1f));
 410                         g2d.setStroke(new BasicStroke());
 411                         g2d.fillRect(rc.x, rc.y, rc.width, rc.height);
 412 
 413                         g2d.setPaint(new Color(
 414                                 1f - fbase,
 415                                 fbase,
 416                                 0.5f,
 417                                 1f));
 418                         g2d.drawRect(rc.x, rc.y, rc.width, rc.height);
 419                     }
 420                     //restore transform
 421                     setTransform(cur);
 422                     state.clip(new Rectangle(rc.x+1, rc.y+1, rc.width-2, rc.height-2));
 423                 }
 424             }
 425             if (cachedGraphics != null) {
 426                 cachedGraphics.setClipRect(state.getClipNoClone());
 427             }
 428         } else {
 429             //twisted axis set
 430             WCPath path = new WCPathImpl();
 431             path.addRect(shape.x, shape.y, shape.width, shape.height);
 432             setClip(path, false);
 433         }
 434     }
 435 
 436     public void setClip(int cx, int cy, int cw, int ch) {
 437         setClip(new Rectangle(cx, cy, cw, ch));
 438     }
 439 
 440     public void setClip(WCRectangle c) {
 441         setClip(new Rectangle((int)c.getX(), (int)c.getY(),
 442                               (int)c.getWidth(), (int)c.getHeight()));
 443     }
 444 
 445     public void setClip(int cx, int cy, int cw, int ch, WCImage maskImage) {
 446         setClip(new Rectangle(cx, cy, cw, ch));
 447         state.setClipMaskImage(maskImage);
 448     }
 449 
 450     public WCRectangle getClip() {
 451         Rectangle r = state.getClipNoClone();
 452         return r == null ? null : new WCRectangle(r.x, r.y, r.width, r.height);
 453     }
 454 
 455     protected Rectangle getClipRectNoClone() {
 456         return state.getClipNoClone();
 457     }
 458 
 459     protected Affine3D getTransformNoClone() {
 460         return state.getTransformNoClone();
 461     }
 462 
 463     public void translate(float x, float y) {
 464         if (log.isLoggable(Level.FINE)) {
 465             log.fine(&quot;translate({0},{1})&quot;, new Object[] {x, y});
 466         }
 467         state.translate(x, y);
 468         if (cachedGraphics != null) {
 469             cachedGraphics.translate(x, y);
 470         }
 471     }
 472 
 473     public void scale(float sx, float sy) {
 474         if (log.isLoggable(Level.FINE)) {
 475             log.fine(&quot;scale(&quot; + sx + &quot; &quot; + sy + &quot;)&quot;);
 476         }
 477         state.scale(sx, sy);
 478         if (cachedGraphics != null) {
 479             cachedGraphics.scale(sx, sy);
 480         }
 481     }
 482 
 483     public void rotate(float radians) {
 484         if (log.isLoggable(Level.FINE)) {
 485             log.fine(&quot;rotate(&quot; + radians + &quot;)&quot;);
 486         }
 487         state.rotate(radians);
 488         if (cachedGraphics != null) {
 489             cachedGraphics.setTransform(state.getTransformNoClone());
 490         }
 491     }
 492 
 493     // overriden in WCBufferedContext
 494     protected boolean shouldRenderRect(float x, float y, float w, float h,
 495                                        DropShadow shadow, BasicStroke stroke)
 496     {
 497         return true;
 498     }
 499 
 500     // overriden in WCBufferedContext
 501     protected boolean shouldRenderShape(Shape shape, DropShadow shadow, BasicStroke stroke) {
 502         return true;
 503     }
 504 
 505     // overriden in WCBufferedContext
 506     protected boolean shouldCalculateIntersection() {
 507         return false;
 508     }
 509 
 510     @Override
 511     public void fillRect(final float x, final float y, final float w, final float h, final Integer rgba) {
 512         if (log.isLoggable(Level.FINE)) {
 513             String format = (rgba != null)
 514                     ? &quot;fillRect(%f, %f, %f, %f, 0x%x)&quot;
 515                     : &quot;fillRect(%f, %f, %f, %f, null)&quot;;
 516             log.fine(String.format(format, x, y, w, h, rgba));
 517         }
 518         if (!shouldRenderRect(x, y, w, h, state.getShadowNoClone(), null)) {
 519             return;
 520         }
 521         new Composite() {
 522             @Override void doPaint(Graphics g) {
 523                 Paint paint = (rgba != null) ? createColor(rgba) : state.getPaintNoClone();
 524                 DropShadow shadow = state.getShadowNoClone();
 525                 // TextureMapperJava::drawSolidColor calls fillRect with perspective
 526                 // projection.
 527                 if (shadow != null || !state.getPerspectiveTransformNoClone().isIdentity()) {
 528                     final NGRectangle node = new NGRectangle();
 529                     node.updateRectangle(x, y, w, h, 0, 0);
 530                     render(g, shadow, paint, null, node);
<a name="1" id="anc1"></a><span class="line-modified"> 531                 } else if(state.getClipMaskImageNoClone() != null) {</span>
<span class="line-modified"> 532                     Rectangle rect = new Rectangle((int) x, (int) y, (int) w, (int) h);</span>
<span class="line-removed"> 533                     Rectangle transformedRect = new Rectangle();</span>
<span class="line-removed"> 534                     state.getTransformNoClone().transform(rect, transformedRect);</span>
 535                     RTTexture paintRtTexture = g.getResourceFactory().createRTTexture(
<a name="2" id="anc2"></a><span class="line-modified"> 536                             transformedRect.width, transformedRect.height, Texture.WrapMode.CLAMP_NOT_NEEDED);</span>
 537                     Graphics g1 = paintRtTexture.createGraphics();
 538                     g1.setPaint(paint);
<a name="3" id="anc3"></a><span class="line-modified"> 539                     g1.setTransform(PrismGraphicsManager.getPixelScaleTransform());</span>
<span class="line-removed"> 540                     g1.fillRect(0, 0, paintRtTexture.getContentWidth(), paintRtTexture.getContentHeight());</span>
 541 
 542                     RTImage maskImage = (RTImage) (state.getClipMaskImageNoClone());
 543                     Image nativeMaskImage = Image.fromByteBgraPreData(maskImage.getPixelBuffer(), maskImage.getWidth(),
 544                             maskImage.getHeight(), 0, maskImage.getPixelScale());
<a name="4" id="anc4"></a><span class="line-modified"> 545                     Texture maskTexture = g.getResourceFactory().createTexture(nativeMaskImage, Texture.Usage.STATIC,</span>
<span class="line-modified"> 546                             Texture.WrapMode.CLAMP_NOT_NEEDED);</span>
<span class="line-modified"> 547                     RTTexture maskRtTexture = g.getResourceFactory().createRTTexture(nativeMaskImage.getWidth(),</span>
<span class="line-modified"> 548                             nativeMaskImage.getHeight(), Texture.WrapMode.CLAMP_NOT_NEEDED);</span>



 549                     Graphics g2 = maskRtTexture.createGraphics();
<a name="5" id="anc5"></a><span class="line-modified"> 550                     g2.setTransform(PrismGraphicsManager.getPixelScaleTransform());</span>
<span class="line-modified"> 551                     g2.drawTexture(maskTexture, 0, 0, nativeMaskImage.getWidth(), nativeMaskImage.getHeight());</span>
 552                     maskTexture.dispose();
<a name="6" id="anc6"></a><span class="line-modified"> 553                     if(g instanceof MaskTextureGraphics &amp;&amp; !(g instanceof PrinterGraphics)) {</span>
<span class="line-modified"> 554                         MaskTextureGraphics mg = (MaskTextureGraphics) (g);</span>
<span class="line-modified"> 555                         mg.drawPixelsMasked(paintRtTexture, maskRtTexture, transformedRect.x, transformedRect.y,</span>
<span class="line-modified"> 556                                 transformedRect.width, transformedRect.height, 0, 0, 0, 0);</span>
<span class="line-modified"> 557                     } else {</span>
<span class="line-modified"> 558                         FilterContext filterContext = getFilterContext(g);</span>
<span class="line-modified"> 559                         PrDrawable imagePrDrawable = PrDrawable.create(filterContext, paintRtTexture);</span>
<span class="line-modified"> 560                         PrDrawable maskPrDrawable = PrDrawable.create(filterContext, maskRtTexture);</span>
<span class="line-modified"> 561                         Blend blend = new Blend(Blend.Mode.SRC_IN,</span>
<span class="line-modified"> 562                                 new PassThrough(maskPrDrawable, transformedRect.width, transformedRect.height),</span>
<span class="line-removed"> 563                                 new PassThrough(imagePrDrawable, transformedRect.width, transformedRect.height));</span>
<span class="line-removed"> 564                         Affine3D tx = new Affine3D(g.getTransformNoClone());</span>
<span class="line-removed"> 565                         g.setTransform(BaseTransform.IDENTITY_TRANSFORM);</span>
<span class="line-removed"> 566                         PrEffectHelper.render(blend, g, transformedRect.x, transformedRect.y, null);</span>
<span class="line-removed"> 567                         g.setTransform(tx);</span>
<span class="line-removed"> 568                     }</span>
 569                     paintRtTexture.dispose();
 570                     maskRtTexture.dispose();
 571                 } else {
 572                     g.setPaint(paint);
 573                     g.fillRect(x, y, w, h);
 574                 }
 575             }
 576         }.paint();
 577     }
 578 
 579     @Override
 580     public void fillRoundedRect(final float x, final float y, final float w, final float h,
 581         final float topLeftW, final float topLeftH, final float topRightW, final float topRightH,
 582         final float bottomLeftW, final float bottomLeftH, final float bottomRightW, final float bottomRightH,
 583         final int rgba)
 584     {
 585         if (log.isLoggable(Level.FINE)) {
 586             log.fine(String.format(&quot;fillRoundedRect(%f, %f, %f, %f, &quot;
 587                     + &quot;%f, %f, %f, %f, %f, %f, %f, %f, 0x%x)&quot;,
 588                     x, y, w, h, topLeftW, topLeftH, topRightW, topRightH,
 589                     bottomLeftW, bottomLeftH, bottomRightW, bottomRightH, rgba));
 590         }
 591         if (!shouldRenderRect(x, y, w, h, state.getShadowNoClone(), null)) {
 592             return;
 593         }
 594         new Composite() {
 595             @Override void doPaint(Graphics g) {
 596                 // Prism only supports single arcWidth/Height.
 597                 // We work around by calculating average width and height here
 598 
 599                 float arcW = (topLeftW + topRightW + bottomLeftW + bottomRightW) / 2;
 600                 float arcH = (topLeftH + topRightH + bottomLeftH + bottomRightH) / 2;
 601 
 602                 Paint paint = createColor(rgba);
 603                 DropShadow shadow = state.getShadowNoClone();
 604                 if (shadow != null) {
 605                     final NGRectangle node = new NGRectangle();
 606                     node.updateRectangle(x, y, w, h, arcW, arcH);
 607                     render(g, shadow, paint, null, node);
 608                 } else {
 609                     g.setPaint(paint);
 610                     g.fillRoundRect(x, y, w, h, arcW, arcH);
 611                 }
 612             }
 613         }.paint();
 614     }
 615 
 616     @Override
 617     public void clearRect(final float x, final float y, final float w, final float h) {
 618         if (log.isLoggable(Level.FINE)) {
 619             log.fine(String.format(&quot;clearRect(%f, %f, %f, %f)&quot;, x, y, w, h));
 620         }
 621         if (shouldCalculateIntersection()) {
 622             // No intersection is applicable for clearRect.
 623             return;
 624         }
 625         new Composite() {
 626             @Override void doPaint(Graphics g) {
 627                 g.clearQuad(x, y, x + w, y + h);
 628             }
 629         }.paint();
 630     }
 631 
 632     @Override
 633     public void setFillColor(int rgba) {
 634         if (log.isLoggable(Level.FINE)) {
 635             log.fine(String.format(&quot;setFillColor(0x%x)&quot;, rgba));
 636         }
 637         state.setPaint(createColor(rgba));
 638     }
 639 
 640     @Override
 641     public void setFillGradient(WCGradient gradient) {
 642         if (log.isLoggable(Level.FINE)) {
 643             log.fine(&quot;setFillGradient(&quot; + gradient + &quot;)&quot;);
 644         }
 645         state.setPaint((Gradient) gradient.getPlatformGradient());
 646     }
 647 
 648     @Override
 649     public void setTextMode(boolean fill, boolean stroke, boolean clip) {
 650         if (log.isLoggable(Level.FINE)) {
 651             log.fine(&quot;setTextMode(fill:&quot; + fill + &quot;,stroke:&quot; + stroke + &quot;,clip:&quot; + clip + &quot;)&quot;);
 652         }
 653         state.setTextMode(fill, stroke, clip);
 654     }
 655 
 656     @Override
 657     public void setFontSmoothingType(int fontSmoothingType) {
 658         this.fontSmoothingType = fontSmoothingType;
 659     }
 660 
 661     @Override
 662     public int getFontSmoothingType() {
 663         return fontSmoothingType;
 664     }
 665 
 666     @Override
 667     public void setStrokeStyle(int style) {
 668         if (log.isLoggable(Level.FINE)) {
 669             log.fine(&quot;setStrokeStyle({0})&quot;, style);
 670         }
 671         state.getStrokeNoClone().setStyle(style);
 672     }
 673 
 674     @Override
 675     public void setStrokeColor(int rgba) {
 676         if (log.isLoggable(Level.FINE)) {
 677             log.fine(String.format(&quot;setStrokeColor(0x%x)&quot;, rgba));
 678         }
 679         state.getStrokeNoClone().setPaint(createColor(rgba));
 680     }
 681 
 682     @Override
 683     public void setStrokeWidth(float width) {
 684         if (log.isLoggable(Level.FINE)) {
 685             log.fine(&quot;setStrokeWidth({0})&quot;, new Object[] { width });
 686         }
 687         state.getStrokeNoClone().setThickness(width);
 688     }
 689 
 690     @Override
 691     public void setStrokeGradient(WCGradient gradient) {
 692         if (log.isLoggable(Level.FINE)) {
 693             log.fine(&quot;setStrokeGradient(&quot; + gradient + &quot;)&quot;);
 694         }
 695         state.getStrokeNoClone().setPaint((Gradient) gradient.getPlatformGradient());
 696     }
 697 
 698     @Override
 699     public void setLineDash(float offset, float... sizes) {
 700         if (log.isLoggable(Level.FINE)) {
 701             StringBuilder s = new StringBuilder(&quot;[&quot;);
 702             for (int i=0; i &lt; sizes.length; i++) {
 703                 s.append(sizes[i]).append(&#39;,&#39;);
 704             }
 705             s.append(&#39;]&#39;);
 706             log.fine(&quot;setLineDash({0},{1}&quot;, new Object[] {offset, s});
 707         }
 708         state.getStrokeNoClone().setDashOffset(offset);
 709         if (sizes != null) {
 710             boolean allZero = true;
 711             for (int i = 0; i &lt; sizes.length; i++) {
 712                 if (sizes[i] != 0) {
 713                     allZero = false;
 714                     break;
 715                 }
 716             }
 717             if (allZero) {
 718                 sizes = null;
 719             }
 720         }
 721         state.getStrokeNoClone().setDashSizes(sizes);
 722     }
 723 
 724     @Override
 725     public void setLineCap(int lineCap) {
 726         if (log.isLoggable(Level.FINE)) {
 727             log.fine(&quot;setLineCap(&quot; + lineCap + &quot;)&quot;);
 728         }
 729         state.getStrokeNoClone().setLineCap(lineCap);
 730     }
 731 
 732     @Override
 733     public void setLineJoin(int lineJoin) {
 734         if (log.isLoggable(Level.FINE)) {
 735             log.fine(&quot;setLineJoin(&quot; + lineJoin + &quot;)&quot;);
 736         }
 737         state.getStrokeNoClone().setLineJoin(lineJoin);
 738     }
 739 
 740     @Override
 741     public void setMiterLimit(float miterLimit) {
 742         if (log.isLoggable(Level.FINE)) {
 743             log.fine(&quot;setMiterLimit(&quot; + miterLimit + &quot;)&quot;);
 744         }
 745         state.getStrokeNoClone().setMiterLimit(miterLimit);
 746     }
 747 
 748     @Override
 749     public void setShadow(float dx, float dy, float blur, int rgba) {
 750         if (log.isLoggable(Level.FINE)) {
 751             String format = &quot;setShadow(%f, %f, %f, 0x%x)&quot;;
 752             log.fine(String.format(format, dx, dy, blur, rgba));
 753         }
 754         state.setShadow(createShadow(dx, dy, blur, rgba));
 755     }
 756 
 757     @Override
 758     public void drawPolygon(final WCPath path, final boolean shouldAntialias) {
 759         if (log.isLoggable(Level.FINE)) {
 760             log.fine(&quot;drawPolygon({0})&quot;,
 761                     new Object[] {shouldAntialias});
 762         }
 763         if (!shouldRenderShape(((WCPathImpl)path).getPlatformPath(), null,
 764                                 state.getStrokeNoClone().getPlatformStroke()))
 765         {
 766             return;
 767         }
 768         new Composite() {
 769             @Override void doPaint(Graphics g) {
 770                 Path2D p2d = (Path2D) path.getPlatformPath();
 771                 g.setPaint(state.getPaintNoClone());
 772                 g.fill(p2d);
 773                 if (state.getStrokeNoClone().apply(g)) {
 774                     g.draw(p2d);
 775                 }
 776             }
 777         }.paint();
 778     }
 779 
 780     @Override
 781     public void drawLine(final int x0, final int y0, final int x1, final int y1) {
 782         if (log.isLoggable(Level.FINE)) {
 783             log.fine(&quot;drawLine({0}, {1}, {2}, {3})&quot;,
 784                     new Object[] {x0, y0, x1, y1});
 785         }
 786         Line2D line = new Line2D(x0, y0, x1, y1);
 787         if (!shouldRenderShape(line, null, state.getStrokeNoClone().getPlatformStroke())) {
 788             return;
 789         }
 790         new Composite() {
 791             @Override void doPaint(Graphics g) {
 792                 if (state.getStrokeNoClone().apply(g)) {
 793                     g.drawLine(x0, y0, x1, y1);
 794                 }
 795             }
 796         }.paint();
 797     }
 798 
 799     @Override
 800     public void drawPattern(
 801         final WCImage texture,
 802         final WCRectangle srcRect,
 803         final WCTransform patternTransform,
 804         final WCPoint phase,
 805         final WCRectangle destRect)
 806     {
 807         if (log.isLoggable(Level.FINE)) {
 808             log.fine(&quot;drawPattern({0}, {1}, {2}, {3})&quot;,
 809                     new Object[] {destRect.getIntX(), destRect.getIntY(),
 810                                   destRect.getIntWidth(),
 811                                   destRect.getIntHeight()});
 812         }
 813         if (!shouldRenderRect(destRect.getX(), destRect.getY(),
 814                               destRect.getWidth(), destRect.getHeight(), null, null))
 815         {
 816             return;
 817         }
 818         if (texture != null) {
 819             new Composite() {
 820                 @Override void doPaint(Graphics g) {
 821                     // The handling of pattern transform is modeled after the WebKit
 822                     // ImageCG.cpp&#39;s Image::drawPattern()
 823                     float adjustedX = phase.getX()
 824                             + srcRect.getX() * (float) patternTransform.getMatrix()[0];
 825                     float adjustedY = phase.getY()
 826                             + srcRect.getY() * (float) patternTransform.getMatrix()[3];
 827                     float scaledTileWidth =
 828                             srcRect.getWidth() * (float) patternTransform.getMatrix()[0];
 829                     float scaledTileHeight =
 830                             srcRect.getHeight() * (float) patternTransform.getMatrix()[3];
 831 
 832                     Image img = ((PrismImage)texture).getImage();
 833 
 834                     // Create subImage only if srcRect doesn&#39;t fit the texture bounds. See RT-20193.
 835                     if (!srcRect.contains(new WCRectangle(0, 0, texture.getWidth(), texture.getHeight()))) {
 836 
 837                         img = img.createSubImage(srcRect.getIntX(),
 838                                                  srcRect.getIntY(),
 839                                                  (int)Math.ceil(srcRect.getWidth()),
 840                                                  (int)Math.ceil(srcRect.getHeight()));
 841                     }
 842                     g.setPaint(new ImagePattern(
 843                                img,
 844                                adjustedX, adjustedY,
 845                                scaledTileWidth, scaledTileHeight,
 846                                false, false));
 847 
 848                     g.fillRect(destRect.getX(), destRect.getY(),
 849                                destRect.getWidth(), destRect.getHeight());
 850                 }
 851             }.paint();
 852         }
 853     }
 854 
 855     @Override
 856     public void drawImage(final WCImage img,
 857                           final float dstx, final float dsty, final float dstw, final float dsth,
 858                           final float srcx, final float srcy, final float srcw, final float srch)
 859     {
 860         if (log.isLoggable(Level.FINE)){
 861             log.fine(&quot;drawImage(img, dst({0},{1},{2},{3}), &quot; +
 862                     &quot;src({4},{5},{6},{7}))&quot;,
 863                     new Object[] {dstx, dsty, dstw, dsth,
 864                                   srcx, srcy, srcw, srch});
 865         }
 866         if (!shouldRenderRect(dstx, dsty, dstw, dsth, state.getShadowNoClone(), null)) {
 867             return;
 868         }
 869         if (img instanceof PrismImage) {
 870             new Composite() {
 871                 @Override void doPaint(Graphics g) {
 872                     PrismImage pi = (PrismImage) img;
 873                     DropShadow shadow = state.getShadowNoClone();
 874                     if (shadow != null) {
 875                         NGImageView node = new NGImageView();
 876                         node.setImage(pi.getImage());
 877                         node.setX(dstx);
 878                         node.setY(dsty);
 879                         node.setViewport(srcx, srcy, srcw, srch, dstw, dsth);
 880                         node.setContentBounds(new RectBounds(dstx, dsty, dstx + dstw, dsty + dsth));
 881                         render(g, shadow, null, null, node);
 882                     } else {
 883                         pi.draw(g,
 884                                 (int) dstx, (int) dsty,
 885                                 (int) (dstx + dstw), (int) (dsty + dsth),
 886                                 (int) srcx, (int) srcy,
 887                                 (int) (srcx + srcw), (int) (srcy + srch));
 888                     }
 889                 }
 890             }.paint();
 891         }
 892     }
 893 
 894     @Override
 895     public void drawBitmapImage(final ByteBuffer image, final int x, final int y, final int w, final int h) {
 896         if (!shouldRenderRect(x, y, w, h, null, null)) {
 897             return;
 898         }
 899         new Composite() {
 900             @Override void doPaint(Graphics g) {
 901                 image.order(ByteOrder.nativeOrder());
 902                 Image img = Image.fromByteBgraPreData(image, w, h);
 903                 ResourceFactory rf = g.getResourceFactory();
 904                 Texture txt = rf.createTexture(img, Texture.Usage.STATIC, Texture.WrapMode.REPEAT);
 905                 g.drawTexture(txt, x, y, x + w, y + h, 0, 0, w, h);
 906                 txt.dispose();
 907             }
 908         }.paint();
 909     }
 910 
 911     @Override
 912     public void drawIcon(WCIcon icon, int x, int y) {
 913         if (log.isLoggable(Level.FINE)) {
 914             log.fine(&quot;UNIMPLEMENTED drawIcon ({0}, {1})&quot;,
 915                     new Object[] {x, y});
 916         }
 917     }
 918 
 919     @Override
 920     public void drawRect(final int x, final int y, final int w, final int h) {
 921         if (log.isLoggable(Level.FINE)) {
 922             log.fine(&quot;drawRect({0}, {1}, {2}, {3})&quot;,
 923                     new Object[]{x, y, w, h});
 924         }
 925         if (!shouldRenderRect(x, y, w, h,
 926                               null, state.getStrokeNoClone().getPlatformStroke()))
 927         {
 928             return;
 929         }
 930         new Composite() {
 931             @Override void doPaint(Graphics g) {
 932                 Paint c = state.getPaintNoClone();
 933                 if (c != null &amp;&amp; c.isOpaque()) {
 934                     g.setPaint(c);
 935                     g.fillRect(x, y, w, h);
 936                 }
 937 
 938                 if (state.getStrokeNoClone().apply(g)) {
 939                     g.drawRect(x, y, w, h);
 940                 }
 941             }
 942         }.paint();
 943     }
 944 
 945     @Override
 946     public void drawString(final WCFont f, final int[] glyphs,
 947                            final float[] advances, final float x, final float y)
 948     {
 949         if (log.isLoggable(Level.FINE)) {
 950             log.fine(String.format(
 951                     &quot;Drawing %d glyphs @(%.1f, %.1f)&quot;,
 952                     glyphs.length, x, y));
 953         }
 954         PGFont font = (PGFont)f.getPlatformFont();
 955         TextRun gl = TextUtilities.createGlyphList(glyphs, advances, x, y);
 956 
 957         DropShadow shadow = state.getShadowNoClone();
 958         BasicStroke stroke = state.isTextStroke()
 959                 ? state.getStrokeNoClone().getPlatformStroke()
 960                 : null;
 961 
 962         final FontStrike strike = font.getStrike(getTransformNoClone(), getFontSmoothingType());
 963         if (shouldCalculateIntersection()) {
 964             Metrics m = strike.getMetrics();
 965             gl.setMetrics(m.getAscent(), m.getDescent(), m.getLineGap());
 966             if (!shouldRenderRect(x, y, gl.getWidth(), gl.getHeight(), shadow, stroke)) {
 967                 return;
 968             }
 969         }
 970         new Composite() {
 971             @Override void doPaint(Graphics g) {
 972                 Paint paint = state.isTextFill()
 973                         ? state.getPaintNoClone()
 974                         : null;
 975                 if (shadow != null) {
 976                     final NGText span = new NGText();
 977                     span.setGlyphs(new GlyphList[] {gl});
 978                     span.setFont(font);
 979                     span.setFontSmoothingType(fontSmoothingType);
 980                     render(g, shadow, paint, stroke, span);
 981                 } else {
 982                     if (paint != null) {
 983                         g.setPaint(paint);
 984                         g.drawString(gl, strike, x, y, null, 0, 0);
 985                     }
 986                     if (stroke != null) {
 987                         paint = state.getStrokeNoClone().getPaint();
 988                         if (paint != null) {
 989                             g.setPaint(paint);
 990                             g.setStroke(stroke);
 991                             g.draw(strike.getOutline(gl, BaseTransform.getTranslateInstance(x, y)));
 992                         }
 993                     }
 994                 }
 995             }
 996         }.paint();
 997     }
 998 
 999     @Override public void drawString(WCFont f, String str, boolean rtl,
1000             int from, int to, float x, float y)
1001     {
1002         if (log.isLoggable(Level.FINE)) {
1003             log.fine(String.format(
1004                     &quot;str=&#39;%s&#39; (length=%d), from=%d, to=%d, rtl=%b, @(%.1f, %.1f)&quot;,
1005                     str, str.length(), from, to, rtl, x, y));
1006         }
1007         TextLayout layout = TextUtilities.createLayout(
1008                 str.substring(from, to), f.getPlatformFont());
1009         int count = 0;
1010         GlyphList[] runs = layout.getRuns();
1011         for (GlyphList run: runs) {
1012             count += run.getGlyphCount();
1013         }
1014 
1015         int[] glyphs = new int[count];
1016         float[] adv = new float[count];
1017         count = 0;
1018         for (GlyphList run: layout.getRuns()) {
1019             int gc = run.getGlyphCount();
1020             for (int i = 0; i &lt; gc; i++) {
1021                 glyphs[count] = run.getGlyphCode(i);
1022                 adv[count] = run.getPosX(i + 1) - run.getPosX(i);
1023                 count++;
1024             }
1025         }
1026 
1027         // adjust x coordinate (see RT-29908)
1028         if (rtl) {
1029             x += (TextUtilities.getLayoutWidth(str.substring(from), f.getPlatformFont()) -
1030                   layout.getBounds().getWidth());
1031         } else {
1032             x += TextUtilities.getLayoutWidth(str.substring(0, from), f.getPlatformFont());
1033         }
1034         drawString(f, glyphs, adv, x, y);
1035     }
1036 
1037     @Override
1038     public void setComposite(int composite) {
1039         log.fine(&quot;setComposite({0})&quot;, composite);
1040         state.setCompositeOperation(composite);
1041     }
1042 
1043     @Override
1044     public void drawEllipse(final int x, final int y, final int w, final int h) {
1045         if (log.isLoggable(Level.FINE)) {
1046             log.fine(&quot;drawEllipse({0}, {1}, {2}, {3})&quot;,
1047                     new Object[] { x, y, w, h});
1048         }
1049         if (!shouldRenderRect(x, y, w, h,
1050                               null, state.getStrokeNoClone().getPlatformStroke()))
1051         {
1052             return;
1053         }
1054         new Composite() {
1055             @Override void doPaint(Graphics g) {
1056                 g.setPaint(state.getPaintNoClone());
1057                 g.fillEllipse(x, y, w, h);
1058                 if (state.getStrokeNoClone().apply(g)) {
1059                     g.drawEllipse(x, y, w, h);
1060                 }
1061             }
1062         }.paint();
1063     }
1064 
1065     private final static BasicStroke focusRingStroke =
1066         new BasicStroke(1.1f, BasicStroke.CAP_BUTT,
1067                          BasicStroke.JOIN_ROUND, 0.0f,
1068                          new float[] {1.0f}, 0.0f);
1069 
1070     @Override
1071     public void drawFocusRing(final int x, final int y, final int w, final int h, final int rgba) {
1072         if (log.isLoggable(Level.FINE)) {
1073             log.fine(String.format(&quot;drawFocusRing: %d, %d, %d, %d, 0x%x&quot;, x, y, w, h, rgba));
1074         }
1075         if (!shouldRenderRect(x, y, w, h, null, focusRingStroke)) {
1076             return;
1077         }
1078         new Composite() {
1079             @Override void doPaint(Graphics g) {
1080                 g.setPaint(createColor(rgba));
1081                 BasicStroke stroke = g.getStroke();
1082                 g.setStroke(focusRingStroke);
1083                 g.drawRoundRect(x, y, w, h, 4, 4);
1084                 g.setStroke(stroke);
1085             }
1086         }.paint();
1087     }
1088 
1089     public void setAlpha(float alpha) {
1090         log.fine(&quot;setAlpha({0})&quot;, alpha);
1091 
1092         state.setAlpha(alpha);
1093 
1094         if (null != cachedGraphics) {
1095             cachedGraphics.setExtraAlpha(state.getAlpha());
1096         }
1097     }
1098 
1099     public float getAlpha() {
1100         return state.getAlpha();
1101     }
1102 
1103     @Override public void beginTransparencyLayer(float opacity) {
1104         TransparencyLayer layer = new TransparencyLayer(
1105                 getGraphics(false), state.getClipNoClone(), opacity);
1106 
1107         if (log.isLoggable(Level.FINE)) {
1108             log.fine(String.format(&quot;beginTransparencyLayer(%s)&quot;, layer));
1109         }
1110 
1111         //[saveStateIntertal] will work as [saveState]
1112         state.markAsRestorePoint();
1113 
1114         startNewLayer(layer);
1115     }
1116 
1117     @Override public void endTransparencyLayer() {
1118         if (log.isLoggable(Level.FINE)) {
1119             log.fine(String.format(&quot;endTransparencyLayer(%s)&quot;, state.getLayerNoClone()));
1120         }
1121 
1122         //pair to [startNewLayer] that works as [saveState] call
1123         restoreState();
1124     }
1125 
1126     @Override
1127     public void drawWidget(final RenderTheme theme, final Ref widget, final int x, final int y) {
1128         WCSize s = theme.getWidgetSize(widget);
1129         if (!shouldRenderRect(x, y, s.getWidth(), s.getHeight(), null, null)) {
1130             return;
1131         }
1132         new Composite() {
1133             @Override void doPaint(Graphics g) {
1134                 theme.drawWidget(WCGraphicsPrismContext.this, widget, x, y);
1135             }
1136         }.paint();
1137     }
1138 
1139     @Override
1140     public void drawScrollbar(final ScrollBarTheme theme, final Ref widget, int x, int y,
1141                               int pressedPart, int hoveredPart)
1142     {
1143         if (log.isLoggable(Level.FINE)) {
1144             log.fine(String.format(&quot;drawScrollbar(%s, %s, x = %d, y = %d)&quot;, theme, widget, x, y));
1145         }
1146 
1147         WCSize s = theme.getWidgetSize(widget);
1148         if (!shouldRenderRect(x, y, s.getWidth(), s.getHeight(), null, null)) {
1149             return;
1150         }
1151         new Composite() {
1152             @Override void doPaint(Graphics g) {
1153                 theme.paint(WCGraphicsPrismContext.this, widget, x, y, pressedPart, hoveredPart);
1154             }
1155         }.paint();
1156     }
1157 
1158     private static Rectangle intersect(Rectangle what, Rectangle with) {
1159         if (what == null) {
1160             return with;
1161         }
1162         RectBounds b = what.toRectBounds();
1163         b.intersectWith(with);
1164         what.setBounds(b);
1165         return what;
1166     }
1167 
1168     static Color createColor(int rgba) {
1169         float a = (0xFF &amp; (rgba &gt;&gt; 24)) / 255.0f;
1170         float r = (0xFF &amp; (rgba &gt;&gt; 16)) / 255.0f;
1171         float g = (0xFF &amp; (rgba &gt;&gt; 8)) / 255.0f;
1172         float b = (0xFF &amp; (rgba)) / 255.0f;
1173         return new Color(r, g, b, a);
1174     }
1175 
1176     private static Color4f createColor4f(int rgba) {
1177         float a = (0xFF &amp; (rgba &gt;&gt; 24)) / 255.0f;
1178         float r = (0xFF &amp; (rgba &gt;&gt; 16)) / 255.0f;
1179         float g = (0xFF &amp; (rgba &gt;&gt; 8)) / 255.0f;
1180         float b = (0xFF &amp; (rgba)) / 255.0f;
1181         return new Color4f(r, g, b, a);
1182     }
1183 
1184     private DropShadow createShadow(float dx, float dy, float blur, int rgba) {
1185         if (dx == 0f &amp;&amp; dy == 0f &amp;&amp; blur == 0f) {
1186             return null;
1187         }
1188         DropShadow shadow = new DropShadow();
1189         shadow.setOffsetX((int) dx);
1190         shadow.setOffsetY((int) dy);
1191         shadow.setRadius((blur &lt; 0f) ? 0f : (blur &gt; 127f) ? 127f : blur);
1192         shadow.setColor(createColor4f(rgba));
1193         return shadow;
1194     }
1195 
1196     private void render(Graphics g, Effect effect, Paint paint, BasicStroke stroke, NGNode node) {
1197         if (node instanceof NGShape) {
1198             NGShape shape = (NGShape) node;
1199             Shape realShape = shape.getShape();
1200             Paint strokePaint = state.getStrokeNoClone().getPaint();
1201             if ((stroke != null) &amp;&amp; (strokePaint != null)) {
1202                 realShape = stroke.createStrokedShape(realShape);
1203                 shape.setDrawStroke(stroke);
1204                 shape.setDrawPaint(strokePaint);
1205                 shape.setMode((paint == null) ? NGShape.Mode.STROKE : NGShape.Mode.STROKE_FILL);
1206             } else {
1207                 shape.setMode((paint == null) ? NGShape.Mode.EMPTY : NGShape.Mode.FILL);
1208             }
1209             shape.setFillPaint(paint);
1210             shape.setContentBounds(realShape.getBounds());
1211         }
1212         boolean culling = g.hasPreCullingBits();
1213         g.setHasPreCullingBits(false);
1214         node.setEffect(effect);
1215         node.render(g);
1216         g.setHasPreCullingBits(culling);
1217     }
1218 
1219     private static final class ContextState {
1220         private final WCStrokeImpl stroke = new WCStrokeImpl();
1221         private Rectangle clip;
1222         private Paint paint;
1223         private float alpha;
1224 
1225         private boolean textFill = true;
1226         private boolean textStroke = false;
1227         private boolean textClip = false;
1228         private boolean restorePoint = false;
1229 
1230         private DropShadow shadow;
1231         private Affine3D xform;
1232         private GeneralTransform3D perspectiveTransform;
1233         private Layer layer;
1234         private int compositeOperation;
1235         private WCImage clipMaskImage;
1236 
1237         private ContextState() {
1238             clip = null;
1239             paint = Color.BLACK;
1240             stroke.setPaint(Color.BLACK);
1241             alpha = 1.0f;
1242             xform = new Affine3D();
1243             perspectiveTransform = new GeneralTransform3D();
1244             compositeOperation = COMPOSITE_SOURCE_OVER;
1245         }
1246 
1247         private ContextState(ContextState state) {
1248             stroke.copyFrom(state.getStrokeNoClone());
1249             setPaint(state.getPaintNoClone());
1250             clip = state.getClipNoClone();
1251             if (clip != null) {
1252                 clip = new Rectangle(clip);
1253             }
1254             xform = new Affine3D(state.getTransformNoClone());
1255             perspectiveTransform = new GeneralTransform3D().set(state.getPerspectiveTransformNoClone());
1256             setShadow(state.getShadowNoClone());
1257             setLayer(state.getLayerNoClone());
1258             setAlpha(state.getAlpha());
1259             setTextMode(state.isTextFill(), state.isTextStroke(), state.isTextClip());
1260             setCompositeOperation(state.getCompositeOperation());
1261             setClipMaskImage(state.getClipMaskImageNoClone());
1262         }
1263 
1264         @Override
1265         protected ContextState clone() {
1266             return new ContextState(this);
1267         }
1268 
1269         private void apply(Graphics g) {
1270             g.setTransform(getTransformNoClone());
1271             g.setPerspectiveTransform(getPerspectiveTransformNoClone());
1272             g.setClipRect(getClipNoClone());
1273             g.setExtraAlpha(getAlpha());
1274         }
1275 
1276         private int getCompositeOperation() {
1277             return compositeOperation;
1278         }
1279 
1280         private void setCompositeOperation(int compositeOperation) {
1281             this.compositeOperation = compositeOperation;
1282         }
1283 
1284         private WCStrokeImpl getStrokeNoClone() {
1285             return stroke;
1286         }
1287 
1288         private Paint getPaintNoClone() {
1289             return paint;
1290         }
1291 
1292         private void setPaint(Paint paint) {
1293             this.paint = paint;
1294         }
1295 
1296         private void setClipMaskImage(WCImage image) {
1297             this.clipMaskImage = image;
1298         }
1299 
1300         private WCImage getClipMaskImageNoClone() {
1301             return clipMaskImage;
1302         }
1303 
1304         private Rectangle getClipNoClone() {
1305             return clip;
1306         }
1307 
1308         private Layer getLayerNoClone() {
1309             return layer;
1310         }
1311 
1312         private void setLayer(Layer layer) {
1313             this.layer = layer;
1314         }
1315 
1316         private void setClip(Rectangle area) {
1317             clip = area;
1318         }
1319 
1320         private void clip(Rectangle area) {
1321             if (null == clip) {
1322                 clip = area;
1323             } else {
1324                 clip.intersectWith(area);
1325             }
1326         }
1327 
1328         private void setAlpha(float alpha) {
1329             this.alpha = alpha;
1330         }
1331 
1332         private float getAlpha() {
1333             return alpha;
1334         }
1335 
1336         private void setTextMode(boolean fill, boolean stroke, boolean clip) {
1337             textFill = fill;
1338             textStroke = stroke;
1339             textClip = clip;
1340         }
1341 
1342         private boolean isTextFill() {
1343             return textFill;
1344         }
1345 
1346         private boolean isTextStroke() {
1347             return textStroke;
1348         }
1349 
1350         private boolean isTextClip() {
1351             return textClip;
1352         }
1353 
1354         private void markAsRestorePoint() {
1355             restorePoint = true;
1356         }
1357 
1358         private boolean isRestorePoint() {
1359             return restorePoint;
1360         }
1361 
1362         private void setShadow(DropShadow shadow) {
1363             this.shadow = shadow;
1364         }
1365 
1366         private DropShadow getShadowNoClone() {
1367             return shadow;
1368         }
1369 
1370         private Affine3D getTransformNoClone() {
1371             return xform;
1372         }
1373 
1374         private GeneralTransform3D getPerspectiveTransformNoClone() {
1375             return perspectiveTransform;
1376         }
1377 
1378         private void setTransform(final Affine3D at) {
1379             this.xform.setTransform(at);
1380         }
1381 
1382         private void setPerspectiveTransform(final GeneralTransform3D gt) {
1383             this.perspectiveTransform.set(gt);
1384         }
1385 
1386         private void concatTransform(Affine3D at) {
1387             xform.concatenate(at);
1388         }
1389 
1390         private void translate(double dx, double dy) {
1391             xform.translate(dx, dy);
1392         }
1393 
1394         private void scale(double sx, double sy) {
1395             xform.scale(sx,sy);
1396         }
1397 
1398         private void rotate(double radians) {
1399             xform.rotate(radians);
1400         }
1401     }
1402 
1403     private abstract static class Layer {
1404         FilterContext fctx;
1405         PrDrawable buffer;
1406         Graphics graphics;
1407         final Rectangle bounds;
1408         boolean permanent;
1409 
1410         Layer(Graphics g, Rectangle bounds, boolean permanent) {
1411             this.bounds = new Rectangle(bounds);
1412             this.permanent = permanent;
1413 
1414             // avoid creating zero-size drawable, see also RT-21410
1415             int w = Math.max(bounds.width, 1);
1416             int h = Math.max(bounds.height, 1);
1417             fctx = getFilterContext(g);
1418             if (permanent) {
1419                 ResourceFactory f = GraphicsPipeline.getDefaultResourceFactory();
1420                 RTTexture rtt = f.createRTTexture(w, h, Texture.WrapMode.CLAMP_NOT_NEEDED);
1421                 rtt.makePermanent();
1422                 buffer = ((PrRenderer)Renderer.getRenderer(fctx)).createDrawable(rtt);
1423             } else {
1424                 buffer = (PrDrawable) Effect.getCompatibleImage(fctx, w, h);
1425             }
1426         }
1427 
1428         Graphics getGraphics() {
1429             if (graphics == null) {
1430                 graphics = buffer.createGraphics();
1431             }
1432             return graphics;
1433         }
1434 
1435         abstract void init(Graphics g);
1436 
1437         abstract void render(Graphics g);
1438 
1439         private void dispose() {
1440             if (buffer != null) {
1441                 if (permanent) {
1442                     buffer.flush(); // releases the resource
1443                 } else {
1444                     Effect.releaseCompatibleImage(fctx, buffer);
1445                 }
1446                 fctx = null;
1447                 buffer = null;
1448             }
1449         }
1450 
1451         private double getX() { return (double) bounds.x; }
1452         private double getY() { return (double) bounds.y; }
1453     }
1454 
1455     private final class TransparencyLayer extends Layer {
1456         private final float opacity;
1457 
1458         private TransparencyLayer(Graphics g, Rectangle bounds, float opacity) {
1459             super(g, bounds, false);
1460             this.opacity = opacity;
1461         }
1462 
1463         @Override void init(Graphics g) {
1464             state.setCompositeOperation(COMPOSITE_SOURCE_OVER);
1465         }
1466 
1467         @Override void render(Graphics g) {
1468             new Composite() {
1469                 @Override void doPaint(Graphics g) {
1470                     float op = g.getExtraAlpha();
1471                     g.setExtraAlpha(opacity);
1472                     Affine3D tx = new Affine3D(g.getTransformNoClone());
1473                     g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
1474                     g.drawTexture(buffer.getTextureObject(),
1475                             bounds.x, bounds.y, bounds.width, bounds.height);
1476                     g.setTransform(tx);
1477                     g.setExtraAlpha(op);
1478                 }
1479             }.paint(g);
1480         }
1481 
1482         @Override public String toString() {
1483             return String.format(&quot;TransparencyLayer[%d,%d + %dx%d, opacity %.2f]&quot;,
1484                 bounds.x, bounds.y, bounds.width, bounds.height, opacity);
1485         }
1486     }
1487 
1488     private static final class ClipLayer extends Layer {
1489         private final WCPath normalizedToClipPath;
1490         private boolean srcover;
1491 
1492         private ClipLayer(Graphics g, Rectangle bounds, WCPath normalizedToClipPath,
1493                           boolean permanent)
1494         {
1495             super(g, bounds, permanent);
1496             this.normalizedToClipPath = normalizedToClipPath;
1497             srcover = true;
1498         }
1499 
1500         @Override void init(Graphics g) {
1501             RTTexture texture = null;
1502             ReadbackGraphics readbackGraphics = null;
1503             try {
1504                 readbackGraphics = (ReadbackGraphics) g;
1505                 texture = readbackGraphics.readBack(bounds);
1506                 getGraphics().drawTexture(texture, 0, 0, bounds.width, bounds.height);
1507             } finally {
1508                 if (readbackGraphics != null &amp;&amp; texture != null) {
1509                     readbackGraphics.releaseReadBackBuffer(texture);
1510                 }
1511             }
1512             srcover = false;
1513         }
1514 
1515         @Override void render(Graphics g) {
1516             Path2D p2d = ((WCPathImpl)normalizedToClipPath).getPlatformPath();
1517 
1518             // render normalizedToClipPath to a drawable
1519             PrDrawable bufferImg = (PrDrawable) Effect.getCompatibleImage(
1520                     fctx, bounds.width, bounds.height);
1521             Graphics bufferGraphics = bufferImg.createGraphics();
1522 
1523             bufferGraphics.setPaint(Color.BLACK);
1524             bufferGraphics.fill(p2d);
1525 
1526             // blend buffer and clipImg onto |g|
1527             if (g instanceof MaskTextureGraphics &amp;&amp; ! (g instanceof PrinterGraphics)) {
1528                 MaskTextureGraphics mg = (MaskTextureGraphics) g;
1529                 if (srcover) {
1530                     mg.drawPixelsMasked(buffer.getTextureObject(),
1531                                         bufferImg.getTextureObject(),
1532                                         bounds.x, bounds.y, bounds.width, bounds.height,
1533                                         0, 0, 0, 0);
1534                 } else {
1535                     mg.maskInterpolatePixels(buffer.getTextureObject(),
1536                                              bufferImg.getTextureObject(),
1537                                              bounds.x, bounds.y, bounds.width, bounds.height,
1538                                              0, 0, 0, 0);
1539                 }
1540             } else {
1541                 Blend blend = new Blend(Blend.Mode.SRC_IN,
1542                         new PassThrough(bufferImg, bounds.width, bounds.height),
1543                         new PassThrough(buffer, bounds.width, bounds.height));
1544                 Affine3D tx = new Affine3D(g.getTransformNoClone());
1545                 g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
1546                 PrEffectHelper.render(blend, g, bounds.x, bounds.y, null);
1547                 g.setTransform(tx);
1548             }
1549 
1550             Effect.releaseCompatibleImage(fctx, bufferImg);
1551         }
1552 
1553         @Override public String toString() {
1554             return String.format(&quot;ClipLayer[%d,%d + %dx%d, path %s]&quot;,
1555                     bounds.x, bounds.y, bounds.width, bounds.height,
1556                     normalizedToClipPath);
1557         }
1558     }
1559 
1560     private abstract class Composite {
1561         abstract void doPaint(Graphics g);
1562 
1563         void paint() {
1564             paint(getGraphics(true));
1565         }
1566 
1567         void paint(Graphics g) {
1568             if (g != null) {
1569                 CompositeMode oldCompositeMode = g.getCompositeMode();
1570                 switch (state.getCompositeOperation()) {
1571                     // decode operations that don&#39;t require Blend first
1572                     case COMPOSITE_COPY:
1573                         g.setCompositeMode(CompositeMode.SRC);
1574                         doPaint(g);
1575                         g.setCompositeMode(oldCompositeMode);
1576                         break;
1577                     case COMPOSITE_SOURCE_OVER:
1578                         g.setCompositeMode(CompositeMode.SRC_OVER);
1579                         doPaint(g);
1580                         g.setCompositeMode(oldCompositeMode);
1581                         break;
1582                     default:
1583                         // other operations require usage of Blend
1584                         blend(g);
1585                         break;
1586                 }
1587                 isRootLayerValid = false;
1588             }
1589         }
1590 
1591         private void blend(Graphics g) {
1592             FilterContext fctx = getFilterContext(g);
1593             PrDrawable dstImg = null;
1594             PrDrawable srcImg = null;
1595             ReadbackGraphics readBackGraphics = null;
1596             RTTexture texture = null;
1597             Rectangle clip = state.getClipNoClone();
1598             WCImage image = getImage();
1599             try {
1600                 if (image != null &amp;&amp; image instanceof PrismImage) {
1601                     // blending on canvas
1602                     dstImg = (PrDrawable) Effect.getCompatibleImage(fctx, clip.width, clip.height);
1603                     Graphics dstG = dstImg.createGraphics();
1604                     ((PrismImage) image).draw(dstG,
1605                             0, 0, clip.width, clip.height,
1606                             clip.x, clip.y, clip.width, clip.height);
1607                 } else {
1608                     // blending on page
1609                     readBackGraphics = (ReadbackGraphics) g;
1610                     texture = readBackGraphics.readBack(clip);
1611                     dstImg = PrDrawable.create(fctx, texture);
1612                 }
1613 
1614                 srcImg = (PrDrawable) Effect.getCompatibleImage(fctx, clip.width, clip.height);
1615                 Graphics srcG = srcImg.createGraphics();
1616                 state.apply(srcG);
1617                 doPaint(srcG);
1618 
1619                 g.clear();
1620                 PrEffectHelper.render(createEffect(dstImg, srcImg, clip.width, clip.height), g, 0, 0, null);
1621 
1622             } finally {
1623                 if (srcImg != null) {
1624                     Effect.releaseCompatibleImage(fctx, srcImg);
1625                 }
1626                 if (dstImg != null) {
1627                     if (readBackGraphics != null &amp;&amp; texture != null) {
1628                         readBackGraphics.releaseReadBackBuffer(texture);
1629                     } else {
1630                         Effect.releaseCompatibleImage(fctx, dstImg);
1631                     }
1632                 }
1633             }
1634         }
1635 
1636         // provides some syntax sugar for createEffect()
1637         private Effect createBlend(Blend.Mode mode,
1638                                    PrDrawable dstImg,
1639                                    PrDrawable srcImg,
1640                                    int width,
1641                                    int height)
1642         {
1643             return new Blend(
1644                     mode,
1645                     new PassThrough(dstImg, width, height),
1646                     new PassThrough(srcImg, width, height));
1647         }
1648 
1649         private Effect createEffect(PrDrawable dstImg,
1650                                     PrDrawable srcImg,
1651                                     int width,
1652                                     int height)
1653         {
1654             switch (state.getCompositeOperation()) {
1655                 case COMPOSITE_CLEAR: // same as xor
1656                 case COMPOSITE_XOR:
1657                     return new Blend(
1658                             SRC_OVER,
1659                             createBlend(SRC_OUT, dstImg, srcImg, width, height),
1660                             createBlend(SRC_OUT, srcImg, dstImg, width, height)
1661                     );
1662                 case COMPOSITE_SOURCE_IN:
1663                     return createBlend(SRC_IN, dstImg, srcImg, width, height);
1664                 case COMPOSITE_SOURCE_OUT:
1665                     return createBlend(SRC_OUT, dstImg, srcImg, width, height);
1666                 case COMPOSITE_SOURCE_ATOP:
1667                     return createBlend(SRC_ATOP, dstImg, srcImg, width, height);
1668                 case COMPOSITE_DESTINATION_OVER:
1669                     return createBlend(SRC_OVER, srcImg, dstImg, width, height);
1670                 case COMPOSITE_DESTINATION_IN:
1671                     return createBlend(SRC_IN, srcImg, dstImg, width, height);
1672                 case COMPOSITE_DESTINATION_OUT:
1673                     return createBlend(SRC_OUT, srcImg, dstImg, width, height);
1674                 case COMPOSITE_DESTINATION_ATOP:
1675                     return createBlend(SRC_ATOP, srcImg, dstImg, width, height);
1676                 case COMPOSITE_HIGHLIGHT:
1677                     return createBlend(ADD, dstImg, srcImg, width, height);
1678                 default:
1679                     return createBlend(SRC_OVER, dstImg, srcImg, width, height);
1680             }
1681         }
1682     }
1683 
1684     private static final class PassThrough extends Effect {
1685         private final PrDrawable img;
1686         private final int width;
1687         private final int height;
1688 
1689         private PassThrough(PrDrawable img, int width, int height) {
1690             this.img = img;
1691             this.width = width;
1692             this.height = height;
1693         }
1694 
1695         @Override public ImageData filter(
1696                 FilterContext fctx,
1697                 BaseTransform transform,
1698                 Rectangle outputClip,
1699                 Object renderHelper,
1700                 Effect defaultInput) {
1701             // We have an unpaired lock() here, because unlocking is done
1702             // internally by ImageData. See RT-33625 for details.
1703             img.lock();
1704             ImageData imgData = new ImageData(fctx, img, new Rectangle(
1705                                               (int) transform.getMxt(),
1706                                               (int) transform.getMyt(),
1707                                               width, height));
1708             imgData.setReusable(true);
1709             return imgData;
1710         }
1711 
1712         @Override public RectBounds getBounds(
1713                 BaseTransform transform,
1714                 Effect defaultInput) {
1715             return null;
1716         }
1717 
1718         @Override public AccelType getAccelType(FilterContext fctx) {
1719             return AccelType.INTRINSIC;
1720         }
1721 
1722         @Override
1723         public boolean reducesOpaquePixels() {
1724             return false;
1725         }
1726 
1727         @Override
1728         public DirtyRegionContainer getDirtyRegions(Effect defaultInput, DirtyRegionPool regionPool) {
1729             return null;
1730         }
1731     }
1732 
1733     private static FilterContext getFilterContext(Graphics g) {
1734         Screen screen = g.getAssociatedScreen();
1735         if (screen == null) {
1736             ResourceFactory factory = g.getResourceFactory();
1737             return PrFilterContext.getPrinterContext(factory);
1738         } else {
1739             return PrFilterContext.getInstance(screen);
1740         }
1741     }
1742 
1743     @Override
1744     public void strokeArc(final int x, final int y, final int w, final int h,
1745                           final int startAngle, final int angleSpan)
1746     {
1747         if (log.isLoggable(Level.FINE)) {
1748             log.fine(String.format(&quot;strokeArc(%d, %d, %d, %d, %d, %d)&quot;,
1749                                    x, y, w, h, startAngle, angleSpan));
1750         }
1751         Arc2D arc = new Arc2D(x, y, w, h, startAngle, angleSpan, Arc2D.OPEN);
1752         if (state.getStrokeNoClone().isApplicable() &amp;&amp;
1753             !shouldRenderShape(arc, null, state.getStrokeNoClone().getPlatformStroke()))
1754         {
1755             return;
1756         }
1757         new Composite() {
1758             @Override void doPaint(Graphics g) {
1759                 if (state.getStrokeNoClone().apply(g)) {
1760                     g.draw(arc);
1761                 }
1762             }
1763         }.paint();
1764     }
1765 
1766     @Override
1767     public WCImage getImage() {
1768         return null;
1769     }
1770 
1771     @Override
1772     public void strokeRect(final float x, final float y, final float w, final float h,
1773                            final float lineWidth) {
1774         if (log.isLoggable(Level.FINE)) {
1775             log.fine(String.format(&quot;strokeRect_FFFFF(%f, %f, %f, %f, %f)&quot;,
1776                                    x, y, w, h, lineWidth));
1777         }
1778         BasicStroke stroke = new BasicStroke(
1779             lineWidth,
1780             BasicStroke.CAP_BUTT,
1781             BasicStroke.JOIN_MITER,
1782             Math.max(1.0f, lineWidth),
1783             state.getStrokeNoClone().getDashSizes(),
1784             state.getStrokeNoClone().getDashOffset());
1785 
1786         if (!shouldRenderRect(x, y, w, h, null, stroke)) {
1787             return;
1788         }
1789         new Composite() {
1790             @Override void doPaint(Graphics g) {
1791                 g.setStroke(stroke);
1792                 Paint paint = state.getStrokeNoClone().getPaint();
1793                 if (paint == null) {
1794                     paint = state.getPaintNoClone();
1795                 }
1796                 g.setPaint(paint);
1797                 g.drawRect(x, y, w, h);
1798             }
1799         }.paint();
1800     }
1801 
1802     @Override
1803     public void strokePath(final WCPath path) {
1804         log.fine(&quot;strokePath&quot;);
1805         if (path != null) {
1806             final BasicStroke stroke = state.getStrokeNoClone().getPlatformStroke();
1807             final DropShadow shadow = state.getShadowNoClone();
1808             final Path2D p2d = (Path2D)path.getPlatformPath();
1809 
1810             if ((stroke == null &amp;&amp; shadow == null) ||
1811                 !shouldRenderShape(p2d, shadow, stroke))
1812             {
1813                 return;
1814             }
1815             new Composite() {
1816                 @Override void doPaint(Graphics g) {
1817                     if (shadow != null) {
1818                         final NGPath node = new NGPath();
1819                         node.updateWithPath2d(p2d);
1820                         render(g, shadow, null, stroke, node);
1821                     } else if (stroke != null) {
1822                         Paint paint = state.getStrokeNoClone().getPaint();
1823                         if (paint == null) {
1824                             paint = state.getPaintNoClone();
1825                         }
1826                         g.setPaint(paint);
1827                         g.setStroke(stroke);
1828                         g.draw(p2d);
1829                     }
1830                 }
1831             }.paint();
1832         }
1833     }
1834 
1835     @Override
1836     public void fillPath(final WCPath path) {
1837         log.fine(&quot;fillPath&quot;);
1838         if (path != null) {
1839             if (!shouldRenderShape(((WCPathImpl)path).getPlatformPath(),
1840                                    state.getShadowNoClone(), null))
1841             {
1842                 return;
1843             }
1844             new Composite() {
1845                 @Override void doPaint(Graphics g) {
1846                     Path2D p2d = (Path2D) path.getPlatformPath();
1847                     Paint paint = state.getPaintNoClone();
1848                     DropShadow shadow = state.getShadowNoClone();
1849                     if (shadow != null) {
1850                         final NGPath node = new NGPath();
1851                         node.updateWithPath2d(p2d);
1852                         render(g, shadow, paint, null, node);
1853                     } else {
1854                         g.setPaint(paint);
1855                         g.fill(p2d);
1856                     }
1857                 }
1858             }.paint();
1859         }
1860     }
1861 
1862     public void setPerspectiveTransform(WCTransform tm) {
1863         final GeneralTransform3D at = new GeneralTransform3D().set(tm.getMatrix());
1864         state.setPerspectiveTransform(at);
1865         resetCachedGraphics();
1866     }
1867 
1868     public void setTransform(WCTransform tm) {
1869         final double m[] = tm.getMatrix();
1870         final Affine3D at = new Affine3D(new Affine2D(m[0], m[1], m[2], m[3], m[4], m[5]));
1871         if (state.getLayerNoClone() == null) {
1872             at.preConcatenate(baseTransform);
1873         }
1874         state.setTransform(at);
1875         resetCachedGraphics();
1876     }
1877 
1878     public WCTransform getTransform() {
1879         Affine3D xf = state.getTransformNoClone();
1880         return new WCTransform(xf.getMxx(), xf.getMyx(),
1881                                xf.getMxy(), xf.getMyy(),
1882                                xf.getMxt(), xf.getMyt());
1883     }
1884 
1885     public void concatTransform(WCTransform tm) {
1886         double m[] = tm.getMatrix();
1887         Affine3D at = new Affine3D(new Affine2D(m[0], m[1], m[2], m[3], m[4], m[5]));
1888         state.concatTransform(at);
1889         resetCachedGraphics();
1890     }
1891 
1892     @Override
1893     public void flush() {
1894         flushAllLayers();
1895     }
1896 
1897     @Override
1898     public WCGradient createLinearGradient(WCPoint p1, WCPoint p2) {
1899         return new WCLinearGradient(p1, p2);
1900     }
1901 
1902     @Override
1903     public WCGradient createRadialGradient(WCPoint p1, float r1, WCPoint p2, float r2) {
1904         return new WCRadialGradient(p1, r1, p2, r2);
1905     }
1906 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
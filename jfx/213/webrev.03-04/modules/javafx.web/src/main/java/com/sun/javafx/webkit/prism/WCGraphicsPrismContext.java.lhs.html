<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/java/com/sun/javafx/webkit/prism/WCGraphicsPrismContext.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.javafx.webkit.prism;
  27 
  28 import com.sun.glass.ui.Screen;
  29 import com.sun.javafx.font.FontStrike;
  30 import com.sun.javafx.font.Metrics;
  31 import com.sun.javafx.font.PGFont;
  32 import com.sun.javafx.geom.*;
  33 import com.sun.javafx.geom.transform.Affine2D;
  34 import com.sun.javafx.geom.transform.Affine3D;
  35 import com.sun.javafx.geom.transform.BaseTransform;
  36 import com.sun.javafx.geom.transform.GeneralTransform3D;
  37 import com.sun.javafx.logging.PlatformLogger;
  38 import com.sun.javafx.logging.PlatformLogger.Level;
  39 import com.sun.javafx.scene.text.GlyphList;
  40 import com.sun.javafx.scene.text.TextLayout;
  41 import com.sun.javafx.sg.prism.*;
  42 import com.sun.javafx.text.TextRun;
  43 import com.sun.prism.*;
  44 import com.sun.prism.paint.Color;
  45 import com.sun.prism.paint.Gradient;
  46 import com.sun.prism.paint.ImagePattern;
  47 import com.sun.prism.paint.Paint;
  48 import com.sun.scenario.effect.*;
  49 import com.sun.scenario.effect.impl.prism.PrDrawable;
  50 import com.sun.scenario.effect.impl.prism.PrEffectHelper;
  51 import com.sun.scenario.effect.impl.prism.PrFilterContext;
  52 import com.sun.webkit.graphics.*;
  53 
  54 import java.nio.ByteBuffer;
  55 import java.nio.ByteOrder;
  56 import java.security.AccessController;
  57 import java.security.PrivilegedAction;
  58 import java.util.ArrayList;
  59 import java.util.List;
  60 
  61 import static com.sun.scenario.effect.Blend.Mode.*;
  62 import com.sun.scenario.effect.impl.Renderer;
  63 import com.sun.scenario.effect.impl.prism.PrRenderer;
  64 
  65 class WCGraphicsPrismContext extends WCGraphicsContext {
  66 
  67     public enum Type {
  68         /**
  69          * Base context associated with the topmost page buffer.
  70          * Created and disposed during a single render pass.
  71          */
  72         PRIMARY,
  73 
  74         /**
  75          * A context associated with a dedicated buffer representing
  76          * a separate render target like canvas, buffered image etc.
  77          * Its life cycle is not limited to a single render pass.
  78          */
  79         DEDICATED
  80     }
  81 
  82     private final static PlatformLogger log =
  83             PlatformLogger.getLogger(WCGraphicsPrismContext.class.getName());
  84     private final static boolean DEBUG_DRAW_CLIP_SHAPE = Boolean.valueOf(
  85             AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) () -&gt;
  86             System.getProperty(&quot;com.sun.webkit.debugDrawClipShape&quot;, &quot;false&quot;)));
  87 
  88     Graphics baseGraphics;
  89     private BaseTransform baseTransform;
  90 
  91     private final List&lt;ContextState&gt; states = new ArrayList&lt;ContextState&gt;();
  92 
  93     private ContextState state = new ContextState();
  94 
  95     // Cache for getPlatformGraphics
  96     private Graphics cachedGraphics = null;
  97 
  98     private int fontSmoothingType;
  99     private boolean isRootLayerValid = false;
 100 
 101     WCGraphicsPrismContext(Graphics g) {
 102         state.setClip(g.getClipRect());
 103         state.setAlpha(g.getExtraAlpha());
 104         baseGraphics = g;
 105         initBaseTransform(g.getTransformNoClone());
 106     }
 107 
 108     WCGraphicsPrismContext() {
 109     }
 110 
 111     public Type type() {
 112         return Type.PRIMARY;
 113     }
 114 
 115     final void initBaseTransform(BaseTransform t) {
 116         baseTransform = new Affine3D(t);
 117         state.setTransform((Affine3D)baseTransform);
 118     }
 119 
 120     private void resetCachedGraphics() {
 121         cachedGraphics = null;
 122     }
 123 
 124     @Override
 125     public Object getPlatformGraphics() {
 126         return getGraphics(false);
 127     }
 128 
 129     Graphics getGraphics(boolean checkClip) {
 130         if (cachedGraphics == null) {
 131             Layer l = state.getLayerNoClone();
 132             cachedGraphics = (l != null)
 133                     ? l.getGraphics()
 134                     : baseGraphics;
 135 
 136             state.apply(cachedGraphics);
 137 
 138             if (log.isLoggable(Level.FINE)) {
 139                 log.fine(&quot;getPlatformGraphics for &quot; + this + &quot; : &quot; +
 140                          cachedGraphics);
 141             }
 142         }
 143 
 144         Rectangle clip = cachedGraphics.getClipRectNoClone();
 145         return (checkClip &amp;&amp; clip!=null &amp;&amp; clip.isEmpty())
 146             ? null
 147             : cachedGraphics;
 148     }
 149 
 150     public void saveState()
 151     {
 152         state.markAsRestorePoint();
 153         saveStateInternal();
 154     }
 155 
 156     private void saveStateInternal()
 157     {
 158         states.add(state);
 159         state = state.clone();
 160     }
 161 
 162     private void startNewLayer(Layer layer) {
 163         saveStateInternal();
 164 
 165         // layer has the same bounds as clip, so we have to translate
 166         Rectangle clip = state.getClipNoClone();
 167 
 168         //left-side (post-) translate.
 169         //NB! an order of transforms is essential!
 170         Affine3D newTr = new Affine3D(BaseTransform.getTranslateInstance(
 171                 -clip.x,
 172                 -clip.y));
 173         newTr.concatenate(state.getTransformNoClone());
 174 
 175         //move clip to (0, 0) - start of texture
 176         clip.x = 0;
 177         clip.y = 0;
 178         //no-clone - no-set!
 179 
 180         Graphics g = getGraphics(true);
 181         if (g != null &amp;&amp; g != baseGraphics) {
 182             layer.init(g);
 183         }
 184 
 185         state.setTransform(newTr);
 186         state.setLayer(layer);
 187 
 188         resetCachedGraphics();
 189     }
 190 
 191     private void renderLayer(final Layer layer) {
 192         WCTransform cur = getTransform();
 193 
 194         //translate to (layer.getX(), layer.getY())
 195         setTransform(new WCTransform(
 196             1.0, 0.0,
 197             0.0, 1.0,
 198             layer.getX(), layer.getY()));
 199 
 200         // composite drawing delegated to the layer rendering
 201         Graphics g = getGraphics(true);
 202         if (g != null) {
 203             layer.render(g);
 204         }
 205 
 206         //restore transform
 207         setTransform(cur);
 208     }
 209 
 210     private void restoreStateInternal() {
 211         int size = states.size();
 212         if (size == 0) {
 213             assert false: &quot;Unbalanced restoreState&quot;;
 214             return;
 215         }
 216 
 217         Layer layer = state.getLayerNoClone();
 218         state = states.remove(size - 1);
 219         if (layer != state.getLayerNoClone()) {
 220             renderLayer(layer);
 221             layer.dispose();
 222             if (log.isLoggable(Level.FINE)) {
 223                 log.fine(&quot;Popped layer &quot; + layer);
 224             }
 225         } else {
 226             resetCachedGraphics();
 227         }
 228     }
 229 
 230     public void restoreState()
 231     {
 232         log.fine(&quot;restoring state&quot;);
 233         do {
 234             restoreStateInternal();
 235         } while ( !state.isRestorePoint() );
 236     }
 237 
 238     /**
 239      *  Renders all layers to the underlaying Graphics, but preserves the
 240      *  current state and the states stack
 241      */
 242     private void flushAllLayers() {
 243         if (state == null) {
 244             // context disposed
 245             return;
 246         }
 247 
 248         if (isRootLayerValid) {
 249             log.fine(&quot;FlushAllLayers: root layer is valid, skipping&quot;);
 250             return;
 251         }
 252 
 253         if (log.isLoggable(Level.FINE)) {
 254             log.fine(&quot;FlushAllLayers&quot;);
 255         }
 256 
 257         ContextState currentState = state;
 258 
 259         for (int i = states.size() - 1; i &gt;=0; i--) {
 260             Layer layer = state.getLayerNoClone();
 261             state = states.get(i);
 262             if (layer != state.getLayerNoClone()) {
 263                 renderLayer(layer);
 264             } else {
 265                 resetCachedGraphics();
 266             }
 267         }
 268 
 269         Layer layer = state.getLayerNoClone();
 270         if (layer != null) {
 271             renderLayer(layer);
 272         }
 273 
 274         state = currentState;
 275         isRootLayerValid = true;
 276     }
 277 
 278 
 279     public void dispose() {
 280         if (!states.isEmpty()) {
 281             log.fine(&quot;Unbalanced saveState/restoreState&quot;);
 282         }
 283         for (ContextState state: states) {
 284             if (state.getLayerNoClone() != null) {
 285                 state.getLayerNoClone().dispose();
 286             }
 287         }
 288         states.clear();
 289 
 290         if (state != null &amp;&amp; state.getLayerNoClone() != null) {
 291             state.getLayerNoClone().dispose();
 292         }
 293         state = null;
 294     }
 295 
 296 
 297     public void setClip(WCPath path, boolean isOut) {
 298         Affine3D tr = new Affine3D(state.getTransformNoClone());
 299         path.transform(
 300                 tr.getMxx(), tr.getMyx(),
 301                 tr.getMxy(), tr.getMyy(),
 302                 tr.getMxt(), tr.getMyt());
 303         //path now is in node coordinates, as well as clip
 304 
 305         if (!isOut) {
 306             WCRectangle pathBounds = path.getBounds();
 307 
 308             // path bounds could be fractional so &#39;inclusive&#39; rounding
 309             // is used for determining clip rectangle
 310             int pixelX = (int) Math.floor(pathBounds.getX());
 311             int pixelY = (int) Math.floor(pathBounds.getY());
 312             int pixelW = (int) Math.ceil(pathBounds.getMaxX()) - pixelX;
 313             int pixelH = (int) Math.ceil(pathBounds.getMaxY()) - pixelY;
 314 
 315             state.clip(new Rectangle(pixelX, pixelY, pixelW, pixelH));
 316         }
 317 
 318         Rectangle clip = state.getClipNoClone();
 319 
 320         if (isOut) {
 321             path.addRect(clip.x, clip.y, clip.width, clip.height);
 322             //Out clip path is always EVENODD.
 323         }
 324 
 325         path.translate(-clip.x, -clip.y);
 326 
 327         Layer layer = new ClipLayer(
 328             getGraphics(false), clip, path, type() == Type.DEDICATED);
 329 
 330         startNewLayer(layer);
 331 
 332         if (log.isLoggable(Level.FINE)) {
 333             log.fine(&quot;setClip(WCPath &quot; + path.getID() + &quot;)&quot;);
 334             log.fine(&quot;Pushed layer &quot; + layer);
 335         }
 336     }
 337 
 338     private Rectangle transformClip(Rectangle localClip) {
 339         if (localClip==null) {
 340             return null;
 341         }
 342 
 343         float[] points = new float[] {
 344             localClip.x, localClip.y,
 345             localClip.x + localClip.width, localClip.y,
 346             localClip.x, localClip.y + localClip.height,
 347             localClip.x  + localClip.width, localClip.y + localClip.height};
 348         state.getTransformNoClone().transform(points, 0, points, 0, 4);
 349         float minX = Math.min(
 350                points[0], Math.min(
 351                points[2], Math.min(
 352                points[4], points[6])));
 353         float maxX = Math.max(
 354                points[0], Math.max(
 355                points[2], Math.max(
 356                points[4], points[6])));
 357         float minY = Math.min(
 358                points[1], Math.min(
 359                points[3], Math.min(
 360                points[5], points[7])));
 361         float maxY = Math.max(
 362                points[1], Math.max(
 363                points[3], Math.max(
 364                points[5], points[7])));
 365         return new Rectangle(new RectBounds(minX, minY, maxX, maxY));
 366 
 367 /* #1 loose rotate
 368         state.getTransformNoClone().transform(localClip, localClip);
 369 */
 370 /* #2 problem with negative coordinates
 371         RectBounds rb = TransformedShape.transformedShape(
 372             new RoundRectangle2D(localClip.x, localClip.y, localClip.width, localClip.height, 0, 0),
 373             state.getTransformNoClone()).getBounds();
 374         return rb.isEmpty()
 375             ? null
 376             : new Rectangle(rb);
 377  */
 378     }
 379 
 380     private void setClip(Rectangle shape) {
 381         Affine3D tr = state.getTransformNoClone();
 382         if (tr.getMxy() == 0 &amp;&amp; tr.getMxz() == 0
 383          &amp;&amp; tr.getMyx() == 0 &amp;&amp; tr.getMyz() == 0
 384          &amp;&amp; tr.getMzx() == 0 &amp;&amp; tr.getMzy() == 0) {
 385             //There is no rotation here: scale + translation.
 386             //Fast &amp; easy!
 387             state.clip(transformClip(shape));
 388             if (log.isLoggable(Level.FINE)) {
 389                 log.fine(&quot;setClip({0})&quot;, shape);
 390             }
 391             if (DEBUG_DRAW_CLIP_SHAPE) {
 392                 //Draw clip shape
 393                 Rectangle rc = state.getClipNoClone();
 394                 if (rc != null &amp;&amp; rc.width &gt;= 2 &amp;&amp; rc.height &gt;= 2) {
 395                     WCTransform cur = getTransform();
 396                     //translate to (layer.getX(), layer.getY())
 397                     setTransform(new WCTransform(
 398                         1.0, 0.0,
 399                         0.0, 1.0,
 400                         0.0, 0.0));
 401 
 402                     Graphics g2d = getGraphics(true);
 403                     if (g2d != null) {
 404                         float fbase = (float)Math.random();
 405                         g2d.setPaint(new Color(
 406                                 fbase,
 407                                 1f - fbase,
 408                                 0.5f,
 409                                 0.1f));
 410                         g2d.setStroke(new BasicStroke());
 411                         g2d.fillRect(rc.x, rc.y, rc.width, rc.height);
 412 
 413                         g2d.setPaint(new Color(
 414                                 1f - fbase,
 415                                 fbase,
 416                                 0.5f,
 417                                 1f));
 418                         g2d.drawRect(rc.x, rc.y, rc.width, rc.height);
 419                     }
 420                     //restore transform
 421                     setTransform(cur);
 422                     state.clip(new Rectangle(rc.x+1, rc.y+1, rc.width-2, rc.height-2));
 423                 }
 424             }
 425             if (cachedGraphics != null) {
 426                 cachedGraphics.setClipRect(state.getClipNoClone());
 427             }
 428         } else {
 429             //twisted axis set
 430             WCPath path = new WCPathImpl();
 431             path.addRect(shape.x, shape.y, shape.width, shape.height);
 432             setClip(path, false);
 433         }
 434     }
 435 
 436     public void setClip(int cx, int cy, int cw, int ch) {
 437         setClip(new Rectangle(cx, cy, cw, ch));
 438     }
 439 
 440     public void setClip(WCRectangle c) {
 441         setClip(new Rectangle((int)c.getX(), (int)c.getY(),
 442                               (int)c.getWidth(), (int)c.getHeight()));
 443     }
 444 
 445     public void setClip(int cx, int cy, int cw, int ch, WCImage maskImage) {
 446         setClip(new Rectangle(cx, cy, cw, ch));
 447         state.setClipMaskImage(maskImage);
 448     }
 449 
 450     public WCRectangle getClip() {
 451         Rectangle r = state.getClipNoClone();
 452         return r == null ? null : new WCRectangle(r.x, r.y, r.width, r.height);
 453     }
 454 
 455     protected Rectangle getClipRectNoClone() {
 456         return state.getClipNoClone();
 457     }
 458 
 459     protected Affine3D getTransformNoClone() {
 460         return state.getTransformNoClone();
 461     }
 462 
 463     public void translate(float x, float y) {
 464         if (log.isLoggable(Level.FINE)) {
 465             log.fine(&quot;translate({0},{1})&quot;, new Object[] {x, y});
 466         }
 467         state.translate(x, y);
 468         if (cachedGraphics != null) {
 469             cachedGraphics.translate(x, y);
 470         }
 471     }
 472 
 473     public void scale(float sx, float sy) {
 474         if (log.isLoggable(Level.FINE)) {
 475             log.fine(&quot;scale(&quot; + sx + &quot; &quot; + sy + &quot;)&quot;);
 476         }
 477         state.scale(sx, sy);
 478         if (cachedGraphics != null) {
 479             cachedGraphics.scale(sx, sy);
 480         }
 481     }
 482 
 483     public void rotate(float radians) {
 484         if (log.isLoggable(Level.FINE)) {
 485             log.fine(&quot;rotate(&quot; + radians + &quot;)&quot;);
 486         }
 487         state.rotate(radians);
 488         if (cachedGraphics != null) {
 489             cachedGraphics.setTransform(state.getTransformNoClone());
 490         }
 491     }
 492 
 493     // overriden in WCBufferedContext
 494     protected boolean shouldRenderRect(float x, float y, float w, float h,
 495                                        DropShadow shadow, BasicStroke stroke)
 496     {
 497         return true;
 498     }
 499 
 500     // overriden in WCBufferedContext
 501     protected boolean shouldRenderShape(Shape shape, DropShadow shadow, BasicStroke stroke) {
 502         return true;
 503     }
 504 
 505     // overriden in WCBufferedContext
 506     protected boolean shouldCalculateIntersection() {
 507         return false;
 508     }
 509 
 510     @Override
 511     public void fillRect(final float x, final float y, final float w, final float h, final Integer rgba) {
 512         if (log.isLoggable(Level.FINE)) {
 513             String format = (rgba != null)
 514                     ? &quot;fillRect(%f, %f, %f, %f, 0x%x)&quot;
 515                     : &quot;fillRect(%f, %f, %f, %f, null)&quot;;
 516             log.fine(String.format(format, x, y, w, h, rgba));
 517         }
 518         if (!shouldRenderRect(x, y, w, h, state.getShadowNoClone(), null)) {
 519             return;
 520         }
 521         new Composite() {
 522             @Override void doPaint(Graphics g) {
 523                 Paint paint = (rgba != null) ? createColor(rgba) : state.getPaintNoClone();
 524                 DropShadow shadow = state.getShadowNoClone();
 525                 // TextureMapperJava::drawSolidColor calls fillRect with perspective
 526                 // projection.
 527                 if (shadow != null || !state.getPerspectiveTransformNoClone().isIdentity()) {
 528                     final NGRectangle node = new NGRectangle();
 529                     node.updateRectangle(x, y, w, h, 0, 0);
 530                     render(g, shadow, paint, null, node);
 531                 } else if(state.getClipMaskImageNoClone() != null) {
 532                     Rectangle rect = new Rectangle((int) x, (int) y, (int) w, (int) h);
 533                     Rectangle transformedRect = new Rectangle();
 534                     state.getTransformNoClone().transform(rect, transformedRect);
 535                     RTTexture paintRtTexture = g.getResourceFactory().createRTTexture(
<a name="1" id="anc1"></a><span class="line-modified"> 536                             (int) Math.ceil(transformedRect.width),</span>
<span class="line-removed"> 537                             (int) Math.ceil(transformedRect.height),</span>
<span class="line-removed"> 538                             Texture.WrapMode.CLAMP_NOT_NEEDED);</span>
 539                     Graphics g1 = paintRtTexture.createGraphics();
 540                     g1.setPaint(paint);
 541                     g1.setTransform(PrismGraphicsManager.getPixelScaleTransform());
 542                     g1.fillRect(0, 0, paintRtTexture.getContentWidth(), paintRtTexture.getContentHeight());
 543 
 544                     RTImage maskImage = (RTImage) (state.getClipMaskImageNoClone());
 545                     Image nativeMaskImage = Image.fromByteBgraPreData(maskImage.getPixelBuffer(), maskImage.getWidth(),
 546                             maskImage.getHeight(), 0, maskImage.getPixelScale());
 547                     Texture maskTexture = g.getResourceFactory().createTexture(nativeMaskImage, Texture.Usage.STATIC,
 548                             Texture.WrapMode.CLAMP_NOT_NEEDED);
 549                     RTTexture maskRtTexture = g.getResourceFactory().createRTTexture(nativeMaskImage.getWidth(),
 550                             nativeMaskImage.getHeight(), Texture.WrapMode.CLAMP_NOT_NEEDED);
 551                     Graphics g2 = maskRtTexture.createGraphics();
 552                     g2.setTransform(PrismGraphicsManager.getPixelScaleTransform());
 553                     g2.drawTexture(maskTexture, 0, 0, nativeMaskImage.getWidth(), nativeMaskImage.getHeight());
 554                     maskTexture.dispose();
 555                     if(g instanceof MaskTextureGraphics &amp;&amp; !(g instanceof PrinterGraphics)) {
 556                         MaskTextureGraphics mg = (MaskTextureGraphics) (g);
 557                         mg.drawPixelsMasked(paintRtTexture, maskRtTexture, transformedRect.x, transformedRect.y,
 558                                 transformedRect.width, transformedRect.height, 0, 0, 0, 0);
 559                     } else {
 560                         FilterContext filterContext = getFilterContext(g);
 561                         PrDrawable imagePrDrawable = PrDrawable.create(filterContext, paintRtTexture);
 562                         PrDrawable maskPrDrawable = PrDrawable.create(filterContext, maskRtTexture);
 563                         Blend blend = new Blend(Blend.Mode.SRC_IN,
 564                                 new PassThrough(maskPrDrawable, transformedRect.width, transformedRect.height),
 565                                 new PassThrough(imagePrDrawable, transformedRect.width, transformedRect.height));
 566                         Affine3D tx = new Affine3D(g.getTransformNoClone());
 567                         g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
 568                         PrEffectHelper.render(blend, g, transformedRect.x, transformedRect.y, null);
 569                         g.setTransform(tx);
 570                     }
 571                     paintRtTexture.dispose();
 572                     maskRtTexture.dispose();
 573                 } else {
 574                     g.setPaint(paint);
 575                     g.fillRect(x, y, w, h);
 576                 }
 577             }
 578         }.paint();
 579     }
 580 
 581     @Override
 582     public void fillRoundedRect(final float x, final float y, final float w, final float h,
 583         final float topLeftW, final float topLeftH, final float topRightW, final float topRightH,
 584         final float bottomLeftW, final float bottomLeftH, final float bottomRightW, final float bottomRightH,
 585         final int rgba)
 586     {
 587         if (log.isLoggable(Level.FINE)) {
 588             log.fine(String.format(&quot;fillRoundedRect(%f, %f, %f, %f, &quot;
 589                     + &quot;%f, %f, %f, %f, %f, %f, %f, %f, 0x%x)&quot;,
 590                     x, y, w, h, topLeftW, topLeftH, topRightW, topRightH,
 591                     bottomLeftW, bottomLeftH, bottomRightW, bottomRightH, rgba));
 592         }
 593         if (!shouldRenderRect(x, y, w, h, state.getShadowNoClone(), null)) {
 594             return;
 595         }
 596         new Composite() {
 597             @Override void doPaint(Graphics g) {
 598                 // Prism only supports single arcWidth/Height.
 599                 // We work around by calculating average width and height here
 600 
 601                 float arcW = (topLeftW + topRightW + bottomLeftW + bottomRightW) / 2;
 602                 float arcH = (topLeftH + topRightH + bottomLeftH + bottomRightH) / 2;
 603 
 604                 Paint paint = createColor(rgba);
 605                 DropShadow shadow = state.getShadowNoClone();
 606                 if (shadow != null) {
 607                     final NGRectangle node = new NGRectangle();
 608                     node.updateRectangle(x, y, w, h, arcW, arcH);
 609                     render(g, shadow, paint, null, node);
 610                 } else {
 611                     g.setPaint(paint);
 612                     g.fillRoundRect(x, y, w, h, arcW, arcH);
 613                 }
 614             }
 615         }.paint();
 616     }
 617 
 618     @Override
 619     public void clearRect(final float x, final float y, final float w, final float h) {
 620         if (log.isLoggable(Level.FINE)) {
 621             log.fine(String.format(&quot;clearRect(%f, %f, %f, %f)&quot;, x, y, w, h));
 622         }
 623         if (shouldCalculateIntersection()) {
 624             // No intersection is applicable for clearRect.
 625             return;
 626         }
 627         new Composite() {
 628             @Override void doPaint(Graphics g) {
 629                 g.clearQuad(x, y, x + w, y + h);
 630             }
 631         }.paint();
 632     }
 633 
 634     @Override
 635     public void setFillColor(int rgba) {
 636         if (log.isLoggable(Level.FINE)) {
 637             log.fine(String.format(&quot;setFillColor(0x%x)&quot;, rgba));
 638         }
 639         state.setPaint(createColor(rgba));
 640     }
 641 
 642     @Override
 643     public void setFillGradient(WCGradient gradient) {
 644         if (log.isLoggable(Level.FINE)) {
 645             log.fine(&quot;setFillGradient(&quot; + gradient + &quot;)&quot;);
 646         }
 647         state.setPaint((Gradient) gradient.getPlatformGradient());
 648     }
 649 
 650     @Override
 651     public void setTextMode(boolean fill, boolean stroke, boolean clip) {
 652         if (log.isLoggable(Level.FINE)) {
 653             log.fine(&quot;setTextMode(fill:&quot; + fill + &quot;,stroke:&quot; + stroke + &quot;,clip:&quot; + clip + &quot;)&quot;);
 654         }
 655         state.setTextMode(fill, stroke, clip);
 656     }
 657 
 658     @Override
 659     public void setFontSmoothingType(int fontSmoothingType) {
 660         this.fontSmoothingType = fontSmoothingType;
 661     }
 662 
 663     @Override
 664     public int getFontSmoothingType() {
 665         return fontSmoothingType;
 666     }
 667 
 668     @Override
 669     public void setStrokeStyle(int style) {
 670         if (log.isLoggable(Level.FINE)) {
 671             log.fine(&quot;setStrokeStyle({0})&quot;, style);
 672         }
 673         state.getStrokeNoClone().setStyle(style);
 674     }
 675 
 676     @Override
 677     public void setStrokeColor(int rgba) {
 678         if (log.isLoggable(Level.FINE)) {
 679             log.fine(String.format(&quot;setStrokeColor(0x%x)&quot;, rgba));
 680         }
 681         state.getStrokeNoClone().setPaint(createColor(rgba));
 682     }
 683 
 684     @Override
 685     public void setStrokeWidth(float width) {
 686         if (log.isLoggable(Level.FINE)) {
 687             log.fine(&quot;setStrokeWidth({0})&quot;, new Object[] { width });
 688         }
 689         state.getStrokeNoClone().setThickness(width);
 690     }
 691 
 692     @Override
 693     public void setStrokeGradient(WCGradient gradient) {
 694         if (log.isLoggable(Level.FINE)) {
 695             log.fine(&quot;setStrokeGradient(&quot; + gradient + &quot;)&quot;);
 696         }
 697         state.getStrokeNoClone().setPaint((Gradient) gradient.getPlatformGradient());
 698     }
 699 
 700     @Override
 701     public void setLineDash(float offset, float... sizes) {
 702         if (log.isLoggable(Level.FINE)) {
 703             StringBuilder s = new StringBuilder(&quot;[&quot;);
 704             for (int i=0; i &lt; sizes.length; i++) {
 705                 s.append(sizes[i]).append(&#39;,&#39;);
 706             }
 707             s.append(&#39;]&#39;);
 708             log.fine(&quot;setLineDash({0},{1}&quot;, new Object[] {offset, s});
 709         }
 710         state.getStrokeNoClone().setDashOffset(offset);
 711         if (sizes != null) {
 712             boolean allZero = true;
 713             for (int i = 0; i &lt; sizes.length; i++) {
 714                 if (sizes[i] != 0) {
 715                     allZero = false;
 716                     break;
 717                 }
 718             }
 719             if (allZero) {
 720                 sizes = null;
 721             }
 722         }
 723         state.getStrokeNoClone().setDashSizes(sizes);
 724     }
 725 
 726     @Override
 727     public void setLineCap(int lineCap) {
 728         if (log.isLoggable(Level.FINE)) {
 729             log.fine(&quot;setLineCap(&quot; + lineCap + &quot;)&quot;);
 730         }
 731         state.getStrokeNoClone().setLineCap(lineCap);
 732     }
 733 
 734     @Override
 735     public void setLineJoin(int lineJoin) {
 736         if (log.isLoggable(Level.FINE)) {
 737             log.fine(&quot;setLineJoin(&quot; + lineJoin + &quot;)&quot;);
 738         }
 739         state.getStrokeNoClone().setLineJoin(lineJoin);
 740     }
 741 
 742     @Override
 743     public void setMiterLimit(float miterLimit) {
 744         if (log.isLoggable(Level.FINE)) {
 745             log.fine(&quot;setMiterLimit(&quot; + miterLimit + &quot;)&quot;);
 746         }
 747         state.getStrokeNoClone().setMiterLimit(miterLimit);
 748     }
 749 
 750     @Override
 751     public void setShadow(float dx, float dy, float blur, int rgba) {
 752         if (log.isLoggable(Level.FINE)) {
 753             String format = &quot;setShadow(%f, %f, %f, 0x%x)&quot;;
 754             log.fine(String.format(format, dx, dy, blur, rgba));
 755         }
 756         state.setShadow(createShadow(dx, dy, blur, rgba));
 757     }
 758 
 759     @Override
 760     public void drawPolygon(final WCPath path, final boolean shouldAntialias) {
 761         if (log.isLoggable(Level.FINE)) {
 762             log.fine(&quot;drawPolygon({0})&quot;,
 763                     new Object[] {shouldAntialias});
 764         }
 765         if (!shouldRenderShape(((WCPathImpl)path).getPlatformPath(), null,
 766                                 state.getStrokeNoClone().getPlatformStroke()))
 767         {
 768             return;
 769         }
 770         new Composite() {
 771             @Override void doPaint(Graphics g) {
 772                 Path2D p2d = (Path2D) path.getPlatformPath();
 773                 g.setPaint(state.getPaintNoClone());
 774                 g.fill(p2d);
 775                 if (state.getStrokeNoClone().apply(g)) {
 776                     g.draw(p2d);
 777                 }
 778             }
 779         }.paint();
 780     }
 781 
 782     @Override
 783     public void drawLine(final int x0, final int y0, final int x1, final int y1) {
 784         if (log.isLoggable(Level.FINE)) {
 785             log.fine(&quot;drawLine({0}, {1}, {2}, {3})&quot;,
 786                     new Object[] {x0, y0, x1, y1});
 787         }
 788         Line2D line = new Line2D(x0, y0, x1, y1);
 789         if (!shouldRenderShape(line, null, state.getStrokeNoClone().getPlatformStroke())) {
 790             return;
 791         }
 792         new Composite() {
 793             @Override void doPaint(Graphics g) {
 794                 if (state.getStrokeNoClone().apply(g)) {
 795                     g.drawLine(x0, y0, x1, y1);
 796                 }
 797             }
 798         }.paint();
 799     }
 800 
 801     @Override
 802     public void drawPattern(
 803         final WCImage texture,
 804         final WCRectangle srcRect,
 805         final WCTransform patternTransform,
 806         final WCPoint phase,
 807         final WCRectangle destRect)
 808     {
 809         if (log.isLoggable(Level.FINE)) {
 810             log.fine(&quot;drawPattern({0}, {1}, {2}, {3})&quot;,
 811                     new Object[] {destRect.getIntX(), destRect.getIntY(),
 812                                   destRect.getIntWidth(),
 813                                   destRect.getIntHeight()});
 814         }
 815         if (!shouldRenderRect(destRect.getX(), destRect.getY(),
 816                               destRect.getWidth(), destRect.getHeight(), null, null))
 817         {
 818             return;
 819         }
 820         if (texture != null) {
 821             new Composite() {
 822                 @Override void doPaint(Graphics g) {
 823                     // The handling of pattern transform is modeled after the WebKit
 824                     // ImageCG.cpp&#39;s Image::drawPattern()
 825                     float adjustedX = phase.getX()
 826                             + srcRect.getX() * (float) patternTransform.getMatrix()[0];
 827                     float adjustedY = phase.getY()
 828                             + srcRect.getY() * (float) patternTransform.getMatrix()[3];
 829                     float scaledTileWidth =
 830                             srcRect.getWidth() * (float) patternTransform.getMatrix()[0];
 831                     float scaledTileHeight =
 832                             srcRect.getHeight() * (float) patternTransform.getMatrix()[3];
 833 
 834                     Image img = ((PrismImage)texture).getImage();
 835 
 836                     // Create subImage only if srcRect doesn&#39;t fit the texture bounds. See RT-20193.
 837                     if (!srcRect.contains(new WCRectangle(0, 0, texture.getWidth(), texture.getHeight()))) {
 838 
 839                         img = img.createSubImage(srcRect.getIntX(),
 840                                                  srcRect.getIntY(),
 841                                                  (int)Math.ceil(srcRect.getWidth()),
 842                                                  (int)Math.ceil(srcRect.getHeight()));
 843                     }
 844                     g.setPaint(new ImagePattern(
 845                                img,
 846                                adjustedX, adjustedY,
 847                                scaledTileWidth, scaledTileHeight,
 848                                false, false));
 849 
 850                     g.fillRect(destRect.getX(), destRect.getY(),
 851                                destRect.getWidth(), destRect.getHeight());
 852                 }
 853             }.paint();
 854         }
 855     }
 856 
 857     @Override
 858     public void drawImage(final WCImage img,
 859                           final float dstx, final float dsty, final float dstw, final float dsth,
 860                           final float srcx, final float srcy, final float srcw, final float srch)
 861     {
 862         if (log.isLoggable(Level.FINE)){
 863             log.fine(&quot;drawImage(img, dst({0},{1},{2},{3}), &quot; +
 864                     &quot;src({4},{5},{6},{7}))&quot;,
 865                     new Object[] {dstx, dsty, dstw, dsth,
 866                                   srcx, srcy, srcw, srch});
 867         }
 868         if (!shouldRenderRect(dstx, dsty, dstw, dsth, state.getShadowNoClone(), null)) {
 869             return;
 870         }
 871         if (img instanceof PrismImage) {
 872             new Composite() {
 873                 @Override void doPaint(Graphics g) {
 874                     PrismImage pi = (PrismImage) img;
 875                     DropShadow shadow = state.getShadowNoClone();
 876                     if (shadow != null) {
 877                         NGImageView node = new NGImageView();
 878                         node.setImage(pi.getImage());
 879                         node.setX(dstx);
 880                         node.setY(dsty);
 881                         node.setViewport(srcx, srcy, srcw, srch, dstw, dsth);
 882                         node.setContentBounds(new RectBounds(dstx, dsty, dstx + dstw, dsty + dsth));
 883                         render(g, shadow, null, null, node);
 884                     } else {
 885                         pi.draw(g,
 886                                 (int) dstx, (int) dsty,
 887                                 (int) (dstx + dstw), (int) (dsty + dsth),
 888                                 (int) srcx, (int) srcy,
 889                                 (int) (srcx + srcw), (int) (srcy + srch));
 890                     }
 891                 }
 892             }.paint();
 893         }
 894     }
 895 
 896     @Override
 897     public void drawBitmapImage(final ByteBuffer image, final int x, final int y, final int w, final int h) {
 898         if (!shouldRenderRect(x, y, w, h, null, null)) {
 899             return;
 900         }
 901         new Composite() {
 902             @Override void doPaint(Graphics g) {
 903                 image.order(ByteOrder.nativeOrder());
 904                 Image img = Image.fromByteBgraPreData(image, w, h);
 905                 ResourceFactory rf = g.getResourceFactory();
 906                 Texture txt = rf.createTexture(img, Texture.Usage.STATIC, Texture.WrapMode.REPEAT);
 907                 g.drawTexture(txt, x, y, x + w, y + h, 0, 0, w, h);
 908                 txt.dispose();
 909             }
 910         }.paint();
 911     }
 912 
 913     @Override
 914     public void drawIcon(WCIcon icon, int x, int y) {
 915         if (log.isLoggable(Level.FINE)) {
 916             log.fine(&quot;UNIMPLEMENTED drawIcon ({0}, {1})&quot;,
 917                     new Object[] {x, y});
 918         }
 919     }
 920 
 921     @Override
 922     public void drawRect(final int x, final int y, final int w, final int h) {
 923         if (log.isLoggable(Level.FINE)) {
 924             log.fine(&quot;drawRect({0}, {1}, {2}, {3})&quot;,
 925                     new Object[]{x, y, w, h});
 926         }
 927         if (!shouldRenderRect(x, y, w, h,
 928                               null, state.getStrokeNoClone().getPlatformStroke()))
 929         {
 930             return;
 931         }
 932         new Composite() {
 933             @Override void doPaint(Graphics g) {
 934                 Paint c = state.getPaintNoClone();
 935                 if (c != null &amp;&amp; c.isOpaque()) {
 936                     g.setPaint(c);
 937                     g.fillRect(x, y, w, h);
 938                 }
 939 
 940                 if (state.getStrokeNoClone().apply(g)) {
 941                     g.drawRect(x, y, w, h);
 942                 }
 943             }
 944         }.paint();
 945     }
 946 
 947     @Override
 948     public void drawString(final WCFont f, final int[] glyphs,
 949                            final float[] advances, final float x, final float y)
 950     {
 951         if (log.isLoggable(Level.FINE)) {
 952             log.fine(String.format(
 953                     &quot;Drawing %d glyphs @(%.1f, %.1f)&quot;,
 954                     glyphs.length, x, y));
 955         }
 956         PGFont font = (PGFont)f.getPlatformFont();
 957         TextRun gl = TextUtilities.createGlyphList(glyphs, advances, x, y);
 958 
 959         DropShadow shadow = state.getShadowNoClone();
 960         BasicStroke stroke = state.isTextStroke()
 961                 ? state.getStrokeNoClone().getPlatformStroke()
 962                 : null;
 963 
 964         final FontStrike strike = font.getStrike(getTransformNoClone(), getFontSmoothingType());
 965         if (shouldCalculateIntersection()) {
 966             Metrics m = strike.getMetrics();
 967             gl.setMetrics(m.getAscent(), m.getDescent(), m.getLineGap());
 968             if (!shouldRenderRect(x, y, gl.getWidth(), gl.getHeight(), shadow, stroke)) {
 969                 return;
 970             }
 971         }
 972         new Composite() {
 973             @Override void doPaint(Graphics g) {
 974                 Paint paint = state.isTextFill()
 975                         ? state.getPaintNoClone()
 976                         : null;
 977                 if (shadow != null) {
 978                     final NGText span = new NGText();
 979                     span.setGlyphs(new GlyphList[] {gl});
 980                     span.setFont(font);
 981                     span.setFontSmoothingType(fontSmoothingType);
 982                     render(g, shadow, paint, stroke, span);
 983                 } else {
 984                     if (paint != null) {
 985                         g.setPaint(paint);
 986                         g.drawString(gl, strike, x, y, null, 0, 0);
 987                     }
 988                     if (stroke != null) {
 989                         paint = state.getStrokeNoClone().getPaint();
 990                         if (paint != null) {
 991                             g.setPaint(paint);
 992                             g.setStroke(stroke);
 993                             g.draw(strike.getOutline(gl, BaseTransform.getTranslateInstance(x, y)));
 994                         }
 995                     }
 996                 }
 997             }
 998         }.paint();
 999     }
1000 
1001     @Override public void drawString(WCFont f, String str, boolean rtl,
1002             int from, int to, float x, float y)
1003     {
1004         if (log.isLoggable(Level.FINE)) {
1005             log.fine(String.format(
1006                     &quot;str=&#39;%s&#39; (length=%d), from=%d, to=%d, rtl=%b, @(%.1f, %.1f)&quot;,
1007                     str, str.length(), from, to, rtl, x, y));
1008         }
1009         TextLayout layout = TextUtilities.createLayout(
1010                 str.substring(from, to), f.getPlatformFont());
1011         int count = 0;
1012         GlyphList[] runs = layout.getRuns();
1013         for (GlyphList run: runs) {
1014             count += run.getGlyphCount();
1015         }
1016 
1017         int[] glyphs = new int[count];
1018         float[] adv = new float[count];
1019         count = 0;
1020         for (GlyphList run: layout.getRuns()) {
1021             int gc = run.getGlyphCount();
1022             for (int i = 0; i &lt; gc; i++) {
1023                 glyphs[count] = run.getGlyphCode(i);
1024                 adv[count] = run.getPosX(i + 1) - run.getPosX(i);
1025                 count++;
1026             }
1027         }
1028 
1029         // adjust x coordinate (see RT-29908)
1030         if (rtl) {
1031             x += (TextUtilities.getLayoutWidth(str.substring(from), f.getPlatformFont()) -
1032                   layout.getBounds().getWidth());
1033         } else {
1034             x += TextUtilities.getLayoutWidth(str.substring(0, from), f.getPlatformFont());
1035         }
1036         drawString(f, glyphs, adv, x, y);
1037     }
1038 
1039     @Override
1040     public void setComposite(int composite) {
1041         log.fine(&quot;setComposite({0})&quot;, composite);
1042         state.setCompositeOperation(composite);
1043     }
1044 
1045     @Override
1046     public void drawEllipse(final int x, final int y, final int w, final int h) {
1047         if (log.isLoggable(Level.FINE)) {
1048             log.fine(&quot;drawEllipse({0}, {1}, {2}, {3})&quot;,
1049                     new Object[] { x, y, w, h});
1050         }
1051         if (!shouldRenderRect(x, y, w, h,
1052                               null, state.getStrokeNoClone().getPlatformStroke()))
1053         {
1054             return;
1055         }
1056         new Composite() {
1057             @Override void doPaint(Graphics g) {
1058                 g.setPaint(state.getPaintNoClone());
1059                 g.fillEllipse(x, y, w, h);
1060                 if (state.getStrokeNoClone().apply(g)) {
1061                     g.drawEllipse(x, y, w, h);
1062                 }
1063             }
1064         }.paint();
1065     }
1066 
1067     private final static BasicStroke focusRingStroke =
1068         new BasicStroke(1.1f, BasicStroke.CAP_BUTT,
1069                          BasicStroke.JOIN_ROUND, 0.0f,
1070                          new float[] {1.0f}, 0.0f);
1071 
1072     @Override
1073     public void drawFocusRing(final int x, final int y, final int w, final int h, final int rgba) {
1074         if (log.isLoggable(Level.FINE)) {
1075             log.fine(String.format(&quot;drawFocusRing: %d, %d, %d, %d, 0x%x&quot;, x, y, w, h, rgba));
1076         }
1077         if (!shouldRenderRect(x, y, w, h, null, focusRingStroke)) {
1078             return;
1079         }
1080         new Composite() {
1081             @Override void doPaint(Graphics g) {
1082                 g.setPaint(createColor(rgba));
1083                 BasicStroke stroke = g.getStroke();
1084                 g.setStroke(focusRingStroke);
1085                 g.drawRoundRect(x, y, w, h, 4, 4);
1086                 g.setStroke(stroke);
1087             }
1088         }.paint();
1089     }
1090 
1091     public void setAlpha(float alpha) {
1092         log.fine(&quot;setAlpha({0})&quot;, alpha);
1093 
1094         state.setAlpha(alpha);
1095 
1096         if (null != cachedGraphics) {
1097             cachedGraphics.setExtraAlpha(state.getAlpha());
1098         }
1099     }
1100 
1101     public float getAlpha() {
1102         return state.getAlpha();
1103     }
1104 
1105     @Override public void beginTransparencyLayer(float opacity) {
1106         TransparencyLayer layer = new TransparencyLayer(
1107                 getGraphics(false), state.getClipNoClone(), opacity);
1108 
1109         if (log.isLoggable(Level.FINE)) {
1110             log.fine(String.format(&quot;beginTransparencyLayer(%s)&quot;, layer));
1111         }
1112 
1113         //[saveStateIntertal] will work as [saveState]
1114         state.markAsRestorePoint();
1115 
1116         startNewLayer(layer);
1117     }
1118 
1119     @Override public void endTransparencyLayer() {
1120         if (log.isLoggable(Level.FINE)) {
1121             log.fine(String.format(&quot;endTransparencyLayer(%s)&quot;, state.getLayerNoClone()));
1122         }
1123 
1124         //pair to [startNewLayer] that works as [saveState] call
1125         restoreState();
1126     }
1127 
1128     @Override
1129     public void drawWidget(final RenderTheme theme, final Ref widget, final int x, final int y) {
1130         WCSize s = theme.getWidgetSize(widget);
1131         if (!shouldRenderRect(x, y, s.getWidth(), s.getHeight(), null, null)) {
1132             return;
1133         }
1134         new Composite() {
1135             @Override void doPaint(Graphics g) {
1136                 theme.drawWidget(WCGraphicsPrismContext.this, widget, x, y);
1137             }
1138         }.paint();
1139     }
1140 
1141     @Override
1142     public void drawScrollbar(final ScrollBarTheme theme, final Ref widget, int x, int y,
1143                               int pressedPart, int hoveredPart)
1144     {
1145         if (log.isLoggable(Level.FINE)) {
1146             log.fine(String.format(&quot;drawScrollbar(%s, %s, x = %d, y = %d)&quot;, theme, widget, x, y));
1147         }
1148 
1149         WCSize s = theme.getWidgetSize(widget);
1150         if (!shouldRenderRect(x, y, s.getWidth(), s.getHeight(), null, null)) {
1151             return;
1152         }
1153         new Composite() {
1154             @Override void doPaint(Graphics g) {
1155                 theme.paint(WCGraphicsPrismContext.this, widget, x, y, pressedPart, hoveredPart);
1156             }
1157         }.paint();
1158     }
1159 
1160     private static Rectangle intersect(Rectangle what, Rectangle with) {
1161         if (what == null) {
1162             return with;
1163         }
1164         RectBounds b = what.toRectBounds();
1165         b.intersectWith(with);
1166         what.setBounds(b);
1167         return what;
1168     }
1169 
1170     static Color createColor(int rgba) {
1171         float a = (0xFF &amp; (rgba &gt;&gt; 24)) / 255.0f;
1172         float r = (0xFF &amp; (rgba &gt;&gt; 16)) / 255.0f;
1173         float g = (0xFF &amp; (rgba &gt;&gt; 8)) / 255.0f;
1174         float b = (0xFF &amp; (rgba)) / 255.0f;
1175         return new Color(r, g, b, a);
1176     }
1177 
1178     private static Color4f createColor4f(int rgba) {
1179         float a = (0xFF &amp; (rgba &gt;&gt; 24)) / 255.0f;
1180         float r = (0xFF &amp; (rgba &gt;&gt; 16)) / 255.0f;
1181         float g = (0xFF &amp; (rgba &gt;&gt; 8)) / 255.0f;
1182         float b = (0xFF &amp; (rgba)) / 255.0f;
1183         return new Color4f(r, g, b, a);
1184     }
1185 
1186     private DropShadow createShadow(float dx, float dy, float blur, int rgba) {
1187         if (dx == 0f &amp;&amp; dy == 0f &amp;&amp; blur == 0f) {
1188             return null;
1189         }
1190         DropShadow shadow = new DropShadow();
1191         shadow.setOffsetX((int) dx);
1192         shadow.setOffsetY((int) dy);
1193         shadow.setRadius((blur &lt; 0f) ? 0f : (blur &gt; 127f) ? 127f : blur);
1194         shadow.setColor(createColor4f(rgba));
1195         return shadow;
1196     }
1197 
1198     private void render(Graphics g, Effect effect, Paint paint, BasicStroke stroke, NGNode node) {
1199         if (node instanceof NGShape) {
1200             NGShape shape = (NGShape) node;
1201             Shape realShape = shape.getShape();
1202             Paint strokePaint = state.getStrokeNoClone().getPaint();
1203             if ((stroke != null) &amp;&amp; (strokePaint != null)) {
1204                 realShape = stroke.createStrokedShape(realShape);
1205                 shape.setDrawStroke(stroke);
1206                 shape.setDrawPaint(strokePaint);
1207                 shape.setMode((paint == null) ? NGShape.Mode.STROKE : NGShape.Mode.STROKE_FILL);
1208             } else {
1209                 shape.setMode((paint == null) ? NGShape.Mode.EMPTY : NGShape.Mode.FILL);
1210             }
1211             shape.setFillPaint(paint);
1212             shape.setContentBounds(realShape.getBounds());
1213         }
1214         boolean culling = g.hasPreCullingBits();
1215         g.setHasPreCullingBits(false);
1216         node.setEffect(effect);
1217         node.render(g);
1218         g.setHasPreCullingBits(culling);
1219     }
1220 
1221     private static final class ContextState {
1222         private final WCStrokeImpl stroke = new WCStrokeImpl();
1223         private Rectangle clip;
1224         private Paint paint;
1225         private float alpha;
1226 
1227         private boolean textFill = true;
1228         private boolean textStroke = false;
1229         private boolean textClip = false;
1230         private boolean restorePoint = false;
1231 
1232         private DropShadow shadow;
1233         private Affine3D xform;
1234         private GeneralTransform3D perspectiveTransform;
1235         private Layer layer;
1236         private int compositeOperation;
1237         private WCImage clipMaskImage;
1238 
1239         private ContextState() {
1240             clip = null;
1241             paint = Color.BLACK;
1242             stroke.setPaint(Color.BLACK);
1243             alpha = 1.0f;
1244             xform = new Affine3D();
1245             perspectiveTransform = new GeneralTransform3D();
1246             compositeOperation = COMPOSITE_SOURCE_OVER;
1247         }
1248 
1249         private ContextState(ContextState state) {
1250             stroke.copyFrom(state.getStrokeNoClone());
1251             setPaint(state.getPaintNoClone());
1252             clip = state.getClipNoClone();
1253             if (clip != null) {
1254                 clip = new Rectangle(clip);
1255             }
1256             xform = new Affine3D(state.getTransformNoClone());
1257             perspectiveTransform = new GeneralTransform3D().set(state.getPerspectiveTransformNoClone());
1258             setShadow(state.getShadowNoClone());
1259             setLayer(state.getLayerNoClone());
1260             setAlpha(state.getAlpha());
1261             setTextMode(state.isTextFill(), state.isTextStroke(), state.isTextClip());
1262             setCompositeOperation(state.getCompositeOperation());
1263             setClipMaskImage(state.getClipMaskImageNoClone());
1264         }
1265 
1266         @Override
1267         protected ContextState clone() {
1268             return new ContextState(this);
1269         }
1270 
1271         private void apply(Graphics g) {
1272             g.setTransform(getTransformNoClone());
1273             g.setPerspectiveTransform(getPerspectiveTransformNoClone());
1274             g.setClipRect(getClipNoClone());
1275             g.setExtraAlpha(getAlpha());
1276         }
1277 
1278         private int getCompositeOperation() {
1279             return compositeOperation;
1280         }
1281 
1282         private void setCompositeOperation(int compositeOperation) {
1283             this.compositeOperation = compositeOperation;
1284         }
1285 
1286         private WCStrokeImpl getStrokeNoClone() {
1287             return stroke;
1288         }
1289 
1290         private Paint getPaintNoClone() {
1291             return paint;
1292         }
1293 
1294         private void setPaint(Paint paint) {
1295             this.paint = paint;
1296         }
1297 
1298         private void setClipMaskImage(WCImage image) {
1299             this.clipMaskImage = image;
1300         }
1301 
1302         private WCImage getClipMaskImageNoClone() {
1303             return clipMaskImage;
1304         }
1305 
1306         private Rectangle getClipNoClone() {
1307             return clip;
1308         }
1309 
1310         private Layer getLayerNoClone() {
1311             return layer;
1312         }
1313 
1314         private void setLayer(Layer layer) {
1315             this.layer = layer;
1316         }
1317 
1318         private void setClip(Rectangle area) {
1319             clip = area;
1320         }
1321 
1322         private void clip(Rectangle area) {
1323             if (null == clip) {
1324                 clip = area;
1325             } else {
1326                 clip.intersectWith(area);
1327             }
1328         }
1329 
1330         private void setAlpha(float alpha) {
1331             this.alpha = alpha;
1332         }
1333 
1334         private float getAlpha() {
1335             return alpha;
1336         }
1337 
1338         private void setTextMode(boolean fill, boolean stroke, boolean clip) {
1339             textFill = fill;
1340             textStroke = stroke;
1341             textClip = clip;
1342         }
1343 
1344         private boolean isTextFill() {
1345             return textFill;
1346         }
1347 
1348         private boolean isTextStroke() {
1349             return textStroke;
1350         }
1351 
1352         private boolean isTextClip() {
1353             return textClip;
1354         }
1355 
1356         private void markAsRestorePoint() {
1357             restorePoint = true;
1358         }
1359 
1360         private boolean isRestorePoint() {
1361             return restorePoint;
1362         }
1363 
1364         private void setShadow(DropShadow shadow) {
1365             this.shadow = shadow;
1366         }
1367 
1368         private DropShadow getShadowNoClone() {
1369             return shadow;
1370         }
1371 
1372         private Affine3D getTransformNoClone() {
1373             return xform;
1374         }
1375 
1376         private GeneralTransform3D getPerspectiveTransformNoClone() {
1377             return perspectiveTransform;
1378         }
1379 
1380         private void setTransform(final Affine3D at) {
1381             this.xform.setTransform(at);
1382         }
1383 
1384         private void setPerspectiveTransform(final GeneralTransform3D gt) {
1385             this.perspectiveTransform.set(gt);
1386         }
1387 
1388         private void concatTransform(Affine3D at) {
1389             xform.concatenate(at);
1390         }
1391 
1392         private void translate(double dx, double dy) {
1393             xform.translate(dx, dy);
1394         }
1395 
1396         private void scale(double sx, double sy) {
1397             xform.scale(sx,sy);
1398         }
1399 
1400         private void rotate(double radians) {
1401             xform.rotate(radians);
1402         }
1403     }
1404 
1405     private abstract static class Layer {
1406         FilterContext fctx;
1407         PrDrawable buffer;
1408         Graphics graphics;
1409         final Rectangle bounds;
1410         boolean permanent;
1411 
1412         Layer(Graphics g, Rectangle bounds, boolean permanent) {
1413             this.bounds = new Rectangle(bounds);
1414             this.permanent = permanent;
1415 
1416             // avoid creating zero-size drawable, see also RT-21410
1417             int w = Math.max(bounds.width, 1);
1418             int h = Math.max(bounds.height, 1);
1419             fctx = getFilterContext(g);
1420             if (permanent) {
1421                 ResourceFactory f = GraphicsPipeline.getDefaultResourceFactory();
1422                 RTTexture rtt = f.createRTTexture(w, h, Texture.WrapMode.CLAMP_NOT_NEEDED);
1423                 rtt.makePermanent();
1424                 buffer = ((PrRenderer)Renderer.getRenderer(fctx)).createDrawable(rtt);
1425             } else {
1426                 buffer = (PrDrawable) Effect.getCompatibleImage(fctx, w, h);
1427             }
1428         }
1429 
1430         Graphics getGraphics() {
1431             if (graphics == null) {
1432                 graphics = buffer.createGraphics();
1433             }
1434             return graphics;
1435         }
1436 
1437         abstract void init(Graphics g);
1438 
1439         abstract void render(Graphics g);
1440 
1441         private void dispose() {
1442             if (buffer != null) {
1443                 if (permanent) {
1444                     buffer.flush(); // releases the resource
1445                 } else {
1446                     Effect.releaseCompatibleImage(fctx, buffer);
1447                 }
1448                 fctx = null;
1449                 buffer = null;
1450             }
1451         }
1452 
1453         private double getX() { return (double) bounds.x; }
1454         private double getY() { return (double) bounds.y; }
1455     }
1456 
1457     private final class TransparencyLayer extends Layer {
1458         private final float opacity;
1459 
1460         private TransparencyLayer(Graphics g, Rectangle bounds, float opacity) {
1461             super(g, bounds, false);
1462             this.opacity = opacity;
1463         }
1464 
1465         @Override void init(Graphics g) {
1466             state.setCompositeOperation(COMPOSITE_SOURCE_OVER);
1467         }
1468 
1469         @Override void render(Graphics g) {
1470             new Composite() {
1471                 @Override void doPaint(Graphics g) {
1472                     float op = g.getExtraAlpha();
1473                     g.setExtraAlpha(opacity);
1474                     Affine3D tx = new Affine3D(g.getTransformNoClone());
1475                     g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
1476                     g.drawTexture(buffer.getTextureObject(),
1477                             bounds.x, bounds.y, bounds.width, bounds.height);
1478                     g.setTransform(tx);
1479                     g.setExtraAlpha(op);
1480                 }
1481             }.paint(g);
1482         }
1483 
1484         @Override public String toString() {
1485             return String.format(&quot;TransparencyLayer[%d,%d + %dx%d, opacity %.2f]&quot;,
1486                 bounds.x, bounds.y, bounds.width, bounds.height, opacity);
1487         }
1488     }
1489 
1490     private static final class ClipLayer extends Layer {
1491         private final WCPath normalizedToClipPath;
1492         private boolean srcover;
1493 
1494         private ClipLayer(Graphics g, Rectangle bounds, WCPath normalizedToClipPath,
1495                           boolean permanent)
1496         {
1497             super(g, bounds, permanent);
1498             this.normalizedToClipPath = normalizedToClipPath;
1499             srcover = true;
1500         }
1501 
1502         @Override void init(Graphics g) {
1503             RTTexture texture = null;
1504             ReadbackGraphics readbackGraphics = null;
1505             try {
1506                 readbackGraphics = (ReadbackGraphics) g;
1507                 texture = readbackGraphics.readBack(bounds);
1508                 getGraphics().drawTexture(texture, 0, 0, bounds.width, bounds.height);
1509             } finally {
1510                 if (readbackGraphics != null &amp;&amp; texture != null) {
1511                     readbackGraphics.releaseReadBackBuffer(texture);
1512                 }
1513             }
1514             srcover = false;
1515         }
1516 
1517         @Override void render(Graphics g) {
1518             Path2D p2d = ((WCPathImpl)normalizedToClipPath).getPlatformPath();
1519 
1520             // render normalizedToClipPath to a drawable
1521             PrDrawable bufferImg = (PrDrawable) Effect.getCompatibleImage(
1522                     fctx, bounds.width, bounds.height);
1523             Graphics bufferGraphics = bufferImg.createGraphics();
1524 
1525             bufferGraphics.setPaint(Color.BLACK);
1526             bufferGraphics.fill(p2d);
1527 
1528             // blend buffer and clipImg onto |g|
1529             if (g instanceof MaskTextureGraphics &amp;&amp; ! (g instanceof PrinterGraphics)) {
1530                 MaskTextureGraphics mg = (MaskTextureGraphics) g;
1531                 if (srcover) {
1532                     mg.drawPixelsMasked(buffer.getTextureObject(),
1533                                         bufferImg.getTextureObject(),
1534                                         bounds.x, bounds.y, bounds.width, bounds.height,
1535                                         0, 0, 0, 0);
1536                 } else {
1537                     mg.maskInterpolatePixels(buffer.getTextureObject(),
1538                                              bufferImg.getTextureObject(),
1539                                              bounds.x, bounds.y, bounds.width, bounds.height,
1540                                              0, 0, 0, 0);
1541                 }
1542             } else {
1543                 Blend blend = new Blend(Blend.Mode.SRC_IN,
1544                         new PassThrough(bufferImg, bounds.width, bounds.height),
1545                         new PassThrough(buffer, bounds.width, bounds.height));
1546                 Affine3D tx = new Affine3D(g.getTransformNoClone());
1547                 g.setTransform(BaseTransform.IDENTITY_TRANSFORM);
1548                 PrEffectHelper.render(blend, g, bounds.x, bounds.y, null);
1549                 g.setTransform(tx);
1550             }
1551 
1552             Effect.releaseCompatibleImage(fctx, bufferImg);
1553         }
1554 
1555         @Override public String toString() {
1556             return String.format(&quot;ClipLayer[%d,%d + %dx%d, path %s]&quot;,
1557                     bounds.x, bounds.y, bounds.width, bounds.height,
1558                     normalizedToClipPath);
1559         }
1560     }
1561 
1562     private abstract class Composite {
1563         abstract void doPaint(Graphics g);
1564 
1565         void paint() {
1566             paint(getGraphics(true));
1567         }
1568 
1569         void paint(Graphics g) {
1570             if (g != null) {
1571                 CompositeMode oldCompositeMode = g.getCompositeMode();
1572                 switch (state.getCompositeOperation()) {
1573                     // decode operations that don&#39;t require Blend first
1574                     case COMPOSITE_COPY:
1575                         g.setCompositeMode(CompositeMode.SRC);
1576                         doPaint(g);
1577                         g.setCompositeMode(oldCompositeMode);
1578                         break;
1579                     case COMPOSITE_SOURCE_OVER:
1580                         g.setCompositeMode(CompositeMode.SRC_OVER);
1581                         doPaint(g);
1582                         g.setCompositeMode(oldCompositeMode);
1583                         break;
1584                     default:
1585                         // other operations require usage of Blend
1586                         blend(g);
1587                         break;
1588                 }
1589                 isRootLayerValid = false;
1590             }
1591         }
1592 
1593         private void blend(Graphics g) {
1594             FilterContext fctx = getFilterContext(g);
1595             PrDrawable dstImg = null;
1596             PrDrawable srcImg = null;
1597             ReadbackGraphics readBackGraphics = null;
1598             RTTexture texture = null;
1599             Rectangle clip = state.getClipNoClone();
1600             WCImage image = getImage();
1601             try {
1602                 if (image != null &amp;&amp; image instanceof PrismImage) {
1603                     // blending on canvas
1604                     dstImg = (PrDrawable) Effect.getCompatibleImage(fctx, clip.width, clip.height);
1605                     Graphics dstG = dstImg.createGraphics();
1606                     ((PrismImage) image).draw(dstG,
1607                             0, 0, clip.width, clip.height,
1608                             clip.x, clip.y, clip.width, clip.height);
1609                 } else {
1610                     // blending on page
1611                     readBackGraphics = (ReadbackGraphics) g;
1612                     texture = readBackGraphics.readBack(clip);
1613                     dstImg = PrDrawable.create(fctx, texture);
1614                 }
1615 
1616                 srcImg = (PrDrawable) Effect.getCompatibleImage(fctx, clip.width, clip.height);
1617                 Graphics srcG = srcImg.createGraphics();
1618                 state.apply(srcG);
1619                 doPaint(srcG);
1620 
1621                 g.clear();
1622                 PrEffectHelper.render(createEffect(dstImg, srcImg, clip.width, clip.height), g, 0, 0, null);
1623 
1624             } finally {
1625                 if (srcImg != null) {
1626                     Effect.releaseCompatibleImage(fctx, srcImg);
1627                 }
1628                 if (dstImg != null) {
1629                     if (readBackGraphics != null &amp;&amp; texture != null) {
1630                         readBackGraphics.releaseReadBackBuffer(texture);
1631                     } else {
1632                         Effect.releaseCompatibleImage(fctx, dstImg);
1633                     }
1634                 }
1635             }
1636         }
1637 
1638         // provides some syntax sugar for createEffect()
1639         private Effect createBlend(Blend.Mode mode,
1640                                    PrDrawable dstImg,
1641                                    PrDrawable srcImg,
1642                                    int width,
1643                                    int height)
1644         {
1645             return new Blend(
1646                     mode,
1647                     new PassThrough(dstImg, width, height),
1648                     new PassThrough(srcImg, width, height));
1649         }
1650 
1651         private Effect createEffect(PrDrawable dstImg,
1652                                     PrDrawable srcImg,
1653                                     int width,
1654                                     int height)
1655         {
1656             switch (state.getCompositeOperation()) {
1657                 case COMPOSITE_CLEAR: // same as xor
1658                 case COMPOSITE_XOR:
1659                     return new Blend(
1660                             SRC_OVER,
1661                             createBlend(SRC_OUT, dstImg, srcImg, width, height),
1662                             createBlend(SRC_OUT, srcImg, dstImg, width, height)
1663                     );
1664                 case COMPOSITE_SOURCE_IN:
1665                     return createBlend(SRC_IN, dstImg, srcImg, width, height);
1666                 case COMPOSITE_SOURCE_OUT:
1667                     return createBlend(SRC_OUT, dstImg, srcImg, width, height);
1668                 case COMPOSITE_SOURCE_ATOP:
1669                     return createBlend(SRC_ATOP, dstImg, srcImg, width, height);
1670                 case COMPOSITE_DESTINATION_OVER:
1671                     return createBlend(SRC_OVER, srcImg, dstImg, width, height);
1672                 case COMPOSITE_DESTINATION_IN:
1673                     return createBlend(SRC_IN, srcImg, dstImg, width, height);
1674                 case COMPOSITE_DESTINATION_OUT:
1675                     return createBlend(SRC_OUT, srcImg, dstImg, width, height);
1676                 case COMPOSITE_DESTINATION_ATOP:
1677                     return createBlend(SRC_ATOP, srcImg, dstImg, width, height);
1678                 case COMPOSITE_HIGHLIGHT:
1679                     return createBlend(ADD, dstImg, srcImg, width, height);
1680                 default:
1681                     return createBlend(SRC_OVER, dstImg, srcImg, width, height);
1682             }
1683         }
1684     }
1685 
1686     private static final class PassThrough extends Effect {
1687         private final PrDrawable img;
1688         private final int width;
1689         private final int height;
1690 
1691         private PassThrough(PrDrawable img, int width, int height) {
1692             this.img = img;
1693             this.width = width;
1694             this.height = height;
1695         }
1696 
1697         @Override public ImageData filter(
1698                 FilterContext fctx,
1699                 BaseTransform transform,
1700                 Rectangle outputClip,
1701                 Object renderHelper,
1702                 Effect defaultInput) {
1703             // We have an unpaired lock() here, because unlocking is done
1704             // internally by ImageData. See RT-33625 for details.
1705             img.lock();
1706             ImageData imgData = new ImageData(fctx, img, new Rectangle(
1707                                               (int) transform.getMxt(),
1708                                               (int) transform.getMyt(),
1709                                               width, height));
1710             imgData.setReusable(true);
1711             return imgData;
1712         }
1713 
1714         @Override public RectBounds getBounds(
1715                 BaseTransform transform,
1716                 Effect defaultInput) {
1717             return null;
1718         }
1719 
1720         @Override public AccelType getAccelType(FilterContext fctx) {
1721             return AccelType.INTRINSIC;
1722         }
1723 
1724         @Override
1725         public boolean reducesOpaquePixels() {
1726             return false;
1727         }
1728 
1729         @Override
1730         public DirtyRegionContainer getDirtyRegions(Effect defaultInput, DirtyRegionPool regionPool) {
1731             return null;
1732         }
1733     }
1734 
1735     private static FilterContext getFilterContext(Graphics g) {
1736         Screen screen = g.getAssociatedScreen();
1737         if (screen == null) {
1738             ResourceFactory factory = g.getResourceFactory();
1739             return PrFilterContext.getPrinterContext(factory);
1740         } else {
1741             return PrFilterContext.getInstance(screen);
1742         }
1743     }
1744 
1745     @Override
1746     public void strokeArc(final int x, final int y, final int w, final int h,
1747                           final int startAngle, final int angleSpan)
1748     {
1749         if (log.isLoggable(Level.FINE)) {
1750             log.fine(String.format(&quot;strokeArc(%d, %d, %d, %d, %d, %d)&quot;,
1751                                    x, y, w, h, startAngle, angleSpan));
1752         }
1753         Arc2D arc = new Arc2D(x, y, w, h, startAngle, angleSpan, Arc2D.OPEN);
1754         if (state.getStrokeNoClone().isApplicable() &amp;&amp;
1755             !shouldRenderShape(arc, null, state.getStrokeNoClone().getPlatformStroke()))
1756         {
1757             return;
1758         }
1759         new Composite() {
1760             @Override void doPaint(Graphics g) {
1761                 if (state.getStrokeNoClone().apply(g)) {
1762                     g.draw(arc);
1763                 }
1764             }
1765         }.paint();
1766     }
1767 
1768     @Override
1769     public WCImage getImage() {
1770         return null;
1771     }
1772 
1773     @Override
1774     public void strokeRect(final float x, final float y, final float w, final float h,
1775                            final float lineWidth) {
1776         if (log.isLoggable(Level.FINE)) {
1777             log.fine(String.format(&quot;strokeRect_FFFFF(%f, %f, %f, %f, %f)&quot;,
1778                                    x, y, w, h, lineWidth));
1779         }
1780         BasicStroke stroke = new BasicStroke(
1781             lineWidth,
1782             BasicStroke.CAP_BUTT,
1783             BasicStroke.JOIN_MITER,
1784             Math.max(1.0f, lineWidth),
1785             state.getStrokeNoClone().getDashSizes(),
1786             state.getStrokeNoClone().getDashOffset());
1787 
1788         if (!shouldRenderRect(x, y, w, h, null, stroke)) {
1789             return;
1790         }
1791         new Composite() {
1792             @Override void doPaint(Graphics g) {
1793                 g.setStroke(stroke);
1794                 Paint paint = state.getStrokeNoClone().getPaint();
1795                 if (paint == null) {
1796                     paint = state.getPaintNoClone();
1797                 }
1798                 g.setPaint(paint);
1799                 g.drawRect(x, y, w, h);
1800             }
1801         }.paint();
1802     }
1803 
1804     @Override
1805     public void strokePath(final WCPath path) {
1806         log.fine(&quot;strokePath&quot;);
1807         if (path != null) {
1808             final BasicStroke stroke = state.getStrokeNoClone().getPlatformStroke();
1809             final DropShadow shadow = state.getShadowNoClone();
1810             final Path2D p2d = (Path2D)path.getPlatformPath();
1811 
1812             if ((stroke == null &amp;&amp; shadow == null) ||
1813                 !shouldRenderShape(p2d, shadow, stroke))
1814             {
1815                 return;
1816             }
1817             new Composite() {
1818                 @Override void doPaint(Graphics g) {
1819                     if (shadow != null) {
1820                         final NGPath node = new NGPath();
1821                         node.updateWithPath2d(p2d);
1822                         render(g, shadow, null, stroke, node);
1823                     } else if (stroke != null) {
1824                         Paint paint = state.getStrokeNoClone().getPaint();
1825                         if (paint == null) {
1826                             paint = state.getPaintNoClone();
1827                         }
1828                         g.setPaint(paint);
1829                         g.setStroke(stroke);
1830                         g.draw(p2d);
1831                     }
1832                 }
1833             }.paint();
1834         }
1835     }
1836 
1837     @Override
1838     public void fillPath(final WCPath path) {
1839         log.fine(&quot;fillPath&quot;);
1840         if (path != null) {
1841             if (!shouldRenderShape(((WCPathImpl)path).getPlatformPath(),
1842                                    state.getShadowNoClone(), null))
1843             {
1844                 return;
1845             }
1846             new Composite() {
1847                 @Override void doPaint(Graphics g) {
1848                     Path2D p2d = (Path2D) path.getPlatformPath();
1849                     Paint paint = state.getPaintNoClone();
1850                     DropShadow shadow = state.getShadowNoClone();
1851                     if (shadow != null) {
1852                         final NGPath node = new NGPath();
1853                         node.updateWithPath2d(p2d);
1854                         render(g, shadow, paint, null, node);
1855                     } else {
1856                         g.setPaint(paint);
1857                         g.fill(p2d);
1858                     }
1859                 }
1860             }.paint();
1861         }
1862     }
1863 
1864     public void setPerspectiveTransform(WCTransform tm) {
1865         final GeneralTransform3D at = new GeneralTransform3D().set(tm.getMatrix());
1866         state.setPerspectiveTransform(at);
1867         resetCachedGraphics();
1868     }
1869 
1870     public void setTransform(WCTransform tm) {
1871         final double m[] = tm.getMatrix();
1872         final Affine3D at = new Affine3D(new Affine2D(m[0], m[1], m[2], m[3], m[4], m[5]));
1873         if (state.getLayerNoClone() == null) {
1874             at.preConcatenate(baseTransform);
1875         }
1876         state.setTransform(at);
1877         resetCachedGraphics();
1878     }
1879 
1880     public WCTransform getTransform() {
1881         Affine3D xf = state.getTransformNoClone();
1882         return new WCTransform(xf.getMxx(), xf.getMyx(),
1883                                xf.getMxy(), xf.getMyy(),
1884                                xf.getMxt(), xf.getMyt());
1885     }
1886 
1887     public void concatTransform(WCTransform tm) {
1888         double m[] = tm.getMatrix();
1889         Affine3D at = new Affine3D(new Affine2D(m[0], m[1], m[2], m[3], m[4], m[5]));
1890         state.concatTransform(at);
1891         resetCachedGraphics();
1892     }
1893 
1894     @Override
1895     public void flush() {
1896         flushAllLayers();
1897     }
1898 
1899     @Override
1900     public WCGradient createLinearGradient(WCPoint p1, WCPoint p2) {
1901         return new WCLinearGradient(p1, p2);
1902     }
1903 
1904     @Override
1905     public WCGradient createRadialGradient(WCPoint p1, float r1, WCPoint p2, float r2) {
1906         return new WCRadialGradient(p1, r1, p2, r2);
1907     }
1908 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
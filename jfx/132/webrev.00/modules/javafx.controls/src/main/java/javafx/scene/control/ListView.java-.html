<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.controls/src/main/java/javafx/scene/control/ListView.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control;
  27 
  28 import java.util.ArrayList;
  29 import java.util.Collections;
  30 import java.util.HashMap;
  31 import java.util.List;
  32 
  33 import com.sun.javafx.scene.control.Properties;
  34 import com.sun.javafx.scene.control.SelectedItemsReadOnlyObservableList;
  35 import com.sun.javafx.scene.control.behavior.ListCellBehavior;
  36 import javafx.beans.InvalidationListener;
  37 import javafx.beans.Observable;
  38 import javafx.beans.WeakInvalidationListener;
  39 import javafx.beans.property.BooleanProperty;
  40 import javafx.beans.property.DoubleProperty;
  41 import javafx.beans.property.ObjectProperty;
  42 import javafx.beans.property.ObjectPropertyBase;
  43 import javafx.beans.property.ReadOnlyIntegerProperty;
  44 import javafx.beans.property.ReadOnlyIntegerWrapper;
  45 import javafx.beans.property.SimpleBooleanProperty;
  46 import javafx.beans.property.SimpleObjectProperty;
  47 import javafx.beans.value.WritableValue;
  48 import javafx.collections.FXCollections;
  49 import javafx.collections.ListChangeListener;
  50 import javafx.collections.ListChangeListener.Change;
  51 import javafx.collections.MapChangeListener;
  52 import javafx.collections.ObservableList;
  53 import javafx.css.StyleableDoubleProperty;
  54 import javafx.event.Event;
  55 import javafx.event.EventHandler;
  56 import javafx.event.EventType;
  57 import javafx.geometry.Orientation;
  58 import javafx.scene.layout.Region;
  59 import javafx.util.Callback;
  60 import javafx.css.StyleableObjectProperty;
  61 import javafx.css.CssMetaData;
  62 
  63 import javafx.css.converter.EnumConverter;
  64 
  65 import javafx.collections.WeakListChangeListener;
  66 
  67 import javafx.css.converter.SizeConverter;
  68 import javafx.scene.control.skin.ListViewSkin;
  69 
  70 import java.lang.ref.WeakReference;
  71 
  72 import javafx.css.PseudoClass;
  73 import javafx.beans.DefaultProperty;
  74 import javafx.css.Styleable;
  75 import javafx.css.StyleableProperty;
  76 import javafx.scene.AccessibleAttribute;
  77 import javafx.scene.AccessibleRole;
  78 import javafx.scene.Node;
  79 import javafx.util.Pair;
  80 
  81 /**
  82  * A ListView displays a horizontal or vertical list of items from which the
  83  * user may select, or with which the user may interact. A ListView is able to
  84  * have its generic type set to represent the type of data in the backing model.
  85  * Doing this has the benefit of making various methods in the ListView, as well
  86  * as the supporting classes (mentioned below), type-safe. In addition, making
  87  * use of the generic type supports substantially simplified development of applications
  88  * making use of ListView, as all modern IDEs are able to auto-complete far
  89  * more successfully with the additional type information.
  90  *
  91  * &lt;h2&gt;Populating a ListView&lt;/h2&gt;
  92  * &lt;p&gt;A simple example of how to create and populate a ListView of names (Strings)
  93  * is shown here:
  94  *
  95  * &lt;pre&gt; {@code ObservableList&lt;String&gt; names = FXCollections.observableArrayList(
  96  *          &quot;Julia&quot;, &quot;Ian&quot;, &quot;Sue&quot;, &quot;Matthew&quot;, &quot;Hannah&quot;, &quot;Stephan&quot;, &quot;Denise&quot;);
  97  * ListView&lt;String&gt; listView = new ListView&lt;String&gt;(names);}&lt;/pre&gt;
  98  *
  99  * &lt;p&gt;The elements of the ListView are contained within the
 100  * {@link #itemsProperty() items} {@link ObservableList}. This
 101  * ObservableList is automatically observed by the ListView, such that any
 102  * changes that occur inside the ObservableList will be automatically shown in
 103  * the ListView itself. If passing the &lt;code&gt;ObservableList&lt;/code&gt; in to the
 104  * ListView constructor is not feasible, the recommended approach for setting
 105  * the items is to simply call:
 106  *
 107  * &lt;pre&gt; {@code ObservableList&lt;T&gt; content = ...
 108  * listView.setItems(content);}&lt;/pre&gt;
 109  *
 110  * &lt;img src=&quot;doc-files/ListView.png&quot; alt=&quot;Image of the ListView control&quot;&gt;
 111  *
 112  * &lt;p&gt;The end result of this is, as noted above, that the ListView will automatically
 113  * refresh the view to represent the items in the list.
 114  *
 115  * &lt;p&gt;Another approach, whilst accepted by the ListView, &lt;b&gt;is not the
 116  * recommended approach&lt;/b&gt;:
 117  *
 118  * &lt;pre&gt; {@code List&lt;T&gt; content = ...
 119  * getItems().setAll(content);}&lt;/pre&gt;
 120  *
 121  * The issue with the approach shown above is that the content list is being
 122  * copied into the items list - meaning that subsequent changes to the content
 123  * list are not observed, and will not be reflected visually within the ListView.
 124  *
 125  * &lt;h2&gt;ListView Selection / Focus APIs&lt;/h2&gt;
 126  * &lt;p&gt;To track selection and focus, it is necessary to become familiar with the
 127  * {@link SelectionModel} and {@link FocusModel} classes. A ListView has at most
 128  * one instance of each of these classes, available from
 129  * {@link #selectionModelProperty() selectionModel} and
 130  * {@link #focusModelProperty() focusModel} properties respectively.
 131  * Whilst it is possible to use this API to set a new selection model, in
 132  * most circumstances this is not necessary - the default selection and focus
 133  * models should work in most circumstances.
 134  *
 135  * &lt;p&gt;The default {@link SelectionModel} used when instantiating a ListView is
 136  * an implementation of the {@link MultipleSelectionModel} abstract class.
 137  * However, as noted in the API documentation for
 138  * the {@link MultipleSelectionModel#selectionModeProperty() selectionMode}
 139  * property, the default value is {@link SelectionMode#SINGLE}. To enable
 140  * multiple selection in a default ListView instance, it is therefore necessary
 141  * to do the following:
 142  *
 143  * &lt;pre&gt; {@code listView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);}&lt;/pre&gt;
 144  *
 145  * &lt;h2&gt;Customizing ListView Visuals&lt;/h2&gt;
 146  * &lt;p&gt;The visuals of the ListView can be entirely customized by replacing the
 147  * default {@link #cellFactoryProperty() cell factory}. A cell factory is used to
 148  * generate {@link ListCell} instances, which are used to represent an item in the
 149  * ListView. See the {@link Cell} class documentation for a more complete
 150  * description of how to write custom Cells.
 151  *
 152  * &lt;h2&gt;Editing&lt;/h2&gt;
 153  * &lt;p&gt;This control supports inline editing of values, and this section attempts to
 154  * give an overview of the available APIs and how you should use them.&lt;/p&gt;
 155  *
 156  * &lt;p&gt;Firstly, cell editing most commonly requires a different user interface
 157  * than when a cell is not being edited. This is the responsibility of the
 158  * {@link Cell} implementation being used. For ListView, this is the responsibility
 159  * of the {@link #cellFactoryProperty() cell factory}. It is your choice whether the cell is
 160  * permanently in an editing state (e.g. this is common for {@link CheckBox} cells),
 161  * or to switch to a different UI when editing begins (e.g. when a double-click
 162  * is received on a cell).&lt;/p&gt;
 163  *
 164  * &lt;p&gt;To know when editing has been requested on a cell,
 165  * simply override the {@link javafx.scene.control.Cell#startEdit()} method, and
 166  * update the cell {@link javafx.scene.control.Cell#textProperty() text} and
 167  * {@link javafx.scene.control.Cell#graphicProperty() graphic} properties as
 168  * appropriate (e.g. set the text to null and set the graphic to be a
 169  * {@link TextField}). Additionally, you should also override
 170  * {@link Cell#cancelEdit()} to reset the UI back to its original visual state
 171  * when the editing concludes. In both cases it is important that you also
 172  * ensure that you call the super method to have the cell perform all duties it
 173  * must do to enter or exit its editing mode.&lt;/p&gt;
 174  *
 175  * &lt;p&gt;Once your cell is in an editing state, the next thing you are most probably
 176  * interested in is how to commit or cancel the editing that is taking place. This is your
 177  * responsibility as the cell factory provider. Your cell implementation will know
 178  * when the editing is over, based on the user input (e.g. when the user presses
 179  * the Enter or ESC keys on their keyboard). When this happens, it is your
 180  * responsibility to call {@link Cell#commitEdit(Object)} or
 181  * {@link Cell#cancelEdit()}, as appropriate.&lt;/p&gt;
 182  *
 183  * &lt;p&gt;When you call {@link Cell#commitEdit(Object)} an event is fired to the
 184  * ListView, which you can observe by adding an {@link EventHandler} via
 185  * {@link ListView#setOnEditCommit(javafx.event.EventHandler)}. Similarly,
 186  * you can also observe edit events for
 187  * {@link ListView#setOnEditStart(javafx.event.EventHandler) edit start}
 188  * and {@link ListView#setOnEditCancel(javafx.event.EventHandler) edit cancel}.&lt;/p&gt;
 189  *
 190  * &lt;p&gt;By default the ListView edit commit handler is non-null, with a default
 191  * handler that attempts to overwrite the property value for the
 192  * item in the currently-being-edited row. It is able to do this as the
 193  * {@link Cell#commitEdit(Object)} method is passed in the new value, and this
 194  * is passed along to the edit commit handler via the
 195  * {@link EditEvent} that is fired. It is simply a matter of calling
 196  * {@link EditEvent#getNewValue()} to retrieve this value.
 197  *
 198  * &lt;p&gt;It is very important to note that if you call
 199  * {@link ListView#setOnEditCommit(javafx.event.EventHandler)} with your own
 200  * {@link EventHandler}, then you will be removing the default handler. Unless
 201  * you then handle the writeback to the property (or the relevant data source),
 202  * nothing will happen. You can work around this by using the
 203  * {@link ListView#addEventHandler(javafx.event.EventType, javafx.event.EventHandler)}
 204  * method to add a {@link ListView#editCommitEvent()} {@link EventType} with
 205  * your desired {@link EventHandler} as the second argument. Using this method,
 206  * you will not replace the default implementation, but you will be notified when
 207  * an edit commit has occurred.&lt;/p&gt;
 208  *
 209  * &lt;p&gt;Hopefully this summary answers some of the commonly asked questions.
 210  * Fortunately, JavaFX ships with a number of pre-built cell factories that
 211  * handle all the editing requirements on your behalf. You can find these
 212  * pre-built cell factories in the javafx.scene.control.cell package.&lt;/p&gt;
 213  *
 214  * @see ListCell
 215  * @see MultipleSelectionModel
 216  * @see FocusModel
 217  * @param &lt;T&gt; This type is used to represent the type of the objects stored in
 218  *          the ListViews {@link #itemsProperty() items} ObservableList. It is
 219  *          also used in the {@link #selectionModelProperty() selection model}
 220  *          and {@link #focusModelProperty() focus model}.
 221  * @since JavaFX 2.0
 222  */
 223 // TODO add code examples
 224 @DefaultProperty(&quot;items&quot;)
 225 public class ListView&lt;T&gt; extends Control {
 226 
 227     /***************************************************************************
 228      *                                                                         *
 229      * Static properties and methods                                           *
 230      *                                                                         *
 231      **************************************************************************/
 232 
 233     /**
 234      * An EventType that indicates some edit event has occurred. It is the parent
 235      * type of all other edit events: {@link #editStartEvent()},
 236      *  {@link #editCommitEvent()} and {@link #editCancelEvent()}.
 237      * @param &lt;T&gt; the type of the objects stored in this ListView
 238      * @return the event type
 239      */
 240     @SuppressWarnings(&quot;unchecked&quot;)
 241     public static &lt;T&gt; EventType&lt;ListView.EditEvent&lt;T&gt;&gt; editAnyEvent() {
 242         return (EventType&lt;ListView.EditEvent&lt;T&gt;&gt;) EDIT_ANY_EVENT;
 243     }
 244     private static final EventType&lt;?&gt; EDIT_ANY_EVENT =
 245             new EventType&lt;&gt;(Event.ANY, &quot;LIST_VIEW_EDIT&quot;);
 246 
 247     /**
 248      * An EventType used to indicate that an edit event has started within the
 249      * ListView upon which the event was fired.
 250      * @param &lt;T&gt; the type of the objects stored in this ListView
 251      * @return the event type
 252      */
 253     @SuppressWarnings(&quot;unchecked&quot;)
 254     public static &lt;T&gt; EventType&lt;ListView.EditEvent&lt;T&gt;&gt; editStartEvent() {
 255         return (EventType&lt;ListView.EditEvent&lt;T&gt;&gt;) EDIT_START_EVENT;
 256     }
 257     private static final EventType&lt;?&gt; EDIT_START_EVENT =
 258             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_START&quot;);
 259 
 260     /**
 261      * An EventType used to indicate that an edit event has just been canceled
 262      * within the ListView upon which the event was fired.
 263      * @param &lt;T&gt; the type of the objects stored in this ListView
 264      * @return the event type
 265      */
 266     @SuppressWarnings(&quot;unchecked&quot;)
 267     public static &lt;T&gt; EventType&lt;ListView.EditEvent&lt;T&gt;&gt; editCancelEvent() {
 268         return (EventType&lt;ListView.EditEvent&lt;T&gt;&gt;) EDIT_CANCEL_EVENT;
 269     }
 270     private static final EventType&lt;?&gt; EDIT_CANCEL_EVENT =
 271             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_CANCEL&quot;);
 272 
 273     /**
 274      * An EventType used to indicate that an edit event has been committed
 275      * within the ListView upon which the event was fired.
 276      * @param &lt;T&gt; the type of the objects stored in this ListView
 277      * @return the event type
 278      */
 279     @SuppressWarnings(&quot;unchecked&quot;)
 280     public static &lt;T&gt; EventType&lt;ListView.EditEvent&lt;T&gt;&gt; editCommitEvent() {
 281         return (EventType&lt;ListView.EditEvent&lt;T&gt;&gt;) EDIT_COMMIT_EVENT;
 282     }
 283     private static final EventType&lt;?&gt; EDIT_COMMIT_EVENT =
 284             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_COMMIT&quot;);
 285 
 286 
 287 
 288     /***************************************************************************
 289      *                                                                         *
 290      * Fields                                                                  *
 291      *                                                                         *
 292      **************************************************************************/
 293 
 294     // by default we always select the first row in the ListView, and when the
 295     // items list changes, we also reselect the first row. In some cases, such as
 296     // for the ComboBox, this is not desirable, so it can be disabled here.
 297     private boolean selectFirstRowByDefault = true;
 298 
 299 
 300 
 301     /***************************************************************************
 302      *                                                                         *
 303      * Constructors                                                            *
 304      *                                                                         *
 305      **************************************************************************/
 306 
 307     /**
 308      * Creates a default ListView which will display contents stacked vertically.
 309      * As no {@link ObservableList} is provided in this constructor, an empty
 310      * ObservableList is created, meaning that it is legal to directly call
 311      * {@link #getItems()} if so desired. However, as noted elsewhere, this
 312      * is not the recommended approach
 313      * (instead call {@link #setItems(javafx.collections.ObservableList)}).
 314      *
 315      * &lt;p&gt;Refer to the {@link ListView} class documentation for details on the
 316      * default state of other properties.
 317      */
 318     public ListView() {
 319         this(FXCollections.&lt;T&gt;observableArrayList());
 320     }
 321 
 322     /**
 323      * Creates a default ListView which will stack the contents retrieved from the
 324      * provided {@link ObservableList} vertically.
 325      *
 326      * &lt;p&gt;Attempts to add a listener to the {@link ObservableList}, such that all
 327      * subsequent changes inside the list will be shown to the user.
 328      *
 329      * &lt;p&gt;Refer to the {@link ListView} class documentation for details on the
 330      * default state of other properties.
 331      * @param items the list of items
 332      */
 333     public ListView(ObservableList&lt;T&gt; items) {
 334         getStyleClass().setAll(DEFAULT_STYLE_CLASS);
 335         setAccessibleRole(AccessibleRole.LIST_VIEW);
 336 
 337         setItems(items);
 338 
 339         // Install default....
 340         // ...selection model
 341         setSelectionModel(new ListView.ListViewBitSetSelectionModel&lt;T&gt;(this));
 342 
 343         // ...focus model
 344         setFocusModel(new ListView.ListViewFocusModel&lt;T&gt;(this));
 345 
 346         // ...edit commit handler
 347         setOnEditCommit(DEFAULT_EDIT_COMMIT_HANDLER);
 348 
 349         // Fix for RT-36651, which was introduced by RT-35679 (above) and resolved
 350         // by having special-case code to remove the listener when requested.
 351         // This is done by ComboBoxListViewSkin, so that selection is not done
 352         // when a ComboBox is shown.
 353         getProperties().addListener((MapChangeListener&lt;Object, Object&gt;) change -&gt; {
 354             if (change.wasAdded() &amp;&amp; &quot;selectFirstRowByDefault&quot;.equals(change.getKey())) {
 355                 Boolean _selectFirstRowByDefault = (Boolean) change.getValueAdded();
 356                 if (_selectFirstRowByDefault == null) return;
 357                 selectFirstRowByDefault = _selectFirstRowByDefault;
 358             }
 359         });
 360     }
 361 
 362 
 363 
 364     /***************************************************************************
 365      *                                                                         *
 366      * Callbacks and Events                                                    *
 367      *                                                                         *
 368      **************************************************************************/
 369 
 370     private EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt; DEFAULT_EDIT_COMMIT_HANDLER = t -&gt; {
 371         int index = t.getIndex();
 372         List&lt;T&gt; list = getItems();
 373         if (index &lt; 0 || index &gt;= list.size()) return;
 374         list.set(index, t.getNewValue());
 375     };
 376 
 377 
 378 
 379     /***************************************************************************
 380      *                                                                         *
 381      * Properties                                                              *
 382      *                                                                         *
 383      **************************************************************************/
 384 
 385     // --- Items
 386     private ObjectProperty&lt;ObservableList&lt;T&gt;&gt; items;
 387 
 388     /**
 389      * Sets the underlying data model for the ListView. Note that it has a generic
 390      * type that must match the type of the ListView itself.
 391      * @param value the list of items for this ListView
 392      */
 393     public final void setItems(ObservableList&lt;T&gt; value) {
 394         itemsProperty().set(value);
 395     }
 396 
 397     /**
 398      * Returns an {@link ObservableList} that contains the items currently being
 399      * shown to the user. This may be null if
 400      * {@link #setItems(javafx.collections.ObservableList)} has previously been
 401      * called, however, by default it is an empty ObservableList.
 402      *
 403      * @return An ObservableList containing the items to be shown to the user, or
 404      *      null if the items have previously been set to null.
 405      */
 406     public final ObservableList&lt;T&gt; getItems() {
 407         return items == null ? null : items.get();
 408     }
 409 
 410     /**
 411      * The underlying data model for the ListView. Note that it has a generic
 412      * type that must match the type of the ListView itself.
 413      * @return the items property for this ListView
 414      */
 415     public final ObjectProperty&lt;ObservableList&lt;T&gt;&gt; itemsProperty() {
 416         if (items == null) {
 417             items = new SimpleObjectProperty&lt;&gt;(this, &quot;items&quot;);
 418         }
 419         return items;
 420     }
 421 
 422 
 423     // --- Placeholder Node
 424     private ObjectProperty&lt;Node&gt; placeholder;
 425     /**
 426      * This Node is shown to the user when the listview has no content to show.
 427      * This may be the case because the table model has no data in the first
 428      * place or that a filter has been applied to the list model, resulting
 429      * in there being nothing to show the user..
 430      * @return the placeholder property for this ListView
 431      * @since JavaFX 8.0
 432      */
 433     public final ObjectProperty&lt;Node&gt; placeholderProperty() {
 434         if (placeholder == null) {
 435             placeholder = new SimpleObjectProperty&lt;Node&gt;(this, &quot;placeholder&quot;);
 436         }
 437         return placeholder;
 438     }
 439     public final void setPlaceholder(Node value) {
 440         placeholderProperty().set(value);
 441     }
 442     public final Node getPlaceholder() {
 443         return placeholder == null ? null : placeholder.get();
 444     }
 445 
 446 
 447     // --- Selection Model
 448     private ObjectProperty&lt;MultipleSelectionModel&lt;T&gt;&gt; selectionModel = new SimpleObjectProperty&lt;MultipleSelectionModel&lt;T&gt;&gt;(this, &quot;selectionModel&quot;);
 449 
 450     /**
 451      * Sets the {@link MultipleSelectionModel} to be used in the ListView.
 452      * Despite a ListView requiring a &lt;b&gt;Multiple&lt;/b&gt;SelectionModel, it is possible
 453      * to configure it to only allow single selection (see
 454      * {@link MultipleSelectionModel#setSelectionMode(javafx.scene.control.SelectionMode)}
 455      * for more information).
 456      * @param value the MultipleSelectionModel to be used in this ListView
 457      */
 458     public final void setSelectionModel(MultipleSelectionModel&lt;T&gt; value) {
 459         selectionModelProperty().set(value);
 460     }
 461 
 462     /**
 463      * Returns the currently installed selection model.
 464      * @return the currently installed selection model
 465      */
 466     public final MultipleSelectionModel&lt;T&gt; getSelectionModel() {
 467         return selectionModel == null ? null : selectionModel.get();
 468     }
 469 
 470     /**
 471      * The SelectionModel provides the API through which it is possible
 472      * to select single or multiple items within a ListView, as  well as inspect
 473      * which items have been selected by the user. Note that it has a generic
 474      * type that must match the type of the ListView itself.
 475      * @return the selectionModel property
 476      */
 477     public final ObjectProperty&lt;MultipleSelectionModel&lt;T&gt;&gt; selectionModelProperty() {
 478         return selectionModel;
 479     }
 480 
 481 
 482     // --- Focus Model
 483     private ObjectProperty&lt;FocusModel&lt;T&gt;&gt; focusModel;
 484 
 485     /**
 486      * Sets the {@link FocusModel} to be used in the ListView.
 487      * @param value the FocusModel to be used in the ListView
 488      */
 489     public final void setFocusModel(FocusModel&lt;T&gt; value) {
 490         focusModelProperty().set(value);
 491     }
 492 
 493     /**
 494      * Returns the currently installed {@link FocusModel}.
 495      * @return the currently installed FocusModel
 496      */
 497     public final FocusModel&lt;T&gt; getFocusModel() {
 498         return focusModel == null ? null : focusModel.get();
 499     }
 500 
 501     /**
 502      * The FocusModel provides the API through which it is possible
 503      * to both get and set the focus on a single item within a ListView. Note
 504      * that it has a generic type that must match the type of the ListView itself.
 505      * @return the FocusModel property
 506      */
 507     public final ObjectProperty&lt;FocusModel&lt;T&gt;&gt; focusModelProperty() {
 508         if (focusModel == null) {
 509             focusModel = new SimpleObjectProperty&lt;FocusModel&lt;T&gt;&gt;(this, &quot;focusModel&quot;);
 510         }
 511         return focusModel;
 512     }
 513 
 514 
 515     // --- Orientation
 516     private ObjectProperty&lt;Orientation&gt; orientation;
 517 
 518     /**
 519      * Sets the orientation of the ListView, which dictates whether
 520      * it scrolls vertically or horizontally.
 521      * @param value the orientation of the ListView
 522      */
 523     public final void setOrientation(Orientation value) {
 524         orientationProperty().set(value);
 525     };
 526 
 527     /**
 528      * Returns the current orientation of the ListView, which dictates whether
 529      * it scrolls vertically or horizontally.
 530      * @return the current orientation of the ListView
 531      */
 532     public final Orientation getOrientation() {
 533         return orientation == null ? Orientation.VERTICAL : orientation.get();
 534     }
 535 
 536     /**
 537      * The orientation of the {@code ListView} - this can either be horizontal
 538      * or vertical.
 539      * @return the orientation property of this ListView
 540      */
 541     public final ObjectProperty&lt;Orientation&gt; orientationProperty() {
 542         if (orientation == null) {
 543             orientation = new StyleableObjectProperty&lt;Orientation&gt;(Orientation.VERTICAL) {
 544                 @Override public void invalidated() {
 545                     final boolean active = (get() == Orientation.VERTICAL);
 546                     pseudoClassStateChanged(PSEUDO_CLASS_VERTICAL,    active);
 547                     pseudoClassStateChanged(PSEUDO_CLASS_HORIZONTAL, !active);
 548                 }
 549 
 550                 @Override
 551                 public CssMetaData&lt;ListView&lt;?&gt;,Orientation&gt; getCssMetaData() {
 552                     return ListView.StyleableProperties.ORIENTATION;
 553                 }
 554 
 555                 @Override
 556                 public Object getBean() {
 557                     return ListView.this;
 558                 }
 559 
 560                 @Override
 561                 public String getName() {
 562                     return &quot;orientation&quot;;
 563                 }
 564             };
 565         }
 566         return orientation;
 567     }
 568 
 569 
 570 
 571 
 572     // --- Cell Factory
 573     private ObjectProperty&lt;Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt;&gt; cellFactory;
 574 
 575     /**
 576      * Sets a new cell factory to use in the ListView. This forces all old
 577      * {@link ListCell}&#39;s to be thrown away, and new ListCell&#39;s created with
 578      * the new cell factory.
 579      * @param value cell factory to use in this ListView
 580      */
 581     public final void setCellFactory(Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt; value) {
 582         cellFactoryProperty().set(value);
 583     }
 584 
 585     /**
 586      * Returns the current cell factory.
 587      * @return the current cell factory
 588      */
 589     public final Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt; getCellFactory() {
 590         return cellFactory == null ? null : cellFactory.get();
 591     }
 592 
 593     /**
 594      * &lt;p&gt;Setting a custom cell factory has the effect of deferring all cell
 595      * creation, allowing for total customization of the cell. Internally, the
 596      * ListView is responsible for reusing ListCells - all that is necessary
 597      * is for the custom cell factory to return from this function a ListCell
 598      * which might be usable for representing any item in the ListView.
 599      *
 600      * &lt;p&gt;Refer to the {@link Cell} class documentation for more detail.
 601      * @return the cell factory property
 602      */
 603     public final ObjectProperty&lt;Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt;&gt; cellFactoryProperty() {
 604         if (cellFactory == null) {
 605             cellFactory = new SimpleObjectProperty&lt;Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt;&gt;(this, &quot;cellFactory&quot;);
 606         }
 607         return cellFactory;
 608     }
 609 
 610 
 611     // --- Fixed cell size
 612     private DoubleProperty fixedCellSize;
 613 
 614     /**
 615      * Sets the new fixed cell size for this control. Any value greater than
 616      * zero will enable fixed cell size mode, whereas a zero or negative value
 617      * (or Region.USE_COMPUTED_SIZE) will be used to disabled fixed cell size
 618      * mode.
 619      *
 620      * @param value The new fixed cell size value, or a value less than or equal
 621      *              to zero (or Region.USE_COMPUTED_SIZE) to disable.
 622      * @since JavaFX 8.0
 623      */
 624     public final void setFixedCellSize(double value) {
 625         fixedCellSizeProperty().set(value);
 626     }
 627 
 628     /**
 629      * Returns the fixed cell size value. A value less than or equal to zero is
 630      * used to represent that fixed cell size mode is disabled, and a value
 631      * greater than zero represents the size of all cells in this control.
 632      *
 633      * @return A double representing the fixed cell size of this control, or a
 634      *      value less than or equal to zero if fixed cell size mode is disabled.
 635      * @since JavaFX 8.0
 636      */
 637     public final double getFixedCellSize() {
 638         return fixedCellSize == null ? Region.USE_COMPUTED_SIZE : fixedCellSize.get();
 639     }
 640     /**
 641      * Specifies whether this control has cells that are a fixed height (of the
 642      * specified value). If this value is less than or equal to zero,
 643      * then all cells are individually sized and positioned. This is a slow
 644      * operation. Therefore, when performance matters and developers are not
 645      * dependent on variable cell sizes it is a good idea to set the fixed cell
 646      * size value. Generally cells are around 24px, so setting a fixed cell size
 647      * of 24 is likely to result in very little difference in visuals, but a
 648      * improvement to performance.
 649      *
 650      * &lt;p&gt;To set this property via CSS, use the -fx-fixed-cell-size property.
 651      * This should not be confused with the -fx-cell-size property. The difference
 652      * between these two CSS properties is that -fx-cell-size will size all
 653      * cells to the specified size, but it will not enforce that this is the
 654      * only size (thus allowing for variable cell sizes, and preventing the
 655      * performance gains from being possible). Therefore, when performance matters
 656      * use -fx-fixed-cell-size, instead of -fx-cell-size. If both properties are
 657      * specified in CSS, -fx-fixed-cell-size takes precedence.&lt;/p&gt;
 658      *
 659      * @return the fixed cell size property
 660      * @since JavaFX 8.0
 661      */
 662     public final DoubleProperty fixedCellSizeProperty() {
 663         if (fixedCellSize == null) {
 664             fixedCellSize = new StyleableDoubleProperty(Region.USE_COMPUTED_SIZE) {
 665                 @Override public CssMetaData&lt;ListView&lt;?&gt;,Number&gt; getCssMetaData() {
 666                     return StyleableProperties.FIXED_CELL_SIZE;
 667                 }
 668 
 669                 @Override public Object getBean() {
 670                     return ListView.this;
 671                 }
 672 
 673                 @Override public String getName() {
 674                     return &quot;fixedCellSize&quot;;
 675                 }
 676             };
 677         }
 678         return fixedCellSize;
 679     }
 680 
 681 
 682     // --- Editable
 683     private BooleanProperty editable;
 684     public final void setEditable(boolean value) {
 685         editableProperty().set(value);
 686     }
 687     public final boolean isEditable() {
 688         return editable == null ? false : editable.get();
 689     }
 690     /**
 691      * Specifies whether this ListView is editable - only if the ListView and
 692      * the ListCells within it are both editable will a ListCell be able to go
 693      * into their editing state.
 694      * @return the editable property
 695      */
 696     public final BooleanProperty editableProperty() {
 697         if (editable == null) {
 698             editable = new SimpleBooleanProperty(this, &quot;editable&quot;, false);
 699         }
 700         return editable;
 701     }
 702 
 703 
 704     // --- Editing Index
 705     private ReadOnlyIntegerWrapper editingIndex;
 706 
 707     private void setEditingIndex(int value) {
 708         editingIndexPropertyImpl().set(value);
 709     }
 710 
 711     /**
 712      * Returns the index of the item currently being edited in the ListView,
 713      * or -1 if no item is being edited.
 714      * @return the index of the item currently being edited
 715      */
 716     public final int getEditingIndex() {
 717         return editingIndex == null ? -1 : editingIndex.get();
 718     }
 719 
 720     /**
 721      * &lt;p&gt;A property used to represent the index of the item currently being edited
 722      * in the ListView, if editing is taking place, or -1 if no item is being edited.
 723      *
 724      * &lt;p&gt;It is not possible to set the editing index, instead it is required that
 725      * you call {@link #edit(int)}.
 726      * @return the editing index property
 727      */
 728     public final ReadOnlyIntegerProperty editingIndexProperty() {
 729         return editingIndexPropertyImpl().getReadOnlyProperty();
 730     }
 731 
 732     private ReadOnlyIntegerWrapper editingIndexPropertyImpl() {
 733         if (editingIndex == null) {
 734             editingIndex = new ReadOnlyIntegerWrapper(this, &quot;editingIndex&quot;, -1);
 735         }
 736         return editingIndex;
 737     }
 738 
 739 
 740     // --- On Edit Start
 741     private ObjectProperty&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt; onEditStart;
 742 
 743     /**
 744      * Sets the {@link EventHandler} that will be called when the user begins
 745      * an edit.
 746      *
 747      * &lt;p&gt;This is a convenience method - the same result can be
 748      * achieved by calling
 749      * &lt;code&gt;addEventHandler(ListView.EDIT_START_EVENT, eventHandler)&lt;/code&gt;.
 750      * @param value the EventHandler that will be called when the user begins
 751      * an edit
 752      */
 753     public final void setOnEditStart(EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt; value) {
 754         onEditStartProperty().set(value);
 755     }
 756 
 757     /**
 758      * Returns the {@link EventHandler} that will be called when the user begins
 759      * an edit.
 760      * @return the EventHandler that will be called when the user begins an edit
 761      */
 762     public final EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt; getOnEditStart() {
 763         return onEditStart == null ? null : onEditStart.get();
 764     }
 765 
 766     /**
 767      * This event handler will be fired when the user successfully initiates
 768      * editing.
 769      * @return the onEditStart event handler property
 770      */
 771     public final ObjectProperty&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt; onEditStartProperty() {
 772         if (onEditStart == null) {
 773             onEditStart = new ObjectPropertyBase&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt;() {
 774                 @Override protected void invalidated() {
 775                     setEventHandler(ListView.&lt;T&gt;editStartEvent(), get());
 776                 }
 777 
 778                 @Override
 779                 public Object getBean() {
 780                     return ListView.this;
 781                 }
 782 
 783                 @Override
 784                 public String getName() {
 785                     return &quot;onEditStart&quot;;
 786                 }
 787             };
 788         }
 789         return onEditStart;
 790     }
 791 
 792 
 793     // --- On Edit Commit
 794     private ObjectProperty&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt; onEditCommit;
 795 
 796     /**
 797      * Sets the {@link EventHandler} that will be called when the user has
 798      * completed their editing. This is called as part of the
 799      * {@link ListCell#commitEdit(java.lang.Object)} method.
 800      *
 801      * &lt;p&gt;This is a convenience method - the same result can be
 802      * achieved by calling
 803      * &lt;code&gt;addEventHandler(ListView.EDIT_START_EVENT, eventHandler)&lt;/code&gt;.
 804      * @param value the EventHandler that will be called when the user has
 805      * completed their editing
 806      */
 807     public final void setOnEditCommit(EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt; value) {
 808         onEditCommitProperty().set(value);
 809     }
 810 
 811     /**
 812      * Returns the {@link EventHandler} that will be called when the user commits
 813      * an edit.
 814      * @return the EventHandler that will be called when the user commits an edit
 815      */
 816     public final EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt; getOnEditCommit() {
 817         return onEditCommit == null ? null : onEditCommit.get();
 818     }
 819 
 820     /**
 821      * &lt;p&gt;This property is used when the user performs an action that should
 822      * result in their editing input being persisted.&lt;/p&gt;
 823      *
 824      * &lt;p&gt;The EventHandler in this property should not be called directly -
 825      * instead call {@link ListCell#commitEdit(java.lang.Object)} from within
 826      * your custom ListCell. This will handle firing this event, updating the
 827      * view, and switching out of the editing state.&lt;/p&gt;
 828      * @return the onEditCommit event handler property
 829      */
 830     public final ObjectProperty&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt; onEditCommitProperty() {
 831         if (onEditCommit == null) {
 832             onEditCommit = new ObjectPropertyBase&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt;() {
 833                 @Override protected void invalidated() {
 834                     setEventHandler(ListView.&lt;T&gt;editCommitEvent(), get());
 835                 }
 836 
 837                 @Override
 838                 public Object getBean() {
 839                     return ListView.this;
 840                 }
 841 
 842                 @Override
 843                 public String getName() {
 844                     return &quot;onEditCommit&quot;;
 845                 }
 846             };
 847         }
 848         return onEditCommit;
 849     }
 850 
 851 
 852     // --- On Edit Cancel
 853     private ObjectProperty&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt; onEditCancel;
 854 
 855     /**
 856      * Sets the {@link EventHandler} that will be called when the user cancels
 857      * an edit.
 858      * @param value the EventHandler that will be called when the user cancels
 859      * an edit
 860      */
 861     public final void setOnEditCancel(EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt; value) {
 862         onEditCancelProperty().set(value);
 863     }
 864 
 865     /**
 866      * Returns the {@link EventHandler} that will be called when the user cancels
 867      * an edit.
 868      * @return the EventHandler that will be called when the user cancels an edit
 869      */
 870     public final EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt; getOnEditCancel() {
 871         return onEditCancel == null ? null : onEditCancel.get();
 872     }
 873 
 874     /**
 875      * This event handler will be fired when the user cancels editing a cell.
 876      * @return the onEditCancel event handler property
 877      */
 878     public final ObjectProperty&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt; onEditCancelProperty() {
 879         if (onEditCancel == null) {
 880             onEditCancel = new ObjectPropertyBase&lt;EventHandler&lt;ListView.EditEvent&lt;T&gt;&gt;&gt;() {
 881                 @Override protected void invalidated() {
 882                     setEventHandler(ListView.&lt;T&gt;editCancelEvent(), get());
 883                 }
 884 
 885                 @Override
 886                 public Object getBean() {
 887                     return ListView.this;
 888                 }
 889 
 890                 @Override
 891                 public String getName() {
 892                     return &quot;onEditCancel&quot;;
 893                 }
 894             };
 895         }
 896         return onEditCancel;
 897     }
 898 
 899 
 900 
 901 
 902     /***************************************************************************
 903      *                                                                         *
 904      * Public API                                                              *
 905      *                                                                         *
 906      **************************************************************************/
 907 
 908     /**
 909      * Instructs the ListView to begin editing the item in the given index, if
 910      * the ListView is {@link #editableProperty() editable}. Once
 911      * this method is called, if the current {@link #cellFactoryProperty()} is
 912      * set up to support editing, the Cell will switch its visual state to enable
 913      * for user input to take place.
 914      *
 915      * @param itemIndex The index of the item in the ListView that should be
 916      *     edited.
 917      */
 918     public void edit(int itemIndex) {
 919         if (!isEditable()) return;
 920         setEditingIndex(itemIndex);
 921     }
 922 
 923     /**
 924      * Scrolls the ListView such that the item in the given index is visible to
 925      * the end user.
 926      *
 927      * @param index The index that should be made visible to the user, assuming
 928      *      of course that it is greater than, or equal to 0, and less than the
 929      *      size of the items list contained within the given ListView.
 930      */
 931     public void scrollTo(int index) {
 932         ControlUtils.scrollToIndex(this, index);
 933     }
 934 
 935     /**
 936      * Scrolls the ListView so that the given object is visible within the viewport.
 937      * @param object The object that should be visible to the user.
 938      * @since JavaFX 8.0
 939      */
 940     public void scrollTo(T object) {
 941         if( getItems() != null ) {
 942             int idx = getItems().indexOf(object);
 943             if( idx &gt;= 0 ) {
 944                 ControlUtils.scrollToIndex(this, idx);
 945             }
 946         }
 947     }
 948 
 949     /**
 950      * Called when there&#39;s a request to scroll an index into view using {@link #scrollTo(int)}
 951      * or {@link #scrollTo(Object)}
 952      * @since JavaFX 8.0
 953      */
 954     private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollTo;
 955 
 956     public void setOnScrollTo(EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; value) {
 957         onScrollToProperty().set(value);
 958     }
 959 
 960     public EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; getOnScrollTo() {
 961         if( onScrollTo != null ) {
 962             return onScrollTo.get();
 963         }
 964         return null;
 965     }
 966 
 967     public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollToProperty() {
 968         if( onScrollTo == null ) {
 969             onScrollTo = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt;() {
 970                 @Override protected void invalidated() {
 971                     setEventHandler(ScrollToEvent.scrollToTopIndex(), get());
 972                 }
 973 
 974                 @Override public Object getBean() {
 975                     return ListView.this;
 976                 }
 977 
 978                 @Override public String getName() {
 979                     return &quot;onScrollTo&quot;;
 980                 }
 981             };
 982         }
 983         return onScrollTo;
 984     }
 985 
 986     /** {@inheritDoc} */
 987     @Override protected Skin&lt;?&gt; createDefaultSkin() {
 988         return new ListViewSkin&lt;T&gt;(this);
 989     }
 990 
 991     /**
 992      * Calling {@code refresh()} forces the ListView control to recreate and
 993      * repopulate the cells necessary to populate the visual bounds of the control.
 994      * In other words, this forces the ListView to update what it is showing to
 995      * the user. This is useful in cases where the underlying data source has
 996      * changed in a way that is not observed by the ListView itself.
 997      *
 998      * @since JavaFX 8u60
 999      */
1000     public void refresh() {
1001         getProperties().put(Properties.RECREATE, Boolean.TRUE);
1002     }
1003 
1004 
1005 
1006     /***************************************************************************
1007      *                                                                         *
1008      * Private Implementation                                                  *
1009      *                                                                         *
1010      **************************************************************************/
1011 
1012 
1013 
1014     /***************************************************************************
1015      *                                                                         *
1016      * Stylesheet Handling                                                     *
1017      *                                                                         *
1018      **************************************************************************/
1019 
1020     private static final String DEFAULT_STYLE_CLASS = &quot;list-view&quot;;
1021 
1022     private static class StyleableProperties {
1023         private static final CssMetaData&lt;ListView&lt;?&gt;,Orientation&gt; ORIENTATION =
1024             new CssMetaData&lt;ListView&lt;?&gt;,Orientation&gt;(&quot;-fx-orientation&quot;,
1025                 new EnumConverter&lt;Orientation&gt;(Orientation.class),
1026                 Orientation.VERTICAL) {
1027 
1028             @Override
1029             public Orientation getInitialValue(ListView&lt;?&gt; node) {
1030                 // A vertical ListView should remain vertical
1031                 return node.getOrientation();
1032             }
1033 
1034             @Override
1035             public boolean isSettable(ListView&lt;?&gt; n) {
1036                 return n.orientation == null || !n.orientation.isBound();
1037             }
1038 
1039             @SuppressWarnings(&quot;unchecked&quot;) // orientationProperty() is a StyleableProperty&lt;Orientation&gt;
1040             @Override
1041             public StyleableProperty&lt;Orientation&gt; getStyleableProperty(ListView&lt;?&gt; n) {
1042                 return (StyleableProperty&lt;Orientation&gt;)n.orientationProperty();
1043             }
1044         };
1045 
1046         private static final CssMetaData&lt;ListView&lt;?&gt;,Number&gt; FIXED_CELL_SIZE =
1047             new CssMetaData&lt;ListView&lt;?&gt;,Number&gt;(&quot;-fx-fixed-cell-size&quot;,
1048                                                 SizeConverter.getInstance(),
1049                                                 Region.USE_COMPUTED_SIZE) {
1050 
1051                 @Override public Double getInitialValue(ListView&lt;?&gt; node) {
1052                     return node.getFixedCellSize();
1053                 }
1054 
1055                 @Override public boolean isSettable(ListView&lt;?&gt; n) {
1056                     return n.fixedCellSize == null || !n.fixedCellSize.isBound();
1057                 }
1058 
1059                 @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(ListView&lt;?&gt; n) {
1060                     return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)n.fixedCellSizeProperty();
1061                 }
1062             };
1063 
1064         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
1065         static {
1066             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1067                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
1068             styleables.add(ORIENTATION);
1069             styleables.add(FIXED_CELL_SIZE);
1070             STYLEABLES = Collections.unmodifiableList(styleables);
1071         }
1072     }
1073 
1074     /**
1075      * @return The CssMetaData associated with this class, which may include the
1076      * CssMetaData of its superclasses.
1077      * @since JavaFX 8.0
1078      */
1079     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1080         return StyleableProperties.STYLEABLES;
1081     }
1082 
1083     /**
1084      * {@inheritDoc}
1085      * @since JavaFX 8.0
1086      */
1087     @Override
1088     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
1089         return getClassCssMetaData();
1090     }
1091 
1092     private static final PseudoClass PSEUDO_CLASS_VERTICAL =
1093             PseudoClass.getPseudoClass(&quot;vertical&quot;);
1094     private static final PseudoClass PSEUDO_CLASS_HORIZONTAL =
1095             PseudoClass.getPseudoClass(&quot;horizontal&quot;);
1096 
1097 
1098 
1099     /***************************************************************************
1100      *                                                                         *
1101      * Accessibility handling                                                  *
1102      *                                                                         *
1103      **************************************************************************/
1104 
1105     /** {@inheritDoc} */
1106     @Override
1107     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1108         switch (attribute) {
1109             case MULTIPLE_SELECTION: {
1110                 MultipleSelectionModel&lt;T&gt; sm = getSelectionModel();
1111                 return sm != null &amp;&amp; sm.getSelectionMode() == SelectionMode.MULTIPLE;
1112             }
1113             default: return super.queryAccessibleAttribute(attribute, parameters);
1114         }
1115     }
1116 
1117 
1118     /***************************************************************************
1119      *                                                                         *
1120      * Support Interfaces                                                      *
1121      *                                                                         *
1122      **************************************************************************/
1123 
1124 
1125 
1126     /***************************************************************************
1127      *                                                                         *
1128      * Support Classes                                                         *
1129      *                                                                         *
1130      **************************************************************************/
1131 
1132     /**
1133      * An {@link Event} subclass used specifically in ListView for representing
1134      * edit-related events. It provides additional API to easily access the
1135      * index that the edit event took place on, as well as the input provided
1136      * by the end user.
1137      *
1138      * @param &lt;T&gt; The type of the input, which is the same type as the ListView
1139      *      itself.
1140      * @since JavaFX 2.0
1141      */
1142     public static class EditEvent&lt;T&gt; extends Event {
1143         private final T newValue;
1144         private final int editIndex;
1145         private final ListView&lt;T&gt; source;
1146 
1147         private static final long serialVersionUID = 20130724L;
1148 
1149         /**
1150          * Common supertype for all edit event types.
1151          * @since JavaFX 8.0
1152          */
1153         public static final EventType&lt;?&gt; ANY = EDIT_ANY_EVENT;
1154 
1155         /**
1156          * Creates a new EditEvent instance to represent an edit event. This
1157          * event is used for {@link #editStartEvent()},
1158          * {@link #editCommitEvent()} and {@link #editCancelEvent()} types.
1159          * @param source the source
1160          * @param eventType the event type
1161          * @param newValue the new value
1162          * @param editIndex the edit index
1163          */
1164         public EditEvent(ListView&lt;T&gt; source,
1165                          EventType&lt;? extends ListView.EditEvent&lt;T&gt;&gt; eventType,
1166                          T newValue,
1167                          int editIndex) {
1168             super(source, Event.NULL_SOURCE_TARGET, eventType);
1169             this.source = source;
1170             this.editIndex = editIndex;
1171             this.newValue = newValue;
1172         }
1173 
1174         /**
1175          * Returns the ListView upon which the edit took place.
1176          */
1177         @Override public ListView&lt;T&gt; getSource() {
1178             return source;
1179         }
1180 
1181         /**
1182          * Returns the index in which the edit took place.
1183          * @return the index in which the edit took place
1184          */
1185         public int getIndex() {
1186             return editIndex;
1187         }
1188 
1189         /**
1190          * Returns the value of the new input provided by the end user.
1191          * @return the value of the new input provided by the end user
1192          */
1193         public T getNewValue() {
1194             return newValue;
1195         }
1196 
1197         /**
1198          * Returns a string representation of this {@code EditEvent} object.
1199          * @return a string representation of this {@code EditEvent} object.
1200          */
1201         @Override public String toString() {
1202             return &quot;ListViewEditEvent [ newValue: &quot; + getNewValue() + &quot;, ListView: &quot; + getSource() + &quot; ]&quot;;
1203         }
1204     }
1205 
1206 
1207 
1208     // package for testing
1209     static class ListViewBitSetSelectionModel&lt;T&gt; extends MultipleSelectionModelBase&lt;T&gt; {
1210 
1211         /***********************************************************************
1212          *                                                                     *
1213          * Constructors                                                        *
1214          *                                                                     *
1215          **********************************************************************/
1216 
1217         public ListViewBitSetSelectionModel(final ListView&lt;T&gt; listView) {
1218             if (listView == null) {
1219                 throw new IllegalArgumentException(&quot;ListView can not be null&quot;);
1220             }
1221 
1222             this.listView = listView;
1223 
1224             ((SelectedItemsReadOnlyObservableList)getSelectedItems()).setItemsList(listView.getItems());
1225 
1226 
1227             /*
1228              * The following two listeners are used in conjunction with
1229              * SelectionModel.select(T obj) to allow for a developer to select
1230              * an item that is not actually in the data model. When this occurs,
1231              * we actively try to find an index that matches this object, going
1232              * so far as to actually watch for all changes to the items list,
1233              * rechecking each time.
1234              */
1235             itemsObserver = new InvalidationListener() {
1236                 private WeakReference&lt;ObservableList&lt;T&gt;&gt; weakItemsRef = new WeakReference&lt;&gt;(listView.getItems());
1237 
1238                 @Override public void invalidated(Observable observable) {
1239                     ObservableList&lt;T&gt; oldItems = weakItemsRef.get();
1240                     weakItemsRef = new WeakReference&lt;&gt;(listView.getItems());
1241                     ((SelectedItemsReadOnlyObservableList)getSelectedItems()).setItemsList(listView.getItems());
1242                     updateItemsObserver(oldItems, listView.getItems());
1243                 }
1244             };
1245 
1246             this.listView.itemsProperty().addListener(new WeakInvalidationListener(itemsObserver));
1247             if (listView.getItems() != null) {
1248                 this.listView.getItems().addListener(weakItemsContentObserver);
1249             }
1250 
1251             updateItemCount();
1252 
1253             updateDefaultSelection();
1254         }
1255 
1256         // watching for changes to the items list content
1257         private final ListChangeListener&lt;T&gt; itemsContentObserver = new ListChangeListener&lt;T&gt;() {
1258             @Override public void onChanged(Change&lt;? extends T&gt; c) {
1259                 updateItemCount();
1260 
1261                 boolean doSelectionUpdate = true;
1262 
1263                 while (c.next()) {
1264                     final T selectedItem = getSelectedItem();
1265                     final int selectedIndex = getSelectedIndex();
1266 
1267                     if (listView.getItems() == null || listView.getItems().isEmpty()) {
1268                         selectedItemChange = c;
1269                         clearSelection();
1270                         selectedItemChange = null;
1271                     } else if (selectedIndex == -1 &amp;&amp; selectedItem != null) {
1272                         int newIndex = listView.getItems().indexOf(selectedItem);
1273                         if (newIndex != -1) {
1274                             setSelectedIndex(newIndex);
1275                             doSelectionUpdate = false;
1276                         }
1277                     } else if (c.wasRemoved() &amp;&amp;
1278                             c.getRemovedSize() == 1 &amp;&amp;
1279                             ! c.wasAdded() &amp;&amp;
1280                             selectedItem != null &amp;&amp;
1281                             selectedItem.equals(c.getRemoved().get(0))) {
1282                         // Bug fix for RT-28637
1283                         if (getSelectedIndex() &lt; getItemCount()) {
1284                             final int previousRow = selectedIndex == 0 ? 0 : selectedIndex - 1;
1285                             T newSelectedItem = getModelItem(previousRow);
1286                             if (! selectedItem.equals(newSelectedItem)) {
1287                                 startAtomic();
1288                                 clearSelection(selectedIndex);
1289                                 stopAtomic();
1290                                 select(newSelectedItem);
1291                             }
1292                         }
1293                     }
1294                 }
1295 
1296                 if (doSelectionUpdate) {
1297                     updateSelection(c);
1298                 }
1299             }
1300         };
1301 
1302         // watching for changes to the items list
1303         private final InvalidationListener itemsObserver;
1304 
1305         private WeakListChangeListener&lt;T&gt; weakItemsContentObserver =
1306                 new WeakListChangeListener&lt;&gt;(itemsContentObserver);
1307 
1308 
1309 
1310 
1311         /***********************************************************************
1312          *                                                                     *
1313          * Internal properties                                                 *
1314          *                                                                     *
1315          **********************************************************************/
1316 
1317         private final ListView&lt;T&gt; listView;
1318 
1319         private int itemCount = 0;
1320 
1321         private int previousModelSize = 0;
1322 
1323         // Listen to changes in the listview items list, such that when it
1324         // changes we can update the selected indices bitset to refer to the
1325         // new indices.
1326         // At present this is basically a left/right shift operation, which
1327         // seems to work ok.
1328         private void updateSelection(Change&lt;? extends T&gt; c) {
1329 //            // debugging output
1330 //            System.out.println(listView.getId());
1331 //            if (c.wasAdded()) {
1332 //                System.out.println(&quot;\tAdded size: &quot; + c.getAddedSize() + &quot;, Added sublist: &quot; + c.getAddedSubList());
1333 //            }
1334 //            if (c.wasRemoved()) {
1335 //                System.out.println(&quot;\tRemoved size: &quot; + c.getRemovedSize() + &quot;, Removed sublist: &quot; + c.getRemoved());
1336 //            }
1337 //            if (c.wasReplaced()) {
1338 //                System.out.println(&quot;\tWas replaced&quot;);
1339 //            }
1340 //            if (c.wasPermutated()) {
1341 //                System.out.println(&quot;\tWas permutated&quot;);
1342 //            }
1343             c.reset();
1344 
1345             List&lt;Pair&lt;Integer, Integer&gt;&gt; shifts = new ArrayList&lt;&gt;();
1346             while (c.next()) {
1347                 if (c.wasReplaced()) {
1348                     if (c.getList().isEmpty()) {
1349                         // the entire items list was emptied - clear selection
1350                         clearSelection();
1351                     } else {
1352                         int index = getSelectedIndex();
1353 
1354                         if (previousModelSize == c.getRemovedSize()) {
1355                             // all items were removed from the model
1356                             clearSelection();
1357                         } else if (index &lt; getItemCount() &amp;&amp; index &gt;= 0) {
1358                             // Fix for RT-18969: the list had setAll called on it
1359                             // Use of makeAtomic is a fix for RT-20945
1360                             startAtomic();
1361                             clearSelection(index);
1362                             stopAtomic();
1363                             select(index);
1364                         } else {
1365                             // Fix for RT-22079
1366                             clearSelection();
1367                         }
1368                     }
1369                 } else if (c.wasAdded() || c.wasRemoved()) {
1370                     int shift = c.wasAdded() ? c.getAddedSize() : -c.getRemovedSize();
1371                     shifts.add(new Pair&lt;&gt;(c.getFrom(), shift));
1372                 } else if (c.wasPermutated()) {
1373 
1374                     // General approach:
1375                     //   -- detected a sort has happened
1376                     //   -- Create a permutation lookup map (1)
1377                     //   -- dump all the selected indices into a list (2)
1378                     //   -- clear the selected items / indexes (3)
1379                     //   -- create a list containing the new indices (4)
1380                     //   -- for each previously-selected index (5)
1381                     //     -- if index is in the permutation lookup map
1382                     //       -- add the new index to the new indices list
1383                     //   -- Perform batch selection (6)
1384 
1385                     // (1)
1386                     int length = c.getTo() - c.getFrom();
1387                     HashMap&lt;Integer, Integer&gt; pMap = new HashMap&lt;Integer, Integer&gt;(length);
1388                     for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
1389                         pMap.put(i, c.getPermutation(i));
1390                     }
1391 
1392                     // (2)
1393                     List&lt;Integer&gt; selectedIndices = new ArrayList&lt;Integer&gt;(getSelectedIndices());
1394 
1395 
1396                     // (3)
1397                     clearSelection();
1398 
1399                     // (4)
1400                     List&lt;Integer&gt; newIndices = new ArrayList&lt;Integer&gt;(getSelectedIndices().size());
1401 
1402                     // (5)
1403                     for (int i = 0; i &lt; selectedIndices.size(); i++) {
1404                         int oldIndex = selectedIndices.get(i);
1405 
1406                         if (pMap.containsKey(oldIndex)) {
1407                             Integer newIndex = pMap.get(oldIndex);
1408                             newIndices.add(newIndex);
1409                         }
1410                     }
1411 
1412                     // (6)
1413                     if (!newIndices.isEmpty()) {
1414                         if (newIndices.size() == 1) {
1415                             select(newIndices.get(0));
1416                         } else {
1417                             int[] ints = new int[newIndices.size() - 1];
1418                             for (int i = 0; i &lt; newIndices.size() - 1; i++) {
1419                                 ints[i] = newIndices.get(i + 1);
1420                             }
1421                             selectIndices(newIndices.get(0), ints);
1422                         }
1423                     }
1424                 }
1425             }
1426 
1427             if (!shifts.isEmpty()) {
1428                 shiftSelection(shifts, null);
1429             }
1430 
1431             previousModelSize = getItemCount();
1432         }
1433 
1434 
1435 
1436         /***********************************************************************
1437          *                                                                     *
1438          * Public selection API                                                *
1439          *                                                                     *
1440          **********************************************************************/
1441 
1442         /** {@inheritDoc} */
1443         @Override public void selectAll() {
1444             // when a selectAll happens, the anchor should not change, so we store it
1445             // before, and restore it afterwards
1446             final int anchor = ListCellBehavior.getAnchor(listView, -1);
1447             super.selectAll();
1448             ListCellBehavior.setAnchor(listView, anchor, false);
1449         }
1450 
1451         /** {@inheritDoc} */
1452         @Override public void clearAndSelect(int row) {
1453             ListCellBehavior.setAnchor(listView, row, false);
1454             super.clearAndSelect(row);
1455         }
1456 
1457         /** {@inheritDoc} */
1458         @Override protected void focus(int row) {
1459             if (listView.getFocusModel() == null) return;
1460             listView.getFocusModel().focus(row);
1461 
1462             listView.notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
1463         }
1464 
1465         /** {@inheritDoc} */
1466         @Override protected int getFocusedIndex() {
1467             if (listView.getFocusModel() == null) return -1;
1468             return listView.getFocusModel().getFocusedIndex();
1469         }
1470 
1471         @Override protected int getItemCount() {
1472             return itemCount;
1473         }
1474 
1475         @Override protected T getModelItem(int index) {
1476             List&lt;T&gt; items = listView.getItems();
1477             if (items == null) return null;
1478             if (index &lt; 0 || index &gt;= itemCount) return null;
1479 
1480             return items.get(index);
1481         }
1482 
1483 
1484 
1485         /***********************************************************************
1486          *                                                                     *
1487          * Private implementation                                              *
1488          *                                                                     *
1489          **********************************************************************/
1490 
1491         private void updateItemCount() {
1492             if (listView == null) {
1493                 itemCount = -1;
1494             } else {
1495                 List&lt;T&gt; items = listView.getItems();
1496                 itemCount = items == null ? -1 : items.size();
1497             }
1498         }
1499 
1500         private void updateItemsObserver(ObservableList&lt;T&gt; oldList, ObservableList&lt;T&gt; newList) {
1501             // update listeners
1502             if (oldList != null) {
1503                 oldList.removeListener(weakItemsContentObserver);
1504             }
1505             if (newList != null) {
1506                 newList.addListener(weakItemsContentObserver);
1507             }
1508 
1509             updateItemCount();
1510             updateDefaultSelection();
1511         }
1512 
1513         private void updateDefaultSelection() {
1514             // when the items list totally changes, we should clear out
1515             // the selection and focus
1516             int newSelectionIndex = -1;
1517             int newFocusIndex = -1;
1518             if (listView.getItems() != null) {
1519                 T selectedItem = getSelectedItem();
1520                 if (selectedItem != null) {
1521                     newSelectionIndex = listView.getItems().indexOf(selectedItem);
1522                     newFocusIndex = newSelectionIndex;
1523                 }
1524 
1525                 // we put focus onto the first item, if there is at least
1526                 // one item in the list
1527                 if (listView.selectFirstRowByDefault &amp;&amp; newFocusIndex == -1) {
1528                     newFocusIndex = listView.getItems().size() &gt; 0 ? 0 : -1;
1529                 }
1530             }
1531 
1532             clearSelection();
1533             select(newSelectionIndex);
1534 //            focus(newFocusIndex);
1535         }
1536     }
1537 
1538 
1539 
1540     // package for testing
1541     static class ListViewFocusModel&lt;T&gt; extends FocusModel&lt;T&gt; {
1542 
1543         private final ListView&lt;T&gt; listView;
1544         private int itemCount = 0;
1545 
1546         public ListViewFocusModel(final ListView&lt;T&gt; listView) {
1547             if (listView == null) {
1548                 throw new IllegalArgumentException(&quot;ListView can not be null&quot;);
1549             }
1550 
1551             this.listView = listView;
1552 
1553             itemsObserver = new InvalidationListener() {
1554                 private WeakReference&lt;ObservableList&lt;T&gt;&gt; weakItemsRef = new WeakReference&lt;&gt;(listView.getItems());
1555 
1556                 @Override public void invalidated(Observable observable) {
1557                     ObservableList&lt;T&gt; oldItems = weakItemsRef.get();
1558                     weakItemsRef = new WeakReference&lt;&gt;(listView.getItems());
1559                     updateItemsObserver(oldItems, listView.getItems());
1560                 }
1561             };
1562             this.listView.itemsProperty().addListener(new WeakInvalidationListener(itemsObserver));
1563             if (listView.getItems() != null) {
1564                 this.listView.getItems().addListener(weakItemsContentListener);
1565             }
1566 
1567             updateItemCount();
1568             updateDefaultFocus();
1569 
1570             focusedIndexProperty().addListener(o -&gt; {
1571                 listView.notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
1572             });
1573         }
1574 
1575 
1576         private void updateItemsObserver(ObservableList&lt;T&gt; oldList, ObservableList&lt;T&gt; newList) {
1577             // the listview items list has changed, we need to observe
1578             // the new list, and remove any observer we had from the old list
1579             if (oldList != null) oldList.removeListener(weakItemsContentListener);
1580             if (newList != null) newList.addListener(weakItemsContentListener);
1581 
1582             updateItemCount();
1583             updateDefaultFocus();
1584         }
1585 
1586         private final InvalidationListener itemsObserver;
1587 
1588         // Listen to changes in the listview items list, such that when it
1589         // changes we can update the focused index to refer to the new indices.
1590         private final ListChangeListener&lt;T&gt; itemsContentListener = c -&gt; {
1591             updateItemCount();
1592 
1593             while (c.next()) {
1594                 // looking at the first change
1595                 int from = c.getFrom();
1596 
1597                 if (c.wasReplaced() || c.getAddedSize() == getItemCount()) {
1598                     updateDefaultFocus();
1599                     return;
1600                 }
1601 
1602                 if (getFocusedIndex() == -1 || from &gt; getFocusedIndex()) {
1603                     return;
1604                 }
1605 
1606                 c.reset();
1607                 boolean added = false;
1608                 boolean removed = false;
1609                 int addedSize = 0;
1610                 int removedSize = 0;
1611                 while (c.next()) {
1612                     added |= c.wasAdded();
1613                     removed |= c.wasRemoved();
1614                     addedSize += c.getAddedSize();
1615                     removedSize += c.getRemovedSize();
1616                 }
1617 
1618                 if (added &amp;&amp; !removed) {
1619                     focus(Math.min(getItemCount() - 1, getFocusedIndex() + addedSize));
1620                 } else if (!added &amp;&amp; removed) {
1621                     focus(Math.max(0, getFocusedIndex() - removedSize));
1622                 }
1623             }
1624         };
1625 
1626         private WeakListChangeListener&lt;T&gt; weakItemsContentListener
1627                 = new WeakListChangeListener&lt;T&gt;(itemsContentListener);
1628 
1629         @Override protected int getItemCount() {
1630             return itemCount;
1631         }
1632 
1633         @Override protected T getModelItem(int index) {
1634             if (isEmpty()) return null;
1635             if (index &lt; 0 || index &gt;= itemCount) return null;
1636 
1637             return listView.getItems().get(index);
1638         }
1639 
1640         private boolean isEmpty() {
1641             return itemCount == -1;
1642         }
1643 
1644         private void updateItemCount() {
1645             if (listView == null) {
1646                 itemCount = -1;
1647             } else {
1648                 List&lt;T&gt; items = listView.getItems();
1649                 itemCount = items == null ? -1 : items.size();
1650             }
1651         }
1652 
1653         private void updateDefaultFocus() {
1654             // when the items list totally changes, we should clear out
1655             // the focus
1656             int newValueIndex = -1;
1657             if (listView.getItems() != null) {
1658                 T focusedItem = getFocusedItem();
1659                 if (focusedItem != null) {
1660                     newValueIndex = listView.getItems().indexOf(focusedItem);
1661                 }
1662 
1663                 // we put focus onto the first item, if there is at least
1664                 // one item in the list
1665                 if (newValueIndex == -1) {
1666                     newValueIndex = listView.getItems().size() &gt; 0 ? 0 : -1;
1667                 }
1668             }
1669 
1670             focus(newValueIndex);
1671         }
1672     }
1673 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/skin/ProgressIndicatorSkin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javafx.scene.control.skin;
 27 
 28 import com.sun.javafx.scene.NodeHelper;
 29 import com.sun.javafx.scene.control.skin.Utils;
 30 import java.util.ArrayList;
 31 import java.util.Collections;
 32 import java.util.List;
<a name="1" id="anc1"></a>
 33 
 34 import javafx.animation.Animation;
 35 import javafx.animation.KeyFrame;
 36 import javafx.animation.KeyValue;
 37 import javafx.animation.Timeline;
 38 import javafx.beans.property.BooleanProperty;
 39 import javafx.beans.property.IntegerProperty;
 40 import javafx.beans.property.ObjectProperty;
<a name="2" id="anc2"></a>
 41 import javafx.beans.value.WritableValue;
 42 import javafx.collections.FXCollections;
 43 import javafx.collections.ObservableList;
 44 import javafx.geometry.NodeOrientation;
 45 import javafx.geometry.VPos;
 46 import javafx.scene.Node;
 47 import javafx.scene.control.Control;
 48 import javafx.scene.control.ProgressIndicator;
 49 import javafx.scene.control.SkinBase;
 50 import javafx.scene.layout.Pane;
 51 import javafx.scene.layout.Region;
 52 import javafx.scene.layout.StackPane;
 53 import javafx.scene.paint.Color;
 54 import javafx.scene.paint.Paint;
 55 import javafx.scene.shape.Arc;
 56 import javafx.scene.shape.ArcType;
 57 import javafx.scene.shape.Circle;
<a name="3" id="anc3"></a>
 58 import javafx.scene.text.Text;
 59 import javafx.scene.text.TextBoundsType;
 60 import javafx.scene.transform.Scale;
 61 import javafx.util.Duration;
 62 import javafx.css.CssMetaData;
 63 import javafx.css.StyleableObjectProperty;
 64 import javafx.css.StyleableProperty;
 65 import javafx.css.StyleableBooleanProperty;
 66 import javafx.css.StyleableIntegerProperty;
 67 import javafx.css.converter.BooleanConverter;
 68 import javafx.css.converter.PaintConverter;
 69 import javafx.css.converter.SizeConverter;
 70 import com.sun.javafx.scene.control.skin.resources.ControlResources;
 71 import javafx.css.Styleable;
 72 
 73 /**
 74  * Default skin implementation for the {@link ProgressIndicator} control.
 75  *
 76  * @see ProgressIndicator
 77  * @since 9
 78  */
 79 public class ProgressIndicatorSkin extends SkinBase&lt;ProgressIndicator&gt; {
 80 
 81     /***************************************************************************
 82      *                                                                         *
 83      * Static fields                                                           *
 84      *                                                                         *
 85      **************************************************************************/
 86 
 87 
 88 
 89     /***************************************************************************
 90      *                                                                         *
 91      * Private fields                                                          *
 92      *                                                                         *
 93      **************************************************************************/
 94 
 95     // JDK-8149818: This constant should not be static, because the
 96     // Locale may change between instances.
 97 
 98     /** DONE string is just used to know the size of Done as that is the biggest text we need to allow for */
 99     private final String DONE = ControlResources.getString(&quot;ProgressIndicator.doneString&quot;);
100 
101     final Duration CLIPPED_DELAY = new Duration(300);
102     final Duration UNCLIPPED_DELAY = new Duration(0);
103 
104     private IndeterminateSpinner spinner;
105     private DeterminateIndicator determinateIndicator;
106     private ProgressIndicator control;
107 
108     Animation indeterminateTransition;
109 
110 
111 
112     /***************************************************************************
113      *                                                                         *
114      * Constructors                                                            *
115      *                                                                         *
116      **************************************************************************/
117 
118     /**
119      * Creates a new ProgressIndicatorSkin instance, installing the necessary child
120      * nodes into the Control {@link Control#getChildren() children} list.
121      *
122      * @param control The control that this skin should be installed onto.
123      */
124     public ProgressIndicatorSkin(ProgressIndicator control) {
125         super(control);
126 
127         this.control = control;
128 
129         // register listeners
130         registerChangeListener(control.indeterminateProperty(), e -&gt; initialize());
131         registerChangeListener(control.progressProperty(), e -&gt; updateProgress());
132         registerChangeListener(NodeHelper.treeShowingProperty(control), e -&gt; updateAnimation());
133         registerChangeListener(control.sceneProperty(), e-&gt;updateAnimation());
134 
135         initialize();
136         updateAnimation();
137     }
138 
139 
140 
141     /***************************************************************************
142      *                                                                         *
143      * Properties                                                              *
144      *                                                                         *
145      **************************************************************************/
146 
147     /**
148      * The colour of the progress segment.
149      */
150     private ObjectProperty&lt;Paint&gt; progressColor = new StyleableObjectProperty&lt;Paint&gt;(null) {
151         @Override protected void invalidated() {
152             final Paint value = get();
153             if (value != null &amp;&amp; !(value instanceof Color)) {
154                 if (isBound()) {
155                     unbind();
156                 }
157                 set(null);
158                 throw new IllegalArgumentException(&quot;Only Color objects are supported&quot;);
159             }
160             if (spinner!=null) spinner.setFillOverride(value);
161             if (determinateIndicator!=null) determinateIndicator.setFillOverride(value);
162         }
163 
164         @Override public Object getBean() {
165             return ProgressIndicatorSkin.this;
166         }
167 
168         @Override public String getName() {
169             return &quot;progressColorProperty&quot;;
170         }
171 
172         @Override public CssMetaData&lt;ProgressIndicator,Paint&gt; getCssMetaData() {
173             return PROGRESS_COLOR;
174         }
175     };
176 
177     Paint getProgressColor() {
178         return progressColor.get();
179     }
180 
181     /**
182      * The number of segments in the spinner.
183      */
184     private IntegerProperty indeterminateSegmentCount = new StyleableIntegerProperty(8) {
185         @Override protected void invalidated() {
186             if (spinner!=null) spinner.rebuild();
187         }
188 
189         @Override public Object getBean() {
190             return ProgressIndicatorSkin.this;
191         }
192 
193         @Override public String getName() {
194             return &quot;indeterminateSegmentCount&quot;;
195         }
196 
197         @Override public CssMetaData&lt;ProgressIndicator,Number&gt; getCssMetaData() {
198             return INDETERMINATE_SEGMENT_COUNT;
199         }
200     };
201 
202     /**
203      * True if the progress indicator should rotate as well as animate opacity.
204      */
205     private final BooleanProperty spinEnabled = new StyleableBooleanProperty(false) {
206         @Override protected void invalidated() {
207             if (spinner!=null) spinner.setSpinEnabled(get());
208         }
209 
210         @Override public CssMetaData&lt;ProgressIndicator,Boolean&gt; getCssMetaData() {
211             return SPIN_ENABLED;
212         }
213 
214         @Override public Object getBean() {
215             return ProgressIndicatorSkin.this;
216         }
217 
218         @Override public String getName() {
219             return &quot;spinEnabled&quot;;
220         }
221     };
222 
223 
224 
225     /***************************************************************************
226      *                                                                         *
227      * Public API                                                              *
228      *                                                                         *
229      **************************************************************************/
230 
231     /** {@inheritDoc} */
232     @Override public void dispose() {
233         super.dispose();
234 
235         if (indeterminateTransition != null) {
236             indeterminateTransition.stop();
237             indeterminateTransition = null;
238         }
239 
240         if (spinner != null) {
241             spinner = null;
242         }
243 
244         control = null;
245     }
246 
247     /** {@inheritDoc} */
248     @Override protected void layoutChildren(final double x, final double y,
249                                             final double w, final double h) {
250         if (spinner != null &amp;&amp; control.isIndeterminate()) {
251             spinner.layoutChildren();
252             spinner.resizeRelocate(0, 0, w, h);
253         } else if (determinateIndicator != null) {
254             determinateIndicator.layoutChildren();
255             determinateIndicator.resizeRelocate(0, 0, w, h);
256         }
257     }
258 
259     /** {@inheritDoc} */
260     @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
261         double minWidth = 0.0;
262 
263         if (spinner != null &amp;&amp; control.isIndeterminate()) {
264             minWidth = spinner.minWidth(-1);
265         } else if (determinateIndicator != null) {
266             minWidth = determinateIndicator.minWidth(-1);
267         }
268         return minWidth;
269     }
270 
271     /** {@inheritDoc} */
272     @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
273         double minHeight = 0.0;
274 
275         if (spinner != null &amp;&amp; control.isIndeterminate()) {
276             minHeight = spinner.minHeight(-1);
277         } else if (determinateIndicator != null) {
278             minHeight = determinateIndicator.minHeight(-1);
279         }
280         return minHeight;
281     }
282 
283     /** {@inheritDoc} */
284     @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
285         double prefWidth = 0.0;
286 
287         if (spinner != null &amp;&amp; control.isIndeterminate()) {
288             prefWidth = spinner.prefWidth(height);
289         } else if (determinateIndicator != null) {
290             prefWidth = determinateIndicator.prefWidth(height);
291         }
292         return prefWidth;
293     }
294 
295    /** {@inheritDoc} */
296    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
297         double prefHeight = 0.0;
298 
299         if (spinner != null &amp;&amp; control.isIndeterminate()) {
300             prefHeight = spinner.prefHeight(width);
301         } else if (determinateIndicator != null) {
302             prefHeight = determinateIndicator.prefHeight(width);
303         }
304         return prefHeight;
305     }
306 
307     /** {@inheritDoc} */
308     @Override protected double computeMaxWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
309         return computePrefWidth(height, topInset, rightInset, bottomInset, leftInset);
310     }
311 
312     /** {@inheritDoc} */
313     @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
314         return computePrefHeight(width, topInset, rightInset, bottomInset, leftInset);
315     }
316 
317 
318     /***************************************************************************
319      *                                                                         *
320      * Private implementation                                                  *
321      *                                                                         *
322      **************************************************************************/
323 
324     void initialize() {
325         boolean isIndeterminate = control.isIndeterminate();
326         if (isIndeterminate) {
<a name="4" id="anc4"></a><span class="line-modified">327             // clean up determinateIndicator</span>



328             determinateIndicator = null;
329 
330             // create spinner
331             spinner = new IndeterminateSpinner(spinEnabled.get(), progressColor.get());
332             getChildren().setAll(spinner);
333             if (NodeHelper.isTreeShowing(control)) {
334                 if (indeterminateTransition != null) {
335                     indeterminateTransition.play();
336                 }
337             }
338         } else {
339             // clean up after spinner
340             if (spinner != null) {
341                 if (indeterminateTransition != null) {
342                     indeterminateTransition.stop();
343                 }
344                 spinner = null;
345             }
346 
347             // create determinateIndicator
348             determinateIndicator = new DeterminateIndicator(control, this, progressColor.get());
349             getChildren().setAll(determinateIndicator);
350         }
351     }
352 
353     void updateProgress() {
354         if (determinateIndicator != null) {
355             determinateIndicator.updateProgress(control.getProgress());
356         }
357     }
358 
359     void createIndeterminateTimeline() {
360         if (spinner != null) {
361             spinner.rebuildTimeline();
362         }
363     }
364 
365     void pauseTimeline(boolean pause) {
366         if (getSkinnable().isIndeterminate()) {
367             if (indeterminateTransition == null) {
368                 createIndeterminateTimeline();
369             }
370             if (pause) {
371                 indeterminateTransition.pause();
372             } else {
373                 indeterminateTransition.play();
374             }
375         }
376     }
377 
378     void updateAnimation() {
379         ProgressIndicator control = getSkinnable();
380         final boolean isTreeShowing = NodeHelper.isTreeShowing(control) &amp;&amp;
381                                       control.getScene() != null;
382         if (indeterminateTransition != null) {
383             pauseTimeline(!isTreeShowing);
384         } else if (isTreeShowing) {
385             createIndeterminateTimeline();
386         }
387     }
388 
389 
390 
391     /***************************************************************************
392      *                                                                         *
393      * Stylesheet Handling                                                     *
394      *                                                                         *
395      **************************************************************************/
396 
397     private static final CssMetaData&lt;ProgressIndicator,Paint&gt; PROGRESS_COLOR =
398             new CssMetaData&lt;ProgressIndicator,Paint&gt;(&quot;-fx-progress-color&quot;,
399                     PaintConverter.getInstance(), null) {
400 
401                 @Override
402                 public boolean isSettable(ProgressIndicator n) {
403                     final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) n.getSkin();
404                     return skin.progressColor == null ||
405                             !skin.progressColor.isBound();
406                 }
407 
408                 @Override
409                 public StyleableProperty&lt;Paint&gt; getStyleableProperty(ProgressIndicator n) {
410                     final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) n.getSkin();
411                     return (StyleableProperty&lt;Paint&gt;)(WritableValue&lt;Paint&gt;)skin.progressColor;
412                 }
413             };
414     private static final CssMetaData&lt;ProgressIndicator,Number&gt; INDETERMINATE_SEGMENT_COUNT =
415             new CssMetaData&lt;ProgressIndicator,Number&gt;(&quot;-fx-indeterminate-segment-count&quot;,
416                     SizeConverter.getInstance(), 8) {
417 
418                 @Override public boolean isSettable(ProgressIndicator n) {
419                     final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) n.getSkin();
420                     return skin.indeterminateSegmentCount == null ||
421                             !skin.indeterminateSegmentCount.isBound();
422                 }
423 
424                 @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(ProgressIndicator n) {
425                     final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) n.getSkin();
426                     return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)skin.indeterminateSegmentCount;
427                 }
428             };
429     private static final CssMetaData&lt;ProgressIndicator,Boolean&gt; SPIN_ENABLED =
430             new CssMetaData&lt;ProgressIndicator,Boolean&gt;(&quot;-fx-spin-enabled&quot;, BooleanConverter.getInstance(), Boolean.FALSE) {
431 
432                 @Override public boolean isSettable(ProgressIndicator node) {
433                     final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) node.getSkin();
434                     return skin.spinEnabled == null || !skin.spinEnabled.isBound();
435                 }
436 
437                 @Override public StyleableProperty&lt;Boolean&gt; getStyleableProperty(ProgressIndicator node) {
438                     final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) node.getSkin();
439                     return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)skin.spinEnabled;
440                 }
441             };
442 
443     private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
444     static {
445         final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
446                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
447         styleables.add(PROGRESS_COLOR);
448         styleables.add(INDETERMINATE_SEGMENT_COUNT);
449         styleables.add(SPIN_ENABLED);
450         STYLEABLES = Collections.unmodifiableList(styleables);
451     }
452 
453     /**
454      * Returns the CssMetaData associated with this class, which may include the
455      * CssMetaData of its superclasses.
456      * @return the CssMetaData associated with this class, which may include the
457      * CssMetaData of its superclasses
458      */
459     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
460         return STYLEABLES;
461     }
462 
463     /**
464      * {@inheritDoc}
465      */
466     @Override
467     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
468         return getClassCssMetaData();
469     }
470 
471 
472 
473     /***************************************************************************
474      *                                                                         *
475      * Support classes                                                         *
476      *                                                                         *
477      **************************************************************************/
478 
479     private final class DeterminateIndicator extends Region {
480         private double textGap = 2.0F;
481 
482         // only update progress text on whole percentages
483         private int intProgress;
484 
485         // only update pie arc to nearest degree
486         private int degProgress;
487         private Text text;
488         private StackPane indicator;
489         private StackPane progress;
490         private StackPane tick;
491         private Arc arcShape;
492         private Circle indicatorCircle;
493         private double doneTextWidth;
494         private double doneTextHeight;
495 
496         public DeterminateIndicator(ProgressIndicator control, ProgressIndicatorSkin s, Paint fillOverride) {
497 
498             getStyleClass().add(&quot;determinate-indicator&quot;);
499 
500             intProgress = (int) Math.round(control.getProgress() * 100.0) ;
501             degProgress = (int) (360 * control.getProgress());
502 
503             getChildren().clear();
504 
505             text = new Text((control.getProgress() &gt;= 1) ? (DONE) : (&quot;&quot; + intProgress + &quot;%&quot;));
506             text.setTextOrigin(VPos.TOP);
507             text.getStyleClass().setAll(&quot;text&quot;, &quot;percentage&quot;);
508 
509             registerChangeListener(text.fontProperty(), o -&gt; {
510                 doneTextWidth = Utils.computeTextWidth(text.getFont(), DONE, 0);
511                 doneTextHeight = Utils.computeTextHeight(text.getFont(), DONE, 0, TextBoundsType.LOGICAL_VERTICAL_CENTER);
512             });
513 
514             // The circular background for the progress pie piece
515             indicator = new StackPane();
516             indicator.setScaleShape(false);
517             indicator.setCenterShape(false);
518             indicator.getStyleClass().setAll(&quot;indicator&quot;);
519             indicatorCircle = new Circle();
520             indicator.setShape(indicatorCircle);
521 
522             // The shape for our progress pie piece
523             arcShape = new Arc();
524             arcShape.setType(ArcType.ROUND);
525             arcShape.setStartAngle(90.0F);
526 
527             // Our progress pie piece
528             progress = new StackPane();
529             progress.getStyleClass().setAll(&quot;progress&quot;);
530             progress.setScaleShape(false);
531             progress.setCenterShape(false);
532             progress.setShape(arcShape);
533             progress.getChildren().clear();
534             setFillOverride(fillOverride);
535 
536             // The check mark that&#39;s drawn at 100%
537             tick = new StackPane();
538             tick.getStyleClass().setAll(&quot;tick&quot;);
539 
540             getChildren().setAll(indicator, progress, text, tick);
541             updateProgress(control.getProgress());
542         }
543 
<a name="5" id="anc5"></a>



544         private void setFillOverride(Paint fillOverride) {
545             if (fillOverride instanceof Color) {
546                 Color c = (Color)fillOverride;
547                 progress.setStyle(&quot;-fx-background-color: rgba(&quot;+((int)(255*c.getRed()))+&quot;,&quot;+((int)(255*c.getGreen()))+&quot;,&quot;+((int)(255*c.getBlue()))+&quot;,&quot;+c.getOpacity()+&quot;);&quot;);
548             } else {
549                 progress.setStyle(null);
550             }
551         }
552 
553         @Override public boolean usesMirroring() {
554             // This is used instead of setting NodeOrientation,
555             // allowing the Text node to inherit the current
556             // orientation.
557             return false;
558         }
559 
560         private void updateProgress(double progress) {
561             intProgress = (int) Math.round(progress * 100.0) ;
562             text.setText((progress &gt;= 1) ? (DONE) : (&quot;&quot; + intProgress + &quot;%&quot;));
563 
564             degProgress = (int) (360 * progress);
565             arcShape.setLength(-degProgress);
566             requestLayout();
567         }
568 
569         @Override protected void layoutChildren() {
570             // Position and size the circular background
571             final double left = control.snappedLeftInset();
572             final double right = control.snappedRightInset();
573             final double top = control.snappedTopInset();
574             final double bottom = control.snappedBottomInset();
575 
576             /*
577             ** use the min of width, or height, keep it a circle
578             */
579             final double areaW = control.getWidth() - left - right;
580             final double areaH = control.getHeight() - top - bottom - textGap - doneTextHeight;
581             final double radiusW = areaW / 2;
582             final double radiusH = areaH / 2;
583             final double radius = Math.floor(Math.min(radiusW, radiusH));
584             final double centerX = snapPosition(left + radiusW);
585             final double centerY = snapPosition(top + radius);
586 
587             // find radius that fits inside radius - insetsPadding
588             final double iLeft = indicator.snappedLeftInset();
589             final double iRight = indicator.snappedRightInset();
590             final double iTop = indicator.snappedTopInset();
591             final double iBottom = indicator.snappedBottomInset();
592             final double progressRadius = snapSize(Math.min(
593                     Math.min(radius - iLeft, radius - iRight),
594                     Math.min(radius - iTop, radius - iBottom)));
595 
596             indicatorCircle.setRadius(radius);
597             indicator.setLayoutX(centerX);
598             indicator.setLayoutY(centerY);
599 
600             arcShape.setRadiusX(progressRadius);
601             arcShape.setRadiusY(progressRadius);
602             progress.setLayoutX(centerX);
603             progress.setLayoutY(centerY);
604 
605             // find radius that fits inside progressRadius - progressInsets
606             final double pLeft = progress.snappedLeftInset();
607             final double pRight = progress.snappedRightInset();
608             final double pTop = progress.snappedTopInset();
609             final double pBottom = progress.snappedBottomInset();
610             final double indicatorRadius = snapSize(Math.min(
611                     Math.min(progressRadius - pLeft, progressRadius - pRight),
612                     Math.min(progressRadius - pTop, progressRadius - pBottom)));
613 
614             // find size of spare box that fits inside indicator radius
615             double squareBoxHalfWidth = Math.ceil(Math.sqrt((indicatorRadius * indicatorRadius) / 2));
616 
617             tick.setLayoutX(centerX - squareBoxHalfWidth);
618             tick.setLayoutY(centerY - squareBoxHalfWidth);
619             tick.resize(squareBoxHalfWidth + squareBoxHalfWidth, squareBoxHalfWidth + squareBoxHalfWidth);
620             tick.setVisible(control.getProgress() &gt;= 1);
621 
622             // if the % text can&#39;t fit anywhere in the bounds then don&#39;t display it
623             double textWidth = text.getLayoutBounds().getWidth();
624             double textHeight = text.getLayoutBounds().getHeight();
625             if (control.getWidth() &gt;= textWidth &amp;&amp; control.getHeight() &gt;= textHeight) {
626                 if (!text.isVisible()) text.setVisible(true);
627                 text.setLayoutY(snapPosition(centerY + radius + textGap));
628                 text.setLayoutX(snapPosition(centerX - (textWidth/2)));
629             } else {
630                 if (text.isVisible()) text.setVisible(false);
631             }
632         }
633 
634         @Override protected double computePrefWidth(double height) {
635             final double left = control.snappedLeftInset();
636             final double right = control.snappedRightInset();
637             final double iLeft = indicator.snappedLeftInset();
638             final double iRight = indicator.snappedRightInset();
639             final double iTop = indicator.snappedTopInset();
640             final double iBottom = indicator.snappedBottomInset();
641             final double indicatorMax = snapSize(Math.max(Math.max(iLeft, iRight), Math.max(iTop, iBottom)));
642             final double pLeft = progress.snappedLeftInset();
643             final double pRight = progress.snappedRightInset();
644             final double pTop = progress.snappedTopInset();
645             final double pBottom = progress.snappedBottomInset();
646             final double progressMax = snapSize(Math.max(Math.max(pLeft, pRight), Math.max(pTop, pBottom)));
647             final double tLeft = tick.snappedLeftInset();
648             final double tRight = tick.snappedRightInset();
649             final double indicatorWidth = indicatorMax + progressMax + tLeft + tRight + progressMax + indicatorMax;
650             return left + Math.max(indicatorWidth, doneTextWidth) + right;
651         }
652 
653         @Override protected double computePrefHeight(double width) {
654             final double top = control.snappedTopInset();
655             final double bottom = control.snappedBottomInset();
656             final double iLeft = indicator.snappedLeftInset();
657             final double iRight = indicator.snappedRightInset();
658             final double iTop = indicator.snappedTopInset();
659             final double iBottom = indicator.snappedBottomInset();
660             final double indicatorMax = snapSize(Math.max(Math.max(iLeft, iRight), Math.max(iTop, iBottom)));
661             final double pLeft = progress.snappedLeftInset();
662             final double pRight = progress.snappedRightInset();
663             final double pTop = progress.snappedTopInset();
664             final double pBottom = progress.snappedBottomInset();
665             final double progressMax = snapSize(Math.max(Math.max(pLeft, pRight), Math.max(pTop, pBottom)));
666             final double tTop = tick.snappedTopInset();
667             final double tBottom = tick.snappedBottomInset();
668             final double indicatorHeight = indicatorMax + progressMax + tTop + tBottom + progressMax + indicatorMax;
669             return top + indicatorHeight + textGap + doneTextHeight + bottom;
670         }
671 
672         @Override protected double computeMaxWidth(double height) {
673             return computePrefWidth(height);
674         }
675 
676         @Override protected double computeMaxHeight(double width) {
677             return computePrefHeight(width);
678         }
679     }
680 
681 
682     private final class IndeterminateSpinner extends Region {
683         private IndicatorPaths pathsG;
684         private final List&lt;Double&gt; opacities = new ArrayList&lt;&gt;();
685         private boolean spinEnabled = false;
686         private Paint fillOverride = null;
687 
688         private IndeterminateSpinner(boolean spinEnabled, Paint fillOverride) {
689             this.spinEnabled = spinEnabled;
690             this.fillOverride = fillOverride;
691 
692             setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
693             getStyleClass().setAll(&quot;spinner&quot;);
694 
695             pathsG = new IndicatorPaths();
696             getChildren().add(pathsG);
697             rebuild();
698 
699             rebuildTimeline();
700 
701         }
702 
703         public void setFillOverride(Paint fillOverride) {
704             this.fillOverride = fillOverride;
705             rebuild();
706         }
707 
708         public void setSpinEnabled(boolean spinEnabled) {
709             this.spinEnabled = spinEnabled;
710             rebuildTimeline();
711         }
712 
713         private void rebuildTimeline() {
714             if (spinEnabled) {
715                 if (indeterminateTransition == null) {
716                     indeterminateTransition = new Timeline();
717                     indeterminateTransition.setCycleCount(Timeline.INDEFINITE);
718                     indeterminateTransition.setDelay(UNCLIPPED_DELAY);
719                 } else {
720                     indeterminateTransition.stop();
721                     ((Timeline)indeterminateTransition).getKeyFrames().clear();
722                 }
723                 final ObservableList&lt;KeyFrame&gt; keyFrames = FXCollections.&lt;KeyFrame&gt;observableArrayList();
724 
725                 keyFrames.add(new KeyFrame(Duration.millis(1), new KeyValue(pathsG.rotateProperty(), 360)));
726                 keyFrames.add(new KeyFrame(Duration.millis(3900), new KeyValue(pathsG.rotateProperty(), 0)));
727 
728                 for (int i = 100; i &lt;= 3900; i += 100) {
729                     keyFrames.add(new KeyFrame(Duration.millis(i), event -&gt; shiftColors()));
730                 }
731 
732                 ((Timeline)indeterminateTransition).getKeyFrames().setAll(keyFrames);
733                 indeterminateTransition.playFromStart();
734             } else {
735                 if (indeterminateTransition != null) {
736                     indeterminateTransition.stop();
737                     ((Timeline)indeterminateTransition).getKeyFrames().clear();
738                     indeterminateTransition = null;
739                 }
740             }
741         }
742 
743         private class IndicatorPaths extends Pane {
744             @Override protected double computePrefWidth(double height) {
745                 double w = 0;
746                 for(Node child: getChildren()) {
747                     if (child instanceof Region) {
748                         Region region = (Region)child;
749                         if (region.getShape() != null) {
750                             w = Math.max(w,region.getShape().getLayoutBounds().getMaxX());
751                         } else {
752                             w = Math.max(w,region.prefWidth(height));
753                         }
754                     }
755                 }
756                 return w;
757             }
758 
759             @Override protected double computePrefHeight(double width) {
760                 double h = 0;
761                 for(Node child: getChildren()) {
762                     if (child instanceof Region) {
763                         Region region = (Region)child;
764                         if (region.getShape() != null) {
765                             h = Math.max(h,region.getShape().getLayoutBounds().getMaxY());
766                         } else {
767                             h = Math.max(h,region.prefHeight(width));
768                         }
769                     }
770                 }
771                 return h;
772             }
773 
774             @Override protected void layoutChildren() {
775                 // calculate scale
776                 double scale = getWidth() / computePrefWidth(-1);
777                 for(Node child: getChildren()) {
778                     if (child instanceof Region) {
779                         Region region = (Region)child;
780                         if (region.getShape() != null) {
781                             region.resize(
782                                     region.getShape().getLayoutBounds().getMaxX(),
783                                     region.getShape().getLayoutBounds().getMaxY()
784                             );
785                             region.getTransforms().setAll(new Scale(scale,scale,0,0));
786                         } else {
787                             region.autosize();
788                         }
789                     }
790                 }
791             }
792         }
793 
794         @Override protected void layoutChildren() {
795             final double w = control.getWidth() - control.snappedLeftInset() - control.snappedRightInset();
796             final double h = control.getHeight() - control.snappedTopInset() - control.snappedBottomInset();
797             final double prefW = pathsG.prefWidth(-1);
798             final double prefH = pathsG.prefHeight(-1);
799             double scaleX = w / prefW;
800             double scale = scaleX;
801             if ((scaleX * prefH) &gt; h) {
802                 scale = h / prefH;
803             }
804             double indicatorW = prefW * scale;
805             double indicatorH = prefH * scale;
806             pathsG.resizeRelocate((w - indicatorW) / 2, (h - indicatorH) / 2, indicatorW, indicatorH);
807         }
808 
809         private void rebuild() {
810             // update indeterminate indicator
811             final int segments = indeterminateSegmentCount.get();
812             opacities.clear();
813             pathsG.getChildren().clear();
814             final double step = 0.8/(segments-1);
815             for (int i = 0; i &lt; segments; i++) {
816                 Region region = new Region();
817                 region.setScaleShape(false);
818                 region.setCenterShape(false);
819                 region.getStyleClass().addAll(&quot;segment&quot;, &quot;segment&quot; + i);
820                 if (fillOverride instanceof Color) {
821                     Color c = (Color)fillOverride;
822                     region.setStyle(&quot;-fx-background-color: rgba(&quot;+((int)(255*c.getRed()))+&quot;,&quot;+((int)(255*c.getGreen()))+&quot;,&quot;+((int)(255*c.getBlue()))+&quot;,&quot;+c.getOpacity()+&quot;);&quot;);
823                 } else {
824                     region.setStyle(null);
825                 }
826                 pathsG.getChildren().add(region);
827                 opacities.add(Math.max(0.1, (1.0 - (step*i))));
828             }
829         }
830 
831         private void shiftColors() {
832             if (opacities.size() &lt;= 0) return;
833             final int segments = indeterminateSegmentCount.get();
834             Collections.rotate(opacities, -1);
835             for (int i = 0; i &lt; segments; i++) {
836                 pathsG.getChildren().get(i).setOpacity(opacities.get(i));
837             }
838         }
839     }
840 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/skin/ProgressIndicatorSkin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javafx.scene.control.skin;
 27 
 28 import com.sun.javafx.scene.NodeHelper;
 29 import com.sun.javafx.scene.control.skin.Utils;
 30 import java.util.ArrayList;
 31 import java.util.Collections;
 32 import java.util.List;
<a name="1" id="anc1"></a><span class="line-removed"> 33 import java.util.function.Consumer;</span>
 34 
 35 import javafx.animation.Animation;
 36 import javafx.animation.KeyFrame;
 37 import javafx.animation.KeyValue;
 38 import javafx.animation.Timeline;
 39 import javafx.beans.property.BooleanProperty;
 40 import javafx.beans.property.IntegerProperty;
 41 import javafx.beans.property.ObjectProperty;
<a name="2" id="anc2"></a><span class="line-removed"> 42 import javafx.beans.value.ObservableValue;</span>
 43 import javafx.beans.value.WritableValue;
 44 import javafx.collections.FXCollections;
 45 import javafx.collections.ObservableList;
 46 import javafx.geometry.NodeOrientation;
 47 import javafx.geometry.VPos;
 48 import javafx.scene.Node;
 49 import javafx.scene.control.Control;
 50 import javafx.scene.control.ProgressIndicator;
 51 import javafx.scene.control.SkinBase;
 52 import javafx.scene.layout.Pane;
 53 import javafx.scene.layout.Region;
 54 import javafx.scene.layout.StackPane;
 55 import javafx.scene.paint.Color;
 56 import javafx.scene.paint.Paint;
 57 import javafx.scene.shape.Arc;
 58 import javafx.scene.shape.ArcType;
 59 import javafx.scene.shape.Circle;
<a name="3" id="anc3"></a><span class="line-removed"> 60 import javafx.scene.text.Font;</span>
 61 import javafx.scene.text.Text;
 62 import javafx.scene.text.TextBoundsType;
 63 import javafx.scene.transform.Scale;
 64 import javafx.util.Duration;
 65 import javafx.css.CssMetaData;
 66 import javafx.css.StyleableObjectProperty;
 67 import javafx.css.StyleableProperty;
 68 import javafx.css.StyleableBooleanProperty;
 69 import javafx.css.StyleableIntegerProperty;
 70 import javafx.css.converter.BooleanConverter;
 71 import javafx.css.converter.PaintConverter;
 72 import javafx.css.converter.SizeConverter;
 73 import com.sun.javafx.scene.control.skin.resources.ControlResources;
 74 import javafx.css.Styleable;
 75 
 76 /**
 77  * Default skin implementation for the {@link ProgressIndicator} control.
 78  *
 79  * @see ProgressIndicator
 80  * @since 9
 81  */
 82 public class ProgressIndicatorSkin extends SkinBase&lt;ProgressIndicator&gt; {
 83 
 84     /***************************************************************************
 85      *                                                                         *
 86      * Static fields                                                           *
 87      *                                                                         *
 88      **************************************************************************/
 89 
 90 
 91 
 92     /***************************************************************************
 93      *                                                                         *
 94      * Private fields                                                          *
 95      *                                                                         *
 96      **************************************************************************/
 97 
 98     // JDK-8149818: This constant should not be static, because the
 99     // Locale may change between instances.
100 
101     /** DONE string is just used to know the size of Done as that is the biggest text we need to allow for */
102     private final String DONE = ControlResources.getString(&quot;ProgressIndicator.doneString&quot;);
103 
104     final Duration CLIPPED_DELAY = new Duration(300);
105     final Duration UNCLIPPED_DELAY = new Duration(0);
106 
107     private IndeterminateSpinner spinner;
108     private DeterminateIndicator determinateIndicator;
109     private ProgressIndicator control;
110 
111     Animation indeterminateTransition;
112 
113 
114 
115     /***************************************************************************
116      *                                                                         *
117      * Constructors                                                            *
118      *                                                                         *
119      **************************************************************************/
120 
121     /**
122      * Creates a new ProgressIndicatorSkin instance, installing the necessary child
123      * nodes into the Control {@link Control#getChildren() children} list.
124      *
125      * @param control The control that this skin should be installed onto.
126      */
127     public ProgressIndicatorSkin(ProgressIndicator control) {
128         super(control);
129 
130         this.control = control;
131 
132         // register listeners
133         registerChangeListener(control.indeterminateProperty(), e -&gt; initialize());
134         registerChangeListener(control.progressProperty(), e -&gt; updateProgress());
135         registerChangeListener(NodeHelper.treeShowingProperty(control), e -&gt; updateAnimation());
136         registerChangeListener(control.sceneProperty(), e-&gt;updateAnimation());
137 
138         initialize();
139         updateAnimation();
140     }
141 
142 
143 
144     /***************************************************************************
145      *                                                                         *
146      * Properties                                                              *
147      *                                                                         *
148      **************************************************************************/
149 
150     /**
151      * The colour of the progress segment.
152      */
153     private ObjectProperty&lt;Paint&gt; progressColor = new StyleableObjectProperty&lt;Paint&gt;(null) {
154         @Override protected void invalidated() {
155             final Paint value = get();
156             if (value != null &amp;&amp; !(value instanceof Color)) {
157                 if (isBound()) {
158                     unbind();
159                 }
160                 set(null);
161                 throw new IllegalArgumentException(&quot;Only Color objects are supported&quot;);
162             }
163             if (spinner!=null) spinner.setFillOverride(value);
164             if (determinateIndicator!=null) determinateIndicator.setFillOverride(value);
165         }
166 
167         @Override public Object getBean() {
168             return ProgressIndicatorSkin.this;
169         }
170 
171         @Override public String getName() {
172             return &quot;progressColorProperty&quot;;
173         }
174 
175         @Override public CssMetaData&lt;ProgressIndicator,Paint&gt; getCssMetaData() {
176             return PROGRESS_COLOR;
177         }
178     };
179 
180     Paint getProgressColor() {
181         return progressColor.get();
182     }
183 
184     /**
185      * The number of segments in the spinner.
186      */
187     private IntegerProperty indeterminateSegmentCount = new StyleableIntegerProperty(8) {
188         @Override protected void invalidated() {
189             if (spinner!=null) spinner.rebuild();
190         }
191 
192         @Override public Object getBean() {
193             return ProgressIndicatorSkin.this;
194         }
195 
196         @Override public String getName() {
197             return &quot;indeterminateSegmentCount&quot;;
198         }
199 
200         @Override public CssMetaData&lt;ProgressIndicator,Number&gt; getCssMetaData() {
201             return INDETERMINATE_SEGMENT_COUNT;
202         }
203     };
204 
205     /**
206      * True if the progress indicator should rotate as well as animate opacity.
207      */
208     private final BooleanProperty spinEnabled = new StyleableBooleanProperty(false) {
209         @Override protected void invalidated() {
210             if (spinner!=null) spinner.setSpinEnabled(get());
211         }
212 
213         @Override public CssMetaData&lt;ProgressIndicator,Boolean&gt; getCssMetaData() {
214             return SPIN_ENABLED;
215         }
216 
217         @Override public Object getBean() {
218             return ProgressIndicatorSkin.this;
219         }
220 
221         @Override public String getName() {
222             return &quot;spinEnabled&quot;;
223         }
224     };
225 
226 
227 
228     /***************************************************************************
229      *                                                                         *
230      * Public API                                                              *
231      *                                                                         *
232      **************************************************************************/
233 
234     /** {@inheritDoc} */
235     @Override public void dispose() {
236         super.dispose();
237 
238         if (indeterminateTransition != null) {
239             indeterminateTransition.stop();
240             indeterminateTransition = null;
241         }
242 
243         if (spinner != null) {
244             spinner = null;
245         }
246 
247         control = null;
248     }
249 
250     /** {@inheritDoc} */
251     @Override protected void layoutChildren(final double x, final double y,
252                                             final double w, final double h) {
253         if (spinner != null &amp;&amp; control.isIndeterminate()) {
254             spinner.layoutChildren();
255             spinner.resizeRelocate(0, 0, w, h);
256         } else if (determinateIndicator != null) {
257             determinateIndicator.layoutChildren();
258             determinateIndicator.resizeRelocate(0, 0, w, h);
259         }
260     }
261 
262     /** {@inheritDoc} */
263     @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
264         double minWidth = 0.0;
265 
266         if (spinner != null &amp;&amp; control.isIndeterminate()) {
267             minWidth = spinner.minWidth(-1);
268         } else if (determinateIndicator != null) {
269             minWidth = determinateIndicator.minWidth(-1);
270         }
271         return minWidth;
272     }
273 
274     /** {@inheritDoc} */
275     @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
276         double minHeight = 0.0;
277 
278         if (spinner != null &amp;&amp; control.isIndeterminate()) {
279             minHeight = spinner.minHeight(-1);
280         } else if (determinateIndicator != null) {
281             minHeight = determinateIndicator.minHeight(-1);
282         }
283         return minHeight;
284     }
285 
286     /** {@inheritDoc} */
287     @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
288         double prefWidth = 0.0;
289 
290         if (spinner != null &amp;&amp; control.isIndeterminate()) {
291             prefWidth = spinner.prefWidth(height);
292         } else if (determinateIndicator != null) {
293             prefWidth = determinateIndicator.prefWidth(height);
294         }
295         return prefWidth;
296     }
297 
298    /** {@inheritDoc} */
299    @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
300         double prefHeight = 0.0;
301 
302         if (spinner != null &amp;&amp; control.isIndeterminate()) {
303             prefHeight = spinner.prefHeight(width);
304         } else if (determinateIndicator != null) {
305             prefHeight = determinateIndicator.prefHeight(width);
306         }
307         return prefHeight;
308     }
309 
310     /** {@inheritDoc} */
311     @Override protected double computeMaxWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
312         return computePrefWidth(height, topInset, rightInset, bottomInset, leftInset);
313     }
314 
315     /** {@inheritDoc} */
316     @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
317         return computePrefHeight(width, topInset, rightInset, bottomInset, leftInset);
318     }
319 
320 
321     /***************************************************************************
322      *                                                                         *
323      * Private implementation                                                  *
324      *                                                                         *
325      **************************************************************************/
326 
327     void initialize() {
328         boolean isIndeterminate = control.isIndeterminate();
329         if (isIndeterminate) {
330             // clean up the old determinateIndicator
<a name="4" id="anc4"></a><span class="line-modified">331             if(determinateIndicator != null) {</span>
332                 determinateIndicator.unregisterListener();
333             }
334             determinateIndicator = null;
335 
336             // create spinner
337             spinner = new IndeterminateSpinner(spinEnabled.get(), progressColor.get());
338             getChildren().setAll(spinner);
339             if (NodeHelper.isTreeShowing(control)) {
340                 if (indeterminateTransition != null) {
341                     indeterminateTransition.play();
342                 }
343             }
344         } else {
345             // clean up after spinner
346             if (spinner != null) {
347                 if (indeterminateTransition != null) {
348                     indeterminateTransition.stop();
349                 }
350                 spinner = null;
351             }
352 
353             // create determinateIndicator
354             determinateIndicator = new DeterminateIndicator(control, this, progressColor.get());
355             getChildren().setAll(determinateIndicator);
356         }
357     }
358 
359     void updateProgress() {
360         if (determinateIndicator != null) {
361             determinateIndicator.updateProgress(control.getProgress());
362         }
363     }
364 
365     void createIndeterminateTimeline() {
366         if (spinner != null) {
367             spinner.rebuildTimeline();
368         }
369     }
370 
371     void pauseTimeline(boolean pause) {
372         if (getSkinnable().isIndeterminate()) {
373             if (indeterminateTransition == null) {
374                 createIndeterminateTimeline();
375             }
376             if (pause) {
377                 indeterminateTransition.pause();
378             } else {
379                 indeterminateTransition.play();
380             }
381         }
382     }
383 
384     void updateAnimation() {
385         ProgressIndicator control = getSkinnable();
386         final boolean isTreeShowing = NodeHelper.isTreeShowing(control) &amp;&amp;
387                                       control.getScene() != null;
388         if (indeterminateTransition != null) {
389             pauseTimeline(!isTreeShowing);
390         } else if (isTreeShowing) {
391             createIndeterminateTimeline();
392         }
393     }
394 
395 
396 
397     /***************************************************************************
398      *                                                                         *
399      * Stylesheet Handling                                                     *
400      *                                                                         *
401      **************************************************************************/
402 
403     private static final CssMetaData&lt;ProgressIndicator,Paint&gt; PROGRESS_COLOR =
404             new CssMetaData&lt;ProgressIndicator,Paint&gt;(&quot;-fx-progress-color&quot;,
405                     PaintConverter.getInstance(), null) {
406 
407                 @Override
408                 public boolean isSettable(ProgressIndicator n) {
409                     final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) n.getSkin();
410                     return skin.progressColor == null ||
411                             !skin.progressColor.isBound();
412                 }
413 
414                 @Override
415                 public StyleableProperty&lt;Paint&gt; getStyleableProperty(ProgressIndicator n) {
416                     final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) n.getSkin();
417                     return (StyleableProperty&lt;Paint&gt;)(WritableValue&lt;Paint&gt;)skin.progressColor;
418                 }
419             };
420     private static final CssMetaData&lt;ProgressIndicator,Number&gt; INDETERMINATE_SEGMENT_COUNT =
421             new CssMetaData&lt;ProgressIndicator,Number&gt;(&quot;-fx-indeterminate-segment-count&quot;,
422                     SizeConverter.getInstance(), 8) {
423 
424                 @Override public boolean isSettable(ProgressIndicator n) {
425                     final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) n.getSkin();
426                     return skin.indeterminateSegmentCount == null ||
427                             !skin.indeterminateSegmentCount.isBound();
428                 }
429 
430                 @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(ProgressIndicator n) {
431                     final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) n.getSkin();
432                     return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)skin.indeterminateSegmentCount;
433                 }
434             };
435     private static final CssMetaData&lt;ProgressIndicator,Boolean&gt; SPIN_ENABLED =
436             new CssMetaData&lt;ProgressIndicator,Boolean&gt;(&quot;-fx-spin-enabled&quot;, BooleanConverter.getInstance(), Boolean.FALSE) {
437 
438                 @Override public boolean isSettable(ProgressIndicator node) {
439                     final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) node.getSkin();
440                     return skin.spinEnabled == null || !skin.spinEnabled.isBound();
441                 }
442 
443                 @Override public StyleableProperty&lt;Boolean&gt; getStyleableProperty(ProgressIndicator node) {
444                     final ProgressIndicatorSkin skin = (ProgressIndicatorSkin) node.getSkin();
445                     return (StyleableProperty&lt;Boolean&gt;)(WritableValue&lt;Boolean&gt;)skin.spinEnabled;
446                 }
447             };
448 
449     private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
450     static {
451         final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
452                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
453         styleables.add(PROGRESS_COLOR);
454         styleables.add(INDETERMINATE_SEGMENT_COUNT);
455         styleables.add(SPIN_ENABLED);
456         STYLEABLES = Collections.unmodifiableList(styleables);
457     }
458 
459     /**
460      * Returns the CssMetaData associated with this class, which may include the
461      * CssMetaData of its superclasses.
462      * @return the CssMetaData associated with this class, which may include the
463      * CssMetaData of its superclasses
464      */
465     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
466         return STYLEABLES;
467     }
468 
469     /**
470      * {@inheritDoc}
471      */
472     @Override
473     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
474         return getClassCssMetaData();
475     }
476 
477 
478 
479     /***************************************************************************
480      *                                                                         *
481      * Support classes                                                         *
482      *                                                                         *
483      **************************************************************************/
484 
485     private final class DeterminateIndicator extends Region {
486         private double textGap = 2.0F;
487 
488         // only update progress text on whole percentages
489         private int intProgress;
490 
491         // only update pie arc to nearest degree
492         private int degProgress;
493         private Text text;
494         private StackPane indicator;
495         private StackPane progress;
496         private StackPane tick;
497         private Arc arcShape;
498         private Circle indicatorCircle;
499         private double doneTextWidth;
500         private double doneTextHeight;
501 
502         public DeterminateIndicator(ProgressIndicator control, ProgressIndicatorSkin s, Paint fillOverride) {
503 
504             getStyleClass().add(&quot;determinate-indicator&quot;);
505 
506             intProgress = (int) Math.round(control.getProgress() * 100.0) ;
507             degProgress = (int) (360 * control.getProgress());
508 
509             getChildren().clear();
510 
511             text = new Text((control.getProgress() &gt;= 1) ? (DONE) : (&quot;&quot; + intProgress + &quot;%&quot;));
512             text.setTextOrigin(VPos.TOP);
513             text.getStyleClass().setAll(&quot;text&quot;, &quot;percentage&quot;);
514 
515             registerChangeListener(text.fontProperty(), o -&gt; {
516                 doneTextWidth = Utils.computeTextWidth(text.getFont(), DONE, 0);
517                 doneTextHeight = Utils.computeTextHeight(text.getFont(), DONE, 0, TextBoundsType.LOGICAL_VERTICAL_CENTER);
518             });
519 
520             // The circular background for the progress pie piece
521             indicator = new StackPane();
522             indicator.setScaleShape(false);
523             indicator.setCenterShape(false);
524             indicator.getStyleClass().setAll(&quot;indicator&quot;);
525             indicatorCircle = new Circle();
526             indicator.setShape(indicatorCircle);
527 
528             // The shape for our progress pie piece
529             arcShape = new Arc();
530             arcShape.setType(ArcType.ROUND);
531             arcShape.setStartAngle(90.0F);
532 
533             // Our progress pie piece
534             progress = new StackPane();
535             progress.getStyleClass().setAll(&quot;progress&quot;);
536             progress.setScaleShape(false);
537             progress.setCenterShape(false);
538             progress.setShape(arcShape);
539             progress.getChildren().clear();
540             setFillOverride(fillOverride);
541 
542             // The check mark that&#39;s drawn at 100%
543             tick = new StackPane();
544             tick.getStyleClass().setAll(&quot;tick&quot;);
545 
546             getChildren().setAll(indicator, progress, text, tick);
547             updateProgress(control.getProgress());
548         }
549 
550         private void unregisterListener() {
551             unregisterChangeListeners(text.fontProperty());
552         }
553 
554         private void setFillOverride(Paint fillOverride) {
555             if (fillOverride instanceof Color) {
556                 Color c = (Color)fillOverride;
557                 progress.setStyle(&quot;-fx-background-color: rgba(&quot;+((int)(255*c.getRed()))+&quot;,&quot;+((int)(255*c.getGreen()))+&quot;,&quot;+((int)(255*c.getBlue()))+&quot;,&quot;+c.getOpacity()+&quot;);&quot;);
558             } else {
559                 progress.setStyle(null);
560             }
561         }
562 
563         @Override public boolean usesMirroring() {
564             // This is used instead of setting NodeOrientation,
565             // allowing the Text node to inherit the current
566             // orientation.
567             return false;
568         }
569 
570         private void updateProgress(double progress) {
571             intProgress = (int) Math.round(progress * 100.0) ;
572             text.setText((progress &gt;= 1) ? (DONE) : (&quot;&quot; + intProgress + &quot;%&quot;));
573 
574             degProgress = (int) (360 * progress);
575             arcShape.setLength(-degProgress);
576             requestLayout();
577         }
578 
579         @Override protected void layoutChildren() {
580             // Position and size the circular background
581             final double left = control.snappedLeftInset();
582             final double right = control.snappedRightInset();
583             final double top = control.snappedTopInset();
584             final double bottom = control.snappedBottomInset();
585 
586             /*
587             ** use the min of width, or height, keep it a circle
588             */
589             final double areaW = control.getWidth() - left - right;
590             final double areaH = control.getHeight() - top - bottom - textGap - doneTextHeight;
591             final double radiusW = areaW / 2;
592             final double radiusH = areaH / 2;
593             final double radius = Math.floor(Math.min(radiusW, radiusH));
594             final double centerX = snapPosition(left + radiusW);
595             final double centerY = snapPosition(top + radius);
596 
597             // find radius that fits inside radius - insetsPadding
598             final double iLeft = indicator.snappedLeftInset();
599             final double iRight = indicator.snappedRightInset();
600             final double iTop = indicator.snappedTopInset();
601             final double iBottom = indicator.snappedBottomInset();
602             final double progressRadius = snapSize(Math.min(
603                     Math.min(radius - iLeft, radius - iRight),
604                     Math.min(radius - iTop, radius - iBottom)));
605 
606             indicatorCircle.setRadius(radius);
607             indicator.setLayoutX(centerX);
608             indicator.setLayoutY(centerY);
609 
610             arcShape.setRadiusX(progressRadius);
611             arcShape.setRadiusY(progressRadius);
612             progress.setLayoutX(centerX);
613             progress.setLayoutY(centerY);
614 
615             // find radius that fits inside progressRadius - progressInsets
616             final double pLeft = progress.snappedLeftInset();
617             final double pRight = progress.snappedRightInset();
618             final double pTop = progress.snappedTopInset();
619             final double pBottom = progress.snappedBottomInset();
620             final double indicatorRadius = snapSize(Math.min(
621                     Math.min(progressRadius - pLeft, progressRadius - pRight),
622                     Math.min(progressRadius - pTop, progressRadius - pBottom)));
623 
624             // find size of spare box that fits inside indicator radius
625             double squareBoxHalfWidth = Math.ceil(Math.sqrt((indicatorRadius * indicatorRadius) / 2));
626 
627             tick.setLayoutX(centerX - squareBoxHalfWidth);
628             tick.setLayoutY(centerY - squareBoxHalfWidth);
629             tick.resize(squareBoxHalfWidth + squareBoxHalfWidth, squareBoxHalfWidth + squareBoxHalfWidth);
630             tick.setVisible(control.getProgress() &gt;= 1);
631 
632             // if the % text can&#39;t fit anywhere in the bounds then don&#39;t display it
633             double textWidth = text.getLayoutBounds().getWidth();
634             double textHeight = text.getLayoutBounds().getHeight();
635             if (control.getWidth() &gt;= textWidth &amp;&amp; control.getHeight() &gt;= textHeight) {
636                 if (!text.isVisible()) text.setVisible(true);
637                 text.setLayoutY(snapPosition(centerY + radius + textGap));
638                 text.setLayoutX(snapPosition(centerX - (textWidth/2)));
639             } else {
640                 if (text.isVisible()) text.setVisible(false);
641             }
642         }
643 
644         @Override protected double computePrefWidth(double height) {
645             final double left = control.snappedLeftInset();
646             final double right = control.snappedRightInset();
647             final double iLeft = indicator.snappedLeftInset();
648             final double iRight = indicator.snappedRightInset();
649             final double iTop = indicator.snappedTopInset();
650             final double iBottom = indicator.snappedBottomInset();
651             final double indicatorMax = snapSize(Math.max(Math.max(iLeft, iRight), Math.max(iTop, iBottom)));
652             final double pLeft = progress.snappedLeftInset();
653             final double pRight = progress.snappedRightInset();
654             final double pTop = progress.snappedTopInset();
655             final double pBottom = progress.snappedBottomInset();
656             final double progressMax = snapSize(Math.max(Math.max(pLeft, pRight), Math.max(pTop, pBottom)));
657             final double tLeft = tick.snappedLeftInset();
658             final double tRight = tick.snappedRightInset();
659             final double indicatorWidth = indicatorMax + progressMax + tLeft + tRight + progressMax + indicatorMax;
660             return left + Math.max(indicatorWidth, doneTextWidth) + right;
661         }
662 
663         @Override protected double computePrefHeight(double width) {
664             final double top = control.snappedTopInset();
665             final double bottom = control.snappedBottomInset();
666             final double iLeft = indicator.snappedLeftInset();
667             final double iRight = indicator.snappedRightInset();
668             final double iTop = indicator.snappedTopInset();
669             final double iBottom = indicator.snappedBottomInset();
670             final double indicatorMax = snapSize(Math.max(Math.max(iLeft, iRight), Math.max(iTop, iBottom)));
671             final double pLeft = progress.snappedLeftInset();
672             final double pRight = progress.snappedRightInset();
673             final double pTop = progress.snappedTopInset();
674             final double pBottom = progress.snappedBottomInset();
675             final double progressMax = snapSize(Math.max(Math.max(pLeft, pRight), Math.max(pTop, pBottom)));
676             final double tTop = tick.snappedTopInset();
677             final double tBottom = tick.snappedBottomInset();
678             final double indicatorHeight = indicatorMax + progressMax + tTop + tBottom + progressMax + indicatorMax;
679             return top + indicatorHeight + textGap + doneTextHeight + bottom;
680         }
681 
682         @Override protected double computeMaxWidth(double height) {
683             return computePrefWidth(height);
684         }
685 
686         @Override protected double computeMaxHeight(double width) {
687             return computePrefHeight(width);
688         }
689     }
690 
691 
692     private final class IndeterminateSpinner extends Region {
693         private IndicatorPaths pathsG;
694         private final List&lt;Double&gt; opacities = new ArrayList&lt;&gt;();
695         private boolean spinEnabled = false;
696         private Paint fillOverride = null;
697 
698         private IndeterminateSpinner(boolean spinEnabled, Paint fillOverride) {
699             this.spinEnabled = spinEnabled;
700             this.fillOverride = fillOverride;
701 
702             setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
703             getStyleClass().setAll(&quot;spinner&quot;);
704 
705             pathsG = new IndicatorPaths();
706             getChildren().add(pathsG);
707             rebuild();
708 
709             rebuildTimeline();
710 
711         }
712 
713         public void setFillOverride(Paint fillOverride) {
714             this.fillOverride = fillOverride;
715             rebuild();
716         }
717 
718         public void setSpinEnabled(boolean spinEnabled) {
719             this.spinEnabled = spinEnabled;
720             rebuildTimeline();
721         }
722 
723         private void rebuildTimeline() {
724             if (spinEnabled) {
725                 if (indeterminateTransition == null) {
726                     indeterminateTransition = new Timeline();
727                     indeterminateTransition.setCycleCount(Timeline.INDEFINITE);
728                     indeterminateTransition.setDelay(UNCLIPPED_DELAY);
729                 } else {
730                     indeterminateTransition.stop();
731                     ((Timeline)indeterminateTransition).getKeyFrames().clear();
732                 }
733                 final ObservableList&lt;KeyFrame&gt; keyFrames = FXCollections.&lt;KeyFrame&gt;observableArrayList();
734 
735                 keyFrames.add(new KeyFrame(Duration.millis(1), new KeyValue(pathsG.rotateProperty(), 360)));
736                 keyFrames.add(new KeyFrame(Duration.millis(3900), new KeyValue(pathsG.rotateProperty(), 0)));
737 
738                 for (int i = 100; i &lt;= 3900; i += 100) {
739                     keyFrames.add(new KeyFrame(Duration.millis(i), event -&gt; shiftColors()));
740                 }
741 
742                 ((Timeline)indeterminateTransition).getKeyFrames().setAll(keyFrames);
743                 indeterminateTransition.playFromStart();
744             } else {
745                 if (indeterminateTransition != null) {
746                     indeterminateTransition.stop();
747                     ((Timeline)indeterminateTransition).getKeyFrames().clear();
748                     indeterminateTransition = null;
749                 }
750             }
751         }
752 
753         private class IndicatorPaths extends Pane {
754             @Override protected double computePrefWidth(double height) {
755                 double w = 0;
756                 for(Node child: getChildren()) {
757                     if (child instanceof Region) {
758                         Region region = (Region)child;
759                         if (region.getShape() != null) {
760                             w = Math.max(w,region.getShape().getLayoutBounds().getMaxX());
761                         } else {
762                             w = Math.max(w,region.prefWidth(height));
763                         }
764                     }
765                 }
766                 return w;
767             }
768 
769             @Override protected double computePrefHeight(double width) {
770                 double h = 0;
771                 for(Node child: getChildren()) {
772                     if (child instanceof Region) {
773                         Region region = (Region)child;
774                         if (region.getShape() != null) {
775                             h = Math.max(h,region.getShape().getLayoutBounds().getMaxY());
776                         } else {
777                             h = Math.max(h,region.prefHeight(width));
778                         }
779                     }
780                 }
781                 return h;
782             }
783 
784             @Override protected void layoutChildren() {
785                 // calculate scale
786                 double scale = getWidth() / computePrefWidth(-1);
787                 for(Node child: getChildren()) {
788                     if (child instanceof Region) {
789                         Region region = (Region)child;
790                         if (region.getShape() != null) {
791                             region.resize(
792                                     region.getShape().getLayoutBounds().getMaxX(),
793                                     region.getShape().getLayoutBounds().getMaxY()
794                             );
795                             region.getTransforms().setAll(new Scale(scale,scale,0,0));
796                         } else {
797                             region.autosize();
798                         }
799                     }
800                 }
801             }
802         }
803 
804         @Override protected void layoutChildren() {
805             final double w = control.getWidth() - control.snappedLeftInset() - control.snappedRightInset();
806             final double h = control.getHeight() - control.snappedTopInset() - control.snappedBottomInset();
807             final double prefW = pathsG.prefWidth(-1);
808             final double prefH = pathsG.prefHeight(-1);
809             double scaleX = w / prefW;
810             double scale = scaleX;
811             if ((scaleX * prefH) &gt; h) {
812                 scale = h / prefH;
813             }
814             double indicatorW = prefW * scale;
815             double indicatorH = prefH * scale;
816             pathsG.resizeRelocate((w - indicatorW) / 2, (h - indicatorH) / 2, indicatorW, indicatorH);
817         }
818 
819         private void rebuild() {
820             // update indeterminate indicator
821             final int segments = indeterminateSegmentCount.get();
822             opacities.clear();
823             pathsG.getChildren().clear();
824             final double step = 0.8/(segments-1);
825             for (int i = 0; i &lt; segments; i++) {
826                 Region region = new Region();
827                 region.setScaleShape(false);
828                 region.setCenterShape(false);
829                 region.getStyleClass().addAll(&quot;segment&quot;, &quot;segment&quot; + i);
830                 if (fillOverride instanceof Color) {
831                     Color c = (Color)fillOverride;
832                     region.setStyle(&quot;-fx-background-color: rgba(&quot;+((int)(255*c.getRed()))+&quot;,&quot;+((int)(255*c.getGreen()))+&quot;,&quot;+((int)(255*c.getBlue()))+&quot;,&quot;+c.getOpacity()+&quot;);&quot;);
833                 } else {
834                     region.setStyle(null);
835                 }
836                 pathsG.getChildren().add(region);
837                 opacities.add(Math.max(0.1, (1.0 - (step*i))));
838             }
839         }
840 
841         private void shiftColors() {
842             if (opacities.size() &lt;= 0) return;
843             final int segments = indeterminateSegmentCount.get();
844             Collections.rotate(opacities, -1);
845             for (int i = 0; i &lt; segments; i++) {
846                 pathsG.getChildren().get(i).setOpacity(opacities.get(i));
847             }
848         }
849     }
850 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
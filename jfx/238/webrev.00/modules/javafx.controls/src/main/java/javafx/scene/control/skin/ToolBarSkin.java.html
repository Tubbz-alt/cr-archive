<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.controls/src/main/java/javafx/scene/control/skin/ToolBarSkin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javafx.scene.control.skin;
 27 
 28 import com.sun.javafx.scene.NodeHelper;
 29 import com.sun.javafx.scene.ParentHelper;
 30 import java.util.ArrayList;
 31 import java.util.Collections;
 32 import java.util.List;
 33 
 34 import com.sun.javafx.scene.control.behavior.BehaviorBase;
 35 import com.sun.javafx.scene.traversal.Algorithm;
 36 import com.sun.javafx.scene.traversal.ParentTraversalEngine;
 37 import com.sun.javafx.scene.traversal.TraversalContext;
 38 
 39 import javafx.beans.property.ObjectProperty;
 40 import javafx.beans.property.DoubleProperty;
 41 import javafx.beans.value.WritableValue;
 42 import javafx.collections.FXCollections;
 43 import javafx.collections.ListChangeListener;
 44 import javafx.collections.ObservableList;
 45 import javafx.geometry.HPos;
 46 import javafx.geometry.Orientation;
 47 import javafx.geometry.Pos;
 48 import javafx.geometry.Side;
 49 import javafx.geometry.VPos;
 50 import javafx.scene.AccessibleAction;
 51 import javafx.scene.AccessibleAttribute;
 52 import javafx.scene.AccessibleRole;
 53 import javafx.scene.Node;
 54 import javafx.scene.Parent;
 55 import javafx.scene.control.ContextMenu;
 56 import javafx.scene.control.Control;
 57 import javafx.scene.control.MenuItem;
 58 import javafx.scene.control.CustomMenuItem;
 59 import javafx.scene.control.Separator;
 60 import javafx.scene.control.SeparatorMenuItem;
 61 import javafx.scene.control.SkinBase;
 62 import javafx.scene.control.ToolBar;
 63 import javafx.scene.input.KeyCode;
 64 import javafx.scene.layout.HBox;
 65 import javafx.scene.layout.Pane;
 66 import javafx.scene.layout.StackPane;
 67 import javafx.scene.layout.VBox;
 68 import javafx.css.StyleableDoubleProperty;
 69 import javafx.css.StyleableObjectProperty;
 70 import javafx.css.StyleableProperty;
 71 import javafx.css.CssMetaData;
 72 
 73 import javafx.css.converter.EnumConverter;
 74 import javafx.css.converter.SizeConverter;
 75 import com.sun.javafx.scene.control.behavior.ToolBarBehavior;
 76 import com.sun.javafx.scene.traversal.Direction;
 77 
 78 import javafx.css.Styleable;
 79 
 80 import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;
 81 
 82 /**
 83  * Default skin implementation for the {@link ToolBar} control.
 84  *
 85  * @see ToolBar
 86  * @since 9
 87  */
 88 public class ToolBarSkin extends SkinBase&lt;ToolBar&gt; {
 89 
 90     /***************************************************************************
 91      *                                                                         *
 92      * Private fields                                                          *
 93      *                                                                         *
 94      **************************************************************************/
 95 
 96     private Pane box;
 97     private ToolBarOverflowMenu overflowMenu;
 98     private boolean overflow = false;
 99     private double previousWidth = 0;
100     private double previousHeight = 0;
101     private double savedPrefWidth = 0;
102     private double savedPrefHeight = 0;
103     private ObservableList&lt;MenuItem&gt; overflowMenuItems;
104     private boolean needsUpdate = false;
105     private final ParentTraversalEngine engine;
106     private final BehaviorBase&lt;ToolBar&gt; behavior;
107 
108     private ListChangeListener&lt;Node&gt; itemsListener;
109 
110     /***************************************************************************
111      *                                                                         *
112      * Constructors                                                            *
113      *                                                                         *
114      **************************************************************************/
115 
116     /**
117      * Creates a new ToolBarSkin instance, installing the necessary child
118      * nodes into the Control {@link Control#getChildren() children} list, as
119      * well as the necessary input mappings for handling key, mouse, etc events.
120      *
121      * @param control The control that this skin should be installed onto.
122      */
123     public ToolBarSkin(ToolBar control) {
124         super(control);
125 
126         // install default input map for the ToolBar control
127         behavior = new ToolBarBehavior(control);
128 //        control.setInputMap(behavior.getInputMap());
129 
130         overflowMenuItems = FXCollections.observableArrayList();
131         initialize();
132         registerChangeListener(control.orientationProperty(), e -&gt; initialize());
133 
134         engine = new ParentTraversalEngine(getSkinnable(), new Algorithm() {
135 
136             private Node selectPrev(int from, TraversalContext context) {
137                 for (int i = from; i &gt;= 0; --i) {
138                     Node n = box.getChildren().get(i);
139                     if (n.isDisabled() || !NodeHelper.isTreeShowing(n)) continue;
140                     if (n instanceof Parent) {
141                         Node selected = context.selectLastInParent((Parent)n);
142                         if (selected != null) return selected;
143                     }
144                     if (n.isFocusTraversable() ) {
145                         return n;
146                     }
147                 }
148                 return null;
149             }
150 
151             private Node selectNext(int from, TraversalContext context) {
152                 for (int i = from, max = box.getChildren().size(); i &lt; max; ++i) {
153                     Node n = box.getChildren().get(i);
154                     if (n.isDisabled() || !NodeHelper.isTreeShowing(n)) continue;
155                     if (n.isFocusTraversable()) {
156                         return n;
157                     }
158                     if (n instanceof Parent) {
159                         Node selected = context.selectFirstInParent((Parent)n);
160                         if (selected != null) return selected;
161                     }
162                 }
163                 return null;
164             }
165 
166             @Override
167             public Node select(Node owner, Direction dir, TraversalContext context) {
168 
169                 dir = dir.getDirectionForNodeOrientation(control.getEffectiveNodeOrientation());
170 
171                 final ObservableList&lt;Node&gt; boxChildren = box.getChildren();
172                 if (owner == overflowMenu) {
173                     if (dir.isForward()) {
174                         return null;
175                     } else {
176                         Node selected = selectPrev(boxChildren.size() - 1, context);
177                         if (selected != null) return selected;
178                     }
179                 }
180 
181                 int idx = boxChildren.indexOf(owner);
182 
183                 if (idx &lt; 0) {
184                     // The current focus owner is a child of some Toolbar&#39;s item
185                     Parent item = owner.getParent();
186                     while (!boxChildren.contains(item)) {
187                         item = item.getParent();
188                     }
189                     Node selected = context.selectInSubtree(item, owner, dir);
190                     if (selected != null) return selected;
191                     idx = boxChildren.indexOf(item);
192                     if (dir == Direction.NEXT) dir = Direction.NEXT_IN_LINE;
193                 }
194 
195                 if (idx &gt;= 0) {
196                     if (dir.isForward()) {
197                         Node selected = selectNext(idx + 1, context);
198                         if (selected != null) return selected;
199                         if (overflow) {
200                             overflowMenu.requestFocus();
201                             return overflowMenu;
202                         }
203                     } else {
204                         Node selected = selectPrev(idx - 1, context);
205                         if (selected != null) return selected;
206                     }
207                 }
208                 return null;
209             }
210 
211             @Override
212             public Node selectFirst(TraversalContext context) {
213                 Node selected = selectNext(0, context);
214                 if (selected != null) return selected;
215                 if (overflow) {
216                     return overflowMenu;
217                 }
218                 return null;
219             }
220 
221             @Override
222             public Node selectLast(TraversalContext context) {
223                 if (overflow) {
224                     return overflowMenu;
225                 }
226                 return selectPrev(box.getChildren().size() - 1, context);
227             }
228         });
229         ParentHelper.setTraversalEngine(getSkinnable(), engine);
230 
231         registerChangeListener(control.focusedProperty(), ov -&gt; {
232             if (getSkinnable().isFocused()) {
233                 // TODO need to detect the focus direction
234                 // to selected the first control in the toolbar when TAB is pressed
235                 // or select the last control in the toolbar when SHIFT TAB is pressed.
236                 if (!box.getChildren().isEmpty()) {
237                     box.getChildren().get(0).requestFocus();
238                 } else {
239                     overflowMenu.requestFocus();
240                 }
241             }
242         });
243 
244         itemsListener = (ListChangeListener&lt;Node&gt;) c -&gt; {
245             while (c.next()) {
246                 for (Node n: c.getRemoved()) {
247                     box.getChildren().remove(n);
248                 }
249                 box.getChildren().addAll(c.getAddedSubList());
250             }
251             needsUpdate = true;
252             getSkinnable().requestLayout();
253         };
254         control.getItems().addListener(itemsListener);
255     }
256 
257 
258 
259     /***************************************************************************
260      *                                                                         *
261      * Properties                                                              *
262      *                                                                         *
263      **************************************************************************/
264 
265     private double snapSpacing(double value) {
266         if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
267             return snapSpaceY(value);
268         } else {
269             return snapSpaceX(value);
270         }
271     }
272 
273     // --- spacing
274     private DoubleProperty spacing;
275     private final void setSpacing(double value) {
276         spacingProperty().set(snapSpacing(value));
277     }
278 
279     private final double getSpacing() {
280         return spacing == null ? 0.0 : snapSpacing(spacing.get());
281     }
282 
283     private final DoubleProperty spacingProperty() {
284         if (spacing == null) {
285             spacing = new StyleableDoubleProperty() {
286 
287                 @Override
288                 protected void invalidated() {
289                     final double value = get();
290                     if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
291                         ((VBox)box).setSpacing(value);
292                     } else {
293                         ((HBox)box).setSpacing(value);
294                     }
295                 }
296 
297                 @Override
298                 public Object getBean() {
299                     return ToolBarSkin.this;
300                 }
301 
302                 @Override
303                 public String getName() {
304                     return &quot;spacing&quot;;
305                 }
306 
307                 @Override
308                 public CssMetaData&lt;ToolBar,Number&gt; getCssMetaData() {
309                     return StyleableProperties.SPACING;
310                 }
311             };
312         }
313         return spacing;
314     }
315 
316     // --- box alignment
317     private ObjectProperty&lt;Pos&gt; boxAlignment;
318     private final void setBoxAlignment(Pos value) {
319         boxAlignmentProperty().set(value);
320     }
321 
322     private final Pos getBoxAlignment() {
323         return boxAlignment == null ? Pos.TOP_LEFT : boxAlignment.get();
324     }
325 
326     private final ObjectProperty&lt;Pos&gt; boxAlignmentProperty() {
327         if (boxAlignment == null) {
328             boxAlignment = new StyleableObjectProperty&lt;Pos&gt;(Pos.TOP_LEFT) {
329 
330                 @Override
331                 public void invalidated() {
332                     final Pos value = get();
333                     if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
334                         ((VBox)box).setAlignment(value);
335                     } else {
336                         ((HBox)box).setAlignment(value);
337                     }
338                 }
339 
340                 @Override
341                 public Object getBean() {
342                     return ToolBarSkin.this;
343                 }
344 
345                 @Override
346                 public String getName() {
347                     return &quot;boxAlignment&quot;;
348                 }
349 
350                 @Override
351                 public CssMetaData&lt;ToolBar,Pos&gt; getCssMetaData() {
352                     return StyleableProperties.ALIGNMENT;
353                 }
354             };
355         }
356         return boxAlignment;
357     }
358 
359 
360 
361     /***************************************************************************
362      *                                                                         *
363      * Public API                                                              *
364      *                                                                         *
365      **************************************************************************/
366 
367     /** {@inheritDoc} */
368     @Override public void dispose() {
369         if (getSkinnable() == null) return;
370         getSkinnable().getItems().removeListener(itemsListener);
371         super.dispose();
372 
373         if (behavior != null) {
374             behavior.dispose();
375         }
376     }
377 
378     /** {@inheritDoc} */
379     @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
380         final ToolBar toolbar = getSkinnable();
381         return toolbar.getOrientation() == Orientation.VERTICAL ?
382             computePrefWidth(-1, topInset, rightInset, bottomInset, leftInset) :
383             snapSizeX(overflowMenu.prefWidth(-1)) + leftInset + rightInset;
384     }
385 
386     /** {@inheritDoc} */
387     @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
388         final ToolBar toolbar = getSkinnable();
389         return toolbar.getOrientation() == Orientation.VERTICAL?
390             snapSizeY(overflowMenu.prefHeight(-1)) + topInset + bottomInset :
391             computePrefHeight(-1, topInset, rightInset, bottomInset, leftInset);
392     }
393 
394     /** {@inheritDoc} */
395     @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
396         double prefWidth = 0;
397         final ToolBar toolbar = getSkinnable();
398 
399         if (toolbar.getOrientation() == Orientation.HORIZONTAL) {
400             for (Node node : toolbar.getItems()) {
401                 if (!node.isManaged()) continue;
402                 prefWidth += snapSizeX(node.prefWidth(-1)) + getSpacing();
403             }
404             prefWidth -= getSpacing();
405         } else {
406             for (Node node : toolbar.getItems()) {
407                 if (!node.isManaged()) continue;
408                 prefWidth = Math.max(prefWidth, snapSizeX(node.prefWidth(-1)));
409             }
410             if (toolbar.getItems().size() &gt; 0) {
411                 savedPrefWidth = prefWidth;
412             } else {
413                 prefWidth = savedPrefWidth;
414             }
415         }
416         return leftInset + prefWidth + rightInset;
417     }
418 
419     /** {@inheritDoc} */
420     @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
421         double prefHeight = 0;
422         final ToolBar toolbar = getSkinnable();
423 
424         if(toolbar.getOrientation() == Orientation.VERTICAL) {
425             for (Node node: toolbar.getItems()) {
426                 if (!node.isManaged()) continue;
427                 prefHeight += snapSizeY(node.prefHeight(-1)) + getSpacing();
428             }
429             prefHeight -= getSpacing();
430         } else {
431             for (Node node : toolbar.getItems()) {
432                 if (!node.isManaged()) continue;
433                 prefHeight = Math.max(prefHeight, snapSizeY(node.prefHeight(-1)));
434             }
435             if (toolbar.getItems().size() &gt; 0) {
436                 savedPrefHeight = prefHeight;
437             } else {
438                 prefHeight = savedPrefHeight;
439             }
440         }
441         return topInset + prefHeight + bottomInset;
442     }
443 
444     /** {@inheritDoc} */
445     @Override protected double computeMaxWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
446         return getSkinnable().getOrientation() == Orientation.VERTICAL ?
447                 snapSizeX(getSkinnable().prefWidth(-1)) : Double.MAX_VALUE;
448     }
449 
450     /** {@inheritDoc} */
451     @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
452         return getSkinnable().getOrientation() == Orientation.VERTICAL ?
453                 Double.MAX_VALUE : snapSizeY(getSkinnable().prefHeight(-1));
454     }
455 
456     /** {@inheritDoc} */
457     @Override protected void layoutChildren(final double x,final double y,
458             final double w, final double h) {
459 //        super.layoutChildren();
460         final ToolBar toolbar = getSkinnable();
461 
462         double toolbarLength = getToolbarLength(toolbar);
463         if (toolbar.getOrientation() == Orientation.VERTICAL) {
464             if (snapSizeY(toolbar.getHeight()) != previousHeight || needsUpdate) {
465                 ((VBox)box).setSpacing(getSpacing());
466                 ((VBox)box).setAlignment(getBoxAlignment());
467                 previousHeight = snapSizeY(toolbar.getHeight());
468                 addNodesToToolBar();
469             } else {
470                 correctOverflow(toolbarLength);
471             }
472         } else {
473             if (snapSizeX(toolbar.getWidth()) != previousWidth || needsUpdate) {
474                 ((HBox)box).setSpacing(getSpacing());
475                 ((HBox)box).setAlignment(getBoxAlignment());
476                 previousWidth = snapSizeX(toolbar.getWidth());
477                 addNodesToToolBar();
478             } else {
479                 correctOverflow(toolbarLength);
480             }
481         }
482 
483         needsUpdate = false;
484 
485         double toolbarWidth = w;
486         double toolbarHeight = h;
487 
488         if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
489             toolbarHeight -= (overflow ? snapSizeY(overflowMenu.prefHeight(-1)) : 0);
490         } else {
491             toolbarWidth -= (overflow ? snapSizeX(overflowMenu.prefWidth(-1)) : 0);
492         }
493 
494         box.resize(toolbarWidth, toolbarHeight);
495         positionInArea(box, x, y,
496                 toolbarWidth, toolbarHeight, /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
497 
498         // If popup menu is not null show the overflowControl
499         if (overflow) {
500             double overflowMenuWidth = snapSizeX(overflowMenu.prefWidth(-1));
501             double overflowMenuHeight = snapSizeY(overflowMenu.prefHeight(-1));
502             double overflowX = x;
503             double overflowY = x;
504             if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
505                 // This is to prevent the overflow menu from moving when there
506                 // are no items in the toolbar.
507                 if (toolbarWidth == 0) {
508                     toolbarWidth = savedPrefWidth;
509                 }
510                 HPos pos = ((VBox)box).getAlignment().getHpos();
511                 if (HPos.LEFT.equals(pos)) {
512                     overflowX = x + Math.abs((toolbarWidth - overflowMenuWidth)/2);
513                 } else if (HPos.RIGHT.equals(pos)) {
514                     overflowX = (snapSizeX(toolbar.getWidth()) - snappedRightInset() - toolbarWidth) +
515                         Math.abs((toolbarWidth - overflowMenuWidth)/2);
516                 } else {
517                     overflowX = x +
518                         Math.abs((snapSizeX(toolbar.getWidth()) - (x) +
519                         snappedRightInset() - overflowMenuWidth)/2);
520                 }
521                 overflowY = snapSizeY(toolbar.getHeight()) - overflowMenuHeight - y;
522             } else {
523                 // This is to prevent the overflow menu from moving when there
524                 // are no items in the toolbar.
525                 if (toolbarHeight == 0) {
526                     toolbarHeight = savedPrefHeight;
527                 }
528                 VPos pos = ((HBox)box).getAlignment().getVpos();
529                 if (VPos.TOP.equals(pos)) {
530                     overflowY = y +
531                         Math.abs((toolbarHeight - overflowMenuHeight)/2);
532                 } else if (VPos.BOTTOM.equals(pos)) {
533                     overflowY = (snapSizeY(toolbar.getHeight()) - snappedBottomInset() - toolbarHeight) +
534                         Math.abs((toolbarHeight - overflowMenuHeight)/2);
535                 } else {
536                     overflowY = y + Math.abs((toolbarHeight - overflowMenuHeight)/2);
537                 }
538                overflowX = snapSizeX(toolbar.getWidth()) - overflowMenuWidth - snappedRightInset();
539             }
540             overflowMenu.resize(overflowMenuWidth, overflowMenuHeight);
541             positionInArea(overflowMenu, overflowX, overflowY, overflowMenuWidth, overflowMenuHeight, /*baseline ignored*/0,
542                     HPos.CENTER, VPos.CENTER);
543         }
544     }
545 
546     /***************************************************************************
547      *                                                                         *
548      * Private implementation                                                  *
549      *                                                                         *
550      **************************************************************************/
551 
552     private void initialize() {
553         if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
554             box = new VBox();
555         } else {
556             box = new HBox();
557         }
558         box.getStyleClass().add(&quot;container&quot;);
559         box.getChildren().addAll(getSkinnable().getItems());
560         overflowMenu = new ToolBarOverflowMenu(overflowMenuItems);
561         overflowMenu.setVisible(false);
562         overflowMenu.setManaged(false);
563 
564         getChildren().clear();
565         getChildren().add(box);
566         getChildren().add(overflowMenu);
567 
568         previousWidth = 0;
569         previousHeight = 0;
570         savedPrefWidth = 0;
571         savedPrefHeight = 0;
572         needsUpdate = true;
573         getSkinnable().requestLayout();
574     }
575 
576     private void correctOverflow(double length) {
577         boolean overflowed = isOverflowed(length);
578         if (overflowed != overflow) {
579             organizeOverflow(length, overflow);
580         }
581     }
582 
583     private void organizeOverflow(double length, boolean hasOverflow) {
584         if (hasOverflow) {
585             if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
586                 length -= snapSizeY(overflowMenu.prefHeight(-1));
587             } else {
588                 length -= snapSizeX(overflowMenu.prefWidth(-1));
589             }
590             length -= getSpacing();
591         }
592 
593         // Determine which node goes to the toolbar and which goes to the overflow.
594 
595         double x = 0;
596         overflowMenuItems.clear();
597         box.getChildren().clear();
598         for (Node node : getSkinnable().getItems()) {
599             node.getStyleClass().remove(&quot;menu-item&quot;);
600             node.getStyleClass().remove(&quot;custom-menu-item&quot;);
601 
602             if (node.isManaged()) {
603                 if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
604                     x += snapSizeY(node.prefHeight(-1)) + getSpacing();
605                 } else {
606                     x += snapSizeX(node.prefWidth(-1)) + getSpacing();
607                 }
608             }
609 
610             if (x &lt;= length) {
611                 box.getChildren().add(node);
612             } else {
613                 if (node.isFocused()) {
614                     if (!box.getChildren().isEmpty()) {
615                         Node last = engine.selectLast();
616                         if (last != null) {
617                             last.requestFocus();
618                         }
619                     } else {
620                         overflowMenu.requestFocus();
621                     }
622                 }
623                 if (node instanceof Separator) {
624                     overflowMenuItems.add(new SeparatorMenuItem());
625                 } else {
626                     CustomMenuItem customMenuItem = new CustomMenuItem(node);
627 
628                     // RT-36455:
629                     // We can&#39;t be totally certain of all nodes, but for the
630                     // most common nodes we can check to see whether we should
631                     // hide the menu when the node is clicked on. The common
632                     // case is for TextField or Slider.
633                     // This list won&#39;t be exhaustive (there is no point really
634                     // considering the ListView case), but it should try to
635                     // include most common control types that find themselves
636                     // placed in menus.
637                     final String nodeType = node.getTypeSelector();
638                     switch (nodeType) {
639                         case &quot;Button&quot;:
640                         case &quot;Hyperlink&quot;:
641                         case &quot;Label&quot;:
642                             customMenuItem.setHideOnClick(true);
643                             break;
644                         case &quot;CheckBox&quot;:
645                         case &quot;ChoiceBox&quot;:
646                         case &quot;ColorPicker&quot;:
647                         case &quot;ComboBox&quot;:
648                         case &quot;DatePicker&quot;:
649                         case &quot;MenuButton&quot;:
650                         case &quot;PasswordField&quot;:
651                         case &quot;RadioButton&quot;:
652                         case &quot;ScrollBar&quot;:
653                         case &quot;ScrollPane&quot;:
654                         case &quot;Slider&quot;:
655                         case &quot;SplitMenuButton&quot;:
656                         case &quot;SplitPane&quot;:
657                         case &quot;TextArea&quot;:
658                         case &quot;TextField&quot;:
659                         case &quot;ToggleButton&quot;:
660                         case &quot;ToolBar&quot;:
661                         default:
662                             customMenuItem.setHideOnClick(false);
663                             break;
664                     }
665 
666                     overflowMenuItems.add(customMenuItem);
667                 }
668             }
669         }
670 
671         // Check if we overflowed.
672         overflow = overflowMenuItems.size() &gt; 0;
673         if (!overflow &amp;&amp; overflowMenu.isFocused()) {
674             Node last = engine.selectLast();
675             if (last != null) {
676                 last.requestFocus();
677             }
678         }
679         overflowMenu.setVisible(overflow);
680         overflowMenu.setManaged(overflow);
681     }
682 
683     private void addNodesToToolBar() {
684         final ToolBar toolbar = getSkinnable();
685         double toolbarLength = getToolbarLength(toolbar);
686 
687         // Is there overflow ?
688         boolean hasOverflow = isOverflowed(toolbarLength);
689 
690         organizeOverflow(toolbarLength, hasOverflow);
691     }
692 
693     private double getToolbarLength(ToolBar toolbar) {
694         double length;
695         if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
696             length = snapSizeY(toolbar.getHeight()) - snappedTopInset() - snappedBottomInset() + getSpacing();
697         } else {
698             length = snapSizeX(toolbar.getWidth()) - snappedLeftInset() - snappedRightInset() + getSpacing();
699         }
700         return length;
701     }
702 
703     private boolean isOverflowed(double length) {
704         double x = 0;
705         boolean hasOverflow = false;
706         for (Node node : getSkinnable().getItems()) {
707             if (!node.isManaged()) continue;
708             if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
709                 x += snapSizeY(node.prefHeight(-1)) + getSpacing();
710             } else {
711                 x += snapSizeX(node.prefWidth(-1)) + getSpacing();
712             }
713             if (x &gt; length) {
714                 hasOverflow = true;
715                 break;
716             }
717         }
718         return hasOverflow;
719     }
720 
721     /***************************************************************************
722      *                                                                         *
723      * Support classes                                                         *
724      *                                                                         *
725      **************************************************************************/
726 
727     class ToolBarOverflowMenu extends StackPane {
728         private StackPane downArrow;
729         private ContextMenu popup;
730         private ObservableList&lt;MenuItem&gt; menuItems;
731 
732         public ToolBarOverflowMenu(ObservableList&lt;MenuItem&gt; items) {
733             getStyleClass().setAll(&quot;tool-bar-overflow-button&quot;);
734             setAccessibleRole(AccessibleRole.BUTTON);
735             setAccessibleText(getString(&quot;Accessibility.title.ToolBar.OverflowButton&quot;));
736             setFocusTraversable(true);
737             this.menuItems = items;
738             downArrow = new StackPane();
739             downArrow.getStyleClass().setAll(&quot;arrow&quot;);
740             downArrow.setOnMousePressed(me -&gt; {
741                 fire();
742             });
743 
744             setOnKeyPressed(ke -&gt; {
745                 if (KeyCode.SPACE.equals(ke.getCode())) {
746                     if (!popup.isShowing()) {
747                         popup.getItems().clear();
748                         popup.getItems().addAll(menuItems);
749                         popup.show(downArrow, Side.BOTTOM, 0, 0);
750                     }
751                     ke.consume();
752                 } else if (KeyCode.ESCAPE.equals(ke.getCode())) {
753                     if (popup.isShowing()) {
754                         popup.hide();
755                     }
756                     ke.consume();
757                 } else if (KeyCode.ENTER.equals(ke.getCode())) {
758                     fire();
759                     ke.consume();
760                 }
761             });
762 
763             visibleProperty().addListener((observable, oldValue, newValue) -&gt; {
764                     if (newValue) {
765                         if (box.getChildren().isEmpty()) {
766                             setFocusTraversable(true);
767                         }
768                     }
769             });
770             popup = new ContextMenu();
771             setVisible(false);
772             setManaged(false);
773             getChildren().add(downArrow);
774         }
775 
776         private void fire() {
777             if (popup.isShowing()) {
778                 popup.hide();
779             } else {
780                 popup.getItems().clear();
781                 popup.getItems().addAll(menuItems);
782                 popup.show(downArrow, Side.BOTTOM, 0, 0);
783             }
784         }
785 
786         @Override protected double computePrefWidth(double height) {
787             return snappedLeftInset() + snappedRightInset();
788         }
789 
790         @Override protected double computePrefHeight(double width) {
791             return snappedTopInset() + snappedBottomInset();
792         }
793 
794         @Override protected void layoutChildren() {
795             double w = snapSize(downArrow.prefWidth(-1));
796             double h = snapSize(downArrow.prefHeight(-1));
797             double x = (snapSize(getWidth()) - w)/2;
798             double y = (snapSize(getHeight()) - h)/2;
799 
800             // TODO need to provide support for when the toolbar is on the right
801             // or bottom
802             if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
803                 downArrow.setRotate(0);
804             }
805 
806             downArrow.resize(w, h);
807             positionInArea(downArrow, x, y, w, h,
808                     /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
809         }
810 
811         /** {@inheritDoc} */
812         @Override
813         public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
814             switch (action) {
815                 case FIRE: fire(); break;
816                 default: super.executeAccessibleAction(action); break;
817             }
818         }
819     }
820 
821     /***************************************************************************
822      *                                                                         *
823      *                         Stylesheet Handling                             *
824      *                                                                         *
825      **************************************************************************/
826 
827      /*
828       * Super-lazy instantiation pattern from Bill Pugh.
829       */
830      private static class StyleableProperties {
831          private static final CssMetaData&lt;ToolBar,Number&gt; SPACING =
832              new CssMetaData&lt;ToolBar,Number&gt;(&quot;-fx-spacing&quot;,
833                  SizeConverter.getInstance(), 0.0) {
834 
835             @Override
836             public boolean isSettable(ToolBar n) {
837                 final ToolBarSkin skin = (ToolBarSkin) n.getSkin();
838                 return skin.spacing == null || !skin.spacing.isBound();
839             }
840 
841             @Override
842             public StyleableProperty&lt;Number&gt; getStyleableProperty(ToolBar n) {
843                 final ToolBarSkin skin = (ToolBarSkin) n.getSkin();
844                 return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)skin.spacingProperty();
845             }
846         };
847 
848         private static final CssMetaData&lt;ToolBar,Pos&gt;ALIGNMENT =
849                 new CssMetaData&lt;ToolBar,Pos&gt;(&quot;-fx-alignment&quot;,
850                 new EnumConverter&lt;Pos&gt;(Pos.class), Pos.TOP_LEFT ) {
851 
852             @Override
853             public boolean isSettable(ToolBar n) {
854                 final ToolBarSkin skin = (ToolBarSkin) n.getSkin();
855                 return skin.boxAlignment == null || !skin.boxAlignment.isBound();
856             }
857 
858             @Override
859             public StyleableProperty&lt;Pos&gt; getStyleableProperty(ToolBar n) {
860                 final ToolBarSkin skin = (ToolBarSkin) n.getSkin();
861                 return (StyleableProperty&lt;Pos&gt;)(WritableValue&lt;Pos&gt;)skin.boxAlignmentProperty();
862             }
863         };
864 
865 
866          private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
867          static {
868 
869             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
870                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
871 
872             // StackPane also has -fx-alignment. Replace it with
873             // ToolBarSkin&#39;s.
874             // TODO: Really should be able to reference StackPane.StyleableProperties.ALIGNMENT
875             final String alignmentProperty = ALIGNMENT.getProperty();
876             for (int n=0, nMax=styleables.size(); n&lt;nMax; n++) {
877                 final CssMetaData&lt;?,?&gt; prop = styleables.get(n);
878                 if (alignmentProperty.equals(prop.getProperty())) styleables.remove(prop);
879             }
880 
881             styleables.add(SPACING);
882             styleables.add(ALIGNMENT);
883             STYLEABLES = Collections.unmodifiableList(styleables);
884 
885          }
886     }
887 
888     /**
889      * Returns the CssMetaData associated with this class, which may include the
890      * CssMetaData of its superclasses.
891      * @return the CssMetaData associated with this class, which may include the
892      * CssMetaData of its superclasses
893      */
894     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
895         return StyleableProperties.STYLEABLES;
896     }
897 
898     /**
899      * {@inheritDoc}
900      */
901     @Override
902     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
903         return getClassCssMetaData();
904     }
905 
906     @Override
907     protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
908         switch (attribute) {
909             case OVERFLOW_BUTTON: return overflowMenu;
910             default: return super.queryAccessibleAttribute(attribute, parameters);
911         }
912     }
913 
914     @Override
915     protected void executeAccessibleAction(AccessibleAction action, Object... parameters) {
916         switch (action) {
917             case SHOW_MENU:
918                 overflowMenu.fire();
919                 break;
920             default: super.executeAccessibleAction(action, parameters);
921         }
922     }
923 }
    </pre>
  </body>
</html>
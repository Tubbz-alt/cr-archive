<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.controls/src/main/java/javafx/scene/control/skin/ToolBarSkin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javafx.scene.control.skin;
 27 
 28 import com.sun.javafx.scene.NodeHelper;
 29 import com.sun.javafx.scene.ParentHelper;
 30 import java.util.ArrayList;
 31 import java.util.Collections;
 32 import java.util.List;
 33 
 34 import com.sun.javafx.scene.control.behavior.BehaviorBase;
 35 import com.sun.javafx.scene.traversal.Algorithm;
 36 import com.sun.javafx.scene.traversal.ParentTraversalEngine;
 37 import com.sun.javafx.scene.traversal.TraversalContext;
 38 
 39 import javafx.beans.property.ObjectProperty;
 40 import javafx.beans.property.DoubleProperty;
 41 import javafx.beans.value.WritableValue;
 42 import javafx.collections.FXCollections;
 43 import javafx.collections.ListChangeListener;
 44 import javafx.collections.ObservableList;
 45 import javafx.geometry.HPos;
 46 import javafx.geometry.Orientation;
 47 import javafx.geometry.Pos;
 48 import javafx.geometry.Side;
 49 import javafx.geometry.VPos;
 50 import javafx.scene.AccessibleAction;
 51 import javafx.scene.AccessibleAttribute;
 52 import javafx.scene.AccessibleRole;
 53 import javafx.scene.Node;
 54 import javafx.scene.Parent;
 55 import javafx.scene.control.ContextMenu;
 56 import javafx.scene.control.Control;
 57 import javafx.scene.control.MenuItem;
 58 import javafx.scene.control.CustomMenuItem;
 59 import javafx.scene.control.Separator;
 60 import javafx.scene.control.SeparatorMenuItem;
 61 import javafx.scene.control.SkinBase;
 62 import javafx.scene.control.ToolBar;
 63 import javafx.scene.input.KeyCode;
 64 import javafx.scene.layout.HBox;
 65 import javafx.scene.layout.Pane;
 66 import javafx.scene.layout.StackPane;
 67 import javafx.scene.layout.VBox;
 68 import javafx.css.StyleableDoubleProperty;
 69 import javafx.css.StyleableObjectProperty;
 70 import javafx.css.StyleableProperty;
 71 import javafx.css.CssMetaData;
 72 
 73 import javafx.css.converter.EnumConverter;
 74 import javafx.css.converter.SizeConverter;
 75 import com.sun.javafx.scene.control.behavior.ToolBarBehavior;
 76 import com.sun.javafx.scene.traversal.Direction;
 77 
 78 import javafx.css.Styleable;
 79 
 80 import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;
 81 
 82 /**
 83  * Default skin implementation for the {@link ToolBar} control.
 84  *
 85  * @see ToolBar
 86  * @since 9
 87  */
 88 public class ToolBarSkin extends SkinBase&lt;ToolBar&gt; {
 89 
 90     /***************************************************************************
 91      *                                                                         *
 92      * Private fields                                                          *
 93      *                                                                         *
 94      **************************************************************************/
 95 
 96     private Pane box;
 97     private ToolBarOverflowMenu overflowMenu;
 98     private boolean overflow = false;
 99     private double previousWidth = 0;
100     private double previousHeight = 0;
101     private double savedPrefWidth = 0;
102     private double savedPrefHeight = 0;
103     private ObservableList&lt;MenuItem&gt; overflowMenuItems;
104     private boolean needsUpdate = false;
105     private final ParentTraversalEngine engine;
106     private final BehaviorBase&lt;ToolBar&gt; behavior;
107 
108 
109 
110     /***************************************************************************
111      *                                                                         *
112      * Constructors                                                            *
113      *                                                                         *
114      **************************************************************************/
115 
116     /**
117      * Creates a new ToolBarSkin instance, installing the necessary child
118      * nodes into the Control {@link Control#getChildren() children} list, as
119      * well as the necessary input mappings for handling key, mouse, etc events.
120      *
121      * @param control The control that this skin should be installed onto.
122      */
123     public ToolBarSkin(ToolBar control) {
124         super(control);
125 
126         // install default input map for the ToolBar control
127         behavior = new ToolBarBehavior(control);
128 //        control.setInputMap(behavior.getInputMap());
129 
130         overflowMenuItems = FXCollections.observableArrayList();
131         initialize();
132         registerChangeListener(control.orientationProperty(), e -&gt; initialize());
133 
134         engine = new ParentTraversalEngine(getSkinnable(), new Algorithm() {
135 
136             private Node selectPrev(int from, TraversalContext context) {
137                 for (int i = from; i &gt;= 0; --i) {
138                     Node n = box.getChildren().get(i);
139                     if (n.isDisabled() || !NodeHelper.isTreeShowing(n)) continue;
140                     if (n instanceof Parent) {
141                         Node selected = context.selectLastInParent((Parent)n);
142                         if (selected != null) return selected;
143                     }
144                     if (n.isFocusTraversable() ) {
145                         return n;
146                     }
147                 }
148                 return null;
149             }
150 
151             private Node selectNext(int from, TraversalContext context) {
152                 for (int i = from, max = box.getChildren().size(); i &lt; max; ++i) {
153                     Node n = box.getChildren().get(i);
154                     if (n.isDisabled() || !NodeHelper.isTreeShowing(n)) continue;
155                     if (n.isFocusTraversable()) {
156                         return n;
157                     }
158                     if (n instanceof Parent) {
159                         Node selected = context.selectFirstInParent((Parent)n);
160                         if (selected != null) return selected;
161                     }
162                 }
163                 return null;
164             }
165 
166             @Override
167             public Node select(Node owner, Direction dir, TraversalContext context) {
168 
169                 dir = dir.getDirectionForNodeOrientation(control.getEffectiveNodeOrientation());
170 
171                 final ObservableList&lt;Node&gt; boxChildren = box.getChildren();
172                 if (owner == overflowMenu) {
173                     if (dir.isForward()) {
174                         return null;
175                     } else {
176                         Node selected = selectPrev(boxChildren.size() - 1, context);
177                         if (selected != null) return selected;
178                     }
179                 }
180 
181                 int idx = boxChildren.indexOf(owner);
182 
183                 if (idx &lt; 0) {
184                     // The current focus owner is a child of some Toolbar&#39;s item
185                     Parent item = owner.getParent();
186                     while (!boxChildren.contains(item)) {
187                         item = item.getParent();
188                     }
189                     Node selected = context.selectInSubtree(item, owner, dir);
190                     if (selected != null) return selected;
191                     idx = boxChildren.indexOf(item);
192                     if (dir == Direction.NEXT) dir = Direction.NEXT_IN_LINE;
193                 }
194 
195                 if (idx &gt;= 0) {
196                     if (dir.isForward()) {
197                         Node selected = selectNext(idx + 1, context);
198                         if (selected != null) return selected;
199                         if (overflow) {
200                             overflowMenu.requestFocus();
201                             return overflowMenu;
202                         }
203                     } else {
204                         Node selected = selectPrev(idx - 1, context);
205                         if (selected != null) return selected;
206                     }
207                 }
208                 return null;
209             }
210 
211             @Override
212             public Node selectFirst(TraversalContext context) {
213                 Node selected = selectNext(0, context);
214                 if (selected != null) return selected;
215                 if (overflow) {
216                     return overflowMenu;
217                 }
218                 return null;
219             }
220 
221             @Override
222             public Node selectLast(TraversalContext context) {
223                 if (overflow) {
224                     return overflowMenu;
225                 }
226                 return selectPrev(box.getChildren().size() - 1, context);
227             }
228         });
229         ParentHelper.setTraversalEngine(getSkinnable(), engine);
230 
231         control.focusedProperty().addListener((observable, oldValue, newValue) -&gt; {
232             if (newValue) {
233                 // TODO need to detect the focus direction
234                 // to selected the first control in the toolbar when TAB is pressed
235                 // or select the last control in the toolbar when SHIFT TAB is pressed.
236                 if (!box.getChildren().isEmpty()) {
237                     box.getChildren().get(0).requestFocus();
238                 } else {
239                     overflowMenu.requestFocus();
240                 }
241             }
242         });
243 
244         control.getItems().addListener((ListChangeListener&lt;Node&gt;) c -&gt; {
245             while (c.next()) {
246                 for (Node n: c.getRemoved()) {
247                     box.getChildren().remove(n);
248                 }
249                 box.getChildren().addAll(c.getAddedSubList());
250             }
251             needsUpdate = true;
252             getSkinnable().requestLayout();
253         });
254     }
255 
256 
257 
258     /***************************************************************************
259      *                                                                         *
260      * Properties                                                              *
261      *                                                                         *
262      **************************************************************************/
263 
264     private double snapSpacing(double value) {
265         if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
266             return snapSpaceY(value);
267         } else {
268             return snapSpaceX(value);
269         }
270     }
271 
272     // --- spacing
273     private DoubleProperty spacing;
274     private final void setSpacing(double value) {
275         spacingProperty().set(snapSpacing(value));
276     }
277 
278     private final double getSpacing() {
279         return spacing == null ? 0.0 : snapSpacing(spacing.get());
280     }
281 
282     private final DoubleProperty spacingProperty() {
283         if (spacing == null) {
284             spacing = new StyleableDoubleProperty() {
285 
286                 @Override
287                 protected void invalidated() {
288                     final double value = get();
289                     if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
290                         ((VBox)box).setSpacing(value);
291                     } else {
292                         ((HBox)box).setSpacing(value);
293                     }
294                 }
295 
296                 @Override
297                 public Object getBean() {
298                     return ToolBarSkin.this;
299                 }
300 
301                 @Override
302                 public String getName() {
303                     return &quot;spacing&quot;;
304                 }
305 
306                 @Override
307                 public CssMetaData&lt;ToolBar,Number&gt; getCssMetaData() {
308                     return StyleableProperties.SPACING;
309                 }
310             };
311         }
312         return spacing;
313     }
314 
315     // --- box alignment
316     private ObjectProperty&lt;Pos&gt; boxAlignment;
317     private final void setBoxAlignment(Pos value) {
318         boxAlignmentProperty().set(value);
319     }
320 
321     private final Pos getBoxAlignment() {
322         return boxAlignment == null ? Pos.TOP_LEFT : boxAlignment.get();
323     }
324 
325     private final ObjectProperty&lt;Pos&gt; boxAlignmentProperty() {
326         if (boxAlignment == null) {
327             boxAlignment = new StyleableObjectProperty&lt;Pos&gt;(Pos.TOP_LEFT) {
328 
329                 @Override
330                 public void invalidated() {
331                     final Pos value = get();
332                     if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
333                         ((VBox)box).setAlignment(value);
334                     } else {
335                         ((HBox)box).setAlignment(value);
336                     }
337                 }
338 
339                 @Override
340                 public Object getBean() {
341                     return ToolBarSkin.this;
342                 }
343 
344                 @Override
345                 public String getName() {
346                     return &quot;boxAlignment&quot;;
347                 }
348 
349                 @Override
350                 public CssMetaData&lt;ToolBar,Pos&gt; getCssMetaData() {
351                     return StyleableProperties.ALIGNMENT;
352                 }
353             };
354         }
355         return boxAlignment;
356     }
357 
358 
359 
360     /***************************************************************************
361      *                                                                         *
362      * Public API                                                              *
363      *                                                                         *
364      **************************************************************************/
365 
366     /** {@inheritDoc} */
367     @Override public void dispose() {
368         super.dispose();
369 
370         if (behavior != null) {
371             behavior.dispose();
372         }
373     }
374 
375     /** {@inheritDoc} */
376     @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
377         final ToolBar toolbar = getSkinnable();
378         return toolbar.getOrientation() == Orientation.VERTICAL ?
379             computePrefWidth(-1, topInset, rightInset, bottomInset, leftInset) :
380             snapSizeX(overflowMenu.prefWidth(-1)) + leftInset + rightInset;
381     }
382 
383     /** {@inheritDoc} */
384     @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
385         final ToolBar toolbar = getSkinnable();
386         return toolbar.getOrientation() == Orientation.VERTICAL?
387             snapSizeY(overflowMenu.prefHeight(-1)) + topInset + bottomInset :
388             computePrefHeight(-1, topInset, rightInset, bottomInset, leftInset);
389     }
390 
391     /** {@inheritDoc} */
392     @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
393         double prefWidth = 0;
394         final ToolBar toolbar = getSkinnable();
395 
396         if (toolbar.getOrientation() == Orientation.HORIZONTAL) {
397             for (Node node : toolbar.getItems()) {
398                 if (!node.isManaged()) continue;
399                 prefWidth += snapSizeX(node.prefWidth(-1)) + getSpacing();
400             }
401             prefWidth -= getSpacing();
402         } else {
403             for (Node node : toolbar.getItems()) {
404                 if (!node.isManaged()) continue;
405                 prefWidth = Math.max(prefWidth, snapSizeX(node.prefWidth(-1)));
406             }
407             if (toolbar.getItems().size() &gt; 0) {
408                 savedPrefWidth = prefWidth;
409             } else {
410                 prefWidth = savedPrefWidth;
411             }
412         }
413         return leftInset + prefWidth + rightInset;
414     }
415 
416     /** {@inheritDoc} */
417     @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
418         double prefHeight = 0;
419         final ToolBar toolbar = getSkinnable();
420 
421         if(toolbar.getOrientation() == Orientation.VERTICAL) {
422             for (Node node: toolbar.getItems()) {
423                 if (!node.isManaged()) continue;
424                 prefHeight += snapSizeY(node.prefHeight(-1)) + getSpacing();
425             }
426             prefHeight -= getSpacing();
427         } else {
428             for (Node node : toolbar.getItems()) {
429                 if (!node.isManaged()) continue;
430                 prefHeight = Math.max(prefHeight, snapSizeY(node.prefHeight(-1)));
431             }
432             if (toolbar.getItems().size() &gt; 0) {
433                 savedPrefHeight = prefHeight;
434             } else {
435                 prefHeight = savedPrefHeight;
436             }
437         }
438         return topInset + prefHeight + bottomInset;
439     }
440 
441     /** {@inheritDoc} */
442     @Override protected double computeMaxWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
443         return getSkinnable().getOrientation() == Orientation.VERTICAL ?
444                 snapSizeX(getSkinnable().prefWidth(-1)) : Double.MAX_VALUE;
445     }
446 
447     /** {@inheritDoc} */
448     @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
449         return getSkinnable().getOrientation() == Orientation.VERTICAL ?
450                 Double.MAX_VALUE : snapSizeY(getSkinnable().prefHeight(-1));
451     }
452 
453     /** {@inheritDoc} */
454     @Override protected void layoutChildren(final double x,final double y,
455             final double w, final double h) {
456 //        super.layoutChildren();
457         final ToolBar toolbar = getSkinnable();
458 
459         double toolbarLength = getToolbarLength(toolbar);
460         if (toolbar.getOrientation() == Orientation.VERTICAL) {
461             if (snapSizeY(toolbar.getHeight()) != previousHeight || needsUpdate) {
462                 ((VBox)box).setSpacing(getSpacing());
463                 ((VBox)box).setAlignment(getBoxAlignment());
464                 previousHeight = snapSizeY(toolbar.getHeight());
465                 addNodesToToolBar();
466             } else {
467                 correctOverflow(toolbarLength);
468             }
469         } else {
470             if (snapSizeX(toolbar.getWidth()) != previousWidth || needsUpdate) {
471                 ((HBox)box).setSpacing(getSpacing());
472                 ((HBox)box).setAlignment(getBoxAlignment());
473                 previousWidth = snapSizeX(toolbar.getWidth());
474                 addNodesToToolBar();
475             } else {
476                 correctOverflow(toolbarLength);
477             }
478         }
479 
480         needsUpdate = false;
481 
482         double toolbarWidth = w;
483         double toolbarHeight = h;
484 
485         if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
486             toolbarHeight -= (overflow ? snapSizeY(overflowMenu.prefHeight(-1)) : 0);
487         } else {
488             toolbarWidth -= (overflow ? snapSizeX(overflowMenu.prefWidth(-1)) : 0);
489         }
490 
491         box.resize(toolbarWidth, toolbarHeight);
492         positionInArea(box, x, y,
493                 toolbarWidth, toolbarHeight, /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
494 
495         // If popup menu is not null show the overflowControl
496         if (overflow) {
497             double overflowMenuWidth = snapSizeX(overflowMenu.prefWidth(-1));
498             double overflowMenuHeight = snapSizeY(overflowMenu.prefHeight(-1));
499             double overflowX = x;
500             double overflowY = x;
501             if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
502                 // This is to prevent the overflow menu from moving when there
503                 // are no items in the toolbar.
504                 if (toolbarWidth == 0) {
505                     toolbarWidth = savedPrefWidth;
506                 }
507                 HPos pos = ((VBox)box).getAlignment().getHpos();
508                 if (HPos.LEFT.equals(pos)) {
509                     overflowX = x + Math.abs((toolbarWidth - overflowMenuWidth)/2);
510                 } else if (HPos.RIGHT.equals(pos)) {
511                     overflowX = (snapSizeX(toolbar.getWidth()) - snappedRightInset() - toolbarWidth) +
512                         Math.abs((toolbarWidth - overflowMenuWidth)/2);
513                 } else {
514                     overflowX = x +
515                         Math.abs((snapSizeX(toolbar.getWidth()) - (x) +
516                         snappedRightInset() - overflowMenuWidth)/2);
517                 }
518                 overflowY = snapSizeY(toolbar.getHeight()) - overflowMenuHeight - y;
519             } else {
520                 // This is to prevent the overflow menu from moving when there
521                 // are no items in the toolbar.
522                 if (toolbarHeight == 0) {
523                     toolbarHeight = savedPrefHeight;
524                 }
525                 VPos pos = ((HBox)box).getAlignment().getVpos();
526                 if (VPos.TOP.equals(pos)) {
527                     overflowY = y +
528                         Math.abs((toolbarHeight - overflowMenuHeight)/2);
529                 } else if (VPos.BOTTOM.equals(pos)) {
530                     overflowY = (snapSizeY(toolbar.getHeight()) - snappedBottomInset() - toolbarHeight) +
531                         Math.abs((toolbarHeight - overflowMenuHeight)/2);
532                 } else {
533                     overflowY = y + Math.abs((toolbarHeight - overflowMenuHeight)/2);
534                 }
535                overflowX = snapSizeX(toolbar.getWidth()) - overflowMenuWidth - snappedRightInset();
536             }
537             overflowMenu.resize(overflowMenuWidth, overflowMenuHeight);
538             positionInArea(overflowMenu, overflowX, overflowY, overflowMenuWidth, overflowMenuHeight, /*baseline ignored*/0,
539                     HPos.CENTER, VPos.CENTER);
540         }
541     }
542 
543     /***************************************************************************
544      *                                                                         *
545      * Private implementation                                                  *
546      *                                                                         *
547      **************************************************************************/
548 
549     private void initialize() {
550         if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
551             box = new VBox();
552         } else {
553             box = new HBox();
554         }
555         box.getStyleClass().add(&quot;container&quot;);
556         box.getChildren().addAll(getSkinnable().getItems());
557         overflowMenu = new ToolBarOverflowMenu(overflowMenuItems);
558         overflowMenu.setVisible(false);
559         overflowMenu.setManaged(false);
560 
561         getChildren().clear();
562         getChildren().add(box);
563         getChildren().add(overflowMenu);
564 
565         previousWidth = 0;
566         previousHeight = 0;
567         savedPrefWidth = 0;
568         savedPrefHeight = 0;
569         needsUpdate = true;
570         getSkinnable().requestLayout();
571     }
572 
573     private void correctOverflow(double length) {
574         boolean overflowed = isOverflowed(length);
575         if (overflowed != overflow) {
576             organizeOverflow(length, overflow);
577         }
578     }
579 
580     private void organizeOverflow(double length, boolean hasOverflow) {
581         if (hasOverflow) {
582             if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
583                 length -= snapSizeY(overflowMenu.prefHeight(-1));
584             } else {
585                 length -= snapSizeX(overflowMenu.prefWidth(-1));
586             }
587             length -= getSpacing();
588         }
589 
590         // Determine which node goes to the toolbar and which goes to the overflow.
591 
592         double x = 0;
593         overflowMenuItems.clear();
594         box.getChildren().clear();
595         for (Node node : getSkinnable().getItems()) {
596             node.getStyleClass().remove(&quot;menu-item&quot;);
597             node.getStyleClass().remove(&quot;custom-menu-item&quot;);
598 
599             if (node.isManaged()) {
600                 if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
601                     x += snapSizeY(node.prefHeight(-1)) + getSpacing();
602                 } else {
603                     x += snapSizeX(node.prefWidth(-1)) + getSpacing();
604                 }
605             }
606 
607             if (x &lt;= length) {
608                 box.getChildren().add(node);
609             } else {
610                 if (node.isFocused()) {
611                     if (!box.getChildren().isEmpty()) {
612                         Node last = engine.selectLast();
613                         if (last != null) {
614                             last.requestFocus();
615                         }
616                     } else {
617                         overflowMenu.requestFocus();
618                     }
619                 }
620                 if (node instanceof Separator) {
621                     overflowMenuItems.add(new SeparatorMenuItem());
622                 } else {
623                     CustomMenuItem customMenuItem = new CustomMenuItem(node);
624 
625                     // RT-36455:
626                     // We can&#39;t be totally certain of all nodes, but for the
627                     // most common nodes we can check to see whether we should
628                     // hide the menu when the node is clicked on. The common
629                     // case is for TextField or Slider.
630                     // This list won&#39;t be exhaustive (there is no point really
631                     // considering the ListView case), but it should try to
632                     // include most common control types that find themselves
633                     // placed in menus.
634                     final String nodeType = node.getTypeSelector();
635                     switch (nodeType) {
636                         case &quot;Button&quot;:
637                         case &quot;Hyperlink&quot;:
638                         case &quot;Label&quot;:
639                             customMenuItem.setHideOnClick(true);
640                             break;
641                         case &quot;CheckBox&quot;:
642                         case &quot;ChoiceBox&quot;:
643                         case &quot;ColorPicker&quot;:
644                         case &quot;ComboBox&quot;:
645                         case &quot;DatePicker&quot;:
646                         case &quot;MenuButton&quot;:
647                         case &quot;PasswordField&quot;:
648                         case &quot;RadioButton&quot;:
649                         case &quot;ScrollBar&quot;:
650                         case &quot;ScrollPane&quot;:
651                         case &quot;Slider&quot;:
652                         case &quot;SplitMenuButton&quot;:
653                         case &quot;SplitPane&quot;:
654                         case &quot;TextArea&quot;:
655                         case &quot;TextField&quot;:
656                         case &quot;ToggleButton&quot;:
657                         case &quot;ToolBar&quot;:
658                         default:
659                             customMenuItem.setHideOnClick(false);
660                             break;
661                     }
662 
663                     overflowMenuItems.add(customMenuItem);
664                 }
665             }
666         }
667 
668         // Check if we overflowed.
669         overflow = overflowMenuItems.size() &gt; 0;
670         if (!overflow &amp;&amp; overflowMenu.isFocused()) {
671             Node last = engine.selectLast();
672             if (last != null) {
673                 last.requestFocus();
674             }
675         }
676         overflowMenu.setVisible(overflow);
677         overflowMenu.setManaged(overflow);
678     }
679 
680     private void addNodesToToolBar() {
681         final ToolBar toolbar = getSkinnable();
682         double toolbarLength = getToolbarLength(toolbar);
683 
684         // Is there overflow ?
685         boolean hasOverflow = isOverflowed(toolbarLength);
686 
687         organizeOverflow(toolbarLength, hasOverflow);
688     }
689 
690     private double getToolbarLength(ToolBar toolbar) {
691         double length;
692         if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
693             length = snapSizeY(toolbar.getHeight()) - snappedTopInset() - snappedBottomInset() + getSpacing();
694         } else {
695             length = snapSizeX(toolbar.getWidth()) - snappedLeftInset() - snappedRightInset() + getSpacing();
696         }
697         return length;
698     }
699 
700     private boolean isOverflowed(double length) {
701         double x = 0;
702         boolean hasOverflow = false;
703         for (Node node : getSkinnable().getItems()) {
704             if (!node.isManaged()) continue;
705             if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
706                 x += snapSizeY(node.prefHeight(-1)) + getSpacing();
707             } else {
708                 x += snapSizeX(node.prefWidth(-1)) + getSpacing();
709             }
710             if (x &gt; length) {
711                 hasOverflow = true;
712                 break;
713             }
714         }
715         return hasOverflow;
716     }
717 
718     /***************************************************************************
719      *                                                                         *
720      * Support classes                                                         *
721      *                                                                         *
722      **************************************************************************/
723 
724     class ToolBarOverflowMenu extends StackPane {
725         private StackPane downArrow;
726         private ContextMenu popup;
727         private ObservableList&lt;MenuItem&gt; menuItems;
728 
729         public ToolBarOverflowMenu(ObservableList&lt;MenuItem&gt; items) {
730             getStyleClass().setAll(&quot;tool-bar-overflow-button&quot;);
731             setAccessibleRole(AccessibleRole.BUTTON);
732             setAccessibleText(getString(&quot;Accessibility.title.ToolBar.OverflowButton&quot;));
733             setFocusTraversable(true);
734             this.menuItems = items;
735             downArrow = new StackPane();
736             downArrow.getStyleClass().setAll(&quot;arrow&quot;);
737             downArrow.setOnMousePressed(me -&gt; {
738                 fire();
739             });
740 
741             setOnKeyPressed(ke -&gt; {
742                 if (KeyCode.SPACE.equals(ke.getCode())) {
743                     if (!popup.isShowing()) {
744                         popup.getItems().clear();
745                         popup.getItems().addAll(menuItems);
746                         popup.show(downArrow, Side.BOTTOM, 0, 0);
747                     }
748                     ke.consume();
749                 } else if (KeyCode.ESCAPE.equals(ke.getCode())) {
750                     if (popup.isShowing()) {
751                         popup.hide();
752                     }
753                     ke.consume();
754                 } else if (KeyCode.ENTER.equals(ke.getCode())) {
755                     fire();
756                     ke.consume();
757                 }
758             });
759 
760             visibleProperty().addListener((observable, oldValue, newValue) -&gt; {
761                     if (newValue) {
762                         if (box.getChildren().isEmpty()) {
763                             setFocusTraversable(true);
764                         }
765                     }
766             });
767             popup = new ContextMenu();
768             setVisible(false);
769             setManaged(false);
770             getChildren().add(downArrow);
771         }
772 
773         private void fire() {
774             if (popup.isShowing()) {
775                 popup.hide();
776             } else {
777                 popup.getItems().clear();
778                 popup.getItems().addAll(menuItems);
779                 popup.show(downArrow, Side.BOTTOM, 0, 0);
780             }
781         }
782 
783         @Override protected double computePrefWidth(double height) {
784             return snappedLeftInset() + snappedRightInset();
785         }
786 
787         @Override protected double computePrefHeight(double width) {
788             return snappedTopInset() + snappedBottomInset();
789         }
790 
791         @Override protected void layoutChildren() {
792             double w = snapSize(downArrow.prefWidth(-1));
793             double h = snapSize(downArrow.prefHeight(-1));
794             double x = (snapSize(getWidth()) - w)/2;
795             double y = (snapSize(getHeight()) - h)/2;
796 
797             // TODO need to provide support for when the toolbar is on the right
798             // or bottom
799             if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
800                 downArrow.setRotate(0);
801             }
802 
803             downArrow.resize(w, h);
804             positionInArea(downArrow, x, y, w, h,
805                     /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
806         }
807 
808         /** {@inheritDoc} */
809         @Override
810         public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
811             switch (action) {
812                 case FIRE: fire(); break;
813                 default: super.executeAccessibleAction(action); break;
814             }
815         }
816     }
817 
818     /***************************************************************************
819      *                                                                         *
820      *                         Stylesheet Handling                             *
821      *                                                                         *
822      **************************************************************************/
823 
824      /*
825       * Super-lazy instantiation pattern from Bill Pugh.
826       */
827      private static class StyleableProperties {
828          private static final CssMetaData&lt;ToolBar,Number&gt; SPACING =
829              new CssMetaData&lt;ToolBar,Number&gt;(&quot;-fx-spacing&quot;,
830                  SizeConverter.getInstance(), 0.0) {
831 
832             @Override
833             public boolean isSettable(ToolBar n) {
834                 final ToolBarSkin skin = (ToolBarSkin) n.getSkin();
835                 return skin.spacing == null || !skin.spacing.isBound();
836             }
837 
838             @Override
839             public StyleableProperty&lt;Number&gt; getStyleableProperty(ToolBar n) {
840                 final ToolBarSkin skin = (ToolBarSkin) n.getSkin();
841                 return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)skin.spacingProperty();
842             }
843         };
844 
845         private static final CssMetaData&lt;ToolBar,Pos&gt;ALIGNMENT =
846                 new CssMetaData&lt;ToolBar,Pos&gt;(&quot;-fx-alignment&quot;,
847                 new EnumConverter&lt;Pos&gt;(Pos.class), Pos.TOP_LEFT ) {
848 
849             @Override
850             public boolean isSettable(ToolBar n) {
851                 final ToolBarSkin skin = (ToolBarSkin) n.getSkin();
852                 return skin.boxAlignment == null || !skin.boxAlignment.isBound();
853             }
854 
855             @Override
856             public StyleableProperty&lt;Pos&gt; getStyleableProperty(ToolBar n) {
857                 final ToolBarSkin skin = (ToolBarSkin) n.getSkin();
858                 return (StyleableProperty&lt;Pos&gt;)(WritableValue&lt;Pos&gt;)skin.boxAlignmentProperty();
859             }
860         };
861 
862 
863          private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
864          static {
865 
866             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
867                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
868 
869             // StackPane also has -fx-alignment. Replace it with
870             // ToolBarSkin&#39;s.
871             // TODO: Really should be able to reference StackPane.StyleableProperties.ALIGNMENT
872             final String alignmentProperty = ALIGNMENT.getProperty();
873             for (int n=0, nMax=styleables.size(); n&lt;nMax; n++) {
874                 final CssMetaData&lt;?,?&gt; prop = styleables.get(n);
875                 if (alignmentProperty.equals(prop.getProperty())) styleables.remove(prop);
876             }
877 
878             styleables.add(SPACING);
879             styleables.add(ALIGNMENT);
880             STYLEABLES = Collections.unmodifiableList(styleables);
881 
882          }
883     }
884 
885     /**
886      * Returns the CssMetaData associated with this class, which may include the
887      * CssMetaData of its superclasses.
888      * @return the CssMetaData associated with this class, which may include the
889      * CssMetaData of its superclasses
890      */
891     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
892         return StyleableProperties.STYLEABLES;
893     }
894 
895     /**
896      * {@inheritDoc}
897      */
898     @Override
899     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
900         return getClassCssMetaData();
901     }
902 
903     @Override
904     protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
905         switch (attribute) {
906             case OVERFLOW_BUTTON: return overflowMenu;
907             default: return super.queryAccessibleAttribute(attribute, parameters);
908         }
909     }
910 
911     @Override
912     protected void executeAccessibleAction(AccessibleAction action, Object... parameters) {
913         switch (action) {
914             case SHOW_MENU:
915                 overflowMenu.fire();
916                 break;
917             default: super.executeAccessibleAction(action, parameters);
918         }
919     }
920 }
    </pre>
  </body>
</html>
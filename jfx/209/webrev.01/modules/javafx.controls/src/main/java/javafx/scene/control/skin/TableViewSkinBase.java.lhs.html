<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/skin/TableViewSkinBase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control.skin;
  27 
  28 import com.sun.javafx.scene.control.Properties;
  29 import javafx.application.Platform;
  30 import javafx.beans.InvalidationListener;
  31 import javafx.beans.Observable;
  32 import javafx.collections.FXCollections;
  33 import javafx.collections.ListChangeListener;
  34 import javafx.collections.MapChangeListener;
  35 import javafx.collections.ObservableList;
  36 import javafx.collections.ObservableMap;
  37 import javafx.scene.AccessibleAttribute;
  38 import javafx.scene.Node;
  39 import javafx.scene.control.*;
  40 
  41 import javafx.scene.layout.Region;
  42 import javafx.scene.layout.StackPane;
  43 import javafx.util.Callback;
  44 
  45 import javafx.collections.WeakListChangeListener;
  46 import com.sun.javafx.scene.control.skin.resources.ControlResources;
  47 
  48 import java.lang.ref.WeakReference;
  49 import java.util.List;
  50 import javafx.beans.WeakInvalidationListener;
  51 import javafx.beans.property.ObjectProperty;
  52 import javafx.geometry.HPos;
  53 import javafx.geometry.VPos;
  54 
  55 import java.security.AccessController;
  56 import java.security.PrivilegedAction;
  57 
  58 /**
  59  * TableViewSkinBase is the base skin class used by controls such as
  60  * {@link javafx.scene.control.TableView} and {@link javafx.scene.control.TreeTableView}
  61  * (the concrete classes are {@link TableViewSkin} and {@link TreeTableViewSkin},
  62  * respectively).
  63  *
  64  * @param &lt;M&gt; The type of the item stored in each row (for TableView, this is the type
  65  *           of the items list, and for TreeTableView, this is the type of the
  66  *           TreeItem).
  67  * @param &lt;S&gt; The type of the item, as represented by the selection model (for
  68  *           TableView, this is, again, the type of the items list, and for
  69  *           TreeTableView, this is TreeItem typed to the same type as M).
  70  * @param &lt;C&gt; The type of the virtualised control (e.g TableView, TreeTableView)
  71  * @param &lt;I&gt; The type of cell used by this virtualised control (e.g. TableRow, TreeTableRow)
  72  * @param &lt;TC&gt; The type of TableColumnBase used by this virtualised control (e.g. TableColumn, TreeTableColumn)
  73  *
  74  * @since 9
  75  * @see TableView
  76  * @see TreeTableView
  77  * @see TableViewSkin
  78  * @see TreeTableViewSkin
  79  */
  80 public abstract class TableViewSkinBase&lt;M, S, C extends Control, I extends IndexedCell&lt;M&gt;, TC extends TableColumnBase&lt;S,?&gt;&gt; extends VirtualContainerBase&lt;C, I&gt; {
  81 
  82     /***************************************************************************
  83      *                                                                         *
  84      * Static Fields                                                           *
  85      *                                                                         *
  86      **************************************************************************/
  87 
  88     private static final double GOLDEN_RATIO_MULTIPLIER = 0.618033987;
  89 
  90     // RT-34744 : IS_PANNABLE will be false unless
  91     // javafx.scene.control.skin.TableViewSkin.pannable
  92     // is set to true. This is done in order to make TableView functional
  93     // on embedded systems with touch screens which do not generate scroll
  94     // events for touch drag gestures.
  95     private static final boolean IS_PANNABLE =
  96             AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;javafx.scene.control.skin.TableViewSkin.pannable&quot;));
  97 
  98 
  99 
 100     /***************************************************************************
 101      *                                                                         *
 102      * Internal Fields                                                         *
 103      *                                                                         *
 104      **************************************************************************/
 105 
 106     // JDK-8090129: These constants should not be static, because the
 107     // Locale may change between instances.
 108     private final String EMPTY_TABLE_TEXT = ControlResources.getString(&quot;TableView.noContent&quot;);
 109     private final String NO_COLUMNS_TEXT = ControlResources.getString(&quot;TableView.noColumns&quot;);
 110 
 111     VirtualFlow&lt;I&gt; flow;
 112 
 113     private boolean contentWidthDirty = true;
 114 
 115     /**
 116      * This region is used to overlay atop the table when the user is performing
 117      * a column resize operation or a column reordering operation. It is a line
 118      * that runs the height of the table to indicate either the final width of
 119      * of the selected column, or the position the column will be &#39;dropped&#39; into
 120      * when the reordering operation completes.
 121      */
 122     private Region columnReorderLine;
 123 
 124     /**
 125      * A region which is resized and positioned such that it perfectly matches
 126      * the dimensions of any TableColumn that is being reordered by the user.
 127      * This is useful, for example, as a semi-transparent overlay to give
 128      * feedback to the user as to which column is currently being moved.
 129      */
 130     private Region columnReorderOverlay;
 131 
 132     /**
 133      * The entire header region for all columns. This header region handles
 134      * column reordering and resizing. It also handles the positioning and
 135      * resizing of thte columnReorderLine and columnReorderOverlay.
 136      */
 137     private TableHeaderRow tableHeaderRow;
 138 
 139     private Callback&lt;C, I&gt; rowFactory;
 140 
 141     /**
 142      * Region placed over the top of the flow (and possibly the header row) if
 143      * there is no data and/or there are no columns specified.
 144      */
 145     private StackPane placeholderRegion;
 146     private Label placeholderLabel;
 147 
 148     private int visibleColCount;
 149 
 150     boolean needCellsRecreated = true;
 151     boolean needCellsReconfigured = false;
 152 
 153     private int itemCount = -1;
 154 
 155 
 156 
 157     /***************************************************************************
 158      *                                                                         *
 159      * Listeners                                                               *
 160      *                                                                         *
 161      **************************************************************************/
 162 
 163     private MapChangeListener&lt;Object, Object&gt; propertiesMapListener = c -&gt; {
 164         if (! c.wasAdded()) return;
 165         if (Properties.REFRESH.equals(c.getKey())) {
 166             refreshView();
 167             getSkinnable().getProperties().remove(Properties.REFRESH);
 168         } else if (Properties.RECREATE.equals(c.getKey())) {
 169             needCellsRecreated = true;
 170             refreshView();
 171             getSkinnable().getProperties().remove(Properties.RECREATE);
 172         }
 173     };
 174 
 175     private ListChangeListener&lt;S&gt; rowCountListener = c -&gt; {
 176         while (c.next()) {
 177             if (c.wasReplaced()) {
 178                 // RT-28397: Support for when an item is replaced with itself (but
 179                 // updated internal values that should be shown visually).
 180 
 181                 // The ListViewSkin equivalent code here was updated to use the
 182                 // flow.setDirtyCell(int) API, but it was left alone here, otherwise
 183                 // our unit test for RT-36220 fails as we do not handle the case
 184                 // where the TableCell gets updated (only the TableRow does).
 185                 // Ideally we would use the dirtyCell API:
 186                 //
 187                 // for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
 188                 //     flow.setCellDirty(i);
 189                 // }
 190                 itemCount = 0;
 191                 break;
 192             } else if (c.getRemovedSize() == itemCount) {
 193                 // RT-22463: If the user clears out an items list then we
 194                 // should reset all cells (in particular their contained
 195                 // items) such that a subsequent addition to the list of
 196                 // an item which equals the old item (but is rendered
 197                 // differently) still displays as expected (i.e. with the
 198                 // updated display, not the old display).
 199                 itemCount = 0;
 200                 break;
 201             }
 202         }
 203 
 204         // fix for RT-37853
 205         if (getSkinnable() instanceof TableView) {
 206             ((TableView)getSkinnable()).edit(-1, null);
 207         }
 208 
 209         markItemCountDirty();
 210         getSkinnable().requestLayout();
 211     };
 212 
 213     private ListChangeListener&lt;TC&gt; visibleLeafColumnsListener = c -&gt; {
 214         updateVisibleColumnCount();
 215         while (c.next()) {
 216             updateVisibleLeafColumnWidthListeners(c.getAddedSubList(), c.getRemoved());
 217         }
 218     };
 219 
 220     private InvalidationListener widthListener = observable -&gt; {
 221         // This forces the horizontal scrollbar to show when the column
 222         // resizing occurs. It is not ideal, but will work for now.
 223 
 224         // using &#39;needCellsReconfigured&#39; here rather than &#39;needCellsRebuilt&#39;
 225         // as otherwise performance suffers massively (RT-27831)
 226         needCellsReconfigured = true;
 227         if (getSkinnable() != null) {
 228             getSkinnable().requestLayout();
 229         }
 230     };
 231 
 232     private InvalidationListener itemsChangeListener;
 233 
 234     private WeakListChangeListener&lt;S&gt; weakRowCountListener =
 235             new WeakListChangeListener&lt;&gt;(rowCountListener);
 236     private WeakListChangeListener&lt;TC&gt; weakVisibleLeafColumnsListener =
 237             new WeakListChangeListener&lt;&gt;(visibleLeafColumnsListener);
 238     private WeakInvalidationListener weakWidthListener =
 239             new WeakInvalidationListener(widthListener);
 240     private WeakInvalidationListener weakItemsChangeListener;
 241 
 242 
 243 
 244     /***************************************************************************
 245      *                                                                         *
 246      * Constructors                                                            *
 247      *                                                                         *
 248      **************************************************************************/
 249 
 250     /**
 251      *
 252      * @param control the control
 253      */
 254     public TableViewSkinBase(final C control) {
 255         super(control);
 256 
 257         // init the VirtualFlow
 258         flow = getVirtualFlow();
 259         flow.setPannable(IS_PANNABLE);
 260 //        flow.setCellFactory(flow1 -&gt; TableViewSkinBase.this.createCell());
 261 
 262         /*
 263          * Listening for scrolling along the X axis, but we need to be careful
 264          * to handle the situation appropriately when the hbar is invisible.
 265          */
 266         flow.getHbar().valueProperty().addListener(o -&gt; horizontalScroll());
 267 
 268         // RT-37152
 269         flow.getHbar().setUnitIncrement(15);
 270         flow.getHbar().setBlockIncrement(TableColumnHeader.DEFAULT_COLUMN_WIDTH);
 271 
 272         columnReorderLine = new Region();
 273         columnReorderLine.getStyleClass().setAll(&quot;column-resize-line&quot;);
 274         columnReorderLine.setManaged(false);
 275         columnReorderLine.setVisible(false);
 276 
 277         columnReorderOverlay = new Region();
 278         columnReorderOverlay.getStyleClass().setAll(&quot;column-overlay&quot;);
 279         columnReorderOverlay.setVisible(false);
 280         columnReorderOverlay.setManaged(false);
 281 
 282         tableHeaderRow = createTableHeaderRow();
 283 //        tableHeaderRow.setColumnReorderLine(columnReorderLine);
 284         tableHeaderRow.setFocusTraversable(false);
 285 
 286         getChildren().addAll(tableHeaderRow, flow, columnReorderOverlay, columnReorderLine);
 287 
 288         updateVisibleColumnCount();
 289         updateVisibleLeafColumnWidthListeners(getVisibleLeafColumns(), FXCollections.&lt;TC&gt;emptyObservableList());
 290 
 291         tableHeaderRow.reorderingProperty().addListener(valueModel -&gt; {
 292             getSkinnable().requestLayout();
 293         });
 294 
 295         getVisibleLeafColumns().addListener(weakVisibleLeafColumnsListener);
 296 
 297         final ObjectProperty&lt;ObservableList&lt;S&gt;&gt; itemsProperty = TableSkinUtils.itemsProperty(this);
 298         updateTableItems(null, itemsProperty.get());
 299         itemsChangeListener = new InvalidationListener() {
 300             private WeakReference&lt;ObservableList&lt;S&gt;&gt; weakItemsRef = new WeakReference&lt;&gt;(itemsProperty.get());
 301 
 302             @Override public void invalidated(Observable observable) {
 303                 ObservableList&lt;S&gt; oldItems = weakItemsRef.get();
 304                 weakItemsRef = new WeakReference&lt;&gt;(itemsProperty.get());
 305                 updateTableItems(oldItems, itemsProperty.get());
 306             }
 307         };
 308         weakItemsChangeListener = new WeakInvalidationListener(itemsChangeListener);
 309         itemsProperty.addListener(weakItemsChangeListener);
 310 
 311         final ObservableMap&lt;Object, Object&gt; properties = control.getProperties();
 312         properties.remove(Properties.REFRESH);
 313         properties.remove(Properties.RECREATE);
 314         properties.addListener(propertiesMapListener);
 315 
 316         control.addEventHandler(ScrollToEvent.&lt;TC&gt;scrollToColumn(), event -&gt; {
 317             scrollHorizontally(event.getScrollTarget());
 318         });
 319 
 320         // flow and flow.vbar width observer
 321         InvalidationListener widthObserver = valueModel -&gt; {
 322             contentWidthDirty = true;
 323             getSkinnable().requestLayout();
 324         };
 325         flow.widthProperty().addListener(widthObserver);
 326         flow.getVbar().widthProperty().addListener(widthObserver);
 327 
 328         final ObjectProperty&lt;Callback&lt;C, I&gt;&gt; rowFactoryProperty = TableSkinUtils.rowFactoryProperty(this);
 329         registerChangeListener(rowFactoryProperty, e -&gt; {
 330             Callback&lt;C, I&gt; oldFactory = rowFactory;
 331             rowFactory = rowFactoryProperty.get();
 332             if (oldFactory != rowFactory) {
 333                 requestRebuildCells();
 334             }
 335         });
 336         registerChangeListener(TableSkinUtils.placeholderProperty(this), e -&gt; updatePlaceholderRegionVisibility());
 337         registerChangeListener(flow.getVbar().visibleProperty(), e -&gt; updateContentWidth());
 338     }
 339 
 340 
 341 
 342     /***************************************************************************
 343      *                                                                         *
 344      * Abstract Methods                                                        *
 345      *                                                                         *
 346      **************************************************************************/
 347 
 348 
 349 
 350 
 351 
 352     /***************************************************************************
 353      *                                                                         *
 354      * Public API                                                              *
 355      *                                                                         *
 356      **************************************************************************/
 357 
 358     /** {@inheritDoc} */
 359     @Override public void dispose() {
<a name="2" id="anc2"></a>
 360         final ObjectProperty&lt;ObservableList&lt;S&gt;&gt; itemsProperty = TableSkinUtils.itemsProperty(this);
 361 
 362         getVisibleLeafColumns().removeListener(weakVisibleLeafColumnsListener);
 363         itemsProperty.removeListener(weakItemsChangeListener);
 364         getSkinnable().getProperties().removeListener(propertiesMapListener);
 365         updateTableItems(itemsProperty.get(), null);
 366 
 367         super.dispose();
 368     }
 369 
 370     /** {@inheritDoc} */
 371     @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
 372         return 400;
 373     }
 374 
 375     /** {@inheritDoc} */
 376     @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
 377         double prefHeight = computePrefHeight(-1, topInset, rightInset, bottomInset, leftInset);
 378 
 379         List&lt;? extends TC&gt; cols = getVisibleLeafColumns();
 380         if (cols == null || cols.isEmpty()) {
 381             return prefHeight * GOLDEN_RATIO_MULTIPLIER;
 382         }
 383 
 384         double pw = leftInset + rightInset;
 385         for (int i = 0, max = cols.size(); i &lt; max; i++) {
 386             TC tc = cols.get(i);
 387             pw += Math.max(tc.getPrefWidth(), tc.getMinWidth());
 388         }
 389 //        return pw;
 390         return Math.max(pw, prefHeight * GOLDEN_RATIO_MULTIPLIER);
 391     }
 392 
 393     /** {@inheritDoc} */
 394     @Override protected void layoutChildren(final double x, double y,
 395             final double w, final double h) {
 396 
 397         C table = getSkinnable();
 398 
 399         // an unlikely scenario, but it does pop up in unit tests, so guarding
 400         // here to prevent test failures seems ok.
 401         if (table == null) {
 402             return;
 403         }
 404 
 405         super.layoutChildren(x, y, w, h);
 406 
 407         if (needCellsRecreated) {
 408             flow.recreateCells();
 409         } else if (needCellsReconfigured) {
 410             flow.reconfigureCells();
 411         }
 412 
 413         needCellsRecreated = false;
 414         needCellsReconfigured = false;
 415 
 416         final double baselineOffset = table.getLayoutBounds().getHeight() / 2;
 417 
 418         // position the table header
 419         double tableHeaderRowHeight = tableHeaderRow.prefHeight(-1);
 420         layoutInArea(tableHeaderRow, x, y, w, tableHeaderRowHeight, baselineOffset,
 421                 HPos.CENTER, VPos.CENTER);
 422         y += tableHeaderRowHeight;
 423 
 424         // let the virtual flow take up all remaining space
 425         // TODO this calculation is to ensure the bottom border is visible when
 426         // placed in a Pane. It is not ideal, but will suffice for now. See
 427         // RT-14335 for more information.
 428         double flowHeight = Math.floor(h - tableHeaderRowHeight);
 429         if (getItemCount() == 0 || visibleColCount == 0) {
 430             // show message overlay instead of empty table
 431             layoutInArea(placeholderRegion, x, y,
 432                     w, flowHeight,
 433                     baselineOffset, HPos.CENTER, VPos.CENTER);
 434         } else {
 435             layoutInArea(flow, x, y,
 436                     w, flowHeight,
 437                     baselineOffset, HPos.CENTER, VPos.CENTER);
 438         }
 439 
 440         // painting the overlay over the column being reordered
 441         if (tableHeaderRow.getReorderingRegion() != null) {
 442             TableColumnHeader reorderingColumnHeader = tableHeaderRow.getReorderingRegion();
 443             TableColumnBase reorderingColumn = reorderingColumnHeader.getTableColumn();
 444             if (reorderingColumn != null) {
 445                 Node n = tableHeaderRow.getReorderingRegion();
 446 
 447                 // determine where to draw the column header overlay, it&#39;s
 448                 // either from the left-edge of the column, or 0, if the column
 449                 // is off the left-side of the TableView (i.e. horizontal
 450                 // scrolling has occured).
 451                 double minX = tableHeaderRow.sceneToLocal(n.localToScene(n.getBoundsInLocal())).getMinX();
 452                 double overlayWidth = reorderingColumnHeader.getWidth();
 453                 if (minX &lt; 0) {
 454                     overlayWidth += minX;
 455                 }
 456                 minX = minX &lt; 0 ? 0 : minX;
 457 
 458                 // prevent the overlay going out the right-hand side of the
 459                 // TableView
 460                 if (minX + overlayWidth &gt; w) {
 461                     overlayWidth = w - minX;
 462 
 463                     if (flow.getVbar().isVisible()) {
 464                         overlayWidth -= flow.getVbar().getWidth() - 1;
 465                     }
 466                 }
 467 
 468                 double contentAreaHeight = flowHeight;
 469                 if (flow.getHbar().isVisible()) {
 470                     contentAreaHeight -= flow.getHbar().getHeight();
 471                 }
 472 
 473                 columnReorderOverlay.resize(overlayWidth, contentAreaHeight);
 474 
 475                 columnReorderOverlay.setLayoutX(minX);
 476                 columnReorderOverlay.setLayoutY(tableHeaderRow.getHeight());
 477             }
 478 
 479             // paint the reorder line as well
 480             double cw = columnReorderLine.snappedLeftInset() + columnReorderLine.snappedRightInset();
 481             double lineHeight = h - (flow.getHbar().isVisible() ? flow.getHbar().getHeight() - 1 : 0);
 482             columnReorderLine.resizeRelocate(0, columnReorderLine.snappedTopInset(), cw, lineHeight);
 483         }
 484 
 485         columnReorderLine.setVisible(tableHeaderRow.isReordering());
 486         columnReorderOverlay.setVisible(tableHeaderRow.isReordering());
 487 
 488         checkContentWidthState();
 489     }
 490 
 491     /**
 492      * Creates a new TableHeaderRow instance. By default this method should not be overridden, but in some
 493      * circumstances it makes sense (e.g. testing, or when extreme customization is desired).
 494      *
 495      * @return A new TableHeaderRow instance.
 496      */
 497     protected TableHeaderRow createTableHeaderRow() {
 498         return new TableHeaderRow(this);
 499     }
 500 
 501 
 502 
 503     /***************************************************************************
 504      *                                                                         *
 505      * Private implementation                                                  *
 506      *                                                                         *
 507      **************************************************************************/
 508 
 509     /**
 510      * Returns the {@code TableHeaderRow} created using {@link #createTableHeaderRow()}.
 511      *
 512      * @return the {@code TableHeaderRow} for this {@code TableViewSkinBase}
 513      * @since 12
 514      */
 515     protected TableHeaderRow getTableHeaderRow() {
 516         return tableHeaderRow;
 517     }
 518 
 519     private TableSelectionModel&lt;S&gt; getSelectionModel() {
 520         return TableSkinUtils.getSelectionModel(this);
 521     }
 522 
 523     private TableFocusModel&lt;M,?&gt; getFocusModel() {
 524         return TableSkinUtils.getFocusModel(this);
 525     }
 526 
 527     // returns the currently focused cell in the focus model
 528     private TablePositionBase&lt;? extends TC&gt; getFocusedCell() {
 529         return TableSkinUtils.getFocusedCell(this);
 530     }
 531 
 532     // returns an ObservableList of the visible leaf columns of the control
 533     private ObservableList&lt;? extends TC&gt; getVisibleLeafColumns() {
 534         return TableSkinUtils.getVisibleLeafColumns(this);
 535     }
 536 
 537     /** {@inheritDoc} */
 538     @Override protected void updateItemCount() {
 539         updatePlaceholderRegionVisibility();
 540 
 541         int oldCount = itemCount;
 542         int newCount = getItemCount();
 543 
 544         itemCount = newCount;
 545 
 546         if (itemCount == 0) {
 547             flow.getHbar().setValue(0.0);
 548         }
 549 
 550         // if this is not called even when the count is the same, we get a
 551         // memory leak in VirtualFlow.sheet.children. This can probably be
 552         // optimised in the future when time permits.
 553         flow.setCellCount(newCount);
 554 
 555         if (newCount != oldCount) {
 556             // FIXME updateItemCount is called _a lot_. Perhaps we can make rebuildCells
 557             // smarter. Imagine if items has one million items added - do we really
 558             // need to rebuildCells a million times? Maybe this is better now that
 559             // we do rebuildCells instead of recreateCells.
 560             requestRebuildCells();
 561         } else {
 562             needCellsReconfigured = true;
 563         }
 564     }
 565 
 566     private void checkContentWidthState() {
 567         // we test for item count here to resolve RT-14855, where the column
 568         // widths weren&#39;t being resized properly when in constrained layout mode
 569         // if there were no items.
 570         if (contentWidthDirty || getItemCount() == 0) {
 571             updateContentWidth();
 572             contentWidthDirty = false;
 573         }
 574     }
 575 
 576     void horizontalScroll() {
 577         tableHeaderRow.updateScrollX();
 578     }
 579 
 580     /**
 581      * Called when the focus is set on the cell above the current focused cell in order to scroll to it to make it
 582      * visible.
 583      *
 584      * @since 12
 585      */
 586     protected void onFocusAboveCell() {
 587         TableFocusModel&lt;M, ?&gt; fm = getFocusModel();
 588         if (fm == null) return;
 589 
 590         flow.scrollTo(fm.getFocusedIndex());
 591     }
 592 
 593     /**
 594      * Called when the focus is set on the cell below the current focused cell in order to scroll to it to make it
 595      * visible.
 596      *
 597      * @since 12
 598      */
 599     protected void onFocusBelowCell() {
 600         TableFocusModel&lt;M, ?&gt; fm = getFocusModel();
 601         if (fm == null) return;
 602 
 603         flow.scrollTo(fm.getFocusedIndex());
 604     }
 605 
 606     /**
 607      * Called when the selection is set on the the cell above the current focused cell in order to scroll to it to make
 608      * it visible.
 609      *
 610      * @since 12
 611      */
 612     protected void onSelectAboveCell() {
 613         SelectionModel&lt;S&gt; sm = getSelectionModel();
 614         if (sm == null) return;
 615 
 616         flow.scrollTo(sm.getSelectedIndex());
 617     }
 618 
 619     /**
 620      * Called when the selection is set on the cell below the current focused cell in order to scroll to it to make it
 621      * visible.
 622      *
 623      * @since 12
 624      */
 625     protected void onSelectBelowCell() {
 626         SelectionModel&lt;S&gt; sm = getSelectionModel();
 627         if (sm == null) return;
 628 
 629         flow.scrollTo(sm.getSelectedIndex());
 630     }
 631 
 632     /**
 633      * Called when the selection is set on the left cell of the current selected one in order to horizontally scroll to
 634      * it to make it visible.
 635      *
 636      * @since 12
 637      */
 638     protected void onSelectLeftCell() {
 639         scrollHorizontally();
 640     }
 641 
 642     /**
 643      * Called when the selection is set on the right cell of the current selected one in order to horizontally scroll to
 644      * it to make it visible.
 645      *
 646      * @since 12
 647      */
 648     protected void onSelectRightCell() {
 649         scrollHorizontally();
 650     }
 651 
 652     /**
 653      * Called when the focus is set on the left cell of the current selected one in order to horizontally scroll to it
 654      * to make it visible.
 655      *
 656      * @since 12
 657      */
 658     protected void onFocusLeftCell() {
 659         scrollHorizontally();
 660     }
 661 
 662     /**
 663      * Called when the focus is set on the right cell of the current selected one in order to horizontally scroll to it
 664      * to make it visible.
 665      *
 666      * @since 12
 667      */
 668     protected void onFocusRightCell() {
 669         scrollHorizontally();
 670     }
 671 
 672     /**
 673      * Called when the selection is set on the first cell of the table (first row and first column) in order to scroll
 674      * to it to make it visible.
 675      *
 676      * @since 12
 677      */
 678     protected void onMoveToFirstCell() {
 679         flow.scrollTo(0);
 680         flow.setPosition(0);
 681     }
 682 
 683     /**
 684      * Called when the selection is set on the last cell of the table (last row and last column) in order to scroll to
 685      * it to make it visible.
 686      *
 687      * @since 12
 688      */
 689     protected void onMoveToLastCell() {
 690         int endPos = getItemCount();
 691         flow.scrollTo(endPos);
 692         flow.setPosition(1);
 693     }
 694 
 695     private void updateTableItems(ObservableList&lt;S&gt; oldList, ObservableList&lt;S&gt; newList) {
 696         if (oldList != null) {
 697             oldList.removeListener(weakRowCountListener);
 698         }
 699 
 700         if (newList != null) {
 701             newList.addListener(weakRowCountListener);
 702         }
 703 
 704         markItemCountDirty();
 705         getSkinnable().requestLayout();
 706     }
 707 
 708     Region getColumnReorderLine() {
 709         return columnReorderLine;
 710     }
 711 
 712     /**
 713      * Returns the index of the selected (or focused, if {@code isFocusDriven} is {@code true}) cell after a page scroll
 714      * operation. If the selected/focused cell is not the last fully visible cell, then the last fully visible cell is
 715      * selected/focused. Otherwise, the content is scrolled such that the cell is made visible at the top of the
 716      * viewport (and the new last fully visible cell is selected/focused instead).
 717      *
 718      * @param isFocusDriven {@code true} if focused cell should be considered over selection
 719      * @return the new index to select, or to focus if {@code isFocusDriven} is {@code true}
 720      * @since 12
 721      */
 722     protected int onScrollPageDown(boolean isFocusDriven) {
 723         TableSelectionModel&lt;S&gt; sm = getSelectionModel();
 724         if (sm == null) return -1;
 725 
 726         final int itemCount = getItemCount();
 727 
 728         I lastVisibleCell = flow.getLastVisibleCellWithinViewport();
 729         if (lastVisibleCell == null) return -1;
 730 
 731         int lastVisibleCellIndex = lastVisibleCell.getIndex();
 732 
 733         // we include this test here as the virtual flow will return cells that
 734         // exceed past the item count, so we need to clamp here (and further down
 735         // in this method also). See RT-19053 for more information.
 736         lastVisibleCellIndex = lastVisibleCellIndex &gt;= itemCount ? itemCount - 1 : lastVisibleCellIndex;
 737 
 738         // isSelected represents focus OR selection
 739         boolean isSelected;
 740         if (isFocusDriven) {
 741             isSelected = lastVisibleCell.isFocused() || isCellFocused(lastVisibleCellIndex);
 742         } else {
 743             isSelected = lastVisibleCell.isSelected() || isCellSelected(lastVisibleCellIndex);
 744         }
 745 
 746         if (isSelected) {
 747             boolean isLeadIndex = isLeadIndex(isFocusDriven, lastVisibleCellIndex);
 748 
 749             if (isLeadIndex) {
 750                 // if the last visible cell is selected, we want to shift that cell up
 751                 // to be the top-most cell, or at least as far to the top as we can go.
 752                 flow.scrollToTop(lastVisibleCell);
 753 
 754                 I newLastVisibleCell = flow.getLastVisibleCellWithinViewport();
 755                 lastVisibleCell = newLastVisibleCell == null ? lastVisibleCell : newLastVisibleCell;
 756             }
 757         }
 758 
 759         int newSelectionIndex = lastVisibleCell.getIndex();
 760         newSelectionIndex = newSelectionIndex &gt;= itemCount ? itemCount - 1 : newSelectionIndex;
 761         flow.scrollTo(newSelectionIndex);
 762         return newSelectionIndex;
 763     }
 764 
 765     /**
 766      * Returns the index of the selected (or focused, if {@code isFocusDriven} is {@code true}) cell after a page scroll
 767      * operation. If the selected/focused cell is not the first fully visible cell, then the first fully visible cell is
 768      * selected/focused. Otherwise, the content is scrolled such that the cell is made visible at the bottom of the
 769      * viewport (and the new first fully visible cell is selected/focused instead).
 770      *
 771      * @param isFocusDriven {@code true} if focused cell should be considered over selection
 772      * @return the new index to select, or to focus if {@code isFocusDriven} is {@code true}
 773      * @since 12
 774      */
 775     protected int onScrollPageUp(boolean isFocusDriven) {
 776         I firstVisibleCell = flow.getFirstVisibleCellWithinViewport();
 777         if (firstVisibleCell == null) return -1;
 778 
 779         int firstVisibleCellIndex = firstVisibleCell.getIndex();
 780 
 781         // isSelected represents focus OR selection
 782         boolean isSelected = false;
 783         if (isFocusDriven) {
 784             isSelected = firstVisibleCell.isFocused() || isCellFocused(firstVisibleCellIndex);
 785         } else {
 786             isSelected = firstVisibleCell.isSelected() || isCellSelected(firstVisibleCellIndex);
 787         }
 788 
 789         if (isSelected) {
 790             boolean isLeadIndex = isLeadIndex(isFocusDriven, firstVisibleCellIndex);
 791 
 792             if (isLeadIndex) {
 793                 // if the first visible cell is selected, we want to shift that cell down
 794                 // to be the bottom-most cell, or at least as far to the bottom as we can go.
 795                 flow.scrollToBottom(firstVisibleCell);
 796 
 797                 I newFirstVisibleCell = flow.getFirstVisibleCellWithinViewport();
 798                 firstVisibleCell = newFirstVisibleCell == null ? firstVisibleCell : newFirstVisibleCell;
 799             }
 800         }
 801 
 802         int newSelectionIndex = firstVisibleCell.getIndex();
 803         flow.scrollTo(newSelectionIndex);
 804         return newSelectionIndex;
 805     }
 806 
 807     private boolean isLeadIndex(boolean isFocusDriven, int index) {
 808         final TableSelectionModel&lt;S&gt; sm = getSelectionModel();
 809         final FocusModel&lt;M&gt; fm = getFocusModel();
 810 
 811         return (isFocusDriven &amp;&amp; fm.getFocusedIndex() == index)
 812                 || (! isFocusDriven &amp;&amp; sm.getSelectedIndex() == index);
 813     }
 814 
 815     /**
 816      * Keeps track of how many leaf columns are currently visible in this table.
 817      */
 818     private void updateVisibleColumnCount() {
 819         visibleColCount = getVisibleLeafColumns().size();
 820 
 821         updatePlaceholderRegionVisibility();
 822         requestRebuildCells();
 823     }
 824 
 825     private void updateVisibleLeafColumnWidthListeners(
 826             List&lt;? extends TC&gt; added, List&lt;? extends TC&gt; removed) {
 827 
 828         for (int i = 0, max = removed.size(); i &lt; max; i++) {
 829             TC tc = removed.get(i);
 830             tc.widthProperty().removeListener(weakWidthListener);
 831         }
 832         for (int i = 0, max = added.size(); i &lt; max; i++) {
 833             TC tc = added.get(i);
 834             tc.widthProperty().addListener(weakWidthListener);
 835         }
 836         requestRebuildCells();
 837     }
 838 
 839     final void updatePlaceholderRegionVisibility() {
 840         boolean visible = visibleColCount == 0 || getItemCount() == 0;
 841 
 842         if (visible) {
 843             if (placeholderRegion == null) {
 844                 placeholderRegion = new StackPane();
 845                 placeholderRegion.getStyleClass().setAll(&quot;placeholder&quot;);
 846                 getChildren().add(placeholderRegion);
 847             }
 848 
 849             Node placeholderNode = TableSkinUtils.placeholderProperty(this).get();
 850 
 851             if (placeholderNode == null) {
 852                 if (placeholderLabel == null) {
 853                     placeholderLabel = new Label();
 854                 }
 855                 String s = visibleColCount == 0 ? NO_COLUMNS_TEXT : EMPTY_TABLE_TEXT;
 856                 placeholderLabel.setText(s);
 857 
 858                 placeholderRegion.getChildren().setAll(placeholderLabel);
 859             } else {
 860                 placeholderRegion.getChildren().setAll(placeholderNode);
 861             }
 862         }
 863 
 864         flow.setVisible(! visible);
 865         if (placeholderRegion != null) {
 866             placeholderRegion.setVisible(visible);
 867         }
 868     }
 869 
 870     /*
 871      * It&#39;s often important to know how much width is available for content
 872      * within the table, and this needs to exclude the width of any vertical
 873      * scrollbar.
 874      */
 875     private void updateContentWidth() {
 876         double contentWidth = flow.getWidth();
 877 
 878         if (flow.getVbar().isVisible()) {
 879             contentWidth -= flow.getVbar().getWidth();
 880         }
 881 
 882         if (contentWidth &lt;= 0) {
 883             // Fix for RT-14855 when there is no content in the TableView.
 884             Control c = getSkinnable();
 885             contentWidth = c.getWidth() - (snappedLeftInset() + snappedRightInset());
 886         }
 887 
 888         contentWidth = Math.max(0.0, contentWidth);
 889 
 890         // FIXME this isn&#39;t perfect, but it prevents RT-14885, which results in
 891         // undesired horizontal scrollbars when in constrained resize mode
 892         getSkinnable().getProperties().put(&quot;TableView.contentWidth&quot;, Math.floor(contentWidth));
 893     }
 894 
 895     private void refreshView() {
 896         markItemCountDirty();
 897         Control c = getSkinnable();
 898         if (c != null) {
 899             c.requestLayout();
 900         }
 901     }
 902 
 903     /**
 904      * Scrolls to the column containing the current focused cell.
 905      * &lt;p&gt;
 906      * Handles the horizontal scrolling when the selection mode is cell-based and the newly selected cell belongs to a
 907      * column which is not completely visible.
 908      *
 909      * @since 12
 910      */
 911     public void scrollHorizontally() {
 912         TableFocusModel&lt;M, ?&gt; fm = getFocusModel();
 913         if (fm == null) return;
 914 
 915         TC col = getFocusedCell().getTableColumn();
 916         scrollHorizontally(col);
 917     }
 918 
 919     /**
 920      * Programmatically scrolls to the given column. This call will ensure that the column is aligned on the left edge
 921      * of the {@code TableView} and also that the columns don&#39;t become detached from the right edge of the table.
 922      *
 923      * @param col the column to scroll to
 924      * @since 12
 925      */
 926     protected void scrollHorizontally(TC col) {
 927         if (col == null || !col.isVisible()) return;
 928 
 929         final Control control = getSkinnable();
 930 
 931         // RT-37060 - if we are trying to scroll to a column that has not
 932         // yet even been rendered, we must wait until the layout pass has
 933         // happened and then do the scroll. The laziest way to do this is to
 934         // queue up the task to run later, at which point we will have hopefully
 935         // fully run the column through layout and css.
 936         TableColumnHeader header = tableHeaderRow.getColumnHeaderFor(col);
 937         if (header == null || header.getWidth() &lt;= 0) {
 938             Platform.runLater(() -&gt; scrollHorizontally(col));
 939             return;
 940         }
 941 
 942         // work out where this column header is, and it&#39;s width (start -&gt; end)
 943         double start = 0;
 944         for (TC c : getVisibleLeafColumns()) {
 945             if (c.equals(col)) break;
 946             start += c.getWidth();
 947         }
 948         double end = start + col.getWidth();
 949 
 950         // determine the visible width of the table
 951         double headerWidth = control.getWidth() - snappedLeftInset() - snappedRightInset();
 952 
 953         // determine by how much we need to translate the table to ensure that
 954         // the start position of this column lines up with the left edge of the
 955         // tableview, and also that the columns don&#39;t become detached from the
 956         // right edge of the table
 957         double pos = flow.getHbar().getValue();
 958         double max = flow.getHbar().getMax();
 959         double newPos;
 960 
 961         if (start &lt; pos &amp;&amp; start &gt;= 0) {
 962             newPos = start;
 963         } else {
 964             double delta = start &lt; 0 || end &gt; headerWidth ? start - pos : 0;
 965             newPos = pos + delta &gt; max ? max : pos + delta;
 966         }
 967 
 968         // FIXME we should add API in VirtualFlow so we don&#39;t end up going
 969         // direct to the hbar.
 970         // actually shift the flow - this will result in the header moving
 971         // as well
 972         flow.getHbar().setValue(newPos);
 973     }
 974 
 975     private boolean isCellSelected(int row) {
 976         TableSelectionModel&lt;S&gt; sm = getSelectionModel();
 977         if (sm == null) return false;
 978         if (! sm.isCellSelectionEnabled()) return false;
 979 
 980         int columnCount = getVisibleLeafColumns().size();
 981         for (int col = 0; col &lt; columnCount; col++) {
 982             if (sm.isSelected(row, TableSkinUtils.getVisibleLeafColumn(this,col))) {
 983                 return true;
 984             }
 985         }
 986 
 987         return false;
 988     }
 989 
 990     private boolean isCellFocused(int row) {
 991         TableFocusModel&lt;S,TC&gt; fm = (TableFocusModel&lt;S,TC&gt;)(Object)getFocusModel();
 992         if (fm == null) return false;
 993 
 994         int columnCount = getVisibleLeafColumns().size();
 995         for (int col = 0; col &lt; columnCount; col++) {
 996             if (fm.isFocused(row, TableSkinUtils.getVisibleLeafColumn(this,col))) {
 997                 return true;
 998             }
 999         }
1000 
1001         return false;
1002     }
1003 
1004 
1005 
1006     /***************************************************************************
1007      *                                                                         *
1008      * A11y                                                                    *
1009      *                                                                         *
1010      **************************************************************************/
1011 
1012     /** {@inheritDoc} */
1013     @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1014         switch (attribute) {
1015             case FOCUS_ITEM: {
1016                 TableFocusModel&lt;M,?&gt; fm = getFocusModel();
1017                 int focusedIndex = fm.getFocusedIndex();
1018                 if (focusedIndex == -1) {
1019                     if (placeholderRegion != null &amp;&amp; placeholderRegion.isVisible()) {
1020                         return placeholderRegion.getChildren().get(0);
1021                     }
1022                     if (getItemCount() &gt; 0) {
1023                         focusedIndex = 0;
1024                     } else {
1025                         return null;
1026                     }
1027                 }
1028                 return flow.getPrivateCell(focusedIndex);
1029             }
1030             case CELL_AT_ROW_COLUMN: {
1031                 int rowIndex = (Integer)parameters[0];
1032                 return flow.getPrivateCell(rowIndex);
1033             }
1034             case COLUMN_AT_INDEX: {
1035                 int index = (Integer)parameters[0];
1036                 TableColumnBase&lt;S,?&gt; column = TableSkinUtils.getVisibleLeafColumn(this,index);
1037                 return getTableHeaderRow().getColumnHeaderFor(column);
1038             }
1039             case HEADER: {
1040                 /* Not sure how this is used by Accessibility, but without this VoiceOver will not
1041                  * look for column headers */
1042                 return getTableHeaderRow();
1043             }
1044             case VERTICAL_SCROLLBAR: return flow.getVbar();
1045             case HORIZONTAL_SCROLLBAR: return flow.getHbar();
1046             default: return super.queryAccessibleAttribute(attribute, parameters);
1047         }
1048     }
1049 
1050 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/skin/TableViewSkinBase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control.skin;
  27 
  28 import com.sun.javafx.scene.control.Properties;
  29 import javafx.application.Platform;
  30 import javafx.beans.InvalidationListener;
  31 import javafx.beans.Observable;
  32 import javafx.collections.FXCollections;
  33 import javafx.collections.ListChangeListener;
  34 import javafx.collections.MapChangeListener;
  35 import javafx.collections.ObservableList;
  36 import javafx.collections.ObservableMap;
  37 import javafx.scene.AccessibleAttribute;
  38 import javafx.scene.Node;
  39 import javafx.scene.control.*;
  40 
  41 import javafx.scene.layout.Region;
  42 import javafx.scene.layout.StackPane;
  43 import javafx.util.Callback;
  44 
  45 import javafx.collections.WeakListChangeListener;
  46 import com.sun.javafx.scene.control.skin.resources.ControlResources;
  47 
  48 import java.lang.ref.WeakReference;
  49 import java.util.List;
  50 import javafx.beans.WeakInvalidationListener;
  51 import javafx.beans.property.ObjectProperty;
  52 import javafx.geometry.HPos;
  53 import javafx.geometry.VPos;
  54 
  55 import java.security.AccessController;
  56 import java.security.PrivilegedAction;
  57 
  58 /**
  59  * TableViewSkinBase is the base skin class used by controls such as
  60  * {@link javafx.scene.control.TableView} and {@link javafx.scene.control.TreeTableView}
  61  * (the concrete classes are {@link TableViewSkin} and {@link TreeTableViewSkin},
  62  * respectively).
  63  *
  64  * @param &lt;M&gt; The type of the item stored in each row (for TableView, this is the type
  65  *           of the items list, and for TreeTableView, this is the type of the
  66  *           TreeItem).
  67  * @param &lt;S&gt; The type of the item, as represented by the selection model (for
  68  *           TableView, this is, again, the type of the items list, and for
  69  *           TreeTableView, this is TreeItem typed to the same type as M).
  70  * @param &lt;C&gt; The type of the virtualised control (e.g TableView, TreeTableView)
  71  * @param &lt;I&gt; The type of cell used by this virtualised control (e.g. TableRow, TreeTableRow)
  72  * @param &lt;TC&gt; The type of TableColumnBase used by this virtualised control (e.g. TableColumn, TreeTableColumn)
  73  *
  74  * @since 9
  75  * @see TableView
  76  * @see TreeTableView
  77  * @see TableViewSkin
  78  * @see TreeTableViewSkin
  79  */
  80 public abstract class TableViewSkinBase&lt;M, S, C extends Control, I extends IndexedCell&lt;M&gt;, TC extends TableColumnBase&lt;S,?&gt;&gt; extends VirtualContainerBase&lt;C, I&gt; {
  81 
  82     /***************************************************************************
  83      *                                                                         *
  84      * Static Fields                                                           *
  85      *                                                                         *
  86      **************************************************************************/
  87 
  88     private static final double GOLDEN_RATIO_MULTIPLIER = 0.618033987;
  89 
  90     // RT-34744 : IS_PANNABLE will be false unless
  91     // javafx.scene.control.skin.TableViewSkin.pannable
  92     // is set to true. This is done in order to make TableView functional
  93     // on embedded systems with touch screens which do not generate scroll
  94     // events for touch drag gestures.
  95     private static final boolean IS_PANNABLE =
  96             AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;javafx.scene.control.skin.TableViewSkin.pannable&quot;));
  97 
  98 
  99 
 100     /***************************************************************************
 101      *                                                                         *
 102      * Internal Fields                                                         *
 103      *                                                                         *
 104      **************************************************************************/
 105 
 106     // JDK-8090129: These constants should not be static, because the
 107     // Locale may change between instances.
 108     private final String EMPTY_TABLE_TEXT = ControlResources.getString(&quot;TableView.noContent&quot;);
 109     private final String NO_COLUMNS_TEXT = ControlResources.getString(&quot;TableView.noColumns&quot;);
 110 
 111     VirtualFlow&lt;I&gt; flow;
 112 
 113     private boolean contentWidthDirty = true;
 114 
 115     /**
 116      * This region is used to overlay atop the table when the user is performing
 117      * a column resize operation or a column reordering operation. It is a line
 118      * that runs the height of the table to indicate either the final width of
 119      * of the selected column, or the position the column will be &#39;dropped&#39; into
 120      * when the reordering operation completes.
 121      */
 122     private Region columnReorderLine;
 123 
 124     /**
 125      * A region which is resized and positioned such that it perfectly matches
 126      * the dimensions of any TableColumn that is being reordered by the user.
 127      * This is useful, for example, as a semi-transparent overlay to give
 128      * feedback to the user as to which column is currently being moved.
 129      */
 130     private Region columnReorderOverlay;
 131 
 132     /**
 133      * The entire header region for all columns. This header region handles
 134      * column reordering and resizing. It also handles the positioning and
 135      * resizing of thte columnReorderLine and columnReorderOverlay.
 136      */
 137     private TableHeaderRow tableHeaderRow;
 138 
 139     private Callback&lt;C, I&gt; rowFactory;
 140 
 141     /**
 142      * Region placed over the top of the flow (and possibly the header row) if
 143      * there is no data and/or there are no columns specified.
 144      */
 145     private StackPane placeholderRegion;
 146     private Label placeholderLabel;
 147 
 148     private int visibleColCount;
 149 
 150     boolean needCellsRecreated = true;
 151     boolean needCellsReconfigured = false;
 152 
 153     private int itemCount = -1;
 154 
 155 
 156 
 157     /***************************************************************************
 158      *                                                                         *
 159      * Listeners                                                               *
 160      *                                                                         *
 161      **************************************************************************/
 162 
 163     private MapChangeListener&lt;Object, Object&gt; propertiesMapListener = c -&gt; {
 164         if (! c.wasAdded()) return;
 165         if (Properties.REFRESH.equals(c.getKey())) {
 166             refreshView();
 167             getSkinnable().getProperties().remove(Properties.REFRESH);
 168         } else if (Properties.RECREATE.equals(c.getKey())) {
 169             needCellsRecreated = true;
 170             refreshView();
 171             getSkinnable().getProperties().remove(Properties.RECREATE);
 172         }
 173     };
 174 
 175     private ListChangeListener&lt;S&gt; rowCountListener = c -&gt; {
 176         while (c.next()) {
 177             if (c.wasReplaced()) {
 178                 // RT-28397: Support for when an item is replaced with itself (but
 179                 // updated internal values that should be shown visually).
 180 
 181                 // The ListViewSkin equivalent code here was updated to use the
 182                 // flow.setDirtyCell(int) API, but it was left alone here, otherwise
 183                 // our unit test for RT-36220 fails as we do not handle the case
 184                 // where the TableCell gets updated (only the TableRow does).
 185                 // Ideally we would use the dirtyCell API:
 186                 //
 187                 // for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
 188                 //     flow.setCellDirty(i);
 189                 // }
 190                 itemCount = 0;
 191                 break;
 192             } else if (c.getRemovedSize() == itemCount) {
 193                 // RT-22463: If the user clears out an items list then we
 194                 // should reset all cells (in particular their contained
 195                 // items) such that a subsequent addition to the list of
 196                 // an item which equals the old item (but is rendered
 197                 // differently) still displays as expected (i.e. with the
 198                 // updated display, not the old display).
 199                 itemCount = 0;
 200                 break;
 201             }
 202         }
 203 
 204         // fix for RT-37853
 205         if (getSkinnable() instanceof TableView) {
 206             ((TableView)getSkinnable()).edit(-1, null);
 207         }
 208 
 209         markItemCountDirty();
 210         getSkinnable().requestLayout();
 211     };
 212 
 213     private ListChangeListener&lt;TC&gt; visibleLeafColumnsListener = c -&gt; {
 214         updateVisibleColumnCount();
 215         while (c.next()) {
 216             updateVisibleLeafColumnWidthListeners(c.getAddedSubList(), c.getRemoved());
 217         }
 218     };
 219 
 220     private InvalidationListener widthListener = observable -&gt; {
 221         // This forces the horizontal scrollbar to show when the column
 222         // resizing occurs. It is not ideal, but will work for now.
 223 
 224         // using &#39;needCellsReconfigured&#39; here rather than &#39;needCellsRebuilt&#39;
 225         // as otherwise performance suffers massively (RT-27831)
 226         needCellsReconfigured = true;
 227         if (getSkinnable() != null) {
 228             getSkinnable().requestLayout();
 229         }
 230     };
 231 
 232     private InvalidationListener itemsChangeListener;
 233 
 234     private WeakListChangeListener&lt;S&gt; weakRowCountListener =
 235             new WeakListChangeListener&lt;&gt;(rowCountListener);
 236     private WeakListChangeListener&lt;TC&gt; weakVisibleLeafColumnsListener =
 237             new WeakListChangeListener&lt;&gt;(visibleLeafColumnsListener);
 238     private WeakInvalidationListener weakWidthListener =
 239             new WeakInvalidationListener(widthListener);
 240     private WeakInvalidationListener weakItemsChangeListener;
 241 
 242 
 243 
 244     /***************************************************************************
 245      *                                                                         *
 246      * Constructors                                                            *
 247      *                                                                         *
 248      **************************************************************************/
 249 
 250     /**
 251      *
 252      * @param control the control
 253      */
 254     public TableViewSkinBase(final C control) {
 255         super(control);
 256 
 257         // init the VirtualFlow
 258         flow = getVirtualFlow();
 259         flow.setPannable(IS_PANNABLE);
 260 //        flow.setCellFactory(flow1 -&gt; TableViewSkinBase.this.createCell());
 261 
 262         /*
 263          * Listening for scrolling along the X axis, but we need to be careful
 264          * to handle the situation appropriately when the hbar is invisible.
 265          */
 266         flow.getHbar().valueProperty().addListener(o -&gt; horizontalScroll());
 267 
 268         // RT-37152
 269         flow.getHbar().setUnitIncrement(15);
 270         flow.getHbar().setBlockIncrement(TableColumnHeader.DEFAULT_COLUMN_WIDTH);
 271 
 272         columnReorderLine = new Region();
 273         columnReorderLine.getStyleClass().setAll(&quot;column-resize-line&quot;);
 274         columnReorderLine.setManaged(false);
 275         columnReorderLine.setVisible(false);
 276 
 277         columnReorderOverlay = new Region();
 278         columnReorderOverlay.getStyleClass().setAll(&quot;column-overlay&quot;);
 279         columnReorderOverlay.setVisible(false);
 280         columnReorderOverlay.setManaged(false);
 281 
 282         tableHeaderRow = createTableHeaderRow();
 283 //        tableHeaderRow.setColumnReorderLine(columnReorderLine);
 284         tableHeaderRow.setFocusTraversable(false);
 285 
 286         getChildren().addAll(tableHeaderRow, flow, columnReorderOverlay, columnReorderLine);
 287 
 288         updateVisibleColumnCount();
 289         updateVisibleLeafColumnWidthListeners(getVisibleLeafColumns(), FXCollections.&lt;TC&gt;emptyObservableList());
 290 
 291         tableHeaderRow.reorderingProperty().addListener(valueModel -&gt; {
 292             getSkinnable().requestLayout();
 293         });
 294 
 295         getVisibleLeafColumns().addListener(weakVisibleLeafColumnsListener);
 296 
 297         final ObjectProperty&lt;ObservableList&lt;S&gt;&gt; itemsProperty = TableSkinUtils.itemsProperty(this);
 298         updateTableItems(null, itemsProperty.get());
 299         itemsChangeListener = new InvalidationListener() {
 300             private WeakReference&lt;ObservableList&lt;S&gt;&gt; weakItemsRef = new WeakReference&lt;&gt;(itemsProperty.get());
 301 
 302             @Override public void invalidated(Observable observable) {
 303                 ObservableList&lt;S&gt; oldItems = weakItemsRef.get();
 304                 weakItemsRef = new WeakReference&lt;&gt;(itemsProperty.get());
 305                 updateTableItems(oldItems, itemsProperty.get());
 306             }
 307         };
 308         weakItemsChangeListener = new WeakInvalidationListener(itemsChangeListener);
 309         itemsProperty.addListener(weakItemsChangeListener);
 310 
 311         final ObservableMap&lt;Object, Object&gt; properties = control.getProperties();
 312         properties.remove(Properties.REFRESH);
 313         properties.remove(Properties.RECREATE);
 314         properties.addListener(propertiesMapListener);
 315 
 316         control.addEventHandler(ScrollToEvent.&lt;TC&gt;scrollToColumn(), event -&gt; {
 317             scrollHorizontally(event.getScrollTarget());
 318         });
 319 
 320         // flow and flow.vbar width observer
 321         InvalidationListener widthObserver = valueModel -&gt; {
 322             contentWidthDirty = true;
 323             getSkinnable().requestLayout();
 324         };
 325         flow.widthProperty().addListener(widthObserver);
 326         flow.getVbar().widthProperty().addListener(widthObserver);
 327 
 328         final ObjectProperty&lt;Callback&lt;C, I&gt;&gt; rowFactoryProperty = TableSkinUtils.rowFactoryProperty(this);
 329         registerChangeListener(rowFactoryProperty, e -&gt; {
 330             Callback&lt;C, I&gt; oldFactory = rowFactory;
 331             rowFactory = rowFactoryProperty.get();
 332             if (oldFactory != rowFactory) {
 333                 requestRebuildCells();
 334             }
 335         });
 336         registerChangeListener(TableSkinUtils.placeholderProperty(this), e -&gt; updatePlaceholderRegionVisibility());
 337         registerChangeListener(flow.getVbar().visibleProperty(), e -&gt; updateContentWidth());
 338     }
 339 
 340 
 341 
 342     /***************************************************************************
 343      *                                                                         *
 344      * Abstract Methods                                                        *
 345      *                                                                         *
 346      **************************************************************************/
 347 
 348 
 349 
 350 
 351 
 352     /***************************************************************************
 353      *                                                                         *
 354      * Public API                                                              *
 355      *                                                                         *
 356      **************************************************************************/
 357 
 358     /** {@inheritDoc} */
 359     @Override public void dispose() {
 360         if (getSkinnable() == null) return;
 361         final ObjectProperty&lt;ObservableList&lt;S&gt;&gt; itemsProperty = TableSkinUtils.itemsProperty(this);
 362 
 363         getVisibleLeafColumns().removeListener(weakVisibleLeafColumnsListener);
 364         itemsProperty.removeListener(weakItemsChangeListener);
 365         getSkinnable().getProperties().removeListener(propertiesMapListener);
 366         updateTableItems(itemsProperty.get(), null);
 367 
 368         super.dispose();
 369     }
 370 
 371     /** {@inheritDoc} */
 372     @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
 373         return 400;
 374     }
 375 
 376     /** {@inheritDoc} */
 377     @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
 378         double prefHeight = computePrefHeight(-1, topInset, rightInset, bottomInset, leftInset);
 379 
 380         List&lt;? extends TC&gt; cols = getVisibleLeafColumns();
 381         if (cols == null || cols.isEmpty()) {
 382             return prefHeight * GOLDEN_RATIO_MULTIPLIER;
 383         }
 384 
 385         double pw = leftInset + rightInset;
 386         for (int i = 0, max = cols.size(); i &lt; max; i++) {
 387             TC tc = cols.get(i);
 388             pw += Math.max(tc.getPrefWidth(), tc.getMinWidth());
 389         }
 390 //        return pw;
 391         return Math.max(pw, prefHeight * GOLDEN_RATIO_MULTIPLIER);
 392     }
 393 
 394     /** {@inheritDoc} */
 395     @Override protected void layoutChildren(final double x, double y,
 396             final double w, final double h) {
 397 
 398         C table = getSkinnable();
 399 
 400         // an unlikely scenario, but it does pop up in unit tests, so guarding
 401         // here to prevent test failures seems ok.
 402         if (table == null) {
 403             return;
 404         }
 405 
 406         super.layoutChildren(x, y, w, h);
 407 
 408         if (needCellsRecreated) {
 409             flow.recreateCells();
 410         } else if (needCellsReconfigured) {
 411             flow.reconfigureCells();
 412         }
 413 
 414         needCellsRecreated = false;
 415         needCellsReconfigured = false;
 416 
 417         final double baselineOffset = table.getLayoutBounds().getHeight() / 2;
 418 
 419         // position the table header
 420         double tableHeaderRowHeight = tableHeaderRow.prefHeight(-1);
 421         layoutInArea(tableHeaderRow, x, y, w, tableHeaderRowHeight, baselineOffset,
 422                 HPos.CENTER, VPos.CENTER);
 423         y += tableHeaderRowHeight;
 424 
 425         // let the virtual flow take up all remaining space
 426         // TODO this calculation is to ensure the bottom border is visible when
 427         // placed in a Pane. It is not ideal, but will suffice for now. See
 428         // RT-14335 for more information.
 429         double flowHeight = Math.floor(h - tableHeaderRowHeight);
 430         if (getItemCount() == 0 || visibleColCount == 0) {
 431             // show message overlay instead of empty table
 432             layoutInArea(placeholderRegion, x, y,
 433                     w, flowHeight,
 434                     baselineOffset, HPos.CENTER, VPos.CENTER);
 435         } else {
 436             layoutInArea(flow, x, y,
 437                     w, flowHeight,
 438                     baselineOffset, HPos.CENTER, VPos.CENTER);
 439         }
 440 
 441         // painting the overlay over the column being reordered
 442         if (tableHeaderRow.getReorderingRegion() != null) {
 443             TableColumnHeader reorderingColumnHeader = tableHeaderRow.getReorderingRegion();
 444             TableColumnBase reorderingColumn = reorderingColumnHeader.getTableColumn();
 445             if (reorderingColumn != null) {
 446                 Node n = tableHeaderRow.getReorderingRegion();
 447 
 448                 // determine where to draw the column header overlay, it&#39;s
 449                 // either from the left-edge of the column, or 0, if the column
 450                 // is off the left-side of the TableView (i.e. horizontal
 451                 // scrolling has occured).
 452                 double minX = tableHeaderRow.sceneToLocal(n.localToScene(n.getBoundsInLocal())).getMinX();
 453                 double overlayWidth = reorderingColumnHeader.getWidth();
 454                 if (minX &lt; 0) {
 455                     overlayWidth += minX;
 456                 }
 457                 minX = minX &lt; 0 ? 0 : minX;
 458 
 459                 // prevent the overlay going out the right-hand side of the
 460                 // TableView
 461                 if (minX + overlayWidth &gt; w) {
 462                     overlayWidth = w - minX;
 463 
 464                     if (flow.getVbar().isVisible()) {
 465                         overlayWidth -= flow.getVbar().getWidth() - 1;
 466                     }
 467                 }
 468 
 469                 double contentAreaHeight = flowHeight;
 470                 if (flow.getHbar().isVisible()) {
 471                     contentAreaHeight -= flow.getHbar().getHeight();
 472                 }
 473 
 474                 columnReorderOverlay.resize(overlayWidth, contentAreaHeight);
 475 
 476                 columnReorderOverlay.setLayoutX(minX);
 477                 columnReorderOverlay.setLayoutY(tableHeaderRow.getHeight());
 478             }
 479 
 480             // paint the reorder line as well
 481             double cw = columnReorderLine.snappedLeftInset() + columnReorderLine.snappedRightInset();
 482             double lineHeight = h - (flow.getHbar().isVisible() ? flow.getHbar().getHeight() - 1 : 0);
 483             columnReorderLine.resizeRelocate(0, columnReorderLine.snappedTopInset(), cw, lineHeight);
 484         }
 485 
 486         columnReorderLine.setVisible(tableHeaderRow.isReordering());
 487         columnReorderOverlay.setVisible(tableHeaderRow.isReordering());
 488 
 489         checkContentWidthState();
 490     }
 491 
 492     /**
 493      * Creates a new TableHeaderRow instance. By default this method should not be overridden, but in some
 494      * circumstances it makes sense (e.g. testing, or when extreme customization is desired).
 495      *
 496      * @return A new TableHeaderRow instance.
 497      */
 498     protected TableHeaderRow createTableHeaderRow() {
 499         return new TableHeaderRow(this);
 500     }
 501 
 502 
 503 
 504     /***************************************************************************
 505      *                                                                         *
 506      * Private implementation                                                  *
 507      *                                                                         *
 508      **************************************************************************/
 509 
 510     /**
 511      * Returns the {@code TableHeaderRow} created using {@link #createTableHeaderRow()}.
 512      *
 513      * @return the {@code TableHeaderRow} for this {@code TableViewSkinBase}
 514      * @since 12
 515      */
 516     protected TableHeaderRow getTableHeaderRow() {
 517         return tableHeaderRow;
 518     }
 519 
 520     private TableSelectionModel&lt;S&gt; getSelectionModel() {
 521         return TableSkinUtils.getSelectionModel(this);
 522     }
 523 
 524     private TableFocusModel&lt;M,?&gt; getFocusModel() {
 525         return TableSkinUtils.getFocusModel(this);
 526     }
 527 
 528     // returns the currently focused cell in the focus model
 529     private TablePositionBase&lt;? extends TC&gt; getFocusedCell() {
 530         return TableSkinUtils.getFocusedCell(this);
 531     }
 532 
 533     // returns an ObservableList of the visible leaf columns of the control
 534     private ObservableList&lt;? extends TC&gt; getVisibleLeafColumns() {
 535         return TableSkinUtils.getVisibleLeafColumns(this);
 536     }
 537 
 538     /** {@inheritDoc} */
 539     @Override protected void updateItemCount() {
 540         updatePlaceholderRegionVisibility();
 541 
 542         int oldCount = itemCount;
 543         int newCount = getItemCount();
 544 
 545         itemCount = newCount;
 546 
 547         if (itemCount == 0) {
 548             flow.getHbar().setValue(0.0);
 549         }
 550 
 551         // if this is not called even when the count is the same, we get a
 552         // memory leak in VirtualFlow.sheet.children. This can probably be
 553         // optimised in the future when time permits.
 554         flow.setCellCount(newCount);
 555 
 556         if (newCount != oldCount) {
 557             // FIXME updateItemCount is called _a lot_. Perhaps we can make rebuildCells
 558             // smarter. Imagine if items has one million items added - do we really
 559             // need to rebuildCells a million times? Maybe this is better now that
 560             // we do rebuildCells instead of recreateCells.
 561             requestRebuildCells();
 562         } else {
 563             needCellsReconfigured = true;
 564         }
 565     }
 566 
 567     private void checkContentWidthState() {
 568         // we test for item count here to resolve RT-14855, where the column
 569         // widths weren&#39;t being resized properly when in constrained layout mode
 570         // if there were no items.
 571         if (contentWidthDirty || getItemCount() == 0) {
 572             updateContentWidth();
 573             contentWidthDirty = false;
 574         }
 575     }
 576 
 577     void horizontalScroll() {
 578         tableHeaderRow.updateScrollX();
 579     }
 580 
 581     /**
 582      * Called when the focus is set on the cell above the current focused cell in order to scroll to it to make it
 583      * visible.
 584      *
 585      * @since 12
 586      */
 587     protected void onFocusAboveCell() {
 588         TableFocusModel&lt;M, ?&gt; fm = getFocusModel();
 589         if (fm == null) return;
 590 
 591         flow.scrollTo(fm.getFocusedIndex());
 592     }
 593 
 594     /**
 595      * Called when the focus is set on the cell below the current focused cell in order to scroll to it to make it
 596      * visible.
 597      *
 598      * @since 12
 599      */
 600     protected void onFocusBelowCell() {
 601         TableFocusModel&lt;M, ?&gt; fm = getFocusModel();
 602         if (fm == null) return;
 603 
 604         flow.scrollTo(fm.getFocusedIndex());
 605     }
 606 
 607     /**
 608      * Called when the selection is set on the the cell above the current focused cell in order to scroll to it to make
 609      * it visible.
 610      *
 611      * @since 12
 612      */
 613     protected void onSelectAboveCell() {
 614         SelectionModel&lt;S&gt; sm = getSelectionModel();
 615         if (sm == null) return;
 616 
 617         flow.scrollTo(sm.getSelectedIndex());
 618     }
 619 
 620     /**
 621      * Called when the selection is set on the cell below the current focused cell in order to scroll to it to make it
 622      * visible.
 623      *
 624      * @since 12
 625      */
 626     protected void onSelectBelowCell() {
 627         SelectionModel&lt;S&gt; sm = getSelectionModel();
 628         if (sm == null) return;
 629 
 630         flow.scrollTo(sm.getSelectedIndex());
 631     }
 632 
 633     /**
 634      * Called when the selection is set on the left cell of the current selected one in order to horizontally scroll to
 635      * it to make it visible.
 636      *
 637      * @since 12
 638      */
 639     protected void onSelectLeftCell() {
 640         scrollHorizontally();
 641     }
 642 
 643     /**
 644      * Called when the selection is set on the right cell of the current selected one in order to horizontally scroll to
 645      * it to make it visible.
 646      *
 647      * @since 12
 648      */
 649     protected void onSelectRightCell() {
 650         scrollHorizontally();
 651     }
 652 
 653     /**
 654      * Called when the focus is set on the left cell of the current selected one in order to horizontally scroll to it
 655      * to make it visible.
 656      *
 657      * @since 12
 658      */
 659     protected void onFocusLeftCell() {
 660         scrollHorizontally();
 661     }
 662 
 663     /**
 664      * Called when the focus is set on the right cell of the current selected one in order to horizontally scroll to it
 665      * to make it visible.
 666      *
 667      * @since 12
 668      */
 669     protected void onFocusRightCell() {
 670         scrollHorizontally();
 671     }
 672 
 673     /**
 674      * Called when the selection is set on the first cell of the table (first row and first column) in order to scroll
 675      * to it to make it visible.
 676      *
 677      * @since 12
 678      */
 679     protected void onMoveToFirstCell() {
 680         flow.scrollTo(0);
 681         flow.setPosition(0);
 682     }
 683 
 684     /**
 685      * Called when the selection is set on the last cell of the table (last row and last column) in order to scroll to
 686      * it to make it visible.
 687      *
 688      * @since 12
 689      */
 690     protected void onMoveToLastCell() {
 691         int endPos = getItemCount();
 692         flow.scrollTo(endPos);
 693         flow.setPosition(1);
 694     }
 695 
 696     private void updateTableItems(ObservableList&lt;S&gt; oldList, ObservableList&lt;S&gt; newList) {
 697         if (oldList != null) {
 698             oldList.removeListener(weakRowCountListener);
 699         }
 700 
 701         if (newList != null) {
 702             newList.addListener(weakRowCountListener);
 703         }
 704 
 705         markItemCountDirty();
 706         getSkinnable().requestLayout();
 707     }
 708 
 709     Region getColumnReorderLine() {
 710         return columnReorderLine;
 711     }
 712 
 713     /**
 714      * Returns the index of the selected (or focused, if {@code isFocusDriven} is {@code true}) cell after a page scroll
 715      * operation. If the selected/focused cell is not the last fully visible cell, then the last fully visible cell is
 716      * selected/focused. Otherwise, the content is scrolled such that the cell is made visible at the top of the
 717      * viewport (and the new last fully visible cell is selected/focused instead).
 718      *
 719      * @param isFocusDriven {@code true} if focused cell should be considered over selection
 720      * @return the new index to select, or to focus if {@code isFocusDriven} is {@code true}
 721      * @since 12
 722      */
 723     protected int onScrollPageDown(boolean isFocusDriven) {
 724         TableSelectionModel&lt;S&gt; sm = getSelectionModel();
 725         if (sm == null) return -1;
 726 
 727         final int itemCount = getItemCount();
 728 
 729         I lastVisibleCell = flow.getLastVisibleCellWithinViewport();
 730         if (lastVisibleCell == null) return -1;
 731 
 732         int lastVisibleCellIndex = lastVisibleCell.getIndex();
 733 
 734         // we include this test here as the virtual flow will return cells that
 735         // exceed past the item count, so we need to clamp here (and further down
 736         // in this method also). See RT-19053 for more information.
 737         lastVisibleCellIndex = lastVisibleCellIndex &gt;= itemCount ? itemCount - 1 : lastVisibleCellIndex;
 738 
 739         // isSelected represents focus OR selection
 740         boolean isSelected;
 741         if (isFocusDriven) {
 742             isSelected = lastVisibleCell.isFocused() || isCellFocused(lastVisibleCellIndex);
 743         } else {
 744             isSelected = lastVisibleCell.isSelected() || isCellSelected(lastVisibleCellIndex);
 745         }
 746 
 747         if (isSelected) {
 748             boolean isLeadIndex = isLeadIndex(isFocusDriven, lastVisibleCellIndex);
 749 
 750             if (isLeadIndex) {
 751                 // if the last visible cell is selected, we want to shift that cell up
 752                 // to be the top-most cell, or at least as far to the top as we can go.
 753                 flow.scrollToTop(lastVisibleCell);
 754 
 755                 I newLastVisibleCell = flow.getLastVisibleCellWithinViewport();
 756                 lastVisibleCell = newLastVisibleCell == null ? lastVisibleCell : newLastVisibleCell;
 757             }
 758         }
 759 
 760         int newSelectionIndex = lastVisibleCell.getIndex();
 761         newSelectionIndex = newSelectionIndex &gt;= itemCount ? itemCount - 1 : newSelectionIndex;
 762         flow.scrollTo(newSelectionIndex);
 763         return newSelectionIndex;
 764     }
 765 
 766     /**
 767      * Returns the index of the selected (or focused, if {@code isFocusDriven} is {@code true}) cell after a page scroll
 768      * operation. If the selected/focused cell is not the first fully visible cell, then the first fully visible cell is
 769      * selected/focused. Otherwise, the content is scrolled such that the cell is made visible at the bottom of the
 770      * viewport (and the new first fully visible cell is selected/focused instead).
 771      *
 772      * @param isFocusDriven {@code true} if focused cell should be considered over selection
 773      * @return the new index to select, or to focus if {@code isFocusDriven} is {@code true}
 774      * @since 12
 775      */
 776     protected int onScrollPageUp(boolean isFocusDriven) {
 777         I firstVisibleCell = flow.getFirstVisibleCellWithinViewport();
 778         if (firstVisibleCell == null) return -1;
 779 
 780         int firstVisibleCellIndex = firstVisibleCell.getIndex();
 781 
 782         // isSelected represents focus OR selection
 783         boolean isSelected = false;
 784         if (isFocusDriven) {
 785             isSelected = firstVisibleCell.isFocused() || isCellFocused(firstVisibleCellIndex);
 786         } else {
 787             isSelected = firstVisibleCell.isSelected() || isCellSelected(firstVisibleCellIndex);
 788         }
 789 
 790         if (isSelected) {
 791             boolean isLeadIndex = isLeadIndex(isFocusDriven, firstVisibleCellIndex);
 792 
 793             if (isLeadIndex) {
 794                 // if the first visible cell is selected, we want to shift that cell down
 795                 // to be the bottom-most cell, or at least as far to the bottom as we can go.
 796                 flow.scrollToBottom(firstVisibleCell);
 797 
 798                 I newFirstVisibleCell = flow.getFirstVisibleCellWithinViewport();
 799                 firstVisibleCell = newFirstVisibleCell == null ? firstVisibleCell : newFirstVisibleCell;
 800             }
 801         }
 802 
 803         int newSelectionIndex = firstVisibleCell.getIndex();
 804         flow.scrollTo(newSelectionIndex);
 805         return newSelectionIndex;
 806     }
 807 
 808     private boolean isLeadIndex(boolean isFocusDriven, int index) {
 809         final TableSelectionModel&lt;S&gt; sm = getSelectionModel();
 810         final FocusModel&lt;M&gt; fm = getFocusModel();
 811 
 812         return (isFocusDriven &amp;&amp; fm.getFocusedIndex() == index)
 813                 || (! isFocusDriven &amp;&amp; sm.getSelectedIndex() == index);
 814     }
 815 
 816     /**
 817      * Keeps track of how many leaf columns are currently visible in this table.
 818      */
 819     private void updateVisibleColumnCount() {
 820         visibleColCount = getVisibleLeafColumns().size();
 821 
 822         updatePlaceholderRegionVisibility();
 823         requestRebuildCells();
 824     }
 825 
 826     private void updateVisibleLeafColumnWidthListeners(
 827             List&lt;? extends TC&gt; added, List&lt;? extends TC&gt; removed) {
 828 
 829         for (int i = 0, max = removed.size(); i &lt; max; i++) {
 830             TC tc = removed.get(i);
 831             tc.widthProperty().removeListener(weakWidthListener);
 832         }
 833         for (int i = 0, max = added.size(); i &lt; max; i++) {
 834             TC tc = added.get(i);
 835             tc.widthProperty().addListener(weakWidthListener);
 836         }
 837         requestRebuildCells();
 838     }
 839 
 840     final void updatePlaceholderRegionVisibility() {
 841         boolean visible = visibleColCount == 0 || getItemCount() == 0;
 842 
 843         if (visible) {
 844             if (placeholderRegion == null) {
 845                 placeholderRegion = new StackPane();
 846                 placeholderRegion.getStyleClass().setAll(&quot;placeholder&quot;);
 847                 getChildren().add(placeholderRegion);
 848             }
 849 
 850             Node placeholderNode = TableSkinUtils.placeholderProperty(this).get();
 851 
 852             if (placeholderNode == null) {
 853                 if (placeholderLabel == null) {
 854                     placeholderLabel = new Label();
 855                 }
 856                 String s = visibleColCount == 0 ? NO_COLUMNS_TEXT : EMPTY_TABLE_TEXT;
 857                 placeholderLabel.setText(s);
 858 
 859                 placeholderRegion.getChildren().setAll(placeholderLabel);
 860             } else {
 861                 placeholderRegion.getChildren().setAll(placeholderNode);
 862             }
 863         }
 864 
 865         flow.setVisible(! visible);
 866         if (placeholderRegion != null) {
 867             placeholderRegion.setVisible(visible);
 868         }
 869     }
 870 
 871     /*
 872      * It&#39;s often important to know how much width is available for content
 873      * within the table, and this needs to exclude the width of any vertical
 874      * scrollbar.
 875      */
 876     private void updateContentWidth() {
 877         double contentWidth = flow.getWidth();
 878 
 879         if (flow.getVbar().isVisible()) {
 880             contentWidth -= flow.getVbar().getWidth();
 881         }
 882 
 883         if (contentWidth &lt;= 0) {
 884             // Fix for RT-14855 when there is no content in the TableView.
 885             Control c = getSkinnable();
 886             contentWidth = c.getWidth() - (snappedLeftInset() + snappedRightInset());
 887         }
 888 
 889         contentWidth = Math.max(0.0, contentWidth);
 890 
 891         // FIXME this isn&#39;t perfect, but it prevents RT-14885, which results in
 892         // undesired horizontal scrollbars when in constrained resize mode
 893         getSkinnable().getProperties().put(&quot;TableView.contentWidth&quot;, Math.floor(contentWidth));
 894     }
 895 
 896     private void refreshView() {
 897         markItemCountDirty();
 898         Control c = getSkinnable();
 899         if (c != null) {
 900             c.requestLayout();
 901         }
 902     }
 903 
 904     /**
 905      * Scrolls to the column containing the current focused cell.
 906      * &lt;p&gt;
 907      * Handles the horizontal scrolling when the selection mode is cell-based and the newly selected cell belongs to a
 908      * column which is not completely visible.
 909      *
 910      * @since 12
 911      */
 912     public void scrollHorizontally() {
 913         TableFocusModel&lt;M, ?&gt; fm = getFocusModel();
 914         if (fm == null) return;
 915 
 916         TC col = getFocusedCell().getTableColumn();
 917         scrollHorizontally(col);
 918     }
 919 
 920     /**
 921      * Programmatically scrolls to the given column. This call will ensure that the column is aligned on the left edge
 922      * of the {@code TableView} and also that the columns don&#39;t become detached from the right edge of the table.
 923      *
 924      * @param col the column to scroll to
 925      * @since 12
 926      */
 927     protected void scrollHorizontally(TC col) {
 928         if (col == null || !col.isVisible()) return;
 929 
 930         final Control control = getSkinnable();
 931 
 932         // RT-37060 - if we are trying to scroll to a column that has not
 933         // yet even been rendered, we must wait until the layout pass has
 934         // happened and then do the scroll. The laziest way to do this is to
 935         // queue up the task to run later, at which point we will have hopefully
 936         // fully run the column through layout and css.
 937         TableColumnHeader header = tableHeaderRow.getColumnHeaderFor(col);
 938         if (header == null || header.getWidth() &lt;= 0) {
 939             Platform.runLater(() -&gt; scrollHorizontally(col));
 940             return;
 941         }
 942 
 943         // work out where this column header is, and it&#39;s width (start -&gt; end)
 944         double start = 0;
 945         for (TC c : getVisibleLeafColumns()) {
 946             if (c.equals(col)) break;
 947             start += c.getWidth();
 948         }
 949         double end = start + col.getWidth();
 950 
 951         // determine the visible width of the table
 952         double headerWidth = control.getWidth() - snappedLeftInset() - snappedRightInset();
 953 
 954         // determine by how much we need to translate the table to ensure that
 955         // the start position of this column lines up with the left edge of the
 956         // tableview, and also that the columns don&#39;t become detached from the
 957         // right edge of the table
 958         double pos = flow.getHbar().getValue();
 959         double max = flow.getHbar().getMax();
 960         double newPos;
 961 
 962         if (start &lt; pos &amp;&amp; start &gt;= 0) {
 963             newPos = start;
 964         } else {
 965             double delta = start &lt; 0 || end &gt; headerWidth ? start - pos : 0;
 966             newPos = pos + delta &gt; max ? max : pos + delta;
 967         }
 968 
 969         // FIXME we should add API in VirtualFlow so we don&#39;t end up going
 970         // direct to the hbar.
 971         // actually shift the flow - this will result in the header moving
 972         // as well
 973         flow.getHbar().setValue(newPos);
 974     }
 975 
 976     private boolean isCellSelected(int row) {
 977         TableSelectionModel&lt;S&gt; sm = getSelectionModel();
 978         if (sm == null) return false;
 979         if (! sm.isCellSelectionEnabled()) return false;
 980 
 981         int columnCount = getVisibleLeafColumns().size();
 982         for (int col = 0; col &lt; columnCount; col++) {
 983             if (sm.isSelected(row, TableSkinUtils.getVisibleLeafColumn(this,col))) {
 984                 return true;
 985             }
 986         }
 987 
 988         return false;
 989     }
 990 
 991     private boolean isCellFocused(int row) {
 992         TableFocusModel&lt;S,TC&gt; fm = (TableFocusModel&lt;S,TC&gt;)(Object)getFocusModel();
 993         if (fm == null) return false;
 994 
 995         int columnCount = getVisibleLeafColumns().size();
 996         for (int col = 0; col &lt; columnCount; col++) {
 997             if (fm.isFocused(row, TableSkinUtils.getVisibleLeafColumn(this,col))) {
 998                 return true;
 999             }
1000         }
1001 
1002         return false;
1003     }
1004 
1005 
1006 
1007     /***************************************************************************
1008      *                                                                         *
1009      * A11y                                                                    *
1010      *                                                                         *
1011      **************************************************************************/
1012 
1013     /** {@inheritDoc} */
1014     @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1015         switch (attribute) {
1016             case FOCUS_ITEM: {
1017                 TableFocusModel&lt;M,?&gt; fm = getFocusModel();
1018                 int focusedIndex = fm.getFocusedIndex();
1019                 if (focusedIndex == -1) {
1020                     if (placeholderRegion != null &amp;&amp; placeholderRegion.isVisible()) {
1021                         return placeholderRegion.getChildren().get(0);
1022                     }
1023                     if (getItemCount() &gt; 0) {
1024                         focusedIndex = 0;
1025                     } else {
1026                         return null;
1027                     }
1028                 }
1029                 return flow.getPrivateCell(focusedIndex);
1030             }
1031             case CELL_AT_ROW_COLUMN: {
1032                 int rowIndex = (Integer)parameters[0];
1033                 return flow.getPrivateCell(rowIndex);
1034             }
1035             case COLUMN_AT_INDEX: {
1036                 int index = (Integer)parameters[0];
1037                 TableColumnBase&lt;S,?&gt; column = TableSkinUtils.getVisibleLeafColumn(this,index);
1038                 return getTableHeaderRow().getColumnHeaderFor(column);
1039             }
1040             case HEADER: {
1041                 /* Not sure how this is used by Accessibility, but without this VoiceOver will not
1042                  * look for column headers */
1043                 return getTableHeaderRow();
1044             }
1045             case VERTICAL_SCROLLBAR: return flow.getVbar();
1046             case HORIZONTAL_SCROLLBAR: return flow.getHbar();
1047             default: return super.queryAccessibleAttribute(attribute, parameters);
1048         }
1049     }
1050 
1051 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
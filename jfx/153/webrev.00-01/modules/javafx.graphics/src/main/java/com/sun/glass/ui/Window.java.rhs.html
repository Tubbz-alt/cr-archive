<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/com/sun/glass/ui/Window.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package com.sun.glass.ui;
  26 
  27 import com.sun.glass.events.MouseEvent;
  28 import com.sun.glass.events.WindowEvent;
  29 import com.sun.prism.impl.PrismSettings;
  30 
  31 import java.lang.annotation.Native;
  32 
  33 import java.util.Collections;
  34 import java.util.LinkedList;
  35 import java.util.List;
  36 import java.util.Map;
  37 
  38 public abstract class Window {
  39 
  40     public static class EventHandler {
  41         public void handleWindowEvent(Window window, long time, int type) {
  42         }
  43 
  44         /**
  45          * Notifies a listener that the screen object for this Window instance
  46          * has been updated.
  47          *
  48          * Note that while the old and new screen objects may be different,
  49          * they can still represent the same physical screen. This can happen
  50          * if e.g. only a certain parameter of the screen has been updated such
  51          * as its scale factor.
  52          *
  53          * On some platforms when a window is moved to another physical screen
  54          * an app can receive this event twice. One representing the physical
  55          * screen change, and another - the display&#39;s parameters change. Note
  56          * that sending two events instead of just one is platform-specific.
  57          *
  58          * The event handler can use the {@link Screen#getNativeScreen} method
  59          * to determine if this is the same physical screen or not. If the
  60          * native system always creates new native screen instances, there&#39;s no
  61          * way for the app to distinguish between a real move to another screen
  62          * or jsut a parameters update event. Since this is a somewhat rare
  63          * event, an app is advised to always process it the same way.
  64          *
  65          * @see Window#getScreen
  66          */
  67         public void handleScreenChangedEvent(Window window, long time, Screen oldScreen, Screen newScreen) {
  68         }
  69 
  70         /**
  71          * Notifies the listener that the window level has changed. The Level should be one of
  72          * {@link com.sun.glass.ui.Window.Level#NORMAL}, {@link com.sun.glass.ui.Window.Level#FLOATING},
  73          * {@link com.sun.glass.ui.Window.Level#TOPMOST}.
  74          * @param level Level from {@link com.sun.glass.ui.Window.Level} class
  75          */
  76         public void handleLevelEvent(int level) {
  77         }
  78     }
  79 
  80     // Native object handle (HWND, or NSWindow*, etc.)
  81     private long ptr;
  82 
  83     // &#39;Delegate window&#39; ptr. Used in e.g. the Full Screen mode.
  84     private volatile long delegatePtr = 0L;
  85 
  86     // window list
  87     static private final LinkedList&lt;Window&gt; visibleWindows = new LinkedList&lt;Window&gt;();
  88      // Return a list of all visible windows.  Note that on platforms without a native window manager,
  89      // this list will be sorted in proper z-order
  90     static public synchronized List&lt;Window&gt; getWindows() {
  91         Application.checkEventThread();
  92         return Collections.unmodifiableList(Window.visibleWindows);
  93     }
  94 
  95     static public List&lt;Window&gt; getWindowsClone() {
  96         Application.checkEventThread();
  97         return (List&lt;Window&gt;)visibleWindows.clone();
  98     }
  99 
 100     // used by Lens Native
 101     static protected void add(Window window) {
 102         visibleWindows.add(window);
 103     }
 104 
 105     static protected void addFirst(Window window) {
 106         visibleWindows.addFirst(window);
 107     }
 108 
 109     // used by Lens Native
 110     static protected void remove(Window window) {
 111         visibleWindows.remove(window);
 112     }
 113 
 114     // window style mask
 115 
 116     // visual kind: mutually exclusive
 117     public static final int UNTITLED        = 0;
 118     public static final int TITLED          = 1 &lt;&lt; 0;
 119     public static final int TRANSPARENT     = 1 &lt;&lt; 1;
 120 
 121     // functional type: mutually exclusive
 122     /**
 123      * Normal window.
 124      *
 125      * Usual top-level window.
 126      */
 127     public static final int NORMAL          = 0;
 128     /**
 129      * An utility window.
 130      *
 131      * Often used for floating toolbars. It has smaller than usual decorations
 132      * and doesn&#39;t display a taskbar button.
 133      */
 134     @Native public static final int UTILITY         = 1 &lt;&lt; 2;
 135     /**
 136      * A popup window.
 137      *
 138      * Used to display popups (tooltips, popup menus, etc.) Note that by
 139      * default it may display a task-bar button. To hide it the window must be
 140      * owned.
 141      */
 142     @Native public static final int POPUP           = 1 &lt;&lt; 3;
 143 
 144     // These affect window decorations as well as system menu actions,
 145     // so applicable to both decorated and undecorated windows
 146     @Native public static final int CLOSABLE        = 1 &lt;&lt; 4;
 147     @Native public static final int MINIMIZABLE     = 1 &lt;&lt; 5;
 148     @Native public static final int MAXIMIZABLE     = 1 &lt;&lt; 6;
 149 
 150     /**
 151      * Indicates that the window trim will draw from right to left.
 152      */
 153     @Native public static final int RIGHT_TO_LEFT     = 1 &lt;&lt; 7;
 154 
 155     /**
 156      * Indicates that a window will have a client area textured the same way as the platform decorations
 157      * and will not have a border between decorations and the client area.
 158      * This is supported not on all platforms, the client should check if the feature is supported by using
 159      * {@link com.sun.glass.ui.Application#supportsUnifiedWindows()}
 160      */
 161     @Native public static final int UNIFIED = 1 &lt;&lt; 8;
 162 
 163     /**
 164      * Indicates that the window is modal which affects whether the window is minimizable.
 165      */
 166     @Native public static final int MODAL = 1 &lt;&lt; 9;
 167 
 168     final static public class State {
 169         @Native public static final int NORMAL = 1;
 170         @Native public static final int MINIMIZED = 2;
 171         @Native public static final int MAXIMIZED = 3;
 172     }
 173 
 174     /**
 175      * Available window levels.
 176      *
 177      * Note that on some platforms both {@code FLOATING} and {@code TOPMOST}
 178      * may represent the same window level.
 179      *
 180      * @see #setLevel
 181      */
 182     public static final class Level {
 183         @Native private static final int _MIN = 1;
 184 
 185         /** Normal window level. */
 186         @Native public static final int NORMAL = 1;
 187 
 188         /** A window level that is above all other NORMAL windows. */
 189         @Native public static final int FLOATING = 2;
 190 
 191         /** A very topmost window level. May cover system UI elements such as dock, taskbar, etc. */
 192         @Native public static final int TOPMOST = 3;
 193 
 194         @Native private static final int _MAX = 3;
 195     }
 196 
 197     private final Window owner;
 198     private final long parent;
 199     private final int styleMask;
 200     private final boolean isDecorated;
 201     private boolean shouldStartUndecoratedMove = false;
 202 
 203     protected View view = null;
 204     protected Screen screen = null;
 205     private MenuBar menubar = null;
 206     private String title = &quot;&quot;;
 207     private UndecoratedMoveResizeHelper helper = null;
 208 
 209     private int state = State.NORMAL;
 210     private int level = Level.NORMAL;
 211     protected int x = 0;
 212     protected int y = 0;
 213     protected int width = 0;
 214     protected int height = 0;
 215     private float alpha = 1.0f;
 216     protected float platformScaleX = 1.0f;
 217     protected float platformScaleY = 1.0f;
 218     private float outputScaleX = 1.0f;
 219     private float outputScaleY = 1.0f;
 220     private float renderScaleX = 1.0f;
 221     private float renderScaleY = 1.0f;
 222     private boolean appletMode = false;
 223 
 224     // This is a workaround for RT-15970: as for embedded windows we don&#39;t
 225     // receive any MOVE notifications from the native platform, we poll
 226     // the window location on screen from timer and post synthetic events
 227     // if it has changed
 228     private Timer embeddedLocationTimer = null;
 229     private int lastKnownEmbeddedX = 0;
 230     private int lastKnownEmbeddedY = 0;
 231 
 232     private volatile boolean isResizable = false;
 233     private volatile boolean isVisible = false;
 234     private volatile boolean isFocused = false;
 235     private volatile boolean isFocusable = true;
 236     private volatile boolean isModal = false;
 237 
 238     // Indicates how many times setEnabled(false) has been called.
 239     // A value of 0 means the window is enabled.
 240     private volatile int disableCount = 0;
 241 
 242     private int minimumWidth = 0, minimumHeight = 0;
 243     private int maximumWidth = Integer.MAX_VALUE, maximumHeight = Integer.MAX_VALUE;
 244 
 245     private EventHandler eventHandler;
 246 
 247     protected abstract long _createWindow(long ownerPtr, long screenPtr, int mask);
 248     protected Window(Window owner, Screen screen, int styleMask) {
 249         Application.checkEventThread();
 250         switch (styleMask &amp; (TITLED | TRANSPARENT)) {
 251             case UNTITLED:
 252             case TITLED:
 253             case TRANSPARENT:
 254                 break;
 255             default:
 256                 throw new RuntimeException(&quot;The visual kind should be UNTITLED, TITLED, or TRANSPARENT, but not a combination of these&quot;);
 257         }
 258         switch (styleMask &amp; (POPUP | UTILITY)) {
 259             case NORMAL:
 260             case POPUP:
 261             case UTILITY:
 262                 break;
 263             default:
 264                 throw new RuntimeException(&quot;The functional type should be NORMAL, POPUP, or UTILITY, but not a combination of these&quot;);
 265         }
 266 
 267         if (((styleMask &amp; UNIFIED) != 0)
 268                 &amp;&amp; !Application.GetApplication().supportsUnifiedWindows()) {
 269            styleMask &amp;= ~UNIFIED;
 270         }
 271 
 272         if (((styleMask &amp; TRANSPARENT) != 0)
 273                 &amp;&amp; !Application.GetApplication().supportsTransparentWindows()) {
 274             styleMask &amp;= ~TRANSPARENT;
 275         }
 276 
 277 
 278         this.owner = owner;
 279         this.parent = 0L;
 280         this.styleMask = styleMask;
 281         this.isDecorated = (this.styleMask &amp; Window.TITLED) != 0;
 282 
 283         this.screen = screen != null ? screen : Screen.getMainScreen();
 284         if (PrismSettings.allowHiDPIScaling) {
 285             this.platformScaleX = this.screen.getPlatformScaleX();
 286             this.platformScaleY = this.screen.getPlatformScaleY();
 287             this.outputScaleX = this.screen.getRecommendedOutputScaleX();
 288             this.outputScaleY = this.screen.getRecommendedOutputScaleY();
 289         }
 290 
 291         this.ptr = _createWindow(owner != null ? owner.getNativeHandle() : 0L,
 292                 this.screen.getNativeScreen(), this.styleMask);
 293         if (this.ptr == 0L) {
 294             throw new RuntimeException(&quot;could not create platform window&quot;);
 295         }
 296     }
 297 
 298     protected abstract long _createChildWindow(long parent);
 299     /**
 300      * Constructs a child window of the specified native parent window.
 301      */
 302     protected Window(long parent) {
 303         Application.checkEventThread();
 304         this.owner = null;
 305         this.parent = parent;
 306         this.styleMask = Window.UNTITLED;
 307         this.isDecorated = false;
 308 
 309         // Note: we can&#39;t always catch screen changes when parent is moved...
 310         this.screen = null; // should infer from the parent
 311 
 312         this.ptr = _createChildWindow(parent);
 313         if (this.ptr == 0L) {
 314             throw new RuntimeException(&quot;could not create platform window&quot;);
 315         }
 316 
 317         if (screen == null) {
 318             screen = Screen.getMainScreen(); // start with a default
 319 
 320             if (PrismSettings.allowHiDPIScaling) {
 321                 this.platformScaleX = this.screen.getPlatformScaleX();
 322                 this.platformScaleY = this.screen.getPlatformScaleY();
 323                 this.outputScaleX = this.screen.getRecommendedOutputScaleX();
 324                 this.outputScaleY = this.screen.getRecommendedOutputScaleY();
 325             }
 326         }
 327     }
 328 
 329     public boolean isClosed() {
 330         Application.checkEventThread();
 331         return this.ptr == 0L;
 332     }
 333 
 334     private void checkNotClosed() {
 335         if (this.ptr == 0L) {
 336             throw new IllegalStateException(&quot;The window has already been closed&quot;);
 337         }
 338     }
 339 
 340     protected abstract boolean _close(long ptr);
 341     public void close() {
 342         Application.checkEventThread();
 343         if (this.view != null) {
 344             if (this.ptr != 0L) {
 345                 _setView(this.ptr, null);
 346             }
 347             this.view.setWindow(null);
 348             this.view.close();
 349             this.view = null;
 350         }
 351         if (this.ptr != 0L) {
 352             _close(this.ptr);
 353         }
<a name="1" id="anc1"></a><span class="line-modified"> 354         if (Window.focusedWindow == this) {</span>
 355             Window.focusedWindow = null;
 356         }
 357     }
 358 
 359     private boolean isChild() {
 360         Application.checkEventThread();
 361         return this.parent != 0L;
 362     }
 363 
 364     /** This method returns &quot;lowest-level&quot; native window handle
 365      * (HWND on Windows, NSWindow on Mac, X11 Window handle on linux-gtk etc.)
 366      */
 367     public long getNativeWindow() {
 368         Application.checkEventThread();
 369         checkNotClosed();
 370         return this.delegatePtr != 0L ? this.delegatePtr : this.ptr;
 371     }
 372 
 373     /**
 374      * This method returns &quot;higher-level&quot; native window handle.
 375      * glass-mat-lib-gtk GtkWindow.java returns GtkWindow pointer for example.
 376      */
 377     public long getNativeHandle() {
 378         Application.checkEventThread();
 379         return this.delegatePtr != 0L ? this.delegatePtr : this.ptr;
 380     }
 381 
 382     /**
 383      * return the &quot;raw&#39; pointer needed by subclasses to pass to native routines
 384      * @return the native pointer.
 385      */
 386     public long getRawHandle() {
 387         return ptr;
 388     }
 389 
 390     public Window getOwner() {
 391         Application.checkEventThread();
 392         return this.owner;
 393     }
 394 
 395     public View getView() {
 396         Application.checkEventThread();
 397         return this.view;
 398     }
 399 
 400     protected abstract boolean _setView(long ptr, View view);
 401     public void setView(final View view) {
 402         Application.checkEventThread();
 403         checkNotClosed();
 404         View oldView = getView();
 405         if (oldView == view) {
 406             return;
 407         }
 408 
 409         if (oldView != null) {
 410             oldView.setWindow(null);
 411         }
 412         if (view != null) {
 413             Window host = view.getWindow();
 414             if (host != null) {
 415                 host.setView(null);
 416             }
 417         }
 418 
 419         if (view != null &amp;&amp; _setView(this.ptr, view)) {
 420             this.view = view;
 421             this.view.setWindow(this);
 422             if (this.isDecorated == false) {
 423                 this.helper = new UndecoratedMoveResizeHelper();
 424             }
 425         } else {
 426             _setView(this.ptr, null);
 427             this.view = null;
 428         }
 429     }
 430 
 431     public Screen getScreen() {
 432         Application.checkEventThread();
 433         return this.screen;
 434     }
 435 
 436     protected void setScreen(Screen screen) {
 437         Application.checkEventThread();
 438 
 439         final Screen old = this.screen;
 440         this.screen = screen;
 441 
 442         if (this.eventHandler != null) {
 443             if ((old == null &amp;&amp; this.screen != null) ||
 444                 (old != null &amp;&amp; !old.equals(this.screen))) {
 445                 this.eventHandler.handleScreenChangedEvent(this, System.nanoTime(), old, this.screen);
 446             }
 447         }
 448     }
 449 
 450     public int getStyleMask() {
 451         Application.checkEventThread();
 452         return this.styleMask;
 453     }
 454 
 455     public MenuBar getMenuBar() {
 456         Application.checkEventThread();
 457         return this.menubar;
 458     }
 459 
 460     protected abstract boolean _setMenubar(long ptr, long menubarPtr);
 461     public void setMenuBar(final MenuBar menubar) {
 462         Application.checkEventThread();
 463         checkNotClosed();
 464         if (_setMenubar(this.ptr, menubar.getNativeMenu())) {
 465             this.menubar = menubar;
 466         }
 467     }
 468 
 469     public boolean isDecorated() {
 470         Application.checkEventThread();
 471         return this.isDecorated;
 472     }
 473 
 474     public boolean isMinimized() {
 475         Application.checkEventThread();
 476         return (this.state == State.MINIMIZED);
 477     }
 478 
 479     protected abstract boolean _minimize(long ptr, boolean minimize);
 480     public boolean minimize(final boolean minimize) {
 481         Application.checkEventThread();
 482         checkNotClosed();
 483         _minimize(this.ptr, minimize);
 484         //XXX: this is synchronous? On X11 this may not work
 485         return isMinimized();
 486     }
 487 
 488     public boolean isMaximized() {
 489         Application.checkEventThread();
 490         return (this.state == State.MAXIMIZED);
 491     }
 492 
 493     protected abstract boolean _maximize(long ptr, boolean maximize, boolean wasMaximized);
 494     public boolean maximize(final boolean maximize) {
 495         Application.checkEventThread();
 496         checkNotClosed();
 497         _maximize(ptr, maximize, isMaximized());
 498         return isMaximized();
 499     }
 500 
 501     protected void notifyScaleChanged(float platformScaleX, float platformScaleY,
 502                                       float outputScaleX, float outputScaleY)
 503     {
 504         if (!PrismSettings.allowHiDPIScaling) return;
 505         this.platformScaleX = platformScaleX;
 506         this.platformScaleY = platformScaleY;
 507         this.outputScaleX = outputScaleX;
 508         this.outputScaleY = outputScaleY;
 509         notifyRescale();
 510     }
 511 
 512     /**
 513      * Return the horizontal scale used to communicate window locations,
 514      * sizes, and event coordinates to/from the platform.
 515      * @return the horizontal platform scaling for screen locations
 516      */
 517     public final float getPlatformScaleX() {
 518         return platformScaleX;
 519     }
 520 
 521     /**
 522      * Return the vertical scale used to communicate window locations,
 523      * sizes, and event coordinates to/from the platform.
 524      * @return the vertical platform scaling for screen locations
 525      */
 526     public final float getPlatformScaleY() {
 527         return platformScaleY;
 528     }
 529 
 530     public void setRenderScaleX(float renderScaleX) {
 531         if (!PrismSettings.allowHiDPIScaling) return;
 532         this.renderScaleX = renderScaleX;
 533     }
 534 
 535     public void setRenderScaleY(float renderScaleY) {
 536         if (!PrismSettings.allowHiDPIScaling) return;
 537         this.renderScaleY = renderScaleY;
 538     }
 539 
 540     /**
 541      * Return the horizontal scale used for rendering the back buffer.
 542      * @return the horizontal scaling for rendering
 543      */
 544     public final float getRenderScaleX() {
 545         return renderScaleX;
 546     }
 547 
 548     /**
 549      * Return the vertical scale used for rendering to the back buffer.
 550      * @return the vertical scaling for rendering
 551      */
 552     public final float getRenderScaleY() {
 553         return renderScaleY;
 554     }
 555 
 556     public float getOutputScaleX() {
 557         return outputScaleX;
 558     }
 559 
 560     public float getOutputScaleY() {
 561         return outputScaleY;
 562     }
 563 
 564     protected abstract int _getEmbeddedX(long ptr);
 565     protected abstract int _getEmbeddedY(long ptr);
 566 
 567     private void checkScreenLocation() {
 568         this.x = _getEmbeddedX(ptr);
 569         this.y = _getEmbeddedY(ptr);
 570         if ((this.x != lastKnownEmbeddedX) || (this.y != lastKnownEmbeddedY)) {
 571             lastKnownEmbeddedX = this.x;
 572             lastKnownEmbeddedY = this.y;
 573             handleWindowEvent(System.nanoTime(), WindowEvent.MOVE);
 574         }
 575     }
 576 
 577     public int getX() {
 578         Application.checkEventThread();
 579         return this.x;
 580     }
 581 
 582     public int getY() {
 583         Application.checkEventThread();
 584         return this.y;
 585     }
 586 
 587     public int getWidth() {
 588         Application.checkEventThread();
 589         return this.width;
 590     }
 591 
 592     public int getHeight() {
 593         Application.checkEventThread();
 594         return this.height;
 595     }
 596 
 597     protected abstract void _setBounds(long ptr, int x, int y, boolean xSet, boolean ySet,
 598                                        int w, int h, int cw, int ch,
 599                                        float xGravity, float yGravity);
 600 
 601     /**
 602      * Sets the window bounds to the specified values.
 603      *
 604      * Gravity values specify how to correct window location if only its size
 605      * changes (for example when stage decorations are added). User initiated
 606      * resizing should be ignored and must not influence window location through
 607      * this mechanism.
 608      *
 609      * The corresponding correction formulas are:
 610      *
 611      * {@code x -= xGravity * deltaW}
 612      * {@code y -= yGravity * deltaH}
 613      *
 614      * @param x the new window horizontal position, ignored if xSet is set to
 615      *          false
 616      * @param y the new window vertical position, ignored if ySet is set to
 617      *          false
 618      * @param xSet indicates whether the x parameter is valid
 619      * @param ySet indicates whether the y parameter is valid
 620      * @param w the new window width, ignored if set to -1
 621      * @param h the new window height, ignored if set to -1
 622      * @param cw the new window content width, ignored if set to -1
 623      * @param ch the new window content height, ignored if set to -1
 624      * @param xGravity the xGravity coefficient
 625      * @param yGravity the yGravity coefficient
 626      */
 627     public void setBounds(float x, float y, boolean xSet, boolean ySet,
 628                           float w, float h, float cw, float ch,
 629                           float xGravity, float yGravity)
 630     {
 631         Application.checkEventThread();
 632         checkNotClosed();
 633         float pScaleX = platformScaleX;
 634         float pScaleY = platformScaleY;
 635         int px = screen.getPlatformX() + Math.round((x - screen.getX()) * pScaleX);
 636         int py = screen.getPlatformY() + Math.round((y - screen.getY()) * pScaleY);
 637         int pw = (int) (w &gt; 0 ? Math.ceil(w * pScaleX) : w);
 638         int ph = (int) (h &gt; 0 ? Math.ceil(h * pScaleY) : h);
 639         int pcw = (int) (cw &gt; 0 ? Math.ceil(cw * pScaleX) : cw);
 640         int pch = (int) (ch &gt; 0 ? Math.ceil(ch * pScaleY) : ch);
 641         _setBounds(ptr, px, py, xSet, ySet, pw, ph, pcw, pch, xGravity, yGravity);
 642     }
 643 
 644     public void setPosition(int x, int y) {
 645         Application.checkEventThread();
 646         checkNotClosed();
 647         _setBounds(ptr, x, y, true, true, 0, 0, 0, 0, 0, 0);
 648     }
 649 
 650     public void setSize(int w, int h) {
 651         Application.checkEventThread();
 652         checkNotClosed();
 653         _setBounds(ptr, 0, 0, false, false, w, h, 0, 0, 0, 0);
 654     }
 655 
 656     public void setContentSize(int cw, int ch) {
 657         Application.checkEventThread();
 658         checkNotClosed();
 659         _setBounds(ptr, 0, 0, false, false, 0, 0, cw, ch, 0, 0);
 660     }
 661 
 662     public boolean isVisible() {
 663         Application.checkEventThread();
 664         return this.isVisible;
 665     }
 666 
 667     /**
 668      * Generates a ViewEvent.MOVE aka insets (might have) changed.
 669      */
 670     private void synthesizeViewMoveEvent() {
 671         final View view = getView();
 672         if (view != null) {
 673             view.notifyView(com.sun.glass.events.ViewEvent.MOVE);
 674         }
 675     }
 676 
 677     protected abstract boolean _setVisible(long ptr, boolean visible);
 678     public void setVisible(final boolean visible) {
 679         Application.checkEventThread();
 680         if (this.isVisible != visible) {
 681             if (!visible) {
 682                 if (getView() != null) {
 683                     getView().setVisible(visible);
 684                 }
 685                 // Avoid native call if the window has been closed already
 686                 if (this.ptr != 0L) {
 687                     this.isVisible = _setVisible(this.ptr, visible);
 688                 } else {
 689                     this.isVisible = visible;
 690                 }
 691                 remove(this);
 692                 if (parent != 0) {
 693                     embeddedLocationTimer.stop();
 694                 }
 695             } else {
 696                 checkNotClosed();
 697                 this.isVisible = _setVisible(this.ptr, visible);
 698 
 699                 if (getView() != null) {
 700                     getView().setVisible(this.isVisible);
 701                 }
 702                 add(this);
 703                 if (parent != 0) {
 704                     final Runnable checkRunnable = () -&gt; checkScreenLocation();
 705                     final Runnable timerRunnable = () -&gt; Application.invokeLater(checkRunnable);
 706                     embeddedLocationTimer =
 707                            Application.GetApplication().createTimer(timerRunnable);
 708                     embeddedLocationTimer.start(16);
 709                 }
 710 
 711                 synthesizeViewMoveEvent();
 712             }
 713         }
 714     }
 715 
 716     protected abstract boolean _setResizable(long ptr, boolean resizable);
 717     public boolean setResizable(final boolean resizable) {
 718         Application.checkEventThread();
 719         checkNotClosed();
 720         if (this.isResizable != resizable) {
 721             if (_setResizable(this.ptr, resizable)) {
 722                 this.isResizable = resizable;
 723                 synthesizeViewMoveEvent();
 724             }
 725         }
 726         return isResizable;
 727     }
 728 
 729     public boolean isResizable() {
 730         Application.checkEventThread();
 731         return this.isResizable;
 732     }
 733 
 734     public boolean isUnifiedWindow() {
 735         //The UNIFIED flag is set only if it is supported
 736         return (this.styleMask &amp; Window.UNIFIED) != 0;
 737     }
 738 
 739     public boolean isTransparentWindow() {
 740         //The TRANSPARENT flag is set only if it is supported
 741         return (this.styleMask &amp; Window.TRANSPARENT) != 0;
 742     }
 743 
 744     private static volatile Window focusedWindow = null;
 745     public static Window getFocusedWindow() {
 746         Application.checkEventThread();
 747         return Window.focusedWindow;
 748     }
 749 
 750     private static void setFocusedWindow(final Window window) {
 751         Window.focusedWindow = window;
 752     }
 753 
 754     public boolean isFocused() {
 755         Application.checkEventThread();
 756         return this.isFocused;
 757     }
 758 
 759     protected abstract boolean _requestFocus(long ptr, int event);
 760     /**
 761      * Requests or resigns focus on this window.
 762      *
 763      * If this is a top-level window (owned or not), then the only possible
 764      * value for the {@code event} argument is WindowEvent.FOCUS_GAINED.
 765      * Otherwise, if the window is a child window, the argument may be
 766      * WindowEvent.FOCUS_LOST, FOCUS_GAINED, FOCUS_GAINED_FORWARD, or
 767      * FOCUS_GAINED_BACKWARD.
 768      *
 769      * @param event one of WindowEvent.FOCUS_LOST, FOCUS_GAINED, FOCUS_GAINED_FORWARD, FOCUS_GAINED_BACKWARD
 770      *
 771      * @throws IllegalArgumentException if the argument value is invalid for this window
 772      *
 773      * @return {@code true} if the operation succeeded
 774      */
 775     public boolean requestFocus(int event) {
 776         Application.checkEventThread();
 777         checkNotClosed();
 778 
 779         if (!isChild() &amp;&amp; event != WindowEvent.FOCUS_GAINED) {
 780             throw new IllegalArgumentException(&quot;Invalid focus event ID for top-level window&quot;);
 781         }
 782 
 783         if (isChild() &amp;&amp; (event &lt; WindowEvent._FOCUS_MIN || event &gt; WindowEvent._FOCUS_MAX)) {
 784             throw new IllegalArgumentException(&quot;Invalid focus event ID for child window&quot;);
 785         }
 786 
 787         if (event == WindowEvent.FOCUS_LOST &amp;&amp; !isFocused()) {
 788             // Already unfocused, nothing to do
 789             return true;
 790         }
 791 
 792         // At this point either A) the user requests focus for a focused or unfocused window,
 793         // or B) the window is focused and the user requests FOCUS_LOST
 794         if (!this.isFocusable) {
 795             // It&#39;s obviously A). Fail.
 796             return false;
 797         }
 798 
 799         return _requestFocus(this.ptr, event);
 800     }
 801 
 802     public boolean requestFocus() {
 803         Application.checkEventThread();
 804         return requestFocus(WindowEvent.FOCUS_GAINED);
 805     }
 806 
 807     protected abstract void _setFocusable(long ptr, boolean isFocusable);
 808     /**
 809      * Sets whether this window is focusable.
 810      *
 811      * Clicking an unfocusable window doesn&#39;t activate it.
 812      */
 813     public void setFocusable(final boolean isFocusable) {
 814         Application.checkEventThread();
 815         checkNotClosed();
 816         this.isFocusable = isFocusable;
 817         if (isEnabled()) {
 818             _setFocusable(this.ptr, isFocusable);
 819         }
 820     }
 821 
 822     protected abstract boolean _grabFocus(long ptr);
 823     protected abstract void _ungrabFocus(long ptr);
 824     /**
 825      * Grabs focus on this window.
 826      *
 827      * All mouse clicks that occur in this window&#39;s client area or client-areas
 828      * of any of its unfocusable owned windows are delivered as usual. Whenever
 829      * a click occurs on another app&#39;s window (not related via the ownership
 830      * relation with this one, or a focusable owned window), or on non-client
 831      * area of any window (titlebar, etc.), or any third-party app&#39;s window, or
 832      * native OS GUI (e.g. a taskbar), the grab is automatically reset, and the
 833      * window that held the grab receives the FOCUS_UNGRAB event.
 834      *
 835      * Note that for this functionality to work correctly, the window must have
 836      * a focus upon calling this method. All owned popup windows that should be
 837      * operable during the grabbed focus state (e.g. nested popup menus) must
 838      * be unfocusable (see {@link #setFocusable}). Clicking a focusable owned
 839      * window will reset the grab due to a focus transfer.
 840      *
 841      * The click that occurs in another window and causes resetting of the grab
 842      * may or may not be delivered to that other window depending on the native
 843      * OS behavior.
 844      *
 845      * If any of the application&#39;s windows already holds the grab, it is reset
 846      * prior to grabbing the focus for this window. The method may be called
 847      * multiple times for one window. Subsequent calls do not affect the grab
 848      * status unless it is reset between the calls, in which case the focus
 849      * is grabbed again.
 850      *
 851      * Note that grabbing the focus on an application window may prevent
 852      * delivering certain events to other applications until the grab is reset.
 853      * Therefore, if the application has finished showing popup windows based
 854      * on a user action (e.g. clicking a menu item), and doesn&#39;t require the
 855      * grab any more, it should call the {@link #ungrabFocus} method. The
 856      * FOCUS_UNGRAB event signals that the grab has been reset.
 857      *
 858      * A user event handler associated with a menu item must be invoked after
 859      * resetting the grab. Otherwise, if a developer debugs the application and
 860      * has installed a breakpoint in the event handler, the debugger may become
 861      * unoperable due to events blocking for other applications on some
 862      * platforms.
 863      *
 864      * @return {@code true} if the operation is successful
 865      * @throws IllegalStateException if the window isn&#39;t focused currently
 866      */
 867     public boolean grabFocus() {
 868         Application.checkEventThread();
 869         checkNotClosed();
 870 
 871         if (!isFocused()) {
 872             throw new IllegalStateException(&quot;The window must be focused when calling grabFocus()&quot;);
 873         }
 874 
 875         return _grabFocus(this.ptr);
 876     }
 877 
 878     /**
 879      * Manually ungrabs focus grabbed on this window previously.
 880      *
 881      * This method resets the grab, and forces sending of the FOCUS_UNGRAB
 882      * event. It should be used when popup windows (such as menus) should be
 883      * dismissed manually, e.g. when a user clicks a menu item which usually
 884      * causes the menus to hide.
 885      *
 886      * @see #grabFocus
 887      */
 888     public void ungrabFocus() {
 889         Application.checkEventThread();
 890         checkNotClosed();
 891         _ungrabFocus(this.ptr);
 892     }
 893 
 894     public String getTitle() {
 895         Application.checkEventThread();
 896         return this.title;
 897     }
 898 
 899     protected abstract boolean _setTitle(long ptr, String title);
 900     public void setTitle(String title) {
 901         Application.checkEventThread();
 902         checkNotClosed();
 903         if (title == null) {
 904             title = &quot;&quot;;
 905         }
 906         if (!title.equals(this.title)) {
 907             if (_setTitle(this.ptr, title)) {
 908                 this.title = title;
 909             }
 910         }
 911     }
 912 
 913     protected abstract void _setLevel(long ptr, int level);
 914     /**
 915      * Set the level of this window in the z-order.
 916      *
 917      * @param level one of the constants from {@link Window.Level}
 918      * @see Window.Level
 919      */
 920     public void setLevel(final int level) {
 921         Application.checkEventThread();
 922         checkNotClosed();
 923         if (level &lt; Level._MIN || level &gt; Level._MAX) {
 924             throw new IllegalArgumentException(&quot;Level should be in the range [&quot; + Level._MIN + &quot;..&quot; + Level._MAX + &quot;]&quot;);
 925         }
 926         if (this.level != level) {
 927             _setLevel(this.ptr, level);
 928             this.level = level;
 929         }
 930     }
 931 
 932     public int getLevel() {
 933         Application.checkEventThread();
 934         return this.level;
 935     }
 936 
 937     private boolean isInFullscreen() {
 938         final View view = getView();
 939         return view == null ? false : view.isInFullscreen();
 940     }
 941 
 942     // Invoked from the View class before sending FULLSCREEN_ to the View.EventHandler
 943     void notifyFullscreen(boolean entered) {
 944         final float alpha = getAlpha();
 945         if (alpha &lt; 1f) {
 946             if (entered) {
 947                 // Reset alpha at native level
 948                 _setAlpha(this.ptr, 1f);
 949             } else {
 950                 // restore the current opacity level
 951                 setAlpha(alpha);
 952             }
 953         }
 954     }
 955 
 956     protected abstract void _setAlpha(long ptr, float alpha);
 957     /**
 958      * Sets the uniform translucency level for this window.
 959      *
 960      * In the full screen mode the native window is always fully opaque.
 961      * The requested opacity level is applied upon exiting the full screen
 962      * mode only.
 963      *
 964      * @param alpha a value in the range [0..1f] (transparent..fully-opaque)
 965      */
 966     public void setAlpha(final float alpha) {
 967         Application.checkEventThread();
 968         checkNotClosed();
 969         if (alpha &lt; 0f || alpha &gt; 1f) {
 970             throw new IllegalArgumentException(&quot;Alpha should be in the range [0f..1f]&quot;);
 971         }
 972 
 973         this.alpha = alpha;
 974 
 975         if (alpha &lt; 1f &amp;&amp; isInFullscreen()) {
 976             return;
 977         }
 978 
 979         _setAlpha(this.ptr, this.alpha);
 980     }
 981 
 982     public float getAlpha() {
 983         Application.checkEventThread();
 984         return this.alpha;
 985     }
 986 
 987     public boolean getAppletMode() {
 988         return appletMode;
 989     }
 990 
 991     public void setAppletMode(boolean appletMode) {
 992         this.appletMode = appletMode;
 993     }
 994 
 995     protected abstract boolean _setBackground(long ptr, float r, float g, float b);
 996     /**
 997      * Set the background of the window.
 998      *
 999      * In most cases the View covers the whole window, so the background color
1000      * of the window is never seen by the user. However, a window w/o a view
1001      * does display the background color in its content area.
1002      *
1003      * On some platforms setting the background color may produce flickering
1004      * when painting the content area of the View (even though the View covers
1005      * the whole window).  Therefore it is recommended to set the background
1006      * color to windows w/o views only.
1007      */
1008     public boolean setBackground(final float r, final float g, final float b) {
1009         Application.checkEventThread();
1010         checkNotClosed();
1011         return _setBackground(this.ptr, r, g, b);
1012     }
1013 
1014     public boolean isEnabled() {
1015         Application.checkEventThread();
1016         return this.disableCount == 0;
1017     }
1018 
1019     protected abstract void _setEnabled(long ptr, boolean enabled);
1020     /**
1021      * Enables or disables the window.
1022      *
1023      * A disabled window is unfocusable by definition.
1024      * Also, key or mouse events aren&#39;t generated for disabled windows.
1025      *
1026      * When a user tries to activate a disabled window, or the window gets
1027      * accidentally brought to the top of the stacking order, the window
1028      * generates the FOCUS_DISABLED window event. A Glass client should react
1029      * to this event and bring the currently active modal blocker of the
1030      * disabled window to top by calling blocker&#39;s minimize(false), toFront(),
1031      * and requestFocus() methods. It may also &#39;blink&#39; the blocker window to
1032      * further attract user&#39;s attention.
1033      *
1034      * It&#39;s strongly recommended to process the FOCUS_DISABLED event
1035      * synchronously and as fast as possible to avoid any possible visual and
1036      * behavioral artifacts. Note that a disabled window may by no means gain
1037      * the input focus. The purpose of this event is to make sure that the
1038      * current modal blocker window is always visible to the user, and the user
1039      * understands why he can&#39;t interact with a disabled window.
1040      *
1041      * The method supports nested calls. If you disable the window twice
1042      * with two calls to setEnabled(false), you must call setEnabled(true)
1043      * twice as well in order to enable it afterwards. This is to support
1044      * &#39;nested&#39; modal dialogs when one modal dialog opens another one.
1045      */
1046     public void setEnabled(boolean enabled) {
1047         Application.checkEventThread();
1048         checkNotClosed();
1049         if (!enabled) {
1050             if (++this.disableCount &gt; 1) {
1051                 // already disabled
1052                 return;
1053             }
1054         } else {
1055             if (this.disableCount == 0) {
1056                 //should report a warning about an extra enable call ?
1057                 return;
1058             }
1059             if (--this.disableCount &gt; 0) {
1060                 // not yet enabled
1061                 return;
1062             }
1063         }
1064 
1065         //TODO: on Windows _setFocusable(this.ptr, isEnabled() ? this.isFocusable : false);
1066         _setEnabled(this.ptr, isEnabled());
1067     }
1068 
1069     public int getMinimumWidth() {
1070         Application.checkEventThread();
1071         return this.minimumWidth;
1072     }
1073 
1074     public int getMinimumHeight() {
1075         Application.checkEventThread();
1076         return this.minimumHeight;
1077     }
1078 
1079     public int getMaximumWidth() {
1080         Application.checkEventThread();
1081         return this.maximumWidth;
1082     }
1083 
1084     public int getMaximumHeight() {
1085         Application.checkEventThread();
1086         return this.maximumHeight;
1087     }
1088 
1089     protected abstract boolean _setMinimumSize(long ptr, int width, int height);
1090     /**
1091      * Sets the minimum size for this window.
1092      * A value of zero indicates no restriction.
1093      * If the native platform is unable to apply the constraints,
1094      * the values returned by getMinimumWidth()/Height() won&#39;t change.
1095      *
1096      * @throws IllegalArgumentException if width or height &lt; 0
1097      */
1098     public void setMinimumSize(int width, int height) {
1099         Application.checkEventThread();
1100         if (width &lt; 0 || height &lt; 0) {
1101             throw new IllegalArgumentException(&quot;The width and height must be &gt;= 0. Got: width=&quot; + width + &quot;; height=&quot; + height);
1102         }
1103         checkNotClosed();
1104         if (_setMinimumSize(this.ptr, width, height)) {
1105             this.minimumWidth = width;
1106             this.minimumHeight = height;
1107         }
1108     }
1109 
1110     protected abstract boolean _setMaximumSize(long ptr, int width, int height);
1111     /**
1112      * Sets the maximum size for this window.
1113      * A value of {@code Integer.MAX_VALUE} indicates no restriction.
1114      * If the native platform is unable to apply the constraints,
1115      * the values returned by getMaximumWidth()/Height() won&#39;t change.
1116      *
1117      * @throws IllegalArgumentException if width or height &lt; 0
1118      */
1119     public void setMaximumSize(int width, int height) {
1120         Application.checkEventThread();
1121         if (width &lt; 0 || height &lt; 0) {
1122             throw new IllegalArgumentException(&quot;The width and height must be &gt;= 0. Got: width=&quot; + width + &quot;; height=&quot; + height);
1123         }
1124         checkNotClosed();
1125         if (_setMaximumSize(this.ptr,
1126                     // for easier handling in native:
1127                     width == Integer.MAX_VALUE ? -1 : width,
1128                     height == Integer.MAX_VALUE ? -1 : height))
1129         {
1130             this.maximumWidth = width;
1131             this.maximumHeight = height;
1132         }
1133     }
1134 
1135 
1136     protected abstract void _setIcon(long ptr, Pixels pixels);
1137 
1138     // In the future we may want to pass a collection of Pixels, so that
1139     // the native platform could pick up the icon with the best dimensions
1140     public void setIcon(final Pixels pixels) {
1141         Application.checkEventThread();
1142         checkNotClosed();
1143         _setIcon(this.ptr, pixels);
1144     }
1145 
1146     protected abstract void _setCursor(long ptr, Cursor cursor);
1147 
1148     /**
1149      * Sets given cursor as the cursor for this window.
1150      * If the cursor is NONE, it is automatically hidden,
1151      * otherwise it is automatically shown.
1152      * @see Cursor#setVisible(boolean)
1153      */
1154     public void setCursor(Cursor cursor) {
1155         Application.checkEventThread();
1156         _setCursor(this.ptr, cursor);
1157     }
1158 
1159     protected abstract void _toFront(long ptr);
1160     /**
1161      * Bring the window to front in the z-order.
1162      * This method DOES NOT activate the window. To make it active use
1163      * the requestFocus() method right after calling toFront().
1164      */
1165     public void toFront() {
1166         Application.checkEventThread();
1167         checkNotClosed();
1168         _toFront(ptr);
1169     }
1170 
1171     protected abstract void _toBack(long ptr);
1172     /**
1173      * Send the window to the bottom of the stacking order.
1174      * This method may or may not de-focus this window
1175      * depending on the native platform. To make sure some other
1176      * window is activated, call requestFocus() on that other window.
1177      */
1178     public void toBack() {
1179         Application.checkEventThread();
1180         checkNotClosed();
1181         _toBack(this.ptr);
1182     }
1183 
1184     // *****************************************************
1185     // modality (prototype using native platform feature)
1186     // *****************************************************
1187     protected abstract void _enterModal(long ptr);
1188     /**
1189      * Enter modal state blocking everything except our window.
1190      */
1191     public void enterModal() {
1192         checkNotClosed();
1193         if (this.isModal == false) {
1194             this.isModal = true;
1195             _enterModal(this.ptr);
1196         }
1197     }
1198 
1199     protected abstract void _enterModalWithWindow(long dialog, long window);
1200     /**
1201      * Enter modal state only blocking the given window.
1202      * On Mac OS X this is done using a dialog sheet.
1203      */
1204     public void enterModal(final Window window) {
1205         checkNotClosed();
1206         if (this.isModal == false) {
1207             this.isModal = true;
1208             _enterModalWithWindow(this.ptr, window.getNativeHandle());
1209         }
1210     }
1211 
1212     protected abstract void _exitModal(long ptr);
1213     public void exitModal() {
1214         checkNotClosed();
1215         if (this.isModal == true) {
1216             _exitModal(this.ptr);
1217             this.isModal = false;
1218         }
1219     }
1220 
1221     public boolean isModal() {
1222         return this.isModal;
1223     }
1224 
1225     /** Only used on Mac when run inside a plugin */
1226     public void dispatchNpapiEvent(Map eventInfo) {
1227         Application.checkEventThread();
1228         throw new RuntimeException(&quot;This operation is not supported on this platform&quot;);
1229     }
1230 
1231     public EventHandler getEventHandler() {
1232         Application.checkEventThread();
1233         return eventHandler;
1234     }
1235 
1236     public void setEventHandler(EventHandler eventHandler) {
1237         Application.checkEventThread();
1238         this.eventHandler = eventHandler;
1239     }
1240 
1241     /**
1242      * Enables unconditional start of window move operation when
1243      * mouse is dragged in the client area.
1244      */
1245     public void setShouldStartUndecoratedMove(boolean v) {
1246         Application.checkEventThread();
1247         this.shouldStartUndecoratedMove = v;
1248     }
1249 
1250     // *****************************************************
1251     // notification callbacks
1252     // *****************************************************
1253     protected void notifyClose() {
1254         handleWindowEvent(System.nanoTime(), WindowEvent.CLOSE);
1255     }
1256 
1257     protected void notifyDestroy() {
1258         // Mac is known to send multiple WillClose notifications for some reason
1259         if (this.ptr == 0) {
1260             return;
1261         }
1262 
1263         handleWindowEvent(System.nanoTime(), WindowEvent.DESTROY);
1264 
1265         this.ptr = 0;
1266 
1267         // Do this after setting ptr to 0 to avoid a call to _setVisible()
1268         setVisible(false);
1269     }
1270 
1271     protected void notifyMove(final int x, final int y) {
1272         this.x = x;
1273         this.y = y;
1274         handleWindowEvent(System.nanoTime(), WindowEvent.MOVE);
1275     }
1276 
1277     protected void notifyRescale() {
1278         handleWindowEvent(System.nanoTime(), WindowEvent.RESCALE);
1279     }
1280 
1281     protected void notifyMoveToAnotherScreen(Screen newScreen) {
1282         setScreen(newScreen);
1283     }
1284 
1285     protected void setState(int state) {
1286         this.state = state;
1287     }
1288 
1289     /**
1290      * type values:
1291      *   - WindowEvent.RESIZE
1292      *   - WindowEvent.MINIMIZE
1293      *   - WindowEvent.MAXIMIZE
1294      *   - WindowEvent.RESTORE
1295      */
1296     protected void notifyResize(final int type, final int width, final int height) {
1297         if (type == WindowEvent.MINIMIZE) {
1298             this.state = State.MINIMIZED;
1299         } else {
1300             if (type == WindowEvent.MAXIMIZE) {
1301                 this.state = State.MAXIMIZED;
1302             } else { // WindowEvent.RESIZE or WindowEvent.RESTORE
1303                 this.state = State.NORMAL;
1304             }
1305             this.width = width;
1306             this.height = height;
1307 
1308             // update moveRect/resizeRect
1309             if (this.helper != null){
1310                 this.helper.updateRectangles();
1311             }
1312         }
1313         handleWindowEvent(System.nanoTime(), type);
1314 
1315         /*
1316          * Send RESIZE notification as MAXIMIZE and RESTORE change the window size
1317          */
1318         if (type == WindowEvent.MAXIMIZE || type == WindowEvent.RESTORE) {
1319             handleWindowEvent(System.nanoTime(), WindowEvent.RESIZE);
1320         }
1321     }
1322 
1323     protected void notifyFocus(int event) {
1324         final boolean focused = event != WindowEvent.FOCUS_LOST;
1325 
1326         if (this.isFocused != focused) {
1327             this.isFocused = focused;
1328             if (this.isFocused &amp;&amp; this.isVisible) {
1329                 setFocusedWindow(this);
1330             } else {
1331                 setFocusedWindow(null);
1332             }
1333             handleWindowEvent(System.nanoTime(), event);
1334         }
1335     }
1336 
1337     protected void notifyFocusDisabled() {
1338         handleWindowEvent(System.nanoTime(), WindowEvent.FOCUS_DISABLED);
1339     }
1340 
1341     protected void notifyFocusUngrab() {
1342         handleWindowEvent(System.nanoTime(), WindowEvent.FOCUS_UNGRAB);
1343     }
1344 
1345     protected void notifyDelegatePtr(long ptr) {
1346         this.delegatePtr = ptr;
1347     }
1348 
1349     // *****************************************************
1350     // window event handlers
1351     // *****************************************************
1352     protected void handleWindowEvent(long time, int type) {
1353         if (this.eventHandler != null) {
1354             this.eventHandler.handleWindowEvent(this, time, type);
1355         }
1356     }
1357 
1358     // *****************************************************
1359     // programmatical move/resize
1360     // *****************************************************
1361     /** Sets &quot;programmatical move&quot; rectangle.
1362      * The rectangle is measured from top of the View:
1363      * width is View.width, height is size.
1364      *
1365      * throws RuntimeException for decorated window.
1366      */
1367     public void setUndecoratedMoveRectangle(int size) {
1368         Application.checkEventThread();
1369         if (this.isDecorated == true) {
1370             //throw new RuntimeException(&quot;setUndecoratedMoveRectangle is only valid for Undecorated Window&quot;);
1371             System.err.println(&quot;Glass Window.setUndecoratedMoveRectangle is only valid for Undecorated Window. In the future this will be hard error.&quot;);
1372             Thread.dumpStack();
1373             return;
1374         }
1375 
1376         if (this.helper != null) {
1377             this.helper.setMoveRectangle(size);
1378         }
1379     }
1380     /** The method called only for undecorated windows
1381      * x, y: mouse coordinates (in View space).
1382      *
1383      * throws RuntimeException for decorated window.
1384      */
1385     public boolean shouldStartUndecoratedMove(final int x, final int y) {
1386         Application.checkEventThread();
1387         if (this.shouldStartUndecoratedMove == true) {
1388             return true;
1389         }
1390         if (this.isDecorated == true) {
1391             return false;
1392         }
1393 
1394         if (this.helper != null) {
1395             return this.helper.shouldStartMove(x, y);
1396         } else {
1397             return false;
1398         }
1399     }
1400 
1401     /** Sets &quot;programmatical resize&quot; rectangle.
1402      * The rectangle is measured from top of the View:
1403      * width is View.width, height is size.
1404      *
1405      * throws RuntimeException for decorated window.
1406      */
1407     public void setUndecoratedResizeRectangle(int size) {
1408         Application.checkEventThread();
1409         if ((this.isDecorated == true) || (this.isResizable == false)) {
1410             //throw new RuntimeException(&quot;setUndecoratedMoveRectangle is only valid for Undecorated Resizable Window&quot;);
1411             System.err.println(&quot;Glass Window.setUndecoratedResizeRectangle is only valid for Undecorated Resizable Window. In the future this will be hard error.&quot;);
1412             Thread.dumpStack();
1413             return;
1414         }
1415 
1416         if (this.helper != null) {
1417             this.helper.setResizeRectangle(size);
1418         }
1419     }
1420 
1421     /** The method called only for undecorated windows
1422      * x, y: mouse coordinates (in View space).
1423      *
1424      * throws RuntimeException for decorated window.
1425      */
1426     public boolean shouldStartUndecoratedResize(final int x, final int y) {
1427         Application.checkEventThread();
1428         if ((this.isDecorated == true) || (this.isResizable == false)) {
1429             return false;
1430         }
1431 
1432         if (this.helper != null) {
1433             return this.helper.shouldStartResize(x, y);
1434         }  else {
1435             return false;
1436         }
1437     }
1438 
1439     /** Mouse event handler for processing programmatical resize/move
1440      * (for undecorated windows only).
1441      * Must be called by View.
1442      * x &amp; y are View coordinates.
1443      * NOTE: it&#39;s package private!
1444      * @return true if the event is processed by the window,
1445      *         false if it has to be delivered to the app
1446      */
1447     boolean handleMouseEvent(int type, int button, int x, int y, int xAbs, int yAbs) {
1448         if (this.isDecorated == false) {
1449             return this.helper.handleMouseEvent(type, button, x, y, xAbs, yAbs);
1450         }
1451         return false;
1452     }
1453 
1454     @Override
1455     public String toString() {
1456         Application.checkEventThread();
1457         return  &quot;Window:&quot;+&quot;\n&quot;
1458                 + &quot;    ptr: &quot; + getNativeWindow() + &quot;\n&quot;
1459                 + &quot;    screen ptr: &quot; + (screen != null ? screen.getNativeScreen() : &quot;null&quot;) + &quot;\n&quot;
1460                 + &quot;    isDecorated: &quot; + isDecorated() + &quot;\n&quot;
1461                 + &quot;    title: &quot; + getTitle() + &quot;\n&quot;
1462                 + &quot;    visible: &quot; + isVisible() + &quot;\n&quot;
1463                 + &quot;    focused: &quot; + isFocused() + &quot;\n&quot;
1464                 + &quot;    modal: &quot; + isModal() + &quot;\n&quot;
1465                 + &quot;    state: &quot; + state + &quot;\n&quot;
1466                 + &quot;    x: &quot; + getX() + &quot;, y: &quot; + getY() + &quot;, w: &quot; + getWidth() + &quot;, h: &quot; + getHeight() + &quot;\n&quot;
1467                 + &quot;&quot;;
1468     }
1469 
1470     // &quot;programmical&quot; move/resize support for undecorated windows
1471 
1472     static private class TrackingRectangle {
1473         int size = 0;
1474         int x = 0, y = 0, width = 0, height = 0;
1475         boolean contains(final int x, final int y) {
1476             return ((size &gt; 0) &amp;&amp;
1477                     (x &gt;= this.x) &amp;&amp; (x &lt; (this.x + this.width)) &amp;&amp;
1478                         (y &gt;= this.y) &amp;&amp; (y &lt; (this.y + this.height)));
1479         }
1480     }
1481 
1482     protected void notifyLevelChanged(int level) {
1483         this.level = level;
1484         if (this.eventHandler != null) {
1485             this.eventHandler.handleLevelEvent(level);
1486         }
1487     }
1488 
1489     private class UndecoratedMoveResizeHelper {
1490         TrackingRectangle moveRect = null;
1491         TrackingRectangle resizeRect = null;
1492 
1493         boolean inMove = false;         // we are in &quot;move&quot; mode
1494         boolean inResize = false;       // we are in &quot;resize&quot; mode
1495 
1496         int startMouseX, startMouseY;   // start mouse coords
1497         int startX, startY;             // start window location (for move)
1498         int startWidth, startHeight;    // start window size (for resize)
1499 
1500         UndecoratedMoveResizeHelper() {
1501             this.moveRect = new TrackingRectangle();
1502             this.resizeRect = new TrackingRectangle();
1503         }
1504 
1505         void setMoveRectangle(final int size) {
1506             this.moveRect.size = size;
1507 
1508             this.moveRect.x = 0;
1509             this.moveRect.y = 0;
1510             this.moveRect.width = getWidth();
1511             this.moveRect.height = this.moveRect.size;
1512         }
1513 
1514         boolean shouldStartMove(final int x, final int y) {
1515             return this.moveRect.contains(x, y);
1516         }
1517 
1518         boolean inMove() {
1519             return this.inMove;
1520         }
1521 
1522         void startMove(final int x, final int y) {
1523             this.inMove = true;
1524 
1525             this.startMouseX = x;
1526             this.startMouseY = y;
1527 
1528             this.startX = getX();
1529             this.startY = getY();
1530         }
1531 
1532         void deltaMove(final int x, final int y) {
1533             int deltaX = x - this.startMouseX;
1534             int deltaY = y - this.startMouseY;
1535 
1536             setPosition(this.startX + deltaX, this.startY + deltaY);
1537         }
1538 
1539         void stopMove() {
1540             this.inMove = false;
1541         }
1542 
1543         void setResizeRectangle(final int size) {
1544             this.resizeRect.size = size;
1545 
1546             // set the rect (bottom right corner of the Window)
1547             this.resizeRect.x = getWidth() - this.resizeRect.size;
1548             this.resizeRect.y = getHeight() - this.resizeRect.size;
1549             this.resizeRect.width = this.resizeRect.size;
1550             this.resizeRect.height = this.resizeRect.size;
1551         }
1552 
1553         boolean shouldStartResize(final int x, final int y) {
1554             return this.resizeRect.contains(x, y);
1555         }
1556 
1557         boolean inResize() {
1558             return this.inResize;
1559         }
1560 
1561         void startResize(final int x, final int y) {
1562             this.inResize = true;
1563 
1564             this.startMouseX = x;
1565             this.startMouseY = y;
1566 
1567             this.startWidth = getWidth();
1568             this.startHeight = getHeight();
1569         }
1570 
1571         void deltaResize(final int x, final int y) {
1572             int deltaX = x - this.startMouseX;
1573             int deltaY = y - this.startMouseY;
1574 
1575             setSize(this.startWidth + deltaX, this.startHeight + deltaY);
1576         }
1577 
1578         protected void stopResize() {
1579             this.inResize = false;
1580         }
1581 
1582         void updateRectangles() {
1583             if (this.moveRect.size &gt; 0) {
1584                 setMoveRectangle(this.moveRect.size);
1585             }
1586             if (this.resizeRect.size &gt; 0) {
1587                 setResizeRectangle(this.resizeRect.size);
1588             }
1589         }
1590 
1591         boolean handleMouseEvent(final int type, final int button, final int x, final int y, final int xAbs, final int yAbs) {
1592             switch (type) {
1593                 case MouseEvent.DOWN:
1594                     if (button == MouseEvent.BUTTON_LEFT) {
1595                         if (shouldStartUndecoratedMove(x, y) == true) {
1596                             startMove(xAbs, yAbs);
1597                             return true;
1598                         } else if (shouldStartUndecoratedResize(x, y) == true) {
1599                             startResize(xAbs, yAbs);
1600                             return true;
1601                         }
1602                     }
1603                     break;
1604 
1605                 case MouseEvent.MOVE:
1606                 case MouseEvent.DRAG:
1607                     if (inMove() == true) {
1608                         deltaMove(xAbs, yAbs);
1609                         return true;
1610                     } else if (inResize() == true) {
1611                         deltaResize(xAbs, yAbs);
1612                         return true;
1613                     }
1614                     break;
1615 
1616                 case MouseEvent.UP:
1617                     boolean wasProcessed = inMove() || inResize();
1618                     stopResize();
1619                     stopMove();
1620                     return wasProcessed;
1621             }
1622             return false;
1623         }
1624     }
1625 
1626     /**
1627      * Requests text input in form of native keyboard for text component
1628      * contained by this Window. Native text input component is drawn on the place
1629      * of JavaFX component to cover it completely and to provide native text editing
1630      * techniques. Any change of text is immediately reflected in JavaFX text component.
1631      *
1632      * @param text text to be shown in the native text input component
1633      * @param type type of text input component @see com.sun.javafx.scene.control.behavior.TextInputTypes
1634      * @param width width of JavaFX text input component
1635      * @param height height of JavaFX text input component
1636      * @param M standard transformation matrix for drawing the native text component derived from JavaFX component
1637      */
1638     public void requestInput(String text, int type, double width, double height,
1639                                 double Mxx, double Mxy, double Mxz, double Mxt,
1640                                 double Myx, double Myy, double Myz, double Myt,
1641                                 double Mzx, double Mzy, double Mzz, double Mzt) {
1642         Application.checkEventThread();
1643         _requestInput(this.ptr, text, type, width, height,
1644                         Mxx, Mxy, Mxz, Mxt,
1645                         Myx, Myy, Myz, Myt,
1646                         Mzx, Mzy, Mzz, Mzt);
1647     }
1648 
1649     /**
1650      * Native keyboard for text input is no longer necessary.
1651      * Keyboard will be hidden and native text input component too.
1652      */
1653     public void releaseInput() {
1654         Application.checkEventThread();
1655         _releaseInput(this.ptr);
1656     }
1657 
1658     protected abstract void _requestInput(long ptr, String text, int type, double width, double height,
1659                                             double Mxx, double Mxy, double Mxz, double Mxt,
1660                                             double Myx, double Myy, double Myz, double Myt,
1661                                             double Mzx, double Mzy, double Mzz, double Mzt);
1662 
1663     protected abstract void _releaseInput(long ptr);
1664 
1665 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
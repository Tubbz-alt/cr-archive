<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.fxml/src/main/java/javafx/fxml/FXMLLoader.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.fxml;
  27 
  28 import com.sun.javafx.util.Logging;
  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.io.InputStreamReader;
  32 import java.lang.reflect.Array;
  33 import java.lang.reflect.Constructor;
  34 import java.lang.reflect.Field;
  35 import java.lang.reflect.InvocationTargetException;
  36 import java.lang.reflect.Method;
  37 import java.lang.reflect.Modifier;
  38 import java.lang.reflect.ParameterizedType;
  39 import java.lang.reflect.Type;
  40 import java.net.URL;
  41 import java.nio.charset.Charset;
  42 import java.util.AbstractMap;
  43 import java.util.ArrayList;
  44 import java.util.Collections;
  45 import java.util.HashMap;
  46 import java.util.LinkedList;
  47 import java.util.List;
  48 import java.util.Map;
  49 import java.util.ResourceBundle;
  50 import java.util.Set;
  51 import java.util.regex.Pattern;
  52 
  53 import javafx.beans.DefaultProperty;
  54 import javafx.beans.InvalidationListener;
  55 import javafx.beans.property.Property;
  56 import javafx.beans.value.ChangeListener;
  57 import javafx.beans.value.ObservableValue;
  58 import javafx.collections.*;
  59 import javafx.event.Event;
  60 import javafx.event.EventHandler;
  61 import javafx.util.Builder;
  62 import javafx.util.BuilderFactory;
  63 import javafx.util.Callback;
  64 
  65 import javax.script.Bindings;
<a name="1" id="anc1"></a><span class="line-added">  66 import javax.script.Compilable;</span>
<span class="line-added">  67 import javax.script.CompiledScript;</span>
  68 import javax.script.ScriptContext;
  69 import javax.script.ScriptEngine;
  70 import javax.script.ScriptEngineManager;
  71 import javax.script.ScriptException;
  72 import javax.script.SimpleBindings;
  73 import javax.xml.stream.XMLInputFactory;
  74 import javax.xml.stream.XMLStreamConstants;
  75 import javax.xml.stream.XMLStreamException;
  76 import javax.xml.stream.XMLStreamReader;
  77 import javax.xml.stream.util.StreamReaderDelegate;
  78 
  79 import com.sun.javafx.beans.IDProperty;
  80 import com.sun.javafx.fxml.BeanAdapter;
  81 import com.sun.javafx.fxml.ParseTraceElement;
  82 import com.sun.javafx.fxml.PropertyNotFoundException;
  83 import com.sun.javafx.fxml.expression.Expression;
  84 import com.sun.javafx.fxml.expression.ExpressionValue;
  85 import com.sun.javafx.fxml.expression.KeyPath;
  86 import static com.sun.javafx.FXPermissions.MODIFY_FXML_CLASS_LOADER_PERMISSION;
  87 import com.sun.javafx.fxml.FXMLLoaderHelper;
  88 import com.sun.javafx.fxml.MethodHelper;
  89 import java.net.MalformedURLException;
  90 import java.security.AccessController;
  91 import java.security.PrivilegedAction;
  92 import java.util.EnumMap;
  93 import java.util.Locale;
  94 import java.util.StringTokenizer;
  95 import com.sun.javafx.reflect.ConstructorUtil;
  96 import com.sun.javafx.reflect.MethodUtil;
  97 import com.sun.javafx.reflect.ReflectUtil;
  98 
  99 /**
 100  * Loads an object hierarchy from an XML document.
 101  * For more information, see the
 102  * &lt;a href=&quot;doc-files/introduction_to_fxml.html&quot;&gt;Introduction to FXML&lt;/a&gt;
 103  * document.
 104  *
 105  * @since JavaFX 2.0
 106  */
 107 public class FXMLLoader {
 108 
 109     // Indicates permission to get the ClassLoader
 110     private static final RuntimePermission GET_CLASSLOADER_PERMISSION =
 111         new RuntimePermission(&quot;getClassLoader&quot;);
 112 
 113     // Instance of StackWalker used to get caller class (must be private)
 114     private static final StackWalker walker =
 115         AccessController.doPrivileged((PrivilegedAction&lt;StackWalker&gt;) () -&gt;
 116             StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE));
 117 
 118     // Abstract base class for elements
 119     private abstract class Element {
 120         public final Element parent;
 121 
 122         public Object value = null;
 123         private BeanAdapter valueAdapter = null;
 124 
 125         public final LinkedList&lt;Attribute&gt; eventHandlerAttributes = new LinkedList&lt;Attribute&gt;();
 126         public final LinkedList&lt;Attribute&gt; instancePropertyAttributes = new LinkedList&lt;Attribute&gt;();
 127         public final LinkedList&lt;Attribute&gt; staticPropertyAttributes = new LinkedList&lt;Attribute&gt;();
 128         public final LinkedList&lt;PropertyElement&gt; staticPropertyElements = new LinkedList&lt;PropertyElement&gt;();
 129 
 130         public Element() {
 131             parent = current;
 132         }
 133 
 134         public boolean isCollection() {
 135             // Return true if value is a list, or if the value&#39;s type defines
 136             // a default property that is a list
 137             boolean collection;
 138             if (value instanceof List&lt;?&gt;) {
 139                 collection = true;
 140             } else {
 141                 Class&lt;?&gt; type = value.getClass();
 142                 DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);
 143 
 144                 if (defaultProperty != null) {
 145                     collection = getProperties().get(defaultProperty.value()) instanceof List&lt;?&gt;;
 146                 } else {
 147                     collection = false;
 148                 }
 149             }
 150 
 151             return collection;
 152         }
 153 
 154         @SuppressWarnings(&quot;unchecked&quot;)
 155         public void add(Object element) throws LoadException {
 156             // If value is a list, add element to it; otherwise, get the value
 157             // of the default property, which is assumed to be a list and add
 158             // to that (coerce to the appropriate type)
 159             List&lt;Object&gt; list;
 160             if (value instanceof List&lt;?&gt;) {
 161                 list = (List&lt;Object&gt;)value;
 162             } else {
 163                 Class&lt;?&gt; type = value.getClass();
 164                 DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);
 165                 String defaultPropertyName = defaultProperty.value();
 166 
 167                 // Get the list value
 168                 list = (List&lt;Object&gt;)getProperties().get(defaultPropertyName);
 169 
 170                 // Coerce the element to the list item type
 171                 if (!Map.class.isAssignableFrom(type)) {
 172                     Type listType = getValueAdapter().getGenericType(defaultPropertyName);
 173                     element = BeanAdapter.coerce(element, BeanAdapter.getListItemType(listType));
 174                 }
 175             }
 176 
 177             list.add(element);
 178         }
 179 
 180         public void set(Object value) throws LoadException {
 181             if (this.value == null) {
 182                 throw constructLoadException(&quot;Cannot set value on this element.&quot;);
 183             }
 184 
 185             // Apply value to this element&#39;s properties
 186             Class&lt;?&gt; type = this.value.getClass();
 187             DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);
 188             if (defaultProperty == null) {
 189                 throw constructLoadException(&quot;Element does not define a default property.&quot;);
 190             }
 191 
 192             getProperties().put(defaultProperty.value(), value);
 193         }
 194 
 195         public void updateValue(Object value) {
 196             this.value = value;
 197             valueAdapter = null;
 198         }
 199 
 200         public boolean isTyped() {
 201             return !(value instanceof Map&lt;?, ?&gt;);
 202         }
 203 
 204         public BeanAdapter getValueAdapter() {
 205             if (valueAdapter == null) {
 206                 valueAdapter = new BeanAdapter(value);
 207             }
 208 
 209             return valueAdapter;
 210         }
 211 
 212         @SuppressWarnings(&quot;unchecked&quot;)
 213         public Map&lt;String, Object&gt; getProperties() {
 214             return (isTyped()) ? getValueAdapter() : (Map&lt;String, Object&gt;)value;
 215         }
 216 
 217         public void processStartElement() throws IOException {
 218             for (int i = 0, n = xmlStreamReader.getAttributeCount(); i &lt; n; i++) {
 219                 String prefix = xmlStreamReader.getAttributePrefix(i);
 220                 String localName = xmlStreamReader.getAttributeLocalName(i);
 221                 String value = xmlStreamReader.getAttributeValue(i);
 222 
 223                 if (loadListener != null
 224                     &amp;&amp; prefix != null
 225                     &amp;&amp; prefix.equals(FX_NAMESPACE_PREFIX)) {
 226                     loadListener.readInternalAttribute(prefix + &quot;:&quot; + localName, value);
 227                 }
 228 
 229                 processAttribute(prefix, localName, value);
 230             }
 231         }
 232 
 233         public void processEndElement() throws IOException {
 234             // No-op
 235         }
 236 
 237         public void processCharacters() throws IOException {
 238             throw constructLoadException(&quot;Unexpected characters in input stream.&quot;);
 239         }
 240 
 241         public void processInstancePropertyAttributes() throws IOException {
 242             if (instancePropertyAttributes.size() &gt; 0) {
 243                 for (Attribute attribute : instancePropertyAttributes) {
 244                     processPropertyAttribute(attribute);
 245                 }
 246             }
 247         }
 248 
 249         public void processAttribute(String prefix, String localName, String value)
 250             throws IOException{
 251             if (prefix == null) {
 252                 // Add the attribute to the appropriate list
 253                 if (localName.startsWith(EVENT_HANDLER_PREFIX)) {
 254                     if (loadListener != null) {
 255                         loadListener.readEventHandlerAttribute(localName, value);
 256                     }
 257 
 258                     eventHandlerAttributes.add(new Attribute(localName, null, value));
 259                 } else {
 260                     int i = localName.lastIndexOf(&#39;.&#39;);
 261 
 262                     if (i == -1) {
 263                         // The attribute represents an instance property
 264                         if (loadListener != null) {
 265                             loadListener.readPropertyAttribute(localName, null, value);
 266                         }
 267 
 268                         instancePropertyAttributes.add(new Attribute(localName, null, value));
 269                     } else {
 270                         // The attribute represents a static property
 271                         String name = localName.substring(i + 1);
 272                         Class&lt;?&gt; sourceType = getType(localName.substring(0, i));
 273 
 274                         if (sourceType != null) {
 275                             if (loadListener != null) {
 276                                 loadListener.readPropertyAttribute(name, sourceType, value);
 277                             }
 278 
 279                             staticPropertyAttributes.add(new Attribute(name, sourceType, value));
 280                         } else if (staticLoad) {
 281                             if (loadListener != null) {
 282                                 loadListener.readUnknownStaticPropertyAttribute(localName, value);
 283                             }
 284                         } else {
 285                             throw constructLoadException(localName + &quot; is not a valid attribute.&quot;);
 286                         }
 287                     }
 288 
 289                 }
 290             } else {
 291                 throw constructLoadException(prefix + &quot;:&quot; + localName
 292                     + &quot; is not a valid attribute.&quot;);
 293             }
 294         }
 295 
 296         @SuppressWarnings(&quot;unchecked&quot;)
 297         public void processPropertyAttribute(Attribute attribute) throws IOException {
 298             String value = attribute.value;
 299             if (isBindingExpression(value)) {
 300                 // Resolve the expression
 301                 Expression expression;
 302 
 303                 if (attribute.sourceType != null) {
 304                     throw constructLoadException(&quot;Cannot bind to static property.&quot;);
 305                 }
 306 
 307                 if (!isTyped()) {
 308                     throw constructLoadException(&quot;Cannot bind to untyped object.&quot;);
 309                 }
 310 
 311                 // TODO We may want to identify binding properties in processAttribute()
 312                 // and apply them after build() has been called
 313                 if (this.value instanceof Builder) {
 314                     throw constructLoadException(&quot;Cannot bind to builder property.&quot;);
 315                 }
 316 
 317                 if (!isStaticLoad()) {
 318                     value = value.substring(BINDING_EXPRESSION_PREFIX.length(),
 319                             value.length() - 1);
 320                     expression = Expression.valueOf(value);
 321 
 322                     // Create the binding
 323                     BeanAdapter targetAdapter = new BeanAdapter(this.value);
 324                     ObservableValue&lt;Object&gt; propertyModel = targetAdapter.getPropertyModel(attribute.name);
 325                     Class&lt;?&gt; type = targetAdapter.getType(attribute.name);
 326 
 327                     if (propertyModel instanceof Property&lt;?&gt;) {
 328                         ((Property&lt;Object&gt;) propertyModel).bind(new ExpressionValue(namespace, expression, type));
 329                     }
 330                 }
 331             } else if (isBidirectionalBindingExpression(value)) {
 332                 throw constructLoadException(new UnsupportedOperationException(&quot;This feature is not currently enabled.&quot;));
 333             } else {
 334                 processValue(attribute.sourceType, attribute.name, value);
 335             }
 336         }
 337 
 338         private boolean isBindingExpression(String aValue) {
 339             return aValue.startsWith(BINDING_EXPRESSION_PREFIX)
 340                    &amp;&amp; aValue.endsWith(BINDING_EXPRESSION_SUFFIX);
 341         }
 342 
 343         private boolean isBidirectionalBindingExpression(String aValue) {
 344             return aValue.startsWith(BI_DIRECTIONAL_BINDING_PREFIX);
 345         }
 346 
 347         private boolean processValue(Class sourceType, String propertyName, String aValue)
 348             throws LoadException {
 349 
 350             boolean processed = false;
 351                 //process list or array first
 352                 if (sourceType == null &amp;&amp; isTyped()) {
 353                     BeanAdapter valueAdapter = getValueAdapter();
 354                     Class&lt;?&gt; type = valueAdapter.getType(propertyName);
 355 
 356                     if (type == null) {
 357                         throw new PropertyNotFoundException(&quot;Property \&quot;&quot; + propertyName
 358                             + &quot;\&quot; does not exist&quot; + &quot; or is read-only.&quot;);
 359                     }
 360 
 361                     if (List.class.isAssignableFrom(type)
 362                         &amp;&amp; valueAdapter.isReadOnly(propertyName)) {
 363                         populateListFromString(valueAdapter, propertyName, aValue);
 364                         processed = true;
 365                     } else if (type.isArray()) {
 366                         applyProperty(propertyName, sourceType,
 367                                 populateArrayFromString(type, aValue));
 368                         processed = true;
 369                     }
 370                 }
 371                 if (!processed) {
 372                     applyProperty(propertyName, sourceType, resolvePrefixedValue(aValue));
 373                     processed = true;
 374                 }
 375                 return processed;
 376         }
 377 
 378         /**
 379          * Resolves value prefixed with RELATIVE_PATH_PREFIX and RESOURCE_KEY_PREFIX.
 380          */
 381         private Object resolvePrefixedValue(String aValue) throws LoadException {
 382             if (aValue.startsWith(ESCAPE_PREFIX)) {
 383                 aValue = aValue.substring(ESCAPE_PREFIX.length());
 384 
 385                 if (aValue.length() == 0
 386                     || !(aValue.startsWith(ESCAPE_PREFIX)
 387                         || aValue.startsWith(RELATIVE_PATH_PREFIX)
 388                         || aValue.startsWith(RESOURCE_KEY_PREFIX)
 389                         || aValue.startsWith(EXPRESSION_PREFIX)
 390                         || aValue.startsWith(BI_DIRECTIONAL_BINDING_PREFIX))) {
 391                     throw constructLoadException(&quot;Invalid escape sequence.&quot;);
 392                 }
 393                 return aValue;
 394             } else if (aValue.startsWith(RELATIVE_PATH_PREFIX)) {
 395                 aValue = aValue.substring(RELATIVE_PATH_PREFIX.length());
 396                 if (aValue.length() == 0) {
 397                     throw constructLoadException(&quot;Missing relative path.&quot;);
 398                 }
 399                 if (aValue.startsWith(RELATIVE_PATH_PREFIX)) {
 400                     // The prefix was escaped
 401                     warnDeprecatedEscapeSequence(RELATIVE_PATH_PREFIX);
 402                     return aValue;
 403                 } else {
 404                         if (aValue.charAt(0) == &#39;/&#39;) {
 405                             // FIXME: JIGSAW -- use Class.getResourceAsStream if resource is in a module
 406                             final URL res = getClassLoader().getResource(aValue.substring(1));
 407                             if (res == null) {
 408                                 throw constructLoadException(&quot;Invalid resource: &quot; + aValue + &quot; not found on the classpath&quot;);
 409                             }
 410                             return res.toString();
 411                         } else {
 412                             try {
 413                                 return new URL(FXMLLoader.this.location, aValue).toString();
 414                             } catch (MalformedURLException e) {
 415                                 System.err.println(FXMLLoader.this.location + &quot;/&quot; + aValue);
 416                             }
 417                         }
 418                 }
 419             } else if (aValue.startsWith(RESOURCE_KEY_PREFIX)) {
 420                 aValue = aValue.substring(RESOURCE_KEY_PREFIX.length());
 421                 if (aValue.length() == 0) {
 422                     throw constructLoadException(&quot;Missing resource key.&quot;);
 423                 }
 424                 if (aValue.startsWith(RESOURCE_KEY_PREFIX)) {
 425                     // The prefix was escaped
 426                     warnDeprecatedEscapeSequence(RESOURCE_KEY_PREFIX);
 427                     return aValue;
 428                 } else {
 429                     // Resolve the resource value
 430                     if (resources == null) {
 431                         throw constructLoadException(&quot;No resources specified.&quot;);
 432                     }
 433                     if (!resources.containsKey(aValue)) {
 434                         throw constructLoadException(&quot;Resource \&quot;&quot; + aValue + &quot;\&quot; not found.&quot;);
 435                     }
 436 
 437                     return resources.getString(aValue);
 438                 }
 439             } else if (aValue.startsWith(EXPRESSION_PREFIX)) {
 440                 aValue = aValue.substring(EXPRESSION_PREFIX.length());
 441                 if (aValue.length() == 0) {
 442                     throw constructLoadException(&quot;Missing expression.&quot;);
 443                 }
 444                 if (aValue.startsWith(EXPRESSION_PREFIX)) {
 445                     // The prefix was escaped
 446                     warnDeprecatedEscapeSequence(EXPRESSION_PREFIX);
 447                     return aValue;
 448                 } else if (aValue.equals(NULL_KEYWORD)) {
 449                     // The attribute value is null
 450                     return null;
 451                 }
 452                 return Expression.get(namespace, KeyPath.parse(aValue));
 453             }
 454             return aValue;
 455         }
 456 
 457         /**
 458          * Creates an array of given type and populates it with values from
 459          * a string where tokens are separated by ARRAY_COMPONENT_DELIMITER.
 460          * If token is prefixed with RELATIVE_PATH_PREFIX a value added to
 461          * the array becomes relative to document location.
 462          */
 463         private Object populateArrayFromString(
 464                 Class&lt;?&gt;type,
 465                 String stringValue) throws LoadException {
 466 
 467             Object propertyValue = null;
 468             // Split the string and set the values as an array
 469             Class&lt;?&gt; componentType = type.getComponentType();
 470 
 471             if (stringValue.length() &gt; 0) {
 472                 String[] values = stringValue.split(ARRAY_COMPONENT_DELIMITER);
 473                 propertyValue = Array.newInstance(componentType, values.length);
 474                 for (int i = 0; i &lt; values.length; i++) {
 475                     Array.set(propertyValue, i,
 476                             BeanAdapter.coerce(resolvePrefixedValue(values[i].trim()),
 477                             type.getComponentType()));
 478                 }
 479             } else {
 480                 propertyValue = Array.newInstance(componentType, 0);
 481             }
 482             return propertyValue;
 483         }
 484 
 485         /**
 486          * Populates list with values from a string where tokens are separated
 487          * by ARRAY_COMPONENT_DELIMITER. If token is prefixed with RELATIVE_PATH_PREFIX
 488          * a value added to the list becomes relative to document location.
 489          */
 490         private void populateListFromString(
 491                 BeanAdapter valueAdapter,
 492                 String listPropertyName,
 493                 String stringValue) throws LoadException {
 494             // Split the string and add the values to the list
 495             List&lt;Object&gt; list = (List&lt;Object&gt;)valueAdapter.get(listPropertyName);
 496             Type listType = valueAdapter.getGenericType(listPropertyName);
 497             Type itemType = (Class&lt;?&gt;)BeanAdapter.getGenericListItemType(listType);
 498 
 499             if (itemType instanceof ParameterizedType) {
 500                 itemType = ((ParameterizedType)itemType).getRawType();
 501             }
 502 
 503             if (stringValue.length() &gt; 0) {
 504                 String[] values = stringValue.split(ARRAY_COMPONENT_DELIMITER);
 505 
 506                 for (String aValue: values) {
 507                     aValue = aValue.trim();
 508                     list.add(
 509                             BeanAdapter.coerce(resolvePrefixedValue(aValue),
 510                                                (Class&lt;?&gt;)itemType));
 511                 }
 512             }
 513         }
 514 
 515         public void warnDeprecatedEscapeSequence(String prefix) {
 516             System.err.println(prefix + prefix + &quot; is a deprecated escape sequence. &quot;
 517                 + &quot;Please use \\&quot; + prefix + &quot; instead.&quot;);
 518         }
 519 
 520         public void applyProperty(String name, Class&lt;?&gt; sourceType, Object value) {
 521             if (sourceType == null) {
 522                 getProperties().put(name, value);
 523             } else {
 524                 BeanAdapter.put(this.value, sourceType, name, value);
 525             }
 526         }
 527 
 528         private Object getExpressionObject(String handlerValue) throws LoadException{
 529             if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
 530                 handlerValue = handlerValue.substring(EXPRESSION_PREFIX.length());
 531 
 532                 if (handlerValue.length() == 0) {
 533                     throw constructLoadException(&quot;Missing expression reference.&quot;);
 534                 }
 535 
 536                 Object expression = Expression.get(namespace, KeyPath.parse(handlerValue));
 537                 if (expression == null) {
 538                     throw constructLoadException(&quot;Unable to resolve expression : $&quot; + handlerValue);
 539                 }
 540                 return expression;
 541             }
 542             return null;
 543         }
 544 
 545         private &lt;T&gt; T getExpressionObjectOfType(String handlerValue, Class&lt;T&gt; type) throws LoadException{
 546             Object expression = getExpressionObject(handlerValue);
 547             if (expression != null) {
 548                 if (type.isInstance(expression)) {
 549                     return (T) expression;
 550                 }
 551                 throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue +&quot;\&quot; expression.&quot;
 552                         + &quot;Does not point to a &quot; + type.getName());
 553             }
 554             return null;
 555         }
 556 
 557         private MethodHandler getControllerMethodHandle(String handlerName, SupportedType... types) throws LoadException {
 558             if (handlerName.startsWith(CONTROLLER_METHOD_PREFIX)) {
 559                 handlerName = handlerName.substring(CONTROLLER_METHOD_PREFIX.length());
 560 
 561                 if (!handlerName.startsWith(CONTROLLER_METHOD_PREFIX)) {
 562                     if (handlerName.length() == 0) {
 563                         throw constructLoadException(&quot;Missing controller method.&quot;);
 564                     }
 565 
 566                     if (controller == null) {
 567                         throw constructLoadException(&quot;No controller specified.&quot;);
 568                     }
 569 
 570                     for (SupportedType t : types) {
 571                         Method method = controllerAccessor
 572                                             .getControllerMethods()
 573                                             .get(t)
 574                                             .get(handlerName);
 575                         if (method != null) {
 576                             return new MethodHandler(controller, method, t);
 577                         }
 578                     }
 579                     Method method = controllerAccessor
 580                                         .getControllerMethods()
 581                                         .get(SupportedType.PARAMETERLESS)
 582                                         .get(handlerName);
 583                     if (method != null) {
 584                         return new MethodHandler(controller, method, SupportedType.PARAMETERLESS);
 585                     }
 586 
 587                     return null;
 588 
 589                 }
 590 
 591             }
 592             return null;
 593         }
 594 
 595         public void processEventHandlerAttributes() throws LoadException {
 596             if (eventHandlerAttributes.size() &gt; 0 &amp;&amp; !staticLoad) {
 597                 for (Attribute attribute : eventHandlerAttributes) {
 598                     String handlerName = attribute.value;
 599                     if (value instanceof ObservableList &amp;&amp; attribute.name.equals(COLLECTION_HANDLER_NAME)) {
 600                         processObservableListHandler(handlerName);
 601                     } else if (value instanceof ObservableMap &amp;&amp; attribute.name.equals(COLLECTION_HANDLER_NAME)) {
 602                         processObservableMapHandler(handlerName);
 603                     } else if (value instanceof ObservableSet &amp;&amp; attribute.name.equals(COLLECTION_HANDLER_NAME)) {
 604                         processObservableSetHandler(handlerName);
 605                     } else if (attribute.name.endsWith(CHANGE_EVENT_HANDLER_SUFFIX)) {
 606                         processPropertyHandler(attribute.name, handlerName);
 607                     } else {
 608                         EventHandler&lt;? extends Event&gt; eventHandler = null;
 609                         MethodHandler handler = getControllerMethodHandle(handlerName, SupportedType.EVENT);
 610                         if (handler != null) {
 611                             eventHandler = new ControllerMethodEventHandler&lt;&gt;(handler);
 612                         }
 613 
 614                         if (eventHandler == null) {
 615                             eventHandler = getExpressionObjectOfType(handlerName, EventHandler.class);
 616                         }
 617 
 618                         if (eventHandler == null) {
 619                             if (handlerName.length() == 0 || scriptEngine == null) {
 620                                 throw constructLoadException(&quot;Error resolving &quot; + attribute.name + &quot;=&#39;&quot; + attribute.value
 621                                         + &quot;&#39;, either the event handler is not in the Namespace or there is an error in the script.&quot;);
 622                             }
 623                             eventHandler = new ScriptEventHandler(handlerName, scriptEngine, location.getPath()
 624                                         + &quot;-&quot; + attribute.name  + &quot;_attribute_in_element_ending_at_line_&quot;  + getLineNumber());
 625                         }
 626 
 627                         // Add the handler
 628                         getValueAdapter().put(attribute.name, eventHandler);
 629                     }
 630                 }
 631             }
 632         }
 633 
 634         private void processObservableListHandler(String handlerValue) throws LoadException {
 635             ObservableList list = (ObservableList)value;
 636             if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
 637                 MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.LIST_CHANGE_LISTENER);
 638                 if (handler != null) {
 639                     list.addListener(new ObservableListChangeAdapter(handler));
 640                 } else {
 641                     throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
 642                 }
 643             } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
 644                 Object listener = getExpressionObject(handlerValue);
 645                    if (listener instanceof ListChangeListener) {
 646                     list.addListener((ListChangeListener) listener);
 647                 } else if (listener instanceof InvalidationListener) {
 648                     list.addListener((InvalidationListener) listener);
 649                 } else {
 650                     throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
 651                             + &quot;Must be either ListChangeListener or InvalidationListener&quot;);
 652                 }
 653             }
 654         }
 655 
 656         private void processObservableMapHandler(String handlerValue) throws LoadException {
 657             ObservableMap map = (ObservableMap)value;
 658             if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
 659                 MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.MAP_CHANGE_LISTENER);
 660                 if (handler != null) {
 661                     map.addListener(new ObservableMapChangeAdapter(handler));
 662                 } else {
 663                     throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
 664                 }
 665             } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
 666                 Object listener = getExpressionObject(handlerValue);
 667                 if (listener instanceof MapChangeListener) {
 668                     map.addListener((MapChangeListener) listener);
 669                 } else if (listener instanceof InvalidationListener) {
 670                     map.addListener((InvalidationListener) listener);
 671                 } else {
 672                     throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
 673                             + &quot;Must be either MapChangeListener or InvalidationListener&quot;);
 674                 }
 675             }
 676         }
 677 
 678         private void processObservableSetHandler(String handlerValue) throws LoadException {
 679             ObservableSet set = (ObservableSet)value;
 680             if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
 681                 MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.SET_CHANGE_LISTENER);
 682                 if (handler != null) {
 683                     set.addListener(new ObservableSetChangeAdapter(handler));
 684                 } else {
 685                     throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
 686                 }
 687             } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
 688                 Object listener = getExpressionObject(handlerValue);
 689                 if (listener instanceof SetChangeListener) {
 690                     set.addListener((SetChangeListener) listener);
 691                 } else if (listener instanceof InvalidationListener) {
 692                     set.addListener((InvalidationListener) listener);
 693                 } else {
 694                     throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
 695                             + &quot;Must be either SetChangeListener or InvalidationListener&quot;);
 696                 }
 697             }
 698         }
 699 
 700         private void processPropertyHandler(String attributeName, String handlerValue) throws LoadException {
 701             int i = EVENT_HANDLER_PREFIX.length();
 702             int j = attributeName.length() - CHANGE_EVENT_HANDLER_SUFFIX.length();
 703 
 704             if (i != j) {
 705                 String key = Character.toLowerCase(attributeName.charAt(i))
 706                         + attributeName.substring(i + 1, j);
 707 
 708                 ObservableValue&lt;Object&gt; propertyModel = getValueAdapter().getPropertyModel(key);
 709                 if (propertyModel == null) {
 710                     throw constructLoadException(value.getClass().getName() + &quot; does not define&quot;
 711                             + &quot; a property model for \&quot;&quot; + key + &quot;\&quot;.&quot;);
 712                 }
 713 
 714                 if (handlerValue.startsWith(CONTROLLER_METHOD_PREFIX)) {
 715                     final MethodHandler handler = getControllerMethodHandle(handlerValue, SupportedType.PROPERTY_CHANGE_LISTENER, SupportedType.EVENT);
 716                     if (handler != null) {
 717                         if (handler.type == SupportedType.EVENT) {
 718                             // Note: this part is solely for purpose of 2.2 backward compatibility where an Event object
 719                             // has been used instead of usual property change parameters
 720                             propertyModel.addListener(new ChangeListener&lt;Object&gt;() {
 721                                 @Override
 722                                 public void changed(ObservableValue&lt;?&gt; observable, Object oldValue, Object newValue) {
 723                                     handler.invoke(new Event(value, null, Event.ANY));
 724                                 }
 725                             });
 726                         } else {
 727                             propertyModel.addListener(new PropertyChangeAdapter(handler));
 728                         }
 729                     } else {
 730                     throw constructLoadException(&quot;Controller method \&quot;&quot; + handlerValue + &quot;\&quot; not found.&quot;);
 731                     }
 732                 } else if (handlerValue.startsWith(EXPRESSION_PREFIX)) {
 733                     Object listener = getExpressionObject(handlerValue);
 734                     if (listener instanceof ChangeListener) {
 735                         propertyModel.addListener((ChangeListener) listener);
 736                     } else if (listener instanceof InvalidationListener) {
 737                         propertyModel.addListener((InvalidationListener) listener);
 738                     } else {
 739                         throw constructLoadException(&quot;Error resolving \&quot;&quot; + handlerValue + &quot;\&quot; expression.&quot;
 740                                 + &quot;Must be either ChangeListener or InvalidationListener&quot;);
 741                     }
 742                 }
 743 
 744             }
 745         }
 746     }
 747 
 748     // Element representing a value
 749     private abstract class ValueElement extends Element {
 750         public String fx_id = null;
 751 
 752         @Override
 753         public void processStartElement() throws IOException {
 754             super.processStartElement();
 755 
 756             updateValue(constructValue());
 757 
 758             if (value instanceof Builder&lt;?&gt;) {
 759                 processInstancePropertyAttributes();
 760             } else {
 761                 processValue();
 762             }
 763         }
 764 
 765         @Override
 766         @SuppressWarnings(&quot;unchecked&quot;)
 767         public void processEndElement() throws IOException {
 768             super.processEndElement();
 769 
 770             // Build the value, if necessary
 771             if (value instanceof Builder&lt;?&gt;) {
 772                 Builder&lt;Object&gt; builder = (Builder&lt;Object&gt;)value;
 773                 updateValue(builder.build());
 774 
 775                 processValue();
 776             } else {
 777                 processInstancePropertyAttributes();
 778             }
 779 
 780             processEventHandlerAttributes();
 781 
 782             // Process static property attributes
 783             if (staticPropertyAttributes.size() &gt; 0) {
 784                 for (Attribute attribute : staticPropertyAttributes) {
 785                     processPropertyAttribute(attribute);
 786                 }
 787             }
 788 
 789             // Process static property elements
 790             if (staticPropertyElements.size() &gt; 0) {
 791                 for (PropertyElement element : staticPropertyElements) {
 792                     BeanAdapter.put(value, element.sourceType, element.name, element.value);
 793                 }
 794             }
 795 
 796             if (parent != null) {
 797                 if (parent.isCollection()) {
 798                     parent.add(value);
 799                 } else {
 800                     parent.set(value);
 801                 }
 802             }
 803         }
 804 
 805         private Object getListValue(Element parent, String listPropertyName, Object value) {
 806             // If possible, coerce the value to the list item type
 807             if (parent.isTyped()) {
 808                 Type listType = parent.getValueAdapter().getGenericType(listPropertyName);
 809 
 810                 if (listType != null) {
 811                     Type itemType = BeanAdapter.getGenericListItemType(listType);
 812 
 813                     if (itemType instanceof ParameterizedType) {
 814                         itemType = ((ParameterizedType)itemType).getRawType();
 815                     }
 816 
 817                     value = BeanAdapter.coerce(value, (Class&lt;?&gt;)itemType);
 818                 }
 819             }
 820 
 821             return value;
 822         }
 823 
 824         private void processValue() throws LoadException {
 825             // If this is the root element, update the value
 826             if (parent == null) {
 827                 root = value;
 828 
 829                 // checking version of fx namespace - throw exception if not supported
 830                 String fxNSURI = xmlStreamReader.getNamespaceContext().getNamespaceURI(&quot;fx&quot;);
 831                 if (fxNSURI != null) {
 832                     String fxVersion = fxNSURI.substring(fxNSURI.lastIndexOf(&quot;/&quot;) + 1);
 833                     if (compareJFXVersions(FX_NAMESPACE_VERSION, fxVersion) &lt; 0) {
 834                         throw constructLoadException(&quot;Loading FXML document of version &quot; +
 835                                 fxVersion + &quot; by JavaFX runtime supporting version &quot; + FX_NAMESPACE_VERSION);
 836                     }
 837                 }
 838 
 839                 // checking the version JavaFX API - print warning if not supported
 840                 String defaultNSURI = xmlStreamReader.getNamespaceContext().getNamespaceURI(&quot;&quot;);
 841                 if (defaultNSURI != null) {
 842                     String nsVersion = defaultNSURI.substring(defaultNSURI.lastIndexOf(&quot;/&quot;) + 1);
 843                     if (compareJFXVersions(JAVAFX_VERSION, nsVersion) &lt; 0) {
 844                         Logging.getJavaFXLogger().warning(&quot;Loading FXML document with JavaFX API of version &quot; +
 845                                 nsVersion + &quot; by JavaFX runtime of version &quot; + JAVAFX_VERSION);
 846                     }
 847                 }
 848             }
 849 
 850             // Add the value to the namespace
 851             if (fx_id != null) {
 852                 namespace.put(fx_id, value);
 853 
 854                 // If the value defines an ID property, set it
 855                 IDProperty idProperty = value.getClass().getAnnotation(IDProperty.class);
 856 
 857                 if (idProperty != null) {
 858                     Map&lt;String, Object&gt; properties = getProperties();
 859                     // set fx:id property value to Node.id only if Node.id was not
 860                     // already set when processing start element attributes
 861                     if (properties.get(idProperty.value()) == null) {
 862                         properties.put(idProperty.value(), fx_id);
 863                     }
 864                 }
 865 
 866                 // Set the controller field value
 867                 injectFields(fx_id, value);
 868             }
 869         }
 870 
 871         @Override
 872         @SuppressWarnings(&quot;unchecked&quot;)
 873         public void processCharacters() throws LoadException {
 874             Class&lt;?&gt; type = value.getClass();
 875             DefaultProperty defaultProperty = type.getAnnotation(DefaultProperty.class);
 876 
 877             // If the default property is a read-only list, add the value to it;
 878             // otherwise, set the value as the default property
 879             if (defaultProperty != null) {
 880                 String text = xmlStreamReader.getText();
 881                 text = extraneousWhitespacePattern.matcher(text).replaceAll(&quot; &quot;);
 882 
 883                 String defaultPropertyName = defaultProperty.value();
 884                 BeanAdapter valueAdapter = getValueAdapter();
 885 
 886                 if (valueAdapter.isReadOnly(defaultPropertyName)
 887                     &amp;&amp; List.class.isAssignableFrom(valueAdapter.getType(defaultPropertyName))) {
 888                     List&lt;Object&gt; list = (List&lt;Object&gt;)valueAdapter.get(defaultPropertyName);
 889                     list.add(getListValue(this, defaultPropertyName, text));
 890                 } else {
 891                     valueAdapter.put(defaultPropertyName, text.trim());
 892                 }
 893             } else {
 894                 throw constructLoadException(type.getName() + &quot; does not have a default property.&quot;);
 895             }
 896         }
 897 
 898         @Override
 899         public void processAttribute(String prefix, String localName, String value)
 900             throws IOException{
 901             if (prefix != null
 902                 &amp;&amp; prefix.equals(FX_NAMESPACE_PREFIX)) {
 903                 if (localName.equals(FX_ID_ATTRIBUTE)) {
 904                     // Verify that ID is a valid identifier
 905                     if (value.equals(NULL_KEYWORD)) {
 906                         throw constructLoadException(&quot;Invalid identifier.&quot;);
 907                     }
 908 
 909                     for (int i = 0, n = value.length(); i &lt; n; i++) {
 910                         if (!Character.isJavaIdentifierPart(value.charAt(i))) {
 911                             throw constructLoadException(&quot;Invalid identifier.&quot;);
 912                         }
 913                     }
 914 
 915                     fx_id = value;
 916 
 917                 } else if (localName.equals(FX_CONTROLLER_ATTRIBUTE)) {
 918                     if (current.parent != null) {
 919                         throw constructLoadException(FX_NAMESPACE_PREFIX + &quot;:&quot; + FX_CONTROLLER_ATTRIBUTE
 920                             + &quot; can only be applied to root element.&quot;);
 921                     }
 922 
 923                     if (controller != null) {
 924                         throw constructLoadException(&quot;Controller value already specified.&quot;);
 925                     }
 926 
 927                     if (!staticLoad) {
 928                         Class&lt;?&gt; type;
 929                         try {
 930                             type = getClassLoader().loadClass(value);
 931                         } catch (ClassNotFoundException exception) {
 932                             throw constructLoadException(exception);
 933                         }
 934 
 935                         try {
 936                             if (controllerFactory == null) {
 937                                 ReflectUtil.checkPackageAccess(type);
 938                                 setController(type.newInstance());
 939                             } else {
 940                                 setController(controllerFactory.call(type));
 941                             }
 942                         } catch (InstantiationException exception) {
 943                             throw constructLoadException(exception);
 944                         } catch (IllegalAccessException exception) {
 945                             throw constructLoadException(exception);
 946                         }
 947                     }
 948                 } else {
 949                     throw constructLoadException(&quot;Invalid attribute.&quot;);
 950                 }
 951             } else {
 952                 super.processAttribute(prefix, localName, value);
 953             }
 954         }
 955 
 956         public abstract Object constructValue() throws IOException;
 957     }
 958 
 959     // Element representing a class instance
 960     private class InstanceDeclarationElement extends ValueElement {
 961         public Class&lt;?&gt; type;
 962 
 963         public String constant = null;
 964         public String factory = null;
 965 
 966         public InstanceDeclarationElement(Class&lt;?&gt; type) throws LoadException {
 967             this.type = type;
 968         }
 969 
 970         @Override
 971         public void processAttribute(String prefix, String localName, String value)
 972             throws IOException {
 973             if (prefix != null
 974                 &amp;&amp; prefix.equals(FX_NAMESPACE_PREFIX)) {
 975                 if (localName.equals(FX_VALUE_ATTRIBUTE)) {
 976                     this.value = value;
 977                 } else if (localName.equals(FX_CONSTANT_ATTRIBUTE)) {
 978                     constant = value;
 979                 } else if (localName.equals(FX_FACTORY_ATTRIBUTE)) {
 980                     factory = value;
 981                 } else {
 982                     super.processAttribute(prefix, localName, value);
 983                 }
 984             } else {
 985                 super.processAttribute(prefix, localName, value);
 986             }
 987         }
 988 
 989         @Override
 990         public Object constructValue() throws IOException {
 991             Object value;
 992             if (this.value != null) {
 993                 value = BeanAdapter.coerce(this.value, type);
 994             } else if (constant != null) {
 995                 value = BeanAdapter.getConstantValue(type, constant);
 996             } else if (factory != null) {
 997                 Method factoryMethod;
 998                 try {
 999                     factoryMethod = MethodUtil.getMethod(type, factory, new Class[] {});
1000                 } catch (NoSuchMethodException exception) {
1001                     throw constructLoadException(exception);
1002                 }
1003 
1004                 try {
1005                     value = MethodHelper.invoke(factoryMethod, null, new Object [] {});
1006                 } catch (IllegalAccessException exception) {
1007                     throw constructLoadException(exception);
1008                 } catch (InvocationTargetException exception) {
1009                     throw constructLoadException(exception);
1010                 }
1011             } else {
1012                 value = (builderFactory == null) ? null : builderFactory.getBuilder(type);
1013 
1014                 if (value == null) {
1015                     value = DEFAULT_BUILDER_FACTORY.getBuilder(type);
1016                 }
1017 
1018                 if (value == null) {
1019                     try {
1020                         ReflectUtil.checkPackageAccess(type);
1021                         value = type.newInstance();
1022                     } catch (InstantiationException exception) {
1023                         throw constructLoadException(exception);
1024                     } catch (IllegalAccessException exception) {
1025                         throw constructLoadException(exception);
1026                     }
1027                 }
1028             }
1029 
1030             return value;
1031         }
1032     }
1033 
1034     // Element representing an unknown type
1035     private class UnknownTypeElement extends ValueElement {
1036         // Map type representing an unknown value
1037         @DefaultProperty(&quot;items&quot;)
1038         public class UnknownValueMap extends AbstractMap&lt;String, Object&gt; {
1039             private ArrayList&lt;?&gt; items = new ArrayList&lt;Object&gt;();
1040             private HashMap&lt;String, Object&gt; values = new HashMap&lt;String, Object&gt;();
1041 
1042             @Override
1043             public Object get(Object key) {
1044                 if (key == null) {
1045                     throw new NullPointerException();
1046                 }
1047 
1048                 return (key.equals(getClass().getAnnotation(DefaultProperty.class).value())) ?
1049                     items : values.get(key);
1050             }
1051 
1052             @Override
1053             public Object put(String key, Object value) {
1054                 if (key == null) {
1055                     throw new NullPointerException();
1056                 }
1057 
1058                 if (key.equals(getClass().getAnnotation(DefaultProperty.class).value())) {
1059                     throw new IllegalArgumentException();
1060                 }
1061 
1062                 return values.put(key, value);
1063             }
1064 
1065             @Override
1066             public Set&lt;Entry&lt;String, Object&gt;&gt; entrySet() {
1067                 return Collections.emptySet();
1068             }
1069         }
1070 
1071         @Override
1072         public void processEndElement() throws IOException {
1073             // No-op
1074         }
1075 
1076         @Override
1077         public Object constructValue() throws LoadException {
1078             return new UnknownValueMap();
1079         }
1080     }
1081 
1082     // Element representing an include
1083     private class IncludeElement extends ValueElement {
1084         public String source = null;
1085         public ResourceBundle resources = FXMLLoader.this.resources;
1086         public Charset charset = FXMLLoader.this.charset;
1087 
1088         @Override
1089         public void processAttribute(String prefix, String localName, String value)
1090             throws IOException {
1091             if (prefix == null) {
1092                 if (localName.equals(INCLUDE_SOURCE_ATTRIBUTE)) {
1093                     if (loadListener != null) {
1094                         loadListener.readInternalAttribute(localName, value);
1095                     }
1096 
1097                     source = value;
1098                 } else if (localName.equals(INCLUDE_RESOURCES_ATTRIBUTE)) {
1099                     if (loadListener != null) {
1100                         loadListener.readInternalAttribute(localName, value);
1101                     }
1102 
1103                     resources = ResourceBundle.getBundle(value, Locale.getDefault(),
1104                             FXMLLoader.this.resources.getClass().getClassLoader());
1105                 } else if (localName.equals(INCLUDE_CHARSET_ATTRIBUTE)) {
1106                     if (loadListener != null) {
1107                         loadListener.readInternalAttribute(localName, value);
1108                     }
1109 
1110                     charset = Charset.forName(value);
1111                 } else {
1112                     super.processAttribute(prefix, localName, value);
1113                 }
1114             } else {
1115                 super.processAttribute(prefix, localName, value);
1116             }
1117         }
1118 
1119         @Override
1120         public Object constructValue() throws IOException {
1121             if (source == null) {
1122                 throw constructLoadException(INCLUDE_SOURCE_ATTRIBUTE + &quot; is required.&quot;);
1123             }
1124 
1125             URL location;
1126             final ClassLoader cl = getClassLoader();
1127             if (source.charAt(0) == &#39;/&#39;) {
1128             // FIXME: JIGSAW -- use Class.getResourceAsStream if resource is in a module
1129                 location = cl.getResource(source.substring(1));
1130                 if (location == null) {
1131                     throw constructLoadException(&quot;Cannot resolve path: &quot; + source);
1132                 }
1133             } else {
1134                 if (FXMLLoader.this.location == null) {
1135                     throw constructLoadException(&quot;Base location is undefined.&quot;);
1136                 }
1137 
1138                 location = new URL(FXMLLoader.this.location, source);
1139             }
1140 
1141             FXMLLoader fxmlLoader = new FXMLLoader(location, resources,
1142                 builderFactory, controllerFactory, charset,
1143                 loaders);
1144             fxmlLoader.parentLoader = FXMLLoader.this;
1145 
1146             if (isCyclic(FXMLLoader.this, fxmlLoader)) {
1147                 throw new IOException(
1148                         String.format(
1149                         &quot;Including \&quot;%s\&quot; in \&quot;%s\&quot; created cyclic reference.&quot;,
1150                         fxmlLoader.location.toExternalForm(),
1151                         FXMLLoader.this.location.toExternalForm()));
1152             }
1153             fxmlLoader.setClassLoader(cl);
1154             fxmlLoader.setStaticLoad(staticLoad);
1155 
1156             Object value = fxmlLoader.loadImpl(callerClass);
1157 
1158             if (fx_id != null) {
1159                 String id = this.fx_id + CONTROLLER_SUFFIX;
1160                 Object controller = fxmlLoader.getController();
1161 
1162                 namespace.put(id, controller);
1163                 injectFields(id, controller);
1164             }
1165 
1166             return value;
1167         }
1168     }
1169 
1170     private void injectFields(String fieldName, Object value) throws LoadException {
1171         if (controller != null &amp;&amp; fieldName != null) {
1172             List&lt;Field&gt; fields = controllerAccessor.getControllerFields().get(fieldName);
1173             if (fields != null) {
1174                 try {
1175                     for (Field f : fields) {
1176                         f.set(controller, value);
1177                     }
1178                 } catch (IllegalAccessException exception) {
1179                     throw constructLoadException(exception);
1180                 }
1181             }
1182         }
1183     }
1184 
1185     // Element representing a reference
1186     private class ReferenceElement extends ValueElement {
1187         public String source = null;
1188 
1189         @Override
1190         public void processAttribute(String prefix, String localName, String value)
1191             throws IOException {
1192             if (prefix == null) {
1193                 if (localName.equals(REFERENCE_SOURCE_ATTRIBUTE)) {
1194                     if (loadListener != null) {
1195                         loadListener.readInternalAttribute(localName, value);
1196                     }
1197 
1198                     source = value;
1199                 } else {
1200                     super.processAttribute(prefix, localName, value);
1201                 }
1202             } else {
1203                 super.processAttribute(prefix, localName, value);
1204             }
1205         }
1206 
1207         @Override
1208         public Object constructValue() throws LoadException {
1209             if (source == null) {
1210                 throw constructLoadException(REFERENCE_SOURCE_ATTRIBUTE + &quot; is required.&quot;);
1211             }
1212 
1213             KeyPath path = KeyPath.parse(source);
1214             if (!Expression.isDefined(namespace, path)) {
1215                 throw constructLoadException(&quot;Value \&quot;&quot; + source + &quot;\&quot; does not exist.&quot;);
1216             }
1217 
1218             return Expression.get(namespace, path);
1219         }
1220     }
1221 
1222     // Element representing a copy
1223     private class CopyElement extends ValueElement {
1224         public String source = null;
1225 
1226         @Override
1227         public void processAttribute(String prefix, String localName, String value)
1228             throws IOException {
1229             if (prefix == null) {
1230                 if (localName.equals(COPY_SOURCE_ATTRIBUTE)) {
1231                     if (loadListener != null) {
1232                         loadListener.readInternalAttribute(localName, value);
1233                     }
1234 
1235                     source = value;
1236                 } else {
1237                     super.processAttribute(prefix, localName, value);
1238                 }
1239             } else {
1240                 super.processAttribute(prefix, localName, value);
1241             }
1242         }
1243 
1244         @Override
1245         public Object constructValue() throws LoadException {
1246             if (source == null) {
1247                 throw constructLoadException(COPY_SOURCE_ATTRIBUTE + &quot; is required.&quot;);
1248             }
1249 
1250             KeyPath path = KeyPath.parse(source);
1251             if (!Expression.isDefined(namespace, path)) {
1252                 throw constructLoadException(&quot;Value \&quot;&quot; + source + &quot;\&quot; does not exist.&quot;);
1253             }
1254 
1255             Object sourceValue = Expression.get(namespace, path);
1256             Class&lt;?&gt; sourceValueType = sourceValue.getClass();
1257 
1258             Constructor&lt;?&gt; constructor = null;
1259             try {
1260                 constructor = ConstructorUtil.getConstructor(sourceValueType, new Class[] { sourceValueType });
1261             } catch (NoSuchMethodException exception) {
1262                 // No-op
1263             }
1264 
1265             Object value;
1266             if (constructor != null) {
1267                 try {
1268                     ReflectUtil.checkPackageAccess(sourceValueType);
1269                     value = constructor.newInstance(sourceValue);
1270                 } catch (InstantiationException exception) {
1271                     throw constructLoadException(exception);
1272                 } catch (IllegalAccessException exception) {
1273                     throw constructLoadException(exception);
1274                 } catch (InvocationTargetException exception) {
1275                     throw constructLoadException(exception);
1276                 }
1277             } else {
1278                 throw constructLoadException(&quot;Can&#39;t copy value &quot; + sourceValue + &quot;.&quot;);
1279             }
1280 
1281             return value;
1282         }
1283     }
1284 
1285     // Element representing a predefined root value
1286     private class RootElement extends ValueElement {
1287         public String type = null;
1288 
1289         @Override
1290         public void processAttribute(String prefix, String localName, String value)
1291             throws IOException {
1292             if (prefix == null) {
1293                 if (localName.equals(ROOT_TYPE_ATTRIBUTE)) {
1294                     if (loadListener != null) {
1295                         loadListener.readInternalAttribute(localName, value);
1296                     }
1297 
1298                     type = value;
1299                 } else {
1300                     super.processAttribute(prefix, localName, value);
1301                 }
1302             } else {
1303                 super.processAttribute(prefix, localName, value);
1304             }
1305         }
1306 
1307         @Override
1308         public Object constructValue() throws LoadException {
1309             if (type == null) {
1310                 throw constructLoadException(ROOT_TYPE_ATTRIBUTE + &quot; is required.&quot;);
1311             }
1312 
1313             Class&lt;?&gt; type = getType(this.type);
1314 
1315             if (type == null) {
1316                 throw constructLoadException(this.type + &quot; is not a valid type.&quot;);
1317             }
1318 
1319             Object value;
1320             if (root == null) {
1321                 if (staticLoad) {
1322                     value = (builderFactory == null) ? null : builderFactory.getBuilder(type);
1323 
1324                     if (value == null) {
1325                         value = DEFAULT_BUILDER_FACTORY.getBuilder(type);
1326                     }
1327 
1328                     if (value == null) {
1329                         try {
1330                             ReflectUtil.checkPackageAccess(type);
1331                             value = type.newInstance();
1332                         } catch (InstantiationException exception) {
1333                             throw constructLoadException(exception);
1334                         } catch (IllegalAccessException exception) {
1335                             throw constructLoadException(exception);
1336                         }
1337                     }
1338                     root = value;
1339                 } else {
1340                     throw constructLoadException(&quot;Root hasn&#39;t been set. Use method setRoot() before load.&quot;);
1341                 }
1342             } else {
1343                 if (!type.isAssignableFrom(root.getClass())) {
1344                     throw constructLoadException(&quot;Root is not an instance of &quot;
1345                         + type.getName() + &quot;.&quot;);
1346                 }
1347 
1348                 value = root;
1349             }
1350 
1351             return value;
1352         }
1353     }
1354 
1355     // Element representing a property
1356     private class PropertyElement extends Element {
1357         public final String name;
1358         public final Class&lt;?&gt; sourceType;
1359         public final boolean readOnly;
1360 
1361         public PropertyElement(String name, Class&lt;?&gt; sourceType) throws LoadException {
1362             if (parent == null) {
1363                 throw constructLoadException(&quot;Invalid root element.&quot;);
1364             }
1365 
1366             if (parent.value == null) {
1367                 throw constructLoadException(&quot;Parent element does not support property elements.&quot;);
1368             }
1369 
1370             this.name = name;
1371             this.sourceType = sourceType;
1372 
1373             if (sourceType == null) {
1374                 // The element represents an instance property
1375                 if (name.startsWith(EVENT_HANDLER_PREFIX)) {
1376                     throw constructLoadException(&quot;\&quot;&quot; + name + &quot;\&quot; is not a valid element name.&quot;);
1377                 }
1378 
1379                 Map&lt;String, Object&gt; parentProperties = parent.getProperties();
1380 
1381                 if (parent.isTyped()) {
1382                     readOnly = parent.getValueAdapter().isReadOnly(name);
1383                 } else {
1384                 // If the map already defines a value for the property, assume
1385                     // that it is read-only
1386                     readOnly = parentProperties.containsKey(name);
1387                 }
1388 
1389                 if (readOnly) {
1390                     Object value = parentProperties.get(name);
1391                     if (value == null) {
1392                         throw constructLoadException(&quot;Invalid property.&quot;);
1393                     }
1394 
1395                     updateValue(value);
1396                 }
1397             } else {
1398                 // The element represents a static property
1399                 readOnly = false;
1400             }
1401         }
1402 
1403         @Override
1404         public boolean isCollection() {
1405             return (readOnly) ? super.isCollection() : false;
1406         }
1407 
1408         @Override
1409         public void add(Object element) throws LoadException {
1410             // Coerce the element to the list item type
1411             if (parent.isTyped()) {
1412                 Type listType = parent.getValueAdapter().getGenericType(name);
1413                 element = BeanAdapter.coerce(element, BeanAdapter.getListItemType(listType));
1414             }
1415 
1416             // Add the item to the list
1417             super.add(element);
1418         }
1419 
1420         @Override
1421         public void set(Object value) throws LoadException {
1422             // Update the value
1423             updateValue(value);
1424 
1425             if (sourceType == null) {
1426                 // Apply value to parent element&#39;s properties
1427                 parent.getProperties().put(name, value);
1428             } else {
1429                 if (parent.value instanceof Builder) {
1430                     // Defer evaluation of the property
1431                     parent.staticPropertyElements.add(this);
1432                 } else {
1433                     // Apply the static property value
1434                     BeanAdapter.put(parent.value, sourceType, name, value);
1435                 }
1436             }
1437         }
1438 
1439         @Override
1440         public void processAttribute(String prefix, String localName, String value)
1441             throws IOException {
1442             if (!readOnly) {
1443                 throw constructLoadException(&quot;Attributes are not supported for writable property elements.&quot;);
1444             }
1445 
1446             super.processAttribute(prefix, localName, value);
1447         }
1448 
1449         @Override
1450         public void processEndElement() throws IOException {
1451             super.processEndElement();
1452 
1453             if (readOnly) {
1454                 processInstancePropertyAttributes();
1455                 processEventHandlerAttributes();
1456             }
1457         }
1458 
1459         @Override
1460         public void processCharacters() throws IOException {
1461             String text = xmlStreamReader.getText();
1462             text = extraneousWhitespacePattern.matcher(text).replaceAll(&quot; &quot;).trim();
1463 
1464             if (readOnly) {
1465                 if (isCollection()) {
1466                     add(text);
1467                 } else {
1468                     super.processCharacters();
1469                 }
1470             } else {
1471                 set(text);
1472             }
1473         }
1474     }
1475 
1476     // Element representing an unknown static property
1477     private class UnknownStaticPropertyElement extends Element {
1478         public UnknownStaticPropertyElement() throws LoadException {
1479             if (parent == null) {
1480                 throw constructLoadException(&quot;Invalid root element.&quot;);
1481             }
1482 
1483             if (parent.value == null) {
1484                 throw constructLoadException(&quot;Parent element does not support property elements.&quot;);
1485             }
1486         }
1487 
1488         @Override
1489         public boolean isCollection() {
1490             return false;
1491         }
1492 
1493         @Override
1494         public void set(Object value) {
1495             updateValue(value);
1496         }
1497 
1498         @Override
1499         public void processCharacters() throws IOException {
1500             String text = xmlStreamReader.getText();
1501             text = extraneousWhitespacePattern.matcher(text).replaceAll(&quot; &quot;);
1502 
1503             updateValue(text.trim());
1504         }
1505     }
1506 
1507     // Element representing a script block
1508     private class ScriptElement extends Element {
1509         public String source = null;
1510         public Charset charset = FXMLLoader.this.charset;
1511 
1512         @Override
1513         public boolean isCollection() {
1514             return false;
1515         }
1516 
1517         @Override
1518         public void processStartElement() throws IOException {
1519             super.processStartElement();
1520 
1521             if (source != null &amp;&amp; !staticLoad) {
1522                 int i = source.lastIndexOf(&quot;.&quot;);
1523                 if (i == -1) {
1524                     throw constructLoadException(&quot;Cannot determine type of script \&quot;&quot;
1525                         + source + &quot;\&quot;.&quot;);
1526                 }
1527 
1528                 String extension = source.substring(i + 1);
1529                 ScriptEngine engine;
1530                 final ClassLoader cl = getClassLoader();
1531                 if (scriptEngine != null &amp;&amp; scriptEngine.getFactory().getExtensions().contains(extension)) {
1532                     // If we have a page language and it&#39;s engine supports the extension, use the same engine
1533                     engine = scriptEngine;
1534                 } else {
1535                     ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();
1536                     try {
1537                         Thread.currentThread().setContextClassLoader(cl);
1538                         ScriptEngineManager scriptEngineManager = getScriptEngineManager();
1539                         engine = scriptEngineManager.getEngineByExtension(extension);
1540                     } finally {
1541                         Thread.currentThread().setContextClassLoader(oldLoader);
1542                     }
1543                 }
1544 
1545                 if (engine == null) {
1546                     throw constructLoadException(&quot;Unable to locate scripting engine for&quot;
1547                         + &quot; extension &quot; + extension + &quot;.&quot;);
1548                 }
1549 
1550                 try {
1551                     URL location;
1552                     if (source.charAt(0) == &#39;/&#39;) {
1553                         // FIXME: JIGSAW -- use Class.getResourceAsStream if resource is in a module
1554                         location = cl.getResource(source.substring(1));
1555                     } else {
1556                         if (FXMLLoader.this.location == null) {
1557                             throw constructLoadException(&quot;Base location is undefined.&quot;);
1558                         }
1559 
1560                         location = new URL(FXMLLoader.this.location, source);
1561                     }
1562                     Bindings engineBindings = engine.getBindings(ScriptContext.ENGINE_SCOPE);
1563                     engineBindings.put(engine.FILENAME, location.getPath());
1564 
1565                     InputStreamReader scriptReader = null;
1566                     try {
1567                         scriptReader = new InputStreamReader(location.openStream(), charset);
<a name="2" id="anc2"></a><span class="line-modified">1568                         if (engine instanceof Compilable) {</span>
<span class="line-added">1569                             ((Compilable) engine).compile(scriptReader).eval();</span>
<span class="line-added">1570                         }</span>
<span class="line-added">1571                         else {</span>
<span class="line-added">1572                            engine.eval(scriptReader);</span>
<span class="line-added">1573                         }</span>
1574                     } catch(ScriptException exception) {
1575                         exception.printStackTrace();
1576                     } finally {
1577                         if (scriptReader != null) {
1578                             scriptReader.close();
1579                         }
1580                     }
1581                 } catch (IOException exception) {
1582                     throw constructLoadException(exception);
1583                 }
1584             }
1585         }
1586 
1587         @Override
1588         public void processEndElement() throws IOException {
1589             super.processEndElement();
1590 
1591             if (value != null &amp;&amp; !staticLoad) {
1592                 // Evaluate the script
1593                 try {
1594                     Bindings engineBindings = scriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);
1595                     engineBindings.put(scriptEngine.FILENAME, location.getPath() + &quot;-script_starting_at_line_&quot;
1596                                        + (getLineNumber() - (int) ((String) value).codePoints().filter(c -&gt; c == &#39;\n&#39;).count()));
<a name="3" id="anc3"></a><span class="line-modified">1597 </span>
<span class="line-added">1598                     if (scriptEngine instanceof Compilable) {</span>
<span class="line-added">1599                        ((Compilable) scriptEngine).compile((String)value).eval();</span>
<span class="line-added">1600                     }</span>
<span class="line-added">1601                     else {</span>
<span class="line-added">1602                        scriptEngine.eval((String)value);</span>
<span class="line-added">1603                     }</span>
1604                 } catch (ScriptException exception) {
1605                     System.err.println(exception.getMessage());
1606                 }
1607             }
1608         }
1609 
1610         @Override
1611         public void processCharacters() throws LoadException {
1612             if (source != null) {
1613                 throw constructLoadException(&quot;Script source already specified.&quot;);
1614             }
1615 
1616             if (scriptEngine == null &amp;&amp; !staticLoad) {
1617                 throw constructLoadException(&quot;Page language not specified.&quot;);
1618             }
1619 
1620             updateValue(xmlStreamReader.getText());
1621         }
1622 
1623         @Override
1624         public void processAttribute(String prefix, String localName, String value)
1625             throws IOException {
1626             if (prefix == null
1627                 &amp;&amp; localName.equals(SCRIPT_SOURCE_ATTRIBUTE)) {
1628                 if (loadListener != null) {
1629                     loadListener.readInternalAttribute(localName, value);
1630                 }
1631 
1632                 source = value;
1633             } else if (localName.equals(SCRIPT_CHARSET_ATTRIBUTE)) {
1634                 if (loadListener != null) {
1635                     loadListener.readInternalAttribute(localName, value);
1636                 }
1637 
1638                 charset = Charset.forName(value);
1639             } else {
1640                 throw constructLoadException(prefix == null ? localName : prefix + &quot;:&quot; + localName
1641                     + &quot; is not a valid attribute.&quot;);
1642             }
1643         }
1644     }
1645 
1646     // Element representing a define block
1647     private class DefineElement extends Element {
1648         @Override
1649         public boolean isCollection() {
1650             return true;
1651         }
1652 
1653         @Override
1654         public void add(Object element) {
1655             // No-op
1656         }
1657 
1658         @Override
1659         public void processAttribute(String prefix, String localName, String value)
1660             throws LoadException{
1661             throw constructLoadException(&quot;Element does not support attributes.&quot;);
1662         }
1663     }
1664 
1665     // Class representing an attribute of an element
1666     private static class Attribute {
1667         public final String name;
1668         public final Class&lt;?&gt; sourceType;
1669         public final String value;
1670 
1671         public Attribute(String name, Class&lt;?&gt; sourceType, String value) {
1672             this.name = name;
1673             this.sourceType = sourceType;
1674             this.value = value;
1675         }
1676     }
1677 
1678     // Event handler that delegates to a method defined by the controller object
1679     private static class ControllerMethodEventHandler&lt;T extends Event&gt; implements EventHandler&lt;T&gt; {
1680         private final MethodHandler handler;
1681 
1682         public ControllerMethodEventHandler(MethodHandler handler) {
1683             this.handler = handler;
1684         }
1685 
1686         @Override
1687         public void handle(T event) {
1688             handler.invoke(event);
1689         }
1690     }
1691 
1692     // Event handler implemented in script code
1693     private static class ScriptEventHandler implements EventHandler&lt;Event&gt; {
1694         public final String script;
1695         public final ScriptEngine scriptEngine;
1696         public final String filename;
<a name="4" id="anc4"></a><span class="line-added">1697         public CompiledScript compiledScript;</span>
<span class="line-added">1698         public boolean isCompiled=false;</span>
1699 
1700         public ScriptEventHandler(String script, ScriptEngine scriptEngine, String filename) {
1701             this.script = script;
1702             this.scriptEngine = scriptEngine;
1703             this.filename = filename;
<a name="5" id="anc5"></a><span class="line-added">1704             if (scriptEngine instanceof Compilable) {</span>
<span class="line-added">1705                try {</span>
<span class="line-added">1706                   // supply the filename to the scriptEngine engine scope Bindings in case it is needed for compilation</span>
<span class="line-added">1707                   scriptEngine.getBindings(ScriptContext.ENGINE_SCOPE).put(scriptEngine.FILENAME, filename);</span>
<span class="line-added">1708                   this.compiledScript = ((Compilable) scriptEngine).compile(script);</span>
<span class="line-added">1709                   this.isCompiled = true;</span>
<span class="line-added">1710                } catch (ScriptException exception){</span>
<span class="line-added">1711                    throw new RuntimeException(exception);</span>
<span class="line-added">1712                }</span>
<span class="line-added">1713             }</span>
1714         }
1715 
1716         @Override
1717         public void handle(Event event) {
1718             // Don&#39;t pollute the page namespace with values defined in the script
1719             Bindings engineBindings = scriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);
1720             Bindings localBindings = scriptEngine.createBindings();
1721             localBindings.putAll(engineBindings);
1722             localBindings.put(EVENT_KEY, event);
1723             localBindings.put(scriptEngine.ARGV, new Object[]{event});
1724             localBindings.put(scriptEngine.FILENAME, filename);
1725             // Execute the script
1726             try {
<a name="6" id="anc6"></a><span class="line-modified">1727                 if (isCompiled) {</span>
<span class="line-added">1728                    compiledScript.eval(localBindings);</span>
<span class="line-added">1729                 }</span>
<span class="line-added">1730                 else {</span>
<span class="line-added">1731                    scriptEngine.eval(script, localBindings);</span>
<span class="line-added">1732                 }</span>
1733             } catch (ScriptException exception){
1734                 throw new RuntimeException(exception);
1735             }
1736         }
1737     }
1738 
1739     // Observable list change listener
1740     private static class ObservableListChangeAdapter implements ListChangeListener {
1741         private final MethodHandler handler;
1742 
1743         public ObservableListChangeAdapter(MethodHandler handler) {
1744             this.handler = handler;
1745         }
1746 
1747         @Override
1748         @SuppressWarnings(&quot;unchecked&quot;)
1749         public void onChanged(Change change) {
1750             if (handler != null) {
1751                 handler.invoke(change);
1752             }
1753         }
1754     }
1755 
1756     // Observable map change listener
1757     private static class ObservableMapChangeAdapter implements MapChangeListener {
1758         public final MethodHandler handler;
1759 
1760         public ObservableMapChangeAdapter(MethodHandler handler) {
1761             this.handler = handler;
1762         }
1763 
1764         @Override
1765         public void onChanged(Change change) {
1766             if (handler != null) {
1767                 handler.invoke(change);
1768             }
1769         }
1770     }
1771 
1772     // Observable set change listener
1773     private static class ObservableSetChangeAdapter implements SetChangeListener {
1774         public final MethodHandler handler;
1775 
1776         public ObservableSetChangeAdapter(MethodHandler handler) {
1777             this.handler = handler;
1778         }
1779 
1780         @Override
1781         public void onChanged(Change change) {
1782             if (handler != null) {
1783                 handler.invoke(change);
1784             }
1785         }
1786     }
1787 
1788     // Property model change listener
1789     private static class PropertyChangeAdapter implements ChangeListener&lt;Object&gt; {
1790         public final MethodHandler handler;
1791 
1792         public PropertyChangeAdapter(MethodHandler handler) {
1793             this.handler = handler;
1794         }
1795 
1796         @Override
1797         public void changed(ObservableValue&lt;? extends Object&gt; observable, Object oldValue, Object newValue) {
1798             handler.invoke(observable, oldValue, newValue);
1799         }
1800     }
1801 
1802     private static class MethodHandler {
1803         private final Object controller;
1804         private final Method method;
1805         private final SupportedType type;
1806 
1807         private MethodHandler(Object controller, Method method, SupportedType type) {
1808             this.method = method;
1809             this.controller = controller;
1810             this.type = type;
1811         }
1812 
1813         public void invoke(Object... params) {
1814             try {
1815                 if (type != SupportedType.PARAMETERLESS) {
1816                     MethodHelper.invoke(method, controller, params);
1817                 } else {
1818                     MethodHelper.invoke(method, controller, new Object[] {});
1819                 }
1820             } catch (InvocationTargetException exception) {
1821                 throw new RuntimeException(exception);
1822             } catch (IllegalAccessException exception) {
1823                 throw new RuntimeException(exception);
1824             }
1825         }
1826     }
1827 
1828     private URL location;
1829     private ResourceBundle resources;
1830 
1831     private ObservableMap&lt;String, Object&gt; namespace = FXCollections.observableHashMap();
1832 
1833     private Object root = null;
1834     private Object controller = null;
1835 
1836     private BuilderFactory builderFactory;
1837     private Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory;
1838     private Charset charset;
1839 
1840     private final LinkedList&lt;FXMLLoader&gt; loaders;
1841 
1842     private ClassLoader classLoader = null;
1843     private boolean staticLoad = false;
1844     private LoadListener loadListener = null;
1845 
1846     private FXMLLoader parentLoader;
1847 
1848     private XMLStreamReader xmlStreamReader = null;
1849     private Element current = null;
1850 
1851     private ScriptEngine scriptEngine = null;
1852 
1853     private List&lt;String&gt; packages = new LinkedList&lt;String&gt;();
1854     private Map&lt;String, Class&lt;?&gt;&gt; classes = new HashMap&lt;String, Class&lt;?&gt;&gt;();
1855 
1856     private ScriptEngineManager scriptEngineManager = null;
1857 
1858     private static ClassLoader defaultClassLoader = null;
1859 
1860     private static final Pattern extraneousWhitespacePattern = Pattern.compile(&quot;\\s+&quot;);
1861 
1862     private static BuilderFactory DEFAULT_BUILDER_FACTORY = new JavaFXBuilderFactory();
1863 
1864     /**
1865      * The character set used when character set is not explicitly specified.
1866      */
1867     public static final String DEFAULT_CHARSET_NAME = &quot;UTF-8&quot;;
1868 
1869     /**
1870      * The tag name of language processing instruction.
1871      */
1872     public static final String LANGUAGE_PROCESSING_INSTRUCTION = &quot;language&quot;;
1873     /**
1874      * The tag name of import processing instruction.
1875      */
1876     public static final String IMPORT_PROCESSING_INSTRUCTION = &quot;import&quot;;
1877 
1878     /**
1879      * Prefix of &#39;fx&#39; namespace.
1880      */
1881     public static final String FX_NAMESPACE_PREFIX = &quot;fx&quot;;
1882     /**
1883      * The name of fx:controller attribute of a root.
1884      */
1885     public static final String FX_CONTROLLER_ATTRIBUTE = &quot;controller&quot;;
1886     /**
1887      * The name of fx:id attribute.
1888      */
1889     public static final String FX_ID_ATTRIBUTE = &quot;id&quot;;
1890     /**
1891      * The name of fx:value attribute.
1892      */
1893     public static final String FX_VALUE_ATTRIBUTE = &quot;value&quot;;
1894     /**
1895      * The tag name of &#39;fx:constant&#39;.
1896      * @since JavaFX 2.2
1897      */
1898     public static final String FX_CONSTANT_ATTRIBUTE = &quot;constant&quot;;
1899     /**
1900      * The name of &#39;fx:factory&#39; attribute.
1901      */
1902     public static final String FX_FACTORY_ATTRIBUTE = &quot;factory&quot;;
1903 
1904     /**
1905      * The tag name of {@literal &lt;fx:include&gt;}.
1906      */
1907     public static final String INCLUDE_TAG = &quot;include&quot;;
1908     /**
1909      * The {@literal &lt;fx:include&gt;} &#39;source&#39; attribute.
1910      */
1911     public static final String INCLUDE_SOURCE_ATTRIBUTE = &quot;source&quot;;
1912     /**
1913      * The {@literal &lt;fx:include&gt;} &#39;resources&#39; attribute.
1914      */
1915     public static final String INCLUDE_RESOURCES_ATTRIBUTE = &quot;resources&quot;;
1916     /**
1917      * The {@literal &lt;fx:include&gt;} &#39;charset&#39; attribute.
1918      */
1919     public static final String INCLUDE_CHARSET_ATTRIBUTE = &quot;charset&quot;;
1920 
1921     /**
1922      * The tag name of {@literal &lt;fx:script&gt;}.
1923      */
1924     public static final String SCRIPT_TAG = &quot;script&quot;;
1925     /**
1926      * The {@literal &lt;fx:script&gt;} &#39;source&#39; attribute.
1927      */
1928     public static final String SCRIPT_SOURCE_ATTRIBUTE = &quot;source&quot;;
1929     /**
1930      * The {@literal &lt;fx:script&gt;} &#39;charset&#39; attribute.
1931      */
1932     public static final String SCRIPT_CHARSET_ATTRIBUTE = &quot;charset&quot;;
1933 
1934     /**
1935      * The tag name of {@literal &lt;fx:define&gt;}.
1936      */
1937     public static final String DEFINE_TAG = &quot;define&quot;;
1938 
1939     /**
1940      * The tag name of {@literal &lt;fx:reference&gt;}.
1941      */
1942     public static final String REFERENCE_TAG = &quot;reference&quot;;
1943     /**
1944      * The {@literal &lt;fx:reference&gt;} &#39;source&#39; attribute.
1945      */
1946     public static final String REFERENCE_SOURCE_ATTRIBUTE = &quot;source&quot;;
1947 
1948     /**
1949      * The tag name of {@literal &lt;fx:root&gt;}.
1950      * @since JavaFX 2.2
1951      */
1952     public static final String ROOT_TAG = &quot;root&quot;;
1953     /**
1954      * The {@literal &lt;fx:root&gt;} &#39;type&#39; attribute.
1955      * @since JavaFX 2.2
1956      */
1957     public static final String ROOT_TYPE_ATTRIBUTE = &quot;type&quot;;
1958 
1959     /**
1960      * The tag name of {@literal &lt;fx:copy&gt;}.
1961      */
1962     public static final String COPY_TAG = &quot;copy&quot;;
1963     /**
1964      * The {@literal &lt;fx:copy&gt;} &#39;source&#39; attribute.
1965      */
1966     public static final String COPY_SOURCE_ATTRIBUTE = &quot;source&quot;;
1967 
1968     /**
1969      * The prefix of event handler attributes.
1970      */
1971     public static final String EVENT_HANDLER_PREFIX = &quot;on&quot;;
1972     /**
1973      * The name of the Event object in event handler scripts.
1974      */
1975     public static final String EVENT_KEY = &quot;event&quot;;
1976     /**
1977      * Suffix for property change/invalidation handlers.
1978      */
1979     public static final String CHANGE_EVENT_HANDLER_SUFFIX = &quot;Change&quot;;
1980     private static final String COLLECTION_HANDLER_NAME = EVENT_HANDLER_PREFIX + CHANGE_EVENT_HANDLER_SUFFIX;
1981 
1982     /**
1983      * Value that represents &#39;null&#39;.
1984      */
1985     public static final String NULL_KEYWORD = &quot;null&quot;;
1986 
1987     /**
1988      * Escape prefix for escaping special characters inside attribute values.
1989      * Serves as an escape for {@link #ESCAPE_PREFIX}, {@link #RELATIVE_PATH_PREFIX},
1990      * {@link #RESOURCE_KEY_PREFIX}, {@link #EXPRESSION_PREFIX},
1991      * {@link #BI_DIRECTIONAL_BINDING_PREFIX}
1992      * @since JavaFX 2.1
1993      */
1994     public static final String ESCAPE_PREFIX = &quot;\\&quot;;
1995     /**
1996      * Prefix for relative location resolution.
1997      */
1998     public static final String RELATIVE_PATH_PREFIX = &quot;@&quot;;
1999     /**
2000      * Prefix for resource resolution.
2001      */
2002     public static final String RESOURCE_KEY_PREFIX = &quot;%&quot;;
2003     /**
2004      * Prefix for (variable) expression resolution.
2005      */
2006     public static final String EXPRESSION_PREFIX = &quot;$&quot;;
2007     /**
2008      * Prefix for binding expression resolution.
2009      */
2010     public static final String BINDING_EXPRESSION_PREFIX = &quot;${&quot;;
2011     /**
2012      * Suffix for binding expression resolution.
2013      */
2014     public static final String BINDING_EXPRESSION_SUFFIX = &quot;}&quot;;
2015 
2016     /**
2017      * Prefix for bidirectional-binding expression resolution.
2018      * @since JavaFX 2.1
2019      */
2020     public static final String BI_DIRECTIONAL_BINDING_PREFIX = &quot;#{&quot;;
2021     /**
2022      * Suffix for bidirectional-binding expression resolution.
2023      * @since JavaFX 2.1
2024      */
2025     public static final String BI_DIRECTIONAL_BINDING_SUFFIX = &quot;}&quot;;
2026 
2027     /**
2028      * Delimiter for arrays as values.
2029      * @since JavaFX 2.1
2030      */
2031     public static final String ARRAY_COMPONENT_DELIMITER = &quot;,&quot;;
2032 
2033     /**
2034      * A key for location URL in namespace map.
2035      * @see #getNamespace()
2036      * @since JavaFX 2.2
2037      */
2038     public static final String LOCATION_KEY = &quot;location&quot;;
2039     /**
2040      * A key for ResourceBundle in namespace map.
2041      * @see #getNamespace()
2042      * @since JavaFX 2.2
2043      */
2044     public static final String RESOURCES_KEY = &quot;resources&quot;;
2045 
2046     /**
2047      * Prefix for controller method resolution.
2048      */
2049     public static final String CONTROLLER_METHOD_PREFIX = &quot;#&quot;;
2050     /**
2051      * A key for controller in namespace map.
2052      * @see #getNamespace()
2053      * @since JavaFX 2.1
2054      */
2055     public static final String CONTROLLER_KEYWORD = &quot;controller&quot;;
2056     /**
2057      * A suffix for controllers of included fxml files.
2058      * The full key is stored in namespace map.
2059      * @see #getNamespace()
2060      * @since JavaFX 2.2
2061      */
2062     public static final String CONTROLLER_SUFFIX = &quot;Controller&quot;;
2063 
2064     /**
2065      * The name of initialize method.
2066      * @since JavaFX 2.2
2067      */
2068     public static final String INITIALIZE_METHOD_NAME = &quot;initialize&quot;;
2069 
2070     /**
2071      * Contains the current javafx version.
2072      * @since JavaFX 8.0
2073      */
2074     public static final String JAVAFX_VERSION;
2075 
2076     /**
2077      * Contains the current fx namepsace version.
2078      * @since JavaFX 8.0
2079      */
2080     public static final String FX_NAMESPACE_VERSION = &quot;1&quot;;
2081 
2082     static {
2083         JAVAFX_VERSION = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {
2084             @Override
2085             public String run() {
2086                 return System.getProperty(&quot;javafx.version&quot;);
2087             }
2088         });
2089 
2090         FXMLLoaderHelper.setFXMLLoaderAccessor(new FXMLLoaderHelper.FXMLLoaderAccessor() {
2091             @Override
2092             public void setStaticLoad(FXMLLoader fxmlLoader, boolean staticLoad) {
2093                 fxmlLoader.setStaticLoad(staticLoad);
2094             }
2095         });
2096     }
2097 
2098     /**
2099      * Creates a new FXMLLoader instance.
2100      */
2101     public FXMLLoader() {
2102         this((URL)null);
2103     }
2104 
2105     /**
2106      * Creates a new FXMLLoader instance.
2107      *
2108      * @param location the location used to resolve relative path attribute values
2109      * @since JavaFX 2.1
2110      */
2111     public FXMLLoader(URL location) {
2112         this(location, null);
2113     }
2114 
2115     /**
2116      * Creates a new FXMLLoader instance.
2117      *
2118      * @param location the location used to resolve relative path attribute values
2119      * @param resources the resources used to resolve resource key attribute values
2120      * @since JavaFX 2.1
2121      */
2122     public FXMLLoader(URL location, ResourceBundle resources) {
2123         this(location, resources, null);
2124     }
2125 
2126     /**
2127      * Creates a new FXMLLoader instance.
2128      *
2129      * @param location the location used to resolve relative path attribute values
2130      * @param resources resources used to resolve resource key attribute values
2131      * @param builderFactory the builder factory used by this loader
2132      * @since JavaFX 2.1
2133      */
2134     public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory) {
2135         this(location, resources, builderFactory, null);
2136     }
2137 
2138     /**
2139      * Creates a new FXMLLoader instance.
2140      *
2141      * @param location the location used to resolve relative path attribute values
2142      * @param resources resources used to resolve resource key attribute values
2143      * @param builderFactory the builder factory used by this loader
2144      * @param controllerFactory the controller factory used by this loader
2145      * @since JavaFX 2.1
2146      */
2147     public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
2148         Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory) {
2149         this(location, resources, builderFactory, controllerFactory, Charset.forName(DEFAULT_CHARSET_NAME));
2150     }
2151 
2152     /**
2153      * Creates a new FXMLLoader instance.
2154      *
2155      * @param charset the character set used by this loader
2156      */
2157     public FXMLLoader(Charset charset) {
2158         this(null, null, null, null, charset);
2159     }
2160 
2161     /**
2162      * Creates a new FXMLLoader instance.
2163      *
2164      * @param location the location used to resolve relative path attribute values
2165      * @param resources resources used to resolve resource key attribute values
2166      * @param builderFactory the builder factory used by this loader
2167      * @param controllerFactory the controller factory used by this loader
2168      * @param charset the character set used by this loader
2169      * @since JavaFX 2.1
2170      */
2171     public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
2172         Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory, Charset charset) {
2173         this(location, resources, builderFactory, controllerFactory, charset,
2174             new LinkedList&lt;FXMLLoader&gt;());
2175     }
2176 
2177     /**
2178      * Creates a new FXMLLoader instance.
2179      *
2180      * @param location the location used to resolve relative path attribute values
2181      * @param resources resources used to resolve resource key attribute values
2182      * @param builderFactory the builder factory used by this loader
2183      * @param controllerFactory the controller factory used by this loader
2184      * @param charset the character set used by this loader
2185      * @param loaders list of loaders
2186      * @since JavaFX 2.1
2187      */
2188     public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,
2189         Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory, Charset charset,
2190         LinkedList&lt;FXMLLoader&gt; loaders) {
2191         setLocation(location);
2192         setResources(resources);
2193         setBuilderFactory(builderFactory);
2194         setControllerFactory(controllerFactory);
2195         setCharset(charset);
2196 
2197         this.loaders = new LinkedList(loaders);
2198     }
2199 
2200     /**
2201      * Returns the location used to resolve relative path attribute values.
2202      * @return the location used to resolve relative path attribute values
2203      */
2204     public URL getLocation() {
2205         return location;
2206     }
2207 
2208     /**
2209      * Sets the location used to resolve relative path attribute values.
2210      *
2211      * @param location the location
2212      */
2213     public void setLocation(URL location) {
2214         this.location = location;
2215     }
2216 
2217     /**
2218      * Returns the resources used to resolve resource key attribute values.
2219      * @return the resources used to resolve resource key attribute values
2220      */
2221     public ResourceBundle getResources() {
2222         return resources;
2223     }
2224 
2225     /**
2226      * Sets the resources used to resolve resource key attribute values.
2227      *
2228      * @param resources the resources
2229      */
2230     public void setResources(ResourceBundle resources) {
2231         this.resources = resources;
2232     }
2233 
2234     /**
2235      * Returns the namespace used by this loader.
2236      * @return the namespace
2237      */
2238     public ObservableMap&lt;String, Object&gt; getNamespace() {
2239         return namespace;
2240     }
2241 
2242     /**
2243      * Returns the root of the object hierarchy.
2244      * @param &lt;T&gt; the type of the root object
2245      * @return the root of the object hierarchy
2246      */
2247     @SuppressWarnings(&quot;unchecked&quot;)
2248     public &lt;T&gt; T getRoot() {
2249         return (T)root;
2250     }
2251 
2252     /**
2253      * Sets the root of the object hierarchy. The value passed to this method
2254      * is used as the value of the {@code &lt;fx:root&gt;} tag. This method
2255      * must be called prior to loading the document when using
2256      * {@code &lt;fx:root&gt;}.
2257      *
2258      * @param root the root of the object hierarchy
2259      *
2260      * @since JavaFX 2.2
2261      */
2262     public void setRoot(Object root) {
2263         this.root = root;
2264     }
2265 
2266     @Override
2267     public boolean equals(Object obj) {
2268         if (obj instanceof FXMLLoader) {
2269             FXMLLoader loader = (FXMLLoader)obj;
2270             if (location == null || loader.location == null) {
2271                 return loader.location == location;
2272             }
2273             return location.toExternalForm().equals(
2274                     loader.location.toExternalForm());
2275         }
2276         return false;
2277     }
2278 
2279     private boolean isCyclic(
2280                             FXMLLoader currentLoader,
2281                             FXMLLoader node) {
2282         if (currentLoader == null) {
2283             return false;
2284         }
2285         if (currentLoader.equals(node)) {
2286             return true;
2287         }
2288         return isCyclic(currentLoader.parentLoader, node);
2289     }
2290 
2291     /**
2292      * Returns the controller associated with the root object.
2293      * @param &lt;T&gt; the type of the controller
2294      * @return the controller associated with the root object
2295      */
2296     @SuppressWarnings(&quot;unchecked&quot;)
2297     public &lt;T&gt; T getController() {
2298         return (T)controller;
2299     }
2300 
2301     /**
2302      * Sets the controller associated with the root object. The value passed to
2303      * this method is used as the value of the {@code fx:controller} attribute.
2304      * This method must be called prior to loading the document when using
2305      * controller event handlers when an {@code fx:controller} attribute is not
2306      * specified in the document.
2307      *
2308      * @param controller the controller to associate with the root object
2309      *
2310      * @since JavaFX 2.2
2311      */
2312     public void setController(Object controller) {
2313         this.controller = controller;
2314 
2315         if (controller == null) {
2316             namespace.remove(CONTROLLER_KEYWORD);
2317         } else {
2318             namespace.put(CONTROLLER_KEYWORD, controller);
2319         }
2320 
2321         controllerAccessor.setController(controller);
2322     }
2323 
2324     /**
2325      * Returns the builder factory used by this loader.
2326      * @return the builder factory
2327      */
2328     public BuilderFactory getBuilderFactory() {
2329         return builderFactory;
2330     }
2331 
2332     /**
2333      * Sets the builder factory used by this loader.
2334      *
2335      * @param builderFactory the builder factory
2336      */
2337     public void setBuilderFactory(BuilderFactory builderFactory) {
2338         this.builderFactory = builderFactory;
2339     }
2340 
2341     /**
2342      * Returns the controller factory used by this loader.
2343      * @return the controller factory
2344      * @since JavaFX 2.1
2345      */
2346     public Callback&lt;Class&lt;?&gt;, Object&gt; getControllerFactory() {
2347         return controllerFactory;
2348     }
2349 
2350     /**
2351      * Sets the controller factory used by this loader.
2352      *
2353      * @param controllerFactory the controller factory
2354      * @since JavaFX 2.1
2355      */
2356     public void setControllerFactory(Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory) {
2357         this.controllerFactory = controllerFactory;
2358     }
2359 
2360     /**
2361      * Returns the character set used by this loader.
2362      * @return the character set
2363      */
2364     public Charset getCharset() {
2365         return charset;
2366     }
2367 
2368     /**
2369      * Sets the character set used by this loader.
2370      *
2371      * @param charset the character set
2372      * @since JavaFX 2.1
2373      */
2374     public void setCharset(Charset charset) {
2375         if (charset == null) {
2376             throw new NullPointerException(&quot;charset is null.&quot;);
2377         }
2378 
2379         this.charset = charset;
2380     }
2381 
2382     /**
2383      * Returns the classloader used by this loader.
2384      * @return the classloader
2385      * @since JavaFX 2.1
2386      */
2387     public ClassLoader getClassLoader() {
2388         if (classLoader == null) {
2389             final SecurityManager sm = System.getSecurityManager();
2390             final Class caller = (sm != null) ?
2391                     walker.getCallerClass() :
2392                     null;
2393             return getDefaultClassLoader(caller);
2394         }
2395         return classLoader;
2396     }
2397 
2398     /**
2399      * Sets the classloader used by this loader and clears any existing
2400      * imports.
2401      *
2402      * @param classLoader the classloader
2403      * @since JavaFX 2.1
2404      */
2405     public void setClassLoader(ClassLoader classLoader) {
2406         if (classLoader == null) {
2407             throw new IllegalArgumentException();
2408         }
2409 
2410         this.classLoader = classLoader;
2411 
2412         clearImports();
2413     }
2414 
2415     /*
2416      * Returns the static load flag.
2417      */
2418     boolean isStaticLoad() {
2419         // SB-dependency: RT-21226 has been filed to track this
2420         return staticLoad;
2421     }
2422 
2423     /*
2424      * Sets the static load flag.
2425      *
2426      * @param staticLoad
2427      */
2428     void setStaticLoad(boolean staticLoad) {
2429         // SB-dependency: RT-21226 has been filed to track this
2430         this.staticLoad = staticLoad;
2431     }
2432 
2433     /**
2434      * Returns this loader&#39;s load listener.
2435      *
2436      * @return the load listener
2437      *
2438      * @since 9
2439      */
2440     public LoadListener getLoadListener() {
2441         // SB-dependency: RT-21228 has been filed to track this
2442         return loadListener;
2443     }
2444 
2445     /**
2446      * Sets this loader&#39;s load listener.
2447      *
2448      * @param loadListener the load listener
2449      *
2450      * @since 9
2451      */
2452     public final void setLoadListener(LoadListener loadListener) {
2453         // SB-dependency: RT-21228 has been filed to track this
2454         this.loadListener = loadListener;
2455     }
2456 
2457     /**
2458      * Loads an object hierarchy from a FXML document. The location from which
2459      * the document will be loaded must have been set by a prior call to
2460      * {@link #setLocation(URL)}.
2461      *
2462      * @param &lt;T&gt; the type of the root object
2463      * @throws IOException if an error occurs during loading
2464      * @return the loaded object hierarchy
2465      *
2466      * @since JavaFX 2.1
2467      */
2468     public &lt;T&gt; T load() throws IOException {
2469         return loadImpl((System.getSecurityManager() != null)
2470                             ? walker.getCallerClass()
2471                             : null);
2472     }
2473 
2474     /**
2475      * Loads an object hierarchy from a FXML document.
2476      *
2477      * @param &lt;T&gt; the type of the root object
2478      * @param inputStream an input stream containing the FXML data to load
2479      *
2480      * @throws IOException if an error occurs during loading
2481      * @return the loaded object hierarchy
2482      */
2483     public &lt;T&gt; T load(InputStream inputStream) throws IOException {
2484         return loadImpl(inputStream, (System.getSecurityManager() != null)
2485                                          ? walker.getCallerClass()
2486                                          : null);
2487     }
2488 
2489     private Class&lt;?&gt; callerClass;
2490 
2491     private &lt;T&gt; T loadImpl(final Class&lt;?&gt; callerClass) throws IOException {
2492         if (location == null) {
2493             throw new IllegalStateException(&quot;Location is not set.&quot;);
2494         }
2495 
2496         InputStream inputStream = null;
2497         T value;
2498         try {
2499             inputStream = location.openStream();
2500             value = loadImpl(inputStream, callerClass);
2501         } finally {
2502             if (inputStream != null) {
2503                 inputStream.close();
2504             }
2505         }
2506 
2507         return value;
2508     }
2509 
2510     @SuppressWarnings({ &quot;dep-ann&quot;, &quot;unchecked&quot; })
2511     private &lt;T&gt; T loadImpl(InputStream inputStream,
2512                            Class&lt;?&gt; callerClass) throws IOException {
2513         if (inputStream == null) {
2514             throw new NullPointerException(&quot;inputStream is null.&quot;);
2515         }
2516 
2517         this.callerClass = callerClass;
2518         controllerAccessor.setCallerClass(callerClass);
2519         try {
2520             clearImports();
2521 
2522             // Initialize the namespace
2523             namespace.put(LOCATION_KEY, location);
2524             namespace.put(RESOURCES_KEY, resources);
2525 
2526             // Clear the script engine
2527             scriptEngine = null;
2528 
2529             // Create the parser
2530             try {
2531                 XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
2532                 xmlInputFactory.setProperty(&quot;javax.xml.stream.isCoalescing&quot;, true);
2533 
2534                 // Some stream readers incorrectly report an empty string as the prefix
2535                 // for the default namespace; correct this as needed
2536                 InputStreamReader inputStreamReader = new InputStreamReader(inputStream, charset);
2537                 xmlStreamReader = new StreamReaderDelegate(xmlInputFactory.createXMLStreamReader(inputStreamReader)) {
2538                     @Override
2539                     public String getPrefix() {
2540                         String prefix = super.getPrefix();
2541 
2542                         if (prefix != null
2543                             &amp;&amp; prefix.length() == 0) {
2544                             prefix = null;
2545                         }
2546 
2547                         return prefix;
2548                     }
2549 
2550                     @Override
2551                     public String getAttributePrefix(int index) {
2552                         String attributePrefix = super.getAttributePrefix(index);
2553 
2554                         if (attributePrefix != null
2555                             &amp;&amp; attributePrefix.length() == 0) {
2556                             attributePrefix = null;
2557                         }
2558 
2559                         return attributePrefix;
2560                     }
2561                 };
2562             } catch (XMLStreamException exception) {
2563                 throw constructLoadException(exception);
2564             }
2565 
2566             // Push this loader onto the stack
2567             loaders.push(this);
2568 
2569             // Parse the XML stream
2570             try {
2571                 while (xmlStreamReader.hasNext()) {
2572                     int event = xmlStreamReader.next();
2573 
2574                     switch (event) {
2575                         case XMLStreamConstants.PROCESSING_INSTRUCTION: {
2576                             processProcessingInstruction();
2577                             break;
2578                         }
2579 
2580                         case XMLStreamConstants.COMMENT: {
2581                             processComment();
2582                             break;
2583                         }
2584 
2585                         case XMLStreamConstants.START_ELEMENT: {
2586                             processStartElement();
2587                             break;
2588                         }
2589 
2590                         case XMLStreamConstants.END_ELEMENT: {
2591                             processEndElement();
2592                             break;
2593                         }
2594 
2595                         case XMLStreamConstants.CHARACTERS: {
2596                             processCharacters();
2597                             break;
2598                         }
2599                     }
2600                 }
2601             } catch (XMLStreamException exception) {
2602                 throw constructLoadException(exception);
2603             }
2604 
2605             if (controller != null) {
2606                 if (controller instanceof Initializable) {
2607                     ((Initializable)controller).initialize(location, resources);
2608                 } else {
2609                     // Inject controller fields
2610                     Map&lt;String, List&lt;Field&gt;&gt; controllerFields =
2611                             controllerAccessor.getControllerFields();
2612 
2613                     injectFields(LOCATION_KEY, location);
2614 
2615                     injectFields(RESOURCES_KEY, resources);
2616 
2617                     // Initialize the controller
2618                     Method initializeMethod = controllerAccessor
2619                                                   .getControllerMethods()
2620                                                   .get(SupportedType.PARAMETERLESS)
2621                                                   .get(INITIALIZE_METHOD_NAME);
2622 
2623                     if (initializeMethod != null) {
2624                         try {
2625                             MethodHelper.invoke(initializeMethod, controller, new Object [] {});
2626                         } catch (IllegalAccessException exception) {
2627                             throw constructLoadException(exception);
2628                         } catch (InvocationTargetException exception) {
2629                             throw constructLoadException(exception);
2630                         }
2631                     }
2632                 }
2633             }
2634         } catch (final LoadException exception) {
2635             throw exception;
2636         } catch (final Exception exception) {
2637             throw constructLoadException(exception);
2638         } finally {
2639             controllerAccessor.setCallerClass(null);
2640             // Clear controller accessor caches
2641             controllerAccessor.reset();
2642             // Clear the parser
2643             xmlStreamReader = null;
2644         }
2645 
2646         return (T)root;
2647     }
2648 
2649     private void clearImports() {
2650         packages.clear();
2651         classes.clear();
2652     }
2653 
2654     private LoadException constructLoadException(String message){
2655         return new LoadException(message + constructFXMLTrace());
2656     }
2657 
2658     private LoadException constructLoadException(Throwable cause) {
2659         return new LoadException(constructFXMLTrace(), cause);
2660     }
2661 
2662     private LoadException constructLoadException(String message, Throwable cause){
2663         return new LoadException(message + constructFXMLTrace(), cause);
2664     }
2665 
2666     private String constructFXMLTrace() {
2667         StringBuilder messageBuilder = new StringBuilder(&quot;\n&quot;);
2668 
2669         for (FXMLLoader loader : loaders) {
2670             messageBuilder.append(loader.location != null ? loader.location.getPath() : &quot;unknown path&quot;);
2671 
2672             if (loader.current != null) {
2673                 messageBuilder.append(&quot;:&quot;);
2674                 messageBuilder.append(loader.getLineNumber());
2675             }
2676 
2677             messageBuilder.append(&quot;\n&quot;);
2678         }
2679         return messageBuilder.toString();
2680     }
2681 
2682     /**
2683      * Returns the current line number.
2684      */
2685     int getLineNumber() {
2686         return xmlStreamReader.getLocation().getLineNumber();
2687     }
2688 
2689     /**
2690      * Returns the current parse trace.
2691      */
2692     ParseTraceElement[] getParseTrace() {
2693         ParseTraceElement[] parseTrace = new ParseTraceElement[loaders.size()];
2694 
2695         int i = 0;
2696         for (FXMLLoader loader : loaders) {
2697             parseTrace[i++] = new ParseTraceElement(loader.location, (loader.current != null) ?
2698                 loader.getLineNumber() : -1);
2699         }
2700 
2701         return parseTrace;
2702     }
2703 
2704     private void processProcessingInstruction() throws LoadException {
2705         String piTarget = xmlStreamReader.getPITarget().trim();
2706 
2707         if (piTarget.equals(LANGUAGE_PROCESSING_INSTRUCTION)) {
2708             processLanguage();
2709         } else if (piTarget.equals(IMPORT_PROCESSING_INSTRUCTION)) {
2710             processImport();
2711         }
2712     }
2713 
2714     private void processLanguage() throws LoadException {
2715         if (scriptEngine != null) {
2716             throw constructLoadException(&quot;Page language already set.&quot;);
2717         }
2718 
2719         String language = xmlStreamReader.getPIData();
2720 
2721         if (loadListener != null) {
2722             loadListener.readLanguageProcessingInstruction(language);
2723         }
2724 
2725         if (!staticLoad) {
2726             ScriptEngineManager scriptEngineManager = getScriptEngineManager();
2727             scriptEngine = scriptEngineManager.getEngineByName(language);
2728         }
2729     }
2730 
2731     private void processImport() throws LoadException {
2732         String target = xmlStreamReader.getPIData().trim();
2733 
2734         if (loadListener != null) {
2735             loadListener.readImportProcessingInstruction(target);
2736         }
2737 
2738         if (target.endsWith(&quot;.*&quot;)) {
2739             importPackage(target.substring(0, target.length() - 2));
2740         } else {
2741             importClass(target);
2742         }
2743     }
2744 
2745     private void processComment() throws LoadException {
2746         if (loadListener != null) {
2747             loadListener.readComment(xmlStreamReader.getText());
2748         }
2749     }
2750 
2751     private void processStartElement() throws IOException {
2752         // Create the element
2753         createElement();
2754 
2755         // Process the start tag
2756         current.processStartElement();
2757 
2758         // Set the root value
2759         if (root == null) {
2760             root = current.value;
2761         }
2762     }
2763 
2764     private void createElement() throws IOException {
2765         String prefix = xmlStreamReader.getPrefix();
2766         String localName = xmlStreamReader.getLocalName();
2767 
2768         if (prefix == null) {
2769             int i = localName.lastIndexOf(&#39;.&#39;);
2770 
2771             if (Character.isLowerCase(localName.charAt(i + 1))) {
2772                 String name = localName.substring(i + 1);
2773 
2774                 if (i == -1) {
2775                     // This is an instance property
2776                     if (loadListener != null) {
2777                         loadListener.beginPropertyElement(name, null);
2778                     }
2779 
2780                     current = new PropertyElement(name, null);
2781                 } else {
2782                     // This is a static property
2783                     Class&lt;?&gt; sourceType = getType(localName.substring(0, i));
2784 
2785                     if (sourceType != null) {
2786                         if (loadListener != null) {
2787                             loadListener.beginPropertyElement(name, sourceType);
2788                         }
2789 
2790                         current = new PropertyElement(name, sourceType);
2791                     } else if (staticLoad) {
2792                         // The source type was not recognized
2793                         if (loadListener != null) {
2794                             loadListener.beginUnknownStaticPropertyElement(localName);
2795                         }
2796 
2797                         current = new UnknownStaticPropertyElement();
2798                     } else {
2799                         throw constructLoadException(localName + &quot; is not a valid property.&quot;);
2800                     }
2801                 }
2802             } else {
2803                 if (current == null &amp;&amp; root != null) {
2804                     throw constructLoadException(&quot;Root value already specified.&quot;);
2805                 }
2806 
2807                 Class&lt;?&gt; type = getType(localName);
2808 
2809                 if (type != null) {
2810                     if (loadListener != null) {
2811                         loadListener.beginInstanceDeclarationElement(type);
2812                     }
2813 
2814                     current = new InstanceDeclarationElement(type);
2815                 } else if (staticLoad) {
2816                     // The type was not recognized
2817                     if (loadListener != null) {
2818                         loadListener.beginUnknownTypeElement(localName);
2819                     }
2820 
2821                     current = new UnknownTypeElement();
2822                 } else {
2823                     throw constructLoadException(localName + &quot; is not a valid type.&quot;);
2824                 }
2825             }
2826         } else if (prefix.equals(FX_NAMESPACE_PREFIX)) {
2827             if (localName.equals(INCLUDE_TAG)) {
2828                 if (loadListener != null) {
2829                     loadListener.beginIncludeElement();
2830                 }
2831 
2832                 current = new IncludeElement();
2833             } else if (localName.equals(REFERENCE_TAG)) {
2834                 if (loadListener != null) {
2835                     loadListener.beginReferenceElement();
2836                 }
2837 
2838                 current = new ReferenceElement();
2839             } else if (localName.equals(COPY_TAG)) {
2840                 if (loadListener != null) {
2841                     loadListener.beginCopyElement();
2842                 }
2843 
2844                 current = new CopyElement();
2845             } else if (localName.equals(ROOT_TAG)) {
2846                 if (loadListener != null) {
2847                     loadListener.beginRootElement();
2848                 }
2849 
2850                 current = new RootElement();
2851             } else if (localName.equals(SCRIPT_TAG)) {
2852                 if (loadListener != null) {
2853                     loadListener.beginScriptElement();
2854                 }
2855 
2856                 current = new ScriptElement();
2857             } else if (localName.equals(DEFINE_TAG)) {
2858                 if (loadListener != null) {
2859                     loadListener.beginDefineElement();
2860                 }
2861 
2862                 current = new DefineElement();
2863             } else {
2864                 throw constructLoadException(prefix + &quot;:&quot; + localName + &quot; is not a valid element.&quot;);
2865             }
2866         } else {
2867             throw constructLoadException(&quot;Unexpected namespace prefix: &quot; + prefix + &quot;.&quot;);
2868         }
2869     }
2870 
2871     private void processEndElement() throws IOException {
2872         current.processEndElement();
2873 
2874         if (loadListener != null) {
2875             loadListener.endElement(current.value);
2876         }
2877 
2878         // Move up the stack
2879         current = current.parent;
2880     }
2881 
2882     private void processCharacters() throws IOException {
2883         // Process the characters
2884         if (!xmlStreamReader.isWhiteSpace()) {
2885             current.processCharacters();
2886         }
2887     }
2888 
2889     private void importPackage(String name) throws LoadException {
2890         packages.add(name);
2891     }
2892 
2893     private void importClass(String name) throws LoadException {
2894         try {
2895             loadType(name, true);
2896         } catch (ClassNotFoundException exception) {
2897             throw constructLoadException(exception);
2898         }
2899     }
2900 
2901     private Class&lt;?&gt; getType(String name) throws LoadException {
2902         Class&lt;?&gt; type = null;
2903 
2904         if (Character.isLowerCase(name.charAt(0))) {
2905             // This is a fully-qualified class name
2906             try {
2907                 type = loadType(name, false);
2908             } catch (ClassNotFoundException exception) {
2909                 // No-op
2910             }
2911         } else {
2912             // This is an unqualified class name
2913             type = classes.get(name);
2914 
2915             if (type == null) {
2916                 // The class has not been loaded yet; look it up
2917                 for (String packageName : packages) {
2918                     try {
2919                         type = loadTypeForPackage(packageName, name);
2920                     } catch (ClassNotFoundException exception) {
2921                         // No-op
2922                     }
2923 
2924                     if (type != null) {
2925                         break;
2926                     }
2927                 }
2928 
2929                 if (type != null) {
2930                     classes.put(name, type);
2931                 }
2932             }
2933         }
2934 
2935         return type;
2936     }
2937 
2938     private Class&lt;?&gt; loadType(String name, boolean cache) throws ClassNotFoundException {
2939         int i = name.indexOf(&#39;.&#39;);
2940         int n = name.length();
2941         while (i != -1
2942             &amp;&amp; i &lt; n
2943             &amp;&amp; Character.isLowerCase(name.charAt(i + 1))) {
2944             i = name.indexOf(&#39;.&#39;, i + 1);
2945         }
2946 
2947         if (i == -1 || i == n) {
2948             throw new ClassNotFoundException();
2949         }
2950 
2951         String packageName = name.substring(0, i);
2952         String className = name.substring(i + 1);
2953 
2954         Class&lt;?&gt; type = loadTypeForPackage(packageName, className);
2955 
2956         if (cache) {
2957             classes.put(className, type);
2958         }
2959 
2960         return type;
2961     }
2962 
2963     // TODO Rename to loadType() when deprecated static version is removed
2964     private Class&lt;?&gt; loadTypeForPackage(String packageName, String className) throws ClassNotFoundException {
2965         return getClassLoader().loadClass(packageName + &quot;.&quot; + className.replace(&#39;.&#39;, &#39;$&#39;));
2966     }
2967 
2968     private static enum SupportedType {
2969         PARAMETERLESS {
2970 
2971             @Override
2972             protected boolean methodIsOfType(Method m) {
2973                 return m.getParameterTypes().length == 0;
2974             }
2975 
2976         },
2977         EVENT {
2978 
2979             @Override
2980             protected boolean methodIsOfType(Method m) {
2981                 return m.getParameterTypes().length == 1 &amp;&amp;
2982                         Event.class.isAssignableFrom(m.getParameterTypes()[0]);
2983             }
2984 
2985         },
2986         LIST_CHANGE_LISTENER {
2987 
2988             @Override
2989             protected boolean methodIsOfType(Method m) {
2990                 return m.getParameterTypes().length == 1 &amp;&amp;
2991                         m.getParameterTypes()[0].equals(ListChangeListener.Change.class);
2992             }
2993 
2994         },
2995         MAP_CHANGE_LISTENER {
2996 
2997             @Override
2998             protected boolean methodIsOfType(Method m) {
2999                 return m.getParameterTypes().length == 1 &amp;&amp;
3000                         m.getParameterTypes()[0].equals(MapChangeListener.Change.class);
3001             }
3002 
3003         },
3004         SET_CHANGE_LISTENER {
3005 
3006             @Override
3007             protected boolean methodIsOfType(Method m) {
3008                 return m.getParameterTypes().length == 1 &amp;&amp;
3009                         m.getParameterTypes()[0].equals(SetChangeListener.Change.class);
3010             }
3011 
3012         },
3013         PROPERTY_CHANGE_LISTENER {
3014 
3015             @Override
3016             protected boolean methodIsOfType(Method m) {
3017                 return m.getParameterTypes().length == 3 &amp;&amp;
3018                         ObservableValue.class.isAssignableFrom(m.getParameterTypes()[0])
3019                         &amp;&amp; m.getParameterTypes()[1].equals(m.getParameterTypes()[2]);
3020             }
3021 
3022         };
3023 
3024         protected abstract boolean methodIsOfType(Method m);
3025     }
3026 
3027     private static SupportedType toSupportedType(Method m) {
3028         for (SupportedType t : SupportedType.values()) {
3029             if (t.methodIsOfType(m)) {
3030                 return t;
3031             }
3032         }
3033         return null;
3034     }
3035 
3036     private ScriptEngineManager getScriptEngineManager() {
3037         if (scriptEngineManager == null) {
3038             scriptEngineManager = new javax.script.ScriptEngineManager();
3039             scriptEngineManager.setBindings(new SimpleBindings(namespace));
3040         }
3041 
3042         return scriptEngineManager;
3043     }
3044 
3045     /**
3046      * Loads a type using the default class loader.
3047      *
3048      * @param packageName the package name of the class to load
3049      * @param className the name of the class to load
3050      *
3051      * @throws ClassNotFoundException if the specified class cannot be found
3052      * @return the class
3053      *
3054      * @deprecated
3055      * This method now delegates to {@link #getDefaultClassLoader()}.
3056      */
3057     @Deprecated
3058     public static Class&lt;?&gt; loadType(String packageName, String className) throws ClassNotFoundException {
3059         return loadType(packageName + &quot;.&quot; + className.replace(&#39;.&#39;, &#39;$&#39;));
3060     }
3061 
3062     /**
3063      * Loads a type using the default class loader.
3064      *
3065      * @param className the name of the class to load
3066      * @throws ClassNotFoundException if the specified class cannot be found
3067      * @return the class
3068      *
3069      * @deprecated
3070      * This method now delegates to {@link #getDefaultClassLoader()}.
3071      */
3072     @Deprecated
3073     public static Class&lt;?&gt; loadType(String className) throws ClassNotFoundException {
3074         ReflectUtil.checkPackageAccess(className);
3075         return Class.forName(className, true, getDefaultClassLoader());
3076     }
3077 
3078     private static boolean needsClassLoaderPermissionCheck(Class caller) {
3079         if (caller == null) {
3080             return false;
3081         }
3082         return !FXMLLoader.class.getModule().equals(caller.getModule());
3083     }
3084 
3085     private static ClassLoader getDefaultClassLoader(Class caller) {
3086         if (defaultClassLoader == null) {
3087             final SecurityManager sm = System.getSecurityManager();
3088             if (sm != null) {
3089                 if (needsClassLoaderPermissionCheck(caller)) {
3090                     sm.checkPermission(GET_CLASSLOADER_PERMISSION);
3091                 }
3092             }
3093             return Thread.currentThread().getContextClassLoader();
3094         }
3095         return defaultClassLoader;
3096     }
3097 
3098     /**
3099      * Returns the default class loader.
3100      * @return the default class loader
3101      * @since JavaFX 2.1
3102      */
3103     public static ClassLoader getDefaultClassLoader() {
3104         final SecurityManager sm = System.getSecurityManager();
3105         final Class caller = (sm != null) ?
3106                 walker.getCallerClass() :
3107                 null;
3108         return getDefaultClassLoader(caller);
3109     }
3110 
3111     /**
3112      * Sets the default class loader.
3113      *
3114      * @param defaultClassLoader
3115      * The default class loader to use when loading classes.
3116      * @since JavaFX 2.1
3117      */
3118     public static void setDefaultClassLoader(ClassLoader defaultClassLoader) {
3119         if (defaultClassLoader == null) {
3120             throw new NullPointerException();
3121         }
3122         final SecurityManager sm = System.getSecurityManager();
3123         if (sm != null) {
3124             sm.checkPermission(MODIFY_FXML_CLASS_LOADER_PERMISSION);
3125         }
3126 
3127         FXMLLoader.defaultClassLoader = defaultClassLoader;
3128     }
3129 
3130     /**
3131      * Loads an object hierarchy from a FXML document.
3132      *
3133      * @param &lt;T&gt; the type of the root object
3134      * @param location the location used to resolve relative path attribute values
3135      *
3136      * @throws IOException if an error occurs during loading
3137      * @return the loaded object hierarchy
3138      */
3139     public static &lt;T&gt; T load(URL location) throws IOException {
3140         return loadImpl(location, (System.getSecurityManager() != null)
3141                                       ? walker.getCallerClass()
3142                                       : null);
3143     }
3144 
3145     private static &lt;T&gt; T loadImpl(URL location, Class&lt;?&gt; callerClass)
3146             throws IOException {
3147         return loadImpl(location, null, callerClass);
3148     }
3149 
3150     /**
3151      * Loads an object hierarchy from a FXML document.
3152      *
3153      * @param &lt;T&gt; the type of the root object
3154      * @param location the location used to resolve relative path attribute values
3155      * @param resources the resources used to resolve resource key attribute values
3156      *
3157      * @throws IOException if an error occurs during loading
3158      * @return the loaded object hierarchy
3159      */
3160     public static &lt;T&gt; T load(URL location, ResourceBundle resources)
3161                                      throws IOException {
3162         return loadImpl(location, resources,
3163                         (System.getSecurityManager() != null)
3164                             ? walker.getCallerClass()
3165                             : null);
3166     }
3167 
3168     private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
3169                                   Class&lt;?&gt; callerClass) throws IOException {
3170         return loadImpl(location, resources,  null,
3171                         callerClass);
3172     }
3173 
3174     /**
3175      * Loads an object hierarchy from a FXML document.
3176      *
3177      * @param &lt;T&gt; the type of the root object
3178      * @param location the location used to resolve relative path attribute values
3179      * @param resources the resources used to resolve resource key attribute values
3180      * @param builderFactory the builder factory used to load the document
3181      *
3182      * @throws IOException if an error occurs during loading
3183      * @return the loaded object hierarchy
3184      */
3185     public static &lt;T&gt; T load(URL location, ResourceBundle resources,
3186                              BuilderFactory builderFactory)
3187                                      throws IOException {
3188         return loadImpl(location, resources, builderFactory,
3189                         (System.getSecurityManager() != null)
3190                             ? walker.getCallerClass()
3191                             : null);
3192     }
3193 
3194     private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
3195                                   BuilderFactory builderFactory,
3196                                   Class&lt;?&gt; callerClass) throws IOException {
3197         return loadImpl(location, resources, builderFactory, null, callerClass);
3198     }
3199 
3200     /**
3201      * Loads an object hierarchy from a FXML document.
3202      *
3203      * @param &lt;T&gt; the type of the root object
3204      * @param location the location used to resolve relative path attribute values
3205      * @param resources the resources used to resolve resource key attribute values
3206      * @param builderFactory the builder factory used when loading the document
3207      * @param controllerFactory the controller factory used when loading the document
3208      *
3209      * @throws IOException if an error occurs during loading
3210      * @return the loaded object hierarchy
3211      *
3212      * @since JavaFX 2.1
3213      */
3214     public static &lt;T&gt; T load(URL location, ResourceBundle resources,
3215                              BuilderFactory builderFactory,
3216                              Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory)
3217                                      throws IOException {
3218         return loadImpl(location, resources, builderFactory, controllerFactory,
3219                         (System.getSecurityManager() != null)
3220                             ? walker.getCallerClass()
3221                             : null);
3222     }
3223 
3224     private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
3225                                   BuilderFactory builderFactory,
3226                                   Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory,
3227                                   Class&lt;?&gt; callerClass) throws IOException {
3228         return loadImpl(location, resources, builderFactory, controllerFactory,
3229                         Charset.forName(DEFAULT_CHARSET_NAME), callerClass);
3230     }
3231 
3232     /**
3233      * Loads an object hierarchy from a FXML document.
3234      *
3235      * @param &lt;T&gt; the type of the root object
3236      * @param location the location used to resolve relative path attribute values
3237      * @param resources the resources used to resolve resource key attribute values
3238      * @param builderFactory the builder factory used when loading the document
3239      * @param controllerFactory the controller factory used when loading the document
3240      * @param charset the character set used when loading the document
3241      *
3242      * @throws IOException if an error occurs during loading
3243      * @return the loaded object hierarchy
3244      *
3245      * @since JavaFX 2.1
3246      */
3247     public static &lt;T&gt; T load(URL location, ResourceBundle resources,
3248                              BuilderFactory builderFactory,
3249                              Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory,
3250                              Charset charset) throws IOException {
3251         return loadImpl(location, resources, builderFactory, controllerFactory,
3252                         charset,
3253                         (System.getSecurityManager() != null)
3254                             ? walker.getCallerClass()
3255                             : null);
3256     }
3257 
3258     private static &lt;T&gt; T loadImpl(URL location, ResourceBundle resources,
3259                                   BuilderFactory builderFactory,
3260                                   Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory,
3261                                   Charset charset, Class&lt;?&gt; callerClass)
3262                                           throws IOException {
3263         if (location == null) {
3264             throw new NullPointerException(&quot;Location is required.&quot;);
3265         }
3266 
3267         FXMLLoader fxmlLoader =
3268                 new FXMLLoader(location, resources, builderFactory,
3269                                controllerFactory, charset);
3270 
3271         return fxmlLoader.&lt;T&gt;loadImpl(callerClass);
3272     }
3273 
3274     /**
3275      * Utility method for comparing two JavaFX version strings (such as 2.2.5, 8.0.0-ea)
3276      * @param rtVer String representation of JavaFX runtime version, including - or _ appendix
3277      * @param nsVer String representation of JavaFX version to compare against runtime version
3278      * @return number &amp;lt; 0 if runtime version is lower, 0 when both versions are the same,
3279      *          number &amp;gt; 0 if runtime is higher version
3280      */
3281     static int compareJFXVersions(String rtVer, String nsVer) {
3282 
3283         int retVal = 0;
3284 
3285         if (rtVer == null || &quot;&quot;.equals(rtVer) ||
3286             nsVer == null || &quot;&quot;.equals(nsVer)) {
3287             return retVal;
3288         }
3289 
3290         if (rtVer.equals(nsVer)) {
3291             return retVal;
3292         }
3293 
3294         // version string can contain &#39;-&#39;
3295         int dashIndex = rtVer.indexOf(&quot;-&quot;);
3296         if (dashIndex &gt; 0) {
3297             rtVer = rtVer.substring(0, dashIndex);
3298         }
3299 
3300         // or &quot;_&quot;
3301         int underIndex = rtVer.indexOf(&quot;_&quot;);
3302         if (underIndex &gt; 0) {
3303             rtVer = rtVer.substring(0, underIndex);
3304         }
3305 
3306         // do not try to compare if the string is not valid version format
3307         if (!Pattern.matches(&quot;^(\\d+)(\\.\\d+)*$&quot;, rtVer) ||
3308             !Pattern.matches(&quot;^(\\d+)(\\.\\d+)*$&quot;, nsVer)) {
3309             return retVal;
3310         }
3311 
3312         StringTokenizer nsVerTokenizer = new StringTokenizer(nsVer, &quot;.&quot;);
3313         StringTokenizer rtVerTokenizer = new StringTokenizer(rtVer, &quot;.&quot;);
3314         int nsDigit = 0, rtDigit = 0;
3315         boolean rtVerEnd = false;
3316 
3317         while (nsVerTokenizer.hasMoreTokens() &amp;&amp; retVal == 0) {
3318             nsDigit = Integer.parseInt(nsVerTokenizer.nextToken());
3319             if (rtVerTokenizer.hasMoreTokens()) {
3320                 rtDigit = Integer.parseInt(rtVerTokenizer.nextToken());
3321                 retVal = rtDigit - nsDigit;
3322             } else {
3323                 rtVerEnd = true;
3324                 break;
3325             }
3326         }
3327 
3328         if (rtVerTokenizer.hasMoreTokens() &amp;&amp; retVal == 0) {
3329             rtDigit = Integer.parseInt(rtVerTokenizer.nextToken());
3330             if (rtDigit &gt; 0) {
3331                 retVal = 1;
3332             }
3333         }
3334 
3335         if (rtVerEnd) {
3336             if (nsDigit &gt; 0) {
3337                 retVal = -1;
3338             } else {
3339                 while (nsVerTokenizer.hasMoreTokens()) {
3340                     nsDigit = Integer.parseInt(nsVerTokenizer.nextToken());
3341                     if (nsDigit &gt; 0) {
3342                         retVal = -1;
3343                         break;
3344                     }
3345                 }
3346             }
3347         }
3348 
3349         return retVal;
3350     }
3351 
3352     private static void checkClassLoaderPermission() {
3353         final SecurityManager securityManager = System.getSecurityManager();
3354         if (securityManager != null) {
3355             securityManager.checkPermission(MODIFY_FXML_CLASS_LOADER_PERMISSION);
3356         }
3357     }
3358 
3359     private final ControllerAccessor controllerAccessor =
3360             new ControllerAccessor();
3361 
3362     private static final class ControllerAccessor {
3363         private static final int PUBLIC = 1;
3364         private static final int PROTECTED = 2;
3365         private static final int PACKAGE = 4;
3366         private static final int PRIVATE = 8;
3367         private static final int INITIAL_CLASS_ACCESS =
3368                 PUBLIC | PROTECTED | PACKAGE | PRIVATE;
3369         private static final int INITIAL_MEMBER_ACCESS =
3370                 PUBLIC | PROTECTED | PACKAGE | PRIVATE;
3371 
3372         private static final int METHODS = 0;
3373         private static final int FIELDS = 1;
3374 
3375         private Object controller;
3376         private ClassLoader callerClassLoader;
3377 
3378         private Map&lt;String, List&lt;Field&gt;&gt; controllerFields;
3379         private Map&lt;SupportedType, Map&lt;String, Method&gt;&gt; controllerMethods;
3380 
3381         void setController(final Object controller) {
3382             if (this.controller != controller) {
3383                 this.controller = controller;
3384                 reset();
3385             }
3386         }
3387 
3388         void setCallerClass(final Class&lt;?&gt; callerClass) {
3389             final ClassLoader newCallerClassLoader =
3390                     (callerClass != null) ? callerClass.getClassLoader()
3391                                           : null;
3392             if (callerClassLoader != newCallerClassLoader) {
3393                 callerClassLoader = newCallerClassLoader;
3394                 reset();
3395             }
3396         }
3397 
3398         void reset() {
3399             controllerFields = null;
3400             controllerMethods = null;
3401         }
3402 
3403         Map&lt;String, List&lt;Field&gt;&gt; getControllerFields() {
3404             if (controllerFields == null) {
3405                 controllerFields = new HashMap&lt;&gt;();
3406 
3407                 if (callerClassLoader == null) {
3408                     // allow null class loader only with permission check
3409                     checkClassLoaderPermission();
3410                 }
3411 
3412                 addAccessibleMembers(controller.getClass(),
3413                                      INITIAL_CLASS_ACCESS,
3414                                      INITIAL_MEMBER_ACCESS,
3415                                      FIELDS);
3416             }
3417 
3418             return controllerFields;
3419         }
3420 
3421         Map&lt;SupportedType, Map&lt;String, Method&gt;&gt; getControllerMethods() {
3422             if (controllerMethods == null) {
3423                 controllerMethods = new EnumMap&lt;&gt;(SupportedType.class);
3424                 for (SupportedType t: SupportedType.values()) {
3425                     controllerMethods.put(t, new HashMap&lt;String, Method&gt;());
3426                 }
3427 
3428                 if (callerClassLoader == null) {
3429                     // allow null class loader only with permission check
3430                     checkClassLoaderPermission();
3431                 }
3432 
3433                 addAccessibleMembers(controller.getClass(),
3434                                      INITIAL_CLASS_ACCESS,
3435                                      INITIAL_MEMBER_ACCESS,
3436                                      METHODS);
3437             }
3438 
3439             return controllerMethods;
3440         }
3441 
3442         private void addAccessibleMembers(final Class&lt;?&gt; type,
3443                                           final int prevAllowedClassAccess,
3444                                           final int prevAllowedMemberAccess,
3445                                           final int membersType) {
3446             if (type == Object.class) {
3447                 return;
3448             }
3449 
3450             int allowedClassAccess = prevAllowedClassAccess;
3451             int allowedMemberAccess = prevAllowedMemberAccess;
3452             if ((callerClassLoader != null)
3453                     &amp;&amp; (type.getClassLoader() != callerClassLoader)) {
3454                 // restrict further access
3455                 allowedClassAccess &amp;= PUBLIC;
3456                 allowedMemberAccess &amp;= PUBLIC;
3457             }
3458 
3459             final int classAccess = getAccess(type.getModifiers());
3460             if ((classAccess &amp; allowedClassAccess) == 0) {
3461                 // we are done
3462                 return;
3463             }
3464 
3465             ReflectUtil.checkPackageAccess(type);
3466 
3467             addAccessibleMembers(type.getSuperclass(),
3468                                  allowedClassAccess,
3469                                  allowedMemberAccess,
3470                                  membersType);
3471 
3472             final int finalAllowedMemberAccess = allowedMemberAccess;
3473             AccessController.doPrivileged(
3474                     new PrivilegedAction&lt;Void&gt;() {
3475                         @Override
3476                         public Void run() {
3477                             if (membersType == FIELDS) {
3478                                 addAccessibleFields(type,
3479                                                     finalAllowedMemberAccess);
3480                             } else {
3481                                 addAccessibleMethods(type,
3482                                                      finalAllowedMemberAccess);
3483                             }
3484 
3485                             return null;
3486                         }
3487                     });
3488         }
3489 
3490         private void addAccessibleFields(final Class&lt;?&gt; type,
3491                                          final int allowedMemberAccess) {
3492             final boolean isPublicType = Modifier.isPublic(type.getModifiers());
3493 
3494             final Field[] fields = type.getDeclaredFields();
3495             for (int i = 0; i &lt; fields.length; ++i) {
3496                 final Field field = fields[i];
3497                 final int memberModifiers = field.getModifiers();
3498 
3499                 if (((memberModifiers &amp; (Modifier.STATIC
3500                                              | Modifier.FINAL)) != 0)
3501                         || ((getAccess(memberModifiers) &amp; allowedMemberAccess)
3502                                 == 0)) {
3503                     continue;
3504                 }
3505 
3506                 if (!isPublicType || !Modifier.isPublic(memberModifiers)) {
3507                     if (field.getAnnotation(FXML.class) == null) {
3508                         // no fxml annotation on a non-public field
3509                         continue;
3510                     }
3511 
3512                     // Ensure that the field is accessible
3513                     field.setAccessible(true);
3514                 }
3515 
3516                 List&lt;Field&gt; list = controllerFields.get(field.getName());
3517                 if (list == null) {
3518                     list = new ArrayList&lt;&gt;(1);
3519                     controllerFields.put(field.getName(), list);
3520                 }
3521                 list.add(field);
3522 
3523             }
3524         }
3525 
3526         private void addAccessibleMethods(final Class&lt;?&gt; type,
3527                                           final int allowedMemberAccess) {
3528             final boolean isPublicType = Modifier.isPublic(type.getModifiers());
3529 
3530             final Method[] methods = type.getDeclaredMethods();
3531             for (int i = 0; i &lt; methods.length; ++i) {
3532                 final Method method = methods[i];
3533                 final int memberModifiers = method.getModifiers();
3534 
3535                 if (((memberModifiers &amp; (Modifier.STATIC
3536                                              | Modifier.NATIVE)) != 0)
3537                         || ((getAccess(memberModifiers) &amp; allowedMemberAccess)
3538                                 == 0)) {
3539                     continue;
3540                 }
3541 
3542                 if (!isPublicType || !Modifier.isPublic(memberModifiers)) {
3543                     if (method.getAnnotation(FXML.class) == null) {
3544                         // no fxml annotation on a non-public method
3545                         continue;
3546                     }
3547 
3548                     // Ensure that the method is accessible
3549                     method.setAccessible(true);
3550                 }
3551 
3552                 // Add this method to the map if:
3553                 // a) it is the initialize() method, or
3554                 // b) it takes a single event argument, or
3555                 // c) it takes no arguments and a handler with this
3556                 //    name has not already been defined
3557                 final String methodName = method.getName();
3558                 final SupportedType convertedType;
3559 
3560                 if ((convertedType = toSupportedType(method)) != null) {
3561                     controllerMethods.get(convertedType)
3562                                      .put(methodName, method);
3563                 }
3564             }
3565         }
3566 
3567         private static int getAccess(final int fullModifiers) {
3568             final int untransformedAccess =
3569                     fullModifiers &amp; (Modifier.PRIVATE | Modifier.PROTECTED
3570                                                       | Modifier.PUBLIC);
3571 
3572             switch (untransformedAccess) {
3573                 case Modifier.PUBLIC:
3574                     return PUBLIC;
3575 
3576                 case Modifier.PROTECTED:
3577                     return PROTECTED;
3578 
3579                 case Modifier.PRIVATE:
3580                     return PRIVATE;
3581 
3582                 default:
3583                     return PACKAGE;
3584             }
3585         }
3586     }
3587 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
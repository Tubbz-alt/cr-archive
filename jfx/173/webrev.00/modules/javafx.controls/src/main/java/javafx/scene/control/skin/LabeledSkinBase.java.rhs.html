<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/skin/LabeledSkinBase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control.skin;
  27 
  28 import com.sun.javafx.scene.control.LabeledText;
  29 import com.sun.javafx.scene.control.behavior.TextBinding;
  30 import com.sun.javafx.scene.control.skin.Utils;
  31 import javafx.application.Platform;
  32 import javafx.beans.InvalidationListener;
  33 import javafx.geometry.HPos;
  34 import javafx.geometry.NodeOrientation;
  35 import javafx.geometry.Orientation;
  36 import javafx.geometry.Point2D;
  37 import javafx.geometry.Pos;
  38 import javafx.geometry.VPos;
  39 import javafx.scene.AccessibleAttribute;
  40 import javafx.scene.Node;
  41 import javafx.scene.Scene;
  42 import javafx.scene.control.Accordion;
  43 import javafx.scene.control.ContentDisplay;
  44 import javafx.scene.control.Control;
  45 import javafx.scene.control.Label;
  46 import javafx.scene.control.Labeled;
  47 import javafx.scene.control.OverrunStyle;
  48 import javafx.scene.control.SkinBase;
  49 import javafx.scene.image.ImageView;
  50 import javafx.scene.input.KeyCombination;
  51 import javafx.scene.input.Mnemonic;
  52 import javafx.scene.shape.Line;
  53 import javafx.scene.shape.Rectangle;
  54 import javafx.scene.text.Font;
  55 
  56 import static javafx.scene.control.ContentDisplay.BOTTOM;
  57 import static javafx.scene.control.ContentDisplay.LEFT;
  58 import static javafx.scene.control.ContentDisplay.RIGHT;
  59 import static javafx.scene.control.ContentDisplay.TOP;
  60 import static javafx.scene.control.OverrunStyle.CLIP;
  61 
  62 /**
  63  * Default skin implementation for controls extends {@link Labeled}.
  64  *
  65  * @see Labeled
  66  * @since 9
  67  */
  68 public abstract class LabeledSkinBase&lt;C extends Labeled&gt; extends SkinBase&lt;C&gt; {
  69 
  70     /***************************************************************************
  71      *                                                                         *
  72      * Private fields                                                          *
  73      *                                                                         *
  74      **************************************************************************/
  75 
  76     /**
  77      *  The Text node used to display the text. This is package only
  78      *  for the sake of testing!
  79      */
  80     LabeledText text;
  81 
  82     /**
  83      * Indicates that the text content is invalid and needs to be updated.
  84      * This is package private only for the sake of testing.
  85      */
  86     boolean invalidText = true;
  87 
  88     /**
  89      * A reference to the last-known graphic on the Labeled. This reference
  90      * is kept so that we can remove listeners from the old graphic later
  91      */
  92     Node graphic;
  93 
  94     /**
  95      * The cached full width of the non-truncated text. We only want to
  96      * recompute this if the text has itself changed, or if the font has changed.
  97      * This is package private ONLY FOR THE SAKE OF TESTING
  98      */
  99     double textWidth = Double.NEGATIVE_INFINITY;
 100 
 101     /**
 102      * The cached width of the ellipsis string. This will be recomputed
 103      * if the font or the ellipsisString property have changed.
 104      * This is package private ONLY FOR THE SAKE OF TESTING
 105      */
 106     double ellipsisWidth = Double.NEGATIVE_INFINITY;
 107 
 108     /**
 109      * A listener which is applied to the graphic whenever the graphic is set
 110      * and is visible within the labeled. For example, if there is a graphic
 111      * defined on the Labeled but the ContentDisplay is set to TEXT_ONLY, then
 112      * we will not bother installing this listener on the graphic. In all
 113      * other cases, if the graphic is defined, it will have this listener
 114      * added to it, which ensures that if the graphic&#39;s layout bounds change,
 115      * we end up performing a layout and potentially update the visible text.
 116      *
 117      * This is package private ONLY FOR THE SAKE OF TESTING
 118      */
 119     final InvalidationListener graphicPropertyChangedListener = valueModel -&gt; {
 120         invalidText = true;
 121         if (getSkinnable() != null) getSkinnable().requestLayout();
 122     };
 123 
 124     private Rectangle textClip;
 125     private double wrapWidth;
 126     private double wrapHeight;
 127 
 128     private TextBinding bindings;
 129     private Line mnemonic_underscore;
 130 
 131     private boolean containsMnemonic = false;
 132     private Scene mnemonicScene = null;
 133     private KeyCombination mnemonicCode;
 134     // needs to be an object, as MenuItem isn&#39;t a node
 135     private Node labeledNode = null;
 136 
 137 
 138 
 139     /***************************************************************************
 140      *                                                                         *
 141      * Constructors                                                            *
 142      *                                                                         *
 143      **************************************************************************/
 144 
 145     /**
 146      * Constructor for LabeledSkinBase. The Labeled must be specified, and cannot be null.
 147      * At the conclusion of the constructor call, the skin will be marked as
 148      * needsLayout, and will be fully configured based on the current state of
 149      * the labeled. Any subsequent changes to the Labeled will be handled via
 150      * listeners and applied appropriately.
 151      *
 152      * @param labeled The labeled that this skin should be installed onto.
 153      */
 154     public LabeledSkinBase(final C labeled) {
 155         super(labeled);
 156 
 157         // Configure the Text node with all of the attributes from the
 158         // Labeled which apply to it.
 159         text = new LabeledText(labeled);
 160 
 161         updateChildren();
 162 
 163         // Labels do not block the mouse by default, unlike most other UI Controls.
 164         //consumeMouseEvents(false);
 165 
 166         // Register listeners
 167         /*
 168          * There are basically 2 things to worry about in each of these handlers
 169          *  1) Update the Text node
 170          *  2) Have the text metrics changed?
 171          *
 172          * If the metrics have changed, we need to request a layout and invalidate
 173          * the text so that we recompute the display text on next read.
 174          */
 175         registerChangeListener(labeled.ellipsisStringProperty(), o -&gt; {
 176             textMetricsChanged();
 177             invalidateWidths();
 178             ellipsisWidth = Double.NEGATIVE_INFINITY;
 179         });
 180         registerChangeListener(labeled.widthProperty(), o -&gt; {
 181             updateWrappingWidth();
 182             invalidText = true;
 183             // No requestLayout() because Control will force a layout
 184         });
 185         registerChangeListener(labeled.heightProperty(), o -&gt; {
 186             invalidText = true;
 187             // No requestLayout() because Control will force a layout
 188         });
 189         registerChangeListener(labeled.fontProperty(), o -&gt; {
 190             textMetricsChanged();
 191             invalidateWidths();
 192             ellipsisWidth = Double.NEGATIVE_INFINITY;
 193         });
 194         registerChangeListener(labeled.graphicProperty(), o -&gt; {
 195             updateChildren();
 196             textMetricsChanged();
 197         });
 198         registerChangeListener(labeled.contentDisplayProperty(), o -&gt; {
 199             updateChildren();
 200             textMetricsChanged();
 201         });
 202         registerChangeListener(labeled.labelPaddingProperty(), o -&gt; textMetricsChanged());
 203         registerChangeListener(labeled.graphicTextGapProperty(), o -&gt; textMetricsChanged());
 204         registerChangeListener(labeled.alignmentProperty(), o -&gt; {
 205             // Doesn&#39;t involve text metrics because if the text is too long, then
 206             // it will already have fit all available width and a change to hpos
 207             // has no effect. Or it is too short (i.e. it all fits) and we don&#39;t
 208             // have to worry about truncation. So just call request layout.
 209             // Doesn&#39;t involve text metrics because if the text is too long, then
 210             // it will already have fit all available height and a change to vpos
 211             // has no effect. Or it is too short (i.e. it all fits) and we don&#39;t
 212             // have to worry about truncation. So just call request layout.
 213             getSkinnable().requestLayout();
 214         });
 215         registerChangeListener(labeled.mnemonicParsingProperty(), o -&gt; {
 216             containsMnemonic = false;
 217             textMetricsChanged();
 218         });
 219         registerChangeListener(labeled.textProperty(), o -&gt; {
 220             updateChildren();
 221             textMetricsChanged();
 222             invalidateWidths();
 223         });
 224         registerChangeListener(labeled.textAlignmentProperty(), o -&gt; { /* NO-OP */ });
 225         registerChangeListener(labeled.textOverrunProperty(), o -&gt; textMetricsChanged());
 226         registerChangeListener(labeled.wrapTextProperty(), o -&gt; {
 227             updateWrappingWidth();
 228             textMetricsChanged();
 229         });
 230         registerChangeListener(labeled.underlineProperty(), o -&gt; textMetricsChanged());
 231         registerChangeListener(labeled.lineSpacingProperty(), o -&gt; textMetricsChanged());
 232         registerChangeListener(labeled.sceneProperty(), o -&gt; sceneChanged());
 233     }
 234 
 235 
 236 
 237     /***************************************************************************
 238      *                                                                         *
 239      * Public API                                                              *
 240      *                                                                         *
 241      **************************************************************************/
 242 
 243     /**
 244      * Updates the children managed by LabeledSkinBase, which can be the Labeled
 245      * graphic and/or a Text node. Only those nodes which actually must
 246      * be used are used. For example, with a ContentDisplay of
 247      * GRAPHIC_ONLY the text node is not added, and with a ContentDisplay
 248      * of TEXT_ONLY, the graphic is not added.
 249      */
 250     protected void updateChildren() {
 251         final Labeled labeled = getSkinnable();
 252         // Only in some situations do we want to have the graphicPropertyChangedListener
 253         // installed. Since updateChildren() is not called much, we&#39;ll just remove it always
 254         // and reinstall it later if it is necessary to do so.
 255         if (graphic != null) {
 256             graphic.layoutBoundsProperty().removeListener(graphicPropertyChangedListener);
 257         }
 258         // Now update the graphic (since it may have changed)
 259         graphic = labeled.getGraphic();
 260 
 261         // RT-19851 Only setMouseTransparent(true) for an ImageView.  This allows the button
 262         // to be picked regardless of the changing images on top of it.
 263         if (graphic instanceof ImageView) {
 264             graphic.setMouseTransparent(true);
 265         }
 266 
 267         // Now update the children (and add the graphicPropertyChangedListener as necessary)
 268         if (isIgnoreGraphic()) {
 269             if (labeled.getContentDisplay() == ContentDisplay.GRAPHIC_ONLY) {
 270                 getChildren().clear();
 271             } else {
 272                 getChildren().setAll(text);
 273             }
 274         } else {
 275             graphic.layoutBoundsProperty().addListener(graphicPropertyChangedListener);
 276             if (isIgnoreText()) {
 277                 getChildren().setAll(graphic);
 278             } else {
 279                 getChildren().setAll(graphic, text);
 280             }
 281         }
 282     }
 283 
 284     /**
 285      * Compute and return the minimum width of this Labeled. The minimum width is
 286      * the smaller of the width of &quot;...&quot; and the width with the actual text.
 287      * In this way, if the text width itself is smaller than the ellipsis then
 288      * we should use that as the min width, otherwise the ellipsis needs to be the
 289      * min width.
 290      * &lt;p&gt;
 291      * We use the same calculation here regardless of whether we are talking
 292      * about a single or multiline labeled. So a multiline labeled may find that
 293      * the width of the &quot;...&quot; is as small as it will ever get.
 294      */
 295     @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
 296         return computeMinLabeledPartWidth(height, topInset, rightInset, bottomInset, leftInset);
 297     }
 298 
 299     /** {@inheritDoc} */
 300     @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
 301         return computeMinLabeledPartHeight(width, topInset, rightInset, bottomInset, leftInset);
 302     }
 303 
 304     /** {@inheritDoc} */
 305     @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
 306         // Get the preferred width of the text
 307         final Labeled labeled = getSkinnable();
 308         final Font font = text.getFont();
 309         String string = labeled.getText();
 310         boolean emptyText = string == null || string.isEmpty();
 311         double widthPadding = leftInset + rightInset;
 312 
 313         if (!isIgnoreText()) {
 314             widthPadding += leftLabelPadding() + rightLabelPadding();
 315         }
 316 
 317         double textWidth = 0.0;
 318         if (!emptyText) {
 319             if (labeled.isMnemonicParsing()) {
 320                 if (string.contains(&quot;_&quot;) &amp;&amp; (string.indexOf(&quot;_&quot;) != string.length()-1)) {
 321                     string = string.replaceFirst(&quot;_&quot;, &quot;&quot;);
 322                 }
 323             }
 324             textWidth = Utils.computeTextWidth(font, string, 0);
 325         }
 326 
 327         // Fix for RT-39889
 328         double graphicWidth = graphic == null ? 0.0 :
 329                 Utils.boundedSize(graphic.prefWidth(-1), graphic.minWidth(-1), graphic.maxWidth(-1));
 330 
 331         // Now add on the graphic, gap, and padding as appropriate
 332         if (isIgnoreGraphic()) {
 333             return textWidth + widthPadding;
 334         } else if (isIgnoreText()) {
 335             return graphicWidth + widthPadding;
 336         } else if (labeled.getContentDisplay() == ContentDisplay.LEFT
 337                 || labeled.getContentDisplay() == ContentDisplay.RIGHT) {
 338             return textWidth + labeled.getGraphicTextGap() + graphicWidth + widthPadding;
 339         } else {
 340             return Math.max(textWidth, graphicWidth) + widthPadding;
 341         }
 342     }
 343 
 344     /** {@inheritDoc} */
 345     @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
 346         final Labeled labeled = getSkinnable();
 347         final Font font = text.getFont();
 348         final ContentDisplay contentDisplay = labeled.getContentDisplay();
 349         final double gap = labeled.getGraphicTextGap();
 350 
 351         width -= leftInset + rightInset;
 352 
 353         if (!isIgnoreText()) {
 354             width -= leftLabelPadding() + rightLabelPadding();
 355         }
 356 
 357         String str = labeled.getText();
 358         if (str != null &amp;&amp; str.endsWith(&quot;\n&quot;)) {
 359             // Strip ending newline so we don&#39;t count another row.
 360             str = str.substring(0, str.length() - 1);
 361         }
 362 
 363         double textWidth = width;
 364         if (!isIgnoreGraphic() &amp;&amp;
 365                 (contentDisplay == LEFT || contentDisplay == RIGHT)) {
 366             textWidth -= (graphic.prefWidth(-1) + gap);
 367         }
 368 
 369         // TODO figure out how to cache this effectively.
 370         final double textHeight = Utils.computeTextHeight(font, str,
 371                 labeled.isWrapText() ? textWidth : 0,
 372                 labeled.getLineSpacing(), text.getBoundsType());
 373 
 374         // Now we want to add on the graphic if necessary!
 375         double h = textHeight;
 376         if (!isIgnoreGraphic()) {
 377             final Node graphic = labeled.getGraphic();
 378             if (contentDisplay == TOP || contentDisplay == BOTTOM) {
 379                 h = graphic.prefHeight(width) + gap + textHeight;
 380             } else {
 381                 h = Math.max(textHeight, graphic.prefHeight(width));
 382             }
 383         }
 384 
 385         double padding = topInset + bottomInset;
 386 
 387         if (!isIgnoreText()) {
 388             padding += topLabelPadding() + bottomLabelPadding();
 389         }
 390 
 391         return  h + padding;
 392     }
 393 
 394     /** {@inheritDoc} */
 395     @Override protected double computeMaxWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
 396         return getSkinnable().prefWidth(height);
 397     }
 398 
 399     /** {@inheritDoc} */
 400     @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
 401         return getSkinnable().prefHeight(width);
 402     }
 403 
 404     /** {@inheritDoc} */
 405     @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
 406         double textBaselineOffset = text.getBaselineOffset();
 407         double h = textBaselineOffset;
 408         final Labeled labeled = getSkinnable();
 409         final Node g = labeled.getGraphic();
 410         if (!isIgnoreGraphic()) {
 411             ContentDisplay contentDisplay = labeled.getContentDisplay();
 412             if (contentDisplay == ContentDisplay.TOP) {
 413                 h = g.prefHeight(-1) + labeled.getGraphicTextGap() + textBaselineOffset;
 414             } else if (contentDisplay == ContentDisplay.LEFT || contentDisplay == RIGHT) {
 415                 h = textBaselineOffset + (g.prefHeight(-1) - text.prefHeight(-1)) / 2;
 416             }
 417         }
 418 
 419         double offset = topInset + h;
 420         if (!isIgnoreText()) {
 421             offset += topLabelPadding();
 422         }
 423         return offset;
 424     }
 425 
 426     /**
 427      * The Layout algorithm works like this:
 428      *
 429      *  - Get the labeled w/h, graphic w/h, text w/h
 430      *  - Compute content w/h based on graphicVPos, graphicHPos,
 431      *    graphicTextGap, and graphic w/h and text w/h
 432      *  - (Note that the text content has been pre-truncated where
 433      *    necessary)
 434      *  - compute content x/y based on content w/h and labeled w/h
 435      *    and the labeled&#39;s hpos and vpos
 436      *  - position the graphic and text
 437      */
 438     @Override protected void layoutChildren(final double x, final double y,
 439                                             final double w, final double h) {
 440         layoutLabelInArea(x, y, w, h);
 441     }
 442 
 443     /**
 444      * Performs the actual layout of the label content within the area given.
 445      * This method is called by subclasses that override layoutChildren().
 446      *
 447      * @param x The x position of the label part of the control, inside padding
 448      *
 449      * @param y The y position of the label part of the control, inside padding
 450      *
 451      * @param w The width of the label part of the control, not including padding
 452      *
 453      * @param h The height of the label part of the control, not including padding
 454      */
 455     protected void layoutLabelInArea(double x, double y, double w, double h) {
 456         layoutLabelInArea(x, y, w, h, null);
 457     }
 458 
 459     /**
 460      * Performs the actual layout of the label content within the area given.
 461      * This method is called by subclasses that override layoutChildren().
 462      *
 463      * @param x The x position of the label part of the control, inside padding
 464      *
 465      * @param y The y position of the label part of the control, inside padding
 466      *
 467      * @param w The width of the label part of the control, not including padding
 468      *
 469      * @param h The height of the label part of the control, not including padding
 470      *
 471      * @param alignment The alignment of the label part of the control within the given area. If null, then the control&#39;s alignment will be used.
 472      */
 473     protected void layoutLabelInArea(double x, double y, double w, double h, Pos alignment) {
 474         // References to essential labeled state
 475         final Labeled labeled = getSkinnable();
 476         final ContentDisplay contentDisplay = labeled.getContentDisplay();
 477 
 478         if (alignment == null) {
 479             alignment = labeled.getAlignment();
 480         }
 481 
 482         final HPos hpos = alignment == null ? HPos.LEFT   : alignment.getHpos();
 483         final VPos vpos = alignment == null ? VPos.CENTER : alignment.getVpos();
 484 
 485         // Figure out whether we should ignore the Graphic, and/or
 486         // ignore the Text
 487         final boolean ignoreGraphic = isIgnoreGraphic();
 488         final boolean ignoreText = isIgnoreText();
 489 
 490         if (!ignoreText) {
 491             x += leftLabelPadding();
 492             y += topLabelPadding();
 493             w -= leftLabelPadding() + rightLabelPadding();
 494             h -= topLabelPadding() + bottomLabelPadding();
 495         }
 496 
 497         // Compute some standard useful numbers for the graphic, text, and gap
 498         double graphicWidth;
 499         double graphicHeight;
 500         double textWidth;
 501         double textHeight;
 502 
 503         if (ignoreGraphic) {
 504             graphicWidth = graphicHeight = 0;
 505         } else if (ignoreText) {
 506             if (graphic.isResizable()) {
 507                 Orientation contentBias = graphic.getContentBias();
 508                 if (contentBias == Orientation.HORIZONTAL) {
 509                     graphicWidth  = Utils.boundedSize(w, graphic.minWidth(-1), graphic.maxWidth(-1));
 510                     graphicHeight = Utils.boundedSize(h, graphic.minHeight(graphicWidth), graphic.maxHeight(graphicWidth));
 511                 } else if (contentBias == Orientation.VERTICAL) {
 512                     graphicHeight = Utils.boundedSize(h, graphic.minHeight(-1), graphic.maxHeight(-1));
 513                     graphicWidth  = Utils.boundedSize(w, graphic.minWidth(graphicHeight), graphic.maxWidth(graphicHeight));
 514                 } else {
 515                     graphicWidth  = Utils.boundedSize(w, graphic.minWidth(-1), graphic.maxWidth(-1));
 516                     graphicHeight = Utils.boundedSize(h, graphic.minHeight(-1), graphic.maxHeight(-1));
 517                 }
 518                 graphic.resize(graphicWidth, graphicHeight);
 519             } else {
 520                 graphicWidth = graphic.getLayoutBounds().getWidth();
 521                 graphicHeight = graphic.getLayoutBounds().getHeight();
 522             }
 523         } else {
 524             graphic.autosize(); // We have to do this before getting metrics
 525             graphicWidth = graphic.getLayoutBounds().getWidth();
 526             graphicHeight = graphic.getLayoutBounds().getHeight();
 527         }
 528 
 529         if (ignoreText) {
 530             textWidth  = textHeight = 0;
 531             text.setText(&quot;&quot;);
 532         } else {
 533             updateDisplayedText(w, h); // Have to do this just in case it needs to be recomputed
 534             textWidth  = snapSizeX(Math.min(text.getLayoutBounds().getWidth(),  wrapWidth));
 535             textHeight = snapSizeY(Math.min(text.getLayoutBounds().getHeight(), wrapHeight));
 536         }
 537 
 538         final double gap = (ignoreText || ignoreGraphic) ? 0 : labeled.getGraphicTextGap();
 539 
 540         // Figure out the contentWidth and contentHeight. This is the width
 541         // and height of the Labeled and Graphic together, not the available
 542         // content area (which would be a different calculation).
 543         double contentWidth = Math.max(graphicWidth, textWidth);
 544         double contentHeight = Math.max(graphicHeight, textHeight);
 545         if (contentDisplay == ContentDisplay.TOP || contentDisplay == ContentDisplay.BOTTOM) {
 546             contentHeight = graphicHeight + gap + textHeight;
 547         } else if (contentDisplay == ContentDisplay.LEFT || contentDisplay == ContentDisplay.RIGHT) {
 548             contentWidth = graphicWidth + gap + textWidth;
 549         }
 550 
 551         // Now we want to compute the x/y location to place the content at.
 552 
 553         // Compute the contentX position based on hpos and the space available
 554         double contentX;
 555         if (hpos == HPos.LEFT) {
 556             contentX = x;
 557         } else if (hpos == HPos.RIGHT) {
 558             contentX = x + (w - contentWidth);
 559         } else {
 560             // TODO Baseline may not be handled correctly
 561             // may have been CENTER or null, treat as center
 562             contentX = (x + ((w - contentWidth) / 2.0));
 563         }
 564 
 565         // Compute the contentY position based on vpos and the space available
 566         double contentY;
 567         if (vpos == VPos.TOP) {
 568             contentY = y;
 569         } else if (vpos == VPos.BOTTOM) {
 570             contentY = (y + (h - contentHeight));
 571         } else {
 572             // TODO Baseline may not be handled correctly
 573             // may have been CENTER, BASELINE, or null, treat as center
 574             contentY = (y + ((h - contentHeight) / 2.0));
 575         }
 576 
 577         Point2D mnemonicPos = null;
 578         double mnemonicWidth = 0.0;
 579         double mnemonicHeight = 0.0;
 580         if (containsMnemonic) {
 581             final Font font = text.getFont();
 582             String preSt = bindings.getText();
 583             boolean isRTL = (labeledNode.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT);
 584             mnemonicPos = Utils.computeMnemonicPosition(font, preSt, bindings.getMnemonicIndex(), this.wrapWidth, labeled.getLineSpacing(), isRTL);
 585             mnemonicWidth = Utils.computeTextWidth(font, preSt.substring(bindings.getMnemonicIndex(), bindings.getMnemonicIndex() + 1), 0);
 586             mnemonicHeight = Utils.computeTextHeight(font, &quot;_&quot;, 0, text.getBoundsType());
 587         }
 588 
 589 
 590         // Now to position the graphic and text. At this point I know the
 591         // contentX and contentY locations (including the padding and whatnot
 592         // that was defined on the Labeled). I also know the content width and
 593         // height. So now I just need to lay out the graphic and text within
 594         // that content x/y/w/h area.
 595         if ((!ignoreGraphic || !ignoreText) &amp;&amp; !text.isManaged()) {
 596             text.setManaged(true);
 597         }
 598 
 599         if (ignoreGraphic &amp;&amp; ignoreText) {
 600             // There might be a text node as a child, or a graphic node as
 601             // a child. However we don&#39;t have to do anything for the graphic
 602             // node because the only way it can be a child and still have
 603             // ignoreGraphic true is if it is unmanaged. Text however might
 604             // be a child but still not matter, in which case we will just
 605             // stop managing it (although really I wish it just wasn&#39;t here
 606             // all all in that case)
 607             if (text.isManaged()) {
 608                 text.setManaged(false);
 609             }
 610             text.relocate(snapPositionX(contentX), snapPositionY(contentY));
 611         } else if (ignoreGraphic) {
 612             // Since I only have to position the text, it goes at the
 613             // contentX/contentY location. Note that positionNode will
 614             // adjust the text based on the text&#39;s minX/minY so no need to
 615             // worry about that here
 616             text.relocate(snapPositionX(contentX), snapPositionY(contentY));
 617             if (containsMnemonic &amp;&amp; (mnemonicPos != null)) {
 618                 mnemonic_underscore.setEndX(mnemonicWidth-2.0);
 619                 mnemonic_underscore.relocate(snapPositionX(contentX + mnemonicPos.getX()),
 620                                              snapPositionY(contentY + mnemonicPos.getY()));
 621             }
 622 
 623         } else if (ignoreText) {
 624             // there isn&#39;t text to display, so we need to position it
 625             // such that it doesn&#39;t affect the content area (although when
 626             // there is a graphic, the text isn&#39;t even in the scene)
 627             text.relocate(snapPositionX(contentX), snapPositionY(contentY));
 628             graphic.relocate(snapPositionX(contentX), snapPositionY(contentY));
 629             if (containsMnemonic &amp;&amp; (mnemonicPos != null)) {
 630                 mnemonic_underscore.setEndX(mnemonicWidth);
 631                 mnemonic_underscore.setStrokeWidth(mnemonicHeight/10.0);
 632                 mnemonic_underscore.relocate(snapPositionX(contentX + mnemonicPos.getX()),
 633                                              snapPositionY(contentY + mnemonicPos.getY()));
 634             }
 635         } else {
 636             // There is both text and a graphic, so I need to position them
 637             // relative to each other
 638             double graphicX = 0;
 639             double graphicY = 0;
 640             double textX = 0;
 641             double textY = 0;
 642 
 643             if (contentDisplay == ContentDisplay.TOP) {
 644                 graphicX = contentX + ((contentWidth - graphicWidth) / 2.0);
 645                 textX = contentX + ((contentWidth - textWidth) / 2.0);
 646                 // The graphic is above the text, so it is positioned at
 647                 // graphicY and the text below it.
 648                 graphicY = contentY;
 649                 textY = graphicY + graphicHeight + gap;
 650             } else if (contentDisplay == ContentDisplay.RIGHT) {
 651                 // The graphic is to the right of the text
 652                 textX = contentX;
 653                 graphicX = textX + textWidth + gap;
 654                 graphicY = contentY + ((contentHeight - graphicHeight) / 2.0);
 655                 textY = contentY + ((contentHeight - textHeight) / 2.0);
 656             } else if (contentDisplay == ContentDisplay.BOTTOM) {
 657                 graphicX = contentX + ((contentWidth - graphicWidth) / 2.0);
 658                 textX = contentX + ((contentWidth - textWidth) / 2.0);
 659                 // The graphic is below the text
 660                 textY = contentY;
 661                 graphicY = textY + textHeight + gap;
 662             } else if (contentDisplay == ContentDisplay.LEFT) {
 663                 // The graphic is to the left of the text, so the graphicX is
 664                 // simply the contentX and the textX is to the right of it.
 665                 graphicX = contentX;
 666                 textX = graphicX + graphicWidth + gap;
 667                 graphicY = contentY + ((contentHeight - graphicHeight) / 2.0);
 668                 textY = contentY + ((contentHeight - textHeight) / 2.0);
 669             } else if (contentDisplay == ContentDisplay.CENTER) {
 670                 graphicX = contentX + ((contentWidth - graphicWidth) / 2.0);
 671                 textX = contentX + ((contentWidth - textWidth) / 2.0);
 672                 graphicY = contentY + ((contentHeight - graphicHeight) / 2.0);
 673                 textY = contentY + ((contentHeight - textHeight) / 2.0);
 674             }
 675             text.relocate(snapPositionX(textX), snapPositionY(textY));
 676             if (containsMnemonic &amp;&amp; (mnemonicPos != null)) {
 677                 mnemonic_underscore.setEndX(mnemonicWidth);
 678                 mnemonic_underscore.setStrokeWidth(mnemonicHeight/10.0);
 679                 mnemonic_underscore.relocate(snapPositionX(textX + mnemonicPos.getX()),
 680                                              snapPositionY(textY + mnemonicPos.getY()));
 681             }
 682             graphic.relocate(snapPositionX(graphicX), snapPositionY(graphicY));
 683         }
 684 
 685         /**
 686          * check if the label text overflows it&#39;s bounds.
 687          * If there&#39;s an overflow, and no text clip then
 688          * we&#39;ll clip it.
 689          * If there is no overflow, and the label text has a
 690          * clip, then remove it.
 691          */
 692         if ((text != null) &amp;&amp;
 693                 ((text.getLayoutBounds().getHeight() &gt; wrapHeight) ||
 694                         (text.getLayoutBounds().getWidth() &gt; wrapWidth))) {
 695 
 696             if (textClip == null) {
 697                 textClip = new Rectangle();
 698             }
 699 
 700             if (labeled.getEffectiveNodeOrientation() == NodeOrientation.LEFT_TO_RIGHT) {
 701                 textClip.setX(text.getLayoutBounds().getMinX());
 702             } else {
 703                 textClip.setX(text.getLayoutBounds().getMaxX() - wrapWidth);
 704             }
 705             textClip.setY(text.getLayoutBounds().getMinY());
 706             textClip.setWidth(wrapWidth);
 707             textClip.setHeight(wrapHeight);
 708             if (text.getClip() == null) {
 709                 text.setClip(textClip);
 710             }
 711         }
 712         else {
 713             /**
 714              * content fits inside bounds, no need
 715              * for a clip
 716              */
 717             if (text.getClip() != null) {
 718                 text.setClip(null);
 719             }
 720         }
 721     }
 722 
 723     /** {@inheritDoc} */
 724     @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
 725         switch (attribute) {
 726             case TEXT: {
 727                 Labeled labeled = getSkinnable();
 728                 String accText = labeled.getAccessibleText();
 729                 if (accText != null &amp;&amp; !accText.isEmpty()) return accText;
 730 
 731                 /* Use the text in the binding if available to handle mnemonics */
 732                 if (bindings != null) {
 733                     String text = bindings.getText();
 734                     if (text != null &amp;&amp; !text.isEmpty()) return text;
 735                 }
 736                 /* Avoid the content in text.getText() as it can contain ellipses
 737                  * for clipping
 738                  */
 739                 String text = labeled.getText();
 740                 if (text != null &amp;&amp; !text.isEmpty()) return text;
 741 
 742                 /* Use the graphic as last resource. Note that this implementation
 743                  * does not attempt to combine the label and graphics if both
 744                  * are being displayed
 745                  */
 746                 if (graphic != null) {
 747                     Object result = graphic.queryAccessibleAttribute(AccessibleAttribute.TEXT);
 748                     if (result != null) return result;
 749                 }
 750                 return null;
 751             }
 752             case MNEMONIC: {
 753                 if (bindings != null) {
 754                     return bindings.getMnemonic();
 755                 }
 756                 return null;
 757             }
 758             default: return super.queryAccessibleAttribute(attribute, parameters);
 759         }
 760     }
 761 
 762 
 763 
 764     /***************************************************************************
 765      *                                                                         *
 766      * Private implementation                                                  *
 767      *                                                                         *
 768      **************************************************************************/
 769 
 770     private double computeMinLabeledPartWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
 771         // First compute the minTextWidth by checking the width of the string
 772         // made by the ellipsis &quot;...&quot;, and then by checking the width of the
 773         // string made up by labeled.text. We want the smaller of the two.
 774         final Labeled labeled = getSkinnable();
 775         final ContentDisplay contentDisplay = labeled.getContentDisplay();
 776         final double gap = labeled.getGraphicTextGap();
 777         double minTextWidth = 0;
 778 
 779         final Font font = text.getFont();
 780         OverrunStyle truncationStyle = labeled.getTextOverrun();
 781         String ellipsisString = labeled.getEllipsisString();
 782         final String string = labeled.getText();
 783         final boolean emptyText = string == null || string.isEmpty();
 784 
 785         if (!emptyText) {
 786             // We only want to recompute the full text width if the font or text changed
 787             if (truncationStyle == CLIP) {
 788                 if (textWidth == Double.NEGATIVE_INFINITY) {
 789                     // Show at minimum the first character
 790                     textWidth = Utils.computeTextWidth(font, string.substring(0, 1), 0);
 791                 }
 792                 minTextWidth = textWidth;
 793             } else {
 794                 if (textWidth == Double.NEGATIVE_INFINITY) {
 795                     textWidth = Utils.computeTextWidth(font, string, 0);
 796                 }
 797                 // We only want to recompute the ellipsis width if the font has changed
 798                 if (ellipsisWidth == Double.NEGATIVE_INFINITY) {
 799                     ellipsisWidth = Utils.computeTextWidth(font, ellipsisString, 0);
 800                 }
 801                 minTextWidth = Math.min(textWidth, ellipsisWidth);
 802             }
 803         }
 804 
 805         // Now inspect the graphic and the hpos to determine the the minWidth
 806         final Node graphic = labeled.getGraphic();
 807         double width;
 808         if (isIgnoreGraphic()) {
 809             width = minTextWidth;
 810         } else if (isIgnoreText()) {
 811             width = graphic.minWidth(-1);
 812         } else if (contentDisplay == LEFT || contentDisplay == RIGHT){
 813             width = (minTextWidth + graphic.minWidth(-1) + gap);
 814         } else {
 815             width = Math.max(minTextWidth, graphic.minWidth(-1));
 816         }
 817 
 818         double padding = leftInset + rightInset;
 819         if (!isIgnoreText()) {
 820             padding += leftLabelPadding() + rightLabelPadding();
 821         }
 822 
 823         return width + padding;
 824     }
 825 
 826     private double computeMinLabeledPartHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
 827         final Labeled labeled = getSkinnable();
 828         final Font font = text.getFont();
 829 
 830         String str = labeled.getText();
 831         if (str != null &amp;&amp; str.length() &gt; 0) {
 832             int newlineIndex = str.indexOf(&#39;\n&#39;);
 833             if (newlineIndex &gt;= 0) {
 834                 str = str.substring(0, newlineIndex);
 835             }
 836         }
 837 
 838         // TODO figure out how to cache this effectively.
 839         // Base minimum height on one line (ignoring wrapping here).
 840         double s = labeled.getLineSpacing();
 841         final double textHeight = Utils.computeTextHeight(font, str, 0, s, text.getBoundsType());
 842 
 843         double h = textHeight;
 844 
 845         // Now we want to add on the graphic if necessary!
 846         if (!isIgnoreGraphic()) {
 847             final Node graphic = labeled.getGraphic();
 848             if (labeled.getContentDisplay() == ContentDisplay.TOP
 849                     || labeled.getContentDisplay() == ContentDisplay.BOTTOM) {
 850                 h = graphic.minHeight(width) + labeled.getGraphicTextGap() + textHeight;
 851             } else {
 852                 h = Math.max(textHeight, graphic.minHeight(width));
 853             }
 854         }
 855 
 856         double padding = topInset + bottomInset;
 857         if (!isIgnoreText()) {
 858             padding += topLabelPadding() - bottomLabelPadding();
 859         }
 860         return h + padding;
 861     }
 862 
 863     double topLabelPadding() {
 864         return snapSizeY(getSkinnable().getLabelPadding().getTop());
 865     }
 866 
 867     double bottomLabelPadding() {
 868         return snapSizeY(getSkinnable().getLabelPadding().getBottom());
 869     }
 870 
 871     double leftLabelPadding() {
 872         return snapSizeX(getSkinnable().getLabelPadding().getLeft());
 873     }
 874 
 875     double rightLabelPadding() {
 876         return snapSizeX(getSkinnable().getLabelPadding().getRight());
 877     }
 878 
 879 
 880     /**
 881      * Called whenever some state has changed that affects the text metrics.
 882      * Changes here will involve invalidating the display text so the next
 883      * call to updateDisplayedText computes a new value, and call requestLayout.
 884      */
 885     private void textMetricsChanged() {
 886         invalidText = true;
 887         getSkinnable().requestLayout();
 888     }
 889 
 890     /*
 891     ** The Label is a mnemonic, and it&#39;s target node
 892     ** has changed, but it&#39;s label hasn&#39;t so just
 893     ** swap them over, and tidy up.
 894     */
 895     void mnemonicTargetChanged() {
 896         if (containsMnemonic == true) {
 897             /*
 898             ** was there previously a labelFor
 899             */
 900             removeMnemonic();
 901 
 902             /*
 903             ** is there a new labelFor
 904             */
 905             Control control = getSkinnable();
 906             if (control instanceof Label) {
 907                 labeledNode = ((Label)control).getLabelFor();
 908                 addMnemonic();
 909             }
 910             else {
 911                 labeledNode = null;
 912             }
 913         }
 914     }
 915 
 916     private void sceneChanged() {
 917         final Labeled labeled = getSkinnable();
 918         Scene scene = labeled.getScene();
 919 
 920         if (scene != null &amp;&amp; containsMnemonic) {
 921             addMnemonic();
 922         }
 923 
 924     }
 925 
 926     /**
 927      * Marks minWidth as being invalid and in need of recomputation.
 928      */
 929     private void invalidateWidths() {
 930         textWidth = Double.NEGATIVE_INFINITY;
 931     }
 932 
 933     /**
 934      * Updates the content of the underlying Text node. This method should
 935      * only be called when necessary. If the invalidText flag is not set, then
 936      * the method is a no-op. This care is taken because recomputing the
 937      * text to display is an expensive operation. Package private ONLY FOR THE
 938      * SAKE OF TESTING.
 939      */
 940     void updateDisplayedText() {
 941         updateDisplayedText(-1, -1);
 942     }
 943 
 944     private void updateDisplayedText(double w, double h) {
 945         if (invalidText) {
 946             final Labeled labeled = getSkinnable();
 947             String s = labeled.getText();
 948 
 949             int mnemonicIndex = -1;
 950 
 951             /*
 952             ** if there&#39;s a valid string then parse it
 953             */
 954             if (s != null &amp;&amp; s.length() &gt; 0) {
 955                 bindings = new TextBinding(s);
 956 
 957                 if (!com.sun.javafx.PlatformUtil.isMac() &amp;&amp; getSkinnable().isMnemonicParsing() == true) {
 958                     /*
 959                     ** the Labeled has a MnemonicParsing property,
 960                     ** if set true, then auto-parsing will check for
 961                     ** a mnemonic
 962                     */
 963                     if (labeled instanceof Label) {
 964                         // buttons etc
 965                         labeledNode = ((Label)labeled).getLabelFor();
 966                     } else {
 967                         labeledNode = labeled;
 968                     }
 969 
 970                     if (labeledNode == null) {
 971                         labeledNode = labeled;
 972                     }
 973                     mnemonicIndex = bindings.getMnemonicIndex() ;
 974                 }
 975             }
 976 
 977             /*
 978             ** we were previously a mnemonic
 979             */
 980             if (containsMnemonic) {
 981                 /*
 982                 ** are we no longer a mnemonic, or have we changed code?
 983                 */
 984                 if (mnemonicScene != null) {
 985                     if (mnemonicIndex == -1 ||
 986                             (bindings != null &amp;&amp; !bindings.getMnemonicKeyCombination().equals(mnemonicCode))) {
 987                         removeMnemonic();
 988                         containsMnemonic = false;
 989                     }
 990                 }
 991             }
 992             else {
 993                 /*
 994                 ** this can happen if mnemonic parsing is
 995                 ** disabled on a previously valid mnemonic
 996                 */
 997                 removeMnemonic();
 998             }
 999 
1000             /*
1001             ** check we have a labeled
1002             */
1003             if (s != null &amp;&amp; s.length() &gt; 0) {
1004                 if (mnemonicIndex &gt;= 0 &amp;&amp; containsMnemonic == false) {
1005                     containsMnemonic = true;
1006                     mnemonicCode = bindings.getMnemonicKeyCombination();
1007                     addMnemonic();
1008                 }
1009             }
1010 
1011             if (containsMnemonic == true) {
1012                 s = bindings.getText();
1013                 if (mnemonic_underscore == null) {
1014                     mnemonic_underscore = new Line();
1015                     mnemonic_underscore.setStartX(0.0f);
1016                     mnemonic_underscore.setStartY(0.0f);
1017                     mnemonic_underscore.setEndY(0.0f);
1018                     mnemonic_underscore.getStyleClass().clear();
1019                     mnemonic_underscore.getStyleClass().setAll(&quot;mnemonic-underline&quot;);
1020                 }
1021                 if (!getChildren().contains(mnemonic_underscore)) {
1022                     getChildren().add(mnemonic_underscore);
1023                 }
1024             } else {
1025                 /*
1026                 ** we don&#39;t need a mnemonic....
1027                 */
1028                 if (getSkinnable().isMnemonicParsing() == true &amp;&amp; com.sun.javafx.PlatformUtil.isMac() &amp;&amp; bindings != null) {
1029                     s = bindings.getText();
1030                 }
1031                 else {
1032                     s = labeled.getText();
1033                 }
1034                 if (mnemonic_underscore != null) {
1035                     if (getChildren().contains(mnemonic_underscore)) {
1036                         Platform.runLater(() -&gt; {
1037                               getChildren().remove(mnemonic_underscore);
1038                               mnemonic_underscore = null;
1039                         });
1040                     }
1041                 }
1042             }
1043 
1044             int len = s != null ? s.length() : 0;
1045             boolean multiline = false;
1046 
1047             if (s != null &amp;&amp; len &gt; 0) {
1048                 int i = s.indexOf(&#39;\n&#39;);
1049                 if (i &gt; -1 &amp;&amp; i &lt; len - 1) {
1050                     // Multiline text with embedded newlines - not
1051                     // taking into account a potential trailing newline.
1052                     multiline = true;
1053                 }
1054             }
1055 
1056             String result;
1057             boolean horizontalPosition =
1058                     (labeled.getContentDisplay() == ContentDisplay.LEFT ||
1059                     labeled.getContentDisplay() == ContentDisplay.RIGHT);
1060 
1061             double availableWidth = labeled.getWidth() -
1062                     snappedLeftInset() - snappedRightInset();
1063 
1064             if (!isIgnoreText()) {
1065                 availableWidth -= leftLabelPadding() + rightLabelPadding();
1066             }
1067             availableWidth = Math.max(availableWidth, 0);
1068 
1069             if (w == -1) {
1070                 w = availableWidth;
1071             }
1072             double minW = Math.min(computeMinLabeledPartWidth(-1, snappedTopInset() , snappedRightInset(), snappedBottomInset(), snappedLeftInset()), availableWidth);
1073             if (horizontalPosition &amp;&amp; !isIgnoreGraphic()) {
1074                 double graphicW = (labeled.getGraphic().getLayoutBounds().getWidth() + labeled.getGraphicTextGap());
1075                 w -= graphicW;
1076                 minW -= graphicW;
1077             }
1078             wrapWidth = Math.max(minW, w);
1079 
1080             boolean verticalPosition =
1081                     (labeled.getContentDisplay() == ContentDisplay.TOP ||
1082                     labeled.getContentDisplay() == ContentDisplay.BOTTOM);
1083 
1084             double availableHeight = labeled.getHeight() -
1085                     snappedTopInset() - snappedBottomInset();
1086 
1087             if (!isIgnoreText()) {
1088                 availableHeight -= topLabelPadding() + bottomLabelPadding();
1089             }
1090             availableHeight = Math.max(availableHeight, 0);
1091 
1092             if (h == -1) {
1093                 h = availableHeight;
1094             }
1095             double minH = Math.min(computeMinLabeledPartHeight(wrapWidth, snappedTopInset() , snappedRightInset(), snappedBottomInset(), snappedLeftInset()), availableHeight);
1096             if (verticalPosition &amp;&amp; labeled.getGraphic() != null) {
1097                 double graphicH = labeled.getGraphic().getLayoutBounds().getHeight() + labeled.getGraphicTextGap();
1098                 h -= graphicH;
1099                 minH -= graphicH;
1100             }
1101             wrapHeight = Math.max(minH, h);
1102 
1103             updateWrappingWidth();
1104 
1105             Font font = text.getFont();
1106             OverrunStyle truncationStyle = labeled.getTextOverrun();
1107             String ellipsisString = labeled.getEllipsisString();
1108 
1109             if (labeled.isWrapText()) {
<a name="1" id="anc1"></a><span class="line-modified">1110                 result = Utils.computeClippedWrappedText(font, s, wrapWidth, wrapHeight, labeled.getLineSpacing(), truncationStyle, ellipsisString, text.getBoundsType());</span>
1111             } else if (multiline) {
1112                 StringBuilder sb = new StringBuilder();
1113 
1114                 String[] splits = s.split(&quot;\n&quot;);
1115                 for (int i = 0; i &lt; splits.length; i++) {
1116                     sb.append(Utils.computeClippedText(font, splits[i], wrapWidth, truncationStyle, ellipsisString));
1117                     if (i &lt; splits.length - 1) {
1118                         sb.append(&#39;\n&#39;);
1119                     }
1120                 }
1121 
1122                 // TODO: Consider what to do in the case where vertical space is
1123                 // limited and the last visible line isn&#39;t already truncated
1124                 // with a trailing ellipsis. What if the style calls for leading
1125                 // or center ellipses? We could possibly add an additional
1126                 // trailing ellipsis to the last visible line, like this:
1127 
1128                 // +--------------------------------+
1129                 // |  This is some long text with multiple lines\n
1130                 // |  where more than one exceed the|width\n
1131                 // |  and wrapText is false, and all|lines\n
1132                 // +--don&#39;t fit.--------------------+
1133                 //
1134                 // +--------------------------------+
1135                 // |  This is some...multiple lines |
1136                 // |  where more t...ceed the width |
1137                 // |  and wrapText...d all lines... |
1138                 // +--------------------------------+
1139 
1140                 result = sb.toString();
1141             } else {
1142                 result = Utils.computeClippedText(font, s, wrapWidth, truncationStyle, ellipsisString);
1143             }
1144 
1145             if (result != null &amp;&amp; result.endsWith(&quot;\n&quot;)) {
1146                 // Strip ending newline so we don&#39;t display another row.
1147                 result = result.substring(0, result.length() - 1);
1148             }
1149 
1150             text.setText(result);
1151             updateWrappingWidth();
1152             invalidText = false;
1153         }
1154     }
1155 
1156     private void addMnemonic() {
1157         if (labeledNode != null) {
1158             mnemonicScene = labeledNode.getScene();
1159             if (mnemonicScene != null) {
1160                 mnemonicScene.addMnemonic(new Mnemonic(labeledNode, mnemonicCode));
1161             }
1162         }
1163     }
1164 
1165 
1166     private void removeMnemonic() {
1167         if (mnemonicScene != null &amp;&amp; labeledNode != null) {
1168             mnemonicScene.removeMnemonic(new Mnemonic(labeledNode, mnemonicCode));
1169             mnemonicScene = null;
1170         }
1171     }
1172 
1173     /**
1174      * Updates the wrapping width of the text node. Although changing the font
1175      * does affect the metrics used for text layout, this method does not
1176      * call requestLayout or invalidate the text, since it may be called
1177      * from the constructor and such work would be duplicative and wasted.
1178      */
1179     private void updateWrappingWidth() {
1180         final Labeled labeled = getSkinnable();
1181         text.setWrappingWidth(0);
1182         if (labeled.isWrapText()) {
1183             // Note that the wrapping width needs to be set to zero before
1184             // getting the text&#39;s real preferred width.
1185             double w = Math.min(text.prefWidth(-1), wrapWidth);
1186             text.setWrappingWidth(w);
1187         }
1188     }
1189 
1190     /**
1191      * Gets whether for various computations we can ignore the presence of the graphic
1192      * (or lack thereof).
1193      * @return
1194      */
1195     boolean isIgnoreGraphic() {
1196         return (graphic == null ||
1197                 !graphic.isManaged() ||
1198                 getSkinnable().getContentDisplay() == ContentDisplay.TEXT_ONLY);
1199     }
1200 
1201     /**
1202      * Gets whether for various computations we can ignore the presence of the text.
1203      * @return
1204      */
1205     boolean isIgnoreText() {
1206         final Labeled labeled = getSkinnable();
1207         final String txt = labeled.getText();
1208         return (txt == null ||
1209                 txt.equals(&quot;&quot;) ||
1210                 labeled.getContentDisplay() == ContentDisplay.GRAPHIC_ONLY);
1211     }
1212 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
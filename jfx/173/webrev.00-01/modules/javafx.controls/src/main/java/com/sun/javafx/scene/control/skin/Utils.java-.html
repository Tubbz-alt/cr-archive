<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/skin/Utils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * To change this template, choose Tools | Templates
 28  * and open the template in the editor.
 29  */
 30 
 31 package com.sun.javafx.scene.control.skin;
 32 
 33 import com.sun.javafx.scene.NodeHelper;
 34 import com.sun.javafx.scene.control.behavior.TextBinding;
 35 import com.sun.javafx.scene.text.TextLayout;
 36 import com.sun.javafx.tk.Toolkit;
 37 import javafx.application.ConditionalFeature;
 38 import javafx.application.Platform;
 39 import javafx.beans.InvalidationListener;
 40 import javafx.beans.Observable;
 41 import javafx.beans.value.ObservableValue;
 42 import javafx.collections.ObservableList;
 43 import javafx.geometry.Bounds;
 44 import javafx.geometry.HPos;
 45 import javafx.geometry.Point2D;
 46 import javafx.geometry.VPos;
 47 import javafx.scene.Scene;
 48 import javafx.scene.control.ContextMenu;
 49 import javafx.scene.control.MenuItem;
 50 import javafx.scene.control.OverrunStyle;
 51 import com.sun.javafx.scene.control.ContextMenuContent;
 52 import com.sun.javafx.scene.text.FontHelper;
 53 import java.net.URL;
 54 import javafx.scene.input.KeyCombination;
 55 import javafx.scene.input.Mnemonic;
 56 import javafx.scene.paint.Color;
 57 import javafx.scene.text.Font;
 58 import javafx.scene.text.Text;
 59 import javafx.scene.text.TextBoundsType;
 60 import javafx.scene.text.HitInfo;
 61 
 62 import java.text.Bidi;
 63 import java.util.List;
 64 import java.util.Locale;
 65 import java.util.function.Consumer;
 66 
 67 import static javafx.scene.control.OverrunStyle.CENTER_ELLIPSIS;
 68 import static javafx.scene.control.OverrunStyle.CENTER_WORD_ELLIPSIS;
 69 import static javafx.scene.control.OverrunStyle.CLIP;
 70 import static javafx.scene.control.OverrunStyle.ELLIPSIS;
 71 import static javafx.scene.control.OverrunStyle.LEADING_ELLIPSIS;
 72 import static javafx.scene.control.OverrunStyle.LEADING_WORD_ELLIPSIS;
 73 import static javafx.scene.control.OverrunStyle.WORD_ELLIPSIS;
 74 
 75 /**
 76  * BE REALLY CAREFUL WITH RESTORING OR RESETTING STATE OF helper NODE AS LEFTOVER
 77  * STATE CAUSES REALLY ODD NASTY BUGS!
 78  *
 79  * We expect all methods to set the Font property of helper but other than that
 80  * any properties set should be restored to defaults.
 81  */
 82 public class Utils {
 83 
 84     static final Text helper = new Text();
 85     static final double DEFAULT_WRAPPING_WIDTH = helper.getWrappingWidth();
 86     static final double DEFAULT_LINE_SPACING = helper.getLineSpacing();
 87     static final String DEFAULT_TEXT = helper.getText();
 88     static final TextBoundsType DEFAULT_BOUNDS_TYPE = helper.getBoundsType();
 89 
 90     /* Using TextLayout directly for simple text measurement.
 91      * Instead of restoring the TextLayout attributes to default values
 92      * (each renders the TextLayout unable to efficiently cache layout data).
 93      * It always sets all the attributes pertinent to calculation being performed.
 94      * Note that lineSpacing and boundsType are important when computing the height
 95      * but irrelevant when computing the width.
 96      *
 97      * Note: This code assumes that TextBoundsType#VISUAL is never used by controls.
 98      * */
 99     static final TextLayout layout = Toolkit.getToolkit().getTextLayoutFactory().createLayout();
100 
101     public static double getAscent(Font font, TextBoundsType boundsType) {
102         layout.setContent(&quot;&quot;, FontHelper.getNativeFont(font));
103         layout.setWrapWidth(0);
104         layout.setLineSpacing(0);
105         if (boundsType == TextBoundsType.LOGICAL_VERTICAL_CENTER) {
106             layout.setBoundsType(TextLayout.BOUNDS_CENTER);
107         } else {
108             layout.setBoundsType(0);
109         }
110         return -layout.getBounds().getMinY();
111     }
112 
113     public static double getLineHeight(Font font, TextBoundsType boundsType) {
114         layout.setContent(&quot;&quot;, FontHelper.getNativeFont(font));
115         layout.setWrapWidth(0);
116         layout.setLineSpacing(0);
117         if (boundsType == TextBoundsType.LOGICAL_VERTICAL_CENTER) {
118             layout.setBoundsType(TextLayout.BOUNDS_CENTER);
119         } else {
120             layout.setBoundsType(0);
121         }
122 
123         // RT-37092: Use the line bounds specifically, to include font leading.
124         return layout.getLines()[0].getBounds().getHeight();
125     }
126 
127     public static double computeTextWidth(Font font, String text, double wrappingWidth) {
128         layout.setContent(text != null ? text : &quot;&quot;, FontHelper.getNativeFont(font));
129         layout.setWrapWidth((float)wrappingWidth);
130         return layout.getBounds().getWidth();
131     }
132 
133     public static double computeTextHeight(Font font, String text, double wrappingWidth, TextBoundsType boundsType) {
134         return computeTextHeight(font, text, wrappingWidth, 0, boundsType);
135     }
136 
137     @SuppressWarnings(&quot;deprecation&quot;)
138     public static double computeTextHeight(Font font, String text, double wrappingWidth, double lineSpacing, TextBoundsType boundsType) {
139         layout.setContent(text != null ? text : &quot;&quot;, FontHelper.getNativeFont(font));
140         layout.setWrapWidth((float)wrappingWidth);
141         layout.setLineSpacing((float)lineSpacing);
142         if (boundsType == TextBoundsType.LOGICAL_VERTICAL_CENTER) {
143             layout.setBoundsType(TextLayout.BOUNDS_CENTER);
144         } else {
145             layout.setBoundsType(0);
146         }
147         return layout.getBounds().getHeight();
148     }
149 
150     public static Point2D computeMnemonicPosition(Font font, String text, int mnemonicIndex, double wrappingWidth,
151                                                   double lineSpacing, boolean isRTL) {
152         // Input validation
153         if ((font == null) || (text == null) ||
154             (mnemonicIndex &lt; 0) || (mnemonicIndex &gt; text.length())) {
155             return null;
156         }
157 
158         // Layout the text with given font, wrapping width and line spacing
159         layout.setContent(text, FontHelper.getNativeFont(font));
160         layout.setWrapWidth((float)wrappingWidth);
161         layout.setLineSpacing((float)lineSpacing);
162 
163         // The text could be spread over multiple lines
164         // We need to find out on which line the mnemonic character lies
165         int start = 0;
166         int i = 0;
167         int totalLines = layout.getLines().length;
168         int lineLength = 0;
169         while (i &lt; totalLines) {
170             lineLength = layout.getLines()[i].getLength();
171 
172             if ((mnemonicIndex &gt;= start) &amp;&amp;
173                 (mnemonicIndex &lt; (start + lineLength))) {
174                 // mnemonic lies on line &#39;i&#39;
175                 break;
176             }
177 
178             start += lineLength;
179             i++;
180         }
181 
182         // Find x and y offsets of mnemonic character position
183         // in line numbered &#39;i&#39;
184         double lineHeight = layout.getBounds().getHeight() / totalLines;
185         double x = Utils.computeTextWidth(font, text.substring(start, mnemonicIndex), 0);
186         if (isRTL) {
187             double lineWidth = Utils.computeTextWidth(font, text.substring(start, (start + lineLength - 1)), 0);
188             x = lineWidth - x;
189         }
190 
191         double y = (lineHeight * (i+1));
192         // Adjust y offset for linespacing except for the last line.
193         if ((i+1) != totalLines) {
194             y -= (lineSpacing / 2);
195         }
196 
197         return new Point2D(x, y);
198     }
199 
200     public static int computeTruncationIndex(Font font, String text, double width) {
201         helper.setText(text);
202         helper.setFont(font);
203         helper.setWrappingWidth(0);
204         helper.setLineSpacing(0);
205         // The -2 is a fudge to make sure the result more often matches
206         // what we get from using computeTextWidth instead. It&#39;s not yet
207         // clear what causes the small discrepancies.
208         Bounds bounds = helper.getLayoutBounds();
209         Point2D endPoint = new Point2D(width - 2, bounds.getMinY() + bounds.getHeight() / 2);
210         final int index = helper.hitTest(endPoint).getCharIndex();
211         // RESTORE STATE
212         helper.setWrappingWidth(DEFAULT_WRAPPING_WIDTH);
213         helper.setLineSpacing(DEFAULT_LINE_SPACING);
214         helper.setText(DEFAULT_TEXT);
215         return index;
216     }
217 
218     public static String computeClippedText(Font font, String text, double width,
219                                      OverrunStyle type, String ellipsisString) {
220         if (font == null) {
221             throw new IllegalArgumentException(&quot;Must specify a font&quot;);
222         }
223         OverrunStyle style = (type == null || type == CLIP) ? ELLIPSIS : type;
224         final String ellipsis = (type == CLIP) ? &quot;&quot; : ellipsisString;
225         // if the text is empty or null or no ellipsis, then it always fits
226         if (text == null || &quot;&quot;.equals(text)) {
227             return text;
228         }
229         // if the string width is &lt; the available width, then it fits and
230         // doesn&#39;t need to be clipped.  We use a double point comparison
231         // of 0.001 (1/1000th of a pixel) to account for any numerical
232         // discrepancies introduced when the available width was calculated.
233         // MenuItemSkinBase.doLayout, for example, does a number of double
234         // point operations when computing the available width.
235         final double stringWidth = computeTextWidth(font, text, 0);
236         if (stringWidth - width &lt; 0.0010F) {
237             return text;
238         }
239         // the width used by the ellipsis string
240         final double ellipsisWidth = computeTextWidth(font, ellipsis, 0);
241         // the available maximum width to fit chars into. This is essentially
242         // the width minus the space required for the ellipsis string
243         final double availableWidth = width - ellipsisWidth;
244 
245         if (width &lt; ellipsisWidth) {
246             // The ellipsis doesn&#39;t fit.
247             return &quot;&quot;;
248         }
249 
250         // if we got here, then we must clip the text with an ellipsis.
251         // this can be pretty expensive depending on whether &quot;complex&quot; text
252         // layout needs to be taken into account. So each ellipsis option has
253         // to take into account two code paths: the easy way and the correct
254         // way. This is flagged by the &quot;complexLayout&quot; boolean
255         // TODO make sure this function call takes into account ligatures, kerning,
256         // and such as that will change the layout characteristics of the text
257         // and will require a full complex layout
258         // TODO since we don&#39;t have all the stuff available in FX to determine
259         // complex text, I&#39;m going to for now assume complex text is always false.
260         final boolean complexLayout = false;
261         //requiresComplexLayout(font, text);
262 
263         // generally all we want to do is count characters and add their widths.
264         // For ellipsis that breaks on words, we do NOT want to include any
265         // hanging whitespace.
266         if (style == ELLIPSIS ||
267             style == WORD_ELLIPSIS ||
268             style == LEADING_ELLIPSIS ||
269             style == LEADING_WORD_ELLIPSIS) {
270 
271             final boolean wordTrim =
272                 (style == WORD_ELLIPSIS || style == LEADING_WORD_ELLIPSIS);
273             String substring;
274             if (complexLayout) {
275             //            AttributedString a = new AttributedString(text);
276             //            LineBreakMeasurer m = new LineBreakMeasurer(a.getIterator(), frc);
277             //            substring = text.substring(0, m.nextOffset((double)availableWidth));
278             } else {
279                 // RT-23458: Use a faster algorithm for the most common case
280                 // where truncation happens at the end, i.e. for ELLIPSIS and
281                 // CLIP, but not for other cases such as WORD_ELLIPSIS, etc.
282                 if (style == ELLIPSIS &amp;&amp; !new Bidi(text, Bidi.DIRECTION_LEFT_TO_RIGHT).isMixed()) {
283                     int hit = computeTruncationIndex(font, text, width - ellipsisWidth);
284                     if (hit &lt; 0 || hit &gt;= text.length()) {
285                         return text;
286                     } else {
287                         return text.substring(0, hit) + ellipsis;
288                     }
289                 }
290 
291                 // simply total up the widths of all chars to determine how many
292                 // will fit in the available space. Remember the last whitespace
293                 // encountered so that if we&#39;re breaking on words we can trim
294                 // and omit it.
295                 double total = 0.0F;
296                 int whitespaceIndex = -1;
297                 // at the termination of the loop, index will be one past the
298                 // end of the substring
299                 int index = 0;
300                 int start = (style == LEADING_ELLIPSIS || style == LEADING_WORD_ELLIPSIS) ? (text.length() - 1) : (0);
301                 int end = (start == 0) ? (text.length() - 1) : 0;
302                 int stepValue = (start == 0) ? 1 : -1;
303                 boolean done = (start == 0) ? start &gt; end : start &lt; end;
304                 for (int i = start; !done ; i += stepValue) {
305                     index = i;
306                     char c = text.charAt(index);
307                     total = computeTextWidth(font,
308                                              (start == 0) ? text.substring(0, i + 1)
309                                                           : text.substring(i, start + 1),
310                                              0);
311                     if (Character.isWhitespace(c)) {
312                         whitespaceIndex = index;
313                     }
314                     if (total &gt; availableWidth) {
315                         break;
316                     }
317                     done = start == 0? i &gt;= end : i &lt;= end;
318                 }
319                 final boolean fullTrim = !wordTrim || whitespaceIndex == -1;
320                 substring = (start == 0) ?
321                     (text.substring(0, fullTrim ? index : whitespaceIndex)) :
322                         (text.substring((fullTrim ? index : whitespaceIndex) + 1));
323                 assert(!text.equals(substring));
324             }
325             if (style == ELLIPSIS || style == WORD_ELLIPSIS) {
326                  return substring + ellipsis;
327             } else {
328                 //style is LEADING_ELLIPSIS or LEADING_WORD_ELLIPSIS
329                 return ellipsis + substring;
330             }
331         } else {
332             // these two indexes are INCLUSIVE not exclusive
333             int leadingIndex = 0;
334             int trailingIndex = 0;
335             int leadingWhitespace = -1;
336             int trailingWhitespace = -1;
337             // The complex case is going to be killer. What I have to do is
338             // read all the chars from the left up to the leadingIndex,
339             // and all the chars from the right up to the trailingIndex,
340             // and sum those together to get my total. That is, I cannot have
341             // a running total but must retotal the cummulative chars each time
342             if (complexLayout) {
343             } else /*            double leadingTotal = 0;
344                double trailingTotal = 0;
345                for (int i=0; i&lt;text.length(); i++) {
346                double total = computeStringWidth(metrics, text.substring(0, i));
347                if (total + trailingTotal &gt; availableWidth) break;
348                leadingIndex = i;
349                leadingTotal = total;
350                if (Character.isWhitespace(text.charAt(i))) leadingWhitespace = leadingIndex;
351 
352                int index = text.length() - (i + 1);
353                total = computeStringWidth(metrics, text.substring(index - 1));
354                if (total + leadingTotal &gt; availableWidth) break;
355                trailingIndex = index;
356                trailingTotal = total;
357                if (Character.isWhitespace(text.charAt(index))) trailingWhitespace = trailingIndex;
358                }*/
359             {
360                 // either CENTER_ELLIPSIS or CENTER_WORD_ELLIPSIS
361                 // for this case I read one char on the left, then one on the end
362                 // then second on the left, then second from the end, etc until
363                 // I have used up all the availableWidth. At that point, I trim
364                 // the string twice: once from the start to firstIndex, and
365                 // once from secondIndex to the end. I then insert the ellipsis
366                 // between the two.
367                 leadingIndex = -1;
368                 trailingIndex = -1;
369                 double total = 0.0F;
370                 for (int i = 0; i &lt;= text.length() - 1; i++) {
371                     char c = text.charAt(i);
372                     //total += metrics.charWidth(c);
373                     total += computeTextWidth(font, &quot;&quot; + c, 0);
374                     if (total &gt; availableWidth) {
375                         break;
376                     }
377                     leadingIndex = i;
378                     if (Character.isWhitespace(c)) {
379                         leadingWhitespace = leadingIndex;
380                     }
381                     int index = text.length() - 1 - i;
382                     c = text.charAt(index);
383                     //total += metrics.charWidth(c);
384                     total += computeTextWidth(font, &quot;&quot; + c, 0);
385                     if (total &gt; availableWidth) {
386                         break;
387                     }
388                     trailingIndex = index;
389                     if (Character.isWhitespace(c)) {
390                         trailingWhitespace = trailingIndex;
391                     }
392                 }
393             }
394             if (leadingIndex &lt; 0) {
395                 return ellipsis;
396             }
397             if (style == CENTER_ELLIPSIS) {
398                 if (trailingIndex &lt; 0) {
399                     return text.substring(0, leadingIndex + 1) + ellipsis;
400                 }
401                 return text.substring(0, leadingIndex + 1) + ellipsis + text.substring(trailingIndex);
402             } else {
403                 boolean leadingIndexIsLastLetterInWord =
404                     Character.isWhitespace(text.charAt(leadingIndex + 1));
405                 int index = (leadingWhitespace == -1 || leadingIndexIsLastLetterInWord) ? (leadingIndex + 1) : (leadingWhitespace);
406                 String leading = text.substring(0, index);
407                 if (trailingIndex &lt; 0) {
408                     return leading + ellipsis;
409                 }
410                 boolean trailingIndexIsFirstLetterInWord =
411                     Character.isWhitespace(text.charAt(trailingIndex - 1));
412                 index = (trailingWhitespace == -1 || trailingIndexIsFirstLetterInWord) ? (trailingIndex) : (trailingWhitespace + 1);
413                 String trailing = text.substring(index);
414                 return leading + ellipsis + trailing;
415             }
416         }
417     }
418 
419     public static String computeClippedWrappedText(Font font, String text, double width,
420                                             double height, double lineSpacing, OverrunStyle truncationStyle,
421                                             String ellipsisString, TextBoundsType boundsType) {
422         if (font == null) {
423             throw new IllegalArgumentException(&quot;Must specify a font&quot;);
424         }
425 
426         height += lineSpacing;
427 
428         String ellipsis = (truncationStyle == CLIP) ? &quot;&quot; : ellipsisString;
429         int eLen = ellipsis.length();
430         // Do this before using helper, as it&#39;s not reentrant.
431         double eWidth = computeTextWidth(font, ellipsis, 0);
432         double eHeight = computeTextHeight(font, ellipsis, 0, boundsType);
433 
434         if (width &lt; eWidth || height &lt; eHeight) {
435             // The ellipsis doesn&#39;t fit.
436             return text; // RT-30868 - return text, not empty string.
437         }
438 
439         helper.setText(text);
440         helper.setFont(font);
441         helper.setWrappingWidth((int)Math.ceil(width));
442         helper.setBoundsType(boundsType);
443         helper.setLineSpacing(lineSpacing);
444 
445         boolean leading =  (truncationStyle == LEADING_ELLIPSIS ||
446                             truncationStyle == LEADING_WORD_ELLIPSIS);
447         boolean center =   (truncationStyle == CENTER_ELLIPSIS ||
448                             truncationStyle == CENTER_WORD_ELLIPSIS);
449         boolean trailing = !(leading || center);
450         boolean wordTrim = (truncationStyle == WORD_ELLIPSIS ||
451                             truncationStyle == LEADING_WORD_ELLIPSIS ||
452                             truncationStyle == CENTER_WORD_ELLIPSIS);
453 
454         String result = text;
455         int len = (result != null) ? result.length() : 0;
456         int centerLen = -1;
457 
458         Point2D centerPoint = null;
459         if (center) {
460             // Find index of character in the middle of the visual text area
461             centerPoint = new Point2D((width - eWidth) / 2, height / 2 - helper.getBaselineOffset());
462         }
463 
464         // Find index of character at the bottom left of the text area.
465         // This should be the first character of a line that would be clipped.
466         Point2D endPoint = new Point2D(0, height - helper.getBaselineOffset());
467 
468         int hit = helper.hitTest(endPoint).getCharIndex();
469         if (hit &gt;= len) {
470             helper.setBoundsType(TextBoundsType.LOGICAL); // restore
471             return text;
472         }
473         if (center) {
474             hit = helper.hitTest(centerPoint).getCharIndex();
475         }
476 
477         if (hit &gt; 0 &amp;&amp; hit &lt; len) {
478             // Step one, make a truncation estimate.
479 
480             if (center || trailing) {
481                 int ind = hit;
482                 if (center) {
483                     // This is for the first part, i.e. beginning of text up to ellipsis.
484                     if (wordTrim) {
485                         int brInd = lastBreakCharIndex(text, ind + 1);
486                         if (brInd &gt;= 0) {
487                             ind = brInd + 1;
488                         } else {
489                             brInd = firstBreakCharIndex(text, ind);
490                             if (brInd &gt;= 0) {
491                                 ind = brInd + 1;
492                             }
493                         }
494                     }
495                     centerLen = ind + eLen;
496                 } // else: text node wraps at words, so wordTrim is not needed here.
497                 result = result.substring(0, ind) + ellipsis;
498             }
499 
500             if (leading || center) {
501                 // The hit is an index counted from the beginning, but we need
502                 // the opposite, i.e. an index counted from the end.  However,
503                 // the Text node does not support wrapped line layout in the
504                 // reverse direction, starting at the bottom right corner.
505 
506                 // We&#39;ll simulate by assuming the index will be a similar
507                 // number, then back up 10 characters just to add some slop.
508                 // For example, the ending lines might pack tighter than the
509                 // beginning lines, and therefore fit a higher number of
510                 // characters.
511                 int ind = Math.max(0, len - hit - 10);
512                 if (ind &gt; 0 &amp;&amp; wordTrim) {
513                     int brInd = lastBreakCharIndex(text, ind + 1);
514                     if (brInd &gt;= 0) {
515                         ind = brInd + 1;
516                     } else {
517                         brInd = firstBreakCharIndex(text, ind);
518                         if (brInd &gt;= 0) {
519                             ind = brInd + 1;
520                         }
521                     }
522                 }
523                 if (center) {
524                     // This is for the second part, i.e. from ellipsis to end of text.
525                     result = result + text.substring(ind);
526                 } else {
527                     result = ellipsis + text.substring(ind);
528                 }
529             }
530 
531             // Step two, check if text still overflows after we added the ellipsis.
532             // If so, remove one char or word at a time.
533             while (true) {
534                 helper.setText(result);
535                 int hit2 = helper.hitTest(endPoint).getCharIndex();
536                 if (center &amp;&amp; hit2 &lt; centerLen) {
537                     // No room for text after ellipsis. Maybe there is a newline
538                     // here, and the next line falls outside the view.
539                     if (hit2 &gt; 0 &amp;&amp; result.charAt(hit2-1) == &#39;\n&#39;) {
540                         hit2--;
541                     }
542                     result = text.substring(0, hit2) + ellipsis;
543                     break;
544                 } else if (hit2 &gt; 0 &amp;&amp; hit2 &lt; result.length()) {
545                     if (leading) {
546                         int ind = eLen + 1; // Past ellipsis and first char.
547                         if (wordTrim) {
548                             int brInd = firstBreakCharIndex(result, ind);
549                             if (brInd &gt;= 0) {
550                                 ind = brInd + 1;
551                             }
552                         }
553                         result = ellipsis + result.substring(ind);
554                     } else if (center) {
555                         int ind = centerLen + 1; // Past ellipsis and first char.
556                         if (wordTrim) {
557                             int brInd = firstBreakCharIndex(result, ind);
558                             if (brInd &gt;= 0) {
559                                 ind = brInd + 1;
560                             }
561                         }
562                         result = result.substring(0, centerLen) + result.substring(ind);
563                     } else {
564                         int ind = result.length() - eLen - 1; // Before last char and ellipsis.
565                         if (wordTrim) {
566                             int brInd = lastBreakCharIndex(result, ind);
567                             if (brInd &gt;= 0) {
568                                 ind = brInd;
569                             }
570                         }
571                         result = result.substring(0, ind) + ellipsis;
572                     }
573                 } else {
574                     break;
575                 }
576             }
577         }
578         // RESTORE STATE
579         helper.setWrappingWidth(DEFAULT_WRAPPING_WIDTH);
580         helper.setLineSpacing(DEFAULT_LINE_SPACING);
581         helper.setText(DEFAULT_TEXT);
582         helper.setBoundsType(DEFAULT_BOUNDS_TYPE);
583         return result;
584     }
585 
586 
587     private static int firstBreakCharIndex(String str, int start) {
588         char[] chars = str.toCharArray();
589         for (int i = start; i &lt; chars.length; i++) {
590             if (isPreferredBreakCharacter(chars[i])) {
591                 return i;
592             }
593         }
594         return -1;
595     }
596 
597     private static int lastBreakCharIndex(String str, int start) {
598         char[] chars = str.toCharArray();
599         for (int i = start; i &gt;= 0; i--) {
600             if (isPreferredBreakCharacter(chars[i])) {
601                 return i;
602             }
603         }
604         return -1;
605     }
606 
607     /* Recognizes white space and latin punctuation as preferred
608      * line break positions. Could do a bit better with using more
609      * of the properties from the Character class.
610      */
611     private static boolean isPreferredBreakCharacter(char ch) {
612         if (Character.isWhitespace(ch)) {
613             return true;
614         } else {
615             switch (ch) {
616             case &#39;;&#39; :
617             case &#39;:&#39; :
618             case &#39;.&#39; :
619                 return true;
620             default: return false;
621             }
622         }
623     }
624 
625     private static boolean requiresComplexLayout(Font font, String string) {
626         /*        Map attrs = font.getAttributes();
627            if (contains(attrs, KERNING, KERNING_ON) ||
628            contains(attrs, LIGATURES, LIGATURES_ON) ||
629            (attrs.containsKey(TRACKING) &amp;&amp; attrs.get(TRACKING) != null)) {
630            return true;
631            }
632            return isComplexLayout(string.toCharArray(), 0, string.length());
633          */
634         return false;
635     }
636 
637     static int computeStartOfWord(Font font, String text, int index) {
638         if (&quot;&quot;.equals(text) || index &lt; 0) return 0;
639         if (text.length() &lt;= index) return text.length();
640         // if the given index is not in a word (but in whitespace), then
641         // simply return the index
642         if (Character.isWhitespace(text.charAt(index))) {
643             return index;
644         }
645         boolean complexLayout = requiresComplexLayout(font, text);
646         if (complexLayout) {
647             // TODO needs implementation
648             return 0;
649         } else {
650             // just start walking backwards from index until either i&lt;0 or
651             // the first whitespace is found.
652             int i = index;
653             while (--i &gt;= 0) {
654                 if (Character.isWhitespace(text.charAt(i))) {
655                     return i + 1;
656                 }
657             }
658             return 0;
659         }
660     }
661 
662     static int computeEndOfWord(Font font, String text, int index) {
663         if (text.equals(&quot;&quot;) || index &lt; 0) {
664             return 0;
665         }
666         if (text.length() &lt;= index) {
667             return text.length();
668         }
669         // if the given index is not in a word (but in whitespace), then
670         // simply return the index
671         if (Character.isWhitespace(text.charAt(index))) {
672             return index;
673         }
674         boolean complexLayout = requiresComplexLayout(font, text);
675         if (complexLayout) {
676             // TODO needs implementation
677             return text.length();
678         } else {
679             // just start walking forward from index until either i &gt; length or
680             // the first whitespace is found.
681             int i = index;
682             while (++i &lt; text.length()) {
683                 if (Character.isWhitespace(text.charAt(i))) {
684                     return i;
685                 }
686             }
687             return text.length();
688         }
689     }
690 
691     // used for layout to adjust widths to honor the min/max policies consistently
692     public static double boundedSize(double value, double min, double max) {
693         // if max &lt; value, return max
694         // if min &gt; value, return min
695         // if min &gt; max, return min
696         return Math.min(Math.max(value, min), Math.max(min,max));
697     }
698 
699     public static void addMnemonics(ContextMenu popup, Scene scene) {
700         addMnemonics(popup, scene, false);
701     }
702 
703     public static void addMnemonics(ContextMenu popup, Scene scene, boolean initialState) {
704         addMnemonics(popup, scene, initialState, null);
705     }
706 
707     public static void addMnemonics(ContextMenu popup, Scene scene, boolean initialState, List&lt;Mnemonic&gt; into) {
708 
709         if (!com.sun.javafx.PlatformUtil.isMac()) {
710 
711             ContextMenuContent cmContent = (ContextMenuContent)popup.getSkin().getNode();
712             MenuItem menuitem;
713 
714             for (int i = 0 ; i &lt; popup.getItems().size() ; i++) {
715                 menuitem = popup.getItems().get(i);
716                 /*
717                 ** check is there are any mnemonics in this menu
718                 */
719                 if (menuitem.isMnemonicParsing()) {
720 
721                     TextBinding bindings = new TextBinding(menuitem.getText());
722                     int mnemonicIndex = bindings.getMnemonicIndex() ;
723                     if (mnemonicIndex &gt;= 0) {
724                         KeyCombination mnemonicKeyCombo = bindings.getMnemonicKeyCombination();
725                         Mnemonic myMnemonic = new Mnemonic(cmContent.getLabelAt(i), mnemonicKeyCombo);
726                         scene.addMnemonic(myMnemonic);
727                         NodeHelper.setShowMnemonics(cmContent.getLabelAt(i), initialState);
728                         if (into != null) {
729                             into.add(myMnemonic);
730                         }
731                     }
732                 }
733             }
734         }
735     }
736 
737 
738 
739     public static void removeMnemonics(ContextMenu popup, Scene scene) {
740 
741         if (!com.sun.javafx.PlatformUtil.isMac()) {
742 
743             ContextMenuContent cmContent = (ContextMenuContent)popup.getSkin().getNode();
744             MenuItem menuitem;
745 
746             for (int i = 0 ; i &lt; popup.getItems().size() ; i++) {
747                 menuitem = popup.getItems().get(i);
748                 /*
749                 ** check is there are any mnemonics in this menu
750                 */
751                 if (menuitem.isMnemonicParsing()) {
752 
753                     TextBinding bindings = new TextBinding(menuitem.getText());
754                     int mnemonicIndex = bindings.getMnemonicIndex() ;
755                     if (mnemonicIndex &gt;= 0) {
756                         KeyCombination mnemonicKeyCombo = bindings.getMnemonicKeyCombination();
757 
758                         ObservableList&lt;Mnemonic&gt; mnemonicsList = scene.getMnemonics().get(mnemonicKeyCombo);
759                         if (mnemonicsList != null) {
760                             for (int j = 0 ; j &lt; mnemonicsList.size() ; j++) {
761                                 if (mnemonicsList.get(j).getNode() == cmContent.getLabelAt(i)) {
762                                     mnemonicsList.remove(j);
763                                 }
764                             }
765                         }
766                     }
767                 }
768             }
769         }
770     }
771 
772     public static double computeXOffset(double width, double contentWidth, HPos hpos) {
773         if (hpos == null) {
774             return 0;
775         }
776 
777         switch(hpos) {
778             case LEFT:
779                return 0;
780             case CENTER:
781                return (width - contentWidth) / 2;
782             case RIGHT:
783                return width - contentWidth;
784             default:
785                 return 0;
786         }
787     }
788 
789     public static double computeYOffset(double height, double contentHeight, VPos vpos) {
790         if (vpos == null) {
791             return 0;
792         }
793 
794         switch(vpos) {
795             case TOP:
796                return 0;
797             case CENTER:
798                return (height - contentHeight) / 2;
799             case BOTTOM:
800                return height - contentHeight;
801             default:
802                 return 0;
803         }
804     }
805 
806     /*
807     ** Returns true if the platform is to use Two-Level-Focus.
808     ** This is in the Util class to ease any changes in
809     ** the criteria for enabling this feature.
810     **
811     ** TwoLevelFocus is needed on platforms that
812     ** only support 5-button navigation (arrow keys and Select/OK).
813     **
814     */
815     public static boolean isTwoLevelFocus() {
816         return Platform.isSupported(ConditionalFeature.TWO_LEVEL_FOCUS);
817     }
818 
819 
820     // useful method for linking things together when before a property is
821     // necessarily set
822     public static &lt;T&gt; void executeOnceWhenPropertyIsNonNull(ObservableValue&lt;T&gt; p, Consumer&lt;T&gt; consumer) {
823         if (p == null) return;
824 
825         T value = p.getValue();
826         if (value != null) {
827             consumer.accept(value);
828         } else {
829             final InvalidationListener listener = new InvalidationListener() {
830                 @Override public void invalidated(Observable observable) {
831                     T value = p.getValue();
832 
833                     if (value != null) {
834                         p.removeListener(this);
835                         consumer.accept(value);
836                     }
837                 }
838             };
839             p.addListener(listener);
840         }
841     }
842 
843     public static String formatHexString(Color c) {
844         if (c != null) {
845             return String.format((Locale) null, &quot;#%02x%02x%02x&quot;,
846                     Math.round(c.getRed() * 255),
847                     Math.round(c.getGreen() * 255),
848                     Math.round(c.getBlue() * 255));
849         } else {
850             return null;
851         }
852     }
853 
854     public static URL getResource(String str) {
855         return Utils.class.getResource(str);
856     }
857 
858 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/skin/Utils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * To change this template, choose Tools | Templates
 28  * and open the template in the editor.
 29  */
 30 
 31 package com.sun.javafx.scene.control.skin;
 32 
 33 import com.sun.javafx.scene.NodeHelper;
 34 import com.sun.javafx.scene.control.behavior.TextBinding;
 35 import com.sun.javafx.scene.text.TextLayout;
 36 import com.sun.javafx.tk.Toolkit;
 37 import javafx.application.ConditionalFeature;
 38 import javafx.application.Platform;
 39 import javafx.beans.InvalidationListener;
 40 import javafx.beans.Observable;
 41 import javafx.beans.value.ObservableValue;
 42 import javafx.collections.ObservableList;
 43 import javafx.geometry.Bounds;
 44 import javafx.geometry.HPos;
 45 import javafx.geometry.Point2D;
 46 import javafx.geometry.VPos;
 47 import javafx.scene.Scene;
 48 import javafx.scene.control.ContextMenu;
 49 import javafx.scene.control.MenuItem;
 50 import javafx.scene.control.OverrunStyle;
 51 import com.sun.javafx.scene.control.ContextMenuContent;
 52 import com.sun.javafx.scene.text.FontHelper;
 53 import java.net.URL;
 54 import javafx.scene.input.KeyCombination;
 55 import javafx.scene.input.Mnemonic;
 56 import javafx.scene.paint.Color;
 57 import javafx.scene.text.Font;
 58 import javafx.scene.text.Text;
 59 import javafx.scene.text.TextBoundsType;
 60 import javafx.scene.text.HitInfo;
 61 
 62 import java.text.Bidi;
 63 import java.util.List;
 64 import java.util.Locale;
 65 import java.util.function.Consumer;
 66 
 67 import static javafx.scene.control.OverrunStyle.CENTER_ELLIPSIS;
 68 import static javafx.scene.control.OverrunStyle.CENTER_WORD_ELLIPSIS;
 69 import static javafx.scene.control.OverrunStyle.CLIP;
 70 import static javafx.scene.control.OverrunStyle.ELLIPSIS;
 71 import static javafx.scene.control.OverrunStyle.LEADING_ELLIPSIS;
 72 import static javafx.scene.control.OverrunStyle.LEADING_WORD_ELLIPSIS;
 73 import static javafx.scene.control.OverrunStyle.WORD_ELLIPSIS;
 74 
 75 /**
 76  * BE REALLY CAREFUL WITH RESTORING OR RESETTING STATE OF helper NODE AS LEFTOVER
 77  * STATE CAUSES REALLY ODD NASTY BUGS!
 78  *
 79  * We expect all methods to set the Font property of helper but other than that
 80  * any properties set should be restored to defaults.
 81  */
 82 public class Utils {
 83 
 84     static final Text helper = new Text();
 85     static final double DEFAULT_WRAPPING_WIDTH = helper.getWrappingWidth();
 86     static final double DEFAULT_LINE_SPACING = helper.getLineSpacing();
 87     static final String DEFAULT_TEXT = helper.getText();
 88     static final TextBoundsType DEFAULT_BOUNDS_TYPE = helper.getBoundsType();
 89 
 90     /* Using TextLayout directly for simple text measurement.
 91      * Instead of restoring the TextLayout attributes to default values
 92      * (each renders the TextLayout unable to efficiently cache layout data).
 93      * It always sets all the attributes pertinent to calculation being performed.
 94      * Note that lineSpacing and boundsType are important when computing the height
 95      * but irrelevant when computing the width.
 96      *
 97      * Note: This code assumes that TextBoundsType#VISUAL is never used by controls.
 98      * */
 99     static final TextLayout layout = Toolkit.getToolkit().getTextLayoutFactory().createLayout();
100 
101     public static double getAscent(Font font, TextBoundsType boundsType) {
102         layout.setContent(&quot;&quot;, FontHelper.getNativeFont(font));
103         layout.setWrapWidth(0);
104         layout.setLineSpacing(0);
105         if (boundsType == TextBoundsType.LOGICAL_VERTICAL_CENTER) {
106             layout.setBoundsType(TextLayout.BOUNDS_CENTER);
107         } else {
108             layout.setBoundsType(0);
109         }
110         return -layout.getBounds().getMinY();
111     }
112 
113     public static double getLineHeight(Font font, TextBoundsType boundsType) {
114         layout.setContent(&quot;&quot;, FontHelper.getNativeFont(font));
115         layout.setWrapWidth(0);
116         layout.setLineSpacing(0);
117         if (boundsType == TextBoundsType.LOGICAL_VERTICAL_CENTER) {
118             layout.setBoundsType(TextLayout.BOUNDS_CENTER);
119         } else {
120             layout.setBoundsType(0);
121         }
122 
123         // RT-37092: Use the line bounds specifically, to include font leading.
124         return layout.getLines()[0].getBounds().getHeight();
125     }
126 
127     public static double computeTextWidth(Font font, String text, double wrappingWidth) {
128         layout.setContent(text != null ? text : &quot;&quot;, FontHelper.getNativeFont(font));
129         layout.setWrapWidth((float)wrappingWidth);
130         return layout.getBounds().getWidth();
131     }
132 
133     public static double computeTextHeight(Font font, String text, double wrappingWidth, TextBoundsType boundsType) {
134         return computeTextHeight(font, text, wrappingWidth, 0, boundsType);
135     }
136 
137     @SuppressWarnings(&quot;deprecation&quot;)
138     public static double computeTextHeight(Font font, String text, double wrappingWidth, double lineSpacing, TextBoundsType boundsType) {
139         layout.setContent(text != null ? text : &quot;&quot;, FontHelper.getNativeFont(font));
140         layout.setWrapWidth((float)wrappingWidth);
141         layout.setLineSpacing((float)lineSpacing);
142         if (boundsType == TextBoundsType.LOGICAL_VERTICAL_CENTER) {
143             layout.setBoundsType(TextLayout.BOUNDS_CENTER);
144         } else {
145             layout.setBoundsType(0);
146         }
147         return layout.getBounds().getHeight();
148     }
149 
150     public static Point2D computeMnemonicPosition(Font font, String text, int mnemonicIndex, double wrappingWidth,
151                                                   double lineSpacing, boolean isRTL) {
152         // Input validation
153         if ((font == null) || (text == null) ||
154             (mnemonicIndex &lt; 0) || (mnemonicIndex &gt; text.length())) {
155             return null;
156         }
157 
158         // Layout the text with given font, wrapping width and line spacing
159         layout.setContent(text, FontHelper.getNativeFont(font));
160         layout.setWrapWidth((float)wrappingWidth);
161         layout.setLineSpacing((float)lineSpacing);
162 
163         // The text could be spread over multiple lines
164         // We need to find out on which line the mnemonic character lies
165         int start = 0;
166         int i = 0;
167         int totalLines = layout.getLines().length;
168         int lineLength = 0;
169         while (i &lt; totalLines) {
170             lineLength = layout.getLines()[i].getLength();
171 
172             if ((mnemonicIndex &gt;= start) &amp;&amp;
173                 (mnemonicIndex &lt; (start + lineLength))) {
174                 // mnemonic lies on line &#39;i&#39;
175                 break;
176             }
177 
178             start += lineLength;
179             i++;
180         }
181 
182         // Find x and y offsets of mnemonic character position
183         // in line numbered &#39;i&#39;
184         double lineHeight = layout.getBounds().getHeight() / totalLines;
185         double x = Utils.computeTextWidth(font, text.substring(start, mnemonicIndex), 0);
186         if (isRTL) {
187             double lineWidth = Utils.computeTextWidth(font, text.substring(start, (start + lineLength - 1)), 0);
188             x = lineWidth - x;
189         }
190 
191         double y = (lineHeight * (i+1));
192         // Adjust y offset for linespacing except for the last line.
193         if ((i+1) != totalLines) {
194             y -= (lineSpacing / 2);
195         }
196 
197         return new Point2D(x, y);
198     }
199 
200     public static int computeTruncationIndex(Font font, String text, double width) {
201         helper.setText(text);
202         helper.setFont(font);
203         helper.setWrappingWidth(0);
204         helper.setLineSpacing(0);
205         // The -2 is a fudge to make sure the result more often matches
206         // what we get from using computeTextWidth instead. It&#39;s not yet
207         // clear what causes the small discrepancies.
208         Bounds bounds = helper.getLayoutBounds();
209         Point2D endPoint = new Point2D(width - 2, bounds.getMinY() + bounds.getHeight() / 2);
210         final int index = helper.hitTest(endPoint).getCharIndex();
211         // RESTORE STATE
212         helper.setWrappingWidth(DEFAULT_WRAPPING_WIDTH);
213         helper.setLineSpacing(DEFAULT_LINE_SPACING);
214         helper.setText(DEFAULT_TEXT);
215         return index;
216     }
217 
218     public static String computeClippedText(Font font, String text, double width,
219                                      OverrunStyle type, String ellipsisString) {
220         if (font == null) {
221             throw new IllegalArgumentException(&quot;Must specify a font&quot;);
222         }
223         OverrunStyle style = (type == null || type == CLIP) ? ELLIPSIS : type;
224         final String ellipsis = (type == CLIP) ? &quot;&quot; : ellipsisString;
225         // if the text is empty or null or no ellipsis, then it always fits
226         if (text == null || &quot;&quot;.equals(text)) {
227             return text;
228         }
229         // if the string width is &lt; the available width, then it fits and
230         // doesn&#39;t need to be clipped.  We use a double point comparison
231         // of 0.001 (1/1000th of a pixel) to account for any numerical
232         // discrepancies introduced when the available width was calculated.
233         // MenuItemSkinBase.doLayout, for example, does a number of double
234         // point operations when computing the available width.
235         final double stringWidth = computeTextWidth(font, text, 0);
236         if (stringWidth - width &lt; 0.0010F) {
237             return text;
238         }
239         // the width used by the ellipsis string
240         final double ellipsisWidth = computeTextWidth(font, ellipsis, 0);
241         // the available maximum width to fit chars into. This is essentially
242         // the width minus the space required for the ellipsis string
243         final double availableWidth = width - ellipsisWidth;
244 
245         if (width &lt; ellipsisWidth) {
246             // The ellipsis doesn&#39;t fit.
247             return &quot;&quot;;
248         }
249 
250         // if we got here, then we must clip the text with an ellipsis.
251         // this can be pretty expensive depending on whether &quot;complex&quot; text
252         // layout needs to be taken into account. So each ellipsis option has
253         // to take into account two code paths: the easy way and the correct
254         // way. This is flagged by the &quot;complexLayout&quot; boolean
255         // TODO make sure this function call takes into account ligatures, kerning,
256         // and such as that will change the layout characteristics of the text
257         // and will require a full complex layout
258         // TODO since we don&#39;t have all the stuff available in FX to determine
259         // complex text, I&#39;m going to for now assume complex text is always false.
260         final boolean complexLayout = false;
261         //requiresComplexLayout(font, text);
262 
263         // generally all we want to do is count characters and add their widths.
264         // For ellipsis that breaks on words, we do NOT want to include any
265         // hanging whitespace.
266         if (style == ELLIPSIS ||
267             style == WORD_ELLIPSIS ||
268             style == LEADING_ELLIPSIS ||
269             style == LEADING_WORD_ELLIPSIS) {
270 
271             final boolean wordTrim =
272                 (style == WORD_ELLIPSIS || style == LEADING_WORD_ELLIPSIS);
273             String substring;
274             if (complexLayout) {
275             //            AttributedString a = new AttributedString(text);
276             //            LineBreakMeasurer m = new LineBreakMeasurer(a.getIterator(), frc);
277             //            substring = text.substring(0, m.nextOffset((double)availableWidth));
278             } else {
279                 // RT-23458: Use a faster algorithm for the most common case
280                 // where truncation happens at the end, i.e. for ELLIPSIS and
281                 // CLIP, but not for other cases such as WORD_ELLIPSIS, etc.
282                 if (style == ELLIPSIS &amp;&amp; !new Bidi(text, Bidi.DIRECTION_LEFT_TO_RIGHT).isMixed()) {
283                     int hit = computeTruncationIndex(font, text, width - ellipsisWidth);
284                     if (hit &lt; 0 || hit &gt;= text.length()) {
285                         return text;
286                     } else {
287                         return text.substring(0, hit) + ellipsis;
288                     }
289                 }
290 
291                 // simply total up the widths of all chars to determine how many
292                 // will fit in the available space. Remember the last whitespace
293                 // encountered so that if we&#39;re breaking on words we can trim
294                 // and omit it.
295                 double total = 0.0F;
296                 int whitespaceIndex = -1;
297                 // at the termination of the loop, index will be one past the
298                 // end of the substring
299                 int index = 0;
300                 int start = (style == LEADING_ELLIPSIS || style == LEADING_WORD_ELLIPSIS) ? (text.length() - 1) : (0);
301                 int end = (start == 0) ? (text.length() - 1) : 0;
302                 int stepValue = (start == 0) ? 1 : -1;
303                 boolean done = (start == 0) ? start &gt; end : start &lt; end;
304                 for (int i = start; !done ; i += stepValue) {
305                     index = i;
306                     char c = text.charAt(index);
307                     total = computeTextWidth(font,
308                                              (start == 0) ? text.substring(0, i + 1)
309                                                           : text.substring(i, start + 1),
310                                              0);
311                     if (Character.isWhitespace(c)) {
312                         whitespaceIndex = index;
313                     }
314                     if (total &gt; availableWidth) {
315                         break;
316                     }
317                     done = start == 0? i &gt;= end : i &lt;= end;
318                 }
319                 final boolean fullTrim = !wordTrim || whitespaceIndex == -1;
320                 substring = (start == 0) ?
321                     (text.substring(0, fullTrim ? index : whitespaceIndex)) :
322                         (text.substring((fullTrim ? index : whitespaceIndex) + 1));
323                 assert(!text.equals(substring));
324             }
325             if (style == ELLIPSIS || style == WORD_ELLIPSIS) {
326                  return substring + ellipsis;
327             } else {
328                 //style is LEADING_ELLIPSIS or LEADING_WORD_ELLIPSIS
329                 return ellipsis + substring;
330             }
331         } else {
332             // these two indexes are INCLUSIVE not exclusive
333             int leadingIndex = 0;
334             int trailingIndex = 0;
335             int leadingWhitespace = -1;
336             int trailingWhitespace = -1;
337             // The complex case is going to be killer. What I have to do is
338             // read all the chars from the left up to the leadingIndex,
339             // and all the chars from the right up to the trailingIndex,
340             // and sum those together to get my total. That is, I cannot have
341             // a running total but must retotal the cummulative chars each time
342             if (complexLayout) {
343             } else /*            double leadingTotal = 0;
344                double trailingTotal = 0;
345                for (int i=0; i&lt;text.length(); i++) {
346                double total = computeStringWidth(metrics, text.substring(0, i));
347                if (total + trailingTotal &gt; availableWidth) break;
348                leadingIndex = i;
349                leadingTotal = total;
350                if (Character.isWhitespace(text.charAt(i))) leadingWhitespace = leadingIndex;
351 
352                int index = text.length() - (i + 1);
353                total = computeStringWidth(metrics, text.substring(index - 1));
354                if (total + leadingTotal &gt; availableWidth) break;
355                trailingIndex = index;
356                trailingTotal = total;
357                if (Character.isWhitespace(text.charAt(index))) trailingWhitespace = trailingIndex;
358                }*/
359             {
360                 // either CENTER_ELLIPSIS or CENTER_WORD_ELLIPSIS
361                 // for this case I read one char on the left, then one on the end
362                 // then second on the left, then second from the end, etc until
363                 // I have used up all the availableWidth. At that point, I trim
364                 // the string twice: once from the start to firstIndex, and
365                 // once from secondIndex to the end. I then insert the ellipsis
366                 // between the two.
367                 leadingIndex = -1;
368                 trailingIndex = -1;
369                 double total = 0.0F;
370                 for (int i = 0; i &lt;= text.length() - 1; i++) {
371                     char c = text.charAt(i);
372                     //total += metrics.charWidth(c);
373                     total += computeTextWidth(font, &quot;&quot; + c, 0);
374                     if (total &gt; availableWidth) {
375                         break;
376                     }
377                     leadingIndex = i;
378                     if (Character.isWhitespace(c)) {
379                         leadingWhitespace = leadingIndex;
380                     }
381                     int index = text.length() - 1 - i;
382                     c = text.charAt(index);
383                     //total += metrics.charWidth(c);
384                     total += computeTextWidth(font, &quot;&quot; + c, 0);
385                     if (total &gt; availableWidth) {
386                         break;
387                     }
388                     trailingIndex = index;
389                     if (Character.isWhitespace(c)) {
390                         trailingWhitespace = trailingIndex;
391                     }
392                 }
393             }
394             if (leadingIndex &lt; 0) {
395                 return ellipsis;
396             }
397             if (style == CENTER_ELLIPSIS) {
398                 if (trailingIndex &lt; 0) {
399                     return text.substring(0, leadingIndex + 1) + ellipsis;
400                 }
401                 return text.substring(0, leadingIndex + 1) + ellipsis + text.substring(trailingIndex);
402             } else {
403                 boolean leadingIndexIsLastLetterInWord =
404                     Character.isWhitespace(text.charAt(leadingIndex + 1));
405                 int index = (leadingWhitespace == -1 || leadingIndexIsLastLetterInWord) ? (leadingIndex + 1) : (leadingWhitespace);
406                 String leading = text.substring(0, index);
407                 if (trailingIndex &lt; 0) {
408                     return leading + ellipsis;
409                 }
410                 boolean trailingIndexIsFirstLetterInWord =
411                     Character.isWhitespace(text.charAt(trailingIndex - 1));
412                 index = (trailingWhitespace == -1 || trailingIndexIsFirstLetterInWord) ? (trailingIndex) : (trailingWhitespace + 1);
413                 String trailing = text.substring(index);
414                 return leading + ellipsis + trailing;
415             }
416         }
417     }
418 
419     public static String computeClippedWrappedText(Font font, String text, double width,
<a name="1" id="anc1"></a><span class="line-modified">420                                             double height, double lineSpacing, OverrunStyle truncationStyle,</span>
421                                             String ellipsisString, TextBoundsType boundsType) {
422         if (font == null) {
423             throw new IllegalArgumentException(&quot;Must specify a font&quot;);
424         }
425 
<a name="2" id="anc2"></a><span class="line-added">426         // The height given does not need to include the line spacing after</span>
<span class="line-added">427         // the last line to be able to render that last line correctly.</span>
<span class="line-added">428         //</span>
<span class="line-added">429         // However the calculations include the line spacing as part of a</span>
<span class="line-added">430         // line&#39;s height.  In order to not cut off the last line because its</span>
<span class="line-added">431         // line spacing wouldn&#39;t fit, the height used for the calculation</span>
<span class="line-added">432         // is increased here with the line spacing amount.</span>
<span class="line-added">433 </span>
<span class="line-added">434         height += lineSpacing;</span>
<span class="line-added">435 </span>
436         String ellipsis = (truncationStyle == CLIP) ? &quot;&quot; : ellipsisString;
437         int eLen = ellipsis.length();
438         // Do this before using helper, as it&#39;s not reentrant.
439         double eWidth = computeTextWidth(font, ellipsis, 0);
<a name="3" id="anc3"></a><span class="line-modified">440         double eHeight = computeTextHeight(font, ellipsis, 0, lineSpacing, boundsType);</span>
441 
442         if (width &lt; eWidth || height &lt; eHeight) {
443             // The ellipsis doesn&#39;t fit.
444             return text; // RT-30868 - return text, not empty string.
445         }
446 
447         helper.setText(text);
448         helper.setFont(font);
449         helper.setWrappingWidth((int)Math.ceil(width));
450         helper.setBoundsType(boundsType);
<a name="4" id="anc4"></a><span class="line-modified">451         helper.setLineSpacing(lineSpacing);</span>
452 
453         boolean leading =  (truncationStyle == LEADING_ELLIPSIS ||
454                             truncationStyle == LEADING_WORD_ELLIPSIS);
455         boolean center =   (truncationStyle == CENTER_ELLIPSIS ||
456                             truncationStyle == CENTER_WORD_ELLIPSIS);
457         boolean trailing = !(leading || center);
458         boolean wordTrim = (truncationStyle == WORD_ELLIPSIS ||
459                             truncationStyle == LEADING_WORD_ELLIPSIS ||
460                             truncationStyle == CENTER_WORD_ELLIPSIS);
461 
462         String result = text;
463         int len = (result != null) ? result.length() : 0;
464         int centerLen = -1;
465 
466         Point2D centerPoint = null;
467         if (center) {
468             // Find index of character in the middle of the visual text area
469             centerPoint = new Point2D((width - eWidth) / 2, height / 2 - helper.getBaselineOffset());
470         }
471 
472         // Find index of character at the bottom left of the text area.
473         // This should be the first character of a line that would be clipped.
474         Point2D endPoint = new Point2D(0, height - helper.getBaselineOffset());
475 
476         int hit = helper.hitTest(endPoint).getCharIndex();
477         if (hit &gt;= len) {
478             helper.setBoundsType(TextBoundsType.LOGICAL); // restore
479             return text;
480         }
481         if (center) {
482             hit = helper.hitTest(centerPoint).getCharIndex();
483         }
484 
485         if (hit &gt; 0 &amp;&amp; hit &lt; len) {
486             // Step one, make a truncation estimate.
487 
488             if (center || trailing) {
489                 int ind = hit;
490                 if (center) {
491                     // This is for the first part, i.e. beginning of text up to ellipsis.
492                     if (wordTrim) {
493                         int brInd = lastBreakCharIndex(text, ind + 1);
494                         if (brInd &gt;= 0) {
495                             ind = brInd + 1;
496                         } else {
497                             brInd = firstBreakCharIndex(text, ind);
498                             if (brInd &gt;= 0) {
499                                 ind = brInd + 1;
500                             }
501                         }
502                     }
503                     centerLen = ind + eLen;
504                 } // else: text node wraps at words, so wordTrim is not needed here.
505                 result = result.substring(0, ind) + ellipsis;
506             }
507 
508             if (leading || center) {
509                 // The hit is an index counted from the beginning, but we need
510                 // the opposite, i.e. an index counted from the end.  However,
511                 // the Text node does not support wrapped line layout in the
512                 // reverse direction, starting at the bottom right corner.
513 
514                 // We&#39;ll simulate by assuming the index will be a similar
515                 // number, then back up 10 characters just to add some slop.
516                 // For example, the ending lines might pack tighter than the
517                 // beginning lines, and therefore fit a higher number of
518                 // characters.
519                 int ind = Math.max(0, len - hit - 10);
520                 if (ind &gt; 0 &amp;&amp; wordTrim) {
521                     int brInd = lastBreakCharIndex(text, ind + 1);
522                     if (brInd &gt;= 0) {
523                         ind = brInd + 1;
524                     } else {
525                         brInd = firstBreakCharIndex(text, ind);
526                         if (brInd &gt;= 0) {
527                             ind = brInd + 1;
528                         }
529                     }
530                 }
531                 if (center) {
532                     // This is for the second part, i.e. from ellipsis to end of text.
533                     result = result + text.substring(ind);
534                 } else {
535                     result = ellipsis + text.substring(ind);
536                 }
537             }
538 
539             // Step two, check if text still overflows after we added the ellipsis.
540             // If so, remove one char or word at a time.
541             while (true) {
542                 helper.setText(result);
543                 int hit2 = helper.hitTest(endPoint).getCharIndex();
544                 if (center &amp;&amp; hit2 &lt; centerLen) {
545                     // No room for text after ellipsis. Maybe there is a newline
546                     // here, and the next line falls outside the view.
547                     if (hit2 &gt; 0 &amp;&amp; result.charAt(hit2-1) == &#39;\n&#39;) {
548                         hit2--;
549                     }
550                     result = text.substring(0, hit2) + ellipsis;
551                     break;
552                 } else if (hit2 &gt; 0 &amp;&amp; hit2 &lt; result.length()) {
553                     if (leading) {
554                         int ind = eLen + 1; // Past ellipsis and first char.
555                         if (wordTrim) {
556                             int brInd = firstBreakCharIndex(result, ind);
557                             if (brInd &gt;= 0) {
558                                 ind = brInd + 1;
559                             }
560                         }
561                         result = ellipsis + result.substring(ind);
562                     } else if (center) {
563                         int ind = centerLen + 1; // Past ellipsis and first char.
564                         if (wordTrim) {
565                             int brInd = firstBreakCharIndex(result, ind);
566                             if (brInd &gt;= 0) {
567                                 ind = brInd + 1;
568                             }
569                         }
570                         result = result.substring(0, centerLen) + result.substring(ind);
571                     } else {
572                         int ind = result.length() - eLen - 1; // Before last char and ellipsis.
573                         if (wordTrim) {
574                             int brInd = lastBreakCharIndex(result, ind);
575                             if (brInd &gt;= 0) {
576                                 ind = brInd;
577                             }
578                         }
579                         result = result.substring(0, ind) + ellipsis;
580                     }
581                 } else {
582                     break;
583                 }
584             }
585         }
586         // RESTORE STATE
587         helper.setWrappingWidth(DEFAULT_WRAPPING_WIDTH);
588         helper.setLineSpacing(DEFAULT_LINE_SPACING);
589         helper.setText(DEFAULT_TEXT);
590         helper.setBoundsType(DEFAULT_BOUNDS_TYPE);
591         return result;
592     }
593 
594 
595     private static int firstBreakCharIndex(String str, int start) {
596         char[] chars = str.toCharArray();
597         for (int i = start; i &lt; chars.length; i++) {
598             if (isPreferredBreakCharacter(chars[i])) {
599                 return i;
600             }
601         }
602         return -1;
603     }
604 
605     private static int lastBreakCharIndex(String str, int start) {
606         char[] chars = str.toCharArray();
607         for (int i = start; i &gt;= 0; i--) {
608             if (isPreferredBreakCharacter(chars[i])) {
609                 return i;
610             }
611         }
612         return -1;
613     }
614 
615     /* Recognizes white space and latin punctuation as preferred
616      * line break positions. Could do a bit better with using more
617      * of the properties from the Character class.
618      */
619     private static boolean isPreferredBreakCharacter(char ch) {
620         if (Character.isWhitespace(ch)) {
621             return true;
622         } else {
623             switch (ch) {
624             case &#39;;&#39; :
625             case &#39;:&#39; :
626             case &#39;.&#39; :
627                 return true;
628             default: return false;
629             }
630         }
631     }
632 
633     private static boolean requiresComplexLayout(Font font, String string) {
634         /*        Map attrs = font.getAttributes();
635            if (contains(attrs, KERNING, KERNING_ON) ||
636            contains(attrs, LIGATURES, LIGATURES_ON) ||
637            (attrs.containsKey(TRACKING) &amp;&amp; attrs.get(TRACKING) != null)) {
638            return true;
639            }
640            return isComplexLayout(string.toCharArray(), 0, string.length());
641          */
642         return false;
643     }
644 
645     static int computeStartOfWord(Font font, String text, int index) {
646         if (&quot;&quot;.equals(text) || index &lt; 0) return 0;
647         if (text.length() &lt;= index) return text.length();
648         // if the given index is not in a word (but in whitespace), then
649         // simply return the index
650         if (Character.isWhitespace(text.charAt(index))) {
651             return index;
652         }
653         boolean complexLayout = requiresComplexLayout(font, text);
654         if (complexLayout) {
655             // TODO needs implementation
656             return 0;
657         } else {
658             // just start walking backwards from index until either i&lt;0 or
659             // the first whitespace is found.
660             int i = index;
661             while (--i &gt;= 0) {
662                 if (Character.isWhitespace(text.charAt(i))) {
663                     return i + 1;
664                 }
665             }
666             return 0;
667         }
668     }
669 
670     static int computeEndOfWord(Font font, String text, int index) {
671         if (text.equals(&quot;&quot;) || index &lt; 0) {
672             return 0;
673         }
674         if (text.length() &lt;= index) {
675             return text.length();
676         }
677         // if the given index is not in a word (but in whitespace), then
678         // simply return the index
679         if (Character.isWhitespace(text.charAt(index))) {
680             return index;
681         }
682         boolean complexLayout = requiresComplexLayout(font, text);
683         if (complexLayout) {
684             // TODO needs implementation
685             return text.length();
686         } else {
687             // just start walking forward from index until either i &gt; length or
688             // the first whitespace is found.
689             int i = index;
690             while (++i &lt; text.length()) {
691                 if (Character.isWhitespace(text.charAt(i))) {
692                     return i;
693                 }
694             }
695             return text.length();
696         }
697     }
698 
699     // used for layout to adjust widths to honor the min/max policies consistently
700     public static double boundedSize(double value, double min, double max) {
701         // if max &lt; value, return max
702         // if min &gt; value, return min
703         // if min &gt; max, return min
704         return Math.min(Math.max(value, min), Math.max(min,max));
705     }
706 
707     public static void addMnemonics(ContextMenu popup, Scene scene) {
708         addMnemonics(popup, scene, false);
709     }
710 
711     public static void addMnemonics(ContextMenu popup, Scene scene, boolean initialState) {
712         addMnemonics(popup, scene, initialState, null);
713     }
714 
715     public static void addMnemonics(ContextMenu popup, Scene scene, boolean initialState, List&lt;Mnemonic&gt; into) {
716 
717         if (!com.sun.javafx.PlatformUtil.isMac()) {
718 
719             ContextMenuContent cmContent = (ContextMenuContent)popup.getSkin().getNode();
720             MenuItem menuitem;
721 
722             for (int i = 0 ; i &lt; popup.getItems().size() ; i++) {
723                 menuitem = popup.getItems().get(i);
724                 /*
725                 ** check is there are any mnemonics in this menu
726                 */
727                 if (menuitem.isMnemonicParsing()) {
728 
729                     TextBinding bindings = new TextBinding(menuitem.getText());
730                     int mnemonicIndex = bindings.getMnemonicIndex() ;
731                     if (mnemonicIndex &gt;= 0) {
732                         KeyCombination mnemonicKeyCombo = bindings.getMnemonicKeyCombination();
733                         Mnemonic myMnemonic = new Mnemonic(cmContent.getLabelAt(i), mnemonicKeyCombo);
734                         scene.addMnemonic(myMnemonic);
735                         NodeHelper.setShowMnemonics(cmContent.getLabelAt(i), initialState);
736                         if (into != null) {
737                             into.add(myMnemonic);
738                         }
739                     }
740                 }
741             }
742         }
743     }
744 
745 
746 
747     public static void removeMnemonics(ContextMenu popup, Scene scene) {
748 
749         if (!com.sun.javafx.PlatformUtil.isMac()) {
750 
751             ContextMenuContent cmContent = (ContextMenuContent)popup.getSkin().getNode();
752             MenuItem menuitem;
753 
754             for (int i = 0 ; i &lt; popup.getItems().size() ; i++) {
755                 menuitem = popup.getItems().get(i);
756                 /*
757                 ** check is there are any mnemonics in this menu
758                 */
759                 if (menuitem.isMnemonicParsing()) {
760 
761                     TextBinding bindings = new TextBinding(menuitem.getText());
762                     int mnemonicIndex = bindings.getMnemonicIndex() ;
763                     if (mnemonicIndex &gt;= 0) {
764                         KeyCombination mnemonicKeyCombo = bindings.getMnemonicKeyCombination();
765 
766                         ObservableList&lt;Mnemonic&gt; mnemonicsList = scene.getMnemonics().get(mnemonicKeyCombo);
767                         if (mnemonicsList != null) {
768                             for (int j = 0 ; j &lt; mnemonicsList.size() ; j++) {
769                                 if (mnemonicsList.get(j).getNode() == cmContent.getLabelAt(i)) {
770                                     mnemonicsList.remove(j);
771                                 }
772                             }
773                         }
774                     }
775                 }
776             }
777         }
778     }
779 
780     public static double computeXOffset(double width, double contentWidth, HPos hpos) {
781         if (hpos == null) {
782             return 0;
783         }
784 
785         switch(hpos) {
786             case LEFT:
787                return 0;
788             case CENTER:
789                return (width - contentWidth) / 2;
790             case RIGHT:
791                return width - contentWidth;
792             default:
793                 return 0;
794         }
795     }
796 
797     public static double computeYOffset(double height, double contentHeight, VPos vpos) {
798         if (vpos == null) {
799             return 0;
800         }
801 
802         switch(vpos) {
803             case TOP:
804                return 0;
805             case CENTER:
806                return (height - contentHeight) / 2;
807             case BOTTOM:
808                return height - contentHeight;
809             default:
810                 return 0;
811         }
812     }
813 
814     /*
815     ** Returns true if the platform is to use Two-Level-Focus.
816     ** This is in the Util class to ease any changes in
817     ** the criteria for enabling this feature.
818     **
819     ** TwoLevelFocus is needed on platforms that
820     ** only support 5-button navigation (arrow keys and Select/OK).
821     **
822     */
823     public static boolean isTwoLevelFocus() {
824         return Platform.isSupported(ConditionalFeature.TWO_LEVEL_FOCUS);
825     }
826 
827 
828     // useful method for linking things together when before a property is
829     // necessarily set
830     public static &lt;T&gt; void executeOnceWhenPropertyIsNonNull(ObservableValue&lt;T&gt; p, Consumer&lt;T&gt; consumer) {
831         if (p == null) return;
832 
833         T value = p.getValue();
834         if (value != null) {
835             consumer.accept(value);
836         } else {
837             final InvalidationListener listener = new InvalidationListener() {
838                 @Override public void invalidated(Observable observable) {
839                     T value = p.getValue();
840 
841                     if (value != null) {
842                         p.removeListener(this);
843                         consumer.accept(value);
844                     }
845                 }
846             };
847             p.addListener(listener);
848         }
849     }
850 
851     public static String formatHexString(Color c) {
852         if (c != null) {
853             return String.format((Locale) null, &quot;#%02x%02x%02x&quot;,
854                     Math.round(c.getRed() * 255),
855                     Math.round(c.getGreen() * 255),
856                     Math.round(c.getBlue() * 255));
857         } else {
858             return null;
859         }
860     }
861 
862     public static URL getResource(String str) {
863         return Utils.class.getResource(str);
864     }
865 
866 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/skin/Utils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * To change this template, choose Tools | Templates
 28  * and open the template in the editor.
 29  */
 30 
 31 package com.sun.javafx.scene.control.skin;
 32 
 33 import com.sun.javafx.scene.NodeHelper;
 34 import com.sun.javafx.scene.control.behavior.TextBinding;
 35 import com.sun.javafx.scene.text.TextLayout;
 36 import com.sun.javafx.tk.Toolkit;
 37 import javafx.application.ConditionalFeature;
 38 import javafx.application.Platform;
 39 import javafx.beans.InvalidationListener;
 40 import javafx.beans.Observable;
 41 import javafx.beans.value.ObservableValue;
 42 import javafx.collections.ObservableList;
 43 import javafx.geometry.Bounds;
 44 import javafx.geometry.HPos;
 45 import javafx.geometry.Point2D;
 46 import javafx.geometry.VPos;
 47 import javafx.scene.Scene;
 48 import javafx.scene.control.ContextMenu;
 49 import javafx.scene.control.MenuItem;
 50 import javafx.scene.control.OverrunStyle;
 51 import com.sun.javafx.scene.control.ContextMenuContent;
 52 import com.sun.javafx.scene.text.FontHelper;
 53 import java.net.URL;
 54 import javafx.scene.input.KeyCombination;
 55 import javafx.scene.input.Mnemonic;
 56 import javafx.scene.paint.Color;
 57 import javafx.scene.text.Font;
 58 import javafx.scene.text.Text;
 59 import javafx.scene.text.TextBoundsType;
 60 import javafx.scene.text.HitInfo;
 61 
 62 import java.text.Bidi;
 63 import java.util.List;
 64 import java.util.Locale;
 65 import java.util.function.Consumer;
 66 
 67 import static javafx.scene.control.OverrunStyle.CENTER_ELLIPSIS;
 68 import static javafx.scene.control.OverrunStyle.CENTER_WORD_ELLIPSIS;
 69 import static javafx.scene.control.OverrunStyle.CLIP;
 70 import static javafx.scene.control.OverrunStyle.ELLIPSIS;
 71 import static javafx.scene.control.OverrunStyle.LEADING_ELLIPSIS;
 72 import static javafx.scene.control.OverrunStyle.LEADING_WORD_ELLIPSIS;
 73 import static javafx.scene.control.OverrunStyle.WORD_ELLIPSIS;
 74 
 75 /**
 76  * BE REALLY CAREFUL WITH RESTORING OR RESETTING STATE OF helper NODE AS LEFTOVER
 77  * STATE CAUSES REALLY ODD NASTY BUGS!
 78  *
 79  * We expect all methods to set the Font property of helper but other than that
 80  * any properties set should be restored to defaults.
 81  */
 82 public class Utils {
 83 
 84     static final Text helper = new Text();
 85     static final double DEFAULT_WRAPPING_WIDTH = helper.getWrappingWidth();
 86     static final double DEFAULT_LINE_SPACING = helper.getLineSpacing();
 87     static final String DEFAULT_TEXT = helper.getText();
 88     static final TextBoundsType DEFAULT_BOUNDS_TYPE = helper.getBoundsType();
 89 
 90     /* Using TextLayout directly for simple text measurement.
 91      * Instead of restoring the TextLayout attributes to default values
 92      * (each renders the TextLayout unable to efficiently cache layout data).
 93      * It always sets all the attributes pertinent to calculation being performed.
 94      * Note that lineSpacing and boundsType are important when computing the height
 95      * but irrelevant when computing the width.
 96      *
 97      * Note: This code assumes that TextBoundsType#VISUAL is never used by controls.
 98      * */
 99     static final TextLayout layout = Toolkit.getToolkit().getTextLayoutFactory().createLayout();
100 
101     public static double getAscent(Font font, TextBoundsType boundsType) {
102         layout.setContent(&quot;&quot;, FontHelper.getNativeFont(font));
103         layout.setWrapWidth(0);
104         layout.setLineSpacing(0);
105         if (boundsType == TextBoundsType.LOGICAL_VERTICAL_CENTER) {
106             layout.setBoundsType(TextLayout.BOUNDS_CENTER);
107         } else {
108             layout.setBoundsType(0);
109         }
110         return -layout.getBounds().getMinY();
111     }
112 
113     public static double getLineHeight(Font font, TextBoundsType boundsType) {
114         layout.setContent(&quot;&quot;, FontHelper.getNativeFont(font));
115         layout.setWrapWidth(0);
116         layout.setLineSpacing(0);
117         if (boundsType == TextBoundsType.LOGICAL_VERTICAL_CENTER) {
118             layout.setBoundsType(TextLayout.BOUNDS_CENTER);
119         } else {
120             layout.setBoundsType(0);
121         }
122 
123         // RT-37092: Use the line bounds specifically, to include font leading.
124         return layout.getLines()[0].getBounds().getHeight();
125     }
126 
127     public static double computeTextWidth(Font font, String text, double wrappingWidth) {
128         layout.setContent(text != null ? text : &quot;&quot;, FontHelper.getNativeFont(font));
129         layout.setWrapWidth((float)wrappingWidth);
130         return layout.getBounds().getWidth();
131     }
132 
133     public static double computeTextHeight(Font font, String text, double wrappingWidth, TextBoundsType boundsType) {
134         return computeTextHeight(font, text, wrappingWidth, 0, boundsType);
135     }
136 
137     @SuppressWarnings(&quot;deprecation&quot;)
138     public static double computeTextHeight(Font font, String text, double wrappingWidth, double lineSpacing, TextBoundsType boundsType) {
139         layout.setContent(text != null ? text : &quot;&quot;, FontHelper.getNativeFont(font));
140         layout.setWrapWidth((float)wrappingWidth);
141         layout.setLineSpacing((float)lineSpacing);
142         if (boundsType == TextBoundsType.LOGICAL_VERTICAL_CENTER) {
143             layout.setBoundsType(TextLayout.BOUNDS_CENTER);
144         } else {
145             layout.setBoundsType(0);
146         }
147         return layout.getBounds().getHeight();
148     }
149 
150     public static Point2D computeMnemonicPosition(Font font, String text, int mnemonicIndex, double wrappingWidth,
<a name="2" id="anc2"></a><span class="line-modified">151                                                   double lineSpacing) {</span>
152         // Input validation
153         if ((font == null) || (text == null) ||
154             (mnemonicIndex &lt; 0) || (mnemonicIndex &gt; text.length())) {
155             return null;
156         }
157 
158         // Layout the text with given font, wrapping width and line spacing
159         layout.setContent(text, FontHelper.getNativeFont(font));
160         layout.setWrapWidth((float)wrappingWidth);
161         layout.setLineSpacing((float)lineSpacing);
162 
163         // The text could be spread over multiple lines
164         // We need to find out on which line the mnemonic character lies
165         int start = 0;
166         int i = 0;
167         int totalLines = layout.getLines().length;
<a name="3" id="anc3"></a>
168         while (i &lt; totalLines) {
<a name="4" id="anc4"></a><span class="line-modified">169             int lineLength = layout.getLines()[i].getLength();</span>
170 
171             if ((mnemonicIndex &gt;= start) &amp;&amp;
172                 (mnemonicIndex &lt; (start + lineLength))) {
173                 // mnemonic lies on line &#39;i&#39;
174                 break;
175             }
176 
177             start += lineLength;
178             i++;
179         }
180 
181         // Find x and y offsets of mnemonic character position
182         // in line numbered &#39;i&#39;
183         double lineHeight = layout.getBounds().getHeight() / totalLines;
184         double x = Utils.computeTextWidth(font, text.substring(start, mnemonicIndex), 0);
<a name="5" id="anc5"></a>



185 
186         double y = (lineHeight * (i+1));
187         // Adjust y offset for linespacing except for the last line.
188         if ((i+1) != totalLines) {
189             y -= (lineSpacing / 2);
190         }
191 
192         return new Point2D(x, y);
193     }
194 
195     public static int computeTruncationIndex(Font font, String text, double width) {
196         helper.setText(text);
197         helper.setFont(font);
198         helper.setWrappingWidth(0);
199         helper.setLineSpacing(0);
200         // The -2 is a fudge to make sure the result more often matches
201         // what we get from using computeTextWidth instead. It&#39;s not yet
202         // clear what causes the small discrepancies.
203         Bounds bounds = helper.getLayoutBounds();
204         Point2D endPoint = new Point2D(width - 2, bounds.getMinY() + bounds.getHeight() / 2);
205         final int index = helper.hitTest(endPoint).getCharIndex();
206         // RESTORE STATE
207         helper.setWrappingWidth(DEFAULT_WRAPPING_WIDTH);
208         helper.setLineSpacing(DEFAULT_LINE_SPACING);
209         helper.setText(DEFAULT_TEXT);
210         return index;
211     }
212 
213     public static String computeClippedText(Font font, String text, double width,
214                                      OverrunStyle type, String ellipsisString) {
215         if (font == null) {
216             throw new IllegalArgumentException(&quot;Must specify a font&quot;);
217         }
218         OverrunStyle style = (type == null || type == CLIP) ? ELLIPSIS : type;
219         final String ellipsis = (type == CLIP) ? &quot;&quot; : ellipsisString;
220         // if the text is empty or null or no ellipsis, then it always fits
221         if (text == null || &quot;&quot;.equals(text)) {
222             return text;
223         }
224         // if the string width is &lt; the available width, then it fits and
225         // doesn&#39;t need to be clipped.  We use a double point comparison
226         // of 0.001 (1/1000th of a pixel) to account for any numerical
227         // discrepancies introduced when the available width was calculated.
228         // MenuItemSkinBase.doLayout, for example, does a number of double
229         // point operations when computing the available width.
230         final double stringWidth = computeTextWidth(font, text, 0);
231         if (stringWidth - width &lt; 0.0010F) {
232             return text;
233         }
234         // the width used by the ellipsis string
235         final double ellipsisWidth = computeTextWidth(font, ellipsis, 0);
236         // the available maximum width to fit chars into. This is essentially
237         // the width minus the space required for the ellipsis string
238         final double availableWidth = width - ellipsisWidth;
239 
240         if (width &lt; ellipsisWidth) {
241             // The ellipsis doesn&#39;t fit.
242             return &quot;&quot;;
243         }
244 
245         // if we got here, then we must clip the text with an ellipsis.
246         // this can be pretty expensive depending on whether &quot;complex&quot; text
247         // layout needs to be taken into account. So each ellipsis option has
248         // to take into account two code paths: the easy way and the correct
249         // way. This is flagged by the &quot;complexLayout&quot; boolean
250         // TODO make sure this function call takes into account ligatures, kerning,
251         // and such as that will change the layout characteristics of the text
252         // and will require a full complex layout
253         // TODO since we don&#39;t have all the stuff available in FX to determine
254         // complex text, I&#39;m going to for now assume complex text is always false.
255         final boolean complexLayout = false;
256         //requiresComplexLayout(font, text);
257 
258         // generally all we want to do is count characters and add their widths.
259         // For ellipsis that breaks on words, we do NOT want to include any
260         // hanging whitespace.
261         if (style == ELLIPSIS ||
262             style == WORD_ELLIPSIS ||
263             style == LEADING_ELLIPSIS ||
264             style == LEADING_WORD_ELLIPSIS) {
265 
266             final boolean wordTrim =
267                 (style == WORD_ELLIPSIS || style == LEADING_WORD_ELLIPSIS);
268             String substring;
269             if (complexLayout) {
270             //            AttributedString a = new AttributedString(text);
271             //            LineBreakMeasurer m = new LineBreakMeasurer(a.getIterator(), frc);
272             //            substring = text.substring(0, m.nextOffset((double)availableWidth));
273             } else {
274                 // RT-23458: Use a faster algorithm for the most common case
275                 // where truncation happens at the end, i.e. for ELLIPSIS and
276                 // CLIP, but not for other cases such as WORD_ELLIPSIS, etc.
277                 if (style == ELLIPSIS &amp;&amp; !new Bidi(text, Bidi.DIRECTION_LEFT_TO_RIGHT).isMixed()) {
278                     int hit = computeTruncationIndex(font, text, width - ellipsisWidth);
279                     if (hit &lt; 0 || hit &gt;= text.length()) {
280                         return text;
281                     } else {
282                         return text.substring(0, hit) + ellipsis;
283                     }
284                 }
285 
286                 // simply total up the widths of all chars to determine how many
287                 // will fit in the available space. Remember the last whitespace
288                 // encountered so that if we&#39;re breaking on words we can trim
289                 // and omit it.
290                 double total = 0.0F;
291                 int whitespaceIndex = -1;
292                 // at the termination of the loop, index will be one past the
293                 // end of the substring
294                 int index = 0;
295                 int start = (style == LEADING_ELLIPSIS || style == LEADING_WORD_ELLIPSIS) ? (text.length() - 1) : (0);
296                 int end = (start == 0) ? (text.length() - 1) : 0;
297                 int stepValue = (start == 0) ? 1 : -1;
298                 boolean done = (start == 0) ? start &gt; end : start &lt; end;
299                 for (int i = start; !done ; i += stepValue) {
300                     index = i;
301                     char c = text.charAt(index);
302                     total = computeTextWidth(font,
303                                              (start == 0) ? text.substring(0, i + 1)
304                                                           : text.substring(i, start + 1),
305                                              0);
306                     if (Character.isWhitespace(c)) {
307                         whitespaceIndex = index;
308                     }
309                     if (total &gt; availableWidth) {
310                         break;
311                     }
312                     done = start == 0? i &gt;= end : i &lt;= end;
313                 }
314                 final boolean fullTrim = !wordTrim || whitespaceIndex == -1;
315                 substring = (start == 0) ?
316                     (text.substring(0, fullTrim ? index : whitespaceIndex)) :
317                         (text.substring((fullTrim ? index : whitespaceIndex) + 1));
318                 assert(!text.equals(substring));
319             }
320             if (style == ELLIPSIS || style == WORD_ELLIPSIS) {
321                  return substring + ellipsis;
322             } else {
323                 //style is LEADING_ELLIPSIS or LEADING_WORD_ELLIPSIS
324                 return ellipsis + substring;
325             }
326         } else {
327             // these two indexes are INCLUSIVE not exclusive
328             int leadingIndex = 0;
329             int trailingIndex = 0;
330             int leadingWhitespace = -1;
331             int trailingWhitespace = -1;
332             // The complex case is going to be killer. What I have to do is
333             // read all the chars from the left up to the leadingIndex,
334             // and all the chars from the right up to the trailingIndex,
335             // and sum those together to get my total. That is, I cannot have
336             // a running total but must retotal the cummulative chars each time
337             if (complexLayout) {
338             } else /*            double leadingTotal = 0;
339                double trailingTotal = 0;
340                for (int i=0; i&lt;text.length(); i++) {
341                double total = computeStringWidth(metrics, text.substring(0, i));
342                if (total + trailingTotal &gt; availableWidth) break;
343                leadingIndex = i;
344                leadingTotal = total;
345                if (Character.isWhitespace(text.charAt(i))) leadingWhitespace = leadingIndex;
346 
347                int index = text.length() - (i + 1);
348                total = computeStringWidth(metrics, text.substring(index - 1));
349                if (total + leadingTotal &gt; availableWidth) break;
350                trailingIndex = index;
351                trailingTotal = total;
352                if (Character.isWhitespace(text.charAt(index))) trailingWhitespace = trailingIndex;
353                }*/
354             {
355                 // either CENTER_ELLIPSIS or CENTER_WORD_ELLIPSIS
356                 // for this case I read one char on the left, then one on the end
357                 // then second on the left, then second from the end, etc until
358                 // I have used up all the availableWidth. At that point, I trim
359                 // the string twice: once from the start to firstIndex, and
360                 // once from secondIndex to the end. I then insert the ellipsis
361                 // between the two.
362                 leadingIndex = -1;
363                 trailingIndex = -1;
364                 double total = 0.0F;
365                 for (int i = 0; i &lt;= text.length() - 1; i++) {
366                     char c = text.charAt(i);
367                     //total += metrics.charWidth(c);
368                     total += computeTextWidth(font, &quot;&quot; + c, 0);
369                     if (total &gt; availableWidth) {
370                         break;
371                     }
372                     leadingIndex = i;
373                     if (Character.isWhitespace(c)) {
374                         leadingWhitespace = leadingIndex;
375                     }
376                     int index = text.length() - 1 - i;
377                     c = text.charAt(index);
378                     //total += metrics.charWidth(c);
379                     total += computeTextWidth(font, &quot;&quot; + c, 0);
380                     if (total &gt; availableWidth) {
381                         break;
382                     }
383                     trailingIndex = index;
384                     if (Character.isWhitespace(c)) {
385                         trailingWhitespace = trailingIndex;
386                     }
387                 }
388             }
389             if (leadingIndex &lt; 0) {
390                 return ellipsis;
391             }
392             if (style == CENTER_ELLIPSIS) {
393                 if (trailingIndex &lt; 0) {
394                     return text.substring(0, leadingIndex + 1) + ellipsis;
395                 }
396                 return text.substring(0, leadingIndex + 1) + ellipsis + text.substring(trailingIndex);
397             } else {
398                 boolean leadingIndexIsLastLetterInWord =
399                     Character.isWhitespace(text.charAt(leadingIndex + 1));
400                 int index = (leadingWhitespace == -1 || leadingIndexIsLastLetterInWord) ? (leadingIndex + 1) : (leadingWhitespace);
401                 String leading = text.substring(0, index);
402                 if (trailingIndex &lt; 0) {
403                     return leading + ellipsis;
404                 }
405                 boolean trailingIndexIsFirstLetterInWord =
406                     Character.isWhitespace(text.charAt(trailingIndex - 1));
407                 index = (trailingWhitespace == -1 || trailingIndexIsFirstLetterInWord) ? (trailingIndex) : (trailingWhitespace + 1);
408                 String trailing = text.substring(index);
409                 return leading + ellipsis + trailing;
410             }
411         }
412     }
413 
414     public static String computeClippedWrappedText(Font font, String text, double width,
415                                             double height, OverrunStyle truncationStyle,
416                                             String ellipsisString, TextBoundsType boundsType) {
417         if (font == null) {
418             throw new IllegalArgumentException(&quot;Must specify a font&quot;);
419         }
420 
421         String ellipsis = (truncationStyle == CLIP) ? &quot;&quot; : ellipsisString;
422         int eLen = ellipsis.length();
423         // Do this before using helper, as it&#39;s not reentrant.
424         double eWidth = computeTextWidth(font, ellipsis, 0);
425         double eHeight = computeTextHeight(font, ellipsis, 0, boundsType);
426 
427         if (width &lt; eWidth || height &lt; eHeight) {
428             // The ellipsis doesn&#39;t fit.
429             return text; // RT-30868 - return text, not empty string.
430         }
431 
432         helper.setText(text);
433         helper.setFont(font);
434         helper.setWrappingWidth((int)Math.ceil(width));
435         helper.setBoundsType(boundsType);
436         helper.setLineSpacing(0);
437 
438         boolean leading =  (truncationStyle == LEADING_ELLIPSIS ||
439                             truncationStyle == LEADING_WORD_ELLIPSIS);
440         boolean center =   (truncationStyle == CENTER_ELLIPSIS ||
441                             truncationStyle == CENTER_WORD_ELLIPSIS);
442         boolean trailing = !(leading || center);
443         boolean wordTrim = (truncationStyle == WORD_ELLIPSIS ||
444                             truncationStyle == LEADING_WORD_ELLIPSIS ||
445                             truncationStyle == CENTER_WORD_ELLIPSIS);
446 
447         String result = text;
448         int len = (result != null) ? result.length() : 0;
449         int centerLen = -1;
450 
451         Point2D centerPoint = null;
452         if (center) {
453             // Find index of character in the middle of the visual text area
454             centerPoint = new Point2D((width - eWidth) / 2, height / 2 - helper.getBaselineOffset());
455         }
456 
457         // Find index of character at the bottom left of the text area.
458         // This should be the first character of a line that would be clipped.
459         Point2D endPoint = new Point2D(0, height - helper.getBaselineOffset());
460 
461         int hit = helper.hitTest(endPoint).getCharIndex();
462         if (hit &gt;= len) {
463             helper.setBoundsType(TextBoundsType.LOGICAL); // restore
464             return text;
465         }
466         if (center) {
467             hit = helper.hitTest(centerPoint).getCharIndex();
468         }
469 
470         if (hit &gt; 0 &amp;&amp; hit &lt; len) {
471             // Step one, make a truncation estimate.
472 
473             if (center || trailing) {
474                 int ind = hit;
475                 if (center) {
476                     // This is for the first part, i.e. beginning of text up to ellipsis.
477                     if (wordTrim) {
478                         int brInd = lastBreakCharIndex(text, ind + 1);
479                         if (brInd &gt;= 0) {
480                             ind = brInd + 1;
481                         } else {
482                             brInd = firstBreakCharIndex(text, ind);
483                             if (brInd &gt;= 0) {
484                                 ind = brInd + 1;
485                             }
486                         }
487                     }
488                     centerLen = ind + eLen;
489                 } // else: text node wraps at words, so wordTrim is not needed here.
490                 result = result.substring(0, ind) + ellipsis;
491             }
492 
493             if (leading || center) {
494                 // The hit is an index counted from the beginning, but we need
495                 // the opposite, i.e. an index counted from the end.  However,
496                 // the Text node does not support wrapped line layout in the
497                 // reverse direction, starting at the bottom right corner.
498 
499                 // We&#39;ll simulate by assuming the index will be a similar
500                 // number, then back up 10 characters just to add some slop.
501                 // For example, the ending lines might pack tighter than the
502                 // beginning lines, and therefore fit a higher number of
503                 // characters.
504                 int ind = Math.max(0, len - hit - 10);
505                 if (ind &gt; 0 &amp;&amp; wordTrim) {
506                     int brInd = lastBreakCharIndex(text, ind + 1);
507                     if (brInd &gt;= 0) {
508                         ind = brInd + 1;
509                     } else {
510                         brInd = firstBreakCharIndex(text, ind);
511                         if (brInd &gt;= 0) {
512                             ind = brInd + 1;
513                         }
514                     }
515                 }
516                 if (center) {
517                     // This is for the second part, i.e. from ellipsis to end of text.
518                     result = result + text.substring(ind);
519                 } else {
520                     result = ellipsis + text.substring(ind);
521                 }
522             }
523 
524             // Step two, check if text still overflows after we added the ellipsis.
525             // If so, remove one char or word at a time.
526             while (true) {
527                 helper.setText(result);
528                 int hit2 = helper.hitTest(endPoint).getCharIndex();
529                 if (center &amp;&amp; hit2 &lt; centerLen) {
530                     // No room for text after ellipsis. Maybe there is a newline
531                     // here, and the next line falls outside the view.
532                     if (hit2 &gt; 0 &amp;&amp; result.charAt(hit2-1) == &#39;\n&#39;) {
533                         hit2--;
534                     }
535                     result = text.substring(0, hit2) + ellipsis;
536                     break;
537                 } else if (hit2 &gt; 0 &amp;&amp; hit2 &lt; result.length()) {
538                     if (leading) {
539                         int ind = eLen + 1; // Past ellipsis and first char.
540                         if (wordTrim) {
541                             int brInd = firstBreakCharIndex(result, ind);
542                             if (brInd &gt;= 0) {
543                                 ind = brInd + 1;
544                             }
545                         }
546                         result = ellipsis + result.substring(ind);
547                     } else if (center) {
548                         int ind = centerLen + 1; // Past ellipsis and first char.
549                         if (wordTrim) {
550                             int brInd = firstBreakCharIndex(result, ind);
551                             if (brInd &gt;= 0) {
552                                 ind = brInd + 1;
553                             }
554                         }
555                         result = result.substring(0, centerLen) + result.substring(ind);
556                     } else {
557                         int ind = result.length() - eLen - 1; // Before last char and ellipsis.
558                         if (wordTrim) {
559                             int brInd = lastBreakCharIndex(result, ind);
560                             if (brInd &gt;= 0) {
561                                 ind = brInd;
562                             }
563                         }
564                         result = result.substring(0, ind) + ellipsis;
565                     }
566                 } else {
567                     break;
568                 }
569             }
570         }
571         // RESTORE STATE
572         helper.setWrappingWidth(DEFAULT_WRAPPING_WIDTH);
573         helper.setLineSpacing(DEFAULT_LINE_SPACING);
574         helper.setText(DEFAULT_TEXT);
575         helper.setBoundsType(DEFAULT_BOUNDS_TYPE);
576         return result;
577     }
578 
579 
580     private static int firstBreakCharIndex(String str, int start) {
581         char[] chars = str.toCharArray();
582         for (int i = start; i &lt; chars.length; i++) {
583             if (isPreferredBreakCharacter(chars[i])) {
584                 return i;
585             }
586         }
587         return -1;
588     }
589 
590     private static int lastBreakCharIndex(String str, int start) {
591         char[] chars = str.toCharArray();
592         for (int i = start; i &gt;= 0; i--) {
593             if (isPreferredBreakCharacter(chars[i])) {
594                 return i;
595             }
596         }
597         return -1;
598     }
599 
600     /* Recognizes white space and latin punctuation as preferred
601      * line break positions. Could do a bit better with using more
602      * of the properties from the Character class.
603      */
604     private static boolean isPreferredBreakCharacter(char ch) {
605         if (Character.isWhitespace(ch)) {
606             return true;
607         } else {
608             switch (ch) {
609             case &#39;;&#39; :
610             case &#39;:&#39; :
611             case &#39;.&#39; :
612                 return true;
613             default: return false;
614             }
615         }
616     }
617 
618     private static boolean requiresComplexLayout(Font font, String string) {
619         /*        Map attrs = font.getAttributes();
620            if (contains(attrs, KERNING, KERNING_ON) ||
621            contains(attrs, LIGATURES, LIGATURES_ON) ||
622            (attrs.containsKey(TRACKING) &amp;&amp; attrs.get(TRACKING) != null)) {
623            return true;
624            }
625            return isComplexLayout(string.toCharArray(), 0, string.length());
626          */
627         return false;
628     }
629 
630     static int computeStartOfWord(Font font, String text, int index) {
631         if (&quot;&quot;.equals(text) || index &lt; 0) return 0;
632         if (text.length() &lt;= index) return text.length();
633         // if the given index is not in a word (but in whitespace), then
634         // simply return the index
635         if (Character.isWhitespace(text.charAt(index))) {
636             return index;
637         }
638         boolean complexLayout = requiresComplexLayout(font, text);
639         if (complexLayout) {
640             // TODO needs implementation
641             return 0;
642         } else {
643             // just start walking backwards from index until either i&lt;0 or
644             // the first whitespace is found.
645             int i = index;
646             while (--i &gt;= 0) {
647                 if (Character.isWhitespace(text.charAt(i))) {
648                     return i + 1;
649                 }
650             }
651             return 0;
652         }
653     }
654 
655     static int computeEndOfWord(Font font, String text, int index) {
656         if (text.equals(&quot;&quot;) || index &lt; 0) {
657             return 0;
658         }
659         if (text.length() &lt;= index) {
660             return text.length();
661         }
662         // if the given index is not in a word (but in whitespace), then
663         // simply return the index
664         if (Character.isWhitespace(text.charAt(index))) {
665             return index;
666         }
667         boolean complexLayout = requiresComplexLayout(font, text);
668         if (complexLayout) {
669             // TODO needs implementation
670             return text.length();
671         } else {
672             // just start walking forward from index until either i &gt; length or
673             // the first whitespace is found.
674             int i = index;
675             while (++i &lt; text.length()) {
676                 if (Character.isWhitespace(text.charAt(i))) {
677                     return i;
678                 }
679             }
680             return text.length();
681         }
682     }
683 
684     // used for layout to adjust widths to honor the min/max policies consistently
685     public static double boundedSize(double value, double min, double max) {
686         // if max &lt; value, return max
687         // if min &gt; value, return min
688         // if min &gt; max, return min
689         return Math.min(Math.max(value, min), Math.max(min,max));
690     }
691 
692     public static void addMnemonics(ContextMenu popup, Scene scene) {
693         addMnemonics(popup, scene, false);
694     }
695 
696     public static void addMnemonics(ContextMenu popup, Scene scene, boolean initialState) {
697         addMnemonics(popup, scene, initialState, null);
698     }
699 
700     public static void addMnemonics(ContextMenu popup, Scene scene, boolean initialState, List&lt;Mnemonic&gt; into) {
701 
702         if (!com.sun.javafx.PlatformUtil.isMac()) {
703 
704             ContextMenuContent cmContent = (ContextMenuContent)popup.getSkin().getNode();
705             MenuItem menuitem;
706 
707             for (int i = 0 ; i &lt; popup.getItems().size() ; i++) {
708                 menuitem = popup.getItems().get(i);
709                 /*
710                 ** check is there are any mnemonics in this menu
711                 */
712                 if (menuitem.isMnemonicParsing()) {
713 
714                     TextBinding bindings = new TextBinding(menuitem.getText());
715                     int mnemonicIndex = bindings.getMnemonicIndex() ;
716                     if (mnemonicIndex &gt;= 0) {
717                         KeyCombination mnemonicKeyCombo = bindings.getMnemonicKeyCombination();
718                         Mnemonic myMnemonic = new Mnemonic(cmContent.getLabelAt(i), mnemonicKeyCombo);
719                         scene.addMnemonic(myMnemonic);
720                         NodeHelper.setShowMnemonics(cmContent.getLabelAt(i), initialState);
721                         if (into != null) {
722                             into.add(myMnemonic);
723                         }
724                     }
725                 }
726             }
727         }
728     }
729 
730 
731 
732     public static void removeMnemonics(ContextMenu popup, Scene scene) {
733 
734         if (!com.sun.javafx.PlatformUtil.isMac()) {
735 
736             ContextMenuContent cmContent = (ContextMenuContent)popup.getSkin().getNode();
737             MenuItem menuitem;
738 
739             for (int i = 0 ; i &lt; popup.getItems().size() ; i++) {
740                 menuitem = popup.getItems().get(i);
741                 /*
742                 ** check is there are any mnemonics in this menu
743                 */
744                 if (menuitem.isMnemonicParsing()) {
745 
746                     TextBinding bindings = new TextBinding(menuitem.getText());
747                     int mnemonicIndex = bindings.getMnemonicIndex() ;
748                     if (mnemonicIndex &gt;= 0) {
749                         KeyCombination mnemonicKeyCombo = bindings.getMnemonicKeyCombination();
750 
751                         ObservableList&lt;Mnemonic&gt; mnemonicsList = scene.getMnemonics().get(mnemonicKeyCombo);
752                         if (mnemonicsList != null) {
753                             for (int j = 0 ; j &lt; mnemonicsList.size() ; j++) {
754                                 if (mnemonicsList.get(j).getNode() == cmContent.getLabelAt(i)) {
755                                     mnemonicsList.remove(j);
756                                 }
757                             }
758                         }
759                     }
760                 }
761             }
762         }
763     }
764 
765     public static double computeXOffset(double width, double contentWidth, HPos hpos) {
766         if (hpos == null) {
767             return 0;
768         }
769 
770         switch(hpos) {
771             case LEFT:
772                return 0;
773             case CENTER:
774                return (width - contentWidth) / 2;
775             case RIGHT:
776                return width - contentWidth;
777             default:
778                 return 0;
779         }
780     }
781 
782     public static double computeYOffset(double height, double contentHeight, VPos vpos) {
783         if (vpos == null) {
784             return 0;
785         }
786 
787         switch(vpos) {
788             case TOP:
789                return 0;
790             case CENTER:
791                return (height - contentHeight) / 2;
792             case BOTTOM:
793                return height - contentHeight;
794             default:
795                 return 0;
796         }
797     }
798 
799     /*
800     ** Returns true if the platform is to use Two-Level-Focus.
801     ** This is in the Util class to ease any changes in
802     ** the criteria for enabling this feature.
803     **
804     ** TwoLevelFocus is needed on platforms that
805     ** only support 5-button navigation (arrow keys and Select/OK).
806     **
807     */
808     public static boolean isTwoLevelFocus() {
809         return Platform.isSupported(ConditionalFeature.TWO_LEVEL_FOCUS);
810     }
811 
812 
813     // useful method for linking things together when before a property is
814     // necessarily set
815     public static &lt;T&gt; void executeOnceWhenPropertyIsNonNull(ObservableValue&lt;T&gt; p, Consumer&lt;T&gt; consumer) {
816         if (p == null) return;
817 
818         T value = p.getValue();
819         if (value != null) {
820             consumer.accept(value);
821         } else {
822             final InvalidationListener listener = new InvalidationListener() {
823                 @Override public void invalidated(Observable observable) {
824                     T value = p.getValue();
825 
826                     if (value != null) {
827                         p.removeListener(this);
828                         consumer.accept(value);
829                     }
830                 }
831             };
832             p.addListener(listener);
833         }
834     }
835 
836     public static String formatHexString(Color c) {
837         if (c != null) {
838             return String.format((Locale) null, &quot;#%02x%02x%02x&quot;,
839                     Math.round(c.getRed() * 255),
840                     Math.round(c.getGreen() * 255),
841                     Math.round(c.getBlue() * 255));
842         } else {
843             return null;
844         }
845     }
846 
847     public static URL getResource(String str) {
848         return Utils.class.getResource(str);
849     }
850 
851 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
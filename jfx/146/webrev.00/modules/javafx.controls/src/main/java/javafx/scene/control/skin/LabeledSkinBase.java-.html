<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.controls/src/main/java/javafx/scene/control/skin/LabeledSkinBase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control.skin;
  27 
  28 import com.sun.javafx.scene.control.LabeledText;
  29 import com.sun.javafx.scene.control.behavior.TextBinding;
  30 import com.sun.javafx.scene.control.skin.Utils;
  31 import javafx.application.Platform;
  32 import javafx.beans.InvalidationListener;
  33 import javafx.geometry.HPos;
  34 import javafx.geometry.NodeOrientation;
  35 import javafx.geometry.Orientation;
  36 import javafx.geometry.Point2D;
  37 import javafx.geometry.Pos;
  38 import javafx.geometry.VPos;
  39 import javafx.scene.AccessibleAttribute;
  40 import javafx.scene.Node;
  41 import javafx.scene.Scene;
  42 import javafx.scene.control.Accordion;
  43 import javafx.scene.control.ContentDisplay;
  44 import javafx.scene.control.Control;
  45 import javafx.scene.control.Label;
  46 import javafx.scene.control.Labeled;
  47 import javafx.scene.control.OverrunStyle;
  48 import javafx.scene.control.SkinBase;
  49 import javafx.scene.image.ImageView;
  50 import javafx.scene.input.KeyCombination;
  51 import javafx.scene.input.Mnemonic;
  52 import javafx.scene.shape.Line;
  53 import javafx.scene.shape.Rectangle;
  54 import javafx.scene.text.Font;
  55 
  56 import static javafx.scene.control.ContentDisplay.BOTTOM;
  57 import static javafx.scene.control.ContentDisplay.LEFT;
  58 import static javafx.scene.control.ContentDisplay.RIGHT;
  59 import static javafx.scene.control.ContentDisplay.TOP;
  60 import static javafx.scene.control.OverrunStyle.CLIP;
  61 
  62 /**
  63  * Default skin implementation for controls extends {@link Labeled}.
  64  *
  65  * @see Labeled
  66  * @since 9
  67  */
  68 public abstract class LabeledSkinBase&lt;C extends Labeled&gt; extends SkinBase&lt;C&gt; {
  69 
  70     /***************************************************************************
  71      *                                                                         *
  72      * Private fields                                                          *
  73      *                                                                         *
  74      **************************************************************************/
  75 
  76     /**
  77      *  The Text node used to display the text. This is package only
  78      *  for the sake of testing!
  79      */
  80     LabeledText text;
  81 
  82     /**
  83      * Indicates that the text content is invalid and needs to be updated.
  84      * This is package private only for the sake of testing.
  85      */
  86     boolean invalidText = true;
  87 
  88     /**
  89      * A reference to the last-known graphic on the Labeled. This reference
  90      * is kept so that we can remove listeners from the old graphic later
  91      */
  92     Node graphic;
  93 
  94     /**
  95      * The cached full width of the non-truncated text. We only want to
  96      * recompute this if the text has itself changed, or if the font has changed.
  97      * This is package private ONLY FOR THE SAKE OF TESTING
  98      */
  99     double textWidth = Double.NEGATIVE_INFINITY;
 100 
 101     /**
 102      * The cached width of the ellipsis string. This will be recomputed
 103      * if the font or the ellipsisString property have changed.
 104      * This is package private ONLY FOR THE SAKE OF TESTING
 105      */
 106     double ellipsisWidth = Double.NEGATIVE_INFINITY;
 107 
 108     /**
 109      * A listener which is applied to the graphic whenever the graphic is set
 110      * and is visible within the labeled. For example, if there is a graphic
 111      * defined on the Labeled but the ContentDisplay is set to TEXT_ONLY, then
 112      * we will not bother installing this listener on the graphic. In all
 113      * other cases, if the graphic is defined, it will have this listener
 114      * added to it, which ensures that if the graphic&#39;s layout bounds change,
 115      * we end up performing a layout and potentially update the visible text.
 116      *
 117      * This is package private ONLY FOR THE SAKE OF TESTING
 118      */
 119     final InvalidationListener graphicPropertyChangedListener = valueModel -&gt; {
 120         invalidText = true;
 121         if (getSkinnable() != null) getSkinnable().requestLayout();
 122     };
 123 
 124     private Rectangle textClip;
 125     private double wrapWidth;
 126     private double wrapHeight;
 127 
 128     private TextBinding bindings;
 129     private Line mnemonic_underscore;
 130 
 131     private boolean containsMnemonic = false;
 132     private Scene mnemonicScene = null;
 133     private KeyCombination mnemonicCode;
 134     // needs to be an object, as MenuItem isn&#39;t a node
 135     private Node labeledNode = null;
 136 
 137 
 138 
 139     /***************************************************************************
 140      *                                                                         *
 141      * Constructors                                                            *
 142      *                                                                         *
 143      **************************************************************************/
 144 
 145     /**
 146      * Constructor for LabeledSkinBase. The Labeled must be specified, and cannot be null.
 147      * At the conclusion of the constructor call, the skin will be marked as
 148      * needsLayout, and will be fully configured based on the current state of
 149      * the labeled. Any subsequent changes to the Labeled will be handled via
 150      * listeners and applied appropriately.
 151      *
 152      * @param labeled The labeled that this skin should be installed onto.
 153      */
 154     public LabeledSkinBase(final C labeled) {
 155         super(labeled);
 156 
 157         // Configure the Text node with all of the attributes from the
 158         // Labeled which apply to it.
 159         text = new LabeledText(labeled);
 160 
 161         updateChildren();
 162 
 163         // Labels do not block the mouse by default, unlike most other UI Controls.
 164         //consumeMouseEvents(false);
 165 
 166         // Register listeners
 167         /*
 168          * There are basically 2 things to worry about in each of these handlers
 169          *  1) Update the Text node
 170          *  2) Have the text metrics changed?
 171          *
 172          * If the metrics have changed, we need to request a layout and invalidate
 173          * the text so that we recompute the display text on next read.
 174          */
 175         registerChangeListener(labeled.ellipsisStringProperty(), o -&gt; {
 176             textMetricsChanged();
 177             invalidateWidths();
 178             ellipsisWidth = Double.NEGATIVE_INFINITY;
 179         });
 180         registerChangeListener(labeled.widthProperty(), o -&gt; {
 181             updateWrappingWidth();
 182             invalidText = true;
 183             // No requestLayout() because Control will force a layout
 184         });
 185         registerChangeListener(labeled.heightProperty(), o -&gt; {
 186             invalidText = true;
 187             // No requestLayout() because Control will force a layout
 188         });
 189         registerChangeListener(labeled.fontProperty(), o -&gt; {
 190             textMetricsChanged();
 191             invalidateWidths();
 192             ellipsisWidth = Double.NEGATIVE_INFINITY;
 193         });
 194         registerChangeListener(labeled.graphicProperty(), o -&gt; {
 195             updateChildren();
 196             textMetricsChanged();
 197         });
 198         registerChangeListener(labeled.contentDisplayProperty(), o -&gt; {
 199             updateChildren();
 200             textMetricsChanged();
 201         });
 202         registerChangeListener(labeled.labelPaddingProperty(), o -&gt; textMetricsChanged());
 203         registerChangeListener(labeled.graphicTextGapProperty(), o -&gt; textMetricsChanged());
 204         registerChangeListener(labeled.alignmentProperty(), o -&gt; {
 205             // Doesn&#39;t involve text metrics because if the text is too long, then
 206             // it will already have fit all available width and a change to hpos
 207             // has no effect. Or it is too short (i.e. it all fits) and we don&#39;t
 208             // have to worry about truncation. So just call request layout.
 209             // Doesn&#39;t involve text metrics because if the text is too long, then
 210             // it will already have fit all available height and a change to vpos
 211             // has no effect. Or it is too short (i.e. it all fits) and we don&#39;t
 212             // have to worry about truncation. So just call request layout.
 213             getSkinnable().requestLayout();
 214         });
 215         registerChangeListener(labeled.mnemonicParsingProperty(), o -&gt; {
 216             containsMnemonic = false;
 217             textMetricsChanged();
 218         });
 219         registerChangeListener(labeled.textProperty(), o -&gt; {
 220             updateChildren();
 221             textMetricsChanged();
 222             invalidateWidths();
 223         });
 224         registerChangeListener(labeled.textAlignmentProperty(), o -&gt; { /* NO-OP */ });
 225         registerChangeListener(labeled.textOverrunProperty(), o -&gt; textMetricsChanged());
 226         registerChangeListener(labeled.wrapTextProperty(), o -&gt; {
 227             updateWrappingWidth();
 228             textMetricsChanged();
 229         });
 230         registerChangeListener(labeled.underlineProperty(), o -&gt; textMetricsChanged());
 231         registerChangeListener(labeled.lineSpacingProperty(), o -&gt; textMetricsChanged());
 232         registerChangeListener(labeled.sceneProperty(), o -&gt; sceneChanged());
 233     }
 234 
 235 
 236 
 237     /***************************************************************************
 238      *                                                                         *
 239      * Public API                                                              *
 240      *                                                                         *
 241      **************************************************************************/
 242 
 243     /**
 244      * Updates the children managed by LabeledSkinBase, which can be the Labeled
 245      * graphic and/or a Text node. Only those nodes which actually must
 246      * be used are used. For example, with a ContentDisplay of
 247      * GRAPHIC_ONLY the text node is not added, and with a ContentDisplay
 248      * of TEXT_ONLY, the graphic is not added.
 249      */
 250     protected void updateChildren() {
 251         final Labeled labeled = getSkinnable();
 252         // Only in some situations do we want to have the graphicPropertyChangedListener
 253         // installed. Since updateChildren() is not called much, we&#39;ll just remove it always
 254         // and reinstall it later if it is necessary to do so.
 255         if (graphic != null) {
 256             graphic.layoutBoundsProperty().removeListener(graphicPropertyChangedListener);
 257         }
 258         // Now update the graphic (since it may have changed)
 259         graphic = labeled.getGraphic();
 260 
 261         // RT-19851 Only setMouseTransparent(true) for an ImageView.  This allows the button
 262         // to be picked regardless of the changing images on top of it.
 263         if (graphic instanceof ImageView) {
 264             graphic.setMouseTransparent(true);
 265         }
 266 
 267         // Now update the children (and add the graphicPropertyChangedListener as necessary)
 268         if (isIgnoreGraphic()) {
 269             if (labeled.getContentDisplay() == ContentDisplay.GRAPHIC_ONLY) {
 270                 getChildren().clear();
 271             } else {
 272                 getChildren().setAll(text);
 273             }
 274         } else {
 275             graphic.layoutBoundsProperty().addListener(graphicPropertyChangedListener);
 276             if (isIgnoreText()) {
 277                 getChildren().setAll(graphic);
 278             } else {
 279                 getChildren().setAll(graphic, text);
 280             }
 281         }
 282     }
 283 
 284     /**
 285      * Compute and return the minimum width of this Labeled. The minimum width is
 286      * the smaller of the width of &quot;...&quot; and the width with the actual text.
 287      * In this way, if the text width itself is smaller than the ellipsis then
 288      * we should use that as the min width, otherwise the ellipsis needs to be the
 289      * min width.
 290      * &lt;p&gt;
 291      * We use the same calculation here regardless of whether we are talking
 292      * about a single or multiline labeled. So a multiline labeled may find that
 293      * the width of the &quot;...&quot; is as small as it will ever get.
 294      */
 295     @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
 296         return computeMinLabeledPartWidth(height, topInset, rightInset, bottomInset, leftInset);
 297     }
 298 
 299     /** {@inheritDoc} */
 300     @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
 301         return computeMinLabeledPartHeight(width, topInset, rightInset, bottomInset, leftInset);
 302     }
 303 
 304     /** {@inheritDoc} */
 305     @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
 306         // Get the preferred width of the text
 307         final Labeled labeled = getSkinnable();
 308         final Font font = text.getFont();
 309         String string = labeled.getText();
 310         boolean emptyText = string == null || string.isEmpty();
 311         double widthPadding = leftInset + rightInset;
 312 
 313         if (!isIgnoreText()) {
 314             widthPadding += leftLabelPadding() + rightLabelPadding();
 315         }
 316 
 317         double textWidth = 0.0;
 318         if (!emptyText) {
 319             if (labeled.isMnemonicParsing()) {
 320                 if (string.contains(&quot;_&quot;) &amp;&amp; (string.indexOf(&quot;_&quot;) != string.length()-1)) {
 321                     string = string.replaceFirst(&quot;_&quot;, &quot;&quot;);
 322                 }
 323             }
 324             textWidth = Utils.computeTextWidth(font, string, 0);
 325         }
 326 
 327         // Fix for RT-39889
 328         double graphicWidth = graphic == null ? 0.0 :
 329                 Utils.boundedSize(graphic.prefWidth(-1), graphic.minWidth(-1), graphic.maxWidth(-1));
 330 
 331         // Now add on the graphic, gap, and padding as appropriate
 332         if (isIgnoreGraphic()) {
 333             return textWidth + widthPadding;
 334         } else if (isIgnoreText()) {
 335             return graphicWidth + widthPadding;
 336         } else if (labeled.getContentDisplay() == ContentDisplay.LEFT
 337                 || labeled.getContentDisplay() == ContentDisplay.RIGHT) {
 338             return textWidth + labeled.getGraphicTextGap() + graphicWidth + widthPadding;
 339         } else {
 340             return Math.max(textWidth, graphicWidth) + widthPadding;
 341         }
 342     }
 343 
 344     /** {@inheritDoc} */
 345     @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
 346         final Labeled labeled = getSkinnable();
 347         final Font font = text.getFont();
 348         final ContentDisplay contentDisplay = labeled.getContentDisplay();
 349         final double gap = labeled.getGraphicTextGap();
 350 
 351         width -= leftInset + rightInset;
 352 
 353         if (!isIgnoreText()) {
 354             width -= leftLabelPadding() + rightLabelPadding();
 355         }
 356 
 357         String str = labeled.getText();
 358         if (str != null &amp;&amp; str.endsWith(&quot;\n&quot;)) {
 359             // Strip ending newline so we don&#39;t count another row.
 360             str = str.substring(0, str.length() - 1);
 361         }
 362 
 363         double textWidth = width;
 364         if (!isIgnoreGraphic() &amp;&amp;
 365                 (contentDisplay == LEFT || contentDisplay == RIGHT)) {
 366             textWidth -= (graphic.prefWidth(-1) + gap);
 367         }
 368 
 369         // TODO figure out how to cache this effectively.
 370         final double textHeight = Utils.computeTextHeight(font, str,
 371                 labeled.isWrapText() ? textWidth : 0,
 372                 labeled.getLineSpacing(), text.getBoundsType());
 373 
 374         // Now we want to add on the graphic if necessary!
 375         double h = textHeight;
 376         if (!isIgnoreGraphic()) {
 377             final Node graphic = labeled.getGraphic();
 378             if (contentDisplay == TOP || contentDisplay == BOTTOM) {
 379                 h = graphic.prefHeight(width) + gap + textHeight;
 380             } else {
 381                 h = Math.max(textHeight, graphic.prefHeight(width));
 382             }
 383         }
 384 
 385         double padding = topInset + bottomInset;
 386 
 387         if (!isIgnoreText()) {
 388             padding += topLabelPadding() + bottomLabelPadding();
 389         }
 390 
 391         return  h + padding;
 392     }
 393 
 394     /** {@inheritDoc} */
 395     @Override protected double computeMaxWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
 396         return getSkinnable().prefWidth(height);
 397     }
 398 
 399     /** {@inheritDoc} */
 400     @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
 401         return getSkinnable().prefHeight(width);
 402     }
 403 
 404     /** {@inheritDoc} */
 405     @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
 406         double textBaselineOffset = text.getBaselineOffset();
 407         double h = textBaselineOffset;
 408         final Labeled labeled = getSkinnable();
 409         final Node g = labeled.getGraphic();
 410         if (!isIgnoreGraphic()) {
 411             ContentDisplay contentDisplay = labeled.getContentDisplay();
 412             if (contentDisplay == ContentDisplay.TOP) {
 413                 h = g.prefHeight(-1) + labeled.getGraphicTextGap() + textBaselineOffset;
 414             } else if (contentDisplay == ContentDisplay.LEFT || contentDisplay == RIGHT) {
 415                 h = textBaselineOffset + (g.prefHeight(-1) - text.prefHeight(-1)) / 2;
 416             }
 417         }
 418 
 419         double offset = topInset + h;
 420         if (!isIgnoreText()) {
 421             offset += topLabelPadding();
 422         }
 423         return offset;
 424     }
 425 
 426     /**
 427      * The Layout algorithm works like this:
 428      *
 429      *  - Get the labeled w/h, graphic w/h, text w/h
 430      *  - Compute content w/h based on graphicVPos, graphicHPos,
 431      *    graphicTextGap, and graphic w/h and text w/h
 432      *  - (Note that the text content has been pre-truncated where
 433      *    necessary)
 434      *  - compute content x/y based on content w/h and labeled w/h
 435      *    and the labeled&#39;s hpos and vpos
 436      *  - position the graphic and text
 437      */
 438     @Override protected void layoutChildren(final double x, final double y,
 439                                             final double w, final double h) {
 440         layoutLabelInArea(x, y, w, h);
 441     }
 442 
 443     /**
 444      * Performs the actual layout of the label content within the area given.
 445      * This method is called by subclasses that override layoutChildren().
 446      *
 447      * @param x The x position of the label part of the control, inside padding
 448      *
 449      * @param y The y position of the label part of the control, inside padding
 450      *
 451      * @param w The width of the label part of the control, not including padding
 452      *
 453      * @param h The height of the label part of the control, not including padding
 454      */
 455     protected void layoutLabelInArea(double x, double y, double w, double h) {
 456         layoutLabelInArea(x, y, w, h, null);
 457     }
 458 
 459     /**
 460      * Performs the actual layout of the label content within the area given.
 461      * This method is called by subclasses that override layoutChildren().
 462      *
 463      * @param x The x position of the label part of the control, inside padding
 464      *
 465      * @param y The y position of the label part of the control, inside padding
 466      *
 467      * @param w The width of the label part of the control, not including padding
 468      *
 469      * @param h The height of the label part of the control, not including padding
 470      *
 471      * @param alignment The alignment of the label part of the control within the given area. If null, then the control&#39;s alignment will be used.
 472      */
 473     protected void layoutLabelInArea(double x, double y, double w, double h, Pos alignment) {
 474         // References to essential labeled state
 475         final Labeled labeled = getSkinnable();
 476         final ContentDisplay contentDisplay = labeled.getContentDisplay();
 477 
 478         if (alignment == null) {
 479             alignment = labeled.getAlignment();
 480         }
 481 
 482         final HPos hpos = alignment == null ? HPos.LEFT   : alignment.getHpos();
 483         final VPos vpos = alignment == null ? VPos.CENTER : alignment.getVpos();
 484 
 485         // Figure out whether we should ignore the Graphic, and/or
 486         // ignore the Text
 487         final boolean ignoreGraphic = isIgnoreGraphic();
 488         final boolean ignoreText = isIgnoreText();
 489 
 490         if (!ignoreText) {
 491             x += leftLabelPadding();
 492             y += topLabelPadding();
 493             w -= leftLabelPadding() + rightLabelPadding();
 494             h -= topLabelPadding() + bottomLabelPadding();
 495         }
 496 
 497         // Compute some standard useful numbers for the graphic, text, and gap
 498         double graphicWidth;
 499         double graphicHeight;
 500         double textWidth;
 501         double textHeight;
 502 
 503         if (ignoreGraphic) {
 504             graphicWidth = graphicHeight = 0;
 505         } else if (ignoreText) {
 506             if (graphic.isResizable()) {
 507                 Orientation contentBias = graphic.getContentBias();
 508                 if (contentBias == Orientation.HORIZONTAL) {
 509                     graphicWidth  = Utils.boundedSize(w, graphic.minWidth(-1), graphic.maxWidth(-1));
 510                     graphicHeight = Utils.boundedSize(h, graphic.minHeight(graphicWidth), graphic.maxHeight(graphicWidth));
 511                 } else if (contentBias == Orientation.VERTICAL) {
 512                     graphicHeight = Utils.boundedSize(h, graphic.minHeight(-1), graphic.maxHeight(-1));
 513                     graphicWidth  = Utils.boundedSize(w, graphic.minWidth(graphicHeight), graphic.maxWidth(graphicHeight));
 514                 } else {
 515                     graphicWidth  = Utils.boundedSize(w, graphic.minWidth(-1), graphic.maxWidth(-1));
 516                     graphicHeight = Utils.boundedSize(h, graphic.minHeight(-1), graphic.maxHeight(-1));
 517                 }
 518                 graphic.resize(graphicWidth, graphicHeight);
 519             } else {
 520                 graphicWidth = graphic.getLayoutBounds().getWidth();
 521                 graphicHeight = graphic.getLayoutBounds().getHeight();
 522             }
 523         } else {
 524             graphic.autosize(); // We have to do this before getting metrics
 525             graphicWidth = graphic.getLayoutBounds().getWidth();
 526             graphicHeight = graphic.getLayoutBounds().getHeight();
 527         }
 528 
 529         if (ignoreText) {
 530             textWidth  = textHeight = 0;
 531             text.setText(&quot;&quot;);
 532         } else {
 533             updateDisplayedText(w, h); // Have to do this just in case it needs to be recomputed
 534             textWidth  = snapSizeX(Math.min(text.getLayoutBounds().getWidth(),  wrapWidth));
 535             textHeight = snapSizeY(Math.min(text.getLayoutBounds().getHeight(), wrapHeight));
 536         }
 537 
 538         final double gap = (ignoreText || ignoreGraphic) ? 0 : labeled.getGraphicTextGap();
 539 
 540         // Figure out the contentWidth and contentHeight. This is the width
 541         // and height of the Labeled and Graphic together, not the available
 542         // content area (which would be a different calculation).
 543         double contentWidth = Math.max(graphicWidth, textWidth);
 544         double contentHeight = Math.max(graphicHeight, textHeight);
 545         if (contentDisplay == ContentDisplay.TOP || contentDisplay == ContentDisplay.BOTTOM) {
 546             contentHeight = graphicHeight + gap + textHeight;
 547         } else if (contentDisplay == ContentDisplay.LEFT || contentDisplay == ContentDisplay.RIGHT) {
 548             contentWidth = graphicWidth + gap + textWidth;
 549         }
 550 
 551         // Now we want to compute the x/y location to place the content at.
 552 
 553         // Compute the contentX position based on hpos and the space available
 554         double contentX;
 555         if (hpos == HPos.LEFT) {
 556             contentX = x;
 557         } else if (hpos == HPos.RIGHT) {
 558             contentX = x + (w - contentWidth);
 559         } else {
 560             // TODO Baseline may not be handled correctly
 561             // may have been CENTER or null, treat as center
 562             contentX = (x + ((w - contentWidth) / 2.0));
 563         }
 564 
 565         // Compute the contentY position based on vpos and the space available
 566         double contentY;
 567         if (vpos == VPos.TOP) {
 568             contentY = y;
 569         } else if (vpos == VPos.BOTTOM) {
 570             contentY = (y + (h - contentHeight));
 571         } else {
 572             // TODO Baseline may not be handled correctly
 573             // may have been CENTER, BASELINE, or null, treat as center
 574             contentY = (y + ((h - contentHeight) / 2.0));
 575         }
 576 
 577         Point2D mnemonicPos = null;
 578         double mnemonicWidth = 0.0;
 579         double mnemonicHeight = 0.0;
 580         if (containsMnemonic) {
 581             final Font font = text.getFont();
 582             String preSt = bindings.getText();
 583             mnemonicPos = Utils.computeMnemonicPosition(font, preSt, bindings.getMnemonicIndex(), this.wrapWidth, labeled.getLineSpacing());
 584             mnemonicWidth = Utils.computeTextWidth(font, preSt.substring(bindings.getMnemonicIndex(), bindings.getMnemonicIndex() + 1), 0);
 585             mnemonicHeight = Utils.computeTextHeight(font, &quot;_&quot;, 0, text.getBoundsType());
 586         }
 587 
 588 
 589         // Now to position the graphic and text. At this point I know the
 590         // contentX and contentY locations (including the padding and whatnot
 591         // that was defined on the Labeled). I also know the content width and
 592         // height. So now I just need to lay out the graphic and text within
 593         // that content x/y/w/h area.
 594         if ((!ignoreGraphic || !ignoreText) &amp;&amp; !text.isManaged()) {
 595             text.setManaged(true);
 596         }
 597 
 598         if (ignoreGraphic &amp;&amp; ignoreText) {
 599             // There might be a text node as a child, or a graphic node as
 600             // a child. However we don&#39;t have to do anything for the graphic
 601             // node because the only way it can be a child and still have
 602             // ignoreGraphic true is if it is unmanaged. Text however might
 603             // be a child but still not matter, in which case we will just
 604             // stop managing it (although really I wish it just wasn&#39;t here
 605             // all all in that case)
 606             if (text.isManaged()) {
 607                 text.setManaged(false);
 608             }
 609             text.relocate(snapPositionX(contentX), snapPositionY(contentY));
 610         } else if (ignoreGraphic) {
 611             // Since I only have to position the text, it goes at the
 612             // contentX/contentY location. Note that positionNode will
 613             // adjust the text based on the text&#39;s minX/minY so no need to
 614             // worry about that here
 615             text.relocate(snapPositionX(contentX), snapPositionY(contentY));
 616             if (containsMnemonic &amp;&amp; (mnemonicPos != null)) {
 617                 mnemonic_underscore.setEndX(mnemonicWidth-2.0);
 618                 mnemonic_underscore.relocate(snapPositionX(contentX + mnemonicPos.getX()),
 619                                              snapPositionY(contentY + mnemonicPos.getY()));
 620             }
 621 
 622         } else if (ignoreText) {
 623             // there isn&#39;t text to display, so we need to position it
 624             // such that it doesn&#39;t affect the content area (although when
 625             // there is a graphic, the text isn&#39;t even in the scene)
 626             text.relocate(snapPositionX(contentX), snapPositionY(contentY));
 627             graphic.relocate(snapPositionX(contentX), snapPositionY(contentY));
 628             if (containsMnemonic &amp;&amp; (mnemonicPos != null)) {
 629                 mnemonic_underscore.setEndX(mnemonicWidth);
 630                 mnemonic_underscore.setStrokeWidth(mnemonicHeight/10.0);
 631                 mnemonic_underscore.relocate(snapPositionX(contentX + mnemonicPos.getX()),
 632                                              snapPositionY(contentY + mnemonicPos.getY()));
 633             }
 634         } else {
 635             // There is both text and a graphic, so I need to position them
 636             // relative to each other
 637             double graphicX = 0;
 638             double graphicY = 0;
 639             double textX = 0;
 640             double textY = 0;
 641 
 642             if (contentDisplay == ContentDisplay.TOP) {
 643                 graphicX = contentX + ((contentWidth - graphicWidth) / 2.0);
 644                 textX = contentX + ((contentWidth - textWidth) / 2.0);
 645                 // The graphic is above the text, so it is positioned at
 646                 // graphicY and the text below it.
 647                 graphicY = contentY;
 648                 textY = graphicY + graphicHeight + gap;
 649             } else if (contentDisplay == ContentDisplay.RIGHT) {
 650                 // The graphic is to the right of the text
 651                 textX = contentX;
 652                 graphicX = textX + textWidth + gap;
 653                 graphicY = contentY + ((contentHeight - graphicHeight) / 2.0);
 654                 textY = contentY + ((contentHeight - textHeight) / 2.0);
 655             } else if (contentDisplay == ContentDisplay.BOTTOM) {
 656                 graphicX = contentX + ((contentWidth - graphicWidth) / 2.0);
 657                 textX = contentX + ((contentWidth - textWidth) / 2.0);
 658                 // The graphic is below the text
 659                 textY = contentY;
 660                 graphicY = textY + textHeight + gap;
 661             } else if (contentDisplay == ContentDisplay.LEFT) {
 662                 // The graphic is to the left of the text, so the graphicX is
 663                 // simply the contentX and the textX is to the right of it.
 664                 graphicX = contentX;
 665                 textX = graphicX + graphicWidth + gap;
 666                 graphicY = contentY + ((contentHeight - graphicHeight) / 2.0);
 667                 textY = contentY + ((contentHeight - textHeight) / 2.0);
 668             } else if (contentDisplay == ContentDisplay.CENTER) {
 669                 graphicX = contentX + ((contentWidth - graphicWidth) / 2.0);
 670                 textX = contentX + ((contentWidth - textWidth) / 2.0);
 671                 graphicY = contentY + ((contentHeight - graphicHeight) / 2.0);
 672                 textY = contentY + ((contentHeight - textHeight) / 2.0);
 673             }
 674             text.relocate(snapPositionX(textX), snapPositionY(textY));
 675             if (containsMnemonic &amp;&amp; (mnemonicPos != null)) {
 676                 mnemonic_underscore.setEndX(mnemonicWidth);
 677                 mnemonic_underscore.setStrokeWidth(mnemonicHeight/10.0);
 678                 mnemonic_underscore.relocate(snapPositionX(textX + mnemonicPos.getX()),
 679                                              snapPositionY(textY + mnemonicPos.getY()));
 680             }
 681             graphic.relocate(snapPositionX(graphicX), snapPositionY(graphicY));
 682         }
 683 
 684         /**
 685          * check if the label text overflows it&#39;s bounds.
 686          * If there&#39;s an overflow, and no text clip then
 687          * we&#39;ll clip it.
 688          * If there is no overflow, and the label text has a
 689          * clip, then remove it.
 690          */
 691         if ((text != null) &amp;&amp;
 692                 ((text.getLayoutBounds().getHeight() &gt; wrapHeight) ||
 693                         (text.getLayoutBounds().getWidth() &gt; wrapWidth))) {
 694 
 695             if (textClip == null) {
 696                 textClip = new Rectangle();
 697             }
 698 
 699             if (labeled.getEffectiveNodeOrientation() == NodeOrientation.LEFT_TO_RIGHT) {
 700                 textClip.setX(text.getLayoutBounds().getMinX());
 701             } else {
 702                 textClip.setX(text.getLayoutBounds().getMaxX() - wrapWidth);
 703             }
 704             textClip.setY(text.getLayoutBounds().getMinY());
 705             textClip.setWidth(wrapWidth);
 706             textClip.setHeight(wrapHeight);
 707             if (text.getClip() == null) {
 708                 text.setClip(textClip);
 709             }
 710         }
 711         else {
 712             /**
 713              * content fits inside bounds, no need
 714              * for a clip
 715              */
 716             if (text.getClip() != null) {
 717                 text.setClip(null);
 718             }
 719         }
 720     }
 721 
 722     /** {@inheritDoc} */
 723     @Override protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
 724         switch (attribute) {
 725             case TEXT: {
 726                 Labeled labeled = getSkinnable();
 727                 String accText = labeled.getAccessibleText();
 728                 if (accText != null &amp;&amp; !accText.isEmpty()) return accText;
 729 
 730                 /* Use the text in the binding if available to handle mnemonics */
 731                 if (bindings != null) {
 732                     String text = bindings.getText();
 733                     if (text != null &amp;&amp; !text.isEmpty()) return text;
 734                 }
 735                 /* Avoid the content in text.getText() as it can contain ellipses
 736                  * for clipping
 737                  */
 738                 String text = labeled.getText();
 739                 if (text != null &amp;&amp; !text.isEmpty()) return text;
 740 
 741                 /* Use the graphic as last resource. Note that this implementation
 742                  * does not attempt to combine the label and graphics if both
 743                  * are being displayed
 744                  */
 745                 if (graphic != null) {
 746                     Object result = graphic.queryAccessibleAttribute(AccessibleAttribute.TEXT);
 747                     if (result != null) return result;
 748                 }
 749                 return null;
 750             }
 751             case MNEMONIC: {
 752                 if (bindings != null) {
 753                     return bindings.getMnemonic();
 754                 }
 755                 return null;
 756             }
 757             default: return super.queryAccessibleAttribute(attribute, parameters);
 758         }
 759     }
 760 
 761 
 762 
 763     /***************************************************************************
 764      *                                                                         *
 765      * Private implementation                                                  *
 766      *                                                                         *
 767      **************************************************************************/
 768 
 769     private double computeMinLabeledPartWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
 770         // First compute the minTextWidth by checking the width of the string
 771         // made by the ellipsis &quot;...&quot;, and then by checking the width of the
 772         // string made up by labeled.text. We want the smaller of the two.
 773         final Labeled labeled = getSkinnable();
 774         final ContentDisplay contentDisplay = labeled.getContentDisplay();
 775         final double gap = labeled.getGraphicTextGap();
 776         double minTextWidth = 0;
 777 
 778         final Font font = text.getFont();
 779         OverrunStyle truncationStyle = labeled.getTextOverrun();
 780         String ellipsisString = labeled.getEllipsisString();
 781         final String string = labeled.getText();
 782         final boolean emptyText = string == null || string.isEmpty();
 783 
 784         if (!emptyText) {
 785             // We only want to recompute the full text width if the font or text changed
 786             if (truncationStyle == CLIP) {
 787                 if (textWidth == Double.NEGATIVE_INFINITY) {
 788                     // Show at minimum the first character
 789                     textWidth = Utils.computeTextWidth(font, string.substring(0, 1), 0);
 790                 }
 791                 minTextWidth = textWidth;
 792             } else {
 793                 if (textWidth == Double.NEGATIVE_INFINITY) {
 794                     textWidth = Utils.computeTextWidth(font, string, 0);
 795                 }
 796                 // We only want to recompute the ellipsis width if the font has changed
 797                 if (ellipsisWidth == Double.NEGATIVE_INFINITY) {
 798                     ellipsisWidth = Utils.computeTextWidth(font, ellipsisString, 0);
 799                 }
 800                 minTextWidth = Math.min(textWidth, ellipsisWidth);
 801             }
 802         }
 803 
 804         // Now inspect the graphic and the hpos to determine the the minWidth
 805         final Node graphic = labeled.getGraphic();
 806         double width;
 807         if (isIgnoreGraphic()) {
 808             width = minTextWidth;
 809         } else if (isIgnoreText()) {
 810             width = graphic.minWidth(-1);
 811         } else if (contentDisplay == LEFT || contentDisplay == RIGHT){
 812             width = (minTextWidth + graphic.minWidth(-1) + gap);
 813         } else {
 814             width = Math.max(minTextWidth, graphic.minWidth(-1));
 815         }
 816 
 817         double padding = leftInset + rightInset;
 818         if (!isIgnoreText()) {
 819             padding += leftLabelPadding() + rightLabelPadding();
 820         }
 821 
 822         return width + padding;
 823     }
 824 
 825     private double computeMinLabeledPartHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
 826         final Labeled labeled = getSkinnable();
 827         final Font font = text.getFont();
 828 
 829         String str = labeled.getText();
 830         if (str != null &amp;&amp; str.length() &gt; 0) {
 831             int newlineIndex = str.indexOf(&#39;\n&#39;);
 832             if (newlineIndex &gt;= 0) {
 833                 str = str.substring(0, newlineIndex);
 834             }
 835         }
 836 
 837         // TODO figure out how to cache this effectively.
 838         // Base minimum height on one line (ignoring wrapping here).
 839         double s = labeled.getLineSpacing();
 840         final double textHeight = Utils.computeTextHeight(font, str, 0, s, text.getBoundsType());
 841 
 842         double h = textHeight;
 843 
 844         // Now we want to add on the graphic if necessary!
 845         if (!isIgnoreGraphic()) {
 846             final Node graphic = labeled.getGraphic();
 847             if (labeled.getContentDisplay() == ContentDisplay.TOP
 848                     || labeled.getContentDisplay() == ContentDisplay.BOTTOM) {
 849                 h = graphic.minHeight(width) + labeled.getGraphicTextGap() + textHeight;
 850             } else {
 851                 h = Math.max(textHeight, graphic.minHeight(width));
 852             }
 853         }
 854 
 855         double padding = topInset + bottomInset;
 856         if (!isIgnoreText()) {
 857             padding += topLabelPadding() - bottomLabelPadding();
 858         }
 859         return h + padding;
 860     }
 861 
 862     double topLabelPadding() {
 863         return snapSizeY(getSkinnable().getLabelPadding().getTop());
 864     }
 865 
 866     double bottomLabelPadding() {
 867         return snapSizeY(getSkinnable().getLabelPadding().getBottom());
 868     }
 869 
 870     double leftLabelPadding() {
 871         return snapSizeX(getSkinnable().getLabelPadding().getLeft());
 872     }
 873 
 874     double rightLabelPadding() {
 875         return snapSizeX(getSkinnable().getLabelPadding().getRight());
 876     }
 877 
 878 
 879     /**
 880      * Called whenever some state has changed that affects the text metrics.
 881      * Changes here will involve invalidating the display text so the next
 882      * call to updateDisplayedText computes a new value, and call requestLayout.
 883      */
 884     private void textMetricsChanged() {
 885         invalidText = true;
 886         getSkinnable().requestLayout();
 887     }
 888 
 889     /*
 890     ** The Label is a mnemonic, and it&#39;s target node
 891     ** has changed, but it&#39;s label hasn&#39;t so just
 892     ** swap them over, and tidy up.
 893     */
 894     void mnemonicTargetChanged() {
 895         if (containsMnemonic == true) {
 896             /*
 897             ** was there previously a labelFor
 898             */
 899             removeMnemonic();
 900 
 901             /*
 902             ** is there a new labelFor
 903             */
 904             Control control = getSkinnable();
 905             if (control instanceof Label) {
 906                 labeledNode = ((Label)control).getLabelFor();
 907                 addMnemonic();
 908             }
 909             else {
 910                 labeledNode = null;
 911             }
 912         }
 913     }
 914 
 915     private void sceneChanged() {
 916         final Labeled labeled = getSkinnable();
 917         Scene scene = labeled.getScene();
 918 
 919         if (scene != null &amp;&amp; containsMnemonic) {
 920             addMnemonic();
 921         }
 922 
 923     }
 924 
 925     /**
 926      * Marks minWidth as being invalid and in need of recomputation.
 927      */
 928     private void invalidateWidths() {
 929         textWidth = Double.NEGATIVE_INFINITY;
 930     }
 931 
 932     /**
 933      * Updates the content of the underlying Text node. This method should
 934      * only be called when necessary. If the invalidText flag is not set, then
 935      * the method is a no-op. This care is taken because recomputing the
 936      * text to display is an expensive operation. Package private ONLY FOR THE
 937      * SAKE OF TESTING.
 938      */
 939     void updateDisplayedText() {
 940         updateDisplayedText(-1, -1);
 941     }
 942 
 943     private void updateDisplayedText(double w, double h) {
 944         if (invalidText) {
 945             final Labeled labeled = getSkinnable();
 946             String s = labeled.getText();
 947 
 948             int mnemonicIndex = -1;
 949 
 950             /*
 951             ** if there&#39;s a valid string then parse it
 952             */
 953             if (s != null &amp;&amp; s.length() &gt; 0) {
 954                 bindings = new TextBinding(s);
 955 
 956                 if (!com.sun.javafx.PlatformUtil.isMac() &amp;&amp; getSkinnable().isMnemonicParsing() == true) {
 957                     /*
 958                     ** the Labeled has a MnemonicParsing property,
 959                     ** if set true, then auto-parsing will check for
 960                     ** a mnemonic
 961                     */
 962                     if (labeled instanceof Label) {
 963                         // buttons etc
 964                         labeledNode = ((Label)labeled).getLabelFor();
 965                     } else {
 966                         labeledNode = labeled;
 967                     }
 968 
 969                     if (labeledNode == null) {
 970                         labeledNode = labeled;
 971                     }
 972                     mnemonicIndex = bindings.getMnemonicIndex() ;
 973                 }
 974             }
 975 
 976             /*
 977             ** we were previously a mnemonic
 978             */
 979             if (containsMnemonic) {
 980                 /*
 981                 ** are we no longer a mnemonic, or have we changed code?
 982                 */
 983                 if (mnemonicScene != null) {
 984                     if (mnemonicIndex == -1 ||
 985                             (bindings != null &amp;&amp; !bindings.getMnemonicKeyCombination().equals(mnemonicCode))) {
 986                         removeMnemonic();
 987                         containsMnemonic = false;
 988                     }
 989                 }
 990             }
 991             else {
 992                 /*
 993                 ** this can happen if mnemonic parsing is
 994                 ** disabled on a previously valid mnemonic
 995                 */
 996                 removeMnemonic();
 997             }
 998 
 999             /*
1000             ** check we have a labeled
1001             */
1002             if (s != null &amp;&amp; s.length() &gt; 0) {
1003                 if (mnemonicIndex &gt;= 0 &amp;&amp; containsMnemonic == false) {
1004                     containsMnemonic = true;
1005                     mnemonicCode = bindings.getMnemonicKeyCombination();
1006                     addMnemonic();
1007                 }
1008             }
1009 
1010             if (containsMnemonic == true) {
1011                 s = bindings.getText();
1012                 if (mnemonic_underscore == null) {
1013                     mnemonic_underscore = new Line();
1014                     mnemonic_underscore.setStartX(0.0f);
1015                     mnemonic_underscore.setStartY(0.0f);
1016                     mnemonic_underscore.setEndY(0.0f);
1017                     mnemonic_underscore.getStyleClass().clear();
1018                     mnemonic_underscore.getStyleClass().setAll(&quot;mnemonic-underline&quot;);
1019                 }
1020                 if (!getChildren().contains(mnemonic_underscore)) {
1021                     getChildren().add(mnemonic_underscore);
1022                 }
1023             } else {
1024                 /*
1025                 ** we don&#39;t need a mnemonic....
1026                 */
1027                 if (getSkinnable().isMnemonicParsing() == true &amp;&amp; com.sun.javafx.PlatformUtil.isMac() &amp;&amp; bindings != null) {
1028                     s = bindings.getText();
1029                 }
1030                 else {
1031                     s = labeled.getText();
1032                 }
1033                 if (mnemonic_underscore != null) {
1034                     if (getChildren().contains(mnemonic_underscore)) {
1035                         Platform.runLater(() -&gt; {
1036                               getChildren().remove(mnemonic_underscore);
1037                               mnemonic_underscore = null;
1038                         });
1039                     }
1040                 }
1041             }
1042 
1043             int len = s != null ? s.length() : 0;
1044             boolean multiline = false;
1045 
1046             if (s != null &amp;&amp; len &gt; 0) {
1047                 int i = s.indexOf(&#39;\n&#39;);
1048                 if (i &gt; -1 &amp;&amp; i &lt; len - 1) {
1049                     // Multiline text with embedded newlines - not
1050                     // taking into account a potential trailing newline.
1051                     multiline = true;
1052                 }
1053             }
1054 
1055             String result;
1056             boolean horizontalPosition =
1057                     (labeled.getContentDisplay() == ContentDisplay.LEFT ||
1058                     labeled.getContentDisplay() == ContentDisplay.RIGHT);
1059 
1060             double availableWidth = labeled.getWidth() -
1061                     snappedLeftInset() - snappedRightInset();
1062 
1063             if (!isIgnoreText()) {
1064                 availableWidth -= leftLabelPadding() + rightLabelPadding();
1065             }
1066             availableWidth = Math.max(availableWidth, 0);
1067 
1068             if (w == -1) {
1069                 w = availableWidth;
1070             }
1071             double minW = Math.min(computeMinLabeledPartWidth(-1, snappedTopInset() , snappedRightInset(), snappedBottomInset(), snappedLeftInset()), availableWidth);
1072             if (horizontalPosition &amp;&amp; !isIgnoreGraphic()) {
1073                 double graphicW = (labeled.getGraphic().getLayoutBounds().getWidth() + labeled.getGraphicTextGap());
1074                 w -= graphicW;
1075                 minW -= graphicW;
1076             }
1077             wrapWidth = Math.max(minW, w);
1078 
1079             boolean verticalPosition =
1080                     (labeled.getContentDisplay() == ContentDisplay.TOP ||
1081                     labeled.getContentDisplay() == ContentDisplay.BOTTOM);
1082 
1083             double availableHeight = labeled.getHeight() -
1084                     snappedTopInset() - snappedBottomInset();
1085 
1086             if (!isIgnoreText()) {
1087                 availableHeight -= topLabelPadding() + bottomLabelPadding();
1088             }
1089             availableHeight = Math.max(availableHeight, 0);
1090 
1091             if (h == -1) {
1092                 h = availableHeight;
1093             }
1094             double minH = Math.min(computeMinLabeledPartHeight(wrapWidth, snappedTopInset() , snappedRightInset(), snappedBottomInset(), snappedLeftInset()), availableHeight);
1095             if (verticalPosition &amp;&amp; labeled.getGraphic() != null) {
1096                 double graphicH = labeled.getGraphic().getLayoutBounds().getHeight() + labeled.getGraphicTextGap();
1097                 h -= graphicH;
1098                 minH -= graphicH;
1099             }
1100             wrapHeight = Math.max(minH, h);
1101 
1102             updateWrappingWidth();
1103 
1104             Font font = text.getFont();
1105             OverrunStyle truncationStyle = labeled.getTextOverrun();
1106             String ellipsisString = labeled.getEllipsisString();
1107 
1108             if (labeled.isWrapText()) {
1109                 result = Utils.computeClippedWrappedText(font, s, wrapWidth, wrapHeight, truncationStyle, ellipsisString, text.getBoundsType());
1110             } else if (multiline) {
1111                 StringBuilder sb = new StringBuilder();
1112 
1113                 String[] splits = s.split(&quot;\n&quot;);
1114                 for (int i = 0; i &lt; splits.length; i++) {
1115                     sb.append(Utils.computeClippedText(font, splits[i], wrapWidth, truncationStyle, ellipsisString));
1116                     if (i &lt; splits.length - 1) {
1117                         sb.append(&#39;\n&#39;);
1118                     }
1119                 }
1120 
1121                 // TODO: Consider what to do in the case where vertical space is
1122                 // limited and the last visible line isn&#39;t already truncated
1123                 // with a trailing ellipsis. What if the style calls for leading
1124                 // or center ellipses? We could possibly add an additional
1125                 // trailing ellipsis to the last visible line, like this:
1126 
1127                 // +--------------------------------+
1128                 // |  This is some long text with multiple lines\n
1129                 // |  where more than one exceed the|width\n
1130                 // |  and wrapText is false, and all|lines\n
1131                 // +--don&#39;t fit.--------------------+
1132                 //
1133                 // +--------------------------------+
1134                 // |  This is some...multiple lines |
1135                 // |  where more t...ceed the width |
1136                 // |  and wrapText...d all lines... |
1137                 // +--------------------------------+
1138 
1139                 result = sb.toString();
1140             } else {
1141                 result = Utils.computeClippedText(font, s, wrapWidth, truncationStyle, ellipsisString);
1142             }
1143 
1144             if (result != null &amp;&amp; result.endsWith(&quot;\n&quot;)) {
1145                 // Strip ending newline so we don&#39;t display another row.
1146                 result = result.substring(0, result.length() - 1);
1147             }
1148 
1149             text.setText(result);
1150             updateWrappingWidth();
1151             invalidText = false;
1152         }
1153     }
1154 
1155     private void addMnemonic() {
1156         if (labeledNode != null) {
1157             mnemonicScene = labeledNode.getScene();
1158             if (mnemonicScene != null) {
1159                 mnemonicScene.addMnemonic(new Mnemonic(labeledNode, mnemonicCode));
1160             }
1161         }
1162     }
1163 
1164 
1165     private void removeMnemonic() {
1166         if (mnemonicScene != null &amp;&amp; labeledNode != null) {
1167             mnemonicScene.removeMnemonic(new Mnemonic(labeledNode, mnemonicCode));
1168             mnemonicScene = null;
1169         }
1170     }
1171 
1172     /**
1173      * Updates the wrapping width of the text node. Although changing the font
1174      * does affect the metrics used for text layout, this method does not
1175      * call requestLayout or invalidate the text, since it may be called
1176      * from the constructor and such work would be duplicative and wasted.
1177      */
1178     private void updateWrappingWidth() {
1179         final Labeled labeled = getSkinnable();
1180         text.setWrappingWidth(0);
1181         if (labeled.isWrapText()) {
1182             // Note that the wrapping width needs to be set to zero before
1183             // getting the text&#39;s real preferred width.
1184             double w = Math.min(text.prefWidth(-1), wrapWidth);
1185             text.setWrappingWidth(w);
1186         }
1187     }
1188 
1189     /**
1190      * Gets whether for various computations we can ignore the presence of the graphic
1191      * (or lack thereof).
1192      * @return
1193      */
1194     boolean isIgnoreGraphic() {
1195         return (graphic == null ||
1196                 !graphic.isManaged() ||
1197                 getSkinnable().getContentDisplay() == ContentDisplay.TEXT_ONLY);
1198     }
1199 
1200     /**
1201      * Gets whether for various computations we can ignore the presence of the text.
1202      * @return
1203      */
1204     boolean isIgnoreText() {
1205         final Labeled labeled = getSkinnable();
1206         final String txt = labeled.getText();
1207         return (txt == null ||
1208                 txt.equals(&quot;&quot;) ||
1209                 labeled.getContentDisplay() == ContentDisplay.GRAPHIC_ONLY);
1210     }
1211 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/skin/Utils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * To change this template, choose Tools | Templates
 28  * and open the template in the editor.
 29  */
 30 
 31 package com.sun.javafx.scene.control.skin;
 32 
 33 import com.sun.javafx.scene.NodeHelper;
 34 import com.sun.javafx.scene.control.behavior.TextBinding;
 35 import com.sun.javafx.scene.text.TextLayout;
 36 import com.sun.javafx.tk.Toolkit;
 37 import javafx.application.ConditionalFeature;
 38 import javafx.application.Platform;
 39 import javafx.beans.InvalidationListener;
 40 import javafx.beans.Observable;
 41 import javafx.beans.value.ObservableValue;
 42 import javafx.collections.ObservableList;
 43 import javafx.geometry.Bounds;
 44 import javafx.geometry.HPos;
 45 import javafx.geometry.Point2D;
 46 import javafx.geometry.VPos;
 47 import javafx.scene.Scene;
 48 import javafx.scene.control.ContextMenu;
 49 import javafx.scene.control.MenuItem;
 50 import javafx.scene.control.OverrunStyle;
 51 import com.sun.javafx.scene.control.ContextMenuContent;
 52 import com.sun.javafx.scene.text.FontHelper;
 53 import java.net.URL;
 54 import javafx.scene.input.KeyCombination;
 55 import javafx.scene.input.Mnemonic;
 56 import javafx.scene.paint.Color;
 57 import javafx.scene.text.Font;
 58 import javafx.scene.text.Text;
 59 import javafx.scene.text.TextBoundsType;
 60 import javafx.scene.text.HitInfo;
 61 
 62 import java.text.Bidi;
 63 import java.util.List;
 64 import java.util.Locale;
 65 import java.util.function.Consumer;
 66 
 67 import static javafx.scene.control.OverrunStyle.CENTER_ELLIPSIS;
 68 import static javafx.scene.control.OverrunStyle.CENTER_WORD_ELLIPSIS;
 69 import static javafx.scene.control.OverrunStyle.CLIP;
 70 import static javafx.scene.control.OverrunStyle.ELLIPSIS;
 71 import static javafx.scene.control.OverrunStyle.LEADING_ELLIPSIS;
 72 import static javafx.scene.control.OverrunStyle.LEADING_WORD_ELLIPSIS;
 73 import static javafx.scene.control.OverrunStyle.WORD_ELLIPSIS;
 74 
 75 /**
 76  * BE REALLY CAREFUL WITH RESTORING OR RESETTING STATE OF helper NODE AS LEFTOVER
 77  * STATE CAUSES REALLY ODD NASTY BUGS!
 78  *
 79  * We expect all methods to set the Font property of helper but other than that
 80  * any properties set should be restored to defaults.
 81  */
 82 public class Utils {
 83 
 84     static final Text helper = new Text();
 85     static final double DEFAULT_WRAPPING_WIDTH = helper.getWrappingWidth();
 86     static final double DEFAULT_LINE_SPACING = helper.getLineSpacing();
 87     static final String DEFAULT_TEXT = helper.getText();
 88     static final TextBoundsType DEFAULT_BOUNDS_TYPE = helper.getBoundsType();
 89 
 90     /* Using TextLayout directly for simple text measurement.
 91      * Instead of restoring the TextLayout attributes to default values
 92      * (each renders the TextLayout unable to efficiently cache layout data).
 93      * It always sets all the attributes pertinent to calculation being performed.
 94      * Note that lineSpacing and boundsType are important when computing the height
 95      * but irrelevant when computing the width.
 96      *
 97      * Note: This code assumes that TextBoundsType#VISUAL is never used by controls.
 98      * */
 99     static final TextLayout layout = Toolkit.getToolkit().getTextLayoutFactory().createLayout();
100 
101     public static double getAscent(Font font, TextBoundsType boundsType) {
102         layout.setContent(&quot;&quot;, FontHelper.getNativeFont(font));
103         layout.setWrapWidth(0);
104         layout.setLineSpacing(0);
105         if (boundsType == TextBoundsType.LOGICAL_VERTICAL_CENTER) {
106             layout.setBoundsType(TextLayout.BOUNDS_CENTER);
107         } else {
108             layout.setBoundsType(0);
109         }
110         return -layout.getBounds().getMinY();
111     }
112 
113     public static double getLineHeight(Font font, TextBoundsType boundsType) {
114         layout.setContent(&quot;&quot;, FontHelper.getNativeFont(font));
115         layout.setWrapWidth(0);
116         layout.setLineSpacing(0);
117         if (boundsType == TextBoundsType.LOGICAL_VERTICAL_CENTER) {
118             layout.setBoundsType(TextLayout.BOUNDS_CENTER);
119         } else {
120             layout.setBoundsType(0);
121         }
122 
123         // RT-37092: Use the line bounds specifically, to include font leading.
124         return layout.getLines()[0].getBounds().getHeight();
125     }
126 
127     public static double computeTextWidth(Font font, String text, double wrappingWidth) {
128         layout.setContent(text != null ? text : &quot;&quot;, FontHelper.getNativeFont(font));
129         layout.setWrapWidth((float)wrappingWidth);
130         return layout.getBounds().getWidth();
131     }
132 
133     public static double computeTextHeight(Font font, String text, double wrappingWidth, TextBoundsType boundsType) {
134         return computeTextHeight(font, text, wrappingWidth, 0, boundsType);
135     }
136 
137     @SuppressWarnings(&quot;deprecation&quot;)
138     public static double computeTextHeight(Font font, String text, double wrappingWidth, double lineSpacing, TextBoundsType boundsType) {
139         layout.setContent(text != null ? text : &quot;&quot;, FontHelper.getNativeFont(font));
140         layout.setWrapWidth((float)wrappingWidth);
141         layout.setLineSpacing((float)lineSpacing);
142         if (boundsType == TextBoundsType.LOGICAL_VERTICAL_CENTER) {
143             layout.setBoundsType(TextLayout.BOUNDS_CENTER);
144         } else {
145             layout.setBoundsType(0);
146         }
147         return layout.getBounds().getHeight();
148     }
149 
150     public static Point2D computeMnemonicPosition(Font font, String text, int mnemonicIndex, double wrappingWidth,
151                                                   double lineSpacing, boolean isRTL) {
152         // Input validation
153         if ((font == null) || (text == null) ||
154             (mnemonicIndex &lt; 0) || (mnemonicIndex &gt; text.length())) {
155             return null;
156         }
157 
158         // Layout the text with given font, wrapping width and line spacing
159         layout.setContent(text, FontHelper.getNativeFont(font));
160         layout.setWrapWidth((float)wrappingWidth);
161         layout.setLineSpacing((float)lineSpacing);
162 
163         // The text could be spread over multiple lines
164         // We need to find out on which line the mnemonic character lies
165         int start = 0;
166         int i = 0;
167         int totalLines = layout.getLines().length;
168         int lineLength = 0;
169         while (i &lt; totalLines) {
170             lineLength = layout.getLines()[i].getLength();
171 
172             if ((mnemonicIndex &gt;= start) &amp;&amp;
173                 (mnemonicIndex &lt; (start + lineLength))) {
174                 // mnemonic lies on line &#39;i&#39;
175                 break;
176             }
177 
178             start += lineLength;
179             i++;
180         }
181 
182         // Find x and y offsets of mnemonic character position
183         // in line numbered &#39;i&#39;
184         double lineHeight = layout.getBounds().getHeight() / totalLines;
185         double x = Utils.computeTextWidth(font, text.substring(start, mnemonicIndex), 0);
186         if (isRTL) {
187             double lineWidth = Utils.computeTextWidth(font, text.substring(start, (start + lineLength - 1)), 0);
188             x = lineWidth - x;
189         }
190 
191         double y = (lineHeight * (i+1));
192         // Adjust y offset for linespacing except for the last line.
193         if ((i+1) != totalLines) {
194             y -= (lineSpacing / 2);
195         }
196 
197         return new Point2D(x, y);
198     }
199 
200     public static int computeTruncationIndex(Font font, String text, double width) {
201         helper.setText(text);
202         helper.setFont(font);
203         helper.setWrappingWidth(0);
204         helper.setLineSpacing(0);
205         // The -2 is a fudge to make sure the result more often matches
206         // what we get from using computeTextWidth instead. It&#39;s not yet
207         // clear what causes the small discrepancies.
208         Bounds bounds = helper.getLayoutBounds();
209         Point2D endPoint = new Point2D(width - 2, bounds.getMinY() + bounds.getHeight() / 2);
210         final int index = helper.hitTest(endPoint).getCharIndex();
211         // RESTORE STATE
212         helper.setWrappingWidth(DEFAULT_WRAPPING_WIDTH);
213         helper.setLineSpacing(DEFAULT_LINE_SPACING);
214         helper.setText(DEFAULT_TEXT);
215         return index;
216     }
217 
218     public static String computeClippedText(Font font, String text, double width,
219                                      OverrunStyle type, String ellipsisString) {
220         if (font == null) {
221             throw new IllegalArgumentException(&quot;Must specify a font&quot;);
222         }
223         OverrunStyle style = (type == null || type == CLIP) ? ELLIPSIS : type;
224         final String ellipsis = (type == CLIP) ? &quot;&quot; : ellipsisString;
225         // if the text is empty or null or no ellipsis, then it always fits
226         if (text == null || &quot;&quot;.equals(text)) {
227             return text;
228         }
229         // if the string width is &lt; the available width, then it fits and
230         // doesn&#39;t need to be clipped.  We use a double point comparison
231         // of 0.001 (1/1000th of a pixel) to account for any numerical
232         // discrepancies introduced when the available width was calculated.
233         // MenuItemSkinBase.doLayout, for example, does a number of double
234         // point operations when computing the available width.
235         final double stringWidth = computeTextWidth(font, text, 0);
236         if (stringWidth - width &lt; 0.0010F) {
237             return text;
238         }
239         // the width used by the ellipsis string
240         final double ellipsisWidth = computeTextWidth(font, ellipsis, 0);
241         // the available maximum width to fit chars into. This is essentially
242         // the width minus the space required for the ellipsis string
243         final double availableWidth = width - ellipsisWidth;
244 
245         if (width &lt; ellipsisWidth) {
246             // The ellipsis doesn&#39;t fit.
247             return &quot;&quot;;
248         }
249 
250         // if we got here, then we must clip the text with an ellipsis.
251         // this can be pretty expensive depending on whether &quot;complex&quot; text
252         // layout needs to be taken into account. So each ellipsis option has
253         // to take into account two code paths: the easy way and the correct
254         // way. This is flagged by the &quot;complexLayout&quot; boolean
255         // TODO make sure this function call takes into account ligatures, kerning,
256         // and such as that will change the layout characteristics of the text
257         // and will require a full complex layout
258         // TODO since we don&#39;t have all the stuff available in FX to determine
259         // complex text, I&#39;m going to for now assume complex text is always false.
260         final boolean complexLayout = false;
261         //requiresComplexLayout(font, text);
262 
263         // generally all we want to do is count characters and add their widths.
264         // For ellipsis that breaks on words, we do NOT want to include any
265         // hanging whitespace.
266         if (style == ELLIPSIS ||
267             style == WORD_ELLIPSIS ||
268             style == LEADING_ELLIPSIS ||
269             style == LEADING_WORD_ELLIPSIS) {
270 
271             final boolean wordTrim =
272                 (style == WORD_ELLIPSIS || style == LEADING_WORD_ELLIPSIS);
273             String substring;
274             if (complexLayout) {
275             //            AttributedString a = new AttributedString(text);
276             //            LineBreakMeasurer m = new LineBreakMeasurer(a.getIterator(), frc);
277             //            substring = text.substring(0, m.nextOffset((double)availableWidth));
278             } else {
279                 // RT-23458: Use a faster algorithm for the most common case
280                 // where truncation happens at the end, i.e. for ELLIPSIS and
281                 // CLIP, but not for other cases such as WORD_ELLIPSIS, etc.
282                 if (style == ELLIPSIS &amp;&amp; !new Bidi(text, Bidi.DIRECTION_LEFT_TO_RIGHT).isMixed()) {
283                     int hit = computeTruncationIndex(font, text, width - ellipsisWidth);
284                     if (hit &lt; 0 || hit &gt;= text.length()) {
285                         return text;
286                     } else {
287                         return text.substring(0, hit) + ellipsis;
288                     }
289                 }
290 
291                 // simply total up the widths of all chars to determine how many
292                 // will fit in the available space. Remember the last whitespace
293                 // encountered so that if we&#39;re breaking on words we can trim
294                 // and omit it.
295                 double total = 0.0F;
296                 int whitespaceIndex = -1;
297                 // at the termination of the loop, index will be one past the
298                 // end of the substring
299                 int index = 0;
300                 int start = (style == LEADING_ELLIPSIS || style == LEADING_WORD_ELLIPSIS) ? (text.length() - 1) : (0);
301                 int end = (start == 0) ? (text.length() - 1) : 0;
302                 int stepValue = (start == 0) ? 1 : -1;
303                 boolean done = (start == 0) ? start &gt; end : start &lt; end;
304                 for (int i = start; !done ; i += stepValue) {
305                     index = i;
306                     char c = text.charAt(index);
307                     total = computeTextWidth(font,
308                                              (start == 0) ? text.substring(0, i + 1)
309                                                           : text.substring(i, start + 1),
310                                              0);
311                     if (Character.isWhitespace(c)) {
312                         whitespaceIndex = index;
313                     }
314                     if (total &gt; availableWidth) {
315                         break;
316                     }
317                     done = start == 0? i &gt;= end : i &lt;= end;
318                 }
319                 final boolean fullTrim = !wordTrim || whitespaceIndex == -1;
320                 substring = (start == 0) ?
321                     (text.substring(0, fullTrim ? index : whitespaceIndex)) :
322                         (text.substring((fullTrim ? index : whitespaceIndex) + 1));
323                 assert(!text.equals(substring));
324             }
325             if (style == ELLIPSIS || style == WORD_ELLIPSIS) {
326                  return substring + ellipsis;
327             } else {
328                 //style is LEADING_ELLIPSIS or LEADING_WORD_ELLIPSIS
329                 return ellipsis + substring;
330             }
331         } else {
332             // these two indexes are INCLUSIVE not exclusive
333             int leadingIndex = 0;
334             int trailingIndex = 0;
335             int leadingWhitespace = -1;
336             int trailingWhitespace = -1;
337             // The complex case is going to be killer. What I have to do is
338             // read all the chars from the left up to the leadingIndex,
339             // and all the chars from the right up to the trailingIndex,
340             // and sum those together to get my total. That is, I cannot have
341             // a running total but must retotal the cummulative chars each time
342             if (complexLayout) {
343             } else /*            double leadingTotal = 0;
344                double trailingTotal = 0;
345                for (int i=0; i&lt;text.length(); i++) {
346                double total = computeStringWidth(metrics, text.substring(0, i));
347                if (total + trailingTotal &gt; availableWidth) break;
348                leadingIndex = i;
349                leadingTotal = total;
350                if (Character.isWhitespace(text.charAt(i))) leadingWhitespace = leadingIndex;
351 
352                int index = text.length() - (i + 1);
353                total = computeStringWidth(metrics, text.substring(index - 1));
354                if (total + leadingTotal &gt; availableWidth) break;
355                trailingIndex = index;
356                trailingTotal = total;
357                if (Character.isWhitespace(text.charAt(index))) trailingWhitespace = trailingIndex;
358                }*/
359             {
360                 // either CENTER_ELLIPSIS or CENTER_WORD_ELLIPSIS
361                 // for this case I read one char on the left, then one on the end
362                 // then second on the left, then second from the end, etc until
363                 // I have used up all the availableWidth. At that point, I trim
364                 // the string twice: once from the start to firstIndex, and
365                 // once from secondIndex to the end. I then insert the ellipsis
366                 // between the two.
367                 leadingIndex = -1;
368                 trailingIndex = -1;
369                 double total = 0.0F;
370                 for (int i = 0; i &lt;= text.length() - 1; i++) {
371                     char c = text.charAt(i);
372                     //total += metrics.charWidth(c);
373                     total += computeTextWidth(font, &quot;&quot; + c, 0);
374                     if (total &gt; availableWidth) {
375                         break;
376                     }
377                     leadingIndex = i;
378                     if (Character.isWhitespace(c)) {
379                         leadingWhitespace = leadingIndex;
380                     }
381                     int index = text.length() - 1 - i;
382                     c = text.charAt(index);
383                     //total += metrics.charWidth(c);
384                     total += computeTextWidth(font, &quot;&quot; + c, 0);
385                     if (total &gt; availableWidth) {
386                         break;
387                     }
388                     trailingIndex = index;
389                     if (Character.isWhitespace(c)) {
390                         trailingWhitespace = trailingIndex;
391                     }
392                 }
393             }
394             if (leadingIndex &lt; 0) {
395                 return ellipsis;
396             }
397             if (style == CENTER_ELLIPSIS) {
398                 if (trailingIndex &lt; 0) {
399                     return text.substring(0, leadingIndex + 1) + ellipsis;
400                 }
401                 return text.substring(0, leadingIndex + 1) + ellipsis + text.substring(trailingIndex);
402             } else {
403                 boolean leadingIndexIsLastLetterInWord =
404                     Character.isWhitespace(text.charAt(leadingIndex + 1));
405                 int index = (leadingWhitespace == -1 || leadingIndexIsLastLetterInWord) ? (leadingIndex + 1) : (leadingWhitespace);
406                 String leading = text.substring(0, index);
407                 if (trailingIndex &lt; 0) {
408                     return leading + ellipsis;
409                 }
410                 boolean trailingIndexIsFirstLetterInWord =
411                     Character.isWhitespace(text.charAt(trailingIndex - 1));
412                 index = (trailingWhitespace == -1 || trailingIndexIsFirstLetterInWord) ? (trailingIndex) : (trailingWhitespace + 1);
413                 String trailing = text.substring(index);
414                 return leading + ellipsis + trailing;
415             }
416         }
417     }
418 
419     public static String computeClippedWrappedText(Font font, String text, double width,
420                                             double height, OverrunStyle truncationStyle,
421                                             String ellipsisString, TextBoundsType boundsType) {
422         if (font == null) {
423             throw new IllegalArgumentException(&quot;Must specify a font&quot;);
424         }
425 
426         String ellipsis = (truncationStyle == CLIP) ? &quot;&quot; : ellipsisString;
427         int eLen = ellipsis.length();
428         // Do this before using helper, as it&#39;s not reentrant.
429         double eWidth = computeTextWidth(font, ellipsis, 0);
430         double eHeight = computeTextHeight(font, ellipsis, 0, boundsType);
431 
432         if (width &lt; eWidth || height &lt; eHeight) {
433             // The ellipsis doesn&#39;t fit.
434             return text; // RT-30868 - return text, not empty string.
435         }
436 
437         helper.setText(text);
438         helper.setFont(font);
439         helper.setWrappingWidth((int)Math.ceil(width));
440         helper.setBoundsType(boundsType);
441         helper.setLineSpacing(0);
442 
443         boolean leading =  (truncationStyle == LEADING_ELLIPSIS ||
444                             truncationStyle == LEADING_WORD_ELLIPSIS);
445         boolean center =   (truncationStyle == CENTER_ELLIPSIS ||
446                             truncationStyle == CENTER_WORD_ELLIPSIS);
447         boolean trailing = !(leading || center);
448         boolean wordTrim = (truncationStyle == WORD_ELLIPSIS ||
449                             truncationStyle == LEADING_WORD_ELLIPSIS ||
450                             truncationStyle == CENTER_WORD_ELLIPSIS);
451 
452         String result = text;
453         int len = (result != null) ? result.length() : 0;
454         int centerLen = -1;
455 
456         Point2D centerPoint = null;
457         if (center) {
458             // Find index of character in the middle of the visual text area
459             centerPoint = new Point2D((width - eWidth) / 2, height / 2 - helper.getBaselineOffset());
460         }
461 
462         // Find index of character at the bottom left of the text area.
463         // This should be the first character of a line that would be clipped.
464         Point2D endPoint = new Point2D(0, height - helper.getBaselineOffset());
465 
466         int hit = helper.hitTest(endPoint).getCharIndex();
467         if (hit &gt;= len) {
468             helper.setBoundsType(TextBoundsType.LOGICAL); // restore
469             return text;
470         }
471         if (center) {
472             hit = helper.hitTest(centerPoint).getCharIndex();
473         }
474 
475         if (hit &gt; 0 &amp;&amp; hit &lt; len) {
476             // Step one, make a truncation estimate.
477 
478             if (center || trailing) {
479                 int ind = hit;
480                 if (center) {
481                     // This is for the first part, i.e. beginning of text up to ellipsis.
482                     if (wordTrim) {
483                         int brInd = lastBreakCharIndex(text, ind + 1);
484                         if (brInd &gt;= 0) {
485                             ind = brInd + 1;
486                         } else {
487                             brInd = firstBreakCharIndex(text, ind);
488                             if (brInd &gt;= 0) {
489                                 ind = brInd + 1;
490                             }
491                         }
492                     }
493                     centerLen = ind + eLen;
494                 } // else: text node wraps at words, so wordTrim is not needed here.
495                 result = result.substring(0, ind) + ellipsis;
496             }
497 
498             if (leading || center) {
499                 // The hit is an index counted from the beginning, but we need
500                 // the opposite, i.e. an index counted from the end.  However,
501                 // the Text node does not support wrapped line layout in the
502                 // reverse direction, starting at the bottom right corner.
503 
504                 // We&#39;ll simulate by assuming the index will be a similar
505                 // number, then back up 10 characters just to add some slop.
506                 // For example, the ending lines might pack tighter than the
507                 // beginning lines, and therefore fit a higher number of
508                 // characters.
509                 int ind = Math.max(0, len - hit - 10);
510                 if (ind &gt; 0 &amp;&amp; wordTrim) {
511                     int brInd = lastBreakCharIndex(text, ind + 1);
512                     if (brInd &gt;= 0) {
513                         ind = brInd + 1;
514                     } else {
515                         brInd = firstBreakCharIndex(text, ind);
516                         if (brInd &gt;= 0) {
517                             ind = brInd + 1;
518                         }
519                     }
520                 }
521                 if (center) {
522                     // This is for the second part, i.e. from ellipsis to end of text.
523                     result = result + text.substring(ind);
524                 } else {
525                     result = ellipsis + text.substring(ind);
526                 }
527             }
528 
529             // Step two, check if text still overflows after we added the ellipsis.
530             // If so, remove one char or word at a time.
531             while (true) {
532                 helper.setText(result);
533                 int hit2 = helper.hitTest(endPoint).getCharIndex();
534                 if (center &amp;&amp; hit2 &lt; centerLen) {
535                     // No room for text after ellipsis. Maybe there is a newline
536                     // here, and the next line falls outside the view.
537                     if (hit2 &gt; 0 &amp;&amp; result.charAt(hit2-1) == &#39;\n&#39;) {
538                         hit2--;
539                     }
540                     result = text.substring(0, hit2) + ellipsis;
541                     break;
542                 } else if (hit2 &gt; 0 &amp;&amp; hit2 &lt; result.length()) {
543                     if (leading) {
544                         int ind = eLen + 1; // Past ellipsis and first char.
545                         if (wordTrim) {
546                             int brInd = firstBreakCharIndex(result, ind);
547                             if (brInd &gt;= 0) {
548                                 ind = brInd + 1;
549                             }
550                         }
551                         result = ellipsis + result.substring(ind);
552                     } else if (center) {
553                         int ind = centerLen + 1; // Past ellipsis and first char.
554                         if (wordTrim) {
555                             int brInd = firstBreakCharIndex(result, ind);
556                             if (brInd &gt;= 0) {
557                                 ind = brInd + 1;
558                             }
559                         }
560                         result = result.substring(0, centerLen) + result.substring(ind);
561                     } else {
562                         int ind = result.length() - eLen - 1; // Before last char and ellipsis.
563                         if (wordTrim) {
564                             int brInd = lastBreakCharIndex(result, ind);
565                             if (brInd &gt;= 0) {
566                                 ind = brInd;
567                             }
568                         }
569                         result = result.substring(0, ind) + ellipsis;
570                     }
571                 } else {
572                     break;
573                 }
574             }
575         }
576         // RESTORE STATE
577         helper.setWrappingWidth(DEFAULT_WRAPPING_WIDTH);
578         helper.setLineSpacing(DEFAULT_LINE_SPACING);
579         helper.setText(DEFAULT_TEXT);
580         helper.setBoundsType(DEFAULT_BOUNDS_TYPE);
581         return result;
582     }
583 
584 
585     private static int firstBreakCharIndex(String str, int start) {
586         char[] chars = str.toCharArray();
587         for (int i = start; i &lt; chars.length; i++) {
588             if (isPreferredBreakCharacter(chars[i])) {
589                 return i;
590             }
591         }
592         return -1;
593     }
594 
595     private static int lastBreakCharIndex(String str, int start) {
596         char[] chars = str.toCharArray();
597         for (int i = start; i &gt;= 0; i--) {
598             if (isPreferredBreakCharacter(chars[i])) {
599                 return i;
600             }
601         }
602         return -1;
603     }
604 
605     /* Recognizes white space and latin punctuation as preferred
606      * line break positions. Could do a bit better with using more
607      * of the properties from the Character class.
608      */
609     private static boolean isPreferredBreakCharacter(char ch) {
610         if (Character.isWhitespace(ch)) {
611             return true;
612         } else {
613             switch (ch) {
614             case &#39;;&#39; :
615             case &#39;:&#39; :
616             case &#39;.&#39; :
617                 return true;
618             default: return false;
619             }
620         }
621     }
622 
623     private static boolean requiresComplexLayout(Font font, String string) {
624         /*        Map attrs = font.getAttributes();
625            if (contains(attrs, KERNING, KERNING_ON) ||
626            contains(attrs, LIGATURES, LIGATURES_ON) ||
627            (attrs.containsKey(TRACKING) &amp;&amp; attrs.get(TRACKING) != null)) {
628            return true;
629            }
630            return isComplexLayout(string.toCharArray(), 0, string.length());
631          */
632         return false;
633     }
634 
635     static int computeStartOfWord(Font font, String text, int index) {
636         if (&quot;&quot;.equals(text) || index &lt; 0) return 0;
637         if (text.length() &lt;= index) return text.length();
638         // if the given index is not in a word (but in whitespace), then
639         // simply return the index
640         if (Character.isWhitespace(text.charAt(index))) {
641             return index;
642         }
643         boolean complexLayout = requiresComplexLayout(font, text);
644         if (complexLayout) {
645             // TODO needs implementation
646             return 0;
647         } else {
648             // just start walking backwards from index until either i&lt;0 or
649             // the first whitespace is found.
650             int i = index;
651             while (--i &gt;= 0) {
652                 if (Character.isWhitespace(text.charAt(i))) {
653                     return i + 1;
654                 }
655             }
656             return 0;
657         }
658     }
659 
660     static int computeEndOfWord(Font font, String text, int index) {
661         if (text.equals(&quot;&quot;) || index &lt; 0) {
662             return 0;
663         }
664         if (text.length() &lt;= index) {
665             return text.length();
666         }
667         // if the given index is not in a word (but in whitespace), then
668         // simply return the index
669         if (Character.isWhitespace(text.charAt(index))) {
670             return index;
671         }
672         boolean complexLayout = requiresComplexLayout(font, text);
673         if (complexLayout) {
674             // TODO needs implementation
675             return text.length();
676         } else {
677             // just start walking forward from index until either i &gt; length or
678             // the first whitespace is found.
679             int i = index;
680             while (++i &lt; text.length()) {
681                 if (Character.isWhitespace(text.charAt(i))) {
682                     return i;
683                 }
684             }
685             return text.length();
686         }
687     }
688 
689     // used for layout to adjust widths to honor the min/max policies consistently
690     public static double boundedSize(double value, double min, double max) {
691         // if max &lt; value, return max
692         // if min &gt; value, return min
693         // if min &gt; max, return min
694         return Math.min(Math.max(value, min), Math.max(min,max));
695     }
696 
697     public static void addMnemonics(ContextMenu popup, Scene scene) {
698         addMnemonics(popup, scene, false);
699     }
700 
701     public static void addMnemonics(ContextMenu popup, Scene scene, boolean initialState) {
702         addMnemonics(popup, scene, initialState, null);
703     }
704 
705     public static void addMnemonics(ContextMenu popup, Scene scene, boolean initialState, List&lt;Mnemonic&gt; into) {
706 
707         if (!com.sun.javafx.PlatformUtil.isMac()) {
708 
709             ContextMenuContent cmContent = (ContextMenuContent)popup.getSkin().getNode();
710             MenuItem menuitem;
711 
712             for (int i = 0 ; i &lt; popup.getItems().size() ; i++) {
713                 menuitem = popup.getItems().get(i);
714                 /*
715                 ** check is there are any mnemonics in this menu
716                 */
717                 if (menuitem.isMnemonicParsing()) {
718 
719                     TextBinding bindings = new TextBinding(menuitem.getText());
720                     int mnemonicIndex = bindings.getMnemonicIndex() ;
721                     if (mnemonicIndex &gt;= 0) {
722                         KeyCombination mnemonicKeyCombo = bindings.getMnemonicKeyCombination();
723                         Mnemonic myMnemonic = new Mnemonic(cmContent.getLabelAt(i), mnemonicKeyCombo);
724                         scene.addMnemonic(myMnemonic);
725                         NodeHelper.setShowMnemonics(cmContent.getLabelAt(i), initialState);
726                         if (into != null) {
727                             into.add(myMnemonic);
728                         }
729                     }
730                 }
731             }
732         }
733     }
734 
735 
736 
737     public static void removeMnemonics(ContextMenu popup, Scene scene) {
738 
739         if (!com.sun.javafx.PlatformUtil.isMac()) {
740 
741             ContextMenuContent cmContent = (ContextMenuContent)popup.getSkin().getNode();
742             MenuItem menuitem;
743 
744             for (int i = 0 ; i &lt; popup.getItems().size() ; i++) {
745                 menuitem = popup.getItems().get(i);
746                 /*
747                 ** check is there are any mnemonics in this menu
748                 */
749                 if (menuitem.isMnemonicParsing()) {
750 
751                     TextBinding bindings = new TextBinding(menuitem.getText());
752                     int mnemonicIndex = bindings.getMnemonicIndex() ;
753                     if (mnemonicIndex &gt;= 0) {
754                         KeyCombination mnemonicKeyCombo = bindings.getMnemonicKeyCombination();
755 
756                         ObservableList&lt;Mnemonic&gt; mnemonicsList = scene.getMnemonics().get(mnemonicKeyCombo);
757                         if (mnemonicsList != null) {
758                             for (int j = 0 ; j &lt; mnemonicsList.size() ; j++) {
759                                 if (mnemonicsList.get(j).getNode() == cmContent.getLabelAt(i)) {
760                                     mnemonicsList.remove(j);
761                                 }
762                             }
763                         }
764                     }
765                 }
766             }
767         }
768     }
769 
770     public static double computeXOffset(double width, double contentWidth, HPos hpos) {
771         if (hpos == null) {
772             return 0;
773         }
774 
775         switch(hpos) {
776             case LEFT:
777                return 0;
778             case CENTER:
779                return (width - contentWidth) / 2;
780             case RIGHT:
781                return width - contentWidth;
782             default:
783                 return 0;
784         }
785     }
786 
787     public static double computeYOffset(double height, double contentHeight, VPos vpos) {
788         if (vpos == null) {
789             return 0;
790         }
791 
792         switch(vpos) {
793             case TOP:
794                return 0;
795             case CENTER:
796                return (height - contentHeight) / 2;
797             case BOTTOM:
798                return height - contentHeight;
799             default:
800                 return 0;
801         }
802     }
803 
804     /*
805     ** Returns true if the platform is to use Two-Level-Focus.
806     ** This is in the Util class to ease any changes in
807     ** the criteria for enabling this feature.
808     **
809     ** TwoLevelFocus is needed on platforms that
810     ** only support 5-button navigation (arrow keys and Select/OK).
811     **
812     */
813     public static boolean isTwoLevelFocus() {
814         return Platform.isSupported(ConditionalFeature.TWO_LEVEL_FOCUS);
815     }
816 
817 
818     // useful method for linking things together when before a property is
819     // necessarily set
820     public static &lt;T&gt; void executeOnceWhenPropertyIsNonNull(ObservableValue&lt;T&gt; p, Consumer&lt;T&gt; consumer) {
821         if (p == null) return;
822 
823         T value = p.getValue();
824         if (value != null) {
825             consumer.accept(value);
826         } else {
827             final InvalidationListener listener = new InvalidationListener() {
828                 @Override public void invalidated(Observable observable) {
829                     T value = p.getValue();
830 
831                     if (value != null) {
832                         p.removeListener(this);
833                         consumer.accept(value);
834                     }
835                 }
836             };
837             p.addListener(listener);
838         }
839     }
840 
841     public static String formatHexString(Color c) {
842         if (c != null) {
843             return String.format((Locale) null, &quot;#%02x%02x%02x&quot;,
844                     Math.round(c.getRed() * 255),
845                     Math.round(c.getGreen() * 255),
846                     Math.round(c.getBlue() * 255));
847         } else {
848             return null;
849         }
850     }
851 
852     public static URL getResource(String str) {
853         return Utils.class.getResource(str);
854     }
855 
856 }
    </pre>
  </body>
</html>
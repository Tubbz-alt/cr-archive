<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.graphics/src/main/native-glass/ios/GlassApplication.m</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #import &lt;UIKit/UIKit.h&gt;
  27 
  28 #import &quot;GlassMacros.h&quot;
  29 #import &quot;GlassApplication.h&quot;
  30 #import &quot;GlassHelper.h&quot;
  31 #import &quot;GlassStatics.h&quot;
  32 #import &quot;GlassTimer.h&quot;
  33 #import &quot;GlassWindow.h&quot;
  34 #import &quot;GlassScreen.h&quot;
  35 
  36 pthread_key_t GlassThreadDataKey = 0;
  37 
  38 // Java JNI IDs
  39 JNIEnv *jEnv = NULL;
  40 
  41 jclass mat_jIntegerClass = NULL;
  42 jclass mat_jMapClass = NULL;
  43 jclass mat_jBooleanClass = NULL;
  44 jclass mat_jLongClass = NULL;
  45 
  46 #if PROTECT_INVOKE_AND_WAIT
  47 static jobject mat_eventThread = 0;
  48 static jclass mat_jThreadClass = 0;
  49 static jmethodID mat_ThreadCurrentThread = 0;
  50 #endif
  51 
  52 jmethodID mat_jVectorAddElement = 0;
  53 
  54 jclass mat_jScreenClass = NULL;
  55 
  56 jclass mat_jViewClass = NULL;
  57 
  58 jclass jApplicationClass = NULL;
  59 jmethodID jApplicationReportException = 0;
  60 
  61 jmethodID mat_jViewNotifyResize = 0;
  62 jmethodID mat_jViewNotifyRepaint = 0;
  63 jmethodID mat_jViewNotifyKey = 0;
  64 jmethodID mat_jViewNotifyMouse = 0;
  65 jmethodID mat_jViewNotifyInputMethod = 0;
  66 jmethodID mat_jViewNotifyView = 0;
  67 
  68 jmethodID mat_jMapGetMethod = 0;
  69 jmethodID mat_jBooleanValueMethod = 0;
  70 jmethodID mat_jIntegerValueMethod = 0;
  71 jmethodID mat_jLongValueMethod = 0;
  72 
  73 jfieldID mat_jViewWindow = 0;
  74 jfieldID mat_jViewWidth = 0;
  75 jfieldID mat_jViewHeight = 0;
  76 jfieldID mat_jViewPtr = 0;
  77 
  78 jclass mat_jWindowClass = NULL;
  79 
  80 jfieldID mat_jWindowX = 0;
  81 jfieldID mat_jWindowY = 0;
  82 jfieldID mat_jWindowWidth = 0;
  83 jfieldID mat_jWindowHeight = 0;
  84 jfieldID mat_jWindowView = 0;
  85 jfieldID mat_jWindowPtr = 0;
  86 
  87 jmethodID mat_jWindowNotifyClose = 0;
  88 jmethodID mat_jWindowNotifyDestroy = 0;
  89 jmethodID mat_jWindowNotifyFocus = 0;
  90 jmethodID mat_jWindowNotifyFocusDisabled = 0;
  91 jmethodID jWindowNotifyFocusUngrab = 0;
  92 jmethodID mat_jWindowNotifyMove = 0;
  93 jmethodID mat_jWindowNotifyMoveToAnotherScreen = 0;
  94 jmethodID mat_jWindowNotifyResize = 0;
  95 
  96 jclass mat_jPixelsClass = NULL;
  97 
  98 jfieldID mat_jPixelsWidth = 0;
  99 jfieldID mat_jPixelsHeight = 0;
 100 jfieldID mat_jPixelsBytes = 0;
 101 jfieldID mat_jPixelsInts = 0;
 102 
 103 jmethodID mat_jPixelsAttachData = 0;
 104 
 105 jclass mat_jCursorClass = NULL;
 106 
 107 
 108 // a unix pipe which we will use as a runnable queue for posted events.
 109 static int postEventPipe[2];
 110 static int haveIDs = 0;
 111 
 112 static BOOL shouldKeepRunningNestedLoop = YES;
 113 static jobject nestedLoopReturnValue = NULL;
 114 
 115 //Library entrypoint
 116 JNIEXPORT jint JNICALL
 117 JNI_OnLoad_glass(JavaVM *vm, void *reserved)
 118 {
 119 #ifdef JNI_VERSION_1_8
 120     //min. returned JNI_VERSION required by JDK8 for builtin libraries
 121     JNIEnv *env;
 122     if ((*vm)-&gt;GetEnv(vm, (void **)&amp;env, JNI_VERSION_1_8) != JNI_OK) {
 123         return JNI_VERSION_1_4;
 124     }
 125     return JNI_VERSION_1_8;
 126 #else
 127     return JNI_VERSION_1_4;
 128 #endif
 129 }
 130 
 131 /*
 132  * Function to set the context class loader for the main glass event thread.
 133  * This is necessary because we co-opt the UIKit thread as the glass event
 134  * thread.
 135  */
 136 jboolean setContextClassLoader(JNIEnv *env, jobject contextClassLoader)
 137 {
 138     jclass threadCls = (*env)-&gt;FindClass(env, &quot;java/lang/Thread&quot;);
 139     if ((*env)-&gt;ExceptionCheck(env) || threadCls == NULL) {
 140         return JNI_FALSE;
 141     }
 142     jmethodID currentThreadMID = (*env)-&gt;GetStaticMethodID(env, threadCls,
 143                                                            &quot;currentThread&quot;, &quot;()Ljava/lang/Thread;&quot;);
 144     if ((*env)-&gt;ExceptionCheck(env) || currentThreadMID == NULL) {
 145         return JNI_FALSE;
 146     }
 147     jobject jCurrentThread = (*env)-&gt;CallStaticObjectMethod(env, threadCls, currentThreadMID);
 148     if ((*env)-&gt;ExceptionCheck(env) || jCurrentThread == NULL) {
 149         return JNI_FALSE;
 150     }
 151 
 152     jmethodID setContextClassLoaderMID = (*env)-&gt;GetMethodID(env, threadCls,
 153                                                              &quot;setContextClassLoader&quot;, &quot;(Ljava/lang/ClassLoader;)V&quot;);
 154     if ((*env)-&gt;ExceptionCheck(env) || setContextClassLoaderMID == NULL) {
 155         return JNI_FALSE;
 156     }
 157     (*env)-&gt;CallVoidMethod(env, jCurrentThread, setContextClassLoaderMID, contextClassLoader);
 158     if ((*env)-&gt;ExceptionCheck(env)) {
 159         return JNI_FALSE;
 160     }
 161 
 162     return JNI_TRUE;
 163 }
 164 
 165 
 166 /*
 167  * Function to find a glass class using the context class loader. All glass
 168  * classes must be looked up using this function rather than FindClass so that
 169  * the correct ClassLoader is used.
 170  *
 171  * Note that the className passed to this function must use &quot;.&quot; rather than &quot;/&quot;
 172  * as a package separator.
 173  */
 174 jclass classForName(JNIEnv *env, char *className)
 175 {
 176     jclass threadCls = (*env)-&gt;FindClass(env, &quot;java/lang/Thread&quot;);
 177     if ((*env)-&gt;ExceptionCheck(env) || threadCls == NULL) {
 178         return NULL;
 179     }
 180     jmethodID currentThreadMID = (*env)-&gt;GetStaticMethodID(env, threadCls,
 181                                                            &quot;currentThread&quot;, &quot;()Ljava/lang/Thread;&quot;);
 182     if ((*env)-&gt;ExceptionCheck(env) || currentThreadMID == NULL) {
 183         return NULL;
 184     }
 185     jobject jCurrentThread = (*env)-&gt;CallStaticObjectMethod(env, threadCls, currentThreadMID);
 186     if ((*env)-&gt;ExceptionCheck(env) || jCurrentThread == NULL) {
 187         return NULL;
 188     }
 189 
 190     jmethodID getContextClassLoaderMID = (*env)-&gt;GetMethodID(env, threadCls,
 191                                                              &quot;getContextClassLoader&quot;, &quot;()Ljava/lang/ClassLoader;&quot;);
 192     if ((*env)-&gt;ExceptionCheck(env) || getContextClassLoaderMID == NULL) {
 193         return NULL;
 194     }
 195     jobject contextClassLoader = (*env)-&gt;CallObjectMethod(env, jCurrentThread, getContextClassLoaderMID);
 196     if ((*env)-&gt;ExceptionCheck(env)) {
 197         return NULL;
 198     }
 199 
 200     jclass classCls = (*env)-&gt;FindClass(env, &quot;java/lang/Class&quot;);
 201     if ((*env)-&gt;ExceptionCheck(env) || classCls == NULL) {
 202         return NULL;
 203     }
 204     jmethodID forNameMID = (*env)-&gt;GetStaticMethodID(env, classCls,
 205                                                      &quot;forName&quot;, &quot;(Ljava/lang/String;ZLjava/lang/ClassLoader;)Ljava/lang/Class;&quot;);
 206     if ((*env)-&gt;ExceptionCheck(env) || forNameMID == NULL) {
 207         return NULL;
 208     }
 209     jstring classNameStr = (*env)-&gt;NewStringUTF(env, className);
 210     if ((*env)-&gt;ExceptionCheck(env) || classNameStr == NULL) {
 211         return NULL;
 212     }
 213     jclass theCls = (*env)-&gt;CallStaticObjectMethod(env, classCls, forNameMID,
 214                                                    classNameStr, JNI_TRUE, contextClassLoader);
 215     if ((*env)-&gt;ExceptionCheck(env)) {
 216         return NULL;
 217     }
 218     return theCls;
 219 }
 220 
 221 
 222 
 223 @interface GlassRunnable : NSObject
 224 {
 225 
 226 }
 227 
 228 @property (nonatomic) jobject jRunnable;
 229 
 230 - (id)initWithRunnable:(jobject)runnable;
 231 - (void)run;
 232 
 233 @end
 234 
 235 
 236 
 237 @implementation GlassRunnable
 238 
 239 @synthesize jRunnable;
 240 
 241 - (id)initWithRunnable:(jobject)runnable
 242 {
 243     self.jRunnable = runnable;
 244     return self;
 245 }
 246 
 247 
 248 - (void)run
 249 {
 250     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 251     {
 252         NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 253         if (jEnv != NULL)
 254         {
 255             (*jEnv)-&gt;CallVoidMethod(jEnv, self.jRunnable, jRunnableRun);
 256             GLASS_CHECK_EXCEPTION(jEnv);
 257         }
 258 
 259         [self release];
 260     }
 261     [pool drain];
 262 }
 263 
 264 
 265 - (void)dealloc
 266 {
 267     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 268     if (jEnv != NULL)
 269     {
 270         (*jEnv)-&gt;DeleteGlobalRef(jEnv, self.jRunnable);
 271     }
 272     self.jRunnable = NULL;
 273 
 274     [super dealloc];
 275 }
 276 
 277 @end
 278 
 279 
 280 
 281 @implementation GlassApplication
 282 
 283 @synthesize started;
 284 @synthesize condition;
 285 @synthesize jApplication;
 286 @synthesize jLaunchable;
 287 @synthesize jContextClassLoader;
 288 
 289 - (id)initWithEnv:(JNIEnv*)env application:(jobject)application contextClassLoader:(jobject)contextClassLoader launchable:(jobject)launchable
 290 {
 291     GLASS_LOG(&quot;GlassApplication_initWithEnv called.&quot;);
 292     self = [super init];
 293     if (self != nil)
 294     {
 295         self.condition = [[NSCondition alloc] init];
 296         [self.condition release]; //condition property retains; alloc as well
 297         self.started = NO;
 298         (*env)-&gt;GetJavaVM(env, &amp;jVM);
 299         self.jApplication = (*env)-&gt;NewGlobalRef(env, application);
 300         if (launchable != NULL)
 301         {
 302             self.jLaunchable = (*env)-&gt;NewGlobalRef(env, launchable);
 303         }
 304         if (contextClassLoader != NULL)
 305         {
 306             self.jContextClassLoader = (*env)-&gt;NewGlobalRef(env, contextClassLoader);
 307         }
 308     }
 309     return self;
 310 }
 311 
 312 // Called e.g. by GlassViewController when app. user interface changes orientation.
 313 // FX can resize Stage, adjust UI, etc. in response.
 314 - (void)GlassApplicationDidChangeScreenParameters
 315 {
 316     GLASS_LOG(&quot;GlassApplication_GlassApplicationDidChangeScreenParameters&quot;);
 317     GlassScreenDidChangeScreenParameters(jEnv);
 318 }
 319 
 320 
 321 // Application state changes callbacks to java
 322 
 323 - (void)callWillResignActive
 324 {
 325     GET_MAIN_JENV;
 326     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 327     {
 328         (*env)-&gt;CallVoidMethod(env, self.jApplication, [GlassHelper ApplicationNotifyWillResignActiveMethod]);
 329     }
 330     [pool drain];
 331     GLASS_CHECK_EXCEPTION(env);
 332 }
 333 
 334 - (void)callDidResignActive
 335 {
 336     GET_MAIN_JENV;
 337     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 338     {
 339         (*env)-&gt;CallVoidMethod(env, self.jApplication, [GlassHelper ApplicationNotifyDidResignActiveMethod]);
 340     }
 341     [pool drain];
 342     GLASS_CHECK_EXCEPTION(env);
 343 }
 344 
 345 - (void)callDidReceiveMemoryWarning
 346 {
 347     GET_MAIN_JENV;
 348     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 349     {
 350         (*env)-&gt;CallVoidMethod(env, self.jApplication, [GlassHelper ApplicationNotifyDidReceiveMemoryWarningMethod]);
 351     }
 352     [pool drain];
 353     GLASS_CHECK_EXCEPTION(env);
 354 }
 355 
 356 
 357 - (void)callWillBecomeActive
 358 {
 359     GET_MAIN_JENV;
 360     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 361     {
 362         (*env)-&gt;CallVoidMethod(env, self.jApplication, [GlassHelper ApplicationNotifyWillBecomeActiveMethod]);
 363     }
 364     [pool drain];
 365     GLASS_CHECK_EXCEPTION(env);
 366 }
 367 
 368 - (void)callDidBecomeActive
 369 {
 370     GET_MAIN_JENV;
 371     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 372     {
 373         (*env)-&gt;CallVoidMethod(env, self.jApplication, [GlassHelper ApplicationNotifyDidBecomeActiveMethod]);
 374     }
 375     [pool drain];
 376     GLASS_CHECK_EXCEPTION(env);
 377 }
 378 
 379 - (void)callQuit
 380 {
 381     GET_MAIN_JENV;
 382     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 383     {
 384         (*env)-&gt;CallVoidMethod(env, self.jApplication, [GlassHelper ApplicationNotifyWillQuitMethod]);
 385     }
 386     [pool drain];
 387     GLASS_CHECK_EXCEPTION(env);
 388 }
 389 
 390 
 391 - (void)applicationCallback:(SEL)method
 392 {
 393     if ([[NSThread currentThread] isMainThread] == YES)
 394     {
 395         [self performSelector:method];
 396     }
 397     else
 398     {
 399         [self performSelectorOnMainThread:method withObject:nil waitUntilDone:YES];
 400     }
 401 }
 402 
 403 
 404 - (void)applicationWillResignActive:(UIApplication *)application
 405 {
 406     /*
 407      Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
 408      Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.
 409      */
 410     GLASS_LOG(&quot;GlassApplication:applicationWillResignActive&quot;);
 411     [self applicationCallback:@selector(callWillResignActive)];
 412 }
 413 
 414 
 415 - (void)applicationDidEnterBackground:(UIApplication *)application {
 416     GLASS_LOG(&quot;GlassApplication:applicationDidEnterBackground&quot;);
 417     [self applicationCallback:@selector(callDidResignActive)];
 418 }
 419 
 420 - (void)applicationDidReceiveMemoryWarning:(UIApplication *)application {
 421     GLASS_LOG(&quot;GlassApplication:applicationDidReceiveMemoryWarning&quot;);
 422     [self applicationCallback:@selector(callDidReceiveMemoryWarning)];
 423 }
 424 
 425 - (void)applicationWillEnterForeground:(UIApplication *)application {
 426     /*
 427      Called as part of  transition from the background to the inactive state: here you can undo many of the changes made on entering the background.
 428      */
 429     GLASS_LOG(&quot;GlassApplication:applicationWillEnterForeground&quot;);
 430     [self applicationCallback:@selector(callWillBecomeActive)];
 431 }
 432 
 433 
 434 - (void)applicationDidBecomeActive:(UIApplication *)application {
 435     /*
 436      Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
 437      */
 438     GLASS_LOG(&quot;GlassApplication:applicationDidBecomeActive&quot;);
 439     [self applicationCallback:@selector(callDidBecomeActive)];
 440 }
 441 
 442 
 443 - (void)applicationWillTerminate:(UIApplication *)application {
 444     GLASS_LOG(&quot;GlassApplication:applicationWillTerminate&quot;);
 445     [self applicationCallback:@selector(callQuit)];
 446 }
 447 
 448 
 449 - (void)applicationWillFinishLaunching:(NSNotification *)aNotification
 450 {
 451     GLASS_LOG(&quot;GlassApplication_applicationWillFinishLaunching&quot;);
 452     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 453     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 454     {
 455         if (self.jLaunchable != NULL)
 456         {
 457             jclass runnableClass = classForName(jEnv, &quot;java.lang.Runnable&quot;);
 458             if ((*jEnv)-&gt;ExceptionCheck(jEnv) == JNI_TRUE)
 459             {
 460                 (*jEnv)-&gt;ExceptionDescribe(jEnv);
 461             }
 462 
 463             jmethodID runMethod = (*jEnv)-&gt;GetMethodID(jEnv, runnableClass, &quot;run&quot;, &quot;()V&quot;);
 464             if ((*jEnv)-&gt;ExceptionCheck(jEnv) == JNI_TRUE)
 465             {
 466                 (*jEnv)-&gt;ExceptionDescribe(jEnv);
 467             }
 468 
 469             if ((runnableClass != 0) &amp;&amp; (runMethod != 0))
 470             {
 471                 (*jEnv)-&gt;CallVoidMethod(jEnv, self.jLaunchable, runMethod);
 472                 if ((*jEnv)-&gt;ExceptionCheck(jEnv) == JNI_TRUE)
 473                 {
 474                     (*jEnv)-&gt;ExceptionDescribe(jEnv);
 475                 }
 476             }
 477             else if (runnableClass == 0)
 478             {
 479                 NSLog(@&quot;ERROR: Glass could not find Runnable class&quot;);
 480             }
 481             else if (runMethod == 0)
 482             {
 483                 NSLog(@&quot;ERROR: Glass could not find run() method&quot;);
 484             }
 485         }
 486 
 487         [self notify];
 488     }
 489     [pool drain];
 490 
 491     GLASS_CHECK_EXCEPTION(jEnv);
 492 }
 493 
 494 
 495 - (void)runLoop:(id)selector
 496 {
 497     GLASS_LOG(&quot;GlassApplication:runLoop&quot;);
 498     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 499     jint error = (*jVM)-&gt;AttachCurrentThread(jVM, (void **)&amp;jEnv, NULL);
 500     GLASS_LOG(&quot;AttachCurrentThread returned %ld&quot;,error);
 501 
 502 
 503     if (error == 0)
 504     {
 505         NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 506         {
 507             if ([[NSThread currentThread] name] == nil) {
 508                 [[NSThread currentThread] setName:@&quot;Main UIKit Thread&quot;];
 509             }
 510 
 511             GlassApplication *glassApp = (GlassApplication *) selector;
 512 
 513             // Set the context class loader for this thread
 514             if (!setContextClassLoader(jEnv, glassApp.jContextClassLoader)) {
 515                 NSLog(@&quot;ERROR: can&#39;t set the context classloader&quot;);
 516             }
 517             GLASS_CHECK_EXCEPTION(jEnv);
 518 
 519             // Load IosApplication class using the glass classloader
 520             jclass cls = [GlassHelper ClassForName:&quot;com.sun.glass.ui.ios.IosApplication&quot; withEnv:jEnv];
 521             if (!cls)
 522             {
 523                 NSLog(@&quot;ERROR: can&#39;t find the IosApplication class&quot;);
 524             }
 525             else
 526             {
 527                 jmethodID setEventThreadMID = (*jEnv)-&gt;GetMethodID(jEnv, cls, &quot;setEventThread&quot;, &quot;()V&quot;);
 528                 if (!setEventThreadMID)
 529                 {
 530                     NSLog(@&quot;ERROR: can&#39;t get IosApplication.setEventThread() method ID&quot;);
 531                 }
 532                 else
 533                 {
 534                     (*jEnv)-&gt;CallVoidMethod(jEnv, glassApp-&gt;jApplication, setEventThreadMID);
 535                 }
 536             }
 537             GLASS_CHECK_EXCEPTION(jEnv);
 538 
 539             //Set self as UIApplicationDelegate so we can pass life cycle notifications from iOS
 540             //to JavaFX
 541             [[UIApplication sharedApplication] setDelegate:glassApp];
 542 
 543             [glassApp performSelectorOnMainThread:@selector(applicationWillFinishLaunching:) withObject:NULL waitUntilDone:NO];
 544             GLASS_CHECK_EXCEPTION(jEnv);
 545         }
 546         [pool drain];
 547     }
 548     else // attaching to JVM failed
 549     {
 550         NSLog(@&quot;ERROR: Glass could not attach to VM, result:%ld&quot;, error);
 551     }
 552 }
 553 
 554 
 555 + (jobject)enterNestedEventLoopWithEnv:(JNIEnv*)env
 556 {
 557     jobject ret = NULL;
 558     GLASS_LOG(&quot;entering nestedEventLoop&quot;);
 559 
 560     NSRunLoop *theRL = [NSRunLoop currentRunLoop];
 561     UIApplication * app = [UIApplication sharedApplication];
 562     shouldKeepRunningNestedLoop = YES;
 563     while (shouldKeepRunningNestedLoop &amp;&amp; [theRL runMode:NSDefaultRunLoopMode
 564                                               beforeDate:[NSDate dateWithTimeIntervalSinceNow:0.010]])
 565     {
 566         // don&#39;t do anything, as long as we should stay here events are forwarded.
 567     }
 568     GLASS_LOG(&quot;leaving enterNestedEventLoop&quot;);
 569 
 570     if (nestedLoopReturnValue != NULL) {
 571         ret = (*env)-&gt;NewLocalRef(env, nestedLoopReturnValue);
 572         (*env)-&gt;DeleteGlobalRef(env, nestedLoopReturnValue);
 573         nestedLoopReturnValue = NULL;
 574     }
 575 
 576     shouldKeepRunningNestedLoop = YES;
 577 
 578     return ret;
 579 }
 580 
 581 + (void)leaveNestedEventLoopWithEnv:(JNIEnv*)env retValue:(jobject)retValue
 582 {
 583     if (retValue != NULL) {
 584         nestedLoopReturnValue = (*env)-&gt;NewGlobalRef(env, retValue);
 585     }
 586     shouldKeepRunningNestedLoop = NO;
 587 }
 588 
 589 
 590 
 591 - (void)notify
 592 {
 593     [self.condition lock];
 594     [self setStarted: YES];
 595     [self.condition signal];
 596     [self.condition unlock];
 597 }
 598 
 599 
 600 -(void)await
 601 {
 602     [self.condition lock];
 603     while(self.started == NO)
 604     {
 605         GLASS_LOG(&quot;&lt;--&gt;waiting for [glass started]&quot;);
 606         [self.condition wait];
 607     }
 608     [self.condition unlock];
 609 }
 610 
 611 
 612 - (void)dealloc {
 613     [[NSNotificationCenter defaultCenter] removeObserver: self];
 614     self.condition = nil;
 615     [super dealloc];
 616 }
 617 
 618 @end
 619 
 620 
 621 
 622 /*
 623  * Class:     com_sun_glass_ui_ios_IosApplication
 624  * Method:    _initIDs
 625  * Signature: ()V
 626  */
 627 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosApplication__1initIDs
 628 (JNIEnv *env, jclass jClass)
 629 {
 630 
 631     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosApplication__1initIDs&quot;);
 632 
 633     if (haveIDs)
 634         return;
 635     haveIDs = 1;
 636 
 637     assert(pthread_key_create(&amp;GlassThreadDataKey, NULL) == 0);
 638 
 639     jApplicationClass = (*env)-&gt;NewGlobalRef(env, jClass);
 640     jApplicationReportException = (*env)-&gt;GetStaticMethodID(env, jClass, &quot;reportException&quot;, &quot;(Ljava/lang/Throwable;)V&quot;);
 641 
 642     mat_jIntegerClass = (*env)-&gt;NewGlobalRef(env, (*env)-&gt;FindClass(env, &quot;java/lang/Integer&quot;));
 643     mat_jMapClass = (*env)-&gt;NewGlobalRef(env, (*env)-&gt;FindClass(env, &quot;java/util/Map&quot;));
 644     mat_jBooleanClass = (*env)-&gt;NewGlobalRef(env, (*env)-&gt;FindClass(env, &quot;java/lang/Boolean&quot;));
 645     mat_jLongClass = (*env)-&gt;NewGlobalRef(env, (*env)-&gt;FindClass(env, &quot;java/lang/Long&quot;));
 646 
 647 #if PROTECT_INVOKE_AND_WAIT
 648     mat_jThreadClass = (*env)-&gt;NewGlobalRef(env, (*env)-&gt;FindClass(env, &quot;java/lang/Thread&quot;));
 649     mat_ThreadCurrentThread = (*env)-&gt;GetStaticMethodID(env, mat_jThreadClass, &quot;currentThread&quot;, &quot;()Ljava/lang/Thread;&quot;);
 650 #endif
 651 
 652     mat_jVectorAddElement = (*env)-&gt;GetMethodID(env, (*env)-&gt;FindClass(env, &quot;java/util/Vector&quot;), &quot;addElement&quot;, &quot;(Ljava/lang/Object;)V&quot;);
 653 
 654     mat_jMapGetMethod = (*env)-&gt;GetMethodID(env, mat_jMapClass, &quot;get&quot;, &quot;(Ljava/lang/Object;)Ljava/lang/Object;&quot;);
 655     mat_jBooleanValueMethod = (*env)-&gt;GetMethodID(env, mat_jBooleanClass, &quot;booleanValue&quot;, &quot;()Z&quot;);
 656     mat_jIntegerValueMethod = (*env)-&gt;GetMethodID(env, mat_jIntegerClass, &quot;intValue&quot;, &quot;()I&quot;);
 657     mat_jLongValueMethod = (*env)-&gt;GetMethodID(env, mat_jLongClass, &quot;longValue&quot;, &quot;()J&quot;);
 658 
 659     jRunnableRun = (*env)-&gt;GetMethodID(env, (*env)-&gt;FindClass(env, &quot;java/lang/Runnable&quot;), &quot;run&quot;, &quot;()V&quot;);
 660 
 661     // screen specific
 662     mat_jScreenClass = (*env)-&gt;NewGlobalRef(env, (*env)-&gt;FindClass(env, &quot;com/sun/glass/ui/Screen&quot;));
 663     GLASS_CHECK_EXCEPTION(env);
 664 
 665     // view specific
 666     mat_jViewClass = (*env)-&gt;NewGlobalRef(env, (*env)-&gt;FindClass(env, &quot;com/sun/glass/ui/ios/IosView&quot;));
 667     jclass mat_jViewBaseClass = (*env)-&gt;FindClass(env, &quot;com/sun/glass/ui/View&quot;);
 668     GLASS_CHECK_EXCEPTION(env);
 669 
 670     mat_jViewNotifyResize = (*env)-&gt;GetMethodID(env, mat_jViewBaseClass, &quot;notifyResize&quot;, &quot;(II)V&quot;);
 671     mat_jViewNotifyRepaint = (*env)-&gt;GetMethodID(env, mat_jViewBaseClass, &quot;notifyRepaint&quot;, &quot;(IIII)V&quot;);
 672     mat_jViewNotifyKey = (*env)-&gt;GetMethodID(env, mat_jViewBaseClass, &quot;notifyKey&quot;, &quot;(II[CI)V&quot;);
 673     mat_jViewNotifyMouse = (*env)-&gt;GetMethodID(env, mat_jViewBaseClass, &quot;notifyMouse&quot;, &quot;(IIIIIIIZZ)V&quot;);
 674     mat_jViewNotifyInputMethod = (*env)-&gt;GetMethodID(env, mat_jViewBaseClass, &quot;notifyInputMethod&quot;, &quot;(Ljava/lang/String;[I[I[BIII)V&quot;);
 675     mat_jViewNotifyView = (*env)-&gt;GetMethodID(env, mat_jViewBaseClass, &quot;notifyView&quot;, &quot;(I)V&quot;);
 676     GLASS_CHECK_EXCEPTION(env);
 677 
 678 
 679     if (jViewNotifyDragEnter == NULL)
 680     {
 681         jViewNotifyDragEnter = (*env)-&gt;GetMethodID(env, mat_jViewClass, &quot;notifyDragEnter&quot;, &quot;(IIIII)I&quot;);
 682     }
 683 
 684     if (jViewNotifyDragOver == NULL)
 685     {
 686         jViewNotifyDragOver = (*env)-&gt;GetMethodID(env, mat_jViewClass, &quot;notifyDragOver&quot;, &quot;(IIIII)I&quot;);
 687     }
 688 
 689     if (jViewNotifyDragLeave == NULL)
 690     {
 691         jViewNotifyDragLeave = (*env)-&gt;GetMethodID(env, mat_jViewClass, &quot;notifyDragLeave&quot;, &quot;()V&quot;);
 692     }
 693 
 694     if (jViewNotifyDragDrop == NULL)
 695     {
 696         jViewNotifyDragDrop = (*env)-&gt;GetMethodID(env, mat_jViewClass, &quot;notifyDragDrop&quot;, &quot;(IIIII)I&quot;);
 697     }
 698 
 699     if (jViewNotifyDragEnd == NULL)
 700     {
 701         jViewNotifyDragEnd = (*env)-&gt;GetMethodID(env, mat_jViewClass, &quot;notifyDragEnd&quot;, &quot;(I)V&quot;);
 702     }
 703 
 704     GLASS_CHECK_EXCEPTION(env);
 705 
 706     mat_jViewWidth = (*env)-&gt;GetFieldID(env, mat_jViewBaseClass, &quot;width&quot;,&quot;I&quot;);
 707     mat_jViewHeight = (*env)-&gt;GetFieldID(env, mat_jViewBaseClass, &quot;height&quot;,&quot;I&quot;);
 708     mat_jViewWindow = (*env)-&gt;GetFieldID(env, mat_jViewBaseClass, &quot;window&quot;,&quot;Lcom/sun/glass/ui/Window;&quot;);
 709     GLASS_CHECK_EXCEPTION(env);
 710 
 711     mat_jViewPtr = (*env)-&gt;GetFieldID(env, mat_jViewBaseClass, &quot;ptr&quot;, &quot;J&quot;);
 712     GLASS_CHECK_EXCEPTION(env);
 713 
 714     //window specific
 715     mat_jWindowClass = (*env)-&gt;NewGlobalRef(env, (*env)-&gt;FindClass(env, &quot;com/sun/glass/ui/ios/IosWindow&quot;));
 716     jclass mat_jWindowBaseClass = (*env)-&gt;FindClass(env, &quot;com/sun/glass/ui/Window&quot;);
 717     GLASS_CHECK_EXCEPTION(env);
 718 
 719     mat_jWindowX = (*env)-&gt;GetFieldID(env, mat_jWindowBaseClass, &quot;x&quot;, &quot;I&quot;);
 720     mat_jWindowY = (*env)-&gt;GetFieldID(env, mat_jWindowBaseClass, &quot;y&quot;, &quot;I&quot;);
 721     mat_jWindowWidth = (*env)-&gt;GetFieldID(env, mat_jWindowBaseClass, &quot;width&quot;, &quot;I&quot;);
 722     mat_jWindowHeight = (*env)-&gt;GetFieldID(env, mat_jWindowBaseClass, &quot;height&quot;, &quot;I&quot;);
 723     mat_jWindowPtr = (*env)-&gt;GetFieldID(env, mat_jWindowBaseClass, &quot;ptr&quot;, &quot;J&quot;);
 724 
 725     mat_jWindowView = (*env)-&gt;GetFieldID(env, mat_jWindowBaseClass, &quot;view&quot;, &quot;Lcom/sun/glass/ui/View;&quot;);
 726     GLASS_CHECK_EXCEPTION(env);
 727 
 728     mat_jWindowNotifyMove = (*env)-&gt;GetMethodID(env, mat_jWindowBaseClass, &quot;notifyMove&quot;, &quot;(II)V&quot;);
 729     mat_jWindowNotifyResize = (*env)-&gt;GetMethodID(env, mat_jWindowBaseClass, &quot;notifyResize&quot;, &quot;(III)V&quot;);
 730     mat_jWindowNotifyMoveToAnotherScreen = (*env)-&gt;GetMethodID(env, mat_jWindowBaseClass, &quot;notifyMoveToAnotherScreen&quot;, &quot;(Lcom/sun/glass/ui/Screen;)V&quot;);
 731     mat_jWindowNotifyClose = (*env)-&gt;GetMethodID(env, mat_jWindowBaseClass, &quot;notifyClose&quot;, &quot;()V&quot;);
 732     mat_jWindowNotifyFocus = (*env)-&gt;GetMethodID(env, mat_jWindowBaseClass, &quot;notifyFocus&quot;, &quot;(I)V&quot;);
 733     mat_jWindowNotifyDestroy = (*env)-&gt;GetMethodID(env, mat_jWindowBaseClass, &quot;notifyDestroy&quot;, &quot;()V&quot;);
 734     mat_jWindowNotifyFocusDisabled = (*env)-&gt;GetMethodID(env, mat_jWindowBaseClass, &quot;notifyFocusDisabled&quot;, &quot;()V&quot;);
 735     jWindowNotifyFocusUngrab = (*env)-&gt;GetMethodID(env, mat_jWindowBaseClass, &quot;notifyFocusUngrab&quot;, &quot;()V&quot;);
 736     GLASS_CHECK_EXCEPTION(env);
 737 
 738     //pixels specific
 739     mat_jPixelsClass = (*env)-&gt;NewGlobalRef(env, (*env)-&gt;FindClass(env, &quot;com/sun/glass/ui/ios/IosPixels&quot;));
 740     jclass mat_jPixelsBaseClass = (*env)-&gt;FindClass(env, &quot;com/sun/glass/ui/Pixels&quot;);
 741     GLASS_CHECK_EXCEPTION(env);
 742 
 743     mat_jPixelsWidth = (*env)-&gt;GetFieldID(env, mat_jPixelsBaseClass, &quot;width&quot;, &quot;I&quot;);
 744     mat_jPixelsHeight = (*env)-&gt;GetFieldID(env, mat_jPixelsBaseClass, &quot;height&quot;, &quot;I&quot;);
 745     mat_jPixelsBytes = (*env)-&gt;GetFieldID(env, mat_jPixelsBaseClass, &quot;bytes&quot;, &quot;Ljava/nio/ByteBuffer;&quot;);
 746     mat_jPixelsInts = (*env)-&gt;GetFieldID(env, mat_jPixelsBaseClass, &quot;ints&quot;, &quot;Ljava/nio/IntBuffer;&quot;);
 747     GLASS_CHECK_EXCEPTION(env);
 748 
 749     mat_jPixelsAttachData = (*env)-&gt;GetMethodID(env, mat_jPixelsBaseClass, &quot;attachData&quot;, &quot;(J)V&quot;);
 750     GLASS_CHECK_EXCEPTION(env);
 751 
 752     //cursor specific
 753     mat_jCursorClass = (*env)-&gt;NewGlobalRef(env, (*env)-&gt;FindClass(env, &quot;com/sun/glass/ui/ios/IosCursor&quot;));
 754     GLASS_CHECK_EXCEPTION(env);
 755 
 756     if (pipe(postEventPipe) != 0) {
 757         mat_JNU_ThrowByName(env, mat_RuntimeException, &quot;Pipe allocation failed&quot;);
 758     }
 759 
 760     // display link timer
 761     NSObject&lt;GlassTimerDelegate&gt;  *delegate = [[GlassTimer alloc] init];
 762     [GlassTimer setDelegate: delegate];
 763 
 764     GLASS_LOG(&quot;leaving Java_com_sun_glass_ui_ios_IosApplication__1initIDs&quot;);
 765 }
 766 
 767 
 768 #if PROTECT_INVOKE_AND_WAIT
 769 static jobject getCurrentThread(JNIEnv *env) {
 770     jobject jobj = (*env)-&gt;CallStaticObjectMethod(env, mat_jThreadClass, mat_ThreadCurrentThread);
 771     if ((*env)-&gt;ExceptionCheck(env)) {
 772         return NULL;
 773     }
 774     return jobj;
 775 }
 776 #endif
 777 
 778 
 779 /*
 780  * Class:     com_sun_glass_ui_ios_IosApplication
 781  * Method:    _runLoop
 782  * Signature: (Ljava/lang/Runnable;)V
 783  */
 784 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosApplication__1runLoop
 785 (JNIEnv *env, jobject japplication, jobject jLaunchable, jobject jContextClassLoader)
 786 {
 787     GLASS_LOG(&quot;Entering Java_com_sun_glass_ui_ios_IosApplication__1runLoop !!!&quot;);
 788     NSAutoreleasePool *glasspool = [[NSAutoreleasePool alloc] init];
 789     {
 790         if ([[NSThread currentThread] isMainThread] == YES)
 791         {
 792             NSLog(@&quot;\nWARNING: Glass was started on 1st thread and will block this thread.\nYou most likely do not want to do this - please remove \&quot;-XstartOnFirstThread\&quot; from VM arguments.&quot;);
 793         }
 794         else
 795         {
 796             GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosApplication__1runLoop - not on main thread 2&quot;);
 797 
 798             if ([[NSThread currentThread] name] == nil)
 799             {
 800                 GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosApplication__1runLoop - setting name &#39;Main Java Thread&#39; to current thread &quot;);
 801 
 802                 [[NSThread currentThread] setName:@&quot;Main Java Thread&quot;];
 803             }
 804         }
 805 
 806         GLASS_LOG(&quot;iOSApplication_runloop before glass init ... &quot;);
 807 
 808         const GlassApplication * const glass = [[GlassApplication alloc]
 809             initWithEnv:env
 810             application:japplication
 811             contextClassLoader:jContextClassLoader
 812             launchable:jLaunchable];
 813         [glass performSelectorOnMainThread:@selector(runLoop:) withObject:glass waitUntilDone:[[NSThread currentThread] isMainThread]];
 814 
 815 
 816         // wait for UIKit to enter its UI runloop
 817         [glass await];
 818 
 819         // at this point Java main thread is allowed to proceed, but UIKit thread entered its run loop, so the VM will not quit
 820     }
 821     [glasspool drain];
 822     glasspool=nil;
 823     GLASS_CHECK_EXCEPTION(env);
 824     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosApplication__1runLoop ... returns&quot;);
 825 }
 826 
 827 
 828 /*
 829  *  * Class:     com_sun_glass_ui_ios_IosApplication
 830  *   * Method:    _enterNestedEventLoopImpl
 831  *    * Signature: ()Ljava/lang/Object;
 832  *     */
 833 JNIEXPORT jobject JNICALL Java_com_sun_glass_ui_ios_IosApplication__1enterNestedEventLoopImpl
 834 (JNIEnv *env, jobject japplication)
 835 {
 836     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosApplication__1enterNestedEventLoopImpl&quot;);
 837 
 838     jobject ret;
 839 
 840     NSAutoreleasePool *glasspool = [[NSAutoreleasePool alloc] init];
 841     {
 842         ret = [GlassApplication enterNestedEventLoopWithEnv:env];
 843     }
 844     [glasspool drain]; glasspool=nil;
 845      GLASS_CHECK_EXCEPTION(env);
 846 
 847     return ret;
 848 }
 849 
 850 /*
 851  *  * Class:     com_sun_glass_ui_ios_IosApplication
 852  *   * Method:    _leaveNestedEventLoopImpl
 853  *    * Signature: (Ljava/lang/Object;)V
 854  *     */
 855 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosApplication__1leaveNestedEventLoopImpl
 856 (JNIEnv *env, jobject japplication, jobject retValue)
 857 {
 858     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosApplication__1leaveNestedEventLoopImpl&quot;);
 859 
 860     NSAutoreleasePool *glasspool = [[NSAutoreleasePool alloc] init];
 861     {
 862         [GlassApplication leaveNestedEventLoopWithEnv:env retValue:retValue];
 863     }
 864     [glasspool drain]; glasspool=nil;
 865      GLASS_CHECK_EXCEPTION(env);
 866 
 867 }
 868 
 869 
 870 
 871 /*
 872  * Class:     com_sun_glass_ui_Application
 873  * Method:    _invokeAndWait
 874  * Signature: (Ljava/lang/Runnable;)V
 875  */
 876 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosApplication__1invokeAndWait
 877 (JNIEnv *env, jobject jApplication, jobject jRunnable)
 878 {
 879     if (jEnv != NULL)
 880     {
 881         GlassRunnable *runnable = [[GlassRunnable alloc] initWithRunnable:(*env)-&gt;NewGlobalRef(env, jRunnable)];
 882         [runnable performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES];
 883         // released in the run method
 884     }
 885 }
 886 
 887 
 888 /*
 889  * Class:     com_sun_glass_ui_Application
 890  * Method:    _invokeLater
 891  * Signature: (Ljava/lang/Runnable;)V
 892  */
 893 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosApplication__1invokeLater
 894 (JNIEnv *env, jobject jApplication, jobject jRunnable)
 895 {
 896     if (jEnv != NULL)
 897     {
 898         GlassRunnable *runnable = [[GlassRunnable alloc] initWithRunnable:(*env)-&gt;NewGlobalRef(env, jRunnable)];
 899         [runnable performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];
 900         // released in the run method
 901     }
 902 }
 903 
 904 
 905 char * mat_RuntimeException = &quot;java/lang/RuntimeException&quot;;
 906 
 907 void
 908 mat_JNU_ThrowByName(JNIEnv *env, const char *name, const char *msg)
 909 {
 910     GLASS_LOG(&quot;Throwing Exception ... %s&quot;,name);
 911     jclass cls = (*env)-&gt;FindClass(env, name);
 912     // if cls is NULL, an exception has already been thrown
 913     if (cls != NULL) {
 914         GLASS_LOG(&quot;Throwing Exception ....... %s(%s)&quot;,name,msg);
 915         (*env)-&gt;ThrowNew(env, cls, msg);
 916     } else {
 917         GLASS_LOG(&quot;EXCEPTION: not found %s(%s)&quot;, name, msg);
 918     }
 919     // free the local ref
 920     (*env)-&gt;DeleteLocalRef(env, cls);
 921 }
 922 
 923 
 924 /*
 925  * Class:     com_sun_glass_ui_ios_IosApplication
 926  * Method:    _setStatusBarHidden
 927  */
 928 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosApplication__1setStatusBarHidden
 929 (JNIEnv *env, jclass clazz, jboolean hidden) {
 930     [UIApplication sharedApplication].statusBarHidden = (hidden == JNI_TRUE);
 931 }
 932 
 933 /*
 934  * Class:     com_sun_glass_ui_ios_IosApplication
 935  * Method:    _setStatusBarHiddenWithAnimation
 936  */
 937 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosApplication__1setStatusBarHiddenWithAnimation
 938 (JNIEnv *env, jclass clazz, jboolean hidden, jint animation) {
 939     [[UIApplication sharedApplication]
 940         setStatusBarHidden:hidden == JNI_TRUE
 941         withAnimation:(UIStatusBarAnimation)animation];
 942 }
 943 
 944 /*
 945  * Class:     com_sun_glass_ui_ios_IosApplication
 946  * Method:    _setStatusBarOrientationAnimated
 947  */
 948 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosApplication__1setStatusBarOrientationAnimated
 949 (JNIEnv *env, jclass clazz, jint interfaceOrientation, jboolean animated) {
 950     [[UIApplication sharedApplication]
 951         setStatusBarOrientation:(UIInterfaceOrientation)interfaceOrientation
 952         animated:animated == JNI_TRUE
 953     ];
 954 }
 955 
 956 /*
 957  * Class:     com_sun_glass_ui_ios_IosApplication
 958  * Method:    _setStatusBarStyleAnimated
 959  */
 960 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosApplication__1setStatusBarStyleAnimated
 961 (JNIEnv *env, jclass clazz, jint statusBarStyle, jboolean animated) {
 962     [[UIApplication sharedApplication]
 963         setStatusBarStyle:(UIStatusBarStyle)statusBarStyle
 964         animated:animated == JNI_TRUE
 965     ];
 966 }
 967 
 968 /*
 969  * Class:     com_sun_glass_ui_ios_IosApplication
 970  * Method:    _getStatusBarHidden
 971  */
 972 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosApplication__1getStatusBarHidden
 973 (JNIEnv *env, jclass clazz) {
 974     return [UIApplication sharedApplication].statusBarHidden == YES ? JNI_TRUE : JNI_FALSE;
 975 }
 976 
 977 /*
 978  * Class:     com_sun_glass_ui_ios_IosApplication
 979  * Method:    _getStatusBarStyle
 980  */
 981 JNIEXPORT jint JNICALL Java_com_sun_glass_ui_ios_IosApplication__1getStatusBarStyle
 982 (JNIEnv *env, jclass clazz) {
 983     return [UIApplication sharedApplication].statusBarStyle;
 984 }
 985 
 986 /*
 987  * Class:     com_sun_glass_ui_ios_IosApplication
 988  * Method:    _getStatusBarStyle
 989  */
 990 JNIEXPORT jint JNICALL Java_com_sun_glass_ui_ios_IosApplication__1getStatusBarOrientation
 991 (JNIEnv *env, jclass clazz) {
 992     return [UIApplication sharedApplication].statusBarOrientation;
 993 }
 994 
 995 /*
 996  * Class:     com_sun_glass_ui_ios_IosApplication
 997  * Method:    staticScreen_getVideoRefreshPeriod
 998  * Signature: ()D
 999  */
1000 JNIEXPORT jdouble JNICALL
1001 Java_com_sun_glass_ui_ios_IosApplication_staticScreen_1getVideoRefreshPeriod
1002 (JNIEnv *env, jobject jApplication)
1003 {
1004     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosApplication_staticScreen_1getVideoRefreshPeriod&quot;);
1005 
1006     double outRefresh = 1.0 / 30.0;     // ability to set frame divider
1007     return (outRefresh * 1000.0);       // to millis
1008 }
1009 
1010 /*
1011  * Class:     com_sun_glass_ui_ios_IosApplication
1012  * Method:    staticScreen_getScreens
1013  * Signature: ([Lcom/sun/glass/ui/Screen;)D
1014  */
1015 JNIEXPORT jobjectArray JNICALL
1016 Java_com_sun_glass_ui_ios_IosApplication_staticScreen_1getScreens
1017 (JNIEnv *env, jobject jApplication)
1018 {
1019     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosApplication_staticScreen_1getScreens&quot;);
1020 
1021     return createJavaScreens(env);
1022 }
1023 
    </pre>
  </body>
</html>
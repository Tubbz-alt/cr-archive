<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/native-glass/ios/GlassWindow.m</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #import &lt;UIKit/UIKit.h&gt;
  27 #import &lt;Foundation/NSNotification.h&gt;
  28 
  29 #include &quot;GlassWindow.h&quot;
  30 
  31 #include &quot;com_sun_glass_events_WindowEvent.h&quot;
  32 #include &quot;com_sun_glass_ui_Window_Level.h&quot;
  33 #include &quot;com_sun_glass_ui_Window.h&quot;
  34 #include &quot;GlassViewGL.h&quot;
  35 #include &quot;GlassApplication.h&quot;
  36 #include &quot;GlassViewController.h&quot;
  37 
  38 static UIView * s_grabWindow = nil;
  39 static GlassWindow   * focusOwner; // currently focused GlassWindow - i.e. key events receiver
  40 
  41 
  42 @implementation GlassMainWindow
  43 
  44 -(id)initWithFrame:(CGRect)frame {
  45     self = [super initWithFrame:frame];
  46 
  47     [[NSNotificationCenter defaultCenter] addObserver:self
  48                                              selector:@selector(keyboardDidShow:)
  49                                                  name:UIKeyboardDidShowNotification
  50                                                object:nil];
  51 
  52     [[NSNotificationCenter defaultCenter] addObserver:self
  53                                              selector:@selector(keyboardDidHide:)
  54                                                  name:UIKeyboardDidHideNotification
  55                                                object:nil];
  56     return self;
  57 }
  58 
  59 // multitouch debugging
  60 - (void) sendEvent:(UIEvent *)event
  61 {
  62     GLASS_LOG(&quot;GlassMainWindow received UIEvent: %@&quot;, event);
  63     [super sendEvent:event];
  64 }
  65 
  66 - (void) keyboardDidShow:(NSNotification *) notification
  67 {
  68 #if MAT_IOS_DEBUG
  69     GLASS_LOG(&quot;[GlassMainWindow keyboardDidShow]&quot;);
  70     NSDictionary *info = [notification userInfo];
  71     CGRect keyboardFrame = [[info objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue];
  72     GLASS_LOG(&quot;Keyboard frame x = %f, y = %f, width = %f, height = %f&quot;, keyboardFrame.origin.x, keyboardFrame.origin.y, keyboardFrame.size.width, keyboardFrame.size.height);
  73 #endif
  74 }
  75 
  76 - (void) keyboardDidHide:(NSNotification *) notification
  77 {
  78     GLASS_LOG(&quot;[GlassMainWindow keyboardidHide]&quot;);
  79     [self resignFocusOwner];
  80 }
  81 
  82 - (void) resignFocusOwner {
  83     [focusOwner resignKeyWindow];
  84 }
  85 
  86 @end
  87 
  88 @implementation GlassMainView
  89 
  90 - (id) initWithFrame:(CGRect)frame
  91 {
  92     self = [super initWithFrame:frame];
  93     if (self != nil) {
  94         [GlassDragDelegate setDragViewParent:self];
  95     }
  96     return self;
  97 }
  98 
  99 - (void) dealloc {
 100     [GlassDragDelegate setDragViewParent:nil];
 101     [GlassDragDelegate cleanup];
 102     [super dealloc];
 103 }
 104 
 105 @end
 106 
 107 //Toplevel containers of all GlassWindows
 108 //once we support multiple screens on iOS - there will be one masterWindow/
 109 //masterWindowHost per screen
 110 static GlassMainWindow * masterWindow = nil;
 111 static GlassMainView * masterWindowHost = nil;
 112 
 113 @interface GlassWindow (JavaAdditions)
 114 - (void)displaySubviews;
 115 - (void)_setLevel;
 116 - (void)orderBack;
 117 - (void)_orderBack;
 118 - (void)orderFrontRegardless;
 119 - (void)_orderFrontRegardless;
 120 
 121 - (void)addChildWindow:(GlassWindow*)child;
 122 - (void)removeChildWindow:(GlassWindow*)child;
 123 
 124 - (void)_setAlpha;
 125 - (void)_setBoundsAndPosition;
 126 - (CGSize)_constrainBounds:(CGRect)cFrame;
 127 - (void)_setMinimumSize;
 128 - (void)_setMaximumSize;
 129 - (void)_setVisible;
 130 
 131 + (void)_resetGrab;
 132 - (void)_grabFocus;
 133 - (void)_ungrabFocus;
 134 - (void)_checkUngrab;
 135 
 136 - (void)_sendJavaWindowMoveEventForFrame:(CGRect)frame;
 137 - (void)_sendJavaWindowResizeEvent:(int)type forFrame:(CGRect)frame;
 138 
 139 - (void)becomeKeyWindow;
 140 - (void)resignKeyWindow;
 141 - (void)windowWillClose;
 142 - (void)sendEvent:(UIEvent *)event;
 143 @end
 144 
 145 
 146 @interface GlassWindow (Java)
 147 - (id)initWithScreen:(UIScreen *)screen jwindow:(jobject)jwindow;
 148 @end
 149 
 150 
 151 
 152 static inline GlassWindow *getGlassWindow(JNIEnv *env, jlong jPtr)
 153 {
 154     if (jPtr != 0L)
 155     {
 156         return (GlassWindow*)jlong_to_ptr(jPtr);
 157     }
 158     else
 159     {
 160         return nil;
 161     }
 162 }
 163 
 164 
 165 static inline UIView&lt;GlassView&gt;* getiOSView(JNIEnv *env, jobject jview)
 166 {
 167     if (jview != NULL)
 168     {
 169         return (UIView&lt;GlassView&gt;*)jlong_to_ptr((*env)-&gt;GetLongField(env, jview, (*env)-&gt;GetFieldID(env, mat_jViewClass, &quot;nativePtr&quot;, &quot;J&quot;)));
 170     }
 171     else
 172     {
 173         return nil;
 174     }
 175 }
 176 
 177 
 178 static inline void setWindowFrame(GlassWindow *window, CGFloat x, CGFloat y, CGFloat w, CGFloat h, jboolean display, jboolean animate)
 179 {
 180     // set help variables
 181     window-&gt;_setFrameX = x;
 182     window-&gt;_setFrameY = y;
 183     window-&gt;_setFrameWidth = w;
 184     window-&gt;_setFrameHeight = h;
 185     window-&gt;_setFrameDisplay = display;
 186     window-&gt;_setFrameAnimated = animate;
 187 
 188     if ([[NSThread currentThread] isMainThread] == YES)
 189     {
 190         [window _setBoundsAndPosition]; // update origin and bounds
 191         if (display == JNI_TRUE) {
 192             GLASS_LOG(&quot;calling displaySubviews&quot;);
 193             [window displaySubviews];
 194             GLASS_LOG(&quot;called displaySubviews&quot;);
 195         }
 196         GLASS_LOG(&quot;GlassWindow frame after setWindowFrame: %f,%f,%f,%f&quot;,[window center].x - [window bounds].size.width / 2,[window center].y - [window bounds].size.height / 2, [window bounds].size.width,[window bounds].size.height);
 197     }
 198     else
 199     {
 200         [window performSelectorOnMainThread:@selector(_setBoundsAndPosition) withObject:nil waitUntilDone:YES];
 201         if (display == JNI_TRUE)
 202             [window performSelectorOnMainThread:@selector(displaySubviews) withObject:nil waitUntilDone:YES];
 203     }
 204 }
 205 
 206 
 207 @implementation GlassWindow
 208 
 209 +(GlassMainWindow *)  getMasterWindow {
 210     return masterWindow;
 211 }
 212 
 213 +(GlassMainView *) getMasterWindowHost {
 214     return masterWindowHost;
 215 }
 216 
 217 - (BOOL) canBecomeFirstResponder {return YES;}
 218 
 219 - (BOOL)hasText {
 220         return YES;
 221 }
 222 
 223 - (void)insertText:(NSString *)theText {
 224     const char * inputString = [theText UTF8String];
 225     for(GlassViewGL * subView in [self-&gt;hostView subviews]) {
 226         if(subView != nil &amp;&amp; [subView isKindOfClass:[GlassViewGL class]] == YES) {
 227             [subView doInsertText:theText];
 228         }
 229     }
 230 }
 231 
 232 - (void)deleteBackward {
 233     for(GlassViewGL * subView in [self-&gt;hostView subviews]) {
 234         if(subView != nil &amp;&amp; [subView isKindOfClass:[GlassViewGL class]] == YES) {
 235             [subView doDeleteBackward];
 236         }
 237     }
 238 }
 239 
 240 JNIEXPORT void JNICALL Java_javafx_scene_control_skin_TextFieldSkinIos_showSoftwareKeyboard
 241 (JNIEnv *env, jobject jTextFieldSkin)
 242 {
 243     [focusOwner becomeFirstResponder];
 244 }
 245 
 246 JNIEXPORT void JNICALL Java_javafx_scene_control_skin_TextFieldSkinIos_hideSoftwareKeyboard
 247 (JNIEnv *env, jobject jTextFieldSkin)
 248 {
 249     [focusOwner resignFirstResponder];
 250 }
 251 
 252 JNIEXPORT void JNICALL Java_javafx_scene_control_skin_TextAreaSkinIos_showSoftwareKeyboard
 253 (JNIEnv *env, jobject jTextAreaSkin)
 254 {
 255     [focusOwner becomeFirstResponder];
 256 }
 257 
 258 JNIEXPORT void JNICALL Java_javafx_scene_control_skin_TextAreaSkinIos_hideSoftwareKeyboard
 259 (JNIEnv *env, jobject jTextAreaSkin)
 260 {
 261     [focusOwner resignFirstResponder];
 262 }
 263 
 264 
 265 // request subviews to repaint
 266 - (void) displaySubviews
 267 {
 268     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 269     for (UIView * subView in [self-&gt;hostView subviews]) {
 270         if (subView != nil) {
 271             [subView setNeedsDisplay];
 272         }
 273     }
 274 }
 275 
 276 #pragma mark ---
 277 
 278 // close window (hide and destroy it)
 279 - (void) close {
 280     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 281     [self _ungrabFocus];
 282     [self setHidden:YES];
 283 
 284     [self windowWillClose];
 285 
 286     [masterWindowHost release];
 287     [masterWindow release];//decrease retaincount
 288 }
 289 
 290 
 291 - (void)setEnabled:(BOOL)enabled
 292 {
 293     GLASS_LOG(&quot;GlassWindow setEnabled&quot;);
 294     self-&gt;isEnabled = enabled;
 295 }
 296 
 297 
 298 #pragma mark --- Java
 299 
 300 - (id)initWithScreen:(UIScreen *)screen jwindow:(jobject)jwindow
 301 {
 302     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 303     CGRect bounds = CGRectMake(0.0f,0.0f,0.0f,0.0f);
 304     self = (GlassWindow *)[super initWithFrame: bounds];
 305     if (self != nil)
 306     {
 307         self-&gt;jWindow = jwindow;
 308         self-&gt;isFocusable = YES; // can become key window
 309 
 310         self-&gt;suppressWindowMoveEvent = NO;
 311         self-&gt;suppressWindowResizeEvent = NO;
 312         self-&gt;isEnabled = YES;
 313 
 314         //default values of min/max frame sizes
 315         self-&gt;minWidth = self-&gt;minHeight = 0.0f;
 316         self-&gt;maxWidth = self-&gt;maxHeight = CGFLOAT_MAX;
 317 
 318         self-&gt;childWindows = [NSMutableArray arrayWithCapacity:(NSUInteger)1];
 319         self-&gt;childWindows = [self-&gt;childWindows retain];
 320 
 321         // default to opaque
 322         [self _setTransparent:NO];
 323 
 324         [self setAutoresizesSubviews:NO];
 325 
 326     }
 327     return self;
 328 }
 329 
<a name="1" id="anc1"></a><span class="line-added"> 330 - (UIKeyboardType) keyboardType</span>
<span class="line-added"> 331 {</span>
<span class="line-added"> 332     return UIKeyboardTypeASCIICapable;</span>
<span class="line-added"> 333 }</span>
 334 
 335 #pragma mark ---
 336 
 337 - (void)_setTransparent:(BOOL)state
 338 {
 339     GLASS_LOG(&quot;GlassWindow _setTransparent called.&quot;);
 340     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 341     // should we store original background color?
 342     // This is only set during window creation so I don&#39;t think it&#39;s necessary
 343     self-&gt;isTransparent = state;
 344     if (self-&gt;isTransparent == YES)
 345     {
 346         [super setBackgroundColor:[UIColor clearColor]];
 347         [super setOpaque:NO];
 348     }
 349     else
 350     {
 351         [super setBackgroundColor:[UIColor blackColor]];
 352         [super setOpaque:YES];
 353     }
 354 }
 355 
 356 
 357 #pragma mark --- JavaAdditions
 358 
 359 - (void)_setAlpha
 360 {
 361     GLASS_LOG(&quot;GlassWindow _setAlpha called.&quot;);
 362     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 363     [self setAlpha:_setAlpha];
 364 }
 365 
 366 
 367 - (void)_setBoundsAndPosition
 368 {
 369     GLASS_LOG(&quot;_GlassWindow _setFrame called&quot;);
 370     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 371     CGRect frameRect = CGRectMake(0.0, 0.0, self-&gt;_setFrameWidth, self-&gt;_setFrameHeight);
 372 
 373     GLASS_LOG(&quot;bounds width, height before constraining %f, %f &quot;, self-&gt;_setFrameWidth, self-&gt;_setFrameHeight);
 374 
 375     CGSize constrainedSize = [self _constrainBounds:frameRect];
 376     //if larger than maxSize | smaller than minSize
 377     if (frameRect.size.width != constrainedSize.width ||
 378         frameRect.size.height != constrainedSize.height) {
 379         self-&gt;_setFrameWidth = constrainedSize.width;
 380         self-&gt;_setFrameHeight = constrainedSize.height;
 381         frameRect.size.width = constrainedSize.width;
 382         frameRect.size.height = constrainedSize.height;
 383     }
 384 
 385     GLASS_LOG(&quot;bounds width, height after constraining %f, %f &quot;, self-&gt;_setFrameWidth, self-&gt;_setFrameHeight);
 386 
 387 
 388     [self setBounds: frameRect];
 389 
 390 
 391     CGPoint newCenter = CGPointMake(self-&gt;_setFrameX + self-&gt;_setFrameWidth / 2, self-&gt;_setFrameY + self-&gt;_setFrameHeight / 2);
 392 
 393     [self setCenter:newCenter];
 394 
 395     GLASS_LOG(&quot;BOUNDS after GlassWindow _setFrame == %f, %f, center == %f %f&quot;,[self bounds].size.width,[self bounds].size.height ,[self center].x, [self center].y);
 396 
 397     GLASS_LOG(&quot;FRAME after GlassWindow _setFrame == %f, %f, %f, %f&quot;,[self frame].size.width,[self frame].size.height ,[self frame].origin.x, [self frame].origin.y);
 398 }
 399 
 400 -(void) setBounds:(CGRect)bounds
 401 {
 402     CGRect frameRect = bounds;
 403     if (self-&gt;owner == nil) { // primary Stage
 404         GLASS_LOG(&quot;primaryStage was asked to resize to %f, %f&quot;,bounds.size.width, bounds.size.height);
 405         frameRect = [[self superview] bounds];
 406         GLASS_LOG(&quot;primaryStage resized to %f, %f&quot;,frameRect.size.width, frameRect.size.height);
 407     }
 408 
 409     [super setBounds:frameRect];
 410 
 411     [self-&gt;hostView setFrame:frameRect];//hostView is always same size as GlassWindow
 412 
 413     for(GlassViewGL * subView in [self-&gt;hostView subviews]) {
 414         if(subView != nil &amp;&amp; [subView isKindOfClass:[GlassViewGL class]] == YES) {
 415             [subView setFrame:frameRect];
 416         }
 417     }
 418 
 419     [self _sendJavaWindowResizeEvent:com_sun_glass_events_WindowEvent_RESIZE forFrame:[self bounds]];
 420 }
 421 
 422 -(void) setCenter:(CGPoint)center
 423 {
 424     CGPoint newCenter = center;
 425 
 426     if (self-&gt;owner == nil) { // primary Stage
 427         GLASS_LOG(&quot;primaryStage was asked to setCenter to %f, %f&quot;,center.x, center.y);
 428         CGRect frameRect = [[self superview] bounds];
 429         newCenter = CGPointMake(frameRect.size.width/2, frameRect.size.height/2);
 430 
 431         GLASS_LOG(&quot;primaryStage setCenter to %f, %f&quot;,newCenter.x, newCenter.y);
 432     }
 433 
 434     [super setCenter:newCenter];
 435 
 436     [self _sendJavaWindowMoveEventForFrame:CGRectMake([self center].x - [self bounds].size.width / 2, [self center].y - [self bounds].size.height / 2, [self bounds].size.width,[self bounds].size.height )];
 437 }
 438 
 439 
 440 - (CGSize)_constrainBounds:(CGRect)frame
 441 {
 442     GLASS_LOG(&quot;GlassWindow _constrainBounds called&quot;);
 443     CGSize size = frame.size;
 444 
 445     CGSize constrained = CGSizeMake(frame.size.width, frame.size.height);
 446     {
 447         if (size.width &lt; self-&gt;minWidth)
 448         {
 449             constrained.width = self-&gt;minWidth;
 450         }
 451         else if (size.width &gt; self-&gt;maxWidth)
 452         {
 453             constrained.width = self-&gt;maxWidth;
 454         }
 455         if (size.height &lt; self-&gt;minHeight)
 456         {
 457             constrained.height = self-&gt;minHeight;
 458         }
 459         else if (size.height &gt; self-&gt;maxHeight)
 460         {
 461             constrained.height = self-&gt;maxHeight;
 462         }
 463     }
 464     return constrained;
 465 }
 466 
 467 
 468 - (void)_setMinimumSize
 469 {
 470     GLASS_LOG(&quot;GlassWindow _setMinimumSize called. (w %f, h %f)&quot;,self-&gt;minWidth, self-&gt;minHeight);
 471     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 472     CGSize currentSize = [self bounds].size;
 473     if (currentSize.width &lt; self-&gt;minWidth || currentSize.height &lt; self-&gt;minHeight) {
 474         [self _setBoundsAndPosition];
 475         [self _sendJavaWindowResizeEvent:com_sun_glass_events_WindowEvent_RESIZE forFrame:[self bounds]];
 476     }
 477 }
 478 
 479 
 480 - (void)_setMaximumSize
 481 {
 482     GLASS_LOG(&quot;GlassWindow _setMaximumSize called. (w %f, h %f)&quot;,self-&gt;maxWidth, self-&gt;maxHeight);
 483     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 484     CGSize currentSize = [self bounds].size;
 485     if (currentSize.width &gt; self-&gt;maxWidth || currentSize.height &gt; self-&gt;maxHeight) {
 486         [self _setBoundsAndPosition];
 487         [self _sendJavaWindowResizeEvent:com_sun_glass_events_WindowEvent_RESIZE forFrame:[self bounds]];
 488     }
 489 }
 490 
 491 
 492 - (void)_setLevel
 493 {
 494     GLASS_LOG(&quot;GlassWindow _setLevel called.&quot;);
 495     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 496     UIWindowLevel level = UIWindowLevelNormal;
 497     switch (self-&gt;_setLevel)
 498     {
 499         case com_sun_glass_ui_Window_Level_FLOATING:
 500             level = UIWindowLevelStatusBar;
 501             break;
 502         case com_sun_glass_ui_Window_Level_TOPMOST:
 503             level = UIWindowLevelAlert;
 504             break;
 505     }
 506     //[self setWindowLevel:level];         // implemenation comes here
 507 }
 508 
 509 
 510 - (void)orderBack
 511 {
 512     GLASS_LOG(&quot;GlassWindow orderBack&quot;);
 513     if ([[NSThread currentThread] isMainThread] == YES) {
 514         [self _orderBack];
 515     } else {
 516         [self performSelectorOnMainThread:@selector(_orderBack) withObject:nil waitUntilDone:YES];
 517     }
 518 }
 519 
 520 
 521 - (void)_orderBack
 522 {
 523     GLASS_LOG(&quot;GlassWindow _orderBack&quot;);
 524     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 525     if ([self superview] != nil) {
 526         [[self superview] sendSubviewToBack:self];
 527     }
 528 }
 529 
 530 
 531 - (void) _orderFrontRegardless
 532 {
 533     GLASS_LOG(&quot;GlassWindow _orderFrontRegardless &quot;);
 534     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 535     if ([self superview] != nil) {
 536         [[self superview] bringSubviewToFront:self];
 537     }
 538 }
 539 
 540 
 541 - (void) orderFrontRegardless
 542 {
 543     if ([[NSThread currentThread] isMainThread] == YES) {
 544         [self _orderFrontRegardless];
 545     } else {
 546         [self performSelectorOnMainThread:@selector(_orderFrontRegardless) withObject:nil waitUntilDone:YES];
 547     }
 548 }
 549 
 550 
 551 - (void)addChildWindow:(GlassWindow*)child
 552 {
 553     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 554     if (child != nil) {
 555         child-&gt;parentWindow = self;
 556         [self-&gt;childWindows addObject:child];
 557 
 558         [child _setBoundsAndPosition];
 559     }
 560 }
 561 
 562 
 563 - (void)removeChildWindow:(GlassWindow*)child
 564 {
 565     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 566     if (child != nil) {
 567         child-&gt;parentWindow = nil;
 568         [self-&gt;childWindows removeObject:child];
 569     }
 570 }
 571 
 572 
 573 + (void)_resetGrab
 574 {
 575     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 576     if (s_grabWindow &amp;&amp; [s_grabWindow isKindOfClass:[GlassWindow class]]) {
 577         GlassWindow * window = (GlassWindow*)s_grabWindow;
 578         [window _ungrabFocus];
 579     }
 580     s_grabWindow = nil; // unconditionally
 581 }
 582 
 583 
 584 - (void)_ungrabFocus
 585 {
 586     if (s_grabWindow != self) {
 587         return;
 588     }
 589 
 590     GET_MAIN_JENV;
 591     (*env)-&gt;CallVoidMethod(env, self-&gt;jWindow, jWindowNotifyFocusUngrab);
 592 
 593     s_grabWindow = nil;
 594 }
 595 
 596 
 597 - (void)_checkUngrab
 598 {
 599     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 600     if (!s_grabWindow) {
 601         return;
 602     }
 603 
 604     // If this window doesn&#39;t belong to an owned windows hierarchy that
 605     // holds the grab currently, then the grab should be released.
 606     for (GlassWindow * window = self; window; window = window-&gt;parentWindow) {
 607         if (window == s_grabWindow) {
 608             return;
 609         }
 610     }
 611 
 612     [GlassWindow _resetGrab];
 613 }
 614 
 615 
 616 - (void)_grabFocus
 617 {
 618     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 619     if (s_grabWindow == self) {
 620         return;
 621     }
 622 
 623     [GlassWindow _resetGrab];
 624     s_grabWindow = self;
 625 }
 626 
 627 
 628 - (void)_setVisible
 629 {
 630     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 631     if (self-&gt;isEnabled == YES)
 632     {
 633         GLASS_LOG(&quot;making GlassWindow Visible %p&quot;,self);
 634         [self setHidden:NO];
 635 
 636         if (self-&gt;isFocusable == YES) {
 637             GLASS_LOG(&quot;making GlassWindow key %p&quot;,self);
 638             [self makeKeyWindow];
 639         }
 640 
 641         [self orderFrontRegardless];
 642     } else {
 643         [self orderFrontRegardless];
 644     }
 645 
 646     if ((self-&gt;owner != nil &amp;&amp; self-&gt;parentWindow == nil))
 647     {
 648         [(GlassWindow *)self-&gt;owner addChildWindow:self];
 649     }
 650 }
 651 
 652 
 653 - (void)_sendJavaWindowMoveEventForFrame:(CGRect)frame
 654 {
 655     if (self-&gt;suppressWindowMoveEvent == NO)
 656     {
 657         GET_MAIN_JENV;
 658         (*env)-&gt;CallVoidMethod(env, jWindow, mat_jWindowNotifyMove, (int)frame.origin.x,  (int)frame.origin.y);
 659     }
 660 }
 661 
 662 
 663 - (void)_sendJavaWindowResizeEvent:(int)type forFrame:(CGRect)frame
 664 {
 665     if (self-&gt;suppressWindowResizeEvent == NO)
 666     {
 667         GET_MAIN_JENV;
 668         (*env)-&gt;CallVoidMethod(env, jWindow, mat_jWindowNotifyResize, type, (int)frame.size.width, (int)frame.size.height);
 669     }
 670 }
 671 
 672 
 673 #pragma mark --- UIView
 674 
 675 - (void) setBackgroundColor:(UIColor *)color
 676 {
 677     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 678     if (self-&gt;isTransparent == NO)
 679     {
 680         // allow color if we&#39;re opaque
 681         [super setBackgroundColor:color];
 682     }
 683     else
 684     {
 685         // for transparent window, ignore and set to clear color
 686         // do we want to store the background color in case we switch to non-transparent mode?
 687         [super setBackgroundColor:[UIColor clearColor]];
 688     }
 689 }
 690 
 691 - (void) makeKeyWindow
 692 {
 693     if (self-&gt;isEnabled &amp;&amp; self-&gt;isFocusable &amp;&amp; focusOwner != self) {
 694 
 695         [focusOwner resignKeyWindow];
 696 
 697         [self becomeKeyWindow];
 698     }
 699 }
 700 
 701 - (BOOL) isKeyWindow
 702 {
 703     return self == focusOwner;
 704 }
 705 
 706 - (void)becomeKeyWindow
 707 {
 708     GLASS_LOG(&quot;Window did become key&quot;);
 709     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 710 
 711 
 712     GET_MAIN_JENV;
 713     if (!self-&gt;isEnabled)
 714     {
 715         (*env)-&gt;CallVoidMethod(env, self-&gt;jWindow, mat_jWindowNotifyFocusDisabled);
 716         return;
 717     }
 718 
 719     focusOwner = self;
 720 
 721     (*env)-&gt;CallVoidMethod(env, self-&gt;jWindow, mat_jWindowNotifyFocus, com_sun_glass_events_WindowEvent_FOCUS_GAINED);
 722 }
 723 
 724 
 725 - (void)resignKeyWindow
 726 {
 727     GLASS_LOG(&quot;Window did resign key&quot;);
 728     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 729 
 730     if (focusOwner == self) {
 731         focusOwner = nil;
 732     }
 733 
 734     [self _ungrabFocus];
 735 
 736     GET_MAIN_JENV;
 737     (*env)-&gt;CallVoidMethod(env, self-&gt;jWindow, mat_jWindowNotifyFocus, com_sun_glass_events_WindowEvent_FOCUS_LOST);
 738 }
 739 
 740 
 741 - (void)windowWillClose
 742 {
 743     GLASS_LOG(&quot;GlassWindow windowWillClose&quot;);
 744     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 745     // Unparent self
 746     if (self-&gt;parentWindow != nil)
 747     {
 748         [self-&gt;parentWindow removeChildWindow:self];
 749     }
 750 
 751     // Call the notification method
 752     GET_MAIN_JENV;
 753     (*env)-&gt;CallVoidMethod(env, self-&gt;jWindow, mat_jWindowNotifyDestroy);
 754 
 755     if (childWindows != NULL) {
 756 
 757         // Finally, close owned windows to mimic MS Windows behavior
 758         for (GlassWindow * child in self-&gt;childWindows)
 759         {
 760             [child close];
 761         }
 762 
 763         [childWindows release];
 764     }
 765 
 766     [self-&gt;hostView removeFromSuperview];
 767     [self-&gt;hostView release];
 768 
 769     if ([self superview] != nil) {
 770         [self removeFromSuperview];
 771     }
 772 
 773     if (focusOwner == self) {
 774         focusOwner = nil;
 775     }
 776 
 777     (*jEnv)-&gt;DeleteGlobalRef(jEnv, self-&gt;jWindow);
 778     GLASS_CHECK_EXCEPTION(jEnv);
 779 
 780     self-&gt;jWindow = NULL;
 781 }
 782 
 783 
 784 - (void) requestInput:(NSString *)text type:(int)type width:(double)width height:(double)height
 785                   mxx:(double)mxx mxy:(double)mxy mxz:(double)mxz mxt:(double)mxt
 786                   myx:(double)myx myy:(double)myy myz:(double)myz myt:(double)myt
 787                   mzx:(double)mzx mzy:(double)mzy mzz:(double)mzz mzt:(double)mzt
 788 
 789 {
 790     [view requestInput:text type:type width:width height:height
 791                    mxx:mxx mxy:mxy mxz:mxz mxt:mxt
 792                    myx:myx myy:myy myz:myz myt:myt
 793                    mzx:mzx mzy:mzy mzz:mzz mzt:mzt];
 794 }
 795 
 796 
 797 - (void) releaseInput
 798 {
 799     [view releaseInput];
 800 }
 801 
 802 @end
 803 
 804 
 805 
 806 jlong _1createWindow(JNIEnv *env, jobject jWindow, jlong jOwnerPtr, jlong jScreenPtr, jint jStyleMask)
 807 {
 808     [[NSThread currentThread] isMainThread];
 809     if ([[NSThread currentThread] isMainThread] == NO) NSLog(@&quot;[1] must be on main thread&quot;);
 810     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 811 
 812     GlassWindow *window;
 813 
 814     {
 815         UIScreen *screen = (UIScreen*)jlong_to_ptr(jScreenPtr);
 816         BOOL hidden = YES;
 817         if (jOwnerPtr == 0L) {
 818             // no owner means it is the primary stage; Decorated primary stage shows status bar by default
 819             hidden = ((jStyleMask &amp; com_sun_glass_ui_Window_TITLED) == 0);
 820 
 821             NSObject * values = [[NSBundle mainBundle] objectForInfoDictionaryKey:@&quot;UIStatusBarHidden&quot;];
 822             //we prefer explicit settings from .plist
 823             if (values != nil) {
 824                 hidden = (values == @(YES))?YES:NO;
 825             }
 826 
 827             [UIApplication sharedApplication].statusBarHidden = hidden;
 828         }
 829 
 830 
 831         if (masterWindow == nil) {
 832             //We have to remove rootViewController of splashscreen UIWindow in order to avoid
 833             //StatusBar orientation change ...
 834             UIWindow *splashScreen = [[UIApplication sharedApplication] keyWindow];
 835             splashScreen.rootViewController = nil;
 836 
 837             GLASS_LOG(&quot;SCREEN: %@&quot;, screen);
 838             CGRect applicationFrame = [screen bounds];
 839             GLASS_LOG(&quot;FRAME: %@&quot;, applicationFrame);
 840 
 841             masterWindow = [[GlassMainWindow alloc] initWithFrame:applicationFrame];
 842             masterWindowHost = [[GlassMainView alloc] initWithFrame:CGRectMake(0.0, 0.0, applicationFrame.size.width, applicationFrame.size.height)];
 843 
 844             // Set GlassViewController - responsible for orientation change, etc.
 845             GlassViewController *rvc = [[GlassViewController alloc] init];
 846             [rvc setView:masterWindowHost];
 847             [masterWindow setRootViewController:rvc];
 848             [rvc release];
 849 
 850             [masterWindow setHidden:NO];
 851             [masterWindowHost setHidden:NO];
 852         } else {
 853             masterWindow = [masterWindow retain];//increase retain count per each GlassWindow
 854             masterWindowHost = [masterWindowHost retain];
 855         }
 856 
 857         [masterWindow setAutoresizesSubviews:YES];
 858         [masterWindowHost setAutoresizesSubviews:NO];
 859 
 860         [masterWindow makeKeyWindow];
 861 
 862         GLASS_LOG(&quot;GlassWindow _1createWindow&quot;);
 863         window = [[GlassWindow alloc] initWithScreen:screen jwindow:jWindow];
 864 
 865         window-&gt;isResizable = NO;
 866 
 867         window-&gt;hostView = [[UIView alloc] init];
 868         [window-&gt;hostView setAutoresizesSubviews:NO];
 869 
 870         [window addSubview:window-&gt;hostView];
 871 
 872         window.backgroundColor = [UIColor whiteColor];
 873 
 874         if ((jStyleMask &amp; com_sun_glass_ui_Window_TRANSPARENT) != 0)
 875         {
 876             [window _setTransparent:YES];
 877         }
 878         else
 879         {
 880             [window _setTransparent:NO];
 881         }
 882 
 883         [masterWindowHost addSubview:window];
 884 
 885         if (jOwnerPtr != 0L)
 886         {
 887             GLASS_LOG(&quot;Adding %p window as usbview of owner window %lld&quot;, window, jOwnerPtr);
 888             window-&gt;owner = (UIWindow*)jlong_to_ptr(jOwnerPtr);
 889         } else {
 890             NSArray *views = [masterWindowHost subviews];
 891             // if there exists any secondary stage, its owner is primary stage internally if
 892             // not set explicitly
 893             if ([views count] &gt; 1) {
 894                 window-&gt;owner = [views objectAtIndex:0];
 895             }
 896         }
 897     }
 898     [pool drain];
 899 
 900     GLASS_CHECK_EXCEPTION(env);
 901 
 902     return ptr_to_jlong(window);
 903 }
 904 
 905 
 906 
 907 @interface GlassWindowDispatcher : NSObject
 908 {
 909 @public
 910     jobject     jWindow;
 911     jlong       jOwnerPtr;
 912     jlong       jScreenPtr;
 913     jint        jStyleMask;
 914     jlong       jlongReturn;
 915 }
 916 @end
 917 
 918 
 919 
 920 @implementation GlassWindowDispatcher
 921 
 922 - (void) _createWindow
 923 {
 924     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot;);
 925     GET_MAIN_JENV;
 926     self-&gt;jlongReturn = _1createWindow(env, self-&gt;jWindow, self-&gt;jOwnerPtr, self-&gt;jScreenPtr, self-&gt;jStyleMask);
 927 }
 928 
 929 @end
 930 
 931 
 932 
 933 /*
 934  * Class:     com_sun_glass_ui_ios_IosWindow
 935  * Method:    _createWindow
 936  * Signature: (JJZI)J
 937  */
 938 JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_ios_IosWindow__1createWindow
 939 (JNIEnv *env, jobject jwindow, jlong jownerPtr, jlong jscreenPtr, jint jstyleMask)
 940 {
 941     jlong value;
 942 
 943     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
 944     GLASS_POOL_ENTER;
 945     {
 946         GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1createWindow&quot;);
 947         jobject jWindowRef = (*env)-&gt;NewGlobalRef(env, jwindow);
 948         if ([[NSThread currentThread] isMainThread] == YES)
 949         {
 950             value = _1createWindow(env, jWindowRef, jownerPtr, jscreenPtr, jstyleMask);
 951             GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1createWindow  from NSMainThread called&quot;);
 952 
 953         }
 954         else
 955         {
 956             GlassWindowDispatcher *dispatcher = [[GlassWindowDispatcher alloc] autorelease];
 957             dispatcher-&gt;jWindow = jWindowRef;
 958             dispatcher-&gt;jOwnerPtr = jownerPtr;
 959             dispatcher-&gt;jScreenPtr = jscreenPtr;
 960             dispatcher-&gt;jStyleMask = jstyleMask;
 961             [dispatcher performSelectorOnMainThread:@selector(_createWindow) withObject:dispatcher waitUntilDone:YES];
 962             value = dispatcher-&gt;jlongReturn;
 963         }
 964     }
 965     GLASS_POOL_EXIT;
 966     GLASS_CHECK_EXCEPTION(env);
 967 
 968     return value;
 969 }
 970 
 971 
 972 /*
 973  * Class:     com_sun_glass_ui_ios_IosWindow
 974  * Method:    _createChildWindow
 975  * Signature: (J)J
 976  */
 977 JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_ios_IosWindow__1createChildWindow
 978 (JNIEnv *env, jobject jwindow, jlong parent) {
 979     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1createChildWindow&quot;);
 980     // implementation comes here
 981     return 0L;
 982 }
 983 
 984 
 985 /*
 986  * Class:     com_sun_glass_ui_ios_IosWindow
 987  * Method:    _close
 988  * Signature: (J)Z
 989  */
 990 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1close
 991 (JNIEnv *env, jclass jwindow, jlong ptr) {
 992     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1close&quot;);
 993     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
 994     GLASS_POOL_ENTER;
 995     {
 996         GlassWindow *window = (GlassWindow*)jlong_to_ptr(ptr);
 997         if ([[NSThread currentThread] isMainThread] == YES)
 998         {
 999             // this call will always close the window
1000             // without calling the windowShouldClose
1001             [window close];
1002             [window release];
1003         }
1004         else
1005         {
1006             // this call will always close the window
1007             // without calling the windowShouldClose
1008             [window performSelectorOnMainThread:@selector(close) withObject:nil waitUntilDone:YES];
1009             [window performSelectorOnMainThread:@selector(release) withObject:nil waitUntilDone:YES];
1010         }
1011         // The window is released here since we retain it - different from Mac OS X
1012     }
1013     GLASS_POOL_EXIT;
1014     GLASS_CHECK_EXCEPTION(env);
1015 
1016     return JNI_TRUE;
1017 }
1018 
1019 
1020 /*
1021  * Class:     com_sun_glass_ui_ios_IosWindow
1022  * Method:    _setView
1023  * Signature: (JLcom/sun/glass/ui/View;)Z
1024  */
1025 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setView
1026 (JNIEnv *env, jobject jwindow, jlong windowPtr, jobject jview) {
1027 
1028     if ([[NSThread currentThread] isMainThread] == NO) NSLog(@&quot;[2] must be on main thread&quot;);
1029 
1030     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1031     GLASS_POOL_ENTER;
1032     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setView&quot;);
1033     {
1034         GlassWindow *window = getGlassWindow(env, windowPtr);
1035 
1036         window-&gt;view = getiOSView(env, jview);
1037 
1038 
1039         GLASS_LOG(&quot;window: %@&quot;, window);
1040         GLASS_LOG(&quot;frame: %.2f,%.2f %.2fx%.2f&quot;, [window frame].origin.x, [window frame].origin.y, [window frame].size.width, [window frame].size.height);
1041         GLASS_LOG(&quot;view: %@&quot;, window-&gt;view);
1042         GLASS_LOG(&quot;frame: %.2f,%.2f %.2fx%.2f&quot;, [window-&gt;view frame].origin.x, [window-&gt;view frame].origin.y, [window-&gt;view frame].size.width, [window-&gt;view frame].size.height);
1043 
1044         if (window-&gt;view != nil)
1045         {
1046             window-&gt;suppressWindowMoveEvent = YES; // RT-11215
1047             {
1048                 CGRect viewFrame = [window-&gt;view bounds];
1049                 if ((viewFrame.size.width != 0.0f) &amp;&amp; (viewFrame.size.height != 0.0f))
1050                 {
1051                     CGRect windowFrame = CGRectMake(0.0, 0.0, viewFrame.size.width, viewFrame.size.height);
1052                     windowFrame.origin.x = [window center].x - viewFrame.size.width / 2 ;
1053                     windowFrame.origin.y = [window center].y - viewFrame.size.height / 2;
1054                     setWindowFrame(window, windowFrame.origin.x, windowFrame.origin.y, windowFrame.size.width, windowFrame.size.height, JNI_TRUE, JNI_FALSE);
1055                 }
1056 
1057                 if ([[NSThread currentThread] isMainThread] == YES)
1058                 {
1059                     [window-&gt;hostView addSubview: window-&gt;view];
1060                 }
1061                 else
1062                 {
1063                     [window-&gt;hostView performSelectorOnMainThread:@selector(addSubview:) withObject:window-&gt;view waitUntilDone:YES];
1064                 }
1065             }
1066             window-&gt;suppressWindowMoveEvent = NO;
1067         }
1068     }
1069     GLASS_POOL_EXIT;
1070     GLASS_CHECK_EXCEPTION(env);
1071 
1072     return JNI_TRUE;
1073 }
1074 
1075 
1076 /*
1077  * Class:     com_sun_glass_ui_ios_IosWindow
1078  * Method:    _setMenubar
1079  * Signature: (JJ)Z
1080  */
1081 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setMenubar
1082 (JNIEnv *env, jobject jwindow, jlong windowPtr, jlong menubarPtr) {
1083 
1084     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1085     GLASS_POOL_ENTER;
1086     {
1087         GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setMenubar - setMenuBar called.&quot;);
1088         // implementation comes here
1089     }
1090     GLASS_POOL_EXIT;
1091     GLASS_CHECK_EXCEPTION(env);
1092 
1093     return JNI_TRUE;
1094 }
1095 
1096 
1097 /*
1098  * Class:     com_sun_glass_ui_ios_IosWindow
1099  * Method:    _minimize
1100  * Signature: (JZ)Z
1101  */
1102 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1minimize
1103 (JNIEnv *env, jobject jwindow, jlong windowPtr, jboolean minimize) {
1104     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1minimize called.&quot;);
1105 
1106     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1107     GLASS_POOL_ENTER;
1108     {
1109         // implementation comes here
1110     }
1111     GLASS_POOL_EXIT;
1112     GLASS_CHECK_EXCEPTION(env);
1113 
1114     return JNI_TRUE;
1115 }
1116 
1117 
1118 /*
1119  * Class:     com_sun_glass_ui_ios_IosWindow
1120  * Method:    _maximize
1121  * Signature: (JZZ)Z
1122  */
1123 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1maximize
1124 (JNIEnv *env, jobject jwindow, jlong windowPtr, jboolean maximize, jboolean wasMaximized) {
1125     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1maximize called.&quot;);
1126     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1127     GLASS_POOL_ENTER;
1128     {
1129         // implementation comes here
1130     }
1131     GLASS_POOL_EXIT;
1132     GLASS_CHECK_EXCEPTION(env);
1133 
1134     return JNI_TRUE;
1135 }
1136 
1137 
1138 /*
1139  * Class:     com_sun_glass_ui_ios_IosWindow
1140  * Method:    _setBoundsAndPosition
1141  * Signature: (JIIZZIIIIFF)V
1142  */
1143 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setBounds
1144 (JNIEnv *env, jobject jWindow, jlong jPtr,
1145  jint x, jint y, jboolean xSet, jboolean ySet,
1146  jint w, jint h, jint cw, jint ch, jfloat xGravity, jfloat yGravity)
1147 {
1148     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setBounds&quot;);
1149     if ([[NSThread currentThread] isMainThread] == NO) NSLog(@&quot;[3] must be on main thread&quot;);
1150 
1151     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1152     GLASS_POOL_ENTER;
1153     {
1154         GLASS_LOG(&quot;Called setBounds with x %ld,y %ld,xSet %d,ySet %d,w %ld,h %ld,cw %ld,ch %ld&quot;,x,y,xSet,ySet,w,h,cw,ch);
1155 
1156         GlassWindow *window = (GlassWindow *)jlong_to_ptr(jPtr);
1157 
1158         CGPoint origin = CGPointMake([window center].x - [window bounds].size.width / 2, [window center].y - [window bounds].size.height / 2);
1159         GLASS_LOG(&quot;window original position x,y %f, %f&quot;,origin.x,origin.y);
1160 
1161         CGSize size = [window bounds].size;
1162         GLASS_LOG(&quot;window size w,h %f,%f&quot;,size.width,size.height);
1163 
1164         CGSize sizeForClient = CGRectMake(0, 0, cw &gt; 0 ? cw : 0, ch &gt; 0 ? ch : 0).size;
1165         GLASS_LOG(&quot;sizeForClient %f, %f&quot;, sizeForClient.width, sizeForClient.height);
1166 
1167         CGFloat newX = xSet == JNI_TRUE ? x : origin.x;
1168         CGFloat newY = ySet == JNI_TRUE ? y : origin.y;
1169         CGFloat newW = (w &gt; 0) ? w :
1170         (cw &gt; 0) ? sizeForClient.width : size.width;
1171         CGFloat newH = (h &gt; 0) ? h :
1172         (ch &gt; 0) ? sizeForClient.height : size.height;
1173         GLASS_LOG(&quot;FRAME: x,y,w,h - %f, %f, %f %f&quot;,newX, newY, newW, newH);
1174 
1175         setWindowFrame(window, newX, newY, newW, newH, JNI_TRUE, JNI_FALSE);
1176 
1177         //Let&#39;s notify JavaFX about move,size change (as we don&#39;t have window&#39;s size,position) Notifications on iOS
1178         if(xSet == JNI_TRUE || ySet == JNI_TRUE) {
1179             [window _sendJavaWindowMoveEventForFrame:CGRectMake([window center].x - [window bounds].size.width / 2, [window center].y - [window bounds].size.height / 2, [window bounds].size.width,[window bounds].size.height )];
1180         } else {
1181             [window _sendJavaWindowResizeEvent:com_sun_glass_events_WindowEvent_RESIZE forFrame:[window bounds]];
1182         }
1183     }
1184     GLASS_POOL_EXIT;
1185     GLASS_CHECK_EXCEPTION(env);
1186 }
1187 
1188 
1189 /*
1190  * Class:     com_sun_glass_ui_ios_IosWindow
1191  * Method:    _setVisible
1192  * Signature: (JZ)Z
1193  */
1194 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setVisible
1195 (JNIEnv *env, jobject jwindow, jlong windowPtr, jboolean visible) {
1196     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setVisible called.&quot;);
1197     jboolean now;
1198 
1199     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1200     GLASS_POOL_ENTER;
1201     {
1202         GlassWindow *window = getGlassWindow(env, windowPtr);
1203         if (visible == JNI_TRUE)
1204         {
1205             if ([[NSThread currentThread] isMainThread] == YES)
1206             {
1207                 [window _setVisible];
1208             }
1209             else
1210             {
1211                 [window performSelectorOnMainThread:@selector(_setVisible) withObject:nil waitUntilDone:YES];
1212             }
1213         }
1214         else
1215         {
1216             if ([[NSThread currentThread] isMainThread] == YES)
1217             {
1218                 [window _ungrabFocus];
1219                 if (window-&gt;owner != nil)
1220                 {
1221                     [(GlassWindow *)window-&gt;owner removeChildWindow: window];
1222                 }
1223                 //[window orderOut:window];
1224             }
1225             else
1226             {
1227                 [window performSelectorOnMainThread:@selector(_ungrabFocus) withObject:nil waitUntilDone:YES];
1228                 if (window-&gt;owner != nil)
1229                 {
1230                     [(GlassWindow *)(window-&gt;owner) performSelectorOnMainThread:@selector(removeChildWindow:) withObject:window waitUntilDone:YES];
1231                 }
1232                 //[window performSelectorOnMainThread:@selector(orderOut:) withObject:window waitUntilDone:YES];
1233             }
1234         }
1235         if ([[NSThread currentThread] isMainThread] == NO) NSLog(@&quot;[4] must be on main thread&quot;);
1236         now = ([window isHidden] == NO) ? JNI_TRUE : JNI_FALSE;
1237     }
1238     GLASS_POOL_EXIT;
1239     GLASS_CHECK_EXCEPTION(env);
1240 
1241     return now;
1242 }
1243 
1244 
1245 /*
1246  * Class:     com_sun_glass_ui_ios_IosWindow
1247  * Method:    _requestFocus
1248  * Signature: (J)Z
1249  */
1250 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1requestFocus
1251 (JNIEnv *env, jobject jwindow, jlong windowPtr) {
1252     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1requestFocus  called.&quot;);
1253     jboolean focused;
1254 
1255     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1256     GLASS_POOL_ENTER;
1257     {
1258         GlassWindow *window = getGlassWindow(env, windowPtr);
1259         if (window-&gt;isFocusable == YES) {
1260             if ([[NSThread currentThread] isMainThread] == YES)
1261             {
1262                 [window makeKeyWindow];//for iOS
1263                 [window orderFrontRegardless];
1264             }
1265             else
1266             {
1267                 [window performSelectorOnMainThread:@selector(makeKeyWindow) withObject:nil waitUntilDone:YES];
1268                 [window performSelectorOnMainThread:@selector(orderFrontRegardless) withObject:window waitUntilDone:YES];
1269             }
1270         }
1271         if ([[NSThread currentThread] isMainThread] == NO) NSLog(@&quot;[5] must be on main thread&quot;);
1272         focused = [window isKeyWindow] ? JNI_TRUE : JNI_FALSE;
1273     }
1274     GLASS_POOL_EXIT;
1275     GLASS_CHECK_EXCEPTION(env);
1276 
1277     return focused;
1278 }
1279 
1280 
1281 /*
1282  * Class:     com_sun_glass_ui_ios_IosWindow
1283  * Method:    _grabFocus
1284  * Signature: (J)Z
1285  */
1286 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1grabFocus
1287 (JNIEnv *env, jobject jwindow, jlong windowPtr) {
1288     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1grabFocus&quot;);
1289     jboolean ret;
1290 
1291     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1292     GLASS_POOL_ENTER;
1293     {
1294         GlassWindow * window = getGlassWindow(env, windowPtr);
1295         if ([[NSThread currentThread] isMainThread] == YES)
1296         {
1297             [window _grabFocus];
1298         }
1299         else
1300         {
1301             [window performSelectorOnMainThread:@selector(_grabFocus) withObject:nil waitUntilDone:YES];
1302         }
1303         ret = JNI_TRUE;
1304     }
1305     GLASS_POOL_EXIT;
1306     GLASS_CHECK_EXCEPTION(env);
1307 
1308     return ret;
1309 }
1310 
1311 
1312 /*
1313  * Class:     com_sun_glass_ui_ios_IosWindow
1314  * Method:    _ungrabFocus
1315  * Signature: (J)
1316  */
1317 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1ungrabFocus
1318 (JNIEnv *env, jobject jwindow, jlong windowPtr) {
1319     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1ungrabFocus&quot;);
1320 
1321     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1322     GLASS_POOL_ENTER;
1323     {
1324         GlassWindow * window = getGlassWindow(env, windowPtr);
1325 
1326         if ([[NSThread currentThread] isMainThread] == YES)
1327         {
1328             [window _ungrabFocus];
1329         } else {
1330             [window performSelectorOnMainThread:@selector(_ungrabFocus) withObject:nil waitUntilDone:YES];
1331         }
1332     }
1333     GLASS_POOL_EXIT;
1334     GLASS_CHECK_EXCEPTION(env);
1335 }
1336 
1337 
1338 /*
1339  * Class:     com_sun_glass_ui_ios_IosWindow
1340  * Method:    _setTitle
1341  * Signature: (JLjava/lang/String;)Z
1342  */
1343 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setTitle
1344 (JNIEnv *env, jobject jwindow, jlong windowPtr, jstring title) {
1345     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setTitle called.&quot;);
1346     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1347     GLASS_POOL_ENTER;
1348     {
1349         // implementation comes here when feature is requested on iOS
1350     }
1351     GLASS_POOL_EXIT;
1352     GLASS_CHECK_EXCEPTION(env);
1353 
1354     return JNI_TRUE;
1355 }
1356 
1357 
1358 /*
1359  * Class:     com_sun_glass_ui_ios_IosWindow
1360  * Method:    _setLevel
1361  * Signature: (JI)V
1362  */
1363 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setLevel
1364 (JNIEnv *env, jobject jwindow, jlong windowPtr, jint level) {
1365     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setLevel called.&quot;);
1366     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1367     GLASS_POOL_ENTER;
1368     {
1369         GlassWindow *window = getGlassWindow(env, windowPtr);
1370         window-&gt;_setLevel = level;
1371 
1372         if ([[NSThread currentThread] isMainThread] == YES)
1373         {
1374             [window _setLevel];
1375         }
1376         else
1377         {
1378             [window performSelectorOnMainThread:@selector(setLevel) withObject:nil waitUntilDone:YES];
1379         }
1380     }
1381     GLASS_POOL_EXIT;
1382     GLASS_CHECK_EXCEPTION(env);
1383 }
1384 
1385 
1386 /*
1387  * Class:     com_sun_glass_ui_ios_IosWindow
1388  * Method:    _setResizable
1389  * Signature: (JZ)Z
1390  */
1391 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setResizable
1392 (JNIEnv *env, jobject jwindow, jlong windowPtr, jboolean resizeable) {
1393     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1394     GLASS_POOL_ENTER;
1395     {
1396         GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setResizable called.&quot;);
1397         GlassWindow *window = getGlassWindow(env, windowPtr);
1398         if (window-&gt;isResizable != resizeable)
1399         {
1400             window-&gt;isResizable = resizeable;
1401         }
1402     }
1403     GLASS_POOL_EXIT;
1404     GLASS_CHECK_EXCEPTION(env);
1405 
1406     return JNI_TRUE;
1407 }
1408 
1409 
1410 /*
1411  * Class:     com_sun_glass_ui_ios_IosWindow
1412  * Method:    _setFocusable
1413  * Signature: (JZ)V
1414  */
1415 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setFocusable
1416 (JNIEnv *env, jobject jwindow, jlong windowPtr, jboolean isFocusable) {
1417     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setFocusable called.&quot;);
1418     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1419     GLASS_POOL_ENTER;
1420     {
1421         GlassWindow *window = getGlassWindow(env, windowPtr);
1422         window-&gt;isFocusable = isFocusable;
1423     }
1424     GLASS_POOL_EXIT;
1425     GLASS_CHECK_EXCEPTION(env);
1426 }
1427 
1428 
1429 /*
1430  * Class:     com_sun_glass_ui_ios_IosWindow
1431  * Method:    _setAlpha
1432  * Signature: (JF)V
1433  */
1434 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setAlpha
1435 (JNIEnv *env, jobject jwindow, jlong windowPtr, jfloat alpha) {
1436     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setAlpha(%f)&quot;,alpha);
1437     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1438     GLASS_POOL_ENTER;
1439     {
1440         GlassWindow *window = getGlassWindow(env, windowPtr);
1441         window-&gt;_setAlpha = alpha;
1442 
1443         if ([[NSThread currentThread] isMainThread] == YES)
1444         {
1445             [window _setAlpha];
1446         }
1447         else
1448         {
1449             [window performSelectorOnMainThread:@selector(_setAlpha) withObject:nil waitUntilDone:YES];
1450         }
1451     }
1452     GLASS_POOL_EXIT;
1453     GLASS_CHECK_EXCEPTION(env);
1454 }
1455 
1456 
1457 /*
1458  * Class:     com_sun_glass_ui_ios_IosWindow
1459  * Method:    _setBackground
1460  * Signature: (JFFF)Z
1461  */
1462 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setBackground
1463 (JNIEnv *env, jobject jwindow, jlong windowPtr, jfloat r, jfloat g, jfloat b) {
1464     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setBackground&quot;);
1465     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1466     GLASS_POOL_ENTER;
1467     {
1468         GlassWindow *window = getGlassWindow(env, windowPtr);
1469         if ([[NSThread currentThread] isMainThread] == YES)
1470         {
1471             [window setBackgroundColor:[UIColor colorWithRed:r green:g blue:b alpha:1.0f]];
1472         }
1473         else
1474         {
1475             [window performSelectorOnMainThread:@selector(setBackgroundColor:) withObject:[UIColor colorWithRed:r green:g blue:b alpha:1.0f] waitUntilDone:YES];
1476         }
1477     }
1478     GLASS_POOL_EXIT;
1479     GLASS_CHECK_EXCEPTION(env);
1480 
1481     return JNI_TRUE;
1482 }
1483 
1484 
1485 /*
1486  * Class:     com_sun_glass_ui_ios_IosWindow
1487  * Method:    _setMinimumSize
1488  * Signature: (JII)Z
1489  */
1490 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setMinimumSize
1491 (JNIEnv *env, jobject jwindow, jlong windowPtr, jint width, jint height) {
1492     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setMinimumSize called.&quot;);
1493     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1494     GLASS_POOL_ENTER;
1495     {
1496         GlassWindow *window = getGlassWindow(env, windowPtr);
1497         window-&gt;minWidth = (jfloat) width;
1498         window-&gt;minHeight = (jfloat) height;
1499 
1500         if ([[NSThread currentThread] isMainThread] == YES)
1501         {
1502             [window _setMinimumSize];
1503         }
1504         else
1505         {
1506             [window performSelectorOnMainThread:@selector(_setMinimumSize) withObject:nil waitUntilDone:YES];
1507         }
1508     }
1509     GLASS_POOL_EXIT;
1510     GLASS_CHECK_EXCEPTION(env);
1511 
1512     return JNI_TRUE;
1513 }
1514 
1515 
1516 /*
1517  * Class:     com_sun_glass_ui_ios_IosWindow
1518  * Method:    _setMaximumSize
1519  * Signature: (JII)Z
1520  */
1521 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setMaximumSize
1522 (JNIEnv *env, jobject jwindow, jlong windowPtr, jint width, jint height) {
1523     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setMaximumSize called.&quot;);
1524     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1525     GLASS_POOL_ENTER;
1526     {
1527         GlassWindow *window = getGlassWindow(env, windowPtr);
1528         window-&gt;maxWidth = (jfloat)(width &gt;= 0 ? width : CGFLOAT_MAX);
1529         window-&gt;maxHeight = (jfloat)(height &gt;= 0 ? height : CGFLOAT_MAX);
1530 
1531         if ([[NSThread currentThread] isMainThread] == YES)
1532         {
1533             [window _setMaximumSize];
1534         }
1535         else
1536         {
1537             [window performSelectorOnMainThread:@selector(_setMaximumSize) withObject:nil waitUntilDone:YES];
1538         }
1539     }
1540     GLASS_POOL_EXIT;
1541     GLASS_CHECK_EXCEPTION(env);
1542 
1543     return JNI_TRUE;
1544 }
1545 
1546 
1547 /*
1548  * Class:     com_sun_glass_ui_ios_IosWindow
1549  * Method:    _setIcon
1550  * Signature: (JIILjava/nio/ByteBuffer;)V
1551  */
1552 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setIcon
1553 (JNIEnv *env, jobject jwindow, jlong windowPtr, jobject pixels) {
1554     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setIcon called.&quot;);
1555     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1556     GLASS_POOL_ENTER;
1557     {
1558         // implemenation comes here
1559     }
1560     GLASS_POOL_EXIT;
1561     GLASS_CHECK_EXCEPTION(env);
1562 }
1563 
1564 
1565 /*
1566  * Class:     com_sun_glass_ui_ios_IosWindow
1567  * Method:    _toFront
1568  * Signature: (J)V
1569  */
1570 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1toFront
1571 (JNIEnv *env, jobject jwindow, jlong windowPtr) {
1572     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1toFront called.&quot;);
1573     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1574     GLASS_POOL_ENTER;
1575     {
1576         GlassWindow *window = getGlassWindow(env, windowPtr);
1577         [window orderFrontRegardless];
1578     }
1579     GLASS_POOL_EXIT;
1580     GLASS_CHECK_EXCEPTION(env);
1581 }
1582 
1583 
1584 /*
1585  * Class:     com_sun_glass_ui_ios_IosWindow
1586  * Method:    _toBack
1587  * Signature: (J)V
1588  */
1589 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1toBack
1590 (JNIEnv *env, jobject jwindow, jlong windowPtr) {
1591     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1toBack called.&quot;);
1592     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1593     GLASS_POOL_ENTER;
1594     {
1595         GlassWindow *window = getGlassWindow(env, windowPtr);
1596         [window orderBack];
1597     }
1598     GLASS_POOL_EXIT;
1599     GLASS_CHECK_EXCEPTION(env);
1600 }
1601 
1602 
1603 /*
1604  * Class:     com_sun_glass_ui_ios_IosWindow
1605  * Method:    _enterModal
1606  * Signature: (J)V
1607  */
1608 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1enterModal
1609 (JNIEnv *env, jobject jwindow, jlong windowPtr) {
1610     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1enterModal called.&quot;);
1611     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1612     GLASS_POOL_ENTER;
1613     {
1614         // implementation omes here
1615     }
1616     GLASS_POOL_EXIT;
1617     GLASS_CHECK_EXCEPTION(env);
1618 }
1619 
1620 
1621 /*
1622  * Class:     com_sun_glass_ui_ios_IosWindow
1623  * Method:    _enterModalWithWindow
1624  * Signature: (JJ)V
1625  */
1626 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1enterModalWithWindow
1627 (JNIEnv *env, jobject jwindow, jlong windowPtr, jlong window) {
1628     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1enterModalWithWindow called.&quot;);
1629     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1630     GLASS_POOL_ENTER;
1631     {
1632         // implemenation comes here
1633     }
1634     GLASS_POOL_EXIT;
1635     GLASS_CHECK_EXCEPTION(env);
1636 }
1637 
1638 
1639 /*
1640  * Class:     com_sun_glass_ui_ios_IosWindow
1641  * Method:    _exitModal
1642  * Signature: (J)V
1643  */
1644 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1exitModal
1645 (JNIEnv *env, jobject jwindow, jlong windowPtr) {
1646     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1exitModal called.&quot;);
1647     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1648     GLASS_POOL_ENTER;
1649     {
1650         // implementation comes here
1651     }
1652     GLASS_POOL_EXIT;
1653     GLASS_CHECK_EXCEPTION(env);
1654 }
1655 
1656 
1657 /*
1658  * Class:     com_sun_glass_ui_ios_IosWindow
1659  * Method:    _setEnabled
1660  * Signature: (JZ)V
1661  */
1662 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setEnabled
1663 (JNIEnv *env, jobject jwindow, jlong windowPtr, jboolean enabled) {
1664     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setEnabled called.&quot;);
1665     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1666     GLASS_POOL_ENTER;
1667 
1668     GlassWindow *window = (GlassWindow*)jlong_to_ptr(windowPtr);
1669     [window setEnabled:(BOOL)enabled];
1670 
1671     GLASS_POOL_EXIT;
1672     GLASS_CHECK_EXCEPTION(env);
1673 }
1674 
1675 
1676 /*
1677  * Class:     com_sun_glass_ui_ios_IosWindow
1678  * Method:    _requestInput
1679  * Signature: (JLjava/lang/String;IDDDDDDDDDDDDDD)V
1680  */
1681 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1requestInput
1682 (JNIEnv *env, jobject jwin, jlong ptr, jstring text, jint type, jdouble width, jdouble height,
1683     jdouble mxx, jdouble mxy, jdouble mxz, jdouble mxt,
1684     jdouble myx, jdouble myy, jdouble myz, jdouble myt,
1685     jdouble mzx, jdouble mzy, jdouble mzz, jdouble mzt)
1686 {
1687     fprintf(stderr, &quot;We should never be here!\n&quot;);
1688     return;
1689 }
1690 
1691 
1692 /*
1693  * Class:     com_sun_glass_ui_ios_IosWindow
1694  * Method:    _releaseInput
1695  * Signature: (J)V
1696  */
1697 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1releaseInput (JNIEnv *env, jobject jwin, jlong ptr)
1698 {
1699     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1700     GLASS_POOL_ENTER;
1701 
1702     GlassWindow *window = getGlassWindow(env, ptr);
1703     [window releaseInput];
1704 
1705     GLASS_POOL_EXIT;
1706     GLASS_CHECK_EXCEPTION(env);
1707 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.controls/src/main/java/javafx/scene/control/skin/TableRowSkinBase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javafx.scene.control.skin;
 27 
 28 
 29 import java.lang.ref.Reference;
 30 import java.lang.ref.WeakReference;
 31 import java.util.*;
 32 
 33 import com.sun.javafx.PlatformUtil;
 34 import javafx.animation.FadeTransition;
 35 import javafx.beans.property.DoubleProperty;
 36 import javafx.beans.property.ObjectProperty;
 37 import javafx.collections.ListChangeListener;
 38 import javafx.collections.ObservableList;
 39 import javafx.collections.WeakListChangeListener;
 40 import javafx.collections.transformation.FilteredList;
 41 import javafx.css.StyleOrigin;
 42 import javafx.css.StyleableObjectProperty;
 43 import javafx.geometry.Insets;
 44 import javafx.geometry.Orientation;
 45 import javafx.geometry.Pos;
 46 import javafx.scene.Node;
 47 import javafx.scene.Parent;
 48 import javafx.scene.control.*;
 49 import javafx.util.Duration;
 50 
 51 import com.sun.javafx.tk.Toolkit;
 52 
 53 /**
 54  * TableRowSkinBase is the base skin class used by controls such as
 55  * {@link javafx.scene.control.TableRow} and {@link javafx.scene.control.TreeTableRow}
 56  * (the concrete classes are {@link TableRowSkin} and {@link TreeTableRowSkin},
 57  * respectively).
 58  *
 59  * @param &lt;T&gt; The type of the cell (i.e. the generic type of the {@link IndexedCell} subclass).
 60  * @param &lt;C&gt; The cell type (e.g. TableRow or TreeTableRow)
 61  * @param &lt;R&gt; The type of cell that is contained within each row (e.g.
 62  *           {@link javafx.scene.control.TableCell or {@link javafx.scene.control.TreeTableCell}}).
 63  *
 64  * @since 9
 65  * @see javafx.scene.control.TableRow
 66  * @see javafx.scene.control.TreeTableRow
 67  * @see TableRowSkin
 68  * @see TreeTableRowSkin
 69  */
 70 public abstract class TableRowSkinBase&lt;T,
 71                                        C extends IndexedCell/*&lt;T&gt;*/,
 72                                        R extends IndexedCell&gt; extends CellSkinBase&lt;C&gt; {
 73 
 74     /***************************************************************************
 75      *                                                                         *
 76      * Static Fields                                                           *
 77      *                                                                         *
 78      **************************************************************************/
 79 
 80     // There appears to be a memory leak when using the stub toolkit. Therefore,
 81     // to prevent tests from failing we disable the animations below when the
 82     // stub toolkit is being used.
 83     // Filed as RT-29163.
 84     private static boolean IS_STUB_TOOLKIT = Toolkit.getToolkit().toString().contains(&quot;StubToolkit&quot;);
 85 
 86     // lets save the CPU and not do animations when on embedded platforms
 87     private static boolean DO_ANIMATIONS = ! IS_STUB_TOOLKIT &amp;&amp; ! PlatformUtil.isEmbedded();
 88 
 89     private static final Duration FADE_DURATION = Duration.millis(200);
 90 
 91     /*
 92      * This is rather hacky - but it is a quick workaround to resolve the
 93      * issue that we don&#39;t know maximum width of a disclosure node for a given
 94      * control. If we don&#39;t know the maximum width, we have no way to ensure
 95      * consistent indentation.
 96      *
 97      * To work around this, we create a single WeakHashMap to store a max
 98      * disclosureNode width per TableColumnBase. We use WeakHashMap to help prevent
 99      * any memory leaks.
100      */
101     static final Map&lt;TableColumnBase&lt;?,?&gt;, Double&gt; maxDisclosureWidthMap = new WeakHashMap&lt;&gt;();
102 
103     // Specifies the number of times we will call &#39;recreateCells()&#39; before we blow
104     // out the cellsMap structure and rebuild all cells. This helps to prevent
105     // against memory leaks in certain extreme circumstances.
106     private static final int DEFAULT_FULL_REFRESH_COUNTER = 100;
107 
108 
109 
110     /***************************************************************************
111      *                                                                         *
112      * Private Fields                                                          *
113      *                                                                         *
114      **************************************************************************/
115 
116     /*
117      * A map that maps from TableColumn to TableCell (i.e. model to view).
118      * This is recreated whenever the leaf columns change, however to increase
119      * efficiency we create cells for all columns, even if they aren&#39;t visible,
120      * and we only create new cells if we don&#39;t already have it cached in this
121      * map.
122      *
123      * Note that this means that it is possible for this map to therefore be
124      * a memory leak if an application uses TableView and is creating and removing
125      * a large number of tableColumns. This is mitigated in the recreateCells()
126      * function below - refer to that to learn more.
127      */
128     WeakHashMap&lt;TableColumnBase, Reference&lt;R&gt;&gt; cellsMap;
129 
130     // This observableArrayList contains the currently visible table cells for this row.
131     final List&lt;R&gt; cells = new ArrayList&lt;&gt;();
132 
133     private int fullRefreshCounter = DEFAULT_FULL_REFRESH_COUNTER;
134 
135     boolean isDirty = false;
136     boolean updateCells = false;
137 
138     double fixedCellSize;
139     boolean fixedCellSizeEnabled;
140 
141 
142     /***************************************************************************
143      *                                                                         *
144      * Constructors                                                            *
145      *                                                                         *
146      **************************************************************************/
147 
148     /**
149      * Creates a new instance of TableRowSkinBase, although note that this
150      * instance does not handle any behavior / input mappings - this needs to be
151      * handled appropriately by subclasses.
152      *
153      * @param control The control that this skin should be installed onto.
154      */
155     public TableRowSkinBase(C control) {
156         super(control);
157         getSkinnable().setPickOnBounds(false);
158 
159         recreateCells();
160 
161         if(control instanceof TableRow){
162             TableRow tableRow = (TableRow)control;
163             TableView tableView = tableRow.getTableView();
164             if(tableView!=null){
165                 fixedCellSize = tableView.getFixedCellSize();
166                 fixedCellSizeEnabled = fixedCellSize &gt;= 0;
167             }
168         }else if(control instanceof TreeTableRow){
169             TreeTableRow treeTableRow = (TreeTableRow)control;
170             TreeTableView treeTableView = treeTableRow.getTreeTableView();
171             if(treeTableView!=null){
172                 fixedCellSize = treeTableView.getFixedCellSize();
173                 fixedCellSizeEnabled = fixedCellSize &gt;= 0;
174             }
175         }
176 
177         updateCells(true);
178         // init bindings
179         // watches for any change in the leaf columns observableArrayList - this will indicate
180         // that the column order has changed and that we should update the row
181         // such that the cells are in the new order
182         getVisibleLeafColumns().addListener(weakVisibleLeafColumnsListener);
183         // --- end init bindings
184 
185 
186         // use invalidation listener here to update even when item equality is true
187         // (e.g. see RT-22463)
188         control.itemProperty().addListener(o -&gt; requestCellUpdate());
189         registerChangeListener(control.indexProperty(), e -&gt; {
190             // Fix for RT-36661, where empty table cells were showing content, as they
191             // had incorrect table cell indices (but the table row index was correct).
192             // Note that we only do the update on empty cells to avoid the issue
193             // noted below in requestCellUpdate().
194             if (getSkinnable().isEmpty()) {
195                 requestCellUpdate();
196             }
197         });
198     }
199 
200 
201 
202     /***************************************************************************
203      *                                                                         *
204      * Listeners                                                               *
205      *                                                                         *
206      **************************************************************************/
207 
208     private ListChangeListener&lt;TableColumnBase&gt; visibleLeafColumnsListener = c -&gt; {
209         isDirty = true;
210         getSkinnable().requestLayout();
211     };
212 
213     private WeakListChangeListener&lt;TableColumnBase&gt; weakVisibleLeafColumnsListener =
214             new WeakListChangeListener&lt;&gt;(visibleLeafColumnsListener);
215 
216 
217 
218     /***************************************************************************
219      *                                                                         *
220      * Abstract Methods                                                        *
221      *                                                                         *
222      **************************************************************************/
223 
224     /**
225      * Creates a new cell instance that is suitable for representing the given table column instance.
226      * @param tc the table column
227      * @return the created cell
228      */
229     protected abstract R createCell(TableColumnBase&lt;T,?&gt; tc);
230 
231     /**
232      * A method to allow the given cell to be told that it is a member of the given row.
233      * How this is implemented is dependent on the actual cell implementation.
234      * @param cell The cell for which we want to inform it of its owner row.
235      * @param row The row which will be set on the given cell.
236      */
237     protected abstract void updateCell(R cell, C row);
238 
239     /**
240      * Returns the {@link TableColumnBase} instance for the given cell instance.
241      * @param cell The cell for which a TableColumn is desired.
242      * @return the table column
243      */
244     protected abstract TableColumnBase&lt;T,?&gt; getTableColumn(R cell);
245 
246     /**
247      * Returns an unmodifiable list containing the currently visible leaf columns.
248      * @return the list of visible leaf columns
249      */
250     protected abstract ObservableList&lt;? extends TableColumnBase/*&lt;T,?&gt;*/&gt; getVisibleLeafColumns();
251 
252 
253 
254     /***************************************************************************
255      *                                                                         *
256      * Public Methods                                                          *
257      *                                                                         *
258      **************************************************************************/
259 
260     /**
261      * Returns the graphic to draw on the inside of the disclosure node. Null
262      * is acceptable when no graphic should be shown. Commonly this is the
263      * graphic associated with a TreeItem (i.e. treeItem.getGraphic()), rather
264      * than a graphic associated with a cell.
265      * @return the graphic to draw on the inside of the disclosure node
266      */
267     protected ObjectProperty&lt;Node&gt; graphicProperty() {
268         return null;
269     }
270 
271     /** {@inheritDoc} */
272     @Override protected void layoutChildren(double x, final double y, final double w, final double h) {
273         checkState();
274         if (cellsMap.isEmpty()) return;
275 
276         ObservableList&lt;? extends TableColumnBase&gt; visibleLeafColumns = getVisibleLeafColumns();
277         final int visibleLeafColumnsSize =  visibleLeafColumns.size();
278         if (visibleLeafColumnsSize==0) {
279             super.layoutChildren(x,y,w,h);
280             return;
281         }
282 
283         C control = getSkinnable();
284 
285         ///////////////////////////////////////////
286         // indentation code starts here
287         ///////////////////////////////////////////
288         double leftMargin = 0;
289         double disclosureWidth = 0;
290         double graphicWidth = 0;
291         boolean indentationRequired = isIndentationRequired();
292         boolean disclosureVisible = isDisclosureNodeVisible();
293         int indentationColumnIndex = 0;
294         Node disclosureNode = null;
295         if (indentationRequired) {
296             // Determine the column in which we want to put the disclosure node.
297             // By default it is null, which means the 0th column should be
298             // where the indentation occurs.
299             TableColumnBase&lt;?,?&gt; treeColumn = getTreeColumn();
300             indentationColumnIndex = treeColumn == null ? 0 : visibleLeafColumns.indexOf(treeColumn);
301             indentationColumnIndex = indentationColumnIndex &lt; 0 ? 0 : indentationColumnIndex;
302 
303             int indentationLevel = getIndentationLevel(control);
304             if (! isShowRoot()) indentationLevel--;
305             final double indentationPerLevel = getIndentationPerLevel();
306             leftMargin = indentationLevel * indentationPerLevel;
307 
308             // position the disclosure node so that it is at the proper indent
309             final double defaultDisclosureWidth = maxDisclosureWidthMap.containsKey(treeColumn) ?
310                 maxDisclosureWidthMap.get(treeColumn) : 0;
311             disclosureWidth = defaultDisclosureWidth;
312 
313             disclosureNode = getDisclosureNode();
314             if (disclosureNode != null) {
315                 disclosureNode.setVisible(disclosureVisible);
316 
317                 if (disclosureVisible) {
318                     disclosureWidth = disclosureNode.prefWidth(h);
319                     if (disclosureWidth &gt; defaultDisclosureWidth) {
320                         maxDisclosureWidthMap.put(treeColumn, disclosureWidth);
321 
322                         // RT-36359: The recorded max width of the disclosure node
323                         // has increased. We need to go back and request all
324                         // earlier rows to update themselves to take into account
325                         // this increased indentation.
326                         final VirtualFlow&lt;C&gt; flow = getVirtualFlow();
327                         for (int i = 0, max = flow.getCellCount(); i &lt; max; i++) {
328                             C cell = flow.getCell(i);
329                             if (cell == null || cell.isEmpty()) continue;
330                             cell.requestLayout();
331                             cell.layout();
332                         }
333                     }
334                 }
335             }
336         }
337         ///////////////////////////////////////////
338         // indentation code ends here
339         ///////////////////////////////////////////
340 
341         // layout the individual column cells
342         double width;
343         double height;
344 
345         final double verticalPadding = snappedTopInset() + snappedBottomInset();
346         final double controlHeight = control.getHeight();
347 
348         /**
349          * RT-26743:TreeTableView: Vertical Line looks unfinished.
350          * We used to not do layout on cells whose row exceeded the number
351          * of items, but now we do so as to ensure we get vertical lines
352          * where expected in cases where the vertical height exceeds the
353          * number of items.
354          */
355         int index = control.getIndex();
356         if (index &lt; 0/* || row &gt;= itemsProperty().get().size()*/) return;
357 
358         int firstVisibleColumnIndex = -1;
359         int lastVisibleColumnIndex = -1;
360         final VirtualFlow&lt;?&gt; virtualFlow = getVirtualFlow();
361         final double scrollX = virtualFlow == null ? 0.0 : virtualFlow.getHbar().getValue();
362         final Insets padding = getSkinnable().getPadding();
363         final double vfWidth = virtualFlow == null ? 0.0:virtualFlow.getWidth();
364         final double headerWidth = vfWidth - (padding.getLeft() + padding.getRight());
365 
366         double start = 0;
367         for (int i = 0; i &lt; visibleLeafColumnsSize; i++) {
368             TableColumnBase&lt;?,?&gt; c = visibleLeafColumns.get(i);
369             double end = start + snapSizeX(c.getWidth());
370             final boolean visible = isOverlap(start, end, scrollX, headerWidth + scrollX);
371             if(visible) {
372                 if(firstVisibleColumnIndex == -1) {
373                     firstVisibleColumnIndex = i;
374                 }
375                 lastVisibleColumnIndex = i;
376             }else if( firstVisibleColumnIndex != -1 ) {
377                 break;
378             }
379             start = end;
380         }
381 
382         final ObservableList&lt;Node&gt; children = getChildren();
383         if(fixedCellSizeEnabled) {
384             for (int column = cells.size()-1; column &gt;= 0; column--) {
385                 R tableCell = cells.get(column);
386                 final boolean isVisible = firstVisibleColumnIndex &lt;= column &amp;&amp; column &lt;= lastVisibleColumnIndex;
387                 if (isVisible ) {
388                     if(tableCell.getParent()==null){
389                         children.add(tableCell);
390                     }
391                 }else{
392                     // we only add/remove to the scenegraph if the fixed cell
393                     // length support is enabled - otherwise we keep all
394                     // TableCells in the scenegraph
395                     if(tableCell.getParent()!=null){
396                         children.remove(tableCell);
397                     }
398                 }
399             }
400         }
401 
402         // Added for RT-32700, and then updated for RT-34074.
403         // We change the alignment from CENTER_LEFT to TOP_LEFT if the
404         // height of the row is greater than the default size, and if
405         // the alignment is the default alignment.
406         // What I would rather do is only change the alignment if the
407         // alignment has not been manually changed, but for now this will
408         // do.
409         final boolean centreContent = h &lt;= 24.0;
410 
411         double layoutY = snappedTopInset();
412         final double snapSizeYVerticalPadding = snapSizeY(verticalPadding);
413 
414         for (int column = 0, max = cells.size(); column &lt; max; column++) {
415             R tableCell = cells.get(column);
416             TableColumnBase&lt;T, ?&gt; tableColumn = getTableColumn(tableCell);
417 
418             boolean isVisible = firstVisibleColumnIndex &lt;= column &amp;&amp; column &lt;= lastVisibleColumnIndex;
419             width = snapSizeX(tableColumn.getWidth());
420             if (isVisible || isOverlap(tableCell.getLayoutX(), tableCell.getLayoutX()+width, scrollX, headerWidth + scrollX)) {
421                 // if the style origin is null then the property has not been
422                 // set (or it has been reset to its default), which means that
423                 // we can set it without overwriting someone elses settings.
424                 final StyleOrigin origin = ((StyleableObjectProperty&lt;?&gt;) tableCell.alignmentProperty()).getStyleOrigin();
425                 if (! centreContent &amp;&amp; origin == null) {
426                     tableCell.setAlignment(Pos.TOP_LEFT);
427                 }
428                 // --- end of RT-32700 fix
429 
430                 ///////////////////////////////////////////
431                 // further indentation code starts here
432                 ///////////////////////////////////////////
433                 if (indentationRequired &amp;&amp; column == indentationColumnIndex) {
434                     if (disclosureVisible) {
435                         double ph = disclosureNode.prefHeight(disclosureWidth);
436 
437                         if (width &gt; 0 &amp;&amp; width &lt; (disclosureWidth + leftMargin)) {
438                             fadeOut(disclosureNode);
439                         } else {
440                             fadeIn(disclosureNode);
441                             disclosureNode.resize(disclosureWidth, ph);
442 
443                             disclosureNode.relocate(x + leftMargin,
444                                     centreContent ? (h / 2.0 - ph / 2.0) :
445                                             (y + tableCell.getPadding().getTop()));
446                             disclosureNode.toFront();
447                         }
448                     }
449 
450                     // determine starting point of the graphic or cell node, and the
451                     // remaining width available to them
452                     ObjectProperty&lt;Node&gt; graphicProperty = graphicProperty();
453                     Node graphic = graphicProperty == null ? null : graphicProperty.get();
454 
455                     if (graphic != null) {
456                         graphicWidth = graphic.prefWidth(-1) + 3;
457                         double ph = graphic.prefHeight(graphicWidth);
458 
459                         if (width &gt; 0 &amp;&amp; width &lt; disclosureWidth + leftMargin + graphicWidth) {
460                             fadeOut(graphic);
461                         } else {
462                             fadeIn(graphic);
463 
464                             graphic.relocate(x + leftMargin + disclosureWidth,
465                                     centreContent ? (h / 2.0 - ph / 2.0) :
466                                             (y + tableCell.getPadding().getTop()));
467 
468                             graphic.toFront();
469                         }
470                     }
471                 }
472 
473                 if (fixedCellSizeEnabled) {
474                     // we determine if the cell is visible, and if not we have the
475                     // ability to take it out of the scenegraph to help improve
476                     // performance. However, we only do this when there is a
477                     // fixed cell length specified in the TableView. This is because
478                     // when we have a fixed cell length it is possible to know with
479                     // certainty the height of each TableCell - it is the fixed value
480                     // provided by the developer, and this means that we do not have
481                     // to concern ourselves with the possibility that the height
482                     // may be variable and / or dynamic.
483 
484                     height = fixedCellSize;
485                 } else {
486                     height = Math.max(controlHeight, tableCell.prefHeight(-1));
487                     height = snapSizeY(height) - snapSizeYVerticalPadding;
488                 }
489 
490                 ///////////////////////////////////////////
491                 // further indentation code ends here
492                 ///////////////////////////////////////////
493                 tableCell.resizeRelocate(x, layoutY, width, height);
494 
495                 // Request layout is here as (partial) fix for RT-28684.
496                 // This does not appear to impact performance...
497                 tableCell.requestLayout();
498             }else if(fixedCellSizeEnabled &amp;&amp; lastVisibleColumnIndex&lt;column){
499                 break;
500             }
501             x += width;
502         }
503     }
504 
505     int getIndentationLevel(C control) {
506         return 0;
507     }
508 
509     double getIndentationPerLevel() {
510         return 0;
511     }
512 
513     /**
514      * Used to represent whether the current virtual flow owner is wanting
515      * indentation to be used in this table row.
516      */
517     boolean isIndentationRequired() {
518         return false;
519     }
520 
521     /**
522      * Returns the table column that should show the disclosure nodes and / or
523      * a graphic. By default this is the left-most column.
524      */
525     TableColumnBase getTreeColumn() {
526         return null;
527     }
528 
529     Node getDisclosureNode() {
530         return null;
531     }
532 
533     /**
534      * Used to represent whether a disclosure node is visible for _this_
535      * table row. Not to be confused with isIndentationRequired(), which is the
536      * more general API.
537      */
538     boolean isDisclosureNodeVisible() {
539         return false;
540     }
541 
542     boolean isShowRoot() {
543         return true;
544     }
545 
546     void updateCells(boolean resetChildren) {
547         // To avoid a potential memory leak (when the TableColumns in the
548         // TableView are created/inserted/removed/deleted, we have a &#39;refresh
549         // counter&#39; that when we reach 0 will delete all cells in this row
550         // and recreate all of them.
551         if (resetChildren) {
552             if (fullRefreshCounter == 0) {
553                 recreateCells();
554             }
555             fullRefreshCounter--;
556         }
557 
558         // if clear isn&#39;t called first, we can run into situations where the
559         // cells aren&#39;t updated properly.
560         final boolean cellsEmpty = cells.isEmpty();
561         cells.clear();
562 
563         final C skinnable = getSkinnable();
564         final int skinnableIndex = skinnable.getIndex();
565         final List&lt;? extends TableColumnBase/*&lt;T,?&gt;*/&gt; visibleLeafColumns = getVisibleLeafColumns();
566 
567         for (TableColumnBase&lt;T,?&gt; col : visibleLeafColumns) {
568 
569             R cell = null;
570             if (cellsMap.containsKey(col)) {
571                 cell = cellsMap.get(col).get();
572 
573                 // the reference has been gc&#39;d, remove key entry from map
574                 if (cell == null) {
575                     cellsMap.remove(col);
576                 }
577             }
578 
579             if (cell == null) {
580                 // if the cell is null it means we don&#39;t have it in cache and
581                 // need to create it
582                 cell = createCellAndCache(col);
583             }
584 
585             updateCell(cell, skinnable);
586             cell.updateIndex(skinnableIndex);
587             cells.add(cell);
588         }
589 
590         if (fixedCellSizeEnabled) {
591             return;
592         }
593         if (resetChildren || cellsEmpty) {
594             getChildren().setAll(cells);
595         }
596     }
597 
598     VirtualFlow&lt;C&gt; getVirtualFlow() {
599         Parent p = getSkinnable();
600         while (p != null) {
601             if (p instanceof VirtualFlow) {
602                 return (VirtualFlow&lt;C&gt;) p;
603             }
604             p = p.getParent();
605         }
606         return null;
607     }
608 
609     /** {@inheritDoc} */
610     @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
611         double width = 0;
612         ObservableList&lt;? extends TableColumnBase&gt; visibleLeafColumns = getVisibleLeafColumns();
613         for (TableColumnBase&lt;?,?&gt; c: visibleLeafColumns) {
614             if( c.isVisible() ) {
615                 width += snapSizeX(c.getWidth());
616             }
617         }
618         final Insets padding = getSkinnable().getPadding();
619         return width + padding.getLeft() + padding.getRight();
620     }
621 
622     /** {@inheritDoc} */
623     @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
624         if (fixedCellSizeEnabled) {
625             return fixedCellSize;
626         }
627 
628         // fix for RT-29080
629         checkState();
630 
631         // Support for RT-18467: making it easier to specify a height for
632         // cells via CSS, where the desired height is less than the height
633         // of the TableCells. Essentially, -fx-cell-size is given higher
634         // precedence now
635         final double cellSize = getCellSize();
636         if (cellSize &lt; DEFAULT_CELL_SIZE) {
637             return cellSize;
638         }
639 
640         // FIXME according to profiling, this method is slow and should
641         // be optimised
642         double prefHeight = 0.0f;
643         final int count = cells.size();
644         for (int i=0; i&lt;count; i++) {
645             final R tableCell = cells.get(i);
646             prefHeight = Math.max(prefHeight, tableCell.prefHeight(-1));
647         }
648         double ph = Math.max(prefHeight, Math.max(cellSize, getSkinnable().minHeight(-1)));
649         return ph;
650     }
651 
652     /** {@inheritDoc} */
653     @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
654         if (fixedCellSizeEnabled) {
655             return fixedCellSize;
656         }
657 
658         // fix for RT-29080
659         checkState();
660 
661         // Support for RT-18467: making it easier to specify a height for
662         // cells via CSS, where the desired height is less than the height
663         // of the TableCells. Essentially, -fx-cell-size is given higher
664         // precedence now
665         final double cellSize = getCellSize();
666         if (cellSize &lt; DEFAULT_CELL_SIZE) {
667             return cellSize;
668         }
669 
670         // FIXME according to profiling, this method is slow and should
671         // be optimised
672         double minHeight = 0.0f;
673         final int count = cells.size();
674         for (int i = 0; i &lt; count; i++) {
675             final R tableCell = cells.get(i);
676             minHeight = Math.max(minHeight, tableCell.minHeight(-1));
677         }
678         return minHeight;
679     }
680 
681     /** {@inheritDoc} */
682     @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
683         if (fixedCellSizeEnabled) {
684             return fixedCellSize;
685         }
686         return super.computeMaxHeight(width, topInset, rightInset, bottomInset, leftInset);
687     }
688 
689     final void checkState() {
690         if (isDirty) {
691             updateCells(true);
692             isDirty = false;
693             updateCells = false;
694         } else if (updateCells) {
695             updateCells(false);
696             updateCells = false;
697         }
698     }
699 
700 
701 
702     /***************************************************************************
703      *                                                                         *
704      * Private Implementation                                                  *
705      *                                                                         *
706      **************************************************************************/
707 
708     private static boolean isOverlap(double start, double end, double start2, double end2){
709         return (start&lt;=end2 &amp;&amp; end &gt;= start2);
710     }
711 
712     private void requestCellUpdate() {
713         updateCells = true;
714         getSkinnable().requestLayout();
715 
716         // update the index of all children cells (RT-29849).
717         // Note that we do this after the TableRow item has been updated,
718         // rather than when the TableRow index has changed (as this will be
719         // before the row has updated its item). This will result in the
720         // issue highlighted in RT-33602, where the table cell had the correct
721         // item whilst the row had the old item.
722         final int newIndex = getSkinnable().getIndex();
723         for (int i = 0, max = cells.size(); i &lt; max; i++) {
724             cells.get(i).updateIndex(newIndex);
725         }
726     }
727 
728     private void recreateCells() {
729         if (cellsMap != null) {
730             Collection&lt;Reference&lt;R&gt;&gt; cells = cellsMap.values();
731             Iterator&lt;Reference&lt;R&gt;&gt; cellsIter = cells.iterator();
732             while (cellsIter.hasNext()) {
733                 Reference&lt;R&gt; cellRef = cellsIter.next();
734                 R cell = cellRef.get();
735                 if (cell != null) {
736                     cell.updateIndex(-1);
737                     cell.getSkin().dispose();
738                     cell.setSkin(null);
739                 }
740             }
741             cellsMap.clear();
742         }
743 
744         ObservableList&lt;? extends TableColumnBase/*&lt;T,?&gt;*/&gt; columns = getVisibleLeafColumns();
745 
746         cellsMap = new WeakHashMap&lt;&gt;(columns.size());
747         fullRefreshCounter = DEFAULT_FULL_REFRESH_COUNTER;
748         getChildren().clear();
749 
750         for (TableColumnBase col : columns) {
751             if (cellsMap.containsKey(col)) {
752                 continue;
753             }
754 
755             // create a TableCell for this column and store it in the cellsMap
756             // for future use
757             createCellAndCache(col);
758         }
759     }
760 
761     private R createCellAndCache(TableColumnBase&lt;T,?&gt; col) {
762         // we must create a TableCell for this table column
763         R cell = createCell(col);
764 
765         // and store this in our HashMap until needed
766         cellsMap.put(col, new WeakReference&lt;&gt;(cell));
767 
768         return cell;
769     }
770 
771     private void fadeOut(final Node node) {
772         if (node.getOpacity() &lt; 1.0) return;
773 
774         if (! DO_ANIMATIONS) {
775             node.setOpacity(0);
776             return;
777         }
778 
779         final FadeTransition fader = new FadeTransition(FADE_DURATION, node);
780         fader.setToValue(0.0);
781         fader.play();
782     }
783 
784     private void fadeIn(final Node node) {
785         if (node.getOpacity() &gt; 0.0) return;
786 
787         if (! DO_ANIMATIONS) {
788             node.setOpacity(1);
789             return;
790         }
791 
792         final FadeTransition fader = new FadeTransition(FADE_DURATION, node);
793         fader.setToValue(1.0);
794         fader.play();
795     }
796 }
    </pre>
  </body>
</html>
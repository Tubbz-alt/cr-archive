<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/baseclasses/winctrl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 //------------------------------------------------------------------------------
   2 // File: WinCtrl.cpp
   3 //
   4 // Desc: DirectShow base classes - implements video control interface class.
   5 //
   6 // Copyright (c) 1992-2001 Microsoft Corporation.  All rights reserved.
   7 //------------------------------------------------------------------------------
   8 
   9 
  10 #include &lt;streams.h&gt;
  11 #include &lt;intsafe.h&gt;
  12 #include &lt;checkbmi.h&gt;
  13 
  14 // The control interface methods require us to be connected
  15 
  16 #define CheckConnected(pin,code)                    \
  17 {                                                   \
  18     if (pin == NULL) {                              \
  19         ASSERT(!TEXT(&quot;Pin not set&quot;));               \
  20     } else if (pin-&gt;IsConnected() == FALSE) {       \
  21         return (code);                              \
  22     }                                               \
  23 }
  24 
  25 // This checks to see whether the window has a drain. An application can in
  26 // most environments set the owner/parent of windows so that they appear in
  27 // a compound document context (for example). In this case, the application
  28 // would probably like to be told of any keyboard/mouse messages. Therefore
  29 // we pass these messages on untranslated, returning TRUE if we&#39;re successful
  30 
  31 BOOL WINAPI PossiblyEatMessage(HWND hwndDrain, UINT uMsg, WPARAM wParam, LPARAM lParam)
  32 {
  33     if (hwndDrain != NULL &amp;&amp; !InSendMessage())
  34     {
  35         switch (uMsg)
  36         {
  37             case WM_CHAR:
  38             case WM_DEADCHAR:
  39             case WM_KEYDOWN:
  40             case WM_KEYUP:
  41             case WM_LBUTTONDBLCLK:
  42             case WM_LBUTTONDOWN:
  43             case WM_LBUTTONUP:
  44             case WM_MBUTTONDBLCLK:
  45             case WM_MBUTTONDOWN:
  46             case WM_MBUTTONUP:
  47             case WM_MOUSEACTIVATE:
  48             case WM_MOUSEMOVE:
  49             // If we pass this on we don&#39;t get any mouse clicks
  50             //case WM_NCHITTEST:
  51             case WM_NCLBUTTONDBLCLK:
  52             case WM_NCLBUTTONDOWN:
  53             case WM_NCLBUTTONUP:
  54             case WM_NCMBUTTONDBLCLK:
  55             case WM_NCMBUTTONDOWN:
  56             case WM_NCMBUTTONUP:
  57             case WM_NCMOUSEMOVE:
  58             case WM_NCRBUTTONDBLCLK:
  59             case WM_NCRBUTTONDOWN:
  60             case WM_NCRBUTTONUP:
  61             case WM_RBUTTONDBLCLK:
  62             case WM_RBUTTONDOWN:
  63             case WM_RBUTTONUP:
  64             case WM_SYSCHAR:
  65             case WM_SYSDEADCHAR:
  66             case WM_SYSKEYDOWN:
  67             case WM_SYSKEYUP:
  68 
  69                 DbgLog((LOG_TRACE, 2, TEXT(&quot;Forwarding %x to drain&quot;)));
  70                 PostMessage(hwndDrain, uMsg, wParam, lParam);
  71 
  72                 return TRUE;
  73         }
  74     }
  75     return FALSE;
  76 }
  77 
  78 
  79 // This class implements the IVideoWindow control functions (dual interface)
  80 // we support a large number of properties and methods designed to allow the
  81 // client (whether it be an automation controller or a C/C++ application) to
  82 // set and get a number of window related properties such as it&#39;s position.
  83 // We also support some methods that duplicate the properties but provide a
  84 // more direct and efficient mechanism as many values may be changed in one
  85 
  86 CBaseControlWindow::CBaseControlWindow(
  87                         __inout CBaseFilter *pFilter,     // Owning filter
  88                         __in CCritSec *pInterfaceLock,    // Locking object
  89                         __in_opt LPCTSTR pName,           // Object description
  90                         __inout_opt LPUNKNOWN pUnk,       // Normal COM ownership
  91                         __inout HRESULT *phr) :           // OLE return code
  92 
  93     CBaseVideoWindow(pName,pUnk),
  94     m_pInterfaceLock(pInterfaceLock),
  95     m_hwndOwner(NULL),
  96     m_hwndDrain(NULL),
  97     m_bAutoShow(TRUE),
  98     m_pFilter(pFilter),
  99     m_bCursorHidden(FALSE),
 100     m_pPin(NULL)
 101 {
 102     ASSERT(m_pFilter);
 103     ASSERT(m_pInterfaceLock);
 104     ASSERT(phr);
 105     m_BorderColour = VIDEO_COLOUR;
 106 }
 107 
 108 
 109 // Set the title caption on the base window, we don&#39;t do any field checking
 110 // as we really don&#39;t care what title they intend to have. We can always get
 111 // it back again later with GetWindowText. The only other complication is to
 112 // do the necessary string conversions between ANSI and OLE Unicode strings
 113 
 114 STDMETHODIMP CBaseControlWindow::put_Caption(__in BSTR strCaption)
 115 {
 116     CheckPointer((PVOID)strCaption,E_POINTER);
 117     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 118 #ifdef UNICODE
 119     SetWindowText(m_hwnd, strCaption);
 120 #else
 121     CHAR Caption[CAPTION];
 122 
 123     WideCharToMultiByte(CP_ACP,0,strCaption,-1,Caption,CAPTION,NULL,NULL);
 124     SetWindowText(m_hwnd, Caption);
 125 #endif
 126     return NOERROR;
 127 }
 128 
 129 
 130 // Get the current base window title caption, once again we do no real field
 131 // checking. We allocate a string for the window title to be filled in with
 132 // which ensures the interface doesn&#39;t fiddle around with getting memory. A
 133 // BSTR is a normal C string with the length at position (-1), we use the
 134 // WriteBSTR helper function to create the caption to try and avoid OLE32
 135 
 136 STDMETHODIMP CBaseControlWindow::get_Caption(__out BSTR *pstrCaption)
 137 {
 138     CheckPointer(pstrCaption,E_POINTER);
 139     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 140     WCHAR WideCaption[CAPTION];
 141 
 142 #ifdef UNICODE
 143     GetWindowText(m_hwnd,WideCaption,CAPTION);
 144 #else
 145     // Convert the ASCII caption to a UNICODE string
 146 
 147     TCHAR Caption[CAPTION];
 148     GetWindowText(m_hwnd,Caption,CAPTION);
 149     MultiByteToWideChar(CP_ACP,0,Caption,-1,WideCaption,CAPTION);
 150 #endif
 151     return WriteBSTR(pstrCaption,WideCaption);
 152 }
 153 
 154 
 155 // Set the window style using GWL_EXSTYLE
 156 
 157 STDMETHODIMP CBaseControlWindow::put_WindowStyleEx(long WindowStyleEx)
 158 {
 159     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 160 
 161     // Should we be taking off WS_EX_TOPMOST
 162 
 163     if (GetWindowLong(m_hwnd,GWL_EXSTYLE) &amp; WS_EX_TOPMOST) {
 164         if ((WindowStyleEx &amp; WS_EX_TOPMOST) == 0) {
 165             SendMessage(m_hwnd,m_ShowStageTop,(WPARAM) FALSE,(LPARAM) 0);
 166         }
 167     }
 168 
 169     // Likewise should we be adding WS_EX_TOPMOST
 170 
 171     if (WindowStyleEx &amp; WS_EX_TOPMOST) {
 172         SendMessage(m_hwnd,m_ShowStageTop,(WPARAM) TRUE,(LPARAM) 0);
 173         WindowStyleEx &amp;= (~WS_EX_TOPMOST);
 174         if (WindowStyleEx == 0) return NOERROR;
 175     }
 176     return DoSetWindowStyle(WindowStyleEx,GWL_EXSTYLE);
 177 }
 178 
 179 
 180 // Gets the current GWL_EXSTYLE base window style
 181 
 182 STDMETHODIMP CBaseControlWindow::get_WindowStyleEx(__out long *pWindowStyleEx)
 183 {
 184     CheckPointer(pWindowStyleEx,E_POINTER);
 185     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 186     return DoGetWindowStyle(pWindowStyleEx,GWL_EXSTYLE);
 187 }
 188 
 189 
 190 // Set the window style using GWL_STYLE
 191 
 192 STDMETHODIMP CBaseControlWindow::put_WindowStyle(long WindowStyle)
 193 {
 194     // These styles cannot be changed dynamically
 195 
 196     if ((WindowStyle &amp; WS_DISABLED) ||
 197         (WindowStyle &amp; WS_ICONIC) ||
 198         (WindowStyle &amp; WS_MAXIMIZE) ||
 199         (WindowStyle &amp; WS_MINIMIZE) ||
 200         (WindowStyle &amp; WS_HSCROLL) ||
 201         (WindowStyle &amp; WS_VSCROLL)) {
 202 
 203             return E_INVALIDARG;
 204     }
 205 
 206     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 207     return DoSetWindowStyle(WindowStyle,GWL_STYLE);
 208 }
 209 
 210 
 211 // Get the current GWL_STYLE base window style
 212 
 213 STDMETHODIMP CBaseControlWindow::get_WindowStyle(__out long *pWindowStyle)
 214 {
 215     CheckPointer(pWindowStyle,E_POINTER);
 216     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 217     return DoGetWindowStyle(pWindowStyle,GWL_STYLE);
 218 }
 219 
 220 
 221 // Change the base window style or the extended styles depending on whether
 222 // WindowLong is GWL_STYLE or GWL_EXSTYLE. We must call SetWindowPos to have
 223 // the window displayed in it&#39;s new style after the change which is a little
 224 // tricky if the window is not currently visible as we realise it offscreen.
 225 // In most cases the client will call get_WindowStyle before they call this
 226 // and then AND and OR in extra bit settings according to the requirements
 227 
 228 HRESULT CBaseControlWindow::DoSetWindowStyle(long Style,long WindowLong)
 229 {
 230     RECT WindowRect;
 231 
 232     // Get the window&#39;s visibility before setting the style
 233     BOOL bVisible = IsWindowVisible(m_hwnd);
 234     EXECUTE_ASSERT(GetWindowRect(m_hwnd,&amp;WindowRect));
 235 
 236     // Set the new style flags for the window
 237     SetWindowLong(m_hwnd,WindowLong,Style);
 238     UINT WindowFlags = SWP_SHOWWINDOW | SWP_FRAMECHANGED | SWP_NOACTIVATE;
 239     WindowFlags |= SWP_NOZORDER | SWP_NOSIZE | SWP_NOMOVE;
 240 
 241     // Show the window again in the current position
 242 
 243     if (bVisible == TRUE) {
 244 
 245         SetWindowPos(m_hwnd,            // Base window handle
 246                      HWND_TOP,          // Just a place holder
 247                      0,0,0,0,           // Leave size and position
 248                      WindowFlags);      // Just draw it again
 249 
 250         return NOERROR;
 251     }
 252 
 253     // Move the window offscreen so the user doesn&#39;t see the changes
 254 
 255     MoveWindow((HWND) m_hwnd,                     // Base window handle
 256                GetSystemMetrics(SM_CXSCREEN),     // Current desktop width
 257                GetSystemMetrics(SM_CYSCREEN),     // Likewise it&#39;s height
 258                WIDTH(&amp;WindowRect),                // Use the same width
 259                HEIGHT(&amp;WindowRect),               // Keep height same to
 260                TRUE);                             // May as well repaint
 261 
 262     // Now show the previously hidden window
 263 
 264     SetWindowPos(m_hwnd,            // Base window handle
 265                  HWND_TOP,          // Just a place holder
 266                  0,0,0,0,           // Leave size and position
 267                  WindowFlags);      // Just draw it again
 268 
 269     ShowWindow(m_hwnd,SW_HIDE);
 270 
 271     if (GetParent(m_hwnd)) {
 272 
 273         MapWindowPoints(HWND_DESKTOP, GetParent(m_hwnd), (LPPOINT)&amp;WindowRect, 2);
 274     }
 275 
 276     MoveWindow((HWND) m_hwnd,        // Base window handle
 277                WindowRect.left,      // Existing x coordinate
 278                WindowRect.top,       // Existing y coordinate
 279                WIDTH(&amp;WindowRect),   // Use the same width
 280                HEIGHT(&amp;WindowRect),  // Keep height same to
 281                TRUE);                // May as well repaint
 282 
 283     return NOERROR;
 284 }
 285 
 286 
 287 // Get the current base window style (either GWL_STYLE or GWL_EXSTYLE)
 288 
 289 HRESULT CBaseControlWindow::DoGetWindowStyle(__out long *pStyle,long WindowLong)
 290 {
 291     *pStyle = GetWindowLong(m_hwnd,WindowLong);
 292     return NOERROR;
 293 }
 294 
 295 
 296 // Change the visibility of the base window, this takes the same parameters
 297 // as the ShowWindow Win32 API does, so the client can have the window hidden
 298 // or shown, minimised to an icon, or maximised to play in full screen mode
 299 // We pass the request on to the base window to actually make the change
 300 
 301 STDMETHODIMP CBaseControlWindow::put_WindowState(long WindowState)
 302 {
 303     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 304     DoShowWindow(WindowState);
 305     return NOERROR;
 306 }
 307 
 308 
 309 // Get the current window state, this function returns a subset of the SW bit
 310 // settings available in ShowWindow, if the window is visible then SW_SHOW is
 311 // set, if it is hidden then the SW_HIDDEN is set, if it is either minimised
 312 // or maximised then the SW_MINIMIZE or SW_MAXIMIZE is set respectively. The
 313 // other SW bit settings are really set commands not readable output values
 314 
 315 STDMETHODIMP CBaseControlWindow::get_WindowState(__out long *pWindowState)
 316 {
 317     CheckPointer(pWindowState,E_POINTER);
 318     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 319     ASSERT(pWindowState);
 320     *pWindowState = FALSE;
 321 
 322     // Is the window visible, a window is termed visible if it is somewhere on
 323     // the current desktop even if it is completely obscured by other windows
 324     // so the flag is a style for each window set with the WS_VISIBLE bit
 325 
 326     if (IsWindowVisible(m_hwnd) == TRUE) {
 327 
 328         // Is the base window iconic
 329         if (IsIconic(m_hwnd) == TRUE) {
 330             *pWindowState |= SW_MINIMIZE;
 331         }
 332 
 333         // Has the window been maximised
 334         else if (IsZoomed(m_hwnd) == TRUE) {
 335             *pWindowState |= SW_MAXIMIZE;
 336         }
 337 
 338         // Window is normal
 339         else {
 340             *pWindowState |= SW_SHOW;
 341         }
 342 
 343     } else {
 344         *pWindowState |= SW_HIDE;
 345     }
 346     return NOERROR;
 347 }
 348 
 349 
 350 // This makes sure that any palette we realise in the base window (through a
 351 // media type or through the overlay interface) is done in the background and
 352 // is therefore mapped to existing device entries rather than taking it over
 353 // as it will do when we this window gets the keyboard focus. An application
 354 // uses this to make sure it doesn&#39;t have it&#39;s palette removed by the window
 355 
 356 STDMETHODIMP CBaseControlWindow::put_BackgroundPalette(long BackgroundPalette)
 357 {
 358     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 359     CAutoLock cWindowLock(&amp;m_WindowLock);
 360 
 361     // Check this is a valid automation boolean type
 362 
 363     if (BackgroundPalette != OATRUE) {
 364         if (BackgroundPalette != OAFALSE) {
 365             return E_INVALIDARG;
 366         }
 367     }
 368 
 369     // Make sure the window realises any palette it has again
 370 
 371     m_bBackground = (BackgroundPalette == OATRUE ? TRUE : FALSE);
 372     PostMessage(m_hwnd,m_RealizePalette,0,0);
 373     PaintWindow(FALSE);
 374 
 375     return NOERROR;
 376 }
 377 
 378 
 379 // This returns the current background realisation setting
 380 
 381 STDMETHODIMP
 382 CBaseControlWindow::get_BackgroundPalette(__out long *pBackgroundPalette)
 383 {
 384     CheckPointer(pBackgroundPalette,E_POINTER);
 385     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 386     CAutoLock cWindowLock(&amp;m_WindowLock);
 387 
 388     // Get the current background palette setting
 389 
 390     *pBackgroundPalette = (m_bBackground == TRUE ? OATRUE : OAFALSE);
 391     return NOERROR;
 392 }
 393 
 394 
 395 // Change the visibility of the base window
 396 
 397 STDMETHODIMP CBaseControlWindow::put_Visible(long Visible)
 398 {
 399     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 400 
 401     // Check this is a valid automation boolean type
 402 
 403     if (Visible != OATRUE) {
 404         if (Visible != OAFALSE) {
 405             return E_INVALIDARG;
 406         }
 407     }
 408 
 409     // Convert the boolean visibility into SW_SHOW and SW_HIDE
 410 
 411     INT Mode = (Visible == OATRUE ? SW_SHOWNORMAL : SW_HIDE);
 412     DoShowWindow(Mode);
 413     return NOERROR;
 414 }
 415 
 416 
 417 // Return OATRUE if the window is currently visible otherwise OAFALSE
 418 
 419 STDMETHODIMP CBaseControlWindow::get_Visible(__out long *pVisible)
 420 {
 421     CheckPointer(pVisible,E_POINTER);
 422     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 423 
 424     // See if the base window has a WS_VISIBLE style - this will return TRUE
 425     // even if the window is completely obscured by other desktop windows, we
 426     // return FALSE if the window is not showing because of earlier calls
 427 
 428     BOOL Mode = IsWindowVisible(m_hwnd);
 429     *pVisible = (Mode == TRUE ? OATRUE : OAFALSE);
 430     return NOERROR;
 431 }
 432 
 433 
 434 // Change the left position of the base window. This keeps the window width
 435 // and height properties the same so it effectively shunts the window left or
 436 // right accordingly - there is the Width property to change that dimension
 437 
 438 STDMETHODIMP CBaseControlWindow::put_Left(long Left)
 439 {
 440     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 441     BOOL bSuccess;
 442     RECT WindowRect;
 443 
 444     // Get the current window position in a RECT
 445     EXECUTE_ASSERT(GetWindowRect(m_hwnd,&amp;WindowRect));
 446 
 447     if (GetParent(m_hwnd)) {
 448 
 449         MapWindowPoints(HWND_DESKTOP, GetParent(m_hwnd), (LPPOINT)&amp;WindowRect, 2);
 450     }
 451 
 452     // Adjust the coordinates ready for SetWindowPos, the window rectangle we
 453     // get back from GetWindowRect is in left,top,right and bottom while the
 454     // coordinates SetWindowPos wants are left,top,width and height values
 455 
 456     WindowRect.bottom = WindowRect.bottom - WindowRect.top;
 457     WindowRect.right = WindowRect.right - WindowRect.left;
 458     UINT WindowFlags = SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE;
 459 
 460     bSuccess = SetWindowPos(m_hwnd,                // Window handle
 461                             HWND_TOP,              // Put it at the top
 462                             Left,                  // New left position
 463                             WindowRect.top,        // Leave top alone
 464                             WindowRect.right,      // The WIDTH (not right)
 465                             WindowRect.bottom,     // The HEIGHT (not bottom)
 466                             WindowFlags);          // Show window options
 467 
 468     if (bSuccess == FALSE) {
 469         return E_INVALIDARG;
 470     }
 471     return NOERROR;
 472 }
 473 
 474 
 475 // Return the current base window left position
 476 
 477 STDMETHODIMP CBaseControlWindow::get_Left(__out long *pLeft)
 478 {
 479     CheckPointer(pLeft,E_POINTER);
 480     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 481     RECT WindowRect;
 482 
 483     EXECUTE_ASSERT(GetWindowRect(m_hwnd,&amp;WindowRect));
 484     *pLeft = WindowRect.left;
 485     return NOERROR;
 486 }
 487 
 488 
 489 // Change the current width of the base window. This property complements the
 490 // left position property so we must keep the left edge constant and expand or
 491 // contract to the right, the alternative would be to change the left edge so
 492 // keeping the right edge constant but this is maybe a little more intuitive
 493 
 494 STDMETHODIMP CBaseControlWindow::put_Width(long Width)
 495 {
 496     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 497     BOOL bSuccess;
 498     RECT WindowRect;
 499 
 500     // Adjust the coordinates ready for SetWindowPos, the window rectangle we
 501     // get back from GetWindowRect is in left,top,right and bottom while the
 502     // coordinates SetWindowPos wants are left,top,width and height values
 503 
 504     EXECUTE_ASSERT(GetWindowRect(m_hwnd,&amp;WindowRect));
 505 
 506     if (GetParent(m_hwnd)) {
 507 
 508         MapWindowPoints(HWND_DESKTOP, GetParent(m_hwnd), (LPPOINT)&amp;WindowRect, 2);
 509     }
 510 
 511     WindowRect.bottom = WindowRect.bottom - WindowRect.top;
 512     UINT WindowFlags = SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE;
 513 
 514     // This seems to have a bug in that calling SetWindowPos on a window with
 515     // just the width changing causes it to ignore the width that you pass in
 516     // and sets it to a mimimum value of 110 pixels wide (Windows NT 3.51)
 517 
 518     bSuccess = SetWindowPos(m_hwnd,                // Window handle
 519                             HWND_TOP,              // Put it at the top
 520                             WindowRect.left,       // Leave left alone
 521                             WindowRect.top,        // Leave top alone
 522                             Width,                 // New WIDTH dimension
 523                             WindowRect.bottom,     // The HEIGHT (not bottom)
 524                             WindowFlags);          // Show window options
 525 
 526     if (bSuccess == FALSE) {
 527         return E_INVALIDARG;
 528     }
 529     return NOERROR;
 530 }
 531 
 532 
 533 // Return the current base window width
 534 
 535 STDMETHODIMP CBaseControlWindow::get_Width(__out long *pWidth)
 536 {
 537     CheckPointer(pWidth,E_POINTER);
 538     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 539     RECT WindowRect;
 540 
 541     EXECUTE_ASSERT(GetWindowRect(m_hwnd,&amp;WindowRect));
 542     *pWidth = WindowRect.right - WindowRect.left;
 543     return NOERROR;
 544 }
 545 
 546 
 547 // This allows the client program to change the top position for the window in
 548 // the same way that changing the left position does not affect the width of
 549 // the image so changing the top position does not affect the window height
 550 
 551 STDMETHODIMP CBaseControlWindow::put_Top(long Top)
 552 {
 553     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 554     BOOL bSuccess;
 555     RECT WindowRect;
 556 
 557     // Get the current window position in a RECT
 558     EXECUTE_ASSERT(GetWindowRect(m_hwnd,&amp;WindowRect));
 559 
 560     if (GetParent(m_hwnd)) {
 561 
 562         MapWindowPoints(HWND_DESKTOP, GetParent(m_hwnd), (LPPOINT)&amp;WindowRect, 2);
 563     }
 564 
 565     // Adjust the coordinates ready for SetWindowPos, the window rectangle we
 566     // get back from GetWindowRect is in left,top,right and bottom while the
 567     // coordinates SetWindowPos wants are left,top,width and height values
 568 
 569     WindowRect.bottom = WindowRect.bottom - WindowRect.top;
 570     WindowRect.right = WindowRect.right - WindowRect.left;
 571     UINT WindowFlags = SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE;
 572 
 573     bSuccess = SetWindowPos(m_hwnd,                // Window handle
 574                             HWND_TOP,              // Put it at the top
 575                             WindowRect.left,       // Leave left alone
 576                             Top,                   // New top position
 577                             WindowRect.right,      // The WIDTH (not right)
 578                             WindowRect.bottom,     // The HEIGHT (not bottom)
 579                             WindowFlags);          // Show window flags
 580 
 581     if (bSuccess == FALSE) {
 582         return E_INVALIDARG;
 583     }
 584     return NOERROR;
 585 }
 586 
 587 
 588 // Return the current base window top position
 589 
 590 STDMETHODIMP CBaseControlWindow::get_Top(long *pTop)
 591 {
 592     CheckPointer(pTop,E_POINTER);
 593     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 594     RECT WindowRect;
 595 
 596     EXECUTE_ASSERT(GetWindowRect(m_hwnd,&amp;WindowRect));
 597     *pTop = WindowRect.top;
 598     return NOERROR;
 599 }
 600 
 601 
 602 // Change the height of the window, this complements the top property so when
 603 // we change this we must keep the top position for the base window, as said
 604 // before we could keep the bottom and grow upwards although this is perhaps
 605 // a little more intuitive since we already have a top position property
 606 
 607 STDMETHODIMP CBaseControlWindow::put_Height(long Height)
 608 {
 609     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 610     BOOL bSuccess;
 611     RECT WindowRect;
 612 
 613     // Adjust the coordinates ready for SetWindowPos, the window rectangle we
 614     // get back from GetWindowRect is in left,top,right and bottom while the
 615     // coordinates SetWindowPos wants are left,top,width and height values
 616 
 617     EXECUTE_ASSERT(GetWindowRect(m_hwnd,&amp;WindowRect));
 618 
 619     if (GetParent(m_hwnd)) {
 620 
 621         MapWindowPoints(HWND_DESKTOP, GetParent(m_hwnd), (LPPOINT)&amp;WindowRect, 2);
 622     }
 623 
 624     WindowRect.right = WindowRect.right - WindowRect.left;
 625     UINT WindowFlags = SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE;
 626 
 627     bSuccess = SetWindowPos(m_hwnd,                // Window handle
 628                             HWND_TOP,              // Put it at the top
 629                             WindowRect.left,       // Leave left alone
 630                             WindowRect.top,        // Leave top alone
 631                             WindowRect.right,      // The WIDTH (not right)
 632                             Height,                // New height dimension
 633                             WindowFlags);          // Show window flags
 634 
 635     if (bSuccess == FALSE) {
 636         return E_INVALIDARG;
 637     }
 638     return NOERROR;
 639 }
 640 
 641 
 642 // Return the current base window height
 643 
 644 STDMETHODIMP CBaseControlWindow::get_Height(__out long *pHeight)
 645 {
 646     CheckPointer(pHeight,E_POINTER);
 647     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 648     RECT WindowRect;
 649 
 650     EXECUTE_ASSERT(GetWindowRect(m_hwnd,&amp;WindowRect));
 651     *pHeight = WindowRect.bottom - WindowRect.top;
 652     return NOERROR;
 653 }
 654 
 655 
 656 // This can be called to change the owning window. Setting the owner is done
 657 // through this function, however to make the window a true child window the
 658 // style must also be set to WS_CHILD. After resetting the owner to NULL an
 659 // application should also set the style to WS_OVERLAPPED | WS_CLIPCHILDREN.
 660 
 661 // We cannot lock the object here because the SetParent causes an interthread
 662 // SendMessage to the owner window. If they are in GetState we will sit here
 663 // incomplete with the critical section locked therefore blocking out source
 664 // filter threads from accessing us. Because the source thread can&#39;t enter us
 665 // it can&#39;t get buffers or call EndOfStream so the GetState will not complete
 666 
 667 STDMETHODIMP CBaseControlWindow::put_Owner(OAHWND Owner)
 668 {
 669     // Check we are connected otherwise reject the call
 670 
 671     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 672     m_hwndOwner = (HWND) Owner;
 673     HWND hwndParent = m_hwndOwner;
 674 
 675     // Add or remove WS_CHILD as appropriate
 676 
 677     LONG Style = GetWindowLong(m_hwnd,GWL_STYLE);
 678     if (Owner == NULL) {
 679         Style &amp;= (~WS_CHILD);
 680     } else {
 681         Style |= (WS_CHILD);
 682     }
 683     SetWindowLong(m_hwnd,GWL_STYLE,Style);
 684 
 685     // Don&#39;t call this with the filter locked
 686 
 687     SetParent(m_hwnd,hwndParent);
 688 
 689     PaintWindow(TRUE);
 690     NOTE1(&quot;Changed parent %lx&quot;,hwndParent);
 691 
 692     return NOERROR;
 693 }
 694 
 695 
 696 // This complements the put_Owner to get the current owning window property
 697 // we always return NOERROR although the returned window handle may be NULL
 698 // to indicate no owning window (the desktop window doesn&#39;t qualify as one)
 699 // If an application sets the owner we call SetParent, however that returns
 700 // NULL until the WS_CHILD bit is set on, so we store the owner internally
 701 
 702 STDMETHODIMP CBaseControlWindow::get_Owner(__out OAHWND *Owner)
 703 {
 704     CheckPointer(Owner,E_POINTER);
 705     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 706     *Owner = (OAHWND) m_hwndOwner;
 707     return NOERROR;
 708 }
 709 
 710 
 711 // And renderer supporting IVideoWindow may have an HWND set who will get any
 712 // keyboard and mouse messages we receive posted on to them. This is separate
 713 // from setting an owning window. By separating the two, applications may get
 714 // messages sent on even when they have set no owner (perhaps it&#39;s maximised)
 715 
 716 STDMETHODIMP CBaseControlWindow::put_MessageDrain(OAHWND Drain)
 717 {
 718     // Check we are connected otherwise reject the call
 719 
 720     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 721     m_hwndDrain = (HWND) Drain;
 722     return NOERROR;
 723 }
 724 
 725 
 726 // Return the current message drain
 727 
 728 STDMETHODIMP CBaseControlWindow::get_MessageDrain(__out OAHWND *Drain)
 729 {
 730     CheckPointer(Drain,E_POINTER);
 731     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 732     *Drain = (OAHWND) m_hwndDrain;
 733     return NOERROR;
 734 }
 735 
 736 
 737 // This is called by the filter graph to inform us of a message we should know
 738 // is being sent to our owning window. We have this because as a child window
 739 // we do not get certain messages that are only sent to top level windows. We
 740 // must see the palette changed/changing/query messages so that we know if we
 741 // have the foreground palette or not. We pass the message on to our window
 742 // using SendMessage - this will cause an interthread send message to occur
 743 
 744 STDMETHODIMP
 745 CBaseControlWindow::NotifyOwnerMessage(OAHWND hwnd,    // Window handle
 746                                        long uMsg,    // Message ID
 747                                        LONG_PTR wParam,  // Parameters
 748                                        LONG_PTR lParam)  // for message
 749 {
 750     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 751 
 752     // Only interested in these Windows messages
 753 
 754     switch (uMsg) {
 755 
 756         case WM_SYSCOLORCHANGE:
 757         case WM_PALETTECHANGED:
 758         case WM_PALETTEISCHANGING:
 759         case WM_QUERYNEWPALETTE:
 760         case WM_DEVMODECHANGE:
 761         case WM_DISPLAYCHANGE:
 762         case WM_ACTIVATEAPP:
 763 
 764             // If we do not have an owner then ignore
 765 
 766             if (m_hwndOwner == NULL) {
 767                 return NOERROR;
 768             }
 769             SendMessage(m_hwnd,uMsg,(WPARAM)wParam,(LPARAM)lParam);
 770         break;
 771 
 772     // do NOT fwd WM_MOVE. the parameters are the location of the parent
 773     // window, NOT what the renderer should be looking at.  But we need
 774     // to make sure the overlay is moved with the parent window, so we
 775     // do this.
 776     case WM_MOVE:
 777         PostMessage(m_hwnd,WM_PAINT,0,0);
 778         break;
 779     }
 780     return NOERROR;
 781 }
 782 
 783 
 784 // Allow an application to have us set the base window in the foreground. We
 785 // have this because it is difficult for one thread to do do this to a window
 786 // owned by another thread. We ask the base window class to do the real work
 787 
 788 STDMETHODIMP CBaseControlWindow::SetWindowForeground(long Focus)
 789 {
 790     // Check this is a valid automation boolean type
 791 
 792     if (Focus != OATRUE) {
 793         if (Focus != OAFALSE) {
 794             return E_INVALIDARG;
 795         }
 796     }
 797 
 798     // We shouldn&#39;t lock as this sends a message
 799 
 800     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 801     BOOL bFocus = (Focus == OATRUE ? TRUE : FALSE);
 802     DoSetWindowForeground(bFocus);
 803 
 804     return NOERROR;
 805 }
 806 
 807 
 808 // This allows a client to set the complete window size and position in one
 809 // atomic operation. The same affect can be had by changing each dimension
 810 // in turn through their individual properties although some flashing will
 811 // occur as each of them gets updated (they are better set at design time)
 812 
 813 STDMETHODIMP
 814 CBaseControlWindow::SetWindowPosition(long Left,long Top,long Width,long Height)
 815 {
 816     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 817     BOOL bSuccess;
 818 
 819     // Set the new size and position
 820     UINT WindowFlags = SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE;
 821 
 822     ASSERT(IsWindow(m_hwnd));
 823     bSuccess = SetWindowPos(m_hwnd,         // Window handle
 824                             HWND_TOP,       // Put it at the top
 825                             Left,           // Left position
 826                             Top,            // Top position
 827                             Width,          // Window width
 828                             Height,         // Window height
 829                             WindowFlags);   // Show window flags
 830     ASSERT(bSuccess);
 831 #ifdef DEBUG
 832     DbgLog((LOG_TRACE, 1, TEXT(&quot;SWP failed error %d&quot;), GetLastError()));
 833 #endif
 834     if (bSuccess == FALSE) {
 835         return E_INVALIDARG;
 836     }
 837     return NOERROR;
 838 }
 839 
 840 
 841 // This complements the SetWindowPosition to return the current window place
 842 // in device coordinates. As before the same information can be retrived by
 843 // calling the property get functions individually but this is atomic and is
 844 // therefore more suitable to a live environment rather than design time
 845 
 846 STDMETHODIMP
 847 CBaseControlWindow::GetWindowPosition(__out long *pLeft,__out long *pTop,__out long *pWidth,__out long *pHeight)
 848 {
 849     // Should check the pointers are not NULL
 850 
 851     CheckPointer(pLeft,E_POINTER);
 852     CheckPointer(pTop,E_POINTER);
 853     CheckPointer(pWidth,E_POINTER);
 854     CheckPointer(pHeight,E_POINTER);
 855     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 856     RECT WindowRect;
 857 
 858     // Get the current window coordinates
 859 
 860     EXECUTE_ASSERT(GetWindowRect(m_hwnd,&amp;WindowRect));
 861 
 862     // Convert the RECT into left,top,width and height values
 863 
 864     *pLeft = WindowRect.left;
 865     *pTop = WindowRect.top;
 866     *pWidth = WindowRect.right - WindowRect.left;
 867     *pHeight = WindowRect.bottom - WindowRect.top;
 868 
 869     return NOERROR;
 870 }
 871 
 872 
 873 // When a window is maximised or iconic calling GetWindowPosition will return
 874 // the current window position (likewise for the properties). However if the
 875 // restored size (ie the size we&#39;ll return to when normally shown) is needed
 876 // then this should be used. When in a normal position (neither iconic nor
 877 // maximised) then this returns the same coordinates as GetWindowPosition
 878 
 879 STDMETHODIMP
 880 CBaseControlWindow::GetRestorePosition(__out long *pLeft,__out long *pTop,__out long *pWidth,__out long *pHeight)
 881 {
 882     // Should check the pointers are not NULL
 883 
 884     CheckPointer(pLeft,E_POINTER);
 885     CheckPointer(pTop,E_POINTER);
 886     CheckPointer(pWidth,E_POINTER);
 887     CheckPointer(pHeight,E_POINTER);
 888     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 889 
 890     // Use GetWindowPlacement to find the restore position
 891 
 892     WINDOWPLACEMENT Place;
 893     Place.length = sizeof(WINDOWPLACEMENT);
 894     EXECUTE_ASSERT(GetWindowPlacement(m_hwnd,&amp;Place));
 895 
 896     RECT WorkArea;
 897 
 898     // We must take into account any task bar present
 899 
 900     if (SystemParametersInfo(SPI_GETWORKAREA,0,&amp;WorkArea,FALSE) == TRUE) {
 901         if (GetParent(m_hwnd) == NULL) {
 902             Place.rcNormalPosition.top += WorkArea.top;
 903             Place.rcNormalPosition.bottom += WorkArea.top;
 904             Place.rcNormalPosition.left += WorkArea.left;
 905             Place.rcNormalPosition.right += WorkArea.left;
 906         }
 907     }
 908 
 909     // Convert the RECT into left,top,width and height values
 910 
 911     *pLeft = Place.rcNormalPosition.left;
 912     *pTop = Place.rcNormalPosition.top;
 913     *pWidth = Place.rcNormalPosition.right - Place.rcNormalPosition.left;
 914     *pHeight = Place.rcNormalPosition.bottom - Place.rcNormalPosition.top;
 915 
 916     return NOERROR;
 917 }
 918 
 919 
 920 // Return the current border colour, if we are playing something to a subset
 921 // of the base window display there is an outside area exposed. The default
 922 // action is to paint this colour in the Windows background colour (defined
 923 // as value COLOR_WINDOW) We reset to this default when we&#39;re disconnected
 924 
 925 STDMETHODIMP CBaseControlWindow::get_BorderColor(__out long *Color)
 926 {
 927     CheckPointer(Color,E_POINTER);
 928     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 929     *Color = (long) m_BorderColour;
 930     return NOERROR;
 931 }
 932 
 933 
 934 // This can be called to set the current border colour
 935 
 936 STDMETHODIMP CBaseControlWindow::put_BorderColor(long Color)
 937 {
 938     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 939 
 940     // Have the window repainted with the new border colour
 941 
 942     m_BorderColour = (COLORREF) Color;
 943     PaintWindow(TRUE);
 944     return NOERROR;
 945 }
 946 
 947 
 948 // Delegate fullscreen handling to plug in distributor
 949 
 950 STDMETHODIMP CBaseControlWindow::get_FullScreenMode(__out long *FullScreenMode)
 951 {
 952     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 953     CheckPointer(FullScreenMode,E_POINTER);
 954     return E_NOTIMPL;
 955 }
 956 
 957 
 958 // Delegate fullscreen handling to plug in distributor
 959 
 960 STDMETHODIMP CBaseControlWindow::put_FullScreenMode(long FullScreenMode)
 961 {
 962     return E_NOTIMPL;
 963 }
 964 
 965 
 966 // This sets the auto show property, this property causes the base window to
 967 // be displayed whenever we change state. This allows an application to have
 968 // to do nothing to have the window appear but still allow them to change the
 969 // default behaviour if for example they want to keep it hidden for longer
 970 
 971 STDMETHODIMP CBaseControlWindow::put_AutoShow(long AutoShow)
 972 {
 973     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 974 
 975     // Check this is a valid automation boolean type
 976 
 977     if (AutoShow != OATRUE) {
 978         if (AutoShow != OAFALSE) {
 979             return E_INVALIDARG;
 980         }
 981     }
 982 
 983     m_bAutoShow = (AutoShow == OATRUE ? TRUE : FALSE);
 984     return NOERROR;
 985 }
 986 
 987 
 988 // This can be called to get the current auto show flag. The flag is updated
 989 // when we connect and disconnect and through this interface all of which are
 990 // controlled and serialised by means of the main renderer critical section
 991 
 992 STDMETHODIMP CBaseControlWindow::get_AutoShow(__out long *AutoShow)
 993 {
 994     CheckPointer(AutoShow,E_POINTER);
 995     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
 996     *AutoShow = (m_bAutoShow == TRUE ? OATRUE : OAFALSE);
 997     return NOERROR;
 998 }
 999 
1000 
1001 // Return the minimum ideal image size for the current video. This may differ
1002 // to the actual video dimensions because we may be using DirectDraw hardware
1003 // that has specific stretching requirements. For example the Cirrus Logic
1004 // cards have a minimum stretch factor depending on the overlay surface size
1005 
1006 STDMETHODIMP
1007 CBaseControlWindow::GetMinIdealImageSize(__out long *pWidth,__out long *pHeight)
1008 {
1009     CheckPointer(pWidth,E_POINTER);
1010     CheckPointer(pHeight,E_POINTER);
1011     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1012     FILTER_STATE State;
1013 
1014     // Must not be stopped for this to work correctly
1015 
1016     m_pFilter-&gt;GetState(0,&amp;State);
1017     if (State == State_Stopped) {
1018         return VFW_E_WRONG_STATE;
1019     }
1020 
1021     RECT DefaultRect = GetDefaultRect();
1022     *pWidth = WIDTH(&amp;DefaultRect);
1023     *pHeight = HEIGHT(&amp;DefaultRect);
1024     return NOERROR;
1025 }
1026 
1027 
1028 // Return the maximum ideal image size for the current video. This may differ
1029 // to the actual video dimensions because we may be using DirectDraw hardware
1030 // that has specific stretching requirements. For example the Cirrus Logic
1031 // cards have a maximum stretch factor depending on the overlay surface size
1032 
1033 STDMETHODIMP
1034 CBaseControlWindow::GetMaxIdealImageSize(__out long *pWidth,__out long *pHeight)
1035 {
1036     CheckPointer(pWidth,E_POINTER);
1037     CheckPointer(pHeight,E_POINTER);
1038     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1039     FILTER_STATE State;
1040 
1041     // Must not be stopped for this to work correctly
1042 
1043     m_pFilter-&gt;GetState(0,&amp;State);
1044     if (State == State_Stopped) {
1045         return VFW_E_WRONG_STATE;
1046     }
1047 
1048     RECT DefaultRect = GetDefaultRect();
1049     *pWidth = WIDTH(&amp;DefaultRect);
1050     *pHeight = HEIGHT(&amp;DefaultRect);
1051     return NOERROR;
1052 }
1053 
1054 
1055 // Allow an application to hide the cursor on our window
1056 
1057 STDMETHODIMP
1058 CBaseControlWindow::HideCursor(long HideCursor)
1059 {
1060     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1061 
1062     // Check this is a valid automation boolean type
1063 
1064     if (HideCursor != OATRUE) {
1065         if (HideCursor != OAFALSE) {
1066             return E_INVALIDARG;
1067         }
1068     }
1069 
1070     m_bCursorHidden = (HideCursor == OATRUE ? TRUE : FALSE);
1071     return NOERROR;
1072 }
1073 
1074 
1075 // Returns whether we have the cursor hidden or not
1076 
1077 STDMETHODIMP CBaseControlWindow::IsCursorHidden(__out long *CursorHidden)
1078 {
1079     CheckPointer(CursorHidden,E_POINTER);
1080     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1081     *CursorHidden = (m_bCursorHidden == TRUE ? OATRUE : OAFALSE);
1082     return NOERROR;
1083 }
1084 
1085 
1086 // This class implements the IBasicVideo control functions (dual interface)
1087 // we support a large number of properties and methods designed to allow the
1088 // client (whether it be an automation controller or a C/C++ application) to
1089 // set and get a number of video related properties such as the native video
1090 // size. We support some methods that duplicate the properties but provide a
1091 // more direct and efficient mechanism as many values may be changed in one
1092 
1093 CBaseControlVideo::CBaseControlVideo(
1094                         __inout CBaseFilter *pFilter,     // Owning filter
1095                         __in CCritSec *pInterfaceLock,    // Locking object
1096                         __in_opt LPCTSTR pName,           // Object description
1097                         __inout_opt LPUNKNOWN pUnk,       // Normal COM ownership
1098                         __inout HRESULT *phr) :           // OLE return code
1099 
1100     CBaseBasicVideo(pName,pUnk),
1101     m_pFilter(pFilter),
1102     m_pInterfaceLock(pInterfaceLock),
1103     m_pPin(NULL)
1104 {
1105     ASSERT(m_pFilter);
1106     ASSERT(m_pInterfaceLock);
1107     ASSERT(phr);
1108 }
1109 
1110 // Return an approximate average time per frame
1111 
1112 STDMETHODIMP CBaseControlVideo::get_AvgTimePerFrame(__out REFTIME *pAvgTimePerFrame)
1113 {
1114     CheckPointer(pAvgTimePerFrame,E_POINTER);
1115     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1116     CAutoLock cInterfaceLock(m_pInterfaceLock);
1117 
1118     VIDEOINFOHEADER *pVideoInfo = GetVideoFormat();
1119     if (pVideoInfo == NULL)
1120     return E_OUTOFMEMORY;
1121     COARefTime AvgTime(pVideoInfo-&gt;AvgTimePerFrame);
1122     *pAvgTimePerFrame = (REFTIME) AvgTime;
1123 
1124     return NOERROR;
1125 }
1126 
1127 
1128 // Return an approximate bit rate for the video
1129 
1130 STDMETHODIMP CBaseControlVideo::get_BitRate(__out long *pBitRate)
1131 {
1132     CheckPointer(pBitRate,E_POINTER);
1133     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1134     CAutoLock cInterfaceLock(m_pInterfaceLock);
1135 
1136     VIDEOINFOHEADER *pVideoInfo = GetVideoFormat();
1137     if (pVideoInfo == NULL)
1138     return E_OUTOFMEMORY;
1139     *pBitRate = pVideoInfo-&gt;dwBitRate;
1140     return NOERROR;
1141 }
1142 
1143 
1144 // Return an approximate bit error rate
1145 
1146 STDMETHODIMP CBaseControlVideo::get_BitErrorRate(__out long *pBitErrorRate)
1147 {
1148     CheckPointer(pBitErrorRate,E_POINTER);
1149     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1150     CAutoLock cInterfaceLock(m_pInterfaceLock);
1151 
1152     VIDEOINFOHEADER *pVideoInfo = GetVideoFormat();
1153     if (pVideoInfo == NULL)
1154     return E_OUTOFMEMORY;
1155     *pBitErrorRate = pVideoInfo-&gt;dwBitErrorRate;
1156     return NOERROR;
1157 }
1158 
1159 
1160 // This returns the current video width
1161 
1162 STDMETHODIMP CBaseControlVideo::get_VideoWidth(__out long *pVideoWidth)
1163 {
1164     CheckPointer(pVideoWidth,E_POINTER);
1165     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1166     CAutoLock cInterfaceLock(m_pInterfaceLock);
1167 
1168     VIDEOINFOHEADER *pVideoInfo = GetVideoFormat();
1169     if (pVideoInfo == NULL)
1170     return E_OUTOFMEMORY;
1171     *pVideoWidth = pVideoInfo-&gt;bmiHeader.biWidth;
1172     return NOERROR;
1173 }
1174 
1175 
1176 // This returns the current video height
1177 
1178 STDMETHODIMP CBaseControlVideo::get_VideoHeight(__out long *pVideoHeight)
1179 {
1180     CheckPointer(pVideoHeight,E_POINTER);
1181     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1182     CAutoLock cInterfaceLock(m_pInterfaceLock);
1183 
1184     VIDEOINFOHEADER *pVideoInfo = GetVideoFormat();
1185     if (pVideoInfo == NULL)
1186     return E_OUTOFMEMORY;
1187     *pVideoHeight = pVideoInfo-&gt;bmiHeader.biHeight;
1188     return NOERROR;
1189 }
1190 
1191 
1192 // This returns the current palette the video is using as an array allocated
1193 // by the user. To remain consistent we use PALETTEENTRY fields to return the
1194 // colours in rather than RGBQUADs that multimedia decided to use. The memory
1195 // is allocated by the user so we simple copy each in turn. We check that the
1196 // number of entries requested and the start position offset are both valid
1197 // If the number of entries evaluates to zero then we return an S_FALSE code
1198 
1199 STDMETHODIMP CBaseControlVideo::GetVideoPaletteEntries(long StartIndex,
1200                                                        long Entries,
1201                                                        __out long *pRetrieved,
1202                                                        __out_ecount_part(Entries, *pRetrieved) long *pPalette)
1203 {
1204     CheckPointer(pRetrieved,E_POINTER);
1205     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1206     CAutoLock cInterfaceLock(m_pInterfaceLock);
1207     CMediaType MediaType;
1208 
1209     // Get the video format from the derived class
1210 
1211     VIDEOINFOHEADER *pVideoInfo = GetVideoFormat();
1212     if (pVideoInfo == NULL)
1213     return E_OUTOFMEMORY;
1214     BITMAPINFOHEADER *pHeader = HEADER(pVideoInfo);
1215 
1216     // Is the current format palettised
1217 
1218     if (PALETTISED(pVideoInfo) == FALSE) {
1219         *pRetrieved = 0;
1220         return VFW_E_NO_PALETTE_AVAILABLE;
1221     }
1222 
1223     // Do they just want to know how many are available
1224 
1225     if (pPalette == NULL) {
1226         *pRetrieved = pHeader-&gt;biClrUsed;
1227         return NOERROR;
1228     }
1229 
1230     // Make sure the start position is a valid offset
1231 
1232     if (StartIndex &gt;= (LONG) pHeader-&gt;biClrUsed || StartIndex &lt; 0) {
1233         *pRetrieved = 0;
1234         return E_INVALIDARG;
1235     }
1236 
1237     // Correct the number we can retrieve
1238 
1239     LONG Available = (LONG) pHeader-&gt;biClrUsed - StartIndex;
1240     *pRetrieved = max(0,min(Available,Entries));
1241     if (*pRetrieved == 0) {
1242         return S_FALSE;
1243     }
1244 
1245     // Copy the palette entries to the output buffer
1246 
1247     PALETTEENTRY *pEntries = (PALETTEENTRY *) pPalette;
1248     RGBQUAD *pColours = COLORS(pVideoInfo) + StartIndex;
1249 
1250     for (LONG Count = 0;Count &lt; *pRetrieved;Count++) {
1251         pEntries[Count].peRed = pColours[Count].rgbRed;
1252         pEntries[Count].peGreen = pColours[Count].rgbGreen;
1253         pEntries[Count].peBlue = pColours[Count].rgbBlue;
1254         pEntries[Count].peFlags = 0;
1255     }
1256     return NOERROR;
1257 }
1258 
1259 
1260 // This returns the current video dimensions as a method rather than a number
1261 // of individual property get calls. For the same reasons as said before we
1262 // cannot access the renderer media type directly as the window object thread
1263 // may be updating it since dynamic format changes may change these values
1264 
1265 STDMETHODIMP CBaseControlVideo::GetVideoSize(__out long *pWidth,__out long *pHeight)
1266 {
1267     CheckPointer(pWidth,E_POINTER);
1268     CheckPointer(pHeight,E_POINTER);
1269     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1270     CAutoLock cInterfaceLock(m_pInterfaceLock);
1271 
1272     // Get the video format from the derived class
1273     VIDEOINFOHEADER *pVideoInfo = GetVideoFormat();
1274     if (pVideoInfo == NULL)
1275     return E_OUTOFMEMORY;
1276     *pWidth = pVideoInfo-&gt;bmiHeader.biWidth;
1277     *pHeight = pVideoInfo-&gt;bmiHeader.biHeight;
1278     return NOERROR;
1279 }
1280 
1281 
1282 // Set the source video rectangle as left,top,right and bottom coordinates
1283 // rather than left,top,width and height as per OLE automation interfaces
1284 // Then pass the rectangle on to the window object to set the source
1285 
1286 STDMETHODIMP
1287 CBaseControlVideo::SetSourcePosition(long Left,long Top,long Width,long Height)
1288 {
1289     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1290     CAutoLock cInterfaceLock(m_pInterfaceLock);
1291     RECT SourceRect;
1292     SourceRect.left = Left;
1293     SourceRect.top = Top;
1294     SourceRect.right = Left + Width;
1295     SourceRect.bottom = Top + Height;
1296 
1297     // Check the source rectangle is valid
1298 
1299     HRESULT hr = CheckSourceRect(&amp;SourceRect);
1300     if (FAILED(hr)) {
1301         return hr;
1302     }
1303 
1304     // Now set the source rectangle
1305 
1306     hr = SetSourceRect(&amp;SourceRect);
1307     if (FAILED(hr)) {
1308         return hr;
1309     }
1310     return OnUpdateRectangles();
1311 }
1312 
1313 
1314 // Return the source rectangle in left,top,width and height rather than the
1315 // left,top,right and bottom values that RECT uses (and which the window
1316 // object returns through GetSourceRect) which requires a little work
1317 
1318 STDMETHODIMP
1319 CBaseControlVideo::GetSourcePosition(__out long *pLeft,__out long *pTop,__out long *pWidth,__out long *pHeight)
1320 {
1321     // Should check the pointers are non NULL
1322 
1323     CheckPointer(pLeft,E_POINTER);
1324     CheckPointer(pTop,E_POINTER);
1325     CheckPointer(pWidth,E_POINTER);
1326     CheckPointer(pHeight,E_POINTER);
1327     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1328     RECT SourceRect;
1329 
1330     CAutoLock cInterfaceLock(m_pInterfaceLock);
1331     GetSourceRect(&amp;SourceRect);
1332 
1333     *pLeft = SourceRect.left;
1334     *pTop = SourceRect.top;
1335     *pWidth = WIDTH(&amp;SourceRect);
1336     *pHeight = HEIGHT(&amp;SourceRect);
1337 
1338     return NOERROR;
1339 }
1340 
1341 
1342 // Set the video destination as left,top,right and bottom coordinates rather
1343 // than the left,top,width and height uses as per OLE automation interfaces
1344 // Then pass the rectangle on to the window object to set the destination
1345 
1346 STDMETHODIMP
1347 CBaseControlVideo::SetDestinationPosition(long Left,long Top,long Width,long Height)
1348 {
1349     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1350     CAutoLock cInterfaceLock(m_pInterfaceLock);
1351     RECT DestinationRect;
1352 
1353     DestinationRect.left = Left;
1354     DestinationRect.top = Top;
1355     DestinationRect.right = Left + Width;
1356     DestinationRect.bottom = Top + Height;
1357 
1358     // Check the target rectangle is valid
1359 
1360     HRESULT hr = CheckTargetRect(&amp;DestinationRect);
1361     if (FAILED(hr)) {
1362         return hr;
1363     }
1364 
1365     // Now set the new target rectangle
1366 
1367     hr = SetTargetRect(&amp;DestinationRect);
1368     if (FAILED(hr)) {
1369         return hr;
1370     }
1371     return OnUpdateRectangles();
1372 }
1373 
1374 
1375 // Return the destination rectangle in left,top,width and height rather than
1376 // the left,top,right and bottom values that RECT uses (and which the window
1377 // object returns through GetDestinationRect) which requires a little work
1378 
1379 STDMETHODIMP
1380 CBaseControlVideo::GetDestinationPosition(__out long *pLeft,__out long *pTop,__out long *pWidth,__out long *pHeight)
1381 {
1382     // Should check the pointers are not NULL
1383 
1384     CheckPointer(pLeft,E_POINTER);
1385     CheckPointer(pTop,E_POINTER);
1386     CheckPointer(pWidth,E_POINTER);
1387     CheckPointer(pHeight,E_POINTER);
1388     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1389     RECT DestinationRect;
1390 
1391     CAutoLock cInterfaceLock(m_pInterfaceLock);
1392     GetTargetRect(&amp;DestinationRect);
1393 
1394     *pLeft = DestinationRect.left;
1395     *pTop = DestinationRect.top;
1396     *pWidth = WIDTH(&amp;DestinationRect);
1397     *pHeight = HEIGHT(&amp;DestinationRect);
1398 
1399     return NOERROR;
1400 }
1401 
1402 
1403 // Set the source left position, the source rectangle we get back from the
1404 // window object is a true rectangle in left,top,right and bottom positions
1405 // so all we have to do is to update the left position and pass it back. We
1406 // must keep the current width constant when we&#39;re updating this property
1407 
1408 STDMETHODIMP CBaseControlVideo::put_SourceLeft(long SourceLeft)
1409 {
1410     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1411     CAutoLock cInterfaceLock(m_pInterfaceLock);
1412     RECT SourceRect;
1413     GetSourceRect(&amp;SourceRect);
1414     SourceRect.right = SourceLeft + WIDTH(&amp;SourceRect);
1415     SourceRect.left = SourceLeft;
1416 
1417     // Check the source rectangle is valid
1418 
1419     HRESULT hr = CheckSourceRect(&amp;SourceRect);
1420     if (FAILED(hr)) {
1421         return hr;
1422     }
1423 
1424     // Now set the source rectangle
1425 
1426     hr = SetSourceRect(&amp;SourceRect);
1427     if (FAILED(hr)) {
1428         return hr;
1429     }
1430     return OnUpdateRectangles();
1431 }
1432 
1433 
1434 // Return the current left source video position
1435 
1436 STDMETHODIMP CBaseControlVideo::get_SourceLeft(__out long *pSourceLeft)
1437 {
1438     CheckPointer(pSourceLeft,E_POINTER);
1439     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1440     CAutoLock cInterfaceLock(m_pInterfaceLock);
1441     RECT SourceRect;
1442 
1443     GetSourceRect(&amp;SourceRect);
1444     *pSourceLeft = SourceRect.left;
1445     return NOERROR;
1446 }
1447 
1448 
1449 // Set the source width, we get the current source rectangle and then update
1450 // the right position to be the left position (thereby keeping it constant)
1451 // plus the new source width we are passed in (it expands to the right)
1452 
1453 STDMETHODIMP CBaseControlVideo::put_SourceWidth(long SourceWidth)
1454 {
1455     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1456     CAutoLock cInterfaceLock(m_pInterfaceLock);
1457     RECT SourceRect;
1458     GetSourceRect(&amp;SourceRect);
1459     SourceRect.right = SourceRect.left + SourceWidth;
1460 
1461     // Check the source rectangle is valid
1462 
1463     HRESULT hr = CheckSourceRect(&amp;SourceRect);
1464     if (FAILED(hr)) {
1465         return hr;
1466     }
1467 
1468     // Now set the source rectangle
1469 
1470     hr = SetSourceRect(&amp;SourceRect);
1471     if (FAILED(hr)) {
1472         return hr;
1473     }
1474     return OnUpdateRectangles();
1475 }
1476 
1477 
1478 // Return the current source width
1479 
1480 STDMETHODIMP CBaseControlVideo::get_SourceWidth(__out long *pSourceWidth)
1481 {
1482     CheckPointer(pSourceWidth,E_POINTER);
1483     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1484     CAutoLock cInterfaceLock(m_pInterfaceLock);
1485     RECT SourceRect;
1486 
1487     GetSourceRect(&amp;SourceRect);
1488     *pSourceWidth = WIDTH(&amp;SourceRect);
1489     return NOERROR;
1490 }
1491 
1492 
1493 // Set the source top position - changing this property does not affect the
1494 // current source height. So changing this shunts the source rectangle up and
1495 // down appropriately. Changing the height complements this functionality by
1496 // keeping the top position constant and simply changing the source height
1497 
1498 STDMETHODIMP CBaseControlVideo::put_SourceTop(long SourceTop)
1499 {
1500     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1501     CAutoLock cInterfaceLock(m_pInterfaceLock);
1502     RECT SourceRect;
1503     GetSourceRect(&amp;SourceRect);
1504     SourceRect.bottom = SourceTop + HEIGHT(&amp;SourceRect);
1505     SourceRect.top = SourceTop;
1506 
1507     // Check the source rectangle is valid
1508 
1509     HRESULT hr = CheckSourceRect(&amp;SourceRect);
1510     if (FAILED(hr)) {
1511         return hr;
1512     }
1513 
1514     // Now set the source rectangle
1515 
1516     hr = SetSourceRect(&amp;SourceRect);
1517     if (FAILED(hr)) {
1518         return hr;
1519     }
1520     return OnUpdateRectangles();
1521 }
1522 
1523 
1524 // Return the current top position
1525 
1526 STDMETHODIMP CBaseControlVideo::get_SourceTop(__out long *pSourceTop)
1527 {
1528     CheckPointer(pSourceTop,E_POINTER);
1529     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1530     CAutoLock cInterfaceLock(m_pInterfaceLock);
1531     RECT SourceRect;
1532 
1533     GetSourceRect(&amp;SourceRect);
1534     *pSourceTop = SourceRect.top;
1535     return NOERROR;
1536 }
1537 
1538 
1539 // Set the source height
1540 
1541 STDMETHODIMP CBaseControlVideo::put_SourceHeight(long SourceHeight)
1542 {
1543     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1544     CAutoLock cInterfaceLock(m_pInterfaceLock);
1545     RECT SourceRect;
1546     GetSourceRect(&amp;SourceRect);
1547     SourceRect.bottom = SourceRect.top + SourceHeight;
1548 
1549     // Check the source rectangle is valid
1550 
1551     HRESULT hr = CheckSourceRect(&amp;SourceRect);
1552     if (FAILED(hr)) {
1553         return hr;
1554     }
1555 
1556     // Now set the source rectangle
1557 
1558     hr = SetSourceRect(&amp;SourceRect);
1559     if (FAILED(hr)) {
1560         return hr;
1561     }
1562     return OnUpdateRectangles();
1563 }
1564 
1565 
1566 // Return the current source height
1567 
1568 STDMETHODIMP CBaseControlVideo::get_SourceHeight(__out long *pSourceHeight)
1569 {
1570     CheckPointer(pSourceHeight,E_POINTER);
1571     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1572     CAutoLock cInterfaceLock(m_pInterfaceLock);
1573     RECT SourceRect;
1574 
1575     GetSourceRect(&amp;SourceRect);
1576     *pSourceHeight = HEIGHT(&amp;SourceRect);
1577     return NOERROR;
1578 }
1579 
1580 
1581 // Set the target left position, the target rectangle we get back from the
1582 // window object is a true rectangle in left,top,right and bottom positions
1583 // so all we have to do is to update the left position and pass it back. We
1584 // must keep the current width constant when we&#39;re updating this property
1585 
1586 STDMETHODIMP CBaseControlVideo::put_DestinationLeft(long DestinationLeft)
1587 {
1588     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1589     CAutoLock cInterfaceLock(m_pInterfaceLock);
1590     RECT DestinationRect;
1591     GetTargetRect(&amp;DestinationRect);
1592     DestinationRect.right = DestinationLeft + WIDTH(&amp;DestinationRect);
1593     DestinationRect.left = DestinationLeft;
1594 
1595     // Check the target rectangle is valid
1596 
1597     HRESULT hr = CheckTargetRect(&amp;DestinationRect);
1598     if (FAILED(hr)) {
1599         return hr;
1600     }
1601 
1602     // Now set the new target rectangle
1603 
1604     hr = SetTargetRect(&amp;DestinationRect);
1605     if (FAILED(hr)) {
1606         return hr;
1607     }
1608     return OnUpdateRectangles();
1609 }
1610 
1611 
1612 // Return the left position for the destination rectangle
1613 
1614 STDMETHODIMP CBaseControlVideo::get_DestinationLeft(__out long *pDestinationLeft)
1615 {
1616     CheckPointer(pDestinationLeft,E_POINTER);
1617     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1618     CAutoLock cInterfaceLock(m_pInterfaceLock);
1619     RECT DestinationRect;
1620 
1621     GetTargetRect(&amp;DestinationRect);
1622     *pDestinationLeft = DestinationRect.left;
1623     return NOERROR;
1624 }
1625 
1626 
1627 // Set the destination width
1628 
1629 STDMETHODIMP CBaseControlVideo::put_DestinationWidth(long DestinationWidth)
1630 {
1631     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1632     CAutoLock cInterfaceLock(m_pInterfaceLock);
1633     RECT DestinationRect;
1634     GetTargetRect(&amp;DestinationRect);
1635     DestinationRect.right = DestinationRect.left + DestinationWidth;
1636 
1637     // Check the target rectangle is valid
1638 
1639     HRESULT hr = CheckTargetRect(&amp;DestinationRect);
1640     if (FAILED(hr)) {
1641         return hr;
1642     }
1643 
1644     // Now set the new target rectangle
1645 
1646     hr = SetTargetRect(&amp;DestinationRect);
1647     if (FAILED(hr)) {
1648         return hr;
1649     }
1650     return OnUpdateRectangles();
1651 }
1652 
1653 
1654 // Return the width for the destination rectangle
1655 
1656 STDMETHODIMP CBaseControlVideo::get_DestinationWidth(__out long *pDestinationWidth)
1657 {
1658     CheckPointer(pDestinationWidth,E_POINTER);
1659     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1660     CAutoLock cInterfaceLock(m_pInterfaceLock);
1661     RECT DestinationRect;
1662 
1663     GetTargetRect(&amp;DestinationRect);
1664     *pDestinationWidth = WIDTH(&amp;DestinationRect);
1665     return NOERROR;
1666 }
1667 
1668 
1669 // Set the target top position - changing this property does not affect the
1670 // current target height. So changing this shunts the target rectangle up and
1671 // down appropriately. Changing the height complements this functionality by
1672 // keeping the top position constant and simply changing the target height
1673 
1674 STDMETHODIMP CBaseControlVideo::put_DestinationTop(long DestinationTop)
1675 {
1676     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1677     CAutoLock cInterfaceLock(m_pInterfaceLock);
1678     RECT DestinationRect;
1679     GetTargetRect(&amp;DestinationRect);
1680     DestinationRect.bottom = DestinationTop + HEIGHT(&amp;DestinationRect);
1681     DestinationRect.top = DestinationTop;
1682 
1683     // Check the target rectangle is valid
1684 
1685     HRESULT hr = CheckTargetRect(&amp;DestinationRect);
1686     if (FAILED(hr)) {
1687         return hr;
1688     }
1689 
1690     // Now set the new target rectangle
1691 
1692     hr = SetTargetRect(&amp;DestinationRect);
1693     if (FAILED(hr)) {
1694         return hr;
1695     }
1696     return OnUpdateRectangles();
1697 }
1698 
1699 
1700 // Return the top position for the destination rectangle
1701 
1702 STDMETHODIMP CBaseControlVideo::get_DestinationTop(__out long *pDestinationTop)
1703 {
1704     CheckPointer(pDestinationTop,E_POINTER);
1705     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1706     CAutoLock cInterfaceLock(m_pInterfaceLock);
1707     RECT DestinationRect;
1708 
1709     GetTargetRect(&amp;DestinationRect);
1710     *pDestinationTop = DestinationRect.top;
1711     return NOERROR;
1712 }
1713 
1714 
1715 // Set the destination height
1716 
1717 STDMETHODIMP CBaseControlVideo::put_DestinationHeight(long DestinationHeight)
1718 {
1719     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1720     CAutoLock cInterfaceLock(m_pInterfaceLock);
1721     RECT DestinationRect;
1722     GetTargetRect(&amp;DestinationRect);
1723     DestinationRect.bottom = DestinationRect.top + DestinationHeight;
1724 
1725     // Check the target rectangle is valid
1726 
1727     HRESULT hr = CheckTargetRect(&amp;DestinationRect);
1728     if (FAILED(hr)) {
1729         return hr;
1730     }
1731 
1732     // Now set the new target rectangle
1733 
1734     hr = SetTargetRect(&amp;DestinationRect);
1735     if (FAILED(hr)) {
1736         return hr;
1737     }
1738     return OnUpdateRectangles();
1739 }
1740 
1741 
1742 // Return the height for the destination rectangle
1743 
1744 STDMETHODIMP CBaseControlVideo::get_DestinationHeight(__out long *pDestinationHeight)
1745 {
1746     CheckPointer(pDestinationHeight,E_POINTER);
1747     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1748     CAutoLock cInterfaceLock(m_pInterfaceLock);
1749     RECT DestinationRect;
1750 
1751     GetTargetRect(&amp;DestinationRect);
1752     *pDestinationHeight = HEIGHT(&amp;DestinationRect);
1753     return NOERROR;
1754 }
1755 
1756 
1757 // Reset the source rectangle to the full video dimensions
1758 
1759 STDMETHODIMP CBaseControlVideo::SetDefaultSourcePosition()
1760 {
1761     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1762     CAutoLock cInterfaceLock(m_pInterfaceLock);
1763     HRESULT hr = SetDefaultSourceRect();
1764     if (FAILED(hr)) {
1765         return hr;
1766     }
1767     return OnUpdateRectangles();
1768 }
1769 
1770 
1771 // Return S_OK if we&#39;re using the default source otherwise S_FALSE
1772 
1773 STDMETHODIMP CBaseControlVideo::IsUsingDefaultSource()
1774 {
1775     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1776     CAutoLock cInterfaceLock(m_pInterfaceLock);
1777     return IsDefaultSourceRect();
1778 }
1779 
1780 
1781 // Reset the video renderer to use the entire playback area
1782 
1783 STDMETHODIMP CBaseControlVideo::SetDefaultDestinationPosition()
1784 {
1785     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1786     CAutoLock cInterfaceLock(m_pInterfaceLock);
1787     HRESULT hr = SetDefaultTargetRect();
1788     if (FAILED(hr)) {
1789         return hr;
1790     }
1791     return OnUpdateRectangles();
1792 }
1793 
1794 
1795 // Return S_OK if we&#39;re using the default target otherwise S_FALSE
1796 
1797 STDMETHODIMP CBaseControlVideo::IsUsingDefaultDestination()
1798 {
1799     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1800     CAutoLock cInterfaceLock(m_pInterfaceLock);
1801     return IsDefaultTargetRect();
1802 }
1803 
1804 
1805 // Return a copy of the current image in the video renderer
1806 
1807 STDMETHODIMP
1808 CBaseControlVideo::GetCurrentImage(__inout long *pBufferSize,__out_bcount_part(*pBufferSize, *pBufferSize) long *pVideoImage)
1809 {
1810     CheckPointer(pBufferSize,E_POINTER);
1811     CheckConnected(m_pPin,VFW_E_NOT_CONNECTED);
1812     CAutoLock cInterfaceLock(m_pInterfaceLock);
1813     FILTER_STATE State;
1814 
1815     // Make sure we are in a paused state
1816 
1817     if (pVideoImage != NULL) {
1818         m_pFilter-&gt;GetState(0,&amp;State);
1819         if (State != State_Paused) {
1820             return VFW_E_NOT_PAUSED;
1821         }
1822         return GetStaticImage(pBufferSize,pVideoImage);
1823     }
1824 
1825     // Just return the memory required
1826 
1827     VIDEOINFOHEADER *pVideoInfo = GetVideoFormat();
1828     if (pVideoInfo == NULL)
1829     return E_OUTOFMEMORY;
1830     RECT SourceRect;
1831     GetSourceRect(&amp;SourceRect);
1832     return GetImageSize(pVideoInfo,pBufferSize,&amp;SourceRect);
1833 }
1834 
1835 
1836 // An application has two ways of using GetCurrentImage, one is to pass a real
1837 // buffer which should be filled with the current image. The other is to pass
1838 // a NULL buffer pointer which is interpreted as asking us to return how much
1839 // memory is required for the image. The constraints for when the latter can
1840 // be called are much looser. To calculate the memory required we synthesize
1841 // a VIDEOINFO that takes into account the source rectangle that&#39;s being used
1842 
1843 HRESULT CBaseControlVideo::GetImageSize(__in VIDEOINFOHEADER *pVideoInfo,
1844                                         __out long *pBufferSize,
1845                                         __in RECT *pSourceRect)
1846 {
1847     NOTE(&quot;Entering GetImageSize&quot;);
1848     ASSERT(pSourceRect);
1849 
1850     // Check we have the correct input parameters
1851 
1852     if (pSourceRect == NULL ||
1853             pVideoInfo == NULL ||
1854             pBufferSize == NULL) {
1855 
1856         return E_UNEXPECTED;
1857     }
1858 
1859     // Is the data format compatible
1860 
1861     if (pVideoInfo-&gt;bmiHeader.biCompression != BI_RGB) {
1862         if (pVideoInfo-&gt;bmiHeader.biCompression != BI_BITFIELDS) {
1863             return E_INVALIDARG;
1864         }
1865     }
1866 
1867     ASSERT(IsRectEmpty(pSourceRect) == FALSE);
1868 
1869     BITMAPINFOHEADER bih;
1870     bih.biWidth = WIDTH(pSourceRect);
1871     bih.biHeight = HEIGHT(pSourceRect);
1872     bih.biBitCount = pVideoInfo-&gt;bmiHeader.biBitCount;
1873     LONG Size = DIBSIZE(bih);
1874     Size += GetBitmapFormatSize(HEADER(pVideoInfo)) - SIZE_PREHEADER;
1875     *pBufferSize = Size;
1876 
1877     return NOERROR;
1878 }
1879 
1880 
1881 // Given an IMediaSample containing a linear buffer with an image and a type
1882 // describing the bitmap make a rendering of the image into the output buffer
1883 // This may be called by derived classes who render typical video images to
1884 // handle the IBasicVideo GetCurrentImage method. The pVideoImage pointer may
1885 // be NULL when passed to GetCurrentImage in which case GetImageSize will be
1886 // called instead, which will just do the calculation of the memory required
1887 
1888 HRESULT CBaseControlVideo::CopyImage(IMediaSample *pMediaSample,
1889                                      __in VIDEOINFOHEADER *pVideoInfo,
1890                                      __inout long *pBufferSize,
1891                                      __out_bcount_part(*pBufferSize, *pBufferSize) BYTE *pVideoImage,
1892                                      __in RECT *pSourceRect)
1893 {
1894     NOTE(&quot;Entering CopyImage&quot;);
1895     ASSERT(pSourceRect);
1896     BYTE *pCurrentImage;
1897 
1898     // Check we have an image to copy
1899 
1900     if (pMediaSample == NULL || pSourceRect == NULL ||
1901             pVideoInfo == NULL || pVideoImage == NULL ||
1902             pBufferSize == NULL) {
1903 
1904         return E_UNEXPECTED;
1905     }
1906 
1907     // Is the data format compatible
1908 
1909     if (pVideoInfo-&gt;bmiHeader.biCompression != BI_RGB) {
1910         if (pVideoInfo-&gt;bmiHeader.biCompression != BI_BITFIELDS) {
1911             return E_INVALIDARG;
1912         }
1913     }
1914 
1915     if (*pBufferSize &lt; 0) {
1916         return E_INVALIDARG;
1917     }
1918 
1919     // Arbitrarily large size to prevent integer overflow problems
1920     if (pVideoInfo-&gt;bmiHeader.biSize &gt; 4096)
1921     {
1922         return E_INVALIDARG;
1923     }
1924 
1925     ASSERT(IsRectEmpty(pSourceRect) == FALSE);
1926 
1927     BITMAPINFOHEADER bih;
1928     bih.biWidth = WIDTH(pSourceRect);
1929     bih.biHeight = HEIGHT(pSourceRect);
1930     bih.biBitCount = pVideoInfo-&gt;bmiHeader.biBitCount;
1931     DWORD Size = GetBitmapFormatSize(HEADER(pVideoInfo)) - SIZE_PREHEADER;
1932     DWORD Total;
1933     DWORD dwDibSize;
1934 
1935     if( !ValidateBitmapInfoHeader( HEADER(pVideoInfo), Size)) {
1936         return E_INVALIDARG;
1937     }
1938 
1939     //  ValidateBitmapInfoHeader checks this but for some reason code scanning
1940     //  tools aren&#39;t picking up the annotation
1941     __analysis_assume(Size &gt;= sizeof(BITMAPINFOHEADER));
1942 
1943     if (FAILED(SAFE_DIBSIZE(&amp;bih, &amp;dwDibSize))) {
1944         return E_INVALIDARG;
1945     }
1946 
1947     if (FAILED(DWordAdd(Size, dwDibSize, &amp;Total))) {
1948         return E_INVALIDARG;
1949     }
1950 
1951     // Make sure we have a large enough buffer
1952 
1953     if ((DWORD)*pBufferSize &lt; Total) {
1954         return E_OUTOFMEMORY;
1955     }
1956 
1957     // Copy the BITMAPINFO
1958 
1959     CopyMemory((PVOID)pVideoImage, (PVOID)&amp;pVideoInfo-&gt;bmiHeader, Size);
1960     ((BITMAPINFOHEADER *)pVideoImage)-&gt;biWidth = WIDTH(pSourceRect);
1961     ((BITMAPINFOHEADER *)pVideoImage)-&gt;biHeight = HEIGHT(pSourceRect);
1962     ((BITMAPINFOHEADER *)pVideoImage)-&gt;biSizeImage = DIBSIZE(bih);
1963     BYTE *pImageData = pVideoImage + Size;
1964 
1965     // Get the pointer to it&#39;s image data
1966 
1967     HRESULT hr = pMediaSample-&gt;GetPointer(&amp;pCurrentImage);
1968     if (FAILED(hr)) {
1969         return hr;
1970     }
1971 
1972     // Now we are ready to start copying the source scan lines
1973 
1974     LONG ScanLine = (pVideoInfo-&gt;bmiHeader.biBitCount / 8) * WIDTH(pSourceRect);
1975     LONG LinesToSkip = pVideoInfo-&gt;bmiHeader.biHeight;
1976     LinesToSkip -= pSourceRect-&gt;top + HEIGHT(pSourceRect);
1977     pCurrentImage += LinesToSkip * DIBWIDTHBYTES(pVideoInfo-&gt;bmiHeader);
1978     pCurrentImage += pSourceRect-&gt;left * (pVideoInfo-&gt;bmiHeader.biBitCount / 8);
1979 
1980     // Even money on this GP faulting sometime...
1981 
1982     for (LONG Line = 0;Line &lt; HEIGHT(pSourceRect);Line++) {
1983         CopyMemory((PVOID)pImageData, (PVOID)pCurrentImage, ScanLine);
1984         pImageData += DIBWIDTHBYTES(*(BITMAPINFOHEADER *)pVideoImage);
1985         pCurrentImage += DIBWIDTHBYTES(pVideoInfo-&gt;bmiHeader);
1986     }
1987     return NOERROR;
1988 }
1989 
1990 
1991 // Called when we change media types either during connection or dynamically
1992 // We inform the filter graph and therefore the application that the video
1993 // size may have changed, we don&#39;t bother looking to see if it really has as
1994 // we leave that to the application - the dimensions are the event parameters
1995 
1996 HRESULT CBaseControlVideo::OnVideoSizeChange()
1997 {
1998     // Get the video format from the derived class
1999 
2000     VIDEOINFOHEADER *pVideoInfo = GetVideoFormat();
2001     if (pVideoInfo == NULL)
2002     return E_OUTOFMEMORY;
2003     WORD Width = (WORD) pVideoInfo-&gt;bmiHeader.biWidth;
2004     WORD Height = (WORD) pVideoInfo-&gt;bmiHeader.biHeight;
2005 
2006     return m_pFilter-&gt;NotifyEvent(EC_VIDEO_SIZE_CHANGED,
2007                                   MAKELPARAM(Width,Height),
2008                                   MAKEWPARAM(0,0));
2009 }
2010 
2011 
2012 // Set the video source rectangle. We must check the source rectangle against
2013 // the actual video dimensions otherwise when we come to draw the pictures we
2014 // get access violations as GDI tries to touch data outside of the image data
2015 // Although we store the rectangle in left, top, right and bottom coordinates
2016 // instead of left, top, width and height as OLE uses we do take into account
2017 // that the rectangle is used up to, but not including, the right column and
2018 // bottom row of pixels, see the Win32 documentation on RECT for more details
2019 
2020 HRESULT CBaseControlVideo::CheckSourceRect(__in RECT *pSourceRect)
2021 {
2022     CheckPointer(pSourceRect,E_POINTER);
2023     LONG Width,Height;
2024     GetVideoSize(&amp;Width,&amp;Height);
2025 
2026     // Check the coordinates are greater than zero
2027     // and that the rectangle is valid (left&lt;right, top&lt;bottom)
2028 
2029     if ((pSourceRect-&gt;left &gt;= pSourceRect-&gt;right) ||
2030        (pSourceRect-&gt;left &lt; 0) ||
2031        (pSourceRect-&gt;top &gt;= pSourceRect-&gt;bottom) ||
2032        (pSourceRect-&gt;top &lt; 0)) {
2033 
2034         return E_INVALIDARG;
2035     }
2036 
2037     // Check the coordinates are less than the extents
2038 
2039     if ((pSourceRect-&gt;right &gt; Width) ||
2040         (pSourceRect-&gt;bottom &gt; Height)) {
2041 
2042         return E_INVALIDARG;
2043     }
2044     return NOERROR;
2045 }
2046 
2047 
2048 // Check the target rectangle has some valid coordinates, which amounts to
2049 // little more than checking the destination rectangle isn&#39;t empty. Derived
2050 // classes may call this when they have their SetTargetRect method called to
2051 // check the rectangle validity, we do not update the rectangles passed in
2052 // Although we store the rectangle in left, top, right and bottom coordinates
2053 // instead of left, top, width and height as OLE uses we do take into account
2054 // that the rectangle is used up to, but not including, the right column and
2055 // bottom row of pixels, see the Win32 documentation on RECT for more details
2056 
2057 HRESULT CBaseControlVideo::CheckTargetRect(__in RECT *pTargetRect)
2058 {
2059     // Check the pointer is valid
2060 
2061     if (pTargetRect == NULL) {
2062         return E_POINTER;
2063     }
2064 
2065     // These overflow the WIDTH and HEIGHT checks
2066 
2067     if (pTargetRect-&gt;left &gt; pTargetRect-&gt;right ||
2068             pTargetRect-&gt;top &gt; pTargetRect-&gt;bottom) {
2069                 return E_INVALIDARG;
2070     }
2071 
2072     // Check the rectangle has valid coordinates
2073 
2074     if (WIDTH(pTargetRect) &lt;= 0 || HEIGHT(pTargetRect) &lt;= 0) {
2075         return E_INVALIDARG;
2076     }
2077 
2078     ASSERT(IsRectEmpty(pTargetRect) == FALSE);
2079     return NOERROR;
2080 }
2081 
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/baseclasses/ctlutil.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 //------------------------------------------------------------------------------
   2 // File: CtlUtil.cpp
   3 //
   4 // Desc: DirectShow base classes.
   5 //
   6 // Copyright (c) 1992-2001 Microsoft Corporation.  All rights reserved.
   7 //------------------------------------------------------------------------------
   8 
   9 
  10 // Base classes implementing IDispatch parsing for the basic control dual
  11 // interfaces. Derive from these and implement just the custom method and
  12 // property methods. We also implement CPosPassThru that can be used by
  13 // renderers and transforms to pass by IMediaPosition and IMediaSeeking
  14 
  15 
  16 #include &lt;streams.h&gt;
  17 #include &lt;limits.h&gt;
  18 #include &quot;seekpt.h&quot;
  19 
  20 // &#39;bool&#39; non standard reserved word
  21 #pragma warning(disable:4237)
  22 
  23 
  24 // --- CBaseDispatch implementation ----------
  25 CBaseDispatch::~CBaseDispatch()
  26 {
  27     if (m_pti) {
  28     m_pti-&gt;Release();
  29     }
  30 }
  31 
  32 
  33 // return 1 if we support GetTypeInfo
  34 
  35 STDMETHODIMP
  36 CBaseDispatch::GetTypeInfoCount(__out UINT * pctinfo)
  37 {
  38     CheckPointer(pctinfo,E_POINTER);
  39     ValidateReadWritePtr(pctinfo,sizeof(UINT *));
  40     *pctinfo = 1;
  41     return S_OK;
  42 }
  43 
  44 
  45 typedef HRESULT (STDAPICALLTYPE *LPLOADTYPELIB)(
  46                 const OLECHAR FAR *szFile,
  47                 __deref_out ITypeLib FAR* FAR* pptlib);
  48 
  49 typedef HRESULT (STDAPICALLTYPE *LPLOADREGTYPELIB)(REFGUID rguid,
  50                 WORD wVerMajor,
  51                 WORD wVerMinor,
  52                 LCID lcid,
  53                 __deref_out ITypeLib FAR* FAR* pptlib);
  54 
  55 // attempt to find our type library
  56 
  57 STDMETHODIMP
  58 CBaseDispatch::GetTypeInfo(
  59   REFIID riid,
  60   UINT itinfo,
  61   LCID lcid,
  62   __deref_out ITypeInfo ** pptinfo)
  63 {
  64     CheckPointer(pptinfo,E_POINTER);
  65     ValidateReadWritePtr(pptinfo,sizeof(ITypeInfo *));
  66     HRESULT hr;
  67 
  68     *pptinfo = NULL;
  69 
  70     // we only support one type element
  71     if (0 != itinfo) {
  72     return TYPE_E_ELEMENTNOTFOUND;
  73     }
  74 
  75     if (NULL == pptinfo) {
  76     return E_POINTER;
  77     }
  78 
  79     // always look for neutral
  80     if (NULL == m_pti) {
  81 
  82     LPLOADTYPELIB       lpfnLoadTypeLib;
  83     LPLOADREGTYPELIB    lpfnLoadRegTypeLib;
  84     ITypeLib        *ptlib;
  85     HINSTANCE       hInst;
  86 
  87     static const char  szTypeLib[]    = &quot;LoadTypeLib&quot;;
  88     static const char  szRegTypeLib[] = &quot;LoadRegTypeLib&quot;;
  89     static const WCHAR szControl[]    = L&quot;control.tlb&quot;;
  90 
  91     //
  92     // Try to get the Ole32Aut.dll module handle.
  93     //
  94 
  95     hInst = LoadOLEAut32();
  96     if (hInst == NULL) {
  97         DWORD dwError = GetLastError();
  98         return AmHresultFromWin32(dwError);
  99     }
 100     lpfnLoadRegTypeLib = (LPLOADREGTYPELIB)GetProcAddress(hInst,
 101                                   szRegTypeLib);
 102     if (lpfnLoadRegTypeLib == NULL) {
 103         DWORD dwError = GetLastError();
 104         return AmHresultFromWin32(dwError);
 105     }
 106 
 107     hr = (*lpfnLoadRegTypeLib)(LIBID_QuartzTypeLib, 1, 0, // version 1.0
 108                    lcid, &amp;ptlib);
 109 
 110     if (FAILED(hr)) {
 111 
 112         // attempt to load directly - this will fill the
 113         // registry in if it finds it
 114 
 115         lpfnLoadTypeLib = (LPLOADTYPELIB)GetProcAddress(hInst, szTypeLib);
 116         if (lpfnLoadTypeLib == NULL) {
 117         DWORD dwError = GetLastError();
 118         return AmHresultFromWin32(dwError);
 119         }
 120 
 121         hr = (*lpfnLoadTypeLib)(szControl, &amp;ptlib);
 122         if (FAILED(hr)) {
 123         return hr;
 124         }
 125     }
 126 
 127     hr = ptlib-&gt;GetTypeInfoOfGuid(
 128             riid,
 129             &amp;m_pti);
 130 
 131     ptlib-&gt;Release();
 132 
 133     if (FAILED(hr)) {
 134         return hr;
 135     }
 136     }
 137 
 138     *pptinfo = m_pti;
 139     m_pti-&gt;AddRef();
 140     return S_OK;
 141 }
 142 
 143 
 144 STDMETHODIMP
 145 CBaseDispatch::GetIDsOfNames(
 146   REFIID riid,
 147   __in_ecount(cNames) LPOLESTR * rgszNames,
 148   UINT cNames,
 149   LCID lcid,
 150   __out_ecount(cNames) DISPID * rgdispid)
 151 {
 152     // although the IDispatch riid is dead, we use this to pass from
 153     // the interface implementation class to us the iid we are talking about.
 154 
 155     ITypeInfo * pti;
 156     HRESULT hr = GetTypeInfo(riid, 0, lcid, &amp;pti);
 157 
 158     if (SUCCEEDED(hr)) {
 159     hr = pti-&gt;GetIDsOfNames(rgszNames, cNames, rgdispid);
 160 
 161     pti-&gt;Release();
 162     }
 163     return hr;
 164 }
 165 
 166 
 167 // --- CMediaControl implementation ---------
 168 
 169 CMediaControl::CMediaControl(const TCHAR * name,LPUNKNOWN pUnk) :
 170     CUnknown(name, pUnk)
 171 {
 172 }
 173 
 174 // expose our interfaces IMediaControl and IUnknown
 175 
 176 STDMETHODIMP
 177 CMediaControl::NonDelegatingQueryInterface(REFIID riid, __deref_out void **ppv)
 178 {
 179     ValidateReadWritePtr(ppv,sizeof(PVOID));
 180     if (riid == IID_IMediaControl) {
 181     return GetInterface( (IMediaControl *) this, ppv);
 182     } else {
 183     return CUnknown::NonDelegatingQueryInterface(riid, ppv);
 184     }
 185 }
 186 
 187 
 188 // return 1 if we support GetTypeInfo
 189 
 190 STDMETHODIMP
 191 CMediaControl::GetTypeInfoCount(__out UINT * pctinfo)
 192 {
 193     return m_basedisp.GetTypeInfoCount(pctinfo);
 194 }
 195 
 196 
 197 // attempt to find our type library
 198 
 199 STDMETHODIMP
 200 CMediaControl::GetTypeInfo(
 201   UINT itinfo,
 202   LCID lcid,
 203   __deref_out ITypeInfo ** pptinfo)
 204 {
 205     return m_basedisp.GetTypeInfo(
 206         IID_IMediaControl,
 207         itinfo,
 208         lcid,
 209         pptinfo);
 210 }
 211 
 212 
 213 STDMETHODIMP
 214 CMediaControl::GetIDsOfNames(
 215   REFIID riid,
 216   __in_ecount(cNames) LPOLESTR * rgszNames,
 217   UINT cNames,
 218   LCID lcid,
 219   __out_ecount(cNames) DISPID * rgdispid)
 220 {
 221     return m_basedisp.GetIDsOfNames(
 222             IID_IMediaControl,
 223             rgszNames,
 224             cNames,
 225             lcid,
 226             rgdispid);
 227 }
 228 
 229 
 230 STDMETHODIMP
 231 CMediaControl::Invoke(
 232   DISPID dispidMember,
 233   REFIID riid,
 234   LCID lcid,
 235   WORD wFlags,
 236   __in DISPPARAMS * pdispparams,
 237   __out_opt VARIANT * pvarResult,
 238   __out_opt EXCEPINFO * pexcepinfo,
 239   __out_opt UINT * puArgErr)
 240 {
 241     // this parameter is a dead leftover from an earlier interface
 242     if (IID_NULL != riid) {
 243     return DISP_E_UNKNOWNINTERFACE;
 244     }
 245 
 246     ITypeInfo * pti;
 247     HRESULT hr = GetTypeInfo(0, lcid, &amp;pti);
 248 
 249     if (FAILED(hr)) {
 250     return hr;
 251     }
 252 
 253     hr = pti-&gt;Invoke(
 254         (IMediaControl *)this,
 255         dispidMember,
 256         wFlags,
 257         pdispparams,
 258         pvarResult,
 259         pexcepinfo,
 260         puArgErr);
 261 
 262     pti-&gt;Release();
 263     return hr;
 264 }
 265 
 266 
 267 // --- CMediaEvent implementation ----------
 268 
 269 
 270 CMediaEvent::CMediaEvent(__in_opt LPCTSTR name,__in_opt LPUNKNOWN pUnk) :
 271     CUnknown(name, pUnk)
 272 {
 273 }
 274 
 275 
 276 // expose our interfaces IMediaEvent and IUnknown
 277 
 278 STDMETHODIMP
 279 CMediaEvent::NonDelegatingQueryInterface(REFIID riid, __deref_out void **ppv)
 280 {
 281     ValidateReadWritePtr(ppv,sizeof(PVOID));
 282     if (riid == IID_IMediaEvent || riid == IID_IMediaEventEx) {
 283     return GetInterface( (IMediaEventEx *) this, ppv);
 284     } else {
 285     return CUnknown::NonDelegatingQueryInterface(riid, ppv);
 286     }
 287 }
 288 
 289 
 290 // return 1 if we support GetTypeInfo
 291 
 292 STDMETHODIMP
 293 CMediaEvent::GetTypeInfoCount(__out UINT * pctinfo)
 294 {
 295     return m_basedisp.GetTypeInfoCount(pctinfo);
 296 }
 297 
 298 
 299 // attempt to find our type library
 300 
 301 STDMETHODIMP
 302 CMediaEvent::GetTypeInfo(
 303   UINT itinfo,
 304   LCID lcid,
 305   __deref_out ITypeInfo ** pptinfo)
 306 {
 307     return m_basedisp.GetTypeInfo(
 308         IID_IMediaEvent,
 309         itinfo,
 310         lcid,
 311         pptinfo);
 312 }
 313 
 314 
 315 STDMETHODIMP
 316 CMediaEvent::GetIDsOfNames(
 317   REFIID riid,
 318   __in_ecount(cNames) LPOLESTR * rgszNames,
 319   UINT cNames,
 320   LCID lcid,
 321   __out_ecount(cNames) DISPID * rgdispid)
 322 {
 323     return m_basedisp.GetIDsOfNames(
 324             IID_IMediaEvent,
 325             rgszNames,
 326             cNames,
 327             lcid,
 328             rgdispid);
 329 }
 330 
 331 
 332 STDMETHODIMP
 333 CMediaEvent::Invoke(
 334   DISPID dispidMember,
 335   REFIID riid,
 336   LCID lcid,
 337   WORD wFlags,
 338   __in DISPPARAMS * pdispparams,
 339   __out_opt VARIANT * pvarResult,
 340   __out_opt EXCEPINFO * pexcepinfo,
 341   __out_opt UINT * puArgErr)
 342 {
 343     // this parameter is a dead leftover from an earlier interface
 344     if (IID_NULL != riid) {
 345     return DISP_E_UNKNOWNINTERFACE;
 346     }
 347 
 348     ITypeInfo * pti;
 349     HRESULT hr = GetTypeInfo(0, lcid, &amp;pti);
 350 
 351     if (FAILED(hr)) {
 352     return hr;
 353     }
 354 
 355     hr = pti-&gt;Invoke(
 356         (IMediaEvent *)this,
 357         dispidMember,
 358         wFlags,
 359         pdispparams,
 360         pvarResult,
 361         pexcepinfo,
 362         puArgErr);
 363 
 364     pti-&gt;Release();
 365     return hr;
 366 }
 367 
 368 
 369 // --- CMediaPosition implementation ----------
 370 
 371 
 372 CMediaPosition::CMediaPosition(__in_opt LPCTSTR name,__in_opt LPUNKNOWN pUnk) :
 373     CUnknown(name, pUnk)
 374 {
 375 }
 376 
 377 CMediaPosition::CMediaPosition(__in_opt LPCTSTR name,
 378                                __in_opt LPUNKNOWN pUnk,
 379                                __inout HRESULT * phr) :
 380     CUnknown(name, pUnk)
 381 {
 382     UNREFERENCED_PARAMETER(phr);
 383 }
 384 
 385 
 386 // expose our interfaces IMediaPosition and IUnknown
 387 
 388 STDMETHODIMP
 389 CMediaPosition::NonDelegatingQueryInterface(REFIID riid, __deref_out void **ppv)
 390 {
 391     ValidateReadWritePtr(ppv,sizeof(PVOID));
 392     if (riid == IID_IMediaPosition) {
 393     return GetInterface( (IMediaPosition *) this, ppv);
 394     } else {
 395     return CUnknown::NonDelegatingQueryInterface(riid, ppv);
 396     }
 397 }
 398 
 399 
 400 // return 1 if we support GetTypeInfo
 401 
 402 STDMETHODIMP
 403 CMediaPosition::GetTypeInfoCount(__out UINT * pctinfo)
 404 {
 405     return m_basedisp.GetTypeInfoCount(pctinfo);
 406 }
 407 
 408 
 409 // attempt to find our type library
 410 
 411 STDMETHODIMP
 412 CMediaPosition::GetTypeInfo(
 413   UINT itinfo,
 414   LCID lcid,
 415   __deref_out ITypeInfo ** pptinfo)
 416 {
 417     return m_basedisp.GetTypeInfo(
 418         IID_IMediaPosition,
 419         itinfo,
 420         lcid,
 421         pptinfo);
 422 }
 423 
 424 
 425 STDMETHODIMP
 426 CMediaPosition::GetIDsOfNames(
 427   REFIID riid,
 428   __in_ecount(cNames) LPOLESTR * rgszNames,
 429   UINT cNames,
 430   LCID lcid,
 431   __out_ecount(cNames) DISPID * rgdispid)
 432 {
 433     return m_basedisp.GetIDsOfNames(
 434             IID_IMediaPosition,
 435             rgszNames,
 436             cNames,
 437             lcid,
 438             rgdispid);
 439 }
 440 
 441 
 442 STDMETHODIMP
 443 CMediaPosition::Invoke(
 444   DISPID dispidMember,
 445   REFIID riid,
 446   LCID lcid,
 447   WORD wFlags,
 448   __in DISPPARAMS * pdispparams,
 449   __out_opt VARIANT * pvarResult,
 450   __out_opt EXCEPINFO * pexcepinfo,
 451   __out_opt UINT * puArgErr)
 452 {
 453     // this parameter is a dead leftover from an earlier interface
 454     if (IID_NULL != riid) {
 455     return DISP_E_UNKNOWNINTERFACE;
 456     }
 457 
 458     ITypeInfo * pti;
 459     HRESULT hr = GetTypeInfo(0, lcid, &amp;pti);
 460 
 461     if (FAILED(hr)) {
 462     return hr;
 463     }
 464 
 465     hr = pti-&gt;Invoke(
 466         (IMediaPosition *)this,
 467         dispidMember,
 468         wFlags,
 469         pdispparams,
 470         pvarResult,
 471         pexcepinfo,
 472         puArgErr);
 473 
 474     pti-&gt;Release();
 475     return hr;
 476 }
 477 
 478 
 479 // --- IMediaPosition and IMediaSeeking pass through class ----------
 480 
 481 
 482 CPosPassThru::CPosPassThru(__in_opt LPCTSTR pName,
 483                __in_opt LPUNKNOWN pUnk,
 484                __inout HRESULT *phr,
 485                IPin *pPin) :
 486     CMediaPosition(pName,pUnk),
 487     m_pPin(pPin)
 488 {
 489     if (pPin == NULL) {
 490     *phr = E_POINTER;
 491     return;
 492     }
 493 }
 494 
 495 
 496 // Expose our IMediaSeeking and IMediaPosition interfaces
 497 
 498 STDMETHODIMP
 499 CPosPassThru::NonDelegatingQueryInterface(REFIID riid,__deref_out void **ppv)
 500 {
 501     CheckPointer(ppv,E_POINTER);
 502     *ppv = NULL;
 503 
 504     if (riid == IID_IMediaSeeking) {
 505     return GetInterface( static_cast&lt;IMediaSeeking *&gt;(this), ppv);
 506     }
 507     return CMediaPosition::NonDelegatingQueryInterface(riid,ppv);
 508 }
 509 
 510 
 511 // Return the IMediaPosition interface from our peer
 512 
 513 HRESULT
 514 CPosPassThru::GetPeer(IMediaPosition ** ppMP)
 515 {
 516     *ppMP = NULL;
 517 
 518     IPin *pConnected;
 519     HRESULT hr = m_pPin-&gt;ConnectedTo(&amp;pConnected);
 520     if (FAILED(hr)) {
 521     return E_NOTIMPL;
 522     }
 523     IMediaPosition * pMP;
 524     hr = pConnected-&gt;QueryInterface(IID_IMediaPosition, (void **) &amp;pMP);
 525     pConnected-&gt;Release();
 526     if (FAILED(hr)) {
 527     return E_NOTIMPL;
 528     }
 529 
 530     *ppMP = pMP;
 531     return S_OK;
 532 }
 533 
 534 
 535 // Return the IMediaSeeking interface from our peer
 536 
 537 HRESULT
 538 CPosPassThru::GetPeerSeeking(__deref_out IMediaSeeking ** ppMS)
 539 {
 540     *ppMS = NULL;
 541 
 542     IPin *pConnected;
 543     HRESULT hr = m_pPin-&gt;ConnectedTo(&amp;pConnected);
 544     if (FAILED(hr)) {
 545     return E_NOTIMPL;
 546     }
 547     IMediaSeeking * pMS;
 548     hr = pConnected-&gt;QueryInterface(IID_IMediaSeeking, (void **) &amp;pMS);
 549     pConnected-&gt;Release();
 550     if (FAILED(hr)) {
 551     return E_NOTIMPL;
 552     }
 553 
 554     *ppMS = pMS;
 555     return S_OK;
 556 }
 557 
 558 
 559 // --- IMediaSeeking methods ----------
 560 
 561 
 562 STDMETHODIMP
 563 CPosPassThru::GetCapabilities(__out DWORD * pCaps)
 564 {
 565     IMediaSeeking* pMS;
 566     HRESULT hr = GetPeerSeeking(&amp;pMS);
 567     if (FAILED(hr)) {
 568     return hr;
 569     }
 570 
 571     hr = pMS-&gt;GetCapabilities(pCaps);
 572     pMS-&gt;Release();
 573     return hr;
 574 }
 575 
 576 STDMETHODIMP
 577 CPosPassThru::CheckCapabilities(__inout DWORD * pCaps)
 578 {
 579     IMediaSeeking* pMS;
 580     HRESULT hr = GetPeerSeeking(&amp;pMS);
 581     if (FAILED(hr)) {
 582     return hr;
 583     }
 584 
 585     hr = pMS-&gt;CheckCapabilities(pCaps);
 586     pMS-&gt;Release();
 587     return hr;
 588 }
 589 
 590 STDMETHODIMP
 591 CPosPassThru::IsFormatSupported(const GUID * pFormat)
 592 {
 593     IMediaSeeking* pMS;
 594     HRESULT hr = GetPeerSeeking(&amp;pMS);
 595     if (FAILED(hr)) {
 596     return hr;
 597     }
 598 
 599     hr = pMS-&gt;IsFormatSupported(pFormat);
 600     pMS-&gt;Release();
 601     return hr;
 602 }
 603 
 604 
 605 STDMETHODIMP
 606 CPosPassThru::QueryPreferredFormat(__out GUID *pFormat)
 607 {
 608     IMediaSeeking* pMS;
 609     HRESULT hr = GetPeerSeeking(&amp;pMS);
 610     if (FAILED(hr)) {
 611     return hr;
 612     }
 613 
 614     hr = pMS-&gt;QueryPreferredFormat(pFormat);
 615     pMS-&gt;Release();
 616     return hr;
 617 }
 618 
 619 
 620 STDMETHODIMP
 621 CPosPassThru::SetTimeFormat(const GUID * pFormat)
 622 {
 623     IMediaSeeking* pMS;
 624     HRESULT hr = GetPeerSeeking(&amp;pMS);
 625     if (FAILED(hr)) {
 626     return hr;
 627     }
 628 
 629     hr = pMS-&gt;SetTimeFormat(pFormat);
 630     pMS-&gt;Release();
 631     return hr;
 632 }
 633 
 634 
 635 STDMETHODIMP
 636 CPosPassThru::GetTimeFormat(__out GUID *pFormat)
 637 {
 638     IMediaSeeking* pMS;
 639     HRESULT hr = GetPeerSeeking(&amp;pMS);
 640     if (FAILED(hr)) {
 641     return hr;
 642     }
 643 
 644     hr = pMS-&gt;GetTimeFormat(pFormat);
 645     pMS-&gt;Release();
 646     return hr;
 647 }
 648 
 649 
 650 STDMETHODIMP
 651 CPosPassThru::IsUsingTimeFormat(const GUID * pFormat)
 652 {
 653     IMediaSeeking* pMS;
 654     HRESULT hr = GetPeerSeeking(&amp;pMS);
 655     if (FAILED(hr)) {
 656     return hr;
 657     }
 658 
 659     hr = pMS-&gt;IsUsingTimeFormat(pFormat);
 660     pMS-&gt;Release();
 661     return hr;
 662 }
 663 
 664 
 665 STDMETHODIMP
 666 CPosPassThru::ConvertTimeFormat(__out LONGLONG * pTarget,
 667                                 __in_opt const GUID * pTargetFormat,
 668                 LONGLONG Source,
 669                                 __in_opt const GUID * pSourceFormat )
 670 {
 671     IMediaSeeking* pMS;
 672     HRESULT hr = GetPeerSeeking(&amp;pMS);
 673     if (FAILED(hr)) {
 674     return hr;
 675     }
 676 
 677     hr = pMS-&gt;ConvertTimeFormat(pTarget, pTargetFormat, Source, pSourceFormat );
 678     pMS-&gt;Release();
 679     return hr;
 680 }
 681 
 682 
 683 STDMETHODIMP
 684 CPosPassThru::SetPositions( __inout_opt LONGLONG * pCurrent,
 685                             DWORD CurrentFlags,
 686                             __inout_opt LONGLONG * pStop,
 687                             DWORD StopFlags )
 688 {
 689     IMediaSeeking* pMS;
 690     HRESULT hr = GetPeerSeeking(&amp;pMS);
 691     if (FAILED(hr)) {
 692     return hr;
 693     }
 694 
 695     hr = pMS-&gt;SetPositions(pCurrent, CurrentFlags, pStop, StopFlags );
 696     pMS-&gt;Release();
 697     return hr;
 698 }
 699 
 700 STDMETHODIMP
 701 CPosPassThru::GetPositions(__out_opt LONGLONG *pCurrent, __out_opt LONGLONG * pStop)
 702 {
 703     IMediaSeeking* pMS;
 704     HRESULT hr = GetPeerSeeking(&amp;pMS);
 705     if (FAILED(hr)) {
 706     return hr;
 707     }
 708 
 709     hr = pMS-&gt;GetPositions(pCurrent,pStop);
 710     pMS-&gt;Release();
 711     return hr;
 712 }
 713 
 714 HRESULT
 715 CPosPassThru::GetSeekingLongLong
 716 ( HRESULT (__stdcall IMediaSeeking::*pMethod)( __out LONGLONG * )
 717 , LONGLONG * pll
 718 )
 719 {
 720     IMediaSeeking* pMS;
 721     HRESULT hr = GetPeerSeeking(&amp;pMS);
 722     if (SUCCEEDED(hr))
 723     {
 724     hr = (pMS-&gt;*pMethod)(pll);
 725     pMS-&gt;Release();
 726     }
 727     return hr;
 728 }
 729 
 730 // If we don&#39;t have a current position then ask upstream
 731 
 732 STDMETHODIMP
 733 CPosPassThru::GetCurrentPosition(__out LONGLONG *pCurrent)
 734 {
 735     // Can we report the current position
 736     HRESULT hr = GetMediaTime(pCurrent,NULL);
 737     if (SUCCEEDED(hr)) hr = NOERROR;
 738     else hr = GetSeekingLongLong( &amp;IMediaSeeking::GetCurrentPosition, pCurrent );
 739     return hr;
 740 }
 741 
 742 
 743 STDMETHODIMP
 744 CPosPassThru::GetStopPosition(__out LONGLONG *pStop)
 745 {
 746     return GetSeekingLongLong( &amp;IMediaSeeking::GetStopPosition, pStop );;
 747 }
 748 
 749 STDMETHODIMP
 750 CPosPassThru::GetDuration(__out LONGLONG *pDuration)
 751 {
 752     return GetSeekingLongLong( &amp;IMediaSeeking::GetDuration, pDuration );;
 753 }
 754 
 755 
 756 STDMETHODIMP
 757 CPosPassThru::GetPreroll(__out LONGLONG *pllPreroll)
 758 {
 759     return GetSeekingLongLong( &amp;IMediaSeeking::GetPreroll, pllPreroll );;
 760 }
 761 
 762 
 763 STDMETHODIMP
 764 CPosPassThru::GetAvailable( __out_opt LONGLONG *pEarliest, __out_opt LONGLONG *pLatest )
 765 {
 766     IMediaSeeking* pMS;
 767     HRESULT hr = GetPeerSeeking(&amp;pMS);
 768     if (FAILED(hr)) {
 769     return hr;
 770     }
 771 
 772     hr = pMS-&gt;GetAvailable( pEarliest, pLatest );
 773     pMS-&gt;Release();
 774     return hr;
 775 }
 776 
 777 
 778 STDMETHODIMP
 779 CPosPassThru::GetRate(__out double * pdRate)
 780 {
 781     IMediaSeeking* pMS;
 782     HRESULT hr = GetPeerSeeking(&amp;pMS);
 783     if (FAILED(hr)) {
 784     return hr;
 785     }
 786     hr = pMS-&gt;GetRate(pdRate);
 787     pMS-&gt;Release();
 788     return hr;
 789 }
 790 
 791 
 792 STDMETHODIMP
 793 CPosPassThru::SetRate(double dRate)
 794 {
 795     if (0.0 == dRate) {
 796         return E_INVALIDARG;
 797     }
 798 
 799     IMediaSeeking* pMS;
 800     HRESULT hr = GetPeerSeeking(&amp;pMS);
 801     if (FAILED(hr)) {
 802     return hr;
 803     }
 804     hr = pMS-&gt;SetRate(dRate);
 805     pMS-&gt;Release();
 806     return hr;
 807 }
 808 
 809 
 810 
 811 
 812 // --- IMediaPosition methods ----------
 813 
 814 
 815 STDMETHODIMP
 816 CPosPassThru::get_Duration(__out REFTIME * plength)
 817 {
 818     IMediaPosition* pMP;
 819     HRESULT hr = GetPeer(&amp;pMP);
 820     if (FAILED(hr)) {
 821     return hr;
 822     }
 823 
 824     hr = pMP-&gt;get_Duration(plength);
 825     pMP-&gt;Release();
 826     return hr;
 827 }
 828 
 829 
 830 STDMETHODIMP
 831 CPosPassThru::get_CurrentPosition(__out REFTIME * pllTime)
 832 {
 833     IMediaPosition* pMP;
 834     HRESULT hr = GetPeer(&amp;pMP);
 835     if (FAILED(hr)) {
 836     return hr;
 837     }
 838     hr = pMP-&gt;get_CurrentPosition(pllTime);
 839     pMP-&gt;Release();
 840     return hr;
 841 }
 842 
 843 
 844 STDMETHODIMP
 845 CPosPassThru::put_CurrentPosition(REFTIME llTime)
 846 {
 847     IMediaPosition* pMP;
 848     HRESULT hr = GetPeer(&amp;pMP);
 849     if (FAILED(hr)) {
 850     return hr;
 851     }
 852     hr = pMP-&gt;put_CurrentPosition(llTime);
 853     pMP-&gt;Release();
 854     return hr;
 855 }
 856 
 857 
 858 STDMETHODIMP
 859 CPosPassThru::get_StopTime(__out REFTIME * pllTime)
 860 {
 861     IMediaPosition* pMP;
 862     HRESULT hr = GetPeer(&amp;pMP);
 863     if (FAILED(hr)) {
 864     return hr;
 865     }
 866     hr = pMP-&gt;get_StopTime(pllTime);
 867     pMP-&gt;Release();
 868     return hr;
 869 }
 870 
 871 
 872 STDMETHODIMP
 873 CPosPassThru::put_StopTime(REFTIME llTime)
 874 {
 875     IMediaPosition* pMP;
 876     HRESULT hr = GetPeer(&amp;pMP);
 877     if (FAILED(hr)) {
 878     return hr;
 879     }
 880     hr = pMP-&gt;put_StopTime(llTime);
 881     pMP-&gt;Release();
 882     return hr;
 883 }
 884 
 885 
 886 STDMETHODIMP
 887 CPosPassThru::get_PrerollTime(__out REFTIME * pllTime)
 888 {
 889     IMediaPosition* pMP;
 890     HRESULT hr = GetPeer(&amp;pMP);
 891     if (FAILED(hr)) {
 892     return hr;
 893     }
 894     hr = pMP-&gt;get_PrerollTime(pllTime);
 895     pMP-&gt;Release();
 896     return hr;
 897 }
 898 
 899 
 900 STDMETHODIMP
 901 CPosPassThru::put_PrerollTime(REFTIME llTime)
 902 {
 903     IMediaPosition* pMP;
 904     HRESULT hr = GetPeer(&amp;pMP);
 905     if (FAILED(hr)) {
 906     return hr;
 907     }
 908     hr = pMP-&gt;put_PrerollTime(llTime);
 909     pMP-&gt;Release();
 910     return hr;
 911 }
 912 
 913 
 914 STDMETHODIMP
 915 CPosPassThru::get_Rate(__out double * pdRate)
 916 {
 917     IMediaPosition* pMP;
 918     HRESULT hr = GetPeer(&amp;pMP);
 919     if (FAILED(hr)) {
 920     return hr;
 921     }
 922     hr = pMP-&gt;get_Rate(pdRate);
 923     pMP-&gt;Release();
 924     return hr;
 925 }
 926 
 927 
 928 STDMETHODIMP
 929 CPosPassThru::put_Rate(double dRate)
 930 {
 931     if (0.0 == dRate) {
 932         return E_INVALIDARG;
 933     }
 934 
 935     IMediaPosition* pMP;
 936     HRESULT hr = GetPeer(&amp;pMP);
 937     if (FAILED(hr)) {
 938     return hr;
 939     }
 940     hr = pMP-&gt;put_Rate(dRate);
 941     pMP-&gt;Release();
 942     return hr;
 943 }
 944 
 945 
 946 STDMETHODIMP
 947 CPosPassThru::CanSeekForward(__out LONG *pCanSeekForward)
 948 {
 949     IMediaPosition* pMP;
 950     HRESULT hr = GetPeer(&amp;pMP);
 951     if (FAILED(hr)) {
 952     return hr;
 953     }
 954     hr = pMP-&gt;CanSeekForward(pCanSeekForward);
 955     pMP-&gt;Release();
 956     return hr;
 957 }
 958 
 959 
 960 STDMETHODIMP
 961 CPosPassThru::CanSeekBackward(__out LONG *pCanSeekBackward)
 962 {
 963     IMediaPosition* pMP;
 964     HRESULT hr = GetPeer(&amp;pMP);
 965     if (FAILED(hr)) {
 966     return hr;
 967     }
 968     hr = pMP-&gt;CanSeekBackward(pCanSeekBackward);
 969     pMP-&gt;Release();
 970     return hr;
 971 }
 972 
 973 
 974 // --- Implements the CRendererPosPassThru class ----------
 975 
 976 
 977 // Media times (eg current frame, field, sample etc) are passed through the
 978 // filtergraph in media samples. When a renderer gets a sample with media
 979 // times in it, it will call one of the RegisterMediaTime methods we expose
 980 // (one takes an IMediaSample, the other takes the media times direct). We
 981 // store the media times internally and return them in GetCurrentPosition.
 982 
 983 CRendererPosPassThru::CRendererPosPassThru(__in_opt LPCTSTR pName,
 984                        __in_opt LPUNKNOWN pUnk,
 985                        __inout HRESULT *phr,
 986                        IPin *pPin) :
 987     CPosPassThru(pName,pUnk,phr,pPin),
 988     m_StartMedia(0),
 989     m_EndMedia(0),
 990     m_bReset(TRUE)
 991 {
 992 }
 993 
 994 
 995 // Sets the media times the object should report
 996 
 997 HRESULT
 998 CRendererPosPassThru::RegisterMediaTime(IMediaSample *pMediaSample)
 999 {
1000     ASSERT(pMediaSample);
1001     LONGLONG StartMedia;
1002     LONGLONG EndMedia;
1003 
1004     CAutoLock cAutoLock(&amp;m_PositionLock);
1005 
1006     // Get the media times from the sample
1007 
1008     HRESULT hr = pMediaSample-&gt;GetTime(&amp;StartMedia,&amp;EndMedia);
1009     if (FAILED(hr))
1010     {
1011     ASSERT(hr == VFW_E_SAMPLE_TIME_NOT_SET);
1012     return hr;
1013     }
1014 
1015     m_StartMedia = StartMedia;
1016     m_EndMedia = EndMedia;
1017     m_bReset = FALSE;
1018     return NOERROR;
1019 }
1020 
1021 
1022 // Sets the media times the object should report
1023 
1024 HRESULT
1025 CRendererPosPassThru::RegisterMediaTime(LONGLONG StartTime,LONGLONG EndTime)
1026 {
1027     CAutoLock cAutoLock(&amp;m_PositionLock);
1028     m_StartMedia = StartTime;
1029     m_EndMedia = EndTime;
1030     m_bReset = FALSE;
1031     return NOERROR;
1032 }
1033 
1034 
1035 // Return the current media times registered in the object
1036 
1037 HRESULT
1038 CRendererPosPassThru::GetMediaTime(__out LONGLONG *pStartTime, __out_opt LONGLONG *pEndTime)
1039 {
1040     ASSERT(pStartTime);
1041 
1042     CAutoLock cAutoLock(&amp;m_PositionLock);
1043     if (m_bReset == TRUE) {
1044     return E_FAIL;
1045     }
1046 
1047     // We don&#39;t have to return the end time
1048 
1049     HRESULT hr = ConvertTimeFormat( pStartTime, 0, m_StartMedia, &amp;TIME_FORMAT_MEDIA_TIME );
1050     if (pEndTime &amp;&amp; SUCCEEDED(hr)) {
1051     hr = ConvertTimeFormat( pEndTime, 0, m_EndMedia, &amp;TIME_FORMAT_MEDIA_TIME );
1052     }
1053     return hr;
1054 }
1055 
1056 
1057 // Resets the media times we hold
1058 
1059 HRESULT
1060 CRendererPosPassThru::ResetMediaTime()
1061 {
1062     CAutoLock cAutoLock(&amp;m_PositionLock);
1063     m_StartMedia = 0;
1064     m_EndMedia = 0;
1065     m_bReset = TRUE;
1066     return NOERROR;
1067 }
1068 
1069 // Intended to be called by the owing filter during EOS processing so
1070 // that the media times can be adjusted to the stop time.  This ensures
1071 // that the GetCurrentPosition will actully get to the stop position.
1072 HRESULT
1073 CRendererPosPassThru::EOS()
1074 {
1075     HRESULT hr;
1076 
1077     if ( m_bReset == TRUE ) hr = E_FAIL;
1078     else
1079     {
1080     LONGLONG llStop;
1081     if SUCCEEDED(hr=GetStopPosition(&amp;llStop))
1082     {
1083         CAutoLock cAutoLock(&amp;m_PositionLock);
1084         m_StartMedia =
1085         m_EndMedia   = llStop;
1086     }
1087     }
1088     return hr;
1089 }
1090 
1091 // -- CSourceSeeking implementation ------------
1092 
1093 CSourceSeeking::CSourceSeeking(
1094     __in_opt LPCTSTR pName,
1095     __in_opt LPUNKNOWN pUnk,
1096     __inout HRESULT* phr,
1097     __in CCritSec * pLock) :
1098         CUnknown(pName, pUnk),
1099         m_pLock(pLock),
1100         m_rtStart((long)0)
1101 {
1102     m_rtStop = _I64_MAX / 2;
1103     m_rtDuration = m_rtStop;
1104     m_dRateSeeking = 1.0;
1105 
1106     m_dwSeekingCaps = AM_SEEKING_CanSeekForwards
1107         | AM_SEEKING_CanSeekBackwards
1108         | AM_SEEKING_CanSeekAbsolute
1109         | AM_SEEKING_CanGetStopPos
1110         | AM_SEEKING_CanGetDuration;
1111 }
1112 
1113 HRESULT CSourceSeeking::NonDelegatingQueryInterface(REFIID riid, __deref_out void **ppv)
1114 {
1115     if(riid == IID_IMediaSeeking) {
1116         CheckPointer(ppv, E_POINTER);
1117         return GetInterface(static_cast&lt;IMediaSeeking *&gt;(this), ppv);
1118     }
1119     else {
1120         return CUnknown::NonDelegatingQueryInterface(riid, ppv);
1121     }
1122 }
1123 
1124 
1125 HRESULT CSourceSeeking::IsFormatSupported(const GUID * pFormat)
1126 {
1127     CheckPointer(pFormat, E_POINTER);
1128     // only seeking in time (REFERENCE_TIME units) is supported
1129     return *pFormat == TIME_FORMAT_MEDIA_TIME ? S_OK : S_FALSE;
1130 }
1131 
1132 HRESULT CSourceSeeking::QueryPreferredFormat(__out GUID *pFormat)
1133 {
1134     CheckPointer(pFormat, E_POINTER);
1135     *pFormat = TIME_FORMAT_MEDIA_TIME;
1136     return S_OK;
1137 }
1138 
1139 HRESULT CSourceSeeking::SetTimeFormat(const GUID * pFormat)
1140 {
1141     CheckPointer(pFormat, E_POINTER);
1142 
1143     // nothing to set; just check that it&#39;s TIME_FORMAT_TIME
1144     return *pFormat == TIME_FORMAT_MEDIA_TIME ? S_OK : E_INVALIDARG;
1145 }
1146 
1147 HRESULT CSourceSeeking::IsUsingTimeFormat(const GUID * pFormat)
1148 {
1149     CheckPointer(pFormat, E_POINTER);
1150     return *pFormat == TIME_FORMAT_MEDIA_TIME ? S_OK : S_FALSE;
1151 }
1152 
1153 HRESULT CSourceSeeking::GetTimeFormat(__out GUID *pFormat)
1154 {
1155     CheckPointer(pFormat, E_POINTER);
1156     *pFormat = TIME_FORMAT_MEDIA_TIME;
1157     return S_OK;
1158 }
1159 
1160 HRESULT CSourceSeeking::GetDuration(__out LONGLONG *pDuration)
1161 {
1162     CheckPointer(pDuration, E_POINTER);
1163     CAutoLock lock(m_pLock);
1164     *pDuration = m_rtDuration;
1165     return S_OK;
1166 }
1167 
1168 HRESULT CSourceSeeking::GetStopPosition(__out LONGLONG *pStop)
1169 {
1170     CheckPointer(pStop, E_POINTER);
1171     CAutoLock lock(m_pLock);
1172     *pStop = m_rtStop;
1173     return S_OK;
1174 }
1175 
1176 HRESULT CSourceSeeking::GetCurrentPosition(__out LONGLONG *pCurrent)
1177 {
1178     // GetCurrentPosition is typically supported only in renderers and
1179     // not in source filters.
1180     return E_NOTIMPL;
1181 }
1182 
1183 HRESULT CSourceSeeking::GetCapabilities( __out DWORD * pCapabilities )
1184 {
1185     CheckPointer(pCapabilities, E_POINTER);
1186     *pCapabilities = m_dwSeekingCaps;
1187     return S_OK;
1188 }
1189 
1190 HRESULT CSourceSeeking::CheckCapabilities( __inout DWORD * pCapabilities )
1191 {
1192     CheckPointer(pCapabilities, E_POINTER);
1193 
1194     // make sure all requested capabilities are in our mask
1195     return (~m_dwSeekingCaps &amp; *pCapabilities) ? S_FALSE : S_OK;
1196 }
1197 
1198 HRESULT CSourceSeeking::ConvertTimeFormat( __out LONGLONG * pTarget,
1199                                            __in_opt const GUID * pTargetFormat,
1200                                            LONGLONG Source,
1201                                            __in_opt const GUID * pSourceFormat )
1202 {
1203     CheckPointer(pTarget, E_POINTER);
1204     // format guids can be null to indicate current format
1205 
1206     // since we only support TIME_FORMAT_MEDIA_TIME, we don&#39;t really
1207     // offer any conversions.
1208     if(pTargetFormat == 0 || *pTargetFormat == TIME_FORMAT_MEDIA_TIME)
1209     {
1210         if(pSourceFormat == 0 || *pSourceFormat == TIME_FORMAT_MEDIA_TIME)
1211         {
1212             *pTarget = Source;
1213             return S_OK;
1214         }
1215     }
1216 
1217     return E_INVALIDARG;
1218 }
1219 
1220 
1221 HRESULT CSourceSeeking::SetPositions( __inout_opt LONGLONG * pCurrent,
1222                                       DWORD CurrentFlags,
1223                                       __inout_opt LONGLONG * pStop,
1224                                       DWORD StopFlags )
1225 {
1226     DWORD StopPosBits = StopFlags &amp; AM_SEEKING_PositioningBitsMask;
1227     DWORD StartPosBits = CurrentFlags &amp; AM_SEEKING_PositioningBitsMask;
1228 
1229     if(StopFlags) {
1230         CheckPointer(pStop, E_POINTER);
1231 
1232         // accept only relative, incremental, or absolute positioning
1233         if(StopPosBits != StopFlags) {
1234             return E_INVALIDARG;
1235         }
1236     }
1237 
1238     if(CurrentFlags) {
1239         CheckPointer(pCurrent, E_POINTER);
1240         if(StartPosBits != AM_SEEKING_AbsolutePositioning &amp;&amp;
1241            StartPosBits != AM_SEEKING_RelativePositioning) {
1242             return E_INVALIDARG;
1243         }
1244     }
1245 
1246 
1247     // scope for autolock
1248     {
1249         CAutoLock lock(m_pLock);
1250 
1251         // set start position
1252         if(StartPosBits == AM_SEEKING_AbsolutePositioning)
1253         {
1254             m_rtStart = *pCurrent;
1255         }
1256         else if(StartPosBits == AM_SEEKING_RelativePositioning)
1257         {
1258             m_rtStart += *pCurrent;
1259         }
1260 
1261         // set stop position
1262         if(StopPosBits == AM_SEEKING_AbsolutePositioning)
1263         {
1264             m_rtStop = *pStop;
1265         }
1266         else if(StopPosBits == AM_SEEKING_IncrementalPositioning)
1267         {
1268             m_rtStop = m_rtStart + *pStop;
1269         }
1270         else if(StopPosBits == AM_SEEKING_RelativePositioning)
1271         {
1272             m_rtStop = m_rtStop + *pStop;
1273         }
1274     }
1275 
1276 
1277     HRESULT hr = S_OK;
1278     if(SUCCEEDED(hr) &amp;&amp; StopPosBits) {
1279         hr = ChangeStop();
1280     }
1281     if(StartPosBits) {
1282         hr = ChangeStart();
1283     }
1284 
1285     return hr;
1286 }
1287 
1288 
1289 HRESULT CSourceSeeking::GetPositions( __out_opt LONGLONG * pCurrent, __out_opt LONGLONG * pStop )
1290 {
1291     if(pCurrent) {
1292         *pCurrent = m_rtStart;
1293     }
1294     if(pStop) {
1295         *pStop = m_rtStop;
1296     }
1297 
1298     return S_OK;;
1299 }
1300 
1301 
1302 HRESULT CSourceSeeking::GetAvailable( __out_opt LONGLONG * pEarliest, __out_opt LONGLONG * pLatest )
1303 {
1304     if(pEarliest) {
1305         *pEarliest = 0;
1306     }
1307     if(pLatest) {
1308         CAutoLock lock(m_pLock);
1309         *pLatest = m_rtDuration;
1310     }
1311     return S_OK;
1312 }
1313 
1314 HRESULT CSourceSeeking::SetRate( double dRate)
1315 {
1316     {
1317         CAutoLock lock(m_pLock);
1318         m_dRateSeeking = dRate;
1319     }
1320     return ChangeRate();
1321 }
1322 
1323 HRESULT CSourceSeeking::GetRate( __out double * pdRate)
1324 {
1325     CheckPointer(pdRate, E_POINTER);
1326     CAutoLock lock(m_pLock);
1327     *pdRate = m_dRateSeeking;
1328     return S_OK;
1329 }
1330 
1331 HRESULT CSourceSeeking::GetPreroll(__out LONGLONG *pPreroll)
1332 {
1333     CheckPointer(pPreroll, E_POINTER);
1334     *pPreroll = 0;
1335     return S_OK;
1336 }
1337 
1338 
1339 
1340 
1341 
1342 // --- CSourcePosition implementation ----------
1343 
1344 
1345 CSourcePosition::CSourcePosition(__in_opt LPCTSTR pName,
1346                  __in_opt LPUNKNOWN pUnk,
1347                  __inout HRESULT* phr,
1348                  __in CCritSec * pLock) :
1349     CMediaPosition(pName, pUnk),
1350     m_pLock(pLock),
1351     m_Start(CRefTime((LONGLONG)0))
1352 {
1353     m_Stop = _I64_MAX;
1354     m_Rate = 1.0;
1355 }
1356 
1357 
1358 STDMETHODIMP
1359 CSourcePosition::get_Duration(__out REFTIME * plength)
1360 {
1361     CheckPointer(plength,E_POINTER);
1362     ValidateReadWritePtr(plength,sizeof(REFTIME));
1363     CAutoLock lock(m_pLock);
1364 
1365     *plength = m_Duration;
1366     return S_OK;
1367 }
1368 
1369 
1370 STDMETHODIMP
1371 CSourcePosition::put_CurrentPosition(REFTIME llTime)
1372 {
1373     m_pLock-&gt;Lock();
1374     m_Start = llTime;
1375     m_pLock-&gt;Unlock();
1376 
1377     return ChangeStart();
1378 }
1379 
1380 
1381 STDMETHODIMP
1382 CSourcePosition::get_StopTime(__out REFTIME * pllTime)
1383 {
1384     CheckPointer(pllTime,E_POINTER);
1385     ValidateReadWritePtr(pllTime,sizeof(REFTIME));
1386     CAutoLock lock(m_pLock);
1387 
1388     *pllTime = m_Stop;
1389     return S_OK;
1390 }
1391 
1392 
1393 STDMETHODIMP
1394 CSourcePosition::put_StopTime(REFTIME llTime)
1395 {
1396     m_pLock-&gt;Lock();
1397     m_Stop = llTime;
1398     m_pLock-&gt;Unlock();
1399 
1400     return ChangeStop();
1401 }
1402 
1403 
1404 STDMETHODIMP
1405 CSourcePosition::get_PrerollTime(__out REFTIME * pllTime)
1406 {
1407     CheckPointer(pllTime,E_POINTER);
1408     ValidateReadWritePtr(pllTime,sizeof(REFTIME));
1409     return E_NOTIMPL;
1410 }
1411 
1412 
1413 STDMETHODIMP
1414 CSourcePosition::put_PrerollTime(REFTIME llTime)
1415 {
1416     return E_NOTIMPL;
1417 }
1418 
1419 
1420 STDMETHODIMP
1421 CSourcePosition::get_Rate(__out double * pdRate)
1422 {
1423     CheckPointer(pdRate,E_POINTER);
1424     ValidateReadWritePtr(pdRate,sizeof(double));
1425     CAutoLock lock(m_pLock);
1426 
1427     *pdRate = m_Rate;
1428     return S_OK;
1429 }
1430 
1431 
1432 STDMETHODIMP
1433 CSourcePosition::put_Rate(double dRate)
1434 {
1435     m_pLock-&gt;Lock();
1436     m_Rate = dRate;
1437     m_pLock-&gt;Unlock();
1438 
1439     return ChangeRate();
1440 }
1441 
1442 
1443 // By default we can seek forwards
1444 
1445 STDMETHODIMP
1446 CSourcePosition::CanSeekForward(__out LONG *pCanSeekForward)
1447 {
1448     CheckPointer(pCanSeekForward,E_POINTER);
1449     *pCanSeekForward = OATRUE;
1450     return S_OK;
1451 }
1452 
1453 
1454 // By default we can seek backwards
1455 
1456 STDMETHODIMP
1457 CSourcePosition::CanSeekBackward(__out LONG *pCanSeekBackward)
1458 {
1459     CheckPointer(pCanSeekBackward,E_POINTER);
1460     *pCanSeekBackward = OATRUE;
1461     return S_OK;
1462 }
1463 
1464 
1465 // --- Implementation of CBasicAudio class ----------
1466 
1467 
1468 CBasicAudio::CBasicAudio(__in_opt LPCTSTR pName,__in_opt LPUNKNOWN punk) :
1469     CUnknown(pName, punk)
1470 {
1471 }
1472 
1473 // overriden to publicise our interfaces
1474 
1475 STDMETHODIMP
1476 CBasicAudio::NonDelegatingQueryInterface(REFIID riid, __deref_out void **ppv)
1477 {
1478     ValidateReadWritePtr(ppv,sizeof(PVOID));
1479     if (riid == IID_IBasicAudio) {
1480     return GetInterface( (IBasicAudio *) this, ppv);
1481     } else {
1482     return CUnknown::NonDelegatingQueryInterface(riid, ppv);
1483     }
1484 }
1485 
1486 
1487 STDMETHODIMP
1488 CBasicAudio::GetTypeInfoCount(__out UINT * pctinfo)
1489 {
1490     return m_basedisp.GetTypeInfoCount(pctinfo);
1491 }
1492 
1493 
1494 STDMETHODIMP
1495 CBasicAudio::GetTypeInfo(
1496   UINT itinfo,
1497   LCID lcid,
1498   __deref_out ITypeInfo ** pptinfo)
1499 {
1500     return m_basedisp.GetTypeInfo(
1501         IID_IBasicAudio,
1502         itinfo,
1503         lcid,
1504         pptinfo);
1505 }
1506 
1507 
1508 STDMETHODIMP
1509 CBasicAudio::GetIDsOfNames(
1510   REFIID riid,
1511   __in_ecount(cNames) LPOLESTR * rgszNames,
1512   UINT cNames,
1513   LCID lcid,
1514   __out_ecount(cNames) DISPID * rgdispid)
1515 {
1516     return m_basedisp.GetIDsOfNames(
1517             IID_IBasicAudio,
1518             rgszNames,
1519             cNames,
1520             lcid,
1521             rgdispid);
1522 }
1523 
1524 
1525 STDMETHODIMP
1526 CBasicAudio::Invoke(
1527   DISPID dispidMember,
1528   REFIID riid,
1529   LCID lcid,
1530   WORD wFlags,
1531   __in DISPPARAMS * pdispparams,
1532   __out_opt VARIANT * pvarResult,
1533   __out_opt EXCEPINFO * pexcepinfo,
1534   __out_opt UINT * puArgErr)
1535 {
1536     // this parameter is a dead leftover from an earlier interface
1537     if (IID_NULL != riid) {
1538     return DISP_E_UNKNOWNINTERFACE;
1539     }
1540 
1541     ITypeInfo * pti;
1542     HRESULT hr = GetTypeInfo(0, lcid, &amp;pti);
1543 
1544     if (FAILED(hr)) {
1545     return hr;
1546     }
1547 
1548     hr = pti-&gt;Invoke(
1549         (IBasicAudio *)this,
1550         dispidMember,
1551         wFlags,
1552         pdispparams,
1553         pvarResult,
1554         pexcepinfo,
1555         puArgErr);
1556 
1557     pti-&gt;Release();
1558     return hr;
1559 }
1560 
1561 
1562 // --- IVideoWindow implementation ----------
1563 
1564 CBaseVideoWindow::CBaseVideoWindow(__in_opt LPCTSTR pName,__in_opt LPUNKNOWN punk) :
1565     CUnknown(pName, punk)
1566 {
1567 }
1568 
1569 
1570 // overriden to publicise our interfaces
1571 
1572 STDMETHODIMP
1573 CBaseVideoWindow::NonDelegatingQueryInterface(REFIID riid, __deref_out void **ppv)
1574 {
1575     ValidateReadWritePtr(ppv,sizeof(PVOID));
1576     if (riid == IID_IVideoWindow) {
1577     return GetInterface( (IVideoWindow *) this, ppv);
1578     } else {
1579     return CUnknown::NonDelegatingQueryInterface(riid, ppv);
1580     }
1581 }
1582 
1583 
1584 STDMETHODIMP
1585 CBaseVideoWindow::GetTypeInfoCount(__out UINT * pctinfo)
1586 {
1587     return m_basedisp.GetTypeInfoCount(pctinfo);
1588 }
1589 
1590 
1591 STDMETHODIMP
1592 CBaseVideoWindow::GetTypeInfo(
1593   UINT itinfo,
1594   LCID lcid,
1595   __deref_out ITypeInfo ** pptinfo)
1596 {
1597     return m_basedisp.GetTypeInfo(
1598         IID_IVideoWindow,
1599         itinfo,
1600         lcid,
1601         pptinfo);
1602 }
1603 
1604 
1605 STDMETHODIMP
1606 CBaseVideoWindow::GetIDsOfNames(
1607   REFIID riid,
1608   __in_ecount(cNames) LPOLESTR * rgszNames,
1609   UINT cNames,
1610   LCID lcid,
1611   __out_ecount(cNames) DISPID * rgdispid)
1612 {
1613     return m_basedisp.GetIDsOfNames(
1614             IID_IVideoWindow,
1615             rgszNames,
1616             cNames,
1617             lcid,
1618             rgdispid);
1619 }
1620 
1621 
1622 STDMETHODIMP
1623 CBaseVideoWindow::Invoke(
1624   DISPID dispidMember,
1625   REFIID riid,
1626   LCID lcid,
1627   WORD wFlags,
1628   __in DISPPARAMS * pdispparams,
1629   __out_opt VARIANT * pvarResult,
1630   __out_opt EXCEPINFO * pexcepinfo,
1631   __out_opt UINT * puArgErr)
1632 {
1633     // this parameter is a dead leftover from an earlier interface
1634     if (IID_NULL != riid) {
1635     return DISP_E_UNKNOWNINTERFACE;
1636     }
1637 
1638     ITypeInfo * pti;
1639     HRESULT hr = GetTypeInfo(0, lcid, &amp;pti);
1640 
1641     if (FAILED(hr)) {
1642     return hr;
1643     }
1644 
1645     hr = pti-&gt;Invoke(
1646         (IVideoWindow *)this,
1647         dispidMember,
1648         wFlags,
1649         pdispparams,
1650         pvarResult,
1651         pexcepinfo,
1652         puArgErr);
1653 
1654     pti-&gt;Release();
1655     return hr;
1656 }
1657 
1658 
1659 // --- IBasicVideo implementation ----------
1660 
1661 
1662 CBaseBasicVideo::CBaseBasicVideo(__in_opt LPCTSTR pName,__in_opt LPUNKNOWN punk) :
1663     CUnknown(pName, punk)
1664 {
1665 }
1666 
1667 
1668 // overriden to publicise our interfaces
1669 
1670 STDMETHODIMP
1671 CBaseBasicVideo::NonDelegatingQueryInterface(REFIID riid, __deref_out void **ppv)
1672 {
1673     ValidateReadWritePtr(ppv,sizeof(PVOID));
1674     if (riid == IID_IBasicVideo || riid == IID_IBasicVideo2) {
1675     return GetInterface( static_cast&lt;IBasicVideo2 *&gt;(this), ppv);
1676     } else {
1677     return CUnknown::NonDelegatingQueryInterface(riid, ppv);
1678     }
1679 }
1680 
1681 
1682 STDMETHODIMP
1683 CBaseBasicVideo::GetTypeInfoCount(__out UINT * pctinfo)
1684 {
1685     return m_basedisp.GetTypeInfoCount(pctinfo);
1686 }
1687 
1688 
1689 STDMETHODIMP
1690 CBaseBasicVideo::GetTypeInfo(
1691   UINT itinfo,
1692   LCID lcid,
1693   __deref_out ITypeInfo ** pptinfo)
1694 {
1695     return m_basedisp.GetTypeInfo(
1696         IID_IBasicVideo,
1697         itinfo,
1698         lcid,
1699         pptinfo);
1700 }
1701 
1702 
1703 STDMETHODIMP
1704 CBaseBasicVideo::GetIDsOfNames(
1705   REFIID riid,
1706   __in_ecount(cNames) LPOLESTR * rgszNames,
1707   UINT cNames,
1708   LCID lcid,
1709   __out_ecount(cNames) DISPID * rgdispid)
1710 {
1711     return m_basedisp.GetIDsOfNames(
1712             IID_IBasicVideo,
1713             rgszNames,
1714             cNames,
1715             lcid,
1716             rgdispid);
1717 }
1718 
1719 
1720 STDMETHODIMP
1721 CBaseBasicVideo::Invoke(
1722   DISPID dispidMember,
1723   REFIID riid,
1724   LCID lcid,
1725   WORD wFlags,
1726   __in DISPPARAMS * pdispparams,
1727   __out_opt VARIANT * pvarResult,
1728   __out_opt EXCEPINFO * pexcepinfo,
1729   __out_opt UINT * puArgErr)
1730 {
1731     // this parameter is a dead leftover from an earlier interface
1732     if (IID_NULL != riid) {
1733     return DISP_E_UNKNOWNINTERFACE;
1734     }
1735 
1736     ITypeInfo * pti;
1737     HRESULT hr = GetTypeInfo(0, lcid, &amp;pti);
1738 
1739     if (FAILED(hr)) {
1740     return hr;
1741     }
1742 
1743     hr = pti-&gt;Invoke(
1744         (IBasicVideo *)this,
1745         dispidMember,
1746         wFlags,
1747         pdispparams,
1748         pvarResult,
1749         pexcepinfo,
1750         puArgErr);
1751 
1752     pti-&gt;Release();
1753     return hr;
1754 }
1755 
1756 
1757 // --- Implementation of Deferred Commands ----------
1758 
1759 
1760 CDispParams::CDispParams(UINT nArgs, __in_ecount(nArgs) VARIANT* pArgs, __inout_opt HRESULT *phr)
1761 {
1762    cNamedArgs = 0;
1763    rgdispidNamedArgs = NULL;
1764    cArgs = nArgs;
1765 
1766     if (cArgs) {
1767     rgvarg = new VARIANT[cArgs];
1768         if (NULL == rgvarg) {
1769             cArgs = 0;
1770             if (phr) {
1771                 *phr = E_OUTOFMEMORY;
1772             }
1773             return;
1774         }
1775 
1776     for (UINT i = 0; i &lt; cArgs; i++) {
1777 
1778             //  Why aren&#39;t we using VariantCopy?
1779 
1780         VARIANT * pDest = &amp;rgvarg[i];
1781         VARIANT * pSrc = &amp;pArgs[i];
1782 
1783         pDest-&gt;vt = pSrc-&gt;vt;
1784         switch(pDest-&gt;vt) {
1785 
1786         case VT_I4:
1787         pDest-&gt;lVal = pSrc-&gt;lVal;
1788         break;
1789 
1790         case VT_UI1:
1791         pDest-&gt;bVal = pSrc-&gt;bVal;
1792         break;
1793 
1794         case VT_I2:
1795         pDest-&gt;iVal = pSrc-&gt;iVal;
1796         break;
1797 
1798         case VT_R4:
1799         pDest-&gt;fltVal = pSrc-&gt;fltVal;
1800         break;
1801 
1802         case VT_R8:
1803         pDest-&gt;dblVal = pSrc-&gt;dblVal;
1804         break;
1805 
1806         case VT_BOOL:
1807         pDest-&gt;boolVal = pSrc-&gt;boolVal;
1808         break;
1809 
1810         case VT_ERROR:
1811         pDest-&gt;scode = pSrc-&gt;scode;
1812         break;
1813 
1814         case VT_CY:
1815         pDest-&gt;cyVal = pSrc-&gt;cyVal;
1816         break;
1817 
1818         case VT_DATE:
1819         pDest-&gt;date = pSrc-&gt;date;
1820         break;
1821 
1822         case VT_BSTR:
1823         if ((PVOID)pSrc-&gt;bstrVal == NULL) {
1824             pDest-&gt;bstrVal = NULL;
1825         } else {
1826 
1827             // a BSTR is a WORD followed by a UNICODE string.
1828             // the pointer points just after the WORD
1829 
1830             WORD len = * (WORD*) (pSrc-&gt;bstrVal - (sizeof(WORD) / sizeof(OLECHAR)));
1831             OLECHAR* pch = new OLECHAR[len + (sizeof(WORD)/sizeof(OLECHAR))];
1832                     if (pch) {
1833                 WORD *pui = (WORD*)pch;
1834                 *pui = len;
1835                     pDest-&gt;bstrVal = pch + (sizeof(WORD)/sizeof(OLECHAR));
1836                 CopyMemory(pDest-&gt;bstrVal, pSrc-&gt;bstrVal, len*sizeof(OLECHAR));
1837                     } else {
1838                         cArgs = i;
1839                         if (phr) {
1840                             *phr = E_OUTOFMEMORY;
1841                         }
1842                     }
1843         }
1844         break;
1845 
1846         case VT_UNKNOWN:
1847         pDest-&gt;punkVal = pSrc-&gt;punkVal;
1848         pDest-&gt;punkVal-&gt;AddRef();
1849         break;
1850 
1851         case VT_DISPATCH:
1852         pDest-&gt;pdispVal = pSrc-&gt;pdispVal;
1853         pDest-&gt;pdispVal-&gt;AddRef();
1854         break;
1855 
1856         default:
1857         // a type we haven&#39;t got round to adding yet!
1858         ASSERT(0);
1859         break;
1860         }
1861     }
1862 
1863     } else {
1864     rgvarg = NULL;
1865     }
1866 
1867 }
1868 
1869 
1870 CDispParams::~CDispParams()
1871 {
1872     for (UINT i = 0; i &lt; cArgs; i++) {
1873     switch(rgvarg[i].vt) {
1874         case VT_BSTR:
1875             //  Explicitly cast BSTR to PVOID to tell code scanning tools we really mean to test the pointer
1876         if ((PVOID)rgvarg[i].bstrVal != NULL) {
1877         OLECHAR * pch = rgvarg[i].bstrVal - (sizeof(WORD)/sizeof(OLECHAR));
1878         delete pch;
1879         }
1880         break;
1881 
1882     case VT_UNKNOWN:
1883         rgvarg[i].punkVal-&gt;Release();
1884         break;
1885 
1886     case VT_DISPATCH:
1887         rgvarg[i].pdispVal-&gt;Release();
1888         break;
1889     }
1890     }
1891     delete[] rgvarg;
1892 }
1893 
1894 
1895 // lifetime is controlled by refcounts (see defer.h)
1896 
1897 CDeferredCommand::CDeferredCommand(
1898     __inout CCmdQueue * pQ,
1899     __in_opt LPUNKNOWN  pUnk,
1900     __inout HRESULT *   phr,
1901     __in LPUNKNOWN  pUnkExecutor,
1902     REFTIME time,
1903     __in GUID*  iid,
1904     long    dispidMethod,
1905     short   wFlags,
1906     long    nArgs,
1907     __in_ecount(nArgs) VARIANT* pDispParams,
1908     __out VARIANT*  pvarResult,
1909     __out short*    puArgErr,
1910     BOOL    bStream
1911     ) :
1912     CUnknown(NAME(&quot;DeferredCommand&quot;), pUnk),
1913     m_pQueue(pQ),
1914     m_pUnk(pUnkExecutor),
1915     m_iid(iid),
1916     m_dispidMethod(dispidMethod),
1917     m_wFlags(wFlags),
1918     m_DispParams(nArgs, pDispParams, phr),
1919     m_pvarResult(pvarResult),
1920     m_bStream(bStream),
1921     m_hrResult(E_ABORT)
1922 
1923 {
1924     // convert REFTIME to REFERENCE_TIME
1925     COARefTime convertor(time);
1926     m_time = convertor;
1927 
1928     // no check of time validity - it&#39;s ok to queue a command that&#39;s
1929     // already late
1930 
1931     // check iid is supportable on pUnk by QueryInterface for it
1932     IUnknown * pInterface;
1933     HRESULT hr = m_pUnk-&gt;QueryInterface(GetIID(), (void**) &amp;pInterface);
1934     if (FAILED(hr)) {
1935     *phr = hr;
1936     return;
1937     }
1938     pInterface-&gt;Release();
1939 
1940 
1941     // !!! check dispidMethod and param/return types using typelib
1942     ITypeInfo *pti;
1943     hr = m_Dispatch.GetTypeInfo(*iid, 0, 0, &amp;pti);
1944     if (FAILED(hr)) {
1945     *phr = hr;
1946     return;
1947     }
1948     // !!! some sort of ITypeInfo validity check here
1949     pti-&gt;Release();
1950 
1951 
1952     // Fix up the dispid for put and get
1953     if (wFlags == DISPATCH_PROPERTYPUT) {
1954         m_DispParams.cNamedArgs = 1;
1955         m_DispId = DISPID_PROPERTYPUT;
1956         m_DispParams.rgdispidNamedArgs = &amp;m_DispId;
1957     }
1958 
1959     // all checks ok - add to queue
1960     hr = pQ-&gt;Insert(this);
1961     if (FAILED(hr)) {
1962     *phr = hr;
1963     }
1964 }
1965 
1966 
1967 // refcounts are held by caller of InvokeAt... and by list. So if
1968 // we get here, we can&#39;t be on the list
1969 
1970 #if 0
1971 CDeferredCommand::~CDeferredCommand()
1972 {
1973     // this assert is invalid since if the queue is deleted while we are
1974     // still on the queue, we will have been removed by the queue and this
1975     // m_pQueue will not have been modified.
1976     // ASSERT(m_pQueue == NULL);
1977 
1978     // we don&#39;t hold a ref count on pUnk, which is the object that should
1979     // execute the command.
1980     // This is because there would otherwise be a circular refcount problem
1981     // since pUnk probably owns the CmdQueue object that has a refcount
1982     // on us.
1983     // The lifetime of pUnk is guaranteed by it being part of, or lifetime
1984     // controlled by, our parent object. As long as we are on the list, pUnk
1985     // must be valid. Once we are off the list, we do not use pUnk.
1986 
1987 }
1988 #endif
1989 
1990 
1991 // overriden to publicise our interfaces
1992 
1993 STDMETHODIMP
1994 CDeferredCommand::NonDelegatingQueryInterface(REFIID riid, __out void **ppv)
1995 {
1996     ValidateReadWritePtr(ppv,sizeof(PVOID));
1997     if (riid == IID_IDeferredCommand) {
1998     return GetInterface( (IDeferredCommand *) this, ppv);
1999     } else {
2000     return CUnknown::NonDelegatingQueryInterface(riid, ppv);
2001     }
2002 }
2003 
2004 
2005 // remove from q. this will reduce the refcount by one (since the q
2006 // holds a count) but can&#39;t make us go away since he must have a
2007 // refcount in order to call this method.
2008 
2009 STDMETHODIMP
2010 CDeferredCommand::Cancel()
2011 {
2012     if (m_pQueue == NULL) {
2013     return VFW_E_ALREADY_CANCELLED;
2014     }
2015 
2016     HRESULT hr = m_pQueue-&gt;Remove(this);
2017     if (FAILED(hr)) {
2018     return hr;
2019     }
2020 
2021     m_pQueue = NULL;
2022     return S_OK;
2023 }
2024 
2025 
2026 STDMETHODIMP
2027 CDeferredCommand::Confidence(__out LONG* pConfidence)
2028 {
2029     return E_NOTIMPL;
2030 }
2031 
2032 
2033 STDMETHODIMP
2034 CDeferredCommand::GetHResult(__out HRESULT * phrResult)
2035 {
2036     CheckPointer(phrResult,E_POINTER);
2037     ValidateReadWritePtr(phrResult,sizeof(HRESULT));
2038 
2039     if (m_pQueue != NULL) {
2040     return E_ABORT;
2041     }
2042     *phrResult = m_hrResult;
2043     return S_OK;
2044 }
2045 
2046 
2047 // set the time to be a new time (checking that it is valid) and
2048 // then requeue
2049 
2050 STDMETHODIMP
2051 CDeferredCommand::Postpone(REFTIME newtime)
2052 {
2053 
2054     // check that this time is not past
2055     // convert REFTIME to REFERENCE_TIME
2056     COARefTime convertor(newtime);
2057 
2058     // check that the time has not passed
2059     if (m_pQueue-&gt;CheckTime(convertor, IsStreamTime())) {
2060     return VFW_E_TIME_ALREADY_PASSED;
2061     }
2062 
2063     // extract from list
2064     HRESULT hr = m_pQueue-&gt;Remove(this);
2065     if (FAILED(hr)) {
2066     return hr;
2067     }
2068 
2069     // change time
2070     m_time = convertor;
2071 
2072     // requeue
2073     hr = m_pQueue-&gt;Insert(this);
2074 
2075     return hr;
2076 }
2077 
2078 
2079 HRESULT
2080 CDeferredCommand::Invoke()
2081 {
2082     // check that we are still outstanding
2083     if (m_pQueue == NULL) {
2084     return VFW_E_ALREADY_CANCELLED;
2085     }
2086 
2087     // get the type info
2088     ITypeInfo* pti;
2089     HRESULT hr = m_Dispatch.GetTypeInfo(GetIID(), 0, 0, &amp;pti);
2090     if (FAILED(hr)) {
2091     return hr;
2092     }
2093 
2094     // qi for the expected interface and then invoke it. Note that we have to
2095     // treat the returned interface as IUnknown since we don&#39;t know its type.
2096     IUnknown* pInterface;
2097 
2098     hr = m_pUnk-&gt;QueryInterface(GetIID(), (void**) &amp;pInterface);
2099     if (FAILED(hr)) {
2100     pti-&gt;Release();
2101     return hr;
2102     }
2103 
2104     EXCEPINFO expinfo;
2105     UINT uArgErr;
2106     m_hrResult = pti-&gt;Invoke(
2107     pInterface,
2108     GetMethod(),
2109     GetFlags(),
2110     GetParams(),
2111     GetResult(),
2112     &amp;expinfo,
2113     &amp;uArgErr);
2114 
2115     // release the interface we QI&#39;d for
2116     pInterface-&gt;Release();
2117     pti-&gt;Release();
2118 
2119 
2120     // remove from list whether or not successful
2121     // or we loop indefinitely
2122     hr = m_pQueue-&gt;Remove(this);
2123     m_pQueue = NULL;
2124     return hr;
2125 }
2126 
2127 
2128 
2129 // --- CCmdQueue methods ----------
2130 
2131 
2132 CCmdQueue::CCmdQueue(__inout_opt HRESULT *phr) :
2133     m_listPresentation(NAME(&quot;Presentation time command list&quot;)),
2134     m_listStream(NAME(&quot;Stream time command list&quot;)),
2135     m_evDue(TRUE, phr),    // manual reset
2136     m_dwAdvise(0),
2137     m_pClock(NULL),
2138     m_bRunning(FALSE)
2139 {
2140 }
2141 
2142 
2143 CCmdQueue::~CCmdQueue()
2144 {
2145     // empty all our lists
2146 
2147     // we hold a refcount on each, so traverse and Release each
2148     // entry then RemoveAll to empty the list
2149     POSITION pos = m_listPresentation.GetHeadPosition();
2150 
2151     while(pos) {
2152     CDeferredCommand* pCmd = m_listPresentation.GetNext(pos);
2153     pCmd-&gt;Release();
2154     }
2155     m_listPresentation.RemoveAll();
2156 
2157     pos = m_listStream.GetHeadPosition();
2158 
2159     while(pos) {
2160     CDeferredCommand* pCmd = m_listStream.GetNext(pos);
2161     pCmd-&gt;Release();
2162     }
2163     m_listStream.RemoveAll();
2164 
2165     if (m_pClock) {
2166     if (m_dwAdvise) {
2167         m_pClock-&gt;Unadvise(m_dwAdvise);
2168         m_dwAdvise = 0;
2169     }
2170     m_pClock-&gt;Release();
2171     }
2172 }
2173 
2174 
2175 // returns a new CDeferredCommand object that will be initialised with
2176 // the parameters and will be added to the queue during construction.
2177 // returns S_OK if successfully created otherwise an error and
2178 // no object has been queued.
2179 
2180 HRESULT
2181 CCmdQueue::New(
2182     __out CDeferredCommand **ppCmd,
2183     __in     LPUNKNOWN  pUnk,       // this object will execute command
2184     REFTIME time,
2185     __in GUID*  iid,
2186     long    dispidMethod,
2187     short   wFlags,
2188     long    cArgs,
2189     __in_ecount(cArgs) VARIANT* pDispParams,
2190     __out VARIANT*  pvarResult,
2191     __out short*    puArgErr,
2192     BOOL    bStream
2193 )
2194 {
2195     CAutoLock lock(&amp;m_Lock);
2196 
2197     HRESULT hr = S_OK;
2198     *ppCmd = NULL;
2199 
2200     CDeferredCommand* pCmd;
2201     pCmd = new CDeferredCommand(
2202             this,
2203             NULL,       // not aggregated
2204             &amp;hr,
2205             pUnk,       // this guy will execute
2206             time,
2207             iid,
2208             dispidMethod,
2209             wFlags,
2210             cArgs,
2211             pDispParams,
2212             pvarResult,
2213             puArgErr,
2214             bStream);
2215 
2216     if (pCmd == NULL) {
2217     hr = E_OUTOFMEMORY;
2218     } else {
2219     *ppCmd = pCmd;
2220     }
2221     return hr;
2222 }
2223 
2224 
2225 HRESULT
2226 CCmdQueue::Insert(__in CDeferredCommand* pCmd)
2227 {
2228     CAutoLock lock(&amp;m_Lock);
2229 
2230     // addref the item
2231     pCmd-&gt;AddRef();
2232 
2233     CGenericList&lt;CDeferredCommand&gt; * pList;
2234     if (pCmd-&gt;IsStreamTime()) {
2235     pList = &amp;m_listStream;
2236     } else {
2237     pList = &amp;m_listPresentation;
2238     }
2239     POSITION pos = pList-&gt;GetHeadPosition();
2240 
2241     // seek past all items that are before us
2242     while (pos &amp;&amp;
2243     (pList-&gt;GetValid(pos)-&gt;GetTime() &lt;= pCmd-&gt;GetTime())) {
2244 
2245     pList-&gt;GetNext(pos);
2246     }
2247 
2248     // now at end of list or in front of items that come later
2249     if (!pos) {
2250     pList-&gt;AddTail(pCmd);
2251     } else {
2252     pList-&gt;AddBefore(pos, pCmd);
2253     }
2254 
2255     SetTimeAdvise();
2256     return S_OK;
2257 }
2258 
2259 
2260 HRESULT
2261 CCmdQueue::Remove(__in CDeferredCommand* pCmd)
2262 {
2263     CAutoLock lock(&amp;m_Lock);
2264     HRESULT hr = S_OK;
2265 
2266     CGenericList&lt;CDeferredCommand&gt; * pList;
2267     if (pCmd-&gt;IsStreamTime()) {
2268     pList = &amp;m_listStream;
2269     } else {
2270     pList = &amp;m_listPresentation;
2271     }
2272     POSITION pos = pList-&gt;GetHeadPosition();
2273 
2274     // traverse the list
2275     while (pos &amp;&amp; (pList-&gt;GetValid(pos) != pCmd)) {
2276     pList-&gt;GetNext(pos);
2277     }
2278 
2279     // did we drop off the end?
2280     if (!pos) {
2281     hr = VFW_E_NOT_FOUND;
2282     } else {
2283 
2284     // found it - now take off list
2285     pList-&gt;Remove(pos);
2286 
2287     // Insert did an AddRef, so release it
2288     pCmd-&gt;Release();
2289 
2290     // check that timer request is still for earliest time
2291     SetTimeAdvise();
2292     }
2293     return hr;
2294 }
2295 
2296 
2297 // set the clock used for timing
2298 
2299 HRESULT
2300 CCmdQueue::SetSyncSource(__in_opt IReferenceClock* pClock)
2301 {
2302     CAutoLock lock(&amp;m_Lock);
2303 
2304     // addref the new clock first in case they are the same
2305     if (pClock) {
2306     pClock-&gt;AddRef();
2307     }
2308 
2309     // kill any advise on the old clock
2310     if (m_pClock) {
2311     if (m_dwAdvise) {
2312         m_pClock-&gt;Unadvise(m_dwAdvise);
2313         m_dwAdvise = 0;
2314     }
2315     m_pClock-&gt;Release();
2316     }
2317     m_pClock = pClock;
2318 
2319     // set up a new advise
2320     SetTimeAdvise();
2321     return S_OK;
2322 }
2323 
2324 
2325 // set up a timer event with the reference clock
2326 
2327 void
2328 CCmdQueue::SetTimeAdvise(void)
2329 {
2330     // make sure we have a clock to use
2331     if (!m_pClock) {
2332     return;
2333     }
2334 
2335     // reset the event whenever we are requesting a new signal
2336     m_evDue.Reset();
2337 
2338     // time 0 is earliest
2339     CRefTime current;
2340 
2341     // find the earliest presentation time
2342     POSITION pos = m_listPresentation.GetHeadPosition();
2343     if (pos != NULL) {
2344     current = m_listPresentation.GetValid(pos)-&gt;GetTime();
2345     }
2346 
2347     // if we&#39;re running, check the stream times too
2348     if (m_bRunning) {
2349 
2350     CRefTime t;
2351         pos = m_listStream.GetHeadPosition();
2352     if (NULL != pos) {
2353         t = m_listStream.GetValid(pos)-&gt;GetTime();
2354 
2355         // add on stream time offset to get presentation time
2356         t += m_StreamTimeOffset;
2357 
2358         // is this earlier?
2359         if ((current == TimeZero) || (t &lt; current)) {
2360         current = t;
2361         }
2362     }
2363     }
2364 
2365     // need to change?
2366     if ((current &gt; TimeZero) &amp;&amp; (current != m_tCurrentAdvise)) {
2367     if (m_dwAdvise) {
2368         m_pClock-&gt;Unadvise(m_dwAdvise);
2369         // reset the event whenever we are requesting a new signal
2370         m_evDue.Reset();
2371     }
2372 
2373     // ask for time advice - the first two params are either
2374     // stream time offset and stream time or
2375     // presentation time and 0. we always use the latter
2376     HRESULT hr = m_pClock-&gt;AdviseTime(
2377             (REFERENCE_TIME)current,
2378             TimeZero,
2379             (HEVENT) HANDLE(m_evDue),
2380             &amp;m_dwAdvise);
2381 
2382     ASSERT(SUCCEEDED(hr));
2383     m_tCurrentAdvise = current;
2384     }
2385 }
2386 
2387 
2388 // switch to run mode. Streamtime to Presentation time mapping known.
2389 
2390 HRESULT
2391 CCmdQueue::Run(REFERENCE_TIME tStreamTimeOffset)
2392 {
2393     CAutoLock lock(&amp;m_Lock);
2394 
2395     m_StreamTimeOffset = tStreamTimeOffset;
2396     m_bRunning = TRUE;
2397 
2398     // ensure advise is accurate
2399     SetTimeAdvise();
2400     return S_OK;
2401 }
2402 
2403 
2404 // switch to Stopped or Paused mode. Time mapping not known.
2405 
2406 HRESULT
2407 CCmdQueue::EndRun()
2408 {
2409     CAutoLock lock(&amp;m_Lock);
2410 
2411     m_bRunning = FALSE;
2412 
2413     // check timer setting - stream times
2414     SetTimeAdvise();
2415     return S_OK;
2416 }
2417 
2418 
2419 // return a pointer to the next due command. Blocks for msTimeout
2420 // milliseconds until there is a due command.
2421 // Stream-time commands will only become due between Run and Endrun calls.
2422 // The command remains queued until invoked or cancelled.
2423 // Returns E_ABORT if timeout occurs, otherwise S_OK (or other error).
2424 //
2425 // returns an AddRef&#39;d object
2426 
2427 HRESULT
2428 CCmdQueue::GetDueCommand(__out CDeferredCommand ** ppCmd, long msTimeout)
2429 {
2430     // loop until we timeout or find a due command
2431     for (;;) {
2432 
2433     {
2434         CAutoLock lock(&amp;m_Lock);
2435 
2436 
2437         // find the earliest command
2438         CDeferredCommand * pCmd = NULL;
2439 
2440         // check the presentation time and the
2441         // stream time list to find the earliest
2442 
2443             POSITION pos = m_listPresentation.GetHeadPosition();
2444 
2445         if (NULL != pos) {
2446         pCmd = m_listPresentation.GetValid(pos);
2447         }
2448 
2449         if (m_bRunning) {
2450         pos = m_listStream.GetHeadPosition();
2451                 if (NULL != pos) {
2452                     CDeferredCommand* pStrm = m_listStream.GetValid(pos);
2453 
2454                     CRefTime t = pStrm-&gt;GetTime() + m_StreamTimeOffset;
2455                     if (!pCmd || (t &lt; pCmd-&gt;GetTime())) {
2456                         pCmd = pStrm;
2457                     }
2458                 }
2459             }
2460 
2461         //  if we have found one, is it due?
2462         if (pCmd) {
2463         if (CheckTime(pCmd-&gt;GetTime(), pCmd-&gt;IsStreamTime())) {
2464 
2465             // yes it&#39;s due - addref it
2466             pCmd-&gt;AddRef();
2467             *ppCmd = pCmd;
2468             return S_OK;
2469         }
2470         }
2471     }
2472 
2473     // block until the advise is signalled
2474     if (WaitForSingleObject(m_evDue, msTimeout) != WAIT_OBJECT_0) {
2475         return E_ABORT;
2476     }
2477     }
2478 }
2479 
2480 
2481 // return a pointer to a command that will be due for a given time.
2482 // Pass in a stream time here. The stream time offset will be passed
2483 // in via the Run method.
2484 // Commands remain queued until invoked or cancelled.
2485 // This method will not block. It will report E_ABORT if there are no
2486 // commands due yet.
2487 //
2488 // returns an AddRef&#39;d object
2489 
2490 HRESULT
2491 CCmdQueue::GetCommandDueFor(REFERENCE_TIME rtStream, __out CDeferredCommand**ppCmd)
2492 {
2493     CAutoLock lock(&amp;m_Lock);
2494 
2495     CRefTime tStream(rtStream);
2496 
2497     // find the earliest stream and presentation time commands
2498     CDeferredCommand* pStream = NULL;
2499     POSITION pos = m_listStream.GetHeadPosition();
2500     if (NULL != pos) {
2501     pStream = m_listStream.GetValid(pos);
2502     }
2503     CDeferredCommand* pPresent = NULL;
2504     pos = m_listPresentation.GetHeadPosition();
2505     if (NULL != pos) {
2506     pPresent = m_listPresentation.GetValid(pos);
2507     }
2508 
2509     // is there a presentation time that has passed already
2510     if (pPresent &amp;&amp; CheckTime(pPresent-&gt;GetTime(), FALSE)) {
2511     pPresent-&gt;AddRef();
2512     *ppCmd = pPresent;
2513     return S_OK;
2514     }
2515 
2516     // is there a stream time command due before this stream time
2517     if (pStream &amp;&amp; (pStream-&gt;GetTime() &lt;= tStream)) {
2518     pStream-&gt;AddRef();
2519     *ppCmd = pStream;
2520     return S_OK;
2521     }
2522 
2523     // if we are running, we can map presentation times to
2524     // stream time. In this case, is there a presentation time command
2525     // that will be due before this stream time is presented?
2526     if (m_bRunning &amp;&amp; pPresent) {
2527 
2528     // this stream time will appear at...
2529     tStream += m_StreamTimeOffset;
2530 
2531     // due before that?
2532     if (pPresent-&gt;GetTime() &lt;= tStream) {
2533         *ppCmd = pPresent;
2534         return S_OK;
2535     }
2536     }
2537 
2538     // no commands due yet
2539     return VFW_E_NOT_FOUND;
2540 }
2541 
    </pre>
  </body>
</html>
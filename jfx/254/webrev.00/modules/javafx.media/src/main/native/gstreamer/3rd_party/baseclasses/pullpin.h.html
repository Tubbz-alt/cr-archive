<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/baseclasses/pullpin.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 //------------------------------------------------------------------------------
  2 // File: PullPin.h
  3 //
  4 // Desc: DirectShow base classes - defines CPullPin class.
  5 //
  6 // Copyright (c) 1992-2001 Microsoft Corporation.  All rights reserved.
  7 //------------------------------------------------------------------------------
  8 
  9 
 10 #ifndef __PULLPIN_H__
 11 #define __PULLPIN_H__
 12 
 13 //
 14 // CPullPin
 15 //
 16 // object supporting pulling data from an IAsyncReader interface.
 17 // Given a start/stop position, calls a pure Receive method with each
 18 // IMediaSample received.
 19 //
 20 // This is essentially for use in a MemInputPin when it finds itself
 21 // connected to an IAsyncReader pin instead of a pushing pin.
 22 //
 23 
 24 class CPullPin : public CAMThread
 25 {
 26     IAsyncReader*       m_pReader;
 27     REFERENCE_TIME      m_tStart;
 28     REFERENCE_TIME      m_tStop;
 29     REFERENCE_TIME      m_tDuration;
 30     BOOL                m_bSync;
 31 
 32     enum ThreadMsg {
 33     TM_Pause,       // stop pulling and wait for next message
 34     TM_Start,       // start pulling
 35     TM_Exit,        // stop and exit
 36     };
 37 
 38     ThreadMsg m_State;
 39 
 40     // override pure thread proc from CAMThread
 41     DWORD ThreadProc(void);
 42 
 43     // running pull method (check m_bSync)
 44     void Process(void);
 45 
 46     // clean up any cancelled i/o after a flush
 47     void CleanupCancelled(void);
 48 
 49     // suspend thread from pulling, eg during seek
 50     HRESULT PauseThread();
 51 
 52     // start thread pulling - create thread if necy
 53     HRESULT StartThread();
 54 
 55     // stop and close thread
 56     HRESULT StopThread();
 57 
 58     // called from ProcessAsync to queue and collect requests
 59     HRESULT QueueSample(
 60         __inout REFERENCE_TIME&amp; tCurrent,
 61         REFERENCE_TIME tAlignStop,
 62         BOOL bDiscontinuity);
 63 
 64     HRESULT CollectAndDeliver(
 65         REFERENCE_TIME tStart,
 66         REFERENCE_TIME tStop);
 67 
 68     HRESULT DeliverSample(
 69         IMediaSample* pSample,
 70         REFERENCE_TIME tStart,
 71         REFERENCE_TIME tStop);
 72 
 73 protected:
 74     IMemAllocator *     m_pAlloc;
 75 
 76 public:
 77     CPullPin();
 78     virtual ~CPullPin();
 79 
 80     // returns S_OK if successfully connected to an IAsyncReader interface
 81     // from this object
 82     // Optional allocator should be proposed as a preferred allocator if
 83     // necessary
 84     // bSync is TRUE if we are to use sync reads instead of the
 85     // async methods.
 86     HRESULT Connect(IUnknown* pUnk, IMemAllocator* pAlloc, BOOL bSync);
 87 
 88     // disconnect any connection made in Connect
 89     HRESULT Disconnect();
 90 
 91     // agree an allocator using RequestAllocator - optional
 92     // props param specifies your requirements (non-zero fields).
 93     // returns an error code if fail to match requirements.
 94     // optional IMemAllocator interface is offered as a preferred allocator
 95     // but no error occurs if it can&#39;t be met.
 96     virtual HRESULT DecideAllocator(
 97         IMemAllocator* pAlloc,
 98         __inout_opt ALLOCATOR_PROPERTIES * pProps);
 99 
100     // set start and stop position. if active, will start immediately at
101     // the new position. Default is 0 to duration
102     HRESULT Seek(REFERENCE_TIME tStart, REFERENCE_TIME tStop);
103 
104     // return the total duration
105     HRESULT Duration(__out REFERENCE_TIME* ptDuration);
106 
107     // start pulling data
108     HRESULT Active(void);
109 
110     // stop pulling data
111     HRESULT Inactive(void);
112 
113     // helper functions
114     LONGLONG AlignDown(LONGLONG ll, LONG lAlign) {
115     // aligning downwards is just truncation
116     return ll &amp; ~(lAlign-1);
117     };
118 
119     LONGLONG AlignUp(LONGLONG ll, LONG lAlign) {
120     // align up: round up to next boundary
121     return (ll + (lAlign -1)) &amp; ~(lAlign -1);
122     };
123 
124     // GetReader returns the (addrefed) IAsyncReader interface
125     // for SyncRead etc
126     IAsyncReader* GetReader() {
127     m_pReader-&gt;AddRef();
128     return m_pReader;
129     };
130 
131     // -- pure --
132 
133     // override this to handle data arrival
134     // return value other than S_OK will stop data
135     virtual HRESULT Receive(IMediaSample*) PURE;
136 
137     // override this to handle end-of-stream
138     virtual HRESULT EndOfStream(void) PURE;
139 
140     // called on runtime errors that will have caused pulling
141     // to stop
142     // these errors are all returned from the upstream filter, who
143     // will have already reported any errors to the filtergraph.
144     virtual void OnError(HRESULT hr) PURE;
145 
146     // flush this pin and all downstream
147     virtual HRESULT BeginFlush() PURE;
148     virtual HRESULT EndFlush() PURE;
149 
150 };
151 
152 #endif //__PULLPIN_H__
    </pre>
  </body>
</html>
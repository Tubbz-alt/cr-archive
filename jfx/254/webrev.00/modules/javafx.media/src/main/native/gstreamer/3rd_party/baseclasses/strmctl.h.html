<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/baseclasses/strmctl.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 //------------------------------------------------------------------------------
  2 // File: StrmCtl.h
  3 //
  4 // Desc: DirectShow base classes.
  5 //
  6 // Copyright (c) 1996-2001 Microsoft Corporation.  All rights reserved.
  7 //------------------------------------------------------------------------------
  8 
  9 
 10 #ifndef __strmctl_h__
 11 #define __strmctl_h__
 12 
 13 class CBaseStreamControl : public IAMStreamControl
 14 {
 15 public:
 16     // Used by the implementation
 17     enum StreamControlState
 18     { STREAM_FLOWING = 0x1000,
 19       STREAM_DISCARDING
 20     };
 21 
 22 private:
 23     enum StreamControlState m_StreamState;      // Current stream state
 24     enum StreamControlState m_StreamStateOnStop;    // State after next stop
 25                         // (i.e.Blocking or Discarding)
 26 
 27     REFERENCE_TIME  m_tStartTime;       // MAX_TIME implies none
 28     REFERENCE_TIME  m_tStopTime;        // MAX_TIME implies none
 29     DWORD       m_dwStartCookie;    // Cookie for notification to app
 30     DWORD       m_dwStopCookie;     // Cookie for notification to app
 31     volatile BOOL       m_bIsFlushing;        // No optimization pls!
 32     volatile BOOL   m_bStopSendExtra;   // bSendExtra was set
 33     volatile BOOL   m_bStopExtraSent;   // the extra one was sent
 34 
 35     CCritSec        m_CritSec;      // CritSec to guard above attributes
 36 
 37     // Event to fire when we can come
 38     // out of blocking, or to come out of waiting
 39     // to discard if we change our minds.
 40     //
 41     CAMEvent            m_StreamEvent;
 42 
 43     // All of these methods execute immediately.  Helpers for others.
 44     //
 45     void ExecuteStop();
 46     void ExecuteStart();
 47     void CancelStop();
 48     void CancelStart();
 49 
 50     // Some things we need to be told by our owning filter
 51     // Your pin must also expose IAMStreamControl when QI&#39;d for it!
 52     //
 53     IReferenceClock *   m_pRefClock;        // Need it to set advises
 54                         // Filter must tell us via
 55                         // SetSyncSource
 56     IMediaEventSink *   m_pSink;            // Event sink
 57                         // Filter must tell us after it
 58                         // creates it in JoinFilterGraph()
 59     FILTER_STATE    m_FilterState;      // Just need it!
 60                         // Filter must tell us via
 61                         // NotifyFilterState
 62     REFERENCE_TIME  m_tRunStart;        // Per the Run call to the filter
 63 
 64     // This guy will return one of the three StreamControlState&#39;s.  Here&#39;s what
 65     // the caller should do for each one:
 66     //
 67     // STREAM_FLOWING:      Proceed as usual (render or pass the sample on)
 68     // STREAM_DISCARDING:   Calculate the time &#39;til *pSampleStop and wait
 69     //              that long for the event handle
 70     //              (GetStreamEventHandle()).  If the wait
 71     //              expires, throw the sample away.  If the event
 72     //              fires, call me back - I&#39;ve changed my mind.
 73     //
 74     enum StreamControlState CheckSampleTimes( __in const REFERENCE_TIME * pSampleStart,
 75                           __in const REFERENCE_TIME * pSampleStop );
 76 
 77 public:
 78     // You don&#39;t have to tell us much when we&#39;re created, but there are other
 79     // obligations that must be met.  See SetSyncSource &amp; NotifyFilterState
 80     // below.
 81     //
 82     CBaseStreamControl(__inout_opt HRESULT *phr = NULL);
 83     ~CBaseStreamControl();
 84 
 85     // If you want this class to work properly, there are thing you need to
 86     // (keep) telling it.  Filters with pins that use this class
 87     // should ensure that they pass through to this method any calls they
 88     // receive on their SetSyncSource.
 89 
 90     // We need a clock to see what time it is.  This is for the
 91     // &quot;discard in a timely fashion&quot; logic.  If we discard everything as
 92     // quick as possible, a whole 60 minute file could get discarded in the
 93     // first 10 seconds, and if somebody wants to turn streaming on at 30
 94     // minutes into the file, and they make the call more than a few seconds
 95     // after the graph is run, it may be too late!
 96     // So we hold every sample until it&#39;s time has gone, then we discard it.
 97     // The filter should call this when it gets a SetSyncSource
 98     //
 99     void SetSyncSource( IReferenceClock * pRefClock )
100     {
101     CAutoLock lck(&amp;m_CritSec);
102     if (m_pRefClock) m_pRefClock-&gt;Release();
103     m_pRefClock = pRefClock;
104     if (m_pRefClock) m_pRefClock-&gt;AddRef();
105     }
106 
107     // Set event sink for notifications
108     // The filter should call this in its JoinFilterGraph after it creates the
109     // IMediaEventSink
110     //
111     void SetFilterGraph( IMediaEventSink *pSink ) {
112         m_pSink = pSink;
113     }
114 
115     // Since we schedule in stream time, we need the tStart and must track the
116     // state of our owning filter.
117     // The app should call this ever state change
118     //
119     void NotifyFilterState( FILTER_STATE new_state, REFERENCE_TIME tStart = 0 );
120 
121     // Filter should call Flushing(TRUE) in BeginFlush,
122     // and Flushing(FALSE) in EndFlush.
123     //
124     void Flushing( BOOL bInProgress );
125 
126 
127     // The two main methods of IAMStreamControl
128 
129     // Class adds default values suitable for immediate
130     // muting and unmuting of the stream.
131 
132     STDMETHODIMP StopAt( const REFERENCE_TIME * ptStop = NULL,
133              BOOL bSendExtra = FALSE,
134              DWORD dwCookie = 0 );
135     STDMETHODIMP StartAt( const REFERENCE_TIME * ptStart = NULL,
136                   DWORD dwCookie = 0 );
137     STDMETHODIMP GetInfo( __out AM_STREAM_INFO *pInfo);
138 
139     // Helper function for pin&#39;s receive method.  Call this with
140     // the sample and we&#39;ll tell you what to do with it.  We&#39;ll do a
141     // WaitForSingleObject within this call if one is required.  This is
142     // a &quot;What should I do with this sample?&quot; kind of call. We&#39;ll tell the
143     // caller to either flow it or discard it.
144     // If pSample is NULL we evaluate based on the current state
145     // settings
146     enum StreamControlState CheckStreamState( IMediaSample * pSample );
147 
148 private:
149     // These don&#39;t require locking, but we are relying on the fact that
150     // m_StreamState can be retrieved with integrity, and is a snap shot that
151     // may have just been, or may be just about to be, changed.
152     HANDLE GetStreamEventHandle() const { return m_StreamEvent; }
153     enum StreamControlState GetStreamState() const { return m_StreamState; }
154     BOOL IsStreaming() const { return m_StreamState == STREAM_FLOWING; }
155 };
156 
157 #endif
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/baseclasses/videoctl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 //------------------------------------------------------------------------------
  2 // File: VideoCtl.cpp
  3 //
  4 // Desc: DirectShow base classes.
  5 //
  6 // Copyright (c) 1992-2001 Microsoft Corporation.  All rights reserved.
  7 //------------------------------------------------------------------------------
  8 
  9 
 10 #include &lt;streams.h&gt;
 11 #include &quot;ddmm.h&quot;
 12 
 13 // Load a string from the resource file string table. The buffer must be at
 14 // least STR_MAX_LENGTH bytes. The easiest way to use this is to declare a
 15 // buffer in the property page class and use it for all string loading. It
 16 // cannot be static as multiple property pages may be active simultaneously
 17 
 18 LPTSTR WINAPI StringFromResource(__out_ecount(STR_MAX_LENGTH) LPTSTR pBuffer, int iResourceID)
 19 {
 20     if (LoadString(g_hInst,iResourceID,pBuffer,STR_MAX_LENGTH) == 0) {
 21         return TEXT(&quot;&quot;);
 22     }
 23     return pBuffer;
 24 }
 25 
 26 #ifdef UNICODE
 27 LPSTR WINAPI StringFromResource(__out_ecount(STR_MAX_LENGTH) LPSTR pBuffer, int iResourceID)
 28 {
 29     if (LoadStringA(g_hInst,iResourceID,pBuffer,STR_MAX_LENGTH) == 0) {
 30         return &quot;&quot;;
 31     }
 32     return pBuffer;
 33 }
 34 #endif
 35 
 36 
 37 
 38 // Property pages typically are called through their OLE interfaces. These
 39 // use UNICODE strings regardless of how the binary is built. So when we
 40 // load strings from the resource file we sometimes want to convert them
 41 // to UNICODE. This method is passed the target UNICODE buffer and does a
 42 // convert after loading the string (if built UNICODE this is not needed)
 43 // On WinNT we can explicitly call LoadStringW which saves two conversions
 44 
 45 #ifndef UNICODE
 46 
 47 LPWSTR WINAPI WideStringFromResource(__out_ecount(STR_MAX_LENGTH) LPWSTR pBuffer, int iResourceID)
 48 {
 49     *pBuffer = 0;
 50 
 51     if (g_amPlatform == VER_PLATFORM_WIN32_NT) {
 52     LoadStringW(g_hInst,iResourceID,pBuffer,STR_MAX_LENGTH);
 53     } else {
 54 
 55     CHAR szBuffer[STR_MAX_LENGTH];
 56     DWORD dwStringLength = LoadString(g_hInst,iResourceID,szBuffer,STR_MAX_LENGTH);
 57     // if we loaded a string convert it to wide characters, ensuring
 58     // that we also null terminate the result.
 59     if (dwStringLength++) {
 60         MultiByteToWideChar(CP_ACP,0,szBuffer,dwStringLength,pBuffer,STR_MAX_LENGTH);
 61     }
 62     }
 63     return pBuffer;
 64 }
 65 
 66 #endif
 67 
 68 
 69 // Helper function to calculate the size of the dialog
 70 
 71 BOOL WINAPI GetDialogSize(int iResourceID,
 72                           DLGPROC pDlgProc,
 73                           LPARAM lParam,
 74                           __out SIZE *pResult)
 75 {
 76     RECT rc;
 77     HWND hwnd;
 78 
 79     // Create a temporary property page
 80 
 81     hwnd = CreateDialogParam(g_hInst,
 82                              MAKEINTRESOURCE(iResourceID),
 83                              GetDesktopWindow(),
 84                              pDlgProc,
 85                              lParam);
 86     if (hwnd == NULL) {
 87         return FALSE;
 88     }
 89 
 90     GetWindowRect(hwnd, &amp;rc);
 91     pResult-&gt;cx = rc.right - rc.left;
 92     pResult-&gt;cy = rc.bottom - rc.top;
 93 
 94     DestroyWindow(hwnd);
 95     return TRUE;
 96 }
 97 
 98 
 99 // Class that aggregates on the IDirectDraw interface. Although DirectDraw
100 // has the ability in its interfaces to be aggregated they&#39;re not currently
101 // implemented. This makes it difficult for various parts of Quartz that want
102 // to aggregate these interfaces. In particular the video renderer passes out
103 // media samples that expose IDirectDraw and IDirectDrawSurface. The filter
104 // graph manager also exposes IDirectDraw as a plug in distributor. For these
105 // objects we provide these aggregation classes that republish the interfaces
106 
107 STDMETHODIMP CAggDirectDraw::NonDelegatingQueryInterface(REFIID riid, __deref_out void **ppv)
108 {
109     ASSERT(m_pDirectDraw);
110 
111     // Do we have this interface
112 
113     if (riid == IID_IDirectDraw) {
114         return GetInterface((IDirectDraw *)this,ppv);
115     } else {
116         return CUnknown::NonDelegatingQueryInterface(riid,ppv);
117     }
118 }
119 
120 
121 STDMETHODIMP CAggDirectDraw::Compact()
122 {
123     ASSERT(m_pDirectDraw);
124     return m_pDirectDraw-&gt;Compact();
125 }
126 
127 
128 STDMETHODIMP CAggDirectDraw::CreateClipper(DWORD dwFlags, __deref_out LPDIRECTDRAWCLIPPER *lplpDDClipper, __inout_opt IUnknown *pUnkOuter)
129 {
130     ASSERT(m_pDirectDraw);
131     return m_pDirectDraw-&gt;CreateClipper(dwFlags,lplpDDClipper,pUnkOuter);
132 }
133 
134 
135 STDMETHODIMP CAggDirectDraw::CreatePalette(DWORD dwFlags,
136                                            __in LPPALETTEENTRY lpColorTable,
137                                            __deref_out LPDIRECTDRAWPALETTE *lplpDDPalette,
138                                            __inout_opt IUnknown *pUnkOuter)
139 {
140     ASSERT(m_pDirectDraw);
141     return m_pDirectDraw-&gt;CreatePalette(dwFlags,lpColorTable,lplpDDPalette,pUnkOuter);
142 }
143 
144 
145 STDMETHODIMP CAggDirectDraw::CreateSurface(__in LPDDSURFACEDESC lpDDSurfaceDesc,
146                                            __deref_out LPDIRECTDRAWSURFACE *lplpDDSurface,
147                                            __inout_opt IUnknown *pUnkOuter)
148 {
149     ASSERT(m_pDirectDraw);
150     return m_pDirectDraw-&gt;CreateSurface(lpDDSurfaceDesc,lplpDDSurface,pUnkOuter);
151 }
152 
153 
154 STDMETHODIMP CAggDirectDraw::DuplicateSurface(__in LPDIRECTDRAWSURFACE lpDDSurface,
155                                               __deref_out LPDIRECTDRAWSURFACE *lplpDupDDSurface)
156 {
157     ASSERT(m_pDirectDraw);
158     return m_pDirectDraw-&gt;DuplicateSurface(lpDDSurface,lplpDupDDSurface);
159 }
160 
161 
162 STDMETHODIMP CAggDirectDraw::EnumDisplayModes(DWORD dwSurfaceDescCount,
163                                               __in LPDDSURFACEDESC lplpDDSurfaceDescList,
164                                               __in LPVOID lpContext,
165                                               __in LPDDENUMMODESCALLBACK lpEnumCallback)
166 {
167     ASSERT(m_pDirectDraw);
168     return m_pDirectDraw-&gt;EnumDisplayModes(dwSurfaceDescCount,lplpDDSurfaceDescList,lpContext,lpEnumCallback);
169 }
170 
171 
172 STDMETHODIMP CAggDirectDraw::EnumSurfaces(DWORD dwFlags,
173                                           __in LPDDSURFACEDESC lpDDSD,
174                                           __in LPVOID lpContext,
175                                           __in LPDDENUMSURFACESCALLBACK lpEnumCallback)
176 {
177     ASSERT(m_pDirectDraw);
178     return m_pDirectDraw-&gt;EnumSurfaces(dwFlags,lpDDSD,lpContext,lpEnumCallback);
179 }
180 
181 
182 STDMETHODIMP CAggDirectDraw::FlipToGDISurface()
183 {
184     ASSERT(m_pDirectDraw);
185     return m_pDirectDraw-&gt;FlipToGDISurface();
186 }
187 
188 
189 STDMETHODIMP CAggDirectDraw::GetCaps(__out LPDDCAPS lpDDDriverCaps,__out LPDDCAPS lpDDHELCaps)
190 {
191     ASSERT(m_pDirectDraw);
192     return m_pDirectDraw-&gt;GetCaps(lpDDDriverCaps,lpDDHELCaps);
193 }
194 
195 
196 STDMETHODIMP CAggDirectDraw::GetDisplayMode(__out LPDDSURFACEDESC lpDDSurfaceDesc)
197 {
198     ASSERT(m_pDirectDraw);
199     return m_pDirectDraw-&gt;GetDisplayMode(lpDDSurfaceDesc);
200 }
201 
202 
203 STDMETHODIMP CAggDirectDraw::GetFourCCCodes(__inout LPDWORD lpNumCodes,__out_ecount(*lpNumCodes) LPDWORD lpCodes)
204 {
205     ASSERT(m_pDirectDraw);
206     return m_pDirectDraw-&gt;GetFourCCCodes(lpNumCodes,lpCodes);
207 }
208 
209 
210 STDMETHODIMP CAggDirectDraw::GetGDISurface(__deref_out LPDIRECTDRAWSURFACE *lplpGDIDDSurface)
211 {
212     ASSERT(m_pDirectDraw);
213     return m_pDirectDraw-&gt;GetGDISurface(lplpGDIDDSurface);
214 }
215 
216 
217 STDMETHODIMP CAggDirectDraw::GetMonitorFrequency(__out LPDWORD lpdwFrequency)
218 {
219     ASSERT(m_pDirectDraw);
220     return m_pDirectDraw-&gt;GetMonitorFrequency(lpdwFrequency);
221 }
222 
223 
224 STDMETHODIMP CAggDirectDraw::GetScanLine(__out LPDWORD lpdwScanLine)
225 {
226     ASSERT(m_pDirectDraw);
227     return m_pDirectDraw-&gt;GetScanLine(lpdwScanLine);
228 }
229 
230 
231 STDMETHODIMP CAggDirectDraw::GetVerticalBlankStatus(__out LPBOOL lpblsInVB)
232 {
233     ASSERT(m_pDirectDraw);
234     return m_pDirectDraw-&gt;GetVerticalBlankStatus(lpblsInVB);
235 }
236 
237 
238 STDMETHODIMP CAggDirectDraw::Initialize(__in GUID *lpGUID)
239 {
240     ASSERT(m_pDirectDraw);
241     return m_pDirectDraw-&gt;Initialize(lpGUID);
242 }
243 
244 
245 STDMETHODIMP CAggDirectDraw::RestoreDisplayMode()
246 {
247     ASSERT(m_pDirectDraw);
248     return m_pDirectDraw-&gt;RestoreDisplayMode();
249 }
250 
251 
252 STDMETHODIMP CAggDirectDraw::SetCooperativeLevel(HWND hWnd,DWORD dwFlags)
253 {
254     ASSERT(m_pDirectDraw);
255     return m_pDirectDraw-&gt;SetCooperativeLevel(hWnd,dwFlags);
256 }
257 
258 
259 STDMETHODIMP CAggDirectDraw::SetDisplayMode(DWORD dwWidth,DWORD dwHeight,DWORD dwBpp)
260 {
261     ASSERT(m_pDirectDraw);
262     return m_pDirectDraw-&gt;SetDisplayMode(dwWidth,dwHeight,dwBpp);
263 }
264 
265 
266 STDMETHODIMP CAggDirectDraw::WaitForVerticalBlank(DWORD dwFlags,HANDLE hEvent)
267 {
268     ASSERT(m_pDirectDraw);
269     return m_pDirectDraw-&gt;WaitForVerticalBlank(dwFlags,hEvent);
270 }
271 
272 
273 // Class that aggregates an IDirectDrawSurface interface. Although DirectDraw
274 // has the ability in its interfaces to be aggregated they&#39;re not currently
275 // implemented. This makes it difficult for various parts of Quartz that want
276 // to aggregate these interfaces. In particular the video renderer passes out
277 // media samples that expose IDirectDraw and IDirectDrawSurface. The filter
278 // graph manager also exposes IDirectDraw as a plug in distributor. For these
279 // objects we provide these aggregation classes that republish the interfaces
280 
281 STDMETHODIMP CAggDrawSurface::NonDelegatingQueryInterface(REFIID riid, __deref_out void **ppv)
282 {
283     ASSERT(m_pDirectDrawSurface);
284 
285     // Do we have this interface
286 
287     if (riid == IID_IDirectDrawSurface) {
288         return GetInterface((IDirectDrawSurface *)this,ppv);
289     } else {
290         return CUnknown::NonDelegatingQueryInterface(riid,ppv);
291     }
292 }
293 
294 
295 STDMETHODIMP CAggDrawSurface::AddAttachedSurface(__in LPDIRECTDRAWSURFACE lpDDSAttachedSurface)
296 {
297     ASSERT(m_pDirectDrawSurface);
298     return m_pDirectDrawSurface-&gt;AddAttachedSurface(lpDDSAttachedSurface);
299 }
300 
301 
302 STDMETHODIMP CAggDrawSurface::AddOverlayDirtyRect(__in LPRECT lpRect)
303 {
304     ASSERT(m_pDirectDrawSurface);
305     return m_pDirectDrawSurface-&gt;AddOverlayDirtyRect(lpRect);
306 }
307 
308 
309 STDMETHODIMP CAggDrawSurface::Blt(__in LPRECT lpDestRect,
310                                   __in LPDIRECTDRAWSURFACE lpDDSrcSurface,
311                                   __in LPRECT lpSrcRect,
312                                   DWORD dwFlags,
313                                   __in LPDDBLTFX lpDDBltFx)
314 {
315     ASSERT(m_pDirectDrawSurface);
316     return m_pDirectDrawSurface-&gt;Blt(lpDestRect,lpDDSrcSurface,lpSrcRect,dwFlags,lpDDBltFx);
317 }
318 
319 
320 STDMETHODIMP CAggDrawSurface::BltBatch(__in_ecount(dwCount) LPDDBLTBATCH lpDDBltBatch,DWORD dwCount,DWORD dwFlags)
321 {
322     ASSERT(m_pDirectDrawSurface);
323     return m_pDirectDrawSurface-&gt;BltBatch(lpDDBltBatch,dwCount,dwFlags);
324 }
325 
326 
327 STDMETHODIMP CAggDrawSurface::BltFast(DWORD dwX,DWORD dwY,
328                                       __in LPDIRECTDRAWSURFACE lpDDSrcSurface,
329                                       __in LPRECT lpSrcRect,
330                                       DWORD dwTrans)
331 {
332     ASSERT(m_pDirectDrawSurface);
333     return m_pDirectDrawSurface-&gt;BltFast(dwX,dwY,lpDDSrcSurface,lpSrcRect,dwTrans);
334 }
335 
336 
337 STDMETHODIMP CAggDrawSurface::DeleteAttachedSurface(DWORD dwFlags,
338                                                     __in LPDIRECTDRAWSURFACE lpDDSAttachedSurface)
339 {
340     ASSERT(m_pDirectDrawSurface);
341     return m_pDirectDrawSurface-&gt;DeleteAttachedSurface(dwFlags,lpDDSAttachedSurface);
342 }
343 
344 
345 STDMETHODIMP CAggDrawSurface::EnumAttachedSurfaces(__in LPVOID lpContext,
346                                                    __in LPDDENUMSURFACESCALLBACK lpEnumSurfacesCallback)
347 {
348     ASSERT(m_pDirectDrawSurface);
349     return m_pDirectDrawSurface-&gt;EnumAttachedSurfaces(lpContext,lpEnumSurfacesCallback);
350 }
351 
352 
353 STDMETHODIMP CAggDrawSurface::EnumOverlayZOrders(DWORD dwFlags,
354                                                  __in LPVOID lpContext,
355                                                  __in LPDDENUMSURFACESCALLBACK lpfnCallback)
356 {
357     ASSERT(m_pDirectDrawSurface);
358     return m_pDirectDrawSurface-&gt;EnumOverlayZOrders(dwFlags,lpContext,lpfnCallback);
359 }
360 
361 
362 STDMETHODIMP CAggDrawSurface::Flip(__in LPDIRECTDRAWSURFACE lpDDSurfaceTargetOverride,DWORD dwFlags)
363 {
364     ASSERT(m_pDirectDrawSurface);
365     return m_pDirectDrawSurface-&gt;Flip(lpDDSurfaceTargetOverride,dwFlags);
366 }
367 
368 
369 STDMETHODIMP CAggDrawSurface::GetAttachedSurface(__in LPDDSCAPS lpDDSCaps,
370                                                  __deref_out LPDIRECTDRAWSURFACE *lplpDDAttachedSurface)
371 {
372     ASSERT(m_pDirectDrawSurface);
373     return m_pDirectDrawSurface-&gt;GetAttachedSurface(lpDDSCaps,lplpDDAttachedSurface);
374 }
375 
376 
377 STDMETHODIMP CAggDrawSurface::GetBltStatus(DWORD dwFlags)
378 {
379     ASSERT(m_pDirectDrawSurface);
380     return m_pDirectDrawSurface-&gt;GetBltStatus(dwFlags);
381 }
382 
383 
384 STDMETHODIMP CAggDrawSurface::GetCaps(__out LPDDSCAPS lpDDSCaps)
385 {
386     ASSERT(m_pDirectDrawSurface);
387     return m_pDirectDrawSurface-&gt;GetCaps(lpDDSCaps);
388 }
389 
390 
391 STDMETHODIMP CAggDrawSurface::GetClipper(__deref_out LPDIRECTDRAWCLIPPER *lplpDDClipper)
392 {
393     ASSERT(m_pDirectDrawSurface);
394     return m_pDirectDrawSurface-&gt;GetClipper(lplpDDClipper);
395 }
396 
397 
398 STDMETHODIMP CAggDrawSurface::GetColorKey(DWORD dwFlags,__out LPDDCOLORKEY lpDDColorKey)
399 {
400     ASSERT(m_pDirectDrawSurface);
401     return m_pDirectDrawSurface-&gt;GetColorKey(dwFlags,lpDDColorKey);
402 }
403 
404 
405 STDMETHODIMP CAggDrawSurface::GetDC(__out HDC *lphDC)
406 {
407     ASSERT(m_pDirectDrawSurface);
408     return m_pDirectDrawSurface-&gt;GetDC(lphDC);
409 }
410 
411 
412 STDMETHODIMP CAggDrawSurface::GetFlipStatus(DWORD dwFlags)
413 {
414     ASSERT(m_pDirectDrawSurface);
415     return m_pDirectDrawSurface-&gt;GetFlipStatus(dwFlags);
416 }
417 
418 
419 STDMETHODIMP CAggDrawSurface::GetOverlayPosition(__out LPLONG lpdwX,__out LPLONG lpdwY)
420 {
421     ASSERT(m_pDirectDrawSurface);
422     return m_pDirectDrawSurface-&gt;GetOverlayPosition(lpdwX,lpdwY);
423 }
424 
425 
426 STDMETHODIMP CAggDrawSurface::GetPalette(__deref_out LPDIRECTDRAWPALETTE *lplpDDPalette)
427 {
428     ASSERT(m_pDirectDrawSurface);
429     return m_pDirectDrawSurface-&gt;GetPalette(lplpDDPalette);
430 }
431 
432 
433 STDMETHODIMP CAggDrawSurface::GetPixelFormat(__out LPDDPIXELFORMAT lpDDPixelFormat)
434 {
435     ASSERT(m_pDirectDrawSurface);
436     return m_pDirectDrawSurface-&gt;GetPixelFormat(lpDDPixelFormat);
437 }
438 
439 
440 // A bit of a warning here: Our media samples in DirectShow aggregate on
441 // IDirectDraw and IDirectDrawSurface (ie are available through IMediaSample
442 // by QueryInterface). Unfortunately the underlying DirectDraw code cannot
443 // be aggregated so we have to use these classes. The snag is that when we
444 // call a different surface and pass in this interface as perhaps the source
445 // surface the call will fail because DirectDraw dereferences the pointer to
446 // get at its private data structures. Therefore we supply this workaround to give
447 // access to the real IDirectDraw surface. A filter can call GetSurfaceDesc
448 // and we will fill in the lpSurface pointer with the real underlying surface
449 
450 STDMETHODIMP CAggDrawSurface::GetSurfaceDesc(__out LPDDSURFACEDESC lpDDSurfaceDesc)
451 {
452     ASSERT(m_pDirectDrawSurface);
453 
454     // First call down to the underlying DirectDraw
455 
456     HRESULT hr = m_pDirectDrawSurface-&gt;GetSurfaceDesc(lpDDSurfaceDesc);
457     if (FAILED(hr)) {
458         return hr;
459     }
460 
461     // Store the real DirectDrawSurface interface
462     lpDDSurfaceDesc-&gt;lpSurface = m_pDirectDrawSurface;
463     return hr;
464 }
465 
466 
467 STDMETHODIMP CAggDrawSurface::Initialize(__in LPDIRECTDRAW lpDD,__in LPDDSURFACEDESC lpDDSurfaceDesc)
468 {
469     ASSERT(m_pDirectDrawSurface);
470     return m_pDirectDrawSurface-&gt;Initialize(lpDD,lpDDSurfaceDesc);
471 }
472 
473 
474 STDMETHODIMP CAggDrawSurface::IsLost()
475 {
476     ASSERT(m_pDirectDrawSurface);
477     return m_pDirectDrawSurface-&gt;IsLost();
478 }
479 
480 
481 STDMETHODIMP CAggDrawSurface::Lock(__in LPRECT lpDestRect,
482                                    __inout LPDDSURFACEDESC lpDDSurfaceDesc,
483                                    DWORD dwFlags,
484                                    HANDLE hEvent)
485 {
486     ASSERT(m_pDirectDrawSurface);
487     return m_pDirectDrawSurface-&gt;Lock(lpDestRect,lpDDSurfaceDesc,dwFlags,hEvent);
488 }
489 
490 
491 STDMETHODIMP CAggDrawSurface::ReleaseDC(HDC hDC)
492 {
493     ASSERT(m_pDirectDrawSurface);
494     return m_pDirectDrawSurface-&gt;ReleaseDC(hDC);
495 }
496 
497 
498 STDMETHODIMP CAggDrawSurface::Restore()
499 {
500     ASSERT(m_pDirectDrawSurface);
501     return m_pDirectDrawSurface-&gt;Restore();
502 }
503 
504 
505 STDMETHODIMP CAggDrawSurface::SetClipper(__in LPDIRECTDRAWCLIPPER lpDDClipper)
506 {
507     ASSERT(m_pDirectDrawSurface);
508     return m_pDirectDrawSurface-&gt;SetClipper(lpDDClipper);
509 }
510 
511 
512 STDMETHODIMP CAggDrawSurface::SetColorKey(DWORD dwFlags,__in LPDDCOLORKEY lpDDColorKey)
513 {
514     ASSERT(m_pDirectDrawSurface);
515     return m_pDirectDrawSurface-&gt;SetColorKey(dwFlags,lpDDColorKey);
516 }
517 
518 
519 STDMETHODIMP CAggDrawSurface::SetOverlayPosition(LONG dwX,LONG dwY)
520 {
521     ASSERT(m_pDirectDrawSurface);
522     return m_pDirectDrawSurface-&gt;SetOverlayPosition(dwX,dwY);
523 }
524 
525 
526 STDMETHODIMP CAggDrawSurface::SetPalette(__in LPDIRECTDRAWPALETTE lpDDPalette)
527 {
528     ASSERT(m_pDirectDrawSurface);
529     return m_pDirectDrawSurface-&gt;SetPalette(lpDDPalette);
530 }
531 
532 
533 STDMETHODIMP CAggDrawSurface::Unlock(__in LPVOID lpSurfaceData)
534 {
535     ASSERT(m_pDirectDrawSurface);
536     return m_pDirectDrawSurface-&gt;Unlock(lpSurfaceData);
537 }
538 
539 
540 STDMETHODIMP CAggDrawSurface::UpdateOverlay(__in LPRECT lpSrcRect,
541                                             __in LPDIRECTDRAWSURFACE lpDDDestSurface,
542                                             __in LPRECT lpDestRect,
543                                             DWORD dwFlags,
544                                             __in LPDDOVERLAYFX lpDDOverlayFX)
545 {
546     ASSERT(m_pDirectDrawSurface);
547     return m_pDirectDrawSurface-&gt;UpdateOverlay(lpSrcRect,lpDDDestSurface,lpDestRect,dwFlags,lpDDOverlayFX);
548 }
549 
550 
551 STDMETHODIMP CAggDrawSurface::UpdateOverlayDisplay(DWORD dwFlags)
552 {
553     ASSERT(m_pDirectDrawSurface);
554     return m_pDirectDrawSurface-&gt;UpdateOverlayDisplay(dwFlags);
555 }
556 
557 
558 STDMETHODIMP CAggDrawSurface::UpdateOverlayZOrder(DWORD dwFlags,__in LPDIRECTDRAWSURFACE lpDDSReference)
559 {
560     ASSERT(m_pDirectDrawSurface);
561     return m_pDirectDrawSurface-&gt;UpdateOverlayZOrder(dwFlags,lpDDSReference);
562 }
563 
564 
565 // DirectShow must work on multiple platforms.  In particular, it also runs on
566 // Windows NT 3.51 which does not have DirectDraw capabilities. The filters
567 // cannot therefore link statically to the DirectDraw library. To make their
568 // lives that little bit easier we provide this class that manages loading
569 // and unloading the library and creating the initial IDirectDraw interface
570 
571 CLoadDirectDraw::CLoadDirectDraw() :
572     m_pDirectDraw(NULL),
573     m_hDirectDraw(NULL)
574 {
575 }
576 
577 
578 // Destructor forces unload
579 
580 CLoadDirectDraw::~CLoadDirectDraw()
581 {
582     ReleaseDirectDraw();
583 
584     if (m_hDirectDraw) {
585         NOTE(&quot;Unloading library&quot;);
586         FreeLibrary(m_hDirectDraw);
587     }
588 }
589 
590 
591 // We can&#39;t be sure that DirectDraw is always available so we can&#39;t statically
592 // link to the library. Therefore we load the library, get the function entry
593 // point addresses and call them to create the driver objects. We return S_OK
594 // if we manage to load DirectDraw correctly otherwise we return E_NOINTERFACE
595 // We initialise a DirectDraw instance by explicitely loading the library and
596 // calling GetProcAddress on the DirectDrawCreate entry point that it exports
597 
598 // On a multi monitor system, we can get the DirectDraw object for any
599 // monitor (device) with the optional szDevice parameter
600 
601 HRESULT CLoadDirectDraw::LoadDirectDraw(__in LPSTR szDevice)
602 {
603     PDRAWCREATE pDrawCreate;
604     PDRAWENUM pDrawEnum;
605     LPDIRECTDRAWENUMERATEEXA pDrawEnumEx;
606     HRESULT hr = NOERROR;
607 
608     NOTE(&quot;Entering DoLoadDirectDraw&quot;);
609 
610     // Is DirectDraw already loaded
611 
612     if (m_pDirectDraw) {
613         NOTE(&quot;Already loaded&quot;);
614         ASSERT(m_hDirectDraw);
615         return NOERROR;
616     }
617 
618     // Make sure the library is available
619 
620     if(!m_hDirectDraw)
621     {
622         UINT ErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX);
623         m_hDirectDraw = LoadLibrary(TEXT(&quot;DDRAW.DLL&quot;));
624         SetErrorMode(ErrorMode);
625 
626         if (m_hDirectDraw == NULL) {
627             DbgLog((LOG_ERROR,1,TEXT(&quot;Can&#39;t load DDRAW.DLL&quot;)));
628             NOTE(&quot;No library&quot;);
629             return E_NOINTERFACE;
630         }
631     }
632 
633     // Get the DLL address for the creator function
634 
635     pDrawCreate = (PDRAWCREATE)GetProcAddress(m_hDirectDraw,&quot;DirectDrawCreate&quot;);
636     // force ANSI, we assume it
637     pDrawEnum = (PDRAWENUM)GetProcAddress(m_hDirectDraw,&quot;DirectDrawEnumerateA&quot;);
638     pDrawEnumEx = (LPDIRECTDRAWENUMERATEEXA)GetProcAddress(m_hDirectDraw,
639                         &quot;DirectDrawEnumerateExA&quot;);
640 
641     // We don&#39;t NEED DirectDrawEnumerateEx, that&#39;s just for multimon stuff
642     if (pDrawCreate == NULL || pDrawEnum == NULL) {
643         DbgLog((LOG_ERROR,1,TEXT(&quot;Can&#39;t get functions: Create=%x Enum=%x&quot;),
644             pDrawCreate, pDrawEnum));
645         NOTE(&quot;No entry point&quot;);
646         ReleaseDirectDraw();
647         return E_NOINTERFACE;
648     }
649 
650     DbgLog((LOG_TRACE,3,TEXT(&quot;Creating DDraw for device %s&quot;),
651                     szDevice ? szDevice : &quot;&lt;NULL&gt;&quot;));
652 
653     // Create a DirectDraw display provider for this device, using the fancy
654     // multimon-aware version, if it exists
655     if (pDrawEnumEx)
656         m_pDirectDraw = DirectDrawCreateFromDeviceEx(szDevice, pDrawCreate,
657                                 pDrawEnumEx);
658     else
659         m_pDirectDraw = DirectDrawCreateFromDevice(szDevice, pDrawCreate,
660                                 pDrawEnum);
661 
662     if (m_pDirectDraw == NULL) {
663             DbgLog((LOG_ERROR,1,TEXT(&quot;Can&#39;t create DDraw&quot;)));
664             NOTE(&quot;No instance&quot;);
665             ReleaseDirectDraw();
666             return E_NOINTERFACE;
667     }
668     return NOERROR;
669 }
670 
671 
672 // Called to release any DirectDraw provider we previously loaded. We may be
673 // called at any time especially when something goes horribly wrong and when
674 // we need to clean up before returning so we can&#39;t guarantee that all state
675 // variables are consistent so free only those really allocated allocated
676 // This should only be called once all reference counts have been released
677 
678 void CLoadDirectDraw::ReleaseDirectDraw()
679 {
680     NOTE(&quot;Releasing DirectDraw driver&quot;);
681 
682     // Release any DirectDraw provider interface
683 
684     if (m_pDirectDraw) {
685         NOTE(&quot;Releasing instance&quot;);
686         m_pDirectDraw-&gt;Release();
687         m_pDirectDraw = NULL;
688     }
689 
690 }
691 
692 
693 // Return NOERROR (S_OK) if DirectDraw has been loaded by this object
694 
695 HRESULT CLoadDirectDraw::IsDirectDrawLoaded()
696 {
697     NOTE(&quot;Entering IsDirectDrawLoaded&quot;);
698 
699     if (m_pDirectDraw == NULL) {
700         NOTE(&quot;DirectDraw not loaded&quot;);
701         return S_FALSE;
702     }
703     return NOERROR;
704 }
705 
706 
707 // Return the IDirectDraw interface we look after
708 
709 LPDIRECTDRAW CLoadDirectDraw::GetDirectDraw()
710 {
711     NOTE(&quot;Entering GetDirectDraw&quot;);
712 
713     if (m_pDirectDraw == NULL) {
714         NOTE(&quot;No DirectDraw&quot;);
715         return NULL;
716     }
717 
718     NOTE(&quot;Returning DirectDraw&quot;);
719     m_pDirectDraw-&gt;AddRef();
720     return m_pDirectDraw;
721 }
722 
723 
724 // Are we running on Direct Draw version 1?  We need to find out as
725 // we rely on specific bug fixes in DirectDraw 2 for fullscreen playback. To
726 // find out, we simply see if it supports IDirectDraw2.  Only version 2 and
727 // higher support this.
728 
729 BOOL CLoadDirectDraw::IsDirectDrawVersion1()
730 {
731 
732     if (m_pDirectDraw == NULL)
733     return FALSE;
734 
735     IDirectDraw2 *p = NULL;
736     HRESULT hr = m_pDirectDraw-&gt;QueryInterface(IID_IDirectDraw2, (void **)&amp;p);
737     if (p)
738     p-&gt;Release();
739     if (hr == NOERROR) {
740         DbgLog((LOG_TRACE,3,TEXT(&quot;Direct Draw Version 2 or greater&quot;)));
741     return FALSE;
742     } else {
743         DbgLog((LOG_TRACE,3,TEXT(&quot;Direct Draw Version 1&quot;)));
744     return TRUE;
745     }
746 }
    </pre>
  </body>
</html>
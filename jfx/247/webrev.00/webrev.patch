diff a/modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/behavior/ListViewBehavior.java b/modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/behavior/ListViewBehavior.java
--- a/modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/behavior/ListViewBehavior.java
+++ b/modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/behavior/ListViewBehavior.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -211,20 +211,24 @@
 
     @Override public void dispose() {
         ListView<T> control = getNode();
 
         ListCellBehavior.removeAnchor(control);
+        control.selectionModelProperty().removeListener(weakSelectionModelListener);
+        if (control.getSelectionModel() != null) {
+            control.getSelectionModel().getSelectedIndices().removeListener(weakSelectedIndicesListener);
+        }
+        control.itemsProperty().removeListener(weakItemsListener);
+        if (control.getItems() != null) {
+            control.getItems().removeListener(weakItemsListListener);
+        }
+
         if (tlFocus != null) tlFocus.dispose();
+        control.removeEventFilter(KeyEvent.ANY, keyEventListener);
         super.dispose();
-
-        control.removeEventHandler(KeyEvent.ANY, keyEventListener);
     }
 
-
-
-
-
     /**************************************************************************
      *                         State and Functions                            *
      *************************************************************************/
 
     private boolean isShiftDown = false;
diff a/modules/javafx.controls/src/main/java/javafx/scene/control/skin/ListViewSkin.java b/modules/javafx.controls/src/main/java/javafx/scene/control/skin/ListViewSkin.java
--- a/modules/javafx.controls/src/main/java/javafx/scene/control/skin/ListViewSkin.java
+++ b/modules/javafx.controls/src/main/java/javafx/scene/control/skin/ListViewSkin.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -35,10 +35,11 @@
 import javafx.collections.ListChangeListener;
 import javafx.collections.MapChangeListener;
 import javafx.collections.ObservableList;
 import javafx.collections.ObservableMap;
 import javafx.collections.WeakListChangeListener;
+import javafx.collections.WeakMapChangeListener;
 import javafx.event.EventHandler;
 import javafx.geometry.Orientation;
 import javafx.scene.AccessibleAction;
 import javafx.scene.AccessibleAttribute;
 import javafx.scene.Node;
@@ -102,11 +103,10 @@
     // FIXME this should not be a StackPane
     private StackPane placeholderRegion;
     private Node placeholderNode;
 
     private ObservableList<T> listViewItems;
-    private final InvalidationListener itemsChangeListener = observable -> updateListViewItems();
 
     private boolean needCellsRebuilt = true;
     private boolean needCellsReconfigured = false;
 
     private int itemCount = -1;
@@ -127,10 +127,13 @@
             getSkinnable().requestLayout();
             getSkinnable().getProperties().remove(Properties.RECREATE);
         }
     };
 
+    private WeakMapChangeListener<Object, Object> weakPropertiesMapListener =
+            new WeakMapChangeListener<>(propertiesMapListener);
+
     private final ListChangeListener<T> listViewItemsListener = new ListChangeListener<T>() {
         @Override public void onChanged(Change<? extends T> c) {
             while (c.next()) {
                 if (c.wasReplaced()) {
                     // RT-28397: Support for when an item is replaced with itself (but
@@ -164,10 +167,16 @@
 
     private final WeakListChangeListener<T> weakListViewItemsListener =
             new WeakListChangeListener<T>(listViewItemsListener);
 
 
+    private final InvalidationListener itemsChangeListener = observable -> updateListViewItems();
+
+    private WeakInvalidationListener
+                weakItemsChangeListener = new WeakInvalidationListener(itemsChangeListener);
+
+    private EventHandler<MouseEvent> ml;
 
     /***************************************************************************
      *                                                                         *
      * Constructors                                                            *
      *                                                                         *
@@ -206,11 +215,11 @@
         flow.setVertical(control.getOrientation() == Orientation.VERTICAL);
         flow.setCellFactory(flow -> createCell());
         flow.setFixedCellSize(control.getFixedCellSize());
         getChildren().add(flow);
 
-        EventHandler<MouseEvent> ml = event -> {
+        ml = event -> {
             // RT-15127: cancel editing on scroll. This is a bit extreme
             // (we are cancelling editing on touching the scrollbars).
             // This can be improved at a later date.
             if (control.getEditingIndex() > -1) {
                 control.edit(-1);
@@ -228,15 +237,15 @@
         flow.getVbar().addEventFilter(MouseEvent.MOUSE_PRESSED, ml);
         flow.getHbar().addEventFilter(MouseEvent.MOUSE_PRESSED, ml);
 
         updateItemCount();
 
-        control.itemsProperty().addListener(new WeakInvalidationListener(itemsChangeListener));
+        control.itemsProperty().addListener(weakItemsChangeListener);
 
         final ObservableMap<Object, Object> properties = control.getProperties();
         properties.remove(Properties.RECREATE);
-        properties.addListener(propertiesMapListener);
+        properties.addListener(weakPropertiesMapListener);
 
         // Register listeners
         registerChangeListener(control.itemsProperty(), o -> updateListViewItems());
         registerChangeListener(control.orientationProperty(), o ->
             flow.setVertical(control.getOrientation() == Orientation.VERTICAL)
@@ -261,10 +270,24 @@
      *                                                                         *
      **************************************************************************/
 
     /** {@inheritDoc} */
     @Override public void dispose() {
+        if (getSkinnable() == null) return;
+        // listener cleanup fixes side-effects (NPE on refresh, setItems, modifyItems)
+        getSkinnable().getProperties().removeListener(weakPropertiesMapListener);
+        getSkinnable().itemsProperty().removeListener(weakItemsChangeListener);
+        if (listViewItems != null) {
+            listViewItems.removeListener(weakListViewItemsListener);
+            listViewItems = null;
+        }
+        // flow related cleanup
+        // leaking without nulling factory
+        flow.setCellFactory(null);
+        // for completeness - but no effect with/out?
+        flow.getVbar().removeEventFilter(MouseEvent.MOUSE_PRESSED, ml);
+        flow.getHbar().removeEventFilter(MouseEvent.MOUSE_PRESSED, ml);
         super.dispose();
 
         if (behavior != null) {
             behavior.dispose();
         }
diff a/modules/javafx.controls/src/main/java/javafx/scene/control/skin/VirtualContainerBase.java b/modules/javafx.controls/src/main/java/javafx/scene/control/skin/VirtualContainerBase.java
--- a/modules/javafx.controls/src/main/java/javafx/scene/control/skin/VirtualContainerBase.java
+++ b/modules/javafx.controls/src/main/java/javafx/scene/control/skin/VirtualContainerBase.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,10 +23,11 @@
  * questions.
  */
 
 package javafx.scene.control.skin;
 
+import javafx.event.EventHandler;
 import javafx.scene.control.Control;
 import javafx.scene.control.IndexedCell;
 import javafx.scene.control.ScrollToEvent;
 import javafx.scene.control.SkinBase;
 
@@ -51,10 +52,11 @@
      * The virtualized container which handles the layout and scrolling of
      * all the cells.
      */
     private final VirtualFlow<I> flow;
 
+    private EventHandler<? super ScrollToEvent<Integer>> scrollToEventHandler;
 
 
     /***************************************************************************
      *                                                                         *
      * Constructors                                                            *
@@ -67,20 +69,21 @@
      */
     public VirtualContainerBase(final C control) {
         super(control);
         flow = createVirtualFlow();
 
-        control.addEventHandler(ScrollToEvent.scrollToTopIndex(), event -> {
+        scrollToEventHandler = event -> {
             // Fix for RT-24630: The row count in VirtualFlow was incorrect
             // (normally zero), so the scrollTo call was misbehaving.
             if (itemCountDirty) {
                 // update row count before we do a scroll
                 updateItemCount();
                 itemCountDirty = false;
             }
             flow.scrollToTop(event.getScrollTarget());
-        });
+        };
+        control.addEventHandler(ScrollToEvent.scrollToTopIndex(), scrollToEventHandler);
     }
 
 
 
     /***************************************************************************
@@ -121,10 +124,21 @@
      */
     protected VirtualFlow<I> createVirtualFlow() {
         return new VirtualFlow<>();
     }
 
+    /**
+     * {@inheritDoc} <p>
+     * Overridden to remove EventHandler.
+     */
+    @Override
+    public void dispose() {
+        if (getSkinnable() == null) return;
+        getSkinnable().removeEventHandler(ScrollToEvent.scrollToTopIndex(), scrollToEventHandler);
+        super.dispose();
+    }
+
     /**
      * Get the virtualized container.
      * Subclasses can invoke this method to get the VirtualFlow instance.
      * @return the virtualized container
      * @since 10
diff a/modules/javafx.controls/src/test/java/test/com/sun/javafx/scene/control/behavior/BehaviorCleanupTest.java b/modules/javafx.controls/src/test/java/test/com/sun/javafx/scene/control/behavior/BehaviorCleanupTest.java
--- /dev/null
+++ b/modules/javafx.controls/src/test/java/test/com/sun/javafx/scene/control/behavior/BehaviorCleanupTest.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package test.com.sun.javafx.scene.control.behavior;
+
+import java.lang.ref.WeakReference;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import com.sun.javafx.scene.control.behavior.BehaviorBase;
+import com.sun.javafx.scene.control.behavior.ListCellBehavior;
+
+import static javafx.collections.FXCollections.*;
+import static org.junit.Assert.*;
+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.*;
+
+import javafx.scene.control.ListView;
+
+/**
+ * Test for misbehavior of individual implementations that turned
+ * up in binch testing.
+ *
+ */
+public class BehaviorCleanupTest {
+
+// ---------- ListView
+
+    /**
+     * Test cleanup of listener to itemsProperty.
+     */
+    @Test
+    public void testListViewBehaviorDisposeSetItems() {
+        ListView<String> listView = new ListView<>(observableArrayList("one", "two"));
+        WeakReference<BehaviorBase<?>> weakRef = new WeakReference<>(createBehavior(listView));
+        weakRef.get().dispose();
+        int last = 1;
+        ListCellBehavior.setAnchor(listView, last, false);
+        listView.setItems(observableArrayList("other", "again"));
+        assertEquals("sanity: anchor unchanged", last, listView.getProperties().get("anchor"));
+        listView.getItems().remove(0);
+        assertEquals("anchor must not be updated on items modification when disposed",
+                last, listView.getProperties().get("anchor"));
+    }
+
+    @Test
+    public void testListViewBehaviorSetItems() {
+        ListView<String> listView = new ListView<>(observableArrayList("one", "two"));
+        createBehavior(listView);
+        int last = 1;
+        ListCellBehavior.setAnchor(listView, last, false);
+        listView.setItems(observableArrayList("other", "again"));
+        assertEquals("sanity: anchor unchanged", last, listView.getProperties().get("anchor"));
+        listView.getItems().remove(0);
+        assertEquals("anchor must be updated on items modification",
+                last -1, listView.getProperties().get("anchor"));
+   }
+
+    /**
+     * Test cleanup of itemsList listener in ListViewBehavior.
+     */
+    @Test
+    public void testListViewBehaviorDisposeRemoveItem() {
+        ListView<String> listView = new ListView<>(observableArrayList("one", "two"));
+        WeakReference<BehaviorBase<?>> weakRef = new WeakReference<>(createBehavior(listView));
+        weakRef.get().dispose();
+        int last = 1;
+        ListCellBehavior.setAnchor(listView, last, false);
+        listView.getItems().remove(0);
+        assertEquals("anchor must not be updated on items modification when disposed",
+                last,
+                listView.getProperties().get("anchor"));
+    }
+
+    @Test
+    public void testListViewBehaviorRemoveItem() {
+        ListView<String> listView = new ListView<>(observableArrayList("one", "two"));
+        createBehavior(listView);
+        int last = 1;
+        ListCellBehavior.setAnchor(listView, last, false);
+        assertEquals("behavior must set anchor on select", last, listView.getProperties().get("anchor"));
+        listView.getItems().remove(0);
+        assertEquals("anchor must be updated on items modification",
+                last -1, listView.getProperties().get("anchor"));
+    }
+
+    /**
+     * Test cleanup of selection listeners in ListViewBehavior.
+     */
+    @Test
+    public void testListViewBehaviorDisposeSelect() {
+        ListView<String> listView = new ListView<>(observableArrayList("one", "two"));
+        WeakReference<BehaviorBase<?>> weakRef = new WeakReference<>(createBehavior(listView));
+        listView.getSelectionModel().select(1);
+        weakRef.get().dispose();
+        listView.getSelectionModel().select(0);
+        assertNull("anchor must remain cleared on selecting when disposed",
+                listView.getProperties().get("anchor"));
+    }
+
+    @Test
+    public void testListViewBehaviorSelect() {
+        ListView<String> listView = new ListView<>(observableArrayList("one", "two"));
+        createBehavior(listView);
+        int last = 1;
+        listView.getSelectionModel().select(last);
+        assertEquals("anchor must be set", last, listView.getProperties().get("anchor"));
+    }
+
+    @Test
+    public void testListViewBehaviorDispose() {
+        ListView<String> listView = new ListView<>(observableArrayList("one", "two"));
+        WeakReference<BehaviorBase<?>> weakRef = new WeakReference<>(createBehavior(listView));
+        listView.getSelectionModel().select(1);
+        weakRef.get().dispose();
+        assertNull("anchor must be cleared after dispose", listView.getProperties().get("anchor"));
+    }
+
+  //------------------ setup/cleanup
+
+    @After
+    public void cleanup() {
+        Thread.currentThread().setUncaughtExceptionHandler(null);
+    }
+
+    @Before
+    public void setup() {
+        Thread.currentThread().setUncaughtExceptionHandler((thread, throwable) -> {
+            if (throwable instanceof RuntimeException) {
+                throw (RuntimeException)throwable;
+            } else {
+                Thread.currentThread().getThreadGroup().uncaughtException(thread, throwable);
+            }
+        });
+    }
+
+}
diff a/modules/javafx.controls/src/test/java/test/com/sun/javafx/scene/control/behavior/BehaviorMemoryLeakTest.java b/modules/javafx.controls/src/test/java/test/com/sun/javafx/scene/control/behavior/BehaviorMemoryLeakTest.java
--- a/modules/javafx.controls/src/test/java/test/com/sun/javafx/scene/control/behavior/BehaviorMemoryLeakTest.java
+++ b/modules/javafx.controls/src/test/java/test/com/sun/javafx/scene/control/behavior/BehaviorMemoryLeakTest.java
@@ -82,11 +82,10 @@
         // FIXME as part of JDK-8241364
         // The behaviors of these controls are leaking
         // step 1: file issues (where not yet done), add informal ignore to entry
         // step 2: fix and remove from list
         List<Class<? extends Control>> leakingClasses = List.of(
-                ListView.class,
                 PasswordField.class,
                 TableView.class,
                 TextArea.class,
                 TextField.class,
                 TreeTableView.class,
diff a/modules/javafx.controls/src/test/java/test/javafx/scene/control/skin/SkinCleanupTest.java b/modules/javafx.controls/src/test/java/test/javafx/scene/control/skin/SkinCleanupTest.java
--- a/modules/javafx.controls/src/test/java/test/javafx/scene/control/skin/SkinCleanupTest.java
+++ b/modules/javafx.controls/src/test/java/test/javafx/scene/control/skin/SkinCleanupTest.java
@@ -25,20 +25,23 @@
 
 package test.javafx.scene.control.skin;
 
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
+import static javafx.collections.FXCollections.*;
 import static javafx.scene.control.ControlShim.*;
 import static org.junit.Assert.*;
 import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.*;
 
 import javafx.scene.Scene;
 import javafx.scene.control.Button;
 import javafx.scene.control.ChoiceBox;
 import javafx.scene.control.Control;
+import javafx.scene.control.ListView;
 import javafx.scene.control.ToolBar;
 import javafx.scene.layout.Pane;
 import javafx.scene.layout.VBox;
 import javafx.scene.shape.Rectangle;
 import javafx.stage.Stage;
@@ -50,10 +53,51 @@
 
     private Scene scene;
     private Stage stage;
     private Pane root;
 
+  //-------------- listView
+
+    @Test
+    public void testListViewAddItems() {
+        ListView<String> listView = new ListView<>();
+        installDefaultSkin(listView);
+        replaceSkin(listView);
+        listView.getItems().add("addded");
+    }
+
+    @Test
+    public void testListViewRefresh() {
+        ListView<String> listView = new ListView<>();
+        installDefaultSkin(listView);
+        replaceSkin(listView);
+        listView.refresh();
+    }
+
+    @Test
+    public void testListViewSetItems() {
+        ListView<String> listView = new ListView<>();
+        installDefaultSkin(listView);
+        replaceSkin(listView);
+        listView.setItems(observableArrayList());
+    }
+
+//-------- choiceBox, toolBar
+
+    /**
+     * FIXME: Left-over from ChoiceBox fix.
+     * NPE on sequence setItems -> modify items after skin is replaced.
+     */
+    @Test @Ignore("8246202")
+    public void testChoiceBoxSetItems() {
+        ChoiceBox<String> box = new ChoiceBox<>();
+        installDefaultSkin(box);
+        replaceSkin(box);
+        box.setItems(observableArrayList("one"));
+        box.getItems().add("added");
+    }
+
     /**
      * NPE when adding items after skin is replaced
      */
     @Test
     public void testChoiceBoxAddItems() {
diff a/modules/javafx.controls/src/test/java/test/javafx/scene/control/skin/SkinMemoryLeakTest.java b/modules/javafx.controls/src/test/java/test/javafx/scene/control/skin/SkinMemoryLeakTest.java
--- a/modules/javafx.controls/src/test/java/test/javafx/scene/control/skin/SkinMemoryLeakTest.java
+++ b/modules/javafx.controls/src/test/java/test/javafx/scene/control/skin/SkinMemoryLeakTest.java
@@ -109,11 +109,10 @@
                 ButtonBar.class,
                 ColorPicker.class,
                 ComboBox.class,
                 DatePicker.class,
                 ListCell.class,
-                ListView.class,
                 MenuBar.class,
                 MenuButton.class,
                 Pagination.class,
                 PasswordField.class,
                 ScrollBar.class,

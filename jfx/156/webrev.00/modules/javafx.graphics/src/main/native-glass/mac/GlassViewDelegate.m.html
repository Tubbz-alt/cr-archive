<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.graphics/src/main/native-glass/mac/GlassViewDelegate.m</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #import &quot;common.h&quot;
  27 #import &quot;com_sun_glass_events_ViewEvent.h&quot;
  28 #import &quot;com_sun_glass_events_MouseEvent.h&quot;
  29 #import &quot;com_sun_glass_events_KeyEvent.h&quot;
  30 #import &quot;com_sun_glass_events_DndEvent.h&quot;
  31 #import &quot;com_sun_glass_events_SwipeGesture.h&quot;
  32 #import &quot;com_sun_glass_ui_Clipboard.h&quot;
  33 #import &quot;com_sun_glass_ui_mac_MacGestureSupport.h&quot;
  34 
  35 #import &quot;GlassMacros.h&quot;
  36 #import &quot;GlassViewDelegate.h&quot;
  37 #import &quot;GlassKey.h&quot;
  38 #import &quot;GlassScreen.h&quot;
  39 #import &quot;GlassWindow.h&quot;
  40 #import &quot;GlassApplication.h&quot;
  41 #import &quot;GlassLayer3D.h&quot;
  42 #import &quot;GlassNSEvent.h&quot;
  43 #import &quot;GlassPasteboard.h&quot;
  44 #import &quot;GlassHelper.h&quot;
  45 #import &quot;GlassStatics.h&quot;
  46 #import &quot;GlassPasteboard.h&quot;
  47 #import &quot;GlassTouches.h&quot;
  48 
  49 //#define VERBOSE
  50 #ifndef VERBOSE
  51     #define LOG(MSG, ...)
  52 #else
  53     #define LOG(MSG, ...) GLASS_LOG(MSG, ## __VA_ARGS__);
  54 #endif
  55 
  56 //#define DNDVERBOSE
  57 #ifndef DNDVERBOSE
  58     #define DNDLOG(MSG, ...)
  59 #else
  60     #define DNDLOG(MSG, ...) GLASS_LOG(MSG, ## __VA_ARGS__);
  61 #endif
  62 
  63 // used Safari as a reference while dragging large images
  64 #define MAX_DRAG_SIZE 400
  65 
  66 // explicitly set image size
  67 #define DEFAULT_DRAG_SIZE 64
  68 
  69 // Tracks pressed modifier keys
  70 static NSUInteger s_modifierFlags = 0;
  71 
  72 @interface GlassViewDelegate (hidden)
  73 - (void)maybeBeginGestureWithEvent:(NSEvent *)theEvent withMask:(GestureMaskType)theMask;
  74 - (void)maybeEndGestureWithEvent:(NSEvent *)theEvent withMask:(GestureMaskType)theMask;
  75 @end
  76 
  77 // Extracted from class-dump utility output for NSEvent class
  78 @interface NSEvent (hidden)
  79 
  80 - (long long)_scrollPhase;
  81 - (unsigned long long)momentumPhase;
  82 @end
  83 
  84 
  85 static jboolean isInertialScroll(NSEvent *theEvent)
  86 {
  87     enum
  88     {
  89         SelectorNotSet,
  90         MomentumPhaseSelector,
  91         ScrollPhaseSelector,
  92         SelectorNotAvailable
  93     };
  94 
  95     static int selector = SelectorNotSet;
  96 
  97     switch (selector)
  98     {
  99         case SelectorNotSet:
 100             if ([theEvent respondsToSelector:@selector(momentumPhase)])
 101             {   // Available from OS X 10.7
 102                 selector = MomentumPhaseSelector;
 103             }
 104             else if ([theEvent respondsToSelector:@selector(_scrollPhase)])
 105             {   // Available in OS X 10.6 and earlier. Deprecated in OS X 10.7
 106                 selector = ScrollPhaseSelector;
 107             }
 108             else
 109             {
 110                 selector = SelectorNotAvailable;
 111             }
 112             return isInertialScroll(theEvent);
 113 
 114         case MomentumPhaseSelector:
 115             return ([theEvent momentumPhase] != 0);
 116 
 117         case ScrollPhaseSelector:
 118             return ([theEvent _scrollPhase] != 0);
 119     }
 120 
 121     return JNI_FALSE;
 122 }
 123 
 124 
 125 static jint getSwipeDirFromEvent(NSEvent *theEvent)
 126 {
 127     if ([theEvent deltaX] &lt; 0) {
 128         return com_sun_glass_events_SwipeGesture_DIR_RIGHT;
 129     }
 130     if ([theEvent deltaX] &gt; 0) {
 131         return com_sun_glass_events_SwipeGesture_DIR_LEFT;
 132     }
 133     if ([theEvent deltaY] &gt; 0) {
 134         return com_sun_glass_events_SwipeGesture_DIR_UP;
 135     }
 136     if ([theEvent deltaY] &lt; 0) {
 137         return com_sun_glass_events_SwipeGesture_DIR_DOWN;
 138     }
 139     return 0;
 140 }
 141 
 142 
 143 @implementation GlassViewDelegate
 144 
 145 - (id)initWithView:(NSView*)view withJview:(jobject)jview
 146 {
 147     self = [super init];
 148     if (self != nil)
 149     {
 150         GET_MAIN_JENV;
 151 
 152         self-&gt;nsView = view;
 153         self-&gt;jView = (*env)-&gt;NewGlobalRef(env, jview);
 154         self-&gt;mouseIsOver = NO;
 155         self-&gt;mouseDownMask = 0;
 156 
 157         self-&gt;gestureInProgress = NO;
 158         self-&gt;gesturesBeganMask = 0;
 159 
 160         self-&gt;nativeFullScreenModeWindow = nil;
 161 
 162         // optimization
 163         [self-&gt;nsView allocateGState];
 164 
 165                 // register for drag and drop
 166                 [self-&gt;nsView registerForDraggedTypes:[NSArray arrayWithObjects:        NSPasteboardTypeString,
 167                                                                                 NSPasteboardTypeTIFF,
 168                                                                                    NSPasteboardTypeRTF,
 169                                                                                    NSPasteboardTypeTabularText,
 170                                                                                    NSPasteboardTypeFont,
 171                                                                                    NSPasteboardTypeRuler,
 172                                                                                    NSPasteboardTypeColor,
 173                                                                                    NSPasteboardTypeRTFD,
 174                                                                                    NSPasteboardTypeHTML,
 175                                                                                    NSPasteboardTypePDF,
 176                                                                                    NSPasteboardTypeMultipleTextSelection,
 177                                                                                    (NSString*)kUTTypeURL,
 178                                                                                    (NSString*)kUTTypeFileURL,
 179                                                                                    (NSString*)@&quot;public.mime-type&quot;,
 180                                                                             nil]];
 181     }
 182     return self;
 183 }
 184 
 185 - (void)dealloc
 186 {
 187     [self-&gt;lastEvent release];
 188     self-&gt;lastEvent = nil;
 189 
 190     [self-&gt;parentHost release];
 191     self-&gt;parentHost = nil;
 192 
 193     [self-&gt;parentWindow release];
 194     self-&gt;parentWindow = nil;
 195 
 196     [self-&gt;fullscreenWindow release];
 197     self-&gt;fullscreenWindow = nil;
 198 
 199     [self-&gt;nativeFullScreenModeWindow release];
 200     self-&gt;nativeFullScreenModeWindow = nil;
 201 
 202     [GlassTouches stopTracking:self];
 203 
 204     GET_MAIN_JENV;
 205     if (env != NULL)
 206     {
 207         (*env)-&gt;DeleteGlobalRef(env, self-&gt;jView);
 208     }
 209     self-&gt;jView = NULL;
 210 
 211     [super dealloc];
 212 }
 213 
 214 - (jobject)jView
 215 {
 216     return self-&gt;jView;
 217 }
 218 
 219 - (void)viewDidMoveToWindow
 220 {
 221     //        NSLog(@&quot;viewDidMoveToWindow&quot;);
 222     //        NSLog(@&quot;        self: %@&quot;, self);
 223     //        NSLog(@&quot;        [self superview]: %@&quot;, [self superview]);
 224     GET_MAIN_JENV;
 225     if ([self-&gt;nsView window] != nil)
 226     {
 227         if (self-&gt;parentHost == nil)
 228         {
 229             self-&gt;parentHost = (GlassHostView*)[[self-&gt;nsView superview] retain];
 230         }
 231         if (self-&gt;parentWindow == nil)
 232         {
 233             self-&gt;parentWindow = [[self-&gt;nsView window] retain];
 234         }
 235 
 236         [[self-&gt;nsView window] setAcceptsMouseMovedEvents:YES];
 237         (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyEvent, com_sun_glass_events_ViewEvent_ADD);
 238     }
 239     else
 240     {
 241         if (self-&gt;parentWindow != nil)
 242         {
 243             [self-&gt;parentWindow release];
 244             self-&gt;parentWindow = nil;
 245         }
 246         (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyEvent, com_sun_glass_events_ViewEvent_REMOVE);
 247     }
 248     GLASS_CHECK_EXCEPTION(env);
 249 }
 250 
 251 - (void)setFrameOrigin:(NSPoint)newOrigin
 252 {
 253 
 254 }
 255 
 256 - (void)setFrameSize:(NSSize)newSize
 257 {
 258     LOG(&quot;GlassViewDelegate setFrameSize %fx%f&quot;, newSize.width, newSize.height);
 259 
 260     //NSLog(@&quot;GlassViewDelegate setFrameSize: %dx%d&quot;, (int)newSize.width, (int)newSize.height);
 261     // TODO: listen for resize view&#39;s notifications
 262     GET_MAIN_JENV;
 263     (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyResize, (int)newSize.width, (int)newSize.height);
 264     GLASS_CHECK_EXCEPTION(env);
 265 
 266     [self-&gt;nsView removeTrackingRect:self-&gt;trackingRect];
 267     self-&gt;trackingRect = [self-&gt;nsView addTrackingRect:[self-&gt;nsView bounds] owner:self-&gt;nsView userData:nil assumeInside:NO];
 268 }
 269 
 270 - (void)setFrame:(NSRect)frameRect
 271 {
 272     LOG(&quot;GlassViewDelegate setFrame %fx%f&quot;, frameRect.size.width, frameRect.size.height);
 273 
 274     //NSLog(@&quot;GlassViewDelegate setFrame: %d,%d %dx%d&quot;, (int)frameRect.origin.x, (int)frameRect.origin.y, (int)frameRect.size.width, (int)frameRect.size.height);
 275     // TODO: listen for resize view&#39;s notifications
 276     GET_MAIN_JENV;
 277     (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyResize, (int)frameRect.size.width, (int)frameRect.size.height);
 278     GLASS_CHECK_EXCEPTION(env);
 279 
 280     [self-&gt;nsView removeTrackingRect:self-&gt;trackingRect];
 281     self-&gt;trackingRect = [self-&gt;nsView addTrackingRect:[self-&gt;nsView bounds] owner:self-&gt;nsView userData:nil assumeInside:NO];
 282 }
 283 
 284 - (void)updateTrackingAreas
 285 {
 286     [self-&gt;nsView removeTrackingRect:self-&gt;trackingRect];
 287     self-&gt;trackingRect = [self-&gt;nsView addTrackingRect:[self-&gt;nsView bounds] owner:self-&gt;nsView userData:nil assumeInside:NO];
 288 }
 289 
 290 - (void)drawRect:(NSRect)dirtyRect
 291 {
 292     //NSLog(@&quot;BEGIN View:drawRect %@: &quot;, self);
 293     //NSLog(@&quot;        [self frame]: %f,%f %fx%f&quot;, [self-&gt;nsView frame].origin.x, [self-&gt;nsView frame].origin.y, [self-&gt;nsView frame].size.width, [self-&gt;nsView frame].size.height);
 294     GET_MAIN_JENV;
 295     jint x = (jint)[self-&gt;nsView frame].origin.x;
 296     jint y = (jint)[self-&gt;nsView frame].origin.y;
 297     jint w = (jint)[self-&gt;nsView frame].size.width;
 298     jint h = (jint)[self-&gt;nsView frame].size.height;
 299     (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyRepaint, x, y, w, h);
 300     GLASS_CHECK_EXCEPTION(env);
 301     //NSLog(@&quot;END drawRect&quot;);
 302 }
 303 
 304 - (void)sendJavaMenuEvent:(NSEvent *)theEvent
 305 {
 306 //    NSLog(@&quot;sendJavaMenuEvent&quot;);
 307     NSWindow * nswindow = [nsView window];
 308     if (nswindow &amp;&amp; [[nswindow delegate] isKindOfClass: [GlassWindow class]]) {
 309         GlassWindow *window = (GlassWindow*)[nswindow delegate];
 310         if (!window-&gt;isEnabled) {
 311             return;
 312         }
 313     }
 314     NSPoint viewPoint = [nsView convertPoint:[theEvent locationInWindow] fromView:nil]; // convert from window coordinates to view coordinates
 315     CGPoint basePoint = CGEventGetLocation([theEvent CGEvent]);
 316 
 317     GET_MAIN_JENV;
 318     jboolean isKeyboardTrigger = JNI_FALSE;
 319     (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyMenu,
 320                             (jint)viewPoint.x, (jint)viewPoint.y, (jint)basePoint.x, (jint)basePoint.y, isKeyboardTrigger);
 321     GLASS_CHECK_EXCEPTION(env);
 322 }
 323 
 324 - (void)sendJavaMouseEvent:(NSEvent *)theEvent
 325 {
 326     NSWindow * nswindow = [nsView window];
 327     if (nswindow &amp;&amp; [[nswindow delegate] isKindOfClass: [GlassWindow class]]) {
 328         GlassWindow *window = (GlassWindow*)[nswindow delegate];
 329         if (!window-&gt;isEnabled) {
 330             return;
 331         }
 332     }
 333 
 334     int type = 0;
 335     int button = com_sun_glass_events_MouseEvent_BUTTON_NONE;
 336     switch ([theEvent type])
 337     {
 338         case NSLeftMouseDown:
 339             type = com_sun_glass_events_MouseEvent_DOWN;
 340             button = com_sun_glass_events_MouseEvent_BUTTON_LEFT;
 341             break;
 342         case NSRightMouseDown:
 343             type = com_sun_glass_events_MouseEvent_DOWN;
 344             button = com_sun_glass_events_MouseEvent_BUTTON_RIGHT;
 345             break;
 346         case NSOtherMouseDown:
 347             type = com_sun_glass_events_MouseEvent_DOWN;
 348             switch ([theEvent buttonNumber]) {
 349                 case 2:
 350                     button = com_sun_glass_events_MouseEvent_BUTTON_OTHER;
 351                     break;
 352                 case 3:
 353                     button = com_sun_glass_events_MouseEvent_BUTTON_BACK;
 354                     break;
 355                 case 4:
 356                     button = com_sun_glass_events_MouseEvent_BUTTON_FORWARD;
 357                     break;
 358             }
 359             break;
 360 
 361         case NSLeftMouseUp:
 362             type = com_sun_glass_events_MouseEvent_UP;
 363             button = com_sun_glass_events_MouseEvent_BUTTON_LEFT;
 364             break;
 365         case NSRightMouseUp:
 366             type = com_sun_glass_events_MouseEvent_UP;
 367             button = com_sun_glass_events_MouseEvent_BUTTON_RIGHT;
 368             break;
 369         case NSOtherMouseUp:
 370             type = com_sun_glass_events_MouseEvent_UP;
 371             switch ([theEvent buttonNumber]) {
 372                 case 2:
 373                     button = com_sun_glass_events_MouseEvent_BUTTON_OTHER;
 374                     break;
 375                 case 3:
 376                     button = com_sun_glass_events_MouseEvent_BUTTON_BACK;
 377                     break;
 378                 case 4:
 379                     button = com_sun_glass_events_MouseEvent_BUTTON_FORWARD;
 380                     break;
 381             }
 382             break;
 383 
 384         case NSLeftMouseDragged:
 385             type = com_sun_glass_events_MouseEvent_DRAG;
 386             button = com_sun_glass_events_MouseEvent_BUTTON_LEFT;
 387             break;
 388         case NSRightMouseDragged:
 389             type = com_sun_glass_events_MouseEvent_DRAG;
 390             button = com_sun_glass_events_MouseEvent_BUTTON_RIGHT;
 391             break;
 392         case NSOtherMouseDragged:
 393             type = com_sun_glass_events_MouseEvent_DRAG;
 394             switch ([theEvent buttonNumber]) {
 395                 case 2:
 396                     button = com_sun_glass_events_MouseEvent_BUTTON_OTHER;
 397                     break;
 398                 case 3:
 399                     button = com_sun_glass_events_MouseEvent_BUTTON_BACK;
 400                     break;
 401                 case 4:
 402                     button = com_sun_glass_events_MouseEvent_BUTTON_FORWARD;
 403                     break;
 404             }
 405             break;
 406 
 407         case NSMouseMoved:
 408             type = com_sun_glass_events_MouseEvent_MOVE;
 409             break;
 410 
 411         case NSMouseEntered:
 412             type = com_sun_glass_events_MouseEvent_ENTER;
 413             [GlassTouches startTracking:self];
 414             self-&gt;lastTrackingNumber = [theEvent trackingNumber];
 415             break;
 416 
 417         case NSMouseExited:
 418             type = com_sun_glass_events_MouseEvent_EXIT;
 419             [GlassTouches stopTracking:self];
 420             self-&gt;lastTrackingNumber = [theEvent trackingNumber];
 421             break;
 422 
 423         case NSScrollWheel:
 424             type = com_sun_glass_events_MouseEvent_WHEEL;
 425             break;
 426     }
 427 
 428     NSPoint viewPoint = [nsView convertPoint:[theEvent locationInWindow] fromView:nil]; // convert from window coordinates to view coordinates
 429     CGPoint basePoint = CGEventGetLocation([theEvent CGEvent]);
 430 
 431     if (type == com_sun_glass_events_MouseEvent_MOVE)
 432     {
 433         NSRect frame = [nsView frame];
 434 
 435         if (viewPoint.x &lt; 0 || viewPoint.y &lt; 0 ||
 436                 viewPoint.x &gt;= frame.size.width ||
 437                 viewPoint.y &gt;= frame.size.height)
 438         {
 439             // The MOVE events happening outside of the view must be ignored
 440             return;
 441         }
 442 
 443         // Check if the event is a duplicate
 444         if (self-&gt;lastEvent)
 445         {
 446             CGPoint oldBasePoint = CGEventGetLocation([self-&gt;lastEvent CGEvent]);
 447 
 448             if (basePoint.x == oldBasePoint.x &amp;&amp; basePoint.y == oldBasePoint.y)
 449             {
 450                 return;
 451             }
 452         }
 453     }
 454 
 455         //    NSLog(@&quot;Event location: in window %@, in view %@, in base coordinates %d,%d&quot;,
 456         //          NSStringFromPoint([theEvent locationInWindow]),
 457         //          NSStringFromPoint(viewPoint),
 458         //          (jint)basePoint.x, (jint)basePoint.y);
 459 
 460     jdouble rotationX = 0.0;
 461     jdouble rotationY = 0.0;
 462     if (type == com_sun_glass_events_MouseEvent_WHEEL)
 463     {
 464         if ([theEvent hasPreciseScrollingDeltas])
 465         {
 466             rotationX = (jdouble)[theEvent scrollingDeltaX] * 0.1;
 467             rotationY = (jdouble)[theEvent scrollingDeltaY] * 0.1;
 468         }
 469         else
 470         {
 471             rotationX = (jdouble)[theEvent deltaX];
 472             rotationY = (jdouble)[theEvent deltaY];
 473         }
 474         
 475         //XXX: check for equality for doubles???
 476         if (rotationX == 0.0 &amp;&amp; rotationY == 0.0)
 477         {
 478             return;
 479         }
 480     }
 481 
 482     BOOL block = NO;
 483     {
 484         // RT-5892
 485         if ((type == com_sun_glass_events_MouseEvent_ENTER) || (type == com_sun_glass_events_MouseEvent_EXIT))
 486         {
 487             // userData indicates if this is a synthesized EXIT event that MUST pass through
 488             // Note: userData is only valid for ENTER/EXIT events!
 489             if (self-&gt;mouseIsDown == YES &amp;&amp; [theEvent userData] != self)
 490             {
 491                 block = [self suppressMouseEnterExitOnMouseDown];
 492             }
 493         }
 494         else
 495         {
 496             // for the mouse supression we can not look at the mouse down state during ENTER/EXIT events
 497             // as they always report mouse up regardless of the actual state, so we need to store it
 498             // based on the events other than ENTER/EXIT
 499             self-&gt;mouseIsDown = (button != com_sun_glass_events_MouseEvent_BUTTON_NONE);
 500         }
 501     }
 502     if (block == NO)
 503     {
 504         if (!self-&gt;mouseIsOver &amp;&amp;
 505                 type != com_sun_glass_events_MouseEvent_ENTER &amp;&amp;
 506                 type != com_sun_glass_events_MouseEvent_EXIT)
 507         {
 508             // OS X didn&#39;t send mouseEnter. Synthesize it here.
 509             NSEvent *eeEvent = [NSEvent enterExitEventWithType:NSMouseEntered
 510                                                       location:[theEvent locationInWindow]
 511                                                  modifierFlags:[theEvent modifierFlags]
 512                                                      timestamp:[theEvent timestamp]
 513                                                   windowNumber:[theEvent windowNumber]
 514                                                        context:[theEvent context]
 515                                                    eventNumber:0
 516                                                 trackingNumber:self-&gt;lastTrackingNumber
 517                                                       userData:self];
 518             [self sendJavaMouseEvent:eeEvent];
 519         }
 520 
 521         jint modifiers = GetJavaKeyModifiers(theEvent);
 522         if (type != com_sun_glass_events_MouseEvent_ENTER &amp;&amp;
 523             type != com_sun_glass_events_MouseEvent_EXIT) {
 524             modifiers |= GetJavaMouseModifiers([NSEvent pressedMouseButtons]);
 525             if (type != com_sun_glass_events_MouseEvent_UP)
 526             {
 527                 switch (button)
 528                 {
 529                     case com_sun_glass_events_MouseEvent_BUTTON_LEFT:
 530                         modifiers |= com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_PRIMARY;
 531                         break;
 532                     case com_sun_glass_events_MouseEvent_BUTTON_RIGHT:
 533                         modifiers |= com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_SECONDARY;
 534                         break;
 535                     case com_sun_glass_events_MouseEvent_BUTTON_OTHER:
 536                         modifiers |= com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_MIDDLE;
 537                         break;
 538                     case com_sun_glass_events_MouseEvent_BUTTON_BACK:
 539                         modifiers |= com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_BACK;
 540                         break;
 541                     case com_sun_glass_events_MouseEvent_BUTTON_FORWARD:
 542                         modifiers |= com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_FORWARD;
 543                         break;
 544                 }
 545             }
 546         }
 547 
 548         jboolean isSynthesized = JNI_FALSE;
 549 
 550         jboolean isPopupTrigger = JNI_FALSE;
 551         if (type == com_sun_glass_events_MouseEvent_DOWN) {
 552             if (button == com_sun_glass_events_MouseEvent_BUTTON_RIGHT) {
 553                 isPopupTrigger = JNI_TRUE;
 554             }
 555             if (button == com_sun_glass_events_MouseEvent_BUTTON_LEFT &amp;&amp;
 556                 (modifiers &amp; com_sun_glass_events_KeyEvent_MODIFIER_CONTROL))
 557             {
 558                 isPopupTrigger = JNI_TRUE;
 559             }
 560         }
 561 
 562         [self-&gt;lastEvent release];
 563         self-&gt;lastEvent = nil;
 564         switch (type) {
 565             // prepare GlassDragSource for possible drag,
 566             case com_sun_glass_events_MouseEvent_DOWN:
 567                 switch (button) {
 568                     case com_sun_glass_events_MouseEvent_BUTTON_LEFT:    self-&gt;mouseDownMask |= 1 &lt;&lt; 0; break;
 569                     case com_sun_glass_events_MouseEvent_BUTTON_RIGHT:   self-&gt;mouseDownMask |= 1 &lt;&lt; 1; break;
 570                     case com_sun_glass_events_MouseEvent_BUTTON_OTHER:   self-&gt;mouseDownMask |= 1 &lt;&lt; 2; break;
 571                     case com_sun_glass_events_MouseEvent_BUTTON_BACK:    self-&gt;mouseDownMask |= 1 &lt;&lt; 3; break;
 572                     case com_sun_glass_events_MouseEvent_BUTTON_FORWARD: self-&gt;mouseDownMask |= 1 &lt;&lt; 4; break;
 573                 }
 574                 //fall through
 575             case com_sun_glass_events_MouseEvent_DRAG:
 576                 [GlassDragSource setDelegate:self];
 577                 // fall through to save the lastEvent
 578             // or for filtering out duplicate MOVE events
 579             case com_sun_glass_events_MouseEvent_MOVE:
 580                 self-&gt;lastEvent = [theEvent retain];
 581                 break;
 582             case com_sun_glass_events_MouseEvent_UP:
 583                 switch (button) {
 584                     case com_sun_glass_events_MouseEvent_BUTTON_LEFT:    self-&gt;mouseDownMask &amp;= ~(1 &lt;&lt; 0); break;
 585                     case com_sun_glass_events_MouseEvent_BUTTON_RIGHT:   self-&gt;mouseDownMask &amp;= ~(1 &lt;&lt; 1); break;
 586                     case com_sun_glass_events_MouseEvent_BUTTON_OTHER:   self-&gt;mouseDownMask &amp;= ~(1 &lt;&lt; 2); break;
 587                     case com_sun_glass_events_MouseEvent_BUTTON_BACK:    self-&gt;mouseDownMask &amp;= ~(1 &lt;&lt; 3); break;
 588                     case com_sun_glass_events_MouseEvent_BUTTON_FORWARD: self-&gt;mouseDownMask &amp;= ~(1 &lt;&lt; 4); break;
 589                 }
 590                 break;
 591 
 592 
 593 
 594             // Track whether the mouse is over the view
 595             case com_sun_glass_events_MouseEvent_ENTER:
 596                 self-&gt;mouseIsOver = YES;
 597                 break;
 598             case com_sun_glass_events_MouseEvent_EXIT:
 599                 self-&gt;mouseIsOver = NO;
 600                 break;
 601         }
 602 
 603         GET_MAIN_JENV;
 604         if (type == com_sun_glass_events_MouseEvent_WHEEL) {
 605             // Detect mouse wheel event sender.
 606             // Can be inertia from scroll gesture,
 607             // scroll gesture or mouse wheel itself
 608             //
 609             // RT-22388, RT-25269
 610             jint sender = com_sun_glass_ui_mac_MacGestureSupport_SCROLL_SRC_WHEEL;
 611             if (isInertialScroll(theEvent))
 612             {
 613                 sender = com_sun_glass_ui_mac_MacGestureSupport_SCROLL_SRC_INERTIA;
 614             }
 615             else if (self-&gt;gestureInProgress == YES)
 616             {
 617                 sender = com_sun_glass_ui_mac_MacGestureSupport_SCROLL_SRC_GESTURE;
 618             }
 619 
 620             const jclass jGestureSupportClass = [GlassHelper ClassForName:&quot;com.sun.glass.ui.mac.MacGestureSupport&quot;
 621                                                                   withEnv:env];
 622             if (jGestureSupportClass)
 623             {
 624                 (*env)-&gt;CallStaticVoidMethod(env, jGestureSupportClass,
 625                                              javaIDs.GestureSupport.scrollGesturePerformed,
 626                                              self-&gt;jView, modifiers, sender,
 627                                              (jint)viewPoint.x, (jint)viewPoint.y,
 628                                              (jint)basePoint.x, (jint)basePoint.y,
 629                                              rotationX, rotationY);
 630             }
 631         } else {
 632             (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyMouse, type, button,
 633                     (jint)viewPoint.x, (jint)viewPoint.y, (jint)basePoint.x, (jint)basePoint.y,
 634                     modifiers, isPopupTrigger, isSynthesized);
 635         }
 636         GLASS_CHECK_EXCEPTION(env);
 637 
 638         if (isPopupTrigger) {
 639             [self sendJavaMenuEvent:theEvent];
 640         }
 641     }
 642 }
 643 
 644 - (void)resetMouseTracking
 645 {
 646     if (self-&gt;mouseIsOver) {
 647         // Nothing of the parameters really matters for the EXIT event, except userData
 648         NSEvent* theEvent = [NSEvent
 649             enterExitEventWithType:NSMouseExited
 650                           location:[NSEvent mouseLocation]
 651                      modifierFlags:0
 652                          timestamp:[NSDate timeIntervalSinceReferenceDate]
 653                       windowNumber:[[self-&gt;nsView window] windowNumber]
 654                            context:[NSGraphicsContext currentContext]
 655                        eventNumber:0
 656                     trackingNumber:self-&gt;lastTrackingNumber
 657                           userData:self]; // indicates that this is a synthesized event
 658 
 659         [self sendJavaMouseEvent:theEvent];
 660     }
 661 }
 662 
 663 // RT-11707: zero out the keycode for TYPED events
 664 #define SEND_KEY_EVENT(type) \
 665     (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyKey, (type), \
 666             (type) == com_sun_glass_events_KeyEvent_TYPED ? 0 : jKeyCode, \
 667             jKeyChars, jModifiers); \
 668     GLASS_CHECK_EXCEPTION(env);
 669 
 670 - (void)sendJavaKeyEvent:(NSEvent *)theEvent isDown:(BOOL)isDown
 671 {
 672     if (theEvent == s_lastKeyEvent) {
 673         // this must be a keyDown: generated by performKeyEquivalent: which returns NO by design
 674         return;
 675     }
 676     [s_lastKeyEvent release];
 677     s_lastKeyEvent = [theEvent retain];
 678 
 679     GET_MAIN_JENV;
 680 
 681     jint jKeyCode = GetJavaKeyCode(theEvent);
 682     jcharArray jKeyChars = GetJavaKeyChars(env, theEvent);
 683     jint jModifiers = GetJavaModifiers(theEvent);
 684 
 685     // Short circuit here: If this is a synthetic key-typed from a text event
 686     // post it and return.
 687     if ([theEvent isKindOfClass:[GlassNSEvent class]]) {
 688         if ([(GlassNSEvent *)theEvent isSyntheticKeyTyped]) {
 689             SEND_KEY_EVENT(com_sun_glass_events_KeyEvent_TYPED);
 690             (*env)-&gt;DeleteLocalRef(env, jKeyChars);
 691             return;
 692         }
 693     }
 694 
 695     if (!isDown)
 696     {
 697         SEND_KEY_EVENT(com_sun_glass_events_KeyEvent_RELEASE);
 698     }
 699     else
 700     {
 701         SEND_KEY_EVENT(com_sun_glass_events_KeyEvent_PRESS);
 702 
 703         // In the applet case, FireFox always sends a text input event after every
 704         // key-pressed, which gets turned into a TYPED event for simple key strokes.
 705         // The NPAPI support code will send a boolean to let us know if we need to
 706         // generate the TYPED, or if we should expect the input method support to do it.
 707         BOOL sendKeyTyped = YES;
 708 
 709         if ([theEvent isKindOfClass:[GlassNSEvent class]]) {
 710             sendKeyTyped = [(GlassNSEvent *)theEvent needsKeyTyped];
 711         }
 712 
 713         // TYPED events should only be sent for printable characters. Thus we avoid
 714         // sending them for navigation keys. Perhaps this logic could be enhanced.
 715         if (sendKeyTyped) {
 716             if (jKeyCode &lt; com_sun_glass_events_KeyEvent_VK_PAGE_UP ||
 717                 jKeyCode &gt; com_sun_glass_events_KeyEvent_VK_DOWN)
 718             {
 719                 SEND_KEY_EVENT(com_sun_glass_events_KeyEvent_TYPED);
 720             }
 721 
 722             // Quirk in Firefox: If we have to generate a key-typed and this
 723             // event is a repeat we will also need to generate a fake RELEASE event
 724             // because we won&#39;t see a key-release.
 725             if ([theEvent isARepeat] &amp;&amp;
 726                 [[self-&gt;nsView window] isKindOfClass:[GlassEmbeddedWindow class]]) {
 727                 SEND_KEY_EVENT(com_sun_glass_events_KeyEvent_RELEASE);
 728             }
 729         }
 730 
 731         // Mac doesn&#39;t send keyUp for Cmd+&lt;&gt; key combinations (including Shift+Cmd+&lt;&gt;, etc.)
 732         // So we synthesize the event
 733         if (jModifiers &amp; com_sun_glass_events_KeyEvent_MODIFIER_COMMAND)
 734         {
 735             SEND_KEY_EVENT(com_sun_glass_events_KeyEvent_RELEASE);
 736         }
 737     }
 738 
 739     (*env)-&gt;DeleteLocalRef(env, jKeyChars);
 740     GLASS_CHECK_EXCEPTION(env);
 741 }
 742 
 743 #define SEND_MODIFIER_KEY_EVENT_WITH_TYPE(type, vkCode) \
 744         (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyKey, \
 745                 (type), \
 746                 (vkCode), \
 747                 jKeyChars, jModifiers);
 748 
 749 #define SEND_MODIFIER_KEY_EVENT(mask, vkCode) \
 750     if (changedFlags &amp; (mask)) { \
 751         SEND_MODIFIER_KEY_EVENT_WITH_TYPE(currentFlags &amp; (mask) ? com_sun_glass_events_KeyEvent_PRESS : com_sun_glass_events_KeyEvent_RELEASE, vkCode); \
 752         GLASS_CHECK_EXCEPTION(env); \
 753     }
 754 
 755 - (void)sendJavaModifierKeyEvent:(NSEvent *)theEvent
 756 {
 757     NSUInteger currentFlags = [theEvent modifierFlags] &amp; NSDeviceIndependentModifierFlagsMask;
 758     NSUInteger changedFlags = currentFlags ^ s_modifierFlags;
 759 
 760     jint jModifiers = GetJavaModifiers(theEvent);
 761 
 762     GET_MAIN_JENV;
 763     jcharArray jKeyChars = (*env)-&gt;NewCharArray(env, 0);
 764 
 765     SEND_MODIFIER_KEY_EVENT(NSShiftKeyMask,       com_sun_glass_events_KeyEvent_VK_SHIFT);
 766     SEND_MODIFIER_KEY_EVENT(NSControlKeyMask,     com_sun_glass_events_KeyEvent_VK_CONTROL);
 767     SEND_MODIFIER_KEY_EVENT(NSAlternateKeyMask,   com_sun_glass_events_KeyEvent_VK_ALT);
 768     SEND_MODIFIER_KEY_EVENT(NSCommandKeyMask,     com_sun_glass_events_KeyEvent_VK_COMMAND);
 769 
 770     // For CapsLock both PRESS and RELEASE should be synthesized each time
 771     if (changedFlags &amp; NSAlphaShiftKeyMask) {
 772         SEND_MODIFIER_KEY_EVENT_WITH_TYPE(com_sun_glass_events_KeyEvent_PRESS, com_sun_glass_events_KeyEvent_VK_CAPS_LOCK);
 773         SEND_MODIFIER_KEY_EVENT_WITH_TYPE(com_sun_glass_events_KeyEvent_RELEASE, com_sun_glass_events_KeyEvent_VK_CAPS_LOCK);
 774     }
 775 
 776     (*env)-&gt;DeleteLocalRef(env, jKeyChars);
 777     GLASS_CHECK_EXCEPTION(env);
 778 
 779     s_modifierFlags = currentFlags;
 780 }
 781 
 782 - (void)sendJavaGestureEvent:(NSEvent *)theEvent type:(int)type
 783 {
 784     NSPoint viewPoint = [nsView convertPoint:[theEvent locationInWindow] fromView:nil]; // convert from window coordinates to view coordinates
 785     CGPoint basePoint = CGEventGetLocation([theEvent CGEvent]);
 786 
 787     jint modifiers = GetJavaModifiers(theEvent);
 788 
 789     GET_MAIN_JENV;
 790     const jclass jGestureSupportClass = [GlassHelper ClassForName:&quot;com.sun.glass.ui.mac.MacGestureSupport&quot;
 791                                                           withEnv:env];
 792     if (jGestureSupportClass)
 793     {
 794         switch (type)
 795         {
 796             case com_sun_glass_ui_mac_MacGestureSupport_GESTURE_ROTATE:
 797                 (*env)-&gt;CallStaticVoidMethod(env, jGestureSupportClass,
 798                                              javaIDs.GestureSupport.rotateGesturePerformed,
 799                                              self-&gt;jView, modifiers,
 800                                              (jint)viewPoint.x, (jint)viewPoint.y,
 801                                              (jint)basePoint.x, (jint)basePoint.y,
 802                                              (jfloat)[theEvent rotation]);
 803                 break;
 804             case com_sun_glass_ui_mac_MacGestureSupport_GESTURE_SWIPE:
 805                 (*env)-&gt;CallStaticVoidMethod(env, jGestureSupportClass,
 806                                              javaIDs.GestureSupport.swipeGesturePerformed,
 807                                              self-&gt;jView, modifiers,
 808                                              getSwipeDirFromEvent(theEvent),
 809                                              (jint)viewPoint.x, (jint)viewPoint.y,
 810                                              (jint)basePoint.x, (jint)basePoint.y);
 811                 break;
 812             case com_sun_glass_ui_mac_MacGestureSupport_GESTURE_MAGNIFY:
 813                 (*env)-&gt;CallStaticVoidMethod(env, jGestureSupportClass,
 814                                              javaIDs.GestureSupport.magnifyGesturePerformed,
 815                                              self-&gt;jView, modifiers,
 816                                              (jint)viewPoint.x, (jint)viewPoint.y,
 817                                              (jint)basePoint.x, (jint)basePoint.y,
 818                                              (jfloat)[theEvent magnification]);
 819                 break;
 820         }
 821     }
 822     GLASS_CHECK_EXCEPTION(env);
 823 }
 824 
 825 - (void)sendJavaGestureBeginEvent:(NSEvent *)theEvent
 826 {
 827     self-&gt;gestureInProgress = YES;
 828 }
 829 
 830 - (void)sendJavaGestureEndEvent:(NSEvent *)theEvent
 831 {
 832     self-&gt;gestureInProgress = NO;
 833 
 834     NSPoint viewPoint = [nsView convertPoint:[theEvent locationInWindow] fromView:nil]; // convert from window coordinates to view coordinates
 835     CGPoint basePoint = CGEventGetLocation([theEvent CGEvent]);
 836 
 837     jint modifiers = GetJavaModifiers(theEvent);
 838 
 839     GET_MAIN_JENV;
 840     const jclass jGestureSupportClass = [GlassHelper ClassForName:&quot;com.sun.glass.ui.mac.MacGestureSupport&quot;
 841                                                           withEnv:env];
 842     if (jGestureSupportClass)
 843     {
 844         (*env)-&gt;CallStaticVoidMethod(env, jGestureSupportClass,
 845                                      javaIDs.GestureSupport.gestureFinished,
 846                                      self-&gt;jView, modifiers,
 847                                      (jint)viewPoint.x, (jint)viewPoint.y,
 848                                      (jint)basePoint.x, (jint)basePoint.y);
 849 
 850     }
 851     GLASS_CHECK_EXCEPTION(env);
 852 }
 853 
 854 /*
 855  * This method is a replacement for the deprecated beginGestureWithEvent
 856  * method, which is no longer delivered to a View by macOS. This
 857  * is called for each gesture event to track the beginning of a
 858  * gesture using the phase of the event. We call sendJavaGestureBeginEvent
 859  * if there are no other gestures active.
 860  */
 861 - (void)maybeBeginGestureWithEvent:(NSEvent *)theEvent withMask:(GestureMaskType)theMask
 862 {
 863     NSEventPhase phase = [theEvent phase];
 864     if (phase == NSEventPhaseBegan) {
 865         if (gesturesBeganMask == 0) {
 866             [self sendJavaGestureBeginEvent:theEvent];
 867         }
 868         gesturesBeganMask |= theMask;
 869     }
 870 }
 871 
 872 /*
 873  * This method is a replacement for the deprecated endGestureWithEvent
 874  * method, which is no longer delivered to a View by macOS. This
 875  * is called for each gesture event to track the end of a
 876  * gesture using the phase of the event. We call sendJavaGestureEndEvent
 877  * if there are no other gestures active.
 878  */
 879 - (void)maybeEndGestureWithEvent:(NSEvent *)theEvent withMask:(GestureMaskType)theMask
 880 {
 881     NSEventPhase phase = [theEvent phase];
 882     if (phase == NSEventPhaseEnded || phase == NSEventPhaseCancelled) {
 883         if ((gesturesBeganMask &amp; theMask) != 0) {
 884             gesturesBeganMask &amp;= ~theMask;
 885             if (gesturesBeganMask == 0) {
 886                 [self sendJavaGestureEndEvent:theEvent];
 887             }
 888         }
 889     }
 890 }
 891 
 892 - (void)doRotateWithEvent:(NSEvent *)theEvent
 893 {
 894     [self maybeBeginGestureWithEvent:theEvent withMask:GESTURE_MASK_ROTATE];
 895     [self sendJavaGestureEvent:theEvent type:com_sun_glass_ui_mac_MacGestureSupport_GESTURE_ROTATE];
 896     [self maybeEndGestureWithEvent:theEvent withMask:GESTURE_MASK_ROTATE];
 897 }
 898 
 899 - (void)doSwipeWithEvent:(NSEvent *)theEvent
 900 {
 901     [self maybeBeginGestureWithEvent:theEvent withMask:GESTURE_MASK_SWIPE];
 902     [self sendJavaGestureEvent:theEvent type:com_sun_glass_ui_mac_MacGestureSupport_GESTURE_SWIPE];
 903     [self maybeEndGestureWithEvent:theEvent withMask:GESTURE_MASK_SWIPE];
 904 }
 905 
 906 - (void)doMagnifyWithEvent:(NSEvent *)theEvent
 907 {
 908     [self maybeBeginGestureWithEvent:theEvent withMask:GESTURE_MASK_MAGNIFY];
 909     [self sendJavaGestureEvent:theEvent type:com_sun_glass_ui_mac_MacGestureSupport_GESTURE_MAGNIFY];
 910     [self maybeEndGestureWithEvent:theEvent withMask:GESTURE_MASK_MAGNIFY];
 911 }
 912 
 913 - (void)doScrollWheel:(NSEvent *)theEvent
 914 {
 915     [self maybeBeginGestureWithEvent:theEvent withMask:GESTURE_MASK_SCROLL];
 916     [self sendJavaMouseEvent:theEvent];
 917     [self maybeEndGestureWithEvent:theEvent withMask:GESTURE_MASK_SCROLL];
 918 }
 919 
 920 - (NSDragOperation)sendJavaDndEvent:(id &lt;NSDraggingInfo&gt;)info type:(jint)type
 921 {
 922     GET_MAIN_JENV;
 923 
 924     NSPoint draggingLocation = [nsView convertPoint:[info draggingLocation] fromView:nil];
 925     int x = (int)draggingLocation.x;
 926     int y = (int)draggingLocation.y;
 927 
 928     int xAbs = (int)([info draggingLocation].x + [self-&gt;nsView window].frame.origin.x);
 929     int yAbs = (int)([[self-&gt;nsView window] screen].frame.size.height - [self-&gt;nsView window].frame.origin.y
 930                      - [info draggingLocation].y);
 931 
 932     int mask;
 933     NSDragOperation operation = [info draggingSourceOperationMask];
 934 
 935     [GlassDragSource setSupportedActions:[GlassDragSource mapNsOperationToJavaMask:operation]];
 936 
 937     jint recommendedAction = [GlassDragSource getRecommendedActionForMask:operation];
 938     switch (type)
 939     {
 940         case com_sun_glass_events_DndEvent_ENTER:
 941             DNDLOG(&quot;com_sun_glass_events_DndEvent_ENTER&quot;);
 942             copyToDragPasteboardIfNeeded(info);
 943             mask = (*env)-&gt;CallIntMethod(env, self-&gt;jView, jViewNotifyDragEnter, x, y, xAbs, yAbs, recommendedAction);
 944             break;
 945         case com_sun_glass_events_DndEvent_UPDATE:
 946             DNDLOG(&quot;com_sun_glass_events_DndEvent_UPDATE&quot;);
 947             mask = (*env)-&gt;CallIntMethod(env, self-&gt;jView, jViewNotifyDragOver, x, y, xAbs, yAbs, recommendedAction);
 948             break;
 949         case com_sun_glass_events_DndEvent_PERFORM:
 950             DNDLOG(&quot;com_sun_glass_events_DndEvent_PERFORM&quot;);
 951             mask = (*env)-&gt;CallIntMethod(env, self-&gt;jView, jViewNotifyDragDrop, x, y, xAbs, yAbs, recommendedAction);
 952             break;
 953         case com_sun_glass_events_DndEvent_EXIT:
 954             DNDLOG(&quot;com_sun_glass_events_DndEvent_EXIT&quot;);
 955             (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyDragLeave);
 956             mask = com_sun_glass_ui_Clipboard_ACTION_NONE;
 957             break;
 958         default:
 959             mask = com_sun_glass_ui_Clipboard_ACTION_NONE;
 960             break;
 961     }
 962     [GlassDragSource setMask:mask];
 963 
 964     GLASS_CHECK_EXCEPTION(env);
 965 
 966     return [GlassDragSource mapJavaMaskToNsOperation:[GlassDragSource getMask]];
 967 }
 968 
 969 - (NSDragOperation)draggingSourceOperationMaskForLocal:(BOOL)isLocal
 970 {
 971     return self-&gt;dragOperation;
 972 }
 973 
 974 // called from Java layer drag handler, triggered by DnD Pasteboard flush
 975 - (void)startDrag:(NSDragOperation)operation
 976 {
 977     DNDLOG(&quot;startDrag&quot;);
 978     self-&gt;dragOperation = operation;
 979     {
 980         NSPoint dragPoint = [self-&gt;nsView convertPoint:[self-&gt;lastEvent locationInWindow] fromView:nil];
 981         NSPasteboard *pasteboard = [NSPasteboard pasteboardWithName:NSDragPboard];
 982         NSImage *image = nil;
 983 
 984         if ([[pasteboard types] containsObject:DRAG_IMAGE_MIME]) {
 985             //Try to init with drag image specified by the user
 986             image = [[NSImage alloc] initWithData:[pasteboard dataForType:DRAG_IMAGE_MIME]];
 987         }
 988 
 989         if (image == nil &amp;&amp; [NSImage canInitWithPasteboard:pasteboard] == YES)
 990         {
 991             // ask the Pasteboard for ist own image representation of its contents
 992             image = [[NSImage alloc] initWithPasteboard:pasteboard];
 993         }
 994 
 995         if (image != nil)
 996         {
 997             // check the drag image size and scale it down as needed using Safari behavior (sizes) as reference
 998             CGFloat width = [image size].width;
 999             CGFloat height = [image size].height;
1000             if ((width &gt; MAX_DRAG_SIZE) || (height &gt; MAX_DRAG_SIZE))
1001             {
1002                 if (width &gt;= height)
1003                 {
1004                     CGFloat ratio = height/width;
1005                     width = MIN(width, MAX_DRAG_SIZE);
1006                     height = ratio * width;
1007                     [image setSize:NSMakeSize(width, height)];
1008                 }
1009                 else
1010                 {
1011                     CGFloat ratio = width/height;
1012                     height = MIN(height, MAX_DRAG_SIZE);
1013                     width = ratio * height;
1014                     [image setSize:NSMakeSize(width, height)];
1015                 }
1016             }
1017         } else {
1018             NSArray *items = [pasteboard pasteboardItems];
1019             if ([items count] == 1)
1020             {
1021                 image = [[NSImage alloc] initWithContentsOfFile:@&quot;/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/GenericDocumentIcon.icns&quot;];
1022             }
1023 
1024             if (image == nil)
1025             {
1026                 image = [[NSImage imageNamed:NSImageNameMultipleDocuments] retain];
1027             }
1028 
1029             [image setSize:NSMakeSize(DEFAULT_DRAG_SIZE, DEFAULT_DRAG_SIZE)];
1030         }
1031 
1032         if (image != nil)
1033         {
1034             // select the center of the image as the drag origin
1035             // TODO http://javafx-jira.kenai.com/browse/RT-17629
1036             // would be nice to get this info from the Java layer,
1037             // so that we could adjust the drag image origin based on where in the src it was clicked on
1038             dragPoint.x -= ([image size].width/2.0f);
1039             dragPoint.y += ([image size].height/2.0f);
1040 
1041             NSString *offsetString = [pasteboard stringForType:DRAG_IMAGE_OFFSET];
1042             if (offsetString != nil) {
1043                 NSPoint offset = NSPointFromString(offsetString);
1044                 //Adjust offset to the image size
1045                 float imageHalfX = [image size].width/2.0f;
1046                 float imageHalfY = [image size].height/2.0f;
1047 
1048                 if (offset.x &gt; imageHalfX || offset.x &lt; -imageHalfX) {
1049                     offset.x = imageHalfX * (offset.x &gt; 0 ? 1 : -1);
1050                 }
1051                 if (offset.y &gt; imageHalfY || offset.y &lt; -imageHalfY) {
1052                     offset.y = imageHalfY * (offset.y &gt; 0 ? 1 : -1);
1053                 }
1054 
1055                 dragPoint.x += offset.x;
1056                 dragPoint.y -= offset.y;
1057             }
1058         }
1059         else
1060         {
1061             // last resource: &quot;empty&quot; image
1062             image = [[NSImage alloc] initWithSize:NSMakeSize(1.0f, 1.0f)];
1063         }
1064         [self-&gt;nsView dragImage:image at:dragPoint offset:NSZeroSize event:self-&gt;lastEvent pasteboard:pasteboard source:self-&gt;nsView slideBack:YES];
1065 
1066         // main thread blocked here until drag completes
1067 
1068         [GlassDragSource setDelegate:nil];
1069 
1070         [image release];
1071     }
1072     self-&gt;dragOperation = NSDragOperationNone;
1073 }
1074 
1075 - (void)synthesizeMouseUp:(NSEventType)type
1076 {
1077     NSEvent* theEvent = [NSEvent
1078         mouseEventWithType:type
1079                   location:[NSEvent mouseLocation]
1080              modifierFlags:0
1081                  timestamp:[NSDate timeIntervalSinceReferenceDate]
1082               windowNumber:[[self-&gt;nsView window] windowNumber]
1083                    context:[NSGraphicsContext currentContext]
1084                eventNumber:0
1085                 clickCount:0
1086                   pressure:0.0];
1087 
1088     [self sendJavaMouseEvent:theEvent];
1089 }
1090 
1091 - (void)draggingEnded
1092 {
1093     GET_MAIN_JENV;
1094     (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyDragEnd,  [GlassDragSource getMask]);
1095     GLASS_CHECK_EXCEPTION(env);
1096 
1097     // RT-36038: OS X won&#39;t send mouseUp after DnD is complete, so we synthesize them
1098     if (self-&gt;mouseDownMask &amp; 1 &lt;&lt; 0) [self synthesizeMouseUp:NSLeftMouseUp];
1099     if (self-&gt;mouseDownMask &amp; 1 &lt;&lt; 1) [self synthesizeMouseUp:NSRightMouseUp];
1100     if (self-&gt;mouseDownMask &amp; 1 &lt;&lt; 2) [self synthesizeMouseUp:NSOtherMouseUp];
1101 }
1102 
1103 - (BOOL)suppressMouseEnterExitOnMouseDown
1104 {
1105     return YES;
1106 }
1107 
1108 static jstring convertNSStringToJString(id aString, int length)
1109 {
1110     GET_MAIN_JENV;
1111 
1112     jstring jStr;
1113     if ([aString isKindOfClass:[NSAttributedString class]]) {
1114         NSData *data = [[aString string] dataUsingEncoding:NSUTF16LittleEndianStringEncoding];
1115         jchar *dataBytes = (jchar *)malloc(sizeof(jchar) * length);
1116         if (dataBytes != NULL) {
1117             [data getBytes:dataBytes length:length * 2];
1118             jStr = (*env)-&gt;NewString(env, dataBytes, length);
1119             free(dataBytes);
1120         }
1121     } else {
1122         jStr = (*env)-&gt;NewStringUTF(env, [aString UTF8String]);
1123     }
1124 
1125     GLASS_CHECK_EXCEPTION(env);
1126 
1127     return jStr;
1128 }
1129 
1130 - (void)notifyInputMethod:(id) aString attr:(int)attr length:(int)length cursor:(int)cursor
1131             selectedRange:(NSRange)selectionRange
1132 {
1133     if ([NSThread isMainThread] == YES)
1134     {
1135         GET_MAIN_JENV;
1136         
1137         jstring jStr = convertNSStringToJString(aString, length);
1138         if (jStr != NULL) {
1139             (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyInputMethodMac, jStr, attr,
1140                                    length, cursor, selectionRange.location,
1141                                    selectionRange.length);
1142         }
1143         GLASS_CHECK_EXCEPTION(env);
1144     }
1145 }
1146 
1147 - (NSRect)getInputMethodCandidatePosRequest:(int)pos
1148 {
1149     NSRect retVal = NSMakeRect(0.0, 0.0, 0.0, 0.0);
1150     if ([NSThread isMainThread] == YES)
1151     {
1152         // TODO: For some reason result is not always converted to the screen coordinates,
1153         // and when we call this method before we set text to updated we get the
1154         // IndexOutOfBoundsException
1155         // In this case we return an empty rectangle so suggestion window is shown at the
1156         // bottom left corner of the main screen.
1157         GET_MAIN_JENV;
1158         jdoubleArray theArray =
1159             (jdoubleArray) (*env)-&gt;CallObjectMethod(env,
1160                                                     self-&gt;jView,
1161                                                     jViewNotifyInputMethodCandidatePosRequest,
1162                                                     pos);
1163         GLASS_CHECK_EXCEPTION(env);
1164         if (theArray != NULL) {
1165             jint n = (*env)-&gt;GetArrayLength(env, theArray);
1166             if (n == 2) {
1167                 jboolean isCopy;
1168                 jdouble *elems = (*env)-&gt;GetDoubleArrayElements(env, theArray, &amp;isCopy);
1169                 retVal = NSMakeRect((CGFloat)elems[0], (CGFloat)elems[1], 0, 0);
1170                 (*env)-&gt;ReleaseDoubleArrayElements(env, theArray, elems, 0);
1171                 (*env)-&gt;DeleteLocalRef(env, theArray);
1172             }
1173         }
1174         GLASS_CHECK_EXCEPTION(env);
1175     }
1176     return retVal;
1177 }
1178 
1179 - (void)sendJavaFullScreenEvent:(BOOL)entered withNativeWidget:(BOOL)isNative
1180 {
1181     if (isNative) {
1182         // Must be done before sending the event to Java since the event handler
1183         // may re-request the operation.
1184         if (entered) {
1185             self-&gt;nativeFullScreenModeWindow = [[self-&gt;nsView window] retain];
1186         } else {
1187             [self-&gt;nativeFullScreenModeWindow release];
1188             self-&gt;nativeFullScreenModeWindow = nil;
1189         }
1190     }
1191 
1192     GET_MAIN_JENV;
1193     (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyEvent,
1194             entered ? com_sun_glass_events_ViewEvent_FULLSCREEN_ENTER : com_sun_glass_events_ViewEvent_FULLSCREEN_EXIT);
1195     GLASS_CHECK_EXCEPTION(env);
1196 }
1197 
1198 - (void)setResizableForFullscreen:(BOOL)resizable
1199 {
1200     NSWindow* window =  [self-&gt;nsView window];
1201     if ([window isKindOfClass:[GlassEmbeddedWindow class]] == NO
1202         &amp;&amp; !((GlassWindow*) window)-&gt;isResizable) {
1203         NSUInteger mask = [window styleMask];
1204         if (resizable) {
1205             mask |= NSResizableWindowMask;
1206         } else {
1207             mask &amp;= ~(NSUInteger)NSResizableWindowMask;
1208         }
1209         [window setStyleMask: mask];
1210     }
1211 }
1212 
1213 /*
1214  The hierarchy for our view is view -&gt; superview (host) -&gt; window
1215 
1216  1. create superview (new host) for our view
1217  2. create fullscreen window with the new superview
1218  3. create the background window (for fading out the desktop)
1219  4. remove our view from the window superview and insert it into the fullscreen window superview
1220  5. show our fullscreen window (and hide the original window)
1221  6. attach to it our background window (which will show it as well)
1222  7. zoom out our fullscreen window and at the same time animate the background window transparency
1223  8. enter fullscreen
1224  */
1225 - (void)enterFullscreenWithAnimate:(BOOL)animate withKeepRatio:(BOOL)keepRatio withHideCursor:(BOOL)hideCursor
1226 {
1227     LOG(&quot;GlassViewDelegate enterFullscreenWithAnimate:%d withKeepRatio:%d withHideCursor:%d&quot;, animate, keepRatio, hideCursor);
1228 
1229     if ([[self-&gt;nsView window] isKindOfClass:[GlassEmbeddedWindow class]] == NO)
1230     {
1231         [[self-&gt;nsView window] toggleFullScreen:self];
1232         // wait until the operation is complete
1233         [GlassApplication enterFullScreenExitingLoop];
1234         return;
1235     }
1236 
1237     NSScreen *screen = [[self-&gt;nsView window] screen];
1238 
1239     NSRect frameInWindowScreenCoords = [self-&gt;nsView bounds];
1240     frameInWindowScreenCoords = [self-&gt;parentWindow convertRectToScreen:frameInWindowScreenCoords];
1241     NSPoint pointInPrimaryScreenCoords = frameInWindowScreenCoords.origin;
1242 
1243     // Convert to local screen
1244     frameInWindowScreenCoords.origin.x -= screen.frame.origin.x;
1245     frameInWindowScreenCoords.origin.y -= screen.frame.origin.y;
1246 
1247     @try
1248     {
1249         // 0. Retain the view while it&#39;s in the FS mode
1250         [self-&gt;nsView retain];
1251 
1252         // 1.
1253         self-&gt;fullscreenHost = [[GlassHostView alloc] initWithFrame:[self-&gt;nsView bounds]];
1254         [self-&gt;fullscreenHost setAutoresizesSubviews:YES];
1255 
1256         // 2.
1257         self-&gt;fullscreenWindow = [[GlassFullscreenWindow alloc] initWithContentRect:frameInWindowScreenCoords
1258                                                                        withHostView:self-&gt;fullscreenHost
1259                                                                            withView:self-&gt;nsView withScreen:screen
1260                                                                           withPoint:pointInPrimaryScreenCoords];
1261 
1262         // 3.
1263 
1264         [self-&gt;parentWindow disableFlushWindow];
1265         {
1266             // handle plugin case
1267             if ([[self-&gt;nsView window] isKindOfClass:[GlassEmbeddedWindow class]] == YES)
1268             {
1269                 GlassEmbeddedWindow *window = (GlassEmbeddedWindow*)self-&gt;parentWindow;
1270                 [window setFullscreenWindow:self-&gt;fullscreenWindow];
1271             }
1272 
1273             // 4.
1274             [self-&gt;nsView retain];
1275             {
1276                 [self-&gt;nsView removeFromSuperviewWithoutNeedingDisplay];
1277                 [self-&gt;fullscreenHost addSubview:self-&gt;nsView];
1278             }
1279             [self-&gt;nsView release];
1280 
1281             if ([[self-&gt;parentWindow delegate] isKindOfClass:[GlassWindow class]] == YES)
1282             {
1283                 GlassWindow *window = (GlassWindow*)[self-&gt;parentWindow delegate];
1284                 [window setFullscreenWindow:self-&gt;fullscreenWindow];
1285             }
1286 
1287             // 5.
1288             [self-&gt;fullscreenWindow setInitialFirstResponder:self-&gt;nsView];
1289             [self-&gt;fullscreenWindow makeFirstResponder:self-&gt;nsView];
1290 
1291             // This trick allows an applet to display a focused window. This is harmless otherwise.
1292             // If we don&#39;t do this, we end up with a literally empty full screen background and no content shown whatsoever.
1293             [[NSRunningApplication currentApplication] activateWithOptions:(NSApplicationActivateIgnoringOtherApps | NSApplicationActivateAllWindows)];
1294 
1295             [self-&gt;fullscreenWindow makeKeyAndOrderFront:self-&gt;nsView];
1296             [self-&gt;fullscreenWindow orderFrontRegardless];
1297             [self-&gt;fullscreenWindow makeMainWindow];
1298         }
1299 
1300         // 6.
1301 
1302         NSRect screenFrame = [screen frame];
1303         NSRect fullscreenFrame = [screen frame];
1304         if (keepRatio == YES)
1305         {
1306             CGFloat ratioWidth = (frameInWindowScreenCoords.size.width/screenFrame.size.width);
1307             CGFloat ratioHeight = (frameInWindowScreenCoords.size.height/screenFrame.size.height);
1308             if (ratioWidth &gt; ratioHeight)
1309             {
1310                 CGFloat ratio = (frameInWindowScreenCoords.size.width/frameInWindowScreenCoords.size.height);
1311                 fullscreenFrame.size.height = fullscreenFrame.size.width / ratio;
1312                 fullscreenFrame.origin.y += (screenFrame.size.height - fullscreenFrame.size.height) / 2.0f;
1313             }
1314             else
1315             {
1316                 CGFloat ratio = (frameInWindowScreenCoords.size.height/frameInWindowScreenCoords.size.width);
1317                 fullscreenFrame.size.width = fullscreenFrame.size.height / ratio;
1318                 fullscreenFrame.origin.x += (screenFrame.size.width - fullscreenFrame.size.width) / 2.0f;
1319             }
1320         }
1321 
1322         // 7.
1323         //[self-&gt;fullscreenWindow setBackgroundColor:[NSColor whiteColor]]; // debug
1324         [self-&gt;fullscreenWindow setFrame:frameInWindowScreenCoords display:YES animate:animate];
1325 
1326         // 8.
1327         [self-&gt;fullscreenWindow toggleFullScreen:self-&gt;fullscreenWindow];
1328     }
1329     @catch (NSException *e)
1330     {
1331         NSLog(@&quot;enterFullscreenWithAnimate caught exception: %@&quot;, e);
1332     }
1333 
1334     [self sendJavaFullScreenEvent:YES withNativeWidget:NO];
1335 }
1336 
1337 - (void)exitFullscreenWithAnimate:(BOOL)animate
1338 {
1339     LOG(&quot;GlassViewDelegate exitFullscreenWithAnimate&quot;);
1340 
1341     @try
1342     {
1343         if (self-&gt;nativeFullScreenModeWindow)
1344         {
1345             [self-&gt;nativeFullScreenModeWindow performSelector:@selector(toggleFullScreen:) withObject:nil];
1346             // wait until the operation is complete
1347             [GlassApplication enterFullScreenExitingLoop];
1348             return;
1349         }
1350 
1351         [self-&gt;fullscreenWindow toggleFullScreen:self-&gt;fullscreenWindow];
1352 
1353         NSRect frame = [self-&gt;parentHost bounds];
1354         frame.origin = [self-&gt;fullscreenWindow point];
1355         [self-&gt;fullscreenWindow setFrame:frame display:YES animate:animate];
1356 
1357         [self-&gt;fullscreenWindow disableFlushWindow];
1358         {
1359             [self-&gt;nsView retain];
1360             {
1361                 [self-&gt;nsView removeFromSuperviewWithoutNeedingDisplay];
1362                 [self-&gt;parentHost addSubview:self-&gt;nsView];
1363             }
1364             [self-&gt;nsView release];
1365 
1366             // handle plugin case
1367             if ([[self-&gt;nsView window] isKindOfClass:[GlassEmbeddedWindow class]] == YES)
1368             {
1369                 GlassEmbeddedWindow *window = (GlassEmbeddedWindow*)[self-&gt;nsView window];
1370                 [window setFullscreenWindow:nil];
1371             }
1372 
1373             [self-&gt;parentWindow setInitialFirstResponder:self-&gt;nsView];
1374             [self-&gt;parentWindow makeFirstResponder:self-&gt;nsView];
1375 
1376             if ([[self-&gt;parentWindow delegate] isKindOfClass:[GlassWindow class]])
1377             {
1378                 GlassWindow *window = (GlassWindow*)[self-&gt;parentWindow delegate];
1379                 [window setFullscreenWindow: nil];
1380             }
1381         }
1382         [self-&gt;fullscreenWindow enableFlushWindow];
1383         [self-&gt;parentWindow enableFlushWindow];
1384 
1385         [self-&gt;fullscreenWindow orderOut:nil];
1386         [self-&gt;fullscreenWindow close];
1387         self-&gt;fullscreenWindow = nil;
1388 
1389         // It was retained upon entering the FS mode
1390         [self-&gt;nsView release];
1391     }
1392     @catch (NSException *e)
1393     {
1394         NSLog(@&quot;exitFullscreenWithAnimate caught exception: %@&quot;, e);
1395     }
1396 
1397     [self sendJavaFullScreenEvent:NO withNativeWidget:NO];
1398 }
1399 
1400 - (GlassAccessible*)getAccessible
1401 {
1402     GET_MAIN_JENV;
1403     jlong accessible = (*env)-&gt;CallLongMethod(env, self-&gt;jView, jViewGetAccessible);
1404     GLASS_CHECK_EXCEPTION(env);
1405     return (GlassAccessible*)jlong_to_ptr(accessible);
1406 }
1407 
1408 @end
    </pre>
  </body>
</html>
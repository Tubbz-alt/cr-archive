<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/native-glass/mac/GlassViewDelegate.m</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #import &quot;common.h&quot;
  27 #import &quot;com_sun_glass_events_ViewEvent.h&quot;
  28 #import &quot;com_sun_glass_events_MouseEvent.h&quot;
  29 #import &quot;com_sun_glass_events_KeyEvent.h&quot;
  30 #import &quot;com_sun_glass_events_DndEvent.h&quot;
  31 #import &quot;com_sun_glass_events_SwipeGesture.h&quot;
  32 #import &quot;com_sun_glass_ui_Clipboard.h&quot;
  33 #import &quot;com_sun_glass_ui_mac_MacGestureSupport.h&quot;
  34 
  35 #import &quot;GlassMacros.h&quot;
  36 #import &quot;GlassViewDelegate.h&quot;
  37 #import &quot;GlassKey.h&quot;
  38 #import &quot;GlassScreen.h&quot;
  39 #import &quot;GlassWindow.h&quot;
  40 #import &quot;GlassApplication.h&quot;
  41 #import &quot;GlassLayer3D.h&quot;
  42 #import &quot;GlassNSEvent.h&quot;
  43 #import &quot;GlassPasteboard.h&quot;
  44 #import &quot;GlassHelper.h&quot;
  45 #import &quot;GlassStatics.h&quot;
  46 #import &quot;GlassPasteboard.h&quot;
  47 #import &quot;GlassTouches.h&quot;
  48 
  49 //#define VERBOSE
  50 #ifndef VERBOSE
  51     #define LOG(MSG, ...)
  52 #else
  53     #define LOG(MSG, ...) GLASS_LOG(MSG, ## __VA_ARGS__);
  54 #endif
  55 
  56 //#define DNDVERBOSE
  57 #ifndef DNDVERBOSE
  58     #define DNDLOG(MSG, ...)
  59 #else
  60     #define DNDLOG(MSG, ...) GLASS_LOG(MSG, ## __VA_ARGS__);
  61 #endif
  62 
  63 // used Safari as a reference while dragging large images
  64 #define MAX_DRAG_SIZE 400
  65 
  66 // explicitly set image size
  67 #define DEFAULT_DRAG_SIZE 64
  68 
  69 // Tracks pressed modifier keys
  70 static NSUInteger s_modifierFlags = 0;
  71 
<a name="2" id="anc2"></a>




  72 // Extracted from class-dump utility output for NSEvent class
  73 @interface NSEvent (hidden)
  74 
  75 - (long long)_scrollPhase;
  76 - (unsigned long long)momentumPhase;
  77 @end
  78 
  79 
  80 static jboolean isInertialScroll(NSEvent *theEvent)
  81 {
  82     enum
  83     {
  84         SelectorNotSet,
  85         MomentumPhaseSelector,
  86         ScrollPhaseSelector,
  87         SelectorNotAvailable
  88     };
  89 
  90     static int selector = SelectorNotSet;
  91 
  92     switch (selector)
  93     {
  94         case SelectorNotSet:
  95             if ([theEvent respondsToSelector:@selector(momentumPhase)])
  96             {   // Available from OS X 10.7
  97                 selector = MomentumPhaseSelector;
  98             }
  99             else if ([theEvent respondsToSelector:@selector(_scrollPhase)])
 100             {   // Available in OS X 10.6 and earlier. Deprecated in OS X 10.7
 101                 selector = ScrollPhaseSelector;
 102             }
 103             else
 104             {
 105                 selector = SelectorNotAvailable;
 106             }
 107             return isInertialScroll(theEvent);
 108 
 109         case MomentumPhaseSelector:
 110             return ([theEvent momentumPhase] != 0);
 111 
 112         case ScrollPhaseSelector:
 113             return ([theEvent _scrollPhase] != 0);
 114     }
 115 
 116     return JNI_FALSE;
 117 }
 118 
 119 
 120 static jint getSwipeDirFromEvent(NSEvent *theEvent)
 121 {
 122     if ([theEvent deltaX] &lt; 0) {
 123         return com_sun_glass_events_SwipeGesture_DIR_RIGHT;
 124     }
 125     if ([theEvent deltaX] &gt; 0) {
 126         return com_sun_glass_events_SwipeGesture_DIR_LEFT;
 127     }
 128     if ([theEvent deltaY] &gt; 0) {
 129         return com_sun_glass_events_SwipeGesture_DIR_UP;
 130     }
 131     if ([theEvent deltaY] &lt; 0) {
 132         return com_sun_glass_events_SwipeGesture_DIR_DOWN;
 133     }
 134     return 0;
 135 }
 136 
 137 
 138 @implementation GlassViewDelegate
 139 
 140 - (id)initWithView:(NSView*)view withJview:(jobject)jview
 141 {
 142     self = [super init];
 143     if (self != nil)
 144     {
 145         GET_MAIN_JENV;
 146 
 147         self-&gt;nsView = view;
 148         self-&gt;jView = (*env)-&gt;NewGlobalRef(env, jview);
 149         self-&gt;mouseIsOver = NO;
 150         self-&gt;mouseDownMask = 0;
 151 
 152         self-&gt;gestureInProgress = NO;
<a name="3" id="anc3"></a>
 153 
 154         self-&gt;nativeFullScreenModeWindow = nil;
 155 
 156         // optimization
 157         [self-&gt;nsView allocateGState];
 158 
 159                 // register for drag and drop
 160                 [self-&gt;nsView registerForDraggedTypes:[NSArray arrayWithObjects:        NSPasteboardTypeString,
 161                                                                                 NSPasteboardTypeTIFF,
 162                                                                                    NSPasteboardTypeRTF,
 163                                                                                    NSPasteboardTypeTabularText,
 164                                                                                    NSPasteboardTypeFont,
 165                                                                                    NSPasteboardTypeRuler,
 166                                                                                    NSPasteboardTypeColor,
 167                                                                                    NSPasteboardTypeRTFD,
 168                                                                                    NSPasteboardTypeHTML,
 169                                                                                    NSPasteboardTypePDF,
 170                                                                                    NSPasteboardTypeMultipleTextSelection,
 171                                                                                    (NSString*)kUTTypeURL,
 172                                                                                    (NSString*)kUTTypeFileURL,
 173                                                                                    (NSString*)@&quot;public.mime-type&quot;,
 174                                                                             nil]];
 175     }
 176     return self;
 177 }
 178 
 179 - (void)dealloc
 180 {
 181     [self-&gt;lastEvent release];
 182     self-&gt;lastEvent = nil;
 183 
 184     [self-&gt;parentHost release];
 185     self-&gt;parentHost = nil;
 186 
 187     [self-&gt;parentWindow release];
 188     self-&gt;parentWindow = nil;
 189 
 190     [self-&gt;fullscreenWindow release];
 191     self-&gt;fullscreenWindow = nil;
 192 
 193     [self-&gt;nativeFullScreenModeWindow release];
 194     self-&gt;nativeFullScreenModeWindow = nil;
 195 
 196     [GlassTouches stopTracking:self];
 197 
 198     GET_MAIN_JENV;
 199     if (env != NULL)
 200     {
 201         (*env)-&gt;DeleteGlobalRef(env, self-&gt;jView);
 202     }
 203     self-&gt;jView = NULL;
 204 
 205     [super dealloc];
 206 }
 207 
 208 - (jobject)jView
 209 {
 210     return self-&gt;jView;
 211 }
 212 
 213 - (void)viewDidMoveToWindow
 214 {
 215     //        NSLog(@&quot;viewDidMoveToWindow&quot;);
 216     //        NSLog(@&quot;        self: %@&quot;, self);
 217     //        NSLog(@&quot;        [self superview]: %@&quot;, [self superview]);
 218     GET_MAIN_JENV;
 219     if ([self-&gt;nsView window] != nil)
 220     {
 221         if (self-&gt;parentHost == nil)
 222         {
 223             self-&gt;parentHost = (GlassHostView*)[[self-&gt;nsView superview] retain];
 224         }
 225         if (self-&gt;parentWindow == nil)
 226         {
 227             self-&gt;parentWindow = [[self-&gt;nsView window] retain];
 228         }
 229 
 230         [[self-&gt;nsView window] setAcceptsMouseMovedEvents:YES];
 231         (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyEvent, com_sun_glass_events_ViewEvent_ADD);
 232     }
 233     else
 234     {
 235         if (self-&gt;parentWindow != nil)
 236         {
 237             [self-&gt;parentWindow release];
 238             self-&gt;parentWindow = nil;
 239         }
 240         (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyEvent, com_sun_glass_events_ViewEvent_REMOVE);
 241     }
 242     GLASS_CHECK_EXCEPTION(env);
 243 }
 244 
 245 - (void)setFrameOrigin:(NSPoint)newOrigin
 246 {
 247 
 248 }
 249 
 250 - (void)setFrameSize:(NSSize)newSize
 251 {
 252     LOG(&quot;GlassViewDelegate setFrameSize %fx%f&quot;, newSize.width, newSize.height);
 253 
 254     //NSLog(@&quot;GlassViewDelegate setFrameSize: %dx%d&quot;, (int)newSize.width, (int)newSize.height);
 255     // TODO: listen for resize view&#39;s notifications
 256     GET_MAIN_JENV;
 257     (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyResize, (int)newSize.width, (int)newSize.height);
 258     GLASS_CHECK_EXCEPTION(env);
 259 
 260     [self-&gt;nsView removeTrackingRect:self-&gt;trackingRect];
 261     self-&gt;trackingRect = [self-&gt;nsView addTrackingRect:[self-&gt;nsView bounds] owner:self-&gt;nsView userData:nil assumeInside:NO];
 262 }
 263 
 264 - (void)setFrame:(NSRect)frameRect
 265 {
 266     LOG(&quot;GlassViewDelegate setFrame %fx%f&quot;, frameRect.size.width, frameRect.size.height);
 267 
 268     //NSLog(@&quot;GlassViewDelegate setFrame: %d,%d %dx%d&quot;, (int)frameRect.origin.x, (int)frameRect.origin.y, (int)frameRect.size.width, (int)frameRect.size.height);
 269     // TODO: listen for resize view&#39;s notifications
 270     GET_MAIN_JENV;
 271     (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyResize, (int)frameRect.size.width, (int)frameRect.size.height);
 272     GLASS_CHECK_EXCEPTION(env);
 273 
 274     [self-&gt;nsView removeTrackingRect:self-&gt;trackingRect];
 275     self-&gt;trackingRect = [self-&gt;nsView addTrackingRect:[self-&gt;nsView bounds] owner:self-&gt;nsView userData:nil assumeInside:NO];
 276 }
 277 
 278 - (void)updateTrackingAreas
 279 {
 280     [self-&gt;nsView removeTrackingRect:self-&gt;trackingRect];
 281     self-&gt;trackingRect = [self-&gt;nsView addTrackingRect:[self-&gt;nsView bounds] owner:self-&gt;nsView userData:nil assumeInside:NO];
 282 }
 283 
 284 - (void)drawRect:(NSRect)dirtyRect
 285 {
 286     //NSLog(@&quot;BEGIN View:drawRect %@: &quot;, self);
 287     //NSLog(@&quot;        [self frame]: %f,%f %fx%f&quot;, [self-&gt;nsView frame].origin.x, [self-&gt;nsView frame].origin.y, [self-&gt;nsView frame].size.width, [self-&gt;nsView frame].size.height);
 288     GET_MAIN_JENV;
 289     jint x = (jint)[self-&gt;nsView frame].origin.x;
 290     jint y = (jint)[self-&gt;nsView frame].origin.y;
 291     jint w = (jint)[self-&gt;nsView frame].size.width;
 292     jint h = (jint)[self-&gt;nsView frame].size.height;
 293     (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyRepaint, x, y, w, h);
 294     GLASS_CHECK_EXCEPTION(env);
 295     //NSLog(@&quot;END drawRect&quot;);
 296 }
 297 
 298 - (void)sendJavaMenuEvent:(NSEvent *)theEvent
 299 {
 300 //    NSLog(@&quot;sendJavaMenuEvent&quot;);
 301     NSWindow * nswindow = [nsView window];
 302     if (nswindow &amp;&amp; [[nswindow delegate] isKindOfClass: [GlassWindow class]]) {
 303         GlassWindow *window = (GlassWindow*)[nswindow delegate];
 304         if (!window-&gt;isEnabled) {
 305             return;
 306         }
 307     }
 308     NSPoint viewPoint = [nsView convertPoint:[theEvent locationInWindow] fromView:nil]; // convert from window coordinates to view coordinates
 309     CGPoint basePoint = CGEventGetLocation([theEvent CGEvent]);
 310 
 311     GET_MAIN_JENV;
 312     jboolean isKeyboardTrigger = JNI_FALSE;
 313     (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyMenu,
 314                             (jint)viewPoint.x, (jint)viewPoint.y, (jint)basePoint.x, (jint)basePoint.y, isKeyboardTrigger);
 315     GLASS_CHECK_EXCEPTION(env);
 316 }
 317 
 318 - (void)sendJavaMouseEvent:(NSEvent *)theEvent
 319 {
 320     NSWindow * nswindow = [nsView window];
 321     if (nswindow &amp;&amp; [[nswindow delegate] isKindOfClass: [GlassWindow class]]) {
 322         GlassWindow *window = (GlassWindow*)[nswindow delegate];
 323         if (!window-&gt;isEnabled) {
 324             return;
 325         }
 326     }
 327 
 328     int type = 0;
 329     int button = com_sun_glass_events_MouseEvent_BUTTON_NONE;
 330     switch ([theEvent type])
 331     {
 332         case NSLeftMouseDown:
 333             type = com_sun_glass_events_MouseEvent_DOWN;
 334             button = com_sun_glass_events_MouseEvent_BUTTON_LEFT;
 335             break;
 336         case NSRightMouseDown:
 337             type = com_sun_glass_events_MouseEvent_DOWN;
 338             button = com_sun_glass_events_MouseEvent_BUTTON_RIGHT;
 339             break;
 340         case NSOtherMouseDown:
 341             type = com_sun_glass_events_MouseEvent_DOWN;
 342             switch ([theEvent buttonNumber]) {
 343                 case 2:
 344                     button = com_sun_glass_events_MouseEvent_BUTTON_OTHER;
 345                     break;
 346                 case 3:
 347                     button = com_sun_glass_events_MouseEvent_BUTTON_BACK;
 348                     break;
 349                 case 4:
 350                     button = com_sun_glass_events_MouseEvent_BUTTON_FORWARD;
 351                     break;
 352             }
 353             break;
 354 
 355         case NSLeftMouseUp:
 356             type = com_sun_glass_events_MouseEvent_UP;
 357             button = com_sun_glass_events_MouseEvent_BUTTON_LEFT;
 358             break;
 359         case NSRightMouseUp:
 360             type = com_sun_glass_events_MouseEvent_UP;
 361             button = com_sun_glass_events_MouseEvent_BUTTON_RIGHT;
 362             break;
 363         case NSOtherMouseUp:
 364             type = com_sun_glass_events_MouseEvent_UP;
 365             switch ([theEvent buttonNumber]) {
 366                 case 2:
 367                     button = com_sun_glass_events_MouseEvent_BUTTON_OTHER;
 368                     break;
 369                 case 3:
 370                     button = com_sun_glass_events_MouseEvent_BUTTON_BACK;
 371                     break;
 372                 case 4:
 373                     button = com_sun_glass_events_MouseEvent_BUTTON_FORWARD;
 374                     break;
 375             }
 376             break;
 377 
 378         case NSLeftMouseDragged:
 379             type = com_sun_glass_events_MouseEvent_DRAG;
 380             button = com_sun_glass_events_MouseEvent_BUTTON_LEFT;
 381             break;
 382         case NSRightMouseDragged:
 383             type = com_sun_glass_events_MouseEvent_DRAG;
 384             button = com_sun_glass_events_MouseEvent_BUTTON_RIGHT;
 385             break;
 386         case NSOtherMouseDragged:
 387             type = com_sun_glass_events_MouseEvent_DRAG;
 388             switch ([theEvent buttonNumber]) {
 389                 case 2:
 390                     button = com_sun_glass_events_MouseEvent_BUTTON_OTHER;
 391                     break;
 392                 case 3:
 393                     button = com_sun_glass_events_MouseEvent_BUTTON_BACK;
 394                     break;
 395                 case 4:
 396                     button = com_sun_glass_events_MouseEvent_BUTTON_FORWARD;
 397                     break;
 398             }
 399             break;
 400 
 401         case NSMouseMoved:
 402             type = com_sun_glass_events_MouseEvent_MOVE;
 403             break;
 404 
 405         case NSMouseEntered:
 406             type = com_sun_glass_events_MouseEvent_ENTER;
 407             [GlassTouches startTracking:self];
 408             self-&gt;lastTrackingNumber = [theEvent trackingNumber];
 409             break;
 410 
 411         case NSMouseExited:
 412             type = com_sun_glass_events_MouseEvent_EXIT;
 413             [GlassTouches stopTracking:self];
 414             self-&gt;lastTrackingNumber = [theEvent trackingNumber];
 415             break;
 416 
 417         case NSScrollWheel:
 418             type = com_sun_glass_events_MouseEvent_WHEEL;
 419             break;
 420     }
 421 
 422     NSPoint viewPoint = [nsView convertPoint:[theEvent locationInWindow] fromView:nil]; // convert from window coordinates to view coordinates
 423     CGPoint basePoint = CGEventGetLocation([theEvent CGEvent]);
 424 
 425     if (type == com_sun_glass_events_MouseEvent_MOVE)
 426     {
 427         NSRect frame = [nsView frame];
 428 
 429         if (viewPoint.x &lt; 0 || viewPoint.y &lt; 0 ||
 430                 viewPoint.x &gt;= frame.size.width ||
 431                 viewPoint.y &gt;= frame.size.height)
 432         {
 433             // The MOVE events happening outside of the view must be ignored
 434             return;
 435         }
 436 
 437         // Check if the event is a duplicate
 438         if (self-&gt;lastEvent)
 439         {
 440             CGPoint oldBasePoint = CGEventGetLocation([self-&gt;lastEvent CGEvent]);
 441 
 442             if (basePoint.x == oldBasePoint.x &amp;&amp; basePoint.y == oldBasePoint.y)
 443             {
 444                 return;
 445             }
 446         }
 447     }
 448 
 449         //    NSLog(@&quot;Event location: in window %@, in view %@, in base coordinates %d,%d&quot;,
 450         //          NSStringFromPoint([theEvent locationInWindow]),
 451         //          NSStringFromPoint(viewPoint),
 452         //          (jint)basePoint.x, (jint)basePoint.y);
 453 
 454     jdouble rotationX = 0.0;
 455     jdouble rotationY = 0.0;
 456     if (type == com_sun_glass_events_MouseEvent_WHEEL)
 457     {
 458         if ([theEvent hasPreciseScrollingDeltas])
 459         {
 460             rotationX = (jdouble)[theEvent scrollingDeltaX] * 0.1;
 461             rotationY = (jdouble)[theEvent scrollingDeltaY] * 0.1;
 462         }
 463         else
 464         {
 465             rotationX = (jdouble)[theEvent deltaX];
 466             rotationY = (jdouble)[theEvent deltaY];
 467         }
 468         
 469         //XXX: check for equality for doubles???
 470         if (rotationX == 0.0 &amp;&amp; rotationY == 0.0)
 471         {
 472             return;
 473         }
 474     }
 475 
 476     BOOL block = NO;
 477     {
 478         // RT-5892
 479         if ((type == com_sun_glass_events_MouseEvent_ENTER) || (type == com_sun_glass_events_MouseEvent_EXIT))
 480         {
 481             // userData indicates if this is a synthesized EXIT event that MUST pass through
 482             // Note: userData is only valid for ENTER/EXIT events!
 483             if (self-&gt;mouseIsDown == YES &amp;&amp; [theEvent userData] != self)
 484             {
 485                 block = [self suppressMouseEnterExitOnMouseDown];
 486             }
 487         }
 488         else
 489         {
 490             // for the mouse supression we can not look at the mouse down state during ENTER/EXIT events
 491             // as they always report mouse up regardless of the actual state, so we need to store it
 492             // based on the events other than ENTER/EXIT
 493             self-&gt;mouseIsDown = (button != com_sun_glass_events_MouseEvent_BUTTON_NONE);
 494         }
 495     }
 496     if (block == NO)
 497     {
 498         if (!self-&gt;mouseIsOver &amp;&amp;
 499                 type != com_sun_glass_events_MouseEvent_ENTER &amp;&amp;
 500                 type != com_sun_glass_events_MouseEvent_EXIT)
 501         {
 502             // OS X didn&#39;t send mouseEnter. Synthesize it here.
 503             NSEvent *eeEvent = [NSEvent enterExitEventWithType:NSMouseEntered
 504                                                       location:[theEvent locationInWindow]
 505                                                  modifierFlags:[theEvent modifierFlags]
 506                                                      timestamp:[theEvent timestamp]
 507                                                   windowNumber:[theEvent windowNumber]
 508                                                        context:[theEvent context]
 509                                                    eventNumber:0
 510                                                 trackingNumber:self-&gt;lastTrackingNumber
 511                                                       userData:self];
 512             [self sendJavaMouseEvent:eeEvent];
 513         }
 514 
 515         jint modifiers = GetJavaKeyModifiers(theEvent);
 516         if (type != com_sun_glass_events_MouseEvent_ENTER &amp;&amp;
 517             type != com_sun_glass_events_MouseEvent_EXIT) {
 518             modifiers |= GetJavaMouseModifiers([NSEvent pressedMouseButtons]);
 519             if (type != com_sun_glass_events_MouseEvent_UP)
 520             {
 521                 switch (button)
 522                 {
 523                     case com_sun_glass_events_MouseEvent_BUTTON_LEFT:
 524                         modifiers |= com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_PRIMARY;
 525                         break;
 526                     case com_sun_glass_events_MouseEvent_BUTTON_RIGHT:
 527                         modifiers |= com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_SECONDARY;
 528                         break;
 529                     case com_sun_glass_events_MouseEvent_BUTTON_OTHER:
 530                         modifiers |= com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_MIDDLE;
 531                         break;
 532                     case com_sun_glass_events_MouseEvent_BUTTON_BACK:
 533                         modifiers |= com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_BACK;
 534                         break;
 535                     case com_sun_glass_events_MouseEvent_BUTTON_FORWARD:
 536                         modifiers |= com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_FORWARD;
 537                         break;
 538                 }
 539             }
 540         }
 541 
 542         jboolean isSynthesized = JNI_FALSE;
 543 
 544         jboolean isPopupTrigger = JNI_FALSE;
 545         if (type == com_sun_glass_events_MouseEvent_DOWN) {
 546             if (button == com_sun_glass_events_MouseEvent_BUTTON_RIGHT) {
 547                 isPopupTrigger = JNI_TRUE;
 548             }
 549             if (button == com_sun_glass_events_MouseEvent_BUTTON_LEFT &amp;&amp;
 550                 (modifiers &amp; com_sun_glass_events_KeyEvent_MODIFIER_CONTROL))
 551             {
 552                 isPopupTrigger = JNI_TRUE;
 553             }
 554         }
 555 
 556         [self-&gt;lastEvent release];
 557         self-&gt;lastEvent = nil;
 558         switch (type) {
 559             // prepare GlassDragSource for possible drag,
 560             case com_sun_glass_events_MouseEvent_DOWN:
 561                 switch (button) {
 562                     case com_sun_glass_events_MouseEvent_BUTTON_LEFT:    self-&gt;mouseDownMask |= 1 &lt;&lt; 0; break;
 563                     case com_sun_glass_events_MouseEvent_BUTTON_RIGHT:   self-&gt;mouseDownMask |= 1 &lt;&lt; 1; break;
 564                     case com_sun_glass_events_MouseEvent_BUTTON_OTHER:   self-&gt;mouseDownMask |= 1 &lt;&lt; 2; break;
 565                     case com_sun_glass_events_MouseEvent_BUTTON_BACK:    self-&gt;mouseDownMask |= 1 &lt;&lt; 3; break;
 566                     case com_sun_glass_events_MouseEvent_BUTTON_FORWARD: self-&gt;mouseDownMask |= 1 &lt;&lt; 4; break;
 567                 }
 568                 //fall through
 569             case com_sun_glass_events_MouseEvent_DRAG:
 570                 [GlassDragSource setDelegate:self];
 571                 // fall through to save the lastEvent
 572             // or for filtering out duplicate MOVE events
 573             case com_sun_glass_events_MouseEvent_MOVE:
 574                 self-&gt;lastEvent = [theEvent retain];
 575                 break;
 576             case com_sun_glass_events_MouseEvent_UP:
 577                 switch (button) {
 578                     case com_sun_glass_events_MouseEvent_BUTTON_LEFT:    self-&gt;mouseDownMask &amp;= ~(1 &lt;&lt; 0); break;
 579                     case com_sun_glass_events_MouseEvent_BUTTON_RIGHT:   self-&gt;mouseDownMask &amp;= ~(1 &lt;&lt; 1); break;
 580                     case com_sun_glass_events_MouseEvent_BUTTON_OTHER:   self-&gt;mouseDownMask &amp;= ~(1 &lt;&lt; 2); break;
 581                     case com_sun_glass_events_MouseEvent_BUTTON_BACK:    self-&gt;mouseDownMask &amp;= ~(1 &lt;&lt; 3); break;
 582                     case com_sun_glass_events_MouseEvent_BUTTON_FORWARD: self-&gt;mouseDownMask &amp;= ~(1 &lt;&lt; 4); break;
 583                 }
 584                 break;
 585 
 586 
 587 
 588             // Track whether the mouse is over the view
 589             case com_sun_glass_events_MouseEvent_ENTER:
 590                 self-&gt;mouseIsOver = YES;
 591                 break;
 592             case com_sun_glass_events_MouseEvent_EXIT:
 593                 self-&gt;mouseIsOver = NO;
 594                 break;
 595         }
 596 
 597         GET_MAIN_JENV;
 598         if (type == com_sun_glass_events_MouseEvent_WHEEL) {
 599             // Detect mouse wheel event sender.
 600             // Can be inertia from scroll gesture,
 601             // scroll gesture or mouse wheel itself
 602             //
 603             // RT-22388, RT-25269
 604             jint sender = com_sun_glass_ui_mac_MacGestureSupport_SCROLL_SRC_WHEEL;
 605             if (isInertialScroll(theEvent))
 606             {
 607                 sender = com_sun_glass_ui_mac_MacGestureSupport_SCROLL_SRC_INERTIA;
 608             }
 609             else if (self-&gt;gestureInProgress == YES)
 610             {
 611                 sender = com_sun_glass_ui_mac_MacGestureSupport_SCROLL_SRC_GESTURE;
 612             }
 613 
 614             const jclass jGestureSupportClass = [GlassHelper ClassForName:&quot;com.sun.glass.ui.mac.MacGestureSupport&quot;
 615                                                                   withEnv:env];
 616             if (jGestureSupportClass)
 617             {
 618                 (*env)-&gt;CallStaticVoidMethod(env, jGestureSupportClass,
 619                                              javaIDs.GestureSupport.scrollGesturePerformed,
 620                                              self-&gt;jView, modifiers, sender,
 621                                              (jint)viewPoint.x, (jint)viewPoint.y,
 622                                              (jint)basePoint.x, (jint)basePoint.y,
 623                                              rotationX, rotationY);
 624             }
 625         } else {
 626             (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyMouse, type, button,
 627                     (jint)viewPoint.x, (jint)viewPoint.y, (jint)basePoint.x, (jint)basePoint.y,
 628                     modifiers, isPopupTrigger, isSynthesized);
 629         }
 630         GLASS_CHECK_EXCEPTION(env);
 631 
 632         if (isPopupTrigger) {
 633             [self sendJavaMenuEvent:theEvent];
 634         }
 635     }
 636 }
 637 
 638 - (void)resetMouseTracking
 639 {
 640     if (self-&gt;mouseIsOver) {
 641         // Nothing of the parameters really matters for the EXIT event, except userData
 642         NSEvent* theEvent = [NSEvent
 643             enterExitEventWithType:NSMouseExited
 644                           location:[NSEvent mouseLocation]
 645                      modifierFlags:0
 646                          timestamp:[NSDate timeIntervalSinceReferenceDate]
 647                       windowNumber:[[self-&gt;nsView window] windowNumber]
 648                            context:[NSGraphicsContext currentContext]
 649                        eventNumber:0
 650                     trackingNumber:self-&gt;lastTrackingNumber
 651                           userData:self]; // indicates that this is a synthesized event
 652 
 653         [self sendJavaMouseEvent:theEvent];
 654     }
 655 }
 656 
 657 // RT-11707: zero out the keycode for TYPED events
 658 #define SEND_KEY_EVENT(type) \
 659     (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyKey, (type), \
 660             (type) == com_sun_glass_events_KeyEvent_TYPED ? 0 : jKeyCode, \
 661             jKeyChars, jModifiers); \
 662     GLASS_CHECK_EXCEPTION(env);
 663 
 664 - (void)sendJavaKeyEvent:(NSEvent *)theEvent isDown:(BOOL)isDown
 665 {
 666     if (theEvent == s_lastKeyEvent) {
 667         // this must be a keyDown: generated by performKeyEquivalent: which returns NO by design
 668         return;
 669     }
 670     [s_lastKeyEvent release];
 671     s_lastKeyEvent = [theEvent retain];
 672 
 673     GET_MAIN_JENV;
 674 
 675     jint jKeyCode = GetJavaKeyCode(theEvent);
 676     jcharArray jKeyChars = GetJavaKeyChars(env, theEvent);
 677     jint jModifiers = GetJavaModifiers(theEvent);
 678 
 679     // Short circuit here: If this is a synthetic key-typed from a text event
 680     // post it and return.
 681     if ([theEvent isKindOfClass:[GlassNSEvent class]]) {
 682         if ([(GlassNSEvent *)theEvent isSyntheticKeyTyped]) {
 683             SEND_KEY_EVENT(com_sun_glass_events_KeyEvent_TYPED);
 684             (*env)-&gt;DeleteLocalRef(env, jKeyChars);
 685             return;
 686         }
 687     }
 688 
 689     if (!isDown)
 690     {
 691         SEND_KEY_EVENT(com_sun_glass_events_KeyEvent_RELEASE);
 692     }
 693     else
 694     {
 695         SEND_KEY_EVENT(com_sun_glass_events_KeyEvent_PRESS);
 696 
 697         // In the applet case, FireFox always sends a text input event after every
 698         // key-pressed, which gets turned into a TYPED event for simple key strokes.
 699         // The NPAPI support code will send a boolean to let us know if we need to
 700         // generate the TYPED, or if we should expect the input method support to do it.
 701         BOOL sendKeyTyped = YES;
 702 
 703         if ([theEvent isKindOfClass:[GlassNSEvent class]]) {
 704             sendKeyTyped = [(GlassNSEvent *)theEvent needsKeyTyped];
 705         }
 706 
 707         // TYPED events should only be sent for printable characters. Thus we avoid
 708         // sending them for navigation keys. Perhaps this logic could be enhanced.
 709         if (sendKeyTyped) {
 710             if (jKeyCode &lt; com_sun_glass_events_KeyEvent_VK_PAGE_UP ||
 711                 jKeyCode &gt; com_sun_glass_events_KeyEvent_VK_DOWN)
 712             {
 713                 SEND_KEY_EVENT(com_sun_glass_events_KeyEvent_TYPED);
 714             }
 715 
 716             // Quirk in Firefox: If we have to generate a key-typed and this
 717             // event is a repeat we will also need to generate a fake RELEASE event
 718             // because we won&#39;t see a key-release.
 719             if ([theEvent isARepeat] &amp;&amp;
 720                 [[self-&gt;nsView window] isKindOfClass:[GlassEmbeddedWindow class]]) {
 721                 SEND_KEY_EVENT(com_sun_glass_events_KeyEvent_RELEASE);
 722             }
 723         }
 724 
 725         // Mac doesn&#39;t send keyUp for Cmd+&lt;&gt; key combinations (including Shift+Cmd+&lt;&gt;, etc.)
 726         // So we synthesize the event
 727         if (jModifiers &amp; com_sun_glass_events_KeyEvent_MODIFIER_COMMAND)
 728         {
 729             SEND_KEY_EVENT(com_sun_glass_events_KeyEvent_RELEASE);
 730         }
 731     }
 732 
 733     (*env)-&gt;DeleteLocalRef(env, jKeyChars);
 734     GLASS_CHECK_EXCEPTION(env);
 735 }
 736 
 737 #define SEND_MODIFIER_KEY_EVENT_WITH_TYPE(type, vkCode) \
 738         (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyKey, \
 739                 (type), \
 740                 (vkCode), \
 741                 jKeyChars, jModifiers);
 742 
 743 #define SEND_MODIFIER_KEY_EVENT(mask, vkCode) \
 744     if (changedFlags &amp; (mask)) { \
 745         SEND_MODIFIER_KEY_EVENT_WITH_TYPE(currentFlags &amp; (mask) ? com_sun_glass_events_KeyEvent_PRESS : com_sun_glass_events_KeyEvent_RELEASE, vkCode); \
 746         GLASS_CHECK_EXCEPTION(env); \
 747     }
 748 
 749 - (void)sendJavaModifierKeyEvent:(NSEvent *)theEvent
 750 {
 751     NSUInteger currentFlags = [theEvent modifierFlags] &amp; NSDeviceIndependentModifierFlagsMask;
 752     NSUInteger changedFlags = currentFlags ^ s_modifierFlags;
 753 
 754     jint jModifiers = GetJavaModifiers(theEvent);
 755 
 756     GET_MAIN_JENV;
 757     jcharArray jKeyChars = (*env)-&gt;NewCharArray(env, 0);
 758 
 759     SEND_MODIFIER_KEY_EVENT(NSShiftKeyMask,       com_sun_glass_events_KeyEvent_VK_SHIFT);
 760     SEND_MODIFIER_KEY_EVENT(NSControlKeyMask,     com_sun_glass_events_KeyEvent_VK_CONTROL);
 761     SEND_MODIFIER_KEY_EVENT(NSAlternateKeyMask,   com_sun_glass_events_KeyEvent_VK_ALT);
 762     SEND_MODIFIER_KEY_EVENT(NSCommandKeyMask,     com_sun_glass_events_KeyEvent_VK_COMMAND);
 763 
 764     // For CapsLock both PRESS and RELEASE should be synthesized each time
 765     if (changedFlags &amp; NSAlphaShiftKeyMask) {
 766         SEND_MODIFIER_KEY_EVENT_WITH_TYPE(com_sun_glass_events_KeyEvent_PRESS, com_sun_glass_events_KeyEvent_VK_CAPS_LOCK);
 767         SEND_MODIFIER_KEY_EVENT_WITH_TYPE(com_sun_glass_events_KeyEvent_RELEASE, com_sun_glass_events_KeyEvent_VK_CAPS_LOCK);
 768     }
 769 
 770     (*env)-&gt;DeleteLocalRef(env, jKeyChars);
 771     GLASS_CHECK_EXCEPTION(env);
 772 
 773     s_modifierFlags = currentFlags;
 774 }
 775 
 776 - (void)sendJavaGestureEvent:(NSEvent *)theEvent type:(int)type
 777 {
 778     NSPoint viewPoint = [nsView convertPoint:[theEvent locationInWindow] fromView:nil]; // convert from window coordinates to view coordinates
 779     CGPoint basePoint = CGEventGetLocation([theEvent CGEvent]);
 780 
 781     jint modifiers = GetJavaModifiers(theEvent);
 782 
 783     GET_MAIN_JENV;
 784     const jclass jGestureSupportClass = [GlassHelper ClassForName:&quot;com.sun.glass.ui.mac.MacGestureSupport&quot;
 785                                                           withEnv:env];
 786     if (jGestureSupportClass)
 787     {
 788         switch (type)
 789         {
 790             case com_sun_glass_ui_mac_MacGestureSupport_GESTURE_ROTATE:
 791                 (*env)-&gt;CallStaticVoidMethod(env, jGestureSupportClass,
 792                                              javaIDs.GestureSupport.rotateGesturePerformed,
 793                                              self-&gt;jView, modifiers,
 794                                              (jint)viewPoint.x, (jint)viewPoint.y,
 795                                              (jint)basePoint.x, (jint)basePoint.y,
 796                                              (jfloat)[theEvent rotation]);
 797                 break;
 798             case com_sun_glass_ui_mac_MacGestureSupport_GESTURE_SWIPE:
 799                 (*env)-&gt;CallStaticVoidMethod(env, jGestureSupportClass,
 800                                              javaIDs.GestureSupport.swipeGesturePerformed,
 801                                              self-&gt;jView, modifiers,
 802                                              getSwipeDirFromEvent(theEvent),
 803                                              (jint)viewPoint.x, (jint)viewPoint.y,
 804                                              (jint)basePoint.x, (jint)basePoint.y);
 805                 break;
 806             case com_sun_glass_ui_mac_MacGestureSupport_GESTURE_MAGNIFY:
 807                 (*env)-&gt;CallStaticVoidMethod(env, jGestureSupportClass,
 808                                              javaIDs.GestureSupport.magnifyGesturePerformed,
 809                                              self-&gt;jView, modifiers,
 810                                              (jint)viewPoint.x, (jint)viewPoint.y,
 811                                              (jint)basePoint.x, (jint)basePoint.y,
 812                                              (jfloat)[theEvent magnification]);
 813                 break;
 814         }
 815     }
 816     GLASS_CHECK_EXCEPTION(env);
 817 }
 818 
 819 - (void)sendJavaGestureBeginEvent:(NSEvent *)theEvent
 820 {
 821     self-&gt;gestureInProgress = YES;
 822 }
 823 
 824 - (void)sendJavaGestureEndEvent:(NSEvent *)theEvent
 825 {
 826     self-&gt;gestureInProgress = NO;
 827 
 828     NSPoint viewPoint = [nsView convertPoint:[theEvent locationInWindow] fromView:nil]; // convert from window coordinates to view coordinates
 829     CGPoint basePoint = CGEventGetLocation([theEvent CGEvent]);
 830 
 831     jint modifiers = GetJavaModifiers(theEvent);
 832 
 833     GET_MAIN_JENV;
 834     const jclass jGestureSupportClass = [GlassHelper ClassForName:&quot;com.sun.glass.ui.mac.MacGestureSupport&quot;
 835                                                           withEnv:env];
 836     if (jGestureSupportClass)
 837     {
 838         (*env)-&gt;CallStaticVoidMethod(env, jGestureSupportClass,
 839                                      javaIDs.GestureSupport.gestureFinished,
 840                                      self-&gt;jView, modifiers,
 841                                      (jint)viewPoint.x, (jint)viewPoint.y,
 842                                      (jint)basePoint.x, (jint)basePoint.y);
 843 
 844     }
 845     GLASS_CHECK_EXCEPTION(env);
 846 }
 847 
<a name="4" id="anc4"></a>

































































 848 - (NSDragOperation)sendJavaDndEvent:(id &lt;NSDraggingInfo&gt;)info type:(jint)type
 849 {
 850     GET_MAIN_JENV;
 851 
 852     NSPoint draggingLocation = [nsView convertPoint:[info draggingLocation] fromView:nil];
 853     int x = (int)draggingLocation.x;
 854     int y = (int)draggingLocation.y;
 855 
 856     int xAbs = (int)([info draggingLocation].x + [self-&gt;nsView window].frame.origin.x);
 857     int yAbs = (int)([[self-&gt;nsView window] screen].frame.size.height - [self-&gt;nsView window].frame.origin.y
 858                      - [info draggingLocation].y);
 859 
 860     int mask;
 861     NSDragOperation operation = [info draggingSourceOperationMask];
 862 
 863     [GlassDragSource setSupportedActions:[GlassDragSource mapNsOperationToJavaMask:operation]];
 864 
 865     jint recommendedAction = [GlassDragSource getRecommendedActionForMask:operation];
 866     switch (type)
 867     {
 868         case com_sun_glass_events_DndEvent_ENTER:
 869             DNDLOG(&quot;com_sun_glass_events_DndEvent_ENTER&quot;);
 870             copyToDragPasteboardIfNeeded(info);
 871             mask = (*env)-&gt;CallIntMethod(env, self-&gt;jView, jViewNotifyDragEnter, x, y, xAbs, yAbs, recommendedAction);
 872             break;
 873         case com_sun_glass_events_DndEvent_UPDATE:
 874             DNDLOG(&quot;com_sun_glass_events_DndEvent_UPDATE&quot;);
 875             mask = (*env)-&gt;CallIntMethod(env, self-&gt;jView, jViewNotifyDragOver, x, y, xAbs, yAbs, recommendedAction);
 876             break;
 877         case com_sun_glass_events_DndEvent_PERFORM:
 878             DNDLOG(&quot;com_sun_glass_events_DndEvent_PERFORM&quot;);
 879             mask = (*env)-&gt;CallIntMethod(env, self-&gt;jView, jViewNotifyDragDrop, x, y, xAbs, yAbs, recommendedAction);
 880             break;
 881         case com_sun_glass_events_DndEvent_EXIT:
 882             DNDLOG(&quot;com_sun_glass_events_DndEvent_EXIT&quot;);
 883             (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyDragLeave);
 884             mask = com_sun_glass_ui_Clipboard_ACTION_NONE;
 885             break;
 886         default:
 887             mask = com_sun_glass_ui_Clipboard_ACTION_NONE;
 888             break;
 889     }
 890     [GlassDragSource setMask:mask];
 891 
 892     GLASS_CHECK_EXCEPTION(env);
 893 
 894     return [GlassDragSource mapJavaMaskToNsOperation:[GlassDragSource getMask]];
 895 }
 896 
 897 - (NSDragOperation)draggingSourceOperationMaskForLocal:(BOOL)isLocal
 898 {
 899     return self-&gt;dragOperation;
 900 }
 901 
 902 // called from Java layer drag handler, triggered by DnD Pasteboard flush
 903 - (void)startDrag:(NSDragOperation)operation
 904 {
 905     DNDLOG(&quot;startDrag&quot;);
 906     self-&gt;dragOperation = operation;
 907     {
 908         NSPoint dragPoint = [self-&gt;nsView convertPoint:[self-&gt;lastEvent locationInWindow] fromView:nil];
 909         NSPasteboard *pasteboard = [NSPasteboard pasteboardWithName:NSDragPboard];
 910         NSImage *image = nil;
 911 
 912         if ([[pasteboard types] containsObject:DRAG_IMAGE_MIME]) {
 913             //Try to init with drag image specified by the user
 914             image = [[NSImage alloc] initWithData:[pasteboard dataForType:DRAG_IMAGE_MIME]];
 915         }
 916 
 917         if (image == nil &amp;&amp; [NSImage canInitWithPasteboard:pasteboard] == YES)
 918         {
 919             // ask the Pasteboard for ist own image representation of its contents
 920             image = [[NSImage alloc] initWithPasteboard:pasteboard];
 921         }
 922 
 923         if (image != nil)
 924         {
 925             // check the drag image size and scale it down as needed using Safari behavior (sizes) as reference
 926             CGFloat width = [image size].width;
 927             CGFloat height = [image size].height;
 928             if ((width &gt; MAX_DRAG_SIZE) || (height &gt; MAX_DRAG_SIZE))
 929             {
 930                 if (width &gt;= height)
 931                 {
 932                     CGFloat ratio = height/width;
 933                     width = MIN(width, MAX_DRAG_SIZE);
 934                     height = ratio * width;
 935                     [image setSize:NSMakeSize(width, height)];
 936                 }
 937                 else
 938                 {
 939                     CGFloat ratio = width/height;
 940                     height = MIN(height, MAX_DRAG_SIZE);
 941                     width = ratio * height;
 942                     [image setSize:NSMakeSize(width, height)];
 943                 }
 944             }
 945         } else {
 946             NSArray *items = [pasteboard pasteboardItems];
 947             if ([items count] == 1)
 948             {
 949                 image = [[NSImage alloc] initWithContentsOfFile:@&quot;/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/GenericDocumentIcon.icns&quot;];
 950             }
 951 
 952             if (image == nil)
 953             {
 954                 image = [[NSImage imageNamed:NSImageNameMultipleDocuments] retain];
 955             }
 956 
 957             [image setSize:NSMakeSize(DEFAULT_DRAG_SIZE, DEFAULT_DRAG_SIZE)];
 958         }
 959 
 960         if (image != nil)
 961         {
 962             // select the center of the image as the drag origin
 963             // TODO http://javafx-jira.kenai.com/browse/RT-17629
 964             // would be nice to get this info from the Java layer,
 965             // so that we could adjust the drag image origin based on where in the src it was clicked on
 966             dragPoint.x -= ([image size].width/2.0f);
 967             dragPoint.y += ([image size].height/2.0f);
 968 
 969             NSString *offsetString = [pasteboard stringForType:DRAG_IMAGE_OFFSET];
 970             if (offsetString != nil) {
 971                 NSPoint offset = NSPointFromString(offsetString);
 972                 //Adjust offset to the image size
 973                 float imageHalfX = [image size].width/2.0f;
 974                 float imageHalfY = [image size].height/2.0f;
 975 
 976                 if (offset.x &gt; imageHalfX || offset.x &lt; -imageHalfX) {
 977                     offset.x = imageHalfX * (offset.x &gt; 0 ? 1 : -1);
 978                 }
 979                 if (offset.y &gt; imageHalfY || offset.y &lt; -imageHalfY) {
 980                     offset.y = imageHalfY * (offset.y &gt; 0 ? 1 : -1);
 981                 }
 982 
 983                 dragPoint.x += offset.x;
 984                 dragPoint.y -= offset.y;
 985             }
 986         }
 987         else
 988         {
 989             // last resource: &quot;empty&quot; image
 990             image = [[NSImage alloc] initWithSize:NSMakeSize(1.0f, 1.0f)];
 991         }
 992         [self-&gt;nsView dragImage:image at:dragPoint offset:NSZeroSize event:self-&gt;lastEvent pasteboard:pasteboard source:self-&gt;nsView slideBack:YES];
 993 
 994         // main thread blocked here until drag completes
 995 
 996         [GlassDragSource setDelegate:nil];
 997 
 998         [image release];
 999     }
1000     self-&gt;dragOperation = NSDragOperationNone;
1001 }
1002 
1003 - (void)synthesizeMouseUp:(NSEventType)type
1004 {
1005     NSEvent* theEvent = [NSEvent
1006         mouseEventWithType:type
1007                   location:[NSEvent mouseLocation]
1008              modifierFlags:0
1009                  timestamp:[NSDate timeIntervalSinceReferenceDate]
1010               windowNumber:[[self-&gt;nsView window] windowNumber]
1011                    context:[NSGraphicsContext currentContext]
1012                eventNumber:0
1013                 clickCount:0
1014                   pressure:0.0];
1015 
1016     [self sendJavaMouseEvent:theEvent];
1017 }
1018 
1019 - (void)draggingEnded
1020 {
1021     GET_MAIN_JENV;
1022     (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyDragEnd,  [GlassDragSource getMask]);
1023     GLASS_CHECK_EXCEPTION(env);
1024 
1025     // RT-36038: OS X won&#39;t send mouseUp after DnD is complete, so we synthesize them
1026     if (self-&gt;mouseDownMask &amp; 1 &lt;&lt; 0) [self synthesizeMouseUp:NSLeftMouseUp];
1027     if (self-&gt;mouseDownMask &amp; 1 &lt;&lt; 1) [self synthesizeMouseUp:NSRightMouseUp];
1028     if (self-&gt;mouseDownMask &amp; 1 &lt;&lt; 2) [self synthesizeMouseUp:NSOtherMouseUp];
1029 }
1030 
1031 - (BOOL)suppressMouseEnterExitOnMouseDown
1032 {
1033     return YES;
1034 }
1035 
1036 static jstring convertNSStringToJString(id aString, int length)
1037 {
1038     GET_MAIN_JENV;
1039 
1040     jstring jStr;
1041     if ([aString isKindOfClass:[NSAttributedString class]]) {
1042         NSData *data = [[aString string] dataUsingEncoding:NSUTF16LittleEndianStringEncoding];
1043         jchar *dataBytes = (jchar *)malloc(sizeof(jchar) * length);
1044         if (dataBytes != NULL) {
1045             [data getBytes:dataBytes length:length * 2];
1046             jStr = (*env)-&gt;NewString(env, dataBytes, length);
1047             free(dataBytes);
1048         }
1049     } else {
1050         jStr = (*env)-&gt;NewStringUTF(env, [aString UTF8String]);
1051     }
1052 
1053     GLASS_CHECK_EXCEPTION(env);
1054 
1055     return jStr;
1056 }
1057 
1058 - (void)notifyInputMethod:(id) aString attr:(int)attr length:(int)length cursor:(int)cursor
1059             selectedRange:(NSRange)selectionRange
1060 {
1061     if ([NSThread isMainThread] == YES)
1062     {
1063         GET_MAIN_JENV;
1064         
1065         jstring jStr = convertNSStringToJString(aString, length);
1066         if (jStr != NULL) {
1067             (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyInputMethodMac, jStr, attr,
1068                                    length, cursor, selectionRange.location,
1069                                    selectionRange.length);
1070         }
1071         GLASS_CHECK_EXCEPTION(env);
1072     }
1073 }
1074 
1075 - (NSRect)getInputMethodCandidatePosRequest:(int)pos
1076 {
1077     NSRect retVal = NSMakeRect(0.0, 0.0, 0.0, 0.0);
1078     if ([NSThread isMainThread] == YES)
1079     {
1080         // TODO: For some reason result is not always converted to the screen coordinates,
1081         // and when we call this method before we set text to updated we get the
1082         // IndexOutOfBoundsException
1083         // In this case we return an empty rectangle so suggestion window is shown at the
1084         // bottom left corner of the main screen.
1085         GET_MAIN_JENV;
1086         jdoubleArray theArray =
1087             (jdoubleArray) (*env)-&gt;CallObjectMethod(env,
1088                                                     self-&gt;jView,
1089                                                     jViewNotifyInputMethodCandidatePosRequest,
1090                                                     pos);
1091         GLASS_CHECK_EXCEPTION(env);
1092         if (theArray != NULL) {
1093             jint n = (*env)-&gt;GetArrayLength(env, theArray);
1094             if (n == 2) {
1095                 jboolean isCopy;
1096                 jdouble *elems = (*env)-&gt;GetDoubleArrayElements(env, theArray, &amp;isCopy);
1097                 retVal = NSMakeRect((CGFloat)elems[0], (CGFloat)elems[1], 0, 0);
1098                 (*env)-&gt;ReleaseDoubleArrayElements(env, theArray, elems, 0);
1099                 (*env)-&gt;DeleteLocalRef(env, theArray);
1100             }
1101         }
1102         GLASS_CHECK_EXCEPTION(env);
1103     }
1104     return retVal;
1105 }
1106 
1107 - (void)sendJavaFullScreenEvent:(BOOL)entered withNativeWidget:(BOOL)isNative
1108 {
1109     if (isNative) {
1110         // Must be done before sending the event to Java since the event handler
1111         // may re-request the operation.
1112         if (entered) {
1113             self-&gt;nativeFullScreenModeWindow = [[self-&gt;nsView window] retain];
1114         } else {
1115             [self-&gt;nativeFullScreenModeWindow release];
1116             self-&gt;nativeFullScreenModeWindow = nil;
1117         }
1118     }
1119 
1120     GET_MAIN_JENV;
1121     (*env)-&gt;CallVoidMethod(env, self-&gt;jView, jViewNotifyEvent,
1122             entered ? com_sun_glass_events_ViewEvent_FULLSCREEN_ENTER : com_sun_glass_events_ViewEvent_FULLSCREEN_EXIT);
1123     GLASS_CHECK_EXCEPTION(env);
1124 }
1125 
1126 - (void)setResizableForFullscreen:(BOOL)resizable
1127 {
1128     NSWindow* window =  [self-&gt;nsView window];
1129     if ([window isKindOfClass:[GlassEmbeddedWindow class]] == NO
1130         &amp;&amp; !((GlassWindow*) window)-&gt;isResizable) {
1131         NSUInteger mask = [window styleMask];
1132         if (resizable) {
1133             mask |= NSResizableWindowMask;
1134         } else {
1135             mask &amp;= ~(NSUInteger)NSResizableWindowMask;
1136         }
1137         [window setStyleMask: mask];
1138     }
1139 }
1140 
1141 /*
1142  The hierarchy for our view is view -&gt; superview (host) -&gt; window
1143 
1144  1. create superview (new host) for our view
1145  2. create fullscreen window with the new superview
1146  3. create the background window (for fading out the desktop)
1147  4. remove our view from the window superview and insert it into the fullscreen window superview
1148  5. show our fullscreen window (and hide the original window)
1149  6. attach to it our background window (which will show it as well)
1150  7. zoom out our fullscreen window and at the same time animate the background window transparency
1151  8. enter fullscreen
1152  */
1153 - (void)enterFullscreenWithAnimate:(BOOL)animate withKeepRatio:(BOOL)keepRatio withHideCursor:(BOOL)hideCursor
1154 {
1155     LOG(&quot;GlassViewDelegate enterFullscreenWithAnimate:%d withKeepRatio:%d withHideCursor:%d&quot;, animate, keepRatio, hideCursor);
1156 
1157     if ([[self-&gt;nsView window] isKindOfClass:[GlassEmbeddedWindow class]] == NO)
1158     {
1159         [[self-&gt;nsView window] toggleFullScreen:self];
1160         // wait until the operation is complete
1161         [GlassApplication enterFullScreenExitingLoop];
1162         return;
1163     }
1164 
1165     NSScreen *screen = [[self-&gt;nsView window] screen];
1166 
1167     NSRect frameInWindowScreenCoords = [self-&gt;nsView bounds];
1168     frameInWindowScreenCoords = [self-&gt;parentWindow convertRectToScreen:frameInWindowScreenCoords];
1169     NSPoint pointInPrimaryScreenCoords = frameInWindowScreenCoords.origin;
1170 
1171     // Convert to local screen
1172     frameInWindowScreenCoords.origin.x -= screen.frame.origin.x;
1173     frameInWindowScreenCoords.origin.y -= screen.frame.origin.y;
1174 
1175     @try
1176     {
1177         // 0. Retain the view while it&#39;s in the FS mode
1178         [self-&gt;nsView retain];
1179 
1180         // 1.
1181         self-&gt;fullscreenHost = [[GlassHostView alloc] initWithFrame:[self-&gt;nsView bounds]];
1182         [self-&gt;fullscreenHost setAutoresizesSubviews:YES];
1183 
1184         // 2.
1185         self-&gt;fullscreenWindow = [[GlassFullscreenWindow alloc] initWithContentRect:frameInWindowScreenCoords
1186                                                                        withHostView:self-&gt;fullscreenHost
1187                                                                            withView:self-&gt;nsView withScreen:screen
1188                                                                           withPoint:pointInPrimaryScreenCoords];
1189 
1190         // 3.
1191 
1192         [self-&gt;parentWindow disableFlushWindow];
1193         {
1194             // handle plugin case
1195             if ([[self-&gt;nsView window] isKindOfClass:[GlassEmbeddedWindow class]] == YES)
1196             {
1197                 GlassEmbeddedWindow *window = (GlassEmbeddedWindow*)self-&gt;parentWindow;
1198                 [window setFullscreenWindow:self-&gt;fullscreenWindow];
1199             }
1200 
1201             // 4.
1202             [self-&gt;nsView retain];
1203             {
1204                 [self-&gt;nsView removeFromSuperviewWithoutNeedingDisplay];
1205                 [self-&gt;fullscreenHost addSubview:self-&gt;nsView];
1206             }
1207             [self-&gt;nsView release];
1208 
1209             if ([[self-&gt;parentWindow delegate] isKindOfClass:[GlassWindow class]] == YES)
1210             {
1211                 GlassWindow *window = (GlassWindow*)[self-&gt;parentWindow delegate];
1212                 [window setFullscreenWindow:self-&gt;fullscreenWindow];
1213             }
1214 
1215             // 5.
1216             [self-&gt;fullscreenWindow setInitialFirstResponder:self-&gt;nsView];
1217             [self-&gt;fullscreenWindow makeFirstResponder:self-&gt;nsView];
1218 
1219             // This trick allows an applet to display a focused window. This is harmless otherwise.
1220             // If we don&#39;t do this, we end up with a literally empty full screen background and no content shown whatsoever.
1221             [[NSRunningApplication currentApplication] activateWithOptions:(NSApplicationActivateIgnoringOtherApps | NSApplicationActivateAllWindows)];
1222 
1223             [self-&gt;fullscreenWindow makeKeyAndOrderFront:self-&gt;nsView];
1224             [self-&gt;fullscreenWindow orderFrontRegardless];
1225             [self-&gt;fullscreenWindow makeMainWindow];
1226         }
1227 
1228         // 6.
1229 
1230         NSRect screenFrame = [screen frame];
1231         NSRect fullscreenFrame = [screen frame];
1232         if (keepRatio == YES)
1233         {
1234             CGFloat ratioWidth = (frameInWindowScreenCoords.size.width/screenFrame.size.width);
1235             CGFloat ratioHeight = (frameInWindowScreenCoords.size.height/screenFrame.size.height);
1236             if (ratioWidth &gt; ratioHeight)
1237             {
1238                 CGFloat ratio = (frameInWindowScreenCoords.size.width/frameInWindowScreenCoords.size.height);
1239                 fullscreenFrame.size.height = fullscreenFrame.size.width / ratio;
1240                 fullscreenFrame.origin.y += (screenFrame.size.height - fullscreenFrame.size.height) / 2.0f;
1241             }
1242             else
1243             {
1244                 CGFloat ratio = (frameInWindowScreenCoords.size.height/frameInWindowScreenCoords.size.width);
1245                 fullscreenFrame.size.width = fullscreenFrame.size.height / ratio;
1246                 fullscreenFrame.origin.x += (screenFrame.size.width - fullscreenFrame.size.width) / 2.0f;
1247             }
1248         }
1249 
1250         // 7.
1251         //[self-&gt;fullscreenWindow setBackgroundColor:[NSColor whiteColor]]; // debug
1252         [self-&gt;fullscreenWindow setFrame:frameInWindowScreenCoords display:YES animate:animate];
1253 
1254         // 8.
1255         [self-&gt;fullscreenWindow toggleFullScreen:self-&gt;fullscreenWindow];
1256     }
1257     @catch (NSException *e)
1258     {
1259         NSLog(@&quot;enterFullscreenWithAnimate caught exception: %@&quot;, e);
1260     }
1261 
1262     [self sendJavaFullScreenEvent:YES withNativeWidget:NO];
1263 }
1264 
1265 - (void)exitFullscreenWithAnimate:(BOOL)animate
1266 {
1267     LOG(&quot;GlassViewDelegate exitFullscreenWithAnimate&quot;);
1268 
1269     @try
1270     {
1271         if (self-&gt;nativeFullScreenModeWindow)
1272         {
1273             [self-&gt;nativeFullScreenModeWindow performSelector:@selector(toggleFullScreen:) withObject:nil];
1274             // wait until the operation is complete
1275             [GlassApplication enterFullScreenExitingLoop];
1276             return;
1277         }
1278 
1279         [self-&gt;fullscreenWindow toggleFullScreen:self-&gt;fullscreenWindow];
1280 
1281         NSRect frame = [self-&gt;parentHost bounds];
1282         frame.origin = [self-&gt;fullscreenWindow point];
1283         [self-&gt;fullscreenWindow setFrame:frame display:YES animate:animate];
1284 
1285         [self-&gt;fullscreenWindow disableFlushWindow];
1286         {
1287             [self-&gt;nsView retain];
1288             {
1289                 [self-&gt;nsView removeFromSuperviewWithoutNeedingDisplay];
1290                 [self-&gt;parentHost addSubview:self-&gt;nsView];
1291             }
1292             [self-&gt;nsView release];
1293 
1294             // handle plugin case
1295             if ([[self-&gt;nsView window] isKindOfClass:[GlassEmbeddedWindow class]] == YES)
1296             {
1297                 GlassEmbeddedWindow *window = (GlassEmbeddedWindow*)[self-&gt;nsView window];
1298                 [window setFullscreenWindow:nil];
1299             }
1300 
1301             [self-&gt;parentWindow setInitialFirstResponder:self-&gt;nsView];
1302             [self-&gt;parentWindow makeFirstResponder:self-&gt;nsView];
1303 
1304             if ([[self-&gt;parentWindow delegate] isKindOfClass:[GlassWindow class]])
1305             {
1306                 GlassWindow *window = (GlassWindow*)[self-&gt;parentWindow delegate];
1307                 [window setFullscreenWindow: nil];
1308             }
1309         }
1310         [self-&gt;fullscreenWindow enableFlushWindow];
1311         [self-&gt;parentWindow enableFlushWindow];
1312 
1313         [self-&gt;fullscreenWindow orderOut:nil];
1314         [self-&gt;fullscreenWindow close];
1315         self-&gt;fullscreenWindow = nil;
1316 
1317         // It was retained upon entering the FS mode
1318         [self-&gt;nsView release];
1319     }
1320     @catch (NSException *e)
1321     {
1322         NSLog(@&quot;exitFullscreenWithAnimate caught exception: %@&quot;, e);
1323     }
1324 
1325     [self sendJavaFullScreenEvent:NO withNativeWidget:NO];
1326 }
1327 
1328 - (GlassAccessible*)getAccessible
1329 {
1330     GET_MAIN_JENV;
1331     jlong accessible = (*env)-&gt;CallLongMethod(env, self-&gt;jView, jViewGetAccessible);
1332     GLASS_CHECK_EXCEPTION(env);
1333     return (GlassAccessible*)jlong_to_ptr(accessible);
1334 }
1335 
1336 @end
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
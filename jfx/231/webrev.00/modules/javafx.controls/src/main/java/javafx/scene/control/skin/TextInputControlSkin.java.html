<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.controls/src/main/java/javafx/scene/control/skin/TextInputControlSkin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control.skin;
  27 
  28 import com.sun.javafx.scene.control.Properties;
  29 import com.sun.javafx.scene.control.skin.FXVK;
  30 import com.sun.javafx.scene.input.ExtendedInputMethodRequests;
  31 import javafx.animation.KeyFrame;
  32 import javafx.animation.Timeline;
  33 import javafx.application.ConditionalFeature;
  34 import javafx.application.Platform;
  35 import javafx.beans.binding.BooleanBinding;
  36 import javafx.beans.binding.ObjectBinding;
  37 import javafx.beans.property.BooleanProperty;
  38 import javafx.beans.property.ObjectProperty;
  39 import javafx.beans.property.SimpleBooleanProperty;
  40 import javafx.beans.value.ObservableBooleanValue;
  41 import javafx.beans.value.ObservableObjectValue;
  42 import javafx.collections.ObservableList;
  43 import javafx.css.CssMetaData;
  44 import javafx.css.Styleable;
  45 import javafx.css.StyleableBooleanProperty;
  46 import javafx.css.StyleableObjectProperty;
  47 import javafx.css.StyleableProperty;
  48 import javafx.geometry.NodeOrientation;
  49 import javafx.geometry.Point2D;
  50 import javafx.geometry.Rectangle2D;
  51 import javafx.scene.AccessibleAction;
  52 import javafx.scene.Node;
  53 import javafx.scene.Scene;
  54 import javafx.scene.control.IndexRange;
  55 import javafx.scene.control.SkinBase;
  56 import javafx.scene.control.TextInputControl;
  57 import javafx.scene.input.InputMethodEvent;
  58 import javafx.scene.input.InputMethodHighlight;
  59 import javafx.scene.input.InputMethodTextRun;
  60 import javafx.scene.layout.StackPane;
  61 import javafx.scene.paint.Color;
  62 import javafx.scene.paint.Paint;
  63 import javafx.scene.shape.ClosePath;
  64 import javafx.scene.shape.HLineTo;
  65 import javafx.scene.shape.Line;
  66 import javafx.scene.shape.LineTo;
  67 import javafx.scene.shape.MoveTo;
  68 import javafx.scene.shape.Path;
  69 import javafx.scene.shape.PathElement;
  70 import javafx.scene.shape.Shape;
  71 import javafx.scene.shape.VLineTo;
  72 import javafx.scene.text.HitInfo;
  73 import javafx.stage.Window;
  74 import javafx.util.Duration;
  75 import java.lang.ref.WeakReference;
  76 import java.util.ArrayList;
  77 import java.util.Collections;
  78 import java.util.List;
  79 import com.sun.javafx.PlatformUtil;
  80 import javafx.css.converter.BooleanConverter;
  81 import javafx.css.converter.PaintConverter;
  82 import com.sun.javafx.scene.control.behavior.TextInputControlBehavior;
  83 import com.sun.javafx.tk.FontMetrics;
  84 import com.sun.javafx.tk.Toolkit;
  85 import static com.sun.javafx.PlatformUtil.isWindows;
  86 import java.security.AccessController;
  87 import java.security.PrivilegedAction;
  88 
  89 /**
  90  * Abstract base class for text input skins.
  91  *
  92  * @since 9
  93  * @see TextFieldSkin
  94  * @see TextAreaSkin
  95  */
  96 public abstract class TextInputControlSkin&lt;T extends TextInputControl&gt; extends SkinBase&lt;T&gt; {
  97 
  98     /**************************************************************************
  99      *
 100      * Static fields / blocks
 101      *
 102      **************************************************************************/
 103 
 104     /**
 105      * Unit names for caret movement.
 106      *
 107      * @see #moveCaret(TextUnit, Direction, boolean)
 108      */
 109     public static enum TextUnit { CHARACTER, WORD, LINE, PARAGRAPH, PAGE };
 110 
 111     /**
 112      * Direction names for caret movement.
 113      *
 114      * @see #moveCaret(TextUnit, Direction, boolean)
 115      */
 116     public static enum Direction { LEFT, RIGHT, UP, DOWN, BEGINNING, END };
 117 
 118     static boolean preload = false;
 119     static {
 120         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 121             String s = System.getProperty(&quot;com.sun.javafx.virtualKeyboard.preload&quot;);
 122             if (s != null) {
 123                 if (s.equalsIgnoreCase(&quot;PRERENDER&quot;)) {
 124                     preload = true;
 125                 }
 126             }
 127             return null;
 128         });
 129     }
 130 
 131     /**
 132      * Specifies whether we ought to show handles. We should do it on touch platforms
 133      */
 134     static final boolean SHOW_HANDLES = Properties.IS_TOUCH_SUPPORTED;
 135 
 136     private final static boolean IS_FXVK_SUPPORTED = Platform.isSupported(ConditionalFeature.VIRTUAL_KEYBOARD);
 137 
 138     /**************************************************************************
 139      *
 140      * Private fields
 141      *
 142      **************************************************************************/
 143 
 144     final ObservableObjectValue&lt;FontMetrics&gt; fontMetrics;
 145     private ObservableBooleanValue caretVisible;
 146     private CaretBlinking caretBlinking = new CaretBlinking(blinkProperty());
 147 
 148     /**
 149      * A path, provided by the textNode, which represents the caret.
 150      * I assume this has to be updated whenever the caretPosition
 151      * changes. Perhaps more frequently (including text changes),
 152      * but I&#39;m not sure.
 153      */
 154     final Path caretPath = new Path();
 155 
 156     StackPane caretHandle = null;
 157     StackPane selectionHandle1 = null;
 158     StackPane selectionHandle2 = null;
 159 
 160     // Start/Length of the text under input method composition
 161     private int imstart;
 162     private int imlength;
 163     // Holds concrete attributes for the composition runs
 164     private List&lt;Shape&gt; imattrs = new java.util.ArrayList&lt;Shape&gt;();
 165 
 166 
 167 
 168     /**************************************************************************
 169      *
 170      * Constructors
 171      *
 172      **************************************************************************/
 173 
 174     /**
 175      * Creates a new instance of TextInputControlSkin, although note that this
 176      * instance does not handle any behavior / input mappings - this needs to be
 177      * handled appropriately by subclasses.
 178      *
 179      * @param control The control that this skin should be installed onto.
 180      */
 181     public TextInputControlSkin(final T control) {
 182         super(control);
 183 
 184         fontMetrics = new ObjectBinding&lt;FontMetrics&gt;() {
 185             { bind(control.fontProperty()); }
 186             @Override protected FontMetrics computeValue() {
 187                 invalidateMetrics();
 188                 return Toolkit.getToolkit().getFontLoader().getFontMetrics(control.getFont());
 189             }
 190         };
 191 
 192         /**
 193          * The caret is visible when the text box is focused AND when the selection
 194          * is empty. If the selection is non empty or the text box is not focused
 195          * then we don&#39;t want to show the caret. Also, we show the caret while
 196          * performing some operations such as most key strokes. In that case we
 197          * simply toggle its opacity.
 198          * &lt;p&gt;
 199          */
 200         caretVisible = new BooleanBinding() {
 201             { bind(control.focusedProperty(), control.anchorProperty(), control.caretPositionProperty(),
 202                     control.disabledProperty(), control.editableProperty(), displayCaret, blinkProperty());}
 203             @Override protected boolean computeValue() {
 204                 // RT-10682: On Windows, we show the caret during selection, but on others we hide it
 205                 return !blinkProperty().get() &amp;&amp; displayCaret.get() &amp;&amp; control.isFocused() &amp;&amp;
 206                         (isWindows() || (control.getCaretPosition() == control.getAnchor())) &amp;&amp;
 207                         !control.isDisabled() &amp;&amp;
 208                         control.isEditable();
 209             }
 210         };
 211 
 212         if (SHOW_HANDLES) {
 213             caretHandle      = new StackPane();
 214             selectionHandle1 = new StackPane();
 215             selectionHandle2 = new StackPane();
 216 
 217             caretHandle.setManaged(false);
 218             selectionHandle1.setManaged(false);
 219             selectionHandle2.setManaged(false);
 220 
 221             if (PlatformUtil.isIOS()) {
 222                 caretHandle.setVisible(false);
 223             } else {
 224                 caretHandle.visibleProperty().bind(new BooleanBinding() {
 225                     {
 226                         bind(control.focusedProperty(), control.anchorProperty(),
 227                                 control.caretPositionProperty(), control.disabledProperty(),
 228                                 control.editableProperty(), control.lengthProperty(), displayCaret);
 229                     }
 230 
 231                     @Override
 232                     protected boolean computeValue() {
 233                         return (displayCaret.get() &amp;&amp; control.isFocused() &amp;&amp;
 234                                 control.getCaretPosition() == control.getAnchor() &amp;&amp;
 235                                 !control.isDisabled() &amp;&amp; control.isEditable() &amp;&amp;
 236                                 control.getLength() &gt; 0);
 237                     }
 238                 });
 239             }
 240 
 241 
 242             selectionHandle1.visibleProperty().bind(new BooleanBinding() {
 243                 { bind(control.focusedProperty(), control.anchorProperty(), control.caretPositionProperty(),
 244                         control.disabledProperty(), displayCaret);}
 245                 @Override protected boolean computeValue() {
 246                     return (displayCaret.get() &amp;&amp; control.isFocused() &amp;&amp;
 247                             control.getCaretPosition() != control.getAnchor() &amp;&amp;
 248                             !control.isDisabled());
 249                 }
 250             });
 251 
 252 
 253             selectionHandle2.visibleProperty().bind(new BooleanBinding() {
 254                 { bind(control.focusedProperty(), control.anchorProperty(), control.caretPositionProperty(),
 255                         control.disabledProperty(), displayCaret);}
 256                 @Override protected boolean computeValue() {
 257                     return (displayCaret.get() &amp;&amp; control.isFocused() &amp;&amp;
 258                             control.getCaretPosition() != control.getAnchor() &amp;&amp;
 259                             !control.isDisabled());
 260                 }
 261             });
 262 
 263 
 264             caretHandle.getStyleClass().setAll(&quot;caret-handle&quot;);
 265             selectionHandle1.getStyleClass().setAll(&quot;selection-handle&quot;);
 266             selectionHandle2.getStyleClass().setAll(&quot;selection-handle&quot;);
 267 
 268             selectionHandle1.setId(&quot;selection-handle-1&quot;);
 269             selectionHandle2.setId(&quot;selection-handle-2&quot;);
 270         }
 271 
 272         if (IS_FXVK_SUPPORTED) {
 273             if (preload) {
 274                 Scene scene = control.getScene();
 275                 if (scene != null) {
 276                     Window window = scene.getWindow();
 277                     if (window != null) {
 278                         FXVK.init(control);
 279                     }
 280                 }
 281             }
 282             control.focusedProperty().addListener(observable -&gt; {
 283                 if (FXVK.useFXVK()) {
 284                     Scene scene = getSkinnable().getScene();
 285                     if (control.isEditable() &amp;&amp; control.isFocused()) {
 286                         FXVK.attach(control);
 287                     } else if (scene == null ||
 288                             scene.getWindow() == null ||
 289                             !scene.getWindow().isFocused() ||
 290                             !(scene.getFocusOwner() instanceof TextInputControl &amp;&amp;
 291                                     ((TextInputControl)scene.getFocusOwner()).isEditable())) {
 292                         FXVK.detach();
 293                     }
 294                 }
 295             });
 296         }
 297 
 298         if (control.getOnInputMethodTextChanged() == null) {
 299             control.setOnInputMethodTextChanged(event -&gt; {
 300                 handleInputMethodEvent(event);
 301             });
 302         }
 303 
 304         control.setInputMethodRequests(new ExtendedInputMethodRequests() {
 305             @Override public Point2D getTextLocation(int offset) {
 306                 Scene scene = getSkinnable().getScene();
 307                 Window window = scene.getWindow();
 308                 // Don&#39;t use imstart here because it isn&#39;t initialized yet.
 309                 Rectangle2D characterBounds = getCharacterBounds(control.getSelection().getStart() + offset);
 310                 Point2D p = getSkinnable().localToScene(characterBounds.getMinX(), characterBounds.getMaxY());
 311                 Point2D location = new Point2D(window.getX() + scene.getX() + p.getX(),
 312                         window.getY() + scene.getY() + p.getY());
 313                 return location;
 314             }
 315 
 316             @Override public int getLocationOffset(int x, int y) {
 317                 return getInsertionPoint(x, y);
 318             }
 319 
 320             @Override public void cancelLatestCommittedText() {
 321                 // TODO
 322             }
 323 
 324             @Override public String getSelectedText() {
 325                 TextInputControl control = getSkinnable();
 326                 IndexRange selection = control.getSelection();
 327 
 328                 return control.getText(selection.getStart(), selection.getEnd());
 329             }
 330 
 331             @Override public int getInsertPositionOffset() {
 332                 int caretPosition = getSkinnable().getCaretPosition();
 333                 if (caretPosition &lt; imstart) {
 334                     return caretPosition;
 335                 } else if (caretPosition &lt; imstart + imlength) {
 336                     return imstart;
 337                 } else {
 338                     return caretPosition - imlength;
 339                 }
 340             }
 341 
 342             @Override public String getCommittedText(int begin, int end) {
 343                 TextInputControl control = getSkinnable();
 344                 if (begin &lt; imstart) {
 345                     if (end &lt;= imstart) {
 346                         return control.getText(begin, end);
 347                     } else {
 348                         return control.getText(begin, imstart) + control.getText(imstart + imlength, end + imlength);
 349                     }
 350                 } else {
 351                     return control.getText(begin + imlength, end + imlength);
 352                 }
 353             }
 354 
 355             @Override public int getCommittedTextLength() {
 356                 return getSkinnable().getText().length() - imlength;
 357             }
 358         });
 359     }
 360 
 361 
 362 
 363     /**************************************************************************
 364      *
 365      * Properties
 366      *
 367      **************************************************************************/
 368 
 369     // --- blink
 370     private BooleanProperty blink;
 371     private final void setBlink(boolean value) {
 372         blinkProperty().set(value);
 373     }
 374     private final boolean isBlink() {
 375         return blinkProperty().get();
 376     }
 377     private final BooleanProperty blinkProperty() {
 378         if (blink == null) {
 379             blink = new SimpleBooleanProperty(this, &quot;blink&quot;, true);
 380         }
 381         return blink;
 382     }
 383 
 384     // --- text fill
 385     /**
 386      * The fill to use for the text under normal conditions
 387      */
 388     private final ObjectProperty&lt;Paint&gt; textFill = new StyleableObjectProperty&lt;Paint&gt;(Color.BLACK) {
 389         @Override protected void invalidated() {
 390             updateTextFill();
 391         }
 392 
 393         @Override public Object getBean() {
 394             return TextInputControlSkin.this;
 395         }
 396 
 397         @Override public String getName() {
 398             return &quot;textFill&quot;;
 399         }
 400 
 401         @Override public CssMetaData&lt;TextInputControl,Paint&gt; getCssMetaData() {
 402             return StyleableProperties.TEXT_FILL;
 403         }
 404     };
 405 
 406     /**
 407      * The fill {@code Paint} used for the foreground text color.
 408      * @param value the text fill
 409      */
 410     protected final void setTextFill(Paint value) {
 411         textFill.set(value);
 412     }
 413     protected final Paint getTextFill() {
 414         return textFill.get();
 415     }
 416     protected final ObjectProperty&lt;Paint&gt; textFillProperty() {
 417         return textFill;
 418     }
 419 
 420     // --- prompt text fill
 421     private final ObjectProperty&lt;Paint&gt; promptTextFill = new StyleableObjectProperty&lt;Paint&gt;(Color.GRAY) {
 422         @Override public Object getBean() {
 423             return TextInputControlSkin.this;
 424         }
 425 
 426         @Override public String getName() {
 427             return &quot;promptTextFill&quot;;
 428         }
 429 
 430         @Override public CssMetaData&lt;TextInputControl,Paint&gt; getCssMetaData() {
 431             return StyleableProperties.PROMPT_TEXT_FILL;
 432         }
 433     };
 434 
 435     /**
 436      * The fill {@code Paint} used for the foreground prompt text color.
 437      * @param value the prompt text fill
 438      */
 439     protected final void setPromptTextFill(Paint value) {
 440         promptTextFill.set(value);
 441     }
 442     protected final Paint getPromptTextFill() {
 443         return promptTextFill.get();
 444     }
 445     protected final ObjectProperty&lt;Paint&gt; promptTextFillProperty() {
 446         return promptTextFill;
 447     }
 448 
 449     // --- hightlight fill
 450     /**
 451      * The fill to use for the text when highlighted.
 452      */
 453     private final ObjectProperty&lt;Paint&gt; highlightFill = new StyleableObjectProperty&lt;Paint&gt;(Color.DODGERBLUE) {
 454         @Override protected void invalidated() {
 455             updateHighlightFill();
 456         }
 457 
 458         @Override public Object getBean() {
 459             return TextInputControlSkin.this;
 460         }
 461 
 462         @Override public String getName() {
 463             return &quot;highlightFill&quot;;
 464         }
 465 
 466         @Override public CssMetaData&lt;TextInputControl,Paint&gt; getCssMetaData() {
 467             return StyleableProperties.HIGHLIGHT_FILL;
 468         }
 469     };
 470 
 471     /**
 472      * The fill {@code Paint} used for the background of selected text.
 473      * @param value the highlight fill
 474      */
 475     protected final void setHighlightFill(Paint value) {
 476         highlightFill.set(value);
 477     }
 478     protected final Paint getHighlightFill() {
 479         return highlightFill.get();
 480     }
 481     protected final ObjectProperty&lt;Paint&gt; highlightFillProperty() {
 482         return highlightFill;
 483     }
 484 
 485     // --- highlight text fill
 486     private final ObjectProperty&lt;Paint&gt; highlightTextFill = new StyleableObjectProperty&lt;Paint&gt;(Color.WHITE) {
 487         @Override protected void invalidated() {
 488             updateHighlightTextFill();
 489         }
 490 
 491         @Override public Object getBean() {
 492             return TextInputControlSkin.this;
 493         }
 494 
 495         @Override public String getName() {
 496             return &quot;highlightTextFill&quot;;
 497         }
 498 
 499         @Override public CssMetaData&lt;TextInputControl,Paint&gt; getCssMetaData() {
 500             return StyleableProperties.HIGHLIGHT_TEXT_FILL;
 501         }
 502     };
 503 
 504     /**
 505      * The fill {@code Paint} used for the foreground of selected text.
 506      * @param value the highlight text fill
 507      */
 508     protected final void setHighlightTextFill(Paint value) {
 509         highlightTextFill.set(value);
 510     }
 511     protected final Paint getHighlightTextFill() {
 512         return highlightTextFill.get();
 513     }
 514     protected final ObjectProperty&lt;Paint&gt; highlightTextFillProperty() {
 515         return highlightTextFill;
 516     }
 517 
 518     // --- display caret
 519     private final BooleanProperty displayCaret = new StyleableBooleanProperty(true) {
 520         @Override public Object getBean() {
 521             return TextInputControlSkin.this;
 522         }
 523 
 524         @Override public String getName() {
 525             return &quot;displayCaret&quot;;
 526         }
 527 
 528         @Override public CssMetaData&lt;TextInputControl,Boolean&gt; getCssMetaData() {
 529             return StyleableProperties.DISPLAY_CARET;
 530         }
 531     };
 532 
 533     private final void setDisplayCaret(boolean value) {
 534         displayCaret.set(value);
 535     }
 536     private final boolean isDisplayCaret() {
 537         return displayCaret.get();
 538     }
 539     private final BooleanProperty displayCaretProperty() {
 540         return displayCaret;
 541     }
 542 
 543 
 544     /**
 545      * Caret bias in the content. true means a bias towards forward character
 546      * (true=leading/false=trailing)
 547      */
 548     private BooleanProperty forwardBias = new SimpleBooleanProperty(this, &quot;forwardBias&quot;, true);
 549     protected final BooleanProperty forwardBiasProperty() {
 550         return forwardBias;
 551     }
 552     // Public for behavior
 553     public final void setForwardBias(boolean isLeading) {
 554         forwardBias.set(isLeading);
 555     }
 556     protected final boolean isForwardBias() {
 557         return forwardBias.get();
 558     }
 559 
 560 
 561 
 562     /**************************************************************************
 563      *
 564      * Abstract API
 565      *
 566      **************************************************************************/
 567 
 568     /**
 569      * @param start the start
 570      * @param end the end
 571      * @return the path elements describing the shape of the underline for the given range.
 572      */
 573     protected abstract PathElement[] getUnderlineShape(int start, int end);
 574     /**
 575      * @param start the start
 576      * @param end the end
 577      * @return the path elements describing the bounding rectangles for the given range of text.
 578      */
 579     protected abstract PathElement[] getRangeShape(int start, int end);
 580     /**
 581      * Adds highlight for composed text from Input Method.
 582      * @param nodes the list of nodes
 583      * @param start the start
 584      */
 585     protected abstract void addHighlight(List&lt;? extends Node&gt; nodes, int start);
 586     /**
 587      * Removes highlight for composed text from Input Method.
 588      * @param nodes the list of nodes
 589      */
 590     protected abstract void removeHighlight(List&lt;? extends Node&gt; nodes);
 591 
 592     // Public for behavior
 593     /**
 594      * Moves the caret by one of the given text unit, in the given
 595      * direction. Note that only certain combinations are valid,
 596      * depending on the implementing subclass.
 597      *
 598      * @param unit the unit of text to move by.
 599      * @param dir the direction of movement.
 600      * @param select whether to extends the selection to the new posititon.
 601      */
 602     public abstract void moveCaret(TextUnit unit, Direction dir, boolean select);
 603 
 604     /**************************************************************************
 605      *
 606      * Public API
 607      *
 608      **************************************************************************/
 609 
 610 
 611     // Public for behavior
 612     /**
 613      * Returns the position to be used for a context menu, based on the location
 614      * of the caret handle or selection handles. This is supported only on touch
 615      * displays and does not use the location of the mouse.
 616      * @return the position to be used for this context menu
 617      */
 618     public Point2D getMenuPosition() {
 619         if (SHOW_HANDLES) {
 620             if (caretHandle.isVisible()) {
 621                 return new Point2D(caretHandle.getLayoutX() + caretHandle.getWidth() / 2,
 622                                    caretHandle.getLayoutY());
 623             } else if (selectionHandle1.isVisible() &amp;&amp; selectionHandle2.isVisible()) {
 624                 return new Point2D((selectionHandle1.getLayoutX() + selectionHandle1.getWidth() / 2 +
 625                                     selectionHandle2.getLayoutX() + selectionHandle2.getWidth() / 2) / 2,
 626                                    selectionHandle2.getLayoutY() + selectionHandle2.getHeight() / 2);
 627             } else {
 628                 return null;
 629             }
 630         } else {
 631             throw new UnsupportedOperationException();
 632         }
 633     }
 634 
 635     // For use with PasswordField in TextFieldSkin
 636     /**
 637      * This method may be overridden by subclasses to replace the displayed
 638      * characters without affecting the actual text content. This is used to
 639      * display bullet characters in PasswordField.
 640      *
 641      * @param txt the content that may need to be masked.
 642      * @return the replacement string. This may just be the input string, or may be a string of replacement characters with the same length as the input string.
 643      */
 644     protected String maskText(String txt) {
 645         return txt;
 646     }
 647 
 648     /**
 649      * Returns the insertion point for a given location.
 650      *
 651      * @param x the x location
 652      * @param y the y location
 653      * @return the insertion point for a given location
 654      */
 655     protected int getInsertionPoint(double x, double y) { return 0; }
 656 
 657     /**
 658      * Returns the bounds of the character at a given index.
 659      *
 660      * @param index the index
 661      * @return the bounds of the character at a given index
 662      */
 663     public Rectangle2D getCharacterBounds(int index) { return null; }
 664 
 665     /**
 666      * Ensures that the character at a given index is visible.
 667      *
 668      * @param index the index
 669      */
 670     protected void scrollCharacterToVisible(int index) {}
 671 
 672     /**
 673      * Invalidates cached min and pref sizes for the TextInputControl.
 674      */
 675     protected void invalidateMetrics() {
 676     }
 677 
 678     /**
 679      * Called when textFill property changes.
 680      */
 681     protected void updateTextFill() {};
 682 
 683     /**
 684      * Called when highlightFill property changes.
 685      */
 686     protected void updateHighlightFill() {};
 687 
 688     /**
 689      * Called when highlightTextFill property changes.
 690      */
 691     protected void updateHighlightTextFill() {};
 692 
 693     protected void handleInputMethodEvent(InputMethodEvent event) {
 694         final TextInputControl textInput = getSkinnable();
 695         if (textInput.isEditable() &amp;&amp; !textInput.textProperty().isBound() &amp;&amp; !textInput.isDisabled()) {
 696 
 697             // remove previous input method text (if any) or selected text
 698             if (imlength != 0) {
 699                 removeHighlight(imattrs);
 700                 imattrs.clear();
 701                 textInput.selectRange(imstart, imstart + imlength);
 702             }
 703 
 704             // Insert committed text
 705             if (event.getCommitted().length() != 0) {
 706                 String committed = event.getCommitted();
 707                 textInput.replaceText(textInput.getSelection(), committed);
 708             }
 709 
 710             // Replace composed text
 711             imstart = textInput.getSelection().getStart();
 712             StringBuilder composed = new StringBuilder();
 713             for (InputMethodTextRun run : event.getComposed()) {
 714                 composed.append(run.getText());
 715             }
 716             textInput.replaceText(textInput.getSelection(), composed.toString());
 717             imlength = composed.length();
 718             if (imlength != 0) {
 719                 int pos = imstart;
 720                 for (InputMethodTextRun run : event.getComposed()) {
 721                     int endPos = pos + run.getText().length();
 722                     createInputMethodAttributes(run.getHighlight(), pos, endPos);
 723                     pos = endPos;
 724                 }
 725                 addHighlight(imattrs, imstart);
 726 
 727                 // Set caret position in composed text
 728                 int caretPos = event.getCaretPosition();
 729                 if (caretPos &gt;= 0 &amp;&amp; caretPos &lt; imlength) {
 730                     textInput.selectRange(imstart + caretPos, imstart + caretPos);
 731                 }
 732             }
 733         }
 734     }
 735 
 736     // Public for behavior
 737     /**
 738      * Starts or stops caret blinking. The behavior classes use this to temporarily
 739      * pause blinking while user is typing or otherwise moving the caret.
 740      *
 741      * @param value whether caret should be blinking.
 742      */
 743     public void setCaretAnimating(boolean value) {
 744         if (value) {
 745             caretBlinking.start();
 746         } else {
 747             caretBlinking.stop();
 748             blinkProperty().set(true);
 749         }
 750     }
 751 
 752 
 753 
 754     /**************************************************************************
 755      *
 756      * Private implementation
 757      *
 758      **************************************************************************/
 759 
 760     TextInputControlBehavior getBehavior() {
 761         return null;
 762     }
 763 
 764     ObservableBooleanValue caretVisibleProperty() {
 765         return caretVisible;
 766     }
 767 
 768     boolean isRTL() {
 769         return (getSkinnable().getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT);
 770     };
 771 
 772     private void createInputMethodAttributes(InputMethodHighlight highlight, int start, int end) {
 773         double minX = 0f;
 774         double maxX = 0f;
 775         double minY = 0f;
 776         double maxY = 0f;
 777 
 778         PathElement elements[] = getUnderlineShape(start, end);
 779         for (int i = 0; i &lt; elements.length; i++) {
 780             PathElement pe = elements[i];
 781             if (pe instanceof MoveTo) {
 782                 minX = maxX = ((MoveTo)pe).getX();
 783                 minY = maxY = ((MoveTo)pe).getY();
 784             } else if (pe instanceof LineTo) {
 785                 minX = (minX &lt; ((LineTo)pe).getX() ? minX : ((LineTo)pe).getX());
 786                 maxX = (maxX &gt; ((LineTo)pe).getX() ? maxX : ((LineTo)pe).getX());
 787                 minY = (minY &lt; ((LineTo)pe).getY() ? minY : ((LineTo)pe).getY());
 788                 maxY = (maxY &gt; ((LineTo)pe).getY() ? maxY : ((LineTo)pe).getY());
 789             } else if (pe instanceof HLineTo) {
 790                 minX = (minX &lt; ((HLineTo)pe).getX() ? minX : ((HLineTo)pe).getX());
 791                 maxX = (maxX &gt; ((HLineTo)pe).getX() ? maxX : ((HLineTo)pe).getX());
 792             } else if (pe instanceof VLineTo) {
 793                 minY = (minY &lt; ((VLineTo)pe).getY() ? minY : ((VLineTo)pe).getY());
 794                 maxY = (maxY &gt; ((VLineTo)pe).getY() ? maxY : ((VLineTo)pe).getY());
 795             }
 796             // Don&#39;t assume that shapes are ended with ClosePath.
 797             if (pe instanceof ClosePath ||
 798                     i == elements.length - 1 ||
 799                     (i &lt; elements.length - 1 &amp;&amp; elements[i+1] instanceof MoveTo)) {
 800                 // Now, create the attribute.
 801                 Shape attr = null;
 802                 if (highlight == InputMethodHighlight.SELECTED_RAW) {
 803                     // blue background
 804                     attr = new Path();
 805                     ((Path)attr).getElements().addAll(getRangeShape(start, end));
 806                     attr.setFill(Color.BLUE);
 807                     attr.setOpacity(0.3f);
 808                 } else if (highlight == InputMethodHighlight.UNSELECTED_RAW) {
 809                     // dash underline.
 810                     attr = new Line(minX + 2, maxY + 1, maxX - 2, maxY + 1);
 811                     attr.setStroke(textFill.get());
 812                     attr.setStrokeWidth(maxY - minY);
 813                     ObservableList&lt;Double&gt; dashArray = attr.getStrokeDashArray();
 814                     dashArray.add(Double.valueOf(2f));
 815                     dashArray.add(Double.valueOf(2f));
 816                 } else if (highlight == InputMethodHighlight.SELECTED_CONVERTED) {
 817                     // thick underline.
 818                     attr = new Line(minX + 2, maxY + 1, maxX - 2, maxY + 1);
 819                     attr.setStroke(textFill.get());
 820                     attr.setStrokeWidth((maxY - minY) * 3);
 821                 } else if (highlight == InputMethodHighlight.UNSELECTED_CONVERTED) {
 822                     // single underline.
 823                     attr = new Line(minX + 2, maxY + 1, maxX - 2, maxY + 1);
 824                     attr.setStroke(textFill.get());
 825                     attr.setStrokeWidth(maxY - minY);
 826                 }
 827 
 828                 if (attr != null) {
 829                     attr.setManaged(false);
 830                     imattrs.add(attr);
 831                 }
 832             }
 833         }
 834     }
 835 
 836 
 837 
 838     /**************************************************************************
 839      *
 840      * Support classes
 841      *
 842      **************************************************************************/
 843 
 844     private static final class CaretBlinking {
 845         private final Timeline caretTimeline;
 846         private final WeakReference&lt;BooleanProperty&gt; blinkPropertyRef;
 847 
 848         public CaretBlinking(final BooleanProperty blinkProperty) {
 849             blinkPropertyRef = new WeakReference&lt;&gt;(blinkProperty);
 850 
 851             caretTimeline = new Timeline();
 852             caretTimeline.setCycleCount(Timeline.INDEFINITE);
 853             caretTimeline.getKeyFrames().addAll(
 854                 new KeyFrame(Duration.ZERO, e -&gt; setBlink(false)),
 855                 new KeyFrame(Duration.seconds(.5), e -&gt; setBlink(true)),
 856                 new KeyFrame(Duration.seconds(1)));
 857         }
 858 
 859         public void start() {
 860             caretTimeline.play();
 861         }
 862 
 863         public void stop() {
 864             caretTimeline.stop();
 865         }
 866 
 867         private void setBlink(final boolean value) {
 868             final BooleanProperty blinkProperty = blinkPropertyRef.get();
 869             if (blinkProperty == null) {
 870                 caretTimeline.stop();
 871                 return;
 872             }
 873 
 874             blinkProperty.set(value);
 875         }
 876     }
 877 
 878 
 879     private static class StyleableProperties {
 880         private static final CssMetaData&lt;TextInputControl,Paint&gt; TEXT_FILL =
 881             new CssMetaData&lt;TextInputControl,Paint&gt;(&quot;-fx-text-fill&quot;,
 882                 PaintConverter.getInstance(), Color.BLACK) {
 883 
 884             @Override public boolean isSettable(TextInputControl n) {
 885                 final TextInputControlSkin&lt;?&gt; skin = (TextInputControlSkin&lt;?&gt;) n.getSkin();
 886                 return skin.textFill == null || !skin.textFill.isBound();
 887             }
 888 
 889             @Override @SuppressWarnings(&quot;unchecked&quot;)
 890             public StyleableProperty&lt;Paint&gt; getStyleableProperty(TextInputControl n) {
 891                 final TextInputControlSkin&lt;?&gt; skin = (TextInputControlSkin&lt;?&gt;) n.getSkin();
 892                 return (StyleableProperty&lt;Paint&gt;)skin.textFill;
 893             }
 894         };
 895 
 896         private static final CssMetaData&lt;TextInputControl,Paint&gt; PROMPT_TEXT_FILL =
 897             new CssMetaData&lt;TextInputControl,Paint&gt;(&quot;-fx-prompt-text-fill&quot;,
 898                 PaintConverter.getInstance(), Color.GRAY) {
 899 
 900             @Override public boolean isSettable(TextInputControl n) {
 901                 final TextInputControlSkin&lt;?&gt; skin = (TextInputControlSkin&lt;?&gt;) n.getSkin();
 902                 return skin.promptTextFill == null || !skin.promptTextFill.isBound();
 903             }
 904 
 905             @Override @SuppressWarnings(&quot;unchecked&quot;)
 906             public StyleableProperty&lt;Paint&gt; getStyleableProperty(TextInputControl n) {
 907                 final TextInputControlSkin&lt;?&gt; skin = (TextInputControlSkin&lt;?&gt;) n.getSkin();
 908                 return (StyleableProperty&lt;Paint&gt;)skin.promptTextFill;
 909             }
 910         };
 911 
 912         private static final CssMetaData&lt;TextInputControl,Paint&gt; HIGHLIGHT_FILL =
 913             new CssMetaData&lt;TextInputControl,Paint&gt;(&quot;-fx-highlight-fill&quot;,
 914                 PaintConverter.getInstance(), Color.DODGERBLUE) {
 915 
 916             @Override public boolean isSettable(TextInputControl n) {
 917                 final TextInputControlSkin&lt;?&gt; skin = (TextInputControlSkin&lt;?&gt;) n.getSkin();
 918                 return skin.highlightFill == null || !skin.highlightFill.isBound();
 919             }
 920 
 921             @Override @SuppressWarnings(&quot;unchecked&quot;)
 922             public StyleableProperty&lt;Paint&gt; getStyleableProperty(TextInputControl n) {
 923                 final TextInputControlSkin&lt;?&gt; skin = (TextInputControlSkin&lt;?&gt;) n.getSkin();
 924                 return (StyleableProperty&lt;Paint&gt;)skin.highlightFill;
 925             }
 926         };
 927 
 928         private static final CssMetaData&lt;TextInputControl,Paint&gt; HIGHLIGHT_TEXT_FILL =
 929             new CssMetaData&lt;TextInputControl,Paint&gt;(&quot;-fx-highlight-text-fill&quot;,
 930                 PaintConverter.getInstance(), Color.WHITE) {
 931 
 932             @Override public boolean isSettable(TextInputControl n) {
 933                 final TextInputControlSkin&lt;?&gt; skin = (TextInputControlSkin&lt;?&gt;) n.getSkin();
 934                 return skin.highlightTextFill == null || !skin.highlightTextFill.isBound();
 935             }
 936 
 937             @Override @SuppressWarnings(&quot;unchecked&quot;)
 938             public StyleableProperty&lt;Paint&gt; getStyleableProperty(TextInputControl n) {
 939                 final TextInputControlSkin&lt;?&gt; skin = (TextInputControlSkin&lt;?&gt;) n.getSkin();
 940                 return (StyleableProperty&lt;Paint&gt;)skin.highlightTextFill;
 941             }
 942         };
 943 
 944         private static final CssMetaData&lt;TextInputControl,Boolean&gt; DISPLAY_CARET =
 945             new CssMetaData&lt;TextInputControl,Boolean&gt;(&quot;-fx-display-caret&quot;,
 946                 BooleanConverter.getInstance(), Boolean.TRUE) {
 947 
 948             @Override public boolean isSettable(TextInputControl n) {
 949                 final TextInputControlSkin&lt;?&gt; skin = (TextInputControlSkin&lt;?&gt;) n.getSkin();
 950                 return skin.displayCaret == null || !skin.displayCaret.isBound();
 951             }
 952 
 953             @Override @SuppressWarnings(&quot;unchecked&quot;)
 954             public StyleableProperty&lt;Boolean&gt; getStyleableProperty(TextInputControl n) {
 955                 final TextInputControlSkin&lt;?&gt; skin = (TextInputControlSkin&lt;?&gt;) n.getSkin();
 956                 return (StyleableProperty&lt;Boolean&gt;)skin.displayCaret;
 957             }
 958         };
 959 
 960         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
 961         static {
 962             List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
 963                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
 964             styleables.add(TEXT_FILL);
 965             styleables.add(PROMPT_TEXT_FILL);
 966             styleables.add(HIGHLIGHT_FILL);
 967             styleables.add(HIGHLIGHT_TEXT_FILL);
 968             styleables.add(DISPLAY_CARET);
 969 
 970             STYLEABLES = Collections.unmodifiableList(styleables);
 971         }
 972     }
 973 
 974     /**
 975      * Returns the CssMetaData associated with this class, which may include the
 976      * CssMetaData of its superclasses.
 977      * @return the CssMetaData associated with this class, which may include the
 978      * CssMetaData of its superclasses
 979      */
 980     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
 981         return StyleableProperties.STYLEABLES;
 982     }
 983 
 984     /**
 985      * {@inheritDoc}
 986      */
 987     @Override public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
 988         return getClassCssMetaData();
 989     }
 990 
 991     @Override protected void executeAccessibleAction(AccessibleAction action, Object... parameters) {
 992         switch (action) {
 993             case SHOW_TEXT_RANGE: {
 994                 Integer start = (Integer)parameters[0];
 995                 Integer end = (Integer)parameters[1];
 996                 if (start != null &amp;&amp; end != null) {
 997                     scrollCharacterToVisible(end);
 998                     scrollCharacterToVisible(start);
 999                     scrollCharacterToVisible(end);
1000                 }
1001                 break;
1002             }
1003             default: super.executeAccessibleAction(action, parameters);
1004         }
1005     }
1006 }
    </pre>
  </body>
</html>
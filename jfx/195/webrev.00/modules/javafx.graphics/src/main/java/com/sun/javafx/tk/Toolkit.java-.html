<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.graphics/src/main/java/com/sun/javafx/tk/Toolkit.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.javafx.tk;
 27 
 28 import javafx.application.ConditionalFeature;
 29 import javafx.beans.property.ReadOnlyObjectProperty;
 30 import javafx.geometry.Dimension2D;
 31 import javafx.scene.Scene;
 32 import javafx.scene.effect.BlurType;
 33 import javafx.scene.image.Image;
 34 import javafx.scene.image.PixelFormat;
 35 import javafx.scene.image.WritableImage;
 36 import javafx.scene.input.Dragboard;
 37 import javafx.scene.input.InputMethodRequests;
 38 import javafx.scene.input.KeyCode;
 39 import javafx.scene.input.KeyEvent;
 40 import javafx.scene.input.TransferMode;
 41 import javafx.scene.paint.Color;
 42 import javafx.scene.paint.ImagePattern;
 43 import javafx.scene.paint.LinearGradient;
 44 import javafx.scene.paint.Paint;
 45 import javafx.scene.paint.RadialGradient;
 46 import javafx.scene.paint.Stop;
 47 import javafx.scene.shape.PathElement;
 48 import javafx.scene.shape.SVGPath;
 49 import javafx.scene.shape.StrokeLineCap;
 50 import javafx.scene.shape.StrokeLineJoin;
 51 import javafx.scene.shape.StrokeType;
 52 import javafx.stage.FileChooser.ExtensionFilter;
 53 import javafx.stage.Modality;
 54 import javafx.stage.Stage;
 55 import javafx.stage.StageStyle;
 56 import javafx.stage.Window;
 57 import java.io.File;
 58 import java.io.IOException;
 59 import java.io.InputStream;
 60 import java.nio.ByteBuffer;
 61 import java.security.AccessControlContext;
 62 import java.security.AccessController;
 63 import java.security.PrivilegedAction;
 64 import java.util.ArrayList;
 65 import java.util.HashSet;
 66 import java.util.Iterator;
 67 import java.util.List;
 68 import java.util.Map;
 69 import java.util.Set;
 70 import java.util.WeakHashMap;
 71 import java.util.concurrent.CountDownLatch;
 72 import java.util.concurrent.Future;
 73 import com.sun.glass.ui.CommonDialogs.FileChooserResult;
 74 import com.sun.glass.ui.GlassRobot;
 75 import com.sun.glass.utils.NativeLibLoader;
 76 import com.sun.javafx.PlatformUtil;
 77 import com.sun.javafx.beans.event.AbstractNotifyListener;
 78 import com.sun.javafx.embed.HostInterface;
 79 import com.sun.javafx.geom.Path2D;
 80 import com.sun.javafx.geom.transform.BaseTransform;
 81 import com.sun.javafx.perf.PerformanceTracker;
 82 import com.sun.javafx.runtime.VersionInfo;
 83 import com.sun.javafx.runtime.async.AsyncOperation;
 84 import com.sun.javafx.runtime.async.AsyncOperationListener;
 85 import com.sun.javafx.scene.SceneHelper;
 86 import com.sun.javafx.scene.text.TextLayoutFactory;
 87 import com.sun.javafx.sg.prism.NGCamera;
 88 import com.sun.javafx.sg.prism.NGLightBase;
 89 import com.sun.javafx.sg.prism.NGNode;
 90 import com.sun.javafx.util.Utils;
 91 import com.sun.scenario.DelayedRunnable;
 92 import com.sun.scenario.animation.AbstractMasterTimer;
 93 import com.sun.scenario.effect.AbstractShadow.ShadowMode;
 94 import com.sun.scenario.effect.Color4f;
 95 import com.sun.scenario.effect.FilterContext;
 96 import com.sun.scenario.effect.Filterable;
 97 
 98 
 99 public abstract class Toolkit {
100     private static String tk;
101     private static Toolkit TOOLKIT;
102     private static Thread fxUserThread = null;
103 
104     private static final String QUANTUM_TOOLKIT     = &quot;com.sun.javafx.tk.quantum.QuantumToolkit&quot;;
105     private static final String DEFAULT_TOOLKIT     = QUANTUM_TOOLKIT;
106 
107     private static final Map gradientMap = new WeakHashMap();
108 
109     private static final boolean verbose = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;javafx.verbose&quot;));
110 
111     private static final String[] msLibNames = {
112         &quot;api-ms-win-core-console-l1-1-0&quot;,
113         &quot;api-ms-win-core-datetime-l1-1-0&quot;,
114         &quot;api-ms-win-core-debug-l1-1-0&quot;,
115         &quot;api-ms-win-core-errorhandling-l1-1-0&quot;,
116         &quot;api-ms-win-core-file-l1-1-0&quot;,
117         &quot;api-ms-win-core-file-l1-2-0&quot;,
118         &quot;api-ms-win-core-file-l2-1-0&quot;,
119         &quot;api-ms-win-core-handle-l1-1-0&quot;,
120         &quot;api-ms-win-core-heap-l1-1-0&quot;,
121         &quot;api-ms-win-core-interlocked-l1-1-0&quot;,
122         &quot;api-ms-win-core-libraryloader-l1-1-0&quot;,
123         &quot;api-ms-win-core-localization-l1-2-0&quot;,
124         &quot;api-ms-win-core-memory-l1-1-0&quot;,
125         &quot;api-ms-win-core-namedpipe-l1-1-0&quot;,
126         &quot;api-ms-win-core-processenvironment-l1-1-0&quot;,
127         &quot;api-ms-win-core-processthreads-l1-1-0&quot;,
128         &quot;api-ms-win-core-processthreads-l1-1-1&quot;,
129         &quot;api-ms-win-core-profile-l1-1-0&quot;,
130         &quot;api-ms-win-core-rtlsupport-l1-1-0&quot;,
131         &quot;api-ms-win-core-string-l1-1-0&quot;,
132         &quot;api-ms-win-core-synch-l1-1-0&quot;,
133         &quot;api-ms-win-core-synch-l1-2-0&quot;,
134         &quot;api-ms-win-core-sysinfo-l1-1-0&quot;,
135         &quot;api-ms-win-core-timezone-l1-1-0&quot;,
136         &quot;api-ms-win-core-util-l1-1-0&quot;,
137         &quot;api-ms-win-crt-conio-l1-1-0&quot;,
138         &quot;api-ms-win-crt-convert-l1-1-0&quot;,
139         &quot;api-ms-win-crt-environment-l1-1-0&quot;,
140         &quot;api-ms-win-crt-filesystem-l1-1-0&quot;,
141         &quot;api-ms-win-crt-heap-l1-1-0&quot;,
142         &quot;api-ms-win-crt-locale-l1-1-0&quot;,
143         &quot;api-ms-win-crt-math-l1-1-0&quot;,
144         &quot;api-ms-win-crt-multibyte-l1-1-0&quot;,
145         &quot;api-ms-win-crt-private-l1-1-0&quot;,
146         &quot;api-ms-win-crt-process-l1-1-0&quot;,
147         &quot;api-ms-win-crt-runtime-l1-1-0&quot;,
148         &quot;api-ms-win-crt-stdio-l1-1-0&quot;,
149         &quot;api-ms-win-crt-string-l1-1-0&quot;,
150         &quot;api-ms-win-crt-time-l1-1-0&quot;,
151         &quot;api-ms-win-crt-utility-l1-1-0&quot;,
152         &quot;ucrtbase&quot;,
153 
154         // Finally load VS 2017 DLLs in the following order
155         &quot;vcruntime140&quot;,
156         &quot;msvcp140&quot;,
157         &quot;concrt140&quot;
158 };
159 
160     private static String lookupToolkitClass(String name) {
161         if (&quot;prism&quot;.equalsIgnoreCase(name)) {
162             return QUANTUM_TOOLKIT;
163         } else if (&quot;quantum&quot;.equalsIgnoreCase(name)) {
164             return QUANTUM_TOOLKIT;
165         }
166         return name;
167     }
168 
169     public static synchronized void loadMSWindowsLibraries() {
170         for (String libName : msLibNames) {
171             try {
172                 NativeLibLoader.loadLibrary(libName);
173             } catch (Throwable t) {
174                 if (verbose) {
175                     System.err.println(&quot;Error: failed to load &quot;
176                             + libName + &quot;.dll : &quot; + t);
177                 }
178             }
179         }
180     }
181 
182     private static String getDefaultToolkit() {
183         if (PlatformUtil.isWindows()) {
184             return DEFAULT_TOOLKIT;
185         } else if (PlatformUtil.isMac()) {
186             return DEFAULT_TOOLKIT;
187         } else if (PlatformUtil.isLinux()) {
188             return DEFAULT_TOOLKIT;
189         } else if (PlatformUtil.isIOS()) {
190             return DEFAULT_TOOLKIT;
191         } else if (PlatformUtil.isAndroid()) {
192            return DEFAULT_TOOLKIT;
193         }
194 
195         throw new UnsupportedOperationException(System.getProperty(&quot;os.name&quot;) + &quot; is not supported&quot;);
196     }
197 
198     public static synchronized Toolkit getToolkit() {
199         if (TOOLKIT != null) {
200             return TOOLKIT;
201         }
202 
203         AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
204             // Get the javafx.version and javafx.runtime.version from a preconstructed
205             // java class, VersionInfo, created at build time.
206             VersionInfo.setupSystemProperties();
207             return null;
208         });
209 
210         // This loading of msvcp140.dll and vcruntime140.dll (VS2017) is required on Windows platforms
211         if (PlatformUtil.isWindows()) {
212             loadMSWindowsLibraries();
213         }
214 
215         boolean userSpecifiedToolkit = true;
216 
217         // Check a system property to see if there is a specific toolkit to use.
218         // This is not a doPriviledged check so that applets cannot use this.
219         String forcedToolkit = null;
220         try {
221             forcedToolkit = System.getProperty(&quot;javafx.toolkit&quot;);
222         } catch (SecurityException ex) {}
223 
224         if (forcedToolkit == null) {
225             forcedToolkit = tk;
226         }
227         if (forcedToolkit == null) {
228             userSpecifiedToolkit = false;
229             forcedToolkit = getDefaultToolkit();
230         }
231 
232         if (forcedToolkit.indexOf(&#39;.&#39;) == -1) {
233             // Turn a short name into a fully qualified classname
234             forcedToolkit = lookupToolkitClass(forcedToolkit);
235         }
236 
237         boolean printToolkit = verbose
238                 || (userSpecifiedToolkit &amp;&amp; !forcedToolkit.endsWith(&quot;StubToolkit&quot;));
239 
240         try {
241             Class clz = null;
242 
243             try {
244                 // try our priveledged loader first
245                 final ClassLoader loader = Toolkit.class.getClassLoader();
246                 clz = Class.forName(forcedToolkit, false, loader);
247             } catch (ClassNotFoundException e) {
248                 // fall back and try the application class loader
249                 final ClassLoader loader = Thread.currentThread().getContextClassLoader();
250                 clz = Class.forName(forcedToolkit, false, loader);
251             }
252 
253             // Check that clz is a subclass of Toolkit
254             if (!Toolkit.class.isAssignableFrom(clz)) {
255                 throw new IllegalArgumentException(&quot;Unrecognized FX Toolkit class: &quot;
256                         + forcedToolkit);
257             }
258 
259             TOOLKIT = (Toolkit)clz.newInstance();
260             if (TOOLKIT.init()) {
261                 if (printToolkit) {
262                     System.err.println(&quot;JavaFX: using &quot; + forcedToolkit);
263                 }
264                 return TOOLKIT;
265             }
266             TOOLKIT = null;
267         } catch (Exception any) {
268             TOOLKIT = null;
269             any.printStackTrace();
270         }
271 
272         throw new RuntimeException(&quot;No toolkit found&quot;);
273     }
274 
275     protected static Thread getFxUserThread() {
276         return fxUserThread;
277     }
278 
279     protected static void setFxUserThread(Thread t) {
280         if (fxUserThread != null) {
281             throw new IllegalStateException(&quot;Error: FX User Thread already initialized&quot;);
282         }
283 
284         fxUserThread = t;
285     }
286 
287     public void checkFxUserThread() {
288         // Throw exception if not on FX user thread
289         if (!isFxUserThread()) {
290             throw new IllegalStateException(&quot;Not on FX application thread; currentThread = &quot;
291                     + Thread.currentThread().getName());
292         }
293     }
294 
295     // Toolkit can override this if needed
296     public boolean isFxUserThread() {
297         return Thread.currentThread() == fxUserThread;
298     }
299 
300     protected Toolkit() {
301     }
302 
303     public abstract boolean init();
304 
305     /**
306      * Indicates whether or not a nested event loop can be started
307      * from the current thread in the current state. Note that a nested
308      * event loop is not allowed outside of an event handler.
309      *
310      * @return flag indicating whether a nested event loop can be started.
311      */
312     public abstract boolean canStartNestedEventLoop();
313 
314     /**
315      * Enter a nested event loop and block until the corresponding
316      * exitNestedEventLoop call is made.
317      * The key passed into this method is used to
318      * uniquely identify the matched enter/exit pair. This method creates a
319      * new nested event loop and blocks until the corresponding
320      * exitNestedEventLoop method is called with the same key.
321      * The return value of this method will be the {@code rval}
322      * object supplied to the exitNestedEventLoop method call that unblocks it.
323      *
324      * @param key the Object that identifies the nested event loop, which
325      * must not be null
326      *
327      * @throws IllegalArgumentException if the specified key is associated
328      * with a nested event loop that has not yet returned
329      *
330      * @throws NullPointerException if the key is null
331      *
332      * @throws IllegalStateException if this method is called on a thread
333      * other than the FX Application thread
334      *
335      * @return the value passed into the corresponding call to exitEventLoop
336      */
337     public abstract Object enterNestedEventLoop(Object key);
338 
339     /**
340      * Exit a nested event loop and unblock the caller of the
341      * corresponding enterNestedEventLoop.
342      * The key passed into this method is used to
343      * uniquely identify the matched enter/exit pair. This method causes the
344      * nested event loop that was previously created with the key to exit and
345      * return control to the caller. If the specified nested event loop is not
346      * the inner-most loop then it will not return until all other inner loops
347      * also exit.
348      *
349      * @param key the Object that identifies the nested event loop, which
350      * must not be null
351      *
352      * @param rval an Object that is returned to the caller of the
353      * corresponding enterNestedEventLoop. This may be null.
354      *
355      * @throws IllegalArgumentException if the specified key is not associated
356      * with an active nested event loop
357      *
358      * @throws NullPointerException if the key is null
359      *
360      * @throws IllegalStateException if this method is called on a thread
361      * other than the FX Application thread
362      */
363     public abstract void exitNestedEventLoop(Object key, Object rval);
364 
365     public abstract void exitAllNestedEventLoops();
366 
367     public abstract boolean isNestedLoopRunning();
368 
369     public abstract TKStage createTKStage(Window peerWindow, boolean securityDialog, StageStyle stageStyle, boolean primary, Modality modality, TKStage owner, boolean rtl, AccessControlContext acc);
370 
371     public abstract TKStage createTKPopupStage(Window peerWindow, StageStyle popupStyle, TKStage owner, AccessControlContext acc);
372     public abstract TKStage createTKEmbeddedStage(HostInterface host, AccessControlContext acc);
373 
374     /**
375      * Creates an AppletWindow using the provided window pointer as the parent
376      * window.
377      *
378      * @param parent the native parent which will contain the primary stage
379      * window(s). Used on Windows/Linux platforms.
380      *
381      * @param serverName the name of CARemoteLayerServer which
382      * will be used to register native layer. Used on Mac platform.
383      */
384     public abstract AppletWindow createAppletWindow(long parent, String serverName);
385 
386     /**
387      * Perform cleanup in preparation for applet termination, including closing
388      * the applet window.
389      */
390     public abstract void closeAppletWindow();
391 
392     private final Map&lt;TKPulseListener,AccessControlContext&gt; stagePulseListeners =
393             new WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();
394     private final Map&lt;TKPulseListener,AccessControlContext&gt; scenePulseListeners =
395             new WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();
396     private final Map&lt;TKPulseListener,AccessControlContext&gt; postScenePulseListeners =
397             new WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();
398     private final Map&lt;TKListener,AccessControlContext&gt; toolkitListeners =
399             new WeakHashMap&lt;TKListener,AccessControlContext&gt;();
400 
401     // The set of shutdown hooks is strongly held to avoid premature GC.
402     private final Set&lt;Runnable&gt; shutdownHooks = new HashSet&lt;Runnable&gt;();
403 
404     private void runPulse(final TKPulseListener listener,
405             final AccessControlContext acc) {
406 
407         if (acc == null) {
408             throw new IllegalStateException(&quot;Invalid AccessControlContext&quot;);
409         }
410 
411         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
412             listener.pulse();
413             return null;
414         }, acc);
415     }
416 
417     public void firePulse() {
418         // Stages need to be notified of pulses before scenes so the Stage can resized
419         // and those changes propogated to scene before it gets its pulse to update
420 
421         // Copy of listener map
422         final Map&lt;TKPulseListener,AccessControlContext&gt; stagePulseList =
423                 new WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();
424         final Map&lt;TKPulseListener,AccessControlContext&gt; scenePulseList =
425                 new WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();
426         final Map&lt;TKPulseListener,AccessControlContext&gt; postScenePulseList =
427                 new WeakHashMap&lt;TKPulseListener,AccessControlContext&gt;();
428 
429         synchronized (this) {
430             stagePulseList.putAll(stagePulseListeners);
431             scenePulseList.putAll(scenePulseListeners);
432             postScenePulseList.putAll(postScenePulseListeners);
433         }
434         for (Map.Entry&lt;TKPulseListener,AccessControlContext&gt; entry : stagePulseList.entrySet()) {
435             runPulse(entry.getKey(), entry.getValue());
436         }
437         for (Map.Entry&lt;TKPulseListener,AccessControlContext&gt; entry : scenePulseList.entrySet()) {
438             runPulse(entry.getKey(), entry.getValue());
439         }
440         for (Map.Entry&lt;TKPulseListener,AccessControlContext&gt; entry : postScenePulseList.entrySet()) {
441             runPulse(entry.getKey(), entry.getValue());
442         }
443 
444         if (lastTkPulseListener != null) {
445             runPulse(lastTkPulseListener, lastTkPulseAcc);
446         }
447     }
448     public void addStageTkPulseListener(TKPulseListener listener) {
449         if (listener == null) {
450             return;
451         }
452         synchronized (this) {
453             AccessControlContext acc = AccessController.getContext();
454             stagePulseListeners.put(listener, acc);
455         }
456     }
457     public void removeStageTkPulseListener(TKPulseListener listener) {
458         synchronized (this) {
459             stagePulseListeners.remove(listener);
460         }
461     }
462     public void addSceneTkPulseListener(TKPulseListener listener) {
463         if (listener == null) {
464             return;
465         }
466         synchronized (this) {
467             AccessControlContext acc = AccessController.getContext();
468             scenePulseListeners.put(listener, acc);
469         }
470     }
471     public void removeSceneTkPulseListener(TKPulseListener listener) {
472         synchronized (this) {
473             scenePulseListeners.remove(listener);
474         }
475     }
476     public void addPostSceneTkPulseListener(TKPulseListener listener) {
477         if (listener == null) {
478             return;
479         }
480         synchronized (this) {
481             AccessControlContext acc = AccessController.getContext();
482             postScenePulseListeners.put(listener, acc);
483         }
484     }
485     public void removePostSceneTkPulseListener(TKPulseListener listener) {
486         synchronized (this) {
487             postScenePulseListeners.remove(listener);
488         }
489     }
490 
491     public void addTkListener(TKListener listener) {
492         if (listener == null) {
493             return;
494         }
495         AccessControlContext acc = AccessController.getContext();
496         toolkitListeners.put(listener, acc);
497     }
498 
499     public void removeTkListener(TKListener listener) {
500         toolkitListeners.remove(listener);
501     }
502 
503     private TKPulseListener lastTkPulseListener = null;
504     private AccessControlContext lastTkPulseAcc = null;
505     public void setLastTkPulseListener(TKPulseListener listener) {
506         lastTkPulseAcc = AccessController.getContext();
507         lastTkPulseListener = listener;
508     }
509 
510     public void addShutdownHook(Runnable hook) {
511         if (hook == null) {
512             return;
513         }
514         synchronized (shutdownHooks) {
515             shutdownHooks.add(hook);
516         }
517     }
518 
519     public void removeShutdownHook(Runnable hook) {
520         synchronized (shutdownHooks) {
521             shutdownHooks.remove(hook);
522         }
523     }
524 
525     protected void notifyShutdownHooks() {
526         List&lt;Runnable&gt; hooks;
527         synchronized (shutdownHooks) {
528             hooks = new ArrayList&lt;Runnable&gt;(shutdownHooks);
529             shutdownHooks.clear();
530         }
531 
532         for (Runnable hook : hooks) {
533             hook.run();
534         }
535     }
536 
537     public void notifyWindowListeners(final List&lt;TKStage&gt; windows) {
538         for (Map.Entry&lt;TKListener,AccessControlContext&gt; entry : toolkitListeners.entrySet()) {
539             final TKListener listener = entry.getKey();
540             final AccessControlContext acc = entry.getValue();
541             if (acc == null) {
542                 throw new IllegalStateException(&quot;Invalid AccessControlContext&quot;);
543             }
544 
545             AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
546                 listener.changedTopLevelWindows(windows);
547                 return null;
548             }, acc);
549         }
550     }
551 
552     public void notifyLastNestedLoopExited() {
553         for (TKListener listener: toolkitListeners.keySet()) {
554             listener.exitedLastNestedLoop();
555         }
556     }
557 
558     // notify the pulse timer code that we need the next pulse to happen
559     // this flag is cleared each cycle so subsequent pulses must be requested
560     public abstract void requestNextPulse();
561 
562     public abstract Future addRenderJob(RenderJob rj);
563 
564     public abstract ImageLoader loadImage(String url,
565                                           double width, double height,
566                                           boolean preserveRatio,
567                                           boolean smooth);
568     public abstract ImageLoader loadImage(InputStream stream,
569                                           double width, double height,
570                                           boolean preserveRatio,
571                                           boolean smooth);
572     public abstract AsyncOperation loadImageAsync(
573                                           AsyncOperationListener&lt;? extends ImageLoader&gt; listener,
574                                           String url,
575                                           double width, double height,
576                                           boolean preserveRatio,
577                                           boolean smooth);
578 
579     /*
580      * The loadPlatformImage method supports the following image types:
581      *   - an object returned by the renderToImage method
582      *   - an instance of com.sun.prism.Image (in case of prism)
583      *   - an instance of an external image object, which can be a BufferedImage
584      * If JavaFX Image had one more constructor Image(ImageLoader),
585      * we could introduce a different method for external image loading support.
586      */
587 
588     public abstract ImageLoader loadPlatformImage(Object platformImage);
589 
590     public abstract PlatformImage createPlatformImage(int w, int h);
591 
592     // Indicates the default state of smooth for ImageView and MediaView
593     // Subclasses may override this to provide a platform-specific default
594     public boolean getDefaultImageSmooth() { return true; }
595 
596     public abstract void startup(Runnable runnable);
597     public abstract void defer(Runnable runnable);
598     public void exit() {
599         fxUserThread = null;
600     }
601 
602     public abstract Map&lt;Object, Object&gt; getContextMap();
603     public abstract int getRefreshRate();
604     public abstract void setAnimationRunnable(DelayedRunnable animationRunnable);
605     public abstract PerformanceTracker getPerformanceTracker();
606     public abstract PerformanceTracker createPerformanceTracker();
607 
608     //to be used for testing only
609     public abstract void waitFor(Task t);
610 
611     private Object checkSingleColor(List&lt;Stop&gt; stops) {
612         if (stops.size() == 2) {
613             Color c = stops.get(0).getColor();
614             if (c.equals(stops.get(1).getColor())) {
615                 return Toolkit.getPaintAccessor().getPlatformPaint(c);
616             }
617         }
618         return null;
619     }
620 
621     private Object getPaint(LinearGradient paint) {
622         Object p = gradientMap.get(paint);
623         if (p != null) {
624             return p;
625         }
626         p = checkSingleColor(paint.getStops());
627         if (p == null) {
628             p = createLinearGradientPaint(paint);
629         }
630         gradientMap.put(paint, p);
631         return p;
632     }
633 
634     private Object getPaint(RadialGradient paint) {
635         Object p = gradientMap.get(paint);
636         if (p != null) {
637             return p;
638         }
639         p = checkSingleColor(paint.getStops());
640         if (p == null) {
641             p = createRadialGradientPaint(paint);
642         }
643         gradientMap.put(paint, p);
644         return p;
645     }
646 
647     public Object getPaint(Paint paint) {
648         if (paint instanceof Color) {
649             return createColorPaint((Color) paint);
650         }
651 
652         if (paint instanceof LinearGradient) {
653             return getPaint((LinearGradient) paint);
654         }
655 
656         if (paint instanceof RadialGradient) {
657             return getPaint((RadialGradient) paint);
658         }
659 
660         if (paint instanceof ImagePattern) {
661             return createImagePatternPaint((ImagePattern) paint);
662         }
663 
664         return null;
665     }
666 
667     protected static final double clampStopOffset(double offset) {
668         return (offset &gt; 1.0) ? 1.0 :
669                (offset &lt; 0.0) ? 0.0 : offset;
670     }
671 
672     protected abstract Object createColorPaint(Color paint);
673     protected abstract Object createLinearGradientPaint(LinearGradient paint);
674     protected abstract Object createRadialGradientPaint(RadialGradient paint);
675     protected abstract Object createImagePatternPaint(ImagePattern paint);
676 
677     public abstract void
678         accumulateStrokeBounds(com.sun.javafx.geom.Shape shape,
679                                float bbox[],
680                                StrokeType type,
681                                double strokewidth,
682                                StrokeLineCap cap,
683                                StrokeLineJoin join,
684                                float miterLimit,
685                                BaseTransform tx);
686 
687     public abstract boolean
688         strokeContains(com.sun.javafx.geom.Shape shape,
689                        double x, double y,
690                        StrokeType type,
691                        double strokewidth,
692                        StrokeLineCap cap,
693                        StrokeLineJoin join,
694                        float miterLimit);
695 
696     public abstract com.sun.javafx.geom.Shape
697         createStrokedShape(com.sun.javafx.geom.Shape shape,
698                            StrokeType type,
699                            double strokewidth,
700                            StrokeLineCap cap,
701                            StrokeLineJoin join,
702                            float miterLimit,
703                            float[] dashArray,
704                            float dashOffset);
705 
706     public abstract int getKeyCodeForChar(String character);
707     public abstract Dimension2D getBestCursorSize(int preferredWidth, int preferredHeight);
708     public abstract int getMaximumCursorColors();
709     public abstract PathElement[] convertShapeToFXPath(Object shape);
710 
711     public abstract Filterable toFilterable(Image img);
712     public abstract FilterContext getFilterContext(Object config);
713 
714     public abstract boolean isForwardTraversalKey(KeyEvent e);
715     public abstract boolean isBackwardTraversalKey(KeyEvent e);
716 
717     public abstract AbstractMasterTimer getMasterTimer();
718 
719     public abstract FontLoader getFontLoader();
720     public abstract TextLayoutFactory getTextLayoutFactory();
721 
722     public abstract Object createSVGPathObject(SVGPath svgpath);
723     public abstract Path2D createSVGPath2D(SVGPath svgpath);
724 
725     /**
726      * Tests whether the pixel on the given coordinates in the given image
727      * is non-empty (not fully transparent). Return value is not defined
728      * for pixels out of the image bounds.
729      */
730     public abstract boolean imageContains(Object image, float x, float y);
731 
732     public abstract TKClipboard getSystemClipboard();
733 
734     public TKClipboard createLocalClipboard() {
735         return new LocalClipboard();
736     }
737 
738     public abstract TKSystemMenu getSystemMenu();
739 
740     public abstract TKClipboard getNamedClipboard(String name);
741 
742     public boolean isSupported(ConditionalFeature feature) { return false; }
743 
744     public boolean isMSAASupported() { return false; }
745 
746     public abstract ScreenConfigurationAccessor setScreenConfigurationListener(TKScreenConfigurationListener listener);
747 
748     public abstract Object getPrimaryScreen();
749 
750     public abstract List&lt;?&gt; getScreens();
751 
752     public abstract ScreenConfigurationAccessor getScreenConfigurationAccessor();
753 
754     public abstract void registerDragGestureListener(TKScene s, Set&lt;TransferMode&gt; tm, TKDragGestureListener l);
755 
756     /**
757      * This function is called when a drag originates within a JavaFX application.
758      * This means that drags that originate in other applications / from the OS
759      * do not call this function.
760      * The argument o represents an object used to identify a scene on which
761      * the drag has started.
762      */
763     public abstract void startDrag(TKScene scene, Set&lt;TransferMode&gt; tm, TKDragSourceListener l, Dragboard dragboard);
764 
765     // template function which can be implemented by toolkit impls such that they
766     // can be informed when a drag and drop operation has completed. This allows
767     // for any cleanup that may need to be done.
768     public void stopDrag(Dragboard dragboard) {
769         // no-op
770     }
771 
772     public abstract void enableDrop(TKScene s, TKDropTargetListener l);
773 
774     public interface Task {
775         boolean isFinished();
776     }
777 
778     public Color4f toColor4f(Color color) {
779         return new Color4f((float)color.getRed(), (float)color.getGreen(), (float)color.getBlue(), (float)color.getOpacity());
780     }
781 
782 
783     public ShadowMode toShadowMode(BlurType blurType) {
784         switch (blurType) {
785             case ONE_PASS_BOX:
786                 return ShadowMode.ONE_PASS_BOX;
787             case TWO_PASS_BOX:
788                 return ShadowMode.TWO_PASS_BOX;
789             case THREE_PASS_BOX:
790                 return ShadowMode.THREE_PASS_BOX;
791             default:
792                 return ShadowMode.GAUSSIAN;
793         }
794     }
795 
796     public abstract void installInputMethodRequests(TKScene scene, InputMethodRequests requests);
797 
798     /*
799      * ImageRenderingContext holds the many parameters passed to
800      * the renderToImage method.
801      * The use of the parameters is specified by the renderToImage
802      * method.
803      * @see #renderToImage
804      */
805     public static class ImageRenderingContext {
806         // Node to be rendered
807         public NGNode root;
808 
809         // Viewport for rendering
810         public int x;
811         public int y;
812         public int width;
813         public int height;
814 
815         // Initial transform for root node
816         public BaseTransform transform;
817 
818         // Rendering parameters either from Scene or SnapShotParams
819         public boolean depthBuffer;
820         public Object platformPaint;
821         public NGCamera camera;
822         public NGLightBase[] lights;
823 
824         // PlatformImage into which to render or null
825         public Object platformImage;
826     }
827 
828     /*
829      * This method renders a PG-graph to a platform image object.
830      * The returned object can be turned into a useable
831      * scene graph image using the appropriate factor of the
832      * Image class.
833      * The scale specified in the params is used to scale the
834      * entire rendering before any transforms in the nodes are
835      * applied.
836      * The width and height specified in the params represent
837      * the user space dimensions to be rendered.  The returned
838      * image will be large enough to hold these dimensions
839      * scaled by the scale parameter.
840      * The depthBuffer specified in the params is used to determine
841      * with or without depthBuffer rendering should be performed.
842      * The root node is the root of a tree of toolkit-specific
843      * scene graph peer nodes to be rendered and should have
844      * been previously created by this toolkit.
845      * The platformPaint specified in the params must be
846      * generated by the appropriate Toolkit.createPaint method
847      * and is used to fill the background of the image before
848      * rendering the scene graph.
849      * The platformImage specified in the params may be non-null
850      * and should be a previous return value from this method.
851      * If it is non-null then it may be reused as the return value
852      * of this method if it is still valid and large enough to
853      * hold the requested size.
854      *
855      * @param context a ImageRenderingContext instance specifying
856      *               the various rendering parameters
857      * @return a platform specific image object
858      * @see Toolkit.getImageAccessor().fromPlatformImage
859      */
860 
861     public abstract Object renderToImage(ImageRenderingContext context);
862 
863     /**
864      * Returns the key code for the key which is commonly used on the
865      * corresponding platform as a modifier key in shortcuts. For example
866      * it is {@code KeyCode.CONTROL} on Windows (Ctrl + C, Ctrl + V ...) and
867      * {@code KeyCode.META} on MacOS (Cmd + C, Cmd + V ...).
868      *
869      * @return the key code for shortcut modifier key
870      */
871     public KeyCode getPlatformShortcutKey() {
872         return PlatformUtil.isMac() ? KeyCode.META : KeyCode.CONTROL;
873     }
874 
875     public abstract FileChooserResult showFileChooser(
876             TKStage ownerWindow,
877             String title,
878             File initialDirectory,
879             String initialFileName,
880             FileChooserType fileChooserType,
881             List&lt;ExtensionFilter&gt; extensionFilters,
882             ExtensionFilter selectedFilter);
883 
884     public abstract File showDirectoryChooser(
885             TKStage ownerWindow,
886             String title,
887             File initialDirectory);
888 
889     /*
890      * Methods for obtaining &quot;double-click&quot; speed value.
891      */
892     public abstract long getMultiClickTime();
893     public abstract int getMultiClickMaxX();
894     public abstract int getMultiClickMaxY();
895 
896     private CountDownLatch pauseScenesLatch = null;
897 
898     public interface WritableImageAccessor {
899         public void loadTkImage(WritableImage wimg, Object loader);
900         public Object getTkImageLoader(WritableImage wimg);
901     }
902 
903     private static WritableImageAccessor writableImageAccessor = null;
904 
905     public static void setWritableImageAccessor(WritableImageAccessor accessor) {
906         writableImageAccessor = accessor;
907     }
908 
909     public static WritableImageAccessor getWritableImageAccessor() {
910         return writableImageAccessor;
911     }
912 
913     public interface PaintAccessor {
914         public boolean isMutable(Paint paint);
915         public Object getPlatformPaint(Paint paint);
916         public void addListener(Paint paint, AbstractNotifyListener platformChangeListener);
917         public void removeListener(Paint paint, AbstractNotifyListener platformChangeListener);
918     }
919 
920     private static PaintAccessor paintAccessor = null;
921 
922     public static void setPaintAccessor(PaintAccessor accessor) {
923         paintAccessor = accessor;
924     }
925 
926     public static PaintAccessor getPaintAccessor() {
927         return paintAccessor;
928     }
929 
930     public interface ImageAccessor {
931         public boolean isAnimation(Image image);
932         public ReadOnlyObjectProperty&lt;PlatformImage&gt;getImageProperty(Image image);
933         public int[] getPreColors(PixelFormat&lt;ByteBuffer&gt; pf);
934         public int[] getNonPreColors(PixelFormat&lt;ByteBuffer&gt; pf);
935         public Object getPlatformImage(Image image);
936         public Image fromPlatformImage(Object image);
937     }
938 
939     private static ImageAccessor imageAccessor;
940 
941     static {
942         // Need to ensure that the Image class is loaded since Toolkit class
943         // is the provider of getImageAccessor method and sets the accessor.
944         Utils.forceInit(Image.class);
945     }
946 
947     public static void setImageAccessor(ImageAccessor accessor) {
948         imageAccessor = accessor;
949     }
950 
951     public static ImageAccessor getImageAccessor() {
952         return imageAccessor;
953     }
954 
955     public String getThemeName() {
956         return null;
957     }
958 
959     public abstract GlassRobot createRobot();
960 }
    </pre>
  </body>
</html>
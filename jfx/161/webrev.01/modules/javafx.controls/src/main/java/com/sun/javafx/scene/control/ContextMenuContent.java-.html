<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/ContextMenuContent.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.javafx.scene.control;
  27 
  28 import com.sun.javafx.scene.NodeHelper;
  29 import com.sun.javafx.scene.control.behavior.TwoLevelFocusPopupBehavior;
  30 import com.sun.javafx.scene.control.skin.Utils;
  31 import com.sun.javafx.scene.traversal.Direction;
  32 import javafx.animation.Animation.Status;
  33 import javafx.animation.KeyFrame;
  34 import javafx.animation.Timeline;
  35 import javafx.beans.InvalidationListener;
  36 import javafx.beans.WeakInvalidationListener;
  37 import javafx.beans.property.ReadOnlyBooleanProperty;
  38 import javafx.beans.value.ChangeListener;
  39 import javafx.beans.value.ObservableValue;
  40 import javafx.collections.ListChangeListener;
  41 import javafx.collections.ObservableList;
  42 import javafx.css.CssMetaData;
  43 import javafx.css.PseudoClass;
  44 import javafx.css.Styleable;
  45 import javafx.event.ActionEvent;
  46 import javafx.event.EventHandler;
  47 import javafx.geometry.*;
  48 import javafx.scene.AccessibleAction;
  49 import javafx.scene.AccessibleAttribute;
  50 import javafx.scene.AccessibleRole;
  51 import javafx.scene.Node;
  52 import javafx.scene.Parent;
  53 import javafx.scene.control.*;
  54 import javafx.scene.input.KeyEvent;
  55 import javafx.scene.input.MouseEvent;
  56 import javafx.scene.input.ScrollEvent;
  57 import javafx.scene.layout.Region;
  58 import javafx.scene.layout.StackPane;
  59 import javafx.scene.layout.VBox;
  60 import javafx.scene.shape.Rectangle;
  61 import javafx.stage.Window;
  62 import javafx.util.Duration;
  63 
  64 import java.util.ArrayList;
  65 import java.util.Collections;
  66 import java.util.List;
  67 import java.util.Optional;
  68 
  69 /**
  70  * This is a the SkinBase for ContextMenu based controls so that the CSS parts
  71  * work right, because otherwise we would have to copy the Keys from there to here.
  72  */
  73 public class ContextMenuContent extends Region {
  74 
  75     private static final String ITEM_STYLE_CLASS_LISTENER = &quot;itemStyleClassListener&quot;;
  76 
  77     private ContextMenu contextMenu;
  78 
  79     /***************************************************************************
  80      * UI subcomponents
  81      **************************************************************************/
  82 
  83     private double maxGraphicWidth = 0; // we keep this margin to left for graphic
  84     private double maxRightWidth = 0;
  85     private double maxLabelWidth = 0;
  86     private double maxRowHeight = 0;
  87     private double maxLeftWidth = 0;
  88     private double oldWidth = 0;
  89 
  90     private Rectangle clipRect;
  91     MenuBox itemsContainer;
  92     private ArrowMenuItem upArrow;
  93     private ArrowMenuItem downArrow;
  94 
  95     /*
  96      * We maintain a current focused index which is used
  97      * in keyboard navigation of menu items.
  98      */
  99     private int currentFocusedIndex = -1;
 100 
 101     private boolean itemsDirty = true;
 102     private InvalidationListener popupShowingListener = arg0 -&gt; {
 103         updateItems();
 104     };
 105     private WeakInvalidationListener weakPopupShowingListener =
 106             new WeakInvalidationListener(popupShowingListener);
 107 
 108 
 109     /***************************************************************************
 110      * Constructors
 111      **************************************************************************/
 112     public ContextMenuContent(final ContextMenu popupMenu) {
 113         this.contextMenu = popupMenu;
 114         clipRect = new Rectangle();
 115          clipRect.setSmooth(false);
 116         itemsContainer = new MenuBox();
 117 //        itemsContainer = new VBox();
 118         itemsContainer.setClip(clipRect);
 119 
 120         upArrow = new ArrowMenuItem(this);
 121         upArrow.setUp(true);
 122         upArrow.setFocusTraversable(false);
 123 
 124         downArrow = new ArrowMenuItem(this);
 125         downArrow.setUp(false);
 126         downArrow.setFocusTraversable(false);
 127         getChildren().add(itemsContainer);
 128         getChildren().add(upArrow);
 129         getChildren().add(downArrow);
 130         initialize();
 131         setUpBinds();
 132         updateItems();
 133         // RT-20197 add menuitems only on first show.
 134         popupMenu.showingProperty().addListener(weakPopupShowingListener);
 135 
 136         /*
 137         ** only add this if we&#39;re on an embedded
 138         ** platform that supports 5-button navigation
 139         */
 140         if (Utils.isTwoLevelFocus()) {
 141             new TwoLevelFocusPopupBehavior(this);
 142         }
 143     }
 144 
 145     //For access from controls
 146     public VBox getItemsContainer() {
 147         return itemsContainer;
 148     }
 149     //For testing purpose only
 150     int getCurrentFocusIndex() {
 151         return currentFocusedIndex;
 152     }
 153     //For testing purpose only
 154     void setCurrentFocusedIndex(int index) {
 155         if (index &lt; itemsContainer.getChildren().size()) {
 156             currentFocusedIndex = index;
 157         }
 158     }
 159 
 160     private void updateItems() {
 161         if (itemsDirty) {
 162             updateVisualItems();
 163             itemsDirty = false;
 164         }
 165     }
 166 
 167     private void computeVisualMetrics() {
 168         maxRightWidth = 0;
 169         maxLabelWidth = 0;
 170         maxRowHeight = 0;
 171         maxGraphicWidth = 0;
 172         maxLeftWidth = 0;
 173 
 174         for (int i = 0; i &lt; itemsContainer.getChildren().size(); i++) {
 175             Node child = itemsContainer.getChildren().get(i);
 176             if (child instanceof MenuItemContainer) {
 177                 final MenuItemContainer menuItemContainer = (MenuItemContainer)itemsContainer.getChildren().get(i);
 178 
 179                 if (! menuItemContainer.isVisible()) continue;
 180 
 181                 double alt = -1;
 182                 Node n = menuItemContainer.left;
 183                 if (n != null) {
 184                     if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
 185                         alt = snapSizeY(n.prefHeight(-1));
 186                     } else alt = -1;
 187                     maxLeftWidth = Math.max(maxLeftWidth, snapSizeX(n.prefWidth(alt)));
 188                     maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
 189                 }
 190 
 191                 n = menuItemContainer.graphic;
 192                 if (n != null) {
 193                     if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
 194                         alt = snapSizeY(n.prefHeight(-1));
 195                     } else alt = -1;
 196                     maxGraphicWidth = Math.max(maxGraphicWidth, snapSizeX(n.prefWidth(alt)));
 197                     maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
 198                 }
 199 
 200                 n = menuItemContainer.label;
 201                 if (n != null) {
 202                     if (n.getContentBias() == Orientation.VERTICAL) {
 203                         alt = snapSizeY(n.prefHeight(-1));
 204                     } else alt = -1;
 205                     maxLabelWidth = Math.max(maxLabelWidth, snapSizeX(n.prefWidth(alt)));
 206                     maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
 207                 }
 208 
 209                 n = menuItemContainer.right;
 210                 if (n != null) {
 211                     if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
 212                         alt = snapSizeY(n.prefHeight(-1));
 213                     } else alt = -1;
 214                     maxRightWidth = Math.max(maxRightWidth, snapSizeX(n.prefWidth(alt)));
 215                     maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
 216                 }
 217             }
 218         }
 219 
 220         // Fix for RT-38838.
 221         // This fixes the issue where CSS is applied to a menu after it has been
 222         // showing, resulting in its bounds changing. In this case, we need to
 223         // shift the submenu such that it is properly aligned with its parent menu.
 224         //
 225         // To do this, we must firstly determine if the open submenu is shifted
 226         // horizontally to appear on the other side of this menu, as this is the
 227         // only situation where shifting has to happen. If so, we need to check
 228         // if we should shift the submenu due to changes in width.
 229         //
 230         // We need to get the parent menu of this contextMenu, so that we only
 231         // modify the X value in the following conditions:
 232         // 1) There exists a parent menu
 233         // 2) The parent menu is in the correct position (i.e. to the left of this
 234         //    menu in normal LTR systems).
 235         final double newWidth = maxRightWidth + maxLabelWidth + maxGraphicWidth + maxLeftWidth;
 236         Window ownerWindow = contextMenu.getOwnerWindow();
 237         if (ownerWindow instanceof ContextMenu) {
 238             if (contextMenu.getX() &lt; ownerWindow.getX()) {
 239                 if (oldWidth != newWidth) {
 240                     contextMenu.setX(contextMenu.getX() + oldWidth - newWidth);
 241                 }
 242             }
 243         }
 244 
 245         oldWidth = newWidth;
 246     }
 247 
 248     private void updateVisualItems() {
 249         ObservableList&lt;Node&gt; itemsContainerChilder = itemsContainer.getChildren();
 250 
 251         disposeVisualItems();
 252 
 253         for (int row = 0; row &lt; getItems().size(); row++) {
 254             final MenuItem item = getItems().get(row);
 255             if (item instanceof CustomMenuItem &amp;&amp; ((CustomMenuItem) item).getContent() == null) {
 256                 continue;
 257             }
 258 
 259             if (item instanceof SeparatorMenuItem) {
 260                 // we don&#39;t want the hover highlight for separators, so for
 261                 // now this is the simplest approach - just remove the
 262                 // background entirely. This may cause issues if people
 263                 // intend to style the background differently.
 264                 Node node = ((CustomMenuItem) item).getContent();
 265                 node.visibleProperty().bind(item.visibleProperty());
 266                 itemsContainerChilder.add(node);
 267                 // Add the (separator) menu item to properties map of this node.
 268                 // Special casing this for separator :
 269                 // This allows associating this container with SeparatorMenuItem.
 270                 node.getProperties().put(MenuItem.class, item);
 271             } else {
 272                 MenuItemContainer menuItemContainer = new MenuItemContainer(item);
 273                 menuItemContainer.visibleProperty().bind(item.visibleProperty());
 274                 itemsContainerChilder.add(menuItemContainer);
 275             }
 276         }
 277 
 278         // Add the Menu to properties map of this skin. Used by QA for testing
 279         // This enables associating a parent menu for this skin showing menu items.
 280         if (getItems().size() &gt; 0) {
 281             final MenuItem item = getItems().get(0);
 282             getProperties().put(Menu.class, item.getParentMenu());
 283         }
 284 
 285         // RT-36513 made this applyCss(). Modified by RT-36995 to NodeHelper.reapplyCSS()
 286         NodeHelper.reapplyCSS(this);
 287     }
 288 
 289     private void disposeVisualItems() {
 290         // clean up itemsContainer
 291         ObservableList&lt;Node&gt; itemsContainerChilder = itemsContainer.getChildren();
 292         for (int i = 0, max = itemsContainerChilder.size(); i &lt; max; i++) {
 293             Node n = itemsContainerChilder.get(i);
 294 
 295             if (n instanceof MenuItemContainer) {
 296                 MenuItemContainer container = (MenuItemContainer) n;
 297                 container.visibleProperty().unbind();
 298                 container.dispose();
 299             }
 300         }
 301         itemsContainerChilder.clear();
 302     }
 303 
 304     /**
 305      * Can be called by Skins when they need to clean up the content of any
 306      * ContextMenu instances they might have created. This ensures that contents
 307      * of submenus if any, also get cleaned up.
 308      */
 309     public void dispose() {
 310         disposeBinds();
 311         disposeVisualItems();
 312 
 313         disposeContextMenu(submenu);
 314         submenu = null;
 315         openSubmenu = null;
 316         selectedBackground = null;
 317         if (contextMenu != null) {
 318             contextMenu.getItems().clear();
 319             contextMenu = null;
 320         }
 321     }
 322 
 323     public void disposeContextMenu(ContextMenu menu) {
 324         if (menu == null) return;
 325 
 326         Skin&lt;?&gt; skin = menu.getSkin();
 327         if (skin == null) return;
 328 
 329         ContextMenuContent cmContent = (ContextMenuContent)skin.getNode();
 330         if (cmContent == null) return;
 331 
 332         cmContent.dispose(); // recursive call to dispose submenus.
 333     }
 334 
 335     @Override protected void layoutChildren() {
 336         if (itemsContainer.getChildren().size() == 0) return;
 337         final double x = snappedLeftInset();
 338         final double y = snappedTopInset();
 339         final double w = getWidth() - x - snappedRightInset();
 340         final double h = getHeight() - y - snappedBottomInset();
 341         final double contentHeight =  snapSizeY(getContentHeight()); // itemsContainer.prefHeight(-1);
 342 
 343         itemsContainer.resize(w,contentHeight);
 344         itemsContainer.relocate(x, y);
 345 
 346         if (isFirstShow &amp;&amp; ty == 0) {
 347             upArrow.setVisible(false);
 348             isFirstShow = false;
 349         } else {
 350             upArrow.setVisible(ty &lt; y &amp;&amp; ty &lt; 0);
 351         }
 352         downArrow.setVisible(ty + contentHeight &gt; (y + h));
 353 
 354         clipRect.setX(0);
 355         clipRect.setY(0);
 356         clipRect.setWidth(w);
 357         clipRect.setHeight(h);
 358 
 359         if (upArrow.isVisible()) {
 360             final double prefHeight = snapSizeY(upArrow.prefHeight(-1));
 361             clipRect.setHeight(snapSizeY(clipRect.getHeight() - prefHeight));
 362             clipRect.setY(snapSizeY(clipRect.getY()) + prefHeight);
 363             upArrow.resize(snapSizeX(upArrow.prefWidth(-1)), prefHeight);
 364             positionInArea(upArrow, x, y, w, prefHeight, /*baseline ignored*/0,
 365                     HPos.CENTER, VPos.CENTER);
 366         }
 367 
 368         if (downArrow.isVisible()) {
 369             final double prefHeight = snapSizeY(downArrow.prefHeight(-1));
 370             clipRect.setHeight(snapSizeY(clipRect.getHeight()) - prefHeight);
 371             downArrow.resize(snapSizeX(downArrow.prefWidth(-1)), prefHeight);
 372             positionInArea(downArrow, x, (y + h - prefHeight), w, prefHeight, /*baseline ignored*/0,
 373                     HPos.CENTER, VPos.CENTER);
 374         }
 375     }
 376 
 377      @Override protected double computePrefWidth(double height) {
 378          computeVisualMetrics();
 379          double prefWidth = 0;
 380          if (itemsContainer.getChildren().size() == 0) return 0;
 381          for (Node n : itemsContainer.getChildren()) {
 382              if (! n.isVisible()) continue;
 383              prefWidth = Math.max(prefWidth, snapSizeX(n.prefWidth(-1)));
 384          }
 385          return snappedLeftInset() + snapSizeX(prefWidth) + snappedRightInset();
 386     }
 387 
 388     @Override protected double computePrefHeight(double width) {
 389         if (itemsContainer.getChildren().size() == 0) return 0;
 390         final double screenHeight = getScreenHeight();
 391         final double contentHeight = getContentHeight(); // itemsContainer.prefHeight(width);
 392         double totalHeight = snappedTopInset() + snapSizeY(contentHeight) + snappedBottomInset();
 393         // the pref height of this menu is the smaller value of the
 394         // actual pref height and the height of the screens _visual_ bounds.
 395         double prefHeight = (screenHeight &lt;= 0) ? (totalHeight) : (Math.min(totalHeight, screenHeight));
 396         return prefHeight;
 397     }
 398 
 399     @Override protected double computeMinHeight(double width) {
 400         return 0.0;
 401     }
 402 
 403     @Override protected double computeMaxHeight(double height) {
 404         return getScreenHeight();
 405     }
 406 
 407     private double getScreenHeight() {
 408         if (contextMenu == null || contextMenu.getOwnerWindow() == null ||
 409                 contextMenu.getOwnerWindow().getScene() == null) {
 410             return -1;
 411         }
 412         return snapSizeY(com.sun.javafx.util.Utils.getScreen(
 413             contextMenu.getOwnerWindow().getScene().getRoot()).getVisualBounds().getHeight());
 414 
 415     }
 416 
 417     private double getContentHeight() {
 418         double h = 0.0d;
 419         for (Node i : itemsContainer.getChildren()) {
 420             if (i.isVisible()) {
 421                h += snapSizeY(i.prefHeight(-1));
 422             }
 423         }
 424         return h;
 425     }
 426 
 427     // This handles shifting ty when doing keyboard navigation.
 428     private void ensureFocusedMenuItemIsVisible(Node node) {
 429         if (node == null) return;
 430 
 431         final Bounds nodeBounds = node.getBoundsInParent();
 432         final Bounds clipBounds = clipRect.getBoundsInParent();
 433 
 434         if (nodeBounds.getMaxY() &gt;= clipBounds.getMaxY()) {
 435             // this is for moving down the menu
 436             scroll(-nodeBounds.getMaxY() + clipBounds.getMaxY());
 437         } else if (nodeBounds.getMinY() &lt;= clipBounds.getMinY()) {
 438             // this is for moving up the menu
 439             scroll(-nodeBounds.getMinY() + clipBounds.getMinY());
 440         }
 441     }
 442 
 443     protected ObservableList&lt;MenuItem&gt; getItems() {
 444         return contextMenu.getItems();
 445     }
 446 
 447     /**
 448      * Finds the index of currently focused item.
 449      */
 450     private int findFocusedIndex() {
 451          for (int i = 0; i &lt; itemsContainer.getChildren().size(); i++) {
 452             Node n = itemsContainer.getChildren().get(i);
 453             if (n.isFocused()) {
 454                 return i;
 455             }
 456         }
 457         return -1;
 458     }
 459 
 460     private boolean isFirstShow = true;
 461     private double ty;
 462 
 463     private void initialize() {
 464         // RT-19624 calling requestFocus inside layout was casuing repeated layouts.
 465         contextMenu.addEventHandler(Menu.ON_SHOWN, event -&gt; {
 466             currentFocusedIndex = -1;
 467             for (Node child : itemsContainer.getChildren()) {
 468                 if (child instanceof MenuItemContainer) {
 469                     final MenuItem item = ((MenuItemContainer)child).item;
 470                     // When the choiceBox popup is shown, if this menu item is selected
 471                     // do a requestFocus so CSS kicks in and the item is highlighted.
 472                     if (&quot;choice-box-menu-item&quot;.equals(item.getId())) {
 473                         if (((RadioMenuItem)item).isSelected()) {
 474                             child.requestFocus();
 475                             break;
 476                         }
 477                     }
 478                 }
 479 
 480             }
 481         });
 482 
 483 //        // FIXME For some reason getSkinnable()Behavior traversal functions don&#39;t
 484 //        // get called as expected, so I&#39;ve just put the important code below.
 485         // We use setOnKeyPressed here as we are not adding a listener to a public
 486         // event type (ContextMenuContent is not public API), and without this
 487         // we get the issue shown in RT-34429
 488         setOnKeyPressed(new EventHandler&lt;KeyEvent&gt;() {
 489             @Override public void handle(KeyEvent ke) {
 490                 switch (ke.getCode()) {
 491                     case LEFT:
 492                         if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
 493                             processRightKey(ke);
 494                         } else {
 495                             processLeftKey(ke);
 496                         }
 497                         break;
 498                     case RIGHT:
 499                         if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
 500                             processLeftKey(ke);
 501                         } else {
 502                             processRightKey(ke);
 503                         }
 504                         break;
 505                     case CANCEL:
 506                         ke.consume();
 507                         break;
 508                     case ESCAPE:
 509                         // if the owner is not a menubar button, just close the
 510                         // menu - this will move focus up to the parent menu
 511                         // as required. In the case of the parent being a
 512                         // menubar button we special case in the conditional code
 513                         // beneath this switch statement. See RT-34429 for more context.
 514                         final Node ownerNode = contextMenu.getOwnerNode();
 515                         if (! (ownerNode instanceof MenuBarButton)) {
 516                             contextMenu.hide();
 517                             ke.consume();
 518                         }
 519                         break;
 520                     case DOWN:
 521                         // move to the next sibling
 522                         move(Direction.NEXT);
 523                         ke.consume();
 524                         break;
 525                     case UP:
 526                         // move to previous sibling
 527                         move(Direction.PREVIOUS);
 528                         ke.consume();
 529                         break;
 530                     case SPACE:
 531                     case ENTER:
 532                         // select the menuitem
 533                         selectMenuItem();
 534                         ke.consume();
 535                         break;
 536                     default:
 537                         break;
 538                 }
 539 
 540                 if (!ke.isConsumed()) {
 541                     final Node ownerNode = contextMenu.getOwnerNode();
 542                     if (ownerNode instanceof MenuItemContainer) {
 543                         // Forward to parent menu
 544                         Parent parent = ownerNode.getParent();
 545                         while (parent != null &amp;&amp; !(parent instanceof ContextMenuContent)) {
 546                             parent = parent.getParent();
 547                         }
 548                         if (parent instanceof ContextMenuContent) {
 549                             parent.getOnKeyPressed().handle(ke);
 550                         }
 551                     } else if (ownerNode instanceof MenuBarButton) {
 552                         // the following code no longer appears necessary, but
 553                         // leaving in intact for now...
 554 //                        // This is a top-level MenuBar Menu, so forward event to MenuBar
 555 //                        MenuBarSkin mbs = ((MenuBarButton)ownerNode).getMenuBarSkin();
 556 //                        if (mbs != null &amp;&amp; mbs.getKeyEventHandler() != null) {
 557 //                            mbs.getKeyEventHandler().handle(ke);
 558 //                        }
 559                     }
 560                 }
 561             }
 562         });
 563 
 564         addEventHandler(ScrollEvent.SCROLL, event -&gt; {
 565             /*
 566              * we&#39;ll only scroll if the arrows are visible in the direction
 567              * that we&#39;re going, otherwise we go into empty space.
 568              */
 569             final double textDeltaY = event.getTextDeltaY();
 570             final double deltaY = event.getDeltaY();
 571             if ((downArrow.isVisible() &amp;&amp; (textDeltaY &lt; 0.0 || deltaY &lt; 0.0)) ||
 572                 (upArrow.isVisible() &amp;&amp; (textDeltaY &gt; 0.0 || deltaY &gt; 0.0))) {
 573 
 574                 switch(event.getTextDeltaYUnits()) {
 575                   case LINES:
 576                       /*
 577                       ** scroll lines, use the row height of selected row,
 578                       ** or row 0 if none selected
 579                       */
 580                       int focusedIndex = findFocusedIndex();
 581                       if (focusedIndex == -1) {
 582                           focusedIndex = 0;
 583                       }
 584                       double rowHeight = itemsContainer.getChildren().get(focusedIndex).prefHeight(-1);
 585                       scroll(textDeltaY * rowHeight);
 586                       break;
 587                   case PAGES:
 588                       /*
 589                       ** page scroll, scroll the menu height
 590                       */
 591                       scroll(textDeltaY * itemsContainer.getHeight());
 592                       break;
 593                   case NONE:
 594                       /*
 595                       ** pixel scroll
 596                       */
 597                       scroll(deltaY);
 598                       break;
 599                 }
 600                 event.consume();
 601             }
 602         });
 603     }
 604 
 605     private Optional&lt;Node&gt; getFocusedNode() {
 606         final List&lt;Node&gt; children = itemsContainer.getChildren();
 607         final boolean validIndex = currentFocusedIndex &gt;= 0 &amp;&amp; currentFocusedIndex &lt; children.size();
 608         return validIndex ? Optional.of(children.get(currentFocusedIndex)) : Optional.empty();
 609     }
 610 
 611     private void processLeftKey(KeyEvent ke) {
 612         getFocusedNode().ifPresent(n -&gt; {
 613             if (n instanceof MenuItemContainer) {
 614                 MenuItem item = ((MenuItemContainer)n).item;
 615                 if (item instanceof Menu) {
 616                     final Menu menu = (Menu) item;
 617 
 618                     // if the submenu for this menu is showing, hide it
 619                     if (menu == openSubmenu &amp;&amp; submenu != null &amp;&amp; submenu.isShowing()) {
 620                         hideSubmenu();
 621                         ke.consume();
 622                     }
 623                 }
 624             }
 625         });
 626     }
 627 
 628     private void processRightKey(KeyEvent ke) {
 629         getFocusedNode().ifPresent(n -&gt; {
 630             if (n instanceof MenuItemContainer) {
 631                 MenuItem item = ((MenuItemContainer)n).item;
 632                 if (item instanceof Menu) {
 633                     final Menu menu = (Menu) item;
 634                     if (menu.isDisable()) return;
 635                     selectedBackground = ((MenuItemContainer)n);
 636 
 637                     // RT-15103
 638                     // if submenu for this menu is already showing then do nothing
 639                     // Menubar will process the right key and move to the next menu
 640                     if (openSubmenu == menu &amp;&amp; submenu != null &amp;&amp; submenu.isShowing()) {
 641                         return;
 642                     }
 643 
 644                     showMenu(menu);
 645                     ke.consume();
 646                 }
 647             }
 648         });
 649     }
 650 
 651     private void showMenu(Menu menu) {
 652         menu.show();
 653         // request focus on the first item of the submenu after it is shown
 654         ContextMenuContent cmContent = (ContextMenuContent)submenu.getSkin().getNode();
 655         if (cmContent != null) {
 656            if (cmContent.itemsContainer.getChildren().size() &gt; 0) {
 657                cmContent.itemsContainer.getChildren().get(0).requestFocus();
 658                cmContent.currentFocusedIndex = 0;
 659            } else {
 660                cmContent.requestFocus();
 661            }
 662         }
 663     }
 664 
 665     private void selectMenuItem() {
 666         getFocusedNode().ifPresent(n -&gt; {
 667             if (n instanceof MenuItemContainer) {
 668                 MenuItem item = ((MenuItemContainer)n).item;
 669                 if (item instanceof Menu) {
 670                     final Menu menu = (Menu) item;
 671                     if (openSubmenu != null) {
 672                         hideSubmenu();
 673                     }
 674                     if (menu.isDisable()) return;
 675                     selectedBackground = ((MenuItemContainer)n);
 676                     menu.show();
 677                 } else {
 678                     ((MenuItemContainer)n).doSelect();
 679                 }
 680             }
 681         });
 682     }
 683 
 684     private void move(Direction dir) {
 685         int startIndex = currentFocusedIndex != -1 ? currentFocusedIndex : itemsContainer.getChildren().size();
 686         requestFocusOnIndex(findSibling(dir, startIndex));
 687     }
 688 
 689     private int findSibling(final Direction dir, final int startIndex) {
 690         final int childCount = itemsContainer.getChildren().size();
 691         int i = startIndex;
 692         do {
 693             if (dir.isForward() &amp;&amp; i &gt;= childCount - 1) {
 694                 // loop to zero
 695                 i = 0;
 696             } else if (!dir.isForward() &amp;&amp; i == 0) {
 697                 // loop to end
 698                 i = childCount - 1;
 699             } else {
 700                 i += (dir.isForward() ? 1 : -1);
 701             }
 702 
 703             Node n = itemsContainer.getChildren().get(i);
 704             if (n instanceof MenuItemContainer &amp;&amp; n.isVisible()) {
 705                 return i;
 706             }
 707         } while (i != startIndex);
 708         return -1;
 709     }
 710 
 711     public void requestFocusOnIndex(int index) {
 712         currentFocusedIndex = index;
 713         Node n = itemsContainer.getChildren().get(index);
 714         selectedBackground = ((MenuItemContainer)n);
 715         n.requestFocus();
 716         ensureFocusedMenuItemIsVisible(n);
 717     }
 718 
 719     /*
 720      * Get the Y offset from the top of the popup to the menu item whose index
 721      * is given.
 722      */
 723     public double getMenuYOffset(int menuIndex) {
 724         double offset = 0;
 725         if (itemsContainer.getChildren().size() &gt; menuIndex) {
 726             offset = snappedTopInset();
 727             Node menuitem = itemsContainer.getChildren().get(menuIndex);
 728             offset += menuitem.getLayoutY() + menuitem.prefHeight(-1);
 729         }
 730         return offset;
 731     }
 732 
 733     private void setUpBinds() {
 734         updateMenuShowingListeners(contextMenu.getItems(), true);
 735         contextMenu.getItems().addListener(contextMenuItemsListener);
 736     }
 737 
 738     private void disposeBinds() {
 739         updateMenuShowingListeners(contextMenu.getItems(), false);
 740         contextMenu.getItems().removeListener(contextMenuItemsListener);
 741     }
 742 
 743     private ChangeListener&lt;Boolean&gt; menuShowingListener = (observable, wasShowing, isShowing) -&gt; {
 744         ReadOnlyBooleanProperty isShowingProperty = (ReadOnlyBooleanProperty) observable;
 745         Menu menu = (Menu) isShowingProperty.getBean();
 746 
 747         if (wasShowing &amp;&amp; ! isShowing) {
 748             // hide the submenu popup
 749             hideSubmenu();
 750         } else if (! wasShowing &amp;&amp; isShowing) {
 751             // show the submenu popup
 752             showSubmenu(menu);
 753         }
 754     };
 755 
 756     private ListChangeListener&lt;MenuItem&gt; contextMenuItemsListener = (ListChangeListener&lt;MenuItem&gt;) c -&gt; {
 757         // Add listeners to the showing property of all menus that have
 758         // been added, and remove listeners from menus that have been removed
 759         // FIXME this is temporary - we should be adding and removing
 760         // listeners such that they use the one listener defined above
 761         // - but that can&#39;t be done until we have the bean in the
 762         // ObservableValue
 763         while (c.next()) {
 764             updateMenuShowingListeners(c.getRemoved(), false);
 765             updateMenuShowingListeners(c.getAddedSubList(), true);
 766         }
 767 
 768         // Listener to items in PopupMenu to update items in PopupMenuContent
 769         itemsDirty = true;
 770         updateItems(); // RT-29761
 771     };
 772 
 773     private ChangeListener&lt;Boolean&gt; menuItemVisibleListener = (observable, oldValue, newValue) -&gt; {
 774         // re layout as item&#39;s visibility changed
 775         requestLayout();
 776     };
 777 
 778     private void updateMenuShowingListeners(List&lt;? extends MenuItem&gt; items, boolean addListeners) {
 779         for (MenuItem item : items) {
 780             if (item instanceof Menu) {
 781                 final Menu menu = (Menu) item;
 782 
 783                 if (addListeners) {
 784                     menu.showingProperty().addListener(menuShowingListener);
 785                 } else {
 786                     menu.showingProperty().removeListener(menuShowingListener);
 787                 }
 788             }
 789 
 790              // listen to menu items&#39;s visible property.
 791             if (addListeners) {
 792                 item.visibleProperty().addListener(menuItemVisibleListener);
 793             } else {
 794                 item.visibleProperty().removeListener(menuItemVisibleListener);
 795             }
 796         }
 797     }
 798 
 799     // For test purpose only
 800     ContextMenu getSubMenu() {
 801         return submenu;
 802     }
 803 
 804     Menu getOpenSubMenu() {
 805         return openSubmenu;
 806     }
 807 
 808     private void createSubmenu() {
 809         if (submenu == null) {
 810             submenu = new ContextMenu();
 811             submenu.showingProperty().addListener(new ChangeListener&lt;Boolean&gt;() {
 812                 @Override public void changed(ObservableValue&lt;? extends Boolean&gt; observable,
 813                                               Boolean oldValue, Boolean newValue) {
 814                     if (!submenu.isShowing()) {
 815                         // Maybe user clicked outside or typed ESCAPE.
 816                         // Make sure menus are in sync.
 817                         for (Node node : itemsContainer.getChildren()) {
 818                             if (node instanceof MenuItemContainer
 819                                   &amp;&amp; ((MenuItemContainer)node).item instanceof Menu) {
 820                                 Menu menu = (Menu)((MenuItemContainer)node).item;
 821                                 if (menu.isShowing()) {
 822                                     menu.hide();
 823                                 }
 824                             }
 825                         }
 826                     }
 827                 }
 828             });
 829         }
 830     }
 831 
 832     private void showSubmenu(Menu menu) {
 833         openSubmenu = menu;
 834         createSubmenu();
 835         submenu.getItems().setAll(menu.getItems());
 836         submenu.show(selectedBackground, Side.RIGHT, 0, 0);
 837     }
 838 
 839     private void hideSubmenu() {
 840         if (submenu == null) return;
 841 
 842         submenu.hide();
 843         openSubmenu = null;
 844 
 845         // Fix for RT-37022 - we dispose content so that we do not process CSS
 846         // on hidden submenus
 847         disposeContextMenu(submenu);
 848         submenu = null;
 849 
 850         // Fix for JDK-8158679 - we put the focus on the menu, and then back
 851         // on the menu item, so that screen readers can properly speak out
 852         // the menu item.
 853         getFocusedNode().ifPresent(n -&gt; {
 854             requestFocus();
 855             n.requestFocus();
 856         });
 857     }
 858 
 859     private void hideAllMenus(MenuItem item) {
 860         if (contextMenu != null) contextMenu.hide();
 861 
 862         Menu parentMenu;
 863         while ((parentMenu = item.getParentMenu()) != null) {
 864             parentMenu.hide();
 865             item = parentMenu;
 866         }
 867         if (item.getParentPopup() != null) {
 868             item.getParentPopup().hide();
 869         }
 870     }
 871 
 872     private Menu openSubmenu;
 873     private ContextMenu submenu;
 874 
 875     // FIXME: HACKY. We use this so that a submenu knows where to open from
 876     // but this will only work for mouse hovers currently - and won&#39;t work
 877     // programmatically.
 878     // package protected for testing only!
 879     Region selectedBackground;
 880 
 881     void scroll(double delta) {
 882         double newTy = ty + delta;
 883         if (ty == newTy) return;
 884 
 885         // translation should never be positive (this would mean the top of the
 886         // menu content is detaching from the top of the menu!)
 887         if (newTy &gt; 0.0) {
 888             newTy = 0.0;
 889         }
 890 
 891         // translation should never be greater than the preferred height of the
 892         // menu content (otherwise the menu content will be detaching from the
 893         // bottom of the menu).
 894         // RT-37185: We check the direction of the scroll, to prevent it locking
 895         // up when scrolling upwards from the very bottom (using the on-screen
 896         // up arrow).
 897         if (delta &lt; 0 &amp;&amp; (getHeight() - newTy) &gt; itemsContainer.getHeight() - downArrow.getHeight()) {
 898             newTy = getHeight() - itemsContainer.getHeight() - downArrow.getHeight();
 899         }
 900 
 901         ty = newTy;
 902         itemsContainer.requestLayout();
 903     }
 904 
 905     /***************************************************************************
 906      *                                                                         *
 907      *                         Stylesheet Handling                             *
 908      *                                                                         *
 909      **************************************************************************/
 910     @Override public Styleable getStyleableParent() {
 911         return contextMenu;
 912     }
 913 
 914     private static class StyleableProperties {
 915 
 916         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
 917         static {
 918 
 919             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
 920                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Region.getClassCssMetaData());
 921 
 922             //
 923             // SkinBase only has Region&#39;s unique StlyleableProperty&#39;s, none of Nodes
 924             // So, we need to add effect back in. The effect property is in a
 925             // private inner class, so get the property from Node the hard way.
 926             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; nodeStyleables = Node.getClassCssMetaData();
 927             for(int n=0, max=nodeStyleables.size(); n&lt;max; n++) {
 928                 CssMetaData&lt;? extends Styleable, ?&gt; styleable = nodeStyleables.get(n);
 929                 if (&quot;effect&quot;.equals(styleable.getProperty())) {
 930                     styleables.add(styleable);
 931                     break;
 932                 }
 933             }
 934             STYLEABLES = Collections.unmodifiableList(styleables);
 935         }
 936     }
 937 
 938     /**
 939      * @return The CssMetaData associated with this class, which may include the
 940      * CssMetaData of its superclasses.
 941      */
 942     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
 943         return StyleableProperties.STYLEABLES;
 944     }
 945 
 946     /**
 947      * {@inheritDoc}
 948      */
 949     @Override
 950     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
 951         return getClassCssMetaData();
 952     }
 953 
 954     public Label getLabelAt(int index) {
 955         return ((MenuItemContainer)itemsContainer.getChildren().get(index)).getLabel();
 956     }
 957 
 958     /**
 959      * Custom VBox to enable scrolling of items. Scrolling effect is achieved by
 960      * controlling the translate Y coordinate of the menu item &quot;ty&quot; which is set by a
 961      * timeline when mouse is over up/down arrow.
 962      */
 963     class MenuBox extends VBox {
 964         MenuBox() {
 965             setAccessibleRole(AccessibleRole.CONTEXT_MENU);
 966         }
 967 
 968         @Override protected void layoutChildren() {
 969             double yOffset = ty;
 970             for (Node n : getChildren()) {
 971                 if (n.isVisible()) {
 972                     final double prefHeight = snapSizeY(n.prefHeight(-1));
 973                     n.resize(snapSizeX(getWidth()), prefHeight);
 974                     n.relocate(snappedLeftInset(), yOffset);
 975                     yOffset += prefHeight;
 976                 }
 977             }
 978         }
 979 
 980         /** {@inheritDoc} */
 981         @Override
 982         public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
 983             switch (attribute) {
 984                 case VISIBLE: return contextMenu.isShowing();
 985                 case PARENT_MENU: return contextMenu.getOwnerNode();
 986                 default: return super.queryAccessibleAttribute(attribute, parameters);
 987             }
 988         }
 989     }
 990 
 991     class ArrowMenuItem extends StackPane {
 992          private StackPane upDownArrow;
 993          private ContextMenuContent popupMenuContent;
 994          private boolean up = false;
 995          public final boolean isUp() { return up; }
 996          public void setUp(boolean value) {
 997             up = value;
 998             upDownArrow.getStyleClass().setAll(isUp() ? &quot;menu-up-arrow&quot; : &quot;menu-down-arrow&quot;);
 999         }
1000 
1001         // used to automatically scroll through menu items when the user performs
1002         // certain interactions, e.g. pressing and holding the arrow buttons
1003         private Timeline scrollTimeline;
1004 
1005         public ArrowMenuItem(ContextMenuContent pmc) {
1006             getStyleClass().setAll(&quot;scroll-arrow&quot;);
1007             upDownArrow = new StackPane();
1008             this.popupMenuContent = pmc;
1009             upDownArrow.setMouseTransparent(true);
1010             upDownArrow.getStyleClass().setAll(isUp() ? &quot;menu-up-arrow&quot; : &quot;menu-down-arrow&quot;);
1011     //        setMaxWidth(Math.max(upDownArrow.prefWidth(-1), getWidth()));
1012             addEventHandler(MouseEvent.MOUSE_ENTERED, me -&gt; {
1013                 if (scrollTimeline != null &amp;&amp; (scrollTimeline.getStatus() != Status.STOPPED)) {
1014                     return;
1015                 }
1016                 startTimeline();
1017             });
1018             addEventHandler(MouseEvent.MOUSE_EXITED, me -&gt; {
1019                 stopTimeline();
1020             });
1021             setVisible(false);
1022             setManaged(false);
1023             getChildren().add(upDownArrow);
1024         }
1025 
1026         @Override protected double computePrefWidth(double height) {
1027 //            return snapSize(getInsets().getLeft()) + snapSize(getInsets().getRight());
1028             return itemsContainer.getWidth();
1029         }
1030 
1031         @Override protected double computePrefHeight(double width) {
1032             return snappedTopInset() + upDownArrow.prefHeight(-1) + snappedBottomInset();
1033         }
1034 
1035         @Override protected void layoutChildren() {
1036             double w = snapSizeX(upDownArrow.prefWidth(-1));
1037             double h = snapSizeY(upDownArrow.prefHeight(-1));
1038 
1039             upDownArrow.resize(w, h);
1040             positionInArea(upDownArrow, 0, 0, getWidth(), getHeight(),
1041                     /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
1042         }
1043 
1044         private void adjust() {
1045             if(up) popupMenuContent.scroll(12); else popupMenuContent.scroll(-12);
1046         }
1047 
1048         private void startTimeline() {
1049             scrollTimeline = new Timeline();
1050             scrollTimeline.setCycleCount(Timeline.INDEFINITE);
1051             KeyFrame kf = new KeyFrame(
1052                 Duration.millis(60),
1053                     event -&gt; {
1054                         adjust();
1055                     }
1056             );
1057             scrollTimeline.getKeyFrames().clear();
1058             scrollTimeline.getKeyFrames().add(kf);
1059             scrollTimeline.play();
1060         }
1061 
1062         private void stopTimeline() {
1063             scrollTimeline.stop();
1064             scrollTimeline = null;
1065         }
1066     }
1067 
1068     /*
1069      * Container responsible for laying out a single row in the menu - in other
1070      * words, this contains and lays out a single MenuItem, regardless of it&#39;s
1071      * specific subtype.
1072      */
1073     public class MenuItemContainer extends Region {
1074 
1075         private final MenuItem item;
1076 
1077         private Node left;
1078         private Node graphic;
1079         private Node label;
1080         private Node right;
1081 
1082         private final LambdaMultiplePropertyChangeListenerHandler listener =
1083             new LambdaMultiplePropertyChangeListenerHandler();
1084 
1085         private EventHandler&lt;MouseEvent&gt; mouseEnteredEventHandler;
1086         private EventHandler&lt;MouseEvent&gt; mouseReleasedEventHandler;
1087 
1088         private EventHandler&lt;ActionEvent&gt; actionEventHandler;
1089 
1090         protected Label getLabel(){
1091             return (Label) label;
1092         }
1093 
1094         public MenuItem getItem() {
1095             return item;
1096         }
1097 
1098         public MenuItemContainer(MenuItem item){
1099             if (item == null) {
1100                 throw new NullPointerException(&quot;MenuItem can not be null&quot;);
1101             }
1102 
1103             getStyleClass().addAll(item.getStyleClass());
1104             setId(item.getId());
1105             setFocusTraversable(!(item instanceof CustomMenuItem));
1106             this.item = item;
1107 
1108             createChildren();
1109 
1110             // listen to changes in the state of certain MenuItem types
1111             ReadOnlyBooleanProperty pseudoProperty;
1112             if (item instanceof Menu) {
1113                 pseudoProperty = ((Menu)item).showingProperty();
1114                 listener.registerChangeListener(pseudoProperty,
1115                         e -&gt; pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, ((Menu) item).isShowing()));
1116                 pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, pseudoProperty.get());
1117                 setAccessibleRole(AccessibleRole.MENU);
1118             } else if (item instanceof RadioMenuItem) {
1119                 pseudoProperty = ((RadioMenuItem)item).selectedProperty();
1120                 listener.registerChangeListener(pseudoProperty,
1121                         e -&gt; pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, ((RadioMenuItem) item).isSelected()));
1122                 pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, pseudoProperty.get());
1123                 setAccessibleRole(AccessibleRole.RADIO_MENU_ITEM);
1124             } else if (item instanceof CheckMenuItem) {
1125                 pseudoProperty = ((CheckMenuItem)item).selectedProperty();
1126                 listener.registerChangeListener(pseudoProperty,
1127                         e -&gt; pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, ((CheckMenuItem) item).isSelected()));
1128                 pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, pseudoProperty.get());
1129                 setAccessibleRole(AccessibleRole.CHECK_MENU_ITEM);
1130             } else {
1131                 setAccessibleRole(AccessibleRole.MENU_ITEM);
1132             }
1133 
1134             pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, item.disableProperty().get());
1135             listener.registerChangeListener(item.disableProperty(),
1136                     e -&gt; pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, item.isDisable()));
1137 
1138             // Add the menu item to properties map of this node. Used by QA for testing
1139             // This allows associating this container with corresponding MenuItem.
1140             getProperties().put(MenuItem.class, item);
1141 
1142             listener.registerChangeListener(item.graphicProperty(), e -&gt; {
1143                 createChildren();
1144                 computeVisualMetrics();
1145             });
1146 
1147             actionEventHandler = e -&gt; {
1148                 if (item instanceof Menu) {
1149                     final Menu menu = (Menu) item;
1150                     if (openSubmenu == menu &amp;&amp; submenu.isShowing()) return;
1151                     if (openSubmenu != null) {
1152                         hideSubmenu();
1153                     }
1154 
1155                     selectedBackground = MenuItemContainer.this;
1156                     showMenu(menu);
1157                 } else {
1158                     doSelect();
1159                 }
1160             };
1161             addEventHandler(ActionEvent.ACTION, actionEventHandler);
1162         }
1163 
1164         public void dispose() {
1165             if (item instanceof CustomMenuItem) {
1166                 Node node = ((CustomMenuItem)item).getContent();
1167                 if (node != null) {
1168                     node.removeEventHandler(MouseEvent.MOUSE_CLICKED, customMenuItemMouseClickedHandler);
1169                 }
1170             }
1171 
1172             listener.dispose();
1173             removeEventHandler(ActionEvent.ACTION, actionEventHandler);
1174 
1175             if (label != null) {
1176                 ((Label)label).textProperty().unbind();
1177                 label.styleProperty().unbind();
1178                 label.idProperty().unbind();
1179 
1180                 ListChangeListener&lt;String&gt; itemStyleClassListener = (ListChangeListener&lt;String&gt;)item.getProperties().remove(ITEM_STYLE_CLASS_LISTENER);
1181                 if (itemStyleClassListener != null) {
1182                     item.getStyleClass().removeListener(itemStyleClassListener);
1183                 }
1184             }
1185 
1186             left = null;
1187             graphic = null;
1188             label = null;
1189             right = null;
1190         }
1191 
1192         private void createChildren() {
1193             getChildren().clear();
1194 
1195             // draw background region for hover effects. All content (other
1196             // than Nodes from NodeMenuItems) are set to be mouseTransparent, so
1197             // this background also acts as the receiver of user input
1198             if (item instanceof CustomMenuItem) {
1199                 createNodeMenuItemChildren((CustomMenuItem)item);
1200 
1201                 if (mouseEnteredEventHandler == null) {
1202                     mouseEnteredEventHandler = event -&gt; {
1203                         requestFocus(); // request Focus on hover
1204                     };
1205                 } else {
1206                     removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
1207                 }
1208                 addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
1209             } else {
1210                 // --- add check / radio to left column
1211                 Node leftNode = getLeftGraphic(item);
1212                 if (leftNode != null) {
1213                     StackPane leftPane = new StackPane();
1214                     leftPane.getStyleClass().add(&quot;left-container&quot;);
1215                     leftPane.getChildren().add(leftNode);
1216                     left = leftPane;
1217                     getChildren().add(left);
1218                     left.setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
1219                 }
1220                 // -- add graphic to graphic pane
1221                 if (item.getGraphic() != null) {
1222                     Node graphicNode = item.getGraphic();
1223                     StackPane graphicPane = new StackPane();
1224                     graphicPane.getStyleClass().add(&quot;graphic-container&quot;);
1225                     graphicPane.getChildren().add(graphicNode);
1226                     graphic = graphicPane;
1227                     getChildren().add(graphic);
1228                 }
1229 
1230                 // --- add text to center column
1231                 label = new MenuLabel(item, this);  // make this a menulabel to handle mnemonics fire()
1232 
1233                 // set up bindings from the MenuItem into the Label
1234                 ((Label)label).textProperty().bind(item.textProperty());
1235                 label.styleProperty().bind(item.styleProperty());
1236                 label.idProperty().bind(item.styleProperty());
1237 
1238                 // we want to ensure that any styleclasses set on the menuitem are applied to the
1239                 // label (so we can style appropriately), but we can&#39;t just do a binding such as this:
1240                 // Bindings.bindContent(label.getStyleClass(), item.getStyleClass());
1241                 // Because that means we overwrite the &#39;label&#39; style class on the Label.
1242                 // What we really want is to ensure all style classes in the MenuItem are _copied_
1243                 // into the label, which is what we do below
1244                 ListChangeListener&lt;String&gt; itemStyleClassListener = c -&gt; {
1245                     while (c.next()) {
1246                         label.getStyleClass().removeAll(c.getRemoved());
1247                         label.getStyleClass().addAll(c.getAddedSubList());
1248                     }
1249                 };
1250                 item.getStyleClass().addListener(itemStyleClassListener);
1251                 item.getProperties().put(ITEM_STYLE_CLASS_LISTENER, itemStyleClassListener);
1252 
1253 
1254                 label.setMouseTransparent(true);
1255                 getChildren().add(label);
1256 
1257                 listener.unregisterChangeListeners(focusedProperty());
1258                 // RT-19546 update currentFocusedIndex when MenuItemContainer gets focused.
1259                 // e.g this happens when you press the Right key to open a submenu; the first
1260                 // menuitem is focused.
1261                 listener.registerChangeListener(focusedProperty(), e -&gt; {
1262                     if (isFocused()) {
1263                         currentFocusedIndex = itemsContainer.getChildren().indexOf(MenuItemContainer.this);
1264                     }
1265                 });
1266 
1267                 // --- draw in right column - this depends on whether we are
1268                 // a Menu or not. A Menu gets an arrow, whereas other MenuItems
1269                 // get the ability to draw an accelerator
1270                 if (item instanceof Menu) {
1271                     // --- add arrow / accelerator / mnemonic to right column
1272                     Region rightNode = new Region();
1273                     rightNode.setMouseTransparent(true);
1274                     rightNode.getStyleClass().add(&quot;arrow&quot;);
1275 
1276                     StackPane rightPane = new StackPane();
1277                     rightPane.setMaxWidth(Math.max(rightNode.prefWidth(-1), 10));
1278                     rightPane.setMouseTransparent(true);
1279                     rightPane.getStyleClass().add(&quot;right-container&quot;);
1280                     rightPane.getChildren().add(rightNode);
1281                     right = rightPane;
1282                     getChildren().add(rightPane);
1283 
1284                     if (mouseEnteredEventHandler == null) {
1285                         mouseEnteredEventHandler = event -&gt; {
1286                             if (openSubmenu != null &amp;&amp; item != openSubmenu) {
1287                                 // if a submenu of a different menu is already
1288                                 // open then close it (RT-15049)
1289                                 hideSubmenu();
1290                             }
1291 
1292                             selectedBackground = MenuItemContainer.this;
1293                             requestFocus();  // request Focus on hover
1294                             final Menu menu = (Menu) item;
1295                             if (menu.isDisable()) return;
1296                             menu.show();
1297                         };
1298                     } else {
1299                         removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
1300                     }
1301 
1302                     if (mouseReleasedEventHandler == null) {
1303                         mouseReleasedEventHandler = event -&gt; {
1304                             item.fire();
1305                         };
1306                     } else {
1307                         removeEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
1308                     }
1309 
1310                     // show submenu when the menu is hovered over
1311                     addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
1312                     addEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
1313                 } else { // normal MenuItem
1314                     // remove old listeners
1315                     listener.unregisterChangeListeners(item.acceleratorProperty());
1316 
1317                     // accelerator support
1318                     updateAccelerator();
1319 
1320                     if (mouseEnteredEventHandler == null) {
1321                         mouseEnteredEventHandler = event -&gt; {
1322                             if (openSubmenu != null) {
1323                                 openSubmenu.hide();
1324                             }
1325                             requestFocus();  // request Focus on hover
1326                         };
1327                     } else {
1328                         removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
1329                     }
1330 
1331                     if (mouseReleasedEventHandler == null) {
1332                         mouseReleasedEventHandler = event -&gt; {
1333                             doSelect();
1334                         };
1335                     } else {
1336                         removeEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
1337                     }
1338 
1339                     addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
1340                     addEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
1341 
1342                     listener.registerChangeListener(item.acceleratorProperty(), e -&gt; updateAccelerator());
1343                 }
1344             }
1345         }
1346 
1347         private void updateAccelerator() {
1348             if (item.getAccelerator() != null) {
1349                 if (right != null) {
1350                     getChildren().remove(right);
1351                 }
1352 
1353                 String text = item.getAccelerator().getDisplayText();
1354                 right = new Label(text);
1355                 right.setStyle(item.getStyle());
1356                 right.getStyleClass().add(&quot;accelerator-text&quot;);
1357                 getChildren().add(right);
1358             } else {
1359                 getChildren().remove(right);
1360             }
1361         }
1362 
1363         void doSelect() {
1364             // don&#39;t do anything on disabled menu items
1365             if (item.isDisable()) return;
1366             // toggle state of check or radio items
1367             if (item instanceof CheckMenuItem) {
1368                 CheckMenuItem checkItem = (CheckMenuItem)item;
1369                 checkItem.setSelected(!checkItem.isSelected());
1370             } else if (item instanceof RadioMenuItem) {
1371                 // this is a radio button. If there is a toggleGroup specified, we
1372                 // simply set selected to true. If no toggleGroup is specified, we
1373                 // toggle the selected state, as there is no assumption of mutual
1374                 // exclusivity when no toggleGroup is set.
1375                 final RadioMenuItem radioItem = (RadioMenuItem) item;
1376                 radioItem.setSelected(radioItem.getToggleGroup() != null ? true : !radioItem.isSelected());
1377             }
1378 
1379             // fire the action before hiding the menu
1380             item.fire();
1381 
1382             if (item instanceof CustomMenuItem) {
1383                 CustomMenuItem customMenuItem = (CustomMenuItem) item;
1384                 if (customMenuItem.isHideOnClick()) {
1385                     hideAllMenus(item);
1386                 }
1387             } else {
1388                 hideAllMenus(item);
1389             }
1390         }
1391 
1392         private EventHandler&lt;MouseEvent&gt; customMenuItemMouseClickedHandler;
1393 
1394         private void createNodeMenuItemChildren(final CustomMenuItem item) {
1395             Node node = item.getContent();
1396             getChildren().add(node);
1397 
1398             // handle hideOnClick
1399             customMenuItemMouseClickedHandler = event -&gt; {
1400                 if (item == null || item.isDisable()) return;
1401 
1402                 item.fire();
1403                 if (item.isHideOnClick()) {
1404                     hideAllMenus(item);
1405                 }
1406             };
1407             node.addEventHandler(MouseEvent.MOUSE_CLICKED, customMenuItemMouseClickedHandler);
1408         }
1409 
1410         @Override protected void layoutChildren() {
1411             double xOffset;
1412 
1413             final double prefHeight = prefHeight(-1);
1414             if (left != null) {
1415                 xOffset = snappedLeftInset();
1416                 left.resize(left.prefWidth(-1), left.prefHeight(-1));
1417                 positionInArea(left, xOffset, 0,
1418                         maxLeftWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
1419             }
1420             if (graphic != null) {
1421                 xOffset = snappedLeftInset() + maxLeftWidth;
1422                 graphic.resize(graphic.prefWidth(-1), graphic.prefHeight(-1));
1423                 positionInArea(graphic, xOffset, 0,
1424                         maxGraphicWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
1425             }
1426 
1427             if (label != null) {
1428                 xOffset = snappedLeftInset() + maxLeftWidth + maxGraphicWidth;
1429                 label.resize(label.prefWidth(-1), label.prefHeight(-1));
1430                 positionInArea(label, xOffset, 0,
1431                         maxLabelWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
1432             }
1433 
1434             if (right != null) {
1435                 xOffset = snappedLeftInset() + maxLeftWidth + maxGraphicWidth + maxLabelWidth;
1436                 right.resize(right.prefWidth(-1), right.prefHeight(-1));
1437                 positionInArea(right, xOffset, 0,
1438                     maxRightWidth, prefHeight, 0, HPos.RIGHT, VPos.CENTER);
1439             }
1440 
1441             if ( item instanceof CustomMenuItem) {
1442                 Node n = ((CustomMenuItem) item).getContent();
1443                 if (item instanceof SeparatorMenuItem) {
1444                     double width = prefWidth(-1) - (snappedLeftInset() + maxGraphicWidth + snappedRightInset());
1445                     n.resize(width, n.prefHeight(-1));
1446                     positionInArea(n, snappedLeftInset() + maxGraphicWidth, 0, prefWidth(-1), prefHeight, 0, HPos.LEFT, VPos.CENTER);
1447                 } else {
1448                     n.resize(n.prefWidth(-1), n.prefHeight(-1));
1449                     //the node should be left aligned
1450                     positionInArea(n, snappedLeftInset(), 0, getWidth(), prefHeight, 0, HPos.LEFT, VPos.CENTER);
1451                 }
1452             }
1453         }
1454 
1455         @Override protected double computePrefHeight(double width) {
1456             double prefHeight = 0;
1457             if (item instanceof CustomMenuItem || item instanceof SeparatorMenuItem) {
1458                 prefHeight = (getChildren().isEmpty()) ? 0 : getChildren().get(0).prefHeight(-1);
1459             } else {
1460                 prefHeight = Math.max(prefHeight, (left != null) ? left.prefHeight(-1) : 0);
1461                 prefHeight = Math.max(prefHeight, (graphic != null) ? graphic.prefHeight(-1) : 0);
1462                 prefHeight = Math.max(prefHeight, (label != null) ? label.prefHeight(-1) : 0);
1463                 prefHeight = Math.max(prefHeight, (right != null) ? right.prefHeight(-1) : 0);
1464             }
1465              return snappedTopInset() + prefHeight + snappedBottomInset();
1466         }
1467 
1468         @Override protected double computePrefWidth(double height) {
1469             double nodeMenuItemWidth = 0;
1470             if (item instanceof CustomMenuItem &amp;&amp; !(item instanceof SeparatorMenuItem)) {
1471                 nodeMenuItemWidth = snappedLeftInset() + ((CustomMenuItem) item).getContent().prefWidth(-1) +
1472                         snappedRightInset();
1473             }
1474             return Math.max(nodeMenuItemWidth,
1475                     snappedLeftInset() + maxLeftWidth + maxGraphicWidth +
1476                     maxLabelWidth + maxRightWidth + snappedRightInset());
1477         }
1478 
1479         // Responsible for returning a graphic (if necessary) to position in the
1480         // left column of the menu. This may be a Node from the MenuItem.graphic
1481         // property, or it may be a check/radio item if necessary.
1482         private Node getLeftGraphic(MenuItem item) {
1483             if (item instanceof RadioMenuItem) {
1484                  final Region _graphic = new Region();
1485                 _graphic.getStyleClass().add(&quot;radio&quot;);
1486                 return _graphic;
1487             } else if (item instanceof CheckMenuItem) {
1488                 final StackPane _graphic = new StackPane();
1489                 _graphic.getStyleClass().add(&quot;check&quot;);
1490                 return _graphic;
1491             }
1492 
1493             return null;
1494         }
1495 
1496         /** {@inheritDoc} */
1497         @Override
1498         public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1499             switch (attribute) {
1500                 case SELECTED:
1501                     if (item instanceof CheckMenuItem) {
1502                         return ((CheckMenuItem)item).isSelected();
1503                     }
1504                     if (item instanceof RadioMenuItem) {
1505                         return ((RadioMenuItem) item).isSelected();
1506                     }
1507                     return false;
1508                 case ACCELERATOR: return item.getAccelerator();
1509                 case TEXT: {
1510                     String title = &quot;&quot;;
1511                     if (graphic != null) {
1512                         String t = (String)graphic.queryAccessibleAttribute(AccessibleAttribute.TEXT);
1513                         if (t != null) title += t;
1514                     }
1515                     final Label label = getLabel();
1516                     if (label != null) {
1517                         String t = (String)label.queryAccessibleAttribute(AccessibleAttribute.TEXT);
1518                         if (t != null) title += t;
1519                     }
1520                     if (item instanceof CustomMenuItem) {
1521                         Node content = ((CustomMenuItem) item).getContent();
1522                         if (content != null) {
1523                             String t = (String)content.queryAccessibleAttribute(AccessibleAttribute.TEXT);
1524                             if (t != null) title += t;
1525                         }
1526                     }
1527                     return title;
1528                 }
1529                 case MNEMONIC: {
1530                     final Label label = getLabel();
1531                     if (label != null) {
1532                         String mnemonic = (String)label.queryAccessibleAttribute(AccessibleAttribute.MNEMONIC);
1533                         if (mnemonic != null) return mnemonic;
1534                     }
1535                     return null;
1536                 }
1537                 case DISABLED: return item.isDisable();
1538                 case SUBMENU:
1539                     createSubmenu();
1540                     // Accessibility might need to see the menu node before the window
1541                     // is visible (i.e. before the skin is applied).
1542                     if (submenu.getSkin() == null) {
1543                         submenu.getStyleableNode().applyCss();
1544                     }
1545                     ContextMenuContent cmContent = (ContextMenuContent)submenu.getSkin().getNode();
1546                     return cmContent.itemsContainer;
1547                 default: return super.queryAccessibleAttribute(attribute, parameters);
1548             }
1549         }
1550 
1551         /** {@inheritDoc} */
1552         @Override
1553         public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
1554             switch (action) {
1555                 case SHOW_MENU:{
1556                     if (item instanceof Menu) {
1557                         final Menu menuItem = (Menu) item;
1558                         if (menuItem.isShowing()) {
1559                             menuItem.hide();
1560                         } else {
1561                             menuItem.show();
1562                         }
1563                     }
1564                     break;
1565                 }
1566                 case FIRE:
1567                     doSelect();
1568                     break;
1569                 default: super.executeAccessibleAction(action);
1570             }
1571         }
1572     }
1573 
1574 
1575     private static final PseudoClass SELECTED_PSEUDOCLASS_STATE =
1576             PseudoClass.getPseudoClass(&quot;selected&quot;);
1577     private static final PseudoClass DISABLED_PSEUDOCLASS_STATE =
1578             PseudoClass.getPseudoClass(&quot;disabled&quot;);
1579     private static final PseudoClass CHECKED_PSEUDOCLASS_STATE =
1580             PseudoClass.getPseudoClass(&quot;checked&quot;);
1581 
1582     private class MenuLabel extends Label {
1583 
1584         public MenuLabel(MenuItem item, MenuItemContainer mic) {
1585             super(item.getText());
1586             setMnemonicParsing(item.isMnemonicParsing());
1587             setLabelFor(mic);
1588         }
1589     }
1590 
1591 }
    </pre>
  </body>
</html>
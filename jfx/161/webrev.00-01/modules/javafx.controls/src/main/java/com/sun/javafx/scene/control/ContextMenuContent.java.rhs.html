<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/ContextMenuContent.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.javafx.scene.control;
  27 
  28 import com.sun.javafx.scene.NodeHelper;
  29 import com.sun.javafx.scene.control.behavior.TwoLevelFocusPopupBehavior;
  30 import com.sun.javafx.scene.control.skin.Utils;
  31 import com.sun.javafx.scene.traversal.Direction;
  32 import javafx.animation.Animation.Status;
  33 import javafx.animation.KeyFrame;
  34 import javafx.animation.Timeline;
  35 import javafx.beans.InvalidationListener;
  36 import javafx.beans.WeakInvalidationListener;
  37 import javafx.beans.property.ReadOnlyBooleanProperty;
  38 import javafx.beans.value.ChangeListener;
  39 import javafx.beans.value.ObservableValue;
  40 import javafx.collections.ListChangeListener;
  41 import javafx.collections.ObservableList;
  42 import javafx.css.CssMetaData;
  43 import javafx.css.PseudoClass;
  44 import javafx.css.Styleable;
  45 import javafx.event.ActionEvent;
  46 import javafx.event.EventHandler;
  47 import javafx.geometry.*;
  48 import javafx.scene.AccessibleAction;
  49 import javafx.scene.AccessibleAttribute;
  50 import javafx.scene.AccessibleRole;
  51 import javafx.scene.Node;
  52 import javafx.scene.Parent;
  53 import javafx.scene.control.*;
  54 import javafx.scene.input.KeyEvent;
  55 import javafx.scene.input.MouseEvent;
  56 import javafx.scene.input.ScrollEvent;
  57 import javafx.scene.layout.Region;
  58 import javafx.scene.layout.StackPane;
  59 import javafx.scene.layout.VBox;
  60 import javafx.scene.shape.Rectangle;
  61 import javafx.stage.Window;
  62 import javafx.util.Duration;
  63 
  64 import java.util.ArrayList;
  65 import java.util.Collections;
  66 import java.util.List;
  67 import java.util.Optional;
  68 
  69 /**
  70  * This is a the SkinBase for ContextMenu based controls so that the CSS parts
  71  * work right, because otherwise we would have to copy the Keys from there to here.
  72  */
  73 public class ContextMenuContent extends Region {
  74 
  75     private static final String ITEM_STYLE_CLASS_LISTENER = &quot;itemStyleClassListener&quot;;
  76 
  77     private ContextMenu contextMenu;
  78 
  79     /***************************************************************************
  80      * UI subcomponents
  81      **************************************************************************/
  82 
  83     private double maxGraphicWidth = 0; // we keep this margin to left for graphic
  84     private double maxRightWidth = 0;
  85     private double maxLabelWidth = 0;
  86     private double maxRowHeight = 0;
  87     private double maxLeftWidth = 0;
  88     private double oldWidth = 0;
  89 
  90     private Rectangle clipRect;
  91     MenuBox itemsContainer;
  92     private ArrowMenuItem upArrow;
  93     private ArrowMenuItem downArrow;
  94 
  95     /*
  96      * We maintain a current focused index which is used
  97      * in keyboard navigation of menu items.
  98      */
  99     private int currentFocusedIndex = -1;
 100 
 101     private boolean itemsDirty = true;
 102     private InvalidationListener popupShowingListener = arg0 -&gt; {
 103         updateItems();
 104     };
 105     private WeakInvalidationListener weakPopupShowingListener =
 106             new WeakInvalidationListener(popupShowingListener);
 107 
 108 
 109     /***************************************************************************
 110      * Constructors
 111      **************************************************************************/
 112     public ContextMenuContent(final ContextMenu popupMenu) {
 113         this.contextMenu = popupMenu;
 114         clipRect = new Rectangle();
 115          clipRect.setSmooth(false);
 116         itemsContainer = new MenuBox();
 117 //        itemsContainer = new VBox();
 118         itemsContainer.setClip(clipRect);
 119 
 120         upArrow = new ArrowMenuItem(this);
 121         upArrow.setUp(true);
 122         upArrow.setFocusTraversable(false);
 123 
 124         downArrow = new ArrowMenuItem(this);
 125         downArrow.setUp(false);
 126         downArrow.setFocusTraversable(false);
 127         getChildren().add(itemsContainer);
 128         getChildren().add(upArrow);
 129         getChildren().add(downArrow);
 130         initialize();
 131         setUpBinds();
 132         updateItems();
 133         // RT-20197 add menuitems only on first show.
 134         popupMenu.showingProperty().addListener(weakPopupShowingListener);
 135 
 136         /*
 137         ** only add this if we&#39;re on an embedded
 138         ** platform that supports 5-button navigation
 139         */
 140         if (Utils.isTwoLevelFocus()) {
 141             new TwoLevelFocusPopupBehavior(this);
 142         }
 143     }
 144 
 145     //For access from controls
 146     public VBox getItemsContainer() {
 147         return itemsContainer;
 148     }
 149     //For testing purpose only
 150     int getCurrentFocusIndex() {
 151         return currentFocusedIndex;
 152     }
 153     //For testing purpose only
 154     void setCurrentFocusedIndex(int index) {
 155         if (index &lt; itemsContainer.getChildren().size()) {
 156             currentFocusedIndex = index;
 157         }
 158     }
 159 
 160     private void updateItems() {
 161         if (itemsDirty) {
 162             updateVisualItems();
 163             itemsDirty = false;
 164         }
 165     }
 166 
 167     private void computeVisualMetrics() {
 168         maxRightWidth = 0;
 169         maxLabelWidth = 0;
 170         maxRowHeight = 0;
 171         maxGraphicWidth = 0;
 172         maxLeftWidth = 0;
 173 
 174         for (int i = 0; i &lt; itemsContainer.getChildren().size(); i++) {
 175             Node child = itemsContainer.getChildren().get(i);
 176             if (child instanceof MenuItemContainer) {
 177                 final MenuItemContainer menuItemContainer = (MenuItemContainer)itemsContainer.getChildren().get(i);
 178 
 179                 if (! menuItemContainer.isVisible()) continue;
 180 
 181                 double alt = -1;
 182                 Node n = menuItemContainer.left;
 183                 if (n != null) {
 184                     if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
 185                         alt = snapSizeY(n.prefHeight(-1));
 186                     } else alt = -1;
 187                     maxLeftWidth = Math.max(maxLeftWidth, snapSizeX(n.prefWidth(alt)));
 188                     maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
 189                 }
 190 
 191                 n = menuItemContainer.graphic;
 192                 if (n != null) {
 193                     if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
 194                         alt = snapSizeY(n.prefHeight(-1));
 195                     } else alt = -1;
 196                     maxGraphicWidth = Math.max(maxGraphicWidth, snapSizeX(n.prefWidth(alt)));
 197                     maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
 198                 }
 199 
 200                 n = menuItemContainer.label;
 201                 if (n != null) {
 202                     if (n.getContentBias() == Orientation.VERTICAL) {
 203                         alt = snapSizeY(n.prefHeight(-1));
 204                     } else alt = -1;
 205                     maxLabelWidth = Math.max(maxLabelWidth, snapSizeX(n.prefWidth(alt)));
 206                     maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
 207                 }
 208 
 209                 n = menuItemContainer.right;
 210                 if (n != null) {
 211                     if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
 212                         alt = snapSizeY(n.prefHeight(-1));
 213                     } else alt = -1;
 214                     maxRightWidth = Math.max(maxRightWidth, snapSizeX(n.prefWidth(alt)));
 215                     maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
 216                 }
 217             }
 218         }
 219 
 220         // Fix for RT-38838.
 221         // This fixes the issue where CSS is applied to a menu after it has been
 222         // showing, resulting in its bounds changing. In this case, we need to
 223         // shift the submenu such that it is properly aligned with its parent menu.
 224         //
 225         // To do this, we must firstly determine if the open submenu is shifted
 226         // horizontally to appear on the other side of this menu, as this is the
 227         // only situation where shifting has to happen. If so, we need to check
 228         // if we should shift the submenu due to changes in width.
 229         //
 230         // We need to get the parent menu of this contextMenu, so that we only
 231         // modify the X value in the following conditions:
 232         // 1) There exists a parent menu
 233         // 2) The parent menu is in the correct position (i.e. to the left of this
 234         //    menu in normal LTR systems).
 235         final double newWidth = maxRightWidth + maxLabelWidth + maxGraphicWidth + maxLeftWidth;
 236         Window ownerWindow = contextMenu.getOwnerWindow();
 237         if (ownerWindow instanceof ContextMenu) {
 238             if (contextMenu.getX() &lt; ownerWindow.getX()) {
 239                 if (oldWidth != newWidth) {
 240                     contextMenu.setX(contextMenu.getX() + oldWidth - newWidth);
 241                 }
 242             }
 243         }
 244 
 245         oldWidth = newWidth;
 246     }
 247 
 248     private void updateVisualItems() {
 249         ObservableList&lt;Node&gt; itemsContainerChilder = itemsContainer.getChildren();
 250 
 251         disposeVisualItems();
 252 
 253         for (int row = 0; row &lt; getItems().size(); row++) {
 254             final MenuItem item = getItems().get(row);
 255             if (item instanceof CustomMenuItem &amp;&amp; ((CustomMenuItem) item).getContent() == null) {
 256                 continue;
 257             }
 258 
 259             if (item instanceof SeparatorMenuItem) {
 260                 // we don&#39;t want the hover highlight for separators, so for
 261                 // now this is the simplest approach - just remove the
 262                 // background entirely. This may cause issues if people
 263                 // intend to style the background differently.
 264                 Node node = ((CustomMenuItem) item).getContent();
 265                 node.visibleProperty().bind(item.visibleProperty());
 266                 itemsContainerChilder.add(node);
 267                 // Add the (separator) menu item to properties map of this node.
 268                 // Special casing this for separator :
 269                 // This allows associating this container with SeparatorMenuItem.
 270                 node.getProperties().put(MenuItem.class, item);
 271             } else {
 272                 MenuItemContainer menuItemContainer = new MenuItemContainer(item);
 273                 menuItemContainer.visibleProperty().bind(item.visibleProperty());
 274                 itemsContainerChilder.add(menuItemContainer);
 275             }
 276         }
 277 
 278         // Add the Menu to properties map of this skin. Used by QA for testing
 279         // This enables associating a parent menu for this skin showing menu items.
 280         if (getItems().size() &gt; 0) {
 281             final MenuItem item = getItems().get(0);
 282             getProperties().put(Menu.class, item.getParentMenu());
 283         }
 284 
 285         // RT-36513 made this applyCss(). Modified by RT-36995 to NodeHelper.reapplyCSS()
 286         NodeHelper.reapplyCSS(this);
 287     }
 288 
 289     private void disposeVisualItems() {
 290         // clean up itemsContainer
 291         ObservableList&lt;Node&gt; itemsContainerChilder = itemsContainer.getChildren();
 292         for (int i = 0, max = itemsContainerChilder.size(); i &lt; max; i++) {
 293             Node n = itemsContainerChilder.get(i);
 294 
 295             if (n instanceof MenuItemContainer) {
 296                 MenuItemContainer container = (MenuItemContainer) n;
 297                 container.visibleProperty().unbind();
 298                 container.dispose();
 299             }
 300         }
 301         itemsContainerChilder.clear();
 302     }
 303 
 304     /**
 305      * Can be called by Skins when they need to clean up the content of any
 306      * ContextMenu instances they might have created. This ensures that contents
 307      * of submenus if any, also get cleaned up.
 308      */
 309     public void dispose() {
 310         disposeBinds();
 311         disposeVisualItems();
 312 
 313         disposeContextMenu(submenu);
 314         submenu = null;
 315         openSubmenu = null;
 316         selectedBackground = null;
 317         if (contextMenu != null) {
 318             contextMenu.getItems().clear();
 319             contextMenu = null;
 320         }
 321     }
 322 
 323     public void disposeContextMenu(ContextMenu menu) {
 324         if (menu == null) return;
 325 
 326         Skin&lt;?&gt; skin = menu.getSkin();
 327         if (skin == null) return;
 328 
 329         ContextMenuContent cmContent = (ContextMenuContent)skin.getNode();
 330         if (cmContent == null) return;
 331 
 332         cmContent.dispose(); // recursive call to dispose submenus.
 333     }
 334 
 335     @Override protected void layoutChildren() {
 336         if (itemsContainer.getChildren().size() == 0) return;
 337         final double x = snappedLeftInset();
 338         final double y = snappedTopInset();
 339         final double w = getWidth() - x - snappedRightInset();
 340         final double h = getHeight() - y - snappedBottomInset();
 341         final double contentHeight =  snapSizeY(getContentHeight()); // itemsContainer.prefHeight(-1);
 342 
 343         itemsContainer.resize(w,contentHeight);
 344         itemsContainer.relocate(x, y);
 345 
 346         if (isFirstShow &amp;&amp; ty == 0) {
 347             upArrow.setVisible(false);
 348             isFirstShow = false;
 349         } else {
 350             upArrow.setVisible(ty &lt; y &amp;&amp; ty &lt; 0);
 351         }
 352         downArrow.setVisible(ty + contentHeight &gt; (y + h));
 353 
 354         clipRect.setX(0);
 355         clipRect.setY(0);
 356         clipRect.setWidth(w);
 357         clipRect.setHeight(h);
 358 
 359         if (upArrow.isVisible()) {
 360             final double prefHeight = snapSizeY(upArrow.prefHeight(-1));
 361             clipRect.setHeight(snapSizeY(clipRect.getHeight() - prefHeight));
 362             clipRect.setY(snapSizeY(clipRect.getY()) + prefHeight);
 363             upArrow.resize(snapSizeX(upArrow.prefWidth(-1)), prefHeight);
 364             positionInArea(upArrow, x, y, w, prefHeight, /*baseline ignored*/0,
 365                     HPos.CENTER, VPos.CENTER);
 366         }
 367 
 368         if (downArrow.isVisible()) {
 369             final double prefHeight = snapSizeY(downArrow.prefHeight(-1));
 370             clipRect.setHeight(snapSizeY(clipRect.getHeight()) - prefHeight);
 371             downArrow.resize(snapSizeX(downArrow.prefWidth(-1)), prefHeight);
 372             positionInArea(downArrow, x, (y + h - prefHeight), w, prefHeight, /*baseline ignored*/0,
 373                     HPos.CENTER, VPos.CENTER);
 374         }
 375     }
 376 
 377      @Override protected double computePrefWidth(double height) {
 378          computeVisualMetrics();
 379          double prefWidth = 0;
 380          if (itemsContainer.getChildren().size() == 0) return 0;
 381          for (Node n : itemsContainer.getChildren()) {
 382              if (! n.isVisible()) continue;
 383              prefWidth = Math.max(prefWidth, snapSizeX(n.prefWidth(-1)));
 384          }
 385          return snappedLeftInset() + snapSizeX(prefWidth) + snappedRightInset();
 386     }
 387 
 388     @Override protected double computePrefHeight(double width) {
 389         if (itemsContainer.getChildren().size() == 0) return 0;
 390         final double screenHeight = getScreenHeight();
 391         final double contentHeight = getContentHeight(); // itemsContainer.prefHeight(width);
 392         double totalHeight = snappedTopInset() + snapSizeY(contentHeight) + snappedBottomInset();
 393         // the pref height of this menu is the smaller value of the
 394         // actual pref height and the height of the screens _visual_ bounds.
 395         double prefHeight = (screenHeight &lt;= 0) ? (totalHeight) : (Math.min(totalHeight, screenHeight));
 396         return prefHeight;
 397     }
 398 
 399     @Override protected double computeMinHeight(double width) {
 400         return 0.0;
 401     }
 402 
 403     @Override protected double computeMaxHeight(double height) {
 404         return getScreenHeight();
 405     }
 406 
 407     private double getScreenHeight() {
 408         if (contextMenu == null || contextMenu.getOwnerWindow() == null ||
 409                 contextMenu.getOwnerWindow().getScene() == null) {
 410             return -1;
 411         }
 412         return snapSizeY(com.sun.javafx.util.Utils.getScreen(
 413             contextMenu.getOwnerWindow().getScene().getRoot()).getVisualBounds().getHeight());
 414 
 415     }
 416 
 417     private double getContentHeight() {
 418         double h = 0.0d;
 419         for (Node i : itemsContainer.getChildren()) {
 420             if (i.isVisible()) {
 421                h += snapSizeY(i.prefHeight(-1));
 422             }
 423         }
 424         return h;
 425     }
 426 
 427     // This handles shifting ty when doing keyboard navigation.
 428     private void ensureFocusedMenuItemIsVisible(Node node) {
 429         if (node == null) return;
 430 
 431         final Bounds nodeBounds = node.getBoundsInParent();
 432         final Bounds clipBounds = clipRect.getBoundsInParent();
 433 
 434         if (nodeBounds.getMaxY() &gt;= clipBounds.getMaxY()) {
 435             // this is for moving down the menu
 436             scroll(-nodeBounds.getMaxY() + clipBounds.getMaxY());
 437         } else if (nodeBounds.getMinY() &lt;= clipBounds.getMinY()) {
 438             // this is for moving up the menu
 439             scroll(-nodeBounds.getMinY() + clipBounds.getMinY());
 440         }
 441     }
 442 
 443     protected ObservableList&lt;MenuItem&gt; getItems() {
 444         return contextMenu.getItems();
 445     }
 446 
 447     /**
 448      * Finds the index of currently focused item.
 449      */
 450     private int findFocusedIndex() {
 451          for (int i = 0; i &lt; itemsContainer.getChildren().size(); i++) {
 452             Node n = itemsContainer.getChildren().get(i);
 453             if (n.isFocused()) {
 454                 return i;
 455             }
 456         }
 457         return -1;
 458     }
 459 
 460     private boolean isFirstShow = true;
 461     private double ty;
 462 
 463     private void initialize() {
 464         // RT-19624 calling requestFocus inside layout was casuing repeated layouts.
 465         contextMenu.addEventHandler(Menu.ON_SHOWN, event -&gt; {
 466             currentFocusedIndex = -1;
 467             for (Node child : itemsContainer.getChildren()) {
 468                 if (child instanceof MenuItemContainer) {
 469                     final MenuItem item = ((MenuItemContainer)child).item;
 470                     // When the choiceBox popup is shown, if this menu item is selected
 471                     // do a requestFocus so CSS kicks in and the item is highlighted.
 472                     if (&quot;choice-box-menu-item&quot;.equals(item.getId())) {
 473                         if (((RadioMenuItem)item).isSelected()) {
 474                             child.requestFocus();
 475                             break;
 476                         }
 477                     }
 478                 }
 479 
 480             }
 481         });
 482 
 483 //        // FIXME For some reason getSkinnable()Behavior traversal functions don&#39;t
 484 //        // get called as expected, so I&#39;ve just put the important code below.
 485         // We use setOnKeyPressed here as we are not adding a listener to a public
 486         // event type (ContextMenuContent is not public API), and without this
 487         // we get the issue shown in RT-34429
 488         setOnKeyPressed(new EventHandler&lt;KeyEvent&gt;() {
 489             @Override public void handle(KeyEvent ke) {
 490                 switch (ke.getCode()) {
 491                     case LEFT:
 492                         if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
 493                             processRightKey(ke);
 494                         } else {
 495                             processLeftKey(ke);
 496                         }
 497                         break;
 498                     case RIGHT:
 499                         if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
 500                             processLeftKey(ke);
 501                         } else {
 502                             processRightKey(ke);
 503                         }
 504                         break;
 505                     case CANCEL:
 506                         ke.consume();
 507                         break;
 508                     case ESCAPE:
 509                         // if the owner is not a menubar button, just close the
 510                         // menu - this will move focus up to the parent menu
 511                         // as required. In the case of the parent being a
 512                         // menubar button we special case in the conditional code
 513                         // beneath this switch statement. See RT-34429 for more context.
 514                         final Node ownerNode = contextMenu.getOwnerNode();
 515                         if (! (ownerNode instanceof MenuBarButton)) {
 516                             contextMenu.hide();
 517                             ke.consume();
 518                         }
 519                         break;
 520                     case DOWN:
 521                         // move to the next sibling
 522                         move(Direction.NEXT);
 523                         ke.consume();
 524                         break;
 525                     case UP:
 526                         // move to previous sibling
 527                         move(Direction.PREVIOUS);
 528                         ke.consume();
 529                         break;
 530                     case SPACE:
 531                     case ENTER:
 532                         // select the menuitem
 533                         selectMenuItem();
 534                         ke.consume();
 535                         break;
 536                     default:
 537                         break;
 538                 }
 539 
 540                 if (!ke.isConsumed()) {
 541                     final Node ownerNode = contextMenu.getOwnerNode();
 542                     if (ownerNode instanceof MenuItemContainer) {
 543                         // Forward to parent menu
 544                         Parent parent = ownerNode.getParent();
 545                         while (parent != null &amp;&amp; !(parent instanceof ContextMenuContent)) {
 546                             parent = parent.getParent();
 547                         }
 548                         if (parent instanceof ContextMenuContent) {
 549                             parent.getOnKeyPressed().handle(ke);
 550                         }
 551                     } else if (ownerNode instanceof MenuBarButton) {
 552                         // the following code no longer appears necessary, but
 553                         // leaving in intact for now...
 554 //                        // This is a top-level MenuBar Menu, so forward event to MenuBar
 555 //                        MenuBarSkin mbs = ((MenuBarButton)ownerNode).getMenuBarSkin();
 556 //                        if (mbs != null &amp;&amp; mbs.getKeyEventHandler() != null) {
 557 //                            mbs.getKeyEventHandler().handle(ke);
 558 //                        }
 559                     }
 560                 }
 561             }
 562         });
 563 
 564         addEventHandler(ScrollEvent.SCROLL, event -&gt; {
 565             /*
 566              * we&#39;ll only scroll if the arrows are visible in the direction
 567              * that we&#39;re going, otherwise we go into empty space.
 568              */
 569             final double textDeltaY = event.getTextDeltaY();
 570             final double deltaY = event.getDeltaY();
 571             if ((downArrow.isVisible() &amp;&amp; (textDeltaY &lt; 0.0 || deltaY &lt; 0.0)) ||
 572                 (upArrow.isVisible() &amp;&amp; (textDeltaY &gt; 0.0 || deltaY &gt; 0.0))) {
 573 
 574                 switch(event.getTextDeltaYUnits()) {
 575                   case LINES:
 576                       /*
 577                       ** scroll lines, use the row height of selected row,
 578                       ** or row 0 if none selected
 579                       */
 580                       int focusedIndex = findFocusedIndex();
 581                       if (focusedIndex == -1) {
 582                           focusedIndex = 0;
 583                       }
 584                       double rowHeight = itemsContainer.getChildren().get(focusedIndex).prefHeight(-1);
 585                       scroll(textDeltaY * rowHeight);
 586                       break;
 587                   case PAGES:
 588                       /*
 589                       ** page scroll, scroll the menu height
 590                       */
 591                       scroll(textDeltaY * itemsContainer.getHeight());
 592                       break;
 593                   case NONE:
 594                       /*
 595                       ** pixel scroll
 596                       */
 597                       scroll(deltaY);
 598                       break;
 599                 }
 600                 event.consume();
 601             }
 602         });
 603     }
 604 
 605     private Optional&lt;Node&gt; getFocusedNode() {
 606         final List&lt;Node&gt; children = itemsContainer.getChildren();
 607         final boolean validIndex = currentFocusedIndex &gt;= 0 &amp;&amp; currentFocusedIndex &lt; children.size();
 608         return validIndex ? Optional.of(children.get(currentFocusedIndex)) : Optional.empty();
 609     }
 610 
 611     private void processLeftKey(KeyEvent ke) {
 612         getFocusedNode().ifPresent(n -&gt; {
 613             if (n instanceof MenuItemContainer) {
 614                 MenuItem item = ((MenuItemContainer)n).item;
 615                 if (item instanceof Menu) {
 616                     final Menu menu = (Menu) item;
 617 
 618                     // if the submenu for this menu is showing, hide it
 619                     if (menu == openSubmenu &amp;&amp; submenu != null &amp;&amp; submenu.isShowing()) {
 620                         hideSubmenu();
 621                         ke.consume();
 622                     }
 623                 }
 624             }
 625         });
 626     }
 627 
 628     private void processRightKey(KeyEvent ke) {
 629         getFocusedNode().ifPresent(n -&gt; {
 630             if (n instanceof MenuItemContainer) {
 631                 MenuItem item = ((MenuItemContainer)n).item;
 632                 if (item instanceof Menu) {
 633                     final Menu menu = (Menu) item;
 634                     if (menu.isDisable()) return;
 635                     selectedBackground = ((MenuItemContainer)n);
 636 
 637                     // RT-15103
 638                     // if submenu for this menu is already showing then do nothing
 639                     // Menubar will process the right key and move to the next menu
 640                     if (openSubmenu == menu &amp;&amp; submenu != null &amp;&amp; submenu.isShowing()) {
 641                         return;
 642                     }
 643 
 644                     showMenu(menu);
 645                     ke.consume();
 646                 }
 647             }
 648         });
 649     }
 650 
 651     private void showMenu(Menu menu) {
 652         menu.show();
 653 
<a name="2" id="anc2"></a><span class="line-modified"> 654         if (submenu == null) {</span>
<span class="line-modified"> 655             return;</span>
<span class="line-modified"> 656         }</span>
<span class="line-modified"> 657 </span>
<span class="line-modified"> 658         // request focus on the first item of the submenu after it is shown</span>
<span class="line-modified"> 659         ContextMenuContent cmContent = (ContextMenuContent)submenu.getSkin().getNode();</span>
<span class="line-modified"> 660         if (cmContent != null) {</span>
<span class="line-modified"> 661            if (cmContent.itemsContainer.getChildren().size() &gt; 0) {</span>
<span class="line-modified"> 662                cmContent.itemsContainer.getChildren().get(0).requestFocus();</span>
<span class="line-modified"> 663                cmContent.currentFocusedIndex = 0;</span>
<span class="line-modified"> 664            } else {</span>
<span class="line-modified"> 665                cmContent.requestFocus();</span>
<span class="line-added"> 666            }</span>
 667         }
 668     }
 669 
 670     private void selectMenuItem() {
 671         getFocusedNode().ifPresent(n -&gt; {
 672             if (n instanceof MenuItemContainer) {
 673                 MenuItem item = ((MenuItemContainer)n).item;
 674                 if (item instanceof Menu) {
 675                     final Menu menu = (Menu) item;
 676                     if (openSubmenu != null) {
 677                         hideSubmenu();
 678                     }
 679                     if (menu.isDisable()) return;
 680                     selectedBackground = ((MenuItemContainer)n);
 681                     menu.show();
 682                 } else {
 683                     ((MenuItemContainer)n).doSelect();
 684                 }
 685             }
 686         });
 687     }
 688 
 689     private void move(Direction dir) {
 690         int startIndex = currentFocusedIndex != -1 ? currentFocusedIndex : itemsContainer.getChildren().size();
 691         requestFocusOnIndex(findSibling(dir, startIndex));
 692     }
 693 
 694     private int findSibling(final Direction dir, final int startIndex) {
 695         final int childCount = itemsContainer.getChildren().size();
 696         int i = startIndex;
 697         do {
 698             if (dir.isForward() &amp;&amp; i &gt;= childCount - 1) {
 699                 // loop to zero
 700                 i = 0;
 701             } else if (!dir.isForward() &amp;&amp; i == 0) {
 702                 // loop to end
 703                 i = childCount - 1;
 704             } else {
 705                 i += (dir.isForward() ? 1 : -1);
 706             }
 707 
 708             Node n = itemsContainer.getChildren().get(i);
 709             if (n instanceof MenuItemContainer &amp;&amp; n.isVisible()) {
 710                 return i;
 711             }
 712         } while (i != startIndex);
 713         return -1;
 714     }
 715 
 716     public void requestFocusOnIndex(int index) {
 717         currentFocusedIndex = index;
 718         Node n = itemsContainer.getChildren().get(index);
 719         selectedBackground = ((MenuItemContainer)n);
 720         n.requestFocus();
 721         ensureFocusedMenuItemIsVisible(n);
 722     }
 723 
 724     /*
 725      * Get the Y offset from the top of the popup to the menu item whose index
 726      * is given.
 727      */
 728     public double getMenuYOffset(int menuIndex) {
 729         double offset = 0;
 730         if (itemsContainer.getChildren().size() &gt; menuIndex) {
 731             offset = snappedTopInset();
 732             Node menuitem = itemsContainer.getChildren().get(menuIndex);
 733             offset += menuitem.getLayoutY() + menuitem.prefHeight(-1);
 734         }
 735         return offset;
 736     }
 737 
 738     private void setUpBinds() {
 739         updateMenuShowingListeners(contextMenu.getItems(), true);
 740         contextMenu.getItems().addListener(contextMenuItemsListener);
 741     }
 742 
 743     private void disposeBinds() {
 744         updateMenuShowingListeners(contextMenu.getItems(), false);
 745         contextMenu.getItems().removeListener(contextMenuItemsListener);
 746     }
 747 
 748     private ChangeListener&lt;Boolean&gt; menuShowingListener = (observable, wasShowing, isShowing) -&gt; {
 749         ReadOnlyBooleanProperty isShowingProperty = (ReadOnlyBooleanProperty) observable;
 750         Menu menu = (Menu) isShowingProperty.getBean();
 751 
 752         if (wasShowing &amp;&amp; ! isShowing) {
 753             // hide the submenu popup
 754             hideSubmenu();
 755         } else if (! wasShowing &amp;&amp; isShowing) {
 756             // show the submenu popup
 757             showSubmenu(menu);
 758         }
 759     };
 760 
 761     private ListChangeListener&lt;MenuItem&gt; contextMenuItemsListener = (ListChangeListener&lt;MenuItem&gt;) c -&gt; {
 762         // Add listeners to the showing property of all menus that have
 763         // been added, and remove listeners from menus that have been removed
 764         // FIXME this is temporary - we should be adding and removing
 765         // listeners such that they use the one listener defined above
 766         // - but that can&#39;t be done until we have the bean in the
 767         // ObservableValue
 768         while (c.next()) {
 769             updateMenuShowingListeners(c.getRemoved(), false);
 770             updateMenuShowingListeners(c.getAddedSubList(), true);
 771         }
 772 
 773         // Listener to items in PopupMenu to update items in PopupMenuContent
 774         itemsDirty = true;
 775         updateItems(); // RT-29761
 776     };
 777 
 778     private ChangeListener&lt;Boolean&gt; menuItemVisibleListener = (observable, oldValue, newValue) -&gt; {
 779         // re layout as item&#39;s visibility changed
 780         requestLayout();
 781     };
 782 
 783     private void updateMenuShowingListeners(List&lt;? extends MenuItem&gt; items, boolean addListeners) {
 784         for (MenuItem item : items) {
 785             if (item instanceof Menu) {
 786                 final Menu menu = (Menu) item;
 787 
 788                 if (addListeners) {
 789                     menu.showingProperty().addListener(menuShowingListener);
 790                 } else {
 791                     menu.showingProperty().removeListener(menuShowingListener);
 792                 }
 793             }
 794 
 795              // listen to menu items&#39;s visible property.
 796             if (addListeners) {
 797                 item.visibleProperty().addListener(menuItemVisibleListener);
 798             } else {
 799                 item.visibleProperty().removeListener(menuItemVisibleListener);
 800             }
 801         }
 802     }
 803 
 804     // For test purpose only
 805     ContextMenu getSubMenu() {
 806         return submenu;
 807     }
 808 
 809     Menu getOpenSubMenu() {
 810         return openSubmenu;
 811     }
 812 
 813     private void createSubmenu() {
 814         if (submenu == null) {
 815             submenu = new ContextMenu();
 816             submenu.showingProperty().addListener(new ChangeListener&lt;Boolean&gt;() {
 817                 @Override public void changed(ObservableValue&lt;? extends Boolean&gt; observable,
 818                                               Boolean oldValue, Boolean newValue) {
 819                     if (!submenu.isShowing()) {
 820                         // Maybe user clicked outside or typed ESCAPE.
 821                         // Make sure menus are in sync.
 822                         for (Node node : itemsContainer.getChildren()) {
 823                             if (node instanceof MenuItemContainer
 824                                   &amp;&amp; ((MenuItemContainer)node).item instanceof Menu) {
 825                                 Menu menu = (Menu)((MenuItemContainer)node).item;
 826                                 if (menu.isShowing()) {
 827                                     menu.hide();
 828                                 }
 829                             }
 830                         }
 831                     }
 832                 }
 833             });
 834         }
 835     }
 836 
 837     private void showSubmenu(Menu menu) {
 838         openSubmenu = menu;
 839         createSubmenu();
 840         submenu.getItems().setAll(menu.getItems());
 841         submenu.show(selectedBackground, Side.RIGHT, 0, 0);
 842     }
 843 
 844     private void hideSubmenu() {
 845         if (submenu == null) return;
 846 
 847         submenu.hide();
 848         openSubmenu = null;
 849 
 850         // Fix for RT-37022 - we dispose content so that we do not process CSS
 851         // on hidden submenus
 852         disposeContextMenu(submenu);
 853         submenu = null;
 854 
 855         // Fix for JDK-8158679 - we put the focus on the menu, and then back
 856         // on the menu item, so that screen readers can properly speak out
 857         // the menu item.
 858         getFocusedNode().ifPresent(n -&gt; {
 859             requestFocus();
 860             n.requestFocus();
 861         });
 862     }
 863 
 864     private void hideAllMenus(MenuItem item) {
 865         if (contextMenu != null) contextMenu.hide();
 866 
 867         Menu parentMenu;
 868         while ((parentMenu = item.getParentMenu()) != null) {
 869             parentMenu.hide();
 870             item = parentMenu;
 871         }
 872         if (item.getParentPopup() != null) {
 873             item.getParentPopup().hide();
 874         }
 875     }
 876 
 877     private Menu openSubmenu;
 878     private ContextMenu submenu;
 879 
 880     // FIXME: HACKY. We use this so that a submenu knows where to open from
 881     // but this will only work for mouse hovers currently - and won&#39;t work
 882     // programmatically.
 883     // package protected for testing only!
 884     Region selectedBackground;
 885 
 886     void scroll(double delta) {
 887         double newTy = ty + delta;
 888         if (ty == newTy) return;
 889 
 890         // translation should never be positive (this would mean the top of the
 891         // menu content is detaching from the top of the menu!)
 892         if (newTy &gt; 0.0) {
 893             newTy = 0.0;
 894         }
 895 
 896         // translation should never be greater than the preferred height of the
 897         // menu content (otherwise the menu content will be detaching from the
 898         // bottom of the menu).
 899         // RT-37185: We check the direction of the scroll, to prevent it locking
 900         // up when scrolling upwards from the very bottom (using the on-screen
 901         // up arrow).
 902         if (delta &lt; 0 &amp;&amp; (getHeight() - newTy) &gt; itemsContainer.getHeight() - downArrow.getHeight()) {
 903             newTy = getHeight() - itemsContainer.getHeight() - downArrow.getHeight();
 904         }
 905 
 906         ty = newTy;
 907         itemsContainer.requestLayout();
 908     }
 909 
 910     /***************************************************************************
 911      *                                                                         *
 912      *                         Stylesheet Handling                             *
 913      *                                                                         *
 914      **************************************************************************/
 915     @Override public Styleable getStyleableParent() {
 916         return contextMenu;
 917     }
 918 
 919     private static class StyleableProperties {
 920 
 921         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
 922         static {
 923 
 924             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
 925                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Region.getClassCssMetaData());
 926 
 927             //
 928             // SkinBase only has Region&#39;s unique StlyleableProperty&#39;s, none of Nodes
 929             // So, we need to add effect back in. The effect property is in a
 930             // private inner class, so get the property from Node the hard way.
 931             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; nodeStyleables = Node.getClassCssMetaData();
 932             for(int n=0, max=nodeStyleables.size(); n&lt;max; n++) {
 933                 CssMetaData&lt;? extends Styleable, ?&gt; styleable = nodeStyleables.get(n);
 934                 if (&quot;effect&quot;.equals(styleable.getProperty())) {
 935                     styleables.add(styleable);
 936                     break;
 937                 }
 938             }
 939             STYLEABLES = Collections.unmodifiableList(styleables);
 940         }
 941     }
 942 
 943     /**
 944      * @return The CssMetaData associated with this class, which may include the
 945      * CssMetaData of its superclasses.
 946      */
 947     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
 948         return StyleableProperties.STYLEABLES;
 949     }
 950 
 951     /**
 952      * {@inheritDoc}
 953      */
 954     @Override
 955     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
 956         return getClassCssMetaData();
 957     }
 958 
 959     public Label getLabelAt(int index) {
 960         return ((MenuItemContainer)itemsContainer.getChildren().get(index)).getLabel();
 961     }
 962 
 963     /**
 964      * Custom VBox to enable scrolling of items. Scrolling effect is achieved by
 965      * controlling the translate Y coordinate of the menu item &quot;ty&quot; which is set by a
 966      * timeline when mouse is over up/down arrow.
 967      */
 968     class MenuBox extends VBox {
 969         MenuBox() {
 970             setAccessibleRole(AccessibleRole.CONTEXT_MENU);
 971         }
 972 
 973         @Override protected void layoutChildren() {
 974             double yOffset = ty;
 975             for (Node n : getChildren()) {
 976                 if (n.isVisible()) {
 977                     final double prefHeight = snapSizeY(n.prefHeight(-1));
 978                     n.resize(snapSizeX(getWidth()), prefHeight);
 979                     n.relocate(snappedLeftInset(), yOffset);
 980                     yOffset += prefHeight;
 981                 }
 982             }
 983         }
 984 
 985         /** {@inheritDoc} */
 986         @Override
 987         public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
 988             switch (attribute) {
 989                 case VISIBLE: return contextMenu.isShowing();
 990                 case PARENT_MENU: return contextMenu.getOwnerNode();
 991                 default: return super.queryAccessibleAttribute(attribute, parameters);
 992             }
 993         }
 994     }
 995 
 996     class ArrowMenuItem extends StackPane {
 997          private StackPane upDownArrow;
 998          private ContextMenuContent popupMenuContent;
 999          private boolean up = false;
1000          public final boolean isUp() { return up; }
1001          public void setUp(boolean value) {
1002             up = value;
1003             upDownArrow.getStyleClass().setAll(isUp() ? &quot;menu-up-arrow&quot; : &quot;menu-down-arrow&quot;);
1004         }
1005 
1006         // used to automatically scroll through menu items when the user performs
1007         // certain interactions, e.g. pressing and holding the arrow buttons
1008         private Timeline scrollTimeline;
1009 
1010         public ArrowMenuItem(ContextMenuContent pmc) {
1011             getStyleClass().setAll(&quot;scroll-arrow&quot;);
1012             upDownArrow = new StackPane();
1013             this.popupMenuContent = pmc;
1014             upDownArrow.setMouseTransparent(true);
1015             upDownArrow.getStyleClass().setAll(isUp() ? &quot;menu-up-arrow&quot; : &quot;menu-down-arrow&quot;);
1016     //        setMaxWidth(Math.max(upDownArrow.prefWidth(-1), getWidth()));
1017             addEventHandler(MouseEvent.MOUSE_ENTERED, me -&gt; {
1018                 if (scrollTimeline != null &amp;&amp; (scrollTimeline.getStatus() != Status.STOPPED)) {
1019                     return;
1020                 }
1021                 startTimeline();
1022             });
1023             addEventHandler(MouseEvent.MOUSE_EXITED, me -&gt; {
1024                 stopTimeline();
1025             });
1026             setVisible(false);
1027             setManaged(false);
1028             getChildren().add(upDownArrow);
1029         }
1030 
1031         @Override protected double computePrefWidth(double height) {
1032 //            return snapSize(getInsets().getLeft()) + snapSize(getInsets().getRight());
1033             return itemsContainer.getWidth();
1034         }
1035 
1036         @Override protected double computePrefHeight(double width) {
1037             return snappedTopInset() + upDownArrow.prefHeight(-1) + snappedBottomInset();
1038         }
1039 
1040         @Override protected void layoutChildren() {
1041             double w = snapSizeX(upDownArrow.prefWidth(-1));
1042             double h = snapSizeY(upDownArrow.prefHeight(-1));
1043 
1044             upDownArrow.resize(w, h);
1045             positionInArea(upDownArrow, 0, 0, getWidth(), getHeight(),
1046                     /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
1047         }
1048 
1049         private void adjust() {
1050             if(up) popupMenuContent.scroll(12); else popupMenuContent.scroll(-12);
1051         }
1052 
1053         private void startTimeline() {
1054             scrollTimeline = new Timeline();
1055             scrollTimeline.setCycleCount(Timeline.INDEFINITE);
1056             KeyFrame kf = new KeyFrame(
1057                 Duration.millis(60),
1058                     event -&gt; {
1059                         adjust();
1060                     }
1061             );
1062             scrollTimeline.getKeyFrames().clear();
1063             scrollTimeline.getKeyFrames().add(kf);
1064             scrollTimeline.play();
1065         }
1066 
1067         private void stopTimeline() {
1068             scrollTimeline.stop();
1069             scrollTimeline = null;
1070         }
1071     }
1072 
1073     /*
1074      * Container responsible for laying out a single row in the menu - in other
1075      * words, this contains and lays out a single MenuItem, regardless of it&#39;s
1076      * specific subtype.
1077      */
1078     public class MenuItemContainer extends Region {
1079 
1080         private final MenuItem item;
1081 
1082         private Node left;
1083         private Node graphic;
1084         private Node label;
1085         private Node right;
1086 
1087         private final LambdaMultiplePropertyChangeListenerHandler listener =
1088             new LambdaMultiplePropertyChangeListenerHandler();
1089 
1090         private EventHandler&lt;MouseEvent&gt; mouseEnteredEventHandler;
1091         private EventHandler&lt;MouseEvent&gt; mouseReleasedEventHandler;
1092 
1093         private EventHandler&lt;ActionEvent&gt; actionEventHandler;
1094 
1095         protected Label getLabel(){
1096             return (Label) label;
1097         }
1098 
1099         public MenuItem getItem() {
1100             return item;
1101         }
1102 
1103         public MenuItemContainer(MenuItem item){
1104             if (item == null) {
1105                 throw new NullPointerException(&quot;MenuItem can not be null&quot;);
1106             }
1107 
1108             getStyleClass().addAll(item.getStyleClass());
1109             setId(item.getId());
1110             setFocusTraversable(!(item instanceof CustomMenuItem));
1111             this.item = item;
1112 
1113             createChildren();
1114 
1115             // listen to changes in the state of certain MenuItem types
1116             ReadOnlyBooleanProperty pseudoProperty;
1117             if (item instanceof Menu) {
1118                 pseudoProperty = ((Menu)item).showingProperty();
1119                 listener.registerChangeListener(pseudoProperty,
1120                         e -&gt; pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, ((Menu) item).isShowing()));
1121                 pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, pseudoProperty.get());
1122                 setAccessibleRole(AccessibleRole.MENU);
1123             } else if (item instanceof RadioMenuItem) {
1124                 pseudoProperty = ((RadioMenuItem)item).selectedProperty();
1125                 listener.registerChangeListener(pseudoProperty,
1126                         e -&gt; pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, ((RadioMenuItem) item).isSelected()));
1127                 pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, pseudoProperty.get());
1128                 setAccessibleRole(AccessibleRole.RADIO_MENU_ITEM);
1129             } else if (item instanceof CheckMenuItem) {
1130                 pseudoProperty = ((CheckMenuItem)item).selectedProperty();
1131                 listener.registerChangeListener(pseudoProperty,
1132                         e -&gt; pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, ((CheckMenuItem) item).isSelected()));
1133                 pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, pseudoProperty.get());
1134                 setAccessibleRole(AccessibleRole.CHECK_MENU_ITEM);
1135             } else {
1136                 setAccessibleRole(AccessibleRole.MENU_ITEM);
1137             }
1138 
1139             pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, item.disableProperty().get());
1140             listener.registerChangeListener(item.disableProperty(),
1141                     e -&gt; pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, item.isDisable()));
1142 
1143             // Add the menu item to properties map of this node. Used by QA for testing
1144             // This allows associating this container with corresponding MenuItem.
1145             getProperties().put(MenuItem.class, item);
1146 
1147             listener.registerChangeListener(item.graphicProperty(), e -&gt; {
1148                 createChildren();
1149                 computeVisualMetrics();
1150             });
1151 
1152             actionEventHandler = e -&gt; {
1153                 if (item instanceof Menu) {
1154                     final Menu menu = (Menu) item;
1155                     if (openSubmenu == menu &amp;&amp; submenu.isShowing()) return;
1156                     if (openSubmenu != null) {
1157                         hideSubmenu();
1158                     }
1159 
1160                     selectedBackground = MenuItemContainer.this;
1161                     showMenu(menu);
1162                 } else {
1163                     doSelect();
1164                 }
1165             };
1166             addEventHandler(ActionEvent.ACTION, actionEventHandler);
1167         }
1168 
1169         public void dispose() {
1170             if (item instanceof CustomMenuItem) {
1171                 Node node = ((CustomMenuItem)item).getContent();
1172                 if (node != null) {
1173                     node.removeEventHandler(MouseEvent.MOUSE_CLICKED, customMenuItemMouseClickedHandler);
1174                 }
1175             }
1176 
1177             listener.dispose();
1178             removeEventHandler(ActionEvent.ACTION, actionEventHandler);
1179 
1180             if (label != null) {
1181                 ((Label)label).textProperty().unbind();
1182                 label.styleProperty().unbind();
1183                 label.idProperty().unbind();
1184 
1185                 ListChangeListener&lt;String&gt; itemStyleClassListener = (ListChangeListener&lt;String&gt;)item.getProperties().remove(ITEM_STYLE_CLASS_LISTENER);
1186                 if (itemStyleClassListener != null) {
1187                     item.getStyleClass().removeListener(itemStyleClassListener);
1188                 }
1189             }
1190 
1191             left = null;
1192             graphic = null;
1193             label = null;
1194             right = null;
1195         }
1196 
1197         private void createChildren() {
1198             getChildren().clear();
1199 
1200             // draw background region for hover effects. All content (other
1201             // than Nodes from NodeMenuItems) are set to be mouseTransparent, so
1202             // this background also acts as the receiver of user input
1203             if (item instanceof CustomMenuItem) {
1204                 createNodeMenuItemChildren((CustomMenuItem)item);
1205 
1206                 if (mouseEnteredEventHandler == null) {
1207                     mouseEnteredEventHandler = event -&gt; {
1208                         requestFocus(); // request Focus on hover
1209                     };
1210                 } else {
1211                     removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
1212                 }
1213                 addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
1214             } else {
1215                 // --- add check / radio to left column
1216                 Node leftNode = getLeftGraphic(item);
1217                 if (leftNode != null) {
1218                     StackPane leftPane = new StackPane();
1219                     leftPane.getStyleClass().add(&quot;left-container&quot;);
1220                     leftPane.getChildren().add(leftNode);
1221                     left = leftPane;
1222                     getChildren().add(left);
1223                     left.setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
1224                 }
1225                 // -- add graphic to graphic pane
1226                 if (item.getGraphic() != null) {
1227                     Node graphicNode = item.getGraphic();
1228                     StackPane graphicPane = new StackPane();
1229                     graphicPane.getStyleClass().add(&quot;graphic-container&quot;);
1230                     graphicPane.getChildren().add(graphicNode);
1231                     graphic = graphicPane;
1232                     getChildren().add(graphic);
1233                 }
1234 
1235                 // --- add text to center column
1236                 label = new MenuLabel(item, this);  // make this a menulabel to handle mnemonics fire()
1237 
1238                 // set up bindings from the MenuItem into the Label
1239                 ((Label)label).textProperty().bind(item.textProperty());
1240                 label.styleProperty().bind(item.styleProperty());
1241                 label.idProperty().bind(item.styleProperty());
1242 
1243                 // we want to ensure that any styleclasses set on the menuitem are applied to the
1244                 // label (so we can style appropriately), but we can&#39;t just do a binding such as this:
1245                 // Bindings.bindContent(label.getStyleClass(), item.getStyleClass());
1246                 // Because that means we overwrite the &#39;label&#39; style class on the Label.
1247                 // What we really want is to ensure all style classes in the MenuItem are _copied_
1248                 // into the label, which is what we do below
1249                 ListChangeListener&lt;String&gt; itemStyleClassListener = c -&gt; {
1250                     while (c.next()) {
1251                         label.getStyleClass().removeAll(c.getRemoved());
1252                         label.getStyleClass().addAll(c.getAddedSubList());
1253                     }
1254                 };
1255                 item.getStyleClass().addListener(itemStyleClassListener);
1256                 item.getProperties().put(ITEM_STYLE_CLASS_LISTENER, itemStyleClassListener);
1257 
1258 
1259                 label.setMouseTransparent(true);
1260                 getChildren().add(label);
1261 
1262                 listener.unregisterChangeListeners(focusedProperty());
1263                 // RT-19546 update currentFocusedIndex when MenuItemContainer gets focused.
1264                 // e.g this happens when you press the Right key to open a submenu; the first
1265                 // menuitem is focused.
1266                 listener.registerChangeListener(focusedProperty(), e -&gt; {
1267                     if (isFocused()) {
1268                         currentFocusedIndex = itemsContainer.getChildren().indexOf(MenuItemContainer.this);
1269                     }
1270                 });
1271 
1272                 // --- draw in right column - this depends on whether we are
1273                 // a Menu or not. A Menu gets an arrow, whereas other MenuItems
1274                 // get the ability to draw an accelerator
1275                 if (item instanceof Menu) {
1276                     // --- add arrow / accelerator / mnemonic to right column
1277                     Region rightNode = new Region();
1278                     rightNode.setMouseTransparent(true);
1279                     rightNode.getStyleClass().add(&quot;arrow&quot;);
1280 
1281                     StackPane rightPane = new StackPane();
1282                     rightPane.setMaxWidth(Math.max(rightNode.prefWidth(-1), 10));
1283                     rightPane.setMouseTransparent(true);
1284                     rightPane.getStyleClass().add(&quot;right-container&quot;);
1285                     rightPane.getChildren().add(rightNode);
1286                     right = rightPane;
1287                     getChildren().add(rightPane);
1288 
1289                     if (mouseEnteredEventHandler == null) {
1290                         mouseEnteredEventHandler = event -&gt; {
1291                             if (openSubmenu != null &amp;&amp; item != openSubmenu) {
1292                                 // if a submenu of a different menu is already
1293                                 // open then close it (RT-15049)
1294                                 hideSubmenu();
1295                             }
1296 
1297                             selectedBackground = MenuItemContainer.this;
1298                             requestFocus();  // request Focus on hover
1299                             final Menu menu = (Menu) item;
1300                             if (menu.isDisable()) return;
1301                             menu.show();
1302                         };
1303                     } else {
1304                         removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
1305                     }
1306 
1307                     if (mouseReleasedEventHandler == null) {
1308                         mouseReleasedEventHandler = event -&gt; {
1309                             item.fire();
1310                         };
1311                     } else {
1312                         removeEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
1313                     }
1314 
1315                     // show submenu when the menu is hovered over
1316                     addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
1317                     addEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
1318                 } else { // normal MenuItem
1319                     // remove old listeners
1320                     listener.unregisterChangeListeners(item.acceleratorProperty());
1321 
1322                     // accelerator support
1323                     updateAccelerator();
1324 
1325                     if (mouseEnteredEventHandler == null) {
1326                         mouseEnteredEventHandler = event -&gt; {
1327                             if (openSubmenu != null) {
1328                                 openSubmenu.hide();
1329                             }
1330                             requestFocus();  // request Focus on hover
1331                         };
1332                     } else {
1333                         removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
1334                     }
1335 
1336                     if (mouseReleasedEventHandler == null) {
1337                         mouseReleasedEventHandler = event -&gt; {
1338                             doSelect();
1339                         };
1340                     } else {
1341                         removeEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
1342                     }
1343 
1344                     addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
1345                     addEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
1346 
1347                     listener.registerChangeListener(item.acceleratorProperty(), e -&gt; updateAccelerator());
1348                 }
1349             }
1350         }
1351 
1352         private void updateAccelerator() {
1353             if (item.getAccelerator() != null) {
1354                 if (right != null) {
1355                     getChildren().remove(right);
1356                 }
1357 
1358                 String text = item.getAccelerator().getDisplayText();
1359                 right = new Label(text);
1360                 right.setStyle(item.getStyle());
1361                 right.getStyleClass().add(&quot;accelerator-text&quot;);
1362                 getChildren().add(right);
1363             } else {
1364                 getChildren().remove(right);
1365             }
1366         }
1367 
1368         void doSelect() {
1369             // don&#39;t do anything on disabled menu items
1370             if (item.isDisable()) return;
1371             // toggle state of check or radio items
1372             if (item instanceof CheckMenuItem) {
1373                 CheckMenuItem checkItem = (CheckMenuItem)item;
1374                 checkItem.setSelected(!checkItem.isSelected());
1375             } else if (item instanceof RadioMenuItem) {
1376                 // this is a radio button. If there is a toggleGroup specified, we
1377                 // simply set selected to true. If no toggleGroup is specified, we
1378                 // toggle the selected state, as there is no assumption of mutual
1379                 // exclusivity when no toggleGroup is set.
1380                 final RadioMenuItem radioItem = (RadioMenuItem) item;
1381                 radioItem.setSelected(radioItem.getToggleGroup() != null ? true : !radioItem.isSelected());
1382             }
1383 
1384             // fire the action before hiding the menu
1385             item.fire();
1386 
1387             if (item instanceof CustomMenuItem) {
1388                 CustomMenuItem customMenuItem = (CustomMenuItem) item;
1389                 if (customMenuItem.isHideOnClick()) {
1390                     hideAllMenus(item);
1391                 }
1392             } else {
1393                 hideAllMenus(item);
1394             }
1395         }
1396 
1397         private EventHandler&lt;MouseEvent&gt; customMenuItemMouseClickedHandler;
1398 
1399         private void createNodeMenuItemChildren(final CustomMenuItem item) {
1400             Node node = item.getContent();
1401             getChildren().add(node);
1402 
1403             // handle hideOnClick
1404             customMenuItemMouseClickedHandler = event -&gt; {
1405                 if (item == null || item.isDisable()) return;
1406 
1407                 item.fire();
1408                 if (item.isHideOnClick()) {
1409                     hideAllMenus(item);
1410                 }
1411             };
1412             node.addEventHandler(MouseEvent.MOUSE_CLICKED, customMenuItemMouseClickedHandler);
1413         }
1414 
1415         @Override protected void layoutChildren() {
1416             double xOffset;
1417 
1418             final double prefHeight = prefHeight(-1);
1419             if (left != null) {
1420                 xOffset = snappedLeftInset();
1421                 left.resize(left.prefWidth(-1), left.prefHeight(-1));
1422                 positionInArea(left, xOffset, 0,
1423                         maxLeftWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
1424             }
1425             if (graphic != null) {
1426                 xOffset = snappedLeftInset() + maxLeftWidth;
1427                 graphic.resize(graphic.prefWidth(-1), graphic.prefHeight(-1));
1428                 positionInArea(graphic, xOffset, 0,
1429                         maxGraphicWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
1430             }
1431 
1432             if (label != null) {
1433                 xOffset = snappedLeftInset() + maxLeftWidth + maxGraphicWidth;
1434                 label.resize(label.prefWidth(-1), label.prefHeight(-1));
1435                 positionInArea(label, xOffset, 0,
1436                         maxLabelWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
1437             }
1438 
1439             if (right != null) {
1440                 xOffset = snappedLeftInset() + maxLeftWidth + maxGraphicWidth + maxLabelWidth;
1441                 right.resize(right.prefWidth(-1), right.prefHeight(-1));
1442                 positionInArea(right, xOffset, 0,
1443                     maxRightWidth, prefHeight, 0, HPos.RIGHT, VPos.CENTER);
1444             }
1445 
1446             if ( item instanceof CustomMenuItem) {
1447                 Node n = ((CustomMenuItem) item).getContent();
1448                 if (item instanceof SeparatorMenuItem) {
1449                     double width = prefWidth(-1) - (snappedLeftInset() + maxGraphicWidth + snappedRightInset());
1450                     n.resize(width, n.prefHeight(-1));
1451                     positionInArea(n, snappedLeftInset() + maxGraphicWidth, 0, prefWidth(-1), prefHeight, 0, HPos.LEFT, VPos.CENTER);
1452                 } else {
1453                     n.resize(n.prefWidth(-1), n.prefHeight(-1));
1454                     //the node should be left aligned
1455                     positionInArea(n, snappedLeftInset(), 0, getWidth(), prefHeight, 0, HPos.LEFT, VPos.CENTER);
1456                 }
1457             }
1458         }
1459 
1460         @Override protected double computePrefHeight(double width) {
1461             double prefHeight = 0;
1462             if (item instanceof CustomMenuItem || item instanceof SeparatorMenuItem) {
1463                 prefHeight = (getChildren().isEmpty()) ? 0 : getChildren().get(0).prefHeight(-1);
1464             } else {
1465                 prefHeight = Math.max(prefHeight, (left != null) ? left.prefHeight(-1) : 0);
1466                 prefHeight = Math.max(prefHeight, (graphic != null) ? graphic.prefHeight(-1) : 0);
1467                 prefHeight = Math.max(prefHeight, (label != null) ? label.prefHeight(-1) : 0);
1468                 prefHeight = Math.max(prefHeight, (right != null) ? right.prefHeight(-1) : 0);
1469             }
1470              return snappedTopInset() + prefHeight + snappedBottomInset();
1471         }
1472 
1473         @Override protected double computePrefWidth(double height) {
1474             double nodeMenuItemWidth = 0;
1475             if (item instanceof CustomMenuItem &amp;&amp; !(item instanceof SeparatorMenuItem)) {
1476                 nodeMenuItemWidth = snappedLeftInset() + ((CustomMenuItem) item).getContent().prefWidth(-1) +
1477                         snappedRightInset();
1478             }
1479             return Math.max(nodeMenuItemWidth,
1480                     snappedLeftInset() + maxLeftWidth + maxGraphicWidth +
1481                     maxLabelWidth + maxRightWidth + snappedRightInset());
1482         }
1483 
1484         // Responsible for returning a graphic (if necessary) to position in the
1485         // left column of the menu. This may be a Node from the MenuItem.graphic
1486         // property, or it may be a check/radio item if necessary.
1487         private Node getLeftGraphic(MenuItem item) {
1488             if (item instanceof RadioMenuItem) {
1489                  final Region _graphic = new Region();
1490                 _graphic.getStyleClass().add(&quot;radio&quot;);
1491                 return _graphic;
1492             } else if (item instanceof CheckMenuItem) {
1493                 final StackPane _graphic = new StackPane();
1494                 _graphic.getStyleClass().add(&quot;check&quot;);
1495                 return _graphic;
1496             }
1497 
1498             return null;
1499         }
1500 
1501         /** {@inheritDoc} */
1502         @Override
1503         public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1504             switch (attribute) {
1505                 case SELECTED:
1506                     if (item instanceof CheckMenuItem) {
1507                         return ((CheckMenuItem)item).isSelected();
1508                     }
1509                     if (item instanceof RadioMenuItem) {
1510                         return ((RadioMenuItem) item).isSelected();
1511                     }
1512                     return false;
1513                 case ACCELERATOR: return item.getAccelerator();
1514                 case TEXT: {
1515                     String title = &quot;&quot;;
1516                     if (graphic != null) {
1517                         String t = (String)graphic.queryAccessibleAttribute(AccessibleAttribute.TEXT);
1518                         if (t != null) title += t;
1519                     }
1520                     final Label label = getLabel();
1521                     if (label != null) {
1522                         String t = (String)label.queryAccessibleAttribute(AccessibleAttribute.TEXT);
1523                         if (t != null) title += t;
1524                     }
1525                     if (item instanceof CustomMenuItem) {
1526                         Node content = ((CustomMenuItem) item).getContent();
1527                         if (content != null) {
1528                             String t = (String)content.queryAccessibleAttribute(AccessibleAttribute.TEXT);
1529                             if (t != null) title += t;
1530                         }
1531                     }
1532                     return title;
1533                 }
1534                 case MNEMONIC: {
1535                     final Label label = getLabel();
1536                     if (label != null) {
1537                         String mnemonic = (String)label.queryAccessibleAttribute(AccessibleAttribute.MNEMONIC);
1538                         if (mnemonic != null) return mnemonic;
1539                     }
1540                     return null;
1541                 }
1542                 case DISABLED: return item.isDisable();
1543                 case SUBMENU:
1544                     createSubmenu();
1545                     // Accessibility might need to see the menu node before the window
1546                     // is visible (i.e. before the skin is applied).
1547                     if (submenu.getSkin() == null) {
1548                         submenu.getStyleableNode().applyCss();
1549                     }
1550                     ContextMenuContent cmContent = (ContextMenuContent)submenu.getSkin().getNode();
1551                     return cmContent.itemsContainer;
1552                 default: return super.queryAccessibleAttribute(attribute, parameters);
1553             }
1554         }
1555 
1556         /** {@inheritDoc} */
1557         @Override
1558         public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
1559             switch (action) {
1560                 case SHOW_MENU:{
1561                     if (item instanceof Menu) {
1562                         final Menu menuItem = (Menu) item;
1563                         if (menuItem.isShowing()) {
1564                             menuItem.hide();
1565                         } else {
1566                             menuItem.show();
1567                         }
1568                     }
1569                     break;
1570                 }
1571                 case FIRE:
1572                     doSelect();
1573                     break;
1574                 default: super.executeAccessibleAction(action);
1575             }
1576         }
1577     }
1578 
1579 
1580     private static final PseudoClass SELECTED_PSEUDOCLASS_STATE =
1581             PseudoClass.getPseudoClass(&quot;selected&quot;);
1582     private static final PseudoClass DISABLED_PSEUDOCLASS_STATE =
1583             PseudoClass.getPseudoClass(&quot;disabled&quot;);
1584     private static final PseudoClass CHECKED_PSEUDOCLASS_STATE =
1585             PseudoClass.getPseudoClass(&quot;checked&quot;);
1586 
1587     private class MenuLabel extends Label {
1588 
1589         public MenuLabel(MenuItem item, MenuItemContainer mic) {
1590             super(item.getText());
1591             setMnemonicParsing(item.isMnemonicParsing());
1592             setLabelFor(mic);
1593         }
1594     }
1595 
1596 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/ContextMenuContent.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.javafx.scene.control;
  27 
  28 import com.sun.javafx.scene.NodeHelper;
  29 import com.sun.javafx.scene.control.behavior.TwoLevelFocusPopupBehavior;
  30 import com.sun.javafx.scene.control.skin.Utils;
  31 import com.sun.javafx.scene.traversal.Direction;
  32 import javafx.animation.Animation.Status;
  33 import javafx.animation.KeyFrame;
  34 import javafx.animation.Timeline;
  35 import javafx.beans.InvalidationListener;
  36 import javafx.beans.WeakInvalidationListener;
  37 import javafx.beans.property.ReadOnlyBooleanProperty;
  38 import javafx.beans.value.ChangeListener;
  39 import javafx.beans.value.ObservableValue;
  40 import javafx.collections.ListChangeListener;
  41 import javafx.collections.ObservableList;
  42 import javafx.css.CssMetaData;
  43 import javafx.css.PseudoClass;
  44 import javafx.css.Styleable;
  45 import javafx.event.ActionEvent;
  46 import javafx.event.EventHandler;
  47 import javafx.geometry.*;
  48 import javafx.scene.AccessibleAction;
  49 import javafx.scene.AccessibleAttribute;
  50 import javafx.scene.AccessibleRole;
  51 import javafx.scene.Node;
  52 import javafx.scene.Parent;
  53 import javafx.scene.control.*;
  54 import javafx.scene.input.KeyEvent;
  55 import javafx.scene.input.MouseEvent;
  56 import javafx.scene.input.ScrollEvent;
  57 import javafx.scene.layout.Region;
  58 import javafx.scene.layout.StackPane;
  59 import javafx.scene.layout.VBox;
  60 import javafx.scene.shape.Rectangle;
  61 import javafx.stage.Window;
  62 import javafx.util.Duration;
  63 
  64 import java.util.ArrayList;
  65 import java.util.Collections;
  66 import java.util.List;
  67 import java.util.Optional;
  68 
  69 /**
  70  * This is a the SkinBase for ContextMenu based controls so that the CSS parts
  71  * work right, because otherwise we would have to copy the Keys from there to here.
  72  */
  73 public class ContextMenuContent extends Region {
  74 
  75     private static final String ITEM_STYLE_CLASS_LISTENER = &quot;itemStyleClassListener&quot;;
  76 
  77     private ContextMenu contextMenu;
  78 
  79     /***************************************************************************
  80      * UI subcomponents
  81      **************************************************************************/
  82 
  83     private double maxGraphicWidth = 0; // we keep this margin to left for graphic
  84     private double maxRightWidth = 0;
  85     private double maxLabelWidth = 0;
  86     private double maxRowHeight = 0;
  87     private double maxLeftWidth = 0;
  88     private double oldWidth = 0;
  89 
  90     private Rectangle clipRect;
  91     MenuBox itemsContainer;
  92     private ArrowMenuItem upArrow;
  93     private ArrowMenuItem downArrow;
  94 
  95     /*
  96      * We maintain a current focused index which is used
  97      * in keyboard navigation of menu items.
  98      */
  99     private int currentFocusedIndex = -1;
 100 
 101     private boolean itemsDirty = true;
 102     private InvalidationListener popupShowingListener = arg0 -&gt; {
 103         updateItems();
 104     };
 105     private WeakInvalidationListener weakPopupShowingListener =
 106             new WeakInvalidationListener(popupShowingListener);
 107 
 108 
 109     /***************************************************************************
 110      * Constructors
 111      **************************************************************************/
 112     public ContextMenuContent(final ContextMenu popupMenu) {
 113         this.contextMenu = popupMenu;
 114         clipRect = new Rectangle();
 115          clipRect.setSmooth(false);
 116         itemsContainer = new MenuBox();
 117 //        itemsContainer = new VBox();
 118         itemsContainer.setClip(clipRect);
 119 
 120         upArrow = new ArrowMenuItem(this);
 121         upArrow.setUp(true);
 122         upArrow.setFocusTraversable(false);
 123 
 124         downArrow = new ArrowMenuItem(this);
 125         downArrow.setUp(false);
 126         downArrow.setFocusTraversable(false);
 127         getChildren().add(itemsContainer);
 128         getChildren().add(upArrow);
 129         getChildren().add(downArrow);
 130         initialize();
 131         setUpBinds();
 132         updateItems();
 133         // RT-20197 add menuitems only on first show.
 134         popupMenu.showingProperty().addListener(weakPopupShowingListener);
 135 
 136         /*
 137         ** only add this if we&#39;re on an embedded
 138         ** platform that supports 5-button navigation
 139         */
 140         if (Utils.isTwoLevelFocus()) {
 141             new TwoLevelFocusPopupBehavior(this);
 142         }
 143     }
 144 
 145     //For access from controls
 146     public VBox getItemsContainer() {
 147         return itemsContainer;
 148     }
 149     //For testing purpose only
 150     int getCurrentFocusIndex() {
 151         return currentFocusedIndex;
 152     }
 153     //For testing purpose only
 154     void setCurrentFocusedIndex(int index) {
 155         if (index &lt; itemsContainer.getChildren().size()) {
 156             currentFocusedIndex = index;
 157         }
 158     }
 159 
 160     private void updateItems() {
 161         if (itemsDirty) {
 162             updateVisualItems();
 163             itemsDirty = false;
 164         }
 165     }
 166 
 167     private void computeVisualMetrics() {
 168         maxRightWidth = 0;
 169         maxLabelWidth = 0;
 170         maxRowHeight = 0;
 171         maxGraphicWidth = 0;
 172         maxLeftWidth = 0;
 173 
 174         for (int i = 0; i &lt; itemsContainer.getChildren().size(); i++) {
 175             Node child = itemsContainer.getChildren().get(i);
 176             if (child instanceof MenuItemContainer) {
 177                 final MenuItemContainer menuItemContainer = (MenuItemContainer)itemsContainer.getChildren().get(i);
 178 
 179                 if (! menuItemContainer.isVisible()) continue;
 180 
 181                 double alt = -1;
 182                 Node n = menuItemContainer.left;
 183                 if (n != null) {
 184                     if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
 185                         alt = snapSizeY(n.prefHeight(-1));
 186                     } else alt = -1;
 187                     maxLeftWidth = Math.max(maxLeftWidth, snapSizeX(n.prefWidth(alt)));
 188                     maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
 189                 }
 190 
 191                 n = menuItemContainer.graphic;
 192                 if (n != null) {
 193                     if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
 194                         alt = snapSizeY(n.prefHeight(-1));
 195                     } else alt = -1;
 196                     maxGraphicWidth = Math.max(maxGraphicWidth, snapSizeX(n.prefWidth(alt)));
 197                     maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
 198                 }
 199 
 200                 n = menuItemContainer.label;
 201                 if (n != null) {
 202                     if (n.getContentBias() == Orientation.VERTICAL) {
 203                         alt = snapSizeY(n.prefHeight(-1));
 204                     } else alt = -1;
 205                     maxLabelWidth = Math.max(maxLabelWidth, snapSizeX(n.prefWidth(alt)));
 206                     maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
 207                 }
 208 
 209                 n = menuItemContainer.right;
 210                 if (n != null) {
 211                     if (n.getContentBias() == Orientation.VERTICAL) { // width depends on height
 212                         alt = snapSizeY(n.prefHeight(-1));
 213                     } else alt = -1;
 214                     maxRightWidth = Math.max(maxRightWidth, snapSizeX(n.prefWidth(alt)));
 215                     maxRowHeight = Math.max(maxRowHeight, n.prefHeight(-1));
 216                 }
 217             }
 218         }
 219 
 220         // Fix for RT-38838.
 221         // This fixes the issue where CSS is applied to a menu after it has been
 222         // showing, resulting in its bounds changing. In this case, we need to
 223         // shift the submenu such that it is properly aligned with its parent menu.
 224         //
 225         // To do this, we must firstly determine if the open submenu is shifted
 226         // horizontally to appear on the other side of this menu, as this is the
 227         // only situation where shifting has to happen. If so, we need to check
 228         // if we should shift the submenu due to changes in width.
 229         //
 230         // We need to get the parent menu of this contextMenu, so that we only
 231         // modify the X value in the following conditions:
 232         // 1) There exists a parent menu
 233         // 2) The parent menu is in the correct position (i.e. to the left of this
 234         //    menu in normal LTR systems).
 235         final double newWidth = maxRightWidth + maxLabelWidth + maxGraphicWidth + maxLeftWidth;
 236         Window ownerWindow = contextMenu.getOwnerWindow();
 237         if (ownerWindow instanceof ContextMenu) {
 238             if (contextMenu.getX() &lt; ownerWindow.getX()) {
 239                 if (oldWidth != newWidth) {
 240                     contextMenu.setX(contextMenu.getX() + oldWidth - newWidth);
 241                 }
 242             }
 243         }
 244 
 245         oldWidth = newWidth;
 246     }
 247 
 248     private void updateVisualItems() {
 249         ObservableList&lt;Node&gt; itemsContainerChilder = itemsContainer.getChildren();
 250 
 251         disposeVisualItems();
 252 
 253         for (int row = 0; row &lt; getItems().size(); row++) {
 254             final MenuItem item = getItems().get(row);
 255             if (item instanceof CustomMenuItem &amp;&amp; ((CustomMenuItem) item).getContent() == null) {
 256                 continue;
 257             }
 258 
 259             if (item instanceof SeparatorMenuItem) {
 260                 // we don&#39;t want the hover highlight for separators, so for
 261                 // now this is the simplest approach - just remove the
 262                 // background entirely. This may cause issues if people
 263                 // intend to style the background differently.
 264                 Node node = ((CustomMenuItem) item).getContent();
 265                 node.visibleProperty().bind(item.visibleProperty());
 266                 itemsContainerChilder.add(node);
 267                 // Add the (separator) menu item to properties map of this node.
 268                 // Special casing this for separator :
 269                 // This allows associating this container with SeparatorMenuItem.
 270                 node.getProperties().put(MenuItem.class, item);
 271             } else {
 272                 MenuItemContainer menuItemContainer = new MenuItemContainer(item);
 273                 menuItemContainer.visibleProperty().bind(item.visibleProperty());
 274                 itemsContainerChilder.add(menuItemContainer);
 275             }
 276         }
 277 
 278         // Add the Menu to properties map of this skin. Used by QA for testing
 279         // This enables associating a parent menu for this skin showing menu items.
 280         if (getItems().size() &gt; 0) {
 281             final MenuItem item = getItems().get(0);
 282             getProperties().put(Menu.class, item.getParentMenu());
 283         }
 284 
 285         // RT-36513 made this applyCss(). Modified by RT-36995 to NodeHelper.reapplyCSS()
 286         NodeHelper.reapplyCSS(this);
 287     }
 288 
 289     private void disposeVisualItems() {
 290         // clean up itemsContainer
 291         ObservableList&lt;Node&gt; itemsContainerChilder = itemsContainer.getChildren();
 292         for (int i = 0, max = itemsContainerChilder.size(); i &lt; max; i++) {
 293             Node n = itemsContainerChilder.get(i);
 294 
 295             if (n instanceof MenuItemContainer) {
 296                 MenuItemContainer container = (MenuItemContainer) n;
 297                 container.visibleProperty().unbind();
 298                 container.dispose();
 299             }
 300         }
 301         itemsContainerChilder.clear();
 302     }
 303 
 304     /**
 305      * Can be called by Skins when they need to clean up the content of any
 306      * ContextMenu instances they might have created. This ensures that contents
 307      * of submenus if any, also get cleaned up.
 308      */
 309     public void dispose() {
 310         disposeBinds();
 311         disposeVisualItems();
 312 
 313         disposeContextMenu(submenu);
 314         submenu = null;
 315         openSubmenu = null;
 316         selectedBackground = null;
 317         if (contextMenu != null) {
 318             contextMenu.getItems().clear();
 319             contextMenu = null;
 320         }
 321     }
 322 
 323     public void disposeContextMenu(ContextMenu menu) {
 324         if (menu == null) return;
 325 
 326         Skin&lt;?&gt; skin = menu.getSkin();
 327         if (skin == null) return;
 328 
 329         ContextMenuContent cmContent = (ContextMenuContent)skin.getNode();
 330         if (cmContent == null) return;
 331 
 332         cmContent.dispose(); // recursive call to dispose submenus.
 333     }
 334 
 335     @Override protected void layoutChildren() {
 336         if (itemsContainer.getChildren().size() == 0) return;
 337         final double x = snappedLeftInset();
 338         final double y = snappedTopInset();
 339         final double w = getWidth() - x - snappedRightInset();
 340         final double h = getHeight() - y - snappedBottomInset();
 341         final double contentHeight =  snapSizeY(getContentHeight()); // itemsContainer.prefHeight(-1);
 342 
 343         itemsContainer.resize(w,contentHeight);
 344         itemsContainer.relocate(x, y);
 345 
 346         if (isFirstShow &amp;&amp; ty == 0) {
 347             upArrow.setVisible(false);
 348             isFirstShow = false;
 349         } else {
 350             upArrow.setVisible(ty &lt; y &amp;&amp; ty &lt; 0);
 351         }
 352         downArrow.setVisible(ty + contentHeight &gt; (y + h));
 353 
 354         clipRect.setX(0);
 355         clipRect.setY(0);
 356         clipRect.setWidth(w);
 357         clipRect.setHeight(h);
 358 
 359         if (upArrow.isVisible()) {
 360             final double prefHeight = snapSizeY(upArrow.prefHeight(-1));
 361             clipRect.setHeight(snapSizeY(clipRect.getHeight() - prefHeight));
 362             clipRect.setY(snapSizeY(clipRect.getY()) + prefHeight);
 363             upArrow.resize(snapSizeX(upArrow.prefWidth(-1)), prefHeight);
 364             positionInArea(upArrow, x, y, w, prefHeight, /*baseline ignored*/0,
 365                     HPos.CENTER, VPos.CENTER);
 366         }
 367 
 368         if (downArrow.isVisible()) {
 369             final double prefHeight = snapSizeY(downArrow.prefHeight(-1));
 370             clipRect.setHeight(snapSizeY(clipRect.getHeight()) - prefHeight);
 371             downArrow.resize(snapSizeX(downArrow.prefWidth(-1)), prefHeight);
 372             positionInArea(downArrow, x, (y + h - prefHeight), w, prefHeight, /*baseline ignored*/0,
 373                     HPos.CENTER, VPos.CENTER);
 374         }
 375     }
 376 
 377      @Override protected double computePrefWidth(double height) {
 378          computeVisualMetrics();
 379          double prefWidth = 0;
 380          if (itemsContainer.getChildren().size() == 0) return 0;
 381          for (Node n : itemsContainer.getChildren()) {
 382              if (! n.isVisible()) continue;
 383              prefWidth = Math.max(prefWidth, snapSizeX(n.prefWidth(-1)));
 384          }
 385          return snappedLeftInset() + snapSizeX(prefWidth) + snappedRightInset();
 386     }
 387 
 388     @Override protected double computePrefHeight(double width) {
 389         if (itemsContainer.getChildren().size() == 0) return 0;
 390         final double screenHeight = getScreenHeight();
 391         final double contentHeight = getContentHeight(); // itemsContainer.prefHeight(width);
 392         double totalHeight = snappedTopInset() + snapSizeY(contentHeight) + snappedBottomInset();
 393         // the pref height of this menu is the smaller value of the
 394         // actual pref height and the height of the screens _visual_ bounds.
 395         double prefHeight = (screenHeight &lt;= 0) ? (totalHeight) : (Math.min(totalHeight, screenHeight));
 396         return prefHeight;
 397     }
 398 
 399     @Override protected double computeMinHeight(double width) {
 400         return 0.0;
 401     }
 402 
 403     @Override protected double computeMaxHeight(double height) {
 404         return getScreenHeight();
 405     }
 406 
 407     private double getScreenHeight() {
 408         if (contextMenu == null || contextMenu.getOwnerWindow() == null ||
 409                 contextMenu.getOwnerWindow().getScene() == null) {
 410             return -1;
 411         }
 412         return snapSizeY(com.sun.javafx.util.Utils.getScreen(
 413             contextMenu.getOwnerWindow().getScene().getRoot()).getVisualBounds().getHeight());
 414 
 415     }
 416 
 417     private double getContentHeight() {
 418         double h = 0.0d;
 419         for (Node i : itemsContainer.getChildren()) {
 420             if (i.isVisible()) {
 421                h += snapSizeY(i.prefHeight(-1));
 422             }
 423         }
 424         return h;
 425     }
 426 
 427     // This handles shifting ty when doing keyboard navigation.
 428     private void ensureFocusedMenuItemIsVisible(Node node) {
 429         if (node == null) return;
 430 
 431         final Bounds nodeBounds = node.getBoundsInParent();
 432         final Bounds clipBounds = clipRect.getBoundsInParent();
 433 
 434         if (nodeBounds.getMaxY() &gt;= clipBounds.getMaxY()) {
 435             // this is for moving down the menu
 436             scroll(-nodeBounds.getMaxY() + clipBounds.getMaxY());
 437         } else if (nodeBounds.getMinY() &lt;= clipBounds.getMinY()) {
 438             // this is for moving up the menu
 439             scroll(-nodeBounds.getMinY() + clipBounds.getMinY());
 440         }
 441     }
 442 
 443     protected ObservableList&lt;MenuItem&gt; getItems() {
 444         return contextMenu.getItems();
 445     }
 446 
 447     /**
 448      * Finds the index of currently focused item.
 449      */
 450     private int findFocusedIndex() {
 451          for (int i = 0; i &lt; itemsContainer.getChildren().size(); i++) {
 452             Node n = itemsContainer.getChildren().get(i);
 453             if (n.isFocused()) {
 454                 return i;
 455             }
 456         }
 457         return -1;
 458     }
 459 
 460     private boolean isFirstShow = true;
 461     private double ty;
 462 
 463     private void initialize() {
 464         // RT-19624 calling requestFocus inside layout was casuing repeated layouts.
 465         contextMenu.addEventHandler(Menu.ON_SHOWN, event -&gt; {
 466             currentFocusedIndex = -1;
 467             for (Node child : itemsContainer.getChildren()) {
 468                 if (child instanceof MenuItemContainer) {
 469                     final MenuItem item = ((MenuItemContainer)child).item;
 470                     // When the choiceBox popup is shown, if this menu item is selected
 471                     // do a requestFocus so CSS kicks in and the item is highlighted.
 472                     if (&quot;choice-box-menu-item&quot;.equals(item.getId())) {
 473                         if (((RadioMenuItem)item).isSelected()) {
 474                             child.requestFocus();
 475                             break;
 476                         }
 477                     }
 478                 }
 479 
 480             }
 481         });
 482 
 483 //        // FIXME For some reason getSkinnable()Behavior traversal functions don&#39;t
 484 //        // get called as expected, so I&#39;ve just put the important code below.
 485         // We use setOnKeyPressed here as we are not adding a listener to a public
 486         // event type (ContextMenuContent is not public API), and without this
 487         // we get the issue shown in RT-34429
 488         setOnKeyPressed(new EventHandler&lt;KeyEvent&gt;() {
 489             @Override public void handle(KeyEvent ke) {
 490                 switch (ke.getCode()) {
 491                     case LEFT:
 492                         if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
 493                             processRightKey(ke);
 494                         } else {
 495                             processLeftKey(ke);
 496                         }
 497                         break;
 498                     case RIGHT:
 499                         if (getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
 500                             processLeftKey(ke);
 501                         } else {
 502                             processRightKey(ke);
 503                         }
 504                         break;
 505                     case CANCEL:
 506                         ke.consume();
 507                         break;
 508                     case ESCAPE:
 509                         // if the owner is not a menubar button, just close the
 510                         // menu - this will move focus up to the parent menu
 511                         // as required. In the case of the parent being a
 512                         // menubar button we special case in the conditional code
 513                         // beneath this switch statement. See RT-34429 for more context.
 514                         final Node ownerNode = contextMenu.getOwnerNode();
 515                         if (! (ownerNode instanceof MenuBarButton)) {
 516                             contextMenu.hide();
 517                             ke.consume();
 518                         }
 519                         break;
 520                     case DOWN:
 521                         // move to the next sibling
 522                         move(Direction.NEXT);
 523                         ke.consume();
 524                         break;
 525                     case UP:
 526                         // move to previous sibling
 527                         move(Direction.PREVIOUS);
 528                         ke.consume();
 529                         break;
 530                     case SPACE:
 531                     case ENTER:
 532                         // select the menuitem
 533                         selectMenuItem();
 534                         ke.consume();
 535                         break;
 536                     default:
 537                         break;
 538                 }
 539 
 540                 if (!ke.isConsumed()) {
 541                     final Node ownerNode = contextMenu.getOwnerNode();
 542                     if (ownerNode instanceof MenuItemContainer) {
 543                         // Forward to parent menu
 544                         Parent parent = ownerNode.getParent();
 545                         while (parent != null &amp;&amp; !(parent instanceof ContextMenuContent)) {
 546                             parent = parent.getParent();
 547                         }
 548                         if (parent instanceof ContextMenuContent) {
 549                             parent.getOnKeyPressed().handle(ke);
 550                         }
 551                     } else if (ownerNode instanceof MenuBarButton) {
 552                         // the following code no longer appears necessary, but
 553                         // leaving in intact for now...
 554 //                        // This is a top-level MenuBar Menu, so forward event to MenuBar
 555 //                        MenuBarSkin mbs = ((MenuBarButton)ownerNode).getMenuBarSkin();
 556 //                        if (mbs != null &amp;&amp; mbs.getKeyEventHandler() != null) {
 557 //                            mbs.getKeyEventHandler().handle(ke);
 558 //                        }
 559                     }
 560                 }
 561             }
 562         });
 563 
 564         addEventHandler(ScrollEvent.SCROLL, event -&gt; {
 565             /*
 566              * we&#39;ll only scroll if the arrows are visible in the direction
 567              * that we&#39;re going, otherwise we go into empty space.
 568              */
 569             final double textDeltaY = event.getTextDeltaY();
 570             final double deltaY = event.getDeltaY();
 571             if ((downArrow.isVisible() &amp;&amp; (textDeltaY &lt; 0.0 || deltaY &lt; 0.0)) ||
 572                 (upArrow.isVisible() &amp;&amp; (textDeltaY &gt; 0.0 || deltaY &gt; 0.0))) {
 573 
 574                 switch(event.getTextDeltaYUnits()) {
 575                   case LINES:
 576                       /*
 577                       ** scroll lines, use the row height of selected row,
 578                       ** or row 0 if none selected
 579                       */
 580                       int focusedIndex = findFocusedIndex();
 581                       if (focusedIndex == -1) {
 582                           focusedIndex = 0;
 583                       }
 584                       double rowHeight = itemsContainer.getChildren().get(focusedIndex).prefHeight(-1);
 585                       scroll(textDeltaY * rowHeight);
 586                       break;
 587                   case PAGES:
 588                       /*
 589                       ** page scroll, scroll the menu height
 590                       */
 591                       scroll(textDeltaY * itemsContainer.getHeight());
 592                       break;
 593                   case NONE:
 594                       /*
 595                       ** pixel scroll
 596                       */
 597                       scroll(deltaY);
 598                       break;
 599                 }
 600                 event.consume();
 601             }
 602         });
 603     }
 604 
 605     private Optional&lt;Node&gt; getFocusedNode() {
 606         final List&lt;Node&gt; children = itemsContainer.getChildren();
 607         final boolean validIndex = currentFocusedIndex &gt;= 0 &amp;&amp; currentFocusedIndex &lt; children.size();
 608         return validIndex ? Optional.of(children.get(currentFocusedIndex)) : Optional.empty();
 609     }
 610 
 611     private void processLeftKey(KeyEvent ke) {
 612         getFocusedNode().ifPresent(n -&gt; {
 613             if (n instanceof MenuItemContainer) {
 614                 MenuItem item = ((MenuItemContainer)n).item;
 615                 if (item instanceof Menu) {
 616                     final Menu menu = (Menu) item;
 617 
 618                     // if the submenu for this menu is showing, hide it
 619                     if (menu == openSubmenu &amp;&amp; submenu != null &amp;&amp; submenu.isShowing()) {
 620                         hideSubmenu();
 621                         ke.consume();
 622                     }
 623                 }
 624             }
 625         });
 626     }
 627 
 628     private void processRightKey(KeyEvent ke) {
 629         getFocusedNode().ifPresent(n -&gt; {
 630             if (n instanceof MenuItemContainer) {
 631                 MenuItem item = ((MenuItemContainer)n).item;
 632                 if (item instanceof Menu) {
 633                     final Menu menu = (Menu) item;
 634                     if (menu.isDisable()) return;
 635                     selectedBackground = ((MenuItemContainer)n);
 636 
 637                     // RT-15103
 638                     // if submenu for this menu is already showing then do nothing
 639                     // Menubar will process the right key and move to the next menu
 640                     if (openSubmenu == menu &amp;&amp; submenu != null &amp;&amp; submenu.isShowing()) {
 641                         return;
 642                     }
 643 
 644                     showMenu(menu);
 645                     ke.consume();
 646                 }
 647             }
 648         });
 649     }
 650 
 651     private void showMenu(Menu menu) {
 652         menu.show();
<a name="1" id="anc1"></a><span class="line-modified"> 653 </span>
<span class="line-modified"> 654         // if there is a submenu</span>
<span class="line-modified"> 655         if (submenu != null) {</span>
<span class="line-modified"> 656             // request focus on the first item of the submenu after it is shown</span>
<span class="line-modified"> 657             ContextMenuContent cmContent = (ContextMenuContent)submenu.getSkin().getNode();</span>
<span class="line-modified"> 658             if (cmContent != null) {</span>
<span class="line-modified"> 659                if (cmContent.itemsContainer.getChildren().size() &gt; 0) {</span>
<span class="line-modified"> 660                    cmContent.itemsContainer.getChildren().get(0).requestFocus();</span>
<span class="line-modified"> 661                    cmContent.currentFocusedIndex = 0;</span>
<span class="line-added"> 662                } else {</span>
<span class="line-added"> 663                    cmContent.requestFocus();</span>
<span class="line-added"> 664                }</span>
<span class="line-added"> 665             }</span>
 666         }
 667     }
 668 
 669     private void selectMenuItem() {
 670         getFocusedNode().ifPresent(n -&gt; {
 671             if (n instanceof MenuItemContainer) {
 672                 MenuItem item = ((MenuItemContainer)n).item;
 673                 if (item instanceof Menu) {
 674                     final Menu menu = (Menu) item;
 675                     if (openSubmenu != null) {
 676                         hideSubmenu();
 677                     }
 678                     if (menu.isDisable()) return;
 679                     selectedBackground = ((MenuItemContainer)n);
 680                     menu.show();
 681                 } else {
 682                     ((MenuItemContainer)n).doSelect();
 683                 }
 684             }
 685         });
 686     }
 687 
 688     private void move(Direction dir) {
 689         int startIndex = currentFocusedIndex != -1 ? currentFocusedIndex : itemsContainer.getChildren().size();
 690         requestFocusOnIndex(findSibling(dir, startIndex));
 691     }
 692 
 693     private int findSibling(final Direction dir, final int startIndex) {
 694         final int childCount = itemsContainer.getChildren().size();
 695         int i = startIndex;
 696         do {
 697             if (dir.isForward() &amp;&amp; i &gt;= childCount - 1) {
 698                 // loop to zero
 699                 i = 0;
 700             } else if (!dir.isForward() &amp;&amp; i == 0) {
 701                 // loop to end
 702                 i = childCount - 1;
 703             } else {
 704                 i += (dir.isForward() ? 1 : -1);
 705             }
 706 
 707             Node n = itemsContainer.getChildren().get(i);
 708             if (n instanceof MenuItemContainer &amp;&amp; n.isVisible()) {
 709                 return i;
 710             }
 711         } while (i != startIndex);
 712         return -1;
 713     }
 714 
 715     public void requestFocusOnIndex(int index) {
 716         currentFocusedIndex = index;
 717         Node n = itemsContainer.getChildren().get(index);
 718         selectedBackground = ((MenuItemContainer)n);
 719         n.requestFocus();
 720         ensureFocusedMenuItemIsVisible(n);
 721     }
 722 
 723     /*
 724      * Get the Y offset from the top of the popup to the menu item whose index
 725      * is given.
 726      */
 727     public double getMenuYOffset(int menuIndex) {
 728         double offset = 0;
 729         if (itemsContainer.getChildren().size() &gt; menuIndex) {
 730             offset = snappedTopInset();
 731             Node menuitem = itemsContainer.getChildren().get(menuIndex);
 732             offset += menuitem.getLayoutY() + menuitem.prefHeight(-1);
 733         }
 734         return offset;
 735     }
 736 
 737     private void setUpBinds() {
 738         updateMenuShowingListeners(contextMenu.getItems(), true);
 739         contextMenu.getItems().addListener(contextMenuItemsListener);
 740     }
 741 
 742     private void disposeBinds() {
 743         updateMenuShowingListeners(contextMenu.getItems(), false);
 744         contextMenu.getItems().removeListener(contextMenuItemsListener);
 745     }
 746 
 747     private ChangeListener&lt;Boolean&gt; menuShowingListener = (observable, wasShowing, isShowing) -&gt; {
 748         ReadOnlyBooleanProperty isShowingProperty = (ReadOnlyBooleanProperty) observable;
 749         Menu menu = (Menu) isShowingProperty.getBean();
 750 
 751         if (wasShowing &amp;&amp; ! isShowing) {
 752             // hide the submenu popup
 753             hideSubmenu();
 754         } else if (! wasShowing &amp;&amp; isShowing) {
 755             // show the submenu popup
 756             showSubmenu(menu);
 757         }
 758     };
 759 
 760     private ListChangeListener&lt;MenuItem&gt; contextMenuItemsListener = (ListChangeListener&lt;MenuItem&gt;) c -&gt; {
 761         // Add listeners to the showing property of all menus that have
 762         // been added, and remove listeners from menus that have been removed
 763         // FIXME this is temporary - we should be adding and removing
 764         // listeners such that they use the one listener defined above
 765         // - but that can&#39;t be done until we have the bean in the
 766         // ObservableValue
 767         while (c.next()) {
 768             updateMenuShowingListeners(c.getRemoved(), false);
 769             updateMenuShowingListeners(c.getAddedSubList(), true);
 770         }
 771 
 772         // Listener to items in PopupMenu to update items in PopupMenuContent
 773         itemsDirty = true;
 774         updateItems(); // RT-29761
 775     };
 776 
 777     private ChangeListener&lt;Boolean&gt; menuItemVisibleListener = (observable, oldValue, newValue) -&gt; {
 778         // re layout as item&#39;s visibility changed
 779         requestLayout();
 780     };
 781 
 782     private void updateMenuShowingListeners(List&lt;? extends MenuItem&gt; items, boolean addListeners) {
 783         for (MenuItem item : items) {
 784             if (item instanceof Menu) {
 785                 final Menu menu = (Menu) item;
 786 
 787                 if (addListeners) {
 788                     menu.showingProperty().addListener(menuShowingListener);
 789                 } else {
 790                     menu.showingProperty().removeListener(menuShowingListener);
 791                 }
 792             }
 793 
 794              // listen to menu items&#39;s visible property.
 795             if (addListeners) {
 796                 item.visibleProperty().addListener(menuItemVisibleListener);
 797             } else {
 798                 item.visibleProperty().removeListener(menuItemVisibleListener);
 799             }
 800         }
 801     }
 802 
 803     // For test purpose only
 804     ContextMenu getSubMenu() {
 805         return submenu;
 806     }
 807 
 808     Menu getOpenSubMenu() {
 809         return openSubmenu;
 810     }
 811 
 812     private void createSubmenu() {
 813         if (submenu == null) {
 814             submenu = new ContextMenu();
 815             submenu.showingProperty().addListener(new ChangeListener&lt;Boolean&gt;() {
 816                 @Override public void changed(ObservableValue&lt;? extends Boolean&gt; observable,
 817                                               Boolean oldValue, Boolean newValue) {
 818                     if (!submenu.isShowing()) {
 819                         // Maybe user clicked outside or typed ESCAPE.
 820                         // Make sure menus are in sync.
 821                         for (Node node : itemsContainer.getChildren()) {
 822                             if (node instanceof MenuItemContainer
 823                                   &amp;&amp; ((MenuItemContainer)node).item instanceof Menu) {
 824                                 Menu menu = (Menu)((MenuItemContainer)node).item;
 825                                 if (menu.isShowing()) {
 826                                     menu.hide();
 827                                 }
 828                             }
 829                         }
 830                     }
 831                 }
 832             });
 833         }
 834     }
 835 
 836     private void showSubmenu(Menu menu) {
 837         openSubmenu = menu;
 838         createSubmenu();
 839         submenu.getItems().setAll(menu.getItems());
 840         submenu.show(selectedBackground, Side.RIGHT, 0, 0);
 841     }
 842 
 843     private void hideSubmenu() {
 844         if (submenu == null) return;
 845 
 846         submenu.hide();
 847         openSubmenu = null;
 848 
 849         // Fix for RT-37022 - we dispose content so that we do not process CSS
 850         // on hidden submenus
 851         disposeContextMenu(submenu);
 852         submenu = null;
 853 
 854         // Fix for JDK-8158679 - we put the focus on the menu, and then back
 855         // on the menu item, so that screen readers can properly speak out
 856         // the menu item.
 857         getFocusedNode().ifPresent(n -&gt; {
 858             requestFocus();
 859             n.requestFocus();
 860         });
 861     }
 862 
 863     private void hideAllMenus(MenuItem item) {
 864         if (contextMenu != null) contextMenu.hide();
 865 
 866         Menu parentMenu;
 867         while ((parentMenu = item.getParentMenu()) != null) {
 868             parentMenu.hide();
 869             item = parentMenu;
 870         }
 871         if (item.getParentPopup() != null) {
 872             item.getParentPopup().hide();
 873         }
 874     }
 875 
 876     private Menu openSubmenu;
 877     private ContextMenu submenu;
 878 
 879     // FIXME: HACKY. We use this so that a submenu knows where to open from
 880     // but this will only work for mouse hovers currently - and won&#39;t work
 881     // programmatically.
 882     // package protected for testing only!
 883     Region selectedBackground;
 884 
 885     void scroll(double delta) {
 886         double newTy = ty + delta;
 887         if (ty == newTy) return;
 888 
 889         // translation should never be positive (this would mean the top of the
 890         // menu content is detaching from the top of the menu!)
 891         if (newTy &gt; 0.0) {
 892             newTy = 0.0;
 893         }
 894 
 895         // translation should never be greater than the preferred height of the
 896         // menu content (otherwise the menu content will be detaching from the
 897         // bottom of the menu).
 898         // RT-37185: We check the direction of the scroll, to prevent it locking
 899         // up when scrolling upwards from the very bottom (using the on-screen
 900         // up arrow).
 901         if (delta &lt; 0 &amp;&amp; (getHeight() - newTy) &gt; itemsContainer.getHeight() - downArrow.getHeight()) {
 902             newTy = getHeight() - itemsContainer.getHeight() - downArrow.getHeight();
 903         }
 904 
 905         ty = newTy;
 906         itemsContainer.requestLayout();
 907     }
 908 
 909     /***************************************************************************
 910      *                                                                         *
 911      *                         Stylesheet Handling                             *
 912      *                                                                         *
 913      **************************************************************************/
 914     @Override public Styleable getStyleableParent() {
 915         return contextMenu;
 916     }
 917 
 918     private static class StyleableProperties {
 919 
 920         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
 921         static {
 922 
 923             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
 924                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Region.getClassCssMetaData());
 925 
 926             //
 927             // SkinBase only has Region&#39;s unique StlyleableProperty&#39;s, none of Nodes
 928             // So, we need to add effect back in. The effect property is in a
 929             // private inner class, so get the property from Node the hard way.
 930             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; nodeStyleables = Node.getClassCssMetaData();
 931             for(int n=0, max=nodeStyleables.size(); n&lt;max; n++) {
 932                 CssMetaData&lt;? extends Styleable, ?&gt; styleable = nodeStyleables.get(n);
 933                 if (&quot;effect&quot;.equals(styleable.getProperty())) {
 934                     styleables.add(styleable);
 935                     break;
 936                 }
 937             }
 938             STYLEABLES = Collections.unmodifiableList(styleables);
 939         }
 940     }
 941 
 942     /**
 943      * @return The CssMetaData associated with this class, which may include the
 944      * CssMetaData of its superclasses.
 945      */
 946     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
 947         return StyleableProperties.STYLEABLES;
 948     }
 949 
 950     /**
 951      * {@inheritDoc}
 952      */
 953     @Override
 954     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
 955         return getClassCssMetaData();
 956     }
 957 
 958     public Label getLabelAt(int index) {
 959         return ((MenuItemContainer)itemsContainer.getChildren().get(index)).getLabel();
 960     }
 961 
 962     /**
 963      * Custom VBox to enable scrolling of items. Scrolling effect is achieved by
 964      * controlling the translate Y coordinate of the menu item &quot;ty&quot; which is set by a
 965      * timeline when mouse is over up/down arrow.
 966      */
 967     class MenuBox extends VBox {
 968         MenuBox() {
 969             setAccessibleRole(AccessibleRole.CONTEXT_MENU);
 970         }
 971 
 972         @Override protected void layoutChildren() {
 973             double yOffset = ty;
 974             for (Node n : getChildren()) {
 975                 if (n.isVisible()) {
 976                     final double prefHeight = snapSizeY(n.prefHeight(-1));
 977                     n.resize(snapSizeX(getWidth()), prefHeight);
 978                     n.relocate(snappedLeftInset(), yOffset);
 979                     yOffset += prefHeight;
 980                 }
 981             }
 982         }
 983 
 984         /** {@inheritDoc} */
 985         @Override
 986         public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
 987             switch (attribute) {
 988                 case VISIBLE: return contextMenu.isShowing();
 989                 case PARENT_MENU: return contextMenu.getOwnerNode();
 990                 default: return super.queryAccessibleAttribute(attribute, parameters);
 991             }
 992         }
 993     }
 994 
 995     class ArrowMenuItem extends StackPane {
 996          private StackPane upDownArrow;
 997          private ContextMenuContent popupMenuContent;
 998          private boolean up = false;
 999          public final boolean isUp() { return up; }
1000          public void setUp(boolean value) {
1001             up = value;
1002             upDownArrow.getStyleClass().setAll(isUp() ? &quot;menu-up-arrow&quot; : &quot;menu-down-arrow&quot;);
1003         }
1004 
1005         // used to automatically scroll through menu items when the user performs
1006         // certain interactions, e.g. pressing and holding the arrow buttons
1007         private Timeline scrollTimeline;
1008 
1009         public ArrowMenuItem(ContextMenuContent pmc) {
1010             getStyleClass().setAll(&quot;scroll-arrow&quot;);
1011             upDownArrow = new StackPane();
1012             this.popupMenuContent = pmc;
1013             upDownArrow.setMouseTransparent(true);
1014             upDownArrow.getStyleClass().setAll(isUp() ? &quot;menu-up-arrow&quot; : &quot;menu-down-arrow&quot;);
1015     //        setMaxWidth(Math.max(upDownArrow.prefWidth(-1), getWidth()));
1016             addEventHandler(MouseEvent.MOUSE_ENTERED, me -&gt; {
1017                 if (scrollTimeline != null &amp;&amp; (scrollTimeline.getStatus() != Status.STOPPED)) {
1018                     return;
1019                 }
1020                 startTimeline();
1021             });
1022             addEventHandler(MouseEvent.MOUSE_EXITED, me -&gt; {
1023                 stopTimeline();
1024             });
1025             setVisible(false);
1026             setManaged(false);
1027             getChildren().add(upDownArrow);
1028         }
1029 
1030         @Override protected double computePrefWidth(double height) {
1031 //            return snapSize(getInsets().getLeft()) + snapSize(getInsets().getRight());
1032             return itemsContainer.getWidth();
1033         }
1034 
1035         @Override protected double computePrefHeight(double width) {
1036             return snappedTopInset() + upDownArrow.prefHeight(-1) + snappedBottomInset();
1037         }
1038 
1039         @Override protected void layoutChildren() {
1040             double w = snapSizeX(upDownArrow.prefWidth(-1));
1041             double h = snapSizeY(upDownArrow.prefHeight(-1));
1042 
1043             upDownArrow.resize(w, h);
1044             positionInArea(upDownArrow, 0, 0, getWidth(), getHeight(),
1045                     /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
1046         }
1047 
1048         private void adjust() {
1049             if(up) popupMenuContent.scroll(12); else popupMenuContent.scroll(-12);
1050         }
1051 
1052         private void startTimeline() {
1053             scrollTimeline = new Timeline();
1054             scrollTimeline.setCycleCount(Timeline.INDEFINITE);
1055             KeyFrame kf = new KeyFrame(
1056                 Duration.millis(60),
1057                     event -&gt; {
1058                         adjust();
1059                     }
1060             );
1061             scrollTimeline.getKeyFrames().clear();
1062             scrollTimeline.getKeyFrames().add(kf);
1063             scrollTimeline.play();
1064         }
1065 
1066         private void stopTimeline() {
1067             scrollTimeline.stop();
1068             scrollTimeline = null;
1069         }
1070     }
1071 
1072     /*
1073      * Container responsible for laying out a single row in the menu - in other
1074      * words, this contains and lays out a single MenuItem, regardless of it&#39;s
1075      * specific subtype.
1076      */
1077     public class MenuItemContainer extends Region {
1078 
1079         private final MenuItem item;
1080 
1081         private Node left;
1082         private Node graphic;
1083         private Node label;
1084         private Node right;
1085 
1086         private final LambdaMultiplePropertyChangeListenerHandler listener =
1087             new LambdaMultiplePropertyChangeListenerHandler();
1088 
1089         private EventHandler&lt;MouseEvent&gt; mouseEnteredEventHandler;
1090         private EventHandler&lt;MouseEvent&gt; mouseReleasedEventHandler;
1091 
1092         private EventHandler&lt;ActionEvent&gt; actionEventHandler;
1093 
1094         protected Label getLabel(){
1095             return (Label) label;
1096         }
1097 
1098         public MenuItem getItem() {
1099             return item;
1100         }
1101 
1102         public MenuItemContainer(MenuItem item){
1103             if (item == null) {
1104                 throw new NullPointerException(&quot;MenuItem can not be null&quot;);
1105             }
1106 
1107             getStyleClass().addAll(item.getStyleClass());
1108             setId(item.getId());
1109             setFocusTraversable(!(item instanceof CustomMenuItem));
1110             this.item = item;
1111 
1112             createChildren();
1113 
1114             // listen to changes in the state of certain MenuItem types
1115             ReadOnlyBooleanProperty pseudoProperty;
1116             if (item instanceof Menu) {
1117                 pseudoProperty = ((Menu)item).showingProperty();
1118                 listener.registerChangeListener(pseudoProperty,
1119                         e -&gt; pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, ((Menu) item).isShowing()));
1120                 pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, pseudoProperty.get());
1121                 setAccessibleRole(AccessibleRole.MENU);
1122             } else if (item instanceof RadioMenuItem) {
1123                 pseudoProperty = ((RadioMenuItem)item).selectedProperty();
1124                 listener.registerChangeListener(pseudoProperty,
1125                         e -&gt; pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, ((RadioMenuItem) item).isSelected()));
1126                 pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, pseudoProperty.get());
1127                 setAccessibleRole(AccessibleRole.RADIO_MENU_ITEM);
1128             } else if (item instanceof CheckMenuItem) {
1129                 pseudoProperty = ((CheckMenuItem)item).selectedProperty();
1130                 listener.registerChangeListener(pseudoProperty,
1131                         e -&gt; pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, ((CheckMenuItem) item).isSelected()));
1132                 pseudoClassStateChanged(CHECKED_PSEUDOCLASS_STATE, pseudoProperty.get());
1133                 setAccessibleRole(AccessibleRole.CHECK_MENU_ITEM);
1134             } else {
1135                 setAccessibleRole(AccessibleRole.MENU_ITEM);
1136             }
1137 
1138             pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, item.disableProperty().get());
1139             listener.registerChangeListener(item.disableProperty(),
1140                     e -&gt; pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, item.isDisable()));
1141 
1142             // Add the menu item to properties map of this node. Used by QA for testing
1143             // This allows associating this container with corresponding MenuItem.
1144             getProperties().put(MenuItem.class, item);
1145 
1146             listener.registerChangeListener(item.graphicProperty(), e -&gt; {
1147                 createChildren();
1148                 computeVisualMetrics();
1149             });
1150 
1151             actionEventHandler = e -&gt; {
1152                 if (item instanceof Menu) {
1153                     final Menu menu = (Menu) item;
1154                     if (openSubmenu == menu &amp;&amp; submenu.isShowing()) return;
1155                     if (openSubmenu != null) {
1156                         hideSubmenu();
1157                     }
1158 
1159                     selectedBackground = MenuItemContainer.this;
1160                     showMenu(menu);
1161                 } else {
1162                     doSelect();
1163                 }
1164             };
1165             addEventHandler(ActionEvent.ACTION, actionEventHandler);
1166         }
1167 
1168         public void dispose() {
1169             if (item instanceof CustomMenuItem) {
1170                 Node node = ((CustomMenuItem)item).getContent();
1171                 if (node != null) {
1172                     node.removeEventHandler(MouseEvent.MOUSE_CLICKED, customMenuItemMouseClickedHandler);
1173                 }
1174             }
1175 
1176             listener.dispose();
1177             removeEventHandler(ActionEvent.ACTION, actionEventHandler);
1178 
1179             if (label != null) {
1180                 ((Label)label).textProperty().unbind();
1181                 label.styleProperty().unbind();
1182                 label.idProperty().unbind();
1183 
1184                 ListChangeListener&lt;String&gt; itemStyleClassListener = (ListChangeListener&lt;String&gt;)item.getProperties().remove(ITEM_STYLE_CLASS_LISTENER);
1185                 if (itemStyleClassListener != null) {
1186                     item.getStyleClass().removeListener(itemStyleClassListener);
1187                 }
1188             }
1189 
1190             left = null;
1191             graphic = null;
1192             label = null;
1193             right = null;
1194         }
1195 
1196         private void createChildren() {
1197             getChildren().clear();
1198 
1199             // draw background region for hover effects. All content (other
1200             // than Nodes from NodeMenuItems) are set to be mouseTransparent, so
1201             // this background also acts as the receiver of user input
1202             if (item instanceof CustomMenuItem) {
1203                 createNodeMenuItemChildren((CustomMenuItem)item);
1204 
1205                 if (mouseEnteredEventHandler == null) {
1206                     mouseEnteredEventHandler = event -&gt; {
1207                         requestFocus(); // request Focus on hover
1208                     };
1209                 } else {
1210                     removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
1211                 }
1212                 addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
1213             } else {
1214                 // --- add check / radio to left column
1215                 Node leftNode = getLeftGraphic(item);
1216                 if (leftNode != null) {
1217                     StackPane leftPane = new StackPane();
1218                     leftPane.getStyleClass().add(&quot;left-container&quot;);
1219                     leftPane.getChildren().add(leftNode);
1220                     left = leftPane;
1221                     getChildren().add(left);
1222                     left.setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
1223                 }
1224                 // -- add graphic to graphic pane
1225                 if (item.getGraphic() != null) {
1226                     Node graphicNode = item.getGraphic();
1227                     StackPane graphicPane = new StackPane();
1228                     graphicPane.getStyleClass().add(&quot;graphic-container&quot;);
1229                     graphicPane.getChildren().add(graphicNode);
1230                     graphic = graphicPane;
1231                     getChildren().add(graphic);
1232                 }
1233 
1234                 // --- add text to center column
1235                 label = new MenuLabel(item, this);  // make this a menulabel to handle mnemonics fire()
1236 
1237                 // set up bindings from the MenuItem into the Label
1238                 ((Label)label).textProperty().bind(item.textProperty());
1239                 label.styleProperty().bind(item.styleProperty());
1240                 label.idProperty().bind(item.styleProperty());
1241 
1242                 // we want to ensure that any styleclasses set on the menuitem are applied to the
1243                 // label (so we can style appropriately), but we can&#39;t just do a binding such as this:
1244                 // Bindings.bindContent(label.getStyleClass(), item.getStyleClass());
1245                 // Because that means we overwrite the &#39;label&#39; style class on the Label.
1246                 // What we really want is to ensure all style classes in the MenuItem are _copied_
1247                 // into the label, which is what we do below
1248                 ListChangeListener&lt;String&gt; itemStyleClassListener = c -&gt; {
1249                     while (c.next()) {
1250                         label.getStyleClass().removeAll(c.getRemoved());
1251                         label.getStyleClass().addAll(c.getAddedSubList());
1252                     }
1253                 };
1254                 item.getStyleClass().addListener(itemStyleClassListener);
1255                 item.getProperties().put(ITEM_STYLE_CLASS_LISTENER, itemStyleClassListener);
1256 
1257 
1258                 label.setMouseTransparent(true);
1259                 getChildren().add(label);
1260 
1261                 listener.unregisterChangeListeners(focusedProperty());
1262                 // RT-19546 update currentFocusedIndex when MenuItemContainer gets focused.
1263                 // e.g this happens when you press the Right key to open a submenu; the first
1264                 // menuitem is focused.
1265                 listener.registerChangeListener(focusedProperty(), e -&gt; {
1266                     if (isFocused()) {
1267                         currentFocusedIndex = itemsContainer.getChildren().indexOf(MenuItemContainer.this);
1268                     }
1269                 });
1270 
1271                 // --- draw in right column - this depends on whether we are
1272                 // a Menu or not. A Menu gets an arrow, whereas other MenuItems
1273                 // get the ability to draw an accelerator
1274                 if (item instanceof Menu) {
1275                     // --- add arrow / accelerator / mnemonic to right column
1276                     Region rightNode = new Region();
1277                     rightNode.setMouseTransparent(true);
1278                     rightNode.getStyleClass().add(&quot;arrow&quot;);
1279 
1280                     StackPane rightPane = new StackPane();
1281                     rightPane.setMaxWidth(Math.max(rightNode.prefWidth(-1), 10));
1282                     rightPane.setMouseTransparent(true);
1283                     rightPane.getStyleClass().add(&quot;right-container&quot;);
1284                     rightPane.getChildren().add(rightNode);
1285                     right = rightPane;
1286                     getChildren().add(rightPane);
1287 
1288                     if (mouseEnteredEventHandler == null) {
1289                         mouseEnteredEventHandler = event -&gt; {
1290                             if (openSubmenu != null &amp;&amp; item != openSubmenu) {
1291                                 // if a submenu of a different menu is already
1292                                 // open then close it (RT-15049)
1293                                 hideSubmenu();
1294                             }
1295 
1296                             selectedBackground = MenuItemContainer.this;
1297                             requestFocus();  // request Focus on hover
1298                             final Menu menu = (Menu) item;
1299                             if (menu.isDisable()) return;
1300                             menu.show();
1301                         };
1302                     } else {
1303                         removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
1304                     }
1305 
1306                     if (mouseReleasedEventHandler == null) {
1307                         mouseReleasedEventHandler = event -&gt; {
1308                             item.fire();
1309                         };
1310                     } else {
1311                         removeEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
1312                     }
1313 
1314                     // show submenu when the menu is hovered over
1315                     addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
1316                     addEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
1317                 } else { // normal MenuItem
1318                     // remove old listeners
1319                     listener.unregisterChangeListeners(item.acceleratorProperty());
1320 
1321                     // accelerator support
1322                     updateAccelerator();
1323 
1324                     if (mouseEnteredEventHandler == null) {
1325                         mouseEnteredEventHandler = event -&gt; {
1326                             if (openSubmenu != null) {
1327                                 openSubmenu.hide();
1328                             }
1329                             requestFocus();  // request Focus on hover
1330                         };
1331                     } else {
1332                         removeEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
1333                     }
1334 
1335                     if (mouseReleasedEventHandler == null) {
1336                         mouseReleasedEventHandler = event -&gt; {
1337                             doSelect();
1338                         };
1339                     } else {
1340                         removeEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
1341                     }
1342 
1343                     addEventHandler(MouseEvent.MOUSE_ENTERED, mouseEnteredEventHandler);
1344                     addEventHandler(MouseEvent.MOUSE_RELEASED, mouseReleasedEventHandler);
1345 
1346                     listener.registerChangeListener(item.acceleratorProperty(), e -&gt; updateAccelerator());
1347                 }
1348             }
1349         }
1350 
1351         private void updateAccelerator() {
1352             if (item.getAccelerator() != null) {
1353                 if (right != null) {
1354                     getChildren().remove(right);
1355                 }
1356 
1357                 String text = item.getAccelerator().getDisplayText();
1358                 right = new Label(text);
1359                 right.setStyle(item.getStyle());
1360                 right.getStyleClass().add(&quot;accelerator-text&quot;);
1361                 getChildren().add(right);
1362             } else {
1363                 getChildren().remove(right);
1364             }
1365         }
1366 
1367         void doSelect() {
1368             // don&#39;t do anything on disabled menu items
1369             if (item.isDisable()) return;
1370             // toggle state of check or radio items
1371             if (item instanceof CheckMenuItem) {
1372                 CheckMenuItem checkItem = (CheckMenuItem)item;
1373                 checkItem.setSelected(!checkItem.isSelected());
1374             } else if (item instanceof RadioMenuItem) {
1375                 // this is a radio button. If there is a toggleGroup specified, we
1376                 // simply set selected to true. If no toggleGroup is specified, we
1377                 // toggle the selected state, as there is no assumption of mutual
1378                 // exclusivity when no toggleGroup is set.
1379                 final RadioMenuItem radioItem = (RadioMenuItem) item;
1380                 radioItem.setSelected(radioItem.getToggleGroup() != null ? true : !radioItem.isSelected());
1381             }
1382 
1383             // fire the action before hiding the menu
1384             item.fire();
1385 
1386             if (item instanceof CustomMenuItem) {
1387                 CustomMenuItem customMenuItem = (CustomMenuItem) item;
1388                 if (customMenuItem.isHideOnClick()) {
1389                     hideAllMenus(item);
1390                 }
1391             } else {
1392                 hideAllMenus(item);
1393             }
1394         }
1395 
1396         private EventHandler&lt;MouseEvent&gt; customMenuItemMouseClickedHandler;
1397 
1398         private void createNodeMenuItemChildren(final CustomMenuItem item) {
1399             Node node = item.getContent();
1400             getChildren().add(node);
1401 
1402             // handle hideOnClick
1403             customMenuItemMouseClickedHandler = event -&gt; {
1404                 if (item == null || item.isDisable()) return;
1405 
1406                 item.fire();
1407                 if (item.isHideOnClick()) {
1408                     hideAllMenus(item);
1409                 }
1410             };
1411             node.addEventHandler(MouseEvent.MOUSE_CLICKED, customMenuItemMouseClickedHandler);
1412         }
1413 
1414         @Override protected void layoutChildren() {
1415             double xOffset;
1416 
1417             final double prefHeight = prefHeight(-1);
1418             if (left != null) {
1419                 xOffset = snappedLeftInset();
1420                 left.resize(left.prefWidth(-1), left.prefHeight(-1));
1421                 positionInArea(left, xOffset, 0,
1422                         maxLeftWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
1423             }
1424             if (graphic != null) {
1425                 xOffset = snappedLeftInset() + maxLeftWidth;
1426                 graphic.resize(graphic.prefWidth(-1), graphic.prefHeight(-1));
1427                 positionInArea(graphic, xOffset, 0,
1428                         maxGraphicWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
1429             }
1430 
1431             if (label != null) {
1432                 xOffset = snappedLeftInset() + maxLeftWidth + maxGraphicWidth;
1433                 label.resize(label.prefWidth(-1), label.prefHeight(-1));
1434                 positionInArea(label, xOffset, 0,
1435                         maxLabelWidth, prefHeight, 0, HPos.LEFT, VPos.CENTER);
1436             }
1437 
1438             if (right != null) {
1439                 xOffset = snappedLeftInset() + maxLeftWidth + maxGraphicWidth + maxLabelWidth;
1440                 right.resize(right.prefWidth(-1), right.prefHeight(-1));
1441                 positionInArea(right, xOffset, 0,
1442                     maxRightWidth, prefHeight, 0, HPos.RIGHT, VPos.CENTER);
1443             }
1444 
1445             if ( item instanceof CustomMenuItem) {
1446                 Node n = ((CustomMenuItem) item).getContent();
1447                 if (item instanceof SeparatorMenuItem) {
1448                     double width = prefWidth(-1) - (snappedLeftInset() + maxGraphicWidth + snappedRightInset());
1449                     n.resize(width, n.prefHeight(-1));
1450                     positionInArea(n, snappedLeftInset() + maxGraphicWidth, 0, prefWidth(-1), prefHeight, 0, HPos.LEFT, VPos.CENTER);
1451                 } else {
1452                     n.resize(n.prefWidth(-1), n.prefHeight(-1));
1453                     //the node should be left aligned
1454                     positionInArea(n, snappedLeftInset(), 0, getWidth(), prefHeight, 0, HPos.LEFT, VPos.CENTER);
1455                 }
1456             }
1457         }
1458 
1459         @Override protected double computePrefHeight(double width) {
1460             double prefHeight = 0;
1461             if (item instanceof CustomMenuItem || item instanceof SeparatorMenuItem) {
1462                 prefHeight = (getChildren().isEmpty()) ? 0 : getChildren().get(0).prefHeight(-1);
1463             } else {
1464                 prefHeight = Math.max(prefHeight, (left != null) ? left.prefHeight(-1) : 0);
1465                 prefHeight = Math.max(prefHeight, (graphic != null) ? graphic.prefHeight(-1) : 0);
1466                 prefHeight = Math.max(prefHeight, (label != null) ? label.prefHeight(-1) : 0);
1467                 prefHeight = Math.max(prefHeight, (right != null) ? right.prefHeight(-1) : 0);
1468             }
1469              return snappedTopInset() + prefHeight + snappedBottomInset();
1470         }
1471 
1472         @Override protected double computePrefWidth(double height) {
1473             double nodeMenuItemWidth = 0;
1474             if (item instanceof CustomMenuItem &amp;&amp; !(item instanceof SeparatorMenuItem)) {
1475                 nodeMenuItemWidth = snappedLeftInset() + ((CustomMenuItem) item).getContent().prefWidth(-1) +
1476                         snappedRightInset();
1477             }
1478             return Math.max(nodeMenuItemWidth,
1479                     snappedLeftInset() + maxLeftWidth + maxGraphicWidth +
1480                     maxLabelWidth + maxRightWidth + snappedRightInset());
1481         }
1482 
1483         // Responsible for returning a graphic (if necessary) to position in the
1484         // left column of the menu. This may be a Node from the MenuItem.graphic
1485         // property, or it may be a check/radio item if necessary.
1486         private Node getLeftGraphic(MenuItem item) {
1487             if (item instanceof RadioMenuItem) {
1488                  final Region _graphic = new Region();
1489                 _graphic.getStyleClass().add(&quot;radio&quot;);
1490                 return _graphic;
1491             } else if (item instanceof CheckMenuItem) {
1492                 final StackPane _graphic = new StackPane();
1493                 _graphic.getStyleClass().add(&quot;check&quot;);
1494                 return _graphic;
1495             }
1496 
1497             return null;
1498         }
1499 
1500         /** {@inheritDoc} */
1501         @Override
1502         public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1503             switch (attribute) {
1504                 case SELECTED:
1505                     if (item instanceof CheckMenuItem) {
1506                         return ((CheckMenuItem)item).isSelected();
1507                     }
1508                     if (item instanceof RadioMenuItem) {
1509                         return ((RadioMenuItem) item).isSelected();
1510                     }
1511                     return false;
1512                 case ACCELERATOR: return item.getAccelerator();
1513                 case TEXT: {
1514                     String title = &quot;&quot;;
1515                     if (graphic != null) {
1516                         String t = (String)graphic.queryAccessibleAttribute(AccessibleAttribute.TEXT);
1517                         if (t != null) title += t;
1518                     }
1519                     final Label label = getLabel();
1520                     if (label != null) {
1521                         String t = (String)label.queryAccessibleAttribute(AccessibleAttribute.TEXT);
1522                         if (t != null) title += t;
1523                     }
1524                     if (item instanceof CustomMenuItem) {
1525                         Node content = ((CustomMenuItem) item).getContent();
1526                         if (content != null) {
1527                             String t = (String)content.queryAccessibleAttribute(AccessibleAttribute.TEXT);
1528                             if (t != null) title += t;
1529                         }
1530                     }
1531                     return title;
1532                 }
1533                 case MNEMONIC: {
1534                     final Label label = getLabel();
1535                     if (label != null) {
1536                         String mnemonic = (String)label.queryAccessibleAttribute(AccessibleAttribute.MNEMONIC);
1537                         if (mnemonic != null) return mnemonic;
1538                     }
1539                     return null;
1540                 }
1541                 case DISABLED: return item.isDisable();
1542                 case SUBMENU:
1543                     createSubmenu();
1544                     // Accessibility might need to see the menu node before the window
1545                     // is visible (i.e. before the skin is applied).
1546                     if (submenu.getSkin() == null) {
1547                         submenu.getStyleableNode().applyCss();
1548                     }
1549                     ContextMenuContent cmContent = (ContextMenuContent)submenu.getSkin().getNode();
1550                     return cmContent.itemsContainer;
1551                 default: return super.queryAccessibleAttribute(attribute, parameters);
1552             }
1553         }
1554 
1555         /** {@inheritDoc} */
1556         @Override
1557         public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
1558             switch (action) {
1559                 case SHOW_MENU:{
1560                     if (item instanceof Menu) {
1561                         final Menu menuItem = (Menu) item;
1562                         if (menuItem.isShowing()) {
1563                             menuItem.hide();
1564                         } else {
1565                             menuItem.show();
1566                         }
1567                     }
1568                     break;
1569                 }
1570                 case FIRE:
1571                     doSelect();
1572                     break;
1573                 default: super.executeAccessibleAction(action);
1574             }
1575         }
1576     }
1577 
1578 
1579     private static final PseudoClass SELECTED_PSEUDOCLASS_STATE =
1580             PseudoClass.getPseudoClass(&quot;selected&quot;);
1581     private static final PseudoClass DISABLED_PSEUDOCLASS_STATE =
1582             PseudoClass.getPseudoClass(&quot;disabled&quot;);
1583     private static final PseudoClass CHECKED_PSEUDOCLASS_STATE =
1584             PseudoClass.getPseudoClass(&quot;checked&quot;);
1585 
1586     private class MenuLabel extends Label {
1587 
1588         public MenuLabel(MenuItem item, MenuItemContainer mic) {
1589             super(item.getText());
1590             setMnemonicParsing(item.isMnemonicParsing());
1591             setLabelFor(mic);
1592         }
1593     }
1594 
1595 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/java/javafx/scene/web/WebEngine.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.web;
  27 
  28 import com.sun.javafx.logging.PlatformLogger;
  29 import com.sun.javafx.scene.web.Debugger;
  30 import com.sun.javafx.scene.web.Printable;
  31 import com.sun.javafx.tk.TKPulseListener;
  32 import com.sun.javafx.tk.Toolkit;
  33 import com.sun.javafx.webkit.*;
  34 import com.sun.javafx.webkit.prism.PrismGraphicsManager;
  35 import com.sun.javafx.webkit.prism.PrismInvoker;
  36 import com.sun.javafx.webkit.prism.theme.PrismRenderer;
  37 import com.sun.javafx.webkit.theme.RenderThemeImpl;
  38 import com.sun.javafx.webkit.theme.Renderer;
  39 import com.sun.webkit.*;
  40 import com.sun.webkit.graphics.WCGraphicsManager;
  41 import com.sun.webkit.network.URLs;
  42 import com.sun.webkit.network.Util;
  43 import javafx.animation.AnimationTimer;
  44 import javafx.application.Platform;
  45 import javafx.beans.InvalidationListener;
  46 import javafx.beans.property.*;
  47 import javafx.concurrent.Worker;
  48 import javafx.event.EventHandler;
  49 import javafx.event.EventType;
  50 import javafx.geometry.Rectangle2D;
  51 import javafx.print.PageLayout;
  52 import javafx.print.PrinterJob;
  53 import javafx.scene.Node;
  54 import javafx.util.Callback;
  55 import org.w3c.dom.Document;
  56 
  57 import java.io.BufferedInputStream;
  58 import java.io.File;
  59 import java.io.IOException;
  60 import static java.lang.String.format;
  61 import java.lang.ref.WeakReference;
  62 import java.net.MalformedURLException;
  63 import java.net.URLConnection;
  64 import java.nio.file.Files;
  65 import java.nio.file.Path;
  66 import java.nio.file.attribute.PosixFilePermissions;
  67 import java.security.AccessController;
  68 import java.security.PrivilegedAction;
  69 import java.util.ArrayList;
  70 import java.util.Base64;
  71 import java.util.List;
  72 import java.util.Objects;
  73 
  74 import static com.sun.webkit.LoadListenerClient.*;
  75 
  76 /**
  77  * {@code WebEngine} is a non-visual object capable of managing one Web page
  78  * at a time. It loads Web pages, creates their document models, applies
  79  * styles as necessary, and runs JavaScript on pages. It provides access
  80  * to the document model of the current page, and enables two-way
  81  * communication between a Java application and JavaScript code of the page.
  82  *
  83  * &lt;p&gt;&lt;b&gt;Loading Web Pages&lt;/b&gt;&lt;/p&gt;
  84  * &lt;p&gt;The {@code WebEngine} class provides two ways to load content into a
  85  * {@code WebEngine} object:
  86  * &lt;ul&gt;
  87  * &lt;li&gt;From an arbitrary URL using the {@link #load} method. This method uses
  88  *     the {@code java.net} package for network access and protocol handling.
  89  * &lt;li&gt;From an in-memory String using the
  90  *     {@link #loadContent(java.lang.String, java.lang.String)} and
  91  *     {@link #loadContent(java.lang.String)} methods.
  92  * &lt;/ul&gt;
  93  * &lt;p&gt;Loading always happens on a background thread. Methods that initiate
  94  * loading return immediately after scheduling a background job. To track
  95  * progress and/or cancel a job, use the {@link javafx.concurrent.Worker}
  96  * instance available from the {@link #getLoadWorker} method.
  97  *
  98  * &lt;p&gt;The following example changes the stage title when loading completes
  99  * successfully:
 100  * &lt;pre&gt;{@code
 101     import javafx.concurrent.Worker.State;
 102     final Stage stage;
 103     webEngine.getLoadWorker().stateProperty().addListener(
 104         new ChangeListener&lt;State&gt;() {
 105             public void changed(ObservableValue ov, State oldState, State newState) {
 106                 if (newState == State.SUCCEEDED) {
 107                     stage.setTitle(webEngine.getLocation());
 108                 }
 109             }
 110         });
 111     webEngine.load(&quot;http://javafx.com&quot;);
 112  * }&lt;/pre&gt;
 113  *
 114  * &lt;p&gt;&lt;b&gt;User Interface Callbacks&lt;/b&gt;&lt;/p&gt;
 115  * &lt;p&gt;A number of user interface callbacks may be registered with a
 116  * {@code WebEngine} object. These callbacks are invoked when a script running
 117  * on the page requests a user interface operation to be performed, for
 118  * example, opens a popup window or changes status text. A {@code WebEngine}
 119  * object cannot handle such requests internally, so it passes the request to
 120  * the corresponding callbacks. If no callback is defined for a specific
 121  * operation, the request is silently ignored.
 122  *
 123  * &lt;p&gt;The table below shows JavaScript user interface methods and properties
 124  * with their corresponding {@code WebEngine} callbacks:
 125  * &lt;table border=&quot;1&quot;&gt;
 126  * &lt;caption&gt;JavaScript Callback Table&lt;/caption&gt;
 127  * &lt;tr&gt;
 128  *     &lt;th scope=&quot;col&quot;&gt;JavaScript method/property&lt;/th&gt;
 129  *     &lt;th scope=&quot;col&quot;&gt;WebEngine callback&lt;/th&gt;
 130  * &lt;/tr&gt;
 131  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.alert()}&lt;/th&gt;&lt;td&gt;{@code onAlert}&lt;/td&gt;&lt;/tr&gt;
 132  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.confirm()}&lt;/th&gt;&lt;td&gt;{@code confirmHandler}&lt;/td&gt;&lt;/tr&gt;
 133  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.open()}&lt;/th&gt;&lt;td&gt;{@code createPopupHandler}&lt;/td&gt;&lt;/tr&gt;
 134  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.open()} and&lt;br&gt;
 135  *         {@code window.close()}&lt;/th&gt;&lt;td&gt;{@code onVisibilityChanged}&lt;/td&gt;&lt;/tr&gt;
 136  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code window.prompt()}&lt;/th&gt;&lt;td&gt;{@code promptHandler}&lt;/td&gt;&lt;/tr&gt;
 137  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Setting {@code window.status}&lt;/th&gt;&lt;td&gt;{@code onStatusChanged}&lt;/td&gt;&lt;/tr&gt;
 138  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Setting any of the following:&lt;br&gt;
 139  *         {@code window.innerWidth}, {@code window.innerHeight},&lt;br&gt;
 140  *         {@code window.outerWidth}, {@code window.outerHeight},&lt;br&gt;
 141  *         {@code window.screenX}, {@code window.screenY},&lt;br&gt;
 142  *         {@code window.screenLeft}, {@code window.screenTop}&lt;/th&gt;
 143  *         &lt;td&gt;{@code onResized}&lt;/td&gt;&lt;/tr&gt;
 144  * &lt;/table&gt;
 145  *
 146  * &lt;p&gt;The following example shows a callback that resizes a browser window:
 147  * &lt;pre&gt;{@code
 148     Stage stage;
 149     webEngine.setOnResized(
 150         new EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;() {
 151             public void handle(WebEvent&lt;Rectangle2D&gt; ev) {
 152                 Rectangle2D r = ev.getData();
 153                 stage.setWidth(r.getWidth());
 154                 stage.setHeight(r.getHeight());
 155             }
 156         });
 157  * }&lt;/pre&gt;
 158  *
 159  * &lt;p&gt;&lt;b&gt;Access to Document Model&lt;/b&gt;&lt;/p&gt;
 160  * &lt;p&gt;The {@code WebEngine} objects create and manage a Document Object Model
 161  * (DOM) for their Web pages. The model can be accessed and modified using
 162  * Java DOM Core classes. The {@link #getDocument()} method provides access
 163  * to the root of the model. Additionally DOM Event specification is supported
 164  * to define event handlers in Java code.
 165  *
 166  * &lt;p&gt;The following example attaches a Java event listener to an element of
 167  * a Web page. Clicking on the element causes the application to exit:
 168  * &lt;pre&gt;{@code
 169     EventListener listener = new EventListener() {
 170         public void handleEvent(Event ev) {
 171             Platform.exit();
 172         }
 173     };
 174 
 175     Document doc = webEngine.getDocument();
 176     Element el = doc.getElementById(&quot;exit-app&quot;);
 177     ((EventTarget) el).addEventListener(&quot;click&quot;, listener, false);
 178  * }&lt;/pre&gt;
 179  *
 180  * &lt;p&gt;&lt;b&gt;Evaluating JavaScript expressions&lt;/b&gt;&lt;/p&gt;
 181  * &lt;p&gt;It is possible to execute arbitrary JavaScript code in the context of
 182  * the current page using the {@link #executeScript} method. For example:
 183  * &lt;pre&gt;{@code
 184     webEngine.executeScript(&quot;history.back()&quot;);
 185  * }&lt;/pre&gt;
 186  *
 187  * &lt;p&gt;The execution result is returned to the caller,
 188  * as described in the next section.
 189  *
 190  * &lt;p&gt;&lt;b&gt;Mapping JavaScript values to Java objects&lt;/b&gt;&lt;/p&gt;
 191  *
 192  * JavaScript values are represented using the obvious Java classes:
 193  * null becomes Java null; a boolean becomes a {@code java.lang.Boolean};
 194  * and a string becomes a {@code java.lang.String}.
 195  * A number can be {@code java.lang.Double} or a {@code java.lang.Integer},
 196  * depending.
 197  * The undefined value maps to a specific unique String
 198  * object whose value is {@code &quot;undefined&quot;}.
 199  * &lt;p&gt;
 200  * If the result is a
 201  * JavaScript object, it is wrapped as an instance of the
 202  * {@link netscape.javascript.JSObject} class.
 203  * (As a special case, if the JavaScript object is
 204  * a {@code JavaRuntimeObject} as discussed in the next section,
 205  * then the original Java object is extracted instead.)
 206  * The {@code JSObject} class is a proxy that provides access to
 207  * methods and properties of its underlying JavaScript object.
 208  * The most commonly used {@code JSObject} methods are
 209  * {@link netscape.javascript.JSObject#getMember getMember}
 210  * (to read a named property),
 211  * {@link netscape.javascript.JSObject#setMember setMember}
 212  * (to set or define a property),
 213  * and {@link netscape.javascript.JSObject#call call}
 214  * (to call a function-valued property).
 215  * &lt;p&gt;
 216  * A DOM {@code Node} is mapped to an object that both extends
 217  * {@code JSObject} and implements the appropriate DOM interfaces.
 218  * To get a {@code JSObject} object for a {@code Node} just do a cast:
 219  * &lt;pre&gt;
 220  * JSObject jdoc = (JSObject) webEngine.getDocument();
 221  * &lt;/pre&gt;
 222  * &lt;p&gt;
 223  * In some cases the context provides a specific Java type that guides
 224  * the conversion.
 225  * For example if setting a Java {@code String} field from a JavaScript
 226  * expression, then the JavaScript value is converted to a string.
 227  *
 228  * &lt;p&gt;&lt;b&gt;Mapping Java objects to JavaScript values&lt;/b&gt;&lt;/p&gt;
 229  *
 230  * The arguments of the {@code JSObject} methods {@code setMember} and
 231  * {@code call} pass Java objects to the JavaScript environment.
 232  * This is roughly the inverse of the JavaScript-to-Java mapping
 233  * described above:
 234  * Java {@code String},  {@code Number}, or {@code Boolean} objects
 235  * are converted to the obvious JavaScript values. A  {@code JSObject}
 236  * object is converted to the original wrapped JavaScript object.
 237  * Otherwise a {@code JavaRuntimeObject} is created.  This is
 238  * a JavaScript object that acts as a proxy for the Java object,
 239  * in that accessing properties of the {@code JavaRuntimeObject}
 240  * causes the Java field or method with the same name to be accessed.
 241  * &lt;p&gt; Note that the Java objects bound using
 242  * {@link netscape.javascript.JSObject#setMember JSObject.setMember},
 243  * {@link netscape.javascript.JSObject#setSlot JSObject.setSlot}, and
 244  * {@link netscape.javascript.JSObject#call JSObject.call}
 245  * are implemented using weak references. This means that the Java object
 246  * can be garbage collected, causing subsequent accesses to the JavaScript
 247  * objects to have no effect.
 248  *
 249  * &lt;p&gt;&lt;b&gt;Calling back to Java from JavaScript&lt;/b&gt;&lt;/p&gt;
 250  *
 251  * &lt;p&gt;The {@link netscape.javascript.JSObject#setMember JSObject.setMember}
 252  * method is useful to enable upcalls from JavaScript
 253  * into Java code, as illustrated by the following example. The Java code
 254  * establishes a new JavaScript object named {@code app}. This object has one
 255  * public member, the method {@code exit}.
 256  * &lt;pre&gt;&lt;code&gt;
 257 public class JavaApplication {
 258     public void exit() {
 259         Platform.exit();
 260     }
 261 }
 262 ...
 263 JavaApplication javaApp = new JavaApplication();
 264 JSObject window = (JSObject) webEngine.executeScript(&quot;window&quot;);
 265 window.setMember(&quot;app&quot;, javaApp);
 266  * &lt;/code&gt;&lt;/pre&gt;
 267  * You can then refer to the object and the method from your HTML page:
 268  * &lt;pre&gt;{@code
 269     &lt;a href=&quot;&quot; onclick=&quot;app.exit()&quot;&gt;Click here to exit application&lt;/a&gt;
 270  * }&lt;/pre&gt;
 271  * &lt;p&gt;When a user clicks the link the application is closed.
 272  * &lt;p&gt;
 273  * Note that in the above example, the application holds a reference
 274  * to the {@code JavaApplication} instance. This is required for the callback
 275  * from JavaScript to execute the desired method.
 276  * &lt;p&gt; In the following example, the application does not hold a reference
 277  * to the Java object:
 278  * &lt;pre&gt;&lt;code&gt;
 279  * JSObject window = (JSObject) webEngine.executeScript(&quot;window&quot;);
 280  * window.setMember(&quot;app&quot;, new JavaApplication());
 281  * &lt;/code&gt;&lt;/pre&gt;
 282  * &lt;p&gt; In this case, since the property value is a local object, {@code &quot;new JavaApplication()&quot;},
 283  * the value may be garbage collected in next GC cycle.
 284  * &lt;p&gt;
 285  * When a user clicks the link, it does not guarantee to execute the callback method {@code exit}.
 286  * &lt;p&gt;
 287  * If there are multiple Java methods with the given name,
 288  * then the engine selects one matching the number of parameters
 289  * in the call.  (Varargs are not handled.) An unspecified one is
 290  * chosen if there are multiple ones with the correct number of parameters.
 291  * &lt;p&gt;
 292  * You can pick a specific overloaded method by listing the
 293  * parameter types in an &quot;extended method name&quot;, which has the
 294  * form &lt;code&gt;&quot;&lt;var&gt;method_name&lt;/var&gt;(&lt;var&gt;param_type1&lt;/var&gt;,...,&lt;var&gt;param_typen&lt;/var&gt;)&quot;&lt;/code&gt;.  Typically you&#39;d write the JavaScript expression:
 295  * &lt;pre&gt;
 296  * &lt;code&gt;&lt;var&gt;receiver&lt;/var&gt;[&quot;&lt;var&gt;method_name&lt;/var&gt;(&lt;var&gt;param_type1&lt;/var&gt;,...,&lt;var&gt;param_typeN&lt;/var&gt;)&quot;](&lt;var&gt;arg1&lt;/var&gt;,...,&lt;var&gt;argN&lt;/var&gt;)&lt;/code&gt;
 297  * &lt;/pre&gt;
 298  *
 299  * &lt;p&gt;
 300  * The Java class and method must both be declared public.
 301  * &lt;/p&gt;
 302  *
 303  * &lt;p&gt;&lt;b&gt;Deploying an Application as a Module&lt;/b&gt;&lt;/p&gt;
 304  * &lt;p&gt;
 305  * If any Java class passed to JavaScript is in a named module, then it must
 306  * be reflectively accessible to the {@code javafx.web} module.
 307  * A class is reflectively accessible if the module
 308  * {@link Module#isOpen(String,Module) opens} the containing package to at
 309  * least the {@code javafx.web} module.
 310  * Otherwise, the method will not be called, and no error or
 311  * warning will be produced.
 312  * &lt;/p&gt;
 313  * &lt;p&gt;
 314  * For example, if {@code com.foo.MyClass} is in the {@code foo.app} module,
 315  * the {@code module-info.java} might
 316  * look like this:
 317  * &lt;/p&gt;
 318  *
 319 &lt;pre&gt;{@code module foo.app {
 320     opens com.foo to javafx.web;
 321 }}&lt;/pre&gt;
 322  *
 323  * &lt;p&gt;
 324  * Alternatively, a class is reflectively accessible if the module
 325  * {@link Module#isExported(String) exports} the containing package
 326  * unconditionally.
 327  * &lt;/p&gt;
 328  *
<a name="1" id="anc1"></a><span class="line-added"> 329  * &lt;p&gt;</span>
<span class="line-added"> 330  * Starting with JavaFX 14, &lt;a href=&quot;https://tools.ietf.org/html/rfc7540&quot;&gt;HTTP/2&lt;/a&gt; support has been added to WebEngine.</span>
<span class="line-added"> 331  * This is achieved by using {@link java.net.http.HttpClient} instead of {@link URLConnection}. HTTP/2 is activated</span>
<span class="line-added"> 332  * by default when JavaFX 14 (or later) is used with JDK 12 (or later).</span>
<span class="line-added"> 333  * &lt;/p&gt;</span>
<span class="line-added"> 334  *</span>
 335  * &lt;p&gt;&lt;b&gt;Threading&lt;/b&gt;&lt;/p&gt;
 336  * &lt;p&gt;{@code WebEngine} objects must be created and accessed solely from the
 337  * JavaFX Application thread. This rule also applies to any DOM and JavaScript
 338  * objects obtained from the {@code WebEngine} object.
 339  * @since JavaFX 2.0
 340  */
 341 final public class WebEngine {
 342     static {
 343         Accessor.setPageAccessor(w -&gt; w == null ? null : w.getPage());
 344 
 345         Invoker.setInvoker(new PrismInvoker());
 346         Renderer.setRenderer(new PrismRenderer());
 347         WCGraphicsManager.setGraphicsManager(new PrismGraphicsManager());
 348         CursorManager.setCursorManager(new CursorManagerImpl());
 349         com.sun.webkit.EventLoop.setEventLoop(new EventLoopImpl());
 350         ThemeClient.setDefaultRenderTheme(new RenderThemeImpl());
 351         Utilities.setUtilities(new UtilitiesImpl());
 352     }
 353 
 354     private static final PlatformLogger logger =
 355             PlatformLogger.getLogger(WebEngine.class.getName());
 356 
 357     /**
 358      * The number of instances of this class.
 359      * Used to start and stop the pulse timer.
 360      */
 361     private static int instanceCount = 0;
 362 
 363     /**
 364      * The node associated with this engine. There is a one-to-one correspondence
 365      * between the WebView and its WebEngine (although not all WebEngines have
 366      * a WebView, every WebView has one and only one WebEngine).
 367      */
 368     private final ObjectProperty&lt;WebView&gt; view = new SimpleObjectProperty&lt;WebView&gt;(this, &quot;view&quot;);
 369 
 370     /**
 371      * The Worker which shows progress of the web engine as it loads pages.
 372      */
 373     private final LoadWorker loadWorker = new LoadWorker();
 374 
 375     /**
 376      * The object that provides interaction with the native webkit core.
 377      */
 378     private final WebPage page;
 379 
 380     private final SelfDisposer disposer;
 381 
 382     private final DebuggerImpl debugger = new DebuggerImpl();
 383 
 384     private boolean userDataDirectoryApplied = false;
 385 
 386 
 387     /**
 388      * Returns a {@link javafx.concurrent.Worker} object that can be used to
 389      * track loading progress.
 390      *
 391      * @return the {@code Worker} object
 392      */
 393     public final Worker&lt;Void&gt; getLoadWorker() {
 394         return loadWorker;
 395     }
 396 
 397 
 398     /*
 399      * The final document. This may be null if no document has been loaded.
 400      */
 401     private final DocumentProperty document = new DocumentProperty();
 402 
 403     public final Document getDocument() { return document.getValue(); }
 404 
 405     /**
 406      * Document object for the current Web page. The value is {@code null}
 407      * if the Web page failed to load.
 408      *
 409      * @return the document property
 410      */
 411     public final ReadOnlyObjectProperty&lt;Document&gt; documentProperty() {
 412         return document;
 413     }
 414 
 415 
 416     /*
 417      * The location of the current page. This may return null.
 418      */
 419     private final ReadOnlyStringWrapper location = new ReadOnlyStringWrapper(this, &quot;location&quot;);
 420 
 421     public final String getLocation() { return location.getValue(); }
 422 
 423     /**
 424      * URL of the current Web page. If the current page has no URL,
 425      * the value is an empty String.
 426      *
 427      * @return the location property
 428      */
 429     public final ReadOnlyStringProperty locationProperty() { return location.getReadOnlyProperty(); }
 430 
 431     private void updateLocation(String value) {
 432         this.location.set(value);
 433         this.document.invalidate(false);
 434         this.title.set(null);
 435     }
 436 
 437 
 438     /*
 439      * The page title.
 440      */
 441     private final ReadOnlyStringWrapper title = new ReadOnlyStringWrapper(this, &quot;title&quot;);
 442 
 443     public final String getTitle() { return title.getValue(); }
 444 
 445     /**
 446      * Title of the current Web page. If the current page has no title,
 447      * the value is {@code null}.
 448      *
 449      * @return the title property
 450      */
 451     public final ReadOnlyStringProperty titleProperty() { return title.getReadOnlyProperty(); }
 452 
 453     private void updateTitle() {
 454         title.set(page.getTitle(page.getMainFrame()));
 455     }
 456 
 457     //
 458     // Settings
 459 
 460     /**
 461      * Specifies whether JavaScript execution is enabled.
 462      *
 463      * @defaultValue true
 464      * @since JavaFX 2.2
 465      */
 466     private BooleanProperty javaScriptEnabled;
 467 
 468     public final void setJavaScriptEnabled(boolean value) {
 469         javaScriptEnabledProperty().set(value);
 470     }
 471 
 472     public final boolean isJavaScriptEnabled() {
 473         return javaScriptEnabled == null ? true : javaScriptEnabled.get();
 474     }
 475 
 476     public final BooleanProperty javaScriptEnabledProperty() {
 477         if (javaScriptEnabled == null) {
 478             javaScriptEnabled = new BooleanPropertyBase(true) {
 479                 @Override public void invalidated() {
 480                     checkThread();
 481                     page.setJavaScriptEnabled(get());
 482                 }
 483 
 484                 @Override public Object getBean() {
 485                     return WebEngine.this;
 486                 }
 487 
 488                 @Override public String getName() {
 489                     return &quot;javaScriptEnabled&quot;;
 490                 }
 491             };
 492         }
 493         return javaScriptEnabled;
 494     }
 495 
 496     /**
 497      * Location of the user stylesheet as a string URL.
 498      *
 499      * &lt;p&gt;This should be a local URL, i.e. either {@code &#39;data:&#39;},
 500      * {@code &#39;file:&#39;}, or {@code &#39;jar:&#39;}. Remote URLs are not allowed
 501      * for security reasons.
 502      *
 503      * @defaultValue null
 504      * @since JavaFX 2.2
 505      */
 506     private StringProperty userStyleSheetLocation;
 507 
 508     public final void setUserStyleSheetLocation(String value) {
 509         userStyleSheetLocationProperty().set(value);
 510     }
 511 
 512     public final String getUserStyleSheetLocation() {
 513         return userStyleSheetLocation == null ? null : userStyleSheetLocation.get();
 514     }
 515 
 516     private byte[] readFully(BufferedInputStream in) throws IOException {
 517         final int BUF_SIZE = 4096;
 518         int outSize = 0;
 519         final List&lt;byte[]&gt; outList = new ArrayList&lt;&gt;();
 520         byte[] buffer = new byte[BUF_SIZE];
 521 
 522         while (true) {
 523             int nBytes = in.read(buffer);
 524             if (nBytes &lt; 0) break;
 525 
 526             byte[] chunk;
 527             if (nBytes == buffer.length) {
 528                 chunk = buffer;
 529                 buffer = new byte[BUF_SIZE];
 530             } else {
 531                 chunk = new byte[nBytes];
 532                 System.arraycopy(buffer, 0, chunk, 0, nBytes);
 533             }
 534             outList.add(chunk);
 535             outSize += nBytes;
 536         }
 537 
 538         final byte[] out = new byte[outSize];
 539         int outPos = 0;
 540         for (byte[] chunk : outList) {
 541             System.arraycopy(chunk, 0, out, outPos, chunk.length);
 542             outPos += chunk.length;
 543         }
 544 
 545         return out;
 546     }
 547 
 548     public final StringProperty userStyleSheetLocationProperty() {
 549         if (userStyleSheetLocation == null) {
 550             userStyleSheetLocation = new StringPropertyBase(null) {
 551                 private final static String DATA_PREFIX = &quot;data:text/css;charset=utf-8;base64,&quot;;
 552 
 553                 @Override public void invalidated() {
 554                     checkThread();
 555                     String url = get();
 556                     String dataUrl;
 557                     if (url == null || url.length() &lt;= 0) {
 558                         dataUrl = null;
 559                     } else if (url.startsWith(DATA_PREFIX)) {
 560                         dataUrl = url;
 561                     } else if (url.startsWith(&quot;file:&quot;) ||
 562                                url.startsWith(&quot;jar:&quot;)  ||
 563                                url.startsWith(&quot;data:&quot;))
 564                     {
 565                         try {
 566                             URLConnection conn = URLs.newURL(url).openConnection();
 567                             conn.connect();
 568 
 569                             BufferedInputStream in =
 570                                     new BufferedInputStream(conn.getInputStream());
 571                             byte[] inBytes = readFully(in);
 572                             String out = Base64.getMimeEncoder().encodeToString(inBytes);
 573                             dataUrl = DATA_PREFIX + out;
 574                         } catch (IOException e) {
 575                             throw new RuntimeException(e);
 576                         }
 577                     } else {
 578                         throw new IllegalArgumentException(&quot;Invalid stylesheet URL&quot;);
 579                     }
 580                     page.setUserStyleSheetLocation(dataUrl);
 581                 }
 582 
 583                 @Override public Object getBean() {
 584                     return WebEngine.this;
 585                 }
 586 
 587                 @Override public String getName() {
 588                     return &quot;userStyleSheetLocation&quot;;
 589                 }
 590             };
 591         }
 592         return userStyleSheetLocation;
 593     }
 594 
 595     /**
 596      * Specifies the directory to be used by this {@code WebEngine}
 597      * to store local user data.
 598      *
 599      * &lt;p&gt;If the value of this property is not {@code null},
 600      * the {@code WebEngine} will attempt to store local user data
 601      * in the respective directory.
 602      * If the value of this property is {@code null},
 603      * the {@code WebEngine} will attempt to store local user data
 604      * in an automatically selected system-dependent user- and
 605      * application-specific directory.
 606      *
 607      * &lt;p&gt;When a {@code WebEngine} is about to start loading a web
 608      * page or executing a script for the first time, it checks whether
 609      * it can actually use the directory specified by this property.
 610      * If the check fails for some reason, the {@code WebEngine} invokes
 611      * the {@link WebEngine#onErrorProperty WebEngine.onError} event handler,
 612      * if any, with a {@link WebErrorEvent} describing the reason.
 613      * If the invoked event handler modifies the {@code userDataDirectory}
 614      * property, the {@code WebEngine} retries with the new value as soon
 615      * as the handler returns. If the handler does not modify the
 616      * {@code userDataDirectory} property (which is the default),
 617      * the {@code WebEngine} continues without local user data.
 618      *
 619      * &lt;p&gt;Once the {@code WebEngine} has started loading a web page or
 620      * executing a script, changes made to this property have no effect
 621      * on where the {@code WebEngine} stores or will store local user
 622      * data.
 623      *
 624      * &lt;p&gt;Currently, the directory specified by this property is used
 625      * only to store the data that backs the {@code window.localStorage}
 626      * objects. In the future, more types of data can be added.
 627      *
 628      * @defaultValue {@code null}
 629      * @since JavaFX 8.0
 630      */
 631     private final ObjectProperty&lt;File&gt; userDataDirectory =
 632             new SimpleObjectProperty&lt;&gt;(this, &quot;userDataDirectory&quot;);
 633 
 634     public final File getUserDataDirectory() {
 635         return userDataDirectory.get();
 636     }
 637 
 638     public final void setUserDataDirectory(File value) {
 639         userDataDirectory.set(value);
 640     }
 641 
 642     public final ObjectProperty&lt;File&gt; userDataDirectoryProperty() {
 643         return userDataDirectory;
 644     }
 645 
 646     /**
 647      * Specifies user agent ID string. This string is the value of the
 648      * {@code User-Agent} HTTP header.
 649      *
 650      * @defaultValue system dependent
 651      * @since JavaFX 8.0
 652      */
 653     private StringProperty userAgent;
 654 
 655     public final void setUserAgent(String value) {
 656         userAgentProperty().set(value);
 657     }
 658 
 659     public final String getUserAgent() {
 660         return userAgent == null ? page.getUserAgent() : userAgent.get();
 661     }
 662 
 663     public final StringProperty userAgentProperty() {
 664         if (userAgent == null) {
 665             userAgent = new StringPropertyBase(page.getUserAgent()) {
 666                 @Override public void invalidated() {
 667                     checkThread();
 668                     page.setUserAgent(get());
 669                 }
 670 
 671                 @Override public Object getBean() {
 672                     return WebEngine.this;
 673                 }
 674 
 675                 @Override public String getName() {
 676                     return &quot;userAgent&quot;;
 677                 }
 678             };
 679         }
 680         return userAgent;
 681     }
 682 
 683     private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onAlert
 684             = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt;(this, &quot;onAlert&quot;);
 685 
 686     public final EventHandler&lt;WebEvent&lt;String&gt;&gt; getOnAlert() { return onAlert.get(); }
 687 
 688     public final void setOnAlert(EventHandler&lt;WebEvent&lt;String&gt;&gt; handler) { onAlert.set(handler); }
 689 
 690     /**
 691      * JavaScript {@code alert} handler property. This handler is invoked
 692      * when a script running on the Web page calls the {@code alert} function.
 693      * @return the onAlert property
 694      */
 695     public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onAlertProperty() { return onAlert; }
 696 
 697 
 698     private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onStatusChanged
 699             = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt;(this, &quot;onStatusChanged&quot;);
 700 
 701     public final EventHandler&lt;WebEvent&lt;String&gt;&gt; getOnStatusChanged() { return onStatusChanged.get(); }
 702 
 703     public final void setOnStatusChanged(EventHandler&lt;WebEvent&lt;String&gt;&gt; handler) { onStatusChanged.set(handler); }
 704 
 705     /**
 706      * JavaScript status handler property. This handler is invoked when
 707      * a script running on the Web page sets {@code window.status} property.
 708      * @return the onStatusChanged property
 709      */
 710     public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;String&gt;&gt;&gt; onStatusChangedProperty() { return onStatusChanged; }
 711 
 712 
 713     private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;&gt; onResized
 714             = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;&gt;(this, &quot;onResized&quot;);
 715 
 716     public final EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt; getOnResized() { return onResized.get(); }
 717 
 718     public final void setOnResized(EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt; handler) { onResized.set(handler); }
 719 
 720     /**
 721      * JavaScript window resize handler property. This handler is invoked
 722      * when a script running on the Web page moves or resizes the
 723      * {@code window} object.
 724      * @return the onResized property
 725      */
 726     public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Rectangle2D&gt;&gt;&gt; onResizedProperty() { return onResized; }
 727 
 728 
 729     private final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Boolean&gt;&gt;&gt; onVisibilityChanged
 730             = new SimpleObjectProperty&lt;EventHandler&lt;WebEvent&lt;Boolean&gt;&gt;&gt;(this, &quot;onVisibilityChanged&quot;);
 731 
 732     public final EventHandler&lt;WebEvent&lt;Boolean&gt;&gt; getOnVisibilityChanged() { return onVisibilityChanged.get(); }
 733 
 734     public final void setOnVisibilityChanged(EventHandler&lt;WebEvent&lt;Boolean&gt;&gt; handler) { onVisibilityChanged.set(handler); }
 735 
 736     /**
 737      * JavaScript window visibility handler property. This handler is invoked
 738      * when a script running on the Web page changes visibility of the
 739      * {@code window} object.
 740      * @return the onVisibilityChanged property
 741      */
 742     public final ObjectProperty&lt;EventHandler&lt;WebEvent&lt;Boolean&gt;&gt;&gt; onVisibilityChangedProperty() { return onVisibilityChanged; }
 743 
 744 
 745     private final ObjectProperty&lt;Callback&lt;PopupFeatures, WebEngine&gt;&gt; createPopupHandler
 746             = new SimpleObjectProperty&lt;Callback&lt;PopupFeatures, WebEngine&gt;&gt;(this, &quot;createPopupHandler&quot;,
 747             p -&gt; WebEngine.this);
 748 
 749     public final Callback&lt;PopupFeatures, WebEngine&gt; getCreatePopupHandler() { return createPopupHandler.get(); }
 750 
 751     public final void setCreatePopupHandler(Callback&lt;PopupFeatures, WebEngine&gt; handler) { createPopupHandler.set(handler); }
 752 
 753     /**
 754      * JavaScript popup handler property. This handler is invoked when a script
 755      * running on the Web page requests a popup to be created.
 756      * &lt;p&gt;To satisfy this request a handler may create a new {@code WebEngine},
 757      * attach a visibility handler and optionally a resize handler, and return
 758      * the newly created engine. To block the popup, a handler should return
 759      * {@code null}.
 760      * &lt;p&gt;By default, a popup handler is installed that opens popups in this
 761      * {@code WebEngine}.
 762      *
 763      * @return the createPopupHandler property
 764      *
 765      * @see PopupFeatures
 766      */
 767     public final ObjectProperty&lt;Callback&lt;PopupFeatures, WebEngine&gt;&gt; createPopupHandlerProperty() { return createPopupHandler; }
 768 
 769 
 770     private final ObjectProperty&lt;Callback&lt;String, Boolean&gt;&gt; confirmHandler
 771             = new SimpleObjectProperty&lt;Callback&lt;String, Boolean&gt;&gt;(this, &quot;confirmHandler&quot;);
 772 
 773     public final Callback&lt;String, Boolean&gt; getConfirmHandler() { return confirmHandler.get(); }
 774 
 775     public final void setConfirmHandler(Callback&lt;String, Boolean&gt; handler) { confirmHandler.set(handler); }
 776 
 777     /**
 778      * JavaScript {@code confirm} handler property. This handler is invoked
 779      * when a script running on the Web page calls the {@code confirm} function.
 780      * &lt;p&gt;An implementation may display a dialog box with Yes and No options,
 781      * and return the user&#39;s choice.
 782      *
 783      * @return the confirmHandler property
 784      */
 785     public final ObjectProperty&lt;Callback&lt;String, Boolean&gt;&gt; confirmHandlerProperty() { return confirmHandler; }
 786 
 787 
 788     private final ObjectProperty&lt;Callback&lt;PromptData, String&gt;&gt; promptHandler
 789             = new SimpleObjectProperty&lt;Callback&lt;PromptData, String&gt;&gt;(this, &quot;promptHandler&quot;);
 790 
 791     public final Callback&lt;PromptData, String&gt; getPromptHandler() { return promptHandler.get(); }
 792 
 793     public final void setPromptHandler(Callback&lt;PromptData, String&gt; handler) { promptHandler.set(handler); }
 794 
 795     /**
 796      * JavaScript {@code prompt} handler property. This handler is invoked
 797      * when a script running on the Web page calls the {@code prompt} function.
 798      * &lt;p&gt;An implementation may display a dialog box with an text field,
 799      * and return the user&#39;s input.
 800      *
 801      * @return the promptHandler property
 802      * @see PromptData
 803      */
 804     public final ObjectProperty&lt;Callback&lt;PromptData, String&gt;&gt; promptHandlerProperty() { return promptHandler; }
 805 
 806     /**
 807      * The event handler called when an error occurs.
 808      *
 809      * @defaultValue {@code null}
 810      * @since JavaFX 8.0
 811      */
 812     private final ObjectProperty&lt;EventHandler&lt;WebErrorEvent&gt;&gt; onError =
 813             new SimpleObjectProperty&lt;&gt;(this, &quot;onError&quot;);
 814 
 815     public final EventHandler&lt;WebErrorEvent&gt; getOnError() {
 816         return onError.get();
 817     }
 818 
 819     public final void setOnError(EventHandler&lt;WebErrorEvent&gt; handler) {
 820         onError.set(handler);
 821     }
 822 
 823     public final ObjectProperty&lt;EventHandler&lt;WebErrorEvent&gt;&gt; onErrorProperty() {
 824         return onError;
 825     }
 826 
 827 
 828     /**
 829      * Creates a new engine.
 830      */
 831     public WebEngine() {
 832         this(null, false);
 833     }
 834 
 835     /**
 836      * Creates a new engine and loads a Web page into it.
 837      *
 838      * @param url the URL of the web page to load
 839      */
 840     public WebEngine(String url) {
 841         this(url, true);
 842     }
 843 
 844     private WebEngine(String url, boolean callLoad) {
 845         checkThread();
 846         Accessor accessor = new AccessorImpl(this);
 847         page = new WebPage(
 848             new WebPageClientImpl(accessor),
 849             new UIClientImpl(accessor),
 850             null,
 851             new InspectorClientImpl(this),
 852             new ThemeClientImpl(accessor),
 853             false);
 854         page.addLoadListenerClient(new PageLoadListener(this));
 855 
 856         history = new WebHistory(page);
 857 
 858         disposer = new SelfDisposer(page);
 859         Disposer.addRecord(this, disposer);
 860 
 861         if (callLoad) {
 862             load(url);
 863         }
 864 
 865         if (instanceCount == 0 &amp;&amp;
 866             Timer.getMode() == Timer.Mode.PLATFORM_TICKS)
 867         {
 868             PulseTimer.start();
 869         }
 870         instanceCount++;
 871     }
 872 
 873     /**
 874      * Loads a Web page into this engine. This method starts asynchronous
 875      * loading and returns immediately.
 876      * @param url URL of the web page to load
 877      */
 878     public void load(String url) {
 879         checkThread();
 880         loadWorker.cancelAndReset();
 881 
 882         if (url == null || url.equals(&quot;&quot;) || url.equals(&quot;about:blank&quot;)) {
 883             url = &quot;&quot;;
 884         } else {
 885             // verify and, if possible, adjust the url on the Java
 886             // side, otherwise it may crash native code
 887             try {
 888                 url = Util.adjustUrlForWebKit(url);
 889             } catch (MalformedURLException e) {
 890                 loadWorker.dispatchLoadEvent(getMainFrame(),
 891                         PAGE_STARTED, url, null, 0.0, 0);
 892                 loadWorker.dispatchLoadEvent(getMainFrame(),
 893                         LOAD_FAILED, url, null, 0.0, MALFORMED_URL);
 894                 return;
 895             }
 896         }
 897         applyUserDataDirectory();
 898         page.open(page.getMainFrame(), url);
 899     }
 900 
 901     /**
 902      * Loads the given HTML content directly. This method is useful when you have an HTML
 903      * String composed in memory, or loaded from some system which cannot be reached via
 904      * a URL (for example, the HTML text may have come from a database). As with
 905      * {@link #load(String)}, this method is asynchronous.
 906      *
 907      * @param content the HTML content to load
 908      */
 909     public void loadContent(String content) {
 910         loadContent(content, &quot;text/html&quot;);
 911     }
 912 
 913     /**
 914      * Loads the given content directly. This method is useful when you have content
 915      * composed in memory, or loaded from some system which cannot be reached via
 916      * a URL (for example, the SVG text may have come from a database). As with
 917      * {@link #load(String)}, this method is asynchronous. This method also allows you to
 918      * specify the content type of the string being loaded, and so may optionally support
 919      * other types besides just HTML.
 920      *
 921      * @param content the HTML content to load
 922      * @param contentType the type of content to load
 923      */
 924     public void loadContent(String content, String contentType) {
 925         checkThread();
 926         loadWorker.cancelAndReset();
 927         applyUserDataDirectory();
 928         page.load(page.getMainFrame(), content, contentType);
 929     }
 930 
 931     /**
 932      * Reloads the current page, whether loaded from URL or directly from a String in
 933      * one of the {@code loadContent} methods.
 934      */
 935     public void reload() {
 936         // TODO what happens if this is called while currently loading a page?
 937         checkThread();
 938         page.refresh(page.getMainFrame());
 939     }
 940 
 941     private final WebHistory history;
 942 
 943     /**
 944      * Returns the session history object.
 945      *
 946      * @return history object
 947      * @since JavaFX 2.2
 948      */
 949     public WebHistory getHistory() {
 950         return history;
 951     }
 952 
 953     /**
 954      * Executes a script in the context of the current page.
 955      *
 956      * @param script the script
 957      * @return execution result, converted to a Java object using the following
 958      * rules:
 959      * &lt;ul&gt;
 960      * &lt;li&gt;JavaScript Int32 is converted to {@code java.lang.Integer}
 961      * &lt;li&gt;Other JavaScript numbers to {@code java.lang.Double}
 962      * &lt;li&gt;JavaScript string to {@code java.lang.String}
 963      * &lt;li&gt;JavaScript boolean to {@code java.lang.Boolean}
 964      * &lt;li&gt;JavaScript {@code null} to {@code null}
 965      * &lt;li&gt;Most JavaScript objects get wrapped as
 966      *     {@code netscape.javascript.JSObject}
 967      * &lt;li&gt;JavaScript JSNode objects get mapped to instances of
 968      *     {@code netscape.javascript.JSObject}, that also implement
 969      *     {@code org.w3c.dom.Node}
 970      * &lt;li&gt;A special case is the JavaScript class {@code JavaRuntimeObject}
 971      *     which is used to wrap a Java object as a JavaScript value - in this
 972      *     case we just extract the original Java value.
 973      * &lt;/ul&gt;
 974      */
 975     public Object executeScript(String script) {
 976         checkThread();
 977         applyUserDataDirectory();
 978         return page.executeScript(page.getMainFrame(), script);
 979     }
 980 
 981     private long getMainFrame() {
 982         return page.getMainFrame();
 983     }
 984 
 985     WebPage getPage() {
 986         return page;
 987     }
 988 
 989     void setView(WebView view) {
 990         this.view.setValue(view);
 991     }
 992 
 993     private void stop() {
 994         checkThread();
 995         page.stop(page.getMainFrame());
 996     }
 997 
 998     private void applyUserDataDirectory() {
 999         if (userDataDirectoryApplied) {
1000             return;
1001         }
1002         userDataDirectoryApplied = true;
1003         File nominalUserDataDir = getUserDataDirectory();
1004         while (true) {
1005             File userDataDir;
1006             String displayString;
1007             if (nominalUserDataDir == null) {
1008                 userDataDir = defaultUserDataDirectory();
1009                 displayString = format(&quot;null (%s)&quot;, userDataDir);
1010             } else {
1011                 userDataDir = nominalUserDataDir;
1012                 displayString = userDataDir.toString();
1013             }
1014             logger.fine(&quot;Trying to apply user data directory [{0}]&quot;, displayString);
1015             String errorMessage;
1016             EventType&lt;WebErrorEvent&gt; errorType;
1017             Throwable error;
1018             try {
1019                 userDataDir = DirectoryLock.canonicalize(userDataDir);
1020                 File localStorageDir = new File(userDataDir, &quot;localstorage&quot;);
1021                 File[] dirs = new File[] {
1022                     userDataDir,
1023                     localStorageDir,
1024                 };
1025                 for (File dir : dirs) {
1026                     createDirectories(dir);
1027                     // Additional security check to make sure the caller
1028                     // has permission to write to the target directory
1029                     File test = new File(dir, &quot;.test&quot;);
1030                     if (test.createNewFile()) {
1031                         test.delete();
1032                     }
1033                 }
1034                 disposer.userDataDirectoryLock = new DirectoryLock(userDataDir);
1035 
1036                 page.setLocalStorageDatabasePath(localStorageDir.getPath());
1037                 page.setLocalStorageEnabled(true);
1038 
1039                 logger.fine(&quot;User data directory [{0}] has &quot;
1040                         + &quot;been applied successfully&quot;, displayString);
1041                 return;
1042 
1043             } catch (DirectoryLock.DirectoryAlreadyInUseException ex) {
1044                 errorMessage = &quot;User data directory [%s] is already in use&quot;;
1045                 errorType = WebErrorEvent.USER_DATA_DIRECTORY_ALREADY_IN_USE;
1046                 error = ex;
1047             } catch (IOException ex) {
1048                 errorMessage = &quot;An I/O error occurred while setting up &quot;
1049                         + &quot;user data directory [%s]&quot;;
1050                 errorType = WebErrorEvent.USER_DATA_DIRECTORY_IO_ERROR;
1051                 error = ex;
1052             } catch (SecurityException ex) {
1053                 errorMessage = &quot;A security error occurred while setting up &quot;
1054                         + &quot;user data directory [%s]&quot;;
1055                 errorType = WebErrorEvent.USER_DATA_DIRECTORY_SECURITY_ERROR;
1056                 error = ex;
1057             }
1058 
1059             errorMessage = format(errorMessage, displayString);
1060             logger.fine(&quot;{0}, calling error handler&quot;, errorMessage);
1061             File oldNominalUserDataDir = nominalUserDataDir;
1062             fireError(errorType, errorMessage, error);
1063             nominalUserDataDir = getUserDataDirectory();
1064             if (Objects.equals(nominalUserDataDir, oldNominalUserDataDir)) {
1065                 logger.fine(&quot;Error handler did not modify user data directory, &quot;
1066                         + &quot;continuing without user data directory&quot;);
1067                 return;
1068             } else {
1069                 logger.fine(&quot;Error handler has set user data directory to [{0}], &quot;
1070                         + &quot;retrying&quot;, nominalUserDataDir);
1071                 continue;
1072             }
1073         }
1074     }
1075 
1076     private static File defaultUserDataDirectory() {
1077         return new File(
1078                 com.sun.glass.ui.Application.GetApplication()
1079                         .getDataDirectory(),
1080                 &quot;webview&quot;);
1081     }
1082 
1083     private static void createDirectories(File directory) throws IOException {
1084         Path path = directory.toPath();
1085         try {
1086             Files.createDirectories(path, PosixFilePermissions.asFileAttribute(
1087                     PosixFilePermissions.fromString(&quot;rwx------&quot;)));
1088         } catch (UnsupportedOperationException ex) {
1089             Files.createDirectories(path);
1090         }
1091     }
1092 
1093     private void fireError(EventType&lt;WebErrorEvent&gt; eventType, String message,
1094                            Throwable exception)
1095     {
1096         EventHandler&lt;WebErrorEvent&gt; handler = getOnError();
1097         if (handler != null) {
1098             handler.handle(new WebErrorEvent(this, eventType,
1099                                              message, exception));
1100         }
1101     }
1102 
1103     // for testing purposes only
1104     void dispose() {
1105         disposer.dispose();
1106     }
1107 
1108     private static final class SelfDisposer implements DisposerRecord {
1109         private WebPage page;
1110         private DirectoryLock userDataDirectoryLock;
1111 
1112         private SelfDisposer(WebPage page) {
1113             this.page = page;
1114         }
1115 
1116         @Override public void dispose() {
1117             if (page == null) {
1118                 return;
1119             }
1120             page.dispose();
1121             page = null;
1122             if (userDataDirectoryLock != null) {
1123                 userDataDirectoryLock.close();
1124             }
1125             instanceCount--;
1126             if (instanceCount == 0 &amp;&amp;
1127                 Timer.getMode() == Timer.Mode.PLATFORM_TICKS)
1128             {
1129                 PulseTimer.stop();
1130             }
1131         }
1132     }
1133 
1134     private static final class AccessorImpl extends Accessor {
1135         private final WeakReference&lt;WebEngine&gt; engine;
1136 
1137         private AccessorImpl(WebEngine w) {
1138             this.engine = new WeakReference&lt;WebEngine&gt;(w);
1139         }
1140 
1141         @Override public WebEngine getEngine() {
1142             return engine.get();
1143         }
1144 
1145         @Override public WebPage getPage() {
1146             WebEngine w = getEngine();
1147             return w == null ? null : w.page;
1148         }
1149 
1150         @Override public WebView getView() {
1151             WebEngine w = getEngine();
1152             return w == null ? null : w.view.get();
1153         }
1154 
1155         @Override public void addChild(Node child) {
1156             WebView view = getView();
1157             if (view != null) {
1158                 view.getChildren().add(child);
1159             }
1160         }
1161 
1162         @Override public void removeChild(Node child) {
1163             WebView view = getView();
1164             if (view != null) {
1165                 view.getChildren().remove(child);
1166             }
1167         }
1168 
1169         @Override public void addViewListener(InvalidationListener l) {
1170             WebEngine w = getEngine();
1171             if (w != null) {
1172                 w.view.addListener(l);
1173             }
1174         }
1175     }
1176 
1177     /**
1178      * Drives the {@code Timer} when {@code Timer.Mode.PLATFORM_TICKS} is set.
1179      */
1180     private static final class PulseTimer {
1181 
1182         // Used just to guarantee constant pulse activity. See RT-14433.
1183         private static final AnimationTimer animation =
1184             new AnimationTimer() {
1185                 @Override public void handle(long l) {}
1186             };
1187 
1188         private static final TKPulseListener listener =
1189                 () -&gt; {
1190                     // Note, the timer event is executed right in the notifyTick(),
1191                     // that is during the pulse event. This makes the timer more
1192                     // repsonsive, though prolongs the pulse. So far it causes no
1193                     // problems but nevertheless it should be kept in mind.
1194 
1195                     // Execute notifyTick in runLater to run outside of pulse so
1196                     // that events will run in order and be able to display dialogs
1197                     // or call other methods that require a nested event loop.
1198                     Platform.runLater(() -&gt; Timer.getTimer().notifyTick());
1199                 };
1200 
1201         private static void start(){
1202             Toolkit.getToolkit().addSceneTkPulseListener(listener);
1203             animation.start();
1204         }
1205 
1206         private static void stop() {
1207             Toolkit.getToolkit().removeSceneTkPulseListener(listener);
1208             animation.stop();
1209         }
1210     }
1211 
1212     static void checkThread() {
1213         Toolkit.getToolkit().checkFxUserThread();
1214     }
1215 
1216 
1217     /**
1218      * The page load event listener. This object references the owner
1219      * WebEngine weakly so as to avoid referencing WebEngine from WebPage
1220      * strongly.
1221      */
1222     private static final class PageLoadListener implements LoadListenerClient {
1223 
1224         private final WeakReference&lt;WebEngine&gt; engine;
1225 
1226 
1227         private PageLoadListener(WebEngine engine) {
1228             this.engine = new WeakReference&lt;WebEngine&gt;(engine);
1229         }
1230 
1231 
1232         @Override public void dispatchLoadEvent(long frame, int state,
1233                 String url, String contentType, double progress, int errorCode)
1234         {
1235             WebEngine w = engine.get();
1236             if (w != null) {
1237                 w.loadWorker.dispatchLoadEvent(frame, state, url,
1238                         contentType, progress, errorCode);
1239             }
1240         }
1241 
1242         @Override public void dispatchResourceLoadEvent(long frame,
1243                 int state, String url, String contentType, double progress,
1244                 int errorCode)
1245         {
1246         }
1247     }
1248 
1249 
1250     private final class LoadWorker implements Worker&lt;Void&gt; {
1251 
1252         private final ReadOnlyObjectWrapper&lt;State&gt; state = new ReadOnlyObjectWrapper&lt;State&gt;(this, &quot;state&quot;, State.READY);
1253         @Override public final State getState() { checkThread(); return state.get(); }
1254         @Override public final ReadOnlyObjectProperty&lt;State&gt; stateProperty() { checkThread(); return state.getReadOnlyProperty(); }
1255         private void updateState(State value) {
1256             checkThread();
1257             this.state.set(value);
1258             running.set(value == State.SCHEDULED || value == State.RUNNING);
1259         }
1260 
1261         /**
1262          * @InheritDoc
1263          */
1264         private final ReadOnlyObjectWrapper&lt;Void&gt; value = new ReadOnlyObjectWrapper&lt;Void&gt;(this, &quot;value&quot;, null);
1265         @Override public final Void getValue() { checkThread(); return value.get(); }
1266         @Override public final ReadOnlyObjectProperty&lt;Void&gt; valueProperty() { checkThread(); return value.getReadOnlyProperty(); }
1267 
1268         /**
1269          * @InheritDoc
1270          */
1271         private final ReadOnlyObjectWrapper&lt;Throwable&gt; exception = new ReadOnlyObjectWrapper&lt;Throwable&gt;(this, &quot;exception&quot;);
1272         @Override public final Throwable getException() { checkThread(); return exception.get(); }
1273         @Override public final ReadOnlyObjectProperty&lt;Throwable&gt; exceptionProperty() { checkThread(); return exception.getReadOnlyProperty(); }
1274 
1275         /**
1276          * @InheritDoc
1277          */
1278         private final ReadOnlyDoubleWrapper workDone = new ReadOnlyDoubleWrapper(this, &quot;workDone&quot;, -1);
1279         @Override public final double getWorkDone() { checkThread(); return workDone.get(); }
1280         @Override public final ReadOnlyDoubleProperty workDoneProperty() { checkThread(); return workDone.getReadOnlyProperty(); }
1281 
1282         /**
1283          * @InheritDoc
1284          */
1285         private final ReadOnlyDoubleWrapper totalWorkToBeDone = new ReadOnlyDoubleWrapper(this, &quot;totalWork&quot;, -1);
1286         @Override public final double getTotalWork() { checkThread(); return totalWorkToBeDone.get(); }
1287         @Override public final ReadOnlyDoubleProperty totalWorkProperty() { checkThread(); return totalWorkToBeDone.getReadOnlyProperty(); }
1288 
1289         /**
1290          * @InheritDoc
1291          */
1292         private final ReadOnlyDoubleWrapper progress = new ReadOnlyDoubleWrapper(this, &quot;progress&quot;, -1);
1293         @Override public final double getProgress() { checkThread(); return progress.get(); }
1294         @Override public final ReadOnlyDoubleProperty progressProperty() { checkThread(); return progress.getReadOnlyProperty(); }
1295         private void updateProgress(double p) {
1296             totalWorkToBeDone.set(100.0);
1297             workDone.set(p * 100.0);
1298             progress.set(p);
1299         }
1300 
1301         /**
1302          * @InheritDoc
1303          */
1304         private final ReadOnlyBooleanWrapper running = new ReadOnlyBooleanWrapper(this, &quot;running&quot;, false);
1305         @Override public final boolean isRunning() { checkThread(); return running.get(); }
1306         @Override public final ReadOnlyBooleanProperty runningProperty() { checkThread(); return running.getReadOnlyProperty(); }
1307 
1308         /**
1309          * @InheritDoc
1310          */
1311         private final ReadOnlyStringWrapper message = new ReadOnlyStringWrapper(this, &quot;message&quot;, &quot;&quot;);
1312         @Override public final String getMessage() { return message.get(); }
1313         @Override public final ReadOnlyStringProperty messageProperty() { return message.getReadOnlyProperty(); }
1314 
1315         /**
1316          * @InheritDoc
1317          */
1318         private final ReadOnlyStringWrapper title = new ReadOnlyStringWrapper(this, &quot;title&quot;, &quot;WebEngine Loader&quot;);
1319         @Override public final String getTitle() { return title.get(); }
1320         @Override public final ReadOnlyStringProperty titleProperty() { return title.getReadOnlyProperty(); }
1321 
1322         /**
1323          * Cancels the loading of the page. If called after the page has already
1324          * been loaded, then this call takes no effect.
1325          */
1326         @Override public boolean cancel() {
1327             if (isRunning()) {
1328                 stop(); // this call indirectly sets state
1329                 return true;
1330             } else {
1331                 return false;
1332             }
1333         }
1334 
1335         private void cancelAndReset() {
1336             cancel();
1337             exception.set(null);
1338             message.set(&quot;&quot;);
1339             totalWorkToBeDone.set(-1);
1340             workDone.set(-1);
1341             progress.set(-1);
1342             updateState(State.READY);
1343             running.set(false);
1344         }
1345 
1346         private void dispatchLoadEvent(long frame, int state,
1347                 String url, String contentType, double workDone, int errorCode)
1348         {
1349             if (frame != getMainFrame()) {
1350                 return;
1351             }
1352             switch (state) {
1353                 case PAGE_STARTED:
1354                     message.set(&quot;Loading &quot; + url);
1355                     updateLocation(url);
1356                     updateProgress(0.0);
1357                     updateState(State.SCHEDULED);
1358                     updateState(State.RUNNING);
1359                     break;
1360                 case PAGE_REDIRECTED:
1361                     message.set(&quot;Loading &quot; + url);
1362                     updateLocation(url);
1363                     break;
1364                 case PAGE_REPLACED:
1365                     message.set(&quot;Replaced &quot; + url);
1366                     // Update only the location, don&#39;t change title or document.
1367                     WebEngine.this.location.set(url);
1368                     break;
1369                 case PAGE_FINISHED:
1370                     message.set(&quot;Loading complete&quot;);
1371                     updateProgress(1.0);
1372                     updateState(State.SUCCEEDED);
1373                     break;
1374                 case LOAD_FAILED:
1375                     message.set(&quot;Loading failed&quot;);
1376                     exception.set(describeError(errorCode));
1377                     updateState(State.FAILED);
1378                     break;
1379                 case LOAD_STOPPED:
1380                     message.set(&quot;Loading stopped&quot;);
1381                     updateState(State.CANCELLED);
1382                     break;
1383                 case PROGRESS_CHANGED:
1384                     updateProgress(workDone);
1385                     break;
1386                 case TITLE_RECEIVED:
1387                     updateTitle();
1388                     break;
1389                 case DOCUMENT_AVAILABLE:
1390                     if (this.state.get() != State.RUNNING) {
1391                         // We have empty load; send a synthetic event (RT-32097)
1392                         dispatchLoadEvent(frame, PAGE_STARTED, url, contentType, workDone, errorCode);
1393                     }
1394                     document.invalidate(true);
1395                     break;
1396             }
1397         }
1398 
1399         private Throwable describeError(int errorCode) {
1400             String reason = &quot;Unknown error&quot;;
1401 
1402             switch (errorCode) {
1403                 case UNKNOWN_HOST:
1404                     reason = &quot;Unknown host&quot;;
1405                     break;
1406                 case MALFORMED_URL:
1407                     reason = &quot;Malformed URL&quot;;
1408                     break;
1409                 case SSL_HANDSHAKE:
1410                     reason = &quot;SSL handshake failed&quot;;
1411                     break;
1412                 case CONNECTION_REFUSED:
1413                     reason = &quot;Connection refused by server&quot;;
1414                     break;
1415                 case CONNECTION_RESET:
1416                     reason = &quot;Connection reset by server&quot;;
1417                     break;
1418                 case NO_ROUTE_TO_HOST:
1419                     reason = &quot;No route to host&quot;;
1420                     break;
1421                 case CONNECTION_TIMED_OUT:
1422                     reason = &quot;Connection timed out&quot;;
1423                     break;
1424                 case PERMISSION_DENIED:
1425                     reason = &quot;Permission denied&quot;;
1426                     break;
1427                 case INVALID_RESPONSE:
1428                     reason = &quot;Invalid response from server&quot;;
1429                     break;
1430                 case TOO_MANY_REDIRECTS:
1431                     reason = &quot;Too many redirects&quot;;
1432                     break;
1433                 case FILE_NOT_FOUND:
1434                     reason = &quot;File not found&quot;;
1435                     break;
1436             }
1437             return new Throwable(reason);
1438         }
1439     }
1440 
1441 
1442     private final class DocumentProperty
1443             extends ReadOnlyObjectPropertyBase&lt;Document&gt; {
1444 
1445         private boolean available;
1446         private Document document;
1447 
1448         private void invalidate(boolean available) {
1449             if (this.available || available) {
1450                 this.available = available;
1451                 this.document = null;
1452                 fireValueChangedEvent();
1453             }
1454         }
1455 
1456         public Document get() {
1457             if (!this.available) {
1458                 return null;
1459             }
1460             if (this.document == null) {
1461                 this.document = page.getDocument(page.getMainFrame());
1462                 if (this.document == null) {
1463                     this.available = false;
1464                 }
1465             }
1466             return this.document;
1467         }
1468 
1469         public Object getBean() {
1470             return WebEngine.this;
1471         }
1472 
1473         public String getName() {
1474             return &quot;document&quot;;
1475         }
1476     }
1477 
1478 
1479     /*
1480      * Returns the debugger associated with this web engine.
1481      * The debugger is an object that can be used to debug
1482      * the web page currently loaded into the web engine.
1483      * &lt;p&gt;
1484      * All methods of the debugger must be called on
1485      * the JavaFX Application Thread.
1486      * The message callback object registered with the debugger
1487      * is always called on the JavaFX Application Thread.
1488      * @return the debugger associated with this web engine.
1489      *         The return value cannot be {@code null}.
1490      */
1491     Debugger getDebugger() {
1492         return debugger;
1493     }
1494 
1495     /**
1496      * The debugger implementation.
1497      */
1498     private final class DebuggerImpl implements Debugger {
1499 
1500         private boolean enabled;
1501         private Callback&lt;String,Void&gt; messageCallback;
1502 
1503 
1504         @Override
1505         public boolean isEnabled() {
1506             checkThread();
1507             return enabled;
1508         }
1509 
1510         @Override
1511         public void setEnabled(boolean enabled) {
1512             checkThread();
1513             if (enabled != this.enabled) {
1514                 if (enabled) {
1515                     page.setDeveloperExtrasEnabled(true);
1516                     page.connectInspectorFrontend();
1517                 } else {
1518                     page.disconnectInspectorFrontend();
1519                     page.setDeveloperExtrasEnabled(false);
1520                 }
1521                 this.enabled = enabled;
1522             }
1523         }
1524 
1525         @Override
1526         public void sendMessage(String message) {
1527             checkThread();
1528             if (!enabled) {
1529                 throw new IllegalStateException(&quot;Debugger is not enabled&quot;);
1530             }
1531             if (message == null) {
1532                 throw new NullPointerException(&quot;message is null&quot;);
1533             }
1534             page.dispatchInspectorMessageFromFrontend(message);
1535         }
1536 
1537         @Override
1538         public Callback&lt;String,Void&gt; getMessageCallback() {
1539             checkThread();
1540             return messageCallback;
1541         }
1542 
1543         @Override
1544         public void setMessageCallback(Callback&lt;String,Void&gt; callback) {
1545             checkThread();
1546             messageCallback = callback;
1547         }
1548     }
1549 
1550     /**
1551      * The inspector client implementation. This object references the owner
1552      * WebEngine weakly so as to avoid referencing WebEngine from WebPage
1553      * strongly.
1554      */
1555     private static final class InspectorClientImpl implements InspectorClient {
1556 
1557         private final WeakReference&lt;WebEngine&gt; engine;
1558 
1559 
1560         private InspectorClientImpl(WebEngine engine) {
1561             this.engine = new WeakReference&lt;WebEngine&gt;(engine);
1562         }
1563 
1564 
1565         @Override
1566         public boolean sendMessageToFrontend(final String message) {
1567             boolean result = false;
1568             WebEngine webEngine = engine.get();
1569             if (webEngine != null) {
1570                 final Callback&lt;String,Void&gt; messageCallback =
1571                         webEngine.debugger.messageCallback;
1572                 if (messageCallback != null) {
1573                     AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
1574                         messageCallback.call(message);
1575                         return null;
1576                     }, webEngine.page.getAccessControlContext());
1577                     result = true;
1578                 }
1579             }
1580             return result;
1581         }
1582     }
1583 
1584     private static final boolean printStatusOK(PrinterJob job) {
1585         switch (job.getJobStatus()) {
1586             case NOT_STARTED:
1587             case PRINTING:
1588                 return true;
1589             default:
1590                 return false;
1591         }
1592     }
1593 
1594     /**
1595      * Prints the current Web page using the given printer job.
1596      * &lt;p&gt;This method does not modify the state of the job, nor does it call
1597      * {@link PrinterJob#endJob}, so the job may be safely reused afterwards.
1598      *
1599      * @param job printer job used for printing
1600      * @since JavaFX 8.0
1601      */
1602     public void print(PrinterJob job) {
1603         if (!printStatusOK(job)) {
1604             return;
1605         }
1606 
1607         PageLayout pl = job.getJobSettings().getPageLayout();
1608         float width = (float) pl.getPrintableWidth();
1609         float height = (float) pl.getPrintableHeight();
1610         int pageCount = page.beginPrinting(width, height);
1611 
1612         for (int i = 0; i &lt; pageCount; i++) {
1613             if (printStatusOK(job)) {
1614                 Node printable = new Printable(page, i, width);
1615                 job.printPage(printable);
1616             }
1617         }
1618         page.endPrinting();
1619     }
1620 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
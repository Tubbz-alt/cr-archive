<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/skin/ToolBarSkin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javafx.scene.control.skin;
 27 
 28 import com.sun.javafx.scene.NodeHelper;
 29 import com.sun.javafx.scene.ParentHelper;
 30 import java.util.ArrayList;
 31 import java.util.Collections;
 32 import java.util.List;
 33 
 34 import com.sun.javafx.scene.control.behavior.BehaviorBase;
 35 import com.sun.javafx.scene.traversal.Algorithm;
 36 import com.sun.javafx.scene.traversal.ParentTraversalEngine;
 37 import com.sun.javafx.scene.traversal.TraversalContext;
 38 
 39 import javafx.beans.property.ObjectProperty;
 40 import javafx.beans.property.DoubleProperty;
 41 import javafx.beans.value.WritableValue;
 42 import javafx.collections.FXCollections;
 43 import javafx.collections.ListChangeListener;
 44 import javafx.collections.ObservableList;
 45 import javafx.geometry.HPos;
 46 import javafx.geometry.Orientation;
 47 import javafx.geometry.Pos;
 48 import javafx.geometry.Side;
 49 import javafx.geometry.VPos;
 50 import javafx.scene.AccessibleAction;
 51 import javafx.scene.AccessibleAttribute;
 52 import javafx.scene.AccessibleRole;
 53 import javafx.scene.Node;
 54 import javafx.scene.Parent;
 55 import javafx.scene.control.ContextMenu;
 56 import javafx.scene.control.Control;
 57 import javafx.scene.control.MenuItem;
 58 import javafx.scene.control.CustomMenuItem;
 59 import javafx.scene.control.Separator;
 60 import javafx.scene.control.SeparatorMenuItem;
 61 import javafx.scene.control.SkinBase;
 62 import javafx.scene.control.ToolBar;
 63 import javafx.scene.input.KeyCode;
 64 import javafx.scene.layout.HBox;
 65 import javafx.scene.layout.Pane;
 66 import javafx.scene.layout.StackPane;
 67 import javafx.scene.layout.VBox;
 68 import javafx.css.StyleableDoubleProperty;
 69 import javafx.css.StyleableObjectProperty;
 70 import javafx.css.StyleableProperty;
 71 import javafx.css.CssMetaData;
 72 
 73 import javafx.css.converter.EnumConverter;
 74 import javafx.css.converter.SizeConverter;
 75 import com.sun.javafx.scene.control.behavior.ToolBarBehavior;
 76 import com.sun.javafx.scene.traversal.Direction;
 77 
 78 import javafx.css.Styleable;
 79 
 80 import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;
 81 
 82 /**
 83  * Default skin implementation for the {@link ToolBar} control.
 84  *
 85  * @see ToolBar
 86  * @since 9
 87  */
 88 public class ToolBarSkin extends SkinBase&lt;ToolBar&gt; {
 89 
 90     /***************************************************************************
 91      *                                                                         *
 92      * Private fields                                                          *
 93      *                                                                         *
 94      **************************************************************************/
 95 
 96     private Pane box;
 97     private ToolBarOverflowMenu overflowMenu;
 98     private boolean overflow = false;
 99     private double previousWidth = 0;
100     private double previousHeight = 0;
101     private double savedPrefWidth = 0;
102     private double savedPrefHeight = 0;
103     private ObservableList&lt;MenuItem&gt; overflowMenuItems;
104     private boolean needsUpdate = false;
105     private final ParentTraversalEngine engine;
106     private final BehaviorBase&lt;ToolBar&gt; behavior;
107 
108 
109 
110     /***************************************************************************
111      *                                                                         *
112      * Constructors                                                            *
113      *                                                                         *
114      **************************************************************************/
115 
116     /**
117      * Creates a new ToolBarSkin instance, installing the necessary child
118      * nodes into the Control {@link Control#getChildren() children} list, as
119      * well as the necessary input mappings for handling key, mouse, etc events.
120      *
121      * @param control The control that this skin should be installed onto.
122      */
123     public ToolBarSkin(ToolBar control) {
124         super(control);
125 
126         // install default input map for the ToolBar control
127         behavior = new ToolBarBehavior(control);
128 //        control.setInputMap(behavior.getInputMap());
129 
130         overflowMenuItems = FXCollections.observableArrayList();
131         initialize();
132         registerChangeListener(control.orientationProperty(), e -&gt; initialize());
133 
134         engine = new ParentTraversalEngine(getSkinnable(), new Algorithm() {
135 
136             private Node selectPrev(int from, TraversalContext context) {
137                 for (int i = from; i &gt;= 0; --i) {
138                     Node n = box.getChildren().get(i);
139                     if (n.isDisabled() || !NodeHelper.isTreeShowing(n)) continue;
140                     if (n instanceof Parent) {
141                         Node selected = context.selectLastInParent((Parent)n);
142                         if (selected != null) return selected;
143                     }
144                     if (n.isFocusTraversable() ) {
145                         return n;
146                     }
147                 }
148                 return null;
149             }
150 
151             private Node selectNext(int from, TraversalContext context) {
152                 for (int i = from, max = box.getChildren().size(); i &lt; max; ++i) {
153                     Node n = box.getChildren().get(i);
154                     if (n.isDisabled() || !NodeHelper.isTreeShowing(n)) continue;
155                     if (n.isFocusTraversable()) {
156                         return n;
157                     }
158                     if (n instanceof Parent) {
159                         Node selected = context.selectFirstInParent((Parent)n);
160                         if (selected != null) return selected;
161                     }
162                 }
163                 return null;
164             }
165 
166             @Override
167             public Node select(Node owner, Direction dir, TraversalContext context) {
<a name="1" id="anc1"></a>


168                 final ObservableList&lt;Node&gt; boxChildren = box.getChildren();
169                 if (owner == overflowMenu) {
170                     if (dir.isForward()) {
171                         return null;
172                     } else {
173                         Node selected = selectPrev(boxChildren.size() - 1, context);
174                         if (selected != null) return selected;
175                     }
176                 }
177 
178                 int idx = boxChildren.indexOf(owner);
179 
180                 if (idx &lt; 0) {
181                     // The current focus owner is a child of some Toolbar&#39;s item
182                     Parent item = owner.getParent();
183                     while (!boxChildren.contains(item)) {
184                         item = item.getParent();
185                     }
186                     Node selected = context.selectInSubtree(item, owner, dir);
187                     if (selected != null) return selected;
188                     idx = boxChildren.indexOf(item);
189                     if (dir == Direction.NEXT) dir = Direction.NEXT_IN_LINE;
190                 }
191 
192                 if (idx &gt;= 0) {
193                     if (dir.isForward()) {
194                         Node selected = selectNext(idx + 1, context);
195                         if (selected != null) return selected;
196                         if (overflow) {
197                             overflowMenu.requestFocus();
198                             return overflowMenu;
199                         }
200                     } else {
201                         Node selected = selectPrev(idx - 1, context);
202                         if (selected != null) return selected;
203                     }
204                 }
205                 return null;
206             }
207 
208             @Override
209             public Node selectFirst(TraversalContext context) {
210                 Node selected = selectNext(0, context);
211                 if (selected != null) return selected;
212                 if (overflow) {
213                     return overflowMenu;
214                 }
215                 return null;
216             }
217 
218             @Override
219             public Node selectLast(TraversalContext context) {
220                 if (overflow) {
221                     return overflowMenu;
222                 }
223                 return selectPrev(box.getChildren().size() - 1, context);
224             }
225         });
226         ParentHelper.setTraversalEngine(getSkinnable(), engine);
227 
228         control.focusedProperty().addListener((observable, oldValue, newValue) -&gt; {
229             if (newValue) {
230                 // TODO need to detect the focus direction
231                 // to selected the first control in the toolbar when TAB is pressed
232                 // or select the last control in the toolbar when SHIFT TAB is pressed.
233                 if (!box.getChildren().isEmpty()) {
234                     box.getChildren().get(0).requestFocus();
235                 } else {
236                     overflowMenu.requestFocus();
237                 }
238             }
239         });
240 
241         control.getItems().addListener((ListChangeListener&lt;Node&gt;) c -&gt; {
242             while (c.next()) {
243                 for (Node n: c.getRemoved()) {
244                     box.getChildren().remove(n);
245                 }
246                 box.getChildren().addAll(c.getAddedSubList());
247             }
248             needsUpdate = true;
249             getSkinnable().requestLayout();
250         });
251     }
252 
253 
254 
255     /***************************************************************************
256      *                                                                         *
257      * Properties                                                              *
258      *                                                                         *
259      **************************************************************************/
260 
261     private double snapSpacing(double value) {
262         if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
263             return snapSpaceY(value);
264         } else {
265             return snapSpaceX(value);
266         }
267     }
268 
269     // --- spacing
270     private DoubleProperty spacing;
271     private final void setSpacing(double value) {
272         spacingProperty().set(snapSpacing(value));
273     }
274 
275     private final double getSpacing() {
276         return spacing == null ? 0.0 : snapSpacing(spacing.get());
277     }
278 
279     private final DoubleProperty spacingProperty() {
280         if (spacing == null) {
281             spacing = new StyleableDoubleProperty() {
282 
283                 @Override
284                 protected void invalidated() {
285                     final double value = get();
286                     if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
287                         ((VBox)box).setSpacing(value);
288                     } else {
289                         ((HBox)box).setSpacing(value);
290                     }
291                 }
292 
293                 @Override
294                 public Object getBean() {
295                     return ToolBarSkin.this;
296                 }
297 
298                 @Override
299                 public String getName() {
300                     return &quot;spacing&quot;;
301                 }
302 
303                 @Override
304                 public CssMetaData&lt;ToolBar,Number&gt; getCssMetaData() {
305                     return StyleableProperties.SPACING;
306                 }
307             };
308         }
309         return spacing;
310     }
311 
312     // --- box alignment
313     private ObjectProperty&lt;Pos&gt; boxAlignment;
314     private final void setBoxAlignment(Pos value) {
315         boxAlignmentProperty().set(value);
316     }
317 
318     private final Pos getBoxAlignment() {
319         return boxAlignment == null ? Pos.TOP_LEFT : boxAlignment.get();
320     }
321 
322     private final ObjectProperty&lt;Pos&gt; boxAlignmentProperty() {
323         if (boxAlignment == null) {
324             boxAlignment = new StyleableObjectProperty&lt;Pos&gt;(Pos.TOP_LEFT) {
325 
326                 @Override
327                 public void invalidated() {
328                     final Pos value = get();
329                     if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
330                         ((VBox)box).setAlignment(value);
331                     } else {
332                         ((HBox)box).setAlignment(value);
333                     }
334                 }
335 
336                 @Override
337                 public Object getBean() {
338                     return ToolBarSkin.this;
339                 }
340 
341                 @Override
342                 public String getName() {
343                     return &quot;boxAlignment&quot;;
344                 }
345 
346                 @Override
347                 public CssMetaData&lt;ToolBar,Pos&gt; getCssMetaData() {
348                     return StyleableProperties.ALIGNMENT;
349                 }
350             };
351         }
352         return boxAlignment;
353     }
354 
355 
356 
357     /***************************************************************************
358      *                                                                         *
359      * Public API                                                              *
360      *                                                                         *
361      **************************************************************************/
362 
363     /** {@inheritDoc} */
364     @Override public void dispose() {
365         super.dispose();
366 
367         if (behavior != null) {
368             behavior.dispose();
369         }
370     }
371 
372     /** {@inheritDoc} */
373     @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
374         final ToolBar toolbar = getSkinnable();
375         return toolbar.getOrientation() == Orientation.VERTICAL ?
376             computePrefWidth(-1, topInset, rightInset, bottomInset, leftInset) :
377             snapSizeX(overflowMenu.prefWidth(-1)) + leftInset + rightInset;
378     }
379 
380     /** {@inheritDoc} */
381     @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
382         final ToolBar toolbar = getSkinnable();
383         return toolbar.getOrientation() == Orientation.VERTICAL?
384             snapSizeY(overflowMenu.prefHeight(-1)) + topInset + bottomInset :
385             computePrefHeight(-1, topInset, rightInset, bottomInset, leftInset);
386     }
387 
388     /** {@inheritDoc} */
389     @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
390         double prefWidth = 0;
391         final ToolBar toolbar = getSkinnable();
392 
393         if (toolbar.getOrientation() == Orientation.HORIZONTAL) {
394             for (Node node : toolbar.getItems()) {
395                 if (!node.isManaged()) continue;
396                 prefWidth += snapSizeX(node.prefWidth(-1)) + getSpacing();
397             }
398             prefWidth -= getSpacing();
399         } else {
400             for (Node node : toolbar.getItems()) {
401                 if (!node.isManaged()) continue;
402                 prefWidth = Math.max(prefWidth, snapSizeX(node.prefWidth(-1)));
403             }
404             if (toolbar.getItems().size() &gt; 0) {
405                 savedPrefWidth = prefWidth;
406             } else {
407                 prefWidth = savedPrefWidth;
408             }
409         }
410         return leftInset + prefWidth + rightInset;
411     }
412 
413     /** {@inheritDoc} */
414     @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
415         double prefHeight = 0;
416         final ToolBar toolbar = getSkinnable();
417 
418         if(toolbar.getOrientation() == Orientation.VERTICAL) {
419             for (Node node: toolbar.getItems()) {
420                 if (!node.isManaged()) continue;
421                 prefHeight += snapSizeY(node.prefHeight(-1)) + getSpacing();
422             }
423             prefHeight -= getSpacing();
424         } else {
425             for (Node node : toolbar.getItems()) {
426                 if (!node.isManaged()) continue;
427                 prefHeight = Math.max(prefHeight, snapSizeY(node.prefHeight(-1)));
428             }
429             if (toolbar.getItems().size() &gt; 0) {
430                 savedPrefHeight = prefHeight;
431             } else {
432                 prefHeight = savedPrefHeight;
433             }
434         }
435         return topInset + prefHeight + bottomInset;
436     }
437 
438     /** {@inheritDoc} */
439     @Override protected double computeMaxWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
440         return getSkinnable().getOrientation() == Orientation.VERTICAL ?
441                 snapSizeX(getSkinnable().prefWidth(-1)) : Double.MAX_VALUE;
442     }
443 
444     /** {@inheritDoc} */
445     @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
446         return getSkinnable().getOrientation() == Orientation.VERTICAL ?
447                 Double.MAX_VALUE : snapSizeY(getSkinnable().prefHeight(-1));
448     }
449 
450     /** {@inheritDoc} */
451     @Override protected void layoutChildren(final double x,final double y,
452             final double w, final double h) {
453 //        super.layoutChildren();
454         final ToolBar toolbar = getSkinnable();
455 
456         double toolbarLength = getToolbarLength(toolbar);
457         if (toolbar.getOrientation() == Orientation.VERTICAL) {
458             if (snapSizeY(toolbar.getHeight()) != previousHeight || needsUpdate) {
459                 ((VBox)box).setSpacing(getSpacing());
460                 ((VBox)box).setAlignment(getBoxAlignment());
461                 previousHeight = snapSizeY(toolbar.getHeight());
462                 addNodesToToolBar();
463             } else {
464                 correctOverflow(toolbarLength);
465             }
466         } else {
467             if (snapSizeX(toolbar.getWidth()) != previousWidth || needsUpdate) {
468                 ((HBox)box).setSpacing(getSpacing());
469                 ((HBox)box).setAlignment(getBoxAlignment());
470                 previousWidth = snapSizeX(toolbar.getWidth());
471                 addNodesToToolBar();
472             } else {
473                 correctOverflow(toolbarLength);
474             }
475         }
476 
477         needsUpdate = false;
478 
479         double toolbarWidth = w;
480         double toolbarHeight = h;
481 
482         if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
483             toolbarHeight -= (overflow ? snapSizeY(overflowMenu.prefHeight(-1)) : 0);
484         } else {
485             toolbarWidth -= (overflow ? snapSizeX(overflowMenu.prefWidth(-1)) : 0);
486         }
487 
488         box.resize(toolbarWidth, toolbarHeight);
489         positionInArea(box, x, y,
490                 toolbarWidth, toolbarHeight, /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
491 
492         // If popup menu is not null show the overflowControl
493         if (overflow) {
494             double overflowMenuWidth = snapSizeX(overflowMenu.prefWidth(-1));
495             double overflowMenuHeight = snapSizeY(overflowMenu.prefHeight(-1));
496             double overflowX = x;
497             double overflowY = x;
498             if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
499                 // This is to prevent the overflow menu from moving when there
500                 // are no items in the toolbar.
501                 if (toolbarWidth == 0) {
502                     toolbarWidth = savedPrefWidth;
503                 }
504                 HPos pos = ((VBox)box).getAlignment().getHpos();
505                 if (HPos.LEFT.equals(pos)) {
506                     overflowX = x + Math.abs((toolbarWidth - overflowMenuWidth)/2);
507                 } else if (HPos.RIGHT.equals(pos)) {
508                     overflowX = (snapSizeX(toolbar.getWidth()) - snappedRightInset() - toolbarWidth) +
509                         Math.abs((toolbarWidth - overflowMenuWidth)/2);
510                 } else {
511                     overflowX = x +
512                         Math.abs((snapSizeX(toolbar.getWidth()) - (x) +
513                         snappedRightInset() - overflowMenuWidth)/2);
514                 }
515                 overflowY = snapSizeY(toolbar.getHeight()) - overflowMenuHeight - y;
516             } else {
517                 // This is to prevent the overflow menu from moving when there
518                 // are no items in the toolbar.
519                 if (toolbarHeight == 0) {
520                     toolbarHeight = savedPrefHeight;
521                 }
522                 VPos pos = ((HBox)box).getAlignment().getVpos();
523                 if (VPos.TOP.equals(pos)) {
524                     overflowY = y +
525                         Math.abs((toolbarHeight - overflowMenuHeight)/2);
526                 } else if (VPos.BOTTOM.equals(pos)) {
527                     overflowY = (snapSizeY(toolbar.getHeight()) - snappedBottomInset() - toolbarHeight) +
528                         Math.abs((toolbarHeight - overflowMenuHeight)/2);
529                 } else {
530                     overflowY = y + Math.abs((toolbarHeight - overflowMenuHeight)/2);
531                 }
532                overflowX = snapSizeX(toolbar.getWidth()) - overflowMenuWidth - snappedRightInset();
533             }
534             overflowMenu.resize(overflowMenuWidth, overflowMenuHeight);
535             positionInArea(overflowMenu, overflowX, overflowY, overflowMenuWidth, overflowMenuHeight, /*baseline ignored*/0,
536                     HPos.CENTER, VPos.CENTER);
537         }
538     }
539 
540     /***************************************************************************
541      *                                                                         *
542      * Private implementation                                                  *
543      *                                                                         *
544      **************************************************************************/
545 
546     private void initialize() {
547         if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
548             box = new VBox();
549         } else {
550             box = new HBox();
551         }
552         box.getStyleClass().add(&quot;container&quot;);
553         box.getChildren().addAll(getSkinnable().getItems());
554         overflowMenu = new ToolBarOverflowMenu(overflowMenuItems);
555         overflowMenu.setVisible(false);
556         overflowMenu.setManaged(false);
557 
558         getChildren().clear();
559         getChildren().add(box);
560         getChildren().add(overflowMenu);
561 
562         previousWidth = 0;
563         previousHeight = 0;
564         savedPrefWidth = 0;
565         savedPrefHeight = 0;
566         needsUpdate = true;
567         getSkinnable().requestLayout();
568     }
569 
570     private void correctOverflow(double length) {
571         boolean overflowed = isOverflowed(length);
572         if (overflowed != overflow) {
573             organizeOverflow(length, overflow);
574         }
575     }
576 
577     private void organizeOverflow(double length, boolean hasOverflow) {
578         if (hasOverflow) {
579             if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
580                 length -= snapSizeY(overflowMenu.prefHeight(-1));
581             } else {
582                 length -= snapSizeX(overflowMenu.prefWidth(-1));
583             }
584             length -= getSpacing();
585         }
586 
587         // Determine which node goes to the toolbar and which goes to the overflow.
588 
589         double x = 0;
590         overflowMenuItems.clear();
591         box.getChildren().clear();
592         for (Node node : getSkinnable().getItems()) {
593             node.getStyleClass().remove(&quot;menu-item&quot;);
594             node.getStyleClass().remove(&quot;custom-menu-item&quot;);
595 
596             if (node.isManaged()) {
597                 if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
598                     x += snapSizeY(node.prefHeight(-1)) + getSpacing();
599                 } else {
600                     x += snapSizeX(node.prefWidth(-1)) + getSpacing();
601                 }
602             }
603 
604             if (x &lt;= length) {
605                 box.getChildren().add(node);
606             } else {
607                 if (node.isFocused()) {
608                     if (!box.getChildren().isEmpty()) {
609                         Node last = engine.selectLast();
610                         if (last != null) {
611                             last.requestFocus();
612                         }
613                     } else {
614                         overflowMenu.requestFocus();
615                     }
616                 }
617                 if (node instanceof Separator) {
618                     overflowMenuItems.add(new SeparatorMenuItem());
619                 } else {
620                     CustomMenuItem customMenuItem = new CustomMenuItem(node);
621 
622                     // RT-36455:
623                     // We can&#39;t be totally certain of all nodes, but for the
624                     // most common nodes we can check to see whether we should
625                     // hide the menu when the node is clicked on. The common
626                     // case is for TextField or Slider.
627                     // This list won&#39;t be exhaustive (there is no point really
628                     // considering the ListView case), but it should try to
629                     // include most common control types that find themselves
630                     // placed in menus.
631                     final String nodeType = node.getTypeSelector();
632                     switch (nodeType) {
633                         case &quot;Button&quot;:
634                         case &quot;Hyperlink&quot;:
635                         case &quot;Label&quot;:
636                             customMenuItem.setHideOnClick(true);
637                             break;
638                         case &quot;CheckBox&quot;:
639                         case &quot;ChoiceBox&quot;:
640                         case &quot;ColorPicker&quot;:
641                         case &quot;ComboBox&quot;:
642                         case &quot;DatePicker&quot;:
643                         case &quot;MenuButton&quot;:
644                         case &quot;PasswordField&quot;:
645                         case &quot;RadioButton&quot;:
646                         case &quot;ScrollBar&quot;:
647                         case &quot;ScrollPane&quot;:
648                         case &quot;Slider&quot;:
649                         case &quot;SplitMenuButton&quot;:
650                         case &quot;SplitPane&quot;:
651                         case &quot;TextArea&quot;:
652                         case &quot;TextField&quot;:
653                         case &quot;ToggleButton&quot;:
654                         case &quot;ToolBar&quot;:
655                         default:
656                             customMenuItem.setHideOnClick(false);
657                             break;
658                     }
659 
660                     overflowMenuItems.add(customMenuItem);
661                 }
662             }
663         }
664 
665         // Check if we overflowed.
666         overflow = overflowMenuItems.size() &gt; 0;
667         if (!overflow &amp;&amp; overflowMenu.isFocused()) {
668             Node last = engine.selectLast();
669             if (last != null) {
670                 last.requestFocus();
671             }
672         }
673         overflowMenu.setVisible(overflow);
674         overflowMenu.setManaged(overflow);
675     }
676 
677     private void addNodesToToolBar() {
678         final ToolBar toolbar = getSkinnable();
679         double toolbarLength = getToolbarLength(toolbar);
680 
681         // Is there overflow ?
682         boolean hasOverflow = isOverflowed(toolbarLength);
683 
684         organizeOverflow(toolbarLength, hasOverflow);
685     }
686 
687     private double getToolbarLength(ToolBar toolbar) {
688         double length;
689         if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
690             length = snapSizeY(toolbar.getHeight()) - snappedTopInset() - snappedBottomInset() + getSpacing();
691         } else {
692             length = snapSizeX(toolbar.getWidth()) - snappedLeftInset() - snappedRightInset() + getSpacing();
693         }
694         return length;
695     }
696 
697     private boolean isOverflowed(double length) {
698         double x = 0;
699         boolean hasOverflow = false;
700         for (Node node : getSkinnable().getItems()) {
701             if (!node.isManaged()) continue;
702             if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
703                 x += snapSizeY(node.prefHeight(-1)) + getSpacing();
704             } else {
705                 x += snapSizeX(node.prefWidth(-1)) + getSpacing();
706             }
707             if (x &gt; length) {
708                 hasOverflow = true;
709                 break;
710             }
711         }
712         return hasOverflow;
713     }
714 
715     /***************************************************************************
716      *                                                                         *
717      * Support classes                                                         *
718      *                                                                         *
719      **************************************************************************/
720 
721     class ToolBarOverflowMenu extends StackPane {
722         private StackPane downArrow;
723         private ContextMenu popup;
724         private ObservableList&lt;MenuItem&gt; menuItems;
725 
726         public ToolBarOverflowMenu(ObservableList&lt;MenuItem&gt; items) {
727             getStyleClass().setAll(&quot;tool-bar-overflow-button&quot;);
728             setAccessibleRole(AccessibleRole.BUTTON);
729             setAccessibleText(getString(&quot;Accessibility.title.ToolBar.OverflowButton&quot;));
730             setFocusTraversable(true);
731             this.menuItems = items;
732             downArrow = new StackPane();
733             downArrow.getStyleClass().setAll(&quot;arrow&quot;);
734             downArrow.setOnMousePressed(me -&gt; {
735                 fire();
736             });
737 
738             setOnKeyPressed(ke -&gt; {
739                 if (KeyCode.SPACE.equals(ke.getCode())) {
740                     if (!popup.isShowing()) {
741                         popup.getItems().clear();
742                         popup.getItems().addAll(menuItems);
743                         popup.show(downArrow, Side.BOTTOM, 0, 0);
744                     }
745                     ke.consume();
746                 } else if (KeyCode.ESCAPE.equals(ke.getCode())) {
747                     if (popup.isShowing()) {
748                         popup.hide();
749                     }
750                     ke.consume();
751                 } else if (KeyCode.ENTER.equals(ke.getCode())) {
752                     fire();
753                     ke.consume();
754                 }
755             });
756 
757             visibleProperty().addListener((observable, oldValue, newValue) -&gt; {
758                     if (newValue) {
759                         if (box.getChildren().isEmpty()) {
760                             setFocusTraversable(true);
761                         }
762                     }
763             });
764             popup = new ContextMenu();
765             setVisible(false);
766             setManaged(false);
767             getChildren().add(downArrow);
768         }
769 
770         private void fire() {
771             if (popup.isShowing()) {
772                 popup.hide();
773             } else {
774                 popup.getItems().clear();
775                 popup.getItems().addAll(menuItems);
776                 popup.show(downArrow, Side.BOTTOM, 0, 0);
777             }
778         }
779 
780         @Override protected double computePrefWidth(double height) {
781             return snappedLeftInset() + snappedRightInset();
782         }
783 
784         @Override protected double computePrefHeight(double width) {
785             return snappedTopInset() + snappedBottomInset();
786         }
787 
788         @Override protected void layoutChildren() {
789             double w = snapSize(downArrow.prefWidth(-1));
790             double h = snapSize(downArrow.prefHeight(-1));
791             double x = (snapSize(getWidth()) - w)/2;
792             double y = (snapSize(getHeight()) - h)/2;
793 
794             // TODO need to provide support for when the toolbar is on the right
795             // or bottom
796             if (getSkinnable().getOrientation() == Orientation.VERTICAL) {
797                 downArrow.setRotate(0);
798             }
799 
800             downArrow.resize(w, h);
801             positionInArea(downArrow, x, y, w, h,
802                     /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
803         }
804 
805         /** {@inheritDoc} */
806         @Override
807         public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
808             switch (action) {
809                 case FIRE: fire(); break;
810                 default: super.executeAccessibleAction(action); break;
811             }
812         }
813     }
814 
815     /***************************************************************************
816      *                                                                         *
817      *                         Stylesheet Handling                             *
818      *                                                                         *
819      **************************************************************************/
820 
821      /*
822       * Super-lazy instantiation pattern from Bill Pugh.
823       */
824      private static class StyleableProperties {
825          private static final CssMetaData&lt;ToolBar,Number&gt; SPACING =
826              new CssMetaData&lt;ToolBar,Number&gt;(&quot;-fx-spacing&quot;,
827                  SizeConverter.getInstance(), 0.0) {
828 
829             @Override
830             public boolean isSettable(ToolBar n) {
831                 final ToolBarSkin skin = (ToolBarSkin) n.getSkin();
832                 return skin.spacing == null || !skin.spacing.isBound();
833             }
834 
835             @Override
836             public StyleableProperty&lt;Number&gt; getStyleableProperty(ToolBar n) {
837                 final ToolBarSkin skin = (ToolBarSkin) n.getSkin();
838                 return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;)skin.spacingProperty();
839             }
840         };
841 
842         private static final CssMetaData&lt;ToolBar,Pos&gt;ALIGNMENT =
843                 new CssMetaData&lt;ToolBar,Pos&gt;(&quot;-fx-alignment&quot;,
844                 new EnumConverter&lt;Pos&gt;(Pos.class), Pos.TOP_LEFT ) {
845 
846             @Override
847             public boolean isSettable(ToolBar n) {
848                 final ToolBarSkin skin = (ToolBarSkin) n.getSkin();
849                 return skin.boxAlignment == null || !skin.boxAlignment.isBound();
850             }
851 
852             @Override
853             public StyleableProperty&lt;Pos&gt; getStyleableProperty(ToolBar n) {
854                 final ToolBarSkin skin = (ToolBarSkin) n.getSkin();
855                 return (StyleableProperty&lt;Pos&gt;)(WritableValue&lt;Pos&gt;)skin.boxAlignmentProperty();
856             }
857         };
858 
859 
860          private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
861          static {
862 
863             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
864                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
865 
866             // StackPane also has -fx-alignment. Replace it with
867             // ToolBarSkin&#39;s.
868             // TODO: Really should be able to reference StackPane.StyleableProperties.ALIGNMENT
869             final String alignmentProperty = ALIGNMENT.getProperty();
870             for (int n=0, nMax=styleables.size(); n&lt;nMax; n++) {
871                 final CssMetaData&lt;?,?&gt; prop = styleables.get(n);
872                 if (alignmentProperty.equals(prop.getProperty())) styleables.remove(prop);
873             }
874 
875             styleables.add(SPACING);
876             styleables.add(ALIGNMENT);
877             STYLEABLES = Collections.unmodifiableList(styleables);
878 
879          }
880     }
881 
882     /**
883      * Returns the CssMetaData associated with this class, which may include the
884      * CssMetaData of its superclasses.
885      * @return the CssMetaData associated with this class, which may include the
886      * CssMetaData of its superclasses
887      */
888     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
889         return StyleableProperties.STYLEABLES;
890     }
891 
892     /**
893      * {@inheritDoc}
894      */
895     @Override
896     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
897         return getClassCssMetaData();
898     }
899 
900     @Override
901     protected Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
902         switch (attribute) {
903             case OVERFLOW_BUTTON: return overflowMenu;
904             default: return super.queryAccessibleAttribute(attribute, parameters);
905         }
906     }
907 
908     @Override
909     protected void executeAccessibleAction(AccessibleAction action, Object... parameters) {
910         switch (action) {
911             case SHOW_MENU:
912                 overflowMenu.fire();
913                 break;
914             default: super.executeAccessibleAction(action, parameters);
915         }
916     }
917 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
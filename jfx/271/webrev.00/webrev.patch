diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGClobberize.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGClobberize.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGClobberize.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGClobberize.h
@@ -226,11 +226,11 @@
         }
         return;
 
     case ArithAbs:
         if (node->child1().useKind() == Int32Use || node->child1().useKind() == DoubleRepUse)
-            def(PureValue(node));
+            def(PureValue(node, node->arithMode()));
         else {
             read(World);
             write(Heap);
         }
         return;
@@ -246,11 +246,11 @@
 
     case ArithNegate:
         if (node->child1().useKind() == Int32Use
             || node->child1().useKind() == DoubleRepUse
             || node->child1().useKind() == Int52RepUse)
-            def(PureValue(node));
+            def(PureValue(node, node->arithMode()));
         else {
             read(World);
             write(Heap);
         }
         return;
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/GCMemoryOperations.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/GCMemoryOperations.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/GCMemoryOperations.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/GCMemoryOperations.h
@@ -51,11 +51,11 @@
         size_t count = bytes / 8;
         for (unsigned i = 0; i < count; ++i)
             bitwise_cast<volatile uint64_t*>(dst)[i] = bitwise_cast<volatile uint64_t*>(src)[i];
     };
 
-#if COMPILER(GCC_COMPATIBLE) && USE(JSVALUE64)
+#if COMPILER(GCC_COMPATIBLE) && (CPU(X86_64) || CPU(ARM64))
     if (bytes <= smallCutoff)
         slowPathForwardMemcpy();
     else if (isARM64() || bytes <= mediumCutoff) {
 #if CPU(X86_64)
         size_t alignedBytes = (bytes / 64) * 64;
@@ -119,12 +119,10 @@
 
             : [alignedBytes] "+r" (alignedBytes), [bytes] "+r" (bytes), [offset] "+r" (offset), [dstPtr] "+r" (dstPtr), [srcPtr] "+r" (srcPtr)
             :
             : "d0", "d1", "memory"
         );
-#else
-    slowPathForwardMemcpy();
 #endif // CPU(X86_64)
     } else {
         RELEASE_ASSERT(isX86_64());
 #if CPU(X86_64)
         size_t count = bytes / 8;
@@ -137,11 +135,11 @@
             : "memory");
 #endif // CPU(X86_64)
     }
 #else
     slowPathForwardMemcpy();
-#endif // COMPILER(GCC_COMPATIBLE)
+#endif // COMPILER(GCC_COMPATIBLE) && (CPU(X86_64) || CPU(ARM64))
 #else
     memcpy(dst, src, bytes);
 #endif // USE(JSVALUE64)
 }
 
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StructureInlines.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StructureInlines.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StructureInlines.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StructureInlines.h
@@ -34,20 +34,20 @@
 #include "StructureRareDataInlines.h"
 #include <wtf/Threading.h>
 
 namespace JSC {
 
-inline Structure* Structure::create(VM& vm, JSGlobalObject* globalObject, JSValue prototype, const TypeInfo& typeInfo, const ClassInfo* classInfo, IndexingType indexingType, unsigned inlineCapacity)
+inline Structure* Structure::create(VM& vm, JSGlobalObject* globalObject, JSValue prototype, const TypeInfo& typeInfo, const ClassInfo* classInfo, IndexingType indexingModeIncludingHistory, unsigned inlineCapacity)
 {
     ASSERT(vm.structureStructure);
     ASSERT(classInfo);
     if (auto* object = prototype.getObject()) {
-        ASSERT(!object->anyObjectInChainMayInterceptIndexedAccesses(vm) || hasSlowPutArrayStorage(indexingType) || !hasIndexedProperties(indexingType));
+        ASSERT(!object->anyObjectInChainMayInterceptIndexedAccesses(vm) || hasSlowPutArrayStorage(indexingModeIncludingHistory) || !hasIndexedProperties(indexingModeIncludingHistory));
         object->didBecomePrototype();
     }
 
-    Structure* structure = new (NotNull, allocateCell<Structure>(vm.heap)) Structure(vm, globalObject, prototype, typeInfo, classInfo, indexingType, inlineCapacity);
+    Structure* structure = new (NotNull, allocateCell<Structure>(vm.heap)) Structure(vm, globalObject, prototype, typeInfo, classInfo, indexingModeIncludingHistory, inlineCapacity);
     structure->finishCreation(vm);
     return structure;
 }
 
 inline Structure* Structure::createStructure(VM& vm)
diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/DataMutex.h b/modules/javafx.web/src/main/native/Source/WTF/wtf/DataMutex.h
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/DataMutex.h
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/DataMutex.h
@@ -19,14 +19,78 @@
  */
 
 #pragma once
 
 #include <wtf/Lock.h>
+#include <wtf/Threading.h>
 
 namespace WTF {
 
-template<typename T>
+// By default invalid access checks are only done in Debug builds.
+#if !defined(ENABLE_DATA_MUTEX_CHECKS)
+#if defined(NDEBUG)
+#define ENABLE_DATA_MUTEX_CHECKS 0
+#else
+#define ENABLE_DATA_MUTEX_CHECKS 1
+#endif
+#endif
+
+#if ENABLE_DATA_MUTEX_CHECKS
+#define DATA_MUTEX_CHECK(expr) RELEASE_ASSERT(expr)
+#else
+#define DATA_MUTEX_CHECK(expr)
+#endif
+
+template<typename LockType>
+class OwnerAwareLockAdapter {
+public:
+    void lock()
+    {
+        DATA_MUTEX_CHECK(m_owner != &Thread::current()); // Thread attempted recursive lock (unsupported).
+        m_lock.lock();
+#if ENABLE_DATA_MUTEX_CHECKS
+        ASSERT(!m_owner);
+        m_owner = &Thread::current();
+#endif
+    }
+
+    void unlock()
+    {
+#if ENABLE_DATA_MUTEX_CHECKS
+        m_owner = nullptr;
+#endif
+        m_lock.unlock();
+    }
+
+    bool tryLock()
+    {
+        DATA_MUTEX_CHECK(m_owner != &Thread::current()); // Thread attempted recursive lock (unsupported).
+        if (!m_lock.tryLock())
+            return false;
+
+#if ENABLE_DATA_MUTEX_CHECKS
+        ASSERT(!m_owner);
+        m_owner = &Thread::current();
+#endif
+        return true;
+    }
+
+    bool isLocked() const
+    {
+        return m_lock.isLocked();
+    }
+
+private:
+#if ENABLE_DATA_MUTEX_CHECKS
+    Thread* m_owner { nullptr }; // Use Thread* instead of RefPtr<Thread> since m_owner thread is always alive while m_owner is set.
+#endif
+    LockType m_lock;
+};
+
+using OwnerAwareLock = OwnerAwareLockAdapter<Lock>;
+
+template<typename T, typename LockType = OwnerAwareLock>
 class DataMutex {
     WTF_MAKE_FAST_ALLOCATED;
     WTF_MAKE_NONCOPYABLE(DataMutex);
 public:
     template<typename ...Args>
@@ -42,35 +106,47 @@
             , m_data(dataMutex.m_data)
         { }
 
         T* operator->()
         {
+            DATA_MUTEX_CHECK(m_mutex.isLocked());
             return &m_data;
         }
 
         T& operator*()
         {
+            DATA_MUTEX_CHECK(m_mutex.isLocked());
             return m_data;
         }
 
-        Lock& mutex()
+        LockType& mutex()
         {
             return m_mutex;
         }
 
-        LockHolder& lockHolder()
+        Locker<LockType>& lockHolder()
         {
             return m_lockHolder;
         }
 
+        // Used to avoid excessive brace scoping when only small parts of the code need to be run unlocked.
+        // Please be mindful that accessing the wrapped data from the callback is unsafe and will fail on assertions.
+        // It's helpful to use a minimal lambda capture to be conscious of what data you're having access to in these sections.
+        void runUnlocked(WTF::Function<void()> callback)
+        {
+            m_mutex.unlock();
+            callback();
+            m_mutex.lock();
+        }
+
     private:
-        Lock& m_mutex;
-        LockHolder m_lockHolder;
+        LockType& m_mutex;
+        Locker<LockType> m_lockHolder;
         T& m_data;
     };
 
 private:
-    Lock m_mutex;
+    LockType m_mutex;
     T m_data;
 };
 
 } // namespace WTF
diff a/modules/javafx.web/src/main/native/Source/WebCore/SourcesWPE.txt b/modules/javafx.web/src/main/native/Source/WebCore/SourcesWPE.txt
--- a/modules/javafx.web/src/main/native/Source/WebCore/SourcesWPE.txt
+++ b/modules/javafx.web/src/main/native/Source/WebCore/SourcesWPE.txt
@@ -56,10 +56,12 @@
 page/scrolling/nicosia/ScrollingTreeOverflowScrollingNodeNicosia.cpp
 page/scrolling/nicosia/ScrollingTreePositionedNode.cpp
 page/scrolling/nicosia/ScrollingTreeStickyNode.cpp
 
 page/scrolling/generic/ScrollingThreadGeneric.cpp
+
+platform/ScrollAnimationKinetic.cpp
 
 platform/UserAgentQuirks.cpp
 
 platform/graphics/GLContext.cpp
 platform/graphics/PlatformDisplay.cpp
diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMWindowProperties.h b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMWindowProperties.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMWindowProperties.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMWindowProperties.h
@@ -49,11 +49,11 @@
 
     DECLARE_INFO;
 
     static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
     {
-        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
+        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info(), JSC::MayHaveIndexedAccessors);
     }
 
     static bool getOwnPropertySlot(JSC::JSObject*, JSC::JSGlobalObject*, JSC::PropertyName, JSC::PropertySlot&);
     static bool getOwnPropertySlotByIndex(JSC::JSObject*, JSC::JSGlobalObject*, unsigned propertyName, JSC::PropertySlot&);
 
diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptController.cpp b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptController.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptController.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptController.cpp
@@ -809,20 +809,31 @@
     Ref<Frame> protector(m_frame);
     RefPtr<Document> ownerDocument(m_frame.document());
 
     const int javascriptSchemeLength = sizeof("javascript:") - 1;
 
+    JSDOMGlobalObject* globalObject = jsWindowProxy(mainThreadNormalWorld()).window();
+    VM& vm = globalObject->vm();
+    auto throwScope = DECLARE_THROW_SCOPE(vm);
+
     String decodedURL = decodeURLEscapeSequences(url.string());
     auto result = executeScriptIgnoringException(decodedURL.substring(javascriptSchemeLength));
+    RELEASE_ASSERT(&vm == &jsWindowProxy(mainThreadNormalWorld()).window()->vm());
 
     // If executing script caused this frame to be removed from the page, we
     // don't want to try to replace its document!
     if (!m_frame.page())
         return true;
 
+    if (!result)
+        return true;
+
     String scriptResult;
-    if (!result || !result.getString(jsWindowProxy(mainThreadNormalWorld()).window(), scriptResult))
+    bool isString = result.getString(globalObject, scriptResult);
+    RETURN_IF_EXCEPTION(throwScope, true);
+
+    if (!isString)
         return true;
 
     // FIXME: We should always replace the document, but doing so
     //        synchronously can cause crashes:
     //        http://bugs.webkit.org/show_bug.cgi?id=16782
diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/CodeGeneratorJS.pm b/modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/CodeGeneratorJS.pm
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/CodeGeneratorJS.pm
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/CodeGeneratorJS.pm
@@ -2739,19 +2739,20 @@
     }
 
     # Structure ID
     push(@headerContent, "    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)\n");
     push(@headerContent, "    {\n");
+    my $indexingModeIncludingHistory = InstanceOverridesGetOwnPropertySlot($interface) ? "JSC::MayHaveIndexedAccessors" : "JSC::NonArray";
     if (IsDOMGlobalObject($interface)) {
-        push(@headerContent, "        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::GlobalObjectType, StructureFlags), info());\n");
+        push(@headerContent, "        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::GlobalObjectType, StructureFlags), info(), $indexingModeIncludingHistory);\n");
     } elsif ($codeGenerator->InheritsInterface($interface, "Node")) {
         my $type = GetJSTypeForNode($interface);
-        push(@headerContent, "        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::JSType($type), StructureFlags), info());\n");
+        push(@headerContent, "        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::JSType($type), StructureFlags), info(), $indexingModeIncludingHistory);\n");
     } elsif ($codeGenerator->InheritsInterface($interface, "Event")) {
-        push(@headerContent, "        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::JSType(JSEventType), StructureFlags), info());\n");
+        push(@headerContent, "        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::JSType(JSEventType), StructureFlags), info(), $indexingModeIncludingHistory);\n");
     } else {
-        push(@headerContent, "        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());\n");
+        push(@headerContent, "        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info(), $indexingModeIncludingHistory);\n");
     }
     push(@headerContent, "    }\n\n");
 
     # Custom pushEventHandlerScope function
     if ($interface->extendedAttributes->{CustomPushEventHandlerScope}) {
diff a/modules/javafx.web/src/main/native/Source/WebCore/loader/FrameLoader.cpp b/modules/javafx.web/src/main/native/Source/WebCore/loader/FrameLoader.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/loader/FrameLoader.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/loader/FrameLoader.cpp
@@ -4167,16 +4167,25 @@
     FloatRect windowRect = page->chrome().windowRect();
     if (features.x)
         windowRect.setX(*features.x);
     if (features.y)
         windowRect.setY(*features.y);
-    // Zero width and height mean using default size, not minumum one.
+    // Zero width and height mean using default size, not minimum one.
     if (features.width && *features.width)
         windowRect.setWidth(*features.width + (windowRect.width() - viewportSize.width()));
     if (features.height && *features.height)
         windowRect.setHeight(*features.height + (windowRect.height() - viewportSize.height()));
 
+#if PLATFORM(GTK)
+    FloatRect oldWindowRect = oldPage->chrome().windowRect();
+    // Use the size of the previous window if there is no default size.
+    if (!windowRect.width())
+        windowRect.setWidth(oldWindowRect.width());
+    if (!windowRect.height())
+        windowRect.setHeight(oldWindowRect.height());
+#endif
+
     // Ensure non-NaN values, minimum size as well as being within valid screen area.
     FloatRect newWindowRect = DOMWindow::adjustWindowRect(*page, windowRect);
 
     if (!frame->page())
         return nullptr;
diff a/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingTreeScrollingNode.cpp b/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingTreeScrollingNode.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingTreeScrollingNode.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingTreeScrollingNode.cpp
@@ -162,10 +162,13 @@
 void ScrollingTreeScrollingNode::scrollTo(const FloatPoint& position, ScrollType scrollType, ScrollClamping clamp)
 {
     if (position == m_currentScrollPosition)
         return;
 
+    if (scrollType == ScrollType::Programmatic)
+        stopScrollAnimations();
+
     scrollingTree().setIsHandlingProgrammaticScroll(scrollType == ScrollType::Programmatic);
 
     m_currentScrollPosition = adjustedScrollPosition(position, clamp);
 
     LOG_WITH_STREAM(Scrolling, stream << "ScrollingTreeScrollingNode " << scrollingNodeID() << " scrollTo " << position << " (delta from last committed position " << (m_lastCommittedScrollPosition - m_currentScrollPosition) << ")");
diff a/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingTreeScrollingNode.h b/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingTreeScrollingNode.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingTreeScrollingNode.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingTreeScrollingNode.h
@@ -61,17 +61,21 @@
 
     // These are imperative; they adjust the scrolling layers.
     void scrollTo(const FloatPoint&, ScrollType = ScrollType::User, ScrollClamping = ScrollClamping::Clamped);
     void scrollBy(const FloatSize&, ScrollClamping = ScrollClamping::Clamped);
 
+    virtual void stopScrollAnimations() { };
+
     void wasScrolledByDelegatedScrolling(const FloatPoint& position, Optional<FloatRect> overrideLayoutViewport = { }, ScrollingLayerPositionAction = ScrollingLayerPositionAction::Sync);
 
     const FloatSize& scrollableAreaSize() const { return m_scrollableAreaSize; }
     const FloatSize& totalContentsSize() const { return m_totalContentsSize; }
 
     bool horizontalScrollbarHiddenByStyle() const { return m_scrollableAreaParameters.horizontalScrollbarHiddenByStyle; }
     bool verticalScrollbarHiddenByStyle() const { return m_scrollableAreaParameters.verticalScrollbarHiddenByStyle; }
+    bool canHaveHorizontalScrollbar() const { return m_scrollableAreaParameters.horizontalScrollbarMode != ScrollbarAlwaysOff; }
+    bool canHaveVerticalScrollbar() const { return m_scrollableAreaParameters.verticalScrollbarMode != ScrollbarAlwaysOff; }
     bool canHaveScrollbars() const { return m_scrollableAreaParameters.horizontalScrollbarMode != ScrollbarAlwaysOff || m_scrollableAreaParameters.verticalScrollbarMode != ScrollbarAlwaysOff; }
 
 #if ENABLE(CSS_SCROLL_SNAP)
     const Vector<float>& horizontalSnapOffsets() const { return m_snapOffsetsInfo.horizontalSnapOffsets; }
     const Vector<float>& verticalSnapOffsets() const { return m_snapOffsetsInfo.verticalSnapOffsets; }
diff a/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/nicosia/ScrollingTreeFrameScrollingNodeNicosia.cpp b/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/nicosia/ScrollingTreeFrameScrollingNodeNicosia.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/nicosia/ScrollingTreeFrameScrollingNodeNicosia.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/nicosia/ScrollingTreeFrameScrollingNodeNicosia.cpp
@@ -35,20 +35,38 @@
 #include "Logging.h"
 #include "NicosiaPlatformLayer.h"
 #include "ScrollingStateFrameScrollingNode.h"
 #include "ScrollingTree.h"
 
+#if ENABLE(KINETIC_SCROLLING)
+#include "ScrollAnimationKinetic.h"
+#endif
+
 namespace WebCore {
 
 Ref<ScrollingTreeFrameScrollingNode> ScrollingTreeFrameScrollingNodeNicosia::create(ScrollingTree& scrollingTree, ScrollingNodeType nodeType, ScrollingNodeID nodeID)
 {
     return adoptRef(*new ScrollingTreeFrameScrollingNodeNicosia(scrollingTree, nodeType, nodeID));
 }
 
 ScrollingTreeFrameScrollingNodeNicosia::ScrollingTreeFrameScrollingNodeNicosia(ScrollingTree& scrollingTree, ScrollingNodeType nodeType, ScrollingNodeID nodeID)
     : ScrollingTreeFrameScrollingNode(scrollingTree, nodeType, nodeID)
 {
+#if ENABLE(KINETIC_SCROLLING)
+    m_kineticAnimation = makeUnique<ScrollAnimationKinetic>(
+        [this]() -> ScrollAnimationKinetic::ScrollExtents {
+            return { IntPoint(minimumScrollPosition()), IntPoint(maximumScrollPosition()) };
+        },
+        [this](FloatPoint&& position) {
+            auto* scrollLayer = static_cast<Nicosia::PlatformLayer*>(scrolledContentsLayer());
+            ASSERT(scrollLayer);
+            auto& compositionLayer = downcast<Nicosia::CompositionLayer>(*scrollLayer);
+
+            auto updateScope = compositionLayer.createUpdateScope();
+            scrollTo(position);
+        });
+#endif
 }
 
 ScrollingTreeFrameScrollingNodeNicosia::~ScrollingTreeFrameScrollingNodeNicosia() = default;
 
 void ScrollingTreeFrameScrollingNodeNicosia::commitStateBeforeChildren(const ScrollingStateNode& stateNode)
@@ -106,18 +124,43 @@
         ASSERT(scrollLayer);
         auto& compositionLayer = downcast<Nicosia::CompositionLayer>(*scrollLayer);
 
         auto updateScope = compositionLayer.createUpdateScope();
         scrollBy({ -wheelEvent.deltaX(), -wheelEvent.deltaY() });
+
     }
 
+#if ENABLE(KINETIC_SCROLLING)
+    m_kineticAnimation->appendToScrollHistory(wheelEvent);
+#endif
+
+#if ENABLE(KINETIC_SCROLLING)
+    m_kineticAnimation->stop();
+    if (wheelEvent.isEndOfNonMomentumScroll()) {
+        m_kineticAnimation->start(currentScrollPosition(), m_kineticAnimation->computeVelocity(), canHaveHorizontalScrollbar(), canHaveVerticalScrollbar());
+        m_kineticAnimation->clearScrollHistory();
+    }
+    if (wheelEvent.isTransitioningToMomentumScroll()) {
+        m_kineticAnimation->start(currentScrollPosition(), wheelEvent.swipeVelocity(), canHaveHorizontalScrollbar(), canHaveVerticalScrollbar());
+        m_kineticAnimation->clearScrollHistory();
+    }
+#endif
+
     scrollingTree().setOrClearLatchedNode(wheelEvent, scrollingNodeID());
 
     // FIXME: This needs to return whether the event was handled.
     return ScrollingEventResult::DidHandleEvent;
 }
 
+void ScrollingTreeFrameScrollingNodeNicosia::stopScrollAnimations()
+{
+#if ENABLE(KINETIC_SCROLLING)
+    m_kineticAnimation->stop();
+    m_kineticAnimation->clearScrollHistory();
+#endif
+}
+
 FloatPoint ScrollingTreeFrameScrollingNodeNicosia::adjustedScrollPosition(const FloatPoint& position, ScrollClamping clamping) const
 {
     FloatPoint scrollPosition(roundf(position.x()), roundf(position.y()));
     return ScrollingTreeFrameScrollingNode::adjustedScrollPosition(scrollPosition, clamping);
 }
diff a/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/nicosia/ScrollingTreeFrameScrollingNodeNicosia.h b/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/nicosia/ScrollingTreeFrameScrollingNodeNicosia.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/nicosia/ScrollingTreeFrameScrollingNodeNicosia.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/nicosia/ScrollingTreeFrameScrollingNodeNicosia.h
@@ -37,10 +37,11 @@
 namespace Nicosia {
 class CompositionLayer;
 }
 
 namespace WebCore {
+class ScrollAnimationKinetic;
 
 class ScrollingTreeFrameScrollingNodeNicosia final : public ScrollingTreeFrameScrollingNode {
 public:
     static Ref<ScrollingTreeFrameScrollingNode> create(ScrollingTree&, ScrollingNodeType, ScrollingNodeID);
     virtual ~ScrollingTreeFrameScrollingNodeNicosia();
@@ -51,10 +52,12 @@
     void commitStateBeforeChildren(const ScrollingStateNode&) override;
     void commitStateAfterChildren(const ScrollingStateNode&) override;
 
     ScrollingEventResult handleWheelEvent(const PlatformWheelEvent&) override;
 
+    void stopScrollAnimations() override;
+
     FloatPoint adjustedScrollPosition(const FloatPoint&, ScrollClamping) const override;
 
     void currentScrollPositionChanged() override;
 
     void repositionScrollingLayers() override;
@@ -64,10 +67,14 @@
     RefPtr<Nicosia::CompositionLayer> m_counterScrollingLayer;
     RefPtr<Nicosia::CompositionLayer> m_insetClipLayer;
     RefPtr<Nicosia::CompositionLayer> m_contentShadowLayer;
     RefPtr<Nicosia::CompositionLayer> m_headerLayer;
     RefPtr<Nicosia::CompositionLayer> m_footerLayer;
+
+#if ENABLE(KINETIC_SCROLLING)
+    std::unique_ptr<ScrollAnimationKinetic> m_kineticAnimation;
+#endif
 };
 
 } // namespace WebCore
 
 #endif // ENABLE(ASYNC_SCROLLING) && USE(NICOSIA)
diff a/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/nicosia/ScrollingTreeOverflowScrollingNodeNicosia.cpp b/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/nicosia/ScrollingTreeOverflowScrollingNodeNicosia.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/nicosia/ScrollingTreeOverflowScrollingNodeNicosia.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/nicosia/ScrollingTreeOverflowScrollingNodeNicosia.cpp
@@ -30,10 +30,13 @@
 #include "ScrollingTreeOverflowScrollingNodeNicosia.h"
 
 #if ENABLE(ASYNC_SCROLLING) && USE(NICOSIA)
 
 #include "NicosiaPlatformLayer.h"
+#if ENABLE(KINETIC_SCROLLING)
+#include "ScrollAnimationKinetic.h"
+#endif
 #include "ScrollingStateOverflowScrollingNode.h"
 #include "ScrollingTree.h"
 
 namespace WebCore {
 
@@ -43,10 +46,24 @@
 }
 
 ScrollingTreeOverflowScrollingNodeNicosia::ScrollingTreeOverflowScrollingNodeNicosia(ScrollingTree& scrollingTree, ScrollingNodeID nodeID)
     : ScrollingTreeOverflowScrollingNode(scrollingTree, nodeID)
 {
+#if ENABLE(KINETIC_SCROLLING)
+    m_kineticAnimation = makeUnique<ScrollAnimationKinetic>(
+        [this]() -> ScrollAnimationKinetic::ScrollExtents {
+            return { IntPoint(minimumScrollPosition()), IntPoint(maximumScrollPosition()) };
+        },
+        [this](FloatPoint&& position) {
+            auto* scrollLayer = static_cast<Nicosia::PlatformLayer*>(scrolledContentsLayer());
+            ASSERT(scrollLayer);
+            auto& compositionLayer = downcast<Nicosia::CompositionLayer>(*scrollLayer);
+
+            auto updateScope = compositionLayer.createUpdateScope();
+            scrollTo(position);
+        });
+#endif
 }
 
 ScrollingTreeOverflowScrollingNodeNicosia::~ScrollingTreeOverflowScrollingNodeNicosia() = default;
 
 void ScrollingTreeOverflowScrollingNodeNicosia::commitStateAfterChildren(const ScrollingStateNode& stateNode)
@@ -94,13 +111,37 @@
 
         auto updateScope = compositionLayer.createUpdateScope();
         scrollBy({ -wheelEvent.deltaX(), -wheelEvent.deltaY() });
     }
 
+#if ENABLE(KINETIC_SCROLLING)
+    m_kineticAnimation->appendToScrollHistory(wheelEvent);
+#endif
+
+#if ENABLE(KINETIC_SCROLLING)
+    m_kineticAnimation->stop();
+    if (wheelEvent.isEndOfNonMomentumScroll()) {
+        m_kineticAnimation->start(currentScrollPosition(), m_kineticAnimation->computeVelocity(), canHaveHorizontalScrollbar(), canHaveVerticalScrollbar());
+        m_kineticAnimation->clearScrollHistory();
+    }
+    if (wheelEvent.isTransitioningToMomentumScroll()) {
+        m_kineticAnimation->start(currentScrollPosition(), wheelEvent.swipeVelocity(), canHaveHorizontalScrollbar(), canHaveVerticalScrollbar());
+        m_kineticAnimation->clearScrollHistory();
+    }
+#endif
+
     scrollingTree().setOrClearLatchedNode(wheelEvent, scrollingNodeID());
 
     return ScrollingEventResult::DidHandleEvent;
 }
 
+void ScrollingTreeOverflowScrollingNodeNicosia::stopScrollAnimations()
+{
+#if ENABLE(KINETIC_SCROLLING)
+    m_kineticAnimation->stop();
+    m_kineticAnimation->clearScrollHistory();
+#endif
+}
+
 } // namespace WebCore
 
 #endif // ENABLE(ASYNC_SCROLLING) && USE(NICOSIA)
diff a/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/nicosia/ScrollingTreeOverflowScrollingNodeNicosia.h b/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/nicosia/ScrollingTreeOverflowScrollingNodeNicosia.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/nicosia/ScrollingTreeOverflowScrollingNodeNicosia.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/nicosia/ScrollingTreeOverflowScrollingNodeNicosia.h
@@ -31,10 +31,11 @@
 #if ENABLE(ASYNC_SCROLLING) && USE(NICOSIA)
 
 #include "ScrollingTreeOverflowScrollingNode.h"
 
 namespace WebCore {
+class ScrollAnimationKinetic;
 
 class ScrollingTreeOverflowScrollingNodeNicosia final : public ScrollingTreeOverflowScrollingNode {
 public:
     static Ref<ScrollingTreeOverflowScrollingNode> create(ScrollingTree&, ScrollingNodeID);
     virtual ~ScrollingTreeOverflowScrollingNodeNicosia();
@@ -47,10 +48,16 @@
     FloatPoint adjustedScrollPosition(const FloatPoint&, ScrollClamping) const override;
 
     void repositionScrollingLayers() override;
 
     ScrollingEventResult handleWheelEvent(const PlatformWheelEvent&) override;
+
+    void stopScrollAnimations() override;
+
+#if ENABLE(KINETIC_SCROLLING)
+    std::unique_ptr<ScrollAnimationKinetic> m_kineticAnimation;
+#endif
 };
 
 } // namespace WebCore
 
 #endif // ENABLE(ASYNC_SCROLLING) && USE(NICOSIA)
diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/MIMETypeRegistry.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/MIMETypeRegistry.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/MIMETypeRegistry.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/MIMETypeRegistry.cpp
@@ -637,10 +637,16 @@
     }
 
     return true;
 }
 
+bool MIMETypeRegistry::isXMLEntityMIMEType(StringView mimeType)
+{
+    return equalLettersIgnoringASCIICase(mimeType, "text/xml-external-parsed-entity")
+        || equalLettersIgnoringASCIICase(mimeType, "application/xml-external-parsed-entity");
+}
+
 bool MIMETypeRegistry::isJavaAppletMIMEType(const String& mimeType)
 {
     // Since this set is very limited and is likely to remain so we won't bother with the overhead
     // of using a hash set.
     // Any of the MIME types below may be followed by any number of specific versions of the JVM,
diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/MIMETypeRegistry.h b/modules/javafx.web/src/main/native/Source/WebCore/platform/MIMETypeRegistry.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/MIMETypeRegistry.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/MIMETypeRegistry.h
@@ -124,10 +124,13 @@
 
     // Check to see if a MIME type is one where an XML document should be created
     // rather than an HTML document.
     WEBCORE_EXPORT static bool isXMLMIMEType(const String& mimeType);
 
+    // Check to see if a MIME type is for an XML external entity resource.
+    WEBCORE_EXPORT static bool isXMLEntityMIMEType(StringView mimeType);
+
     // Used in page load algorithm to decide whether to display as a text
     // document in a frame. Not a good idea to use elsewhere, because that code
     // makes this test is after many other tests are done on the MIME type.
     WEBCORE_EXPORT static bool isTextMIMEType(const String& mimeType);
 
diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollAnimationKinetic.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollAnimationKinetic.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollAnimationKinetic.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollAnimationKinetic.cpp
@@ -24,11 +24,15 @@
  */
 
 #include "config.h"
 #include "ScrollAnimationKinetic.h"
 
-#include "ScrollableArea.h"
+#include "PlatformWheelEvent.h"
+
+#if USE(GLIB)
+#include <wtf/glib/RunLoopSourcePriority.h>
+#endif
 
 /*
  * PerAxisData is a port of GtkKineticScrolling as of GTK+ 3.20,
  * mimicking its API and its behavior.
  *
@@ -63,10 +67,11 @@
 
 static const double decelFriction = 4;
 static const double frameRate = 60;
 static const Seconds tickTime = 1_s / frameRate;
 static const Seconds minimumTimerInterval { 1_ms };
+static const Seconds scrollCaptureThreshold { 150_ms };
 
 namespace WebCore {
 
 ScrollAnimationKinetic::PerAxisData::PerAxisData(double lower, double upper, double initialPosition, double initialVelocity)
     : m_lower(lower)
@@ -102,15 +107,18 @@
     }
 
     return m_velocity;
 }
 
-ScrollAnimationKinetic::ScrollAnimationKinetic(ScrollableArea& scrollableArea, std::function<void(FloatPoint&&)>&& notifyPositionChangedFunction)
-    : ScrollAnimation(scrollableArea)
+ScrollAnimationKinetic::ScrollAnimationKinetic(ScrollExtentsCallback&& scrollExtentsFunction, NotifyPositionChangedCallback&& notifyPositionChangedFunction)
+    : m_scrollExtentsFunction(WTFMove(scrollExtentsFunction))
     , m_notifyPositionChangedFunction(WTFMove(notifyPositionChangedFunction))
-    , m_animationTimer(*this, &ScrollAnimationKinetic::animationTimerFired)
+    , m_animationTimer(RunLoop::current(), this, &ScrollAnimationKinetic::animationTimerFired)
 {
+#if USE(GLIB)
+    m_animationTimer.setPriority(WTF::RunLoopSourcePriority::DisplayRefreshMonitorTimer);
+#endif
 }
 
 ScrollAnimationKinetic::~ScrollAnimationKinetic() = default;
 
 void ScrollAnimationKinetic::stop()
@@ -118,27 +126,62 @@
     m_animationTimer.stop();
     m_horizontalData = WTF::nullopt;
     m_verticalData = WTF::nullopt;
 }
 
+void ScrollAnimationKinetic::appendToScrollHistory(const PlatformWheelEvent& event)
+{
+    m_scrollHistory.removeAllMatching([&event] (PlatformWheelEvent& otherEvent) -> bool {
+        return (event.timestamp() - otherEvent.timestamp()) > scrollCaptureThreshold;
+    });
+
+    m_scrollHistory.append(event);
+}
+
+void ScrollAnimationKinetic::clearScrollHistory()
+{
+    m_scrollHistory.clear();
+}
+
+FloatPoint ScrollAnimationKinetic::computeVelocity()
+{
+    if (m_scrollHistory.isEmpty())
+        return { };
+
+    auto first = m_scrollHistory[0].timestamp();
+    auto last = m_scrollHistory.rbegin()->timestamp();
+
+    if (last == first)
+        return { };
+
+    FloatPoint accumDelta;
+    for (const auto& scrollEvent : m_scrollHistory)
+        accumDelta += FloatPoint(scrollEvent.deltaX(), scrollEvent.deltaY());
+
+    m_scrollHistory.clear();
+
+    return FloatPoint(accumDelta.x() * -1 / (last - first).value(), accumDelta.y() * -1 / (last - first).value());
+}
+
 void ScrollAnimationKinetic::start(const FloatPoint& initialPosition, const FloatPoint& velocity, bool mayHScroll, bool mayVScroll)
 {
     stop();
 
     m_position = initialPosition;
 
     if (!velocity.x() && !velocity.y())
         return;
 
+    auto extents = m_scrollExtentsFunction();
     if (mayHScroll) {
-        m_horizontalData = PerAxisData(m_scrollableArea.minimumScrollPosition().x(),
-            m_scrollableArea.maximumScrollPosition().x(),
+        m_horizontalData = PerAxisData(extents.minimumScrollPosition.x(),
+            extents.maximumScrollPosition.x(),
             initialPosition.x(), velocity.x());
     }
     if (mayVScroll) {
-        m_verticalData = PerAxisData(m_scrollableArea.minimumScrollPosition().y(),
-            m_scrollableArea.maximumScrollPosition().y(),
+        m_verticalData = PerAxisData(extents.minimumScrollPosition.y(),
+            extents.maximumScrollPosition.y(),
             initialPosition.y(), velocity.y());
     }
 
     m_startTime = MonotonicTime::now() - tickTime / 2.;
     animationTimerFired();
diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollAnimationKinetic.h b/modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollAnimationKinetic.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollAnimationKinetic.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollAnimationKinetic.h
@@ -25,19 +25,20 @@
 
 #pragma once
 
 #include "FloatPoint.h"
 #include "ScrollAnimation.h"
-#include "Timer.h"
 
 #include <wtf/Optional.h>
+#include <wtf/RunLoop.h>
 
 namespace WebCore {
 
-class ScrollableArea;
+class PlatformWheelEvent;
 
-class ScrollAnimationKinetic final: public ScrollAnimation {
+class ScrollAnimationKinetic final {
+    WTF_MAKE_FAST_ALLOCATED;
 private:
     class PerAxisData {
     public:
         PerAxisData(double lower, double upper, double initialPosition, double initialVelocity);
 
@@ -56,25 +57,39 @@
         double m_position { 0 };
         double m_velocity { 0 };
     };
 
 public:
-    ScrollAnimationKinetic(ScrollableArea&, std::function<void(FloatPoint&&)>&& notifyPositionChangedFunction);
+    struct ScrollExtents {
+        IntPoint minimumScrollPosition;
+        IntPoint maximumScrollPosition;
+    };
+
+    using ScrollExtentsCallback = WTF::Function<ScrollExtents(void)>;
+    using NotifyPositionChangedCallback = WTF::Function<void(FloatPoint&&)>;
+
+    ScrollAnimationKinetic(ScrollExtentsCallback&&, NotifyPositionChangedCallback&&);
     virtual ~ScrollAnimationKinetic();
 
+    void appendToScrollHistory(const PlatformWheelEvent&);
+    void clearScrollHistory();
+    FloatPoint computeVelocity();
+
     void start(const FloatPoint& initialPosition, const FloatPoint& velocity, bool mayHScroll, bool mayVScroll);
+    void stop();
 
 private:
-    void stop() override;
     void animationTimerFired();
 
-    std::function<void(FloatPoint&&)> m_notifyPositionChangedFunction;
+    ScrollExtentsCallback m_scrollExtentsFunction;
+    NotifyPositionChangedCallback m_notifyPositionChangedFunction;
 
     Optional<PerAxisData> m_horizontalData;
     Optional<PerAxisData> m_verticalData;
 
     MonotonicTime m_startTime;
-    Timer m_animationTimer;
+    RunLoop::Timer<ScrollAnimationKinetic> m_animationTimer;
     FloatPoint m_position;
+    Vector<PlatformWheelEvent> m_scrollHistory;
 };
 
 } // namespace WebCore
diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/generic/ScrollAnimatorGeneric.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/generic/ScrollAnimatorGeneric.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/generic/ScrollAnimatorGeneric.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/generic/ScrollAnimatorGeneric.cpp
@@ -38,28 +38,31 @@
 
 namespace WebCore {
 
 static const Seconds overflowScrollbarsAnimationDuration { 1_s };
 static const Seconds overflowScrollbarsAnimationHideDelay { 2_s };
-static const Seconds scrollCaptureThreshold { 150_ms };
 
 std::unique_ptr<ScrollAnimator> ScrollAnimator::create(ScrollableArea& scrollableArea)
 {
     return makeUnique<ScrollAnimatorGeneric>(scrollableArea);
 }
 
 ScrollAnimatorGeneric::ScrollAnimatorGeneric(ScrollableArea& scrollableArea)
     : ScrollAnimator(scrollableArea)
     , m_overlayScrollbarAnimationTimer(*this, &ScrollAnimatorGeneric::overlayScrollbarAnimationTimerFired)
 {
-    m_kineticAnimation = makeUnique<ScrollAnimationKinetic>(m_scrollableArea, [this](FloatPoint&& position) {
+    m_kineticAnimation = makeUnique<ScrollAnimationKinetic>(
+        [this]() -> ScrollAnimationKinetic::ScrollExtents {
+            return { m_scrollableArea.minimumScrollPosition(), m_scrollableArea.maximumScrollPosition() };
+        },
+        [this](FloatPoint&& position) {
 #if ENABLE(SMOOTH_SCROLLING)
-        if (m_smoothAnimation)
-            m_smoothAnimation->setCurrentPosition(position);
+            if (m_smoothAnimation)
+                m_smoothAnimation->setCurrentPosition(position);
 #endif
-        updatePosition(WTFMove(position));
-    });
+            updatePosition(WTFMove(position));
+        });
 
 #if ENABLE(SMOOTH_SCROLLING)
     if (scrollableArea.scrollAnimatorEnabled())
         ensureSmoothScrollingAnimation();
 #endif
@@ -92,70 +95,43 @@
 
 void ScrollAnimatorGeneric::scrollToOffsetWithoutAnimation(const FloatPoint& offset, ScrollClamping)
 {
     FloatPoint position = ScrollableArea::scrollPositionFromOffset(offset, toFloatSize(m_scrollableArea.scrollOrigin()));
     m_kineticAnimation->stop();
-    m_scrollHistory.clear();
+    m_kineticAnimation->clearScrollHistory();
 
 #if ENABLE(SMOOTH_SCROLLING)
     if (m_smoothAnimation)
         m_smoothAnimation->setCurrentPosition(position);
 #endif
 
     updatePosition(WTFMove(position));
 }
 
-FloatPoint ScrollAnimatorGeneric::computeVelocity()
-{
-    if (m_scrollHistory.isEmpty())
-        return { };
-
-    auto first = m_scrollHistory[0].timestamp();
-    auto last = m_scrollHistory.rbegin()->timestamp();
-
-    if (last == first)
-        return { };
-
-    FloatPoint accumDelta;
-    for (const auto& scrollEvent : m_scrollHistory)
-        accumDelta += FloatPoint(scrollEvent.deltaX(), scrollEvent.deltaY());
-
-    m_scrollHistory.clear();
-
-    return FloatPoint(accumDelta.x() * -1 / (last - first).value(), accumDelta.y() * -1 / (last - first).value());
-}
-
 bool ScrollAnimatorGeneric::handleWheelEvent(const PlatformWheelEvent& event)
 {
     m_kineticAnimation->stop();
 
-    m_scrollHistory.removeAllMatching([&event] (PlatformWheelEvent& otherEvent) -> bool {
-        return (event.timestamp() - otherEvent.timestamp()) > scrollCaptureThreshold;
-    });
-
 #if ENABLE(KINETIC_SCROLLING)
+    m_kineticAnimation->appendToScrollHistory(event);
+
     if (event.isEndOfNonMomentumScroll()) {
-        // We don't need to add the event to the history as its delta will be (0, 0).
-        static_cast<ScrollAnimationKinetic*>(m_kineticAnimation.get())->start(m_currentPosition, computeVelocity(), m_scrollableArea.horizontalScrollbar(), m_scrollableArea.verticalScrollbar());
+        m_kineticAnimation->start(m_currentPosition, m_kineticAnimation->computeVelocity(), m_scrollableArea.horizontalScrollbar(), m_scrollableArea.verticalScrollbar());
         return true;
     }
     if (event.isTransitioningToMomentumScroll()) {
-        m_scrollHistory.clear();
-        static_cast<ScrollAnimationKinetic*>(m_kineticAnimation.get())->start(m_currentPosition, event.swipeVelocity(), m_scrollableArea.horizontalScrollbar(), m_scrollableArea.verticalScrollbar());
+        m_kineticAnimation->clearScrollHistory();
+        m_kineticAnimation->start(m_currentPosition, event.swipeVelocity(), m_scrollableArea.horizontalScrollbar(), m_scrollableArea.verticalScrollbar());
         return true;
     }
 #endif
 
-    m_scrollHistory.append(event);
-
     return ScrollAnimator::handleWheelEvent(event);
 }
 
 void ScrollAnimatorGeneric::willEndLiveResize()
 {
-    m_kineticAnimation->updateVisibleLengths();
-
 #if ENABLE(SMOOTH_SCROLLING)
     if (m_smoothAnimation)
         m_smoothAnimation->updateVisibleLengths();
 #endif
 }
@@ -167,12 +143,10 @@
     notifyPositionChanged(delta);
 }
 
 void ScrollAnimatorGeneric::didAddVerticalScrollbar(Scrollbar* scrollbar)
 {
-    m_kineticAnimation->updateVisibleLengths();
-
 #if ENABLE(SMOOTH_SCROLLING)
     if (m_smoothAnimation)
         m_smoothAnimation->updateVisibleLengths();
 #endif
     if (!scrollbar->isOverlayScrollbar())
@@ -184,12 +158,10 @@
     hideOverlayScrollbars();
 }
 
 void ScrollAnimatorGeneric::didAddHorizontalScrollbar(Scrollbar* scrollbar)
 {
-    m_kineticAnimation->updateVisibleLengths();
-
 #if ENABLE(SMOOTH_SCROLLING)
     if (m_smoothAnimation)
         m_smoothAnimation->updateVisibleLengths();
 #endif
     if (!scrollbar->isOverlayScrollbar())
diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/generic/ScrollAnimatorGeneric.h b/modules/javafx.web/src/main/native/Source/WebCore/platform/generic/ScrollAnimatorGeneric.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/generic/ScrollAnimatorGeneric.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/generic/ScrollAnimatorGeneric.h
@@ -34,10 +34,11 @@
 #include "Timer.h"
 
 namespace WebCore {
 
 class ScrollAnimation;
+class ScrollAnimationKinetic;
 
 class ScrollAnimatorGeneric final : public ScrollAnimator {
 public:
     explicit ScrollAnimatorGeneric(ScrollableArea&);
     virtual ~ScrollAnimatorGeneric();
@@ -69,19 +70,16 @@
     void overlayScrollbarAnimationTimerFired();
     void showOverlayScrollbars();
     void hideOverlayScrollbars();
     void updateOverlayScrollbarsOpacity();
 
-    FloatPoint computeVelocity();
-
 #if ENABLE(SMOOTH_SCROLLING)
     void ensureSmoothScrollingAnimation();
 
     std::unique_ptr<ScrollAnimation> m_smoothAnimation;
 #endif
-    std::unique_ptr<ScrollAnimation> m_kineticAnimation;
-    Vector<PlatformWheelEvent> m_scrollHistory;
+    std::unique_ptr<ScrollAnimationKinetic> m_kineticAnimation;
     Scrollbar* m_horizontalOverlayScrollbar { nullptr };
     Scrollbar* m_verticalOverlayScrollbar { nullptr };
     bool m_overlayScrollbarsLocked { false };
     Timer m_overlayScrollbarAnimationTimer;
     double m_overlayScrollbarAnimationSource { 0 };
diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/PlatformDisplay.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/PlatformDisplay.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/PlatformDisplay.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/PlatformDisplay.cpp
@@ -88,16 +88,10 @@
             return PlatformDisplayWayland::create(gdk_wayland_display_get_wl_display(display));
 #endif
     }
 #endif // PLATFORM(GTK)
 
-#if USE(WPE_RENDERER)
-    return PlatformDisplayLibWPE::create();
-#elif PLATFORM(WIN)
-    return PlatformDisplayWin::create();
-#endif
-
 #if PLATFORM(WAYLAND)
     if (auto platformDisplay = PlatformDisplayWayland::create())
         return platformDisplay;
 #endif
 
@@ -111,10 +105,16 @@
     return PlatformDisplayWayland::create(nullptr);
 #elif PLATFORM(X11)
     return PlatformDisplayX11::create(nullptr);
 #endif
 
+#if USE(WPE_RENDERER)
+    return PlatformDisplayLibWPE::create();
+#elif PLATFORM(WIN)
+    return PlatformDisplayWin::create();
+#endif
+
     RELEASE_ASSERT_NOT_REACHED();
 }
 
 PlatformDisplay& PlatformDisplay::sharedDisplay()
 {
diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/PlatformMediaResourceLoader.h b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/PlatformMediaResourceLoader.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/PlatformMediaResourceLoader.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/PlatformMediaResourceLoader.h
@@ -52,11 +52,11 @@
     virtual void accessControlCheckFailed(PlatformMediaResource&, const ResourceError&) { }
     virtual void loadFailed(PlatformMediaResource&, const ResourceError&) { }
     virtual void loadFinished(PlatformMediaResource&) { }
 };
 
-class PlatformMediaResourceLoader : public ThreadSafeRefCounted<PlatformMediaResourceLoader> {
+class PlatformMediaResourceLoader : public ThreadSafeRefCounted<PlatformMediaResourceLoader, WTF::DestructionThread::Main> {
     WTF_MAKE_NONCOPYABLE(PlatformMediaResourceLoader); WTF_MAKE_FAST_ALLOCATED;
 public:
     enum LoadOption {
         BufferData = 1 << 0,
         DisallowCaching = 1 << 1,
@@ -69,11 +69,11 @@
 
 protected:
     PlatformMediaResourceLoader() = default;
 };
 
-class PlatformMediaResource : public ThreadSafeRefCounted<PlatformMediaResource> {
+class PlatformMediaResource : public ThreadSafeRefCounted<PlatformMediaResource, WTF::DestructionThread::Main> {
     WTF_MAKE_NONCOPYABLE(PlatformMediaResource); WTF_MAKE_FAST_ALLOCATED;
 public:
     PlatformMediaResource() = default;
     virtual ~PlatformMediaResource() = default;
     virtual void stop() { }
diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlock.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlock.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlock.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlock.cpp
@@ -35,10 +35,11 @@
 #include "FrameView.h"
 #include "GraphicsContext.h"
 #include "HTMLNames.h"
 #include "HitTestLocation.h"
 #include "HitTestResult.h"
+#include "ImageBuffer.h"
 #include "InlineElementBox.h"
 #include "InlineIterator.h"
 #include "InlineTextBox.h"
 #include "LayoutRepainter.h"
 #include "LogicalSelectionOffsetCaches.h"
diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.cpp
@@ -4412,11 +4412,11 @@
     return Path();
 }
 
 bool RenderLayer::setupClipPath(GraphicsContext& context, const LayerPaintingInfo& paintingInfo, const LayoutSize& offsetFromRoot, LayoutRect& rootRelativeBounds, bool& rootRelativeBoundsComputed)
 {
-    if (!renderer().hasClipPath() || context.paintingDisabled())
+    if (!renderer().hasClipPath() || context.paintingDisabled() || paintingInfo.paintDirtyRect.isEmpty())
         return false;
 
     if (!rootRelativeBoundsComputed) {
         rootRelativeBounds = calculateLayerBounds(paintingInfo.rootLayer, offsetFromRoot, { });
         rootRelativeBoundsComputed = true;
@@ -4440,17 +4440,16 @@
     if (style.clipPath()->type() == ClipPathOperation::Reference) {
         ReferenceClipPathOperation* referenceClipPathOperation = static_cast<ReferenceClipPathOperation*>(style.clipPath());
         Element* element = renderer().document().getElementById(referenceClipPathOperation->fragment());
         if (element && element->renderer() && is<RenderSVGResourceClipper>(element->renderer())) {
             context.save();
-            float deviceSaleFactor = renderer().document().deviceScaleFactor();
-            FloatRect referenceBox = snapRectToDevicePixels(computeReferenceBox(renderer(), CSSBoxType::ContentBox, paintingOffsetFromRoot, rootRelativeBounds), deviceSaleFactor);
-            FloatPoint offset {referenceBox.location()};
+            auto referenceBox = snapRectToDevicePixels(rootRelativeBounds, renderer().document().deviceScaleFactor());
+            auto offset = referenceBox.location();
             context.translate(offset);
-            FloatRect svgReferenceBox {FloatPoint(), referenceBox.size()};
-            downcast<RenderSVGResourceClipper>(*element->renderer()).applyClippingToContext(renderer(), svgReferenceBox, paintingInfo.paintDirtyRect, context);
-            context.translate(FloatPoint(-offset.x(), -offset.y()));
+            FloatRect svgReferenceBox { {}, referenceBox.size() };
+            downcast<RenderSVGResourceClipper>(*element->renderer()).applyClippingToContext(renderer(), svgReferenceBox, context);
+            context.translate(-offset);
             return true;
         }
     }
 
     return false;
@@ -6909,20 +6908,10 @@
 
     ensureLayerFilters();
     m_filters->buildFilter(renderer(), page().deviceScaleFactor(), renderer().settings().acceleratedFiltersEnabled() ? RenderingMode::Accelerated : RenderingMode::Unaccelerated);
 }
 
-void RenderLayer::filterNeedsRepaint()
-{
-    // We use the enclosing element so that we recalculate style for the ancestor of an anonymous object.
-    if (Element* element = enclosingElement()) {
-        // FIXME: This really shouldn't have to invalidate layer composition, but tests like css3/filters/effect-reference-delete.html fail if that doesn't happen.
-        element->invalidateStyleAndLayerComposition();
-    }
-    renderer().repaint();
-}
-
 IntOutsets RenderLayer::filterOutsets() const
 {
     if (m_filters)
         return m_filters->filter() ? m_filters->filter()->outsets() : IntOutsets();
     return renderer().style().filterOutsets();
diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.h b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.h
@@ -794,11 +794,10 @@
     FloatPoint perspectiveOrigin() const;
     bool preserves3D() const { return renderer().style().transformStyle3D() == TransformStyle3D::Preserve3D; }
     bool has3DTransform() const { return m_transform && !m_transform->isAffine(); }
     bool hasTransformedAncestor() const { return m_hasTransformedAncestor; }
 
-    void filterNeedsRepaint();
     bool hasFilter() const { return renderer().hasFilter(); }
     bool hasFilterOutsets() const { return !filterOutsets().isZero(); }
     IntOutsets filterOutsets() const;
     bool hasBackdropFilter() const
     {
diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerFilters.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerFilters.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerFilters.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerFilters.cpp
@@ -65,11 +65,15 @@
     return m_filter && m_filter->hasFilterThatShouldBeRestrictedBySecurityOrigin();
 }
 
 void RenderLayerFilters::notifyFinished(CachedResource&)
 {
-    m_layer.filterNeedsRepaint();
+    // FIXME: This really shouldn't have to invalidate layer composition,
+    // but tests like css3/filters/effect-reference-delete.html fail if that doesn't happen.
+    if (auto* enclosingElement = m_layer.enclosingElement())
+        enclosingElement->invalidateStyleAndLayerComposition();
+    m_layer.renderer().repaint();
 }
 
 void RenderLayerFilters::updateReferenceFilterClients(const FilterOperations& operations)
 {
     removeReferenceFilterClients();
diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGResourceClipper.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGResourceClipper.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGResourceClipper.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGResourceClipper.cpp
@@ -28,18 +28,20 @@
 #include "FrameView.h"
 #include "HitTestRequest.h"
 #include "HitTestResult.h"
 #include "IntRect.h"
 #include "RenderObject.h"
+#include "Logging.h"
 #include "RenderStyle.h"
 #include "RenderView.h"
 #include "SVGNames.h"
 #include "SVGRenderingContext.h"
 #include "SVGResources.h"
 #include "SVGResourcesCache.h"
 #include "SVGUseElement.h"
 #include <wtf/IsoMallocInlines.h>
+#include <wtf/text/TextStream.h>
 
 namespace WebCore {
 
 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderSVGResourceClipper);
 
@@ -50,11 +52,11 @@
 
 RenderSVGResourceClipper::~RenderSVGResourceClipper() = default;
 
 void RenderSVGResourceClipper::removeAllClientsFromCache(bool markForInvalidation)
 {
-    m_clipBoundaries = FloatRect();
+    m_clipBoundaries = { };
     m_clipper.clear();
 
     markAllClientsForInvalidation(markForInvalidation ? LayoutAndBoundariesInvalidation : ParentOnlyInvalidation);
 }
 
@@ -68,11 +70,15 @@
 bool RenderSVGResourceClipper::applyResource(RenderElement& renderer, const RenderStyle&, GraphicsContext*& context, OptionSet<RenderSVGResourceMode> resourceMode)
 {
     ASSERT(context);
     ASSERT_UNUSED(resourceMode, !resourceMode);
 
-    return applyClippingToContext(renderer, renderer.objectBoundingBox(), renderer.repaintRectInLocalCoordinates(), *context);
+    auto repaintRect = renderer.repaintRectInLocalCoordinates();
+    if (repaintRect.isEmpty())
+        return true;
+
+    return applyClippingToContext(renderer, renderer.objectBoundingBox(), *context);
 }
 
 bool RenderSVGResourceClipper::pathOnlyClipping(GraphicsContext& context, const AffineTransform& animatedLocalTransform, const FloatRect& objectBoundingBox)
 {
     // If the current clip-path gets clipped itself, we have to fallback to masking.
@@ -126,62 +132,62 @@
         clipPath.addRect(FloatRect());
     context.clipPath(clipPath, clipRule);
     return true;
 }
 
-bool RenderSVGResourceClipper::applyClippingToContext(RenderElement& renderer, const FloatRect& objectBoundingBox, const FloatRect& repaintRect, GraphicsContext& context)
+bool RenderSVGResourceClipper::applyClippingToContext(RenderElement& renderer, const FloatRect& objectBoundingBox, GraphicsContext& context)
 {
-    ClipperMaskImage& clipperMaskImage = addRendererToClipper(renderer);
-    bool shouldCreateClipperMaskImage = !clipperMaskImage;
+    ClipperData& clipperData = addRendererToClipper(renderer);
+
+    LOG_WITH_STREAM(SVG, stream << "RenderSVGResourceClipper " << this << " applyClippingToContext: renderer " << &renderer << " objectBoundingBox " << objectBoundingBox << " (existing image buffer " << clipperData.imageBuffer.get() << ")");
 
     AffineTransform animatedLocalTransform = clipPathElement().animatedLocalTransform();
 
-    if (shouldCreateClipperMaskImage && pathOnlyClipping(context, animatedLocalTransform, objectBoundingBox))
+    if (!clipperData.imageBuffer && pathOnlyClipping(context, animatedLocalTransform, objectBoundingBox))
         return true;
 
     AffineTransform absoluteTransform = SVGRenderingContext::calculateTransformationToOutermostCoordinateSystem(renderer);
-
-    if (shouldCreateClipperMaskImage && !repaintRect.isEmpty()) {
+    if (!clipperData.isValidForGeometry(objectBoundingBox, absoluteTransform)) {
         // FIXME (149469): This image buffer should not be unconditionally unaccelerated. Making it match the context breaks nested clipping, though.
-        clipperMaskImage = SVGRenderingContext::createImageBuffer(repaintRect, absoluteTransform, ColorSpace::SRGB, RenderingMode::Unaccelerated, &context);
-        if (!clipperMaskImage)
+        auto maskImage = SVGRenderingContext::createImageBuffer(objectBoundingBox, absoluteTransform, ColorSpace::SRGB, RenderingMode::Unaccelerated, &context);
+        if (!maskImage)
             return false;
 
-        GraphicsContext& maskContext = clipperMaskImage->context();
+        clipperData = { WTFMove(maskImage), objectBoundingBox, absoluteTransform };
+
+        GraphicsContext& maskContext = clipperData.imageBuffer->context();
         maskContext.concatCTM(animatedLocalTransform);
 
         // clipPath can also be clipped by another clipPath.
         auto* resources = SVGResourcesCache::cachedResourcesForRenderer(*this);
         RenderSVGResourceClipper* clipper;
         bool succeeded;
         if (resources && (clipper = resources->clipper())) {
             GraphicsContextStateSaver stateSaver(maskContext);
 
-            if (!clipper->applyClippingToContext(*this, objectBoundingBox, repaintRect, maskContext))
+            if (!clipper->applyClippingToContext(*this, objectBoundingBox, maskContext))
                 return false;
 
-            succeeded = drawContentIntoMaskImage(clipperMaskImage, objectBoundingBox);
+            succeeded = drawContentIntoMaskImage(*clipperData.imageBuffer, objectBoundingBox);
             // The context restore applies the clipping on non-CG platforms.
         } else
-            succeeded = drawContentIntoMaskImage(clipperMaskImage, objectBoundingBox);
+            succeeded = drawContentIntoMaskImage(*clipperData.imageBuffer, objectBoundingBox);
 
         if (!succeeded)
-            clipperMaskImage.reset();
+            clipperData = { };
     }
 
-    if (!clipperMaskImage)
+    if (!clipperData.imageBuffer)
         return false;
 
-    SVGRenderingContext::clipToImageBuffer(context, absoluteTransform, repaintRect, clipperMaskImage, shouldCreateClipperMaskImage);
+    SVGRenderingContext::clipToImageBuffer(context, absoluteTransform, objectBoundingBox, clipperData.imageBuffer, true);
     return true;
 }
 
-bool RenderSVGResourceClipper::drawContentIntoMaskImage(const ClipperMaskImage& clipperMaskImage, const FloatRect& objectBoundingBox)
+bool RenderSVGResourceClipper::drawContentIntoMaskImage(ImageBuffer& maskImageBuffer, const FloatRect& objectBoundingBox)
 {
-    ASSERT(clipperMaskImage);
-
-    GraphicsContext& maskContext = clipperMaskImage->context();
+    GraphicsContext& maskContext = maskImageBuffer.context();
 
     AffineTransform maskContentTransformation;
     if (clipPathElement().clipPathUnits() == SVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX) {
         maskContentTransformation.translate(objectBoundingBox.location());
         maskContentTransformation.scale(objectBoundingBox.size());
@@ -227,11 +233,11 @@
         maskContext.setFillRule(newClipRule);
 
         // In the case of a <use> element, we obtained its renderere above, to retrieve its clipRule.
         // We have to pass the <use> renderer itself to renderSubtreeToImageBuffer() to apply it's x/y/transform/etc. values when rendering.
         // So if isUseElement is true, refetch the childNode->renderer(), as renderer got overridden above.
-        SVGRenderingContext::renderSubtreeToImageBuffer(clipperMaskImage.get(), isUseElement ? *child.renderer() : *renderer, maskContentTransformation);
+        SVGRenderingContext::renderSubtreeToImageBuffer(&maskImageBuffer, isUseElement ? *child.renderer() : *renderer, maskContentTransformation);
     }
 
     view().frameView().setPaintBehavior(oldBehavior);
     return true;
 }
@@ -251,13 +257,13 @@
         m_clipBoundaries.unite(renderer->localToParentTransform().mapRect(renderer->repaintRectInLocalCoordinates()));
     }
     m_clipBoundaries = clipPathElement().animatedLocalTransform().mapRect(m_clipBoundaries);
 }
 
-ClipperMaskImage& RenderSVGResourceClipper::addRendererToClipper(const RenderObject& object)
+RenderSVGResourceClipper::ClipperData& RenderSVGResourceClipper::addRendererToClipper(const RenderObject& object)
 {
-    return m_clipper.add(&object, ClipperMaskImage()).iterator->value;
+    return m_clipper.add(&object, ClipperData()).iterator->value;
 }
 
 bool RenderSVGResourceClipper::hitTestClipContent(const FloatRect& objectBoundingBox, const FloatPoint& nodeAtPoint)
 {
     FloatPoint point = nodeAtPoint;
@@ -300,11 +306,11 @@
 
 FloatRect RenderSVGResourceClipper::resourceBoundingBox(const RenderObject& object)
 {
     // Resource was not layouted yet. Give back the boundingBox of the object.
     if (selfNeedsLayout()) {
-        addRendererToClipper(object);
+        addRendererToClipper(object); // For selfNeedsClientInvalidation().
         return object.objectBoundingBox();
     }
 
     if (m_clipBoundaries.isEmpty())
         calculateClipContentRepaintRect();
diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGResourceClipper.h b/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGResourceClipper.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGResourceClipper.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGResourceClipper.h
@@ -28,12 +28,10 @@
 namespace WebCore {
 
 class GraphicsContext;
 class ImageBuffer;
 
-typedef std::unique_ptr<ImageBuffer> ClipperMaskImage;
-
 class RenderSVGResourceClipper final : public RenderSVGResourceContainer {
     WTF_MAKE_ISO_ALLOCATED(RenderSVGResourceClipper);
 public:
     RenderSVGResourceClipper(SVGClipPathElement&, RenderStyle&&);
     virtual ~RenderSVGResourceClipper();
@@ -45,11 +43,11 @@
 
     bool applyResource(RenderElement&, const RenderStyle&, GraphicsContext*&, OptionSet<RenderSVGResourceMode>) override;
     // clipPath can be clipped too, but don't have a boundingBox or repaintRect. So we can't call
     // applyResource directly and use the rects from the object, since they are empty for RenderSVGResources
     // FIXME: We made applyClippingToContext public because we cannot call applyResource on HTML elements (it asserts on RenderObject::objectBoundingBox)
-    bool applyClippingToContext(RenderElement&, const FloatRect&, const FloatRect&, GraphicsContext&);
+    bool applyClippingToContext(RenderElement&, const FloatRect&, GraphicsContext&);
     FloatRect resourceBoundingBox(const RenderObject&) override;
 
     RenderSVGResourceType resourceType() const override { return ClipperResourceType; }
 
     bool hitTestClipContent(const FloatRect&, const FloatPoint&);
@@ -58,22 +56,41 @@
 
 protected:
     bool selfNeedsClientInvalidation() const override { return (everHadLayout() || m_clipper.size()) && selfNeedsLayout(); }
 
 private:
+    struct ClipperData {
+        FloatRect objectBoundingBox;
+        AffineTransform absoluteTransform;
+        std::unique_ptr<ImageBuffer> imageBuffer;
+
+        ClipperData() = default;
+        ClipperData(std::unique_ptr<ImageBuffer>&& buffer, const FloatRect& boundingBox, const AffineTransform& transform)
+            : objectBoundingBox(boundingBox)
+            , absoluteTransform(transform)
+            , imageBuffer(WTFMove(buffer))
+        {
+        }
+
+        bool isValidForGeometry(const FloatRect& boundingBox, const AffineTransform& transform) const
+        {
+            return imageBuffer && objectBoundingBox == boundingBox && absoluteTransform == transform;
+        }
+    };
+
     void element() const = delete;
 
     const char* renderName() const override { return "RenderSVGResourceClipper"; }
     bool isSVGResourceClipper() const override { return true; }
 
     bool pathOnlyClipping(GraphicsContext&, const AffineTransform&, const FloatRect&);
-    bool drawContentIntoMaskImage(const ClipperMaskImage&, const FloatRect& objectBoundingBox);
+    bool drawContentIntoMaskImage(ImageBuffer&, const FloatRect& objectBoundingBox);
     void calculateClipContentRepaintRect();
-    ClipperMaskImage& addRendererToClipper(const RenderObject&);
+    ClipperData& addRendererToClipper(const RenderObject&);
 
     FloatRect m_clipBoundaries;
-    HashMap<const RenderObject*, ClipperMaskImage> m_clipper;
+    HashMap<const RenderObject*, ClipperData> m_clipper;
 };
 
 }
 
 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::RenderSVGResourceClipper)
diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGResourceContainer.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGResourceContainer.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGResourceContainer.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGResourceContainer.cpp
@@ -24,10 +24,11 @@
 #include "RenderSVGRoot.h"
 #include "RenderView.h"
 #include "SVGRenderingContext.h"
 #include "SVGResourcesCache.h"
 #include <wtf/IsoMallocInlines.h>
+#include <wtf/SetForScope.h>
 #include <wtf/StackStats.h>
 
 namespace WebCore {
 
 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderSVGResourceContainer);
@@ -89,14 +90,17 @@
     registerResource();
 }
 
 void RenderSVGResourceContainer::markAllClientsForInvalidation(InvalidationMode mode)
 {
+    // FIXME: Style invalidation should either be a pre-layout task or this function
+    // should never get called while in layout. See webkit.org/b/208903.
     if ((m_clients.isEmpty() && m_clientLayers.isEmpty()) || m_isInvalidating)
         return;
 
-    m_isInvalidating = true;
+    SetForScope<bool> isInvalidating(m_isInvalidating, true);
+
     bool needsLayout = mode == LayoutAndBoundariesInvalidation;
     bool markForInvalidation = mode != ParentOnlyInvalidation;
     auto* root = SVGRenderSupport::findTreeRootObject(*this);
 
     for (auto* client : m_clients) {
@@ -114,22 +118,33 @@
 
         RenderSVGResource::markForLayoutAndParentResourceInvalidation(*client, needsLayout);
     }
 
     markAllClientLayersForInvalidation();
-
-    m_isInvalidating = false;
 }
 
 void RenderSVGResourceContainer::markAllClientLayersForInvalidation()
 {
     if (m_clientLayers.isEmpty())
         return;
-    if ((*m_clientLayers.begin())->renderer().renderTreeBeingDestroyed())
+
+    auto& document = (*m_clientLayers.begin())->renderer().document();
+    if (!document.view() || document.renderTreeBeingDestroyed())
         return;
-    for (auto* clientLayer : m_clientLayers)
-        clientLayer->filterNeedsRepaint();
+
+    auto inLayout = document.view()->layoutContext().isInLayout();
+    for (auto* clientLayer : m_clientLayers) {
+        // FIXME: We should not get here while in layout. See webkit.org/b/208903.
+        // Repaint should also be triggered through some other means.
+        if (inLayout) {
+            clientLayer->renderer().repaint();
+            continue;
+        }
+        if (auto* enclosingElement = clientLayer->enclosingElement())
+            enclosingElement->invalidateStyleAndLayerComposition();
+        clientLayer->renderer().repaint();
+    }
 }
 
 void RenderSVGResourceContainer::markClientForInvalidation(RenderObject& client, InvalidationMode mode)
 {
     ASSERT(!m_clients.isEmpty());
diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderFirstLetter.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderFirstLetter.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderFirstLetter.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderFirstLetter.cpp
@@ -249,11 +249,11 @@
             if (isPunctuationForFirstLetter(c))
                 length = scanLength + numCodeUnits;
         }
 
         auto* textNode = currentTextChild.textNode();
-        auto* beforeChild = currentTextChild.nextSibling();
+        auto beforeChild = makeWeakPtr(currentTextChild.nextSibling());
         auto inlineWrapperForDisplayContents = makeWeakPtr(currentTextChild.inlineWrapperForDisplayContents());
         auto hasInlineWrapperForDisplayContents = inlineWrapperForDisplayContents.get();
         m_builder.destroy(currentTextChild);
 
         // Construct a text fragment for the text after the first letter.
@@ -266,11 +266,11 @@
             newRemainingText = createRenderer<RenderTextFragment>(firstLetterBlock.document(), oldText, length, oldText.length() - length);
 
         RenderTextFragment& remainingText = *newRemainingText;
         ASSERT_UNUSED(hasInlineWrapperForDisplayContents, hasInlineWrapperForDisplayContents == inlineWrapperForDisplayContents.get());
         remainingText.setInlineWrapperForDisplayContents(inlineWrapperForDisplayContents.get());
-        m_builder.attach(*textContentParent, WTFMove(newRemainingText), beforeChild);
+        m_builder.attach(*textContentParent, WTFMove(newRemainingText), beforeChild.get());
 
         // FIXME: Make attach the final step so that we don't need to keep firstLetter around.
         auto& firstLetter = *newFirstLetter;
         remainingText.setFirstLetter(firstLetter);
         firstLetter.setFirstLetterRemainingText(remainingText);
diff a/modules/javafx.web/src/main/native/Source/WebCore/svg/SVGClipPathElement.cpp b/modules/javafx.web/src/main/native/Source/WebCore/svg/SVGClipPathElement.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/svg/SVGClipPathElement.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/svg/SVGClipPathElement.cpp
@@ -22,10 +22,11 @@
 
 #include "config.h"
 #include "SVGClipPathElement.h"
 
 #include "Document.h"
+#include "ImageBuffer.h"
 #include "RenderSVGResourceClipper.h"
 #include "SVGNames.h"
 #include "StyleResolver.h"
 #include <wtf/IsoMallocInlines.h>
 #include <wtf/NeverDestroyed.h>
diff a/modules/javafx.web/src/main/native/Source/WebCore/svg/SVGTransform.h b/modules/javafx.web/src/main/native/Source/WebCore/svg/SVGTransform.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/svg/SVGTransform.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/svg/SVGTransform.h
@@ -142,10 +142,24 @@
         m_value.setSkewY(angle);
         commitChange();
         return { };
     }
 
+    void attach(SVGPropertyOwner* owner, SVGPropertyAccess access) override
+    {
+        Base::attach(owner, access);
+        // Reattach the SVGMatrix to the SVGTransformValue with the new SVGPropertyAccess.
+        m_value.matrix()->reattach(this, access);
+    }
+
+    void detach() override
+    {
+        Base::detach();
+        // Reattach the SVGMatrix to the SVGTransformValue with the SVGPropertyAccess::ReadWrite.
+        m_value.matrix()->reattach(this, access());
+    }
+
 private:
     using Base = SVGValueProperty<SVGTransformValue>;
 
     SVGTransform(SVGTransformValue::SVGTransformType type, const AffineTransform& transform = { }, float angle = 0, const FloatPoint& rotationCenter = { })
         : Base(SVGTransformValue(type, SVGMatrix::create(this, SVGPropertyAccess::ReadWrite, transform), angle, rotationCenter))
diff a/modules/javafx.web/src/main/native/Source/WebCore/svg/properties/SVGProperty.h b/modules/javafx.web/src/main/native/Source/WebCore/svg/properties/SVGProperty.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/svg/properties/SVGProperty.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/svg/properties/SVGProperty.h
@@ -34,25 +34,32 @@
 public:
     virtual ~SVGProperty() = default;
 
     // Managing the relationship with the owner.
     bool isAttached() const { return m_owner; }
-    void attach(SVGPropertyOwner* owner, SVGPropertyAccess access)
+    virtual void attach(SVGPropertyOwner* owner, SVGPropertyAccess access)
     {
         ASSERT(!m_owner);
         ASSERT(m_state == SVGPropertyState::Clean);
         m_owner = owner;
         m_access = access;
     }
 
-    void detach()
+    virtual void detach()
     {
         m_owner = nullptr;
         m_access = SVGPropertyAccess::ReadWrite;
         m_state = SVGPropertyState::Clean;
     }
 
+    void reattach(SVGPropertyOwner* owner, SVGPropertyAccess access)
+    {
+        ASSERT_UNUSED(owner, owner == m_owner);
+        m_access = access;
+        m_state = SVGPropertyState::Clean;
+    }
+
     const SVGElement* contextElement() const
     {
         if (!m_owner)
             return nullptr;
         return m_owner->attributeContextElement();
diff a/modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/ServiceWorkerFetch.cpp b/modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/ServiceWorkerFetch.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/ServiceWorkerFetch.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/ServiceWorkerFetch.cpp
@@ -37,10 +37,11 @@
 #include "ReadableStreamChunk.h"
 #include "ResourceRequest.h"
 #include "ServiceWorker.h"
 #include "ServiceWorkerClientIdentifier.h"
 #include "ServiceWorkerGlobalScope.h"
+#include "ServiceWorkerThread.h"
 #include "WorkerGlobalScope.h"
 
 namespace WebCore {
 
 namespace ServiceWorkerFetch {
diff a/modules/javafx.web/src/main/native/Source/WebCore/xml/parser/XMLDocumentParserLibxml2.cpp b/modules/javafx.web/src/main/native/Source/WebCore/xml/parser/XMLDocumentParserLibxml2.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/xml/parser/XMLDocumentParserLibxml2.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/xml/parser/XMLDocumentParserLibxml2.cpp
@@ -37,11 +37,15 @@
 #include "Frame.h"
 #include "FrameLoader.h"
 #include "HTMLEntityParser.h"
 #include "HTMLHtmlElement.h"
 #include "HTMLTemplateElement.h"
+#include "HTTPParsers.h"
 #include "InlineClassicScript.h"
+#include "MIMETypeRegistry.h"
+#include "Page.h"
+#include "PageConsoleClient.h"
 #include "PendingScript.h"
 #include "ProcessingInstruction.h"
 #include "ResourceError.h"
 #include "ResourceResponse.h"
 #include "SVGElement.h"
@@ -373,10 +377,23 @@
 private:
     Vector<char> m_buffer;
     unsigned m_currentOffset;
 };
 
+static bool externalEntityMimeTypeAllowedByNosniff(const ResourceResponse& response)
+{
+    ContentTypeOptionsDisposition contentTypeOption = parseContentTypeOptionsHeader(response.httpHeaderField(HTTPHeaderName::XContentTypeOptions));
+    if (contentTypeOption != ContentTypeOptionsNosniff) {
+        // Allow any MIME type without 'X-Content-Type-Options: nosniff' HTTP header.
+        return true;
+    }
+    String mimeType = extractMIMETypeFromMediaType(response.httpHeaderField(HTTPHeaderName::ContentType));
+    if (MIMETypeRegistry::isXMLMIMEType(mimeType) || MIMETypeRegistry::isXMLEntityMIMEType(mimeType))
+        return true;
+    return false;
+}
+
 static inline void setAttributes(Element* element, Vector<Attribute>& attributeVector, ParserContentPolicy parserContentPolicy)
 {
     if (!scriptingContentIsAllowed(parserContentPolicy))
         element->stripScriptingAttributes(attributeVector);
     element->parserSetAttributes(attributeVector);
@@ -453,10 +470,15 @@
         if (cachedResourceLoader->frame()) {
             FetchOptions options;
             options.mode = FetchOptions::Mode::SameOrigin;
             options.credentials = FetchOptions::Credentials::Include;
             cachedResourceLoader->frame()->loader().loadResourceSynchronously(url, ClientCredentialPolicy::MayAskClientForCredentials, options, { }, error, response, data);
+            if (!externalEntityMimeTypeAllowedByNosniff(response)) {
+                data = nullptr;
+                if (Page* page = cachedResourceLoader->document()->page())
+                    page->console().addMessage(MessageSource::Security, MessageLevel::Error, makeString("Did not parse external entity resource at '", url.stringCenterEllipsizedToLength(), "' because non XML External Entity MIME types are not allowed when 'X-Content-Type-Options: nosniff' is given."));
+            }
         }
     }
 
     // We have to check the URL again after the load to catch redirects.
     // See <https://bugs.webkit.org/show_bug.cgi?id=21963>.

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/DataMutex.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Igalia, S.L.
  3  * Copyright (C) 2019 Metrological Group B.V.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * aint with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  */
 20 
 21 #pragma once
 22 
 23 #include &lt;wtf/Lock.h&gt;
 24 #include &lt;wtf/Threading.h&gt;
 25 
 26 namespace WTF {
 27 
 28 // By default invalid access checks are only done in Debug builds.
 29 #if !defined(ENABLE_DATA_MUTEX_CHECKS)
 30 #if defined(NDEBUG)
 31 #define ENABLE_DATA_MUTEX_CHECKS 0
 32 #else
 33 #define ENABLE_DATA_MUTEX_CHECKS 1
 34 #endif
 35 #endif
 36 
 37 #if ENABLE_DATA_MUTEX_CHECKS
 38 #define DATA_MUTEX_CHECK(expr) RELEASE_ASSERT(expr)
 39 #else
 40 #define DATA_MUTEX_CHECK(expr)
 41 #endif
 42 
 43 template&lt;typename LockType&gt;
 44 class OwnerAwareLockAdapter {
 45 public:
 46     void lock()
 47     {
 48         DATA_MUTEX_CHECK(m_owner != &amp;Thread::current()); // Thread attempted recursive lock (unsupported).
 49         m_lock.lock();
 50 #if ENABLE_DATA_MUTEX_CHECKS
 51         ASSERT(!m_owner);
 52         m_owner = &amp;Thread::current();
 53 #endif
 54     }
 55 
 56     void unlock()
 57     {
 58 #if ENABLE_DATA_MUTEX_CHECKS
 59         m_owner = nullptr;
 60 #endif
 61         m_lock.unlock();
 62     }
 63 
 64     bool tryLock()
 65     {
 66         DATA_MUTEX_CHECK(m_owner != &amp;Thread::current()); // Thread attempted recursive lock (unsupported).
 67         if (!m_lock.tryLock())
 68             return false;
 69 
 70 #if ENABLE_DATA_MUTEX_CHECKS
 71         ASSERT(!m_owner);
 72         m_owner = &amp;Thread::current();
 73 #endif
 74         return true;
 75     }
 76 
 77     bool isLocked() const
 78     {
 79         return m_lock.isLocked();
 80     }
 81 
 82 private:
 83 #if ENABLE_DATA_MUTEX_CHECKS
 84     Thread* m_owner { nullptr }; // Use Thread* instead of RefPtr&lt;Thread&gt; since m_owner thread is always alive while m_owner is set.
 85 #endif
 86     LockType m_lock;
 87 };
 88 
 89 using OwnerAwareLock = OwnerAwareLockAdapter&lt;Lock&gt;;
 90 
 91 template&lt;typename T, typename LockType = OwnerAwareLock&gt;
 92 class DataMutex {
 93     WTF_MAKE_FAST_ALLOCATED;
 94     WTF_MAKE_NONCOPYABLE(DataMutex);
 95 public:
 96     template&lt;typename ...Args&gt;
 97     explicit DataMutex(Args&amp;&amp;... args)
 98         : m_data(std::forward&lt;Args&gt;(args)...)
 99     { }
100 
101     class LockedWrapper {
102     public:
103         explicit LockedWrapper(DataMutex&amp; dataMutex)
104             : m_mutex(dataMutex.m_mutex)
105             , m_lockHolder(dataMutex.m_mutex)
106             , m_data(dataMutex.m_data)
107         { }
108 
109         T* operator-&gt;()
110         {
111             DATA_MUTEX_CHECK(m_mutex.isLocked());
112             return &amp;m_data;
113         }
114 
115         T&amp; operator*()
116         {
117             DATA_MUTEX_CHECK(m_mutex.isLocked());
118             return m_data;
119         }
120 
121         LockType&amp; mutex()
122         {
123             return m_mutex;
124         }
125 
126         Locker&lt;LockType&gt;&amp; lockHolder()
127         {
128             return m_lockHolder;
129         }
130 
131         // Used to avoid excessive brace scoping when only small parts of the code need to be run unlocked.
132         // Please be mindful that accessing the wrapped data from the callback is unsafe and will fail on assertions.
133         // It&#39;s helpful to use a minimal lambda capture to be conscious of what data you&#39;re having access to in these sections.
134         void runUnlocked(WTF::Function&lt;void()&gt; callback)
135         {
136             m_mutex.unlock();
137             callback();
138             m_mutex.lock();
139         }
140 
141     private:
142         LockType&amp; m_mutex;
143         Locker&lt;LockType&gt; m_lockHolder;
144         T&amp; m_data;
145     };
146 
147 private:
148     LockType m_mutex;
149     T m_data;
150 };
151 
152 } // namespace WTF
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGResourceClipper.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../RenderLayerFilters.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderSVGResourceClipper.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGResourceClipper.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,18 ***</span>
<span class="line-new-header">--- 28,20 ---</span>
  #include &quot;FrameView.h&quot;
  #include &quot;HitTestRequest.h&quot;
  #include &quot;HitTestResult.h&quot;
  #include &quot;IntRect.h&quot;
  #include &quot;RenderObject.h&quot;
<span class="line-added">+ #include &quot;Logging.h&quot;</span>
  #include &quot;RenderStyle.h&quot;
  #include &quot;RenderView.h&quot;
  #include &quot;SVGNames.h&quot;
  #include &quot;SVGRenderingContext.h&quot;
  #include &quot;SVGResources.h&quot;
  #include &quot;SVGResourcesCache.h&quot;
  #include &quot;SVGUseElement.h&quot;
  #include &lt;wtf/IsoMallocInlines.h&gt;
<span class="line-added">+ #include &lt;wtf/text/TextStream.h&gt;</span>
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(RenderSVGResourceClipper);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 50,11 ***</span>
  
  RenderSVGResourceClipper::~RenderSVGResourceClipper() = default;
  
  void RenderSVGResourceClipper::removeAllClientsFromCache(bool markForInvalidation)
  {
<span class="line-modified">!     m_clipBoundaries = FloatRect();</span>
      m_clipper.clear();
  
      markAllClientsForInvalidation(markForInvalidation ? LayoutAndBoundariesInvalidation : ParentOnlyInvalidation);
  }
  
<span class="line-new-header">--- 52,11 ---</span>
  
  RenderSVGResourceClipper::~RenderSVGResourceClipper() = default;
  
  void RenderSVGResourceClipper::removeAllClientsFromCache(bool markForInvalidation)
  {
<span class="line-modified">!     m_clipBoundaries = { };</span>
      m_clipper.clear();
  
      markAllClientsForInvalidation(markForInvalidation ? LayoutAndBoundariesInvalidation : ParentOnlyInvalidation);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 68,11 ***</span>
  bool RenderSVGResourceClipper::applyResource(RenderElement&amp; renderer, const RenderStyle&amp;, GraphicsContext*&amp; context, OptionSet&lt;RenderSVGResourceMode&gt; resourceMode)
  {
      ASSERT(context);
      ASSERT_UNUSED(resourceMode, !resourceMode);
  
<span class="line-modified">!     return applyClippingToContext(renderer, renderer.objectBoundingBox(), renderer.repaintRectInLocalCoordinates(), *context);</span>
  }
  
  bool RenderSVGResourceClipper::pathOnlyClipping(GraphicsContext&amp; context, const AffineTransform&amp; animatedLocalTransform, const FloatRect&amp; objectBoundingBox)
  {
      // If the current clip-path gets clipped itself, we have to fallback to masking.
<span class="line-new-header">--- 70,15 ---</span>
  bool RenderSVGResourceClipper::applyResource(RenderElement&amp; renderer, const RenderStyle&amp;, GraphicsContext*&amp; context, OptionSet&lt;RenderSVGResourceMode&gt; resourceMode)
  {
      ASSERT(context);
      ASSERT_UNUSED(resourceMode, !resourceMode);
  
<span class="line-modified">!     auto repaintRect = renderer.repaintRectInLocalCoordinates();</span>
<span class="line-added">+     if (repaintRect.isEmpty())</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return applyClippingToContext(renderer, renderer.objectBoundingBox(), *context);</span>
  }
  
  bool RenderSVGResourceClipper::pathOnlyClipping(GraphicsContext&amp; context, const AffineTransform&amp; animatedLocalTransform, const FloatRect&amp; objectBoundingBox)
  {
      // If the current clip-path gets clipped itself, we have to fallback to masking.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 126,62 ***</span>
          clipPath.addRect(FloatRect());
      context.clipPath(clipPath, clipRule);
      return true;
  }
  
<span class="line-modified">! bool RenderSVGResourceClipper::applyClippingToContext(RenderElement&amp; renderer, const FloatRect&amp; objectBoundingBox, const FloatRect&amp; repaintRect, GraphicsContext&amp; context)</span>
  {
<span class="line-modified">!     ClipperMaskImage&amp; clipperMaskImage = addRendererToClipper(renderer);</span>
<span class="line-modified">!     bool shouldCreateClipperMaskImage = !clipperMaskImage;</span>
  
      AffineTransform animatedLocalTransform = clipPathElement().animatedLocalTransform();
  
<span class="line-modified">!     if (shouldCreateClipperMaskImage &amp;&amp; pathOnlyClipping(context, animatedLocalTransform, objectBoundingBox))</span>
          return true;
  
      AffineTransform absoluteTransform = SVGRenderingContext::calculateTransformationToOutermostCoordinateSystem(renderer);
<span class="line-modified">! </span>
<span class="line-removed">-     if (shouldCreateClipperMaskImage &amp;&amp; !repaintRect.isEmpty()) {</span>
          // FIXME (149469): This image buffer should not be unconditionally unaccelerated. Making it match the context breaks nested clipping, though.
<span class="line-modified">!         clipperMaskImage = SVGRenderingContext::createImageBuffer(repaintRect, absoluteTransform, ColorSpace::SRGB, RenderingMode::Unaccelerated, &amp;context);</span>
<span class="line-modified">!         if (!clipperMaskImage)</span>
              return false;
  
<span class="line-modified">!         GraphicsContext&amp; maskContext = clipperMaskImage-&gt;context();</span>
          maskContext.concatCTM(animatedLocalTransform);
  
          // clipPath can also be clipped by another clipPath.
          auto* resources = SVGResourcesCache::cachedResourcesForRenderer(*this);
          RenderSVGResourceClipper* clipper;
          bool succeeded;
          if (resources &amp;&amp; (clipper = resources-&gt;clipper())) {
              GraphicsContextStateSaver stateSaver(maskContext);
  
<span class="line-modified">!             if (!clipper-&gt;applyClippingToContext(*this, objectBoundingBox, repaintRect, maskContext))</span>
                  return false;
  
<span class="line-modified">!             succeeded = drawContentIntoMaskImage(clipperMaskImage, objectBoundingBox);</span>
              // The context restore applies the clipping on non-CG platforms.
          } else
<span class="line-modified">!             succeeded = drawContentIntoMaskImage(clipperMaskImage, objectBoundingBox);</span>
  
          if (!succeeded)
<span class="line-modified">!             clipperMaskImage.reset();</span>
      }
  
<span class="line-modified">!     if (!clipperMaskImage)</span>
          return false;
  
<span class="line-modified">!     SVGRenderingContext::clipToImageBuffer(context, absoluteTransform, repaintRect, clipperMaskImage, shouldCreateClipperMaskImage);</span>
      return true;
  }
  
<span class="line-modified">! bool RenderSVGResourceClipper::drawContentIntoMaskImage(const ClipperMaskImage&amp; clipperMaskImage, const FloatRect&amp; objectBoundingBox)</span>
  {
<span class="line-modified">!     ASSERT(clipperMaskImage);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     GraphicsContext&amp; maskContext = clipperMaskImage-&gt;context();</span>
  
      AffineTransform maskContentTransformation;
      if (clipPathElement().clipPathUnits() == SVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX) {
          maskContentTransformation.translate(objectBoundingBox.location());
          maskContentTransformation.scale(objectBoundingBox.size());
<span class="line-new-header">--- 132,62 ---</span>
          clipPath.addRect(FloatRect());
      context.clipPath(clipPath, clipRule);
      return true;
  }
  
<span class="line-modified">! bool RenderSVGResourceClipper::applyClippingToContext(RenderElement&amp; renderer, const FloatRect&amp; objectBoundingBox, GraphicsContext&amp; context)</span>
  {
<span class="line-modified">!     ClipperData&amp; clipperData = addRendererToClipper(renderer);</span>
<span class="line-modified">! </span>
<span class="line-added">+     LOG_WITH_STREAM(SVG, stream &lt;&lt; &quot;RenderSVGResourceClipper &quot; &lt;&lt; this &lt;&lt; &quot; applyClippingToContext: renderer &quot; &lt;&lt; &amp;renderer &lt;&lt; &quot; objectBoundingBox &quot; &lt;&lt; objectBoundingBox &lt;&lt; &quot; (existing image buffer &quot; &lt;&lt; clipperData.imageBuffer.get() &lt;&lt; &quot;)&quot;);</span>
  
      AffineTransform animatedLocalTransform = clipPathElement().animatedLocalTransform();
  
<span class="line-modified">!     if (!clipperData.imageBuffer &amp;&amp; pathOnlyClipping(context, animatedLocalTransform, objectBoundingBox))</span>
          return true;
  
      AffineTransform absoluteTransform = SVGRenderingContext::calculateTransformationToOutermostCoordinateSystem(renderer);
<span class="line-modified">!     if (!clipperData.isValidForGeometry(objectBoundingBox, absoluteTransform)) {</span>
          // FIXME (149469): This image buffer should not be unconditionally unaccelerated. Making it match the context breaks nested clipping, though.
<span class="line-modified">!         auto maskImage = SVGRenderingContext::createImageBuffer(objectBoundingBox, absoluteTransform, ColorSpace::SRGB, RenderingMode::Unaccelerated, &amp;context);</span>
<span class="line-modified">!         if (!maskImage)</span>
              return false;
  
<span class="line-modified">!         clipperData = { WTFMove(maskImage), objectBoundingBox, absoluteTransform };</span>
<span class="line-added">+ </span>
<span class="line-added">+         GraphicsContext&amp; maskContext = clipperData.imageBuffer-&gt;context();</span>
          maskContext.concatCTM(animatedLocalTransform);
  
          // clipPath can also be clipped by another clipPath.
          auto* resources = SVGResourcesCache::cachedResourcesForRenderer(*this);
          RenderSVGResourceClipper* clipper;
          bool succeeded;
          if (resources &amp;&amp; (clipper = resources-&gt;clipper())) {
              GraphicsContextStateSaver stateSaver(maskContext);
  
<span class="line-modified">!             if (!clipper-&gt;applyClippingToContext(*this, objectBoundingBox, maskContext))</span>
                  return false;
  
<span class="line-modified">!             succeeded = drawContentIntoMaskImage(*clipperData.imageBuffer, objectBoundingBox);</span>
              // The context restore applies the clipping on non-CG platforms.
          } else
<span class="line-modified">!             succeeded = drawContentIntoMaskImage(*clipperData.imageBuffer, objectBoundingBox);</span>
  
          if (!succeeded)
<span class="line-modified">!             clipperData = { };</span>
      }
  
<span class="line-modified">!     if (!clipperData.imageBuffer)</span>
          return false;
  
<span class="line-modified">!     SVGRenderingContext::clipToImageBuffer(context, absoluteTransform, objectBoundingBox, clipperData.imageBuffer, true);</span>
      return true;
  }
  
<span class="line-modified">! bool RenderSVGResourceClipper::drawContentIntoMaskImage(ImageBuffer&amp; maskImageBuffer, const FloatRect&amp; objectBoundingBox)</span>
  {
<span class="line-modified">!     GraphicsContext&amp; maskContext = maskImageBuffer.context();</span>
  
      AffineTransform maskContentTransformation;
      if (clipPathElement().clipPathUnits() == SVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX) {
          maskContentTransformation.translate(objectBoundingBox.location());
          maskContentTransformation.scale(objectBoundingBox.size());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 227,11 ***</span>
          maskContext.setFillRule(newClipRule);
  
          // In the case of a &lt;use&gt; element, we obtained its renderere above, to retrieve its clipRule.
          // We have to pass the &lt;use&gt; renderer itself to renderSubtreeToImageBuffer() to apply it&#39;s x/y/transform/etc. values when rendering.
          // So if isUseElement is true, refetch the childNode-&gt;renderer(), as renderer got overridden above.
<span class="line-modified">!         SVGRenderingContext::renderSubtreeToImageBuffer(clipperMaskImage.get(), isUseElement ? *child.renderer() : *renderer, maskContentTransformation);</span>
      }
  
      view().frameView().setPaintBehavior(oldBehavior);
      return true;
  }
<span class="line-new-header">--- 233,11 ---</span>
          maskContext.setFillRule(newClipRule);
  
          // In the case of a &lt;use&gt; element, we obtained its renderere above, to retrieve its clipRule.
          // We have to pass the &lt;use&gt; renderer itself to renderSubtreeToImageBuffer() to apply it&#39;s x/y/transform/etc. values when rendering.
          // So if isUseElement is true, refetch the childNode-&gt;renderer(), as renderer got overridden above.
<span class="line-modified">!         SVGRenderingContext::renderSubtreeToImageBuffer(&amp;maskImageBuffer, isUseElement ? *child.renderer() : *renderer, maskContentTransformation);</span>
      }
  
      view().frameView().setPaintBehavior(oldBehavior);
      return true;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 251,13 ***</span>
          m_clipBoundaries.unite(renderer-&gt;localToParentTransform().mapRect(renderer-&gt;repaintRectInLocalCoordinates()));
      }
      m_clipBoundaries = clipPathElement().animatedLocalTransform().mapRect(m_clipBoundaries);
  }
  
<span class="line-modified">! ClipperMaskImage&amp; RenderSVGResourceClipper::addRendererToClipper(const RenderObject&amp; object)</span>
  {
<span class="line-modified">!     return m_clipper.add(&amp;object, ClipperMaskImage()).iterator-&gt;value;</span>
  }
  
  bool RenderSVGResourceClipper::hitTestClipContent(const FloatRect&amp; objectBoundingBox, const FloatPoint&amp; nodeAtPoint)
  {
      FloatPoint point = nodeAtPoint;
<span class="line-new-header">--- 257,13 ---</span>
          m_clipBoundaries.unite(renderer-&gt;localToParentTransform().mapRect(renderer-&gt;repaintRectInLocalCoordinates()));
      }
      m_clipBoundaries = clipPathElement().animatedLocalTransform().mapRect(m_clipBoundaries);
  }
  
<span class="line-modified">! RenderSVGResourceClipper::ClipperData&amp; RenderSVGResourceClipper::addRendererToClipper(const RenderObject&amp; object)</span>
  {
<span class="line-modified">!     return m_clipper.add(&amp;object, ClipperData()).iterator-&gt;value;</span>
  }
  
  bool RenderSVGResourceClipper::hitTestClipContent(const FloatRect&amp; objectBoundingBox, const FloatPoint&amp; nodeAtPoint)
  {
      FloatPoint point = nodeAtPoint;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 300,11 ***</span>
  
  FloatRect RenderSVGResourceClipper::resourceBoundingBox(const RenderObject&amp; object)
  {
      // Resource was not layouted yet. Give back the boundingBox of the object.
      if (selfNeedsLayout()) {
<span class="line-modified">!         addRendererToClipper(object);</span>
          return object.objectBoundingBox();
      }
  
      if (m_clipBoundaries.isEmpty())
          calculateClipContentRepaintRect();
<span class="line-new-header">--- 306,11 ---</span>
  
  FloatRect RenderSVGResourceClipper::resourceBoundingBox(const RenderObject&amp; object)
  {
      // Resource was not layouted yet. Give back the boundingBox of the object.
      if (selfNeedsLayout()) {
<span class="line-modified">!         addRendererToClipper(object); // For selfNeedsClientInvalidation().</span>
          return object.objectBoundingBox();
      }
  
      if (m_clipBoundaries.isEmpty())
          calculateClipContentRepaintRect();
</pre>
<center><a href="../RenderLayerFilters.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderSVGResourceClipper.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollAnimationKinetic.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollAnimationKinetic.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollAnimationKinetic.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollAnimationKinetic.cpp
@@ -24,11 +24,15 @@
  */
 
 #include "config.h"
 #include "ScrollAnimationKinetic.h"
 
-#include "ScrollableArea.h"
+#include "PlatformWheelEvent.h"
+
+#if USE(GLIB)
+#include <wtf/glib/RunLoopSourcePriority.h>
+#endif
 
 /*
  * PerAxisData is a port of GtkKineticScrolling as of GTK+ 3.20,
  * mimicking its API and its behavior.
  *
@@ -63,10 +67,11 @@
 
 static const double decelFriction = 4;
 static const double frameRate = 60;
 static const Seconds tickTime = 1_s / frameRate;
 static const Seconds minimumTimerInterval { 1_ms };
+static const Seconds scrollCaptureThreshold { 150_ms };
 
 namespace WebCore {
 
 ScrollAnimationKinetic::PerAxisData::PerAxisData(double lower, double upper, double initialPosition, double initialVelocity)
     : m_lower(lower)
@@ -102,15 +107,18 @@
     }
 
     return m_velocity;
 }
 
-ScrollAnimationKinetic::ScrollAnimationKinetic(ScrollableArea& scrollableArea, std::function<void(FloatPoint&&)>&& notifyPositionChangedFunction)
-    : ScrollAnimation(scrollableArea)
+ScrollAnimationKinetic::ScrollAnimationKinetic(ScrollExtentsCallback&& scrollExtentsFunction, NotifyPositionChangedCallback&& notifyPositionChangedFunction)
+    : m_scrollExtentsFunction(WTFMove(scrollExtentsFunction))
     , m_notifyPositionChangedFunction(WTFMove(notifyPositionChangedFunction))
-    , m_animationTimer(*this, &ScrollAnimationKinetic::animationTimerFired)
+    , m_animationTimer(RunLoop::current(), this, &ScrollAnimationKinetic::animationTimerFired)
 {
+#if USE(GLIB)
+    m_animationTimer.setPriority(WTF::RunLoopSourcePriority::DisplayRefreshMonitorTimer);
+#endif
 }
 
 ScrollAnimationKinetic::~ScrollAnimationKinetic() = default;
 
 void ScrollAnimationKinetic::stop()
@@ -118,27 +126,62 @@
     m_animationTimer.stop();
     m_horizontalData = WTF::nullopt;
     m_verticalData = WTF::nullopt;
 }
 
+void ScrollAnimationKinetic::appendToScrollHistory(const PlatformWheelEvent& event)
+{
+    m_scrollHistory.removeAllMatching([&event] (PlatformWheelEvent& otherEvent) -> bool {
+        return (event.timestamp() - otherEvent.timestamp()) > scrollCaptureThreshold;
+    });
+
+    m_scrollHistory.append(event);
+}
+
+void ScrollAnimationKinetic::clearScrollHistory()
+{
+    m_scrollHistory.clear();
+}
+
+FloatPoint ScrollAnimationKinetic::computeVelocity()
+{
+    if (m_scrollHistory.isEmpty())
+        return { };
+
+    auto first = m_scrollHistory[0].timestamp();
+    auto last = m_scrollHistory.rbegin()->timestamp();
+
+    if (last == first)
+        return { };
+
+    FloatPoint accumDelta;
+    for (const auto& scrollEvent : m_scrollHistory)
+        accumDelta += FloatPoint(scrollEvent.deltaX(), scrollEvent.deltaY());
+
+    m_scrollHistory.clear();
+
+    return FloatPoint(accumDelta.x() * -1 / (last - first).value(), accumDelta.y() * -1 / (last - first).value());
+}
+
 void ScrollAnimationKinetic::start(const FloatPoint& initialPosition, const FloatPoint& velocity, bool mayHScroll, bool mayVScroll)
 {
     stop();
 
     m_position = initialPosition;
 
     if (!velocity.x() && !velocity.y())
         return;
 
+    auto extents = m_scrollExtentsFunction();
     if (mayHScroll) {
-        m_horizontalData = PerAxisData(m_scrollableArea.minimumScrollPosition().x(),
-            m_scrollableArea.maximumScrollPosition().x(),
+        m_horizontalData = PerAxisData(extents.minimumScrollPosition.x(),
+            extents.maximumScrollPosition.x(),
             initialPosition.x(), velocity.x());
     }
     if (mayVScroll) {
-        m_verticalData = PerAxisData(m_scrollableArea.minimumScrollPosition().y(),
-            m_scrollableArea.maximumScrollPosition().y(),
+        m_verticalData = PerAxisData(extents.minimumScrollPosition.y(),
+            extents.maximumScrollPosition.y(),
             initialPosition.y(), velocity.y());
     }
 
     m_startTime = MonotonicTime::now() - tickTime / 2.;
     animationTimerFired();

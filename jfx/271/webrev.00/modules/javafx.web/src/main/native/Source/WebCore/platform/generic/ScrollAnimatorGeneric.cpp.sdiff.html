<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/generic/ScrollAnimatorGeneric.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../ScrollAnimationKinetic.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScrollAnimatorGeneric.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/generic/ScrollAnimatorGeneric.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 23  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 #include &quot;config.h&quot;
 32 #include &quot;ScrollAnimatorGeneric.h&quot;
 33 
 34 #include &quot;ScrollAnimationKinetic.h&quot;
 35 #include &quot;ScrollAnimationSmooth.h&quot;
 36 #include &quot;ScrollableArea.h&quot;
 37 #include &quot;ScrollbarTheme.h&quot;
 38 
 39 namespace WebCore {
 40 
 41 static const Seconds overflowScrollbarsAnimationDuration { 1_s };
 42 static const Seconds overflowScrollbarsAnimationHideDelay { 2_s };
<span class="line-removed"> 43 static const Seconds scrollCaptureThreshold { 150_ms };</span>
 44 
 45 std::unique_ptr&lt;ScrollAnimator&gt; ScrollAnimator::create(ScrollableArea&amp; scrollableArea)
 46 {
 47     return makeUnique&lt;ScrollAnimatorGeneric&gt;(scrollableArea);
 48 }
 49 
 50 ScrollAnimatorGeneric::ScrollAnimatorGeneric(ScrollableArea&amp; scrollableArea)
 51     : ScrollAnimator(scrollableArea)
 52     , m_overlayScrollbarAnimationTimer(*this, &amp;ScrollAnimatorGeneric::overlayScrollbarAnimationTimerFired)
 53 {
<span class="line-modified"> 54     m_kineticAnimation = makeUnique&lt;ScrollAnimationKinetic&gt;(m_scrollableArea, [this](FloatPoint&amp;&amp; position) {</span>




 55 #if ENABLE(SMOOTH_SCROLLING)
<span class="line-modified"> 56         if (m_smoothAnimation)</span>
<span class="line-modified"> 57             m_smoothAnimation-&gt;setCurrentPosition(position);</span>
 58 #endif
<span class="line-modified"> 59         updatePosition(WTFMove(position));</span>
<span class="line-modified"> 60     });</span>
 61 
 62 #if ENABLE(SMOOTH_SCROLLING)
 63     if (scrollableArea.scrollAnimatorEnabled())
 64         ensureSmoothScrollingAnimation();
 65 #endif
 66 }
 67 
 68 ScrollAnimatorGeneric::~ScrollAnimatorGeneric() = default;
 69 
 70 #if ENABLE(SMOOTH_SCROLLING)
 71 void ScrollAnimatorGeneric::ensureSmoothScrollingAnimation()
 72 {
 73     if (m_smoothAnimation)
 74         return;
 75 
 76     m_smoothAnimation = makeUnique&lt;ScrollAnimationSmooth&gt;(m_scrollableArea, m_currentPosition, [this](FloatPoint&amp;&amp; position) {
 77         updatePosition(WTFMove(position));
 78     });
 79 }
 80 #endif
 81 
 82 #if ENABLE(SMOOTH_SCROLLING)
 83 bool ScrollAnimatorGeneric::scroll(ScrollbarOrientation orientation, ScrollGranularity granularity, float step, float multiplier)
 84 {
 85     if (!m_scrollableArea.scrollAnimatorEnabled())
 86         return ScrollAnimator::scroll(orientation, granularity, step, multiplier);
 87 
 88     ensureSmoothScrollingAnimation();
 89     return m_smoothAnimation-&gt;scroll(orientation, granularity, step, multiplier);
 90 }
 91 #endif
 92 
 93 void ScrollAnimatorGeneric::scrollToOffsetWithoutAnimation(const FloatPoint&amp; offset, ScrollClamping)
 94 {
 95     FloatPoint position = ScrollableArea::scrollPositionFromOffset(offset, toFloatSize(m_scrollableArea.scrollOrigin()));
 96     m_kineticAnimation-&gt;stop();
<span class="line-modified"> 97     m_scrollHistory.clear();</span>
 98 
 99 #if ENABLE(SMOOTH_SCROLLING)
100     if (m_smoothAnimation)
101         m_smoothAnimation-&gt;setCurrentPosition(position);
102 #endif
103 
104     updatePosition(WTFMove(position));
105 }
106 
<span class="line-removed">107 FloatPoint ScrollAnimatorGeneric::computeVelocity()</span>
<span class="line-removed">108 {</span>
<span class="line-removed">109     if (m_scrollHistory.isEmpty())</span>
<span class="line-removed">110         return { };</span>
<span class="line-removed">111 </span>
<span class="line-removed">112     auto first = m_scrollHistory[0].timestamp();</span>
<span class="line-removed">113     auto last = m_scrollHistory.rbegin()-&gt;timestamp();</span>
<span class="line-removed">114 </span>
<span class="line-removed">115     if (last == first)</span>
<span class="line-removed">116         return { };</span>
<span class="line-removed">117 </span>
<span class="line-removed">118     FloatPoint accumDelta;</span>
<span class="line-removed">119     for (const auto&amp; scrollEvent : m_scrollHistory)</span>
<span class="line-removed">120         accumDelta += FloatPoint(scrollEvent.deltaX(), scrollEvent.deltaY());</span>
<span class="line-removed">121 </span>
<span class="line-removed">122     m_scrollHistory.clear();</span>
<span class="line-removed">123 </span>
<span class="line-removed">124     return FloatPoint(accumDelta.x() * -1 / (last - first).value(), accumDelta.y() * -1 / (last - first).value());</span>
<span class="line-removed">125 }</span>
<span class="line-removed">126 </span>
127 bool ScrollAnimatorGeneric::handleWheelEvent(const PlatformWheelEvent&amp; event)
128 {
129     m_kineticAnimation-&gt;stop();
130 
<span class="line-removed">131     m_scrollHistory.removeAllMatching([&amp;event] (PlatformWheelEvent&amp; otherEvent) -&gt; bool {</span>
<span class="line-removed">132         return (event.timestamp() - otherEvent.timestamp()) &gt; scrollCaptureThreshold;</span>
<span class="line-removed">133     });</span>
<span class="line-removed">134 </span>
135 #if ENABLE(KINETIC_SCROLLING)


136     if (event.isEndOfNonMomentumScroll()) {
<span class="line-modified">137         // We don&#39;t need to add the event to the history as its delta will be (0, 0).</span>
<span class="line-removed">138         static_cast&lt;ScrollAnimationKinetic*&gt;(m_kineticAnimation.get())-&gt;start(m_currentPosition, computeVelocity(), m_scrollableArea.horizontalScrollbar(), m_scrollableArea.verticalScrollbar());</span>
139         return true;
140     }
141     if (event.isTransitioningToMomentumScroll()) {
<span class="line-modified">142         m_scrollHistory.clear();</span>
<span class="line-modified">143         static_cast&lt;ScrollAnimationKinetic*&gt;(m_kineticAnimation.get())-&gt;start(m_currentPosition, event.swipeVelocity(), m_scrollableArea.horizontalScrollbar(), m_scrollableArea.verticalScrollbar());</span>
144         return true;
145     }
146 #endif
147 
<span class="line-removed">148     m_scrollHistory.append(event);</span>
<span class="line-removed">149 </span>
150     return ScrollAnimator::handleWheelEvent(event);
151 }
152 
153 void ScrollAnimatorGeneric::willEndLiveResize()
154 {
<span class="line-removed">155     m_kineticAnimation-&gt;updateVisibleLengths();</span>
<span class="line-removed">156 </span>
157 #if ENABLE(SMOOTH_SCROLLING)
158     if (m_smoothAnimation)
159         m_smoothAnimation-&gt;updateVisibleLengths();
160 #endif
161 }
162 
163 void ScrollAnimatorGeneric::updatePosition(FloatPoint&amp;&amp; position)
164 {
165     FloatSize delta = position - m_currentPosition;
166     m_currentPosition = WTFMove(position);
167     notifyPositionChanged(delta);
168 }
169 
170 void ScrollAnimatorGeneric::didAddVerticalScrollbar(Scrollbar* scrollbar)
171 {
<span class="line-removed">172     m_kineticAnimation-&gt;updateVisibleLengths();</span>
<span class="line-removed">173 </span>
174 #if ENABLE(SMOOTH_SCROLLING)
175     if (m_smoothAnimation)
176         m_smoothAnimation-&gt;updateVisibleLengths();
177 #endif
178     if (!scrollbar-&gt;isOverlayScrollbar())
179         return;
180     m_verticalOverlayScrollbar = scrollbar;
181     if (!m_horizontalOverlayScrollbar)
182         m_overlayScrollbarAnimationCurrent = 1;
183     m_verticalOverlayScrollbar-&gt;setOpacity(m_overlayScrollbarAnimationCurrent);
184     hideOverlayScrollbars();
185 }
186 
187 void ScrollAnimatorGeneric::didAddHorizontalScrollbar(Scrollbar* scrollbar)
188 {
<span class="line-removed">189     m_kineticAnimation-&gt;updateVisibleLengths();</span>
<span class="line-removed">190 </span>
191 #if ENABLE(SMOOTH_SCROLLING)
192     if (m_smoothAnimation)
193         m_smoothAnimation-&gt;updateVisibleLengths();
194 #endif
195     if (!scrollbar-&gt;isOverlayScrollbar())
196         return;
197     m_horizontalOverlayScrollbar = scrollbar;
198     if (!m_verticalOverlayScrollbar)
199         m_overlayScrollbarAnimationCurrent = 1;
200     m_horizontalOverlayScrollbar-&gt;setOpacity(m_overlayScrollbarAnimationCurrent);
201     hideOverlayScrollbars();
202 }
203 
204 void ScrollAnimatorGeneric::willRemoveVerticalScrollbar(Scrollbar* scrollbar)
205 {
206     if (m_verticalOverlayScrollbar != scrollbar)
207         return;
208     m_verticalOverlayScrollbar = nullptr;
209     if (!m_horizontalOverlayScrollbar)
210         m_overlayScrollbarAnimationCurrent = 0;
</pre>
</td>
<td>
<hr />
<pre>
 23  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 #include &quot;config.h&quot;
 32 #include &quot;ScrollAnimatorGeneric.h&quot;
 33 
 34 #include &quot;ScrollAnimationKinetic.h&quot;
 35 #include &quot;ScrollAnimationSmooth.h&quot;
 36 #include &quot;ScrollableArea.h&quot;
 37 #include &quot;ScrollbarTheme.h&quot;
 38 
 39 namespace WebCore {
 40 
 41 static const Seconds overflowScrollbarsAnimationDuration { 1_s };
 42 static const Seconds overflowScrollbarsAnimationHideDelay { 2_s };

 43 
 44 std::unique_ptr&lt;ScrollAnimator&gt; ScrollAnimator::create(ScrollableArea&amp; scrollableArea)
 45 {
 46     return makeUnique&lt;ScrollAnimatorGeneric&gt;(scrollableArea);
 47 }
 48 
 49 ScrollAnimatorGeneric::ScrollAnimatorGeneric(ScrollableArea&amp; scrollableArea)
 50     : ScrollAnimator(scrollableArea)
 51     , m_overlayScrollbarAnimationTimer(*this, &amp;ScrollAnimatorGeneric::overlayScrollbarAnimationTimerFired)
 52 {
<span class="line-modified"> 53     m_kineticAnimation = makeUnique&lt;ScrollAnimationKinetic&gt;(</span>
<span class="line-added"> 54         [this]() -&gt; ScrollAnimationKinetic::ScrollExtents {</span>
<span class="line-added"> 55             return { m_scrollableArea.minimumScrollPosition(), m_scrollableArea.maximumScrollPosition() };</span>
<span class="line-added"> 56         },</span>
<span class="line-added"> 57         [this](FloatPoint&amp;&amp; position) {</span>
 58 #if ENABLE(SMOOTH_SCROLLING)
<span class="line-modified"> 59             if (m_smoothAnimation)</span>
<span class="line-modified"> 60                 m_smoothAnimation-&gt;setCurrentPosition(position);</span>
 61 #endif
<span class="line-modified"> 62             updatePosition(WTFMove(position));</span>
<span class="line-modified"> 63         });</span>
 64 
 65 #if ENABLE(SMOOTH_SCROLLING)
 66     if (scrollableArea.scrollAnimatorEnabled())
 67         ensureSmoothScrollingAnimation();
 68 #endif
 69 }
 70 
 71 ScrollAnimatorGeneric::~ScrollAnimatorGeneric() = default;
 72 
 73 #if ENABLE(SMOOTH_SCROLLING)
 74 void ScrollAnimatorGeneric::ensureSmoothScrollingAnimation()
 75 {
 76     if (m_smoothAnimation)
 77         return;
 78 
 79     m_smoothAnimation = makeUnique&lt;ScrollAnimationSmooth&gt;(m_scrollableArea, m_currentPosition, [this](FloatPoint&amp;&amp; position) {
 80         updatePosition(WTFMove(position));
 81     });
 82 }
 83 #endif
 84 
 85 #if ENABLE(SMOOTH_SCROLLING)
 86 bool ScrollAnimatorGeneric::scroll(ScrollbarOrientation orientation, ScrollGranularity granularity, float step, float multiplier)
 87 {
 88     if (!m_scrollableArea.scrollAnimatorEnabled())
 89         return ScrollAnimator::scroll(orientation, granularity, step, multiplier);
 90 
 91     ensureSmoothScrollingAnimation();
 92     return m_smoothAnimation-&gt;scroll(orientation, granularity, step, multiplier);
 93 }
 94 #endif
 95 
 96 void ScrollAnimatorGeneric::scrollToOffsetWithoutAnimation(const FloatPoint&amp; offset, ScrollClamping)
 97 {
 98     FloatPoint position = ScrollableArea::scrollPositionFromOffset(offset, toFloatSize(m_scrollableArea.scrollOrigin()));
 99     m_kineticAnimation-&gt;stop();
<span class="line-modified">100     m_kineticAnimation-&gt;clearScrollHistory();</span>
101 
102 #if ENABLE(SMOOTH_SCROLLING)
103     if (m_smoothAnimation)
104         m_smoothAnimation-&gt;setCurrentPosition(position);
105 #endif
106 
107     updatePosition(WTFMove(position));
108 }
109 




















110 bool ScrollAnimatorGeneric::handleWheelEvent(const PlatformWheelEvent&amp; event)
111 {
112     m_kineticAnimation-&gt;stop();
113 




114 #if ENABLE(KINETIC_SCROLLING)
<span class="line-added">115     m_kineticAnimation-&gt;appendToScrollHistory(event);</span>
<span class="line-added">116 </span>
117     if (event.isEndOfNonMomentumScroll()) {
<span class="line-modified">118         m_kineticAnimation-&gt;start(m_currentPosition, m_kineticAnimation-&gt;computeVelocity(), m_scrollableArea.horizontalScrollbar(), m_scrollableArea.verticalScrollbar());</span>

119         return true;
120     }
121     if (event.isTransitioningToMomentumScroll()) {
<span class="line-modified">122         m_kineticAnimation-&gt;clearScrollHistory();</span>
<span class="line-modified">123         m_kineticAnimation-&gt;start(m_currentPosition, event.swipeVelocity(), m_scrollableArea.horizontalScrollbar(), m_scrollableArea.verticalScrollbar());</span>
124         return true;
125     }
126 #endif
127 


128     return ScrollAnimator::handleWheelEvent(event);
129 }
130 
131 void ScrollAnimatorGeneric::willEndLiveResize()
132 {


133 #if ENABLE(SMOOTH_SCROLLING)
134     if (m_smoothAnimation)
135         m_smoothAnimation-&gt;updateVisibleLengths();
136 #endif
137 }
138 
139 void ScrollAnimatorGeneric::updatePosition(FloatPoint&amp;&amp; position)
140 {
141     FloatSize delta = position - m_currentPosition;
142     m_currentPosition = WTFMove(position);
143     notifyPositionChanged(delta);
144 }
145 
146 void ScrollAnimatorGeneric::didAddVerticalScrollbar(Scrollbar* scrollbar)
147 {


148 #if ENABLE(SMOOTH_SCROLLING)
149     if (m_smoothAnimation)
150         m_smoothAnimation-&gt;updateVisibleLengths();
151 #endif
152     if (!scrollbar-&gt;isOverlayScrollbar())
153         return;
154     m_verticalOverlayScrollbar = scrollbar;
155     if (!m_horizontalOverlayScrollbar)
156         m_overlayScrollbarAnimationCurrent = 1;
157     m_verticalOverlayScrollbar-&gt;setOpacity(m_overlayScrollbarAnimationCurrent);
158     hideOverlayScrollbars();
159 }
160 
161 void ScrollAnimatorGeneric::didAddHorizontalScrollbar(Scrollbar* scrollbar)
162 {


163 #if ENABLE(SMOOTH_SCROLLING)
164     if (m_smoothAnimation)
165         m_smoothAnimation-&gt;updateVisibleLengths();
166 #endif
167     if (!scrollbar-&gt;isOverlayScrollbar())
168         return;
169     m_horizontalOverlayScrollbar = scrollbar;
170     if (!m_verticalOverlayScrollbar)
171         m_overlayScrollbarAnimationCurrent = 1;
172     m_horizontalOverlayScrollbar-&gt;setOpacity(m_overlayScrollbarAnimationCurrent);
173     hideOverlayScrollbars();
174 }
175 
176 void ScrollAnimatorGeneric::willRemoveVerticalScrollbar(Scrollbar* scrollbar)
177 {
178     if (m_verticalOverlayScrollbar != scrollbar)
179         return;
180     m_verticalOverlayScrollbar = nullptr;
181     if (!m_horizontalOverlayScrollbar)
182         m_overlayScrollbarAnimationCurrent = 0;
</pre>
</td>
</tr>
</table>
<center><a href="../ScrollAnimationKinetic.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScrollAnimatorGeneric.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
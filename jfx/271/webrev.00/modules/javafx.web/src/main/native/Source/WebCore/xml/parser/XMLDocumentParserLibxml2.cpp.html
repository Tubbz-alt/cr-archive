<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/xml/parser/XMLDocumentParserLibxml2.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2000 Peter Kelly &lt;pmk@post.com&gt;
   3  * Copyright (C) 2005-2017 Apple Inc. All rights reserved.
   4  * Copyright (C) 2006 Alexey Proskuryakov &lt;ap@webkit.org&gt;
   5  * Copyright (C) 2007 Samuel Weinig &lt;sam@webkit.org&gt;
   6  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
   7  * Copyright (C) 2008 Holger Hans Peter Freyther
   8  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   9  * Copyright (C) 2010 Patrick Gansterer &lt;paroga@paroga.com&gt;
  10  * Copyright (C) 2013 Samsung Electronics. All rights reserved.
  11  *
  12  * This library is free software; you can redistribute it and/or
  13  * modify it under the terms of the GNU Library General Public
  14  * License as published by the Free Software Foundation; either
  15  * version 2 of the License, or (at your option) any later version.
  16  *
  17  * This library is distributed in the hope that it will be useful,
  18  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  19  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  20  * Library General Public License for more details.
  21  *
  22  * You should have received a copy of the GNU Library General Public License
  23  * along with this library; see the file COPYING.LIB.  If not, write to
  24  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  25  * Boston, MA 02110-1301, USA.
  26  */
  27 
  28 #include &quot;config.h&quot;
  29 #include &quot;XMLDocumentParser.h&quot;
  30 
  31 #include &quot;CDATASection.h&quot;
  32 #include &quot;Comment.h&quot;
  33 #include &quot;CachedResourceLoader.h&quot;
  34 #include &quot;Document.h&quot;
  35 #include &quot;DocumentFragment.h&quot;
  36 #include &quot;DocumentType.h&quot;
  37 #include &quot;Frame.h&quot;
  38 #include &quot;FrameLoader.h&quot;
  39 #include &quot;HTMLEntityParser.h&quot;
  40 #include &quot;HTMLHtmlElement.h&quot;
  41 #include &quot;HTMLTemplateElement.h&quot;
  42 #include &quot;HTTPParsers.h&quot;
  43 #include &quot;InlineClassicScript.h&quot;
  44 #include &quot;MIMETypeRegistry.h&quot;
  45 #include &quot;Page.h&quot;
  46 #include &quot;PageConsoleClient.h&quot;
  47 #include &quot;PendingScript.h&quot;
  48 #include &quot;ProcessingInstruction.h&quot;
  49 #include &quot;ResourceError.h&quot;
  50 #include &quot;ResourceResponse.h&quot;
  51 #include &quot;SVGElement.h&quot;
  52 #include &quot;ScriptElement.h&quot;
  53 #include &quot;ScriptSourceCode.h&quot;
  54 #include &quot;Settings.h&quot;
  55 #include &quot;SharedBuffer.h&quot;
  56 #include &quot;StyleScope.h&quot;
  57 #include &quot;TransformSource.h&quot;
  58 #include &quot;XMLNSNames.h&quot;
  59 #include &quot;XMLDocumentParserScope.h&quot;
  60 #include &lt;libxml/parserInternals.h&gt;
  61 #include &lt;wtf/unicode/UTF8Conversion.h&gt;
  62 
  63 #if ENABLE(XSLT)
  64 #include &quot;XMLTreeViewer.h&quot;
  65 #include &lt;libxslt/xslt.h&gt;
  66 #endif
  67 
  68 namespace WebCore {
  69 
  70 #if ENABLE(XSLT)
  71 
  72 static inline bool shouldRenderInXMLTreeViewerMode(Document&amp; document)
  73 {
  74     if (document.sawElementsInKnownNamespaces())
  75         return false;
  76 
  77     if (document.transformSourceDocument())
  78         return false;
  79 
  80     auto* frame = document.frame();
  81     if (!frame)
  82         return false;
  83 
  84     if (!frame-&gt;settings().developerExtrasEnabled())
  85         return false;
  86 
  87     if (frame-&gt;tree().parent())
  88         return false; // This document is not in a top frame
  89 
  90     return true;
  91 }
  92 
  93 #endif
  94 
  95 class PendingCallbacks {
  96     WTF_MAKE_FAST_ALLOCATED;
  97 public:
  98     void appendStartElementNSCallback(const xmlChar* xmlLocalName, const xmlChar* xmlPrefix, const xmlChar* xmlURI, int numNamespaces, const xmlChar** namespaces, int numAttributes, int numDefaulted, const xmlChar** attributes)
  99     {
 100         auto callback = makeUnique&lt;PendingStartElementNSCallback&gt;();
 101 
 102         callback-&gt;xmlLocalName = xmlStrdup(xmlLocalName);
 103         callback-&gt;xmlPrefix = xmlStrdup(xmlPrefix);
 104         callback-&gt;xmlURI = xmlStrdup(xmlURI);
 105         callback-&gt;numNamespaces = numNamespaces;
 106         callback-&gt;namespaces = static_cast&lt;xmlChar**&gt;(xmlMalloc(sizeof(xmlChar*) * numNamespaces * 2));
 107         for (int i = 0; i &lt; numNamespaces * 2 ; i++)
 108             callback-&gt;namespaces[i] = xmlStrdup(namespaces[i]);
 109         callback-&gt;numAttributes = numAttributes;
 110         callback-&gt;numDefaulted = numDefaulted;
 111         callback-&gt;attributes = static_cast&lt;xmlChar**&gt;(xmlMalloc(sizeof(xmlChar*) * numAttributes * 5));
 112         for (int i = 0; i &lt; numAttributes; i++) {
 113             // Each attribute has 5 elements in the array:
 114             // name, prefix, uri, value and an end pointer.
 115 
 116             for (int j = 0; j &lt; 3; j++)
 117                 callback-&gt;attributes[i * 5 + j] = xmlStrdup(attributes[i * 5 + j]);
 118 
 119             int len = attributes[i * 5 + 4] - attributes[i * 5 + 3];
 120 
 121             callback-&gt;attributes[i * 5 + 3] = xmlStrndup(attributes[i * 5 + 3], len);
 122             callback-&gt;attributes[i * 5 + 4] = callback-&gt;attributes[i * 5 + 3] + len;
 123         }
 124 
 125         m_callbacks.append(WTFMove(callback));
 126     }
 127 
 128     void appendEndElementNSCallback()
 129     {
 130         m_callbacks.append(makeUnique&lt;PendingEndElementNSCallback&gt;());
 131     }
 132 
 133     void appendCharactersCallback(const xmlChar* s, int len)
 134     {
 135         auto callback = makeUnique&lt;PendingCharactersCallback&gt;();
 136 
 137         callback-&gt;s = xmlStrndup(s, len);
 138         callback-&gt;len = len;
 139 
 140         m_callbacks.append(WTFMove(callback));
 141     }
 142 
 143     void appendProcessingInstructionCallback(const xmlChar* target, const xmlChar* data)
 144     {
 145         auto callback = makeUnique&lt;PendingProcessingInstructionCallback&gt;();
 146 
 147         callback-&gt;target = xmlStrdup(target);
 148         callback-&gt;data = xmlStrdup(data);
 149 
 150         m_callbacks.append(WTFMove(callback));
 151     }
 152 
 153     void appendCDATABlockCallback(const xmlChar* s, int len)
 154     {
 155         auto callback = makeUnique&lt;PendingCDATABlockCallback&gt;();
 156 
 157         callback-&gt;s = xmlStrndup(s, len);
 158         callback-&gt;len = len;
 159 
 160         m_callbacks.append(WTFMove(callback));
 161     }
 162 
 163     void appendCommentCallback(const xmlChar* s)
 164     {
 165         auto callback = makeUnique&lt;PendingCommentCallback&gt;();
 166 
 167         callback-&gt;s = xmlStrdup(s);
 168 
 169         m_callbacks.append(WTFMove(callback));
 170     }
 171 
 172     void appendInternalSubsetCallback(const xmlChar* name, const xmlChar* externalID, const xmlChar* systemID)
 173     {
 174         auto callback = makeUnique&lt;PendingInternalSubsetCallback&gt;();
 175 
 176         callback-&gt;name = xmlStrdup(name);
 177         callback-&gt;externalID = xmlStrdup(externalID);
 178         callback-&gt;systemID = xmlStrdup(systemID);
 179 
 180         m_callbacks.append(WTFMove(callback));
 181     }
 182 
 183     void appendErrorCallback(XMLErrors::ErrorType type, const xmlChar* message, OrdinalNumber lineNumber, OrdinalNumber columnNumber)
 184     {
 185         auto callback = makeUnique&lt;PendingErrorCallback&gt;();
 186 
 187         callback-&gt;message = xmlStrdup(message);
 188         callback-&gt;type = type;
 189         callback-&gt;lineNumber = lineNumber;
 190         callback-&gt;columnNumber = columnNumber;
 191 
 192         m_callbacks.append(WTFMove(callback));
 193     }
 194 
 195     void callAndRemoveFirstCallback(XMLDocumentParser* parser)
 196     {
 197         std::unique_ptr&lt;PendingCallback&gt; callback = m_callbacks.takeFirst();
 198         callback-&gt;call(parser);
 199     }
 200 
 201     bool isEmpty() const { return m_callbacks.isEmpty(); }
 202 
 203 private:
 204     struct PendingCallback {
 205         WTF_MAKE_STRUCT_FAST_ALLOCATED;
 206         virtual ~PendingCallback() = default;
 207         virtual void call(XMLDocumentParser* parser) = 0;
 208     };
 209 
 210     struct PendingStartElementNSCallback : public PendingCallback {
 211         virtual ~PendingStartElementNSCallback()
 212         {
 213             xmlFree(xmlLocalName);
 214             xmlFree(xmlPrefix);
 215             xmlFree(xmlURI);
 216             for (int i = 0; i &lt; numNamespaces * 2; i++)
 217                 xmlFree(namespaces[i]);
 218             xmlFree(namespaces);
 219             for (int i = 0; i &lt; numAttributes; i++) {
 220                 for (int j = 0; j &lt; 4; j++)
 221                     xmlFree(attributes[i * 5 + j]);
 222             }
 223             xmlFree(attributes);
 224         }
 225 
 226         void call(XMLDocumentParser* parser) override
 227         {
 228             parser-&gt;startElementNs(xmlLocalName, xmlPrefix, xmlURI, numNamespaces, const_cast&lt;const xmlChar**&gt;(namespaces), numAttributes, numDefaulted, const_cast&lt;const xmlChar**&gt;(attributes));
 229         }
 230 
 231         xmlChar* xmlLocalName;
 232         xmlChar* xmlPrefix;
 233         xmlChar* xmlURI;
 234         int numNamespaces;
 235         xmlChar** namespaces;
 236         int numAttributes;
 237         int numDefaulted;
 238         xmlChar** attributes;
 239     };
 240 
 241     struct PendingEndElementNSCallback : public PendingCallback {
 242         void call(XMLDocumentParser* parser) override
 243         {
 244             parser-&gt;endElementNs();
 245         }
 246     };
 247 
 248     struct PendingCharactersCallback : public PendingCallback {
 249         virtual ~PendingCharactersCallback()
 250         {
 251             xmlFree(s);
 252         }
 253 
 254         void call(XMLDocumentParser* parser) override
 255         {
 256             parser-&gt;characters(s, len);
 257         }
 258 
 259         xmlChar* s;
 260         int len;
 261     };
 262 
 263     struct PendingProcessingInstructionCallback : public PendingCallback {
 264         virtual ~PendingProcessingInstructionCallback()
 265         {
 266             xmlFree(target);
 267             xmlFree(data);
 268         }
 269 
 270         void call(XMLDocumentParser* parser) override
 271         {
 272             parser-&gt;processingInstruction(target, data);
 273         }
 274 
 275         xmlChar* target;
 276         xmlChar* data;
 277     };
 278 
 279     struct PendingCDATABlockCallback : public PendingCallback {
 280         virtual ~PendingCDATABlockCallback()
 281         {
 282             xmlFree(s);
 283         }
 284 
 285         void call(XMLDocumentParser* parser) override
 286         {
 287             parser-&gt;cdataBlock(s, len);
 288         }
 289 
 290         xmlChar* s;
 291         int len;
 292     };
 293 
 294     struct PendingCommentCallback : public PendingCallback {
 295         virtual ~PendingCommentCallback()
 296         {
 297             xmlFree(s);
 298         }
 299 
 300         void call(XMLDocumentParser* parser) override
 301         {
 302             parser-&gt;comment(s);
 303         }
 304 
 305         xmlChar* s;
 306     };
 307 
 308     struct PendingInternalSubsetCallback : public PendingCallback {
 309         virtual ~PendingInternalSubsetCallback()
 310         {
 311             xmlFree(name);
 312             xmlFree(externalID);
 313             xmlFree(systemID);
 314         }
 315 
 316         void call(XMLDocumentParser* parser) override
 317         {
 318             parser-&gt;internalSubset(name, externalID, systemID);
 319         }
 320 
 321         xmlChar* name;
 322         xmlChar* externalID;
 323         xmlChar* systemID;
 324     };
 325 
 326     struct PendingErrorCallback: public PendingCallback {
 327         virtual ~PendingErrorCallback()
 328         {
 329             xmlFree(message);
 330         }
 331 
 332         void call(XMLDocumentParser* parser) override
 333         {
 334             parser-&gt;handleError(type, reinterpret_cast&lt;char*&gt;(message), TextPosition(lineNumber, columnNumber));
 335         }
 336 
 337         XMLErrors::ErrorType type;
 338         xmlChar* message;
 339         OrdinalNumber lineNumber;
 340         OrdinalNumber columnNumber;
 341     };
 342 
 343     Deque&lt;std::unique_ptr&lt;PendingCallback&gt;&gt; m_callbacks;
 344 };
 345 // --------------------------------
 346 
 347 static int globalDescriptor = 0;
 348 static Thread* libxmlLoaderThread { nullptr };
 349 
 350 static int matchFunc(const char*)
 351 {
 352     // Only match loads initiated due to uses of libxml2 from within XMLDocumentParser to avoid
 353     // interfering with client applications that also use libxml2.  http://bugs.webkit.org/show_bug.cgi?id=17353
 354     return XMLDocumentParserScope::currentCachedResourceLoader &amp;&amp; libxmlLoaderThread == &amp;Thread::current();
 355 }
 356 
 357 class OffsetBuffer {
 358     WTF_MAKE_FAST_ALLOCATED;
 359 public:
 360     OffsetBuffer(Vector&lt;char&gt; buffer)
 361         : m_buffer(WTFMove(buffer))
 362         , m_currentOffset(0)
 363     {
 364     }
 365 
 366     int readOutBytes(char* outputBuffer, unsigned askedToRead)
 367     {
 368         unsigned bytesLeft = m_buffer.size() - m_currentOffset;
 369         unsigned lenToCopy = std::min(askedToRead, bytesLeft);
 370         if (lenToCopy) {
 371             memcpy(outputBuffer, m_buffer.data() + m_currentOffset, lenToCopy);
 372             m_currentOffset += lenToCopy;
 373         }
 374         return lenToCopy;
 375     }
 376 
 377 private:
 378     Vector&lt;char&gt; m_buffer;
 379     unsigned m_currentOffset;
 380 };
 381 
 382 static bool externalEntityMimeTypeAllowedByNosniff(const ResourceResponse&amp; response)
 383 {
 384     ContentTypeOptionsDisposition contentTypeOption = parseContentTypeOptionsHeader(response.httpHeaderField(HTTPHeaderName::XContentTypeOptions));
 385     if (contentTypeOption != ContentTypeOptionsNosniff) {
 386         // Allow any MIME type without &#39;X-Content-Type-Options: nosniff&#39; HTTP header.
 387         return true;
 388     }
 389     String mimeType = extractMIMETypeFromMediaType(response.httpHeaderField(HTTPHeaderName::ContentType));
 390     if (MIMETypeRegistry::isXMLMIMEType(mimeType) || MIMETypeRegistry::isXMLEntityMIMEType(mimeType))
 391         return true;
 392     return false;
 393 }
 394 
 395 static inline void setAttributes(Element* element, Vector&lt;Attribute&gt;&amp; attributeVector, ParserContentPolicy parserContentPolicy)
 396 {
 397     if (!scriptingContentIsAllowed(parserContentPolicy))
 398         element-&gt;stripScriptingAttributes(attributeVector);
 399     element-&gt;parserSetAttributes(attributeVector);
 400 }
 401 
 402 static void switchToUTF16(xmlParserCtxtPtr ctxt)
 403 {
 404     // Hack around libxml2&#39;s lack of encoding overide support by manually
 405     // resetting the encoding to UTF-16 before every chunk.  Otherwise libxml
 406     // will detect &lt;?xml version=&quot;1.0&quot; encoding=&quot;&lt;encoding name&gt;&quot;?&gt; blocks
 407     // and switch encodings, causing the parse to fail.
 408 
 409     // FIXME: Can we just use XML_PARSE_IGNORE_ENC now?
 410 
 411     const UChar BOM = 0xFEFF;
 412     const unsigned char BOMHighByte = *reinterpret_cast&lt;const unsigned char*&gt;(&amp;BOM);
 413     xmlSwitchEncoding(ctxt, BOMHighByte == 0xFF ? XML_CHAR_ENCODING_UTF16LE : XML_CHAR_ENCODING_UTF16BE);
 414 }
 415 
 416 static bool shouldAllowExternalLoad(const URL&amp; url)
 417 {
 418     String urlString = url.string();
 419 
 420     // On non-Windows platforms libxml asks for this URL, the &quot;XML_XML_DEFAULT_CATALOG&quot;, on initialization.
 421     if (urlString == &quot;file:///etc/xml/catalog&quot;)
 422         return false;
 423 
 424     // On Windows, libxml computes a URL relative to where its DLL resides.
 425     if (startsWithLettersIgnoringASCIICase(urlString, &quot;file:///&quot;) &amp;&amp; urlString.endsWithIgnoringASCIICase(&quot;/etc/catalog&quot;))
 426         return false;
 427 
 428     // The most common DTD. There isn&#39;t much point in hammering www.w3c.org by requesting this for every XHTML document.
 429     if (startsWithLettersIgnoringASCIICase(urlString, &quot;http://www.w3.org/tr/xhtml&quot;))
 430         return false;
 431 
 432     // Similarly, there isn&#39;t much point in requesting the SVG DTD.
 433     if (startsWithLettersIgnoringASCIICase(urlString, &quot;http://www.w3.org/graphics/svg&quot;))
 434         return false;
 435 
 436     // The libxml doesn&#39;t give us a lot of context for deciding whether to
 437     // allow this request.  In the worst case, this load could be for an
 438     // external entity and the resulting document could simply read the
 439     // retrieved content.  If we had more context, we could potentially allow
 440     // the parser to load a DTD.  As things stand, we take the conservative
 441     // route and allow same-origin requests only.
 442     if (!XMLDocumentParserScope::currentCachedResourceLoader-&gt;document()-&gt;securityOrigin().canRequest(url)) {
 443         XMLDocumentParserScope::currentCachedResourceLoader-&gt;printAccessDeniedMessage(url);
 444         return false;
 445     }
 446 
 447     return true;
 448 }
 449 
 450 static void* openFunc(const char* uri)
 451 {
 452     ASSERT(XMLDocumentParserScope::currentCachedResourceLoader);
 453     ASSERT(libxmlLoaderThread == &amp;Thread::current());
 454 
 455     URL url(URL(), uri);
 456 
 457     if (!shouldAllowExternalLoad(url))
 458         return &amp;globalDescriptor;
 459 
 460     ResourceError error;
 461     ResourceResponse response;
 462     RefPtr&lt;SharedBuffer&gt; data;
 463 
 464 
 465     {
 466         CachedResourceLoader* cachedResourceLoader = XMLDocumentParserScope::currentCachedResourceLoader;
 467         XMLDocumentParserScope scope(nullptr);
 468         // FIXME: We should restore the original global error handler as well.
 469 
 470         if (cachedResourceLoader-&gt;frame()) {
 471             FetchOptions options;
 472             options.mode = FetchOptions::Mode::SameOrigin;
 473             options.credentials = FetchOptions::Credentials::Include;
 474             cachedResourceLoader-&gt;frame()-&gt;loader().loadResourceSynchronously(url, ClientCredentialPolicy::MayAskClientForCredentials, options, { }, error, response, data);
 475             if (!externalEntityMimeTypeAllowedByNosniff(response)) {
 476                 data = nullptr;
 477                 if (Page* page = cachedResourceLoader-&gt;document()-&gt;page())
 478                     page-&gt;console().addMessage(MessageSource::Security, MessageLevel::Error, makeString(&quot;Did not parse external entity resource at &#39;&quot;, url.stringCenterEllipsizedToLength(), &quot;&#39; because non XML External Entity MIME types are not allowed when &#39;X-Content-Type-Options: nosniff&#39; is given.&quot;));
 479             }
 480         }
 481     }
 482 
 483     // We have to check the URL again after the load to catch redirects.
 484     // See &lt;https://bugs.webkit.org/show_bug.cgi?id=21963&gt;.
 485     if (!shouldAllowExternalLoad(response.url()))
 486         return &amp;globalDescriptor;
 487     Vector&lt;char&gt; buffer;
 488     if (data)
 489         buffer.append(data-&gt;data(), data-&gt;size());
 490     return new OffsetBuffer(WTFMove(buffer));
 491 }
 492 
 493 static int readFunc(void* context, char* buffer, int len)
 494 {
 495     // Do 0-byte reads in case of a null descriptor
 496     if (context == &amp;globalDescriptor)
 497         return 0;
 498 
 499     OffsetBuffer* data = static_cast&lt;OffsetBuffer*&gt;(context);
 500     return data-&gt;readOutBytes(buffer, len);
 501 }
 502 
 503 static int writeFunc(void*, const char*, int)
 504 {
 505     // Always just do 0-byte writes
 506     return 0;
 507 }
 508 
 509 static int closeFunc(void* context)
 510 {
 511     if (context != &amp;globalDescriptor) {
 512         OffsetBuffer* data = static_cast&lt;OffsetBuffer*&gt;(context);
 513         delete data;
 514     }
 515     return 0;
 516 }
 517 
 518 #if ENABLE(XSLT)
 519 static void errorFunc(void*, const char*, ...)
 520 {
 521     // FIXME: It would be nice to display error messages somewhere.
 522 }
 523 #endif
 524 
 525 static void initializeXMLParser()
 526 {
 527     static std::once_flag flag;
 528     std::call_once(flag, [&amp;] {
 529         xmlInitParser();
 530         xmlRegisterInputCallbacks(matchFunc, openFunc, readFunc, closeFunc);
 531         xmlRegisterOutputCallbacks(matchFunc, openFunc, writeFunc, closeFunc);
 532         libxmlLoaderThread = &amp;Thread::current();
 533     });
 534 }
 535 
 536 Ref&lt;XMLParserContext&gt; XMLParserContext::createStringParser(xmlSAXHandlerPtr handlers, void* userData)
 537 {
 538     initializeXMLParser();
 539 
 540     xmlParserCtxtPtr parser = xmlCreatePushParserCtxt(handlers, 0, 0, 0, 0);
 541     parser-&gt;_private = userData;
 542 
 543     // Substitute entities.
 544     xmlCtxtUseOptions(parser, XML_PARSE_NOENT | XML_PARSE_HUGE);
 545 
 546     switchToUTF16(parser);
 547 
 548     return adoptRef(*new XMLParserContext(parser));
 549 }
 550 
 551 
 552 // Chunk should be encoded in UTF-8
 553 RefPtr&lt;XMLParserContext&gt; XMLParserContext::createMemoryParser(xmlSAXHandlerPtr handlers, void* userData, const CString&amp; chunk)
 554 {
 555     initializeXMLParser();
 556 
 557     // appendFragmentSource() checks that the length doesn&#39;t overflow an int.
 558     xmlParserCtxtPtr parser = xmlCreateMemoryParserCtxt(chunk.data(), chunk.length());
 559 
 560     if (!parser)
 561         return 0;
 562 
 563     memcpy(parser-&gt;sax, handlers, sizeof(xmlSAXHandler));
 564 
 565     // Substitute entities.
 566     // FIXME: Why is XML_PARSE_NODICT needed? This is different from what createStringParser does.
 567     xmlCtxtUseOptions(parser, XML_PARSE_NODICT | XML_PARSE_NOENT | XML_PARSE_HUGE);
 568 
 569     // Internal initialization
 570     parser-&gt;sax2 = 1;
 571     parser-&gt;instate = XML_PARSER_CONTENT; // We are parsing a CONTENT
 572     parser-&gt;depth = 0;
 573     parser-&gt;str_xml = xmlDictLookup(parser-&gt;dict, reinterpret_cast&lt;xmlChar*&gt;(const_cast&lt;char*&gt;(&quot;xml&quot;)), 3);
 574     parser-&gt;str_xmlns = xmlDictLookup(parser-&gt;dict, reinterpret_cast&lt;xmlChar*&gt;(const_cast&lt;char*&gt;(&quot;xmlns&quot;)), 5);
 575     parser-&gt;str_xml_ns = xmlDictLookup(parser-&gt;dict, XML_XML_NAMESPACE, 36);
 576     parser-&gt;_private = userData;
 577 
 578     return adoptRef(*new XMLParserContext(parser));
 579 }
 580 
 581 // --------------------------------
 582 
 583 bool XMLDocumentParser::supportsXMLVersion(const String&amp; version)
 584 {
 585     return version == &quot;1.0&quot;;
 586 }
 587 
 588 XMLDocumentParser::XMLDocumentParser(Document&amp; document, FrameView* frameView)
 589     : ScriptableDocumentParser(document)
 590     , m_view(frameView)
 591     , m_pendingCallbacks(makeUnique&lt;PendingCallbacks&gt;())
 592     , m_currentNode(&amp;document)
 593     , m_scriptStartPosition(TextPosition::belowRangePosition())
 594 {
 595 }
 596 
 597 XMLDocumentParser::XMLDocumentParser(DocumentFragment&amp; fragment, HashMap&lt;AtomString, AtomString&gt;&amp;&amp; prefixToNamespaceMap, const AtomString&amp; defaultNamespaceURI, ParserContentPolicy parserContentPolicy)
 598     : ScriptableDocumentParser(fragment.document(), parserContentPolicy)
 599     , m_pendingCallbacks(makeUnique&lt;PendingCallbacks&gt;())
 600     , m_currentNode(&amp;fragment)
 601     , m_scriptStartPosition(TextPosition::belowRangePosition())
 602     , m_parsingFragment(true)
 603     , m_prefixToNamespaceMap(WTFMove(prefixToNamespaceMap))
 604     , m_defaultNamespaceURI(defaultNamespaceURI)
 605 {
 606     fragment.ref();
 607 }
 608 
 609 XMLParserContext::~XMLParserContext()
 610 {
 611     if (m_context-&gt;myDoc)
 612         xmlFreeDoc(m_context-&gt;myDoc);
 613     xmlFreeParserCtxt(m_context);
 614 }
 615 
 616 XMLDocumentParser::~XMLDocumentParser()
 617 {
 618     // The XMLDocumentParser will always be detached before being destroyed.
 619     ASSERT(m_currentNodeStack.isEmpty());
 620     ASSERT(!m_currentNode);
 621 
 622     // FIXME: m_pendingScript handling should be moved into XMLDocumentParser.cpp!
 623     if (m_pendingScript)
 624         m_pendingScript-&gt;clearClient();
 625 }
 626 
 627 void XMLDocumentParser::doWrite(const String&amp; parseString)
 628 {
 629     ASSERT(!isDetached());
 630     if (!m_context)
 631         initializeParserContext();
 632 
 633     // Protect the libxml context from deletion during a callback
 634     RefPtr&lt;XMLParserContext&gt; context = m_context;
 635 
 636     // libXML throws an error if you try to switch the encoding for an empty string.
 637     if (parseString.length()) {
 638         // JavaScript may cause the parser to detach during xmlParseChunk
 639         // keep this alive until this function is done.
 640         Ref&lt;XMLDocumentParser&gt; protectedThis(*this);
 641 
 642         XMLDocumentParserScope scope(&amp;document()-&gt;cachedResourceLoader());
 643 
 644         // FIXME: Can we parse 8-bit strings directly as Latin-1 instead of upconverting to UTF-16?
 645         switchToUTF16(context-&gt;context());
 646         xmlParseChunk(context-&gt;context(), reinterpret_cast&lt;const char*&gt;(StringView(parseString).upconvertedCharacters().get()), sizeof(UChar) * parseString.length(), 0);
 647 
 648         // JavaScript (which may be run under the xmlParseChunk callstack) may
 649         // cause the parser to be stopped or detached.
 650         if (isStopped())
 651             return;
 652     }
 653 
 654     // FIXME: Why is this here?  And why is it after we process the passed source?
 655     if (document()-&gt;decoder() &amp;&amp; document()-&gt;decoder()-&gt;sawError()) {
 656         // If the decoder saw an error, report it as fatal (stops parsing)
 657         TextPosition position(OrdinalNumber::fromOneBasedInt(context-&gt;context()-&gt;input-&gt;line), OrdinalNumber::fromOneBasedInt(context-&gt;context()-&gt;input-&gt;col));
 658         handleError(XMLErrors::fatal, &quot;Encoding error&quot;, position);
 659     }
 660 }
 661 
 662 static inline String toString(const xmlChar* string, size_t size)
 663 {
 664     return String::fromUTF8(reinterpret_cast&lt;const char*&gt;(string), size);
 665 }
 666 
 667 static inline String toString(const xmlChar* string)
 668 {
 669     return String::fromUTF8(reinterpret_cast&lt;const char*&gt;(string));
 670 }
 671 
 672 static inline AtomString toAtomString(const xmlChar* string, size_t size)
 673 {
 674     return AtomString::fromUTF8(reinterpret_cast&lt;const char*&gt;(string), size);
 675 }
 676 
 677 static inline AtomString toAtomString(const xmlChar* string)
 678 {
 679     return AtomString::fromUTF8(reinterpret_cast&lt;const char*&gt;(string));
 680 }
 681 
 682 struct _xmlSAX2Namespace {
 683     const xmlChar* prefix;
 684     const xmlChar* uri;
 685 };
 686 typedef struct _xmlSAX2Namespace xmlSAX2Namespace;
 687 
 688 static inline bool handleNamespaceAttributes(Vector&lt;Attribute&gt;&amp; prefixedAttributes, const xmlChar** libxmlNamespaces, int numNamespaces)
 689 {
 690     xmlSAX2Namespace* namespaces = reinterpret_cast&lt;xmlSAX2Namespace*&gt;(libxmlNamespaces);
 691     for (int i = 0; i &lt; numNamespaces; i++) {
 692         AtomString namespaceQName = xmlnsAtom();
 693         AtomString namespaceURI = toAtomString(namespaces[i].uri);
 694         if (namespaces[i].prefix)
 695             namespaceQName = &quot;xmlns:&quot; + toString(namespaces[i].prefix);
 696 
 697         auto result = Element::parseAttributeName(XMLNSNames::xmlnsNamespaceURI, namespaceQName);
 698         if (result.hasException())
 699             return false;
 700 
 701         prefixedAttributes.append(Attribute(result.releaseReturnValue(), namespaceURI));
 702     }
 703     return true;
 704 }
 705 
 706 struct _xmlSAX2Attributes {
 707     const xmlChar* localname;
 708     const xmlChar* prefix;
 709     const xmlChar* uri;
 710     const xmlChar* value;
 711     const xmlChar* end;
 712 };
 713 typedef struct _xmlSAX2Attributes xmlSAX2Attributes;
 714 
 715 static inline bool handleElementAttributes(Vector&lt;Attribute&gt;&amp; prefixedAttributes, const xmlChar** libxmlAttributes, int numAttributes)
 716 {
 717     xmlSAX2Attributes* attributes = reinterpret_cast&lt;xmlSAX2Attributes*&gt;(libxmlAttributes);
 718     for (int i = 0; i &lt; numAttributes; i++) {
 719         int valueLength = static_cast&lt;int&gt;(attributes[i].end - attributes[i].value);
 720         AtomString attrValue = toAtomString(attributes[i].value, valueLength);
 721         String attrPrefix = toString(attributes[i].prefix);
 722         AtomString attrURI = attrPrefix.isEmpty() ? nullAtom() : toAtomString(attributes[i].uri);
 723         AtomString attrQName = attrPrefix.isEmpty() ? toAtomString(attributes[i].localname) : attrPrefix + &quot;:&quot; + toString(attributes[i].localname);
 724 
 725         auto result = Element::parseAttributeName(attrURI, attrQName);
 726         if (result.hasException())
 727             return false;
 728 
 729         prefixedAttributes.append(Attribute(result.releaseReturnValue(), attrValue));
 730     }
 731     return true;
 732 }
 733 
 734 // This is a hack around https://bugzilla.gnome.org/show_bug.cgi?id=502960
 735 // Otherwise libxml doesn&#39;t include namespace for parsed entities, breaking entity
 736 // expansion for all entities containing elements.
 737 static inline bool hackAroundLibXMLEntityParsingBug()
 738 {
 739 #if LIBXML_VERSION &gt;= 20704
 740     // This bug has been fixed in libxml 2.7.4.
 741     return false;
 742 #else
 743     return true;
 744 #endif
 745 }
 746 
 747 void XMLDocumentParser::startElementNs(const xmlChar* xmlLocalName, const xmlChar* xmlPrefix, const xmlChar* xmlURI, int numNamespaces, const xmlChar** libxmlNamespaces, int numAttributes, int numDefaulted, const xmlChar** libxmlAttributes)
 748 {
 749     if (isStopped())
 750         return;
 751 
 752     if (m_parserPaused) {
 753         m_pendingCallbacks-&gt;appendStartElementNSCallback(xmlLocalName, xmlPrefix, xmlURI, numNamespaces, libxmlNamespaces, numAttributes, numDefaulted, libxmlAttributes);
 754         return;
 755     }
 756 
 757     if (!updateLeafTextNode())
 758         return;
 759 
 760     AtomString localName = toAtomString(xmlLocalName);
 761     AtomString uri = toAtomString(xmlURI);
 762     AtomString prefix = toAtomString(xmlPrefix);
 763 
 764     if (m_parsingFragment &amp;&amp; uri.isNull()) {
 765         if (!prefix.isNull())
 766             uri = m_prefixToNamespaceMap.get(prefix);
 767         else if (is&lt;SVGElement&gt;(m_currentNode) || localName == SVGNames::svgTag-&gt;localName())
 768             uri = SVGNames::svgNamespaceURI;
 769         else
 770             uri = m_defaultNamespaceURI;
 771     }
 772 
 773     // If libxml entity parsing is broken, transfer the currentNodes&#39; namespaceURI to the new node,
 774     // if we&#39;re currently expanding elements which originate from an entity declaration.
 775     if (hackAroundLibXMLEntityParsingBug() &amp;&amp; depthTriggeringEntityExpansion() != -1 &amp;&amp; context()-&gt;depth &gt; depthTriggeringEntityExpansion() &amp;&amp; uri.isNull() &amp;&amp; prefix.isNull())
 776         uri = m_currentNode-&gt;namespaceURI();
 777 
 778     bool isFirstElement = !m_sawFirstElement;
 779     m_sawFirstElement = true;
 780 
 781     QualifiedName qName(prefix, localName, uri);
 782     auto newElement = m_currentNode-&gt;document().createElement(qName, true);
 783 
 784     Vector&lt;Attribute&gt; prefixedAttributes;
 785     if (!handleNamespaceAttributes(prefixedAttributes, libxmlNamespaces, numNamespaces)) {
 786         setAttributes(newElement.ptr(), prefixedAttributes, parserContentPolicy());
 787         stopParsing();
 788         return;
 789     }
 790 
 791     bool success = handleElementAttributes(prefixedAttributes, libxmlAttributes, numAttributes);
 792     setAttributes(newElement.ptr(), prefixedAttributes, parserContentPolicy());
 793     if (!success) {
 794         stopParsing();
 795         return;
 796     }
 797 
 798     newElement-&gt;beginParsingChildren();
 799 
 800     if (isScriptElement(newElement.get()))
 801         m_scriptStartPosition = textPosition();
 802 
 803     m_currentNode-&gt;parserAppendChild(newElement);
 804     if (!m_currentNode) // Synchronous DOM events may have removed the current node.
 805         return;
 806 
 807     if (is&lt;HTMLTemplateElement&gt;(newElement))
 808         pushCurrentNode(&amp;downcast&lt;HTMLTemplateElement&gt;(newElement.get()).content());
 809     else
 810         pushCurrentNode(newElement.ptr());
 811 
 812     if (is&lt;HTMLHtmlElement&gt;(newElement))
 813         downcast&lt;HTMLHtmlElement&gt;(newElement.get()).insertedByParser();
 814 
 815     if (!m_parsingFragment &amp;&amp; isFirstElement &amp;&amp; document()-&gt;frame())
 816         document()-&gt;frame()-&gt;injectUserScripts(InjectAtDocumentStart);
 817 }
 818 
 819 void XMLDocumentParser::endElementNs()
 820 {
 821     if (isStopped())
 822         return;
 823 
 824     if (m_parserPaused) {
 825         m_pendingCallbacks-&gt;appendEndElementNSCallback();
 826         return;
 827     }
 828 
 829     // JavaScript can detach the parser.  Make sure this is not released
 830     // before the end of this method.
 831     Ref&lt;XMLDocumentParser&gt; protectedThis(*this);
 832 
 833     if (!updateLeafTextNode())
 834         return;
 835 
 836     RefPtr&lt;ContainerNode&gt; node = m_currentNode;
 837     node-&gt;finishParsingChildren();
 838 
 839     // Once we reach the depth again where entity expansion started, stop executing the work-around.
 840     if (hackAroundLibXMLEntityParsingBug() &amp;&amp; context()-&gt;depth &lt;= depthTriggeringEntityExpansion())
 841         setDepthTriggeringEntityExpansion(-1);
 842 
 843     if (!scriptingContentIsAllowed(parserContentPolicy()) &amp;&amp; is&lt;Element&gt;(*node) &amp;&amp; isScriptElement(downcast&lt;Element&gt;(*node))) {
 844         popCurrentNode();
 845         node-&gt;remove();
 846         return;
 847     }
 848 
 849     if (!node-&gt;isElementNode() || !m_view) {
 850         popCurrentNode();
 851         return;
 852     }
 853 
 854     auto&amp; element = downcast&lt;Element&gt;(*node);
 855 
 856     // The element&#39;s parent may have already been removed from document.
 857     // Parsing continues in this case, but scripts aren&#39;t executed.
 858     if (!element.isConnected()) {
 859         popCurrentNode();
 860         return;
 861     }
 862 
 863     if (!isScriptElement(element)) {
 864         popCurrentNode();
 865         return;
 866     }
 867 
 868     // Don&#39;t load external scripts for standalone documents (for now).
 869     ASSERT(!m_pendingScript);
 870     m_requestingScript = true;
 871 
 872     auto&amp; scriptElement = downcastScriptElement(element);
 873     if (scriptElement.prepareScript(m_scriptStartPosition, ScriptElement::AllowLegacyTypeInTypeAttribute)) {
 874         // FIXME: Script execution should be shared between
 875         // the libxml2 and Qt XMLDocumentParser implementations.
 876 
 877         if (scriptElement.readyToBeParserExecuted())
 878             scriptElement.executeClassicScript(ScriptSourceCode(scriptElement.scriptContent(), URL(document()-&gt;url()), m_scriptStartPosition, JSC::SourceProviderSourceType::Program, InlineClassicScript::create(scriptElement)));
 879         else if (scriptElement.willBeParserExecuted() &amp;&amp; scriptElement.loadableScript()) {
 880             m_pendingScript = PendingScript::create(scriptElement, *scriptElement.loadableScript());
 881             m_pendingScript-&gt;setClient(*this);
 882 
 883             // m_pendingScript will be nullptr if script was already loaded and setClient() executed it.
 884             if (m_pendingScript)
 885                 pauseParsing();
 886         }
 887 
 888         // JavaScript may have detached the parser
 889         if (isDetached())
 890             return;
 891     }
 892     m_requestingScript = false;
 893     popCurrentNode();
 894 }
 895 
 896 void XMLDocumentParser::characters(const xmlChar* characters, int length)
 897 {
 898     if (isStopped())
 899         return;
 900 
 901     if (m_parserPaused) {
 902         m_pendingCallbacks-&gt;appendCharactersCallback(characters, length);
 903         return;
 904     }
 905 
 906     if (!m_leafTextNode)
 907         createLeafTextNode();
 908     m_bufferedText.append(characters, length);
 909 }
 910 
 911 void XMLDocumentParser::error(XMLErrors::ErrorType type, const char* message, va_list args)
 912 {
 913     if (isStopped())
 914         return;
 915 
 916     va_list preflightArgs;
 917     va_copy(preflightArgs, args);
 918     size_t stringLength = vsnprintf(nullptr, 0, message, preflightArgs);
 919     va_end(preflightArgs);
 920 
 921     Vector&lt;char, 1024&gt; buffer(stringLength + 1);
 922     vsnprintf(buffer.data(), stringLength + 1, message, args);
 923 
 924     TextPosition position = textPosition();
 925     if (m_parserPaused)
 926         m_pendingCallbacks-&gt;appendErrorCallback(type, reinterpret_cast&lt;const xmlChar*&gt;(buffer.data()), position.m_line, position.m_column);
 927     else
 928         handleError(type, buffer.data(), textPosition());
 929 }
 930 
 931 void XMLDocumentParser::processingInstruction(const xmlChar* target, const xmlChar* data)
 932 {
 933     if (isStopped())
 934         return;
 935 
 936     if (m_parserPaused) {
 937         m_pendingCallbacks-&gt;appendProcessingInstructionCallback(target, data);
 938         return;
 939     }
 940 
 941     if (!updateLeafTextNode())
 942         return;
 943 
 944     auto result = m_currentNode-&gt;document().createProcessingInstruction(toString(target), toString(data));
 945     if (result.hasException())
 946         return;
 947     auto pi = result.releaseReturnValue();
 948 
 949     pi-&gt;setCreatedByParser(true);
 950 
 951     m_currentNode-&gt;parserAppendChild(pi);
 952 
 953     pi-&gt;finishParsingChildren();
 954 
 955     if (pi-&gt;isCSS())
 956         m_sawCSS = true;
 957 
 958 #if ENABLE(XSLT)
 959     m_sawXSLTransform = !m_sawFirstElement &amp;&amp; pi-&gt;isXSL();
 960     if (m_sawXSLTransform &amp;&amp; !document()-&gt;transformSourceDocument())
 961         stopParsing();
 962 #endif
 963 }
 964 
 965 void XMLDocumentParser::cdataBlock(const xmlChar* s, int len)
 966 {
 967     if (isStopped())
 968         return;
 969 
 970     if (m_parserPaused) {
 971         m_pendingCallbacks-&gt;appendCDATABlockCallback(s, len);
 972         return;
 973     }
 974 
 975     if (!updateLeafTextNode())
 976         return;
 977 
 978     m_currentNode-&gt;parserAppendChild(CDATASection::create(m_currentNode-&gt;document(), toString(s, len)));
 979 }
 980 
 981 void XMLDocumentParser::comment(const xmlChar* s)
 982 {
 983     if (isStopped())
 984         return;
 985 
 986     if (m_parserPaused) {
 987         m_pendingCallbacks-&gt;appendCommentCallback(s);
 988         return;
 989     }
 990 
 991     if (!updateLeafTextNode())
 992         return;
 993 
 994     m_currentNode-&gt;parserAppendChild(Comment::create(m_currentNode-&gt;document(), toString(s)));
 995 }
 996 
 997 enum StandaloneInfo {
 998     StandaloneUnspecified = -2,
 999     NoXMlDeclaration,
1000     StandaloneNo,
1001     StandaloneYes
1002 };
1003 
1004 void XMLDocumentParser::startDocument(const xmlChar* version, const xmlChar* encoding, int standalone)
1005 {
1006     StandaloneInfo standaloneInfo = (StandaloneInfo)standalone;
1007     if (standaloneInfo == NoXMlDeclaration) {
1008         document()-&gt;setHasXMLDeclaration(false);
1009         return;
1010     }
1011 
1012     if (version)
1013         document()-&gt;setXMLVersion(toString(version));
1014     if (standalone != StandaloneUnspecified)
1015         document()-&gt;setXMLStandalone(standaloneInfo == StandaloneYes);
1016     if (encoding)
1017         document()-&gt;setXMLEncoding(toString(encoding));
1018     document()-&gt;setHasXMLDeclaration(true);
1019 }
1020 
1021 void XMLDocumentParser::endDocument()
1022 {
1023     updateLeafTextNode();
1024 }
1025 
1026 void XMLDocumentParser::internalSubset(const xmlChar* name, const xmlChar* externalID, const xmlChar* systemID)
1027 {
1028     if (isStopped())
1029         return;
1030 
1031     if (m_parserPaused) {
1032         m_pendingCallbacks-&gt;appendInternalSubsetCallback(name, externalID, systemID);
1033         return;
1034     }
1035 
1036     if (document())
1037         document()-&gt;parserAppendChild(DocumentType::create(*document(), toString(name), toString(externalID), toString(systemID)));
1038 }
1039 
1040 static inline XMLDocumentParser* getParser(void* closure)
1041 {
1042     xmlParserCtxtPtr ctxt = static_cast&lt;xmlParserCtxtPtr&gt;(closure);
1043     return static_cast&lt;XMLDocumentParser*&gt;(ctxt-&gt;_private);
1044 }
1045 
1046 // This is a hack around http://bugzilla.gnome.org/show_bug.cgi?id=159219
1047 // Otherwise libxml seems to call all the SAX callbacks twice for any replaced entity.
1048 static inline bool hackAroundLibXMLEntityBug(void* closure)
1049 {
1050 #if LIBXML_VERSION &gt;= 20627
1051     // This bug has been fixed in libxml 2.6.27.
1052     UNUSED_PARAM(closure);
1053     return false;
1054 #else
1055     return static_cast&lt;xmlParserCtxtPtr&gt;(closure)-&gt;node;
1056 #endif
1057 }
1058 
1059 static void startElementNsHandler(void* closure, const xmlChar* localname, const xmlChar* prefix, const xmlChar* uri, int numNamespaces, const xmlChar** namespaces, int numAttributes, int numDefaulted, const xmlChar** libxmlAttributes)
1060 {
1061     if (hackAroundLibXMLEntityBug(closure))
1062         return;
1063 
1064     getParser(closure)-&gt;startElementNs(localname, prefix, uri, numNamespaces, namespaces, numAttributes, numDefaulted, libxmlAttributes);
1065 }
1066 
1067 static void endElementNsHandler(void* closure, const xmlChar*, const xmlChar*, const xmlChar*)
1068 {
1069     if (hackAroundLibXMLEntityBug(closure))
1070         return;
1071 
1072     getParser(closure)-&gt;endElementNs();
1073 }
1074 
1075 static void charactersHandler(void* closure, const xmlChar* s, int len)
1076 {
1077     if (hackAroundLibXMLEntityBug(closure))
1078         return;
1079 
1080     getParser(closure)-&gt;characters(s, len);
1081 }
1082 
1083 static void processingInstructionHandler(void* closure, const xmlChar* target, const xmlChar* data)
1084 {
1085     if (hackAroundLibXMLEntityBug(closure))
1086         return;
1087 
1088     getParser(closure)-&gt;processingInstruction(target, data);
1089 }
1090 
1091 static void cdataBlockHandler(void* closure, const xmlChar* s, int len)
1092 {
1093     if (hackAroundLibXMLEntityBug(closure))
1094         return;
1095 
1096     getParser(closure)-&gt;cdataBlock(s, len);
1097 }
1098 
1099 static void commentHandler(void* closure, const xmlChar* comment)
1100 {
1101     if (hackAroundLibXMLEntityBug(closure))
1102         return;
1103 
1104     getParser(closure)-&gt;comment(comment);
1105 }
1106 
1107 WTF_ATTRIBUTE_PRINTF(2, 3)
1108 static void warningHandler(void* closure, const char* message, ...)
1109 {
1110     va_list args;
1111     va_start(args, message);
1112     getParser(closure)-&gt;error(XMLErrors::warning, message, args);
1113     va_end(args);
1114 }
1115 
1116 WTF_ATTRIBUTE_PRINTF(2, 3)
1117 static void fatalErrorHandler(void* closure, const char* message, ...)
1118 {
1119     va_list args;
1120     va_start(args, message);
1121     getParser(closure)-&gt;error(XMLErrors::fatal, message, args);
1122     va_end(args);
1123 }
1124 
1125 WTF_ATTRIBUTE_PRINTF(2, 3)
1126 static void normalErrorHandler(void* closure, const char* message, ...)
1127 {
1128     va_list args;
1129     va_start(args, message);
1130     getParser(closure)-&gt;error(XMLErrors::nonFatal, message, args);
1131     va_end(args);
1132 }
1133 
1134 // Using a static entity and marking it XML_INTERNAL_PREDEFINED_ENTITY is
1135 // a hack to avoid malloc/free. Using a global variable like this could cause trouble
1136 // if libxml implementation details were to change
1137 static xmlChar sharedXHTMLEntityResult[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
1138 
1139 static xmlEntityPtr sharedXHTMLEntity()
1140 {
1141     static xmlEntity entity;
1142     if (!entity.type) {
1143         entity.type = XML_ENTITY_DECL;
1144         entity.orig = sharedXHTMLEntityResult;
1145         entity.content = sharedXHTMLEntityResult;
1146         entity.etype = XML_INTERNAL_PREDEFINED_ENTITY;
1147     }
1148     return &amp;entity;
1149 }
1150 
1151 static size_t convertUTF16EntityToUTF8(const UChar* utf16Entity, size_t numberOfCodeUnits, char* target, size_t targetSize)
1152 {
1153     const char* originalTarget = target;
1154     auto conversionResult = WTF::Unicode::convertUTF16ToUTF8(&amp;utf16Entity, utf16Entity + numberOfCodeUnits, &amp;target, target + targetSize);
1155     if (conversionResult != WTF::Unicode::ConversionOK)
1156         return 0;
1157 
1158     // Even though we must pass the length, libxml expects the entity string to be null terminated.
1159     ASSERT(target &gt;= originalTarget + 1);
1160     *target = &#39;\0&#39;;
1161     return target - originalTarget;
1162 }
1163 
1164 static xmlEntityPtr getXHTMLEntity(const xmlChar* name)
1165 {
1166     UChar utf16DecodedEntity[4];
1167     size_t numberOfCodeUnits = decodeNamedEntityToUCharArray(reinterpret_cast&lt;const char*&gt;(name), utf16DecodedEntity);
1168     if (!numberOfCodeUnits)
1169         return 0;
1170 
1171     ASSERT(numberOfCodeUnits &lt;= 4);
1172     size_t entityLengthInUTF8 = convertUTF16EntityToUTF8(utf16DecodedEntity, numberOfCodeUnits,
1173         reinterpret_cast&lt;char*&gt;(sharedXHTMLEntityResult), WTF_ARRAY_LENGTH(sharedXHTMLEntityResult));
1174     if (!entityLengthInUTF8)
1175         return 0;
1176 
1177     xmlEntityPtr entity = sharedXHTMLEntity();
1178     entity-&gt;length = entityLengthInUTF8;
1179     entity-&gt;name = name;
1180     return entity;
1181 }
1182 
1183 static void entityDeclarationHandler(void* closure, const xmlChar* name, int type, const xmlChar* publicId, const xmlChar* systemId, xmlChar* content)
1184 {
1185     // Prevent the next call to getEntityHandler() to record the entity expansion depth.
1186     // We&#39;re parsing the entity declaration, so there&#39;s no need to record anything.
1187     // We only need to record the depth, if we&#39;re actually expanding the entity, when it&#39;s referenced.
1188     if (hackAroundLibXMLEntityParsingBug())
1189         getParser(closure)-&gt;setIsParsingEntityDeclaration(true);
1190     xmlSAX2EntityDecl(closure, name, type, publicId, systemId, content);
1191 }
1192 
1193 static xmlEntityPtr getEntityHandler(void* closure, const xmlChar* name)
1194 {
1195     xmlParserCtxtPtr ctxt = static_cast&lt;xmlParserCtxtPtr&gt;(closure);
1196 
1197     XMLDocumentParser* parser = getParser(closure);
1198     if (hackAroundLibXMLEntityParsingBug()) {
1199         if (parser-&gt;isParsingEntityDeclaration()) {
1200             // We&#39;re parsing the entity declarations (not an entity reference), no need to do anything special.
1201             parser-&gt;setIsParsingEntityDeclaration(false);
1202             ASSERT(parser-&gt;depthTriggeringEntityExpansion() == -1);
1203         } else {
1204             // The entity will be used and eventually expanded. Record the current parser depth
1205             // so the next call to startElementNs() knows that the new element originates from
1206             // an entity declaration.
1207             parser-&gt;setDepthTriggeringEntityExpansion(ctxt-&gt;depth);
1208         }
1209     }
1210 
1211     xmlEntityPtr ent = xmlGetPredefinedEntity(name);
1212     if (ent) {
1213         ent-&gt;etype = XML_INTERNAL_PREDEFINED_ENTITY;
1214         return ent;
1215     }
1216 
1217     ent = xmlGetDocEntity(ctxt-&gt;myDoc, name);
1218     if (!ent &amp;&amp; parser-&gt;isXHTMLDocument()) {
1219         ent = getXHTMLEntity(name);
1220         if (ent)
1221             ent-&gt;etype = XML_INTERNAL_GENERAL_ENTITY;
1222     }
1223 
1224     return ent;
1225 }
1226 
1227 static void startDocumentHandler(void* closure)
1228 {
1229     xmlParserCtxt* ctxt = static_cast&lt;xmlParserCtxt*&gt;(closure);
1230     switchToUTF16(ctxt);
1231     getParser(closure)-&gt;startDocument(ctxt-&gt;version, ctxt-&gt;encoding, ctxt-&gt;standalone);
1232     xmlSAX2StartDocument(closure);
1233 }
1234 
1235 static void endDocumentHandler(void* closure)
1236 {
1237     getParser(closure)-&gt;endDocument();
1238     xmlSAX2EndDocument(closure);
1239 }
1240 
1241 static void internalSubsetHandler(void* closure, const xmlChar* name, const xmlChar* externalID, const xmlChar* systemID)
1242 {
1243     getParser(closure)-&gt;internalSubset(name, externalID, systemID);
1244     xmlSAX2InternalSubset(closure, name, externalID, systemID);
1245 }
1246 
1247 static void externalSubsetHandler(void* closure, const xmlChar*, const xmlChar* externalId, const xmlChar*)
1248 {
1249     String extId = toString(externalId);
1250     if ((extId == &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;)
1251         || (extId == &quot;-//W3C//DTD XHTML 1.1//EN&quot;)
1252         || (extId == &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;)
1253         || (extId == &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot;)
1254         || (extId == &quot;-//W3C//DTD XHTML Basic 1.0//EN&quot;)
1255         || (extId == &quot;-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN&quot;)
1256         || (extId == &quot;-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN&quot;)
1257         || (extId == &quot;-//W3C//DTD MathML 2.0//EN&quot;)
1258         || (extId == &quot;-//WAPFORUM//DTD XHTML Mobile 1.0//EN&quot;)
1259         || (extId == &quot;-//WAPFORUM//DTD XHTML Mobile 1.1//EN&quot;)
1260         || (extId == &quot;-//WAPFORUM//DTD XHTML Mobile 1.2//EN&quot;))
1261         getParser(closure)-&gt;setIsXHTMLDocument(true); // controls if we replace entities or not.
1262 }
1263 
1264 static void ignorableWhitespaceHandler(void*, const xmlChar*, int)
1265 {
1266     // nothing to do, but we need this to work around a crasher
1267     // http://bugzilla.gnome.org/show_bug.cgi?id=172255
1268     // http://bugs.webkit.org/show_bug.cgi?id=5792
1269 }
1270 
1271 void XMLDocumentParser::initializeParserContext(const CString&amp; chunk)
1272 {
1273     xmlSAXHandler sax;
1274     memset(&amp;sax, 0, sizeof(sax));
1275 
1276     sax.error = normalErrorHandler;
1277     sax.fatalError = fatalErrorHandler;
1278     sax.characters = charactersHandler;
1279     sax.processingInstruction = processingInstructionHandler;
1280     sax.cdataBlock = cdataBlockHandler;
1281     sax.comment = commentHandler;
1282     sax.warning = warningHandler;
1283     sax.startElementNs = startElementNsHandler;
1284     sax.endElementNs = endElementNsHandler;
1285     sax.getEntity = getEntityHandler;
1286     sax.startDocument = startDocumentHandler;
1287     sax.endDocument = endDocumentHandler;
1288     sax.internalSubset = internalSubsetHandler;
1289     sax.externalSubset = externalSubsetHandler;
1290     sax.ignorableWhitespace = ignorableWhitespaceHandler;
1291     sax.entityDecl = entityDeclarationHandler;
1292     sax.initialized = XML_SAX2_MAGIC;
1293     DocumentParser::startParsing();
1294     m_sawError = false;
1295     m_sawCSS = false;
1296     m_sawXSLTransform = false;
1297     m_sawFirstElement = false;
1298 
1299     XMLDocumentParserScope scope(&amp;document()-&gt;cachedResourceLoader());
1300     if (m_parsingFragment)
1301         m_context = XMLParserContext::createMemoryParser(&amp;sax, this, chunk);
1302     else {
1303         ASSERT(!chunk.data());
1304         m_context = XMLParserContext::createStringParser(&amp;sax, this);
1305     }
1306 }
1307 
1308 void XMLDocumentParser::doEnd()
1309 {
1310     if (!isStopped()) {
1311         if (m_context) {
1312             // Tell libxml we&#39;re done.
1313             {
1314                 XMLDocumentParserScope scope(&amp;document()-&gt;cachedResourceLoader());
1315                 xmlParseChunk(context(), 0, 0, 1);
1316             }
1317 
1318             m_context = nullptr;
1319         }
1320     }
1321 
1322 #if ENABLE(XSLT)
1323     bool xmlViewerMode = !m_sawError &amp;&amp; !m_sawCSS &amp;&amp; !m_sawXSLTransform &amp;&amp; shouldRenderInXMLTreeViewerMode(*document());
1324     if (xmlViewerMode) {
1325         XMLTreeViewer xmlTreeViewer(*document());
1326         xmlTreeViewer.transformDocumentToTreeView();
1327     } else if (m_sawXSLTransform) {
1328         xmlDocPtr doc = xmlDocPtrForString(document()-&gt;cachedResourceLoader(), m_originalSourceForTransform.toString(), document()-&gt;url().string());
1329         document()-&gt;setTransformSource(makeUnique&lt;TransformSource&gt;(doc));
1330 
1331         document()-&gt;setParsing(false); // Make the document think it&#39;s done, so it will apply XSL stylesheets.
1332         document()-&gt;applyPendingXSLTransformsNowIfScheduled();
1333 
1334         // styleResolverChanged() call can detach the parser and null out its document.
1335         // In that case, we just bail out.
1336         if (isDetached())
1337             return;
1338 
1339         document()-&gt;setParsing(true);
1340         DocumentParser::stopParsing();
1341     }
1342 #endif
1343 }
1344 
1345 #if ENABLE(XSLT)
1346 static inline const char* nativeEndianUTF16Encoding()
1347 {
1348     const UChar BOM = 0xFEFF;
1349     const unsigned char BOMHighByte = *reinterpret_cast&lt;const unsigned char*&gt;(&amp;BOM);
1350     return BOMHighByte == 0xFF ? &quot;UTF-16LE&quot; : &quot;UTF-16BE&quot;;
1351 }
1352 
1353 xmlDocPtr xmlDocPtrForString(CachedResourceLoader&amp; cachedResourceLoader, const String&amp; source, const String&amp; url)
1354 {
1355     if (source.isEmpty())
1356         return nullptr;
1357 
1358     // Parse in a single chunk into an xmlDocPtr
1359     // FIXME: Hook up error handlers so that a failure to parse the main document results in
1360     // good error messages.
1361 
1362     const bool is8Bit = source.is8Bit();
1363     const char* characters = is8Bit ? reinterpret_cast&lt;const char*&gt;(source.characters8()) : reinterpret_cast&lt;const char*&gt;(source.characters16());
1364     size_t sizeInBytes = source.length() * (is8Bit ? sizeof(LChar) : sizeof(UChar));
1365     const char* encoding = is8Bit ? &quot;iso-8859-1&quot; : nativeEndianUTF16Encoding();
1366 
1367     XMLDocumentParserScope scope(&amp;cachedResourceLoader, errorFunc);
1368     return xmlReadMemory(characters, sizeInBytes, url.latin1().data(), encoding, XSLT_PARSE_OPTIONS);
1369 }
1370 #endif
1371 
1372 TextPosition XMLDocumentParser::textPosition() const
1373 {
1374     xmlParserCtxtPtr context = this-&gt;context();
1375     if (!context)
1376         return TextPosition();
1377     return TextPosition(OrdinalNumber::fromOneBasedInt(context-&gt;input-&gt;line),
1378                         OrdinalNumber::fromOneBasedInt(context-&gt;input-&gt;col));
1379 }
1380 
1381 bool XMLDocumentParser::shouldAssociateConsoleMessagesWithTextPosition() const
1382 {
1383     return !m_parserPaused &amp;&amp; !m_requestingScript;
1384 }
1385 
1386 void XMLDocumentParser::stopParsing()
1387 {
1388     if (m_sawError)
1389         insertErrorMessageBlock();
1390 
1391     DocumentParser::stopParsing();
1392     if (context())
1393         xmlStopParser(context());
1394 }
1395 
1396 void XMLDocumentParser::resumeParsing()
1397 {
1398     ASSERT(!isDetached());
1399     ASSERT(m_parserPaused);
1400 
1401     m_parserPaused = false;
1402 
1403     // First, execute any pending callbacks
1404     while (!m_pendingCallbacks-&gt;isEmpty()) {
1405         m_pendingCallbacks-&gt;callAndRemoveFirstCallback(this);
1406 
1407         // A callback paused the parser
1408         if (m_parserPaused)
1409             return;
1410     }
1411 
1412     // There is normally only one string left, so toString() shouldn&#39;t copy.
1413     // In any case, the XML parser runs on the main thread and it&#39;s OK if
1414     // the passed string has more than one reference.
1415     auto rest = m_pendingSrc.toString();
1416     m_pendingSrc.clear();
1417     append(rest.impl());
1418 
1419     // Finally, if finish() has been called and write() didn&#39;t result
1420     // in any further callbacks being queued, call end()
1421     if (m_finishCalled &amp;&amp; m_pendingCallbacks-&gt;isEmpty())
1422         end();
1423 }
1424 
1425 bool XMLDocumentParser::appendFragmentSource(const String&amp; chunk)
1426 {
1427     ASSERT(!m_context);
1428     ASSERT(m_parsingFragment);
1429 
1430     CString chunkAsUtf8 = chunk.utf8();
1431 
1432     // libxml2 takes an int for a length, and therefore can&#39;t handle XML chunks larger than 2 GiB.
1433     if (chunkAsUtf8.length() &gt; INT_MAX)
1434         return false;
1435 
1436     initializeParserContext(chunkAsUtf8);
1437     xmlParseContent(context());
1438     endDocument(); // Close any open text nodes.
1439 
1440     // FIXME: If this code is actually needed, it should probably move to finish()
1441     // XMLDocumentParserQt has a similar check (m_stream.error() == QXmlStreamReader::PrematureEndOfDocumentError) in doEnd().
1442     // Check if all the chunk has been processed.
1443     long bytesProcessed = xmlByteConsumed(context());
1444     if (bytesProcessed == -1 || ((unsigned long)bytesProcessed) != chunkAsUtf8.length()) {
1445         // FIXME: I don&#39;t believe we can hit this case without also having seen an error or a null byte.
1446         // If we hit this ASSERT, we&#39;ve found a test case which demonstrates the need for this code.
1447         ASSERT(m_sawError || (bytesProcessed &gt;= 0 &amp;&amp; !chunkAsUtf8.data()[bytesProcessed]));
1448         return false;
1449     }
1450 
1451     // No error if the chunk is well formed or it is not but we have no error.
1452     return context()-&gt;wellFormed || !xmlCtxtGetLastError(context());
1453 }
1454 
1455 // --------------------------------
1456 
1457 using AttributeParseState = Optional&lt;HashMap&lt;String, String&gt;&gt;;
1458 
1459 static void attributesStartElementNsHandler(void* closure, const xmlChar* xmlLocalName, const xmlChar* /*xmlPrefix*/, const xmlChar* /*xmlURI*/, int /*numNamespaces*/, const xmlChar** /*namespaces*/, int numAttributes, int /*numDefaulted*/, const xmlChar** libxmlAttributes)
1460 {
1461     if (strcmp(reinterpret_cast&lt;const char*&gt;(xmlLocalName), &quot;attrs&quot;) != 0)
1462         return;
1463 
1464     auto&amp; state = *static_cast&lt;AttributeParseState*&gt;(static_cast&lt;xmlParserCtxtPtr&gt;(closure)-&gt;_private);
1465 
1466     state = HashMap&lt;String, String&gt; { };
1467 
1468     xmlSAX2Attributes* attributes = reinterpret_cast&lt;xmlSAX2Attributes*&gt;(libxmlAttributes);
1469     for (int i = 0; i &lt; numAttributes; i++) {
1470         String attrLocalName = toString(attributes[i].localname);
1471         int valueLength = (int) (attributes[i].end - attributes[i].value);
1472         String attrValue = toString(attributes[i].value, valueLength);
1473         String attrPrefix = toString(attributes[i].prefix);
1474         String attrQName = attrPrefix.isEmpty() ? attrLocalName : attrPrefix + &quot;:&quot; + attrLocalName;
1475 
1476         state-&gt;set(attrQName, attrValue);
1477     }
1478 }
1479 
1480 Optional&lt;HashMap&lt;String, String&gt;&gt; parseAttributes(const String&amp; string)
1481 {
1482     String parseString = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;&lt;attrs &quot; + string + &quot; /&gt;&quot;;
1483 
1484     AttributeParseState attributes;
1485 
1486     xmlSAXHandler sax;
1487     memset(&amp;sax, 0, sizeof(sax));
1488     sax.startElementNs = attributesStartElementNsHandler;
1489     sax.initialized = XML_SAX2_MAGIC;
1490 
1491     auto parser = XMLParserContext::createStringParser(&amp;sax, &amp;attributes);
1492 
1493     // FIXME: Can we parse 8-bit strings directly as Latin-1 instead of upconverting to UTF-16?
1494     xmlParseChunk(parser-&gt;context(), reinterpret_cast&lt;const char*&gt;(StringView(parseString).upconvertedCharacters().get()), parseString.length() * sizeof(UChar), 1);
1495 
1496     return attributes;
1497 }
1498 
1499 }
    </pre>
  </body>
</html>
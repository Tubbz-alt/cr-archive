<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlock.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2007 David Smith (catfish.man@gmail.com)
   5  * Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Apple Inc. All rights reserved.
   6  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;RenderBlock.h&quot;
  26 
  27 #include &quot;AXObjectCache.h&quot;
  28 #include &quot;Document.h&quot;
  29 #include &quot;Editor.h&quot;
  30 #include &quot;Element.h&quot;
  31 #include &quot;EventRegion.h&quot;
  32 #include &quot;FloatQuad.h&quot;
  33 #include &quot;Frame.h&quot;
  34 #include &quot;FrameSelection.h&quot;
  35 #include &quot;FrameView.h&quot;
  36 #include &quot;GraphicsContext.h&quot;
  37 #include &quot;HTMLNames.h&quot;
  38 #include &quot;HitTestLocation.h&quot;
  39 #include &quot;HitTestResult.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  40 #include &quot;ImageBuffer.h&quot;</span>
  41 #include &quot;InlineElementBox.h&quot;
  42 #include &quot;InlineIterator.h&quot;
  43 #include &quot;InlineTextBox.h&quot;
  44 #include &quot;LayoutRepainter.h&quot;
  45 #include &quot;LogicalSelectionOffsetCaches.h&quot;
  46 #include &quot;OverflowEvent.h&quot;
  47 #include &quot;Page.h&quot;
  48 #include &quot;PaintInfo.h&quot;
  49 #include &quot;RenderBlockFlow.h&quot;
  50 #include &quot;RenderBoxFragmentInfo.h&quot;
  51 #include &quot;RenderButton.h&quot;
  52 #include &quot;RenderChildIterator.h&quot;
  53 #include &quot;RenderCombineText.h&quot;
  54 #include &quot;RenderDeprecatedFlexibleBox.h&quot;
  55 #include &quot;RenderFlexibleBox.h&quot;
  56 #include &quot;RenderFragmentedFlow.h&quot;
  57 #include &quot;RenderInline.h&quot;
  58 #include &quot;RenderIterator.h&quot;
  59 #include &quot;RenderLayer.h&quot;
  60 #include &quot;RenderLayoutState.h&quot;
  61 #include &quot;RenderListMarker.h&quot;
  62 #include &quot;RenderMenuList.h&quot;
  63 #include &quot;RenderSVGResourceClipper.h&quot;
  64 #include &quot;RenderSVGRoot.h&quot;
  65 #include &quot;RenderTableCell.h&quot;
  66 #include &quot;RenderTextFragment.h&quot;
  67 #include &quot;RenderTheme.h&quot;
  68 #include &quot;RenderTreeBuilder.h&quot;
  69 #include &quot;RenderTreePosition.h&quot;
  70 #include &quot;RenderView.h&quot;
  71 #include &quot;SVGSVGElement.h&quot;
  72 #include &quot;Settings.h&quot;
  73 #include &quot;ShadowRoot.h&quot;
  74 #include &quot;ShapeOutsideInfo.h&quot;
  75 #include &quot;TransformState.h&quot;
  76 #include &lt;wtf/IsoMallocInlines.h&gt;
  77 #include &lt;wtf/NeverDestroyed.h&gt;
  78 #include &lt;wtf/Optional.h&gt;
  79 #include &lt;wtf/SetForScope.h&gt;
  80 #include &lt;wtf/StackStats.h&gt;
  81 
  82 namespace WebCore {
  83 
  84 using namespace HTMLNames;
  85 using namespace WTF::Unicode;
  86 
  87 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderBlock);
  88 
  89 struct SameSizeAsRenderBlock : public RenderBox {
  90 };
  91 
  92 COMPILE_ASSERT(sizeof(RenderBlock) == sizeof(SameSizeAsRenderBlock), RenderBlock_should_stay_small);
  93 
  94 typedef HashMap&lt;const RenderBlock*, std::unique_ptr&lt;TrackedRendererListHashSet&gt;&gt; TrackedDescendantsMap;
  95 typedef HashMap&lt;const RenderBox*, std::unique_ptr&lt;HashSet&lt;const RenderBlock*&gt;&gt;&gt; TrackedContainerMap;
  96 
  97 static TrackedDescendantsMap* percentHeightDescendantsMap;
  98 static TrackedContainerMap* percentHeightContainerMap;
  99 
 100 static void insertIntoTrackedRendererMaps(const RenderBlock&amp; container, RenderBox&amp; descendant)
 101 {
 102     if (!percentHeightDescendantsMap) {
 103         percentHeightDescendantsMap = new TrackedDescendantsMap;
 104         percentHeightContainerMap = new TrackedContainerMap;
 105     }
 106 
 107     auto&amp; descendantSet = percentHeightDescendantsMap-&gt;ensure(&amp;container, [] {
 108         return makeUnique&lt;TrackedRendererListHashSet&gt;();
 109     }).iterator-&gt;value;
 110 
 111     bool added = descendantSet-&gt;add(&amp;descendant).isNewEntry;
 112     if (!added) {
 113         ASSERT(percentHeightContainerMap-&gt;get(&amp;descendant));
 114         ASSERT(percentHeightContainerMap-&gt;get(&amp;descendant)-&gt;contains(&amp;container));
 115         return;
 116     }
 117 
 118     auto&amp; containerSet = percentHeightContainerMap-&gt;ensure(&amp;descendant, [] {
 119         return makeUnique&lt;HashSet&lt;const RenderBlock*&gt;&gt;();
 120     }).iterator-&gt;value;
 121 
 122     ASSERT(!containerSet-&gt;contains(&amp;container));
 123     containerSet-&gt;add(&amp;container);
 124 }
 125 
 126 static void removeFromTrackedRendererMaps(RenderBox&amp; descendant)
 127 {
 128     if (!percentHeightDescendantsMap)
 129         return;
 130 
 131     std::unique_ptr&lt;HashSet&lt;const RenderBlock*&gt;&gt; containerSet = percentHeightContainerMap-&gt;take(&amp;descendant);
 132     if (!containerSet)
 133         return;
 134 
 135     for (auto* container : *containerSet) {
 136         // FIXME: Disabling this assert temporarily until we fix the layout
 137         // bugs associated with positioned objects not properly cleared from
 138         // their ancestor chain before being moved. See webkit bug 93766.
 139         // ASSERT(descendant-&gt;isDescendantOf(container));
 140         auto descendantsMapIterator = percentHeightDescendantsMap-&gt;find(container);
 141         ASSERT(descendantsMapIterator != percentHeightDescendantsMap-&gt;end());
 142         if (descendantsMapIterator == percentHeightDescendantsMap-&gt;end())
 143             continue;
 144         auto&amp; descendantSet = descendantsMapIterator-&gt;value;
 145         ASSERT(descendantSet-&gt;contains(&amp;descendant));
 146         descendantSet-&gt;remove(&amp;descendant);
 147         if (descendantSet-&gt;isEmpty())
 148             percentHeightDescendantsMap-&gt;remove(descendantsMapIterator);
 149     }
 150 }
 151 
 152 class PositionedDescendantsMap {
 153 public:
 154     enum class MoveDescendantToEnd { No, Yes };
 155     void addDescendant(const RenderBlock&amp; containingBlock, RenderBox&amp; positionedDescendant, MoveDescendantToEnd moveDescendantToEnd)
 156     {
 157         // Protect against double insert where a descendant would end up with multiple containing blocks.
 158         auto* previousContainingBlock = m_containerMap.get(&amp;positionedDescendant);
 159         if (previousContainingBlock &amp;&amp; previousContainingBlock != &amp;containingBlock) {
 160             if (auto* descendants = m_descendantsMap.get(previousContainingBlock))
 161                 descendants-&gt;remove(&amp;positionedDescendant);
 162         }
 163 
 164         auto&amp; descendants = m_descendantsMap.ensure(&amp;containingBlock, [] {
 165             return makeUnique&lt;TrackedRendererListHashSet&gt;();
 166         }).iterator-&gt;value;
 167 
 168         bool isNewEntry = moveDescendantToEnd == MoveDescendantToEnd::Yes ? descendants-&gt;appendOrMoveToLast(&amp;positionedDescendant).isNewEntry
 169             : descendants-&gt;add(&amp;positionedDescendant).isNewEntry;
 170         if (!isNewEntry) {
 171             ASSERT(m_containerMap.contains(&amp;positionedDescendant));
 172             return;
 173         }
 174         m_containerMap.set(&amp;positionedDescendant, &amp;containingBlock);
 175     }
 176 
 177     void removeDescendant(const RenderBox&amp; positionedDescendant)
 178     {
 179         auto* containingBlock = m_containerMap.take(&amp;positionedDescendant);
 180         if (!containingBlock)
 181             return;
 182 
 183         auto descendantsIterator = m_descendantsMap.find(containingBlock);
 184         ASSERT(descendantsIterator != m_descendantsMap.end());
 185         if (descendantsIterator == m_descendantsMap.end())
 186             return;
 187 
 188         auto&amp; descendants = descendantsIterator-&gt;value;
 189         ASSERT(descendants-&gt;contains(const_cast&lt;RenderBox*&gt;(&amp;positionedDescendant)));
 190 
 191         descendants-&gt;remove(const_cast&lt;RenderBox*&gt;(&amp;positionedDescendant));
 192         if (descendants-&gt;isEmpty())
 193             m_descendantsMap.remove(descendantsIterator);
 194     }
 195 
 196     void removeContainingBlock(const RenderBlock&amp; containingBlock)
 197     {
 198         auto descendants = m_descendantsMap.take(&amp;containingBlock);
 199         if (!descendants)
 200             return;
 201 
 202         for (auto* renderer : *descendants)
 203             m_containerMap.remove(renderer);
 204     }
 205 
 206     TrackedRendererListHashSet* positionedRenderers(const RenderBlock&amp; containingBlock) const
 207     {
 208         return m_descendantsMap.get(&amp;containingBlock);
 209     }
 210 
 211 private:
 212     using DescendantsMap = HashMap&lt;const RenderBlock*, std::unique_ptr&lt;TrackedRendererListHashSet&gt;&gt;;
 213     using ContainerMap = HashMap&lt;const RenderBox*, const RenderBlock*&gt;;
 214 
 215     DescendantsMap m_descendantsMap;
 216     ContainerMap m_containerMap;
 217 };
 218 
 219 static PositionedDescendantsMap&amp; positionedDescendantsMap()
 220 {
 221     static NeverDestroyed&lt;PositionedDescendantsMap&gt; mapForPositionedDescendants;
 222     return mapForPositionedDescendants;
 223 }
 224 
 225 typedef HashMap&lt;RenderBlock*, std::unique_ptr&lt;ListHashSet&lt;RenderInline*&gt;&gt;&gt; ContinuationOutlineTableMap;
 226 
 227 struct UpdateScrollInfoAfterLayoutTransaction {
 228     UpdateScrollInfoAfterLayoutTransaction(const RenderView&amp; view)
 229         : nestedCount(0)
 230         , view(&amp;view)
 231     {
 232     }
 233 
 234     int nestedCount;
 235     const RenderView* view;
 236     HashSet&lt;RenderBlock*&gt; blocks;
 237 };
 238 
 239 typedef Vector&lt;UpdateScrollInfoAfterLayoutTransaction&gt; DelayedUpdateScrollInfoStack;
 240 static std::unique_ptr&lt;DelayedUpdateScrollInfoStack&gt;&amp; updateScrollInfoAfterLayoutTransactionStack()
 241 {
 242     static NeverDestroyed&lt;std::unique_ptr&lt;DelayedUpdateScrollInfoStack&gt;&gt; delayedUpdatedScrollInfoStack;
 243     return delayedUpdatedScrollInfoStack;
 244 }
 245 
 246 // Allocated only when some of these fields have non-default values
 247 
 248 struct RenderBlockRareData {
 249     WTF_MAKE_NONCOPYABLE(RenderBlockRareData); WTF_MAKE_FAST_ALLOCATED;
 250 public:
 251     RenderBlockRareData()
 252     {
 253     }
 254 
 255     LayoutUnit m_paginationStrut;
 256     LayoutUnit m_pageLogicalOffset;
 257     LayoutUnit m_intrinsicBorderForFieldset;
 258 
 259     Optional&lt;WeakPtr&lt;RenderFragmentedFlow&gt;&gt; m_enclosingFragmentedFlow;
 260 };
 261 
 262 typedef HashMap&lt;const RenderBlock*, std::unique_ptr&lt;RenderBlockRareData&gt;&gt; RenderBlockRareDataMap;
 263 static RenderBlockRareDataMap* gRareDataMap;
 264 
 265 // This class helps dispatching the &#39;overflow&#39; event on layout change. overflow can be set on RenderBoxes, yet the existing code
 266 // only works on RenderBlocks. If this change, this class should be shared with other RenderBoxes.
 267 class OverflowEventDispatcher {
 268     WTF_MAKE_NONCOPYABLE(OverflowEventDispatcher);
 269 public:
 270     OverflowEventDispatcher(const RenderBlock* block)
 271         : m_block(block)
 272         , m_hadHorizontalLayoutOverflow(false)
 273         , m_hadVerticalLayoutOverflow(false)
 274     {
 275         m_shouldDispatchEvent = !m_block-&gt;isAnonymous() &amp;&amp; m_block-&gt;hasOverflowClip() &amp;&amp; m_block-&gt;document().hasListenerType(Document::OVERFLOWCHANGED_LISTENER);
 276         if (m_shouldDispatchEvent) {
 277             m_hadHorizontalLayoutOverflow = m_block-&gt;hasHorizontalLayoutOverflow();
 278             m_hadVerticalLayoutOverflow = m_block-&gt;hasVerticalLayoutOverflow();
 279         }
 280     }
 281 
 282     ~OverflowEventDispatcher()
 283     {
 284         if (!m_shouldDispatchEvent)
 285             return;
 286 
 287         bool hasHorizontalLayoutOverflow = m_block-&gt;hasHorizontalLayoutOverflow();
 288         bool hasVerticalLayoutOverflow = m_block-&gt;hasVerticalLayoutOverflow();
 289 
 290         bool horizontalLayoutOverflowChanged = hasHorizontalLayoutOverflow != m_hadHorizontalLayoutOverflow;
 291         bool verticalLayoutOverflowChanged = hasVerticalLayoutOverflow != m_hadVerticalLayoutOverflow;
 292         if (!horizontalLayoutOverflowChanged &amp;&amp; !verticalLayoutOverflowChanged)
 293             return;
 294 
 295         Ref&lt;OverflowEvent&gt; overflowEvent = OverflowEvent::create(horizontalLayoutOverflowChanged, hasHorizontalLayoutOverflow, verticalLayoutOverflowChanged, hasVerticalLayoutOverflow);
 296         overflowEvent-&gt;setTarget(m_block-&gt;element());
 297         m_block-&gt;document().enqueueOverflowEvent(WTFMove(overflowEvent));
 298     }
 299 
 300 private:
 301     const RenderBlock* m_block;
 302     bool m_shouldDispatchEvent;
 303     bool m_hadHorizontalLayoutOverflow;
 304     bool m_hadVerticalLayoutOverflow;
 305 };
 306 
 307 RenderBlock::RenderBlock(Element&amp; element, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 308     : RenderBox(element, WTFMove(style), baseTypeFlags | RenderBlockFlag)
 309 {
 310 }
 311 
 312 RenderBlock::RenderBlock(Document&amp; document, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 313     : RenderBox(document, WTFMove(style), baseTypeFlags | RenderBlockFlag)
 314 {
 315 }
 316 
 317 static void removeBlockFromPercentageDescendantAndContainerMaps(RenderBlock* block)
 318 {
 319     if (!percentHeightDescendantsMap)
 320         return;
 321     std::unique_ptr&lt;TrackedRendererListHashSet&gt; descendantSet = percentHeightDescendantsMap-&gt;take(block);
 322     if (!descendantSet)
 323         return;
 324 
 325     for (auto* descendant : *descendantSet) {
 326         auto it = percentHeightContainerMap-&gt;find(descendant);
 327         ASSERT(it != percentHeightContainerMap-&gt;end());
 328         if (it == percentHeightContainerMap-&gt;end())
 329             continue;
 330         auto* containerSet = it-&gt;value.get();
 331         ASSERT(containerSet-&gt;contains(block));
 332         containerSet-&gt;remove(block);
 333         if (containerSet-&gt;isEmpty())
 334             percentHeightContainerMap-&gt;remove(it);
 335     }
 336 }
 337 
 338 RenderBlock::~RenderBlock()
 339 {
 340     // Blocks can be added to gRareDataMap during willBeDestroyed(), so this code can&#39;t move there.
 341     if (gRareDataMap)
 342         gRareDataMap-&gt;remove(this);
 343 
 344     // Do not add any more code here. Add it to willBeDestroyed() instead.
 345 }
 346 
 347 // Note that this is not called for RenderBlockFlows.
 348 void RenderBlock::willBeDestroyed()
 349 {
 350     if (!renderTreeBeingDestroyed()) {
 351         if (parent())
 352             parent()-&gt;dirtyLinesFromChangedChild(*this);
 353     }
 354 
 355     blockWillBeDestroyed();
 356 
 357     RenderBox::willBeDestroyed();
 358 }
 359 
 360 void RenderBlock::blockWillBeDestroyed()
 361 {
 362     removeFromUpdateScrollInfoAfterLayoutTransaction();
 363 
 364     removeBlockFromPercentageDescendantAndContainerMaps(this);
 365     positionedDescendantsMap().removeContainingBlock(*this);
 366 }
 367 
 368 bool RenderBlock::hasRareData() const
 369 {
 370     return gRareDataMap ? gRareDataMap-&gt;contains(this) : false;
 371 }
 372 
 373 void RenderBlock::removePositionedObjectsIfNeeded(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
 374 {
 375     bool hadTransform = oldStyle.hasTransformRelatedProperty();
 376     bool willHaveTransform = newStyle.hasTransformRelatedProperty();
 377     if (oldStyle.position() == newStyle.position() &amp;&amp; hadTransform == willHaveTransform)
 378         return;
 379 
 380     // We are no longer the containing block for fixed descendants.
 381     if (hadTransform &amp;&amp; !willHaveTransform) {
 382         // Our positioned descendants will be inserted into a new containing block&#39;s positioned objects list during the next layout.
 383         removePositionedObjects(nullptr, NewContainingBlock);
 384         return;
 385     }
 386 
 387     // We are no longer the containing block for absolute positioned descendants.
 388     if (newStyle.position() == PositionType::Static &amp;&amp; !willHaveTransform) {
 389         // Our positioned descendants will be inserted into a new containing block&#39;s positioned objects list during the next layout.
 390         removePositionedObjects(nullptr, NewContainingBlock);
 391         return;
 392     }
 393 
 394     // We are a new containing block.
 395     if (oldStyle.position() == PositionType::Static &amp;&amp; !hadTransform) {
 396         // Remove our absolutely positioned descendants from their current containing block.
 397         // They will be inserted into our positioned objects list during layout.
 398         auto* containingBlock = parent();
 399         while (containingBlock &amp;&amp; !is&lt;RenderView&gt;(*containingBlock)
 400             &amp;&amp; (containingBlock-&gt;style().position() == PositionType::Static || (containingBlock-&gt;isInline() &amp;&amp; !containingBlock-&gt;isReplaced()))) {
 401             if (containingBlock-&gt;style().position() == PositionType::Relative &amp;&amp; containingBlock-&gt;isInline() &amp;&amp; !containingBlock-&gt;isReplaced()) {
 402                 containingBlock = containingBlock-&gt;containingBlock();
 403                 break;
 404             }
 405             containingBlock = containingBlock-&gt;parent();
 406         }
 407         if (containingBlock &amp;&amp; is&lt;RenderBlock&gt;(*containingBlock))
 408             downcast&lt;RenderBlock&gt;(*containingBlock).removePositionedObjects(this, NewContainingBlock);
 409     }
 410 }
 411 
 412 void RenderBlock::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
 413 {
 414     const RenderStyle* oldStyle = hasInitializedStyle() ? &amp;style() : nullptr;
 415     setReplaced(newStyle.isDisplayInlineType());
 416     if (oldStyle)
 417         removePositionedObjectsIfNeeded(*oldStyle, newStyle);
 418     RenderBox::styleWillChange(diff, newStyle);
 419 }
 420 
 421 static bool borderOrPaddingLogicalWidthChanged(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
 422 {
 423     if (newStyle.isHorizontalWritingMode()) {
 424         return oldStyle.borderLeftWidth() != newStyle.borderLeftWidth()
 425             || oldStyle.borderRightWidth() != newStyle.borderRightWidth()
 426             || oldStyle.paddingLeft() != newStyle.paddingLeft()
 427             || oldStyle.paddingRight() != newStyle.paddingRight();
 428     }
 429 
 430     return oldStyle.borderTopWidth() != newStyle.borderTopWidth()
 431         || oldStyle.borderBottomWidth() != newStyle.borderBottomWidth()
 432         || oldStyle.paddingTop() != newStyle.paddingTop()
 433         || oldStyle.paddingBottom() != newStyle.paddingBottom();
 434 }
 435 
 436 void RenderBlock::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
 437 {
 438     bool hadTransform = hasTransform();
 439     RenderBox::styleDidChange(diff, oldStyle);
 440 
 441     if (hadTransform != hasTransform())
 442         adjustFragmentedFlowStateOnContainingBlockChangeIfNeeded();
 443 
 444     propagateStyleToAnonymousChildren(PropagateToBlockChildrenOnly);
 445 
 446     // It&#39;s possible for our border/padding to change, but for the overall logical width of the block to
 447     // end up being the same. We keep track of this change so in layoutBlock, we can know to set relayoutChildren=true.
 448     setShouldForceRelayoutChildren(oldStyle &amp;&amp; diff == StyleDifference::Layout &amp;&amp; needsLayout() &amp;&amp; borderOrPaddingLogicalWidthChanged(*oldStyle, style()));
 449 }
 450 
 451 RenderPtr&lt;RenderBlock&gt; RenderBlock::clone() const
 452 {
 453     RenderPtr&lt;RenderBlock&gt; cloneBlock;
 454     if (isAnonymousBlock()) {
 455         cloneBlock = RenderPtr&lt;RenderBlock&gt;(createAnonymousBlock());
 456         cloneBlock-&gt;setChildrenInline(childrenInline());
 457     } else {
 458         RenderTreePosition insertionPosition(*parent());
 459         cloneBlock = static_pointer_cast&lt;RenderBlock&gt;(element()-&gt;createElementRenderer(RenderStyle::clone(style()), insertionPosition));
 460         cloneBlock-&gt;initializeStyle();
 461 
 462         // This takes care of setting the right value of childrenInline in case
 463         // generated content is added to cloneBlock and &#39;this&#39; does not have
 464         // generated content added yet.
 465         cloneBlock-&gt;setChildrenInline(cloneBlock-&gt;firstChild() ? cloneBlock-&gt;firstChild()-&gt;isInline() : childrenInline());
 466     }
 467     cloneBlock-&gt;setFragmentedFlowState(fragmentedFlowState());
 468     return cloneBlock;
 469 }
 470 
 471 void RenderBlock::deleteLines()
 472 {
 473     if (AXObjectCache* cache = document().existingAXObjectCache())
 474         cache-&gt;deferRecomputeIsIgnored(element());
 475 }
 476 
 477 bool RenderBlock::childrenPreventSelfCollapsing() const
 478 {
 479     // Whether or not we collapse is dependent on whether all our normal flow children
 480     // are also self-collapsing.
 481     for (RenderBox* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
 482         if (child-&gt;isFloatingOrOutOfFlowPositioned())
 483             continue;
 484         if (!child-&gt;isSelfCollapsingBlock())
 485             return true;
 486     }
 487     return false;
 488 }
 489 
 490 bool RenderBlock::isSelfCollapsingBlock() const
 491 {
 492     // We are not self-collapsing if we
 493     // (a) have a non-zero height according to layout (an optimization to avoid wasting time)
 494     // (b) are a table,
 495     // (c) have border/padding,
 496     // (d) have a min-height
 497     // (e) have specified that one of our margins can&#39;t collapse using a CSS extension
 498     if (logicalHeight() &gt; 0
 499         || isTable() || borderAndPaddingLogicalHeight()
 500         || style().logicalMinHeight().isPositive()
 501         || style().marginBeforeCollapse() == MarginCollapse::Separate || style().marginAfterCollapse() == MarginCollapse::Separate)
 502         return false;
 503 
 504     Length logicalHeightLength = style().logicalHeight();
 505     bool hasAutoHeight = logicalHeightLength.isAuto();
 506     if (logicalHeightLength.isPercentOrCalculated() &amp;&amp; !document().inQuirksMode()) {
 507         hasAutoHeight = true;
 508         for (RenderBlock* cb = containingBlock(); cb &amp;&amp; !is&lt;RenderView&gt;(*cb); cb = cb-&gt;containingBlock()) {
 509             if (cb-&gt;style().logicalHeight().isFixed() || cb-&gt;isTableCell())
 510                 hasAutoHeight = false;
 511         }
 512     }
 513 
 514     // If the height is 0 or auto, then whether or not we are a self-collapsing block depends
 515     // on whether we have content that is all self-collapsing or not.
 516     if (hasAutoHeight || ((logicalHeightLength.isFixed() || logicalHeightLength.isPercentOrCalculated()) &amp;&amp; logicalHeightLength.isZero()))
 517         return !childrenPreventSelfCollapsing();
 518 
 519     return false;
 520 }
 521 
 522 static inline UpdateScrollInfoAfterLayoutTransaction* currentUpdateScrollInfoAfterLayoutTransaction()
 523 {
 524     if (!updateScrollInfoAfterLayoutTransactionStack())
 525         return nullptr;
 526     return &amp;updateScrollInfoAfterLayoutTransactionStack()-&gt;last();
 527 }
 528 
 529 void RenderBlock::beginUpdateScrollInfoAfterLayoutTransaction()
 530 {
 531     if (!updateScrollInfoAfterLayoutTransactionStack())
 532         updateScrollInfoAfterLayoutTransactionStack() = makeUnique&lt;DelayedUpdateScrollInfoStack&gt;();
 533     if (updateScrollInfoAfterLayoutTransactionStack()-&gt;isEmpty() || currentUpdateScrollInfoAfterLayoutTransaction()-&gt;view != &amp;view())
 534         updateScrollInfoAfterLayoutTransactionStack()-&gt;append(UpdateScrollInfoAfterLayoutTransaction(view()));
 535     ++currentUpdateScrollInfoAfterLayoutTransaction()-&gt;nestedCount;
 536 }
 537 
 538 void RenderBlock::endAndCommitUpdateScrollInfoAfterLayoutTransaction()
 539 {
 540     UpdateScrollInfoAfterLayoutTransaction* transaction = currentUpdateScrollInfoAfterLayoutTransaction();
 541     ASSERT(transaction);
 542     ASSERT(transaction-&gt;view == &amp;view());
 543     if (--transaction-&gt;nestedCount)
 544         return;
 545 
 546     // Calling RenderLayer::updateScrollInfoAfterLayout() may cause its associated block to layout again and
 547     // updates its scroll info (i.e. call RenderBlock::updateScrollInfoAfterLayout()). We remove |transaction|
 548     // from the transaction stack to ensure that all subsequent calls to RenderBlock::updateScrollInfoAfterLayout()
 549     // are dispatched immediately. That is, to ensure that such subsequent calls aren&#39;t added to |transaction|
 550     // while we are processing it.
 551     auto blocksToUpdate = copyToVector(transaction-&gt;blocks);
 552     updateScrollInfoAfterLayoutTransactionStack()-&gt;removeLast();
 553     if (updateScrollInfoAfterLayoutTransactionStack()-&gt;isEmpty())
 554         updateScrollInfoAfterLayoutTransactionStack() = nullptr;
 555 
 556     for (auto* block : blocksToUpdate) {
 557         ASSERT(block-&gt;hasOverflowClip());
 558         block-&gt;layer()-&gt;updateScrollInfoAfterLayout();
 559         block-&gt;clearLayoutOverflow();
 560     }
 561 }
 562 
 563 void RenderBlock::removeFromUpdateScrollInfoAfterLayoutTransaction()
 564 {
 565     if (UNLIKELY(updateScrollInfoAfterLayoutTransactionStack().get() != 0)) {
 566         UpdateScrollInfoAfterLayoutTransaction* transaction = currentUpdateScrollInfoAfterLayoutTransaction();
 567         ASSERT(transaction);
 568         if (transaction-&gt;view == &amp;view())
 569             transaction-&gt;blocks.remove(this);
 570     }
 571 }
 572 
 573 void RenderBlock::updateScrollInfoAfterLayout()
 574 {
 575     if (!hasOverflowClip())
 576         return;
 577 
 578     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=97937
 579     // Workaround for now. We cannot delay the scroll info for overflow
 580     // for items with opposite writing directions, as the contents needs
 581     // to overflow in that direction
 582     if (!style().isFlippedBlocksWritingMode()) {
 583         UpdateScrollInfoAfterLayoutTransaction* transaction = currentUpdateScrollInfoAfterLayoutTransaction();
 584         if (transaction &amp;&amp; transaction-&gt;view == &amp;view()) {
 585             transaction-&gt;blocks.add(this);
 586             return;
 587         }
 588     }
 589     if (layer())
 590         layer()-&gt;updateScrollInfoAfterLayout();
 591 }
 592 
 593 void RenderBlock::layout()
 594 {
 595     StackStats::LayoutCheckPoint layoutCheckPoint;
 596     OverflowEventDispatcher dispatcher(this);
 597 
 598     // Table cells call layoutBlock directly, so don&#39;t add any logic here.  Put code into
 599     // layoutBlock().
 600     layoutBlock(false);
 601 
 602     // It&#39;s safe to check for control clip here, since controls can never be table cells.
 603     // If we have a lightweight clip, there can never be any overflow from children.
 604     UpdateScrollInfoAfterLayoutTransaction* transaction = currentUpdateScrollInfoAfterLayoutTransaction();
 605     bool isDelayingUpdateScrollInfoAfterLayoutInView = transaction &amp;&amp; transaction-&gt;view == &amp;view();
 606     if (hasControlClip() &amp;&amp; m_overflow &amp;&amp; !isDelayingUpdateScrollInfoAfterLayoutInView)
 607         clearLayoutOverflow();
 608 
 609     invalidateBackgroundObscurationStatus();
 610 }
 611 
 612 static RenderBlockRareData* getBlockRareData(const RenderBlock&amp; block)
 613 {
 614     return gRareDataMap ? gRareDataMap-&gt;get(&amp;block) : nullptr;
 615 }
 616 
 617 static RenderBlockRareData&amp; ensureBlockRareData(const RenderBlock&amp; block)
 618 {
 619     if (!gRareDataMap)
 620         gRareDataMap = new RenderBlockRareDataMap;
 621 
 622     auto&amp; rareData = gRareDataMap-&gt;add(&amp;block, nullptr).iterator-&gt;value;
 623     if (!rareData)
 624         rareData = makeUnique&lt;RenderBlockRareData&gt;();
 625     return *rareData.get();
 626 }
 627 
 628 void RenderBlock::preparePaginationBeforeBlockLayout(bool&amp; relayoutChildren)
 629 {
 630     // Fragments changing widths can force us to relayout our children.
 631     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
 632     if (fragmentedFlow)
 633         fragmentedFlow-&gt;logicalWidthChangedInFragmentsForBlock(this, relayoutChildren);
 634 }
 635 
 636 bool RenderBlock::recomputeLogicalWidth()
 637 {
 638     LayoutUnit oldWidth = logicalWidth();
 639 
 640     updateLogicalWidth();
 641 
 642     bool hasBorderOrPaddingLogicalWidthChanged = this-&gt;hasBorderOrPaddingLogicalWidthChanged();
 643     setShouldForceRelayoutChildren(false);
 644 
 645     return oldWidth != logicalWidth() || hasBorderOrPaddingLogicalWidthChanged;
 646 }
 647 
 648 void RenderBlock::layoutBlock(bool, LayoutUnit)
 649 {
 650     ASSERT_NOT_REACHED();
 651     clearNeedsLayout();
 652 }
 653 
 654 void RenderBlock::addOverflowFromChildren()
 655 {
 656     if (childrenInline())
 657         addOverflowFromInlineChildren();
 658     else
 659         addOverflowFromBlockChildren();
 660 
 661     // If this block is flowed inside a flow thread, make sure its overflow is propagated to the containing fragments.
 662     if (m_overflow) {
 663         if (RenderFragmentedFlow* containingFragmentedFlow = enclosingFragmentedFlow())
 664             containingFragmentedFlow-&gt;addFragmentsVisualOverflow(this, m_overflow-&gt;visualOverflowRect());
 665     }
 666 }
 667 
 668 // Overflow is always relative to the border-box of the element in question.
 669 // Therefore, if the element has a vertical scrollbar placed on the left, an overflow rect at x=2px would conceptually intersect the scrollbar.
 670 void RenderBlock::computeOverflow(LayoutUnit oldClientAfterEdge, bool)
 671 {
 672     clearOverflow();
 673     addOverflowFromChildren();
 674 
 675     addOverflowFromPositionedObjects();
 676 
 677     if (hasOverflowClip()) {
 678         // When we have overflow clip, propagate the original spillout since it will include collapsed bottom margins
 679         // and bottom padding.  Set the axis we don&#39;t care about to be 1, since we want this overflow to always
 680         // be considered reachable.
 681         LayoutRect clientRect(flippedClientBoxRect());
 682         LayoutRect rectToApply;
 683         if (isHorizontalWritingMode())
 684             rectToApply = LayoutRect(clientRect.x(), clientRect.y(), 1_lu, std::max(0_lu, oldClientAfterEdge - clientRect.y()));
 685         else
 686             rectToApply = LayoutRect(clientRect.x(), clientRect.y(), std::max(0_lu, oldClientAfterEdge - clientRect.x()), 1_lu);
 687         addLayoutOverflow(rectToApply);
 688         if (hasRenderOverflow())
 689             m_overflow-&gt;setLayoutClientAfterEdge(oldClientAfterEdge);
 690     }
 691 
 692     // Add visual overflow from box-shadow, border-image-outset and outline.
 693     addVisualEffectOverflow();
 694 
 695     // Add visual overflow from theme.
 696     addVisualOverflowFromTheme();
 697 }
 698 
 699 void RenderBlock::clearLayoutOverflow()
 700 {
 701     if (!m_overflow)
 702         return;
 703 
 704     if (visualOverflowRect() == borderBoxRect()) {
 705         // FIXME: Implement complete solution for fragments overflow.
 706         clearOverflow();
 707         return;
 708     }
 709 
 710     m_overflow-&gt;setLayoutOverflow(borderBoxRect());
 711 }
 712 
 713 void RenderBlock::addOverflowFromBlockChildren()
 714 {
 715     for (auto* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
 716         if (!child-&gt;isFloatingOrOutOfFlowPositioned())
 717             addOverflowFromChild(child);
 718     }
 719 }
 720 
 721 void RenderBlock::addOverflowFromPositionedObjects()
 722 {
 723     TrackedRendererListHashSet* positionedDescendants = positionedObjects();
 724     if (!positionedDescendants)
 725         return;
 726 
 727     for (auto it = positionedDescendants-&gt;begin(), end = positionedDescendants-&gt;end(); it != end; ++it) {
 728         RenderBox* positionedObject = *it;
 729 
 730         // Fixed positioned elements don&#39;t contribute to layout overflow, since they don&#39;t scroll with the content.
 731         if (positionedObject-&gt;style().position() != PositionType::Fixed)
 732             addOverflowFromChild(positionedObject, { positionedObject-&gt;x(), positionedObject-&gt;y() });
 733     }
 734 }
 735 
 736 void RenderBlock::addVisualOverflowFromTheme()
 737 {
 738     if (!style().hasAppearance())
 739         return;
 740 
 741     FloatRect inflatedRect = borderBoxRect();
 742     theme().adjustRepaintRect(*this, inflatedRect);
 743     addVisualOverflow(snappedIntRect(LayoutRect(inflatedRect)));
 744 
 745     if (RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow())
 746         fragmentedFlow-&gt;addFragmentsVisualOverflowFromTheme(this);
 747 }
 748 
 749 LayoutUnit RenderBlock::computeStartPositionDeltaForChildAvoidingFloats(const RenderBox&amp; child, LayoutUnit childMarginStart, RenderFragmentContainer* fragment)
 750 {
 751     LayoutUnit startPosition = startOffsetForContent(fragment);
 752 
 753     // Add in our start margin.
 754     LayoutUnit oldPosition = startPosition + childMarginStart;
 755     LayoutUnit newPosition = oldPosition;
 756 
 757     LayoutUnit blockOffset = logicalTopForChild(child);
 758     if (fragment)
 759         blockOffset = std::max(blockOffset, blockOffset + (fragment-&gt;logicalTopForFragmentedFlowContent() - offsetFromLogicalTopOfFirstPage()));
 760 
 761     LayoutUnit startOff = startOffsetForLineInFragment(blockOffset, DoNotIndentText, fragment, logicalHeightForChild(child));
 762 
 763     if (style().textAlign() != TextAlignMode::WebKitCenter &amp;&amp; !child.style().marginStartUsing(&amp;style()).isAuto()) {
 764         if (childMarginStart &lt; 0)
 765             startOff += childMarginStart;
 766         newPosition = std::max(newPosition, startOff); // Let the float sit in the child&#39;s margin if it can fit.
 767     } else if (startOff != startPosition)
 768         newPosition = startOff + childMarginStart;
 769 
 770     return newPosition - oldPosition;
 771 }
 772 
 773 void RenderBlock::setLogicalLeftForChild(RenderBox&amp; child, LayoutUnit logicalLeft, ApplyLayoutDeltaMode applyDelta)
 774 {
 775     if (isHorizontalWritingMode()) {
 776         if (applyDelta == ApplyLayoutDelta)
 777             view().frameView().layoutContext().addLayoutDelta(LayoutSize(child.x() - logicalLeft, 0_lu));
 778         child.setX(logicalLeft);
 779     } else {
 780         if (applyDelta == ApplyLayoutDelta)
 781             view().frameView().layoutContext().addLayoutDelta(LayoutSize(0_lu, child.y() - logicalLeft));
 782         child.setY(logicalLeft);
 783     }
 784 }
 785 
 786 void RenderBlock::setLogicalTopForChild(RenderBox&amp; child, LayoutUnit logicalTop, ApplyLayoutDeltaMode applyDelta)
 787 {
 788     if (isHorizontalWritingMode()) {
 789         if (applyDelta == ApplyLayoutDelta)
 790             view().frameView().layoutContext().addLayoutDelta(LayoutSize(0_lu, child.y() - logicalTop));
 791         child.setY(logicalTop);
 792     } else {
 793         if (applyDelta == ApplyLayoutDelta)
 794             view().frameView().layoutContext().addLayoutDelta(LayoutSize(child.x() - logicalTop, 0_lu));
 795         child.setX(logicalTop);
 796     }
 797 }
 798 
 799 void RenderBlock::updateBlockChildDirtyBitsBeforeLayout(bool relayoutChildren, RenderBox&amp; child)
 800 {
 801     if (child.isOutOfFlowPositioned())
 802         return;
 803 
 804     // FIXME: Technically percentage height objects only need a relayout if their percentage isn&#39;t going to be turned into
 805     // an auto value. Add a method to determine this, so that we can avoid the relayout.
 806     if (relayoutChildren || (child.hasRelativeLogicalHeight() &amp;&amp; !isRenderView()))
 807         child.setChildNeedsLayout(MarkOnlyThis);
 808 
 809     // If relayoutChildren is set and the child has percentage padding or an embedded content box, we also need to invalidate the childs pref widths.
 810     if (relayoutChildren &amp;&amp; child.needsPreferredWidthsRecalculation())
 811         child.setPreferredLogicalWidthsDirty(true, MarkOnlyThis);
 812 }
 813 
 814 void RenderBlock::dirtyForLayoutFromPercentageHeightDescendants()
 815 {
 816     if (!percentHeightDescendantsMap)
 817         return;
 818 
 819     TrackedRendererListHashSet* descendants = percentHeightDescendantsMap-&gt;get(this);
 820     if (!descendants)
 821         return;
 822 
 823     for (auto it = descendants-&gt;begin(), end = descendants-&gt;end(); it != end; ++it) {
 824         auto* box = *it;
 825         // Let&#39;s not dirty the height perecentage descendant when it has an absolutely positioned containing block ancestor. We should be able to dirty such boxes through the regular invalidation logic.
 826         bool descendantNeedsLayout = true;
 827         for (auto* ancestor = box-&gt;containingBlock(); ancestor &amp;&amp; ancestor != this; ancestor = ancestor-&gt;containingBlock()) {
 828             if (ancestor-&gt;isOutOfFlowPositioned()) {
 829                 descendantNeedsLayout = false;
 830                 break;
 831             }
 832         }
 833         if (!descendantNeedsLayout)
 834             continue;
 835 
 836         while (box != this) {
 837             if (box-&gt;normalChildNeedsLayout())
 838                 break;
 839             box-&gt;setChildNeedsLayout(MarkOnlyThis);
 840 
 841             // If the width of an image is affected by the height of a child (e.g., an image with an aspect ratio),
 842             // then we have to dirty preferred widths, since even enclosing blocks can become dirty as a result.
 843             // (A horizontal flexbox that contains an inline image wrapped in an anonymous block for example.)
 844             if (box-&gt;hasAspectRatio())
 845                 box-&gt;setPreferredLogicalWidthsDirty(true);
 846             auto* containingBlock = box-&gt;containingBlock();
 847             // Mark the svg ancestor chain dirty as we walk to the containing block. containingBlock() just skips them. See webkit.org/b/183874.
 848             if (is&lt;SVGElement&gt;(box-&gt;element()) &amp;&amp; containingBlock != box-&gt;parent()) {
 849                 auto* ancestor = box-&gt;parent();
 850                 ASSERT(ancestor-&gt;isDescendantOf(containingBlock));
 851                 while (ancestor != containingBlock) {
 852                     ancestor-&gt;setChildNeedsLayout(MarkOnlyThis);
 853                     // This is the topmost SVG root, no need to go any further.
 854                     if (is&lt;SVGSVGElement&gt;(ancestor-&gt;element()) &amp;&amp; !downcast&lt;SVGSVGElement&gt;(*ancestor-&gt;element()).ownerSVGElement())
 855                         break;
 856                     ancestor = ancestor-&gt;parent();
 857                 }
 858             }
 859             box = containingBlock;
 860             ASSERT(box);
 861             if (!box)
 862                 break;
 863         }
 864     }
 865 }
 866 
 867 void RenderBlock::simplifiedNormalFlowLayout()
 868 {
 869     if (childrenInline()) {
 870         ListHashSet&lt;RootInlineBox*&gt; lineBoxes;
 871         for (InlineWalker walker(*this); !walker.atEnd(); walker.advance()) {
 872             RenderObject&amp; renderer = *walker.current();
 873             if (!renderer.isOutOfFlowPositioned() &amp;&amp; (renderer.isReplaced() || renderer.isFloating())) {
 874                 RenderBox&amp; box = downcast&lt;RenderBox&gt;(renderer);
 875                 box.layoutIfNeeded();
 876                 if (box.inlineBoxWrapper())
 877                     lineBoxes.add(&amp;box.inlineBoxWrapper()-&gt;root());
 878             } else if (is&lt;RenderText&gt;(renderer) || (is&lt;RenderInline&gt;(renderer) &amp;&amp; !walker.atEndOfInline()))
 879                 renderer.clearNeedsLayout();
 880         }
 881 
 882         // FIXME: Glyph overflow will get lost in this case, but not really a big deal.
 883         // FIXME: Find a way to invalidate the knownToHaveNoOverflow flag on the InlineBoxes.
 884         GlyphOverflowAndFallbackFontsMap textBoxDataMap;
 885         for (auto it = lineBoxes.begin(), end = lineBoxes.end(); it != end; ++it) {
 886             RootInlineBox* box = *it;
 887             box-&gt;computeOverflow(box-&gt;lineTop(), box-&gt;lineBottom(), textBoxDataMap);
 888         }
 889     } else {
 890         for (auto* box = firstChildBox(); box; box = box-&gt;nextSiblingBox()) {
 891             if (!box-&gt;isOutOfFlowPositioned())
 892                 box-&gt;layoutIfNeeded();
 893         }
 894     }
 895 }
 896 
 897 bool RenderBlock::canPerformSimplifiedLayout() const
 898 {
 899     return (posChildNeedsLayout() || needsSimplifiedNormalFlowLayout()) &amp;&amp; !normalChildNeedsLayout() &amp;&amp; !selfNeedsLayout();
 900 }
 901 
 902 bool RenderBlock::simplifiedLayout()
 903 {
 904     if (!canPerformSimplifiedLayout())
 905         return false;
 906 
 907     LayoutStateMaintainer statePusher(*this, locationOffset(), hasTransform() || hasReflection() || style().isFlippedBlocksWritingMode());
 908     if (needsPositionedMovementLayout() &amp;&amp; !tryLayoutDoingPositionedMovementOnly())
 909         return false;
 910 
 911     // Lay out positioned descendants or objects that just need to recompute overflow.
 912     if (needsSimplifiedNormalFlowLayout())
 913         simplifiedNormalFlowLayout();
 914 
 915     // Make sure a forced break is applied after the content if we are a flow thread in a simplified layout.
 916     // This ensures the size information is correctly computed for the last auto-height fragment receiving content.
 917     if (is&lt;RenderFragmentedFlow&gt;(*this))
 918         downcast&lt;RenderFragmentedFlow&gt;(*this).applyBreakAfterContent(clientLogicalBottom());
 919 
 920     // Lay out our positioned objects if our positioned child bit is set.
 921     // Also, if an absolute position element inside a relative positioned container moves, and the absolute element has a fixed position
 922     // child, neither the fixed element nor its container learn of the movement since posChildNeedsLayout() is only marked as far as the
 923     // relative positioned container. So if we can have fixed pos objects in our positioned objects list check if any of them
 924     // are statically positioned and thus need to move with their absolute ancestors.
 925     bool canContainFixedPosObjects = canContainFixedPositionObjects();
 926     if (posChildNeedsLayout() || canContainFixedPosObjects)
 927         layoutPositionedObjects(false, !posChildNeedsLayout() &amp;&amp; canContainFixedPosObjects);
 928 
 929     // Recompute our overflow information.
 930     // FIXME: We could do better here by computing a temporary overflow object from layoutPositionedObjects and only
 931     // updating our overflow if we either used to have overflow or if the new temporary object has overflow.
 932     // For now just always recompute overflow.  This is no worse performance-wise than the old code that called rightmostPosition and
 933     // lowestPosition on every relayout so it&#39;s not a regression.
 934     // computeOverflow expects the bottom edge before we clamp our height. Since this information isn&#39;t available during
 935     // simplifiedLayout, we cache the value in m_overflow.
 936     LayoutUnit oldClientAfterEdge = hasRenderOverflow() ? m_overflow-&gt;layoutClientAfterEdge() : clientLogicalBottom();
 937     computeOverflow(oldClientAfterEdge, true);
 938 
 939     updateLayerTransform();
 940 
 941     updateScrollInfoAfterLayout();
 942 
 943     clearNeedsLayout();
 944     return true;
 945 }
 946 
 947 void RenderBlock::markFixedPositionObjectForLayoutIfNeeded(RenderBox&amp; positionedChild)
 948 {
 949     if (positionedChild.style().position() != PositionType::Fixed)
 950         return;
 951 
 952     bool hasStaticBlockPosition = positionedChild.style().hasStaticBlockPosition(isHorizontalWritingMode());
 953     bool hasStaticInlinePosition = positionedChild.style().hasStaticInlinePosition(isHorizontalWritingMode());
 954     if (!hasStaticBlockPosition &amp;&amp; !hasStaticInlinePosition)
 955         return;
 956 
 957     auto* parent = positionedChild.parent();
 958     while (parent &amp;&amp; !is&lt;RenderView&gt;(*parent) &amp;&amp; parent-&gt;style().position() != PositionType::Absolute)
 959         parent = parent-&gt;parent();
 960     if (!parent || parent-&gt;style().position() != PositionType::Absolute)
 961         return;
 962 
 963     if (hasStaticInlinePosition) {
 964         LogicalExtentComputedValues computedValues;
 965         positionedChild.computeLogicalWidthInFragment(computedValues);
 966         LayoutUnit newLeft = computedValues.m_position;
 967         if (newLeft != positionedChild.logicalLeft())
 968             positionedChild.setChildNeedsLayout(MarkOnlyThis);
 969     } else if (hasStaticBlockPosition) {
 970         LayoutUnit oldTop = positionedChild.logicalTop();
 971         positionedChild.updateLogicalHeight();
 972         if (positionedChild.logicalTop() != oldTop)
 973             positionedChild.setChildNeedsLayout(MarkOnlyThis);
 974     }
 975 }
 976 
 977 LayoutUnit RenderBlock::marginIntrinsicLogicalWidthForChild(RenderBox&amp; child) const
 978 {
 979     // A margin has three types: fixed, percentage, and auto (variable).
 980     // Auto and percentage margins become 0 when computing min/max width.
 981     // Fixed margins can be added in as is.
 982     Length marginLeft = child.style().marginStartUsing(&amp;style());
 983     Length marginRight = child.style().marginEndUsing(&amp;style());
 984     LayoutUnit margin;
 985     if (marginLeft.isFixed())
 986         margin += marginLeft.value();
 987     if (marginRight.isFixed())
 988         margin += marginRight.value();
 989     return margin;
 990 }
 991 
 992 void RenderBlock::layoutPositionedObject(RenderBox&amp; r, bool relayoutChildren, bool fixedPositionObjectsOnly)
 993 {
 994     estimateFragmentRangeForBoxChild(r);
 995 
 996     // A fixed position element with an absolute positioned ancestor has no way of knowing if the latter has changed position. So
 997     // if this is a fixed position element, mark it for layout if it has an abspos ancestor and needs to move with that ancestor, i.e.
 998     // it has static position.
 999     markFixedPositionObjectForLayoutIfNeeded(r);
1000     if (fixedPositionObjectsOnly) {
1001         r.layoutIfNeeded();
1002         return;
1003     }
1004 
1005     // When a non-positioned block element moves, it may have positioned children that are implicitly positioned relative to the
1006     // non-positioned block.  Rather than trying to detect all of these movement cases, we just always lay out positioned
1007     // objects that are positioned implicitly like this.  Such objects are rare, and so in typical DHTML menu usage (where everything is
1008     // positioned explicitly) this should not incur a performance penalty.
1009     if (relayoutChildren || (r.style().hasStaticBlockPosition(isHorizontalWritingMode()) &amp;&amp; r.parent() != this))
1010         r.setChildNeedsLayout(MarkOnlyThis);
1011 
1012     // If relayoutChildren is set and the child has percentage padding or an embedded content box, we also need to invalidate the childs pref widths.
1013     if (relayoutChildren &amp;&amp; r.needsPreferredWidthsRecalculation())
1014         r.setPreferredLogicalWidthsDirty(true, MarkOnlyThis);
1015 
1016     r.markForPaginationRelayoutIfNeeded();
1017 
1018     // We don&#39;t have to do a full layout.  We just have to update our position. Try that first. If we have shrink-to-fit width
1019     // and we hit the available width constraint, the layoutIfNeeded() will catch it and do a full layout.
1020     if (r.needsPositionedMovementLayoutOnly() &amp;&amp; r.tryLayoutDoingPositionedMovementOnly())
1021         r.clearNeedsLayout();
1022 
1023     // If we are paginated or in a line grid, compute a vertical position for our object now.
1024     // If it&#39;s wrong we&#39;ll lay out again.
1025     LayoutUnit oldLogicalTop;
1026     bool needsBlockDirectionLocationSetBeforeLayout = r.needsLayout() &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;needsBlockDirectionLocationSetBeforeLayout();
1027     if (needsBlockDirectionLocationSetBeforeLayout) {
1028         if (isHorizontalWritingMode() == r.isHorizontalWritingMode())
1029             r.updateLogicalHeight();
1030         else
1031             r.updateLogicalWidth();
1032         oldLogicalTop = logicalTopForChild(r);
1033     }
1034 
1035     r.layoutIfNeeded();
1036 
1037     auto* parent = r.parent();
1038     bool layoutChanged = false;
1039     if (parent-&gt;isFlexibleBox() &amp;&amp; downcast&lt;RenderFlexibleBox&gt;(parent)-&gt;setStaticPositionForPositionedLayout(r)) {
1040         // The static position of an abspos child of a flexbox depends on its size
1041         // (for example, they can be centered). So we may have to reposition the
1042         // item after layout.
1043         // FIXME: We could probably avoid a layout here and just reposition?
1044         layoutChanged = true;
1045     }
1046 
1047     // Lay out again if our estimate was wrong.
1048     if (layoutChanged || (needsBlockDirectionLocationSetBeforeLayout &amp;&amp; logicalTopForChild(r) != oldLogicalTop)) {
1049         r.setChildNeedsLayout(MarkOnlyThis);
1050         r.layoutIfNeeded();
1051     }
1052 
1053     if (updateFragmentRangeForBoxChild(r)) {
1054         r.setNeedsLayout(MarkOnlyThis);
1055         r.layoutIfNeeded();
1056     }
1057 }
1058 
1059 void RenderBlock::layoutPositionedObjects(bool relayoutChildren, bool fixedPositionObjectsOnly)
1060 {
1061     TrackedRendererListHashSet* positionedDescendants = positionedObjects();
1062     if (!positionedDescendants)
1063         return;
1064 
1065     // Do not cache positionedDescendants-&gt;end() in a local variable, since |positionedDescendants| can be mutated
1066     // as it is walked. We always need to fetch the new end() value dynamically.
1067     for (auto it = positionedDescendants-&gt;begin(); it != positionedDescendants-&gt;end(); ++it)
1068         layoutPositionedObject(**it, relayoutChildren, fixedPositionObjectsOnly);
1069 }
1070 
1071 void RenderBlock::markPositionedObjectsForLayout()
1072 {
1073     TrackedRendererListHashSet* positionedDescendants = positionedObjects();
1074     if (!positionedDescendants)
1075         return;
1076 
1077     for (auto it = positionedDescendants-&gt;begin(), end = positionedDescendants-&gt;end(); it != end; ++it) {
1078         RenderBox* r = *it;
1079         r-&gt;setChildNeedsLayout();
1080     }
1081 }
1082 
1083 void RenderBlock::markForPaginationRelayoutIfNeeded()
1084 {
1085     auto* layoutState = view().frameView().layoutContext().layoutState();
1086     if (needsLayout() || !layoutState-&gt;isPaginated())
1087         return;
1088 
1089     if (layoutState-&gt;pageLogicalHeightChanged() || (layoutState-&gt;pageLogicalHeight() &amp;&amp; layoutState-&gt;pageLogicalOffset(this, logicalTop()) != pageLogicalOffset()))
1090         setChildNeedsLayout(MarkOnlyThis);
1091 }
1092 
1093 void RenderBlock::paint(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1094 {
1095     LayoutPoint adjustedPaintOffset = paintOffset + location();
1096     PaintPhase phase = paintInfo.phase;
1097 
1098     // Check if we need to do anything at all.
1099     // FIXME: Could eliminate the isDocumentElementRenderer() check if we fix background painting so that the RenderView
1100     // paints the root&#39;s background.
1101     if (!isDocumentElementRenderer()) {
1102         LayoutRect overflowBox = overflowRectForPaintRejection();
1103         flipForWritingMode(overflowBox);
1104         overflowBox.moveBy(adjustedPaintOffset);
1105         if (!overflowBox.intersects(paintInfo.rect)
1106 #if PLATFORM(IOS_FAMILY)
1107             // FIXME: This may be applicable to non-iOS ports.
1108             &amp;&amp; (!hasLayer() || !layer()-&gt;isComposited())
1109 #endif
1110         )
1111             return;
1112     }
1113 
1114     bool pushedClip = pushContentsClip(paintInfo, adjustedPaintOffset);
1115     paintObject(paintInfo, adjustedPaintOffset);
1116     if (pushedClip)
1117         popContentsClip(paintInfo, phase, adjustedPaintOffset);
1118 
1119     // Our scrollbar widgets paint exactly when we tell them to, so that they work properly with
1120     // z-index. We paint after we painted the background/border, so that the scrollbars will
1121     // sit above the background/border.
1122     if ((phase == PaintPhase::BlockBackground || phase == PaintPhase::ChildBlockBackground) &amp;&amp; hasOverflowClip() &amp;&amp; layer()
1123         &amp;&amp; style().visibility() == Visibility::Visible &amp;&amp; paintInfo.shouldPaintWithinRoot(*this) &amp;&amp; !paintInfo.paintRootBackgroundOnly())
1124         layer()-&gt;paintOverflowControls(paintInfo.context(), roundedIntPoint(adjustedPaintOffset), snappedIntRect(paintInfo.rect));
1125 }
1126 
1127 void RenderBlock::paintContents(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1128 {
1129     // Style is non-final if the element has a pending stylesheet before it. We end up with renderers with such styles if a script
1130     // forces renderer construction by querying something layout dependent.
1131     // Avoid FOUC by not painting. Switching to final style triggers repaint.
1132     if (style().isNotFinal())
1133         return;
1134 
1135     if (childrenInline())
1136         paintInlineChildren(paintInfo, paintOffset);
1137     else {
1138         PaintPhase newPhase = (paintInfo.phase == PaintPhase::ChildOutlines) ? PaintPhase::Outline : paintInfo.phase;
1139         newPhase = (newPhase == PaintPhase::ChildBlockBackgrounds) ? PaintPhase::ChildBlockBackground : newPhase;
1140 
1141         // We don&#39;t paint our own background, but we do let the kids paint their backgrounds.
1142         PaintInfo paintInfoForChild(paintInfo);
1143         paintInfoForChild.phase = newPhase;
1144         paintInfoForChild.updateSubtreePaintRootForChildren(this);
1145 
1146         // FIXME: Paint-time pagination is obsolete and is now only used by embedded WebViews inside AppKit
1147         // NSViews. Do not add any more code for this.
1148         bool usePrintRect = !view().printRect().isEmpty();
1149         paintChildren(paintInfo, paintOffset, paintInfoForChild, usePrintRect);
1150     }
1151 }
1152 
1153 void RenderBlock::paintChildren(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, PaintInfo&amp; paintInfoForChild, bool usePrintRect)
1154 {
1155     for (auto* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
1156         if (!paintChild(*child, paintInfo, paintOffset, paintInfoForChild, usePrintRect))
1157             return;
1158     }
1159 }
1160 
1161 bool RenderBlock::paintChild(RenderBox&amp; child, PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, PaintInfo&amp; paintInfoForChild, bool usePrintRect, PaintBlockType paintType)
1162 {
1163     if (child.isExcludedAndPlacedInBorder())
1164         return true;
1165 
1166     // Check for page-break-before: always, and if it&#39;s set, break and bail.
1167     bool checkBeforeAlways = !childrenInline() &amp;&amp; (usePrintRect &amp;&amp; alwaysPageBreak(child.style().breakBefore()));
1168     LayoutUnit absoluteChildY = paintOffset.y() + child.y();
1169     if (checkBeforeAlways
1170         &amp;&amp; absoluteChildY &gt; paintInfo.rect.y()
1171         &amp;&amp; absoluteChildY &lt; paintInfo.rect.maxY()) {
1172         view().setBestTruncatedAt(absoluteChildY, this, true);
1173         return false;
1174     }
1175 
1176     if (!child.isFloating() &amp;&amp; child.isReplaced() &amp;&amp; usePrintRect &amp;&amp; child.height() &lt;= view().printRect().height()) {
1177         // Paginate block-level replaced elements.
1178         if (absoluteChildY + child.height() &gt; view().printRect().maxY()) {
1179             if (absoluteChildY &lt; view().truncatedAt())
1180                 view().setBestTruncatedAt(absoluteChildY, &amp;child);
1181             // If we were able to truncate, don&#39;t paint.
1182             if (absoluteChildY &gt;= view().truncatedAt())
1183                 return false;
1184         }
1185     }
1186 
1187     LayoutPoint childPoint = flipForWritingModeForChild(&amp;child, paintOffset);
1188     if (!child.hasSelfPaintingLayer() &amp;&amp; !child.isFloating()) {
1189         if (paintType == PaintAsInlineBlock)
1190             child.paintAsInlineBlock(paintInfoForChild, childPoint);
1191         else
1192             child.paint(paintInfoForChild, childPoint);
1193     }
1194 
1195     // Check for page-break-after: always, and if it&#39;s set, break and bail.
1196     bool checkAfterAlways = !childrenInline() &amp;&amp; (usePrintRect &amp;&amp; alwaysPageBreak(child.style().breakAfter()));
1197     if (checkAfterAlways
1198         &amp;&amp; (absoluteChildY + child.height()) &gt; paintInfo.rect.y()
1199         &amp;&amp; (absoluteChildY + child.height()) &lt; paintInfo.rect.maxY()) {
1200         view().setBestTruncatedAt(absoluteChildY + child.height() + std::max&lt;LayoutUnit&gt;(0, child.collapsedMarginAfter()), this, true);
1201         return false;
1202     }
1203 
1204     return true;
1205 }
1206 
1207 void RenderBlock::paintCaret(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, CaretType type)
1208 {
1209     // Paint the caret if the FrameSelection says so or if caret browsing is enabled
1210     RenderBlock* caretPainter;
1211     bool isContentEditable;
1212     if (type == CursorCaret) {
1213         caretPainter = frame().selection().caretRendererWithoutUpdatingLayout();
1214         isContentEditable = frame().selection().selection().hasEditableStyle();
1215     } else {
1216         caretPainter = page().dragCaretController().caretRenderer();
1217         isContentEditable = page().dragCaretController().isContentEditable();
1218     }
1219 
1220     if (caretPainter == this &amp;&amp; (isContentEditable || settings().caretBrowsingEnabled())) {
1221         if (type == CursorCaret)
1222             frame().selection().paintCaret(paintInfo.context(), paintOffset, paintInfo.rect);
1223         else
1224             page().dragCaretController().paintDragCaret(&amp;frame(), paintInfo.context(), paintOffset, paintInfo.rect);
1225     }
1226 }
1227 
1228 void RenderBlock::paintObject(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1229 {
1230     PaintPhase paintPhase = paintInfo.phase;
1231 
1232     // 1. paint background, borders etc
1233     if ((paintPhase == PaintPhase::BlockBackground || paintPhase == PaintPhase::ChildBlockBackground) &amp;&amp; style().visibility() == Visibility::Visible) {
1234         if (hasVisibleBoxDecorations())
1235             paintBoxDecorations(paintInfo, paintOffset);
1236     }
1237 
1238     // Paint legends just above the border before we scroll or clip.
1239     if (paintPhase == PaintPhase::BlockBackground || paintPhase == PaintPhase::ChildBlockBackground || paintPhase == PaintPhase::Selection)
1240         paintExcludedChildrenInBorder(paintInfo, paintOffset);
1241 
1242     if (paintPhase == PaintPhase::Mask &amp;&amp; style().visibility() == Visibility::Visible) {
1243         paintMask(paintInfo, paintOffset);
1244         return;
1245     }
1246 
1247     if (paintPhase == PaintPhase::ClippingMask &amp;&amp; style().visibility() == Visibility::Visible) {
1248         paintClippingMask(paintInfo, paintOffset);
1249         return;
1250     }
1251 
1252     // If just painting the root background, then return.
1253     if (paintInfo.paintRootBackgroundOnly())
1254         return;
1255 
1256     if (paintPhase == PaintPhase::EventRegion) {
1257         auto borderRect = LayoutRect(paintOffset, size());
1258 
1259         if (visibleToHitTesting()) {
1260             auto borderRegion = approximateAsRegion(style().getRoundedBorderFor(borderRect));
1261             paintInfo.eventRegionContext-&gt;unite(borderRegion, style());
1262         }
1263 
1264         // No need to check descendants if we don&#39;t have overflow and the area is already covered.
1265         bool needsTraverseDescendants = hasVisualOverflow() || !paintInfo.eventRegionContext-&gt;contains(enclosingIntRect(borderRect));
1266 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(POINTER_EVENTS)
1267         needsTraverseDescendants = needsTraverseDescendants || document().mayHaveElementsWithNonAutoTouchAction();
1268 #endif
1269         if (!needsTraverseDescendants)
1270             return;
1271     }
1272 
1273     // Adjust our painting position if we&#39;re inside a scrolled layer (e.g., an overflow:auto div).
1274     LayoutPoint scrolledOffset = paintOffset;
1275     scrolledOffset.moveBy(-scrollPosition());
1276 
1277     // Column rules need to account for scrolling and clipping.
1278     // FIXME: Clipping of column rules does not work. We will need a separate paint phase for column rules I suspect in order to get
1279     // clipping correct (since it has to paint as background but is still considered &quot;contents&quot;).
1280     if ((paintPhase == PaintPhase::BlockBackground || paintPhase == PaintPhase::ChildBlockBackground) &amp;&amp; style().visibility() == Visibility::Visible)
1281         paintColumnRules(paintInfo, scrolledOffset);
1282 
1283     // Done with backgrounds, borders and column rules.
1284     if (paintPhase == PaintPhase::BlockBackground)
1285         return;
1286 
1287     // 2. paint contents
1288     if (paintPhase != PaintPhase::SelfOutline)
1289         paintContents(paintInfo, scrolledOffset);
1290 
1291     // 3. paint selection
1292     // FIXME: Make this work with multi column layouts.  For now don&#39;t fill gaps.
1293     bool isPrinting = document().printing();
1294     if (!isPrinting)
1295         paintSelection(paintInfo, scrolledOffset); // Fill in gaps in selection on lines and between blocks.
1296 
1297     // 4. paint floats.
1298     if (paintPhase == PaintPhase::Float || paintPhase == PaintPhase::Selection || paintPhase == PaintPhase::TextClip)
1299         paintFloats(paintInfo, scrolledOffset, paintPhase == PaintPhase::Selection || paintPhase == PaintPhase::TextClip);
1300 
1301     // 5. paint outline.
1302     if ((paintPhase == PaintPhase::Outline || paintPhase == PaintPhase::SelfOutline) &amp;&amp; hasOutline() &amp;&amp; style().visibility() == Visibility::Visible)
1303         paintOutline(paintInfo, LayoutRect(paintOffset, size()));
1304 
1305     // 6. paint continuation outlines.
1306     if ((paintPhase == PaintPhase::Outline || paintPhase == PaintPhase::ChildOutlines)) {
1307         RenderInline* inlineCont = inlineContinuation();
1308         if (inlineCont &amp;&amp; inlineCont-&gt;hasOutline() &amp;&amp; inlineCont-&gt;style().visibility() == Visibility::Visible) {
1309             RenderInline* inlineRenderer = downcast&lt;RenderInline&gt;(inlineCont-&gt;element()-&gt;renderer());
1310             RenderBlock* containingBlock = this-&gt;containingBlock();
1311 
1312             bool inlineEnclosedInSelfPaintingLayer = false;
1313             for (RenderBoxModelObject* box = inlineRenderer; box != containingBlock; box = &amp;box-&gt;parent()-&gt;enclosingBoxModelObject()) {
1314                 if (box-&gt;hasSelfPaintingLayer()) {
1315                     inlineEnclosedInSelfPaintingLayer = true;
1316                     break;
1317                 }
1318             }
1319 
1320             // Do not add continuations for outline painting by our containing block if we are a relative positioned
1321             // anonymous block (i.e. have our own layer), paint them straightaway instead. This is because a block depends on renderers in its continuation table being
1322             // in the same layer.
1323             if (!inlineEnclosedInSelfPaintingLayer &amp;&amp; !hasLayer())
1324                 containingBlock-&gt;addContinuationWithOutline(inlineRenderer);
1325             else if (!inlineRenderer-&gt;firstLineBox() || (!inlineEnclosedInSelfPaintingLayer &amp;&amp; hasLayer()))
1326                 inlineRenderer-&gt;paintOutline(paintInfo, paintOffset - locationOffset() + inlineRenderer-&gt;containingBlock()-&gt;location());
1327         }
1328         paintContinuationOutlines(paintInfo, paintOffset);
1329     }
1330 
1331     // 7. paint caret.
1332     // If the caret&#39;s node&#39;s render object&#39;s containing block is this block, and the paint action is PaintPhase::Foreground,
1333     // then paint the caret.
1334     if (paintPhase == PaintPhase::Foreground) {
1335         paintCaret(paintInfo, paintOffset, CursorCaret);
1336         paintCaret(paintInfo, paintOffset, DragCaret);
1337     }
1338 }
1339 
1340 static ContinuationOutlineTableMap* continuationOutlineTable()
1341 {
1342     static NeverDestroyed&lt;ContinuationOutlineTableMap&gt; table;
1343     return &amp;table.get();
1344 }
1345 
1346 void RenderBlock::addContinuationWithOutline(RenderInline* flow)
1347 {
1348     // We can&#39;t make this work if the inline is in a layer.  We&#39;ll just rely on the broken
1349     // way of painting.
1350     ASSERT(!flow-&gt;layer() &amp;&amp; !flow-&gt;isContinuation());
1351 
1352     ContinuationOutlineTableMap* table = continuationOutlineTable();
1353     ListHashSet&lt;RenderInline*&gt;* continuations = table-&gt;get(this);
1354     if (!continuations) {
1355         continuations = new ListHashSet&lt;RenderInline*&gt;;
1356         table-&gt;set(this, std::unique_ptr&lt;ListHashSet&lt;RenderInline*&gt;&gt;(continuations));
1357     }
1358 
1359     continuations-&gt;add(flow);
1360 }
1361 
1362 bool RenderBlock::paintsContinuationOutline(RenderInline* flow)
1363 {
1364     ContinuationOutlineTableMap* table = continuationOutlineTable();
1365     if (table-&gt;isEmpty())
1366         return false;
1367 
1368     ListHashSet&lt;RenderInline*&gt;* continuations = table-&gt;get(this);
1369     if (!continuations)
1370         return false;
1371 
1372     return continuations-&gt;contains(flow);
1373 }
1374 
1375 void RenderBlock::paintContinuationOutlines(PaintInfo&amp; info, const LayoutPoint&amp; paintOffset)
1376 {
1377     ContinuationOutlineTableMap* table = continuationOutlineTable();
1378     if (table-&gt;isEmpty())
1379         return;
1380 
1381     std::unique_ptr&lt;ListHashSet&lt;RenderInline*&gt;&gt; continuations = table-&gt;take(this);
1382     if (!continuations)
1383         return;
1384 
1385     LayoutPoint accumulatedPaintOffset = paintOffset;
1386     // Paint each continuation outline.
1387     ListHashSet&lt;RenderInline*&gt;::iterator end = continuations-&gt;end();
1388     for (ListHashSet&lt;RenderInline*&gt;::iterator it = continuations-&gt;begin(); it != end; ++it) {
1389         // Need to add in the coordinates of the intervening blocks.
1390         RenderInline* flow = *it;
1391         RenderBlock* block = flow-&gt;containingBlock();
1392         for ( ; block &amp;&amp; block != this; block = block-&gt;containingBlock())
1393             accumulatedPaintOffset.moveBy(block-&gt;location());
1394         ASSERT(block);
1395         flow-&gt;paintOutline(info, accumulatedPaintOffset);
1396     }
1397 }
1398 
1399 bool RenderBlock::shouldPaintSelectionGaps() const
1400 {
1401     if (settings().selectionPaintingWithoutSelectionGapsEnabled())
1402         return false;
1403 
1404     return selectionState() != SelectionNone &amp;&amp; style().visibility() == Visibility::Visible &amp;&amp; isSelectionRoot();
1405 }
1406 
1407 bool RenderBlock::isSelectionRoot() const
1408 {
1409     if (isPseudoElement())
1410         return false;
1411     ASSERT(element() || isAnonymous());
1412 
1413     // FIXME: Eventually tables should have to learn how to fill gaps between cells, at least in simple non-spanning cases.
1414     if (isTable())
1415         return false;
1416 
1417     if (isBody() || isDocumentElementRenderer() || hasOverflowClip()
1418         || isPositioned() || isFloating()
1419         || isTableCell() || isInlineBlockOrInlineTable()
1420         || hasTransform() || hasReflection() || hasMask() || isWritingModeRoot()
1421         || isRenderFragmentedFlow() || style().columnSpan() == ColumnSpan::All)
1422         return true;
1423 
1424     if (view().selection().start()) {
1425         Node* startElement = view().selection().start()-&gt;node();
1426         if (startElement &amp;&amp; startElement-&gt;rootEditableElement() == element())
1427             return true;
1428     }
1429 
1430     return false;
1431 }
1432 
1433 GapRects RenderBlock::selectionGapRectsForRepaint(const RenderLayerModelObject* repaintContainer)
1434 {
1435     ASSERT(!needsLayout());
1436 
1437     if (!shouldPaintSelectionGaps())
1438         return GapRects();
1439 
1440     FloatPoint containerPoint = localToContainerPoint(FloatPoint(), repaintContainer, UseTransforms);
1441     LayoutPoint offsetFromRepaintContainer(containerPoint - toFloatSize(scrollPosition()));
1442 
1443     LogicalSelectionOffsetCaches cache(*this);
1444     LayoutUnit lastTop;
1445     LayoutUnit lastLeft = logicalLeftSelectionOffset(*this, lastTop, cache);
1446     LayoutUnit lastRight = logicalRightSelectionOffset(*this, lastTop, cache);
1447 
1448     return selectionGaps(*this, offsetFromRepaintContainer, IntSize(), lastTop, lastLeft, lastRight, cache);
1449 }
1450 
1451 void RenderBlock::paintSelection(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1452 {
1453 #if ENABLE(TEXT_SELECTION)
1454     if (shouldPaintSelectionGaps() &amp;&amp; paintInfo.phase == PaintPhase::Foreground) {
1455         LogicalSelectionOffsetCaches cache(*this);
1456         LayoutUnit lastTop;
1457         LayoutUnit lastLeft = logicalLeftSelectionOffset(*this, lastTop, cache);
1458         LayoutUnit lastRight = logicalRightSelectionOffset(*this, lastTop, cache);
1459         GraphicsContextStateSaver stateSaver(paintInfo.context());
1460 
1461         LayoutRect gapRectsBounds = selectionGaps(*this, paintOffset, LayoutSize(), lastTop, lastLeft, lastRight, cache, &amp;paintInfo);
1462         if (!gapRectsBounds.isEmpty()) {
1463             if (RenderLayer* layer = enclosingLayer()) {
1464                 gapRectsBounds.moveBy(-paintOffset);
1465                 if (!hasLayer()) {
1466                     LayoutRect localBounds(gapRectsBounds);
1467                     flipForWritingMode(localBounds);
1468                     gapRectsBounds = localToContainerQuad(FloatRect(localBounds), &amp;layer-&gt;renderer()).enclosingBoundingBox();
1469                     if (layer-&gt;renderer().isBox())
1470                         gapRectsBounds.moveBy(layer-&gt;renderBox()-&gt;scrollPosition());
1471                 }
1472                 layer-&gt;addBlockSelectionGapsBounds(gapRectsBounds);
1473             }
1474         }
1475     }
1476 #else
1477     UNUSED_PARAM(paintInfo);
1478     UNUSED_PARAM(paintOffset);
1479 #endif
1480 }
1481 
1482 static void clipOutPositionedObjects(const PaintInfo* paintInfo, const LayoutPoint&amp; offset, TrackedRendererListHashSet* positionedObjects)
1483 {
1484     if (!positionedObjects)
1485         return;
1486 
1487     TrackedRendererListHashSet::const_iterator end = positionedObjects-&gt;end();
1488     for (TrackedRendererListHashSet::const_iterator it = positionedObjects-&gt;begin(); it != end; ++it) {
1489         RenderBox* r = *it;
1490         paintInfo-&gt;context().clipOut(IntRect(offset.x() + r-&gt;x(), offset.y() + r-&gt;y(), r-&gt;width(), r-&gt;height()));
1491     }
1492 }
1493 
1494 LayoutUnit blockDirectionOffset(RenderBlock&amp; rootBlock, const LayoutSize&amp; offsetFromRootBlock)
1495 {
1496     return rootBlock.isHorizontalWritingMode() ? offsetFromRootBlock.height() : offsetFromRootBlock.width();
1497 }
1498 
1499 LayoutUnit inlineDirectionOffset(RenderBlock&amp; rootBlock, const LayoutSize&amp; offsetFromRootBlock)
1500 {
1501     return rootBlock.isHorizontalWritingMode() ? offsetFromRootBlock.width() : offsetFromRootBlock.height();
1502 }
1503 
1504 LayoutRect RenderBlock::logicalRectToPhysicalRect(const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutRect&amp; logicalRect)
1505 {
1506     LayoutRect result;
1507     if (isHorizontalWritingMode())
1508         result = logicalRect;
1509     else
1510         result = LayoutRect(logicalRect.y(), logicalRect.x(), logicalRect.height(), logicalRect.width());
1511     flipForWritingMode(result);
1512     result.moveBy(rootBlockPhysicalPosition);
1513     return result;
1514 }
1515 
1516 GapRects RenderBlock::selectionGaps(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
1517     LayoutUnit&amp; lastLogicalTop, LayoutUnit&amp; lastLogicalLeft, LayoutUnit&amp; lastLogicalRight, const LogicalSelectionOffsetCaches&amp; cache, const PaintInfo* paintInfo)
1518 {
1519     // IMPORTANT: Callers of this method that intend for painting to happen need to do a save/restore.
1520     // Clip out floating and positioned objects when painting selection gaps.
1521     if (paintInfo) {
1522         // Note that we don&#39;t clip out overflow for positioned objects.  We just stick to the border box.
1523         LayoutRect flippedBlockRect(offsetFromRootBlock.width(), offsetFromRootBlock.height(), width(), height());
1524         rootBlock.flipForWritingMode(flippedBlockRect);
1525         flippedBlockRect.moveBy(rootBlockPhysicalPosition);
1526         clipOutPositionedObjects(paintInfo, flippedBlockRect.location(), positionedObjects());
1527         if (isBody() || isDocumentElementRenderer()) { // The &lt;body&gt; must make sure to examine its containingBlock&#39;s positioned objects.
1528             for (RenderBlock* cb = containingBlock(); cb &amp;&amp; !is&lt;RenderView&gt;(*cb); cb = cb-&gt;containingBlock())
1529                 clipOutPositionedObjects(paintInfo, LayoutPoint(cb-&gt;x(), cb-&gt;y()), cb-&gt;positionedObjects()); // FIXME: Not right for flipped writing modes.
1530         }
1531         clipOutFloatingObjects(rootBlock, paintInfo, rootBlockPhysicalPosition, offsetFromRootBlock);
1532     }
1533 
1534     // FIXME: overflow: auto/scroll fragments need more math here, since painting in the border box is different from painting in the padding box (one is scrolled, the other is
1535     // fixed).
1536     GapRects result;
1537     if (!isRenderBlockFlow()) // FIXME: Make multi-column selection gap filling work someday.
1538         return result;
1539 
1540     if (hasTransform() || style().columnSpan() == ColumnSpan::All || isInFlowRenderFragmentedFlow()) {
1541         // FIXME: We should learn how to gap fill multiple columns and transforms eventually.
1542         lastLogicalTop = blockDirectionOffset(rootBlock, offsetFromRootBlock) + logicalHeight();
1543         lastLogicalLeft = logicalLeftSelectionOffset(rootBlock, logicalHeight(), cache);
1544         lastLogicalRight = logicalRightSelectionOffset(rootBlock, logicalHeight(), cache);
1545         return result;
1546     }
1547 
1548     if (childrenInline())
1549         result = inlineSelectionGaps(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, lastLogicalTop, lastLogicalLeft, lastLogicalRight, cache, paintInfo);
1550     else
1551         result = blockSelectionGaps(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, lastLogicalTop, lastLogicalLeft, lastLogicalRight, cache, paintInfo);
1552 
1553     // Fill the vertical gap all the way to the bottom of our block if the selection extends past our block.
1554     if (&amp;rootBlock == this &amp;&amp; (selectionState() != SelectionBoth &amp;&amp; selectionState() != SelectionEnd) &amp;&amp; !isRubyBase() &amp;&amp; !isRubyText()) {
1555         result.uniteCenter(blockSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock,
1556             lastLogicalTop, lastLogicalLeft, lastLogicalRight, logicalHeight(), cache, paintInfo));
1557     }
1558 
1559     return result;
1560 }
1561 
1562 GapRects RenderBlock::inlineSelectionGaps(RenderBlock&amp;, const LayoutPoint&amp;, const LayoutSize&amp;, LayoutUnit&amp;, LayoutUnit&amp;, LayoutUnit&amp;, const LogicalSelectionOffsetCaches&amp;, const PaintInfo*)
1563 {
1564     ASSERT_NOT_REACHED();
1565     return GapRects();
1566 }
1567 
1568 GapRects RenderBlock::blockSelectionGaps(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
1569     LayoutUnit&amp; lastLogicalTop, LayoutUnit&amp; lastLogicalLeft, LayoutUnit&amp; lastLogicalRight, const LogicalSelectionOffsetCaches&amp; cache, const PaintInfo* paintInfo)
1570 {
1571     GapRects result;
1572 
1573     // Jump right to the first block child that contains some selected objects.
1574     RenderBox* curr;
1575     for (curr = firstChildBox(); curr &amp;&amp; curr-&gt;selectionState() == SelectionNone; curr = curr-&gt;nextSiblingBox()) { }
1576 
1577     if (!curr)
1578         return result;
1579 
1580     LogicalSelectionOffsetCaches childCache(*this, cache);
1581 
1582     for (bool sawSelectionEnd = false; curr &amp;&amp; !sawSelectionEnd; curr = curr-&gt;nextSiblingBox()) {
1583         SelectionState childState = curr-&gt;selectionState();
1584         if (childState == SelectionBoth || childState == SelectionEnd)
1585             sawSelectionEnd = true;
1586 
1587         if (curr-&gt;isFloatingOrOutOfFlowPositioned())
1588             continue; // We must be a normal flow object in order to even be considered.
1589 
1590         if (curr-&gt;isInFlowPositioned() &amp;&amp; curr-&gt;hasLayer()) {
1591             // If the relposition offset is anything other than 0, then treat this just like an absolute positioned element.
1592             // Just disregard it completely.
1593             LayoutSize relOffset = curr-&gt;layer()-&gt;offsetForInFlowPosition();
1594             if (relOffset.width() || relOffset.height())
1595                 continue;
1596         }
1597 
1598         bool paintsOwnSelection = curr-&gt;shouldPaintSelectionGaps() || curr-&gt;isTable(); // FIXME: Eventually we won&#39;t special-case table like this.
1599         bool fillBlockGaps = (paintsOwnSelection || (curr-&gt;canBeSelectionLeaf() &amp;&amp; childState != SelectionNone)) &amp;&amp; !isRubyBase() &amp;&amp; !isRubyText();
1600         if (fillBlockGaps) {
1601             // We need to fill the vertical gap above this object.
1602             if (childState == SelectionEnd || childState == SelectionInside) {
1603                 // Fill the gap above the object.
1604                 result.uniteCenter(blockSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock,
1605                     lastLogicalTop, lastLogicalLeft, lastLogicalRight, curr-&gt;logicalTop(), cache, paintInfo));
1606             }
1607 
1608             // Only fill side gaps for objects that paint their own selection if we know for sure the selection is going to extend all the way *past*
1609             // our object.  We know this if the selection did not end inside our object.
1610             if (paintsOwnSelection &amp;&amp; (childState == SelectionStart || sawSelectionEnd))
1611                 childState = SelectionNone;
1612 
1613             // Fill side gaps on this object based off its state.
1614             bool leftGap, rightGap;
1615             getSelectionGapInfo(childState, leftGap, rightGap);
1616 
1617             if (leftGap)
1618                 result.uniteLeft(logicalLeftSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, this, curr-&gt;logicalLeft(), curr-&gt;logicalTop(), curr-&gt;logicalHeight(), cache, paintInfo));
1619             if (rightGap)
1620                 result.uniteRight(logicalRightSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, this, curr-&gt;logicalRight(), curr-&gt;logicalTop(), curr-&gt;logicalHeight(), cache, paintInfo));
1621 
1622             // Update lastLogicalTop to be just underneath the object.  lastLogicalLeft and lastLogicalRight extend as far as
1623             // they can without bumping into floating or positioned objects.  Ideally they will go right up
1624             // to the border of the root selection block.
1625             lastLogicalTop = blockDirectionOffset(rootBlock, offsetFromRootBlock) + curr-&gt;logicalBottom();
1626             lastLogicalLeft = logicalLeftSelectionOffset(rootBlock, curr-&gt;logicalBottom(), cache);
1627             lastLogicalRight = logicalRightSelectionOffset(rootBlock, curr-&gt;logicalBottom(), cache);
1628         } else if (childState != SelectionNone &amp;&amp; is&lt;RenderBlock&gt;(*curr)) {
1629             // We must be a block that has some selected object inside it, so recur.
1630             result.unite(downcast&lt;RenderBlock&gt;(*curr).selectionGaps(rootBlock, rootBlockPhysicalPosition, LayoutSize(offsetFromRootBlock.width() + curr-&gt;x(), offsetFromRootBlock.height() + curr-&gt;y()),
1631                 lastLogicalTop, lastLogicalLeft, lastLogicalRight, childCache, paintInfo));
1632         }
1633     }
1634     return result;
1635 }
1636 
1637 LayoutRect RenderBlock::blockSelectionGap(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
1638     LayoutUnit lastLogicalTop, LayoutUnit lastLogicalLeft, LayoutUnit lastLogicalRight, LayoutUnit logicalBottom, const LogicalSelectionOffsetCaches&amp; cache, const PaintInfo* paintInfo)
1639 {
1640     LayoutUnit logicalTop = lastLogicalTop;
1641     LayoutUnit logicalHeight = blockDirectionOffset(rootBlock, offsetFromRootBlock) + logicalBottom - logicalTop;
1642     if (logicalHeight &lt;= 0)
1643         return LayoutRect();
1644 
1645     // Get the selection offsets for the bottom of the gap
1646     LayoutUnit logicalLeft = std::max(lastLogicalLeft, logicalLeftSelectionOffset(rootBlock, logicalBottom, cache));
1647     LayoutUnit logicalRight = std::min(lastLogicalRight, logicalRightSelectionOffset(rootBlock, logicalBottom, cache));
1648     LayoutUnit logicalWidth = logicalRight - logicalLeft;
1649     if (logicalWidth &lt;= 0)
1650         return LayoutRect();
1651 
1652     LayoutRect gapRect = rootBlock.logicalRectToPhysicalRect(rootBlockPhysicalPosition, LayoutRect(logicalLeft, logicalTop, logicalWidth, logicalHeight));
1653     if (paintInfo)
1654         paintInfo-&gt;context().fillRect(snapRectToDevicePixels(gapRect, document().deviceScaleFactor()), selectionBackgroundColor());
1655     return gapRect;
1656 }
1657 
1658 LayoutRect RenderBlock::logicalLeftSelectionGap(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
1659     RenderBoxModelObject* selObj, LayoutUnit logicalLeft, LayoutUnit logicalTop, LayoutUnit logicalHeight, const LogicalSelectionOffsetCaches&amp; cache, const PaintInfo* paintInfo)
1660 {
1661     LayoutUnit rootBlockLogicalTop = blockDirectionOffset(rootBlock, offsetFromRootBlock) + logicalTop;
1662     LayoutUnit rootBlockLogicalLeft = std::max(logicalLeftSelectionOffset(rootBlock, logicalTop, cache), logicalLeftSelectionOffset(rootBlock, logicalTop + logicalHeight, cache));
1663     LayoutUnit rootBlockLogicalRight = std::min(inlineDirectionOffset(rootBlock, offsetFromRootBlock) + logicalLeft,
1664         std::min(logicalRightSelectionOffset(rootBlock, logicalTop, cache), logicalRightSelectionOffset(rootBlock, logicalTop + logicalHeight, cache)));
1665     LayoutUnit rootBlockLogicalWidth = rootBlockLogicalRight - rootBlockLogicalLeft;
1666     if (rootBlockLogicalWidth &lt;= 0)
1667         return LayoutRect();
1668 
1669     LayoutRect gapRect = rootBlock.logicalRectToPhysicalRect(rootBlockPhysicalPosition, LayoutRect(rootBlockLogicalLeft, rootBlockLogicalTop, rootBlockLogicalWidth, logicalHeight));
1670     if (paintInfo)
1671         paintInfo-&gt;context().fillRect(snapRectToDevicePixels(gapRect, document().deviceScaleFactor()), selObj-&gt;selectionBackgroundColor());
1672     return gapRect;
1673 }
1674 
1675 LayoutRect RenderBlock::logicalRightSelectionGap(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
1676     RenderBoxModelObject* selObj, LayoutUnit logicalRight, LayoutUnit logicalTop, LayoutUnit logicalHeight, const LogicalSelectionOffsetCaches&amp; cache, const PaintInfo* paintInfo)
1677 {
1678     LayoutUnit rootBlockLogicalTop = blockDirectionOffset(rootBlock, offsetFromRootBlock) + logicalTop;
1679     LayoutUnit rootBlockLogicalLeft = std::max(inlineDirectionOffset(rootBlock, offsetFromRootBlock) + logicalRight,
1680         std::max(logicalLeftSelectionOffset(rootBlock, logicalTop, cache), logicalLeftSelectionOffset(rootBlock, logicalTop + logicalHeight, cache)));
1681     LayoutUnit rootBlockLogicalRight = std::min(logicalRightSelectionOffset(rootBlock, logicalTop, cache), logicalRightSelectionOffset(rootBlock, logicalTop + logicalHeight, cache));
1682     LayoutUnit rootBlockLogicalWidth = rootBlockLogicalRight - rootBlockLogicalLeft;
1683     if (rootBlockLogicalWidth &lt;= 0)
1684         return LayoutRect();
1685 
1686     LayoutRect gapRect = rootBlock.logicalRectToPhysicalRect(rootBlockPhysicalPosition, LayoutRect(rootBlockLogicalLeft, rootBlockLogicalTop, rootBlockLogicalWidth, logicalHeight));
1687     if (paintInfo)
1688         paintInfo-&gt;context().fillRect(snapRectToDevicePixels(gapRect, document().deviceScaleFactor()), selObj-&gt;selectionBackgroundColor());
1689     return gapRect;
1690 }
1691 
1692 void RenderBlock::getSelectionGapInfo(SelectionState state, bool&amp; leftGap, bool&amp; rightGap)
1693 {
1694     bool ltr = style().isLeftToRightDirection();
1695     leftGap = (state == RenderObject::SelectionInside) ||
1696               (state == RenderObject::SelectionEnd &amp;&amp; ltr) ||
1697               (state == RenderObject::SelectionStart &amp;&amp; !ltr);
1698     rightGap = (state == RenderObject::SelectionInside) ||
1699                (state == RenderObject::SelectionStart &amp;&amp; ltr) ||
1700                (state == RenderObject::SelectionEnd &amp;&amp; !ltr);
1701 }
1702 
1703 LayoutUnit RenderBlock::logicalLeftSelectionOffset(RenderBlock&amp; rootBlock, LayoutUnit position, const LogicalSelectionOffsetCaches&amp; cache)
1704 {
1705     LayoutUnit logicalLeft = logicalLeftOffsetForLine(position, DoNotIndentText);
1706     if (logicalLeft == logicalLeftOffsetForContent()) {
1707         if (&amp;rootBlock != this) // The border can potentially be further extended by our containingBlock().
1708             return cache.containingBlockInfo(*this).logicalLeftSelectionOffset(rootBlock, position + logicalTop());
1709         return logicalLeft;
1710     }
1711 
1712     RenderBlock* cb = this;
1713     const LogicalSelectionOffsetCaches* currentCache = &amp;cache;
1714     while (cb != &amp;rootBlock) {
1715         logicalLeft += cb-&gt;logicalLeft();
1716 
1717         ASSERT(currentCache);
1718         auto info = currentCache-&gt;containingBlockInfo(*cb);
1719         cb = info.block();
1720         if (!cb)
1721             break;
1722         currentCache = info.cache();
1723     }
1724     return logicalLeft;
1725 }
1726 
1727 LayoutUnit RenderBlock::logicalRightSelectionOffset(RenderBlock&amp; rootBlock, LayoutUnit position, const LogicalSelectionOffsetCaches&amp; cache)
1728 {
1729     LayoutUnit logicalRight = logicalRightOffsetForLine(position, DoNotIndentText);
1730     if (logicalRight == logicalRightOffsetForContent()) {
1731         if (&amp;rootBlock != this) // The border can potentially be further extended by our containingBlock().
1732             return cache.containingBlockInfo(*this).logicalRightSelectionOffset(rootBlock, position + logicalTop());
1733         return logicalRight;
1734     }
1735 
1736     RenderBlock* cb = this;
1737     const LogicalSelectionOffsetCaches* currentCache = &amp;cache;
1738     while (cb != &amp;rootBlock) {
1739         logicalRight += cb-&gt;logicalLeft();
1740 
1741         ASSERT(currentCache);
1742         auto info = currentCache-&gt;containingBlockInfo(*cb);
1743         cb = info.block();
1744         if (!cb)
1745             break;
1746         currentCache = info.cache();
1747     }
1748     return logicalRight;
1749 }
1750 
1751 TrackedRendererListHashSet* RenderBlock::positionedObjects() const
1752 {
1753     return positionedDescendantsMap().positionedRenderers(*this);
1754 }
1755 
1756 void RenderBlock::insertPositionedObject(RenderBox&amp; positioned)
1757 {
1758     ASSERT(!isAnonymousBlock());
1759     if (positioned.isRenderFragmentedFlow())
1760         return;
1761     // FIXME: Find out if we can do this as part of positioned.setChildNeedsLayout(MarkOnlyThis)
1762     if (positioned.needsLayout()) {
1763         // We should turn this bit on only while in layout.
1764         ASSERT(posChildNeedsLayout() || view().frameView().layoutContext().isInLayout());
1765         setPosChildNeedsLayoutBit(true);
1766     }
1767     positionedDescendantsMap().addDescendant(*this, positioned, isRenderView() ? PositionedDescendantsMap::MoveDescendantToEnd::Yes
1768         : PositionedDescendantsMap::MoveDescendantToEnd::No);
1769 }
1770 
1771 void RenderBlock::removePositionedObject(const RenderBox&amp; rendererToRemove)
1772 {
1773     positionedDescendantsMap().removeDescendant(rendererToRemove);
1774 }
1775 
1776 void RenderBlock::removePositionedObjects(const RenderBlock* newContainingBlockCandidate, ContainingBlockState containingBlockState)
1777 {
1778     auto* positionedDescendants = positionedObjects();
1779     if (!positionedDescendants)
1780         return;
1781 
1782     Vector&lt;RenderBox*, 16&gt; renderersToRemove;
1783     for (auto* renderer : *positionedDescendants) {
1784         if (newContainingBlockCandidate &amp;&amp; !renderer-&gt;isDescendantOf(newContainingBlockCandidate))
1785             continue;
1786         renderersToRemove.append(renderer);
1787         if (containingBlockState == NewContainingBlock)
1788             renderer-&gt;setChildNeedsLayout(MarkOnlyThis);
1789         // It is the parent block&#39;s job to add positioned children to positioned objects list of its containing block.
1790         // Dirty the parent to ensure this happens.
1791         auto* parent = renderer-&gt;parent();
1792         while (parent &amp;&amp; !parent-&gt;isRenderBlock())
1793             parent = parent-&gt;parent();
1794         if (parent)
1795             parent-&gt;setChildNeedsLayout();
1796     }
1797     for (auto* renderer : renderersToRemove)
1798         removePositionedObject(*renderer);
1799 }
1800 
1801 void RenderBlock::addPercentHeightDescendant(RenderBox&amp; descendant)
1802 {
1803     insertIntoTrackedRendererMaps(*this, descendant);
1804 }
1805 
1806 void RenderBlock::removePercentHeightDescendant(RenderBox&amp; descendant)
1807 {
1808     removeFromTrackedRendererMaps(descendant);
1809 }
1810 
1811 TrackedRendererListHashSet* RenderBlock::percentHeightDescendants() const
1812 {
1813     return percentHeightDescendantsMap ? percentHeightDescendantsMap-&gt;get(this) : nullptr;
1814 }
1815 
1816 bool RenderBlock::hasPercentHeightContainerMap()
1817 {
1818     return percentHeightContainerMap;
1819 }
1820 
1821 bool RenderBlock::hasPercentHeightDescendant(RenderBox&amp; descendant)
1822 {
1823     // We don&#39;t null check percentHeightContainerMap since the caller
1824     // already ensures this and we need to call this function on every
1825     // descendant in clearPercentHeightDescendantsFrom().
1826     ASSERT(percentHeightContainerMap);
1827     return percentHeightContainerMap-&gt;contains(&amp;descendant);
1828 }
1829 
1830 void RenderBlock::removePercentHeightDescendantIfNeeded(RenderBox&amp; descendant)
1831 {
1832     // We query the map directly, rather than looking at style&#39;s
1833     // logicalHeight()/logicalMinHeight()/logicalMaxHeight() since those
1834     // can change with writing mode/directional changes.
1835     if (!hasPercentHeightContainerMap())
1836         return;
1837 
1838     if (!hasPercentHeightDescendant(descendant))
1839         return;
1840 
1841     removePercentHeightDescendant(descendant);
1842 }
1843 
1844 void RenderBlock::clearPercentHeightDescendantsFrom(RenderBox&amp; parent)
1845 {
1846     ASSERT(percentHeightContainerMap);
1847     for (RenderObject* child = parent.firstChild(); child; child = child-&gt;nextInPreOrder(&amp;parent)) {
1848         if (!is&lt;RenderBox&gt;(*child))
1849             continue;
1850 
1851         auto&amp; box = downcast&lt;RenderBox&gt;(*child);
1852         if (!hasPercentHeightDescendant(box))
1853             continue;
1854 
1855         removePercentHeightDescendant(box);
1856     }
1857 }
1858 
1859 bool RenderBlock::isContainingBlockAncestorFor(RenderObject&amp; renderer) const
1860 {
1861     for (const auto* ancestor = renderer.containingBlock(); ancestor; ancestor = ancestor-&gt;containingBlock()) {
1862         if (ancestor == this)
1863             return true;
1864     }
1865     return false;
1866 }
1867 
1868 LayoutUnit RenderBlock::textIndentOffset() const
1869 {
1870     LayoutUnit cw;
1871     if (style().textIndent().isPercentOrCalculated())
1872         cw = availableLogicalWidth();
1873     return minimumValueForLength(style().textIndent(), cw);
1874 }
1875 
1876 LayoutUnit RenderBlock::logicalLeftOffsetForContent(RenderFragmentContainer* fragment) const
1877 {
1878     LayoutUnit logicalLeftOffset = style().isHorizontalWritingMode() ? borderLeft() + paddingLeft() : borderTop() + paddingTop();
1879     if (shouldPlaceBlockDirectionScrollbarOnLeft())
1880         logicalLeftOffset += verticalScrollbarWidth();
1881     if (!fragment)
1882         return logicalLeftOffset;
1883     LayoutRect boxRect = borderBoxRectInFragment(fragment);
1884     return logicalLeftOffset + (isHorizontalWritingMode() ? boxRect.x() : boxRect.y());
1885 }
1886 
1887 LayoutUnit RenderBlock::logicalRightOffsetForContent(RenderFragmentContainer* fragment) const
1888 {
1889     LayoutUnit logicalRightOffset = style().isHorizontalWritingMode() ? borderLeft() + paddingLeft() : borderTop() + paddingTop();
1890     if (shouldPlaceBlockDirectionScrollbarOnLeft())
1891         logicalRightOffset += verticalScrollbarWidth();
1892     logicalRightOffset += availableLogicalWidth();
1893     if (!fragment)
1894         return logicalRightOffset;
1895     LayoutRect boxRect = borderBoxRectInFragment(fragment);
1896     return logicalRightOffset - (logicalWidth() - (isHorizontalWritingMode() ? boxRect.maxX() : boxRect.maxY()));
1897 }
1898 
1899 LayoutUnit RenderBlock::adjustLogicalLeftOffsetForLine(LayoutUnit offsetFromFloats, bool applyTextIndent) const
1900 {
1901     LayoutUnit left = offsetFromFloats;
1902 
1903     if (applyTextIndent &amp;&amp; style().isLeftToRightDirection())
1904         left += textIndentOffset();
1905 
1906     if (style().lineAlign() == LineAlign::None)
1907         return left;
1908 
1909     // Push in our left offset so that it is aligned with the character grid.
1910     auto* layoutState = view().frameView().layoutContext().layoutState();
1911     if (!layoutState)
1912         return left;
1913 
1914     RenderBlock* lineGrid = layoutState-&gt;lineGrid();
1915     if (!lineGrid || lineGrid-&gt;style().writingMode() != style().writingMode())
1916         return left;
1917 
1918     // FIXME: Should letter-spacing apply? This is complicated since it doesn&#39;t apply at the edge?
1919     float maxCharWidth = lineGrid-&gt;style().fontCascade().primaryFont().maxCharWidth();
1920     if (!maxCharWidth)
1921         return left;
1922 
1923     LayoutUnit lineGridOffset = lineGrid-&gt;isHorizontalWritingMode() ? layoutState-&gt;lineGridOffset().width(): layoutState-&gt;lineGridOffset().height();
1924     LayoutUnit layoutOffset = lineGrid-&gt;isHorizontalWritingMode() ? layoutState-&gt;layoutOffset().width() : layoutState-&gt;layoutOffset().height();
1925 
1926     // Push in to the nearest character width (truncated so that we pixel snap left).
1927     // FIXME: Should be patched when subpixel layout lands, since this calculation doesn&#39;t have to pixel snap
1928     // any more (https://bugs.webkit.org/show_bug.cgi?id=79946).
1929     // FIXME: This is wrong for RTL (https://bugs.webkit.org/show_bug.cgi?id=79945).
1930     // FIXME: This doesn&#39;t work with columns or fragments (https://bugs.webkit.org/show_bug.cgi?id=79942).
1931     // FIXME: This doesn&#39;t work when the inline position of the object isn&#39;t set ahead of time.
1932     // FIXME: Dynamic changes to the font or to the inline position need to result in a deep relayout.
1933     // (https://bugs.webkit.org/show_bug.cgi?id=79944)
1934     float remainder = fmodf(maxCharWidth - fmodf(left + layoutOffset - lineGridOffset, maxCharWidth), maxCharWidth);
1935     left += remainder;
1936     return left;
1937 }
1938 
1939 LayoutUnit RenderBlock::adjustLogicalRightOffsetForLine(LayoutUnit offsetFromFloats, bool applyTextIndent) const
1940 {
1941     LayoutUnit right = offsetFromFloats;
1942 
1943     if (applyTextIndent &amp;&amp; !style().isLeftToRightDirection())
1944         right -= textIndentOffset();
1945 
1946     if (style().lineAlign() == LineAlign::None)
1947         return right;
1948 
1949     // Push in our right offset so that it is aligned with the character grid.
1950     auto* layoutState = view().frameView().layoutContext().layoutState();
1951     if (!layoutState)
1952         return right;
1953 
1954     RenderBlock* lineGrid = layoutState-&gt;lineGrid();
1955     if (!lineGrid || lineGrid-&gt;style().writingMode() != style().writingMode())
1956         return right;
1957 
1958     // FIXME: Should letter-spacing apply? This is complicated since it doesn&#39;t apply at the edge?
1959     float maxCharWidth = lineGrid-&gt;style().fontCascade().primaryFont().maxCharWidth();
1960     if (!maxCharWidth)
1961         return right;
1962 
1963     LayoutUnit lineGridOffset = lineGrid-&gt;isHorizontalWritingMode() ? layoutState-&gt;lineGridOffset().width(): layoutState-&gt;lineGridOffset().height();
1964     LayoutUnit layoutOffset = lineGrid-&gt;isHorizontalWritingMode() ? layoutState-&gt;layoutOffset().width() : layoutState-&gt;layoutOffset().height();
1965 
1966     // Push in to the nearest character width (truncated so that we pixel snap right).
1967     // FIXME: Should be patched when subpixel layout lands, since this calculation doesn&#39;t have to pixel snap
1968     // any more (https://bugs.webkit.org/show_bug.cgi?id=79946).
1969     // FIXME: This is wrong for RTL (https://bugs.webkit.org/show_bug.cgi?id=79945).
1970     // FIXME: This doesn&#39;t work with columns or fragments (https://bugs.webkit.org/show_bug.cgi?id=79942).
1971     // FIXME: This doesn&#39;t work when the inline position of the object isn&#39;t set ahead of time.
1972     // FIXME: Dynamic changes to the font or to the inline position need to result in a deep relayout.
1973     // (https://bugs.webkit.org/show_bug.cgi?id=79944)
1974     float remainder = fmodf(fmodf(right + layoutOffset - lineGridOffset, maxCharWidth), maxCharWidth);
1975     right -= ceilf(remainder);
1976     return right;
1977 }
1978 
1979 bool RenderBlock::isPointInOverflowControl(HitTestResult&amp; result, const LayoutPoint&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset)
1980 {
1981     if (!scrollsOverflow())
1982         return false;
1983 
1984     return layer()-&gt;hitTestOverflowControls(result, roundedIntPoint(locationInContainer - toLayoutSize(accumulatedOffset)));
1985 }
1986 
1987 Node* RenderBlock::nodeForHitTest() const
1988 {
1989     // If we are in the margins of block elements that are part of a
1990     // continuation we&#39;re actually still inside the enclosing element
1991     // that was split. Use the appropriate inner node.
1992     if (isRenderView())
1993         return &amp;document();
1994     return continuation() ? continuation()-&gt;element() : element();
1995 }
1996 
1997 bool RenderBlock::nodeAtPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
1998 {
1999     LayoutPoint adjustedLocation(accumulatedOffset + location());
2000     LayoutSize localOffset = toLayoutSize(adjustedLocation);
2001 
2002     if (!isRenderView()) {
2003         // Check if we need to do anything at all.
2004         LayoutRect overflowBox = visualOverflowRect();
2005         flipForWritingMode(overflowBox);
2006         overflowBox.moveBy(adjustedLocation);
2007         if (!locationInContainer.intersects(overflowBox))
2008             return false;
2009     }
2010 
2011     if ((hitTestAction == HitTestBlockBackground || hitTestAction == HitTestChildBlockBackground) &amp;&amp; isPointInOverflowControl(result, locationInContainer.point(), adjustedLocation)) {
2012         updateHitTestResult(result, locationInContainer.point() - localOffset);
2013         // FIXME: isPointInOverflowControl() doesn&#39;t handle rect-based tests yet.
2014         if (result.addNodeToListBasedTestResult(nodeForHitTest(), request, locationInContainer) == HitTestProgress::Stop)
2015            return true;
2016     }
2017 
2018     if (style().clipPath()) {
2019         switch (style().clipPath()-&gt;type()) {
2020         case ClipPathOperation::Shape: {
2021             auto&amp; clipPath = downcast&lt;ShapeClipPathOperation&gt;(*style().clipPath());
2022 
2023             LayoutRect referenceBoxRect;
2024             switch (clipPath.referenceBox()) {
2025             case CSSBoxType::MarginBox:
2026                 referenceBoxRect = marginBoxRect();
2027                 break;
2028             case CSSBoxType::PaddingBox:
2029                 referenceBoxRect = paddingBoxRect();
2030                 break;
2031             case CSSBoxType::FillBox:
2032             case CSSBoxType::ContentBox:
2033                 referenceBoxRect = contentBoxRect();
2034                 break;
2035             case CSSBoxType::StrokeBox:
2036             case CSSBoxType::ViewBox:
2037             case CSSBoxType::BorderBox:
2038             case CSSBoxType::BoxMissing:
2039                 referenceBoxRect = borderBoxRect();
2040             }
2041             if (!clipPath.pathForReferenceRect(referenceBoxRect).contains(locationInContainer.point() - localOffset, clipPath.windRule()))
2042                 return false;
2043             break;
2044         }
2045         case ClipPathOperation::Reference: {
2046             const auto&amp; referenceClipPathOperation = downcast&lt;ReferenceClipPathOperation&gt;(*style().clipPath());
2047             auto* element = document().getElementById(referenceClipPathOperation.fragment());
2048             if (!element || !element-&gt;renderer())
2049                 break;
2050             if (!is&lt;SVGClipPathElement&gt;(*element))
2051                 break;
2052             auto&amp; clipper = downcast&lt;RenderSVGResourceClipper&gt;(*element-&gt;renderer());
2053             if (!clipper.hitTestClipContent(FloatRect(borderBoxRect()), FloatPoint(locationInContainer.point() - localOffset)))
2054                 return false;
2055             break;
2056         }
2057         case ClipPathOperation::Box:
2058             break;
2059         }
2060     }
2061 
2062     // If we have clipping, then we can&#39;t have any spillout.
2063     bool useOverflowClip = hasOverflowClip() &amp;&amp; !hasSelfPaintingLayer();
2064     bool useClip = (hasControlClip() || useOverflowClip);
2065     bool checkChildren = !useClip || (hasControlClip() ? locationInContainer.intersects(controlClipRect(adjustedLocation)) : locationInContainer.intersects(overflowClipRect(adjustedLocation, nullptr, IncludeOverlayScrollbarSize)));
2066     if (checkChildren) {
2067         // Hit test descendants first.
2068         LayoutSize scrolledOffset(localOffset - toLayoutSize(scrollPosition()));
2069 
2070         if (hitTestAction == HitTestFloat &amp;&amp; hitTestFloats(request, result, locationInContainer, toLayoutPoint(scrolledOffset)))
2071             return true;
2072         if (hitTestContents(request, result, locationInContainer, toLayoutPoint(scrolledOffset), hitTestAction)) {
2073             updateHitTestResult(result, flipForWritingMode(locationInContainer.point() - localOffset));
2074             return true;
2075         }
2076     }
2077 
2078     if (!checkChildren &amp;&amp; hitTestExcludedChildrenInBorder(request, result, locationInContainer, adjustedLocation, hitTestAction))
2079         return true;
2080 
2081     // Check if the point is outside radii.
2082     if (!isRenderView() &amp;&amp; style().hasBorderRadius()) {
2083         LayoutRect borderRect = borderBoxRect();
2084         borderRect.moveBy(adjustedLocation);
2085         RoundedRect border = style().getRoundedBorderFor(borderRect);
2086         if (!locationInContainer.intersects(border))
2087             return false;
2088     }
2089 
2090     // Now hit test our background
2091     if (hitTestAction == HitTestBlockBackground || hitTestAction == HitTestChildBlockBackground) {
2092         LayoutRect boundsRect(adjustedLocation, size());
2093         if (visibleToHitTesting() &amp;&amp; locationInContainer.intersects(boundsRect)) {
2094             updateHitTestResult(result, flipForWritingMode(locationInContainer.point() - localOffset));
2095             if (result.addNodeToListBasedTestResult(nodeForHitTest(), request, locationInContainer, boundsRect) == HitTestProgress::Stop)
2096                 return true;
2097         }
2098     }
2099 
2100     return false;
2101 }
2102 
2103 bool RenderBlock::hitTestContents(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
2104 {
2105     if (childrenInline() &amp;&amp; !isTable())
2106         return hitTestInlineChildren(request, result, locationInContainer, accumulatedOffset, hitTestAction);
2107 
2108     // Hit test our children.
2109     HitTestAction childHitTest = hitTestAction;
2110     if (hitTestAction == HitTestChildBlockBackgrounds)
2111         childHitTest = HitTestChildBlockBackground;
2112     for (auto* child = lastChildBox(); child; child = child-&gt;previousSiblingBox()) {
2113         LayoutPoint childPoint = flipForWritingModeForChild(child, accumulatedOffset);
2114         if (!child-&gt;hasSelfPaintingLayer() &amp;&amp; !child-&gt;isFloating() &amp;&amp; child-&gt;nodeAtPoint(request, result, locationInContainer, childPoint, childHitTest))
2115             return true;
2116     }
2117 
2118     return false;
2119 }
2120 
2121 static inline bool isEditingBoundary(RenderElement* ancestor, RenderObject&amp; child)
2122 {
2123     ASSERT(!ancestor || ancestor-&gt;nonPseudoElement());
2124     ASSERT(child.nonPseudoNode());
2125     return !ancestor || !ancestor-&gt;parent() || (ancestor-&gt;hasLayer() &amp;&amp; ancestor-&gt;parent()-&gt;isRenderView())
2126         || ancestor-&gt;nonPseudoElement()-&gt;hasEditableStyle() == child.nonPseudoNode()-&gt;hasEditableStyle();
2127 }
2128 
2129 // FIXME: This function should go on RenderObject as an instance method. Then
2130 // all cases in which positionForPoint recurs could call this instead to
2131 // prevent crossing editable boundaries. This would require many tests.
2132 VisiblePosition positionForPointRespectingEditingBoundaries(RenderBlock&amp; parent, RenderBox&amp; child, const LayoutPoint&amp; pointInParentCoordinates)
2133 {
2134     LayoutPoint childLocation = child.location();
2135     if (child.isInFlowPositioned())
2136         childLocation += child.offsetForInFlowPosition();
2137 
2138     // FIXME: This is wrong if the child&#39;s writing-mode is different from the parent&#39;s.
2139     LayoutPoint pointInChildCoordinates(toLayoutPoint(pointInParentCoordinates - childLocation));
2140 
2141     // If this is an anonymous renderer, we just recur normally
2142     Element* childElement= child.nonPseudoElement();
2143     if (!childElement)
2144         return child.positionForPoint(pointInChildCoordinates, nullptr);
2145 
2146     // Otherwise, first make sure that the editability of the parent and child agree.
2147     // If they don&#39;t agree, then we return a visible position just before or after the child
2148     RenderElement* ancestor = &amp;parent;
2149     while (ancestor &amp;&amp; !ancestor-&gt;nonPseudoElement())
2150         ancestor = ancestor-&gt;parent();
2151 
2152     // If we can&#39;t find an ancestor to check editability on, or editability is unchanged, we recur like normal
2153     if (isEditingBoundary(ancestor, child))
2154         return child.positionForPoint(pointInChildCoordinates, nullptr);
2155 
2156     // Otherwise return before or after the child, depending on if the click was to the logical left or logical right of the child
2157     LayoutUnit childMiddle = parent.logicalWidthForChild(child) / 2;
2158     LayoutUnit logicalLeft = parent.isHorizontalWritingMode() ? pointInChildCoordinates.x() : pointInChildCoordinates.y();
2159     if (logicalLeft &lt; childMiddle)
2160         return ancestor-&gt;createVisiblePosition(childElement-&gt;computeNodeIndex(), DOWNSTREAM);
2161     return ancestor-&gt;createVisiblePosition(childElement-&gt;computeNodeIndex() + 1, UPSTREAM);
2162 }
2163 
2164 VisiblePosition RenderBlock::positionForPointWithInlineChildren(const LayoutPoint&amp;, const RenderFragmentContainer*)
2165 {
2166     ASSERT_NOT_REACHED();
2167     return VisiblePosition();
2168 }
2169 
2170 static inline bool isChildHitTestCandidate(const RenderBox&amp; box)
2171 {
2172     return box.height() &amp;&amp; box.style().visibility() == Visibility::Visible &amp;&amp; !box.isOutOfFlowPositioned() &amp;&amp; !box.isInFlowRenderFragmentedFlow();
2173 }
2174 
2175 // Valid candidates in a FragmentedFlow must be rendered by the fragment.
2176 static inline bool isChildHitTestCandidate(const RenderBox&amp; box, const RenderFragmentContainer* fragment, const LayoutPoint&amp; point)
2177 {
2178     if (!isChildHitTestCandidate(box))
2179         return false;
2180     if (!fragment)
2181         return true;
2182     const RenderBlock&amp; block = is&lt;RenderBlock&gt;(box) ? downcast&lt;RenderBlock&gt;(box) : *box.containingBlock();
2183     return block.fragmentAtBlockOffset(point.y()) == fragment;
2184 }
2185 
2186 VisiblePosition RenderBlock::positionForPoint(const LayoutPoint&amp; point, const RenderFragmentContainer* fragment)
2187 {
2188     if (isTable())
2189         return RenderBox::positionForPoint(point, fragment);
2190 
2191     if (isReplaced()) {
2192         // FIXME: This seems wrong when the object&#39;s writing-mode doesn&#39;t match the line&#39;s writing-mode.
2193         LayoutUnit pointLogicalLeft = isHorizontalWritingMode() ? point.x() : point.y();
2194         LayoutUnit pointLogicalTop = isHorizontalWritingMode() ? point.y() : point.x();
2195 
2196         if (pointLogicalTop &lt; 0 || (pointLogicalTop &lt; logicalHeight() &amp;&amp; pointLogicalLeft &lt; 0))
2197             return createVisiblePosition(caretMinOffset(), DOWNSTREAM);
2198         if (pointLogicalTop &gt;= logicalHeight() || (pointLogicalTop &gt;= 0 &amp;&amp; pointLogicalLeft &gt;= logicalWidth()))
2199             return createVisiblePosition(caretMaxOffset(), DOWNSTREAM);
2200     }
2201 
2202     LayoutPoint pointInContents = point;
2203     offsetForContents(pointInContents);
2204     LayoutPoint pointInLogicalContents(pointInContents);
2205     if (!isHorizontalWritingMode())
2206         pointInLogicalContents = pointInLogicalContents.transposedPoint();
2207 
2208     if (childrenInline())
2209         return positionForPointWithInlineChildren(pointInLogicalContents, fragment);
2210 
2211     RenderBox* lastCandidateBox = lastChildBox();
2212 
2213     if (!fragment)
2214         fragment = fragmentAtBlockOffset(pointInLogicalContents.y());
2215 
2216     while (lastCandidateBox &amp;&amp; !isChildHitTestCandidate(*lastCandidateBox, fragment, pointInLogicalContents))
2217         lastCandidateBox = lastCandidateBox-&gt;previousSiblingBox();
2218 
2219     bool blocksAreFlipped = style().isFlippedBlocksWritingMode();
2220     if (lastCandidateBox) {
2221         if (pointInLogicalContents.y() &gt; logicalTopForChild(*lastCandidateBox)
2222             || (!blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == logicalTopForChild(*lastCandidateBox)))
2223             return positionForPointRespectingEditingBoundaries(*this, *lastCandidateBox, pointInContents);
2224 
2225         for (auto* childBox = firstChildBox(); childBox; childBox = childBox-&gt;nextSiblingBox()) {
2226             if (!isChildHitTestCandidate(*childBox, fragment, pointInLogicalContents))
2227                 continue;
2228             LayoutUnit childLogicalBottom = logicalTopForChild(*childBox) + logicalHeightForChild(*childBox);
2229             if (is&lt;RenderBlockFlow&gt;(childBox))
2230                 childLogicalBottom += downcast&lt;RenderBlockFlow&gt;(childBox)-&gt;lowestFloatLogicalBottom();
2231             // We hit child if our click is above the bottom of its padding box (like IE6/7 and FF3).
2232             if (isChildHitTestCandidate(*childBox, fragment, pointInLogicalContents) &amp;&amp; (pointInLogicalContents.y() &lt; childLogicalBottom
2233                 || (blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == childLogicalBottom)))
2234                 return positionForPointRespectingEditingBoundaries(*this, *childBox, pointInContents);
2235         }
2236     }
2237 
2238     // We only get here if there are no hit test candidate children below the click.
2239     return RenderBox::positionForPoint(point, fragment);
2240 }
2241 
2242 void RenderBlock::offsetForContents(LayoutPoint&amp; offset) const
2243 {
2244     offset = flipForWritingMode(offset);
2245     offset += toLayoutSize(scrollPosition());
2246     offset = flipForWritingMode(offset);
2247 }
2248 
2249 void RenderBlock::computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
2250 {
2251     ASSERT(!childrenInline());
2252 
2253     computeBlockPreferredLogicalWidths(minLogicalWidth, maxLogicalWidth);
2254 
2255     maxLogicalWidth = std::max(minLogicalWidth, maxLogicalWidth);
2256 
2257     int scrollbarWidth = intrinsicScrollbarLogicalWidth();
2258     maxLogicalWidth += scrollbarWidth;
2259     minLogicalWidth += scrollbarWidth;
2260 }
2261 
2262 void RenderBlock::computePreferredLogicalWidths()
2263 {
2264     ASSERT(preferredLogicalWidthsDirty());
2265 
2266     m_minPreferredLogicalWidth = 0;
2267     m_maxPreferredLogicalWidth = 0;
2268 
2269     const RenderStyle&amp; styleToUse = style();
2270     if (!isTableCell() &amp;&amp; styleToUse.logicalWidth().isFixed() &amp;&amp; styleToUse.logicalWidth().value() &gt;= 0
2271         &amp;&amp; !(isDeprecatedFlexItem() &amp;&amp; !styleToUse.logicalWidth().intValue()))
2272         m_minPreferredLogicalWidth = m_maxPreferredLogicalWidth = adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalWidth().value());
2273     else
2274         computeIntrinsicLogicalWidths(m_minPreferredLogicalWidth, m_maxPreferredLogicalWidth);
2275 
2276     if (styleToUse.logicalMaxWidth().isFixed()) {
2277         m_maxPreferredLogicalWidth = std::min(m_maxPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMaxWidth().value()));
2278         m_minPreferredLogicalWidth = std::min(m_minPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMaxWidth().value()));
2279     }
2280 
2281     if (styleToUse.logicalMinWidth().isFixed() &amp;&amp; styleToUse.logicalMinWidth().value() &gt; 0) {
2282         m_maxPreferredLogicalWidth = std::max(m_maxPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMinWidth().value()));
2283         m_minPreferredLogicalWidth = std::max(m_minPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMinWidth().value()));
2284     }
2285 
2286     LayoutUnit borderAndPadding = borderAndPaddingLogicalWidth();
2287     m_minPreferredLogicalWidth += borderAndPadding;
2288     m_maxPreferredLogicalWidth += borderAndPadding;
2289 
2290     setPreferredLogicalWidthsDirty(false);
2291 }
2292 
2293 void RenderBlock::computeBlockPreferredLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
2294 {
2295     const RenderStyle&amp; styleToUse = style();
2296     bool nowrap = styleToUse.whiteSpace() == WhiteSpace::NoWrap;
2297 
2298     RenderObject* child = firstChild();
2299     RenderBlock* containingBlock = this-&gt;containingBlock();
2300     LayoutUnit floatLeftWidth, floatRightWidth;
2301 
2302     LayoutUnit childMinWidth;
2303     LayoutUnit childMaxWidth;
2304     bool hadExcludedChildren = computePreferredWidthsForExcludedChildren(childMinWidth, childMaxWidth);
2305     if (hadExcludedChildren) {
2306         minLogicalWidth = std::max(childMinWidth, minLogicalWidth);
2307         maxLogicalWidth = std::max(childMaxWidth, maxLogicalWidth);
2308     }
2309 
2310     while (child) {
2311         // Positioned children don&#39;t affect the min/max width. Legends in fieldsets are skipped here
2312         // since they compute outside of any one layout system. Other children excluded from
2313         // normal layout are only used with block flows, so it&#39;s ok to calculate them here.
2314         if (child-&gt;isOutOfFlowPositioned() || child-&gt;isExcludedAndPlacedInBorder()) {
2315             child = child-&gt;nextSibling();
2316             continue;
2317         }
2318 
2319         const RenderStyle&amp; childStyle = child-&gt;style();
2320         if (child-&gt;isFloating() || (is&lt;RenderBox&gt;(*child) &amp;&amp; downcast&lt;RenderBox&gt;(*child).avoidsFloats())) {
2321             LayoutUnit floatTotalWidth = floatLeftWidth + floatRightWidth;
2322             if (childStyle.clear() == Clear::Left || childStyle.clear() == Clear::Both) {
2323                 maxLogicalWidth = std::max(floatTotalWidth, maxLogicalWidth);
2324                 floatLeftWidth = 0;
2325             }
2326             if (childStyle.clear() == Clear::Right || childStyle.clear() == Clear::Both) {
2327                 maxLogicalWidth = std::max(floatTotalWidth, maxLogicalWidth);
2328                 floatRightWidth = 0;
2329             }
2330         }
2331 
2332         // A margin basically has three types: fixed, percentage, and auto (variable).
2333         // Auto and percentage margins simply become 0 when computing min/max width.
2334         // Fixed margins can be added in as is.
2335         Length startMarginLength = childStyle.marginStartUsing(&amp;styleToUse);
2336         Length endMarginLength = childStyle.marginEndUsing(&amp;styleToUse);
2337         LayoutUnit margin;
2338         LayoutUnit marginStart;
2339         LayoutUnit marginEnd;
2340         if (startMarginLength.isFixed())
2341             marginStart += startMarginLength.value();
2342         if (endMarginLength.isFixed())
2343             marginEnd += endMarginLength.value();
2344         margin = marginStart + marginEnd;
2345 
2346         LayoutUnit childMinPreferredLogicalWidth, childMaxPreferredLogicalWidth;
2347         computeChildPreferredLogicalWidths(*child, childMinPreferredLogicalWidth, childMaxPreferredLogicalWidth);
2348 
2349         LayoutUnit w = childMinPreferredLogicalWidth + margin;
2350         minLogicalWidth = std::max(w, minLogicalWidth);
2351 
2352         // IE ignores tables for calculation of nowrap. Makes some sense.
2353         if (nowrap &amp;&amp; !child-&gt;isTable())
2354             maxLogicalWidth = std::max(w, maxLogicalWidth);
2355 
2356         w = childMaxPreferredLogicalWidth + margin;
2357 
2358         if (!child-&gt;isFloating()) {
2359             if (is&lt;RenderBox&gt;(*child) &amp;&amp; downcast&lt;RenderBox&gt;(*child).avoidsFloats()) {
2360                 // Determine a left and right max value based off whether or not the floats can fit in the
2361                 // margins of the object.  For negative margins, we will attempt to overlap the float if the negative margin
2362                 // is smaller than the float width.
2363                 bool ltr = containingBlock ? containingBlock-&gt;style().isLeftToRightDirection() : styleToUse.isLeftToRightDirection();
2364                 LayoutUnit marginLogicalLeft = ltr ? marginStart : marginEnd;
2365                 LayoutUnit marginLogicalRight = ltr ? marginEnd : marginStart;
2366                 LayoutUnit maxLeft = marginLogicalLeft &gt; 0 ? std::max(floatLeftWidth, marginLogicalLeft) : floatLeftWidth + marginLogicalLeft;
2367                 LayoutUnit maxRight = marginLogicalRight &gt; 0 ? std::max(floatRightWidth, marginLogicalRight) : floatRightWidth + marginLogicalRight;
2368                 w = childMaxPreferredLogicalWidth + maxLeft + maxRight;
2369                 w = std::max(w, floatLeftWidth + floatRightWidth);
2370             }
2371             else
2372                 maxLogicalWidth = std::max(floatLeftWidth + floatRightWidth, maxLogicalWidth);
2373             floatLeftWidth = floatRightWidth = 0;
2374         }
2375 
2376         if (child-&gt;isFloating()) {
2377             if (childStyle.floating() == Float::Left)
2378                 floatLeftWidth += w;
2379             else
2380                 floatRightWidth += w;
2381         } else
2382             maxLogicalWidth = std::max(w, maxLogicalWidth);
2383 
2384         child = child-&gt;nextSibling();
2385     }
2386 
2387     // Always make sure these values are non-negative.
2388     minLogicalWidth = std::max&lt;LayoutUnit&gt;(0, minLogicalWidth);
2389     maxLogicalWidth = std::max&lt;LayoutUnit&gt;(0, maxLogicalWidth);
2390 
2391     maxLogicalWidth = std::max(floatLeftWidth + floatRightWidth, maxLogicalWidth);
2392 }
2393 
2394 void RenderBlock::computeChildPreferredLogicalWidths(RenderObject&amp; child, LayoutUnit&amp; minPreferredLogicalWidth, LayoutUnit&amp; maxPreferredLogicalWidth) const
2395 {
2396     if (child.isBox() &amp;&amp; child.isHorizontalWritingMode() != isHorizontalWritingMode()) {
2397         // If the child is an orthogonal flow, child&#39;s height determines the width,
2398         // but the height is not available until layout.
2399         // http://dev.w3.org/csswg/css-writing-modes-3/#orthogonal-shrink-to-fit
2400         if (!child.needsLayout()) {
2401             minPreferredLogicalWidth = maxPreferredLogicalWidth = downcast&lt;RenderBox&gt;(child).logicalHeight();
2402             return;
2403         }
2404         minPreferredLogicalWidth = maxPreferredLogicalWidth = downcast&lt;RenderBox&gt;(child).computeLogicalHeightWithoutLayout();
2405         return;
2406     }
2407 
2408     // The preferred widths of flexbox children should never depend on override sizes. They should
2409     // always be computed without regard for any overrides that are present.
2410     Optional&lt;LayoutUnit&gt; overrideHeight;
2411     Optional&lt;LayoutUnit&gt; overrideWidth;
2412 
2413     if (child.isBox()) {
2414         auto&amp; box = downcast&lt;RenderBox&gt;(child);
2415         if (box.isFlexItem()) {
2416             if (box.hasOverrideContentLogicalHeight())
2417                 overrideHeight = Optional&lt;LayoutUnit&gt;(box.overrideContentLogicalHeight());
2418             if (box.hasOverrideContentLogicalWidth())
2419                 overrideWidth = Optional&lt;LayoutUnit&gt;(box.overrideContentLogicalWidth());
2420             box.clearOverrideContentSize();
2421         }
2422     }
2423 
2424     minPreferredLogicalWidth = child.minPreferredLogicalWidth();
2425     maxPreferredLogicalWidth = child.maxPreferredLogicalWidth();
2426 
2427     if (child.isBox()) {
2428         auto&amp; box = downcast&lt;RenderBox&gt;(child);
2429         if (overrideHeight)
2430             box.setOverrideContentLogicalHeight(overrideHeight.value());
2431         if (overrideWidth)
2432             box.setOverrideContentLogicalWidth(overrideWidth.value());
2433     }
2434 
2435     // For non-replaced blocks if the inline size is min|max-content or a definite
2436     // size the min|max-content contribution is that size plus border, padding and
2437     // margin https://drafts.csswg.org/css-sizing/#block-intrinsic
2438     if (child.isRenderBlock()) {
2439         const Length&amp; computedInlineSize = child.style().logicalWidth();
2440         if (computedInlineSize.isMaxContent())
2441             minPreferredLogicalWidth = maxPreferredLogicalWidth;
2442         else if (computedInlineSize.isMinContent())
2443             maxPreferredLogicalWidth = minPreferredLogicalWidth;
2444     }
2445 }
2446 
2447 bool RenderBlock::hasLineIfEmpty() const
2448 {
2449     if (!element())
2450         return false;
2451 
2452     if (element()-&gt;isRootEditableElement())
2453         return true;
2454 
2455     return false;
2456 }
2457 
2458 LayoutUnit RenderBlock::lineHeight(bool firstLine, LineDirectionMode direction, LinePositionMode linePositionMode) const
2459 {
2460     // Inline blocks are replaced elements. Otherwise, just pass off to
2461     // the base class.  If we&#39;re being queried as though we&#39;re the root line
2462     // box, then the fact that we&#39;re an inline-block is irrelevant, and we behave
2463     // just like a block.
2464     if (isReplaced() &amp;&amp; linePositionMode == PositionOnContainingLine)
2465         return RenderBox::lineHeight(firstLine, direction, linePositionMode);
2466 
2467     if (firstLine &amp;&amp; view().usesFirstLineRules()) {
2468         auto&amp; s = firstLineStyle();
2469         if (&amp;s != &amp;style())
2470             return s.computedLineHeight();
2471     }
2472 
2473     return style().computedLineHeight();
2474 }
2475 
2476 int RenderBlock::baselinePosition(FontBaseline baselineType, bool firstLine, LineDirectionMode direction, LinePositionMode linePositionMode) const
2477 {
2478     // Inline blocks are replaced elements. Otherwise, just pass off to
2479     // the base class.  If we&#39;re being queried as though we&#39;re the root line
2480     // box, then the fact that we&#39;re an inline-block is irrelevant, and we behave
2481     // just like a block.
2482     if (isReplaced() &amp;&amp; linePositionMode == PositionOnContainingLine) {
2483         // For &quot;leaf&quot; theme objects, let the theme decide what the baseline position is.
2484         // FIXME: Might be better to have a custom CSS property instead, so that if the theme
2485         // is turned off, checkboxes/radios will still have decent baselines.
2486         // FIXME: Need to patch form controls to deal with vertical lines.
2487         if (style().hasAppearance() &amp;&amp; !theme().isControlContainer(style().appearance()))
2488             return theme().baselinePosition(*this);
2489 
2490         // CSS2.1 states that the baseline of an inline block is the baseline of the last line box in
2491         // the normal flow.  We make an exception for marquees, since their baselines are meaningless
2492         // (the content inside them moves).  This matches WinIE as well, which just bottom-aligns them.
2493         // We also give up on finding a baseline if we have a vertical scrollbar, or if we are scrolled
2494         // vertically (e.g., an overflow:hidden block that has had scrollTop moved).
2495         bool ignoreBaseline = (layer() &amp;&amp; (layer()-&gt;marquee() || (direction == HorizontalLine ? (layer()-&gt;verticalScrollbar() || layer()-&gt;scrollOffset().y() != 0)
2496             : (layer()-&gt;horizontalScrollbar() || layer()-&gt;scrollOffset().x() != 0)))) || (isWritingModeRoot() &amp;&amp; !isRubyRun());
2497 
2498         Optional&lt;int&gt; baselinePos = ignoreBaseline ? Optional&lt;int&gt;() : inlineBlockBaseline(direction);
2499 
2500         if (isDeprecatedFlexibleBox()) {
2501             // Historically, we did this check for all baselines. But we can&#39;t
2502             // remove this code from deprecated flexbox, because it effectively
2503             // breaks -webkit-line-clamp, which is used in the wild -- we would
2504             // calculate the baseline as if -webkit-line-clamp wasn&#39;t used.
2505             // For simplicity, we use this for all uses of deprecated flexbox.
2506             LayoutUnit bottomOfContent = direction == HorizontalLine ? borderTop() + paddingTop() + contentHeight() : borderRight() + paddingRight() + contentWidth();
2507             if (baselinePos &amp;&amp; baselinePos.value() &gt; bottomOfContent)
2508                 baselinePos = Optional&lt;int&gt;();
2509         }
2510         if (baselinePos)
2511             return direction == HorizontalLine ? marginTop() + baselinePos.value() : marginRight() + baselinePos.value();
2512 
2513         return RenderBox::baselinePosition(baselineType, firstLine, direction, linePositionMode);
2514     }
2515 
2516     const RenderStyle&amp; style = firstLine ? firstLineStyle() : this-&gt;style();
2517     const FontMetrics&amp; fontMetrics = style.fontMetrics();
2518     return fontMetrics.ascent(baselineType) + (lineHeight(firstLine, direction, linePositionMode) - fontMetrics.height()) / 2;
2519 }
2520 
2521 LayoutUnit RenderBlock::minLineHeightForReplacedRenderer(bool isFirstLine, LayoutUnit replacedHeight) const
2522 {
2523     if (!document().inNoQuirksMode() &amp;&amp; replacedHeight)
2524         return replacedHeight;
2525 
2526     const RenderStyle&amp; style = isFirstLine ? firstLineStyle() : this-&gt;style();
2527     if (!(style.lineBoxContain().contains(LineBoxContain::Block)))
2528         return 0;
2529 
2530     return std::max&lt;LayoutUnit&gt;(replacedHeight, lineHeight(isFirstLine, isHorizontalWritingMode() ? HorizontalLine : VerticalLine, PositionOfInteriorLineBoxes));
2531 }
2532 
2533 Optional&lt;int&gt; RenderBlock::firstLineBaseline() const
2534 {
2535     if (isWritingModeRoot() &amp;&amp; !isRubyRun())
2536         return Optional&lt;int&gt;();
2537 
2538     for (RenderBox* curr = firstChildBox(); curr; curr = curr-&gt;nextSiblingBox()) {
2539         if (!curr-&gt;isFloatingOrOutOfFlowPositioned()) {
2540             if (Optional&lt;int&gt; result = curr-&gt;firstLineBaseline())
2541                 return Optional&lt;int&gt;(curr-&gt;logicalTop() + result.value()); // Translate to our coordinate space.
2542         }
2543     }
2544 
2545     return Optional&lt;int&gt;();
2546 }
2547 
2548 Optional&lt;int&gt; RenderBlock::inlineBlockBaseline(LineDirectionMode lineDirection) const
2549 {
2550     if (isWritingModeRoot() &amp;&amp; !isRubyRun())
2551         return Optional&lt;int&gt;();
2552 
2553     bool haveNormalFlowChild = false;
2554     for (auto* box = lastChildBox(); box; box = box-&gt;previousSiblingBox()) {
2555         if (box-&gt;isFloatingOrOutOfFlowPositioned())
2556             continue;
2557         haveNormalFlowChild = true;
2558         if (Optional&lt;int&gt; result = box-&gt;inlineBlockBaseline(lineDirection))
2559             return Optional&lt;int&gt;(box-&gt;logicalTop() + result.value()); // Translate to our coordinate space.
2560     }
2561 
2562     if (!haveNormalFlowChild &amp;&amp; hasLineIfEmpty()) {
2563         auto&amp; fontMetrics = firstLineStyle().fontMetrics();
2564         return Optional&lt;int&gt;(fontMetrics.ascent()
2565             + (lineHeight(true, lineDirection, PositionOfInteriorLineBoxes) - fontMetrics.height()) / 2
2566             + (lineDirection == HorizontalLine ? borderTop() + paddingTop() : borderRight() + paddingRight()));
2567     }
2568 
2569     return Optional&lt;int&gt;();
2570 }
2571 
2572 static inline bool isRenderBlockFlowOrRenderButton(RenderElement&amp; renderElement)
2573 {
2574     // We include isRenderButton in this check because buttons are implemented
2575     // using flex box but should still support first-line|first-letter.
2576     // The flex box and specs require that flex box and grid do not support
2577     // first-line|first-letter, though.
2578     // FIXME: Remove when buttons are implemented with align-items instead of
2579     // flex box.
2580     return renderElement.isRenderBlockFlow() || renderElement.isRenderButton();
2581 }
2582 
2583 RenderBlock* RenderBlock::firstLineBlock() const
2584 {
2585     RenderBlock* firstLineBlock = const_cast&lt;RenderBlock*&gt;(this);
2586     bool hasPseudo = false;
2587     while (true) {
2588         hasPseudo = firstLineBlock-&gt;style().hasPseudoStyle(PseudoId::FirstLine);
2589         if (hasPseudo)
2590             break;
2591         RenderElement* parentBlock = firstLineBlock-&gt;parent();
2592         if (firstLineBlock-&gt;isReplaced() || firstLineBlock-&gt;isFloating()
2593             || !parentBlock || parentBlock-&gt;firstChild() != firstLineBlock || !isRenderBlockFlowOrRenderButton(*parentBlock))
2594             break;
2595         firstLineBlock = downcast&lt;RenderBlock&gt;(parentBlock);
2596     }
2597 
2598     if (!hasPseudo)
2599         return nullptr;
2600 
2601     return firstLineBlock;
2602 }
2603 
2604 static inline RenderBlock* findFirstLetterBlock(RenderBlock* start)
2605 {
2606     RenderBlock* firstLetterBlock = start;
2607     while (true) {
2608         bool canHaveFirstLetterRenderer = firstLetterBlock-&gt;style().hasPseudoStyle(PseudoId::FirstLetter)
2609             &amp;&amp; firstLetterBlock-&gt;canHaveGeneratedChildren()
2610             &amp;&amp; isRenderBlockFlowOrRenderButton(*firstLetterBlock);
2611         if (canHaveFirstLetterRenderer)
2612             return firstLetterBlock;
2613 
2614         RenderElement* parentBlock = firstLetterBlock-&gt;parent();
2615         if (firstLetterBlock-&gt;isReplaced() || !parentBlock || parentBlock-&gt;firstChild() != firstLetterBlock
2616             || !isRenderBlockFlowOrRenderButton(*parentBlock))
2617             return nullptr;
2618         firstLetterBlock = downcast&lt;RenderBlock&gt;(parentBlock);
2619     }
2620 
2621     return nullptr;
2622 }
2623 
2624 void RenderBlock::getFirstLetter(RenderObject*&amp; firstLetter, RenderElement*&amp; firstLetterContainer, RenderObject* skipObject)
2625 {
2626     firstLetter = nullptr;
2627     firstLetterContainer = nullptr;
2628 
2629     if (!view().usesFirstLetterRules())
2630         return;
2631 
2632     // Don&#39;t recur
2633     if (style().styleType() == PseudoId::FirstLetter)
2634         return;
2635 
2636     // FIXME: We need to destroy the first-letter object if it is no longer the first child. Need to find
2637     // an efficient way to check for that situation though before implementing anything.
2638     firstLetterContainer = findFirstLetterBlock(this);
2639     if (!firstLetterContainer)
2640         return;
2641 
2642     // Drill into inlines looking for our first text descendant.
2643     firstLetter = firstLetterContainer-&gt;firstChild();
2644     while (firstLetter) {
2645         if (is&lt;RenderText&gt;(*firstLetter)) {
2646             if (firstLetter == skipObject) {
2647                 firstLetter = firstLetter-&gt;nextSibling();
2648                 continue;
2649             }
2650 
2651             break;
2652         }
2653 
2654         RenderElement&amp; current = downcast&lt;RenderElement&gt;(*firstLetter);
2655         if (is&lt;RenderListMarker&gt;(current))
2656             firstLetter = current.nextSibling();
2657         else if (current.isFloatingOrOutOfFlowPositioned()) {
2658             if (current.style().styleType() == PseudoId::FirstLetter) {
2659                 firstLetter = current.firstChild();
2660                 break;
2661             }
2662             firstLetter = current.nextSibling();
2663         } else if (current.isReplaced() || is&lt;RenderButton&gt;(current) || is&lt;RenderMenuList&gt;(current))
2664             break;
2665         else if (current.isFlexibleBoxIncludingDeprecated() || current.isRenderGrid())
2666             firstLetter = current.nextSibling();
2667         else if (current.style().hasPseudoStyle(PseudoId::FirstLetter) &amp;&amp; current.canHaveGeneratedChildren())  {
2668             // We found a lower-level node with first-letter, which supersedes the higher-level style
2669             firstLetterContainer = &amp;current;
2670             firstLetter = current.firstChild();
2671         } else
2672             firstLetter = current.firstChild();
2673     }
2674 
2675     if (!firstLetter)
2676         firstLetterContainer = nullptr;
2677 }
2678 
2679 RenderFragmentedFlow* RenderBlock::cachedEnclosingFragmentedFlow() const
2680 {
2681     RenderBlockRareData* rareData = getBlockRareData(*this);
2682 
2683     if (!rareData || !rareData-&gt;m_enclosingFragmentedFlow)
2684         return nullptr;
2685 
2686     return rareData-&gt;m_enclosingFragmentedFlow.value().get();
2687 }
2688 
2689 bool RenderBlock::cachedEnclosingFragmentedFlowNeedsUpdate() const
2690 {
2691     RenderBlockRareData* rareData = getBlockRareData(*this);
2692 
2693     if (!rareData || !rareData-&gt;m_enclosingFragmentedFlow)
2694         return true;
2695 
2696     return false;
2697 }
2698 
2699 void RenderBlock::setCachedEnclosingFragmentedFlowNeedsUpdate()
2700 {
2701     RenderBlockRareData&amp; rareData = ensureBlockRareData(*this);
2702     rareData.m_enclosingFragmentedFlow = WTF::nullopt;
2703 }
2704 
2705 RenderFragmentedFlow* RenderBlock::updateCachedEnclosingFragmentedFlow(RenderFragmentedFlow* fragmentedFlow) const
2706 {
2707     RenderBlockRareData&amp; rareData = ensureBlockRareData(*this);
2708     rareData.m_enclosingFragmentedFlow = makeWeakPtr(fragmentedFlow);
2709 
2710     return fragmentedFlow;
2711 }
2712 
2713 RenderFragmentedFlow* RenderBlock::locateEnclosingFragmentedFlow() const
2714 {
2715     RenderBlockRareData* rareData = getBlockRareData(*this);
2716     if (!rareData || !rareData-&gt;m_enclosingFragmentedFlow)
2717         return updateCachedEnclosingFragmentedFlow(RenderBox::locateEnclosingFragmentedFlow());
2718 
2719     ASSERT(rareData-&gt;m_enclosingFragmentedFlow.value() == RenderBox::locateEnclosingFragmentedFlow());
2720     return rareData-&gt;m_enclosingFragmentedFlow.value().get();
2721 }
2722 
2723 void RenderBlock::resetEnclosingFragmentedFlowAndChildInfoIncludingDescendants(RenderFragmentedFlow*)
2724 {
2725     if (fragmentedFlowState() == NotInsideFragmentedFlow)
2726         return;
2727 
2728     if (cachedEnclosingFragmentedFlowNeedsUpdate())
2729         return;
2730 
2731     auto* fragmentedFlow = cachedEnclosingFragmentedFlow();
2732     setCachedEnclosingFragmentedFlowNeedsUpdate();
2733     RenderElement::resetEnclosingFragmentedFlowAndChildInfoIncludingDescendants(fragmentedFlow);
2734 }
2735 
2736 LayoutUnit RenderBlock::paginationStrut() const
2737 {
2738     RenderBlockRareData* rareData = getBlockRareData(*this);
2739     return rareData ? rareData-&gt;m_paginationStrut : 0_lu;
2740 }
2741 
2742 LayoutUnit RenderBlock::pageLogicalOffset() const
2743 {
2744     RenderBlockRareData* rareData = getBlockRareData(*this);
2745     return rareData ? rareData-&gt;m_pageLogicalOffset : 0_lu;
2746 }
2747 
2748 void RenderBlock::setPaginationStrut(LayoutUnit strut)
2749 {
2750     RenderBlockRareData* rareData = getBlockRareData(*this);
2751     if (!rareData) {
2752         if (!strut)
2753             return;
2754         rareData = &amp;ensureBlockRareData(*this);
2755     }
2756     rareData-&gt;m_paginationStrut = strut;
2757 }
2758 
2759 void RenderBlock::setPageLogicalOffset(LayoutUnit logicalOffset)
2760 {
2761     RenderBlockRareData* rareData = getBlockRareData(*this);
2762     if (!rareData) {
2763         if (!logicalOffset)
2764             return;
2765         rareData = &amp;ensureBlockRareData(*this);
2766     }
2767     rareData-&gt;m_pageLogicalOffset = logicalOffset;
2768 }
2769 
2770 void RenderBlock::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
2771 {
2772     // For blocks inside inlines, we include margins so that we run right up to the inline boxes
2773     // above and below us (thus getting merged with them to form a single irregular shape).
2774     if (auto* continuation = this-&gt;continuation()) {
2775         // FIXME: This is wrong for block-flows that are horizontal.
2776         // https://bugs.webkit.org/show_bug.cgi?id=46781
2777         rects.append(snappedIntRect(accumulatedOffset.x(), accumulatedOffset.y() - collapsedMarginBefore(), width(), height() + collapsedMarginBefore() + collapsedMarginAfter()));
2778         continuation-&gt;absoluteRects(rects, accumulatedOffset - toLayoutSize(location() + inlineContinuation()-&gt;containingBlock()-&gt;location()));
2779     } else
2780         rects.append(snappedIntRect(accumulatedOffset, size()));
2781 }
2782 
2783 void RenderBlock::absoluteQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
2784 {
2785     if (!continuation()) {
2786         absoluteQuadsIgnoringContinuation({ { }, size() }, quads, wasFixed);
2787         return;
2788     }
2789     // For blocks inside inlines, we include margins so that we run right up to the inline boxes
2790     // above and below us (thus getting merged with them to form a single irregular shape).
2791     auto logicalRect = FloatRect { 0, -collapsedMarginBefore(), width(), height() + collapsedMarginBefore() + collapsedMarginAfter() };
2792     absoluteQuadsIgnoringContinuation(logicalRect, quads, wasFixed);
2793     collectAbsoluteQuadsForContinuation(quads, wasFixed);
2794 }
2795 
2796 void RenderBlock::absoluteQuadsIgnoringContinuation(const FloatRect&amp; logicalRect, Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
2797 {
2798     // FIXME: This is wrong for block-flows that are horizontal.
2799     // https://bugs.webkit.org/show_bug.cgi?id=46781
2800     auto* fragmentedFlow = enclosingFragmentedFlow();
2801     if (!fragmentedFlow || !fragmentedFlow-&gt;absoluteQuadsForBox(quads, wasFixed, this, logicalRect.y(), logicalRect.maxY()))
2802         quads.append(localToAbsoluteQuad(logicalRect, UseTransforms, wasFixed));
2803 }
2804 
2805 LayoutRect RenderBlock::rectWithOutlineForRepaint(const RenderLayerModelObject* repaintContainer, LayoutUnit outlineWidth) const
2806 {
2807     LayoutRect r(RenderBox::rectWithOutlineForRepaint(repaintContainer, outlineWidth));
2808     if (isContinuation())
2809         r.inflateY(collapsedMarginBefore()); // FIXME: This is wrong for block-flows that are horizontal.
2810     return r;
2811 }
2812 
2813 void RenderBlock::updateDragState(bool dragOn)
2814 {
2815     RenderBox::updateDragState(dragOn);
2816     if (RenderBoxModelObject* continuation = this-&gt;continuation())
2817         continuation-&gt;updateDragState(dragOn);
2818 }
2819 
2820 const RenderStyle&amp; RenderBlock::outlineStyleForRepaint() const
2821 {
2822     if (auto* continuation = this-&gt;continuation())
2823         return continuation-&gt;style();
2824     return RenderElement::outlineStyleForRepaint();
2825 }
2826 
2827 void RenderBlock::updateHitTestResult(HitTestResult&amp; result, const LayoutPoint&amp; point)
2828 {
2829     if (result.innerNode())
2830         return;
2831 
2832     if (Node* n = nodeForHitTest()) {
2833         result.setInnerNode(n);
2834         if (!result.innerNonSharedNode())
2835             result.setInnerNonSharedNode(n);
2836         result.setLocalPoint(point);
2837     }
2838 }
2839 
2840 LayoutRect RenderBlock::localCaretRect(InlineBox* inlineBox, unsigned caretOffset, LayoutUnit* extraWidthToEndOfLine)
2841 {
2842     // Do the normal calculation in most cases.
2843     if (firstChild())
2844         return RenderBox::localCaretRect(inlineBox, caretOffset, extraWidthToEndOfLine);
2845 
2846     LayoutRect caretRect = localCaretRectForEmptyElement(width(), textIndentOffset());
2847 
2848     // FIXME: Does this need to adjust for vertical orientation?
2849     if (extraWidthToEndOfLine)
2850         *extraWidthToEndOfLine = width() - caretRect.maxX();
2851 
2852     return caretRect;
2853 }
2854 
2855 void RenderBlock::addFocusRingRectsForInlineChildren(Vector&lt;LayoutRect&gt;&amp;, const LayoutPoint&amp;, const RenderLayerModelObject*)
2856 {
2857     ASSERT_NOT_REACHED();
2858 }
2859 
2860 void RenderBlock::addFocusRingRects(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject* paintContainer)
2861 {
2862     // For blocks inside inlines, we include margins so that we run right up to the inline boxes
2863     // above and below us (thus getting merged with them to form a single irregular shape).
2864     auto* inlineContinuation = this-&gt;inlineContinuation();
2865     if (inlineContinuation) {
2866         // FIXME: This check really isn&#39;t accurate.
2867         bool nextInlineHasLineBox = inlineContinuation-&gt;firstLineBox();
2868         // FIXME: This is wrong. The principal renderer may not be the continuation preceding this block.
2869         // FIXME: This is wrong for block-flows that are horizontal.
2870         // https://bugs.webkit.org/show_bug.cgi?id=46781
2871         bool prevInlineHasLineBox = downcast&lt;RenderInline&gt;(*inlineContinuation-&gt;element()-&gt;renderer()).firstLineBox();
2872         auto topMargin = prevInlineHasLineBox ? collapsedMarginBefore() : 0_lu;
2873         auto bottomMargin = nextInlineHasLineBox ? collapsedMarginAfter() : 0_lu;
2874         LayoutRect rect(additionalOffset.x(), additionalOffset.y() - topMargin, width(), height() + topMargin + bottomMargin);
2875         if (!rect.isEmpty())
2876             rects.append(rect);
2877     } else if (width() &amp;&amp; height())
2878         rects.append(LayoutRect(additionalOffset, size()));
2879 
2880     if (!hasOverflowClip() &amp;&amp; !hasControlClip()) {
2881         if (childrenInline())
2882             addFocusRingRectsForInlineChildren(rects, additionalOffset, paintContainer);
2883 
2884         for (auto&amp; box : childrenOfType&lt;RenderBox&gt;(*this)) {
2885             if (is&lt;RenderListMarker&gt;(box))
2886                 continue;
2887 
2888             FloatPoint pos;
2889             // FIXME: This doesn&#39;t work correctly with transforms.
2890             if (box.layer())
2891                 pos = box.localToContainerPoint(FloatPoint(), paintContainer);
2892             else
2893                 pos = FloatPoint(additionalOffset.x() + box.x(), additionalOffset.y() + box.y());
2894             box.addFocusRingRects(rects, flooredLayoutPoint(pos), paintContainer);
2895         }
2896     }
2897 
2898     if (inlineContinuation)
2899         inlineContinuation-&gt;addFocusRingRects(rects, flooredLayoutPoint(LayoutPoint(additionalOffset + inlineContinuation-&gt;containingBlock()-&gt;location() - location())), paintContainer);
2900 }
2901 
2902 RenderPtr&lt;RenderBlock&gt; RenderBlock::createAnonymousBlockWithStyleAndDisplay(Document&amp; document, const RenderStyle&amp; style, DisplayType display)
2903 {
2904     // FIXME: Do we need to convert all our inline displays to block-type in the anonymous logic ?
2905     RenderPtr&lt;RenderBlock&gt; newBox;
2906     if (display == DisplayType::Flex || display == DisplayType::InlineFlex)
2907         newBox = createRenderer&lt;RenderFlexibleBox&gt;(document, RenderStyle::createAnonymousStyleWithDisplay(style, DisplayType::Flex));
2908     else
2909         newBox = createRenderer&lt;RenderBlockFlow&gt;(document, RenderStyle::createAnonymousStyleWithDisplay(style, DisplayType::Block));
2910 
2911     newBox-&gt;initializeStyle();
2912     return newBox;
2913 }
2914 
2915 LayoutUnit RenderBlock::offsetFromLogicalTopOfFirstPage() const
2916 {
2917     auto* layoutState = view().frameView().layoutContext().layoutState();
2918     if (layoutState &amp;&amp; !layoutState-&gt;isPaginated())
2919         return 0;
2920 
2921     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
2922     if (fragmentedFlow)
2923         return fragmentedFlow-&gt;offsetFromLogicalTopOfFirstFragment(this);
2924 
2925     if (layoutState) {
2926         ASSERT(layoutState-&gt;renderer() == this);
2927 
2928         LayoutSize offsetDelta = layoutState-&gt;layoutOffset() - layoutState-&gt;pageOffset();
2929         return isHorizontalWritingMode() ? offsetDelta.height() : offsetDelta.width();
2930     }
2931 
2932     ASSERT_NOT_REACHED();
2933     return 0;
2934 }
2935 
2936 RenderFragmentContainer* RenderBlock::fragmentAtBlockOffset(LayoutUnit blockOffset) const
2937 {
2938     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
2939     if (!fragmentedFlow || !fragmentedFlow-&gt;hasValidFragmentInfo())
2940         return 0;
2941 
2942     return fragmentedFlow-&gt;fragmentAtBlockOffset(this, offsetFromLogicalTopOfFirstPage() + blockOffset, true);
2943 }
2944 
2945 static bool canComputeFragmentRangeForBox(const RenderBlock&amp; parentBlock, const RenderBox&amp; childBox, const RenderFragmentedFlow* enclosingFragmentedFlow)
2946 {
2947     if (!enclosingFragmentedFlow)
2948         return false;
2949 
2950     if (!enclosingFragmentedFlow-&gt;hasFragments())
2951         return false;
2952 
2953     if (!childBox.canHaveOutsideFragmentRange())
2954         return false;
2955 
2956     return enclosingFragmentedFlow-&gt;hasCachedFragmentRangeForBox(parentBlock);
2957 }
2958 
2959 bool RenderBlock::childBoxIsUnsplittableForFragmentation(const RenderBox&amp; child) const
2960 {
2961     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
2962     bool checkColumnBreaks = fragmentedFlow &amp;&amp; fragmentedFlow-&gt;shouldCheckColumnBreaks();
2963     bool checkPageBreaks = !checkColumnBreaks &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;pageLogicalHeight();
2964     return child.isUnsplittableForPagination() || child.style().breakInside() == BreakInside::Avoid
2965         || (checkColumnBreaks &amp;&amp; child.style().breakInside() == BreakInside::AvoidColumn)
2966         || (checkPageBreaks &amp;&amp; child.style().breakInside() == BreakInside::AvoidPage);
2967 }
2968 
2969 void RenderBlock::computeFragmentRangeForBoxChild(const RenderBox&amp; box) const
2970 {
2971     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
2972     ASSERT(canComputeFragmentRangeForBox(*this, box, fragmentedFlow));
2973 
2974     RenderFragmentContainer* startFragment;
2975     RenderFragmentContainer* endFragment;
2976     LayoutUnit offsetFromLogicalTopOfFirstFragment = box.offsetFromLogicalTopOfFirstPage();
2977     if (childBoxIsUnsplittableForFragmentation(box))
2978         startFragment = endFragment = fragmentedFlow-&gt;fragmentAtBlockOffset(this, offsetFromLogicalTopOfFirstFragment, true);
2979     else {
2980         startFragment = fragmentedFlow-&gt;fragmentAtBlockOffset(this, offsetFromLogicalTopOfFirstFragment, true);
2981         endFragment = fragmentedFlow-&gt;fragmentAtBlockOffset(this, offsetFromLogicalTopOfFirstFragment + logicalHeightForChild(box), true);
2982     }
2983 
2984     fragmentedFlow-&gt;setFragmentRangeForBox(box, startFragment, endFragment);
2985 }
2986 
2987 void RenderBlock::estimateFragmentRangeForBoxChild(const RenderBox&amp; box) const
2988 {
2989     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
2990     if (!canComputeFragmentRangeForBox(*this, box, fragmentedFlow))
2991         return;
2992 
2993     if (childBoxIsUnsplittableForFragmentation(box)) {
2994         computeFragmentRangeForBoxChild(box);
2995         return;
2996     }
2997 
2998     auto estimatedValues = box.computeLogicalHeight(RenderFragmentedFlow::maxLogicalHeight(), logicalTopForChild(box));
2999     LayoutUnit offsetFromLogicalTopOfFirstFragment = box.offsetFromLogicalTopOfFirstPage();
3000     RenderFragmentContainer* startFragment = fragmentedFlow-&gt;fragmentAtBlockOffset(this, offsetFromLogicalTopOfFirstFragment, true);
3001     RenderFragmentContainer* endFragment = fragmentedFlow-&gt;fragmentAtBlockOffset(this, offsetFromLogicalTopOfFirstFragment + estimatedValues.m_extent, true);
3002 
3003     fragmentedFlow-&gt;setFragmentRangeForBox(box, startFragment, endFragment);
3004 }
3005 
3006 bool RenderBlock::updateFragmentRangeForBoxChild(const RenderBox&amp; box) const
3007 {
3008     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
3009     if (!canComputeFragmentRangeForBox(*this, box, fragmentedFlow))
3010         return false;
3011 
3012     RenderFragmentContainer* startFragment = nullptr;
3013     RenderFragmentContainer* endFragment = nullptr;
3014     fragmentedFlow-&gt;getFragmentRangeForBox(&amp;box, startFragment, endFragment);
3015 
3016     computeFragmentRangeForBoxChild(box);
3017 
3018     RenderFragmentContainer* newStartFragment = nullptr;
3019     RenderFragmentContainer* newEndFragment = nullptr;
3020     fragmentedFlow-&gt;getFragmentRangeForBox(&amp;box, newStartFragment, newEndFragment);
3021 
3022 
3023     // Changing the start fragment means we shift everything and a relayout is needed.
3024     if (newStartFragment != startFragment)
3025         return true;
3026 
3027     // The fragment range of the box has changed. Some boxes (e.g floats) may have been positioned assuming
3028     // a different range.
3029     if (box.needsLayoutAfterFragmentRangeChange() &amp;&amp; newEndFragment != endFragment)
3030         return true;
3031 
3032     return false;
3033 }
3034 
3035 LayoutUnit RenderBlock::collapsedMarginBeforeForChild(const RenderBox&amp; child) const
3036 {
3037     // If the child has the same directionality as we do, then we can just return its
3038     // collapsed margin.
3039     if (!child.isWritingModeRoot())
3040         return child.collapsedMarginBefore();
3041 
3042     // The child has a different directionality.  If the child is parallel, then it&#39;s just
3043     // flipped relative to us.  We can use the collapsed margin for the opposite edge.
3044     if (child.isHorizontalWritingMode() == isHorizontalWritingMode())
3045         return child.collapsedMarginAfter();
3046 
3047     // The child is perpendicular to us, which means its margins don&#39;t collapse but are on the
3048     // &quot;logical left/right&quot; sides of the child box.  We can just return the raw margin in this case.
3049     return marginBeforeForChild(child);
3050 }
3051 
3052 LayoutUnit RenderBlock::collapsedMarginAfterForChild(const RenderBox&amp; child) const
3053 {
3054     // If the child has the same directionality as we do, then we can just return its
3055     // collapsed margin.
3056     if (!child.isWritingModeRoot())
3057         return child.collapsedMarginAfter();
3058 
3059     // The child has a different directionality.  If the child is parallel, then it&#39;s just
3060     // flipped relative to us.  We can use the collapsed margin for the opposite edge.
3061     if (child.isHorizontalWritingMode() == isHorizontalWritingMode())
3062         return child.collapsedMarginBefore();
3063 
3064     // The child is perpendicular to us, which means its margins don&#39;t collapse but are on the
3065     // &quot;logical left/right&quot; side of the child box.  We can just return the raw margin in this case.
3066     return marginAfterForChild(child);
3067 }
3068 
3069 bool RenderBlock::hasMarginBeforeQuirk(const RenderBox&amp; child) const
3070 {
3071     // If the child has the same directionality as we do, then we can just return its
3072     // margin quirk.
3073     if (!child.isWritingModeRoot())
3074         return is&lt;RenderBlock&gt;(child) ? downcast&lt;RenderBlock&gt;(child).hasMarginBeforeQuirk() : child.style().hasMarginBeforeQuirk();
3075 
3076     // The child has a different directionality. If the child is parallel, then it&#39;s just
3077     // flipped relative to us. We can use the opposite edge.
3078     if (child.isHorizontalWritingMode() == isHorizontalWritingMode())
3079         return is&lt;RenderBlock&gt;(child) ? downcast&lt;RenderBlock&gt;(child).hasMarginAfterQuirk() : child.style().hasMarginAfterQuirk();
3080 
3081     // The child is perpendicular to us and box sides are never quirky in html.css, and we don&#39;t really care about
3082     // whether or not authors specified quirky ems, since they&#39;re an implementation detail.
3083     return false;
3084 }
3085 
3086 bool RenderBlock::hasMarginAfterQuirk(const RenderBox&amp; child) const
3087 {
3088     // If the child has the same directionality as we do, then we can just return its
3089     // margin quirk.
3090     if (!child.isWritingModeRoot())
3091         return is&lt;RenderBlock&gt;(child) ? downcast&lt;RenderBlock&gt;(child).hasMarginAfterQuirk() : child.style().hasMarginAfterQuirk();
3092 
3093     // The child has a different directionality. If the child is parallel, then it&#39;s just
3094     // flipped relative to us. We can use the opposite edge.
3095     if (child.isHorizontalWritingMode() == isHorizontalWritingMode())
3096         return is&lt;RenderBlock&gt;(child) ? downcast&lt;RenderBlock&gt;(child).hasMarginBeforeQuirk() : child.style().hasMarginBeforeQuirk();
3097 
3098     // The child is perpendicular to us and box sides are never quirky in html.css, and we don&#39;t really care about
3099     // whether or not authors specified quirky ems, since they&#39;re an implementation detail.
3100     return false;
3101 }
3102 
3103 const char* RenderBlock::renderName() const
3104 {
3105     if (isBody())
3106         return &quot;RenderBody&quot;; // FIXME: Temporary hack until we know that the regression tests pass.
3107     if (isFieldset())
3108         return &quot;RenderFieldSet&quot;; // FIXME: Remove eventually, but done to keep tests from breaking.
3109     if (isFloating())
3110         return &quot;RenderBlock (floating)&quot;;
3111     if (isOutOfFlowPositioned())
3112         return &quot;RenderBlock (positioned)&quot;;
3113     if (isAnonymousBlock())
3114         return &quot;RenderBlock (anonymous)&quot;;
3115     // FIXME: Temporary hack while the new generated content system is being implemented.
3116     if (isPseudoElement())
3117         return &quot;RenderBlock (generated)&quot;;
3118     if (isAnonymous())
3119         return &quot;RenderBlock (generated)&quot;;
3120     if (isRelativelyPositioned())
3121         return &quot;RenderBlock (relative positioned)&quot;;
3122     if (isStickilyPositioned())
3123         return &quot;RenderBlock (sticky positioned)&quot;;
3124     return &quot;RenderBlock&quot;;
3125 }
3126 
3127 TextRun RenderBlock::constructTextRun(StringView stringView, const RenderStyle&amp; style, ExpansionBehavior expansion, TextRunFlags flags)
3128 {
3129     auto textDirection = TextDirection::LTR;
3130     bool directionalOverride = style.rtlOrdering() == Order::Visual;
3131     if (flags != DefaultTextRunFlags) {
3132         if (flags &amp; RespectDirection)
3133             textDirection = style.direction();
3134         if (flags &amp; RespectDirectionOverride)
3135             directionalOverride |= isOverride(style.unicodeBidi());
3136     }
3137     return TextRun(stringView, 0, 0, expansion, textDirection, directionalOverride);
3138 }
3139 
3140 TextRun RenderBlock::constructTextRun(const String&amp; string, const RenderStyle&amp; style, ExpansionBehavior expansion, TextRunFlags flags)
3141 {
3142     return constructTextRun(StringView(string), style, expansion, flags);
3143 }
3144 
3145 TextRun RenderBlock::constructTextRun(const AtomString&amp; atomString, const RenderStyle&amp; style, ExpansionBehavior expansion, TextRunFlags flags)
3146 {
3147     return constructTextRun(StringView(atomString), style, expansion, flags);
3148 }
3149 
3150 TextRun RenderBlock::constructTextRun(const RenderText&amp; text, const RenderStyle&amp; style, ExpansionBehavior expansion)
3151 {
3152     return constructTextRun(text.stringView(), style, expansion);
3153 }
3154 
3155 TextRun RenderBlock::constructTextRun(const RenderText&amp; text, unsigned offset, unsigned length, const RenderStyle&amp; style, ExpansionBehavior expansion)
3156 {
3157     unsigned stop = offset + length;
3158     ASSERT(stop &lt;= text.text().length());
3159     return constructTextRun(text.stringView(offset, stop), style, expansion);
3160 }
3161 
3162 TextRun RenderBlock::constructTextRun(const LChar* characters, unsigned length, const RenderStyle&amp; style, ExpansionBehavior expansion)
3163 {
3164     return constructTextRun(StringView(characters, length), style, expansion);
3165 }
3166 
3167 TextRun RenderBlock::constructTextRun(const UChar* characters, unsigned length, const RenderStyle&amp; style, ExpansionBehavior expansion)
3168 {
3169     return constructTextRun(StringView(characters, length), style, expansion);
3170 }
3171 
3172 #if ASSERT_ENABLED
3173 void RenderBlock::checkPositionedObjectsNeedLayout()
3174 {
3175     auto* positionedDescendants = positionedObjects();
3176     if (!positionedDescendants)
3177         return;
3178 
3179     for (auto* renderer : *positionedDescendants)
3180         ASSERT(!renderer-&gt;needsLayout());
3181 }
3182 #endif // ASSERT_ENABLED
3183 
3184 bool RenderBlock::hasDefiniteLogicalHeight() const
3185 {
3186     return (bool)availableLogicalHeightForPercentageComputation();
3187 }
3188 
3189 Optional&lt;LayoutUnit&gt; RenderBlock::availableLogicalHeightForPercentageComputation() const
3190 {
3191     Optional&lt;LayoutUnit&gt; availableHeight;
3192 
3193     // For anonymous blocks that are skipped during percentage height calculation,
3194     // we consider them to have an indefinite height.
3195     if (skipContainingBlockForPercentHeightCalculation(*this, false))
3196         return availableHeight;
3197 
3198     const auto&amp; styleToUse = style();
3199 
3200     // A positioned element that specified both top/bottom or that specifies
3201     // height should be treated as though it has a height explicitly specified
3202     // that can be used for any percentage computations.
3203     bool isOutOfFlowPositionedWithSpecifiedHeight = isOutOfFlowPositioned() &amp;&amp; (!styleToUse.logicalHeight().isAuto() || (!styleToUse.logicalTop().isAuto() &amp;&amp; !styleToUse.logicalBottom().isAuto()));
3204 
3205     Optional&lt;LayoutUnit&gt; stretchedFlexHeight;
3206     if (isFlexItem())
3207         stretchedFlexHeight = downcast&lt;RenderFlexibleBox&gt;(parent())-&gt;childLogicalHeightForPercentageResolution(*this);
3208 
3209     if (stretchedFlexHeight)
3210         availableHeight = stretchedFlexHeight;
3211     else if (isGridItem() &amp;&amp; hasOverrideContentLogicalHeight())
3212         availableHeight = overrideContentLogicalHeight();
3213     else if (styleToUse.logicalHeight().isFixed()) {
3214         LayoutUnit contentBoxHeight = adjustContentBoxLogicalHeightForBoxSizing((LayoutUnit)styleToUse.logicalHeight().value());
3215         availableHeight = std::max(0_lu, constrainContentBoxLogicalHeightByMinMax(contentBoxHeight - scrollbarLogicalHeight(), WTF::nullopt));
3216     } else if (styleToUse.logicalHeight().isPercentOrCalculated() &amp;&amp; !isOutOfFlowPositionedWithSpecifiedHeight) {
3217         Optional&lt;LayoutUnit&gt; heightWithScrollbar = computePercentageLogicalHeight(styleToUse.logicalHeight());
3218         if (heightWithScrollbar) {
3219             LayoutUnit contentBoxHeightWithScrollbar = adjustContentBoxLogicalHeightForBoxSizing(heightWithScrollbar.value());
3220             // We need to adjust for min/max height because this method does not
3221             // handle the min/max of the current block, its caller does. So the
3222             // return value from the recursive call will not have been adjusted
3223             // yet.
3224             LayoutUnit contentBoxHeight = constrainContentBoxLogicalHeightByMinMax(contentBoxHeightWithScrollbar - scrollbarLogicalHeight(), WTF::nullopt);
3225             availableHeight = std::max(0_lu, contentBoxHeight);
3226         }
3227     } else if (isOutOfFlowPositionedWithSpecifiedHeight) {
3228         // Don&#39;t allow this to affect the block&#39; size() member variable, since this
3229         // can get called while the block is still laying out its kids.
3230         LogicalExtentComputedValues computedValues = computeLogicalHeight(logicalHeight(), 0_lu);
3231         availableHeight = computedValues.m_extent - borderAndPaddingLogicalHeight() - scrollbarLogicalHeight();
3232     } else if (isRenderView())
3233         availableHeight = view().pageOrViewLogicalHeight();
3234 
3235     return availableHeight;
3236 }
3237 
3238 void RenderBlock::layoutExcludedChildren(bool relayoutChildren)
3239 {
3240     if (!isFieldset())
3241         return;
3242 
3243     setIntrinsicBorderForFieldset(0);
3244 
3245     RenderBox* box = findFieldsetLegend();
3246     if (!box)
3247         return;
3248 
3249     box-&gt;setIsExcludedFromNormalLayout(true);
3250     for (auto&amp; child : childrenOfType&lt;RenderBox&gt;(*this)) {
3251         if (&amp;child == box || !child.isLegend())
3252             continue;
3253         child.setIsExcludedFromNormalLayout(false);
3254     }
3255 
3256     RenderBox&amp; legend = *box;
3257     if (relayoutChildren)
3258         legend.setChildNeedsLayout(MarkOnlyThis);
3259     legend.layoutIfNeeded();
3260 
3261     LayoutUnit logicalLeft;
3262     if (style().isLeftToRightDirection()) {
3263         switch (legend.style().textAlign()) {
3264         case TextAlignMode::Center:
3265             logicalLeft = (logicalWidth() - logicalWidthForChild(legend)) / 2;
3266             break;
3267         case TextAlignMode::Right:
3268             logicalLeft = logicalWidth() - borderEnd() - paddingEnd() - logicalWidthForChild(legend);
3269             break;
3270         default:
3271             logicalLeft = borderStart() + paddingStart() + marginStartForChild(legend);
3272             break;
3273         }
3274     } else {
3275         switch (legend.style().textAlign()) {
3276         case TextAlignMode::Left:
3277             logicalLeft = borderStart() + paddingStart();
3278             break;
3279         case TextAlignMode::Center: {
3280             // Make sure that the extra pixel goes to the end side in RTL (since it went to the end side
3281             // in LTR).
3282             LayoutUnit centeredWidth = logicalWidth() - logicalWidthForChild(legend);
3283             logicalLeft = centeredWidth - centeredWidth / 2;
3284             break;
3285         }
3286         default:
3287             logicalLeft = logicalWidth() - borderStart() - paddingStart() - marginStartForChild(legend) - logicalWidthForChild(legend);
3288             break;
3289         }
3290     }
3291 
3292     setLogicalLeftForChild(legend, logicalLeft);
3293 
3294     LayoutUnit fieldsetBorderBefore = borderBefore();
3295     LayoutUnit legendLogicalHeight = logicalHeightForChild(legend);
3296     LayoutUnit legendAfterMargin = marginAfterForChild(legend);
3297     LayoutUnit topPositionForLegend = std::max(0_lu, (fieldsetBorderBefore - legendLogicalHeight) / 2);
3298     LayoutUnit bottomPositionForLegend = topPositionForLegend + legendLogicalHeight + legendAfterMargin;
3299 
3300     // Place the legend now.
3301     setLogicalTopForChild(legend, topPositionForLegend);
3302 
3303     // If the bottom of the legend (including its after margin) is below the fieldset border,
3304     // then we need to add in sufficient intrinsic border to account for this gap.
3305     // FIXME: Should we support the before margin of the legend? Not entirely clear.
3306     // FIXME: Consider dropping support for the after margin of the legend. Not sure other
3307     // browsers support that anyway.
3308     if (bottomPositionForLegend &gt; fieldsetBorderBefore)
3309         setIntrinsicBorderForFieldset(bottomPositionForLegend - fieldsetBorderBefore);
3310 
3311     // Now that the legend is included in the border extent, we can set our logical height
3312     // to the borderBefore (which includes the legend and its after margin if they were bigger
3313     // than the actual fieldset border) and then add in our padding before.
3314     setLogicalHeight(borderBefore() + paddingBefore());
3315 }
3316 
3317 RenderBox* RenderBlock::findFieldsetLegend(FieldsetFindLegendOption option) const
3318 {
3319     for (auto&amp; legend : childrenOfType&lt;RenderBox&gt;(*this)) {
3320         if (option == FieldsetIgnoreFloatingOrOutOfFlow &amp;&amp; legend.isFloatingOrOutOfFlowPositioned())
3321             continue;
3322         if (legend.isLegend())
3323             return const_cast&lt;RenderBox*&gt;(&amp;legend);
3324     }
3325     return nullptr;
3326 }
3327 
3328 void RenderBlock::adjustBorderBoxRectForPainting(LayoutRect&amp; paintRect)
3329 {
3330     if (!isFieldset() || !intrinsicBorderForFieldset())
3331         return;
3332 
3333     auto* legend = findFieldsetLegend();
3334     if (!legend)
3335         return;
3336 
3337     if (style().isHorizontalWritingMode()) {
3338         LayoutUnit yOff = std::max(0_lu, (legend-&gt;height() - RenderBox::borderBefore()) / 2);
3339         paintRect.setHeight(paintRect.height() - yOff);
3340         if (style().writingMode() == TopToBottomWritingMode)
3341             paintRect.setY(paintRect.y() + yOff);
3342     } else {
3343         LayoutUnit xOff = std::max(0_lu, (legend-&gt;width() - RenderBox::borderBefore()) / 2);
3344         paintRect.setWidth(paintRect.width() - xOff);
3345         if (style().writingMode() == LeftToRightWritingMode)
3346             paintRect.setX(paintRect.x() + xOff);
3347     }
3348 }
3349 
3350 LayoutRect RenderBlock::paintRectToClipOutFromBorder(const LayoutRect&amp; paintRect)
3351 {
3352     LayoutRect clipRect;
3353     if (!isFieldset())
3354         return clipRect;
3355     auto* legend = findFieldsetLegend();
3356     if (!legend)
3357         return clipRect;
3358 
3359     LayoutUnit borderExtent = RenderBox::borderBefore();
3360     if (style().isHorizontalWritingMode()) {
3361         clipRect.setX(paintRect.x() + legend-&gt;x());
3362         clipRect.setY(style().writingMode() == TopToBottomWritingMode ? paintRect.y() : paintRect.y() + paintRect.height() - borderExtent);
3363         clipRect.setWidth(legend-&gt;width());
3364         clipRect.setHeight(borderExtent);
3365     } else {
3366         clipRect.setX(style().writingMode() == LeftToRightWritingMode ? paintRect.x() : paintRect.x() + paintRect.width() - borderExtent);
3367         clipRect.setY(paintRect.y() + legend-&gt;y());
3368         clipRect.setWidth(borderExtent);
3369         clipRect.setHeight(legend-&gt;height());
3370     }
3371     return clipRect;
3372 }
3373 
3374 LayoutUnit RenderBlock::intrinsicBorderForFieldset() const
3375 {
3376     auto* rareData = getBlockRareData(*this);
3377     return rareData ? rareData-&gt;m_intrinsicBorderForFieldset : 0_lu;
3378 }
3379 
3380 void RenderBlock::setIntrinsicBorderForFieldset(LayoutUnit padding)
3381 {
3382     auto* rareData = getBlockRareData(*this);
3383     if (!rareData) {
3384         if (!padding)
3385             return;
3386         rareData = &amp;ensureBlockRareData(*this);
3387     }
3388     rareData-&gt;m_intrinsicBorderForFieldset = padding;
3389 }
3390 
3391 LayoutUnit RenderBlock::borderTop() const
3392 {
3393     if (style().writingMode() != TopToBottomWritingMode || !intrinsicBorderForFieldset())
3394         return RenderBox::borderTop();
3395     return RenderBox::borderTop() + intrinsicBorderForFieldset();
3396 }
3397 
3398 LayoutUnit RenderBlock::borderLeft() const
3399 {
3400     if (style().writingMode() != LeftToRightWritingMode || !intrinsicBorderForFieldset())
3401         return RenderBox::borderLeft();
3402     return RenderBox::borderLeft() + intrinsicBorderForFieldset();
3403 }
3404 
3405 LayoutUnit RenderBlock::borderBottom() const
3406 {
3407     if (style().writingMode() != BottomToTopWritingMode || !intrinsicBorderForFieldset())
3408         return RenderBox::borderBottom();
3409     return RenderBox::borderBottom() + intrinsicBorderForFieldset();
3410 }
3411 
3412 LayoutUnit RenderBlock::borderRight() const
3413 {
3414     if (style().writingMode() != RightToLeftWritingMode || !intrinsicBorderForFieldset())
3415         return RenderBox::borderRight();
3416     return RenderBox::borderRight() + intrinsicBorderForFieldset();
3417 }
3418 
3419 LayoutUnit RenderBlock::borderBefore() const
3420 {
3421     return RenderBox::borderBefore() + intrinsicBorderForFieldset();
3422 }
3423 
3424 bool RenderBlock::computePreferredWidthsForExcludedChildren(LayoutUnit&amp; minWidth, LayoutUnit&amp; maxWidth) const
3425 {
3426     if (!isFieldset())
3427         return false;
3428 
3429     auto* legend = findFieldsetLegend();
3430     if (!legend)
3431         return false;
3432 
3433     legend-&gt;setIsExcludedFromNormalLayout(true);
3434 
3435     computeChildPreferredLogicalWidths(*legend, minWidth, maxWidth);
3436 
3437     // These are going to be added in later, so we subtract them out to reflect the
3438     // fact that the legend is outside the scrollable area.
3439     auto scrollbarWidth = intrinsicScrollbarLogicalWidth();
3440     minWidth -= scrollbarWidth;
3441     maxWidth -= scrollbarWidth;
3442 
3443     const auto&amp; childStyle = legend-&gt;style();
3444     auto startMarginLength = childStyle.marginStartUsing(&amp;style());
3445     auto endMarginLength = childStyle.marginEndUsing(&amp;style());
3446     LayoutUnit margin;
3447     LayoutUnit marginStart;
3448     LayoutUnit marginEnd;
3449     if (startMarginLength.isFixed())
3450         marginStart += startMarginLength.value();
3451     if (endMarginLength.isFixed())
3452         marginEnd += endMarginLength.value();
3453     margin = marginStart + marginEnd;
3454 
3455     minWidth += margin;
3456     maxWidth += margin;
3457 
3458     return true;
3459 }
3460 
3461 LayoutUnit RenderBlock::adjustBorderBoxLogicalHeightForBoxSizing(LayoutUnit height) const
3462 {
3463     // FIXME: We&#39;re doing this to match other browsers even though it&#39;s questionable.
3464     // Shouldn&#39;t height:100px mean the fieldset content gets 100px of height even if the
3465     // resulting fieldset becomes much taller because of the legend?
3466     LayoutUnit bordersPlusPadding = borderAndPaddingLogicalHeight();
3467     if (style().boxSizing() == BoxSizing::ContentBox)
3468         return height + bordersPlusPadding - intrinsicBorderForFieldset();
3469     return std::max(height, bordersPlusPadding);
3470 }
3471 
3472 LayoutUnit RenderBlock::adjustContentBoxLogicalHeightForBoxSizing(Optional&lt;LayoutUnit&gt; height) const
3473 {
3474     // FIXME: We&#39;re doing this to match other browsers even though it&#39;s questionable.
3475     // Shouldn&#39;t height:100px mean the fieldset content gets 100px of height even if the
3476     // resulting fieldset becomes much taller because of the legend?
3477     if (!height)
3478         return 0;
3479     LayoutUnit result = height.value();
3480     if (style().boxSizing() == BoxSizing::BorderBox)
3481         result -= borderAndPaddingLogicalHeight();
3482     else
3483         result -= intrinsicBorderForFieldset();
3484     return std::max(0_lu, result);
3485 }
3486 
3487 void RenderBlock::paintExcludedChildrenInBorder(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
3488 {
3489     if (!isFieldset())
3490         return;
3491 
3492     RenderBox* box = findFieldsetLegend();
3493     if (!box || !box-&gt;isExcludedFromNormalLayout() || box-&gt;hasSelfPaintingLayer())
3494         return;
3495 
3496     LayoutPoint childPoint = flipForWritingModeForChild(box, paintOffset);
3497     box-&gt;paintAsInlineBlock(paintInfo, childPoint);
3498 }
3499 
3500 bool RenderBlock::hitTestExcludedChildrenInBorder(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
3501 {
3502     if (!isFieldset())
3503         return false;
3504 
3505     auto* legend = findFieldsetLegend();
3506     if (!legend || !legend-&gt;isExcludedFromNormalLayout() || legend-&gt;hasSelfPaintingLayer())
3507         return false;
3508 
3509     HitTestAction childHitTest = hitTestAction;
3510     if (hitTestAction == HitTestChildBlockBackgrounds)
3511         childHitTest = HitTestChildBlockBackground;
3512     LayoutPoint childPoint = flipForWritingModeForChild(legend, accumulatedOffset);
3513     return legend-&gt;nodeAtPoint(request, result, locationInContainer, childPoint, childHitTest);
3514 }
3515 
3516 } // namespace WebCore
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
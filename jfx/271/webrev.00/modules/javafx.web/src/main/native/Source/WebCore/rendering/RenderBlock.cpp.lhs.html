<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlock.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2007 David Smith (catfish.man@gmail.com)
   5  * Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Apple Inc. All rights reserved.
   6  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;RenderBlock.h&quot;
  26 
  27 #include &quot;AXObjectCache.h&quot;
  28 #include &quot;Document.h&quot;
  29 #include &quot;Editor.h&quot;
  30 #include &quot;Element.h&quot;
  31 #include &quot;EventRegion.h&quot;
  32 #include &quot;FloatQuad.h&quot;
  33 #include &quot;Frame.h&quot;
  34 #include &quot;FrameSelection.h&quot;
  35 #include &quot;FrameView.h&quot;
  36 #include &quot;GraphicsContext.h&quot;
  37 #include &quot;HTMLNames.h&quot;
  38 #include &quot;HitTestLocation.h&quot;
  39 #include &quot;HitTestResult.h&quot;
<a name="1" id="anc1"></a>
  40 #include &quot;InlineElementBox.h&quot;
  41 #include &quot;InlineIterator.h&quot;
  42 #include &quot;InlineTextBox.h&quot;
  43 #include &quot;LayoutRepainter.h&quot;
  44 #include &quot;LogicalSelectionOffsetCaches.h&quot;
  45 #include &quot;OverflowEvent.h&quot;
  46 #include &quot;Page.h&quot;
  47 #include &quot;PaintInfo.h&quot;
  48 #include &quot;RenderBlockFlow.h&quot;
  49 #include &quot;RenderBoxFragmentInfo.h&quot;
  50 #include &quot;RenderButton.h&quot;
  51 #include &quot;RenderChildIterator.h&quot;
  52 #include &quot;RenderCombineText.h&quot;
  53 #include &quot;RenderDeprecatedFlexibleBox.h&quot;
  54 #include &quot;RenderFlexibleBox.h&quot;
  55 #include &quot;RenderFragmentedFlow.h&quot;
  56 #include &quot;RenderInline.h&quot;
  57 #include &quot;RenderIterator.h&quot;
  58 #include &quot;RenderLayer.h&quot;
  59 #include &quot;RenderLayoutState.h&quot;
  60 #include &quot;RenderListMarker.h&quot;
  61 #include &quot;RenderMenuList.h&quot;
  62 #include &quot;RenderSVGResourceClipper.h&quot;
  63 #include &quot;RenderSVGRoot.h&quot;
  64 #include &quot;RenderTableCell.h&quot;
  65 #include &quot;RenderTextFragment.h&quot;
  66 #include &quot;RenderTheme.h&quot;
  67 #include &quot;RenderTreeBuilder.h&quot;
  68 #include &quot;RenderTreePosition.h&quot;
  69 #include &quot;RenderView.h&quot;
  70 #include &quot;SVGSVGElement.h&quot;
  71 #include &quot;Settings.h&quot;
  72 #include &quot;ShadowRoot.h&quot;
  73 #include &quot;ShapeOutsideInfo.h&quot;
  74 #include &quot;TransformState.h&quot;
  75 #include &lt;wtf/IsoMallocInlines.h&gt;
  76 #include &lt;wtf/NeverDestroyed.h&gt;
  77 #include &lt;wtf/Optional.h&gt;
  78 #include &lt;wtf/SetForScope.h&gt;
  79 #include &lt;wtf/StackStats.h&gt;
  80 
  81 namespace WebCore {
  82 
  83 using namespace HTMLNames;
  84 using namespace WTF::Unicode;
  85 
  86 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderBlock);
  87 
  88 struct SameSizeAsRenderBlock : public RenderBox {
  89 };
  90 
  91 COMPILE_ASSERT(sizeof(RenderBlock) == sizeof(SameSizeAsRenderBlock), RenderBlock_should_stay_small);
  92 
  93 typedef HashMap&lt;const RenderBlock*, std::unique_ptr&lt;TrackedRendererListHashSet&gt;&gt; TrackedDescendantsMap;
  94 typedef HashMap&lt;const RenderBox*, std::unique_ptr&lt;HashSet&lt;const RenderBlock*&gt;&gt;&gt; TrackedContainerMap;
  95 
  96 static TrackedDescendantsMap* percentHeightDescendantsMap;
  97 static TrackedContainerMap* percentHeightContainerMap;
  98 
  99 static void insertIntoTrackedRendererMaps(const RenderBlock&amp; container, RenderBox&amp; descendant)
 100 {
 101     if (!percentHeightDescendantsMap) {
 102         percentHeightDescendantsMap = new TrackedDescendantsMap;
 103         percentHeightContainerMap = new TrackedContainerMap;
 104     }
 105 
 106     auto&amp; descendantSet = percentHeightDescendantsMap-&gt;ensure(&amp;container, [] {
 107         return makeUnique&lt;TrackedRendererListHashSet&gt;();
 108     }).iterator-&gt;value;
 109 
 110     bool added = descendantSet-&gt;add(&amp;descendant).isNewEntry;
 111     if (!added) {
 112         ASSERT(percentHeightContainerMap-&gt;get(&amp;descendant));
 113         ASSERT(percentHeightContainerMap-&gt;get(&amp;descendant)-&gt;contains(&amp;container));
 114         return;
 115     }
 116 
 117     auto&amp; containerSet = percentHeightContainerMap-&gt;ensure(&amp;descendant, [] {
 118         return makeUnique&lt;HashSet&lt;const RenderBlock*&gt;&gt;();
 119     }).iterator-&gt;value;
 120 
 121     ASSERT(!containerSet-&gt;contains(&amp;container));
 122     containerSet-&gt;add(&amp;container);
 123 }
 124 
 125 static void removeFromTrackedRendererMaps(RenderBox&amp; descendant)
 126 {
 127     if (!percentHeightDescendantsMap)
 128         return;
 129 
 130     std::unique_ptr&lt;HashSet&lt;const RenderBlock*&gt;&gt; containerSet = percentHeightContainerMap-&gt;take(&amp;descendant);
 131     if (!containerSet)
 132         return;
 133 
 134     for (auto* container : *containerSet) {
 135         // FIXME: Disabling this assert temporarily until we fix the layout
 136         // bugs associated with positioned objects not properly cleared from
 137         // their ancestor chain before being moved. See webkit bug 93766.
 138         // ASSERT(descendant-&gt;isDescendantOf(container));
 139         auto descendantsMapIterator = percentHeightDescendantsMap-&gt;find(container);
 140         ASSERT(descendantsMapIterator != percentHeightDescendantsMap-&gt;end());
 141         if (descendantsMapIterator == percentHeightDescendantsMap-&gt;end())
 142             continue;
 143         auto&amp; descendantSet = descendantsMapIterator-&gt;value;
 144         ASSERT(descendantSet-&gt;contains(&amp;descendant));
 145         descendantSet-&gt;remove(&amp;descendant);
 146         if (descendantSet-&gt;isEmpty())
 147             percentHeightDescendantsMap-&gt;remove(descendantsMapIterator);
 148     }
 149 }
 150 
 151 class PositionedDescendantsMap {
 152 public:
 153     enum class MoveDescendantToEnd { No, Yes };
 154     void addDescendant(const RenderBlock&amp; containingBlock, RenderBox&amp; positionedDescendant, MoveDescendantToEnd moveDescendantToEnd)
 155     {
 156         // Protect against double insert where a descendant would end up with multiple containing blocks.
 157         auto* previousContainingBlock = m_containerMap.get(&amp;positionedDescendant);
 158         if (previousContainingBlock &amp;&amp; previousContainingBlock != &amp;containingBlock) {
 159             if (auto* descendants = m_descendantsMap.get(previousContainingBlock))
 160                 descendants-&gt;remove(&amp;positionedDescendant);
 161         }
 162 
 163         auto&amp; descendants = m_descendantsMap.ensure(&amp;containingBlock, [] {
 164             return makeUnique&lt;TrackedRendererListHashSet&gt;();
 165         }).iterator-&gt;value;
 166 
 167         bool isNewEntry = moveDescendantToEnd == MoveDescendantToEnd::Yes ? descendants-&gt;appendOrMoveToLast(&amp;positionedDescendant).isNewEntry
 168             : descendants-&gt;add(&amp;positionedDescendant).isNewEntry;
 169         if (!isNewEntry) {
 170             ASSERT(m_containerMap.contains(&amp;positionedDescendant));
 171             return;
 172         }
 173         m_containerMap.set(&amp;positionedDescendant, &amp;containingBlock);
 174     }
 175 
 176     void removeDescendant(const RenderBox&amp; positionedDescendant)
 177     {
 178         auto* containingBlock = m_containerMap.take(&amp;positionedDescendant);
 179         if (!containingBlock)
 180             return;
 181 
 182         auto descendantsIterator = m_descendantsMap.find(containingBlock);
 183         ASSERT(descendantsIterator != m_descendantsMap.end());
 184         if (descendantsIterator == m_descendantsMap.end())
 185             return;
 186 
 187         auto&amp; descendants = descendantsIterator-&gt;value;
 188         ASSERT(descendants-&gt;contains(const_cast&lt;RenderBox*&gt;(&amp;positionedDescendant)));
 189 
 190         descendants-&gt;remove(const_cast&lt;RenderBox*&gt;(&amp;positionedDescendant));
 191         if (descendants-&gt;isEmpty())
 192             m_descendantsMap.remove(descendantsIterator);
 193     }
 194 
 195     void removeContainingBlock(const RenderBlock&amp; containingBlock)
 196     {
 197         auto descendants = m_descendantsMap.take(&amp;containingBlock);
 198         if (!descendants)
 199             return;
 200 
 201         for (auto* renderer : *descendants)
 202             m_containerMap.remove(renderer);
 203     }
 204 
 205     TrackedRendererListHashSet* positionedRenderers(const RenderBlock&amp; containingBlock) const
 206     {
 207         return m_descendantsMap.get(&amp;containingBlock);
 208     }
 209 
 210 private:
 211     using DescendantsMap = HashMap&lt;const RenderBlock*, std::unique_ptr&lt;TrackedRendererListHashSet&gt;&gt;;
 212     using ContainerMap = HashMap&lt;const RenderBox*, const RenderBlock*&gt;;
 213 
 214     DescendantsMap m_descendantsMap;
 215     ContainerMap m_containerMap;
 216 };
 217 
 218 static PositionedDescendantsMap&amp; positionedDescendantsMap()
 219 {
 220     static NeverDestroyed&lt;PositionedDescendantsMap&gt; mapForPositionedDescendants;
 221     return mapForPositionedDescendants;
 222 }
 223 
 224 typedef HashMap&lt;RenderBlock*, std::unique_ptr&lt;ListHashSet&lt;RenderInline*&gt;&gt;&gt; ContinuationOutlineTableMap;
 225 
 226 struct UpdateScrollInfoAfterLayoutTransaction {
 227     UpdateScrollInfoAfterLayoutTransaction(const RenderView&amp; view)
 228         : nestedCount(0)
 229         , view(&amp;view)
 230     {
 231     }
 232 
 233     int nestedCount;
 234     const RenderView* view;
 235     HashSet&lt;RenderBlock*&gt; blocks;
 236 };
 237 
 238 typedef Vector&lt;UpdateScrollInfoAfterLayoutTransaction&gt; DelayedUpdateScrollInfoStack;
 239 static std::unique_ptr&lt;DelayedUpdateScrollInfoStack&gt;&amp; updateScrollInfoAfterLayoutTransactionStack()
 240 {
 241     static NeverDestroyed&lt;std::unique_ptr&lt;DelayedUpdateScrollInfoStack&gt;&gt; delayedUpdatedScrollInfoStack;
 242     return delayedUpdatedScrollInfoStack;
 243 }
 244 
 245 // Allocated only when some of these fields have non-default values
 246 
 247 struct RenderBlockRareData {
 248     WTF_MAKE_NONCOPYABLE(RenderBlockRareData); WTF_MAKE_FAST_ALLOCATED;
 249 public:
 250     RenderBlockRareData()
 251     {
 252     }
 253 
 254     LayoutUnit m_paginationStrut;
 255     LayoutUnit m_pageLogicalOffset;
 256     LayoutUnit m_intrinsicBorderForFieldset;
 257 
 258     Optional&lt;WeakPtr&lt;RenderFragmentedFlow&gt;&gt; m_enclosingFragmentedFlow;
 259 };
 260 
 261 typedef HashMap&lt;const RenderBlock*, std::unique_ptr&lt;RenderBlockRareData&gt;&gt; RenderBlockRareDataMap;
 262 static RenderBlockRareDataMap* gRareDataMap;
 263 
 264 // This class helps dispatching the &#39;overflow&#39; event on layout change. overflow can be set on RenderBoxes, yet the existing code
 265 // only works on RenderBlocks. If this change, this class should be shared with other RenderBoxes.
 266 class OverflowEventDispatcher {
 267     WTF_MAKE_NONCOPYABLE(OverflowEventDispatcher);
 268 public:
 269     OverflowEventDispatcher(const RenderBlock* block)
 270         : m_block(block)
 271         , m_hadHorizontalLayoutOverflow(false)
 272         , m_hadVerticalLayoutOverflow(false)
 273     {
 274         m_shouldDispatchEvent = !m_block-&gt;isAnonymous() &amp;&amp; m_block-&gt;hasOverflowClip() &amp;&amp; m_block-&gt;document().hasListenerType(Document::OVERFLOWCHANGED_LISTENER);
 275         if (m_shouldDispatchEvent) {
 276             m_hadHorizontalLayoutOverflow = m_block-&gt;hasHorizontalLayoutOverflow();
 277             m_hadVerticalLayoutOverflow = m_block-&gt;hasVerticalLayoutOverflow();
 278         }
 279     }
 280 
 281     ~OverflowEventDispatcher()
 282     {
 283         if (!m_shouldDispatchEvent)
 284             return;
 285 
 286         bool hasHorizontalLayoutOverflow = m_block-&gt;hasHorizontalLayoutOverflow();
 287         bool hasVerticalLayoutOverflow = m_block-&gt;hasVerticalLayoutOverflow();
 288 
 289         bool horizontalLayoutOverflowChanged = hasHorizontalLayoutOverflow != m_hadHorizontalLayoutOverflow;
 290         bool verticalLayoutOverflowChanged = hasVerticalLayoutOverflow != m_hadVerticalLayoutOverflow;
 291         if (!horizontalLayoutOverflowChanged &amp;&amp; !verticalLayoutOverflowChanged)
 292             return;
 293 
 294         Ref&lt;OverflowEvent&gt; overflowEvent = OverflowEvent::create(horizontalLayoutOverflowChanged, hasHorizontalLayoutOverflow, verticalLayoutOverflowChanged, hasVerticalLayoutOverflow);
 295         overflowEvent-&gt;setTarget(m_block-&gt;element());
 296         m_block-&gt;document().enqueueOverflowEvent(WTFMove(overflowEvent));
 297     }
 298 
 299 private:
 300     const RenderBlock* m_block;
 301     bool m_shouldDispatchEvent;
 302     bool m_hadHorizontalLayoutOverflow;
 303     bool m_hadVerticalLayoutOverflow;
 304 };
 305 
 306 RenderBlock::RenderBlock(Element&amp; element, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 307     : RenderBox(element, WTFMove(style), baseTypeFlags | RenderBlockFlag)
 308 {
 309 }
 310 
 311 RenderBlock::RenderBlock(Document&amp; document, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)
 312     : RenderBox(document, WTFMove(style), baseTypeFlags | RenderBlockFlag)
 313 {
 314 }
 315 
 316 static void removeBlockFromPercentageDescendantAndContainerMaps(RenderBlock* block)
 317 {
 318     if (!percentHeightDescendantsMap)
 319         return;
 320     std::unique_ptr&lt;TrackedRendererListHashSet&gt; descendantSet = percentHeightDescendantsMap-&gt;take(block);
 321     if (!descendantSet)
 322         return;
 323 
 324     for (auto* descendant : *descendantSet) {
 325         auto it = percentHeightContainerMap-&gt;find(descendant);
 326         ASSERT(it != percentHeightContainerMap-&gt;end());
 327         if (it == percentHeightContainerMap-&gt;end())
 328             continue;
 329         auto* containerSet = it-&gt;value.get();
 330         ASSERT(containerSet-&gt;contains(block));
 331         containerSet-&gt;remove(block);
 332         if (containerSet-&gt;isEmpty())
 333             percentHeightContainerMap-&gt;remove(it);
 334     }
 335 }
 336 
 337 RenderBlock::~RenderBlock()
 338 {
 339     // Blocks can be added to gRareDataMap during willBeDestroyed(), so this code can&#39;t move there.
 340     if (gRareDataMap)
 341         gRareDataMap-&gt;remove(this);
 342 
 343     // Do not add any more code here. Add it to willBeDestroyed() instead.
 344 }
 345 
 346 // Note that this is not called for RenderBlockFlows.
 347 void RenderBlock::willBeDestroyed()
 348 {
 349     if (!renderTreeBeingDestroyed()) {
 350         if (parent())
 351             parent()-&gt;dirtyLinesFromChangedChild(*this);
 352     }
 353 
 354     blockWillBeDestroyed();
 355 
 356     RenderBox::willBeDestroyed();
 357 }
 358 
 359 void RenderBlock::blockWillBeDestroyed()
 360 {
 361     removeFromUpdateScrollInfoAfterLayoutTransaction();
 362 
 363     removeBlockFromPercentageDescendantAndContainerMaps(this);
 364     positionedDescendantsMap().removeContainingBlock(*this);
 365 }
 366 
 367 bool RenderBlock::hasRareData() const
 368 {
 369     return gRareDataMap ? gRareDataMap-&gt;contains(this) : false;
 370 }
 371 
 372 void RenderBlock::removePositionedObjectsIfNeeded(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
 373 {
 374     bool hadTransform = oldStyle.hasTransformRelatedProperty();
 375     bool willHaveTransform = newStyle.hasTransformRelatedProperty();
 376     if (oldStyle.position() == newStyle.position() &amp;&amp; hadTransform == willHaveTransform)
 377         return;
 378 
 379     // We are no longer the containing block for fixed descendants.
 380     if (hadTransform &amp;&amp; !willHaveTransform) {
 381         // Our positioned descendants will be inserted into a new containing block&#39;s positioned objects list during the next layout.
 382         removePositionedObjects(nullptr, NewContainingBlock);
 383         return;
 384     }
 385 
 386     // We are no longer the containing block for absolute positioned descendants.
 387     if (newStyle.position() == PositionType::Static &amp;&amp; !willHaveTransform) {
 388         // Our positioned descendants will be inserted into a new containing block&#39;s positioned objects list during the next layout.
 389         removePositionedObjects(nullptr, NewContainingBlock);
 390         return;
 391     }
 392 
 393     // We are a new containing block.
 394     if (oldStyle.position() == PositionType::Static &amp;&amp; !hadTransform) {
 395         // Remove our absolutely positioned descendants from their current containing block.
 396         // They will be inserted into our positioned objects list during layout.
 397         auto* containingBlock = parent();
 398         while (containingBlock &amp;&amp; !is&lt;RenderView&gt;(*containingBlock)
 399             &amp;&amp; (containingBlock-&gt;style().position() == PositionType::Static || (containingBlock-&gt;isInline() &amp;&amp; !containingBlock-&gt;isReplaced()))) {
 400             if (containingBlock-&gt;style().position() == PositionType::Relative &amp;&amp; containingBlock-&gt;isInline() &amp;&amp; !containingBlock-&gt;isReplaced()) {
 401                 containingBlock = containingBlock-&gt;containingBlock();
 402                 break;
 403             }
 404             containingBlock = containingBlock-&gt;parent();
 405         }
 406         if (containingBlock &amp;&amp; is&lt;RenderBlock&gt;(*containingBlock))
 407             downcast&lt;RenderBlock&gt;(*containingBlock).removePositionedObjects(this, NewContainingBlock);
 408     }
 409 }
 410 
 411 void RenderBlock::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
 412 {
 413     const RenderStyle* oldStyle = hasInitializedStyle() ? &amp;style() : nullptr;
 414     setReplaced(newStyle.isDisplayInlineType());
 415     if (oldStyle)
 416         removePositionedObjectsIfNeeded(*oldStyle, newStyle);
 417     RenderBox::styleWillChange(diff, newStyle);
 418 }
 419 
 420 static bool borderOrPaddingLogicalWidthChanged(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
 421 {
 422     if (newStyle.isHorizontalWritingMode()) {
 423         return oldStyle.borderLeftWidth() != newStyle.borderLeftWidth()
 424             || oldStyle.borderRightWidth() != newStyle.borderRightWidth()
 425             || oldStyle.paddingLeft() != newStyle.paddingLeft()
 426             || oldStyle.paddingRight() != newStyle.paddingRight();
 427     }
 428 
 429     return oldStyle.borderTopWidth() != newStyle.borderTopWidth()
 430         || oldStyle.borderBottomWidth() != newStyle.borderBottomWidth()
 431         || oldStyle.paddingTop() != newStyle.paddingTop()
 432         || oldStyle.paddingBottom() != newStyle.paddingBottom();
 433 }
 434 
 435 void RenderBlock::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
 436 {
 437     bool hadTransform = hasTransform();
 438     RenderBox::styleDidChange(diff, oldStyle);
 439 
 440     if (hadTransform != hasTransform())
 441         adjustFragmentedFlowStateOnContainingBlockChangeIfNeeded();
 442 
 443     propagateStyleToAnonymousChildren(PropagateToBlockChildrenOnly);
 444 
 445     // It&#39;s possible for our border/padding to change, but for the overall logical width of the block to
 446     // end up being the same. We keep track of this change so in layoutBlock, we can know to set relayoutChildren=true.
 447     setShouldForceRelayoutChildren(oldStyle &amp;&amp; diff == StyleDifference::Layout &amp;&amp; needsLayout() &amp;&amp; borderOrPaddingLogicalWidthChanged(*oldStyle, style()));
 448 }
 449 
 450 RenderPtr&lt;RenderBlock&gt; RenderBlock::clone() const
 451 {
 452     RenderPtr&lt;RenderBlock&gt; cloneBlock;
 453     if (isAnonymousBlock()) {
 454         cloneBlock = RenderPtr&lt;RenderBlock&gt;(createAnonymousBlock());
 455         cloneBlock-&gt;setChildrenInline(childrenInline());
 456     } else {
 457         RenderTreePosition insertionPosition(*parent());
 458         cloneBlock = static_pointer_cast&lt;RenderBlock&gt;(element()-&gt;createElementRenderer(RenderStyle::clone(style()), insertionPosition));
 459         cloneBlock-&gt;initializeStyle();
 460 
 461         // This takes care of setting the right value of childrenInline in case
 462         // generated content is added to cloneBlock and &#39;this&#39; does not have
 463         // generated content added yet.
 464         cloneBlock-&gt;setChildrenInline(cloneBlock-&gt;firstChild() ? cloneBlock-&gt;firstChild()-&gt;isInline() : childrenInline());
 465     }
 466     cloneBlock-&gt;setFragmentedFlowState(fragmentedFlowState());
 467     return cloneBlock;
 468 }
 469 
 470 void RenderBlock::deleteLines()
 471 {
 472     if (AXObjectCache* cache = document().existingAXObjectCache())
 473         cache-&gt;deferRecomputeIsIgnored(element());
 474 }
 475 
 476 bool RenderBlock::childrenPreventSelfCollapsing() const
 477 {
 478     // Whether or not we collapse is dependent on whether all our normal flow children
 479     // are also self-collapsing.
 480     for (RenderBox* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
 481         if (child-&gt;isFloatingOrOutOfFlowPositioned())
 482             continue;
 483         if (!child-&gt;isSelfCollapsingBlock())
 484             return true;
 485     }
 486     return false;
 487 }
 488 
 489 bool RenderBlock::isSelfCollapsingBlock() const
 490 {
 491     // We are not self-collapsing if we
 492     // (a) have a non-zero height according to layout (an optimization to avoid wasting time)
 493     // (b) are a table,
 494     // (c) have border/padding,
 495     // (d) have a min-height
 496     // (e) have specified that one of our margins can&#39;t collapse using a CSS extension
 497     if (logicalHeight() &gt; 0
 498         || isTable() || borderAndPaddingLogicalHeight()
 499         || style().logicalMinHeight().isPositive()
 500         || style().marginBeforeCollapse() == MarginCollapse::Separate || style().marginAfterCollapse() == MarginCollapse::Separate)
 501         return false;
 502 
 503     Length logicalHeightLength = style().logicalHeight();
 504     bool hasAutoHeight = logicalHeightLength.isAuto();
 505     if (logicalHeightLength.isPercentOrCalculated() &amp;&amp; !document().inQuirksMode()) {
 506         hasAutoHeight = true;
 507         for (RenderBlock* cb = containingBlock(); cb &amp;&amp; !is&lt;RenderView&gt;(*cb); cb = cb-&gt;containingBlock()) {
 508             if (cb-&gt;style().logicalHeight().isFixed() || cb-&gt;isTableCell())
 509                 hasAutoHeight = false;
 510         }
 511     }
 512 
 513     // If the height is 0 or auto, then whether or not we are a self-collapsing block depends
 514     // on whether we have content that is all self-collapsing or not.
 515     if (hasAutoHeight || ((logicalHeightLength.isFixed() || logicalHeightLength.isPercentOrCalculated()) &amp;&amp; logicalHeightLength.isZero()))
 516         return !childrenPreventSelfCollapsing();
 517 
 518     return false;
 519 }
 520 
 521 static inline UpdateScrollInfoAfterLayoutTransaction* currentUpdateScrollInfoAfterLayoutTransaction()
 522 {
 523     if (!updateScrollInfoAfterLayoutTransactionStack())
 524         return nullptr;
 525     return &amp;updateScrollInfoAfterLayoutTransactionStack()-&gt;last();
 526 }
 527 
 528 void RenderBlock::beginUpdateScrollInfoAfterLayoutTransaction()
 529 {
 530     if (!updateScrollInfoAfterLayoutTransactionStack())
 531         updateScrollInfoAfterLayoutTransactionStack() = makeUnique&lt;DelayedUpdateScrollInfoStack&gt;();
 532     if (updateScrollInfoAfterLayoutTransactionStack()-&gt;isEmpty() || currentUpdateScrollInfoAfterLayoutTransaction()-&gt;view != &amp;view())
 533         updateScrollInfoAfterLayoutTransactionStack()-&gt;append(UpdateScrollInfoAfterLayoutTransaction(view()));
 534     ++currentUpdateScrollInfoAfterLayoutTransaction()-&gt;nestedCount;
 535 }
 536 
 537 void RenderBlock::endAndCommitUpdateScrollInfoAfterLayoutTransaction()
 538 {
 539     UpdateScrollInfoAfterLayoutTransaction* transaction = currentUpdateScrollInfoAfterLayoutTransaction();
 540     ASSERT(transaction);
 541     ASSERT(transaction-&gt;view == &amp;view());
 542     if (--transaction-&gt;nestedCount)
 543         return;
 544 
 545     // Calling RenderLayer::updateScrollInfoAfterLayout() may cause its associated block to layout again and
 546     // updates its scroll info (i.e. call RenderBlock::updateScrollInfoAfterLayout()). We remove |transaction|
 547     // from the transaction stack to ensure that all subsequent calls to RenderBlock::updateScrollInfoAfterLayout()
 548     // are dispatched immediately. That is, to ensure that such subsequent calls aren&#39;t added to |transaction|
 549     // while we are processing it.
 550     auto blocksToUpdate = copyToVector(transaction-&gt;blocks);
 551     updateScrollInfoAfterLayoutTransactionStack()-&gt;removeLast();
 552     if (updateScrollInfoAfterLayoutTransactionStack()-&gt;isEmpty())
 553         updateScrollInfoAfterLayoutTransactionStack() = nullptr;
 554 
 555     for (auto* block : blocksToUpdate) {
 556         ASSERT(block-&gt;hasOverflowClip());
 557         block-&gt;layer()-&gt;updateScrollInfoAfterLayout();
 558         block-&gt;clearLayoutOverflow();
 559     }
 560 }
 561 
 562 void RenderBlock::removeFromUpdateScrollInfoAfterLayoutTransaction()
 563 {
 564     if (UNLIKELY(updateScrollInfoAfterLayoutTransactionStack().get() != 0)) {
 565         UpdateScrollInfoAfterLayoutTransaction* transaction = currentUpdateScrollInfoAfterLayoutTransaction();
 566         ASSERT(transaction);
 567         if (transaction-&gt;view == &amp;view())
 568             transaction-&gt;blocks.remove(this);
 569     }
 570 }
 571 
 572 void RenderBlock::updateScrollInfoAfterLayout()
 573 {
 574     if (!hasOverflowClip())
 575         return;
 576 
 577     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=97937
 578     // Workaround for now. We cannot delay the scroll info for overflow
 579     // for items with opposite writing directions, as the contents needs
 580     // to overflow in that direction
 581     if (!style().isFlippedBlocksWritingMode()) {
 582         UpdateScrollInfoAfterLayoutTransaction* transaction = currentUpdateScrollInfoAfterLayoutTransaction();
 583         if (transaction &amp;&amp; transaction-&gt;view == &amp;view()) {
 584             transaction-&gt;blocks.add(this);
 585             return;
 586         }
 587     }
 588     if (layer())
 589         layer()-&gt;updateScrollInfoAfterLayout();
 590 }
 591 
 592 void RenderBlock::layout()
 593 {
 594     StackStats::LayoutCheckPoint layoutCheckPoint;
 595     OverflowEventDispatcher dispatcher(this);
 596 
 597     // Table cells call layoutBlock directly, so don&#39;t add any logic here.  Put code into
 598     // layoutBlock().
 599     layoutBlock(false);
 600 
 601     // It&#39;s safe to check for control clip here, since controls can never be table cells.
 602     // If we have a lightweight clip, there can never be any overflow from children.
 603     UpdateScrollInfoAfterLayoutTransaction* transaction = currentUpdateScrollInfoAfterLayoutTransaction();
 604     bool isDelayingUpdateScrollInfoAfterLayoutInView = transaction &amp;&amp; transaction-&gt;view == &amp;view();
 605     if (hasControlClip() &amp;&amp; m_overflow &amp;&amp; !isDelayingUpdateScrollInfoAfterLayoutInView)
 606         clearLayoutOverflow();
 607 
 608     invalidateBackgroundObscurationStatus();
 609 }
 610 
 611 static RenderBlockRareData* getBlockRareData(const RenderBlock&amp; block)
 612 {
 613     return gRareDataMap ? gRareDataMap-&gt;get(&amp;block) : nullptr;
 614 }
 615 
 616 static RenderBlockRareData&amp; ensureBlockRareData(const RenderBlock&amp; block)
 617 {
 618     if (!gRareDataMap)
 619         gRareDataMap = new RenderBlockRareDataMap;
 620 
 621     auto&amp; rareData = gRareDataMap-&gt;add(&amp;block, nullptr).iterator-&gt;value;
 622     if (!rareData)
 623         rareData = makeUnique&lt;RenderBlockRareData&gt;();
 624     return *rareData.get();
 625 }
 626 
 627 void RenderBlock::preparePaginationBeforeBlockLayout(bool&amp; relayoutChildren)
 628 {
 629     // Fragments changing widths can force us to relayout our children.
 630     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
 631     if (fragmentedFlow)
 632         fragmentedFlow-&gt;logicalWidthChangedInFragmentsForBlock(this, relayoutChildren);
 633 }
 634 
 635 bool RenderBlock::recomputeLogicalWidth()
 636 {
 637     LayoutUnit oldWidth = logicalWidth();
 638 
 639     updateLogicalWidth();
 640 
 641     bool hasBorderOrPaddingLogicalWidthChanged = this-&gt;hasBorderOrPaddingLogicalWidthChanged();
 642     setShouldForceRelayoutChildren(false);
 643 
 644     return oldWidth != logicalWidth() || hasBorderOrPaddingLogicalWidthChanged;
 645 }
 646 
 647 void RenderBlock::layoutBlock(bool, LayoutUnit)
 648 {
 649     ASSERT_NOT_REACHED();
 650     clearNeedsLayout();
 651 }
 652 
 653 void RenderBlock::addOverflowFromChildren()
 654 {
 655     if (childrenInline())
 656         addOverflowFromInlineChildren();
 657     else
 658         addOverflowFromBlockChildren();
 659 
 660     // If this block is flowed inside a flow thread, make sure its overflow is propagated to the containing fragments.
 661     if (m_overflow) {
 662         if (RenderFragmentedFlow* containingFragmentedFlow = enclosingFragmentedFlow())
 663             containingFragmentedFlow-&gt;addFragmentsVisualOverflow(this, m_overflow-&gt;visualOverflowRect());
 664     }
 665 }
 666 
 667 // Overflow is always relative to the border-box of the element in question.
 668 // Therefore, if the element has a vertical scrollbar placed on the left, an overflow rect at x=2px would conceptually intersect the scrollbar.
 669 void RenderBlock::computeOverflow(LayoutUnit oldClientAfterEdge, bool)
 670 {
 671     clearOverflow();
 672     addOverflowFromChildren();
 673 
 674     addOverflowFromPositionedObjects();
 675 
 676     if (hasOverflowClip()) {
 677         // When we have overflow clip, propagate the original spillout since it will include collapsed bottom margins
 678         // and bottom padding.  Set the axis we don&#39;t care about to be 1, since we want this overflow to always
 679         // be considered reachable.
 680         LayoutRect clientRect(flippedClientBoxRect());
 681         LayoutRect rectToApply;
 682         if (isHorizontalWritingMode())
 683             rectToApply = LayoutRect(clientRect.x(), clientRect.y(), 1_lu, std::max(0_lu, oldClientAfterEdge - clientRect.y()));
 684         else
 685             rectToApply = LayoutRect(clientRect.x(), clientRect.y(), std::max(0_lu, oldClientAfterEdge - clientRect.x()), 1_lu);
 686         addLayoutOverflow(rectToApply);
 687         if (hasRenderOverflow())
 688             m_overflow-&gt;setLayoutClientAfterEdge(oldClientAfterEdge);
 689     }
 690 
 691     // Add visual overflow from box-shadow, border-image-outset and outline.
 692     addVisualEffectOverflow();
 693 
 694     // Add visual overflow from theme.
 695     addVisualOverflowFromTheme();
 696 }
 697 
 698 void RenderBlock::clearLayoutOverflow()
 699 {
 700     if (!m_overflow)
 701         return;
 702 
 703     if (visualOverflowRect() == borderBoxRect()) {
 704         // FIXME: Implement complete solution for fragments overflow.
 705         clearOverflow();
 706         return;
 707     }
 708 
 709     m_overflow-&gt;setLayoutOverflow(borderBoxRect());
 710 }
 711 
 712 void RenderBlock::addOverflowFromBlockChildren()
 713 {
 714     for (auto* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
 715         if (!child-&gt;isFloatingOrOutOfFlowPositioned())
 716             addOverflowFromChild(child);
 717     }
 718 }
 719 
 720 void RenderBlock::addOverflowFromPositionedObjects()
 721 {
 722     TrackedRendererListHashSet* positionedDescendants = positionedObjects();
 723     if (!positionedDescendants)
 724         return;
 725 
 726     for (auto it = positionedDescendants-&gt;begin(), end = positionedDescendants-&gt;end(); it != end; ++it) {
 727         RenderBox* positionedObject = *it;
 728 
 729         // Fixed positioned elements don&#39;t contribute to layout overflow, since they don&#39;t scroll with the content.
 730         if (positionedObject-&gt;style().position() != PositionType::Fixed)
 731             addOverflowFromChild(positionedObject, { positionedObject-&gt;x(), positionedObject-&gt;y() });
 732     }
 733 }
 734 
 735 void RenderBlock::addVisualOverflowFromTheme()
 736 {
 737     if (!style().hasAppearance())
 738         return;
 739 
 740     FloatRect inflatedRect = borderBoxRect();
 741     theme().adjustRepaintRect(*this, inflatedRect);
 742     addVisualOverflow(snappedIntRect(LayoutRect(inflatedRect)));
 743 
 744     if (RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow())
 745         fragmentedFlow-&gt;addFragmentsVisualOverflowFromTheme(this);
 746 }
 747 
 748 LayoutUnit RenderBlock::computeStartPositionDeltaForChildAvoidingFloats(const RenderBox&amp; child, LayoutUnit childMarginStart, RenderFragmentContainer* fragment)
 749 {
 750     LayoutUnit startPosition = startOffsetForContent(fragment);
 751 
 752     // Add in our start margin.
 753     LayoutUnit oldPosition = startPosition + childMarginStart;
 754     LayoutUnit newPosition = oldPosition;
 755 
 756     LayoutUnit blockOffset = logicalTopForChild(child);
 757     if (fragment)
 758         blockOffset = std::max(blockOffset, blockOffset + (fragment-&gt;logicalTopForFragmentedFlowContent() - offsetFromLogicalTopOfFirstPage()));
 759 
 760     LayoutUnit startOff = startOffsetForLineInFragment(blockOffset, DoNotIndentText, fragment, logicalHeightForChild(child));
 761 
 762     if (style().textAlign() != TextAlignMode::WebKitCenter &amp;&amp; !child.style().marginStartUsing(&amp;style()).isAuto()) {
 763         if (childMarginStart &lt; 0)
 764             startOff += childMarginStart;
 765         newPosition = std::max(newPosition, startOff); // Let the float sit in the child&#39;s margin if it can fit.
 766     } else if (startOff != startPosition)
 767         newPosition = startOff + childMarginStart;
 768 
 769     return newPosition - oldPosition;
 770 }
 771 
 772 void RenderBlock::setLogicalLeftForChild(RenderBox&amp; child, LayoutUnit logicalLeft, ApplyLayoutDeltaMode applyDelta)
 773 {
 774     if (isHorizontalWritingMode()) {
 775         if (applyDelta == ApplyLayoutDelta)
 776             view().frameView().layoutContext().addLayoutDelta(LayoutSize(child.x() - logicalLeft, 0_lu));
 777         child.setX(logicalLeft);
 778     } else {
 779         if (applyDelta == ApplyLayoutDelta)
 780             view().frameView().layoutContext().addLayoutDelta(LayoutSize(0_lu, child.y() - logicalLeft));
 781         child.setY(logicalLeft);
 782     }
 783 }
 784 
 785 void RenderBlock::setLogicalTopForChild(RenderBox&amp; child, LayoutUnit logicalTop, ApplyLayoutDeltaMode applyDelta)
 786 {
 787     if (isHorizontalWritingMode()) {
 788         if (applyDelta == ApplyLayoutDelta)
 789             view().frameView().layoutContext().addLayoutDelta(LayoutSize(0_lu, child.y() - logicalTop));
 790         child.setY(logicalTop);
 791     } else {
 792         if (applyDelta == ApplyLayoutDelta)
 793             view().frameView().layoutContext().addLayoutDelta(LayoutSize(child.x() - logicalTop, 0_lu));
 794         child.setX(logicalTop);
 795     }
 796 }
 797 
 798 void RenderBlock::updateBlockChildDirtyBitsBeforeLayout(bool relayoutChildren, RenderBox&amp; child)
 799 {
 800     if (child.isOutOfFlowPositioned())
 801         return;
 802 
 803     // FIXME: Technically percentage height objects only need a relayout if their percentage isn&#39;t going to be turned into
 804     // an auto value. Add a method to determine this, so that we can avoid the relayout.
 805     if (relayoutChildren || (child.hasRelativeLogicalHeight() &amp;&amp; !isRenderView()))
 806         child.setChildNeedsLayout(MarkOnlyThis);
 807 
 808     // If relayoutChildren is set and the child has percentage padding or an embedded content box, we also need to invalidate the childs pref widths.
 809     if (relayoutChildren &amp;&amp; child.needsPreferredWidthsRecalculation())
 810         child.setPreferredLogicalWidthsDirty(true, MarkOnlyThis);
 811 }
 812 
 813 void RenderBlock::dirtyForLayoutFromPercentageHeightDescendants()
 814 {
 815     if (!percentHeightDescendantsMap)
 816         return;
 817 
 818     TrackedRendererListHashSet* descendants = percentHeightDescendantsMap-&gt;get(this);
 819     if (!descendants)
 820         return;
 821 
 822     for (auto it = descendants-&gt;begin(), end = descendants-&gt;end(); it != end; ++it) {
 823         auto* box = *it;
 824         // Let&#39;s not dirty the height perecentage descendant when it has an absolutely positioned containing block ancestor. We should be able to dirty such boxes through the regular invalidation logic.
 825         bool descendantNeedsLayout = true;
 826         for (auto* ancestor = box-&gt;containingBlock(); ancestor &amp;&amp; ancestor != this; ancestor = ancestor-&gt;containingBlock()) {
 827             if (ancestor-&gt;isOutOfFlowPositioned()) {
 828                 descendantNeedsLayout = false;
 829                 break;
 830             }
 831         }
 832         if (!descendantNeedsLayout)
 833             continue;
 834 
 835         while (box != this) {
 836             if (box-&gt;normalChildNeedsLayout())
 837                 break;
 838             box-&gt;setChildNeedsLayout(MarkOnlyThis);
 839 
 840             // If the width of an image is affected by the height of a child (e.g., an image with an aspect ratio),
 841             // then we have to dirty preferred widths, since even enclosing blocks can become dirty as a result.
 842             // (A horizontal flexbox that contains an inline image wrapped in an anonymous block for example.)
 843             if (box-&gt;hasAspectRatio())
 844                 box-&gt;setPreferredLogicalWidthsDirty(true);
 845             auto* containingBlock = box-&gt;containingBlock();
 846             // Mark the svg ancestor chain dirty as we walk to the containing block. containingBlock() just skips them. See webkit.org/b/183874.
 847             if (is&lt;SVGElement&gt;(box-&gt;element()) &amp;&amp; containingBlock != box-&gt;parent()) {
 848                 auto* ancestor = box-&gt;parent();
 849                 ASSERT(ancestor-&gt;isDescendantOf(containingBlock));
 850                 while (ancestor != containingBlock) {
 851                     ancestor-&gt;setChildNeedsLayout(MarkOnlyThis);
 852                     // This is the topmost SVG root, no need to go any further.
 853                     if (is&lt;SVGSVGElement&gt;(ancestor-&gt;element()) &amp;&amp; !downcast&lt;SVGSVGElement&gt;(*ancestor-&gt;element()).ownerSVGElement())
 854                         break;
 855                     ancestor = ancestor-&gt;parent();
 856                 }
 857             }
 858             box = containingBlock;
 859             ASSERT(box);
 860             if (!box)
 861                 break;
 862         }
 863     }
 864 }
 865 
 866 void RenderBlock::simplifiedNormalFlowLayout()
 867 {
 868     if (childrenInline()) {
 869         ListHashSet&lt;RootInlineBox*&gt; lineBoxes;
 870         for (InlineWalker walker(*this); !walker.atEnd(); walker.advance()) {
 871             RenderObject&amp; renderer = *walker.current();
 872             if (!renderer.isOutOfFlowPositioned() &amp;&amp; (renderer.isReplaced() || renderer.isFloating())) {
 873                 RenderBox&amp; box = downcast&lt;RenderBox&gt;(renderer);
 874                 box.layoutIfNeeded();
 875                 if (box.inlineBoxWrapper())
 876                     lineBoxes.add(&amp;box.inlineBoxWrapper()-&gt;root());
 877             } else if (is&lt;RenderText&gt;(renderer) || (is&lt;RenderInline&gt;(renderer) &amp;&amp; !walker.atEndOfInline()))
 878                 renderer.clearNeedsLayout();
 879         }
 880 
 881         // FIXME: Glyph overflow will get lost in this case, but not really a big deal.
 882         // FIXME: Find a way to invalidate the knownToHaveNoOverflow flag on the InlineBoxes.
 883         GlyphOverflowAndFallbackFontsMap textBoxDataMap;
 884         for (auto it = lineBoxes.begin(), end = lineBoxes.end(); it != end; ++it) {
 885             RootInlineBox* box = *it;
 886             box-&gt;computeOverflow(box-&gt;lineTop(), box-&gt;lineBottom(), textBoxDataMap);
 887         }
 888     } else {
 889         for (auto* box = firstChildBox(); box; box = box-&gt;nextSiblingBox()) {
 890             if (!box-&gt;isOutOfFlowPositioned())
 891                 box-&gt;layoutIfNeeded();
 892         }
 893     }
 894 }
 895 
 896 bool RenderBlock::canPerformSimplifiedLayout() const
 897 {
 898     return (posChildNeedsLayout() || needsSimplifiedNormalFlowLayout()) &amp;&amp; !normalChildNeedsLayout() &amp;&amp; !selfNeedsLayout();
 899 }
 900 
 901 bool RenderBlock::simplifiedLayout()
 902 {
 903     if (!canPerformSimplifiedLayout())
 904         return false;
 905 
 906     LayoutStateMaintainer statePusher(*this, locationOffset(), hasTransform() || hasReflection() || style().isFlippedBlocksWritingMode());
 907     if (needsPositionedMovementLayout() &amp;&amp; !tryLayoutDoingPositionedMovementOnly())
 908         return false;
 909 
 910     // Lay out positioned descendants or objects that just need to recompute overflow.
 911     if (needsSimplifiedNormalFlowLayout())
 912         simplifiedNormalFlowLayout();
 913 
 914     // Make sure a forced break is applied after the content if we are a flow thread in a simplified layout.
 915     // This ensures the size information is correctly computed for the last auto-height fragment receiving content.
 916     if (is&lt;RenderFragmentedFlow&gt;(*this))
 917         downcast&lt;RenderFragmentedFlow&gt;(*this).applyBreakAfterContent(clientLogicalBottom());
 918 
 919     // Lay out our positioned objects if our positioned child bit is set.
 920     // Also, if an absolute position element inside a relative positioned container moves, and the absolute element has a fixed position
 921     // child, neither the fixed element nor its container learn of the movement since posChildNeedsLayout() is only marked as far as the
 922     // relative positioned container. So if we can have fixed pos objects in our positioned objects list check if any of them
 923     // are statically positioned and thus need to move with their absolute ancestors.
 924     bool canContainFixedPosObjects = canContainFixedPositionObjects();
 925     if (posChildNeedsLayout() || canContainFixedPosObjects)
 926         layoutPositionedObjects(false, !posChildNeedsLayout() &amp;&amp; canContainFixedPosObjects);
 927 
 928     // Recompute our overflow information.
 929     // FIXME: We could do better here by computing a temporary overflow object from layoutPositionedObjects and only
 930     // updating our overflow if we either used to have overflow or if the new temporary object has overflow.
 931     // For now just always recompute overflow.  This is no worse performance-wise than the old code that called rightmostPosition and
 932     // lowestPosition on every relayout so it&#39;s not a regression.
 933     // computeOverflow expects the bottom edge before we clamp our height. Since this information isn&#39;t available during
 934     // simplifiedLayout, we cache the value in m_overflow.
 935     LayoutUnit oldClientAfterEdge = hasRenderOverflow() ? m_overflow-&gt;layoutClientAfterEdge() : clientLogicalBottom();
 936     computeOverflow(oldClientAfterEdge, true);
 937 
 938     updateLayerTransform();
 939 
 940     updateScrollInfoAfterLayout();
 941 
 942     clearNeedsLayout();
 943     return true;
 944 }
 945 
 946 void RenderBlock::markFixedPositionObjectForLayoutIfNeeded(RenderBox&amp; positionedChild)
 947 {
 948     if (positionedChild.style().position() != PositionType::Fixed)
 949         return;
 950 
 951     bool hasStaticBlockPosition = positionedChild.style().hasStaticBlockPosition(isHorizontalWritingMode());
 952     bool hasStaticInlinePosition = positionedChild.style().hasStaticInlinePosition(isHorizontalWritingMode());
 953     if (!hasStaticBlockPosition &amp;&amp; !hasStaticInlinePosition)
 954         return;
 955 
 956     auto* parent = positionedChild.parent();
 957     while (parent &amp;&amp; !is&lt;RenderView&gt;(*parent) &amp;&amp; parent-&gt;style().position() != PositionType::Absolute)
 958         parent = parent-&gt;parent();
 959     if (!parent || parent-&gt;style().position() != PositionType::Absolute)
 960         return;
 961 
 962     if (hasStaticInlinePosition) {
 963         LogicalExtentComputedValues computedValues;
 964         positionedChild.computeLogicalWidthInFragment(computedValues);
 965         LayoutUnit newLeft = computedValues.m_position;
 966         if (newLeft != positionedChild.logicalLeft())
 967             positionedChild.setChildNeedsLayout(MarkOnlyThis);
 968     } else if (hasStaticBlockPosition) {
 969         LayoutUnit oldTop = positionedChild.logicalTop();
 970         positionedChild.updateLogicalHeight();
 971         if (positionedChild.logicalTop() != oldTop)
 972             positionedChild.setChildNeedsLayout(MarkOnlyThis);
 973     }
 974 }
 975 
 976 LayoutUnit RenderBlock::marginIntrinsicLogicalWidthForChild(RenderBox&amp; child) const
 977 {
 978     // A margin has three types: fixed, percentage, and auto (variable).
 979     // Auto and percentage margins become 0 when computing min/max width.
 980     // Fixed margins can be added in as is.
 981     Length marginLeft = child.style().marginStartUsing(&amp;style());
 982     Length marginRight = child.style().marginEndUsing(&amp;style());
 983     LayoutUnit margin;
 984     if (marginLeft.isFixed())
 985         margin += marginLeft.value();
 986     if (marginRight.isFixed())
 987         margin += marginRight.value();
 988     return margin;
 989 }
 990 
 991 void RenderBlock::layoutPositionedObject(RenderBox&amp; r, bool relayoutChildren, bool fixedPositionObjectsOnly)
 992 {
 993     estimateFragmentRangeForBoxChild(r);
 994 
 995     // A fixed position element with an absolute positioned ancestor has no way of knowing if the latter has changed position. So
 996     // if this is a fixed position element, mark it for layout if it has an abspos ancestor and needs to move with that ancestor, i.e.
 997     // it has static position.
 998     markFixedPositionObjectForLayoutIfNeeded(r);
 999     if (fixedPositionObjectsOnly) {
1000         r.layoutIfNeeded();
1001         return;
1002     }
1003 
1004     // When a non-positioned block element moves, it may have positioned children that are implicitly positioned relative to the
1005     // non-positioned block.  Rather than trying to detect all of these movement cases, we just always lay out positioned
1006     // objects that are positioned implicitly like this.  Such objects are rare, and so in typical DHTML menu usage (where everything is
1007     // positioned explicitly) this should not incur a performance penalty.
1008     if (relayoutChildren || (r.style().hasStaticBlockPosition(isHorizontalWritingMode()) &amp;&amp; r.parent() != this))
1009         r.setChildNeedsLayout(MarkOnlyThis);
1010 
1011     // If relayoutChildren is set and the child has percentage padding or an embedded content box, we also need to invalidate the childs pref widths.
1012     if (relayoutChildren &amp;&amp; r.needsPreferredWidthsRecalculation())
1013         r.setPreferredLogicalWidthsDirty(true, MarkOnlyThis);
1014 
1015     r.markForPaginationRelayoutIfNeeded();
1016 
1017     // We don&#39;t have to do a full layout.  We just have to update our position. Try that first. If we have shrink-to-fit width
1018     // and we hit the available width constraint, the layoutIfNeeded() will catch it and do a full layout.
1019     if (r.needsPositionedMovementLayoutOnly() &amp;&amp; r.tryLayoutDoingPositionedMovementOnly())
1020         r.clearNeedsLayout();
1021 
1022     // If we are paginated or in a line grid, compute a vertical position for our object now.
1023     // If it&#39;s wrong we&#39;ll lay out again.
1024     LayoutUnit oldLogicalTop;
1025     bool needsBlockDirectionLocationSetBeforeLayout = r.needsLayout() &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;needsBlockDirectionLocationSetBeforeLayout();
1026     if (needsBlockDirectionLocationSetBeforeLayout) {
1027         if (isHorizontalWritingMode() == r.isHorizontalWritingMode())
1028             r.updateLogicalHeight();
1029         else
1030             r.updateLogicalWidth();
1031         oldLogicalTop = logicalTopForChild(r);
1032     }
1033 
1034     r.layoutIfNeeded();
1035 
1036     auto* parent = r.parent();
1037     bool layoutChanged = false;
1038     if (parent-&gt;isFlexibleBox() &amp;&amp; downcast&lt;RenderFlexibleBox&gt;(parent)-&gt;setStaticPositionForPositionedLayout(r)) {
1039         // The static position of an abspos child of a flexbox depends on its size
1040         // (for example, they can be centered). So we may have to reposition the
1041         // item after layout.
1042         // FIXME: We could probably avoid a layout here and just reposition?
1043         layoutChanged = true;
1044     }
1045 
1046     // Lay out again if our estimate was wrong.
1047     if (layoutChanged || (needsBlockDirectionLocationSetBeforeLayout &amp;&amp; logicalTopForChild(r) != oldLogicalTop)) {
1048         r.setChildNeedsLayout(MarkOnlyThis);
1049         r.layoutIfNeeded();
1050     }
1051 
1052     if (updateFragmentRangeForBoxChild(r)) {
1053         r.setNeedsLayout(MarkOnlyThis);
1054         r.layoutIfNeeded();
1055     }
1056 }
1057 
1058 void RenderBlock::layoutPositionedObjects(bool relayoutChildren, bool fixedPositionObjectsOnly)
1059 {
1060     TrackedRendererListHashSet* positionedDescendants = positionedObjects();
1061     if (!positionedDescendants)
1062         return;
1063 
1064     // Do not cache positionedDescendants-&gt;end() in a local variable, since |positionedDescendants| can be mutated
1065     // as it is walked. We always need to fetch the new end() value dynamically.
1066     for (auto it = positionedDescendants-&gt;begin(); it != positionedDescendants-&gt;end(); ++it)
1067         layoutPositionedObject(**it, relayoutChildren, fixedPositionObjectsOnly);
1068 }
1069 
1070 void RenderBlock::markPositionedObjectsForLayout()
1071 {
1072     TrackedRendererListHashSet* positionedDescendants = positionedObjects();
1073     if (!positionedDescendants)
1074         return;
1075 
1076     for (auto it = positionedDescendants-&gt;begin(), end = positionedDescendants-&gt;end(); it != end; ++it) {
1077         RenderBox* r = *it;
1078         r-&gt;setChildNeedsLayout();
1079     }
1080 }
1081 
1082 void RenderBlock::markForPaginationRelayoutIfNeeded()
1083 {
1084     auto* layoutState = view().frameView().layoutContext().layoutState();
1085     if (needsLayout() || !layoutState-&gt;isPaginated())
1086         return;
1087 
1088     if (layoutState-&gt;pageLogicalHeightChanged() || (layoutState-&gt;pageLogicalHeight() &amp;&amp; layoutState-&gt;pageLogicalOffset(this, logicalTop()) != pageLogicalOffset()))
1089         setChildNeedsLayout(MarkOnlyThis);
1090 }
1091 
1092 void RenderBlock::paint(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1093 {
1094     LayoutPoint adjustedPaintOffset = paintOffset + location();
1095     PaintPhase phase = paintInfo.phase;
1096 
1097     // Check if we need to do anything at all.
1098     // FIXME: Could eliminate the isDocumentElementRenderer() check if we fix background painting so that the RenderView
1099     // paints the root&#39;s background.
1100     if (!isDocumentElementRenderer()) {
1101         LayoutRect overflowBox = overflowRectForPaintRejection();
1102         flipForWritingMode(overflowBox);
1103         overflowBox.moveBy(adjustedPaintOffset);
1104         if (!overflowBox.intersects(paintInfo.rect)
1105 #if PLATFORM(IOS_FAMILY)
1106             // FIXME: This may be applicable to non-iOS ports.
1107             &amp;&amp; (!hasLayer() || !layer()-&gt;isComposited())
1108 #endif
1109         )
1110             return;
1111     }
1112 
1113     bool pushedClip = pushContentsClip(paintInfo, adjustedPaintOffset);
1114     paintObject(paintInfo, adjustedPaintOffset);
1115     if (pushedClip)
1116         popContentsClip(paintInfo, phase, adjustedPaintOffset);
1117 
1118     // Our scrollbar widgets paint exactly when we tell them to, so that they work properly with
1119     // z-index. We paint after we painted the background/border, so that the scrollbars will
1120     // sit above the background/border.
1121     if ((phase == PaintPhase::BlockBackground || phase == PaintPhase::ChildBlockBackground) &amp;&amp; hasOverflowClip() &amp;&amp; layer()
1122         &amp;&amp; style().visibility() == Visibility::Visible &amp;&amp; paintInfo.shouldPaintWithinRoot(*this) &amp;&amp; !paintInfo.paintRootBackgroundOnly())
1123         layer()-&gt;paintOverflowControls(paintInfo.context(), roundedIntPoint(adjustedPaintOffset), snappedIntRect(paintInfo.rect));
1124 }
1125 
1126 void RenderBlock::paintContents(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1127 {
1128     // Style is non-final if the element has a pending stylesheet before it. We end up with renderers with such styles if a script
1129     // forces renderer construction by querying something layout dependent.
1130     // Avoid FOUC by not painting. Switching to final style triggers repaint.
1131     if (style().isNotFinal())
1132         return;
1133 
1134     if (childrenInline())
1135         paintInlineChildren(paintInfo, paintOffset);
1136     else {
1137         PaintPhase newPhase = (paintInfo.phase == PaintPhase::ChildOutlines) ? PaintPhase::Outline : paintInfo.phase;
1138         newPhase = (newPhase == PaintPhase::ChildBlockBackgrounds) ? PaintPhase::ChildBlockBackground : newPhase;
1139 
1140         // We don&#39;t paint our own background, but we do let the kids paint their backgrounds.
1141         PaintInfo paintInfoForChild(paintInfo);
1142         paintInfoForChild.phase = newPhase;
1143         paintInfoForChild.updateSubtreePaintRootForChildren(this);
1144 
1145         // FIXME: Paint-time pagination is obsolete and is now only used by embedded WebViews inside AppKit
1146         // NSViews. Do not add any more code for this.
1147         bool usePrintRect = !view().printRect().isEmpty();
1148         paintChildren(paintInfo, paintOffset, paintInfoForChild, usePrintRect);
1149     }
1150 }
1151 
1152 void RenderBlock::paintChildren(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, PaintInfo&amp; paintInfoForChild, bool usePrintRect)
1153 {
1154     for (auto* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
1155         if (!paintChild(*child, paintInfo, paintOffset, paintInfoForChild, usePrintRect))
1156             return;
1157     }
1158 }
1159 
1160 bool RenderBlock::paintChild(RenderBox&amp; child, PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, PaintInfo&amp; paintInfoForChild, bool usePrintRect, PaintBlockType paintType)
1161 {
1162     if (child.isExcludedAndPlacedInBorder())
1163         return true;
1164 
1165     // Check for page-break-before: always, and if it&#39;s set, break and bail.
1166     bool checkBeforeAlways = !childrenInline() &amp;&amp; (usePrintRect &amp;&amp; alwaysPageBreak(child.style().breakBefore()));
1167     LayoutUnit absoluteChildY = paintOffset.y() + child.y();
1168     if (checkBeforeAlways
1169         &amp;&amp; absoluteChildY &gt; paintInfo.rect.y()
1170         &amp;&amp; absoluteChildY &lt; paintInfo.rect.maxY()) {
1171         view().setBestTruncatedAt(absoluteChildY, this, true);
1172         return false;
1173     }
1174 
1175     if (!child.isFloating() &amp;&amp; child.isReplaced() &amp;&amp; usePrintRect &amp;&amp; child.height() &lt;= view().printRect().height()) {
1176         // Paginate block-level replaced elements.
1177         if (absoluteChildY + child.height() &gt; view().printRect().maxY()) {
1178             if (absoluteChildY &lt; view().truncatedAt())
1179                 view().setBestTruncatedAt(absoluteChildY, &amp;child);
1180             // If we were able to truncate, don&#39;t paint.
1181             if (absoluteChildY &gt;= view().truncatedAt())
1182                 return false;
1183         }
1184     }
1185 
1186     LayoutPoint childPoint = flipForWritingModeForChild(&amp;child, paintOffset);
1187     if (!child.hasSelfPaintingLayer() &amp;&amp; !child.isFloating()) {
1188         if (paintType == PaintAsInlineBlock)
1189             child.paintAsInlineBlock(paintInfoForChild, childPoint);
1190         else
1191             child.paint(paintInfoForChild, childPoint);
1192     }
1193 
1194     // Check for page-break-after: always, and if it&#39;s set, break and bail.
1195     bool checkAfterAlways = !childrenInline() &amp;&amp; (usePrintRect &amp;&amp; alwaysPageBreak(child.style().breakAfter()));
1196     if (checkAfterAlways
1197         &amp;&amp; (absoluteChildY + child.height()) &gt; paintInfo.rect.y()
1198         &amp;&amp; (absoluteChildY + child.height()) &lt; paintInfo.rect.maxY()) {
1199         view().setBestTruncatedAt(absoluteChildY + child.height() + std::max&lt;LayoutUnit&gt;(0, child.collapsedMarginAfter()), this, true);
1200         return false;
1201     }
1202 
1203     return true;
1204 }
1205 
1206 void RenderBlock::paintCaret(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, CaretType type)
1207 {
1208     // Paint the caret if the FrameSelection says so or if caret browsing is enabled
1209     RenderBlock* caretPainter;
1210     bool isContentEditable;
1211     if (type == CursorCaret) {
1212         caretPainter = frame().selection().caretRendererWithoutUpdatingLayout();
1213         isContentEditable = frame().selection().selection().hasEditableStyle();
1214     } else {
1215         caretPainter = page().dragCaretController().caretRenderer();
1216         isContentEditable = page().dragCaretController().isContentEditable();
1217     }
1218 
1219     if (caretPainter == this &amp;&amp; (isContentEditable || settings().caretBrowsingEnabled())) {
1220         if (type == CursorCaret)
1221             frame().selection().paintCaret(paintInfo.context(), paintOffset, paintInfo.rect);
1222         else
1223             page().dragCaretController().paintDragCaret(&amp;frame(), paintInfo.context(), paintOffset, paintInfo.rect);
1224     }
1225 }
1226 
1227 void RenderBlock::paintObject(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1228 {
1229     PaintPhase paintPhase = paintInfo.phase;
1230 
1231     // 1. paint background, borders etc
1232     if ((paintPhase == PaintPhase::BlockBackground || paintPhase == PaintPhase::ChildBlockBackground) &amp;&amp; style().visibility() == Visibility::Visible) {
1233         if (hasVisibleBoxDecorations())
1234             paintBoxDecorations(paintInfo, paintOffset);
1235     }
1236 
1237     // Paint legends just above the border before we scroll or clip.
1238     if (paintPhase == PaintPhase::BlockBackground || paintPhase == PaintPhase::ChildBlockBackground || paintPhase == PaintPhase::Selection)
1239         paintExcludedChildrenInBorder(paintInfo, paintOffset);
1240 
1241     if (paintPhase == PaintPhase::Mask &amp;&amp; style().visibility() == Visibility::Visible) {
1242         paintMask(paintInfo, paintOffset);
1243         return;
1244     }
1245 
1246     if (paintPhase == PaintPhase::ClippingMask &amp;&amp; style().visibility() == Visibility::Visible) {
1247         paintClippingMask(paintInfo, paintOffset);
1248         return;
1249     }
1250 
1251     // If just painting the root background, then return.
1252     if (paintInfo.paintRootBackgroundOnly())
1253         return;
1254 
1255     if (paintPhase == PaintPhase::EventRegion) {
1256         auto borderRect = LayoutRect(paintOffset, size());
1257 
1258         if (visibleToHitTesting()) {
1259             auto borderRegion = approximateAsRegion(style().getRoundedBorderFor(borderRect));
1260             paintInfo.eventRegionContext-&gt;unite(borderRegion, style());
1261         }
1262 
1263         // No need to check descendants if we don&#39;t have overflow and the area is already covered.
1264         bool needsTraverseDescendants = hasVisualOverflow() || !paintInfo.eventRegionContext-&gt;contains(enclosingIntRect(borderRect));
1265 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(POINTER_EVENTS)
1266         needsTraverseDescendants = needsTraverseDescendants || document().mayHaveElementsWithNonAutoTouchAction();
1267 #endif
1268         if (!needsTraverseDescendants)
1269             return;
1270     }
1271 
1272     // Adjust our painting position if we&#39;re inside a scrolled layer (e.g., an overflow:auto div).
1273     LayoutPoint scrolledOffset = paintOffset;
1274     scrolledOffset.moveBy(-scrollPosition());
1275 
1276     // Column rules need to account for scrolling and clipping.
1277     // FIXME: Clipping of column rules does not work. We will need a separate paint phase for column rules I suspect in order to get
1278     // clipping correct (since it has to paint as background but is still considered &quot;contents&quot;).
1279     if ((paintPhase == PaintPhase::BlockBackground || paintPhase == PaintPhase::ChildBlockBackground) &amp;&amp; style().visibility() == Visibility::Visible)
1280         paintColumnRules(paintInfo, scrolledOffset);
1281 
1282     // Done with backgrounds, borders and column rules.
1283     if (paintPhase == PaintPhase::BlockBackground)
1284         return;
1285 
1286     // 2. paint contents
1287     if (paintPhase != PaintPhase::SelfOutline)
1288         paintContents(paintInfo, scrolledOffset);
1289 
1290     // 3. paint selection
1291     // FIXME: Make this work with multi column layouts.  For now don&#39;t fill gaps.
1292     bool isPrinting = document().printing();
1293     if (!isPrinting)
1294         paintSelection(paintInfo, scrolledOffset); // Fill in gaps in selection on lines and between blocks.
1295 
1296     // 4. paint floats.
1297     if (paintPhase == PaintPhase::Float || paintPhase == PaintPhase::Selection || paintPhase == PaintPhase::TextClip)
1298         paintFloats(paintInfo, scrolledOffset, paintPhase == PaintPhase::Selection || paintPhase == PaintPhase::TextClip);
1299 
1300     // 5. paint outline.
1301     if ((paintPhase == PaintPhase::Outline || paintPhase == PaintPhase::SelfOutline) &amp;&amp; hasOutline() &amp;&amp; style().visibility() == Visibility::Visible)
1302         paintOutline(paintInfo, LayoutRect(paintOffset, size()));
1303 
1304     // 6. paint continuation outlines.
1305     if ((paintPhase == PaintPhase::Outline || paintPhase == PaintPhase::ChildOutlines)) {
1306         RenderInline* inlineCont = inlineContinuation();
1307         if (inlineCont &amp;&amp; inlineCont-&gt;hasOutline() &amp;&amp; inlineCont-&gt;style().visibility() == Visibility::Visible) {
1308             RenderInline* inlineRenderer = downcast&lt;RenderInline&gt;(inlineCont-&gt;element()-&gt;renderer());
1309             RenderBlock* containingBlock = this-&gt;containingBlock();
1310 
1311             bool inlineEnclosedInSelfPaintingLayer = false;
1312             for (RenderBoxModelObject* box = inlineRenderer; box != containingBlock; box = &amp;box-&gt;parent()-&gt;enclosingBoxModelObject()) {
1313                 if (box-&gt;hasSelfPaintingLayer()) {
1314                     inlineEnclosedInSelfPaintingLayer = true;
1315                     break;
1316                 }
1317             }
1318 
1319             // Do not add continuations for outline painting by our containing block if we are a relative positioned
1320             // anonymous block (i.e. have our own layer), paint them straightaway instead. This is because a block depends on renderers in its continuation table being
1321             // in the same layer.
1322             if (!inlineEnclosedInSelfPaintingLayer &amp;&amp; !hasLayer())
1323                 containingBlock-&gt;addContinuationWithOutline(inlineRenderer);
1324             else if (!inlineRenderer-&gt;firstLineBox() || (!inlineEnclosedInSelfPaintingLayer &amp;&amp; hasLayer()))
1325                 inlineRenderer-&gt;paintOutline(paintInfo, paintOffset - locationOffset() + inlineRenderer-&gt;containingBlock()-&gt;location());
1326         }
1327         paintContinuationOutlines(paintInfo, paintOffset);
1328     }
1329 
1330     // 7. paint caret.
1331     // If the caret&#39;s node&#39;s render object&#39;s containing block is this block, and the paint action is PaintPhase::Foreground,
1332     // then paint the caret.
1333     if (paintPhase == PaintPhase::Foreground) {
1334         paintCaret(paintInfo, paintOffset, CursorCaret);
1335         paintCaret(paintInfo, paintOffset, DragCaret);
1336     }
1337 }
1338 
1339 static ContinuationOutlineTableMap* continuationOutlineTable()
1340 {
1341     static NeverDestroyed&lt;ContinuationOutlineTableMap&gt; table;
1342     return &amp;table.get();
1343 }
1344 
1345 void RenderBlock::addContinuationWithOutline(RenderInline* flow)
1346 {
1347     // We can&#39;t make this work if the inline is in a layer.  We&#39;ll just rely on the broken
1348     // way of painting.
1349     ASSERT(!flow-&gt;layer() &amp;&amp; !flow-&gt;isContinuation());
1350 
1351     ContinuationOutlineTableMap* table = continuationOutlineTable();
1352     ListHashSet&lt;RenderInline*&gt;* continuations = table-&gt;get(this);
1353     if (!continuations) {
1354         continuations = new ListHashSet&lt;RenderInline*&gt;;
1355         table-&gt;set(this, std::unique_ptr&lt;ListHashSet&lt;RenderInline*&gt;&gt;(continuations));
1356     }
1357 
1358     continuations-&gt;add(flow);
1359 }
1360 
1361 bool RenderBlock::paintsContinuationOutline(RenderInline* flow)
1362 {
1363     ContinuationOutlineTableMap* table = continuationOutlineTable();
1364     if (table-&gt;isEmpty())
1365         return false;
1366 
1367     ListHashSet&lt;RenderInline*&gt;* continuations = table-&gt;get(this);
1368     if (!continuations)
1369         return false;
1370 
1371     return continuations-&gt;contains(flow);
1372 }
1373 
1374 void RenderBlock::paintContinuationOutlines(PaintInfo&amp; info, const LayoutPoint&amp; paintOffset)
1375 {
1376     ContinuationOutlineTableMap* table = continuationOutlineTable();
1377     if (table-&gt;isEmpty())
1378         return;
1379 
1380     std::unique_ptr&lt;ListHashSet&lt;RenderInline*&gt;&gt; continuations = table-&gt;take(this);
1381     if (!continuations)
1382         return;
1383 
1384     LayoutPoint accumulatedPaintOffset = paintOffset;
1385     // Paint each continuation outline.
1386     ListHashSet&lt;RenderInline*&gt;::iterator end = continuations-&gt;end();
1387     for (ListHashSet&lt;RenderInline*&gt;::iterator it = continuations-&gt;begin(); it != end; ++it) {
1388         // Need to add in the coordinates of the intervening blocks.
1389         RenderInline* flow = *it;
1390         RenderBlock* block = flow-&gt;containingBlock();
1391         for ( ; block &amp;&amp; block != this; block = block-&gt;containingBlock())
1392             accumulatedPaintOffset.moveBy(block-&gt;location());
1393         ASSERT(block);
1394         flow-&gt;paintOutline(info, accumulatedPaintOffset);
1395     }
1396 }
1397 
1398 bool RenderBlock::shouldPaintSelectionGaps() const
1399 {
1400     if (settings().selectionPaintingWithoutSelectionGapsEnabled())
1401         return false;
1402 
1403     return selectionState() != SelectionNone &amp;&amp; style().visibility() == Visibility::Visible &amp;&amp; isSelectionRoot();
1404 }
1405 
1406 bool RenderBlock::isSelectionRoot() const
1407 {
1408     if (isPseudoElement())
1409         return false;
1410     ASSERT(element() || isAnonymous());
1411 
1412     // FIXME: Eventually tables should have to learn how to fill gaps between cells, at least in simple non-spanning cases.
1413     if (isTable())
1414         return false;
1415 
1416     if (isBody() || isDocumentElementRenderer() || hasOverflowClip()
1417         || isPositioned() || isFloating()
1418         || isTableCell() || isInlineBlockOrInlineTable()
1419         || hasTransform() || hasReflection() || hasMask() || isWritingModeRoot()
1420         || isRenderFragmentedFlow() || style().columnSpan() == ColumnSpan::All)
1421         return true;
1422 
1423     if (view().selection().start()) {
1424         Node* startElement = view().selection().start()-&gt;node();
1425         if (startElement &amp;&amp; startElement-&gt;rootEditableElement() == element())
1426             return true;
1427     }
1428 
1429     return false;
1430 }
1431 
1432 GapRects RenderBlock::selectionGapRectsForRepaint(const RenderLayerModelObject* repaintContainer)
1433 {
1434     ASSERT(!needsLayout());
1435 
1436     if (!shouldPaintSelectionGaps())
1437         return GapRects();
1438 
1439     FloatPoint containerPoint = localToContainerPoint(FloatPoint(), repaintContainer, UseTransforms);
1440     LayoutPoint offsetFromRepaintContainer(containerPoint - toFloatSize(scrollPosition()));
1441 
1442     LogicalSelectionOffsetCaches cache(*this);
1443     LayoutUnit lastTop;
1444     LayoutUnit lastLeft = logicalLeftSelectionOffset(*this, lastTop, cache);
1445     LayoutUnit lastRight = logicalRightSelectionOffset(*this, lastTop, cache);
1446 
1447     return selectionGaps(*this, offsetFromRepaintContainer, IntSize(), lastTop, lastLeft, lastRight, cache);
1448 }
1449 
1450 void RenderBlock::paintSelection(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1451 {
1452 #if ENABLE(TEXT_SELECTION)
1453     if (shouldPaintSelectionGaps() &amp;&amp; paintInfo.phase == PaintPhase::Foreground) {
1454         LogicalSelectionOffsetCaches cache(*this);
1455         LayoutUnit lastTop;
1456         LayoutUnit lastLeft = logicalLeftSelectionOffset(*this, lastTop, cache);
1457         LayoutUnit lastRight = logicalRightSelectionOffset(*this, lastTop, cache);
1458         GraphicsContextStateSaver stateSaver(paintInfo.context());
1459 
1460         LayoutRect gapRectsBounds = selectionGaps(*this, paintOffset, LayoutSize(), lastTop, lastLeft, lastRight, cache, &amp;paintInfo);
1461         if (!gapRectsBounds.isEmpty()) {
1462             if (RenderLayer* layer = enclosingLayer()) {
1463                 gapRectsBounds.moveBy(-paintOffset);
1464                 if (!hasLayer()) {
1465                     LayoutRect localBounds(gapRectsBounds);
1466                     flipForWritingMode(localBounds);
1467                     gapRectsBounds = localToContainerQuad(FloatRect(localBounds), &amp;layer-&gt;renderer()).enclosingBoundingBox();
1468                     if (layer-&gt;renderer().isBox())
1469                         gapRectsBounds.moveBy(layer-&gt;renderBox()-&gt;scrollPosition());
1470                 }
1471                 layer-&gt;addBlockSelectionGapsBounds(gapRectsBounds);
1472             }
1473         }
1474     }
1475 #else
1476     UNUSED_PARAM(paintInfo);
1477     UNUSED_PARAM(paintOffset);
1478 #endif
1479 }
1480 
1481 static void clipOutPositionedObjects(const PaintInfo* paintInfo, const LayoutPoint&amp; offset, TrackedRendererListHashSet* positionedObjects)
1482 {
1483     if (!positionedObjects)
1484         return;
1485 
1486     TrackedRendererListHashSet::const_iterator end = positionedObjects-&gt;end();
1487     for (TrackedRendererListHashSet::const_iterator it = positionedObjects-&gt;begin(); it != end; ++it) {
1488         RenderBox* r = *it;
1489         paintInfo-&gt;context().clipOut(IntRect(offset.x() + r-&gt;x(), offset.y() + r-&gt;y(), r-&gt;width(), r-&gt;height()));
1490     }
1491 }
1492 
1493 LayoutUnit blockDirectionOffset(RenderBlock&amp; rootBlock, const LayoutSize&amp; offsetFromRootBlock)
1494 {
1495     return rootBlock.isHorizontalWritingMode() ? offsetFromRootBlock.height() : offsetFromRootBlock.width();
1496 }
1497 
1498 LayoutUnit inlineDirectionOffset(RenderBlock&amp; rootBlock, const LayoutSize&amp; offsetFromRootBlock)
1499 {
1500     return rootBlock.isHorizontalWritingMode() ? offsetFromRootBlock.width() : offsetFromRootBlock.height();
1501 }
1502 
1503 LayoutRect RenderBlock::logicalRectToPhysicalRect(const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutRect&amp; logicalRect)
1504 {
1505     LayoutRect result;
1506     if (isHorizontalWritingMode())
1507         result = logicalRect;
1508     else
1509         result = LayoutRect(logicalRect.y(), logicalRect.x(), logicalRect.height(), logicalRect.width());
1510     flipForWritingMode(result);
1511     result.moveBy(rootBlockPhysicalPosition);
1512     return result;
1513 }
1514 
1515 GapRects RenderBlock::selectionGaps(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
1516     LayoutUnit&amp; lastLogicalTop, LayoutUnit&amp; lastLogicalLeft, LayoutUnit&amp; lastLogicalRight, const LogicalSelectionOffsetCaches&amp; cache, const PaintInfo* paintInfo)
1517 {
1518     // IMPORTANT: Callers of this method that intend for painting to happen need to do a save/restore.
1519     // Clip out floating and positioned objects when painting selection gaps.
1520     if (paintInfo) {
1521         // Note that we don&#39;t clip out overflow for positioned objects.  We just stick to the border box.
1522         LayoutRect flippedBlockRect(offsetFromRootBlock.width(), offsetFromRootBlock.height(), width(), height());
1523         rootBlock.flipForWritingMode(flippedBlockRect);
1524         flippedBlockRect.moveBy(rootBlockPhysicalPosition);
1525         clipOutPositionedObjects(paintInfo, flippedBlockRect.location(), positionedObjects());
1526         if (isBody() || isDocumentElementRenderer()) { // The &lt;body&gt; must make sure to examine its containingBlock&#39;s positioned objects.
1527             for (RenderBlock* cb = containingBlock(); cb &amp;&amp; !is&lt;RenderView&gt;(*cb); cb = cb-&gt;containingBlock())
1528                 clipOutPositionedObjects(paintInfo, LayoutPoint(cb-&gt;x(), cb-&gt;y()), cb-&gt;positionedObjects()); // FIXME: Not right for flipped writing modes.
1529         }
1530         clipOutFloatingObjects(rootBlock, paintInfo, rootBlockPhysicalPosition, offsetFromRootBlock);
1531     }
1532 
1533     // FIXME: overflow: auto/scroll fragments need more math here, since painting in the border box is different from painting in the padding box (one is scrolled, the other is
1534     // fixed).
1535     GapRects result;
1536     if (!isRenderBlockFlow()) // FIXME: Make multi-column selection gap filling work someday.
1537         return result;
1538 
1539     if (hasTransform() || style().columnSpan() == ColumnSpan::All || isInFlowRenderFragmentedFlow()) {
1540         // FIXME: We should learn how to gap fill multiple columns and transforms eventually.
1541         lastLogicalTop = blockDirectionOffset(rootBlock, offsetFromRootBlock) + logicalHeight();
1542         lastLogicalLeft = logicalLeftSelectionOffset(rootBlock, logicalHeight(), cache);
1543         lastLogicalRight = logicalRightSelectionOffset(rootBlock, logicalHeight(), cache);
1544         return result;
1545     }
1546 
1547     if (childrenInline())
1548         result = inlineSelectionGaps(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, lastLogicalTop, lastLogicalLeft, lastLogicalRight, cache, paintInfo);
1549     else
1550         result = blockSelectionGaps(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, lastLogicalTop, lastLogicalLeft, lastLogicalRight, cache, paintInfo);
1551 
1552     // Fill the vertical gap all the way to the bottom of our block if the selection extends past our block.
1553     if (&amp;rootBlock == this &amp;&amp; (selectionState() != SelectionBoth &amp;&amp; selectionState() != SelectionEnd) &amp;&amp; !isRubyBase() &amp;&amp; !isRubyText()) {
1554         result.uniteCenter(blockSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock,
1555             lastLogicalTop, lastLogicalLeft, lastLogicalRight, logicalHeight(), cache, paintInfo));
1556     }
1557 
1558     return result;
1559 }
1560 
1561 GapRects RenderBlock::inlineSelectionGaps(RenderBlock&amp;, const LayoutPoint&amp;, const LayoutSize&amp;, LayoutUnit&amp;, LayoutUnit&amp;, LayoutUnit&amp;, const LogicalSelectionOffsetCaches&amp;, const PaintInfo*)
1562 {
1563     ASSERT_NOT_REACHED();
1564     return GapRects();
1565 }
1566 
1567 GapRects RenderBlock::blockSelectionGaps(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
1568     LayoutUnit&amp; lastLogicalTop, LayoutUnit&amp; lastLogicalLeft, LayoutUnit&amp; lastLogicalRight, const LogicalSelectionOffsetCaches&amp; cache, const PaintInfo* paintInfo)
1569 {
1570     GapRects result;
1571 
1572     // Jump right to the first block child that contains some selected objects.
1573     RenderBox* curr;
1574     for (curr = firstChildBox(); curr &amp;&amp; curr-&gt;selectionState() == SelectionNone; curr = curr-&gt;nextSiblingBox()) { }
1575 
1576     if (!curr)
1577         return result;
1578 
1579     LogicalSelectionOffsetCaches childCache(*this, cache);
1580 
1581     for (bool sawSelectionEnd = false; curr &amp;&amp; !sawSelectionEnd; curr = curr-&gt;nextSiblingBox()) {
1582         SelectionState childState = curr-&gt;selectionState();
1583         if (childState == SelectionBoth || childState == SelectionEnd)
1584             sawSelectionEnd = true;
1585 
1586         if (curr-&gt;isFloatingOrOutOfFlowPositioned())
1587             continue; // We must be a normal flow object in order to even be considered.
1588 
1589         if (curr-&gt;isInFlowPositioned() &amp;&amp; curr-&gt;hasLayer()) {
1590             // If the relposition offset is anything other than 0, then treat this just like an absolute positioned element.
1591             // Just disregard it completely.
1592             LayoutSize relOffset = curr-&gt;layer()-&gt;offsetForInFlowPosition();
1593             if (relOffset.width() || relOffset.height())
1594                 continue;
1595         }
1596 
1597         bool paintsOwnSelection = curr-&gt;shouldPaintSelectionGaps() || curr-&gt;isTable(); // FIXME: Eventually we won&#39;t special-case table like this.
1598         bool fillBlockGaps = (paintsOwnSelection || (curr-&gt;canBeSelectionLeaf() &amp;&amp; childState != SelectionNone)) &amp;&amp; !isRubyBase() &amp;&amp; !isRubyText();
1599         if (fillBlockGaps) {
1600             // We need to fill the vertical gap above this object.
1601             if (childState == SelectionEnd || childState == SelectionInside) {
1602                 // Fill the gap above the object.
1603                 result.uniteCenter(blockSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock,
1604                     lastLogicalTop, lastLogicalLeft, lastLogicalRight, curr-&gt;logicalTop(), cache, paintInfo));
1605             }
1606 
1607             // Only fill side gaps for objects that paint their own selection if we know for sure the selection is going to extend all the way *past*
1608             // our object.  We know this if the selection did not end inside our object.
1609             if (paintsOwnSelection &amp;&amp; (childState == SelectionStart || sawSelectionEnd))
1610                 childState = SelectionNone;
1611 
1612             // Fill side gaps on this object based off its state.
1613             bool leftGap, rightGap;
1614             getSelectionGapInfo(childState, leftGap, rightGap);
1615 
1616             if (leftGap)
1617                 result.uniteLeft(logicalLeftSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, this, curr-&gt;logicalLeft(), curr-&gt;logicalTop(), curr-&gt;logicalHeight(), cache, paintInfo));
1618             if (rightGap)
1619                 result.uniteRight(logicalRightSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, this, curr-&gt;logicalRight(), curr-&gt;logicalTop(), curr-&gt;logicalHeight(), cache, paintInfo));
1620 
1621             // Update lastLogicalTop to be just underneath the object.  lastLogicalLeft and lastLogicalRight extend as far as
1622             // they can without bumping into floating or positioned objects.  Ideally they will go right up
1623             // to the border of the root selection block.
1624             lastLogicalTop = blockDirectionOffset(rootBlock, offsetFromRootBlock) + curr-&gt;logicalBottom();
1625             lastLogicalLeft = logicalLeftSelectionOffset(rootBlock, curr-&gt;logicalBottom(), cache);
1626             lastLogicalRight = logicalRightSelectionOffset(rootBlock, curr-&gt;logicalBottom(), cache);
1627         } else if (childState != SelectionNone &amp;&amp; is&lt;RenderBlock&gt;(*curr)) {
1628             // We must be a block that has some selected object inside it, so recur.
1629             result.unite(downcast&lt;RenderBlock&gt;(*curr).selectionGaps(rootBlock, rootBlockPhysicalPosition, LayoutSize(offsetFromRootBlock.width() + curr-&gt;x(), offsetFromRootBlock.height() + curr-&gt;y()),
1630                 lastLogicalTop, lastLogicalLeft, lastLogicalRight, childCache, paintInfo));
1631         }
1632     }
1633     return result;
1634 }
1635 
1636 LayoutRect RenderBlock::blockSelectionGap(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
1637     LayoutUnit lastLogicalTop, LayoutUnit lastLogicalLeft, LayoutUnit lastLogicalRight, LayoutUnit logicalBottom, const LogicalSelectionOffsetCaches&amp; cache, const PaintInfo* paintInfo)
1638 {
1639     LayoutUnit logicalTop = lastLogicalTop;
1640     LayoutUnit logicalHeight = blockDirectionOffset(rootBlock, offsetFromRootBlock) + logicalBottom - logicalTop;
1641     if (logicalHeight &lt;= 0)
1642         return LayoutRect();
1643 
1644     // Get the selection offsets for the bottom of the gap
1645     LayoutUnit logicalLeft = std::max(lastLogicalLeft, logicalLeftSelectionOffset(rootBlock, logicalBottom, cache));
1646     LayoutUnit logicalRight = std::min(lastLogicalRight, logicalRightSelectionOffset(rootBlock, logicalBottom, cache));
1647     LayoutUnit logicalWidth = logicalRight - logicalLeft;
1648     if (logicalWidth &lt;= 0)
1649         return LayoutRect();
1650 
1651     LayoutRect gapRect = rootBlock.logicalRectToPhysicalRect(rootBlockPhysicalPosition, LayoutRect(logicalLeft, logicalTop, logicalWidth, logicalHeight));
1652     if (paintInfo)
1653         paintInfo-&gt;context().fillRect(snapRectToDevicePixels(gapRect, document().deviceScaleFactor()), selectionBackgroundColor());
1654     return gapRect;
1655 }
1656 
1657 LayoutRect RenderBlock::logicalLeftSelectionGap(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
1658     RenderBoxModelObject* selObj, LayoutUnit logicalLeft, LayoutUnit logicalTop, LayoutUnit logicalHeight, const LogicalSelectionOffsetCaches&amp; cache, const PaintInfo* paintInfo)
1659 {
1660     LayoutUnit rootBlockLogicalTop = blockDirectionOffset(rootBlock, offsetFromRootBlock) + logicalTop;
1661     LayoutUnit rootBlockLogicalLeft = std::max(logicalLeftSelectionOffset(rootBlock, logicalTop, cache), logicalLeftSelectionOffset(rootBlock, logicalTop + logicalHeight, cache));
1662     LayoutUnit rootBlockLogicalRight = std::min(inlineDirectionOffset(rootBlock, offsetFromRootBlock) + logicalLeft,
1663         std::min(logicalRightSelectionOffset(rootBlock, logicalTop, cache), logicalRightSelectionOffset(rootBlock, logicalTop + logicalHeight, cache)));
1664     LayoutUnit rootBlockLogicalWidth = rootBlockLogicalRight - rootBlockLogicalLeft;
1665     if (rootBlockLogicalWidth &lt;= 0)
1666         return LayoutRect();
1667 
1668     LayoutRect gapRect = rootBlock.logicalRectToPhysicalRect(rootBlockPhysicalPosition, LayoutRect(rootBlockLogicalLeft, rootBlockLogicalTop, rootBlockLogicalWidth, logicalHeight));
1669     if (paintInfo)
1670         paintInfo-&gt;context().fillRect(snapRectToDevicePixels(gapRect, document().deviceScaleFactor()), selObj-&gt;selectionBackgroundColor());
1671     return gapRect;
1672 }
1673 
1674 LayoutRect RenderBlock::logicalRightSelectionGap(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
1675     RenderBoxModelObject* selObj, LayoutUnit logicalRight, LayoutUnit logicalTop, LayoutUnit logicalHeight, const LogicalSelectionOffsetCaches&amp; cache, const PaintInfo* paintInfo)
1676 {
1677     LayoutUnit rootBlockLogicalTop = blockDirectionOffset(rootBlock, offsetFromRootBlock) + logicalTop;
1678     LayoutUnit rootBlockLogicalLeft = std::max(inlineDirectionOffset(rootBlock, offsetFromRootBlock) + logicalRight,
1679         std::max(logicalLeftSelectionOffset(rootBlock, logicalTop, cache), logicalLeftSelectionOffset(rootBlock, logicalTop + logicalHeight, cache)));
1680     LayoutUnit rootBlockLogicalRight = std::min(logicalRightSelectionOffset(rootBlock, logicalTop, cache), logicalRightSelectionOffset(rootBlock, logicalTop + logicalHeight, cache));
1681     LayoutUnit rootBlockLogicalWidth = rootBlockLogicalRight - rootBlockLogicalLeft;
1682     if (rootBlockLogicalWidth &lt;= 0)
1683         return LayoutRect();
1684 
1685     LayoutRect gapRect = rootBlock.logicalRectToPhysicalRect(rootBlockPhysicalPosition, LayoutRect(rootBlockLogicalLeft, rootBlockLogicalTop, rootBlockLogicalWidth, logicalHeight));
1686     if (paintInfo)
1687         paintInfo-&gt;context().fillRect(snapRectToDevicePixels(gapRect, document().deviceScaleFactor()), selObj-&gt;selectionBackgroundColor());
1688     return gapRect;
1689 }
1690 
1691 void RenderBlock::getSelectionGapInfo(SelectionState state, bool&amp; leftGap, bool&amp; rightGap)
1692 {
1693     bool ltr = style().isLeftToRightDirection();
1694     leftGap = (state == RenderObject::SelectionInside) ||
1695               (state == RenderObject::SelectionEnd &amp;&amp; ltr) ||
1696               (state == RenderObject::SelectionStart &amp;&amp; !ltr);
1697     rightGap = (state == RenderObject::SelectionInside) ||
1698                (state == RenderObject::SelectionStart &amp;&amp; ltr) ||
1699                (state == RenderObject::SelectionEnd &amp;&amp; !ltr);
1700 }
1701 
1702 LayoutUnit RenderBlock::logicalLeftSelectionOffset(RenderBlock&amp; rootBlock, LayoutUnit position, const LogicalSelectionOffsetCaches&amp; cache)
1703 {
1704     LayoutUnit logicalLeft = logicalLeftOffsetForLine(position, DoNotIndentText);
1705     if (logicalLeft == logicalLeftOffsetForContent()) {
1706         if (&amp;rootBlock != this) // The border can potentially be further extended by our containingBlock().
1707             return cache.containingBlockInfo(*this).logicalLeftSelectionOffset(rootBlock, position + logicalTop());
1708         return logicalLeft;
1709     }
1710 
1711     RenderBlock* cb = this;
1712     const LogicalSelectionOffsetCaches* currentCache = &amp;cache;
1713     while (cb != &amp;rootBlock) {
1714         logicalLeft += cb-&gt;logicalLeft();
1715 
1716         ASSERT(currentCache);
1717         auto info = currentCache-&gt;containingBlockInfo(*cb);
1718         cb = info.block();
1719         if (!cb)
1720             break;
1721         currentCache = info.cache();
1722     }
1723     return logicalLeft;
1724 }
1725 
1726 LayoutUnit RenderBlock::logicalRightSelectionOffset(RenderBlock&amp; rootBlock, LayoutUnit position, const LogicalSelectionOffsetCaches&amp; cache)
1727 {
1728     LayoutUnit logicalRight = logicalRightOffsetForLine(position, DoNotIndentText);
1729     if (logicalRight == logicalRightOffsetForContent()) {
1730         if (&amp;rootBlock != this) // The border can potentially be further extended by our containingBlock().
1731             return cache.containingBlockInfo(*this).logicalRightSelectionOffset(rootBlock, position + logicalTop());
1732         return logicalRight;
1733     }
1734 
1735     RenderBlock* cb = this;
1736     const LogicalSelectionOffsetCaches* currentCache = &amp;cache;
1737     while (cb != &amp;rootBlock) {
1738         logicalRight += cb-&gt;logicalLeft();
1739 
1740         ASSERT(currentCache);
1741         auto info = currentCache-&gt;containingBlockInfo(*cb);
1742         cb = info.block();
1743         if (!cb)
1744             break;
1745         currentCache = info.cache();
1746     }
1747     return logicalRight;
1748 }
1749 
1750 TrackedRendererListHashSet* RenderBlock::positionedObjects() const
1751 {
1752     return positionedDescendantsMap().positionedRenderers(*this);
1753 }
1754 
1755 void RenderBlock::insertPositionedObject(RenderBox&amp; positioned)
1756 {
1757     ASSERT(!isAnonymousBlock());
1758     if (positioned.isRenderFragmentedFlow())
1759         return;
1760     // FIXME: Find out if we can do this as part of positioned.setChildNeedsLayout(MarkOnlyThis)
1761     if (positioned.needsLayout()) {
1762         // We should turn this bit on only while in layout.
1763         ASSERT(posChildNeedsLayout() || view().frameView().layoutContext().isInLayout());
1764         setPosChildNeedsLayoutBit(true);
1765     }
1766     positionedDescendantsMap().addDescendant(*this, positioned, isRenderView() ? PositionedDescendantsMap::MoveDescendantToEnd::Yes
1767         : PositionedDescendantsMap::MoveDescendantToEnd::No);
1768 }
1769 
1770 void RenderBlock::removePositionedObject(const RenderBox&amp; rendererToRemove)
1771 {
1772     positionedDescendantsMap().removeDescendant(rendererToRemove);
1773 }
1774 
1775 void RenderBlock::removePositionedObjects(const RenderBlock* newContainingBlockCandidate, ContainingBlockState containingBlockState)
1776 {
1777     auto* positionedDescendants = positionedObjects();
1778     if (!positionedDescendants)
1779         return;
1780 
1781     Vector&lt;RenderBox*, 16&gt; renderersToRemove;
1782     for (auto* renderer : *positionedDescendants) {
1783         if (newContainingBlockCandidate &amp;&amp; !renderer-&gt;isDescendantOf(newContainingBlockCandidate))
1784             continue;
1785         renderersToRemove.append(renderer);
1786         if (containingBlockState == NewContainingBlock)
1787             renderer-&gt;setChildNeedsLayout(MarkOnlyThis);
1788         // It is the parent block&#39;s job to add positioned children to positioned objects list of its containing block.
1789         // Dirty the parent to ensure this happens.
1790         auto* parent = renderer-&gt;parent();
1791         while (parent &amp;&amp; !parent-&gt;isRenderBlock())
1792             parent = parent-&gt;parent();
1793         if (parent)
1794             parent-&gt;setChildNeedsLayout();
1795     }
1796     for (auto* renderer : renderersToRemove)
1797         removePositionedObject(*renderer);
1798 }
1799 
1800 void RenderBlock::addPercentHeightDescendant(RenderBox&amp; descendant)
1801 {
1802     insertIntoTrackedRendererMaps(*this, descendant);
1803 }
1804 
1805 void RenderBlock::removePercentHeightDescendant(RenderBox&amp; descendant)
1806 {
1807     removeFromTrackedRendererMaps(descendant);
1808 }
1809 
1810 TrackedRendererListHashSet* RenderBlock::percentHeightDescendants() const
1811 {
1812     return percentHeightDescendantsMap ? percentHeightDescendantsMap-&gt;get(this) : nullptr;
1813 }
1814 
1815 bool RenderBlock::hasPercentHeightContainerMap()
1816 {
1817     return percentHeightContainerMap;
1818 }
1819 
1820 bool RenderBlock::hasPercentHeightDescendant(RenderBox&amp; descendant)
1821 {
1822     // We don&#39;t null check percentHeightContainerMap since the caller
1823     // already ensures this and we need to call this function on every
1824     // descendant in clearPercentHeightDescendantsFrom().
1825     ASSERT(percentHeightContainerMap);
1826     return percentHeightContainerMap-&gt;contains(&amp;descendant);
1827 }
1828 
1829 void RenderBlock::removePercentHeightDescendantIfNeeded(RenderBox&amp; descendant)
1830 {
1831     // We query the map directly, rather than looking at style&#39;s
1832     // logicalHeight()/logicalMinHeight()/logicalMaxHeight() since those
1833     // can change with writing mode/directional changes.
1834     if (!hasPercentHeightContainerMap())
1835         return;
1836 
1837     if (!hasPercentHeightDescendant(descendant))
1838         return;
1839 
1840     removePercentHeightDescendant(descendant);
1841 }
1842 
1843 void RenderBlock::clearPercentHeightDescendantsFrom(RenderBox&amp; parent)
1844 {
1845     ASSERT(percentHeightContainerMap);
1846     for (RenderObject* child = parent.firstChild(); child; child = child-&gt;nextInPreOrder(&amp;parent)) {
1847         if (!is&lt;RenderBox&gt;(*child))
1848             continue;
1849 
1850         auto&amp; box = downcast&lt;RenderBox&gt;(*child);
1851         if (!hasPercentHeightDescendant(box))
1852             continue;
1853 
1854         removePercentHeightDescendant(box);
1855     }
1856 }
1857 
1858 bool RenderBlock::isContainingBlockAncestorFor(RenderObject&amp; renderer) const
1859 {
1860     for (const auto* ancestor = renderer.containingBlock(); ancestor; ancestor = ancestor-&gt;containingBlock()) {
1861         if (ancestor == this)
1862             return true;
1863     }
1864     return false;
1865 }
1866 
1867 LayoutUnit RenderBlock::textIndentOffset() const
1868 {
1869     LayoutUnit cw;
1870     if (style().textIndent().isPercentOrCalculated())
1871         cw = availableLogicalWidth();
1872     return minimumValueForLength(style().textIndent(), cw);
1873 }
1874 
1875 LayoutUnit RenderBlock::logicalLeftOffsetForContent(RenderFragmentContainer* fragment) const
1876 {
1877     LayoutUnit logicalLeftOffset = style().isHorizontalWritingMode() ? borderLeft() + paddingLeft() : borderTop() + paddingTop();
1878     if (shouldPlaceBlockDirectionScrollbarOnLeft())
1879         logicalLeftOffset += verticalScrollbarWidth();
1880     if (!fragment)
1881         return logicalLeftOffset;
1882     LayoutRect boxRect = borderBoxRectInFragment(fragment);
1883     return logicalLeftOffset + (isHorizontalWritingMode() ? boxRect.x() : boxRect.y());
1884 }
1885 
1886 LayoutUnit RenderBlock::logicalRightOffsetForContent(RenderFragmentContainer* fragment) const
1887 {
1888     LayoutUnit logicalRightOffset = style().isHorizontalWritingMode() ? borderLeft() + paddingLeft() : borderTop() + paddingTop();
1889     if (shouldPlaceBlockDirectionScrollbarOnLeft())
1890         logicalRightOffset += verticalScrollbarWidth();
1891     logicalRightOffset += availableLogicalWidth();
1892     if (!fragment)
1893         return logicalRightOffset;
1894     LayoutRect boxRect = borderBoxRectInFragment(fragment);
1895     return logicalRightOffset - (logicalWidth() - (isHorizontalWritingMode() ? boxRect.maxX() : boxRect.maxY()));
1896 }
1897 
1898 LayoutUnit RenderBlock::adjustLogicalLeftOffsetForLine(LayoutUnit offsetFromFloats, bool applyTextIndent) const
1899 {
1900     LayoutUnit left = offsetFromFloats;
1901 
1902     if (applyTextIndent &amp;&amp; style().isLeftToRightDirection())
1903         left += textIndentOffset();
1904 
1905     if (style().lineAlign() == LineAlign::None)
1906         return left;
1907 
1908     // Push in our left offset so that it is aligned with the character grid.
1909     auto* layoutState = view().frameView().layoutContext().layoutState();
1910     if (!layoutState)
1911         return left;
1912 
1913     RenderBlock* lineGrid = layoutState-&gt;lineGrid();
1914     if (!lineGrid || lineGrid-&gt;style().writingMode() != style().writingMode())
1915         return left;
1916 
1917     // FIXME: Should letter-spacing apply? This is complicated since it doesn&#39;t apply at the edge?
1918     float maxCharWidth = lineGrid-&gt;style().fontCascade().primaryFont().maxCharWidth();
1919     if (!maxCharWidth)
1920         return left;
1921 
1922     LayoutUnit lineGridOffset = lineGrid-&gt;isHorizontalWritingMode() ? layoutState-&gt;lineGridOffset().width(): layoutState-&gt;lineGridOffset().height();
1923     LayoutUnit layoutOffset = lineGrid-&gt;isHorizontalWritingMode() ? layoutState-&gt;layoutOffset().width() : layoutState-&gt;layoutOffset().height();
1924 
1925     // Push in to the nearest character width (truncated so that we pixel snap left).
1926     // FIXME: Should be patched when subpixel layout lands, since this calculation doesn&#39;t have to pixel snap
1927     // any more (https://bugs.webkit.org/show_bug.cgi?id=79946).
1928     // FIXME: This is wrong for RTL (https://bugs.webkit.org/show_bug.cgi?id=79945).
1929     // FIXME: This doesn&#39;t work with columns or fragments (https://bugs.webkit.org/show_bug.cgi?id=79942).
1930     // FIXME: This doesn&#39;t work when the inline position of the object isn&#39;t set ahead of time.
1931     // FIXME: Dynamic changes to the font or to the inline position need to result in a deep relayout.
1932     // (https://bugs.webkit.org/show_bug.cgi?id=79944)
1933     float remainder = fmodf(maxCharWidth - fmodf(left + layoutOffset - lineGridOffset, maxCharWidth), maxCharWidth);
1934     left += remainder;
1935     return left;
1936 }
1937 
1938 LayoutUnit RenderBlock::adjustLogicalRightOffsetForLine(LayoutUnit offsetFromFloats, bool applyTextIndent) const
1939 {
1940     LayoutUnit right = offsetFromFloats;
1941 
1942     if (applyTextIndent &amp;&amp; !style().isLeftToRightDirection())
1943         right -= textIndentOffset();
1944 
1945     if (style().lineAlign() == LineAlign::None)
1946         return right;
1947 
1948     // Push in our right offset so that it is aligned with the character grid.
1949     auto* layoutState = view().frameView().layoutContext().layoutState();
1950     if (!layoutState)
1951         return right;
1952 
1953     RenderBlock* lineGrid = layoutState-&gt;lineGrid();
1954     if (!lineGrid || lineGrid-&gt;style().writingMode() != style().writingMode())
1955         return right;
1956 
1957     // FIXME: Should letter-spacing apply? This is complicated since it doesn&#39;t apply at the edge?
1958     float maxCharWidth = lineGrid-&gt;style().fontCascade().primaryFont().maxCharWidth();
1959     if (!maxCharWidth)
1960         return right;
1961 
1962     LayoutUnit lineGridOffset = lineGrid-&gt;isHorizontalWritingMode() ? layoutState-&gt;lineGridOffset().width(): layoutState-&gt;lineGridOffset().height();
1963     LayoutUnit layoutOffset = lineGrid-&gt;isHorizontalWritingMode() ? layoutState-&gt;layoutOffset().width() : layoutState-&gt;layoutOffset().height();
1964 
1965     // Push in to the nearest character width (truncated so that we pixel snap right).
1966     // FIXME: Should be patched when subpixel layout lands, since this calculation doesn&#39;t have to pixel snap
1967     // any more (https://bugs.webkit.org/show_bug.cgi?id=79946).
1968     // FIXME: This is wrong for RTL (https://bugs.webkit.org/show_bug.cgi?id=79945).
1969     // FIXME: This doesn&#39;t work with columns or fragments (https://bugs.webkit.org/show_bug.cgi?id=79942).
1970     // FIXME: This doesn&#39;t work when the inline position of the object isn&#39;t set ahead of time.
1971     // FIXME: Dynamic changes to the font or to the inline position need to result in a deep relayout.
1972     // (https://bugs.webkit.org/show_bug.cgi?id=79944)
1973     float remainder = fmodf(fmodf(right + layoutOffset - lineGridOffset, maxCharWidth), maxCharWidth);
1974     right -= ceilf(remainder);
1975     return right;
1976 }
1977 
1978 bool RenderBlock::isPointInOverflowControl(HitTestResult&amp; result, const LayoutPoint&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset)
1979 {
1980     if (!scrollsOverflow())
1981         return false;
1982 
1983     return layer()-&gt;hitTestOverflowControls(result, roundedIntPoint(locationInContainer - toLayoutSize(accumulatedOffset)));
1984 }
1985 
1986 Node* RenderBlock::nodeForHitTest() const
1987 {
1988     // If we are in the margins of block elements that are part of a
1989     // continuation we&#39;re actually still inside the enclosing element
1990     // that was split. Use the appropriate inner node.
1991     if (isRenderView())
1992         return &amp;document();
1993     return continuation() ? continuation()-&gt;element() : element();
1994 }
1995 
1996 bool RenderBlock::nodeAtPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
1997 {
1998     LayoutPoint adjustedLocation(accumulatedOffset + location());
1999     LayoutSize localOffset = toLayoutSize(adjustedLocation);
2000 
2001     if (!isRenderView()) {
2002         // Check if we need to do anything at all.
2003         LayoutRect overflowBox = visualOverflowRect();
2004         flipForWritingMode(overflowBox);
2005         overflowBox.moveBy(adjustedLocation);
2006         if (!locationInContainer.intersects(overflowBox))
2007             return false;
2008     }
2009 
2010     if ((hitTestAction == HitTestBlockBackground || hitTestAction == HitTestChildBlockBackground) &amp;&amp; isPointInOverflowControl(result, locationInContainer.point(), adjustedLocation)) {
2011         updateHitTestResult(result, locationInContainer.point() - localOffset);
2012         // FIXME: isPointInOverflowControl() doesn&#39;t handle rect-based tests yet.
2013         if (result.addNodeToListBasedTestResult(nodeForHitTest(), request, locationInContainer) == HitTestProgress::Stop)
2014            return true;
2015     }
2016 
2017     if (style().clipPath()) {
2018         switch (style().clipPath()-&gt;type()) {
2019         case ClipPathOperation::Shape: {
2020             auto&amp; clipPath = downcast&lt;ShapeClipPathOperation&gt;(*style().clipPath());
2021 
2022             LayoutRect referenceBoxRect;
2023             switch (clipPath.referenceBox()) {
2024             case CSSBoxType::MarginBox:
2025                 referenceBoxRect = marginBoxRect();
2026                 break;
2027             case CSSBoxType::PaddingBox:
2028                 referenceBoxRect = paddingBoxRect();
2029                 break;
2030             case CSSBoxType::FillBox:
2031             case CSSBoxType::ContentBox:
2032                 referenceBoxRect = contentBoxRect();
2033                 break;
2034             case CSSBoxType::StrokeBox:
2035             case CSSBoxType::ViewBox:
2036             case CSSBoxType::BorderBox:
2037             case CSSBoxType::BoxMissing:
2038                 referenceBoxRect = borderBoxRect();
2039             }
2040             if (!clipPath.pathForReferenceRect(referenceBoxRect).contains(locationInContainer.point() - localOffset, clipPath.windRule()))
2041                 return false;
2042             break;
2043         }
2044         case ClipPathOperation::Reference: {
2045             const auto&amp; referenceClipPathOperation = downcast&lt;ReferenceClipPathOperation&gt;(*style().clipPath());
2046             auto* element = document().getElementById(referenceClipPathOperation.fragment());
2047             if (!element || !element-&gt;renderer())
2048                 break;
2049             if (!is&lt;SVGClipPathElement&gt;(*element))
2050                 break;
2051             auto&amp; clipper = downcast&lt;RenderSVGResourceClipper&gt;(*element-&gt;renderer());
2052             if (!clipper.hitTestClipContent(FloatRect(borderBoxRect()), FloatPoint(locationInContainer.point() - localOffset)))
2053                 return false;
2054             break;
2055         }
2056         case ClipPathOperation::Box:
2057             break;
2058         }
2059     }
2060 
2061     // If we have clipping, then we can&#39;t have any spillout.
2062     bool useOverflowClip = hasOverflowClip() &amp;&amp; !hasSelfPaintingLayer();
2063     bool useClip = (hasControlClip() || useOverflowClip);
2064     bool checkChildren = !useClip || (hasControlClip() ? locationInContainer.intersects(controlClipRect(adjustedLocation)) : locationInContainer.intersects(overflowClipRect(adjustedLocation, nullptr, IncludeOverlayScrollbarSize)));
2065     if (checkChildren) {
2066         // Hit test descendants first.
2067         LayoutSize scrolledOffset(localOffset - toLayoutSize(scrollPosition()));
2068 
2069         if (hitTestAction == HitTestFloat &amp;&amp; hitTestFloats(request, result, locationInContainer, toLayoutPoint(scrolledOffset)))
2070             return true;
2071         if (hitTestContents(request, result, locationInContainer, toLayoutPoint(scrolledOffset), hitTestAction)) {
2072             updateHitTestResult(result, flipForWritingMode(locationInContainer.point() - localOffset));
2073             return true;
2074         }
2075     }
2076 
2077     if (!checkChildren &amp;&amp; hitTestExcludedChildrenInBorder(request, result, locationInContainer, adjustedLocation, hitTestAction))
2078         return true;
2079 
2080     // Check if the point is outside radii.
2081     if (!isRenderView() &amp;&amp; style().hasBorderRadius()) {
2082         LayoutRect borderRect = borderBoxRect();
2083         borderRect.moveBy(adjustedLocation);
2084         RoundedRect border = style().getRoundedBorderFor(borderRect);
2085         if (!locationInContainer.intersects(border))
2086             return false;
2087     }
2088 
2089     // Now hit test our background
2090     if (hitTestAction == HitTestBlockBackground || hitTestAction == HitTestChildBlockBackground) {
2091         LayoutRect boundsRect(adjustedLocation, size());
2092         if (visibleToHitTesting() &amp;&amp; locationInContainer.intersects(boundsRect)) {
2093             updateHitTestResult(result, flipForWritingMode(locationInContainer.point() - localOffset));
2094             if (result.addNodeToListBasedTestResult(nodeForHitTest(), request, locationInContainer, boundsRect) == HitTestProgress::Stop)
2095                 return true;
2096         }
2097     }
2098 
2099     return false;
2100 }
2101 
2102 bool RenderBlock::hitTestContents(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
2103 {
2104     if (childrenInline() &amp;&amp; !isTable())
2105         return hitTestInlineChildren(request, result, locationInContainer, accumulatedOffset, hitTestAction);
2106 
2107     // Hit test our children.
2108     HitTestAction childHitTest = hitTestAction;
2109     if (hitTestAction == HitTestChildBlockBackgrounds)
2110         childHitTest = HitTestChildBlockBackground;
2111     for (auto* child = lastChildBox(); child; child = child-&gt;previousSiblingBox()) {
2112         LayoutPoint childPoint = flipForWritingModeForChild(child, accumulatedOffset);
2113         if (!child-&gt;hasSelfPaintingLayer() &amp;&amp; !child-&gt;isFloating() &amp;&amp; child-&gt;nodeAtPoint(request, result, locationInContainer, childPoint, childHitTest))
2114             return true;
2115     }
2116 
2117     return false;
2118 }
2119 
2120 static inline bool isEditingBoundary(RenderElement* ancestor, RenderObject&amp; child)
2121 {
2122     ASSERT(!ancestor || ancestor-&gt;nonPseudoElement());
2123     ASSERT(child.nonPseudoNode());
2124     return !ancestor || !ancestor-&gt;parent() || (ancestor-&gt;hasLayer() &amp;&amp; ancestor-&gt;parent()-&gt;isRenderView())
2125         || ancestor-&gt;nonPseudoElement()-&gt;hasEditableStyle() == child.nonPseudoNode()-&gt;hasEditableStyle();
2126 }
2127 
2128 // FIXME: This function should go on RenderObject as an instance method. Then
2129 // all cases in which positionForPoint recurs could call this instead to
2130 // prevent crossing editable boundaries. This would require many tests.
2131 VisiblePosition positionForPointRespectingEditingBoundaries(RenderBlock&amp; parent, RenderBox&amp; child, const LayoutPoint&amp; pointInParentCoordinates)
2132 {
2133     LayoutPoint childLocation = child.location();
2134     if (child.isInFlowPositioned())
2135         childLocation += child.offsetForInFlowPosition();
2136 
2137     // FIXME: This is wrong if the child&#39;s writing-mode is different from the parent&#39;s.
2138     LayoutPoint pointInChildCoordinates(toLayoutPoint(pointInParentCoordinates - childLocation));
2139 
2140     // If this is an anonymous renderer, we just recur normally
2141     Element* childElement= child.nonPseudoElement();
2142     if (!childElement)
2143         return child.positionForPoint(pointInChildCoordinates, nullptr);
2144 
2145     // Otherwise, first make sure that the editability of the parent and child agree.
2146     // If they don&#39;t agree, then we return a visible position just before or after the child
2147     RenderElement* ancestor = &amp;parent;
2148     while (ancestor &amp;&amp; !ancestor-&gt;nonPseudoElement())
2149         ancestor = ancestor-&gt;parent();
2150 
2151     // If we can&#39;t find an ancestor to check editability on, or editability is unchanged, we recur like normal
2152     if (isEditingBoundary(ancestor, child))
2153         return child.positionForPoint(pointInChildCoordinates, nullptr);
2154 
2155     // Otherwise return before or after the child, depending on if the click was to the logical left or logical right of the child
2156     LayoutUnit childMiddle = parent.logicalWidthForChild(child) / 2;
2157     LayoutUnit logicalLeft = parent.isHorizontalWritingMode() ? pointInChildCoordinates.x() : pointInChildCoordinates.y();
2158     if (logicalLeft &lt; childMiddle)
2159         return ancestor-&gt;createVisiblePosition(childElement-&gt;computeNodeIndex(), DOWNSTREAM);
2160     return ancestor-&gt;createVisiblePosition(childElement-&gt;computeNodeIndex() + 1, UPSTREAM);
2161 }
2162 
2163 VisiblePosition RenderBlock::positionForPointWithInlineChildren(const LayoutPoint&amp;, const RenderFragmentContainer*)
2164 {
2165     ASSERT_NOT_REACHED();
2166     return VisiblePosition();
2167 }
2168 
2169 static inline bool isChildHitTestCandidate(const RenderBox&amp; box)
2170 {
2171     return box.height() &amp;&amp; box.style().visibility() == Visibility::Visible &amp;&amp; !box.isOutOfFlowPositioned() &amp;&amp; !box.isInFlowRenderFragmentedFlow();
2172 }
2173 
2174 // Valid candidates in a FragmentedFlow must be rendered by the fragment.
2175 static inline bool isChildHitTestCandidate(const RenderBox&amp; box, const RenderFragmentContainer* fragment, const LayoutPoint&amp; point)
2176 {
2177     if (!isChildHitTestCandidate(box))
2178         return false;
2179     if (!fragment)
2180         return true;
2181     const RenderBlock&amp; block = is&lt;RenderBlock&gt;(box) ? downcast&lt;RenderBlock&gt;(box) : *box.containingBlock();
2182     return block.fragmentAtBlockOffset(point.y()) == fragment;
2183 }
2184 
2185 VisiblePosition RenderBlock::positionForPoint(const LayoutPoint&amp; point, const RenderFragmentContainer* fragment)
2186 {
2187     if (isTable())
2188         return RenderBox::positionForPoint(point, fragment);
2189 
2190     if (isReplaced()) {
2191         // FIXME: This seems wrong when the object&#39;s writing-mode doesn&#39;t match the line&#39;s writing-mode.
2192         LayoutUnit pointLogicalLeft = isHorizontalWritingMode() ? point.x() : point.y();
2193         LayoutUnit pointLogicalTop = isHorizontalWritingMode() ? point.y() : point.x();
2194 
2195         if (pointLogicalTop &lt; 0 || (pointLogicalTop &lt; logicalHeight() &amp;&amp; pointLogicalLeft &lt; 0))
2196             return createVisiblePosition(caretMinOffset(), DOWNSTREAM);
2197         if (pointLogicalTop &gt;= logicalHeight() || (pointLogicalTop &gt;= 0 &amp;&amp; pointLogicalLeft &gt;= logicalWidth()))
2198             return createVisiblePosition(caretMaxOffset(), DOWNSTREAM);
2199     }
2200 
2201     LayoutPoint pointInContents = point;
2202     offsetForContents(pointInContents);
2203     LayoutPoint pointInLogicalContents(pointInContents);
2204     if (!isHorizontalWritingMode())
2205         pointInLogicalContents = pointInLogicalContents.transposedPoint();
2206 
2207     if (childrenInline())
2208         return positionForPointWithInlineChildren(pointInLogicalContents, fragment);
2209 
2210     RenderBox* lastCandidateBox = lastChildBox();
2211 
2212     if (!fragment)
2213         fragment = fragmentAtBlockOffset(pointInLogicalContents.y());
2214 
2215     while (lastCandidateBox &amp;&amp; !isChildHitTestCandidate(*lastCandidateBox, fragment, pointInLogicalContents))
2216         lastCandidateBox = lastCandidateBox-&gt;previousSiblingBox();
2217 
2218     bool blocksAreFlipped = style().isFlippedBlocksWritingMode();
2219     if (lastCandidateBox) {
2220         if (pointInLogicalContents.y() &gt; logicalTopForChild(*lastCandidateBox)
2221             || (!blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == logicalTopForChild(*lastCandidateBox)))
2222             return positionForPointRespectingEditingBoundaries(*this, *lastCandidateBox, pointInContents);
2223 
2224         for (auto* childBox = firstChildBox(); childBox; childBox = childBox-&gt;nextSiblingBox()) {
2225             if (!isChildHitTestCandidate(*childBox, fragment, pointInLogicalContents))
2226                 continue;
2227             LayoutUnit childLogicalBottom = logicalTopForChild(*childBox) + logicalHeightForChild(*childBox);
2228             if (is&lt;RenderBlockFlow&gt;(childBox))
2229                 childLogicalBottom += downcast&lt;RenderBlockFlow&gt;(childBox)-&gt;lowestFloatLogicalBottom();
2230             // We hit child if our click is above the bottom of its padding box (like IE6/7 and FF3).
2231             if (isChildHitTestCandidate(*childBox, fragment, pointInLogicalContents) &amp;&amp; (pointInLogicalContents.y() &lt; childLogicalBottom
2232                 || (blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == childLogicalBottom)))
2233                 return positionForPointRespectingEditingBoundaries(*this, *childBox, pointInContents);
2234         }
2235     }
2236 
2237     // We only get here if there are no hit test candidate children below the click.
2238     return RenderBox::positionForPoint(point, fragment);
2239 }
2240 
2241 void RenderBlock::offsetForContents(LayoutPoint&amp; offset) const
2242 {
2243     offset = flipForWritingMode(offset);
2244     offset += toLayoutSize(scrollPosition());
2245     offset = flipForWritingMode(offset);
2246 }
2247 
2248 void RenderBlock::computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
2249 {
2250     ASSERT(!childrenInline());
2251 
2252     computeBlockPreferredLogicalWidths(minLogicalWidth, maxLogicalWidth);
2253 
2254     maxLogicalWidth = std::max(minLogicalWidth, maxLogicalWidth);
2255 
2256     int scrollbarWidth = intrinsicScrollbarLogicalWidth();
2257     maxLogicalWidth += scrollbarWidth;
2258     minLogicalWidth += scrollbarWidth;
2259 }
2260 
2261 void RenderBlock::computePreferredLogicalWidths()
2262 {
2263     ASSERT(preferredLogicalWidthsDirty());
2264 
2265     m_minPreferredLogicalWidth = 0;
2266     m_maxPreferredLogicalWidth = 0;
2267 
2268     const RenderStyle&amp; styleToUse = style();
2269     if (!isTableCell() &amp;&amp; styleToUse.logicalWidth().isFixed() &amp;&amp; styleToUse.logicalWidth().value() &gt;= 0
2270         &amp;&amp; !(isDeprecatedFlexItem() &amp;&amp; !styleToUse.logicalWidth().intValue()))
2271         m_minPreferredLogicalWidth = m_maxPreferredLogicalWidth = adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalWidth().value());
2272     else
2273         computeIntrinsicLogicalWidths(m_minPreferredLogicalWidth, m_maxPreferredLogicalWidth);
2274 
2275     if (styleToUse.logicalMaxWidth().isFixed()) {
2276         m_maxPreferredLogicalWidth = std::min(m_maxPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMaxWidth().value()));
2277         m_minPreferredLogicalWidth = std::min(m_minPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMaxWidth().value()));
2278     }
2279 
2280     if (styleToUse.logicalMinWidth().isFixed() &amp;&amp; styleToUse.logicalMinWidth().value() &gt; 0) {
2281         m_maxPreferredLogicalWidth = std::max(m_maxPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMinWidth().value()));
2282         m_minPreferredLogicalWidth = std::max(m_minPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMinWidth().value()));
2283     }
2284 
2285     LayoutUnit borderAndPadding = borderAndPaddingLogicalWidth();
2286     m_minPreferredLogicalWidth += borderAndPadding;
2287     m_maxPreferredLogicalWidth += borderAndPadding;
2288 
2289     setPreferredLogicalWidthsDirty(false);
2290 }
2291 
2292 void RenderBlock::computeBlockPreferredLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
2293 {
2294     const RenderStyle&amp; styleToUse = style();
2295     bool nowrap = styleToUse.whiteSpace() == WhiteSpace::NoWrap;
2296 
2297     RenderObject* child = firstChild();
2298     RenderBlock* containingBlock = this-&gt;containingBlock();
2299     LayoutUnit floatLeftWidth, floatRightWidth;
2300 
2301     LayoutUnit childMinWidth;
2302     LayoutUnit childMaxWidth;
2303     bool hadExcludedChildren = computePreferredWidthsForExcludedChildren(childMinWidth, childMaxWidth);
2304     if (hadExcludedChildren) {
2305         minLogicalWidth = std::max(childMinWidth, minLogicalWidth);
2306         maxLogicalWidth = std::max(childMaxWidth, maxLogicalWidth);
2307     }
2308 
2309     while (child) {
2310         // Positioned children don&#39;t affect the min/max width. Legends in fieldsets are skipped here
2311         // since they compute outside of any one layout system. Other children excluded from
2312         // normal layout are only used with block flows, so it&#39;s ok to calculate them here.
2313         if (child-&gt;isOutOfFlowPositioned() || child-&gt;isExcludedAndPlacedInBorder()) {
2314             child = child-&gt;nextSibling();
2315             continue;
2316         }
2317 
2318         const RenderStyle&amp; childStyle = child-&gt;style();
2319         if (child-&gt;isFloating() || (is&lt;RenderBox&gt;(*child) &amp;&amp; downcast&lt;RenderBox&gt;(*child).avoidsFloats())) {
2320             LayoutUnit floatTotalWidth = floatLeftWidth + floatRightWidth;
2321             if (childStyle.clear() == Clear::Left || childStyle.clear() == Clear::Both) {
2322                 maxLogicalWidth = std::max(floatTotalWidth, maxLogicalWidth);
2323                 floatLeftWidth = 0;
2324             }
2325             if (childStyle.clear() == Clear::Right || childStyle.clear() == Clear::Both) {
2326                 maxLogicalWidth = std::max(floatTotalWidth, maxLogicalWidth);
2327                 floatRightWidth = 0;
2328             }
2329         }
2330 
2331         // A margin basically has three types: fixed, percentage, and auto (variable).
2332         // Auto and percentage margins simply become 0 when computing min/max width.
2333         // Fixed margins can be added in as is.
2334         Length startMarginLength = childStyle.marginStartUsing(&amp;styleToUse);
2335         Length endMarginLength = childStyle.marginEndUsing(&amp;styleToUse);
2336         LayoutUnit margin;
2337         LayoutUnit marginStart;
2338         LayoutUnit marginEnd;
2339         if (startMarginLength.isFixed())
2340             marginStart += startMarginLength.value();
2341         if (endMarginLength.isFixed())
2342             marginEnd += endMarginLength.value();
2343         margin = marginStart + marginEnd;
2344 
2345         LayoutUnit childMinPreferredLogicalWidth, childMaxPreferredLogicalWidth;
2346         computeChildPreferredLogicalWidths(*child, childMinPreferredLogicalWidth, childMaxPreferredLogicalWidth);
2347 
2348         LayoutUnit w = childMinPreferredLogicalWidth + margin;
2349         minLogicalWidth = std::max(w, minLogicalWidth);
2350 
2351         // IE ignores tables for calculation of nowrap. Makes some sense.
2352         if (nowrap &amp;&amp; !child-&gt;isTable())
2353             maxLogicalWidth = std::max(w, maxLogicalWidth);
2354 
2355         w = childMaxPreferredLogicalWidth + margin;
2356 
2357         if (!child-&gt;isFloating()) {
2358             if (is&lt;RenderBox&gt;(*child) &amp;&amp; downcast&lt;RenderBox&gt;(*child).avoidsFloats()) {
2359                 // Determine a left and right max value based off whether or not the floats can fit in the
2360                 // margins of the object.  For negative margins, we will attempt to overlap the float if the negative margin
2361                 // is smaller than the float width.
2362                 bool ltr = containingBlock ? containingBlock-&gt;style().isLeftToRightDirection() : styleToUse.isLeftToRightDirection();
2363                 LayoutUnit marginLogicalLeft = ltr ? marginStart : marginEnd;
2364                 LayoutUnit marginLogicalRight = ltr ? marginEnd : marginStart;
2365                 LayoutUnit maxLeft = marginLogicalLeft &gt; 0 ? std::max(floatLeftWidth, marginLogicalLeft) : floatLeftWidth + marginLogicalLeft;
2366                 LayoutUnit maxRight = marginLogicalRight &gt; 0 ? std::max(floatRightWidth, marginLogicalRight) : floatRightWidth + marginLogicalRight;
2367                 w = childMaxPreferredLogicalWidth + maxLeft + maxRight;
2368                 w = std::max(w, floatLeftWidth + floatRightWidth);
2369             }
2370             else
2371                 maxLogicalWidth = std::max(floatLeftWidth + floatRightWidth, maxLogicalWidth);
2372             floatLeftWidth = floatRightWidth = 0;
2373         }
2374 
2375         if (child-&gt;isFloating()) {
2376             if (childStyle.floating() == Float::Left)
2377                 floatLeftWidth += w;
2378             else
2379                 floatRightWidth += w;
2380         } else
2381             maxLogicalWidth = std::max(w, maxLogicalWidth);
2382 
2383         child = child-&gt;nextSibling();
2384     }
2385 
2386     // Always make sure these values are non-negative.
2387     minLogicalWidth = std::max&lt;LayoutUnit&gt;(0, minLogicalWidth);
2388     maxLogicalWidth = std::max&lt;LayoutUnit&gt;(0, maxLogicalWidth);
2389 
2390     maxLogicalWidth = std::max(floatLeftWidth + floatRightWidth, maxLogicalWidth);
2391 }
2392 
2393 void RenderBlock::computeChildPreferredLogicalWidths(RenderObject&amp; child, LayoutUnit&amp; minPreferredLogicalWidth, LayoutUnit&amp; maxPreferredLogicalWidth) const
2394 {
2395     if (child.isBox() &amp;&amp; child.isHorizontalWritingMode() != isHorizontalWritingMode()) {
2396         // If the child is an orthogonal flow, child&#39;s height determines the width,
2397         // but the height is not available until layout.
2398         // http://dev.w3.org/csswg/css-writing-modes-3/#orthogonal-shrink-to-fit
2399         if (!child.needsLayout()) {
2400             minPreferredLogicalWidth = maxPreferredLogicalWidth = downcast&lt;RenderBox&gt;(child).logicalHeight();
2401             return;
2402         }
2403         minPreferredLogicalWidth = maxPreferredLogicalWidth = downcast&lt;RenderBox&gt;(child).computeLogicalHeightWithoutLayout();
2404         return;
2405     }
2406 
2407     // The preferred widths of flexbox children should never depend on override sizes. They should
2408     // always be computed without regard for any overrides that are present.
2409     Optional&lt;LayoutUnit&gt; overrideHeight;
2410     Optional&lt;LayoutUnit&gt; overrideWidth;
2411 
2412     if (child.isBox()) {
2413         auto&amp; box = downcast&lt;RenderBox&gt;(child);
2414         if (box.isFlexItem()) {
2415             if (box.hasOverrideContentLogicalHeight())
2416                 overrideHeight = Optional&lt;LayoutUnit&gt;(box.overrideContentLogicalHeight());
2417             if (box.hasOverrideContentLogicalWidth())
2418                 overrideWidth = Optional&lt;LayoutUnit&gt;(box.overrideContentLogicalWidth());
2419             box.clearOverrideContentSize();
2420         }
2421     }
2422 
2423     minPreferredLogicalWidth = child.minPreferredLogicalWidth();
2424     maxPreferredLogicalWidth = child.maxPreferredLogicalWidth();
2425 
2426     if (child.isBox()) {
2427         auto&amp; box = downcast&lt;RenderBox&gt;(child);
2428         if (overrideHeight)
2429             box.setOverrideContentLogicalHeight(overrideHeight.value());
2430         if (overrideWidth)
2431             box.setOverrideContentLogicalWidth(overrideWidth.value());
2432     }
2433 
2434     // For non-replaced blocks if the inline size is min|max-content or a definite
2435     // size the min|max-content contribution is that size plus border, padding and
2436     // margin https://drafts.csswg.org/css-sizing/#block-intrinsic
2437     if (child.isRenderBlock()) {
2438         const Length&amp; computedInlineSize = child.style().logicalWidth();
2439         if (computedInlineSize.isMaxContent())
2440             minPreferredLogicalWidth = maxPreferredLogicalWidth;
2441         else if (computedInlineSize.isMinContent())
2442             maxPreferredLogicalWidth = minPreferredLogicalWidth;
2443     }
2444 }
2445 
2446 bool RenderBlock::hasLineIfEmpty() const
2447 {
2448     if (!element())
2449         return false;
2450 
2451     if (element()-&gt;isRootEditableElement())
2452         return true;
2453 
2454     return false;
2455 }
2456 
2457 LayoutUnit RenderBlock::lineHeight(bool firstLine, LineDirectionMode direction, LinePositionMode linePositionMode) const
2458 {
2459     // Inline blocks are replaced elements. Otherwise, just pass off to
2460     // the base class.  If we&#39;re being queried as though we&#39;re the root line
2461     // box, then the fact that we&#39;re an inline-block is irrelevant, and we behave
2462     // just like a block.
2463     if (isReplaced() &amp;&amp; linePositionMode == PositionOnContainingLine)
2464         return RenderBox::lineHeight(firstLine, direction, linePositionMode);
2465 
2466     if (firstLine &amp;&amp; view().usesFirstLineRules()) {
2467         auto&amp; s = firstLineStyle();
2468         if (&amp;s != &amp;style())
2469             return s.computedLineHeight();
2470     }
2471 
2472     return style().computedLineHeight();
2473 }
2474 
2475 int RenderBlock::baselinePosition(FontBaseline baselineType, bool firstLine, LineDirectionMode direction, LinePositionMode linePositionMode) const
2476 {
2477     // Inline blocks are replaced elements. Otherwise, just pass off to
2478     // the base class.  If we&#39;re being queried as though we&#39;re the root line
2479     // box, then the fact that we&#39;re an inline-block is irrelevant, and we behave
2480     // just like a block.
2481     if (isReplaced() &amp;&amp; linePositionMode == PositionOnContainingLine) {
2482         // For &quot;leaf&quot; theme objects, let the theme decide what the baseline position is.
2483         // FIXME: Might be better to have a custom CSS property instead, so that if the theme
2484         // is turned off, checkboxes/radios will still have decent baselines.
2485         // FIXME: Need to patch form controls to deal with vertical lines.
2486         if (style().hasAppearance() &amp;&amp; !theme().isControlContainer(style().appearance()))
2487             return theme().baselinePosition(*this);
2488 
2489         // CSS2.1 states that the baseline of an inline block is the baseline of the last line box in
2490         // the normal flow.  We make an exception for marquees, since their baselines are meaningless
2491         // (the content inside them moves).  This matches WinIE as well, which just bottom-aligns them.
2492         // We also give up on finding a baseline if we have a vertical scrollbar, or if we are scrolled
2493         // vertically (e.g., an overflow:hidden block that has had scrollTop moved).
2494         bool ignoreBaseline = (layer() &amp;&amp; (layer()-&gt;marquee() || (direction == HorizontalLine ? (layer()-&gt;verticalScrollbar() || layer()-&gt;scrollOffset().y() != 0)
2495             : (layer()-&gt;horizontalScrollbar() || layer()-&gt;scrollOffset().x() != 0)))) || (isWritingModeRoot() &amp;&amp; !isRubyRun());
2496 
2497         Optional&lt;int&gt; baselinePos = ignoreBaseline ? Optional&lt;int&gt;() : inlineBlockBaseline(direction);
2498 
2499         if (isDeprecatedFlexibleBox()) {
2500             // Historically, we did this check for all baselines. But we can&#39;t
2501             // remove this code from deprecated flexbox, because it effectively
2502             // breaks -webkit-line-clamp, which is used in the wild -- we would
2503             // calculate the baseline as if -webkit-line-clamp wasn&#39;t used.
2504             // For simplicity, we use this for all uses of deprecated flexbox.
2505             LayoutUnit bottomOfContent = direction == HorizontalLine ? borderTop() + paddingTop() + contentHeight() : borderRight() + paddingRight() + contentWidth();
2506             if (baselinePos &amp;&amp; baselinePos.value() &gt; bottomOfContent)
2507                 baselinePos = Optional&lt;int&gt;();
2508         }
2509         if (baselinePos)
2510             return direction == HorizontalLine ? marginTop() + baselinePos.value() : marginRight() + baselinePos.value();
2511 
2512         return RenderBox::baselinePosition(baselineType, firstLine, direction, linePositionMode);
2513     }
2514 
2515     const RenderStyle&amp; style = firstLine ? firstLineStyle() : this-&gt;style();
2516     const FontMetrics&amp; fontMetrics = style.fontMetrics();
2517     return fontMetrics.ascent(baselineType) + (lineHeight(firstLine, direction, linePositionMode) - fontMetrics.height()) / 2;
2518 }
2519 
2520 LayoutUnit RenderBlock::minLineHeightForReplacedRenderer(bool isFirstLine, LayoutUnit replacedHeight) const
2521 {
2522     if (!document().inNoQuirksMode() &amp;&amp; replacedHeight)
2523         return replacedHeight;
2524 
2525     const RenderStyle&amp; style = isFirstLine ? firstLineStyle() : this-&gt;style();
2526     if (!(style.lineBoxContain().contains(LineBoxContain::Block)))
2527         return 0;
2528 
2529     return std::max&lt;LayoutUnit&gt;(replacedHeight, lineHeight(isFirstLine, isHorizontalWritingMode() ? HorizontalLine : VerticalLine, PositionOfInteriorLineBoxes));
2530 }
2531 
2532 Optional&lt;int&gt; RenderBlock::firstLineBaseline() const
2533 {
2534     if (isWritingModeRoot() &amp;&amp; !isRubyRun())
2535         return Optional&lt;int&gt;();
2536 
2537     for (RenderBox* curr = firstChildBox(); curr; curr = curr-&gt;nextSiblingBox()) {
2538         if (!curr-&gt;isFloatingOrOutOfFlowPositioned()) {
2539             if (Optional&lt;int&gt; result = curr-&gt;firstLineBaseline())
2540                 return Optional&lt;int&gt;(curr-&gt;logicalTop() + result.value()); // Translate to our coordinate space.
2541         }
2542     }
2543 
2544     return Optional&lt;int&gt;();
2545 }
2546 
2547 Optional&lt;int&gt; RenderBlock::inlineBlockBaseline(LineDirectionMode lineDirection) const
2548 {
2549     if (isWritingModeRoot() &amp;&amp; !isRubyRun())
2550         return Optional&lt;int&gt;();
2551 
2552     bool haveNormalFlowChild = false;
2553     for (auto* box = lastChildBox(); box; box = box-&gt;previousSiblingBox()) {
2554         if (box-&gt;isFloatingOrOutOfFlowPositioned())
2555             continue;
2556         haveNormalFlowChild = true;
2557         if (Optional&lt;int&gt; result = box-&gt;inlineBlockBaseline(lineDirection))
2558             return Optional&lt;int&gt;(box-&gt;logicalTop() + result.value()); // Translate to our coordinate space.
2559     }
2560 
2561     if (!haveNormalFlowChild &amp;&amp; hasLineIfEmpty()) {
2562         auto&amp; fontMetrics = firstLineStyle().fontMetrics();
2563         return Optional&lt;int&gt;(fontMetrics.ascent()
2564             + (lineHeight(true, lineDirection, PositionOfInteriorLineBoxes) - fontMetrics.height()) / 2
2565             + (lineDirection == HorizontalLine ? borderTop() + paddingTop() : borderRight() + paddingRight()));
2566     }
2567 
2568     return Optional&lt;int&gt;();
2569 }
2570 
2571 static inline bool isRenderBlockFlowOrRenderButton(RenderElement&amp; renderElement)
2572 {
2573     // We include isRenderButton in this check because buttons are implemented
2574     // using flex box but should still support first-line|first-letter.
2575     // The flex box and specs require that flex box and grid do not support
2576     // first-line|first-letter, though.
2577     // FIXME: Remove when buttons are implemented with align-items instead of
2578     // flex box.
2579     return renderElement.isRenderBlockFlow() || renderElement.isRenderButton();
2580 }
2581 
2582 RenderBlock* RenderBlock::firstLineBlock() const
2583 {
2584     RenderBlock* firstLineBlock = const_cast&lt;RenderBlock*&gt;(this);
2585     bool hasPseudo = false;
2586     while (true) {
2587         hasPseudo = firstLineBlock-&gt;style().hasPseudoStyle(PseudoId::FirstLine);
2588         if (hasPseudo)
2589             break;
2590         RenderElement* parentBlock = firstLineBlock-&gt;parent();
2591         if (firstLineBlock-&gt;isReplaced() || firstLineBlock-&gt;isFloating()
2592             || !parentBlock || parentBlock-&gt;firstChild() != firstLineBlock || !isRenderBlockFlowOrRenderButton(*parentBlock))
2593             break;
2594         firstLineBlock = downcast&lt;RenderBlock&gt;(parentBlock);
2595     }
2596 
2597     if (!hasPseudo)
2598         return nullptr;
2599 
2600     return firstLineBlock;
2601 }
2602 
2603 static inline RenderBlock* findFirstLetterBlock(RenderBlock* start)
2604 {
2605     RenderBlock* firstLetterBlock = start;
2606     while (true) {
2607         bool canHaveFirstLetterRenderer = firstLetterBlock-&gt;style().hasPseudoStyle(PseudoId::FirstLetter)
2608             &amp;&amp; firstLetterBlock-&gt;canHaveGeneratedChildren()
2609             &amp;&amp; isRenderBlockFlowOrRenderButton(*firstLetterBlock);
2610         if (canHaveFirstLetterRenderer)
2611             return firstLetterBlock;
2612 
2613         RenderElement* parentBlock = firstLetterBlock-&gt;parent();
2614         if (firstLetterBlock-&gt;isReplaced() || !parentBlock || parentBlock-&gt;firstChild() != firstLetterBlock
2615             || !isRenderBlockFlowOrRenderButton(*parentBlock))
2616             return nullptr;
2617         firstLetterBlock = downcast&lt;RenderBlock&gt;(parentBlock);
2618     }
2619 
2620     return nullptr;
2621 }
2622 
2623 void RenderBlock::getFirstLetter(RenderObject*&amp; firstLetter, RenderElement*&amp; firstLetterContainer, RenderObject* skipObject)
2624 {
2625     firstLetter = nullptr;
2626     firstLetterContainer = nullptr;
2627 
2628     if (!view().usesFirstLetterRules())
2629         return;
2630 
2631     // Don&#39;t recur
2632     if (style().styleType() == PseudoId::FirstLetter)
2633         return;
2634 
2635     // FIXME: We need to destroy the first-letter object if it is no longer the first child. Need to find
2636     // an efficient way to check for that situation though before implementing anything.
2637     firstLetterContainer = findFirstLetterBlock(this);
2638     if (!firstLetterContainer)
2639         return;
2640 
2641     // Drill into inlines looking for our first text descendant.
2642     firstLetter = firstLetterContainer-&gt;firstChild();
2643     while (firstLetter) {
2644         if (is&lt;RenderText&gt;(*firstLetter)) {
2645             if (firstLetter == skipObject) {
2646                 firstLetter = firstLetter-&gt;nextSibling();
2647                 continue;
2648             }
2649 
2650             break;
2651         }
2652 
2653         RenderElement&amp; current = downcast&lt;RenderElement&gt;(*firstLetter);
2654         if (is&lt;RenderListMarker&gt;(current))
2655             firstLetter = current.nextSibling();
2656         else if (current.isFloatingOrOutOfFlowPositioned()) {
2657             if (current.style().styleType() == PseudoId::FirstLetter) {
2658                 firstLetter = current.firstChild();
2659                 break;
2660             }
2661             firstLetter = current.nextSibling();
2662         } else if (current.isReplaced() || is&lt;RenderButton&gt;(current) || is&lt;RenderMenuList&gt;(current))
2663             break;
2664         else if (current.isFlexibleBoxIncludingDeprecated() || current.isRenderGrid())
2665             firstLetter = current.nextSibling();
2666         else if (current.style().hasPseudoStyle(PseudoId::FirstLetter) &amp;&amp; current.canHaveGeneratedChildren())  {
2667             // We found a lower-level node with first-letter, which supersedes the higher-level style
2668             firstLetterContainer = &amp;current;
2669             firstLetter = current.firstChild();
2670         } else
2671             firstLetter = current.firstChild();
2672     }
2673 
2674     if (!firstLetter)
2675         firstLetterContainer = nullptr;
2676 }
2677 
2678 RenderFragmentedFlow* RenderBlock::cachedEnclosingFragmentedFlow() const
2679 {
2680     RenderBlockRareData* rareData = getBlockRareData(*this);
2681 
2682     if (!rareData || !rareData-&gt;m_enclosingFragmentedFlow)
2683         return nullptr;
2684 
2685     return rareData-&gt;m_enclosingFragmentedFlow.value().get();
2686 }
2687 
2688 bool RenderBlock::cachedEnclosingFragmentedFlowNeedsUpdate() const
2689 {
2690     RenderBlockRareData* rareData = getBlockRareData(*this);
2691 
2692     if (!rareData || !rareData-&gt;m_enclosingFragmentedFlow)
2693         return true;
2694 
2695     return false;
2696 }
2697 
2698 void RenderBlock::setCachedEnclosingFragmentedFlowNeedsUpdate()
2699 {
2700     RenderBlockRareData&amp; rareData = ensureBlockRareData(*this);
2701     rareData.m_enclosingFragmentedFlow = WTF::nullopt;
2702 }
2703 
2704 RenderFragmentedFlow* RenderBlock::updateCachedEnclosingFragmentedFlow(RenderFragmentedFlow* fragmentedFlow) const
2705 {
2706     RenderBlockRareData&amp; rareData = ensureBlockRareData(*this);
2707     rareData.m_enclosingFragmentedFlow = makeWeakPtr(fragmentedFlow);
2708 
2709     return fragmentedFlow;
2710 }
2711 
2712 RenderFragmentedFlow* RenderBlock::locateEnclosingFragmentedFlow() const
2713 {
2714     RenderBlockRareData* rareData = getBlockRareData(*this);
2715     if (!rareData || !rareData-&gt;m_enclosingFragmentedFlow)
2716         return updateCachedEnclosingFragmentedFlow(RenderBox::locateEnclosingFragmentedFlow());
2717 
2718     ASSERT(rareData-&gt;m_enclosingFragmentedFlow.value() == RenderBox::locateEnclosingFragmentedFlow());
2719     return rareData-&gt;m_enclosingFragmentedFlow.value().get();
2720 }
2721 
2722 void RenderBlock::resetEnclosingFragmentedFlowAndChildInfoIncludingDescendants(RenderFragmentedFlow*)
2723 {
2724     if (fragmentedFlowState() == NotInsideFragmentedFlow)
2725         return;
2726 
2727     if (cachedEnclosingFragmentedFlowNeedsUpdate())
2728         return;
2729 
2730     auto* fragmentedFlow = cachedEnclosingFragmentedFlow();
2731     setCachedEnclosingFragmentedFlowNeedsUpdate();
2732     RenderElement::resetEnclosingFragmentedFlowAndChildInfoIncludingDescendants(fragmentedFlow);
2733 }
2734 
2735 LayoutUnit RenderBlock::paginationStrut() const
2736 {
2737     RenderBlockRareData* rareData = getBlockRareData(*this);
2738     return rareData ? rareData-&gt;m_paginationStrut : 0_lu;
2739 }
2740 
2741 LayoutUnit RenderBlock::pageLogicalOffset() const
2742 {
2743     RenderBlockRareData* rareData = getBlockRareData(*this);
2744     return rareData ? rareData-&gt;m_pageLogicalOffset : 0_lu;
2745 }
2746 
2747 void RenderBlock::setPaginationStrut(LayoutUnit strut)
2748 {
2749     RenderBlockRareData* rareData = getBlockRareData(*this);
2750     if (!rareData) {
2751         if (!strut)
2752             return;
2753         rareData = &amp;ensureBlockRareData(*this);
2754     }
2755     rareData-&gt;m_paginationStrut = strut;
2756 }
2757 
2758 void RenderBlock::setPageLogicalOffset(LayoutUnit logicalOffset)
2759 {
2760     RenderBlockRareData* rareData = getBlockRareData(*this);
2761     if (!rareData) {
2762         if (!logicalOffset)
2763             return;
2764         rareData = &amp;ensureBlockRareData(*this);
2765     }
2766     rareData-&gt;m_pageLogicalOffset = logicalOffset;
2767 }
2768 
2769 void RenderBlock::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
2770 {
2771     // For blocks inside inlines, we include margins so that we run right up to the inline boxes
2772     // above and below us (thus getting merged with them to form a single irregular shape).
2773     if (auto* continuation = this-&gt;continuation()) {
2774         // FIXME: This is wrong for block-flows that are horizontal.
2775         // https://bugs.webkit.org/show_bug.cgi?id=46781
2776         rects.append(snappedIntRect(accumulatedOffset.x(), accumulatedOffset.y() - collapsedMarginBefore(), width(), height() + collapsedMarginBefore() + collapsedMarginAfter()));
2777         continuation-&gt;absoluteRects(rects, accumulatedOffset - toLayoutSize(location() + inlineContinuation()-&gt;containingBlock()-&gt;location()));
2778     } else
2779         rects.append(snappedIntRect(accumulatedOffset, size()));
2780 }
2781 
2782 void RenderBlock::absoluteQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
2783 {
2784     if (!continuation()) {
2785         absoluteQuadsIgnoringContinuation({ { }, size() }, quads, wasFixed);
2786         return;
2787     }
2788     // For blocks inside inlines, we include margins so that we run right up to the inline boxes
2789     // above and below us (thus getting merged with them to form a single irregular shape).
2790     auto logicalRect = FloatRect { 0, -collapsedMarginBefore(), width(), height() + collapsedMarginBefore() + collapsedMarginAfter() };
2791     absoluteQuadsIgnoringContinuation(logicalRect, quads, wasFixed);
2792     collectAbsoluteQuadsForContinuation(quads, wasFixed);
2793 }
2794 
2795 void RenderBlock::absoluteQuadsIgnoringContinuation(const FloatRect&amp; logicalRect, Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
2796 {
2797     // FIXME: This is wrong for block-flows that are horizontal.
2798     // https://bugs.webkit.org/show_bug.cgi?id=46781
2799     auto* fragmentedFlow = enclosingFragmentedFlow();
2800     if (!fragmentedFlow || !fragmentedFlow-&gt;absoluteQuadsForBox(quads, wasFixed, this, logicalRect.y(), logicalRect.maxY()))
2801         quads.append(localToAbsoluteQuad(logicalRect, UseTransforms, wasFixed));
2802 }
2803 
2804 LayoutRect RenderBlock::rectWithOutlineForRepaint(const RenderLayerModelObject* repaintContainer, LayoutUnit outlineWidth) const
2805 {
2806     LayoutRect r(RenderBox::rectWithOutlineForRepaint(repaintContainer, outlineWidth));
2807     if (isContinuation())
2808         r.inflateY(collapsedMarginBefore()); // FIXME: This is wrong for block-flows that are horizontal.
2809     return r;
2810 }
2811 
2812 void RenderBlock::updateDragState(bool dragOn)
2813 {
2814     RenderBox::updateDragState(dragOn);
2815     if (RenderBoxModelObject* continuation = this-&gt;continuation())
2816         continuation-&gt;updateDragState(dragOn);
2817 }
2818 
2819 const RenderStyle&amp; RenderBlock::outlineStyleForRepaint() const
2820 {
2821     if (auto* continuation = this-&gt;continuation())
2822         return continuation-&gt;style();
2823     return RenderElement::outlineStyleForRepaint();
2824 }
2825 
2826 void RenderBlock::updateHitTestResult(HitTestResult&amp; result, const LayoutPoint&amp; point)
2827 {
2828     if (result.innerNode())
2829         return;
2830 
2831     if (Node* n = nodeForHitTest()) {
2832         result.setInnerNode(n);
2833         if (!result.innerNonSharedNode())
2834             result.setInnerNonSharedNode(n);
2835         result.setLocalPoint(point);
2836     }
2837 }
2838 
2839 LayoutRect RenderBlock::localCaretRect(InlineBox* inlineBox, unsigned caretOffset, LayoutUnit* extraWidthToEndOfLine)
2840 {
2841     // Do the normal calculation in most cases.
2842     if (firstChild())
2843         return RenderBox::localCaretRect(inlineBox, caretOffset, extraWidthToEndOfLine);
2844 
2845     LayoutRect caretRect = localCaretRectForEmptyElement(width(), textIndentOffset());
2846 
2847     // FIXME: Does this need to adjust for vertical orientation?
2848     if (extraWidthToEndOfLine)
2849         *extraWidthToEndOfLine = width() - caretRect.maxX();
2850 
2851     return caretRect;
2852 }
2853 
2854 void RenderBlock::addFocusRingRectsForInlineChildren(Vector&lt;LayoutRect&gt;&amp;, const LayoutPoint&amp;, const RenderLayerModelObject*)
2855 {
2856     ASSERT_NOT_REACHED();
2857 }
2858 
2859 void RenderBlock::addFocusRingRects(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject* paintContainer)
2860 {
2861     // For blocks inside inlines, we include margins so that we run right up to the inline boxes
2862     // above and below us (thus getting merged with them to form a single irregular shape).
2863     auto* inlineContinuation = this-&gt;inlineContinuation();
2864     if (inlineContinuation) {
2865         // FIXME: This check really isn&#39;t accurate.
2866         bool nextInlineHasLineBox = inlineContinuation-&gt;firstLineBox();
2867         // FIXME: This is wrong. The principal renderer may not be the continuation preceding this block.
2868         // FIXME: This is wrong for block-flows that are horizontal.
2869         // https://bugs.webkit.org/show_bug.cgi?id=46781
2870         bool prevInlineHasLineBox = downcast&lt;RenderInline&gt;(*inlineContinuation-&gt;element()-&gt;renderer()).firstLineBox();
2871         auto topMargin = prevInlineHasLineBox ? collapsedMarginBefore() : 0_lu;
2872         auto bottomMargin = nextInlineHasLineBox ? collapsedMarginAfter() : 0_lu;
2873         LayoutRect rect(additionalOffset.x(), additionalOffset.y() - topMargin, width(), height() + topMargin + bottomMargin);
2874         if (!rect.isEmpty())
2875             rects.append(rect);
2876     } else if (width() &amp;&amp; height())
2877         rects.append(LayoutRect(additionalOffset, size()));
2878 
2879     if (!hasOverflowClip() &amp;&amp; !hasControlClip()) {
2880         if (childrenInline())
2881             addFocusRingRectsForInlineChildren(rects, additionalOffset, paintContainer);
2882 
2883         for (auto&amp; box : childrenOfType&lt;RenderBox&gt;(*this)) {
2884             if (is&lt;RenderListMarker&gt;(box))
2885                 continue;
2886 
2887             FloatPoint pos;
2888             // FIXME: This doesn&#39;t work correctly with transforms.
2889             if (box.layer())
2890                 pos = box.localToContainerPoint(FloatPoint(), paintContainer);
2891             else
2892                 pos = FloatPoint(additionalOffset.x() + box.x(), additionalOffset.y() + box.y());
2893             box.addFocusRingRects(rects, flooredLayoutPoint(pos), paintContainer);
2894         }
2895     }
2896 
2897     if (inlineContinuation)
2898         inlineContinuation-&gt;addFocusRingRects(rects, flooredLayoutPoint(LayoutPoint(additionalOffset + inlineContinuation-&gt;containingBlock()-&gt;location() - location())), paintContainer);
2899 }
2900 
2901 RenderPtr&lt;RenderBlock&gt; RenderBlock::createAnonymousBlockWithStyleAndDisplay(Document&amp; document, const RenderStyle&amp; style, DisplayType display)
2902 {
2903     // FIXME: Do we need to convert all our inline displays to block-type in the anonymous logic ?
2904     RenderPtr&lt;RenderBlock&gt; newBox;
2905     if (display == DisplayType::Flex || display == DisplayType::InlineFlex)
2906         newBox = createRenderer&lt;RenderFlexibleBox&gt;(document, RenderStyle::createAnonymousStyleWithDisplay(style, DisplayType::Flex));
2907     else
2908         newBox = createRenderer&lt;RenderBlockFlow&gt;(document, RenderStyle::createAnonymousStyleWithDisplay(style, DisplayType::Block));
2909 
2910     newBox-&gt;initializeStyle();
2911     return newBox;
2912 }
2913 
2914 LayoutUnit RenderBlock::offsetFromLogicalTopOfFirstPage() const
2915 {
2916     auto* layoutState = view().frameView().layoutContext().layoutState();
2917     if (layoutState &amp;&amp; !layoutState-&gt;isPaginated())
2918         return 0;
2919 
2920     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
2921     if (fragmentedFlow)
2922         return fragmentedFlow-&gt;offsetFromLogicalTopOfFirstFragment(this);
2923 
2924     if (layoutState) {
2925         ASSERT(layoutState-&gt;renderer() == this);
2926 
2927         LayoutSize offsetDelta = layoutState-&gt;layoutOffset() - layoutState-&gt;pageOffset();
2928         return isHorizontalWritingMode() ? offsetDelta.height() : offsetDelta.width();
2929     }
2930 
2931     ASSERT_NOT_REACHED();
2932     return 0;
2933 }
2934 
2935 RenderFragmentContainer* RenderBlock::fragmentAtBlockOffset(LayoutUnit blockOffset) const
2936 {
2937     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
2938     if (!fragmentedFlow || !fragmentedFlow-&gt;hasValidFragmentInfo())
2939         return 0;
2940 
2941     return fragmentedFlow-&gt;fragmentAtBlockOffset(this, offsetFromLogicalTopOfFirstPage() + blockOffset, true);
2942 }
2943 
2944 static bool canComputeFragmentRangeForBox(const RenderBlock&amp; parentBlock, const RenderBox&amp; childBox, const RenderFragmentedFlow* enclosingFragmentedFlow)
2945 {
2946     if (!enclosingFragmentedFlow)
2947         return false;
2948 
2949     if (!enclosingFragmentedFlow-&gt;hasFragments())
2950         return false;
2951 
2952     if (!childBox.canHaveOutsideFragmentRange())
2953         return false;
2954 
2955     return enclosingFragmentedFlow-&gt;hasCachedFragmentRangeForBox(parentBlock);
2956 }
2957 
2958 bool RenderBlock::childBoxIsUnsplittableForFragmentation(const RenderBox&amp; child) const
2959 {
2960     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
2961     bool checkColumnBreaks = fragmentedFlow &amp;&amp; fragmentedFlow-&gt;shouldCheckColumnBreaks();
2962     bool checkPageBreaks = !checkColumnBreaks &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;pageLogicalHeight();
2963     return child.isUnsplittableForPagination() || child.style().breakInside() == BreakInside::Avoid
2964         || (checkColumnBreaks &amp;&amp; child.style().breakInside() == BreakInside::AvoidColumn)
2965         || (checkPageBreaks &amp;&amp; child.style().breakInside() == BreakInside::AvoidPage);
2966 }
2967 
2968 void RenderBlock::computeFragmentRangeForBoxChild(const RenderBox&amp; box) const
2969 {
2970     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
2971     ASSERT(canComputeFragmentRangeForBox(*this, box, fragmentedFlow));
2972 
2973     RenderFragmentContainer* startFragment;
2974     RenderFragmentContainer* endFragment;
2975     LayoutUnit offsetFromLogicalTopOfFirstFragment = box.offsetFromLogicalTopOfFirstPage();
2976     if (childBoxIsUnsplittableForFragmentation(box))
2977         startFragment = endFragment = fragmentedFlow-&gt;fragmentAtBlockOffset(this, offsetFromLogicalTopOfFirstFragment, true);
2978     else {
2979         startFragment = fragmentedFlow-&gt;fragmentAtBlockOffset(this, offsetFromLogicalTopOfFirstFragment, true);
2980         endFragment = fragmentedFlow-&gt;fragmentAtBlockOffset(this, offsetFromLogicalTopOfFirstFragment + logicalHeightForChild(box), true);
2981     }
2982 
2983     fragmentedFlow-&gt;setFragmentRangeForBox(box, startFragment, endFragment);
2984 }
2985 
2986 void RenderBlock::estimateFragmentRangeForBoxChild(const RenderBox&amp; box) const
2987 {
2988     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
2989     if (!canComputeFragmentRangeForBox(*this, box, fragmentedFlow))
2990         return;
2991 
2992     if (childBoxIsUnsplittableForFragmentation(box)) {
2993         computeFragmentRangeForBoxChild(box);
2994         return;
2995     }
2996 
2997     auto estimatedValues = box.computeLogicalHeight(RenderFragmentedFlow::maxLogicalHeight(), logicalTopForChild(box));
2998     LayoutUnit offsetFromLogicalTopOfFirstFragment = box.offsetFromLogicalTopOfFirstPage();
2999     RenderFragmentContainer* startFragment = fragmentedFlow-&gt;fragmentAtBlockOffset(this, offsetFromLogicalTopOfFirstFragment, true);
3000     RenderFragmentContainer* endFragment = fragmentedFlow-&gt;fragmentAtBlockOffset(this, offsetFromLogicalTopOfFirstFragment + estimatedValues.m_extent, true);
3001 
3002     fragmentedFlow-&gt;setFragmentRangeForBox(box, startFragment, endFragment);
3003 }
3004 
3005 bool RenderBlock::updateFragmentRangeForBoxChild(const RenderBox&amp; box) const
3006 {
3007     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
3008     if (!canComputeFragmentRangeForBox(*this, box, fragmentedFlow))
3009         return false;
3010 
3011     RenderFragmentContainer* startFragment = nullptr;
3012     RenderFragmentContainer* endFragment = nullptr;
3013     fragmentedFlow-&gt;getFragmentRangeForBox(&amp;box, startFragment, endFragment);
3014 
3015     computeFragmentRangeForBoxChild(box);
3016 
3017     RenderFragmentContainer* newStartFragment = nullptr;
3018     RenderFragmentContainer* newEndFragment = nullptr;
3019     fragmentedFlow-&gt;getFragmentRangeForBox(&amp;box, newStartFragment, newEndFragment);
3020 
3021 
3022     // Changing the start fragment means we shift everything and a relayout is needed.
3023     if (newStartFragment != startFragment)
3024         return true;
3025 
3026     // The fragment range of the box has changed. Some boxes (e.g floats) may have been positioned assuming
3027     // a different range.
3028     if (box.needsLayoutAfterFragmentRangeChange() &amp;&amp; newEndFragment != endFragment)
3029         return true;
3030 
3031     return false;
3032 }
3033 
3034 LayoutUnit RenderBlock::collapsedMarginBeforeForChild(const RenderBox&amp; child) const
3035 {
3036     // If the child has the same directionality as we do, then we can just return its
3037     // collapsed margin.
3038     if (!child.isWritingModeRoot())
3039         return child.collapsedMarginBefore();
3040 
3041     // The child has a different directionality.  If the child is parallel, then it&#39;s just
3042     // flipped relative to us.  We can use the collapsed margin for the opposite edge.
3043     if (child.isHorizontalWritingMode() == isHorizontalWritingMode())
3044         return child.collapsedMarginAfter();
3045 
3046     // The child is perpendicular to us, which means its margins don&#39;t collapse but are on the
3047     // &quot;logical left/right&quot; sides of the child box.  We can just return the raw margin in this case.
3048     return marginBeforeForChild(child);
3049 }
3050 
3051 LayoutUnit RenderBlock::collapsedMarginAfterForChild(const RenderBox&amp; child) const
3052 {
3053     // If the child has the same directionality as we do, then we can just return its
3054     // collapsed margin.
3055     if (!child.isWritingModeRoot())
3056         return child.collapsedMarginAfter();
3057 
3058     // The child has a different directionality.  If the child is parallel, then it&#39;s just
3059     // flipped relative to us.  We can use the collapsed margin for the opposite edge.
3060     if (child.isHorizontalWritingMode() == isHorizontalWritingMode())
3061         return child.collapsedMarginBefore();
3062 
3063     // The child is perpendicular to us, which means its margins don&#39;t collapse but are on the
3064     // &quot;logical left/right&quot; side of the child box.  We can just return the raw margin in this case.
3065     return marginAfterForChild(child);
3066 }
3067 
3068 bool RenderBlock::hasMarginBeforeQuirk(const RenderBox&amp; child) const
3069 {
3070     // If the child has the same directionality as we do, then we can just return its
3071     // margin quirk.
3072     if (!child.isWritingModeRoot())
3073         return is&lt;RenderBlock&gt;(child) ? downcast&lt;RenderBlock&gt;(child).hasMarginBeforeQuirk() : child.style().hasMarginBeforeQuirk();
3074 
3075     // The child has a different directionality. If the child is parallel, then it&#39;s just
3076     // flipped relative to us. We can use the opposite edge.
3077     if (child.isHorizontalWritingMode() == isHorizontalWritingMode())
3078         return is&lt;RenderBlock&gt;(child) ? downcast&lt;RenderBlock&gt;(child).hasMarginAfterQuirk() : child.style().hasMarginAfterQuirk();
3079 
3080     // The child is perpendicular to us and box sides are never quirky in html.css, and we don&#39;t really care about
3081     // whether or not authors specified quirky ems, since they&#39;re an implementation detail.
3082     return false;
3083 }
3084 
3085 bool RenderBlock::hasMarginAfterQuirk(const RenderBox&amp; child) const
3086 {
3087     // If the child has the same directionality as we do, then we can just return its
3088     // margin quirk.
3089     if (!child.isWritingModeRoot())
3090         return is&lt;RenderBlock&gt;(child) ? downcast&lt;RenderBlock&gt;(child).hasMarginAfterQuirk() : child.style().hasMarginAfterQuirk();
3091 
3092     // The child has a different directionality. If the child is parallel, then it&#39;s just
3093     // flipped relative to us. We can use the opposite edge.
3094     if (child.isHorizontalWritingMode() == isHorizontalWritingMode())
3095         return is&lt;RenderBlock&gt;(child) ? downcast&lt;RenderBlock&gt;(child).hasMarginBeforeQuirk() : child.style().hasMarginBeforeQuirk();
3096 
3097     // The child is perpendicular to us and box sides are never quirky in html.css, and we don&#39;t really care about
3098     // whether or not authors specified quirky ems, since they&#39;re an implementation detail.
3099     return false;
3100 }
3101 
3102 const char* RenderBlock::renderName() const
3103 {
3104     if (isBody())
3105         return &quot;RenderBody&quot;; // FIXME: Temporary hack until we know that the regression tests pass.
3106     if (isFieldset())
3107         return &quot;RenderFieldSet&quot;; // FIXME: Remove eventually, but done to keep tests from breaking.
3108     if (isFloating())
3109         return &quot;RenderBlock (floating)&quot;;
3110     if (isOutOfFlowPositioned())
3111         return &quot;RenderBlock (positioned)&quot;;
3112     if (isAnonymousBlock())
3113         return &quot;RenderBlock (anonymous)&quot;;
3114     // FIXME: Temporary hack while the new generated content system is being implemented.
3115     if (isPseudoElement())
3116         return &quot;RenderBlock (generated)&quot;;
3117     if (isAnonymous())
3118         return &quot;RenderBlock (generated)&quot;;
3119     if (isRelativelyPositioned())
3120         return &quot;RenderBlock (relative positioned)&quot;;
3121     if (isStickilyPositioned())
3122         return &quot;RenderBlock (sticky positioned)&quot;;
3123     return &quot;RenderBlock&quot;;
3124 }
3125 
3126 TextRun RenderBlock::constructTextRun(StringView stringView, const RenderStyle&amp; style, ExpansionBehavior expansion, TextRunFlags flags)
3127 {
3128     auto textDirection = TextDirection::LTR;
3129     bool directionalOverride = style.rtlOrdering() == Order::Visual;
3130     if (flags != DefaultTextRunFlags) {
3131         if (flags &amp; RespectDirection)
3132             textDirection = style.direction();
3133         if (flags &amp; RespectDirectionOverride)
3134             directionalOverride |= isOverride(style.unicodeBidi());
3135     }
3136     return TextRun(stringView, 0, 0, expansion, textDirection, directionalOverride);
3137 }
3138 
3139 TextRun RenderBlock::constructTextRun(const String&amp; string, const RenderStyle&amp; style, ExpansionBehavior expansion, TextRunFlags flags)
3140 {
3141     return constructTextRun(StringView(string), style, expansion, flags);
3142 }
3143 
3144 TextRun RenderBlock::constructTextRun(const AtomString&amp; atomString, const RenderStyle&amp; style, ExpansionBehavior expansion, TextRunFlags flags)
3145 {
3146     return constructTextRun(StringView(atomString), style, expansion, flags);
3147 }
3148 
3149 TextRun RenderBlock::constructTextRun(const RenderText&amp; text, const RenderStyle&amp; style, ExpansionBehavior expansion)
3150 {
3151     return constructTextRun(text.stringView(), style, expansion);
3152 }
3153 
3154 TextRun RenderBlock::constructTextRun(const RenderText&amp; text, unsigned offset, unsigned length, const RenderStyle&amp; style, ExpansionBehavior expansion)
3155 {
3156     unsigned stop = offset + length;
3157     ASSERT(stop &lt;= text.text().length());
3158     return constructTextRun(text.stringView(offset, stop), style, expansion);
3159 }
3160 
3161 TextRun RenderBlock::constructTextRun(const LChar* characters, unsigned length, const RenderStyle&amp; style, ExpansionBehavior expansion)
3162 {
3163     return constructTextRun(StringView(characters, length), style, expansion);
3164 }
3165 
3166 TextRun RenderBlock::constructTextRun(const UChar* characters, unsigned length, const RenderStyle&amp; style, ExpansionBehavior expansion)
3167 {
3168     return constructTextRun(StringView(characters, length), style, expansion);
3169 }
3170 
3171 #if ASSERT_ENABLED
3172 void RenderBlock::checkPositionedObjectsNeedLayout()
3173 {
3174     auto* positionedDescendants = positionedObjects();
3175     if (!positionedDescendants)
3176         return;
3177 
3178     for (auto* renderer : *positionedDescendants)
3179         ASSERT(!renderer-&gt;needsLayout());
3180 }
3181 #endif // ASSERT_ENABLED
3182 
3183 bool RenderBlock::hasDefiniteLogicalHeight() const
3184 {
3185     return (bool)availableLogicalHeightForPercentageComputation();
3186 }
3187 
3188 Optional&lt;LayoutUnit&gt; RenderBlock::availableLogicalHeightForPercentageComputation() const
3189 {
3190     Optional&lt;LayoutUnit&gt; availableHeight;
3191 
3192     // For anonymous blocks that are skipped during percentage height calculation,
3193     // we consider them to have an indefinite height.
3194     if (skipContainingBlockForPercentHeightCalculation(*this, false))
3195         return availableHeight;
3196 
3197     const auto&amp; styleToUse = style();
3198 
3199     // A positioned element that specified both top/bottom or that specifies
3200     // height should be treated as though it has a height explicitly specified
3201     // that can be used for any percentage computations.
3202     bool isOutOfFlowPositionedWithSpecifiedHeight = isOutOfFlowPositioned() &amp;&amp; (!styleToUse.logicalHeight().isAuto() || (!styleToUse.logicalTop().isAuto() &amp;&amp; !styleToUse.logicalBottom().isAuto()));
3203 
3204     Optional&lt;LayoutUnit&gt; stretchedFlexHeight;
3205     if (isFlexItem())
3206         stretchedFlexHeight = downcast&lt;RenderFlexibleBox&gt;(parent())-&gt;childLogicalHeightForPercentageResolution(*this);
3207 
3208     if (stretchedFlexHeight)
3209         availableHeight = stretchedFlexHeight;
3210     else if (isGridItem() &amp;&amp; hasOverrideContentLogicalHeight())
3211         availableHeight = overrideContentLogicalHeight();
3212     else if (styleToUse.logicalHeight().isFixed()) {
3213         LayoutUnit contentBoxHeight = adjustContentBoxLogicalHeightForBoxSizing((LayoutUnit)styleToUse.logicalHeight().value());
3214         availableHeight = std::max(0_lu, constrainContentBoxLogicalHeightByMinMax(contentBoxHeight - scrollbarLogicalHeight(), WTF::nullopt));
3215     } else if (styleToUse.logicalHeight().isPercentOrCalculated() &amp;&amp; !isOutOfFlowPositionedWithSpecifiedHeight) {
3216         Optional&lt;LayoutUnit&gt; heightWithScrollbar = computePercentageLogicalHeight(styleToUse.logicalHeight());
3217         if (heightWithScrollbar) {
3218             LayoutUnit contentBoxHeightWithScrollbar = adjustContentBoxLogicalHeightForBoxSizing(heightWithScrollbar.value());
3219             // We need to adjust for min/max height because this method does not
3220             // handle the min/max of the current block, its caller does. So the
3221             // return value from the recursive call will not have been adjusted
3222             // yet.
3223             LayoutUnit contentBoxHeight = constrainContentBoxLogicalHeightByMinMax(contentBoxHeightWithScrollbar - scrollbarLogicalHeight(), WTF::nullopt);
3224             availableHeight = std::max(0_lu, contentBoxHeight);
3225         }
3226     } else if (isOutOfFlowPositionedWithSpecifiedHeight) {
3227         // Don&#39;t allow this to affect the block&#39; size() member variable, since this
3228         // can get called while the block is still laying out its kids.
3229         LogicalExtentComputedValues computedValues = computeLogicalHeight(logicalHeight(), 0_lu);
3230         availableHeight = computedValues.m_extent - borderAndPaddingLogicalHeight() - scrollbarLogicalHeight();
3231     } else if (isRenderView())
3232         availableHeight = view().pageOrViewLogicalHeight();
3233 
3234     return availableHeight;
3235 }
3236 
3237 void RenderBlock::layoutExcludedChildren(bool relayoutChildren)
3238 {
3239     if (!isFieldset())
3240         return;
3241 
3242     setIntrinsicBorderForFieldset(0);
3243 
3244     RenderBox* box = findFieldsetLegend();
3245     if (!box)
3246         return;
3247 
3248     box-&gt;setIsExcludedFromNormalLayout(true);
3249     for (auto&amp; child : childrenOfType&lt;RenderBox&gt;(*this)) {
3250         if (&amp;child == box || !child.isLegend())
3251             continue;
3252         child.setIsExcludedFromNormalLayout(false);
3253     }
3254 
3255     RenderBox&amp; legend = *box;
3256     if (relayoutChildren)
3257         legend.setChildNeedsLayout(MarkOnlyThis);
3258     legend.layoutIfNeeded();
3259 
3260     LayoutUnit logicalLeft;
3261     if (style().isLeftToRightDirection()) {
3262         switch (legend.style().textAlign()) {
3263         case TextAlignMode::Center:
3264             logicalLeft = (logicalWidth() - logicalWidthForChild(legend)) / 2;
3265             break;
3266         case TextAlignMode::Right:
3267             logicalLeft = logicalWidth() - borderEnd() - paddingEnd() - logicalWidthForChild(legend);
3268             break;
3269         default:
3270             logicalLeft = borderStart() + paddingStart() + marginStartForChild(legend);
3271             break;
3272         }
3273     } else {
3274         switch (legend.style().textAlign()) {
3275         case TextAlignMode::Left:
3276             logicalLeft = borderStart() + paddingStart();
3277             break;
3278         case TextAlignMode::Center: {
3279             // Make sure that the extra pixel goes to the end side in RTL (since it went to the end side
3280             // in LTR).
3281             LayoutUnit centeredWidth = logicalWidth() - logicalWidthForChild(legend);
3282             logicalLeft = centeredWidth - centeredWidth / 2;
3283             break;
3284         }
3285         default:
3286             logicalLeft = logicalWidth() - borderStart() - paddingStart() - marginStartForChild(legend) - logicalWidthForChild(legend);
3287             break;
3288         }
3289     }
3290 
3291     setLogicalLeftForChild(legend, logicalLeft);
3292 
3293     LayoutUnit fieldsetBorderBefore = borderBefore();
3294     LayoutUnit legendLogicalHeight = logicalHeightForChild(legend);
3295     LayoutUnit legendAfterMargin = marginAfterForChild(legend);
3296     LayoutUnit topPositionForLegend = std::max(0_lu, (fieldsetBorderBefore - legendLogicalHeight) / 2);
3297     LayoutUnit bottomPositionForLegend = topPositionForLegend + legendLogicalHeight + legendAfterMargin;
3298 
3299     // Place the legend now.
3300     setLogicalTopForChild(legend, topPositionForLegend);
3301 
3302     // If the bottom of the legend (including its after margin) is below the fieldset border,
3303     // then we need to add in sufficient intrinsic border to account for this gap.
3304     // FIXME: Should we support the before margin of the legend? Not entirely clear.
3305     // FIXME: Consider dropping support for the after margin of the legend. Not sure other
3306     // browsers support that anyway.
3307     if (bottomPositionForLegend &gt; fieldsetBorderBefore)
3308         setIntrinsicBorderForFieldset(bottomPositionForLegend - fieldsetBorderBefore);
3309 
3310     // Now that the legend is included in the border extent, we can set our logical height
3311     // to the borderBefore (which includes the legend and its after margin if they were bigger
3312     // than the actual fieldset border) and then add in our padding before.
3313     setLogicalHeight(borderBefore() + paddingBefore());
3314 }
3315 
3316 RenderBox* RenderBlock::findFieldsetLegend(FieldsetFindLegendOption option) const
3317 {
3318     for (auto&amp; legend : childrenOfType&lt;RenderBox&gt;(*this)) {
3319         if (option == FieldsetIgnoreFloatingOrOutOfFlow &amp;&amp; legend.isFloatingOrOutOfFlowPositioned())
3320             continue;
3321         if (legend.isLegend())
3322             return const_cast&lt;RenderBox*&gt;(&amp;legend);
3323     }
3324     return nullptr;
3325 }
3326 
3327 void RenderBlock::adjustBorderBoxRectForPainting(LayoutRect&amp; paintRect)
3328 {
3329     if (!isFieldset() || !intrinsicBorderForFieldset())
3330         return;
3331 
3332     auto* legend = findFieldsetLegend();
3333     if (!legend)
3334         return;
3335 
3336     if (style().isHorizontalWritingMode()) {
3337         LayoutUnit yOff = std::max(0_lu, (legend-&gt;height() - RenderBox::borderBefore()) / 2);
3338         paintRect.setHeight(paintRect.height() - yOff);
3339         if (style().writingMode() == TopToBottomWritingMode)
3340             paintRect.setY(paintRect.y() + yOff);
3341     } else {
3342         LayoutUnit xOff = std::max(0_lu, (legend-&gt;width() - RenderBox::borderBefore()) / 2);
3343         paintRect.setWidth(paintRect.width() - xOff);
3344         if (style().writingMode() == LeftToRightWritingMode)
3345             paintRect.setX(paintRect.x() + xOff);
3346     }
3347 }
3348 
3349 LayoutRect RenderBlock::paintRectToClipOutFromBorder(const LayoutRect&amp; paintRect)
3350 {
3351     LayoutRect clipRect;
3352     if (!isFieldset())
3353         return clipRect;
3354     auto* legend = findFieldsetLegend();
3355     if (!legend)
3356         return clipRect;
3357 
3358     LayoutUnit borderExtent = RenderBox::borderBefore();
3359     if (style().isHorizontalWritingMode()) {
3360         clipRect.setX(paintRect.x() + legend-&gt;x());
3361         clipRect.setY(style().writingMode() == TopToBottomWritingMode ? paintRect.y() : paintRect.y() + paintRect.height() - borderExtent);
3362         clipRect.setWidth(legend-&gt;width());
3363         clipRect.setHeight(borderExtent);
3364     } else {
3365         clipRect.setX(style().writingMode() == LeftToRightWritingMode ? paintRect.x() : paintRect.x() + paintRect.width() - borderExtent);
3366         clipRect.setY(paintRect.y() + legend-&gt;y());
3367         clipRect.setWidth(borderExtent);
3368         clipRect.setHeight(legend-&gt;height());
3369     }
3370     return clipRect;
3371 }
3372 
3373 LayoutUnit RenderBlock::intrinsicBorderForFieldset() const
3374 {
3375     auto* rareData = getBlockRareData(*this);
3376     return rareData ? rareData-&gt;m_intrinsicBorderForFieldset : 0_lu;
3377 }
3378 
3379 void RenderBlock::setIntrinsicBorderForFieldset(LayoutUnit padding)
3380 {
3381     auto* rareData = getBlockRareData(*this);
3382     if (!rareData) {
3383         if (!padding)
3384             return;
3385         rareData = &amp;ensureBlockRareData(*this);
3386     }
3387     rareData-&gt;m_intrinsicBorderForFieldset = padding;
3388 }
3389 
3390 LayoutUnit RenderBlock::borderTop() const
3391 {
3392     if (style().writingMode() != TopToBottomWritingMode || !intrinsicBorderForFieldset())
3393         return RenderBox::borderTop();
3394     return RenderBox::borderTop() + intrinsicBorderForFieldset();
3395 }
3396 
3397 LayoutUnit RenderBlock::borderLeft() const
3398 {
3399     if (style().writingMode() != LeftToRightWritingMode || !intrinsicBorderForFieldset())
3400         return RenderBox::borderLeft();
3401     return RenderBox::borderLeft() + intrinsicBorderForFieldset();
3402 }
3403 
3404 LayoutUnit RenderBlock::borderBottom() const
3405 {
3406     if (style().writingMode() != BottomToTopWritingMode || !intrinsicBorderForFieldset())
3407         return RenderBox::borderBottom();
3408     return RenderBox::borderBottom() + intrinsicBorderForFieldset();
3409 }
3410 
3411 LayoutUnit RenderBlock::borderRight() const
3412 {
3413     if (style().writingMode() != RightToLeftWritingMode || !intrinsicBorderForFieldset())
3414         return RenderBox::borderRight();
3415     return RenderBox::borderRight() + intrinsicBorderForFieldset();
3416 }
3417 
3418 LayoutUnit RenderBlock::borderBefore() const
3419 {
3420     return RenderBox::borderBefore() + intrinsicBorderForFieldset();
3421 }
3422 
3423 bool RenderBlock::computePreferredWidthsForExcludedChildren(LayoutUnit&amp; minWidth, LayoutUnit&amp; maxWidth) const
3424 {
3425     if (!isFieldset())
3426         return false;
3427 
3428     auto* legend = findFieldsetLegend();
3429     if (!legend)
3430         return false;
3431 
3432     legend-&gt;setIsExcludedFromNormalLayout(true);
3433 
3434     computeChildPreferredLogicalWidths(*legend, minWidth, maxWidth);
3435 
3436     // These are going to be added in later, so we subtract them out to reflect the
3437     // fact that the legend is outside the scrollable area.
3438     auto scrollbarWidth = intrinsicScrollbarLogicalWidth();
3439     minWidth -= scrollbarWidth;
3440     maxWidth -= scrollbarWidth;
3441 
3442     const auto&amp; childStyle = legend-&gt;style();
3443     auto startMarginLength = childStyle.marginStartUsing(&amp;style());
3444     auto endMarginLength = childStyle.marginEndUsing(&amp;style());
3445     LayoutUnit margin;
3446     LayoutUnit marginStart;
3447     LayoutUnit marginEnd;
3448     if (startMarginLength.isFixed())
3449         marginStart += startMarginLength.value();
3450     if (endMarginLength.isFixed())
3451         marginEnd += endMarginLength.value();
3452     margin = marginStart + marginEnd;
3453 
3454     minWidth += margin;
3455     maxWidth += margin;
3456 
3457     return true;
3458 }
3459 
3460 LayoutUnit RenderBlock::adjustBorderBoxLogicalHeightForBoxSizing(LayoutUnit height) const
3461 {
3462     // FIXME: We&#39;re doing this to match other browsers even though it&#39;s questionable.
3463     // Shouldn&#39;t height:100px mean the fieldset content gets 100px of height even if the
3464     // resulting fieldset becomes much taller because of the legend?
3465     LayoutUnit bordersPlusPadding = borderAndPaddingLogicalHeight();
3466     if (style().boxSizing() == BoxSizing::ContentBox)
3467         return height + bordersPlusPadding - intrinsicBorderForFieldset();
3468     return std::max(height, bordersPlusPadding);
3469 }
3470 
3471 LayoutUnit RenderBlock::adjustContentBoxLogicalHeightForBoxSizing(Optional&lt;LayoutUnit&gt; height) const
3472 {
3473     // FIXME: We&#39;re doing this to match other browsers even though it&#39;s questionable.
3474     // Shouldn&#39;t height:100px mean the fieldset content gets 100px of height even if the
3475     // resulting fieldset becomes much taller because of the legend?
3476     if (!height)
3477         return 0;
3478     LayoutUnit result = height.value();
3479     if (style().boxSizing() == BoxSizing::BorderBox)
3480         result -= borderAndPaddingLogicalHeight();
3481     else
3482         result -= intrinsicBorderForFieldset();
3483     return std::max(0_lu, result);
3484 }
3485 
3486 void RenderBlock::paintExcludedChildrenInBorder(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
3487 {
3488     if (!isFieldset())
3489         return;
3490 
3491     RenderBox* box = findFieldsetLegend();
3492     if (!box || !box-&gt;isExcludedFromNormalLayout() || box-&gt;hasSelfPaintingLayer())
3493         return;
3494 
3495     LayoutPoint childPoint = flipForWritingModeForChild(box, paintOffset);
3496     box-&gt;paintAsInlineBlock(paintInfo, childPoint);
3497 }
3498 
3499 bool RenderBlock::hitTestExcludedChildrenInBorder(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
3500 {
3501     if (!isFieldset())
3502         return false;
3503 
3504     auto* legend = findFieldsetLegend();
3505     if (!legend || !legend-&gt;isExcludedFromNormalLayout() || legend-&gt;hasSelfPaintingLayer())
3506         return false;
3507 
3508     HitTestAction childHitTest = hitTestAction;
3509     if (hitTestAction == HitTestChildBlockBackgrounds)
3510         childHitTest = HitTestChildBlockBackground;
3511     LayoutPoint childPoint = flipForWritingModeForChild(legend, accumulatedOffset);
3512     return legend-&gt;nodeAtPoint(request, result, locationInContainer, childPoint, childHitTest);
3513 }
3514 
3515 } // namespace WebCore
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2003, 2009, 2012, 2015 Apple Inc. All rights reserved.
   3  *
   4  * Portions are Copyright (C) 1998 Netscape Communications Corporation.
   5  *
   6  * Other contributors:
   7  *   Robert O&#39;Callahan &lt;roc+@cs.cmu.edu&gt;
   8  *   David Baron &lt;dbaron@fas.harvard.edu&gt;
   9  *   Christian Biesinger &lt;cbiesinger@web.de&gt;
  10  *   Randall Jesup &lt;rjesup@wgate.com&gt;
  11  *   Roland Mainz &lt;roland.mainz@informatik.med.uni-giessen.de&gt;
  12  *   Josh Soref &lt;timeless@mac.com&gt;
  13  *   Boris Zbarsky &lt;bzbarsky@mit.edu&gt;
  14  *
  15  * This library is free software; you can redistribute it and/or
  16  * modify it under the terms of the GNU Lesser General Public
  17  * License as published by the Free Software Foundation; either
  18  * version 2.1 of the License, or (at your option) any later version.
  19  *
  20  * This library is distributed in the hope that it will be useful,
  21  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  22  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  23  * Lesser General Public License for more details.
  24  *
  25  * You should have received a copy of the GNU Lesser General Public
  26  * License along with this library; if not, write to the Free Software
  27  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  28  *
  29  * Alternatively, the contents of this file may be used under the terms
  30  * of either the Mozilla Public License Version 1.1, found at
  31  * http://www.mozilla.org/MPL/ (the &quot;MPL&quot;) or the GNU General Public
  32  * License Version 2.0, found at http://www.fsf.org/copyleft/gpl.html
  33  * (the &quot;GPL&quot;), in which case the provisions of the MPL or the GPL are
  34  * applicable instead of those above.  If you wish to allow use of your
  35  * version of this file only under the terms of one of those two
  36  * licenses (the MPL or the GPL) and not to allow others to use your
  37  * version of this file under the LGPL, indicate your decision by
  38  * deletingthe provisions above and replace them with the notice and
  39  * other provisions required by the MPL or the GPL, as the case may be.
  40  * If you do not delete the provisions above, a recipient may use your
  41  * version of this file under any of the LGPL, the MPL or the GPL.
  42  */
  43 
  44 #pragma once
  45 
  46 #include &quot;ClipRect.h&quot;
  47 #include &quot;GraphicsLayer.h&quot;
  48 #include &quot;LayerFragment.h&quot;
  49 #include &quot;PaintFrequencyTracker.h&quot;
  50 #include &quot;PaintInfo.h&quot;
  51 #include &quot;RenderBox.h&quot;
  52 #include &quot;RenderPtr.h&quot;
  53 #include &quot;ScrollableArea.h&quot;
  54 #include &lt;memory&gt;
  55 #include &lt;wtf/WeakPtr.h&gt;
  56 
  57 namespace WTF {
  58 class TextStream;
  59 }
  60 
  61 namespace WebCore {
  62 
  63 class CSSFilter;
  64 class ClipRects;
  65 class ClipRectsCache;
  66 class EventRegionContext;
  67 class HitTestRequest;
  68 class HitTestResult;
  69 class HitTestingTransformState;
  70 class Region;
  71 class RenderFragmentedFlow;
  72 class RenderGeometryMap;
  73 class RenderLayerBacking;
  74 class RenderLayerCompositor;
  75 class RenderLayerFilters;
  76 class RenderMarquee;
  77 class RenderReplica;
  78 class RenderScrollbarPart;
  79 class RenderStyle;
  80 class RenderView;
  81 class Scrollbar;
  82 class TransformationMatrix;
  83 
  84 enum BorderRadiusClippingRule { IncludeSelfForBorderRadius, DoNotIncludeSelfForBorderRadius };
  85 enum IncludeSelfOrNot { IncludeSelf, ExcludeSelf };
  86 
  87 enum RepaintStatus {
  88     NeedsNormalRepaint,
  89     NeedsFullRepaint,
  90     NeedsFullRepaintForPositionedMovementLayout
  91 };
  92 
  93 enum ClipRectsType {
  94     PaintingClipRects, // Relative to painting ancestor. Used for painting.
  95     RootRelativeClipRects, // Relative to the ancestor treated as the root (e.g. transformed layer). Used for hit testing.
  96     AbsoluteClipRects, // Relative to the RenderView&#39;s layer. Used for compositing overlap testing.
  97     NumCachedClipRectsTypes,
  98     AllClipRectTypes,
  99     TemporaryClipRects
 100 };
 101 
 102 enum ShouldRespectOverflowClip {
 103     IgnoreOverflowClip,
 104     RespectOverflowClip
 105 };
 106 
 107 enum ShouldApplyRootOffsetToFragments {
 108     ApplyRootOffsetToFragments,
 109     IgnoreRootOffsetForFragments
 110 };
 111 
 112 enum class RequestState {
 113     Unknown,
 114     DontCare,
 115     False,
 116     True,
 117     Undetermined
 118 };
 119 
 120 enum class IndirectCompositingReason {
 121     None,
 122     Clipping,
 123     Stacking,
 124     OverflowScrollPositioning,
 125     Overlap,
 126     BackgroundLayer,
 127     GraphicalEffect, // opacity, mask, filter, transform etc.
 128     Perspective,
 129     Preserve3D
 130 };
 131 
 132 struct ScrollRectToVisibleOptions {
 133     SelectionRevealMode revealMode { SelectionRevealMode::Reveal };
 134     const ScrollAlignment&amp; alignX { ScrollAlignment::alignCenterIfNeeded };
 135     const ScrollAlignment&amp; alignY { ScrollAlignment::alignCenterIfNeeded };
 136     ShouldAllowCrossOriginScrolling shouldAllowCrossOriginScrolling { ShouldAllowCrossOriginScrolling::No };
 137 };
 138 
 139 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(RenderLayer);
 140 class RenderLayer final : public ScrollableArea {
 141     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(RenderLayer);
 142 public:
 143     friend class RenderReplica;
 144     friend class RenderLayerFilters;
 145     friend class RenderLayerBacking;
 146     friend class RenderLayerCompositor;
 147 
 148     explicit RenderLayer(RenderLayerModelObject&amp;);
 149     virtual ~RenderLayer();
 150 
 151 #if PLATFORM(IOS_FAMILY)
 152     // Called before the renderer&#39;s widget (if any) has been nulled out.
 153     void willBeDestroyed();
 154 #endif
 155     String name() const;
 156 
 157     Page&amp; page() const { return renderer().page(); }
 158     RenderLayerModelObject&amp; renderer() const { return m_renderer; }
 159     RenderBox* renderBox() const { return is&lt;RenderBox&gt;(renderer()) ? &amp;downcast&lt;RenderBox&gt;(renderer()) : nullptr; }
 160 
 161     RenderLayer* parent() const { return m_parent; }
 162     RenderLayer* previousSibling() const { return m_previous; }
 163     RenderLayer* nextSibling() const { return m_next; }
 164     RenderLayer* firstChild() const { return m_first; }
 165     RenderLayer* lastChild() const { return m_last; }
 166     bool isDescendantOf(const RenderLayer&amp;) const;
 167     RenderLayer* commonAncestorWithLayer(const RenderLayer&amp;) const;
 168 
 169     // This does an ancestor tree walk. Avoid it!
 170     const RenderLayer* root() const
 171     {
 172         const RenderLayer* curr = this;
 173         while (curr-&gt;parent())
 174             curr = curr-&gt;parent();
 175         return curr;
 176     }
 177 
 178     void addChild(RenderLayer&amp; newChild, RenderLayer* beforeChild = nullptr);
 179     void removeChild(RenderLayer&amp;);
 180 
 181     enum class LayerChangeTiming {
 182         StyleChange,
 183         RenderTreeConstruction,
 184     };
 185     void insertOnlyThisLayer(LayerChangeTiming);
 186     void removeOnlyThisLayer(LayerChangeTiming);
 187 
 188     bool isNormalFlowOnly() const { return m_isNormalFlowOnly; }
 189 
 190     // isStackingContext is true for layers that we&#39;ve determined should be stacking contexts for painting.
 191     // Not all stacking contexts are CSS stacking contexts.
 192     bool isStackingContext() const { return isCSSStackingContext() || m_isOpportunisticStackingContext; }
 193 
 194     // isCSSStackingContext is true for layers that are stacking contexts from a CSS perspective.
 195     // isCSSStackingContext() =&gt; isStackingContext().
 196     // FIXME: m_forcedStackingContext should affect isStackingContext(), not isCSSStackingContext(), but doing so breaks media control mix-blend-mode.
 197     bool isCSSStackingContext() const { return m_isCSSStackingContext || m_forcedStackingContext; }
 198 
 199     // Gets the enclosing stacking context for this layer, excluding this layer itself.
 200     RenderLayer* stackingContext() const;
 201 
 202     // Gets the enclosing stacking container for this layer, possibly the layer
 203     // itself, if it is a stacking container.
 204     RenderLayer* enclosingStackingContext() { return isStackingContext() ? this : stackingContext(); }
 205 
 206     RenderLayer* paintOrderParent() const;
 207 
 208     void dirtyNormalFlowList();
 209     void dirtyZOrderLists();
 210     void dirtyStackingContextZOrderLists();
 211 
 212     bool normalFlowListDirty() const { return m_normalFlowListDirty; }
 213     bool zOrderListsDirty() const { return m_zOrderListsDirty; }
 214 
 215 #if ASSERT_ENABLED
 216     bool layerListMutationAllowed() const { return m_layerListMutationAllowed; }
 217     void setLayerListMutationAllowed(bool flag) { m_layerListMutationAllowed = flag; }
 218 #endif
 219 
 220 private:
 221     // These flags propagate in paint order (z-order tree).
 222     enum class Compositing {
 223         HasDescendantNeedingRequirementsTraversal           = 1 &lt;&lt; 0, // Need to do the overlap-testing tree walk because hierarchy or geometry changed.
 224         HasDescendantNeedingBackingOrHierarchyTraversal     = 1 &lt;&lt; 1, // Need to update geometry, configuration and update the GraphicsLayer tree.
 225 
 226         // Things that trigger HasDescendantNeedingRequirementsTraversal
 227         NeedsPaintOrderChildrenUpdate                       = 1 &lt;&lt; 2, // The paint order children of this layer changed (gained/lost child, order change).
 228         NeedsPostLayoutUpdate                               = 1 &lt;&lt; 3, // Needs compositing to be re-evaluated after layout (it depends on geometry).
 229         DescendantsNeedRequirementsTraversal                = 1 &lt;&lt; 4, // Something changed that forces computeCompositingRequirements to traverse all descendant layers.
 230         SubsequentLayersNeedRequirementsTraversal           = 1 &lt;&lt; 5, // Something changed that forces computeCompositingRequirements to traverse all layers later in paint order.
 231 
 232         // Things that trigger HasDescendantNeedingBackingOrHierarchyTraversal
 233         NeedsGeometryUpdate                                 = 1 &lt;&lt; 6, // This layer needs a geometry update.
 234         NeedsConfigurationUpdate                            = 1 &lt;&lt; 7, // This layer needs a configuration update (updating its internal compositing hierarchy).
 235         NeedsScrollingTreeUpdate                            = 1 &lt;&lt; 8, // Something changed that requires this layer&#39;s scrolling tree node to be updated.
 236         NeedsLayerConnection                                = 1 &lt;&lt; 9, // This layer needs hookup with its parents or children.
 237         ChildrenNeedGeometryUpdate                          = 1 &lt;&lt; 10, // This layer&#39;s composited children need a geometry update.
 238         DescendantsNeedBackingAndHierarchyTraversal         = 1 &lt;&lt; 11, // Something changed that forces us to traverse all descendant layers in updateBackingAndHierarchy.
 239     };
 240 
 241     static constexpr OptionSet&lt;Compositing&gt; computeCompositingRequirementsFlags()
 242     {
 243         return {
 244             Compositing::NeedsPaintOrderChildrenUpdate,
 245             Compositing::NeedsPostLayoutUpdate,
 246             Compositing::DescendantsNeedRequirementsTraversal,
 247             Compositing::SubsequentLayersNeedRequirementsTraversal,
 248         };
 249     }
 250 
 251     static constexpr OptionSet&lt;Compositing&gt; updateBackingOrHierarchyFlags()
 252     {
 253         return {
 254             Compositing::NeedsLayerConnection,
 255             Compositing::NeedsGeometryUpdate,
 256             Compositing::NeedsConfigurationUpdate,
 257             Compositing::NeedsScrollingTreeUpdate,
 258             Compositing::ChildrenNeedGeometryUpdate,
 259             Compositing::DescendantsNeedBackingAndHierarchyTraversal,
 260         };
 261     }
 262 
 263     void setAncestorsHaveCompositingDirtyFlag(Compositing);
 264 
 265 public:
 266     bool hasDescendantNeedingCompositingRequirementsTraversal() const { return m_compositingDirtyBits.contains(Compositing::HasDescendantNeedingRequirementsTraversal); }
 267     bool hasDescendantNeedingUpdateBackingOrHierarchyTraversal() const { return m_compositingDirtyBits.contains(Compositing::HasDescendantNeedingBackingOrHierarchyTraversal); }
 268 
 269     bool needsCompositingPaintOrderChildrenUpdate() const { return m_compositingDirtyBits.contains(Compositing::NeedsPaintOrderChildrenUpdate); }
 270     bool needsPostLayoutCompositingUpdate() const { return m_compositingDirtyBits.contains(Compositing::NeedsPostLayoutUpdate); }
 271     bool descendantsNeedCompositingRequirementsTraversal() const { return m_compositingDirtyBits.contains(Compositing::DescendantsNeedRequirementsTraversal); }
 272     bool subsequentLayersNeedCompositingRequirementsTraversal() const { return m_compositingDirtyBits.contains(Compositing::SubsequentLayersNeedRequirementsTraversal); }
 273 
 274     bool needsCompositingLayerConnection() const { return m_compositingDirtyBits.contains(Compositing::NeedsLayerConnection); }
 275     bool needsCompositingGeometryUpdate() const { return m_compositingDirtyBits.contains(Compositing::NeedsGeometryUpdate); }
 276     bool needsCompositingConfigurationUpdate() const { return m_compositingDirtyBits.contains(Compositing::NeedsConfigurationUpdate); }
 277     bool needsScrollingTreeUpdate() const { return m_compositingDirtyBits.contains(Compositing::NeedsScrollingTreeUpdate); }
 278     bool childrenNeedCompositingGeometryUpdate() const { return m_compositingDirtyBits.contains(Compositing::ChildrenNeedGeometryUpdate); }
 279     bool descendantsNeedUpdateBackingAndHierarchyTraversal() const { return m_compositingDirtyBits.contains(Compositing::DescendantsNeedBackingAndHierarchyTraversal); }
 280 
 281     template&lt;Compositing V&gt;
 282     void setRequirementsTraversalDirtyBit()
 283     {
 284         m_compositingDirtyBits.add(V);
 285         setAncestorsHaveCompositingDirtyFlag(Compositing::HasDescendantNeedingRequirementsTraversal);
 286     }
 287 
 288     void setNeedsCompositingPaintOrderChildrenUpdate() { setRequirementsTraversalDirtyBit&lt;Compositing::NeedsPaintOrderChildrenUpdate&gt;(); }
 289     void setNeedsPostLayoutCompositingUpdate() { setRequirementsTraversalDirtyBit&lt;Compositing::NeedsPostLayoutUpdate&gt;(); }
 290     void setDescendantsNeedCompositingRequirementsTraversal() { setRequirementsTraversalDirtyBit&lt;Compositing::DescendantsNeedRequirementsTraversal&gt;(); }
 291     void setSubsequentLayersNeedCompositingRequirementsTraversal() { setRequirementsTraversalDirtyBit&lt;Compositing::SubsequentLayersNeedRequirementsTraversal&gt;(); }
 292 
 293     void setNeedsPostLayoutCompositingUpdateOnAncestors() { setAncestorsHaveCompositingDirtyFlag(Compositing::NeedsPostLayoutUpdate); }
 294 
 295     template&lt;Compositing V&gt;
 296     void setBackingAndHierarchyTraversalDirtyBit()
 297     {
 298         m_compositingDirtyBits.add(V);
 299         setAncestorsHaveCompositingDirtyFlag(Compositing::HasDescendantNeedingBackingOrHierarchyTraversal);
 300     }
 301 
 302     void setNeedsCompositingLayerConnection() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::NeedsLayerConnection&gt;(); }
 303     void setNeedsCompositingGeometryUpdate() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::NeedsGeometryUpdate&gt;(); }
 304     void setNeedsCompositingConfigurationUpdate() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::NeedsConfigurationUpdate&gt;(); }
 305     void setNeedsScrollingTreeUpdate() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::NeedsScrollingTreeUpdate&gt;(); }
 306     void setChildrenNeedCompositingGeometryUpdate() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::ChildrenNeedGeometryUpdate&gt;(); }
 307     void setDescendantsNeedUpdateBackingAndHierarchyTraversal() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::DescendantsNeedBackingAndHierarchyTraversal&gt;(); }
 308 
 309     void setNeedsCompositingGeometryUpdateOnAncestors() { setAncestorsHaveCompositingDirtyFlag(Compositing::NeedsGeometryUpdate); }
 310 
 311     bool needsCompositingRequirementsTraversal() const { return m_compositingDirtyBits.containsAny(computeCompositingRequirementsFlags()); }
 312     void clearCompositingRequirementsTraversalState()
 313     {
 314         m_compositingDirtyBits.remove(Compositing::HasDescendantNeedingRequirementsTraversal);
 315         m_compositingDirtyBits.remove(computeCompositingRequirementsFlags());
 316     }
 317 
 318     bool needsUpdateBackingOrHierarchyTraversal() const { return m_compositingDirtyBits.containsAny(updateBackingOrHierarchyFlags()); }
 319     void clearUpdateBackingOrHierarchyTraversalState()
 320     {
 321         m_compositingDirtyBits.remove(Compositing::HasDescendantNeedingBackingOrHierarchyTraversal);
 322         m_compositingDirtyBits.remove(updateBackingOrHierarchyFlags());
 323     }
 324 
 325     bool needsAnyCompositingTraversal() const { return !m_compositingDirtyBits.isEmpty(); }
 326     void clearCompositingPaintOrderState() { m_compositingDirtyBits = { }; }
 327 
 328     class LayerList {
 329         friend class RenderLayer;
 330     public:
 331         using iterator = RenderLayer**;
 332         using const_iterator = RenderLayer * const *;
 333         using reverse_iterator = std::reverse_iterator&lt;iterator&gt;;
 334         using const_reverse_iterator = std::reverse_iterator&lt;const_iterator&gt;;
 335 
 336         iterator begin() { return m_layerList ? m_layerList-&gt;begin() : nullptr; }
 337         iterator end() { return m_layerList ? m_layerList-&gt;end() : nullptr; }
 338 
 339         reverse_iterator rbegin() { return reverse_iterator(end()); }
 340         reverse_iterator rend() { return reverse_iterator(begin()); }
 341 
 342         const_iterator begin() const { return m_layerList ? m_layerList-&gt;begin() : nullptr; }
 343         const_iterator end() const { return m_layerList ? m_layerList-&gt;end() : nullptr; }
 344 
 345         const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }
 346         const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }
 347 
 348         size_t size() const { return m_layerList ? m_layerList-&gt;size() : 0; }
 349 
 350     private:
 351         LayerList(Vector&lt;RenderLayer*&gt;* layerList)
 352             : m_layerList(layerList)
 353         {
 354         }
 355 
 356         Vector&lt;RenderLayer*&gt;* m_layerList;
 357     };
 358 
 359     LayerList normalFlowLayers() const
 360     {
 361         ASSERT(!m_normalFlowListDirty);
 362         return LayerList(m_normalFlowList.get());
 363     }
 364 
 365     LayerList positiveZOrderLayers() const
 366     {
 367         ASSERT(!m_zOrderListsDirty);
 368         ASSERT(isStackingContext() || !m_posZOrderList);
 369         return LayerList(m_posZOrderList.get());
 370     }
 371 
 372     bool hasNegativeZOrderLayers() const
 373     {
 374         return m_negZOrderList &amp;&amp; m_negZOrderList-&gt;size();
 375     }
 376 
 377     LayerList negativeZOrderLayers() const
 378     {
 379         ASSERT(!m_zOrderListsDirty);
 380         ASSERT(isStackingContext() || !m_negZOrderList);
 381         return LayerList(m_negZOrderList.get());
 382     }
 383 
 384     // Update our normal and z-index lists.
 385     void updateLayerListsIfNeeded();
 386     void updateDescendantDependentFlags();
 387     bool descendantDependentFlagsAreDirty() const
 388     {
 389         return m_visibleDescendantStatusDirty || m_visibleContentStatusDirty || m_hasSelfPaintingLayerDescendantDirty
 390 #if ENABLE(CSS_COMPOSITING)
 391             || m_hasNotIsolatedBlendingDescendantsStatusDirty
 392 #endif
 393         ;
 394     }
 395 
 396     void repaintIncludingDescendants();
 397 
 398     // Indicate that the layer contents need to be repainted. Only has an effect
 399     // if layer compositing is being used.
 400     void setBackingNeedsRepaint(GraphicsLayer::ShouldClipToLayer = GraphicsLayer::ClipToLayer);
 401 
 402     // The rect is in the coordinate space of the layer&#39;s render object.
 403     void setBackingNeedsRepaintInRect(const LayoutRect&amp;, GraphicsLayer::ShouldClipToLayer = GraphicsLayer::ClipToLayer);
 404     void repaintIncludingNonCompositingDescendants(RenderLayerModelObject* repaintContainer);
 405 
 406     void styleChanged(StyleDifference, const RenderStyle* oldStyle);
 407 
 408     RenderMarquee* marquee() const { return m_marquee.get(); }
 409 
 410     bool isSelfPaintingLayer() const { return m_isSelfPaintingLayer; }
 411 
 412     bool cannotBlitToWindow() const;
 413 
 414     bool isTransparent() const { return renderer().isTransparent() || renderer().hasMask(); }
 415 
 416     bool hasReflection() const { return renderer().hasReflection(); }
 417     bool isReflection() const { return renderer().isReplica(); }
 418     RenderReplica* reflection() const { return m_reflection.get(); }
 419     RenderLayer* reflectionLayer() const;
 420     bool isReflectionLayer(const RenderLayer&amp;) const;
 421 
 422     const LayoutPoint&amp; location() const { return m_topLeft; }
 423     void setLocation(const LayoutPoint&amp; p) { m_topLeft = p; }
 424 
 425     const IntSize&amp; size() const { return m_layerSize; }
 426     void setSize(const IntSize&amp; size) { m_layerSize = size; } // Only public for RenderTreeAsText.
 427 
 428     LayoutRect rect() const { return LayoutRect(location(), size()); }
 429 
 430     IntSize visibleSize() const override;
 431     IntSize contentsSize() const override;
 432     IntSize reachableTotalContentsSize() const override;
 433 
 434     int scrollWidth() const;
 435     int scrollHeight() const;
 436 
 437     void panScrollFromPoint(const IntPoint&amp;);
 438 
 439     // Scrolling methods for layers that can scroll their overflow.
 440     void scrollByRecursively(const IntSize&amp; delta, ScrollableArea** scrolledArea = nullptr);
 441 
 442     bool requestScrollPositionUpdate(const ScrollPosition&amp;, ScrollType = ScrollType::User, ScrollClamping = ScrollClamping::Clamped) override;
 443 
 444     WEBCORE_EXPORT void scrollToOffset(const ScrollOffset&amp;, ScrollType = ScrollType::Programmatic, ScrollClamping = ScrollClamping::Clamped);
 445 
 446     void scrollToXPosition(int x, ScrollType, ScrollClamping = ScrollClamping::Clamped);
 447     void scrollToYPosition(int y, ScrollType, ScrollClamping = ScrollClamping::Clamped);
 448 
 449     // These are only used by marquee.
 450     void scrollToXOffset(int x) { scrollToOffset(ScrollOffset(x, scrollOffset().y()), ScrollType::Programmatic, ScrollClamping::Unclamped); }
 451     void scrollToYOffset(int y) { scrollToOffset(ScrollOffset(scrollOffset().x(), y), ScrollType::Programmatic, ScrollClamping::Unclamped); }
 452 
 453     void setPostLayoutScrollPosition(Optional&lt;ScrollPosition&gt;);
 454     void applyPostLayoutScrollPositionIfNeeded();
 455 
 456     void availableContentSizeChanged(AvailableSizeChangeReason) override;
 457 
 458     // &quot;absoluteRect&quot; is in scaled document coordinates.
 459     void scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp;);
 460 
 461     bool scrollsOverflow() const;
 462     bool hasScrollableHorizontalOverflow() const;
 463     bool hasScrollableVerticalOverflow() const;
 464     bool hasScrollbars() const { return m_hBar || m_vBar; }
 465     void setHasHorizontalScrollbar(bool);
 466     void setHasVerticalScrollbar(bool);
 467 
 468     Ref&lt;Scrollbar&gt; createScrollbar(ScrollbarOrientation);
 469     void destroyScrollbar(ScrollbarOrientation);
 470 
 471     bool hasHorizontalScrollbar() const { return horizontalScrollbar(); }
 472     bool hasVerticalScrollbar() const { return verticalScrollbar(); }
 473 
 474     bool horizontalScrollbarHiddenByStyle() const override;
 475     bool verticalScrollbarHiddenByStyle() const override;
 476 
 477     // ScrollableArea overrides
 478     ScrollPosition scrollPosition() const override { return m_scrollPosition; }
 479 
 480     Scrollbar* horizontalScrollbar() const override { return m_hBar.get(); }
 481     Scrollbar* verticalScrollbar() const override { return m_vBar.get(); }
 482     ScrollableArea* enclosingScrollableArea() const override;
 483 
 484     bool isScrollableOrRubberbandable() override;
 485     bool hasScrollableOrRubberbandableAncestor() override;
 486     bool useDarkAppearance() const final;
 487 #if ENABLE(CSS_SCROLL_SNAP)
 488     void updateSnapOffsets() override;
 489 #endif
 490 
 491     bool requiresScrollPositionReconciliation() const { return m_requiresScrollPositionReconciliation; }
 492     void setRequiresScrollPositionReconciliation(bool requiresReconciliation = true) { m_requiresScrollPositionReconciliation = requiresReconciliation; }
 493 
 494 #if PLATFORM(IOS_FAMILY)
 495 #if ENABLE(IOS_TOUCH_EVENTS)
 496     bool handleTouchEvent(const PlatformTouchEvent&amp;) override;
 497 #endif
 498 
 499     void didStartScroll() override;
 500     void didEndScroll() override;
 501     void didUpdateScroll() override;
 502 #endif
 503 
 504     // Returns true when the layer could do touch scrolling, but doesn&#39;t look at whether there is actually scrollable overflow.
 505     bool canUseCompositedScrolling() const;
 506     // Returns true when there is actually scrollable overflow (requires layout to be up-to-date).
 507     bool hasCompositedScrollableOverflow() const { return m_hasCompositedScrollableOverflow; }
 508 
 509     int verticalScrollbarWidth(OverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize) const;
 510     int horizontalScrollbarHeight(OverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize) const;
 511 
 512     bool hasOverflowControls() const;
 513     bool isPointInResizeControl(const IntPoint&amp; absolutePoint) const;
 514     bool hitTestOverflowControls(HitTestResult&amp;, const IntPoint&amp; localPoint);
 515     IntSize offsetFromResizeCorner(const IntPoint&amp; absolutePoint) const;
 516 
 517     void paintOverflowControls(GraphicsContext&amp;, const IntPoint&amp;, const IntRect&amp; damageRect, bool paintingOverlayControls = false);
 518     void paintScrollCorner(GraphicsContext&amp;, const IntPoint&amp;, const IntRect&amp; damageRect);
 519     void paintResizer(GraphicsContext&amp;, const LayoutPoint&amp;, const LayoutRect&amp; damageRect);
 520 
 521     void updateScrollInfoAfterLayout();
 522 
 523     bool scroll(ScrollDirection, ScrollGranularity, float multiplier = 1);
 524     void autoscroll(const IntPoint&amp;);
 525 
 526     bool canResize() const;
 527     void resize(const PlatformMouseEvent&amp;, const LayoutSize&amp;);
 528     bool inResizeMode() const { return m_inResizeMode; }
 529     void setInResizeMode(bool b) { m_inResizeMode = b; }
 530 
 531     bool isRenderViewLayer() const { return m_isRenderViewLayer; }
 532     bool isForcedStackingContext() const { return m_forcedStackingContext; }
 533     bool isOpportunisticStackingContext() const { return m_isOpportunisticStackingContext; }
 534 
 535     RenderLayerCompositor&amp; compositor() const;
 536 
 537     // Notification from the renderer that its content changed (e.g. current frame of image changed).
 538     // Allows updates of layer content without repainting.
 539     void contentChanged(ContentChangeType);
 540 
 541     bool canRender3DTransforms() const;
 542 
 543     void updateLayerPositionsAfterStyleChange();
 544     void updateLayerPositionsAfterLayout(bool isRelayoutingSubtree, bool didFullRepaint);
 545 
 546     void updateLayerPositionsAfterOverflowScroll();
 547     void updateLayerPositionsAfterDocumentScroll();
 548 
 549     bool hasCompositedLayerInEnclosingPaginationChain() const;
 550     enum PaginationInclusionMode { ExcludeCompositedPaginatedLayers, IncludeCompositedPaginatedLayers };
 551     RenderLayer* enclosingPaginationLayer(PaginationInclusionMode mode) const
 552     {
 553         if (mode == ExcludeCompositedPaginatedLayers &amp;&amp; hasCompositedLayerInEnclosingPaginationChain())
 554             return nullptr;
 555         return m_enclosingPaginationLayer.get();
 556     }
 557 
 558     void updateTransform();
 559 
 560 #if ENABLE(CSS_COMPOSITING)
 561     void updateBlendMode();
 562     void willRemoveChildWithBlendMode();
 563 #endif
 564 
 565     const LayoutSize&amp; offsetForInFlowPosition() const { return m_offsetForInFlowPosition; }
 566 
 567     void clearClipRectsIncludingDescendants(ClipRectsType typeToClear = AllClipRectTypes);
 568     void clearClipRects(ClipRectsType typeToClear = AllClipRectTypes);
 569 
 570     void addBlockSelectionGapsBounds(const LayoutRect&amp;);
 571     void clearBlockSelectionGapsBounds();
 572     void repaintBlockSelectionGaps();
 573 
 574     // FIXME: We should ASSERT(!m_visibleContentStatusDirty) here, but see https://bugs.webkit.org/show_bug.cgi?id=71044
 575     // ditto for hasVisibleDescendant(), see https://bugs.webkit.org/show_bug.cgi?id=71277
 576     bool hasVisibleContent() const { return m_hasVisibleContent; }
 577     bool hasVisibleDescendant() const { return m_hasVisibleDescendant; }
 578 
 579     void setHasVisibleContent();
 580     void dirtyVisibleContentStatus();
 581 
 582     bool hasVisibleBoxDecorationsOrBackground() const;
 583     bool hasVisibleBoxDecorations() const;
 584 
 585     bool behavesAsFixed() const { return m_behavesAsFixed; }
 586 
 587     struct PaintedContentRequest {
 588         void makeStatesUndetermined()
 589         {
 590             if (hasPaintedContent == RequestState::Unknown)
 591                 hasPaintedContent = RequestState::Undetermined;
 592 
 593             if (hasSubpixelAntialiasedText == RequestState::Unknown)
 594                 hasSubpixelAntialiasedText = RequestState::Undetermined;
 595         }
 596 
 597         void setHasPaintedContent() { hasPaintedContent = RequestState::True; }
 598         void setHasSubpixelAntialiasedText() { hasSubpixelAntialiasedText = RequestState::True; }
 599 
 600         bool needToDeterminePaintedContentState() const { return hasPaintedContent == RequestState::Unknown; }
 601         bool needToDetermineSubpixelAntialiasedTextState() const { return hasSubpixelAntialiasedText == RequestState::Unknown; }
 602 
 603         bool probablyHasPaintedContent() const { return hasPaintedContent == RequestState::True || hasPaintedContent == RequestState::Undetermined; }
 604         bool probablyHasSubpixelAntialiasedText() const { return hasSubpixelAntialiasedText == RequestState::True || hasSubpixelAntialiasedText == RequestState::Undetermined; }
 605 
 606         bool isSatisfied() const { return hasPaintedContent != RequestState::Unknown &amp;&amp; hasSubpixelAntialiasedText != RequestState::Unknown; }
 607 
 608         RequestState hasPaintedContent { RequestState::Unknown };
 609         RequestState hasSubpixelAntialiasedText { RequestState::DontCare };
 610     };
 611 
 612     // Returns true if this layer has visible content (ignoring any child layers).
 613     bool isVisuallyNonEmpty(PaintedContentRequest* = nullptr) const;
 614     // True if this layer container renderers that paint.
 615     bool hasNonEmptyChildRenderers(PaintedContentRequest&amp;) const;
 616 
 617     // FIXME: We should ASSERT(!m_hasSelfPaintingLayerDescendantDirty); here but we hit the same bugs as visible content above.
 618     // Part of the issue is with subtree relayout: we don&#39;t check if our ancestors have some descendant flags dirty, missing some updates.
 619     bool hasSelfPaintingLayerDescendant() const { return m_hasSelfPaintingLayerDescendant; }
 620 
 621     bool ancestorLayerIsInContainingBlockChain(const RenderLayer&amp; ancestor, const RenderLayer* checkLimit = nullptr) const;
 622 
 623     // Gets the nearest enclosing positioned ancestor layer (also includes
 624     // the &lt;html&gt; layer and the root layer).
 625     RenderLayer* enclosingAncestorForPosition(PositionType) const;
 626 
 627     // Returns the nearest enclosing layer that is scrollable.
 628     RenderLayer* enclosingScrollableLayer() const;
 629 
 630     // The layer relative to which clipping rects for this layer are computed.
 631     RenderLayer* clippingRootForPainting() const;
 632 
 633     RenderLayer* enclosingOverflowClipLayer(IncludeSelfOrNot) const;
 634 
 635     // Enclosing compositing layer; if includeSelf is true, may return this.
 636     RenderLayer* enclosingCompositingLayer(IncludeSelfOrNot = IncludeSelf) const;
 637     RenderLayer* enclosingCompositingLayerForRepaint(IncludeSelfOrNot = IncludeSelf) const;
 638     // Ancestor compositing layer, excluding this.
 639     RenderLayer* ancestorCompositingLayer() const { return enclosingCompositingLayer(ExcludeSelf); }
 640 
 641     RenderLayer* enclosingFilterLayer(IncludeSelfOrNot = IncludeSelf) const;
 642     RenderLayer* enclosingFilterRepaintLayer() const;
 643     void setFilterBackendNeedsRepaintingInRect(const LayoutRect&amp;);
 644     bool hasAncestorWithFilterOutsets() const;
 645 
 646     bool canUseOffsetFromAncestor() const
 647     {
 648         // FIXME: This really needs to know if there are transforms on this layer and any of the layers
 649         // between it and the ancestor in question.
 650         return !renderer().hasTransform() &amp;&amp; !renderer().isSVGRoot();
 651     }
 652 
 653     // FIXME: adjustForColumns allows us to position compositing layers in columns correctly, but eventually they need to be split across columns too.
 654     enum ColumnOffsetAdjustment { DontAdjustForColumns, AdjustForColumns };
 655     void convertToPixelSnappedLayerCoords(const RenderLayer* ancestorLayer, IntPoint&amp; location, ColumnOffsetAdjustment adjustForColumns = DontAdjustForColumns) const;
 656     LayoutPoint convertToLayerCoords(const RenderLayer* ancestorLayer, const LayoutPoint&amp;, ColumnOffsetAdjustment adjustForColumns = DontAdjustForColumns) const;
 657     LayoutSize offsetFromAncestor(const RenderLayer*, ColumnOffsetAdjustment = DontAdjustForColumns) const;
 658 
 659     int zIndex() const { return renderer().style().usedZIndex(); }
 660 
 661     enum PaintLayerFlag {
 662         PaintLayerHaveTransparency                      = 1 &lt;&lt; 0,
 663         PaintLayerAppliedTransform                      = 1 &lt;&lt; 1,
 664         PaintLayerTemporaryClipRects                    = 1 &lt;&lt; 2,
 665         PaintLayerPaintingReflection                    = 1 &lt;&lt; 3,
 666         PaintLayerPaintingOverlayScrollbars             = 1 &lt;&lt; 4,
 667         PaintLayerPaintingCompositingBackgroundPhase    = 1 &lt;&lt; 5,
 668         PaintLayerPaintingCompositingForegroundPhase    = 1 &lt;&lt; 6,
 669         PaintLayerPaintingCompositingMaskPhase          = 1 &lt;&lt; 7,
 670         PaintLayerPaintingCompositingClipPathPhase      = 1 &lt;&lt; 8,
 671         PaintLayerPaintingCompositingScrollingPhase     = 1 &lt;&lt; 9,
 672         PaintLayerPaintingOverflowContents              = 1 &lt;&lt; 10,
 673         PaintLayerPaintingRootBackgroundOnly            = 1 &lt;&lt; 11,
 674         PaintLayerPaintingSkipRootBackground            = 1 &lt;&lt; 12,
 675         PaintLayerPaintingChildClippingMaskPhase        = 1 &lt;&lt; 13,
 676         PaintLayerCollectingEventRegion                 = 1 &lt;&lt; 14,
 677     };
 678     static constexpr OptionSet&lt;PaintLayerFlag&gt; paintLayerPaintingCompositingAllPhasesFlags() { return { PaintLayerPaintingCompositingBackgroundPhase, PaintLayerPaintingCompositingForegroundPhase }; }
 679 
 680     enum class SecurityOriginPaintPolicy { AnyOrigin, AccessibleOriginOnly };
 681 
 682     // The two main functions that use the layer system.  The paint method
 683     // paints the layers that intersect the damage rect from back to
 684     // front.  The hitTest method looks for mouse events by walking
 685     // layers that intersect the point from front to back.
 686     void paint(GraphicsContext&amp;, const LayoutRect&amp; damageRect, const LayoutSize&amp; subpixelOffset = LayoutSize(), OptionSet&lt;PaintBehavior&gt; = PaintBehavior::Normal,
 687         RenderObject* subtreePaintRoot = nullptr, OptionSet&lt;PaintLayerFlag&gt; = { }, SecurityOriginPaintPolicy = SecurityOriginPaintPolicy::AnyOrigin);
 688     bool hitTest(const HitTestRequest&amp;, HitTestResult&amp;);
 689     bool hitTest(const HitTestRequest&amp;, const HitTestLocation&amp;, HitTestResult&amp;);
 690     void paintOverlayScrollbars(GraphicsContext&amp;, const LayoutRect&amp; damageRect, OptionSet&lt;PaintBehavior&gt;, RenderObject* subtreePaintRoot = nullptr);
 691 
 692     struct ClipRectsContext {
 693         ClipRectsContext(const RenderLayer* inRootLayer, ClipRectsType inClipRectsType, OverlayScrollbarSizeRelevancy inOverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize, ShouldRespectOverflowClip inRespectOverflowClip = RespectOverflowClip)
 694             : rootLayer(inRootLayer)
 695             , clipRectsType(inClipRectsType)
 696             , overlayScrollbarSizeRelevancy(inOverlayScrollbarSizeRelevancy)
 697             , respectOverflowClip(inRespectOverflowClip)
 698         { }
 699         const RenderLayer* rootLayer;
 700         ClipRectsType clipRectsType;
 701         OverlayScrollbarSizeRelevancy overlayScrollbarSizeRelevancy;
 702         ShouldRespectOverflowClip respectOverflowClip;
 703     };
 704 
 705     // This method figures out our layerBounds in coordinates relative to
 706     // |rootLayer}.  It also computes our background and foreground clip rects
 707     // for painting/event handling.
 708     // Pass offsetFromRoot if known.
 709     void calculateRects(const ClipRectsContext&amp;, const LayoutRect&amp; paintDirtyRect, LayoutRect&amp; layerBounds,
 710         ClipRect&amp; backgroundRect, ClipRect&amp; foregroundRect, const LayoutSize&amp; offsetFromRoot) const;
 711 
 712     // Public just for RenderTreeAsText.
 713     void collectFragments(LayerFragments&amp;, const RenderLayer* rootLayer, const LayoutRect&amp; dirtyRect,
 714         PaginationInclusionMode,
 715         ClipRectsType, OverlayScrollbarSizeRelevancy inOverlayScrollbarSizeRelevancy, ShouldRespectOverflowClip, const LayoutSize&amp; offsetFromRoot,
 716         const LayoutRect* layerBoundingBox = nullptr, ShouldApplyRootOffsetToFragments = IgnoreRootOffsetForFragments);
 717 
 718     LayoutRect childrenClipRect() const; // Returns the foreground clip rect of the layer in the document&#39;s coordinate space.
 719     LayoutRect selfClipRect() const; // Returns the background clip rect of the layer in the document&#39;s coordinate space.
 720     LayoutRect localClipRect(bool&amp; clipExceedsBounds) const; // Returns the background clip rect of the layer in the local coordinate space.
 721 
 722     bool clipCrossesPaintingBoundary() const;
 723 
 724     // Pass offsetFromRoot if known.
 725     bool intersectsDamageRect(const LayoutRect&amp; layerBounds, const LayoutRect&amp; damageRect, const RenderLayer* rootLayer, const LayoutSize&amp; offsetFromRoot, const LayoutRect* cachedBoundingBox = nullptr) const;
 726 
 727     enum CalculateLayerBoundsFlag {
 728         IncludeSelfTransform                    = 1 &lt;&lt; 0,
 729         UseLocalClipRectIfPossible              = 1 &lt;&lt; 1,
 730         IncludeFilterOutsets                    = 1 &lt;&lt; 2,
 731         IncludePaintedFilterOutsets             = 1 &lt;&lt; 3,
 732         ExcludeHiddenDescendants                = 1 &lt;&lt; 4,
 733         DontConstrainForMask                    = 1 &lt;&lt; 5,
 734         IncludeCompositedDescendants            = 1 &lt;&lt; 6,
 735         UseFragmentBoxesExcludingCompositing    = 1 &lt;&lt; 7,
 736         UseFragmentBoxesIncludingCompositing    = 1 &lt;&lt; 8,
 737     };
 738     static constexpr OptionSet&lt;CalculateLayerBoundsFlag&gt; defaultCalculateLayerBoundsFlags() { return { IncludeSelfTransform, UseLocalClipRectIfPossible, IncludePaintedFilterOutsets, UseFragmentBoxesExcludingCompositing }; }
 739 
 740     // Bounding box relative to some ancestor layer. Pass offsetFromRoot if known.
 741     LayoutRect boundingBox(const RenderLayer* rootLayer, const LayoutSize&amp; offsetFromRoot = LayoutSize(), OptionSet&lt;CalculateLayerBoundsFlag&gt; = { }) const;
 742     // Bounding box in the coordinates of this layer.
 743     LayoutRect localBoundingBox(OptionSet&lt;CalculateLayerBoundsFlag&gt; = { }) const;
 744     // Deprecated: Pixel snapped bounding box relative to the root.
 745     WEBCORE_EXPORT IntRect absoluteBoundingBox() const;
 746     // Device pixel snapped bounding box relative to the root. absoluteBoundingBox() callers will be directed to this.
 747     FloatRect absoluteBoundingBoxForPainting() const;
 748 
 749     // Bounds used for layer overlap testing in RenderLayerCompositor.
 750     LayoutRect overlapBounds() const;
 751 
 752     // Takes transform animations into account, returning true if they could be cheaply computed.
 753     // Unlike overlapBounds, these bounds include descendant layers.
 754     bool getOverlapBoundsIncludingChildrenAccountingForTransformAnimations(LayoutRect&amp;, OptionSet&lt;CalculateLayerBoundsFlag&gt; additionalFlags = { }) const;
 755 
 756     // If true, this layer&#39;s children are included in its bounds for overlap testing.
 757     // We can&#39;t rely on the children&#39;s positions if this layer has a filter that could have moved the children&#39;s pixels around.
 758     bool overlapBoundsIncludeChildren() const { return hasFilter() &amp;&amp; renderer().style().filter().hasFilterThatMovesPixels(); }
 759 
 760     // Can pass offsetFromRoot if known.
 761     LayoutRect calculateLayerBounds(const RenderLayer* ancestorLayer, const LayoutSize&amp; offsetFromRoot, OptionSet&lt;CalculateLayerBoundsFlag&gt; = defaultCalculateLayerBoundsFlags()) const;
 762 
 763     // Return a cached repaint rect, computed relative to the layer renderer&#39;s containerForRepaint.
 764     bool hasComputedRepaintRects() const { return renderer().hasRepaintLayoutRects(); }
 765     LayoutRect repaintRectIncludingNonCompositingDescendants() const;
 766 
 767     void setRepaintStatus(RepaintStatus status) { m_repaintStatus = status; }
 768     RepaintStatus repaintStatus() const { return static_cast&lt;RepaintStatus&gt;(m_repaintStatus); }
 769 
 770     LayoutUnit staticInlinePosition() const { return m_staticInlinePosition; }
 771     LayoutUnit staticBlockPosition() const { return m_staticBlockPosition; }
 772 
 773     void setStaticInlinePosition(LayoutUnit position) { m_staticInlinePosition = position; }
 774     void setStaticBlockPosition(LayoutUnit position) { m_staticBlockPosition = position; }
 775 
 776 #if PLATFORM(IOS_FAMILY)
 777     bool adjustForIOSCaretWhenScrolling() const { return m_adjustForIOSCaretWhenScrolling; }
 778     void setAdjustForIOSCaretWhenScrolling(bool adjustForIOSCaretWhenScrolling) { m_adjustForIOSCaretWhenScrolling = adjustForIOSCaretWhenScrolling; }
 779 #endif
 780 
 781     bool hasTransform() const { return renderer().hasTransform(); }
 782     // Note that this transform has the transform-origin baked in.
 783     TransformationMatrix* transform() const { return m_transform.get(); }
 784     // currentTransform computes a transform which takes accelerated animations into account. The
 785     // resulting transform has transform-origin baked in. If the layer does not have a transform,
 786     // returns the identity matrix.
 787     TransformationMatrix currentTransform(RenderStyle::ApplyTransformOrigin = RenderStyle::IncludeTransformOrigin) const;
 788     TransformationMatrix renderableTransform(OptionSet&lt;PaintBehavior&gt;) const;
 789 
 790     // Get the perspective transform, which is applied to transformed sublayers.
 791     // Returns true if the layer has a -webkit-perspective.
 792     // Note that this transform has the perspective-origin baked in.
 793     TransformationMatrix perspectiveTransform() const;
 794     FloatPoint perspectiveOrigin() const;
 795     bool preserves3D() const { return renderer().style().transformStyle3D() == TransformStyle3D::Preserve3D; }
 796     bool has3DTransform() const { return m_transform &amp;&amp; !m_transform-&gt;isAffine(); }
 797     bool hasTransformedAncestor() const { return m_hasTransformedAncestor; }
 798 
 799     bool hasFilter() const { return renderer().hasFilter(); }
 800     bool hasFilterOutsets() const { return !filterOutsets().isZero(); }
 801     IntOutsets filterOutsets() const;
 802     bool hasBackdropFilter() const
 803     {
 804 #if ENABLE(FILTERS_LEVEL_2)
 805         return renderer().hasBackdropFilter();
 806 #else
 807         return false;
 808 #endif
 809     }
 810 
 811 #if ENABLE(CSS_COMPOSITING)
 812     bool hasBlendMode() const { return renderer().hasBlendMode(); }
 813     BlendMode blendMode() const { return static_cast&lt;BlendMode&gt;(m_blendMode); }
 814 
 815     bool isolatesCompositedBlending() const { return m_hasNotIsolatedCompositedBlendingDescendants &amp;&amp; isCSSStackingContext(); }
 816     bool hasNotIsolatedCompositedBlendingDescendants() const { return m_hasNotIsolatedCompositedBlendingDescendants; }
 817     void setHasNotIsolatedCompositedBlendingDescendants(bool hasNotIsolatedCompositedBlendingDescendants)
 818     {
 819         m_hasNotIsolatedCompositedBlendingDescendants = hasNotIsolatedCompositedBlendingDescendants;
 820     }
 821 
 822     bool isolatesBlending() const { return hasNotIsolatedBlendingDescendants() &amp;&amp; isCSSStackingContext(); }
 823 
 824     // FIXME: We should ASSERT(!m_hasNotIsolatedBlendingDescendantsStatusDirty); here but we hit the same bugs as visible content above.
 825     bool hasNotIsolatedBlendingDescendants() const { return m_hasNotIsolatedBlendingDescendants; }
 826     bool hasNotIsolatedBlendingDescendantsStatusDirty() const { return m_hasNotIsolatedBlendingDescendantsStatusDirty; }
 827 #else
 828     bool hasBlendMode() const { return false; }
 829     bool isolatesCompositedBlending() const { return false; }
 830     bool isolatesBlending() const { return false; }
 831     bool hasNotIsolatedBlendingDescendantsStatusDirty() const { return false; }
 832 #endif
 833 
 834     bool isComposited() const { return m_backing != nullptr; }
 835     bool hasCompositingDescendant() const { return m_hasCompositingDescendant; }
 836     bool hasCompositedMask() const;
 837 
 838     // If non-null, a non-ancestor composited layer that this layer paints into (it is sharing its backing store with this layer).
 839     RenderLayer* backingProviderLayer() const { return m_backingProviderLayer.get(); }
 840     void setBackingProviderLayer(RenderLayer*);
 841     void disconnectFromBackingProviderLayer();
 842 
 843     bool paintsIntoProvidedBacking() const { return !!m_backingProviderLayer; }
 844 
 845     RenderLayerBacking* backing() const { return m_backing.get(); }
 846     RenderLayerBacking* ensureBacking();
 847     void clearBacking(bool layerBeingDestroyed = false);
 848 
 849     GraphicsLayer* layerForHorizontalScrollbar() const override;
 850     GraphicsLayer* layerForVerticalScrollbar() const override;
 851     GraphicsLayer* layerForScrollCorner() const override;
 852 
 853     bool usesCompositedScrolling() const override;
 854     bool usesAsyncScrolling() const override;
 855 
 856     bool hasCompositedScrollingAncestor() const { return m_hasCompositedScrollingAncestor; }
 857     void setHasCompositedScrollingAncestor(bool hasCompositedScrollingAncestor) { m_hasCompositedScrollingAncestor = hasCompositedScrollingAncestor; }
 858 
 859     bool paintsWithTransparency(OptionSet&lt;PaintBehavior&gt; paintBehavior) const
 860     {
 861         return (isTransparent() || hasBlendMode() || (isolatesBlending() &amp;&amp; !renderer().isDocumentElementRenderer())) &amp;&amp; ((paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) || !isComposited());
 862     }
 863 
 864     bool paintsWithTransform(OptionSet&lt;PaintBehavior&gt;) const;
 865     bool shouldPaintMask(OptionSet&lt;PaintBehavior&gt;, OptionSet&lt;PaintLayerFlag&gt;) const;
 866     bool shouldApplyClipPath(OptionSet&lt;PaintBehavior&gt;, OptionSet&lt;PaintLayerFlag&gt;) const;
 867 
 868     // Returns true if background phase is painted opaque in the given rect.
 869     // The query rect is given in local coordinates.
 870     bool backgroundIsKnownToBeOpaqueInRect(const LayoutRect&amp;) const;
 871 
 872     bool scrollingMayRevealBackground() const;
 873 
 874     bool containsDirtyOverlayScrollbars() const { return m_containsDirtyOverlayScrollbars; }
 875     void setContainsDirtyOverlayScrollbars(bool dirtyScrollbars) { m_containsDirtyOverlayScrollbars = dirtyScrollbars; }
 876 
 877     bool paintsWithFilters() const;
 878     bool requiresFullLayerImageForFilters() const;
 879 
 880     Element* enclosingElement() const;
 881 
 882     enum ViewportConstrainedNotCompositedReason {
 883         NoNotCompositedReason,
 884         NotCompositedForBoundsOutOfView,
 885         NotCompositedForNonViewContainer,
 886         NotCompositedForNoVisibleContent,
 887     };
 888 
 889     void setViewportConstrainedNotCompositedReason(ViewportConstrainedNotCompositedReason reason) { m_viewportConstrainedNotCompositedReason = reason; }
 890     ViewportConstrainedNotCompositedReason viewportConstrainedNotCompositedReason() const { return static_cast&lt;ViewportConstrainedNotCompositedReason&gt;(m_viewportConstrainedNotCompositedReason); }
 891 
 892     IndirectCompositingReason indirectCompositingReason() const { return static_cast&lt;IndirectCompositingReason&gt;(m_indirectCompositingReason); }
 893 
 894     bool isRenderFragmentedFlow() const { return renderer().isRenderFragmentedFlow(); }
 895     bool isOutOfFlowRenderFragmentedFlow() const { return renderer().isOutOfFlowRenderFragmentedFlow(); }
 896     bool isInsideFragmentedFlow() const { return renderer().fragmentedFlowState() != RenderObject::NotInsideFragmentedFlow; }
 897     bool isDirtyRenderFragmentedFlow() const
 898     {
 899         ASSERT(isRenderFragmentedFlow());
 900         return zOrderListsDirty() || normalFlowListDirty();
 901     }
 902 
 903     RenderLayer* enclosingFragmentedFlowAncestor() const;
 904 
 905     bool shouldPlaceBlockDirectionScrollbarOnLeft() const final { return renderer().shouldPlaceBlockDirectionScrollbarOnLeft(); }
 906 
 907     void simulateFrequentPaint() { SinglePaintFrequencyTracking { m_paintFrequencyTracker }; }
 908     bool paintingFrequently() const { return m_paintFrequencyTracker.paintingFrequently(); }
 909 
 910     WEBCORE_EXPORT bool isTransparentRespectingParentFrames() const;
 911 
 912     void invalidateEventRegion();
 913 
 914 private:
 915 
 916     void setNextSibling(RenderLayer* next) { m_next = next; }
 917     void setPreviousSibling(RenderLayer* prev) { m_previous = prev; }
 918     void setParent(RenderLayer*);
 919     void setFirstChild(RenderLayer* first) { m_first = first; }
 920     void setLastChild(RenderLayer* last) { m_last = last; }
 921 
 922     void dirtyPaintOrderListsOnChildChange(RenderLayer&amp;);
 923 
 924     bool shouldBeNormalFlowOnly() const;
 925     bool shouldBeCSSStackingContext() const;
 926 
 927     // Return true if changed.
 928     bool setIsNormalFlowOnly(bool);
 929 
 930     bool setIsOpportunisticStackingContext(bool);
 931     bool setIsCSSStackingContext(bool);
 932 
 933     void isStackingContextChanged();
 934 
 935     bool isDirtyStackingContext() const { return m_zOrderListsDirty &amp;&amp; isStackingContext(); }
 936 
 937     void updateZOrderLists();
 938     void rebuildZOrderLists();
 939     void rebuildZOrderLists(std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, OptionSet&lt;Compositing&gt;&amp;);
 940     void collectLayers(bool includeHiddenLayers, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, OptionSet&lt;Compositing&gt;&amp;);
 941     void clearZOrderLists();
 942 
 943     void updateNormalFlowList();
 944 
 945     struct LayerPaintingInfo {
 946         LayerPaintingInfo(RenderLayer* inRootLayer, const LayoutRect&amp; inDirtyRect, OptionSet&lt;PaintBehavior&gt; inPaintBehavior, const LayoutSize&amp; inSubpixelOffset, RenderObject* inSubtreePaintRoot = nullptr, OverlapTestRequestMap* inOverlapTestRequests = nullptr, bool inRequireSecurityOriginAccessForWidgets = false)
 947             : rootLayer(inRootLayer)
 948             , subtreePaintRoot(inSubtreePaintRoot)
 949             , paintDirtyRect(inDirtyRect)
 950             , subpixelOffset(inSubpixelOffset)
 951             , overlapTestRequests(inOverlapTestRequests)
 952             , paintBehavior(inPaintBehavior)
 953             , requireSecurityOriginAccessForWidgets(inRequireSecurityOriginAccessForWidgets)
 954         { }
 955 
 956         RenderLayer* rootLayer;
 957         RenderObject* subtreePaintRoot; // Only paint descendants of this object.
 958         LayoutRect paintDirtyRect; // Relative to rootLayer;
 959         LayoutSize subpixelOffset;
 960         OverlapTestRequestMap* overlapTestRequests; // May be null.
 961         OptionSet&lt;PaintBehavior&gt; paintBehavior;
 962         bool requireSecurityOriginAccessForWidgets;
 963         bool clipToDirtyRect { true };
 964         EventRegionContext* eventRegionContext { nullptr };
 965     };
 966 
 967     // Compute, cache and return clip rects computed with the given layer as the root.
 968     Ref&lt;ClipRects&gt; updateClipRects(const ClipRectsContext&amp;);
 969     // Compute and return the clip rects. If useCached is true, will used previously computed clip rects on ancestors
 970     // (rather than computing them all from scratch up the parent chain).
 971     void calculateClipRects(const ClipRectsContext&amp;, ClipRects&amp;) const;
 972     ClipRects* clipRects(const ClipRectsContext&amp;) const;
 973 
 974     void setAncestorChainHasSelfPaintingLayerDescendant();
 975     void dirtyAncestorChainHasSelfPaintingLayerDescendantStatus();
 976 
 977     void computeRepaintRects(const RenderLayerModelObject* repaintContainer, const RenderGeometryMap* = nullptr);
 978     void computeRepaintRectsIncludingDescendants();
 979     void clearRepaintRects();
 980 
 981     LayoutRect clipRectRelativeToAncestor(RenderLayer* ancestor, LayoutSize offsetFromAncestor, const LayoutRect&amp; constrainingRect) const;
 982 
 983     void clipToRect(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const ClipRect&amp;, BorderRadiusClippingRule = IncludeSelfForBorderRadius);
 984     void restoreClip(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const ClipRect&amp;);
 985 
 986     bool shouldRepaintAfterLayout() const;
 987 
 988     void updateSelfPaintingLayer();
 989 
 990     void updateScrollbarsAfterStyleChange(const RenderStyle* oldStyle);
 991     void updateScrollbarsAfterLayout();
 992 
 993     enum UpdateLayerPositionsFlag {
 994         CheckForRepaint                     = 1 &lt;&lt; 0,
 995         NeedsFullRepaintInBacking           = 1 &lt;&lt; 1,
 996         ContainingClippingLayerChangedSize  = 1 &lt;&lt; 2,
 997         UpdatePagination                    = 1 &lt;&lt; 3,
 998         SeenFixedLayer                      = 1 &lt;&lt; 4,
 999         SeenTransformedLayer                = 1 &lt;&lt; 5,
1000         Seen3DTransformedLayer              = 1 &lt;&lt; 6,
1001         SeenCompositedScrollingLayer        = 1 &lt;&lt; 7,
1002     };
1003     static OptionSet&lt;UpdateLayerPositionsFlag&gt; flagsForUpdateLayerPositions(RenderLayer&amp; startingLayer);
1004 
1005     // Returns true if the position changed.
1006     bool updateLayerPosition(OptionSet&lt;UpdateLayerPositionsFlag&gt;* = nullptr);
1007 
1008     void updateLayerPositions(RenderGeometryMap*, OptionSet&lt;UpdateLayerPositionsFlag&gt;);
1009 
1010     enum UpdateLayerPositionsAfterScrollFlag {
1011         IsOverflowScroll                        = 1 &lt;&lt; 0,
1012         HasSeenViewportConstrainedAncestor      = 1 &lt;&lt; 1,
1013         HasSeenAncestorWithOverflowClip         = 1 &lt;&lt; 2,
1014         HasChangedAncestor                      = 1 &lt;&lt; 3,
1015     };
1016     void updateLayerPositionsAfterScroll(RenderGeometryMap*, OptionSet&lt;UpdateLayerPositionsAfterScrollFlag&gt; = { });
1017 
1018     ScrollOffset clampScrollOffset(const ScrollOffset&amp;) const;
1019 
1020     RenderLayer* enclosingPaginationLayerInSubtree(const RenderLayer* rootLayer, PaginationInclusionMode) const;
1021 
1022     LayoutPoint renderBoxLocation() const { return is&lt;RenderBox&gt;(renderer()) ? downcast&lt;RenderBox&gt;(renderer()).location() : LayoutPoint(); }
1023 
1024     bool setupFontSubpixelQuantization(GraphicsContext&amp;, bool&amp; didQuantizeFonts);
1025 
1026     Path computeClipPath(const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, WindRule&amp;) const;
1027 
1028     bool setupClipPath(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed);
1029 
1030     void ensureLayerFilters();
1031     void clearLayerFilters();
1032 
1033     RenderLayerFilters* filtersForPainting(GraphicsContext&amp;, OptionSet&lt;PaintLayerFlag&gt;) const;
1034     GraphicsContext* setupFilters(GraphicsContext&amp; destinationContext, LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed);
1035     void applyFilters(GraphicsContext&amp; originalContext, const LayerPaintingInfo&amp;, const LayerFragments&amp;);
1036 
1037     void paintLayer(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
1038     void paintLayerWithEffects(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
1039 
1040     void paintLayerContentsAndReflection(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
1041     void paintLayerByApplyingTransform(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;, const LayoutSize&amp; translationOffset = LayoutSize());
1042     void paintLayerContents(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
1043     void paintList(LayerList, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
1044 
1045     void updatePaintingInfoForFragments(LayerFragments&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;, bool shouldPaintContent, const LayoutSize&amp; offsetFromRoot);
1046     void paintBackgroundForFragments(const LayerFragments&amp;, GraphicsContext&amp;, GraphicsContext&amp; transparencyLayerContext,
1047         const LayoutRect&amp; transparencyPaintDirtyRect, bool haveTransparency, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1048     void paintForegroundForFragments(const LayerFragments&amp;, GraphicsContext&amp;, GraphicsContext&amp; transparencyLayerContext,
1049         const LayoutRect&amp; transparencyPaintDirtyRect, bool haveTransparency, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1050     void paintForegroundForFragmentsWithPhase(PaintPhase, const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1051     void paintOutlineForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1052     void paintOverflowControlsForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;);
1053     void paintMaskForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1054     void paintChildClippingMaskForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1055     void paintTransformedLayerIntoFragments(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
1056     void collectEventRegionForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;);
1057 
1058     RenderLayer* transparentPaintingAncestor();
1059     void beginTransparencyLayers(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const LayoutRect&amp; dirtyRect);
1060 
1061     RenderLayer* hitTestLayer(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp;, HitTestResult&amp;,
1062         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;, bool appliedTransform,
1063         const HitTestingTransformState* = nullptr, double* zOffset = nullptr);
1064     RenderLayer* hitTestLayerByApplyingTransform(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp;, HitTestResult&amp;,
1065         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;, const HitTestingTransformState* = nullptr, double* zOffset = nullptr,
1066         const LayoutSize&amp; translationOffset = LayoutSize());
1067     RenderLayer* hitTestList(LayerList, RenderLayer* rootLayer, const HitTestRequest&amp;, HitTestResult&amp;,
1068         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;,
1069         const HitTestingTransformState*, double* zOffsetForDescendants, double* zOffset,
1070         const HitTestingTransformState* unflattenedTransformState, bool depthSortDescendants);
1071 
1072     Ref&lt;HitTestingTransformState&gt; createLocalTransformState(RenderLayer* rootLayer, RenderLayer* containerLayer,
1073         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;,
1074         const HitTestingTransformState* containerTransformState,
1075         const LayoutSize&amp; translationOffset = LayoutSize()) const;
1076 
1077     bool hitTestContents(const HitTestRequest&amp;, HitTestResult&amp;, const LayoutRect&amp; layerBounds, const HitTestLocation&amp;, HitTestFilter) const;
1078     bool hitTestContentsForFragments(const LayerFragments&amp;, const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp;, HitTestFilter, bool&amp; insideClipRect) const;
1079     bool hitTestResizerInFragments(const LayerFragments&amp;, const HitTestLocation&amp;) const;
1080     RenderLayer* hitTestTransformedLayerInFragments(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp;, HitTestResult&amp;,
1081         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;, const HitTestingTransformState* = nullptr, double* zOffset = nullptr);
1082 
1083     bool listBackgroundIsKnownToBeOpaqueInRect(const LayerList&amp;, const LayoutRect&amp;) const;
1084 
1085     void computeScrollDimensions();
1086     bool hasHorizontalOverflow() const;
1087     bool hasVerticalOverflow() const;
1088 
1089     bool showsOverflowControls() const;
1090 
1091     bool shouldBeSelfPaintingLayer() const;
1092 
1093     // ScrollableArea interface
1094     void invalidateScrollbarRect(Scrollbar&amp;, const IntRect&amp;) override;
1095     void invalidateScrollCornerRect(const IntRect&amp;) override;
1096     bool isActive() const override;
1097     bool isScrollCornerVisible() const override;
1098     IntRect scrollCornerRect() const override;
1099     IntRect convertFromScrollbarToContainingView(const Scrollbar&amp;, const IntRect&amp;) const override;
1100     IntRect convertFromContainingViewToScrollbar(const Scrollbar&amp;, const IntRect&amp;) const override;
1101     IntPoint convertFromScrollbarToContainingView(const Scrollbar&amp;, const IntPoint&amp;) const override;
1102     IntPoint convertFromContainingViewToScrollbar(const Scrollbar&amp;, const IntPoint&amp;) const override;
1103     void setScrollOffset(const ScrollOffset&amp;) override;
1104     ScrollingNodeID scrollingNodeID() const override;
1105 
1106     IntRect visibleContentRectInternal(VisibleContentRectIncludesScrollbars, VisibleContentRectBehavior) const override;
1107     IntSize overhangAmount() const override;
1108     IntPoint lastKnownMousePosition() const override;
1109     bool isHandlingWheelEvent() const override;
1110     bool shouldSuspendScrollAnimations() const override;
1111     IntRect scrollableAreaBoundingBox(bool* isInsideFixed = nullptr) const override;
1112     bool isRubberBandInProgress() const override;
1113     bool forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const override;
1114 #if ENABLE(CSS_SCROLL_SNAP)
1115     bool isScrollSnapInProgress() const override;
1116 #endif
1117     bool usesMockScrollAnimator() const override;
1118     void logMockScrollAnimatorMessage(const String&amp;) const override;
1119 
1120 #if ENABLE(IOS_TOUCH_EVENTS)
1121     void registerAsTouchEventListenerForScrolling();
1122     void unregisterAsTouchEventListenerForScrolling();
1123 #endif
1124 
1125     // Rectangle encompassing the scroll corner and resizer rect.
1126     LayoutRect scrollCornerAndResizerRect() const;
1127 
1128     // NOTE: This should only be called by the overridden setScrollOffset from ScrollableArea.
1129     void scrollTo(const ScrollPosition&amp;);
1130     void updateCompositingLayersAfterScroll();
1131 
1132     IntSize scrollbarOffset(const Scrollbar&amp;) const;
1133 
1134     void updateScrollableAreaSet(bool hasOverflow);
1135 
1136     bool allowsCurrentScroll() const;
1137 
1138     void dirtyAncestorChainVisibleDescendantStatus();
1139     void setAncestorChainHasVisibleDescendant();
1140 
1141     bool has3DTransformedDescendant() const { return m_has3DTransformedDescendant; }
1142     bool has3DTransformedAncestor() const { return m_has3DTransformedAncestor; }
1143 
1144     void dirty3DTransformedDescendantStatus();
1145     // Both updates the status, and returns true if descendants of this have 3d.
1146     bool update3DTransformedDescendantStatus();
1147 
1148     void createReflection();
1149     void removeReflection();
1150 
1151     RenderStyle createReflectionStyle();
1152     bool paintingInsideReflection() const { return m_paintingInsideReflection; }
1153     void setPaintingInsideReflection(bool b) { m_paintingInsideReflection = b; }
1154 
1155     void updateFiltersAfterStyleChange();
1156     void updateFilterPaintingStrategy();
1157 
1158 #if ENABLE(CSS_COMPOSITING)
1159     void updateAncestorChainHasBlendingDescendants();
1160     void dirtyAncestorChainHasBlendingDescendants();
1161 #endif
1162 
1163     Ref&lt;ClipRects&gt; parentClipRects(const ClipRectsContext&amp;) const;
1164     ClipRect backgroundClipRect(const ClipRectsContext&amp;) const;
1165 
1166     RenderLayer* enclosingTransformedAncestor() const;
1167 
1168     LayoutRect getRectToExpose(const LayoutRect&amp; visibleRect, const LayoutRect&amp; exposeRect, bool insideFixed, const ScrollAlignment&amp; alignX, const ScrollAlignment&amp; alignY) const;
1169 
1170     // Convert a point in absolute coords into layer coords, taking transforms into account
1171     LayoutPoint absoluteToContents(const LayoutPoint&amp;) const;
1172 
1173     void positionOverflowControls(const IntSize&amp;);
1174     void updateScrollCornerStyle();
1175     void clearScrollCorner();
1176     void updateResizerStyle();
1177     void clearResizer();
1178 
1179     void drawPlatformResizerImage(GraphicsContext&amp;, const LayoutRect&amp; resizerCornerRect);
1180 
1181     void updatePagination();
1182 
1183     void setHasCompositingDescendant(bool b)  { m_hasCompositingDescendant = b; }
1184 
1185     void setIndirectCompositingReason(IndirectCompositingReason reason) { m_indirectCompositingReason = static_cast&lt;unsigned&gt;(reason); }
1186     bool mustCompositeForIndirectReasons() const { return m_indirectCompositingReason; }
1187 
1188     LayoutUnit overflowTop() const;
1189     LayoutUnit overflowBottom() const;
1190     LayoutUnit overflowLeft() const;
1191     LayoutUnit overflowRight() const;
1192 
1193     IntRect rectForHorizontalScrollbar(const IntRect&amp; borderBoxRect) const;
1194     IntRect rectForVerticalScrollbar(const IntRect&amp; borderBoxRect) const;
1195 
1196     LayoutUnit verticalScrollbarStart(int minX, int maxX) const;
1197     LayoutUnit horizontalScrollbarStart(int minX) const;
1198 
1199     bool overflowControlsIntersectRect(const IntRect&amp; localRect) const;
1200 
1201     OptionSet&lt;Compositing&gt; m_compositingDirtyBits;
1202 
1203     const bool m_isRenderViewLayer : 1;
1204     const bool m_forcedStackingContext : 1;
1205 
1206     bool m_isNormalFlowOnly : 1;
1207     bool m_isCSSStackingContext : 1;
1208     bool m_isOpportunisticStackingContext : 1;
1209 
1210     bool m_zOrderListsDirty : 1;
1211     bool m_normalFlowListDirty: 1;
1212     bool m_hadNegativeZOrderList : 1;
1213 
1214     // Keeps track of whether the layer is currently resizing, so events can cause resizing to start and stop.
1215     bool m_inResizeMode : 1;
1216 
1217     bool m_scrollDimensionsDirty : 1;
1218     bool m_isSelfPaintingLayer : 1;
1219 
1220     // If have no self-painting descendants, we don&#39;t have to walk our children during painting. This can lead to
1221     // significant savings, especially if the tree has lots of non-self-painting layers grouped together (e.g. table cells).
1222     bool m_hasSelfPaintingLayerDescendant : 1;
1223     bool m_hasSelfPaintingLayerDescendantDirty : 1;
1224 
1225     bool m_usedTransparency : 1; // Tracks whether we need to close a transparent layer, i.e., whether
1226                                  // we ended up painting this layer or any descendants (and therefore need to
1227                                  // blend).
1228     bool m_paintingInsideReflection : 1;  // A state bit tracking if we are painting inside a replica.
1229     bool m_inOverflowRelayout : 1;
1230     unsigned m_repaintStatus : 2; // RepaintStatus
1231 
1232     bool m_visibleContentStatusDirty : 1;
1233     bool m_hasVisibleContent : 1;
1234     bool m_visibleDescendantStatusDirty : 1;
1235     bool m_hasVisibleDescendant : 1;
1236     bool m_registeredScrollableArea : 1;
1237     bool m_isFixedIntersectingViewport : 1;
1238     bool m_behavesAsFixed : 1;
1239 
1240     bool m_3DTransformedDescendantStatusDirty : 1;
1241     bool m_has3DTransformedDescendant : 1;  // Set on a stacking context layer that has 3D descendants anywhere
1242                                             // in a preserves3D hierarchy. Hint to do 3D-aware hit testing.
1243     bool m_hasCompositingDescendant : 1; // In the z-order tree.
1244 
1245     bool m_hasCompositedScrollingAncestor : 1; // In the layer-order tree.
1246     bool m_hasCompositedScrollableOverflow : 1;
1247 
1248     bool m_hasTransformedAncestor : 1;
1249     bool m_has3DTransformedAncestor : 1;
1250 
1251     unsigned m_indirectCompositingReason : 4; // IndirectCompositingReason
1252     unsigned m_viewportConstrainedNotCompositedReason : 2; // ViewportConstrainedNotCompositedReason
1253 
1254 #if PLATFORM(IOS_FAMILY)
1255 #if ENABLE(IOS_TOUCH_EVENTS)
1256     bool m_registeredAsTouchEventListenerForScrolling : 1;
1257 #endif
1258     bool m_adjustForIOSCaretWhenScrolling : 1;
1259 #endif
1260 
1261     bool m_requiresScrollPositionReconciliation : 1;
1262     bool m_containsDirtyOverlayScrollbars : 1;
1263     bool m_updatingMarqueePosition : 1;
1264 
1265 #if ASSERT_ENABLED
1266     bool m_layerListMutationAllowed : 1;
1267 #endif
1268 
1269 #if ENABLE(CSS_COMPOSITING)
1270     unsigned m_blendMode : 5; // BlendMode
1271     bool m_hasNotIsolatedCompositedBlendingDescendants : 1;
1272     bool m_hasNotIsolatedBlendingDescendants : 1;
1273     bool m_hasNotIsolatedBlendingDescendantsStatusDirty : 1;
1274 #endif
1275 
1276     RenderLayerModelObject&amp; m_renderer;
1277 
1278     RenderLayer* m_parent { nullptr };
1279     RenderLayer* m_previous { nullptr };
1280     RenderLayer* m_next { nullptr };
1281     RenderLayer* m_first { nullptr };
1282     RenderLayer* m_last { nullptr };
1283 
1284     WeakPtr&lt;RenderLayer&gt; m_backingProviderLayer;
1285 
1286     // For layers that establish stacking contexts, m_posZOrderList holds a sorted list of all the
1287     // descendant layers within the stacking context that have z-indices of 0 or greater
1288     // (auto will count as 0). m_negZOrderList holds descendants within our stacking context with negative
1289     // z-indices.
1290     std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt; m_posZOrderList;
1291     std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt; m_negZOrderList;
1292 
1293     // This list contains child layers that cannot create stacking contexts and appear in normal flow order.
1294     std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt; m_normalFlowList;
1295 
1296     // Our current relative position offset.
1297     LayoutSize m_offsetForInFlowPosition;
1298 
1299     // Our (x,y) coordinates are in our parent layer&#39;s coordinate space.
1300     LayoutPoint m_topLeft;
1301 
1302     // The layer&#39;s width/height
1303     IntSize m_layerSize;
1304 
1305     ScrollPosition m_scrollPosition;
1306     Optional&lt;ScrollPosition&gt; m_postLayoutScrollPosition;
1307 
1308     // The width/height of our scrolled area.
1309     IntSize m_scrollSize;
1310 
1311     // For layers with overflow, we have a pair of scrollbars.
1312     RefPtr&lt;Scrollbar&gt; m_hBar;
1313     RefPtr&lt;Scrollbar&gt; m_vBar;
1314 
1315     std::unique_ptr&lt;ClipRectsCache&gt; m_clipRectsCache;
1316 
1317     IntPoint m_cachedOverlayScrollbarOffset;
1318 
1319     std::unique_ptr&lt;RenderMarquee&gt; m_marquee; // Used for &lt;marquee&gt;.
1320 
1321     // Cached normal flow values for absolute positioned elements with static left/top values.
1322     LayoutUnit m_staticInlinePosition;
1323     LayoutUnit m_staticBlockPosition;
1324 
1325     std::unique_ptr&lt;TransformationMatrix&gt; m_transform;
1326 
1327     // May ultimately be extended to many replicas (with their own paint order).
1328     RenderPtr&lt;RenderReplica&gt; m_reflection;
1329 
1330     // Renderers to hold our custom scroll corner and resizer.
1331     RenderPtr&lt;RenderScrollbarPart&gt; m_scrollCorner;
1332     RenderPtr&lt;RenderScrollbarPart&gt; m_resizer;
1333 
1334     // Pointer to the enclosing RenderLayer that caused us to be paginated. It is 0 if we are not paginated.
1335     WeakPtr&lt;RenderLayer&gt; m_enclosingPaginationLayer;
1336 
1337     IntRect m_blockSelectionGapsBounds;
1338 
1339     std::unique_ptr&lt;RenderLayerFilters&gt; m_filters;
1340     std::unique_ptr&lt;RenderLayerBacking&gt; m_backing;
1341 
1342     PaintFrequencyTracker m_paintFrequencyTracker;
1343 };
1344 
1345 inline void RenderLayer::clearZOrderLists()
1346 {
1347     ASSERT(!isStackingContext());
1348     ASSERT(layerListMutationAllowed());
1349 
1350     m_posZOrderList = nullptr;
1351     m_negZOrderList = nullptr;
1352 }
1353 
1354 inline void RenderLayer::updateZOrderLists()
1355 {
1356     if (!m_zOrderListsDirty)
1357         return;
1358 
1359     if (!isStackingContext()) {
1360         clearZOrderLists();
1361         m_zOrderListsDirty = false;
1362         return;
1363     }
1364 
1365     rebuildZOrderLists();
1366 }
1367 
1368 inline RenderLayer* RenderLayer::paintOrderParent() const
1369 {
1370     return m_isNormalFlowOnly ? m_parent : stackingContext();
1371 }
1372 
1373 #if ASSERT_ENABLED
1374 class LayerListMutationDetector {
1375 public:
1376     LayerListMutationDetector(RenderLayer&amp; layer)
1377         : m_layer(layer)
1378         , m_previousMutationAllowedState(layer.layerListMutationAllowed())
1379     {
1380         m_layer.setLayerListMutationAllowed(false);
1381     }
1382 
1383     ~LayerListMutationDetector()
1384     {
1385         m_layer.setLayerListMutationAllowed(m_previousMutationAllowedState);
1386     }
1387 
1388 private:
1389     RenderLayer&amp; m_layer;
1390     bool m_previousMutationAllowedState;
1391 };
1392 #endif // ASSERT_ENABLED
1393 
1394 void makeMatrixRenderable(TransformationMatrix&amp;, bool has3DRendering);
1395 
1396 bool compositedWithOwnBackingStore(const RenderLayer&amp;);
1397 
1398 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, ClipRectsType);
1399 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const RenderLayer&amp;);
1400 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const RenderLayer::ClipRectsContext&amp;);
1401 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, IndirectCompositingReason);
1402 
1403 } // namespace WebCore
1404 
1405 #if ENABLE(TREE_DEBUGGING)
1406 // Outside the WebCore namespace for ease of invocation from lldb.
1407 void showLayerTree(const WebCore::RenderLayer*);
1408 void showPaintOrderTree(const WebCore::RenderLayer*);
1409 void showLayerTree(const WebCore::RenderObject*);
1410 #endif
    </pre>
  </body>
</html>
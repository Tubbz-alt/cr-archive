<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGResourceClipper.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../RenderLayerFilters.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderSVGResourceClipper.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGResourceClipper.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -28,18 +28,20 @@</span>
  #include &quot;FrameView.h&quot;
  #include &quot;HitTestRequest.h&quot;
  #include &quot;HitTestResult.h&quot;
  #include &quot;IntRect.h&quot;
  #include &quot;RenderObject.h&quot;
<span class="udiff-line-added">+ #include &quot;Logging.h&quot;</span>
  #include &quot;RenderStyle.h&quot;
  #include &quot;RenderView.h&quot;
  #include &quot;SVGNames.h&quot;
  #include &quot;SVGRenderingContext.h&quot;
  #include &quot;SVGResources.h&quot;
  #include &quot;SVGResourcesCache.h&quot;
  #include &quot;SVGUseElement.h&quot;
  #include &lt;wtf/IsoMallocInlines.h&gt;
<span class="udiff-line-added">+ #include &lt;wtf/text/TextStream.h&gt;</span>
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(RenderSVGResourceClipper);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -50,11 +52,11 @@</span>
  
  RenderSVGResourceClipper::~RenderSVGResourceClipper() = default;
  
  void RenderSVGResourceClipper::removeAllClientsFromCache(bool markForInvalidation)
  {
<span class="udiff-line-modified-removed">-     m_clipBoundaries = FloatRect();</span>
<span class="udiff-line-modified-added">+     m_clipBoundaries = { };</span>
      m_clipper.clear();
  
      markAllClientsForInvalidation(markForInvalidation ? LayoutAndBoundariesInvalidation : ParentOnlyInvalidation);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -68,11 +70,15 @@</span>
  bool RenderSVGResourceClipper::applyResource(RenderElement&amp; renderer, const RenderStyle&amp;, GraphicsContext*&amp; context, OptionSet&lt;RenderSVGResourceMode&gt; resourceMode)
  {
      ASSERT(context);
      ASSERT_UNUSED(resourceMode, !resourceMode);
  
<span class="udiff-line-modified-removed">-     return applyClippingToContext(renderer, renderer.objectBoundingBox(), renderer.repaintRectInLocalCoordinates(), *context);</span>
<span class="udiff-line-modified-added">+     auto repaintRect = renderer.repaintRectInLocalCoordinates();</span>
<span class="udiff-line-added">+     if (repaintRect.isEmpty())</span>
<span class="udiff-line-added">+         return true;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return applyClippingToContext(renderer, renderer.objectBoundingBox(), *context);</span>
  }
  
  bool RenderSVGResourceClipper::pathOnlyClipping(GraphicsContext&amp; context, const AffineTransform&amp; animatedLocalTransform, const FloatRect&amp; objectBoundingBox)
  {
      // If the current clip-path gets clipped itself, we have to fallback to masking.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -126,62 +132,62 @@</span>
          clipPath.addRect(FloatRect());
      context.clipPath(clipPath, clipRule);
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool RenderSVGResourceClipper::applyClippingToContext(RenderElement&amp; renderer, const FloatRect&amp; objectBoundingBox, const FloatRect&amp; repaintRect, GraphicsContext&amp; context)</span>
<span class="udiff-line-modified-added">+ bool RenderSVGResourceClipper::applyClippingToContext(RenderElement&amp; renderer, const FloatRect&amp; objectBoundingBox, GraphicsContext&amp; context)</span>
  {
<span class="udiff-line-modified-removed">-     ClipperMaskImage&amp; clipperMaskImage = addRendererToClipper(renderer);</span>
<span class="udiff-line-modified-removed">-     bool shouldCreateClipperMaskImage = !clipperMaskImage;</span>
<span class="udiff-line-modified-added">+     ClipperData&amp; clipperData = addRendererToClipper(renderer);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     LOG_WITH_STREAM(SVG, stream &lt;&lt; &quot;RenderSVGResourceClipper &quot; &lt;&lt; this &lt;&lt; &quot; applyClippingToContext: renderer &quot; &lt;&lt; &amp;renderer &lt;&lt; &quot; objectBoundingBox &quot; &lt;&lt; objectBoundingBox &lt;&lt; &quot; (existing image buffer &quot; &lt;&lt; clipperData.imageBuffer.get() &lt;&lt; &quot;)&quot;);</span>
  
      AffineTransform animatedLocalTransform = clipPathElement().animatedLocalTransform();
  
<span class="udiff-line-modified-removed">-     if (shouldCreateClipperMaskImage &amp;&amp; pathOnlyClipping(context, animatedLocalTransform, objectBoundingBox))</span>
<span class="udiff-line-modified-added">+     if (!clipperData.imageBuffer &amp;&amp; pathOnlyClipping(context, animatedLocalTransform, objectBoundingBox))</span>
          return true;
  
      AffineTransform absoluteTransform = SVGRenderingContext::calculateTransformationToOutermostCoordinateSystem(renderer);
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-     if (shouldCreateClipperMaskImage &amp;&amp; !repaintRect.isEmpty()) {</span>
<span class="udiff-line-modified-added">+     if (!clipperData.isValidForGeometry(objectBoundingBox, absoluteTransform)) {</span>
          // FIXME (149469): This image buffer should not be unconditionally unaccelerated. Making it match the context breaks nested clipping, though.
<span class="udiff-line-modified-removed">-         clipperMaskImage = SVGRenderingContext::createImageBuffer(repaintRect, absoluteTransform, ColorSpace::SRGB, RenderingMode::Unaccelerated, &amp;context);</span>
<span class="udiff-line-modified-removed">-         if (!clipperMaskImage)</span>
<span class="udiff-line-modified-added">+         auto maskImage = SVGRenderingContext::createImageBuffer(objectBoundingBox, absoluteTransform, ColorSpace::SRGB, RenderingMode::Unaccelerated, &amp;context);</span>
<span class="udiff-line-modified-added">+         if (!maskImage)</span>
              return false;
  
<span class="udiff-line-modified-removed">-         GraphicsContext&amp; maskContext = clipperMaskImage-&gt;context();</span>
<span class="udiff-line-modified-added">+         clipperData = { WTFMove(maskImage), objectBoundingBox, absoluteTransform };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         GraphicsContext&amp; maskContext = clipperData.imageBuffer-&gt;context();</span>
          maskContext.concatCTM(animatedLocalTransform);
  
          // clipPath can also be clipped by another clipPath.
          auto* resources = SVGResourcesCache::cachedResourcesForRenderer(*this);
          RenderSVGResourceClipper* clipper;
          bool succeeded;
          if (resources &amp;&amp; (clipper = resources-&gt;clipper())) {
              GraphicsContextStateSaver stateSaver(maskContext);
  
<span class="udiff-line-modified-removed">-             if (!clipper-&gt;applyClippingToContext(*this, objectBoundingBox, repaintRect, maskContext))</span>
<span class="udiff-line-modified-added">+             if (!clipper-&gt;applyClippingToContext(*this, objectBoundingBox, maskContext))</span>
                  return false;
  
<span class="udiff-line-modified-removed">-             succeeded = drawContentIntoMaskImage(clipperMaskImage, objectBoundingBox);</span>
<span class="udiff-line-modified-added">+             succeeded = drawContentIntoMaskImage(*clipperData.imageBuffer, objectBoundingBox);</span>
              // The context restore applies the clipping on non-CG platforms.
          } else
<span class="udiff-line-modified-removed">-             succeeded = drawContentIntoMaskImage(clipperMaskImage, objectBoundingBox);</span>
<span class="udiff-line-modified-added">+             succeeded = drawContentIntoMaskImage(*clipperData.imageBuffer, objectBoundingBox);</span>
  
          if (!succeeded)
<span class="udiff-line-modified-removed">-             clipperMaskImage.reset();</span>
<span class="udiff-line-modified-added">+             clipperData = { };</span>
      }
  
<span class="udiff-line-modified-removed">-     if (!clipperMaskImage)</span>
<span class="udiff-line-modified-added">+     if (!clipperData.imageBuffer)</span>
          return false;
  
<span class="udiff-line-modified-removed">-     SVGRenderingContext::clipToImageBuffer(context, absoluteTransform, repaintRect, clipperMaskImage, shouldCreateClipperMaskImage);</span>
<span class="udiff-line-modified-added">+     SVGRenderingContext::clipToImageBuffer(context, absoluteTransform, objectBoundingBox, clipperData.imageBuffer, true);</span>
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool RenderSVGResourceClipper::drawContentIntoMaskImage(const ClipperMaskImage&amp; clipperMaskImage, const FloatRect&amp; objectBoundingBox)</span>
<span class="udiff-line-modified-added">+ bool RenderSVGResourceClipper::drawContentIntoMaskImage(ImageBuffer&amp; maskImageBuffer, const FloatRect&amp; objectBoundingBox)</span>
  {
<span class="udiff-line-modified-removed">-     ASSERT(clipperMaskImage);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     GraphicsContext&amp; maskContext = clipperMaskImage-&gt;context();</span>
<span class="udiff-line-modified-added">+     GraphicsContext&amp; maskContext = maskImageBuffer.context();</span>
  
      AffineTransform maskContentTransformation;
      if (clipPathElement().clipPathUnits() == SVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX) {
          maskContentTransformation.translate(objectBoundingBox.location());
          maskContentTransformation.scale(objectBoundingBox.size());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -227,11 +233,11 @@</span>
          maskContext.setFillRule(newClipRule);
  
          // In the case of a &lt;use&gt; element, we obtained its renderere above, to retrieve its clipRule.
          // We have to pass the &lt;use&gt; renderer itself to renderSubtreeToImageBuffer() to apply it&#39;s x/y/transform/etc. values when rendering.
          // So if isUseElement is true, refetch the childNode-&gt;renderer(), as renderer got overridden above.
<span class="udiff-line-modified-removed">-         SVGRenderingContext::renderSubtreeToImageBuffer(clipperMaskImage.get(), isUseElement ? *child.renderer() : *renderer, maskContentTransformation);</span>
<span class="udiff-line-modified-added">+         SVGRenderingContext::renderSubtreeToImageBuffer(&amp;maskImageBuffer, isUseElement ? *child.renderer() : *renderer, maskContentTransformation);</span>
      }
  
      view().frameView().setPaintBehavior(oldBehavior);
      return true;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -251,13 +257,13 @@</span>
          m_clipBoundaries.unite(renderer-&gt;localToParentTransform().mapRect(renderer-&gt;repaintRectInLocalCoordinates()));
      }
      m_clipBoundaries = clipPathElement().animatedLocalTransform().mapRect(m_clipBoundaries);
  }
  
<span class="udiff-line-modified-removed">- ClipperMaskImage&amp; RenderSVGResourceClipper::addRendererToClipper(const RenderObject&amp; object)</span>
<span class="udiff-line-modified-added">+ RenderSVGResourceClipper::ClipperData&amp; RenderSVGResourceClipper::addRendererToClipper(const RenderObject&amp; object)</span>
  {
<span class="udiff-line-modified-removed">-     return m_clipper.add(&amp;object, ClipperMaskImage()).iterator-&gt;value;</span>
<span class="udiff-line-modified-added">+     return m_clipper.add(&amp;object, ClipperData()).iterator-&gt;value;</span>
  }
  
  bool RenderSVGResourceClipper::hitTestClipContent(const FloatRect&amp; objectBoundingBox, const FloatPoint&amp; nodeAtPoint)
  {
      FloatPoint point = nodeAtPoint;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -300,11 +306,11 @@</span>
  
  FloatRect RenderSVGResourceClipper::resourceBoundingBox(const RenderObject&amp; object)
  {
      // Resource was not layouted yet. Give back the boundingBox of the object.
      if (selfNeedsLayout()) {
<span class="udiff-line-modified-removed">-         addRendererToClipper(object);</span>
<span class="udiff-line-modified-added">+         addRendererToClipper(object); // For selfNeedsClientInvalidation().</span>
          return object.objectBoundingBox();
      }
  
      if (m_clipBoundaries.isEmpty())
          calculateClipContentRepaintRect();
</pre>
<center><a href="../RenderLayerFilters.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderSVGResourceClipper.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
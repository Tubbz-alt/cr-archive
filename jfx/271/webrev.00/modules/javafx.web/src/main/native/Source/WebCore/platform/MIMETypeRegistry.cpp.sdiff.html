<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/MIMETypeRegistry.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../page/scrolling/nicosia/ScrollingTreeOverflowScrollingNodeNicosia.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MIMETypeRegistry.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/MIMETypeRegistry.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
622         return true;
623 
624     if (!mimeType.endsWithIgnoringASCIICase(&quot;+xml&quot;))
625         return false;
626 
627     size_t slashPosition = mimeType.find(&#39;/&#39;);
628     // Take into account the &#39;+xml&#39; ending of mimeType.
629     if (slashPosition == notFound || !slashPosition || slashPosition == mimeType.length() - 5)
630         return false;
631 
632     // Again, mimeType ends with &#39;+xml&#39;, no need to check the validity of that substring.
633     size_t mimeLength = mimeType.length();
634     for (size_t i = 0; i &lt; mimeLength - 4; ++i) {
635         if (!isValidXMLMIMETypeChar(mimeType[i]) &amp;&amp; i != slashPosition)
636             return false;
637     }
638 
639     return true;
640 }
641 






642 bool MIMETypeRegistry::isJavaAppletMIMEType(const String&amp; mimeType)
643 {
644     // Since this set is very limited and is likely to remain so we won&#39;t bother with the overhead
645     // of using a hash set.
646     // Any of the MIME types below may be followed by any number of specific versions of the JVM,
647     // which is why we use startsWith()
648     return startsWithLettersIgnoringASCIICase(mimeType, &quot;application/x-java-applet&quot;)
649         || startsWithLettersIgnoringASCIICase(mimeType, &quot;application/x-java-bean&quot;)
650         || startsWithLettersIgnoringASCIICase(mimeType, &quot;application/x-java-vm&quot;);
651 }
652 
653 bool MIMETypeRegistry::isPDFMIMEType(const String&amp; mimeType)
654 {
655     if (mimeType.isEmpty())
656         return false;
657     return pdfMIMETypes().contains(mimeType);
658 }
659 
660 bool MIMETypeRegistry::isPostScriptMIMEType(const String&amp; mimeType)
661 {
</pre>
</td>
<td>
<hr />
<pre>
622         return true;
623 
624     if (!mimeType.endsWithIgnoringASCIICase(&quot;+xml&quot;))
625         return false;
626 
627     size_t slashPosition = mimeType.find(&#39;/&#39;);
628     // Take into account the &#39;+xml&#39; ending of mimeType.
629     if (slashPosition == notFound || !slashPosition || slashPosition == mimeType.length() - 5)
630         return false;
631 
632     // Again, mimeType ends with &#39;+xml&#39;, no need to check the validity of that substring.
633     size_t mimeLength = mimeType.length();
634     for (size_t i = 0; i &lt; mimeLength - 4; ++i) {
635         if (!isValidXMLMIMETypeChar(mimeType[i]) &amp;&amp; i != slashPosition)
636             return false;
637     }
638 
639     return true;
640 }
641 
<span class="line-added">642 bool MIMETypeRegistry::isXMLEntityMIMEType(StringView mimeType)</span>
<span class="line-added">643 {</span>
<span class="line-added">644     return equalLettersIgnoringASCIICase(mimeType, &quot;text/xml-external-parsed-entity&quot;)</span>
<span class="line-added">645         || equalLettersIgnoringASCIICase(mimeType, &quot;application/xml-external-parsed-entity&quot;);</span>
<span class="line-added">646 }</span>
<span class="line-added">647 </span>
648 bool MIMETypeRegistry::isJavaAppletMIMEType(const String&amp; mimeType)
649 {
650     // Since this set is very limited and is likely to remain so we won&#39;t bother with the overhead
651     // of using a hash set.
652     // Any of the MIME types below may be followed by any number of specific versions of the JVM,
653     // which is why we use startsWith()
654     return startsWithLettersIgnoringASCIICase(mimeType, &quot;application/x-java-applet&quot;)
655         || startsWithLettersIgnoringASCIICase(mimeType, &quot;application/x-java-bean&quot;)
656         || startsWithLettersIgnoringASCIICase(mimeType, &quot;application/x-java-vm&quot;);
657 }
658 
659 bool MIMETypeRegistry::isPDFMIMEType(const String&amp; mimeType)
660 {
661     if (mimeType.isEmpty())
662         return false;
663     return pdfMIMETypes().contains(mimeType);
664 }
665 
666 bool MIMETypeRegistry::isPostScriptMIMEType(const String&amp; mimeType)
667 {
</pre>
</td>
</tr>
</table>
<center><a href="../page/scrolling/nicosia/ScrollingTreeOverflowScrollingNodeNicosia.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MIMETypeRegistry.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
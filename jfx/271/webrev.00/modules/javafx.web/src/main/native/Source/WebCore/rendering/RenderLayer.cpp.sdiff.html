<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderBlock.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
4397         windRule = clipPath.windRule();
4398         return clipPath.pathForReferenceRect(referenceBox);
4399     }
4400 
4401     if (is&lt;BoxClipPathOperation&gt;(*style.clipPath()) &amp;&amp; is&lt;RenderBox&gt;(renderer())) {
4402 
4403         auto&amp; clipPath = downcast&lt;BoxClipPathOperation&gt;(*style.clipPath());
4404 
4405         FloatRoundedRect shapeRect = computeRoundedRectForBoxShape(clipPath.referenceBox(), downcast&lt;RenderBox&gt;(renderer())).pixelSnappedRoundedRectForPainting(deviceSaleFactor);
4406         shapeRect.move(offsetFromRoot);
4407 
4408         windRule = WindRule::NonZero;
4409         return clipPath.pathForReferenceRect(shapeRect);
4410     }
4411 
4412     return Path();
4413 }
4414 
4415 bool RenderLayer::setupClipPath(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed)
4416 {
<span class="line-modified">4417     if (!renderer().hasClipPath() || context.paintingDisabled())</span>
4418         return false;
4419 
4420     if (!rootRelativeBoundsComputed) {
4421         rootRelativeBounds = calculateLayerBounds(paintingInfo.rootLayer, offsetFromRoot, { });
4422         rootRelativeBoundsComputed = true;
4423     }
4424 
4425     // SVG elements get clipped in SVG code.
4426     if (is&lt;RenderSVGRoot&gt;(renderer()))
4427         return false;
4428 
4429     auto&amp; style = renderer().style();
4430     LayoutSize paintingOffsetFromRoot = LayoutSize(snapSizeToDevicePixel(offsetFromRoot + paintingInfo.subpixelOffset, LayoutPoint(), renderer().document().deviceScaleFactor()));
4431     ASSERT(style.clipPath());
4432     if (is&lt;ShapeClipPathOperation&gt;(*style.clipPath()) || (is&lt;BoxClipPathOperation&gt;(*style.clipPath()) &amp;&amp; is&lt;RenderBox&gt;(renderer()))) {
4433         WindRule windRule;
4434         Path path = computeClipPath(paintingOffsetFromRoot, rootRelativeBounds, windRule);
4435         context.save();
4436         context.clipPath(path, windRule);
4437         return true;
4438     }
4439 
4440     if (style.clipPath()-&gt;type() == ClipPathOperation::Reference) {
4441         ReferenceClipPathOperation* referenceClipPathOperation = static_cast&lt;ReferenceClipPathOperation*&gt;(style.clipPath());
4442         Element* element = renderer().document().getElementById(referenceClipPathOperation-&gt;fragment());
4443         if (element &amp;&amp; element-&gt;renderer() &amp;&amp; is&lt;RenderSVGResourceClipper&gt;(element-&gt;renderer())) {
4444             context.save();
<span class="line-modified">4445             float deviceSaleFactor = renderer().document().deviceScaleFactor();</span>
<span class="line-modified">4446             FloatRect referenceBox = snapRectToDevicePixels(computeReferenceBox(renderer(), CSSBoxType::ContentBox, paintingOffsetFromRoot, rootRelativeBounds), deviceSaleFactor);</span>
<span class="line-removed">4447             FloatPoint offset {referenceBox.location()};</span>
4448             context.translate(offset);
<span class="line-modified">4449             FloatRect svgReferenceBox {FloatPoint(), referenceBox.size()};</span>
<span class="line-modified">4450             downcast&lt;RenderSVGResourceClipper&gt;(*element-&gt;renderer()).applyClippingToContext(renderer(), svgReferenceBox, paintingInfo.paintDirtyRect, context);</span>
<span class="line-modified">4451             context.translate(FloatPoint(-offset.x(), -offset.y()));</span>
4452             return true;
4453         }
4454     }
4455 
4456     return false;
4457 }
4458 
4459 RenderLayerFilters* RenderLayer::filtersForPainting(GraphicsContext&amp; context, OptionSet&lt;PaintLayerFlag&gt; paintFlags) const
4460 {
4461     if (context.paintingDisabled())
4462         return nullptr;
4463 
4464     if (paintFlags &amp; PaintLayerPaintingOverlayScrollbars)
4465         return nullptr;
4466 
4467     if (!paintsWithFilters())
4468         return nullptr;
4469 
4470     if (m_filters &amp;&amp; m_filters-&gt;filter())
4471         return m_filters.get();
</pre>
<hr />
<pre>
6894     // RenderLayerFilters is only used to render the filters in software mode,
6895     // so we always need to run updateFilterPaintingStrategy() after the composited
6896     // mode might have changed for this layer.
6897     if (!paintsWithFilters()) {
6898         // Don&#39;t delete the whole filter info here, because we might use it
6899         // for loading SVG reference filter files.
6900         if (m_filters)
6901             m_filters-&gt;setFilter(nullptr);
6902 
6903         // Early-return only if we *don&#39;t* have reference filters.
6904         // For reference filters, we still want the FilterEffect graph built
6905         // for us, even if we&#39;re composited.
6906         if (!renderer().style().filter().hasReferenceFilter())
6907             return;
6908     }
6909 
6910     ensureLayerFilters();
6911     m_filters-&gt;buildFilter(renderer(), page().deviceScaleFactor(), renderer().settings().acceleratedFiltersEnabled() ? RenderingMode::Accelerated : RenderingMode::Unaccelerated);
6912 }
6913 
<span class="line-removed">6914 void RenderLayer::filterNeedsRepaint()</span>
<span class="line-removed">6915 {</span>
<span class="line-removed">6916     // We use the enclosing element so that we recalculate style for the ancestor of an anonymous object.</span>
<span class="line-removed">6917     if (Element* element = enclosingElement()) {</span>
<span class="line-removed">6918         // FIXME: This really shouldn&#39;t have to invalidate layer composition, but tests like css3/filters/effect-reference-delete.html fail if that doesn&#39;t happen.</span>
<span class="line-removed">6919         element-&gt;invalidateStyleAndLayerComposition();</span>
<span class="line-removed">6920     }</span>
<span class="line-removed">6921     renderer().repaint();</span>
<span class="line-removed">6922 }</span>
<span class="line-removed">6923 </span>
6924 IntOutsets RenderLayer::filterOutsets() const
6925 {
6926     if (m_filters)
6927         return m_filters-&gt;filter() ? m_filters-&gt;filter()-&gt;outsets() : IntOutsets();
6928     return renderer().style().filterOutsets();
6929 }
6930 
6931 bool RenderLayer::isTransparentRespectingParentFrames() const
6932 {
6933     static const double minimumVisibleOpacity = 0.01;
6934 
6935     float currentOpacity = 1;
6936     for (auto* layer = this; layer; layer = parentLayerCrossFrame(*layer)) {
6937         currentOpacity *= layer-&gt;renderer().style().opacity();
6938         if (currentOpacity &lt; minimumVisibleOpacity)
6939             return true;
6940     }
6941 
6942     return false;
6943 }
</pre>
</td>
<td>
<hr />
<pre>
4397         windRule = clipPath.windRule();
4398         return clipPath.pathForReferenceRect(referenceBox);
4399     }
4400 
4401     if (is&lt;BoxClipPathOperation&gt;(*style.clipPath()) &amp;&amp; is&lt;RenderBox&gt;(renderer())) {
4402 
4403         auto&amp; clipPath = downcast&lt;BoxClipPathOperation&gt;(*style.clipPath());
4404 
4405         FloatRoundedRect shapeRect = computeRoundedRectForBoxShape(clipPath.referenceBox(), downcast&lt;RenderBox&gt;(renderer())).pixelSnappedRoundedRectForPainting(deviceSaleFactor);
4406         shapeRect.move(offsetFromRoot);
4407 
4408         windRule = WindRule::NonZero;
4409         return clipPath.pathForReferenceRect(shapeRect);
4410     }
4411 
4412     return Path();
4413 }
4414 
4415 bool RenderLayer::setupClipPath(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed)
4416 {
<span class="line-modified">4417     if (!renderer().hasClipPath() || context.paintingDisabled() || paintingInfo.paintDirtyRect.isEmpty())</span>
4418         return false;
4419 
4420     if (!rootRelativeBoundsComputed) {
4421         rootRelativeBounds = calculateLayerBounds(paintingInfo.rootLayer, offsetFromRoot, { });
4422         rootRelativeBoundsComputed = true;
4423     }
4424 
4425     // SVG elements get clipped in SVG code.
4426     if (is&lt;RenderSVGRoot&gt;(renderer()))
4427         return false;
4428 
4429     auto&amp; style = renderer().style();
4430     LayoutSize paintingOffsetFromRoot = LayoutSize(snapSizeToDevicePixel(offsetFromRoot + paintingInfo.subpixelOffset, LayoutPoint(), renderer().document().deviceScaleFactor()));
4431     ASSERT(style.clipPath());
4432     if (is&lt;ShapeClipPathOperation&gt;(*style.clipPath()) || (is&lt;BoxClipPathOperation&gt;(*style.clipPath()) &amp;&amp; is&lt;RenderBox&gt;(renderer()))) {
4433         WindRule windRule;
4434         Path path = computeClipPath(paintingOffsetFromRoot, rootRelativeBounds, windRule);
4435         context.save();
4436         context.clipPath(path, windRule);
4437         return true;
4438     }
4439 
4440     if (style.clipPath()-&gt;type() == ClipPathOperation::Reference) {
4441         ReferenceClipPathOperation* referenceClipPathOperation = static_cast&lt;ReferenceClipPathOperation*&gt;(style.clipPath());
4442         Element* element = renderer().document().getElementById(referenceClipPathOperation-&gt;fragment());
4443         if (element &amp;&amp; element-&gt;renderer() &amp;&amp; is&lt;RenderSVGResourceClipper&gt;(element-&gt;renderer())) {
4444             context.save();
<span class="line-modified">4445             auto referenceBox = snapRectToDevicePixels(rootRelativeBounds, renderer().document().deviceScaleFactor());</span>
<span class="line-modified">4446             auto offset = referenceBox.location();</span>

4447             context.translate(offset);
<span class="line-modified">4448             FloatRect svgReferenceBox { {}, referenceBox.size() };</span>
<span class="line-modified">4449             downcast&lt;RenderSVGResourceClipper&gt;(*element-&gt;renderer()).applyClippingToContext(renderer(), svgReferenceBox, context);</span>
<span class="line-modified">4450             context.translate(-offset);</span>
4451             return true;
4452         }
4453     }
4454 
4455     return false;
4456 }
4457 
4458 RenderLayerFilters* RenderLayer::filtersForPainting(GraphicsContext&amp; context, OptionSet&lt;PaintLayerFlag&gt; paintFlags) const
4459 {
4460     if (context.paintingDisabled())
4461         return nullptr;
4462 
4463     if (paintFlags &amp; PaintLayerPaintingOverlayScrollbars)
4464         return nullptr;
4465 
4466     if (!paintsWithFilters())
4467         return nullptr;
4468 
4469     if (m_filters &amp;&amp; m_filters-&gt;filter())
4470         return m_filters.get();
</pre>
<hr />
<pre>
6893     // RenderLayerFilters is only used to render the filters in software mode,
6894     // so we always need to run updateFilterPaintingStrategy() after the composited
6895     // mode might have changed for this layer.
6896     if (!paintsWithFilters()) {
6897         // Don&#39;t delete the whole filter info here, because we might use it
6898         // for loading SVG reference filter files.
6899         if (m_filters)
6900             m_filters-&gt;setFilter(nullptr);
6901 
6902         // Early-return only if we *don&#39;t* have reference filters.
6903         // For reference filters, we still want the FilterEffect graph built
6904         // for us, even if we&#39;re composited.
6905         if (!renderer().style().filter().hasReferenceFilter())
6906             return;
6907     }
6908 
6909     ensureLayerFilters();
6910     m_filters-&gt;buildFilter(renderer(), page().deviceScaleFactor(), renderer().settings().acceleratedFiltersEnabled() ? RenderingMode::Accelerated : RenderingMode::Unaccelerated);
6911 }
6912 










6913 IntOutsets RenderLayer::filterOutsets() const
6914 {
6915     if (m_filters)
6916         return m_filters-&gt;filter() ? m_filters-&gt;filter()-&gt;outsets() : IntOutsets();
6917     return renderer().style().filterOutsets();
6918 }
6919 
6920 bool RenderLayer::isTransparentRespectingParentFrames() const
6921 {
6922     static const double minimumVisibleOpacity = 0.01;
6923 
6924     float currentOpacity = 1;
6925     for (auto* layer = this; layer; layer = parentLayerCrossFrame(*layer)) {
6926         currentOpacity *= layer-&gt;renderer().style().opacity();
6927         if (currentOpacity &lt; minimumVisibleOpacity)
6928             return true;
6929     }
6930 
6931     return false;
6932 }
</pre>
</td>
</tr>
</table>
<center><a href="RenderBlock.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>